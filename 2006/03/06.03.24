00:03:23 <dons> ibid, hmm. you might be right.
00:08:14 <robokop> how do i do something like getChar but then without echoing the char
00:09:41 <audreyt> @type hSetEcho
00:09:42 <lambdabot> Not in scope: `hSetEcho'
00:09:48 <audreyt> @index hSetEcho
00:09:48 <lambdabot> System.IO
00:09:59 <audreyt> @type System.IO.hSetEcho
00:10:00 <lambdabot> GHC.IOBase.Handle -> Bool -> IO ()
00:10:04 <audreyt> there you go
00:15:38 <robokop> thanks got it working
00:18:55 <audreyt> np :)
00:23:01 * shapr boings
00:27:36 <ProfTeggy> Moin
00:28:57 <shapr> good morning!
00:43:24 <adu> morning
00:48:02 <shapr> \yow -> excitement!
00:48:02 <lambdabot> Yow!  I'm having a quadrophonic sensation of two winos alone in a steel
00:48:02 <lambdabot> mill!
00:48:33 <lammell> why does not haskell accept "(+) (+) 1 2 3"
00:48:53 <shapr> \lambda joy "1 2 3 + +"
00:48:54 <lambdabot> [6]
00:49:14 <ProfTeggy> (+) ((+) 1 2) 3
00:49:17 <shapr> lammell: Right associative
00:49:30 <lammell> left assoc
00:49:33 <shapr> er, right
00:49:34 <shapr> doh
00:49:54 <lammell> Is this a matter of left assoc of application or of precedence ?
00:50:08 <lammell> for example, in general, what is    f g h x
00:50:29 <lammell> it ought to be ((f g) h) x
00:50:32 <lammell> for left assoc
00:50:36 <ProfTeggy> It is
00:50:37 <shapr> Left associative application, when you have the same operators.
00:50:49 <shapr> Precedence can make a difference, thus the use of $
00:51:06 <lammell> $ reverses associativity in a vague sense
00:51:11 <ProfTeggy> Juxtaposition binds tightest and is left assoc.
00:51:17 <lammell> (that was a question)
00:51:19 <shapr> $ reduces precedence.
00:51:32 <lammell> f $ g $ h $ x   works as well
00:51:45 <shapr> $ is a low precedence application operator.
00:52:04 <lammell> but we have multiple $:ars so precedence can not be the issue?
00:52:10 <lammell> they all have the same precedence here, I mean
00:52:18 <ProfTeggy> $ associates to the right
00:52:24 <lammell> clear
00:52:30 <ProfTeggy> infixr 0 $
00:52:43 <lammell> so it has two properties.
00:52:46 <lammell> ?
00:52:57 <ProfTeggy> right assoc and low precedence (0)
00:53:04 <lammell> grat.
00:53:06 <lammell> great.
00:53:11 <lammell> another queston:
00:53:23 <lammell> why is seq built in and not defined like in Bird's textbook
00:53:35 <lammell> strict x f = if x == undefined then undefined else f x 
00:54:00 <lammell> (== does not work for functional arguments?)
00:54:13 <lammell> _is_ it the same functions on ground types?
00:55:35 <ProfTeggy> Type constructor -> is not a member of class Eq, thus equality does not work on values of function types
00:55:46 <ProfTeggy> (How could it be?)
00:55:55 <dblhelix> lammell: not sure, but I think Bird's definition is intended as pseudocode and just there to illustrate what strict does... in Haskell, use (==) to check for equality
00:56:07 <dblhelix> of bottoms
00:59:47 <lammell> ok, so it seems that seq is strict but for function types too.
00:59:53 <lammell> how can it be built-in even?
01:00:05 <lammell> oh, it probably can, sorry.
01:02:02 <lammell> btw, is macro application left associative in LaTeX / TeX too?
01:02:52 <ProfTeggy> TeX \defs are mixfix, in general
01:03:00 <ProfTeggy> So your question makes not much sense
01:03:56 <ProfTeggy> The interaction of TeX's mouth and stomach is not easily described in an IRC session.
01:03:58 <ibid> latex has no infix operators, so there's no associativity question
01:04:13 <ProfTeggy> I propose you watch Don Knuth's video-taped lecture on TeX 82 internals
01:04:22 <ProfTeggy> lectures, even
01:59:50 <mikezs> What dpes the error: Missing binding for variable "createIndividual" in type signature mean?
02:07:17 <Saulzar> mikezs, Not sure - what was the code/error?
02:09:22 <mikezs> i fixed it now, was a typo :)
02:52:43 <dcoutts> ibid, I was hoping we could add the gtk2hs rss feed to planet.haskell.org
02:53:08 <dcoutts> ibid, I'll email the details
03:03:27 <chrisbrown> dcoutts: what kind of blogs should go onto planet.haskell.org? 
03:03:46 <dcoutts> chrisbrown, personal & project related I think
03:03:53 <dcoutts> ask ibid for sure
03:03:59 <chrisbrown> a PhD blog?
03:04:00 <chrisbrown> ok
03:04:45 <chrisbrown> ibid: would a blog about my PhD work in haskell refactoring be suitable to go onto planet.haskell.org?
03:15:42 <chrisbrown> has anyone here have experience of building GHC 6.5 on mac os x?
03:15:45 <dcoutts> dons, is your email address on http://www.haskell.org/haskellwiki/HWN correct?
03:16:32 <dcoutts> dons, looks to be missing an edu
03:19:59 <ibid> chrisbrown: certainly
03:20:20 <chrisbrown> ibid: do you need the url for my blog?
03:21:14 <ibid> i'm following the planet debian policy, with some tweaks: haskell people's english blogs (not necessarily restricted to just haskell stuff), plus selected other haskell-related feeds (like HWN)
03:21:24 <ibid> chrisbrown: a RSS/Atom feed, yes
03:21:58 <chrisbrown> ibid: would you like me to email you that?
03:24:20 <ibid> yes
03:24:29 <chrisbrown> what is your email address?
03:24:37 <ibid> antti-juhani@kaijanaho.fi
03:25:06 <chrisbrown> thanks
03:25:59 <ibid> note that it's not yet planet.haskell.org, i'm just hoping it will become that :)
03:26:33 <chrisbrown> yeah i appreciate that, its a good idea though
03:30:23 <ibid> chrisbrown: do you mind if i use your name as the feed name in planet?
03:30:34 <chrisbrown> sure
03:30:42 <chrisbrown> i mean i dont mind
03:31:24 <ibid> added
03:31:27 <ibid> dcoutts: added
03:32:15 <ibid> http://antti-juhani.kaijanaho.fi/planet-haskell/
03:33:17 <chrisbrown> oh cool thanks
03:33:29 <shapr> oh me too!
03:34:54 <ibid> shapr: i need a feed url that you deem to fit the policy i outlined above :)
03:36:11 <shapr> Well, I have only an english blog, and it's mostly haskell and type theory, so...
03:36:23 <shapr> http://www.scannedinavian.com/plog.rss
03:36:41 <dcoutts> ibid, thanks
03:37:09 <shapr> Speaking of which, I should really rsync my recent entries.
03:37:29 <shapr> akemp: Hey, did you look at fix, mfix, loop, etc?
03:37:47 <shapr> @seen akemp
03:37:48 <lambdabot> akemp is in #haskell. Last spoke 1 day, 5 hours, 8 minutes and 23 seconds ago.
03:39:36 <ibid> shapr: added, it will pick it up in 20 mins
03:39:37 <shapr> Oh hey, I found a neat data point about how culture affects language.
03:39:45 <shapr> um
03:40:26 <shapr> Science News had an article about a tribe of isolated villagers in Brazil that don't have recursion, indirection, etc in their language.
03:40:39 <shapr> They can't count, can't read, and are totally unable to refer to time.
03:41:44 <shapr> It took the researcher seven years or so to learn their language well enough to communicate effectively, after which he started evening classes in math and literacy.
03:41:48 <Saulzar> Teach them haskell then? :)
03:42:13 <shapr> After seven months, they finally learned that 1+1 = 2, after which they all walked out and did not come back.
03:43:02 <Maddas> heh!
03:43:03 <shapr> The whole story is really cool, but the results say that culture affects language dramatically, which totally goes against current theories.
03:43:42 <shapr> Basically, the Piraha tribe approach to life and conversation is that you should not refer to something that is not your own experience.
03:44:08 <shapr> They have only two tenses, 1. things that are directly in my perception and 2. things that are not
03:45:25 <shapr> This fits together with a bunch of pieces I've seen recently, leading me to the conclusion that the culture around something is often more important than the something itself.
03:45:42 <cpatrick> Yes and no
03:45:52 <shapr> Look at the Erlang guys who wrote the bitstream benchmark recently.
03:45:56 <cpatrick> I remember reading somewhere (The Language Instinct?) that claims that languages "don't have" some concept
03:46:16 <cpatrick> are often the result of sociologists misinterpreting the people they're trying to study
03:46:26 <Maddas> The language log?
03:46:37 <shapr> cpatrick: That is discussed in more detail in the article I read.
03:46:54 <cpatrick> Maddas: no, a physical book by Stephen Pinker
03:46:59 <Maddas> Oh, ok.
03:47:11 <shapr> Two other researchers have spent less time learning this language (two or five years, I think), and they came to different conclusions.
03:47:25 <cpatrick> shapr: ooh, interesting - do you have a URL / reference for the article?
03:47:42 <Maddas> shapr: Reminds me of the 'communication is the source of all misunderstanding' quote (:
03:47:43 <shapr> But one of them later agreed with the original article after talking to the guy who had seven years experience.
03:48:03 <shapr> The third researcher said something along the lines of "you're all full of it!"
03:48:24 <Maddas> Heh. Maybe he had something going with an opposing tribe!
03:48:36 <shapr> cpatrick: You should subscribe to sciencenews.org, they're great.
03:50:01 <shapr> Funny thing is that the tribe only allowed researchers in so that they could stop being cheated by their neighbors.
03:50:13 <Maddas> Haha.
03:50:27 <Maddas> shapr: Do they have any free subscription or were you referring to the magazine subscription?
03:50:35 <shapr> Being unable to count, they never knew whether they were getting the agreed upon price for a bunch of palm nuts.
03:50:45 <Maddas> shapr: Sounds very interesting.
03:51:13 <shapr> I have a paid subscription to sciencenews.org, but many of their articles are freely available on the web. I'll see if this one is.
03:51:26 <Maddas> Thanks.
03:53:44 <shapr> http://www.sciencenews.org/articles/20051210/bob8.asp
03:53:50 <shapr> I dunno if it's freely available though.
03:55:37 <shapr> The crux of the matter is "Pirahã problems with reading, writing, and arithmetic stemmed not from slow-wittedness but from a cultural conviction about how to converse, Everett proposes. From the villagers' perspective, talking should concern only knowledge based on one's personal, immediate experience. No Pirahã refers to abstract concepts or to distant places and times."
03:56:10 <cpatrick> shapr: cool, thanks ... it's not freely available but my uni has a subscription 
03:57:02 <pengo> language instinct said you could communicate any concept to anyone even if they didn't have words for it
03:57:31 <cpatrick> pengo: kinda...that's the sapir-whorf hypothesis IIRC
03:57:42 <pengo> sounds right
03:58:40 <shapr> Anyway, this is just the lead up to my totally on-topic thought...
03:58:53 <shapr> The Haskell culture is to produce beautiful elegant code.
03:59:36 <shapr> A coupla days ago dons said, "<dons> pure haskell is simple and easy, and the bits that model imperative/impure langs should feel icky"
04:00:05 <shapr> If you look at the later work of the original Haskell community, you see the same sort of culture.
04:01:25 <cpatrick> I don't think I've reached Haskell Zen in that case (heck, I know I haven't)
04:01:26 <shapr> dons himself is an interesting point in case (good thing he's asleep now, eh?) since he is able to do lots of mutable things to get amazingly fast code, and still prefers pure haskell.
04:01:48 <cpatrick> often it seems really hard to express things in pure haskell
04:01:54 * shapr wonders where he's going with this...
04:02:23 <shapr> cpatrick: That changed for me after a few months.
04:02:43 <shapr> When I got to the point where it was easier to do pure Haskell than pure Python, I knew I was there :-)
04:02:57 * cpatrick grins
04:03:24 <shapr> But I realize that all the crazy mutable code that dons produces is still 'pure Haskell' with optimizations added.
04:04:00 <shapr> I'mnot really sure what conclusion to draw from this, but it is a fascinating data point.
04:04:06 <musasabi> finding the right combinators and isolating the dirty bits works frequently.
04:04:22 <ibid> shapr: hrm your feed is rather boring, canÃ¤t you get the actual text in?
04:04:46 <shapr> ibid: Not without rewriting PLog :-( thus my interest in Oleg's HSXML
04:05:08 <shapr> I've made a few stabs at rewriting PLog, but always got frustrated and gave up.
04:05:24 <shapr> ibid: You can pull my feed until I get HSXML working, how about that?
04:05:27 * shapr feels motivation!
04:06:02 <shapr> musasabi: Yeah, but still that's a cultural goal. Look at random PHP source for contrast...
04:07:25 <shapr> This is definitely my favorite programming culture out of all the ones I've seen so far.
04:07:50 <Maddas> shapr: But then again, consider the motivation of the average PHP programmer and the motivation of the average Haskell programmer.
04:07:52 <shapr> I like the balance of beauty and functionality as evidenced by the code produced by dons and others.
04:08:02 <shapr> Maddas: How so?
04:08:25 <shapr> I produce web pages for a living, as does the average PHP programmer.
04:08:26 <Saulzar> Well, those goals are more or less the goals of software engineering in general
04:08:27 <Maddas> I think there are a lot more people just writing PHP code as, well, just a job. You need some motivation to even beginn with Haskell :-)
04:08:47 <sieni> PHP programmer has an inexplicable urge for obtaining maximal pain from programming?
04:09:09 <shapr> Maddas: That comes back to the first point in "The Pragmatic Programmer" : "Care about your craft"
04:09:12 <flux__> who knows, but "hello world" is a lot simpler in php than in haskell :)
04:09:20 <Maddas> Right
04:09:25 <Maddas> flux__: Is it?
04:09:26 <cpatrick> flux__: mm?
04:09:29 <chrisbrown> f = "hello world"
04:09:30 <flux__> didn't I just write it
04:09:31 <cpatrick> main = putStrLn "hello world"
04:09:32 <Saulzar> Average PHP programmer possibly hasn't done any other programming at all, knows html and snippets of PHP off websites
04:09:32 * Maddas leaves
04:09:40 <shapr> Maddas: Could that be called a cultural difference as well?
04:09:44 <flux__> hello-world program in pgp is hello world?
04:09:48 <flux__> php even
04:10:30 <shapr> Saulzar: Yeah, but if what Maddas suggests is correct, that's because they don't care enough to improve.
04:10:32 <dcoutts> hey vincenz, how was the appointment and the rb tree screenshot? :-)
04:10:59 <shapr> Self-improvement as a programmer is extremely accessible, even more so if you build websites for a living.
04:11:15 <Saulzar> shapr, They only care enough to want to write websites. For a fair comparison Java or C++ is much more reasonable, and there are certainly people who strive to make elegant code in those languages :)
04:11:56 <tic> shapr, what do you mean by self-improvement being extremely accessible?
04:12:09 <cpatrick> These days the elegant-code-for-web-sites crowd seem to hover around Ruby On Snails and Django
04:12:33 <tic> RoR = initial bootstrap, but then not much.
04:12:35 <shapr> Yes, that's true. Though the Sun control of Java reminds me of China's practice of government mandated language.
04:12:41 <tic> you need more than CRUD in a web app. :)
04:14:55 <shapr> Saulzar: On the other hand, wishing to use PHP as a tool to produce websites shouldn't result in code that's so hard to maintain.
04:15:31 <Muad_Dib> eww @ php.
04:15:45 <shapr> One of my closest friends is moving to Croatia and starting a graphic design business in Zagreb. I recommend PHP for her to build websites.
04:16:06 <Muad_Dib> really, php lacks to much of a typesystem for me to even be a bit ussuable.
04:16:23 <Saulzar> I think mostly it's because people don't learn PHP as a programming language, it's for making websites
04:16:42 <Muad_Dib> even checking whether something is indeed a plain string or an object is a plain pain in the ass.
04:16:43 <shapr> And yet, that is a worthwhile goal, isn't it?
04:17:17 <shapr> I don't know much about drop forging, but I can use a wrench.
04:17:23 <tic> Muad_Dib, there is a type system, just a lot of coercions. :)
04:17:27 <Muad_Dib> so where do the haskell-alike good webscripting language stay?
04:17:30 <Saulzar> Sure, but first time programmers don't make elegant code in any language
04:17:52 <Saulzar> and PHP certainly doesn't show them another way
04:18:09 <shapr> I think that's a big part of the problem.
04:18:11 <Saulzar> I just don't think picking on PHP is fair :)
04:18:20 <Muad_Dib> tic: and the only way to check whether it is irght is to do if(! is_a($var,"class")) { echo "Invalid type for $var."; exit; } manually
04:18:24 <shapr> I could equally pick on Java or C++
04:18:46 <tic> Muad_Dib, how often do you need to do that, though?
04:18:48 <shapr> Saulzar: Oh, I just had a crazy idea for a solution!
04:18:57 <Muad_Dib> tic: in my code a lot :P
04:19:02 <Saulzar> But it's harder, there are some great C++/Java programmers around
04:19:07 <Muad_Dib> it detects a lot of errors :D
04:19:13 <tic> okay...
04:19:18 <Muad_Dib> but then again i'm used to using typechecking to solve my problems ;)
04:19:24 <shapr> Saulzar: What about building code improvement tools into the editor, much like the evil paperclip?
04:19:26 <tic> then you don't seem to trust your own code.
04:19:27 <tic> Right.
04:19:51 <shapr> For example, there's a cool trick to detect code duplication where you just dump it into gzip and see what compression ration you get.
04:19:57 <shapr> ratio*
04:20:06 <tic> shapr, heard Gyllene Tider?
04:20:10 <shapr> nah?
04:20:15 <shapr> vem Ã¤r det?
04:20:28 <shapr> hm, the name sounds familiar...
04:20:35 <tic> shapr, Swedish band from the southern west coast.  Per Gessle is the singer.. Popular band in the 80s or so.
04:20:54 <shapr> Any free mp3s online?
04:20:58 <tic> shapr, don't know how good you're at understanding Swedish, but they have some pretty nice songs. Also, Lars Winnerbäck makes good tunes.
04:21:06 <tic> shapr, not really, however if you can stream... ?=
04:21:13 <Saulzar> shapr, Hmm, reminds me of the work of one of the lecturers here - his idea is to measure various software metrics and highlight them to the user, eg. red underline for bad code
04:21:19 <shapr> Nah, I'll stick with copyright accessible...
04:21:32 <shapr> Saulzar: I just had the same idea, so I totally agree with him.
04:21:32 <tic> shapr, okay then. 
04:21:42 <chrisbrown> ghc is behaving very strangly on my mac
04:21:43 <shapr> tic: I'll check out the band if I get a chance though. Do you have a last.fm account?
04:21:53 <shapr> Saulzar: As you said, <Saulzar> and PHP certainly doesn't show them another way
04:21:56 <tic> shapr, not yet. kolmodin's nagging me to get one. :P
04:22:02 <shapr> So, why not show them another way?
04:22:04 <Saulzar> shapr, He's 100% a Java guy, so it's mostly OO stuff he's looking at
04:22:24 <shapr> The evil paperclip can make suggestions for natural language, I'm sure we can do better with proglangs.
04:23:06 <tic> shapr, the problem is determining what is "bad" and what is "good" code though.
04:23:06 * shapr suggests people apt-get install vigor
04:23:18 <shapr> tic: I think that's pretty easy actually.
04:23:27 <Muad_Dib> vigor?
04:23:40 <tic> shapr, oh yah?
04:23:54 <shapr> tic: Yeah, code metrics for some things are quite clear.
04:24:14 <Saulzar> It could be much harder for something like fp :)
04:24:16 <tic> shapr, for some things. but then again, there are probably a lot of cases where it's difficult to see that?
04:24:28 <shapr> Duplication is easily found by doing the equivalent of CSE on the AST.
04:24:50 <tic> what's CSE?
04:24:58 <shapr> common subexpression elimination
04:25:00 <Saulzar> Usually you don't get 100% duplication but duplication and modify 1 line
04:25:01 <tic> aha.
04:25:17 <shapr> Saulzar: hm, CSE + fuzzy compare like spelling correctors?
04:25:29 <Saulzar> Hmm
04:26:11 <shapr> tic: code reachability is easily checked
04:26:22 <tic> shapr, yes.
04:26:38 <shapr> Stylistic problems are often easy to find, "don't use more than ten arguments to a function"
04:27:11 <shapr> I think that automated programmer improvement along these simple lines would still improve the PHP codebase dramatically.
04:27:12 <tic> that's what I meant.
04:27:28 <shapr> Can you suggest some cases that would be difficult to see?
04:28:07 <tic> No, as I don't know them myself. The hard part about style is to concretize(?) your feel for what's good code into actual applicable rules.
04:28:10 <shapr> I'd probably add checks for variable names that are overly similar, name shadowing (since that's rarely purposeful in imperative langs), that sort of thing.
04:29:13 <Saulzar> Hmm, maybe there's enough simple stuff to make it worthwhile. The program design level stuff would be very hard though I guess
04:29:26 <shapr> Some of it would be easy.
04:29:58 <shapr> I worked with some Java programmers who put in an empty "else {}" for every if because they didn't know it was optional.
04:30:13 <Muad_Dib> lol
04:30:13 <Saulzar> Haha
04:30:33 <shapr> They also had the form objects call the database connector directly, and it would fill in the form field itself!
04:30:54 <Saulzar> Trouble is that they can always fix things in a superficial way to please your checker
04:31:04 <pengo> who needs abstraction, eh?
04:31:29 <shapr> What's the name of the principle for "You can pick your friends, you can pick your nose, but you can't pick your friend's nose." ?
04:31:55 <shapr> It's the idea behind "if you have a dog object with leg objects, don't call the leg object, ask the dog to walk"
04:32:07 <tic> delegation?
04:32:15 <tic> abstraction?
04:32:32 <saintiss> hi
04:32:36 <shapr> I think there's some spiffy name for it..
04:32:38 <Saulzar> information hiding
04:32:47 <tic> existential quantification!
04:32:49 <Saulzar> That's not the one, but..
04:32:51 <shapr> aha http://c2.com/cgi-bin/wiki?LawOfDemeter
04:33:04 <Saulzar> Yep, that's the one I was thinking of :)
04:33:33 <saintiss> I'm looking into the I/O monads. I don't understand how you can do a getLine, which results in an IO string, and then pass this IO string to a function which requires a normal string. What is causing this magic conversion?
04:33:35 <shapr> I think you could check this one automatically, though it's more a usage thing.
04:33:38 <Saulzar> Becomes somewhat hard in practice, there's always a need to have some kind of "slave"
04:33:52 <saintiss> maybe it's the "do" construct, but I read somewhere this can be translated into >>=, which includes no conversion...
04:33:59 <shapr> Saulzar: And factory methods will look like bad behavior too.
04:34:10 <shapr> saintiss: http://www.nomaware.com/monads/
04:34:23 <shapr> Or will they? hm.
04:34:53 <saintiss> shapr, I've been browsing there before... are you sure the info is there?
04:35:01 <shapr> You could use the LoD as "don't touch instance variables if you're not the instance" maybe?
04:35:05 <shapr> saintiss: I am positive.
04:35:36 <shapr> saintiss: Do you understand the maybe monad?
04:36:14 <saintiss> shapr, yes
04:36:28 <shapr> What about the state monad?
04:36:37 <saintiss> shapr, haven't seen that one, no
04:37:04 <shapr> IO is a state monad with some extra rules for safety.
04:38:03 <saintiss> shapr, is the automatic conversion in the state monad, or in the extra safety rules?
04:38:45 <shapr> Neither. An IO result is pure when you're inside the monad.
04:38:53 <shapr> But the IO monad can only wind forward.
04:39:09 <shapr> This is because Haskell cannot yet go back in time.
04:39:13 <Saulzar> saintiss, There is no automatic conversion as such - it comes from the definition of >>=
04:39:17 <shapr> Maybe with GHC 6.8
04:39:41 <shapr> In which case I'll go back and teach myself Haskell when I'm sixteen years old.
04:40:01 <wilx> :)
04:40:01 <saintiss> Saulzar, this is what I read before, but >>= returns a monadic type (e.g. IO String), so I can't see why that result can be passed to a function requiring a non-monadic type
04:40:15 <saintiss> shapr, pure means e.g. String instead of IO String, right?
04:40:22 <shapr> saintiss: yes
04:40:41 <shapr> saintiss: You'll understand all of this if you go through the nomaware tutorial from the beginning and understand all of it.
04:40:55 <saintiss> shapr, and the reason it is pure, is because of the definition of >>=?
04:41:23 <saintiss> shapr, it's rather huge...
04:41:39 <shapr> You only need the first part really.
04:41:50 <shapr> Plus it's really cool :-)
04:42:06 <shapr> The monadic abstractions stomps all over the object abstraction in my opinion.
04:42:24 * shapr makes squishing noises.
04:42:26 <Saulzar> I still don't think they're comarable :)
04:42:56 <shapr> I think monads are like objects unwrapped along the time axis.
04:43:10 <Saulzar> Just that objects are sometimes used for similar tasks...
04:43:51 <saintiss> One-way monads allow values to enter the monad through the return function (and sometimes the fail function) and they allow computations to be performed within the monad using the bind functions >>= and >>, but they do not allow values back out of the monad.
04:43:58 <saintiss> this is what it says in the tutorial
04:44:11 <saintiss> that seems to confirm you can NOT pass an IO String to a function requiring a String
04:44:21 <shapr> Saulzar: I think they perform exactly the same task, 'abstraction.'
04:44:36 <shapr> saintiss: IO something means the something is in the IO monad.
04:44:51 <shapr> saintiss: If you're in there too, it's just something.
04:44:51 <Saulzar> Functions give abstraction in haskell, so do type classes...
04:45:09 <shapr> And monads are just functions... yeah?
04:45:15 <saintiss> shapr, I understand that conceptually, but in terms of static type checking, I don't think the engine has such a rule, right?
04:45:38 <shapr> saintiss: Sure it does. Monads are type constructors. How else would you keep this all straight?
04:45:39 <Saulzar> They're like a design pattern of FP
04:46:03 <shapr> I'd say that objects are a design pattern as well.
04:46:20 <shapr> Plus monads work fine in Java, Perl, Scheme, etc
04:46:23 <saintiss> type constructors indeed... but >>= will never discard such type constructor
04:46:44 <saintiss> it starts from an Io something, and returns another Io something
04:46:48 <saintiss> no way to escape afacs
04:46:56 <shapr> Sure there is. Don't return.
04:47:26 <saintiss> ok, e.g. this:
04:47:55 <saintiss> readn n >>= \cs -> functionWhichTakesString
04:47:59 <saintiss> you are saying this will work?
04:48:08 <saintiss> it's the same as:
04:48:10 <saintiss> do
04:48:16 <saintiss> cs <- readn n
04:48:23 <saintiss> functionWhichTakesString cs
04:48:25 <saintiss> or not?
04:48:30 <Saulzar> > (Just 5) >>= \x -> return (x + 1)
04:48:31 <lambdabot> Just 6
04:49:00 <saintiss> yes, I can see why that works... because return stays inside the monad
04:49:35 <Saulzar> Right, you can't get out using just the monad operators
04:49:46 <Saulzar> But x is an Int, not a Maybe Int
04:50:01 <saintiss> that is true...
04:50:48 <saintiss> hmm, I think I understand...
04:50:50 <saintiss> thanks...
04:51:16 <shapr> saintiss: readLine >>= \x -> putLine x
04:51:26 <shapr> At what point do you need to escape?
04:54:11 <shapr> hiya phone
05:01:15 <saintiss> shapr, indeed, you don't...
05:01:38 <saintiss> I just had a confusing example, where there was not putLine, but:
05:01:55 <saintiss> if (palin cs) then writeln "yes" else writeln ("no")
05:02:12 <saintiss> so I was confused since I thought palin took a String but didn't return to the Io monad
05:02:25 <saintiss> but of course it is in fact the if function which takes a String and does return to Io
05:02:58 <saintiss> although I must ask: is "if" a normal function, like any other?
05:03:13 <tic> sure.
05:03:30 <tic> if p x y = | p = x | otherwise = y
05:03:39 <tic> p == True = x, even.
05:03:44 <tic> (I *think* that should be valid)
05:04:10 <saintiss> tic, but that's if without "then" and "else"...
05:04:21 <tic> saintiss, oh, true.  forgot that.. then maybe it's a built-in.
05:04:33 <tic> saintiss why do you wish to know?
05:04:41 <saintiss> yeah, because the really interesting part is that, apparently, if you do 
05:04:44 <saintiss>  if (palin cs) then writeln "yes" else writeln ("no")
05:04:53 <Saulzar> Yeah, if is built in
05:04:55 <saintiss> then the type of that is a function requiring a String
05:05:28 <ibid> shapr: pulled
05:05:33 <saintiss> Saulzar, is that why my example results in a function taking a string? because if-then-else is being rewritten to something else?
05:05:44 <Saulzar> What is palin and cs?
05:05:53 <Saulzar> I don't think that's possible
05:05:53 <shapr> if then else is the same as case condition of; True -> ...; False -> ...
05:05:58 <saintiss> palin :: String -> Bool
05:06:22 <Saulzar> Unless writeln takes another agument...
05:06:22 <saintiss> \cs -> palin :: String -> Bool
05:06:23 <lambdabot> Maybe you meant: . docs id msg pl wn
05:06:40 <Saulzar> What is the type of writeln "yes" ?
05:06:46 <saintiss> Saulzar, IO()
05:06:59 <Saulzar> Then the type of the whole expression must be IO ()
05:07:35 <saintiss> Saulzar, it is... but the if part in itself is apparently of type String -> IO()
05:07:46 <saintiss> then since it is bound to cs, the result is IO()
05:08:13 <shapr> You get two results really, but one is a side-effect.
05:08:29 <shapr> Or maybe "two things happen"
05:08:56 <Saulzar> saintiss, Don't see what you're saying..
05:09:10 <Saulzar> @type if True then putStrLn "True" else putStrLn "False"
05:09:11 <lambdabot> IO ()
05:09:57 <saintiss> Saulzar, no...
05:10:02 <Saulzar> saintiss, Oh, you're talking about how it is connected in the do block
05:10:02 <saintiss> if palin  then putStrLn "True" else putStrLn "False"
05:10:05 <saintiss> yes
05:10:41 <Saulzar> Yeah,  cs <- blah; foobar  will produce  blah >>= \cs -> foobar
05:11:01 <saintiss> Saulzar, exactly, and foobar in this case is:
05:11:07 <saintiss>  if palin cs then putStrLn "True" else putStrLn "False"
05:11:21 <Saulzar> \cs -> foobar   certainly is of type String -> IO ()  :)
05:11:22 <lambdabot> Maybe you meant: . docs id msg pl wn
05:11:36 <saintiss> Saulzar, exactly... so then
05:11:40 <saintiss>  if palin  then putStrLn "True" else putStrLn "False"
05:11:46 <saintiss> is of type String -> IO() ?
05:11:52 <saintiss> or only
05:11:57 <saintiss> \cs ->   if palin cs then putStrLn "True" else putStrLn "False"
05:11:57 <lambdabot> Maybe you meant: . docs id msg pl wn
05:11:58 <saintiss> ?
05:12:05 <Saulzar> Right, second one
05:12:16 <saintiss> Saulzar, ok, then I understand... thanks
05:20:21 <alar> does anybody understand typed lambda-calculus?
05:20:37 <pengo> i can pretend to
05:21:14 <alar> is (\x. xx ) valid expression?
05:22:36 <alar> \x -> x x if Haskell syntax is preferred
05:22:36 <lambdabot> compose module failed: Parse error: "->"
05:22:41 <alar>  \x -> x x if Haskell syntax is preferred
05:37:18 <vincenz> alar: that's not typeable
05:37:43 <alar> then it's invalid
05:37:45 <alar> thanks
05:37:53 <vincenz> x has type A where A = A -> T
05:37:57 <vincenz> for some T
05:39:23 <jethr0> ls
05:39:27 <jethr0> hi vincenz 
05:39:55 <vincenz> aloha
05:39:58 <vincenz> jethr0: looked at hac?
05:40:00 <vincenz> @where hac
05:40:00 <lambdabot> http://haskell.org/haskellwiki/HAC
05:40:25 <jethr0> not yet, i think
05:41:26 <jethr0> nice, when does it start? :)
05:41:53 <alar> type A=A->T is invalid because it is infinite?
05:42:10 <vincenz> yes
05:42:20 <vincenz> jethr0: when we get enough people involved to organize it
05:42:22 <vincenz> jethr0: join #hac
05:44:25 <dcoutts> vincenz, how's that rb tree screenshot? :-)
05:44:31 <vincenz> dcoutts: oh right
05:44:33 <vincenz> let me make it ;)
05:44:37 <dcoutts> cool!
05:44:45 <vincenz> it's rather bare to the bones ya know
05:45:17 <vincenz> how do I screen shot an application?
05:45:29 <dcoutts> alt+prtinscr
05:45:34 <dcoutts> (in gnome anyway)
05:45:38 <vincenz> okies
05:45:41 <vincenz> let me recompile the app
05:45:46 <vincenz> right now it onl makes windows for faulty trees
05:45:57 <dcoutts> clever
05:46:07 <vincenz> :)
05:46:09 <dcoutts> did you turn AA on in the end?
05:46:14 <vincenz> yes
05:46:27 * dcoutts is shocked!
05:47:00 <vincenz> this is great
05:47:02 <vincenz> my c++ program
05:47:06 <vincenz> basically accepts text on stdin
05:47:10 <vincenz> Add n, Remove n
05:47:11 <vincenz> where n is a key
05:47:17 <vincenz> (value is just the same as key for now)
05:47:21 <vincenz> and at each step outputs the tree
05:50:59 <vincenz> ideally
05:51:03 <vincenz> I'd have a scrollbox on the right
05:51:07 <vincenz> with all the trees to be shown
05:51:12 <vincenz> instead of opening a new window each time
05:51:14 <vincenz> and waiting until it finishes
05:51:29 <vincenz> let me code that in
05:55:09 <vincenz> @hoogle iovar
05:55:10 <lambdabot> No matches found
05:55:25 <vincenz> how do I make a var?
05:55:36 <vincenz> ah ioref
05:58:14 <vincenz> dcoutts: quick way of making a panel with options that I can clickk on?
05:58:21 <vincenz> like a list of strings that are clickable
05:58:36 <dcoutts> vincenz, fixed length or not?
05:58:45 <vincenz> once made yes
05:58:57 <dcoutts> oh, so built dynamically
05:59:00 <vincenz> I guess a box of buttons
05:59:04 <vincenz> dcoutts: yep
05:59:10 <vincenz> based on the number of trees to be displayed
05:59:18 <dcoutts> yeah a button box might do
05:59:38 <dcoutts> lists boxes are a bit hard to do at the moment (though not for much longer!)
06:00:05 <vincenz> ok
06:00:23 <vincenz> adding a button to a box?
06:02:31 <dcoutts> vincenz, set box [ containerChild := button ]
06:02:58 <vincenz> that'll add
06:03:22 <vincenz> hmm
06:03:27 * vincenz wishes there was an each function
06:03:28 <vincenz> something like
06:03:37 <vincenz> each l f = sequence_ $ map f l
06:04:18 <xerox> (sequence_ .) . flip mapM_ !
06:04:32 <dcoutts> vincenz, each = flip mapM_
06:04:45 <xerox> I believe so too.
06:04:57 <xerox> That is usually called `forM_'.
06:05:08 <vincenz> @hoogle forM_
06:05:09 <lambdabot> No matches found
06:05:40 <vincenz> @hoogle mapM_
06:05:40 <lambdabot> Control.Monad.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
06:05:41 <lambdabot> Prelude.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
06:05:41 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
06:05:48 <vincenz> cool
06:06:05 <dcoutts> vincenz, set box [ containerChild := button | button <- butons ]
06:06:18 <dcoutts> that's nicer :-)
06:07:44 <int-e> dcoutts: what's the type of := ?
06:08:06 <xerox> GObject -> [Property] -> IO ..
06:10:06 <dcoutts> int-e, (:=) :: ReadWriteAttr o a b -> b -> AttrOp o
06:10:21 <dcoutts> set :: o -> [AttrOp o] -> IO ()
06:11:04 <vincenz> @hoogle zip
06:11:05 <lambdabot> Data.List.zip :: [a] -> [b] -> [(a, b)]
06:11:05 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
06:11:05 <lambdabot> Control.Monad.zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
06:11:09 <vincenz> @hoogle zip
06:11:10 <lambdabot> Data.List.zip :: [a] -> [b] -> [(a, b)]
06:11:10 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
06:11:10 <lambdabot> Control.Monad.zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
06:12:32 <int-e> dcoutts: thanks.
06:13:03 <vincenz> dcoutts: alt+printscreen seems not to work
06:13:20 <vincenz> nm
06:13:57 <shapr> tic: got a last.fm account yet?
06:14:04 <tic> shapr, no. should I? :)
06:14:19 <vincenz> shapr: hi
06:14:23 <vincenz> shapr: more people are interested
06:14:40 <vincenz> dcoutts: http://oasis.yi.org:8080/Screenshot-Graph.png
06:14:53 <shapr> vincenz: nice screenie
06:14:56 <vincenz> thx
06:14:57 <shapr> tic: like, of course
06:15:06 <shapr> @seen franka
06:15:06 <lambdabot> I saw franka leaving #haskell and #haskell-blah 4 days, 14 hours, 28 minutes and 26 seconds ago, and I have missed 1 hour, 20 minutes and 6 seconds since then.
06:15:53 <dcoutts> vincenz, nice!
06:16:21 <vincenz> shapr: join #hac?
06:16:40 <shapr> I left a shoutout on franka's last.fm page, "Skolemization!" and he replied with "Your message gave me such joy that I had to reach for a prenex."
06:16:41 * shapr laughs
06:17:21 <tic> heh
06:20:30 <musasabi> Does Data.Map have a nice way of detecting duplicate keys on insert and returning the fact?
06:26:23 <ihope> Let's see here...
06:26:49 <ihope> \x -> (\y -> x (y y)) (\y -> x (y y))
06:26:49 <lambdabot> compose module failed: Parse error: "->"
06:26:57 <ihope> \x id id
06:27:07 <ihope> \x elite arr
06:27:07 <lambdabot> ahOy m4Teys
06:27:20 <ihope> Hmm. What's up with that?
06:29:09 <shapr> @ elite arr
06:29:25 <shapr> @x elite arr
06:29:26 <lambdabot> 5HIv3r mE 7I/\/\beRS!
06:29:30 <shapr> ihope: Oh, I get it :-)
06:29:52 <shapr> spelling correction turns the x into the compose command, which is @.
06:30:05 <ihope> @@ elite arr
06:30:06 <lambdabot> i'|l crU5H Ye b4rnAC1E5!
06:30:07 <shapr> and backslash is a new alternative for @
06:30:17 <ihope> I thought . was the compose command.
06:30:24 <ihope> @help .
06:30:25 <lambdabot>  @compose/@. is the composition of two plugins, where: . f g xs == g xs >>= f
06:30:43 <shapr> It is. But spell correct probably found the only other single char command and used that instead of @x
06:30:45 <int-e> @help x
06:30:46 <lambdabot>  @help <command> - ask for help for <command>
06:33:41 <ihope> :-)
06:34:07 <ihope> \-:
06:34:08 <lambdabot> Maybe you meant: . id pl wn
06:34:23 <int-e> @hl now which command is this
06:34:24 <lambdabot> now which command is this
06:34:49 <ihope> @pl now which command is this
06:34:49 <lambdabot> now which command is this
06:34:57 <shapr> hl probably gets you hello
06:35:04 <shapr> oh, guess not
06:35:07 <shapr> @hello world.
06:35:07 <lambdabot>  @help <command> - ask for help for <command>
06:35:11 <shapr> hm
06:35:27 <int-e> @hl \x y z -> x z (y z)
06:35:28 <lambdabot> ap
06:35:31 <ihope> @pl It's like the identity command, but it doesn't work "as well".
06:35:31 <lambdabot> (line 1, column 31):
06:35:31 <lambdabot> unexpected ","
06:35:31 <lambdabot> expecting variable, "(", operator or end of input
06:38:02 <shapr> pointless?
06:39:14 <ihope> @pl How pointless it is
06:39:15 <lambdabot> How pointless it is
06:39:25 <shapr> @pl How (pointless it is)
06:39:26 <lambdabot> How (pointless it is)
06:39:45 <ihope> @pl How pointless. It does very little
06:39:46 <lambdabot> How pointless . It does very little
06:39:52 <musasabi> GHC has nice error messages like "My brain just exploded." :-)
06:39:55 <ihope> :-)
06:40:10 <ihope> @pl \x -> product [1..x] -- never mind?
06:40:10 <lambdabot> product . enumFromTo 1
06:40:27 <ihope> @ghc
06:40:27 <lambdabot>  Exotic Stmt in meta brackets
06:40:39 <ihope> Whoo. How does that one come about?
06:41:39 <shapr> @ghc
06:41:39 <lambdabot>  Multiple default declarations
06:43:12 <ihope> > lift return
06:43:13 <lambdabot>  add an instance declaration for (Show (t ((->) a) (m a)))
06:43:17 <ihope> Aww.
06:45:20 <int-e> > lift lift lift
06:45:20 <lambdabot> Couldn't match kind `(* -> *) -> * -> *' against `?? -> ? -> *'
06:46:05 <shapr> > lift . lift . lift
06:46:05 <lambdabot>  add an instance declaration for (Show (m a -> t (t1 (t2 m)) a))
06:46:15 <shapr> @pl lift . lift . lift
06:46:15 <lambdabot> lift . lift . lift
06:46:35 <ihope> @pl lift lift lift
06:46:35 <lambdabot> lift lift lift
06:46:58 <int-e> > lift local return
06:46:58 <lambdabot> Couldn't match kind `(* -> *) -> * -> *' against `?? -> ? -> *'
06:47:58 <xerox> @type Control.Monad.lift Control.Monad.lift Control.Monad.lift
06:47:59 <lambdabot> Not in scope: `Control.Monad.lift'
06:47:59 <lambdabot>  
06:47:59 <lambdabot> <interactive>:1:19: Not in scope: `Control.Monad.lift'
06:48:03 <ihope> data RandomGen_ where RandomGen_ :: RandomGen g => g -> RandomGen_
06:48:21 <int-e> it's in Control.Monad.Trans
06:49:02 <musasabi> Is there a good solution for pattern binding existential constructors?
06:50:28 <ihope> instance RandomGen RandomGen_ where next (RandomGen_ x) = (\(y,z) -> (y,RandomGen_ z)) (next x); split (RandomGen_ x) = (\(y,x) -> (RandomGen_ y,RandomGen_ z)) (split x); genRange (RandomGen_ x) = genRange x
07:08:07 <reltuk> ok, I need a function like `words`, except it returns a pair of tuples, (String, Int), and each word has it's original index in the string attached
07:08:20 <bringert> is there any way in cabal to say that modules using a package need some extensions?
07:08:26 <reltuk> is there a better way to do that than basically duplicating the words function?
07:08:48 <reltuk> s/returns a pair/returns a list/
07:08:58 <bringert> for example, programs using HaskellDB must be compiled with OverlappingInstances
07:09:09 <xerox> @type ((id &&& read) . words) :: String -> [(String,Int)]
07:09:10 <lambdabot> Not in scope: `&&&'
07:09:17 <xerox> @type ((id Control.Arrow.&&& read) . words) :: String -> [(String,Int)]
07:09:18 <lambdabot>   Couldn't match `Char' against `String'
07:09:18 <lambdabot>   Expected type: String -> String
07:09:41 <xerox> > (id &&& read) . words $ "1 2 3" :: [(String,Int)]
07:09:42 <lambdabot> Couldn't match `Char' against `String'
07:09:46 <xerox> Grr.
07:10:10 <xerox> > map (id &&& read) . words $ "1 2 3" :: [(String,Int)]
07:10:11 <lambdabot> [("1",1),("2",2),("3",3)]
07:10:40 <xerox> Ah, index?
07:10:59 <reltuk> xerox: yeah...index of the character that started it...seems like it's gonna be nasty  :/
07:11:04 <xerox> > zip [1..] . words $ "three indexed tokens"
07:11:04 <lambdabot> [(1,"three"),(2,"indexed"),(3,"tokens")]
07:11:19 <xerox> Hmm, what do you mean?
07:11:40 <xerox> (by "index of the character that started it"?)
07:12:13 <reltuk> wordsWithPos "this is a test"    ---->   [("this",0),("is",5),("a",8),("test",10)]
07:13:18 <reltuk> like, the "index" of the first character of the word in the original string........I'm trying to store the file offset that the word appears at in a file 
07:13:27 <xerox> Oh.
07:14:24 <xerox> Idea.
07:14:40 <bringert> you could zip the whole string with [1..], then use splitBy (isSpace . snd), and then use head to just keep the first index in each sublist
07:14:46 <bringert> or something like that
07:15:05 <bringert> see http://www.haskell.org/hawiki/LicensedPreludeExts for splitBy
07:15:37 <Saulzar> > scanl (flip ((+) . length)) 0 ["foobar", "emu", "fred"]
07:15:38 <lambdabot> [0,6,9,13]
07:18:01 <xerox> I was about .. :-)
07:18:24 <reltuk> bringert: sounds sexy
07:19:59 <bringert> sexy?
07:20:22 <reltuk> map (\x -> (fst (head x), map snd x)) (splitBy (Char.isSpace . snd) (zip [1..] "this is a   test"))
07:20:43 <reltuk> es perfecto
07:21:02 <xerox> > scanl1 (\(n,_) (m,s) -> ((n+length s),s)) . map ((,)0) . words $ "this is a string"
07:21:02 <lambdabot> [(0,"this"),(2,"is"),(3,"a"),(9,"string")]
07:21:26 <xerox> ops.
07:21:48 <xerox> > scanl1 (\(n,s) (m,r) -> ((n+length s),r)) . map ((,)0) . words $ "this is a string"
07:21:49 <lambdabot> [(0,"this"),(4,"is"),(6,"a"),(7,"string")]
07:22:10 <reltuk> xerox: but the double space gets dropped
07:22:27 <xerox> Yes.
07:49:08 * SamB wonders what alternatives there are to using "return ()" everywhere to make types match up
07:50:31 <reltuk> wow, I can't believe this works so well
07:52:24 <SamB> @pl (\x -> (fst (head x), map snd x))
07:52:24 <lambdabot> ap ((,) . fst . head) (map snd)
07:52:53 <reltuk> what's @pl do?
07:53:08 <SamB> a pointless transformation
07:53:44 <Saulzar> Hmm, don't suppose anyone has done multitexturing with hOpenGL, the environment functions don't seem to do aynthing...
07:53:50 <SamB> actually, it attempts to eliminate variables
07:54:11 <SamB> Saulzar: does your card actually support them?
07:54:13 <reltuk> is ap a function?  or is it just a prefix to the answer...?
07:54:20 <Saulzar> SamB, Yeah..
07:54:22 <SamB> it is a function
07:54:45 <SamB> I'm thinking this answer probably uses the (-> a) reader monad...
07:54:50 <SamB> er.
07:54:57 <SamB> I (a ->)?
07:55:00 <xerox> SamB: undefined :-)
07:55:03 <reltuk> it's not in prelude...
07:55:16 <xerox> (a ->)
07:55:20 <xerox> @type Control.Monad.ap
07:55:20 <lambdabot> forall b (m :: * -> *) a.
07:55:20 <lambdabot>        (Monad m) =>
07:55:20 <lambdabot>        m (a -> b) -> m a -> m b
07:55:30 * reltuk boggles
07:55:34 <reltuk> thank you   :)
07:55:40 <xerox> You're welcome.
07:58:16 <reltuk> @pl (\x -> createIndex (snd x) (fst x))
07:58:16 <lambdabot> liftM2 createIndex snd fst
07:58:24 <reltuk> hah, that's so cool
07:59:57 <SamB> might be inefficient though
08:00:58 <reltuk> SamB: efficiency isn't paramount (luckily...I understand it's hard and this is my first haskell program...so...  :-p)
08:01:14 <SamB> maybe not here
08:01:40 <int-e> @type \f -> uncurry (flip f)
08:01:41 <lambdabot> forall a b c.
08:01:41 <lambdabot>          (b -> a -> c) -> (a, b) -> c
08:02:18 <Saulzar> Whoops, I assumed by having a Maybe argument that textureBinding was also enabling texturing
08:02:23 <Saulzar> Apparently not
08:03:46 <ihope> First-class types...
08:04:05 <ihope> (::) :: forall a. exists b. a -> * -> b
08:04:09 <ihope> :-)
08:04:32 <ihope> Hmm, wait, it's overloaded.
08:04:41 * shapr overloads too
08:05:07 <ihope> (::) :: forall a b c. TypeAnnotation a b c => a -> b -> c
08:05:49 <ihope> instance TypeAnnotation a * (exists c. c) where...
08:06:07 <reltuk> can I serialize out my FiniteMap?
08:07:31 <ihope> Hey!
08:07:48 <xerox> FiniteMap is deprecated, use Map!
08:07:56 <reltuk> xerox: it doesn't exist in 6.2  :/
08:07:56 <ihope> > read "wheeeeeeeee, a standard generator" :: System.Random.StdGen
08:07:57 <lambdabot>  Not in scope: type constructor or class `System.Random.StdGen'
08:08:02 <reltuk> at least, in my 6.2...
08:08:09 <xerox> reltuk: oh, 6.2 exists?  <grin>
08:08:12 <reltuk> haha
08:08:24 * reltuk wants new ghc!
08:08:54 <xerox> Get it!
08:09:08 <reltuk> fink started sucking
08:09:28 <ihope> What's the latest GHC? I have 6.4.1.
08:10:39 <reltuk> ihope: that's the latest release
08:10:52 <ihope> Okay.
08:11:13 <ihope> Now how come read :: String -> StdGen doesn't like to parse some things?
08:16:24 <reltuk> @type read
08:16:25 <lambdabot> forall a. (Read a) => String -> a
08:21:54 <dcoutts> dons, any idea how I get the nofib testsuite running?
08:22:21 <dcoutts> I want to make the gentoo ghc ebuild run the testes (when one builds using FEATURES="test")
08:30:59 <davidhouse> heh. i was at an oxford & cambridge conference today (the two leading universities in the UK for anyone that doesn't know), they were talking about their compsci degrees. they said they like to teach the freshers haskell because "no-one's come across it, so it's a great leveler" :)
08:32:11 <davidhouse> i felt so special :)
08:32:48 <integral> cambridge teaches haskell to freshers?!
08:32:57 <davidhouse> it was oxford actually
08:33:02 <xerox> Cool!
08:33:03 <davidhouse> cambridge taught ML.
08:33:11 <liyang> Still teaches ML.
08:33:12 <cpatrick> A lot of universities teach Haskell to freshers
08:33:16 <integral> davidhouse: and excessive Java.  A whole course on teaching Java. :-(
08:33:21 <liyang> How else is Larry Paulson going to get rid of his books?
08:33:41 * dcoutts teaches the first Haskell course to undergrads at Oxford
08:33:59 <dcoutts> well the practicals anyway, not the lectures / classes
08:34:05 <davidhouse> dcoutts, really?
08:34:07 <davidhouse> cool :)
08:34:29 <dcoutts> I wrote a new practical this year, using GUIs of course! :-)
08:35:06 <davidhouse> dcoutts, what kind of stuff is taught?
08:36:22 <dcoutts> the basics, primitive rcursion, higher order stuff, equational reasoning, folds, no monads
08:36:26 <reltuk> ok, if I "import Data.Map as Map", why would is shadow the Prelude map?
08:36:31 <shapr> dcoutts: Unlike most Haskellers, we write impracticals.
08:36:52 <dcoutts> shapr, heh
08:36:58 <Igloo> reltuk: import Data.Map qualified as Map
08:36:59 <integral> reltuk: you need "import qualified Data.Map as Map"
08:37:08 <reltuk> ahhh, cool
08:37:21 <xerox> Today the prof explained recursion, I really couldn't figure out how to make them understand it in Visual Basic.
08:37:32 <davidhouse> Igloo, "import qualified ...", not "import ... qualified"
08:37:43 <dcoutts> shapr, well it's much better than it used to be, we used to use hugs and have it pipe commands to a tcltk gui. Now we use ghc / ghci and Gtk2Hs :-) Much less of a toy example.
08:37:47 <xerox> Hence I explained to two of them the basic of equational reasoning, which is *really* straightforward... and the grokked recursion in no time!
08:37:48 * Igloo can never remember which order it is  :-)
08:37:54 <xerox> Hurray for referential transparency!!
08:38:05 <davidhouse> Igloo, it's the one that makes for less readable code ;)
08:38:07 <davidhouse> isn't recursion just really simple?
08:38:26 <davidhouse> just a function calling itself, but with an if () statement around it so it doesn't do so infinitely
08:38:27 <shapr> dcoutts: Truly, that is better.
08:38:34 <davidhouse> that's about as complicated as it gets in VB, at least
08:38:37 <xerox> VB syntax makes it quite unreadable.
08:38:56 <xerox> Well, you can read it because you know what it is.  But they were lost.
08:39:25 * davidhouse tries to think of an example of where recursion would be used in non-functional code
08:39:44 <shapr> I do that all the time!
08:39:50 <shapr> But usually I fix before I start using it.
08:39:51 <davidhouse> i guess some of the functional examples could be translated into procedural code, but that would draw cries of "why not just use a loop?".
08:40:07 <dcoutts> shapr, right. For one thing it's all in Haskell so it doesn't look like Haskell is useless. Then using a compiler rather than a toy interpreter makes a better impression with students. Oh and Gtk+ doesn't look ugly like tk does.
08:40:15 <xerox> The point is that recursion is very very straightforward once you've got a substitution model.  Which you *don't*, in VB.
08:40:18 <ihope> Hmm, /me works on his unsafePerformIO factorial function
08:40:18 <integral> you end up with an explicit stack, using recursion hides that in the parameter stack
08:40:55 <shapr> Recursion and laziness are both nice for dealing with multidimensional data structures.
08:41:56 <reltuk> ok, so what (read "[1,2,3]")::[Int] works, is that because the type qualifier tells the compiler which "read" to use?
08:42:04 <reltuk> s/so what/so when/
08:42:09 <shapr> reltuk: yup
08:42:09 <xerox> I also made them grok the difference between iterative/recursive *definitions* and iterative/recursive *processes*.
08:42:10 <sjanssen> reltuk: yes
08:42:11 <shapr> typeclasses rock
08:42:26 <shapr> xerox: Oh do that for me too!
08:42:38 <xerox> I was really happy, one of them handed me an answer in the English licterature test.  Grin.
08:43:00 <xerox> shapr: you know very well about TCO!
08:43:17 <shapr> er, um, ok.
08:43:48 <shapr> I admit, I do.
08:43:51 <xerox> :-)
08:45:25 <ihope> data Value where Value :: a -> Value -- defines a type that can hold anything at all, but such that you can't figure out what it's holding, so you have to use \(Value a) -> unsafeCoerce# a to do anything with it.
08:45:31 <shapr> You can use recursive definitions to build recursive processes.
08:47:09 <ihope> Now, I should add a thread to this program that represents zero. Oh-so-fun.
08:47:25 <integral> data Value where Value :: (Typeable a) => a -> Value;  and then \(Value a) -> cast a -- actually _useful_
08:47:40 <ihope> What's Typeable?
08:47:46 <davidhouse> @index unsafeCoerce#
08:47:47 <lambdabot> bzzt
08:48:43 <integral> ihope: types that have runtime type information available
08:49:12 <integral> @type Data.Typeable.typeOf
08:49:13 <lambdabot> forall a.
08:49:13 <lambdabot>         (Data.Typeable.Typeable a) =>
08:49:13 <lambdabot>         a -> Data.Typeable.TypeRep
08:51:39 <ihope> What the...
08:52:01 <ihope> Oh!
08:53:06 <SamB> its the first part of dynamic typing in a static type system
08:53:39 <integral> I've got a really handy comp :: (a -> b) -> (b' -> c) -> Maybe (a -> c) built out of it for example
08:54:06 <ihope> !
08:54:10 <heatsink> Is there a way to make a subtype of a data type?
08:54:20 <ihope> heatsink: what do you mean?
08:54:21 <SamB> whats a subtype?
08:54:40 <integral> heatsink: haskell's type system doesn't have subtypes
08:54:42 <heatsink> Bar is a subtype of Foo if all data of type Bar is also of type Foo
08:54:47 <davidhouse> A is a subtype of B if all value with type of A have type B as well
08:54:54 <davidhouse> *all values
08:54:56 <integral> heatsink: you could put the interface into a typeclass
08:55:01 <davidhouse> heatsink: snap!
08:55:25 <SamB> well, wxHaskell does soemthing vaguely like that.
08:55:34 <ihope> heatsink: would converting from Bar to Foo work?
08:55:38 <heatsink> integral, I guess so.  But I don't actually need the indirection of type class indirection.
08:55:54 <heatsink> I have one data type right now, a type Expression.
08:56:09 <integral> heatsink: you could have a function that converts a Bar into a Foo, and have your Foo's be: data Foo = ... | FooBar Bar
08:56:10 <heatsink> There is a function to simplify expressions, which is currently Expr -> Expr
08:56:14 <davidhouse> all values of type Int are also types of Integer, that's an example.
08:56:23 <heatsink> but I want to make it Expr -> SimplifiedExpr
08:56:32 <integral> haskell sucks for that one :-)
08:56:38 <SamB> yes it does!
08:57:21 <heatsink> Some functions expect expressions that are in simplified form, and others do not.  I'd like to check that with the type system without incurring runtime overhead.
08:57:39 <davidhouse> create a typeclass Expression, and make Expr and SimplifiedExpr instances thereof.
08:57:41 <davidhouse> perhaps
08:57:42 <SamB> well, GADTs might be able to do it
08:57:58 <davidhouse> although that wouldn't actually help.
08:58:04 * davidhouse retracts that idea
08:58:13 <ihope> Yeah: class Expression a where toExpression :: a -> Expr
08:58:42 <SamB> another option is plain-old phantom typing, probably...
08:59:00 <ihope> If you want to take any expression at all: Expression a => a -> WhateverYourFunctionReturns
09:00:02 <heatsink> I can certainly do it with typeclasses, though it'll add more indirections.
09:00:04 <davidhouse> SamB, GADTs?
09:00:25 <heatsink> How would one do it with phantom typing?
09:00:42 <davidhouse> SamB, Ground-Air Defense Turrets?
09:00:50 <heatsink> haha
09:01:06 <heatsink> Generalized Abstract Data Types
09:01:10 <SyntaxNinja> 'mornin
09:01:13 <SamB> data Expr a ...
09:01:25 <heatsink> ,prmom
09:01:33 <SamB> data Simplified
09:01:48 <davidhouse> > map succ "mornin"
09:01:48 <lambdabot> "npsojo"
09:02:13 <SamB> simplify :: Expr a -> Expr Simplified
09:02:41 <ihope> What's wrong with classes?
09:02:48 <heatsink> I think i get it.
09:03:04 <heatsink> Yea, I like that, SamB.
09:03:09 <davidhouse> we need a haskell glossary
09:04:05 <heatsink> ihope: classes mean passing type dictionaries around at runtime.  Also there'll be a lot of type coercing (toSimplifiedExpr x) (fromSimplifiedExpr x) in the code.
09:05:17 <SamB> now, you can fill in the definition for Expr a couple of ways...
09:05:50 <SamB> you could just leave it the way it is, or you could convert it to a GADT
09:06:00 <davidhouse> can someone define a GADT?
09:06:16 <davidhouse> (i.e., don't just expand the abbreviation ;) )
09:06:20 * heatsink hasn't taken the time to understand GADTs
09:06:21 <SamB> oh
09:06:34 <SamB> well, basically you get to write
09:06:57 <liyang> Something that lets you specify the type signature of type constructors explicitly.
09:07:53 <davidhouse> the type signature of _type_ constructors?
09:08:22 <liyang> http://haskell.org/ghc/docs/latest/html/users_guide/gadt.html is as good an explanation as any.
09:08:43 <SamB> data Expr a where { Prim :: (a -> b) -> Expr (a -> b); App :: Expr (a -> b) -> Expr a -> Expr b }
09:08:49 <SamB> and stuff like that
09:09:29 <davidhouse> liyang: ah, you meant the type of data constructors, not type ones ;)
09:09:46 <liyang> er... yes.
09:09:57 <liyang> s/type/a type's/ 
09:09:58 <liyang> >_>
09:09:59 <liyang> <_<
09:10:23 <SamB> of course, there would be more data constructors, and likely you would not have that Prim one...
09:11:21 <SamB> this can even be used for stuff like red-black trees (with a tiny bit of fudging)
09:11:45 <davidhouse> are GADTs just syntactic sugar?
09:11:55 <shapr> This is the only channel I know where what at first glance appear to be cheesy emoticons might just turn out to have some deep category theory meaning.
09:12:20 <SyntaxNinja> heh
09:12:31 <chrisbrown> ghc is really really starting to p**** me off
09:12:45 <lesshaste> hi
09:13:20 <lesshaste> can balanced binary search trees be implemented with their "correct" time complexity in Haskell (without arrays and monads etc. :) )
09:13:52 <int-e> yes. Data.Map does that
09:14:13 <lesshaste> thx.. how does Data.Map do it?
09:14:31 <lesshaste> I would like to understand any issues that there re
09:14:31 <lesshaste> are
09:14:36 <chrisbrown> nobody here tried building 6.5 on mac os x? or used darwin ports?
09:15:23 <reltuk_> lesshaste: there are no issues...
09:15:41 <lesshaste> reltuk_, ok... I am mostly worried about the balancing etc.  
09:15:44 <int-e> lesshaste: what's the problem? searching traverses a constant data structure; insert and delete modify the data structure, but they only modify O(log(n)) nodes, so the complexity is the same for creating those nodes anew as with destructive updates.
09:15:50 <reltuk_> lesshaste: if you traverse O(lg n) elements, then you can duplicate O(lg n) elements and it's still bounded by O(lg n)
09:16:03 <lesshaste> that sounds very convincing thx
09:16:33 <lesshaste> creating the thing in the first place will be O(n) still?
09:16:34 <int-e> (you can easily share the parts that have not changed, because they are never updated)
09:16:56 <reltuk_> good examples in "Purely Functional Datastructures"
09:16:58 <int-e> O(n log(n)) unless your elements are already sorted
09:17:08 <lesshaste> I mean if you insert the nodes one by one you get O(nlogn)
09:17:14 <lesshaste> which is not as good as imperative right?
09:17:27 <lesshaste> int-e, assuming they are already sorted :)
09:18:04 <lesshaste> Purely Functional Datastructures is available online! :)
09:18:10 <reltuk_> is it really?
09:18:18 <davidhouse> @where yaht
09:18:19 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
09:18:45 <int-e> lesshaste: you can construct the map in O(n) time from a sorted list. I don't know if Data.Map implements that though. (you can build the tree bottom up, for example, in n+n/2 + n/4 + ... = O(n) steps.)
09:18:47 <shapr> lesshaste: huh?
09:18:51 <reltuk_> wow, that's amazing
09:19:03 <shapr> Okasaki's book? or just his thesis?
09:19:06 <Philippa> lesshaste: clever use of laziness and data sharing is how most of it's done
09:19:07 <lesshaste> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
09:19:14 <lesshaste> Philippa, thanks
09:19:18 <reltuk_> ahh, that's his thesis
09:19:22 <shapr> book > thesis
09:19:24 <lesshaste> the basic problem has been answered though.. thx all
09:20:38 <reltuk_> are there better serialization methods than "read" and "show"?
09:21:41 <reltuk> well, that was a dumb question...obviously there are (for arbitrary definitions of better); the question is in regards to if any of these methods are implemented in portable, free, easy to use libraries
09:22:12 <shapr> @where binary
09:22:12 <lambdabot> I know nothing about binary.
09:22:14 <shapr> @where newbinary
09:22:15 <lambdabot> darcs get http://www.n-heptane.com/nhlab/repos/NewBinary
09:27:45 <reltuk> uggh, this was so easy...I prototyped the program in Haskell and now I have to implement it in C.  that's going to suck
09:28:25 <sebell> reltuk: Why do you have to implement it in C? :)
09:29:14 * heatsink sympathizes with reltuk
09:29:58 <davidhouse> does lambdabot have an @index interface?
09:30:06 <reltuk> sebell: it's for a "systems programming course"...but the program didn't seem to have much to do with systems level programming
09:30:26 <heatsink> What do they mean by systems programming?
09:30:35 <sebell> reltuk: Ah, I see
09:30:49 <reltuk> heatsink: no one knows...posix threads, processes, socket programming...
09:31:21 <Philippa> so they mean app-level programming for non-user-friendly values of app
09:31:25 <heatsink> That sounds like distributed/parallel/OS programming
09:31:39 <Philippa> (on a *nix-flavoured system)
09:31:59 <Philippa> oh, in fairness servers too
09:32:02 <Philippa> but hey
09:32:02 <musasabi> reltuk: is there a reason not to use Haskell?
09:32:13 <Philippa> musasabi: I'd imagine the course specifies C
09:32:15 <sebell> musasabi: It seems like a C course
09:32:19 <reltuk> Philippa: they're only non-friendly when you use the wrong tools  (i.e. c)   ;)
09:32:37 <Philippa> reltuk: I fail to see how language choice decides UI issues, but hey
09:32:51 <Philippa> (yeah yeah, throw GWBASIC at me as a response why don't you ;-)
09:33:43 <reltuk> I'm not even bad at C...this is the first haskell program I've ever written, and it's like 50 lines.  the C program will be well over 500
09:33:44 <heatsink> btw, what is the haskell equivalent of select()?
09:34:11 <musasabi> heatsink: threads or STM.
09:37:09 <heatsink> ah.
09:38:07 <musasabi> of course low level libraries might use operating system select/poll/etc facilities
09:38:08 <davidhouse> reltul, what does it do?
09:39:07 <davidhouse> reltuk, what does it do?
09:39:22 <reltuk> davidhouse: indexes a bunch of files (creates a mapping from all the words in the file to a list of all the files and positions that word appeared at), and stores that index out
09:39:39 <reltuk> davidhouse: then there's another program that reads the index and looks up words in the index
09:39:43 <davidhouse> yeah.
09:40:11 <reltuk> ok, gotta go, thanks for help :)
09:40:30 <musasabi> a haskell program outputting a C program solving the problem is not allowed either? ;)
09:41:21 <SamB> ooh! use GHC! (or does the C program haveta be portable and/or resemble C?)
09:43:03 <davidhouse> @where darcs
09:43:04 <lambdabot> http://darcs.net/
09:49:26 <shapr> @where shapr
09:49:26 <lambdabot> http://www.ScannedInAvian.com/
09:49:29 <shapr> !
09:54:10 * shapr tries to rewrite const in Python
10:04:26 <ski> SamB : :D
10:06:32 <SyntaxNinja> kosmikus: msg me your email address?
10:07:19 <SyntaxNinja> kosmikus: oh, nm
10:09:36 <davidhouse> \version
10:09:37 <lambdabot> lambdabot 3p330, GHC 6.4.1 (Linux i686 3.20GHz)
10:09:37 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
10:09:58 <ski> \x -> x
10:09:58 <lambdabot> compose module failed: Parse error: "->"
10:13:04 <davidhouse> whose project is lambdabot?
10:13:13 <davidhouse> more to the point, does it have an @index interface?
10:13:25 <jethr0_> @index foldl
10:13:25 <lambdabot> Data.List, Prelude
10:13:54 <davidhouse> ah, cool.
10:13:59 <davidhouse> wait
10:14:02 <davidhouse> i meant :info
10:14:06 <davidhouse> @info Enum
10:14:06 <lambdabot> Unknown command, try @listcommands.
10:17:15 <davidhouse> @where lambdabot
10:17:16 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
10:17:25 <davidhouse> dons, ping
10:21:58 <bolrod> hm.. why can't I do   'instance Something String where...'
10:22:12 <davidhouse> you can.
10:22:14 <bolrod> but I can do  'instance Something Char where'
10:22:28 <bolrod> I get
10:22:30 <bolrod>         (The instance type must be of form (T a b c)
10:22:30 <bolrod>          where T is not a synonym, and a,b,c are distinct type variables)
10:22:40 <davidhouse> oh, try [Char].
10:22:45 <bolrod> same thing
10:22:58 <astrolabe> @localtime dons
10:23:01 <lambdabot> Local time for dons is Sat Mar 25 05:23:21 2006
10:23:03 <ski> not haskell98
10:23:16 <davidhouse> that seems a rather major limitation
10:23:23 <bolrod> since its a list?
10:23:25 <davidhouse> not allowing Strings to be instances of things
10:23:38 <ski> either do -fglasgow-exts / -98 or make a newtype
10:23:47 <bolrod> how weird
10:24:32 <ski> 'instance Something String' really means 'instance Something [Char]', since 'String' is a type-synonym for '[Char]'
10:24:52 <davidhouse> what's wrong with a list of things being an instance of something?
10:24:56 <davidhouse> it seems a rather arbitrary limitation
10:25:20 <bolrod> and why can't I write 'instance Something [Char] where..' then?
10:25:26 <ski> '[Char]' is syntacic sugar for '[] Char'
10:25:27 <bolrod> gives the same error
10:25:34 <bolrod> my gawd..
10:25:39 <bolrod> lets try that
10:26:13 <ski> the valid instances are of form 'instance (Foo x y z ...)', where 'Foo' is a type-constructor, and 'x y z ...' are distinct type-variables
10:26:22 <davidhouse> why?
10:26:33 <davidhouse> why not allow more complicated type constructors?
10:26:47 <ski> i guess it was a simple restriction ..
10:26:56 <ski> ghc and hugs implement extensions to this
10:27:01 <davidhouse> yeah.
10:27:36 <bolrod> urh
10:27:37 <ski> possibly it was not fully clear how many extenstions could be made to work nice with inference-algorithms, etc
10:27:38 <bolrod>     Illegal instance declaration for `Something [Char]'
10:27:38 <bolrod>         (The instance type must be of form (T a b c)
10:27:38 <bolrod>          where T is not a synonym, and a,b,c are distinct type variables)
10:27:38 <bolrod>     In the instance declaration for `Something ([] Char)'
10:27:49 <bolrod> yep.. still doesn't work..
10:27:49 <davidhouse> most extensions provide functionality along the lines of "that's a nice idea, we could have implemented that in the core compiler" but this one seems more like "let's impose some arbitrary limitation for no reason and force extensions to deal with it"
10:27:52 <ski> so, this sortof was a "safe spot" .. i assume
10:28:19 <bolrod> okthen... how would you solve this then?
10:28:25 <ski> bolrod : i only explained above the error message ("The instance type must be of form (T a b c) ...")
10:28:34 <ski> <ski> either do -fglasgow-exts / -98 or make a newtype
10:29:11 <ski> newtype MyString = MS String
10:29:36 <ski> possibly deriving instances for standard classes like 'Eq','Ord', etc ...
10:29:54 <ski> instance Something MyString
10:30:09 <ski> this is using a newtype
10:30:20 <ski> the other solution was to enable extensions in ghc / hugs
10:30:21 <bolrod> yes... but then it would match MyString.. and not String ?
10:30:47 <bolrod> anyway.. not that I really needed this.. but still.. I wondered why it wasn't working.. I thought I'd 'test' something simple
10:31:05 <ski> yes .. using a newtype has the disadvantage that you have to wrap and unwrap the constructor 'MS'
10:31:25 <ski> bolrod : did you try enabling extensions, yet ?
10:31:38 <bolrod> I'll try now
10:32:45 <bolrod> well.. it just compiles fine with the extensions
10:34:29 <bolrod> I'm not going to use the extensions anyway..
10:34:31 <bolrod> but thx :)
10:34:46 <ski> np
10:38:16 <bolrod> yeah.. some assignment... doesn't say I may use the extensions :)
10:39:35 <bolrod> ./win 10
10:39:38 <bolrod> oops
10:54:35 * davidhouse yawns
10:54:38 <davidhouse> i need a project.
10:54:49 <davidhouse> i always need a project. i'm rubbish at coming up with project ideas.
10:56:03 <astrolabe> What kind of thing interests you?
10:57:38 <davidhouse> good question :)
10:57:51 <davidhouse> i've come from a web development background, but that's not necessarily where i'd like to stay.
10:58:11 <davidhouse> i'd like to write something useful rather than something just academic
10:58:43 <davidhouse> i'm also interested in mathematics, but beyond mathematica-like systems there's not much that could be done there
10:59:33 <Pupeno> Hello.
10:59:59 <Pupeno> davidhouse: most free projects need help.
11:00:04 <Pupeno> [OT] anybody worked with IBM mainframes ?
11:00:28 <davidhouse> Pupeno: yep, which is also why i've been asking if anyone has any recomendations there
11:02:04 <Pupeno> davidhouse: take a look at http://savannah.gnu.org/people/
11:02:34 <davidhouse> Pupeno: well, i want a haskell project
11:02:43 <Pupeno> davidhouse: http://sf.net has a similar list.
11:03:07 <shapr> w00, stupid Plone bug found and worked around! I kick so much butt!
11:03:50 <davidhouse> if anyone does have any haskell projects they need a (somewhat inexperienced) contributor for, let me know.
11:03:50 <shapr> davidhouse: It used to do info, but that ended up being total spam.
11:03:59 <shapr> davidhouse: There are many, jump on in!
11:04:02 <davidhouse> right. i have to go.
11:07:23 <malig> does anyone know of a good reference for implementing data structures *on disk*?  how is it typically done, by just storing offsets where you'd store pointers in a memory-based structure?
11:13:14 <sebell> malig: What kind of data structures?
11:13:24 <shapr> I usually use HaskellDB =)
11:13:52 <shapr> What about an inverse index?
11:14:11 <shapr> malig: Or maybe SerTH?
11:14:22 <shapr> What's the purpose of the on-disk structures?
11:23:20 <malig> a B-tree... I could just use HaskellDB, but it suddenly hit me that I have no idea how data structures should be implemented on disk :P
11:28:22 <astrolabe> Maybe use XML?
11:30:27 <Korollary> blasphemy
11:30:56 <int-e> I'm sure XML solves some problem. But I have yet to figure out which one.
11:31:19 <Korollary> it definitely solves the buzzword-with-x problem.
11:31:23 <sieni> "I used to have a problem and decided to solve it with XML. Now I have two problems"
11:31:47 <sieni> XML is tolerable with Scheme, since you can use Oleg's SXML tools
11:34:17 <flux__> if xml doesn't solve your problem, you aren't using enough of it.
11:35:21 <astrolabe> I thought I was the one who couldn't understand what XML was for!  I just reasoned that it must be for something, so maybe it was for this.
11:37:05 <Philippa> XML solves the problem of convincing managers there's a commonish set of interoperable tools
11:37:21 <astrolabe> I wanted to store a tree structure on a disk once, and I used an ad-hoc sort-of RPN format in a text file.
11:37:46 <malig> hmm, hooray for open source... sqlite describes how they do it, I'll assume they're at least mostly on track
11:39:56 <astrolabe> This channel is wierd.  I said once on it that I didn't understand the point of XML, and I got lots of responses (that I didn't really understand) explaining it to me.  Now when I suggest that it might be useful for something, there are lots of responses explaining that it is useless.  :)
11:42:04 <Philippa> it's both
11:43:30 <palomer> Philippa: is there any simple way to see if a case statement is exhaustive?
11:43:56 <Philippa> palomer: for what value of "case statement"?
11:44:21 <Philippa> for a simple non-nested one you just check you've got a case for each constructor
11:44:33 <Philippa> you should be able to generalise from that - guards're trickier
11:44:46 <Philippa> (because then you're checking that at least one predicate is always true...)
11:44:59 <palomer>  oh, I don't bother with guards
11:45:08 <palomer> nested patterns
11:45:12 <palomer> and I can't expand it
11:47:27 <palomer> actually, wait, it's easy to check
11:47:37 <palomer> since I have the type of the scrutinee
11:59:52 <Philippa> yep :-)
12:22:34 <shapr> I have to find some way to better organize my research papers.
12:23:10 <gzl> by subject, by date ?
12:24:41 <shapr> I have way too many for that.
12:25:14 <shapr> I need something that organizes by all of them.
12:25:41 <shapr> I also want to be able to click on references like weblinks, and get the reference in context.
12:25:47 <shapr> as well as backtracking of the same.
12:27:04 <palomer> pfft
12:27:13 <palomer> I just spent a week writing a state of the art midi parser
12:27:19 <palomer> when one was already written
12:27:30 <palomer> oh brother
12:27:51 <shapr> Hey, you learned lots, right?
12:28:13 <palomer> well, erm, a little
12:28:18 <palomer> it's the second time I write one
12:28:23 <palomer> and I know the midi standard like the back of my hand
12:28:47 <palomer> I learned more about c++ design
12:28:58 <Philippa> I tend to treat it more like the back of my used toilet paper
12:29:32 <Philippa> gotta love it when lack of bandwidth means you can even run a single drum machine off just one connection without noticable desync
12:29:36 <Philippa> *can't
12:31:05 <palomer> I can't find the thread of this conversation
12:31:17 <Philippa> "it" = the midi standard
12:31:18 <palomer> what do you use like the  back of your used toilet paper?
12:31:21 <palomer> ah
12:31:23 <palomer> and how is that?
12:31:27 <Philippa> "shit"
12:31:39 <Philippa> I'm being unnecessarily snarky in fairness
12:32:00 <Korollary> Isnt there a modern alternative to midi?
12:32:06 <Philippa> but hey. Most of my background's in tracking
12:32:10 <shapr> mp4?
12:32:13 <shapr> supercollider?
12:32:16 <Korollary> fasttracker2 baby
12:32:22 <Philippa> Korollary: for which purposes?
12:32:35 <Korollary> for the purposes people use midi. afaik that thing is 20 years old?
12:32:52 <Philippa> most stuff keeps the logical layer, maybe uses 14-bit NRPNs for resolution and shoves it over a different cable with more bandwidth (MLAN does some of that, for example)
12:34:44 <reltuk> http://blog.moertel.com/articles/2006/03/23/the-perfect-shuffles-puzzle-solved-in-haskell  <--- cool
12:34:45 <Philippa> I was more an IT type, btw :-)
12:35:23 <Korollary> I knew a bit about protracker in my amiga days
12:40:36 <ihope> Is there a function to convert [1,2,3,4,5] into [1,3,5]?
12:40:56 <Philippa> been playing with Renoise more recently. FT2-like that does MIDI and VST(i)
12:41:02 <lightstep> ihope, do you want every second element?
12:41:33 <ihope> lightstep: well, not just every second element. Maybe every fifth in some cases, or every third...
12:41:48 <ihope> @hoogle Integer -> [a] -> [a]
12:41:49 <lambdabot> Data.List.tail :: [a] -> [a]
12:41:49 <lambdabot> Data.List.init :: [a] -> [a]
12:41:49 <lambdabot> Data.List.reverse :: [a] -> [a]
12:41:54 <ihope> @hoogle Int -> [a] -> [a]
12:41:55 <lambdabot> Data.List.take :: Int -> [a] -> [a]
12:41:55 <lambdabot> Data.List.drop :: Int -> [a] -> [a]
12:41:55 <lambdabot> Prelude.take :: Int -> [a] -> [a]
12:42:05 <palomer> the midi standard is quite good at what it does
12:42:30 <palomer> which isn't very much, admittedly
12:42:36 <ihope> Heh.
12:42:42 <palomer> or, rather, it's very good for a subset of what it does
12:43:10 <Cale> > map snd . filter (even . fst) . zip [0..] $ [1..10]
12:43:11 <lambdabot> [1,3,5,7,9]
12:43:48 <ihope> Um.
12:44:09 <lightstep> @type \n -> unfold $ \list -> Just (head list, drop n list)
12:44:10 <lambdabot> Not in scope: `unfold'
12:44:24 <lightstep> @type \n -> Data.List.unfoldr $ \list -> Just (head list, drop n list)
12:44:24 <lambdabot> forall a.
12:44:24 <lambdabot>                        Int -> [a] -> [a]
12:44:33 <ihope> Aha. Thanks
12:44:45 <Cale> > map snd . filter ((== 0) . (`mod` 3) . fst) . zip [0..] $ [1..10]
12:44:46 <lambdabot> [1,4,7,10]
12:44:47 <lightstep> i only prooved it correct, didn't check it
12:44:53 <ihope> :-)
12:45:46 <lightstep> and it doesn't work
12:46:04 <Cale> My method is good when you want to do various things based on the index of an element in the list.
12:46:36 <lightstep> my method is good when you want to be bird-like
12:47:13 <lightstep> (the bug is that you need to check the empty list in the internal function in the unfold)
12:47:42 <Cale> It's unfortunate that unfoldr is so unwieldy.
12:48:36 <lightstep> yes
12:49:18 <lightstep> someone on a scheme list boasted once that she had a macro that generated the various folds she needed on the spot
12:49:32 <lightstep> list folds, not generic ones
12:49:53 <Cale> what exactly does that mean then?
12:50:05 <reltuk> Cale: that she does the same type of thing over and over
12:50:23 <lightstep> i don't know. perhaps things like separating the predicate from the generator, or something.
12:50:42 <Cale> hmm
12:51:50 <lightstep> but i didn't ask at the time
12:53:03 <Cale> There are a bunch of different list folds, but I can't see how you'd ever be able to just infer which one was needed, so it would have to take some description of the fold as input too.
12:53:40 <Cale> I hardly ever use anything other than foldr
12:54:14 <Cale> Though in scheme, I suppose that due to strictness, you'd want foldl more often.
12:55:46 <kosmikus> SyntaxNinja: got your mail, thanks
12:57:42 <lightstep> i wonder why the new time library represents the second fraction as Fixed E12 instead of Double
12:58:49 <TuringTest> Double's cannot be accurately compared
12:58:58 <TuringTest> especially for equality
12:59:23 <TuringTest> > map head $ takeWhile (not . null) $  unfoldr (Just . splitAt 3) [0..30]
12:59:24 <lambdabot> [0,3,6,9,12,15,18,21,24,27,30]
13:00:48 <lightstep> TuringTest, they can, if you only use a subset of them with few significant bits in the mantissa (like if you only use multiples of 1e-12)
13:01:16 <TuringTest> Which is equivalent to a Fixed precision type, is it not?
13:01:51 <lightstep> yes, except it's a standard numeric type
13:02:28 <lightstep> saying that time comes in quanta of picoseconds seems strange
13:03:29 <TuringTest> Unless you are me, that should be accurate enough.
13:04:01 <TuringTest> (I am working with 10 fs long pulses of laser light)
13:04:24 <TuringTest> > 2^64
13:04:24 <lambdabot> 18446744073709551616
13:04:36 <TuringTest> 2^64 * (10^(-12))
13:04:39 <lightstep> what does the f in fs stand for?
13:04:52 <TuringTest> fempto
13:05:00 <TuringTest> (10^-15)
13:05:17 <TuringTest> > (2^64) % 1
13:05:18 <lambdabot> 18446744073709551616%1
13:05:23 <TuringTest> > (2^64) % (10^12)
13:05:24 <lambdabot> 4503599627370496%244140625
13:06:13 <TuringTest> > fromRational ( (2^64) % (10^12) ) :: Double
13:06:14 <lambdabot> 1.844674407370955e7
13:06:34 <TuringTest> > (fromRational ( (2^64) % (10^12) ) :: Double) / 60 / 60 / 24
13:06:35 <lambdabot> 213.50398233460132
13:06:57 <TuringTest> Hmmm... 2^64 pico seconds is less than a year.
13:07:05 <ptolomy_> Say I have two lists and I want to return Maybe ListItem where ListItem is the first element in the second list that is not equal to the first. Is there a clean-and-efficient way of doing this with the Maybe monad?
13:07:23 <TuringTest> Maybe
13:07:37 <TuringTest> Are you comparing the two lists element by element ?
13:07:48 <ptolomy_> Yeah.
13:08:12 <TuringTest> > zipWith (\a b -> (comparing a b, b)) [1,2,3,4] [1,2,4,4]
13:08:13 <lambdabot>  Not in scope: `comparing'
13:08:19 <TuringTest> > zipWith (\a b -> (compare a b, b)) [1,2,3,4] [1,2,4,4]
13:08:20 <lambdabot> [(EQ,1),(EQ,2),(LT,4),(EQ,4)]
13:08:23 <lightstep> ptolomy_, you can use zipWith and than catMaybe
13:08:47 <TuringTest> zipWith (\a b -> (if eq /= compare a b then Just  b else Nothing)) [1,2,3,4] [1,2,4,4]
13:08:52 <TuringTest> > zipWith (\a b -> (if eq /= compare a b then Just  b else Nothing)) [1,2,3,4] [1,2,4,4]
13:08:52 <lambdabot>  Not in scope: `eq'
13:09:09 <TuringTest> > catMaybe $ zipWith (\a b -> (if EQ /= compare a b then Just  b else Nothing)) [1,2,3,4] [1,2,4,4]
13:09:10 <lambdabot>  Not in scope: `catMaybe'
13:09:16 <TuringTest> >  zipWith (\a b -> (if EQ /= compare a b then Just  b else Nothing)) [1,2,3,4] [1,2,4,4]
13:09:17 <lambdabot> [Nothing,Nothing,Just 4,Nothing]
13:09:21 <lightstep> @hoogle catMaybe
13:09:21 <lambdabot> Data.Maybe.catMaybes :: [Maybe a] -> [a]
13:09:41 <TuringTest> >  Data.Maybe.catMaybes $  zipWith (\a b -> (if EQ /= compare a b then Just  b else Nothing)) [1,2,3,4] [1,2,4,4]
13:09:42 <lightstep> @hoogle listToMaybe
13:09:42 <lambdabot> [4]
13:09:43 <lambdabot> Data.Maybe.listToMaybe :: [a] -> Maybe a
13:09:49 <TuringTest> >  head $  Data.Maybe.catMaybes $  zipWith (\a b -> (if EQ /= compare a b then Just  b else Nothing)) [1,2,3,4] [1,2,4,4]
13:09:50 <lambdabot> 4
13:10:09 <lightstep> listToMaybe is like head, but doesn't crash
13:10:12 <int-e> EQ /= compare a b ... why not a /= b ?
13:10:26 <TuringTest> >  listToMaybe $  Data.Maybe.catMaybes $  zipWith (\a b -> (if EQ /= compare a b then Just  b else Nothing)) [1,2,3,4] [1,2,4,4]
13:10:27 <lambdabot> Just 4
13:10:32 <lightstep> it should use ExceptM, though
13:10:35 <TuringTest> int-e: True
13:11:05 * ptolomy_ had no idea that catMaybes existed.
13:11:07 <TuringTest> >  listToMaybe $  Data.Maybe.catMaybes $  zipWith (\a b -> (if a /= b then Just  b else Nothing)) [1,2,3,4,5] [1,2,4,4,7]
13:11:08 <lambdabot> Just 4
13:11:19 <TuringTest> >  listToMaybe $  Data.Maybe.catMaybes $  zipWith (\a b -> (if a /= b then Just  b else Nothing)) [1,2,3] [1,2]
13:11:20 <lambdabot> Nothing
13:12:00 <lightstep> @pl listToMaybe . Data.Maybe.catMaybes
13:12:01 <lambdabot> listToMaybe . Data . Maybe . catMaybes
13:12:24 <lightstep> sequence $ zipWith (\a b -> (if a /= b then Just  b else Nothing)) [1,2,3,4,5] [1,2,4,4,7]
13:12:30 <TuringTest> >  listToMaybe $  catMaybes $  zipWith (\a b -> (if a /= b then Just  b else Nothing)) [1,2,3] [1,2]
13:12:31 <lambdabot> Nothing
13:12:42 <lightstep> > sequence $ zipWith (\a b -> (if a /= b then Just  b else Nothing)) [1,2,3,4,5] [1,2,4,4,7]
13:12:43 <lambdabot> Nothing
13:12:58 <lightstep> > msum $ zipWith (\a b -> (if a /= b then Just  b else Nothing)) [1,2,3,4,5] [1,2,4,4,7]
13:12:59 <TuringTest> That dies at the first maybe ?
13:12:59 <lambdabot> Just 4
13:13:09 <lightstep> > msum $ zipWith (\a b -> (if a /= b then Just  b else Nothing)) [1,2,3,4,5] [1,2]
13:13:10 <TuringTest> Ohhh.....that is nice
13:13:10 <lambdabot> Nothing
13:13:46 <TuringTest> >  msum $  zipWith (\a b -> (if a /= b then Just  b else Nothing)) [1,2,3,4,5] [1,2,4,4,7]
13:13:47 <lambdabot> Just 4
13:13:51 <lightstep> @type msum $ zipWith (\a b -> if a /= b then Just  b else Nothing)
13:13:52 <lambdabot> Not in scope: `msum'
13:14:07 <TuringTest> mplus (Just 1) (Just 2)
13:14:13 <TuringTest> > mplus (Just 1) (Just 2)
13:14:14 <lambdabot> Just 1
13:14:16 <int-e> > fmap snd $ listToMaybe $ filter (uncurry (/=)) $ zip [1..] [1,2,4,4,7]
13:14:17 <lambdabot> Just 4
13:15:47 <TuringTest> That is more efficient, int-e
13:16:05 <lightstep> maybe zip [1..] should be in the standard libraries
13:16:33 <int-e> hmm. zip [1..] is quite short
13:17:26 <lightstep> oh, for some reason i thought that the precedence wasn't high enough
13:17:52 <TuringTest> Or zip [0..]
13:18:11 <TuringTest> @
13:18:14 <TuringTest> @type EnumFrom
13:18:15 <lambdabot> Not in scope: data constructor `EnumFrom'
13:18:25 <TuringTest> @type from
13:18:25 <lambdabot> Not in scope: `from'
13:18:33 <TuringTest> @type enumFrom
13:18:34 <lambdabot> forall a. (Enum a) => a -> [a]
13:18:36 <TuringTest> ah
13:18:41 <int-e> @pl [1..]
13:18:42 <lambdabot> [1..]
13:18:44 <int-e> hmm
13:18:51 <int-e> @pl \x -> [x..]
13:18:52 <lambdabot> enumFrom
13:19:02 <TuringTest> @type zip  (enumFrom 1)
13:19:03 <lambdabot> forall a b. (Enum a, Num a) => [b] -> [(a, b)]
13:20:53 <int-e> @hoogle Bool -> a -> Maybe a
13:20:53 <lambdabot> Data.Maybe.Just :: a -> Maybe a
13:20:53 <lambdabot> Prelude.Just :: a -> Maybe a
13:26:36 <heatsink> can I make this function? map' :: (forall a. Foo a -> b) -> [forall a. Foo a] -> [Foo b]
13:27:01 <heatsink> The last part should be [b], not [Foo b]
13:27:24 <heatsink> ghc doesn't seem to like the forall inside the list.
13:31:51 <mathrick> what exactly is forall?
13:32:07 <mathrick> ghc seems to be using it in type definition, where hugs for instance doesn't
13:32:17 <mathrick> *definitions
13:32:21 <TuringTest> data Foo = Foo (forall a. a); type Fs = [Foo]
13:32:43 <astrolabe> It is an extension of the language I think
13:33:20 <TuringTest> type MAP' b = (Foo -> b) -> [Foo] -> [b]
13:35:38 <Korollary> forall is implicit in Haskell98. It's a ghc extension.
13:37:54 <TuringTest> data Foo = forall a. Foo a
13:37:55 <TuringTest> main = print (map (const '.') [Foo "Hello", Foo 0])
13:38:11 <TuringTest> The only sensible function for map is (const X)
13:43:06 <ihope> Is the totient of, say, 2^5 * 3^2 * 7 * 31 equal to 1 * 2^4 * 2 * 3^1 * 6 * 30?
13:54:51 <heatsink> TuringTest, the type variable 'a' is a phantom type.  Will it take up memory in each Foo object that way?
13:55:14 <heatsink> oh, you quit
14:01:31 <Lemmih> @seen shapr 
14:01:31 <lambdabot> shapr is in #hac, #haskell, #ScannedInAvian and #khjk. Last spoke 1 hour, 27 minutes and 9 seconds ago.
14:02:24 <heatsink> shapr has his own channel?
14:05:48 <ihope> Where?
14:06:39 <heatsink> #ScannedInAvian
14:06:49 <ptolomy_> @type fmap snd
14:06:49 <lambdabot> forall (f :: * -> *) a b.
14:06:49 <lambdabot>     (Functor f) =>
14:06:49 <lambdabot>     f (a, b) -> f b
14:07:01 <heatsink> that's the name of shapr's personal website
14:07:12 <malig> @seen mwolak
14:07:13 <lambdabot> I saw mwolak leaving #haskell 3 days, 17 hours, 55 minutes and 26 seconds ago.
14:14:57 <ptolomy_> Oye. I'd assert that it is more difficult to write working haskell when quite fatigued than most languages.
14:15:30 <jyp> wrong
14:15:35 <jyp> imho :)
14:15:49 <ptolomy_> Oye. I'd assert that it is more difficult to make reasonable assertions when quite fatigued than when not. :)
14:15:57 <Korollary> Heh
14:16:36 <jyp> I'd say, when fatigued enough, you never pass compilation stage in haskell
14:16:57 <jyp> whereas other lanugages let you write nonsense
14:17:51 <ptolomy_> Well, I suppose that for me, haskell still acts as sort of a fun brain teaser, where I try to figure out how to do things that are mundane in other languages in the most haskell-y way possible.
14:19:11 <jyp> Speaking of... Good night folks ;)
14:19:19 <ptolomy_> nite.
14:21:10 <ptolomy_> Do there exist any code review websites? Like, post some code, and people can annotate or something?
14:21:50 <ihope> I oughta finish that factorial function!
14:23:07 * Philippa finds it's easier to write haskell that's not going to make me wish I'd not written anything in the morning than it is most other languages
14:25:48 <ihope> Let's see here...
14:25:50 <ihope> \o/
14:25:50 <lambdabot> Maybe you meant: . id pl wn yow
14:28:40 <sjanssen> ihope: how about "product [1..n]"
14:28:53 <ihope> sjanssen: that's no fun...
14:29:19 <ptolomy_> @pl map (\x -> x 1)
14:29:20 <lambdabot> map ($ 1)
14:29:38 <palomer> hrmph
14:29:40 <ihope> This factorial won me Quote of the Week. I don't wanna quit this far into it :-)
14:29:44 * palomer wonders if pl is deterministic
14:29:55 <ihope> @pl map (\x -> x 1)
14:29:55 <lambdabot> map ($ 1)
14:29:57 <ihope> @pl map (\x -> x 1)
14:29:57 <lambdabot> map ($ 1)
14:30:15 <sjanssen> what was this quote?
14:30:30 <ihope> "My factorial function uses GADTs."
14:31:05 <Philippa> do they verify anything?
14:31:17 <Philippa> (is the GADT in question just the usual type for the natural numbers?)
14:31:32 <ihope> No, it's the datatype that one thread's "mailbox" uses.
14:31:44 <ihope> The GADT itself is pretty boring, really.
14:33:05 <ihope> Okay, the addition thread is done.
14:34:26 <palomer> ihope: where's your factorial function?
14:34:34 * palomer is always interested in GADTs, since it's what his thesis is on
14:34:35 <ihope> I'm still writing it.
14:35:12 <ihope> Let's see here...
14:35:25 <ihope> Succ x + y = x + Succ y
14:35:42 <ihope> Succ x * y = y + x * y
14:35:49 <ihope> That makes it work.
14:36:05 <palomer> factorial from scratch?
14:36:16 <ihope> Yep.
14:36:27 <ihope> Well, the MVars and stuff aren't written from scratch :-P
14:36:46 <sjanssen> MVars?  if you want to be really leet, you should use STM
14:37:14 <ihope> What's STM?
14:38:01 <sjanssen> Software Transactional Memory -- a monad to do concurrency in
14:38:07 <ihope> Ow.
14:38:20 <ihope> No thanks; I'll stick with my MVars.
14:39:27 <CJ^Sniper> For this program, how can i get the head included with the tail after the case matches (plz/thanks) ?
14:39:27 <CJ^Sniper> setVal :: Store -> (Variable, Data) -> Store
14:39:27 <CJ^Sniper> setVal ((a,b):ls) (c,d)
14:39:27 <CJ^Sniper> 	  | a == c = ((a,d):ls) 
14:39:27 <CJ^Sniper> 	  | otherwise = head setVal ls (c,d)
14:39:57 <ihope> Wait a minute, that multiplication function isn't tail recursive! Argh!
14:41:33 <ihope> I'm pretty much using CPS anyway, though. Hmm...
14:44:45 <Lemmih> CJ^Sniper: (a,b):setVal ls (c,d)?
14:49:13 <CJ^Sniper> cheers
14:49:38 <CJ^Sniper> i've been swearing over that one  with  +  ++ and everything else apart from concat with :     thanks once again
15:01:46 <CJ^Sniper> nite nite ppl   
15:14:07 <int-e> > let fac n = (\f -> (!! n) . iterate f) (\x p -> p (x (\a b f x -> a (b f) x)) (\f z -> x (\x y -> y) f (f z))) (\p -> p (\x -> x) (\x -> x)) (\x y -> x) (+1) 0 in map fac [1..6]
15:14:08 <lambdabot> [1,2,6,24,120,720]
15:14:58 <basti_> exactly.
15:16:46 <resiak> Is that not a somewhat ... roundabout method?
15:17:45 <int-e> maybe :)
15:18:13 <ptolomy_> > let fac = product . (enumFromTo 1) in map fac [1..6]
15:18:14 <lambdabot> [1,2,6,24,120,720]
15:18:55 <wenzel> nice
15:19:38 <SyntaxNinja> w00t
15:19:40 <int-e> ptolomy_: you can leave out the parens, too.
15:19:54 <ptolomy_> oh. Indeed I can.
15:20:02 <ptolomy_> > let fac = product . enumFromTo 1 in map fac [1..6]
15:20:03 <lambdabot> [1,2,6,24,120,720]
15:20:18 * ptolomy_ has a silly habit of forgetting how "." binds.
15:31:39 <ptolomy_> @pl map (\x -> if x then '*' else '-')
15:31:39 <lambdabot> map (flip (flip if' '*') '-')
15:35:34 <resiak> @type if'
15:35:35 <lambdabot> Not in scope: `if''
15:37:17 <ptolomy_> if' True x y = x \n if' False x y = y
15:37:41 <ptolomy_> if' :: Bool -> a -> a
15:37:44 <ptolomy_> (iirc)
15:45:50 <vincenz> hello
15:45:51 <vincenz> what's new
15:50:07 * ihope makes something new
15:50:09 <ihope> That.
16:01:49 <int-e> dons: I'm afraid lambdabot needs a restart ... that djinn problem that I gave it seems to be too big for it.
16:02:13 <dons> ok
16:02:26 <dons> I shouuld add a time limit to djinn too
16:02:29 * ihope giggles
16:02:40 <ihope> What was it, by the way?
16:02:40 <dons> my trick tricks to time limit everything didn't work for some unknown reason
16:03:02 <ihope> You trick *is*...?
16:03:20 <dons> \uptime
16:03:38 <lambdabot> uptime: 8 seconds
16:03:48 <int-e> ihope: (((((t3 -> t2) -> t4 -> t2) -> (t5 -> t4 -> t3) -> t1) -> ((t3 -> t2) -> t4 -> t3) -> (t5 -> t3 -> t2) -> t1) -> (t6 -> t7 -> t7) -> (t8 -> t8) -> (t9 -> t9) -> t) -> t ... I was curious if it could reconstruct the (lambda calculus) factorial function from that signature.
16:04:05 <ihope> Whoo.
16:04:18 * ihope runs it through his own Djinn
16:11:59 <int-e> funnily that function exhibits a bug in @pl
16:12:54 <ihope> By the way... that's not using Church numerals, is it? That'd be ((a -> a) -> a -> a) -> (a -> a) -> a -> a.
16:16:02 <lisppaste2> int-e pasted "pl bug" at http://paste.lisp.org/display/18249
16:16:59 <int-e> ihope: yes it does, but the a is instanciated with a more complicated type.
16:18:00 <stepcut> is there something like Data.Map that lets you have secondary indexes ?
16:18:43 <stepcut> I could just index the data several times -- but the values are big -- so it would be nice to make sure they are shared
16:19:58 <stepcut> I could also have the secondary key return the corresponding primary key -- but then I would have to do two lookups instead of one
16:26:59 <ihope> By the way... I found something that doesn't typecheck after going through @pl.
16:27:05 <ihope> It did typecheck before :-)
16:31:49 <ihope> > filter (\x -> x `gcd` 210 == 1) [1..210]
16:31:50 <lambdabot> [1,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,121,127,131,137,139,143,149,151,157,163,167,169,173,179,181,187,191,193,197,199,209]
16:32:19 <ihope> Now, most of those are prime...
16:33:12 <ihope> However, 1, 121, 143 and 169 are composite.
16:34:46 <int-e> 1 isn't composite.
16:35:54 <wenzel> 1 isn't prime either :)
16:36:01 <int-e> it's a unit
16:39:45 <ihope> I'd call it composite.
16:40:14 <ihope> Like 0 of something is plural.
16:40:47 * ihope "away"
16:59:25 <mwc> I don't know if I'd call one composite; 1x1 = 1? But that's trivial, since 7x1 = 7 would have all primes composite if we allow that
17:02:53 <Cale> 1 is neither composite, nor prime
17:02:56 <Cale> it's a unit
17:03:16 <mwc> I am so confused
17:03:26 <Cale> A unit u is a number such that there exists v such that u * v = 1
17:04:01 <Cale> A prime p is a number such that whenever p | a * b, we have that p | a, or p | b.
17:04:09 <mwc> No, I mean, I have some code that completely defies all logical sense
17:04:25 <Cale> okay
17:04:41 <Cale> Oh sorry, I should say...
17:04:51 <Cale> A prime p is a non-unit, non-zero number such that whenever p | a * b, we have that p | a, or p | b.
17:05:44 <mwc> http://rafb.net/paste/results/8XwaRJ48.html
17:05:58 <mwc> I don't know how that can be out of bounds
17:07:13 <mwc> debug/trace time
17:07:38 <mwc> Too bad ghci can't give me a dump of what values each binding has at the exception point
17:08:24 <Cale> nope
17:08:33 <Cale> ((xmin,ymin), (xmax,ymax))
17:08:38 <Cale> is what you want
17:08:44 <mwc> Hahaha, of course
17:09:42 <mwc> So sad that I couldn't spot that yesterday :(
17:18:05 <mwc> Thanks again, Cale 
17:57:26 <dons> \yow!
17:57:26 <lambdabot> I am a traffic light, and Alan Ginzberg kidnapped my laundry in 1927!
18:00:06 <Korollary> \keal
18:00:07 <lambdabot> Cale etc already pointed out Haskell is puny to nothing to emulate using my barrage of mathematic theories
18:30:26 <JKnecht> do few or most of the Haskell Heirarchial Libraries currently use Cabal?
18:31:27 <Korollary> ghc-pkg list
18:31:32 <Korollary> hm
18:33:03 <dons> all the standard libs do.
18:33:09 <dons> many external libs do too (most?)
18:33:33 <JKnecht> standard like ST, mtl, etc.?
18:33:57 <dons> and some external apps use it now too.
18:34:00 <dons> yep. those ones
18:34:16 <dons> and others, lke hs-plugins, hsx, fps, gtk2hs
18:34:19 <dons> c2hs
18:34:20 <dons> lots
18:35:10 <Igloo> Are you sure gtk2hs does?
18:35:21 <dons> ah, maybe it just has package.confs
18:35:26 <dons> you might be right there, Igloo
18:35:41 <dons> it _should_ 
18:35:46 <dons> dcoutts ^^
18:36:26 <dons> JKnecht, why do you ask?
18:38:06 <JKnecht> just looking bringing up Visual Haskell and was unclear if packages in list were based on CABAL, but then saw Haddock documentation showing they were. 
18:38:42 <JKnecht> would be great if there was a darcs Visual Studio project someplace.
18:47:32 <dons> hmm, I think there is 
18:47:41 <dons> or maybe it's darcs eclipse i'm thinking of
18:50:08 <JKnecht> well if darcs is cabal based should build directly in Visual Haskell if I understand correctly.
18:51:37 <JKnecht> don't expect the debugger to work but the browser would be worth the effort if it builds quickly.
18:52:50 <dons> oh, I see what you mean. darcs isn't cabal based.
18:53:08 <dons> I thought you wanted darcs support in Visudal Studio. not cabal build support for darcs.
18:56:26 <JKnecht> there is a how-to or something on using darcs instead of source safe?
19:00:20 <JKnecht> sorry, wrong #
19:02:34 <dons> darcs is petty easy to use.  check darcs.org for lots of info, tuts and such like.
19:04:58 <Korollary> cabal is sweet.
19:05:07 <Korollary> I dont know why I havent bothered with it
19:05:10 <Korollary> till now
19:05:30 <JKnecht> right I'm already using for sources of a .net prjct, but hadn't attempted VS integration.
19:06:30 <JKnecht> i don't think there is any.
19:08:49 <JKnecht> darcs should build under Visual haskell anyway  though even thogh it's  not a CABAL package since VHS is standard ghc 6.5.
19:10:25 <JKnecht> bbl
19:40:38 <vincenz> what's new ppl
19:40:39 <vincenz> Cale: hi
19:43:02 <Korollary> What kind of directory hierarchy is needed for cabal to have modules as A, A.B, etc? 
19:43:42 <dons> A/ A/B.hs
19:43:53 <Korollary> where do I put A.hs?
19:44:18 <dons> A.hs is in the top level
19:44:22 <dons> next to the directory, A
19:44:33 <dons> so: A/ A.hs       A/B.hs
19:44:48 <dons> if my crude attempt to draw this helps
19:44:52 <Korollary> I get it
19:45:05 <dons> e.g. I have:
19:45:06 <dons> Yi.hs
19:45:06 <dons> Yi:
19:45:07 <dons> Buffer.hs
19:46:35 <vincenz> dons: hi
19:46:51 <Korollary> can't find source for B in ["."]
19:47:19 <Korollary> oops
19:47:27 <Korollary> fixed the .cabal file. ok now.
19:47:35 <dons> heya
19:48:01 <vincenz> :)
20:12:14 <palomer> @type read
20:12:15 <lambdabot> forall a. (Read a) => String -> a
20:16:04 <Cale> vincenz: hi
20:18:16 <palomer> Read doesn't seem awfully useful
20:18:30 <Cale> hm?
20:18:36 <Cale> it's pretty useful, I think
20:18:50 <Cale> > read "57" :: Integer
20:18:51 <lambdabot> 57
20:18:56 <Korollary> Show & Read are pretty useful together
20:18:58 <palomer> useful for lambdabot
20:19:04 <palomer> but in MY code
20:20:03 <palomer> I can't, for example, read a string and pass it to something that requires an Int
20:20:14 <dons> it's very useful. why wouldn't it be?
20:20:18 <Cale> why not?
20:20:24 <Cale> > read "57" :: Int
20:20:26 <lambdabot> 57
20:20:40 <Cale> There's an instance of read for Int
20:21:16 <palomer> @type (\x -> (read x)::Int)
20:21:17 <lambdabot> String -> Int
20:23:27 <palomer> hrmph
20:23:34 <palomer> typeclasses are more intricate than I thought
20:23:39 <palomer> I should really learn the typing rules for typeclasses
20:23:40 <palomer> bbl
20:29:56 <ofelt_>  /nick
20:35:55 <dons> \dynamic-reload dummy
20:35:56 <lambdabot> module reloaded
20:36:04 <dons> \help palomer
20:36:04 <lambdabot> sound a bit like palomer on a bad day
20:36:14 <dons> \palomer
20:36:14 <lambdabot> hrmph
20:36:17 <dons> I told you I would!
20:36:25 <Cale> @palomer
20:36:26 <lambdabot> hrmph
20:36:34 <Cale> are there other sayings?
20:36:36 <Cale> @palomer
20:36:36 <lambdabot> hrmph
20:36:37 <dons> that's all it does  :}
20:36:48 <dons> maybe there are some others.
20:39:48 <vincenz> Cale: :)
20:39:52 <vincenz> Cale: check out @hac
20:39:53 <vincenz> @where hac
20:39:53 <lambdabot> http://haskell.org/haskellwiki/HAC
20:50:13 <Cale> cool
21:01:44 <dons> huh . wiki editing hass caused w3m to crash 2 times now
21:01:58 <dons> first time in 4 or 5 years of use its segfaulting on me
21:12:16 <vincenz> still nothing new on that page
21:27:01 <rasterfar> is a "bifunctor" the same thing as a "two-variable hom functor"?
21:28:28 <dons> palomer, were you asking about putting really big numbers into the type level?
21:28:41 <dons> i see that Rob Dockins lib supports up to 10^15, or so
23:51:53 <ski> rasterfar : a "bifunctor" is a "two-variable functor"
