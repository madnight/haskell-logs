00:19:41 <Lokadin_> say how would i use getLine as the argument for a function?
00:20:26 <Lemmih> Lokadin_: do line <- getLine; fn line
00:20:39 <Lokadin_> that's the only way? :(
00:20:51 <Lemmih> Or just "fn getLine" but that's probably not what you want.
00:21:11 <Lemmih> There's also: getLine >>= fn or fn =<< getLine.
00:21:41 <Lokadin_> kk :) i like that better
00:22:29 <Lokadin_> Not in scope: `<<='
00:22:31 <Lokadin_> :(
00:22:41 <adu> hi
00:22:51 <Lemmih> <<=?
00:24:03 <Lokadin_> oo
00:24:06 <Lokadin_> oops
00:25:55 <Lokadin_> getCont "." = ""
00:25:55 <Lokadin_> getCont x = x ++ getCont =<< getLine
00:26:25 <Lokadin_> :( doesn't work says it needs type [Char] but infers [Char -> Char]
00:26:46 <Lokadin_> what it's supposed to do is exit when input is equal to .
00:27:02 <Lemmih> getCont "." = return ""; getCont x = do c <- getCont =<< getLine; return (x ++ c)
00:27:09 <Lemmih> Lokadin_: You can't escape the IO monad.
00:27:40 <Lokadin_> so you have to have return statements?
00:27:54 <Lokadin_> is what you're saying?
00:28:03 <Lemmih> Yes.
00:28:25 <Lokadin_> kk :) thanks for clarifying that
00:38:25 <adu> is mauke here?
00:52:52 <ski> Lokadin_ : you can also do
00:52:58 <ski> getCont "." = return ""
00:53:02 <ski> getCont x   = liftM (x ++) (getCont =<< getLine)
00:54:21 <ski> or
00:54:23 <ski> getCont "." = return ""
00:54:47 <ski> getCont x   = return (++) `ap` (return x) `ap` (getCont =<< getLine)
00:55:12 <ski> though that last one is prolly not better in this case
00:56:07 <Lemmih> @pl getCont x = if x == "." then return "" else liftM (x ++) (getCont =<< getLine)
00:56:08 <lambdabot> getCont = fix (ap (flip if' (return []) . ("." ==)) . flip (fmap . (++)) .
00:56:08 <lambdabot> (getLine >>=))
00:57:34 <ski> Lemmih : ty
00:58:33 <ski> @pl getCont x = (getCont =<< getLine) >>= \x -> return (x ++ c)
00:58:34 <lambdabot> getCont = fix (const . ((++ c) `fmap`) . (getLine >>=))
00:58:44 <ski> @pl (getCont =<< getLine) >>= \x -> return (x ++ c)
00:58:44 <lambdabot> (++ c) `fmap` (getCont =<< getLine)
00:58:57 <ski> er
00:59:00 <ski> @pl (getCont =<< getLine) >>= \c -> return (x ++ c)
00:59:00 <lambdabot> (x ++) `fmap` (getCont =<< getLine)
00:59:17 <Lemmih> Lokadin_: You can also play with laziness: do inp <- getContents; putStrLn (unlines (takeWhile (/=".") (lines inp)))
00:59:19 <ski> @pl getCont x = (getCont =<< getLine) >>= \c -> return (x ++ c)
00:59:20 <lambdabot> getCont = fix (flip (fmap . (++)) . (getLine >>=))
01:02:04 <mathrick_> hmm
01:02:20 <mathrick_> > do x <- [10,20,30]; [x, x+1]
01:02:22 <lambdabot> [10,11,20,21,30,31]
01:03:08 <mathrick_> is the fact that the values come in order in any way caused/required by monads model? Or is it only the consequence of the fact that bulitin lists are processed in order?
01:03:56 <ski> what do you mean by 'come in order' ?
01:04:20 <ski> the nesting or the order of each list ?
01:04:23 <mathrick_> that first you get results coming from 10, then from 20, then from 30
01:04:43 <mathrick_> ski: the resulting list here
01:05:16 <ski> hm
01:05:37 <ski> fmap has to preserve order of list
01:05:57 <ski> ma >>= amb = join (fmap amb ma)
01:07:18 <ski> join . return = id .. so join (return [a0,...]) = join [[a0,...]]  and that must then be [a0,...]
01:07:30 <mathrick_> right
01:07:37 <ski> join . (fmap return) = id .. so join (fmap return [a0,...]) = join [[a0],...]  and that must then be [a0,...]
01:08:05 <ski> i'm wondering if this force 'join' to work as it usually does, for lists
01:08:18 <mathrick_> so the resulting order is wholly determined by the underlying model implemented by given monad, and it's predictable?
01:08:27 <ski> (instead of doing some permutation, when flattening, e.g.)
01:08:39 <mathrick_> ski: what is "it"?
01:09:09 <ski> "formal noun"
01:09:36 <mathrick_> heh
01:09:51 <mathrick_> right, I meant "this"
01:10:03 <mathrick_> <ski> i'm wondering if this force 'join' to work as it usually does, for lists <-- "this" in there
01:10:11 <ski> ah
01:10:14 <ski> well
01:10:22 <ski> join [[a0,...]] = [a0,...]
01:10:30 <ski> join [[a0],...] = [a0,...]
01:10:51 <ski> this is two special cases of the workings of 'join' in the usual list monad
01:11:08 <mathrick_> ah
01:11:45 <ski> join [[a_{0,0},a_{0,1},...],[a_{1,0},a_{1,1},...],...] = [a_{0,0},a_{0,1},...,a_{1,0},a_{1,1},...,...]
01:12:21 <ski> i was wondering if these two above (possibly together with other monad laws) force this latter
01:12:24 <mathrick_> what do you mean by {0,0} etc.?
01:12:32 <ski> indexing
01:12:44 <ski> (i.e. that was not haskell, instead meta-notation)
01:13:30 <ski> (if they don't force this latter, then there are other possible list monads)
01:14:07 <mathrick_> right
01:14:13 <mathrick_> that was exactly my question
01:14:22 <ski> ok
01:18:51 * ski stops trying to express the above property with more in-haskell notation
01:19:03 <mathrick_> :)
01:19:34 <ski> (i could do it, but too non-clear to be worth it)
01:19:35 * mathrick_ chews on another chunk of lakrids
01:20:03 <ski> (i was thinking to describe it with what '(!!)' would give)
01:20:07 <ski> mm
01:20:28 * ski wants salt-lakris
01:20:39 <mathrick_> yeah, it's awesome
01:20:48 <mathrick_> this is salmiak-lakrids tho
01:20:55 <ski> ah, also nice
01:21:01 <mathrick_> although I can't quite detect that salmiak :)
01:21:12 * ski seldom eats non-salt lakrits
01:21:30 * ski ponders what the proper spelling in swedish (and english) is
01:21:33 <mathrick_> salt lakrids is strong as hell
01:21:41 <mathrick_> ski: liquorice
01:21:50 <mathrick_> for the lakrids part
01:21:55 <ski> 'strong' meaning 'good' ?
01:22:01 <ski> ok
01:22:04 <mathrick_> ski: no, as in very strong taste
01:22:23 <ski> depends, i think
01:23:38 <mathrick_> ski: dunno, what I tried could adequatly be described by the danish word "staerk"
01:23:51 * mathrick_ wonders where his compose key went
01:24:53 <mathrick_> æ
01:24:55 <mathrick_> okay
01:26:36 <ski> ok
01:26:55 <ski> (prolly same as 'stark' in sv)
01:27:17 <mathrick_> you spell it stark or stärk?
01:30:52 <mathrick_> is it kill-3-letters-nicks day or what?
01:31:12 * mathrick_ counts his letters, just in case
01:31:24 <nothingmuch> ski is still here =)
01:35:29 <ski> hmm
01:35:48 * ski paranoidly looks around
01:55:56 <adu> hi ski
01:58:21 <ski> adu : what do you mean by 'does call/cc and monads fulfill similar use cases?' ?  (jethr0,twobitsprite,sieni)
01:58:23 <ski> hi adu
01:59:59 <adu> oh
02:01:13 <adu> well i figure that 1) they both have 'goto' characteristics 2) they both can be used for handleing errors, and 3) they pass values around in spooky ways
02:01:27 <adu> but I was wondering what other people thought
02:01:47 <ski> i don't see how monads have 'goto' characteristics, per se
02:02:04 <ski> though
02:02:05 <adu> if an error occurs it returns
02:02:19 <ski> that's just the workings of particular monads
02:02:26 <adu> oh
02:02:35 <ski> like 'Maybe' and 'Either err' monads
02:02:40 <adu> ic
02:02:44 <saintiss> hi all
02:02:48 <ski> though
02:02:58 <saintiss> is it possible to pass on a parameter of polymorphic type to a function which requires Int?
02:02:59 <adu> I've only had experience with Maybe and []
02:03:24 <ski> every implementable monad can be reflected into implicit side-effects, given composable continuations (or state and unbounded continuations)
02:03:34 <adu> and I still don't understand how [] is a monad
02:04:20 <ski> saintiss : no ... what would happen if you pass in something of type 'Double' to the polymorphic function ?
02:04:36 <gaal> hello, beginner CH question: I'm trying to find some interesting to say about, say map
02:04:38 <gaal> @t map
02:04:39 <lambdabot> Maybe you meant: time todo todo-add todo-delete topic-cons topic-init
02:04:39 <lambdabot> topic-null topic-snoc topic-tail topic-tell type .
02:04:44 <ski> adu : do you mean you don't understand how the monad laws are fulfilled ?
02:04:51 <gaal> @type map
02:04:52 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
02:05:09 <gaal> so, that's, like, trivial, because [b] is always true (because of [])
02:05:16 <ski> gaal : some interesting what ?
02:05:31 <ski> (aha, CH = Curry-Howard)
02:05:42 <ski> no
02:05:43 <gaal> ski: I'm trying to see some non-trivial proofs in action
02:05:58 <ski> s/no/yes/
02:06:03 <saintiss> ski, agreed, but you ARE able to create functions which e.g. only have a pattern for x > 0
02:06:13 <saintiss> ski, then when x < 0, you just get a pattern match failuer
02:06:24 <saintiss> so they could have done something similar for Double then?
02:06:31 <gaal> how do I deduce a from [a]? probably I can't, so okay, I invent
02:06:39 <ski> saintiss : but then they are not fully polymorphic anymore ..
02:06:50 <ski> gaal : right, you can't ..
02:06:59 <gaal> data List' a = Cons a (List' a)
02:07:03 <saintiss> ski, ok, but again, if I define a function Int -> Int, then only allow x > 0, then it's also not Int-> Int anymore
02:07:10 <gaal> that is, infinite lists only
02:07:24 <ski> gaal : usually called 'Stream'
02:07:26 <gaal> clearly, map' (which only operates on infinite lists) is sound
02:07:36 <gaal> but now I don't see the proof :)
02:07:39 <adu> ski: i understand how return and bind work for lists, but I don't know how to use it
02:07:47 <ski> saintiss : then it is a partial function from integers to integers
02:07:55 <gaal> ski: Stream works, okay
02:08:13 <gaal> how is List' a -> a proved?
02:08:31 <gaal> more generally: how are types composed in CH?
02:08:39 <ski> gaal : what do you mean ?
02:09:03 <gaal> ski: I can understand the logic side of, say, (.)
02:09:20 <saintiss> ski, right, so then why no "partial polymorphic" functions? :)
02:09:25 <ski> adu : hm .. you can use it for ("don't care" / "angelic") nondeterministic operations
02:09:27 <adu> whats CH?
02:09:41 <ski> adu : <ski> (aha, CH = Curry-Howard)
02:09:46 <gaal> ski: and if you tell me to interpret (,) as logical n-ary conjunction, sure, I understand the proof of (,) too
02:09:57 <adu> oh
02:10:21 <gaal> I guess I'm looking for the model for more complex types?
02:10:32 <ski> saintiss : because, this is parametric polymorphism .. so behaviour of function can't depend on which actual type is used in place of the type variable
02:11:00 <ski> gaal : i'm not sure what kind of proof you are after ..
02:11:32 <gaal> ski: well, let's take a simple example
02:11:36 <gaal> @type (,)
02:11:37 <lambdabot> forall b a. a -> b -> (a, b)
02:12:03 <gaal> "given a and b, (a,b)
02:12:04 <gaal> "
02:12:25 <gaal> sure, if I take "," to mean "and also", that's clearly a tautology
02:12:26 <ski> adu : i have an example file with computing permutations, using nondeterminism .. which you might be interested in looking at
02:12:39 <adu> ok
02:12:39 <gaal> or
02:12:43 <gaal> @type (.)
02:12:44 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
02:13:07 <adu> ski: is nondeterminism like not caring which order things happen?
02:13:29 <ski> adu : erm .. i said worng before
02:13:29 <gaal> okay, taking (b->c), (a->b), and a as premises, I use a and (a->b) to infer b;
02:13:40 <gaal> and then b and (b->c) to infer c;
02:13:43 <ski> s/don't care/don't know/
02:13:49 <gaal> and, okay, I'm done.
02:13:57 <ski> gaal : yes
02:14:10 <adu> ski: is it about order? or results? or run-time?
02:14:25 <adu> i've heard nondeterminism used lots of different ways
02:14:30 <ski> adu : nondeterminism is about having different number of possible results than 1
02:14:40 <gaal> so, mapStream :: (a -> b) -> Stream a -> Stream b
02:14:54 <ski> adu : there are basically two common ways for this
02:15:14 <adu> like random?
02:15:15 <gaal> unlike @type map, which is trivially sound because [b] always obtains (because of []), why is mapStream sound?
02:15:20 <ski> adu : "don't know" / "angelic" nondeterminism  :  you want all the possible results
02:15:41 <ski> adu : "don't care" / "demonic" nondeterminism  :  you want *some* of the possible results, don't care which
02:15:53 <adu> ok
02:16:23 <ski> adu : an example of the latter is race conditions in non-declarative concurrency (i.e. scheduling ordering affect result)
02:16:55 <ski> adu : random would be like latter too, sortof, exept there you usually also want sensible distributions
02:17:08 <adu> ya
02:17:13 <ski> adu : list monad is of the former kind
02:17:37 <adu> so it could be about ordering
02:17:40 <gaal> so it looks like I'm missing two pieces: how to infer a from Stream a; and how to infer Stream b from b
02:17:50 <ski> adu : exceptions in haskell is of the latter kind
02:18:14 <adu> like Maybe?
02:18:35 <ski> hm
02:18:42 <adu> do you mean Maybe by "exceptions"?
02:18:47 <ski> no
02:18:57 <ski> Maybe is of the former kind, except only 0 or 1 results
02:19:08 <ski> gaal : hmm
02:19:16 <adu> i thought Nothing or Just results
02:19:25 <ski> gaal : 'Stream a' is a coinductive type
02:19:33 <ski> @type Just
02:19:34 <lambdabot> forall a. a -> Maybe a
02:19:50 <ski> yes
02:20:02 <ski> 'Nothing" <- 0 results, 'Just x' <- 1 result
02:20:12 <adu> ok
02:21:01 <ski> <adu> so it could be about ordering
02:21:01 <ski> ?
02:21:07 <adu> so what is an example of angelic determinism?
02:21:12 <ski> list monad
02:21:21 <adu> but that only has a finite amount of things
02:21:23 <gaal> ski: what does coinductive mean? that by axiom, a -> Stream a   and   Stream a -> a ?
02:21:38 <adu> how could it represent an unknown about of things?
02:21:39 <saintiss> ski, ok thx
02:21:46 <ski> > [(+),(-)] `ap` [100,200] `ap` [1,10]
02:21:47 <lambdabot> [101,110,201,210,99,90,199,190]
02:22:23 <ski> gaal : it means that you can't (generally) build up values "from the bottom"
02:22:24 <adu> wha?
02:22:47 <gaal> ski: sure, because I don't have Nil. but mapStream surely is sound, no?
02:22:52 <ski> > do f <- [(+),(-)]; x <- [100,200]; y <- [1,10]; f x y
02:22:53 <lambdabot>  add an instance declaration for (Num [t])
02:22:53 <lambdabot>   In the list element: 10
02:22:53 <lambdabot>   In a 'do' expression: y <- [1, 10]
02:23:01 <ski> er
02:23:14 <ski> > do f <- [(+),(-)]; x <- [100,200]; y <- [1,10]; return (f x y)
02:23:15 <lambdabot> [101,110,201,210,99,90,199,190]
02:23:26 <ski> also
02:23:41 <adu> that isn't deterministic
02:23:44 <ski> > [f x y | f <- [(+),(-)], x <- [100,200], y <- [1,10]]
02:23:45 <lambdabot> [101,110,201,210,99,90,199,190]
02:23:48 <adu> i mean it is
02:23:50 <ski> right
02:24:11 <adu> that isn't nondeterministic
02:24:23 <ski> gaal : yes .. 'Stream' is inherently "lazy" one could say
02:24:34 <ski> adu : what do you mean ?
02:24:44 <adu> i don't know
02:24:50 <ski> we nondeterministically select a function, and two arguments for it
02:25:13 <ski> and we get all possible answers, for all possible selections in the nondeterministic choices
02:25:37 <adu> oooooooo so nondeterministic means multiple options?
02:26:00 <ski> <ski> adu : nondeterminism is about having different number of possible results than 1
02:26:01 <ski> yes
02:26:02 <gaal> ski: all right.. but still I don't see how that helps towards the proof of mapStream?
02:26:21 <ski> /= 1 means either 0 or more than 1
02:26:49 <adu> i thought you meant having "1" as a result or some other value
02:26:57 <ski> ah, sorry
02:27:00 <adu> i totally didn't understand you the first time
02:27:01 <ski> was maybe unclear
02:28:21 <ski> so, with "don't care" / "demonic" nondeterminism, the implementation would choose some selection, and commit/stick to that choice, only giving one result at top-level
02:28:27 <adu> when i usually think "nondeterministic" i think given an input x, theres no way to compute the output f(x)
02:28:43 <adu> this is totally different
02:28:51 <ski> maybe you're confusing it with 'nontermination' ?
02:29:24 <ski> (or 'partiality' ??)
02:29:26 <adu> no, because in regular language nondeterministic means theres no way to tell what is going to happen
02:29:51 <ski> i think this is the "don't care" / "demonic" kind
02:30:08 <ski> (at least as long as it doesn't do weird "undefined behaviour"-like things)
02:30:08 <adu> i suppose
02:30:53 <ski> as long as there's a set of possible results, and the implementation just computes one of those, it's the "don't care" kind
02:31:44 <ski> insert :: a -> [a] -> List [a]
02:31:46 <ski> select :: [a] -> List (a,[a])
02:32:12 <ski> adu : those are example nondeterministic operations (from my example file mentioned above)
02:32:27 <ski> first nondeterministically inserts an element "somewhere" into a list
02:32:56 <ski> second nondeterministically selects "some" element out of a list, also giving the rest of the list
02:33:11 <adu> so using monads somehow allow you to account for all cases at the same time?
02:33:13 <ski> (and 'type List a = [a]' just for readability)
02:33:45 <ski> adu : using "don't care"-nondeterministic monads, yes
02:34:10 <ski> mathematically, i guess the most "obvious" such would be the set monad
02:34:19 <adu> wouldn't that be "don't know"?
02:34:28 <ski> right
02:34:42 <adu> theres a Set Monad?
02:34:47 <ski> not in haskell
02:34:51 <adu> oh
02:34:54 <ski> but in math, there is
02:35:07 <adu> math has monads?
02:35:11 <musasabi> yes.
02:35:16 <ski> monads come from math
02:35:19 <adu> what branch?
02:35:26 <ski> (more specifically category theory)
02:35:31 <adu> ic
02:35:46 <musasabi> There is hopefully a Set Monad in a future version of Haskell which allows datatypes with restricted kinds or something similar.
02:35:51 <adu> i've only heard of morphisms from category theory
02:36:26 <adu> musasabi: restricted kinds?
02:36:52 <ski> gaal : hm, possibly you'd have a primitive 'unfold' form for streams
02:39:04 <ski> (adu : something like a kind "(a :: * *> Ord a) -> *" ..)
02:39:30 <adu> huh
02:40:13 <ski> adu : the problem is that the implementation of 'Set' in haskell requires 'Ord' (for efficiency .. at least 'Eq' is needed otherwise), and 'Monad' requires it's members to accept any type, not just types in 'Ord'
02:41:41 <ski> adu : anyway .. if you have composable continuations, then you can reflect any implementable monad, which is quite cool
02:42:48 <ski> hmm .. what was again the reason for no type-level lambdas ? .. higher-order unification ?
02:44:28 <adu> that does make things tricky
02:44:40 * ski wonders if some restricted thing .. like e.g. L-lambda (i think it was called), would be ok
02:45:08 <adu> i dunno
02:45:17 <ski> ('that' being ?)
02:45:21 <musasabi> ski: the typesystem being decidable I think.
02:45:43 <adu> ski: type-level lambdas
02:45:46 <ski> musasabi : yes, but due to what ?  higher-order unification or other issues also ?
02:45:51 <musasabi> "does this typelevel lambda terminate"
02:45:58 <musasabi> I think.
02:46:13 <adu> what do you mean by type-level lambdas anyway? do you mean functions that take types as arguments?
02:46:14 <ski> musasabi : hm .. doesn't well-kindedness ensure that ?
02:46:28 <ski> adu : no, i mean lambdas at type-level
02:46:30 <ski> like
02:46:46 <ski> instance Functor (\a -> Either a b)
02:47:25 <adu> ouch my brain hurts
02:47:30 * ski realizes that one probable complication is in non-ambiguity things
02:48:01 <ski> adu : hm ?
02:48:09 <ski> (as opposed to the normal
02:48:13 <ski> instance Functor (\b -> Either a b)
02:48:14 <ski> which is
02:48:19 <ski> instance Functor (Either a)
02:48:20 <ski> )
02:49:01 <adu> no
02:49:09 <adu> wouldn't that be like:
02:49:24 <adu> instance Functor (flip Either a)
02:49:31 <ski> right
02:49:37 <adu> only thats illegal
02:49:45 <ski> indeed
02:50:34 <adu> maybe you could find a way to do it and make it part of haskell 3.0
02:50:59 <ski> i wonder how to resolve ambiguity, then
02:51:26 <ski> there can be a lot of decompositions of 'tau' into 'tau0 tau1'
02:51:33 <ski> so, if you have
02:51:39 <adu> er i meant something like Haskell '07...
02:51:54 <ski> \(x :: Either Int Int) -> fmap foo x
02:51:55 <lambdabot> Maybe you meant: . id pl wn
02:52:15 <ski> do you mean to map over left or right part ?
02:54:05 <adu> but that isn't mapable
02:54:18 <ski> @poll-list *
02:54:18 <lambdabot> ["DoesSunGoAroundTheEarth_HowOften","ShouldWeVoteMore","VincenzKoan","
02:54:18 <lambdabot> WhatCommandPrefixShouldLambdabotUse?"]
02:54:27 <ski> @poll-show WhatCommandPrefixShouldLambdabotUse?
02:54:27 <lambdabot> ["\"","-","|","`",".","%",":","~","/","&","\\","$","!","#","@"]
02:55:09 <ski> @choice-add WhatCommandPrefixShouldLambdabotUse? not \
02:55:10 <lambdabot> usage: @choice-add <poll> <choice>
02:55:19 <ski> @choice-add WhatCommandPrefixShouldLambdabotUse? "not \\"
02:55:19 <lambdabot> usage: @choice-add <poll> <choice>
02:55:31 <ski> @choice-add "WhatCommandPrefixShouldLambdabotUse?" "not \\"
02:55:31 <lambdabot> usage: @choice-add <poll> <choice>
02:55:36 <ski> bah
02:55:47 <ski> adu : hm ?
02:56:08 <adu> i know!
02:56:19 <adu> how about a type-level Flip?
02:56:42 <ski> you can 'newtype' a such, yes
02:56:59 <ski> (but one'd like kind-polymorphism for that)
02:57:30 <adu> what do you mean "one'd"?
02:57:40 <ski> "one would"
02:57:45 <adu> o
02:57:46 <adu> ok
02:58:00 <ski> instead of just
02:58:10 <ski> Flip :: (* -> * -> *) -> * -> * -> *
02:58:13 <ski> we'd like
02:58:39 <ski> Flip :: forall k0 k1. (k1 -> k0 -> *) -> k0 -> k1 -> *
02:58:41 <ski> or even
02:58:52 <ski> Flip :: forall k0 k1 k2. (k1 -> k0 -> k2) -> k0 -> k1 -> k2
02:59:06 <ski> (hm, not sure about last one)
02:59:28 <integral> so we'd need simply typed lambda calculus at the kind level,  but then we'd want a kind level Flip...
02:59:49 <adu> ooo
03:00:08 <ski> integral : we haven't proposed lambda at kind-level, yet, have we ?
03:00:10 <adu> they ARE revising haskell...
03:00:30 <integral> ski: not *yet* 8-)
03:01:21 * ski ponders
03:02:22 <ski> newtype Flip (f :: k1 -> k0 -> *) (a :: k0) (b :: k1) = MkFlip (f b a)
03:02:24 * adu cheers ski on
03:02:54 <adu> ponder away my friend, you may be onto something!
03:02:57 <ski> newtype Flip :: (k1 -> k0 -> *) -> k0 -> k1 -> *
03:02:59 <ski>   where
03:03:22 <ski>   MkFlip :: forall k0 k1. f k1 k0 -> Flip f k0 k1
03:03:29 <ski> er
03:03:59 <ski>   MkFlip :: forall f (a :: k0) (b :: k1). f b a -> Flip f a b
03:04:21 <ski> or just
03:04:28 <ski>   MkFlip :: f b a -> Flip f a b
03:04:55 <ski> but can we somehow generalize the result kind '*' into 'k2' ?
03:05:45 <adu> where is k2? i don't see any k2
03:05:45 <ski> hm, in type of 'MkFlip', we have 'f b a :: *' and 'Flip f a b :: *'
03:05:58 <ski> <ski> Flip :: forall k0 k1 k2. (k1 -> k0 -> k2) -> k0 -> k1 -> k2
03:06:23 <ski> adu : because i haven't put it in there, yet
03:06:32 <adu> ok
03:06:58 <ski> so, generalizing, and changing nothing more, we get
03:07:11 <ski> MkFlip :: ..blah.. -> ..bleh..
03:07:13 <ski> with
03:07:19 <ski> ..blah.. :: k2
03:07:22 <ski> ..bleh.. :: k2
03:07:28 <ski> this is not valid
03:07:49 <ski> since '(->) :: * -> * -> *' (ignoring GHC's extension)
03:08:10 <ski> but, hm
03:08:39 <ski> 'newtype' generates a type, which is isomorphic to a type
03:08:49 <ski> and the kind there is '*'
03:09:38 <ski> so, could we somehow generate an iso/newtype for types whose kinds are not '*'
03:10:04 <ski> this is like asking above isomorphisms in other categories than our base category
03:10:09 <ski> e.g. functor categories
03:10:42 <adu> igtg
03:11:08 <ski> (i wonder if one could do something with natural transformations)
03:11:36 <ski> s/above/aout/
03:11:44 <ski> s/aout/about/
03:14:36 * ski realizes he used scoped-kind-variables, from a result-type-pattern :)
03:18:03 * beelsebob_ wonders if there's a way to hack a simple dependant type into haskell
03:18:48 <beelsebob_> I want to specify data Dependancy = Dependancy [Node] ([Float] -> Float) where the length of the two lists is equal
03:19:51 <jethr0> beelsebob_: the evil way would to hide the constructor and supply a constructing function that only accepts lists of equal length
03:19:52 <alar> beelsebob: Oleg should know one
03:20:01 <jethr0> but that's far from a dependent type :)
03:20:07 <beelsebob_> jethr0: indeed
03:20:19 <ski> GADT ?
03:20:23 <integral> see TMR for an oleg produced vector type with the length in the type
03:20:28 <beelsebob_> and anyway - it's a function, not a list in the second argument
03:20:49 <jethr0> ah, right
03:21:09 <ski> data List :: * -> * -> *
03:21:11 <ski>   where
03:21:21 <jethr0> you could use a _huge_ tuple, but that's even more evil
03:21:26 <ski>   Nil :: List Zero a
03:21:33 <beelsebob_> heh
03:21:41 <ski>   Cons :: a -> List n a -> List (Succ n) a
03:21:48 <beelsebob_> ah - interesting
03:22:13 <beelsebob_> that's very useful ski
03:22:23 <beelsebob_> so List 5 would then be a type?
03:22:24 <ski> data Dependancy = forall n. Dependancy (List n Node) (List n Float -> Float)
03:22:29 <integral> (see http://www.haskell.org/tmrwiki/NumberParamTypes)
03:22:34 <beelsebob_> that's very very neet
03:22:41 <ski> beelsebob_ : no
03:22:44 <integral> ski: don't you mean "exists" not "forall"?
03:22:54 <beelsebob_> sorry - a type schema
03:23:09 <ski> 'List (Succ (Succ Zero)) Int' would be type of lists of length two, of ints
03:23:22 <ski> integral : no
03:23:56 <ski> integral : i assumed beelsebob_ wanted 'Dependency :: forall n. List n Node -> (List n Float -> Float) -> Dependency'
03:24:11 <jethr0> ski: so, are Zero and Succ type constructors??
03:24:12 <beelsebob_> ski: I do, I think
03:24:14 <integral> hmm
03:24:19 <ski> jethr0 : yes
03:24:41 <ski> jethr0 : better would be for them to belong to another kind than '*', of course
03:25:11 <jethr0> so one could calculate the factorial in type space :). just like in good old C++ templates, right?
03:25:51 <sieni> argh :-)
03:25:51 <jethr0> how would one define Succ and Zero then?
03:25:53 <ski> jethr0 : i believe one can already compute factorial with multi-arg classes with fun.dep.s
03:26:04 <ski> data Zero
03:26:08 <ski> data Succ a
03:26:10 <ski> e.g.
03:26:16 <jethr0> k
03:26:27 <ski> (you could add points, too, for convenience)
03:27:15 <ski> jethr0 : though, i don't see, right now, how to compute factorial with GADTs (though, it could possibly be done)
03:28:18 <ski> beelsebob_ : possibly you'd want something like 'toList :: [a] -> exists n. List n a' ..
03:28:32 <beelsebob_> ski: indeed
03:28:36 <beelsebob_> already have :)
03:28:44 <ski> (with wrapper, i assume)
03:29:26 <beelsebob_> nope, being nasty and hacky :)
03:29:36 <ski> hm ?
03:29:47 <ski> 'unsafeCoerce' ?
03:30:04 <beelsebob_> no?
03:30:08 <beelsebob_> *confused*
03:30:22 <ski> "being nasty and hacky" means ?
03:31:05 <ski> ( hmm ... 'zipList :: List n a -> List n b -> List n (a,b)' :)
03:33:26 <jethr0> ski: doesn't work with infinite lists though, right?
03:33:57 <ski> jethr0 : interesting question
03:34:10 <ski> i think it doesn't
03:34:47 <jethr0> well, the types have to be pretty specific i guess. so infinite types will likely not work so easily
03:35:33 <ski> codatakind NatInf
03:35:40 <ski>   where
03:36:01 <ski>   Pred :: NatInf -> TMaybe NatInf
03:36:03 <ski> or something
03:38:07 <jethr0> bbl
03:41:20 <ski> beelsebob_ : so ?
03:55:25 <neologism> do you know whats the difference between "reader vs writer" and "coinsumer vs producent" ?
03:58:18 <ski> in what context ?
04:01:55 <neologism> proces synchronization
04:02:03 <neologism> or data sync..
04:02:28 <neologism> I dont understrand how this is different... imho write produces writing and reader consumes it
04:02:31 <neologism> ie. its the same
04:05:25 <ski> who says it's different ?
04:05:36 <neologism> I am studying for an exam
04:05:39 <neologism> and the scriptum says so
04:05:51 <ski> i'd say it depends on the context
04:06:10 <ski> it's too vague words to say in general
04:08:12 <neologism> the scriptum just says "cooperation: reader vs writer, mutual exclusion: producer vs consument"
04:11:34 <ski> hm .. this is for concurrent programming ?
04:16:38 <ski> neologism : i can only assume there is some specific meaning in your context
04:19:03 <neologism> I dont care about that exam that much :)
04:19:27 <ski> (what course is it for ?)
04:21:50 <neologism> parallel programming
04:22:30 <ski> ya
04:22:58 <ski> i'm not sure what the mutual exclusion would be, here
04:23:16 <ski> maybe that producer must produce all of a value, before consuming can begin ?
04:23:56 <neologism> hard to say
04:24:01 <neologism> the scriptum is not very info-rich
04:25:24 <ski> what languages (really models) are considered ?
04:26:38 <neologism> well. the scriptum talks about VLIW/[SM]I[SM]D/PRAM/DataFlow
04:27:20 <ski> mhm
04:27:46 <ski> so, it's really about 'parallel' and not 'concurrent', then ?
04:28:01 <neologism> yes
04:28:33 <ski> (since, e.g., for some strange reason, the concurrent programming course here in se was called 'parallel programmering')
04:41:17 <tre_> out of curiosity, what is the difference between 'concurrent programming' and 'parallel programming'?
04:41:53 <ski> 'concurrent' is 'possibly-parallel', roughly
04:42:05 <int-e> you can do concurrent programming yourself, for example if you work on two projects at the same time. parallel programming takes two people.
04:42:12 <ski> also, the former usually have more nondeterminism than the latter
04:42:46 <ski> int-e : :)
04:44:14 <Maddas> or just a lot of mood swings (-;
04:45:34 <Maddas> (er, many)
04:50:07 <int-e> > take 10 $ iterate reverse ":-)"
04:50:08 <lambdabot> [":-)",")-:",":-)",")-:",":-)",")-:",":-)",")-:",":-)",")-:"]
04:54:24 <neologism> do any oif you know what is "processor RAM" ?
04:59:10 <ski> class Reverse a
04:59:14 <ski>   where
04:59:20 <ski>   reverse :: a -> a
04:59:31 <ski> instance Reverse Char
04:59:32 <ski>   where
04:59:39 <ski>   reverse '(' = ')'
04:59:40 <ski>   ...
04:59:52 <ski> instance Reverse a => Reverse [a]
04:59:54 <ski>   where
05:00:03 <ski>   reverse = map reverse . reverse
05:00:57 <Lemmih> Isn't that gonna be _|_?
05:01:00 <ski> (though, better would possibly be 'class Reverse a b | a -> b,b -> a where reverse a -> b')
05:01:10 <ski> sorry
05:01:16 <ski>   reverse = map reverse . Prelude.reverse
05:01:44 <ski> (they didn't shadow in my head !)
05:02:56 <ski> imagine
05:03:17 <ski> data Foo = BaR deriving Reverse
05:03:20 <ski> deriving
05:03:29 <ski> data RevFoo = RaB
05:03:35 <ski> (with appropriate instance)
05:07:50 <Lemmih> RevFoo? Not OoF?
05:08:20 <ski> maybe
05:08:43 <ski> (considered that, but settled on just value-level)
05:09:01 <ski> (e.g. there is no 'RahC')
05:10:23 <ski> the invariant to uphold is of course  'reverse . show = show . reverse'
05:13:50 <nothingmuch> 3
05:14:01 <ProfTeggy> 4
05:14:52 <ProfTeggy> neologism, this might refer to the on-chip CPU cache
05:15:05 <ProfTeggy> (Although it's unusual wording.)
05:20:49 <ski> well, let's say that 'show . reverse' should be lesser or equal than 'reverse. show', then ?
05:21:33 <dcoutts> does anyone know the minimum set of packages that need to be downloaded to build ghc?
05:22:14 <dcoutts> or does it need them all (all 28 of them)
05:22:22 <dcoutts> http://darcs.haskell.org/packages/
05:24:47 <pvgorp> Hi all, I assumed that Bool would be an instance of Eq since == is defined for it but can't find it in the prelude.  Am I overlooking something?
05:25:47 <ski> should be
05:25:53 <ski> instance Eq Bool
05:25:55 <ski>   where
05:26:03 <ski>   False == False = True
05:26:10 <ski>   True  == True  = True
05:26:21 <ski>   _     == _     = False
05:26:28 <pvgorp> on http://www.haskell.org/onlinereport/standard-prelude.html i don't find 'instance eq bool'
05:26:51 <Igloo> data  Bool  =  False | True     deriving (Eq, [...]
05:27:14 <pvgorp> igloo: thanks a lot
05:27:20 <pvgorp> how could I have overlooked that
05:27:25 <pvgorp> you'r right 
05:27:25 <pvgorp> data  Bool  =  False | True     deriving (Eq, Ord, Enum, Read, Show, Bounded)
05:27:35 <ski> ah
05:27:40 <ski> right
05:28:18 <pvgorp> thanks again
05:34:22 <Itkovian> A quick question. I want to construct a call tree of a program. I've got a trace of function entry en exit points along with a host of data attached to them.
05:34:44 <Itkovian> Of course, between entry and exit, a number of opther functions have been called
05:35:03 <neologism> ProfTeggy: RAM processor is not connected to Von Neumann in any sense
05:35:05 <neologism> so I doubt it
05:35:06 <Itkovian> basically, you can construct the tree using a stack
05:35:34 <Itkovian> but how can one update the information in the tree without looking it up each time?
05:35:47 <ProfTeggy> neologism, please excuse my jump forward then
05:35:54 <Itkovian> I mean, classically, you'd have a pointer to the relevant structure and update that structure
05:36:07 <Itkovian> I'm not at all sure how to translate that to Haskell
05:36:15 <Itkovian> without slowing things down too much
05:36:50 <ProfTeggy> Itkovian, you can represent the tree as pairs of (preorder,postorder) numbers and associate date with the (unique) preorder value of a node.
05:37:08 <ProfTeggy> The pairs give you a structurally isomorphic rep of the tree
05:37:18 <ProfTeggy> You can draw the tree later, etc.
05:37:43 <ProfTeggy> Your data can be simply kept in a list of type [(a,b)] where a is the preorder number and b is your payload
05:38:26 <ProfTeggy> Assigning pre/postorder numbers is trivial while you scan the trace
05:38:45 <ProfTeggy> entry to function: increment pre, exit from function: increment post
05:42:47 <Itkovian> ok, drawing the tree goes as follows: A is a child of B iff pre(A) > pre(B) && post(A) < post(B), otherwise you climb one up in the tree, right?
05:43:24 * ProfTeggy nods.  Well, what you describe is "A is a descendant of B"
05:43:32 <Itkovian> true
05:43:54 <ProfTeggy> There are even algorithms which directly map pre/post into pleasing coordinates in a 2-d plane
05:44:12 <ihope> What's happening?
05:44:14 <Itkovian> but adjacent elements in the list would have to be either a child of the predecessor, a sibling or otherwise climb up until the stated proposition holds, no?
05:44:28 <ProfTeggy> That's true, Itkovian
05:45:16 <Itkovian> I think a tree-like rep would be best suited to manipulate the data, e.g. accumulate some of the pyload into parents atc.
05:45:32 <Itkovian> my typing seems to be deteriorating too
05:45:45 <ProfTeggy> :-)
05:46:21 <rep> yes?
05:47:25 <ProfTeggy> Itkovian, if such accumulation relates to all descendants of a node (which seems useful to summarize an exec trace), then pre/postorder ranks are very convenient to traverse the subtree
05:47:39 <ProfTeggy> But I agree, this is an unusual tree rep
05:47:57 <ProfTeggy> We use it since many years here and love it ;-)
05:48:01 <Itkovian> Well, filtering all nodes with pre(node) > x seems a tad overkill
05:48:13 <Itkovian> It seems very good for building the tree though
05:48:23 <Itkovian> How could I ever have forgotten about that :-)
05:48:32 <ProfTeggy> Itkovian, such operations are what DBMSs are best at ;-)
05:48:35 <Itkovian> It's like first lesson data structures
05:48:53 <Itkovian> not SMDB?
05:49:04 <ProfTeggy> database management systems
05:49:04 <Itkovian> erm DBSM
05:49:08 <Itkovian> :-)
05:49:49 <Itkovian> grmbl
05:50:00 <Itkovian> BDSM I meant
05:50:17 <Itkovian> as you can see, I'm not overly familiar with that particular term.
05:50:54 <Itkovian> ok, so this would be it:
05:52:10 <twobitsprite> wow... ghc produces some pretty lengthy asm code for just a few type/data declarations...
05:52:53 <ProfTeggy> twobitsprite, if you use 'deriving', such declarations generate code, too
05:53:02 <twobitsprite> ahh
05:53:23 <dcoutts> deriving read & show generate quite a bit of code
05:56:31 <twobitsprite> how can you get ghc to not look for a main function and just spit out some asm...
05:56:35 <twobitsprite> ?
05:56:54 <kowey> vincenz, did you ever solve your wxhaskell problems?
05:56:59 <Igloo> If you have "Module Foo where" then it won't look for a main function
05:57:06 <twobitsprite> ahh
06:00:28 <Lemmih> twobitsprite: -c
06:02:55 <twobitsprite> it still produces quite a bit of code :P
06:20:15 <twobitsprite> are there any plans to introduce guarded types into the haskell spec or any of it's implementations?
06:21:33 <Lemmih> guarded types == GADTs?
06:22:02 <twobitsprite> ?
06:22:34 <jips> doesn't ghc already have that?
06:22:40 <twobitsprite> jips: does it?
06:23:27 <twobitsprite> what are GADTs?
06:24:07 <alar> imho guarded types < GADTs
06:25:01 <twobitsprite> I can't find "GADT" on the wiki... can someone enlighten me please?
06:25:02 <audreyt> isn't GADT aka  guarded algebraic data types ?
06:25:06 <Lemmih> twobitsprite: http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html
06:25:21 <audreyt> twobitsprite: also http://www.haskell.org/hawiki/GADT_20with_20record_20syntax
06:25:38 <audreyt> (as an example)
06:28:26 <Igloo> audreyt: "Generalised"
06:28:37 <kosmikus> guarded recursive data types
06:29:00 <kosmikus> there are papers by Xi
06:29:07 <kosmikus> they're more or less the same
06:29:53 <audreyt> Igloo: it goes by many names
06:30:03 <audreyt> strangely all abbreviating to GADT
06:30:18 <audreyt> (except when they are abbreviated to GRDT)
06:30:27 <Igloo> Ah, I see, I thought you were just misremembering the canonical expansion  :-)
06:30:43 <audreyt> :)
06:31:32 <twobitsprite> I'm trying to figure out how I could do something like "type Foo a | a < 3^9 = Int a" (or something, I know that wouldn't be correct)
06:32:07 <kosmikus> that's beyond Haskell's type system
06:32:50 <alar> 2bitsprite: Oleg shows how
06:33:09 <alar> but you have to use type-level numerics instead of Ints
06:33:42 <kosmikus> ... which effectively renders the occurrence of numbers such as 3^9 impossible
06:33:44 <twobitsprite> right... I know I can use a function to construct types ("smart constructors"), but I loose type safety... I can still stick a normal Int into my higher-level types without realizing it...
06:34:06 <twobitsprite> alar: right... those are not an option
06:34:20 <alar> kosmicus: Oleg showed decimals of arbitrary length @ type-level
06:34:48 <twobitsprite> alar: I need to be able to do efficient arithmetic on these numbers...
06:35:38 <kosmikus> alar: ok. I haven't seen that. I still doubt it's practical, but maybe I'm wrong.
06:35:41 <alar> 2bitsprite: what do you call efficient arithmetics? exp and log and roots and reverse factorial?
06:35:41 <twobitsprite> anyways... I was just hoping to save myself some trouble, but I can do with out it.
06:35:58 <alar> imho it's impractical
06:36:16 <twobitsprite> alar: efficient arithmetic is impractical?
06:36:40 <alar> Oleg's inventions are impractical
06:36:44 <twobitsprite> ahh
06:36:47 <twobitsprite> I agree
06:37:08 <alar> but what do you call efficient arithmetics again?
06:37:20 <ProfTeggy> i++
06:37:27 <twobitsprite> nice for a day-or-two's discussion in a class on type theory, but ultimately unusable on anything but the minute scale
06:37:45 <twobitsprite> alar: just +, -, etc in a tight loop
06:37:45 <alar> nope
06:38:09 <alar> usable if one really needs parametric dadatypes
06:39:02 <alar> and also usable to convince one that his task is solvable without poarametric types 
06:39:04 <alar> =)
06:39:44 <alar> 2bitsprite: there are +. -. *. ^ , exp, log, root, ! on integers
06:40:32 <alar> but it is unpractical because of one more reason: typechecker is not designed to work in such perverted way
06:41:55 <jethr0> dependent types are not impractical!
06:42:11 <kosmikus> we're not talking about dependent types currently
06:42:25 <kosmikus> Haskell doesn't have dependent types.
06:43:02 <jethr0> i know haskell doesn't. but doesn't "type Foo a | a < 3^9" go into the direction of dependent types?
06:43:29 <kosmikus> yes, sure.
06:43:41 <kosmikus> but we weren't saying that such types per se would be impractical.
06:43:47 <jethr0> yes, and that's the example that started the whole discussion
06:43:53 <jethr0> ah, k
06:44:18 <kosmikus> we were saying that trying to do it in current Haskell is impractical, even though it's possible.
06:44:20 <alar> jethr0: dependent types are practical
06:44:42 <alar> but realization of dependent types on top of Haskell typoe system isn't
06:45:10 <dcoutts> @karma+ epigram
06:45:11 <lambdabot> epigram's karma raised to 1.
06:45:30 <jethr0> hehe
06:45:36 <kosmikus> well, I don't think you can currently do 3^9 in any practical way in epigram either
06:45:44 <audreyt> why not just compile it into runtime assertions?
06:45:44 <alar> @seen epigram
06:45:45 <lambdabot> I haven't seen epigram.
06:45:53 <audreyt> (as we do in p6)
06:46:00 <dcoutts> kosmikus, really?
06:46:02 <audreyt> (not a rhetorical question)
06:46:05 <alar> kosmikum: why? 
06:46:13 <kosmikus> no integer base type, afaik
06:46:31 <dcoutts> kosmikus, defining int is only one definition
06:46:43 <kosmikus> ?
06:46:44 <jethr0> audreyt: do what in p6?
06:46:52 <dcoutts> data Int = Zero | Succ Int
06:46:56 <dcoutts> or something similar
06:47:14 <audreyt> jethr0: subset Pos of Int where { .sign == 1 }
06:47:16 <kosmikus> yes, that's exactly what I mean when I say "impractical"
06:47:32 <audreyt> (compiles to runtime assertions)
06:47:37 <dcoutts> kosmikus, yeah, so there isn't a prelude yet
06:47:52 <kosmikus> you don't want such a definition of Int if you're going to compute with numbers such as 3^9 or larger
06:48:09 <dcoutts> one could use a binary definition
06:48:09 <jethr0> audreyt: yes, but that's not at type level. although subset types would be nice in haskell too. there is Bounded though
06:48:09 <kosmikus> even addition is linear
06:49:01 <audreyt> jethr0: well... they are constraints, like typeclasses
06:49:06 <audreyt> so it exists both at type and runtime level
06:49:17 <audreyt> but yeah, it's not dependent typing per se
06:49:45 <kosmikus> dcoutts: how do you write down a number like 1000000?
06:49:53 <dcoutts> kosmikus, ie a binary tree like definition rather than a list-like definition
06:50:16 <dcoutts> kosmikus, you mean a integer literal?
06:50:17 <kosmikus> dcoutts: you need built-in support, you need literals, you need constant-time operations.
06:52:11 <alar> kosmikus: 1000000000 is made by using decimal notation, Oleg invented one
06:53:36 <kosmikus> yes, but you're not going to tell me that you really want to write "D1 .+. D0 .+. D0 .+. D0 .+. D0 .+. D0 .+. D0" in your programs? ;)
06:53:41 <kosmikus> (invented some notation)
06:54:01 <ProfTeggy> You forgot two zeros there, Andres ;-)
06:54:18 <kosmikus> ProfTeggy: I referred to my number above ;)
06:54:25 <ProfTeggy> Lazy bastard.
06:54:27 <ProfTeggy> ;-)
06:54:28 <kosmikus> but you're right, of course
06:54:32 <kosmikus> which sort of proves my point ...
06:55:16 <Saulzar> Could be reasonable for small fixed size vectors or something, 2 3 or 4 for example
06:55:23 <Saulzar> But probably not 100000000
06:55:25 <ProfTeggy> This smells like implementing lambda calculus based on the text expansion built into the C++ template mechanism
06:55:48 <twobitsprite> ProfTeggy: ick
06:55:58 <ProfTeggy> It has been done.
06:56:14 <ProfTeggy> But I felt uneasy when I listened to the talk
06:56:35 <kosmikus> heh, that was back then in Dagstuhl
06:56:39 <alar> someone told me about WAM ontop asm macros
06:56:42 <ProfTeggy> kosmikus, you have been there, don't you?  (Dagstuhl)
06:56:46 <ProfTeggy> hehe
06:56:56 <audreyt> well, there is also UTM on game of life
06:57:02 <twobitsprite> UTM?
06:57:07 <audreyt> universal turing machine
06:57:12 <twobitsprite> ahh yeah
06:57:14 <twobitsprite> that's nifty
06:57:21 <alar> nice
06:57:36 <alar> audreyt: where is it described?
06:58:19 <twobitsprite> I remember seeing a UTM on game of life that used 2 "stacks" each with a depth of about 4 items... I think it also might have had a register or two
06:58:47 <audreyt> alar: http://www.cs.ualberta.ca/~bulitko/F02/papers/tm_words.pdf
06:59:27 <audreyt> battery almost drained, finding an outlet, bbiab &
06:59:43 <twobitsprite> http://www.cs.ualberta.ca/~bulitko/F02/papers/tm_words.pdf
06:59:50 <twobitsprite> audreyt: damn, meat me to it
06:59:56 <twobitsprite> s/meat/beat
07:08:09 * twobitsprite just can't wait until someone crack-pot develops a hardware game-of-life :)
07:09:56 <Igloo> Surely someone already has. It would be trivial, anyway
07:10:01 * alar can't wait until someone develops a hardware UTM
07:10:35 <alar> Igloo: infinite dimensions are the only hard thing in development of one
07:11:18 <Igloo> You could make a toroidal one
07:11:36 <dcoutts> or a klein bottle
07:12:01 <xerox> Howdy!
07:12:13 <dcoutts> g'day xerox!
07:12:45 <alar> Igloo: maybe you mean spherical? Life should be infinite in both dimensions
07:12:55 * xerox immerges dcoutts in R^3.
07:13:01 <jethr0> twobitsprite: you mean like this? www.dropoutdesign.com/products/life-doc.pdf
07:13:04 <Igloo> No, I mean toroidal
07:13:13 * dcoutts thinks Igloo is right
07:13:18 <jethr0> or this? www.sparetimegizmos.com/Downloads/Life.pdf
07:13:21 <alar> ah, I see my error
07:13:23 <dcoutts> xerox, so when are we going to start hacking on Cairo.Pure ?
07:13:38 <xerox> dcoutts: as soon as possible, I'll have exams to stody for in the next months then!
07:13:50 <dcoutts> xerox, ah, good luck!
07:13:52 <xerox> Well, proper Life is infinite plane.
07:14:30 <xerox> dcoutts: thanks.  I was about to ask you if there are opportunities in your uni afterwards
07:14:56 <dcoutts> xerox, you mean graduate courses?
07:15:13 <xerox> Yeah.  I'm looking for where to go :-)
07:16:24 <xerox> Not that I can afford everything, I think I'll try to get a grant somewhere, in Pisa for math, maybe, or somewhere else in CS, but certainly not in Italy.
07:16:33 <dcoutts> xerox, ox.ac.uk has a MSc but it's mostly for people who did thigs other than CS as undergrads
07:17:07 <liyang> ic.ac.uk has an MSc in Advanced Computing.
07:17:10 <araujo> morning
07:17:17 <xerox> What are 'MSc' ?
07:17:48 <dcoutts> xerox, Master of Science or soemthing similar
07:17:58 <liyang> Master of Science (c.f. BA = Bachelor of Arts)
07:18:04 <vincenz> kowey: I never had a wxhaskell problem
07:18:27 <kowey> vincenz: oh... must have misread the logs - thought you and robdockins had compile problems
07:18:41 <xerox> Comparing schoolsystems is always difficult, hmpf.  And I'm not fond on the terminology.
07:19:09 <yaarg> ed.ac.uk has an MSc in Informatics.
07:19:26 <liyang> yaarg: but it's freezing up there. ;)
07:20:07 <yaarg> liyang: oh yes...
07:20:13 * yaarg shivers
07:21:32 * xerox wants to do Haskell!
07:21:55 <yaarg> xerox: oh we have the wadler at ed.ac.uk :)
07:22:07 <liyang> But he's scary as hell.
07:22:17 <xerox> Is 'grant' the right word to describe the possibility that certain university give to Good students?
07:22:25 <yaarg> yup
07:22:30 <xerox> (Money or place to live, or both.)
07:22:37 <liyang> or bursary.
07:22:39 <xerox> OK, thanks.
07:22:49 <yaarg> liyang: heh also true
07:23:20 <xerox> It seens there is Moggi 200km down here, in Genova... but the only functional language they use is OCaml, I've a friend studying there.
07:23:24 <xerox> *seems
07:24:18 <xerox> dcoutts: what exactly is an MSc, is it some type of 'grant'/'bursary' ?
07:24:22 <liyang> I got £8k from ic.ac.uk plus fees paid. The MSc in Adv. Comp. is quite good but no Haskell involved. Having said that, what I imagine you already know (by virtue of being on this channel :) is years beyond what'll get taught in an MSc course anyway. :)
07:24:45 <yaarg> liyang: i can't remember, did you do an msc before your phd?
07:24:53 <liyang> yaarg: yup.
07:24:56 <dcoutts> xerox, an MSc is the type of course, as opposed to a BA, BSc or PhD
07:25:14 <xerox> liyang: hmm.  Yes, then, I said myself, let's do something more general: mathematics!
07:25:15 <norpan> MSc is a degree
07:25:23 <norpan> a Masters degree
07:25:24 <xerox> dcoutts: hrm...
07:25:24 <liyang> (We used O'Caml for our Prolog group project. I could have convinced the others to use Haskell had I tried hard enough...)
07:25:27 <yaarg> in the uk BSc->MSc->PhD basically
07:25:28 <Saulzar> an MSc here is a 4th year + 1 year project
07:26:03 <liyang> xerox: I did 3 years of maths undergrad. Then converted to CompSci. :)
07:26:13 <yaarg> hehe
07:26:17 <xerox> liyang: OTOH, since I know what are you talking about, I wonder if I could use this knowledge to find a grant somewhere.
07:26:35 <yaarg> i did 1 year of maths then swtiched to cs for 2 years then wanted to switch back to maths
07:26:40 <yaarg> but by then it was too late :(
07:26:48 <xerox> Too late?
07:27:26 <dcoutts> it's too easy to forget maths
07:27:35 <yaarg> i didn't have the requirements for honours maths
07:27:40 <dcoutts> they don't reccommend taking gap years
07:27:43 <yaarg> because i did cs
07:27:44 <dcoutts> for maths
07:28:39 <xerox> Ah, :-|
07:28:44 * xerox mumbles
07:28:54 <liyang> xerox: apply to ic.ac.uk. They give grants to EU students. http://www.doc.ic.ac.uk/teaching/postgraduate/mac/
07:29:41 <xerox> Are you there?
07:29:46 <liyang> Last year
07:30:02 <xerox> Ah :-)
07:30:22 <xerox> More #haskell people, more fun :-D
07:31:27 <liyang> as I said, there isn't much in terms of Haskell there, but I have learnt a fair bit of useful CS on that course.
07:31:40 <yaarg> i had a complete shift in interests. i use to like low level bit twiddling in C and now i like Haskell. :)
07:32:02 <jewel> be prepared to shift again
07:32:14 <liyang> yaarg: You did maths... that explains it.
07:32:26 <yaarg> liyang: i guess so
07:33:32 <Saulzar> Everyone likes low level bit twiddling until they have had enough debugging
07:34:23 <xerox> Mumble mumble.
07:34:30 <xerox> Thanks for the informations, guys.
07:38:47 <beelsebob_> w00 yay!
07:39:05 <beelsebob_> bob's hypergraph traversing unit converter of doom is working!
07:39:30 <beelsebob_> time to add some more conversions and link it into lambdabot
07:40:14 * xerox launches the evil plan (of doom) suppressing unit on bob's unit.
07:44:34 <beelsebob_> dhcp2970:~/Documents/Work/Hat test cases/Convert tatd2$ ./Convert 
07:44:34 <beelsebob_> Mass: 5N Gravity: 10N/Kg Height: 2m to BMI in Kg/msq 
07:44:34 <beelsebob_> BMI: 12.5 Kg/msg
07:44:59 <beelsebob_> ... it'll do any conversion as long as there is a method of getting it from the input
07:45:20 <dcoutts> grr, we really need a proper binary framework in ghc base, there are too many other versions floating about and several packages are now picking up deps on them.
07:45:29 <xerox> In fact, finding a grant in CS is mainly an excuse to avoid passing the whole summer studying math and physics.
07:45:46 <dcoutts> which is annoying since I don't think the current NewBinary is appropriate for packaging for distros
07:45:53 <dcoutts> but everything depends on it
07:46:18 <xerox> @karma+ beelsebob_ 
07:46:19 <lambdabot> beelsebob_'s karma raised to 1.
07:46:27 <beelsebob_> why thank you xerox :)
07:46:32 <xerox> Nice one :-D
07:46:41 * xerox doesn't know what to do! KMAA KMAA!!!
07:46:59 <beelsebob_> I'll get to work on making it do more than just mass, weight, height and BMI now
07:47:13 <beelsebob_> and then add it as a lambdabot module
07:48:34 <xerox> What is 'BMI' ?
07:48:55 <yaarg> body mass index
07:49:02 <yaarg> body fat relative to height
07:49:03 <xerox> Ah-ha.
07:49:23 <norpan> not body fat, body mass
07:50:35 * dcoutts growls at packages that release new tarballs without increasing the version number
07:50:45 <dcoutts> http://www.n-heptane.com/nhlab/NewBinary-2005-08-21.tgz
07:50:45 <dcoutts> http://www.n-heptane.com/nhlab/NewBinary/NewBinary-2005-12-11.tar.gz
07:50:51 <dcoutts> both 0.1 apparently
07:51:07 <palomer> don't be fooled!
07:51:14 <dcoutts> we just can't package things like that
07:51:24 <xerox> :-(
07:51:25 <dcoutts> it would screw up packaging systems
07:51:27 * beelsebob_ licks Philippa_ 
07:51:56 <beelsebob_> @karma+ Beelsebob 
07:51:57 <beelsebob_> @karma- beelsebob_ 
07:51:57 <lambdabot> Beelsebob's karma raised to 3.
07:51:57 <lambdabot> You can't change your own karma, silly.
07:52:02 <beelsebob_> buh
07:52:09 <beelsebob_> someone decrement mine will you?
07:52:16 <xerox> Pleasure!
07:52:20 <xerox> @karma- beelsebob_ 
07:52:20 <lambdabot> beelsebob_'s karma lowered to 0.
07:52:23 <beelsebob_> chears :)
07:52:25 <Itkovian> @karma- beelsebob_ 
07:52:27 <lambdabot> beelsebob_'s karma lowered to -1.
07:52:30 <beelsebob_> OI!
07:52:31 <xerox> Again, again!
07:52:38 <beelsebob_> @karma- Itkovian 
07:52:39 <lambdabot> Itkovian's karma lowered to -1.
07:52:41 <beelsebob_> :P
07:52:47 <beelsebob_> @karma+ Itkovian 
07:52:48 <lambdabot> Itkovian's karma raised to 0.
07:52:49 <xerox> Yarr!! Yarr! Karmawars!
07:52:53 <beelsebob_> @arr
07:52:54 <lambdabot> I'll crush ye barnacles!
07:53:43 * xerox sighs and dissolves in the background... later, later.
07:53:44 <twobitsprite> stop it! My co-workers are staring at my as I laugh like an idiot! :P
07:53:52 <twobitsprite> s/my/me
07:53:54 <beelsebob_> :P
07:54:09 <beelsebob_> @vixen should we embarras twobitsprite some more?
07:54:10 <lambdabot> is that really what you want to know?
07:54:25 <beelsebob_> @vixen why wouldn't I want to know that?
07:54:25 <lambdabot> because
07:54:29 <beelsebob_> oh... okay
07:54:39 <twobitsprite> lambdabot says so! :P
07:55:07 <alar> @vixen because what?
07:55:07 <lambdabot> oh, okay
07:55:25 <beelsebob_> @vixen and the answer is?
07:55:26 <lambdabot> i dunno, what was the question?
07:55:37 <alar> @vixen are you alright?
07:55:38 <lambdabot> do i not seem alright? i'm fine!
07:55:39 <beelsebob_> @vixen should we keep twobitsprite lauging
07:55:40 <lambdabot> Does your mommie know you're here, little naughty boy?
07:55:51 <beelsebob_> hehe
07:56:01 <alar> @vixen surely she doesn't
07:56:01 <lambdabot> Does your mommie know you're here, little naughty boy?
07:56:12 <alar> aha!
07:56:28 <beelsebob_> @. elite vixen does *your* mommie know you're here, little naughly bot?
07:56:28 <alar> vixen caught in trivial loop
07:56:29 <lambdabot> \/\/|-|Er3 E15E \/\/0Uld I 8e?
07:57:01 <alar> @vixen maybe somewhere or elsewhere?
07:57:02 <lambdabot> why, aren't you sure?
07:57:10 <beelsebob_> @. vixen arr
07:57:11 <lambdabot> Are you adopted by trolls?
07:57:16 <beelsebob_> LOL!
07:57:27 <alar> @vixen yow
07:57:27 <lambdabot> Any way you want it, baby!
07:57:38 <beelsebob_> @. vixen yow
07:57:39 <lambdabot> where can I a see a picture of you?? URL??
07:57:44 <beelsebob_> O.o
07:57:57 <beelsebob_> @vixen do you enjoy bot abuse?
07:57:57 <lambdabot> why does everyone ask i'f on a bot?
07:58:12 <xerox> @. vixen . state yow
07:58:13 <lambdabot> have you ever scubadived?
07:58:15 <xerox> @state
07:58:16 <lambdabot> Will it improve my CASH FLOW?
07:58:16 <lambdabot>  
07:58:18 <xerox> haha
07:58:26 <xerox> So one can see what is going on.
07:58:34 <beelsebob_> hehe, indeed
07:58:46 <Lemmih> @. vixen . state keal
07:58:47 <lambdabot> Whatever
07:58:50 <beelsebob_> @. elite . elite . elite elite elite
07:58:51 <lambdabot> 3|i73
07:58:54 <beelsebob_> *g*
07:58:57 <xerox> @state
07:58:58 <lambdabot> lamadabot took 5 to 8 whole seconds to return []
07:59:07 <xerox> :-)
07:59:16 <xerox> @. vixen . state arr
07:59:17 <lambdabot> You should add me to your buddy list!
07:59:19 <xerox> @state
07:59:20 <lambdabot> I'll keel haul ya fer that!
07:59:28 <Lemmih> @. vixen . state keal
07:59:29 <lambdabot> help help!
07:59:43 <xerox> keal?
07:59:49 <beelsebob_> @help keal
07:59:50 <lambdabot> Talk like Keal
07:59:53 <Lemmih> @keal
07:59:54 <lambdabot> just seeing how offtopic i could get everyone
07:59:56 <beelsebob_> @. vixen . state arr
07:59:57 <lambdabot> yup
08:00:02 <beelsebob_> @state
08:00:03 <lambdabot> Har de har har!
08:00:06 <beelsebob_> LOL!
08:00:08 <xerox> OK, I ought to disappear for real.
08:00:14 <beelsebob_> hf xerox 
08:00:15 <dcoutts> Are you fully geek????
08:00:21 * xerox GRINS!
08:02:39 <Itkovian> ttyl
08:10:53 <twobitsprite> for being a "functional" language, I sure do find myself defining more types than functions...
08:11:34 <basti_> maybe functions will rise from them if you do it enough
08:15:04 <twobitsprite> basti_: heh
08:16:31 * twobitsprite is trying to think of a concise way to make sure that all of the characters in a string are in the range ['a'..'q']...
08:18:06 <basti_> > 'g' `elem` ['a'..'q']
08:18:07 <lambdabot> True
08:18:22 <basti_> > "afg" `all` (`elem` ['a'..'q'])
08:18:23 <lambdabot> Couldn't match `a -> Bool' against `[Char]'
08:18:28 <basti_> uhm
08:18:34 <basti_> > all (`elem` ['a'..'q']) "afg"
08:18:35 <lambdabot> True
08:18:50 <int-e> @pl (\x -> 'a' <= x && x <= 'q')
08:18:51 <lambdabot> liftM2 (&&) ('a' <=) (<= 'q')
08:20:29 * twobitsprite doesn't understand <= syntax... I assume it has to do with list monads?
08:21:24 <int-e> <= is 'less than or equal to'
08:21:25 <basti_> @type (<=)
08:21:26 <lambdabot> forall a. (Ord a) => a -> a -> Bool
08:21:31 <basti_> @type (<= 'q')
08:21:32 <lambdabot> Char -> Bool
08:21:44 <int-e> @type liftM2 (&&)
08:21:45 <lambdabot> Not in scope: `liftM2'
08:21:52 <int-e> @type Control.Monad.liftM2 (&&)
08:21:53 <lambdabot> forall (m :: * -> *).
08:21:53 <lambdabot>           (Monad m) =>
08:21:53 <lambdabot>           m Bool -> m Bool -> m Bool
08:22:23 <twobitsprite> I don't understand "* -> *" either :P
08:23:07 <twobitsprite> int-e: sorry... I should have known <=, but with all the arrows I've been seeing recently.....
08:23:29 <basti_> -g-
08:23:36 <basti_> don't worry, that'll pass
08:24:04 <int-e> twobitsprite: and liftM2 to confuse you. I'd ignore that for now. If you want to understand it, look at the Control.Monad.Reader sources, it defines a Monad instance for (->) r
08:24:59 <int-e> twobitsprite: but it's probably better to come back to that once you have a grip on the more common monads, list and maybe
08:25:04 <int-e> and maybe state
08:25:17 <twobitsprite> it looks like it factored out the (&&) somehow
08:25:51 <int-e> in that context, liftM2 (&&) a b = \x -> a x && b x
08:26:14 <monstre> can someone recommend a good haskell book or tuturial please?
08:26:24 <basti_> @learn
08:26:24 <lambdabot> http://www.haskell.org/learning.html
08:26:27 <monstre> preferably, one that's not too "gentle"
08:26:40 <twobitsprite> basti_: when people say things like "that'll pass" I feel like I just pulled out of the imperative Matrix and you're Morpheus telling me that I feel weak because my muscles have atrophed... :P
08:26:56 <twobitsprite> monstre: read the spec :P
08:27:01 <twobitsprite> @spec
08:27:01 <twobitsprite> ?
08:27:02 <lambdabot> Maybe you meant: seen spell
08:27:05 <monstre> I have, actually
08:27:13 <monstre> hence my question
08:27:25 * basti_ laughs
08:27:51 * int-e wonders if the 'gentle introduction to haskell' is ungentle enough. people keep complaining about it.
08:28:16 * twobitsprite liked the "gentle intro"..
08:28:25 <twobitsprite> er... well, I haven't actually finished it yet, but it's good so far
08:28:48 <monstre> it ramps up pretty quickly
08:28:54 <monstre> or maybe I'm just dense
08:29:43 <twobitsprite> it has ramped up against type classes for me, but I'm pushing through it
08:29:46 <jethr0_> monstre: don't flatter yourself. at some point almost everyone feels dumb when confronted with lazy evaluation, monads, ...
08:29:51 <twobitsprite> I'll probably have to re-read it
08:29:54 <jethr0_> for the first time
08:32:12 <monstre> so... any particular recommendations?
08:33:23 <jethr0_> monstre: what are you having trouble with?
08:34:37 <monstre> I just need a good basic introduction to functional programming in general and haskell in particular
08:35:27 <twobitsprite> my favorite intro to functional program (and possibly programming in general) has been "Structure and Interpretation of Computer Programs"
08:35:54 <monstre> SICP is on my read list
08:35:59 <twobitsprite> it uses the language Scheme, which is dynamically typed so you can learn functional concepts with out having to lean type theory at the same time
08:36:42 <integral> Types and Programming Languages is nice if you want to know too much about type systems later on
08:36:44 <jethr0_> monstre: i liked yet another haskell tutorial, but i'm not sure how well it works for beginners. SICP is definitely worth reading, but only helps with haskell to a certain point
08:36:45 <yaarg> there's videos available online for that
08:37:05 <yaarg> http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/
08:37:19 <yaarg> Structure and Interpretation of Computer Programs Video Lectures by Hal Abelson and Gerald Jay Sussman
08:37:39 <twobitsprite> the path I took to get to Haskell was: Python (where I learned to love higher-order functions) -> Scheme (learned that Python is hardly functional :P) -> Ocaml (learning basic type system and a tad bit more purity) -> here
08:39:01 <twobitsprite> I don't know if I would recommend Haskell to someone with no functional background... (I definately would not teach it to someone with no programming background...)
08:39:02 <monstre> thanks for the recommendations, I'll give YAHT a try
08:39:45 <yaarg> twobitsprite: some universities are using it as a first language
08:39:51 <yaarg> i don't think that's a bad thing at all
08:40:02 <jethr0_> twobitsprite: i'm not so sure. IMO scheme works very nicely for beginners, and why should haskell work any less. if anything scheme beginners would have appreciated a type system to guide them along
08:40:22 <yaarg> (me: basic->java/python->c->ml->haskell)
08:41:09 <twobitsprite> yaarg: which uni's?
08:41:41 <yaarg> twobitsprite: ed.ac.uk
08:41:43 <yaarg> and i've heard of others
08:42:07 <jethr0_> me: pascal->c->c++->java->python->smalltalk->ruby->scheme->haskell :)
08:42:58 <araujo> jethr0_, i also had scheme, preceded by smalltak before getting to haskell :-]
08:43:04 <araujo> interesting....
08:43:10 <defcon8> hey i made a cool motto for haskell
08:43:23 <defcon8> "haskell, you don't have to be l33t to make bugless code"
08:43:40 <yaarg> in many ways i think it would easier to pick up haskell with no programming haskell
08:43:49 <yaarg> because then you don't try and write for loops in haskell :)
08:44:02 * defcon8 isnt used to using for loops
08:44:09 * basti_ was like: basic, 6502 assembly, C, 80x86 assembly, Pascal, C++, java, prolog, some scheme, some clean, haskell
08:44:19 <yaarg> grr with no programming experience even
08:45:10 <jethr0_> basti_: so you like haskell "better" than clean?
08:45:27 <defcon8> what is clean? :|
08:45:49 <basti_> clean isn't free.
08:45:53 <monstre> it's another lazy functional language
08:46:00 <monstre> looks pretty haskellish to me
08:46:08 <monstre> but what do I know...
08:46:10 <defcon8> why haskell over python in the real industry?
08:46:22 <beelsebob_> ROFL @ question hat-delta just asked me
08:46:31 <basti_> its almost the same, except for monads
08:46:36 <jethr0_> defcon8: wast that a question? :)
08:47:20 <beelsebob_> (((((convString simpleReadType . acceptText <+> f) (accept Colon) <+> g)
08:47:20 <beelsebob_>         (acceptNumber <|> _ <|> _) <+> ($)) (convString simpleReadUnit . acceptText) <+>     
08:47:21 <defcon8> yes
08:47:23 <defcon8> jethr0_
08:47:23 <beelsebob_>       f) (parse <|> (accept To <+> f) _)) (TText _:Colon:Number _:TText _:TText _:Colon:Number _:Dot:_) == Right _?
08:47:30 <beelsebob_> that one's easy to answer then
08:47:32 <defcon8> i mean does anyone use python at work?
08:47:42 <darrint> depends on where you work
08:47:53 <defcon8> okay lets say the majority
08:48:11 <jethr0_> defcon8: it's a pretty general question. but static type inference has its PROs and haskell is faster than python, i'd think
08:48:46 <twobitsprite> defcon8: python is probably more widely (publicly) used...
08:48:48 <jethr0_> but in a sense it's really comparing apples to oranges
08:49:11 <twobitsprite> defcon8: at least in terms of user applications, etc
08:49:20 <jethr0_> few people use haskell "in practice", _yet_
08:50:01 * twobitsprite thinks haskell (and functional programming in general) puts the "science" back in computer science...
08:50:57 <integral> or at least the maths
08:52:06 <jethr0_> yes, i've had little to do with CS while programming C++ for example, but haskell really puts many central CS question right in your face :)
08:53:33 <twobitsprite> jethr0_: precisely... most C++ programmers are just _some guy_ working some day job who went to school for CS because they thought it payed well... I've found that most functional programmers have a general enthusiasm for stuctured formal systems, etc
08:54:09 <jethr0_> implementing k-d-trees and any kind of complicated data structure can certainly be a royal pain in the *ass in C++, while in haskell the language stands less in the way of solving the already difficult enough problems at hand
08:54:28 <jethr0_> type safety, garbage collection, sane recursion and pattern matching can go a long way :)
08:54:41 <twobitsprite> indeed
08:55:18 <jethr0_> but i guess manual resource management is what makes that kind of thing so unbearable in c++
08:56:04 <jethr0_> _plus_, genericity doesn't necessarily come naturally in c++/java. whereas haskell is (mostly) pretty generous about that
08:58:17 <jethr0_> but for me lazyness is one of the most important aspects because it allows you to create all kinds of neat control structures and all-encompassing abstractions (at the cost of annoying space leaks (at least until you stop creating them), that is)
08:59:05 <jethr0_> > Just{} == Just 4
08:59:07 <lambdabot>  Missing field in record construction
08:59:41 <jethr0_> i wish that worked. inline "case" expressions can be so ugly...
09:00:40 <Igloo> Do you want isJust?
09:00:55 <jethr0_> no, i mean for generic data types
09:01:21 <jethr0_> instead of (\x -> case x of Just _ -> True; _ -> False)
09:01:47 <jethr0_> or writing an "isConstructor" function
09:05:55 <jberg> anyone know of a good haskell mode for emacs?
09:06:33 <yaarg> http://www.haskell.org/haskell-mode/
09:07:29 <twobitsprite> what's wrong with this:
09:07:31 <twobitsprite> foldr (\ a (n,m) -> (a,(n,m)) ) 0 [1..4]
09:07:36 <twobitsprite> > foldr (\ a (n,m) -> (a,(n,m)) ) 0 [1..4]
09:07:37 <lambdabot>   Occurs check: cannot construct the infinite type: b = (a, b)
09:07:37 <lambdabot>   Expected type: b
09:07:37 <lambdabot>   Inferred type: (a, b)
09:13:55 <liyang> twobitsprite: what were you expecting to be the result of that expression?
09:33:44 <twobitsprite> liyang: n/m I've figured it out
09:47:29 <twobitsprite> data Foo = Bar Int Int ; type Baz = Bar 4
09:47:35 <twobitsprite> can you curry types like that?
09:47:43 <jips> nutch
09:47:56 <twobitsprite> nutch?
09:48:12 <jips> negative, i'm afraid not. no
09:48:23 <twobitsprite> damn
09:49:04 <jips> but you can make a "constructor function" createFoo x y = Bar x y and then you can curry that
09:49:44 <twobitsprite> yeah, but I can't define a function which accepts only Bar's created with that function :P
09:50:50 <jips> twobitsprite: you can if you use haskell's module system to guarantee that that function is the only way to create Bars :)
09:51:06 <twobitsprite> true...
09:57:08 <twobitsprite> are module names and type names in different name spaces?
09:58:26 <twobitsprite> n/m... seems to work
09:59:40 <musasabi> twobitsprite: module names have their own namespace, think about module Monad and the type Monad for example.
10:05:43 <noj> dons, hey, I nagged on you before about the GHC update in the OpenBSD ports system. what's the status, anything I can test?
10:06:03 <noj> dons, I also nagged about the runtime dependency on ghc for darcs in the OpenBSD ports system :)
10:49:02 <lisppaste2> twobitsprite pasted "monadizing?" at http://paste.lisp.org/display/17952
10:49:38 <twobitsprite> I think I might be on the verge of understanding monads, because I think I'm recognizing an opportunity to utilize a monad...
10:50:41 <xerox> ...helpers usually are f', e.g. if the function is foo, it has the helper foo'.
10:50:54 <xerox> Mumble.
10:50:55 <twobitsprite> xerox: ahh
10:51:24 <twobitsprite> but, am I wrong in thinking that one of those functions might be more easily expressed as a monad?
10:51:44 <xerox> That's what the "mumble" was about.  What do you mean?
10:52:55 <twobitsprite> i.e. the way I'm passing a state tuple around in toInt using foldr... sounds like something a monad might do
10:54:33 <kosmikus> yes, but it wouldn't make things much easier in this context
10:54:57 <twobitsprite> kosmikus: well... I still think I'd learn a bit from using a monad here, donchya think?
10:54:57 <kosmikus> your changing the complete state (one Int) in every step of the computation
10:55:03 <kosmikus> so there's no benefit in hiding the state
10:56:01 <twobitsprite> can you help me do it though, so I can at least see more monad action?
10:56:14 <twobitsprite> just for examplary purposes?
10:59:17 <jethr0_> execState (modify (+1)) 0
11:01:18 <twobitsprite> jethr0_: ?
11:01:28 <twobitsprite> n/m maybe I should just read more tutorials
11:02:20 <jethr0_> twobitsprite: that wasn't directly as response to your answer
11:02:30 <jethr0_> in your case fold is quite a nice solution
11:03:26 <kosmikus> > let toInt rad num = foldl (\n p -> (n * rad) + p) 0 num in toInt 10 [1,2,3,4,5]
11:03:27 <lambdabot> 12345
11:03:28 <twobitsprite> jethr0_: right... but I was hoping to gain some insight by having someone guide me through the process of converting that to monadic style
11:03:36 <kosmikus> twobitsprite: why aren't you using this definition?
11:04:06 <jethr0_> twobitsprite: i understand that. but i'm pondering how to make that sensibly into a monadic form and it would just become more complicated
11:04:43 <twobitsprite> kosmikus: hmm... I guess I was thinking backwords :P
11:05:11 <kosmikus> twobitsprite: anyway, I think that this is a more or less faithful translation of your version into a variant using a State monad:
11:05:36 <kosmikus> > let toInt rad num = fst $ runState (foldM helper 0 (reverse num)) 0 where helper p n = do { e <- get; put (e + 1); return ((n * rad^e) + p) } in toInt 10 [1,2,3,4,5]
11:05:37 <lambdabot>  Not in scope: `put'
11:05:49 <kosmikus> hmm, ok, you need to import Control.Monad.State for this to work
11:06:15 <jethr0_> "e <- get; put (e+1)" == "modify (+1)"
11:06:24 <kosmikus> yes, but I still need the e
11:06:30 <kosmikus> modify returns ()
11:06:32 <ValarQ> lambdabot got modify but not put?
11:06:33 <jethr0_> ah, sry, just trying to be a smartass ;)
11:07:10 <jethr0_> ValarQ: haskell does the error messages a bit backwards in ghci/lambdabot
11:07:22 <kosmikus> this isn't very elegant, but I've said that before
11:07:27 <ValarQ> jethr0_: er, ok?
11:07:39 * twobitsprite meditates upon this :)
11:07:40 <kosmikus> foldM is a foldl, that's why there's a double reverse in the program compared to your original one
11:07:54 <jethr0_> ValarQ: i've tried to get lambdabot to use modify,put,get,... but to no avail. also not with explicity module prefixes
11:08:09 <kosmikus> (reverse num) being one, and helper n (p,e) --> helper p n being the other
11:08:54 <twobitsprite> foldM is like fold for monads?
11:09:04 <kosmikus> yes
11:09:07 <kosmikus> @type foldM
11:09:08 <lambdabot> Not in scope: `foldM'
11:09:14 <kosmikus> @type Control.Monad.foldM
11:09:15 <lambdabot> forall a (m :: * -> *) b.
11:09:15 <lambdabot>         (Monad m) =>
11:09:15 <lambdabot>         (a -> b -> m a) -> a -> [b] -> m a
11:09:19 <ValarQ> jethr0_: put must be excluded in some whay then
11:09:54 <jethr0_> kosmikus: it should work with some kind of mapM_ too.
11:09:58 <twobitsprite> so, I know that "* -> *" is a "kind" expression, but I have no idea what it means
11:10:53 <Cale> It means that in some sense, m is a function from types to types.
11:11:28 <Cale> similarly to how if t is a type, then Maybe t is a type.
11:11:32 <Cale> @kind Maybe
11:11:33 <lambdabot> * -> *
11:11:40 <Cale> @kind Integer
11:11:40 <lambdabot> *
11:11:45 <Cale> @kind Maybe Integer
11:11:45 <lambdabot> *
11:45:55 <sili> is there a way to do IPC or setup some sort of timers? i want to nicely exit after N seconds
11:46:23 <sili> using another process to sent the sigint is fine
11:52:18 <Shapr-nokia770> y0 wassup?
11:53:06 <dcoutts> Shapr-nokia770, yay!
11:54:22 <ValarQ> hej nokiaformaren
11:55:08 <MarcWeber> To which library does the module CCall belong?
11:57:34 <Shapr-nokia770> dcoutts, hiya!
11:57:46 <Shapr-nokia770> Yo ValarQ 
11:57:59 <dcoutts> Shapr-nokia770, so is yhc next?
11:58:16 <dcoutts> Shapr-nokia770, so what network mechanism are you using?
11:58:51 <Shapr-nokia770> Wifi?
12:02:13 <shapr> dcoutts, do you mean am I using the builtin wifi?wifi
12:02:18 <dcoutts> Shapr, right
12:13:08 <shapr> Sure is quiet.
12:16:31 <jips> what's new?
12:19:25 <MarcWeber> q
12:24:23 <sili> what are the benefits of point-free progamming?
12:24:28 <xerox> readability!
12:24:29 * xerox hides
12:24:46 <sili> aside from readability
12:24:47 <xerox> composability and whipuptitude.
12:24:54 <sili> :(
12:25:05 <xerox> i swear it's a bit about readability too.
12:29:56 * jethr0_ just had a nice idea for a jump'n'run character: a running lambda :)
12:30:22 <bolrod> my god..
12:30:35 <xerox> hah!
12:30:36 <bolrod> thats.....  possibly.. the most nerdish character ever
12:30:46 <jethr0_> *yeah*
12:30:51 <jethr0_> exactly what i was going for :)
12:31:02 <bolrod> :)
12:31:06 <shapr> I'm a little  shaper, drunk and stout
12:31:16 <bolrod> ::)
12:31:21 <jethr0_> like earthworm jim, but in lambda form
12:31:41 <bolrod> a jumping lambda.. trying to dodge curves and infinite sets
12:31:42 <shapr> Doh, never let your girlfriend grab the stylus
12:31:47 <jethr0_> hehe
12:32:03 <jethr0_> and you could put a little monad-bind in there like donkey kong's helper monkey
12:32:24 <bolrod> :)
12:32:58 <jethr0_> and one of the enemies would be the evil C# that tried to extiguinsh all lazyness
12:33:02 <bolrod> crossing the java world in search of haskellland
12:33:04 <jethr0_> k, getting ahead of myself
12:33:16 <bolrod> hehehe
12:33:57 <bolrod> C with the # boomerang
12:34:01 <bolrod> 8)
12:34:02 <jethr0_> he
12:34:37 <sili> sigh
12:34:42 <sili> haskell is fucking my brain
12:34:45 <jethr0_> in one level our little lambda would have to swim against the mainstream
12:34:53 <jethr0_> sili: how can i help?
12:34:55 <bolrod> hehe
12:35:12 <sili> jethr0_: develop that matrix learning machine thing and put haskell in my head.
12:35:23 <bolrod> :)
12:35:31 <sili> kung fu, too. i want to beat up morpheus
12:35:34 <jethr0_> i know kung-haskell!
12:35:46 <bolrod> Hey skipper, it looks like you're trying to put something in your head.. can I help?
12:35:51 <jethr0_> sili: no seriously, anything specific i can help with?
12:36:08 <bolrod> 8)
12:36:31 <sili> jethr0_: yes, i'd like to explore the plausability of writing the scheduler i need to write in haskell. so, write me the scheduler, and i'll decide if it's good or not :p
12:36:44 <bolrod> scheduler in haskell?...  
12:36:48 <sili> why not?
12:36:48 <jethr0_> scheduling what?
12:36:55 <sili> jethr0_: students into classes
12:37:01 <jethr0_> ah
12:37:12 <bolrod> bwah!
12:37:22 <bolrod> scheduler... haskell is too lazy to follow schedules
12:37:23 <bolrod> :)
12:37:28 <jethr0_> doesn't sound so hard, maybe with a little non-determinism like cale's sudoku solver
12:37:35 <jethr0_> sili: any more specifications?
12:37:57 <bolrod> sudoku solver.. hmm.. yes.. thought about writing one sometimes
12:37:58 <bolrod> -s
12:38:07 <bolrod> shouldn't be too hard I guess.........
12:38:27 <sili> jethr0_: lots... i know how to express myself in imperative languages, haskell is another story
12:38:44 <xerox> 'night.
12:39:12 <bolrod> I'm not too familiar with haskell..
12:39:21 <bolrod> bust just forgetting everything about imperative programming sure helps
12:39:22 <bolrod> :P
12:39:28 <bolrod> but*
12:40:10 <jethr0_> sili: if you gave me an overview of what you need i might be inclined to write sth for you..
12:40:19 <bolrod> haha
12:40:22 <bolrod> wait
12:40:28 <bolrod> I have some program I need to make
12:40:30 <bolrod> >:)
12:40:33 <sili> jethr0_: cool. not yet though
12:40:37 <sili> i have more thinking to do
12:40:51 <bolrod> thinking? :)
12:43:13 <jethr0_> sili: i'd like to help, but i'll be off soon. anything short you could tell me? classes have a max. number of students, students give favorite classes in descending order, ...?
12:44:35 <sili> jethr0_: there's a lot to it. thanks anyway
12:44:42 <sili> i'll just harass here again later if i need more
12:45:43 <jethr0_> don't worry, there are always lots of helpful people around :)
12:50:40 <|ct16k|> hy! what's the shortest way to add two [int]s? (eg [1,2,3]+[1,3]=[2,5,3])
12:51:16 <jips> > zip [1, 2, 3] [1, 2]
12:51:17 <lambdabot> [(1,1),(2,2)]
12:55:24 <jethr0_> > let a = [1,2,3]; b = [1,2]; f' a b = zipWith (+) a b ++ drop (length b) a in f a b = if length a > length b then f a b else f b a
12:55:25 <lambdabot>  parse error on input `='
12:55:48 <jethr0_> > let f' a b = zipWith (+) a b ++ drop (length b) a; f a b = if length a > length b then f a b else f b a in f [1,2,3] [1,2]
12:55:49 <lambdabot> Add a type signature
12:56:07 * jethr0_ wonders why he never uses the lambdabot in private msg mode...
12:56:41 <jethr0_> and that should read f' in both cases inside "f" *grmpf*
12:57:40 <jethr0_> > let f' a b = zipWith (+) a b ++ drop (length b) a; f a b = if length a > length b then f' a b else f' b a in f [1,2,3] [1,2]
12:57:41 <lambdabot> [2,4,3]
12:58:27 <ct16k> humm... thx :)
12:58:43 <jethr0_> padding with 0s would be an alternative approach
13:00:39 <jethr0_> > let f [] [] = []; f [] xs = xs; f xs [] = xs; f (x:xs) (y:ys) = x+y:f xs ys in f [1,2,3] [1,2]
13:00:41 <lambdabot> [2,4,3]
13:00:46 <sili> heh. i'm glad i just learned about named fields for data types
13:01:38 <ct16k> jethr0_: the last one was smth I came up with on my own, but was hoping for smth more... elegant
13:01:45 <ct16k> to say so
13:02:05 <ct16k> and I was just studying the zipWith description
13:02:17 <jethr0_> essentially it's a tweaked zip. so one could write a tweaked zipWith and reuse that
13:03:11 <ct16k> I'm kind of hoping to be to find an alternative solution without checking len
13:03:24 <ct16k> would that be possible?
13:04:06 <jethr0_> ct16k: i mean writing a function "zipWith'" and reusing that whenever that use case came up
13:04:59 <jethr0_> ct16k: maybe... you could use length on the list produced by "zipWith"...
13:05:03 <ct16k> ah... now that's elegant. I'll just make it not drop the elems from the longest list
13:10:09 <palomer> > zipWith (+) [1..] [2..]
13:10:10 <lambdabot> [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,
13:10:10 <lambdabot> 53,55,57,59,61,63,65,67,69,71,73,75,77,79,81,83,85,87,89,91,93,95,97,99,
13:10:10 <lambdabot> 101,103,105,107,109,111,113,115,117,119,121,123,125,127,129,131,133,135,
13:10:10 <lambdabot> 137,139,141,143,145,147,149,151,153,155,157,159,161,163,165,167,169,171,
13:10:10 <lambdabot> 173,175,177,179,181,183,185,187,189,191,193,195,197,199,201,203,205,207,
13:10:12 <lambdabot> [24 @more lines]
13:10:25 <palomer> > zipWith mod [1..] [1..]
13:10:29 <lambdabot> [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
13:10:31 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
13:10:33 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
13:10:35 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
13:10:37 <lambdabot> 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
13:10:40 <lambdabot> [23 @more lines]
13:10:44 * vincenz peers at palomer 
13:10:48 <jethr0_> you my friend are a spammer
13:10:52 * vincenz agrees
13:10:57 <palomer> I disagree!
13:10:58 <ValarQ> he sure is
13:11:01 * vincenz suggests people use [1..10]
13:11:14 <palomer> I suggest that you're all quite mistaken
13:11:25 <palomer> any objections to my suggestions?
13:13:03 <davidhouse> what happened to that idea of mine to shorted lambdabot's output?
13:13:26 <davidhouse> one line if the @eval was in-chan, five or however many if in PM.
13:14:03 <jethr0_> davidhouse: someone objected that bots shouldn't initiate PMs
13:14:19 <davidhouse> they wouldn't be.
13:14:28 <davidhouse> if the @eval was in a PM, then respond with five or whatever lines
13:14:40 <davidhouse> if the @eval was in-channel, just post 1 line. fin.
13:15:13 <ValarQ> i've seen lambdabot take to lines to report an error
13:15:28 <ValarQ> so 1 line might be to short
13:15:43 <ValarQ> s/take to/take 2/
13:16:08 <davidhouse> perhaps errors, @types, @hoogles etc should be handled seperately.
13:16:40 <palomer> davidhouse: sounsd good
13:17:00 <ihope> > 2*2*3*3*5*5*7*7*11*11-1
13:17:01 <ValarQ> yeah, but 2 rows of calculations isn't that bad
13:17:02 <lambdabot> 5336099
13:17:21 <ihope> Not prime?
13:17:23 <ihope> Aww.
13:18:17 <davidhouse> > 2309 * 2311
13:18:18 <lambdabot> 5336099
13:18:47 <jethr0_> > let f x y = catMaybes . takeWhile isJust $ zipWith (\a b -> case (a,b) of (Nothing,Nothing) -> Nothing; _ -> return ((maybe 0 id a) + (maybe 0 id b))) (map Just x ++ repeat Nothing) (map Just y ++ repeat Nothing) in f [1,2,3] [1,2]
13:18:48 <lambdabot> [2,4,3]
13:19:08 <jethr0_> *ahh*, that's pure beaty in my eyes ^_^
13:19:19 <ihope> :-)
13:19:27 <ihope> @type catMaybes
13:19:29 <lambdabot> Not in scope: `catMaybes'
13:19:33 <ihope> @index catMaybes
13:19:35 <lambdabot> Data.Maybe
13:19:52 <jethr0_> hmm, maybe i don't need the filter...
13:20:13 <jethr0_> yes, i do :)
13:20:34 <davidhouse> > let x `divides` y = (x `mod` y) /= 0; isPrime x = all (not.divides x) [1..x] in isPrime 5336099
13:20:35 <lambdabot> False
13:20:36 <ihope> So where's that tool that gives random prime numbers with certain numbers of digits?
13:21:01 <ihope> Wait a minute...
13:21:14 <ihope> So 5336099 *is* what I wanted!
13:21:52 <jethr0_> davidhouse: trying to divide by zero doesn't seem right
13:21:56 <jethr0_> *by one
13:22:11 <davidhouse> oops
13:22:14 <davidhouse> > let x `divides` y = (x `mod` y) /= 0; isPrime x = all (not.divides x) [2..x] in isPrime 5336099
13:22:15 <lambdabot> False
13:22:21 <davidhouse> > let x `divides` y = (x `mod` y) /= 0; isPrime x = all (not.divides x) [2..x - 1] in isPrime 5336099
13:22:23 <lambdabot> False
13:22:53 <jethr0_> and defining "x `divides` y" as "x `mod` y" might be construed as non-intuitive
13:23:02 <jethr0_> *considered
13:23:20 <astrolabe> shouldn't it be == rather than /=?
13:23:47 <ihope> Sí, señor((it)a).
13:23:51 <davidhouse> there's something wrong, hang on
13:25:39 <astrolabe> > let x `divides` y = (y `mod` x) == 0; isPrime x = all (not.divides x) [2..x-1] in isPrime 5336099
13:25:42 <lambdabot> True
13:25:57 <ihope> That's not right.
13:26:05 <astrolabe> why not?
13:26:14 <ihope> > 2309 * 2311
13:26:16 <lambdabot> 5336099
13:26:23 <ihope> > let x `divides` y = (y `mod` x) == 0; isPrime x = all (not.divides x) [2..x-1] in isPrime 2
13:26:25 <lambdabot> True
13:26:27 <ihope> > let x `divides` y = (y `mod` x) == 0; isPrime x = all (not.divides x) [2..x-1] in isPrime 3
13:26:28 <lambdabot> True
13:26:30 <ihope> > let x `divides` y = (y `mod` x) == 0; isPrime x = all (not.divides x) [2..x-1] in isPrime 4
13:26:30 <davidhouse> got it.
13:26:32 <lambdabot> True
13:26:35 <ihope> ;-)
13:26:38 <ihope> > let x `divides` y = (y `mod` x) == 0; isPrime x = all (not.divides x) [2..x-1] in isPrime 100
13:26:40 <lambdabot> True
13:27:03 <astrolabe> > let x `divides` y = (y `mod` x) == 0; isPrime x = all (not.(flip divides) x) [2..x-1] in isPrime 5336099
13:27:03 <davidhouse> let x `divides` y = (y `mod` x) == 0; isPrime x = all (not. ( `divides` x)) [2..x - 1] in isPrime 5336099
13:27:04 <lambdabot> False
13:27:05 <davidhouse> > let x `divides` y = (y `mod` x) == 0; isPrime x = all (not. ( `divides` x)) [2..x - 1] in isPrime 5336099
13:27:07 <lambdabot> False
13:27:13 <davidhouse> heh
13:27:15 <jethr0_> davidhouse: don't you mean "x `mod` y"?
13:27:24 <jethr0_> k, or that way round
13:27:26 <ihope> > let x `divides` y = (y `mod` x) == 0; isPrime x = all (not. ( `divides` x)) [2..x - 1] in isPrime 37
13:27:28 <lambdabot> True
13:27:44 <jethr0_> AND lambdabot works in private message mode
13:28:00 <ihope> GASP, really?
13:28:02 <davidhouse> ghci is good too
13:28:37 <davidhouse> > let x `divides` y = (y `mod` x) == 0; isPrime x = all (not. ( `divides` x)) [2..x - 1] in take 10 [ x | x <- [1..], isPrime x ]
13:28:38 <lambdabot> [1,2,3,5,7,11,13,17,19,23]
13:28:51 <ct16k> couldn't you make the upper limit of the list sqrt(x)?
13:28:58 <davidhouse> oh yeah.
13:29:02 <ct16k> as it doesn't make any sense to check above that
13:29:11 <astrolabe> 1 isn't a prime
13:29:23 <davidhouse> > let x `divides` y = (y `mod` x) == 0; isPrime x = all (not. ( `divides` x)) [2..x - 1] in take 10 [ x | x <- [2..], isPrime x ]
13:29:25 <lambdabot> [2,3,5,7,11,13,17,19,23,29]
13:29:46 <jethr0_> please change "y `mod` x" to "x `mod` y" and undo the later `divides`
13:29:52 <ValarQ> astrolabe: why not?
13:30:08 <davidhouse> > let isPrime x = (all (\y -> x `mod` y /= 0) [2..(ceiling(x/2))]) in [ z | z <- [1..], isPrime z] -- this is something i did ages ago
13:30:09 <lambdabot> Add a type signature
13:30:11 <ihope> Um...
13:30:29 <davidhouse> and it evidently doesn't work
13:30:47 <ihope> @type let isPrime x = (all (\y -> x `mod` y /= 0) [2..(ceiling(x/2))]) in [ z | z <- [1..], isPrime z]
13:30:48 <lambdabot> forall a.
13:30:48 <lambdabot>                                   (RealFrac a,
13:30:48 <lambdabot>                                   Integral a) =>
13:30:48 <lambdabot>                                   [a]
13:31:11 <astrolabe> valarQ: I don't understand your question.  Primes could be defined to include 1 or not.  They are defined not to include 1.
13:31:12 <jethr0_> "A prime number (or prime integer, often simply called a "prime" for short) is a positive integer p>1 that has no positive integer divisors other than 1 and p itself. "
13:31:16 <ihope> ValarQ: because then nothing else would be prime, as it'd all be divisable by 1.
13:32:08 <ValarQ> astrolabe, ihope: ok
13:32:18 <jethr0_> and factorisation would always include an arbitrary number of ones, making the factorisation non-unique
13:32:44 <ihope> My definition: a prime number is an integer that is not divisible by any lower prime such that 2 is prime but no number lower than 2 is prime.
13:33:34 <drakioned> ooh, primes.
13:33:38 <ihope> It could be modified to something like "such that 3 is prime but no number lower than 3 is prime", but this would result in different prime numbers :-)
13:34:02 <ValarQ> drakioned: yeah, they seem to be some sort of numbers
13:34:05 <astrolabe> In ring theory, a prime is an element p, not 0 or a unit such that whenever p divides ab, it either divides a or b.
13:34:07 <ihope> I think the only difference would be 4 being prime and 2 not being prime.
13:35:04 <drakioned> can we just define them normally, something like: that a prime is a natural number with no proper divisors asides from the trivial one?
13:35:22 <astrolabe> an irreducible is an element i not 0 or a unit such that whenever i = ab, either a or b is a unit.
13:35:30 <davidhouse> > let divides x y = x `mod` y == 0; isPrime x = all (\y -> not $ x ` divides` y) (takeWhile (\z -> z*z <= x) [2..]) in take 10 [ x | x <- [2..], isPrime x ]
13:35:31 <lambdabot> [2,3,5,7,11,13,17,19,23,29]
13:35:47 <davidhouse> that was from a project when i was very new to haskell
13:36:00 <astrolabe> It is easy to show all irreducibles are prime.  In the integers, all primes are irreducable.
13:36:59 <jethr0_> ihope: then many numbers wouldn't have a prime factorization. 6 = 3*?
13:37:17 <ihope> jethr0_: so?
13:37:21 <davidhouse> heh
13:37:32 <jethr0_> just sayin'
13:37:33 <astrolabe> oops.  wrong way round :o
13:37:33 <davidhouse> unique prime factorisations is one of the most useful tools in number theory
13:37:34 <drakioned> what weird system are you people working in?
13:37:59 <ihope> jethr0_: 1/2 doesn't have a prime factorization ;-)
13:38:05 <davidhouse> integers.
13:38:07 <davidhouse> naturals, actually
13:38:17 <davidhouse> astrolabe: defined over a group?
13:38:23 <ihope> drakioned: the two-isn't-prime system.
13:38:37 <jethr0_> drakioned: don't mind us fools :)
13:38:44 <astrolabe> davidhouse: a commutative ring.
13:39:06 <astrolabe> There is a natural extension of prime factorisation to the rationals.
13:39:07 <drakioned> commutative rings. arggghhhh
13:39:18 <drakioned> er.. there is?
13:39:31 <davidhouse> why does it need a ring? if all you're talking is multiplication and units, surely you'd just need a group
13:40:04 <drakioned> what does it mean for a number to be prime in a group?
13:40:14 <ihope> > let pt x = all (\y -> x `mod` y /= 0) (takeWhile (\y -> y*y <= x) pl); pl = 2 : filter pt x in take 10 pl
13:40:15 <lambdabot>  Not in scope: `x'
13:40:24 <ihope> > let pt x = all (\y -> x `mod` y /= 0) (takeWhile (\y -> y*y <= x) pl); pl = 2 : filter pt [2..] in take 10 pl
13:40:26 <lambdabot> [2,2,3,5,7,11,13,17,19,23]
13:40:32 <ihope> Oops :-)
13:40:50 <drakioned> > let pt x = all (\y -> x `mod` y /= 0) (takeWhile (\y -> y*y <= x) pl); pl = filter pt [2..] in take 10 pl
13:40:51 <lambdabot> Terminated
13:41:05 <ihope> s/[2..]/[3..]/
13:41:16 <drakioned> > let pt x = all (\y -> x `mod` y /= 0) (takeWhile (\y -> y*y <= x) pl); pl = 2 : filter pt [3..] in take 10 pl
13:41:18 <lambdabot> [2,3,5,7,11,13,17,19,23,29]
13:41:20 <astrolabe> every non-zero rational can be written uniquely as a finite product +/- p_1^i_1 *...* p_n^i_n for prime p_j and non-zero integers i_j
13:41:28 <ihope> Or s/[2\.\.]/[3..]/ if you want :-P
13:42:19 <ihope> let pt x = all (\y -> x `mod` y /= 0) (takeWhile (\y -> y*y <= x) pl); pl = 3 : filter pt [4..] in pl -- a very weird list of primes
13:42:30 <davidhouse> > let divides x y = x `mod` y == 0; isPrime x = all (not . (x ` divides`)) (takeWhile ((<=x).(^2)) [2..]) in take 10 [ x | x <- [2..], isPrime x ]
13:42:33 <lambdabot> [2,3,5,7,11,13,17,19,23,29]
13:42:53 <liyang> astrolabe: you mean integer?
13:43:23 <liyang> oh, i_j are integers too.
13:43:42 <astrolabe> :)
13:43:55 <davidhouse> how can it?
13:44:07 <davidhouse> that's a product of integers, and so an integer
13:44:16 <drakioned> :t notdiv
13:44:18 <astrolabe> i_j can be negative
13:44:44 <drakioned> hmm
13:44:44 <davidhouse> oh, to the i_j. i thought it was just * again.
13:45:19 <drakioned> I'm confused
13:45:27 <davidhouse> that's quite cool.
13:45:35 <drakioned> what's i_j ?
13:45:49 <davidhouse> you pick some primes
13:45:54 <davidhouse> call them p_1, p_2, p_3...
13:45:58 <davidhouse> then pick some integers
13:46:01 <ihope> Whoa!
13:46:03 <davidhouse> call them i_1, i_2, i_3...
13:46:07 <astrolabe> for instance 4/3 = 2^2 * 3^ (-1)
13:46:19 <davidhouse> then do p_1^i_1 * p_2^i_2...
13:46:31 <davidhouse> and if you picked the right primes and integers you get the number you wanted
13:46:31 <liyang> It's just the fundamental theorem of arithmetic / unique factorisation theorem extended to the rationals.
13:46:49 <drakioned> oh.. why's it called i_j?
13:47:05 <davidhouse> the whole series is called i_j
13:47:10 <astrolabe> '_' means subscript
13:47:18 <liyang> http://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic
13:47:34 <davidhouse> it's just convention: you use a variable instead of a number to indicate any general term
13:48:24 <drakioned> ok.
13:48:34 <astrolabe> I chose 'i' to stand for 'index'
13:49:28 <sieni> hmmh.... is there a #basic-mathematics channel on freenode?
13:49:37 <davidhouse> it's quite normal to say "the ith term" etc.
13:49:44 <davidhouse> sieni: #haskell. :)
13:50:05 <davidhouse> i like freenode's #math. they have a lambdabot.
13:50:10 <sieni> isn't #haskell-overflow better for such discussions or something
13:50:37 <davidhouse> you got any haskell discussions? or do you just want to kill the conversations
13:50:51 <sieni> no
13:50:51 <resiak> How can you express 1/2 as sigma p_j i_j if i_j are integers?
13:50:54 <astrolabe> #math has lots of homework questions
13:51:04 <davidhouse> resiak: 2^-1
13:51:12 <resiak> doh
13:51:13 <drakioned> so the claim is that every rational number can be be expressed as a unique factorisation (up to order) of powers of primes?
13:51:22 <resiak> This is why I fail the maths, because I fail to read
13:51:26 <liyang> resiak: not \Sigma, \Pi.
13:51:40 <resiak> liyang: I meant that, too
13:51:50 <sieni> drakioned: probably, which is a trivial conclusion from the fact that every integer can be expressed in such a format
13:51:58 <liyang> :)
13:52:01 <astrolabe> You either have to include all the primes, or exclude zero powers to get uniqueness.
13:53:37 <drakioned> hmm
13:53:52 <astrolabe> davidhouse: That is an interesting observation that you only need the multiplicative structure to define primes and irreducables.
13:54:07 <drakioned> I'm not sure that makes all that much sense.
13:54:12 <davidhouse> otherwise you can just do any_random_prime^0 * the rest of the stuff and it's not unique
13:54:28 <sieni> Well, what is claimed, that you can reduce a rational into a form where the numerator and denominator are relatively prime. If they are not, just divide by the greatest common divisor. D'oh.
13:54:52 <drakioned> see, that makes more sense.
13:55:13 <astrolabe> That's existence.  You need uniqueness too :)  (not that it's hard)
13:56:10 <sili> haskell is hard.
13:56:19 <astrolabe> yeah
13:56:26 <davidhouse> great, isn't it
13:56:56 <drakioned> Haskell seems easier to learn than any other programming I've tried..
13:57:11 <sieni> I don't think Haskell is that hard. Although I think that exposure to Scheme before has helped a lot
13:57:14 <davidhouse> drakioned: woah! what languages have you tried?!
13:57:23 <drakioned> umm. Java, Prolog.
13:57:33 <sili> those languages are easy
13:57:52 <drakioned> dunno, I can write pages and pages of Java and still can't get it to do anything.
13:57:55 <davidhouse> there's a lot of concepts in functional programming that would turn your average OOP monkey into a gibbering wreck
13:58:18 <sieni> Well, Haskell might be marginally harder to learn than Scheme, but is certainly many orders of magnitude easier to learn than C++.
13:58:26 <sili> davidhouse: it's not just the functional programming that's getting to me, it's haskell
13:58:36 <sili> sieni: whhaaaa?
13:58:57 <davidhouse> C++ is hard for precisely one reason: memory management.
13:58:57 <ihope> Say... where's me Preluded list of primes? :-)
13:59:21 <drakioned> *shrug* I dunno, in Haskell, I tend to just type what I would like the computer to do and ghc seems to take care of the rest.
13:59:24 <sieni> sili: Could you explain for me for example what protected inheritance means and explain some idioms, where it can be naturally used.
13:59:30 <sieni> davidhouse: not only that
13:59:42 <kosmikus> I agree. C++ is horribly complex.
13:59:49 <kosmikus> with siensi, that is.
13:59:52 <kosmikus> sieni, even.
14:00:20 <liyang> ( So you can reduce any rational to m/n where m = \Pi_i p_i^j_i and n = \Pi_i p_i^k_i (where some of the j_i or k_i are zero) and uniquely, m/n = \Pi p_i^(j_i - k_i) ... up to all that zero-th power nonsense.)
14:00:44 <sili> sieni: protected inherited stuff is hidden from the public, but visible to children. you might use something like that for a Animal class that has a lick() method. you don't want users calling lick() because it's an internal method
14:01:15 <tuomov> accessing "raw" data structures seems a bit too complicated in haskell
14:01:19 <sili> but you want the child class Dog() to be able to clean himself when necessary. or something
14:01:29 <sieni> sili: Yes, I know what it means in a superficial level as you just explained, but how would you use it in any real application and why?
14:01:50 <davidhouse> OOP isn't nearly as hard as functional programming
14:01:57 <tuomov> by raw I mean that the layout in memory must be something specified
14:02:00 <kosmikus> davidhouse: why?
14:02:08 <drakioned> davidhouse, funny, I'd have said it the other way around
14:02:17 <sili> sieni: you'd use it in any case like the one i explained...
14:02:20 <TuringTest> I think people need to define "hard"
14:02:43 <davidhouse> kosmikus: my experience
14:02:44 <kosmikus> I think that whatever you learn first is easier than the other.
14:02:45 <drakioned> TuringTest, time taken to code something I guess.
14:03:02 <davidhouse> kosmikus: that's probably true
14:03:05 <davidhouse> drakioned: still subjective
14:03:14 <liyang> davidhouse: explain multiple inheritance. ;)
14:03:23 <davidhouse> liyang: sin on legs
14:03:33 <sieni> Of course, multi-level inheritance sucks ass anyway and only usefule feature in C++ is that you can have an abstract class and then a bunch of implementation class that derive from it, but that's about it. Otherwise C++ just gives you the liberty to shoot yourself in the foot in manners completely unimaginable for a C programmer
14:03:42 <drakioned> well, they taught me Java a good semester before they taught me Haskell, but it seems to take a shorter amount of time to get anything done in Haskell for me..
14:03:42 <sili> MI per se isn't evil, it's the users who are doing stuff incorrectly
14:03:45 <tuomov> simple OO isn't complicated. OO occording to the OOP religion is.
14:04:22 <davidhouse> drakioned: depends what you write
14:04:24 <sieni> I would say, that multiple inheritance is almost always wrong and deriving from a non-abstract class is almost always wrong
14:04:32 <davidhouse> if you write hardcore algorithms, haskell is god.
14:04:41 <davidhouse> well, functional programming is
14:04:48 <tuomov> depends on the algorithm..
14:04:55 <kosmikus> Both OO and FP are reasonably simple to grasp, if you look at the concepts independent of any languages.
14:05:14 <tuomov> e.g. I gave up implementing a sparse bitmap with data directly mmapped from disk in haskell
14:05:30 <sieni> if you stick to just giving implementations of an abstract interface, well: you can get the same effect with ML functors or Haskell type classes
14:05:37 <drakioned> well, not even that, it took me a shorter time to figure out how to use wxHaskell to display some buttons than in Java
14:05:40 <tuomov> it's just much mor enatural in C
14:05:47 <pejo> sieni, the largest problem with MI in c++ that people see is the implementation inheritance. 
14:06:04 <tuomov> although, the bitmap intersection stuff would then be more natural in haskell, as I have to hack lazyness into C :)
14:06:55 <sieni> tuomov: I don't have anything against using C, where it's applicable. especially if the real language has a good FFI
14:07:45 <drakioned> C.. there's another language I can't make head or tail out of..
14:07:48 <tuomov> sieni: I was just telling davidhouse that not all algorithms are that well implemented in FP
14:07:54 <tuomov> (or haskell in particular)
14:08:33 <tuomov> sometime the algorithms (well, usable implementation anyway) depend so much on the hardware details
14:08:34 <sieni> btw, if there's anybody who hasn't noticed that Chris Okasaki's book "Purely Functional Data Structures" is fucking awesome, I'll tell you that Chris Okasaki's book "Purely Functional Data Structures" is fucking awesome.
14:08:52 <davidhouse> tuomov: true.
14:09:27 <drakioned> I think sieni is Chris Okasaki in disguise.
14:10:00 <sieni> drakioned: O RLY?
14:10:02 <tuomov> I scanned through the shorter online version of the book once.. interesting stuff indeed
14:10:17 <sili> i think i need a good haskell book
14:10:35 <drakioned> I think you should buy Graham Hutton's book.
14:10:37 <liyang> sieni: NO U.
14:11:06 <sili> drakioned: i'm frightened by any haskell / functional programming book
14:11:06 * liyang seconds drakioned 
14:11:24 <drakioned> read Graham Hutton's book.
14:11:40 <sili> is it full of stuff i won't possibly understand?
14:11:58 <drakioned> I doubt it, it starts at pretty much the beginning (afaik)
14:12:12 <sili> book name?
14:12:30 <kosmikus> Graham's book is very basic. Good for beginners.
14:12:35 <drakioned> "Programming in Haskell"
14:12:58 <kosmikus> Not really very interesting for people who already know Haskell.
14:13:05 <sili> is it me, or is that not on amazon
14:13:05 <drakioned> it's suppose to be released sometime this year, most of the chapters are online
14:13:29 <drakioned> first couple of chapters (preview) -> http://www.cs.nott.ac.uk/~gmh/preview.pdf
14:14:11 * drakioned plugs Graham Hutton's book some more.
14:16:01 <liyang> `lol'
14:16:11 <sili> eh.
14:17:18 <drakioned> it was the course text for a course I took.
14:17:41 <sieni> Also Paulsen's book "ML for a working programmer" is a nice introduction to functional programming, even though it uses Standard ML instead of Haskell
14:17:56 <davidhouse> pfft.
14:17:58 <sieni> (better than anything I've seen solely for Haskell)
14:17:59 <davidhouse> @where yaht
14:18:00 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
14:18:10 <davidhouse> that's all you need
14:18:40 <sili> davidhouse: i've been reading that and it's pretty good
14:18:41 <ihope> Note to self: "we write" followed by an unknown notation is nothing to worry about.
14:18:59 <sili> davidhouse: but some things are slighted
14:19:01 <sieni> Well, actually the "gentle" "introduction" is quite nice.
14:19:06 <davidhouse> sili: it's got some problems
14:19:54 <sili> i'd really like to try and use haskell for a scheduler but the learning curve is kicking my ass
14:20:23 <liyang> The classic one is Bird and Wadler, Introduction to FP; or the updated second edition by Bird.
14:20:26 <drakioned> does anyone want to teach me how to do anything with an array in Haskell?
14:20:42 <sili> drakioned: there's a section in yaht about arrays
14:20:55 <sili> which seems pretty simple except for accumArray, which I didn't grok
14:21:30 <kosmikus> liyang: those are still my favourties. glad you mentioned them.
14:21:52 <liyang> I think this is a rather cool quote: ``If you find that the theory doesn’t match the implementation, you should probably rethink the implementation.''
14:24:30 <sili> maybe i'm having so many problems cause i keep trying to equate something in haskell to a tangible expression in a language i know
14:25:11 <drakioned> try and equate it to mathematics
14:26:00 <davidhouse> just start easy
14:26:04 <davidhouse> write lots of easy programs
14:26:15 <davidhouse> you get a feel for how to handle the various data structures
14:26:54 <sieni> yes, mathematics is a good way of thinking about haskell :-)
14:30:05 <davidhouse> what would be a nice project to test my understanding of monad transformers?
14:30:53 <_Codex> parsers?
14:31:11 <davidhouse> specifically
14:31:12 <davidhouse> ?
14:31:57 <musasabi> Easy or hard?
14:32:12 <davidhouse> err
14:32:21 <davidhouse> well easy would be nice. perhaps with a slightly harder one as well
14:32:38 <drakioned> write something to parse arithmetic expressions?
14:33:20 <musasabi> parser + IO (#include and other such things) for something easy, continuations for hard things.
14:33:29 <ihope> Well... you won't learn Spanish by learning to translate it into English really fast.
14:34:03 <davidhouse> ihope: less abstractly?
14:34:49 <ihope> Um.
14:36:25 <davidhouse> musasabi: hmm... i'm not sure that would really lend itself toward monad transformers
14:36:41 <davidhouse> it's easy enough to work at the top level in IO, and lower down in another monad without using MTs.
14:38:35 <ihope> liftM . liftM
14:38:59 <ihope> @type Control.Monad.liftM . Control.Monad.liftM
14:39:01 <lambdabot> forall (m :: * -> *)
14:39:01 <lambdabot>                   a1
14:39:01 <lambdabot>                   r
14:39:01 <lambdabot>                   (m1 :: * -> *).
14:39:01 <lambdabot>                (Monad m, Monad m1) =>
14:39:03 <lambdabot>                (a1 -> r) -> m (m1 a1) -> m (m1 r)
15:00:03 * palomer hits sml
15:00:09 <palomer> god the value restriction is annoying
15:00:14 <palomer> thank god no such thing exists in haskell
15:05:26 <araujo> Hello
15:05:28 <araujo> Is this the channel of that weird programming language with no side-effects? 
15:06:18 <dcoutts> araujo, go change your nick and try again :-)
15:06:29 <araujo> dcoutts, hah, hiya!!!
15:06:39 <kosmikus> it worked for me without changing my nick once
15:06:43 <dcoutts> heh
15:08:20 <jips> hello dcoutts 
15:08:27 <dcoutts> hia jips 
15:08:52 <jips> hello kolmodin_ 
15:09:11 <jips> hello araujo 
15:11:12 <araujo> hello jips , what's up?
15:12:11 <jips> how hard is it to write multithreaded networking applications in haskell? like a webserver?
15:14:05 * sili says very, but wouldn't know
15:16:09 <Lemmih> jips: Pretty easy.
15:16:43 <dcoutts> jips, and compared to the C/Java/Python versions they're rather shorter
15:17:38 <araujo> jips, very easy
15:17:49 <jips> because i am interested in using haskell to program the server side logic of an "ajax web application" and it seems that just writing the entire thing from scratch might be the best idea
15:19:09 <musasabi> jips: HAppS is used for AJAX like things.
15:19:41 <musasabi> jips: but you might want to wait a week for a new version with fresh examples being published.
15:25:14 <Cale> sili: still about? What sort of scheduler are you writing?
15:25:31 <Cale> I wrote a pipeline scheduler in Haskell, and had quite a good time of it.
15:26:15 <sili> Cale: one that puts students into classes given certain constraints. i know how it should be done, it's just the expresion of it in haskell that's the problem
15:26:33 <sili> Cale: because i just started learning haskell
15:26:53 <sili> and I don't figure it out quick, I get to use C++ or perl
15:27:02 <sili> if I *
15:28:28 <Cale> I'd think it would be a good way to use the list monad. At each step, you just need a list of the options, and the order in which to try them, and it will basically handle the rest.
15:29:02 <Cale> (the options as to what to try adding to your incomplete schedule)
15:29:32 <sili> i'm sure it'd be easy if I knew the language
15:30:20 <Cale> good luck with it, and let us know if you get stuck
15:30:28 <sili> word
15:36:20 <dons> moin
15:36:26 * palomer wonders why every programming language feels its its duty to create a new comment lexical token
15:37:11 <Pseudonym> Because every programming language has different operator lexical tokens.
15:37:30 <Pseudonym> Wadler's law applies.
15:40:49 <palomer> what's his law?
15:41:54 <Pseudonym> http://wadler.blogspot.com/2006/01/bikeshed-coloring.html
15:44:57 <sili>  mmm fun
15:48:27 <GeniXPro> Are there any algorithms/programs that can find a pattern between two sequences of numbers, like given {1, 2, 3} and {2, 4, 6}, it will figure out that the each element in the second one is the multiple 2 of the first? It can be a brute force solving algorithm, i just want to come out with an equation
15:51:24 <drakioned> I don't think it's possible to have such an algorithm.
15:51:49 <ihope_> Um...
15:52:01 <ihope_> Polynomial?
15:52:13 <GeniXPro> yes
15:52:27 <ihope_> Yeah, generate a polynomial including the points (1,2), (2,4), and (3,6).
15:52:45 <ihope_> I'm not sure just how this is done... /me digs up
15:53:27 <drakioned> could you not find more than 1 function that crosses those 3 points though?
15:53:45 <liyang> yes, but you construct the simplest one.
15:53:46 <GeniXPro> You probably could
15:53:56 <ihope_> I think there's only one quadratic function.
15:54:13 <ihope_> Just like there's only one linear function for two points, and only one constant function for one.
15:54:31 <ihope_> Well, this looks right: http://en.wikipedia.org/wiki/Polynomial_interpolation
15:54:35 <GeniXPro> I'm examing the following sequence: 1)  1,   2)  1,   3)  2,   4)  1,   5)  3,   6)  3,   7)  1
15:55:26 <ihope_> So points (1,1), (2,1), (3,2), (4,1), (5,3), (6,3) and (7,1)?
15:55:36 <GeniXPro> yep
15:56:48 <ihope_> Hmm...
15:58:05 <liyang> http://en.wikipedia.org/wiki/Lagrange_form gives you the actual formula you need.
15:58:37 <ihope_> Well, that means that [1,2,3,4,5,6,7] corresponds to [1,1,2,1,3,3,1]. Taking the difference thingies of that yields [0,1,-1,2,0,-2], and the diffs there would be [1,-2,3,-2,-2], then [-3,5,-5,0], then [8,-8,5], then [-16,13], then [29].
15:58:50 <ihope_> It doesn't look polynomial to me.
15:59:18 <ihope_> But it's still possible to fit a polynomial to it.
16:01:20 <GeniXPro> thanks for the help
16:01:25 <GeniXPro> Talk to yall later
16:01:35 <liyang> To fit n data points, in general you will you need an (n-1)-th order polynomial. The Lagrangian method shows you how to generate this polynomial.
16:14:52 <twobitsprite> how would you all feel about first class types? do you think they would increase expressivity, or kill type safety
16:15:07 * twobitsprite was just contemplating this
16:16:06 <ihope_> They'd kill type safety, but be lots of fun :-D
16:16:50 <ihope_> If (::) were an infix operator, what would its type be?
16:17:15 <ihope_> (::) :: forall a. exists b. a -> * -> b -- something like that
16:18:43 <ihope_> I don't know what exists does/did :-P
16:18:50 <ihope_> @google haskell exists
16:18:51 <lambdabot> http://www.haskell.org/onlinelibrary/directory.html
16:20:27 <ihope_> s/exists/forsome/, then.
16:20:35 <ihope_> That'd keep it typesafe, anyway.
16:21:55 <twobitsprite> hmm
16:22:06 <twobitsprite> @kind (->)
16:22:07 <lambdabot> ?? -> ? -> *
16:22:11 <twobitsprite> what does that mean?
16:22:21 <dons> first class types?
16:22:21 <ihope_> I dunno :-P
16:22:27 <ihope_> Aye.
16:22:35 <dons> what the?
16:22:39 <ihope_> forsome a. a = this value has a type
16:22:50 <dons> you mean, types on the value level?
16:22:55 <ihope_> Yep.
16:23:02 <ihope_> And kinds on the type level.
16:23:03 <dons> at runtime?
16:23:09 <ihope_> Um... yeah.
16:23:11 <dons> this is a dependent type system.
16:23:12 <dons> nasty
16:23:15 <dons> and at runtime too
16:23:19 <dons> even more evil
16:23:44 <dons> languages like the theorem prover twelf let you mix up kind/type and values
16:24:28 <dons> you'd need a type checker running at runtime, checking these weird expressoins, no?
16:24:51 <ihope_> Who needs to check types when we have extremelyUnsafeCoerce?
16:25:08 <twobitsprite> @type extremelyUnsafeCoerce
16:25:09 <lambdabot> Not in scope: `extremelyUnsafeCoerce'
16:25:12 <dons> ok, so that's C
16:25:40 <ihope_> Maybe this: http://www.haskell.org/pipermail/haskell/2004-April/013993.html
16:26:09 <ihope_> @index newIORef
16:26:10 <lambdabot> Data.IORef
16:26:18 <ihope_> @type Data.IORef.newIORef
16:26:19 <lambdabot> forall a. a -> IO (GHC.IOBase.IORef a)
16:26:40 <ihope_> @type Data.IORef.writeIORef
16:26:41 <lambdabot> forall a. GHC.IOBase.IORef a -> a -> IO ()
16:26:49 <ihope_> @type Data.IORef.readIORef
16:26:50 <lambdabot> forall a. GHC.IOBase.IORef a -> IO a
16:27:40 <ihope_> Combining those with undefined and unsafePerformIO, it's apparently possible to pop values from any type into any other type.
16:28:36 <dons> polymorphic iorefs break type safety
16:28:49 <ihope_> Well, that's why I call it extremelyUnsafeCoerce.
16:31:38 <ihope_> Stick it in a new file extension thingy though, and call it Extremely Unsafe Haskell :-)
16:32:34 <Saulzar> You've got things like Dynamic and existentials already 
16:33:51 <ihope_> How do existentials work, though?
16:35:02 <dons> you package a value of type 'a' with a dictionary, such that type 'a' isn't visible, and the only interface is via the dictionary
16:35:19 <dons> so  a whole bunch of different types can be treated as the same, as long as the yy have the same interface
16:35:28 <dons> and, it's all checked statically
16:36:29 <dons> \wiki Existential_type
16:36:30 <lambdabot> http://www.haskell.org/haskellwiki/Existential_type
16:41:25 <sethk> dons, that's interesting
16:43:24 <ihope_> Tell me what this does: data Shape = forall a. Shape_ a => Shape a
16:43:48 <sethk> ihope_, one thing it does is to give me a headache
16:43:51 <ihope_> Is it equivalent to data Shape = Shape (forall a. Shape a => a)?
16:44:28 <palomer> that forall should be exists
16:44:55 <ihope_> Ah, right.
16:45:42 * ihope_ attempts
16:45:45 <ihope_> ...to think
16:46:02 <palomer> so Shape holds a Shape
16:46:04 <dons> no, it's not equivalent to the 2nd. the 2nd says "Shape takes a polymorphic value , that is aninstance of Shape" -- no such value exists in fact, only bottom
16:46:16 <dons> whereas the first, the scope of the type 'a' is different
16:46:23 <dons> it takes some 'a' which is in Shape_
16:46:31 <dons> the 2nd is a rank-2 type
16:46:36 <palomer> the first isn't even legal, no?
16:46:41 <dons> the first is very legal
16:46:43 <ihope_> Now, are classes and types (rather, type constructors) in different namespaces?
16:46:47 <dons> it's an existential
16:47:06 <dons> you can read it as: exists a. ShapeClass a => Shape a
16:47:20 <ihope_> Okay.
16:47:22 <dons> so, there's some type 'a' in ShapeClass, but that's all you know about it
16:47:34 <dons> so you can only apply polymorphic functions to a Shape, or methods of ShapeClass
16:47:58 <palomer> the first one boggles the mind
16:48:00 <dons> the scope of the 'a' here is very differenet: Shape (forall a. Shape a => a)
16:48:08 <dons> this is not a useful type
16:48:19 <dons> but the first, forall a. Shape_ a => Shape a, is very useful
16:48:44 <dons> you can see the different if you ask ghc to infer the type of the constructor 'Shape'
16:49:04 <ihope_> How about "data Shape where Shape :: Shape_ a => a -> Shape"?
16:49:15 <ihope_> Would that work?
16:49:21 <dons> not sure what happens when you throw gadts in
16:49:58 <dons> you can try it by writing thhe code, and then trying to build a 'Shape' to see if it is useful
16:50:54 <dons> so, whenever you see a 'forall' on the left hand side of a class, in a data type decl, read it as an 'exists'
16:51:39 <dons> and know that the only thing you can do with it is apply polymorphic things to it, and methods from its class 
16:51:59 <dons> but, knowing that you can apply class methods makes it really useful
16:52:19 <ihope_> Um...
16:52:41 <dons> since then youu can do things you can't normally do -- since you have a new constraint
16:52:51 <dons> [1, 'x', ()] isn't legal right?
16:52:53 <ihope_> data Monad a where Monad :: Monad m => m a -> Monad a
16:53:03 <ihope_> dons: right...
16:53:19 <nothingmuch> can someone please compare uniqueness type based IO with monadic IO in terms of complexity?
16:53:21 <ihope_> Hmm, I see what you're getting at, I think.
16:53:32 <nothingmuch> it seems that uniqueness types are simpler
16:53:37 <nothingmuch> but i'm probably missing something
16:53:43 <ihope_> Those all have the type exists a. a, right?
16:56:57 <dons> but a list of existentials wrapping 1 , 'x', and () would be legal
16:57:19 <dons> which is what the wiki article describes
16:57:29 <ihope_> I see.
16:57:45 <dons> you make it safe since the code 'dynamically' dispatches to the class dictionary with the correct methods for each existential
16:59:19 <dons> so, I thin, existentials are not so scary after all  _but_ it's a pit y we don't have the world 'exists' for them yet
16:59:38 <dons> in ML, existentials are introduced very early, with their pack/unpack stuff.
17:00:19 <dons> we ge tthem via type classes, and reuse the 'forall' keyword. so its a bit harder.
17:00:22 <palomer> when you say ML, what are you referring to?
17:00:57 <dons> Standard ML
17:01:22 <ihope_> Dang, there's so many ways to convert between types of numbers...
17:02:12 <ihope_> Maybe there should be classes FromInteger, ToInteger, FromInt, ToInt, FromDouble, ToDouble etc. each defining only the respective type :-P
17:03:09 <ihope_> Anyway, I can conveniently define many of these toWhatever as fromNatural.
17:07:37 <ihope_> Now, whenever I see "In a 'do' expression: print it", I often think that means if it's in a do expression, printing it would solve the problem.
17:09:35 <ihope_> Okay here.
17:09:42 <ihope_> data Monad_ a where Monad :: Monad m => m a -> Monad_ a
17:09:54 <ihope_> What's the (>>=) for Monad_?
17:12:28 <ihope_> *bang bang bang*
17:20:10 <ihope_> Let's see here...
17:20:23 <ihope_> Monad_ a -> (a -> Monad_ b) -> Monad_ b
17:21:05 <ihope_> We can get the Monad_ b by applying Monad to any monadic value whatsoever.
17:23:55 <ihope_> But it's a better idea to apply it to a "sensible" value :-)
17:24:22 <ihope_> I realized that a Monad_ value is pretty much useless... oh well.
17:24:40 <dons> :)
17:25:13 <ihope_> I keep getting "can't match m against Monad_".
17:25:58 <ihope_> My current definition: (Monad a) >>= b = a >>= (Monad . b)
17:26:24 <ihope_> What's wrong with this?
17:27:38 <ihope_> Hmm...
17:30:17 <ihope_> Well, it looks like... um.
18:08:11 <Azzkicker> HOW TO: Boot Windows XP on Intel Based Mac's *Instructions Inside*
18:08:13 <Azzkicker> HOW TO: http://www.steaknbj.com/forum/showthread.php?t=83
18:10:39 <ihope_> Why would we want to use Windows XP?
18:11:12 <ihope_> Especially if we already have Mac OS...
18:15:24 <eivuokko> Some people only like the coverings on macs.
18:22:45 <dons> :)
18:26:32 <dons> \names
18:26:33 <lambdabot> Unknown command, try @listcommands.
18:26:45 <dons> ah, still not near the 200 user record
18:30:45 <jips> dons: hi
18:35:06 <dons> hey jips
18:35:14 <jips> dons: do you know who i am?
18:35:37 <dons> yes :)
18:35:40 <dons> :p
18:35:54 <jips> did you fix the bug? :D
18:35:56 <jips> :p
18:40:48 <dons> did _I_ fix the bug. not yet, no. did you send me a test case that fails?
18:49:15 <jips> no.... i'll try to fix the bug tomorrow morning... i gotta go to sleep now
18:49:54 <dons> ok :)
18:49:56 <jips> just wanted to make sure that all the debugging work i do tomorrow won't be redundant :)
18:50:07 <dons> nope.
18:50:13 <jips> nighty
18:50:15 <dons> i'm waiting for you to do it, or give up trying
18:50:19 <jips> heh
19:08:59 <lennart> howdy
19:09:55 <dons> hey lennart
19:10:51 <lennart> back on an LH flght again :)
19:11:41 <dons> you still in NYC? (Gabi works with you, right? -- She's my supervisor)
19:12:27 <lennart> She sits next to me, yup.
19:12:42 <dons> oh, ok :)
19:12:49 <lennart> and across from the people that buy and sell soy beans and pork bellies.
19:12:56 <dons> hehe
19:13:17 <dons> weird environment for lambda folks :)
19:13:28 <lennart> no kidding!
19:13:43 <lennart> i usually listen to my ipod
19:13:52 <dons> lol
19:13:59 <lennart> Gabi forgot hers in oz
19:17:30 <dons> oh!
19:17:42 <dons> so she's stuck with the pork bellies then.
19:18:07 <dons> hmm, maybe she should install hmp3..
19:19:01 <araujo> @yay!
19:19:02 <lambdabot> Unknown command, try @listcommands.
19:19:07 <araujo> :-(
19:19:51 <dons> araujo, write a \yay! :)
19:20:12 <lennart> the machines at Credit Suisse are incredibly firewalled.  and also very logged
19:20:30 <araujo> oh, right, lambdabot is being re-written now :-]
19:20:37 <dons> yeah, fair enough, lennart.
19:20:44 <dons> all work, no play :)
19:20:59 <dons> araujo, is being re-written?
19:21:26 <dons> oh, you mean @ versus \ versus ?
19:21:29 <araujo> lennart, that's why i don't work for important companies ;-)
19:21:40 <lennart> it's because of regulations.  the bank has to be able to prove that there's no insider trading if accused.  so all external communication has to be logged
19:21:42 <araujo> dons, yay!
19:26:03 <lennart> sometimes modern tecnology amazes me (even if I know how it works).  Here I set at 40000 feet somewhere over the atlantic listening to streaming mp3 from my server at home in sweden :)
19:26:22 <lennart> (but I can't spell!)
19:26:26 <Pseudonym> And watching your wallet drain?
19:27:36 <lennart> $30 for an entire flight
19:29:47 <dons> that's really cool :)
19:29:58 <dons> and on irc too.
19:30:25 <dons> i think this is only the 2nd #haskell-er coming to us from middair
20:08:50 <lennart> @listcommands
20:08:51 <lambdabot> use listcommands [module|command]. Modules are:
20:08:51 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock
20:08:51 <lambdabot> help hoogle karma lambda localtime more pl plugs poll pretty quote search
20:08:51 <lambdabot> seen spell state system todo topic type unlambda version vixen where
20:09:31 <lennart> @where pl
20:09:33 <lambdabot> I know nothing about pl.
20:10:03 <palomer> hello lennart
20:10:14 <lennart> hej!
20:10:39 <palomer> I'm learning about twelf, and I'm getting used to it by proving type preservation from this small little language
20:10:52 <palomer> and, since it's dependently typed, I thought you could give me some insight
20:11:24 <lennart> hmmmm, i can't say i have any twelf experience
20:11:36 <palomer> now, to me, a proof of type preservation would have the type: eval A V -> of A T -> of V T
20:11:47 <palomer> of A T is the set of proofs that A has type T
20:12:52 <palomer> however, my prof claims that there isn't a dependently type system that would let me do this, and I have to instead populate eval A V -> of A T -> of V T -> type
20:13:02 <lennart> And 'eval A V' says that A evaluates to V?
20:13:07 <palomer> lennart: yup
20:14:06 <palomer> you probably have something similar in cayenne, no?
20:14:48 <lennart> so your proof would operate on proofs.... hmmm
20:15:31 <lennart> so you want to constract a term of type 'eval A v -> of A T -> of V T' in twelf?
20:15:39 <palomer> yeah
20:15:45 <palomer> but my prof says I can't do this
20:16:15 <lennart> well, he might have some insight that I don't, but I don't see why this should be so
20:16:21 <palomer> she
20:16:28 <lennart> ok
20:16:32 <palomer> so, in cayenne, you could, right?
20:17:09 <lennart> well, it's expressible.  if you can actually prove it I'll leave unsaid
20:17:34 <lennart> so you must have a concrete representation of proofs?
20:17:34 <palomer> how so?
20:17:41 <palomer> or, rather, why so
20:18:01 <lennart> just that I've not done it, so I don't want to say it can be done
20:18:33 <lennart> sometimes there are technical snags that stop you from doing something
20:19:02 <lennart> why does she claim it can't be done?
20:19:25 <palomer> she said it's a limitation of dependently typed systems
20:19:31 <palomer> can cayenne be used as a theorem prover?
20:19:55 <lennart> well, theorem checker
20:20:11 <lennart> you provide the proof, it checks that your proof is ok
20:20:23 <palomer> does it do term reconstruction?
20:20:41 <lennart> very limited
20:21:05 <lennart> if you actually want to make proofs in something like cayennne you should use Agda
20:21:33 <palomer> a functional twelf?
20:22:11 <lennart> i guess you could say that
20:22:23 <lennart> it's about the same syntax as cayenne
20:22:30 <lennart> (since they stole my parser :)
20:22:55 <palomer> ok, but I still don't what the kind "eval A V -> of A T -> of V T -> type" has anything to do with what I want to prove
20:24:26 <lennart> well, anything '... -> type' could be a predicate.  so only the empty vs non-empty type is interesting
20:25:37 <palomer> but what does this predicate represent?
20:25:40 <lennart> using that representation you could be able to prove things that are not decidable
20:26:07 <palomer> like, what's the relationship between the type t and the kind t -> type
20:26:36 <palomer> (or, in this case, t -> u -> v and t -> u -> v -> type)
20:27:18 <lennart> so something of type 'Nat -> Nat -> type' could be a type level version of an equality test
20:27:46 <lennart> so it would say that the two Nat's are related is some way if the type is non-empty
20:28:07 <lennart> for equality it's not so interesting since it's decidable
20:28:14 <palomer> a : Nat -> Nat -> type {- a t u is inhabited iff t = u -}
20:28:28 <lennart> yes
20:29:42 <lennart> so for equality on Nat you could make 'Nat -> Nat -> Bool'
20:30:12 <palomer> but, in this specific case, we would need to prove that  tps t u v   is inhabited iff the t is a proof that eval A V and u is a proof that of A T
20:31:14 <palomer> ie, I don't see how declaring constructors of type   tps t u v   helps us to prove our theorem (type preservation)
20:31:40 <palomer> much like Nat -> Nat -> type isn't a proof that all natural numbers are equal
20:31:44 <lennart> no, i don't see what she means either
20:32:28 <lennart> you should try to do it your way :)
20:32:30 <palomer> but we agree that an element of eval A V -> of A T -> of V T is what we're really looking for, right?
20:32:45 <lennart> you'll either succeed or get an insight to why it's impossible
20:33:47 <lennart> well, if you can get a term of that type you are fine.
20:34:08 <lennart> but it could be that it would only work for certain values in 'of A T'
20:34:22 <palomer> maybe she means to populate tps t u v, and then check that tps is always populated for all t u having the correct types
20:34:54 <palomer> or, rather, tps t u v
20:35:20 <lennart> define a trivial language and do it your way :)
20:35:52 <palomer> ie, tps is a total type constructor
20:36:06 <palomer> so, if tps is a total type constructor, then the theorem is proven, right?
20:36:34 <lennart> what's a total type constructor?
20:36:59 <palomer> no matter what we pick for t u v, then tps t u v is inhabited
20:37:23 <lennart> ok
20:38:32 <palomer> err, ok as in yes?
20:38:52 <lennart> ok, i understand your statement.
20:39:00 <palomer> do you agree with it?
20:39:32 <lennart> if 'tps t u v' is always non-empty then the theorem hold.  yeah, sounds good
20:40:37 <lennart> it could be easier to prove, because you don;t need to provide an algorithm that transforms one proof into another
20:40:57 <palomer> I don't?
20:41:53 <lennart> you have to show that the three arguments are related, not that you can obtain the third from the first two
20:42:58 <palomer> ahh, righto
20:43:29 <lennart> like 'getFactor :: Nat -> Nat' is hard, but 'isFactor :: Nat -> Nat -> Bool' is easy
20:44:24 <palomer> so it won't give me a proof of       of V T
20:44:40 <lennart> no
20:44:45 <lennart> not her version
20:44:49 <palomer> so what will I get?
20:44:57 <lennart> nothing
20:45:17 <lennart> well, you'll get an uninteresting proof object
20:45:34 <palomer> it won't have any meaning at all?
20:45:34 <lennart> (probably uninteresting)
20:45:57 <lennart> depends on what your proof looks like
20:46:18 <palomer> but from the kind, one cannot infer any meaning
20:46:27 <lennart> no
20:46:52 <lennart> the meaning would be in having a proof that 'tps t u v' is non-empty
20:47:07 <palomer> ahh, right
20:47:07 <palomer> o
20:47:14 <lennart> i'm not sure how you'd prove that
20:47:20 <palomer> btw, why aren't any dependently typed system classically typed?
20:48:01 <lennart> because it's easier to make computational sense of constructive logic
20:48:28 <lennart> and most people in that area are interested in computation
20:48:38 <palomer> but the theorem may need classical logic to be proven
20:48:54 <palomer> for example, strong normalization of system F
20:49:44 <palomer> and, really ,what do we lose by adding a function of type (A -> void -> void) -> A ?
20:50:29 <lennart> well, if you don't intend to use the proof for any computational purposes you can add a classical axiom without a computation rule if you feel like it
20:51:11 <palomer> it's not that hard to make computational sense of classical logic, really
20:51:15 <palomer> I mean, look at monads
20:51:37 <lennart> but if you use the types as a specification and the proof as the program, you'd be in trouble
20:52:13 <lennart> (well, unless we do all the double negation song and dance. call-cc or whatever you want to call it)
20:52:16 <aFlag> i'm having a hard time trying to compile only the man pages for ghc, does anyone know if it's an option?
20:52:32 <palomer> lennart: you could do call/cc or you could use lambda-mu
20:52:49 <palomer> or you can put everything in a monad
20:52:55 <palomer> whatever floats your boat
20:53:11 <lennart> yeah, but call/cc works if the underlying implementation is done in some double negation way
20:53:44 <lennart> and in some sense they all are
20:53:50 <palomer> sure, the semantics change a bit, but programming languages with call/cc are usually intuitive
20:54:17 <lennart> call/cc is fine as long as you don't interact with the outside world
20:54:23 <palomer> how so?
20:54:45 <lennart> how would you jump back in time with call/cc if you have side-effected the real world?
20:54:46 <palomer> you could also use krivine's system, where continuations are first class citizens
20:55:25 <palomer> I never understood the temporal arguments you guys keep using
20:57:21 <lennart> ok, so let me give you an example.  what does the proof of 'A or NOT(A)' do with call-cc?
20:57:45 <lennart> well, 'A or NOT(A)' is 'A or (A->Void)'
20:58:18 <lennart> So what the call-cc will do is return a function 'A->Void'
20:58:58 <lennart> so now you can happily compute on.  Should you in the future find a value of type A you can call that function.
20:59:01 <palomer> wait wait, what are you passing to call/cc?
21:00:01 <lennart> What will happen iof you do?  Well, you can't return Void.  So instead the call/cc will return again.  But how it will claim it's the left disjuct that is true.  Since it now has an A to exhibit as a proof.
21:00:39 <lennart> But what happens to the rockets you launched because you thought NOT(A) was true?  They won't be called back.
21:01:59 <palomer> how did you produce a value of type A -> void?
21:02:04 <lennart> what am I passing to call/cc?  can't remember.  Just use Peirce law to prove the law of excluded middle and you'll see.
21:02:36 <palomer> I won't be able to understand your argument until I do
21:03:07 <palomer> why would you launch a rocket knowing that (A -> void ) is inhabited?
21:03:15 <palomer> how could you even ask that question?
21:05:02 <lennart> The Chinese army is either inside the borders or not.
21:05:20 <lennart> if it's not you'll launch an attack on China.
21:05:46 <palomer> got any pseudocode to illustrate?
21:05:49 <lennart> the proof of 'A or NOT(A)' will tell you which branch is true
21:06:37 <lennart> A proof of 'A or NOT(A)' is either Left x, where x::A  or  Right f, where f::(A->Void)
21:07:10 <palomer> ok, so you have an element of Either A (A -> void)
21:07:57 <lennart> yes.  And if you prove it with call/cc it will behave as I described.
21:08:49 <palomer> it will launch missiles?
21:08:56 <palomer> I don't see how missiles come into the picture
21:09:47 <lennart> With call/cc I can make a program, p, with type p :: Either A (Not A)
21:10:38 <lennart> so the missiles was a silly example
21:11:01 <palomer> I'm not objecting to the content of the example
21:11:02 <lennart> let's take something different.  the type A is Goldbach's conjecture
21:11:06 <palomer> I just don't see how it relates
21:11:10 <palomer> ok
21:11:42 <lennart> so I have a program p :: Either Goldbach (Not Goldbach)
21:12:22 <lennart> so I can do 'case p of Left x -> ...; Right f -> ...'
21:13:38 <lennart> now operationally this will always go to the right branch first
21:14:11 <lennart> and if you ever invoke f in the right branch it will jump to the left branch
21:14:31 <lennart> btw, this is the program p, I believe:
21:14:32 <lennart> call/cc (\ k -> Right (\ a -> k (Left a)))
21:15:12 <palomer> well, f will  be the continuation
21:15:30 <lennart> f is the function 'A->Void'
21:15:41 <palomer> p = call/cc (..) ?
21:15:45 <lennart> yes
21:15:53 <palomer> but P is an element of Either a b 
21:15:58 <palomer> s/P/p
21:15:59 <lennart> so this doesn't play well with side effects
21:16:22 <palomer> don't you mean Right (call/cc (..)) ?
21:16:28 <lennart> no
21:16:55 <lennart> call/cc return what it's argument function returns
21:17:34 <palomer> ok, I see it better now
21:17:45 <palomer> now, what's the problem of jumping to the left branch?
21:19:57 <palomer> all programming languages I know who have call/cc as part of their syntax/semantics have side effects
21:21:23 <palomer> hrmph, this has been very instructional
21:21:26 <palomer> but I must be off
21:21:28 <palomer> take care!
21:21:39 <lennart> what if you have 'case p of Left x -> ...; Right f -> putString "A is false"'
21:21:39 <lennart> how will you undo what you printed on the screen (or the rockets you launched)
21:21:39 <lennart> add some ... to my right branch that actually invokes f
21:21:39 <lennart> yes, and they don't really work right
21:21:39 <lennart> you too
21:22:28 <lennart> @type let callCC :: ((a->b)->a)->a; callCC = undefined in callCC (\ k -> Right (\ a -> k (Left a)))
21:22:29 <lambdabot> ((a->b)->a)->a; callCC = undefined in callCC (\ k -> Right (\ a -> k (
21:22:29 <lambdabot> Left a))) :: forall b
21:22:29 <lambdabot>                                    a.
21:22:29 <lambdabot>                                  Either a
21:22:29 <lambdabot>                                    (a
21:22:31 <lambdabot>                                    -> b)
21:22:57 <Pseudonym> There are logic languages with negation-as-failure without side effects.
21:22:59 <lennart> Yup, that's the term
21:23:20 <lennart> and callCC in Haskell works right
21:23:32 <lennart> in the Continuation monad
21:23:45 <lennart> because you can't combine it with the IO monad in a bad way
21:24:06 <palomer> why would you want to undo the printing of the message?
21:24:36 <lennart> because you were wrong
21:24:45 <Pseudonym> If a computation "fails", then you don't want it to have done anything.
21:24:54 <Pseudonym> For example, you don't want to have consumed any characters from a stream.
21:24:58 <Pseudonym> You want to be back where you were.
21:25:46 <lennart> and with some things you can, with some you can't
21:26:05 <palomer> ok, so it changes the way you have to reason
21:26:12 <palomer> and things may not be as they appear
21:26:24 <lennart> right
21:26:34 <palomer> but, other than that, I don't see a problem with call/cc
21:27:13 <palomer> and in languages like twelf, I don't even think there is any IO
21:27:14 <lennart> unless someone used p to launch rockets at you because they thought the answer was final :)
21:27:49 <palomer> that person had no business launching the rocket!
21:27:57 <palomer> I think we should combine case and lambda
21:28:01 <lennart> then how can you use twelf programs?
21:28:10 <palomer> lennart: twelf is used for theorem proving, mainly
21:28:21 <palomer> if your program type checks, you're happy
21:28:38 <palomer> and it is a really poor programming environment
21:28:39 <lennart> yes, what I was objecting to was really that you called it a programming language :)
21:29:00 <palomer> you have a top-level to interact with your programs
21:29:34 <palomer> oh, did I call it a programming language?
21:29:40 <palomer> my bad
21:30:16 <lennart> so then you could add Peirce law, and quickly find that Goldbach's conjecture is false
21:30:16 <lennart> this will make you very sad and you will shoot your room mate
21:31:13 <palomer> sounds good to me
21:31:19 <lennart> lol
21:31:41 <Pseudonym> So what's Pierce's law in lambda calculus?
21:31:47 <Pseudonym> With call/cc.
21:32:00 <Pseudonym> Ah, right.
21:32:03 <Pseudonym> It IS call/cc
21:32:11 <lennart> I don't understand the question
21:32:11 <lennart> yes
21:32:59 <Pseudonym> Gotta go.
21:33:00 <Pseudonym> Nytol!
21:38:25 <dons> \uptime
21:38:26 <lambdabot> uptime: 2 days, 3 hours, 3 minutes and 35 seconds
21:50:49 <rlaager-test> @type replicate
21:50:50 <lambdabot> forall a. Int -> a -> [a]
23:43:14 <gFunk> @pl f l = zipWith (>) (tail l) l
23:43:15 <lambdabot> f = zipWith (>) =<< tail
23:51:48 <gFunk> @hoogle join
23:51:49 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
23:51:49 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
23:51:49 <lambdabot> Distribution.Compat.FilePath.joinFileName :: String -> String -> FilePath
