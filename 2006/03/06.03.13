00:03:22 <palomer>  dynamic typing scares me
00:05:02 <mahogny> even scarier if put in haskell among tons of maps and lambdas. the type checker is what saves one from doing really bad things in haskell :)
00:11:13 <dons> it's just like static typing, where everything has the same type -- how bad can that be ;)
00:12:26 <mahogny> lol
00:14:01 <mahogny> I wouldn't mind if haskell could do automatic conversion float<->int though
00:14:07 <dons> I like Bob Harper's comments on dynamic typing, and how it is just a matter of turning runtime type errors into checked errors, moving errors as late as possible, rather than having them as early as possible
00:14:32 <dons> mahogny, fromIntegral ;)
00:14:38 <mahogny> automatic! :)
00:14:52 <dons> automatic promotion is the work of the devil, go look at the C standard :}
00:15:30 <dons> it's interesting that you can add dynamic typing to a statically typed language, but you can't add static typing to a dynamiically typed one
00:15:39 <mahogny> yeah. reminds me about Erlang. I had no manual and didn't knew I had to put certain things with a capital in the beginning. so I was sitting there for hours with a non-capital variable and the "error" erlang gave me looked like a crash dump :P
00:15:56 <palomer> dons: sure you can, with macros!
00:15:57 <dons> so dynamic typing is just a special case of static typing, hence static typing wins  :)
00:16:14 <dons> without metaprogramming, palomer, that's even harder on the brain
00:16:44 <dons> and in a dynamically typed language you pay the cost of all those checks, even if your code is statically type safe
00:16:55 <dons> so at least in haskell, you only pay for dynamica checks in the code that needs those checks
00:17:01 <dons> hence, static typing wins 
00:17:07 <dons> .... I see a pattern :)
00:17:33 <mahogny> well, you don't really need automatic promotion to get int<->float working. polymorphic functions would be a better way. just make (+) and friends able to take different types. that's quite an addition though
00:20:18 <dons> yeah, some type class magic could probably get you there
00:23:03 <dons> the chapter on dynamic typing (as a form of static typing) is interesting in `Programming Languages: Theory and Practice', http://www.cs.cmu.edu/~rwh/plbook/
00:23:42 <mahogny> well. it's quite obvious how to put it in
00:23:48 <dons> palomer, that book (online is free) might be worth a peep at with all the type hackery you're doing
00:24:21 <mahogny> ehr. "offline.pdf"???
00:24:25 <mahogny> I sense a contradiction
00:24:31 <dons> different pagination
00:24:38 <dons> whether you're printing or viewing online
00:24:45 <mahogny> aha
00:25:06 <wolverian> people use PDFs for online .. uh.. pages now?
00:25:32 <dons> ah, I see the chapter on dynamic typing has been relegated to the end this year
00:25:40 <dons> it was closer to the front previously
00:25:43 <mahogny> pdf is nicer than html if you want proper formatting and have tons of formulas etc
00:25:51 <dons> (it gets updated each spring when this course is taught)
00:26:12 <dons> yeah, it's for the tons of formulas
00:27:36 <dons> I like the argument that static typing is more expressive than dynamic typing, since you can code up dynamic typing in a statically typed system :) fun fun
00:28:18 <palomer> harper's book?
00:28:28 <palomer> right now I'm into dynamic typing
00:28:32 <dons> this is a rather good read, by the way, especially if taPL is too expensive for anyone
00:28:49 <palomer> with type tagging
00:29:09 <dons> palomer, yeah, I reckon it's worth reading -- just as TaPL is worth reading.
00:29:17 <mahogny> hm. is anyone using this pi-calculus for anything sensible?
00:29:24 <palomer> I've read parts of harper's book
00:29:27 <palomer> quite good
00:29:35 <dons> didn't I see that someone's started up a company using pi-calculus ?
00:29:37 <palomer> mahogny: most people use variants, methinks
00:29:41 <dons> on ltu, yesterday, i think
00:29:45 <palomer> night!
00:29:51 <mahogny> palomer, yeah. that's what I thought
00:36:16 <Lokadin_> so is there any like laptop assembly kits?
00:36:45 <Lokadin_> or are laptops basically not like desktops in that sense
00:37:08 <mahogny> laptops are more or less by definition impossible to assemble
00:37:23 <Lokadin_> kk 
00:37:27 <Lokadin_> just wondering
00:37:32 <wolverian> some stores do sell laptops that come with the display and the case, and you install the rest.
00:37:58 <wolverian> maybe they also come with mobos, I'm not sure. I only have experience with one manufacturer.
00:38:06 <wolverian> (and haven't bought any personally)
00:38:21 <mahogny> I think there are too few standards for it to make sense. laptops are highly compact and this is the price
00:38:36 <Lokadin_> yea
00:38:41 <Lokadin_> kk thanks :)
00:39:25 <wolverian> yeah. those laptops I looked at ended up costing more than the equivalent thinkpad.
00:40:10 <Lokadin_> wow
00:40:18 <Lokadin_> damn oh well
00:40:26 <Lokadin_> maybe in the future, but probably not
00:40:56 <Lokadin_> it just seems so much cheaper for companies to just get smaller and smaller with devices
00:41:14 <Lokadin_> standard sized ports or anything would be a bottleneck
00:41:25 <Lokadin_> or stuff like cellphones
00:48:19 <goltrpoat> what's the algorithm behind Data.HashTable?  the ghc docs cite a paper, but i don't have an ACM subscription
00:49:06 <goltrpoat> actually.. nevermind, Data.HashTable wouldn't work at all here
00:51:20 <goltrpoat> (i need something more like a static/nongrowing memoization type deal, but on a hash, and maybe two or three tier context-sensitive collision resolution, anything more than 2-3 values per key would be bad)
00:57:44 <goltrpoat> thinking about how i'd write a chess program in haskell (wrote a couple in c++ some time ago)..  one thing that seems to be nice is that i can start out with an arbitrary board representation, and then optimize it to my heart's content by swapping out the monad later on.  trying out different alpha-beta flavors is also pretty trivial.  transposition tables are going to be weird though.
02:04:17 <kosmikus> any Clean experts around?
02:05:20 <Lemmih> (:
02:08:00 <kosmikus> Lemmih: you?
02:08:32 <Lemmih> I think I'll ask that question whenever someone wonders why Haskell is case-sensitive.
02:08:59 <kosmikus> :)
02:09:54 <mathrick> heh
02:11:34 <vincenz> clean isn't?
02:13:33 <shapr> eivuokko: Hey, did you seen Daan's darcs-server thingy?
02:15:34 <shapr> Sure is quiet...
02:16:05 <kosmikus> shapr: change it
02:16:26 <eivuokko> Yeah, seen message, not tried yet (and doubt I will - perl)..but I'm off now.
02:16:39 <vincenz> shapr >>= shapr >>= shapr >>= shapr >> return ()  :: IRCMonad ()
02:16:45 <shapr> whee!
02:17:06 <shapr> eivuokko: You could replace that part with a nice Haskell something :-)
02:17:12 <shapr> Good morning #haskell!
02:17:27 <JKnecht> morning shae!
02:17:54 <shapr> hiya JKnecht 
02:20:46 <JKnecht> I found that Mathematica trial version doesn't even run on FC4 x86_64 although it clearly is supposed to.
02:24:59 <cajole> finger rxf04u
02:25:40 <musasabi> Has anyone got a md5/sha1/... checksum module in Haskell that works even on 10mb input files?
02:26:50 <mathrick> "even"?
02:26:54 <mathrick> 10mb is nothing
02:27:06 <mathrick> not that I have such module
02:27:15 <shapr> Didn't Igloo write a Fast Packed String sha1 for darcs?
02:27:42 <musasabi> I was using the http://chaos.earth.li/~ian/haskell/md5/haskell-md5-0.2.7/ / http://www.cse.unsw.edu.au/~dons/code/icfp05/MD5.hs, but that seems to have a memory leak in it. (needs some hundreds of mb for such a file)
02:28:22 <shapr> That's what stopped my combinatorrent project.
02:28:47 <vincenz> :/
02:29:07 <shapr> musasabi: I'd suggest the lazy eval solution, aka whine on the haskell-cafe mailing list =)
02:29:08 <mathrick> it's probably saving thumps instead of evaluating stuff somewhere
02:29:48 <musasabi> shapr: I'll try the darcs code and if that does not work go for the lazy solution :-)
02:30:09 <vincenz> that would sound funny on #meta-science, shapr, we're currently dissalowing the 'h' key
02:30:25 <shapr> :-P
02:30:38 <shapr> You're not getting me on #meta-science, I have enough trouble with distractions as it is.
02:30:48 <vincenz> Iwasn't attempting that
02:30:54 <vincenz> just... I saw whine and read wine
02:31:09 <vincenz> and I know what you mean about distractions :/
02:31:15 <shapr> I have access to the chat network, irc, yahoo, icq, gale, silc...
02:31:21 <vincenz> skype
02:31:22 <shapr> networks*
02:31:25 <shapr> oh, that too
02:31:29 <shapr> What's your skype name?
02:31:34 <vincenz> my name
02:31:37 <vincenz> with a . in the middle
02:31:44 <vincenz> oh wait
02:31:58 <vincenz> Damn, my current account doesn't have my fullname
02:32:43 <vincenz> This is odd..for some reason I don't see text that I /msg to someone else
02:32:54 <vincenz> Crap... nothing is shown in the /msg windows, it's all blackk
02:32:57 <vincenz> shapr: I can't read that :/
02:33:08 <vincenz> it flashed the window but nothing is visible
02:33:12 <vincenz> maybe my irrsi is messed
02:33:17 <vincenz> let me relogin
02:43:23 <shapr> dcoutts: Hey, I like this idea...
02:43:43 <dcoutts> shapr, good! We'll see what JaffaCake thinks.
02:43:54 <shapr> ghc-pkg would check for consistency and the like, but registration is just throwing a .conf file into the dir, yeah?
02:44:00 <dcoutts> yep
02:44:06 <shapr> That kicks butt.
02:44:31 <dcoutts> at least for package managers, for users doing it manually they can get ghc-pkg to throw the file in the right dir
02:44:38 <dcoutts> so the ghc-pkg interface doesn't change
02:44:55 <shapr> seriously spiffy
02:45:02 <dcoutts> but if you know what you're doing then it can be done more conveniently
02:45:05 <vincenz> shapr: I see the problem with privmsgs no... I had this screen open on my computer at home too where the window is bigger hence the text in the privmsg window was above my window here at work
02:45:14 <dcoutts> usign registration progs sucks for package management systems
02:45:26 <dcoutts> managign bunches of files is what they do best
02:45:58 <sowhat> does anyone know why you cannot load the Distribution.Compat.FilePath module? (its part of the cabal package, which i have loaded in ghci)
02:48:33 <shapr> What error do you get?
02:48:48 <dcoutts> those modules may well not be exposed
02:48:57 <dcoutts> check with ghc-pkg describe Cabal
02:49:30 <dcoutts> ghc-pkg field Cabal exposed-modules
02:49:49 <dcoutts> if Distribution.Compat.FilePath is not listed then you can't import it since it's an internal module
02:50:12 <dcoutts> if it is listed then it should be possible to import it
02:50:48 <shapr> dons: You think Oleg's HSXML would be good for blogging?
02:50:55 <shapr> PLog is getting a bit long in the tooth...
02:51:15 <sowhat> it says it is a hidden module (acc. to the cabal doc: only for internal use). but the functions are very useful for platform independent development.
02:51:51 <shapr> Platform independent path modules have been proposed often, but nothing has ever gained general acceptance, sadly.
02:52:49 <sowhat> shapr, thats a real pitty. 
02:52:54 <kosmikus> shapr: I think all it needs is someone to write a good one, document it, and publish it. I don't really care if it's an optimal design, but whenever I look for one, there just isn't one, so I roll my own.
02:53:13 <dcoutts> there's a FilePath cabal package around somewhere
02:53:44 <dcoutts> it's on the hackage page as I recall
02:53:56 <shapr> Well, I'll champion a FilePath module if people will contribute code.
02:54:00 <musasabi> shapr: it (HSXML) suffers from the HList huge types problems.
02:54:11 <shapr> Oh, that's too bad.
02:54:24 <shapr> musasabi: Can you get away with never declaring types? Or must they be explicit?
02:55:11 <kosmikus> yes, FilePath from cabal would be a good start. I think the only thing I hate about it is that the joining of path names is so verbose. I mean, it's a / to do it as a string, but it's called something like joinFilePathNames in that module ...
02:55:31 <vincenz> lunch time
02:55:53 <musasabi> shapr: it works until you make the first typo.
02:56:01 <shapr> kosmikus: change it :-)
02:56:25 <musasabi> shapr: if the code is correct then it works prettily. If not GHC will print a type error which can be a few screenfulls
02:56:30 <shapr> yikes
02:56:47 <shapr> I may still try it, I'm getting tired of doing it all by hand with PLog.
02:56:55 <shapr> Unless you have other suggestions?
02:57:54 <pesco> Morning shapr. :)
02:57:55 <shapr> I'm especially fond of the built-in RSS support :-)
02:57:56 <musasabi> not really.
02:57:58 <shapr> hiya pesco 
02:58:14 <shapr> Lots of people complain to me about my blog's lack of RSS support.
02:58:27 <musasabi> SHA1 from darcs is 10 times slower than system sha1sum, but still fast enough.
02:58:30 <sowhat> kosmikus, nothing wrong with verbose function names, if we would have a decent editor, with auto name completion
02:58:51 <shapr> I use hippie-expand.
02:59:03 * shapr considers adding a haskell-module-expand for hippie-expand
02:59:41 <shapr> Hm, probably easier to use Yi
02:59:44 * pesco waves a little flag labled "ilkacro"
03:03:28 <shapr> Anyway, a usable FilePath module is really needed...
03:05:34 <sowhat> shapr, i agree
03:06:18 <mathrick> shapr: tried pabbrev?
03:06:28 <mathrick> not directly related to modules
03:06:31 <mathrick> but still cool
03:08:39 <sowhat> there is a discussion on filepath and its correct implementation on http://thread.gmane.org/gmane.comp.lang.haskell.prime/338
03:09:22 <shapr> And a trac ticket - http://hackage.haskell.org/trac/haskell-prime/ticket/89
03:09:48 <shapr> Sounds like a discussion we should jump into...
03:11:18 <sowhat> its for Haskell', isnt that the new haskell language set (or smth?)
03:12:06 <shapr> Yeah, it'll replace the Haskell 98 standard.
03:12:27 <shapr> That's exactly where you want to talk about a better FilePath module.
03:14:39 <sowhat> cool, hope they can agree on it
03:16:14 <shapr> You could jump in and ask for specific functionality.
03:17:12 <shapr> You took Implementation of Programming Languages in 03-04, right? ;-)
03:19:10 <shapr> sowhat: btw, Have you seen Trevor Blackwell's PhD thesis? It's vaguely related to your STC paper.
03:20:00 * shapr is distracted by the cannons firing outside his window.
03:21:39 <shapr> sowhat: Heh, you referenced Bagley's shootout. That's amusing.
03:22:11 <shapr> hiya AI_coder 
03:22:37 <shapr> dbremner mentioned Trevor Blackwell's PhD thesis to me, it's quite nifty.
03:22:53 <ValarQ> g'day formarn
03:23:12 <shapr> hey ValarQ 
03:23:19 <shapr> How's code?
03:23:30 <ValarQ> slow progress...
03:23:36 <shapr> Whatcha writin?
03:23:49 <ValarQ> i'm experimenting with gtk2hs
03:23:54 <shapr> Oh, how's it going?
03:23:54 <dcoutts> :-)
03:24:02 <shapr> Do the TMR articles help any?
03:24:25 <dcoutts> I wrote a intro presentation the other day, that's on the gtk2hs web site now
03:24:28 <ValarQ> it progresses slowly...
03:24:35 <ValarQ> didn't i say so? :)
03:24:39 * shapr grins
03:25:04 <aleator> Has ndm added the gtk2hs to hoogle yet?
03:25:13 <ValarQ> shapr: have you transformed into a mindless stockholm zombie yet?
03:25:35 <shapr> No one has offered me any Java or PHP jobs yet.
03:25:38 <shapr> Maybe soon.
03:25:46 <pesco> shapr: Wow, cool, you're transforming into a mindless zombie?!
03:26:06 <shapr> I need some way to get money until my internet startup has its IPO.
03:26:15 <sieni> there isn't much of a choice if one is living in stockholm ;-)
03:26:25 <pesco> I see.
03:27:20 * ValarQ had to go to stockholm once
03:27:46 <ValarQ> when i worked as a royal guard
03:29:00 <shapr> oh neat
03:29:19 <tromp_> can't you work as a unicycle instructor:-?
03:29:36 <ValarQ> :)
03:29:38 * shapr grins
03:32:55 <sowhat> shapr, no havent seen it, what the link?
05:44:23 --- topic: '["Submit a paper to the Haskell Workshop:", "http://haskell.org/haskell-workshop/2006", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion"]'
05:44:23 --- topic: set by sylvan on [Fri Mar 03 08:35:02 2006]
05:44:23 --- names: list (clog kombinator chucky iblechbot CLxyz mauke_ orbitz ntgrl magagr tromp_ arguile Maddas Lunar^ flux__ emu lispy zamez sieni_ ibid pejo dcoutts_ musasabi earthy Twigathy dcoutts liyang integral moonlite wli borism yaargy qwr noj ValarQ norpan grey- Lemmih shrimpx cods _frederi1_ Poeir Sonarman Igloo mornfall bolrod dany2k takuan khaladan djw cpatrick cmeme tic Evelf Nioate drbean Lokadin_ _Codex rustyryan genneth araujo binary42 univac)
05:44:23 --- names: list (thedward mahogny Si\Uni wilx Wallbraker rasfar kosmikus jmichaelson Hmm_| neologism cathper gzl spamsch xerox Excedrin Spark juhp aleator nibro ulfdoz ed-210 lisppaste2 slipstream-- cparrott triplah swiert nnunley int-e shapr Muad_Dib sowhat edwinb Itkovian tumm mornfall|oss audreyt resiak eyck Philippa perspectival eivuokko nothingmuch Saulzar jgrimes Cale CrewdenX g11|123 scw jiing_ waltz sili Plareplane tessier_ WillKW carp cajole gdsx)
05:44:23 --- names: list (kzm wolverian dfhaii tuomov rep johs ksandstr lucca isydor dons cognominal_ kpk kolmodin __AL__ ex_nor svens pesco Beelsebob noclouds lambdabot ramkrsna SamB Revision17 sellout ricebowl Trixsey jethr0 slyrus SimonRC boegel arjanb Khisanth jlouis palomer Bobstopper cbus ski |giksos| twobitsprite essiene mathrick Paltas vincenz chris2 petekaz jp-autark ikegami-- Akshaal llappala kpreid_ beelsebob_ mgoetze Nomius_ akemp sieni)
05:44:41 <shapr> vincenz: How would you clean it up?
05:44:49 <mathrick> > let myjoin xss = xss >>= id in myjoin [[1,2,3],[4,5,6]]
05:44:50 <lambdabot> [1,2,3,4,5,6]
05:44:55 <mathrick> O_o
05:45:52 <mathrick> @type let myjoin xss = xss >>= id in myjoin
05:45:53 <lambdabot> forall (m :: * -> *) b.
05:45:53 <lambdabot>               (Monad m) =>
05:45:53 <lambdabot>               m (m b) -> m b
05:47:06 <mathrick> @type >>= :: List
05:47:06 <lambdabot> parse error on input `>>='
05:47:13 <mathrick> @type (>>=) :: List
05:47:14 <lambdabot> Not in scope: type constructor or class `List'
05:47:14 * dcoutts notes that gentoo now supports ghc on 7 arches, alpha, amd64, hppa, ppc, ppc64, sparc and x86
05:47:17 <mathrick> @type (>>=) :: [Int]
05:47:19 <lambdabot>   Couldn't match `[Int]' against `t -> t1'
05:47:19 <lambdabot>   Expected type: [Int]
05:47:41 <mathrick> who know what I want to say?
05:47:47 <vincenz> dcoutts: who did the work of porting ghc
05:47:57 <mathrick> *knows
05:48:02 <vincenz> dcoutts: I know for instance that the ocaml people were working hard to support amd64... or is ghc just written more platform independently?
05:48:09 <dcoutts> vincenz, gentoo helpers and packages we nicked from debian
05:48:22 <vincenz> dcoutts: I meant getting it compiled without bugs
05:48:41 <dcoutts> for a couple arches we started with debian binaries and use that to bootstrap a gentoo portage ebuild
05:48:56 <vincenz> I'm not talking about packaging it
05:49:02 <vincenz> I'm talking about making ghc work on a 64 bit platform
05:49:03 <dcoutts> vincenz, it works pretty well for most arches
05:49:17 <dcoutts> we had trouble with ppc64 and mips is still blocked
05:49:18 <mathrick> dcoutts: heh, and how does debian do it? magic?
05:49:20 <vincenz> for instance the gc
05:49:35 <mathrick> or do they take gentoo's packages? ;)
05:49:38 <dcoutts> mathrick, dedication I think.
05:49:41 <vincenz> mathrick: lazy eval
05:49:54 <vincenz> dcoutts: I'd think porting ot other platforms would be done by the gch people...
05:49:54 * dcoutts is grateful for the hard porting work of the debian haskell maintainers
05:50:06 <vincenz> I mean a different cpu arch
05:50:09 <dcoutts> vincenz, they generally don't have access to the hardware
05:50:16 <vincenz> ah
05:50:45 <tuomov> hmm.. I wonder if ghc3.2 would work on 32bit platforms, since ghc6.4 doesn't.. :)
05:50:57 <mathrick> haha
05:50:59 <dcoutts> vincenz, ghc has worked on 64bit arches for some time
05:51:16 <dcoutts> though people found more bugs when they ported to amd64
05:51:32 <tuomov> the whole package management system is an absolute mess
05:51:34 <vincenz> ah
05:51:44 <dcoutts> tuomov, how so?
05:51:50 <mathrick> @type (>>=)
05:51:51 <lambdabot> forall (m :: * -> *) b a.
05:51:51 <lambdabot>    (Monad m) =>
05:51:51 <lambdabot>    m a -> (a -> m b) -> m b
05:52:05 * dcoutts is pretty pleased with the current state of Haskell support in gentoo
05:52:08 <tuomov> dcoutts: loses packages all the time
05:52:50 <tuomov> (and one has to constantly recompile them for other reasons as well, and still it won't find them)
05:53:13 <vincenz> yah recompile on gentoo is a b*tch
05:53:21 <vincenz> just install X from scratch
05:53:24 <vincenz> and gnome
05:54:01 <tuomov> I was talking of GHC's own package/library management system, and on Debian
05:54:19 <tuomov> I can't even bother with hs-plugins for riot for that reason anymore
05:54:25 <tuomov> way too much work
05:54:37 <dcoutts> tuomov, well I sent in a patch today on that issue, to make package registration more robust
05:54:45 <Igloo> tuomov: How do you lose packages on Debian?
05:54:46 * vincenz mutters
05:55:05 <vincenz> don't you hate thosea rticles that highlight certain words ...but instead of those words linking to relevant info, they just link to adds with those words in them
05:55:05 <tuomov> Igloo: it just won't find them, even if they're listed by ghc-pkg
05:55:49 <tuomov> vincenz: well, I prefer that kind of adds (with a distinguishable broken underline) to banner and popup adds
05:55:50 * dcoutts agrees with vincenz 
05:56:06 <Igloo> tuomov: If you can tell me how to reproduce it then e-mail me
05:56:15 <Igloo> (or file a bug)
05:56:23 <dons> oh this guy on glasgow-haskell-users complaining about ghc needing ghc to compile is so much fun :)
05:56:30 <vincenz> tuomov: well I rather have it link for instance to the source of the news
05:56:35 <vincenz> tuomov: or the relevant paper
05:56:38 <mauke> I found a few typos in the gentle introduction
05:56:41 <vincenz> instead of putting "Citation ...blabla" in text
05:56:42 <mauke> what should I do with them?
05:57:23 <dcoutts> dons, where?
05:57:59 <sieni> dons: wtf? :-)
05:58:56 * mathrick still thinks that gentle introduction is one of the biggest misnomers ever
05:59:30 <dons> dcoutts, oh its just too funny -- "are you fully nerd??" is a great quote. http://article.gmane.org/gmane.comp.lang.haskell.glasgow.bugs/3779
05:59:31 <musasabi> gentle introduction to a headache with Haskell?
05:59:43 <tuomov> it was gentle to me..
05:59:47 <mathrick> ...
06:00:08 <dcoutts> dons, heh
06:00:13 <tuomov> and I had never done FP before
06:00:22 <dcoutts> doesn't gcc need a C compiler too?
06:00:27 <mathrick> it does
06:00:30 <dons> yeah.
06:00:33 <dcoutts> so ghc is different how?
06:00:35 <mathrick> it needs gcc even
06:00:40 <dons> it's not :)
06:00:41 <mathrick> it isn't
06:00:44 <vincenz> it is
06:00:49 <dons> but still, we're fully nerd :) i love it.
06:00:59 <mathrick> vincenz: yeah, we know, we can lazily evaluate it
06:01:03 <dcoutts> mathrick, does it? I thought basic bits worked with any C compiler
06:01:06 <shapr> @quote DennisHuer
06:01:06 <lambdabot>  Are you fully nerd???? How can ghc expect an installed ghc for the first
06:01:06 <lambdabot> build stage????? What is that????
06:01:17 <vincenz> a) ghc doesn't crosscmpile afaik, b) there are far more backends for gcc, c) gcc actually uses a minimalistic bootstrap c compiler that is much simpler
06:01:24 <mathrick> dcoutts: not sure actually, but I think it needs gcc
06:02:08 <dons> vincenz, we boot via gcc, not ghc. we use ghc for the 2nd stage, in effect, first creating a minimal ghc via gcc.
06:02:12 <tuomov> I wonder it they used non-free software to bootstrap the first gcc!
06:02:20 <mathrick> yes
06:02:27 <mathrick> probably
06:02:30 <vincenz> dons: ah ok :)
06:02:57 <dcoutts> dons, so are you going to reply with how we do it in source based distros like OpenBSD & Gentoo? :-)
06:02:59 <mathrick> > x where x = 10
06:03:00 <lambdabot> 10
06:03:13 <vincenz> dons: be cooler if you only wrote a minimal haskell compiler in c and then wrote ghc purely in haskell :)
06:03:24 <dons> oh, i think he doesn't really care, dcoutts :) 
06:03:33 <dons> obviously he had a stack overflow from the recursion in his head
06:03:42 <vincenz> ll
06:03:54 <vincenz> > intersperse 'o' "ll"
06:03:55 <lambdabot> "lol"
06:04:33 <dons> shapr, yeah, I think oleg's might be worth looking at
06:05:11 <vincenz> who is this oleg that people keep talking about
06:06:27 <dons> oleg the magnificent, twister of types, killer of kinds!
06:06:31 <vincenz> ?
06:06:50 <sieni> kiselyov
06:06:53 <dcoutts> dons, heh
06:06:59 <vincenz> never seen anythng by him..
06:07:12 <musasabi> vincenz: except GHC needs GHC not a minimal Haskell compiler.
06:07:17 <dons> @google Oleg Kiselyov
06:07:17 <sieni> vincenz: http://okmij.org/ftp/
06:07:18 <lambdabot> http://okmij.org/ftp/
06:07:33 <musasabi> vincenz: Oleg has lots of very neat stuff.
06:07:37 <mauke> http://www.google.de/search?q=haskell%20oleg
06:07:42 <jgrimes> interesting
06:07:43 <dons> well, it needs a minimal haskell compiler in the sense that we don't build all the libs or all the backends on the first run
06:08:06 <dons> just a C backend, unregisterised and no other tricks, plus the base libs, is what's built in the first stage
06:08:18 <dcoutts> but it does need to be ghc, not say, hugs or yhc
06:08:27 <dons> yep. used to be nhc was ok too
06:08:36 <dcoutts> I wonder what extensions ghc relies on
06:08:42 <dons> and hbc was also ok
06:08:52 <dons> not many, but a lot of cpp. and unboxed values.
06:08:54 <dcoutts> perhaps it would be possible to build stage1 with yhc or hugs
06:09:02 <dons> that's the main (or only?) extension
06:09:10 <dcoutts> unboxed stuff
06:09:20 <dcoutts> that's pretty much ghc-only
06:09:38 <musasabi> dons: base has lots of problematic stuff, but don't know how much of it GHC actually uses.
06:10:08 <musasabi> portable base != ghc base, which makes things hard.
06:10:08 <dons> base is portable though
06:10:14 <mathrick> > myjoin [[1,2,3],[4,5,6]] where myjoin = x `bind` id; bind [] f = []; bind (x:xs) f = f x ++ $ bind xs f
06:10:14 <lambdabot>  parse error on input `$'
06:10:17 <dons> ah I see what you mean
06:10:23 <Lemmih> dons: But GHC.* isn't.
06:10:26 <dons> yup
06:10:37 <mathrick> > myjoin [[1,2,3],[4,5,6]] where myjoin = x `bind` id; bind [] f = []; bind (x:xs) f = f x ++ (bind xs f)
06:10:38 <lambdabot>  Not in scope: `x'
06:10:46 <musasabi> or Control.Concurrent.* or Control.Exception or ...
06:10:49 <dons> and ghc itself does import stuff from GHC.* I think
06:10:56 <dcoutts> so it might be ok
06:11:08 <dons> so even if you suppported unboxed values, which are used directly in ghc, you'd then also need to be able to compile GHC.*
06:11:14 <mathrick> > myjoin [[1,2,3],[4,5,6]] where { myjoin = x `bind` id; bind [] f = []; bind (x:xs) f = f x ++ (bind xs f) }
06:11:16 <lambdabot>  Not in scope: `x'
06:11:20 <mathrick> whut?
06:11:23 <dons> which in turn uses a few other extensions (local quantification at least)
06:11:44 <Lemmih> mathrick: myjoin x = ...?
06:11:52 <mathrick> Lemmih: ah, thanks
06:11:58 <musasabi> dons: well it defines STM, Concurrent haskell, ST etc
06:12:12 <musasabi> also the set of primops should probably match
06:12:17 <Lemmih> mathrick: You can also use lambdabot in private, btw.
06:12:23 <dons> ah, yeah. you wouldn't want all those
06:12:29 <mathrick> Lemmih: didn't work last time I tried
06:12:36 <dons> hmm. amazing the primops did match ever...
06:12:46 <dons> there must have been a ghc in the past that didn't use GHC.*
06:12:49 <Lemmih> mathrick: freenode requires you to be registered.
06:12:53 <dons> for nhc to be able to produce a bootstrapping ghc
06:12:55 <mathrick> I were registered
06:13:01 <mathrick> well, I'm not now and it works :)
06:13:13 <musasabi> and having a different representation of IO makes GHC.* hard
06:13:18 <dcoutts> dons, they probalby added a dep on GHC.* to be fully nerd.
06:13:32 <dons> true!
06:14:17 <dcoutts> ask your friends "are you fully nerd???"
06:14:18 <mathrick> can I define (++) in terms of (:) ?
06:14:26 <dcoutts> mathrick, yep
06:14:29 <dons> Lemmih, want to clean out any deps on GHC.* while you're in there spring cleaning ghc? ;)
06:14:44 <dons> Haskell, the language of choice for the fully nerd
06:14:54 * dcoutts grins
06:14:54 <mathrick> dcoutts: ahh, I see it now
06:15:21 <goron> I like the discriminating hackers tag more ;)
06:15:28 <dons> the silly silly people who define recursive bootstrapping procedures, crazy clowns
06:15:33 <musasabi> This is an actual problem with jhc because nearly all Cabal packages depend on base and there is no way to know whether they mean "portable base" or "ghc base".
06:15:47 <dcoutts> musasabi, mm, true
06:15:49 <dons> hmm. 
06:16:00 <dons> yes,, it's a social convention not to rely on GHC.*
06:16:10 <dons> but maybe we want a clear line drawn
06:17:14 <mathrick> > let pp [] [] = []; pp [] (x:xs) = x : pp [] xs; pp (x:xs) z = x : pp xs z in [1,2,3] `pp` [4,5,6]
06:17:16 <lambdabot> [1,2,3,4,5,6]
06:17:20 <mathrick> good
06:17:25 <dcoutts> Lemmih, dons, so are we going to use mmaped fps for reading .hi files in ghc?
06:17:49 <dons> not sure about the mmap, but simon wants to use packed strings, yup
06:17:59 <dons> ah, but not for .hi files 
06:18:00 <musasabi> there are other parts in base too that require various extensions like concurrency, fundeps, ST etc
06:18:03 <dons> for the internal FastStrings
06:18:11 <dons> and maybe mmap for .hi files, that's another issue
06:18:14 <dcoutts> using mmap for .hi files would reduce memory use
06:18:22 <dons> that would require mmap cases for the binary class
06:18:26 <dons> which would be 5 lines of code...
06:18:59 * dons has to keep resisting replying to the fully nerd guy with jokes about recursion
06:19:11 <dcoutts> it'd especially help builds that don't use ghc --make
06:19:22 <musasabi> if the hi-files are small isn't that going to be slower and take more memory?
06:19:28 <dcoutts> dons, why resist?
06:19:42 <dons> dcoutts pushes me over the edge
06:20:00 <musasabi> 4k granularity on most architectures + VM overhead + threading issues with NFS
06:20:02 <dcoutts> musasabi, ah but they're not small and they're shared by many invocations of ghc that use them (at least in a large bild)
06:20:22 <musasabi> dcoutts: ok, if they are not small then it makes sense.
06:20:47 <dcoutts> musasabi, the .hi files keep getting re-read by each ghc invocation in a build
06:21:15 <dcoutts> so we can keep one copy hot in the page cache rather than making a copy in each ghc instance
06:21:25 <musasabi> yes, makes sense.
06:21:40 <dcoutts> I'd also like to implement something to pack all the .hi files in a package into one file
06:21:51 <dcoutts> then mmap would certainly be an advantage
06:22:07 <dons> that would make a big difference in ghci startup times
06:22:11 <dcoutts> right
06:22:19 <dons> it's notably faster to load a package than to load a tree of .hi files
06:22:32 <dcoutts> and save ram and make management a bit easier
06:22:47 <dcoutts> it'd mean that an installed package would be 2 files rather than hundreds
06:22:52 <dcoutts> er, 3
06:23:05 <dcoutts> 4 if we have seperate package.conf files
06:23:32 <dcoutts> and if someone teaches ghci to read libHS*.a files then we save that too
06:23:40 <dcoutts> .a files are pretty simple really
06:23:41 <musasabi> jhc only reads 2 files when starting jhci + jhci config file for user if it exists
06:24:40 <musasabi> it just embeds the metainfo in the haskell library rather than using external package config files.
06:32:07 <Jarod> hello
06:32:51 <Jarod> i am learning haskell and i just want your opinion about a my_foldr function
06:33:02 <Jarod> i wrote:
06:33:29 <Jarod> my_foldr f init [] = f init
06:33:58 <Jarod> my_foldr f init [x:xs] = f (x my_foldr f init xs)
06:34:10 <Jarod> is it correct ?
06:34:17 <mathrick> no
06:34:24 <mathrick> my_foldr is not an operator
06:34:47 <mathrick> you need : there
06:35:07 <Jarod> ah , i have forgot that
06:35:24 <mathrick> @type foldr
06:35:25 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
06:35:54 <Lemmih> ans (x:xs) instead of [x:xs]
06:36:04 <Lemmih> @typo and
06:36:05 <lambdabot> [Bool] -> Bool
06:37:44 <mathrick> my_foldr (+) [1 .. 10] where { my_foldr f init [] = f init; my_foldr f init (x:xs) = f x $ my_foldr f init xs
06:37:47 <mathrick>  my_foldr (+) [1 .. 10] where { my_foldr f init [] = f init; my_foldr f init (x:xs) = f x $ my_foldr f init xs
06:37:48 <mathrick> ghr
06:37:50 <mathrick> > my_foldr (+) [1 .. 10] where { my_foldr f init [] = f init; my_foldr f init (x:xs) = f x $ my_foldr f init xs
06:37:51 <lambdabot>  parse error on input `in'
06:37:56 <mathrick> > my_foldr (+) [1 .. 10] where { my_foldr f init [] = f init; my_foldr f init (x:xs) = f x $ my_foldr f init xs }
06:37:58 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
06:37:58 <lambdabot>   Expected type: a
06:37:58 <lambdabot>   Inferred type: a -> b
06:38:25 <mathrick> > my_foldr (+) 0 [1 .. 10] where { my_foldr f init [] = f init; my_foldr f init (x:xs) = f x $ my_foldr f init xs }
06:38:26 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
06:38:26 <lambdabot>   Expected type: a
06:38:26 <lambdabot>   Inferred type: a -> b
06:39:14 <Jarod> what is the role of the symbol $ ?
06:39:46 <mathrick> Jarod: f $ x y is a better way to write f (x y)
06:39:55 <Jarod> ok thanks
06:40:03 <vincenz> mathrick: that's a tricky naming of variables
06:40:07 <mathrick> $ applies its LHS to its RHS, but has really low priority
06:40:13 <vincenz> Jarod: what he means is  f $ g x = f (g x)
06:40:24 <mathrick> okay, I meant that
06:40:26 <mathrick> :)
06:40:28 <Jarod> ah composition ok
06:40:40 <vincenz> mathrick: yeah except a quick read of your line first made me think of c style f(x,y)
06:40:50 <mathrick> sorry about that
06:40:56 <vincenz> no worries :)
06:41:06 <Lemmih> mathrick: And what vincenz means is   f $ x = f x
06:41:12 <mathrick> heh
06:41:15 <vincenz> :)
06:41:35 <vincenz> Lemmih: except that case people wonder why you'd use it
06:41:37 <jberg> is f . g x == f $ g x ?
06:41:41 <vincenz> no
06:41:41 <mathrick> also, I can't see the bug in my my_foldr
06:41:45 <jberg> or do you need parens around (f . g) ?
06:41:49 <vincenz> f . g $ x = f $ g x
06:41:53 <vincenz> or
06:41:58 <vincenz> f . g $ x = f $ g x = f $ g $ x
06:42:21 <vincenz> jberg: f . g x.... function binding binds tighter so that would be f . (g x) instead of (f.g)x
06:42:34 <jberg> ok
06:42:41 <vincenz> $ binds the lowest and is right to left
06:43:14 <mathrick> ah, I can
06:43:31 <mathrick> <Jarod> my_foldr f init [] = f init
06:43:35 <mathrick> this is wrong
06:43:41 <Jarod> ah ?
06:43:44 <mathrick> my_foldr f init [] = init
06:43:58 <mathrick> the second line is also wrong :)
06:43:59 <vincenz> yep
06:44:01 <vincenz> f is dyadic
06:44:19 <Jarod> yes i understand for the first line
06:44:42 <mathrick> Jarod: foldr is supposed to return the value of the same type as f does, that's why it's called foldr
06:44:53 <mathrick> it doesn't make f operate on lists
06:44:58 <mathrick> but values
06:45:04 <Jarod> ok
06:45:07 <mathrick> > my_foldr (+) 0 [1 .. 10] where { my_foldr f init [] = init; my_foldr f init (x:xs) = f x $ my_foldr f init xs }
06:45:08 <lambdabot> 55
06:45:21 <mathrick> > foldr (+) 0 [1 .. 10] 
06:45:22 <lambdabot> 55
06:47:03 <Jarod> let y = my_foldr f init xs in f (x y) ?
06:47:20 <mathrick> hmm?
06:47:20 <Jarod> no
06:47:55 <Jarod> $ troubled me
06:48:00 <mathrick> ah
06:48:30 <mathrick> Jarod: it's essentially a neat way to write () without actually cluttering the code with excessive ()'s :)
06:48:44 <mathrick> > my_foldr (+) 0 [1 .. 10] where { my_foldr f init [] = init; my_foldr f init (x:xs) = f x (my_foldr f init xs) }
06:48:45 <lambdabot> 55
06:48:49 <mathrick> same thing
06:49:27 <mathrick> Jarod: and yes, it's troubling, I have learnt about $ just yesterday :)
06:49:30 <Jarod> ok thanks, i have understood :)
06:50:08 <mathrick> btw, what priority do user-defined operators have?
06:50:30 <mathrick> @type 1
06:50:31 <lambdabot> forall t. (Num t) => t
06:50:51 <mathrick> @type 1.2
06:50:52 <lambdabot> forall t. (Fractional t) => t
06:53:07 <Jarod> and for my_foldl: my_foldl f init [] = init
06:53:30 <Jarod> my_foldl f init (x:xs) = finit $ my_foldl f x xs
06:53:32 <Jarod> ?
06:57:01 <goron> mathrick: you can declare the priority yourself. 
06:57:19 <mathrick> oh, how?
06:58:08 <goron> E.g. infix 5 \\
06:58:34 <goron> You can also declare them to be infixr, or infixl. 
06:58:44 <mathrick> nice
06:58:50 <goron> mathrick: But there is a limitation.
06:58:58 <Jarod> > my_foldl (+) 0 [1 .. 10] where { my_foldl f init [] = init; my_foldl f init (x:xs) = f init (my_foldl f x xs) }
06:59:00 <lambdabot> 55
06:59:04 <xerox> HI!
06:59:17 <goron> mathrick: there are only about 9 priority levels.
06:59:22 <mathrick> aha
06:59:30 <goron> mathrick: But if you want to get around that, just write your own compiler :)
06:59:57 <goron> Maybe it's a good limitation. 
06:59:58 <Jarod> well my_foldl is good even if i don't really understand lol
07:00:50 <goron> Jarod: it helps to write down a list on paper. Then put the parentheses the way you want them, and then think of the code...
07:01:05 <xerox> Waaaa.
07:01:15 <Jarod> ok
07:01:18 <xerox> My internet is back on track.  Happy happy, joy joy.
07:01:29 <goron> It would be a cool hack, 100's of priority levels.
07:01:49 <goron> It would make a good entry to a code obfuscation contest.
07:02:32 <mathrick> > my_foldl (+) 0 [1 .. 10] where { my_foldl f init [] = init; my_foldl f init (x:xs) = my_foldl f $ f x init $ xs }
07:02:33 <lambdabot>   Occurs check: cannot construct the infinite type: b = [a] -> b
07:02:33 <lambdabot>   Expected type: b
07:02:33 <lambdabot>   Inferred type: [a] -> b
07:03:35 <mathrick> > my_foldl (+) 0 [1 .. 10] where { my_foldl f init [] = init; my_foldl f init (x:xs) = my_foldl f (f x init) xs }
07:03:37 <lambdabot> 55
07:03:40 <mathrick> now
07:03:45 <mathrick> Jarod: it's more like that
07:04:04 <mathrick> Jarod: use the init value as a vehicle to carry the value from left to right
07:04:11 <Jarod> my solution is false ?
07:04:18 <goron> You are using this channel as your private interpreter. 
07:04:26 <mathrick> it's the same as foldr as far as I can see
07:04:30 <mathrick> goron: who is?
07:04:38 <shapr> me me!
07:04:43 <mathrick> well, everyone is :)
07:04:44 <dcoutts> @quote dons
07:04:45 <lambdabot>  I don't mind autoconf, except for the fact that it's stupid and ugly
07:04:50 <shapr> @quote dons
07:04:50 <lambdabot>  note to self: grep only works on disks
07:04:56 <xerox> Hiya dcoutts, shapr, woopee!
07:05:00 <dcoutts> again, again
07:05:01 <dcoutts> @quote dons
07:05:02 <lambdabot>  I don't mind autoconf, except for the fact that it's stupid and ugly
07:05:05 <dcoutts> grr
07:05:06 <dcoutts> @quote dons
07:05:06 <lambdabot>  note to self: grep only works on disks
07:05:09 <dcoutts> @quote dons
07:05:10 <lambdabot>  note to self: grep only works on disks
07:05:12 <dcoutts> bah!
07:05:27 <shapr> @quote xerox
07:05:28 <lambdabot>  you know, befunge is probably the only language I've seen where you can
07:05:28 <lambdabot> run code pasted from IRC with the <nick> tags still in place ;-)
07:05:39 <xerox> O_o
07:05:40 * dcoutts wonders if lambdabot's quotes are local to a channel
07:05:46 <shapr> Nope.
07:05:52 <mathrick> Jarod: foldl needs to work differently than foldr, as lists in haskell naturally fold to the right, thanks to (x:xs) matching
07:05:52 * dcoutts tries again
07:05:54 <dcoutts> @quote dons
07:05:55 <lambdabot>  Haskell, the language of choice for the fully nerd!!!!
07:05:59 <shapr> w00
07:05:59 <dcoutts> yeah!
07:06:06 <xerox> What's up with @quote, people?
07:06:14 <xerox> @quote lambdabot 
07:06:15 <lambdabot>  Couldn't match kind `?? -> ? -> *' against `(* -> *) -> * -> *'
07:06:21 <mathrick> heh
07:06:22 <shapr> @quote DennisHuer
07:06:23 <lambdabot>  Are you fully nerd???? How can ghc expect an installed ghc for the first
07:06:23 <lambdabot> build stage????? What is that????
07:06:28 <dcoutts> nothing, it's just that dons has got too many quotes
07:06:39 <dcoutts> xerox, we were looking for one in particular
07:06:48 <xerox> @quote-search for the masses!
07:06:48 <lambdabot> Unknown command, try @listcommands.
07:07:01 <shapr> Truly, quote-search would be neat.
07:07:15 <xerox> Kind of @hoogle, @qoogle
07:07:23 * shapr grins
07:07:33 <Jarod> ah ok mathrick thanks
07:07:52 * xerox offers orange juice to the fellows Haskellers, his internet is back on track!
07:08:13 <shapr> w00
07:08:21 <mathrick> Jarod: if you want to check the correctness of left/right fold, choose some type and operator that's not commutative
07:08:29 <mathrick> > my_foldl (:) "" "asd" where { my_foldl f init [] = init; my_foldl f init (x:xs) = my_foldl f (f x init) xs }
07:08:30 <lambdabot> "dsa"
07:08:44 * dcoutts welcomes xerox back
07:08:47 <mathrick> > my_foldl (:) "" "asd" where { my_foldl f init [] = init; my_foldl f init (x:xs) = f init (my_foldl f x xs) }
07:08:48 <xerox> \o/
07:08:49 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
07:08:49 <lambdabot>   Expected type: a -> a -> a
07:08:49 <lambdabot>   Inferred type: a -> [a] -> [a]
07:08:49 <lambdabot> Maybe you meant: . id pl wn yow
07:08:53 <shapr> musasabi: Do you have any demo code for Oleg's HSXML lib? I'm tempted...
07:09:01 <xerox> dcoutts: how's code?
07:09:07 * shapr drinks coffee
07:09:08 <Jarod> ok  :)
07:09:09 <dcoutts> xerox, ok
07:09:37 <xerox> dcoutts: does Gtk2Hs work on osx at the present?
07:09:43 <dcoutts> xerox, yes
07:10:00 <xerox> Great.
07:10:06 <mathrick> > my_foldl (:) "" "asd" where { my_foldr f init [] = init; my_foldr f init (x:xs) = f x $ my_foldr f init xs }
07:10:07 <lambdabot>  Not in scope: `my_foldl'
07:10:12 <mathrick> bah
07:10:22 <xerox> It is something you'll have to explain me sometime in the next days :-)
07:10:37 <mathrick> > my_foldl (:) "" "asd" where { my_foldl f init [] = init; my_foldl f init (x:xs) = f x $ my_foldl f init xs }
07:10:38 <lambdabot> "asd"
07:10:40 <dcoutts> xerox, I've never done it myself but I hear that it works
07:10:47 <xerox> Right.
07:10:55 <mathrick> Jarod: here, you can see if it works with strings and (:) easily
07:10:56 <dcoutts> xerox, I wouldn't choose to afford a mac
07:11:13 <xerox> Why?
07:11:20 <dcoutts> xerox, and if I did I'd only end up running gentoo on it so there wouldn't be much point :-)
07:11:24 <Jarod> mathrick, yes
07:11:49 <xerox> dcoutts: heh, okay.  I've ordered one the last week, the order is still ``pending'' tho.
07:12:01 <mathrick> except that I meant foldr in that last line... wrong substitution
07:12:03 <dcoutts> xerox, ppc or x86 ?
07:12:22 <xerox> dcoutts: x86 dual core!
07:12:32 <dcoutts> xerox, nice
07:12:47 <mathrick> btw, damn you #haskell!
07:12:47 <xerox> Thought decision :-)
07:12:48 <dcoutts> xerox, I don't think ghc has been ported to that yet
07:12:53 * mathrick shakes his fist
07:13:06 <xerox> dcoutts: something to do then :-D
07:13:16 <dcoutts> xerox, heh, yep :-)
07:13:25 <shapr> mathrick: Are you addicted?
07:13:32 <xerox> mathrick: what what what's up?
07:14:05 <mathrick> you're sucking away my time
07:14:10 <mathrick> and I need to move :\
07:14:25 <pesco> mathrick: There's a technical solution to everything... ;-)
07:14:31 <xerox> Uh-oh.  Come here for another glass of orange juice!
07:14:48 <mathrick> and yes, lambdabot is almost as addictive as puyo puyo and puzzle fighter and tetris...
07:14:56 <Jarod> thanks for all your help mathrick 
07:15:06 <mathrick> np
07:15:12 <tromp_> anyone here installed ghc on Ubuntu?
07:15:19 * xerox raises hand
07:15:23 * pesco happily sways to the Quake soundtrack.
07:15:28 * pesco raises hand.
07:15:40 <tromp_> did you use a repository?
07:15:45 <xerox> Yep, universe.
07:16:07 <tromp_> just the standard ubuntu sites?
07:16:14 <xerox> ghc6:  //  Installed: 6.4.1-1ubuntu3  // 500 ftp://archive.ubuntu.com dapper/universe Packages
07:16:15 <pesco> Yep.
07:16:44 <tromp_> i'm running breezy though
07:16:49 <vincenz> who thinks that dia is a crappy software from a programming perspective?
07:16:55 <vincenz> lots of items are not first class
07:17:00 <shapr> mathrick: Wait till you start with djinn.
07:17:07 <vincenz> if you want extra connectors you have to make new objects in a custom format
07:17:19 <tromp_> ah, ghc6 works
07:17:27 <vincenz> if you want to group objects and still use their connectors, well you're fucked... grouped objects don't behave properly in terms of their subobjects
07:17:38 <vincenz> all in all the objects are not first class in groups
07:18:08 <shapr> vincenz: Fix it! Rewrite it in Haskell!
07:18:17 <vincenz> ya
07:18:22 <vincenz> I've been considering it
07:18:40 <xerox> tromp_: I think it works for breezy too, also, there is a breezy-backports repository, perchance...
07:19:43 <xerox> I must say that being disconnected from internet for a week had its advantages...  I finished a lot of books I started somewhen in the past...  yay :-)
07:20:24 <shapr> heh
07:20:26 <mathrick> shapr: heh
07:22:10 <mathrick> vincenz: dia is crappy
07:22:14 <vincenz> yah
07:22:16 <vincenz> but I have no alternative
07:22:19 <mathrick> cool kids nowadays use inkscape
07:22:47 * xerox grins
07:23:25 <vincenz> but I'm a nerd!
07:23:30 <shapr> inkscape r0xx
07:23:30 <sieni> h
07:23:45 <tromp_> got ghc up and running on my breezy box now
07:23:45 <sieni> make that \hbar rather
07:23:46 <xerox> In fact now it has some developement support for ``connectors''.
07:24:04 <mathrick> it's in in 0.43
07:24:08 <xerox> tromp_: now update to dapper flight 5 :-)
07:24:19 <vincenz> I want to make DIAGRAMS tho
07:24:20 <vincenz> not drawings
07:24:32 <xerox> DIAGRAMS are boring!
07:24:35 * xerox chuckles
07:24:36 <vincenz> to make flow diagrams (not flow graphs)
07:24:51 <mathrick> vincenz: inkscape has connectors just for that
07:24:55 <vincenz> mm
07:25:56 <vincenz> I once installed it
07:25:59 <vincenz> it was way too busy
07:26:14 <vincenz> ala office
07:26:28 <vincenz> I take it 0.42 won't do
07:26:28 <vincenz> ?
07:28:57 <vincenz> ah I remember my vexation now
07:28:59 <tromp_> dapper is a dutch word
07:28:59 <vincenz> you open inkscape
07:29:07 <vincenz> and you can't even find a basic square
07:29:08 <tromp_> meaning brave
07:29:11 <vincenz> yep
07:29:32 <xerox> "find a basic square" ?
07:29:37 <vincenz> yeah
07:29:40 <vincenz> a rectangle shape
07:29:47 <xerox> You can either get a square in terms of "borders", or a rectangle shaped object.
07:29:52 <vincenz> all it has is this blue square with a bunch of hilightling rap
07:29:56 <vincenz> crap
07:30:13 <xerox> Inkscape objects have introspection :-)
07:30:38 <mathrick> vincenz: ???
07:30:43 <mathrick> <vincenz> all it has is this blue square with a bunch of hilightling rap
07:30:44 <xerox> Try clicking on them many times, or playing with the menus in the upper right (color/stroke/alignments/..)
07:30:44 <vincenz> I want a basic rectangle
07:30:47 <mathrick> explain please?
07:30:50 <vincenz> like four black lines
07:31:03 <mathrick> vincenz: click rectangle on toolbar, drag on drawing area, voila!
07:31:11 <vincenz> it's black
07:31:20 <mathrick> change it's colour then?
07:31:25 * mathrick pffts @ vincenz 
07:31:28 <xerox> You do a rectangle, click on colours up there, remove the fill, add the stroke, set it to n px, black, and you can choose how it should joint & co.
07:31:36 <vincenz> mathrick: color != transparent
07:31:45 <mathrick> vincenz: what do you want to do?
07:31:53 <mathrick> vincenz: set it to no fill colour then
07:32:01 <vincenz> ah
07:32:01 <vincenz> at last
07:32:49 <vincenz> so much work for something simple
07:32:50 <vincenz> pfft
07:33:05 <mathrick> vincenz: ...
07:33:12 <mathrick> it's not mspaint y'know
07:33:17 <mathrick> and it's no work at all
07:33:27 <vincenz> I don't want mspaint
07:33:30 <mathrick> you do
07:33:31 <vincenz> I want something to easily make diagrams
07:33:51 <vincenz> aka simple shapes that can be connected easily with a bunch of layout crap (aka NOT mspaint, I care about content, not form)
07:33:53 <mathrick> vincenz: click rectangle tool, but don't draw anything, now change colour to none
07:33:59 <mathrick> it'll set the default fill to none
07:34:01 <mathrick> voila!
07:34:17 <vincenz> and then add connectors, meaning a bunch of work for something simple
07:34:18 <julian> a
07:34:26 <mathrick> vincenz: it *is* simple
07:34:29 <vincenz> I think inkscape is more presentation oriented
07:34:34 <vincenz> not quickthinking/diagramming
07:34:37 <pesco> I'd tend to agree with vincenz. The prototypical "rectangle", IMO, is not a region but a curve.
07:34:40 <mathrick> vincenz: then use dot
07:34:46 <vincenz> mathrick: dot doesn't draw
07:34:51 <mathrick> pesco: ?
07:35:03 <mathrick> vincenz: you can generate PNGs from it easily enough
07:35:15 <jethr0_> mathrick: you're not really helping
07:35:16 <pesco> mathrick: Obviously, the whole problem stems from the fact that vincenz didn't get the result he expected.
07:35:19 <mathrick> and a bunch of other formats
07:35:27 <mathrick> jethr0_: I don't see what's the problem
07:35:52 <jethr0_> how do you propose drawing a flow diagram in dot?
07:36:03 <pesco> mathrick: And my claim is that he rightfully expected something different from what he got.
07:36:04 <jethr0_> mathrick: vincenz wants a "dia" that doesn't suck
07:36:16 <vincenz> no my issues with inkscape is that it's presentation oriented, not idea-oriented
07:36:27 <mathrick> flow diagram is when you have a bunch of diamonds and rectangles joined with arrows?
07:36:29 <vincenz> it's like using powerpoint to make diagrams that convey ideas
07:36:47 <vincenz> dia, while crappy, is oriented to getting content first instead of the form
07:37:00 <vincenz> it's a bitch to make it look nice, but to get basic diagrams it's relatively a breeze
07:37:09 <mathrick> vincenz: if you want content, you can't get much more efficient than dot
07:37:20 <vincenz> mathrick: except dot is not gui-oriented
07:37:29 <mathrick> you never said you wanted gui
07:37:37 <vincenz> that was implicit
07:37:41 <mathrick> I'm just presenting you with solutions I know to work
07:37:45 <vincenz> I assume it awas also implicit in your answer "inkscape"
07:37:57 <jethr0_> there's this really nice (commercial) diagram editor for mac os.
07:38:06 <jethr0_> would be nice to have sth like that as OSS
07:38:30 <pesco> vincenz: Have you looked at any of the available 2d cad programs? Maybe one of them can do diagrams, too.
07:38:41 <vincenz> pesco: not yet no
07:38:44 <vincenz> so far I've stuck with dia
07:38:59 <vincenz> tried inkscape, and I don't want to diss it, it's fancy, but it doesn't serve the purpose
07:39:13 <vincenz> it's like using word to write latex
07:39:28 <mathrick> notice that latex is also not gui
07:39:30 <pesco> vincenz: I think I remember qcad having a library of diagram elements. I've used it to draw floorplans and after a little learning curve, it seemed to be a pretty fine program.
07:39:57 <vincenz> neat :)
07:40:41 <vincenz> when in highschool I did some interning at a company
07:40:57 <vincenz> and I worked with the most uberleet cad program ever (it simply made me DROOL) in comparison, autocad seemed like a buggy toy
07:41:13 <pesco> What was the name?
07:41:17 <vincenz> CATIA
07:41:34 <vincenz> heh, one day I tried autocad on a program, and it felt just wrong... CATIA lets you edit solids in 3d space
07:41:40 <vincenz> (or if you want you can pick a planE)
07:41:46 <jethr0_> supposedly catia and proengineer have become the industry standards
07:41:48 <vincenz> in contrast at that time autocad did only plane-editing
07:41:55 <vincenz> trust me, autocad -rocks-
07:42:03 <vincenz> well at least back then (this is 8 years ago)
07:42:35 <jethr0_> <vincenz> "autocad seemed like a buggy toy" "autocad -rocks-" ??
07:42:46 <vincenz> hmm?
07:42:49 <vincenz> woops
07:42:52 <vincenz> CATIA -rocks-
07:43:04 <__AL__> Only one scripting language in CATIA is Basic =(
07:43:22 <jethr0_> that makes autocad _way_ cooler with lisp scripting :)
07:43:32 * vincenz made a flythrough of a fusion reactor while there... using their CATIA SGI-model flyer (or whatever it's calleD)
07:43:47 <jethr0_> good old fusion reactor
07:44:11 <vincenz> it was for the iter project
07:44:14 <vincenz> www.iter.org
07:44:38 <vincenz> (international thermonuclear experimental reactor)
07:47:01 <__AL__> Does anybody know when CATIA for Linux will be released?
07:47:18 <jethr0_> that site get's the ironic "sensible use of javascript" award from me :)
07:47:43 <vincenz> heh
07:48:00 <vincenz> kinda funny, there'es an old pic of my father on that site too, even though he no longer works for the project :
07:48:03 <vincenz> :P
07:49:01 <jethr0_> supposedly (http://www.freelists.org/archives/cad-linux/07-2002/msg00000.html) there was an existing internal linux version in 2002 already
07:49:16 <goron> I used inkscape's "connector" functionality and it was totally flawed. 
07:49:33 <vincenz> jethr0_: we used IBMs with ...V (forgot the name)...and sgi
07:49:45 <vincenz> and these were powerhouses
07:49:50 <vincenz> each ibm was two desktops
07:49:55 <vincenz> one the computer, one the graphics renderer
07:49:58 <goron> Dia still crashes sometimes.
07:50:15 <vincenz> dia really sucks if you zoom your diagram, for some reason it beoms INANELY slow
07:50:39 <goron> In short, all open-source software that I know of sucks in this area. 
07:50:53 <vincenz> firefox?
07:51:04 <goron> vincenz: firefox is not in that area
07:51:15 <__AL__> xfig?
07:51:27 <vincenz> oh... 
07:51:33 <vincenz> I thougght you meant "all open-source is crashy"
07:51:39 <goron> __AL__: That might be something. I didn't look through all the documentation. 
07:51:49 <goron> __AL__: I have that on my TODO list.
07:52:00 <mathrick> xfig is hopeless
07:52:09 <goron> __AL__: but it looks very old.
07:52:34 <mathrick> goron: it's even older in reality
07:52:46 <__AL__> xdvi looks very old too but it is the best dvi viewer for me
07:53:02 * vincenz likes evince
07:53:11 <goron> __AL__: I think kdvi/evince are "better".
07:53:25 <goron> __AL__: For Latex, xdvi is better, since it's uberfast.
07:53:37 <__AL__> In evince i can't select text from dvi files
07:53:38 <vincenz> aweembaweh, aweembawehh, aweembaweh,
07:53:49 <goron> __AL__: you can in kdvi.
07:54:04 <vincenz> the lion song is great
07:56:33 <__AL__> goron, Hm, yes, selection works, but xdvi is much faster
07:56:43 <goron> __AL__: I know :)
07:57:41 <goron> OSS is good for programmers until this point. Non-programmers only see Firefox. People in other application domains (like construction) still have to cope with commercial garbage (especially in area's with little competition). 
07:58:49 <shapr> dcoutts: Yay Simon likes it! I also like the one package per file.
07:58:54 <goron> Problem basically is that there are very few people who understand the problem domain *and* are able do design sensible programs.
07:59:02 <dcoutts> shapr, yeah, it's looking good
07:59:07 <shapr> goron: There is a solution...
07:59:41 <shapr> goron: Find a friend who has a need and a bit of cash. Get them to pay you to write something simple that is immediately helpful.
08:00:36 <shapr> Then other friends in need will talk to their geeky friends, and said geeky friends will say "X exists and can help you, but it's really primitive, lemme add something."
08:01:00 <tromp_> shapr, i need a go program that can beat me:)
08:01:06 <tromp_> i have abit of cash...
08:01:09 <shapr> tromp_: There limits :-P
08:01:14 <shapr> "There are limits"
08:01:22 <goron> shapr: I don't think that works for construction software. 
08:01:43 <shapr> What could be automated in the construction domain?
08:01:57 <goron> shapr: Basically the modelling tools should Just Work. 
08:01:58 <shapr> Maybe start with a list of regulations by area?
08:02:08 <shapr> Oh, you mean CAD?
08:02:31 <goron> shapr: There are lots of regulations. If your program can automatically check all these rules, you'd be in business.
08:02:47 <shapr> A simple expert system would help there.
08:03:05 <shapr> "I have a building plan. I want to build this building in Ghent."
08:03:12 <goron> shapr: I don't think it will be that simple.
08:03:14 <shapr> "Does your building have N fire escapes?"
08:03:39 <goron> shapr: Yeah, those kinds of questions should be automatically answered.
08:04:05 <goron> shapr: but the most complex I think would be to get the GUI, and the FEM right.
08:04:09 <shapr> FEM?
08:04:12 <goron> (Finite Element Method)
08:04:37 <goron> "right" meaning "fast".
08:04:37 <shapr> I think it would make more sense to have naming conventions for a building plan.
08:04:57 <shapr> Then you could just count the number of fire escapes :-)
08:05:15 <goron> shapr: yes, the user could annotate something as being a fire escape.
08:05:44 <shapr> That wouldn't be hard to do.
08:05:47 <goron> shapr: I am not really into this domain myself, but I hear the cries of people using >100,000$ software.  
08:05:56 <shapr> Get them to hire you!
08:06:03 <goron> shapr: that software still crashes 
08:06:28 <shapr> OSS DXF file readers exist. You could count annotations easily enough.
08:07:02 <shapr> Organize a bunch of construction companies to fund an open source replacement that gives enough value to be used, and it will be extended.
08:07:22 <shapr> SchoolTool is doing this for school organization, and is generating lots of interest.
08:07:35 <goron> shapr: anyway, that's what I was saying: programmers have good tools (Emacs/Eclipse). Non-programmers do not. 
08:07:48 <goron> shapr: In theory it would be a great idea, indeed.
08:07:56 <shapr> True. That's because programmers are tool builders.
08:08:08 <shapr> We're digital blacksmiths.
08:08:15 <__AL__> goron, You tried Kivio? It looks hopefully...
08:08:38 <shapr> goron: It'd probably work in practice too. It sure wouldn't hurt to try.
08:08:46 <goron> shapr: In practice... I have no idea. Do you really think you can get 20 competitors in one domain to agree on how great that idea is?
08:09:05 <shapr> goron: If it'll save them $50,000 next year, then yes!
08:09:10 <goron> __AL__: no, I haven't.
08:09:39 <__AL__> goron, http://www.koffice.org/kivio/screenshots.php
08:09:46 <shapr> My friend spent $3000 on her laptop, and $5000 on her software.
08:10:17 <shapr> 95% of that was Adobe software. I suggested scribus, inkscape, gimp, etc
08:10:23 <shapr> She said they don't do ask much.
08:10:41 <goron> __AL__: Ah, I already have it on my system.
08:10:42 <neologism> anyone skilled here with analysis of paralel algorithms?
08:10:44 <shapr> I offered to extend them as much as I could if she would tell me what they're missing...
08:11:01 <shapr> neologism: I have a tiny clue in that area, not skilled.
08:11:29 <shapr> Sadly, my friend wouldn't even install the OSS programs to try them out. She just assumes they're worse than the commercial versions.
08:11:52 <goron> shapr: "She said they don't do ask much."?
08:11:55 <tromp_> obviously something free HAS to be tons worse than a 1000$ program...
08:11:59 <shapr> "as much"
08:12:05 <shapr> tromp_: Right, that's the reasoning.
08:12:06 <neologism> shapr: time complexity... what is t() c() and p() ?
08:12:17 <shapr> oh, no idea there...
08:12:21 <neologism> :(
08:12:22 <neologism> same here
08:12:24 <shapr> I thought you meant like opportunities for parallelism.
08:12:30 <shapr> What's the url for what you're reading?
08:12:35 <goron> neologism: I can help you with a few.
08:12:41 <neologism> I am studying for an exam
08:12:47 <goron> neologism: t is time for the compuation.
08:12:59 <goron> neologism: c is complexity, IIRC.
08:13:02 <shapr> neologism: Time, Cpu, and Processes?
08:13:06 * shapr is guessing
08:13:08 <goron> neologism: p, not a clue.
08:13:53 <neologism> goron: what is complexity?
08:14:03 <neologism> I mean.. whats the difference between t() and c() then
08:14:11 <neologism> btw: c() = p()*t()
08:14:14 <shapr> I know that humans mostly live in a rut of habit, but it still frustrates me.
08:14:15 <goron> neologism: I think the same as O
08:14:48 <neologism> uh.. seems like p() is time complexity of paralel algo
08:14:53 <goron> neologism: When you have a parallel alg. the complexity stays the same.
08:14:54 <neologism> t() is the same for sequential algo
08:14:57 <shapr> Maybe I should change my nick to Sisyphus for awhile.
08:15:02 <neologism> and c() is their product
08:15:11 <goron> neologism: no, t becomes small of course.
08:15:15 <goron> er smaller
08:15:40 <neologism> oh!
08:15:45 <neologism> p() is number of processors!
08:15:46 <goron> neologism: If you have an infinite number of computers you can solve NPC problems very fast. 
08:15:48 <neologism> now it makes sense
08:15:52 <goron> neologism: ok :)
08:16:11 <goron> shapr: I agree on your points.
08:16:24 <goron> shapr: Don't you see the same with Windows/Linux?
08:16:28 <neologism> thnx
08:16:42 <vincenz> goron: *cough* bs
08:16:59 <goron> vincenz: Come again?
08:16:59 <vincenz> goron: infinte number of computers doesn't necessarily solve a problem
08:17:10 <goron> vincenz: I didn't say that.
08:17:21 <vincenz> think of any linear ocmputation, try as much as you want, you can't speed it up with multiple computers
08:17:42 <goron> vincenz: I was talking about NPC.
08:17:50 <shapr> dons: Oh please make this quote of the week: "I know! What is wrong with all these functional programmers defining everything with recursion???? I think they do it just to be fully nerd!!!"
08:17:54 <vincenz> well ys, but it would all depend on the NPC problem, no?/
08:18:00 <vincenz> if it has implicit parallelism
08:18:12 <goron> vincenz: Uh... not really.
08:18:35 <Maddas> shapr: Eww :-)
08:19:06 <vincenz> goron: how do you figure
08:19:15 <goron> vincenz: Heuristics for NPC problems always branch. If you branch in all directions you always get the correct answer.
08:19:27 <goron> vincenz: that's where the infinite number of computers comes from.
08:19:37 <araujo> hello
08:19:43 <goron> vincenz: read always as "always".
08:20:01 <JKnecht> Ocmputation: an implicature of possible greater simplicity?
08:20:08 <goron> vincenz: I meant to say that it is possible to create heuristics that branch.
08:20:30 <goron> vincenz: do you understand?
08:22:25 <vincenz> yes
08:22:30 <vincenz> I'm not convinced it's true
08:22:34 <vincenz> but I understand
08:24:56 <vincenz> I didn't know heuristics always branch undatadependently
08:25:16 <vincenz> cause if they do, they the maximum number of computers is not infinte but just your branch factor
08:25:23 <vincenz> initially
08:25:32 <goron> vincenz: I am not saying they do. 
08:26:02 * vincenz wonders about it now
08:26:36 <goron> vincenz: If you have an infinite number of computers you can just try everything. 
08:27:09 <vincenz> ou assume the problemspace is enumerable
08:27:12 <goron> vincenz: the computation will be finished in the time that is needed to check one answer + the time needed to generate the answer. 
08:27:17 <vincenz> for instance... R is not enumerable
08:27:20 <vincenz> you can't try all of R at the same time
08:27:23 <goron> vincenz: NPC problems....
08:27:25 <vincenz> even with an infinte number of computers
08:27:47 <goron> vincenz: Tell me an NPC problem for which the property does not hold.
08:27:54 <goron> vincenz: I am most interested. 
08:27:56 <vincenz> goron: that's not a valid proof
08:28:17 <vincenz> goron: I'm not stating that what I say is true, I'm just saying that  I don't know of any proof negating it
08:28:41 <goron> vincenz: Ok, I will give you a better proof.
08:28:54 <goron> vincenz: Everything can be reduced to 3-SAT. 
08:29:07 <goron> vincenz: 3-SAT has finite space. 
08:29:18 <goron> vincenz: An enumeration is possible.
08:29:21 <goron> vincenz: QED
08:29:21 * vincenz doesn't know 3-sat :?
08:29:34 <goron> vincenz: then you don't have expertise on NPC>
08:29:36 <goron> vincenz: NPC.
08:29:49 <neologism> sat is about boolean expressions evaluation?
08:29:49 <tromp_> you can only reduce bounded space problems to 3sat
08:30:01 <mathrick> vincenz: SAT in normal form
08:30:16 <goron> tromp_: and are those non-bounded problems in NPC?
08:30:26 <vincenz> My point is simple... in general, for -A- problem, I don't know that you can parallelise a search algorithm infinitely
08:30:39 <tromp_> here's a problem you can't do with countably many computers:
08:30:40 <vincenz> I think that's probably problem-domain-specific
08:30:43 <goron> vincenz: not for a general problem, for NPC you can. 
08:30:48 <tromp_> what's the n'th bit of Omega?
08:30:52 <vincenz> goron: NPC is not a rpbolem
08:30:59 <vincenz> goron: NPC describes a facet of a problem
08:31:00 <goron> vincenz: it's a class.
08:31:02 <vincenz> yes
08:31:11 <vincenz> and I'm saying... for all elements in that class, it's not a given
08:31:22 <goron> vincenz: I am saying it is. 
08:31:29 <goron> vincenz: the proof is very simple.
08:31:48 <vincenz> using 3sat
08:32:03 <vincenz> someone just stated 3sat is only for boolean problems
08:32:20 <vincenz> tromp_: is that problem NPC?
08:32:29 <neologism> vincenz: http://en.wikipedia.org/wiki/Boolean_satisfiability_problem
08:32:31 <vincenz> tromp_: thank you for an example if so :)
08:32:35 <tromp_> i dont know what npc is
08:32:41 <vincenz> non polynomial complete
08:32:55 <vincenz> aka no polynomial algo will find a solution
08:32:57 <tromp_> oh, it's worse than that:(
08:33:02 <goron> tromp_: Omega, how interesting. 
08:33:09 <vincenz> tromp_: then  it's NPC
08:33:17 <goron> vincenz: incorrect.
08:33:18 <tromp_> no
08:33:26 <mathrick> vincenz: npc is not non-polynomial
08:33:29 <tromp_> to be complete for a class, you have to be *in* the class
08:33:37 <mathrick> it's non-deterministic polynomial
08:33:39 <neologism> non-deterministic polynomal
08:33:40 <goron> vincenz: non-determistic polynomial
08:33:56 <goron> vincenz: I guess you need to read a good book :)
08:34:04 <mathrick> vincenz: also, your definition is incorrect
08:34:07 <neologism> ie. only ND turing machine can solve that in P time
08:34:07 <tromp_> oh NP-complete
08:34:23 <vincenz> goron: no it's just been a long time
08:34:32 <mathrick> if it was known that no polynomial algo will find a solution, someone would be richer by few M $
08:34:47 <goron> mathrick: I have been thinking about that. 
08:34:48 <neologism> mathrick: it is known.. just not proven :)
08:34:59 <tromp_> you shldn't abbreviate that to NPC;(
08:35:01 <vincenz> NP-complete is no polynomial solution to me
08:35:07 <goron> mathrick: It's hard to make money from such an algorithm.
08:35:13 <mathrick> vincenz: then you're wront
08:35:15 <mathrick> *g
08:35:16 <neologism> vincenz: nondeterministic TM can solve such problems in P time
08:35:18 <goron> mathrick: You can get 1M from Clay-math.
08:35:21 <vincenz> neologism: how?
08:35:27 <vincenz> neologism: and nondeterministic in what sense?
08:35:30 <mathrick> goron: ?
08:35:37 <mathrick> it's the money for proof
08:35:39 <mathrick> not algo
08:35:45 <neologism> vincenz: you dont know what nondeterministic TM is?
08:35:45 <goron> mathrick: yes, I know.
08:35:50 <mathrick> well, algo would be a proof if it was polynomial
08:35:56 <goron> mathrick: You said a few M$.
08:36:06 <vincenz> neologism: no
08:36:10 <mathrick> goron: I think there was more than one of them?
08:36:11 <vincenz> neologism: my formation is EE, not cs
08:36:18 <mathrick> s/was/were/
08:36:31 <goron> mathrick: I don't think you can make billions of dollars from it. 
08:36:37 <goron> mathrick: although that is it's value. 
08:36:40 <tromp_> P vs NP is the most famous open problem in all of computer science
08:36:54 <mathrick> goron: few M != billions
08:36:55 <goron> mathrick: (when a polynomial (with small constant) alg is found) 
08:37:03 <goron> mathrick: sure
08:37:21 <neologism> vincenz: http://en.wikipedia.org/wiki/Turing_machine#Deterministic_and_non-deterministic_Turing_machines
08:37:27 <mathrick> also, having found a polynomial algo would surely make you richer than that
08:37:29 <vincenz> thx
08:37:35 <goron> mathrick: How?
08:37:49 <mathrick> because if you can do it, certain possibilities open up?
08:37:57 <goron> mathrick: legally, I mean.
08:38:02 <vincenz> neologism: ah I see... you just hide the exponential complexity in the machine itself
08:38:07 <mathrick> goron: !?
08:38:10 <neologism> vincenz: ND TM has the same computing ability as D TM it just computes faster ;)
08:38:15 <tromp_> the CIA will want to capture you:(
08:38:26 <goron> tromp_: I know.
08:38:30 <vincenz> If the action table contains multiple entries for a combination of symbol and state then the machine is
08:38:38 <goron> tromp_: That's why I am glad why I haven't found it yet.
08:38:39 <neologism> vincenz: see lets say you have a language which accepts strings [ ab | a == reverse b ]
08:38:47 <neologism> no deterministic machine can say where a ends and b starts
08:38:50 <neologism> nondeterministic can
08:39:01 <vincenz> o.O
08:39:06 <vincenz> that seems simple
08:39:08 <vincenz> split in half
08:39:20 <neologism> vincenz: think of accepting words of a language
08:39:28 <neologism> ie. you have infinite stream of chars
08:39:31 <vincenz> ah
08:39:32 <vincenz> hmm
08:39:35 <neologism> there's no "half"
08:39:38 <vincenz> so multiple of those
08:39:44 * vincenz nods
08:39:46 <vincenz> right
08:39:47 <vincenz> so the question is
08:39:48 <neologism> abba
08:39:54 <vincenz> can you do this with infinitely many machines
08:39:54 <neologism> what is a and what is b?
08:39:58 <goron> Theoretical CS is so nice. I read a paper on super-turing cap. this week :) Although, I was not really convinced of the correctness.
08:40:00 <vincenz> ab and ba
08:40:08 <neologism> vincenz: why not a and b ?
08:40:15 <neologism> I mean... "a" and "b" 
08:40:16 <vincenz> neologism: cause a != reverse b
08:40:26 <neologism> sorry "b" and "b" of course
08:40:40 <vincenz> neologism: cause then you're "a" is unmatched
08:40:41 <mathrick> goron: super-turing cap?
08:40:41 <mathrick> what is cap?
08:40:46 <neologism> vincenz: it doesnt matter
08:40:49 <vincenz> hh?
08:40:58 <neologism> I am just trying to show you that ND can do a bit more than D
08:41:01 <neologism> or faster
08:41:15 <neologism> ok... lets have a finite stream.. D machine can check all occurances
08:41:19 <neologism> ND just "guess" and has it
08:41:22 <neologism> ie. its faster :)
08:41:29 <neologism> the same applies to turing machiens
08:41:30 <vincenz> so it's basically like a quantum mcomputer
08:41:44 <dcoutts> @seen mwc
08:41:44 <neologism> ND TMs cannot be built I think
08:41:45 <lambdabot> I saw mwc leaving #haskell 10 hours, 18 minutes and 45 seconds ago.
08:41:52 <mathrick> neologism: orly
08:41:53 <vincenz> then why argue about them?
08:42:06 <vincenz> csers...
08:42:08 * vincenz tsks
08:42:17 <goron> mathrick: capability
08:42:32 <mathrick> vincenz: because it's useful for showing certain fundamental properties of the universe
08:42:38 <vincenz> oh?
08:42:51 <mathrick> goron: okay, so what would it be capable of, and is it a model attainable in any way?
08:43:07 <goron> mathrick: it's capable of solving the Halting Problem.
08:43:10 <neologism> mathrick: what is orly?
08:43:13 <goron> mathrick: among other things.
08:43:14 <mathrick> goron: ooooh
08:43:15 <neologism> airport in paris? ;)
08:43:21 <mathrick> neologism: "oh really?"
08:43:21 <vincenz> hehe
08:43:31 <mathrick> vincenz: for instance, showing that ND = D in terms of power shows that certain problems are truly not computable
08:43:35 <vincenz> man this conversation is scattered
08:43:38 <mathrick> unless that paper goron read is true
08:44:01 <mathrick> but so far, TM is the most powerful model of computation known
08:44:04 <mathrick> and it can't do halting
08:44:10 <goron> Computer Science also gives insights about consciouness, and other fundamental questions. 
08:44:13 <neologism> mathrick: TM with an oraculum is stronger I think
08:44:19 <mathrick> goron: but how does it deal with diagonalisation?
08:44:19 <vincenz> goron: that's debatable
08:44:31 <vincenz> neologism: an oracle plain and simple is even better
08:44:34 <mathrick> neologism: but oracle is not realisable
08:44:48 <neologism> model doesnt have to be realisable
08:44:53 <neologism> but ok.. I agree
08:44:54 <mathrick> goron: it'd imply it's not serialisable
08:45:08 <mathrick> and that would mean you can't write programmes for it
08:45:12 <goron> mathrick: diagonalisation? 
08:45:13 <mathrick> which is somewhat inconvenient
08:45:21 <mathrick> goron: the original halting problem uses it
08:45:32 <mathrick> what happens on M'(M')?
08:45:37 <goron> mathrick: oh, that. 
08:45:47 <mathrick> TM's equivalent of Russel's paradox
08:45:55 <goron> mathrick: Halting Problem is defined on TM. 
08:45:57 <vincenz> should use a constructive model then
08:46:13 <mathrick> ah, that way
08:46:27 <goron> mathrick: The Halting Problem does not exist for STM.
08:46:34 <neologism> what is STM?
08:46:43 <goron> neologism: Super-TM.
08:46:48 <neologism> what is super-tm?
08:46:52 * vincenz sighs
08:46:56 * vincenz is stuck formalizing something
08:47:02 <goron> neologism: read back, ty.
08:47:12 <mathrick> goron: well, but if you wanted to halt STM... :)
08:47:14 * neologism doesnt see it
08:47:35 <goron> neologism: Super Turing Machine.
08:47:44 <neologism> yeah.. but what it is :)
08:47:56 <mathrick> <goron> Theoretical CS is so nice. I read a paper on super-turing cap. this week :) Although, I was not really convinced of the correctness.
08:48:02 <mathrick> sigh
08:48:02 <neologism> aaah
08:48:35 <mathrick> goron: that's a bit of evading a problem by saying "it doesn't apply to me"
08:48:47 <mathrick> but if you could do HP just for TMs, it's still nice
08:48:56 <mathrick> but then, it's not realisable
08:49:04 <mathrick> at least not on our computers
08:49:19 <mathrick> because you need to serialise to a TM to run on a computer
08:49:21 <goron> mathrick: I am saying that you can solve the HP for a Turing Machine program on a STM.
08:49:41 <mathrick> goron: and how does an STM work?
08:49:52 <goron> mathrick: Good question, nobody knows.
08:50:01 <neologism> mathrick: http://en.wikipedia.org/wiki/Super-Turing_computation
08:50:02 <neologism> I found this
08:50:05 <mathrick> so what the hell was that paper about?
08:50:16 <goron> mathrick: The paper conjectured that the universe is one.
08:50:27 <mathrick> oh, how so?
08:50:34 <goron> mathrick: read the paper, please.
08:50:39 <mathrick> okay, where?
08:50:42 <goron> mathrick: I will give you the URL.
08:50:55 <goron> mathrick: Or, better, I will dcc it.
08:51:04 <mathrick> k
08:51:25 * neologism interested in the url
08:52:18 <goron> Oh, then I will look up the URL.
08:53:08 <goron> wget http://archive.cs.uu.nl/pub/RUU/CS/techreps/CS-2002/2002-002.pdf
08:53:19 <neologism> tnxc
08:53:27 <mathrick> what a descriptive name
08:53:48 <goron> mathrick: can't have it all.
08:54:22 <vincenz> goron: anyways, I hope no hard feelings
08:54:29 <goron> vincenz: of course not. 
08:54:36 * vincenz argues until proven wrong
08:54:36 <goron> vincenz: you know EE :)
08:55:02 <vincenz> all my cs knowledge is self-taught
08:55:04 <goron> vincenz: (at least that's what you told us ;) )
08:55:14 <vincenz> yep cs ain't my backgkround
08:55:49 <vincenz> still not sure whether I agree about the infinite computers however
08:56:13 <neologism> infinite computers?
08:56:17 <goron> vincenz: finite space, infinite computers. Isn't it obvious?
08:56:22 <mathrick> reductability is one of the fundamental properties of NPC problems
08:56:24 <vincenz> goron: why finite space??
08:56:34 <goron> vincenz: 3-SAT is finite.
08:56:43 <goron> vincenz: Everything can be reduced to 3-SAT.
08:56:48 <vincenz> define everything
08:56:53 <mathrick> in NPC class
08:56:55 <goron> vincenz: Everything in NPC
08:57:09 <neologism> goron: are you talking about lineary bounded TM?
08:57:19 <vincenz> so if you had a code-analysis thingy that was NPC... you're saying it can be brought to 3sat
08:57:30 <vincenz> or for instance optimal layouting (for a memory manager)
08:57:30 <goron> vincenz: yep
08:58:06 <goron> vincenz: with only polynomial blow-up.
08:58:16 <vincenz> erm
08:58:27 <goron> vincenz: it might be 10^10000, but yes, that's possible. 
08:58:38 <vincenz> what's blow-up?
08:58:49 <vincenz> you mean the branching facotr
08:58:51 <mathrick> vincenz: slowdown
08:59:00 <vincenz> in laymen?
08:59:09 <mathrick> you can reduce a problem using well-defined, polynomial algo
08:59:24 * vincenz kicks himself in the balls
08:59:30 <vincenz> doh
08:59:41 <vincenz> I thought NP-complete, not polynmoial
09:00:18 <mathrick> I thought that too for a long time
09:00:27 <mathrick> then I was taught better :)
09:00:30 <vincenz> well it's liberally used 
09:00:43 <mathrick> well, it's used without definition often
09:00:48 <vincenz> heh
09:00:55 <vincenz> NP-complete to me = exponential
09:00:56 <mathrick> hence people assume it's non-polynomial
09:01:05 <mathrick> vincenz: most probably, yes
09:01:10 <mathrick> but noone knows for sure
09:01:18 <goron> I'd laugh really hard when P=NP. 
09:01:28 <mathrick> why?
09:01:28 <vincenz> why woudl that ever be?
09:01:47 <goron> Well, the whole society is build on P/=NP
09:01:53 <mathrick> how so?
09:01:55 <vincenz> how so?
09:02:12 <goron> mathrick: every security process assumes it.
09:02:17 <mathrick> will buildings suddenly collapse when it's false?
09:02:21 <vincenz> you mean for prime-factorisation
09:02:24 <goron> mathrick: besides one time pad.
09:02:28 <mathrick> well
09:02:29 <goron> vincenz: not only that.
09:02:33 <vincenz> for instance
09:02:46 <goron> vincenz: discrete logarithm.
09:02:46 <mathrick> goron: n^1000 is still slow
09:02:51 <vincenz> goron: right
09:02:56 <mathrick> O(n^1000) even
09:02:59 <goron> mathrick: true.
09:03:05 * vincenz votes to ban the O notation
09:03:11 <goron> mathrick: I ofcourse meant a low constant. 
09:03:15 <vincenz> it's the most absurd notation ever
09:03:17 <goron> er of course.
09:03:21 <mathrick> vincenz: ?
09:03:32 <pesco> vincenz: Got any better suggestion?
09:03:38 <goron> pesco: I have.
09:03:46 <mathrick> hmm, and what is discrete logarithm?
09:03:59 <mathrick> now I am not familiar with that :)
09:04:01 <vincenz> mathrick: find a in a^k mod n = b
09:04:02 <goron> What is this? A CS education channel?
09:04:15 <vincenz> err
09:04:16 <vincenz> find k even
09:04:31 <vincenz> goron: prime log isn't cs specific
09:04:32 <mathrick> aha
09:04:37 <vincenz> crypto at our uni is given to ee not cs
09:04:48 <goron> vincenz: I know
09:05:04 * mathrick isn't a crypto guy
09:05:06 <goron> vincenz: I am sure banking people get something about it too.
09:05:11 <vincenz> probably
09:13:48 <shapr> hiya dbremner, did you see your proxy blog? ;-)
09:14:55 <shapr> goron: Yes, I'd call this a CS education channel.
09:15:00 <SimonRC> Interesting: there are problems which can be solved by modern computers that cannot be solved algorithmically.
09:15:03 <SimonRC> specifically, those problems cannot be solved algoritmically because they are not functions.
09:15:24 <SimonRC> http://www.engr.uconn.edu/~dqg/papers/myth.pdf
09:15:24 <ski> vincenz : what do you think absurd about it ?
09:15:28 <SimonRC> :-S
09:16:20 <goron> shapr: yes, you are right. I think everyone learned something here. 
09:20:56 <ski> (SimonRC : .. i wonder if choice machines is related to the "with" connective in linear logic)
09:24:18 <Cale> SimonRC: Hm?
09:24:25 <gzl> Cale, mind if I privmsg you?
09:24:26 <ski> (hm .. "entanglement of inputs and outputs" make me think of laziness)
09:24:32 <Cale> gzl: I don't mind
09:28:29 <tromp_> what a great paper. it argues that driving a car is not a mathematical function but is computable by a robotic car:)
09:29:04 <tromp_> and therefore limiting computabililty to mathematical functions is flawed:)
09:32:43 <Cale> that seems a little silly to me
09:33:37 <mathrick> it is silly
09:33:45 <mathrick> it all depends on how you define a function
09:34:13 <mathrick> monads clearly show you can treat interaction using well-defined mathematical concepts
09:35:10 <mathrick> besides, you could always see driving a car as an instance of an offline problem (thus computable), just treated with an online algorithms
09:35:14 <Cale> Most computers aren't even as powerful as a TM by the fact that they have bounded memory.
09:35:21 <mathrick> so it's not true they aren't algorithmical
09:35:39 <Cale> yes, of course
09:37:40 <SimonRC> Actually, that whole paper seems to be about one tiny piece of pedantry: Theoretical CS is about functions, not general programs.  And since big programs consist of lots of functiony code and a relatively small amount of non-functiony code that PoV is definitely useful.
09:37:48 <SimonRC> erm
09:38:08 <SimonRC> "that PoV" == only considering functions.
09:38:18 <mathrick> of course
09:38:35 <Cale> A computer as a whole can be modelled by a function though.
09:38:41 <mathrick> the rest is just a plumbing to adapt those functions to a reality
09:38:56 <Cale> It's the other way around that's the hard part
09:39:07 <mathrick> well, yeah
09:39:33 <mathrick> but generally, you can always see any interaction as an instance of algorithmic problem
09:39:46 <mathrick> you only need to define an appropriate measure for solutions
09:39:56 <tromp_> i'll happily toss that paper on my sillyness pile:)
09:40:07 <mathrick> heh
09:45:58 <dcoutts> hia SyntaxNinja 
10:06:59 <SyntaxNinja> w00t
10:08:04 <shapr> hiya SyntaxNinja 
10:08:33 <goron> Cale: what about the universe? Is the universe a TM (in your opinion)?
10:09:15 <Cale> Depends on what you mean by 'universe'. If you mean our current physical model, then I think so, yes.
10:12:06 <Cale> well, it's not directly a TM, I suppose. It's a mathematical system together with an interpretation which maps those mathematical statements into expected observations. Both of those should be computable, even if in a not-so-useful way. (Enumerating true statements of a theory tends to be slow)
10:13:54 <goron> Cale: well, I meant like the transitive closure of the reachability relation from my current location :) 
10:13:59 <xerox> I recently read an article about ``black holes as computers'' which have some interesting facts in it.
10:14:17 <goron> xerox: the most interesting was that you couldn't get the answer out of it.
10:14:35 <Cale> goron: but assuming any model of space to be able to define that relation means that you've already accepted a formal model
10:14:51 <goron> Cale: yes, you are right.
10:15:19 <xerox> It wasn't the scientific paper or such, it didn't mention that, hmm.  I think it said that they're trying to find the algorithm beneath...
10:15:34 <xerox> Well, it was in the italian translation of ``Scientific American''.
10:15:40 <goron> Cale: some people think that the universe is finite and that you can jump from one location to the next instantly.
10:15:42 <shapr> Leibniz said the world was made of monads.
10:16:02 <Cale> shapr: but he meant something different by 'monad' than we do
10:16:13 <xerox> Right.
10:16:15 <shapr> He meant a cellular automata, pretty much.
10:16:26 <xerox> Also he had two philosphical theories!
10:16:52 <xerox> One public, to please the reinessance men, one private, which was the first to talk about the concept of... /me tries to remember
10:16:56 <shapr> I met a few highschool age math geeks here in Boden, and they were big fans of Wolfram's New Kind of Science.
10:17:09 <SyntaxNinja> heya shapr. how's it going?
10:17:29 <xerox> Oh right, the Voltaire's book,``Candide'', you know?  The fact that this world, simply for the fact of being the only one, is the best one.
10:17:48 <Cale> http://www.rbjones.com/rbjpub/philos/classics/leibniz/monad.htm
10:18:05 <Cale> #2 there seems quite questionable to me
10:18:20 <xerox> There is a whole lot of wierdness about monads and windows that I recall...
10:18:23 <Cale> data Tree = Branch [Tree]
10:19:16 <edwinb> Branch [] is the simple thing
10:19:29 <goron> How can I get in math mode a bold variable?
10:19:34 <shapr> SyntaxNinja: life is good!
10:19:35 <Cale> oh, perhaps I want
10:19:37 <Cale> data Tree = Branch Tree [Tree]
10:19:43 <xerox> Say the simple things are 0 1 and you map the meaning upon ;-)
10:19:45 <Igloo> goron: \mathbf{x}
10:19:50 <ValarQ> Cale: maybe there can be simple compounds
10:19:53 <goron> Igloo: ty 
10:20:43 * xerox takes it back, it was so nineties...
10:20:57 <Cale> I suppose it's acceptable to assume that there's always finite recursion depth, but call it an assumption rather than a conclusion.
10:21:34 <xerox> Let's say ``it from bit'' in a more 21th-century-ish way: ``it from qubit".
10:22:15 * ValarQ liked the old water/fire/earth/cheesecake theory...
10:22:54 <bolrod> ?
10:23:04 * araujo waiting for the "universe being a software simulation" theory
10:23:23 <bolrod> :)
10:23:30 <xerox> araujo: I could try to translate the article I got into english...
10:23:47 <xerox> ...but maybe there is some licterature online.
10:23:48 <araujo> xerox, you've got it?, i mean, i know there are people working in such a theory
10:24:08 <xerox> <http://www.ar-tiste.com/qcomp_onion/jan2002/UltimateLaptop.htm>
10:24:44 <xerox> Yeah, it has some numbers too, like, the maximum number of bits of information the universe stores... & co.
10:24:52 <araujo> hah nice
10:24:57 <xerox> This link is just what I found googline now a little bit.
10:25:29 <xerox> I'll make an attempt to translate it then, okay :-)
10:25:36 * xerox can't promise tho ;-)
10:26:21 <araujo> xerox, but what do you have?
10:26:50 <goron> I finally understand why people like Emacs. 
10:27:14 <xerox> Let me find it.
10:29:09 <xerox> I've got a little "Extreme physics: from negative energy to quantum teletransportation." book with some number of the italian translation of the American Scientist, one of the chapters is titled ``Black holes as computers''.
10:37:09 <roconnor> how much energy does it take to preform a computation.
10:37:12 <roconnor> ans: non.
10:37:15 <roconnor> ans: none.
10:39:19 <ski> how much energy does it take to throw away information ?
10:39:52 <xerox> Do you know it exist negative information? 
10:40:14 <xerox> Okay, don't ask me the details now, a whole lot of quantum-blah :-)
10:43:29 <roconnor> ski: 9.56993863  10-24 J / K / bit
10:43:57 * ski smiles
10:44:07 <roconnor> am I right?
10:44:15 <ski> i don't recall :)
10:44:40 <roconnor> @google ln(2)*(boltzmann constant) in J/K
10:44:41 <lambdabot> ln(2) * Boltzmann constant = 9.56993863 x 10^-24 J / K
10:45:08 <ski> er ?
10:45:22 <ski> doesn't lambdabot usually respond with an url ?
10:45:43 <Blicero_> google does math
10:46:03 * ski 'oh's
10:46:31 <dcoutts> anyone know of ldap bindings for Haskell?
10:47:20 <davidhouse> ski, you've not seen google's calculator?
10:47:55 <bolrod> wow!
10:48:19 <roconnor> @google (mass of earth)*(1 knot)*(1 mph) in J
10:48:21 <lambdabot> mass of Earth * (1 knot) * (1 mph) = 1.37393005 x 10^24 joules
10:48:31 <davidhouse> @google the speed of light in gigaparsecs per fortnight
10:48:33 <lambdabot> the speed of light = 1.1751994 x 10^-11 gigaParsecs per fortnight
10:48:40 <bolrod> haha
10:48:43 <davidhouse> now THAT is a useful number.
10:48:44 <bolrod> thats sick
10:49:53 <davidhouse> > Just "ask"
10:49:54 <lambdabot> Just "ask"
10:50:05 <bolrod> > Just "do it!"
10:50:06 <lambdabot> Just "do it!"
10:50:09 <ski> davidhouse : not that i remember, no
10:50:22 <davidhouse> @google google calculator
10:50:23 <lambdabot> http://www.google.com/features.html
10:50:48 <bolrod> @google mass of sun in grams
10:50:50 <lambdabot> mass of the sun = 1.98892 x 10^33 grams
10:50:52 <bolrod> ;o
10:51:02 <bolrod> mass of galaxy in milligrams
10:51:09 <bolrod> @google mass of galaxy in milligrams
10:51:11 <lambdabot> http://en.wikipedia.org/wiki/Orders_of_magnitude_(mass)
10:51:15 <bolrod> hrm
10:51:24 <bolrod> @mass of solar system
10:51:25 <lambdabot> Maybe you meant: map msg
10:51:31 <bolrod> @google mass of solar system
10:51:33 <lambdabot> http://www.solarviews.com/eng/solarsys.htm
10:51:38 <bolrod> bla
10:51:38 <davidhouse> @google mass of the sun * mass of the earth / mass of a proton in milligrams
10:51:40 <lambdabot> (mass of the sun * mass of Earth) / proton mass = 7.1039415 x 10^87
10:51:40 <lambdabot> milligrams
10:51:46 <bolrod> haha
10:52:01 <davidhouse> it's even internationalised.
10:52:14 <vincenz> that's a odd thing
10:52:23 <bolrod> @google (mass of sun ) / mass of electron in milligrams
10:52:24 <vincenz> why are you multiplying two masses
10:52:25 <lambdabot> http://en.wikipedia.org/wiki/Orders_of_magnitude_(mass)
10:52:37 <bolrod> @google mass of electron
10:52:39 <lambdabot> http://whatis.techtarget.com/definition/0,,sid9_gci839930,00.html
10:52:46 <davidhouse> http://www.google.fr/search?hl=fr&q=rayon+de+la+terre&spell=1
10:52:51 <roconnor> @google 1 pound force divided by 1 pound times 1 British pound
10:52:53 <lambdabot> ((1 pound force) divided by (1 pound)) times (1 British pound) = 16.
10:52:53 <lambdabot> 9890405 m U.S. Dollars / s^2
10:52:57 <vincenz> google mass of a proton
10:52:58 <davidhouse> vicenz, no real reason.
10:53:00 <vincenz> @google mass of a proton
10:53:02 <lambdabot> http://www.newton.dep.anl.gov/askasci/gen01/gen01078.htm
10:53:06 <davidhouse> @google m_p
10:53:08 <lambdabot> http://www.filext.com/detaillist.php?extdetail=M_P
10:53:16 <davidhouse> @google proton mass
10:53:17 <lambdabot> http://www.newton.dep.anl.gov/askasci/gen01/gen01078.htm
10:53:20 <davidhouse> huh?
10:53:23 <ski> (oughtn't it tell the unit in the answer ?)
10:53:24 <bolrod> @google mass gold
10:53:26 <lambdabot> http://www.allmeasures.com/Formulae/static/formulae/atomic_mass/16.
10:53:26 <lambdabot> htm
10:53:30 <davidhouse> @google proton mass in kilograms
10:53:32 <lambdabot> proton mass = 1.67262158 x 10^-27 kilograms
10:53:52 <roconnor> @google netruno mass
10:53:53 * ski misreads
10:53:54 <lambdabot> No Result Found.
10:54:00 <roconnor> @google netrino mass
10:54:02 <lambdabot> http://www.chemphys.boun.edu.tr/~semiz/universe/far/03.html
10:54:04 <roconnor> :(
10:54:05 <bolrod> @google density of gold in grams per cubic inch
10:54:06 <lambdabot> http://www.24carat.co.uk/densityofgoldandothermetals.html
10:54:20 <bolrod> @google mass positron
10:54:21 <lambdabot> http://www.nucmed.buffalo.edu/prevweb/positron.htm
10:54:23 <davidhouse> it's not that good.
10:54:29 <bolrod> :)
10:54:32 <ski> @google mass of top quark in kilograms
10:54:33 <lambdabot> http://en.wikipedia.org/wiki/1_E-30_kg
10:54:52 <bolrod> @google mass of the average american devided by the average weight of humans in afrika 100.000 years ago
10:54:53 <lambdabot> http://feuerhake.unverkaeuflich.net/?c=English
10:54:59 <bolrod> :x
10:55:23 <mauke> "divided", "africa", "100,000"
10:55:38 <bolrod> I See
10:55:48 <bolrod> 100.000 depends on where you live.....
10:55:53 <bolrod> @google 1.1+0.1
10:55:54 <lambdabot> 1.1 + 0.1 = 1.2
10:55:56 <bolrod> :)
10:55:57 <ski> @google airspeed velocity of an unladen swallow in meters per second
10:55:59 <lambdabot> http://www.style.org/unladenswallow/
10:56:01 <bolrod> @google 1,1+0,1
10:56:02 <lambdabot> 1,1 + 0,1 = 1,2
10:56:06 <bolrod> hmm.
10:56:11 <davidhouse> ski, european or african?
10:56:21 <davidhouse> or whatever the quote is :)
10:56:26 <roconnor> >(1,1) + (0,1)
10:56:30 <roconnor> > (1,1) + (0,1)
10:56:31 <lambdabot>  add an instance declaration for (Num (a, b))
10:56:31 <lambdabot>   In the definition of `tvi': tvi = (1, 1) + (0, 1)
10:56:31 <lambdabot>   In the definition of `v': v = let tvi = (1, 1) + (0, 1) in take 2048 (
10:56:31 <lambdabot> show tvi)
10:56:35 <bolrod> DUH
10:56:41 <ski> davidhouse : i was hoping google calculator would query that ..
10:56:55 <jethr0_> > (0,0) < (1,0)
10:56:56 <lambdabot> True
10:56:57 <bolrod> @google speed fastest animal
10:56:59 <lambdabot> http://www.homeworkspot.com/ask/fastestanimals.htm
10:56:59 <davidhouse> @google meaning of the life, universe and everything
10:57:01 <lambdabot> http://en.wikipedia.org/wiki/The_Answer_to_Life,_the_Universe,_and_
10:57:01 <lambdabot> Everything
10:57:06 <davidhouse> aww. it used to work.
10:57:11 <davidhouse> @google life, the universe and everything
10:57:11 <bolrod> ?
10:57:13 <lambdabot> http://en.wikipedia.org/wiki/The_Answer_to_Life,_the_Universe,_and_
10:57:13 <lambdabot> Everything
10:57:23 <ski> @google lajakeka
10:57:27 <lambdabot> http://www.mongoosepublishing.com/phpBB2/posting.php?mode=quote&p=25689&
10:57:27 <lambdabot> sid=9e1ffc155682bd554ded8e69437f61ad
10:57:27 <bolrod> @google intent of google power
10:57:29 <lambdabot> http://www.stephanspencer.com/tag/google_power_searching
10:57:38 <ski> @google ogg-kor-kaggaz
10:57:42 <lambdabot> http://towerofthesun.com/lonewolf/modules.php?name=Encyclopedia&op=
10:57:42 <lambdabot> content&tid=417
10:57:42 <jethr0_> @google how evil are you?
10:57:45 <lambdabot> http://home.att.net/~slugbutter/evil/
10:57:55 <bolrod> @google return a usefull search result
10:57:57 <lambdabot> http://beeblex.com/search.php?s=l%3Aphp.gtk.dev&o=1
10:57:57 <sieni> @google 1.6 barn megaparsecs in ml
10:57:59 <lambdabot> 1.6 barn megaParsecs = 4.9370884 ml
10:58:25 <bolrod> @goog mass of sun in protons
10:58:27 <lambdabot> http://www.spaceweather.com/
10:58:36 <bolrod> @goog mass Earth in gold
10:58:37 <sieni> @google 1 teaspoon in ml
10:58:38 <lambdabot> http://www.cheatsolution.com/
10:58:39 <lambdabot> 1 US teaspoon = 4.92892161 ml
10:58:53 <bolrod> @goog 1 bucket in teaspoon
10:58:54 <lambdabot> http://middlepath.com.au/qol/householdtips01.php
10:59:08 <bolrod> @goog 1 atom
10:59:10 <lambdabot> http://www.phys.virginia.edu/classes/109N/more_stuff/Applets/Piston/
10:59:10 <lambdabot> jarapplet.html
10:59:19 <bolrod> @goo test
10:59:20 <lambdabot> http://www.test.com/
10:59:22 <bolrod> @g test
10:59:23 <lambdabot> Maybe you meant: gazetteer get-shapr ghc google .
10:59:26 <bolrod> @go ah
10:59:28 <lambdabot> http://www.ah.com/
10:59:29 <bolrod> wicked
10:59:31 <davidhouse> @help ghc
10:59:31 <lambdabot> GHC!
10:59:38 <davidhouse> yes. thanks.
10:59:49 <davidhouse> @ghc foldr (+) 0 [1..10]
10:59:50 <lambdabot>  Malformed constructor signature
10:59:51 <bolrod> hmm..
11:00:06 <bolrod> a recursive search result..  would that be possible?
11:00:19 <bolrod> google does give results of other search engines sometimes
11:00:38 <bolrod> @google search self
11:00:40 <lambdabot> http://anunda.com/self.htm
11:00:59 <bolrod> @google google.com/search?q=google.com/search?q=google
11:01:02 <lambdabot> No Result Found.
11:01:33 <bolrod> who uses McAfee ?
11:01:35 <bolrod> :)
11:16:41 <davidhouse> in ghci, can i :l two modules at once?
11:16:54 <davidhouse> i want to have a module which I'm testing, and another module with some test data in it.
11:17:15 <davidhouse> i don't want to just "let" all the test data because it gets cleared when i :r.
11:18:15 <dcoutts> davidhouse, :m + Foo
11:18:28 <davidhouse> dcoutts, it's on my filesystem. both modules.
11:18:42 <dcoutts> the + means add it to the set of loaded modules
11:18:51 <dcoutts> as in add module Foo
11:18:55 <davidhouse> yes, but i can't use paths in :m.
11:19:04 <dcoutts> oh, perhaps I mean :l + Foo
11:19:11 <davidhouse> and that doesn't work.
11:19:19 <dcoutts> oh, :l Foo Bar
11:19:32 <dcoutts> one of these things works :-)
11:19:44 <davidhouse> awesome. the last is perfect :)
11:27:57 <davidhouse> @pl x > 0 && x < 6 && y > 0 && y < 6
11:27:58 <lambdabot> x > 0 && x < 6 && y > 0 && y < 6
11:28:03 <davidhouse> @pl \x y -> x > 0 && x < 6 && y > 0 && y < 6
11:28:04 <lambdabot> ap ((.) . (&&) . (> 0)) ((. liftM2 (&&) (> 0) (< 6)) . (&&) . (< 6))
11:28:11 <davidhouse> eww. maybe not.
11:29:15 <mauke> heh
11:29:21 <berthold> Hello all, anyone have a moment for a beginner question?
11:32:07 <berthold> I'll shoot it, see if anyone catches.  I'm running GHC 6.4.1 on a Windows XP box.  I'm attempting to get HXT added in, but have gotten stuck at the http library, it configures fine, but when it get's to "Building HTTP-2006.1.15..." GHC crashes.  Any advice?
11:34:10 <davidhouse> @hoogle Int -> Int ->
11:34:10 <lambdabot> hoogle: Hoogle/MatchType.hs:76:8-45: Non-exhaustive patterns in function
11:34:10 <lambdabot> asBound
11:34:10 <lambdabot>  
11:34:13 <davidhouse> @hoogle Int -> Int -> 
11:34:14 <lambdabot> hoogle: Hoogle/MatchType.hs:76:8-45: Non-exhaustive patterns in function
11:34:14 <lambdabot> asBound
11:34:14 <lambdabot>  
11:34:16 <davidhouse> @hoogle Int -> Int -> a
11:34:17 <lambdabot> Graphics.UI.GLUT.Callbacks.Window.TabletPosition :: Int -> Int ->
11:34:17 <lambdabot> TabletPosition
11:34:18 <lambdabot> Graphics.UI.ObjectIO.StdControlDef.ControlHMargin :: Int -> Int ->
11:34:20 <lambdabot> ControlAttribute ls ps
11:34:22 <lambdabot> Graphics.UI.ObjectIO.StdControlDef.ControlItemSpace :: Int -> Int ->
11:34:24 <lambdabot> ControlAttribute ls ps
11:35:16 <davidhouse> @pl \x y -> (read x) + (read y)
11:35:17 <lambdabot> (. read) . (+) . read
11:35:37 <davidhouse> @pl \x y -> (+) (read x) (read y)
11:35:38 <lambdabot> (. read) . (+) . read
11:36:31 <davidhouse> is there a better way of doing this code? http://pastebin.com/600242
11:38:48 <davidhouse> i figure there must be some kind of parsing function which makes it a bit prettier?
11:43:09 <sjanssen> I'm not sure what you want, but have you seen words?
11:43:11 <sjanssen> @type words
11:43:13 <lambdabot> String -> [String]
11:43:23 <davidhouse> hmm... not sure that'd make it nicer.
11:43:54 <sjanssen> x and y are just one character long?
11:44:05 <davidhouse> i'd have to do something like map read $ filter (not.isSpace.head) $ words input
11:44:08 <davidhouse> sjanssen: right.
11:44:58 <sjanssen> oh, there is one easy improvement
11:45:11 <sjanssen> in your pattern match, you can have [x, ' ', y]
11:46:00 <davidhouse> hmm. true.
11:48:56 <sjanssen> this code also doesn't check whether x and y are valid
11:49:02 <davidhouse> no, i realise that.
11:50:42 <davidhouse> is there an easy way of doing that?
11:50:45 <davidhouse> check they can be read?
11:52:10 <davidhouse> (incidentally i should also be using read [x] and read [y])
11:53:00 <sjanssen> what is the type of newPosition?
11:54:05 <davidhouse> (Int, Int) -> [(Int, Int)]
12:17:19 <davidhouse> argh. working in the list monad is driving me crazy :)
12:18:46 <davidhouse> here's what i want to do: i have a board, and some initial co-ordinates. i have a function newPosition::Coords -> [Coords] which returns a list of possible new coordinates for a given pair thereof.
12:19:02 <davidhouse> type Board = Data.Map.Map Coords Int
12:19:07 <davidhouse> type Coords = (Int,Int)
12:19:14 <davidhouse> (it's a 5x5 board)
12:20:24 <davidhouse> right. i want a function that, given some Coords, will generate a list of possible boards. each board consists of the numbers 1 to 25 such that for any k, k + 1 can be found at one of the positions generated by newPosition.
12:21:27 <davidhouse> so the function just needs to find all the valid positions for 2 (as we already know where 1 is placed, the user tells us), then from each of those find all the valid positions for 3, and then for each of those...
12:22:18 <davidhouse> this sounds like a perfect application of the list monad. it's the added complexity of keeping track of the incrementing number which i think is screwing this up. should i try to incoporate State as well?
12:22:36 <mahogny> I would just use a list enumeration
12:24:46 <davidhouse> mahogny: could you expand? i don't think i've heard that term before
12:24:54 <mahogny> ehr
12:25:04 <mahogny> [i |  ... ]?
12:25:10 <mauke> list comprehension?
12:25:13 <mahogny> yeah
12:25:54 <davidhouse> err... how?
12:26:01 <mahogny> some recursive mess
12:26:10 <mahogny> depends. how fast do you want it to be?
12:26:18 <davidhouse> not a problem.
12:26:22 <sjanssen> list monad and list comprehension are the same thing
12:26:44 <sjanssen> and, as far as nesting state in this, I would pass your state explicitly
12:27:14 <sjanssen> the state monad seems like overkill
12:27:33 <davidhouse> yep. okay.
12:29:10 <chris2> i'm looking for an elegant way to parse a html color like "33aaff" into a list of three ints, but i'm not sure how to start
12:29:54 <mahogny> heh. I did a hack yesterday. foo (a:b:c:d:...) = :)
12:30:50 <dcoutts> mwc, sorry I didn't get your gtk2hs xulrunner patch, could you try resending
12:33:15 <mwc> dcoutts, sure
12:34:36 <davidhouse> @index String
12:34:37 <lambdabot> Data.Char, Prelude, Text.Read.Lex, Text.Read
12:35:05 <stepcut> is there a parsec combinator that alternates between two parsers ? something like > alternate1 (char 'a') (char'b') -- that would accept "ababa" "baba" "a" or "b", but not "aab"
12:36:54 <davidhouse> chris2: split it into the first two, the second two, the third two, then parse those as hex digits
12:36:59 <mwc> dcoutts, I think I might not have postfix set up correctly, could I extract the patch and send it manually?
12:37:13 <chris2> davidhouse: and how do i split like that?
12:37:29 <sjanssen> @type take
12:37:30 <lambdabot> forall a. Int -> [a] -> [a]
12:37:34 <dcoutts> mwc, yes use darcs send --output=foo.patch
12:37:39 <dcoutts> and email that file
12:37:55 <davidhouse> i'm not really sure. i guess there's some in built function which takes an index and a length, and returns that many starting from that index.
12:38:23 <chris2> i can do that, but does that mean i need to do it recursively?
12:38:43 <davidhouse> > let midList n len l = drop n $ take (n + len) l in midList 3 2 "aabbcc"
12:38:44 <lambdabot> "bc"
12:38:45 <sieni> stepcut: yes: translate the following regex into a parser: (a?(ba)*|b?(ab)*)
12:38:49 <davidhouse> > let midList n len l = drop n $ take (n + len) l in midList 2 2 "aabbcc"
12:38:51 <lambdabot> "bb"
12:38:55 <sjanssen> chris2: you don't need recursion, a couple lets would do
12:39:13 <davidhouse> sjanssen: is there an inbuilt function for that midList i just defined?
12:39:53 <sjanssen> @type Data.List.splitAt
12:39:54 <lambdabot> forall a. Int -> [a] -> ([a], [a])
12:40:11 <sjanssen> > Data.List.splitAt 2 "aabbcc"
12:40:13 <lambdabot> ("aa","bbcc")
12:40:39 <chris2> mmh. thx
12:40:42 <davidhouse> well, you'd have to write a wrapper func anyway.
12:40:52 <davidhouse> so you might as well use my definition.
12:41:22 <sieni> stepcut: or even a?(ba)*b?
12:42:11 <GeniXPro> mauke, your wierd
12:42:21 <stepcut> sieni: hrm, I will give that a shot
12:43:05 <mauke> GeniXPro: that script is impressive in channels with >50 nicks o_O
12:43:20 <sieni> stepcut: if you need it to match at least one character, then you can use (a(ba)*b?|b(ab)*a?)
12:43:23 <GeniXPro> mauke, you woke everyone up
12:43:39 <mauke> I can see it in the graph :/
12:43:52 <davidhouse> (what did muake do?)
12:43:59 <mauke> I nickflooded ##c++
12:44:18 <stepcut> sieni: thanks.
12:44:22 <mornfall> mauke: you suck
12:44:38 <GeniXPro> he does suck
12:45:04 <sieni> stepcut: no problem
12:46:13 <davidhouse> muake, what, just pinged everyone?
12:47:28 <mauke> no, public messages containing every nick in the channel
12:48:15 <davidhouse> muake, yeah, that's what i mean by "ping". sorry. heh.
12:48:37 <chris2> > map (fst . head . Numeric.readHex) $ takeWhile (/= "") $ List.unfoldr (Just . splitAt 2) "ff00ee00"
12:48:38 <lambdabot> [255,0,238,0]
12:48:40 <mauke> oh, I thought you meant ctcp ping
12:50:42 <hnrgrgr> hi
12:54:44 <araujo> Hello!
12:54:51 <alar> 
12:56:10 <ValarQ> ?
12:56:36 <ValarQ> and what are you doing with the middle section of my nick!
12:56:37 <alar> hi
12:56:43 <alar> =))
12:59:15 <alar> @seen ndm
12:59:16 <lambdabot> I saw ndm leaving #haskell-overflow, #haskell-blah and #haskell 42
12:59:16 <lambdabot> minutes and 48 seconds ago.
12:59:59 <davidhouse> woah
13:00:05 <davidhouse> what's #haskell-overflow for?
13:00:19 <davidhouse> (i figure #haskell-blah is just OT chat, like #not-math)
13:00:26 <bolrod> hm.. I think I got the typing of functions now 8)
13:00:31 <dcoutts> topic: Overflow channel for conversations from #haskell
13:00:36 <bolrod> the types of functions :)
13:02:27 <davidhouse> bolrod: oh yeah?
13:02:34 <davidhouse> so what's the type of zipWith7?
13:02:38 <davidhouse> off the top of your head
13:04:09 <sjanssen> (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]
13:04:37 * sjanssen hopes he counted correctly
13:04:50 <sieni> @type zipWith7
13:04:52 <lambdabot> Not in scope: `zipWith7'
13:04:58 <sieni> :-(
13:04:59 <davidhouse> doesn't it return a list of pairs?
13:05:00 <sjanssen> @type Data.Tuple.zipWith7
13:05:01 <lambdabot> Not in scope: `Data.Tuple.zipWith7'
13:05:08 <davidhouse> @hoogle zipWith
13:05:09 <lambdabot> Data.List.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
13:05:09 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
13:05:09 <lambdabot> Control.Monad.zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [
13:05:09 <lambdabot> c]
13:05:13 <sjanssen> @hoogle (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]
13:05:17 <sieni> @type zipWith4
13:05:18 <lambdabot> Data.List.zipWith7 :: (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b]
13:05:18 <lambdabot> -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]
13:05:19 <lambdabot> Not in scope: `zipWith4'
13:06:00 <davidhouse> @type zip
13:06:01 <lambdabot> forall b a. [a] -> [b] -> [(a, b)]
13:06:07 <davidhouse> @zip zipWith
13:06:08 <lambdabot> Maybe you meant: id map
13:06:14 <davidhouse> @tyoe zipWith
13:06:15 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
13:06:27 <davidhouse> ? it's configured to support typos?
13:06:28 <lambdabot> Maybe you meant: . all-dicts arr babel botsnack choice-add code compose
13:06:28 <lambdabot> devils dice dict dict-help djinn djinn-add djinn-clr djinn-del djinn-env
13:06:28 <lambdabot> djinn-ver docs dummy dynamic-load dynamic-reload dynamic-unload easton
13:06:28 <lambdabot> echo elements elite eurohaskell eval fact fact-cons fact-delete fact-set
13:06:28 <lambdabot> fact-snoc fact-update faq foldoc fortune fptools gazetteer get-shapr ghc
13:06:30 <lambdabot> [8 @more lines]
13:09:22 <bolrod> :)
13:09:39 <bolrod> @ty zipWith
13:09:40 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
13:09:43 <bolrod> ;)
13:09:50 <bolrod> @t zipWith
13:09:51 <lambdabot> Maybe you meant: time todo todo-add todo-delete topic-cons topic-init
13:09:51 <lambdabot> topic-null topic-snoc topic-tail topic-tell type .
13:11:08 <bolrod> yay!
13:12:51 <alar> @arr
13:12:52 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
13:13:54 <davidhouse> @arr
13:13:55 <lambdabot> Shiver me timbers!
13:13:57 <davidhouse> @arr
13:13:58 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
13:14:05 <davidhouse> hehe
13:14:21 <davidhouse> > replicate 10 "@arr"
13:14:22 <lambdabot> ["@arr","@arr","@arr","@arr","@arr","@arr","@arr","@arr","@arr","@arr"]
13:14:32 <davidhouse> aww, that didn't work
13:14:33 <davidhouse> @arr
13:14:34 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
13:14:37 <davidhouse> @arr
13:14:38 <lambdabot> Aye
13:14:49 <bolrod> :)
13:15:05 <bolrod> > show "test"
13:15:07 <lambdabot> "\"test\""
13:15:23 <berthold> Is anyone particularly knowledgable regarding running GHC on windows?
13:15:35 <bolrod> windows.....
13:15:39 <bolrod> Windows!?
13:15:50 <berthold> Windows XP(insult to injury)
13:15:58 <bolrod> @arr
13:15:59 <lambdabot> Har de har har!
13:16:01 <bolrod> :D
13:16:11 <bolrod> @yarr
13:16:12 <lambdabot> Swab the deck!
13:16:16 <bolrod> :)
13:16:18 <bolrod> no
13:16:28 <bolrod> I'm not even knowledgable with running windows
13:16:29 <bolrod> ;p
13:16:44 <davidhouse> berthold: just ask
13:16:55 <sieni> http://en.wikipedia.org/wiki/Cornholio
13:17:35 <berthold> I'm trying to get the http libraries installed but it's consistently crashing during the build stage.  I've got GHC 4.6.1 running at the moment.
13:19:08 <berthold> Pardon my dyslexia, make that version 6.4.1.
13:19:34 <berthold> Has anyone encountered similar problems?
13:21:48 <bolrod> @type zipWith4 ((+).(+))
13:21:50 <lambdabot> Not in scope: `zipWith4'
13:22:13 <davidhouse> @type (+).(+)
13:22:14 <lambdabot> forall a.
13:22:14 <lambdabot>     (Num (a -> a), Num a) =>
13:22:14 <lambdabot>     a -> (a -> a) -> a -> a
13:22:17 <bolrod> :)
13:22:30 <bolrod> @type Data.List.zipWith4 ((+).(+))
13:22:31 <lambdabot> forall d e.
13:22:31 <lambdabot>            (Num ((d -> e) -> d -> e), Num (d -> e)) =>
13:22:31 <lambdabot>            [d -> e] -> [(d -> e) -> d -> e] -> [d -> e] -> [d] -> [e]
13:22:34 <bolrod> :]
13:22:53 <bolrod> I figured it out meself correct.. hmm.. I guess I could try another
13:22:54 <bolrod> :)
13:23:21 <davidhouse> @type (.).(.)
13:23:22 <lambdabot> forall a b c a1.
13:23:22 <lambdabot>     (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
13:23:28 <bolrod> harhar
13:23:32 <bolrod> whats a1 ?
13:23:37 <davidhouse> just another label.
13:23:41 <bolrod> why not d then?
13:23:45 <davidhouse> @hoogle a -> b
13:23:46 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
13:23:46 <lambdabot> Prelude.id :: a -> a
13:23:46 <lambdabot> Prelude.undefined :: a
13:24:48 <davidhouse> ((.).(.)) negate (+) 4 5
13:24:53 <davidhouse> > ((.).(.)) negate (+) 4 5
13:24:55 <lambdabot> -9
13:25:15 <sieni> Ahh, Haskell the booby language
13:25:28 <bolrod> :)
13:25:35 <davidhouse> @type (.Y.)
13:25:36 <lambdabot> parse error on input `)'
13:26:18 <bolrod> hmm.. that I dont get.. 
13:26:20 <sieni> @type (.).(.)
13:26:22 <lambdabot> forall a b c a1.
13:26:22 <lambdabot>     (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
13:26:23 <bolrod> the types with the .
13:26:28 <bolrod> lets see how this works
13:26:39 <davidhouse> @type (.)
13:26:40 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
13:26:58 <davidhouse> (.) group sort "hello world"
13:27:04 <davidhouse> > (.) group sort "hello world"
13:27:05 <lambdabot> [" ","d","e","h","lll","oo","r","w"]
13:27:17 <davidhouse> (group . sort) "hello world"
13:27:34 <bolrod> obviously
13:27:40 <bolrod> hrm
13:27:52 <davidhouse> @type group
13:27:52 <lambdabot> Not in scope: `group'
13:27:58 <davidhouse> @type Data.List.group
13:27:59 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
13:28:03 <davidhouse> @type Data.List.sort
13:28:04 <lambdabot> forall a. (Ord a) => [a] -> [a]
13:28:13 <davidhouse> @type "hello world"
13:28:14 <lambdabot> [Char]
13:30:39 <bolrod> @type ["Hello","world"]
13:30:40 <lambdabot> [[Char]]
13:30:43 <bolrod> hrm
13:30:45 <bolrod> weird
13:30:48 <bolrod> why not [String]
13:30:59 <davidhouse> [Char] is String.
13:31:00 <Yango> is hugs the standard interpreter for linux systemas?
13:31:01 <bolrod> yes
13:31:02 <bolrod> I know
13:31:02 <davidhouse> type String = [Char]
13:31:10 <davidhouse> so why [String]?
13:31:25 <bolrod> 22:30:18 < lambdabot> [[Char]]
13:31:47 <sjanssen> Yango: ghci is used more often
13:31:48 <bolrod> Yango: why not use ghci?
13:32:11 <sjanssen> but hugs will probably work fine for you
13:32:22 <davidhouse> bolrod: yeah.
13:32:30 <davidhouse> why would it want to use [String]?
13:32:51 <Yango> sjanssen, bolrod: because i found hugs on my system :) but given your reaction, I'll probably install ghc
13:33:34 <sjanssen> @type ["Hello" :: String, "world"]
13:33:36 <lambdabot> String, "world"] :: [String]
13:33:54 <Yango>  is ghc the same as ghci?
13:34:03 <sjanssen> ghci is part of ghc
13:34:26 <alar> ghci is ghc --interactive
14:07:46 <sjanssen> somebody reworked the haskell.org frontpage, it looks very nice now
14:42:35 <astrolabe> How do I get [5,4,3,2] using ..?
14:43:16 <Igloo> [5,4..2]
14:43:53 <astrolabe> > [6,5..2]
14:43:54 <lambdabot> [6,5,4,3,2]
14:43:57 <astrolabe> thanks
14:44:51 <ski> > [8,6..2]
14:44:52 <lambdabot> [8,6,4,2]
14:46:53 <resiak> > [1,1,2,3,5..13
14:46:54 <lambdabot>  parse error on input `..'
14:46:56 <resiak> erm...
14:46:58 <resiak> > [1,1,2,3,5..13]
14:46:59 <lambdabot>  parse error on input `..'
14:47:02 <resiak> :-(
15:03:49 <alar> resiak
15:04:05 <alar> [5,4..2] = enumFromThenTo 5 4 2
15:04:22 <resiak> ah, I seee
15:16:05 <sethk> my friend who is in Seattle about?
15:19:09 <sethk> anyone have a url for a very simple hello world type application with FFI?  I'm looking for bare bones, with, say, only one function call with one or two arguments.
15:19:14 <shapr> g'day Pseudonym 
15:19:23 <shapr> sethk: Seen the FFITutorial on the old wiki?
15:19:24 <Pseudonym> G'day.
15:19:26 <Pseudonym> How's things?
15:19:32 <shapr> Pseudonym: Sleepy...
15:19:35 * shapr falls over...
15:19:50 <Pseudonym> Unsurprising.
15:20:11 <sethk> shapr, I don't think  so.  I did see one on the current wiki, which was more complicated than I was looking for
15:20:17 <sethk> shapr, where is the old wiki?
15:21:02 <alar> is there a "private messaging" function in lambdabot?
15:21:18 <araujo> sethk, ive got a simple FFI code for libmagic here arjox.org
15:21:34 <sethk> araujo, thanks, I'm going there now...
15:22:24 <sethk> araujo, I'm there, what am I looking for?
15:24:01 <araujo> sethk, http://www.arjox.org/programs/MagicFile.chs
15:24:17 <sethk> oh, you did say libmagic before, sorry, I didn't see it.
15:24:22 <araujo> sethk, it's in c2hs, but then you can take a look at the .hs
15:24:32 <sethk> araujo, thanks
15:24:35 <alar> and how is the command called?
15:25:07 <araujo> sethk, oh, yes, i named it MagicFile... sorry :-)
15:36:20 <alar> what privilegies do I need to @msg ?
15:37:05 <kosmikus> alar: your nick must be registered
15:37:19 <alar> it is registered
15:37:36 <kosmikus> then it should work
15:37:42 <alar> do I have to register it with lambdabot?
15:38:04 <kosmikus> oh, sorry, I didn't understand you were referring to lambdabot
15:38:34 <alar> can I send msgs with NickServ as well?
15:39:12 <kosmikus> I'm not sure if you can via lambdabot
15:39:22 <alar> @msg
15:39:39 <lambdabot> Not enough privileges
15:39:44 <alar> oh, it can't be used in channel
15:39:50 <alar> no
15:39:52 <alar> it can
15:40:12 <alar> but what privilegies is it talking about?
15:40:43 <jethr0_> alar: "/msg lambdabot > 4+4" works just fine
15:41:27 <jethr0_> or what kind of message do you want to send?
15:41:48 <kosmikus> doesn't work for me
15:41:54 <kosmikus> I also get "not enough privileges"
15:42:01 <alar> offline message to ndm
15:42:21 <alar> I continue to fail to get him in channels 
15:42:50 <jethr0_> ah, didn't know that was implemented in lambdabot yet
15:42:58 <alar> I have one question and he supposedly knows the answer
15:43:29 <jethr0_> any chance i can help or is it a really specific question?
15:44:19 <alar> Are there theorems that machine that always halts can't be used to describe itself?
15:44:30 <alar> Like Epigram can't be made in Epigram
15:44:53 <jethr0_> ahh, yes, that's pretty specific :)
15:45:07 <sethk> alar, a machine that always halts can't describe much of anything at all, except always halting
15:45:21 <jethr0_> but epigram runs on a turing machine. and if epigram is turing complete you should be able to write it in itself
15:46:09 <jethr0_> sethk: primitive recursion is a "machine" that always halts and you can describe a lot with that!
15:46:20 <alar> Epigram can't be Turing-complete because there are some halting guaranties
15:46:27 <jethr0_> ah
15:46:44 <jethr0_> i remember reading that in the paper somewhere
15:46:45 <sethk> jethr0_, well, it does other things besides halting  :)
15:47:10 <jethr0_> sethk: yes, but nobody said _when_ it would halt, only _that_ it would
15:47:29 <sethk> jethr0_, details, details ...
15:47:41 <alar> sethk: can you tell concrete examples of what can't be made on machine that always halt besides TM-emulation? :)
15:47:59 <jethr0_> infinite loops
15:48:16 <jethr0_> unix service daemons
15:48:26 <sethk> alar, the flip answer is, of course, anything that runs forever, which is what jethr0 thought of before me ...
15:48:26 <jethr0_> web servers
15:48:28 <Yango> jethr0_, they can be simulated...
15:48:39 * alar doen't think that infinite loops are of much use
15:48:52 <Yango> jethr0_, for all practical purposes a loop that lasts 4000000 years, is infinite
15:48:57 <jethr0_> alar: web servers are naively infinite loops
15:49:13 <jethr0_> Yango: that's a pragmatic approach :)
15:49:21 * alar agrees with Yango
15:49:59 <jethr0_> in math there's a difference between "limited by N", "arbitrarily large" and "infinite"
15:50:26 <jethr0_> and i can always give you an example that doesn't finish within N computations
15:51:00 * alar thinks that probably the best implementation for forever-running server would be program_that_always_halt embedded in infinite loop
15:51:29 <alar> because that guarantees finite responce time
15:52:11 <alar> I don't think someone wishes that his request wouls be handled in infinite time
15:52:47 <jethr0_> alar there's a difference between "bounded by N" and "arbitrarily large"
15:54:16 <alar> jethr0: but anything that is bounded_by_N is definitely _not_arbitrarily_large
15:54:26 * Yango the pragmatic asks: "Who cares?"
15:54:48 <jethr0_> Yango: i supposed you're no CS academic ^_^
15:55:13 * alar is not CS academic too :)
15:55:22 <sethk> pragmatist
15:55:27 <Yango> I've taught at (and stuidied in) some CS departments! *blush*
15:55:28 <jethr0_> in that vein you can ask "who cares about the difference between O(n^2) and O(n) with a large constant factor"
15:55:30 <sethk> pragmatic is an adjective
15:55:43 <Yango> jethr0_, that's not at all the same!
15:56:06 <jethr0_> that would be a pragmatic approach with a given time frame!
15:57:03 <Yango> well, the 'large' constant factor... is it bounded, arbitrarily large, or infinite? 
15:57:04 <jethr0_> and a given input size
15:57:17 <jethr0_> same as your 4000000 years
15:57:55 <Yango> thanks, sethk
15:58:02 * alar is afraid of meeting infinite constant factor in a nightmare
15:58:28 <jethr0_> an infinite constant factor would easily superseed any polynomic factor inside the O
15:58:46 <alar> how?
15:58:48 <jethr0_> it would just become O(oo)
15:58:55 <tromp> ppl talking so much nonsense here...
15:58:59 <Yango> sure... and in that case who cares about O(n) or O(n^2)
15:59:09 <jethr0_> tromp: pls correct me if i'm wrong
15:59:37 <tromp> there'a no such thing as an unbounded constant
16:00:14 <jethr0_> i never said that.
16:00:45 <tromp> then dont talk about infinite constants
16:00:58 <jethr0_> didn't bring that one up either
16:01:29 <Yango> jethr0_, a loop that has to last forever (or not) will not conduce people to write better or worse algorithms. OTOH, caring about O() will
16:01:53 <jethr0_> i was just trying to make an analogy that if you say "4000000 years is infinity for all practical purposes" you could also apply a similar argument to large  constants in "O(n^2) vs O(n)"
16:02:39 <Yango> jethr0_, and you can, if your constant is arbitrarily large :), if it's bounded, you cannot
16:03:06 <MarcWeber> Has anyone of you tried to use wash, yet? I can't compile. ghc hangs on HTMLMonad98.hs.. (or it needs hours..) ?
16:03:08 <jethr0_> now that i've lost tromp's respect i'm gonna go to bed :)
16:03:26 <tromp> i have a short memory:)
16:03:47 <tromp> tomorrow i'll have forgotten who mentioned infinite constants
16:04:14 <alar> tromp: assume it was me :)
16:06:12 <jethr0_> tromp: arbitrarily large constants are not altogether stupid though
16:06:58 <jethr0_> it should be valid to argue that "O(n^2) > O(N*n)" with an arbitrarily large N and n->infinity, no?
16:09:22 <mwc> jethr0_, N is constant?
16:09:31 <Cale> It's just a matter of which n are practically required. It might be a good idea to combine two algorithms so as to use the one with the lower constant factor for small cases, and switch to one with better asymptotic complexity as the problem size increases
16:09:36 <jethr0_> mwc: constant in "n", yes
16:11:05 <mwc> jethr0_, i'd argue that they aren't the same; their asymptotic behaviour is entirely different. But then I'm a math person
16:11:19 <mwc> perhaps as N goes to infinity
16:11:28 <jethr0_> "aren't the same"?
16:11:39 <mwc> O(nn) vs O(Nn)
16:11:53 <jethr0_> i was arguing that O(n^2) would be greater
16:12:30 <Cale> well, they're not really comparable
16:12:35 <mwc> Oh, yhes, absolutely
16:12:46 <Cale> if we hold N fixed, then n^2 grows faster, sure
16:12:58 <jethr0_> k
16:13:12 <jethr0_> that's what arbitrarily large means, i thought
16:13:15 <mwc> then you have to decide if N or n grows faster :P
16:13:23 <alar> Cale: if N is constant then we hold it fixed 
16:13:36 <mwc> alar, trust me, Cale knows
16:13:43 <MarcWeber> tromp: Thats why logfiles exist ;-))
16:13:58 <jethr0_> this is getting too abstruse for me. math is so much more precise than semi-CS arguments ^_^
16:14:03 <Cale> alar: It just wasn't clear that N actually was a constant.
16:14:29 <mwc> it's not a function of n is what we've stated, afaik
16:14:36 <Cale> right
16:14:54 <jethr0_> that should suffice for the complexity comparison
16:16:17 <Cale> It's sort of like saying that f < g, when f is a function of two parameters and g is a function of only one. You kind of have to be clear about what you mean :)
16:17:46 <jethr0_> if "N" is not a function of "n" then it's constant in variance of "n" and that's all we're looking at in this case, IMO
16:18:28 <vincenz> I've said it before and I'll say it again
16:18:34 <vincenz> The O-notation is seriously useless
16:18:38 <jethr0_> that's always a good introduction
16:18:43 <vincenz> :)
16:18:54 <jethr0_> vincenz: that's not true. it's just complexity theory taught to CSsers that's pretty ambiguous
16:19:09 <vincenz> ambiguous and out of touch
16:19:10 <jethr0_> and poorly defined
16:19:10 <Yango> jethr0_, did you get what I meant? What Cale said is what I mean, the phrase starting with "It's just a matter"
16:19:24 <vincenz> be cool to make a language starting from CT
16:19:25 <vincenz> :D
16:20:38 <jethr0_> Yango: i think we're just on very different grounds. 4m years might be a long time, but one shouldn't speak lightly of "infinity"!
16:21:25 <Cale> jethr0_: the confusion was mostly because if you hold n fixed and vary N, you can always get nN > n^2
16:21:30 <Yango> jethr0_, you just missed the part "for all practical purposes". I didn't mean to offend infinity or you :)
16:21:37 <jethr0_> if you see the universe as a big computer, an abort after 4m years would have wrecked the whole "program" before even heavy elements formed (i think)
16:21:45 <vincenz> besides O(a) and O(b) are not comparable
16:22:00 <jethr0_> i'm hard to offend
16:22:15 <jethr0_> vincenz: i'm pretty sure there's an order defined on complexity classes
16:22:24 <Yango> jethr0_, and you can add to the practical purposes: " on earth, for humans, at this time " :)
16:22:24 <vincenz> jethr0_: not if you're comparing n1 and n2
16:22:35 <jethr0_> vincenz: i didn't mean to
16:23:22 <jethr0_> Cale: i'm aware of that. i should've been more precise.
16:25:53 <vincenz> heh 
16:26:02 <vincenz> for some reason I often get a filed named "plop" in my /home/vincenz
16:26:04 <vincenz> that's empty
16:26:14 <vincenz> but I don't' know where it's coming from!
16:26:30 <jethr0_> try "lsof" and hope that the program is still open
16:26:38 * vincenz deleted the file
16:27:01 <vincenz> wooah
16:27:02 <vincenz> bug!
16:27:08 <vincenz> lsof works fine
16:27:11 <vincenz> lsof | grep plop
16:27:22 <vincenz> lsof: WARNING: can't stat() reiserfs file system /dev/.static/dev Output information may be incomplete.
16:27:41 <vincenz> yay for non orthogonality
16:28:04 <jethr0_> grep just works on the output stream of lsof. i don't see how that should come about
16:28:20 <vincenz> yeah I know
16:28:23 <vincenz> which makes it so odd
16:29:54 * vincenz is a freecell-addict
16:42:11 <palomer> :o
16:46:41 <dons> moin
16:47:29 <palomer> ugh
16:47:42 <palomer> I presented my dynamic typing proposal to my 2 profs, they didn't like it
16:48:35 <jethr0_> palomer: dynamic typing?
16:48:57 <alar> what do you propose to type dynamically?
16:50:59 <palomer> terms
16:51:04 <palomer> standard stuff
16:51:08 <palomer> now I'm going to have to rewrite it
16:51:37 <vincenz> palomer: phd student
16:51:37 <vincenz> ?
16:51:54 <palomer> no, masters
16:52:06 <palomer> though I could most certainly turn this into a PhD thesis
16:54:29 <palomer> hrm
16:54:40 * palomer wonders why we only generalize types at let bindings
16:54:47 <palomer> why not generalize everywhere we can?
17:04:09 * vincenz is off
17:10:01 <jberg> what do you use as a developer enviroment for haskell?
17:10:44 <dons> vim or emacs, usually, and a shell running ghci
17:11:17 <jberg> ok. so there are nice haskell modes for both vim and emacs?
17:11:21 * araujo wanna use a haskell editor......
17:11:37 <dons> other useful things to do are: use hasktags to tag all the standard libraries, get familiar with lambdabot, install the standard library docs on your machine
17:11:55 <dons> yes, I think emacs has quite a reasonable mode, and vim does nice syn hl (if I do say so myself)
17:12:29 <jberg> ok, i will, thanks
17:12:41 <dons> there's a small minority using things like eclipse or visual studio -- the latter has a very sophisticated haskell mode, if you're into big ides like that
17:13:12 <dons> I would suspect though that 95% of people here use emacs or vim, and ghci
17:14:34 * araujo uses emacs+(ghci+lambdabot)+ghc
17:14:54 * xanavim uses emacs *and* vim
17:15:05 * dons uses vim+(ghci+lambdabot)+ghc+hasktags
17:15:10 <araujo> though i'd be happy of using some haskell editor :-]
17:15:22 <dons> and lambdabot should be an editor module
17:15:25 <dons> :)
17:15:28 <araujo> yay!
17:15:29 <alar> araujo: there's hIDE project
17:15:37 <araujo> alar, yeah, i know
17:15:43 <dons> and yi :) don't forget yi
17:15:51 <araujo> of course!
17:15:53 <alar> I'm not sure whether it is alive
17:15:59 <dons> I am sure.
17:16:01 <dons> @where yi
17:16:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
17:16:04 <dons> ^^ it's alive!!
17:16:09 <alar> I mean hIDE
17:16:14 <dons> oh, it's also alive
17:16:33 <dons>  Lemmih patched some cool things very recently, and is now improving the ghc interface
17:16:47 <dons> but, as always, it's a part-time job
17:17:06 <araujo> nice, i didn't know
17:18:37 <dons> @quit new code
17:18:48 <dons> \version
17:19:06 <lambdabot> lambdabot 3p324, GHC 6.4.1 (Linux i686 3.20GHz)
17:19:08 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:19:13 <dons> ? lambdabot should ignore this test
17:19:25 <dons> ?but not this
17:19:29 <dons> hey!
17:19:52 <dons> what happened there?
17:20:24 <dons> ?but might be"quit"?
17:20:31 <dons> yes.
17:20:31 <araujo> dons, but i pretty much like that lambdabot editor module idea
17:22:36 <dons> yeah, we've basically been developing an irc-based ide, so it should move to an editor frontend as well
17:34:12 <xanavim> an irc-based ide?  0_o
17:42:43 <Aphex_Twin> what does the $ operator do in haskell?
17:43:23 <alar> composition
17:43:31 <alar> like . but more fun
17:44:26 <alar> length $ filter (/='l') "Hello world"
17:44:51 <alar> instead of length (filter (/= 'l') "Hello world")
17:45:06 <gzl> simple example:
17:45:08 <gzl> > (+1) $ 2
17:45:09 <lambdabot> 3
17:45:13 <alar> Less Idiotic Silly Parentheses
17:45:22 <dons> > (+1) `id` 2 -- also works :)
17:45:23 <lambdabot> 3
17:46:04 <gzl> ok, maybe it was too simple. :)
17:46:35 <dons> the operator does nothing except remove the need for extra parenthesis
17:46:46 <dons> we should have a lambbdabot command to answer this :)
17:46:53 <dons> such as @whatdoes$do?
17:47:04 <gzl> or just @$
17:47:19 <dons> which would be equivalent to $$ ;)
17:47:24 <dons> $bot
17:47:31 <dons> or did I disable that?
17:47:35 <gzl> wait, what?
17:47:46 <dons> ah yes, I turned it off
17:47:52 <dons> &bot
17:47:53 <lambdabot> :)
17:47:54 <dons> %bot
17:47:55 <lambdabot> :)
17:47:58 <dons> ?bot
17:47:58 <lambdabot> :)
17:48:00 <gzl> oh, why do you have that?
17:48:02 <dons> so you could have ?$
17:48:05 <dons> \bot
17:48:05 <lambdabot> :)
17:48:11 <dons> ^^ I think that is the nicer option
17:48:22 <dons> just trying out some alternatives to the "heavy" @ syntax
17:48:40 <dons> I prefer ? or \ to introduce commands, but so far it hasn't caught on.
17:48:44 <dons> ?uptime
17:48:45 <lambdabot> uptime: 28 minutes and 19 seconds
17:48:48 <dons> ?google lambdabot
17:48:51 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
17:48:55 <dons> or the more latex-ish
17:49:02 <dons> \wiki Lambdabot
17:49:03 <lambdabot> http://www.haskell.org/haskellwiki/Lambdabot
17:49:17 <dons> gzl, what do you think?
17:49:50 <dons> I did have $ too, but people posted perl code and lambdabot got confused, then frustrated, then annoying
17:49:58 <gzl> I dunno. the bot standard is !. I like @. I've seen ? for a bot that has to coexist with a bot that accepts !commands. not a fan of \, but I get your point with the LaTeX thing.
17:50:35 <dons> yeah, ! would also be acceptable. a bit vi-ish. but we want to be different :)
17:50:50 <dons> I actually wanted: .type foo
17:50:55 <dons> but that clashed with peopletyping ellipsis
17:50:59 <dons> ... what?
17:51:11 <dons> .type map -- looks so nice
17:51:44 <alar> what about :t 1+1 ?
17:51:59 <alar> like that of ghci
17:52:09 <dons> hmm, would ':' clash with everyday text i wonder?
17:52:21 <alar> oh, yes
17:52:24 <dons> maybe I'll enable ! and : to see
17:52:26 <jethr0_> smileys to no end
17:52:27 <alar> that'll clash with smiles
17:52:28 * dons checks the logs
17:52:33 <dons> ah yes that was the reason
17:52:44 <jethr0_> i like \ too. it just takes time to adopt
17:53:06 <dons> I think the '?' is nice. I feel like i'm asking a question when I type it :)
17:53:14 <dons> but \ looks nice visually
17:53:24 <jethr0_> \vixen hello
17:53:26 <lambdabot> how're you?
17:53:47 <MarcWeber> Any idea whats going wrong here? (make system of wash) http://www.rafb.net/paste/results/VSpJJo52.html
17:53:55 <jethr0_> k. good night #haskell
17:54:00 <dons> oh fun the _make_ system
17:54:04 <dons> ;)
17:54:29 <dons> hmm, MarcWeber, could it be a broken line continuation ending in \
17:54:30 <dons> ?
17:54:53 <MarcWeber> It could.. Let me see
17:55:13 <dons> it must be the line just after the call to ghc, so you should be able to narrow it down
18:12:13 <MarcWeber> There is this: 
18:12:13 <MarcWeber> %o: %.o
18:12:13 <MarcWeber>      @\:
18:12:13 <MarcWeber> This must be the reason. Why do they escape :? .. Thanks dons, solved!
18:12:15 <lambdabot> Maybe you meant: . id pl wn yow
18:14:28 <MarcWeber> pesco:  Thanks for your cmdline lib!
18:14:48 <palomer> ho hum
18:14:58 <palomer> I'm too lazy to prove progress and preservation
18:19:41 <dons> weird. that should definiting be @:  -- a non-echoing empty statement, right?
18:19:56 <MarcWeber> dons I think so...
18:24:15 <include> Hi.  I'm new to Haskell, and just have a quick comparison.  I'm writing a polymorphic function which takes a list [a] (which I'll call 'l').  I need to compare (greater than comparison) head l with head (drop 1 l).  Unfortunately, I can't seem to find a way to do this properly
18:25:13 <gzl> ?
18:25:27 <gzl> f l = head l > head (drop 1 l)
18:25:28 <gzl> that's it
18:25:29 <dons> > let f [] = False ; f (x:[]) = False ; f (x:y:_) = x == y in f [2,2,7,9]
18:25:30 <lambdabot> True
18:25:35 <gzl> bah. fine.
18:25:39 <dons> oh, sorry, > not ==
18:25:51 <MarcWeber> include:  comp a:b:xs= a > b ?
18:26:14 <dons> and as I wrote above, you better handle [] lists and lists of 1 element too..
18:26:38 <gzl> yeah. ignore my thing.
18:26:41 <gzl> spoke too soon.
18:26:42 <dons> does that code make sense, include?
18:26:50 <gzl> obviously today is a total writeoff. two stupid errors. :)
18:27:30 <dons> include, rather than calling head explictly, pattern match on the elements you want: thus, f (x:y:_) = x > y -- does that make sense?
18:27:51 <alar> gzl isn't your code equivalent to f a:b:xs = a > b ?
18:28:09 <gzl> yes
18:28:27 <gzl> I only wrote it that way because I wasn't sure what he thought wasn't working in his definition.
18:28:43 <MarcWeber> I've never meat a file taking so long to compile..
18:28:46 <gzl> I mean, the code he wrote is fine, but it doesn't handle [] and singletons.
18:28:51 <alar> gzl then what do you call "errors"?
18:29:07 <gzl> I call them errors. I'm not sure what you're asking.
18:29:14 <dons> include, and as a general technique, it's useful to write these functions by proceeding `by induction' on the structure of the list. so handle the empty list, then the list of 1 eleme, then the list of two elems. 
18:29:45 <dons> especially important when writing recursive functions :)
18:29:47 <include> dons, right.  I've got the trivial cases written (as you said, where length l == 1 and 0)
18:30:04 <dons> and do you use pattern matching, or length and head?
18:30:19 <alar> sometimes I leave trivial cases uncovered as "assertions"
18:30:40 <gzl> alar: I'm not sure what you're getting at. I answered too quickly and missed the point of the question.
18:30:40 <dons> alar, hmm interesting. so not even a f _ = error "foo" ?
18:30:45 <include> I'm just testing with length l
18:30:49 <alar> when I don't want them to appear
18:31:19 <alar> dons: error foo is undoubtely better
18:31:34 <dons> include, probably the idiomatic way is to write:
18:31:35 <dons> f []      = False
18:31:35 <dons> f [_]     = False
18:31:35 <dons> f (x:y:_) = x > y
18:31:43 <dons> very simple, and efficient
18:32:26 * dons -> disappears
18:32:37 <include> thanks, dons.  I've more to do with the tail of the list after y.  Instead of using a wildcard '_', can I assign the entire tail to an identifier?
18:32:56 <Cale> include: right
18:33:10 <Cale> also, you can do the obvious thing which you said
18:33:17 * MarcWeber is still waiting for ghc to finish compiling HTMLMonad98.hs
18:33:45 <Cale> (if you don't like pattern matching, it's possible to just apply head and drop 1, etc.
18:33:45 <Cale> )
18:33:52 <Cale> though pattern matching is nice here :)
18:34:38 <include> yes, much cleaner.  I apologize for the simple questions--It's been hard on me to switch from an imperative paradigm to functional
18:36:10 <MarcWeber> include: It will be for some time .. ;) I'm trying this for some month now ;) Just keep on reading suff and asking ;)
18:36:20 <Cale> that's common, and it's also what we're here for :)
18:36:48 <alar> It took me more than year to move from imperative paradigm
18:37:44 * alar thinks it is nice to learn Haskell as the first language
18:42:30 <_frederi1_> there's no equivalent of say "perldoc" for haskell, is there?
18:42:40 <_frederi1_> i mean people just use the html...
18:43:56 <include> ahg.  So I'm taking your (collectively) advice and using pattern matching instead of head/drop/etc, which is certainly a lot easier on the eyes.  This should be a valid expression in my eyes: "(x:y:_) = if x > y then x else y", however, some "Ord a" constraint is not justified in an explicitly typed binding.  Again, I apologize; not quite sure what to make of the message
18:44:37 <alar> include: > is only defined on types which are Ord members
18:45:11 <include> ah, okay
18:45:12 <alar> you've probably given explicit type signature to your function?
18:47:16 <include> I suppose I am (f :: [a] -> a)
18:47:46 <alar> compiler says it's f::Ord a=> [a] -> a
18:48:25 <alar> because the type of (>) is Ord a=> a -> a -> Bool
18:49:21 <alar> you there was no explicit signature compiler would infer proper type
18:49:48 <include> I see
18:49:56 <alar> but I think it is good practice for newbies to put explicit type signature
18:50:11 <alar> I put them most of the time
18:51:39 <include> right; in the case of the small function in question, the explicit type sig is preventing the compiler from infering the right type, then, as you say?
18:56:22 <Cale> well, the compiler is inferring the right type, and finding it doesn't agree with your type, and that's an error
18:57:32 <include> okay, I see; since it's a general type it's not necesarily a member of Ord (which is required for the comparison), and thus the error?
18:57:41 <Cale> right
18:58:06 <include> so if I change the signature to require a to be a member of Ord it should go through, then, I assume?
18:58:08 <alar> if your type was narrower than inferred one that would be ok, but if it is wider compiler doesn't know how to handle it
18:58:17 <Cale> include: yeah
18:58:34 <include> okay, makes perfect sense
19:03:18 <aFlag> is there a function for finding a string within a string and substituting it for other?
19:03:37 <aFlag> because i don't seem to find one
19:05:50 <Lemmih> aFlag: Nope.
19:06:29 <aFlag> ok, thanks
19:08:51 <alar> Can someone help me with type theory notation?
19:09:11 <alar> I do not understand what those strange glyph mean :(
19:09:16 <alar> glyphs
19:16:01 <Cale> which ones?
19:16:26 <Cale> I don't know too much type theory, but I can probably recognise some of the symbols :)
19:19:02 <alar> the one resembling + without left -
19:20:05 <alar> and + without right - too :)
19:21:15 <aFlag> what about the _|_ one? On haskell 98 report it says: Errors in Haskell are semantically equivalent to _|_. What's that?
19:27:36 <cpatrick> aFlag: _|_ is 'bottom', or a computation that doesn't terminate
19:27:46 <cpatrick> e.g. "let bot = bot in bot"
19:27:56 <cpatrick> > let bot = bot in bot
19:27:57 <lambdabot> Add a type signature
19:28:08 <cpatrick> > let bot :: Int; bot = bot in bot
19:28:09 <lambdabot> Terminated
19:30:05 <aFlag> i see, thanks
19:30:22 <alar> what abot _|_ rotated 90 degrees clockwise?
19:33:32 <sethk> how can a computation that doesn't terminate be terminated?
19:34:45 <alar> sethk: "terminated" means it did not terminate normally
19:35:01 <alar> and was terminated by time-limiting system or something
19:36:59 <dons> _frederi1_, yes, it's called haddock
19:37:12 <dons> it generates the html documentation used in the libraries, for example
19:37:14 <dons> @docs Data.List
19:37:15 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
19:41:25 <aFlag> cpatrick: if you don't mind answering, what's that "in" syntax? as in "bot = bot in bot"
19:42:28 <Lemmih> aFlag: It's a part of the 'let' expression.
19:42:44 <dons> let ident = expr in expr
19:43:06 <dons> let x = e1 in e2 =~ (\x.e2) e1
19:43:09 <dons> if that helps :)
19:43:20 <dons> it binds 'x' to e1, visible in e2
19:43:45 <dons> roughly similar to a 'where' clause: e2 where x = e1
19:44:06 <aFlag> oh, i see
19:44:49 <dons> in many of the haskell textbooks, let is never used. however, most binding forms translate into `let' underneath
19:44:51 <araujo> @index find
19:44:52 <lambdabot> Data.List
19:44:59 <araujo> @hoogle find
19:45:00 <lambdabot> Data.List.find :: (a -> Bool) -> [a] -> Maybe a
19:45:00 <lambdabot> Data.IntMap.findWithDefault :: a -> Key -> IntMap a -> a
19:45:00 <lambdabot> Data.List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
19:46:11 <araujo> dons, interesting.. ive also noticed that... any reason?
19:46:16 <mwc> Using my first monad transformer, embedding a Maybe inside a StateT. How do I return "nothing"
19:46:26 <alar> let is used in standard Prelude
19:46:30 <mwc> StateT WalkState Maybe gi
19:46:46 <dons> araujo, noticed what, that 'let' isn't used in introductory textbooks/
19:46:47 <dons> ?
19:47:15 <mwc> do I need to use nested monads instead?
19:47:27 <araujo> dons, yes
19:47:32 <dons> it's common in code written by experienced haskellers, as it has a precise operational effect, however for beginners, 'where' is preferred due to its clarity, and nice "mathematical" feel
19:47:48 <dons> 'case' too is never introduced to beginners, but used all the time by hackers
19:47:54 <dons> even moreso than 'let'
19:48:19 <araujo> yes, very clear when you take any code out there and compare with most of the textbooks
19:48:54 <dons> textbooks use guards a lot too, which aren't so common. 
19:49:35 * alar doesn't clearly understand the difference between let and where
19:49:55 <mwc> If I want to perform a stateful computation that may fail, should I use StateT StateType Maybe RType, or should I be using State StateType (Maybe RType)? I don't quite understand the difference between them
19:50:31 <araujo> alar, they both introduce local bindings to a function
19:50:32 <cpatrick> alar: only the syntax - let lets you put your variable=value assignments before the expression using them, where lets you put them after the expression
19:51:09 <dons> 'where' isn't an expression form.
19:51:11 <palomer> MaybeT State and StateT Maybe are pretty similar
19:51:13 <cpatrick> I tend to use "where" and guards quite a lot, but I'm no dons-level experienced haskeller :-)
19:51:20 <dons> you can't say: if True then where ... 
19:51:27 <dons> but you can say: if True then let x = 1 in 2
19:51:37 <mwc> Well, even if the computation fails, there's still valid state, so I know that the State needs to be the "outer" monad
19:51:44 <eivuokko> Scoping is diffrent for let and where.  Let is in itself an expression, and let foo in bar, foo is visiable in bar, while where scopes to up to maing level binding
19:51:48 <palomer> where comes after a binding, I believe
19:51:53 <alar> dons: what is where? sugar?
19:52:02 <dons> it's sugar for 'let' :)
19:52:12 <eivuokko> Isn't let sugar for lambda?
19:52:17 <dons> everything is sugar for let, case, application or lambda
19:52:30 <dons> no, let is primitive, it allocates a suspended computation on the heap
19:52:36 <eivuokko> Hmm.
19:52:47 <eivuokko> Gotta think over it, good point.
19:52:47 <cpatrick> eivuokko: I don't think so in haskell, but it is in strict languages
19:52:51 <dons> but in lambda calculus, of course, it is sugar for a lambda
19:53:18 <araujo> yup, pretty much the same than in lisp-like dialects
19:53:37 * alar has to go
19:53:52 <dons> and 'case' is the primitive evaluate-to-whnf and scrutinise/pattern-match the constructors operation.
19:54:05 <dons> all patterns and guards translate to 'case'
19:54:06 <palomer> case is fun
19:54:21 <cpatrick> dons: so is "seq x y" equivalent to "case x of _ -> y" ?
19:54:35 <palomer> does if translate to case?
19:54:52 <dons> no, since 'seq' will force the value, but that wildcard won't.
19:54:53 <cpatrick> palomer: pretty sure it's case expr of True -> blah; False -> blah
19:54:59 <dons> if is sugar for case True ; False , yep.
19:55:06 <dons> it's defined as such in the report
19:55:11 <dons> and also in ghc
19:56:15 <cpatrick> dons: ahh right, so 'seq' has to be magic because case only forces evaluation sometimes?
19:56:34 <dons> let's see if we can construct an example
19:56:44 <dons> > case (1,undefined) of x  -> fst x
19:56:45 <lambdabot> 1
19:57:00 <dons> > let x = (1,undefined) in x `seq` fst x
19:57:02 <lambdabot> 1
19:57:08 <dons> hmm thinking...
19:57:16 <cpatrick> > case undefined of x -> 42
19:57:17 <lambdabot> 42
19:57:25 <dons> > undefined `seq` 42
19:57:27 <lambdabot> Undefined
19:57:29 <dons> of course :)
19:57:45 <dons> "case forces evaluation to normal form, not always" :)
19:59:53 <palomer> doesn't case force as much as is needed?
20:00:06 <dons> it'll force to the outer most constructor, in the pattern
20:00:16 <dons> so, yes :)
20:00:18 <eivuokko> let x = foo in y x;  (\x' -> case x' of x -> y x) foo  <- couldn't you desugar let that way to preserve pattern match laziness?
20:00:24 <Saulzar> > case undefined of (x, _) -> 42
20:00:25 <lambdabot> Undefined
20:00:44 <palomer> > case undefined of x -> x
20:00:45 <lambdabot> Add a type signature
20:00:47 <palomer> > case undefined of x -> 4
20:00:48 <lambdabot> 4
20:01:06 <palomer> my prof wants me to use subversion instead of darcs
20:01:10 <palomer> I don't know what to tell her
20:01:22 <dons> eivuokko ,yes, but then the virtual machine would need to do much more work working out when to allocate thunks
20:01:35 <dons> so better to distinguish them with their own syntactic form, I think
20:01:43 <dons> it's in the STG paper
20:01:57 <eivuokko> dons, Sure.  Of course let is primitive on compiler.
20:02:10 <eivuokko> dons, But I thought in ... theory or whatever
20:02:13 <palomer> let is primitive?
20:02:39 <eivuokko> You'd need such structure to do any sensible optimisations anyway
20:02:55 <cpatrick> eivuokko: That wouldn't work for `let Just x = foo in f x` though
20:03:03 <cpatrick> Hmm, or can you pattern match in lambdas?
20:03:22 <dons> yes
20:03:25 <eivuokko> cpatrick, my case was supposed to move pattern match like that
20:03:37 <cpatrick> > (\Just x -> x) (Nothing)
20:03:38 <lambdabot>   Constructor `Just' should have 1 argument, but has been given 0
20:03:38 <lambdabot>   When checking the pattern: Just
20:03:38 <lambdabot>   In a lambda abstraction: \ Just x -> x
20:03:59 <cpatrick> > (\(Just x) -> x) (Nothing)
20:04:00 <lambdabot> Add a type signature
20:04:03 <eivuokko> > (\(Just x) -> x) Nothing
20:04:04 <lambdabot> Add a type signature
20:04:07 <cpatrick> > (\(Just x) -> 2) (Nothing)
20:04:08 <lambdabot>  Non-exhaustive patterns in lambda
20:08:11 <mwc> lift $ Nothing, does that make sense in the context of a StateT SType Maybe RType if I want to have a stateful computation not return a value?
20:08:18 <mwc> lift Nothing I guess
20:09:07 <Saulzar> Looks right
20:51:01 <palomer> whew, I've done more thinking today than is healthy
21:44:41 <Saulzar> What's the advantage of the fgl Data.Graph.Inductive stuff over Data.Graph? Data.Graph looks somewhat simpler and more consistent... 
21:51:37 <MarcWeber> Saulzar. I don't know, yet. On the homepage of fgl there is a pdf describing the fgl... Perhars that can also help you. I haven't managed to read the Data.Graph code yet
22:38:47 * shapr yodels cheerfully
22:39:01 <shapr> Good morning #haskell!
22:45:17 <adu> morning
22:45:54 <shapr> Wassup?
22:49:01 <adu> not much
22:49:06 <adu> still learning haskell
22:49:21 <adu> i think i got type-classes understood
22:49:34 <adu> but i'm still trying to understand monads
22:49:38 <dons> Saulzar, flg is lazy and normal graph uses arrays. so fgl can handle big graphs with less memory overhead, iirc
22:49:49 <dons> we could only use fgl in last years icfp contest, i seem to recall
22:50:28 <Saulzar> Hmm
22:51:25 <Saulzar> I'm using tiny graphs, perhaps 5x5 grids .. was looking at maze algorithms for generating maps
22:56:40 <adu> what can I do to an IO monad that is a good tutorial about monads in general?
22:57:08 <qwr> http://www.nomaware.com/monads/html/meet.html
22:57:42 <qwr> http://www.nomaware.com/monads/html/
23:01:23 <dons> adu, do it  it?
23:01:28 <dons> hit it on the head ? :)
23:02:22 <adu> is there any difference between "a `op` b = a %% b" and "op = (%%)"?
23:04:10 <qwr> imho, no.
23:05:07 <adu> about the return method in the class Monad, given a type 'a' how does it know what kind of 'm' to wrap around it?
23:05:10 <dons> the latter is clearer?
23:05:10 <Cale> one is a function binding and the other is a pattern binding
23:05:42 <adu> oh
23:05:58 <ibid> the former will not trip the monomorphism restriction, the latter might, depending
23:06:11 <Cale> adu: context
23:08:12 <adu> so does 'return' only appear after >>= or >> ?
23:08:12 <Cale> adu: obviously, if you use 'putStrLn', m will have to be the IO monad.
23:08:12 <ibid> adu: not always
23:08:12 <Cale> > return 5 :: Maybe Integer
23:08:12 <lambdabot> Just 5
23:08:12 <Saulzar> adu, It can infer the type of return from a type signature in the same way
23:08:13 <Cale> > return 5 >>= fmap (+1) :: Maybe Integer
23:08:13 <lambdabot>  add an instance declaration for (Num (Maybe Integer))
23:08:13 <Saulzar> As Cale demonstrates :)
23:08:13 <adu> > return "text"
23:08:13 <lambdabot>  add an instance declaration for (Show (m [Char]))
23:08:13 <Cale> er... sorry
23:08:33 <Cale> > return 5 >>= \x -> Just (x+1)
23:08:35 <lambdabot> Just 6
23:08:43 <Cale> > fmap (+1) (return 5)
23:08:44 <lambdabot>  add an instance declaration for (Show (m a))
23:08:49 <Cale> > fmap (+1) (return 5) :: Maybe Integer
23:08:50 <lambdabot> Just 6
23:09:25 <dons> Cale, do youu think there's anything useful you can do with a constructor that looks like: data D = D (forall a. C a => a) ?
23:09:43 <ibid> > fmap (+1) (return 5) :: [Integer]
23:09:44 <lambdabot> [6]
23:10:56 <adu> so do you have to to :: C T to use a particular instance of a method in the class C?
23:11:49 <ibid> adu: generally not, but this is a special case because it's not part of a larger program that would give you the context
23:12:13 <adu> ok
23:13:11 <ibid> > [9,9,9,9,9] >>= fmap (+1) (return 5)
23:13:12 <lambdabot>  add an instance declaration for (Num [b])
23:13:17 <ibid> grr
23:13:28 <ibid> why can't > use defaulting!
23:13:31 <adu> yey i'm not the only one saying 'grr'
23:13:41 <adu> :)
23:13:43 <ibid> > [9 :: Integer,9,9,9,9] >>= fmap (+1) (return 5)
23:13:44 <lambdabot>  add an instance declaration for (Num [b])
23:13:48 <dons> ibid, it's hard
23:14:03 <ibid> > [9,9,9,9,9] >>= fmap (+1) (return (5::Integer))
23:14:04 <lambdabot> Couldn't match `[b]' against `Integer'
23:14:08 <dons> we've discussed it before. if you come up with an easy to implement scheme, then perhaps we can add it
23:14:29 <ibid> dons: the compiler already does it, and > uses the compiler, yes?
23:14:43 <dons> umm. .. by compiler you mean ghci?
23:14:54 <ibid> well, ghc in general
23:15:02 <dons> ghci does it at the command prompt. but @eval is just normal haskell, so it does whatever ghc normally does
23:15:43 <ibid> dons: hum, i thought defaulting Num was a standard part of the language
23:15:43 <dons> if I type: [9,9,9,9,9] >>= fmap (+1) (return 5) into ghci, I get the same errror...
23:16:10 <ibid> yeah well, that even makes no sense :)
23:16:15 <ibid> > [9,9,9,9,9] >>= fmap (+1) 
23:16:16 <lambdabot>  add an instance declaration for (Num [a])
23:16:16 <lambdabot>   In the list element: 9
23:16:20 <ibid> but here
23:16:52 <dons> ghci says: 
23:16:52 <ibid> grr, ok, my mistake
23:16:53 <dons> Prelude> [9,9,9,9,9] >>= fmap (+1)
23:16:53 <dons> <interactive>:1:9:
23:16:53 <dons>     No instance for (Num [a])
23:16:56 <ibid> dons: sorry
23:16:59 <dons> @type Prelude> [9,9,9,9,9] >>= fmap (+1)
23:16:59 <dons> <interactive>:1:9:
23:16:59 <dons>     No instance for (Num [a])
23:17:00 <lambdabot> Not in scope: data constructor `Prelude'
23:17:03 <Saulzar> > [9,9,9,9,9] >>= fmap (+1)  . return
23:17:04 <lambdabot> [10,10,10,10,10]
23:17:11 <dons> @type [9,9,9,9,9] >>= fmap (+1)
23:17:12 <lambdabot> forall a. (Num [a], Num a) => [a]
23:17:14 <ibid> Saulzar: thank you!
23:17:24 <ibid> dons: as i said, my mistake
23:17:31 <dons> ok :)
23:17:35 <adu> wow
23:17:35 <dons> there are defaulting issues though
23:17:41 <dons> due to the Show constraint
23:17:43 <ibid> dons: not noticing it was complaining about Num [a], not Num a
23:17:48 <dons> we get errors that sometimes don't appear in ghci
23:18:42 <dons> > let f = f in f -- works in ghci
23:18:43 <lambdabot> Add a type signature
23:18:46 <dons> but not here
23:18:52 <adu> ok so 2 common monads are "Maybe" and "IO"?
23:19:02 <ibid> adu: also []
23:19:02 <dons> > let f = f in f :: () -- needs a signature
23:19:03 <lambdabot> Terminated
23:19:23 <dons> @type let f = f in f
23:19:24 <lambdabot> forall t. t
23:19:29 <Saulzar> Maybe is a nice one to look at first, it's simple and quite useful
23:19:31 <dons> isn't in Show, so we can't compile it
23:19:33 <adu> ibid: is [] T = [T] ?
23:19:43 <ibid> adu: yes
23:20:00 <ibid> dons: hrm, should that not trip a black hole?
23:20:08 <dons> not anymore
23:20:15 <ibid> ?
23:20:17 <dons> though we found one that does yesterday, let me see..
23:20:20 <adu> so how can [] be a type-constructor and a data-constructor at the same time?
23:20:49 <Saulzar> data Fred = Fred Int   is quite a common use
23:20:49 <adu> Saulzar: ok
23:20:51 <ibid> adu: there is no magic. any constructor can be a type-constructor and a data-constructor at the same time
23:20:58 <dons> hmm, maybe I could add a default Show method, such as <<forall a. a>> that would then let polymorphic values run and fail without needing a signature
23:21:29 * adu wishes there was one namespace
23:21:46 <dons> which must be what ghci does for its magic, since normall it needs a Show as well
23:21:49 <dons> hmm
23:22:03 <Saulzar> Makes it hard to find names otherwise, often you don't need union types for a lot of things
23:22:19 <Saulzar> I hate being forced to chose similar names for the same thing.
23:22:32 <ibid> Saulzar: nobody's forcing you
23:22:41 <ibid> ah, sorry
23:22:49 <ibid> Saulzar: misidentified the speaker there ;)
23:22:58 * ibid should hop on a bus evidently
23:26:51 <ProfTeggy> Morning all.
23:29:06 <adu> oooooo
23:29:19 <adu> i think i get it
23:35:52 <adu> so [], IO and Maybe are all functors too?
23:36:08 <adu> are there any functors that aren't monads? or monads that aren't functors?
23:37:51 <neologism> I think you can have functor which is not monad
23:37:55 <neologism> but not vica versa
23:38:16 <dons> to be in both, you need > fmap f xs  ==  xs >>= return . f
23:39:37 <dons> so could you come up with a functor which satisifies:
23:39:37 <dons> > fmap id  ==  id
23:39:38 <lambdabot>  add an instance declaration for (Eq (f a -> f a))
23:39:38 <lambdabot>   In the definition of `ajs': ajs = (fmap id) == id
23:39:38 <lambdabot>   In the definition of `v': v = let ajs = (fmap id) == id in take 2048 (
23:39:38 <lambdabot> show ajs)
23:40:21 <dons>  > fmap (f . g)  ==  fmap f . fmap g
23:40:27 <dons> and a monadd which satifsfies:
23:40:28 <dons>  > return a >>= k  ==  k a
23:40:28 <dons>  > m >>= return  ==  m
23:40:28 <dons>  > m >>= (\x -> k x >>= h)  ==  (m >>= k) >>= h
23:40:37 <dons> but which then doesn't hold fmap f xs  ==  xs >>= return . f
23:42:41 <dons> I think it must be possible other wise the docs wouldn't say that you need to " additionally satisfy the  [last] law" relating Functors to Monads
23:43:57 <astrolabe> Array a is a functor but not a monad.
23:44:03 <adu> hm
23:45:37 <Saulzar> I would guess that is for implementations reasons though
23:45:54 <dons> ah, my mistake, I was wondering if you could be both in Monad and Functor, but not have a valid relation between the two. there are plenty of functors that aren't monads
23:46:47 <dons> so, you can be in functor but not monad, and maybe you can be a monad, but not a functor, if you don't have "fmap f xs  ==  xs >>= return . f", but i'm not 100% sure that is possible
23:47:09 <rizzix> hey where's the lambdabot?
23:47:13 <dons> anyway there's no rule that says you have to add Functor to your Monad.
23:47:15 <dons> \bot
23:47:16 <lambdabot> :)
23:47:21 <dons> ^ there!1
23:47:31 <adu> so could Monad be a sub-typeclass of Functors?
23:47:36 <rizzix> oh cool
23:48:03 <dons> you mean, could or should Functor a => Monad a ?
23:48:09 <adu> ya
23:48:33 <dons> so, are there any meaningful monads that don't have a concept of 'map' ?
23:48:41 <adu> are there?
23:50:21 <dons> I don't know. i suspect there might be ones where xs >>= return . f is not going to be the same as a map, though.
23:50:51 <dons> Cale might have a definitive answer, being Mr. Category for our purposes.
23:50:59 <adu> hehe
23:51:24 <adu> so "xs >>= return . f" is the usual definition of fmap?
23:51:43 <dons> it's the law that must hold for instances of both Functor and Monad
23:51:51 <dons> and it relates Monad to Functor. 
23:52:00 <adu> ic
23:53:16 <dons> but, monads being all about sequencing, and maps being all about sequencing, i do wonder whether if you have Monad you already are going to have some kind of (f)map
23:53:31 <dons> anyway, you might need to consult the literature on this one :)
23:53:35 <Saulzar> I guess you could potentially have different kinds of maps. But map is a fundimental operation for a monad, no?
23:54:05 <Cale> hm?
23:54:13 <Cale> A monad is just a certain kind of functor
23:54:30 <dons> ah, right. so then why not Fucnctor a => Monad a ?
23:54:37 <Cale> with some natural transformations along with it too
23:54:49 <adu> nice
23:54:52 <Cale> because in contemporary Haskell, it's inconvenient
23:55:10 <dons> and, are there instances of Functor && Monad, but for which fmap f xs /= xs >>= return . f ?
23:55:15 <Cale> There's no way to automatically derive instances of superclasses from instances of subclasses
23:55:33 <Cale> no, those are the same
23:55:37 <Cale> liftM and fmap are the same
23:55:50 <Cale> if it really is a monad, anyway
23:56:29 <dons> ok. a lot of the docs then are about stating the extra thiings that need to hold beyond what typing ensures
23:56:57 <dons> monads being functors are not the same as instance Monad always being an instance Functor :)
23:57:37 <dons> adu, so yeah, that makese sense? when the docs say "should be" they really mean "it isn't a monad unless this holds"
23:58:08 <Cale> right
23:59:19 <dons> unfortunately, we can still call it a Monad even if it is not a monad :}
23:59:24 <adu> what does (!) do to arrays?
