00:06:13 <Cale> fmap f = maybe Nothing (Just . f)
00:08:13 <alar> @karma+ Cale
00:08:13 <lambdabot> Cale's karma raised to 8.
00:08:54 <Cale> fmap f = foldr ((:) . f) []
00:09:00 <Cale> analogously :)
00:12:54 <sieni> @seen rotty
00:12:55 <lambdabot> I haven't seen rotty.
00:14:12 <alar> @seen reductor
00:14:13 <lambdabot> I haven't seen reductor.
00:14:18 <alar> @seen reductor_
00:14:18 <lambdabot> I haven't seen reductor_.
00:14:54 <sieni> @seen sieni
00:14:55 <lambdabot> You are in #haskell-overflow, #haskell-blah and #haskell. Last spoke just now.
00:15:14 <sieni> Oh, I'm on #haskell-overflow :-)
00:16:42 <alar> @seen myself
00:16:42 <lambdabot> I haven't seen myself.
00:17:34 <nothingmuch> @seen you
00:17:34 <lambdabot> I haven't seen you.
00:17:45 <nothingmuch> @seen your mother
00:17:45 <lambdabot> I haven't seen your.
00:18:01 <Cale> @seen lambdabot 
00:18:01 <lambdabot> Yes, I'm here. I'm in #ScannedInAvian, #haskell.es, #haskell.it, #gentoo-haskell, #haskell-overflow, #flippi, #haskell-blah, #haskell and #WinFlame
00:18:05 <alar> noyhingmuch: it doesn't understand whom are you referring to =)
00:29:35 <dons> WinFlame?
00:54:18 <MarcWeber> Which function to use to get a monad (IO) out of Maybe? (Maybe (IO a) ) -> IO (Maybe a) ?
01:13:38 <boegel> I believe some people in here were interested in FunMath, the theoretic language I used for my HRay thesis ?
01:13:59 <boegel> I saw a website has been set up... http://www.funmath.be
01:14:00 * alar wonders if instance Num (Maybe Int) can be derived
01:14:01 <adu> never heard of it
01:14:12 <alar> boegel: what is HRay?
01:16:00 <boegel> alar a raytracer I wrote
01:16:36 <alar> raytracer? for 3D?
01:16:39 <boegel> alar: http://www/~kehoste/Haskell/HRay/
01:16:42 <boegel> alar: jep
01:16:57 <alar> The requested URL /~kehoste/Haskell/HRay/ was not found on this server.
01:20:58 <boegel> alar: erm, sorry :) http://www.elis.ugent.be/~kehoste/Haskell/HRay/
01:39:55 <sylvain> hi all
01:39:59 <adu> hi
01:40:22 <sylvain> I am looking for a library for relational computations
01:41:41 <alar> sylvian: what about GHC typechecker?
01:41:46 <alar> ;)
01:41:50 <sylvain> my best shot 'till now was <http://www.di.uminho.pt/~joostvisser/software/UMinhoHaskellSoftware-1.0/Data.Relation.SetOfPairs.html>
01:42:37 <sylvain> but maybe there are better ones around
01:44:31 <sylvain> a set of pairs is not exactly the most efficient way of dealing with relations ...
01:45:34 <alar> > compare (1,2) (4,1)
01:45:34 <lambdabot> LT
01:45:48 <alar> > compare (1,2) (1,4)
01:45:49 <lambdabot> LT
01:45:59 <alar> > compare (1,2) (1,0)
01:45:59 <lambdabot> GT
01:46:59 <sylvain> I want to compute relations like (rel1 U (rel2 o rel3^-1))*
01:48:27 <musasabi> Would it make sense to have a function like "isPristineTVar :: TVar a -> STM Bool" which returns True if this transaction has not written to a given TVar ?
03:23:56 <spo0nman> ola.
03:24:43 <spo0nman> Im trying to install pugs on Freebsd I am facing problems while compiling pugs ... here is the output  http://pastebin.com/612147
03:24:58 <spo0nman> it'll be nice if someone explains what is it that im doing wrong.
03:31:18 <Lemmih> Looks like a problem with gmp.
03:32:27 <spo0nman> Lemmih: hmm, I installed ghc from ports.
03:32:57 <spo0nman> Lemmih: shouldnt it depend on gmp?
03:34:23 * spo0nman tries to grab libgmp.
03:35:18 <spo0nman> its already installed. I have libgmp-4.1.4_1. do i need some other version?
03:43:40 <xerox> G'day, how's haskell?
03:45:04 <alar> better than ever
03:51:13 <spo0nman> hmm I dont have cabal
03:51:22 <spo0nman> do i need cabal to compile pugs?
03:51:50 <sieni> is "pugs" short for "perl user's gofer system"? :-)
03:52:02 <spo0nman> sieni: :)
03:53:04 <MarcWebe1> Can someone tell me how imports works exactly?
03:53:30 <MarcWebe1> import [qualified] Module as Alias(...) hiding (..)
03:53:42 <MarcWebe1> You can't speciy as and hiding at the same time, right?
03:54:10 <audreyt> spo0nman: "Perl 6 User's Golfing System"
03:54:15 <audreyt> er sorry
03:54:22 <audreyt> sieni: "Perl 6 User's Golfing System"
03:54:25 <MarcWebe1> If you give import qualified ... as XY you have to use XY.<something exposed by XY>, right?
03:54:40 <sieni> audreyt: ahh, ok :-)
03:55:10 <audreyt> Golfing is an esteemed sport in the Perl community :)
03:55:30 <MarcWebe1> kolfing, too?
03:55:38 <sieni> audreyt: ahh, I remember that one :-)
03:55:56 <sieni> http://perlgolf.sourceforge.net/
04:03:44 <Saulzar> That looks like a much more fun version of the language shootout
04:05:14 <Saulzar> Crazy looking entries, I was expecting half a page 
04:05:31 <Saulzar> But just one line, and they must be pushing the 55% symbols rule :)
04:29:02 <beelsebob_> Yay for hat-delta asking really fucking insane questions
04:29:27 <beelsebob_> last one was 100 lines long
04:29:52 <eivuokko> Ouch.
04:30:26 <beelsebob_> actually surprisingly easy to answer - the result was a one liner and was Right "Error: it's buggered"
04:30:34 <beelsebob_> so obviously it was a no answer
04:30:52 <edwinb> Yay for helpful error messages ;)
04:31:15 <beelsebob_> indeed - the point of this is to test the debugger though
04:31:24 <beelsebob_> so I couldn't be arsed with doing it right
04:31:29 <beelsebob_> the more wrong it is - the better
04:32:07 <beelsebob_> ohhhh... I just noticed... it's actually an infinitely long question - it had tried to linearise a strongly connected directed hypergraph... and failed
04:32:16 <edwinb> I have a bad habit of sticking in 'error "Can't happen"' too much then not knowing what it was that couldn't happen when it does happen...
04:32:25 <beelsebob_> hehe
04:32:38 <beelsebob_> well - hat-delta will tell you where it came from
04:33:42 * Igloo tends to use "functionname: Can't happen: arg description"
04:34:00 <edwinb> Yes, I do that when I'm not being sloppy
04:34:11 <edwinb> hat-delta won't cope with my gratuitous abuse of type classes, I fear.
04:34:27 <musasabi> There should be a nice way of getting the current source location.
04:34:47 <beelsebob_> why not just `error ("it buggered: " ++ show args)`
04:34:55 <beelsebob_> edwinb: true enough
04:35:10 <beelsebob_> musasabi: there is - hat-delta :)
04:35:22 <musasabi> just make it a pattern match failure, then the error message will have the location.
04:35:30 <beelsebob_> in fact, if you compiled in hat mode it's dead easy to track source positions
04:35:48 <Igloo> beelsebob_: Come back when hat supports contemporary Haskell...
04:35:59 <beelsebob_> Igloo: come back when you're using haskell
04:36:00 <beelsebob_> :P
04:36:17 <beelsebob_> it'll support Haskell' - so that should sort most people's complaints
04:36:59 <Igloo> Depends what Haskell' is. AFAIK nothing has been accepted that would make Control.Monad.State work, for example
04:37:09 <spo0nman> audreyt: :)
04:37:11 <beelsebob_> heh
04:37:45 <xerox> Igloo: what do you mean by "work" ?
04:38:32 <musasabi> if associated things get in:
04:38:33 <musasabi> class MonadState m where type State = *; get :: m State; put :: State -> m ()
04:38:35 <Igloo> xerox: Currently it needs MPTCs+FDs. I believe it could also be written with assoc types. Thus either would make it "work"
04:39:14 <xerox> Igloo: could you expand MPTC and FD?
04:39:30 <musasabi> Multi Parameter Type Classes
04:39:31 <Igloo> Multi-Parameter Type Class, Functional Dependency
04:39:46 <xerox> Oh-uhm.
04:42:16 <musasabi> FDs degenerate into magic, and seem quite hard
04:42:45 <musasabi> btw are extensible kinds enough extra power for assoc types to get FDs covered?
04:50:42 <mahogny> ok. optimization help; if I have a s::[Foo] globally, and do s!!5, will ghci go in and pick out the value at compile time?
04:51:29 <musasabi> ghci does not do optimization.
04:51:35 <mahogny> ...o_O
04:51:40 <mahogny> oh. duh
04:51:41 <mahogny> ghc
04:52:18 <Igloo> I doubt it. -ddump-simpl will tell you
04:58:07 <mahogny> hm. is it possible to somehow force ghci to do that kind of optimizations? I'd like to try and code a quite demanding application for computation. maps etc would make some of the work really easy but if it doesn't even do this simple optimizations, then it's looking pretty bad
04:59:13 <mahogny> (most of the tabulated values are zeros so I'd like to see it strip away a lot of code)
05:00:05 <astrolabe> Are you talking specifically about retrieving the nth element from a list?
05:00:28 <mahogny> yes. where n is a static number, and the list is static
05:00:41 <mahogny> static=constant
05:00:52 <astrolabe> Could you use an array instead?
05:01:17 <mahogny> yes. would ghc act a bit more clever then? ie perform the optimization
05:01:35 <Igloo> No
05:01:39 <mahogny> :/
05:01:49 <astrolabe> I think retrieval from an array is O(1) though, so it might not matter as much.
05:02:17 <mahogny> yeah. but most calculations are in theory O(0) so I still consider that bad :)
05:02:19 <Igloo> Retrieving the n'th item from a list, for fixed n, is O(1) too
05:03:19 <Igloo> It sounds like you are worrying about the wrong thing being optimised, anyway
05:03:20 <sieni> Igloo: A very useful observation.
05:03:25 <mahogny> that is, I have 0*value1 + 1*value2 etc all over the code. so it makes a lot of difference if ghc is clever enough to insert the value or not
05:03:40 <astrolabe> I think 'fixed' meant 'fixed at compile time'  if n is large, it will be slow in proportion to the size of n.
05:04:11 <astrolabe> mahogny: O(1) means constant time.  What does O(0) mean?
05:04:22 <xerox> No time!
05:04:28 <mahogny> astrolabe, =calculation can be optimized away
05:05:47 <mahogny> oh well. back to C then :(
05:06:39 <astrolabe> I think you have to code differently to get optimised code.
05:07:28 <Saulzar> There was some discussion on the mailing list about this (Can't remember what was said)
05:07:46 <astrolabe> but I also think C will be fastest, if that is what is most important to you.
05:08:16 <mahogny> yes. but with some trickery, gcc can already already be fooled to perform this optimization so haskell actually becomes more inconvenient than C in this case (what a failure...)
05:09:26 <mahogny> well. I have considered using haskell to autogenerate optimized C-code in this case. steal the best from both worlds
05:10:05 <astrolabe> mahogny: is speed really crucial in your application?
05:10:38 <mahogny> astrolabe, yeah. it's all in linear time, but we are still talking clusters
05:11:14 <xerox> Whoa.  -ddump-simpl outout is weird.
05:11:22 * Igloo suggests writing the Haskell, then doing the inlining by hand (or by script) and timing the two to see what the difference is
05:12:34 <Igloo> If you really care about performance and are doing mainly things like maths ops in loops you'll probably find C is at least a factor of 2 faster than ghc, though
05:12:40 <mahogny> Igloo, in C, it's almost a factor two
05:13:22 <mahogny> well, that would be the second thing; a lot of $! abuse. I think the convience of haskell would be worth it
05:13:36 <piggy_> will ocaml be faster in the situation?
05:13:48 <mahogny> well. ocaml is eager isn't it?
05:13:59 * Igloo has no knowledge of how well ocaml compiles that sort of thing
05:14:54 <piggy_> yes, isn't as sexy as haskell
05:22:35 <sieni> mahogny: you could also consider MLton
05:33:25 <MarcWeber> Is anyone using haskelldb? I get some weired messages and don't know what's goint wrong.
06:02:36 <twobitsprite> on the shootout, haskell performs very poorly on the k-nucleotide benchmark... any ideas why?
06:02:45 <twobitsprite> (just curious)
06:12:04 <emrahGUI> sim sim sala bim :)
06:16:42 <Saulzar> twobitsprite, Data.HashTable is not amazingly quick - if you look on the wiki people have written some pretty quick alternatives but they don't match the spec of the shootout
06:24:36 <robokop> is there a function IO (a) -> a
06:25:28 <dblhelix> robokop: the answer should really be "no, there isn't"
06:26:08 <dblhelix> robokop: or: "there is, but you should never use it, unless you really have to, which is never"
06:26:36 <robokop> dblhelix: thanks anyway
06:27:05 <dblhelix> robokop: where do you need such a function for, anyway?
06:28:21 <dblhelix> robokop: not, for the lab assignment, I hope ;)
06:28:51 <bolrod> Busted!
06:29:14 <robokop> dblhelix: in fact yes but i have find something else
06:32:12 <beelsebob_> @hoogle [Bool] -> Bool
06:32:13 <lambdabot> Data.List.and :: [Bool] -> Bool
06:32:13 <lambdabot> Data.List.or :: [Bool] -> Bool
06:32:13 <lambdabot> Prelude.and :: [Bool] -> Bool
06:32:50 <beelsebob_> robokop: unsafePerformIO
06:32:55 <beelsebob_> but it's called unsafe for a good reason
06:33:15 <dblhelix> mainly because it's unsafe ;)
06:33:23 <beelsebob_> well no, not in all situations
06:33:33 <Saulzar> What you probably want instead is bind ...  ie  x <- foo inside a do block
06:33:53 <beelsebob_> for example, I use it to read a file that is never written to at the very end of a purely functional computation
06:34:09 <beelsebob_> and it's much neater to do an unsafePerformIO than to lift the whole computation into the IO monad
06:34:34 <dblhelix> beelsebob_: I could not agree less
06:35:01 <Saulzar> You could pass the contents as a parameter :)
06:35:15 <beelsebob_> I could - but that would be as messy as lifting the whole computaiton
06:35:17 <beelsebob_> computation*
06:35:51 <robokop> Saulzar i want to use the result of an IO function in an non IO function
06:35:58 <dblhelix> then try hard to hide the mess, safely
06:36:07 <beelsebob_> dblhelix: it *is* safe
06:36:25 <dblhelix> robokop: call the non-IO function from within a do-block and you're fine
06:36:25 <beelsebob_> it is safe to read a file that is never written to at an unpredictable moment
06:36:39 <beelsebob_> it doesn't matter what time it's called at - it'll always return the same
06:36:40 <beelsebob_> it's pure
06:36:41 <Saulzar> robokop, Right .. so you do something like this  x <- myIOAction; let foo = myPureFunction x
06:37:06 <dblhelix> beelsebob_: but the fact that the file is never written to, cannot be expressed in Haskell
06:37:41 <beelsebob_> dblhelix: if someone else is playing with the file then the behaviour of my program makes no sense - and it wouldn't make any sense even if the time the file is read was determined
06:37:45 <beelsebob_> so that makes no difference
06:37:49 <dblhelix> beelsebob_: so, from a language pov, that can never be used to argue that the operation is save
06:38:34 <beelsebob_> dblhelix: no - that's the point of it being called unsafePerformIO - it's always unsafe from the languages point of view, but it might be safe from the programmers point of view - as in this case
06:38:35 <resiak> Isn't the whole point of unsafe* that they represent thinks which cannot be proven safe by the language, so you must do the proof yourself? So what beelsebob_ is doing is exactly that.
06:38:54 <Igloo> beelsebob_: If the file is atomically updated by an external program then doing it in the IO monad would give a consistent result, whereas uPIO isn't guaranteed to (but would in practice)
06:39:13 <beelsebob_> Igloo: yes - it would give a consistantly wrong result
06:39:25 <beelsebob_> which is no different to what I'm doing now
06:39:41 <Igloo> No, it would give a consistently right result for one point in time or another
06:39:57 <beelsebob_> Igloo: if the file is modified, the result of my program is incorrect
06:40:01 <beelsebob_> it's no more complex than that
06:40:20 <beelsebob_> it will give an incorrect result if something else modifies it whether I use the IO monad or not
06:40:23 <dblhelix> resiak, beelsebob_: indeed, that's exactly what he's doing... he's making the task of the programmer harder...
06:40:33 <resiak> dblhelix: beelsebob_ is the programmer ;)
06:40:44 <beelsebob_> dblhelix: no - to lift 700 lines of code into the IO monad would make the programmers life harder
06:40:51 <Igloo> e.g. you may not know if you are showing the buy/sale/stock figures before or after the update happens, but the sum will certainly be 0
06:40:57 <beelsebob_> especially where all those 700 lines can be neatly expressed purely
06:41:28 <dblhelix> beelsebob_: well at least the compiler will help the programmer then, namely by checking if all his assumptions are justified
06:41:44 <Saulzar> You can always put the bulk of it as a pure function and feed it from one (tiny) IO action
06:41:50 <beelsebob_> dblhelix: but that's the point - the compiler *can't* check this assumption
06:41:54 <beelsebob_> that's why it's called unsafe
06:42:16 <beelsebob_> Saulzar: indeed - but then I need to thread that IO actian through the whole computaiton
06:42:19 <beelsebob_> which is as messy
06:42:55 <dblhelix> beelsebob_: but please let's quit this discussion... I know what you're trying to say... and I do agree with you in some way... but still I don't let first-year undergraduates play around with unsafePerformIO...
06:43:08 <beelsebob_> that's fair enough
06:43:36 <beelsebob_> the bottom line is - unsafePerformIO is unsafe because the compiler can't check that it's right... Thus the programmer must - I have, and thus can use it in this case
06:45:28 <Saulzar> Anyway, it's almost certainly the wrong answer when joe newbie asks: Is there a function IO a -> a :)
06:45:33 <beelsebob_> indeed
06:45:52 <beelsebob_> or well, no - the right answer is unsafePerformIO, but don't use it
06:46:10 <ski> better to not mention it as early, i think
06:46:24 <Maddas> Isn't the right answer to hit him on the head with a thick book so he can become enlightened? ;-)
06:46:34 <dblhelix> Saulzar, beelsebob_: hence, my answer read "there is, but you should never use it, unless you really have to, which is never"
06:46:57 <beelsebob_> Maddas: good approach
06:47:10 <ski> you could state that haskell98 has no such function
06:47:19 <dblhelix> furthermore: In Haskell 98 there is no unsafePerformIO
06:47:26 <dblhelix> ski: ah, indeed :)
06:48:03 <beelsebob_> lol
06:48:15 <beelsebob_> but then in Haskell 98 there is no IO monad
06:48:28 <dblhelix> beelsebob_: why not?
06:48:33 <edwinb> The question 'is there a function IO a -> a' is almost always the wrong question...
06:48:37 <beelsebob_> dblhelix: is it part of the standard?
06:48:46 <dblhelix> beelsebob_: of course
06:48:59 <beelsebob_> dblhelix: show me where it's mentioned in the Haskell report?
06:49:03 <Maddas> edwinb: right, since that couldn't be a _function_ :-)
06:49:20 <beelsebob_> ah - good point
06:49:40 <beelsebob_> actually, no, there is a function from IO actions to their results
06:49:55 <beelsebob_> the problem is that you could have a different action each time
06:50:03 <Maddas> (Well, at least not particularly useful functions)
06:50:06 <beelsebob_> so it is a function - it's the IO a part that isn't
06:50:08 <dblhelix> beelsebob_: for instance, http://haskell.org/onlinereport/standard-prelude.html
06:50:39 <beelsebob_> oh - so it is...
06:50:45 <beelsebob_> I didn't think it was part of the prelude
06:50:59 <dblhelix> beelsebob_: there are two such functions: _|_ and \x -> _|_
06:51:21 <ski> and module 'seq', there's only one
06:52:04 <Igloo> beelsebob_: Are you an ex-York-uni person?
06:52:20 <beelsebob_> dblhelix: there are more than that - there is for example unsafePerformIO - it's not the unsafePerformIO function that's doing different things, it's the IO action
06:52:23 <beelsebob_> Igloo: yes
06:52:49 <dblhelix> beelsebob_: I meant: there's only two in *Haskell 98*
06:52:55 <Igloo> Heh
06:52:59 <beelsebob_> dblhelix: ah, okay
06:53:17 <beelsebob_> @hoogle m a -> a
06:53:18 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
06:53:18 <lambdabot> Prelude.id :: a -> a
06:53:18 <lambdabot> Data.Graph.Inductive.Monad.emptyM :: GraphM m gr => m (gr a b)
06:53:42 <beelsebob_> @hoogle Monad m => m a -> a
06:53:43 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
06:53:51 <beelsebob_> no... apparently not
06:54:17 <dblhelix> @type undefined :: IO a -> a
06:54:18 <lambdabot> IO a -> a :: forall a. IO a -> a
06:54:30 <beelsebob_> indeed
06:54:39 <beelsebob_> I was trying to find another
06:54:39 <dblhelix> @type (\x -> undefined) :: IO a -> a
06:54:40 <lambdabot> IO a -> a :: forall a. IO a -> a
07:22:38 * beelsebob_ giggles at having found a 'bug' at IO.hs line 69
07:22:50 <beelsebob_> "source code not available"
07:34:20 <ski> MarcWeber : maybe (return Nothing) (liftM Just)
07:37:55 <ihope> Ahoy~!
07:38:02 <ihope> s/~//, arr.
07:38:41 <alar> @pl (\(x,y)-> (y,x))
07:38:41 <lambdabot> uncurry (flip (,))
07:39:49 <ihope> @type flip flip
07:39:49 <lambdabot> forall a c b. b -> (a -> b -> c) -> a -> c
07:40:08 <ihope> How weird.
07:40:32 <ihope> I guess it lets you do stuff like "flip flip 1 (+) 2" and get 3, but...
07:41:28 <ihope> Well, a "better" way to do that might be "flip ($) 1 (+) 2", as the above is actually 2+1.
07:41:44 <ihope> flip ($) 1 mod 2... it *looks* infix :-P
07:42:23 <Igloo> Or you could use 1 `mod` 2, which /is/ infix
07:44:41 <ihope> What about 2 ´mod´ 1? :-P
07:51:46 <ndm> beelsebob_: hoogle is broken on higher kinded type classes, including monads
08:03:10 <berthold> Hello folks, is anyone aware of any free shell accounts that have ghc?
08:03:22 <resiak> localhost ;)
08:03:57 <berthold> *grin* Would that I could, my ancient freebsd system has been less than useful, and my windows system's been having trouble compiling the http module.
08:09:47 <JKnecht> I suppose I could do.
08:13:04 <ski> sometimes i've wanted 'foo `bleh baz` bar' ..
08:13:49 <cathper> berthold: unixshell.com and you get full control :-)
08:16:16 <xerox> @yow
08:16:17 <lambdabot> My life is a patio of fun!
08:19:32 <ihope> ski: you mean I can't do that?
08:19:51 <ihope> > return `id` 3 :: [Int]
08:19:52 <lambdabot> [3]
08:19:57 <ihope> Uh.
08:20:00 <ihope> > return `id id` 3 :: [Int]
08:20:00 <lambdabot>  parse error on input `id'
08:20:47 <xerox> <http://ii-0-ii.com/parodycheck/picto/20060320.png>
08:24:28 <ski> ihope : right :/
08:33:38 <berthold> cathper: Thanks for the tip.
08:33:47 <JKnecht> berthold: I definitely will not give you full control :-)
08:34:20 <JKnecht> but a free ssh acct with 6.4.1 I can do.
08:34:32 <berthold> JKnecht: *grin* not what I need friend, just a way to learn to use XML Toolbox.
08:36:04 <zellyn> quick noob question
08:36:52 <zellyn> I'm trying to load a file with a "forall" in it, and GHCi doesn't like it.
08:36:58 <zellyn> Is there a flag to specify?
08:37:08 <zellyn> (I'm assuming it's an extension)
08:37:36 <kosmikus> -fglasgow-exts
08:38:20 <zellyn> thanks!
08:39:06 <pierre-> hello.
08:42:59 <snk_kid_lambda^> hello peeps
08:43:15 <ski> hello long nick
08:43:33 <JKnecht> berthold9: you need Cabal too for HXT, can do but not for free.
08:44:54 <berthold> JKnecht: I know, http's just where my system choked.
08:46:00 <monadic_kid> well i'm still trying to get SDL & ghc on win32 working together, after having aload problems i gave up and tried things fedora 4, no the only problem is lemmih's SDL has vansihed off the net, even darcs doesn't see the server
08:46:25 <monadic_kid> *on fedora 4, now the only....
08:47:25 <monadic_kid> anyone know if there are any mirrors for lemmih's sdl bindings?
08:47:46 <berthold> JKnecht: What will you require for it to be setup?
08:52:05 * monadic_kid sighs
08:53:53 <JKnecht> since Haskell XML processing is not a choice of mine at this point, would require professional rate to make HXT Hunit and other examples work in your account. Prepaid.
08:54:18 <jips> what about haskell xml toolbox?
08:55:14 <berthold> Sensible, I'll be honest, I couldn't pay you at the moment, but I'll be happy to get in touch when I can if I still can't get the fool thing to function on mine.
08:55:15 <JKnecht> sorry should have prefixed that with "berthold: "
08:57:30 <pierre-> @where happs
08:57:30 <lambdabot> I know nothing about happs.
09:34:58 <bynari> What kind of applications are functional languages best used for?
09:36:16 <ptolomy> Hairy question. Some say "most". Some say "parsing". Some say "things that need to be correct". Some say "non-interactive". 
09:37:22 <bynari> So functional languages are a good choice for a lot things then
09:37:31 <ptolomy> Really, depends on the language, the implementation, and the programmer.
09:37:31 <palomer> >;o
09:37:51 <bynari> Would you say haskell is a better choice as a first functional language over scheme?
09:38:06 <xerox> For me it was the other way around.  I enjoyed it.
09:38:08 <bynari> I'm learning towards haskell because it seems more wide-spread
09:38:21 <bynari> And since it's pure functional 
09:38:30 <integral> and it's got typing
09:38:33 <bynari> er, leaning, not learning
09:38:40 <bynari> Oh, hi, integral 
09:38:46 <integral> hello
09:38:53 <ptolomy> I think scheme might be better, in that it is simpler in most ways, so you can hit the big points without wondering "what the f is a monomorphism restriction?".
09:39:24 <integral> if you're looking to learn functional programming,  scheme's probably better, and SICP is excellent.
09:39:53 <bynari> Hm, so haskell wouldn't teach one to be a better functional programmer since it's purer?
09:40:06 <integral> bynari: I mean it might be better to separate the two :-)
09:40:08 <palomer> haskell is purely functional if you consider the runtime system separate from the language, which I think is silly
09:40:08 <xerox> Difficult question!
09:40:25 <bynari> I'm not really looking to just 'get stuff done'. I'm more interested in computer science
09:40:28 <integral> for example, if you don't know how to express your algorithms as folds/map/etc over lists for example
09:40:43 <integral> ah, haskell can appeal to category theory more than lisp :-P
09:41:00 <palomer> anyways, my vote goes for scheme
09:41:10 <bynari> I'm looking more to getting a solid grounding in functional programming and computer science concepts
09:41:12 <palomer> since io is done the same way as anything else
09:41:12 <bynari> Hm. I see.
09:41:38 <tennin> are there HTDP/SICP-like books that use Haskell?
09:41:56 <bynari> I'll just learn them both
09:42:08 <bynari> I'll get 2 books and work through them at the same pace so I see the differences for myself
09:42:12 <palomer> that's the thing, the haskell books suck
09:42:30 <palomer> bynari: really, your best bet is SICP + Sussman lectures
09:42:47 <xerox> Abelson & Sussman lectures are *great*!
09:42:48 <bynari> Sussman lectures? I'll have a look at, thanks
09:43:04 <ski> palomer : 'runtime system separate from the language' ?
09:43:10 <xerox> @google sicp video lectures csail swiss mit
09:43:11 <lambdabot> http://www.swiss.ai.mit.edu/classes/6.001/abelson-sussman-lectures/
09:43:20 <ski> bynari : learn both :)
09:44:07 <palomer> the function main always returns the same thing, but running main induces side effects
09:44:20 <bynari> Thanks for the advice, guys
09:44:34 <xerox> They're not side-effects.  They're effects explicited in the type signature!
09:44:35 <ski> palomer : each time you run 'main' you pass in a different world
09:44:48 <ski> xerox : :)
09:45:09 <palomer> ski: but main doesn't have type world -> foo
09:45:17 * xerox hands ski a typed-lambda-cookie :-)
09:45:35 <ski> rather like '*World -> *World'
09:45:55 <xerox> * product type?
09:45:58 <ski> palomer : this is clear if one has seen Clean
09:46:07 <ski> xerox : uniqueness annotation
09:46:10 <xerox> Ah.
09:46:23 <palomer> maybe Clean is purely functional
09:46:30 <ski> haskell is too
09:46:47 <xerox> ...hot!
09:46:47 <palomer> if you really fiddle with the definition of pure
09:47:15 <ski> it's just that you shouldn't really duplicate the world, for efficiency of implementation
09:47:20 <palomer> if by pure you mean "every time I run the same piece of code the same thing happens", then haskell is certainly not pure
09:47:24 <ski> Clean enforces this in it's type system
09:47:58 <xerox> Maybe one can say that the 'pure' clause in the report, if it's there...
09:47:59 <ski> Haskell enforces this by hiding and enforcing the linearity/uniqueness behind an abstract datatype, the 'IO' monad type
09:48:41 <ski> palomer : i mean "every time i evaluate the same expression, the same value is yielded"
09:48:49 <ski> and haskell is pure, using that
09:48:55 <ski> (as is Clean)
09:49:09 <palomer> but purity has always been defined as running code
09:49:11 <sieni> palomer: good luck passing the exact copy of the world from the previous run to your haskell program
09:49:29 <ski> palomer : note that i distinguished "running" from "evaluating"
09:49:39 <palomer> yes
09:49:45 <palomer> and I think that's cheating
09:49:48 <palomer> :o
09:50:00 <ski> "running" is an indexial expression, it refers to a current environment (the current world)
09:50:32 <ski> IO is more or less just a state monad with the linear world state as state
09:50:37 <palomer> well, that's the thing, one has to define "purely functional" rigorously
09:50:46 <ski> yes
09:51:04 <ski> there's a paper by amr sabry (iirc) about that
09:51:52 <palomer> nonetheless, you really have to fiddle with the definitions to make it fit with haskell
09:51:55 <palomer> and it's a real stretch
09:52:08 <ski> i don't think it's a stretch
09:53:15 <ski> running a state-action means passing in an initial state, and getting a result back + final state
09:53:23 <palomer> you have to do something of the sort "evaluation takes an expression and a world and returns an expression"
09:53:24 <ski> same with 'main'
09:53:36 <ski> no
09:53:53 <palomer> s/evaluation/running
09:54:22 <ski> (s/expression/value and new world/), but yes
09:55:08 <ski> of course we can run actions in other monads, too
09:55:32 <palomer> before haskell came around, this definition surely never existed
09:55:47 <palomer> I'd argue that haskell redefined "purely functional" to fit its needs
09:55:57 <ski> i think something a bit like it existed in denotational semantics
09:56:02 <ski> palomer : :)
09:57:09 <ski> but, yes, you have to accept this understanding of running IO-actions, to make "referential transparency" work, in this manner
09:58:06 <ski> i think i've seen in a CT book a description of imperative programs as endofunctions over the state
09:58:34 <alar> endofunctions?
09:58:41 * palomer has qualms about separating evaluation and runtime
09:58:49 <palomer> isn't same evaluation performed at runtime?
09:59:01 <ski> alar : functions where domain = codomain
09:59:19 <ski> palomer : why separate it ?
09:59:41 <alar> funny name for bijections
09:59:44 <ski> (i know some explanations say you can think of it in two stages)
09:59:54 <ski> alar : no, not bijection
10:00:04 <alar> then what's codomain?
10:00:16 <ski> alar : f : R -> R, f(x) = x^2, f is endo
10:00:53 <ski> alar : otoh g : R -> {x : R | x >= 0}, g(x) = x^2, g is *not* endo
10:01:20 <palomer> ah, so evaluation is performed at runtime
10:01:46 <ski> yes
10:01:47 <alar> yes
10:01:48 <palomer> endo=injective?
10:01:52 <ski> call it eval-time, if you like
10:02:00 <ski> endo = domain is the same as codomain
10:02:05 <ski> f : A -> B
10:02:08 <ski> A is the domain
10:02:11 <ski> B is the codomain
10:02:24 <ski> {f(x) | x : A} is the range
10:02:25 <alar> then it's bijective
10:02:29 <ski> no
10:02:44 <alar> it maps domain onto itself
10:02:55 <palomer> oh, that's right, epi is injective
10:02:59 <sieni> palomer: If you have a pure function that has a type a -> [a] -> [[a]] -> [a] and use it so that you put a new input byte to the first argument, previously received input bytes in the second, previously output byte sequences in the third and it spits out a new sequence of output bytes, then would you consider that somehow non-purely functional, even though you can probably emulate all non-purely functional programming with such a thingie
10:03:02 <ski> palomer : no
10:03:05 <sieni> ?
10:03:15 <ski> palomer : epi corresponds to surjective
10:03:23 <palomer> what's injective?
10:03:31 <ski> alar : if you define  f : R -> R   f(x) = x^2, then f is not a bijection .. you can't invert it
10:03:38 <ski> injective corresponds to mono
10:04:02 <palomer> sieni: well, yes, but you'd need a mechanism to get those bytes
10:04:07 <palomer> brb
10:04:09 <xerox> What are these mono and epi you're talking about?
10:04:13 <ski> (these two corresponances are quite loose .. in category Set, they are ok)
10:04:27 <ski> mono (or monic) is short for monomorphism
10:04:38 <ski> epi (or epic) is short for epimorphism
10:04:55 <alar> ski: I can invert it, but the reverse mapping would not be what we call function
10:05:09 <alar> s/mapping/morphism
10:05:34 <ski> mono (f : A -> B)  <=>  forall x,y : T -> A. (f o x = f o y) ==> x = y
10:05:59 <ski> alar : invert what ?
10:06:09 <alar> f x = x^2
10:06:45 <ski> alar : ah, right .. you can't invert it in category Set .. since it's not a bijection
10:07:01 <alar> ok
10:07:29 <ski> in the category of sets and binary relations between sets, you could invert it, yes
10:07:57 <ski> but then you aren't inverting a function, you are inverting a binary relation that happens to be "functive"
10:08:34 <alar> yes
10:08:56 <ski> (of course Set is a subcategory of this one)
10:11:00 <ski> (one interesting things regarding injective and surjective, and mono and epi, is that generally, if a morhpism is mono and epi, it needn't be an isomorphism (~ bijection))
10:12:05 <palomer> how so?
10:15:14 <gzl> ski: don't you mean that an isomorphism need not be a bijection? something that's mono and epi will be iso
10:17:11 <ski> no
10:17:39 <ski> iso f  ==>  mono f /\ epi f
10:17:51 <xerox> ..and homo?
10:18:23 <ski> xerox : that's special case name for morphisms in algebraic categories
10:19:01 <ski> xerox : also, for some reason, "homeomorhism" in topological categories mean "isomorphism" generally (iirc)
10:19:16 <ski> s/means/is the same as/
10:19:48 <xerox> I'm "reading" ``Elements of Abstract and Linear Algebra'' in the hope of getting comfortable with the definitions.
10:20:38 <ski> a homomorphism between two vector spaces is just a morphism in category Vect
10:22:00 <ski> "morphism" is the general category theory name
10:22:04 <ski> better ?
10:22:25 <ski> (also "arrow" and sometimes "map" is used)
10:23:54 <astrolabe> Do you know any examples of morphisms which are mono and epi but not iso?
10:25:08 <ski> hm .. i think there was some easy example in Mon, the category of monoids and monoid homomorphisms
10:25:29 <ski> irrc
10:25:34 <ski> i : N -> Z
10:25:43 <ski> N is monoid of naturals, with 0 and +
10:25:50 <ski> Z is monoid of integers, with 0 and +
10:25:58 <ski> i is standard inclusion
10:26:08 <ski> i is obviously monic
10:26:39 <ski> now, i should be epic, too
10:26:46 <ski> (of course i isn't iso)
10:27:06 <astrolabe> So if two morphisms from Z agree on the non-negatives...
10:27:22 <ski> epi (f : A -> B)  <=>  forall p,q : A -> P. (p o f = q o f) ==> p = q
10:27:47 <astrolabe> p,q: B->P
10:27:57 <ski> right
10:28:02 <snk_kid> is there away to enable extensions on ghc permantly instead of having to give a flag
10:28:18 <snk_kid> like a config file or something
10:28:35 <ski> snk_kid : i think you can set a shell env, also use a .ghc file or something
10:28:42 <astrolabe> you can have the flag in the source file.
10:28:51 <ski> yes, that too
10:29:06 <snk_kid> well i'm going to change all the files of this package :)
10:29:15 <snk_kid> *i'm not
10:29:56 <ski> astrolabe : was the example ok ?  or should we try to prove it, here ?
10:30:08 <astrolabe> I'm thinking :)
10:30:50 <snk_kid> you see i'm trying another SDL binding from a some japanese website, things seem all well except when i go to build i get aload of ".... Illegal signature in pattern: .....  Use -fglasgow-exts to permit it"
10:31:54 <shapr> SyntaxNinja: Hey, do you know anything about this crazy Haskell language?
10:32:29 <astrolabe> Hi shapr:  Are you new to haskell?
10:32:39 <shapr> astrolabe: Yeah, I've heard that the variables don't vary...
10:32:54 * jips wonders if shapr is drunk
10:33:06 <ski> hi shapr
10:33:08 <astrolabe> I've never heard anything so ridiculus.  How could you program?
10:33:12 <shapr> I did have a beer a few days ago.
10:33:17 <shapr> astrolabe: I have no idea!
10:33:18 <snk_kid> ski: do i just add the flag .ghc file as "-fglasgow-exts"
10:33:24 <ski> shapr : have a look at http://www.haskell.org/hawiki/HaskellDemo
10:33:35 <ski> shapr : that shows the basic syntax of haskell
10:33:36 <shapr> ski: Oh, this looks nice, who wrote it?
10:33:55 <xerox> snk_kid: you could also write {-# OPTIONS_GHC -fglasgow-exts #-} directly in the first line of your file.
10:33:56 <ski> shapr : some wierd guy who's name is "shae"
10:33:58 <jips> snk_kid: i think i used those japanese SDL bindings a while ago, porting my code to lemmih's sdl bindings was very straightforward
10:34:07 * shapr snickers
10:34:41 <shapr> ski: Hey, I was in Stockholm the last five days, it was fun!
10:34:49 <snk_kid> jips: i'm trying to use that since i can't a copy of lemmih's sdl bindings, his server is down or something
10:34:52 <ski> shapr : visiting ?
10:35:18 <shapr> Yeah, preparing to move.
10:35:43 * ski 's been in stockholm, twice
10:35:44 <shapr> snk_kid: I think Lemmih's repos moved from ScannedInAvian.org to darcs.haskell.org, but I'm not positive.
10:35:59 <shapr> ski: How do you like it? Which town are you from originally?
10:36:14 <ski> shapr : always lived here in gbg
10:36:36 <shapr> ski: Oh I have pic of you from EuroHaskell 2004
10:37:36 <shapr> Did you like your visits to Stockholm?
10:37:40 <ski> shapr : yes .. (and i think it's a bad pic of me, of course)
10:37:41 <jips> snk_kid: hm.... have you talked with lemmih?
10:37:54 <ski> (shapr : if you're referring to andersca's)
10:38:06 <shapr> Yes, that's the only pic I have. Do you have better pix of you?
10:38:09 <ski> shapr : yes .. more or less
10:38:14 <snk_kid> jips: no, i've only just notice he's in this room :)
10:38:21 <shapr> Lemmih: hiiii Lemmih!
10:38:24 <ski> shapr : not on computer :/
10:38:40 * snk_kid pokes Lemmih
10:38:45 <ski> shapr : i always forgot to scan such
10:39:06 * snk_kid will bbl
10:40:41 <ski> hm
10:41:13 <ski> shapr : i enjoyed visiting cosmonova, i remember
10:43:00 <astrolabe> p(-1) = p(-1 +1 -1) = p(-1) +p(1) + q(-1) = p(0) + q(-1) = q(-1).  So p(-n) = np(-1) = nq(-1) = q(-n)
10:43:03 <astrolabe> :)
10:44:19 <ski> yes, something like that
10:44:46 <shapr> ski: Ah, we didn't get to that place. We meant to, but it didn't happen. We did get to the comics shop though.
10:45:18 <ski> shapr : found any nice ones ?
10:45:56 <ski> astrolabe : otoh, split_epi f /\ mono f ==> iso f, i think
10:47:41 <kosmikus> @hoogle [a] -> [a] -> Bool
10:47:42 <lambdabot> Data.List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
10:47:42 <lambdabot> Data.List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
10:47:42 <lambdabot> Graphics.UI.ObjectIO.CommonDef.disjointLists :: Eq x => [x] -> [x] -> Bool
10:50:05 <SyntaxNinja> shapr: not yet. working on it.
10:51:10 <shapr> ski: Books of Magic reprint... I was hoping for one of the first printing though.
10:54:00 <ski> shapr : ah .. i'd like to read all those books, once
10:55:06 <ski> (shapr : would you know if 'American Gods' are good ?)
10:55:37 <araujo> hello!
10:57:35 <ski> hello araujo
10:57:41 <snk_kid> so does anybody know where i can get a copy of lemmih's sdl bindings then?
10:59:11 <araujo> hola ski :-)
10:59:42 <A-Tui> hola
11:02:56 <snk_kid> :(
11:03:28 <snk_kid> i don't understand how they could just dispear completely from the net
11:03:47 <berthold> ski: American Gods is pretty good, Gaiman uses a king sized sledgehammer for his foreshadowing though.
11:04:14 * wolverian agrees with berthold 
11:04:36 * ski wonders what 'foreshadowing' means
11:04:39 <wolverian> I even liked stardust, and I hear it's pretty amateurish by some standards. shrug.
11:04:52 <ski> yes, i liked that one
11:05:04 <berthold> wolverian: I haven't gotten to that one yet, but keep intending to.
11:06:13 <wolverian> ski, it means hinting at something that will happen later.
11:06:21 <wolverian> ski, some authors are subtle about it. some are not so.
11:06:26 <ski> (snk_kid : Lemmih has lost it ?)
11:06:33 <ski> ah
11:07:21 <snk_kid> can anyone dcc me a copy :)
11:10:11 * ski has not downloaded that, sorry
11:15:55 <shapr> ski: American Gods is a nifty book.
11:16:16 * wolverian likes death 
11:17:32 <ski> wolverian : the endless one ?
11:17:57 <wolverian> the cute one. :)
11:18:11 <ski> yeah :)
11:18:22 <wolverian> I do not mind death at all when she comes in that form...
11:18:26 * ski has her as bg-pic
11:18:53 <wolverian> she reminds me of the longest journey (and the sequel, dreamfall) characters, as well, if you know those games.
11:19:09 * ski doesn't
11:19:09 <wolverian> hm. I just realised that, in fact. 
11:19:36 <wolverian> well, I can whole heartedly recommend TLJ. it's one of the four games that I can actually recommend to anyone.
11:19:38 <ski> i really like those 10 books
11:19:47 <ski> heh :)
11:19:51 <wolverian> (the gaming industry is like hollywood nowadays, only worse.)
11:20:03 <ski> when did it come out ?
11:20:18 <wolverian> let me see... 1999: http://en.wikipedia.org/wiki/The_Longest_Journey
11:20:41 <wolverian> "... the game was criticized for its extensive dialogue of almost 8300 individual voice samples."
11:20:49 <ski> heh
11:20:50 <wolverian> that is the kind of attitude that has destroyed the gaming industry
11:20:59 <wolverian> "I don't want to think, I just want to shoot people!"
11:20:59 <berthold> Yeah, but it's author is getting kind of scary Hollywood himself...
11:21:05 * ski likes Dungeon Master
11:21:18 <wolverian> I have never played dungeon master. maybe I should give it a try.
11:21:33 <wolverian> berthold, hm, who?
11:21:37 <berthold> <Having said that TLJ is one of my favorites and I'm really hoping he gets dreamfall right>
11:21:43 <berthold> Ragnar Tourquist
11:21:59 <wolverian> ah. what do you mean with the hollywood reference? I don't actually know of his work besides TLJ :)
11:22:02 <ski> http://en.wikipedia.org/wiki/Dungeon_Master_(computer_game)
11:22:18 <ski> wolverian : there is a gnu/linux port, now
11:22:32 <berthold> Behaviour on his blog, kind of the Wolkowski bros sort, "my work is god, noone understands my art"
11:22:51 <ski> (wolverian : a lunatic disassembled the machine code and ported that ..)
11:22:55 <wolverian> berthold, ah. maybe I'll skip the blog then
11:23:06 <wolverian> ski, oh, wow. :) 
11:23:24 <wolverian> I don't much like action RPGs, though. diablo... *shudder*
11:23:30 <ski> (see http://dmweb.free.fr/ for info)
11:23:40 <berthold> wolverian: *grin* It's what I've taken to, The work is a thing of beauty though.
11:27:42 <snk_kid> so what would i put the .ghc to enable extensions permantly
11:27:51 <snk_kid> *put in the ghc file
11:28:14 <snk_kid> i can't find nothing in the docs about .ghc files
11:31:10 <ski> hm
11:31:14 <ski> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-dot-files.html
11:31:22 <ski> i think i was thinking of that
11:31:28 <ski> that's for GHCi, though
11:32:10 <snk_kid> and i can't find anything on env variables
11:38:19 <snk_kid> OMG
11:38:42 <snk_kid> thank f*ck for that, i figure it out, just needed modify the cabal file
11:38:51 <snk_kid> *i figured it out
11:47:50 <astrolabe> Do you people find that with a largish haskell program, you end up carrying a pretty complicated state around, either explicitly or in a monad?
11:48:05 <Lemmih> snk_kid, shapr: Hi.
11:48:17 <snk_kid> OMG
11:48:20 * twobitsprite hasn't gotten to a point in his program that he even uses IO... :P
11:48:36 <snk_kid> Lemmih: you're alive :)
11:49:00 <snk_kid> Lemmih: what happened to your sdl bindings?
11:49:20 <Lemmih> snk_kid: They moved.
11:49:29 <snk_kid> Lemmih: i can't find them :(
11:49:33 <twobitsprite> astrolabe: I have a tendancy to write from the perspective of a library writer, and then at some point I tie all of my modules together with some glue IO code
11:49:50 <Lemmih> snk_kid: to http://darcs.haskell.org/~lemmih/SDLstable
11:50:00 <snk_kid> omg
11:50:08 * snk_kid bangs his head on the wall
11:51:13 <snk_kid> Lemmih: oh man i have a question, i've been dieing to make a build on win32 but i've had some many problem with it
11:51:29 <snk_kid> *i've had so many problems with it
11:52:53 <snk_kid> finally now i can try it out on fedora :)
11:53:10 <waern> astrolabe, yep i've had that experience
11:53:50 <astrolabe> thanks both
11:54:46 <leif> Has anyone here done/heard about research into asynchronous/event-driven IO in Haskell, in the style of Python's Twisted (http://twistedmatrix.com) library?
11:55:28 <leif> My limited understanding of Haskell's do syntax makes me think it could be used for an elegant library like Twisted, but without so many ugly calls to addCallback.
11:56:13 <snk_kid> :(
11:56:24 <snk_kid> :,-(
11:56:35 <snk_kid> "Could not find module `Distribution.Compiler'"
11:56:50 <Lemmih> snk_kid: Using SDL on windows is a PITA, afaik.
11:57:15 <dcoutts> leif, Haskell threads give you event-driven IO for free
11:57:29 <Lemmih> snk_kid: Right, I should fix that.
11:59:08 <Lemmih> snk_kid: Quick fix: write 'import Distribution.Simple; main = defaultMain' in Setup.lhs.
11:59:23 <leif> dcouuts, is that really event-driven? The idea is to avoid using threads and the overhead and complexity they require.
11:59:24 <snk_kid> Lemmih: okay
11:59:51 <mauke> haskell threads are superior
12:00:23 <bynari> ah it's mauke. :)
12:00:33 <dons> Moin
12:00:36 <mauke> how are you gentlemen!!
12:00:48 <bynari> Have you coded in haskell for a while, mauke?
12:00:56 <mauke> yeah
12:01:00 <bynari> I started learning it today. Really enjoying it
12:01:09 <bynari> Functional programming in Perl gave me a taste
12:01:45 <snk_kid> Lemmih: get rid of defaultMainWithHooks?
12:02:05 <snk_kid> Lemmih: the import lines is there already
12:02:13 <snk_kid> *import line is there
12:02:32 <Lemmih> snk_kid: Delete everything in the file.
12:03:17 <snk_kid> Lemmih: this is in SDLstable/src/core/Setup.lhs
12:04:38 <snk_kid> Lemmih: so delete everything and then add that single import & main line
12:04:54 <snk_kid> ?
12:05:24 <Lemmih> snk_kid: Lets continue privately.
12:05:36 <Lemmih> snk_kid: I've PM'ed you the answer.
12:10:54 <twobitsprite> arg... why does Data.Map.insert accept the actual map as the last arg?
12:11:01 <mathrick> bynari: Functional programming in Perl <-- explain?
12:11:26 <bynari> Perl is Procedural, functional and object oriented
12:11:44 <bynari> Most people code Perl as if it's C, but it's more flexible than that
12:11:44 <twobitsprite> @google functional programming perl
12:11:46 <lambdabot> http://www.ibm.com/developerworks/linux/library/l-road4.html
12:11:57 <bynari> It's much more powerful if you treat it as part functional part procedural
12:12:12 <bynari> "Higher Order Perl" by Mark Jason dominus
12:13:50 <gzl> hey, that guy!
12:14:05 <gzl> he's a fun character. done some stuff with him before.
12:15:34 <wolverian> HOP is a _great_ book.
12:41:57 <shapr> leif: Threads has several definitions. Do you know coroutines vs OS threads?
12:53:49 <ValarQ> aieee OS threads
12:53:51 * ValarQ hides
12:55:03 <MarcWeber> How do you use IO monads with wash?
12:59:19 <MarcWeber> http://www.rafb.net/paste/results/cVmQZ376.html
13:05:46 <vincenz> gotta love haskell
13:06:12 <vincenz> 1000 lines of code to implement an rb tree and pipe it to some textual format, 10 lines of code to read it into haskell to enable checking of it (for testing)
13:10:44 <mathrick> 1000 lines -- haskell as well?
13:11:13 <vincenz> no
13:11:14 <vincenz> C++
13:11:28 <mathrick> that's a lot
13:11:34 <mathrick> even for C++
13:11:39 <vincenz> I'm exagerating maybe a bit
13:11:47 <vincenz> let me do a wc
13:12:46 <vincenz> I need a new nick
13:13:39 <flux__> maybe not. I made a course work in 2000, rb-trees in c++, it is 800 lines (templated et al)
13:14:04 <vincenz> nope
13:14:08 <mathrick> seriously? I'm quite sure I could do it in C in much less code
13:14:14 <vincenz> already 800 lines
13:14:20 <vincenz> without "remove"
13:14:25 <vincenz> but it has iterators and such
13:14:28 <flux__> that's right, I didn't have remove either ;)
13:14:41 <flux__> but the code size could be brought down somewhat if it wasn't so multi-layered
13:15:39 <vincenz> Cale: ping
13:16:07 <flux__> oh, that has some dead code in it too
13:16:08 <vincenz> note that itÃ¹s 870 lines with a few comments and whitespace
13:16:15 <vincenz> (very minimal comments)
13:16:20 <flux__> apparently a defunct remove ;)
13:16:30 <vincenz> anyone use yi.org?
13:16:38 <dons> astrolabe, yeah, large programs have more data, more state. so you end up with complicated things in monads, iorefs or explicitly threaded
13:17:17 <vincenz> anyone here use the yi.org stuff?
13:17:26 <mathrick> vincenz: ?
13:17:30 <mathrick> vincenz: what do you need?
13:17:46 <vincenz> mathrick: trying to figure out how to get a name to point to my ip
13:18:01 <mathrick> vincenz: sec, I'll ask friends
13:19:00 <dons> vincenz, I think Cale does
13:19:10 <vincenz> dons: yeah but he's not on
13:22:10 <vincenz> found how to do it
13:22:11 <vincenz> thx!
13:22:16 <davidhouse> an A record
13:22:20 <vincenz> yeah
13:22:26 <davidhouse> DNS is quite scary
13:22:46 <dons> hey davidhouse. how's the haskell hacking coming along?
13:23:05 <vincenz> davidhouse: why?
13:23:09 <vincenz> and whatcha hacking on
13:23:17 <davidhouse> hi dons :) all right thanks! just finished learning about monad transformers.
13:23:23 <davidhouse> i'm not actually hacking on anything at the moment
13:23:29 <davidhouse> looking to get my teeth into a project, actually
13:23:30 <dons> now who made a joke about leaking info through a covert dns channel
13:23:41 <davidhouse> now i've acquired enough knowledge about the language itself
13:23:45 <dons> you could write a lambdabot plugin?
13:23:53 <davidhouse> dons, to do what?
13:23:57 <dons> any fun tool out there that would be ameniable to lambdabotifying?
13:24:33 * davidhouse integrated his GHCi and hoogle the other day
13:24:49 <dons> how so?
13:25:00 <davidhouse> @wiki hoogle
13:25:00 <lambdabot> http://www.haskell.org/haskellwiki/hoogle
13:25:39 <davidhouse> quite easy. you install hoogle, then set up a :def
13:26:09 <vincenz> nifty
13:26:29 <davidhouse> it is. :) anyone know what powers @index?
13:26:32 <davidhouse> i'd like that as well
13:27:09 <dons> lambdabot :)
13:27:11 <dons> you want more info?
13:27:12 <vincenz> lol
13:27:27 <davidhouse> heh
13:27:30 <davidhouse> @where lambdabot
13:27:30 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
13:27:40 * dons is tweaking on espresso and sleater-kinney
13:27:54 <vincenz> ?
13:27:57 <dons> it's in Plugins/Haddock.hs
13:28:05 <vincenz> espresso and sleater-kinney?
13:28:12 <dons> coffee and music
13:28:18 <davidhouse> if i darks-get something, does it create a dir or just dump all the files in the current dir?
13:28:25 <dons> creates a dir
13:28:27 <davidhouse> good
13:28:28 <dons> \version
13:28:28 <lambdabot> lambdabot 3p330, GHC 6.4.1 (Linux i686 3.20GHz)
13:28:28 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
13:28:31 <dons> use that ^^
13:28:34 <dons> add -partial
13:28:39 <davidhouse> yep.
13:28:45 <dons> --partial
13:28:48 * rizzix tried to run lambdabot.. but the search plugin simply fails: @google test results in: search module failed: <socket: 5>: hLookAhead: resource vanished (Connection reset by peer)
13:28:57 <rizzix> :(
13:29:07 <dons> rizzix, maybe you need to tweak the proxy settings in Config.hs?
13:29:15 <dons> i think it uses a proxy by default (as an example)
13:29:15 <rizzix> did i set it to Nothing
13:29:31 <dons> hmm
13:30:11 <dons> don't know. need more info to debug it
13:31:05 <rizzix> anyway to turn on logging or something :P
13:31:10 <dons> \remember MarcEspie So, I was thinking of having backtraces in m4.
13:31:10 <lambdabot> Done.
13:31:41 <dons> rizzix, yep, stick some 'trace' or  'putStrLn' calls in MiniHTTP.hs
13:31:47 <dons> it's pretty short
13:31:53 <rizzix> k
13:32:35 <dons> I wish I had functions in html
13:32:48 <dons> maybe it's time HWN moved to a Haskell combinator setup
13:33:28 <ndm> dons, javascript, xsl - both "functions" in XSL
13:33:37 <ndm> * in HTML
13:33:38 <dons> boo on javascript
13:33:47 <ndm> arrrghhh - javascript is beautiful
13:34:04 <dons> \remember ndm javascript is beautiful
13:34:05 <lambdabot> Done.
13:34:13 <ndm> higher order functions, currying, closures, lambda statements - what more do you want out of an imperative language?
13:34:30 <dons> yeah, and the author was an ICFP guest speaker last year.
13:34:38 <ndm> i loved javascript way before that
13:34:42 <mauke> ndm: type inference
13:34:47 <dons> pity it's the worst ranking language in the language shootout
13:34:49 <ndm> mauke: yes, i would love that
13:34:54 <ndm> dons, speed is nothing
13:35:04 <dons> speed/lines/memory
13:35:04 <ndm> i still use Hugs, which doesn't even have a shootout entry :)
13:35:15 <dons> ndm is a man of strange tastes.. ;)
13:35:18 <ndm> javascript is beautiful
13:35:29 <ndm> its the nicest weakly typed language i know
13:35:33 <vincenz> people who say speed is nothing don't right *real* (TM) programs
13:35:35 <dons> no, I think Hugs does have a shootout entry now, but it's missing a few entries
13:35:38 <vincenz> s/right/write
13:35:51 <dons> i've seen some hugs commits anyway -- it's in cvs
13:36:01 <ndm> vincenz: in real life (TM) I get paid per hour
13:36:02 <dons> (since many of the recent ghc entries are h98)
13:36:11 <vincenz> ndm: point being?
13:36:17 <dons> ndm, so you're serious, you really like javascript?
13:36:21 <ndm> if i make the code 10 times faster than necessary, and charge an extra £20, thats bad
13:36:31 <ndm> dons, yes, totally serious, i think its great
13:36:48 <dons> hmm. maybe i'll have to look at the spec for javascript again.
13:36:54 <ndm> my languages of choice are Javascript, C# and Haskell
13:37:13 <ndm> http://www.nmitchell.co.uk/code/javascript.htm
13:37:32 <ndm> that page has most of what you need to do javascript, it was only after years i realised the inner beauty of javascript
13:38:07 <dons> ok, now this is getting freaky
13:38:15 <ndm> everything is a hash table, in a similar way to C = Array, Haskell = List, Javascript = Hash table
13:38:18 <dons> maybe you'll have to write a 'JavaScript for Haskell Programmers" tut?
13:38:28 <ndm> i could do, its not that hard
13:38:47 <dons> can I map and fold?
13:38:51 <ndm> yes
13:38:54 <rizzix> how
13:39:09 <ndm> define your own methods hanging off Array
13:39:13 <rizzix> ah
13:39:16 <ndm> (array is a lie, its actually a hash table)
13:39:26 <vincenz> ndm: well it depends what code you write... if you have to analyze certain gigabytes of data... and it takes t10 times longer, you got 10 times more time you're twiddling your thumbs
13:39:27 <davidhouse> a hash with ordered keys
13:39:35 <rizzix> ah i guess then you could say perl > all ;)
13:39:43 <ndm> but javascript has a prototype object, so you can "inject" code into an existing object
13:39:52 <rizzix> cool
13:39:59 <vincenz> ndm: ever looked at io?
13:40:00 <ndm> vincenz: true, however, all my clients just want a content management system in VBScript...
13:40:18 <ndm> vincenz: in Javascript?
13:40:34 <rizzix> i think he meant the IO lang
13:40:38 <dons> ndm, you still at uni? 
13:40:48 <dons> or have you graduated?
13:40:55 <ndm> yep, phd for anotherf 2 years
13:41:35 <vincenz> ndm: no the language
13:41:40 <ihope> Arr.
13:41:43 <ndm> never heard of it
13:41:51 <dons> anyone know how to execute haskell source files without .hs or .lhs extensions?
13:41:53 <ihope> Well, ncurses doesn't like my machine. What else is there?
13:41:55 <dons> can we do that yet?
13:41:59 <ihope> dons: rename them?
13:42:04 <dons> I know how to exec .lhs files
13:42:11 <dons> Lemmih, any ideas?
13:42:23 <dons> ihope, without renaming, or redirecting
13:42:30 <ndm> Yhc does that natively....
13:42:52 <dons> ok ok.
13:43:00 <ndm> @google io programming language
13:43:01 <lambdabot> http://www.iolanguage.com/
13:44:06 <ndm> vincenz: what does it have over javascript?
13:44:55 <ndm> no keywords usually leads to an obscure design and a less useable syntax
13:44:58 <vincenz> ndm: it's a very clean oo, object based system
13:45:03 <rizzix> its's a pure prototype based langauge
13:45:18 <ndm> i don't really like OO that much, its a bit of a fake concept
13:45:26 <ndm> and it still seems to lack types
13:45:27 <vincenz> ndm: I just thought it'd be interesting to you, given how you like javascript
13:45:32 <vincenz> ndm: erm... javascript is oo
13:45:40 <ndm> vincenz: thanks for pointing it out, i will take a look
13:45:43 <vincenz> prototype-based : oo without classes, or object-based oo
13:45:54 <ndm> vincenz: no, it has no objects, only hash tables and higher order functions
13:45:59 <vincenz> java oo: class-based object oriented
13:46:02 <dons> ndm, is there a Yhc commmit message list?
13:46:03 <vincenz> ndm: ah... look at lua then
13:46:12 <ndm> dons, no, but there is an RSS feed
13:46:20 <dons> i'm looking to include noteworthy yhc and jhc commits in HWN (as I already do for ghc)
13:46:25 <dons> ah, rss, ok.
13:46:28 <dons> got an url?
13:46:39 * dons <- lazy functional programmer
13:46:44 <ihope> :-)
13:47:01 <ndm> dons, yes, but it seems broken...
13:47:12 <ndm> http://www-users.cs.york.ac.uk/~malcolm/cgi-bin/darcsweb.cgi?r=yhc-devel;a=summary
13:47:27 <ndm> thats the main page, RSS hangs of that, and crashes the web server
13:47:27 <dons> also, anyone else working on a large project. if you commit something really cool -- let me know!
13:47:41 <dons> dcoutts ^^ this means you
13:47:44 <ndm> dons, if we commit cool things, we usually blog them
13:47:54 <ndm> http://yhc06.blogspot.com/
13:47:56 <dons> url for that then? or: ping me
13:48:24 <dons> I'd like to get more of a 'push' style for contributions to hwn, currently it's very centralised and up to me to crawl the various lists
13:48:25 <ndm> we put MVars in last week
13:48:28 <ndm> thats pretty notable
13:48:32 <dons> yes!
13:48:55 <dons> that's _exactly_ the kind of thing that I want to write about
13:49:09 <ndm> i'll forward you the email
13:49:16 <dons> so, CC me when that kind of thing happens :)
13:49:20 <dcoutts> dons, ok!
13:49:31 <dons> who else works on something big?
13:49:48 <vincenz> I've been wanting to rewrite an ocaml tool in haskell
13:49:55 <vincenz> but ... haskell is lacking in binary io :/
13:50:03 <dons> a tool that deletes ocaml and installs ghc?
13:50:07 <vincenz> hehe
13:50:08 <dcoutts> vincenz, no it's not
13:50:09 <dons> vincenz:
13:50:13 <dons> \oldwiki BinaryIo
13:50:13 <vincenz> dcoutts: yes it is
13:50:14 <lambdabot> http://www.haskell.org/hawiki/BinaryIo
13:50:38 <dcoutts> vincenz, ghc, haddock and other things use binary io
13:50:40 <dons> it supports binary IO very well. lambdabot makes strong use of it
13:50:47 <dons> as does hmp3, too.
13:51:06 <dons> .hi files are binary, for example, and ghc slurps them up
13:51:51 <kombinator> hello, ndm
13:52:07 <ndm> hi kombinator 
13:52:09 <dons> thanks ndm for the mail
13:52:58 <ndm> dons, no probs - i'll email you announcements from now on
13:53:08 <kombinator> I tried to run the tests with QUITE_PARANOID, but some of them appear to hang (= more work required)
13:53:09 <ndm> hopefully some day i'll be able to announce hoogle :)
13:53:21 <ndm> kombinator: they may do that normally, to be honest
13:53:26 <ndm> regarding 0 size mallocs
13:53:38 <ndm> can you give an example where they occur?
13:53:51 <ndm> in general i guess its best to avoid them, but not at the cost of more complex code
13:53:56 <kombinator> I can find it in 5 minutes
13:54:14 <ndm> never mind, maybe send an example to the list, since i'm sure it will be the first hting Tom asks :)
13:54:28 <ndm> Tom was away today, hence your patches aren't in yet
13:54:28 <kombinator> sure
13:54:48 <kombinator> but what do you mean by 'they may do that normall
13:54:51 <kombinator> y'?
13:54:54 <ndm> hoogle is currently at version 3 beta, on the front page of haskell.org, and still has never been officially announced....
13:55:11 <dons> should I update the hoogle that lambdabot uses?
13:55:17 <ndm> the tests may be broken under QUITE_PARANOID, i;m not sure anyone has ever tried that
13:55:33 <ndm> dons, no, not yet - i still haven't made the changes planned for ages
13:55:33 <kombinator> hm
13:55:54 <ndm> i finished my thesis proposal earlier today, which has been sapping valuable hacking time away...
13:56:01 <kombinator> all QUITE_PARANOID is supposed to do are consistency checks of the heap
13:56:06 <ndm> so hopefully will be hacking again soon
13:56:10 * ptolomy is ashamed that he hasn't been obsessively following the progress of Yhc.
13:56:21 <ndm> kombinator: not really sure what it does, but should work
13:56:27 <ndm> ptolomy: go read up on the Yhc blog
13:56:35 <ptolomy> I just found it, and did.
13:56:47 <ndm> Yhc will only become _killer_ once we have full library support and Hat trace generation
13:57:04 <ndm> once that happens, i'm giving up on GHC and Hugs forever
13:57:15 <dons> you think it can become killer? or niche (i.e. for portable systems?)
13:57:27 <ndm> a debugger will make it killer for developers
13:57:29 <kombinator> GHC will still have several killer features
13:57:46 <ndm> debugging is the killer feature, everything else is irrelevant for a developer
13:57:47 <Igloo> ndm: What do you mean by "full library support"?
13:57:58 <ndm> Igloo: haskell.org libraries
13:58:11 <dons> once I can run hmp3 or yi in it, I'll definitely be compiling with it. but I'm not sure what would have me actually switch my main compiler. hmm, interesting question.
13:58:12 <Igloo> Bah, debuggers are only a killer feature for people who write buggy code  :-)
13:58:16 <dons> :)
13:58:17 <dons> I agree.
13:58:26 <ndm> at least, i'd rather debugging over an additional type trick
13:58:34 <ndm> personally, i just want a debugging
13:58:36 <Igloo> ndm: DYM all of http://www.haskell.org/ghc/docs/latest/html/libraries/index.html ?
13:58:49 <ptolomy> Does GHC lack in debugging?
13:58:55 <ndm> Igloo: maybe 90% or above
13:59:00 <ndm> but yes, thats the target
13:59:26 <ndm> ptolomy: yes, it basically has little to no proper debugging - Debug.Trace is the most practical tool
13:59:45 <jyp> QuickCheck...
13:59:46 <ndm> Igloo: we have most of it building on local builds, and are working on patches to the main tree
13:59:47 * Philippa_ thinks yhc has the potential to be killer for evolving apps and enterprise-flavoured stuff, FWIW
14:00:20 <jyp> enterprise ?
14:00:22 <dons> I can see it taking the nhc/hugs niche for portable systems, embedded systems, maybe beginner/cs1A stuff
14:00:26 <ptolomy> Philippa_: Could you explain further?
14:00:31 <dons> which is a large part of the market
14:01:21 <ndm> i have to go now, but will be back in an hour, bye
14:01:38 <dons> i'm not sure what I'd need to actually switch. associated types?
14:01:56 <dons> type level debugging? :}
14:02:16 * dons makes joke about being sick of encoding 'trace' in the type systems to debug oleg's programs
14:02:30 <xerox> Hah.
14:02:35 <Igloo> Roughly speaking, if it supportd Control.Monad.State in some way, was truly portable and not much worse performing I'd probably at least partly switch
14:02:43 <davidhouse> "instance Module HaddockModule HaddockState where". what is an instance of what here?
14:02:58 <Igloo> I might need concurrency for some things too, and I think some of GHC's optimisations are critical for serious use
14:02:59 <dons> (HaddockModule HaddockState) is an instance of Module
14:03:08 <dons> HaddockState is the internal state type of the plugin
14:03:26 <davidhouse> right
14:03:33 <xerox> G'nite.
14:04:05 <dons> all the plugins use the same Module class interface, davidhouse, so check out Dummy or some of the others, to get the flavour
14:04:29 <dons> you need to define the names of the commands, the help, and a 'process' method, at the very least
14:05:11 <davidhouse> thanks dons :)
14:13:10 <ihope> A board-minded person is filled with full of love.
14:13:58 <davidhouse> dons, is Plugins.Dummy.Moo what you use when you get bored of writing haskell? :)
14:15:19 <dons> yeah, but it's too verbose, so we disabled it
14:15:26 <dons> when I get bored I usually
14:15:27 <dons> \yow
14:15:27 <lambdabot> Yow!  Am I in Milwaukee?
14:15:28 <ihope> Plugins.Dummy.Moo?
14:15:47 <ihope> @google Plugins.Dummy.Moo
14:15:48 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/Plugins/Dummy.hs
14:16:20 <dons> google is our friend
14:16:24 <davidhouse> http://www.cse.unsw.edu.au/~dons/lambdabot/Plugins/Dummy/Moo.hs
14:16:43 <ihope> @get-shapr
14:16:43 <lambdabot> shapr!!
14:16:47 <ihope> :-)
14:17:22 <dons> we shouldn't wake up shapr without good cause :}
14:17:58 <ihope> @faq Can Haskell solve the halting problem for Turing machines?
14:17:58 <lambdabot> The answer is: Yes! Haskell can do that.
14:18:20 <dons> oh, I'd forgotten that one
14:18:44 <dons> i think we should use @faq more often :)
14:18:57 <davidhouse> @faq can haskell make the tea?
14:18:58 <lambdabot> The answer is: Yes! Haskell can do that.
14:19:05 <ihope> @dummy
14:19:05 <lambdabot> dummy
14:19:09 <davidhouse> woo! :)
14:19:14 <ihope> Oh! How rude!
14:19:21 <davidhouse> @botsnack
14:19:21 <mauke> @faq how do I shot web?
14:19:21 <lambdabot> :)
14:19:21 <lambdabot> The answer is: Yes! Haskell can do that.
14:19:33 <davidhouse> @moo
14:19:34 <lambdabot> Maybe you meant: map more msg todo yow
14:19:53 <davidhouse> @id sausages
14:19:53 <lambdabot> sausages
14:20:00 <davidhouse> ooh! :)
14:20:05 <davidhouse> @id davidhouse: hello there
14:20:05 <lambdabot> davidhouse: hello there
14:20:09 <dons> id is part of a bit of a prelude I was going to add, now we have composition
14:20:12 <dons> it's useful for:
14:20:27 <dons> \. vixen . id elite go team!1
14:20:28 <lambdabot> uhuh
14:20:45 <dons> \. id . elite vixen you're cute
14:20:45 <lambdabot> I'D lIkE +O +|-|iNk I'/\/\ prEtTY
14:21:01 <dons> \reverse  foo
14:21:01 <lambdabot> Unknown command, try @listcommands.
14:21:04 <dons> bah
14:21:14 <Cale> @keal
14:21:15 <lambdabot> write an algorthim that generates the correct responses for a phone survey based on number of rings whether answered how quickly hung up on and the mood of the receiver
14:21:29 <dons> morning Cale
14:21:34 <Cale> morning :)
14:21:42 <dons> hehe
14:21:47 <ihope> Why not \. vixen elite and \. elite vixen?
14:21:48 <Cale> I've actually been here, but not watching IRC too closely.
14:22:00 <davidhouse> @help vixen
14:22:01 <lambdabot> sergeant curry's lonely hearts club
14:22:09 <Cale> looks like vincenz fixed whatever problem he had?
14:22:14 <davidhouse> @vixen so this is a test, then!
14:22:14 <lambdabot> what are you
14:22:44 <davidhouse> uhhuh.
14:22:58 <vincenz> Cale: yeah
14:23:13 * davidhouse remembers when Cale introduced him to haskell
14:23:46 <dons> introduced? you in Cale-land, davidhouse? or via irc?
14:24:12 <davidhouse> in the wonderful #math. he wrote a sieve for finding pythagorean triples, and nerdy2 came out with some hawt algorithm for solving some insane problem
14:24:18 <ski> ihope : backslahdot ?
14:24:25 <vincenz> Cale-land...freaky concept
14:24:31 <davidhouse> "find a 9 digit number such that the first n digits form a number divisible by n" or something
14:24:50 <vincenz> seems like something for the list monad
14:25:15 <vincenz> but erm
14:25:20 <vincenz> isn't that just 1XXXXXXXX
14:25:31 <vincenz> for 1
14:25:37 <davidhouse> yes
14:25:48 <davidhouse> but it must work for 1 <= n <= 9
14:26:42 <vincenz> ah
14:26:45 <ihope> Hmm...
14:26:46 <vincenz> for all n elof [1..9]
14:27:04 <ihope> Well, the next thing would make it 10, 12, 14, 16 or 18.
14:27:27 <vincenz> actually
14:27:33 <ihope> Let's say it's zero... then maybe we could have 102, then 1020, then 10200...
14:27:37 <vincenz> it would work for XY...
14:27:38 <ndm> Igloo, Yhc has concurrency :)
14:27:51 <ihope> 102000...
14:27:58 <vincenz> let me code it up
14:27:59 <ndm> although GHC optimisations will always be critical for certain things
14:28:22 <dons> ihope, did you see you made it into the hwn this week?
14:28:36 <ihope> Nope.
14:28:38 * ihope checks
14:28:44 <dons> \where hwn
14:28:45 <lambdabot> http://sequence.complete.org/
14:29:16 <ihope> :-)
14:29:21 <dons> hehe
14:29:23 <davidhouse> let isValid x n = (read $ take n $ show x) `mod` n == 0 in head [ x | x <- [100000000..999999999], all (isValid x) [1..3]] --probably works but v. slow
14:29:34 <davidhouse> err, that should be [1..9]
14:29:45 <vincenz> davidhouse: that should be VERY inefficient
14:29:47 <ihope> > let isValid x n = (read $ take n $ show x) `mod` n == 0 in head [ x | x <- [100000000..999999999], all (isValid x) [1..9]]
14:29:49 <davidhouse> i don't think a seive is the best option here
14:29:51 <lambdabot> Terminated
14:29:59 <vincenz> I think you should progressive sieve and building
14:30:08 <davidhouse> yep
14:30:45 <astrolabe> Are class instances automatically exported from modules?
14:32:16 <ihope> > 102000 `mod` 7
14:32:17 <lambdabot> 3
14:34:13 <ihope> 102000564
14:34:27 <ihope> > let isValid x n = (read $ take n $ show x) `mod` n == 0 in isValid 102000564
14:34:27 <lambdabot>  add an instance declaration for (Show (Int -> Bool))
14:34:58 <ihope> > let isValid x n = (read $ take n $ show x) `mod` n == 0 in map (isValid 102000564) [1..9]
14:34:59 <lambdabot> [True,True,True,True,True,True,True,True,True]
14:38:58 <vincenz> this is odd
14:38:59 <vincenz> http://rafb.net/paste/results/ehWqzF12.html
14:39:01 <vincenz> I get as answer []
14:39:46 * ihope force-feeds it his number
14:39:53 <davidhouse> ihope, oh, and you're not allowed to repeat digits
14:39:59 <ihope> Oh.
14:40:01 <vincenz> why is mine not working?
14:40:07 <davidhouse> and perhaps not use 0
14:40:12 <vincenz> I get NO answers
14:40:50 <vincenz> doh
14:40:52 <vincenz> it should be mod not div
14:40:59 <vincenz> woo
14:41:23 <vincenz> 2492 options
14:41:53 <ihope> :-)
14:42:45 <davidhouse> vincenz:, what are they?
14:42:49 <davidhouse> do they repeat digits?
14:43:24 <davidmccabe> So I think I'm finally starting to understand monads.
14:43:27 <davidmccabe> a little.
14:43:38 <vincenz> http://rafb.net/paste/results/EWB6V530.html
14:43:46 <vincenz> davidhouse: can't repeat numbers?
14:43:52 <davidhouse> vincenz:, nope :)
14:43:59 <davidhouse> (i forgot to mention that)
14:44:00 <astrolabe> davidmccabe: What do you think of them?
14:44:01 <vincenz> I can add that as a post filter :P
14:44:10 <davidmccabe> astrolabe: they seem like a bit of a hack, actually.
14:44:12 <ihope> vincenz: any line breaks for me?
14:44:18 <vincenz> ihope: nope
14:44:50 <ihope> unlines . map show?
14:44:50 <vincenz> davidhouse: you use monads?
14:45:04 <davidmccabe> anyways, I'm off.
14:45:05 <davidhouse> vincenz: i havne't done it yet
14:45:09 <astrolabe> davidmccabe: You have shocked me.  To me they seem the least hacky thing ever.  How are they a hack?
14:45:23 <vincenz> ok
14:45:24 <davidmccabe> astrolabe: obviously I don't understand them fully then :)
14:45:35 <astrolabe> Well, I don't either.
14:45:38 <davidmccabe> astrolabe: I must go now; I'll explain later if you want.
14:45:46 <astrolabe> ok.  bye for now.
14:46:18 <vincenz> davidhouse: so no 0's?
14:46:27 <davidhouse> vincenz: not sure about that
14:46:31 <vincenz> I guess not
14:46:36 <vincenz> just permutations of 123456789
14:48:21 <vincenz> how do you take an element out a list?
14:48:33 <vincenz> @hoogle a -> [a] -> [a]
14:48:33 <lambdabot> Data.List.intersperse :: a -> [a] -> [a]
14:48:33 <lambdabot> Data.List.delete :: Eq a => a -> [a] -> [a]
14:48:33 <lambdabot> Data.List.insert :: Ord a => a -> [a] -> [a]
14:49:52 <davidhouse> @type (!!)
14:49:52 <lambdabot> forall a. [a] -> Int -> a
14:50:00 <davidhouse> oh, as in remove it
14:50:03 <davidhouse> yeah.
14:50:12 * ihope works on his GADT'd factorial function
14:50:17 <davidhouse> delete l x = filter (/= x) l
14:50:17 <vincenz> > empty []
14:50:18 <lambdabot>  Not in scope: `empty'
14:50:22 <vincenz> > is_empty []
14:50:23 <lambdabot>  Not in scope: `is_empty'
14:50:24 <ihope> > null []
14:50:25 <lambdabot> True
14:52:13 <vincenz> just one foudn
14:52:18 <vincenz> 381654729
14:52:38 <vincenz> http://rafb.net/paste/results/cWeqJK29.html
14:53:00 <ihope> Yay!
14:53:08 <vincenz> ;)
14:53:14 <vincenz> clean at will
14:53:59 <vincenz> hehe
14:54:07 <vincenz> s' `mod` (length $ show s')
14:54:35 * vincenz is very stressed
14:56:23 <vincenz> http://oasis.yi.org:8080/repos/haskell/
14:57:44 <ihope> vincenz: I like my Haskell source served as text
14:59:00 <vincenz> ?
14:59:15 <vincenz> how
14:59:51 <ihope> The plaintext MIME type, whatever that is.
15:00:02 <ihope> @google plaintext mime
15:00:03 <lambdabot> http://www.expita.com/nomime.html
15:01:11 <vincenz> how do I do it
15:01:22 <davidhouse> send Content-Type: text/plain
15:02:07 <vincenz> text/x-haskell          hs
15:02:11 <vincenz> so that shoudl become text/plain
15:02:16 <vincenz> in /etc/mime.types
15:02:41 <davidhouse> tbh, it should stay as that
15:02:53 <ihope> Yeah, if you want me to be able to view your Haskell in my browser.
15:03:09 <davidhouse> ihope, get a browser that recognises it can display text/x-haskell ;)
15:03:27 <davidhouse> or get konqueror, which just opens it in kate (and then it's syntax highlighted, line-numbered and everything)
15:03:28 <ihope> :-)
15:03:36 <ihope> @where kate
15:03:36 <lambdabot> I know nothing about kate.
15:03:57 <davidhouse> text editor for KDE.
15:04:02 <davidhouse> :(
15:04:15 <vincenz> davidhouse: how?
15:04:23 <vincenz> davidhouse: how do I change firefox to accept text/x-haskell
15:04:25 <davidhouse> vincenz: how what?
15:04:42 <davidhouse> vincenz: just associate it with your favourite editor, that's the easiest way
15:04:48 <vincenz> hmm
15:04:49 <vincenz> how?
15:04:52 <davidhouse> no way that i know of to get it to display it in the browser
15:04:59 <vincenz> ok
15:05:01 <vincenz> oh well
15:05:02 <davidhouse> well, when you click it, it pops up a window asking what to do, right?
15:05:04 <vincenz> ihope: don't complain
15:05:07 <vincenz> it's a darcs repo
15:05:08 <vincenz> darcs get
15:05:10 * vincenz smacks ihope 
15:10:01 <astrolabe> Aw lambdabot gone :(
15:10:10 <ihope> @botsnack
15:14:08 <Cale> vincenz:
15:14:13 <Cale> special 1 = [1..9]
15:14:13 <Cale> special n = do
15:14:13 <Cale>     x <- special (n-1)
15:14:13 <Cale>     y <- [1..9]
15:14:13 <Cale>     let u = x * 10 + y
15:14:14 <Cale>     guard $ u `mod` n == 0
15:14:18 <Cale>     return u
15:15:06 <ihope> @index guard
15:15:14 <ihope> Right...
15:15:15 <mauke> ENOBOT
15:15:16 <Cale> It's in Control.Monad
15:15:38 <ihope> What's the type?
15:15:55 <mauke> Bool -> mz () or something like that
15:16:02 <vincenz> Cale: that won't do perms only
15:16:04 <Cale> guard :: (MonadPlus m) => Bool -> m ()
15:16:31 <Cale> vincenz: ah, you only want numbers which are permutations of [1..9]. I suppose it's easy enough to filter those out after :)
15:16:42 <vincenz> Cale: it's extra work ;)
15:16:42 <Cale> or add a second guard
15:16:43 <ihope> Heh...
15:18:15 <ihope> Okay. I'm SURE I spelled "predecessor" wrong.
15:18:59 <vincenz> Cale: it's curious there's exactly ONE solution for the perm case
15:19:28 <ihope> Hmm, I'll need to add another thread to my factorial function that takes the predecessor of a natural number.
15:19:32 <Cale> guard $ y `notElem` digits x
15:19:51 <vincenz> curse you
15:20:25 <Cale> digits 0 = []
15:20:25 <Cale> digits x = x `mod` 10 : digits (x `div` 10)
15:21:25 <Cale> or just filter the [1..9]
15:21:45 <Cale> y <- filter (`notElem` digits x) [1..9]
15:22:10 <Cale> which happens to be the same as
15:22:16 <ihope> Let's see... I'm moving things from the right addend to the left.
15:22:19 <Cale> y <- [1..9] \\ digits x
15:22:44 <vincenz> ok
15:22:57 <vincenz> darcs recorded new version
15:23:04 <vincenz> http://oasis.yi.org:8080/repos/haskell
15:23:43 <vincenz> it'd be cool to have a paste-like site with a darcs-repo as backend
15:24:02 <vincenz> anywas
15:24:06 <vincenz> rebooting for a bit of AA
15:24:06 <Cale> (that avoids the extra line)
15:24:10 * vincenz waves
15:24:11 <Cale> AA?
15:24:17 <vincenz> america's army
15:24:19 <Cale> ah
15:26:30 <Cale> I wonder how it works out in other bases
15:26:50 <ihope> It's easy-ish in binary.
15:27:35 <ihope> Binary: 1. Ternary: 12. Quaternary: 123 (right?)
15:27:42 * vincenz rebooted to windows
15:28:00 <ihope> And you managed to keep your IRC connection. Amazing.
15:28:01 <vincenz> Anyone read the paper "Generalising Monads to Arrows"
15:28:05 <vincenz> I have a question about something specific
15:28:11 <vincenz> ihope: yeah... I have my desktop with screen
15:28:14 <vincenz> so I can ssh from work too
15:28:20 * vincenz is always on his lappy
15:28:21 <ihope> Ah.
15:28:34 <vincenz> anyone reaad that paper
15:28:38 <vincenz> I have a question about stream processors
15:28:45 <ihope> What be it?
15:28:50 <vincenz> where put :: b -> SP a b -> SP a b
15:29:01 <vincenz> get :: (a -> SP a b) -> SP a b
15:29:04 <vincenz> they say that
15:29:20 <vincenz> sp1 >>> Put c sp2 = Put c (sp1 >>> sp2)
15:29:25 <vincenz> doesnt' this move the c ahead of sp1?
15:29:45 <ihope> Well, I'm not sure how put and get work...
15:30:06 <vincenz> hence me asking about people having read that paper
15:30:09 <Cale> *Main> map special [2..14]
15:30:09 <Cale> [[1],[],[27,57],[],[2285,7465],[],[874615,1391089,1538257],[],[381654729],[],[],[],[559922224824157]]
15:30:34 <Cale> hmm
15:30:37 <ihope> Ternary doesn't have any?
15:30:38 <Cale> something seems off
15:30:45 <ihope> That's unpossible!
15:31:03 <Cale> 12 definitely seems like a solution in ternary anyway :)
15:32:39 <vincenz> anyone about stream procssors?/
15:32:46 <ihope> What should I do when I don't want to left-align some text but there's no reason to right-align it?
15:33:46 <Cale> oh
15:33:54 <Cale> of course 12 isn't a solution in ternary
15:34:00 <Cale> since it's not divisible by 2 :)
15:34:07 <ihope> It isn't?
15:34:19 <ihope> Oh, what do you know...
15:35:38 <ihope> > [..3]
15:35:49 <ihope> Yes, I know.
16:09:09 <ihope> Are MVars garbage collected once I stop using them?
16:09:09 <Lemmih> Yes.
16:34:08 <adu> is it appropriate to talk about parsers in here?
17:14:48 <SyntaxNinja> haskell-related parsers?
17:14:52 <adu> no
17:14:52 <adu> just parsers
17:14:52 <rizzix> :)
17:14:53 <ihope> #parsers
17:14:55 <ihope> Erm, that was supposed to be a /join.
17:14:55 <ihope> Oh well.
17:15:00 <ihope> Go there to discuss parsers :-)
17:15:00 * vincenz heads to bed
17:15:00 <vincenz> ihope: noone there
17:15:00 <ihope> Do the mailing lists support attachments, or should I stick this giant threaded factorial function into a pastebin and link it?
17:15:00 <adu> i can't find any chan about parsers
17:15:00 <adu> i tried #bison, #flex, #lex, #yacc, #parser* #gram*
17:15:00 <ihope> Did you try #parsers?
17:15:00 <SyntaxNinja> adu: ask away. maybe someone can answer.
17:15:00 <adu> ihope: ya, that was part of #parser*
17:15:00 <bynari> adu: IRC isn't the only place to ask questions
17:15:00 <ihope> Ah.
17:15:00 <bynari> Mailing lists, forums, usenet..
17:15:00 <SyntaxNinja> adu: or maybe ask on #haskell-blah
17:15:00 <adu> http://en.wikipedia.org/wiki/LR_parser talks about "item sets" and "states" and i don't understand what they mean
17:15:00 <ihope> You could ask at http://en.wikipedia.org/wiki/Talk:LR_parser :-)
17:15:00 <Pseudonym> Until you've constructed a few LR parsers by hand, you'll never get it. :-)
17:15:00 <adu> ah
17:15:00 <Pseudonym> Shall we try?
17:15:00 <Pseudonym> Give me a small grammar.
17:15:00 <Pseudonym> Oh, and have a text editor open.  It's going to be a bumpy ride.
17:15:00 <adu> um, how about expr = | expr op expr |( expr )
17:15:00 <Pseudonym> That's ambiguous.
17:15:00 <adu> it is?
17:15:00 <Pseudonym> Yes.
17:15:00 <adu> ok, then i need to learn more
17:15:00 <Pseudonym> How about this:
17:15:00 <Pseudonym> S -> T #
17:15:00 <Pseudonym> T -> T + B
17:15:00 <Pseudonym> T -> B
17:15:00 <Pseudonym> B -> n
17:15:00 <Pseudonym> B -> ( T )
17:15:00 <adu> what does the -> mean?
17:15:00 <Pseudonym> That's unambiguous.
17:15:00 <Pseudonym> That means ::=
17:15:05 <adu> is that the same as :: or = ?
17:15:05 <adu> ok
17:15:05 <Pseudonym> We'll use ::= if that's better.
17:15:05 <Pseudonym> I'm using # as the terminal symbol here.
17:15:05 <Pseudonym> S is, obviously, the start symbol.
17:15:05 <adu> so like (n + n)# would be valid input?
17:15:05 <Pseudonym> Right.
17:15:05 <adu> ok
17:15:05 <Pseudonym> Now we'll start by giving the rules unique numbers.  Take a record of this:
17:15:05 <Pseudonym> S -> T # {0}
17:15:05 <Pseudonym> T -> T + B {1}
17:15:05 <Pseudonym> T -> B {2}
17:15:05 <Pseudonym> B -> n {3}
17:15:05 <Pseudonym> B -> ( T ) {4}
17:15:05 <Pseudonym> I've put them in curly braces, because they'll also double as semantic actions, like in yacc.
17:15:05 <adu> ok
17:15:05 <Pseudonym> Now, here's what LR parsing is:
17:15:05 <adu> ya i've used lex and yacc before, so i understand that
17:15:05 <Pseudonym> OK.
17:15:05 <Pseudonym> LR parsing is shift-reduce parsing, from left-to-right, producing a rightmost derivation in reverse.
17:15:05 <adu> so are there 5 "item sets" that correspond to those 5 rules?
17:15:05 <Pseudonym> You don't have to understand that, except for the "shift-reduce" part.
17:15:13 <Pseudonym> No!
17:15:13 <adu> ok
17:15:13 <Pseudonym> I'll explain items and item sets in a moment.
17:15:13 <adu> i understand "shift" and "reduce"
17:15:13 <adu> but not the derivation part
17:15:13 <Pseudonym> That's okay, then.
17:15:13 <Pseudonym> You understand that you maintain a stack, and at each step, you either shift a symbol from the input onto the stack, or you reduce a rule.
17:15:13 <adu> right
17:15:13 <adu> is the "state" just the position in the token input?
17:15:13 <Pseudonym> No.
17:15:13 <Pseudonym> Bear with me.
17:15:13 <adu> ok, sorry
17:15:13 <ihope> Dang! I forgot to apply the constructors...
17:15:13 <ihope> Forgetting to apply the constructors is Bad.
17:15:13 <Pseudonym> A grammar is LR(k) if you can correctly decide whether to shift or reduce based on only what you've seen so far, and the next k  symbols in the input stream.
17:15:13 <adu> right
17:15:13 <Pseudonym> What Don Knuth proved if any algorithm can correctly decide this, then a DFA can.
17:15:13 <ihope> What's a DFA?
17:15:13 <Pseudonym> Deterministic finite automaton.
17:15:13 <Pseudonym> adu: You know what a DFA is, right?
17:15:13 <adu> nope
17:15:13 <Pseudonym> Ah.
17:15:13 <Pseudonym> You don't know about regular expressions, NFAs and DFAs?
17:15:13 <adu> i know about RegEx
17:15:13 <Pseudonym> Ah.
17:15:13 <adu> but just from using unix alot, never took a class or anything
17:15:13 <Pseudonym> OK.  A DFA is an abstract machine that has a finite number of states.
17:15:13 <adu> like a turing machine?
17:15:13 <Pseudonym> Exactly like a Turing machine.
17:15:13 <adu> ok
17:15:13 <adu> i know a turning machine
17:15:13 <Pseudonym> A Turing machine has a tape, too.
17:15:13 <adu> right
17:15:13 <Pseudonym> A DFA doesn't.
17:15:13 <adu> ok
17:15:13 <Pseudonym> It's just the machine with states, so it has no instructions for tape control.
17:15:13 <ihope> NFA is nondeterministic?
17:15:13 <Pseudonym> Right.
17:15:13 <Pseudonym> Just like a nondeterministic Turing machine.
17:15:13 <gzl> ihope: but DFA == NFA, but NTM > DTM
17:15:13 <dons> anyone had any experience making a livecd-style bootable usb key running debian?
17:15:13 <Pseudonym> An LR machine is basically like a Turing machine, except instead of tape control, it has two types of operation: shift and reduce.
17:15:13 <ihope> gzl: what about a quantum Turing machine?
17:15:13 <Pseudonym> And it maintains a stack using those twp operations.
17:15:13 <gzl> ihope: I don't know. 
17:15:13 <adu> ok
17:15:13 <Pseudonym> So when you talk about LR machine states, they're just like TM states.
17:15:13 <adu> ok
17:15:13 <adu> the state of the whole machine
17:15:13 <Pseudonym> Right.
17:15:13 <adu> k
17:15:13 <Pseudonym> The state of an LR machine is the machine state, plus the stack, plus the unconsumed input.
17:15:13 <Pseudonym> Just like the state of a TM is the machine state plus the tape.
17:15:13 <Pseudonym> With me?
17:15:13 <adu> yup
17:15:13 <Pseudonym> OK.
17:15:13 <gzl> ihope: actually, I should be clearer. a DTM can simulate an NTM. the main issue is whether the DTM is slower than the NTM and by how much
17:15:13 <gzl> ihope: but this is basically P = NP
17:15:13 <Pseudonym> Now, the way you construct the machine is using sets of LR items.
17:15:13 <adu> ok
17:15:13 <Pseudonym> An LR item is a representation of where in the rules you can be.
17:15:13 <adu> ok
17:15:13 <Pseudonym> So the start item is: S -> _._ T # {0}
17:15:13 <adu> ok
17:15:13 <Pseudonym> The _._ marker, by the way, you might see in yacc's output if you ask it to dump the machine state.
17:15:13 <adu> thats the position, right?
17:15:13 <Pseudonym> Right.
17:15:13 <gzl> ihope: actually, it's exactly P = NP. :)
17:15:13 <ihope> :-)
17:15:13 <Pseudonym> So the start item, if you like, is when you're parsing a start symbol , and haven't consumed any input yet.
17:15:13 <Pseudonym> An item is a rule, plus a marker somewhere on the right hand side.
17:15:13 <adu> so is that item-set 0?
17:15:13 <Pseudonym> (Note for the nitpickers: This is an LR(0) item.  But we have to start somewhere.)
17:15:13 <Pseudonym> No.
17:15:13 <Pseudonym> The item set for the start state is the closure of the initial item set.
17:15:13 <Pseudonym> You compute the closure by looking for nonterminals right after the marker.
17:15:14 <Pseudonym> So in this case, you're about to consume a T.
17:15:14 <Pseudonym> That means you are also at the start of a T rule.
17:15:14 <adu> ok item-set 0 is S -> . T # and S -> T . # and S -> T # .
17:15:14 <Pseudonym> No, it's this:
17:15:14 <Pseudonym> S -> . T # {0}
17:15:14 <Pseudonym> T -> . T + B {1}
17:15:14 <Pseudonym> T -> . B {2}
17:15:14 <Pseudonym> B -> . n {3}
17:15:14 <Pseudonym> B -> . ( T ) {4}
17:15:14 <adu> oh
17:15:14 <Pseudonym> The reason is that when you're before a T, you're also at the start of any rule with T on the LHS.
17:15:14 <adu> right
17:15:14 <Pseudonym> Once you've added those rules, you notice that you're also right before a B.
17:15:14 <Pseudonym> In rule {2}.
17:15:14 <Pseudonym> Hence, you're at the start of any B rule.
17:15:14 <Pseudonym> And so on until you can't add any more items.
17:15:14 <Pseudonym> So that's the item set.
17:15:14 <adu> ic, i think i get it
17:15:14 <Pseudonym> OK.
17:15:14 <Pseudonym> We'll call the start state q0
17:15:14 <Pseudonym> As you can see, there are four possible symbols you can shift in this state.  T, B, n and (
17:15:14 <Pseudonym> T and B are special because they're nonterminals.  We'll deal with those later when we try to understand what the automaton means.
17:15:14 <adu> ok
17:15:14 <Pseudonym> But for now, we can represent this state as:\
17:15:14 <Pseudonym> q0 = T q1 + B q2 + n q3 + ( q4
17:15:14 <Pseudonym> Where those states are closures of other item sets.
17:15:14 <Pseudonym> Looking at q3 first:
17:15:14 <Pseudonym> The initial item set for q3 is B -> n . {3} and nothing else.
17:15:14 <Pseudonym> We don't need to add anything to the closure because there is no marker to the left of a nonterminal.
17:15:14 <Pseudonym> Right?
17:15:14 <adu> um
17:15:14 <Pseudonym> The closure is formed by looking for nonterminals which are directly after markers.
17:15:14 <adu> whats the closure? and whats the marker?
17:15:14 <Pseudonym> The marker represents "where we are" in the rules.
17:15:14 <adu> the marker = "." ?
17:15:14 <Pseudonym> Right.
17:15:14 <adu> k
17:15:14 <Pseudonym> So if you're in the start state, and you shift an "n", then you're in the rule B -> n . {3}
17:15:14 <adu> ok
17:15:14 <adu> got it
17:15:14 <Pseudonym> That's the whole item set for that state.
17:15:14 <adu> for q3?
17:15:14 <Pseudonym> Yes.
17:15:14 <adu> ok
17:15:14 <Pseudonym> So this state is a reduce state.  You just reduce by {3}.
17:15:14 <adu> ok
17:15:14 <Pseudonym> OK.
17:15:14 <Pseudonym> Now let's consider state q1.
17:15:14 <Pseudonym> S -> . T # {0}
17:15:14 <Pseudonym> T -> . T + B {1}
17:15:14 <Pseudonym> T -> . B {2}
17:15:14 <Pseudonym> B -> . n {3}
17:15:14 <Pseudonym> B -> . ( T ) {4}
17:15:14 <adu> igtg ; brb
17:15:14 <Pseudonym> That's q0 again.
17:15:14 <Pseudonym> The item set.
17:15:14 <Pseudonym> OK.
17:15:14 * Pseudonym can't remember how many times he's constructed LR machines by hand
17:16:13 <rizzix> Hello idtt2s
17:16:15 <rizzix> :)
17:16:18 <idtt2s> :D
17:16:20 <idtt2s> wow
17:16:29 <idtt2s> very nice
17:16:31 <rizzix> It is.
17:17:37 <rizzix> So is #math ;)
17:17:42 <idtt2s> lol
17:17:57 <idtt2s> Ok, see you there :D
17:23:15 <adu> sorry
17:23:48 <ihope> @get-ihope
17:23:48 <lambdabot> Unknown command, try @listcommands.
17:23:48 <adu> Pseudonym: by hand meaning on paper or without lex/yacc?
17:23:50 <ihope> Hmm.
17:24:55 <Pseudonym> Right.
17:25:05 <Pseudonym> On paper, or in a text editor.
17:25:36 <Pseudonym> OK, would you like a moment to look over where we got to?
17:25:52 <adu> sorry i forgot i have an informal class right about now so if i leave in 5 mins, don't be offended
17:25:54 <adu> sure
17:26:03 <Pseudonym> No problem.
17:26:16 <adu> we have 5 rules, and we can be at many places within those rules
17:26:22 <Pseudonym> In the mean time, I'll keep typing.
17:26:36 <Pseudonym> S -> . T # {0}
17:26:37 <Pseudonym> T -> . T + B {1}
17:26:37 <Pseudonym> T -> . B {2}
17:26:38 <Pseudonym> B -> . n {3}
17:26:40 <Pseudonym> B -> . ( T ) {4}
17:26:46 <Pseudonym> That's the item set for q0.
17:26:46 <adu> ok
17:27:10 <Pseudonym> Let's look at q1, which is where you go to when you shift a T nonterminal symbol.
17:27:10 <adu> so q1 is T -> T . + B ?
17:27:12 <Pseudonym> The item set is:
17:27:32 <Pseudonym> S -> T . # {0}
17:27:32 <Pseudonym> T -> T . + B {1}
17:27:47 <Pseudonym> Note that there are two items in the initial item set here.
17:28:09 <adu> ok
17:28:24 <Pseudonym> Once again, there is nothing to add to the closure here.
17:28:34 <Pseudonym> Since there is no marker to the left of a nonterminal.
17:28:53 <adu> ok
17:29:24 <Pseudonym> In this case, there are two actions.  If you shift a "+", you go to some other state with the initial item set T -> T + . B {1}
17:29:35 <Pseudonym> If you shift a #, you go to a reduce state for {0}.
17:29:48 <Pseudonym> This state is distinguished, and it's usually called the "accept state".
17:29:56 <Pseudonym> Because it's a state which represents the end of parsing.
17:30:10 <Pseudonym> The usual rule is that when you try to shift #, you accept.
17:30:26 <adu> ya i've heard that before "acc"
17:30:28 <Pseudonym> Right.
17:30:38 <Pseudonym> Now, there's one more feature that you should be aware of.
17:30:45 <Pseudonym> Consider state q4.
17:30:55 <adu> ok
17:30:59 <Pseudonym> It's the state you go to from q0 when you shift a (
17:31:06 <Pseudonym> The initial item set is:
17:31:13 <Pseudonym> B -> ( . T ) {4}
17:31:16 <adu> so q4 is B -> . ( T ) or B -> ( . T )?
17:31:25 <Pseudonym> Not quite.
17:31:35 <adu> why not B -> . ( T ) ?
17:31:45 <Pseudonym> You missed a couple.
17:31:52 <adu> oh
17:31:53 <Pseudonym> T -> . T + B {1} and T -> . B {2}
17:32:02 <Pseudonym> And B -> . n {3}
17:32:21 <Pseudonym> Here's the full item set:
17:32:33 <Pseudonym> B -> ( . T ) {4}
17:32:33 <Pseudonym> T -> . T + B {1}
17:32:33 <Pseudonym> T -> . B {2}
17:32:33 <Pseudonym> B -> . n {3}
17:32:33 <Pseudonym> B -> . ( T ) {4}
17:32:42 <Pseudonym> Now, two things to note.
17:32:44 <adu> oh
17:32:47 <Pseudonym> 1. The same rule appears twice in the item set.
17:32:59 <adu> ic, so the item set is all posibilities of what could come after "." ?
17:33:06 <Pseudonym> Right.
17:33:08 <adu> oooooh
17:33:15 <Pseudonym> It's the set of all rules that you can be in, and where you can be in them.
17:33:21 <adu> ic
17:33:36 <Pseudonym> The second thing to note:
17:33:45 <adu> let me see if i can do q2
17:33:50 <Pseudonym> If you shift "(" from this state, you end up in q4 again.
17:33:58 <Pseudonym> Do you see this?
17:46:50 <Pseudonym> q4 = ( q4 + ...
18:11:06 <adu> B -> . B
18:11:06 <adu> B -> . n
18:11:07 <Pseudonym> No, there's no B -> . B
18:11:07 <adu> B -> . ( T )
18:11:07 <Pseudonym> Because there's no rule B -> B
18:11:07 <adu> ack T -> . B sorry
18:11:07 <Pseudonym> Right./
18:11:07 <adu> those three for q2?
18:11:07 <Pseudonym> q2 is where you get to if you shift B from q0, right?
18:11:07 <Pseudonym> Here's the item set for q0:
18:11:07 <Pseudonym> S -> . T # {0}
18:11:07 <Pseudonym> T -> . T + B {1}
18:11:07 <Pseudonym> T -> . B {2}
18:11:07 <Pseudonym> B -> . n {3}
18:11:07 <Pseudonym> B -> . ( T ) {4}
18:11:07 <Pseudonym> If you shift B, the item set is T -> B . {2}
18:11:07 <adu> ok
18:11:07 <adu> oh
18:11:07 <Pseudonym> Shifting a symbol moves the marker.
18:11:07 <adu> i just realized i don't understand your q# notation
18:11:07 <Pseudonym> Ah.
18:11:07 <Pseudonym> q0 is just the name of a state.
18:11:07 <Pseudonym> q0, q1, q2...
18:11:07 <Pseudonym> I'm just grabbing names as I need them.
18:11:07 <adu> but is q3 the name for B -> . n or B -> n . ?
18:11:07 <Pseudonym> B -> n .
18:11:07 <adu> hmm
18:11:07 <Pseudonym> q0 = ... + n q3 + ...
18:11:07 <Pseudonym> That means that if you shift an n, you end up in q3.
18:11:07 <adu> ya i didn't understand that notation cuz i don't see how + and * apply to states
18:11:07 <Pseudonym> In this case, + means "or".
18:11:07 <adu> oh
18:11:07 <adu> ok
18:11:07 <adu> what does "T q1" mean?
18:11:07 <Pseudonym> That means if you shift a T, you go to q1.
18:11:07 <Pseudonym> This is actually DFA notation.
18:11:07 <adu> ok
18:11:07 <Pseudonym> Sorry, I should have explained.
18:11:21 <adu> its ok, i should've asked earlier
18:11:21 <Pseudonym> Do you see that from q4, if you shift a "(", you go back to q4?
18:11:21 <Pseudonym> If you compute the item set, you'll find it's identical to that of q4.
18:11:21 <adu> ok, i think i understand q0 q2 q3
18:11:21 <Pseudonym> OK.
18:11:21 <adu> i'm still confused about q1 and q4
18:11:21 <Pseudonym> Ignore q1 for the moment.
18:11:21 <Pseudonym> Just treat # as a normal symbol and {0} as a normal reduction.
18:11:21 <Pseudonym> We'll look at q4.
18:11:21 <adu> if you shift a ( on q4 then don't you go back to q1?
18:11:21 <Pseudonym> No.
18:11:21 <Pseudonym> The initial item set for q4 is B -> ( . T ) {4}
18:11:21 <adu> ok
18:11:21 <Pseudonym> The closure of this is:
18:11:21 <Pseudonym> B -> ( . T ) {4}
18:11:21 <Pseudonym> T -> . T + B {1}
18:11:21 <Pseudonym> T -> . B {2}
18:11:21 <Pseudonym> B -> . n {3}
18:11:21 <Pseudonym> B -> . ( T ) {4}
18:11:21 <adu> ok
18:11:21 <Pseudonym> Now look at all of the rules which have a "(" to the right of the marker.
18:11:21 <Pseudonym> Sorry, all of the ITEMS.
18:11:21 <Pseudonym> The only one is the last one.
18:11:21 <adu> the first one
18:11:21 <adu> oh "right", last one
18:11:21 <Pseudonym> No, "(" to the _right_ of the marker.
18:11:21 <Pseudonym> Right.
18:11:21 <adu> sorry
18:11:21 <Pseudonym> So if you shift a "(" from this state, you go to B -> ( . T ) {4}
18:11:21 <adu> oh
18:11:21 <Pseudonym> Which is the same as q4.
18:11:21 <adu> ok
18:11:21 <Pseudonym> While I think of it, there's another thing to consider here.
18:11:21 <Pseudonym> Which speeds things up a bit.
18:11:21 <adu> whats that?
18:11:21 <Pseudonym> I talk about "initial item sets".
18:11:21 <Pseudonym> Which is what you get before you compute the closure.
18:11:21 <adu> ok
18:11:21 <Pseudonym> It turns out that you can identify states from that alone.
18:11:21 <Pseudonym> If you were implementing this in code, you'd have some lookup table where you get an item set, and look for a previous state that matches.
18:11:22 <Pseudonym> e.g. a hash table
18:11:22 <Pseudonym> So you'd compute the item set for where you go when you shift a "(" from q4, look in the hash table, and find q4 again.
18:11:22 <Pseudonym> Right?
18:11:22 <adu> ok
18:11:22 <Pseudonym> It turns out you only need to look for the initial item set.
18:11:22 <adu> what Wikipedia calls the "action table"?
18:11:22 <Pseudonym> We'll talk about the action table later.
18:11:22 <adu> ok
18:11:22 <Pseudonym> At the moment, we're just building the machine.
18:11:22 <Pseudonym> The action table is what you need to actually run it.
18:11:22 <adu> is that only true for out 5 rules or all LALR(1) grammars?
18:11:22 <adu> the initial item set -> state consideration
18:11:22 <Pseudonym> It's trule for all LR(k) parsers.
18:11:22 <adu> ok
18:11:22 <Pseudonym> Both deterministic and nondeterministic.
18:11:22 <adu> ok
18:11:22 <Pseudonym> The difference is: 1) items look a bit different if k > 0
18:11:22 <Pseudonym> 2) LALR parsers are constructed from LR(0) parsers.
18:11:22 <Pseudonym> We'll get to that later if you care.
18:11:22 <adu> maybe
18:11:22 <Pseudonym> For the moment, LR(0) is enough.
18:11:22 <adu> ok
18:11:22 <Pseudonym> i.e. it's difficult enough to understand LR(0) without adding complexity.
18:11:22 <Pseudonym> Now, given that, you should be able to construct an LR(0) machine for this grammar.
18:11:22 <adu> so what about B -> ( T . ) ?
18:11:22 <Pseudonym> Well, there's only one symbol you can shift there.
18:11:22 <adu> would that be state q5?
18:11:22 <Pseudonym> B -> ( T ) . {3}
18:11:22 <Pseudonym> The state numbers are just names.
18:11:22 <Pseudonym> I pull a new state as I need it.
18:11:22 <adu> ok
18:11:22 <Pseudonym> Go ahead and construct the machine.
18:11:23 <Pseudonym> I will add one thing for completeness:
18:11:23 <Pseudonym> This grammar had no lambda rules.
18:11:23 <Pseudonym> Rules of the form: T ->
18:11:23 <Pseudonym> Where the RHS is empty.
18:11:23 <Pseudonym> They're not difficult to handle, but they usually need a little extra code.
18:11:23 <adu> q0 = T q1 + B q2 + n q3 + ( q4
18:11:23 <adu> q4 = T q5
18:11:23 <adu> q5 = )
18:11:23 <adu> q1 = + q6
18:11:23 <adu> q6 = n q3 + ( q4
18:11:23 <adu> ?
18:11:23 <Pseudonym> errr... no
18:11:23 <Pseudonym> Let's look at q4.
18:11:23 <adu> ok
18:11:23 <Pseudonym> Here's the item set after closure:
18:11:23 <Pseudonym> B -> ( . T ) {4}
18:11:23 <Pseudonym> T -> . T + B {1}
18:11:23 <Pseudonym> T -> . B {2}
18:11:23 <Pseudonym> B -> . n {3}
18:11:23 <Pseudonym> B -> . ( T ) {4}
18:11:23 <Pseudonym> What symbols are there to the RHS of the marker?
18:11:23 <Pseudonym> There's T, B, n and (
18:11:23 <Pseudonym> That means you can shift any of those four symbols.
18:11:23 <adu> right
18:11:23 <adu> ooooh
18:11:23 <adu> so q4 = T q1 + B q2 + n q3 + ( q4
18:11:23 <Pseudonym> No.
18:11:23 <Pseudonym> What is the item set if you shift a T?
18:11:23 <adu> T -> T . + B T -> B . B -> n . B -> ( . T )
18:11:23 <Pseudonym> Could you put those on separate lines please?
18:11:23 * Pseudonym can't read those
18:11:23 <adu> that needed linebreaks
18:11:23 <Pseudonym> Or put in commas or something.
18:11:23 <adu> T -> T . + B
18:11:23 <adu> T -> B .
18:11:23 <adu> B -> n .
18:11:23 <adu> B -> ( . T )
18:11:23 <Pseudonym> Nope.
18:11:23 <Pseudonym> Look at the item set again.
18:11:23 <Pseudonym> There are two items that have a T to the right of the marker.
18:11:23 <Pseudonym> If you shift those markers over the T's, you get:
18:11:23 <Pseudonym> B -> ( T . ) {4}
18:11:23 <Pseudonym> T -> T . + B {1}
18:11:24 <adu> ok
18:11:24 <Pseudonym> Now the important point is that the item set is differetn from that of q1.
18:11:24 <Pseudonym> So if you shift a T from q4, you can't be in q1.
18:11:24 <Pseudonym> Two states are the same if and only if their item sets are the same.
18:11:24 <Pseudonym> And it turns out that they're also the same if and only if their _initial_ item sets are the same.
18:11:24 <Pseudonym> (The "initial item set" is often called the "kernel".)
18:11:24 <adu> so the closure of shifting a T in q4 has the posibilities of either shifting a "+" or ")"
18:11:24 <Pseudonym> Right.
18:11:24 <adu> ok
18:11:24 <adu> which is a new posibilitiy
18:11:24 <adu> q7 ?
18:11:24 <adu> ok so what is the initial item set for q1 ?
18:11:24 <Pseudonym> S -> T . # {0}
18:11:24 <Pseudonym> T -> T . + B {1}
18:11:24 <adu> and what happens if you shift a "+" ?
18:11:24 <Pseudonym> T -> T + . B {1}
18:11:24 <Pseudonym> Which you then compute the closure of.
18:11:24 <adu> ok
18:11:24 <adu> which is:
18:11:24 <adu> T -> T + . B
18:11:24 <adu> B -> . n {3}
18:11:24 <adu> B -> . ( T ) {4}
18:11:24 <Pseudonym> Right.
18:11:24 <Pseudonym> You got the idea.
18:11:24 <Pseudonym> And from there, you can shift a B, n or (
18:11:24 <adu> so would we have to come up with a state for that?
18:11:24 <Pseudonym> Let's look.
18:11:24 <Pseudonym> If you shift an n, what's the item set?
18:11:24 <adu> B -> n .
18:11:24 <Pseudonym> Do you have a state for that already?
18:11:24 <adu> q3
18:11:26 <Pseudonym> Right.
18:11:34 <Pseudonym> Now how about if you shift a (?
18:12:01 <adu> q4
18:12:57 <Pseudonym> Right.
18:12:57 <Pseudonym> What about if you shift a B?
18:13:17 <adu> T -> T + B .
18:13:32 <Pseudonym> Any state for that?
18:13:35 <adu> nope
18:13:42 <Pseudonym> Right, so we invent a new one.
18:13:45 <adu> or q0 ?
18:13:45 <adu> ok
18:13:53 <Pseudonym> Which happens to be a reduce state.
18:14:29 <Pseudonym> Keep going and compute the whole machine.
18:14:39 <Pseudonym> I'll go get lunch and see how you did when I get back.
18:15:57 <adu> ok
18:19:56 <ihope> > True
18:19:58 <lambdabot> True
18:20:05 <ihope> > True False
18:20:06 <lambdabot> Couldn't match `Bool' against `t -> t1'
18:20:12 <ihope> > Truly False
18:20:12 <lambdabot>  Not in scope: data constructor `Truly'
18:20:24 <ihope> > guard against danger
18:20:27 <lambdabot>  Not in scope: `danger'
18:23:44 <dons> truly sounds  like a useful function
18:23:48 <dons> a bit like either?
18:23:58 <dons> or when, maybe
18:27:58 <mathrick> why would True False have t -> t1 type?
18:29:06 <dons> \type True False -- bet it doesn't type
18:29:06 <lambdabot>   Couldn't match `Bool' against `t -> t1'
18:29:06 <lambdabot>   Expected type: Bool
18:29:30 <dons> it looks like an application of a contructor, i.e. a function, from some argument type t to some result type t1
18:29:39 <dons> but True has type Bool, not t -> Bool
18:34:07 <Pseudonym> Back.
18:35:40 <Pseudonym> I think that truly :: a would surely be the function that asserts that the type is in habited.
18:36:06 <Pseudonym> Or maybe truly :: (a -> b) -> a -> b makes a proof more emphatic.
18:37:59 <dons> \djinn (a -> b) -> a -> b
18:38:00 <lambdabot> f a = a
18:38:24 <Pseudonym> verily is like truly only more so.
18:38:37 <dons> only more so, yes.
18:39:55 <dons> there's lots of good function names out there that we should have
18:40:08 <dons> like:   lots, good, there, that, should, have, like
18:40:30 <dons> and some more:  more, some, and (oh, we have that)
18:40:58 <dons> also: also
18:41:17 <Pseudonym> also = and?
18:41:25 <dons> do f x `also` g y
18:41:39 <Pseudonym> also = (>>)
18:41:40 <Pseudonym> ?
18:41:45 <Pseudonym> Or is it:
18:41:54 <dons> yeah, or maybe it also lifts into the monad
18:42:24 <Pseudonym> f x `also` g y === f x >>= \x' -> g y >>= \y' -> return (x',y')
18:43:02 <dons> ah, maybe maybe
18:43:15 <dons> a bit arrowish
18:43:21 <Pseudonym> alsoWith f m n = m >>= \x -> n >>= \y -> return (f x y)
19:04:49 <adu> is Pseudonym here?
19:28:27 <Pseudonym> Who?
19:36:59 <adu> yey
19:46:52 <adu> did you get my post?
19:46:56 * Pseudonym looks... 
19:46:57 <Pseudonym> Nope.
19:46:57 <adu> http://pastebin.com/613641
19:46:57 <Pseudonym> OK
19:47:15 * Pseudonym notes that #haskell sometimes resembles #theoretical-computer-science
19:47:27 <adu> :)
19:47:31 <Pseudonym> OK, comments.
19:47:31 <Pseudonym> First off, q1 has another item in its item set.
19:47:31 <Pseudonym> S -> T . #
19:47:31 <adu> oh
19:47:31 <Pseudonym> And, by the way, I annotated the rules with {0}, not q0.
19:47:36 <Pseudonym> You should annotate each state with its reduce actions as well as its shift actions.
19:47:38 <adu> sorry
19:48:31 <adu> ok
19:48:33 <Pseudonym> So q2, which has the rule T -> B . {2}
19:48:33 <Pseudonym> Has action: reduce by rule [2}.
19:48:33 <Pseudonym> {2}
19:48:33 <adu> which turns "B ." into "T"?
19:48:33 <Pseudonym> Yes.
19:48:33 <adu> ok
19:48:33 <Pseudonym> This is why I find it helpful, by the way, to annotate rules with actions which also name the rules.
19:48:33 <Pseudonym> It becomes easy when you need to write down the reduce actions.
19:48:36 <Pseudonym> Now let me check the rest.
19:48:52 <adu> if i was a student what grade would you give me for my first attempt ? :)
19:48:52 <Pseudonym> Pretty good, considering my lecture was awful.
19:48:52 <adu> lol
19:49:05 <Pseudonym> I'm going to change my condensed notation a bit.
19:49:11 <Pseudonym> Because "+" is a symbol in the grammar, I'm going to write a state like this:
19:49:12 <Pseudonym> q0 = T q1 | B q1 | "n" q3 | "(" q4
19:49:12 <adu> ok
19:49:12 <Pseudonym> Putting quotes around terminals, and using | to mean alternatives.
19:49:12 <adu> but how does r#, s# fit in?
19:49:12 <adu> would i use those instead of q# in some places?
19:49:12 <Pseudonym> Hang on, I'll show you.
19:49:13 <Pseudonym> Kind of.
19:49:13 <Pseudonym> OK, in q5, you left out a transition on B.
19:49:18 <adu> like:
19:49:20 <adu> q1 = "#" r0 | "+" q5
19:49:20 <adu> like a B => q2?
19:49:22 <Pseudonym> Just a moment.
19:49:22 <Pseudonym> I'll show you how to use the machine using this notation first.
19:49:22 <Pseudonym> Because I think it makes more sense.
19:49:22 <adu> ok
19:49:22 <Pseudonym> Then I'll show you the rn, sn notation.
19:49:22 <Pseudonym> OK, you need a B transition in q5.
19:49:22 <Pseudonym> I guess we'll invent a new state for that.
19:49:22 <Pseudonym> B => q8
19:49:22 <Pseudonym> Where q8 is T -> T + B .
19:49:22 <adu> :)
19:49:22 <adu> i'm smart
19:49:22 <Pseudonym> But apart from that, it's all good.
19:49:22 <adu> so B => q8
19:49:22 <Pseudonym> Now here's the short summary of the machine:
19:49:22 <Pseudonym> q0 = T q1 | B q1 | "n" q3 | "(" q4
19:49:22 <Pseudonym> q1 = # {0} | "+" q5
19:49:22 <Pseudonym> q2 = {2}
19:49:22 <Pseudonym> q3 = {3}
19:49:22 <Pseudonym> q4 = T q6 | B q2 | "n" q3 | "(" q4
19:49:22 <Pseudonym> q5 = "n" q3 | "(" q4 | B q_
19:49:22 <Pseudonym> q6 = ")" q7 | "+" q5
19:49:22 <Pseudonym> q7 = {4}
19:49:22 <Pseudonym> q8 = {1}
19:49:22 <Pseudonym> Where {2} means reduce by rule 2.
19:49:22 <Pseudonym> etc
19:49:22 <adu> ok
19:49:23 <Pseudonym> OK, now the fun part.
19:49:23 <adu> so i was right when i said q1 = "#" r0 | "+" q5
19:49:23 <Pseudonym> Let's parse a string.
19:49:23 <Pseudonym> Yes.
19:49:25 <adu> yey
19:49:25 <Pseudonym> In the older notation, it would be:
19:49:25 <Pseudonym> "#" r0 | "+" s5
19:49:25 <Pseudonym> i.e. shift and go to state 5
19:49:25 <Pseudonym> Anyway.
19:49:25 <Pseudonym> Give me a string.
19:49:25 <adu> (n + (n))#
19:49:25 <Pseudonym> OK.
19:49:25 <Pseudonym> We start in state q0, so we push that on the stack.
19:49:25 <Pseudonym> I'll use the notation: [ stack, input ]
19:49:25 <Pseudonym> So the initial state is: [ q0, (n+(n))#]
19:49:25 <adu> ok
19:49:25 <Pseudonym> We consult state 0, looking and see that the RHS part that matches is "(" q4
19:49:25 <Pseudonym> So we shift the symbol, push the new state:
19:49:25 <Pseudonym> [ q0 "(" q4, n+(n))# ]
19:49:25 <adu> oooooh
19:49:25 <adu> thats why they alternate
19:49:25 <Pseudonym> One of the nice things about doing things this way is that the state that we're "in" is the one on the top of the stack.
19:49:25 <Pseudonym> Yes.
19:49:25 <Pseudonym> The importance of this will become clear soon.
19:49:25 <Pseudonym> In q4, the rule that matches is "n" q3
19:49:25 <Pseudonym> So we shift:
19:49:25 <Pseudonym> [ q0 "(" q4 "n" q3, +(n))# ]
19:49:25 <Pseudonym> Now q3 is a reduce state.
19:49:25 <Pseudonym> Reduce by rule 3.
19:49:25 <Pseudonym> To reduce, we pop the RHS, and push the LHS.
19:49:25 <Pseudonym> Make sense?
19:49:25 <adu> trying to catch up
19:49:25 <adu> ya, that makes sense
19:49:25 <Pseudonym> OK.
19:49:25 <Pseudonym> This makes our new state:
19:49:25 <Pseudonym> [ q0 "(" a4 B q2, +(n))# ]
19:49:25 <Pseudonym> [ q0 "(" q4 B q2, +(n))# ]
19:49:25 <Pseudonym> The reason why we push q2, is that's the state you move to from q4 if you shift a B.
19:49:25 <Pseudonym> Pushing the LHS of a rule is like shifting the nonterminal.
19:49:26 <Pseudonym> The stack at any point actually shows a path from the start state, q0, to the current state, through all of the terminals _and_ nonterminals in our partial parse.
19:49:26 <adu> so we're still kinda in q4
19:49:26 <Pseudonym> Not quite.
19:49:26 <adu> which is where you got the B q2?
19:49:26 <Pseudonym> When we pop the RHS, we expose the state q4.
19:49:26 <Pseudonym> So yeah, we are kinda still there.
19:49:26 <adu> ok
19:49:26 <Pseudonym> And then you push the LHS, which causes a transition from state q4 on B.
19:49:31 <Pseudonym> Now, you keep parsing.
19:49:33 <Pseudonym> :-)
19:49:34 <adu> ok
19:49:36 <Pseudonym> [ q0 "(" q4 B q2, +(n))# ]
19:49:36 <Pseudonym> That's our current machine state.
19:49:36 <Pseudonym> What next?
19:49:36 <adu> [ q0 "(" q4 T q6, +(n))# ]
19:49:36 <Pseudonym> Correct.
19:49:38 <adu> and in q6, "+" is with q5 so:
19:49:39 <adu> [ q0 "(" q4 T q6 "+" q5, (n))# ]
19:49:39 <Pseudonym> Yup, keep going.
19:49:39 <adu> and in q5, "(" goes with q4 so:
19:49:41 <adu> [ q0 "(" q4 T q6 "+" q5 "(" q4, n))# ]
19:49:41 <adu> [ q0 "(" q4 T q6 "+" q5 "(" q4 "n" q3, ))# ]
19:49:41 <adu> [ q0 "(" q4 T q6 "+" q5 "(" q4 B q2, ))# ]
19:49:41 <adu> [ q0 "(" q4 T q6 "+" q5 "(" q4 T q6, ))# ]
19:49:45 <adu> and in q6 ")" goes with q7 so:
19:49:47 <adu> [ q0 "(" q4 T q6 "+" q5 "(" q4 T q6 ")" q7, )# ]
19:49:47 <adu> and q7 is a reduce state
19:49:47 <Pseudonym> Yes.
19:49:48 <adu> so i have to pretend i'm back in q6 where ")" goes with q7
19:49:48 <Pseudonym> No.
19:49:48 <Pseudonym> The rule that you're reducing by here is B -> ( T )
19:49:48 <Pseudonym> So you have to pop THREE symbol/state pairs off the stack.
19:49:48 <adu> oooo
19:49:48 <adu> oops
19:49:48 <Pseudonym> You notice that the three symbols on the top of the stack are "(", T and ")"
19:49:48 <Pseudonym> This is no accident.
19:49:48 <Pseudonym> Because that's the RHS of the rule.
19:49:49 <adu> which B does it get reduced to?
19:49:54 <Pseudonym> Well, when you pop those three symbols, the stack is this:
19:49:55 <Pseudonym> q0 "(" q4 T q6 "+" q5
19:49:55 <adu> B q2?
19:49:55 <Pseudonym> So now you're in q5, and you have to push a B
19:49:55 <Pseudonym> So that actually puts you in q8.
19:49:55 <adu> so B q8?
19:49:55 <Pseudonym> Yes.
19:49:58 <adu> and q8 is a reduce state for T + B
19:49:58 <Pseudonym> Right.
19:49:58 <adu> [ q0 "(" q4 T q6, )# ]
19:49:58 <adu> and in q6 ")" goes to q7 so:
19:49:58 <adu> [ q0 "(" q4 T q6 ")" q7, # ]
19:49:59 <adu> and q7 is a reduce state for ( T ) so:
19:49:59 <adu> [ q0 T q1, # ]
19:49:59 <adu> and in q1 "#" goes to a reduce state {0}
19:49:59 <Pseudonym> i.e. we accept
19:49:59 <adu> [ q0 T q1 "#" acc ,]?
19:49:59 <Pseudonym> And the parse is successful.
19:49:59 <Pseudonym> Well done.
19:49:59 <Pseudonym> Did that make sense?
19:49:59 <adu> or [q0 S acc ,]?
19:49:59 <adu> ya i think it did
19:49:59 <Pseudonym> How you handle accept is details.
19:49:59 <adu> ok
19:49:59 <Pseudonym> Reasonable people differ.
19:49:59 <Pseudonym> Yacc accepts when you attempt to shift the terminal symbol.
19:49:59 <Pseudonym> But it's an implementation detail.
19:49:59 <adu> at first i had some trouble with which state to "go back to" in order to reduce
19:49:59 <Pseudonym> Right.
19:49:59 <adu> and i still have no clue how i would get a parser to do that, but i think i can do it now
19:49:59 <Pseudonym> Cool.
19:49:59 <Pseudonym> Now, there are some gotchas here.
19:49:59 <Pseudonym> First off, you may end up with a state that looks like this:
19:49:59 <Pseudonym> q5 = {2} | {3}
19:49:59 <adu> some what?
19:49:59 <Pseudonym> Some tricky bits.
19:49:59 <adu> ok
19:49:59 <Pseudonym> If you get that, then what you have is a reduce-reduce conflict.
19:49:59 <Pseudonym> Because you could reduce on more than one rule.
19:49:59 <Pseudonym> You may also end up with a state that looks like this:
19:49:59 <Pseudonym> q6 = "a" q8 | {5}
19:49:59 <adu> and thats where LR(1) comes in right?
19:49:59 <Pseudonym> That is a shift-reduce conflict.
19:49:59 <Pseudonym> Because it's not obvious whether to reduce or to shift.
19:49:59 <Pseudonym> Right.
19:49:59 <Pseudonym> And LALR(1).
19:49:59 <adu> i thought LR(1) = LALR(1)
19:49:59 <Pseudonym> The idea of LR(k), SLR(k) and LALR(k) parsers where k > 0 is to use the next k symbols of lookahead to determine which action to take.
19:50:02 <Pseudonym> Actually, no.  LR(1) != LALR(1).
19:50:02 <Pseudonym> The distinction is unimportant for us right now.
19:50:02 <Pseudonym> In an LR(1), SLR(1) or LALR(1) machine, you might actually have a rule that looks like this:
19:50:02 <Pseudonym> q6 = "a" q8 | "b" {5}
19:50:02 <Pseudonym> The second term isn't an instruction to shift "b", it means that if the next symbol is "b", you should reduce instead of shift.
19:50:02 <Pseudonym> Notation differs on this point.
19:50:02 <adu> i'm planning two small languages, which is why I'm trying to get a good understanding of this stuff
19:50:02 <Pseudonym> Now.  All of the sn, rn etc notation is about compressing the automaton.
19:50:02 <Pseudonym> Sure.
19:50:02 <Pseudonym> The first thing that people noticed was that the shift-by-nonterminal stuff is only important when you reduce a rule.
19:50:02 <Pseudonym> So they put that in a separate table.
19:50:02 <Pseudonym> That's called the "goto table".
19:50:02 <adu> ya i see that on Wikipedia
19:50:02 <Pseudonym> So in our machine, the goto table looks like this:
19:50:02 <Pseudonym> q0 = T q1 | B q1
19:50:02 <Pseudonym> q4 = T q6 | B q2
19:50:02 <Pseudonym> q5 = B q8
19:50:02 <Pseudonym> Note that not every state needs an entry in the table.
19:50:02 <adu> basically the subset that includes non-terminals only
19:50:02 <Pseudonym> Right.
19:50:02 <adu> k
19:50:02 <Pseudonym> And the action table is everything else:
19:50:02 <Pseudonym> q0 = "n" q3 | "(" q4
19:50:02 <Pseudonym> etc etc
19:50:02 <adu> k
19:50:02 <Pseudonym> q4 = "n" q3 | "(" q4
19:50:02 <Pseudonym> q5 = "n" q3 | "(" q4
19:50:02 <Pseudonym> The NEXT thing to notice is that you end up with a lot of states, like these three, which are essentially identical.
19:50:02 <Pseudonym> They differ only in their goto table component.
19:50:02 <adu> yup
19:50:02 <adu> ah ic
19:50:02 <Pseudonym> So you use some indirection to share the action parts.
19:50:04 <adu> ya, the q2 and q8 for B 
19:50:05 <adu> so if you have a really fancy programming language you could index the action table with the pattern q(0|4|5) = "n" q3 | "(" q4
19:50:07 <adu> or maybe not
19:50:07 <Pseudonym> Or something.
19:50:43 <adu> that was a good intro
19:50:48 <Pseudonym> Thanks.
19:51:26 <adu> i wonder how much of that will carry over into writing better grammars
19:51:27 <Pseudonym> If you're at all interested in this topic, there's a book you should look for in your university library.
19:51:38 <Pseudonym> Nigel Chapman, "LR Parsing: Theory and Practice"
19:51:45 <Pseudonym> It's THE book on the topic.
19:51:47 <adu> k
19:54:15 <adu> so is this example how you would turn my first thing into an unambiguous grammar?
19:54:37 <Pseudonym> Ah, now that's an advanced topic.
19:54:41 <adu> expr -> expr op expr | (expr)
19:54:42 <Pseudonym> But yeah.
19:54:45 <Pseudonym> More or less.
19:55:04 <Pseudonym> In an operator grammar, generally, each operator has precedence and associativity.
19:55:17 <adu> start -> expr op part
19:55:21 <adu> expr -> part
19:55:31 <Pseudonym> For example, "-" binds less tightly than "*", and both are left associative.
19:55:33 <adu> part -> terminal
19:55:35 <Pseudonym> So you might say:
19:55:38 <adu> part -> (expr)
19:55:45 <Pseudonym> T -> T - F
19:55:47 <Pseudonym> T -> F
19:55:50 <Pseudonym> F -> F * B
19:55:52 <Pseudonym> F -> B
19:56:00 <Pseudonym> B -> n | ( E )
19:56:02 <Pseudonym> Or something.
19:56:08 <adu> ok
19:56:11 <Pseudonym> You say F -> F * B if * is left-associative
19:56:30 <Pseudonym> For a right-associative operator like "^" (raise to the power of), you might write this:
19:56:36 <Pseudonym> E -> T ^ E
19:56:38 <Pseudonym> E -> T
19:56:47 <adu> right
19:56:52 <Pseudonym> If you have two operators with the same precedence, like + and -, you'd write this:
19:56:54 <adu> that makes sense
19:56:56 <Pseudonym> T -> T + F
19:56:58 <Pseudonym> T -> T - F
19:57:01 <Pseudonym> T -> F
19:57:09 <Pseudonym> They're both left-associative.
19:57:33 <Pseudonym> If you have a nonassociative operator, like "==", you might write this:
19:57:35 <Pseudonym> E -> T == T
19:57:36 <Pseudonym> E -> T
19:57:47 <adu> ok
19:57:49 <Pseudonym> Because a == b == c might make no sense.
19:57:55 <adu> ya
19:58:00 <Pseudonym> I'm picking that one out of the air.  It's just an example.
19:58:09 <Pseudonym> Look at the Haskell grammar in the report if you want more details.
19:58:16 <Pseudonym> Or the C grammar in K&R.
19:58:26 <adu> ya i've looked at tons of grammars
19:58:51 <adu> i'll probably copy some bits from them when i write those languages
19:58:55 <adu> the one i HATE the most is ECMAScript
19:59:04 <Pseudonym> PHP is pretty grody, too.
19:59:11 <adu> i don't like how it has 2 versions of everything
19:59:21 <Pseudonym> Fortran 77 isn't even LR.
19:59:41 <adu> Pseudonym: have you ever read the grammar for ecmascript?
19:59:49 <Pseudonym> Once upon a time.
20:00:06 <Pseudonym> I used to have a desk next to Fergus, so he got all the ISO programming language standards.
20:00:15 <Pseudonym> I flicked through the ECMAscript standard once.
20:00:18 <Pseudonym> Only once, I think.
20:00:22 <adu> who's Fergus?
20:00:28 <Pseudonym> Fergus Henderson.
20:00:39 <Pseudonym> I though you only had to say "Fergus" and everyone knew who you were talking about.
20:00:40 <Pseudonym> Like Oleg.
20:00:58 <adu> who's Oleg?
20:01:12 <dons> \google oleg
20:01:13 <lambdabot> http://www.olegvolk.net/
20:01:15 <dons> nope
20:01:21 <dons> \google oleg kiselyov
20:01:21 <lambdabot> http://okmij.org/ftp/
20:01:33 <dons> maybe
20:01:36 <dons> yes
20:01:36 <adu> ah so fergus worked on C++?
20:01:47 <Pseudonym> Kind of. 
20:01:54 <Pseudonym> I don't think he was actually on the language committee.
20:01:55 <adu> then what is he known for?
20:02:06 <Pseudonym> Mercury, mostly.
20:02:21 <adu> Oleg Dulin?
20:02:21 <Pseudonym> Oh, he was an officially credited technical expert to C++ and C.
20:02:28 <Pseudonym> Fergus, that is.
20:03:24 <adu> i've heard of mercury
20:03:32 <adu> but i've heard of hundreds of programming languages
20:04:20 <Pseudonym> Well I can guarantee that Fergus speaks more programming languages than you do.
20:04:21 <Pseudonym> :-)
20:04:52 <adu> heh
20:05:06 <adu> i only speak 4-5
20:05:26 <Pseudonym> He speaks about 50.  I only speak about 40.
20:05:29 <adu> wow
20:05:33 <Pseudonym> To varying degrees of fluency, of course.
20:05:38 <adu> oh
20:05:47 <Pseudonym> If I wanted to hack SML, I'd have to have a library reference handy.
20:06:02 <Pseudonym> And even an expert needs a Common Lisp library reference handy. :-)
20:06:06 <adu> heh
20:06:18 <adu> ya i haven't memorized any library
20:06:38 <adu> except maybe scheme
20:06:44 <Pseudonym> Well I think I know the standard C library.
20:06:47 <adu> scheme is easy to know all of
20:07:03 <Pseudonym> Yeah.
20:07:22 <adu> i know about 2% of the std C lib
20:07:33 <Pseudonym> I bet you know almost all of the _standard_ C lib.
20:07:39 <adu> and about 0.05% of C++
20:07:39 <Pseudonym> The standard is actually pretty small.
20:07:54 <Pseudonym> A lot smaller than people think, in fact.
20:08:35 <adu> there stdio.h for *printf and *scanf
20:08:55 <Pseudonym> stdio, stdlib, string, math, float, limits...
20:08:58 * Pseudonym thinks
20:09:01 <adu> theres stdlib.h for getopts and some other stuff like SUCCESS and FAILURE
20:09:08 <Pseudonym> I think that's all in the first ISO.
20:09:51 <adu> oh ya
20:09:51 <Pseudonym> Oh, varargs.
20:09:51 <Pseudonym> No, getopt isn't standard.
20:09:51 <adu> oh
20:09:51 <Pseudonym> Nor is unistd.
20:09:51 <adu> hmm
20:09:57 <adu> what about C99? is getopts in there?
20:10:02 <dbremner> Psuedonym - C99 is 554 pages, but it isn't widely implemented.
20:10:10 <Pseudonym> Right.
20:10:15 <Pseudonym> C99 is bigger than that.
20:10:36 <Pseudonym> Here we are.
20:21:54 <Pseudonym> The C standard library:
20:42:30 <dbremner> adu - nope
22:19:08 --- topic: '["Submit a paper to the Haskell Workshop:", "http://haskell.org/haskell-workshop/2006", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion"]'
22:19:08 --- topic: set by sylvan on [Fri Mar 03 08:35:02 2006]
22:19:08 --- names: list (clog_ Nomius_ Lokadin datenmaulwurf_ Lokadin_ gvdm adu sjanssen sili_ khaladan Trixsey newsham dbremner Khisanth Yango astrolabe Igloo Revision17 Lemmih ex_nor HatchBack176 ed-209 Plareplane noclouds lambdabot Sysop_fb Pseudonym cods samx Wallbraker grey- ski kosmikus pesco vincenz thedward resiak perspectival shawn mathrick|sleep shapr tre_ sili SamB Beelsebob ex__nor CosmicRay Maddas ibid pejo dcoutts_ dcoutts wli shrimpx bolrod cpatrick)
22:19:08 --- names: list (cmeme ricebowl liyang djw borism kolmodin_ mornfall jips johs cognominal edwinb ikegami-- eyck flux__ |giksos| jp-autark twobitsprite kpreid_ arjanb spo0nman KOC MarcWeber Saulzar tic lome slipstream-- JKnecht kisu svens kpk isydor lucca rep tuomov kzm gdsx cajole carp scw jgrimes palomer cbus llappala mattam SimonRC zamez eivuokko Korollary audreyt eno-away rkeene TheHunter lisppaste2 hellish sellout __AL__ Laney wimp jiing leif noj qwr)
22:19:08 --- names: list (binary42 mkhl Hmm_| akemp ramkrsna davidmccabe integral piggy_ ValarQ Paltas Soliah Philippa_ drbean rasfar emu ksandstr tessier__ Nioate_ lispy wolverian juhp Poeir Touqen norpan WillKW dfhaii JohnMeacham dons Twigathy alch` clog CLxyz sieni jlouis orbitz magagr arguile Lunar^ musasabi earthy moonlite dany2k ulfdoz Si\Uni neologism cathper gzl spamsch xerox Excedrin Spark aleator nibro)
22:28:44 <MarcWeber> do you know where the io fuction is defined which is used in some wash exampled modules?
22:32:21 --- topic: '["Submit a paper to the Haskell Workshop:", "http://haskell.org/haskell-workshop/2006", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion"]'
22:32:21 --- topic: set by sylvan on [Fri Mar 03 08:35:02 2006]
22:32:21 --- names: list (clog__ slipstream clog_ Nomius_ Lokadin gvdm adu sjanssen sili_ khaladan Trixsey newsham dbremner Khisanth Yango astrolabe Igloo Revision17 Lemmih ex_nor HatchBack176 ed-209 Plareplane noclouds lambdabot Sysop_fb Pseudonym cods samx Wallbraker grey- ski kosmikus pesco vincenz thedward resiak perspectival shawn mathrick|sleep shapr tre_ sili SamB Beelsebob ex__nor CosmicRay Maddas ibid pejo dcoutts_ dcoutts wli shrimpx bolrod cpatrick cmeme)
22:32:21 --- names: list (ricebowl liyang djw borism kolmodin_ mornfall jips johs cognominal edwinb ikegami-- eyck flux__ |giksos| jp-autark twobitsprite kpreid_ arjanb spo0nman KOC MarcWeber Saulzar tic lome slipstream-- JKnecht kisu svens kpk isydor lucca rep tuomov kzm gdsx cajole carp scw jgrimes palomer cbus llappala mattam SimonRC zamez eivuokko Korollary audreyt eno-away rkeene TheHunter lisppaste2 hellish sellout __AL__ Laney wimp jiing leif noj qwr binary42)
22:32:21 --- names: list (mkhl Hmm_| akemp ramkrsna davidmccabe integral piggy_ ValarQ Paltas Soliah Philippa_ drbean rasfar emu ksandstr tessier__ Nioate_ lispy wolverian juhp Poeir Touqen norpan WillKW dfhaii JohnMeacham dons Twigathy alch` clog CLxyz sieni jlouis ulfdoz nibro aleator Spark Excedrin xerox spamsch gzl cathper neologism Si\Uni dany2k moonlite earthy musasabi Lunar^ arguile magagr orbitz)
23:03:19 <ski> palomer : .. possibly one could make monads of e.g. kind '(* -> *) -> (* -> *)', too .. those'd not be instances of the standard monad class, though (kind mismatch)
23:04:02 <ski> hm
23:05:29 <ski> class FMonad m
23:05:32 <ski>   where
23:06:01 <ski>   freturn :: f a -> m f a
23:06:32 <ski> hm
23:08:47 <ski>   fbind :: m f a -> (forall a. f a -> m g a) -> m g a
23:09:14 <ski>   fjoin :: m (m f) a -> m f a
23:09:18 <ski> i think
23:09:55 <ski> (maybe throw in some 'Functor' or 'Monad' constraints, for 'f' and 'g', too .. not sure)
23:15:27 <ski> astrolabe : yes
23:15:56 <ski> vincenz : 'move the c ahead of sp1' ?
23:33:12 <shapr> dons: good morning!
