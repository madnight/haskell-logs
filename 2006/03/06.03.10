00:00:02 <Cale> also, there are a bunch of IO primitives
00:00:06 <Cale> (of course)
00:08:57 <Lemmih> JohnMeacham: How do you select tag names for the jhc repo?
00:14:58 <JohnMeacham> Lemmih: http://www.itl.nist.gov/fipspubs/fip181.htm
00:15:58 <JohnMeacham> Lemmih: http://dev.mosuki.com/passogva/src/passogva.c
00:23:06 <Lemmih> ah
00:50:24 <bolrod> you ok?
00:59:38 <bolrod> O_O
00:59:46 <bolrod> seems like someone has a bit of a connection problem?
01:00:07 <Cale> it happens
01:00:14 <bolrod> tru
01:00:25 <bolrod> just like you predicted!
01:00:26 <Cale> they're probably not even at their computer
01:00:27 <bolrod> :)
01:00:45 <bolrod> its contageous
01:01:03 * Cale predicts turmoil in the middle east
01:01:19 <bolrod> :)
01:01:58 * Saulzar predicts there will be rain or earthquakes somewhere in the world
01:02:09 <bolrod> it rains here...
01:02:31 <sieni> Cale: If I just got 10 buck for every obvious "prediction" I hear...
01:02:35 <Saulzar> I guess that's all the signs we need to be sure the rapture is coming soon then :)
01:02:40 <ski> if it rains, or rains, then it rains
01:03:04 <bolrod> that is correct
01:03:13 <bolrod> HMMM
01:03:30 <bolrod> rain here.. possible snow somewhere else..
01:03:37 <bolrod> I hope its not alot
01:03:40 * ski remembers that from some popular math book about logic in that part
01:03:51 * Cale predicts the existence of regions receiving less than 250mm of rain per year.
01:04:35 * ski is reminded of might and magic 4 & 5
01:06:05 <bolrod> the weather for today!   between the showers it is dry.. afternoon temperatures set in at around 12 local darkness expected after 7PM 
01:06:52 <Cale> News Flash! Rotation of Earth Plunges Entire North American Continent Into Darkness!
01:07:06 <bolrod> oh noe!
01:08:19 <bolrod> the darkness is rapidly moving with a speed of around 2000 km/h over the country!   soon.. it will be in a town near YOU!
01:08:23 <Cale> Effects of the darkness include drowsiness and a reduced desire to continue working.
01:08:59 <ski> woe is upon us (i.e. them), we (i.e. you) have not much time left to repent
01:09:33 <ski> sinners must REPENT ! the END is near !
01:09:47 <Cale> @yow
01:09:48 <lambdabot> I want the presidency so bad I can already taste the hors d'oeuvres.
01:09:49 <bolrod> fear darkness not! for light is chasing it around the globe.. trying to catch up ..
01:11:42 <ski> I'm having TOO much FUN !
01:11:55 <bolrod> is that possible?
01:12:33 <ski> this is the punishment
01:12:39 <ski> *DONG* *DONG*
01:12:50 <rep> yow?
01:13:03 <Cale> Poll: Does the Sun go around the Earth? How often?
01:13:10 <bolrod> I See... I must catch the soon to arrive train
01:15:10 <ski> @listcommands poll
01:15:11 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result
01:15:11 <lambdabot> poll-close poll-remove
01:23:55 <ski> @help poll-list
01:23:56 <lambdabot>  @poll-list                 shows all current polls
01:24:00 <ski> @poll-list
01:24:00 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
01:24:18 <ski> @help poll-show
01:24:19 <lambdabot>  @poll-show <poll>            shows all choices for some poll
01:24:45 <ski> @help poll-add
01:24:46 <lambdabot>  @poll-add <name>             adds a new poll, with no candidates
01:26:36 <ski> @poll-list *
01:26:37 <lambdabot> []
01:28:17 <ski> @poll-add DoesSunGoAroundTheEarth_HowOften
01:28:17 <lambdabot> Added new poll: "DoesSunGoAroundTheEarth_HowOften"
01:28:41 <mauke> @vote
01:28:41 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
01:28:44 <ski> @choice-add DoesSunGoAroundTheEarth_HowOften No
01:28:45 <lambdabot> New candidate "No", added to poll "DoesSunGoAroundTheEarth_HowOften".
01:28:51 <ski> @choice-add DoesSunGoAroundTheEarth_HowOften Yes
01:28:52 <lambdabot> New candidate "Yes", added to poll "DoesSunGoAroundTheEarth_HowOften".
01:28:56 <ski> @choice-add DoesSunGoAroundTheEarth_HowOften Sometimes
01:28:57 <lambdabot> New candidate "Sometimes", added to poll "DoesSunGoAroundTheEarth_
01:28:57 <lambdabot> HowOften".
01:29:03 <ski> @vote DoesSunGoAroundTheEarth_HowOften Sometimes
01:29:04 <lambdabot> voted on "Sometimes"
01:29:48 <ski> @poll-list *
01:29:49 <lambdabot> ["DoesSunGoAroundTheEarth_HowOften"]
01:30:01 <ski> @poll-show DoesSunGoAroundTheEarth_HowOften
01:30:01 <lambdabot> ["Sometimes","Yes","No"]
01:30:10 <ski> @poll-result DoesSunGoAroundTheEarth_HowOften
01:30:11 <lambdabot> Poll results for DoesSunGoAroundTheEarth_HowOften (Open): Twice=1,
01:30:11 <lambdabot> Sometimes=1, Yes=0, No=0
01:30:19 <tromp_> @choice-add DoesSunGoAroundTheEarth_HowOften Once_Per_Sunrise
01:30:20 <lambdabot> New candidate "Once_Per_Sunrise", added to poll "DoesSunGoAroundTheEarth_
01:30:20 <lambdabot> HowOften".
01:30:48 <Cale> @choice-add DoesSunGoAroundTheEarth_HowOften Once_Per_Year
01:30:48 <lambdabot> New candidate "Once_Per_Year", added to poll "DoesSunGoAroundTheEarth_
01:30:48 <lambdabot> HowOften".
01:31:20 <tromp_> @poll-show DoesSunGoAroundTheEarth_HowOften
01:31:20 <lambdabot> ["Once_Per_Year","Once_Per_Sunrise","Twice","Sometimes","Yes","No"]
01:32:30 <ski> @poll-result DoesSunGoAroundTheEarth_HowOften
01:32:30 <lambdabot> Poll results for DoesSunGoAroundTheEarth_HowOften (Open): Once_Per_Year=0,
01:32:31 <lambdabot> Once_Per_Sunrise=0, Twice=1, Sometimes=1, Yes=0, No=0
01:33:21 <ski> @poll-add ShouldWeVoteMore
01:33:22 <lambdabot> Added new poll: "ShouldWeVoteMore"
01:33:32 <ski> @choice-add ShouldWeVoteMore Yes
01:33:32 <lambdabot> New candidate "Yes", added to poll "ShouldWeVoteMore".
01:33:48 <ski> @choice-add ShouldWeVoteMore Often
01:33:48 <lambdabot> New candidate "Often", added to poll "ShouldWeVoteMore".
01:33:55 <ski> @vote ShouldWeVoteMore Often
01:34:23 <ski> @poll-list *
01:34:23 * ibid kuuluu nukkuvien puolueeseen
01:35:03 <lambdabot> voted on "Often"
01:35:05 <lambdabot> ["DoesSunGoAroundTheEarth_HowOften","ShouldWeVoteMore"]
01:36:51 <Saulzar> @vote DoesSunGoAroundTheEarth_HowOften Yes
01:36:51 <lambdabot> voted on "Yes"
01:45:27 <tromp_> @vote DoesSunGoAroundTheEarth_HowOften No
01:45:27 <lambdabot> voted on "No"
01:45:41 <tromp_> @poll-result DoesSunGoAroundTheEarth_HowOften
01:45:41 <lambdabot> Poll results for DoesSunGoAroundTheEarth_HowOften (Open): Once_Per_Year=0,
01:45:41 <lambdabot> Once_Per_Sunrise=0, Twice=1, Sometimes=1, Yes=1, No=1
02:23:25 <tuomov> let wurst = fst in curry wurst
02:23:27 <tuomov> haskell is funny :)
02:31:28 <laney_> Hi. I'm looking for a built-in function to access the nth element of a tuple. Does this exist?
02:32:18 <musasabi> laney_: how would the type of that function look like?
02:32:44 <laney_> Int -> a
02:32:54 <mauke> and where's the tuple?
02:32:55 <musasabi> laney_: and the tuple?
02:33:04 <laney_> oh, sorry
02:33:09 <laney_> Int -> b -> a?
02:33:14 <laney_> Are you saying it's not possible?
02:33:21 <musasabi> laney_: You can write a function to select the kth element of a homogenous n-tuple.
02:33:48 <laney_> But there is no generic one?
02:34:05 <musasabi> laney_: so what would be the type of "tupleSelect (if something then 1 else 2) ("string", True)" ?
02:34:36 <musasabi> with TH you can create a metafunction to do that.
02:35:19 <ski> laney_ : why do you (think you) need such a function ?
02:36:00 <laney_> I have a 3-tuple which is a list of marks and need to get the mark in the ith module.
02:36:16 <laney_> It's no matter, I can just do it with guards. I was looking for a more elegent way :)
02:38:34 <laney_> thanks lads, seeya
02:53:23 <JohnMeacham> holy moly my chinchilla is having babies.
04:16:59 <kosmikus> @seen TheHunter
04:17:00 <lambdabot> I haven't seen TheHunter.
04:26:30 <kosmikus> @seen JaffaCake
04:26:30 <lambdabot> I haven't seen JaffaCake.
04:40:22 <tromp_> @seen lambdabot
04:40:22 <lambdabot> Yes, I'm here. I'm in #plone, #ScannedInAvian, #haskell.es, #haskell.it, #
04:40:22 <lambdabot> gentoo-haskell, #haskell-overflow, #flippi, #haskell-blah and #haskell
04:41:06 <tromp_> wow, it's self aware:)
04:51:09 <saintiss> hi
04:51:23 <saintiss> if I do ['c'..], I get a list of about 255 symbols
04:51:31 <saintiss> however, if I do it on some other machines, it loops endlessly
04:51:36 <saintiss> well, it doesn't loop
04:51:41 <saintiss> it just generates an infinite list
04:51:45 <saintiss> is this a known issue?
04:52:17 <saintiss> e.g. is this influenced by an environment variable?
04:52:23 <Igloo> Are you sure it's infinite and not just all unicode characters?
04:52:34 <saintiss> Igloo, are there more than 100 000 ?
04:52:40 <Igloo> Yes
04:52:50 <Igloo> Hugs.Base> length ['c'..]
04:52:50 <Igloo> 1114013
04:53:14 <saintiss> Igloo, hmm, interesting, then why do I only get 255 here?
04:53:16 <Igloo> The "infinite list" machines probably just have newer versions of the implementation
04:53:18 <saintiss> because it's not unicode?
04:53:25 <saintiss> ah, ic...
04:53:36 <chrisbrown> saintiss: because that system must not be using unicode i guess...
04:53:55 <chrisbrown> must be ASCII
04:54:06 <saintiss> chrisbrown, hmm, is this a system setting then?
04:54:19 <saintiss> or a property of the implementation?
04:54:19 <chrisbrown> what system is it?
04:54:29 <saintiss> chrisbrown, linux, but the other one too :)
04:54:34 <saintiss> mine is debian, the other one ubuntu
04:54:42 <chrisbrown> if it is linux - you can probably install unicode
04:55:17 <chrisbrown> possibly a kernal setting?
04:55:36 <saintiss> ic... ok thanks
04:56:04 <dcoutts> dons, I didn't know your students were using gtk2hs too! Tell me more :-)
04:57:19 <musasabi> Is there a sane way to use range queries on Data.Map ?
04:59:56 <musasabi> range low high = toList . fst . split high . snd . split low
05:00:05 <musasabi> is easy to define, but not very efficient.
05:20:53 <lisppaste2> sbeyer pasted "gtk2hs: treeStoreSetValue doesn't work or what's wrong?" at http://paste.lisp.org/display/17709
05:21:03 <sbeyer> :)
05:21:51 <dcoutts> sbeyer, your column has no cell renderers, so it will not show anything
05:21:58 <sbeyer> dcoutts, thank you ;)
05:22:27 <dcoutts> sbeyer, btw all this stuff will change in the next release, we've got a much better api which doesn't use iters & GenericValues
05:22:44 <dcoutts> it has a nice typed Haskell API :-)
05:23:19 <sbeyer> errm, sounds nice, but I guess it won't be backwards-compatible?
05:25:30 <dcoutts> sorry
05:25:49 <dcoutts> but your list/view code will be half as long
05:25:51 <sbeyer> when does the next release come? ;)
05:25:58 <dcoutts> a few weeks
05:26:14 <dcoutts> it's brweing in the darcs version
05:26:32 <sbeyer> I always have these problems... ;) Nevertheless I write the GUI using the "old" gtk2hs ;)
05:27:22 <sbeyer> will change it when the new version is released ;)
05:29:14 <araujo> Good morning.
05:37:33 <alar> greetings
05:41:14 <musasabi> hello
05:44:21 <alar> I have one more stupid question for local gurus
05:44:42 <alar> about Hindley-Milner, Turing-completeness and wikipedia
06:01:20 <edwinb> hello jjw!
06:03:09 <carp> is it getting a bit sad when 5 people in this room are in this channel?
06:04:33 <edwinb> only if this is the only way they communicate...
06:04:44 <liyang> oh dear.
06:04:51 <carp> good point, could you move up a bit
06:08:06 * ski wonders what alar's question was
06:16:13 <alar> wikipedia says that only Turing-complete thing can compute Ackermann
06:16:40 <alar> it is possible to compute Ackerman with Haskell typesystem
06:16:41 <liyang> primrec won't
06:17:04 <alar> but someone said me that Hindley-Milner is Turing-incomplete
06:17:17 <alar> what did I get wrong?
06:17:52 <sieni> alar: naturally Wikipedia is lying
06:18:11 <roconnor> Who's going to TFP 2006?
06:18:17 <roconnor> I just found out I was going today.
06:18:39 <alar> thanks!
06:18:40 <edwinb> I'm going
06:19:04 <jjw> maybe you should register too ;)
06:19:22 <edwinb> yes, I probably should...
06:19:28 <roconnor> I'm registered for TYPES 2006
06:19:33 <jjw> boo!
06:19:44 <roconnor> then I found out TFP 2006 is happening at the same place / time
06:19:49 <roconnor> so I get to go to both!
06:19:50 <jjw> I need registrations!
06:20:11 <roconnor> jjw: sorry. ;)
06:20:44 <alar> sieni: is it right that in Hindley-Milner halting problem is decidable?
06:21:31 <Igloo> no
06:21:32 <liyang> no
06:21:34 <jjw> no
06:21:38 <edwinb> no
06:21:41 <carp> no
06:21:55 <carp> :)
06:21:58 <alar> =)
06:22:18 <Igloo> Oh, hang on, what exactly do you mean? Type inference is decidable
06:22:25 <kzm> What is the simplest way of defining a CString constant?
06:22:42 <Igloo> "only Turing-complete thing can compute Ackermann" is rubbish
06:22:49 * kzm wonders if it is impolite to try to change the subject.
06:23:10 <alar> Igloo
06:23:22 <alar> actually wikipedia says "things that guaranteed to halt cannot complete Ackerman"
06:23:28 <kzm> Hmm..can't you implement a TM on top of Ackerman's function?
06:23:46 <Igloo> Ackerman is guaranteed to temrinate, no?
06:23:53 <roconnor> alar: ouch
06:24:23 <Igloo> So I can define a language in which all you can do is compute Ackerman's function of values, and it will always terminate
06:24:23 <kosmikus> nice one
06:24:39 <alar> Igloo: thanks
06:25:02 * alar doesn't understand why this was not obvious to wikipedia authors
06:25:04 <musasabi> alar: I think that it is at least computable in GHC Haskell.
06:25:12 * roconnor tries to remember the class of functions that PA proves is total.
06:25:41 <ndm> Ackermanns is not primitve recursive in a first order language
06:25:51 <ndm> and its easy to prove the termination of primitive recursive things
06:26:05 <ndm> hence Ackermanns is not obviously terminating to a primitive recursive checker
06:26:26 <ndm> i.e. you couldn't write it in Epigram using the _rec_ pattern (first order)
06:26:48 <ndm> although Ackermanns *is* primitive recursive in a higher order language, like Haskell
06:26:52 <ski> Non-type variables in constraint: Ackermann m (S Z) a
06:26:52 <ski> (Use -fallow-undecidable-instances to permit this)
06:27:09 <alar> ndm: wikipedia says that primrec things are not subclass of all things that always terminate, but they are equivalent to always-terminating things
06:27:14 <alar> is it wrong too?
06:27:19 <ndm> yep, thats wrong
06:27:39 <ndm> Ackermanns was the first proven example of something that was not in that class, but does terminate
06:28:03 <ndm> primrec things always terminate, but so do some other things
06:28:12 <roconnor> Maybe if you only do induction on Sigma 1 formulas, then you can't prove Ackermann total?
06:28:12 <ndm> primrec is a subset of the terminating prorams
06:28:19 * alar decides to stay away from wikipedia
06:28:29 <wolverian> alar, rather, fix it
06:28:33 <ndm> alar, i've read the prim rec stuff before, and it used to be right
06:28:42 <ndm> alar, point me at hte page and i'll edit it if you want - since i know the details
06:28:59 <ndm> (i'm doing a phd in termination checking)
06:29:54 <astrolabe> Do you know whether you'll finish?
06:30:41 <ndm> astrolabe: was that question directed at me ?
06:31:26 * edwinb chortles
06:32:59 * alar can't find lies
06:33:18 <alar> maybe it was not wikipedia but something else?
06:34:04 <edwinb> I've seen ackermann written in epigram, but annoyingly I can't find the mailing list archives...
06:34:15 <edwinb> but I think it used something higher order on the way
06:34:53 <ndm> @google total functional programming turner
06:34:55 <lambdabot> http://www.jucs.org/jucs_10_7/total_functional_programming
06:34:55 <alar> edwinb: I don't think it is hard to write Ackerman in Epigram
06:35:02 <edwinb> neither do I
06:35:10 <ndm> that gives a higher order version of ackermanns
06:35:27 <ndm> i don't believe its possible to write in epigram using only rec and not using higher order functions
06:36:26 <edwinb> you could probably build a domain predicate for termination, but I haven't really thought how.
06:37:51 <alar> ndm: so primrecs and deciders are only equivalent in the sence of recognizable languages?
06:38:23 <alar> sense
06:38:30 <ndm> alar, deciders?
06:38:51 <alar> machines that always halt
06:38:58 <alar> wikipedia calls them deciders
06:39:13 <ndm> no, there are machines that always halt that produce non-primrec languages
06:39:32 <ndm> deciders are strictly more powerful than primrecs
06:39:59 <ihope> > putStr "Number to multiply: " >> readLn >>= \a -> putStr "Number 2 to multiply:" >> readLn >>= \b -> print (a*b)
06:39:59 <lambdabot> No IO allowed
06:40:07 <ihope> Yay, it works.
06:40:09 <ihope> @pl putStr "Number to multiply: " >> readLn >>= \a -> putStr "Number 2 to multiply:" >> readLn >>= \b -> print (a*b)
06:40:11 <lambdabot> putStr "Number to multiply: " >> readLn >>= ((putStr "Number 2 to
06:40:11 <lambdabot> multiply:" >> readLn) >>=) . (print .) . (*)
06:40:25 <alar> ndm
06:40:29 <alar> http://en.wikipedia.org/wiki/Decider
06:40:42 <alar> The class of formal languages which can be decided by such machines are exactly the recursive languages.
06:41:05 <alar> did I miss something?
06:41:13 <ndm> alar, yes
06:41:20 <alar> or is there something wrong in wikipedia?
06:41:21 <ndm> recursive vs primitive recursive
06:41:22 <carp> you'd need to build some sort of elimination rule like thing to justify why the recursion you wanted to do was structural.  <= rec x justifies structural recursion on constructor bound things.
06:41:30 <carp> oh missed a bit
06:43:01 <ndm> alar, I've never heard of deciders, and that whole article looks a bit half-assed
06:43:53 <roconnor> Is the ackermann function a ``function of interest''?
06:43:55 <ndm> and yes, i think its wrong - certainly the table at the bottom is confusing
06:44:08 <alar> thanks
06:44:34 <roconnor> This whole article doesn't make sense to me
06:44:44 <roconnor> a machine that always halts — also called a decider
06:44:55 <roconnor> There are (Turing-)computable total functions that are not computable by any machine that always halts.
06:45:07 <roconnor> hmm
06:45:14 <ihope> Yep. I don't get it either.
06:45:24 <roconnor> Okay, so it is just saying that there is no universal decider
06:45:31 <ndm> yeah, the whole thing on deciders is added to wikipedia 2005, which is pretty new by wikipedia CS standards
06:45:34 <roconnor> in a very strange way
06:45:34 <alar> ndm: so recursive functions are just partial primitive recursive functions with added "unbounded search operator"
06:45:48 <alar> ?
06:46:21 <ndm> it looks like someone took a copy of Sipser 1997 and went a bit nuts
06:46:35 <ndm> alar, i don't really know - they are a new one on me
06:46:36 <roconnor> recursive functions = partial recursive functions
06:46:51 <ndm> or new compared to the wiki description
06:46:58 <ndm> most people have primrec and rec
06:47:10 <roconnor> what the article calls deciders seems to be what everyone else would call a total-recursive function.
06:47:13 <ndm> rec allows any form of recursion, primrec only allows descending a constructor
06:47:26 <ndm> roconnor: which is an entirely undeciable class?
06:47:59 <roconnor> which recursive functions are total recursive functions is undecidable.
06:48:11 <roconnor> but the langauges that total recursive functions define are (by definition) decidable.
06:48:31 <tromp_> the flaw in their proof is obvious
06:48:41 <alar> ndm: this is astonishingly new for me
06:48:55 <alar> that primrec allows only descending a constructor
06:49:20 <ndm> alar, http://en.wikipedia.org/wiki/Primitive_recursive
06:49:38 <ihope> > (>>)(putStr"Number to multiply: ")((>>=)readLn((.)((.)((>>=)((>>)(putStr"Number 2 to multiply:")readLn))((.)print))(*)))
06:49:39 <lambdabot> No IO allowed
06:49:56 <ndm> alar, not only allows, but at least one argument must be decreasing - others can be increasing
06:49:57 <roconnor> someone ought to just delete the article, so no one will be bothered by it again.
06:50:17 <alar> ndm: there are composition, integer induction and all function are total
06:50:31 <ndm> yes
06:50:48 <ndm> i view "integer induction" as "structural induction"
06:50:59 <ndm> primrec is technically on functions  over natural numbers
06:51:01 <roconnor> Ah, I get it now.
06:51:07 <alar> ah, that Peano point of view
06:51:14 <ndm> extending it to any constructor is a natural thing to do
06:51:19 <roconnor> Turing machine : recrusive function :: Decider : total recursive function
06:52:05 <ndm> yes
06:52:15 <ndm> so Decider is a subset of a turing machine
06:52:17 <roconnor> The problem beging Decider isn't nicely defined like push down automata.
06:52:31 <roconnor> The problem being Decider isn't nicely defined like push down automata.
06:52:32 <ndm> yes, its entirely a bit arbitrary
06:52:42 <roconnor> in fact, it probably can't be nicely defined.
06:52:51 <roconnor> that why it sounds so wonky.
06:52:58 <ndm> roconnor: deciders and undecidable :)
06:53:04 <alar> =))
06:53:06 <roconnor> ndm: excatly
06:53:14 <ndm> but still, it seems a badly written, and most probably wrong page
06:53:16 <ndm> i'll add a comment
06:53:19 <alar> ndm: what do you mean?
06:53:48 <alar> do you mean they are undecidable from that article?
06:53:53 <alar> :)
06:54:02 <ndm> alar, its impossible to decide if a function is total
06:54:37 <ndm> therefore if a decider computes all functions, and is a concrete machine which always terminates, it solves teh halting problem
06:55:43 <roconnor> Automata theory: The factual accuracy of this article is disputed.
06:55:45 <roconnor> *l*
06:57:40 <ndm> roconnor: ok, post that up and i'll chip in with an agree message
06:58:19 <tromp_> oh, i get the article now
06:58:45 <alar> ndm: there should be functions that decider cannot compute
06:59:10 <ndm> alar, there will be
06:59:11 <alar> e.g. solution of the halting problem
06:59:14 <ndm> yes
06:59:16 <ndm> exactly :)
06:59:21 <tromp_> by guaranteed to halt they don't mean happen to halt (as in total functions), but being unable to diverge, like primitive recursive machines
07:00:04 <tromp_> so if for decider you read "primitive recursive function" then it sort of makes sense
07:00:15 <alar> tromp: then you should define "diverge" :)
07:00:50 <tromp_> diverge is not halt:)
07:00:59 <tromp_> run forever
07:01:00 <tromp_> loop
07:01:05 <roconnor> tromp_: A decider is more general than prim rec function, but the same sort of arguements apply to diverges
07:01:59 <alar> yes
07:02:59 <alar> ndm: so what is strcit definition of recursive function?
07:03:00 <roconnor> loop != run forever
07:03:05 <roconnor> loop < run forever
07:03:06 <alar> that of wikipedia?
07:03:15 <roconnor> diverge == run forever
07:03:27 <ihope> Loops are always detectable?
07:03:54 <alar> ihope: supposedly no
07:04:04 <roconnor> ihope: yes, if you have a bigger machine.
07:04:09 <ihope> Well, once they're entered?
07:04:16 <alar> because when they are detectable halting problem may be decidable
07:04:23 <ihope> "may be"?
07:04:23 <roconnor> just watch to see if a state is repeated.
07:04:40 <norpan> roconnor: the problem is how long to watch
07:04:44 <ndm> alar, anything that can be computed by a turing machine
07:05:04 <roconnor> norpan: correct.  Loops are semi-decideable.
07:05:16 <ihope> Like halting is semi-decidable?
07:05:22 <norpan> exactly
07:05:35 <norpan> if the program halts, you will probably detect it :)
07:05:35 <alar> ndm: this definition is not constructive :) is it just always-present property
07:06:21 * alar agrees with norpan
07:07:08 <ihope> So if we run all the possible Turing machines forever, those which will halt at some point will.
07:07:32 <ihope> So we approach a solution to the halting problem, but never actually find it.
07:08:09 <alar> the same with loops
07:10:15 <ihope> Yep.
07:10:24 <ihope> The loop-de-loop problem :-P
07:13:53 <alar> so here comes another question
07:14:17 <alar> Is there a constructive definition of recursive function?
07:14:29 <alar> or
07:14:39 <ihope> Um...
07:14:43 <ihope> Lambda calculus?
07:14:53 <alar> Is the defintion of recursive function from wikipedia right?
07:15:36 <roconnor> alar: I think I can find one for you.
07:15:43 <alar> ihope: then what is the defintion of primrec function in terms of lamvda calculus?
07:16:12 <ihope> Mmh.
07:16:31 * ihope looks
07:16:46 <roconnor> arxiv.org/abs/cs.LO/0505037
07:16:58 <roconnor> General Recursion via Coinductive Types
07:18:08 <roconnor> the idea is that the type of the result of computation is data Computable a = a | Step (Computable a)
07:18:25 <roconnor> mabye data Compute a = a | Step (Compute a) is better
07:18:33 <roconnor> Compute is a Monad!
07:19:02 <roconnor> diverge = Step diverge
07:21:27 <alar> roconnor: and primrec in terms of data Compute is
07:21:45 <ihope> roconnor: you'll need a constructor on that "a"
07:23:52 <roconnor> ihope: right data Compute a = Result a | Step (Compute a)
07:24:19 <roconnor> alar: well general recursive functions are of the form a -> Compute b
07:25:22 <ski> roconnor : that type is coinductive, yes ?
07:25:54 <roconnor> ski: yes, it needs that to represent divergent computation
07:25:54 * ski sees paper link, few lines up
07:26:20 <roconnor> ski: I'm just recalling from memory.  I haven't looked at the paper in a while.
07:26:36 <ski> (s/sees/notices/)
07:26:55 <ihope> fix Step
07:27:46 <alar> ski: what is coinductive? Producing inductive data structure?
07:28:18 <ski> roconnor : i assume one'd need top-level to actually fully walk down such a potentially-finite structure
07:28:45 <ski> alar : coindictive datatype, not inductive
07:28:58 <ski> alar : greatest fixpoint, instead of least, iiuc
07:29:27 <ihope> What's the least fixed point of the identity function?
07:29:44 <roconnor> ski: more or less.  Internally I'd expect a function to run n steps for any given n.
07:29:47 <ski> (roconnor : i.e. one couldn't define 'forall a. Compute a -> a' in the language, yes ?)
07:30:14 <alar> where can I read something about fixpoints?
07:30:29 <ski> ihope : i was referring to fixpoints of type constructors
07:30:57 <roconnor> ski: correct, nor in any langauge.  What would it return for (fix Step)?
07:31:08 <ski> ihope : in this case of the type '\r -> a + r'
07:31:43 <roconnor> alar: wikipedia maybe? :P
07:32:07 <ski> roconnor : m (of course one can in-language walk down the structure by any natural one happens to have around)
07:34:16 <alar> roconnor: ok, then waht order do you use talking about least/greates fixpoints?
07:36:19 <roconnor> alar: good question.
07:42:48 <roconnor> a < b if a is a substructure of b.
07:42:55 <roconnor> I think
07:43:04 <sbeyer> dcoutts, (about gtk2hs) how can I change cellRenderer properties for the whole cell and not for the text/toggle/pixbuf? (those mentioned in http://developer.gnome.org/doc/API/2.0/gtk/GtkCellRenderer.html)
07:44:27 <sbeyer> dcoutts, e.g. to set the attributes for text, I use: textrenderer <- cellRendererTextNew ; col <- treeViewColumnNewWithAttributes title textrenderer [("text",0),("foreground",1)]
07:44:49 <sbeyer> dcoutts, now I want to add ("is-expander",2)
07:46:35 <alar> roconnor: so in lambda caculus lfp of something is the lambda-expression that reduces to subexpression of other fixpoints?
07:48:10 <roconnor> alar: Well, I'm thinking of lfp on type equation, for generating inductive types.
07:48:39 <roconnor> so List A is the lfp of F X = A + X.
07:48:58 <roconnor> wait
07:49:03 <roconnor> is that right?
07:49:15 <roconnor> no
07:49:24 <roconnor> so List A is the lfp of F X = A*X + 1
07:49:35 <roconnor> yes
07:50:55 <roconnor> So F X is either the pair A and X, or the unit type 1.
07:51:09 <roconnor> the unit type 1 represents the nil list
07:51:25 <alar> yes
07:51:35 <roconnor> the pair A X will represent cons when X is a list A.
07:51:46 <ski> (initial F-algebras)
07:51:58 <roconnor> X is a substructure of A*X + 1
07:52:18 <roconnor> extend by transitivity
07:53:15 <alar> then what is gfp of this F?
07:53:32 <alar> universe?
07:54:00 <roconnor> you need to consider the class of possible types to inlcude ``infinite structures''
07:54:33 <roconnor> now my understanding here is even shakier than for lfp
07:54:46 <alar> oh, thanks
07:55:29 <roconnor> let Z = A*Z
07:55:47 <roconnor> wait, nevermind
07:58:59 <ski> alar : gfp of that F is the type of potentially finite streams of A
07:59:04 <ski> (i think)
08:06:48 <alar> Thanks to you all!
08:06:59 * alar has to go
08:31:14 <ihope> No discussion?
08:35:45 <ihope> ...I need discussion!
08:35:53 <ihope> Can I explain to someone what monads are?
08:37:20 <TuringTest> Hmm...it is quiet.
08:38:04 <ihope> Yes! Yes!
08:39:39 <TuringTest> I don't see a concurrency library that allows recursive mutex things
08:39:48 <ihope> Oh, say...
08:39:51 <TuringTest> So I am seeing if I can roll my own
08:39:56 <ihope> (can you see?)
08:40:02 <TuringTest> (uh oh)
08:40:12 <sbeyer> hm.
08:40:20 <TuringTest> sbeyer: ?
08:40:31 <ihope> How do I make the output from a Haskell program take up all but the bottom line of the terminal, and leave that for input?
08:40:50 <TuringTest> ihope: look at hmp3 for the curses interface
08:43:32 <ihope> You mean the mp3 player?
08:44:45 <TuringTest> Yeah
08:45:00 <TuringTest> I have only heard of it -- I have not used it
08:45:19 <TuringTest> But I hear it is a console program, so I expect it uses curses
08:45:29 <ihope> Yep.
08:45:47 <ihope> So what's with the #including? Is this C or what?
08:46:08 <palomer> http://www.rafb.net/paste/results/dA67Wb28.html
08:46:36 <palomer> http://www.rafb.net/paste/results/xYGjIr52.html
08:46:42 <palomer> that last one has more information
08:46:46 <palomer> any help is appreciated
08:47:35 <ihope> Hmm...
08:48:19 <ihope> Well, you can pass Maybe (Eq a b) to it, even if a and b are different.
08:48:27 <ihope> It'll just result in a pattern match failure.
08:51:09 <TuringTest> palomer: GHC looks like it is doing the expected thing to me.
08:52:06 <TuringTest> palomer: I assume you are trying to create a witness of some kind?
08:54:58 <sili> i wonder if they'll let me write the scheduler in haskell
08:55:08 <sili> i'd like that much better than c++
08:55:51 <ihope> What scheduler?
08:56:12 <TuringTest> What tasks are being scheduled?
08:58:15 <musasabi> HSXML looks so pretty and innocent.
08:58:38 <ihope> !
08:58:41 <musasabi> then I made the mistake of hitting :t in ghci and whathes a few screenfulls of the type scrolling by.
08:58:49 <ihope> Heh.
08:59:26 <ihope> @type (const const :: a -> (a -> a -> a)) (const const :: a -> (a -> a -> a)) (const const :: a -> (a -> a -> a)) (const const :: a -> (a -> a -> a)) (const const :: a -> (a -> a -> a))
08:59:27 <lambdabot> forall a.
08:59:27 <lambdabot>                                                              (a
08:59:27 <lambdabot>                                                               -> a
08:59:27 <lambdabot>                                                               -> a
08:59:27 <lambdabot>                                                               -> a)
08:59:28 <sili> ihope: a student scheduler
08:59:29 <lambdabot> [10 @more lines]
08:59:50 <ihope> @more
08:59:50 <lambdabot>                                                              -> (a
08:59:50 <lambdabot>                                                                ->
08:59:50 <lambdabot> a
08:59:50 <lambdabot>                                                                ->
08:59:50 <lambdabot> a
08:59:52 <lambdabot> [5 @more lines]
09:00:02 <ihope> This is severely booched.
09:00:06 <ihope> @more
09:00:06 <lambdabot>                                                                -> a)
09:00:06 <lambdabot>                                                              -> a
09:00:06 <lambdabot>                                                              -> a
09:00:06 <lambdabot>                                                              -> a
09:00:06 <lambdabot>                                                              -> a
09:00:34 <ihope> forall a. (a -> a -> a -> a) -> (a -> a -> a -> a) -> a -> a -> a -> a
09:00:39 <ihope> Why doesn't it just print that?
09:00:50 <vincenz> o.O
09:01:39 <ihope> Whoa...
09:01:40 <ihope> @type ((const const :: a -> (a -> a -> a)) . (const const :: a -> (a -> a -> a)) . (const const :: a -> (a -> a -> a)) . (const const :: a -> (a -> a -> a))) (const const :: a -> (a -> a -> a))
09:01:42 <lambdabot> forall a.
09:01:42 <lambdabot>                                                                 ((((
09:01:42 <lambdabot> a
09:01:42 <lambdabot>                                                                  ->
09:01:42 <lambdabot> a
09:01:44 <lambdabot> [564 @more lines]
09:01:50 <vincenz> and all those emptylines
09:01:59 <ihope> 564 is a lot.
09:02:13 * vincenz smacks ihope 
09:02:32 <adu> wow
09:02:58 <ihope> @type (const const :: a -> (a -> a -> a)) ((const const :: a -> (a -> a -> a)) . (const const :: a -> (a -> a -> a)) . (const const :: a -> (a -> a -> a)) . (const const :: a -> (a -> a -> a))) (const const :: a -> (a -> a -> a))
09:02:59 <lambdabot>   Occurs check: cannot construct the infinite type:
09:02:59 <lambdabot>   a
09:03:06 <adu> um
09:03:12 <ihope> Doesn't look infinite to me.
09:03:20 <vincenz> @seen cale
09:03:20 <lambdabot> cale is in #haskell. Last spoke 7 hours, 32 minutes and 29 seconds ago.
09:03:37 <vincenz> ihope: it doesn't?
09:03:45 <vincenz> ihope: so "inf" doesn't look infinite to you either?
09:03:58 <adu> so does HaRP let you do non-matching lookaheads?
09:03:59 <ihope> vincenz: no, it doesn't
09:04:08 <ihope> a where a = a -> t looks infinite.
09:04:08 <vincenz> ihope: it's a mnemonic for infinite!
09:04:18 <ihope> Just plain old a doesn't look infinite.
09:04:20 <vincenz> ihope: well it just hides the where clause
09:04:32 <vincenz> a can be anything
09:04:34 <vincenz> including that
09:04:38 <ihope> @remember lambdabot Occurs check: cannot construct the infinite type: a
09:04:38 <lambdabot> Done.
09:04:40 <vincenz> so "a" looks perfectly infinite to me
09:04:46 <ihope> Bleh.
09:04:53 <musasabi> Proper records would just make the types that much easier, without all the HList stuff.
09:05:05 <ihope> But my expression shouldn't have an infinite type, should it?
09:05:17 <vincenz> > reverse "ihope"
09:05:18 <lambdabot> "epohi"
09:05:48 <xerox_> Hi!
09:05:54 <vincenz> ciao
09:06:27 <xerox_> Sigh, my internet doesn't really work...
09:06:56 <ihope> @quote
09:06:56 <lambdabot> SebastianHanowski says: I tried to formalise a proof of rev (rev l)  = l
09:06:56 <lambdabot> i found in W. Kluges book "Abstract Computing Machines - A Lambda
09:06:56 <lambdabot> Calculus Perspective" which is pretty much a 'Pimp My Ride' for SECD-
09:06:56 <lambdabot> machines.
09:07:07 <ihope> @index rev
09:07:08 <lambdabot> Text.Html
09:07:11 <xerox_> rev?
09:07:16 <ihope> @type Text.Html.rev
09:07:17 <lambdabot> String -> Text.Html.HtmlAttr
09:07:27 <xerox_> That's prolly not the same rev :-)
09:07:39 <ihope> @type Text.Html.rev . Text.Html.rev
09:07:40 <lambdabot>   Couldn't match `String' against `Text.Html.HtmlAttr'
09:07:40 <lambdabot>   Expected type: String -> String
09:08:36 <TuringTest> > foldl (flip (:)) [] "ihope"
09:08:37 <lambdabot> "epohi"
09:08:46 * ihope claps
09:08:54 <ihope> @type foldl foldl
09:08:55 <lambdabot>   Couldn't match `b -> [b]' against `[b]'
09:08:55 <lambdabot>   Expected type: ([b] -> b -> [b]) -> [b] -> [b] -> b -> [b]
09:09:05 <ihope> @type foldr
09:09:06 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
09:09:09 <ihope> @type foldl
09:09:09 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
09:09:38 <ihope> @type foldl (flip (:))
09:09:38 <lambdabot> forall b. [b] -> [b] -> [b]
09:09:54 <ihope> @type foldl (foldl (flip (:)))
09:09:55 <lambdabot> forall b. [b] -> [[b]] -> [b]
09:10:03 <ihope> @type foldl (foldl (foldl (flip (:))))
09:10:03 <lambdabot> forall b. [b] -> [[[b]]] -> [b]
09:10:49 <ihope> > foldl (foldl (foldl (flip (:)))) [1,2] [[[3,4],[5,6]],[[7,8],[9,10]]]
09:10:50 <lambdabot> [10,9,8,7,6,5,4,3,1,2]
09:10:56 <ihope> Whoa.
09:11:09 <ihope> @type foldr (:)
09:11:10 <lambdabot> forall a. [a] -> [a] -> [a]
09:11:15 <palomer> TuringTest: clearly, the scrutinee has to be of type Maybe (Equal a a)
09:11:26 <ihope> @type foldr (foldr (:)) [] [[1,2,3],[4,5,6],[7,8,9]]
09:11:27 <lambdabot> forall a.
09:11:27 <lambdabot>                  (Num a) =>
09:11:27 <lambdabot>                  [a]
09:11:37 <ihope> > foldr (foldr (:)) [] [[1,2,3],[4,5,6],[7,8,9]]
09:11:38 <lambdabot> [7,8,9,4,5,6,1,2,3]
09:11:42 <ihope> Um.
09:11:46 <palomer> welp, I must be off
09:12:09 <TuringTest> palomer: Imagine that data Equal was imported from anther module without importing the constructor(s).
09:12:17 <ihope> @type (foldr (foldr (:)) . foldl (flip (:)) [])
09:12:17 <lambdabot> forall a.
09:12:17 <lambdabot>                [a] -> [[a]] -> [a]
09:12:21 <ihope> @type (foldr (foldr (:)) . foldl (flip (:)) []) []
09:12:22 <lambdabot> forall a.
09:12:22 <lambdabot>                 [[a]] -> [a]
09:12:31 <TuringTest> palomer: Then f cannot know about Eq 's type signature
09:12:36 <ihope> > (foldr (foldr (:)) . foldl (flip (:)) []) [] [[1,2,3],[4,5,6],[7,8,9]]
09:12:37 <lambdabot> [7,8,9,4,5,6,1,2,3]
09:12:41 <ihope> Grr.
09:13:03 <ihope> > foldr (foldr (:)) [[1,2,3],[4,5,6],[7,8,9]]
09:13:04 <lambdabot>  add an instance declaration for (Show ([[[a]]] -> [[a]]))
09:13:15 <ihope> > foldr (foldr (:)) [] [[1,2,3],[4,5,6],[7,8,9]]
09:13:16 <lambdabot> [7,8,9,4,5,6,1,2,3]
09:13:28 <ihope> > (foldr (foldr (:)) [] . foldl (flip (:)) []) [[1,2,3],[4,5,6],[7,8,9]]
09:13:29 <lambdabot> [1,2,3,4,5,6,7,8,9]
09:13:37 <ihope> Yay!
09:15:39 <davidhouse> > [1..9]
09:15:40 <lambdabot> [1,2,3,4,5,6,7,8,9]
09:15:44 <davidhouse> Yay!
09:15:49 <adu> whats a pretty printing combinator?
09:16:46 <earthy> adu: say you have a pretty printer that prints "a" and a pretty printer that prints "b"
09:17:02 <earthy> then a pretty combinator can take those pretty printers and make a new one that prints
09:17:05 <earthy> "
09:17:06 <earthy> a
09:17:07 <earthy> b
09:17:07 <earthy> "
09:17:09 <earthy> e.g.
09:17:12 <earthy> or  "ab"
09:17:13 <earthy> or whatever
09:17:28 <adu> oh
09:17:34 <earthy> easy, huh? :)
09:17:41 <adu> so its just another pretty printer
09:18:16 <earthy> no
09:18:16 <TuringTest> > foldr (flip $ foldr (:)) []  [[1,2,3],[4],[],[5,6],[7,8,9]]
09:18:17 <lambdabot> [1,2,3,4,5,6,7,8,9]
09:18:27 <earthy> it's a function that takes pretty printers and returns a new one
09:18:37 <adu> ok
09:18:38 <earthy> subtle difference
09:18:45 <TuringTest> > (++) "hello " "world"
09:18:46 <lambdabot> "hello world"
09:18:59 <adu> is that a pretty printer?
09:18:59 <TuringTest> > (flip $ foldr (:)) "hello " "world"
09:19:00 <lambdabot> "hello world"
09:19:13 <earthy> no, it is'nt. :)
09:19:15 <ihope> > (foldr (foldr (:)) [] . foldl (flip (:)) []) ["om","gtf","fbbq"]
09:19:16 <lambdabot> "omgtffbbq"
09:19:24 <ihope> Good enough.
09:20:11 <ihope> > (-:)-:^_^
09:20:12 <lambdabot>  parse error on input `}'
09:20:22 <ihope> > (-:)-:v_v
09:20:22 <lambdabot>  Not in scope: `v_v'
09:20:43 <ihope> > (-: )-: v_v
09:20:44 <lambdabot>  Not in scope: `v_v'
09:21:59 <araujo> Hello
09:22:07 <ihope> @type let (-:) = ($); v_v = id in (-: )-: v_v
09:22:08 <lambdabot> forall a. a -> a
09:22:55 <sjanssen> woo! just wrote my first FFI program ever
09:23:12 <adu> how do you convert an array to a list of lists?
09:23:41 <ihope> What's an array? :-P
09:23:44 <sjanssen> adu: what is the type of the array?
09:24:03 <adu> um Marray BigFloat
09:24:23 <sjanssen> it should have an index type
09:24:38 <adu> i need BigFloat tho
09:24:47 <adu> Float or Double won't work
09:24:54 <beelsebob_> @where quickcheck
09:24:54 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
09:25:42 <sjanssen> adu: getElems or getAssocs both get the elements in an array
09:25:52 <adu> ok thanks
09:30:13 <Cale> hello
09:30:31 <roconnor> hi
09:30:41 <Cale> vincenz: you were looking for me?
09:31:09 <ihope> > (>>>>>)
09:31:09 <lambdabot>  Not in scope: `>>>>>'
09:31:29 <ihope> @type (>>) `asTypeOf` (Control.Arrow.>>>)
09:31:30 <lambdabot> forall b
09:31:30 <lambdabot>                 (a :: * -> * -> *)
09:31:30 <lambdabot>                 b1.
09:31:30 <lambdabot>              (Monad (a b1), Control.Arrow.Arrow a) =>
09:31:30 <lambdabot>              a b1 b1 -> a b1 b -> a b1 b
09:32:22 <ihope> Wow.
09:32:32 <roconnor> > (>>)>>>(>>)
09:32:32 <lambdabot>   add an instance declaration for (Show (m a -> (m b -> b1) -> m b -> b1))
09:32:54 <ihope> @type (>>) Control.Arrow.>>> (>>)
09:32:55 <lambdabot> forall (m :: * -> *) a b b1.
09:32:55 <lambdabot>            (Monad m, Monad ((->) (m b))) =>
09:32:55 <lambdabot>            m a -> (m b -> b1) -> m b -> b1
09:33:26 * ihope shakes his little ol' head
09:33:39 <roconnor> its a useful function.
09:34:16 <ihope> Is it?
09:34:26 <roconnor> no
09:34:31 <ihope> Oh.
09:34:33 <roconnor> I don't know what it does.
09:34:51 <ihope> @type (Control.Møøse.>>=)
09:34:51 <lambdabot> lexical error
09:34:53 <roconnor> probably just a fancy way of saying (flip const)
09:35:03 <ihope> I don't think so.
09:35:08 <ihope> Well...
09:35:57 * beelsebob_ wonders how to get quickcheck to not do massive tests
09:35:59 <ihope> Maybe it sticks the monad bit of its first argument onto its third argument.
09:36:06 <roconnor> > quickcheck (\a b -> ((>>)>>>(>>)) a b == (flip const) a b)
09:36:07 <lambdabot>  Not in scope: `quickcheck'
09:36:29 <roconnor> ihope: there are only two arguements.
09:37:02 <roconnor> beelsebob_: make a fine tuned instance of Arbitrary?
09:39:04 <beelsebob_> roconnor: I have a good instance of arbitrary that uses sized... I'm just trying to figure out how to tell it not to do tests bigger than size 6
09:39:10 <ihope> roconnor: m a -> (m b -> b1) -> m b -> b1 looks like three to me
09:39:53 <roconnor> ihope: yep, I'm dumb
09:39:57 <Cale> however, it has to discard its first parameter
09:40:15 <Cale> hmm, maybe not
09:40:17 <roconnor> ihope: I'm starting to think you might be right.
09:40:34 <Cale> I suppose it could be f x y z = y (x >> z)
09:40:37 <roconnor> Cale: yep, it could use the plumbing of m a, and just ignore the result.
09:41:22 <ihope> Hmm, plumbing.
09:41:31 <ihope> As in pipes?
09:41:40 <beelsebob_> ... when the test input gets beyond 100 pages of terminal long it's getting silly
09:42:00 <roconnor> ihope: well, what do you call the part of a monad m a that isn't a?
09:42:20 <ihope> The monadic bit.
09:42:24 <roconnor> ;)
09:42:47 * roconnor always imagines plumbing.
09:43:03 <Cale> You're referring to all the actions that are not in the range of return?
09:43:42 <roconnor> monadic plumbing is always straight.  I suppose arrow plumbing becomes crazy.
09:43:53 <ihope> Arrow arrow arrow.
09:44:04 <ihope> Only somewhat less confusing than comonads.
09:44:07 <Cale> or was that an abuse of the term 'monad'? :)
09:44:16 <roconnor> > (>>>)>>>(>>>)
09:44:16 <lambdabot>   add an instance declaration for (Show (a b c -> (a b d -> d1) -> a c d -
09:44:16 <lambdabot> > d1))
09:44:34 <ihope> roconnor: I think that's (>>>).(>>>)
09:44:38 <davidhouse> > (\x y z -> y (x >> z)) (["hello world"]) head [1..5]
09:44:39 <lambdabot> 1
09:44:51 <roconnor> > (>>>).(>>>)
09:44:52 <lambdabot>   add an instance declaration for (Show (a b c -> (a b d -> d1) -> a c d -
09:44:52 <lambdabot> > d1))
09:44:53 <davidhouse> how is >> defined for lists?
09:45:02 <ihope> > [1,2,3] >> [4,5,6]
09:45:03 <lambdabot> [4,5,6,4,5,6,4,5,6]
09:45:20 <ihope> It repeats the right list once for each element in the left list.
09:45:27 <roconnor> a >> b == replicate (length a) b ??
09:45:36 <roconnor> a >> b == concat$ replicate (length a) b ??
09:45:44 <ihope> I think so.
09:45:45 <Cale> yeah, up to strictness
09:45:54 <roconnor> strictness?
09:46:08 <Cale> of course those aren't quite the same since length doesn't finish on infinite lists
09:46:16 <roconnor> ah yes
09:46:18 <roconnor> of course
09:46:36 <ihope> > [1..] >> [1,2,3]
09:46:37 <lambdabot> [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,
09:46:37 <lambdabot> 1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,
09:46:37 <lambdabot> 2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,
09:46:37 <lambdabot> 3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,
09:46:37 <lambdabot> 1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,
09:46:39 <lambdabot> [23 @more lines]
09:46:40 * roconnor sometimes forgets that he isn't working with Nat.
09:46:40 <davidhouse> in general, a (>>) b = a >>= (\_ -> b), yeah?
09:46:51 <ihope> davidhouse: yep.
09:47:04 <Cale> yeah
09:47:04 <roconnor> concat $ replicate (length [1..]) [1,2,3]
09:47:06 <roconnor> > concat $ replicate (length [1..]) [1,2,3]
09:47:10 <lambdabot> Terminated
09:47:15 <ihope> @index Nat
09:47:15 <lambdabot> bzzt
09:47:22 <ihope> Prelude it!
09:47:23 <Cale> or  a >> b = a >>= const b  is a nice way to write that
09:48:01 <davidhouse> so in lists, it's concatMap (\_ -> b) a
09:48:14 <Cale> yep
09:48:31 <Cale> > concatMap (const [5,6]) [1,2,3]
09:48:32 <lambdabot> [5,6,5,6,5,6]
09:48:43 <Cale> > [1,2,3] >> [5,6]
09:48:43 <davidhouse> ah, of course.
09:48:44 <lambdabot> [5,6,5,6,5,6]
09:48:50 <adu> why is my matrix function not working
09:49:17 <roconnor> adu: what is the matrix?
09:49:19 <adu> slogMatrix n = [x      | x <- slogMatrixElem j k     | j <- [0..(n-1)]     | k <- [1..(n)]]
09:49:28 <sjanssen> > length $ [(), (), ()] >> [(), ()]
09:49:29 <lambdabot> 6
09:49:45 <adu> it says theres an error
09:49:58 <davidhouse> what's "slogMatrixElem"?
09:50:02 <Cale> adu: that's a parallel list comprehension?
09:50:13 <adu> i dunno, is it?
09:50:21 <Cale> no, you couldn't want that
09:50:32 <Cale> j and k are out of scope in the first generator
09:50:37 <sjanssen> adu, change all but the first |s to commas
09:50:39 <davidhouse> try replacing all the | after the first with commas.
09:50:40 <adu> i want the matrix elements to be computed with slogMatrixElem j k
09:50:46 <roconnor> I see one [ and three ]
09:51:34 <roconnor> oh now I see three [
09:51:39 <Cale> [x | j <- [0 .. n-1], k <- [1..n], x <- slogMatrixElem j k]
09:51:40 <sjanssen> slogMatrix n = [slogMatrixElem j k     | j <- [0..(n-1)]     | k <- [1..(n)]]
09:51:41 <adu> sjanssen: then it says undefined "k"
09:51:48 <sjanssen> bah, didn't mean to press enter there
09:51:54 <roconnor>  [slogMatrixElem j k  | j <- [0..(n-1)], k <- [1..(n)]] is probably what you are trying to say.
09:52:03 <davidhouse> what Cale or roconnor said.
09:52:03 <adu> oh
09:52:04 <adu> ok
09:52:19 <Cale> unless slogMatrixElem returns a list, in which case it's what I said
09:53:16 <adu> yey it works now
09:53:36 <adu> it was [[slogMatrixElem j k | ...] | ...]
09:53:40 <adu> thanks
09:54:06 <adu> sorry for the confusion
09:55:28 <sellout> So, I'm looking into a bug tracker ... Haskell Prime uses Trac + darcs ... is darcs integrated like  svn is?
09:59:08 <sjanssen> > let factorial = length . sequence . tail . Data.List.inits in factorial $ replicate 9 ()
09:59:09 <lambdabot> 362880
09:59:18 <beelsebob_> roconnor: you see what's wrong with this... conts :: Gen [Object]; conts = liftM (liftM (\n -> take n . repeat) listSize) (resize (n-1) arbitrary)
09:59:28 <beelsebob_> listSize :: Gen Int
09:59:43 <beelsebob_> error is     Couldn't match `[Object]' against `t -> t1'
10:00:29 <roconnor> what's the type of resize?
10:00:35 <adu> how would you do a for-loop in haskell?
10:00:46 <beelsebob_> um...
10:00:47 <beelsebob_> resize :: Int -> Gen a -> Gen a
10:00:54 <beelsebob_> it's a QuickCheck built in
10:00:58 <beelsebob_> limits the size of something
10:00:58 <roconnor> oh
10:01:05 <roconnor> wow
10:01:09 <roconnor> I could use that.
10:01:15 <roconnor> anyhow
10:01:30 <roconnor> adu: foldr and map replace many uses of for-loops
10:01:35 <adu> ok
10:01:46 <beelsebob_> adu: for 0 f x = x; for n f x = f (for (n-1) f x)
10:01:54 <beelsebob_> but yes... use foldr and map
10:02:22 <adu> i think i could use map
10:02:29 <adu> i'm afraid of foldr
10:02:45 <beelsebob_> nothing scary about foldr
10:02:51 <roconnor> sum xs = foldr (+) 0 xs
10:03:01 <roconnor> product xs = foldr (*) 1 xs
10:03:16 <beelsebob_> > for 0 f x = x; for n f x = f (for (n-1) f x) in for 10 (+1) 1
10:03:17 <lambdabot>  parse error on input `='
10:03:22 <__AL__> Does anybody know why Make can hang while compiling GHC?
10:03:26 <beelsebob_> > let for 0 f x = x; for n f x = f (for (n-1) f x) in for 10 (+1) 1
10:03:26 <lambdabot> 11
10:04:00 <adu> oh they're plenty scary about foldr, 1) it has a wierd "r" on the end, 2) it does some crazy magic when you call it, and 3) it seems like a fancy version of map anyways so why do you need it?
10:04:22 <roconnor> what's the type of listSize?
10:04:30 <beelsebob_> roconnor: Gen Int
10:04:53 <beelsebob_> for n f x = foldr apply x (replicate n f)
10:04:53 <roconnor> adu: stay away from foldl for now.
10:05:06 <roconnor> adu: foldr is where it is at.
10:05:09 <adu> hehe
10:05:18 <beelsebob_> > let for n f x = foldr apply x (replicate n f) in for 10 (+1) 1
10:05:19 <lambdabot>  Not in scope: `apply'
10:05:21 <adu> they both have funny letters on the end
10:05:22 <beelsebob_> bah
10:05:35 <beelsebob_> @hoogle (a -> b) -> a -> b
10:05:36 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
10:05:36 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
10:05:36 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
10:05:39 <adu> i wouldn't be afraid of "fold" but "foldr" and "foldl" scare me
10:05:43 <roconnor> > let for n f x = foldr (.) id (replicate n f) in for 10 (+1) 1
10:05:44 <lambdabot>  add an instance declaration for (Show (a -> a))
10:05:47 <beelsebob_> > let for n f x = foldr ($) x (replicate n f) in for 10 (+1) 
10:05:48 <lambdabot>  add an instance declaration for (Show (b -> b))
10:05:57 <beelsebob_> ... obviously not
10:06:03 <beelsebob_> oh yes
10:06:10 <beelsebob_> > let for n f x = foldr ($) x (replicate n f) in for 10 (+1) 1
10:06:11 <lambdabot> 11
10:06:13 <beelsebob_> :)
10:06:15 <beelsebob_> rocking
10:06:25 <roconnor> @type (\n-> take n . repeat)
10:06:26 <lambdabot> forall a. Int -> a -> [a]
10:06:35 <roconnor> @type replicate
10:06:35 <lambdabot> forall a. Int -> a -> [a]
10:06:44 <resiak> @pl (\n-> take n . repeat)
10:06:45 <lambdabot> (. repeat) . take
10:06:53 <resiak> figure. *slinks off*
10:07:08 <beelsebob_> roconnor: indeed that should be a replicate
10:07:34 <roconnor> beelsebob_: the outermost liftM doesn't seem right
10:07:53 <roconnor> liftM replicate listSize seems good
10:08:22 <dcoutts_> @seen sbeyer
10:08:23 <lambdabot> I saw sbeyer leaving #haskell 1 hour, 10 minutes and 34 seconds ago.
10:08:23 <beelsebob_> roconnor: surely it needs that to lift the resulting list into gen?
10:09:07 <roconnor> what does liftSize do? oh it lifts the size.
10:09:11 <beelsebob_> indeed it does - couldn't match Gen a -> [a] against t -> [t]
10:09:14 <adu> how do i do a list comprehention  from like 1..20 butnot 15?
10:09:31 <beelsebob_> roconnor: listSize generates a listSize between 0 and the currect maximum size
10:09:33 <roconnor> beelsebob_: now I understand what you are trying to do.
10:09:59 <beelsebob_> adu: [x | x <- [0..20]; x /= 15]
10:10:03 <adu> is it like [i | i<-[1..20] && i != 15]
10:10:13 <adu> oh
10:10:20 <dcoutts_> > [x | x <- [0..20], x /= 15]
10:10:21 <lambdabot> [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,16,17,18,19,20]
10:10:24 <adu> thanx
10:10:34 <beelsebob_> sorry, yes, comma
10:10:41 <roconnor> do {s <- listSize; let l = repliate s arbitrary; sequence l}
10:10:57 <roconnor> beelsebob_: something like that ought to work
10:11:01 <roconnor> and be more clear.
10:11:13 <beelsebob_> roconnor: close... but I need to call resize rather than arbitrary :)
10:11:17 <beelsebob_> indeed that is clearer
10:11:21 <roconnor> ah
10:11:49 <roconnor> do {s <- listSize; let l = replicate s (resize (s-1) arbitrary); sequence l}
10:12:24 <roconnor> @hoogle Int -> m a -> m [a]
10:12:25 <lambdabot> Data.Graph.Inductive.Monad.newNodesM :: GraphM m gr => Int -> m (gr a b) -
10:12:25 <lambdabot> > m [Node]
10:12:33 <beelsebob_> roconnor: sequence l is not an expression apparently
10:12:51 <roconnor> @hoogle sequence
10:12:51 <lambdabot> Control.Monad.sequence :: Monad m => [m a] -> m [a]
10:12:51 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
10:12:51 <lambdabot> Control.Monad.sequence_ :: Monad m => [m a] -> m ()
10:13:32 <beelsebob_>                         conts = do s <- listSize
10:13:32 <beelsebob_>                                 let l = repliate s (resize (n-1) arbitrary)
10:13:32 <beelsebob_>                                 sequence l
10:13:33 <beelsebob_> Parser.hs:40:45: The last statement in a 'do' construct must be an expression
10:14:22 <adu> how do i put (++) between every element of a list?
10:14:23 <roconnor> bah, put in some { } and ;'s to be sure it isn't indentation.
10:14:38 <beelsebob_> adu: foldr (++) []
10:14:43 <beelsebob_> adu: ... or concat
10:14:54 <adu> Beelsebob: so thats what foldr does!
10:14:58 <roconnor> *l* foldr ;)
10:15:22 <roconnor> adu: that's exactly what foldr does!
10:15:32 <beelsebob_> adu: foldr replaces all the (:)s with it's first argument, and [] with it's second argument
10:15:43 <adu> ic
10:15:46 <beelsebob_> roconnor: I'm certain it's not indentation - my editor doesn't let me use tabs
10:15:58 <adu> roconnor: maybe i'm not so afraid of it then :)
10:16:08 <roconnor> adu: sadly concat is more efficent as I recall.
10:16:09 <beelsebob_> ... it does let me be a muppet though
10:16:18 <beelsebob_> It was indentation - I was just being stupid about where it should go
10:16:56 <adu> alright
10:16:57 <roconnor> beelsebob_: good ol' do notation.  
10:17:04 <adu> i think this is going to work
10:17:33 <beelsebob_> excellent - lots of nice small examples :)
10:18:13 <roconnor> beelsebob_: I can maybe use the same trick so I don't generate giant vectors in my infinite dimensional vector space implemenation.
10:18:31 <roconnor> beelsebob_: You should wikify your knowledge for me ;)
10:18:47 <beelsebob_> heh, my knowledge is just pulling stuff out of the manual and hacking
10:18:52 <beelsebob_> http://www.cs.chalmers.se/~rjmh/QuickCheck/manual.html
10:18:59 <beelsebob_> and then leaning on you when it doesn't work
10:21:16 <roconnor> I guess the lesson is to alway use do block when your monadic code gets the slightest bit complicated.
10:24:04 <beelsebob_> indeed
10:24:13 <beelsebob_> roconnor: I just realised how to make it really simple
10:24:37 <beelsebob_> instance Arbitary [Object] where arbitrary = sized objectList.....
10:24:37 <roconnor> beelsebob_: now that the solution is clear, it is easy to simplify it?
10:24:50 <adu> grr
10:24:53 <roconnor> what is objectList?
10:25:06 <roconnor> what is sized?
10:25:10 <beelsebob_> roconnor: it's a function that limits the size of lists of objects
10:25:19 <beelsebob_> sized :: (Int -> Gen a) -> Gen a
10:25:40 <beelsebob_> takes a function from size to generator and returns a generator
10:26:19 <beelsebob_> oh bugger - but that needs overlapping instances
10:26:31 <beelsebob_> because it overlaps with instance Arbitrary [a]
10:26:48 <roconnor> instances shouldn't overlap, should they?
10:27:00 <beelsebob_> [a] and [Object] do
10:27:38 <roconnor> oh dear
10:27:44 <beelsebob_> indeed
10:27:50 <roconnor> time for newtype
10:27:56 <beelsebob_> yeh - that would work
10:27:59 <roconnor> newtype ObjectList = [Object]
10:28:42 <beelsebob_> actually - no, that doesn't work - because it's the top level list that I want to limit the size of now
10:29:01 <beelsebob_> and as I never see the call to construct that I can't lift the conversion function
10:29:06 <gzl> I like how this guy singles out pattern matching and curried functions as features he likes in Haskell.
10:29:28 <Spark> pretty groundbreaking stuff there :)
10:30:11 <gzl> yeah, seriously.
10:30:17 <roconnor> top level as in Prelude>
10:30:20 <Philippa_> in fairness, if you've not used an ML then Haskell's by far the most likely other language you'll find them in
10:30:49 <dcoutts_> Igloo, has any debian person ever tried a mips port of ghc?
10:30:57 <beelsebob_> roconnor: as in I'm needing to generate a list of objects here
10:31:02 <Igloo> Yes, me
10:31:03 <beelsebob_> and quickcheck calls arbitrary
10:31:11 <beelsebob_> not liftM toList arbitrary
10:31:23 <Igloo> It's waiting on the mips GOT stuff being sanified
10:31:27 <roconnor> beelsebob_:  where is here?
10:31:34 <Igloo> (saneified?)
10:31:43 <beelsebob_> roconnor: in the particular set of tests I'm doing
10:32:41 <roconnor> beelsebob_: and you can't reengineer the code. hmmm
10:33:00 <beelsebob_> roconnor: I can't really go play with the quickcheck module just for the hell of it
10:33:16 <roconnor> huh?
10:33:17 <adu> i get a 3D lists of lists of lists
10:33:40 <dcoutts_> Igloo, care to eplain a bit? I've got a helper (cparrott) who's interested in doing a mips port
10:33:43 <beelsebob_> I can't make quickcheck arbitrarily lift this list really
10:33:52 <roconnor> I mean, shouldn't you be able to replace occurances of [Object] with ObjectList in your code?
10:33:57 <dcoutts_> Igloo, so what's the GOT issue?
10:34:00 <beelsebob_> roconnor: I could... but that's a pita
10:34:11 <roconnor> pita?
10:34:13 <beelsebob_> then I'll spend all my time boxing and unboxing
10:34:17 <beelsebob_> Pain in the arse
10:34:38 <Igloo> dcoutts_: IIRC: GHC executables are too big for the multigot format, so need to use xgot, but the libc object files they need to be linked with are compiled as multigot, so linking fails
10:34:54 <roconnor> beelsebob_: I should show you what I've done in my situtation
10:35:02 <roconnor> @where paste
10:35:03 <lambdabot> http://paste.lisp.org/new/haskell
10:35:25 <dcoutts_> Igloo, ok so I should check what they do on gentoo
10:36:03 <dcoutts_> Igloo, so what are you hoping the resolution will be on debian?
10:36:12 <beelsebob_> roconnor: I'm gonna run off and have a quick chat to my supervisor about this - I'll bbl
10:36:33 <Igloo> I am told Thiemo has Great Plans. That's all I've got.
10:37:01 <roconnor> beelsebob_: ah, actually my stuff isn't all that intersesting
10:37:07 <dcoutts_> Igloo, ok :-)
10:37:48 <Igloo> dcoutts_: It's been 1.5 years since I discovered that, BTW, but I only (coincidentally) found out Great Plans existed a couple of weeks ago
10:38:04 <dcoutts_> Igloo, heh, ok, right.
10:38:52 <roconnor> beelsebob_: what are the types of the functions you are trying to quickcheck?
10:39:22 <cparrott> dcoutts_, Igloo: this message seems to sum up the issue: http://lists.debian.org/debian-mips/2005/10/msg00023.html
10:39:52 <cparrott> not sure what Gentoo does, but maybe it's possible to build up an xgot toolchain from stage1
11:00:05 <xerox_> hi!
11:01:38 <dcoutts_> hia xerox 
11:01:56 <dcoutts_> xerox, did you see the icfp 2005 gui done with cairo?
11:06:09 <audreyt> @pl \str -> return $ mkTagStrNode "str" (map (chr . fromEnum) (encode str))
11:06:09 <lambdabot> return . mkTagStrNode "str" . map (chr . fromEnum) . encode
11:06:45 <audreyt> @pl return . fst . decode (map (toEnum . ord) (Str.unpack str))
11:06:45 <lambdabot> return . fst . decode (map (toEnum . ord) (Str . unpack str))
11:06:56 <audreyt> mmm no qualified names support
11:44:56 <musasabi> What happened to the fast serializing library by Bulat?
11:51:48 <ihope> Nothing on the channel for 30 minutes?
11:51:50 <ihope> Hmm.
11:52:08 <bolrod> Hmm.
11:52:13 <bolrod> ieenterestink
12:08:49 * tumbleweed rolls across the barren tundra
12:15:56 <bolrod> argh.. someone using helium?
12:21:33 <ihope> ?
12:22:59 <bolrod> ?
12:26:51 <ihope> ¿
12:31:32 <TuringTest> 
12:31:36 <ihope> ¡!
12:32:05 <bolrod> ?!?
12:32:21 <ihope> ñññ
12:32:29 <musasabi> ...
12:32:35 <ihope> øøø
12:35:29 <bolrod> haha
12:35:55 <TuringTest> A Møøse once bit my sister
12:36:50 <stesch> Now she is a weremoose.
12:42:38 <ihope> Øh nøës!
12:43:58 <MarcWeber> Is there a tutorial on how to use Data.Graph?
12:45:24 <ndm> MarcWebber, one of The Monad Reader articles concerned it
12:45:31 <ndm> and that was pretty tutorial styled
12:48:12 <MarcWeber> ndm: I'll try google ;-)
12:48:33 <ndm> @google the monad reader data graph
12:48:35 <lambdabot> http://web.mit.edu/ghc/www/libraries/doc-index-F.html
12:49:11 <MarcWeber> thx a lot
12:49:55 <ndm> thats not it by the way, thats just a wrong link :)
12:50:20 <MarcWeber> I noticed it.. but I'll now try 2nd, 3rd, .. match
12:50:31 <ndm> http://www.haskell.org/tmrwiki/PracticalGraphHandling
12:50:35 <ndm> thats the right one
12:51:14 <ndm> MarcWeber: above is the right url
13:06:01 <Robokop> i've a question about a fresh installed ghci, when i type :t chr it says  'not in scope: chr'
13:06:35 <ihope> @index chr
13:06:35 <lambdabot> Data.Char
13:06:41 <ihope> Use Data.Char.chr.
13:06:49 <ihope> @type Data.Char.chr
13:06:49 <lambdabot> Int -> Char
13:07:15 <ihope> @state Michigan
13:07:15 <lambdabot>  @state x
13:07:29 * ihope giggles
13:09:10 <Robokop> so everytime i call chr i have to type Data.Char.chr to use it?
13:09:50 <bolrod> import it?
13:09:52 <ihope> Well, you can type import Data.Char into a source file somewhere, and load that.
13:10:02 <ihope> Or type :m + Data.Char into GHCi.
13:10:23 <Robokop> ke thanks
13:11:15 <Robokop> but i thought it stands in the prelude so it would be loaded automatically
13:11:36 <ski> it's not in Prelude
13:11:51 <ihope> Maybe you could add "import Data.Char" to the Prelude.
13:11:57 <ihope> I don't know what that'll do.
13:12:44 <bolrod> :)
13:12:53 <Robokop> then they cheated me at college
13:12:59 <Robokop> http://www.cs.uu.nl/~afie/haskell/tourofprelude.html#chr
13:13:15 <ihope> Hmm...
13:13:20 <ihope> @type fromEnum
13:13:20 <lambdabot> forall a. (Enum a) => a -> Int
13:13:22 <bolrod>    :add <filename> ...         add module(s) to the current target set
13:13:25 <ihope> > fromEnum 'b
13:13:26 <lambdabot>  lexical error in string/character literal
13:13:28 <ihope> > fromEnum 'b'
13:13:29 <lambdabot> 98
13:13:38 <ihope> > toEnum 65
13:13:38 <lambdabot> Add a type signature
13:13:42 <ihope> > toEnum 65 :: Char
13:13:43 <lambdabot> 'A'
13:13:53 <ihope> Try that.
13:13:58 <Robokop> ke thanks
13:14:37 <Robokop> found that one out my self already, but thought why doesn't chr work
13:21:36 <_frederi1_> hi
13:21:40 <_frederi1_> http://ofb.net/~frederik/q
13:21:43 <_frederi1_> what am i doing wrong here?
13:21:49 <ski> Robokop : i think it used to be that 'chr' and 'ord' were in Prelude .. at least in HuGS
13:22:03 <Robokop> so it is just outdated
13:22:25 <ihope> _frederi1_: try adding some type annotations...
13:22:30 <_frederi1_> i did
13:22:33 <_frederi1_> it didn't help
13:22:40 <ihope> Oh, yeah.
13:22:42 <_frederi1_> would it help you understand it?
13:23:19 <ihope> No :-P
13:23:27 <ihope> Well, try removing the type annotation :-P
13:24:08 <_frederi1_> oh
13:24:25 <_frederi1_> no help
13:24:29 <ski> hm
13:24:34 <_frederi1_> the problem is within the function
13:25:00 <ski> @type Data.Array.ST.runSTArray
13:25:01 <lambdabot> forall e i.
13:25:01 <lambdabot>           (GHC.Arr.Ix i) =>
13:25:01 <lambdabot>           (forall s. GHC.ST.ST s (GHC.Arr.STArray s i e))
13:25:01 <lambdabot>           -> GHC.Arr.Array i e
13:26:08 <ski> @type Data.Array.ST.runSTUArray
13:26:08 <lambdabot> forall e i.
13:26:09 <lambdabot>           (GHC.Arr.Ix i) =>
13:26:09 <lambdabot>           (forall s. GHC.ST.ST s (Data.Array.Base.STUArray s i e))
13:26:09 <lambdabot>           -> Data.Array.Base.UArray i e
13:27:20 <_frederi1_> this works in ghci: runSTUArray (do {ax <- newArray (0,5) (0::Int); return ax})
13:27:24 <_frederi1_> ...
13:28:56 <ski> hm
13:29:05 <ski> maybe the '$' kills the polymorphism
13:29:24 <TuringTest> right
13:29:28 <_frederi1_> hrr?
13:29:35 <ski> try replacing 'runSTUArray $ do ...' by 'runSTUArray (do ...)'
13:29:48 <TuringTest> Using "runST $ do" usually fails
13:29:57 <_frederi1_> absurd
13:29:58 <_frederi1_> yeah
13:30:01 <_frederi1_> that fixes it
13:30:06 <_frederi1_> (up to the next bug)
13:30:09 <ski> (you could probably define the do in a where too, if you like that better
13:30:48 <_frederi1_> runSTUArray a where a = do ...?
13:30:57 <ski> yes
13:31:09 <ski> (avoids the trailing paren that way)
13:31:24 <_frederi1_> i see
13:31:26 <_frederi1_> thanks
13:32:04 <_frederi1_> now...
13:32:06 <_frederi1_> class (IArray UArray k, Ord k, Fractional k) => Elt k
13:32:21 <_frederi1_> i should add (MArray (STUArray s) k (ST s)) to this
13:32:29 <_frederi1_> but it doesn't like the free variable 's'
13:35:59 <ski> ... hm, possibly what you really want is 'forall s. MArray (STUArray s) k (ST s)' (but that would be an extension)
13:36:14 <_frederi1_> in fact i don't even know where to put the annotation
13:36:35 <ski> 'Elt' is a class of yours, yes ?
13:36:42 <_frederi1_> yeah
13:36:46 <_frederi1_> margin :: (IxB a, IxB b, Elt k, (MArray (STUArray s) k (ST s))) ...
13:36:48 <_frederi1_> that doesn't work
13:36:55 <Cale> Yeah, you can't use $ with higher rank functions
13:37:05 <ihope> Cale: hmm?
13:37:07 <_frederi1_> ok
13:37:20 <ski> (is 'margin' a method of this class ?)
13:37:39 <_frederi1_> no
13:38:06 <ski> (hm, of course not .. since you have 'Elt k' in there)
13:38:17 <_frederi1_>     No instance for (MArray (STUArray s) k (ST s))
13:38:17 <_frederi1_>       arising from use of `updateArray' at Vector2.hs:167:22-32
13:38:17 <_frederi1_>     Probable fix:
13:38:17 <_frederi1_>       add (MArray (STUArray s) k (ST s)) to the expected type of an expression
13:38:17 <_frederi1_>       or add an instance declaration for (MArray (STUArray s) k (ST s))
13:38:35 <_frederi1_> i don't know where i should add this annotation
13:38:45 <ski> which code generates that error ?
13:38:47 <_frederi1_> but if i can't add it anywhere, then STUArray would be useless
13:38:55 <ski> code of 'margin' ?
13:38:58 <_frederi1_> yeah
13:39:41 <ski> is 'margin' in ST-monad ?
13:39:54 <_frederi1_> http://ofb.net/~frederik/q
13:39:57 <_frederi1_> i've updated that
13:40:15 <_frederi1_> part of 'margin' is, yeah
13:40:48 <_frederi1_> Elt k implies IArray UArray k
13:41:08 <_frederi1_> so it doesn't make sense to me that this doesn't imply (MArray (STUArray s) k (ST s))
13:43:14 <ski> i guess it would make sense if those two were "kept in synch", yes
13:44:02 <_frederi1_> do you know how to fix my program?
13:44:11 <_frederi1_> where should i add the MArray annotation?
13:48:06 <ski> no
13:48:08 <ski> sorry
13:48:34 <ski> iiuc, what is wanted here is a 'forall s. MArray (STUArray s) k (ST s)' constraint
13:48:38 * TuringTest reads the code
13:48:58 <ski> you could try asking on the mailing-list
13:49:29 <ski> the 'runSTUArray' will conjure up a fresh unknown 's'
13:50:00 <_frederi1_> right
13:50:02 <ski> 's' isn't in scope in the type-signature of 'margin', so you can't add a specific instance constraint
13:50:36 <_frederi1_> but if it is impossible to get around this, then STUArray is useless
13:50:44 <_frederi1_> right?
13:50:47 <ski> all the wanted instances though work 'forall s', so if you could specify that in the constraint, it should work
13:51:05 <TuringTest> _frederi1_: Change Vector $ runSTUArray to not use $.  Try Vector (runSTUArray 
13:51:13 <ski> i haven't used STUArray, so it's very possible that i have missed something
13:51:50 <TuringTest> _frederi1_: It may be the same $ nonsense as runST, so $ might be failing...
13:51:50 <ski> (TuringTest : fyi, we already removed one '$')
13:51:56 <TuringTest> ah
13:52:10 <TuringTest> I was looking at http://ofb.net/~frederik/q
13:52:11 <ski> but you can try
13:52:21 <ski> (but i don't think it will help)
13:52:34 <_frederi1_> same problem
13:52:39 <TuringTest> ok
13:52:44 <ski> (TuringTest : earlier version had 'Vector $ runSTUArray $ do ...')
13:53:48 <ski> _frederi1_ : as said, i haven't used STUArray, so i may have missed something .. but you can try asking on the mailing-list .. it could be that there's some work-around (in case my diagnosis is right)
13:54:34 <TuringTest> That's weird
13:54:34 <ski> hm
13:54:48 <ski> _frederi1_ : how's 'Vector' defined ?
13:54:57 <TuringTest> _frederi1_: how is IxB defined?
13:55:56 <TuringTest> Hmmm.... It may be an unboxing problem....
13:56:53 <_frederi1_> oh hi
13:57:10 <_frederi1_> -- |like Array but uses IxB instead of Ix 
13:57:10 <_frederi1_> newtype Vector k i = Vector (UArray.UArray i k) deriving (Eq) 
13:57:15 <ski> (hm, no there's prolly nothing worng with def. of 'Vector')
13:57:22 <ski> right
13:57:35 <_frederi1_> class (Bounded a, Enum a, Ix a, Eq a, Show a) => IxB a 
13:58:46 <TuringTest> It may be that 'margin' cannot prove that k is a type which is allowed to be Unboxed
13:59:33 <_frederi1_> well it knows that it's IArray UArray
13:59:45 <TuringTest> This would explain why GHC can't find an instance, and asks for a constraint.
14:02:20 <lispy> TuringTest: have i ever failed you?
14:02:25 <lispy> ;)
14:02:28 <_frederi1_> sent message to haskell-cafe
14:03:54 <lisppaste2> TuringTest pasted "for _frederi1_:  This works" at http://paste.lisp.org/display/17728
14:04:16 <TuringTest> _frederi1_: I think it is the Unboxed constaint.  
14:04:46 <TuringTest> If you search the mailing list archives you will find the usual solutions.
14:05:30 <ihope> > sig "+++--+---+--+++"
14:05:31 <lambdabot>  Not in scope: `sig'
14:06:06 <_frederi1_> is Unboxed a class?
14:06:52 <davidhouse> ihope, ?
14:07:01 <ihope> Significance...
14:07:16 <ihope> > log (0.3)
14:07:17 <lambdabot> -1.2039728043259361
14:07:36 <ihope> Exponents! That's what I need!
14:08:16 <ihope> \x -> 10^(x/(x+1))
14:08:21 <_frederi1_> TuringTest: what should I search for?
14:08:21 <ihope> Uh, wait.
14:08:24 <lispy> wouldn't an Unboxed class do the opposite of its name?
14:08:31 <ihope> \x -> 10^(1-x/(x+1))
14:08:35 <davidhouse> ihope, what do you want?
14:08:37 <TuringTest> _frederi1_: I am not sure the best search term
14:09:10 <ihope> davidhouse: I want a function that figures out how "significant" a number is.
14:09:15 <davidhouse> > (\x -> 10^(1-x/(x+1))) 5
14:09:15 <lambdabot> Add a type signature
14:09:22 <davidhouse> ihope: define.
14:09:58 <davidhouse> *define significant
14:10:30 <lispy> perhaps ihope means the number of digits after the decimal point?
14:10:37 <ihope> No.
14:10:43 * lispy boggles
14:10:55 <ihope> The significance of a number x is the function (\x -> 10^(1-x/(x+1))) applied to the length of the shortest BF-SC program that will output its binary representation in little-endian form, without the final 1.
14:11:20 <ihope> http://esoteric.voxelperfect.net/wiki/BF-SC
14:11:31 <davidhouse> > (\x -> 10**(1-x/(x+1))) (5::Float)
14:11:32 <lambdabot> 1.4677993
14:11:35 * lispy wishes he wouldn't have asked :)
14:11:37 <davidhouse> > (\x -> 10**(1-x/(x+1))) (10::Float)
14:11:38 <lambdabot> 1.2328466
14:11:40 <ihope> Oh, right.
14:11:49 <ihope> > (\x -> 10**(1-x/(x+1))) (10000::Float)
14:11:50 <lambdabot> 1.0002303
14:11:54 <ihope> > (\x -> 10**(1-x/(x+1))) (0::Float)
14:11:55 <lambdabot> 10.0
14:11:57 <davidhouse> (^) only does integer exponents
14:11:59 <ihope> > (\x -> 10**(1-x/(x+1))) (1::Float)
14:12:00 <lambdabot> 3.1622777
14:12:05 <ihope> Hmm, good enough.
14:12:09 <lispy> so 0 is a very significant number?
14:12:11 <davidhouse> heh, (^) comes up as a cake in my client :)
14:12:22 <lispy> > (\x -> 10**(1-x/(x+1))) (-4::Float)
14:12:23 <lambdabot> 0.46415883
14:12:26 <ihope> lispy: 0 can't be output without the most significant 1
14:12:37 <ihope> Now, be back later!
14:12:52 <lispy> > (\x -> 10**(1-x/(x+1))) (-1::Float)
14:12:53 <lambdabot> Infinity
14:12:53 <TuringTest> _frederi1_: The core problem is that margin promises to work "forall k" and it really only works for types that are instances of STUArray (i.e. unbox-able).
14:13:03 <lispy> oh, so -1 is a very, very significant number
14:13:35 <TuringTest> _frederi1_: What is the definition of Elt ?
14:13:53 <_frederi1_> http://ofb.net/~frederik/q
14:13:56 <_frederi1_> it's in there
14:14:15 <davidhouse> what _is_ Infinity?
14:14:18 <davidhouse> > Infinity
14:14:19 <lambdabot>  Not in scope: data constructor `Infinity'
14:14:26 <davidhouse> @index Infinity
14:14:27 <lambdabot> bzzt
14:14:48 <_frederi1_> i suppose i should use unsafeFreeze?
14:14:52 <davidhouse> i would assume things like 1/0 would just get set to _|_.
14:15:17 <davidhouse> hmm.. that made little sense.
14:15:20 <davidhouse> _|_ is a type.
14:15:54 <ski> davidhouse : ?
14:16:16 <davidhouse> i don't really know what i'm talking about.
14:16:19 <davidhouse> it's just that:
14:16:20 <davidhouse> > 1/0
14:16:21 <lambdabot> Infinity
14:16:25 <davidhouse> @index Infinity
14:16:26 <lambdabot> bzzt
14:16:34 <sjanssen> davidhouse: that is the IEEE specified behavior
14:16:34 <jethr0_> yes, we've had a lot of arguments about that :)
14:16:40 <jethr0_> it seems Infinity has no public constructor
14:16:47 <ski> (TuringTest,_frederi1_ : i read the error message as complaining about that it doesn't know how to perform the 'readArray' and 'writeArray' operations (in the 'ST s' monad) and the 's' is local, so we can't add constraint mentioning it to 'margin')
14:16:52 <davidhouse> jethr0_: ah.
14:17:04 <lispy> > (1/0) + 8
14:17:04 <lambdabot> Infinity
14:17:07 <davidhouse> sjanssen: that's fine (ish), i was just wondering what exactly Infinity is.
14:17:12 <lispy> > (1/0) - (1/0)
14:17:12 <lambdabot> NaN
14:17:30 <davidhouse> @index NaN
14:17:31 <lambdabot> bzzt
14:17:35 <lispy> davidhouse: it's just a pretty printing of a special floating point value
14:17:50 <TuringTest> ski: You could try and put the constraint on updateArray, but I don't think it would help
14:17:57 <jethr0_> algebraically it's a little evil though
14:18:02 <davidhouse> so data Float = Float f | Infinity or something?
14:18:12 <lispy> davidhouse: no
14:18:13 <TuringTest> ski: GHC has no good way of constraining things to Unbox-able types.
14:18:17 <jethr0_> there's NaN too
14:18:20 <TuringTest> (be default)
14:18:29 <ski> TuringTest : how would adding some kind of 'Unboxed' constraint help, unless that can be related to an 'MArray' constraint with 'STUArray s' of that unboxed type (in the 'ST s' monad) ?
14:18:39 <davidhouse> > (1/0)/(1/0) -- that's undefined in mathematics
14:18:40 <lambdabot> NaN
14:18:49 <davidhouse> (if you define 1/0 = infty)
14:18:55 <TuringTest> ski: I used runSTArray and it compiled.  So it is the issue.
14:19:02 <davidhouse> > (-1)/0
14:19:03 <lambdabot> -Infinity
14:19:08 <davidhouse> ooh, it's even signed.
14:19:13 <ski> TuringTest : could one have a 'class Unboxed (u :: #) (t :: *) | u -> t , t -> u' ?
14:19:43 <TuringTest> ski: Ask the mailing list
14:19:57 <jethr0_> > (-1)/0
14:19:58 <lambdabot> -Infinity
14:20:01 <lispy> @index (#)
14:20:01 <lambdabot> bzzt
14:20:07 <jethr0_> > (1/0) * (-1)
14:20:08 <lambdabot> -Infinity
14:20:10 <lispy> @hoogle (#)
14:20:11 <lambdabot> No matches found
14:20:45 <lispy> > (-1)/0 + (1/0)
14:20:46 <lambdabot> NaN
14:20:52 <davidhouse> lispy: they're kinds, i believe
14:21:45 <ski> TuringTest : i think i see .. both our explanations are correct, i think
14:22:08 * jethr0_ wonders if there's an Obfuscated brainf*ck contest :)
14:22:26 <_frederi1_> i don't even understand why unboxed constraints are necessary. i mean, it's not that i don't want people to be able to call my function with boxed types.
14:22:33 <_frederi1_> it's that i want it to work efficiently
14:22:37 <ski> TuringTest : there's an 'instance forall s k. MArray (STArray s) k (ST s)' that generically takes effect, when using boxed arrays
14:22:39 <davidhouse> jethr0_: that's a tautology
14:22:56 <jethr0_> davidhouse: there's brainf*ck golf though (http://sourceforge.net/forum/forum.php?forum_id=201037 ;-)
14:23:28 <ski> TuringTest : but when wanting to use unboxed arrays, there's no generic corresponding 'instance forall s k. MArray (STUArray s) k (ST s)'
14:24:06 * TuringTest nods
14:24:21 <_frederi1_> when i program in C, it automatically decides whether to put a value in a register, or to put it on the stack and store a pointer to that value in the register. i don't see why haskell can't do the same thing and make everything storable in a UArray
14:24:27 <ski> TuringTest : hence the constraint must be deferred to when 'margin' is used, i.e. a constraint must be added to the type of 'margin' .. but that's not possible
14:25:59 <ski> TuringTest : so, i wonder if one could possibly refactor the instances to something like 'instance forall s k. Unboxed k => MArray (STUArray s) k (ST s)' ...
14:27:05 <ski> (of course that requires write-access to the libs)
14:29:48 <ski> (_frederi1_ : hm, possibly one could envisage 'UArray' always being strict in elements, and just have the current instances as special cases of implementations .. i'm not sure how easily that would be extendable though (or if such extension is common or useful))
14:46:41 <davidhouse> does lambdabot have a CLI?
14:46:49 <davidhouse> i want hoogle and index in GHCi.
14:50:39 <ndm> davidhouse: hoogle has a command line interface
14:50:45 <ndm> @where hoogle
14:50:46 <lambdabot> http://www.haskell.org/hoogle
14:50:57 <ndm> if you download it and build it, its an entirely standalone program
14:52:05 <davidhouse> awesome.
14:57:38 <ndm> i intend to put up downloadable .exe's at some point, so its easier for people
14:58:49 <davidhouse> eww, .exe.
14:59:51 <ndm> i mean an executable
14:59:58 <ndm> i was actually hoping to put up a .hbc
15:00:01 <ndm> generated by Yhc
15:00:06 <ndm> that is entirely cross platform :)
15:00:06 <davidhouse> yeah, i know what you meant.
15:01:02 <davidhouse> woah, you can tell i haven't had ubunutu installed for long: "make: command not found"
15:01:38 <ndm> i have no idea if make on hoogle works
15:01:48 <ndm> i've never tried it, so if it doesn't please submit a patch :)
15:02:04 <ndm> i always just ghc --make whatever it, much easier
15:02:17 <davidhouse> well, there's a Makefile, so i though i'd give it a shot.
15:02:31 <davidhouse> works fine.
15:04:55 <sjanssen> @where lambdabot
15:04:55 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
15:05:26 <davidhouse> ndm, _almost_ fine :) it's complaining about a missing hoogle.txt
15:05:45 <ndm> when you run it?
15:06:09 <davidhouse> yeah. from the main hoogle dir, not from src/
15:06:23 <davidhouse> i think you need a "cp src/hoogle.txt ." in the Makefile
15:06:27 <ndm> davidhouse: copy hoogle.txt from src to the root
15:06:37 <ndm> or specify -l on the command line (i think)
15:06:49 <ndm> feel free to add it and send off a patch
15:07:14 <ndm> i don't really want to touch the makefile directly since i don't actually use it, and can't test
15:08:09 <davidhouse> what / who generates it
15:08:13 <davidhouse> ?
15:09:39 <ndm> hoogle.txt ?
15:10:04 <ndm> data/ has 2 programs that can generate hoogle.txt files
15:10:22 <ndm> but the new preferred way is to grab haddock HEAD, which now has a -hoogle flag
15:10:39 <ndm> i generated it using hadhtml
15:10:52 <ndm> but i will regenerate it using haddock at some point, now the patch is in
15:10:56 <davidhouse> sorry, no, the Makefile. you said you didn't want to touch it, so i assume there's some kind of automake behind it
15:11:21 <ndm> no, no automake
15:11:23 <ndm> i just use windows
15:11:26 <ndm> so never invoke it
15:11:40 <ndm> i mean _I_ don't want to touch it, but will happily apply any patch that anyone sends
15:12:05 <ndm> if i tried to patch it myself, things would probably just go wrong :)
15:12:19 <davidhouse> heh.
15:12:26 <tuomov> I wonder how difficult it would be to use mmapped data in haskell..
15:12:40 <davidhouse> sure. i haven't used darcs before, how do you create patches?
15:12:58 <ndm> make whatever change you want
15:13:01 <ndm> darcs record
15:13:10 <ndm> type y for each of the changes you need
15:13:14 <ndm> then give it a name
15:13:31 <ndm> after thats done, darcs send -o outputfile.patch
15:13:36 <ndm> gzip outputfile.patch
15:13:40 <ndm> and mail me the patch
15:13:49 <davidhouse> okay.
15:14:21 <tuomov> For what I'm doing, I really _need_ lazyness, but I also want to use mmapped raw integers and bits
15:15:37 <tuomov> the mmapping is not essential and may infact go away eventually (as some files may grow huge), but accessing raw integers and bits conveniently is
15:16:48 <tuomov> almost all non-C languages have hard time with binary files on disk
15:17:44 <tuomov> C structs match them exactly if you're careful
15:18:27 * mathrick wonders what is meant by binary files on disk, and how is C privileged here
15:18:35 <davidhouse> ndm, "Invalid repository:  http://www.cs.york.ac.uk/fp/darcs/hoogle"
15:18:38 <Spark> memory map, memcpy
15:18:49 <ndm> davidhouse: what were you trying to do?
15:18:55 <davidhouse> darcs send
15:18:58 <Spark> but change compiler or machine and youre screwed :)
15:19:23 <ndm> ok, i'll log in remotely and see if i can repair it, give me a min
15:19:58 <Spark> tuomov: what do you think of java's serialize (maybe + a bit of syntax sugar)
15:20:49 <ndm> davidhouse: can you try again, it should work...
15:21:14 <tuomov> dunno java, but I don't think it allows accessing known formats?
15:21:44 <davidhouse> ndm, still failing. http://pastebin.com/595442 is the full error
15:21:51 <cpatrick> tuomov: Python has a couple of nice-ish modules for it (array and struct I think they're called)
15:22:09 <tuomov> What I'm trying to do is a possibly huge bitmap
15:22:17 <tuomov> and I want to intersect many of them
15:22:22 <tuomov> that's what I need lazyness for
15:22:35 <ndm> davidhouse: can you ping www.cs.york.ac.uk
15:22:46 <davidhouse> works.
15:22:52 <sjanssen> tuomov: can you rip out the mmap code in FastPackedString?
15:22:54 <tuomov> the bitmap seems best implemented as an n-ary tree
15:22:58 <lispy> we did something recently where we wanted python and fortran to share 3000x3000 element arrays and we just had both languages dump and read from disk as 32bit float.  so I don't think it's only C that can dump/read binary
15:23:20 <ndm> that should work then, i'm not sure why it fails
15:23:35 <ndm> if you just email me the whole makefile, i'll make a patch against it myself and do it that way if you want
15:25:14 <davidhouse> ndm, mailing addr?
15:25:26 <ndm> ndmitchell ----- TA ----- gmail.com
15:27:11 <davidhouse> ndm, sent
15:27:49 <ndm> davidhouse: received, i'll apply that on monday (i'm away from the repo all weekend)
15:27:58 <davidhouse> sure.
15:28:06 <davidhouse> thanks :)
15:29:11 <ndm> thanks for the patch
15:29:19 <ndm> if you have any other hoogle related issues, be sure to raise them
15:33:30 <ski> evening, esap
15:35:18 <esap> evening!
15:35:22 <esap> what's up?~
15:38:32 <ski> i'm thinking on my reflected-effects system, again
15:38:44 <esap> reflected effects?
15:39:14 <ski> yes, side-effects, as in monads
15:39:40 <ski> except i keep functions pure, so effects are lexically confined
15:40:30 <esap> side-effects with pure functions. Sounds like a contradication :-)
15:40:43 <ski> :)
15:41:16 <ski> before abstracting, one must reify, if there's any side-effects
15:42:16 <ski> i have a translation into plain haskell, more or less (no impl. just sketching the design)
15:42:57 <ski> esap : sounds interesting ?
15:43:08 <esap> ski: yes!
15:44:03 <ski> (actually, 'twas because i wanted to translate into plain haskell (or similar) that i kept functions pure)
15:44:50 <esap> My solution to side effects requires OO to work at all.
15:45:04 <ski> esap : it was inspired by a certain 'idiom-lite' paper, by conor mcbride (et. al. ?) iirc
15:45:15 <ski> what is that solution ?
15:45:58 <ski> (of course, by side-effects i mean all kinds of monads, as well as other idioms)
15:46:55 <esap> ski: I'm using OO notions to represent regions of storage, somewhat like what's done in C++ classes. Generally that would be syntactic sugar to lots of abstraction [basically everything is universally or existentially quantified].
15:47:28 <esap> ski: Then interaction with functional side would be done with arrows.
15:48:02 <esap> ski: The arrow type, in particular, would be universally quantified in most "OO" code.
15:48:26 <ski> regions as related to region-based memory-management as in e.g. ML Kit ?
15:48:48 <ski> heh
15:48:53 <esap> ski: I don't know ML Kit. But yes, it has connections to memory management.
15:49:28 <ski> allocating on a stack ?
15:50:02 <lispy> ML Kit?
15:50:08 <lispy> is that a language crafting kit?
15:50:36 <lispy> http://www.itu.dk/research/mlkit/index.php/Main_Page ?
15:50:37 <esap> ski: That would have to be one option. The current problem with that approach is that I can't get a reasonable memory management done, because there is no primitive to split a memory region, AFAICT.
15:51:00 <ski> lispy : yes, that one
15:51:16 <esap> ski: But programmer would in general be responsible for choosing a memory management policy.
15:51:40 <ski> ok
15:52:46 <ski> with regions in ML Kit, there's an region-inference (a kind of effect system) that infers regions in which to allocate every value, and also infers over which dynamical extents to allocate regions
15:52:50 <palomer> moscow ml uses region, I think
15:53:10 <ski> palomer : it does ? didn't know that
15:54:03 <esap> ski: Automatic mechanisms for allocating memory can only go so far. What I'm looking into is how to give the programmer power to write his own garbage collector, for example.
15:54:28 <ski> (so, usually closures are allocated on the stack (region stack), only not necessarily in the most recent region (compare region with activtion frame))
15:54:40 <ski> interesting
15:55:30 <palomer> mlkit and mlton should get together and party
15:55:43 <ski> (iirc Philippa_ thought some on how to use region ideas with ST)
15:56:17 <palomer> ski: iirc, she said that odersky (methinks) had written something about it before she had chance to think about it
15:56:46 <ski> possibly
15:56:49 <palomer> and jhc also uses some kind of region inferenc, methinks
15:56:51 <ski> (and oleg, i think)
15:57:05 <palomer> oh yes, it was oleg
15:57:06 <ski> m, could be
15:57:10 <ski> ok
15:57:32 <palomer> from the jhc webpage: A variant of Region Inference is in the works.
15:57:38 <ski> esap : i'm not clear on how this interacts (or interplays) with the OO aspects, though ?
15:57:50 <ski> (esap : bounded polymorphism ??)
15:58:15 <palomer> I think compilers could be much smarter at infering regions than humans
15:58:45 <esap> ski: Think reusability. With OO, reusability is a requirement. Now try to look which parts of the system are normally considered as reusable. Those should be written in OO style.
15:58:47 <ski> well, at least to some degree
15:59:22 <ski> esap : 'which parts of the system are normally considered as reusable' ?
15:59:46 <esap> ski: for example, In a monad, the implementation of Monad instance is clearly reusable, right?
16:00:08 <esap> ski: it can be hidden somewhere deep inside a library and nobody notices.
16:00:10 <ski> i'm not sure of your 'reusable' concept
16:00:51 <esap> ski: reusable means it can be used in new contexts *without* changes to the code.
16:01:08 <ski> without changes to *which* code ?
16:01:16 <esap> ski: to the reused code.
16:01:52 <heatsink> ...that's a tautology
16:02:05 <ski> and that has to do specifically with OO, how ?
16:02:56 <ski> (heatsink : i'm not sure about that)
16:03:22 <esap> ski: OO code has that property. You can write a class in C++, put it in a library, publish it for everyone to use, and they can use it without requiring extensive changes to the code, assuming OO design principles were used when developing it.
16:03:55 <ski> does this reusability you use here depend on (code) inheritance ?
16:04:15 <esap> ski: no, not really.
16:04:19 <ski> or just interface inheritance / record-subtyping ?
16:05:30 <esap> ski: The reusability depends on being able to package pieces of code in a library, and to be able to specify a clearly defined interface for it.
16:05:30 <ski> i guess one problem is that i don't really know what OO design principles are
16:06:06 <ski> just modularity ?
16:06:29 <esap> ski: modularity is an important aspect there.
16:07:05 <ski> i guess i want to know what makes it specifically OO ..
16:07:38 <ski> (i'm probably impaired by equating OO with coalgebras, though :)
16:07:57 <esap> ski: Well coalgebras are a good model for it :-)
16:08:41 <esap> ski: OO is a large collection of different principles and guidelines for building modules out of *program text*.
16:09:29 <ski> since algebras are dual, i'd think there'd be corresponding reusability potential there (but there could be reasons for not full symmetry)
16:09:40 <esap> ski: API interfaces are clearly something that's quite specific to OO way of thinking.
16:09:48 <ski> 'program text' here means ?
16:09:55 <esap> ski: the source code.
16:10:13 <ski> i mean, how would one otherwise do it ?
16:10:49 <tennin> somebody have a good starting point for learning about the coalgebraic interpretation of OOP?
16:11:00 <tennin> and formal, mathematical interpretations of OOP in general I guess
16:12:16 <esap> ski: I think it's about the scale at which reusability occurs. In OO, you can reuse very small pieces of code (say under 100 lines).
16:12:59 <esap> tennin: See Abadi, Cardelli: "A theory of Objects"
16:13:20 <tennin> thanks
16:14:29 <esap> tennin: Actually, now that I think about it, I'm not sure if Abadi&Cardelli discusses coalgebras. They have very many different models of OO, but I'm now not sure if coalgebras were one of them.
16:16:10 <esap> http://citeseer.ist.psu.edu/jacobs99coalgebra.html is something that looks like related.
16:16:59 <ski> (tennin : possibly interesting are two papers by Erik Poll (http://www.cs.ru.nl/E.Poll/) specially interesting ('Subtyping and Inheritance for Inductive Types' and 'Subtyping and Inheritance for Categorical Datatypes' iirc))
16:18:29 <Saulzar> esap, Very small compared to?
16:19:56 <esap> saulzar: Well, in application code, the smallest thing you can reuse is something like 50k .. 200k LOC
16:20:17 <Saulzar> I thought functional programming offered much better prospects for re-use, given that the reuse mechanisms are much lower level - functions
16:21:52 <esap> saulzar: The problem is, functional programming also encourages large functions. This means they contain lots of dependencies to everywhere, and are thus not reusable.
16:22:00 <Saulzar> In most programing languages, most re-use occurs in low level constructs - if statements, for loops etc. in functional programs you can write these yourself
16:23:01 <Saulzar> esap, Really? I've just started Haskell and my programs are full of 2 or 3 line functions
16:24:02 <esap> Saulzar: You are right in the sense that small functions are often not reusable. But I'm not talking about libraries of 2-3 line functions.
16:24:21 <esap> Saulzar: I mean *are* reusable.
16:24:31 <Saulzar> A lot of OO people seem to have given up on the hope that re-use is such a grand goal, as well :)
16:25:50 <esap> Saulzar: The thing is, once you get past the 2-10 line reusable parts, then normally functional programming constructs applications directly on top of those functions. And those applications are not reusable *at all*. OO offers a middle ground.
16:26:35 <vincenz> @seen Cale 
16:26:36 <lambdabot> Cale is in #haskell. Last spoke 2 hours, 49 minutes and 39 seconds ago.
16:26:51 <esap> Saulzar: The middle ground is more reusable than the applications, but less reusable than those 2-4 line functions.
16:26:52 <syntaxfree> do you know what's pink and proves the uncountability of real numbers?
16:27:25 <esap> syntaxfree: I can prove uncountability of real numbers. Hmm.. But for the pink part, no.
16:27:35 <syntaxfree> Cantor's diagonal panther!
16:27:43 <Plareplane> ...
16:28:06 <Plareplane> that can't be the punch line
16:28:31 * esap has to get some sleep.
16:28:41 <Saulzar> esap, I guess I agree with that somewhat, but OO and functional programming are almost orthogonal - you can write functional programs to be extended like OO programs in a similar way
16:29:21 <syntaxfree> I tend to see OOP as a less mathematically tractable layer of abstraction, not much more.
16:29:39 <syntaxfree> I guess people like metaphors. Desktops, objects, yadda yadda.
16:29:42 <esap> Saulzar: They are in some sense orthogonal. The trouble is, if you try to use both in the same program, you get very rigid piece of software.
16:30:05 <Saulzar> How do you mean?
16:30:32 <esap> Saulzar: At least it's easy to do that, if you mix up which parts should be OO and which should be FP.
16:31:32 <esap> Saulzar: People tend to use the paradigm they are accustomed to using, rather than one that would fit the problem.
16:31:33 <ski> hm
16:32:06 <Saulzar> Hmm, well in Haskell for example for some problems existentials and functions/records of functions will serve a very similar purpose to objects
16:32:08 <ski> esap : what kind of reuse above the "small function" level are you thinking of
16:32:13 <ski> any example ?
16:32:33 <esap> ski: well GUI widgets, for example.
16:33:44 <esap> ski: Each different type of GUI widget is reusable [withini the framework it's written in].
16:33:53 <ski> (the interaction between OO and existentials seems strange to me)
16:34:48 <ski> esap : you mean as a building-block ?
16:34:58 <esap> ski: yes.
16:35:35 <esap> ski: You can extend the set of GUI widgets easily in OO-based widget libraries.
16:35:48 <ski> true
16:35:58 <esap> ski: and each widget is in the range of 2k..50k, or something like that.
16:36:01 <Saulzar> In an OO language your functionality (for one object) is carried with the data, an existential carries around the instance and typeclass (dictionary) in a similar way
16:36:04 <esap> ski: LOC
16:36:25 <esap> ok, gotta go, see you later
16:36:29 <Saulzar> Hmm
16:36:34 <ski> esap : ok
16:36:46 <ski> Saulzar : yes, but how does that relate to coalgebras
16:36:49 <ski> ?
16:37:42 <ski> also, what does the existential buy us, more that a simple coalgebra ?
16:38:15 <Saulzar> I'm not entirely clear on what a coalgebra is.
16:38:17 <ski> (i assume stuff like recursive object types)
16:38:32 <ski> more or less just a record of stuff, e.g. functions
16:38:58 <ski> (and those function closures can share bindings)
16:39:38 <Saulzar> Hmm
16:40:43 <ski> of course, it matters a bit if we've pure or impure methods
16:41:03 <ski> (but, otoh, the methods can be monadic)
16:41:03 <Saulzar> I guess they're very similar. One thing perhaps is that you can more easily provide multiple interfaces
16:42:43 <Saulzar> I've noticed that using gtk2hs with records of IO () that it's almost exactly like OO
16:43:26 <ski> 'records of IO ()' ?
16:44:36 <jips> i guess he means a bunch of actions that modify\query the state
16:44:46 <Saulzar> Something like data FooWidget = FW { getSelected :: IO Foo .. }
16:44:51 <ski> ah
16:44:53 <ski> yes
16:45:46 <ski> the "methods" can contain shared references into the IO-RealWord-state, even if they can't mutate usual data
16:46:30 <jips> Saulzar: do you an IORef with this?
16:46:54 <ski> (and conceptually the state is passed in when every monadic methods is executed, so that passes in the "current values of instance variables")
16:47:30 <Saulzar> The gtk widgets are mutable themselves, so yeah - an IORef if extra data is needed
16:47:32 <ski> jips : i assume in many cases the state cells there live in foreign land
16:47:42 <ski> yah
16:49:18 <ski> hm
16:50:02 <ski> i assume if existentials are used, then we know new internal state (if any) has same type, so same methods can be used
16:50:26 <jips> how can i learn about existentials?
16:51:20 <ski> otoh, with recursive records (through the methods) are used, then each method that returns a new record can potentially use a new "internal implementation" of the methods (and we don't know anything about it's internals)
16:51:46 <ski> jips : possibly there's some info on the wiki
16:52:01 <ski> jips : you could also try asking on the irc channel
16:52:23 <Saulzar> ski, To me the approach is very similar...
16:52:38 <ski> Saulzar : which is similar to what ?
16:52:54 <Saulzar> records of functions vs. existentials
16:53:14 <ski> certainly, many common things can be done with both
16:53:31 <ski> (i'm wondering about where and how they differ)
16:56:40 <Saulzar> Have a look at this - distinctly OOish: http://www.haskell.org/hawiki/Existentially_20quantified_20record_20constructors
17:02:15 <Cale> It seems that product types and existentials are what OO is all about.
17:02:32 <Cale> Whereas functional programming focuses more on universal quantification and sums.
17:03:44 <jethr0_> cale, i didn't understand a single word of what you just said :)
17:04:00 <ski> Cale : interesting observation
17:04:29 <cpatrick> what ski said :)
17:04:56 <jethr0_> well, "originally" OO was about dynamic message passing, no? (i.e. smalltalk). but i guess we've moved far "past" that
17:04:58 <cpatrick> Sum types are one of the things that I often miss in 'normal' programming languages
17:05:32 <jethr0_> yes, so do i. but implementing interfaces is like sum types without pattern matching
17:05:44 <cpatrick> jethr0_: but 'message passing' in the OO sense is really just a funny name for indirect function calls
17:05:50 <ihope> lispy: pingy pingy
17:06:07 <jethr0_> cpatrick: hmm, but originally you couldn't know whether the message would be understood.
17:06:28 <jethr0_> and smalltalk is pretty big on handling unknown messages, dispatching them further, ...
17:06:29 <ski> is that so in Simula ?
17:06:43 <Saulzar> I think they're needed for different things, sometimes you want implicit behaviour other times you want to tear apart your data manually 
17:06:56 <cpatrick> jethr0_: ahh, cool. I've never used smalltalk and was thinking in terms of Java/C++ "OO"
17:07:08 <ihope> @where lispy
17:07:09 <lambdabot> I know nothing about lispy.
17:07:17 <ski> @seen lispy
17:07:17 <lambdabot> lispy is in #haskell. Last spoke 1 hour, 16 minutes and 40 seconds ago.
17:07:33 <jethr0_> java/C++ have moved considerably away from message passing (at least conceptually)
17:08:39 <cpatrick> jethr0_: is the OO in Python or Ruby moving closer to smalltalk again?
17:09:17 <jethr0_> cpatrick: ruby is very smalltalk-like in many respects
17:09:17 <cpatrick> certainly Python lets you do "clever" tricks to handle unknown method calls
17:09:20 <ski> jethr0_ : what about message passing in Simula ? does 'message not understood' exist there ?
17:09:45 <jethr0_> and python also has strong reflection on "object methods", although not as strongly as ruby
17:09:59 <jethr0_> ski: i've never even come close to simula, so i wouldn't know
17:10:04 <lispy> ihope: ping!
17:10:09 <ski> fair enough
17:10:42 <ski> @localtime lispy
17:10:44 <lambdabot> Local time for lispy is Fri Mar 10 17:07:40 2006
17:10:58 <lispy> hey, that's wrong!
17:11:04 <ihope> lispy: on that significance thing, that's testing how significant a number is given the number of BF-SC instructions it takes to describe it.
17:11:09 <ihope> @localtime ihope
17:11:10 <lispy> oh wait...my server needs no run ntp as a daemon...
17:11:11 <lambdabot> Local time for ihope is Friday, March 10, 2006 8:10:33 PM
17:11:31 <lispy> ihope: yeah, but i was too lazy to read the wiki page you directed me too
17:11:38 <ihope> :-)
17:11:41 <ihope> @localtime ihope
17:11:44 <lambdabot> Local time for ihope is Friday, March 10, 2006 8:11:06 PM
17:11:54 <ihope> Hmm...
17:12:07 * ihope tried again
17:12:13 <aFlag> I can get a IO FilePath type from Directory.getCurrentDirectory, but i can't figure out how to print the current directory's name from that
17:12:13 <ihope> @localtime ihope
17:12:17 <lambdabot> Local time for ihope is Friday, March 10, 2006 8:11:38 PM
17:12:20 <ihope> Aww.
17:12:21 <dcoutts> Saulzar, yeah, remember that Haskell is the world's finest imperitive programming language. :-)
17:12:39 <ihope> @help spellcheck
17:12:39 <lambdabot>  @help <command> - ask for help for <command>
17:12:42 <ihope> Aww.
17:12:53 <jethr0_> spam spam spam
17:13:15 <lispy> there, i bumped my clock into the future...
17:13:19 <lispy> @localtime lispy
17:13:23 <lambdabot> Local time for lispy is Fri Mar 10 17:12:58 2006
17:13:30 <lispy> that's more like it
17:13:37 <ihope> @localtime lambdabot
17:13:45 <ihope> @localtime NickServ
17:14:00 <ihope> @ping
17:14:01 <lambdabot> parse error (possibly incorrect indentation)
17:14:05 <ihope> @help ping
17:14:05 <lambdabot>  @help <command> - ask for help for <command>
17:14:10 <ihope> @ping bleh
17:14:11 <lambdabot> Not in scope: type variable `bleh'
17:14:16 <ihope> Um.
17:14:24 <ihope> @pnig
17:14:25 <lambdabot> Unknown command, try @listcommands.
17:14:31 <ihope> What command is this?
17:14:36 <ihope> @ping Integer
17:14:37 <lambdabot> *
17:14:41 <ihope> Kind!
17:14:47 <ihope> @ping (->)
17:14:48 <lambdabot> ?? -> ? -> *
17:14:50 <ihope> :-)
17:14:54 <ihope> @help version
17:14:55 <lambdabot> Report the build date, ghc version and darcs repo of this bot
17:15:21 <ski> (jips : fyi, that existential record syntax makes using existentials easier, but is strictly not needed just to use them)
17:15:38 <jethr0_> @tape \x -> x
17:15:39 <lambdabot> forall t. t -> t
17:15:53 <jips> hm.... i actually have no idea what existentials are
17:17:47 <ski> jips : do you know that in (statically typed) OO GUI systems, once can have heterogenous lists of objects, as long as all of them implement a Widget interface ?
17:18:04 <ski> s/once/one/
17:18:44 <wchogg> Hey, does anyone have the address for the haskell site that lists all the standard libraries and all their functions?  It's not the report itself, but there's this site that has a nice layout of all the information and I can't find it now that I've lost my bookmarks.
17:19:41 <jips> ski: yes
17:20:05 <wchogg> Nevermind.  I tried one last google search and I found the one I wanted.  Sorry.
17:21:06 <ski> http://www.zvon.org/other/haskell/Outputglobal/index.html ?
17:21:09 <ski> http://www.cs.uu.nl/~afie/haskell/tourofprelude.html ?
17:22:05 <Cale> There's also the GHC documentation
17:22:17 <wchogg> Yeah, it was the zvon one that I was trying to find.
17:22:39 <ski> jips : if you have a type class Widget in haskell, representing this interface, then a list of type 'Widget a => [a]' still doesn't allow putting things of different type (but "implementing" (i.e. instancing) the 'Widget' interface (i.e. type class))
17:23:21 <ski> jips : since, you have a list of 'a's, all of same type, and that type is in class 'Widget'
17:24:32 <ski> so, what you want is something like '[exists a. Widget a *> a]', this meaning a list of things, that have *some* type 'a' (i.e. there exists such a type, for every element), that is in type class 'Widget' and the element is of this type
17:25:22 <ski> jips : but using explicit 'exists' syntax for existential (like 'forall' for universals) isn't (currently) supported
17:25:44 <ski> so, one have to wrap it into a new datatype
17:26:08 <ski> jips : shall i continue ?
17:29:49 <jabber> Gay Niggers From Outer Space Digitally Remastered    http://video.google.com/videoplay?docid=5121649266422516795&q=
17:30:18 <jips> ski: i think i sort of get the spirit of what you are saying... so please do continue
17:30:51 <ski> so, we get a type '[SomeWidget]' where we have to define the type 'SomeWidget'
17:31:17 <ski> i'll show the definition using GADT style, first
17:31:26 <ski> data SomeWidget
17:31:29 <ski>   where
17:31:46 <ski>   WrapWidget :: Widget a => a -> SomeWidget
17:32:01 <ski> this has one constructor, 'WrapWidget'
17:33:05 <ski> that takes a value of any type 'a', provided 'a' is in 'Widget', and wraps the value together into a SomeWidget
17:33:14 <ski> so, assuming
17:33:21 <ski> instance Widget Button
17:33:25 <ski> instance Widget Label
17:33:28 <ski> if we have
17:33:33 <ski> b :: Button
17:33:38 <ski> l :: Label
17:33:41 <ski> then
17:33:54 <ski> WrapWidget b :: SomeWidget
17:33:57 <ski> WrapWidget l :: SomeWidget
17:34:06 <ski> so, when wrapped, they have the same type
17:34:11 <ski> so we can form
17:34:24 <ski> [WrapWidget l,WrapWidget b] :: [SomeWidget]
17:34:38 <ski> which is our "heterogenous" list
17:34:51 <jips> hm...
17:35:06 <jabber> Gay Niggers From Outer Space Digitally Remastered    http://video.google.com/videoplay?docid=5121649266422516795&q=
17:35:11 <ski> now, when we wrap, we lose all information about what type was wrapped, *except* that the type was an instance of 'Widget'
17:36:00 <ski> this means that if we pattern-match on a 'SomeWidget' value, and extract the internal value of type 'a', then *we*have*no*idea*at*all* what type 'a' is
17:36:20 <ski> we only know we can use methods from class 'Widget' (and possible superclasses) on it
17:37:26 <ski> (in particular if we extract two values from two 'SomeWidget's, we *do*not*know* whether they are of the same type, and since we can't recover the type we must assume they are of different type)
17:37:26 <jips> ok i guess i understand the spirit of what you are saying
17:37:39 <ski> ok
17:38:05 <jips> cool thanks i think i should sleep now
17:38:07 <ski> i'll show the other style of defining the type 'SomeWidget', too
17:38:12 <jips> hm...
17:38:21 <ski> data SomeWidget = forall a. Widget a => WrapWidget a
17:38:47 <ski> in both cases, to be fully explicit, the type of 'WrapWidget' is
17:39:02 <ski> WrapWidget :: forall a. Widget a => a -> SomwWidget
17:39:22 <ski> so, when wrapping, we can wrap any type that conforms to the interface
17:39:48 <ski> when unwrapping, we only know there exists *some* type that conforms to the interface, but we don't know which
17:40:11 <ski> that's one reason these types are dubbed 'existential'
17:40:20 <ski> ok
17:41:35 <jabber> Gay Niggers From Outer Space Digitally Remastered    http://video.google.com/videoplay?docid=5121649266422516795&q=
17:41:50 <jips> interesing, ok i am falling asleep, good night haskell
17:42:25 <ski> yes (the class constraints in the existential types are btw not really needed, but that's for another time, i think :)
17:42:33 <ski> night, jips
17:43:29 <jabber> Gay Niggers From Outer Space Digitally Remastered    http://video.google.com/videoplay?docid=5121649266422516795&q=
17:43:38 <jethr0_> could someone kick jabber?
17:44:08 <vincenz> heh
17:44:17 <jabber> witness the masterpiece in cinema history
17:47:54 <jethr0_> digital remastering is overrated anyways
17:52:37 <jabber> Gay Niggers From Outer Space Digitally Remastered    http://video.google.com/videoplay?docid=5121649266422516795&q=
17:55:44 <jethr0_> @kick spammer where spammer = jabber
17:55:44 <lambdabot> Maybe you meant: dice dict kind
17:56:03 <jabber> do not fear the gay niggers
17:56:10 <dcoutts> jabber, this is not the right channel for that
17:56:28 <jabber> you do not welcome gay niggers?
17:56:32 * dcoutts looks around for our ChanOp
17:56:41 <dcoutts> @summon shapr
17:56:42 <lambdabot> Unknown command, try @listcommands.
17:58:23 <dcoutts> who knows how to kick unwanted spam bots? Igloo? dons? Lemmih?
17:59:19 <Igloo> YM jabber?
17:59:25 --- mode: ChanServ set +o Igloo
17:59:30 <dcoutts> Igloo, yep
17:59:55 --- mode: Igloo set +b *!*@toronto-HSE-ppp4057491.sympatico.ca
17:59:58 --- kick: jabber was kicked by Igloo (Igloo)
18:00:05 <dcoutts> ta
18:00:19 <Igloo> Thanks for pointing it out  :-)
18:00:24 <dcoutts> np
18:03:43 <jethr0_> there should be some kind of voting mechanism. 50% of active users should be able to vote for a kick like with mapvote in counter strike. but i guess abuse might be an issue
18:04:08 <franka> 50% of 169 users?
18:04:48 <ncalexan> 169 users, >80% of whom are idle :)
18:04:48 <franka> Maybe 50% of users who have said something in the last x minutes.
18:05:23 <Igloo> Then 10 clones could drop in and kick everyone in the channel...
18:05:29 --- mode: Igloo set -o Igloo
18:05:38 <jethr0_> no, active as in
18:05:39 <jethr0_> @seen
18:05:40 <lambdabot> Lately, I have seen dcoutts, franka, igloo, jabber, jethr0_ and ncalexan.
18:05:43 <franka> Good point.
18:06:09 <wchogg> Sorry, but what's the url for the paste I can use?  There's some really simple code that's giving me a headache and I'd like to ask about it.
18:06:10 <jethr0_> as i said, abuse might be an issue :)
18:06:20 <aFlag> I can get a IO FilePath type with the function Directory.getCurrentDirectory, but i can't figure out how to print the current directory's name from that
18:06:31 <aFlag> Anyone knows how can i do it?
18:06:53 <Igloo> do d <- Directory.getCurrentDirectory; putStrLn d
18:06:58 <Igloo> or Directory.getCurrentDirectory >>= putStrLn
18:07:31 <franka> Wrong type.
18:08:06 <dons> moin
18:08:08 <aFlag> hum
18:08:12 <Igloo> What's the wrong type?
18:08:12 <franka> He's asking how to get the name from the FilePath.
18:08:19 <Igloo> FilePath = String
18:08:28 <dons> so use 'id' ;)
18:08:29 <franka> Oh, nevermind.
18:10:02 <aFlag> oh, i was trying to do putStrLn Directory.getCurrentDirectory
18:10:23 <aFlag> i'll look up for that >>= operator, thank you guys
18:10:27 <jethr0_> dons: moin moin
18:10:57 <ski> lisppaste2 : url
18:10:58 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
18:11:03 <ski> wchogg
18:11:38 <wchogg> Ah, thanks.
18:15:31 <lisppaste2> wchogg pasted "Double" at http://paste.lisp.org/display/17743
18:15:50 <wchogg> i can't figure out why "nummol" is getting an inferred type of Double
18:16:02 <wchogg> It should be Int or Integral from the ceiling function, yes?
18:18:16 <ski> '(ceiling n**(1/3))' is parsed as '(ceiling n) ** (1/3)', is this intended ?
18:18:28 <wchogg> Ack, no it is *not*.
18:18:29 <dons> that's the problem, I think
18:18:42 <wchogg> I thought the operator ** would take precedence?
18:18:43 <ski> 'ceiling (n ** (1/3))' then
18:19:01 <ski> no, function application binds stronger than any operator
18:19:03 <wchogg> Oh wait...Haskell eagerly grabs the arguments to functions, right?
18:19:09 <dons> ceiling is function application, it binds tighter.
18:19:13 <dons> ah, as ski says.
18:19:16 <wchogg> Okay, thanks.
18:19:28 <dons> infixr 8 ** 
18:19:31 <wchogg> That was drivin' me bleeding crazy.
18:20:23 <dons> interesting that it was fairly easy to spot for ski and me. I guess the 'application binds tightest' is a good rule to know
18:21:15 <ski> btw, why is your 'init' in the IO-monad ? .. it currently does no effects
18:21:30 <wchogg> Oh, because the rest of it is going to use Random
18:21:48 <wchogg> The "return" is just junk so that I could see if it would compile
18:22:04 <ncalexan> dons: application binds tightest feels weird for a while.  Especially when you try to understand long strings of compositions and arithmetic operators.
18:24:14 <dons> yeah, that's what I'm thinking too.
18:24:28 <dons> perhaps when starting out its good to sprinkle extraa parens when you're unsure
18:24:47 <ncalexan> I certainly did.
18:25:16 <wchogg> Probably.  In my case, the problem was that I just looked at it and thought "exponentiation comes first".
18:25:37 <dons> yep. i mean, you spotted that the error was something to do with ceiling
18:25:47 <dons> so that's good.
18:26:07 <ncalexan> I think the step there would be to bind the subexpressions to improve the error messages.
18:26:22 <ncalexan> Breaking it down until it's easier to see the types.
18:26:47 <dons> yep. break it up. and even expicitly annotate the types of the subexpressions if needed
18:27:09 <ncalexan> I wish that was a little cleaner in do expressions, actually.
18:27:27 <ncalexan> Not being able to drop a where in there hurts.
18:27:48 <ncalexan> Also, not being able to say:
18:27:51 <ncalexan> k :: Integer
18:27:57 <ncalexan> k <- someIntComputation
18:28:12 <dons> ah well, you can say:  k :: Integer <- someThing
18:28:21 <dons> or k <- something :: IO Integer
18:28:27 <ncalexan> But then removing the types is annoying... the second is better for that.
18:28:33 <dons> I prefer the former, but use the later more since it's H98
18:28:47 <ncalexan> But separate types has been a big win elsewhere.
18:30:43 <ski> you can use separate type signatures in a 'let'-in-'do'
18:31:32 <wchogg> What do you mean?
18:31:46 <ski> do ..blah..
18:31:53 <ski>    let foo :: Foo
18:32:01 <ski>        foo = ...
18:32:09 <ski>        ...
18:32:16 <ski>    ..bleh..
18:34:32 <ski> (but, one could possibly consider allowing type signatures just before a bind in 'do', that gives types to some of the bound variables)
18:34:41 <ski> ncalexan-away : interesting idea
18:35:01 <ihope> WHOA. Today, I have added the following to my IRC bot:
18:35:06 <ihope> data IRCModeSetting     = 
18:36:47 <dons> ah, you're still hacking away on this. good stuff ihope
18:36:58 <ihope> :-)
18:38:09 <ihope> > reverse ":-)" -- An old joke, I know.
18:38:10 <lambdabot> ")-:"
18:38:27 <ihope> > reverse ":-D"
18:38:28 <lambdabot> "D-:"
18:38:42 <ihope> > reverse ">:-)"
18:38:43 <lambdabot> ")-:>"
18:38:58 <ihope> > reverse "^_^"
18:38:59 <lambdabot> "^_^"
18:39:01 <ihope> Aww.
18:39:37 * ihope boots up PuTTYtel
18:44:03 <ihope> ...Waah, no join message!
18:44:44 <ihope> Some of these joins/quits/parts are getting dropped for some reason.
18:46:16 <ihope> > Mode+
18:46:16 <lambdabot>  parse error on input `}'
18:46:22 <ihope> > (Mode+)
18:46:23 <lambdabot>  Not in scope: data constructor `Mode'
18:46:39 <dons> ihope, what are you trying to do to lambdabot?
18:46:45 <ihope> I'm not!
18:47:17 <dons> ? "13:46  ihope:: > (Mode+)" -- it won't do anything, but what is your goal?
18:47:27 <ihope> To write another IRC bot.
18:47:48 <dons> ah, is '>' syntax for talking to your new bot?
18:48:01 <ihope> Nope. # will be the prefix character.
18:48:12 <ihope> I don't want it to mudge with lambdabot ;-)
18:48:33 <dons> ! would be another option, I think.
18:48:39 <ihope> EgoBot uses that.
18:48:43 <dons> or ?foo
18:48:49 <dons> that's kind of nice.
18:48:52 <dons> maybe $foo
18:48:54 <dons> even better
18:48:56 <ihope> And besides, I like commands looking like channel names :-P
18:49:10 <dons> in fact, I like $foo so much I might make it valid in lambdabot
18:49:19 <dons> who's with me?
18:49:25 <ihope> @help poll
18:49:25 <dons> $type map
18:49:25 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result
18:49:25 <lambdabot> poll-close poll-remove
18:49:26 <int-e> use / ;)
18:49:31 <ihope> :-)
18:49:32 <dons> \type map
18:49:35 <int-e> /blah foo bar
18:49:40 <ihope> Ooh, evule.
18:49:44 <dons> nah, can't use irc commands
18:49:47 <ihope> /Like this?
18:49:48 <dons> but latex ...
18:49:56 <ihope> @poll-list
18:49:57 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
18:50:02 <ihope> @help poll-list
18:50:03 <lambdabot>  @poll-list                 shows all current polls
18:50:10 <ihope> @help poll-add
18:50:11 <lambdabot>  @poll-add <name>             adds a new poll, with no candidates
18:50:25 <ihope> @poll-add Prefix characters for an IRC bot
18:50:25 <lambdabot> usage: @poll-add <poll>   with "ThisTopic" style names
18:50:31 <dons> camel style
18:50:31 <int-e> /part and /quit are mandatory commands then of course.
18:50:31 <ihope> Um
18:50:35 <ihope> :-)
18:50:39 * int-e grins foolishly
18:50:52 <ihope> (How) does /wallops work?
18:51:06 <dons> @poll-add WhatCommandPrefixShouldLambdabotUse?
18:51:06 <lambdabot> Added new poll: "WhatCommandPrefixShouldLambdabotUse?"
18:51:09 <ihope> Or /wall?
18:51:20 <dons> @choice-add WhatCommandPrefixShouldLambdabotUse? @
18:51:21 <lambdabot> New candidate "@", added to poll "WhatCommandPrefixShouldLambdabotUse?".
18:51:23 <dons> @choice-add WhatCommandPrefixShouldLambdabotUse? #
18:51:24 <lambdabot> New candidate "#", added to poll "WhatCommandPrefixShouldLambdabotUse?".
18:51:25 <dons> @choice-add WhatCommandPrefixShouldLambdabotUse? !
18:51:25 <lambdabot> New candidate "!", added to poll "WhatCommandPrefixShouldLambdabotUse?".
18:51:27 <dons> @choice-add WhatCommandPrefixShouldLambdabotUse? $
18:51:27 <lambdabot> New candidate "$", added to poll "WhatCommandPrefixShouldLambdabotUse?".
18:51:29 <dons> @choice-add WhatCommandPrefixShouldLambdabotUse? \
18:51:29 <lambdabot> New candidate "\\", added to poll "WhatCommandPrefixShouldLambdabotUse?".
18:51:35 <dons> @choice-add WhatCommandPrefixShouldLambdabotUse? &
18:51:35 <lambdabot> New candidate "&", added to poll "WhatCommandPrefixShouldLambdabotUse?".
18:51:43 <ihope> @choice-add WhatCommandPrefixShouldLambdabotUse? /
18:51:43 <lambdabot> New candidate "/", added to poll "WhatCommandPrefixShouldLambdabotUse?".
18:51:57 <dons> @vote WhatCommandPrefixShouldLambdabotUse? \
18:51:57 <lambdabot> voted on "\\"
18:51:57 <vincenz> @poll
18:51:57 <lambdabot> Maybe you meant: poll-add poll-close poll-list poll-remove poll-result
18:51:57 <lambdabot> poll-show pl spell
18:52:00 <dons> @vote WhatCommandPrefixShouldLambdabotUse? $
18:52:00 <lambdabot> voted on "$"
18:52:01 <ihope> @choice-add WhatCommandPrefixShouldLambdabotUse? ~
18:52:02 <lambdabot> New candidate "~", added to poll "WhatCommandPrefixShouldLambdabotUse?".
18:52:09 <vincenz> @vote WhatCommandPrefixShouldLambdabotUse @
18:52:09 <lambdabot> No such poll:"WhatCommandPrefixShouldLambdabotUse"
18:52:13 <ihope> @choice-add WhatCommandPrefixShouldLambdabotUse? :
18:52:13 <lambdabot> New candidate ":", added to poll "WhatCommandPrefixShouldLambdabotUse?".
18:52:21 <vincenz> @vote WhatCommandPrefixShouldLambdabotUse @
18:52:22 <lambdabot> No such poll:"WhatCommandPrefixShouldLambdabotUse"
18:52:33 <dons> @poll-result WhatCommandPrefixShouldLambdabotUse?
18:52:34 <lambdabot> Poll results for WhatCommandPrefixShouldLambdabotUse? (Open): :=0, ~=0, /=
18:52:34 <lambdabot> 0, &=0, \=1, $=1, !=0, #=0, @=0
18:52:41 <int-e> vincenz: note the ?
18:52:43 <ihope> @choice-add WhatCommandPrefixShouldLambdabotUse? %
18:52:43 <lambdabot> New candidate "%", added to poll "WhatCommandPrefixShouldLambdabotUse?".
18:52:54 <ihope> @vote WhatCommandPrefixShouldLambdabotUse? #
18:52:55 <lambdabot> voted on "#"
18:53:03 <ihope> @poll-list
18:53:04 <lambdabot> Missing argument. Check @help <vote-cmd> for info.
18:53:10 <Cale> What's wrong with @?
18:53:12 <ihope> @help poll-show
18:53:13 <lambdabot>  @poll-show <poll>            shows all choices for some poll
18:53:16 <int-e>  @vote WhatCommandPrefixShouldLambdabotUse? *
18:53:18 <int-e> @vote WhatCommandPrefixShouldLambdabotUse? *
18:53:19 <lambdabot> "*" is not currently a candidate in this poll
18:53:20 <ihope> Wait a minute...
18:53:21 <dons> it's the noisiest of all, Cale :)
18:53:28 <dons> $type map or \type map seems nicer to me
18:53:29 <ihope> I wanted to use #!
18:53:38 <dons> #!type map ?
18:53:40 <vincenz> @vote WhatCommandPrefixShouldLambdabotUse? @
18:53:40 <lambdabot> voted on "@"
18:53:45 <Cale> .type map
18:53:47 <ihope> @help poll
18:53:48 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result
18:53:48 <lambdabot> poll-close poll-remove
18:53:52 <Cale> `type map
18:53:54 <Cale> hehe
18:53:54 <dons> hmm. maybe
18:53:55 <ihope> @poll-result WhatCommandPrefixShouldLambdabotUse?
18:53:55 <lambdabot> Poll results for WhatCommandPrefixShouldLambdabotUse? (Open): %=0, :=0, ~=
18:53:55 <lambdabot> 0, /=0, &=0, \=1, $=1, !=0, #=1, @=1
18:54:02 <dons> @choice-add WhatCommandPrefixShouldLambdabotUse? .
18:54:03 <lambdabot> New candidate ".", added to poll "WhatCommandPrefixShouldLambdabotUse?".
18:54:04 <dons> @choice-add WhatCommandPrefixShouldLambdabotUse? `
18:54:05 <lambdabot> New candidate "`", added to poll "WhatCommandPrefixShouldLambdabotUse?".
18:54:07 <int-e> @vote WhatCommandPrefixShouldLambdabotUse? /
18:54:07 <lambdabot> voted on "/"
18:54:08 <Cale> those are getting silly though :)
18:54:12 <dons> @vote WhatCommandPrefixShouldLambdabotUse? .
18:54:13 <lambdabot> voted on "."
18:54:13 <ihope> :-)
18:54:18 <dons> '.' is pretty good
18:54:21 <jethr0_> i don't see the problem with "@". but then anything is ok that's not disruptive to normal irc messages
18:54:24 <Cale> int-e: / is really inconvenient
18:54:30 <ihope> Exactly!
18:54:32 <dons> yeah, you can't have /
18:54:33 <int-e> Cale: oh really :)
18:54:37 <jethr0_> \type
18:54:39 <cpatrick> /why not
18:54:46 <ihope> /I don
18:54:55 <ihope> /'t see the problem.
18:54:55 <cpatrick> @vote WhatCommandPrefixShouldLambdabotUse? &
18:54:55 <int-e> Cale: it's a know-your-client game. :)
18:54:55 <lambdabot> voted on "&"
18:54:58 <jethr0_> %quote
18:55:07 <jethr0_> &quote
18:55:08 <Cale> well, it usually involves some special key sequence
18:55:19 <int-e> // does it in x-chat.
18:55:26 <dons> .map <-- whhat language uses '.' ? 
18:55:28 <Cale> right
18:55:31 <int-e> that's almost as easy to type as a single / :)
18:55:41 <ihope> The IRC protocol actually doesn't even mention slashes... I think.
18:55:48 <int-e> it doesn't
18:55:49 <jethr0_> backslash isn't too bad either, IMO
18:55:51 <ihope> PRIVMSG #haskell :/What's the problem?
18:55:53 <Cale> ihope: right, of course not
18:55:57 <dons> jethr0, vote on it!
18:56:04 <vincenz>  / would suck
18:56:06 <Cale> I like @
18:56:09 <ihope> PRIVMSG #haskell ^AACTION doesn't know^A
18:56:12 <Cale> @vote WhatCommandPrefixShouldLambdabotUse? @
18:56:12 <lambdabot> voted on "@"
18:56:33 <dons> i'm thinking I might just add the top 2 or 3 alternatives
18:56:39 <dons> and then let social pressure work out the winner
18:56:46 <Cale> looks sort of command-prefix-like to me for some reason
18:56:50 <ihope> @poll-result WhatCommandPrefixShouldLambdabotUse?
18:56:50 <lambdabot> Poll results for WhatCommandPrefixShouldLambdabotUse? (Open): `=0, .=1, %=
18:56:50 <lambdabot> 0, :=0, ~=0, /=1, &=1, \=1, $=1, !=0, #=1, @=2
18:57:01 <int-e> @vote WhatCommandPrefixShouldLambdabotUse? @
18:57:01 <ihope> Can I un-vote for #? :-)
18:57:01 <Cale> In my branch of lambdabot, I use % for mathematica commands
18:57:01 <lambdabot> voted on "@"
18:57:11 <ihope> Or should I just vote for everything else?
18:57:12 <Cale> and > for Haskell evaluation as usual.
18:57:17 <dons> \foo would be more traditional, I argue.
18:57:20 <dons> yeah, and we keep >
18:57:24 <ihope> #foo
18:57:27 <jethr0_> @vote WhatCommandPrefixShouldLambdabotUse? \
18:57:28 <lambdabot> voted on "\\"
18:57:29 <dons> rememebr how liberating '>' felt when we started using it?
18:57:35 <Cale> ! seems common amongst IRC bots
18:57:46 <dons> there's some psychological aspects to the command prefix char..
18:57:52 <int-e> yes, but that's a good reason not to use !
18:58:00 <dons> and keeping noise down is a good reason too
18:58:12 <cpatrick> I don't like !
18:58:16 <int-e> : is a bad prefix char btw :)
18:58:42 <dons> cpatrick, vote on the ones you do like :)
18:58:58 <cpatrick> A lot of bots respond to their name, e.g. "lambdabot: foo"
18:58:58 <jethr0_> dons: how come there's the one-space-after-">" rule?
18:59:09 <int-e> >:-)
18:59:17 <dons> jethr0, for smilies
18:59:24 <dons> which would also be needed for :
18:59:40 <dons> or *, if htat was an option
18:59:45 <jethr0_> bah, four letter smilies
18:59:48 <int-e> @-)
18:59:49 <lambdabot> Maybe you meant: . id pl wn
19:00:05 <jethr0_> |quote
19:00:10 <ihope> Ooh!
19:00:20 <jethr0_> why isn't "|" an option?
19:00:25 <dons> add it
19:00:30 <ihope> @choice-add WhatCommandPrefixShouldLambdabotUse? |
19:00:30 <lambdabot> New candidate "|", added to poll "WhatCommandPrefixShouldLambdabotUse?".
19:00:32 <dons> -- foo
19:00:35 <dons> -type
19:00:42 <ihope> -)
19:00:42 <dons> might be nice
19:01:04 <dons> @choice-add WhatCommandPrefixShouldLambdabotUse? -
19:01:04 <lambdabot> New candidate "-", added to poll "WhatCommandPrefixShouldLambdabotUse?".
19:01:04 <jethr0_> did you mean "subtract type"
19:01:11 <ihope> > -type
19:01:12 <lambdabot>  parse error on input `type'
19:01:16 <dons> hehe
19:01:27 <ihope> Not in scope: `hehe'
19:01:28 <jethr0_> i don't like the looks of "-" though
19:01:31 <vincenz> why isn't " an option?
19:01:38 <ihope> @choice-add WhatCommandPrefixShouldLambdabotUse? 
19:01:39 <lambdabot> usage: @choice-add <poll> <choice>
19:01:39 <jethr0_> add it
19:01:39 <dons> that would really clash
19:01:42 <ihope> @choice-add WhatCommandPrefixShouldLambdabotUse? "
19:01:42 <lambdabot> New candidate "\"", added to poll "WhatCommandPrefixShouldLambdabotUse?".
19:01:45 <vincenz> that way we could recurse
19:01:54 <dons> a worthy goal, eh?
19:01:58 <jethr0_> i use " a lot for quoting, ...
19:02:16 <ihope> > : - )
19:02:17 <lambdabot>  parse error on input `:'
19:02:32 <jethr0_> ~quote
19:02:47 <ihope> Now, why didn't I allow for prefixes in the PART and JOIN commands?
19:02:48 * ihope adds
19:02:58 <dons> ok, looking in the logs, I see a lot of ! ... ;) :) 
19:03:04 <int-e> let me see ... ~!@#$%^&*()_+-=`{}[]\|;:'",<.>/? ... 32 candidates.
19:03:14 <ihope> Hmm.
19:03:39 * vincenz thinks that @commands should be couplable to code
19:03:40 <ihope> > length "~!@#$%^&*()_+`-=[]\\{}|;':\",./<>?
19:03:41 <lambdabot>  lexical error in string/character literal
19:03:42 <vincenz> so you can do
19:03:50 <int-e> > chr 127
19:03:51 <lambdabot> '\DEL'
19:03:51 <ihope> > length "~!@#$%^&*()_+`-=[]\\{}|;':\",./<>?"
19:03:52 <lambdabot> 32
19:03:55 <jethr0_> the symmetric (i.e. brackets, ...) ones might not look so good
19:03:59 <vincenz> > sequence_ $ map choice-add "xxx" "abcd"
19:04:00 <int-e> > ord '~'
19:04:00 <lambdabot>  Not in scope: `add'
19:04:00 <lambdabot> 126
19:04:02 <ihope> Oh, right.
19:05:09 <dons> @poll-result  WhatCommandPrefixShouldLambdabotUse? 
19:05:09 <lambdabot> Poll results for WhatCommandPrefixShouldLambdabotUse? (Open): "=0, -=0, |=
19:05:09 <lambdabot> 0, `=0, .=1, %=0, :=0, ~=0, /=1, &=1, \=2, $=1, !=0, #=1, @=3
19:05:30 <dons> . / & \ $ # @ eh?
19:05:40 <dons> and I want to veto /
19:05:46 <redlion> i think the prefix should be: shapr
19:05:47 <dons> and @ will remain anyway
19:05:51 <redlion> that would really screw things up ;)
19:05:52 <int-e> fine with me
19:05:52 <dons> hehe
19:06:20 <int-e> @poll-veto WhatCommandPrefixShouldLambdabotUse? /
19:06:20 <lambdabot> Unknown command, try @listcommands.
19:06:22 <int-e> ;)
19:06:24 <jethr0_> wouldn't ":" be bad for smilies too?
19:06:32 <dons> it is, yes
19:06:40 <dons> it would require a space
19:06:43 <dons> which would mess thingss up
19:06:57 <vincenz> I think the prefix should be "yo bitch, what's"
19:07:06 <dons> heh
19:07:09 <vincenz> :P
19:07:25 <stepcut> maybe lambdabot should allow users to set their own prefix preference 
19:07:30 <vincenz> what's 1+1
19:08:14 <int-e> vincenz: we're talking about the command prefix ("@" in @quote) not the eval abbreviation ("> ") though.
19:08:32 <int-e> what'seval 1+1   is ugly :)
19:08:40 <dons> right.
19:09:06 <dons> unlike:  @type #type $type \type .type %type &type |type
19:09:14 <dons> though maybe the last is also space worthy
19:09:18 <dons> -type too
19:09:23 <vincenz> I like @
19:09:25 <vincenz> it feels like a command
19:09:30 <vincenz> but it might be my mush backgroud
19:09:33 <vincenz> don't forget +
19:09:34 <jethr0_> i like @ too
19:09:34 <vincenz> +type
19:09:50 * int-e would like : (because hugs and ghci use that) if it wouldn't clash with smileys.
19:09:51 <dons> @ will not go away.
19:09:51 <lambdabot> Maybe you meant: . all-dicts arr babel botsnack choice-add code compose
19:09:51 <lambdabot> devils dice dict dict-help djinn djinn-add djinn-clr djinn-del djinn-env
19:09:51 <lambdabot> djinn-ver docs dummy dynamic-load dynamic-reload dynamic-unload easton
19:09:51 <lambdabot> echo elements elite eurohaskell eval fact fact-cons fact-delete fact-set
19:09:51 <lambdabot> fact-snoc fact-update faq foldoc fortune fptools gazetteer get-shapr ghc
19:09:53 <lambdabot> [8 @more lines]
19:10:00 <jethr0_> hmm
19:10:02 <int-e> heh.
19:10:09 <dons> int-e, yeah, good point. damn smilesy
19:10:18 <vincenz> > reverse "):"
19:10:18 <lambdabot> ":)"
19:10:29 <vincenz> > fromEnum ':'
19:10:30 <lambdabot> 58
19:10:30 <vincenz> > fromEnum ')'
19:10:31 <lambdabot> 41
19:10:34 <vincenz> > fromEnum '('
19:10:35 <lambdabot> 40
19:11:26 <dons> can anyone think of a problem allowing all of ['@', '#', '$', '\\', '.', '%', '&', '-', '+']
19:11:38 <vincenz> dons: lack of other plugins
19:11:42 <vincenz> like >
19:11:48 <dons> what do you mean?
19:11:54 <ihope> dons: If the input is in ['@', '#', '$', '\\', '.', '%', '&', '-', '+'], then YES, otherwise NO.
19:11:56 <vincenz> well you won't have any other possibilities
19:12:11 <vincenz> I mean any plugins that respond to singlechar prefixes like @eval
19:12:24 * int-e doesn't like +, - and ., but for no good reason. they don't feel command-like.
19:12:33 <dons> the current lambdabot setup means plugins don't get to choose, vincenz.
19:12:39 <dons> int-e, ok. fair enough
19:12:43 <dons> i'll remove those two
19:13:05 <dons> so, ['@','#','$','\\','.','%','&'] 
19:13:17 <dons> oh, and some wanted !
19:13:33 <vincenz> why not some aliases for >
19:13:37 <vincenz> # code
19:13:48 <dons> yeah, that's a good idea too.
19:13:50 <dons> and | code
19:13:54 <vincenz> yeah :)
19:14:03 <stepcut> - might be bad if people posting code snippets that have -- comments at the beginning
19:14:55 * vincenz would also not mind having something like
19:14:57 <vincenz> + and -
19:15:01 <vincenz> to denote start, end of scope of some code
19:15:06 <vincenz> so you can do multiline
19:15:21 <stepcut> that sounds (Possibly) nice
19:15:27 <vincenz> > def1
19:15:28 <lambdabot>  Not in scope: `def1'
19:15:29 <vincenz> > def2
19:15:30 <lambdabot>  Not in scope: `def2'
19:15:32 <vincenz> > usedef1 and def2
19:15:33 <lambdabot>  Not in scope: `def2'
19:15:47 <vincenz> I'd go for per-user scope
19:15:53 <vincenz> so people can setup some basic functions they often use
19:16:23 <vincenz> anyways, night
19:16:33 <vincenz> or, even better
19:16:36 <ihope> @time vincenz
19:16:37 <dons> scope would be fun, but it's a bit more work
19:16:40 <int-e> nah, that's not good. people will wonder why copying other people's code doesn't work for them
19:16:45 <vincenz> have a website where people can enter in basic defs they use...
19:16:45 <dons> it's been discussed before  though. the lispy guys have it?
19:16:50 <ihope> Mmh, good night.
19:16:54 <vincenz> :)
19:17:08 <dons> there's something to be said for stateless eval though
19:17:12 <vincenz> like an online "wiki" where you enter your basic code-defs
19:17:14 <vincenz> that would be easier
19:17:17 <vincenz> just load it in before eval
19:17:32 <vincenz> sort of like a .hs file that gets loaded before > evals
19:17:34 <vincenz> and is user-based
19:18:06 <vincenz> anyways
19:18:07 * vincenz is off
19:18:09 <stepcut> that is, in a way, a weak form of per user plugins
19:18:20 <stepcut> the hurd of irc bots 
19:19:54 <stepcut> that might be interesting -- if each user could install their own lambdabot plugins, but they were all properly isolated from each other (but with IPC).
19:20:01 <ski> sarahbot (in e.g. #schemerepl) allows per-user scope interaction, and also allows a user to join another user's scope
19:20:31 * stepcut dreams up a spec for hurdbot
19:20:39 <ihope> @babel en es To be or not to be: that is the question.
19:20:40 <lambdabot>  Para ser o no ser: sa es la pregunta.
19:20:49 <ihope> @babel es en Para ser o no ser: ésa es la pregunta.
19:20:50 <lambdabot>  To be or not to be: ésa is the question.
19:20:56 <ihope> Mmh.
19:21:43 <ihope> @babel en es Mmh.
19:21:44 <lambdabot>  Mmh.
19:21:47 <dons> @pl arePrefixesOf els str = any (flip isPrefixOf str) els
19:21:48 <lambdabot> arePrefixesOf = flip (any . flip isPrefixOf)
19:21:56 <ihope> @babel en es
19:21:57 <lambdabot>  bzzt.
19:21:58 <ihope> @babel en es if each user could install their own lambdabot plugins, but they were all properly isolated from each other
19:22:00 <lambdabot>  si cada usuario podra instalar sus propios plugins del lambdabot, pero
19:22:00 <lambdabot> los eran todo aislado correctamente de uno a
19:22:22 <ihope> @babel es en si cada usuario podría instalar sus propios plugins del lambdabot, pero los eran todo aislado correctamente de uno a
19:22:23 <lambdabot>  if each own user podría to install their plugins of lambdabot, but were
19:22:23 <lambdabot> them all isolated one correctly of one a
19:22:42 <jethr0_> (`isPrefixOf` str)
19:23:13 <dons> that's not arePrefixesOf ;)
19:23:16 <ski> (if you want to try out #schemerepl, do '.repl' and '.help')
19:23:32 <jethr0_> dons: i know, i meant istead of flip
19:24:15 <ihope> @. babel es en . babel en es quote
19:24:16 <lambdabot> compose module failed: Parse error: "es"
19:24:22 <ihope> I know that wouldn't work.
19:24:27 <ihope> @babelesen
19:24:28 <lambdabot> Unknown command, try @listcommands.
19:24:34 <ihope> Bleh.
19:24:40 <dons> i don't know if there's a way to make @. work -- it's not haskell
19:24:46 <dons> unfortunately
19:36:33 <ihope> > @
19:36:34 <lambdabot>  parse error on input `@'
19:36:41 <ihope> > (@)
19:36:42 <lambdabot>  parse error on input `@'
19:36:49 <ihope> > bleh @ blah
19:36:50 <lambdabot>  Pattern syntax in expression context: bleh@blah
19:36:53 <ihope> !
19:36:58 <ihope> As-patterns!
19:37:29 <ihope> @type \s@(x:xs) -> if null s then (1,3) else (x,xs)
19:37:30 <lambdabot> forall a.
19:37:30 <lambdabot>                  (Num a, Num [a]) =>
19:37:30 <lambdabot>                  [a] -> (a, [a])
19:38:00 <ihope> (\s@(x:xs) -> if null s then error "oh noes" else (x,xs)) "oh noes"
19:38:08 <ihope> > (\s@(x:xs) -> if null s then error "oh noes" else (x,xs)) "oh noes"
19:38:10 <lambdabot> ('o',"h noes")
19:39:28 <dons> @pl \c -> (myname ++ [c]) `isPrefixOf` text
19:39:29 <lambdabot> (`isPrefixOf` text) . (myname ++) . return
19:39:33 <dons> return eh?
19:44:45 <ihope> (:[])?
19:44:54 <ihope> That's a cute emoticon.
19:45:48 <Cale> :[] grar!
19:45:53 <dons> @type (((((((((((((((((((: []) :) :)  :) :) :) :) :) :) :) :) :) :) :) :) :) :) :) :)
19:46:50 <dons> ghc's struggling to get that typed. oh well.
19:47:45 <lambdabot> type module failed: thread killed
19:48:28 <dons> @seen lambdabot
19:48:29 <lambdabot> Yes, I'm here. I'm in #khjk, #plone, #ScannedInAvian, #haskell.es, #
19:48:29 <lambdabot> haskell.it, #gentoo-haskell, #haskell-overflow, #flippi, #haskell-blah
19:48:29 <lambdabot> and #haskell
19:48:56 <int-e> hmm ... and printed. argh. :)
19:50:15 <dons> @quit new syntax for commands
19:50:24 <dons> ?version
19:50:44 <lambdabot> lambdabot 3p313, GHC 6.4.1 (Linux i686 Intel(R) Pentium(R) 4 CPU 3.20GHz)
19:50:46 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:51:09 <dons> \bot
19:51:10 <lambdabot> :)
19:51:15 <dons> | 1+2
19:51:16 <lambdabot> 3
19:51:25 <dons> .type map
19:51:26 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
19:51:42 <dons> it's "do you you want" month here at #haskell!
19:52:06 <int-e> . o O ( oh no! )
19:52:06 <lambdabot> Maybe you meant: . all-dicts arr babel botsnack choice-add code compose
19:52:06 <lambdabot> devils dice dict dict-help djinn djinn-add djinn-clr djinn-del djinn-env
19:52:06 <lambdabot> djinn-ver docs dummy dynamic-load dynamic-reload dynamic-unload easton
19:52:06 <lambdabot> echo elements elite eurohaskell eval fact fact-cons fact-delete fact-set
19:52:06 <lambdabot> fact-snoc fact-update faq foldoc fortune fptools gazetteer get-shapr ghc
19:52:08 <lambdabot> [8 @more lines]
19:52:16 <dons> ah. interesting
19:52:36 <dons> cmds should have no space in front of them
19:52:41 <dons> unlike evals
19:52:53 <dons> this was rare with @ but will be more common now
19:53:13 <dons> .. id id "foo!"
19:53:13 <lambdabot> "foo!"
19:53:31 <int-e> /\_/\__/\___/\____/\_____
19:53:47 <dons> that's just wacked
19:55:27 <aFlag> when i do ghc -static -o foo foo.hs, shouldn't the file program say it's a static linked program and not a dynamic linked one?
19:55:29 <int-e> ... maybe using dot as prefix isn't such a good idea really.
19:55:29 <lambdabot> compose module failed: Parse error: "maybe"
19:55:45 <dons> hmm. maybe:/ oh well
19:55:51 <dons> i'll remove it. it seemed so nice
19:56:34 <Lemmih> aFlag: Try -optl-static or -optc-static
19:57:36 <aFlag> yeah, that did it, thanks
19:57:44 <int-e> -static just tells the compiler to link the haskell stuff statically (which is the default anyway)
19:58:20 <dons> @quit patchify!
19:58:47 <dons> . o O ( fixed? )
19:58:52 <dons> !
19:58:56 <dons> should do anything
19:58:57 <dons> @
19:58:58 <dons> neither
19:58:59 <aFlag> oh, i see, thanks
19:59:06 <dons> @x
19:59:06 <lambdabot> Not enough arguments to @.
19:59:08 <dons> should
19:59:09 <dons> good
19:59:19 <dons> \bot
19:59:19 <lambdabot> :)
19:59:21 <int-e> ...
19:59:27 <int-e> \\\
19:59:28 <lambdabot> Maybe you meant: . id pl wn
19:59:48 <dons> \. id id "! and . aren't magic now"
19:59:49 <lambdabot> "! and . aren't magic now"
20:00:22 <dons> you can choose from ["@","$","?","\\","%","&"]
20:00:30 <dons> and for evals, you get [">","#","|"]
20:00:50 <dons> ?
20:00:54 <dons> good
20:01:04 <dons> ?yow
20:01:04 <lambdabot> Will it improve my CASH FLOW?
20:02:21 <int-e> @quote
20:02:21 <lambdabot> dcnstrct says: even the #lisp people say go with haskell
20:02:38 <int-e> @quote lambdabot
20:02:38 <lambdabot>  Couldn't match kind `?? -> ? -> *' against `(* -> *) -> * -> *'
20:03:00 <int-e> \kind (->)
20:03:00 <lambdabot> ?? -> ? -> *
20:03:58 <dons> that looks nice ^^
20:04:02 <dons> I think \ is the best one :)
20:04:06 <Spark> @quote turing
20:04:06 <lambdabot> turing hasn't said anything memorable
20:04:13 <int-e> ouch.
20:04:17 <Spark> ;)
20:06:56 <dons> \vers
20:06:57 <lambdabot> lambdabot 3p313, GHC 6.4.1 (Linux i686 Intel(R) Pentium(R) 4 CPU 3.20GHz)
20:06:57 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:07:04 <dons> \dynamic-reload version
20:07:04 <lambdabot> module reloaded
20:07:06 <dons> \vers
20:07:06 <lambdabot> lambdabot 3p318, GHC 6.4.1 (Linux i686 3.20GHz)
20:07:06 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:18:55 <sjanssen> \quote lambdabot
20:18:55 <lambdabot>  Occurs check: cannot construct the infinite type: a
20:19:10 <sjanssen> so, error message or joke?
20:19:19 <dons> joke :)
20:19:22 <sjanssen> \quote lambdabot
20:19:22 <lambdabot>  lambdabot hasn't said anything memorable
20:19:26 <dons> it's certainly _not_ running the typechecker
20:19:32 <dons> that is also a joke
20:19:36 <sjanssen> haha
20:19:40 <sjanssen> those are pretty good
20:19:47 <dons> \quote ghc
20:19:48 <lambdabot>  does not have the required strict field(s)
20:19:50 <dons> ghc has a  bunch too
20:19:51 <dons> ghc has a  bunch too
20:19:53 <dons> \quote ghc
20:19:54 <lambdabot>  Splices are not allowed in hs-boot files
20:20:01 <dons> and so on
20:20:35 <dons> ^^ and just when I was going to stick my TH splices in my .hs-boot files to break the module recursion! :/
20:20:38 <dons> boo boo
20:44:23 <ihope> #3+2
20:44:26 <ihope> # 3+2
20:44:27 <lambdabot> 5
20:44:51 <ihope> So it won't get confused with Eaglebot, if Eaglebot ever... happends.
20:45:45 <dons> the eval functions need a space. if Eaglebot, your bot?, needs something in the prefix name space, we can disable something in lambdabot of course
20:46:50 <ihope> Well, it'll take the #foo, and the first letter of foo would never be a space.
20:47:46 <dons> ok, so that wouldn't clash anyway. but probably i'll remove the unused prefixes after a week or two anyway
20:47:56 <dons> so if no one uses # or | for evals, i'll just turn it off
20:48:21 <SamB> that looks ugly
20:48:31 <SamB> shouldn't run Haskell code as root anyway
20:48:53 <ihope> :-)
20:49:38 <ihope> Now, QML looks fun.
20:49:53 <ihope> @localtime ihope
20:49:56 <lambdabot> Local time for ihope is Friday, March 10, 2006 11:49:18 PM
20:50:10 <ihope> As you can see, I should be getting to bed.
20:50:25 <ihope> ===	sleep Unknown command
20:50:25 <dons> SamB, hehe
20:50:32 <ihope> Ah well.
20:50:36 <SamB> Quantum Mechanical Language?
21:00:42 <GeniXPro> If i input (y   a b c x = ax^2 + bx + c) into haskell, is there a way to solve for values automatically, making a new function, like given the return of that function, and b, c, and x, this modifying function will create a function that solves for a
21:08:05 <lispy> GeniXPro: you want haskell to do constraint solving using language features?  I don't know of any tricks
21:08:22 <GeniXPro> lispy, i want haskell to do my math homework
21:08:36 <lispy> heh, now that is possible for some definitions of math
21:08:52 <aFlag> GeniXPro, you could use maxima
21:08:54 <GeniXPro> but given haskells pure functionalism its possible to do that for any pure function
21:09:27 <aFlag> it's probably better suited for what you want
21:20:05 <dons> you want a constraint solver? use maple or something.
21:20:14 <dons> haskell's a good language to write such a solver in..
21:22:14 <dons> you can play around with things though, 
21:22:15 <dons> Prelude> let y b c x a = a * x^2 + b * x + c
21:22:15 <dons> Prelude> let z = y 2 7 3
21:22:15 <dons> Prelude> z 3
21:22:15 <dons> 40
21:27:45 <stepcut> if a module defines an instance of Read, can I import that module, but hide the Read instance ?
21:28:16 <stepcut> (because the Read provided by the module is busted, I want to try to develop a working version without recompiling the broken module)
21:29:41 <stepcut> hrm, according to SPJ -- the answer is no... I will trust him on that one
21:34:52 <aFlag> maple is proprietary software, I rather use maxima, it's fairly descent
21:45:57 <dons> stepcut, can't be done.
21:46:08 <dons> even if you : import Foo () -- you still get the instances
21:47:27 <dons> but, maybe you can do some magic with overlapping instances or incoherant instances?
21:48:21 <dons> aFlag, ah interesting. I don't use either . could a lambdabot plugin be written for maxima? .... would you like to write one?
21:48:53 <aFlag> what kind of plugin?
21:50:08 <aFlag> in the channel #math they have a bot that works like a frontend to maxima, I think cale is who have done it i think
21:50:16 <aFlag> i'm not too good of a haskell programmer :(
21:50:25 <Cale> mathematica
21:50:27 <Cale> actually
21:50:42 <Cale> but maxima would be cool to have too
21:50:46 <aFlag> Cale, isn't there a maxima one?
21:50:49 <aFlag> i thought there was
21:50:55 <Cale> I should possibly get maxima and set that up
22:06:01 * JKnecht smiles as he places a Hollerith card to bookmark the "Monadology" section of his yellowed 1902 edition of the Discours
22:07:19 <GeniXPro> wow maxima is confusing
22:13:38 <stepcut> arg, my email to haskelldb-users was blocked, because the webmail client had the wrong variation of my email address, and my private message to bringert was blocked because I did not identify with NickServ :p
22:40:39 <dons> just thinking that a plugin to a free math system is more useful than a plugin to mathematica
22:41:08 <dons> JKnecth, yeah, the monadology is fun :)
22:41:24 <dons> should be the name of a Haskell news magazine perhaps
22:50:49 <lispy> stepcut: yeah, the "must identify" thing is crap
22:50:57 <lispy> i really hate that about freenode
22:52:46 <stepcut> atleast you don't have to submit a gpg key or something wacky ;)
22:53:00 <lispy> stepcut: ssssh, lilo might hear you :)
22:53:46 * stepcut covers his mouth
22:54:41 * stepcut goes to bed
22:55:15 <araujo> Hello!
22:55:25 <lispy> hi
22:55:29 <lispy> welcome to #haskell
22:55:32 <lispy> (again)
22:57:07 <araujo> Is this that weird programming language that doesn't have variables?
22:57:58 <int-e> that was unlambda.
22:58:27 <aFlag> that's assembly :P
22:58:41 <araujo> muahaha
22:59:07 <araujo> yes, it's this!!.. Hasakell doesn't have variables!!!
22:59:23 <aFlag> unless you call a register a variable...
22:59:43 <int-e> I would even call named memory cells variables.
23:00:59 <aFlag> for me that's the implementation of a variable, but it's not actually the abstraction of a variable
23:01:54 <int-e> araujo: you can think of them as single assignment variables.
23:02:07 <araujo> oh no, this looks like that kind of discussion of "every programming language is interpreted" ! ;-)
23:02:34 <int-e> and further, there are no programs, only data?
23:03:06 <araujo> No, only electrons and protons as far as i know
23:03:12 <araujo> :-)
23:03:17 <araujo> Well, im off to bed
23:03:21 <aFlag> int-e, that's not necessarily true on monads though
23:03:44 <int-e> aFlag: that depends on the level you look at.
23:04:04 <aFlag> how come?
23:04:12 <int-e> aFlag: but it's pointless to discuss this really. let's not do it.
23:04:23 <aFlag> yeah
23:05:30 <lispy> i like the lispers way to look at it.  Code is data and data is code is data is code is data is code...
23:17:08 <JKnecht> dons: yeah, current Scientific American article on generalizations of the Incompleteness Theorem lead to my fishing out the old tome. The punched card was from a place that still had tab.
23:20:16 <Cale> Haskell has variables. It just doesn't (unless you include GHC) have mutable cells.
23:20:42 <Cale> What else would you call x in (\x -> x + 1)?
23:21:09 <Cale> In x + 1 it's a free variable, and in \x -> x + 1, it's a lambda-bound variable.
23:23:20 <lispy> > (\x -> x + 1) 2
23:23:21 <lambdabot> 3
23:23:23 <lispy> > (\x -> x + 1) 3
23:23:24 <lambdabot> 4
23:23:34 <lispy> nah, x is fixed, clearly
23:23:39 <lispy> ;)
23:26:46 <JKnecht> do I correctly assess that there is no concurrency packages (other than threading) such as GPH which is current (i.e. ghc 6.4 or later)?
23:27:05 <JKnecht> s/is/are/
23:31:08 <lispy> JKnecht: i don't understand
23:33:25 <JKnecht> GPH = Glasgow Parallel Haskell, the haskell wiki lists three other packages at least one of which is a fragment/pearl. Stuff like GPH is what I'm referring to. GPH seems to be based on an ancient release of ghc.
23:34:59 <JKnecht> and on topic, I concur, dynamic stuff I wanna do in CL, Prolog and Haskell stuff should be compiled.
23:43:39 <alar> greetings
23:46:19 <JKnecht> hi
23:46:21 <dons> the concurrency stuff you get is in Control.Concurrent, and I guess Control.Concurrent.STM is also interesting. it's not paralell haskell, no -- that's very old stuff. note also that we now have SMP ghc in the cvs.
23:46:53 <JKnecht> in 6.5 HEAD?
23:47:12 <dons> yup.
23:47:34 <dons> is it for research purposes you're asking, or for an application you're writing?
23:47:42 <JKnecht> the later.
23:47:48 <JKnecht> the latter?
23:48:06 <dons> if the atter, I suggest sticking to Control.Concurrent then. it's tried and tested, stable and fast
23:48:27 <dons> use forkIO, MVars and the like. perhaps with STM too 
23:48:27 <JKnecht> Negative. Must integrate PVM.
23:48:42 <dons> hmm. harder then
23:48:54 <dons> maybe the code still works.
23:49:03 <dons> or you might have to ask on haskell@
23:49:09 <JKnecht> the extant pearls and GPH should suffice.
23:49:26 <dons> ok, hope it works.
23:49:38 <dons> it will be interesting to find out how the code base is holding up
23:50:45 <JKnecht> so I should expect Control.Concurrent to be "rock solid" if I run on x86_64 x 2 on FC4?
23:51:37 <dons> yeah, I would expect it to be.
23:52:12 <JKnecht> Acknowledged/Thanks.
23:52:17 <dons> GHC HQ has an amd64 these days
23:53:04 <JKnecht> x 4?
23:53:36 <dons> well, if you really want to run smp, that's probably going to be more experimental.
23:53:46 <JKnecht> i think they support up to 8-way, intel only seems to do 4.
23:54:03 <dons> you'd do best to ask on glasgow-haskell-users@ about running ghc's rts on such a beast
23:54:07 <JKnecht> it's Intel I have btw.
23:56:39 <sjanssen> I wish it was easier to work with C structs and the FFI
