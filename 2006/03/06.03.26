00:36:15 <davidhouse> i decided to take the plunge and learn emacs.
00:36:58 <davidhouse> but i don't want to have to relearn a set of shortcuts.
00:37:01 <neologism> what editor hae you been using till now?
00:37:07 <davidhouse> kate, mostly.
00:37:49 <davidhouse> my valuable shortcuts are: c-x, c-c, c-v for cut, copy, paste. c-z for undo. c-f for find, F3 for find next, c-r for replace, c-a for find all
00:38:05 <neologism> why do you want to learn emacs and not some other editor?
00:38:51 <davidhouse> not really sure. i'd like one of these über-configurable editors under my belt, but i guess i don't have any specific reasons to pick emacs
00:39:11 <neologism> ah
00:40:02 <neologism> I'd try more then one editor and then settle with the one that suits you the most
00:40:29 <davidhouse> sure.
00:40:50 <davidhouse> so how do i go about configuring emacs's shortcuts?
00:41:34 * neologism a vim user
00:41:57 <davidhouse> ah.
00:45:25 <Korollary> M-x customize. But you'd want to use emacs as is for a while before you start changing things around.
00:46:05 <Korollary> also see emacswiki.org
00:46:51 <davidhouse> thanks, Korollary.
00:47:46 <neologism> yes... one should learn the editor as it is before customizing it too much
00:53:12 <mathrick> davidhouse: try CUA-mode
00:53:24 <davidhouse> apparently that doesn't work in xemacs
00:53:31 <mathrick> available as an add-on, and also in CVS builds (you want that)
00:53:42 <mathrick> davidhouse: in emacs it'll need separate downloading
00:53:55 <davidhouse> okay.
00:53:56 <mathrick> and also, throw away CUA shortcuts, they're junk anyway :)
00:54:08 * mathrick uses CUA mode, but without CUA shortcuts
00:54:14 <mathrick> I use wordstar keys instead
00:54:31 <mathrick> C-insert, S-insert, C-delete
01:05:03 <sjanssen> machack666 / rasfar / dancor : if you are still interested in the padding problem, I took a stab at it. http://cse.unl.edu/~sjanssen/pad.hs
01:05:52 <sjanssen> one does the length and padding simultaneously, the other has better time and space complexity.  both work on infinite rows
01:06:24 <rasfar> very neat.  i'll have to read them for a while here...
01:07:46 <davidhouse> where can i get a haskell syntax highlighter for emacs?
01:07:53 <sjanssen> however, in practice, they're probably slower than the straightforward way to do it
01:08:21 <mathrick> davidhouse: emacswiki.org
01:10:15 <gvdm> how do you check if something has a clean square root?
01:10:36 <davidhouse> mathrick: thanks again.
01:10:50 <davidhouse> gvdm: by square-rooting it?
01:10:54 <mathrick> heh
01:11:14 <davidhouse> that's surely the easiest way
01:12:04 <gvdm> hmm as in, is there a simple two function that gives me a bool if its 9 or 16 but not 8 or10
01:12:52 <rasfar> sjanssen, do you mean except for large inputs, or are they slower because of implementation?
01:12:59 <gvdm> instead of having to squareroot it and then check if its rounding is the same as itself
01:14:52 <sjanssen> rasfar: well, I haven't measured anything, but the first variant is almost certainly slower for any input
01:15:51 <rasfar> oh, the first version -- same complexity as doing it in two passes?  but the second one looks like it should be better...
01:16:12 <sjanssen> the second has an advantage if the maximum row is bigger than other rows
01:17:31 <rasfar> oh woops
01:19:02 <rasfar> gvdm: have you seen http://www.mathpages.com/home/kmath265.htm
01:37:30 <xerox> 'mornin
01:38:45 <neologism> anyone skilled with evolution/genetic progamming here?
01:39:04 <xerox> What's the qvestion?
01:39:43 <neologism> whats the difference between those two :)
01:39:53 <neologism> it seems to me that its exactly the same
01:42:59 <rep> yes
02:04:13 <adu> hello?
02:26:42 <neologism> anyone skilled with Random here?
02:27:07 <xerox> What's the qvestion?
02:27:22 <neologism> genOne :: StdGen -> Int -> IO String
02:27:22 <neologism> genOne g l = do
02:27:22 <neologism>                 line <- randomRs ('0', '1') g
02:27:22 <neologism>                 return $ take l line
02:27:31 <neologism> and it tells me that "line" is [a]
02:27:37 <neologism> and I have it to be String (ie. [Char])
02:27:41 <neologism> how do I do so?
02:28:06 <xerox> randomRs produces an infinite list of random values.
02:28:24 <neologism> yes
02:28:36 <neologism> but I want the values to be Chars
02:30:10 <xerox> You can't feed randomRs chars.randomRs ('0','1') :: (RandomGen g) => g -> [Char]
02:30:14 <xerox> Ops.
02:30:16 <xerox> randomRs ('0','1') :: (RandomGen g) => g -> [Char]
02:30:19 <xerox> Nevermind the first phrase.
02:30:50 <xerox> The problem is that the '<-' disassembles the list in single Chars.
02:30:58 <neologism> ?
02:31:00 <neologism> hows that?
02:31:01 <xerox> getOne g l = take l line
02:31:14 <xerox>   where line = randomRs ('0','1') g
02:31:27 <neologism> why <- does the ill effect?
02:31:31 <neologism> should it be String?
02:31:38 <xerox> Because you are using the List Monad.
02:31:57 <neologism> ah
02:32:09 <xerox> You see?  Read the type cautiously.
02:34:38 <xerox> You can do something like this if you want to get an IO-typed function:
02:34:49 <xerox> getOne l = do g <- newStdGen
02:35:26 <xerox>               etc.
02:36:03 <neologism> ok, thnx
02:37:23 <MarcWeber> Is there already getListItem function similar to (head.(drop x)) ?
02:37:31 <xerox> @type (!!)
02:37:32 <lambdabot> forall a. [a] -> Int -> a
02:39:29 <xerox> (Yes, it is called !!.)
02:40:00 <MarcWeber> xerox: Thanks.. I forgot the second ! ;)
02:40:11 <xerox> You're welcome. (!) is for Arrays.
02:40:32 <neologism> btw: is there something like "take n $ repeat" ?
02:40:40 <xerox> Yes.
02:40:43 <xerox> @type replicate
02:40:43 <lambdabot> forall a. Int -> a -> [a]
02:40:55 <neologism> thnx
02:40:55 <xerox> Question like these can be answered by hoogle, usually.
02:41:03 <xerox> @hoogle Int -> a -> [a]
02:41:03 <lambdabot> Data.List.replicate :: Int -> a -> [a]
02:41:03 <lambdabot> Prelude.replicate :: Int -> a -> [a]
02:41:03 <lambdabot> Data.List.repeat :: a -> [a]
02:41:22 <xerox> Provided that you can formalize your idea in a type.  :-)
02:41:43 <neologism> can I use this even for monadic functions?
02:41:49 <xerox> Yes, you can.
02:43:05 <xerox> Oh, uhm.  It doesn't seem to work in the lambdabot version tho.
02:43:23 <xerox> @hoogle Monad m => m (a -> b) -> m a -> m b
02:43:24 <lambdabot> No matches, try a more general search
02:44:29 <neologism> @hoogle Monad m => [m a] -> m [a]
02:44:30 <lambdabot> No matches, try a more general search
02:44:32 <neologism> :(
02:44:57 <xerox> Maybe the web version does it.
02:44:59 <neologism> is there anything to make [IO a] -> IO [a] ?
02:45:11 <xerox> Yup.  sequence.
02:45:33 <neologism> oh yes :)
02:47:59 <neologism> foo :: [IO String]
02:48:10 <neologism> sequence foo = IO [String] ?
02:48:15 <xerox> Yes.
02:48:25 <xerox> s/=/::/
02:48:34 <neologism> yes.. but you got it ;)
02:48:42 <neologism>  let n = replicate p $ genOne l
02:48:42 <neologism>                 return $ sequence n
02:48:47 <neologism> n :: [IO String]
02:49:07 <neologism> it tells me that return $ sequence n :: a (IO [[Char]])
02:49:11 <neologism> hows that?
02:50:08 <xerox> return does encapsulate the value in a monadic binding.
02:50:37 <neologism> ok.. got it working :)
02:50:40 <xerox> If `sequence foo' returns an IO [a], then `return $ sequence foo' will return an `Monad m => m (IO a)'.
02:54:02 <xerox> @seen bosie
02:54:02 <lambdabot> I haven't seen bosie.
03:18:36 <neologism> whats wrong with this
03:18:36 <neologism> getRandomString s1 s2 = do
03:18:36 <neologism>                                 n <- getStdRandom (randomR (0,1))
03:18:36 <neologism>                                 return "foo"
03:19:58 <neologism> the n <- is bad
03:20:16 <neologism> when I rewrite it as
03:20:19 <neologism>   g <- newStdGen
03:20:19 <neologism>                                 let n = randomR (0, 1) g
03:20:23 <neologism> its also bad :(
03:20:45 <xerox> You must make your do blocks and with an expression.
03:21:16 <neologism> uhm?
03:21:40 <xerox> Wait...
03:22:08 <xerox> Hmm, what's the exact error?
03:23:08 <neologism> *** Expression    : getRandomString
03:23:08 <neologism> *** Type          : String -> String -> IO String
03:23:08 <neologism> *** Given context : ()
03:23:08 <neologism> *** Constraints   : (Random a, Num a)
03:23:16 <neologism> ERROR "Evo.hs":47 - Cannot justify constraints in explicitly typed binding
03:23:28 <neologism> the type is String -> String -> IO String
03:23:35 <xerox> Sorry they call me for lunch.  Good luck!
03:23:45 <neologism> enjoy your lunch
03:25:00 <neologism> uh
03:25:18 <neologism> n <- rollDice where rollDice = getStdRandom (randomR (0,1))
03:25:21 <neologism> this works
03:25:25 <neologism> I dont see the difference
03:58:58 <sili_> bored
04:00:00 <jyp> @quote
04:00:01 <lambdabot> S.Behrens says: or maybe she is the Queen of Sciences and he is the Mack Daddy.
04:05:24 <jeroen_p> hello
04:06:25 <neologism> is there any easy way in do block to do some loop?
04:06:43 <ibid> let loop = ...
04:06:44 <ibid> loop
04:06:45 <ibid> :)
04:07:00 <ibid> (vary as necessary)
04:08:40 <neologism> I dont get it
04:09:27 <xerox> action = let loop = do foo
04:09:46 <xerox>                        bar
04:10:00 <xerox>          in loop
04:10:07 <xerox> ops.
04:10:11 <neologism> how does this loop?
04:10:13 <xerox> action = let loop = do foo
04:10:15 <xerox>                        bar
04:10:17 <xerox>                        loop
04:10:19 <xerox>          in loop
04:10:27 <neologism> how do I stop this?
04:10:37 <neologism> by return?
04:10:41 <xerox> No.  What do you want to do exactly?
04:10:52 <neologism> I am implementing genetic algorithm
04:11:02 <neologism> I have done one step crossbreeding
04:11:06 <neologism> and now I want it to loop
04:11:08 <xerox> Well, casing on the inner loop call will permit you to exit at some point.
04:11:08 <neologism> in some easy way
04:11:22 <xerox> There also is iterate, if you have an a -> a function.
04:11:34 <xerox> Or even fix. (The Y combinator.)
04:12:05 <int-e> I guess you can use a monad that limits the number of iteration steps. (hrm, which is, technically, not a monad. but that doesn't matter.)
04:12:10 <neologism> hm...
04:12:12 <xerox> Something like `takeWhile condition $ iterate function initialValue' is ok sometime.
04:12:38 <ibid> neologism: for stopping that loop, you normally add parameters to the loop function and then do cases based on it
04:12:39 <int-e> of course that raises the question on what level do you want to stop the loop :)
04:13:09 <neologism> I have something like
04:13:12 <neologism> do 
04:13:20 <neologism> generation0;
04:13:25 <ibid> neologism: those parameters then become the loop induction variables
04:13:34 <neologism> generation1 <- cross generation0
04:13:46 <neologism> generation1 <- merge generation0 generation1
04:13:51 <neologism> and I want to loop over this
04:14:40 <xerox> Looks like iterate (ap merge cross) or something.
04:14:53 <neologism> ok
04:14:55 <neologism> will think about it
04:15:07 <neologism> I wondered if there is some "do-enabled" loop
04:15:09 <neologism> like in lisp etc
04:15:19 <xerox> There is mdo which do recursion...
04:15:22 <int-e> sequence, sequence_
04:15:31 * int-e thinks
04:15:42 <int-e> na, need a foldM here.
04:15:49 <int-e> @index foldM
04:15:49 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
04:15:53 <xerox> Possibly.
04:15:57 <int-e> @type Control.Monad.foldM
04:15:58 <lambdabot> forall a (m :: * -> *) b.
04:15:58 <lambdabot>         (Monad m) =>
04:15:58 <lambdabot>         (a -> b -> m a) -> a -> [b] -> m a
04:18:17 <ibid> xerox: mdo is value recursion, very different from anything seen in lisp and other languages
04:19:07 <xerox> Do the 'things seen in lisp' mean LOOP macros?
04:19:32 <ibid> as far as i know, those are regular recursion, not value recursion
04:19:48 <xerox> What's the difference?
04:19:49 <ibid> but i don't know lisp that weÃ¶Ã¶
04:20:00 <int-e> @pl foldr id
04:20:00 <lambdabot> foldr id
04:20:46 <ibid> xerox: value recursion is what happens in non-monadic context when you do ones = 1 : ones; the other kind is unfolding recursion, and there recursion is by function call
04:21:03 <ibid> xerox: value recursion is iow tying the knot
04:21:11 <int-e> @hoogle a -> [a -> m a] -> m a
04:21:12 <lambdabot> No matches, try a more general search
04:21:32 <xerox> @type foldr (=<<)
04:21:34 <lambdabot> forall (m :: * -> *) b.
04:21:34 <lambdabot>      (Monad m) =>
04:21:34 <lambdabot>      m b -> [b -> m b] -> m b
04:22:06 <int-e> @type foldr (=<<) . return
04:22:07 <lambdabot> forall (m :: * -> *) a.
04:22:07 <lambdabot>         (Monad m) =>
04:22:07 <lambdabot>         a -> [a -> m a] -> m a
04:22:09 <jeroen_p> Excuse my rude interruption. I'm fairly new to haskell, and I've come across a problem which I can't seem to find a tidy solution for.
04:22:25 * xerox wants to pair-program with int-e sometime!!
04:23:37 <ibid> jeroen_p: just tell us the problem instead of apologising for it :)
04:24:41 <Phyx-> hello, one question, how can i change the path ghci looks for when doing imports?
04:24:41 <int-e> @pl \n action init -> foldr (=<<) (return init) (replicate n action)
04:24:41 <lambdabot> (flip (foldr (=<<) . return) .) . replicate
04:24:52 <Phyx-> if i put the full path in the file, i get an error
04:25:02 <jeroen_p> I have a class 'Parseable', which requires a function which transfers a type into a list of parser rules, and gives you a toString function which requires a function in order to transfer the type to a string 
04:26:01 <jeroen_p> Now I would like to make two different types of parseables, one that parse to (x)(h)tml, and another that parses to some other format
04:26:58 <integral> Phyx-: try -i
04:27:06 <jeroen_p> Both these require exactly the same 'transfer to list of parser rule'-function, but a completely different function for the toString-function
04:27:38 <jeroen_p> I can't find a neat solution to this
04:27:54 <Phyx-> integral: :set -i?
04:27:59 <ibid> hrm, i'm having trouble following. can you put somewhere a few lines of haskell about this? :)
04:28:10 <integral> Phyx-: hmm, not sure what it is inside ghci.   very possibly that I suppose
04:28:14 <Phyx-> nothing more? still files then, "parse error on input c"
04:28:44 <Phyx-> fails*
04:28:45 <integral> ah, a parse error, that would imply you're feeding it something that's not proper haskell
04:29:07 <int-e> So, I guess I want these: compose l = flip (foldr id)  and composeM l = flip (foldr (=<<) . return)
04:29:10 <Phyx-> prolly, if full paths aren't allowed
04:29:22 <Phyx-> import c:\Downloads\test.hs
04:29:26 <integral> Phyx-: umm, yes, import takes module names, not file names.
04:29:28 <int-e> err, without the two ' l'
04:29:29 <jeroen_p> class ParseAble a where
04:29:30 <jeroen_p>    toSheet::a -> Node -> Node -> TSheet
04:29:48 <integral> Phyx-: you use -i to point ghc(i) at the directory at the base of your module sources
04:30:21 <jeroen_p> When you instantiate a type as ParseAble, you get the function "toString::NodeParser -> TSheet -> Maybe String"
04:30:27 <Phyx-> tried passing params to -i and it told me "unrecognized flags"
04:30:35 <Phyx-> did :Set -i C:\downloads\
04:30:55 <jeroen_p> Now I want two different types of parseables, whose only difference lies within the NodeParser
04:30:59 <integral> okay, must not be a :set thing.  I've only used it on the cmdline myself, like I said.
04:31:32 * Phyx- shoots himself
04:31:50 <ibid> jeroen_p: how does one get toString by instantiating ParseAble?
04:32:14 <integral> Phyx-: I see the problem! you need no space after the -i, eg: :set -ic:\downloads\
04:32:17 <jeroen_p> it's in the ParseAble-class
04:32:29 <jeroen_p> I won't copy the function, it's a bit long
04:33:00 <Phyx-> integral: ohh works. thanx
04:33:16 <Phyx-> now to start working and get real haskel errors :)
04:36:42 <jeroen_p> ibid: can you see my problem?
04:36:50 <ibid> jeroen_p: no, not really
04:37:28 <ibid> jeroen_p: hrm, ok, i think i do now
04:37:32 <jeroen_p> Okey
04:37:34 <ibid> (reviewed the backlog)
04:38:33 <ibid> jeroen_p: how about ParseAble a, ParseAble a => ParseAbleXHTML a, ParseAble a => ParseAbleOtherFormat a?
04:38:52 <ibid> ParseAble not containing toString
04:39:09 <ibid> or it can, actually
04:39:17 <jeroen_p> That sounds decent
04:39:39 <jeroen_p> I think I misfigured the whole thing in my head, thanks for setting it straight :)
04:40:02 <ibid> the only problem i can see with that is if toString has to have a different signature in the two subclasses; in that case using two different names might make more sense
04:42:33 <jeroen_p> Is it possible to make haskell forget there was a toString in parseable if an element is of ParseAbleXHTML, forcing it to take ParseAbleXHTML's toString ?
04:43:00 <ibid> huh?
04:44:20 <ibid> that's kinda what the class system does by default, if i understand you correctly
04:44:48 <jeroen_p> What did I say then :) ?
04:45:24 <ibid> ??
04:45:24 <lambdabot> Not enough arguments to @.
04:45:32 <ibid> lambdabot: not you!
04:45:39 <Maddas> @yow
04:45:39 <lambdabot> Used staples are good with SOY SAUCE!
04:47:40 <jeroen_p> So if I were to have class A with function f, and class A a => B with function f, that would be ok?
04:48:00 <xerox> Haha.
04:48:20 <xerox> ?. vixen . state arr
04:48:21 <lambdabot> i find it hard to masturbate when the lights are on.
04:48:23 <xerox> @state
04:48:24 <lambdabot> Shiver me timbers!
04:50:04 <ibid> jeroen_p: the subclass can "re"define it, but the type signature must stay the same
04:51:25 <jeroen_p> Okey
04:51:27 <jeroen_p> Thanks
04:53:29 <jeroen_p> One small thing ibid, what is your opion on one-character variables?
04:54:39 <dons> they're great!1
04:55:16 <dons> $ pwd
04:55:17 <dons> /home/dons/lambdabot
04:55:17 <dons> $ grep ' . ' *.hs */*.hs */*/*.hs | wc -l
04:55:34 <ibid> jeroen_p: that's like asking me my opinion on hammers
04:55:40 <ibid> +for
04:55:53 <dons>    11714 ;)  
04:56:58 <jeroen_p> I don't know you opinion on hammers either
04:57:20 <dons> single char variables are very common in Haskell code
04:58:24 <ndm> my variables are all single letters
04:58:38 <ndm> with the exception of lists, which are usually single letter then an s
04:59:09 <ndm> functions start at f, numbers at n/m, lists at x:xs, others at a
05:01:33 <ibid> jeroen_p: they are a tool. use them wisely
05:01:40 <dons> type varistart either at t or a
05:01:44 <dons> variables
05:01:45 <ibid> jeroen_p: applies to both hammers and one-character variables
05:01:51 <jeroen_p> Good, good
05:01:53 <ibid> hrm, "they are tools", rather
05:01:55 <Saulzar> I use names unless they're fairly meaningless when one-character variables are ok
05:02:43 <dons> anyway, you should use pointfree style if making up pointless names ;)
05:02:46 <jeroen_p> I like to use one-character variables untill it's harder to come up with an unused character than a new word
05:03:09 <dons> speaking of which, anyone played with the offline mode of lambdabot yet?
05:03:17 <davidhouse> dons!
05:03:41 <davidhouse> dons, does lambdabot have an interface to GHCi's :info?
05:03:51 <dons> davidhouse!!
05:03:58 <dons> nope
05:03:58 <Saulzar> For something like fac then n is very clear, but a function taking 10 arguments of different types then a b c d e f g h i j are not very informative
05:04:06 <davidhouse> dons, should it have?
05:04:08 <dons> it was too verbose, so we disabled it
05:04:09 <dons> ihope talked about this yesterday
05:04:22 <dons> it could hve one, if you can make it a bit less noisy
05:04:23 <davidhouse> yes, ihope did mention it.
05:04:25 <davidhouse> two verbose?
05:04:26 <davidhouse> too
05:04:37 <dons> it should go into the Type plugin, btw
05:04:51 <dons> if you're hacking lambdabot you'll like today's patches
05:04:57 <dons> offline mode, and static builds by default
05:05:05 <dons> much easier to test  plugins
05:05:17 <dons> also, vim support for pointfree refactoring!
05:05:19 <ibid> jeroen_p: a good rule of thumb is, the length of a variable is proportional to the size of its scope, and inversely proportional to the number of its lexical uses
05:05:24 <dons> go nuts!
05:05:28 <Saulzar> dons, by the way - yesterday at least 4 times lambdabot triggered on people typing in \foo ->  expressions
05:05:46 <dons> ah. ok.
05:05:47 <davidhouse> \foo -> foo + bar
05:05:47 <lambdabot> Maybe you meant: faq todo yow
05:05:55 <dons> 4 times eh?
05:06:02 <Saulzar> At least :)
05:06:05 <dons> so I should disable that char.
05:06:11 <dons> but ti's so pretty
05:06:22 <dons> fixing...
05:07:46 <dons> anyway, I suggest you all grabb lambdabot and try out the offline mode. if anything it'll propogate pointfree style to the masses
05:07:53 <dons> ?version
05:07:53 <lambdabot> lambdabot 3p330, GHC 6.4.1 (Linux i686 3.20GHz)
05:07:53 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
05:08:54 <Saulzar> Will do, @pl is very handy :)
05:09:30 <dons> and emacs binding to lambdabot would be really welcome, if anyone knows how to do that...
05:10:00 <dons> currently I have a vim binding to @type and @pl
05:10:04 <vincenz> que pasa
05:10:23 <neologism> dons: what is "pointfree style" ?
05:10:28 <vincenz> dons: ooh cocol
05:10:32 <dons> \wiki Pointfree
05:10:32 <lambdabot> http://www.haskell.org/haskellwiki/Pointfree
05:10:41 <vincenz> also known as Pointless
05:10:56 * vincenz waits for the coin to drop
05:11:05 <vincenz> hp
05:11:27 <neologism> ah
05:11:28 <neologism> thnx
05:11:41 <sili_> vincenz: evil
05:11:55 <dons> not so evil when you have editor/lambdabot support
05:12:56 <dons> @quit a new bot age is dawning..
05:13:21 <vincenz> dons: why this pervasive pointlessness
05:13:26 <dons> oh right, I have to say --online now.
05:13:29 * vincenz coughs
05:13:32 <vincenz> pointfreeness
05:13:32 <dons> it's fun!
05:13:35 <shapr> A new age?
05:13:48 <shapr> dons: Is lambdabot part of Yi now?
05:13:56 <vincenz> shapr: lambdabot can go offline and explore new territory... Be afraid, be VERY AFRAID - MUHAHAHAHHA
05:14:11 <shapr> awsome
05:14:56 <neologism> why lambdabot quit?
05:15:13 <vincenz> he went off exploring
05:15:19 <neologism> ah :)
05:15:21 <dons> $ ./lambdabot 
05:15:21 <dons> lambdabot> version
05:15:21 <dons> lambdabot 3p344, GHC 6.4.1 (OpenBSD i386 )
05:15:21 <dons> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
05:15:21 <dons> lambdabot> pl f x y = map f (y ++ "foo!")
05:15:24 <dons> f = fix (const . (. (++ "foo!")) . map)
05:15:26 <dons> lambdabot> quit
05:15:29 <dons> :)
05:15:31 <dons> with vim support.
05:15:35 <dons> and emacs if someone hacks it up...
05:15:46 <xerox> @karma+ dons -- WOAH
05:15:52 <lambdabot> dons's karma raised to 24.
05:16:01 <vincenz> @karma+ dons
05:16:02 <lambdabot> dons's karma raised to 25.
05:16:17 <dons> \lambda test for Saulzar
05:16:26 <neologism> ?version
05:16:26 <lambdabot> lambdabot 3p347, GHC 6.4.1 (Linux i686 3.20GHz)
05:16:26 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
05:16:29 <dons> ?bot yourself up!
05:16:30 <lambdabot> :)
05:16:31 <neologism> ah.. an upgrade
05:16:38 <xerox> ,arr
05:16:40 <shapr> @karma+ dons
05:16:40 <lambdabot> dons's karma raised to 26.
05:16:48 <xerox> Karmafest!!!
05:17:14 <dons> yeah, so if someone knows emacs enough to call an external program, and feed it the current line, taking the result back, that's a perfect way to bind to lambdabot
05:17:24 <shapr> yeah, I can do that.
05:17:26 <dons> check out lambdabot/scripts/vim/ for ideas
05:17:29 <xerox> Sure, comint mode.
05:17:52 <shapr> xerox: So, you think haskell-mode needs keybindings for the lambdabot commands?
05:18:15 <xerox> INDEED.
05:18:24 <neologism> someone shuold hack vim to see that \(x y) -> x does matches brackets
05:18:28 <xerox> lambdabot-pl-region
05:18:29 <vincenz> yeah
05:18:31 <vincenz> neologism: I agree
05:18:39 <dons> ah yeah, neologism, that bugs me too
05:18:39 <xerox> lambdabot-hoogle
05:18:45 <shapr> neologism: same in emacs
05:18:53 <shapr> Though I think fixed in haskell-mode 2.1
05:19:00 <neologism> so. who's volunteering? ;)
05:19:01 <Phyx-> anyone have a precompild lambdabot ? :p
05:19:14 <vincenz> Phyx-: you don't have a haskell compiler?
05:19:32 <vincenz> damn, download is severely slow
05:19:37 <vincenz> I guess everyone is getting
05:19:46 <dons> in fact, a couple of lines of shell would bind most commands properly:
05:19:47 <Phyx-> vincenz: yes, but could never get it to work under windows :|
05:19:47 <dons> lambdabot> djinn a -> b -> (a,b)
05:19:48 <Phyx-> bombs
05:19:48 <dons> f a b = (a, b)
05:20:07 <Saulzar> Hmm, where is System.Console.Shell from?
05:20:41 <dons> in vim would just take "a -> b -> (a,b)" from the current regoin, and then return the 'f a b' result  
05:20:47 <dons> Saulzar, you shouldn't need it. 
05:21:06 <dons> is your repo old?
05:21:13 <Saulzar> Oh, doh... 
05:21:17 <Saulzar> lambdabot_0
05:21:26 <dons> make sure to 'distclean' too.
05:21:28 <dons> ah yes :)
05:21:28 <vincenz> Copying patch 115 of 815...
05:21:38 <dons> --partial !!
05:21:40 <Phyx-> vincenz: ever got it to work under windows?
05:21:41 <vincenz> ah those were the slow ones.... going bfaster now
05:21:47 <vincenz> Phyx-: I don't use windows
05:21:55 <Phyx-> :|
05:22:07 <dons> it has been known to rwork on windows
05:22:07 <dons> I think..
05:22:08 <Phyx-> well, i get a memory violation error
05:22:15 <dons> cool :)
05:22:15 <Phyx-> when i try doing the commands in the readme
05:23:47 <dons> also, hs-pllugins is optional now. I'll update the readme
05:37:28 <dons> night guys! happy haskell hacking :)
05:37:43 <ndm> night dons
05:39:04 <Phyx-> grrrr, i did :set +s
05:39:08 <Phyx-> now do i turn it off now?
05:52:30 <ndm> Phyx-: :set -s
05:56:13 <dons> oh, ndm, btw, this means lambdabot provides a hoogle command line : 
05:56:14 <dons> dons@shodan:~/n/lambdabot$ ./lambdabot 
05:56:14 <dons> Loading plugins ................................ done.
05:56:14 <dons> lambdabot> hoogle (a -> b) -> [a] -> [b]
05:56:14 <dons> Data.List.map :: (a -> b) -> [a] -> [b]
05:56:16 <dons> Prelude.map :: (a -> b) -> [a] -> [b]
05:56:40 <ndm> dons, cool
05:56:51 <ndm> does it require a hoogle binary on the users system to work?
05:57:13 <dons> yep
05:57:28 <dons> unless I move hoogle into the lambdabot scripts/ dir as I have for djinn and runplugs
05:57:38 <dons> (i.e. as a sub-repo)
05:57:49 <ndm> your choice, i hope to get a hoogle binary ready soon enough anyway
05:57:58 <ndm> with all the required fixes in it
05:58:00 <sieni> what's the status of multithreading support in ghc? is there a web page on the subject?
05:58:14 <Phyx-> ndm: that gives me unrecognized flag error
05:58:21 <Phyx-> i just restarted it :|
05:58:39 <ndm> dons, if you make it a sub-repo, will the central updates be propagated to it?
05:58:51 <dons> when I pull them, yes
05:59:32 <ndm> do you pull, then record in the lamdabot repo?
05:59:45 <ndm> we were trying to get this kind of thing going for Yhc, since it depends on cpphs
05:59:54 <ndm> but it wasn't particularly well supported in darcs...
06:00:08 <dons> you pull, but the patches are already recorded
06:00:20 <dons> ah, no , you do record 
06:00:36 <ndm> if you want to do that, feel free
06:00:38 <dons> but you don't place the _darcs repo under your darcs control
06:00:44 <dons> ok. cool.
06:00:54 <dons> it has worked well when pulling the djinn repo from lennart
06:01:07 <dons> and saves on dependencies -- most plugins then "just work"
06:01:50 <ndm> neat, then thats probably a better idea
06:02:26 <ndm> if you need any changes in the repo to make it easiser, just send patches over
06:02:59 <dons> yeah, if lambdabot is going to be more widely used as some kind of devel tool, it has to have hoogle working out of the box, I think. i'll let you know how i proceed on this.
06:03:37 <ndm> cool, i agree - hoogle is a painful dependancy for the moment
06:03:49 <ndm> since i don't even have hoogle installed as a command line tool on my system...
06:04:02 <Phyx-> http://pastebin.com/623173 <-- i keep getting parse error on input if
06:04:04 <dons> I just updated the Hoogle wiki page to mentoin the lambdabot command line version.
06:05:00 <ndm> cheers
06:05:08 <ndm> Phyx-: your indentation is wrong
06:05:24 <ndm> wrong in what way depends on what you wanted to do
06:05:44 <Phyx-> hmm, well, i want to validate the input before continue to ask for more
06:06:33 <Phyx-> ndm: should i push it in more?
06:07:28 <Phyx-> ok, compiled
06:12:19 <dcoutts> dons, I've got access to a mips machine with 16 x R10K/250MHz & 8GB ram :-)
06:12:31 <dcoutts> dons, this is to build & test ghc on mips linux
06:12:55 <dons> 16 x !
06:12:59 <ndm> @pl \a b -> return (f a b)
06:13:00 <lambdabot> (return .) . f
06:13:00 <vincenz> 8 G ram
06:13:01 <vincenz> nice
06:13:07 <dons> ok, so make -jN would be fun...
06:13:14 <dcoutts> dons, yeah :-)
06:13:20 <dons> i'd love to see the lambdabot @version on that machine :)
06:13:31 <vincenz> \version
06:13:32 <dcoutts> dons, it might actually build quicker than on my amd64
06:14:08 <ndm> @version
06:14:08 <lambdabot> lambdabot 3p347, GHC 6.4.1 (Linux i686 3.20GHz)
06:14:08 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
06:15:05 <jeroen_p> ibid, now I know why I had that weird problem about an hour ago
06:15:08 <dons> I don't know if ghc has ever run on a 16x box before
06:15:13 <dons> I've not heard of it.
06:15:27 <dons> i've certainly used it on a quad P4 and a quad itanium 1 machine
06:15:40 <dons> and a dual mips64
06:15:57 <dcoutts> I've used it on a dual iataium 2
06:16:04 <dons> I wonder what the smp work at cambridge has used.
06:16:12 <dcoutts> still takes 2 hours to build on that one
06:16:24 <dons> yeah, ia64 aint much fun
06:16:28 <dcoutts> the new mult-core sparc machines would be nice for that
06:16:44 <dons> @quote JaffaCake
06:16:45 <lambdabot>  not all IOError -> String functions are created equal :)
06:17:05 <dons> @quote JaffaCake
06:17:06 <lambdabot>  not all IOError -> String functions are created equal :)
06:17:07 <dcoutts> I think JaffaCake was using a dual or multi-core amd64 for their smp work
06:17:15 <dons> @quote JaffaCake
06:17:16 <lambdabot>  I'm afraid I'm completely IA64-ignorant (and hoping to remain that way until IA64 goes away :-)
06:17:19 <dons> that one
06:17:22 <dcoutts> hah, yeah
06:17:26 <dons> ah yes. amd64
06:19:11 * Phyx- loves it when haskell code just works :D
06:19:15 <dcoutts> dons, do you know Matthew Chapman (at cse.unsw) ?
06:19:35 <dcoutts> dons, he's the ia64 ghc expert
06:19:58 <snk_kid> erm, where does haddock (run through a cabal package) place generated docs by default?
06:20:06 <dons> yes. I know him well :)
06:20:22 <dons> we did the same AFP class, when he decided to port ghc to ia64
06:20:27 <dons> oh, he taught me perl too :)
06:20:32 <dcoutts> dons, nice
06:20:49 <dcoutts> I'd hear rumours that our ia64 ghc expert was missing in action
06:21:07 <dons> I don't know if he does much haskell these days
06:21:07 <dcoutts> but it's not true, he got back to me quickly with answers
06:21:15 <dons> matt did?
06:21:19 <dcoutts> yes
06:21:26 <dcoutts> for my mangler question
06:21:30 <dons> cool!1
06:21:35 <dcoutts> see ghc-bugs
06:22:09 <dons> i'm surprised actually. he's moved out of the fp circles a bit, i'd thought
06:22:23 <dons> and the ia64 i worked on (part of his group's stuff) has disappeared
06:22:44 <dons> he's still here working on ihis phd though,  I think.
06:24:19 <dcoutts> well he knew excatly what was going wrong
06:24:31 <dcoutts> and exmplained the behaviour I was seeing
06:24:40 <dcoutts> > So that explains why it didn't work when I merely relaxed the regexp in
06:24:40 <dcoutts> > the mangler.
06:24:40 <dcoutts> Yep, the "Illegal instruction" you get is exactly because it's accessing
06:24:40 <dcoutts> past the end of the allocated register window, and that particular fault
06:24:40 <dcoutts> is mapped by Linux to "Illegal instruction".
06:24:41 <lambdabot>  parse error on input `in'
06:24:41 <lambdabot>  parse error on input `}'
06:24:59 <dcoutts> which was enlightening
06:25:07 <dons> ah
06:25:18 <dons> he knows his linux and his ia64 stuff
06:25:24 <dons> he did the ghci port (!)
06:25:29 <Phyx-> uhm, what does this mean? lexical error in string/character literal
06:25:47 <dons> probably a funny \ or ' in a string
06:25:51 <dcoutts> dons, ghci works on ia64? I'll have to try building with that enabled
06:26:00 <dons> > "\"
06:26:00 <lambdabot>  lexical error in string/character literal
06:26:03 <dons> it does, yes.
06:26:15 <Phyx-> dons: again... if i can't use "\" to describe paths, how do i open a file then?
06:26:17 <dons> only the natiive code gen is missing, afaik
06:26:28 <dons> you can use \
06:26:29 <dons> but you have to escape it
06:26:29 <dcoutts> yes
06:26:54 <dons> > "\\"
06:26:55 <lambdabot> "\\"
06:27:04 <Phyx-> ok
06:27:13 <dons> > "a" ++ "\\" ++"b"
06:27:14 <lambdabot> "a\\b"
06:27:31 <dons> ok, really night now. bye!
06:27:37 <dcoutts> g'night dons 
06:27:41 <Phyx-> dons: one sec
06:27:44 <Phyx-> before you g
06:27:51 <Phyx-> any function to get the current working dir?
06:27:58 <Phyx-> does haskell have pwd? :P
06:28:10 <ndm> @hoogle current
06:28:10 <lambdabot> Distribution.Simple.Utils.currentDir :: FilePath
06:28:10 <lambdabot> Graphics.UI.GLUT.Window.currentWindow :: StateVar (Maybe Window)
06:28:10 <lambdabot> Graphics.Rendering.OpenGL.GL.CoordTrans.currentMatrix :: (Matrix m, MatrixComponent c) => StateVar (m c)
06:28:19 <ndm> @hoogle+
06:28:19 <lambdabot> Graphics.Rendering.OpenGL.GL.PerFragment.currentQuery :: QueryTarget -> GettableStateVar (Maybe QueryObject)
06:28:19 <lambdabot> Graphics.Rendering.OpenGL.GL.RasterPos.currentRasterPosition :: StateVar (Vertex4 GLfloat)
06:28:19 <lambdabot> Graphics.Rendering.OpenGL.GL.RasterPos.currentRasterDistance :: GettableStateVar GLfloat
06:28:22 <ndm> @hoogle+
06:28:22 <lambdabot> Graphics.Rendering.OpenGL.GL.RasterPos.currentRasterColor :: GettableStateVar (Color4 GLfloat)
06:28:22 <lambdabot> Graphics.Rendering.OpenGL.GL.RasterPos.currentRasterIndex :: GettableStateVar (Index1 GLint)
06:28:22 <lambdabot> Graphics.Rendering.OpenGL.GL.RasterPos.currentRasterTexCoords :: GettableStateVar (TexCoord4 GLfloat)
06:28:24 <ndm> @hoogle+
06:28:24 <lambdabot> Graphics.Rendering.OpenGL.GL.RasterPos.currentRasterPositionValid :: GettableStateVar Bool
06:28:25 <lambdabot> Graphics.Rendering.OpenGL.GL.SavingState.CurrentAttributes :: ServerAttributeGroup
06:28:27 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Environments.CurrentUnit :: Src
06:28:33 <Phyx-> ok, thanx
06:28:39 <dons> @hoogle CurrentDirectory
06:28:40 <lambdabot> System.Directory.getCurrentDirectory :: IO FilePath
06:28:40 <lambdabot> System.Directory.setCurrentDirectory :: FilePath -> IO ()
06:28:49 <ndm> and thats why i built the standard hoogle without OpenGL...
06:28:59 <dons> :S
06:29:27 <Saulzar> Hehe, cool. Now I know that lambdabot has OpenGL ... :)
06:29:31 <dcoutts> ndm, yes, it does want to be optional, ho hum, more work
06:29:58 <ndm> dcoutts, i know - no time for the moment, PhD stuff to do...
06:30:02 <Phyx-> cool, and how do i use that?
06:30:29 <Phyx-> lost me at the hoogle thing
06:30:33 <waern> why not just some filtering options to the hoogle query?
06:31:09 <waern> that are persistant, and you can enable/disable them
06:32:05 <ndm> waern: yes, thats the plan - i just haven't had time to write it
06:32:22 <waern> aha :)
06:33:54 <Phyx-> @map
06:33:55 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
06:34:06 <Phyx-> hmm forgot how to use lambdabot
06:34:12 <Phyx-> @type map
06:34:13 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
06:34:13 <snk_kid> does anyone know where haddock places generated docs by default?
06:34:17 <Phyx-> there we go
06:34:26 <Phyx-> @type getCurrentDirectory
06:34:27 <lambdabot> Not in scope: `getCurrentDirectory'
06:38:46 <shapr> dons: d-bus integration is the next step.
06:42:11 <dcoutts> shapr, dons, anyone want to do a dbus binding? it'd be a great contribution to the gnomey side of gtk2hs
06:42:47 <dcoutts> we never did the bonobo / orbit / corba bits since it's so ugly, but dbus is much lighter and even has a nice type system
06:50:43 <Phyx-> what does parse error on input `<-' mean?
06:51:24 <shapr> dcoutts: and useful/necessary for 770 apps.
06:51:34 <dcoutts> shapr, oh right
06:51:42 <TuringTest> 770 ?  is that a count?
06:53:35 * Beelsebob wonders how the hell you use the FFI
06:53:46 <dcoutts> Beelsebob, c2hs!
06:53:53 <Phyx-> hello?
06:54:08 <Beelsebob> dcoutts: will that produce a nice simple output I can try and get Hat working with?
06:54:18 <Beelsebob> Phyx-: it means you probably haven't closed enough bracketss
06:54:23 <TuringTest> dcoutts: I cannot convince c2hs to compile using Cabal
06:54:26 <Beelsebob> ... or <- shouldn't appear at that place in the program
06:54:28 <shapr> TuringTest: nokia 770
06:54:32 <Phyx-> Beelsebob: i have none
06:54:36 <dcoutts> Beelsebob, it produces ordinary .hs files
06:54:44 <TuringTest> shapr: That makes more sense, thanks
06:54:45 <Beelsebob> dcoutts: nice simple ones?
06:54:56 <Beelsebob> Phyx-: paste bin your code and the error
06:54:59 <dcoutts> Beelsebob, it doesn't generate too much gubbins
06:55:03 <Phyx-> one sec
06:55:21 <dcoutts> TuringTest, which version of c2hs and which version of cabal? it works in the versions used in the gentoo ebuild
06:55:58 <beelsebob_> @where c2hs
06:55:59 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
06:56:28 <TuringTest> dcoutts: c2hs 0.14.5 and Cabal 1.0 or Cabal 1.1.4
06:56:45 <dcoutts> TuringTest, so I was using 0.14.5 and Cabal 1.1.3
06:56:55 <TuringTest> hmmm....
06:57:44 <Beelsebob> hmm... darcs is being a spak today
06:57:56 <Beelsebob> ... or the server is being sslower than a slow thing
06:59:04 <TuringTest> dcoutts: I'll try 1.1.3
07:00:29 <Beelsebob> dcoutts: configure.in:32: warning AC_CANONICAL_HOST invoked multiple times
07:00:29 <Beelsebob> autoconf/specific.m4:363: AC_CYGWIN is expanded from...
07:00:29 <Beelsebob> configure.in:32: at top level
07:00:43 <Beelsebob> OS X, darcs c2hs
07:01:30 <dcoutts> Beelsebob, doesn't mean much to me, you can report it to the c2hs list
07:01:37 <dcoutts> it's not fatal is it?
07:02:13 <shapr> dcoutts: Does d-bus already have some Haskell integration? Maybe I'm just confused about stuff like Address -> [Bus Name] -> Path -> Interface -> Method 
07:02:42 <dcoutts> shapr, I don't think there has been any work on Haskell / dbus yet
07:03:02 <Beelsebob> dcoutts: yes, it's fatal
07:03:14 <shapr> ah, ok.
07:03:35 <dcoutts> Beelsebob, oh. try the relesed version, they you won't have to run autoreconf
07:03:39 <dcoutts> they/then
07:03:47 <dcoutts> Beelsebob, what versions of autotools btw?
07:03:48 <Beelsebob> ah, okay
07:04:19 <Beelsebob> GNU autoconf 2.59
07:05:35 * Beelsebob pokes ndm with a stick
07:06:16 <dcoutts> Beelsebob, and automake?
07:06:35 <Beelsebob> 1.6.3
07:07:24 * TuringTest builds Cabal 1.1.3 which leads to c2hs which leads to WaSH
07:07:29 * ndm hits Beelsebob
07:07:34 <dcoutts> Beelsebob, that seems a little old
07:07:47 <dcoutts> Beelsebob, I'd try a released version or a later automake
07:07:54 <Beelsebob> tatd2$ ./Setup.hs configure
07:07:54 <Beelsebob> *** Exception: Line 21: Unknown field 'hs-source-dirs'
07:08:02 <Beelsebob> (from the released version)
07:08:24 <Beelsebob> ndm: is yhc able to build it's self, yes?
07:08:36 <ndm> beelsebob, no, but its not far off
07:08:37 * Phyx- throws a chair
07:08:47 <ndm> i could do it in about a day - if i ever get a spare day...
07:08:54 <Beelsebob> ndm: damn... means I can't have a haskell compiler on my iPod... yet
07:09:07 <ndm> beelsebob, did you port Yhi?
07:09:18 <Beelsebob> ndm: not yet... but I will
07:09:27 <Beelsebob> I need to get gcc working first
07:09:32 <ndm> well do that, give me a few weeks, and you'll have Yhc working
07:09:37 <TuringTest> Phyx-: more syntax errors?
07:09:37 <ndm> does it come with any C compiler?
07:09:44 <Beelsebob> and gcc on an ARM 9 with 64MB of ram is evil
07:09:59 <Beelsebob> ndm: no... but I'm making it...
07:10:07 <ndm> beelsebob, how?
07:10:14 <ndm> cross-compiling?
07:10:14 <Phyx-> TuringTest: parse errors. but seems perfectly fine 2 me.
07:10:15 <Beelsebob> I'm getting gcc up and running on it
07:10:19 <Beelsebob> yes, for the moment
07:10:25 <Beelsebob> I have an arm compiler here
07:10:27 <ndm> neato
07:10:35 <Beelsebob> indeed
07:10:37 <ndm> Yhi doesn't require gcc at all
07:10:48 <Beelsebob> just *a* C compiler
07:10:54 <Beelsebob> so I could cross compile it
07:10:54 <ndm> yep
07:11:00 <Beelsebob> but that's no fun
07:11:14 <ndm> only Yhi, then you can compile Haskell code on it still
07:11:20 <Beelsebob> gotta do it the hard way if I'm doing something as stupid as triyng to put a haskell compiler on an iPod
07:11:23 <neologism> is there any other usable oss C compiler beside gcc?
07:11:54 <Beelsebob> can't think of any other OSS ones
07:12:00 <Beelsebob> plenty of closed ones
07:13:54 <neologism> ther'es tendra
07:14:02 <neologism> but I dont htink its too usable
07:15:22 <ihope> Now *this* is #haskell.
07:15:24 <ihope> @type .
07:15:25 <lambdabot> parse error on input `.'
07:15:39 <ihope> As you can all see, that didn't work. /me bows
07:15:41 <Beelsebob> so... how do I write a *really* simple FFI program that just calls a C function... without using c2hs seeing as it's being a bitch
07:15:56 <Beelsebob> @type (.)
07:15:57 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
07:15:58 <TuringTest> ./c2hs chrisk$ ./Setup.hsbuild Preprocessing executables for c2hs-0.14.5...
07:15:58 <TuringTest> Setup.hs: got error code while preprocessing: CLexer
07:16:11 <TuringTest> c2hs won't build for me with Cabal 1.1.3
07:16:16 <TuringTest> dcoutts: Any ideas?
07:16:16 <Beelsebob> TuringTest: looks like you're getting farther than me
07:16:25 <shapr> ihope: Are you demonstrating to someone?
07:16:33 <dcoutts> TuringTest, hmm
07:16:45 <ihope> shapr: something like that
07:16:48 <TuringTest> (Running ghc 6.4.1 on OS X)
07:17:06 <Beelsebob> TuringTest: ohhh... why do you get a different one from me?
07:17:35 <jeroen_p> I've got this silly newbish problem. class A required f and gives you g. Now I have class B which requires your type to be of class A, and gives you h. How do I instantiate something of class B?
07:17:36 <TuringTest> I got c2hs via darcs get --partial http://www.cse.unsw.edu.au/~chak/repos/c2hs/
07:17:44 <TuringTest> I got Cabal via the 1.1.3 tarball
07:18:25 <dcoutts> TuringTest, use ./setup build -v so we can see where it's failing
07:18:30 <Beelsebob> TuringTest: you got autoconf to work?
07:18:30 <TuringTest> ok
07:19:10 <dcoutts> TuringTest, you've got alex installed right?
07:19:18 <TuringTest> it may be that...hang on
07:19:48 <beelsebob_> @where alex
07:19:49 <lambdabot> http://www.haskell.org/alex/
07:19:58 <dcoutts> TuringTest, it'd be easier if you used the released versionm, then you wouldn't need alex or happy
07:20:03 <TuringTest> Yeah.. -v helped pinpoint alex.  I pointed it to the wrong thing
07:22:18 <dcoutts> swiert, how's the epigram gui going now?
07:24:04 * TuringTest plays with calling  autoconf, configure, and Setup.hs  to convince c2hs to compile
07:24:41 <Beelsebob> TuringTest: if you get a sequence that works, tell me
07:24:49 <TuringTest> Beelsebob: I am making progres..what is your error message ?
07:24:56 <Beelsebob> autoconf: fuck off
07:25:09 <TuringTest> Beelsebob: is there a ./configure file yet?
07:25:33 <Beelsebob> ohh... yes
07:25:37 * Beelsebob runs it just for fun
07:25:53 <TuringTest> Try ./configure --prefix=/foo/bar then Setup.hs 
07:26:09 <TuringTest> That is working for me so far
07:26:21 <Beelsebob> *** Exception: Line 21: Unknown field 'hs-source-dirs'
07:26:38 <TuringTest> I have not seen that error before.
07:26:47 <TuringTest> Which Cabal do you have ?
07:27:04 <Beelsebob> 1.0
07:27:18 <TuringTest> I *know* c2hs says Cabal-1.0 will not work
07:27:23 <Beelsebob> oh, okay
07:27:24 <TuringTest> I just installed 1.1.3 
07:27:29 <Beelsebob> @where cabal
07:27:30 <lambdabot> http://www.haskell.org/cabal
07:28:47 <dcoutts> see, you guys should use gentoo then it'd all "Just Work"tm
07:29:16 <dcoutts> (we're currently working on ghc support for Gentoo/OSX)
07:30:01 <Beelsebob> argh!
07:30:08 <TuringTest> I have tried fink, darwin ports, and Gentoo/OSX.  I have kept fink and darwin ports.
07:30:10 <Beelsebob> the cabal build system relies on ghc being in /usr/bin/ghc
07:30:11 <TuringTest> Beelsebob: ?
07:30:16 <TuringTest> oh
07:30:18 <Beelsebob> ... which it isn't
07:30:25 <TuringTest> make HCBASE=/usr/local/bin/
07:30:36 <TuringTest> (learned by reading GNUMakefile)
07:30:52 <Beelsebob> ahh, useful
07:30:58 <dcoutts> TuringTest, yeah, I think Gentoo/OSX started out rather shakily
07:31:00 * TuringTest reports that c2hs compiled
07:31:26 <dcoutts> TuringTest, how many haskell packages does DP offer?
07:31:37 <dcoutts> lots or just ghc ?
07:31:41 <TuringTest> 3135 packages
07:31:47 <TuringTest> oh haskell...wait
07:32:03 <Beelsebob> very few iirc
07:32:07 <Beelsebob> just ghc basically
07:32:13 <TuringTest> It offers c2hs  0.13.6 . . .
07:32:14 <dcoutts> right
07:32:35 <TuringTest> It offer alex and happy (which I am using)
07:32:42 <TuringTest> hs=plugins
07:32:46 <dcoutts> well I'll tell you when Gentoo/OSX supports all the ones we support on Linux
07:32:56 <TuringTest> ok
07:33:28 <dcoutts> it shouldn't be that hard since we support all 30+ packages on linux ppc
07:33:54 <TuringTest> Beelsebob: I got c2hs working
07:34:07 <Beelsebob> TuringTest: cool... I'm still working on having a new cabal
07:36:25 <Beelsebob> ohhh... configure may be doing something now
07:36:40 <Beelsebob> building....
07:37:37 <Beelsebob> @where c2hs
07:37:37 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
07:37:52 <Phyx-> ok, can anyone help me with this? i'm stumped. http://pastebin.com/623308 parse error on input `<-'
07:38:34 <mauke> ENODO
07:39:25 <Saulzar> Phyx-, Which line is the error?
07:39:34 <Phyx-> 22
07:39:43 <mauke> missing do
07:39:52 <Beelsebob> work / do xdata <-
07:39:56 <Beelsebob> =*
07:39:59 <Saulzar> Phyx-, You have rather a big function there, might be easier to deal with if you chop it up
07:40:18 <Phyx-> Beelsebob: ?
07:40:33 <mauke> valid x = isValid x && maandnum x >= 1 && maandnum <= 12
07:40:33 <Beelsebob> Phyx-: work = do xdata <- laadAgenda .....
07:40:44 <Phyx-> ohh the do
07:41:22 <TuringTest> I just saw it too
07:41:33 <Beelsebob> Phyx-: what's this program ssupposed to do?
07:41:39 <Saulzar> Also, you don't need a do for the last 3 cases (eg. do putStrLn ...)
07:42:31 <Saulzar> (As it doesn't require any of the do syntax)
07:42:59 <Phyx-> now i get scope errors, but i can fix that myself. thanx
07:45:32 <swiert> dcoutts: Little development on epigram lately.
07:46:06 <swiert> dcoutts: Joel's been a bit ill and Conor's been busy rewriting a paper.
07:46:59 <dcoutts> swiert, right
07:47:04 <Beelsebob> Phyx-: http://pastebin.com/623321
07:47:22 <Beelsebob> sure it could be made neater still
07:47:59 <ndm_> and $ map
07:48:02 <ndm_> is equivalent to all
07:48:09 <Beelsebob> true indeed
07:48:31 <Phyx-> Beelsebob: heheh, thanx
07:48:31 <Beelsebob> ... http://pastebin.com/623324
07:49:23 <Phyx-> well, i'll get it completely finished first, then make it neater :)
07:49:39 <Beelsebob> Phyx-: in general - use the IO monad for as little as possible
07:49:47 <Beelsebob> get the data you need and pass it off into pure functions
07:51:24 <liyang> hey swiert 
07:52:09 <TuringTest> General haskell idiom question:  In (C++ / gtk / qt) there is a signal/slot style of programming.  Is there a similar idiom in Haskell programming?
07:52:40 <Beelsebob> TuringTest: pass a callback function as the signal handler?
07:53:20 <Phyx-> Beelsebob: ok
07:53:50 <Saulzar> Hmm, at least in gtk2hs it's done by passing an IO action (or function to IO action)
07:54:20 <Saulzar> onClicked button $ putStrLn "foobar"
08:00:35 <Phyx-> ok, now i get http://pastebin.com/623324
08:00:38 <Phyx-> a warning
08:00:55 <Saulzar> So it's very similar for IO events
08:02:00 <Phyx-> Beelsebob: know why i get that error?
08:02:23 <Beelsebob> Philippa: what error?
08:02:27 <Saulzar> Phyx-, What is the warning? I have no esp :)
08:02:32 <Phyx-> hehhe, 
08:02:36 <Phyx-> ok, now i get http://pastebin.com/623324
08:02:38 <Beelsebob> Phyx-: even
08:02:41 <Phyx-> i pasted it :)
08:02:47 <Beelsebob> no error there
08:02:49 <Beelsebob> just code
08:02:59 <Beelsebob> what I pasted
08:03:12 <Phyx-> th top 3 lines
08:03:20 <Phyx-> has a warning
08:03:21 <Beelsebob> webuitvoer :: IO()
08:03:21 <Beelsebob> webuitvoer =
08:03:21 <Beelsebob>   do putStrLn "Agendanaam?"
08:03:29 <Beelsebob> that's the top three lines
08:03:40 <Phyx-> no it's not...
08:03:44 <Beelsebob> yes it is...
08:03:45 <mauke> yes, it is
08:03:53 <Phyx-> wtf?
08:03:54 <Saulzar> Must have the wrong link
08:04:31 <Phyx-> bah, stupid IE
08:04:32 <Phyx-> http://pastebin.com/623336
08:05:00 <mauke> nothing is misspelled
08:05:06 <Beelsebob> nothing wrong with that - but why not use the totally non IO() version?
08:05:19 <Beelsebob> and why the return ()
08:05:32 <mauke> and by nothing I mean "nothing"
08:05:41 <Beelsebob> oh... good point
08:05:42 <Beelsebob> Nothing
08:05:44 <Beelsebob> not nothing
08:05:51 <Phyx-> thanx mauke 
08:06:38 <Phyx-> Beelsebob: because it's a school assignment, i can't just copy other's work. but like i said, i'll make it do what it's suppossed to do first and then make it neater
08:07:04 <Beelsebob> yikes! They're making you use the IO monad for school!
08:07:06 <Beelsebob> scary
08:07:26 <Beelsebob> if they're teaching you FP... why are they teaching it in a non-functional setting
08:07:44 <xerox> The IO Monad is functional!
08:07:49 <Saulzar> Hmm, well you need to, to learn Haskell  (rather than just a tiny subset of Haskell)
08:07:53 <Beelsebob> not purely
08:08:13 <Beelsebob> Saulzar: I've *barely* used it in all my use of Haskell
08:08:26 <Philippa> that's because you've been writing IO-light code, no?
08:08:28 <Beelsebob> the most I use it is the interact function
08:08:32 <Saulzar> Depends what you're writing... some programs don't need it
08:08:35 <Philippa> you've not been doing GUI work, for example
08:08:36 <Beelsebob> and the occasional read file
08:08:48 * Phyx- watches the discussion
08:08:49 <Beelsebob> Philippa: true... but I don't think Haskell is the right language for that
08:08:57 <Philippa> and the fact is, you *need* to see the IO monad to understand that you can do "real work" in Haskell
08:09:01 <Philippa> I do
08:09:06 <Saulzar> Haskell is great for Guis.. gtk2hs is easier than anything else I've used :)
08:09:13 <Philippa> it's a much better language than Java or C++ for it, for example
08:09:14 <Beelsebob> Philippa: I do plenty of real work using only the interact function
08:09:14 <palomer>  "real work" in haskell is an oxymoron
08:09:18 <xerox> Saulzar: that's true for me too.
08:09:28 <Philippa> Beelsebob: but not for most students' idea of real work
08:09:32 * xerox oxtracizes palomer 
08:09:43 <Beelsebob> Philippa: everyone on my course thought that it was real work
08:10:05 <Philippa> you're not writing servers or web apps, you're not doing on-disk database queries, you're not providing a front-end the majority of computer users would feel comfortable with etc etc
08:10:15 <Beelsebob> true...
08:10:22 <Philippa> IOW, you're not doing the bulk of what most people think of as "real world code"
08:10:23 <Beelsebob> but then we're not trying to teach them to do that
08:10:31 <Beelsebob> we're trying to teach them to write *functional* code
08:10:35 <xerox> @iow
08:10:35 <lambdabot> I'm having fun HITCHHIKING to CINCINNATI or FAR ROCKAWAY!!
08:10:39 <Beelsebob> and the fact that it's haskell is by the by
08:11:03 <Philippa> perhaps, but a good many students'll never willingly touch a functional language again if they can't see how to write "real code" with one
08:11:21 <Philippa> IMO you're doing something wrong if you don't cover something about interacting with the rest of the world somewhere
08:11:26 <Beelsebob> true enough - and these are the students that should be doing SE, not CS
08:11:46 <Philippa> I disagree
08:11:57 <Beelsebob> Philippa: we did on our course... the interact function... we were told "there are more complex and powerful ways of doing this, but all we need is the interact function"
08:12:06 <Philippa> it's important *from a CS perspective* to understand how IO and computation work
08:12:07 <dcoutts> Saulzar, that's a nice marketing quote :-)
08:12:11 * Philippa nods
08:12:26 <Philippa> thus leaving everyone in the dark as to how to actually do this and how hard it will or won't be though
08:12:35 <Philippa> and I remember you having a major downer on monads a while back
08:12:46 <Beelsebob> Philippa: I still hate monads
08:12:48 <Saulzar> First Haskell program I wrote had 1 line of IO, raytracer without an interface. For anything more complicated you need IO
08:12:53 <TuringTest> Beelsebob: Why ?
08:12:53 <Beelsebob> I think they're clunky and non-obviouss
08:13:18 <Beelsebob> Saulzar: hat-delta is written with two IO functions - to read in the file, and one interact
08:13:20 <Saulzar> dcoutts, Just the truth :)
08:13:32 <Beelsebob> TuringTest: because the code that you get after using them is a cludgy mess
08:13:39 <Beelsebob> it's non-intuative, and non-functional style
08:14:02 <dcoutts> Saulzar, I should have a slick marketing bit on the gtk2hs site with user tesimonials. Or not. :-)
08:14:19 <Philippa> I've plenty good intuitions about the monads I use. I agree the style isn't purely functional, I disagree that a purely functional style is always the way to go, especially as monads frequently preserve many of the benefits
08:14:33 <Philippa> it's considerably better than just working in an impure language
08:14:49 <Beelsebob> Philippa: true indeed - I just never find the need to do anything impure ;)
08:15:08 <TuringTest> Beelsebob: Well, if you want several threads then you need more than one line of IO code (or STM).  And I rather liked the List monad for some things that were ugly with list comprehension syntax.
08:15:34 <Saulzar> Using a functional style is horrible for some kinds of code, state and errors for example are endlessly simpler using a monad
08:15:40 <Beelsebob> TuringTest: anything purely functional can be multi-threaded automatically by the compiler
08:15:42 <Philippa> not to mention more reliable
08:15:47 <TuringTest> Beelsebob: And you can't do everything efficiently with "pure" code, because sometimes the algorithm need mutable variables inside (using ST)
08:15:55 <Saulzar> dcoutts, Hehe, testimonials from #haskell don't convince many, I think :)
08:15:58 <Maddas> I was about to ask, why are monads considered non-functional? There are plenty of non-IO monads, after all
08:16:01 <xerox> To not mention, too, that monads improve composability.
08:16:10 <Philippa> Maddas: the resulting programming style isn't pure functional
08:16:17 <Beelsebob> whatever... I can't be arse arguing it today
08:16:28 <snk_kid> hmm i wonder if this has anything to do with my post in gamedev :)
08:16:32 <Philippa> any more than writing in BASIC interpreted by a pure interpreter would be
08:16:36 <Maddas> Philippa: Oh, okay, I missed that just the style was being argued about.
08:16:41 <dcoutts> Saulzar, heh, true :-)
08:17:07 <Philippa> TuringTest: actually that only counts if you need a polymorphic heap atm, and even that'd disappear with a strong enough type system
08:17:22 <Philippa> OTOH, you'd have reinvented ST with more risk of fucking up and less performance - IMO you may as well use ST
08:18:22 <snk_kid> you guys read Tim Sweeny's pdf/ppt?
08:18:44 <Philippa> once your program contains elements you can analyse and say "that's state!", it doesn't gain you much to keep using the unstructured implementation...
08:18:59 <Saulzar> snk_kid, It seemed wierd, thought his complaints about syntax were just bizzare
08:19:00 <waern> snk, yeah
08:19:59 <snk_kid> Salzar: yeah i don't agree completely with everything he says, but the majority of stuff, i think he's suggestion on syntax is to make a compromise for C++ coder
08:20:27 <vincenz> snk_kid: what's it on//
08:20:29 <vincenz> snk_kid: got a link
08:20:32 <Saulzar> Hmm, yeah I saw - functional programming with C++ syntax would be quite odd
08:20:46 <Philippa> "fucking painful" is more how I'd describe it, at least in a curried language
08:20:54 * vincenz grins
08:21:20 <snk_kid> vincenz: http://lambda-the-ultimate.org/node/1277
08:21:20 <Saulzar> A lecturer at my Uni wrote some language .. er, what was it called - mondarian? Which looked like an ugly mix of C ish syntax and Haskell
08:21:33 <mauke> mondrian
08:21:43 <snk_kid> isn't a mondarian a haskell like scripting language in .net?
08:21:54 <ndm_> Philip Wadler has been promoting his functional language, which is again ugly like C
08:22:24 <Philippa> any functional language which retains a C-style set of binding constructs I don't want to touch
08:22:52 <Philippa> yes, if you restrict declarations to the start of a block then blocks resemble let statements...
08:23:12 <snk_kid> You should see the kind of response i get when you try to get into peoples heads that C++/C is poorly suited for large scale massively concurrent/parallel games in distributed environments
08:23:14 <Philippa> (I gave some thought to a functional language with C-like syntax a few years back)
08:23:33 <Philippa> yeah, it's like they assume there's no better way to do concurrency
08:23:34 <dcoutts> ndm_, I keep thinking that a language that looked like C but had a haskell-style type system could do rather well
08:23:40 <waern> snk_kid, got a link to your post in gamedev?
08:23:44 <swiert> liyang: hiya
08:23:45 <Phyx-> ok, one question, is i have a type Just a, how can i get a?
08:23:53 <Philippa> dcoutts: were it impure, easily. Harder if pure+monadic
08:23:59 <snk_kid> waern: http://www.gamedev.net/community/forums/topic.asp?topic_id=382846
08:24:04 <ndm_> dcoutts, looks like - i.e. C with a strong type system, or Haskell with an ugly syntax?
08:24:10 <waern> snk_kid, thanks :)
08:24:10 <snk_kid> waern: thats only the latest one
08:24:12 <ndm_> do you want a functional or imperative language?
08:24:20 <Philippa> and the paren count if it were curried would be crazy
08:24:27 <ndm_> but i think that Java/C# with a Haskell type system would take off
08:24:43 <Saulzar> Arguing against C++ in gamedev is blasphemy :)
08:24:56 <dcoutts> ndm_, C with a strong type system would go far
08:25:24 <mauke> Phyx-: pattern matching or the maybe function
08:25:27 <ndm_> dcoutts, to make the type system sound, you have to have garbage collection
08:25:34 <snk_kid> Saulzar: well the industry are going to have learn once they've been bitten by the hand that feeds with games console that have +10, +100, +1000 core CPUs
08:25:47 <Saulzar> It will be interesting
08:25:48 <dcoutts> ndm_, or something python-like with strong typing, since like python you wouldn't need to declare the types of all vars
08:25:58 <dcoutts> ndm_, yes gc would be essential
08:26:11 <Phyx-> mauke: i am pattern matching, it tells me Just a doesn't match a
08:26:12 <TuringTest> Phyx-:  Look at Data.Maybe for several other ways
08:26:15 <ndm_> dcoutts, good plan - basically a well strongly typed imperative language
08:26:19 <mauke> Phyx-: what?
08:26:21 * Phyx- looks
08:26:23 <ndm_> i think there is something powerful in there
08:26:25 <Philippa> Saulzar: not entirely. I heard from a lead coder at Sony that most of the people he respects were going back to C
08:26:44 <dcoutts> ndm_, yes exactly
08:26:50 <snk_kid> ndm_: why would you want that though, have you seen spec# (and it's variants)?
08:27:02 <ndm_> snk_kid: no, i haven't
08:27:34 <kaol> strongly typed, imperative... sounds like felix.
08:27:41 <snk_kid> ndm_: go check out spec# (or maybe it was #spec) i can't remember
08:28:05 * Phyx- hates maybe
08:28:07 <snk_kid> ndm_: there is also a research OS being developed using a derivative of spec#
08:28:10 <ndm_> @google spec# programming language
08:28:13 <lambdabot> http://www.digitalmars.com/d/
08:28:21 <TuringTest> @type maybe
08:28:21 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
08:28:23 <snk_kid> no thats not it :)
08:28:25 <TuringTest> @type fromMaybe
08:28:26 <lambdabot> Not in scope: `fromMaybe'
08:28:29 <ndm_> ok, i think i did hear of that then, the MS OS project
08:28:31 <TuringTest> @type fromJust
08:28:32 <lambdabot> Not in scope: `fromJust'
08:28:40 <ndm_> which gets higher performance than Linux or Windows
08:28:46 <mauke> @index fromJust
08:28:46 <lambdabot> Data.Maybe
08:28:54 <TuringTest> @type Data.Maybe.fromJust
08:28:54 <lambdabot> forall a. Maybe a -> a
08:29:03 <snk_kid> ndm_: http://research.microsoft.com/specsharp/
08:29:05 * Phyx- hugs TuringTest 
08:29:11 <TuringTest> @type Data.Maybe.fromMaybe
08:29:11 <lambdabot> forall a. a -> Maybe a -> a
08:29:36 <TuringTest> Phyx-: fromMaybe has a default parameter for Nothing.  fromJust throws an error on Nothing
08:29:42 <snk_kid> has anyone heard of Qi before?
08:29:49 <ndm_> yes, i have heard of Qi
08:29:57 <ndm_> Lisp with a turing complete prolog type system...
08:29:59 <Phyx-> TuringTest: tells me not in scope. should i import Data.Maybe?
08:30:05 <TuringTest> Phyx-: yes
08:30:06 <ndm_> Phyx-: yes
08:30:19 <mauke> I think you should use pattern matching
08:30:24 <snk_kid> they make some bold claims
08:30:42 <Phyx-> weeee
08:30:43 <ndm_> such as all type systems can be subsumed by theirs
08:30:43 <Phyx-> compiled
08:30:48 <Phyx-> thanx a bunch guys
08:30:49 <Phyx-> :)
08:31:00 <snk_kid> ndm_: yes :)
08:31:31 <ndm_> snk_kid: but they don't claim their type system is terminating (in fact they prove it isn't), which is the big difference
08:31:31 * Phyx- starts to like maybe
08:31:51 <snk_kid> i suppose
08:32:14 * snk_kid will brb
08:32:36 <Philippa> ndm_: that's inherantly the case for one that subsumes all others. The only other thing it really needs after that's overloading
08:40:49 <dcoutts> @quote DennisHeuer
08:40:49 <lambdabot>  Are you fully nerd????
08:41:11 <xerox> Aha :-)
08:41:59 <snk_kid> can someone give me a hand with cabal files
08:42:54 <snk_kid> i'm looking at the docs and i don't see anything about controlling haddock but i'm sure i've seen it before
08:43:33 <dcoutts> xerox, that's not all
08:43:34 <dcoutts> @quote DennisHeuer
08:43:35 <lambdabot>  Your strategy shows that you just don't care.
08:43:41 <dcoutts> @quote DennisHeuer
08:43:42 <lambdabot>  Your strategy shows that you just don't care.
08:43:44 <dcoutts> @quote DennisHeuer
08:43:44 <lambdabot>  What is that????
08:43:51 <xerox> Ohh, I only saw that bug report :-)
08:43:59 <dcoutts> @quote DennisHeuer
08:43:59 <lambdabot>  Your strategy shows that you just don't care.
08:44:04 <dcoutts> bah
08:44:06 <dcoutts> @quote DennisHeuer
08:44:07 <lambdabot>  How can ghc expect an installed ghc for the first build stage?????
08:44:23 <snk_kid> @quote snk_kid
08:44:24 <lambdabot> snk_kid hasn't said anything memorable
08:44:29 <snk_kid> :)
08:45:28 <bolrod> is there some function that can stop an IO from going on  (like fail)  only give a custom error message
08:45:51 <bolrod> so instead of  *** Exception: user error (<custom message>)
08:45:56 <snk_kid> so what is the "haddock-interface:" option about in cabal package file? i can't see it on cabal docs
08:45:56 <bolrod> just the message you want it to show
08:45:57 <dcoutts> @index catch
08:45:57 <lambdabot> Control.Exception, System.IO.Error, Prelude
08:46:18 <Saulzar> Haha, that bug report is a good one.
08:46:27 <dcoutts> @type Control.Exception.catch
08:46:28 <lambdabot> forall a.
08:46:28 <lambdabot>          IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
08:46:44 <dcoutts> bolrod, that's what you want
08:46:49 <bolrod> you sure?
08:47:01 <bolrod> so lets say..
08:47:02 <dcoutts> bolrod, or one of the many other catch / handle functions in Control.Exception
08:47:08 <xerox> @docs Control.Exception
08:47:09 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
08:47:12 <bolrod> lets see
08:48:05 <mauke> http://www.xs4all.nl/%7Eweegen/eelis/analogliterals.xhtml
08:48:46 <bolrod> lets say.. I want the totally useless function that just outputs the user error
08:49:07 <bolrod> say..  sequence_ [operation, operation, ERROR, operation]  
08:49:13 <bolrod> and it has to stop at ERROR
08:49:55 <palomer> @yow
08:49:56 <lambdabot> I don't understand the HUMOUR of the THREE STOOGES!!
08:50:25 <xerox> > sequence_ [Just 1, Just 2, Nothing, Just 3]
08:50:26 <lambdabot> Nothing
08:50:32 <xerox> Maybe ErrorT.
08:50:46 <xerox> (Maybe not being a type, but just part of the phrase.)
08:53:27 <ihope> > sequence [Just 1, Just 2, Nothing, Just 3]
08:53:28 <lambdabot> Nothing
08:53:35 <ihope> > sequence [Just 1, Just 2, Just 3]
08:53:36 <lambdabot> Just [1,2,3]
08:55:02 <snk_kid> Lemmih: are you about?
08:55:04 <bolrod> hmm.. maybe I'm not getting this yet -,-
08:55:36 <bolrod> ah
08:55:36 <bolrod> k
08:55:39 <bolrod> I got it :)
08:56:40 <snk_kid> where does haddock put generated docs by default :(
08:56:53 <xerox> dist/doc, Lemmih said, iirc.
08:58:17 <snk_kid> xerox: yeah, it didn't come out there for me :(
08:59:15 <bolrod> is there a function like fail that doesn't return  "user error(<something>)"
08:59:15 <bolrod> ?
08:59:27 <musasabi> throw ?
08:59:33 <musasabi> @index throw
08:59:34 <lambdabot> Control.Exception
09:00:26 <bolrod> hmm
09:02:34 <bolrod> I dont know.. it doens't work like fail... 
09:02:51 <xerox> 'error' ?
09:03:18 <eivuokko> mzero?
09:03:28 <bolrod> catch doesn't like an error
09:03:40 <xerox> catch likes throw
09:03:44 <bolrod> I get ambiguous occurrence 'catch'
09:03:45 <bolrod> :)
09:03:50 <xerox> @index catch
09:03:50 <lambdabot> Control.Exception, System.IO.Error, Prelude
09:03:55 <snk_kid> all i need is docs for the sdl bindgins :(
09:04:01 <snk_kid> *bindings
09:04:17 <bolrod> yes.. and fail gives user error..   and throw requires some Exception type...
09:04:34 <bolrod> like..  throw (SomeException "quit")
09:04:49 <xerox> @docs Control.Exception
09:04:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
09:04:59 <eivuokko> import Prelude hiding (catch)
09:05:17 <eivuokko> If you have two Control.Exception imported, that would hide the cathcin Prelude
09:05:19 <xerox> They're explained in detail, in fact.
09:06:22 <Lemmih> snk_kid: Yep.
09:08:16 <MarcWeber> Is there a module for getting file extensions, filepath and so on except of the Cabal module?
09:08:28 <snk_kid> Lemmih: hi, i installed cpphs earlier, i had to configure again before doing "runghc Setup.lhs haddock" but i can't find where the files where put, there not in dist/docs :(
09:08:52 <bolrod> bleah.. its really simple.. I just want to use throw with 'some kind of error'   and catch it with 'catch'
09:09:06 <xerox> pffft!
09:09:18 <bolrod> I could use throw (NoMethodError "something")  and catch it just fine
09:09:26 <bolrod> but I dont have NoMethodError...  -,-
09:09:30 * bolrod just doesn't get this 
09:09:59 <Saulzar> catchDyn (do putStrLn "testing..."; throwDyn "foo") (\msg -> putStrLn msg)
09:10:50 <bolrod> ;o.. lets see
09:11:12 <ihope> @lart
09:11:12 <lambdabot> Not enough privileges
09:11:19 * ihope laughs
09:11:54 <ihope> bash: ls: command not found
09:12:13 <bolrod> Saulzar: thx!  that will do fine :)
09:14:30 <Beelsebob> @lard
09:14:30 <lambdabot> Maybe you meant: arr learn part
09:14:39 <ihope> Yeah, it was @part
09:14:42 <Beelsebob> @tart
09:14:43 <lambdabot> Not enough privileges
09:14:45 <Beelsebob> :P
09:14:51 <Beelsebob> @vixen tart
09:14:52 <lambdabot> Let's change the subject
09:14:57 <ihope> @bart
09:14:57 <lambdabot> Not enough privileges
09:15:01 <ihope> @cart
09:15:01 <lambdabot> Not enough privileges
09:15:02 <Beelsebob> @fart
09:15:02 <lambdabot> Maybe you meant: fact part
09:15:05 <Beelsebob> hehe
09:15:12 <snk_kid> i don't understand :'(
09:15:21 <Beelsebob> it's guessing what we wanted
09:15:34 <Beelsebob> @get-shapr
09:15:35 <lambdabot> shapr!!
09:15:36 <ihope> @pact
09:15:37 <lambdabot> Maybe you meant: fact part
09:15:53 <kaol> @meow
09:15:54 <Saulzar> @fact
09:15:54 <lambdabot> LBJ, LBJ, how many JOKES did you tell today??!
09:15:54 <lambdabot> I can not handle empty facts.
09:16:15 <ihope> @fact This is a fact.
09:16:15 <lambdabot> I know nothing about this
09:16:22 <Beelsebob> any lambdabot devs on?
09:16:23 <ihope> @fact fiction
09:16:24 <lambdabot> I know nothing about fiction
09:16:32 <Beelsebob> @fact fact
09:16:32 <lambdabot> fact: A fact is a fact is a fact is a fact. Or not.
09:16:34 <Saulzar> @fact 2 = 3
09:16:35 <lambdabot> I know nothing about 2
09:16:46 <Beelsebob> @. elite fact fact
09:16:47 <lambdabot> FA(7: 4 fact iS 4 Fa(+ iS 4 phaC+ i5 a FAc7. OR NO7.
09:16:50 <ihope> @fact lambdabot
09:16:50 <lambdabot> lambdabot: Lambdabot is a bot of curious opinions, and is female.
09:17:02 <snk_kid> !
09:17:08 <Saulzar> @fact dons
09:17:08 <lambdabot> I know nothing about dons
09:17:10 <ihope> @fact haskell
09:17:10 <lambdabot> haskell: Haskell is the language of choice for discriminating hackers.
09:17:17 <ihope> @fact cobol
09:17:18 <lambdabot> I know nothing about cobol
09:17:23 <ihope> @help fact
09:17:23 <lambdabot>  @fact <fact>, Retrieve a fact from the database
09:17:24 <xerox> Who does.
09:17:30 * xerox sedates ihope 
09:17:34 <Beelsebob> @fact help
09:17:35 <lambdabot> I know nothing about help
09:17:41 <Beelsebob> @fact curry
09:17:41 <lambdabot> I know nothing about curry
09:17:41 <Saulzar> @fact orial
09:17:42 <lambdabot> I know nothing about orial
09:17:46 <Beelsebob> @fact jam
09:17:46 <lambdabot> I know nothing about jam
09:17:53 <ihope> @fact Haskell B. Curry
09:17:54 <lambdabot> haskell: Haskell is the language of choice for discriminating hackers.
09:18:02 <Lemmih> snk_kid: dist/doc perhaps?
09:18:15 <Beelsebob> @break-lambdabot
09:18:16 <lambdabot> Unknown command, try @listcommands.
09:18:33 <palomer> hrmph, I've lost my dev/dsp
09:18:39 <snk_kid> Lemmi: yeah, the folders are there but no files
09:18:52 <snk_kid> *lemmih
09:19:48 * Beelsebob wonders why lambdabot appears to be cutting off lines longer than 100 chars
09:19:51 <davidhouse> anyone familiar with haskell-mode for emacs?
09:20:05 <xerox> Quite.
09:20:16 <davidhouse> specifically, what do i do to edit the colours it uses for syntax highlighting?
09:20:28 <snk_kid> lemmih: you do mean dist/doc in SDLstable/* directories
09:20:29 <xerox> Woops.
09:20:50 <snk_kid> lemmih: like SDLstable/Core/dist
09:21:35 <snk_kid> @listcommands
09:21:35 <lambdabot> use listcommands [module|command]. Modules are:
09:21:35 <lambdabot> babel base code compose dice dict djinn dummy dynamic elite fact haddock help hoogle karma lambda localtime more pl plugs poll pretty quote search seen spell state system todo topic type unlambda version vixen where
09:22:24 <snk_kid> @haddock
09:22:25 <lambdabot> Unknown command, try @listcommands.
09:22:36 <snk_kid> @listcommand haddock
09:22:37 <lambdabot> haddock provides: index
09:24:09 <snk_kid> Lemmih: is there docs online to view?
09:24:59 <Gilson> quit
09:26:32 <ihope> @quit
09:26:32 <lambdabot> Not enough privileges
09:26:33 <TuringTest> davidhouse: To change the color, put the cursor in the color to change and run "M-x customize-face" .  It will prompt you for a face name, but the default is where the cursor is, so just press enter.
09:28:10 <davidhouse> TuringTest: actually it looks like the default is 'all' but i know the face names anyway. thanks.
10:08:56 <jyp> @quote
10:08:56 <lambdabot> mattam says: [Monads are] much more elegant [than soccer] in general.
10:10:06 <Lieter> hey, how can you make a function that chaks if a input drom the user is of the right tyoe(like Int Int Int Int)
10:11:09 <davidhouse> > map read $ words "90 76 45 2"
10:11:10 <lambdabot> Add a type signature
10:11:24 <xerox> > map read $ words :: [Int]
10:11:24 <osquar> how are Haskell arrays implemented and what's their (in)efficiency?
10:11:25 <lambdabot> Couldn't match `[String]' against `t -> t1'
10:11:27 <xerox> ops.
10:11:30 <osquar> are they "native"?
10:11:32 <xerox> > map read $ words "1 2 3 4" :: [Int]
10:11:33 <lambdabot> [1,2,3,4]
10:11:37 <davidhouse> osquar: Data.Array
10:11:41 <davidhouse> not native.
10:12:00 <osquar> is it same as Okasaki's  FiniteMap?
10:12:03 <davidhouse> they have O(1) access, i can't remember the rest.
10:12:12 <xerox> @docs Data.Array
10:12:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
10:12:20 <liyang> osquar: that's Data.Map
10:12:32 <osquar> What is the difference?
10:12:41 <davidhouse> arrays have ordered keys
10:12:50 <osquar> and what is the speed of updates and indexing?
10:12:59 <osquar> so maps are more general
10:13:51 <osquar> O(1) access?
10:13:57 <osquar> is it an underlying tree?
10:14:41 <davidhouse> O(n) update
10:15:52 <davidhouse> lists have O(1) insert, O(n) update, delete, find and map.
10:16:05 <davidhouse> arrays have O(n) insert, update, delete and map, but O(1) find
10:16:18 <davidhouse> maps have O(log n) insert, update, delete and find, but O(n log n) map
10:16:28 <xerox> maps are cool
10:16:34 <davidhouse> maps rock.
10:16:44 <flux__> hmm.. maps have n log n map?
10:16:57 <xerox> Sounds strange to me too.
10:17:03 <davidhouse> well, that's from yaht which was actually talking about FiniteMaps
10:17:04 <osquar> in imperative languages update is O(1) too...
10:17:05 <davidhouse> so it might be wrong
10:17:15 <osquar> why are not arrays O(1) update and O(1) indexing
10:17:20 <xerox> In imperative languages there is no fun.
10:17:26 <davidhouse> @docs Data.Map
10:17:26 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
10:17:32 <osquar> is there no such data structure?
10:17:53 <osquar> is a set a map onto itself?
10:18:13 <flux__> right, mapping keys obviously is more than O(n)
10:18:14 <davidhouse> according to the docs, Maps have O(n) map
10:18:36 <osquar> @docs Set
10:18:36 <lambdabot> Set not available
10:18:44 <flux__> because otherwise it would be a loophole for sorting data in less than O(n log n) when you only have comparison ;)
10:18:46 <davidhouse> but mapping the keys is O(n log n)
10:18:49 <davidhouse> @docs Data.Set
10:18:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
10:19:18 <osquar> in my opinion, Okasaki's approach is nicer... ;-)
10:19:27 <osquar> but this may be practical
10:19:30 <flux__> it also has mapKeysMonotonic, which is O(n). nice.
10:19:42 <flux__> too bad that it doesn't check the precondition, though
10:19:58 <flux__> but I guess you can check it yourself if you want ;)
10:20:00 <osquar> what's the best we can do in indexing in functional languages? E.g. hash tables or such like...?
10:20:10 <flux__> hm, actually, is it that simple..
10:20:10 <osquar> quite close to O(1) I would guess?
10:20:41 <flux__> updateable array-like structures often pose a problem in pure functional languages :/
10:20:52 <osquar> so why not make them primitive
10:21:17 <flux__> haskell doesn't have linear types, which I understand would allow to have updateable arrays and pure functions at the same time
10:21:33 <flux__> unless I'm cutting some corners in my head ;)
10:21:45 <osquar> but it is surely just a matter of having a nice built-in array datatype which has persistence?
10:21:55 <osquar> think of C
10:21:59 <osquar> ;-) native
10:22:10 <xerox> flux__: linear types =~= Clean?
10:22:13 <flux__> xerox, yes
10:22:22 <flux__> I've only read other people commenting those, though ;)
10:22:44 <osquar> GHC is said to have primitive arrays alreadty
10:23:21 <flux__> arrays are difficult because of the expected immutability of the world
10:23:46 <flux__> so you can't just take an array and modify an element; some other function might have a reference to the said array and experience a side effect
10:23:55 <flux__> so you would really need to take a copy, and that would be horribly slow
10:24:48 <osquar> well, ...
10:24:55 <osquar> just pretend it is the current function with its semantics.
10:25:03 <osquar> but make the update faster and use a special representation
10:25:38 <flux__> well, modifying arrays is possible, but the function needs to be in a monad to do that
10:26:15 <osquar> bye
10:29:57 <ihope> > replicate 10 '13â¥'
10:29:57 <lambdabot>  lexical error in string/character literal
10:30:52 <flux__> what on earth did you expect?-)
10:31:27 <flux__> maybe it could convert colors into some funky unicode maps, and back..
10:32:17 <ihope> So what's are these Urk! error messages all about?
10:37:03 <davidhouse> anyone use haskell-mode with setnu-mode (emacs)?
10:48:08 <machack666> is it possible to write a specific Show instance for a specific [DataType]?  Even with -fglasgow-exts specified, I'm getting an `Illegal instance declaration for Show [Card]'  I thought that the list monad was essentially another datatype, so a declaration like this would be a refinement of the general case.  Am I wrong?
10:48:46 <ibid> machack666: instantiate Show Card and define the showList method
10:49:02 <ibid> machack666: the reason you get this is that there's a standard instance Show a => Show [a]
10:50:07 <machack666> Show Card is defined.  So instance Show a => Show [a] can't be "overridden" (not sure of the FP terminology) with a more refined datatype?
10:50:40 <machack666> is showList called automatically by instance Show [a]?
10:50:55 <davidhouse> @type showList
10:50:56 <lambdabot> forall a. (Show a) => [a] -> ShowS
10:51:03 <davidhouse> > showList [1..5]
10:51:03 <lambdabot>  add an instance declaration for (Show (String -> String))
10:51:32 <davidhouse> > show [1..5]
10:51:33 <lambdabot> "[1,2,3,4,5]"
10:51:42 <davidhouse> what's ShowS?
10:52:51 <machack666> @type ShowS
10:52:52 <lambdabot> Not in scope: data constructor `ShowS'
10:53:04 <davidhouse> @index ShowS
10:53:05 <lambdabot> Text.Show, Prelude
10:53:08 <davidhouse> @docs Text.Show
10:53:09 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Show.html
10:53:35 <davidhouse> > (showList [1..5]) ""
10:53:36 <lambdabot> "[1,2,3,4,5]"
10:55:11 <ibid> > showList [1..5] "foo"
10:55:11 <lambdabot> "[1,2,3,4,5]foo"
10:56:29 <machack666> > showList "a" "b" "c"
10:56:30 <lambdabot> Couldn't match `[Char]' against `t -> t1'
10:56:50 <ibid> > showList "a" "b"
10:56:51 <lambdabot> "\"a\"b"
10:57:17 <ibid> machack666: ShowS = String -> String; the idea is that it's a function that prepends something to its argument
10:57:45 <ibid> machack666: it's a rather clever trick to avoid excess copying when creating large strings by appending stuff
10:57:56 <ibid> machack666: ... by concatenating stuff together, rather
10:58:03 <ibid> machack666: the technique is this:
10:58:14 <ibid> @type showChar 'a'
10:58:15 <lambdabot> ShowS
10:58:35 <ibid> think of ShowS as an "abstract" string type
10:58:45 <ibid> showChar makes a character into ShowS
10:58:53 <ibid> showString makes a string into ShowS
10:59:06 <ibid> you concatenate two ShowSs by the (.) operator:
10:59:21 <ibid> @type showString "Hello " . showString "world!"
10:59:22 <lambdabot> String -> String
10:59:31 <ibid> > (showString "Hello " . showString "world!") ""
10:59:32 <lambdabot> "Hello world!"
10:59:43 <ibid> machack666: does that help?
10:59:51 <machack666> so the final "" is needed as input for the composited function?
10:59:55 <ibid> machack666: yes
11:00:07 <machack666> > (showString "Hello " . showString "world!") " It's good to have you here!"
11:00:08 <lambdabot> "Hello world! It's good to have you here!"
11:00:10 <ibid> machack666: well, the final "" is the way to convert ShowS to a regular String
11:00:49 <franka> #haskell get-together poll: http://snappoll.com/poll/84228.php
11:01:16 <machack666> I just defined `instance Show Card where show=...; showList _ = "Many cards"' and it seems to work.
11:01:36 <sieni> franka: that needs to be put in the topic
11:01:45 <ibid> machack666: that will not work
11:01:59 <ibid> machack666: make it showList = showString "Many cards"
11:02:04 <davidhouse> you mean showList _ = const "Many cards"
11:02:08 <machack666> for my constant sting outputting, it did.  :)
11:02:17 <ibid> davidhouse: wrong again
11:02:24 <davidhouse> well, true.
11:02:27 <franka> ibid: Yes, I am looking to do that.
11:02:28 <machack666> insofar as ghci evaled to the "Many cards" string.
11:02:31 <davidhouse> (++"Many cards") then
11:02:33 <ibid> machack666: yes, but it will not work in the general case
11:02:53 <ibid> davidhouse: showString is the preferred function
11:02:59 <davidhouse> okay then.
11:03:14 <ibid> davidhouse: (yes, it's showString s = (++s))
11:03:34 <davidhouse> > showString "a" "b"
11:03:35 <lambdabot> "ab"
11:03:36 <machack666> ah, I actually defined it as (++) "Many cards"
11:03:46 <ibid> that's ok
11:03:48 <davidhouse> > (++"a") "b"
11:03:49 <lambdabot> "ba"
11:03:59 <davidhouse> showString s = (s++)
11:04:02 <ibid> grr, ok, (s++), then :)
11:04:06 <davidhouse> ;)
11:04:25 <machack666> if I want to output a constant string, say, rather than basing anything on previous input, how would I go about that?
11:05:02 <machack666> const "string" compiles.  :)
11:05:15 <davidhouse> good.
11:05:31 <machack666> but, yes, it swallows up the ending bracket if you show [[Card]] :)
11:07:11 <machack666> is there a way to override instances which are lists of lists?
11:11:56 <davidhouse> > show [[1..5]]
11:11:58 <lambdabot> "[[1,2,3,4,5]]"
11:12:06 <davidhouse> machack666: what's your code at the moment?
11:15:17 <machack666> what are the relevant parts for you?
11:15:34 <machack666> i.e., instance Show Card only
11:15:35 <machack666> ?
11:15:41 <jeroen_p> The GHC is driving me crazy, it gives "Couldn't match `[]' against `IO'", but I can't see where it goes wrong. Is this a common mistake, among newbs?
11:16:34 <davidhouse> jeroen_p: no idea, unless you pastebin some code
11:16:36 <Lemmih> Yeah, monads can be tricky if you're not used to them.
11:18:22 <jeroen_p> i have this function f::[IO A]
11:18:40 <davidhouse> eww. but go on.
11:18:42 <jeroen_p> which ends in if y=='j' then x:f else [x]
11:18:47 <machack666> actually, sorry; I don't have time right now.  Thanks for the offer of help
11:19:02 <davidhouse> jeroen_p: what's the type of x?
11:19:11 <jeroen_p> A
11:19:20 <davidhouse> so not IO A?
11:19:28 <jeroen_p> Indeed
11:19:34 <davidhouse> you see the problem?
11:19:40 <jeroen_p> the whole if-thing is within a do, though.
11:19:53 <davidhouse> pastebin.com <- just paste the whole function
11:21:01 <jeroen_p> davidhouse, should I pm the function?
11:21:14 <davidhouse> jeroen_p: no, paste it into pastebin.com
11:21:20 <davidhouse> then copy-paste the URL it gives you here
11:21:29 <Korollary> lisppaste2: url
11:21:30 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:21:35 <davidhouse> or paste it there.
11:22:19 <jeroen_p> http://pastebin.com/pastebin.php?dl=623701
11:22:27 <Phyx-> one question, will filter work on data structures? or do i have to get the data out first?
11:22:47 <Lemmih> @type filter
11:22:48 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
11:23:17 <davidhouse> jeroen_p: "return" throws something into a monad
11:23:21 <davidhouse> > type "hello"
11:23:21 <lambdabot>  parse error on input `type'
11:23:25 <davidhouse> @type "hello"
11:23:26 <lambdabot> [Char]
11:23:32 <davidhouse> @type return "hello"
11:23:32 <lambdabot> forall (m :: * -> *). (Monad m) => m [Char]
11:23:45 <jeroen_p> Yes
11:24:11 <davidhouse> the type of your function is [IO A], but you're returning a list, which will give it type IO [A].
11:24:31 <jeroen_p> We don't want that
11:24:39 <davidhouse> @type return ["hello"]
11:24:40 <lambdabot> forall (m :: * -> *). (Monad m) => m [[Char]]
11:24:47 <davidhouse> @type [return "hello"]
11:24:48 <lambdabot> forall (m :: * -> *). (Monad m) => [m [Char]]
11:25:56 <davidhouse> you need to return the elements then put them into a list
11:27:18 <jeroen_p> Like 'return del:vraagDeelnemer' ?
11:27:54 <davidhouse> (return del):whatever
11:29:30 <jeroen_p> I made the changes, http://pastebin.com/pastebin.php?dl=623714, but it still gives the same error
11:29:32 <franka> @poll-results WouldYouAttendAGetTogetherInAmsterdamPerhapsInMayOrJune?
11:29:32 <lambdabot> Poll results for WouldYouAttendAGetTogetherInAmsterdamPerhapsInMayOrJune? (Open): YesButNotInMayOrJune=0, YesButNotInAmsterdam=0, Yes=1, No=0
11:29:37 <franka> @help vote
11:29:38 <lambdabot>  @vote <poll> <choice>        vote for <choice> in <poll>
11:29:41 <franka> If you care to.
11:30:41 <Lemmih> A EuroHaskell in Amsterdam?
11:30:58 <sieni> Lemmih: that was the plan
11:31:20 <Lemmih> @vote WouldYouAttendAGetTogetherInAmsterdamPerhapsInMayOrJune? Yes
11:31:20 <franka> Yes.
11:31:21 <lambdabot> voted on "Yes"
11:31:31 <davidhouse> jeroen_p: what's the type of Deelnemer?
11:31:42 <davidhouse> wait, stupid question, never mind
11:32:04 <sieni> @vote WouldYouAttendAGetTogetherInAmsterdamPerhapsInMayOrJune? Yes
11:32:04 <lambdabot> voted on "Yes"
11:32:11 <franka> I am only trying to gauge interest at this point, no commitals.
11:32:29 <jeroen_p> I can recall coming across this only several hours ago, though I forgot how I solved this
11:33:10 <davidhouse> that code looks good.
11:34:07 <jeroen_p> Couldn't match `[]' against `IO'
11:34:07 <jeroen_p>   Expected type: []
11:34:07 <jeroen_p>   Inferred type: IO
11:37:01 <davidhouse> sorry, IRC client crashed.
11:37:14 <davidhouse> anyone else see a problem with jeroen_p's code?
11:37:39 <Lemmih> jeroen_p: Do you really want it to be of type [IO Deelnemer]?
11:37:49 <dblhelix> @vote WouldYouAttendAGetTogetherInAmsterdamPerhapsInMayOrJune? yes
11:37:50 <lambdabot> "yes" is not currently a candidate in this poll
11:37:55 <dblhelix> @vote WouldYouAttendAGetTogetherInAmsterdamPerhapsInMayOrJune? Yes
11:37:55 <lambdabot> voted on "Yes"
11:37:55 <Lemmih> jeroen_p: IO [Deelnemer] would make more sense.
11:38:17 --- topic: set to '["Submit a paper to the Haskell Workshop:", "http://haskell.org/haskell-workshop/2006", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion", "Vote on a European #haskell get-together: http://snappoll.com/poll/84228.php"]' by franka
11:38:38 * Phyx- finds data structures annoying
11:38:39 <franka> That is the web version.
11:38:39 <Lemmih> jeroen_p: If you don't want it to be an IO action then you can't use 'putStrLn' and 'inputSeq'.
11:39:02 * davidhouse smacks forehead
11:39:08 <davidhouse> i was concentrating on the if statement
11:39:13 <franka> Of course, now that votes will be split between the two it will be impossible to get a good measurement... :(
11:39:32 <dblhelix> yes, it should definitely be IO [Deelnemer] 
11:39:46 <jeroen_p> Lemmih, would that solve my whole dilemma?
11:40:01 <dblhelix> jeroen_p: don't worry, yet another 26 hours before it's to be handed in ;)
11:40:25 <Phyx-> heheh
11:40:29 * Phyx- is at 1
11:40:35 <Phyx-> started today, hehe
11:40:46 <Lemmih> jeroen_p: Yes, if you also change 'return del:vraagDeelnemer' to 'rest <- vraweirdlang; return (del:rest)'.
11:41:10 <jeroen_p> I found that, thanks
11:43:56 <jeroen_p> Now everything works, woo
11:44:09 <jeroen_p> On to the testing
11:44:49 <Aphex_Twin> what haskell function determins the type of a given expression?
11:45:12 <dblhelix> jeroen_p: can't wait to see what you'll hand in :) don't forget to thank #haskell somewhere in your code ;)
11:45:14 <davidhouse> Aphex_Twin: as in Typeable?
11:45:36 <Aphex_Twin> for instance: the type of (2/3, 4, "abcd)
11:45:46 <Philippa> in haskell98, there's no such function
11:45:55 <Philippa> nor would there be any use for it if you had it
11:46:08 <davidhouse> there's the Typeable library, which allow you to represent types in code.
11:46:10 <Philippa> (to get GHCi or hugs to tell you, :t (2/3, 4, "abcd")
11:46:10 <Philippa> )
11:46:17 <davidhouse> if you mean GHCi, it's :t
11:46:36 <Philippa> Typeable requires further compiler support, it's not just a library in practice
11:46:39 <jeroen_p> dblhelix, can you see the pm's I'm attempting to send?
11:47:00 <dblhelix> jeroen_p: nope
11:48:25 <jeroen_p> Due to a gross lack in irc-communication throughout the last few months my skills in typing those commando's have gone a bit rusty, so I can't type them
11:49:00 <Aphex_Twin> davidhouse: yes, ty
11:49:37 <davidhouse> how can i configure haskell-mode's syntax colouring?
11:50:27 <jeroen_p> my apologies for every futile attempt :)
11:51:09 <jeroen_p> dblhelix, would you mind trying to send me a pm?
11:52:58 <dblhelix> no prob
11:54:45 <dblhelix> jeroen_p: and, did you receive it?
11:55:27 <jeroen_p> dblhelix, yes, did you receive mine?
11:55:40 <dblhelix> jeroen_p: nope
11:56:25 <jeroen_p> How rare
11:57:50 <ihope> @index average
11:57:50 <lambdabot> bzzt
11:57:53 <ihope> @index mean
11:57:54 <lambdabot> bzzt
11:59:46 <ihope> > let 6*9 = 42; x*y = x Prelude.* y in [6*9,4*5,9*6]
11:59:47 <lambdabot> [42,20,54]
12:00:19 <jeroen_p> dblhelix, that's strange. I think I made something fairly exciting for #1.
12:00:24 <davidhouse> > let mean l = sum l / length l in mean [1..5]
12:00:25 <lambdabot>  add an instance declaration for (Fractional Int)
12:00:25 <lambdabot>   In the definition of `mean': mean l = (sum l) / (length l)
12:00:25 <lambdabot>   In the definition of `wil':
12:00:47 <davidhouse> > let mean l = (fromIntegral $ sum l) / (fromIntegral $ length l) in mean [1..5]
12:00:48 <lambdabot> 3.0
12:00:54 <davidhouse> haskell's number classes suck.
12:00:54 <dblhelix> jeroen_p: can't wait
12:00:59 <jeroen_p> let mean l = sum l `div` length l in mean [1..5]
12:01:22 <jeroen_p> > let mean l = sum l `div` length l in mean [1..5]
12:01:22 <lambdabot> 3
12:01:25 <davidhouse> that'll do integer division, which is presumably not what you want.
12:01:30 <davidhouse> > let mean l = sum l `div` length l in mean [1..6]
12:01:31 <lambdabot> 3
12:02:18 <ihope> > let mean l = sum l / length l in (mean . map fromIntegral . map fromEnum) "munch"
12:02:19 <lambdabot>  add an instance declaration for (Fractional Int)
12:02:19 <lambdabot>   In the definition of `mean': mean l = (sum l) / (length l)
12:02:19 <lambdabot>   In the definition of `ooi':
12:02:32 <Aphex_Twin> I seem to have a problem here, probably trivial, but I can't figure it out: http://rafb.net/paste/results/SPXCi891.html
12:03:20 <ihope> Aphex_Twin: use fromInteger to turn an Integer into any number
12:03:51 <jeroen_p> dblhelix, would you care for setting up some sort of pm-channel between us?
12:03:58 <Aphex_Twin> ihope: and conversely, to turn a number into an Integer?
12:04:04 <dblhelix> > let mean l = sum l / List.genericLength l in mean [1 .. 6]
12:04:04 <lambdabot> 3.5
12:04:20 <ihope> @type floor
12:04:21 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
12:04:30 <dblhelix> jeroen_p: not problem
12:04:41 <dblhelix> jeroen_p: no prob, I mean :)
12:04:42 <ihope> Aphex_Twin: try that
12:04:52 <jeroen_p> dblhelix, can you?
12:05:08 <dblhelix> ihope, Aphex_Twin: what's wrong with my proposal? :)
12:05:22 <ihope> > let mean l = sum l / List.genericLength l in (mean . map fromIntegral . map fromEnum) "munch"
12:05:23 <lambdabot> 107.8
12:05:34 <dblhelix> jeroen_p: join #dblhelix
12:05:34 <ihope> Yay!
12:07:00 <ihope> > map fromEnum "munch"
12:07:01 <lambdabot> [109,117,110,99,104]
12:07:45 <gzl> @type List.genericLength
12:07:46 <lambdabot> forall i b. (Num i) => [b] -> i
12:07:59 <xerox> > map ord "munch"
12:08:00 <lambdabot> [109,117,110,99,104]
12:08:23 <gzl> @type length
12:08:24 <lambdabot> forall a. [a] -> Int
12:08:58 <Aphex_Twin> is there a general function that converts a number to an integer?
12:09:05 <Aphex_Twin> Integer, that is
12:09:40 <ihope> Aphex_Twin: well, not every number value represents an integer.
12:10:03 <ihope> How would the complex number (3.82 + -16.3i) be turned into an Integer?
12:10:09 <dblhelix> @type toIntegral
12:10:10 <lambdabot> Not in scope: `toIntegral'
12:10:14 <dblhelix> @type toInteger
12:10:15 <lambdabot> forall a. (Integral a) => a -> Integer
12:10:27 <dblhelix> @type toInteger
12:10:27 <lambdabot> forall a. (Integral a) => a -> Integer
12:10:33 <ihope> Yeah, that only works on Integrals.
12:10:34 <dblhelix> @type fromInteger
12:10:35 <lambdabot> forall a. (Num a) => Integer -> a
12:11:33 <ihope> @hoogle a -> Integer
12:11:35 <lambdabot> System.CPUTime.cpuTimePrecision :: Integer
12:11:35 <lambdabot> GHC.Exts.S# :: Int# -> Integer
12:11:35 <lambdabot> Prelude.toInteger :: Integral a => a -> Integer
12:11:51 <ihope> Ow.
12:12:46 <ihope> Aphex_Twin: if you can find a good way to turn something into an Integer, then add an instance declaration for it:
12:12:55 <ihope> instance Integral Type where
12:13:18 <ihope>   toInteger x = anIntegerVersionOfx
12:13:39 <Aphex_Twin> ok: "toInteger 2.0" gives out the error: "ERROR - Unresolved overloading
12:13:39 <Aphex_Twin> *** Type       : (Fractional a, Integral a) => Integer"
12:14:00 <Aphex_Twin> or: "toInteger (2/3)" gives something symilar
12:14:06 <ihope> You have to give 2.0 and 2/3 types.
12:14:16 <ihope> toInteger (2.0 :: something)
12:14:23 <Aphex_Twin> isn't it possible to do a simple conversion, that is possible in C (int) ?
12:14:31 <Aphex_Twin> (int) (2/3)
12:14:34 <Aphex_Twin> something like that
12:14:45 <ihope> Try round (2/3)
12:14:49 <ihope> > round (2/3)
12:14:50 <lambdabot> 1
12:15:46 <ihope> > 2 `div` 3
12:15:47 <lambdabot> 0
12:16:45 <Aphex_Twin> ihope: Ambiguous type signature in inferred type
12:16:59 <ihope> round (2/3 :: Double)
12:17:07 <Aphex_Twin> in this: t n_    =  round(floor( (3+sqrt(8*n_-7))/2))
12:17:07 <ihope> Are you using Hugs?
12:17:11 <Aphex_Twin> yes
12:17:38 <ihope> t n_ = round(floor( (3+(sqrt(8*n_-7) :: Double))/2))
12:17:59 <ihope> Oh, and using round after floor is redundant...
12:18:07 <ihope> @type floor
12:18:07 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
12:18:56 <ihope> @type round
12:18:57 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
12:19:24 <ihope> Hmm, I see. Maybe using round after floor is actually causing that error.
12:22:06 <Aphex_Twin> this is something I can't understand: "s 2 (t 2)" does not give any error, but "ss 2" does. http://rafb.net/paste/results/jqXmX594.html
12:22:24 <Aphex_Twin> the error is: Unresolved overloading
12:23:53 <ihope> Does it say anything else
12:25:16 <Aphex_Twin> *** Type       : (RealFrac a, Floating a, Integral a) => a
12:25:16 <Aphex_Twin> *** Expression : ss 2
12:26:24 <int-e> Aphex_Twin: in s 2 (t 2) it can give the two 2s different types. it can't do that for ss
12:27:10 <int-e> Aphex_Twin: you need something like ss n = s n (t (fromIntegral n))
12:27:45 <Aphex_Twin> aha
12:27:45 <ihope> Greh.
12:27:47 <Aphex_Twin> TY
12:52:53 <mwc> Anybody using GHC on powerpc-linux?
12:55:14 <dcoutts> mwc, yep
12:55:32 <mwc> dcoutts, smooth sailing?
12:55:40 <dcoutts> mwc, well not personally, but we support it on that platform with the help of some ppc minions
12:55:45 <dcoutts> yeah, pretty good
12:55:52 <dcoutts> mwc, want a binary?
12:55:56 <mwc> not yet
12:56:03 <mwc> take you up on it in a coupla weeks
12:56:10 <mwc> when I get a chance to move to linux
12:56:16 <ihope> Ow, don't talk while I'm talking. It messes things up :-)
12:56:36 <dcoutts> mwc, it's sitting on the gentoo mirrors as distfiles/ghc-bin-6.4.1-ppc.tbz2
12:56:46 <dcoutts> mwc, if you use Gentoo linux then it's easy :-)
12:59:10 <mwc> would be nice if we could bootstrap GHC on Hugs
12:59:34 <SuperTails92> yeah
12:59:41 <dcoutts> mwc, in gentoo we bootstrap via ghc-bin
12:59:52 <dcoutts> we do that on more arches that you're ever likely to use
13:00:18 <SuperTails92> yes, but the ghc binary is huge
13:00:30 <SuperTails92> like, JRE huge
13:00:32 <mwc> plus the source-compiling purists :P
13:00:45 <SuperTails92> yeah, those nutty loons
13:00:48 <dcoutts> mwc, we bootstrap the ghc soruce ebuild with ghc-bin
13:01:00 <dcoutts> mwc, so you get the choice
13:01:05 <mwc> ghc-bin, isn't that just somebody's compiled GHC binaries?
13:01:24 <SuperTails92> still, bootstraping ghc with hugs would be a lot smaller than using ghc-bin
13:01:43 <dcoutts> mwc, right, and you can use that directly, or use it to build the ghc source ebuild
13:01:51 <mwc> ah
13:01:53 <dcoutts> mwc, after that you can remove ghc-bin
13:01:58 <mwc> true enough
13:03:31 <bolrod> dblhelix: question: can we use the extensions for the assignment? :)
13:04:26 <dblhelix> bolrod: let me see, -fglasgow-exts: yes... others: no...
13:04:40 <bolrod> ok..  :)
13:05:05 <bolrod> otherwise  you cannot create    instance Something String where ....  for some reason :/
13:05:20 <ihope> instance Something [Char] where...
13:05:26 <bolrod> not that this is a good solution..   but I just wanted to try
13:05:28 <bolrod> ihope: same
13:05:33 <dblhelix> (I should forbid students to even think about the course after 11pm)
13:05:37 <ihope> What do you get?
13:05:44 <bolrod> dblhelix: why? :/
13:05:56 <Muad_Dibber> lol @ dbremner
13:05:58 <bolrod> then again... it feels like 10PM
13:05:59 <Muad_Dibber> * dblhelix also
13:06:03 <bolrod> ;)
13:06:32 <bolrod> then again... I seem to lack the sense of time
13:06:39 <bolrod> especially when I'm begind a computer listening music
13:06:51 <dblhelix> bolrod: can't you make it work with instance (Something a) =>  Something [a]?
13:07:09 <bolrod> urh. think it does the same
13:07:11 <bolrod> lets see
13:07:45 <SamB> bolrod: well, that works fine for Show...
13:12:00 <bolrod> I already had that instance... but didn't work on strings ;/
13:12:09 <bolrod> since I still need a different action for strings
13:12:57 <dblhelix> bolrod: and Something is something (no pun intended) that you've defined yourself
13:13:10 <bolrod> yes 
13:13:26 <dblhelix> bolrod: in that case you may want to check how it's done for Show and lists...
13:13:28 <bolrod> but  instance Something String    << just doesn't work without the -fglasgow-exts
13:13:45 <SamB> bolrod: why don't you go and look at how Show deals with strings, hmm?
13:13:57 <bolrod> yeah
13:14:02 <bolrod> I'll have a look
13:14:05 <dblhelix> bolrod: no extensions needed there
13:14:11 <xerox> @libsrc GHC.Show
13:14:11 <lambdabot> GHC.Show not available
13:14:40 <dblhelix> @info Show
13:14:40 <lambdabot> Unknown command, try @listcommands.
13:15:10 <dblhelix> class Show a where
13:15:10 <dblhelix>   showsPrec :: Int -> a -> ShowS
13:15:10 <dblhelix>   show :: a -> String
13:15:10 <dblhelix>   showList :: [a] -> ShowS
13:16:18 <jyp> @where lambdabot 
13:16:19 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
13:20:39 <xerox> @seen bosie
13:20:40 <lambdabot> I haven't seen bosie.
13:21:03 <Phyx-> does haskell have a split function or something?
13:21:39 <SamB> there was one on that page-o-useful-code on the wiki
13:21:43 <Muad_Dibber> Phyx-: meaning?
13:22:04 <sjanssen> @hoogle Int -> [a] -> ([a], [a])
13:22:05 <lambdabot> Data.List.splitAt :: Int -> [a] -> ([a], [a])
13:22:05 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
13:22:05 <lambdabot> Graphics.UI.ObjectIO.CommonDef.split :: Int -> [x] -> ([x], [x])
13:22:22 <Phyx-> Muad_Dibber: meaning something to split for instance "a b c" into [a,b,c]
13:22:36 <xerox> splitBy c = map (drop 1) . groupBy (const (/= c)) . (c:)
13:22:41 <xerox> That's words.
13:22:43 <sjanssen> > words "1 2 3" :: [Int]
13:22:44 <lambdabot> Couldn't match `Int' against `String'
13:22:50 <sjanssen> oops
13:22:54 <xerox> > words "a b c"
13:22:55 <lambdabot> ["a","b","c"]
13:23:17 <Phyx-> ah
13:23:20 <Phyx-> forgot about that
13:23:21 <Phyx-> hheh
13:23:36 <xerox> > unwords ["it's","ok"]
13:23:37 <lambdabot> "it's ok"
13:23:46 <Phyx-> now, that one is new
13:24:04 <Phyx-> lol, i gotta stop forgetting functions
13:24:27 <xerox> > lines "oh\nis\nit?"
13:24:28 <lambdabot> ["oh","is","it?"]
13:24:50 <SamB> of course, if you want to split on something else, you'll still want that split function...
13:26:44 <Muad_Dibber> let (h,t) = splitAt 2 $ words "or else it eat" in h ++ reverse t
13:27:54 <Muad_Dibber> that at least clarifies it a bit.
13:27:57 <Muad_Dibber> err
13:28:18 <Muad_Dibber> that is talking in completly the wrong window.
13:29:04 <xerox> > let splitBy c = map (drop 1) . groupBy (const (/= c)) . (c:) in splitBy 'o' "lol"
13:29:05 <lambdabot> ["l","l"]
13:31:36 <bolrod> blah... the whole problem is that stupid show :) -,-
13:32:07 <dcoutts> Igloo, dons, ever seen ghci "Function table overflow" ?
13:32:39 <dcoutts> I'm getting that when loading cabal in ghci
13:32:45 <dcoutts> on ia64
13:33:10 <SamB> ia64 is nasty, isn't it?
13:33:43 <bolrod> I wonder... why does  show String  output  "\"String\""     I think it doesn't make sense
13:33:46 <bolrod> :)
13:34:02 <SamB> because the implicit print shows it again?
13:34:30 <bolrod> blah.. I dont even want to think about it  ;)
13:34:30 <bolrod> hehe
13:34:39 <SamB> > show True
13:34:40 <lambdabot> "True"
13:34:42 <Igloo> dcoutts: No
13:34:49 <bolrod> > show "test"
13:34:50 <lambdabot> "\"test\""
13:35:18 <bolrod> > show 'w'
13:35:19 <lambdabot> "'w'"
13:35:29 <bolrod> ic...
13:36:27 <Muad_Dibber> > putStrLn $ show "test"
13:36:27 <lambdabot> No IO allowed
13:36:30 <Muad_Dibber> oh right.
13:36:32 <thedward> > "test"
13:36:33 <lambdabot> "test"
13:36:39 <bolrod> wow!
13:37:09 <bolrod> hmm.. I need something to drink....  and I've heard this cd way to much today :)
13:38:20 <dcoutts> Igloo, found it, only ia64 uses a function table :-) I just need to up the size
13:41:28 <xerox> Have a joyous week, folks.
13:41:31 <xerox> See you again in some days, Vienna, here I come!
13:41:40 <Phyx-> ok, let's see if this works
13:41:43 <Phyx-> > all (==True) $ concat $ map (map isDigit) $ words "1 23 4 567"
13:41:44 <lambdabot> True
13:41:47 <Phyx-> :)
13:41:50 <Phyx-> > all (==True) $ concat $ map (map isDigit) $ words "1 23 4 567b"
13:41:51 <lambdabot> False
13:41:53 <Phyx-> :D
13:41:59 <xerox> and = all (== True)
13:42:13 <Phyx-> > and $ concat $ map (map isDigit) $ words "1 23 4 567b"
13:42:14 <lambdabot> False
13:42:17 <Phyx-> > and $ concat $ map (map isDigit) $ words "1 23 4 567"
13:42:18 <lambdabot> True
13:42:19 <Phyx-> nice
13:42:20 <Phyx-> :D
13:42:35 <dcoutts> have fun xerox!
13:42:39 <Phyx-> @type and
13:42:40 <lambdabot> [Bool] -> Bool
13:42:49 <xerox> > and (words "1 23 4 567" >>= map isDigit)
13:42:50 <lambdabot> True
13:43:07 <xerox> Yesh, I'll miss you! :-)
13:43:11 <Phyx-> xerox: sorry, that's abit out of my league :|
13:43:20 <Phyx-> bye xerox 
13:43:25 <xerox> Phyx-: It's simple, for the list Monad, (>>=) = flip concatMap.
13:43:37 * xerox waves waves
13:43:44 <Phyx-> ohh, it is?
13:43:46 <dblhelix> Phyx-: (>>=) was discussed during the lecture once, iirc
13:44:02 * Phyx- pleads the fifth
13:45:30 * SamB waves to xerox
13:52:38 <Phyx-> dblhelix: if it in the book somewhere, or on a slide, or was it just "talked" about in class?
13:53:44 <Phyx-> in any case, i get now atleast ^_^
13:55:59 <bolrod> I haven't heard the >>= operator
13:56:12 <bolrod> in class that is
13:57:44 <dblhelix> Phyx-: i think it was just talked about
13:58:52 <Phyx-> ohh, ok
13:58:58 <bolrod> today..?
13:59:04 * bolrod was sleeping today
13:59:10 <Phyx-> today? it's sunday dude
13:59:11 <Phyx-> lol
13:59:15 <bolrod> oh
13:59:15 <bolrod> bleah
13:59:19 * bolrod has no sense of time
13:59:20 <bolrod> >_<
13:59:21 <Phyx-> rofl, hahah
13:59:39 <bolrod> my gawd... too much time at home isn't good 
13:59:46 <Phyx-> your telling me
13:59:48 <Phyx-> :|
13:59:54 <Phyx-> had to finish inp 2
14:00:10 <bolrod> ahyeah
14:00:16 <bolrod> I gave up on that php assignment
14:00:17 <bolrod> :P
14:00:24 <bolrod> fp!
14:00:30 <bolrod> *Yawn*
14:00:32 <Phyx-> how come/
14:00:33 <Phyx-> ?
14:00:40 <bolrod> because I didn't hand in milestone 2
14:00:45 <Phyx-> i finished with 4 minutes to spair
14:01:07 <Phyx-> spend the day sshed into school setting it up, lol
14:01:08 <bolrod> because I was busy with fp when we had to finish milestone 2
14:01:14 <Phyx-> same
14:01:25 <bolrod> a day to ssh into school? O_O
14:01:28 <bolrod> wow
14:01:40 <Phyx-> well, i kept doing different things
14:01:41 <Phyx-> lol
14:01:44 <Phyx-> like chat on ir
14:01:46 <Phyx-> irc8
14:01:48 <Phyx-> irc*
14:02:25 <bolrod> aha :)
14:02:45 <Phyx-> and had problems with paths, used \ while unix used / so had to write a small shellscript to fix that, but couldn't get the right regexp, since it needed to exclude \" from the match
14:03:03 <Phyx-> and then had problems with uppercase includes while files are lowercase etc
14:03:06 <bolrod> you use \  ?!?
14:03:18 <Phyx-> generally things unix is picky about
14:03:30 <bolrod> haha
14:03:36 <bolrod> you need tu use *nix more ;p
14:03:39 <Phyx-> heheh
14:03:40 <bolrod> lol
14:03:46 * Phyx- looks at his gentoo
14:03:58 <bolrod> hrmm.. gentoo..  
14:04:11 <bolrod> I tried installing it on my laptop
14:04:11 <Phyx-> ohh and a blanked my files a few times ^_^
14:04:16 <SamB> sometimes I try to use / under WINE... I have no idea why WINE dislikes this...
14:04:20 <Phyx-> wrong regexp
14:04:30 <bolrod> after like... lots of minutes of kernel compiling.. it got an error
14:04:31 <bolrod> >;/
14:04:55 <Phyx-> heheh, i got it compiled under mine, tested it in vmware first in case i mess up
14:05:18 <bolrod> gentoo is rather difficult to install... if you never used linux before
14:05:41 <Phyx-> well, the guide is pretty good
14:05:42 <bolrod> Ubuntu is really easy .. though it still has the ugly old debian like installer
14:05:47 <bolrod> true
14:06:25 <Phyx-> i just put it to compile and went to sleep, woke up all happy in the morning
14:06:34 <SamB> you dislike character graphics?
14:06:40 <Phyx-> next step "download this pack and compile again"
14:06:49 <Phyx-> :S
14:07:08 <bolrod> yah....
14:07:29 <bolrod> now compile:  Firefox, X.org, openoffice, mozillathunderbird
14:07:32 <bolrod> see you back in a wee
14:07:32 <bolrod> k
14:07:36 <bolrod> week *   :)
14:07:40 <Phyx-> later
14:07:42 <Phyx-> week?
14:07:46 <bolrod> well..
14:07:54 <bolrod> I wouldn't want to compile the complete openoffice ;/
14:07:56 <Phyx-> lol, thought you were going
14:08:03 <bolrod> not while I'm waiting that is
14:08:11 <Phyx-> lol, even KDE takes a long time
14:08:37 <bolrod> then dont use KDE
14:08:38 <bolrod> ;p
14:08:51 <bolrod> KDE looks childish 
14:08:58 <Phyx-> rofl
14:09:11 <bolrod> gnome is cool
14:09:13 <shapr> I figure, you use what you like.
14:09:23 <shapr> franka: hiya!
14:09:31 <bolrod> @yarr
14:09:32 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
14:09:36 <franka> Hi, shapr.
14:09:45 <Phyx-> i think gnome is plain
14:09:55 <Phyx-> to bad the centos boxes at school use it :|
14:09:58 <Phyx-> kde would rule on em
14:10:04 <bolrod> they have kde...
14:10:06 <bolrod> ;p
14:10:10 <Phyx-> they do?
14:10:12 <bolrod> yeah
14:10:15 <SamB> Phyx-: default theme, sure
14:10:16 <Phyx-> when i login i get gnome
14:10:16 <bolrod> just select it in the gdm
14:10:30 <Phyx-> hmm ok, didn't even know they had em installed
14:10:30 <bolrod> you have to switch it to KDE
14:10:31 <bolrod> ;p
14:10:45 <SamB> however, some people like a plain UI
14:10:50 <bolrod> Xgl is soo cool
14:11:05 <bolrod> I have set my gnome to look very minimalistic though
14:11:28 <Phyx-> hehe
14:11:40 <shapr> I started out using Windows, then Enligthenment, then whatever IRIX has, then KDE, then Gnome, and now I use ion3
14:11:40 <shapr> enlightenment*
14:11:46 * Phyx- notes the amound of UU students increase here around deadlines :P
14:12:37 <bolrod> ey ey...
14:12:39 <shapr> franka: cute msg on last.fm
14:12:42 <bolrod> I didn't 
14:12:44 <bolrod> leave
14:12:46 <bolrod> :P
14:13:01 <Phyx-> heheh
14:13:03 <franka> I do my best.
14:13:22 <shapr> franka: How's code?
14:13:22 <Phyx-> bolrod: idling doesn't count a staying
14:13:33 <bolrod> I did say some things..
14:13:50 <bolrod> http://bolrod.homelinux.org/screen.png   :)
14:13:58 <bolrod> yah... yah.. I made it look like osx >_>
14:14:03 <franka> I have to code in C++ now and I hate it.
14:14:19 <Phyx-> lol, same here, and they told me "the mac hater has a mac theme?"
14:15:15 <bolrod> haha
14:15:24 <bolrod> you're a mac hater?
14:15:52 <Phyx-> nah, i just hate it when people say "macs are better, macs are more secure" etc
14:16:00 <Phyx-> i like the eye candy, but that's it for me
14:16:17 <Phyx-> for me it's windows , linux, mac
14:16:23 <bolrod> O_o
14:16:27 <shapr> I like computers.
14:16:38 <bolrod> for me its   linux, then mac, THEN something else, THEN windows
14:16:42 <jcreigh> shapr: heh. Yeah, I'm a fan too. <g>
14:16:44 <shapr> For me it's Haskell!
14:17:05 * Muad_Dibber rudely points to #haskell-blah. :D
14:17:05 <shapr> hiya jcreigh, how's code?
14:17:06 <bolrod> I have to see that... an OS in Haskell
14:17:06 <bolrod> :p
14:17:13 <shapr> bolrod: Um, yes?
14:17:17 <shapr> http://www.cse.ogi.edu/~hallgren/House/
14:17:17 * bolrod rudely points back!
14:17:24 <SamB> bolrod: surely there are some further things that come after windows
14:17:25 <Phyx-> well, i correct myself
14:17:29 <Phyx-> for me it's windows , linux, bsd, mac
14:17:31 <Phyx-> lol
14:17:35 <shapr> http://www.cse.ogi.edu/~hallgren/House/P/screendump-oct2005.png
14:17:58 <Phyx-> btw, visual ghc crashes :|
14:17:59 <Phyx-> lol
14:18:00 <shapr> bolrod: C'mon, take the off-topic parts of the OS discussion to #haskell-blah
14:18:07 <Phyx-> brings down my visual studio like a ton of bricks
14:18:11 <Muad_Dibber> :)
14:18:12 <bolrod> kden
14:18:15 <Muad_Dibber> night people
14:18:18 <bolrod> gnite
14:18:20 <Phyx-> night Muad_Dibber 
14:18:24 <shapr> g'nite Muad_Dibber 
14:18:32 <shapr> franka: Doing nifty type theory?
14:18:48 <Phyx-> well, this hour was productive, i wrote 3 letters
14:18:50 <Phyx-> lol
14:19:02 <Philippa> Phyx-: "WTF"?
14:19:03 <franka> No, not at all.  Distributed computation.
14:19:11 <shapr> franka: oooh, tell me more :-)
14:19:19 <Phyx-> Philippa: no, "and"
14:19:24 <franka> Mobile channels.  Untyped.
14:19:35 <shapr> I've been trying to hack Oleg's HSXML code to automatically generate RSS from blog entries.
14:19:40 <shapr> franka: whoa nifty. Erlang?
14:19:47 <franka> C++.
14:19:49 <stepcut> shapr: sweet!
14:20:01 <Philippa> shapr: might be interested in seeing that code soonish. Just set up lighttpd on my comp and am playing with web stuff again...
14:20:04 * stepcut hopes to look at that HSXML code later this week
14:20:08 <Phyx-> hmmmm my irssi windows are in the wrong order
14:20:15 * Phyx- kicks irssi
14:20:33 <shapr> franka: For your research?
14:20:52 <franka> No, for my job, for Trust4All.
14:21:00 <franka> Actually, no, not for T4A.
14:21:05 <shapr> Philippa: In principle, it should be easy.
14:21:06 <franka> Only incidentally.
14:22:25 <shapr> g'day Pseudonym 
14:22:26 <Philippa> shapr: in practice I hate standards wars :-)
14:22:40 <Philippa> but if you've got sufficient "spit out RSS" code, all's cool, no?
14:22:50 <shapr> dons: oh HEY, I just figured out the armegeddon of lambdabot plugins! Integration with FRAG!
14:23:09 <Philippa> have vixen flirt with the player while kicking their arse, kind of thing?
14:23:13 <shapr> yes!
14:23:32 <Pseudonym> She's abusing me... but she's so cool!
14:23:45 <Pseudonym> I don't think lambdabot should encourage unhealthy codependence.
14:24:11 <shapr> lambdabot would be able to do the blow-by-blow announcer bit on IRC at the same time.
14:24:34 <Philippa> point, I suspect that's been done with UT but hey
14:24:50 <Philippa> (UT came with an IRC client, it would've been a fairly simple bit of UnrealScript to add)
14:24:53 <shapr> There are UT bots that integrate with irc?
14:24:55 <shapr> hm, yeah
14:25:45 <shapr> Pseudonym: Yeah, but pure abuse is okay.
14:33:19 <jcreigh> Recursive programming is fun. I write a function, test it, and then wonder where the rest of the code is. It can't be *that* short.
14:35:34 <Korollary> we're hiding it from the feds.
14:35:59 <Pseudonym> Give us the rest of the code and we won't shoot your teddy bear.
14:45:53 <mikezs> how can i do a reverse filter in haskell?
14:46:06 <mikezs> like filter isTrue xs
14:46:15 <mikezs> i want it when isTrue = false
14:47:00 <dcoutts> filter (not . p)
14:47:34 <dcoutts> filter (not . isTrue) xs
14:48:17 <mikezs> thanks :)
15:02:21 <TuringTest> Hmmm... Today my computer switched to BST and I did not notice.
15:02:33 * TuringTest resets his watch
15:04:09 * Pseudonym curses the Commonwealth Games
15:04:31 <Pseudonym> If it had been ONE DAY earlier, our summer time would be in sync with everyone else's.
16:04:18 <dons> moin
16:06:05 <Cale> moin
16:06:09 <Korollary> good \localtime
16:06:20 <Cale> \localtime Cale
16:06:39 <Cale> @bot
16:06:40 <lambdabot> :)
16:06:45 <Cale> @localtime Cale
16:06:46 <lambdabot> Local time for Cale is Sun Mar 26 19:06:24
16:07:15 <TuringTest> @localtime TuringTEst
16:07:23 <TuringTest> @localtime TuringTest
16:07:38 <TuringTest> Eh...I am now BST at 01:07
16:14:12 <Cale> http://fenris.res.cmu.edu/now.jpg -- hehe
16:19:01 <Korollary> go hw clock
16:29:51 <dons> poor hw clock
16:32:58 <TuringTest> hi dons
16:35:43 <TuringTest> dons: I saw you survive the blinding pain of the drop3 rewrite by simply not reading the Haskell and converting the OCAML.  Good strategy.
16:38:33 <Cale> drop3?
16:39:30 <dons> yeah. the Haskell gave me chills
16:40:00 <TuringTest> We were...saddened...on #haskell when we read that code
16:40:03 <dons> all the unused computations, that they thought would be used :( as well as the interleaved IO 
16:40:12 <dons> yeah. me too.
16:40:20 <dons> at least they knew to ask, though
16:40:21 <Cale> what is drop3?
16:40:26 <dons> but so far, no replies?
16:40:48 <TuringTest> I fail to understand how you they knew enough to get it to run at all but knew so little that they wrote...that
16:40:59 <TuringTest> Cale:  http://bitbenches.infogami.com/
16:41:07 <dons> Cale, last week, they asked for help
16:41:09 <TuringTest> From the mailing list a on the 22nd
16:41:36 <TuringTest> dons: No more activity on the list
16:41:36 <dons> oh, they took my drop3, I think
16:41:45 <dons> but haven't rewritten the others
16:42:25 <TuringTest> I could not test the huffman code I changes without their input file.  So I may have broken it.
16:42:37 <TuringTest> s/changes/changed/
16:42:58 <Korollary> This is a bizarre exercise altogether anyway.
16:43:06 <TuringTest> dons: I think they improve the five11 code
16:43:42 <dons> I thought maybe they were writing a paper, Korollary
16:43:50 <TuringTest> Korollary: Their haskell code inflicts sadness on those who read it.  It is ... different.
16:43:55 <dons> ah yes, the five11 looks better
16:44:09 <dons> well, it's speed does anyway.
16:44:19 <TuringTest> Korollary: they are modifying Erlang, and comparing it to other implementations.
16:44:20 <Cale> is the original code anywhere?
16:44:34 <Korollary> TuringTest: Ah. I see the agenda now.
16:44:46 <dons> looks like they based five11 on drop3?/
16:44:54 <Korollary> I should have guessed it from the column ordering heh.
16:45:33 <TuringTest> Korollary: look at the huffman Haskell code...
16:45:47 <TuringTest> (right hand column)
16:45:54 <Korollary> eek
16:46:25 <TuringTest> Yes... eek ... very sad
16:46:30 <Cale>     let 
16:46:30 <Cale>     'h' = (chr.fromIntegral) (readarr arr 0)
16:46:32 <dons> oh, I see they thank us for helping them ! :)
16:46:33 <Cale> wtf?
16:46:43 <Phyx-> how do i find the lenght of a list? lenght doesn't seem to exist
16:46:50 <Cale> Phyx-: length
16:47:00 <Phyx-> not in scope
16:47:02 <Cale> > length [1,2,3,4,5]
16:47:03 <lambdabot> 5
16:47:10 <Cale> not lenght
16:47:12 <Phyx-> wha do i need to import then?
16:47:16 <Phyx-> ohh
16:47:17 <Cale> it's in the Prelude
16:47:17 <Phyx-> :|
16:47:23 <Phyx-> bah, typos
16:47:24 <dons> The Haskell versions of drop3 and five11 have now been improved and the numbers are closer to what one would expect, uuencode, uudecode and huffman will be improved shortly.Thanks to the people at haskell-cafe for helping me understand how to write more efficient  HAskell programs.
16:47:28 <TuringTest> Cale: They got it work in Haskell without understanding Haskell.  It is quite an achievement, of some description.
16:47:29 <Phyx-> think 2:46am might be my limit
16:47:35 <dons> so good then.
16:48:01 <dons> yeah, it's just close enough to erlang that you can translate, barely
16:48:08 <dons> like speaking italian when all you know is spanish
16:48:20 <Cale> do_iter looks insane
16:48:26 <TuringTest> I don't speak either and I am going to Rome...hmm....
16:48:38 <TuringTest> Cale: do you feel the sadness yet?
16:49:03 <Korollary> I wonder once they figure out how to write decent haskell if any one of them quits erlang ;)
16:50:05 <TuringTest> Korollary: I would not care to estimate how long that will take.
16:50:24 <Cale> meh, if they're interested, it shouldn't take too long
16:50:29 <Cale> (comparatively)
16:58:41 <dons> yeah, I mean, they wrote five11, no?  (Or was that you TuringTest?)
17:00:33 <TuringTest> not me
17:01:44 <TuringTest> Their next line in the table is huffman.  I expect they are going to ignore my code and do the same kind of rewrite as five11.
17:02:46 <dons> I think they should have done that from the start. it's been an effective technique from the shootout
17:03:24 <dons> hmm. five111 stiill has a space leak
17:03:37 <dons> my machhine is crawlingg/swapping can't type
17:04:40 <dons> and they've got random unsafePerformIOs inserted :(
17:05:08 * TuringTest sees it s 2 am and calls it a night.
17:05:41 <dons> night
17:06:16 * dons fires up lambdabot on the five11 src
17:06:28 <Korollary> heh
17:15:13 <Spark> whats the opposite of covariant
17:15:31 <Spark> when you talk about subsumption of arrow types
17:15:39 <Spark> the return type is _ and the argument type is _
17:16:00 <Spark> contravariant thats it
17:26:03 <dons> they're teaching Haskell in Malta?
17:26:04 <dons> cool
17:27:16 <mwc> mmmm. Malt haskell
17:29:47 <dons> but apparently none of the students can do the assignment?
17:32:07 * Phyx- hates the layout rule in haskell
17:32:41 <dons> I don't even notice it any more. I think it just takes getting used to.
17:33:27 <Phyx-> well.. hope i get used to is soon
17:35:56 <Phyx-> dons: care to take a look? http://pastebin.com/624244
17:37:16 <palomer> hrmph
17:37:22 * palomer wonders how to put a bar over a bunch of text in latex
17:37:34 <ncalexan> \overbar
17:38:03 * Phyx- wonders if anyone can help him :P
17:38:06 <Lemmih> Phyx-: You need 'then do ...'
17:38:07 <dons> sure
17:38:43 <Phyx-> Lemmih: infront of the putStrLn?
17:38:45 <Lemmih> Phyx-: And you can't have an 'if' without an 'else'.
17:38:57 <Phyx-> i have an else
17:38:59 <palomer> overbar?
17:39:03 <Phyx-> for both ifs
17:39:17 <Lemmih> Phyx-: Ah, right.
17:39:42 <Lemmih> I usually indent them differently.
17:40:11 <Phyx-> heheh
17:40:22 <Phyx-> me 2, first time i did it like this
17:40:35 <Phyx-> must be a night thing
17:43:53 <dons> Phyx-C[C[C[C[C[C[C[C, I pasted an improvement
17:43:56 <dons>  http://pastebin.com/624253
17:44:32 <dons> at least, that's how i'd format it.
17:46:40 * Phyx- looks
17:46:48 <Phyx-> [c[c[c? lol
17:48:00 <dons> tiny tweak, if you're interested, http://pastebin.com/624255
17:48:27 <dons> oh, my wireless played a little disconnection game
17:49:23 <palomer> overline
17:49:24 <Phyx-> lol
17:50:09 <Phyx-> dons: yeah, the reason why i can't is that i just used the "Ok, Let's go" to debug, that else isn't supposed to print anything
17:51:05 <Phyx-> i can make use of the compose though
18:01:50 * Lemmih plots a 'breakpoint' function which jumps out to ghci with all local bindings in scope.
18:15:41 <sjanssen_> is there a function that is something like "hPutWords :: Handle -> [Word8] -> IO ()" ?
18:17:17 <palomer> Cale: you around?
18:18:19 <jedi> hi all, sorry if this isn't an appropriate place to be asking, but is there any news on GHC running on intel macs?
18:19:47 <Philippa> 'mnot aware of someone having got round to it
18:20:07 <Philippa> OTOH I wouldn't expect it to be overly hard for someone who's used to building GHC on (mildly) new platforms
18:20:28 <jedi> hrm ok
18:21:02 <Philippa> mix of an OS we have a port for on another instruction architecture and the most common instruction architecture
18:21:18 <jedi> yeah
18:21:44 <jedi> i'm just in a bit of a pickle because i don't have darcs available
18:22:06 <jedi> not to mention i can't hack haskell code easily
18:23:00 <Philippa> ouch
18:23:29 <sjanssen_> the PPC emulation doesn't work?
18:23:52 <Philippa> point
18:24:00 <Philippa> though in the long run a native build'd be desirable anyway
18:24:11 <jedi> that's something i've been considering trying... i previously used darwinports
18:27:56 <Igloo> If you have a platform on which GHC is already ported then I would expect it would be easy to get an unregisterised port by following the instructions in the building guide
18:56:36 <dons> sjanssen_, hPut is close. In fact, if you use fps, hPut h . packWords has your type.
19:41:48 <Marudubshinki> Is anyone here familiar with the Haskell wiki?
19:42:59 <Lemmih> Somewhat.
19:42:59 <dons> yes
19:43:18 <Marudubshinki> When I went there to do some reading, I thought for the life of me that it was running on a mediawiki engine, and that I knew what I was doing
19:43:18 <dons> it is using mediawiki
19:43:18 <Marudubshinki> but then I took a look at the intro page, and the formatting there was some of the weirdest I've ever seen
19:43:19 <Marudubshinki> are the contributors incompetnent at wikimarkup or something?
19:43:19 <dons> nope.
19:43:20 <dons> some of the pages are legacy ports from the old weebsite
19:43:21 <dons> they don't always translate well.
19:43:21 <Marudubshinki> that explains all the HTML I guess
19:43:42 <Marudubshinki> thanks. I was going to run some search replaces, and I wanted to be sure I wasn't messing up some intricate and brilliant  formatting scheme
19:44:04 <dons> (mediawii version of haskell.org is only a month old)
20:01:23 <Lemmih> dons: ping.
20:01:52 <dons> yo
20:04:04 <adu> haskell rocks!
20:04:26 <Lemmih> (re dynamic applications from the ground-up) The reason the pass the 'loader' function to the dynamic main instead of the global environment is to avoid linking with hs-plugins twice (one statically, one dynamically), right?
20:04:41 <dons> yep
20:05:34 <dons> you only have the loader in the static code. it's nice and clean that way
20:05:47 <dons> linking the linker dynamically might be a bit unstable. it doesn't work on windows, at least
20:05:57 <dons> and needed Linker.c patches to work on unix
20:06:30 <Lemmih> Really? Doesn't it work in GHCi?
20:07:12 <dons> becaues the ghc linker and hs-plugins need to have the same idea about what packages are loaded.
20:07:12 <dons> yes it does wrork
20:07:12 <dons> but it needed a patch to Linker.c
20:07:12 <dons> any packages loaded by ghci before hs-plugins is loaded dynamically are unknown to hs-plugins -- which might then try to load them twice
20:07:19 <dons> resulting in errors. (or silently ignoring them in the rts on unix now)
20:07:51 <Lemmih> In hIDE, I pass a list of loaded packages to the dynamic main which then show them as loaded to the GHCi linker.
20:13:50 <sethk> dons, is there any way to allow comments in a file (or stream) containing a type of a record value?
20:14:00 <sethk> dons, containing a value, that is
20:14:03 <dons> ah, so you inform the linker? or it informs you?
20:14:12 <dons> sethk, don't know. never tried it.
20:14:28 <sethk> dons, doesn't work the obvious way, I wondered if there is a less obvious way
20:15:04 <dons> you could have a Comment field though
20:15:04 <dons> or preprocess the file before reading it..
20:15:16 <dons> read . filter (prefix /= "--"
20:15:18 <sethk> dons, yes, that's true
20:15:26 <sethk> dons, that's what I'll do, then.
20:15:37 <Lemmih> dons: I inform the linker.
20:16:47 <Lemmih> (well, I pass the info from the first linker to the second)
20:17:10 <dons> > filter (not . List.isPrefixOf "--" ) ["-- foo", "x y z"]
20:17:11 <lambdabot> ["x y z"]
20:17:43 <twobitsprite> how hard do you think it would be to generate haskell programatically?
20:17:47 <dons> Lemmih, iteresting. could we rip this code out into a portable library depending on ghc-api?
20:17:55 <twobitsprite> s/haskell/haskell code
20:17:57 <dons> twobitsprite, like with TH?
20:18:06 <dons> we have a whole language for it :)
20:18:11 <dons> so, I would saay, easy.
20:18:16 <twobitsprite> dons: I suppose... maybe I'll look into it
20:18:31 <dons> \where TH
20:18:38 <twobitsprite> is the generated code compiled or interpreted via some eval function?
20:19:54 <Lemmih> dons: Yeah, I think so.
20:20:00 <twobitsprite> I don't know if you've heard me talk about it, but I'm working on a genetic programming AI, and I'm thinking might just be better to generate compiled code as opposed to coming up with my own language and then interpreting that...
20:20:12 <twobitsprite> you think TH might be suited for that?
20:20:34 <dons> it's a metaprogramming language for generating Haskell.twobitsprite, yes. via ghci (inside ghc)
20:20:38 <dons> ?where THoh, you want an embedded dom
20:20:38 <lambdabot> I know nothing about thoh,.
20:20:39 <dons> grr.
20:20:41 <dons> ain specific language
20:20:47 <dons> you want an embedded domain specific language
20:20:54 <dons> google for EDSL Haskell
20:21:09 <dons> it's a wide field of study -- embedding languages inside haskell to avoid writing interpreters for new langs
20:21:39 <dons> I would think Haskell would be very suitable for this, for an AI app.
20:22:33 <twobitsprite> edsl seems to be "eduacation domain-specific languages"...
20:22:35 <Lemmih> twobitsprite: Seen parsec? It's an EDSL.
20:22:45 <dons> this guy has some links that might be useful: http://www.cse.unsw.edu.au/~sseefried/files/papers/seefried04th-pan.ps
20:22:53 <dons> that's about an EDSL for graphics
20:23:09 <dons> (it also uses TH to optimise the EDSL code, but that's not always necessary)
20:23:27 <twobitsprite> and this code would be compiled code?
20:23:37 <dons> basically, in Haskell, a well-crafted library with infix operators and higher-order functions for control flow, appear as a new language
20:23:52 <dons> which is then compiled with ghc
20:24:21 <dons> if you need new bits of EDSL code compiled at runtime, use hs-plugins 'make' function would be one way.
20:24:38 <twobitsprite> dons: I suppose your right... I'm just wondering how much reflection haskell has in order to be able to randomly generate and then mutate functions, etc...
20:24:51 <dons> the above paper is titled "Optimising Embedded DSLs using Template Haskell."
20:25:07 <twobitsprite> ?where hs-plugins
20:25:07 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
20:25:07 <dons> randomly generate? mutate functions?
20:25:07 <dons> at runtime -- hard
20:25:08 <dons> at compie time -- easy
20:25:17 <dons> compile time. 
20:25:31 <dons> you'd use TH. but I think maybe all you need is an EDSL. not necessarily metaprogrammign support
20:26:06 <dons> read up a bit on EDSLs and metaprogramming to get an idea of the waters you're wading into.
20:26:22 <dons> the above paper should have some good links
20:26:23 <twobitsprite> dons: well... I don't need to mutate the functions as they're running... just to be able to mutate and re-compile, i.e.
20:29:15 <twobitsprite> maybe I'll just learn about TH in general for now, becuase I'm not sure I'm fully understanding how this all works....
20:29:23 <dons> yeah, it's a pretty huge area of research. there are whole conferences on generating programs with programs
20:29:47 <twobitsprite> sorry if I seem a bit ignorant, but I have no formal education on any of these matters... I'm a self-taught programming that is currently self-teaching myself haskell, GA/GP and AI theory in general all at the same time :P
20:31:03 <dons> no no. we're all about learning here.
20:32:41 <twobitsprite> you all are much friendlier than the people in Scheme... I caught a lot of flak in there for being uneducated...
20:32:44 <twobitsprite> er, #scheme
20:33:06 <audreyt> twobitsprite: #haskell is really extremely friendly :)
20:33:08 <audreyt> <- was the village idiot of #haskell for some time ~1yr ago
20:33:33 <dons> i'm just hinting that your problem may have a standard solution, and it might be useful to google a bit
20:33:33 <twobitsprite> dons: I'm googling alright :)
20:33:44 <dons> somewhere aong the line lambdabot became to complex to load into ghci :(
20:34:09 <twobitsprite> dons: still not entirely sure what I should be googling/etc, but I'm googling still :)
20:34:25 <twobitsprite> dons: lambdabot is your creation?
20:34:30 <dons> audreyt, but you just persisted until you were writing type Eval x = forall r. ContT r (ReaderT x IO) (ReaderT x IO x)
20:34:43 <dons> I have maintained it for the last 3 or so years
20:35:01 <dons> twobitsprite, google for "EDSL" and "Haskell" first I think
20:35:09 <dons> then look into "metaprogramming" "Haskell"
20:35:18 <dons> maybe check "scholar.google.com" for some papers on the subject
20:35:37 <dons> lots of really smart people have written papers on this stuff. it's hard to get into, but it will be worth it.
20:35:47 <twobitsprite> ahh! I've never heard of scholar.google.com... :P
20:36:01 <dons> (unfortunatel/ or fortunately, a lot of Haskell docs  are actually scientific papers :)
20:36:19 <twobitsprite> I've noticed :P
20:36:31 <dons> a good trick is to read the scholar.google.com refs that have the most citations. 
20:36:36 <dons> they're probably fundamental in some way
20:36:51 <twobitsprite> in fact, that had deterred me from learning it for a long time, unfortunately... but now that I'm grokking some of it, I can actually read some of the papers...
20:37:04 <dons> we do have docs on the web -- normal docs
20:37:25 <dons> but the advanced stuff is advanced for any programmign language. it's cutting edge research.. so it gets published.
20:38:01 <audreyt> ...but it's all greek to me
20:38:46 <twobitsprite> dons: yar... haskell.org has been a monumental help so far
20:38:46 <dons> the more papers you read the more you become familiar with the concept-space (I just made that up) that the academic papers inhabit
20:38:46 <dons> and the more they make sense
20:38:46 <audreyt> (especially those papers about the typesystems, they are _all_ greek)
20:38:47 <dons> yep
20:38:47 <dons> type-system porn
20:38:58 <twobitsprite> heheh
20:38:58 <dons> a double-page spread of static semantics :S
20:39:07 <twobitsprite> I'm still tackling monads... think I should become more familiar with those kind of fundamentals before I start diving into metaprogramming? :P
20:39:46 <Saulzar> monads are a good example of ways to construct a DSL
20:40:08 <twobitsprite> I mean... I definately grok the concept now, and I know how they work, but I have some code that I'm pretty sure can be refactored into monadic style but am not sure how to approach that...
20:42:38 <eivuokko> Is there a word/term for strictness where, say, list constructors are strict/evaluated for all of list, but actual data is still lazy/unevaluated?
20:47:20 <eivuokko> I guess not.  No wonder strictness/laziness causes problems if there aren't good and accepted words to use! :)
20:47:59 <Korollary> eivuokko: I didn't even understand your question.
20:48:25 <rasfar> eivuokko: "evaluators" and "evaluation transformers"
20:48:38 <eivuokko> Ehm
20:49:01 <eivuokko> let foo = lazy_build_list; bar = seq (length foo) foo in ..
20:50:21 <dons> strict in the spine of the list?
20:50:22 <eivuokko> What would you call the amount of evaluation, strictness, laziness in that list now?
20:50:25 <eivuokko> Spine!  Thanks
20:50:25 <dons> or you talk about the normal form the data is in
20:50:25 <dons> weak head, etc..
20:50:25 <eivuokko> Ehm
20:50:25 <eivuokko> Yeah
20:50:31 <eivuokko> But that isn't intuitive for others than CS people.
20:50:39 <eivuokko> (And I doubt it is even for all of them)
20:51:13 <eivuokko> I am searching good set of words to use in docs at work, as I hope to get haskell into use.
20:51:18 <dons> should be ok for haskell programmers.
20:51:21 <tennin> it seems to me that usually the needs of a computer writing code are very different than the needs of a human writing code
20:51:23 <dons> WHNF is in the h98 spec
20:52:28 <eivuokko> WHNF isn't even in all of (basic) related books I think...
20:52:32 <dons> eivuokko, yeah. I agree this will be hard to translate to non-experts
20:52:32 <dons> metaphors might be helpful
20:52:36 <twobitsprite> tennin: are you referring to what I was talking about earlier?
20:52:38 <tennin> so,  the EDSL/monads etc. should work better than the template/Lisp-style approach for most things
20:52:41 <tennin> yeah
20:52:50 <tennin> I don't know what I'm talking about though, so don't pay any attention =)
20:54:19 <twobitsprite> tennin: no, I completely agree... I thought about this same problem...
20:54:19 <twobitsprite> I've*
20:54:22 <twobitsprite> tennin: but I'm still not sure of what that solution would actually "look" like... I.e. would it be lists and trees of functions? or something a bit more sophisticated...
20:56:00 <dons> wouldn't it look like the AST for your program
20:56:07 <dons> like the TH data type
20:56:12 <dons> so a list of top level decls
20:57:18 <twobitsprite> each decl being a tree of sorts? where each leaf is either literal data or a "built-in" function/etc?
20:58:06 <dons> ?libsrc Language.Haskell.Syntax
20:58:07 <lambdabot> http://darcs.complete.org/fptools/libraries/haskell-src/Language/Haskell/Syntax.hs
20:58:12 <dons> check that out
20:58:26 <twobitsprite> not found
20:58:34 <dons> data HsExp
20:58:34 <dons>     = HsVar HsQName         -- ^ variable
20:58:34 <dons>     | HsCon HsQName         -- ^ data constructor
20:58:34 <dons>     | HsLit HsLiteral       -- ^ literal constant
20:58:35 <dons> ...
20:58:38 <dons> and so on
20:58:41 <dons> ah, ok.
20:58:51 <dons> let me see...
20:59:34 <twobitsprite> (btw... I like that indentation style... ocaml people didn't like it when I did stuff like that :P)
20:59:49 <Korollary> there are people in #ocaml?
21:00:01 <audreyt> I like this style:
21:00:08 * twobitsprite checks
21:00:08 <audreyt> data Foo
21:00:08 <audreyt> err
21:00:10 <audreyt> data HsExp =
21:00:14 <audreyt>     | HsVar HsQName
21:00:17 <audreyt>     | HsCon HsQname
21:00:18 <audreyt> etc
21:00:27 <twobitsprite> you can have a leading '|'?
21:00:28 <Lemmih> That's legal?
21:00:29 <Korollary> minor difference
21:00:29 <audreyt> too bad it's not valid Hs (but is valid P6) :p
21:00:33 <twobitsprite> ahh
21:00:38 <twobitsprite> it's valid Ocaml... :P
21:00:44 <twobitsprite> (well... almost)
21:01:58 <twobitsprite> I didn't realize P6 had any kind of type system like that...
21:02:00 <dons> here it is: haskell support for generating programs: http://darcs.haskell.org/packages/template-haskell/Language/Haskell/TH/Syntax.hs  
21:02:00 <audreyt> it is somewhat inconvenient that leading | and trailing , are illegal in hs
21:02:00 <dons> I should fix ?libsrc
21:03:53 <dons> ?quit  new help support
21:03:53 <dons> ?help 
21:03:57 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:04:00 <dons> ?list
21:04:00 <lambdabot> list [module|command]. Where modules is one of:
21:04:01 <lambdabot> babel base compose dice dict djinn dummy dynamic elite fact haddock help hoogle karma lambda localtime log more pl plugs poll pretty quote search seen slap spell state system todo topic type unlambda version vixen where
21:04:08 <dons> ?list babel
21:04:08 <lambdabot> babel provides: babel
21:04:14 <dons> ?help babel
21:04:14 <lambdabot> babel <lang1> <lang2> <phrase>.
21:04:14 <lambdabot> [3 @more lines]
21:04:18 <dons> ?more
21:04:18 <lambdabot> Translate a phrase in lang1 to lang2.
21:04:18 <lambdabot> Language is an element of
21:04:18 <lambdabot> "german","de" "greek","el" "english","en" "spanish","es" "french","fr" "italian","it" "dutch","nl" "portuguese","pt"
21:04:48 <twobitsprite> ?babel english pt I like fish
21:05:57 <lambdabot>  Eu gosto de peixes
21:05:57 <dons> ?version
21:05:57 <twobitsprite> what is "pt"?
21:05:57 <Korollary> portuguese
21:05:57 <twobitsprite> ahh
21:05:57 <twobitsprite> er. I see :P
21:05:57 <Pseudonym> How come the command symbol keeps changing?
21:05:57 <twobitsprite> @version
21:05:57 <lambdabot> lambdabot 3p358, GHC 6.4.1 (Linux i686 3.20GHz)
21:05:57 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:05:57 <Pseudonym> Do @, \ and ? all work?
21:05:57 <Pseudonym> \version
21:05:57 <twobitsprite> \version
21:05:57 <twobitsprite> :P
21:05:57 <Pseudonym> ?version
21:05:57 <lambdabot> lambdabot 3p358, GHC 6.4.1 (Linux i686 3.20GHz)
21:05:57 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:05:57 <Pseudonym> Hmmm.
21:05:57 <Pseudonym> I thought \ did work for a while.
21:06:08 <twobitsprite> \eval [1..4]
21:06:14 <Korollary> it's a major ui issue. We need a guy from Apple.
21:06:27 <dons> Pseudonym, you can use @ ? or ! 
21:06:36 <twobitsprite> !version
21:06:42 <Korollary> for a aqua-themed backslash
21:06:43 <twobitsprite> or not?
21:06:56 <twobitsprite> Korollary: lol
21:06:58 <twobitsprite> ack... time for bed...!
21:08:37 <twobitsprite> thanks a ton for the links dons... I'm sure they'll provide hours of headaches for me :)
21:08:42 <dons> some people complained about \ and . so I removed them
21:08:42 <dons> oh, maybe you can't use !
21:08:42 <Korollary> #haskell, serving baffling links since 1897
21:08:45 <twobitsprite> Korollary: wow... #haskell was founded before IRC? (or even PC's)?
21:08:45 <dons> I did like \ but yesterday Saulzar petitioned me with a list of 4 signatures asking to remove it
21:08:45 <Korollary> lol
21:08:45 <dons> it was founded when Frege first got his act together
21:08:45 <Saulzar> Type signatures? :)
21:08:51 <dons> though you had to use pidgeons back then
21:09:00 <Korollary> was there a #haskell before haskell98?
21:09:25 <twobitsprite> unless the 98 refers to 1798...
21:09:42 <twobitsprite> anyways... bed!
21:09:44 <twobitsprite> laterz
21:09:49 <Korollary> nyte
21:10:18 <Descoloda> data RealFloat a => Vector3 a = Vector3 !a !a !a deriving Eq what does the ! mean?
21:10:26 <Korollary> strictness annotation
21:11:35 <Descoloda> that does.... ?
21:11:35 <Korollary> evaluate the 'a's strictly instead of lazily
21:11:54 <Descoloda> ok
21:19:17 <dons> ?faq
21:19:24 <lambdabot> The answer is: Yes! Haskell can do that.
21:35:40 <dons> ?quit lambdabot goes on a diet
21:41:58 <dons> ?version
21:41:59 <lambdabot> lambdabot 3p361, GHC 6.4.1 (Linux i686 3.20GHz)
21:41:59 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:55:35 <davidmccabe> is a four line flood ok?
21:55:35 <davidmccabe> five line, actually.
21:56:12 <davidmccabe> nm, http://pastebin.com/624487
21:56:12 <davidmccabe> (the question is contained in the paste itself)
21:56:58 <flux__> you know, you could've just made a one-line question of that
21:57:14 <flux__> I would pick the newest release version
21:57:47 <Lemmih> davidmccabe: ghc6
21:58:16 <davidmccabe> flux__: not with the specific versions.
21:58:43 <davidmccabe> thanks for the info, though.
22:07:02 <sjanssen> dons: have you (or anyone else) tried rewriting huffman from bitbenches.infogami.com ?
22:21:24 <dons> nope. but it says on the page that they'll do it, I think
22:21:36 <dons> they rewrote five11 in the style of drop3
22:21:45 <dons> and thank haskell-cafe@ for their help
22:22:24 <sjanssen> ah, I think my huffman is as fast as the erlang one
22:22:32 <dons> ah, well, submit it!
22:23:01 <dons> I suspect if they told us the spec we could write faster programs
22:23:16 <dons> translating algos from ocaml takes  longer to rediscover the spec and optimise, I've found
22:23:28 <dons> though you get something pretty decent immediately
22:23:42 <dons> I think they do take complete rewrites
22:24:23 <sjanssen> the huffman spec is pretty decent
22:24:30 <rep> tonight is the night when two become one
22:24:34 <dons> oh ok. :) how'd you speed it up?
22:25:06 <dons> anything I could apply to the drop3 code?
22:25:21 <sjanssen> nothing special, I'll put it on the web in a second
22:26:38 <palomer> yay for haskell!
22:26:52 <palomer> is any work being done on yi?
22:26:59 <sjanssen> http://cse.unl.edu/~sjanssen/huffman.hs
22:27:10 <dons> oh, i forgot to do CSE on drop3. that'd explain the slowdown
22:38:36 <dons> sjanssen, you should add an -funbox-strict-field and -O2 to the top of the file (in case they forget to add it themselves)
22:39:22 <dons> -fields, I mean
22:41:19 <davidmccabe> http://pastebin.com/624523
22:42:29 <dons> should you include the writeFile in the cpuTime sjanssen?
22:42:32 <dons> writeFile (f ++ ".haskell")
22:42:41 <dons> should that not be factored out, and just write the last result
22:42:57 <sjanssen> actually, I'm not sure
22:43:45 <dons> use head .  replicateM  or similar
22:43:45 <dons> I think you're never supposed to include IO time
22:43:45 <davidmccabe> sorry, nm about that paste above.
22:44:07 <sjanssen> decode is pure, how can I make sure that each run is really evaluated?
22:44:33 <dons> grr. stupid test.
22:44:38 <dons> you'll have to seq.
22:44:57 <dons> compute the length of the result, for example
22:45:48 <dons> also, unsafeRead/unsafeWrite are often much faster than !
22:45:48 <dons> (though more ugly, admittedly)
22:45:48 <dons> but you're getting a bounds check on every ! otherwise
22:46:34 <sjanssen> hmm, this could become very fast . . .
22:47:20 <dons> writeFile on [Char] is not as  effiicient as a single hPut of aan UArray, if you can do that
22:47:32 <dons> (though once again, IO shouldn't count)
22:48:07 <sjanssen> the only problem with using an array is that I don't know the size of the output beforehand
22:48:36 <sjanssen> is it still faster to find the length of my output, then put it in an array?
22:49:02 <dons> hmm. 
22:49:03 <dons> if you can ensure that the writefile is outside of the cputTime, then no.
22:49:10 <dons> computing it lazily would be ok, i think
22:51:03 <sjanssen> GHC won't get too smart and optimise "map f $ replicate n x" into "replicate n (f x)", will it?
22:51:42 <dons> could you not: replicate evaluate ?
22:51:47 <dons> sorry, replicateM evalaute
22:52:33 <Korollary> Their five11 C entry is very suspicious.
22:52:33 <sjanssen> replicateM is out, because the actual computation is pure
22:52:47 <dons> > replicateM 10 (Control.Exception.evaluate $ 1+2) >>= print
22:52:48 <lambdabot>  Not in scope: `Control.Exception.evaluate'
22:53:00 <dons> it's not you, because you can lift into IO.
22:53:04 <dons> s/you/out
22:53:45 <dons> well, maybe
22:53:54 <dons> I say take advantage of the purity ;)
22:54:23 <dons> or, replicateM 10 (1+2 `seq` return ())
22:54:27 <Korollary> dons: any idea (it's been ages) why the shootout pure mandelbrot entry was so slow?
22:54:27 <dons> is another option
22:54:33 <dons> nope.
22:54:38 <dons> couldn't work it out
22:54:43 <dons> it should run like ocaml
22:55:00 <Korollary> did the Simons see it?
22:55:25 <dons> how many constraints are too many? 
22:55:27 <dons> (MArray a3 b m, Ix i, Integral a2, Num b, Bits a2, Bits a, Integral a, Num a1) =>
22:55:59 <Korollary> that's a long type sig
22:56:14 <dons> which reminds me that adding explicit sigs is good for code generation
22:56:43 <Korollary> yes
23:08:31 <davidmccabe> in the expression:   parseNumber = liftM (Number . read) $ many1 digit
23:08:41 <davidmccabe> I'm having trouble figuring out what order the functions are being called in.
23:09:21 <davidmccabe> is it something along the lines of (liftm (Number (read (many1 digit))))?
23:13:03 <Korollary> My guess:
23:13:18 <Korollary> liftM, (Number . read), (many1 digit)
23:13:32 <davidmccabe> so what exactly is liftM being applied to?
23:13:43 <Korollary> (number . read)
23:13:53 <davidmccabe> which is being applied to (many1 digit), right?
23:13:57 <Korollary> yes
23:14:05 <Korollary> $ is right assoc, lowest prec
23:16:25 <davidmccabe> however, this doesn't work:
23:16:30 <davidmccabe> parseNumber = do str <- (many1 digit)
23:16:30 <davidmccabe>                  int <- read str
23:16:30 <davidmccabe>                  num <- Number int
23:16:30 <davidmccabe>                  liftM num
23:16:30 <davidmccabe>  
23:16:30 <davidmccabe> (don't laugh; the exercises is to figure out what the expression does and rewrite it in do notation)
23:16:30 <Korollary> @type read
23:16:30 <lambdabot> forall a. (Read a) => String -> a
23:16:46 <Korollary> read's type is not IO, so I don't know why "int <- read str" is there. maybe "let int = read str" was meant.
23:17:33 <davidmccabe> ahh, it may be.
23:17:33 <Korollary> same goes for the others
23:17:35 <Korollary> Number int looks like a value constuctor, so no <-.
23:17:49 <davidmccabe> I hadn't noticed the different. let's see if I can make it work now.
23:19:45 <Lemmih> davidmccabe: 'pat <- expr' is used when 'expr' has the type 'm a' and you're interested in the 'a'.
23:20:23 <Lemmih> davidmccabe: 'many1 digit' has the type 'Parser String', iirc.
23:20:37 <davidmccabe> @type liftM
23:20:38 <lambdabot> Not in scope: `liftM'
23:20:45 <davidmccabe> @type Monad::liftM
23:20:46 <lambdabot> Not in scope: data constructor `Monad'
23:20:48 <davidmccabe> @type Monad.liftM
23:20:49 <lambdabot> forall r (m :: * -> *) a1.
23:20:49 <lambdabot>      (Monad m) =>
23:20:49 <lambdabot>      (a1 -> r) -> m a1 -> m r
23:20:53 <davidmccabe> hurrah.
23:27:52 <neologism> an article teaching people how code recursively in C++ ;)
23:28:56 <davidmccabe> IT COMPILES! HALLELUJAH!
23:29:53 <davidmccabe> I didn't realize that liftM wants the function itself as an argument; it doesn't just filter what comes out of the function.
23:32:07 * JKnecht wonders if there's a Haskell equivalent of Opal or Magma, i.e. an Algebraic programming package.
23:41:02 <shapr> DoCon?
23:43:49 <JKnecht> yes, that's it, thanks Shae!
23:52:11 <dons> JKnecht, also, you might want to check out the maths sectionn of haskell.org, 
23:55:44 <dons> \wiki Libraries_and_tools/Mathematics
23:57:09 <shapr> dons: Hey what do you think about a frag plugin for lambdabot?
