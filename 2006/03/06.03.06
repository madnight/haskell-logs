00:39:53 <jonkri> i take it i can use "if" in a "do" statement?
00:40:03 <integral> yep
00:40:15 <jonkri> ok, then i'm doing something wrong. thanks
00:40:55 <integral> > do { x <- [1,2,3]; if x > 2 then return 5 else return 2 }
00:40:56 <lambdabot> [2,2,5]
00:41:15 <integral> jonkri: are you using layout for your if statement?
00:42:04 <resiak> I really should look at list-as-monad some more
00:42:05 <jonkri> i tried simplifying it
00:42:07 <jonkri> hej :: Int -> IO Int
00:42:08 <jonkri> hej a = do
00:42:08 <jonkri>   if a == 5 then a == 3
00:42:08 <jonkri>   return a
00:42:21 <integral> *blink*
00:42:33 <integral> (a == 3) isn't in the IO monad
00:42:34 <jonkri> i get parse error (possibly incorrect intendation)
00:42:48 <integral> and you've got no else clause
00:43:00 <integral> maybe you wanted Control.Monad.when, but maybe not
00:43:11 <jonkri> whoops
00:43:30 <kosmikus> and there's no reason why this should be in the IO monad at all
00:43:34 <jonkri>  if a == 5 then a = 3 else a = 5
00:44:01 <jonkri> i know, i'm just trying to learn how this works
00:44:37 <ndm> and there is no destructive assignment
00:44:44 <ndm> no concept of a = 3 as an assignment
00:44:49 <ndm> if a == 5 then 3 else b
00:44:51 <kosmikus> a <- if a == 5 then return 3 else return 5
00:45:06 <jonkri> aha, ok
00:45:25 <resiak> or just hej a = if a == 5 then return 3 else return 5 , surely?
00:45:53 <jonkri> ah, i get it
00:46:38 <integral> IMHO that'd be prettier with guards
00:46:55 <jonkri> integral, of course
00:57:53 <Phyx-> hello guys, i'm back :P
00:58:39 <Phyx-> is there an easy way to sort this? http://www.rafb.net/paste/results/DuF73469.html
00:58:52 <Phyx-> based on the biggest number in the last field?
00:59:11 <wilx> sortBy?
00:59:15 <wilx> @type sortBy
00:59:15 <lambdabot> Not in scope: `sortBy'
00:59:25 <wilx> @type Data.List.sortBy
00:59:25 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
01:00:08 <Phyx-> wow? helium actually has it
01:03:06 <Phyx-> wilx: pardon me sir, but how do you use it?
01:03:34 <rep> > (\n -> $ (-) n 1) 2
01:03:34 <lambdabot>  parse error on input `$'
01:03:56 <xerox> :)
01:04:26 <wilx> Phyx-, give the appropriate comparator as the first argument to sortBy.
01:04:46 <mauke> > sortBy (flip compare) ["foo","bar","baz"]
01:04:47 <lambdabot> ["foo","baz","bar"]
01:05:24 <Phyx-> :t flip
01:05:28 <Phyx-> oops
01:05:31 <Phyx-> @type flip
01:05:32 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
01:05:36 <xerox> > sortBy (flip compare) [1..10]
01:05:37 <lambdabot> [10,9,8,7,6,5,4,3,2,1]
01:05:40 <xerox> Yay.
01:05:43 <Phyx-> hehe
01:05:52 <mauke> @jinn forall c a b. (a -> b -> c) -> b -> a -> c
01:05:52 <lambdabot> -- f cannot be realized.
01:05:54 <wilx> @type sortBy (\(_,_,_,a) (_,_,_,b) -> compare a b) your_list
01:05:54 <lambdabot> Not in scope: `sortBy'
01:05:54 <lambdabot>  
01:05:54 <lambdabot> <interactive>:1:45: Not in scope: `your_list'
01:06:00 <wilx> @type Data.List.sortBy (\(_,_,_,a) (_,_,_,b) -> compare a b) your_list
01:06:00 <lambdabot> Not in scope: `your_list'
01:06:03 <flux__> > let sortOn f = List.sortBy (\a b -> compare (f a) (f b)) in sortOn snd [(1, 2), (5, 1), (7, 5)]
01:06:05 <lambdabot> [(5,1),(1,2),(7,5)]
01:06:10 <mauke> why can't it realize f?
01:06:11 <xerox> @djinn (a -> b -> c) -> b -> a -> c
01:06:12 <lambdabot> f a b c = a c b
01:06:20 <xerox> It doesn't parse foralls.
01:06:24 <wilx> Anywya, I would try this: sortBy (\(_,_,_,a) (_,_,_,b) -> compare a b) 
01:06:28 <mauke> then it should give me a syntax errors
01:06:30 <mauke> s/s$//
01:07:22 <integral> @djinn a -> (b, c) -> ((a, b), (a, c))
01:07:22 <lambdabot> f a (b, c) = ((a, b), (a, c))
01:07:28 <xerox> mauke: uhm, right, then the problem is another.
01:07:34 <integral> it djinn basically just "auto" in Coq?
01:09:21 <flux__> maybe it parses but doesn't (yet) support?-)
01:15:15 <Phyx-> wilx: flip compare and what more are there?
01:15:55 <xerox> idea
01:16:54 <xerox> Nawh.
01:20:56 <wilx> Hmm, read up in some tutorial.
01:21:15 <wilx> flip "flips" the parameters of binary function.
01:21:23 <xerox> Right.
01:21:27 <wilx> >compare 1 1
01:21:28 <xerox> flip f x y = f y x
01:21:46 <wilx> Compare returns Ordering afaik.
01:21:49 <xerox> Yes.
01:21:54 <wilx> EQ, LT, GT.
01:22:42 <xerox> Yes.
01:23:10 <xerox> sortBy uses its input function to compare the list elements.
01:33:29 <int-e> > sort [(0/0, 1), (0/0, 2)]
01:33:30 <lambdabot> [(NaN,2),(NaN,1)]
01:45:20 <Phyx-> @type LT
01:45:21 <lambdabot> Ordering
01:45:52 <sieni> > (\(Just x)->x) $ (Just 8) >>= return . show
01:45:53 <lambdabot> "8"
01:49:01 <Phyx-> groteKleiner :: Taak -> Taak -> Ordening
01:49:03 <Phyx-> ?
01:49:08 <Phyx-> error on that
01:49:15 <Phyx-> i though LT was an ordening type
01:49:19 <Phyx-> @Type GT
01:49:21 <lambdabot> Ordering
01:49:21 <int-e> Ordening?
01:49:26 <Phyx-> oops
01:49:46 <Phyx-> bah... errors like that make me look stupid...
01:49:54 <int-e> why don't you make an Ord instance for that?
01:50:14 <Phyx-> how so?
01:50:56 <int-e> instance Eq Taak where a==b = ...; instance Ord Taak where compare a b = ...;
01:51:10 <int-e> @type compare
01:51:10 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
01:51:23 <Phyx-> hmmm
01:59:31 * earthy laughs at Phyx
01:59:39 <earthy> *very* well known typo for dutchmen ;)
02:01:28 <Phyx-> earthy: :P
02:03:23 <jonkri> if i have a function that returns a IO Int, is there a way to turn that value to a Int?
02:03:58 <Blicero_> is there a builtin function or a better way to write something like curry (f . uncurry g)
02:04:06 <tromp_> not safely
02:04:09 <Phyx-> ok, this is weird
02:04:22 <Phyx-> i switched it's input list and it still gives the wrong order...
02:05:49 <int-e> Blicero_: (f .) . g
02:06:13 <Lemmih> jonkri: do i <- ioInt; ...
02:06:33 <jonkri> Lemmih, thanks :)
02:06:46 <Blicero_> int-e: thanks, perfect
02:07:36 <jonkri> @index ioInt
02:07:37 <lambdabot> bzzt
02:08:47 <jonkri> Lemmih, where is ioInt?
02:09:41 <jonkri> defined
02:11:32 <stepcut> jonkri: replace ioInt with whatever function you have that is returns an IO Int
02:12:15 <jonkri> ahaa, now i get it
02:12:19 <stepcut> s/is//
02:14:12 <jonkri> what if i want to create a function which takes a IO Int and returns a Int then?
02:14:21 <jonkri> if i use do, i must return IO Int, right?
02:14:29 <integral> @type unsafePerformIO
02:14:30 <lambdabot> Not in scope: `unsafePerformIO'
02:14:36 <integral> @type System.IO.unsafePerformIO
02:14:37 <lambdabot> Not in scope: `System.IO.unsafePerformIO'
02:14:49 <kosmikus> :)
02:14:55 <kosmikus> it's good that it's hard to find ...
02:15:02 <integral> ;)
02:15:41 <stepcut> jonkri: In general, you can never escape the IO monad
02:15:43 <jonkri> what's unsafe with it? i have a io int that i want to use as a int, and if that's hard then the language is unpractical
02:16:03 <integral> jonkri: you can use it as an int using >>=
02:16:09 <ibid> jonkri: it isn'y hard, it's just different
02:16:50 <jonkri> hmm, ok
02:16:52 <integral> do { int <- intMonad :: IO Int; return $ (f :: Int -> a) int } :: IO a
02:17:03 <tromp_> it's unsafe
02:17:11 <int-e> jonkri: if your IO action has no side effects (and is constant) it shouldn't be an IO action in the first place.
02:17:26 <jonkri> int-e, i read from a file
02:17:39 <jonkri> int-e, and want to treat the files content as a constant string
02:17:48 <Philippa> that has a side effect
02:17:51 <Philippa> it reads from the file
02:17:59 <int-e> jonkri: you wouldn't be able to predict how often the side effect takes place, i.e. how often the file is read.
02:18:02 <jonkri> ok, yeah
02:18:07 <ibid> jonkri: the point is, unsafePerformIO basically tells the system, "do my side-effects at some unpredictable time, perhaps overlapping with other side-effects"
02:18:16 <integral> readFile ... >>= \str -> normalStringFunction str
02:18:23 <int-e> ibid: perhaps more than once
02:18:29 <ibid> int-e: yeah
02:18:30 <Philippa> you let the IO code be the "top layer" of the system, in effect
02:18:36 <int-e> ibid: although usually that won't happen
02:18:43 <Philippa> and pass results of IO actions into pure functions and take the results back out to do more IO based on them
02:19:29 <int-e> ibid: more relevant, perhaps never.
02:19:32 <Phyx-> omfg... someone kill me, it took me bout 3 hours to see what my bug was using > instead of >=
02:19:41 <Gemini_5> \join #haskolere
02:19:44 <Gemini_5> of niet
02:19:59 <Philippa> Phyx-: happens
02:20:16 <Philippa> I've done the equivalent enough times, in fact it's responsible for most of my really unpleasant debugging sessions
02:20:24 <ibid> jonkri: the easiest way to think about it, IMHO, is that IO a is a _statement_ returning an a, and like in any language, statements are put together in blocks; that's *do* in haskell. the only thing that's different from many other languages, apart from the syntax, is that you have to "assign" to a variable the result of a statement, you cannot use it directly eg. as an argument
02:21:05 <jonkri> ibid, i see
02:22:10 <jonkri> @type >>=
02:22:14 <lambdabot> parse error on input `>>='
02:22:17 <ibid> ("assignment" is variable <- statement; i use quotes because it's actually initialization, as you cannot modify the value of the variable afterward)
02:22:20 <Phyx-> Philippa: ^_^
02:22:40 <Philippa> a classic one was getting the variance wrong on the -> type constructor in a type checker
02:22:43 <jonkri> ibid, ok :-)
02:23:09 <Philippa> took *ages* to spot, because you don't think of it at first
02:23:09 <Phyx-> now to add comments, submit, and see how i can finish another assigment that has 1 week scheduled for completion in 24 hours
02:23:30 <petekaz> Is there a planet haskell blog aggregator?
02:23:35 <ibid> jonkri: another, equivalent way of saying it is that it's the old procedure vs function split, this time just enforced via the type system
02:23:39 <Philippa> do you have the entire 24 hours?
02:23:49 <ibid> petekaz: make one :)
02:23:51 <Philippa> if so, just stay calm and work on it methodically
02:24:11 <ibid> petekaz: actually, haskell sequence aggregates some haskell-people blogs
02:24:12 <jonkri> ibid, "old procedure vs function split"?
02:24:32 <ibid> jonkri: do you know pascal?
02:25:18 <petekaz> ibid: thanks.
02:26:10 <jonkri> ibid, no
02:26:12 <liyang> QBasic had Functions and Subroutines.
02:26:12 <liyang> But I guess no one starts off on BASIC these days. XD
02:26:12 <jonkri> liyang, i did :)
02:26:12 <ibid> jonkri: ok. there's a faction of language designers who have long though that there are two kinds of subroutines: procedures, which do not return a value but may have side effects, and functions, which do return a value and are side-effects free
02:26:16 <liyang> QBasic's Functions didn't enforce their pureness though.
02:26:17 <Philippa> give or take: it's often accepted that procedures may well return a value, they just ain't functions
02:26:17 <ibid> jonkri: threre are a number of languages following this split, but the side-effect-freeness of functions is rarely enforced by the language
02:26:17 <Philippa> or vice versa
02:26:24 <Philippa> which is, er, the wrong way to do it
02:26:25 <jonkri> ibid, like in haskell
02:26:34 <ibid> jonkri: my point exactly :)
02:27:04 <Philippa> jonkri: almost. In haskell, procedures can return - but functions don't have side-effects
02:27:04 <Philippa> so it's the split done right
02:27:04 <ibid> jonkri: pascal has the split but doesn't enforce side-effect-freeness
02:27:04 <jonkri> Philippa, yeah, just what i thought about :-)
02:27:26 <jonkri> but shouldn't the procedures return no value instead?
02:27:31 <jonkri> to be correct
02:27:50 <Philippa> if a procedure really doesn't have a return value then there're ways to simulate that, like returning a type that only has one value
02:28:09 <Philippa> but if all functions are pure and all procedures don't return, how do you read a file?
02:28:12 <jonkri> ah, that's true
02:28:28 <int-e> Philippa: and why :)
02:29:11 <ValarQ> int-e: maybe you want the hardware to work a bit :)
02:29:16 <ibid> Philippa: i suppose the pascalists in the faction say "use var parameters" ;)
02:29:24 <ibid> Philippa: not useful in haskell, of course
02:29:29 <ValarQ> "cmon you lazy diskdrive!"
02:29:49 <jonkri> but if we return to my question... i have a io int that i want to use in my int functions, how would you do it? i take it you wont transform _all_ my int functions to io int functions?
02:30:03 <ibid> jonkri: the idea is this:
02:30:15 <ibid> foo <- my_int_returning_procedure
02:30:27 <ibid> let bar = my_pure_function foo
02:30:28 <ibid> ...
02:30:31 <ibid> (inside do)
02:30:56 <int-e> jonkri: you could read the file first, then pass in the value (or values) to your functions.
02:31:00 <Philippa> jonkri: you have an outermost IO Whatever which consists of taking your IO Int, passing it into your pure function and returning the result
02:31:22 <jonkri> hm, i see
02:31:30 <jonkri> it's a new way of thinking that's for sure :)
02:31:38 <Philippa> I should use let rather than return. Will try to make that a standard in my next project...
02:31:43 <Philippa> actually it's an incredibly old way of thinking, just formalised
02:31:48 <davidhouse> ? how can return be used instead of let?
02:32:02 <Philippa> it was incredibly familiar to my father the moment I explained "you don't do IO Int -> Int" to him
02:32:03 <ibid> davidhouse: foo <- return (my_pure_function 42)
02:32:10 <davidhouse> oh. in monads.
02:32:38 <Philippa> but then, he hacked in cobol and fortran back in the 70s
02:32:49 <ibid> Philippa: your father is a hacker?
02:32:51 <ibid> cool
02:33:00 <davidhouse> yeah. <- essentially rips a value out of a monad. so, (this isn't quite true but it might as well be), <- converts things from m a -> a.
02:33:08 <ibid> i only taught my father to program
02:33:14 <ibid> davidhouse: ... temporarily :)
02:33:17 <Philippa> these days I think he'd describe himself as more of a dabbler, but yeah. He mostly hacks factory management these days
02:33:23 <davidhouse> ibid, hence the "not quite true" ;)
02:34:03 <davidhouse> all right guys, i need ideas for an exercise which will test my understanding of State.
02:34:45 <ibid> my students had no problems with basic monads (at least they didn't tell me about them), after i started my fp course with "here's how you do procedural programming in Haskell"
02:34:55 <ibid> (before going on to the functional stuff)
02:34:59 <jonkri> stupid question again: is it "<-" that transforms a IO Int to a Int?
02:35:28 <ibid> jonkri: yes and no
02:35:39 <ibid> jonkri: it's a useful fiction to think of it that way
02:41:39 <davidhouse> jonkri: right. so, for example, readLine returns an IO String, so something like input <- readLine, input is then a String.
02:41:47 <davidhouse> BUT you can only use it within that do block.
02:41:47 <jonkri> ah, i see
02:41:47 <tromp_> no, <- just composes an action producing an Int with another IO action that can use its result
02:41:47 <Philippa> jonkri: it's how <- is translated that does
02:41:47 <davidhouse> (once you fully understand >>= this makes a whole lot more sense. basically, when you do a <-, haskell remembers what you called that variable and when you use it, you're actually using >>=)
02:41:47 <Philippa> strictly speaking, >>= does all the work
02:41:47 <Philippa> @type (>>=)
02:41:47 <lambdabot> forall (m :: * -> *) b a.
02:41:47 <lambdabot>    (Monad m) =>
02:41:47 <lambdabot>    m a -> (a -> m b) -> m b
02:41:47 <Philippa> that make sense?
02:41:47 <Philippa> (it's also how you keep being 'stuck in the monad' - you get another action back out again)
02:41:47 <jonkri> i'm beginning to understand
02:41:47 <davidhouse> ^^ in that type, you can see that the second argument (a function, takes a value of type a and not m a. >>= rips the value out of the monad before passing it to the the function
02:41:47 <davidhouse> but the function's result must then be monadic, so you can't ever write a function which has type IO a -> a
02:41:47 <davidhouse> IO is a "one-way" monad.
02:41:47 <davidhouse> (p.s., anybody: any ideas for an algorithm as per above?)
02:41:47 <Philippa> write a hindley-milner typechecker
02:41:47 <ibid> i've sometimes wondered if it'd make sense to add an implicit coercion from more or less a -> b to IO a -> IO b in a monad-based language
02:41:47 <Philippa> (or if you'd rather, an inferred simply-typed lambda calculus typechecker - it's easier)
02:41:47 <Philippa> keep the substitutions you infer via unification in the State
02:41:50 <Philippa> ibid: you're not the only one
02:41:50 <Philippa> although multiple parameters start to be a PITA
02:41:50 <davidhouse> @type lift
02:41:50 <lambdabot> Not in scope: `lift'
02:41:50 <jonkri> thanks a lot people, i will read more about this but your help certainly cleared a lot
02:41:50 <davidhouse> doesn't lift do that?
02:41:50 <ibid> Philippa: or just use references to implement substitutions
02:41:50 <davidhouse> turns a non-monadic function into a monadic one
02:41:50 <Philippa> ibid: sure, but that's no fun, you just let the ST monad do all the work
02:41:50 <Philippa> liftM, you mean?
02:41:50 <Philippa> @type liftM
02:41:50 <lambdabot> Not in scope: `liftM'
02:41:50 <davidhouse> err, yeah.
02:41:50 <ibid> Philippa: yeah, it'd work easier with an uncurried language, basically (a1,...an) -> b to (IO a1,...,IO an) -> IO b
02:41:50 <Philippa> @type Control.Monad.LiftM
02:41:50 <lambdabot> Not in scope: data constructor `Control.Monad.LiftM'
02:41:50 <Philippa> @type Control.Monad.liftM
02:41:50 <lambdabot> forall r (m :: * -> *) a1.
02:41:50 <lambdabot>         (Monad m) =>
02:41:50 <lambdabot>         (a1 -> r) -> m a1 -> m r
02:41:51 * Philippa kicks self
02:41:52 <ibid> Philippa: i found that doing the substitutions manually is just messiness i'd rather avoid :)
02:41:52 <Philippa> ibid: the other one I should think about more is one in which there's no 'default' language to return from, just a bunch of different ones embedding in each other via monads
02:41:54 <davidhouse> > liftM (+1) (return 2::IO Int)
02:41:54 <lambdabot> No IO allowed
02:41:54 <davidhouse> > liftM (+1) [2]
02:41:54 <lambdabot> [3]
02:42:10 <ibid> Philippa: have you, btw, read reynold's "theories of programming languages"?
02:44:39 <Philippa> no, I haven't. Is it available online?
02:44:49 <ibid> reynolds', rather
02:44:51 <ibid> Philippa: no, but see http://www.cs.cmu.edu/~jcr/tpl.html
02:44:51 <davidhouse> reynolds's. unless there's more than one reynold.
02:44:52 <ibid> davidhouse: i think that's a controversial issue in the english language ;)
02:44:56 <davidhouse> :)
07:01:33 --- topic: '["Submit a paper to the Haskell Workshop:", "http://haskell.org/haskell-workshop/2006", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion"]'
07:01:33 --- topic: set by sylvan on [Fri Mar 03 08:35:02 2006]
07:02:05 <Cale> with do, either you put the 'do' on a separate line (somewhat uncommon, though it's nice in certain cases) or you line up the following lines of the do with the first thing inside it
07:02:07 <Cale> e.g.
07:02:14 <Cale> do x <- getLine
07:02:24 <Cale>    putStrLn x
07:03:10 <jmichaelson> gah still not workin
07:03:16 <Cale> lisppaste2: url
07:03:17 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
07:03:18 <davidhouse> i find it works if you just tab-indent the lines following do.
07:03:32 <jmichaelson> I gotta case after then, does that bork it?
07:03:57 <petekaz> What would be the haskell way of counting the occurences of an item in a list.  For example, given a list ["a", "b", "c", "a", "b"], the result would be [("a", 2), ("b", 2), ("c", 1)]?  And does haskell have symbols?
07:04:08 <petekaz> Is there a one-liner for this?
07:04:11 <roconnor> http://hackage.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse
07:04:19 <Cale> jmichaelson: not necessarily, but paste the code. Basically, if something is 'inside' something else, then it needs to be indented more.
07:04:49 <Cale> petekaz: (map length . group . sort)
07:04:50 <Lemmih> petekaz: Sort them, group them, count them.
07:05:11 <Cale> er
07:05:25 <Cale> well, you might want to do something more than map length :)
07:06:00 <Cale> > map (\x -> (head x, length x)) . group . sort $ ["a", "b", "c", "a", "b"]
07:06:00 <lambdabot> [("a",2),("b",2),("c",1)]
07:06:20 <Lemmih> > map (head &&& length) ["11","2222"]
07:06:21 <lambdabot> [('1',2),('2',4)]
07:06:22 <Cale> I suppose if you want to be clever and use Control.Arrow
07:06:23 <astrolabe> @pl \x -> (head x,length x)
07:06:23 <lambdabot> liftM2 (,) head length
07:06:23 <Cale> yes
07:06:38 <Cale> you'd do that :)
07:07:32 <Cale> you could also abuse Data.Map
07:07:35 <davidhouse> roconnor: what should the layout be on that page?
07:07:49 <jethr0_> Cale: is there a "pages to do" page on the new wiki?
07:07:58 <petekaz> Cale: neat, I'm a complete haskell newbie (started reading 2 nights ago for fun), and I was going over some of the traditional problems I've done in other languages before.
07:07:59 <Cale> jethr0_: don't know
07:08:12 <davidhouse> roconnor: ignoring the fact that the do is unnecessary
07:08:13 <roconnor> davidhouse: ``indent the else at least one more step''
07:08:29 <davidhouse> oh, right. yeah, using weird indentation for if.
07:09:08 <Cale> > (M.toList . M.fromListWith (+)) (zip "acabcbabc" [1,1..])
07:09:09 <lambdabot> [('a',3),('b',3),('c',3)]
07:09:09 <astrolabe> petekaz: How do you find haskell so far?
07:09:21 <Cale> > (M.toList . M.fromListWith (+)) (zip "Hello, World!" [1,1..])
07:09:22 <lambdabot> [(' ',1),('!',1),(',',1),('H',1),('W',1),('d',1),('e',1),('l',3),('o',2),(
07:09:22 <lambdabot> 'r',1)]
07:09:58 <Cale> (Data.Map is imported as M here)
07:11:25 <lisppaste2> davidhouse pasted "experimentation with State" at http://paste.lisp.org/display/17579
07:11:45 <davidhouse> jethr0_: remember that State problem earlier that you so nicely solved with a foldl (>>)? i ended up doing it like ^^ that paste.
07:12:05 <davidhouse> i think the last two lines could be collapsed into a foldl, and i'd inevitably end up with your solution :)
07:12:36 <petekaz> astrolabe: very very very different :-)  My background, college 10 years ago (undergrad only), lots of python, some ruby, some java, some C.  To further myself, took upon it to learn CL (which I like a lot), then started learning erlang (which I also like), and now this has led to haskell, and like I said, its very different.  Still not sure of what to think yet.  
07:12:59 <roconnor> associated types?
07:13:00 <Philippa> don't truly cement your judgement 'til you're playing with monad transformers
07:13:04 <jethr0_> davidhouse: i think the "run'" is a fold
07:13:06 <Philippa> it's like CPS turned into lego blocks
07:13:15 <davidhouse> jethr0_: yes, that's what i meant
07:13:21 <jethr0_> sry, just read it
07:13:28 <lisppaste2> jm pasted "if then else" at http://paste.lisp.org/display/17580
07:13:47 <astrolabe> What are the best documents on monad transformers?
07:14:06 <Cale> jmichaelson: indent the 'then' and 'else' deeper than the 'if', as they are inside it
07:14:14 <jmichaelson> k
07:14:43 <Philippa> I tend to leave then on the same line as the condition, with the actual code on the next line
07:14:46 <Philippa> if foo then
07:14:48 <Philippa>   code
07:14:48 <Philippa>  else
07:14:51 <Philippa>  othercode
07:14:57 <lisppaste2> Cale annotated #17580 with "fixed" at http://paste.lisp.org/display/17580#1
07:15:00 <jmichaelson> yea I had then on the same line at first
07:15:13 <lisppaste2> davidhouse annotated #17580 with "alternative indentation" at http://paste.lisp.org/display/17580#2
07:15:20 <davidhouse> that's how i'd do it.
07:15:26 <jmichaelson> wuut it compiled now ;P
07:15:30 <jmichaelson> lets test it
07:15:45 <Cale> davidhouse: that shouldn't fix the problem, should it?
07:15:50 <jmichaelson> thx guys!
07:15:58 <Cale> davidhouse: the 'then' and 'else' are still outside the 'if'
07:16:00 <davidhouse> err, yeah, with Cale's extra indentation. i missed that.
07:16:00 <jmichaelson> and gals?
07:16:43 <petekaz> Philippa: I think I may be a bit ambitious with haskell right now. I fear I am not well versed enough with functional programming to fully appreciate haskell yet.  That is I probably should finish up with SICP first, before delving into this truly different and strange world.  I feel like I need to move up the ladder of evolution slowly.
07:17:00 <davidhouse> petekaz:, haskell's my first functional language, i'm loving it.
07:17:26 <liyang> if b
07:17:36 <liyang>     then e
07:17:38 <liyang>     else f
07:17:44 <Cale> liyang: right
07:18:21 <Cale> Philippa: really? That seems uncommon in most of the Haskell code I've seen
07:18:33 <Philippa> Cale: maybe I'm just weird
07:18:39 <dcoutts> liyang, I'm nearly done with the Gtk2Hs presentation + demos write up
07:18:44 <jethr0_> petekaz: SICP is seriously worth it. but as it pretty soon delves into side-effects, it's help with haskell is only limited...
07:18:45 <petekaz> Cale: that second implementation using zip is neat.  I need to decipher it now. 
07:18:58 <Philippa> I find that when I'm reading the 'then' just gets in the way though
07:19:20 <Cale> petekaz: you'll need the documentation for Data.Map at http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
07:19:28 <liyang> I try to write my code such that hard tabs /can/ be used instead of spaces for indentation. And adding another level of indentation isn't nice...
07:19:41 <davidhouse> i only use hard tabs.
07:19:53 <davidhouse> it's very possible.
07:19:57 <Philippa> don't use hard tabs in haskell
07:20:05 <astrolabe> But your code isn't editor portable
07:20:05 <Philippa> really, it's evil, bad and wrong
07:20:17 <Philippa> (as it happens, the standard says 1 tab = 8 spaces)
07:20:17 <davidhouse> Philippa: why?
07:20:25 <davidhouse> why is it evil, that is
07:20:25 <Philippa> davidhouse: layout is significant
07:20:34 <Philippa> therefore, tabs are confusing
07:20:35 <davidhouse> yes, i know. i haven't got any layout errors.
07:20:36 <petekaz> jethr0_: The bottom line is that I want to broaden my knowledge, it seeems that everyone on the planet highly recommends SICP (start to finish).  I somehowe got distracted to haskell the other night though.  
07:20:48 <Cale> also, collaborating with other Haskell users will be a problem if your editor generates hard tabs
07:20:49 <petekaz> Cale: Thakns.
07:20:52 <mauke> I also use tabs only
07:21:20 <Philippa> also, you develop better style if you use spaces anyway - whitespace is better used with a degree of aesthetics in haskell
07:21:20 <jethr0_> yup, SICP is IMO a _very_ recommendable book. all i'm saying is that haskell goes into a (slightly?) different direction. but it seems you knew that already :)
07:21:21 <Cale> The vast majority of Haskell users configure their editors to only generate spaces.
07:21:48 <petekaz> jethr0_: Right, the pure approach.
07:21:54 <liyang> dcoutts: cool. :) Joel just wanted to see some Pango examples though, nothing more.
07:21:58 <davidhouse> i'd rather write the code then put it through a post-processor if i had to use spaces.
07:22:04 <davidhouse> i hate working with them in my editor.
07:22:21 <dcoutts> liyang, yep, other people wanted more :-)
07:22:22 <astrolabe> Aren't spaces easier than tabs?
07:22:26 <Cale> davidhouse: you can configure your editor to treat multiple spaces like it would a tab
07:22:30 <Cale> davidhouse: which is what I do
07:22:35 <jethr0_> petekaz: it's not all that black-and-white. but when one begins with haskell, it pretty much seems that way. now that i know how to use state monads, IO and foreign function interface, it's much more levels of gray
07:22:47 <liyang> dcoutts: I mean, for now. :)
07:22:53 <davidhouse> Cale: which editor?
07:22:54 <liyang> But yay in any case. :)
07:23:00 <Cale> davidhouse: gvim and emacs
07:23:07 <Philippa> once you've figured enough out, haskell practically begs you to corrupt its purity in new and inventive ways
07:23:26 <liyang> sounds kinky.
07:23:36 <jethr0_> Philippa: that's _your_ interpretation. i'm still hoping to get along with all my purity :)
07:23:38 <davidhouse> Cale, i'm not that hardcore. :)
07:23:48 <davidhouse> what do people use apart from emacs/vim?
07:23:49 <Philippa> it's just a lot keener on being safe and sane, and there're things you can't do consensually with it
07:23:51 <jethr0_> Philippa: but i guess you're (partially) right
07:24:15 <petekaz> jethr0_: My goal is to become a better programmer, so an investigation into haskell seems like a requirement.  What other languages do you use or have used and how do you find haskell in the practical sense?  or are you solely an academice?
07:24:18 <jethr0_> davidhouse: emacs and vim :)
07:24:25 <Cale> liyang: Philippa always does :)
07:24:50 <Cale> petekaz: I find Haskell to be incredibly practical
07:24:54 <jethr0_> petekaz: i've gone through most of the major languages and found haskell as a best fit to what i was looking for.
07:25:09 <Philippa> Cale: be fair, I've managed to keep up entirely vanilla conversations for hours at a time. Just don't ask what I did later that night
07:25:24 <Cale> hehe
07:25:29 <davidhouse> i think i've passed through the initiation phase.
07:25:36 <jethr0_> but then "chose the right tool for the job" is important and i still do small scripts in bash/ruby/python/perl and won't probably be able to evade the evil C++/java world
07:25:36 <davidhouse> i tried writing PHP today and i could only think functionally.
07:25:57 <Cale> davidhouse: hmm, what platform are you on?
07:26:02 <liyang> petekaz: play with an OO language (don't particularly want to say which. Java will do, at a pinch.) Though you may find that uninviting after Haskell.
07:26:02 <davidhouse> i kept forgetting i was looking at code for an eager intepreter. :)
07:26:13 <davidhouse> Cale, ubuntu linux with KDE.
07:26:40 <davidhouse> Cale, why?
07:26:59 <jethr0_> i'm getting more and more displeased with the OO "paradigm". it's always propagated as being the solution to all of CS's problems, and how natural OO design is, but that somehow never rang true for me
07:27:08 * Philippa would strongly suggest playing with a language whose vision of purist OO is significantly different to Java's
07:27:13 <Philippa> smalltalk, ruby, something of that ilk
07:27:23 <araujo> Philippa, you read my mind 
07:27:29 * araujo was about to do such a comment
07:27:41 <Philippa> jethr0_: the problem is that we're all supposed to get obsessed with product/record/"class" types and ignore sum/variant/algebraic types
07:27:53 <Philippa> that really screws a lot of stuff up
07:28:13 <Philippa> if you really want extensibility on that, learn to use the default case when you don't know how to handle stuff
07:28:21 <jethr0_> smalltalk is really interesting with all its integrated tools (refactoring browser, doing live changes on a running system, ...), but i'd have to change my approach quite a bit to do serious development in smalltalk. especially since i know how nice type inference can be!
07:28:43 * liyang agrees wrt SmallTalk/Ruby. Also, Python perhaps. Mixins are a nice idea.
07:28:56 <Philippa> btw, I find Haskell quite nice for scripting type tasks - though it's a little more verbose on average than more traditional languages for the job
07:28:57 <araujo> jethr0_, you would be impressed how many similarities exist between smalltalk and haskell
07:29:02 * araujo is actually impressed
07:29:14 <jethr0_> Philippa: the problem the way i perceive it, is that it's always told to "newbies" how OO simply projects the problem domain's objects into code and how this makes the design process simpler
07:29:14 <Philippa> and where they're not similar as such they're often almost dual
07:29:15 <araujo> smalltalk was inspired by functional programming.
07:29:20 <liyang> OTOH, Haskell's record types suck though. :)
07:29:35 <jethr0_> it just never works that way and at least i got very frustrated when looking for "the perfect" OO design
07:29:39 <Philippa> araujo: I'd say more by lisp than what I think of as functional programming as such - but yeah
07:30:06 <petekaz> I like Ruby and such, but I am finding that OO code eventually becomes a mess after a while.  It takes so much time to decipher what someone has done through the inheritance model etc ... Which is why I started down the CL path.  And now I am hoping SICP will shed the light on more stuff for me.  And then of course haskell too.  I also really like erlang as well because I'm a networking kind of guy.
07:30:23 <jethr0_> araujo: i know smalltalk a little and haskell quite well, but i'm only partially impressed by the similarities :)
07:30:26 <Philippa> jethr0_: agreed, often people forget about the verbs when they do their decomposition. You don't actually capture the language of the domain because you're too busy working out which class of noun the verb belongs to...
07:30:46 <Philippa> going easy on the inheritance is generally the way to go
07:30:57 <Philippa> (subtyping you may have a good reason for, but inheritance?...)
07:31:17 <Cale> davidhouse: If you're using KWrite, then there's some settings you might try
07:31:28 <jethr0_> i've come to use inheritance as little as possible, really. often interfaces and composition are much "safer" ways to go
07:31:29 <davidhouse> Cale, well, Kate, but go on
07:31:51 <Cale> oh, let me look at Kate
07:32:18 <Cale> KWrite has an option to make backspace affect indentation
07:32:21 <Excedrin> Philippa: which compiler do you use for scripting tasks?
07:32:27 <Cale> (at the start of a line with spaces)
07:32:39 <araujo> jethr0_, The reasoning of "object Message" , "function Type" are pretty equivalent in a pragmatic level.
07:32:41 <Philippa> GHC and/or GHCi
07:33:00 <Philippa> although that's just because it's my default environment as such
07:33:03 <Cale> ah, Kate is the same :)
07:33:03 <jethr0_> and also OO design has (for me) the attitude of preseeing all future changes and accomodating them. while this is generally a good idea, it can lead to slow iterations, over-design and losing sight of what the _real_ problem to be solved is
07:33:11 <davidhouse> Cale, they're the same base.
07:33:24 <Philippa> yeah, FP does rather encourage the attitude of "oh sod it, it's not like it'll be hard to refactor"
07:33:35 <Philippa> you don't exhibit foresight, you just keep the code flexible
07:33:46 <Cale> it unfortunately clears to the start of the line though, I'm not sure how to make it only remove one tab's worth of spaces when you hit backspace there
07:33:53 <Philippa> granted that tends to mean a big refactor somewhere around the few hundred lines point, but hey
07:34:23 <jethr0_> Philippa: that's not always wise either, but making refactoring easy by shallow/few dependencies can definitely solve problems that well-meaning monster frameworks might not
07:35:29 <Cale> "Use spaces instead of tabs to indent" together with "Keep indent profile", "Tab key indents" and "Backspace key indents" seems to work okay though.
07:35:31 <Philippa> I've rarely got myself into a truly huge mess in that regard. But like I said, a big loosening-up tends to kick in around the few hundred lines point
07:35:51 <Cale> I can see it being only mildly annoying in certain cases.
07:35:54 <davidhouse> anyone using Kate/KWrite/KDevelop etc with a syntax highlighing schema they feel like throwing my way?
07:35:59 <davidhouse> stop me configuring my own.
07:36:00 <Philippa> thing is, in Haskell I'm pretty damn sure I can untangle any knot I work myself into. And I can see the knots forming, because they're visible in the code in a way they're not in impure languages
07:36:01 <davidhouse> Cale, thanks.
07:36:09 <jethr0_> OO with all its "patterns" and "dependency injection" and so on just becomes very complex early on. whereas FP encourages strict modularity...
07:36:34 <Philippa> AIUI, I've effectively pulled dependency injection in FP a few times. But the patterns are right there in front of you in FP
07:36:45 <araujo> jethr0_, yes, i also think FP makes things simpler.
07:37:26 <jethr0_> Philippa: really? i'd have thought that just passing a (functional) parameter should solve much of that? in what respect have you used it?
07:37:43 <jethr0_> araujo: i wouldn't go that far, but i think i know what you mean :)
07:37:49 <araujo> I actually think FP (particulary Haskell) as an improvement over many OO concepts. For example, first class objects+static typing rul3Z the world!
07:38:05 <araujo> s/think/see/
07:38:50 <jethr0_> although asynchronous exceptions still seem(?) to be a problem. and having one module per file. but i guess there could be worse short-comings :)
07:38:53 <jmichaelson> hm why does ghc link staticly?
07:39:29 <jethr0_> and seeing how haskell modules remain relatively small automatically is quite the contrast to other languages where you have to force yourself to break classes up all the time.
07:40:08 <Philippa> jethr0_: sure, the actual implementation tends to cut out a lot of the junk compared to OO. What else is new? :-)
07:40:16 <araujo> Imperative programming is hard to learn but easy to master, Functional Programming is easy to learn but hard to master.
07:40:31 <Philippa> actually, truly mastering imperative programming is *damn* hard
07:40:37 <jyp> araujo: I'd say the reverse.
07:40:49 * jethr0_ really hates writing read/write accessors for all attributes because it's somehow considered "good". many heuristics are over-simplifying or quick-and-dirty solutions ruin your whole codebase forever
07:40:49 <Philippa> you just think you've mastered it because until you do FP you don't see the same possibilities
07:41:01 <jethr0_> but maybe i'm just having disciplin problems :)
07:41:11 <Philippa> jethr0_: I see that one as a language bug. Fields already /have/ read and write operations, not being able to overload them's the bug
07:41:40 <Philippa> that said, I often need the equivalent code in Haskell
07:42:17 <Philippa> just not /as/ often as you'd expect because I've got fewer side-effects knocking around
07:42:18 <jethr0_> Philippa: smalltalk does that at least better than C++/java. but ruby on the other hand has those weird accessors which allow all kinds of overloading. for me, that's taking it too far to the other side
07:42:44 <araujo> jyp, FP is difficult to learn?
07:43:43 <Philippa> jethr0_: I figure any code of the appropriate type's legit. But that's just me
07:43:51 <jyp> araujo: Well... Once you got used to imperative programming, it seems a bit difficult, yes.
07:43:58 <Philippa> (in Haskell you /know/ if you're doing anything funky because all of a sudden your accessors have monadic types)
07:44:01 <araujo> jyp, no, i didn't mean that :-)
07:44:17 <jyp> araujo: At least I haven't been able to convince most of my contemporaries :)
07:44:19 <jethr0_> or was it python? one of them allowed overriding the [] operator for classes or some such. whenever the hidden operations become murky it's getting dangerous IMO. which is also one of the dangerous corners C++ is cutting
07:44:27 <Philippa> FP encourages you to really master /everything/. When ideas like AOP seem like a sloppy version of what you were coding yesterday, you're on the path :-)
07:44:38 <jyp> araujo: I know you didn't... I just like to misinterpret ;)
07:44:38 <araujo> jyp, Because _that's_ indeed difficult!
07:44:59 <Philippa> jethr0_: I'm not in favour of having anything other than field access and method call on objects, and field access is method call in disguise
07:45:11 <Philippa> *everything* is one of those two things, which means no hidden operations. Make sense?
07:45:30 <araujo> jyp, but i meant something like, get 2 9 years old boy, and let's see who can code faster on Haskell or Java. Nevertheless, i bet the Haskell boy would take longer to master Haskell than the Java one.
07:45:48 <Philippa> but the haskell kid'll be able to do a lot more having mastered Haskell
07:45:49 * araujo would like to do that test
07:45:57 <araujo> Philippa, YEAH!!
07:46:06 <araujo> By far more.
07:46:08 <Philippa> for equivalent levels of ability, I suspect the haskell kid'll be faster
07:46:18 <jyp> Philippa: exactly.
07:46:27 <Excedrin> time to master Java approaches infinity
07:46:28 <araujo> Philippa, Well, im comparing the programming languages :-)
07:46:35 <jethr0_> Philippa: my personal favorite is still overloading/overriding all the standard operators in C++. "The only C operators that can't be are . and ?:"
07:46:39 <jethr0_> :)
07:46:49 <araujo> But at a human level, of course the Haskell kid will do it better.
07:47:03 <jethr0_> there's nothing like overloading operators like &&, ||, ->, (), etc
07:47:17 <Philippa> , for bonus points
07:47:20 <araujo> He could go far far easier to Java than the other one to Haskell.
07:47:42 <Philippa> "oh, it's just like being stuck in the IO monad all the time, without type inference. These libraries stink."
07:48:00 <adu> jethr0_: in Haskell you can overload any operators including ones that haven't been defined yet, like @#$%@#$
07:48:36 <jethr0_> adu: i know and it's kinda dangerous...
07:48:52 <jyp> What saves you in haskell is that overloading is guided by typeclasses
07:48:54 <adu> s/dangerous/liberating/
07:49:10 <jyp> and therefore you actually get type coherency
07:49:12 <jethr0_> jyp: when you're overloading "yes". but you can also overwrite all standard functions
07:49:49 <jethr0_> jyp: what saves you IMO is lack of type coercion + static type checking. coercion is one major problem in C++!
07:49:49 <jyp> overwrite, yes. but you can't have both in the same scope and let the compiler choose for you based on types.
07:50:18 <jethr0_> and stupid stuff like the comma operator *brr*
07:50:30 <adu> btw, what is a haskell "kid"
07:50:45 <jethr0_> @kind Either
07:50:46 <lambdabot> * -> * -> *
07:51:04 <adu> @type Either
07:51:05 <lambdabot> Not in scope: data constructor `Either'
07:51:10 <adu> ??
07:51:21 <jyp> jethr0_: imho the real problem of C++ is that it has "free for all" overloading instead of type-class directed one.
07:51:24 <jethr0_> i'm not really qualified to answer. but i understand kinds as meta-types
07:51:24 <NameTab> hi :)
07:51:42 <Philippa> adu: the one of the two 9 year old boys in araujo's hypothetical example who learnt haskell
07:51:49 <adu> oh, so @kind finds the type-class, and @type is what it sounds like
07:52:06 <Philippa> no, @kind finds the kind
07:52:10 <Philippa> they're different things
07:52:15 <adu> @kind IO
07:52:16 <lambdabot> * -> *
07:52:25 <Philippa> a type class is a collection of types that have specific operations
07:52:35 <mauke> @kind Monad
07:52:36 <lambdabot> Class `Monad' used as a type
07:52:37 <Philippa> a kind is the "type of a type (constructor)"
07:52:48 <Philippa> List has kind * -> *, List Int has kind *
07:53:05 <Philippa> * is the kind of an ordinary, non-polymorphic type
07:53:07 <adu> @kind List Int
07:53:07 <lambdabot> Not in scope: type constructor or class `List'
07:53:13 <Philippa> you want [Int] :-)
07:53:21 <adu> @kind [Int]
07:53:21 <lambdabot> *
07:53:26 <Philippa> @kind []
07:53:27 <lambdabot> * -> *
07:53:32 <Philippa> (for List)
07:53:32 <adu> hmm
07:53:37 <Philippa> @kind Int
07:53:38 <lambdabot> *
07:53:49 <Philippa> [Int] is applying the type constructor [] to the type Int
07:53:51 <jethr0_> so, kind tells you over how many types a type constructor is polymorphic
07:54:00 <Philippa> jethr0_: a little more than that
07:54:09 <astrolabe> Are there any built in * -> * -> *    ?
07:54:10 <jyp> @kind GHC.Int#
07:54:11 <lambdabot> Couldn't find qualified module.
07:54:11 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
07:54:11 <lambdabot> \\)?
07:54:16 <jethr0_> Philippa: yes, for very complicated types :)
07:54:22 <Philippa> astrolabe: a state monad, for example
07:54:23 <adu> Philippa: what I know of haskell is haphazardly borrowed from what i know of other languages...
07:54:24 <jethr0_> @kind Control.Monad.ST.ST
07:54:25 <jyp> @kind (->)
07:54:25 <lambdabot> * -> * -> *
07:54:25 <lambdabot> ?? -> ? -> *
07:54:34 <NameTab> I have a function which has a String for a result, is it possible to return this string on two sepperate lines?
07:54:40 * jyp grins evilly
07:54:47 <adu> Philippa: so i appologize if i make assumptions or seem stupid
07:54:53 <jethr0_> NameTab: where would you like to split it?
07:54:58 <Philippa> adu: 'sok
07:55:14 <Philippa> if it helps, type classes are usually used as constraints on polymorphic types
07:55:25 <Philippa> "give me something of any type" vs "give me something of any type that supports equality"
07:55:25 <astrolabe> @kind Data.Array
07:55:26 <lambdabot> Couldn't find qualified module.
07:55:26 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.
07:55:26 <lambdabot> \\)?
07:56:01 <NameTab> well, the string consists of two times two functions which return the values, I need two strings both containing two of those values
07:56:18 <adu> Philippa: from what i understand type-classes are somewhere between an "interface" and a "metaclass"
07:56:22 <jethr0_> NameTab: that was very hard to understand...
07:56:25 <NameTab> heh
07:56:43 <jethr0_> NameTab: you could lisppaste, maybe
07:56:59 <Philippa> adu: they describe interfaces, and they're used to constraint polymorphic types like I said
07:57:04 <NameTab> I've got a string: cat1 ++ " " ++ value1 ++ cat2 ++ " " ++ value2
07:57:18 <NameTab> I need the first two and the second two on sepperate lines
07:57:19 <Philippa> there's some trickery you can do with multi-parameter type classes, but don't worry about that for now
07:57:23 <adu> Philippa: polymorphic types as in C++'s templated class?
07:57:31 <Philippa> adu: similar idea, yeah
07:57:37 <jethr0_> NameTab: you could put a ++"\n"++ between the value1 and the cat2
07:57:47 <Philippa> although the implementation's very different, we're not forced to generate new code for each instantiation
07:57:58 <Philippa> (and we don't have partial specialisation ala C++)
07:58:05 <adu> Philippa: that is very very nice :)
07:58:12 <jethr0_> and we can write a compiler for typeclasses earlier than 10 years after standard publication :)
07:58:16 <carofe8214660> adu, type is like "class" in C++, class is like "abstract class or inteface" in c++
07:58:21 <NameTab> jethr0_, then the string returns a \n in the midle of the string
07:58:38 <jethr0_> NameTab: depends whether you "show" it or "print" it
07:58:47 <adu> carofe8214660: ok
07:58:50 <NameTab> the problem is, we show it
07:58:50 <bd_> @kind Functor
07:58:51 <lambdabot> Class `Functor' used as a type
07:59:43 <NameTab> we *have* to use a function which has a String as a result, it simply shows that string
08:00:22 <jethr0_> NameTab: if you use "show" to display the string, you can't split it into two lines AFAIK
08:00:52 <jethr0_> NameTab: try 'print "hello\nworld"' in ghci
08:01:16 <jethr0_> NameTab: strike that. use putStrLn instead :)
08:01:31 <NameTab> we use helium :P
08:01:33 <carofe8214660> show to display strings?
08:02:00 <carofe8214660> show is to convert types to string representation , or no?
08:02:06 <astrolabe> show string1 ++ '\n' ++ show sting2
08:02:36 <astrolabe> too convoluted
08:02:37 <jethr0_> astrolabe: that won't work!
08:02:47 <astrolabe> you'd have to print it :)
08:03:00 <jethr0_> astrolabe: since when can you concatenate a string with a char?
08:03:03 <astrolabe> an '\n' should be "\n"
08:03:08 <astrolabe> :p
08:03:25 <carofe8214660> astrolabe: maybe you want : putStr (string1++"\n"++string2)
08:03:40 * astrolabe needs a strongly typed language.
08:03:44 <NameTab> if I use putStr my types are all messed up :P
08:03:47 <carofe8214660> remember that ++ is to concat list
08:04:01 <carofe8214660> and '\n' is a char , not a list
08:04:10 <carofe8214660> "\n" is a list
08:04:21 <astrolabe> 04[22:20] astrolabe: 01an '\n' should be "\n"
08:04:44 <jethr0_> @type "\123456789"
08:04:44 <lambdabot> lexical error in string/character literal
08:05:02 <carofe8214660> nametab: i dont undestand your question
08:05:05 <jethr0_> @type "\1234567"
08:05:06 <lambdabot> lexical error in string/character literal
08:05:28 <adu> i love how you don't need to turn a partial expression into a lambda
08:05:41 <adu> like (+5)
08:05:42 <jethr0_> adu: yup, and you never grow tired of it :)
08:06:37 <jethr0_> > (`elem` 5) [1,3,5,7]
08:06:38 <lambdabot>  add an instance declaration for (Num [[a]])
08:06:56 <davidhouse> @index isUpper
08:06:56 <lambdabot> Data.Char
08:07:00 <jethr0_> i give up and use my personal lambdabot in messagemode. stupid types
08:07:52 <adu> whats the difference between "f g" and "f . g"?
08:07:54 * jethr0_ wonders what shapr's secret evil project is that will change the IT world...
08:08:20 <jethr0_> (f . g) x = f (g x)
08:08:39 <adu> oh rather than (f g) x ?
08:09:11 <jethr0_> is that a question?
08:09:22 <adu> n/m i think i understand now
08:09:23 <Excedrin> "f g" is calling f with g as an argument, "f . g" is returning a new function that is "f (g x)"
08:09:24 <astrolabe> (f g) x means that f returns a function.
08:09:25 <carofe8214660> @type map.filter
08:09:26 <lambdabot> forall a. (a -> Bool) -> [[a]] -> [[a]]
08:10:53 <adu> so that takes a predicate and a matrix and returns a matrix?
08:10:53 <carofe8214660> @type scan1
08:10:54 <lambdabot> Not in scope: `scan1'
08:11:14 <carofe8214660> ops
08:11:18 <carofe8214660> signals
08:11:33 <astrolabe> Does anyone have any recommendations to read about monad transformers except "All about Monads"?
08:11:47 <jethr0_> adu: that's not the easiest possible example :)
08:11:57 <carofe8214660> @(map (+2) [1,2..])!!4 
08:11:57 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
08:12:08 <jethr0_> @type (map (+1)) . (filter even)
08:12:09 <lambdabot> forall a. (Integral a) => [a] -> [a]
08:12:45 * jethr0_ wonders how to use "map . filter" properly...
08:13:00 <adu> @type filter
08:13:01 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
08:13:08 <adu> @type map
08:13:09 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
08:13:16 <davidhouse> when using readLine, pressing Backspace doesn't work.
08:13:23 <davidhouse> how can i fix that?
08:13:30 <carofe8214660> wll
08:13:32 <carofe8214660> well
08:13:33 <jethr0_> davidhouse: i think i had success with changing buffering
08:13:41 <jethr0_> davidhouse: try setting it to NoBuffering
08:14:09 <davidhouse> jethr0_: what's the func for that?
08:14:13 * adu wonders how two functions that go from lists to lists, ever make a matrix
08:14:36 <jethr0_> "hSetBuffering NoBuffering" in System.IO
08:14:43 <davidhouse> thanks
08:14:49 <jethr0_> and a handle in between *grr*
08:15:10 <jethr0_> adu: i don't understand that either, but as i said, it's far from the simplest possible example
08:15:28 <jethr0_> adu: most often you'd concatenate unary functions
08:15:48 <jethr0_> concatenating more-than-unary function get's pretty confusing pretty quickly
08:15:55 <davidhouse> @index NoBuffering
08:15:56 <lambdabot> System.IO
08:16:16 <jethr0_> davidhouse: "hSetBuffering stdin NoBuffering"
08:16:29 <adu> oo i like flip
08:17:01 <Pseudonym> flip plays an important role in functional programming.;
08:17:12 <Pseudonym> It also goes by the cryptic name of "C".
08:17:22 <davidhouse> "Module `System.IO' does not export `NoBuffering'" err...
08:17:32 <adu> is that its name in lambda calculus or something?
08:17:39 <Pseudonym> Combinatory calculus.
08:17:44 <adu> ah
08:17:49 <adu> permutations...
08:17:54 <jethr0_> davidhouse: "import System.IO (BufferMode(..))
08:17:56 <Pseudonym> Not quite.
08:18:01 <jethr0_> davidhouse: or import the whole module
08:18:02 <Pseudonym> If you think of application as an operator:
08:18:33 <Pseudonym> C f g x -> (f $ x) $ g
08:18:47 <Pseudonym> B f g x -> f $ (g $ x)
08:19:10 <Pseudonym> C is flip, B is (.)
08:19:22 <adu> ok
08:19:47 <Pseudonym> So C sends x to its left-hand function, and B sends it to its right-hand function.
08:19:52 <adu> what is Combinatory calculus anyway?
08:20:01 <adu> is it related to combinatorics?
08:20:06 <Pseudonym> Kind of.
08:20:09 <Pseudonym> In a loose way.
08:20:15 <davidhouse> jethr0_: thanks. backspace still doens't work though. grr.
08:20:19 <Pseudonym> It's a way of expressing lambda calculus without variables.
08:20:25 <Pseudonym> So you don't have name capture problems etc.
08:20:33 <jethr0_> davidhouse: i had it working somehow one time, but i never found out why :)
08:20:47 <davidhouse> i'll try LineBuffering
08:21:20 <davidhouse> that worked.
08:21:27 <jethr0_> k, sry for mixing those up
08:21:27 <davidhouse> thanks for the pointer, jethr0_.
08:21:30 <jethr0_> np
08:21:50 <Pseudonym> These functions, B, C etc, are called combinators because they take their arguments and rearrange them.
08:22:14 <jethr0_> Pseudonym: is Y also from combinatory calculus?
08:22:19 <Pseudonym> Yes.
08:22:36 <adu> whats Y?
08:22:59 * astrolabe hides his head
08:23:36 <jethr0_> from the top of my head Y is the fixpoint combinator. with (Y f) = f (Y f) or sth like that
08:24:05 * jethr0_ is going to look for astrolabe
08:24:24 <Pseudonym> Yes, Y f = f (Y f)
08:24:38 <Pseudonym> The point being that Y f is a value x such that x = f x
08:24:41 <Pseudonym> i.e. it's a fixpoint of f
08:24:56 <adu> what's a combinator?
08:25:15 <astrolabe> Y = \f -> (\x -> f x x) (\x -> f x x)  transliterated from wikipedia
08:25:16 <liyang> What's =?
08:25:26 <liyang> Where am I?
08:25:32 <jethr0_> > fix (\f n -> if n == 0 then 1 else n * f (n-1)) 6
08:25:33 <liyang> Who am I?!
08:25:33 <lambdabot> 720
08:25:35 <Pseudonym> You can think of a combinator as a lambda expression which doesn't reference any external symbols.
08:25:53 <Pseudonym> So, for example: flip = \f x y -> f y x
08:26:12 <adu> is that the same as points-free programming style?
08:26:19 <Pseudonym> The only symbols on the RHS are the ones that are lambda bound.
08:26:25 <carofe8214660> >map (1+) [1,2..5] 
08:26:34 <Pseudonym> Pointless programmers like combinators, if that's what you mean.
08:26:51 <Pseudonym> This: plus = \x y -> x + y
08:26:52 <adu> hmm, so they're not the same?
08:26:53 <liyang> carofe8214660: needs more space.
08:26:54 <Pseudonym> is not a combinator
08:27:05 <Pseudonym> Because (+) isn't lambda-bound.
08:27:20 <adu> oh, ok
08:27:35 <jethr0_> Pseudonym: so combinators don't use a/the environment, right?
08:27:36 <carofe8214660> i just trying lamdbot
08:27:40 <Pseudonym> Right.
08:27:45 <adu> so a conbinator is like a completely specified function
08:27:51 <liyang> carofe8214660: you need a space after the >
08:28:23 <astrolabe> Is [1,2..5] haskell?
08:28:28 <Pseudonym> They are related to pointless style in the sense that 
08:28:37 <Pseudonym> pointless programming is variable-free.
08:28:40 <liyang> > map (1) [1,2..5]
08:28:41 <lambdabot>  add an instance declaration for (Num (a -> b))
08:28:46 <Pseudonym> Where possible.
08:28:49 <liyang> > map (1+) [1,2..5]
08:28:50 <lambdabot> [2,3,4,5,6]
08:29:06 <Pseudonym> And it's for the same reason: pointless programmers like rearranging things without running into name capture.
08:29:25 <adu> what is "name capture"?
08:29:37 <carofe8214660> @eval (map (1+) [1..])57
08:29:38 <lambdabot> Couldn't match `[a]' against `t -> t1'
08:29:46 <carofe8214660> @eval (map (1+) [1..])!!57
08:29:47 <Pseudonym> Name capture is the ugliest piece of lambda calculus.
08:29:47 <lambdabot> 59
08:29:51 <carofe8214660> ooo
08:29:57 <liyang> adu: let x = 1 in let x = 2 in x == (what?)
08:30:01 <astrolabe> If I remember 'The little lisper' The Y combinator lets you right recursive functions without nameing them.
08:30:03 <carofe8214660> that's good
08:30:08 <astrolabe> *write
08:30:21 <Pseudonym> (\f x -> f x) x |-> (\x -> x x)
08:30:27 <Pseudonym> That's actually not valid.
08:30:35 <jethr0_> > fix (\f n -> if n == 0 then 1 else n * f (n-1)) 6
08:30:36 <lambdabot> 720
08:30:38 <Pseudonym> The correct way to express this is to rename the first x:
08:30:47 <adu> liyang: so "name capture" is related to scoping?
08:30:52 <Pseudonym> (\f x' -> f x') x = (\x' -> x' x)
08:30:59 <Pseudonym> Errr.
08:31:04 <Pseudonym> (\f x' -> f x') x = (\x' -> x x')
08:31:06 <Pseudonym> That's right.
08:31:12 <Pseudonym> Kind of, yes.
08:31:23 <Pseudonym> The problem here is that the outer x has been captured.
08:31:37 <Pseudonym> This wouldn't happen if the function had been expressed point-free.
08:31:38 <adu> is it the process of protecting scope contexts?
08:31:41 <liyang> adu: something like that. See Pseudonym's explanation. :)
08:31:52 <Pseudonym> Name capture is the problem.
08:31:55 <adu> oh
08:32:07 <Pseudonym> The solution is usually to say that the rules work "up to renaming" and leave it at that. :-)
08:32:32 <carofe8214660> @eval [x|x<-[1..233],234 `mod` x ==0]
08:32:33 <lambdabot> [1,2,3,6,9,13,18,26,39,78,117]
08:32:39 <carofe8214660> ooohh
08:32:59 <Pseudonym> But combinatory calculus, De Brujin numbering etc are all schemes for solving the problem in various creative ways.
08:33:18 <adu> but aren't things like that taken care of if you use functions rather than putting things using the same variable in the same lexical context?
08:33:39 <carofe8214660> lambdabot is may new toy
08:33:47 <Pseudonym> Ah, but they're NOT the same variable.
08:34:09 <Pseudonym> Name capture is only a problem if you view lambda calculus as a simple symbol manipulation.
08:34:10 <adu> like f x = x + 1 and g x = 2*x, wouldn't f (g x) work like expected?
08:34:12 <astrolabe> carofe8214660: You can private message it too if you're logged on.
08:34:20 <Pseudonym> Yes, they would.
08:34:36 <jethr0_> astrolabe: actually it works even when not logged it...
08:34:36 <Pseudonym> And they'd work because a Haskell compiler, just like any other compiler, would rename variables as necessary.
08:35:04 <adu> Pseudonym: but is that because of name capture? or something else?
08:35:35 <Pseudonym> It's because when you call a function, the variables that are local to that function are different from those that are local to the caller.
08:35:41 <Pseudonym> That's true in C, too.
08:36:01 <Pseudonym> Regardless of whether or not they have the same display name.
08:36:26 <adu> so basically, i don't need to worry about name capture when i'm just learning Haskell...
08:36:34 <Pseudonym> Not at all.
08:36:36 <adu> :)
08:36:46 <liyang> from a more pragmatic point of view, you don't get confused over variables that look the same but really aren't. :)
08:36:51 <Pseudonym> It only comes up if you want to refactor your programs in bizarre way.
08:37:08 <carofe8214660> well, i leave you, some day we will talk about haskell, funtional programing and so on again
08:37:15 <carofe8214660> ciao
08:37:15 <adu> like using Haskell with a text preprocessor?
08:37:16 <liyang> (though the concept of pointlessness confuses some even more.)
08:37:29 <adu> i could see that causing name problems
08:37:35 <Pseudonym> Actually, text preprocessors have many, many good examples of name capture problems, yes.
08:37:47 <Pseudonym> Because text preprocessors are simple syntax manipulators.
08:37:56 <Pseudonym> They don't understand the semantics of what they manipulate.
08:38:03 <adu> are there complex syntax manipulators?
08:38:27 <Pseudonym> Sure.
08:38:43 <Pseudonym> C++ "inline" functions, C++ templates, Lisp/Scheme macros etc.
08:38:47 <Pseudonym> Template Haskell.
08:39:11 <adu> now that i think about it, DOM implementations would be an example
08:39:23 <Pseudonym> Good example.
08:39:29 <adu> they're a little bit more understanding than text replacing XML
08:39:51 <Pseudonym> Although I can imagine that a badly written DOM or XSLT transformation might stuff up XML refs.
08:40:02 <adu> hehe
08:40:04 <Pseudonym> But still, yes, it's structural.
08:41:51 <adu> do you know any matrix libraries for haskell?
08:43:27 <adu> i'm hoping to use matrices of the form [[BigFloat]] or something like that...
08:43:47 <shapr> g'day Pseudonym 
08:44:00 <Pseudonym> G'day.
08:44:55 <adu> oh, there is a BigFloat library
08:46:49 <Excedrin> C++ inlines manipulate syntax?
08:47:32 <jethr0_> http://haskelldsp.sourceforge.net/doc/index.html
08:47:50 <jethr0_> adu: but i guess its feature-set is rather reduced for very matrix-specific things
08:48:13 <Pseudonym> Excedrin: After a fashion.
08:48:20 <adu> hmm it doesn't have matrix inverse
08:48:24 <adu> but thats ok
08:48:26 <jethr0_> Excedrin: in the sense of name capture they really have to
08:48:29 <Pseudonym> An inline function is like a macro, only it respects semantics.
08:48:48 <adu> i can port m C code to haskell, and spend 5 years making it shorter :)
08:49:33 <jethr0_> adu: it's really a pity that there aren't more such libraries around :(
08:49:52 <adu> wait there is an inverse in Matrix.LU
08:50:02 <adu> :)
08:50:08 <jethr0_> adu: alternatively you could just call your code from haskell and not lose 5 years in the process :)
08:50:52 <adu> jethr0_: i think i'll just convert Matrix.LU.inverse from Double to BigFloat
08:51:32 <adu> jethr0_: its less a matter of efficiency and more a matter of learning Haskell
08:51:52 <jethr0_> shapr: i can, but i'm not registered so whatever i type you won't see it :)
08:51:55 <dcoutts> liyang, http://haskell.org/gtk2hs/archives/2006/03/06/introductory-presentation/
08:52:05 <dcoutts> liyang, tell me if you think anything is missing
08:53:19 <jethr0_> it would be cool to have haskell bindings for a matrix/algebra equivalent of GMP
08:54:12 <astrolabe> I think someone wrapped Lapack
08:54:31 <adu> jethr0_: GSL has some nice matrix routines
08:54:56 <adu> GSL+GMP is a very nice combo i think
08:55:24 <adu> jethr0_: how would one go about making haskell bindings?
08:55:42 <adu> i suppose there's a tut somewhere...
08:56:20 <jethr0_> adu: making "bad" bindings isn't all that hard, that's automated to some degree via c2hs or similar. the point is to make idiomatic bindings that feel natural in haskell
08:56:46 <adu> ic
08:57:41 <jethr0_> adu: for ones own use, it's pretty feasible to FFI a few functions from a library. it's extremely simple even. but to make public bindings for everyone that is a lot of work, i think
09:26:15 <adu> well the c2hs stuff seems to make sense, but then again i haven't tried using it yet :)
09:32:15 <palomer> http://www.rafb.net/paste/results/BJFdTX76.html <--anyone have any idea what this is about?
09:34:09 <palomer> oh, righto nevermind
09:37:52 <dcoutts> adu, for a textbook example of using c2hs see the cairo bindings.
09:39:15 <palomer> world's longest type: gp::[Prefix (MonoSType s)] -> Kind -> StateT ((([([MonoSType s],MonoSType s)]),([(Prefix (MonoSType s),MonoSType s)])),Bool) (STI s) (Prefix (MonoSType s))
09:39:29 <palomer> gah!
09:39:38 <Philippa> you should see the types a good SQL binding can produce
09:39:52 <Philippa> the constraints alone can get huge
09:40:22 <Philippa> if you've got that written down, I hope you're using whitespace to expose the structure of the type a bit better?
09:40:41 <Philippa> type synonyms might help too
09:40:56 <palomer> how would I use whitespaces?
09:41:20 <Philippa> just throw in spaces and newlines so that the conceptual blocks are kept together and the big links between them're clear
09:41:33 <Philippa> similar idea to how lisp code's layed out
09:43:57 * dcoutts feels compelled to self-publicise:
09:43:59 <dcoutts> http://haskell.org/gtk2hs/archives/2006/03/06/introductory-presentation/
09:44:41 <dcoutts> xerox, did I already show you an early version of our gtk2hs presentation?
09:44:57 <adu> does gtk2hs use c2hs?
09:45:02 <dcoutts> adu, yes
09:45:11 <adu> oh, cool, i'll check it out
09:45:17 <dcoutts> we're pretty happy with it
09:45:27 <adu> i'm trying to learn haskell and c2hs 
09:45:34 <dcoutts> adu, gtk2hs is a big thing, take a look at cairo, it's much simpler
09:45:42 <adu> ok
09:46:03 <jimapple> @google cairo haskell
09:46:05 <dcoutts> cairo is currently distributed with gtk2hs: http://darcs.haskell.org/gtk2hs/cairo/
09:46:05 <lambdabot> http://haskell.org/gtk2hs/
09:46:21 <dcoutts> http://darcs.haskell.org/gtk2hs/cairo/Graphics/Rendering/
09:46:32 <Philippa> dcoutts: apologies for not sorting out a way of saying hi on friday btw
09:46:39 <dcoutts> Philippa, np.
09:47:03 <dcoutts> Philippa, I like the way the FP group takes off to the pub every Friday at 4pm!
09:47:15 <adu> woah i really don't know haskell
09:47:22 <dcoutts> adu, ?
09:47:33 <edwinb> only on Fridays?
09:47:41 <dcoutts> edwinb, heh
09:48:06 <edwinb> I'm staying with Conor this week. My previous experience has been that it's more frequent than that...
09:48:19 <adu> theres a "snippet" that uses ">>" and ">>=" which i don't understand
09:48:35 <dcoutts> edwinb, so pehaps he's being restrained in Nottingham :-)
09:48:42 <Philippa> dcoutts: nice'n'practical, no? :-)
09:48:59 <dcoutts> edwinb, we had a good chat with Conor and his epigram team about their new GUI
09:49:15 <edwinb> Mmm, I'm looking forward to catching up with what they're up to
09:49:15 <dcoutts> adu, which bit exactly?
09:49:26 <dcoutts> edwinb, it's an exciting project
09:50:19 <adu> um is there a cairo tarball?
09:50:23 <kosmikus> edwinb: so you're no longer directly involved?
09:50:37 <dcoutts> adu, it's part of the gtk2hs-0.9.10 release which has a tarball
09:51:01 <dcoutts> adu, or use darcs
09:51:02 <edwinb> kosmikus: Not directly, but I'm still doing stuff when I can.
09:51:15 <dcoutts> they're being quite ambitious with the GUI (though not unrealisticly so) which I'm excited about
09:51:57 <dcoutts> going for WYSIWYG editing of LaTeX quality formula layout
09:52:04 <adu> so is cairo part of Gtk or Gtk2Hs?
09:52:23 <adu> n/m
09:52:32 <adu> i'm tired
09:52:45 <dcoutts> adu, cairo is a 2D rendering lib used by Gtk and applications which use Gtk. The haskell binding is included in Gtk2Hs
09:53:07 <adu> what happened to libart?
09:53:16 <dcoutts> it's not as good as cairo
09:53:20 <adu> ic
09:53:21 <dcoutts> that's what happened
09:53:52 <dcoutts> libart had various problems which are solved in cairo
09:54:01 <dcoutts> and cairo has much else besides
09:54:11 <dcoutts> like multiple backends and hardware acceleration
09:54:19 <dcoutts> and a simpler API
09:54:40 <adu> hmm has anyone tested Gtk2Hs on Mac OS X with Apple's X11?
09:54:47 <dcoutts> adu, yep
09:54:50 <adu> yey
09:54:57 <dcoutts> not personally, but people have
09:55:09 <adu> maybe i can play with it
09:55:32 <dcoutts> it doesn't look native of course, we're still waiting for the native port to mature
09:56:24 <adu> well, there like some kind of default Gtk theme that looks 80% like Apple's Aqua
09:56:30 <dcoutts> right
09:56:42 <dcoutts> the native port doesn't use X11 and will hopefully look better and integrate better
09:56:52 <adu> nice
09:56:52 <dcoutts> but it's still in development
10:01:08 <adu> igtg
10:03:00 <Excedrin> why not use wxhaskell?
10:03:18 <Philippa> it's less well-developed
10:03:40 <Philippa> I had real problems creating an IRC chat display in it for example because I couldn't make it behave appropriately when new text was added
10:04:55 <Excedrin> flickering? or something else
10:05:30 <Philippa> scrolling so only the new line's visible
10:05:46 <Philippa> and playing silly buggers if I tried to make it do the appropriate thing
10:06:50 <dons> though wxHaskell was the default lib to use for the last 10 years, gtk2hs has been coming into its own in the last year or so
10:07:06 <dons> it's much more actively developed, which helps a lot
10:07:29 <dcoutts> dons, wxhaskell is only a couple years old, gtk2hs it much older (going all the way back to gtk+hs for Gtk+ 1.x)
10:07:53 <dons> ? I thought wxHaskell was supposed to have a "10 year hisotry" . hmm.
10:08:04 <dcoutts> oh, wxWidgets is that old
10:08:07 <dcoutts> not the Haskell binding
10:09:14 <dons> hmm. ok. i guess i missed that somehow.
10:11:47 <dons> ah, I see "in development since 1992" on the wx page actually refers to  wxWidgets :) I hadn't read this page in years, and slowly my memory turns to mush http://www.cs.uu.nl/~daan/wxhaskell.html  
10:12:54 <dons> hmm, or maybe it really is a bit ambiguous.
10:13:25 <Philippa> what's the state of MozEmbed under windows? What do I need to do in order to use it?
10:17:02 * Philippa reads
10:17:04 <dcoutts> Philippa, it's pretty hard I think. You need a Gtk+ build of Mozilla on win32 to use MozEmbed
10:17:31 <Philippa> damn. I could really use it for an idea I just had...
10:26:24 <Excedrin> how old is Haskell?
10:30:28 <Lemmih> I think the first Haskell committee assembled in '86. I may be completely off, tho.
10:34:49 <dons> nah, but the first lazy ML papers were in the early 80s, if I remember
10:35:50 <Philippa> IMO gestation doesn't count
10:36:50 <dons> sorry, mid 80s. Lennart's work on compiled graph reduction was published ~87
10:37:13 <dons> then the first references to Haskell are around 1990, I think.
10:38:29 <dons> I always find fun the fact that when you build the hbc haskell 98 compiler, it first builds a binary called `lml`
10:38:46 <dons> oh, "A compiler for lazy ML" was 84.
10:42:32 <dons> so, mid-80s things were really starting to get going, and by 1990 there was a language called `Haskell'. We should ask lennart to clarify when some of the compilers actually called 'Haskell' were released.
10:42:59 <dons> Haskell 1.2 was in place by 93.
10:45:32 <palomer> @pl \x y-> do {x' <- x; y x}
10:45:34 <lambdabot> (line 1, column 11):
10:45:34 <lambdabot> unexpected "{"
10:45:34 <lambdabot> expecting variable, "(", operator or end of input
10:45:38 <palomer> @pl \x y-> do{x' <- x; y x}
10:45:38 <lambdabot> (line 1, column 10):
10:45:38 <lambdabot> unexpected "{"
10:45:38 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
10:45:38 <palomer> @pl \x y-> (do{x' <- x; y x})
10:45:38 <lambdabot> (line 1, column 11):
10:45:38 <lambdabot> unexpected "{"
10:45:38 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
10:45:38 <dons> Excedrin, there's somewhat of a history here http://www.haskell.org/haskell-history.html, though it doesn't go as far back as Frege.
10:45:38 <palomer> ok, what's the deal with lambdabot
10:45:47 <dons> oh, yeah, miranda (the evil twin of haskell) was developed in 85 or so
10:46:13 <dons> palomer? who says @pl parses any random haskell? 
10:46:14 <dons> @pl \x y -> x >>= \x' -> y x
10:46:14 <lambdabot> liftM2 (.) (>>=) ((const .) . flip id)
