00:05:46 <Cale> > 1 + 1
00:05:47 <mbot>  2
00:05:47 <lambdabot>  2
00:05:50 <Cale> yay
00:08:33 <newsham> blah, haxml documentation was written for robots
00:09:06 <newsham> o: "Sequential (Irish,backwards) composition"
00:09:10 <newsham> aha!  *sigh*
00:09:30 <dons> f >.> g, right?
00:15:20 <newsham> if i new i wouldnt be shrugging
00:15:47 * araujo just notices hs-plugins broken in amd64
00:16:12 <dons> hmm?
00:16:29 <dons> and just when its working again on os x
00:18:17 <newsham> f `o` g = concat . map f . g    <- why is it called "irish composition" (other than the reference to O'xxx) ?
00:19:39 <dons> i've never heard of this before, but it can surely on mean that its in | or >>= order, rather than in '.' order
00:20:13 <dons> ?type \f g -> concat . map f . g
00:20:13 <newsham> isnt in the same order?   f `o` g = .... f . g
00:20:15 <lambdabot> forall a a1 a2. (a1 -> [a]) -> (a2 -> [a1]) -> a2 -> [a]
00:20:26 <dons> ?pl \f g -> concat . map f . g
00:20:27 <lambdabot> ((join .) .) . (.) . map
00:20:39 <dons> ?pl \f g -> f >>= g
00:20:39 <lambdabot> (>>=)
00:20:44 <dons> ?pl \f g -> g >>= f
00:20:44 <lambdabot> (=<<)
00:20:57 <dons> ?t \f g -> g >>= f
00:20:57 <lambdabot> Maybe you meant: tell time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . v
00:21:01 <dons> ?type \f g -> g >>= f
00:21:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
00:21:33 <dons> f `o` g = concat . map f . g looks almost like a list monad >>=
00:21:47 <sieni> @pl \a b c -> a b c
00:21:48 <lambdabot> id
00:21:50 <newsham> its from http://www.cs.york.ac.uk/fp/HaXml/icfp99.html (haxml)
00:21:53 <lambdabot> Title: Haskell and XML: Generic Combinators or Type-Based Translation?
00:22:23 <dons> m >>= k             = foldr ((++) . k) [] m --> concatMap k m
00:28:19 <kzm_> Any ubuntu users here?
00:28:58 <kzm_> ..or anybody using dh_haskell to build .debs?
00:31:43 <kzm_> ...or anybody at all? :-)
00:32:04 <kfish> hi kzm_, i use ubuntu ... haven't tried dh_haskell though
00:32:17 <kfish> ghc, cabal packages are a bit out of date :-/
00:32:41 <kzm_> Yes.  I filed a 'bug', asking for 6.4.2 to be backported to dapper.
00:33:02 <kzm_> Especially the outdated version of cabal is a pain in the a^Hneck.
00:33:47 <kzm_> Feel free to voice your support in the bug tracking system (Malone) :-)
00:34:20 <Cale> dons: It was a whole mess of things -- with runplugs, it was just that it didn't exist in the user's path, and with runmath, mathematica hadn't been configured also.
00:35:45 <kzm_> https://launchpad.net/distros/ubuntu/+source/ghc6/+bug/56516
00:38:18 <kfish> kzm_, what version of ghc is in edgy?
00:38:34 <kzm_> kfish: 6.4.2
00:38:45 <kzm_> It should have the upcoming 6.6, of course.
00:38:50 <kfish> that would rule
00:38:51 <kzm_> Being 'edgy' and all.
00:38:56 <kfish> heh
00:39:00 <kzm_> Bleeding Edgy?
00:40:18 <kfish> the bug you reported probably explains the profiling wierdness i had a few weeks ago (hacking with dons)
00:43:58 <araujo> dons, you hadn't received any report about it?
00:44:04 <dons> araujo: nope
00:44:11 <dons> kfish: ah!
00:44:30 <dons> with the missing profiling results?
00:44:54 <kfish> yeah, or -auto-all not working
00:45:34 <dons> yep, right
00:48:48 <shapr> @users
00:48:50 <lambdabot> Maximum users seen in #haskell: 235, currently: 193
00:48:55 <shapr> poing
00:48:56 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
00:49:34 <dons> ?yow!
00:49:35 <lambdabot> Yow!  Are you the self-frying president?
00:51:20 <araujo> mmm...
00:51:27 <araujo> it is working fine here it seems
00:51:56 * araujo should re-mark it as usable 
00:54:28 <araujo> mm ..
00:55:25 <dons> oh good
00:55:45 <araujo> magic number mismatch: old/corrupt interface file?
00:56:01 <araujo> keep getting that when i link it with hashell
00:56:31 <araujo> compilation and everything else went fine
00:59:23 <dons> sounds like it was compiled with one versoin of ghc, but is using another?
00:59:36 <dons> you have a couple of ghcs installed simultaneously?
00:59:42 <dons> or some old libraries lying around?
01:02:13 <araujo> no dons
01:02:33 <araujo> actually, i have only installed one ghc version here in this box so far
01:02:42 <araujo> 6.4.2
01:04:17 <dons> hmm. well .hi file mismatches usually (always?) means that there are somehow .hi files compiled with a different version of ghc to the one you're using
01:04:27 <dons> or... this is an hs-plugins error?
01:04:41 <dons> then it could be the .hi file parser in hs-plugins is broken on your box
01:04:46 <dons> possibly its an old hs-plugins?
01:04:53 <dons> or maybe its a new bug, that hasn't been reported..
01:07:42 <sieni> Making Haskell programs faster and smaller: http://users.aber.ac.uk/afc/stricthaskell.html
01:07:44 <lambdabot> Title: Making Haskell programs faster and smaller
01:08:00 <sieni> Making ML programs faster and smaller:  http://www.hurmio.org/~ville/strictml.html
01:08:05 <lambdabot> Title: Making ML programs faster and smaller
01:11:05 <araujo> dons, first version i install of hs-plugin too
01:12:29 <araujo> dons, using 9.10
01:13:00 <dons> try 1.0
01:17:15 <araujo> ok dons
01:34:01 <araujo> dons, ok, that seemed to work :-)
01:34:09 <dons> 1.0?
01:34:19 <araujo> yes dons
01:34:49 <dons> cool
02:02:21 <kowey> is there a function (somewhere in Data.Typeable, i guess) like this? magicalFn (Just 'a') == "Just"
02:05:40 <xerox> > let magicalFn Nothing = "Nothing"; magicalFn (Just _) = "Just" in magicalFn (Just 'a')
02:05:41 <lambdabot>  "Just"
02:05:55 <xerox> But maybe you want... Maybe :)
02:06:04 <kowey> :-) not quite what i had in mind...
02:06:13 <xerox> > typeOf (Just 'a')
02:06:14 <lambdabot>  Maybe Char
02:06:37 <xerox> ?index typeOf
02:06:37 <lambdabot> Data.Typeable, Data.Dynamic, Data.Generics.Basics, Data.Generics
02:06:42 <kowey> > typeRepTyCon.typeOf (Just 'a')
02:06:43 <xerox> ?type Data.Typeable.typeOf
02:06:43 <lambdabot>    Expecting a function type, but found `TypeRep'
02:06:43 <lambdabot>    Expected type: a ->...
02:06:44 <lambdabot> forall a. (Typeable a) => a -> TypeRep
02:06:58 <xerox> substitute . with $.
02:07:13 <kowey> > typeRepTyCon $ typeOf (Just 'a')
02:07:14 <lambdabot>  Maybe
02:07:24 <xerox> ?docs Data.Typeable
02:07:25 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html
02:07:33 <kowey> hmm... I wanted Just... (yeah, looking at that now)
02:07:52 <xerox> Just is a data constructor
02:08:27 <kowey> aha... (i did not know there was a difference between 'data constructor' and 'type constructor')
02:08:41 <xerox> To check wether a value of type Maybe a is a Nothing or a Just a, you pattern-match at value level.
02:08:46 <dons> one builds a value, the other builds a type :)
02:08:52 <kowey> yeah, but...
02:09:10 <dons> ?kind Maybe -- a type constructor. takes a type, returns a new type
02:09:11 <lambdabot> * -> *
02:09:22 <dons> ?type Just -- a data constructor, takes a value, returns a new value
02:09:24 <lambdabot> forall a. a -> Maybe a
02:09:28 <xerox> ?kind (->) -- takes two types, return a type.
02:09:30 <lambdabot> ?? -> ? -> *
02:10:00 <kowey> so meta
02:10:22 <kowey> ok, back to something concrete (the yeah but)...
02:10:39 <xerox> ?kind Control.Monad.RWS.RWST -- takes lots of types, return a type
02:10:40 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
02:10:54 <dons> even takes a type constructor itself, it seems
02:11:05 <xerox> Yup, a monad, because it is a monad transformer.
02:11:16 <dons> of course
02:11:58 <dons> so its like a 'map' on types, looking at the last part of the kind, (* -> *) -> * -> *
02:12:55 <xerox> At least the shape is similar
02:13:14 <dons> yep
02:13:15 <xerox> But you wouldn't be able to implement a type-map, I believe
02:13:36 <dons> well, what would it be? a list of types, to a new list of types? seems a bit strange
02:13:51 <Cale> Of course, not just looking at the last part of the kind, it's really a monad transformer constructor constructor constructor
02:14:04 <Cale> hehe
02:14:07 <xerox> Yuck.
02:14:28 <xerox> dons, maybe you need higher-kinded types to encode "list of types" ?
02:14:29 <dons> hehe
02:14:43 <xerox> (* -> *) -> [*] -> [*]
02:14:54 <dons> but [] is a (* -> *), remember
02:15:21 <dons> i'm not even sure what a list of types is, without more kinds
02:15:31 <xerox> That's what I mean, yeah :)
02:16:00 <audreyt> what's the fps idiom to implement
02:16:02 <dons> ?hoogle * -> * -> *
02:16:03 <lambdabot> Hoogle Error: Parse Error: Unexpected character '* -> * -> '
02:16:08 <audreyt> substr($x, 0, -5)
02:16:10 <audreyt> again?
02:16:13 <dons> hehe. should we ask ndm for kind searching?
02:16:14 <xerox> ?kind Control.Arrow.Arrow
02:16:15 <lambdabot> Class `Arrow' used as a type
02:16:23 <dons> audreyt: hmm, what's that do?
02:16:26 <xerox> ?type Control.Arrow.Arrow
02:16:28 <lambdabot> Not in scope: data constructor `Control.Arrow.Arrow'
02:16:33 <audreyt> dons: dropEnd 5
02:16:34 <xerox> Hmmm.
02:16:40 <xerox> ?type (&&&) -- :)
02:16:42 <lambdabot> forall (a :: * -> * -> *) c' c b. (Arrow a) => a b c -> a b c' -> a b (c, c')
02:16:44 <audreyt> except there's no dropEnd :)
02:16:48 <dons> audreyt: hmm .take the length, drop len - 5 ?
02:17:00 <dons> drop (length fps - 5) ?
02:17:06 <audreyt> er no
02:17:09 <audreyt> take (length fps - 5)
02:17:21 <dons> oh, dropEnd, yes
02:17:34 <dons> take (length fps - 5) is O(1) , so should be fine
02:17:37 <audreyt> k
02:17:45 <audreyt> I'll add it to my missing-style libs :)
02:18:50 <xerox> ?kind (Arrow (~>)) => (a ~> b)
02:18:52 <lambdabot> *
02:18:58 <xerox> ?kind (Arrow (~>)) => (~>)
02:19:00 <lambdabot>   `~>' is not applied to enough type arguments
02:19:00 <lambdabot>   Expected kind `*', but `~>' has kind `* -> * -> *'
02:19:25 <xerox> ?kind (Arrow a) => a b c
02:19:26 <lambdabot> *
02:19:35 <xerox> Spit * -> * -> * \bot!!
02:29:50 * dcoutts pokes xerox
02:29:58 <xerox> Yow.
02:30:01 <dcoutts> xerox, how's cabal-install going :-)
02:30:14 * xerox shakes head
02:30:39 <dcoutts> don't say that :-(
02:32:47 <eivuokko> dcoutts, xerox, Seen my mail to cabal-devel about Windows enchaments?  Any opinions?
02:33:20 <dcoutts> eivuokko, I know very little about dlls, but the RC seems ok to me
02:34:13 <eivuokko> Is the idea of DLL-building bad, or just that it needs to change PackageDescription etc quite a bit?
02:35:28 <dcoutts> eivuokko, so it's most like building a .exe right
02:35:35 <eivuokko> Yes.
02:35:44 <dcoutts> as you say, this isn't for haskell packages as dlls
02:35:56 <eivuokko> Yeah, that is whole diffrent story.
02:36:02 <eivuokko> (And doesnt' work anyway)
02:36:28 <dcoutts> so you want somethine like an executable section, but a dll
02:37:11 <eivuokko> The diffrence between DLL and .exe is really that one has exported symbol WinMain or ServiceMain and another has DllMain, and gets loaded into another process.
02:38:00 <eivuokko> There are few other details, I think, but practically nobody needs to worry about those.
02:38:10 <dcoutts> eivuokko, I'd try and get an opinion from JaffaCake
02:39:15 <eivuokko> Hmmm.  I wish it wasn't just Windows-people who can answer the question about suitability.  I guess I phrased my mail badly - should've just asked if it's suitable task for Cabal to perform.
02:39:31 <eivuokko> And leave implementation details for later...
02:42:59 <dcoutts> eivuokko, so perhaps you want: shared-lib: ...; main-is: ...; etc
02:43:19 <dcoutts> eivuokko, ie exactly like the exeutable stanzas but for a .dll
02:43:51 <eivuokko> That is one choice, except that at the moment there is never main for a DLL
02:43:58 <eivuokko> (from ghc point of view)
02:45:06 <dcoutts> eivuokko, ah, so the linking is al different
02:45:27 <dcoutts> would it fail if you did have a main?
02:45:31 <eivuokko> No
02:45:50 <eivuokko> The diffrence is almost totally fictioned up by toolchain authors
02:45:55 <dcoutts> ok,
02:46:21 <eivuokko> And of course it is much easier to explain to newbies, because the related issues of memory etc handling are not fiction.
02:47:22 <eivuokko> Mostly, for ghc, it is because gnu toolchain can't really handle export/import business required by DLLs.
02:49:46 <tibbe> can FPS be used to give a boost to socket performance?
02:51:45 <dons> tibbe: I believe so, yes. musasabi uses it for a super-fast web server implementation
02:51:53 <dons> you might want to talk to him more about its use
02:53:46 <dcoutts> dons, oh, did we fix the non-blocking issue
02:55:33 <dons> well, we have a nonblocking IO function. its not the default though -- it should be
02:57:09 <dcoutts> I don't think we need hGetSome in ByteString
02:57:22 <dons> no, I agree
02:57:29 <dons> we toss the old hGetNonBlocking?
02:57:30 <dcoutts> but we should make Lazy.hGetContents use non-blocking + waiting
02:57:39 <dcoutts> hGetNonBlocking is ok
02:57:45 <dcoutts> it's just like in Syatem.IO
02:57:54 <dons> oh, we don't need the strict version of hGetSome at all?
02:58:00 <dcoutts> right
02:58:11 <dcoutts> it's just hWaitForInput >> hGetNonBlocking
02:58:12 <dons> why's that, again?
02:58:17 <dons> ah ok.
02:58:19 <dcoutts> which you can do already
02:58:37 <dons> ok. but we do need it for the lazy bytestrings?
02:58:43 <dcoutts> yes
02:58:46 <dcoutts> but i'll be default
02:58:49 <dcoutts> so no new api
02:58:56 <dons> ok. that sounds ok.
03:04:48 * dcoutts fixes that
03:14:04 <dmhouse> Morning all.
03:15:27 <araujo> morning
03:47:47 <shapr> @users
03:47:48 <lambdabot> Maximum users seen in #haskell: 235, currently: 195
03:48:16 <ValarQ> hello shapr
03:55:37 <shapr> hiya ValarQ
04:42:45 <tibbe> dons, oh thanks, was away for lunch, I'll speak with him
04:43:15 <tibbe> @seen musasabi
04:43:16 <lambdabot> musasabi is in #haskell-overflow, #haskell-blah and #haskell. I last heard musasabi speak 12 hours, 16 minutes and 13 seconds ago.
04:43:29 <tibbe> musasabi, ping
04:52:17 <nomeata> hi. can I check if a record field is undefined?
05:48:38 * mux ponders having some fun with Haskell, or actually doing what he's paid for
05:48:42 <mux> tough choice
05:51:52 * tibbe wishes he had his laptop with him so he could have some fun with haskell instead of doing his job
05:52:48 <mux> you can't have haskell on your work computer?
05:54:43 * gds sees a niche for a lambdabot style on-line evaluation service for larger programmes...
05:56:22 <Philippa> get a shell account somewhere?
05:56:36 <vegai> I'm torn: should I scorn you for being slackers, or do what I'm paid for
05:56:37 <Philippa> (somewhere that doesn't mind the memory and CPU usage)
05:56:38 <sieni> apt-get install ghc? :-)
05:57:40 <vegai> ..or perhaps convert all your codebase to Haskell: both problems solved
05:57:48 <vegai> well, at least one.
05:57:58 <vegai> unless it's not fun.
05:59:07 <pejo> vegai, odds are that you need to be bug-compatible with the old source.
06:01:42 <tibbe> mux, I run haskell on my linux box (laptop) not on my win2000 job desktop, I'm only at this job temporary so no point in installing it
06:01:56 <mux> heh, I think I would do it anyways :-)
06:02:10 * mux has a FreeBSD work box
06:02:39 * tibbe has a secret installation of VMWARE server so he can get a fix once in a while anyway
06:28:46 <musasabi> tibbe: pong
06:31:01 <musasabi> tibbe: for web stuff + fps see HAppS. for the most recent fps version you well need http://www.cs.helsinki.fi/u/ekarttun/haskell/happs-fps.patch
06:32:47 <tibbe> musasabi, ah thanks, looking at it as we speak
06:38:04 <spiffy> I was looking to read Yet Another Haskell Tutorial, but the site appears down. Would it be possible for someone to send me a copy of the pdf?
06:39:13 <benja_> spiffy: http://www.ceng.metu.edu.tr/courseweb/ceng242/documents/haskell/yetanothertutorial.pdf seems to work
06:39:19 <benja_> (googled :))
06:39:29 <benja_> but dunno if it is outdated or whatever
06:40:13 <spiffy> o thanks benja_
06:40:18 <benja_> :)
06:57:15 <semi> up to date, fully comprehensive haskell book for someone with programming background - recommendations?
06:57:38 <semi> umm
06:57:45 <dons> up to date and fully comprehensive?
06:57:53 <dons> there's no such book, unfortunately.
06:58:06 <dons> however, there are many good tutorials, and then on to research papers and documentation
06:58:11 <dons> start at http://haskell.org
06:58:13 <lambdabot> Title: Haskell - HaskellWiki
07:00:35 <semi> too bad, i'd like something that i can read in bed before sleep instead of online
07:00:54 <eivuokko> Printing YAHT is probably the nicest choice.
07:01:15 <dons> yeah, that's a good idea
07:01:22 <dons> YAHT is probably the place to start
07:01:36 <dons> or the 'gentle introduction'
07:01:42 <norpan> yaht yaht yaht
07:01:45 <semi> so, that's up to date and has the whole language?
07:02:06 <dons> well, haskell98 is certainly covered
07:02:11 <tibbe> is there a way to make parsec use the new FPS?
07:02:12 <dons> extensions you can pick up as you go
07:02:23 <semi> are the extensions important?
07:02:27 <eivuokko> Yes
07:02:29 <jgrimes_> yes :)
07:02:36 <dons> they are, they're being currently standardised
07:02:45 <semi> kind of like boost for c++ ?
07:03:14 <eivuokko> semi, There are much more language extensions than that.  But yes, standard libraries have also been reorganised, for practical problems.
07:03:23 <eivuokko> *programs
07:03:33 <dons> anyway,the best way to start is to read yAHT
07:03:34 <semi> ok, i'll just print the yaht then
07:03:36 <dons> ?where yaht
07:03:36 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
07:03:47 <dons> and then start consulting the ghc documentation, and hacking
07:03:50 <benja_> ...but that gives 404
07:04:01 <dons> oh, it might have changed. hang on...
07:04:02 <benja_> http://www.ceng.metu.edu.tr/courseweb/ceng242/documents/haskell/yetanothertutorial.pdf is a copy
07:04:03 <semi> well i can find it, no prob
07:04:07 <semi> thanks
07:04:36 <benja_> http://www.cs.utah.edu/~hal/htut/
07:04:37 <dons> ?where+ yaht http://pub.hal3.name/daume02yaht.pdf
07:04:37 <lambdabot> Done.
07:04:38 <lambdabot> Title: Yet Another Haskell Tutorial
07:04:40 <benja_> is the new official address
07:05:02 <benja_> dons: ok, perhaps that's even more official :)
07:05:03 <dons> ok, that'll do
07:05:07 <dons> ?where+ yaht http://www.cs.utah.edu/~hal/htut/
07:05:08 <lambdabot> Done.
07:05:25 <dcoutts> dons, want to quickly review some non-blocking IO code?
07:05:29 <dons> sure
07:05:34 <dons> -->
07:06:57 <shapr> @users
07:06:59 <lambdabot> Maximum users seen in #haskell: 235, currently: 209
07:07:09 <shapr> Whoa, spiffy
07:07:15 <shapr> spiffy: Are you learning Haskell?
07:09:33 <bringert> shapr: I'm off until late next week, no hope hacking for a while. Have fun!
07:09:48 <spiffy> shapr: I am
07:10:18 <dons> shapr: its been ages since you've done a tour. perhaps there's people who'd like to see that?
07:10:40 <spiffy> Tried before, failed miserably. Learned Common Lisp, liked it, but wished it had types. Learned a little bit of OCaml, didnt quiet agree with. Liking haskell this time.
07:11:30 <dons> why did things go bad the first time, do you think?
07:12:29 <shapr> bringert: Have fun wherever you're going
07:12:37 <semi> spiffy: what did you not agree on about ocaml?
07:12:57 <shapr> spiffy: Got any questions?
07:13:16 <dons> we should do a census one day to work out how many ocaml refugees are living here
07:13:20 <spiffy> haha wow, friendly room :-)
07:13:24 <shapr> dons: I'm about to have a phone interview, don't have time for a tour.
07:13:31 <dons> ok :)
07:13:33 <semi> i thought that common lisp has types where you want them?
07:14:07 <shapr> Plus I'm investigating sending raw 802.11 frames from my Nokia 770.
07:14:11 <semi> what are the things that make people switch to haskell from ocaml?
07:14:15 <spiffy> semi: well, not where I wanted them. You can dispatch on types for function call
07:14:19 <shapr> semi: Typeclasses
07:14:30 <norpan> lazy evaluation?
07:14:57 <mauke> function declarations!
07:15:14 <spiffy> basically declaring a return type, very nice.
07:15:37 <spiffy> im not sure why I didnt like OCaml. But I do like haskell so far.
07:16:05 <SamB> well, I think I've heard of "Lisp types", but I think it was supposed to be people ;-)
07:16:12 <dons> heh
07:17:08 <spiffy> I think i tried to learn haskell too early in my programing career. I mean a 4 line quicksort is great, if you know what quicksort is ;-)
07:17:20 <shapr> heh
07:17:33 <dons> that's interesting. I think there are indeed two sides to the haskell story.
07:17:36 <mauke> do you know fibonacci numbers? :-)
07:17:37 <dons> its often taught to beginners
07:17:43 <dons> who get it, but see only one part.
07:17:53 <dons> then there's all the good programmers, who come to haskell later
07:17:57 <dylan> woah... anyone here heard of ServerPronto?
07:18:10 <dons> and see a different side, labouring under java and c++, haskell must be a bit of a revelation
07:18:21 <dylan> it's a dedicated server good enough to do haskell dev work on, for $30 USD / month.
07:18:38 <dons> "good enough"?
07:18:55 <dons> what do they provide?
07:18:56 <shapr> It's $15 a month for a virtual server at tektonic.
07:18:59 <dylan> AMD 2000 / 256MB memory / 40 GB disk
07:19:05 <semi> well I like ocaml but I can't say I know all of the language yet
07:19:18 <spiffy> well, id agree with that. Functional languages in general tend to open some eyes. Has the newest post by joelonsoftware preaching the virtues of functional languages made its way here yet?
07:19:24 <dylan> I like ocaml. I do not like ocaml's community
07:19:35 <dons> spiffy: yeah, we saw and pondered
07:19:38 <semi> what's wrong with their community?
07:19:38 <SamB> spiffy: actually I think the quicksort is silly...
07:19:39 <xerox> dcoutts: what was the reason why we didn't want to put all the packages in just one packages/ local repository?
07:19:39 <dons> the land of verbs and so on
07:19:40 <boegel> spiffy: yep, it was posted on the mailinglist
07:19:47 <dylan> shapr: tektonic any better than unixhsell?
07:19:49 <sieni> dylan: there's always standard ml ;-)
07:19:50 <shapr> I like programming languages, and Haskell is a good programming language. It is not the only programming language that is good.
07:19:57 <shapr> dylan: I think they're related somehow.
07:20:00 <dylan> sieni: I don't like the syntax.
07:20:18 <dcoutts> xerox, because then we get random overlaps between repos
07:20:34 <spiffy> I really like haskell's syntax this time. Whats the reconmended editor tho?
07:20:45 <dons> vim? emacs? pico?
07:20:48 <xerox> dcoutts: ok, much code needs to change, groan
07:20:49 <dcoutts> xerox, imaging if two repos have foo.cabal
07:20:50 <dons> anything goes
07:20:51 <SamB> what is pico?
07:20:58 <boegel> something like joe ;)
07:21:00 <dons> like nano, but smaller
07:21:03 <SamB> oh
07:21:06 <dcoutts> xerox, if you want to keep it simple (and you should)
07:21:08 <xerox> dcoutts: yup I understand, maybe it is not a problem now, but it could be in principle
07:21:12 <dcoutts> xerox, only use one repo for the moment
07:21:24 <xerox> That makes things very much simpler yes
07:21:24 <dcoutts> xerox, it can be improved later
07:21:41 <spiffy> excellent. Common lisp tends to force emacs on the user ;-)
07:21:56 <dcoutts> xerox, for immediate demoing purposes it's fine.
07:21:57 <SamB> spiffy: yeah
07:21:59 * xerox unreverts
07:21:59 <dylan> I run emacs for the games.
07:22:06 <SamB> either you use Emacs or you use a stupid clone
07:22:10 <SamB> dylan: heh
07:22:11 <dylan> but vim for text editing. :)
07:22:13 <dons> ?remember dylan I run emacs for the games
07:22:13 <lambdabot> Done.
07:22:15 <SamB> they are fun though ;-)
07:22:30 <dcoutts> xerox, when working to a deadline, chuck out non-essential features
07:22:32 <dcoutts> :-)
07:22:34 <SamB> I especially like the multiplication puzzles
07:22:38 <sieni> dylan: yeah, the syntaxes are almost like, identical.
07:22:40 <xerox> dcoutts: aye.
07:22:44 <dcoutts> @arr
07:22:44 <lambdabot> I'll crush ye barnacles!
07:22:47 <dcoutts> oops
07:22:53 <dons> hehe
07:23:06 <dylan> I like vim's code foldind, status bar (a customization of mine), and now inteligent completion.
07:23:07 * dcoutts has pirate turetts
07:23:08 * xerox re-starts from scratch
07:23:21 <mauke> @keal
07:23:22 <lambdabot> nsa has all the profiling info you need to come up with the correct survey answers
07:23:29 <kolmodin> @yarr!
07:23:29 <lambdabot> I want me grog!
07:23:37 <dylan> sieni: SML and O'Caml are quite different with regards to let statements, and there's the eqtype vs. type stuff
07:23:50 <SamB> @quote
07:23:50 <lambdabot> xerox says: > take 10 lol where lol = "ol" : zipWith (:) (intersperse 'o' $ cycle "l") lol
07:24:06 <dcoutts> > take 10 lol where lol = "ol" : zipWith (:) (intersperse 'o' $ cycle "l") lol
07:24:07 <lambdabot>  Parse error
07:24:11 <dcoutts> hah ha
07:24:13 <xerox> o_o
07:24:14 <dylan> of course, I think it's a matter of splash screens
07:24:21 <tibbe> on the topic of emacs, has anyone fixed the indentation of if/then/else in do notation for the Emacs mode?
07:24:32 <dylan> when I first started using linux, I typed 'emacs'
07:24:35 <SamB> thats a roundabout way to write "olololololololololololololololololololol..."
07:24:38 <xerox> no!
07:24:44 <dylan> and then proceeded for about 30 minutes to an hour to close it
07:24:51 <SamB> dylan: hahaha!
07:24:58 <dylan> it was somewhat scary
07:25:19 <dylan> I eventually did alt-f2 and used kill -9
07:25:20 <xerox> > let lol = "lol" : zipWith (:) (intersperse 'o' $ cycle "l") lol in lol
07:25:21 <lambdabot>  ["lol","llol","ollol","lollol","olollol","lolollol","ololollol","lololollol"...
07:25:23 <tibbe> I had a similar experience with vi, I pulled the plug
07:25:29 <emertens> Cale: you there?
07:25:30 <xerox> Ah that's why it started with "ol".
07:25:38 <dylan> Now vim very clearly told me how to exit it
07:25:52 <SamB> dylan: I was fortunate enough to start it under X for the first time ;-)
07:25:53 <emertens> > sequence [(<10),(>5)] 7
07:25:54 <lambdabot>  [True,True]
07:25:55 <dylan> which was nice. it also told me to run vimtutor. So it's just that I learned it first
07:26:23 <dylan> I only use X for running a full screen rxvt, and for firefox
07:26:34 <SamB> dylan: heh
07:26:48 <SamB> well, it makes it easier to figure out how to close Emacs, that is for sure!
07:27:01 <dylan> SamB: But it's not that I hate emacs. I just learned vim and it's so customized now I don't want to switch.
07:27:15 <norpan> i'm indifferent to emacs too
07:27:19 <SamB> dylan: I don't hate vim either
07:27:33 <SamB> I just can't remember how to use it
07:27:39 <dylan> Heh.
07:27:45 <emertens> emacs... isn't that some kind of line-editor?
07:27:51 <dylan> I can't use textareas on forms very well at all
07:27:51 <SamB> emertens: hmm?
07:27:58 <norpan> no, emacs stands for esc-meta-alt-ctrl-shift
07:28:19 * dylan uses control somewhat often in vim. control-w, etc
07:28:30 * emertens rarely uses control in vim
07:28:38 <dons> C-n, C-p, too
07:28:40 <dylan> what's really annoying is when I use windows, and capslock != control. :(
07:28:53 <semi> you can do custom keymaps on windows too
07:28:54 <emertens> dylan: my windows capslock is control
07:28:56 <xerox> (dons you see, that quote states clearly that where worked ages ago.)
07:29:04 <shapr> @quote
07:29:04 <lambdabot> Itkovian says: real programmers don't write docs, if it was hard to write, it should be hard to understand
07:29:11 <dylan> emertens: how do you change that?
07:29:26 <emertens> it's a registry setting
07:29:33 <SamB> some have claimed that it would be nice to have a user's favorite editor embedded for text fields in apps...
07:29:37 <semi> there's even a tool for keymap customization in windows
07:29:42 <semi> can't remember the name of the tool tho
07:29:44 <dons> SamB: I have that.
07:29:47 <dons> since I use w3m
07:29:50 <SamB> dons: it works?
07:29:50 <emertens> MKLM\SYSTEM|CurrentControlSet\Control\Keyboard Layout\Scancode Map
07:29:56 <dons> it really makes editing the wikis easy
07:30:00 <SamB> oh, in w3m only?
07:30:06 <dons> yeah, not firefox
07:30:10 <dons> but I rarely use firefox
07:30:18 <dylan> I use w3m for osme things.
07:30:23 <emertens> I have switched capslock to left control, and left control to capslock
07:30:26 <SamB> I have a difficult time seeing how that would work with single-line text fields
07:30:27 <shapr> MILK\SYSTEM
07:30:37 <dimosd> I have a newbie question about ShowS
07:30:40 <dons> oh, single lines no. w3m doesn't invoke vim for that
07:30:41 <norpan> who uses caps lock anyway
07:30:49 <norpan> lawyers, probably
07:30:53 <dylan> not me.
07:30:56 <emertens> norpan: the idiots that send me emails in caps use it
07:30:58 <dimosd> How do you actually print it?
07:30:59 <boegel> maybe the caps lock people should take this to #haskell-blah?
07:31:06 <dylan> I really which <esc> was next to ~
07:31:11 <boegel> @type show
07:31:12 <lambdabot> forall a. (Show a) => a -> String
07:31:13 <emertens> @karma boegel
07:31:13 <lambdabot> boegel has a karma of 2
07:31:22 <boegel> dimosd: use show
07:31:29 <boegel> I think
07:31:33 <boegel> dimosd: use showS
07:31:34 <SamB> dons: see, the trouble is you'd have no room for status lines
07:31:35 <boegel> @type showS
07:31:37 <lambdabot> Not in scope: `showS'
07:31:40 <boegel> oh, wait
07:31:42 <int-e> @type shows
07:31:43 <lambdabot> forall a. (Show a) => a -> ShowS
07:31:44 <boegel> damn :)
07:31:45 <SamB> I think emacs needs two of them...
07:31:49 <norpan> if something is of type ShowS, just apply "" to it
07:31:52 <dons> SamB: w3m pops up a status/command line on the bottom line, for 1 line fields
07:32:04 <dimosd> shows gives me a ShowS from a string
07:32:05 <int-e> ShowS is just an alias for Stringt -> String.
07:32:07 <boegel> dimosd: yeah, what norpan said
07:32:18 <boegel> > (show 9) ""
07:32:19 <lambdabot>    The function `(show 9)' is applied to one arguments,
07:32:19 <lambdabot>   but its type `S...
07:32:30 <norpan> > (shows 9) ""
07:32:31 <lambdabot>  "9"
07:32:34 <SamB> Obviously the X world is in no shape for this to really work...
07:32:36 <boegel> > (shows 9) ""
07:32:37 <xerox> Parens are not neede
07:32:37 <lambdabot>  "9"
07:32:41 <norpan> but maybe your question were about something else?
07:32:45 <boegel> yeah, that's it :)
07:32:47 <norpan> was
07:32:56 <int-e> > (showString "abc" . showChar ' ' . shows 42 . showChar ' ' . shows "abc") ""
07:32:57 <lambdabot>  "abc 42 \"abc\""
07:33:36 <dimosd> thanks a lot norpan
07:33:38 <dimosd> it worked
07:33:56 <dimosd> I have to get this currying thing in my mind
07:34:17 <norpan> but normally you'd never deal with ShowS
07:34:19 <emertens> I need to get it out of mine, it messes me up in C# every once and a while :)
07:34:20 <shapr> @users
07:34:21 <lambdabot> Maximum users seen in #haskell: 235, currently: 206
07:34:33 <dylan> dimosd: do you know one of perl/python/ruby/javascript/lua?
07:34:35 <dimosd> actually, I just wanted to print a hex number with showHex (using ghc)
07:34:42 <norpan> ah, I see
07:34:49 <dimosd> showHex Int -> ShowS or something
07:34:52 <norpan> yes, that returns ShowS, I remember now
07:34:53 <dimosd> Is there a better way?
07:35:01 <int-e> > showHex 42 ""
07:35:02 <lambdabot>  "2a"
07:35:34 <dimosd> right int-e
07:35:42 * tibbe wants a parser that uses FPS but doesn't know how to write one
07:36:23 <SamB> hmm, is it normal to get a mild headache when switching to a lower dose of Adderall?
07:36:23 <emertens> sounds like a show stopper
07:36:36 <dimosd> thanks a lot, see you soon with more newbie questions :-)
07:37:21 <dons> tibbe: stepcut has one, I think. linspire uses it
07:37:22 <norpan> no time for my comment on expert answers :(
07:37:24 <dons> not sure if its free
07:37:34 <dons> otherwise, we do want one. its an faq, these days
07:37:49 <tibbe> ok
07:37:58 <dons> > printf "%x" 1023 :: String
07:37:59 <lambdabot>  Add a type signature
07:38:06 <dons> > printf "%x" (1023::Int) :: String
07:38:07 <lambdabot>  "3ff"
07:38:13 <xerox> @Yarr
07:38:14 <lambdabot> Maybe you meant: arr yarr
07:38:17 <tibbe> I have a quite limited application for it, correct parsing of RFC 2616, a regex would perhaps do
07:38:22 <xerox> Who added yarr!
07:38:25 <emertens> you were corrected on how to sound like a pirate!
07:38:32 <dons> tibbe: well, maybe just a hand coded version is ok
07:38:36 <dons> not even needing regexes
07:38:36 * tibbe isn't sure if HTTP messages are a regular language
07:38:44 <dons> just normal take/drop stuff
07:38:53 <norpan> > printf "%x" (1023::Double) :: String
07:38:54 <lambdabot>  Exception: Printf.printf: bad argument
07:38:57 <tibbe> I'm staring at a blank page right now
07:39:02 <tibbe> trying to write one
07:39:30 <tibbe> hmm
07:39:33 <dons> > printf "%d" (1023::Double) :: String
07:39:35 <lambdabot>  Exception: Printf.printf: bad argument
07:39:39 <tibbe> perhaps use takeWhile notSpace
07:39:41 <xerox> e/f
07:39:42 <dons> > printf "%f" (1023::Double) :: String
07:39:43 <lambdabot>  "1023.0"
07:39:47 <xerox> Yarr.
07:40:06 <dons> tibbe: right. that's how I'd start. actually, musasabi probably has a header parser already
07:40:11 <dons> in happs
07:40:15 <mauke> > printf "%03d" (42::Int) :: String
07:40:16 <lambdabot>  "042"
07:40:17 <tibbe> I looked at it
07:40:36 <tibbe> it's basically (method, uri, ver) = unwords line
07:40:38 <mauke> > printf "%.*s" (2::Int) "foo" :: String
07:40:39 <lambdabot>  Exception: Printf.printf: bad formatting char *
07:40:48 <tibbe> dons, not very "correct"
07:41:48 * dons `seq` sleep
07:42:01 <musasabi> tibbe: it is correct enough for real world. Can you show me something that really parses according to the RFC?
07:43:22 <musasabi> tibbe: for the header line unwords is actually very near.
07:43:33 <nomeata> ndm: good morning. just send you another small pile of small patches
07:43:52 <ndm> nomeata: just got them, will give them a whirl
07:44:06 <musasabi> tibbe: for the normal headers I think HAppS is more close to the RFC than many other implementations, of course there are things that are not supported like in any implementation.
07:44:14 <tibbe> musasabi, actually I'm trying to follow the route of Mongrel and be strict in the HTTP parsing to catch potential security problems that arise precisely because correct parsing is not performed
07:44:36 <SamB> tibbe: that reminds me of the one I wrote in MOO ;-)
07:45:03 <tibbe> > span (not . isSpace) "GET / HTTP/1.1\r\n\r\n"
07:45:04 <lambdabot>  ("GET"," / HTTP/1.1\r\n\r\n")
07:45:12 <SamB> though unwords doesn't return a triple
07:45:25 <tibbe> well, it was []
07:46:29 <musasabi> tibbe: so you are going to support comments etc inside the headers and remember which header-fields you are allowed to combine in different HTTP versions etc?
07:46:34 <tibbe> anyway, I'd like to try doing parsing according to the RFC and then relax the strictness if neccesary
07:47:00 <mux> is there some standard function similar to popen() ?
07:47:01 <SamB> you said "(method, uri, ver) = unwords line"
07:47:14 <musasabi> 'the problem is that the RFC is very very lax
07:47:20 <tibbe> musasabi, well, we'll see, I'm probably only going to check the syntax first and then let others care about the semantics
07:47:24 <xerox> mux: lambdabot has an Haskell popen
07:47:29 <tibbe> SamB, yes, I know, but that
07:47:36 <xerox> ?docs System.Process
07:47:36 <tibbe> that's not what I meant ;)
07:47:36 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
07:47:38 <mux> xerox: ah, thanks, no standard thing then?
07:47:40 <xerox> There too
07:47:46 <SamB> tibbe: hehe
07:47:59 <mux> oooh
07:48:05 <mux> runProcess nice
07:48:06 <mux> thankies!
07:48:10 <musasabi> tibbe: note how they define headers. And see RFC822 for the horrors.
07:48:34 <tibbe> I know that it's horrible :D
07:48:37 <ndm> nomeata: there is getCtrl and also getTextView etc, so you can remove the explicit types
07:48:45 <tibbe> I've been staring at it for a couple of days now
07:48:46 <musasabi> tibbe: then note that combining+whitespace are related to the type of field in question and those are dependant on the HTTP version.
07:49:08 <musasabi> and in the end you will probably want something faster ;)
07:49:20 <xerox> ?type readIO
07:49:21 <lambdabot> forall a. (Read a) => String -> IO a
07:49:51 <tibbe> as I said, I'll probably compromise somewhere but probably somewhere closer to the RFC than HApps
07:50:24 <tibbe> for example I could try to get the request line right to start with
07:50:38 <tibbe> and leave the headers for, ehm, someone else ;)
07:51:16 <nomeata> ndm: but then one can't use the "let f.." shortcut
07:51:39 <musasabi> I don't remember all of the stuff, but can you think of a valid request line that is misparsed by the unwords?
07:51:40 <ndm> nomeata: yeah, its a trade off...
07:51:52 <ndm> you can put the (f "sb") :: StatusBar on one line
07:51:55 <ndm> which reduces it a bit
07:52:10 <SamB> tibbe: does anyone do the request line in a way that would not work with unwords?
07:52:10 <tibbe> musasabi, no but probably an invalid one that is
07:52:13 <musasabi> (and HAppS takes patches as long as you won't make it 10x slower ;)
07:52:27 <nomeata> ndm: can't we solve the problem in another way, so that this works no matter what kind of widget is behind it?
07:52:45 <SamB> or words, even...
07:53:02 <tibbe> SamB, I'm not after parsing correct requests, that's easy, I'm after the mallicious ones
07:53:03 <SamB> it occurs to me that unwords is the one which puts words together...
07:53:14 <musasabi> s/un//
07:53:17 <tibbe> :)
07:53:23 <ndm> nomeata: i don't think so, since not all widgets give all properties
07:53:32 <ndm> and certainly underneath they are very different at the Gtk level
07:53:55 <nomeata> ndm: probably true
07:54:04 <musasabi> for GET/HEAD/POST/PUT the words should be okay I think.
07:54:32 <musasabi> for OPTIONS etc a stricter parser could catch errors/extensions
07:55:42 <musasabi> For headers one can do lots of stricter parsing.
07:56:00 * xerox gets another tea
07:56:12 <musasabi> The question is just "what is the best compromise between broken RFC and real world"
07:56:13 <SamB> what in the world is OPTIONS?
07:56:17 <xerox> dcoutts: It's going very well I think... yippie!
07:56:29 <tibbe> agreed
07:56:46 <dcoutts> xerox, yeah? cool
07:56:49 <dcoutts> xerox, tell us more
07:56:54 <musasabi> SamB: parts of HTTP spec not really used.
07:57:05 <xerox> dcoutts: let me hack it, I think I can make something usable
07:57:08 <tibbe> but I would like to catch as many bad requests early so I don't risk them slipping through so I have to deal with them later
07:57:14 <dcoutts> xerox, excalent
07:57:50 <musasabi> tibbe: bad in which sense? It is only bad if the raw headers are available in many places where they can be parsed in different fashions.
07:57:51 <dcoutts> xerox, the other shortcut of course is doing no checks on the packages when they're put into the repo
07:58:54 <SamB> tibbe: yeah, don't most Haskell HTTP libraries parse all that stuff for you?
07:58:57 <tibbe> musasabi, bad as in malicious, attempts to DoS the server, etc
07:59:11 <SamB> if they check it at all?
07:59:37 <SamB> seems silly to parse it once only to make the program parse it again
07:59:38 <tibbe> I've only looked at Network.HTTP at haskell.org/http/
07:59:40 <musasabi> tibbe: for DoS it is better to parse it quickly rather than in a slow and correct way
07:59:48 <SamB> what if they get their parser wrong?
08:00:18 <musasabi> SamB: none of the Haskell HTTP parsers follow the RFC. I don't think apache does either.
08:00:19 <tibbe> musasabi, ah but long requests are not the only way to DoS, incorrect ones can hang the implementation as well
08:00:39 <tibbe> the Haskell HTTP parser I
08:00:42 <musasabi> tibbe: so we should make sure the parser parses requests in a fast and safe manner.
08:00:50 <tibbe> I've seen does too much for me, can't reuse them
08:00:52 <musasabi> which is what I tried to do with HAppS
08:01:33 <musasabi> Trying to comb the headers in a more strict fashion seemed to open holes for easier DoS.
08:01:44 <tibbe> yes, and what's I'm saying is that I want a compromise for my application that leans a bit more towards safe in the sense that I have some additional guarantees about the content of the request
08:02:42 <musasabi> tibbe: anything in special that the HAppS parser is lacking (might patch it if it is missing something important)
08:02:58 <mux> http://www.fh-wedel.de/~si/HXmlToolbox/hdoc/System-PipeOpen.html
08:03:21 <tibbe> musasabi, I'm sure the HAppS parser is fine for what it does, it just doesn't do what I want
08:03:45 <tibbe> (which is, writing a server in the style of Mongrel/Simple)
08:04:29 <tibbe> I guess I'm taking the Mongrel guys word for that there parser has helped their security though, probably should get some statistics for the different kind of HTTP attacks
08:05:02 <tibbe> I think the problem they
08:05:21 * tibbe arghs, his return key it to close to his ' key on his french keyboard
08:06:03 <musasabi> The canonical HTTP attack that parsing helps is with HTTP in language A that passes the headers for implementation in language B which reparses them and interprets them in a different fashion.
08:06:19 <tibbe> Once the headers are parsed (the URI into a string for example) they tend to go into different functions which might/might not be able to handle certain inputs
08:07:00 <mux> tibbe: you have a weird french keyboard!
08:07:23 <musasabi> tibbe: of course if ADTs are used the problem goes away since there is only one parsing stage.
08:07:35 <tibbe> mux, I usually use a Swedish one but I'm doing an internship where I use a French one
08:07:49 <mux> well I'm french and I have a french keyboard
08:08:01 <tibbe> musasabi, I'm not sure I understand exactly what you mean, I'm quite new to haskell
08:08:01 <mux> and my ' key is far away from the return one :-)
08:08:23 <tibbe> mux, well, then I guess I have a none standard french keyboard
08:08:35 <dcoutts> musasabi, and parsing using fps should make it less suceptable to DoSing, as you're not doing so much work up front
08:08:38 <tibbe> mux, or perhaps it's not even french, but then I don't know what it is :)
08:08:44 <SamB> tibbe: are you sure it isn't an american keyboard?
08:09:02 <musasabi> dcoutts: true. But some of the fancier features involved backtracking which I wanted to avoid.
08:09:07 <dcoutts> right
08:09:09 <tibbe> SamB, probably is,  I wouldn't know
08:09:10 * mux kicks HXT
08:09:54 <xerox> dcoutts: right, I was also going to ask you for your AR code, but I'll use gnu tar for the moment
08:10:04 <musasabi> tibbe: I mean that if we return URI instead of String then we already know it is an URI and everyone treats it the same - rather than parsing it in ten different ways.
08:10:04 <tibbe> musasabi, of course I'll add some maximum size limits to, and I will silently drop clients who send faulty requests so I don't waste too much resources on them
08:10:07 <xerox> dcoutts: maybe it has some clever options I can use. /me investigates
08:10:16 <mux> anyone knows how I'm supposed to use the xread arrow to parse from a string ?
08:10:35 <musasabi> tibbe: also note that some legal clients will send broken stuff.
08:10:51 <tibbe> musasabi, I will use the standard URI data type for representation of URIs, then there's "*" and perhaps something more
08:11:19 <dcoutts> xerox, you don't need to parse the .tar files yourself, just call gnu tar to unpack them
08:11:20 <tibbe> musasabi, yes, as I said I'll have to relax some requirements once I see which clients sends what
08:11:39 <dcoutts> xerox, but later when we make it work on windows, sure I can help with tar-parsing code.
08:11:45 <mux> freaking hxt
08:11:53 <xerox> dcoutts: yup, I am checking wethere I must recurse the subdirectories, or I can have tar spit out some clever format I can more easily parse instead
08:12:00 <tibbe> musasabi, well, I wouldn't say they are legal, popular yes, I won't support everyones abscure and broken client though
08:12:22 <musasabi> true
08:12:26 <dcoutts> xerox, do you want the code I have for recursing subdirts and returning a lazy tree?
08:12:46 * tibbe leaves work in 18 minutes so he gets to write some haskell instead of just talking about it
08:12:51 <xerox> dcoutts: right, that would help, I think the recursing subdir part is really error-prone
08:12:58 <xerox> Sorry I am afwfully lagged
08:13:02 <dcoutts> :-)
08:13:07 <dcoutts> it's not that hard :-)
08:13:18 <tibbe> musasabi, I'll try to write something when I'll get home and then benchmark it and see if it's worth it
08:13:37 * xerox is fearful of IO
08:13:40 <dcoutts> http://129.67.91.110:8080/~duncan/gtk2hs/demo/customTreeList/BitDepthTest.hs
08:13:41 <musasabi> patches are welcome
08:13:52 <tibbe> musasabi, well, uhm, I guess it'll have to wait until tonight
08:14:10 <dcoutts> xerox, use lazyDirTree but change it to return the full file path names
08:14:10 <tibbe> musasabi, if I do something actually useful I will send it
08:14:11 <xerox> dcoutts: I remember it now, nice. Thanks.
08:14:22 <musasabi> no problem, I am quite busy this week with non-haskell stuff
08:14:29 <tibbe> musasabi, right now I have a particular application in mind I would like to try it on
08:14:46 <dcoutts> xerox, ie it's probably just rootLabel = filePath,
08:14:54 <musasabi> good luck
08:15:08 <xerox> dcoutts: do you think I should use {get,set}CurrentDir in the innermost part of the loop or in the outermost? I can't understand how the current code gets the paths right
08:15:33 <dcoutts> xerox, why do you need {get,set}CurrentDir at all?
08:15:36 <xerox> dcoutts: I might as well just return a list, I don't think I need a tree
08:15:55 <xerox> dcoutts: getFrom url "00-latest.tar.gz" -- where does the file get downloaded to?
08:15:56 <dcoutts> xerox, then use Data.Tree.flatten
08:16:15 <dcoutts> xerox, to wherever the current 00-latest.txt gets downloaded to
08:16:26 <dcoutts> no need to change that
08:16:45 <musasabi> setCurrentDir => non-threadsafe code
08:16:50 <xerox> I am not sure, I will rely on that, but it's strange.
08:16:55 <xerox> Okay.
08:17:09 <dcoutts> what's strange? :-)
08:17:37 <dcoutts> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Tree.html#v%3Aflatten
08:17:45 <xerox> Let's stop talking about it, I'll try to figure out :)
08:17:51 <dcoutts> hah ok
08:23:23 <DukeDave> hey gang, I have a math/list question - thought I'd try it out in here since you're a mart bunch ;)
08:23:42 <norpan> shoot baby
08:24:14 * DukeDave is trying to verse the question in a sane way :)
08:25:02 <emertens> DukeDave... are you in the KKK?
08:25:38 <DukeDave> well, my friend posed the question - given a list of train stations, and the trip time between each station.. is it possible to assert the order in which the stations lie?
08:25:41 <DukeDave> emertens, not again ;)
08:25:59 <DukeDave> I've developed a way to do it
08:26:35 <norpan> DukeDave: that would be easy
08:26:45 <emertens> longest distance tells you the endpoints
08:26:53 <emertens> distances to end points tell you the rest
08:26:59 <DukeDave> but I don't know how to define the relationship between two stations in conversation. Specifically because it's a non-directional relationship
08:27:24 <DukeDave> right
08:27:49 <DukeDave> but when sorting it there's not > or <
08:29:02 <DukeDave> so I'm just wondering about the natural ordering of the element
08:29:05 <DukeDave> *s
08:29:15 <DukeDave> they have one, but not in the normal sense
08:29:58 <norpan> exactly how does your list look
08:30:54 <norpan> or rather, how does an element look
08:31:07 <DukeDave> well, at the moment I just use ints
08:31:16 <norpan> just an int?
08:31:21 <norpan> and what is that int?
08:31:40 <DukeDave> and to get the 'distance' between them take (\x y -> abs x - y)
08:31:59 <norpan> so just sort the list by that int and then you're done
08:32:03 <DukeDave> so the distance between station 2 and station 5 is 3
08:32:16 <emertens> um, if the stations are numbered
08:32:18 <DukeDave> and dist between 7 and 2 is 5
08:32:25 <emertens> just return a sorted list
08:32:28 <DukeDave> but that is just for convenience
08:32:37 <emertens> [0..7] is the list of the 8 stations
08:33:00 <DukeDave> yes
08:34:02 <DukeDave> worded another way..
08:34:28 <DukeDave> Ord requires that the instance provide > and < correct?
08:34:41 <norpan> well, it only needs one of them
08:34:44 <norpan> and ==
08:34:52 <xerox> abs $ x - y
08:34:54 <mux> it's compare
08:35:06 <xerox> (abs .) . (-) -- :)
08:36:13 <DukeDave> but I wish to create a class which requires only that any instance provides a function to give the absolute dist between two of its type
08:36:29 <DukeDave> is there a 'mathmatical' term for that?
08:36:33 <norpan> the only one you need provide actually, is <= or compare
08:37:03 <DukeDave> but in this problem we are not able to assert GT or LT
08:37:31 <DukeDave> need a new symbol like   a <=> b or something  :)
08:37:33 <emertens> then it's not an Ord
08:37:44 <DukeDave> yes but what is it?
08:37:57 <emertens> it sounds like you are trying to overcomplicate it
08:38:01 <norpan> nothing i've ever heard a name for
08:38:39 <ndm> DukeDave: do you really need to use this operator on many types?
08:38:54 <ndm> if all you're going to ever use is Int, there is no point is making it extendable
08:39:08 <DukeDave> it's just a curiosity - I wondered if there was a name for the problem I've been working on
08:39:23 <DukeDave> lol, I'm only using Int's for simplicity
08:39:39 <mux> gha
08:39:41 <ValarQ> DukeDave: (<=>) = const (const True)
08:39:44 * mux kicks HXT hard
08:39:51 <mux> this parser does what I want when I parse form a file
08:39:52 <ndm> mux: HXT?
08:39:54 <ValarQ> DukeDave: is that an acceptable implementation? :)
08:40:05 <mux> but when I parse from a string with xread it's not working anymore
08:40:10 <mux> ndm: haskell xml toolkit
08:40:14 <xerox> (_ <=> _) = True
08:41:31 <DukeDave> well - in reality it shall return a positive int indicating the 'distance' between the two comparitorees :)
08:41:57 <emertens> then you aren't comparing
08:43:59 <ValarQ> isn't that just: abs . (-)
08:44:15 <emertens> ValarQ: that doesn't do what you think it does
08:44:47 <DukeDave> > (abs. (-)) 2 5
08:44:52 <lambdabot>  add an instance declaration for (Num (a -> a))
08:45:05 <emertens> ((abs .) . (-)) 3 4
08:45:08 <emertens> > ((abs .) . (-)) 3 4
08:45:10 <lambdabot>  1
08:45:23 <DukeDave> heh, cracktastic :)
08:45:24 <ValarQ> oh, thats the effect i wanted
08:45:54 <emertens> or if you want to be "readable" (\a b -> abs (a - b))
08:45:55 <xerox> :)
08:45:57 <ValarQ> DukeDave: well, there you go
08:46:20 <DukeDave> right, so, forgetting that little discussion :)
08:46:46 <emertens> DukeDave: but abs (a - b) was what was suggeste to you at the very beginning...
08:46:54 <emertens> I thought that you even suggested it yourself
08:47:18 <DukeDave> does anyone know the name for a list, in which the elements can be compared to get an  (abolute) distance between then ?
08:47:43 <emertens> [Int]
08:48:00 <emertens> @type bas
08:48:01 <emertens> @type abs
08:48:02 <lambdabot> Not in scope: `bas'
08:48:03 <lambdabot> forall a. (Num a) => a -> a
08:48:13 <emertens> (Num a) => [a]
08:48:16 <emertens> that would be the type
08:48:20 <DukeDave> (I already figured the ((\a b -> abs (a - b)) test case :)
08:48:51 <DukeDave> and the 'mathematical' name?
08:48:57 <int-e> @pl \ a b -> max a b - min a b
08:48:57 <lambdabot> ap (ap . ((-) .) . max) min
08:49:15 <int-e> @pl \a -> max (-a) a
08:49:16 <lambdabot> max =<< subtract
08:49:38 <int-e> @pl \a -> max (negate a) a
08:49:38 <lambdabot> max =<< negate
08:50:03 <emertens> int-e: that is definitely clearer ;)
08:50:21 <int-e> emertens: that wasn't my intention.
08:53:40 <emertens> > foldl1 (-) $ sequence [uncurry max, uncurry min] (4,5)
08:53:41 <lambdabot>  1
08:54:46 <mnislaih> Lemmih: I've pushed some new patches to the SoC repo
08:57:09 <emertens> > (foldl1 (-) . curry (sequence [uncurry max, uncurry min])) 4 5
08:57:10 <lambdabot>    Expecting a function type, but found `b'
08:57:10 <lambdabot>    Expected type: a1 -> [a]
08:57:10 <lambdabot> ...
08:57:20 <emertens> > ((foldl1 (-) .) . curry (sequence [uncurry max, uncurry min])) 4 5
08:57:21 <lambdabot>  1
09:08:27 <emertens> It seems like a lot of the problems on mathschallenge.net can be solved in one random character string of J
09:08:45 <emertens> I wonder if it'd be faster to just try running all permutations of valid characters
09:08:49 <emertens> of length 12
09:08:56 <emertens> in J on the problem ;)
09:09:01 <emertens> than to solve it myself
09:13:48 <tibbe> > "hi" == "hi"
09:13:49 <lambdabot>  True
09:13:52 <tibbe> > "hi" == "bi"
09:13:53 <lambdabot>  False
09:20:57 <xerox> undefined is a bless.
09:21:20 <edwardk> heya
09:21:29 <DukeDave> hey, sorry guys
09:21:31 <xerox> Howdy edwardk!
09:22:01 * edwardk escapes from a boring web programming meeting and comes around to slack off.
09:22:57 <tibbe> @hoggle Data.ByteString./=
09:22:58 <lambdabot> Hoogle Error: Parse Error: Unexpected character '/='
09:28:02 <dcoutts> tibbe, hoogle doesn't include ByteString yet, but ByteString is indeed an instance of Eq and Ord
09:28:19 <emertens> anyone here ever programmed in J?
09:29:26 <Kahdloc> there is such a thing?
09:29:45 <reilly> Yes, it's a functional vector language
09:30:10 <mux> any instance of Ord is an instance of Eq anyways, right? like (==) a b == compare a b == EQ
09:30:16 <emertens> I've seen a lot of J code in the mathschallenge.net forum, and I want to understand it, so I'm reading up now :)
09:30:23 <mux> err
09:30:34 <mux> (==) a b = compare a b == EQ
09:30:40 <mux> @pl (==) a b = compare a b == EQ
09:30:40 <lambdabot> (line 1, column 10):
09:30:41 <lambdabot> unexpected "="
09:30:41 <lambdabot> expecting variable, "(", operator or end of input
09:31:04 <reilly> I did a very small amount of programming in K (which is related) several years ago
09:31:39 <mux> (== EQ) . compare
09:31:40 <mux> or something
09:31:46 <emertens> from the sample code I've seen of J, it looks like it might as well be brainfuck :)
09:32:02 <lispy> mux: it's like jeopardy. for @pl you have to phrase it like a function in lambda notation
09:32:10 <reilly> well, it's a descendent of APL
09:32:25 <reilly> very expressive, but write only
09:32:25 <emertens> how does K relate?
09:32:42 <reilly> commercial product
09:32:57 <lispy> @pl \a b -> (compare a b) == EQ
09:32:58 <lambdabot> flip flip EQ . ((==) .) . compare
09:33:14 <reilly> comes with Kdb, which is a column oriented database (design for time series analysis)
09:33:22 <reilly> designed
09:33:54 <xerox> lispy: what do you need that for?!
09:35:02 <emertens> ((==EQ).) . compare?
09:35:11 <emertens> > (((==EQ).) . compare) 1 2
09:35:12 <lambdabot>  False
09:35:32 <dcoutts> > (==) 1 2
09:35:33 <lambdabot>  False
09:35:34 <dcoutts> yay
09:35:59 <xerox> Eh. :)
09:36:28 <dcoutts> lispy, pl isn't so clever as to be able to turn \a b -> compare a b == EQ into (==)
09:36:30 <xerox> dcoutts: I just noticed I have to encode the url in the index file names, or differentiate them somehow anyway
09:36:39 <xerox> Not _yet_ :)
09:36:47 <dcoutts> yeah, we looked at that before
09:36:56 <dcoutts> you've got code for that already right?
09:37:07 <xerox> Right, do you think it's okay? Or maybe just an hash?
09:37:15 <dcoutts> but if you've only got one repo do you really need to?
09:37:16 <xerox> I can use that code we did in fact, right
09:37:27 <xerox> I do because I overwrite them if I download them all
09:37:44 <dcoutts> that's ok isn't it?
09:37:47 <reilly> there's a pretty big J community in new york city
09:37:54 <dcoutts> hah hah
09:38:04 <xerox> dcoutts: I don't know, is it?
09:38:22 <dcoutts> xerox, if it's the index from the same repo then downloading it and unpacking it should be ok
09:38:31 <dcoutts> it'll overwrite any existing files
09:38:33 * lispy wishes more psychologists would team up with software engineering and language theory people to design languages
09:38:45 <xerox> dcoutts: nope, index files of different repositories
09:39:04 <dcoutts> xerox, I thought you were starting with just one repo
09:39:05 <reilly> emertens: J and K are popular with some quantitative analysts on wall street
09:39:14 <xerox> dcoutts: one _local_ repo
09:39:20 <dcoutts> yes
09:39:25 <dcoutts> and one remote :-)
09:39:25 <tibbe> if I pattern match on a regular string like so: do { (x, _:ys) <- f } I can throw away the leading char using _, is it possible to do something similar using ByteString:s or do I have to do a two step "process" and use B.tail?
09:39:31 <xerox> dcoutts: no, many remote
09:39:31 <dcoutts> xerox, makes it much easier :-)
09:39:46 <xerox> Oh well
09:39:49 <dcoutts> xerox, well, if you insist
09:40:01 <xerox> It's just because the current code does it
09:40:09 <dcoutts> I think it'd not be too hard to change it later to use several
09:40:19 <dcoutts> and have several local mirror repos
09:41:01 <xerox> Anyway: is it okay to unpack the tarballs BUT don't have them afterwards?
09:41:19 <dcoutts> you mean unpack them and then delete the tarball?
09:41:23 <xerox> Right
09:41:23 <dcoutts> yes that'd be ok
09:41:34 <xerox> OK, good, even less complexity, no need to encode anything
09:41:34 <dcoutts> xerox, if the user puts more than one url in the server list then exit with an error and tell them to upgrade ;-)
09:41:52 <xerox> It'll be fine if there are no clashes
09:42:02 <dcoutts> yes
09:42:09 <musasabi> dcoutts: not ok. As different versions of tar+gzip will produce different archives with non-matching checksums, and thus they will not be signed.
09:42:19 <xerox> OK, let me try, I really want to have it NOW
09:42:31 <dcoutts> musasabi, we don't have signing yet
09:43:15 <dcoutts> musasabi, by the time we do we'll have multiple local repos, 1-1 mirrors with the remote ones
09:48:49 <xerox> dcoutts: do you still have pub.tar.gz ?  Or maybe I should make a new repository, any idea of what packages I could put in?  If they are inter-dependend is even better.
09:49:08 * xerox writes the last function
09:49:42 <dcoutts> http://hackage.haskell.org/darcs/cabal-server-install/pub.tar.gz
09:50:30 <dcoutts> xerox, that contains the whole lot
09:51:26 <xerox> Is there a ghc-way to avoid `Skipping ...' and having only the `Compiling ...' ?
09:51:53 <Lemmih> Upgrade to 6.6?
09:52:08 <reilly> does anybody have a favorite incarnation (build-date) of ghc-6.5?
09:52:36 <xerox> Lemmih: do you know if it works on osx-intel ?
09:52:44 <xerox> Well, if there are any builds, in fact :)
09:52:46 <reilly> 6.5 does
09:52:58 <xerox> (That's what I have)
09:53:01 <dcoutts> reilly, yes, ghc-6.5.20060724
09:53:18 <reilly> why that date?
09:53:18 <dcoutts> I tried to build from darcs today and it failed.
09:53:33 <dcoutts> that was before the package name destabilisation
09:53:42 <reilly> you should look at the cvs-ghc archive before trying a build
09:53:46 <dcoutts> and it's what I've been using for the ByteString fusion benchmarks.
09:54:06 <dcoutts> reilly, yeah, I know. I saw some nice patches go in and tried it on spec.
09:54:20 <dcoutts> emerge ghc-darcs is pretty easy to fire off
09:54:53 <xerox> Lemmih, dcoutts: do you know offhand if Cabal exports any handy function that takes a .cabal filepath and returns its Haskell representation? (in particular I need (Pkg ident deps pkgSynopsis))
09:55:16 <dcoutts> xerox, readFile >>= readIO ?
09:55:17 <reilly> i like what they're doing with the package name space ... or will when its done
09:55:32 <xerox> dcoutts: ah I see, it's Read/Show instances
09:55:44 <Lemmih> xerox: readPackageDescription?
09:55:55 <dcoutts> xerox, ah, yes it's that, not read/show
09:56:04 <dcoutts> and it gives the data structure
09:56:16 <xerox> Also, I should limit to one repository, I don't know how to get the urls right with more repositories, groan.
09:56:22 <xerox> Lemmih: thanks
09:59:07 <xerox> ?type printf
09:59:09 <lambdabot> forall r. (PrintfType r) => String -> r
09:59:18 <lispy> xerox: what do you need which for?
09:59:19 <xerox> So printf doesn't do any IO ?
10:00:12 <Lemmih> It can.
10:00:39 <xerox> ?index printf
10:00:39 <lambdabot> Text.Printf
10:00:44 <xerox> ?docs Text.Printf
10:00:45 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Printf.html
10:00:52 <emertens> sounds like the C "sprintf"
10:01:10 <Lemmih> It can be both.
10:01:14 <musasabi> it can be both sprintf and printf
10:01:16 <xerox> Oh I see
10:01:19 <musasabi> type class hackery
10:01:32 <xerox> Lemmih: do you know what type is used in fail $ printf ... code in cabal-install ?
10:02:03 <Lemmih> xerox: String.
10:02:29 <xerox> OK good!
10:07:38 <xerox> ?index getSymbolicLinkStatus
10:07:38 <lambdabot> System.Posix.Files, System.Posix
10:23:25 <xerox> ?hoogle suffix
10:23:26 <lambdabot> List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
10:23:26 <lambdabot> Distribution.PreProcess.knownSuffixHandlers :: [PPSuffixHandler]
10:23:26 <lambdabot> Distribution.PreProcess.ppSuffixes :: [PPSuffixHandler] -> [String]
10:26:29 <xerox> dcoutts: yuck, I don't have System.Posix.Files here :)
10:27:09 <xerox> (And more generally the posix package.)
10:28:01 <xerox> OK there seem to exist:
10:28:12 <xerox> ?type doesFileExist
10:28:13 <lambdabot> Not in scope: `doesFileExist'
10:28:21 <xerox> ?type System.Directory.doesFileExist
10:28:23 <lambdabot> FilePath -> IO Bool
10:28:26 <xerox> ?type System.Directory.doesDirectoryExist
10:28:27 <lambdabot> FilePath -> IO Bool
10:42:41 <dcoutts> xerox, yeah, that'll do I guess, though it's not atomic
10:42:56 <dcoutts> hmm, but then neither was the original I guess
10:46:24 <eivuokko> Mmmm.  Seems it would be quite easy to generate wix-xml and hence msi from cabal spec.
10:46:50 <xerox> Yuck, it compiles.
10:47:11 <eivuokko> Now, that sounds worrying.
10:47:44 <xerox> ?paste
10:47:45 <lambdabot> http://paste.lisp.org/new/haskell
10:48:16 <lisppaste2> xerox pasted "collecting cabal files" at http://paste.lisp.org/display/24246
10:48:27 <xerox> dcoutts: what do you think about that?
10:50:15 <dcoutts> xerox, Looks good. I'd not put the .cabal filter test in there. Make it reusable.
10:50:26 <xerox> So flatten and filter
10:50:30 <xerox> Makes sense indeed
10:50:30 <dcoutts> yes
10:50:55 <xerox> It also don't pollute the Tree of "" Nodes
10:51:03 * xerox can't type
10:51:09 <dcoutts> right
10:51:23 <dcoutts> fmap (filter isDotCabalFile . flatten) (lazyDirTree path)
10:51:29 <dcoutts> or something like that :-)
10:51:33 <xerox> That's the easy part yes :D
10:51:41 * dcoutts grins
10:52:37 <xerox> So I need a test repository now!
10:52:58 <dcoutts> got an http server?
10:53:06 <xerox> Yes
10:53:13 <dcoutts> bonus
10:53:17 <xerox> Also, do you have that command line options?
10:53:22 <xerox> (for tar, to generate the index)
10:53:26 <dcoutts> yes
10:53:29 <dcoutts> let me recall
10:53:33 <xerox> Thanks much
10:57:54 <dcoutts> xerox, from the pub dir containing unstable: tar --create --gzip --file 00-index.tar.gz --exclude '*.tar.gz' unstable
10:58:17 <dcoutts> xerox, that way all the files will have a leading /unstable/
10:58:23 <dcoutts> if you do not want that then...
10:59:06 <SamB> ack, I give up on this adventure thing for lack of sufficient RAM
10:59:49 <dcoutts> use tar --create --gzip --file 00-index.tar.gz --exclude '*.tar.gz' --directory unstable .
10:59:56 <dcoutts> xerox, note the final .
11:00:03 <xerox> Right
11:00:10 <dcoutts> xerox, let me just test that... :-)
11:00:12 <xerox> OK!
11:02:43 <dcoutts> xerox, yep, works
11:02:57 <dcoutts> xerox, though that prefixes all files with ./ and adds a ./ dir entry
11:03:03 <dcoutts> final idea...
11:03:37 <dcoutts> well, actually that's probably ok
11:04:09 <dcoutts> you could use * but that needs shell expansion
11:04:11 <xerox> I need them into packages/ I think
11:04:17 <dcoutts> that's ok then
11:04:24 <dcoutts> run the command from the dir above
11:04:35 <dcoutts> then they'll all have the name of the dir they are in
11:04:36 <xerox> That's what I will be doing I believe
11:04:48 <dcoutts> but that'll be whatever the dir is called
11:04:52 <dcoutts> eg unstable
11:04:55 <dcoutts> not packages
11:06:28 <xerox> I'll call it packages.
11:06:47 <dcoutts> anyway, it's easily changed
11:06:55 <dcoutts> you can tar it up anyway you need
11:07:04 <xerox> So...
11:10:33 <dcoutts> oops
11:11:16 <xerox> Hmm it misses the package/ dir
11:11:21 <xerox> Oh sorry.
11:11:27 <xerox> I did it in the wrong dir I see.
11:12:12 <xerox> Ah, it's okay this way: from pub/ without --directory.
11:13:52 <xerox> OK I used 00-latest somewhere and 00-index somewhere else
11:13:55 <xerox> Fix after dinner
11:13:58 <xerox> Later!
11:17:16 * SamB wonders why people had trouble teleporting to the museum -- though he supposes that with 10 minutes it is hard to think well
11:17:30 <SamB> I couldn't even upload a program in 10 minutes, actually
11:18:48 * zarvok observes an article about that competition was published in the post gazette today:
11:18:51 <zarvok> http://www.post-gazette.com/pg/06228/713708-115.stm
11:18:53 <lambdabot> Title: Fiction-filled computer code mystery peppered with 'ancient' puzzles
11:18:55 <xerox> This is crazy
11:19:06 <xerox> We had 4 power outages so far and I didn't realize it
11:19:11 <xerox> The iMacsurvived them all without turning off O-o
11:19:27 <xerox> But I better turn it off I wouldn't like to damage it
11:19:28 <SamB> I wish I had more RAM
11:19:38 <xerox> Crazy anyway... later
11:19:45 <SamB> then I could beg zarvok for tips as to why my RML ain't working
11:19:52 <zarvok> heh
11:19:57 <zarvok> ram is definitely helpful
11:20:37 <SamB> maybe I should items from another room for my scratch space?
11:21:04 <SamB> so it doesn't take so long to test my code...
11:21:04 <zarvok> I think you lost a word there
11:21:13 * stepcut just noticed that google has replaced 'groups' with 'videos' 
11:21:13 <SamB> er, yes, "use" is the word
11:21:17 <SamB> I do that a lot lately
11:21:53 <SamB> is there a room with about five items in it?
11:21:57 <zarvok> well, I'm happy to take a look at your adventure code if you want to paste it or e-mail me (ccasingh@andrew.cmu.edu), but adventure is probably the problem that I worked least on, so I'm not sure I can help much
11:22:01 <zarvok> I don't recall
11:22:18 <SamB> http://paste.lisp.org/display/24205 is most of the code
11:22:48 <zarvok> what are you having trouble with, precisely?
11:23:24 <SamB> well, this code does break all the items in the "Games and Amusements Exhibit" when called appropriately
11:23:44 <SamB> but it doesn't seem to return anything...
11:24:10 <SamB> let me show the case from the process function:
11:24:53 <SamB>   | Break { item } => [
11:24:53 <SamB>       let text = steal_description (item).
11:24:53 <SamB>       return success_command ("speak", Atom { text })
11:24:53 <SamB>   ]
11:26:24 <SamB> anyway, every time I try it, it says:
11:26:29 <SamB> You speak the words "" aloud, but there is no one around to hear
11:26:29 <SamB> them.
11:27:20 <zarvok> hmm
11:27:35 <zarvok> well, sounds like a problem in steal_description, let me see
11:27:44 <SamB> I think so, yes ;-)
11:27:47 <zarvok> your solution, incidentally, works a lot differently than the reference one I have
11:27:52 <zarvok> but it seems like the idea should work
11:28:40 <SamB> would be more practical with more than 256 megs of RAM...
11:29:16 <zarvok> heh, wouldn't everything
11:29:52 <SamB> well, oddly enough I think UMIX and JHC are about the worst offenders I've encountered so far
11:30:05 <zarvok> yes, UMIX is not light on RAM use
11:30:13 <SamB> JHC actually exceeded my *swap*
11:30:23 <zarvok> of course, there are ways to design the UM that use less, but even the best seem to use a fair bit
11:30:32 <zarvok> heh
11:30:45 <SamB> how would a UM use less?
11:31:08 <SamB> my UM has one word of overhead in addition to that of malloc...
11:31:49 <SamB> the only thing I can think of would be if some arrays weren't full word arrays (which would of course slow down the indexing)
11:32:36 <musasabi> SamB: did you try a very recent version. Base.hl is now 1/3 the size it was two weeks ago.
11:32:47 <SamB> musasabi: what?
11:32:49 <zarvok> well, some people did all sorts of funky things, like writing their own slab allocators, etc.
11:32:55 <SamB> my UM is written in C
11:32:58 <SamB> oh, you mean JHC?
11:33:03 <SamB> that was a bad version probably...
11:33:05 <SamB> but still!
11:33:27 <SamB> zarvok: what is a slab allocator?
11:34:20 <zarvok> it's just a memory allocation management strategy, what I mean to say is that some people wrote their own allocators instead of using malloc
11:34:27 <SamB> well
11:34:48 <zarvok> and some claim to have better memory performance as a result, but I haven't personally looked at the numbers
11:35:19 <SamB> I would try using a garbage collector except that valgrind didn't think there was any memory that wasn't still referenced...
11:36:04 <musasabi> SamB: JHC head is very volatile.
11:36:05 <zarvok> yes, I honestly don't know what kind of memory use numbers can be obtained by wonky allocation strategies, only that some people claim to have done better than the obvious solution
11:40:53 * SamB downloads the latest codex, wonders if it will help him with anything
11:41:10 * SamB heard something about changes in the balance problems
11:41:25 <zarvok> I think the only changes from 7 to 8 are in 2D and ants, possibly some spec changes in balance
11:41:44 <SamB> you mean the problems haven't actually changed?
11:41:56 <zarvok> well ants changed because of an exploit
11:42:05 <zarvok> 2d changed because of a possible uncaught exception
11:42:14 <SamB> exploit?
11:42:41 <zarvok> basically, because of the implementation, the lower lines of the puzzle might not be checked for correctness, so you could put ants on them even if there were no stars
11:42:51 <zarvok> making some puzzles trivial
11:42:58 <SamB> oooh
11:43:05 <zarvok> I don't mean exploit so much as we made a stupid error
11:43:13 <SamB> so how is releasing a new codex supposed to help that?
11:43:29 <zarvok> that's why the pubs went from ANTOM to ANTWO, so that people couldn't submit ones from the old codex
11:43:34 <zarvok> well, the error is fixed in the new codex
11:44:28 <SamB> oh
11:48:05 <zarvok> SamB: well, the mistake in your code isn't immediately obvious to me, unfortunately
11:48:16 <SamB> rats :-(
11:48:21 <zarvok> I really need to play all the way through adventure... I've only poked at bits and pieces of it
11:48:32 <zarvok> Only a month to go until ICFP though :)
11:48:48 <SamB> I do have a script for getting the uploader, of course
11:48:52 <zarvok> yes
11:49:31 <zarvok> maybe this weekend I'll have time to play through it.  If I'm able to, I'll ping you at some point when I think I'd have better luck poking at your code
11:49:59 <lisppaste2> SamB annotated #24205 with "uploader.scr" at http://paste.lisp.org/display/24205#1
11:50:46 <SamB> the manual is just north of where the script finishes
11:51:10 <zarvok> Yeah, I doubt there is a problem before that point
11:51:39 <SamB> there cannot be a problem in the script
11:51:39 <zarvok> I have to run though.  I'll take a peek later if I have a chance
11:51:45 <zarvok> yes
11:52:10 <zarvok> that's what I'm saying.  No way fro that to influence what happens later
11:52:19 <SamB> I mean, everything that was destroyed is in the trash heap, everything that is broken can be fixed with a little help from the RML...
11:52:28 <xerox> stepcut: hey there, what's the status of BS-Parsec?
11:52:43 <mnvl> hi, haskell.org/hoogle can't find Data.Trie, yet googling for it seems to suggest that that function / structure exists?
11:52:57 <xerox> Could it be Tree, mnvl ?
11:53:04 <SamB> mnvl: most likely it is in an outside library?
11:53:18 <mnvl> it's definitely Trie
11:53:25 <xerox> OK, then SamB's.
11:53:46 <xerox> @docs
11:53:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
11:53:55 <xerox> ^- this is the standard library hierarchy
11:54:01 <SamB> one not listed in hoogle or the standard library docs
11:54:05 <mnvl> is there nywhere easy to find outside libs, other that google?
11:54:09 <xerox> ...which's hoogle-ized.
11:54:46 <mnvl> k, i didn't realize that
11:55:53 <SamB> zarvok: what is the point of this menu in the self-extractor?
11:56:21 <SamB> is it some kind of sick joke?
12:44:52 * xerox hrrmpffs
12:45:08 <Heffalump> ?
12:45:26 <xerox> Having trouble starting working again.... yaaawn
12:50:12 <zarvok> SamB: no real point, just a sort of stopping point before your screen gets pooped on by loads of binary goodness
12:50:29 <SamB> zarvok: huh
12:50:42 <SamB> I dunno if that is actually any help
12:51:05 <SamB> sure, there isn't really anything else you could reasonably expect, having just coded the UM...
12:51:53 <zarvok> heh, you'd be surprised how many "I think my UM is correct but all it does is dump garbage on my screen" e-mails we got
12:52:32 <Heffalump> :-)
12:52:58 <SamB> you'd think that after picking that item they'd be able to figure out what was going on...
12:53:20 <zarvok> heh
12:54:05 <zarvok> you may give people too much credit
12:55:42 <Heffalump> I was quite impressed by all the people posting to the mailing list for help with getting their UM working on the Sunday/Monday
12:59:26 <zarvok> Heffalump: yeah, there was even an IRC channel they created for people who still didn't have working UMs
12:59:59 <zarvok> I was impressed by their endurance, after two days of hacking on a simple UM and seeing how much more other people had done, I probably would have given up
13:00:59 <Heffalump> yeah
13:01:11 <Heffalump> we were quite disappointed it too us several hours to get it working
13:01:16 <Heffalump> s/too/took/
13:01:43 <Heffalump> and we ended up cross-checking traces between two independent implementations
13:01:51 <zarvok> we figured it would be about a 2 hour task for teams who started in C, and the first team clocked in around 1:45, so we were pleased
13:01:58 <Heffalump> heh
13:02:42 <Heffalump> one of us started in Haskell, then I started a C one a bit later, and then a few hours later we'd fixed all the bugs in the Haskell one. The next morning we fixed the C one.
13:02:57 <zarvok> yeah
13:02:59 <Heffalump> (cos the Haskell one was too slow, story of everyone's life..)
13:03:02 <SamB> C is very bug-prone
13:03:11 <zarvok> it took me about 6-8 hours to get a working haskell one when I tested it pre-contest
13:03:16 <SamB> yeah, the Haskell one is always too slow
13:03:19 <Heffalump> I gave up on the C one once the Haskell one worked, until we realised that we needed the speed.
13:03:27 <zarvok> but I don't pretend to be the worlds fastest haskell coder
13:03:43 <zarvok> and my implementation was too slow to be usable
13:03:51 <Heffalump> ours was usable, just a bit painful
13:03:54 <zarvok> which was part of why it took so long to fix
13:03:57 <Heffalump> especially when I started working on 2D
13:04:00 <zarvok> :)\
13:04:18 <zarvok> We were actually really surprised at how fast 2d implementation was
13:04:19 <Heffalump> how much effort did you all put in to testing stuff?
13:04:19 * tennin is in the running for world's slowest
13:04:36 <Heffalump> seemed like it was quite a lot, from how well balanced the problems were
13:04:42 <zarvok> quite a bit, we have an extensive regression test suite that ran continuously for about a week before the contest
13:04:54 <Heffalump> I meant testing the problems
13:04:55 <SamB> I want to know how much effort they put into HEAP PROFILING!
13:04:58 <zarvok> and we had a number of beta testers
13:05:10 * zarvok laughs
13:05:34 <SamB> (it wasn't enough, anyways!
13:05:35 <SamB> )
13:05:36 <Heffalump> 2D was a great lesson in the value of type checking
13:05:43 <zarvok> heh
13:05:51 <Heffalump> once I'd fixed all the runtime errors that a static type checker would have found, my raytracer worked first time
13:06:41 <Heffalump> I'm still not sure which would have been faster (implementing some kind of monadic or arrow based combinator language to write 2D programs in, or doing it from scratch)
13:06:47 <zarvok> I've been toying with the idea of a 2d 2.0 which is statically typed, but a formalization of the type system seems nontrivial
13:06:59 <SamB> haha
13:07:11 <zarvok> and I am too lazy to think about it much
13:07:37 <zarvok> Heffalump: which way did you do it?
13:07:38 <Heffalump> oh. I didn't think it would be hard, but I also didn't think about it much.
13:07:40 <Heffalump> zarvok: by hand.
13:07:42 <SamB> hmm, these not-really-roots don't really have much purpose, do they?
13:08:02 <Heffalump> so how did you actually implement the puzzles? Presumably you had a compiler to UM bytecode, but from what languages?
13:08:19 <zarvok> we aren't revealing too many details until the ICFP talk
13:08:25 <zarvok> don't want to steal our own thunder
13:08:30 <Heffalump> ok :-)
13:08:35 * SamB is not smart enough to even figure out how to represent 2d programs, nevermind pretty-printing them
13:08:43 * Heffalump can't make ICFP this year :-(
13:08:52 <SamB> or at least, it makes my head spin to think about it
13:08:54 <zarvok> I just found out they are going to send me, and am excited
13:09:03 * zarvok has never been
13:09:35 <SamB> most people think it is from ML or something like that...
13:09:47 <Heffalump> well, being from CMU, it would be mostly ML based :-)
13:09:48 <zarvok> we certainly intended the raytracer to be solved by writing a something-to-2d compiler
13:10:01 <zarvok> heh
13:10:31 <SamB> did they discard Common Lisp a while back?
13:10:41 <zarvok> what's good is that the guy who came up with "cult of the bound variable" didn't realize it had the same initials as call by value for like 2 months
13:11:15 <zarvok> he couldn't understand why the group liked it so much
13:11:18 <monochrom> Haha
13:12:28 <zarvok> took me a while too :)
13:13:20 <bass> Hi guys, I'm playing with HaRe (http://www.cs.kent.ac.uk/projects/refactor-fp/hare.html) When I test it on a simple module with no imports it works perfectly. But when I try to create a new project for a bigger file with a lot of imports like Data.Set, Data.Map, etc.. it gives an error:Source files missing for (add files with 'pfe add' or 'pfe chase'): ...
13:13:44 <bass> and then all the modules I imported
13:21:20 <xerox> Downloading package list from server 'file:///Users/paolo/Code/Cabal/cabal-install/pub'
13:21:23 <xerox> tar (child): etc-cabal-install/00-index.tar.gz: Cannot open: No such file or directory
13:21:26 <xerox> roar
13:25:45 <reilly> has anyone done Mac OS X builds that pickup the OpenAL, OpenGL, GLUT, etc frameworks from /System/Library?
13:25:54 <reilly> of ghc
13:26:02 <LordBrain> HaRe looks like it might be a handy little tool
13:26:57 <dmhouse> xerox: debugging?
13:27:16 <xerox> dmhouse: I printed the current dir now, and it seems to be in the right place, mumble.
13:28:18 <dmhouse> xerox: use an absolute path? Perhaps the tar instance is running from ~ or something.
13:28:19 <xerox> Maybe I should give tar 1. a complete path from /, 2. an option saying where to extract things
13:28:32 <xerox> dmhouse: it isn't, but I thought about it too, checking how to do it now.
13:29:46 <kosmikus> @seen SyntaxNinja
13:29:46 <lambdabot> I saw SyntaxNinja leaving #haskell, #darcs and #haskell-blah 1 day, 20 hours, 15 minutes and 22 seconds ago, and .
13:32:09 <xerox> dcoutts: so I should avoid {get,set}CurrentDir at any cost?
13:32:40 <dcoutts> xerox, not any cost, but I don't expect you need it
13:32:51 <xerox> It's strange for me too
13:33:06 <xerox> I mean, the file is right there, but tar doesn't seem to see it
13:33:24 <Daveman> xerox :D
13:33:29 <dcoutts> how are you invloking it?
13:33:41 <xerox> Like TarUtils.extractTarFile is
13:33:45 <dcoutts> xerox, if you need to set the CWD for tar you can specify it when you call it
13:33:49 <xerox> I.e. I am using it
13:33:52 <dcoutts> see runProcess
13:34:32 <xerox> http://darcs.haskell.org/packages/Cabal/Network/Hackage/CabalInstall/TarUtils.hs
13:35:11 <xerox> Hm I see what you mean
13:35:29 <xerox> Also I just noticed I could use `tarballGetFiles' instead of recursing the fs.
13:35:58 <dcoutts> but you still need to read the files
13:36:05 <dcoutts> which means unpacking the tar
13:36:27 <dcoutts> so recursing is still a sensible thing to do methinks
13:37:21 <dcoutts> xerox, so it takes the path of the .tar.gz file and extracts it inplace
13:37:36 <dcoutts> ie in the same dir as the .tar.gz is in
13:37:45 <xerox> I can unpack and list, then read the files from that list.
13:37:58 <dcoutts> which for the 00-index.tar.gz might be what you want
13:38:26 <dcoutts> xerox, so what goes wrong?
13:38:44 <xerox> Downloading package list from server 'file:///Users/paolo/Code/Cabal/cabal-install/pub'
13:38:48 <xerox> tar (child): etc-cabal-install/00-index.tar.gz: Cannot open: No such file or directory
13:38:59 <xerox> But: $ file etc-cabal-install/00-index.tar.gz
13:38:59 <xerox> etc-cabal-install/00-index.tar.gz: gzip compressed data, from Unix
13:39:54 <dcoutts> xerox, yes, the extractTarFile code is wrong
13:40:08 <xerox> Too many Nothings ?
13:40:21 <dcoutts> it essentially cd's to etc-cabal-install and then calls tar -xzf etc-cabal-install/00-index.tar.gz
13:40:24 <xerox> ?docs System.Process
13:40:24 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
13:40:29 <dcoutts> but there is no etc-cabal-install/00-index.tar.gz
13:40:37 <dcoutts> since you're in etc-cabal-install/
13:40:44 <dcoutts> so there's only 00-index.tar.gz
13:40:46 <xerox> I am not!
13:40:54 <xerox> I did print =<< getCurrentDirectory and it says:
13:40:54 <dcoutts> runProcess tarProg args (Just dir)
13:40:58 <dcoutts> (dir,_) = splitFileName tarFile
13:41:05 <xerox> Oh, I see what you mean.
13:41:19 <dcoutts> it's running tar with dir as it's initial working dir
13:42:43 <dcoutts> xerox, if I were you, I'd change extractTarFile to take one more argument, the dir to extract in
13:42:58 <xerox> Okay.
13:42:59 <dcoutts> then use args = ["-xzf",tarFile, "-C", dir]
13:43:14 <dcoutts> and do not pass (Just dir) as the working dir, leave that as Nothing
13:43:35 <dcoutts> that way, with "-C" tar will cd to that dir before untarring
13:43:50 <xerox> I will break the code that manages the packages this way
13:43:56 <xerox> But okay
13:44:09 <dcoutts> well that doesn't use the dir clearly or it'd break
13:44:14 <dcoutts> ok there's another way
13:44:32 <dcoutts> (dir,fileName) = splitFileName tarFile
13:44:40 <dcoutts> args = ["-xzf",fileName]
13:44:49 <dcoutts> that ought to work too
13:45:18 <SamB> dcoutts: where filename includes ../?
13:45:19 <dcoutts> and in that case leave it using dir as the working dir
13:45:27 <dcoutts> nope
13:45:32 <dcoutts> runProcess tarProg args (Just dir)
13:45:43 <dcoutts> so it is relative to the working dir
13:45:43 <xerox> It works!
13:45:49 <dcoutts> @yarr!
13:45:49 <lambdabot> Yarrr!
13:45:54 <xerox> @karma+ dcoutts
13:45:54 <lambdabot> dcoutts's karma raised to 18.
13:46:01 <dcoutts> @arr
13:46:01 <lambdabot> Arrr!
13:46:13 <xerox> What a nice list of .cabal files it printed....
13:46:20 <xerox> Let's make it WORK!
13:46:28 <xerox> cabal-install: Prelude.undefined
13:46:30 <xerox> Yuck ;)
13:46:33 <dcoutts> ha ha ha
13:46:37 <dcoutts> @brain
13:46:37 <lambdabot> I think so, Brain, but we're already naked.
13:46:45 <dcoutts> !!
13:46:48 <xerox> Exactly... so handy, this undefined, it is.
13:47:18 <SamB> @brain
13:47:19 <lambdabot> But where are we going to find a duck and a hose at this hour?
13:47:39 <SamB> shouldn't that be @Are you pondering what I'm pondering, pinky?
13:47:49 <dcoutts> ;-)
13:48:20 <ozone> @karma ozone
13:48:20 <lambdabot> You have a karma of 0
13:48:35 <ozone> wha, it's not negative?
13:48:42 <xerox> dcoutts: but really, there's no need to traverse the fs because I can get the list out of the tar.  And I'm saying this having the code that traverses working....
13:49:11 <dcoutts> xerox, mm, that invoves decompressing every time
13:49:41 <dcoutts> xerox, if you like, make the thing return the file contents
13:49:49 <dcoutts> that's what you really want
13:49:54 * xerox *nods*
13:50:06 <xerox> I am not sure about how to distinguish the files that way, but I thought about it
13:50:11 <dcoutts> opening them and reading them lazily on demand of course :-)
13:50:54 <xerox> I can have tar spit them all to stout with '-', but it means... parsing?
13:51:04 <dcoutts> xerox, mapM readFile . filter . flatten <<= lazyDirTree thing
13:51:12 <xerox> Comonads? :D
13:51:14 <dcoutts> or something like that
13:51:17 <dcoutts> na, it's easy
13:51:23 <xerox> (kidding about <<=)
13:51:29 <dcoutts> err =<<
13:51:43 * dcoutts always gets that operator confused
13:51:44 <xerox> Yeah, I'll do that way, lazyDirTree works
13:51:57 <xerox> Unfortunately its return value is polluted with "".
13:52:04 <xerox> (One for each subdirectory)
13:52:14 <dcoutts> not after you filter for .cabal files
13:52:25 <dcoutts> which you do anyway
13:52:26 <xerox> Well sure.
13:52:33 <SamB> why does it have ""s anyway?
13:52:48 <xerox> Because when I find a directory I do Node "" entries.
13:52:50 <dcoutts> the tree contains nodes for the dirs themselves
13:53:09 <SamB> hmm, why does amazon thinks it has my media library?
13:53:18 <xerox> No idea.
13:53:19 <SamB> why does it think I have a media library, even?
13:53:51 <SamB> its more like media here, media there ... a little media everywhere!
13:54:14 <SamB> if media includes books, anyway
14:00:34 <dylan> I have a media library in /srv/common, sort of.
14:00:47 <SamB> oh, I do have some video files
14:00:51 <SamB> and some sound files
14:01:06 <SamB> and most of my video and sound files are somewhere in one of two trees, even...
14:01:09 <dylan> I also have a lot of papers mentioned on LtU there... that's media, right?
14:19:02 <PaulAJ> Hi.  I see audreyt is here.
14:20:31 <mnislaih> Lemmih: there ?
14:20:47 <PaulAJ> ping audreyt
14:22:08 <PaulAJ> Well anyway, I read in the Haskell humour file a quote about some stacked continuation monad (using ContT), saying "I wrote it, and it works, but I don't know what it means".
14:22:23 <PaulAJ> I have also been working with ContT, and I have so been there!
14:22:37 <Lemmih> mnislaih: Hiya.
14:22:53 <xerox> I think... it works!
14:23:01 <xerox> At least the update, let me try install something :)
14:23:03 <mnislaih> ah Lemmih: we are nearing a real beta status
14:23:05 <Lemmih> xerox: Cabal-get?
14:23:13 <xerox> Yup.
14:23:19 <mnislaih> I would be glad if you'd do a review of the code.
14:23:33 <mnislaih> I'll be working in the documentation and finishing the tests  until next week
14:24:02 <xerox> cabal-install: /Users/paolo/Code/Cabal/cabal-install/pub/helloWorld2/helloWorld2-1.1.tar.gz: copyFile: does not exist (No such file or directory)
14:24:09 <xerox> roar, I broke something
14:25:09 <xerox> no "packages/" uhu.
14:25:51 <Lemmih> mnislaih: Great. I'll have a look at it after my sister's birthday tomorrow.
14:26:09 <monochrom> there are many degrees of "know"
14:26:23 <mnislaih> fine for me, whenever you find time for it Lemmih
14:28:09 <monochrom> When you issue a "delete row" command to a modern database, you probably don't actually know what it means (internally); you only know it works (externally).  This happens on an hourly basis in the real world.
14:29:29 <monochrom> So if you stack up a few ConT's and they work, don't feel bad if you don't know completely why.  You are ready for the real world.
14:29:50 <monochrom> If you know too much, they call you an academic type.
14:41:44 <PaulAJ> monochrom: you are so right.  I generally keep one foot in each world, and both sides seem to think I'm standing on one leg.
14:45:56 <xerox> Lemmih, dcoutts: we have the new index format :)
14:46:02 <dcoutts> yay
14:46:13 * xerox posts to the list
14:46:29 <xerox> (With some explanations)
14:50:46 <dmhouse> xerox: which list?
15:12:57 <offby1> dmhouse: yo!
15:31:54 <shapr> @users
15:31:57 <lambdabot> Maximum users seen in #haskell: 235, currently: 203
15:32:46 <mnislaih> shapr are you idle?
15:33:34 <shapr> What do you mean?
15:34:28 <mnislaih> since this is so quiet, and you seemed to be randomly asking lambdabot
15:34:55 <mnislaih> I was going to suggest that you should play with the ghci.debugger. I'm in need of beta-te.. err, users
15:35:10 <shapr> I have enough to do, but thanks for the offer :-)
15:35:10 <dmhouse> mnislaih: I'll do it! :)
15:35:26 <mnislaih> great, thanks dmhouse !
15:35:48 <dmhouse> mnislaih: URL then?
15:35:49 <mnislaih> http://haskell.org/haskellwiki/Ghci/Debugger
15:35:51 <lambdabot> Title: Ghci/Debugger - HaskellWiki
15:36:03 <mnislaih> ?remember http://haskell.org/haskellwiki/Ghci/Debugger
15:36:04 <lambdabot> Incorrect arguments to quote
15:36:14 <mnislaih> ?remember ghci.debugger http://haskell.org/haskellwiki/Ghci/Debugger
15:36:15 <lambdabot> Done.
15:36:19 <mnislaih> ?ghci.debugger
15:36:20 <lambdabot> Unknown command, try @list
15:36:23 <shapr> I think it's @where+
15:36:26 <eivuokko> ITYM where+
15:36:29 <mnislaih> @where ghci.debugger
15:36:30 <lambdabot> I know nothing about ghci.debugger.
15:36:40 <shapr> @where+ ghci.debugger http://haskell.org/haskellwiki/Ghci/Debugger
15:36:41 <lambdabot> Done.
15:36:44 <mnislaih> ah, ok
15:36:46 <mnislaih> @where ghci.debugger
15:36:46 <lambdabot> http://haskell.org/haskellwiki/Ghci/Debugger
15:36:54 <dmhouse> What you did is this:
15:37:00 <dmhouse> ?quote ghci.debugger
15:37:00 <lambdabot>  http://haskell.org/haskellwiki/Ghci/Debugger
15:37:06 <dmhouse> ;)
15:37:12 <shapr> @quote
15:37:13 <lambdabot> glguy says: that's odd, mine is this big : |-----------------------------|
15:37:15 <mnislaih> oh, that's what I was going to ask
15:37:29 <shapr> @quote
15:37:30 <lambdabot> ChrisKuklewicz says: Are there little known Haskell idioms for doing math? Is there an undocumented -funleash-fortran parameter?
15:37:44 <eivuokko> mnislaih, Does the repo follow main ghc-6.5 patches?
15:38:08 <mnislaih> I merge them manually. Last time I did was a few days ago
15:38:41 <dmhouse> mnislaih: so, what, I just do a darcs get from there and ./configure && make?
15:38:49 <mnislaih> if you don't get conflicts then it'll probably work fine eivuokko
15:38:59 <mnislaih> dmhouse: plus autoreconf first
15:39:01 <xerox> Hmmm my mail server seem ... not working :(
15:39:19 <mnislaih> dmhouse: important, you also need to pull the libraries from there
15:39:39 <eivuokko> mnislaih, I'll probaby try it next time I start a ghc build.
15:39:56 <mnislaih> eivuokko: if I sync with main ghc patches, will you try it sooner ?
15:40:01 <dmhouse> mnislaih: If I already have a ghc-6.5 installed, will make install bork?
15:40:12 <eivuokko> mnislaih, Nope, I'm working on something else on the tree on my current build.
15:40:34 <mnislaih> dmhouse: you don't need to (nor should) install this version. Use it in-place
15:40:39 <eivuokko> mnislaih, Are you in hurry?  I could start another build, I guess.
15:40:44 <mnislaih> not at all
15:40:45 <dmhouse> mnislaih: right-oh.
15:41:04 <xerox> shapr: did the mail arrive on cabal-devel ?
15:41:15 <xerox> dmhouse: that answers your question too -^  :)
15:41:29 <dmhouse> xerox: aha, not subscribed to that one.
15:41:30 <eivuokko> xerox, I can see your mail on cabal-devel.
15:41:38 <mnislaih> eivuokko: I'm planning to do a beta release before next week, and I'd like to get some people to try it first
15:41:44 <xerox> eivuokko: ok cool! I can't... yuck :)
15:42:19 <dmhouse> xerox: using Gmail?
15:42:35 <xerox> No way! :)
15:42:44 <dmhouse> Gmail won't show outgoing messages in your archive until someone responds and it turns into a conversation.
15:42:45 <xerox> shapr: I hope it'll work for hope :)
15:42:59 <dmhouse> xerox: 'no way'? I love Gmail :)
15:43:02 <xerox> dmhouse: I am using nemail.it in fact.
15:43:13 <xerox> De gustibus.
15:44:34 <dmhouse> mnislaih: it's building.
15:45:07 <mnislaih> cool. did you do the darcs-all thing ?
15:45:26 <dmhouse> No, but make died, so it's okay. :)
15:45:34 <dmhouse> ./darcs-all get, or something, right?
15:45:38 <mnislaih> yep
15:45:50 <dmhouse> After chmodding.
15:46:41 <mnislaih> I'm going to update that script to do this automatically, but in the interim you will need to manually do a 'darcs pull http://darcs.haskell.org/SoC/ghc.debugger/libraries/base' from your libraries/base folder
15:47:08 <dmhouse> So, all in all:
15:47:14 <dmhouse> darcs get http://wherever
15:47:16 <dmhouse> autoreconf
15:47:19 <dmhouse> ./configure
15:47:29 <dmhouse> chmod +x darcs-all
15:47:33 <dmhouse> ./darcs-all get
15:47:41 <dmhouse> cd libraries/base
15:47:49 <mnislaih> oh no. It is important that you do the autoreconf after you have done the darcs-all thing
15:47:58 <eivuokko> Don't you need to do configure-stuff after darcs-all
15:48:00 <dmhouse> darcs pull http://darcs.haskell.org/SoC/ghc.debugger/libraries/base
15:48:00 <mnislaih> so first of all, the darcs-all script
15:48:02 <lambdabot> Title: Index of /SoC/ghc.debugger/libraries/base
15:48:08 <dmhouse> Oh, okay.
15:48:18 <dmhouse> But then do that, then cd ../..; make and go.
15:48:25 <mnislaih> yep
15:48:52 <mnislaih> use make -j2 if you are lucky to have a dual core machine
15:49:03 <eivuokko> make -j2 is broken.
15:49:12 <mnislaih> in every make version ?
15:49:19 <eivuokko> No, in ghc's buildsystem.
15:49:30 <eivuokko> Ah
15:49:42 <eivuokko> But if you are in non-windows the problem wont probably show up
15:49:45 <mnislaih> it seems to work well here, but I wouldn't know well
15:49:51 <mnislaih> Mac Intel here
15:49:54 <eivuokko> As the missing preprocessor defines don't matter...
15:50:12 <dmhouse> Well I'm on a single-core Linux box so it definitely won't matter :)
15:50:28 <eivuokko> Actually, make -j2 is often faster even on single-core machines too.
15:50:44 <dmhouse> What difference does it make?
15:51:04 <mnislaih> in my machine, the compilation process seems to be IO-bound
15:51:18 <mnislaih> so -j2 should definitely give a boost even in single core
15:51:35 <dcoutts> xerox, looks good
15:51:52 <xerox> dcoutts: I'm so happy.
15:51:53 <dcoutts> xerox, so what's next? I think multiple repos is not highest priority.
15:52:00 <xerox> Me too.
15:52:04 <dcoutts> getting a demo working is highest priority
15:52:22 <dcoutts> I want to be able to download and install 3 packages that dep on each other
15:52:37 <dcoutts> and have that "Just Work"tm
15:52:51 <dcoutts> cabal-install hxt-6.1
15:53:14 <SamB> wha?
15:53:21 <SamB> does GHC even support that?
15:53:27 <dcoutts> not ghc
15:53:29 <dcoutts> cabal-install
15:53:31 <SamB> cyclic dependencies between packages?
15:53:38 <dcoutts> no, no
15:53:43 <dcoutts> a chain of 3 packages
15:53:49 <SamB> you said "eachother"
15:53:57 <dcoutts> ambiguous
15:53:59 <SamB> that makes me think "each depends on the other two"
15:54:10 <dmhouse> mnislaih: Okay, now it's really building :)]
15:54:15 <dcoutts> yep, sorry
15:54:27 <SamB> or maybe "first one depends on the second one depends on the third one depends on the first one"
15:54:33 <xerox> dcoutts: I'd like to know what packages people want
15:54:41 <xerox> dcoutts: then I can put them online, in some repo, or even the official one
15:55:16 <mnislaih> Tomorrow there will be a nice new short tutorial in the wiki dmhouse. Make sure you check it
15:55:23 <dmhouse> Sure.
15:55:40 <dcoutts> xerox, well, as an example hxt depends on http which depends on crypto which depends on newbinary
15:55:47 <mnislaih> and feel free to spam me with any issues you find
15:55:48 <dcoutts> ;-)
15:56:15 <SamB> dcoutts: unless you get the "lite" version of http
15:56:22 <dcoutts> SamB, indeed
15:56:34 <xerox> I am trying to get shapr making a repo of hope, but I think I made him angry because I promised cabal-install working so many times until now :(
15:56:37 <dcoutts> I've been trying to persuade people to break those long chains
15:56:45 <dcoutts> but it's useful for testing cabal-install
15:56:53 <SamB> but perhaps that ought to be abandoned after cabal comes out...
15:56:54 <dcoutts> xerox, heh :-)
15:57:04 * xerox sighs
15:57:15 <dcoutts> SamB, no, there were other reasons for breaking those long dep chains
15:57:49 <SamB> well, in any case the logic for http-lite shouldn't be in depending packages...
15:58:12 <dcoutts> xerox, or xml-rpc lib deps on haxml, http and crypto
15:58:20 <SamB> oh, and what were the other reasons anyway?
15:58:29 <dcoutts> SamB, no one supports newbinary
15:58:36 <SamB> oh
15:58:37 <dcoutts> so we can't really package it
15:58:39 <SamB> that is a good point
15:58:54 <dcoutts> also the deps were fairly tenuous
15:59:01 <dcoutts> like using one util module
15:59:19 <dcoutts> eg using base64 from the crypto lib
15:59:36 <SamB> yeah
15:59:40 <dcoutts> it's a lot of code to pull in for just one function
15:59:48 <SamB> true
15:59:50 <xerox> Man, the recent oleg-ery on haskell-cafe is really awesome.
16:00:18 <dcoutts> xerox, you know all the base libs are cabalised
16:00:23 <dcoutts> some of those dep on each other
16:00:36 <dcoutts> minimal installs of ghc will not include all the modules
16:00:43 <xerox> Are the base libs those in darcs.haskell.org/packages/ ?
16:00:47 <dcoutts> yep
16:00:58 <dcoutts> in Gentoo we're going to have a minimal ghc-6.6 and package all the libs seperately
16:01:02 <dcoutts> so quicker compiles
16:01:09 <dcoutts> and you'll onle compile the libs you need
16:01:28 <dcoutts> so pugs & darcs users will be happy
16:02:32 <Patterner> when will gentoo ghc-6.6 be released..?
16:02:52 <xerox> dcoutts: in principle I think I can do a repository of darcs.haskell.org/packages/
16:03:20 <dcoutts> Patterner, some time after ghc-6.6 is release ;-)
16:03:29 <dcoutts> Patterner, actually we hope to have pre-releases
16:03:35 <dcoutts> ie the ghc-6.6 release candidate
16:03:40 <xerox> So those don't actually get installed with ghc?
16:03:44 <xerox> (Some of those?)
16:03:57 <dcoutts> Patterner, in the gentoo haskell overlay at least, not in portage itself
16:04:06 <dcoutts> but anyone can use that overlay
16:04:17 <ivant> dcoutts: and when will debian ghc-6.5. be released then? :-)
16:04:18 <dcoutts> and report problems in #gentoo-haskell
16:04:29 <dcoutts> ivant, you can use ghc-darcs now
16:04:38 <dcoutts> oh sorry, debian.
16:04:40 <dcoutts> no idea
16:05:14 <dcoutts> ghc-darcs is a "live" ebuild that works directly from the current darcs version of ghc.
16:05:19 <Patterner> layman doesn't know a haskell overlay
16:05:29 <xerox> dcoutts: that's cool!
16:05:36 <ivant> dcoutts: though, I guess I still don't have a good reason for wanting the 6.5. Does it allow using runhaskell on non-.hs files?
16:05:39 <dcoutts> Patterner, mm, I can't remember if we added darcs support to layman yet.
16:05:48 <dcoutts> ivant, no idea
16:05:58 <Patterner> you haven't :)
16:06:57 <dcoutts> Patterner, ok, I think we had some patches, I'll look into it
16:07:54 <dcoutts> Patterner, oh, hmm looks like layman-1.0.6 has darcs support
16:07:57 <Patterner> at least not in the current ~amd64 layman
16:08:11 <dcoutts> which is ~amd64 it seems
16:08:19 <Patterner> I have 1.0.6
16:08:27 <xerox> dcoutts: may you write a reply to the ml with that idea you were telling me? I'm really heading to bed
16:08:42 <dcoutts> xerox, I don't have any specific reply
16:08:52 <Patterner> but "layman -L" doesn't list anything with darcs or haskell
16:08:54 <dcoutts> except aim for a demo, not mutiple repos
16:09:02 <dcoutts> Patterner, ah yes, that's true
16:09:09 <xerox> Okay I'll just reread the backlog
16:09:15 <dcoutts> oops
16:09:19 <xerox> Thanks much
16:09:24 <LordBrain> :)
16:09:50 <LordBrain> i now understand the reader monad to my satisfaction
16:10:06 <LordBrain> and (->) e as a monad..
16:11:41 <Cale> > (do x <- reverse; y <- id; (++)) "Hello"
16:11:42 <lambdabot>  <[Char] -> [Char]>
16:12:20 <Cale> > (do x <- reverse; y <- id; (++) (x ++ y)) "Hello" "Goodbye"
16:12:21 <lambdabot>    The function `(do
16:12:21 <lambdabot>            x <- reverse
16:12:21 <lambdabot>           ...
16:12:43 <Cale> Well, this should work...
16:12:46 <Cale> > (do x <- reverse; y <- id; return (x ++ y)) "Hello"
16:12:47 <lambdabot>  "olleHHello"
16:13:15 <Cale> > (do x <- reverse; y <- id; return $ (++) (x ++ y)) "Hello" "Goodbye"
16:13:15 <lambdabot>  "olleHHelloGoodbye"
16:13:18 <Cale> ah
16:14:57 <Tela> Huh, since we've got do notation going. The wikipedia article on Monads seems to imply that do syntax only works if mzero is defined. Is that true? I thought IO didn't have an mzero.
16:15:11 <Cale> Tela: no, that's not true
16:15:23 <dmhouse> (Although IO does have an mzero.)
16:15:48 <dmhouse> ?instances MonadPlus
16:15:50 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
16:15:56 <Cale> Tela: Perhaps do-notation should rely on mzero in certain cases, but it currently doesn't.
16:16:17 <Cale> and certainly MonadZero should be split from MonadPlus again
16:16:26 <dmhouse> Using, say, guard, requires you have an mzero, but do-notation in general works for all monads.
16:20:34 <beschmi> mnislaih, tried to compile ghc.debugger but there where some errors. seems to work with the new patches so far
16:21:14 <beschmi> mnislaih, that should read: tried to compile it yesterday ...
16:27:19 <lisppaste2> dmhouse pasted "ghc.debugger errors" at http://paste.lisp.org/display/24270
16:27:41 <dmhouse> ?tell mnislaih getting http://paste.lisp.org/display/24270 when I make ghc.debugger
16:27:41 <lambdabot> Consider it noted.
16:27:51 <dmhouse> beschmi: same errors as you, by any chance?
16:31:13 <dmhouse> G'night all.
16:31:31 <lispy> @localtime dons
16:31:33 <lambdabot> Local time for dons is Thu Aug 17 09:28:45 2006
16:31:38 <beschmi> dmhouse, i don't remember the error from yesterday. it's still compiling with the patches from today.
16:36:30 <ivant> @localtime ivant
16:36:31 <lambdabot> Local time for ivant is Thu Aug 17 03:38:06 2006
16:37:53 <lambda_the_insig> possibly stupid question: is there a way of using generic IO actions within the context of the ST monad?  (specifically I'd like to use the randomIO family)
16:38:31 <glguy> lambda_the_insig: I'm pretty sure that that would not be possible
16:38:40 <glguy> unless you did some kind of unsafePerformIO
16:39:24 <lambda_the_insig> yeh, the problem with unsafePerformIO is that it would fix the return value, which is antitheical to what I'm wanting to do... :)
16:39:32 <eivuokko> There is unsafeSTToIO, but it isn't safe in the general case.
16:39:55 <eivuokko> Err, IOToST is what you want, and it exists as well
16:40:40 <sieni> stToIO is safe, unsafeIOToST isn't
16:40:51 <swiert> lambda_the_insig: couldn't you just delay passing in the generator?
16:42:32 <lambda_the_insig> yes, I suppose that's an option
16:44:36 <lambda_the_insig> so would using ioToST be exactly equivalent to performing actions in the main IO Monad?  I'm trying to use these in conjunction with runSTUArray in a "pure" function  (insofar as utilizing random state is pure :D)
16:44:48 <lambda_the_insig> I'm not too familiar with the ST* family.
16:45:43 <mnislaih> beschmi: how's it going
16:45:44 <lambdabot> mnislaih: You have 1 new message. '/msg lambdabot @messages' to read it.
16:45:46 <glguy> "random state" in the sense that it's based purely on the seed is pure
16:47:36 <beschmi> mnislaih, still going, but i think it will take some more time
16:49:05 <beschmi> mnislaih: since you're hacking ghci, do you think it would be hard to add support for a different communication channel besides stdin/stdout to ghci (tcp socket or/and unix domain socket)
16:49:26 <lambda_the_insig> ok, I took swiert's suggestion and am now just passing in a tuple with the RandomGen to be passed in at a future point.
16:50:19 <mnislaih> beschmi: certainly that would be doable, I can give you some pointers if you want to go after it
16:50:22 <swiert> lambda_the_insig: if you're in the state monad already, you may as well pass around the generator as part of your state.
16:51:06 <beschmi> mnislaih, i'm working on an emacs mode partially based on slime (the lisp mode) and using stdout/stdin has some problems.  E.g. that there is some crap in there if you do putStr "foo" or someting like that
16:51:29 <lambda_the_insig> swiert: yes, I went from STUArray -> (STUArray, RandomGen) :)
16:51:40 <mnislaih> is it a mode for haskell editing ?
16:52:09 <mnislaih> maybe you want to use the ghc-api directly then
16:53:46 <swiert> lambda_the_insig: why not have your own version of the state monad ST (STArray ..., RandomGen)?
16:53:49 <beschmi> mnislaih, is ghci just a thin wrapper around the functions exposed in GHC.hs?
16:54:12 <mnislaih> Exactly
16:54:51 <mnislaih> ghci goes a bit further and uses some stuff that is not exposed by GHC.hs, but mostly it can be considered a client of ghc-api
16:55:04 <mnislaih> look at InteractiveUI.hs
16:55:11 <beschmi> mnislaih, cool, seems like ghc-api ist the way to go
16:55:11 <Cale> lambda_the_insig: You may be somewhat interested in my Random monad and RandomT transformer
16:55:58 <mnislaih> you should look at the paper about Visual Haskell too
16:56:08 <mnislaih> in case you haven't already
16:56:41 <beschmi> mnislaih, i saved it somewhere but didn't read it yet
16:57:05 <mnislaih> beschmi, it includes some useful stuff about the ghc-api
16:58:51 <lambda_the_insig> swiert: right now the scope of what I'm doing boils down to: runSTUArray (do arr <- newArray bounds; foldM_ doSomeTransform (arr,gen) elemsToAdd; postProcess arr)
16:59:25 <lambda_the_insig> Cale: I'll look into that... I understand single-level monads fairly well, but MonadTransformers are definitely an incomplete gap in my knowledge.
16:59:31 <beschmi> mnislaih, started with the elisp side. in haskell i only have the communication protocol
16:59:39 <beschmi> mnislaih, thanks for all the pointers
16:59:55 <lambda_the_insig> one should not that I haven't yet gotten that specific code fragment working, as I really don't know what I'm doing... :-)
17:00:00 <lambda_the_insig> s/not/note/
17:00:27 <Cale> lambda_the_insig: http://haskell.org/hawiki/MonadRandom
17:00:28 <lambdabot> Title: MonadRandom - The Haskell Wiki
17:00:40 * mnislaih wants to learn some elisp  one of these days
17:00:48 <Cale> http://haskell.org/hawiki/HaskellNewbie_2fWorkingWithRandomNumbers -- has an example of use near the bottom
17:00:48 <lambdabot> Title: HaskellNewbie/WorkingWithRandomNumbers - The Haskell Wiki
17:04:06 <lispy> mnislaih: because you want to extend emacs?  any other reason is surely folly :)
17:04:55 <mnislaih> I love to play with tools & ides
17:05:15 <mnislaih> I used to enjoy hacking Eclipse plugins some time ago
17:05:22 <lispy> @where yi
17:05:22 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
17:05:28 <mnislaih> but I need to find the time to learn Emacs proper
17:05:31 <lispy> mnislaih: you should start playing with yi or hide
17:05:44 <lispy> the up and coming haskell editors
17:05:53 <mnislaih> I'm more inclined to play with hide
17:06:31 <Cale> Well, they're not unrelated. Yi is the editor foundation for hide.
17:06:45 <lambda_the_insig> thanks for the pointers, Cale.  Looks like interesting reading.
17:06:57 <mnislaih> I had the impresion that Yi was based on hs-plugins and hide on ghc-api
17:06:58 <Cale> lambda_the_insig: no problem
17:08:14 <lispy> Cale: oh, i thought they were unrelated
17:08:30 <lispy> mnislaih: at one point i toyed with the  idea of writing an elisp interpreter to run in yi
17:08:44 <lispy> mnislaih: then you could just borrow a large portion of emacs ;)
17:08:59 <mnislaih> that'd be cool, to reuse all the emacs extensions around
17:08:59 <lispy> boostrap the popularity of yi ;)
17:09:01 <Cale> lispy: hmm, they might be now, I'm not completely sure, but I do know that hide at least started off with yi as its editor.
17:10:08 <Cale> lambda_the_insig: one thing which is easy to miss about monad transformers is that while you can use them directly, for anything significant, it's usually much prettier to create a newtype, and derive Functor, Monad, and whichever other interfaces you want. This also lets you control how the features your monad has interact, by exporting your own interface to the functionality rather than the stock one.
17:10:35 <glguy> Cale: I was playing around last night and figured out a better way to do map ($5) [>2,<2]
17:10:44 <glguy> sequence [>2,<2]
17:11:03 <glguy> I remember that you were involved in the conversation... don't remember who the other guy was
17:11:05 <mnislaih> ?tell dmhouse mnislaih is thanks a lot for the follow-up
17:11:05 <Cale> > sequence [(>2), (<2)] 5
17:11:06 <lambdabot> Consider it noted.
17:11:06 <lambdabot>  [True,False]
17:11:10 <Cale> cute
17:11:21 <mnislaih> ?tell dmhouse mnislaih is thankful for the follow-up
17:11:21 <lambdabot> Consider it noted.
17:11:24 <Cale> There's one to remember :)
17:11:33 <xerox> Very nice indeed
17:12:34 <lispy> > sequence [>2, 2<] 5
17:12:34 <lambdabot>  Parse error
17:12:37 <lambda_the_insig> where is the canonical paper on MonadTs?  Preferrably by someone accessible?  :)
17:12:38 <glguy> yeah yeah
17:12:47 <glguy> lispy: I've been playing with J today
17:12:50 <lispy> > sequence [(>2), (2<)] 5
17:12:51 <lambdabot>  [True,True]
17:13:00 <lispy> J?
17:13:07 <glguy> lispy: it's messing up my haskell syntax
17:13:13 <lispy> the editor?
17:13:15 <mnislaih> g'nights people
17:13:18 <glguy> J is a sweet programming language
17:13:24 <Cale> lambda_the_insig: I don't know, I just read All About Monads, and the documentation for the monad transformers in the GHC Hierarchy
17:13:32 <glguy> I'm using it for mathschallenge.net (in addition to haskell)
17:13:42 <Cale> lambda_the_insig: I also have a good collection of small monad transformers to look at as examples
17:14:10 <glguy> lispy: you can answer questions like: "What is the sum of the digits of 100!" with       +/"."0":!100x
17:14:25 <Cale> (MonadRandom being one of them)
17:14:44 <lambda_the_insig> Cale: are those all on the wiki?
17:14:48 <Cale> lambda_the_insig: yeah
17:14:53 <lambda_the_insig> any examples are great (the simpler the better)
17:15:07 <Cale> http://haskell.org/hawiki/MonadUnique
17:15:08 <lambdabot> Title: MonadUnique - The Haskell Wiki
17:15:16 <Cale> http://haskell.org/hawiki/MonadSupply
17:15:17 <lambdabot> Title: MonadSupply - The Haskell Wiki
17:15:43 <MarcWeber> Can I use insert using haskelldb without specifying each field?
17:16:04 <Cale> http://haskell.org/hawiki/MonadUndo
17:16:05 <lispy> glguy: 1+0+0=1?
17:16:05 <lambdabot> Title: MonadUndo - The Haskell Wiki
17:16:17 <lambda_the_insig> so is there a semantic distinction between evalXXX (as seems to be your convention), vs the standard runXXX?
17:16:20 <glguy> lispy:
17:16:21 <lispy> glguy: or 100*99*...*1 = 100! ?
17:16:26 <glguy> > factoria
17:16:26 <lambdabot>  Not in scope: `factoria'
17:16:27 <glguy>  yeah
17:17:05 <Cale> lambda_the_insig: The convention is that runXXX produces any final state along with the result, while evalXXX returns only the final result
17:17:10 <glguy> > let fac n = product [1..n] in sum $ map (read . return) $ show $ fac 100
17:17:11 <lambdabot>  648
17:17:26 <Cale> execXXX produces only the final state, dropping the result
17:17:28 <lispy> that's different
17:17:41 <lispy> > sum [1..100]
17:17:42 <lambdabot>  5050
17:17:45 <lispy> hmm..
17:17:48 <glguy> lispy: no, that's also the sum of the digits of 100 factorial
17:17:50 <lispy> or i misread it :)
17:18:01 <lispy> oh yeah it is
17:18:03 <lispy> my bad
17:18:20 <lispy> i think i would have use a foldl1 but i guess sum is doing that
17:18:32 <glguy> sum = foldl' (+) 0
17:18:33 <lambda_the_insig> Cale: thanks for clarifying.
17:18:43 <lambda_the_insig> MonadUndo looks particularly interesting...
17:19:51 <glguy> > (sum . map (read . (:[])) . show . product . enumFromTo 1) 100
17:19:52 <lambdabot>  648
17:25:24 <lispy> glguy: and if you're golfing, a lot of that whitespace non-necessary
17:25:44 <glguy> sigh
17:25:57 <lispy> > (sum.map(read.(:[])).show.product.enumFromTo 1)100
17:25:58 <lambdabot>  648
17:26:38 <glguy> > sum $ map(read.(:[]))$ show $ product $ [1..100]
17:26:39 <lambdabot>  648
17:27:07 <glguy> why does it let you do sum.map over sum . map?
17:27:13 <glguy> because sum is lowercase?
17:27:44 <glguy> > (id.id)1
17:27:45 <lambdabot>  1
17:27:47 <heatsink> yea, it can't be a module lookup
17:27:55 <glguy> > id$id 1
17:27:56 <lambdabot>    Expecting a function type, but found `Q Exp'
17:27:56 <lambdabot>    Expected type: ExpQ
17:27:56 <lambdabot>  ...
17:28:13 <SamB> maybe you meant
17:28:21 <SamB> > id $ id 1
17:28:22 <lambdabot>  1
17:28:26 * heatsink thought splices required parentheses
17:28:46 <SamB> heatsink: not if you are just splicing a single variable, no
17:28:52 <heatsink> > [| 3 + 5 |]
17:28:52 <lambdabot>  Parse error
17:29:02 <glguy> SamB: nope, I was trying to see if $ acted like .
17:29:02 <SamB> see, lambdabot has a parser too
17:29:16 <SamB> but it doesn't know about TH
17:29:51 <SamB> so it parses about the same as id$id 1 is the same as id $ id 1
17:29:59 <SamB> eh...
17:30:01 <cm> nn
17:30:04 <SamB> I messed that up
17:30:14 <SamB> badly!
17:30:18 <glguy> don't worry, i know how it works
17:30:32 <SamB> $ would if -fth wasn't on
17:30:44 <heatsink> so it parses about the same as intersperse (is the same as) $ repeat (id $ id 1)
17:30:48 <glguy> -fth?
17:31:11 <glguy> oh, feature template haskell
17:31:53 <SamB> whatever -f stands for
18:00:17 <syntaxfree> Is there a numeric type that is restricted between zero and one?
18:01:16 <SamB> I'm not aware of a Word1, no...
18:01:30 <SamB> it is easy enough to write, though, I think ;-)
18:01:48 <dons> instance Num Bool where ?
18:01:57 <dons> > fromEnum True
18:01:58 <lambdabot>  1
18:02:01 <dons> > fromEnum False
18:02:02 <lambdabot>  0
18:02:22 <Pseudonym> Isomorphic to GF(2), surely.
18:02:24 <syntaxfree> No, no. I want an arbitrary real between 0 and 1.
18:02:32 <SamB> oh, between...
18:02:40 <syntaxfree> I could do Data Num01 = Int a
18:02:45 <syntaxfree> and then toReal = 1/(1+a)
18:02:54 <syntaxfree> but I wondered if there was a built in.
18:03:00 <dons> no, nothing built in
18:03:04 <lispy> dons: did you have any ideas wrt the email i sent?
18:03:04 <dons> interesting idea though
18:03:22 <dons> lispy: just woke up. no caffeine yet... gimme 10 mins
18:03:26 <syntaxfree> dons: my econometrics training is finally of some use to Haskell ;)
18:03:30 * syntaxfree is kind of drunk today.
18:03:31 <lispy> dons: hehe, take your time :)
18:03:36 <stepcut> dons: I wrote a jabber backend for lambdabot ... again. This time it only depends on HaXml (though, it requires the unstable devel version)
18:03:48 <dons> stepcut: oh, sounds good!
18:03:51 <lispy> stepcut: cool!
18:03:56 <lispy> @karam+ stepcut
18:03:57 <lambdabot> Maybe you meant: karma karma+
18:04:03 <lispy> @karma+ stepcut
18:04:03 <lambdabot> stepcut's karma raised to 2.
18:04:07 <dons> stepcut: oh, btw, i've had about 5 people ask for a ByteString Parsec
18:04:08 <stepcut> dons: I need to clean it up a bit, but I should have something releasable in a few days
18:04:13 <dons> do you guys have one, over there ?
18:04:26 <dcoutts> stepcut, oh, that'd be cool
18:04:26 <lispy> i could use a bytestring haxml
18:04:27 <dons> stepcut: cool, great work
18:04:51 <lispy> hmm...does a pretty printer based on bytestring exist?
18:04:55 <lispy> that would be nice too
18:05:11 <stepcut> I don't have something as nice as Parsec, but I have something similar, I will send that to you
18:06:31 <syntaxfree> 1/(1+exp(-x)) is a better trnasofrm.
18:06:39 <dons> lispy: hmm, Data/ByteString/Base.hs:302:28:
18:06:40 <dons>    Not in scope: `finalizeForeignPtr'
18:06:42 <dons> eh?
18:06:45 <lispy> if bytestring was a drop in replacement for [Char] that would be ideal of course
18:06:51 <lispy> dons: yeah
18:07:10 <lispy> dons: i checked the haddock generated for visual haskell and it's not listed...which is so odd
18:07:22 <lispy> dons: i think they removed it but I can't think why
18:07:24 <SamB> but the non-abstractness of [Char] makes that difficult
18:07:29 <dons> lispy: weird.
18:07:54 <lispy> dons: okay, so it's not something you know anything about?
18:08:00 <lispy> visual haskell has so many oddities
18:08:11 <lispy> but i don't really want to install a "normal" ghc on this machine right now
18:08:22 <lispy> i have everything setup in visual haskell so i can dev with it
18:08:25 <syntaxfree> I never managed to build lambdabot for various reasons.
18:08:40 <dons> lispy: I have no idea why that function would be missing
18:08:48 <syntaxfree> I got Cabal, I got hs-plugins, but lambdabot just failed no matter how much advice from the channel I took.
18:09:15 <dons> probably the tide was too low
18:09:20 <dons> you should try again at high tide
18:09:26 <lispy> :)
18:09:36 <lispy> that probably goes for me as well
18:10:54 <syntaxfree> well, the relevant information nugget is that I'm at an OS X box.
18:14:19 <lispy> oh, well i think hs-plugins was broken there until recently
18:14:27 <lispy> iirc, dons said he fixed a bug with it this weekd
18:17:37 <benja_> hm, anyone know a channel where people who know about logic hang out? :-)
18:17:57 <Korollary> #math, here. perhaps #scheme
18:18:00 <lispy> benja_: here and #math are the first to places i would look
18:18:07 <xerox> #prolog too
18:18:08 <lispy> is there a #prolog channel?
18:18:20 <xerox> Our ski is one proud member of it
18:18:31 <lispy> benja_: and stay away from #gentoo ;)
18:18:39 <lispy> or #java...
18:18:42 <lispy> ;)
18:18:52 * heatsink chuckles.
18:19:00 <benja_> ok, I'll try here first then. :-) I'm wondering whether there's a name for the inference rule that lets you infer (p --> q) from q
18:19:40 <swiert> benja_: weakening?
18:19:50 <benja_> I would have thought conditional introduction, since disjunction introduction lets you infer (p \/ q) from p, but conditional introduction let's you infer (p --> q) from proving q assuming p, apparently
18:21:28 <benja_> swiert: hm, the wikipedia page says that weakening allows one to conclude Gamma, A |- C from Gamma |- C
18:21:33 <benja_> related, but not quite =)
18:24:20 * benja_ tries #math
18:25:40 <xerox> Goodnight.
18:25:56 <wolverian> any suggestions how to add state to a series of cairo drawing stuff? I haven't used state monads before.
18:26:12 <dcoutts> g'night xerox
18:26:40 <dcoutts> wolverian, well the simplest obviously is to just pass arguments to functions
18:27:14 <wolverian> that is so ugly I can't live with it. at certain points I need to save the point I am at and restore it later.
18:27:16 <dcoutts> if you're using the same kind of argument for every/most functions and it's annoying then consider looking into a state monad
18:27:28 <dcoutts> like the state transformer
18:27:32 <wolverian> right.. do I need StateT, since the drawing happens in a Render monad?
18:27:41 <dcoutts> which allows you to layer state on the underlying Render
18:27:42 <SamB> or reader
18:27:42 <dcoutts> yes
18:28:29 <dcoutts> yes, or reader, depending on what fits your needs
18:28:35 <wolverian> I thought Reader is a read-only environment
18:29:20 <dcoutts> but of course then you have to lift the render actions into your new monad.
18:29:45 <wolverian> oh, Render allows localising the environment.
18:29:58 <wolverian> dcoutts, and with StateT I wouldn't?
18:30:23 <SamB> both ReaderT and StateT would require that
18:30:56 <dcoutts> yep, they have a lift method to lift an action in the lower monad to the one above
18:30:56 <wolverian> okay. StateT is more suitable here. now to figure out how to use it :-)
18:31:21 <dcoutts> I think there's an intro/tutorial somewhere on how to use monad transfomers
18:31:40 <dcoutts> actually Render is itself a transformer on something else
18:31:44 <dcoutts> err
18:31:48 <wolverian> google gave http://haskell.org/hawiki/MonadState
18:31:52 <lambdabot> Title: You have exceeded your Internet quota
18:32:00 <wolverian> nice title!
18:32:03 <dcoutts> is implemented as a ReaderT IO or something like that
18:32:06 <SamB> okay...
18:32:09 <wolverian> is that a problem?
18:32:13 <SamB> what is going on here?
18:32:15 <dcoutts> no, not at all
18:32:28 <SamB> "You have exceeded your internet quota"?
18:32:35 <dcoutts> oh dear
18:32:51 <dcoutts> it's either bad or spam (which is bad)
18:33:04 <SamB> does someone need to buy haskell.org more internet?
18:33:36 <dcoutts> where do you see that?
18:33:43 <SamB> <wolverian> google gave http://haskell.org/hawiki/MonadState
18:33:43 <SamB> <lambdabot> Title: You have exceeded your Internet quota
18:33:44 <lambdabot> Title: You have exceeded your Internet quota
18:33:52 <dons> oh crap
18:34:00 <benja_> http://google.com/
18:34:00 <lambdabot> Title: You have exceeded your Internet quota
18:34:03 <wolverian> hrm, so I need to lift all the functions of the inner monad to my monad? that is kind of ugly :\
18:34:10 <dons> sigh
18:34:12 <benja_> SamB: not haskell.org :)
18:34:15 <SamB> oh, so *lambdabot* needs more internet?
18:34:35 <dons> :(
18:34:50 <dcoutts> dons, problem?
18:34:55 <SamB> well, at least lambdabot still works for IRC connectivity
18:35:19 <dons> i share this machine with another guy. now i just have to work out how the quote went over
18:35:23 <SamB> dcoutts: if you think getting a title of "You have exceeded your Internet quota" every time it does a GET a problem, yes...
18:35:33 <dcoutts> mm
18:35:41 <SamB> insert an "is" somewhere
18:36:19 <wolverian> hrm, since I'm in the io monad already (kind of, I guess), would an ioref work too?
18:36:42 <SamB> you'd need to liftIO
18:36:44 <SamB> if that works
18:36:47 <dcoutts> wolverian, yes but every use of that needs to be lifted into the Render monad
18:36:55 <dcoutts> indeed, using liftIO
18:37:24 <dcoutts> wolverian, but then you'd still need to pass the IORef about
18:37:27 <benja_> 'if you think getting a title of "You have exceeded your Internet quisota" every time it does a GET a problem, yes...'
18:37:33 <benja_> hmm, perhaps in a different place
18:38:05 <SamB> how about right after GET?
18:38:31 <wolverian> hm, thanks. I don't get yet how StateT works (or, how the lifting works), but I'll get there.
18:38:46 <SamB> wolverian: just so long as it does ;-)
18:39:12 <wolverian> well, it doesn't, yet..
18:39:51 <Kahdloc> why's it called filter and not grep?
18:39:54 <Kahdloc> :/
18:40:49 <dons> heh
18:40:54 <SamB> because this is Haskell and not Perl?
18:41:08 <SamB> that, and it doesn't take regular expressions
18:41:09 <dons> prehaps grep is a slightly bizarre name for a filter :: (a -> Bool) -> [a] -> [a] function
18:41:12 <dons> its grepish, but not grep
18:41:19 <dons> and grep is meaningless to lots of people
18:42:12 <syntaxfree> ?remember Kahdloc why's it called filter and not grep? :/
18:42:12 <lambdabot> Done.
18:42:34 <wolverian> oh, now I think I get it. I was wondering how to transform the monad into the result. evalStateT
18:43:58 <SamB> or runStateT
18:44:09 <SamB> theres a third one, too
18:44:25 <SamB> execStateT?
18:45:41 <syntaxfree> the State monad basically stores state variables between calls, right?
18:46:05 <SamB> "between calls"?
18:46:10 <SamB> what is this "between calls"?
18:46:27 <SamB> are you implying that there is time between calls?
18:46:36 <heatsink> Hmm... how come the stage 2 compiler gives me the message "Template Haskell bracket illegal in a stage-1 compiler"?
18:46:39 * syntaxfree ducks.
18:46:43 <SamB> ... or that there is even time?
18:46:58 <wolverian> hm, now I get: No instance for (MonadState (Double, Double) Render) .. am I lifting the wrong function?
18:46:59 <SamB> heatsink: because it is broken?
18:47:17 <SamB> probably
18:47:23 <heatsink> drat
18:47:27 <wolverian> mm.
18:47:27 <wolverian> thanks
18:48:05 <wolverian> does lift sequence make sense?
18:50:22 <SamB> lift sequence?
18:50:33 <SamB> you'd have to do lift (sequence arg)
18:50:48 <SamB> or sequence (lift arg)
18:50:51 <wolverian> right. I meant to ask whether I can lift a sequence of actions in the inner monad
18:51:13 <SamB> oh, you mean like lift (do action1; action2)
18:51:15 <wolverian> or do I need to lift each action separately in the functions they happen in
18:51:26 <SamB> ?
18:51:47 <syntaxfree> "The binding operation for lists creates a new list containing the results of applying the function to all of the values in the original list"
18:51:50 <syntaxfree> bind =  map?
18:52:03 <SamB> concatMap
18:52:08 <SamB> flipped
18:52:10 <wolverian> something like: lift $ sequence [moveTo.., lineTo ...];
18:52:38 <wolverian> (moveTo are actions in the Render monad)
18:52:50 <wolverian> I'm too tired when I drop words randomly
18:53:05 <SamB> wolverian: wouldn't it be simpler to just say lift $ (do moveTo ..; lineTo ...)
18:53:16 <wolverian> well, that was also a simplification, sorry
18:53:22 <wolverian> the actual actions and their order is determined at runtime
18:53:39 <wolverian> (I suck at explaining, obviously. sorry again)
18:54:48 <wolverian> lift $ sequence_ $ mapMaybe (flip lookup (draw system)) string
18:54:55 <wolverian> is the actual line, I suppose
18:55:19 <wolverian> I'm mapping Chars to actions
18:57:21 <wolverian> oh, I guess that won't work.
18:58:54 <SamB> why don't you just lift in the individual functions in the table?
18:59:06 <wolverian> because it's ugly. but, yeah, doing that now :)
18:59:34 <wolverian> I'm very new to this monad stuff. I'm sorry if I'm being obtuse.
18:59:36 <SamB> assuming one or more of the functions in the table needs to use the StateT
18:59:45 <wolverian> yeah.
18:59:47 <notsmack> hey guys, I'm new to haskell and tried to tackle the ICFP's UM.  It handles the self tests, but with either compressed program i quickly consume a gig of memory once it starts loading...
19:00:03 <SamB> notsmack: use UArrays instead of Arrays
19:00:14 <SamB> or IOUArrays instead of IOArrays
19:00:27 * notsmack was just using Lists
19:00:36 <SamB> but fair warning: its probably going to be too slow
19:00:41 <SamB> even if you use IOUArrays
19:00:59 <SamB> ... even if you use C ;-)
19:01:23 <notsmack> i'm fine with slow, i'll look into the types you mention
19:03:25 <wolverian> yay, it works! thankyou, SamB
19:03:29 <wolverian> @karma+ SamB
19:03:30 <lambdabot> SamB's karma raised to 10.
19:07:34 <lispy> notsmack: you may need to add strictness
19:08:00 <lispy> notsmack: all the array basedimplementations i looked at evaluated the values before stuffing them into arrays
19:08:31 <notsmack> hmm
19:09:00 <SamB> notsmack: if you use a UArray (or IOUArray) you need not worry about that
19:09:12 <SamB> because those are strict anyway
19:09:46 <notsmack> SamB: thanks, that's what i thought
19:12:32 <notsmack> so, I naively implemented this function:  setVal i v a = (take i a) ++ [v] ++ (drop (i+1) a)
19:13:00 <notsmack> is IOArray basically a monadic layer to accomplish the same thing?
19:13:01 <edwardk> Hrmm what would be the Comonad equivalent of Applicative? I keep playing with it, but not quite getting it
19:13:47 <wolverian> SamB, http://chronoa.dy.fi/~wolverian/pics/lsys.png this is what I'm doing, by the way. took me ages to get this far :)
19:14:58 <edwardk> wolverian: i probably have some old l-system code lying around in a 3d engine somewhere for generating trees, etc if you want it i'll see what i can dig up
19:15:17 <dons> ?url-off
19:15:17 <lambdabot> Url disabled
19:15:51 <SamB> wolverian: ah, LSystems
19:15:55 <SamB> I suspected as much!
19:15:57 <edwardk> though I tailored it pretty heavily to the 3d case, and to generating image based projections of the trees for compositional rendering, so maybe it wouldn't be a great start =)
19:16:05 <wolverian> SamB, ;)
19:16:24 * SamB goes to look at the picture
19:16:55 <wolverian> edwardk, nah, I think I'll learn this on my own.. it's more fun that way... (cough)
19:17:00 <wolverian> edwardk, pics are welcome though :)
19:17:01 <edwardk> L-systems themselves are always so painfully regular, unless you break them up with some other processes.
19:17:11 <edwardk> wolverian: heh, lemme see what i can do =)
19:17:46 <lispy> wolverian: i like it it
19:17:51 <lispy> that's pretty
19:18:09 <wolverian> lispy, thanks :) it's a very simple system. cairo makes drawing so easy.
19:18:19 <syntaxfree> wait, wait, wait. If I say Data ThisType = (Int a, String b), if ThisType a type constructor?
19:18:39 <lispy> syntaxfree: you can't to that, afaik
19:18:46 <dcoutts> wolverian, looks nice
19:19:12 <wolverian> it _is_ pretty regular though..
19:19:19 <wolverian> I'll have to see how to add some drift to the model
19:19:26 <syntaxfree> ok,  if I say
19:19:35 <dcoutts> wolverian, I'll be teaching a Haskell course in a couple months using L-Systems as a practical
19:19:47 <lispy> dcoutts: your classes sound fun
19:20:00 <dcoutts> one optional extension the students can do is to add a bit of randomeness
19:20:02 <lispy> dcoutts: (i was reading haskell-cafe and saw your post about practicals)
19:20:02 <syntaxfree> L-Systems are the cool.
19:20:03 <wolverian> dcoutts, that's nice. are you doing StateT? :)
19:20:06 <dcoutts> to make the treels less regular
19:20:20 <dcoutts> lispy, oh yeah. :-) It is fun.
19:20:36 <dcoutts> wolverian, heh, no.
19:20:58 <dcoutts> wolverian, this practical is for people who have only ever been programning for 5 weeks.
19:21:01 <wolverian> I suppose I can simply add a drift parameter to the system type, which would get evaluated on each iteration. most open solution, I think.
19:21:01 <dcoutts> no monads
19:21:18 <wolverian> dcoutts, ah. that won't get you trees, then..
19:21:22 <dcoutts> just a few recursive list processing functions
19:21:27 <dcoutts> well actually...
19:22:03 <dcoutts> all you're doing is running an L-System, that is generating a list of drawing commands
19:22:09 <wolverian> right
19:22:27 <wolverian> however, I needed StateT for the branching commands
19:22:33 <syntaxfree> dcoutts: using OpenGL?
19:22:33 <dcoutts> then all you're doing with those commands is turning them into a list of lines with absolute coordinates
19:22:34 <wolverian> (well, s/needed/used/.)
19:22:47 <dcoutts> syntaxfree, that's another optional extension, 3D
19:22:54 <dcoutts> we start with 2D
19:22:59 <dcoutts> GUI with Gtk2Hs
19:23:04 <syntaxfree> well, are you actually plotting the L-Systems?
19:23:08 <dcoutts> yes
19:23:18 <syntaxfree> ah, with Gtk2Hs.
19:23:21 <edwardk> heh found a couple of old projects i'd forgotten i had =)
19:23:28 <dcoutts> but that's trivial as it's just a list of lines
19:23:35 <syntaxfree> You could do 2D stuff with OpenGL.
19:23:36 <wolverian> is there another way to do the branching, without using a state? I'm trying to think how, but it's imploding my head
19:23:53 <dcoutts> sadly we can't use cairo with our aged Solaris boxes
19:24:37 <dons> ?users
19:24:38 <lambdabot> Maximum users seen in #haskell: 235, currently: 191
19:24:39 <syntaxfree> Cairo?
19:24:52 <edwardk> http://slipwave.info/old3djunk/ has some old beer's law integrated light through fog in realtime shots from the pentium 200 era if you are looking for weird rendering tricks =)
19:25:05 <wolverian> syntaxfree, a vector drawing library, gtk2hs supports it. very nice.
19:25:08 <wolverian> (it's what I'm using.)
19:25:09 <dcoutts> syntaxfree, the cool 2D vector grapics system
19:25:16 <syntaxfree> ?users should return (current users / maxium seen)
19:25:17 <lambdabot> Maximum users seen in #haskell: 235, currently: 191
19:25:24 <syntaxfree> @google cairo
19:25:30 <lambdabot> http://ce.eng.usf.edu/pharos/cairo/
19:25:30 <lambdabot> Title: Cairo, Egypt
19:25:39 <edwardk> moving on to other flash drives
19:25:44 <wolverian> edwardk, whoa, nice :)
19:25:51 <wolverian> @google cairo graphics
19:25:53 <lambdabot> http://cairographics.org/
19:25:54 <lambdabot> Title: cairo - introduction
19:25:55 <dcoutts> wolverian, two ways, either use the random split feature, or pass an infinite list of randoms about
19:26:14 <syntaxfree> oh. I wish GNU R used it.
19:26:24 <syntaxfree> R's Quartz library is sad.
19:26:38 <dcoutts> wolverian, passing it about means either partitioning the list when you branch, or passing the unused ones back
19:26:41 <edwardk> the cam2.zip thing is an isometric volumetric rendering engine. can be used for rendering arbitrarily complex models by mapping them onto voxels first
19:27:33 <notsmack> http://www.ggobi.org/rgtk2/
19:27:34 <edwardk> checking the next computer =)
19:27:38 <wolverian> dcoutts, hrm, I'm not sure I understand how you return from a branch then to the original position
19:28:19 <edwardk> push/pop
19:28:20 <dcoutts> wolverian, try using a stack
19:28:38 <wolverian> but isn't that state? :) I mean.. okay.. you can pass it around
19:28:57 <dcoutts> it's just another parameter to a recursive function
19:29:03 <dcoutts> so it's totally pure
19:29:05 <wolverian> yeah
19:30:28 <dcoutts> then since it's just a simple recursion there's no problem with spliting the random number supply
19:30:58 <wolverian> my recursion is kind of meshed with the cairo functions
19:31:07 <wolverian> or rather, I don't recurse at all
19:31:11 <dcoutts> seperate :-)
19:31:17 <dcoutts> it gives more elegant code
19:31:31 <wolverian> hrm.. yeah
19:31:43 <wolverian> I suppose I could get rid of StateT that way, too
19:31:48 <dcoutts> for the practical I run they have no option but to keep it seperate
19:32:05 <dcoutts> since we give them a GUI module which expects jsut a list of lines
19:32:29 <dcoutts> so they can't intermingle generation with rendering
19:32:39 <dcoutts> and that is a "Good Thing"tm
19:32:57 <dcoutts> http://www.haskell.org/gtk2hs/gallery/Cairo-demo/Cairo_demo_13
19:33:20 <wolverian> mm.. that means changing these functions here to types.. and working on a list of those.. thanks, I think this will make things much nicer
19:33:20 <dcoutts> that's xerox's LSystem version when he was testing the cairo bindings.
19:33:54 <edwardk> gah its on whats left of the server in the basement. i need to get some replacement cords, my cats chewed through the monitor cable, power and keyboard for it =)
19:34:05 <edwardk> so i guess i'll dig it up later
19:34:18 <wolverian> :)
19:34:43 <edwardk> good to know thats my only copy of that stuff though
19:35:01 <edwardk> considering i was about to junk the machine ;)
19:43:29 <notsmack> so, to move from lists to (for example) IOUArrays, i guess i should ditch my whole purely recursive machinestate-modification for monads?
19:44:05 <SamB> you don't really have much choice, now do you?
19:44:41 <notsmack> SamB: I didn't think so, I'm just bumbling through this slowly...
19:46:19 <SamB> personally, I would suggest that this program is a bad choice for writing in Haskell, except for the fact that my C UM had some obscure troubles that my Haskell one never did...
19:46:44 <notsmack> SamB: certainly agreed, that's one of the reasons i like it
19:47:05 <dons> its a hard haskell problem, though
19:47:16 <SamB> yeah, my Haskell one took me a lot longer
19:47:21 <dons> .. though no one's tried writing it in Bulat's stream/low-level imperative lib
19:47:25 <SamB> and was much longer
19:47:29 <dons> with its mutable variable syntax and so on
19:47:46 <dons> Cale, around?
19:48:03 <semi_> SamB: which languages you wrote it in?
19:48:22 <SamB> semi_: I wrote a UM in Haskell and one in C
19:48:33 <SamB> both can be found on dons's page
19:48:33 <dons> semi_: have you see the UM shootout page?
19:48:41 <SamB> @google UM dons
19:48:41 <dons> ?google dons UM rankings
19:48:43 <lambdabot> http://www.cse.unsw.edu.au/~dons/um.html
19:48:43 <lambdabot> Title: Haskell UM
19:48:45 <lambdabot> http://thestar.com.my/news/story.asp?file=/2006/3/30/nation/13813040&sec=nation
19:48:46 <lambdabot> Title: UM dons speak up for VC
19:48:49 <SamB> hmm
19:48:56 <semi_> i just briefly looked at the task description
19:48:57 * dons wins
19:49:00 <SamB> hehe
19:49:17 <SamB> usually I mention Haskell or something
19:49:20 <dons> SamB: the net quota is working again, but its slowed to dial up speeds till i sort this mess out
19:49:40 <dons> (my quota got consumed by a visitor using one of my boxes :/)
19:49:40 <Cale> dons: hello
19:49:54 <SamB> dons: that should be adequate for getting titles from web pages, I think
19:50:21 <SamB> ... especially if you don't have to read the whole page to get the title
19:50:24 <dons> Cale, yeah, regarding this quota stuff. i'm over my net quota, however, I can't make new non-http connections. So if lambdabot disconnects, she won't be able to get back on, till I resolve this issue
19:50:33 <dons> Cale, so perhaps have an mbot ready..
19:50:40 <dons> it may take a couple of days to fix this problem
19:50:43 <Cale> okay
19:50:51 <dons> SamB: right, it only reads the first 512 bytes, iirc
19:52:27 <dons> one good thing about using master/slave ssh connections: you don't get blocked from reconnecting (since the system doesn't see any new logins)
19:52:50 <SamB> what are those?
19:53:28 <dons> oh, ssh can be set up to reuse existing connections, rather than reauthenticating and creating a new channel
19:54:32 <dons> much faster to log into remote hosts that way
19:54:32 <dons> but also, to the remote host, it looks like you only logged in once
19:54:32 <dons> so if your *cough* silly admins start blocking new ssh connections due to quota issues, you can get around that by reusing old ones ;)
19:59:13 <notsmack> dons: i'll have to try that, might be more convenient than nesting GNU screens
19:59:51 <dons> its really really useful. e.g. I could push darcs patches over reused connections long before darcs supported that natively
20:00:44 <dons> == faster, no more passwords to type
20:00:59 <notsmack> yep
20:04:17 <dons> some of these new System Fc patches are really fun sounding. e.g. Indexed type decls
20:05:04 <dons> and stuff about type families. very intriguing
20:05:49 <SamB> why are you coughing?
20:06:14 <dons> a cold i've got. luckily winter is almost over
20:06:22 <Tela> If I have defined a data constructor, is there a way to add a new type constructor syntax so that both the original and the new function at the same time in the same way?
20:06:55 <dons> hmm. function at the same time in the same way?
20:07:05 <Tela> Sort of a type constructor synonym
20:07:06 <dons> more details...
20:07:20 <Tela> Ok. For practice I made a tree data constructor
20:07:22 <SamB> type Foo = Bar?
20:07:38 <Tela> But I don't like the syntax I had written in originally anymore
20:07:44 <dons> yeah, just a normal synonym?
20:07:56 <Tela> I suppose?
20:07:58 <Tela> heh heh
20:08:02 <dons> say, type a :.~.~.: b = Oldtype a b
20:08:14 <dons> then you can use the funky type
20:08:34 <Lemmih> That's only for types, though.
20:08:45 <Tela> Nifty... I'm so unused to pattern matching, it keeps astounding me
20:08:57 <SamB> Lemmih: well, it is what he said, if not what he meant...
20:09:30 <Cale> dons: btw, you have admin permissions on mbot :)
20:10:00 <dons> cheers
20:11:03 <dons> hands up if you knew we could declare fixities for type constructors and classes?
20:11:03 <dons> and that back quotes work on the type level now?
20:11:09 <dons> ?kind Int `Either` Bool -- let's see...
20:11:11 <lambdabot> *
20:11:13 <dons> yay
20:12:04 <dons> and tyvars can be symvars, type T (+) = Int + Int
20:12:20 <dons> seems like we're not taking full advantage of this yet ;)
20:13:54 <SamB> dons: how do you specify that you want to declare a fixity for a *type* constructor?
20:17:20 <dons> infixl 7 T, :*:
20:17:30 <dons> sets the fixity for both type constructor T and data constructor T, and similarly for :*:
20:17:46 <SamB> what, they have to be the SAME?
20:17:59 <dons> how can you distinguish it?
20:18:21 <SamB> well, I was thinking infix{l,r,}t
20:18:55 <dons> a kind/type annotation, perhaps...
20:18:55 <dons> submit a patch!
20:18:55 <dons> infixl 7 (T : *)
20:18:55 <dons> infixl 7 (T :: T)
20:18:56 <dons> perhaps
20:18:58 <dons> :}
20:19:02 <dons> oh, but we use :: for kinds, too.
20:20:08 <glguy> LOL @ Bulgaria... news was reporting how the state department had to bargain with their government to fly through Bulgarian air-space. Bulgaria wanted 6 Chrysler mini-vans :-D
20:20:29 <SamB> dons: eh, yeah, GADTs throw wrench in that don't they?
20:20:37 <dons> oh, we have a new http://haskell.org/haskellwiki/Category:Tutorials space on the wiki
20:20:52 <SamB> or don't we have named kinds?
20:20:53 <dons> we should move more tutorials under that
20:20:54 * SamB forgets
20:21:00 <dons> we have * and #
20:21:05 * SamB is confused about what language has named kinds
20:21:12 <dons> Twelf?
20:21:20 <SamB> not that one...
20:21:28 <SamB> so, I guess maybe it would work ;-)
20:21:32 * dons thinks haskell looks more like twelf all the time
20:21:58 <dons> what with these new family things, and index types
20:22:04 <SamB> family things?
20:22:06 <SamB> index types?
20:23:22 <edwardk> dons: is that really such a bad thing though?
20:23:32 <dons> I don't say its bad :)
20:23:36 <dons> i like twelf :)
20:28:01 <LordBrain> @where twelf
20:28:02 <lambdabot> I know nothing about twelf.
20:28:10 <dons> ?google twelf
20:28:13 <lambdabot> http://www.cs.cmu.edu/~twelf/
20:28:13 <lambdabot> Title: The Twelf Project
20:28:16 <dons> ?where+ twelf http://www.cs.cmu.edu/~twelf/
20:28:17 <lambdabot> Done.
20:28:32 <dons> I notice Oleg's been hanging out on the twelf list of late
20:29:05 <edwardk> he's been on a dependant types kick it seems from his paper writing, so i guess it makes sense
20:29:40 <dons> yeah
20:30:56 <edwardk> don't you hate revisting a machine you used 4-5 years ago and not remembering what half the applications are? =)
20:31:04 <dons> there's a GHC Core in Twelf, here, http://www.cse.unsw.edu.au/~sjw/non-cvs/code/coreLF.tar.gz
20:31:19 <dons> for those into formal thingamies
20:31:39 <SamB> I would like to be off of this machine in 4-5 years ;-)
20:32:29 <LordBrain> hehe
20:32:39 <edwardk> btw- been playing with comonads more. i don't know if its so much that they are useless as we are using them over the 'wrong' category for them to be cool. if you have a linear type system it appears that you can use a comonad and a minimal amount of support to model unrestricted types in it.
20:33:32 <edwardk> a little light bulb went on about that this afternoon
20:34:31 <edwardk> since extract is basically a form of weakening and duplicate gives a form of contraction.
20:34:53 <edwardk> thats why i was sking if anyone had a thought as to what the comonadic equivalent of Applicative would be
20:35:09 <edwardk> since it would appear to approach one of the other substructural types (linear/affine) just not sure which
20:35:14 <edwardk> er relevant/affine
20:35:50 <edwardk> ... and nobody cares, so i'll shut up and return to muttering to myself =)
20:36:18 <glguy> I'd care if I knew what a Comonad was
20:36:22 <dons> but you want to climb the irc output rankings, no?
20:36:29 <edwardk> this is very true
20:36:37 <glguy> by the name I can guess that it's the dual of a monad
20:36:42 <glguy> but I don't know what that actually means
20:37:24 <edwardk> Well, monads have their roots in category theory. a Comonad is like a backwards Monad. =)
20:37:34 <edwardk> categorical dual and all that
20:38:06 <edwardk> so instead of return you have a 'coreturn' usually called extract that takes an extract :: Comonad w => w a -> a
20:38:09 <glguy> so instead of returning a value into a monad... you extract it out
20:38:14 <glguy> and instead of binding...
20:38:24 <glguy> you "duplicate" as you said?
20:38:25 <edwardk> you use it to chain backwards dependencies
20:38:35 <edwardk> yeah, easy to duplicate
20:38:51 <edwardk> duplicate :: w a -> w (w a)
20:38:57 <edwardk> think 'splittable'
20:39:17 <edwardk> like the linear implicit params use
20:39:25 <glguy> and I'm out
20:39:32 <edwardk> heh
20:39:57 <edwardk> well, the basic problem is there are only so many problems that a comonad models that we can get our head around easily =)
20:40:07 <glguy> that's very true
20:40:19 <glguy> zero come to mind so far ;)
20:40:26 <edwardk> heh
20:40:30 <glguy> would it help to understand these substructural types
20:40:32 <edwardk> well. (,) is a comonad
20:40:36 <edwardk> er
20:40:37 <glguy> that you are always mumbling about?
20:40:42 <glguy> (,) is a constructor
20:41:00 <glguy> and reminds me a lot of return...
20:41:13 <edwardk> well, you can construct a (,)a comonad that is adjoint to the (->)a Control.Monad.Reader monad
20:41:52 <edwardk> and any pair of adjoint functors give rise to a monad and a corresponding comonad.
20:42:04 <edwardk> so they serve as a descent starting point to look for comonads
20:42:50 <edwardk> Identity is both a comonad and a monad.
20:43:14 <edwardk> there is a Context comonad that is similar in spirit to a State monad.
20:44:39 <edwardk> but basically if you had a restricted pre-monadic type for applicative variables that only had return and ap, then there should be a dual notion involving extract and a form of 'co-ap' =)
20:44:50 <edwardk> er applicative types
20:45:11 <edwardk> applicative is nice coz its closed under composition
20:45:13 <edwardk> unlike monads
20:45:45 <glguy> hmm
20:46:00 <edwardk> and 'coapplicative' should share the same property
20:46:32 <glguy> I swear I'm not totally oblivious, I'm just having a hard time "visualizing" this
20:46:33 <edwardk> and be a little less structured than a comonad, so there should be more useful coapplicative types than there are comonads.
20:48:18 <edwardk> and don't worry i think all of us are pretty oblivious in this area.
20:49:16 <glguy> In my defense, mathschallenge says I'm 56% genius ;)
20:49:21 <edwardk> heh
20:49:55 <lispy> mathschallenge?
20:50:00 <glguy> which makes me the 6th best haskell user on the site ;)
20:50:01 <lispy> sounds like a fun puzzle sight
20:50:04 <lispy> er site
20:50:05 <glguy> http://mathschallenge.net
20:50:06 <edwardk> heh
20:50:09 <glguy> Project Euler
20:50:59 <glguy> I'm trying to solve the puzzles in J also
20:51:21 <glguy> but so far the problems have been rediculously easy in J, or I haven't known enough of the primitives to do it
20:52:16 <dons> how hard are the problems? how long do they take to solve?
20:52:35 <dons> oh, several hours?
20:52:51 <glguy> A reasonable algorithm implemented in Visual Basic should take no more than 1 minute to run
20:53:31 <dons> ah, some of them seem quite tricky, some seem easy
20:53:57 <glguy> yeah, "Find the 10001th prime number" is just    p:10000
20:54:46 <SamB> huh
20:55:03 <glguy> that's J for "return the 10001th prime number"
20:55:06 <edwardk> heh
20:55:08 <dons> > sum [ x | x <- [1..999], x `mod` 3 == 0 || x `mod` 5 == 0 ]
20:55:09 <lambdabot>  233168
20:55:18 <edwardk> yeah a lot of these sorts of things are 1 liners in mathematica
20:56:02 <glguy> dons: sum $ nubs $ [0,5..999] ++ [0,3..999]
20:56:04 <glguy> :)
20:56:50 <SamB> glguy: is that more efficient?
20:57:01 <glguy> or: sum [5,10..999] + sum [3,6..999] - sum [15,30..999]
20:57:12 <glguy> SamB: doesn't really matter , it runs instantly :)
20:57:13 <edwardk> heh
20:57:17 <dons> > takeWhile (< 1000000) [ x | x <- fix $ \f -> 1 : 1 : zipWith (+) f (tail f), x `mod` 2 == 0 ]
20:57:18 <lambdabot>  [2,8,34,144,610,2584,10946,46368,196418,832040]
20:57:39 <glguy> I've already entered the answers, just log in and enter your won
20:57:39 <glguy> own
20:57:43 <dons> > sum $ takeWhile (< 1000000) [ x | x <- fix $ \f -> 1 : 1 : zipWith (+) f (tail f), x `mod` 2 == 0 ]
20:57:43 <glguy> and then say you used Haskell
20:57:44 <lambdabot>  1089154
20:57:52 <dons> just seeing how hard they are :)
20:58:21 <glguy> there are much harder problems than those :-p
20:58:27 <dons> yeah, I can see :)
20:58:47 <Korollary> It's about maths. Programming is a necessary evil for those questions.
20:59:04 <dons> yeah, we'd ideally need more math libs
20:59:14 <dons> to proceed efficiently in haskell
20:59:19 <Korollary> That ought to make us really popular :)
20:59:20 <dons> maybe DoCon would help?
20:59:35 <dons> Korollary: sarcasm?
20:59:41 <Korollary> Always
20:59:46 <dons> of course
20:59:49 <glguy> > 50^4
20:59:50 <lambdabot>  6250000
21:00:18 <edwardk> docon seems to strike me as a little off the mark for some reason, not sure why
21:00:37 <dons> been around for a long time, but just doesn't seem to have achieved wide use
21:00:43 <dons> must be 10 years old now
21:00:55 <edwardk> it also doesn't appear to have gone anywhere in the last 4 or so
21:00:58 <dons> oh, 1999. 7 years
21:01:08 <edwardk> the  author appears to have given up on it, and started trying some other BAL thing
21:01:10 <dons> well, its a one man band, no?
21:01:12 <edwardk> yeah
21:01:21 <dons> not sure about that. he's posted comments about porting to 6.4 just the other day
21:01:37 <edwardk> and a one man band where the guy in charge has a poor grasp of english is rough.
21:01:40 <edwardk> ah
21:02:01 <edwardk> ok, well, from the outside it seems pretty stagnant =)
21:02:02 <dons> yeah, that doesn't help
21:02:09 <edwardk> and kinda haskell 98'ish
21:08:03 <SamB> hmm, I need to do something about that other computer...
21:08:13 <SamB> I went to switch to it and... there was nothing there!
21:08:22 <SamB> the screen just went blank!
21:11:48 <glguy> the speed difference between a compiled haskell app on a 3ghz p4 and interpreted one on my G4 powerbook is huge
21:12:20 <dons> huge in which way?
21:12:24 <dons> the g4's not faster, is it?
21:13:23 <glguy> like in the time it took me to walk over to the p4
21:13:26 <glguy> copy the source file
21:13:28 <glguy> compile it
21:13:30 <glguy> run it
21:13:33 <glguy> write down the answer
21:13:37 <glguy> come back to the laptop
21:13:40 <glguy> and enter the answer
21:13:44 <glguy> the laptop was still running
21:13:45 <dons> hehe
21:13:53 <dons> compiled code is fun
21:14:10 <glguy> it makes brute forcing problems a lot easier
21:16:52 <audreyt> dons: what's the plan for unpack/pack for UTF8?
21:17:02 <audreyt> will cbits get utf8_to_int again
21:17:09 <audreyt> or will it be inlined in some other module?
21:17:27 * audreyt is still using the horribly slow UTF8.lhs for String->String packing/unpacking
21:17:36 <dons> I've not discussed this with sjanssen.
21:17:42 <audreyt> 'k.
21:17:43 <dons> Why not just grab the cbits for now
21:18:04 <audreyt> from darcs?
21:18:19 <dons> it must be floating around somewhere
21:18:21 <audreyt> (was that still in LGPL?)
21:18:25 <dons> yeah, or in the fps history
21:18:29 <dons> GPL, iirc
21:18:52 <dons> not sure if that's good for you
21:21:05 <audreyt> prefer BSD3. I'll dig around
21:21:58 <glguy> length [ () | a <- [1..10^6], b <- [1..a-1], coprime a b] -- this is what... O(n^2 log n) ?
21:22:56 <dons> perhaps use a fold, rather than length [...] :: [()] ?
21:23:15 <glguy> I think that fact that coprime is called 10^12 / 2 times...
21:23:20 <glguy> i don't think that's going to be my problem
21:23:25 <dons> yep
21:23:34 <dons> just commenting on [()] as a style issue
21:23:45 <glguy> ah
21:23:54 <glguy> i just did that to make it clear what i was doing
21:23:57 <glguy> my code doesn't look like that
21:24:04 <glguy> it just fits on an IRC line better
21:24:08 <dons> :)
21:25:36 <glguy> "20 million? no, that's not enough"
21:29:28 <glguy> hell... by finding the unique prime factors of a number
21:29:40 <glguy> and figuring how many multiples of each number exist from 1 to n
21:29:46 <glguy> and summing all of those
21:29:56 <glguy> and subtracting that from the sum of 1..n-1
21:30:14 <glguy> i'd save myself a lot of looping
21:42:57 <lispy> glguy: need a primality testor?
21:43:08 <lispy> glguy: i have an implementation of miller-rabin in haskell that you're welcome to use
21:43:27 <glguy> I've got some fast prime functions I've been using
21:43:29 <lispy> it's probablistic but quite effective
21:43:31 <glguy> that I found online
21:44:09 <lispy> it's not much slower than ssh-keygen for creating 4096 bit keys and it's completely unoptimized :)
21:44:25 <lispy> but i probably do less tests on the keys too
21:44:27 <glguy> I just realized my mistake :)
21:44:29 <lispy> i only test for primality
21:44:33 <glguy> this code will run well under 1 minute
21:44:40 <lispy> nice
21:44:59 <lispy> i've also implemented rsa in haskell
21:45:14 <lispy> at least the algorithm, but not the full encryption schema
21:45:25 <lispy> i have no way to split messages into blocks
21:45:52 * lispy just realized that might make a fun lambdabot plugin
21:46:16 <dons> hmm?
21:46:36 <lispy> well, i'm still working on the "fun" part for the user
21:46:42 <lispy> but fun to add :)
21:46:53 <lispy> give lambdabot an rsa capability
21:47:08 <glguy> I need to subtract out the multiples I've counted twice
21:47:12 <glguy> much like that problem dons brought up
21:47:14 <Korollary> http://geekz.co.uk/schneierfacts/
21:47:23 <glguy> and then re-add in the ones that I've deleted twice
21:49:15 <glguy> crap, there is at least one number in 1-1000000 that has 7 unique prime factors
21:49:59 <glguy> so i can't really take shortcuts when counting the number of factors between the 7
21:53:25 <glguy> i remember doing something like this in class where you count the singles, and then subtract with the pairs, and then add in the triples, and subtrac...
21:53:36 <glguy> I don't remember why we were doing it though...
21:53:59 <lispy> yeah, it sounds very numerological
21:54:07 <lispy> but perhaps it computes something
21:54:30 <glguy> wait... I already accounted for the collisions... that can't be it
21:54:37 <glguy> damn...
21:55:55 <lispy> lol, "If at first you don't succeed at breaking a cipher, you're not Bruce Schneier."
21:58:05 <glguy> ha, i didn't account for them :)
21:58:08 <glguy> I'm getting tired
22:04:28 <lispy> http://geekz.co.uk/schneierfacts/fact/27
22:06:11 <Pseudonym> That site is brilliant.
22:06:31 <dons> ?url-on
22:06:31 <lambdabot> Url enabled
22:06:55 <Pseudonym> http://geekz.co.uk/schneierfacts/fact/22
22:06:56 <lambdabot> Title: Everybody Loves Eric Raymond - Bruce Schneier Facts
22:07:49 <dylan> I love Everybody Loves Eric Raymond.
22:08:37 <glguy> solved!
22:08:38 <glguy> haha
22:10:53 <lispy> http://geekz.co.uk/schneierfacts/fact/30
22:10:54 <lambdabot> Title: Everybody Loves Eric Raymond - Bruce Schneier Facts
22:12:35 <Pseudonym> http://geekz.co.uk/schneierfacts/fact/45
22:12:36 <lambdabot> Title: Everybody Loves Eric Raymond - Bruce Schneier Facts
22:13:08 <Korollary> lambdabot could use such facts
22:13:15 <dons> yeah.
22:13:32 <Pseudonym> I can think of a few facts about Olegf.
22:13:34 <Pseudonym> Oleg
22:13:41 <Korollary> SPJ?
22:14:01 <Pseudonym> Oleg solves NP-hard problems in N log N time... in the type system.
22:14:09 <dons> heh
22:14:11 <dons> yes.
22:14:26 <dons> ?remember OlegFacts Oleg solves NP-hard problems in N log N time... in the type system
22:14:26 <lambdabot> Done.
22:14:35 <Korollary> If Oleg makes a type error, the compiler changes itself to compile it anyway.
22:14:46 <glguy> > (,) =<< (+1) 3
22:14:47 <lambdabot>  add an instance declaration for (Num (b -> a))
22:14:51 <dons> add them to OlegFacts as you see fit
22:14:54 <glguy> > ((,) =<< (+1)) 3
22:14:54 <lambdabot>  (4,3)
22:16:53 <glguy> @pl \(a,b) -> a/b
22:16:53 <lambdabot> uncurry (/)
22:17:01 <glguy> @pl \(a,b) -> b/a
22:17:01 <lambdabot> uncurry (flip (/))
22:17:18 <edwardk> eya Pseudonym, did you ever get a reply to the OI monad stuff from 3 years ago or so?
22:17:33 <Pseudonym> Nope.
22:17:54 <Pseudonym> And shapr hasn't finished FLM either.
22:18:00 <edwardk> flm?
22:18:07 <Pseudonym> Fermat's Last Margin
22:18:09 <edwardk> ah
22:18:11 <Korollary> duke nukem's last margin
22:18:24 <Pseudonym> Which just goes to show that nothing I start ever gets finished.
22:18:52 <edwardk> been playing around with comonads, so i was just checking =)
22:22:37 <dons> lambdabot's finished :)
22:24:33 <Pseudonym> ?quote dons lambdabot's finished
22:24:33 <lambdabot> dons lambdabot's finished hasn't said anything memorable
22:24:51 <Pseudonym> ?remember dons lambdabot's finished
22:24:52 <lambdabot> Done.
22:25:17 <Pseudonym> You don't have to put it in HWN.
22:25:21 <Pseudonym> It's just for posterity.
22:27:01 <dons> ok :)
22:29:02 <dons> I think lambdabot's finished in the same way that GHC was full, in 2003
22:29:56 <Pseudonym> lambdabot's brain never exploded, though.
22:30:47 <dons> no, that's true. maybe we should be prepared for that, though
22:38:43 <Korollary> @vixen are you done?
22:38:43 <lambdabot> i truely am
22:54:40 <glguy> and glguy pulls into 5th place of the haskell users on mathschallenge
23:06:16 <lispy> ghc was full in 2003?
23:06:19 <lispy> what is the story there?
23:21:51 <dons> ?google GHC is full Simon
23:21:53 <dons> let's see...
23:21:53 <lambdabot> http://ajp.psychiatryonline.org/cgi/content/full/163/1/41
23:21:54 <lambdabot> Title: Suicide Risk During Antidepressant Treatment -- Simon et al. 163 (1): 41 -- Amer ...
23:21:58 <dons> ah well
23:22:13 <dons> GHC is full could lead some to think bad thoughts,  I suppose
23:22:56 <Korollary> lol
23:27:16 <Tela> The concept of a monad just began to click and it is beautiful!
23:27:30 <Pseudonym> ?enlightenment+ Tela
23:27:30 <lambdabot> Unknown command, try @list
23:27:47 <Tela> heh heh
23:28:24 <dons> cool !
23:28:54 <Tela> It's great how suddenly all the analogies different papers have used make perfect sense
23:32:48 <Korollary> @quote JohnMeacham
23:32:48 <lambdabot>  There will also be a karaoke competition to determine the fate of the monomorphism restriction.
23:32:51 <Korollary> @quote JohnMeacham
23:32:51 <lambdabot>  I liken learning haskell to tipping over a vending machine. you can't just push it, you gotta rock it back and forth a few times building up momentum until bam! suddenly the flash of insight hits
23:32:51 <lambdabot> and it all makes sense.
23:32:55 <Korollary> there.
23:33:26 <Stinger_> haha karaoke
23:34:02 <Tela> haha
23:35:55 <sieni> unlike java which just falls to the ground and the insight (why would anyone use this piece of shit) never comes
23:35:59 <dons> all the analogies? what about the monad-as-spacesuit?
23:36:06 <dons> hehe
23:36:20 <dons> or monad-as-nuclear-waste-containment-vessel
23:36:37 <Tela> I liked the Monad as a conveyor belt. I forget where that was
23:36:39 <dons> (I refer to actual tutorials ;)
23:36:47 <sieni> until you realize that they must have been former php users and don't know about any other programming languages
23:36:47 <Korollary> Monad the barbarian
23:36:52 <dons> we need a wiki page: "Monad as ..."
23:37:31 <Tela> I'm not surprised... All the tutorials which focus on the IO monad go to great lengths to mention how Monads basically save your life every day.
23:37:41 <dons> hehe
23:38:01 <sieni> monad as a spacesuit sounds almost as useful as the following theory about the nature of tom bombadil: http://www.aerojockey.com/blog/bombadil.html
23:38:03 <dons> ?remember Tela ... tutorials which focus on the IO monad go to great lengths to mention how Monads basically save your life every day
23:38:03 <lambdabot> Done.
23:38:04 <lambdabot> Title: My theory on what Tom Bombadil is
23:38:25 <dons> Monad as Tom Bombadil, perhaps?
23:38:41 <dons> monad-as-ring-of-power?
23:38:49 <Tela> Monad as Mt Doom
23:39:04 <dons> we should have a contest for the most far-fetched monad analogy...
23:39:10 <dons> a good April 1 idea ;)
23:39:24 <Tela> Then put together a tutorial from the winners ;)
23:44:35 <dons> oh my "This photograph shows Tom Bombadil obstructing an edge view of a galaxy"
23:47:28 <notsmack> conveyer belts were arrows i think
23:47:58 <dons> hehe "The microwave is the Windows of cooking. It's good for thawing and reheating, and very easy to use. However, it's woefully inadequate for real cooking, and unless you're very careful, you are constantly plagued by improper heating. Additionally, there are an awful lot of people who don't know how to cook anything without a microwave, there are a lot of people who think the microwave is the best thing ever invented, and still quite a few who 
23:48:49 <Tela> So if we stick aluminum foil in Windows it'll explode?
23:49:10 <dons> I think that's a reasonable conclusion. yes
23:49:21 <dons> if you puts eggs in your windows machine, they may make a mess
23:49:53 <Tela> Make sure to cover anything you try to make using Windows, else pieces might end up everywhere.
