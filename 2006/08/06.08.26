00:09:25 <vegai> angry old men...
00:14:13 <cathper> Who said that?
00:19:07 <newsham> dijkstra:  http://www.cs.utexas.edu/users/EWD/transcriptions/EWD02xx/EWD288.html
00:19:09 <lambdabot> Title: E.W.Dijkstra Archive: Concern for Correctness as a Guiding Principle for Program ...
00:21:10 <basti_> hi
00:27:45 <dcnstrct> "Java is the new cobol"
00:29:35 <basti_> yea
00:30:01 <cathper> Gee, do people actually use Java?
00:31:35 <ToTimKopf> hi
00:31:36 <ToTimKopf> : )
00:32:48 <ToTimKopf> I thought a lazy language was a typless language
00:33:20 <ricky_clarkson> Haskell is lazy in that it doesn't evaluate lists until it needs to.
00:33:32 <araujo> mm...
00:33:37 <araujo> ToTimKopf, why?
00:33:41 <newsham> thats a lazy programmer, to.
00:33:55 <ToTimKopf> ah
00:34:09 <ToTimKopf> interesting
00:34:37 <ricky_clarkson> bash is a nice typeless language. ;)
00:35:06 <newsham> strings and lists arent types?
00:35:48 <ricky_clarkson> They're arrays in bash iirc.
01:06:04 <tieTYT2> i can't get this to run: foldr (+) 0 filter Char.isLower "aBCde"
01:06:25 <tieTYT2> i'm pretty sure it's because of function precidence, but when i change it to this it gives me an error too: foldr (+) 0 filter (Char.isLower "aBCde")
01:06:28 <tieTYT2> so how do i get this to run?
01:11:28 <tieTYT2> ok i see why that doesn't make sense
01:11:30 <araujo> uh?
01:11:32 <tieTYT2> i'm trying to add booleans
01:11:59 <araujo> @type foldr
01:12:00 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
01:12:22 <araujo> > foldr (+) 0 [1..9]
01:12:24 <lambdabot>  45
01:13:06 <tieTYT2> ok well i guess that doesn't matter
01:13:43 <tieTYT2> can i use the result of a filter as the third argument of a foldr?
01:14:32 <araujo> > foldr ((+) . Char.ord)  0 (filter Char.isLower "DfREs")
01:14:33 <lambdabot>  217
01:15:21 <tieTYT2> oh so you put the parens around the function name?
01:15:33 <tieTYT2> these examples are very advanced for me, i know like 3 functions
01:15:44 <araujo> > foldr ((+) . Char.ord)  0 $ filter Char.isLower "DfREs"
01:15:45 * ricky_clarkson salutes tieTYT2.
01:15:45 <lambdabot>  217
01:15:49 <tieTYT2> sup ricky_clarkson
01:16:43 <tieTYT2> i'll bbl
01:16:52 <araujo> tieTYT2, think of the filter application as a whole value
01:43:14 <GeoffSK> quick question - how do i catch the error thrown by code like  (read "abc" :: Int)
01:44:07 <Heffalump> use the IO monad
01:44:43 <GeoffSK> is that error thown an IO Error ?
01:45:24 <Heffalump> yes
01:45:31 <GeoffSK> cool, thanks.
01:45:39 <Heffalump> it'll be a userError
01:46:25 <GeoffSK> so Prelude.	catch	:: IO a -> (IOError -> IO a) -> IO a
01:46:35 <GeoffSK> is an ok place to start?
01:46:56 <Heffalump> yes
01:47:19 <GeoffSK> thanks
04:21:51 <kuribas> Wouldn't it be nice if lisppaste has syntax coloring for haskell?
04:22:18 <sieni> kuribas: yes, doesn't it have?
04:22:51 <sieni> kuribas: oh, it doesn't have
04:23:04 <kuribas> sieni: unfortunately not...
04:23:14 <sieni> kuribas: ask for the administrators for instructions how to provide one
04:23:36 <kuribas> sieni: I found this: http://paste.lisp.org/system-server/show/lisppaste/coloring-types
04:23:46 <sieni> and if you are into it, please provide also syntax coloring for standard ml
04:24:04 <kuribas> sieni: hmm, I don't know standard ml so well...
04:25:23 <sieni> standard ml is fun (also, I like Haskell, Scheme and Common Lisp as well)
04:25:46 <kuribas> well, I know a bit of ocaml...
04:26:56 <kuribas> I find it nice about ocaml that it works well with emacs.
04:27:01 <sieni> well if you can do ocaml highlighting, then it should be easily modifiable to sml
04:27:33 <sieni> mlton produces better code and doesn't have a stupid license
04:27:51 <kuribas> ocaml has a stupid license?
04:28:01 <sieni> Yes, QPL for the compiler code
04:28:15 <sieni> I mean both GPL and BSD are better
04:29:01 <kuribas> Yeah, strange they take a license from another project.
04:29:44 <sieni> QPL is a license invented by TrollTech for Qt and because of criticism, TrollTech nowadays offers it with a triple license (commercial, QPL and GPL)
04:30:11 <kuribas> heh :)
04:30:15 <sieni> QPL says basically that "all your patches are belong to us", which sucks
04:30:41 <kuribas> belong in what sense?
04:30:54 <sieni> i.e. the original developers have bsd-like rights for all contributions, but the contributors have gpl-like responsibility
04:31:20 <kuribas> Ah, so they can use your patches in a commercial product if they want.
04:31:49 <sieni> kuribas: yes, it's mostly the asymmetricity that I'm complaining about
04:32:16 <sieni> QPL for example effectively prevents forking of the project
04:33:09 <sieni> but I don't like licenses that say "we can do whatever we want, others please suck your dink"
04:33:51 <kuribas> I see :)
04:34:24 <kuribas> Do you know common lisp well?  I wasn't able to run the code from lisppaste on my computer...
04:34:39 * Heffalump reads the QPL. It doesn't say that - for the original developer to incorporate your modifications, they have to continue distributing them under the QPL.
04:34:51 <sieni> both bsd and gpl are symmetric with respect to rights and responsibilites, but the ocaml team can use your patches, modify them and sell them commercially without giving you the access to the code, but prevent you from doing the same
04:35:41 <sieni> Heffalump: Granted rights 3b)
04:35:59 <Heffalump> >> provided such versions remain available under these
04:35:59 <Heffalump> >> terms
04:36:04 <sieni> + 3 in general
04:36:22 <Heffalump> that was the bit I was reading
04:36:32 <sieni> of course you can't distribute the modified version only, you have to distribute is as patches to the official version
04:36:40 <sieni> (which of course isn't too difficult)
04:37:21 <jeroenp> I'm experiencing some trouble with wxHaskell. Can someone help me a bit?
04:37:35 <sieni> Heffalump: that's actually a point of ambiguity that was discussed on some mailing list
04:38:10 <sieni> does the "under these terms" mean that the patches are released w.r.t. the original developer of the code or the one providing the patches
04:38:29 <sieni> that also a stupidity in the license, because it's ambiguous
04:39:09 <Heffalump> but it doesn't matter, because the terms provide the same rights to other people
04:39:21 <Heffalump> and "initial developer" is fairly clear.
04:40:00 <sieni> Heffalump: it does matter, since if you provide a patch to the original developers, it makes a difference, if in the clause either you or the original original developer is referred to
04:41:43 <sieni> you could claim that you make a patch to a qpl-licensed software and provide it under qpl, but saying that you are the initial developer of the patch
04:42:07 <Heffalump> I don't see how that matters from the pov of the software remaining free, I mean.
04:42:42 <Heffalump> since clause 3b forces the original developer, whoever that is, to make any modifications built on top of contributions available under the QPL, it stays free
04:45:18 <sieni> but it's different from gpl, since they request the right to use your patches commercially without giving anything back.
04:45:56 <sieni> the original developers can distribute modified versions of the contributor's source code without giving anything back
04:46:05 <sieni> it's ok, if the license is bsd
04:46:16 <sieni> since then you have the same right yourself
04:46:43 <sieni> but qpl actively says that "we do what we want, fuck the contributors"
04:46:50 <Heffalump> they can distribute modified versions, but anyone who gets the modified versions still has to distribute further modifications under the QPL, in addition to any other licence
04:48:09 <sieni> that's of course ambiguous, but assuming that "under QPL" means the original original developer, then it means that you can't effectively provide closed source versions of the software, like the initial developer can
04:48:50 <sieni> but the fact is: qpl is crap, you should provide your software with either bsd or gpl
04:48:56 <sieni> or lgpl
04:49:00 <sieni> or something similar
04:49:00 <Heffalump> what do you mean by "closed source", though?
04:49:32 <sieni> Heffalump: using the code in a commercial product without providing the source to the public
04:49:46 <Heffalump> but they have to release it under the QPL too, so they do have to provide the source.
04:49:59 <sieni> Heffalump: No they don't
04:50:20 <Heffalump> >> provided such versions remain available under these
04:50:20 <Heffalump> >> terms
04:50:24 <Heffalump> how can that mean anything else?
04:50:39 <sieni> Heffalump: since they are the original copyright holders of the software, they can provide the parts of the software with the terms they want to
04:50:52 <Heffalump> they can provide the parts they originally wrote under any terms they want
04:51:04 <sieni> and the license takes care of the fact that they don't have to care about the copyrights of the external contributors
04:51:07 <Heffalump> but they can't take your modifications and then release them solely under a closed licence
04:51:20 <blackdog> Heffalump: are you writing in the Quoting monad? :)
04:51:34 <Heffalump> blackdog: :-)
04:53:48 <jrmole> wait, what's this about catching (read "abc" :: Int) in the IO monad?
04:53:53 <jrmole> that expression doesn't even have IO type
04:54:12 <Heffalump> jrmole: yes, but you have to use IO to catch the exception
04:54:15 <Heffalump> if read fails
04:54:22 <jrmole> can you give an example?
04:54:36 <Heffalump> write some IO code that does a read somewhere
04:54:43 <Heffalump> then use catch to catch it.
04:55:13 <Heffalump> e.g. do v <- catch (\error -> ...) (return (read "abc"))
04:55:35 <Heffalump> except that's a bad example because I don't think the return value will be evaluated so the exception won't be caught
04:55:45 <Heffalump> return $! (read "abc") might work
04:57:42 <Heffalump> catch (\error -> ...) (print (read "abc" :: Int))
04:57:47 <Heffalump> is a better example, probably
05:09:59 <Igloo> It's normally better to just use reads instead, though
05:10:16 <jrmole> doesn't work
05:10:23 <Heffalump> if you want to catch the error locally and functionally, yes, reads is better.
05:10:30 <jrmole> > do {a <- catch (return (read "abc" :: Int)) (\error -> return 3); print a}
05:10:31 <lambdabot>  No IO allowed
05:10:34 <Heffalump> if it's really an exceptional condition you'd rather catch a long way away
05:10:40 <jrmole> Prelude> do {a <- catch (return (read "abc" :: Int)) (\error -> return 3); print a}
05:10:40 <jrmole> *** Exception: Prelude.read: no parse
05:10:43 <Heffalump> did you try $! ?
05:10:56 <Heffalump> alternatively
05:11:02 <jrmole> same
05:11:20 <Igloo> You might need catch from Control.Exception instead of the Prelude one
05:11:31 <Heffalump> do { a <- catch (print (read "abc" :: Int)) (\error -> print 3) }
05:11:36 <Heffalump> aargh, sorry
05:11:40 <dons> blackdog: !
05:11:41 <Heffalump> catch (print (read "abc" :: Int)) (\error -> print 3)
05:12:24 <Heffalump> Igloo: no, the Prelude one would be right
05:12:26 <jrmole> it works with Control.Exception and ($!)
05:12:34 <Heffalump> oh, ok.
05:12:37 <Heffalump> Igloo: errm, why?
05:13:19 <Heffalump> my print code doesn't work either. *confused*
05:13:36 * Heffalump decides he must be too stupid to program in Haskell and goes back to thinking about C
05:13:52 <jrmole> wait, so using this i can write code whose value is () using ($!), and _|_ using ($)
05:14:00 <jrmole> that's, like, the opposite of usual ;)
05:14:01 <dons> Prelude> catch (print (read "abc" :: Int)) (\error -> print 3)
05:14:01 <dons> *** Exception: Prelude.read: no parse
05:14:01 <dons> Prelude> Control.Exception.catch (print (read "abc" :: Int)) (\error -> print 3)
05:14:05 <dons> 3
05:14:24 <Heffalump> so what does Prelude.catch catch?
05:14:26 <sieni> Heffalump: if you know C, then standard ml might be nice way to introduce oneself to functional programming
05:14:39 <jrmole> Prelude Control.Exception> do {a <- Control.Exception.catch (return (read "abc" :: Int)) (\error -> return 3); print a}
05:14:39 <jrmole> *** Exception: Prelude.read: no parse
05:14:39 <jrmole> Prelude Control.Exception> do {a <- Control.Exception.catch (return $! (read "abc" :: Int)) (\error -> return 3); print a}
05:14:39 <jrmole> 3
05:14:57 <Igloo> The Prelude one only catches IO exceptions IIS
05:15:07 <Heffalump> what's an IO exception, then?
05:15:14 <Igloo> s/IIS/IIRC/
05:15:15 <sieni> Heffalump: there even exists a nice book called "ml for the working programmer", which is pretty good, i.e. it doesn't treat the reader as an idiot
05:15:20 <dons> -- Also note that the "Prelude" also exports a function called
05:15:20 <dons> -- 'Prelude.catch' with a similar type to 'Control.Exception.catch',
05:15:20 <dons> -- except that the "Prelude" version only catches the IO and user
05:15:20 <Heffalump> userError seems to be listed in System.IO.Error
05:15:22 <dons> -- families of exceptions (as required by Haskell 98).
05:15:36 <Heffalump> perhaps I'm confused about what a user exception is
05:16:00 <jrmole> error "foo"
05:16:01 <jrmole> i believe
05:16:24 <Heffalump> sieni: sorry to confuse, I do know Haskell pretty well. I was just joking cos my day job right now is writing a C compiler, and Igloo likes trolling me about this :-)
05:16:41 <sieni> Heffalump: Sorry
05:16:54 <sieni> Heffalump: I have a bad nick/face/name memory
05:17:16 <jrmole> hmm, i don't like this whole IO exceptions business
05:17:17 <Heffalump> s'ok. Be glad I resisted my initial temptation to wind you up a bit :-)
05:17:21 <jrmole> except for IO things i guess
05:17:36 <dons> error s = throw (ErrorCall s), i.e. an Exception, not an IOError
05:17:45 <dons> ?type Control.Exception.catch
05:17:47 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
05:17:50 <Heffalump> jrmole: the idea is that you can't write code that catches exceptions with a pure type, because there's no semantic guarantee whether an exception will happen or not
05:17:53 <dons> ?type Prelude.catch
05:17:55 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
05:18:20 <jrmole> but it seems like you'd be better off wrapping with your own error monad than trying to shove what you're doing into IO with dubious things like evaluate / seq / $!
05:18:35 <Heffalump> the $! was dubious, yeah
05:18:46 <Heffalump> my example with using print on the value directly was better
05:19:04 <jrmole> well, it hides that particular issue ;)
05:19:22 <Heffalump> the point is that you are using the value within the IO computation
05:19:26 <jrmole> but i guess if you're doing IO anyway, you'll force it eventually
05:19:26 <jrmole> yeah
05:19:48 <Heffalump> catch doesn't guarantee that the value that comes out will be exception-free
05:20:02 <Heffalump> but it guarantees that any exceptions resulting from side-effects inside will be handled
05:26:55 <GeoffSK> that explains why i couldn't the prelude exception to work.
05:28:12 <dons> you should almost always use Control.Exception.catch
05:28:34 <dons> I hope Prelude.catch goes away, in fact
05:28:55 <GeoffSK> ok - whats the best way to shadow so i dont see it?
05:29:05 <dons> ?docs Control.Exception
05:29:05 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
05:29:09 <dons> has an example of how best to hide it
05:31:41 <eivuokko> I think it was a misnomer to name both catches the same - way too easy to write safe-looking code that actually is broken.
05:32:08 <dons> yep :/
05:32:40 <dons> maybe Prelude.catch should be deprecated, or have some warning pragma attached
05:33:05 <dons> do we have warning pragmas? {-# WARN "fun" "This function is almost always misused, consider .... instead" #-}
05:33:24 <dons> would inject a warning at compile time
05:38:45 <GeoffSK> seriously how do you hide it, the docs just seem to say you should
05:40:18 <eivuokko> import Prelude hiding (catch)
05:40:57 <dons> yeah, don't the docs say: We recommend
05:40:58 <dons> -- either hiding the "Prelude" version of
05:40:58 <dons> -- 'Prelude.catch' when importing
05:40:58 <dons> -- "Control.Exception", or importing
05:40:58 <dons> -- "Control.Exception" qualified, to avoid name-clashes
05:41:13 <dons> ah, so maybe it should actually state the line
05:41:33 * dons crafts a patch
05:41:56 <GeoffSK> yep, for dumb newbies likes me that line is gold (thanks eivuokko)
05:43:41 <dons> GeoffSK: how's this:
05:43:42 <dons> -- We recommend either hiding the "Prelude" version of 'Prelude.catch'
05:43:43 <dons> -- when importing "Control.Exception":
05:43:43 <dons> --  > import Prelude hiding (catch)
05:43:43 <dons> -- or importing "Control.Exception" qualified, to avoid name-clashes:
05:43:45 <dons> --  > import qualified Control.Exception as C
05:43:47 <dons> -- and then using:
05:43:50 <dons> --  > C.catch
05:43:52 <dons> --
05:44:33 <GeoffSK> passes the newbie test (at least for me)
05:44:40 <dons> cool
05:44:45 * dons darcs sends
05:45:16 <GeoffSK> that will update the docs?
05:45:31 <dons> when they're regenerated, yes
05:45:44 <dons> (actually, I'll darcs push ;)
05:45:53 <GeoffSK> impressive
05:48:18 <dons> we aim to please, here at #haskell
05:51:10 <eivuokko> Good idea, dons.
05:52:02 <dons> we should try to do this whenever people point out an issue in the docs
05:52:29 <Heffalump> so when will Haskell' be ready?
05:53:00 <dons> sometime next year?
05:56:03 <ivant> hi guys
05:56:21 <Heffalump> is there a ticket for sorting out Prelude.catch?
05:57:28 <dons> there's some tickets on standardising various exception forms
05:57:33 <dons> so i presume it would come under that
05:58:13 <Heffalump> right, was jsut trying to find a specific mention
05:58:46 <Heffalump> but I guess the new Exception module prototyped obviously does it
06:02:20 <beelsebob> Twigathy_:
06:02:35 <ivant> Can anyone suggest me a good article on how Haskell actually works (i.e. how it manages memory, how and why does space leaks occur). I have a good understanding how a memory can leak in C or C++, but I feel that I miss some simple point for Haskell
06:02:40 <ivant> ?
06:03:33 <ndm> ivant: look up some ofthe papers on space leaks by Runciman
06:03:42 <ndm> @google runciman space leak
06:03:43 <lambdabot> http://www.algorithm.com.au/mt/haskell/index.html
06:03:43 <lambdabot> Title: Algorithm.com.au - Haskell
06:04:07 <GeoffSK> does lazy eval mean that test2 = do catch (return (read "abc" :: Int)) (\error -> return 0) throws an exeption when i try to use test2.
06:04:09 <dons> hmm, here perhaps, http://haskell.org/haskellwiki/Research_papers/Runtime_systems
06:04:11 <lambdabot> Title: Research papers/Runtime systems - HaskellWiki
06:04:20 <dons> GeoffSK: yep
06:04:33 <GeoffSK> dang
06:04:45 <ndm> http://scholar.google.com/url?sa=U&q=http://www.cs.york.ac.uk/ftpdir/pub/colin/jfp93hp.ps.gz
06:05:36 <ndm> dons, i love the idea of @free - i've been thinking of writing a similar thing myself
06:05:43 <ndm> to hook up with ESC/Haskell
06:05:50 <ndm> is the code available as a standalone program?
06:05:59 <dons> yep, let me find the repo
06:06:13 <dons> darcs get http://andrew.bromage.org/darcs/freetheorems
06:06:13 <ndm> @where free
06:06:14 <lambdabot> I know nothing about free.
06:06:18 <lambdabot> Title: Index of /darcs/freetheorems
06:06:21 <dons> ?where+ free http://andrew.bromage.org/darcs/freetheorems
06:06:22 <lambdabot> Done.
06:08:57 <ndm> dons: although lots of theorems seem to be missing
06:10:48 <ivant> thanks a lot, it seems to be just the thing I wanted
06:15:20 <dons> ndm, afaik, its one days hacking by Pseudonym
06:15:27 <dons> and one patch by me.
06:15:39 <dons> so i'm sure there's things missing :)
06:15:58 <ndm> dons: cool - its very nice, and could be quite useful
06:16:06 <dons> yeah, i was thinking so too
06:16:14 <dons> hooking in with QC, for example
06:16:37 <ndm> tah, thats useless
06:16:38 <dons> and its use should encourage people to write types with more free theorems...
06:17:11 <ndm> they are theorems, the type prooves it, no need for QC'ing them
06:17:21 <dons> i'd consider using @free to generate QC properties for my code though
06:17:38 <ndm> why? the fact they were generated means that they are all true, so why check them?
06:17:51 <dons> oh, say I get something about the polymorphic map,
06:18:02 <dons> it should hold over monomorphic Data.ByteString.map too
06:18:19 <ndm> ah, ok - so feed in equivalent type sigs, rather than real ones
06:18:24 <dons> yep
06:18:24 <ndm> kind of a special case
06:18:27 <dons> maybe
06:18:48 <ndm> i think it encourages people to be more abstract, more general in their code, which is a good thing
06:18:52 <dons> yep
06:19:08 <dons> imagine a tool that scores a person's code based on the number of free theorems
06:19:17 <ndm> hehe, thats not that good
06:19:26 <lscd> for random fun, it might be
06:19:28 <ndm> since Catch will generate plenty more theorems than that
06:19:38 <dons> hehe
06:19:40 <dons> ?type catch
06:19:42 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
06:19:46 <dons> ?free IO a -> (IOError -> IO a) -> IO a
06:19:47 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:57:20-34
06:19:53 <dons> ?free catch :: IO a -> (IOError -> IO a) -> IO a
06:19:54 <lambdabot> $map_IO f (g y) = h y => $map_IO f (catch x g) = catch ($map_IO f x) h
06:20:01 <dons> looks like it should hook in to hoogle...
06:20:07 <dons> ?hoogle map
06:20:08 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
06:20:09 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
06:20:09 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
06:20:16 <dons> ?hoogle (a -> b) -> [a] -> [b]
06:20:17 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
06:20:18 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
06:20:18 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
06:20:19 <ndm> i have been working on Hoogle 4 last week
06:20:22 <dons> ?. free hoogle (a -> b) -> [a] -> [b]
06:20:23 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:57:20-34
06:20:38 <ndm> wait til you see that - a 10 times better than Hoogle 3 at least :)
06:20:45 <dons> 10x!
06:20:49 <dons> :)
06:20:58 <ndm> faster, more accurate
06:21:12 <ndm> maybe 100x faster on the current data set
06:21:17 <ndm> but massively more scalable
06:21:27 <dons> how'd you speed it up?
06:21:28 <ndm> O(size of search), instead of O(size of database)
06:21:36 <lscd> wow
06:21:38 <dons> ah
06:21:54 <ndm> for textual searches
06:22:06 <ndm> i sped up type searches, but not by as much
06:22:40 <dons> use any ByteStrings? :)
06:22:45 <ndm> i did that by using compression for type sigs, i.e. init, tail, reverse all have the same type sig
06:22:55 <dons> ah nice idea
06:22:56 <ndm> so there is only one entry in the type database, rather than 3
06:23:00 <dons> going to write this up?
06:23:09 <ndm> no byte strings, not sure they are useful anywhere
06:23:19 <ndm> do you have parsec over ByteStrings?
06:23:25 <dons> yeah, these days.
06:23:32 <SamB> uh?
06:23:39 <ndm> they could help in teh database generation, but thats an offline process, so kind of irrelevant
06:23:41 <dons> i'd have though string searching would be a lot faster with bytestrings though
06:23:48 <dons> ah right
06:23:55 <dons> SamB: well, you're writing something, yeah?
06:24:06 <ndm> it searches byte at a time, in a binary file, so there are rarely real chunks of string sitting around
06:24:10 <SamB> dons: did a little hacking on something someone else wrote...
06:24:13 <ndm> might speed up the final lookup's, will have to see
06:24:17 <SamB> @where ByteStringParser
06:24:17 <lambdabot> http://hackage.haskell.org/~paolo/darcs/ByteStringParser
06:24:25 <SamB> but it is hardly Parsec
06:24:25 <dons> searches in a binary file?
06:24:26 <ndm> do i get insane fast take/drop with bytestring?
06:24:34 <dons> yes, O(1)
06:24:40 <dons> == insane!
06:24:41 <ndm> yeah, writes out a binary file, which has indexes and tries
06:24:53 <ndm> ok, might be good for the final display bit then
06:25:07 <ndm> i get an index for each result, seek to there in the file, and read out the answer
06:25:14 <ndm> which is a pretty printed type sig
06:25:21 <ndm> which i need to colour appropriately
06:25:22 <SamB> (xerox didn't write it either, btw)
06:25:39 <ndm> i may one day write hoogle up, its a question of time, since its not really my phd
06:25:44 <dons> ?credit+ SamB
06:25:44 <lambdabot> Unknown command, try @list
06:32:40 <dons> ?uptime
06:32:40 <lambdabot> uptime: 1 day, 9 hours, 27 minutes and 20 seconds
06:33:30 <SamB> as you can see if you look in the file, it was written by Jeremy Shaw...
06:33:43 <SamB> hmm, had that sitting in the input field for a while...
06:34:18 <dons> yeah, I know. stepcut sent me the parser. but weren't you hacking on it too? or was I dreaming?
06:35:54 <ivant> is there any locale character conversion support for ByteStrings?
06:36:05 <SamB> I hacked on it a bit, yes
06:36:12 <SamB> as darcs changes will show ;-)
06:37:35 <dons> ivant: there's some support for deadling with other latin* encodings, yes
06:37:46 <dons> kzm's got a repo hosted somewhere
06:38:12 <dons> ?seen kzm
06:38:12 <lambdabot> kzm is in #haskell. I last heard kzm speak 1 day, 4 hours and 4 seconds ago.
06:38:15 <SamB> like, I wrote the combinator to run a parser, and then instead of returning the returned value, return the substring it parsed
06:38:24 <dons> :)
06:38:50 <SamB> which is *extremely* easy
06:39:16 <ivant> ?where FilePath
06:39:17 <lambdabot> http://darcs.haskell.org/~lemmih/FilePath
06:39:25 <SamB> just subtract the length of the remaining input at the end from that at the beginning, and take that much from the remaining input at the beginning
06:39:48 <ndm> ivant: try my system.filepath!
06:39:57 <ndm> its the one thats going for a Haskell base library
06:40:01 <ndm> ?where System.FilePath
06:40:02 <lambdabot> I know nothing about system.filepath.
06:40:11 <ivant> ndm: what is the difference?
06:40:17 <ndm> ivant: http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php
06:40:19 <lambdabot> Title: Neil Mitchell - Haskell Libraries
06:40:52 <ndm> ivant: mine is more portable, more copmlete
06:41:05 <ndm> ivant: and hopefully goingto be included in teh base libraries
06:41:16 <ivant> ndm: does it support arbitrary-style URI's like smb://someserver/path/filename ?
06:41:17 <ndm> i stole the good bits out of lemmih's one, with his permission
06:41:28 <ndm> ivant: neither of them do that
06:42:19 <SamB> ivant: is that even a real URI?
06:42:35 <SamB> not that a URI parser wouldn't be able to parse it
06:42:43 <ivant> SamB: it is, why not?
06:47:57 <ivant> @wikipedia URI
06:47:59 <lambdabot> No Result Found.
06:48:10 <ivant> @wikipedia Unified Resource Identifier
06:48:12 <lambdabot> No Result Found.
06:48:14 <lscd> @wikipedia Uri
06:48:15 <lambdabot> No Result Found.
06:48:21 <lscd> hm. funny
06:48:22 <ndm> @help wikipedia
06:48:22 <lambdabot> wikipedia <expr>. Search wikipedia and show url of first hit
06:48:31 <ivant> @wikipedia Wikipedia
06:48:33 <lambdabot> No Result Found.
06:48:40 <ndm> dons, @wikipedia is broken
06:51:03 <ivant> ndm, I "darcs got" your version of FilePath and will try to use it
06:51:37 <ndm> ivant: cool, if you can't figure something out just shout
06:51:59 <dons> hmm, seems broken
06:52:10 <dons> maybe wikipedia changed its search system
06:53:12 <ndm> wikipedia search is regularly broken
06:53:21 <ivant> sure. Do you think it would need the URI handling extension in future or should it be a separate module?
06:53:24 <ndm> why not google on site:en.wikpedia.org
06:53:44 <ivant> @google URI site:en.wikipedia.org
06:53:46 <lambdabot> http://en.wikipedia.org/wiki/Uniform_Resource_Identifier
06:53:49 <ndm> ivant: i want to shove System.FilePath into base, its already generated engouh "discussion" because I use a string
06:54:04 <ndm> ivant: getting it in with URI handling would be impossible - but i'd like to move in that direction
06:54:11 <ndm> possibly as something beyond filepath
06:54:21 <ndm> i also want full readFile/writeFile handling of URL's
06:54:35 <ndm> so readFile "http://www.google.com/" just works with Haskell
06:54:36 <ivant> that would be tricky
06:54:36 <lambdabot> Title: Google
06:54:50 <ndm> it would be, but KDE has something similar
06:55:12 <ivant> it would be great if we could use custom protocol handlers then
06:56:44 <vegai> ndm: well, really that sort of thing should be implemented in the OS
06:57:24 <ndm> vegai: haskell has to be portable, so in that case you can't have it anywhere
06:57:25 <ivant> ?where+ System.FilePath http://www.cs.york.ac.uk/fp/darcs/filepath
06:57:25 <lambdabot> Done.
06:57:35 <vegai> yeah ;/
06:58:26 <ivant> vegai: it is even more tricky at the OS level, I guess
07:01:02 <vegai> ivant: plan 9...
07:01:31 <vegai> just needs a solid base, that's all.
07:01:41 <ndm> yeah, its a nice feature
07:01:46 <musasabi> readFile and writeFile handling URLs by default would be bad.
07:01:50 <ndm> anyway, at the moment its too far away from reality
07:01:58 <musasabi> The OS should be doing that, not each language runtime
07:02:21 <vegai> ndm: chicken & egg...
07:02:23 <ndm> but if you want your language to be portable...
07:02:34 <ndm> vegai: definately!
07:05:48 <xs> what if you have a file called http://www.google.com/?
07:05:50 <lambdabot> Title: Google
07:07:04 <ndm> xs: you can't, you could have a file named file://www.google.com
07:07:14 <ndm> but the bit:// says the protocol, http is a remote server
07:08:02 <xerox> URIs vs. URLs.
07:08:31 <xs> ndm, so you're proposing changing the filesystem namespace too?
07:08:36 <musasabi> ndm: yes one can have a file named "http://www.google.com/", just not on *nix.
07:09:04 <ndm> xs, i'm not really proposing anything - more just: wouldn't it be cool if readFile "http://website.com" did the business
07:09:06 <lambdabot> Title: Website.com - Open Discussion For Every Website
07:09:22 <xs> readFile (URL "http://blah") yup :)
07:09:36 <SamB> I could have a directory called http://www.google.com/
07:09:37 <lambdabot> Title: Google
07:09:37 <musasabi> ndm: that has lots of potential security issues.
07:09:38 <ndm> imagine: ghc --make http://haskell.org/Hoogle/Main.hs -o hoogle.exe
07:09:52 <SamB> but it would be relative to whatever directory I was in at the time
07:10:03 <ndm> musasabi: practically, its going to be a harder seel, but just imagine the coolness
07:10:08 <musasabi> ndm: one can already do things like that with searchpath (using Haskell modules from web).
07:10:18 <SamB> it would be a subdirectory of the $PWD/http:
07:10:30 <xerox> Yes, you can with SearchPath!
07:10:36 <musasabi> ndm: I don't think it is cool that programs work in different ways depending on the language they are written.
07:10:47 <musasabi> pathnames should be an OS level thing.
07:11:01 <musasabi> of course OSs should support extending the namespace with http etc
07:11:16 <dons> yeah, with new filesystems for example
07:11:33 <musasabi> btw automounter + sshfs is quite nice
07:11:43 <SamB> dons: you mean URI filesysytem drivers?
07:11:51 <dons> i was thinking of sshfs
07:12:05 <dons> got to be a userland thing
07:12:05 <SamB> musasabi: did you mean that?
07:12:32 <SamB> dons: oh, yeah, userland filesystems are nice ;-)
07:12:34 <ndm> alright, i'm just bitter that as a windows user i don't get these cool things, and have to download stuff first
07:13:00 <musasabi> sshfs = mount a directory on a remote server over ssh.
07:13:09 <dons> SamB: well, you can write them in haskell ;)
07:13:15 <musasabi> automounter = automagically mount things when they are needed
07:13:57 <ulfdoz> <- is automounter-hater. I ever wondered why the box don't ejects my "unmounted" cds. :)
07:14:25 <musasabi> ulfdoz: automounter is an art and very easy to abuse
07:14:41 <SamB> I would be happy for my cd drive to eject period
07:17:00 <SamB> for some reason it does not like to eject when no disk is in it
07:17:12 <SamB> I don't know how I got it to eject before when this happened...
07:17:42 <SamB> it is especially annoying with my XP box needing a fan replaced...
07:18:26 <jbalint> what about the paper clip?
07:19:13 <SamB> ... what paper clip?
07:19:18 <SamB> oh, that.
07:19:27 <SamB> I thought you meant binky for a second there.
07:19:31 <SamB> I tried that...
07:19:33 <jbalint> o.O
07:19:39 <jbalint> It couldn't force it open?
07:20:00 <SamB> not really, no
07:20:55 <jbalint> Are the mechnanical pieces of the disc sled broken?
07:21:00 <SamB> hmm
07:21:16 <SamB> hard to say with the disk drive stuck closed!
07:21:38 <SamB> I'd need to pull the drive out, I think, somehow get it open...
07:22:49 <jbalint> I've always been able to open with a paper clip.
07:22:56 <SamB> yeah.
07:23:19 <SamB> I think my drive might be improperly mounted, or it could be, as you suggest, some problem with the tray
07:24:08 <SamB> by improperly mounted, I mean maybe I have it screwed on a bit wrong...
07:24:52 <SamB> this has happened before, but I have no idea how I ever got it open after...
07:31:37 <ivant> SamB: yesterday I had a worse hardware malfunction: my notebook was misteriously turning off while I was typing
07:31:51 <araujo> morning
07:32:11 <SamB> ouch!
07:32:58 <ivant> and when it began to happen once in 5 minutes, I unscrewed the back panel and after some investigation found a screw rolling over the motherboard
07:33:06 <ivant> :-)
07:34:05 <SamB> oh, ack!!!!
07:34:23 <SamB> I hope it didn't fry anything!
07:36:30 <ivant> hmm, it is working now but when it was turning off, it was freaky: I had some color lines blinking on my screen
07:39:42 <xian> i think there was a function which - given a function f a b - returned a function which takes b a as arguments (in reversed order). but i right now can't recall its name.
07:39:56 <ndm> xian, flip?
07:40:15 <ndm> @hoogle (a -> b -> c) -> b -> a -> c
07:40:17 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
07:40:29 <ndm> xian, and you can always hoogle things like this relatively easily ^^^^
07:41:09 <xian> oh yes, that looks nice. thank you.
07:45:00 <ivant> @hoogle fix
07:45:01 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
07:45:01 <lambdabot> Control.Monad.Fix :: module
07:45:01 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
07:45:20 <SamB> ivant: whatcha looking for?
07:52:26 <ivant> I'm trying to grasp the concept of the fixed-point combinators
08:03:42 <petekaz> I need some help with instances.  I am using System.Clocktime as a timestamp to some abstract data type called Paste.  I'm trying to serialize Pastes just using show/read.  But there is no read for System.Clocktime and I don't want to make one because the corresponding show prints human readable datetime.  So can I make a new 'show' instance for Clocktime that just prints the ints of secs and picosecs seperated with a ":", then I can
08:03:43 <petekaz> easily make a corresponding read.
08:03:54 <petekaz> I tried this:
08:03:56 <petekaz> type Timestamp = ClockTime
08:03:58 <petekaz> instance Show Timestamp where
08:04:01 <petekaz>   show (TOD secs psecs) = show secs ++ ":" ++ show psecs
08:05:08 <Igloo> petekaz: You'll need to newtype it if you want a different Show instance
08:06:03 <monochrom> I don't think you must call them "show" and "read".  Why not call them "showtime" and "readtime" and eliminate the problem altogether?
08:07:16 <dons> yeah, so either a unique type, via newtype, so you can select the right Show instance, or name your show function something unique, and call that explicitly
08:08:46 <petekaz> (one sec phone)
08:12:23 <dons> petekaz: you're hacking haskell at work? :)
08:14:02 <ndm> some people get phone calls at home...
08:15:38 <dons> oh, I suppose that's possible
08:15:42 <monochrom> some people hack haskell at gf's place
08:16:04 <monochrom> then gf gets upset and leaves
08:16:09 <dons> oh :(
08:16:32 <monochrom> then you call her on the phone, thus you are on the phone and hacking haskell too :)
08:16:42 <dons> :)
08:18:28 <dons> hmm, threadDelay :: Int -> IO ()
08:18:42 <monochrom> threadDelay is cool
08:18:44 <dons> what if i wanted to delay a thread for longer than fits in an Int?
08:18:53 <dons> I'd have to catch it and put it to sleep again
08:18:54 <monochrom> loop
08:19:36 <xerox> > (maxBound :: Int) / 60 / 60
08:19:37 <lambdabot>  add an instance declaration for (Fractional Int)
08:19:56 <xerox> > fromIntegral (maxBound :: Int) / 60 / 60
08:19:58 <lambdabot>  596523.2352777778
08:19:59 <dons> well, its a microsecond argument
08:20:09 <xerox> Ah.
08:20:34 <xerox> > fromIntegral (maxBound :: Int) / 1000000 / 60 / 60
08:20:35 <lambdabot>  0.5965232352777777
08:20:40 <xerox> > fromIntegral (maxBound :: Int) / 1000000 / 60
08:20:41 <lambdabot>  35.791394116666666
08:20:44 <xerox> 35 mins?
08:20:50 <dons> seems small, doesn't it
08:21:05 <Igloo> What are you doing?
08:21:13 <xerox> Sleeping.
08:21:27 <dons> \me -> threadDelay (8 * 60 * 60 * 10^6) -- ;)
08:21:39 <Igloo> Oh, I see  :-)
08:21:56 <ndm> well you're only allowed to nap 35 misn at a time
08:22:07 <monochrom> Haskell alarm?  threadDelay (8 hours) >> putStrLn (repeat '\007') ?
08:22:19 <ndm> leave your IRC on andwe'll ping you every half hour
08:22:25 <dons> hehe
08:22:38 <monochrom> You should add this to lambdabot.
08:22:45 <dons> > 8 * 60 * 60 * 10^6 :: Int
08:22:46 <lambdabot>  -1264771072
08:23:02 <monochrom> @wakemeup 8 hours
08:23:03 <lambdabot> Unknown command, try @list
08:23:19 <dons> hmm. well, we'd need to wrap threadDelay first
08:23:21 <Igloo> You could upgrade to amd64
08:23:24 <ndm> now, an alarm feature would be beautiful
08:23:31 <monochrom> (8 hours later) <lambdabot> monochrom: wake up!
08:23:37 <ndm> @alarm 4 hours, watch TV
08:23:38 <lambdabot> Unknown command, try @list
08:23:49 <dons> hmm. I think threadDelay is actually used in lambdabot for a 30 minutes sleep between darcs patch checking in the darcs patch plugin
08:23:58 <monochrom> You can program your IRC client to beep like crazy on that string.
08:24:12 <xerox> But don't tell anyone!
08:24:38 <dons> well, I suppose lambdabot could be a reasonable alarm
08:24:41 <lennart> hi
08:24:48 <dons> it could privmsg you at time+n
08:25:01 <dons> hey lennart
08:25:35 <musasabi> dons: for slonger sleep periods one needs to do clock syncronizing in any case.
08:25:42 <dons> > fromIntegral (maxBound :: Data.Word.Word64) / 1000000 / 60
08:25:43 <lambdabot>  3.0744573456182587e11
08:25:55 <musasabi> "how much time have I slept and how much UTC time has passed"
08:26:37 <dons> so the maximum sleep period of a GHC thread is governed by the word size of the machine..
08:26:48 <petekaz> monochrom: my data type derives read and show so I can't call a readtime/showtime functions.
08:26:50 <snk_kid> hello, can you guys help me out alittle
08:27:00 <ndm> snk_kid: ask and we'll see :)
08:27:02 <xerox> http://www.youtube.com/watch?v=fizmDE2X1Dg I want lectures this way too! :D
08:27:09 <monochrom> Then go with newtyping.
08:27:37 <dons> petekaz: yeah, you can't derive Read/Show and then write your own Read/Show
08:27:39 <petekaz> right, thanks.
08:28:34 <petekaz> dons: not at work :-) my brother called.
08:28:41 * dons -> threadDelay (8 * 60 * 60 * 10^6 :: Word64) -- night!
08:29:25 <snk_kid> i'm trying to help out some guys in a forum about purely functional progarmmig, monads and haskell. It's gamedev, now all of suden people are kind of curious about it all so i'm kinda of help the haskell community here, could one of you make sure i'm saying the write things :)
08:30:14 <snk_kid> correct me and/or elaborate
08:30:25 <lscd> snk_kid: i'll look, but i'm a newbie
08:30:27 <dons> snk_kid: oh, you could mention Frag, http://haskell.org/haskellwiki/Frag. 1 guy, 8 weeks.
08:30:28 <lambdabot> Title: Frag - HaskellWiki
08:31:59 <snk_kid> dons: i've meantioned functioanl reactive, it's not so much on the side of gamedev just general info that people don't know. I just want to make sure i'm saying the correct things about haskell. One guy was curious about the preformance/space usage of monadic code, things like that
08:32:35 <snk_kid> it's here anyways http://www.gamedev.net/community/forums/topic.asp?whichpage=2&pagesize=25&topic_id=410454
08:32:39 <ndm> snk_kid: have you seen the presentation by one of the game dev people, on what he wanted in a programming langauge?
08:32:46 <ndm> and specifically why haskell wasn't for him
08:33:01 <ndm> as it does kind of read like an advert for haskell :)
08:33:27 <ndm> snk_kid: http://www.google.com/url?sa=t&ct=res&cd=1&url=http%3A%2F%2Fwww.st.cs.uni-sb.de%2Fedu%2Fseminare%2F2005%2Fadvanced-fp%2Fdocs%2Fsweeny.pdf&ei=92jwRLiAD7qWiALQ1_XCCg&sig2=gcngSUSv2GuQlOUeNwxNjA#search=%22game%20development%20haskell%20presentation%22
08:33:42 <ndm> www.st.cs.uni-sb.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf even
08:33:43 <lscd> snk_kid: hm, the curry-howard isomorphism? haskell uses hindley-milner, not dependent types
08:35:05 <snk_kid> ndm: yeah i've seen Sweeney's paper, the thread isn't about converting people. The OP is going to take a course in functional programming with haskell, he just wanted some info, as i was giving him some help others started to get curious about purely functional programming so i'm getting alot of question :)
08:36:24 <snk_kid> lscd: curry-howard isomoprhism states the corrleation between types as propposition or programs as proofs in functional programs so
08:36:51 <snk_kid> lscd:i was just talking about functional in general
08:38:05 <snk_kid> anyways if you guys want to join in and post http://www.gamedev.net/community/forums/topic.asp?whichpage=2&pagesize=25&topic_id=410454
08:38:25 <lscd> snk_kid: how much you can get from the type system varies pretty dramatically; with haskell, you have some fun "theorem for free" stuff
08:39:23 <snk_kid> lscd: anything you feel is incorrect, just post and correct me. Don't even need to be a member to post.
08:40:05 <lscd> snk_kid: as i said, i'm a newbie; there are a couple of bits that make me go "hm", but i can't authoritatively correct them; i lack the knowledge and certainty
08:41:10 <snk_kid> well anyone else is welcome and encouraged to join in :)
08:44:41 <snk_kid> anyways is whats happening with Sweeny's stuff, he said he was working on a prototype and the whole point of his papers where for graduates to come up with something :)
08:44:54 <snk_kid> *post-graduates
08:46:18 <petekaz> ok ... still trying to get this read thing working, can someone show me the read function for this:
08:46:21 <petekaz> newtype Timestamp = TS ClockTime deriving Eq
08:46:23 <petekaz> instance Show Timestamp where
08:46:27 <petekaz>   show (TS (TOD secs psecs)) = show secs ++ ":" ++ show psecs
08:49:40 <int-e> reads s = [(TS (TOD secs psecs), s3) | (secs, s1) <- reads s, let (':':s2) = s1, (psecs, s3) <- reads s2] ?
08:51:22 <petekaz> thanks int-e.
08:51:28 <int-e> Hmm, the let is bad. should be (':':s2) <- [s1] to produce 'fail' instead of 'error', I think.
08:51:54 <int-e> or you can just do (secs, ':':s1) <- reads s  and skipt that step.
08:52:03 <int-e> -t
08:55:36 <petekaz> int-e: sorry, so what would the last version look like?
08:56:01 <int-e> that was meant to replace the (secs, s1) <- reads s
08:56:35 <int-e> so reads s = [(TS (TOD secs psecs), s2) | (secs, ':':s1) <- reads s, (psecs, s2) <- reads s1]
08:57:48 <petekaz> thanks again!
09:07:18 <snk_kid> just before i go, last time
09:07:29 <snk_kid> http://www.gamedev.net/community/forums/topic.asp?whichpage=2&pagesize=25&topic_id=410454
09:07:39 <snk_kid> seeya :)
09:10:03 <dylan> heh: http://www.google.com/trends?q=haskell%2C+ocaml&ctab=0&geo=all&date=all
09:10:05 <lambdabot> Title: Google Trends: haskell, ocaml
09:17:02 <jbalint> There is a sports star called Haskell?
09:17:53 <ndm> its a sports team
09:18:09 <sieni> at least there are some stars called haskell -> #haskell-blah
09:18:53 <Korollary> There are places called Haskell.
09:22:01 <dylan> still, I bet a lot of those are the language.
09:22:29 <ndm> hmm, not sure
09:22:42 <ndm> i tried doing trends on anything else
09:22:59 <ndm> haskell programming
09:23:02 <ndm> haskell functional
09:23:06 <ndm> and none had enough volume
09:29:24 <Korollary> ocaml has the advantage of having a unique name.
09:29:34 <Korollary> albeit a weird name
09:31:38 <lennart> better than haskell
09:34:11 <Oejet> Heh, try searching for anything related to the R statistical package on the internet.
09:34:23 <xerox> ?google R
09:34:26 <lambdabot> http://www.r-project.org/
09:34:26 <lambdabot> Title: The R Project for Statistical Computing
09:34:27 <lennart> or c#
09:34:28 <xerox> :P
09:34:58 <Oejet> xerox: Lalala.
09:35:01 <xerox> :D
09:35:21 <int-e> @karma c#
09:35:22 <lambdabot> c# has a karma of 0
09:35:24 <Oejet> ?google R rolling average
09:35:26 <lambdabot> http://www.rasmussenreports.com/2006/State%20Polls/May%202006/Washington%20Senate%20May.htm
09:35:27 <lambdabot> Title: Rasmussen Reports&trade;: Election Poll 2006 - Montana Senate
09:43:34 <lennart> @pl \ x -> f x >>= g
09:43:35 <lambdabot> (g =<<) . f
09:44:57 <lennart> not too ugly, I guess.  I still wish it was defined in the Monad module
09:46:46 <ChilliX> lennart: yeah
09:46:55 <ChilliX> I agree
09:47:05 <lennart> I need it all the time
09:48:09 <ChilliX> I also need it frequently
09:48:36 <lennart> we should make a petition for Haskell'
09:49:07 <lennart> But I've not come up with a good operator for it
09:49:53 <ChilliX> There are a couple of combinators that should be added IMHO.
09:51:38 <ChilliX> lennart: What are you hacking at, at the moment?
09:52:58 <lennart> just my bank job things
09:53:20 <lennart> i've not made any good haskell hacks in a while :(
09:54:16 <ChilliX> The bank taking over... ;)
09:57:59 <lennart> so does gtk+hs work on macos?
09:58:55 <xerox> lennart: yes. Except you get random bus errors if you use ghc 6.5.
09:59:14 <xerox> I am not sure if it is ghc causing them, tho.
09:59:17 <lennart> i'm not a great fan of random bus errors
10:00:40 <lennart> i have to find a new graphics toolkit for haskell.  wxhaskell feels mosty dead :(
10:01:05 <ndm> gtk2hs is being very actively developed
10:01:25 <yip> gtk2hs is pretty good
10:01:28 <ndm> i moved from wxhaskell to gtk2hs, once i noticed the rats starting to flea
10:01:43 <Igloo> I'm sure I can make you a patch to cause it to predictably bus error instead
10:02:56 <cm> are there ghc 6.5+ binaries for win32 with the new ghc debugger included?
10:05:27 <lennart> installation has begun...
10:10:29 <lennart> something is very broken in macosx; running 'top' uses 10% of the cpu
10:10:44 <ChilliX> urgh
10:10:57 <lennart> last time i saw top take 10% was a VAX/780 (which is about a 1MIPS machine)
10:11:51 <ChilliX> lol
10:12:35 <Lemmih> cm: No binaries, I'm afraid.
10:12:39 <ChilliX> Maybe it's macosx top with an OpenGL backend and weird animated characters in 3d?
10:13:05 <cm> Lemmih: aww :/
10:14:14 <lennart> chillix: maybe it is.  but it sure looks like plain old top to me.  and i started it in a terminal window
10:17:08 <lennart> hahaha, trying to install gtk2hs on the mac end with the message "GHC is not supported on OS X i386 yet"
10:17:29 <monochrom> haha
10:17:51 <lennart> i guess the installation thingy didn't try running ghc
10:18:54 <xerox> lennart: you have to use a ghc binary build and then compile gtk2hs from darcs, I think.
10:19:42 <lennart> well, i have ghc (binary & source) installed
10:20:03 <xerox> Then just darcsget gtk2hs
10:21:10 <lennart> but i get gtk2hs wants gtk installed
10:21:16 <lennart> s/get/bet/
10:21:25 <xerox> You can sudo port install gtk2
10:21:46 <xerox> If you sync darwinports you also get 2.10.2
10:21:53 <xerox> (Me have made pressure for that! :D)
10:22:00 <xerox> /me anyway.
10:38:32 <lennart> xerox: where's the gtk2hs repo?
10:38:54 <xerox> http://darcs.haskell.org/gtk2hs
10:38:56 <lambdabot> Title: Index of /gtk2hs
10:40:08 <lennart> too easy :)
10:42:32 <xerox> :D
10:43:44 <lennart> repos are supposed to be at some impossible to remember url at the end of a serial line in kazachstan
10:44:13 <xerox> Are you used to arch?
10:44:16 <xerox> Yuck.
10:44:49 <lennart> hah: "darcs failed:  Error applying hunk to file ./tools/c2hs/c2hs/tests/Calls.h"
10:44:56 <xerox> :(
10:45:01 <xerox> --partial ?
10:45:05 <lennart> i bet it's that hated non-case-sensitive file system again
10:45:10 <lennart> i'll try partial now
10:46:05 <lennart> better :)
10:46:43 <xerox> Yarrr!
10:47:58 <lennart> ah, but now the install of gtk2 has failed
10:48:06 <lennart> it's always like this :)
10:48:28 <xerox> It worked here.
10:48:35 <xerox> You did port sync recently?
10:48:58 <lennart> 10 minutes ago
10:49:02 <lennart> --->  Configuring gtk2
10:49:02 <lennart> Error: Target com.apple.configure returned: configure failure: shell command "cd "/opt/local/var/db/dports/build/_opt_local_var_db_dports_sources_rsync.rsync.darwinports.org_dpupdate_dports_x11_gtk2/work/gtk+-2.10.2" && LDFLAGS="-L/opt/local/lib -lpango-1.0" CPPFLAGS="-I/opt/local/include -no-cpp-precomp -DX_LOCALE" CFLAGS="-O3 -funroll-loops -fstrict-aliasing" ./configure --prefix=/opt/local --disable-shm --disable-gtk-doc --with-inclu
10:49:28 <xerox> :-/
10:49:55 <lennart> perhaps i should try upgrade
10:50:04 <xerox> I did upgrade in fact
10:50:13 <lennart> upgrade -a ?
10:50:30 <carp_> upgrade outdated
10:50:39 <xerox> sudo port upgrade gtk2
10:50:50 <xerox> It chases and upgrades the dependencies as well
10:50:57 <lennart> ah, excellent
10:51:11 <xerox> Except if you tell it to not do so, but you must do it explicitly
10:52:02 <lennart> haha, first pkg-config starts by upgrading itself :)
10:52:08 <xerox> Yep!
10:52:22 <xerox> pango, glib2, and a bunch of others
10:52:30 <xerox> port info gtk2 for the list of dependencies.
10:52:58 <lennart> i'll keep my fingers crossed
10:53:18 <xerox> :)
10:56:56 <carp_> you might want to do port clean --all gtk2 if something weird happened
11:03:27 <_spydr_> anyone here willing to help with a mac problem w/ ghc?
11:22:36 <lennart> woo woo!  gtk2 installed
11:23:37 <xerox> Roman Leshchinskiy mentioned yesterday that he managed to get GHC running SMP Data Parallel Haskell on a 32 cpu Sun E6900, with memory, 80G real and 500G swap (a bargain at somewhere around $250,000 US for this midrange server)
11:23:37 <xerox> Its fun watching GHC Haskell scale so well..
11:23:43 <xerox> From dons' blog.
11:30:26 <lennart> xerox: so now autoreconf fails for gtk2hs
11:30:36 <xerox> Nevermind warnings from it
11:30:55 <xerox> ...or does it not produce the configure file?
11:30:56 <lennart> well, it's an error.  and trying ./configure fails too
11:31:04 <xerox> @arr
11:31:04 <lambdabot> I want me grog!
11:31:41 <lennart> coxorange:~/Proj/ghc/gtk2hs lennart$ autoreconfconfigure.ac:117: error: possibly undefined macro: AC_MSG_ERROR
11:31:42 <lennart>       If this token and others are legitimate, please use m4_pattern_allow.
11:31:42 <lennart>       See the Autoconf documentation.
11:31:42 <lennart> autoreconf: /usr/bin/autoconf failed with exit status: 1
11:32:23 <lennart> and then configure:
11:32:25 <lennart> checking for ghc-pkg... /usr/local/bin/ghc-pkg
11:32:25 <lennart> ./configure: line 4054: syntax error near unexpected token `GLIB,glib-2.0'
11:32:25 <lennart> ./configure: line 4054: `PKG_CHECK_MODULES(GLIB,glib-2.0 >= 2.0.0 gobject-2.0 >= 2.0.0, , { { echo "$as_me:$LINENO: error:'
11:32:32 <xerox> What version of autoreconf do you have?
11:32:36 <xerox> 2.59 here
11:32:56 <lennart> 2.59
11:32:59 <xerox> :(
11:33:23 <xerox> Our gtk2hs build system expert, nonetheless the only person that understands it all, (arrr), is on vacation, sorry :(
11:33:31 <madpickle> @arr
11:33:31 <lambdabot> Avast!
11:34:29 <carp_> lennart: i think you might need to install a newer version of automake from darwinports
11:34:47 <int-e> AC_MSG_ERROR is a basic autoconf macro though, how could that be undefined? that's weird.
11:35:11 <lennart> i'll try upgrading automake
11:37:19 <lennart> ah, much more happiness
11:50:23 <lennart> is gtk2hs supposed to work with the new package naming in ghc 6.5?
11:53:53 <int-e> lennart: no. I've sent patches to the devel list that make it work, but duncan is out of town, and they break backward compatibility in various ways.
11:54:54 <int-e> lennart: anyway, the issue is known, and it will be fixed, but it's unclear right now how exactly. in the meantime you could grab those patches from the mailing list archives.
11:55:26 <lennart> and where is the archive?
11:56:53 <int-e> wait a second. actually you can grab http://int-e.home.tlink.de/haskell/gtk2hs-update-for-ghc-6.6.patch.gz
11:57:26 <lennart> thanks!
12:30:02 <gmak> hello
12:30:39 <jbalint> hey
12:30:58 <gmak> I would like to master Haskell it looks very interesting, could you show me around?
12:31:20 <jbalint> a little bit. there is a lot of material for beginners
12:32:16 <ricky_clarkson> gmak: Are you already a programmer?
12:32:22 <jbalint> hey ricky_clarkson
12:32:31 <gmak> hey ricky_clarkson
12:32:32 * ricky_clarkson JButton jbalint.
12:32:36 <gmak> yes
12:33:26 <ricky_clarkson> gmak: http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
12:33:34 <gmak> downloading
12:34:01 <ricky_clarkson> gmak: I am using that at the moment, it seems very good so far.
12:34:38 <gmak> lol seems like it
12:34:54 <gmak> I started liking this because of the syntax
12:35:01 <gmak> it looks like math
12:35:16 <gmak> is haskell able to do system - level programming?
12:35:23 <gmak> sorry for my newbieness
12:35:34 <ndm> gmak: define system level
12:35:36 <ricky_clarkson> I like it because of the FP concepts, as I'm learning those.
12:35:48 <gmak> ndm: sockets, filesystem i/o ecc
12:35:49 <ndm> but yes, people have written an OS and a file system in Haskell
12:35:54 <gmak> house i know
12:35:59 <gmak> i have not tested it yet
12:36:02 <ndm> gmak: ah, those things are all easy in Haskell
12:36:12 <ndm> readFile "my file"
12:36:12 <gmak> i find the concept very similar to Singularity
12:36:15 <ndm> that reads a file
12:36:37 <gmak> ndm: filesystem as in creating filesystems (could ext3 be implemented in haskell for example)
12:36:51 <ndm> gmak: halfs, a file system written in haskell
12:36:56 <ndm> so yes, it can
12:36:58 <gmak> excellent
12:37:00 <eivuokko> Writing a kernel-mode driver might be hard.
12:37:11 <gmak> you would read to write a kernel in haskel yes?
12:37:24 <gmak> do any of you know Spec#/Sing# related info
12:37:57 <gmak> hmm sorry of the ill - phrasing: have any of you heard of Spec# / Sing#
12:38:38 <ndm> haerd of it, but don't know that many details
12:38:44 <gmak> looks like microsoft is putting FP steroids there but better not go off - topic. Now, what about Haskell compilers
12:40:01 <zzxxcc> hi, all
12:40:03 <zzxxcc> 	fib :: Int -> Int
12:40:04 <zzxxcc>         fib 1 = 1
12:40:04 <zzxxcc>         fib 2 = 1
12:40:04 <zzxxcc>         fib x = fib(x-2) + fib(x-1)
12:40:40 <wilx> Wrong indentation?
12:40:53 <zzxxcc> this is a fibonacci number function
12:41:04 <zzxxcc> wilx: copy&paste error
12:41:09 <wilx> oook
12:41:17 <zzxxcc> the problem is that it is very slow
12:41:35 <zzxxcc> try fib(40), you will know what I mean
12:41:43 <sjanssen> zzxxcc: the algorithm has exponential time complexity
12:41:52 <zzxxcc> sjanssen: yeah
12:41:58 <ndm> gmak: what about them?
12:42:01 <lennart> the only point of using that algorithm is to make it slow :)
12:42:09 <jcreigh> zzxxcc: Also note that hugs is a *lot* slower than compiling with ghc...
12:42:15 <sjanssen> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
12:42:17 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
12:42:29 <sjanssen> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 40
12:42:30 <lambdabot>  102334155
12:42:36 <gmak> ndm: performance of the produced code in comparison to imperative languages like C/C++
12:42:37 <int-e> jcreigh: that won't cure an exponential time algorithm :)
12:42:48 <zzxxcc> sjanssen: yeah, I know this trick
12:42:59 <ricky_clarkson> gmak: The tutorial I pointed you at suggests O'Caml for performance.
12:43:03 <ndm> @where shootout
12:43:04 <lambdabot> I know nothing about shootout.
12:43:14 <wilx> @where shoutout
12:43:15 <lambdabot> I know nothing about shoutout.
12:43:19 <wilx> :)
12:43:21 <ndm> @google computer language shoot out
12:43:23 <lambdabot> http://shootout.alioth.debian.org/
12:43:32 <ndm> @where+ shootout http://shootout.alioth.debian.org/
12:43:32 <lambdabot> Done.
12:43:43 <ndm> gmak: that link, Haskell is pretty high up there
12:43:54 <ndm> one of the fastest languages
12:44:03 <ndm> and for some tests, concurrency, haskell blows everything away
12:44:04 <gmak> very interesting
12:44:06 <gmak> very
12:44:14 <psi> zzxxcc: http://www.kimbly.com/blog/000263.html
12:44:22 <psi> zzxxcc: that one is pretty cool
12:44:29 <zzxxcc> My question is, because haskell functions have no side-effect, it is possible for the haskell compiler to cache the fib(x) return value. If the haskell compiler can do this, than my first solution is acceptable.
12:44:46 <zzxxcc> s/than/then
12:44:57 <sjanssen> zzxxcc: yes, a compiler could do that if it wanted to
12:45:00 <int-e> zzxxcc: it does not do that automatically.
12:45:15 <psi> why doesn't it?
12:45:18 <int-e> the standard trick to get caching is to use a list
12:45:24 <lispy> zzxxcc: it could, but it turns out that most of the time it's not a good idea, so it's generally not done automatically
12:45:29 <psi> like the link i pasted above
12:46:05 <int-e> psi: because caching can cause space leaks.
12:46:24 <sjanssen> psi: that algorithm has crummy time performance
12:46:36 <int-e> psi: well, caching - there's no caching as such implemented in ghc. 'caching' would mean keeping the values around, pretty much forever.
12:46:59 <gmak> ricky_clarkson: ndm: thanks i will start reading your materials with great interest
12:47:09 <psi> sjanssen: it does? it worked fast when I tried it, but I didn't time it for very large numbers.
12:47:19 <sjanssen> computing the nth fibonacci with that algorithm is O(n ^ 2)
12:47:33 <psi> int-e: maybe it could throw away results after a while
12:47:34 <sjanssen> the zipWith algorithm is better
12:47:37 <int-e> sjanssen: which? the naive recursive one?
12:47:38 <psi> sjanssen: not with caching?
12:47:53 <sjanssen> psi: with caching it is O(n ^ 2)
12:48:03 <lennart> and there are better algorthims if computing large fibonacci numbers is really what you want
12:48:06 <psi> okay
12:48:28 <int-e> psi: maybe. it's hard to get right, it's hard to get efficient, and if the programmer wants it, he's better off being explicit about it most of the time.
12:48:49 <int-e> sjanssen: oh, the one in the link above.
12:49:04 <sjanssen> int-e: yeah
12:50:53 <zzxxcc> And I think my first solution is equ. with let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
12:51:08 <zzxxcc> GHC is just not clever enough to see it
12:51:32 <lennart> all definitions of the fib function are equal (if they are correct)
12:51:43 <ricky_clarkson> Does Haskell's laziness depend on its purity?
12:51:51 <lennart> so how much cleverness do you expect?
12:52:01 <ricky_clarkson> I.e., could you have a lazy result in a language with side effects?
12:52:07 <sjanssen> should GHC translate bubble sort to merge sort?
12:52:10 <ricky_clarkson> ..without possible corruptions.
12:52:14 <araujo> yes ricky_clarkson
12:52:16 <lennart> you can, but it's very messy
12:52:44 <ricky_clarkson> lennart: To me?
12:53:34 <lennart> yes.  laziness and side effects can be mixed.  but it's a very difficult language to use
12:53:37 <araujo> we use lazy here, for the evaluation order.
12:53:54 <ricky_clarkson> araujo: What do you mean?
12:53:55 <lennart> people who have tried it generally regret it :)
12:54:01 <lispy> ricky_clarkson: ocaml has a lazy module
12:54:09 <sjanssen> zzxxcc: I recall reading a paper about a "memo" combinator that can transparently memoize calls to a function.  I think that is better than a general compiler optimization
12:54:20 <lispy> ricky_clarkson: but, i would imagine that code in the lazy module must be ure
12:54:41 <psi> hehe. the zipwith solution really spanks it with n = 10000.
12:54:48 <ricky_clarkson> Does FP pretty much depend on tail-recursion optimisation to scale?
12:54:53 <psi> it's more than 10 times as fast.
12:54:55 <lispy> psi: oh yeah, but then profile for memory usage too :)
12:54:59 <araujo> ricky_clarkson, http://en.wikipedia.org/wiki/Lazy_evaluation
12:55:01 <araujo> now, brb
12:55:35 <lispy> ricky_clarkson: well, i suppose so.  It sure helps out
12:56:25 <lennart> ricky_clarkson: it would be difficult to make an infinite "loop" without tail recursion optimization
12:56:51 <ricky_clarkson> Infinite loops are an error anyway, logically.
12:57:08 <lispy> really?
12:57:46 <xerox> It surely depends on the evaluation mechanism.
12:57:46 <lennart> so make that a very long loop then. :)
12:57:52 <ricky_clarkson> Heh.
12:57:57 <eivuokko> ricky_clarkson, Only if they are part of the proof?  Practical programs rarely are proofs.
12:58:09 <xerox> Programs are proofs!
12:58:33 <int-e> please extract the proof from   main = putStrLn "Hello, world."
12:58:43 <xs> IO ()
12:59:02 <ricky_clarkson> The proof is in the pudding, anyone knows that.
12:59:04 <lispy> i would agree that an algorithm shouldn't have an infinite loop, but then don't we ask computers to do a lot of non-algorithm work these days?
12:59:08 <Heffalump> it proves that a computer can print "Hello, world." - duh
12:59:42 <ricky_clarkson> What's the use of an infinite loop without side effects?
13:00:00 <Heffalump> it has side effects, it'll consume CPU cycles
13:00:10 <Heffalump> your computer will get hotter
13:00:17 <lennart> you can view non-termination as an effect
13:00:20 <xerox> > let odds = 1 : map (+1) evens; evens = map (+1) odds in take 10 $ zip odds evens
13:00:21 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20)]
13:00:26 <xerox> This is purely functional, isn't it?
13:00:44 <ricky_clarkson> Ok..
13:00:47 <xs> no, you can see the results, there's an implicit print.
13:00:52 <araujo> back!
13:01:13 <Heffalump> lennart: only if you view computation time as an effect, surely?
13:01:18 <ricky_clarkson> But if you don't print the result, there is no evaluation, no loop.
13:01:39 <araujo> ricky_clarkson, no
13:02:00 <araujo> printing to something is a 'side effect'
13:02:03 <xerox> Okay...
13:02:38 <xerox> ?wiki Roman_numerals
13:02:38 <lambdabot> http://www.haskell.org/haskellwiki/Roman_numerals
13:02:39 <xerox> :type powersoftwo -- what about that?
13:02:44 <lennart> heffalump: well, some people like to view the lifting monad as one of the effectful ones
13:02:55 <xerox> Hmm, nothing infinite about it possibly, though...
13:03:15 <ricky_clarkson> Ok..
13:03:28 <xerox> But I suppose you can write that evens and odd code in the type system, can't you?
13:03:34 <xerox> Maybe the question is something else.
13:03:43 <ricky_clarkson> So in code that has side effects, tail-recursion optimisation will be useful.
13:03:50 <sjanssen> xerox: the type system doesn't do lazy evaluation
13:04:19 <xerox> Why side-effects?
13:04:48 <ricky_clarkson> xerox: Because code that has no side effects will not usually recurse that deeply.
13:04:57 * ricky_clarkson runs out of logic.
13:04:59 <sjanssen> ricky_clarkson: tail recursion is quite necessary for plenty of pure functions
13:05:02 <jcreigh> ricky_clarkson: Tail-recursion optimization is a useful for writing programs in terms of recursive functions, regardless of whether or not the language has side effects.
13:05:04 <lennart> tail-recursion optimization is necessary with effects or not.  you'd soon run out of stack otherwise
13:05:15 <xerox> Three explanations :)
13:06:03 <ricky_clarkson> So without tail-recursion optimisation you may as well do normal imperative programming for many cases.
13:06:06 <araujo> ricky_clarkson, stop confusions. Think of tail-recursions like the equivalents of loops.
13:06:12 <eivuokko> I don't understand why tail recursion is an optimisation.  There is nothing less natural about jumps than calls, is there?
13:06:15 <ricky_clarkson> araujo: Yes, I get that.
13:06:30 <ricky_clarkson> eivuokko: The traditional approach is to hammer the stack.
13:06:39 <lightstep> eivuokko, it adds another rule to the operational semantics
13:06:39 <ricky_clarkson> Traditional=C, Java etc.
13:06:41 <gmak> bbk
13:07:07 <xerox> eivuokko: tail-call optimization is the optimization of tail calls that swap the values of the tail-called function every time it recurse instead of pushing them in the stack at every run.
13:07:18 <jcreigh> eivuokko: Because we normally run programs on machines that only do jumps. Calls have to be simulated.
13:07:24 <ricky_clarkson> eivuokko: The optimisation makes FP code compile to imperative code, to some extent.
13:07:30 <eivuokko> xerox, I know very well what they are.
13:07:59 <xerox> Oh, okay. Tail recursion per-se isn't an optimization if your compiler doesn't provide tail-recursion optimization.
13:08:42 <xerox> I wonder if we care much about this particular optimization because we don't know the other ones our mighty compiler code does on our code :D
13:09:08 <lennart> oh, we care about that one
13:09:31 <lennart> the Scheme standard even mandates that a Scheme implementation must to tail calls properly
13:09:34 <ricky_clarkson> Maybe that is the limiting factor that stops you from doing FP code in Java.
13:09:35 <eivuokko> lightstep's explanation was the only one that actually answered my question.
13:10:14 <xerox> lennart: right, and the CL one doesn't, newcomers ask all the time.
13:11:55 <Frederick> hello folks
13:12:03 <xerox> Hi.
13:13:22 <Frederick> ski, are you around? :)
13:15:16 <lennart> xerox: the "bus error" when i run a gtk2hs program is totally reliable :(
13:15:29 <xerox> Sigh.
13:15:38 <xerox> lennart: the only demo working for me is the cairo clock.
13:15:48 <lennart> ah, i'll try that
13:15:51 <xerox> http://darcs.haskell.org/~paolo/tmp/osxcairoclock.png
13:16:42 <tibbe> could someone give a quick explanation or link to one for functional reactive programming? The explanation I found wasn't very good... ;) "Functional Reactive Programming is a paradigm for reactive programming in a functional setting."
13:17:10 <xs> http://www.haskell.org/yampa/ ?
13:17:11 <lambdabot> Title: Yampa
13:17:37 <lennart> xerox: nice clock!
13:18:03 <xerox> A bit broken, but nicely looking.
13:18:23 <xerox> The C one we copied had evolved in the meanwhile, so it looks even better :)
13:18:41 <lennart> xerox:  oops, i clicked a bit on it and got an assertion failure
13:18:54 <xerox> (It now uses SVG for the clock parts so it is easily themable.  We also have got svg support, but we didn't update the code.)
13:19:03 <xerox> I could move it around and resize it in fact.
13:20:19 <lennart> so, the short version of gtk2hs status on macos is that it's currently useless?
13:20:34 * ricky_clarkson goes to DJ.  Thanks for the conversation.. you guys always give me food for thought.
13:21:06 <xerox> Have fun ricky_clarkson!
13:21:15 <xerox> lennart: I think so, if you want to investigate more...
13:21:35 <lennart> i'm not desperate, so i can wait a while
13:21:41 <ndm> lennart: with gtk2hs, regular complaining does get you somewhere
13:21:51 <ndm> esp. posting publically about its failings
13:21:52 <xerox> Except when Duncan is on vacations :)
13:22:05 <ndm> ah, thats going to be an issue then...
13:22:05 <xerox> Just kidding.
13:22:48 <lennart> i'm not really complaining, i just wanted to know what the situation is right now
13:23:28 <ndm> complaining is the way to go, really
13:38:37 <gmak> back
13:38:56 <xerox> ?yow
13:38:56 <lambdabot> I feel better about world problems now!
13:45:08 <coffeemug> hey everyone
13:45:39 <coffeemug> I have some questions about manipulating state in Haskell
13:46:20 <coffeemug> in particular, is Control.Monad.State a preferred mechanism to attach state to a computation or is it better to write one for a specific situation?
13:47:00 <xerox> If you need update-able state, State is a good way to get that
13:47:27 <Heffalump> Control.Monad.State is a good choice
13:47:29 <coffeemug> ok
13:47:33 <coffeemug> that's what I'm using
13:47:37 <xerox> If you only need environment, you can use the Reader monad.  Dually, if you only need a way to log, you can use the Writer one.
13:47:48 <Heffalump> I find it a bit inconvenient that it's hard to stack multiple instances of State and use both of them.
13:47:52 <xerox> (If you smooch together Reader and Writer you get State.)
13:47:57 <Heffalump> But apart from that, it's very easy to use
13:48:02 <Heffalump> xerox: how would you put them together?
13:48:21 <coffeemug> so basically I first wrote some code that returned and took state explicitly
13:48:28 <coffeemug> and now I'm trying to convert it to use the state monad
13:48:33 <xerox> Heffalump: as Control.Monad.State.
13:48:33 <coffeemug> and I'm running into some issues
13:48:44 <coffeemug> which I suppose all newbies run into :)
13:49:02 <coffeemug> so first of all
13:49:15 <coffeemug> suppose I'm writing a calculator that allows me to declare variables
13:49:25 <coffeemug> so I can do i = 5
13:49:26 <xerox> shapr has some numbered haskell modules that step through the process, meant as tutorial...
13:49:29 <coffeemug> i + 3
13:49:59 <coffeemug> and from calculation to calculation I need to keep state with the variables, obviously
13:50:10 <coffeemug> now, if I want to write an interactive prompt
13:50:16 <coffeemug> I need to combine two monads
13:50:18 <coffeemug> IO and State
13:50:38 <coffeemug> and for that I use StateT in order to "wrap" the IO monad in it
13:51:07 <Heffalump> xerox: oh, I thought you meant that you can put them together and get something isomorphic to State
13:51:16 <coffeemug> that works, but my problem with that is that my "eval" function has to know that state will be used with IO within it
13:51:17 <Heffalump> whereas I think thecombination of Reader and Writer is strictly weaker
13:51:50 <coffeemug> and that sucks because if I want to use the eval function elsewhere without IO
13:51:57 <Heffalump> coffeemug: why does it need to know it'll be used with IO?
13:52:16 <coffeemug> Heff: well, when I declare its type
13:52:20 <Heffalump> it could just unwrap the StateT
13:52:28 <coffeemug> eval :: Expr -> StateT Variables IO Expr
13:52:39 <Heffalump> why not have it be of type Monad m => StateT Variables m Expr -> m ()
13:52:39 <xerox> Heffalump: (e ->) + (-> (a,w)) =~= (s -> (a,s))
13:52:43 <coffeemug> note that IO has to bee in that declaration
13:52:57 <xerox> (+) = smooch :P
13:53:01 <Heffalump> I don't understand that type of eval. What does it actually do?
13:53:09 <Heffalump> xerox: right...
13:53:13 <Heffalump> is that like magic? ;-)
13:53:41 <coffeemug> that eval takes an expression, evaluates it, and returns the state
13:53:43 <xerox> Heffalump: ok, you don't do that algorithmically, that's why I used the word smooch. But it's a nice way of explaning the thing I think.
13:53:51 <Heffalump> oh, actually, Writer is isomorphic to State, if you return state transforming functions and function composition
13:53:51 <yip> eval :: Expr -> CalcState -> (CalcState, result)
13:54:25 <coffeemug> right
13:54:26 <Heffalump> coffeemug: ah, ok. So you use runStateT somewhere later?
13:54:47 <coffeemug> so before eval was like so - eval :: Expr -> State -> (State, Expr)
13:55:02 * Heffalump is being silly, actually, that's just the same type the eval function for the intepreter I'm working on right now has :-)
13:55:03 <coffeemug> which took expression and a state
13:55:17 <coffeemug> and returned an evaluated expression along with the new state
13:55:32 <Heffalump> ok, so eval does need to know about IO, because some of the elements of Expr are fundamentally IO based, right?
13:55:49 <Heffalump> or are they?
13:55:49 <coffeemug> no
13:55:56 <coffeemug> not yet, anyway :)
13:56:03 <coffeemug> it's just that I use eval in my main block
13:56:04 <Heffalump> in that case, why not have eval :: Monad m => Expr -> StateT Variables m Expr
13:56:05 <coffeemug> so like in main
13:56:08 <coffeemug> I read a line
13:56:52 <coffeemug> ahh, I see
13:56:53 <Heffalump> I bet if you changed the type signature to say that it'd work.
13:57:03 <Heffalump> and if it doesn't, the type error will help you see why
13:57:08 <coffeemug> I see
13:57:24 <coffeemug> but conceptually it doesn't make sense to me
13:57:33 <coffeemug> I'm just writing a function with state
13:57:40 <coffeemug> why does it need to know about how it will be used?
13:57:53 <coffeemug> even though I don't need to say IO explicitly, I can say Monad a => a
13:58:01 <Heffalump> what do you mean "know how it will be used"?
13:58:11 <coffeemug> like
13:58:16 <coffeemug> I would think that IO needs to wrap State
13:58:19 <coffeemug> not the other way around
13:59:00 <Heffalump> IO isn't a monad transformer (and can't be, how would you use it to transform backtracking?)
13:59:51 <coffeemug> right
13:59:59 <coffeemug> hmm ok, so then
14:00:05 <coffeemug> the next thing I don't understand
14:00:07 <coffeemug> is lifting
14:00:20 <coffeemug> it's pretty simple when I have one monad wrapping another
14:00:23 <coffeemug> but if I have more
14:00:28 <coffeemug> can I assign names to them or something?
14:00:33 <Heffalump> names to what?
14:00:40 <coffeemug> to the monads
14:00:41 <Heffalump> StateT etc are instances of MonadTrans
14:00:46 <Heffalump> so you can generally just use lift
14:00:57 <Heffalump> are you planning on having multiple StateTs?
14:01:00 <coffeemug> right, but I have 5 monads wrapping each other in one do statement
14:01:23 <coffeemug> I'll get confused by the lifts very quickly
14:01:27 <Heffalump> you should only need one lift
14:01:41 <coffeemug> well
14:01:45 <coffeemug> when I do a <- get
14:01:51 <coffeemug> how can it know which monad I am talking about?
14:02:05 <Heffalump> if you do a <- get, it won't know unless StateT is the topmost Monad
14:02:12 <Heffalump> but if you do a <- lift get
14:02:21 <Heffalump> it will know, by the magic of type classes
14:02:30 <Heffalump> oh, wait
14:02:36 <coffeemug> right, but if I have state within a state within a state
14:02:51 <coffeemug> how will it know which *state* I want to get?
14:02:51 <Heffalump> ok, if you have state within a state within a state, you are basically stuffed with StateT, IMO
14:02:59 <Heffalump> (see what I said above)
14:03:08 <Heffalump> s/see what/as/
14:03:19 <coffeemug> hmm
14:03:23 <coffeemug> could you explain again?
14:03:27 <Heffalump> actually, I think even with lift you have to use the correct number of instances.
14:03:44 <Heffalump> It's just the problem you are saying yourself - there is no way to name the nested transformers, so it is hard to refer to the one you really mean.
14:03:56 <coffeemug> right
14:03:59 <coffeemug> which is my question
14:04:01 <Heffalump> actually, ignore what I said about lift. It's a red herring.
14:04:06 <coffeemug> is there an elegant way to do this in Haskell?
14:04:10 <Heffalump> get is in a type class, so a <- get *does* work.
14:04:19 * Heffalump had some ideas about using a phantom type to do it.
14:04:26 <Heffalump> I haven't actually tried them yet to see if they work.
14:05:02 <Heffalump> partly cos it'd require rewriting all the transformers in Control.Monad.
14:05:23 <coffeemug> ok, so back to the original question
14:05:35 <coffeemug> if in the calculator functions are first class objects
14:05:40 <coffeemug> that I can assign to variables
14:05:41 <Heffalump> the real problem is the functional dependency in 'class Monad m => MonadState s m | m -> s where'
14:05:43 <coffeemug> and stuff like that
14:05:58 * Igloo makes lifting functions like get using a MonadTrans instance, a concrete instance and overlapping instances
14:06:30 <coffeemug> my expression data type has an ExprInteger constructure, ExprSymbol and ExprFunction
14:06:54 <coffeemug> ExprFunction in this case takes a list of parameters and returns a result along with a state that it might have modified
14:07:05 <Heffalump> Igloo: so it figures out which level is wanted by the type of the state etc?
14:07:27 <Igloo> No, I newtype all the standard monad transformers
14:07:39 <coffeemug> so ExprFn ([Expr]->StateT VarContext a Expr)
14:07:46 <Heffalump> oh, and then make your own get for each one?
14:07:51 <Igloo> Yup
14:08:01 <Heffalump> why do you need overlapping instances then?
14:08:01 <coffeemug> now my Expr datatype must be dependent on a
14:08:21 <Heffalump> oh, cos otherwise you'd need a type class per new transformer
14:08:51 <Heffalump> coffeemug: if you are going to let people have impure functions, you have no choice.
14:09:08 <Igloo> Because I have a MonadTrans instance and an instance for a particular monad transformer
14:09:16 <Heffalump> but do your functions really need access to the underlying monad as well as to the state?
14:09:28 <Igloo> I don't think a new class would help, unless I manually wrote quadratically many instances
14:09:38 <Heffalump> Igloo: yes, that's what you'd have to do.
14:11:20 <coffeemug> see, that's the thing
14:11:29 <coffeemug> the Expr doesn't need access to IO
14:11:34 <coffeemug> or any of that stuff
14:11:40 <coffeemug> which is why I am asking the question
14:11:46 <coffeemug> it seems like I'm doing something wrong
14:11:54 <Heffalump> ok. Then make ExprFn ([Expr] -> StateT VarContext Identity Expr)
14:12:11 <lispy> but, the primitives for the inperpreter do need access to IO right?
14:12:28 <coffeemug> lispy: well, that would be the next step
14:12:30 <Heffalump> and use (mapStateM (return.runIdentity)) inside eval to turn the function into the right type for use in eval.
14:12:53 <lispy> coffeemug: what will you be interpreting?
14:13:05 <lispy> coffeemug: your own language or an existing language/
14:13:11 <coffeemug> lispy: just some simple math functions
14:13:28 <coffeemug> lispy: I'm doing a very simple lisp interpreter, but for now it's just + - and so on
14:13:39 <Heffalump> btw, I would recommend separating your expression domain from your value domain
14:13:42 <lispy> coffeemug: cool
14:13:55 <Heffalump> i.e. have Expr -> StateT VarContext m Val be your basic evaluation type
14:13:57 <coffeemug> Heff: so that would let me use eval with IO later on?
14:14:05 <Heffalump> coffeemug: yes
14:14:48 <Heffalump> well, I think so, I haven't done this myself or tested it
14:14:50 <Heffalump> but I don't see why not
14:15:25 <coffeemug> hmm
14:15:32 <coffeemug> isn't there some generic way to combine monads
14:15:40 <coffeemug> so I can just use State instead of StateT
14:15:47 <coffeemug> and then use something to combine State with IO
14:16:00 <Heffalump> no
14:16:22 <Heffalump> there's a theoretical paper on doing it, but it relies on some properties of the underlying monads
14:16:37 <Heffalump> and noone has implemented it (and when I had a look at it I didn't even understand _how_ to implement it)
14:19:15 <ndm> anyone know any papers about how to implement boolean predicates?
14:19:37 <ndm> i.e. i have a predicate (a v b) ^ (a => c)
14:19:38 <lispy> ndm: what do you mean?
14:19:53 <ndm> and want to do things like ^ and v two predicates
14:20:01 <ndm> check if they are true/false
14:20:30 <ndm> where there might be certain properties known, for example  a v b = d, or something
14:20:32 <lispy> ndm: you mean, you want to check boolean expressions for tautology and such?
14:20:56 <coffeemug> ok
14:21:01 <coffeemug> thanks guys
14:21:02 <ndm> lispy: yes, ultimately, but for the vast majority of the time i'll be dealing with expressions which don't have a tautology
14:21:16 <ndm> i.e. i hope they may one day reduceto a tautology
14:21:26 <ndm> after being combined in loads of ways
14:21:36 <lispy> ndm: so just for the most part you do boolean expression simplification?
14:21:46 <ndm> lispy: currently, yes
14:22:01 <lispy> ndm: seems like it wouldn't be too hard to do with pattern matching..i think i did this one with my mail filtering language
14:22:31 <ndm> its easy enough to implement, and in fact I have: http://www.cs.york.ac.uk/fp/darcs/catch/src/Data/Predicate.hs
14:22:37 <lispy> And (Var "a") (Var "b") = ...
14:22:42 <lispy> oh
14:22:46 <ndm> its just a question of efficiency and spotting all the optimisation opportunities
14:22:47 <lispy> then what are you asking for again?
14:23:06 <ndm> i half suspect that there might be some kind of underlying data structure
14:23:11 <ndm> which "is clever"
14:23:38 <ndm> i am kind of asking if there is anything cleverer than data Pred a = PredAnd [a] | PredOr [a] | PredLit a
14:23:48 <Igloo> You might want BDDs
14:23:53 <ndm> which has plenty of disadvantages
14:24:29 <Igloo> http://en.wikipedia.org/wiki/Binary_decision_diagram (no idea if that's a good reference or not, and I don't know much about them myself)
14:24:37 <ndm> Igloo: good point - have seen them used for model checking before
14:24:56 <Heffalump> bit of a pain to implement in Haskell though
14:25:03 <Heffalump> and you need a finite domain to encode forall and exists
14:25:19 <Heffalump> CNF and DNF are possibilities too
14:25:33 <ndm> I have taken a look at CNF and DNF
14:25:55 <ndm> i'm currently trying to impelement a clever DNF version, with a lookup table mapping variables to Int's
14:26:03 <ndm> (since the predicate literals are relatively complex)
14:26:05 <Heffalump> BDDs are really quite clever
14:26:47 <ndm> hmm, the biggest problem in BDD's will be picking the right variable ordering, i think
14:27:09 <Heffalump> just pick one arbitrarily
14:27:14 <Heffalump> if they start blowing up, then worry about it
14:27:23 <ndm> i guess so
14:27:25 <Heffalump> do your quantifiers have finite domains?
14:27:38 <ndm> are operations like And and Or directly expressible in BDD's?
14:27:50 <Heffalump> or do you not have quantifiers? (In which case I think you mean propositions, not predicates)
14:27:51 <lennart> BDD's also become rather comprehensible when done in Haskell.  Like 50 lines of code.
14:27:55 <Heffalump> well, they have a direct encoding, certainly
14:28:15 <Heffalump> lennart: but you presumably need to use some state monad?
14:28:19 <ndm> i don't have quantifiers
14:28:31 <ndm> well i do, but at a different level, so they are isolated from this, i think
14:28:34 <lennart> No need for a state monad in the external interface
14:28:44 <lennart> internally you need a bit of state
14:29:12 <Heffalump> lennart: how can you avoid a state monad for the external interface if you want sharing between different expressions?
14:29:18 <Heffalump> (short of using unsafePerformIO etc)
14:29:45 <lennart> I didn't care about sharing in my implementation
14:29:50 <Heffalump> oh, ok
14:30:02 <Heffalump> but then you don't get a cheap equality test
14:30:08 <Heffalump> which is one of the really neat things about BDDs
14:30:11 <Heffalump> (IMO)
14:30:19 <ndm> cheap equality would be very nice
14:30:25 <lennart> it was not one of the operations I needed
14:30:28 <ndm> lennart: do you have any code around?
14:30:46 <lennart> my code is (was) part of the bluespec compiler
14:30:48 <Heffalump> ndm: it's worth implementing yourself just so you really understand how they work
14:31:03 <Heffalump> did something happen to the bluespec compiler, then?
14:31:05 <ndm> Heffalump: i couldn't care less how it works - I just want it to work! :)
14:31:24 <lennart> they are now using a BDD package written in C
14:31:27 <Heffalump> fair enough, though they are worth understanding :-)
14:31:38 <Heffalump> you could just use BuDDy or some other pre-existing BDD package, of course.
14:31:44 <lennart> they are certainly worth understanding
14:31:46 <Heffalump> but I don't know of any with a Haskell interface
14:31:48 <ndm> i'd rather stick to upre haskell
14:32:00 <ndm> since my code changes quite rapidly
14:32:20 <ndm> and what i described is a slight simplification of what i need to do
14:32:40 <lennart> I should write a short note with a haskell implementation.  they are not as compilcated as most papers make them out to be.  the complications arise when you try to make everything as efficient as possible
14:32:41 <Heffalump> google finds me http://www.cs.chalmers.se/~qiao/papers/BDDs/
14:32:43 <lambdabot> Title: Index of /~qiao/papers/BDDs
14:33:11 <Heffalump> even the source code of BuDDy, which is a fairly optimised implementation, isn't hard to understand.
14:34:15 <Heffalump> http://www.cs.nott.ac.uk/~nhn/TFP2006/Papers/09-ChristiansenHuch-APurelyFunctionalImplementationOfROBDDs.pdf
14:34:43 <Heffalump> http://www.cs.bris.ac.uk/~bradley/publish/bdd/
14:34:45 <lambdabot> Title: Binary Decision Diagrams - A Functional Implementation
14:34:47 <ndm> Heffalump: woot! that looks great!
14:34:55 * Heffalump is now bored of churning out google results ;-)
14:35:12 <Heffalump> and I still think it'd be good for your soul if you wrote your own ;-)
14:35:54 <lennart> ah, things have improved on the Haskell BDD front in tghe last 5 years, I see :)
14:36:06 <ndm> we'll see, i might still write my own
14:36:26 <ndm> or use my own DNF solver, since there are certain properties in my variables
14:36:42 <ndm> i.e. a => b, which i can tell from the structure of the variables, and would like to make use of
14:37:07 <ndm> although its feasible that in a BDD that can be propagate anyway
14:37:20 <Heffalump> yes, just conjoin it with all your predicates
14:37:35 <Heffalump> if you know some properties A, B, C
14:37:41 <Heffalump> and you have some predicates X, Y, Z
14:38:17 <Heffalump> then under those properties, equivalence of X and Y is the same as equivalence of (A ^ B ^ C ^ X) and (A ^ B ^ C ^ Y) with no preconditions
14:38:43 <Heffalump> I think I mean ^, anyway.
14:38:53 <ndm> i don't want equivalence, of expressions like that, more tautology
14:39:06 <Heffalump> tautology and equivalence are rather closely related :-)
14:39:08 <ndm> which is what the properties help to acheive
14:39:35 <Heffalump> X == Y iff (X ^ Y) v (!X ^ !Y) is a tautology
14:39:42 <Heffalump> and X is a tautology if X == true
14:40:22 <ndm> yeah
14:40:32 <Heffalump> and if you use a single global BDD table to store all your expressions, equivalence is a constant-time operation
14:40:34 <ndm> i'll see if it looks like BDD's get anywhere
14:49:19 <lokadin> say, i remmber there was someone here that was making a more advanced typing system
14:49:44 <lokadin> some different language actually
14:49:54 <lokadin> they were designing if i recall correctly
14:49:59 <ndm> thats probably quitea  few people in here :)
14:50:11 <lokadin> lol :)
14:50:13 <lokadin> hmmm
14:50:45 <lokadin> well i would really like to look at a few
14:51:10 <ndm> Epigram, Cayenne
14:51:21 <lokadin> kk thanks :)
14:51:28 <ndm> DML (Dependant ML)
14:51:34 <ndm> Omega
14:51:52 <ndm> Omega (Tim Sheard, or googling might be hard)
14:55:29 <yip> does tim sheard visit this channel?
14:58:30 <ndm> not as far as i know...
14:59:00 <ndm> well the good news is it looks like BDD's can do some good stuff with my algorithm!
15:00:51 <lokadin> bdd's?
15:01:04 <xerox> What can I suggest to a guy who wants a clear explanation of the distinction between Type Constructor, Data Constructor, Type, Value, Function, and whatnot?
15:01:19 <xerox> Something he can download because he's in a foreign country and has limited internet :D
15:01:30 <xerox> I learnt it all here, so I don't know of some paper....
15:02:01 <Korollary> the gentle intro?
15:02:33 <ndm> halle dume's one is a pdf, i think
15:02:42 <xerox> Oh, I'll tell him of that
15:02:47 <xerox> Yeah he has YAHT
15:10:43 <ndm> lokadin: binary decision diagrams, from an older conversation
15:15:14 * edwardk waves hello.
15:15:22 * Korollary throws corporate red tape at edwardk 
15:15:50 * edwardk attempts to dodge, gets tangled up and returns to his desk - a mindless drone.
15:18:32 * Korollary promotes edwardk to improve synergy and utilize intellectual assests of this thriving enterprise.
15:18:54 <Korollary> Parse that, bitch.
15:19:04 <int-e> you made a typo
15:19:23 <Korollary> was caught up in the moment
15:19:36 <Korollary> I didn't spit on anybody, did I?
15:34:53 <lennart> so quiet here
15:36:01 <xerox> Sssssshh
15:42:06 <lennart> but i want a heated debate over what operator to use for klesli composition!
15:42:54 <profmakx> o.O
15:43:25 <xerox> Maybe just have a drink and relax today....
15:43:34 <profmakx> oh wait
15:43:48 <profmakx> was it something about category theory?
15:44:02 <xerox> This whole channel is something about category theory.
15:45:21 * edwinb walks in, notes that someone has said the 'C' word, and runs away again
15:45:27 <lennart> how can haskell claim to be a functional language that supports monads when there's no operator to compose monadic functions?  huh?  it's a disgrace!
15:45:53 <xerox> :(
15:46:36 <lennart> all haskell programming must cease immediatly!
15:46:47 <xerox> We've got a problem.
15:46:48 * edwinb complains to his MP about it
15:46:55 * xerox waves to edwardk 
15:46:59 <xerox> edwinb, yarr.
15:47:13 <edwinb> yarr!
15:47:16 <profmakx> o.o
15:47:34 <xerox> I heard you are the author of whitespace.... I didn't know at the time we talked together in real life.
15:47:41 <edwinb> hehe
15:47:44 <xerox> I would have punch^Wprod you!
15:47:52 <edwinb> that will haunt me forever, I fear
15:48:05 <profmakx> no really?
15:48:06 <xerox> I'm telling evereybody
15:48:12 <profmakx> *twitch*
15:48:15 <xerox> I mean everybody
15:48:15 <lennart> all programming should switch over to whitespace at once!
15:48:27 <profmakx> whitespace standard library?
15:48:41 <lennart> with whitespace there's no way to tell what operators are missing!
15:48:42 <profmakx> i will implement template-whitespace! thatll be fun
15:48:42 <edwinb> whitespace doesn't have an operator to compose monadic functions either...
15:48:49 <xerox> @spell compressable
15:48:50 <edwinb> but then it never claimed to be a functional language
15:48:51 <lambdabot> compressible compress able compress-able compensable impressible
15:48:56 <xerox> Surely it is easily compressible.
15:49:02 <dbremner> xerox- there's always this proposal for C++. http://www.research.att.com/~bs/whitespace98.pdf#search=%22bjarne%20whitespace%22
15:49:37 <xerox> You also fell on the google link comment pollution...
15:50:07 <lennart> ah yes.  i like bjarne's overloading proposal
15:50:17 <edwinb> yes, that was fun :)
15:51:13 <dbremner> lennart- there's always Damian's Acme::Bleach module
15:51:40 <lennart> hmmm, gotta look that up
15:52:28 <yip> what's the difference between haskell and lisp?
15:52:35 <dbremner> lennart-http://search.cpan.org/dist/Acme-Bleach/lib/Acme/Bleach.pm
15:52:36 <lambdabot> Title: Acme::Bleach - For really clean programs - search.cpan.org
15:52:44 <xerox> > "haskell" - "lisp"
15:52:45 <lambdabot>  add an instance declaration for (Num [Char])
15:52:45 <lambdabot>   In the definition of `cta'...
15:52:51 <xerox> You ought to define that instance first...
15:52:54 <lennart> yes, i'm looking at it.  looks good
15:54:21 <yip> what is `cta' supposed to mean?
15:54:47 <lennart> Acme::DWIM looks interesting too
15:54:51 <xerox> It's a random name for the expression I typed in
15:55:04 <Tela> Does anyone know a good way to change an integer to a list of its digits? It feels like a one-liner, but I'm having such difficulty with it....
15:55:13 <edwinb> Acme::DWIM sounds worrying
15:55:38 <dbremner> lennart- there's also Lingua::Romana::Perligata
15:55:39 <xerox> Tela: show it
15:55:47 <lennart> > map digitToInt (show 123456)
15:55:48 <lambdabot>  [1,2,3,4,5,6]
15:56:05 <Tela> Y
15:56:09 <Tela> Ahh.. Thanks
15:56:21 <Tela> haha, knew it'd be much simpler than what I was aiming at
15:56:24 <Tela> :)
15:56:26 <ndm> @index digitToInt
15:56:27 <lambdabot> Data.Char
15:56:35 <ndm> never knew about that one...
15:57:10 <xerox> Those old school haskellers know it all...
15:58:14 <lennart> digitToInt is the portable way to convert a digit to it's numerical value.  even if it's in some weird alphabet
15:59:22 <xerox> ?fptools Data.Char
15:59:22 <lambdabot> http://darcs.haskell.org/packages/base/Data/Char.hs
15:59:49 <xerox> Ah, hex.
16:00:42 <ihope> What would Haskell with duck typing be like?
16:00:50 <lennart> ah, my sushi delivery is here
16:01:11 <xerox> lennart: yumm
16:01:12 <lennart> that's good.  then i don't have to spew on duck typing
16:02:06 <edwinb> Mmm, duck
16:02:16 <dylan> mmm, chicken sushi
16:17:36 <lennart> oh, what happened to the ducks while i was gone? :)
16:19:47 <ChilliX> lennart: They did not type.
17:02:28 <lennart> so, I don't think the bus error with gtk2hs is to blame on gtk2hs.  some weird shit is happening in the fontconfig code
17:17:59 <ihope> @hoogle bracket
17:18:00 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
17:18:00 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
17:18:00 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
17:18:22 <ihope> @docs IO
17:18:23 <lambdabot> IO not available
17:18:27 <ihope> @docs System.IO
17:18:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
17:31:26 <lennart> @pl \ x -> x x
17:31:27 <lambdabot> join id
17:31:43 <lennart> @pl \ x -> x x x x x x x x x x x x
17:31:43 <lambdabot> join (join (join (join (join (join (join (join (join (join (join id))))))))))
17:33:17 <lennart> @pl let f x = g f in f
17:33:18 <lambdabot> fix (const . g)
17:33:40 <lennart> @pl let f x = g in f
17:33:40 <lambdabot> const g
18:32:01 <profmakx> hmm
18:32:03 <profmakx> @version
18:32:04 <lambdabot> lambdabot 4p86, GHC 6.5 (OpenBSD i386 )
18:32:04 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:35:05 <dons> hmm?
18:39:09 <profmakx> sorry
18:39:18 <profmakx> could have done it in query i guess
18:39:43 <profmakx> just got my "very own lambdabot" to run and am playing around with it
18:39:47 <dons> no no, just wondering what the 'hmm' was :)
18:39:56 <dons> cool. any issues building or using?
18:42:09 <profmakx> not yet ;)
18:42:21 <profmakx> i will be implementing a few modules to practice haskell
18:42:27 <profmakx> if i got some sleep
18:43:31 <dons> great!
18:44:21 <profmakx> ;)
18:44:41 <dons> what kind of things were you thinking of adding?
18:45:20 <edwardk> so how long until undo is officially baked into lambdabot? =)
18:45:25 <ndm> dons, cabal support!
18:45:33 <profmakx> hmm nothing particular as of now
18:45:36 <ndm> as in works on windows cabal support
18:45:48 <dons> oh, you want windows support
18:45:53 <ndm> YES!
18:45:53 <dons> edwardk: undo?
18:45:57 <ndm> (as always :))
18:45:59 <dons> ?undo do x <- f ; return x
18:45:59 <lambdabot> f >>= \ x -> return x
18:46:01 <edwardk> doless from the other night
18:46:04 <edwardk> woot
18:46:15 <edwardk> hrmm
18:46:19 <edwardk> needs to smarten up
18:46:34 <dons> ?. pl undo do x <- f ; return x
18:46:34 <lambdabot> f
18:46:37 <dons> how's that?
18:46:39 <ndm> dons, a gui would be nice as well,of course
18:46:41 <edwardk> better =)
18:47:12 <dons> ndm, heh, you use windows and like guis. send a patch! :)
18:47:28 <ndm> dons: i'll wait til its building...
18:47:56 <ndm> am just having a fresh go actually, so i can beep you with the lastest and freshest issues :)
18:48:17 <dons> ok, great!
18:49:09 <ndm> Configuring lambdabot-4.0...
18:49:11 <ndm> configure: Dependency base-any: using base-1.0
18:49:12 <ndm> Setup: cannot satisfy dependency unix-any
18:49:53 <ndm> so do you need conditional cabal or something to get that going properly?
18:49:53 <dons> right. you remove that dep, and work around any places *.Posix is used.
18:50:07 <ndm> hmm, is there a "proper" solution to that?
18:50:13 <dons> well, we can just ship two .cabal files
18:50:24 <dons> .cabal.win as an extra, for example
18:50:25 <ndm> thats not a proper solution, thats a hack ;)
18:50:36 <dons> until conditional cabal works
18:51:28 <ndm> @where fps
18:51:29 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
18:52:31 <kpreid> where did @undo come from?
18:53:12 <dons> check planet.haskell.org, there's a blog entry there on it
18:53:19 <dons> and on the new @free command too
18:53:41 <ndm> @free [a] -> [a]
18:53:41 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:57:20-34
18:53:54 <edwardk> @free [a] -> a
18:53:55 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:57:20-34
18:53:57 <kpreid> well:
18:53:59 <edwardk> hrmm
18:54:01 <kpreid> @run do [x] <- Just []; return (x :: ())
18:54:02 <ndm> @free [a]
18:54:02 <lambdabot>  Nothing
18:54:02 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:57:20-34
18:54:07 <dons> ?free length :: [a] -> a
18:54:07 <lambdabot> f . length = length . $map f
18:54:09 <kpreid> @. run undo do [x] <- Just []; return (x :: ())
18:54:10 <lambdabot>  Non-exhaustive patterns in lambda
18:54:17 <ndm> @free a
18:54:17 <lambdabot> Expected OpColonColon
18:54:23 <edwardk> @type length
18:54:23 <dons> it needs a name
18:54:24 <lambdabot> forall a. [a] -> Int
18:54:25 <kpreid> undo does not preserve the semantics of failing paterns
18:54:26 <dons> ?help free
18:54:26 <lambdabot> free <id :: a -> a>. Generate theorems for free
18:54:27 <edwardk> ahh
18:54:32 <edwardk> too bad
18:54:38 <edwardk> otherwise we could . it with @type =)
18:54:42 <dons> right
18:54:45 <ndm> @free name :: [a] -> [a]
18:54:45 <lambdabot> $map f . name = name . $map f
18:55:07 <int-e> @undo do [x] <- Just []; return (x :: ())
18:55:08 <lambdabot> Just [] >>= \ [x] -> return (x :: ())
18:55:16 <int-e> ah
18:55:28 <ndm> @free name :: Ord a => [a] -> [a]
18:55:28 <lambdabot> Extra stuff at end of line
18:55:36 <dons> no classes
18:55:45 <dons> ?type sortBy
18:55:46 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
18:55:53 <dons> ?free sortBy :: (a -> a -> Ordering) -> [a] -> [a]
18:55:54 <lambdabot> g x y = h (f x) (f y) => $map f . sortBy g = sortBy h . $map f
18:56:09 <dons> we need unclass too :)
18:56:19 <edwardk> heh
18:56:23 <edwardk> noclass?
18:56:35 <dons> that desugars a class-annotated type into one with the dictionary passed explicitly.
18:56:42 <dons> yes, noclass, that's good
18:56:44 <int-e> just implement perl as a lambdabot module *ducks*
18:57:08 <dons> i'm not sure that would help, would it?
18:57:20 <dons> or, you mean, we want a regex filter plugin?
18:57:40 <int-e> sed?
18:57:49 <edwardk> int-e: well, pugs IS written in haskell right? its not THAT much of a stretch ;)
18:57:50 <int-e> sed, xargs
18:58:45 <edwardk> not sure how you'd do 'no IO' in perl though
18:59:06 <int-e> @unlambda ``ci`.a`ci -- call/cc
18:59:07 <lambdabot>  aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
18:59:46 <dons> wow
19:00:26 <int-e> actually, ``ci`c.a works, too
19:02:31 <ndm> dons, in Plugin.Quote.Fortune
19:02:36 <ndm> you define isFile
19:02:43 <ndm> why not use just doesFileExist for that?
19:03:17 <ndm> if you need to use anything at all
19:04:18 <dons> no idea, I'm not sure I wrote that code
19:04:25 <dons> what does isRegularFile do?
19:04:48 <dons> oh, not a (other wacky unix) file type
19:05:03 <dons> sure, doesFileExist sounds much better
19:05:26 <dons> you could also try just disabling the Plugins that don't build immediatey, by commenting them out of the Modules.hs file
19:05:37 <ndm> i'll send a patch if you want, but at the moment i can't build or test anything :)
19:13:07 <ndm> dons: and -Werror really screws up the Windows build
19:13:29 <dons> its an incentive to fix things :)
19:13:33 <ndm> since the preprocessormeans that things like "f x = return ()"
19:13:43 <ndm> while on Unix its do something on x
19:13:49 <ndm> and that gets flagged as an error
19:20:04 <int-e> . o O ( const () x )
19:22:15 <dons> ah right
19:22:25 <dons> well you know how to edit the .cabal file :)
19:23:45 <ndm> have already done so
19:24:04 <ndm> and have emailed the libraries list
19:25:37 <ndm> to complain :)
19:35:31 <dons> hehe ok :)
20:26:54 <jluquette> if i declare my own data type (via the data keyword), in order to make a list of elements of that data type, does every element in the list have to be made by the same constructor?
20:28:04 <jluquette> and if so, why?
20:28:43 <dons> not the same constructor, no
20:28:48 <dons> e.g.
20:29:01 <dons> > [Nothing, Just 'x', Just 'c', Nothing]
20:29:02 <lambdabot>  [Nothing,Just 'x',Just 'c',Nothing]
20:29:11 <jluquette> ah, good example
20:30:00 <dons> the degenerate case is to have a type with a unique constructor for all types:
20:30:15 <dons> > [toDyn 'x', toDyn (1::Int), toDyn (), toDyn (True,False) ]
20:30:17 <lambdabot>  [<<Char>>,<<Int>>,<<()>>,<<(Bool,Bool)>>]
20:31:00 <dons> that's just a little bit magic, though :)
20:32:22 <jluquette> hmm, after the list of maybes, it's embarrassingly obvious what the answer to my question was . . though now i'm out of ideas as to why ghc is rejecting this little snippet of code i've got
20:32:48 <dons> ?paste it?
20:32:48 <lambdabot> http://paste.lisp.org/new/haskell
20:32:55 <kpreid> dons: !
20:33:04 <dons> kpreid: !!
20:33:06 <kpreid> dons: I think you just helped me understand existentials
20:33:11 <dons> ah :)
20:33:17 <jluquette> data Tuple a b c d = Single a
20:33:17 <jluquette>                    | Pair a b
20:33:17 <jluquette>                    | Triple a b c
20:33:17 <jluquette>                    | Quad a b c d
20:33:17 <jluquette> main :: IO ()
20:33:17 <jluquette> main = do let s = Single 'a'
20:33:19 <jluquette>               p = Pair 1 '2'
20:33:21 <jluquette>               t = Triple "one" 2.5 "three"
20:33:23 <jluquette>               q = Quad 'a' 'b' "c" "d"
20:33:26 <jluquette>               tuples = [s, p, t, q]
20:33:27 <jluquette> ghc dies on the ``tuples ='' line
20:33:52 <dons> kpreid: hiding multiple types by packing them with their accessor functions?
20:34:00 <jluquette> i'm guessing the problem is that it's parameterising a over ALL of those types
20:34:03 <kpreid> dons: I mean, I understood how they behave, but not quite how the "forall" means that
20:34:21 <kpreid> jluquette: try to write out the type of 'tiples'
20:34:24 <kpreid> er, 'tuples'
20:34:29 <dons> yeah, the types is the issue
20:34:39 <dons> oh, hang on.
20:34:44 <dons> what's the final line of your code?
20:35:00 <jluquette> well, it was using a function that i cut out of that snippit
20:35:20 <jluquette> though i can include it if you don't mind seeing more spam :)
20:35:21 <dons> ok. but yes, tuples may be ill typed, check the  types given to each of s p t and q
20:35:45 <dons> i.e. what's the type of : Single 'a'
20:35:48 <dons> jluquette: ?
20:35:58 <dons> and then, what's the type of: Pair 1 '2'
20:36:10 <dons> Single 'a' :: Tuple Char b c d, yes ?
20:36:27 <dons> but Pair 1 '2' :: Tuple Integer Char c d
20:36:31 <jluquette> well, the type of Single 'a' should be Tuple Char, right?
20:36:35 <jluquette> right
20:36:52 <jluquette> ah, so the problem isn't that they use different constructors
20:36:57 <dons> so you can't build a list with: [Single 'a,  Pair 1 '2'] :: ??
20:36:58 <jluquette> it's just that the construtors expect different type signatures
20:37:04 <dons> its that you've given them differen types altogether
20:37:34 <dons> by applying Tuple (by type inference) to different types
20:37:45 <jluquette> it becomes a parameterised type, right?
20:38:27 <dons> you've got [s :: Tuple Char b c d, p :: Tuple Integer Char c d, t :: Tuple String Double String d ... ]
20:38:46 <dons> these types don't unify, clearly. so no type can be assigned to the list, 'tuples'
20:38:59 <jluquette> alright, that makes sense
21:18:24 <dons> ?yow
21:18:25 <lambdabot> ONE:    I will donate my entire "BABY HUEY" comic book collection to
21:18:25 <lambdabot> 	the downtown PLASMA CENTER ...
21:18:25 <lambdabot> TWO:	I won't START a BAND called "KHADAFY & THE HIT SQUAD" ...
21:18:25 <lambdabot> THREE:	I won't ever TUMBLE DRY my FOX TERRIER again!!
21:27:35 <newsham> how much C (or asm or other non-haskell code) code is there in ghc and its runtime?
21:28:59 <dons>                       Code  Comments
21:29:04 <dons> TOTAL:                44237   7381
21:29:11 <dons> rts                   44237   7381
21:30:05 <dons> (remember the runtime is complex enough it even runs on bare metal...)
21:30:43 <newsham> yah, was thinking of House..  OS written in haskell using some formal methods, on top of a large compiler runtime written in C without formal methods :(
21:30:56 <dons> yep :)
21:31:24 <dons> I think they toss out a lot of things in House though
21:31:40 <dons> down to microkernel size
21:32:01 <newsham> have people done work on reducing the non-haskell code, formally reasoning about it, or anything like that?
21:32:36 <dons> and in the L4/Haskell kernel, the whole thing is written in Haskell first, verified in Isabelle, then translated to C
21:33:00 <dons> (i.e. what you actually run isn't the ghc rts, in the L4Haskell kernel, I think)
21:33:39 <newsham> hmm.. interesting.. hadnt heard of the l4 thing.. (well, i heard of L4, but not a haskell project)
21:33:48 <newsham> i should take a look
21:34:08 <dons> there's a bunch of papers on haskell.org's Research/Applications/OS category
21:34:23 <newsham> neatoh..  i'll definitely check that out.
21:34:42 <dons> that's really the cutting edge at the moment , the L4/Haskell stuff
21:34:47 <newsham> did they add any of those companies that you mentioned a few months ago that do some formal coding using haskell to the website?
21:34:57 <dons> maybe, not sure
21:35:08 <dons> Galois and aetion are certainly there somewhere
21:35:37 <newsham> also, are there any tools that do static analysis of haskell code (I know there's code to do some automated random testing of properties)
21:35:43 <dons> ?wiki Research_papers/Program_development#Operating_systems
21:35:44 <lambdabot> http://www.haskell.org/haskellwiki/Research_papers/Program_development#Operating_systems
21:36:04 <dons> yeah, there's QuickCheck, of course. for runtime testing. and now there's HaskellESC, for extended static checking
21:36:21 <newsham> thanks, i'll check out haskellesc
21:36:28 <dons> check the papers here:
21:36:30 <dons> ?wiki Research_papers/Testing_and_correctness
21:36:30 <lambdabot> http://www.haskell.org/haskellwiki/Research_papers/Testing_and_correctness
21:36:38 <newsham> ahh, perfect :)
21:36:42 <dons> http://www.cl.cam.ac.uk/~nx200/research/escH-hw.ps
21:40:38 <dons> what are you thinking of doing?
21:40:45 <newsham> reading papers :)
21:40:54 <dons> oh ok :)
21:46:54 * edwardk is suffering paper overload at the moment ;)
21:47:21 <newsham> excess paper is good for the compost bin
21:47:44 <edwardk> i need to figure out a better organizational system for them
21:48:22 <newsham> it would be neat having correct programs.
21:50:04 <dons> ?remember newsham it would be neat having correct programs
21:50:05 <lambdabot> Done.
21:51:34 <newsham> ?remember lambdabot Done.
21:51:34 <lambdabot> Done.
21:54:31 <stepcut> newsham: do you know about coyotos and BitC ?
21:54:59 <newsham> nope.  havent heard of either
21:56:06 <stepcut> coyotos is a capabilities based OS (well, microkernel), the successor to EROS and keykos
21:56:21 <stepcut> it is being implemented in a language named BitC
21:56:58 <stepcut> BitC is language designed specifically for implementing coyotos
21:57:15 <stepcut> it takes a *lot* of ideas from Haskell, as well as scheme and other functional programming languages
21:57:17 <edwardk> ah eros has picked up a successor?
21:57:27 <edwardk> good to know
21:57:34 <stepcut> edwardk: yes, it is Jonathon Shapiro's next project
21:57:39 <newsham> thanks, added to the list.
21:57:48 <edwardk> ah cool. i'd kinda thought he went off in other directions.
21:57:54 <stepcut> the ultimate goal is to formally prove that coyotos is secure/bug free
21:57:58 <stepcut> hence the new language
21:58:00 * edwardk nods.
21:58:26 <edwardk> I admit I always thought EROS went a little too far in isolating processes entirely. Pays a lot of overhead to keep the capabilities out of user space. =/
21:58:35 <stepcut> BitC is strict, has a bunch of bit twiddling stuff, and I think it gives you better control of memory allocation
21:58:38 <edwardk> I tend to prefer a model closer to singularity or nemesis.
21:58:46 <newsham> stepcut: what about low level interface to the machine?  any assembly?  what'd they do about that formally?
21:59:29 <edwardk> though, i used to obsess about SASOS stuff back in the day, so that kinda set my biases there =)
21:59:44 <stepcut> newsham: I think the goal is write almost all of it in BitC, but presumably there is some initial bootloader stuff that is is asm
22:00:36 <newsham> context switches, page fault handlers, etc.. all in bitc?
22:01:31 <stepcut> newsham: I believe so
22:01:38 <stepcut> http://www.coyotos.org/
22:01:40 <lambdabot> Title: Coyotos Secure Operating System
22:02:25 <Oejet> http://www.haskell.org
22:02:27 <lambdabot> Title: Haskell - HaskellWiki
22:02:51 <dons> Oejet: just testing? ;)
22:03:08 <Oejet> dons: Testing, testing.  :-)
22:03:54 <stepcut> I think that feature could use a bit of testing -- I think it sometimes fails ;)
22:04:34 <Oejet> http://www.java.sun.com
22:04:36 <lambdabot> Title: Java Technology
22:04:50 * Korollary is waiting for nsfw links
22:05:18 <alec> http://www.microsoft.com
22:05:28 <alec> lambdabot filters out nsfw!!!
22:05:36 <newsham> http://www.thenewsh.com/~newsham/x/loop.html
22:05:38 <lambdabot> Title: http://www.thenewsh.com/~newsham/x/loop.html
22:06:16 <dons> MS musn't be serving valid html....
22:06:24 <dons> (why am I not surprised?)
22:06:35 <newsham> mshtml!
22:06:40 <Korollary> Hmm, I thought their homepage has been validating for quite a while
22:07:11 <Korollary> hmm, 2 errors
22:07:15 <Korollary> http://validator.w3.org/check?uri=http%3A%2F%2Fwww.microsoft.com
22:07:17 <Oejet> dons: You can't expect them to write _all_ their millions of pages in valid HTML, now can you?
22:07:17 <lambdabot> Title: Result for http://www.microsoft.com/ - W3C Markup Validator
22:07:27 <dons> possibly they don't have a <title> in the first 1024 bytes
22:07:33 <dons> which might be more likely..
22:08:01 <Korollary> they do
22:08:10 <newsham> if only there was a way to programmatically generate correct html
22:08:20 <dons> they do have a <title> inside 1k?
22:08:22 <johnnowak> newsham: isn't there?
22:08:26 <Korollary> It looks so
22:08:38 <Korollary> I didnt count. But not more than 300 chars I think
22:08:42 <alec> dons: it's on the 12th or so line, it looks like it
22:08:44 <johnnowak> newsham: or was that... sarcasm... :)
22:08:46 <dons> ok
22:09:00 <dons> weird, looks fairly innocuous.
22:09:08 <stepcut> hah! I went to www.microsoft.com, and it crashed konqueror ;)
22:09:12 <dons> maybe their server speaks some funny http that lambdabot doesn't understand
22:09:17 <alec> dons: they don't seem to like http 1.0; I got a bad request when I just did a GET
22:09:20 <dons> and that Korollary spews up on
22:09:26 <dons> ah that would be it
22:09:27 <alec> dons: but when I did a GET http://www.microsoft.com/ it came out
22:09:32 <dons> I think lambdabot speaks http 1.1
22:10:03 <edwardk> but 1.1 should be safe
22:10:13 <johnnowak> scsibug: i think that says more about konqueror than microsoft :)
22:10:14 <edwardk> you request 1.1 it should reply with 1.0 and all will be well
22:10:20 <johnnowak> scsibug: ah sorry.. missed.
22:10:30 <edwardk> just can't keep the socket alive for multiple requests then
22:10:43 <dons> ah well, they screw some more standards, and make themselves seem more foolish. yay for MS.
22:12:25 <dons> I find it funny that the front page of microsoft.com is full of adverts to stop spyware, virsus and other security issues..
22:13:05 <johnnowak> dons: they need to get people to stop clicking every "cute_dogs.exe" they get in their email
22:13:12 <dons> heh
22:14:21 <edwardk> so basically bitc is a reinvented ml?
22:15:07 <stepcut> edwardk: it's a bit of everything. I think it has haskell-like type classes
22:15:13 * edwardk nods.
22:15:29 <edwardk> he really can't help but reinvent everything can he? =)
22:15:54 <stepcut> for a while it had scheme-like syntax, but he is now switching to a more c-like syntax
22:16:41 <edwardk> heh, i've had language projects like that. whatever my current obsessions were at the time, it started to resemble.
22:18:22 <stepcut> I think in the case of BitC, it was because he wanted macros, and it was easier to develop the macros on top of a scheme-like syntax
22:18:29 * edwardk nods.
22:18:36 <edwardk> thats the one thing i don't like about haskell.
22:18:51 <edwardk> no good define-syntax. template-haskell is comparatively clunky.
22:21:25 <stepcut> I have wondered why there is not more clamouring for macro's in Haskell. I figure haskell must have some features that eliminate most of things that people use macros for in scheme
22:21:35 <edwardk> nah.
22:22:11 <edwardk> they just have template-haskell and c defines to fall back on in a pinch, so no pressing need.
22:22:16 <dons> higher order functions + laziness?
22:22:56 <dons> e.g. foreach = flip mapM_ ; foreach [1..10] $ \i -> do some stuff in a loop
22:23:19 <dons> scheme macros are commonly used for new control structures (amongst other things), aren't they?
22:23:33 <edwardk> control structures and domain specific languages.
22:23:57 <dons> right, and DSLs as well are done in haskell directly, without preprocessing or macros
22:24:06 <edwardk> reasonably
22:24:09 <dons> due to the lazy+hof control structures, and the flexible syntax
22:24:21 <dons> that'd be why we don't seem to care about macros
22:24:29 <dons> only for true code generation do people want TH, usually
22:24:49 <edwardk> yeah, but TH is pretty unsightly ;)
22:24:53 <dons> sure
22:25:48 <edwardk> the main thing i would like would be the ability to express monadic code in non-monadic style, wth stuff lifted appropriately, like heff was working on.
22:26:01 <edwardk> but it seems like that can be largely solved in TH
22:26:29 <edwardk> the whole monadic/non-monadic total-style-shift is a little unnerving.
22:26:41 <dons> heh
22:29:29 <edwardk> is he still doing the orthogonal persistence stuff in coyotos?
22:29:45 * edwardk has wound up borrowing that idea a few times =)
22:30:06 <stepcut> edwardk: he was thinking about dropping it, but recently announced that there was no point in dropping it because they had to implement all the hard stuff for other reasons anyway
22:30:12 <edwardk> heh
22:30:21 <stepcut> on the upside, coyotos should have killer suspend/resume on laptop ;)
22:30:26 <stepcut> s
22:30:26 <edwardk> yeah
22:30:39 <edwardk> but it'll also have the worst battery life of any os on a laptop ;)
22:30:46 <edwardk> harddrive spinning all the time.
22:31:01 <edwardk> that was a problem with mine
22:31:27 <edwardk> one of the many reasons why i stopped playing with it
22:31:39 <stepcut> edwardk: perhaps -- it could theorectically have better performance because the OS more control over when data gets written to the disk
22:31:56 <stepcut> yikes
22:32:00 <edwardk> yeah, but with the orthogonal persistence stuff you are always snapshotting
22:32:09 <edwardk> it'll always be sequential, but you'll never stop writing
22:32:16 <stepcut> I should go to sleep, my typing is getting bad
22:32:21 <edwardk> kk
22:32:56 <edwardk> you know, with a simple orthogonal persistence model the STM stuff in haskell can have all 4 ACID properties. ;)
22:33:08 <stepcut> :p
22:33:27 <edwardk> i was debating about writing that up, but i haven't bothered to port my linux process orthogonality stuff to haskell yet
22:34:14 <edwardk> well, it has a slightly weakened durability property given that it always restores to a stable state, not necessarily with all transactions run.
22:34:38 <stepcut> HAppS seems to have some sort of ACID capabilities
22:34:42 <edwardk> needs a slightly more complicated logger for that
22:34:49 <edwardk> haven't looked at HAppS.
22:35:00 <edwardk> just thought about it when i first saw STM.
22:35:37 <stepcut> I have not looked at HAppS recently, but sometime I want to look at it again and see if the ACID stuff can be turned into a general purpose library
22:35:49 * edwardk nods.
23:06:19 <lisppaste2> Tela pasted "Weird Sums" at http://paste.lisp.org/display/24805
23:06:22 <Tela> Hmm. Can anyone take a look at this paste and tell my why ans ends up as 0? (The answer should be 1366)
23:06:48 <Tela> It seems to work fine if I go through the steps one by one
23:07:50 <dons> > foldr1 (+) . map digitToInt . show $ 10000
23:07:51 <lambdabot>  1
23:08:00 <dons> > foldr1 (+) . map digitToInt . show $ 1
23:08:01 <lambdabot>  1
23:08:06 <dons> > foldr1 (+) . map digitToInt . show $ 7
23:08:08 <lambdabot>  7
23:08:15 <dons> > 2^1000 :: Int
23:08:16 <lambdabot>  0
23:08:19 <dons> :)
23:08:22 <edwardk> heh
23:08:23 <dons> there's your answer
23:08:33 <Tela> Oh... Hah. Thanks
23:08:47 <dons> > 2^1000 :: Integer
23:08:48 <lambdabot>  1071508607186267320948425049060001810561404811705533607443750388370351051124...
23:09:19 <dons> > length . show (2^1000 :: Integer)
23:09:20 <lambdabot>    Expecting a function type, but found `[Char]'
23:09:20 <lambdabot>    Expected type: a1 ->...
23:09:25 <dons> > length $ show (2^1000 :: Integer)
23:09:27 <lambdabot>  302
23:09:56 <dons> > foldr1 (+) . map digitToInt . show $ (2^1000 :: Integer)
23:09:57 <lambdabot>  1366
23:10:41 <Tela> Yeah... One of these days I swear I'm going to actually figure this language out and stop making silly mistakes like that :S
23:11:05 <newsham> or you could just get irc to fix the code
23:11:50 <dons> well, your code was fine, but you'd picked a too-restrictive type . premature optimisation :)
23:11:59 <dons> if you'd left the type signatures off, it would have worked :)
23:12:15 <newsham> lots of young programmers have that problem.
23:12:21 <dons> heh
23:12:27 <newsham> (pun intended)
23:12:45 <Stinger_> I dunno, I wouldn't call that optimal :P
23:13:41 <Tela> Is there some document that fully describes the intents of all the number types and contexts? They've been causing me all sorts of difficulty.
23:13:59 <dons> the haskell98 report, i suppose
23:14:19 <dons> you've got Integer and Int, for unbounded and word-sized integers
23:15:17 <newsham> hmm.. so this seL4 stuff, they're actually gonna hand code C to reimplement haskell implementation after the design is done and proved out?
23:16:51 <dons> a bit "iffy", isn't it...
23:17:01 <dons> you kind of want a verified compiler to do that sort of game
23:17:14 <dons> but they argue more for verifying the api, no?
23:17:25 <newsham> yah, but still interesting (especially if all it needs is a compiler)
23:17:34 <dons> yeah, certainly
23:17:38 <edwardk> seL4?
23:17:51 <edwardk> L4 as in microkernel?
23:17:54 <dons> big benefits just from prototyping in haskell, and proving that in Isabelle
23:17:59 <dons> edwardk: yep, sure.
23:18:11 <edwardk> kk
23:18:16 <newsham> http://www.haskell.org/haskellwiki/Research_papers/Program_development  "a secure microkernel" and "reconciling high perf and high assurance in microkernel devel"
23:18:18 <lambdabot> Title: Research papers/Program development - HaskellWiki
23:18:29 <dons> edwardk: I thought you'd already seen that stuff?
23:18:53 <edwardk> i took a peak at house, and i know l4 from l4ka, etc
23:18:56 <newsham> so their goal isnt really a haskell os (as in House)
23:19:09 <dons> yeah, this is quite different to House.
23:19:23 <dons> its about verifying microkernels some way or another
23:19:58 * edwardk nods.
23:20:08 <edwardk> neat
23:21:00 <dons> I have a make target "fusionbench-compile" however I _always_ type "fusionbench-compiler"
23:21:03 <edwardk> i do find the title about high performance and microkernels in the same sentence to be a little off the mark though ;)
23:21:09 <dons> which is funy
23:21:14 <dons> edwardk: boo
23:21:24 <edwardk> cheap shot? =)
23:21:40 <dons> heh yeah ;)
23:21:44 <newsham> depends on your metric.  measured in numbers of theses, microkernels are very performant.
23:21:51 <edwardk> just coz its cheap doesn't make it less accurate ;)
23:21:57 <edwardk> new: heh
23:22:26 <dons> I seem to recall these guys running linux on one of their mips or alphs L4 kernels, and beating normal linux on the same arch
23:22:31 <dons> that was a couple of years ago or 4
23:22:44 <edwardk> l4linux
23:22:47 <edwardk> performed ok
23:23:48 <edwardk> ~4% speed hit
23:24:59 <newsham> i imagine "high performance" means they're going to recode it in C ;-)
23:25:00 <edwardk> the problem is the kind of os design i really want requires lots of very lightweight tasks moving in and out of kernel space, so the hit is worse for the kinds of systems i want to play with.
23:25:12 <dons> yeah not l4 linux though, this was possibly an inhouse linux running on pistachio or something like that.
23:25:16 <edwardk> hence why the singularity/sasos approach is interesting
23:25:22 <dons> right
23:25:22 <edwardk> ah
23:26:02 <newsham> context switches definitely arent getting cheaper with big caches and register files and deep pipelines
23:26:15 <edwardk> yeah
23:26:40 <edwardk> hence why i like reduced usage of hardware protection domains
23:27:17 <edwardk> you can still use virtual memory for protection if you want to pay for the occasional tlb flush, but when you can even bypass that can be a decent win.
23:27:34 <edwardk> add lots of cores and it becomes potentially more beneficial.
23:27:57 <newsham> so provably type-safe binaries sharing the same space?
23:28:02 <edwardk> yeah
23:28:03 <newsham> a la spin?
23:28:19 <edwardk> with the ability to throw in a hardware protection domain if you can't be sure or need reliability at the expense of speed.
23:29:12 <edwardk> now, throw in an orthogonal persistence system and bake garbage collection into the OS and you have a usable system.
23:29:41 <edwardk> or remove gc/persistence and give each isolated binary its own page list that you can free if it runs amok.
23:30:50 <newsham> if bits start flipping, though, your type safety goes out the window pretty quickly
23:31:00 <newsham> more so than with mmu protection
23:31:14 <edwardk> yeah. that was my problem with orthogonal persistence in general
23:31:24 <edwardk> and why i sstopped working on SASOS projects =)
23:31:43 <newsham> there was some interesting paper about using memory errors to compromise java's type system
23:31:50 <edwardk> coz there really is no way to ensure that an alpha-particle won't flip a bit on you
23:31:53 <newsham> wish i remembered where
23:31:54 <edwardk> yeah read it =)
23:32:01 <edwardk> they bombarded the chip
23:32:13 <newsham> security is fun :)
23:32:22 <newsham> so many creative ways to break things
23:32:33 <dons> yeah, with microwaves, no?
23:32:41 <edwardk> heh, well, security isn't magical dust you can sprinkle on something. it relies on the whole system
23:32:55 <edwardk> smart cards can be cracked by checking the amount of voltage they draw, etc.
23:33:08 <edwardk> it all those little side channels of information you don't expect that add up
23:33:47 <newsham> yah, i break stuff for a living.
23:34:13 <edwardk> heh
23:34:22 <newsham> havent done hardware fault injection, but a friend of mine is at CRI where they do some of that stuff
23:34:34 <edwardk> i collected a bunch of security certs, but never found a use for em ;)
23:34:39 <newsham> (and also have some patents on technologies to protect against those attacks)
23:35:30 <edwardk> mostly just have a passing interest in cryptosystems and weird sidechannel attacks
23:37:04 <newsham> we do lots of application audits, looking at code or black box testing applications, web apps, operating systems, etc.
23:37:17 * edwardk nods.
23:37:21 <newsham> mostly C/C++/java type stuff
23:38:33 <edwardk> my 'real world' security stuff comes from my dot-com years. mostly coz we'd go in buy up a copany, gut it and take their customers and whatever legacy support issues they had, wound up having to fix way too many badly secured systems and apps.
23:42:15 <newsham> heh, fun
23:43:52 <edwardk> heh, I don't want anything to do with security any more I think ;)
23:46:49 <edwardk> those bastards cut everyone's name off these except for the one guy who didn't do anything =) http://www.scmagazine.com/us/grouptest/details/dc897f98-0218-4fd1-a643-612063f05dc2/intrusion-prevention-2004/
23:47:34 <edwardk> er =/
23:47:56 <newsham> "Arguably, the most important feature of an IPS is the user interface."
23:48:03 <newsham> and the glossy brochure.
23:48:04 <edwardk> heh
23:48:17 <edwardk> well, there were some pretty non-technical people involved.
23:48:23 <edwardk> i walked away in the middle of the project.
23:50:00 <edwardk> the guy in charge wanted to take credit for everyone's work, there was a guy with a degree in quality that insisted on getting in the way of everyone who wasa actually doing work, and there were a bunch of clueless undergrads who were all they could get to work in the 'lab' that didn't even want to spring for a rack ;)
23:50:17 <edwardk> er spring for a rack for
23:56:47 <Korollary> live engineers are nice
23:57:00 <Korollary> dead ones not so much
23:57:30 <edwardk> depends on whether or not you like the engineer ;)
23:58:19 <Korollary> I don't think I'd like him better dead
23:58:26 <edwardk> fair enogh
23:58:29 <Korollary> such relationships go nowhere
23:58:34 <edwardk> who is this?
23:58:42 <Korollary> Who is who?
23:58:54 <edwardk> the engineer in question
23:59:04 <Korollary> I don't know. I thought you knew
23:59:21 <Korollary> Wait. We have a social engineer.
23:59:28 <Korollary> reset passwords
23:59:40 <edwardk> thats almost as much of a misnomer as a software engineer ;)
