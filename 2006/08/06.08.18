00:01:01 <gaal> #868. Thanks dons.
00:02:42 <dons> ?karma+ gaal
00:02:42 <mbot> gaal's karma raised to 1.
00:03:48 <stepcut> dons: I sent you an email with the bytestring parser
00:03:54 <dons> great!
00:04:01 <stepcut> dons: I am super-tired, so it might be full of gibberish
00:04:21 <dons> stepcut: I'd like to talk a bit about what you guys are using ByteString for, in the bytestring paper dcoutts and I are writing
00:04:34 <dons> so I may ask some questions in the next few days. you are warned ;)
00:04:53 <edwardk> heh. you thinlk you come up with something original and there it is... in  1993 paper by wadler. *sigh* =)
00:04:59 <edwardk> er in a
00:05:03 <stepcut> dons: ok -- currently we are using it to parse debian control files
00:05:24 <dons> cool.
00:05:31 <stepcut> edwardk: meh. Everytime I search for something related to functional programming, I end up on oleg's site :)
00:05:38 <edwardk> stepcut: heh
00:05:52 <stepcut> today it was fast calculation of prime numbers
00:06:05 <dons> hehe
00:06:17 <edwardk> wadler mentioned that linear logic's ! is a comonad in 'A syntax for linear logic', but I never saw read that part before =)
00:06:28 <stepcut> though, I ended up using a different method -- everything I do to make the sieve method go faster, makes it go slower :)
00:06:29 <edwardk> s/saw//
00:07:00 <stepcut> but, filter isPrime [2..], which is moderately non-stupid isPrime predicate is pretty fast
00:07:58 <stepcut> for searching primes less than a million, sieve ~ 10mins vs 'filter isPrime' ~ 5 seconds
00:08:33 <edwardk> hrmm. can anyone think of a use for linear kinds? i've been playing with this substructural stuff and the idea seems to come up the moment i generalize substructural types to a pure type system. not sure i see a use yet, but it seems like they might have some form of singleton semantics.
00:08:53 <edwardk> would be like having types that you can only use once =/
00:08:57 <stepcut> well, using sieve to generate a lazy list of primes -- using sieve on a mutable array can be quite fast :)
00:09:14 <edwardk> not sure the idea is even well defined, they just seem to emerge as a consequence of the syntax.
00:12:44 <Cale> http://blogs.msdn.com/ralflammel/archive/2006/07/28/681041.aspx -- is this a joke?
00:13:41 <merus> Cale: I thought it was a joke.
00:14:19 <edwardk> hahahaha
00:14:29 <Cale> It must be
00:14:55 <edwardk> i think its a dig at the C# AML stuff
00:15:00 <araujo> haha that gotta be a joke
00:15:06 <edwardk> http://www.charlespetzold.com/etc/CSAML.html
00:15:13 <Cale> http://www.charlespetzold.com/etc/CSAML.html
00:15:14 <Cale> yeah
00:15:19 <edwardk> heh, oh, its even linked off the bottom of the page
00:15:31 <mauke> © Charles Petzold, April 1, 2006
00:15:36 <Cale> I love the translation of A = 5 * (B + 27 * C);
00:15:43 <Cale> "This statement translates without much fuss into the following chunk of CSAML"
00:16:11 <Cale> <23 lines of XMLish gibberish>
00:16:12 <edwardk> this is a fine example of people missing the point =)
00:16:52 <araujo> it's a joke
00:16:57 <edwardk> also, note that the xml gibberish has to have explicit type annotations, etc.
00:16:57 <dons> :)
00:16:58 <araujo> they are doing it good
00:17:28 <dons> isn't that interesting: Type="{x:Type Int32}"
00:17:45 <edwardk> which is bad form in xml land too
00:18:00 <edwardk> two pieces of information in one attribute
00:18:10 <edwardk> that should be broken apart into multiple tags =)
00:59:09 <tibbe> @yarr
00:59:10 <mbot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
00:59:29 <tibbe> @quote
00:59:29 <mbot> ChristopherHendrie says: Sometimes I wonder if Java will be indirectly responsible for hastening the adoption of functional programming languages
00:59:34 <tibbe> @bored
00:59:56 <mnislaih_> tibbe, go play with the all exciting ghc.debugger
01:00:01 <mnislaih_> @where ghci.debugger
01:00:01 <mbot> I know nothing about ghci.debugger.
01:00:06 <mnislaih_> @where ghc.debugger
01:00:06 <mbot> I know nothing about ghc.debugger.
01:00:16 <mnislaih_> @google ghci.debugger
01:00:16 <mbot> search module failed: IRCRaised getHostByName: does not exist (no such host entry)
01:00:55 <mnislaih_> http://haskell.org/haskellwiki/Ghci/Debugger
01:01:30 <mnislaih_> @where+ ghci.debugger http://haskell.org/haskellwiki/Ghci/Debugger
01:01:30 <mbot> Done.
01:05:34 * tibbe plays
01:05:58 <foxy> http://www.dcs.st-and.ac.uk/~eb/drafts/ivor.pdf
01:10:50 <tibbe> being one GHC installation short makes playing less fun
01:14:06 <tibbe> @quote
01:14:06 <mbot> astrolabe says: I put my thing in inverted commas because it isn't a really stalactite, but it looks like one, and contains nitrates from urea.
01:18:53 <flux__> so, how's yi going these days?
01:21:40 <dons> oh, puttering along
01:53:44 <tibbe> @quote
01:53:45 <mbot> tennin says: [very #haskell] anyone know of any good books/papers on the application of category theory to databases?
02:00:28 <ivant> @seen lambdabot
02:00:29 <mbot> I haven't seen lambdabot.
02:01:56 <ivant> @seen lambdabot
02:01:57 <mbot> I haven't seen lambdabot.
02:02:05 <ivant> oops
02:05:56 <mux> anyone who could help me with HaXml ?
02:06:39 <ivant> mux: I did help someone with HaXml here yesterday but I don't know it :-)
02:06:47 <ivant> I can try though
02:06:55 <mux> okay :-)
02:07:02 <mux> I'd like to do a very simple thing
02:07:14 <mux> just parsing some XML stream, and get back an appropriate data structure
02:07:34 <mux> that sounds like basic stuff and yet I can't figure out how to do what I want
02:07:40 <ivant> @where haxml
02:07:40 <mbot> http://haskell.org/HaXml
02:08:07 <mux> I don't see how to get something else from HaXml than a Document type
02:08:15 <mux> which is inappropriate for my needs
02:08:34 <mux> and I don't see how I could mix IO computations in filters either, which would be another way of solving my problem
02:09:51 <mux> more precisely, what I would like to do is:
02:10:00 <mux> parse some XML stream of the form
02:10:10 <mux> <item name="foo">
02:10:23 <mux>   <someparam ...>bla</someparam>
02:10:33 <mux>   <someotherparam ...>bar</someotherparam>
02:10:36 <mux> </item>
02:10:37 <mux> and so on
02:11:11 <mux> so ideally, I'd like to get a list of item elements, where an item element is just a record with all the "parameters" in it
02:11:36 <mux> ie data Item = Item { someparam :: Foo, someotherparam :: Bar ... }
02:11:38 <mux> am I being clear?
02:11:44 <ivant> you can try using LabelFilters I guess
02:11:57 <ivant> @hoogle LabelFilter
02:11:57 <mbot> search module failed: IRCRaised getHostByName: does not exist (no such host entry)
02:12:14 <ivant> type LabelFilter a = Content -> [(a, Content)]
02:12:21 <mux> mmmm.
02:12:53 <mux> the ultimate aim being that for each item, I want to add a line in a TreeView widget in gtk
02:13:02 <ivant> so, you can write some functions which fetch the data from the Content and put it in some structure (a) there
02:14:23 <ivant> you can apply these functions to your xml and get [(a, Content)] out of parsing monad
02:15:02 <ivant> and there you can simply (map unzip) or something
02:15:20 <ivant> and do whatever IO you need
02:15:35 <ivant> maybe even mapM ....
02:15:35 <mux> okay, so how do I apply a LabelFilter to my xml?
02:15:42 <mux> sorry if I'm asking dumb questions :-).
02:16:35 <ivant> have you read <http://haskell.org/HaXml/icfp99.html>?
02:16:53 <mux> yep, maybe I should re-read it though
02:16:58 <ivant> I guess you do something like
02:16:59 <ivant> processXmlWith (albumf `o` deep (tag "album"))
02:17:35 <ivant> just find some function which runs monad for the needed types
02:19:19 <mux> but processXmlWith reads from a file, right?
02:19:30 <ivant> I have no idea :-)
02:20:53 <ivant> oh, btw, there is Xml2Haskell in HaXml: <http://haskell.org/HaXml/HaXml/Text-XML-HaXml-Xml2Haskell.html>
02:21:01 <mux> yeah
02:21:40 <ivant> see class XmlContent
02:21:51 <ivant> I guess you need to implement couple of those
02:22:22 <mux> that indeed looks like I should use this
02:22:27 <mux> now, "how" is the question
02:22:31 * mux re-reads stuff again
02:28:59 <mux> the documentation really needs much, much more examples
02:40:14 <ivant> mux: the same is true about marshalling C structures using FFI
02:46:54 * mux nods
02:47:22 <mux> I'm writing type definitions corresponding to the DTD I want to parse and implementing instances of XmlContent
02:47:39 <mux> this looks nice, but I would have liked it even more if there were more examples
02:50:11 <mux> it seems I am forced to implement both toElem and fromElem though, even if I only want to use this in one way
02:55:18 <kzm> is GHC profiling limited to the current applications?  I.e. you don't get profiling of library functions?
03:11:54 <mux> kzm: no, you can have profiling for library functions too, and actually, to build an applicaiton with profiling, you need the profiling version of all the library it uses
03:16:07 <eivuokko> I think the problem is that most of the time the libraries are just compiled with profiling enabled, but no annotations.
03:50:21 <kzm> Copying in the library in the app directory (instead of linking with profiling lib) gives much more detailed results.
03:50:33 <kzm> So eivuokko is right, I think.
04:38:31 <mux> omg, I was suffering writing instances of XmlContent and friends and DrIFT can generate those automatically
04:41:53 * xerox nods
04:44:46 <mux> mmm
04:48:50 <mux> doesn't look like it really does what I mean :-P
04:52:22 <tibbe> could someone pretty please give me an online web 2.0 version of gtk-emacs with inf-haskell running ghci?
04:52:39 <tibbe> so I can run it from work
04:52:41 <xerox> tibbe: maybe the HSP.ClientSide guy.
04:52:53 <tibbe> :)
04:53:49 <xerox> I am not sure about the syntax highlighting and editing commands, but basic eval a-la lambdabot shouldn't be hard.
04:54:05 <kzm> Anybody have problems with FPS and excessive GC times?
04:54:34 <dons> kzm, hmm. interesting. no?
04:54:57 <dons> got a .prof file?
04:55:16 <xerox> Got a proof? ^_^
04:55:21 <kzm> I have a program that builds a lot of bytestrings.  But it is dog slow if I don't give it -M800M or so.
04:55:32 <dons> maybe you've got a space leak?
04:55:52 <araujo> morning
04:55:55 <dons> one idea: try a 6.5 snapshot
04:56:04 <kzm> Nothing that shows up in heap (or other profiling).  But -s gives 90-ish % GC time.
04:56:20 <dons> programs that use lots of bytestrings should be faster in 6.5 by a few factors
04:56:28 <dons> hmm. strange
04:56:31 * kzm was afraid you would suggest that. :-)
04:56:44 <dons> more info would be needed to debug it. but try 6.5 first
04:57:02 <kzm> %GC time      96.0%  (95.1% elapsed)
04:57:09 <dons> not good
04:57:42 <kzm> Could it be that I'm just generating a ton of garbage (building BS'es and throwing them away)?
04:57:48 <dons> yeah
04:57:49 <kzm> I didn't think I was, but perhaps I should look again.
04:57:56 <dons> could just be a normal space leak of some kind
04:59:10 <kzm> Perhaps I can use a different kind of heap profiling?  (biographical or whatchamacallit)
04:59:29 <dons> yeah, maybe some SCC pragmas?
04:59:43 <kzm> Any Ubuntu (or generic debian-like) packages with ghc-6.5 in them?
05:00:16 <dons> there's nightly linux snapshots that'll run ,  I think
05:08:53 <tibbe> any good docs how to turn Cabal packages into .deb packages? Can it be automated or do I need to create debian/ dir and populate it?
05:09:41 <eivuokko> Isn't there a tool called dh_haskell to do something like that?
05:09:53 <kzm> by John Goerzen, I think.
05:10:04 <kzm> If anybody has any experience with it, I'm all ears.
05:10:13 <tibbe> eivuokko, yes but I really never got it to work, it appears to do nothing if there's no debian dir
05:12:23 <tibbe> I googled some for some docs on it but came up empty
05:15:49 <xerox> You need a debian dir to make a deb package
05:16:14 <xerox> There are tools that creates one to start with as well
05:16:30 <kzm> tibbe: debhelper? dh_make?
05:16:30 <tibbe> xerox, more dh_* tools ?
05:16:41 <xerox> Possibly, the debian documentation surely tell you
05:18:07 <tibbe> kzm, I don't know, lots of tools with somewhat unclear purpose came with the haskell-devscripts something package
05:18:44 <tibbe> I've seen one "official" packaging guide for debian and it simply more or less assumed autoconf and friends
05:19:55 <xerox> I don't remember the details but I successfully did it one time, it's not very hard, you just have to use the right tools and fill in the right informations.
05:20:32 <tibbe> :) that's good
05:28:42 <int-e> kzm: have you played around with +RTS -H already?
05:28:53 <kzm> Yes, that "solves" the problem.
05:29:54 <kzm> ..to some extent, at least.  I'd like to avoid the garbage entirely, if possible.
05:32:54 <kzm> Current suspect is reading data line-by-line as BS.  Perhaps it's better to read everything as one big chunk, and parse that.
05:33:29 <dons> yeah
05:33:42 <dons> and then just share the underlying file transparently
05:34:45 <kzm> I need to process it a bit, remove some whitespace, etc.
05:35:06 <kzm> I could use a BS.Lazy-like approach, chaining together the lines, but...
05:35:22 <dons> seems fairly easy.
05:35:36 <dons> i'd still suspect a space leak somewhere
05:35:42 <kzm> Anyway, current suspect is generation of one BS per line, which is later discarded.  That'd generate quite a bit of (expensive?) garbage.
05:35:49 <dons> yeah
05:35:50 <kzm> Doesn't show up on profiles.
05:36:00 <dons> hmm
05:36:22 <kzm> I'm memory profiling a larger data set now, but it takes ages.
05:36:52 <kzm> This is GHC 6.4.1, so as you point out, a newer compiler might help.
05:38:06 <dons> yep. for many many bytestrings, the representation has been greatly improved
05:38:25 <dons> but if there's a leak in there, then there's a leak
05:41:15 <kzm> (I'm using fps-0.8, btw. But you're talking compiler improvements, right?)
05:41:40 <dons> yep
05:41:58 <dons> the underlying ForeignPtr is much faster in 6.5, and uses a more efficient representation
05:43:19 <kzm> I guess I'll just have to try it, then.
05:43:59 * kzm is tired of patching his GHC installation.  I filed a 'backport' request to Ubuntu, so hopefully we'll at least get 6.4.2 by default.
05:44:55 * dons `ap` sleep
05:47:45 <Pupeno> what's the oposite of "broken" ?
05:48:04 <sieni> "not broken"? :-)
05:48:15 <zarvok> functional? :)
05:48:32 <ValarQ> operational? :o)
05:49:01 <int-e> pristine? working? in good condition?
05:49:20 <kzm> My ghc-6.5 snapshot comes with an ancient fps in base.  Has that been updated with recent snapshots?
05:49:29 <sieni> "working like a train's toilet"
05:49:41 <int-e> sieni: we weren't looking for synonyms ;)
05:49:43 <Pupeno> kzm: do you need voters for the backport ?
05:50:10 <kzm> Pupeno, not sure if it's a popularity contest, but feel free to add your voice to the request.
05:50:18 <Pupeno> kzm: any URL ?
05:50:21 <kzm> Currently, there seems to be no response whatsoever.
05:50:52 <tibbe> kzm, I'll vote for it
05:50:59 <int-e> kzm: I believe it comes with what basically is fps-0.7.
05:51:22 <dons> kzm, hmm. the latest ghc has fps 0.7, yep
05:51:30 <int-e> (and I don't know if coexistence with fps-0.8 really works - there seem to be collisions in the C bits)
05:51:33 <kzm> https://launchpad.net/distros/ubuntu/+source/ghc6/+bug/56516
05:51:41 <dons> you'll need one or the other
05:51:48 <dons> probably no need to use 0.8 though
05:52:12 <kzm> dons, did I mention that I think putting fps in base was a bad idea? :-)
05:52:17 <int-e> the problem being that the base lib defines the same symbols for the C bits as fps-0.8 does.
05:52:26 <shapr> Is dons' fps repo down?
05:52:28 <kzm> (but yeah, 0.7 is probably plenty good enough)
05:52:29 <dons> int-e, right
05:52:32 * shapr is upgrading hope
05:52:33 <dons> shapr: yes
05:52:35 <shapr> ah ok
05:52:37 <dons> no power in the building :(
05:52:39 <shapr> Is there a mirror somewhere?
05:52:46 <dons> should be back up in about 12 hours or so
05:52:50 <dons> shapr: hmm, maybe a debian repo?
05:52:55 <zarvok> hmm... any thought on why when I try to msg lambdabot it just prints "lambdabot: No such nick/channel"?  I connected in the same way as always...
05:52:59 <int-e> dons: hmm, do you think appending a version to the symbols would be too much trouble?
05:53:01 <dons> someone must mirror the fps tarballs somewhere
05:53:12 <dons> zarvok: lambdabot is also unavailable, due to power outage
05:53:15 <shapr> zarvok: lambdabot is down
05:53:16 <dons> zarvok: try 'mbot'
05:53:19 <shapr> Shocking idea, I know.
05:53:20 <dons> ?bot
05:53:20 <mbot> :)
05:53:29 <zarvok> dons: thanks
05:53:35 <dons> int-e, hmm. not a bad idea
05:53:36 <xerox> Maybe we can use the SoC money for a server and get a lambdabot instance there :)
05:53:43 <dons> heh
05:53:55 <shapr> I wish we had something even vaguely like mnesia.
05:53:59 <zarvok> shapr: I tried to build hope last night myself... got some strange error that dumped assembly
05:54:04 <dons> a dedicated 24/7 multiple redundancy lambdabot server, eh?
05:54:10 <xerox> Yessss
05:54:10 <zarvok> heh
05:54:10 <shapr> dons: zactly
05:54:13 <zarvok> I'll donate!
05:54:21 <shapr> zarvok: Happily, xerox has gotten cabal-get to the point where I can put up Hope packages.
05:54:28 <shapr> I'd donate too.
05:54:30 <zarvok> would be nice
05:54:42 <zarvok> I e-mailed bringert, but really have no idea what the error I got was about
05:54:43 <shapr> I'd try to bribe musasabi and dons into writing the distributed stuff.
05:55:05 <dons> bribes are fine
05:55:10 <zarvok> heh
05:55:13 <shapr> Would they have any effect?
05:55:17 <xerox> @arr
05:55:17 <mbot> Har de har har!
05:55:21 <shapr> @yarr
05:55:22 <mbot> Keelhaul the swabs!
05:55:25 <shapr> @quote
05:55:25 <mbot> TuringTest says: They got it work in Haskell without understanding Haskell.  It is quite an achievement, of some description.
05:55:36 <shapr> Is there a webpage where we can browse the quotes?
05:55:52 <int-e> hmm, does anyone remember what that quote refers to?
05:55:53 <shapr> Anyway, I'm trying to build a commercial website with Hope, so ...
05:55:59 <xerox> shapr: cool!
05:55:59 <dons> well, you'd have less of whatever you tried to bribe me with...  and I'd have more :)
05:56:09 <dons> shapr: cool :)
05:56:11 <shapr> int-e: Yeah, a bunch of Erlang guys wrote something large in Haskell and posted to the list about it.
05:56:20 <int-e> ah
05:56:36 <dons> it was the bitshifting library?
05:56:45 <dons> their code was pretty scary, iirc
05:56:47 <shapr> int-e: iirc, they made comments like "Once we found unsafePerformIO and IORefs..."
05:56:54 <zarvok> heh
05:57:18 <shapr> I think it was a bitshifting library.
05:57:24 <shapr> They were trying to compare Haskell and Erlang.
05:57:32 * kzm is happily compiling 6.5-20060817.
05:57:59 <shapr> They ended up saying Haskell was nicer than they expected. But most of the resulting traffic on #haskell was along the lines of that TuringTest quote.
05:58:05 <mux> hah!
05:58:07 <int-e> shapr: Uh - uhm. O-kay.
05:58:26 <mux> I finally got to define a data type and instances of XmlContent and friends, and I can generate an XML document from a datatype
05:58:35 <mux> now the other way around :-)
05:59:13 <shapr> The code really is an amazing tribute to "What would happen if a bunch of really smart and motivated people decided they really *did* want to get that Int out of IO, and had no one around to tell them why they shouldn't?"
05:59:15 * kzm is not so happily discovering that he needs Happy >1.15
05:59:27 <shapr> mux: Are you using HaXml 1.15 or later?
05:59:31 <shapr> XmlContent is way spiffy.
05:59:38 <mux> shapr: no, just 1.13.1
05:59:49 <shapr> I thought XmlContent didn't arrive till 1.14?
05:59:52 <mux> well
05:59:56 <mux> there is no XmlContent module
05:59:58 <shapr> Have you seen malcolm's post about it?
06:00:03 <dons> kzm, you can't use a nightly snapshot?
06:00:06 <shapr> mux: huh?
06:00:07 <mux> but there is still XmlContent classes in the Xml2Haskell module
06:00:09 <int-e> shapr: ouch :)
06:00:16 <mux> I don't know what's different, but it works
06:00:20 <kzm> binary shapshot?  Maybe.  Will check.
06:00:26 <shapr> mux: Hey, if it works...
06:00:30 * mux nods
06:01:04 <mux> I could probably make my life easier by using DrIFT, but it seems it wouldn't do things exactly as I would like them to be, plus I'll get to understand things better by doing it manuall
06:01:10 <zarvok> so why were these erlang hackers suddenly attempting a big haskell project?
06:01:28 <shapr> I don't remember, check the thread?
06:01:36 <zarvok> yeah, will do
06:01:37 <shapr> mux: I totally agree.
06:01:46 <shapr> hey scc
06:02:03 <shapr> scc: ski was saying something about your logic glyphs, but I forget what.
06:02:09 <shapr> scc: you should talk to him.
06:02:40 <Pupeno> zarvok: because Haskell is cooler than Erlang except in distributing applcations ?
06:02:58 <shapr> I think that's accurate.
06:03:00 <dons> they were writing a paper about some new language extension
06:03:10 <dons> and wanted to compare against a few other langs
06:03:12 <shapr> @google erlang haskell bitshift paper
06:03:12 <mbot> search module failed: IRCRaised getHostByName: does not exist (no such host entry)
06:03:15 <shapr> wargh!
06:03:21 <zarvok> ah, make sense
06:03:45 <Pupeno> If Haskell has Erlang's distributed capabilities, many people choosing Erlang may choose Haskell (like me, in some cases), but then, I don't think that's a big market.
06:03:54 <shapr> I want lambdabot on my nokia 770, then I'll never have to do without her.
06:04:13 <shapr> Pupeno: Erlang is a *very* large market inside Ericsson.
06:04:21 <shapr> And Ericsson makes serious money.
06:04:47 <shapr> On the other hand, Haskell's advantages have given it other footholds.
06:05:07 <Pupeno> shapr: yes, but they are, from my point of view, outside of the 'many' people that would choose Haskell instead of Erlang, no matter how better Haskell is in distributed applications.
06:05:10 * shapr tries to figure out how to make a real website on top of Hope.
06:05:51 <shapr> Pupeno: Part of that reason is that Erlang was invented specifically for Ericsson and the needs of phone switches. It'll be very hard for anyone to beat that.
06:05:51 <xerox> shapr: are you going to write more hope modules?
06:06:04 <tibbe> shapr: what's Hope like, is it a web application framework thingy or is it a http server as well?
06:06:14 <shapr> xerox: Probably
06:06:22 <shapr> tibbe: It's a webapp framework thingy.
06:06:42 <shapr> Roughly, Hope talks to HaskellDB, where all the state is kept.
06:07:14 <Pupeno> on the following days I plan to develop a secret demo for the place where I am working, re-doing a big part of our ugly distributed Python application in Erlang. I plan to do two weeks of coding in a few hours. If I could choose Haskell over Erlang I'd do it, but I don't think that's possible.
06:07:39 <Pupeno> shapr: indeed. But outside Ericsson, Haskell may stand a chance against Erlang.
06:07:41 <shapr> Hope sits on top of libraries like cgi, fastcgi, xhtml, parsedate, gd & exif, hscolour, rss, ByteString
06:08:15 <shapr> Truly, the Erlang guys did a lot of hard work to get hot code loading working *correctly*.
06:08:44 <shapr> If Haskell wants to beat Erlang at its own game, YHC portable bytecode looks like the best option right now.
06:08:45 <xerox> ...and *fast* ? :)
06:09:15 <tibbe> shapr, so it uses some webserver that talks fastcgi or cgi? haskell one?
06:09:25 <shapr> tibbe: I'm sure it could use the Haskell webserver.
06:09:35 <shapr> But I've only tried it with Apache.
06:09:37 <tibbe> shapr, actually I
06:09:37 <eivuokko> If I understand correctly, JITting yhc bytecode shouldn't be too hard.
06:10:10 <eivuokko> Although, how much it would help without inlining, is a bit guesswork.
06:10:15 <tibbe> shapr, Actually I'm looking for a haskell web server that exposes a, handle :: Request -> IO Response to me
06:10:45 * tibbe curses at his american english keyboard
06:10:53 <xerox> tibbe: that's happs.org !
06:10:53 <shapr> tibbe: In that case, check out Peter Thiemann's HWS-WASH
06:11:01 <zarvok> shapr: I'm not so sure it could run on the hws - doesn't it depend on a couple apache mods?
06:11:10 <shapr> Or HAppS, which I haven't tried yet.
06:11:23 <shapr> zarvok: I dunno, does it?
06:11:36 <tibbe> I was thinking of doing some experiments using REST style web services
06:12:04 <shapr> I think someone has done that sort of experiment in Haskell, but maybe they just talked about it. I'm not sure.
06:12:09 <zarvok> I think it needs mod-rewrite
06:12:12 <shapr> Anyway, I'd like to here what you find out.
06:12:15 <shapr> hear*
06:12:20 * shapr has been thinking in Swedish lately
06:12:41 <shapr> Swedish is breaking my American spelling! Incompatible bytecode!
06:12:42 <tibbe> thinking in Swedish is a good thing ;)
06:12:53 <shapr> Är du säkert?
06:13:08 <kzm> Is it possible to specify conditional dependencies in Cabal?  E.g for ghc 6.4 I must depend on fps, but for 6.5, I must not.
06:13:10 <tibbe> oh ja!
06:13:18 <kzm> bork bork bork?
06:13:48 <shapr> Hej, du är norsk, det är inte så olika!
06:13:50 <tibbe> kzm, did you succeed in building a debianized package of GHC 6.5?
06:13:58 <kzm> Det blir omtrent det samme.
06:14:15 <kzm> (But the chef is Swedish)
06:14:20 <tibbe> :D
06:14:25 <shapr> True that
06:14:42 <ValarQ> kzm: bork på dig också
06:15:00 <kzm> tibbe, no - didn't try.  I managed to build a deb of my own stuff a while ago, but forgot exactly how.  It included dh_something to generate the debian dir, and violently hacking it until a .deb emerged.
06:15:25 <arcatan> all #haskell speaks swedish?
06:15:50 <ValarQ> arcatan: no, there are 4 people who doesn't speak swedish here
06:15:57 <tibbe> arcatan, of course, it's required to learn haskell
06:16:00 <shapr> Python is primarily Dutch, but Haskell is primarily Swedish! Yay!
06:16:02 <zarvok> heh
06:16:11 <shapr> heippa hei arcatan!
06:16:18 <shapr> hyvää paiva!
06:16:21 <arcatan> :)
06:16:21 <tibbe> arcatan, it's the next logical step
06:16:28 <tibbe> shapr, don't curse
06:16:33 <arcatan> tibbe: oh, luckily I happen to know same swedish
06:16:38 <shapr> rakasta!
06:16:48 <shapr> Minä haluan suklataa!
06:16:51 <kzm> Wonderful news: ghc-6.5 appears to be *way* more efficient!
06:16:56 <sieni> shapr: how is alexandre paiva related to this?
06:17:01 * tibbe wants to try 6.5
06:17:16 <arcatan> *some
06:17:32 * ValarQ had some problems with ghc6.5s buildsystem
06:17:38 <shapr> My favorite use of finnish so far is to name a spam filter 'Paskelle'
06:17:40 <kzm> tibbe, well - this is the only case so far where it hurts with 6.4.
06:17:44 <shapr> @users
06:17:44 <mux> I find this idea of defining rules to translate from a datatype to XML and the other way around very, very nice
06:17:45 <mbot> Maximum users seen in #haskell: 198, currently: 196
06:17:49 <mux> it generates DTD automagically
06:17:59 <shapr> er, Paskalle
06:18:37 <tibbe> mux, do you know if HaXML works when you don't know what the XML will look like at runtime?
06:18:48 <tibbe> mux, uhm, at compile/write time ;)
06:19:03 <int-e> argh, the base libraries don't compile without bytestring anymore - the cgi package uses it.
06:19:20 <tibbe> although it would be interesting to deal with XML that you which structure you don't know at run time...
06:19:34 <mux> tibbe: hmmm.  given that filters and stuff are first order, I'd guess so
06:19:43 <tibbe> s/redundant words/
06:19:52 <mux> you could probably define a "dynamic" parser
06:20:36 <tibbe> I'll have a client send me XML via HTTP post which structure depends on some database schema
06:20:56 <shapr> Has anyone else here tried the HaskellNet code?
06:21:03 <int-e> kzm: I agree, it (putting fps in base) was a bad idea.
06:21:06 <tibbe> shapr, I tried to compile it
06:21:13 <shapr> Did you get my reply?
06:21:32 <tibbe> yes, haven't got around to try again yet
06:21:34 <shapr> ok
06:22:02 <tibbe> my gf leaves for sweden tomorrow so after that I've got plenty of spare time unfortuneatly
06:22:16 <shapr> You're not in Sweden? For some reason I thought you were Swedish.
06:22:18 <tibbe> I'll try then
06:22:28 <shapr> Of course, I'm not Swedish.
06:22:30 <tibbe> shapr, I am but I'm in France on an internship
06:22:38 <tibbe> I know
06:22:38 <shapr> Jar är Alabamsk!
06:22:44 <mux> it'd be nice to have them send the DTD as well, or something
06:22:46 <tibbe> hehe
06:23:12 <shapr> I'm going back to the USA and leaving my gf behind for awhile :-(
06:23:12 <mux> wow, I lag a lot.
06:23:17 <tibbe> mux, I'll be abusing the XML somewhat, it's a glorified hash, only one level deep
06:23:45 <tibbe> shapr, :( that sucks, I'm leaving for Zurich in januari and have to leave mine behind as well :(
06:23:52 <scc_> hello shapr I wasn't alerted because of the underscore, I liked the Booleans they seem to fit their name :)
06:23:59 <shapr> heh :-)
06:24:13 <shapr> My gf drew a great monad pic today, but I think a bug in the drawing program ate the picture :-(
06:24:18 <kzm> Anybody going to Portland (ICFP)?
06:24:28 <shapr> It was great, the monad had a lasso and was 'binding' the just and nothing guys.
06:24:36 <shapr> And the booleans were running around in the background.
06:24:38 <tibbe> :)
06:24:52 <shapr> I'll see if I can recover it later.
06:25:30 <tennin> I'll be in Portland
06:25:46 <mux> well you'd do like 99% of XML users then :-)
06:26:31 <tennin> wish it wasn't there till next year, as a relative newbie I don't really feel worthy of ICFP yet =)
06:26:34 <scc_> they sound like great chapter beginning pics
06:26:46 <tibbe> mux, yes and I think a data type will be somewhat overkill for my use and probably not a 100% fit
06:27:01 <tibbe> mux, I will basically translate the XML straight into SQL
06:27:22 <tibbe> when is ICFP?
06:28:10 <Igloo> http://icfp06.cs.uchicago.edu/
06:28:17 <Igloo> Early registration ends today
06:29:36 <tennin> are the surrounding events like the Haskell Workshop only for paid ICFP attenders?
06:30:32 <tennin> attendees
06:30:32 <Igloo> You pay separately for them
06:30:49 <Igloo> https://regmaster2.com/cgi-bin/ICF06/on1/RMSs.cgi
06:31:55 <shapr> Dang, the Monad picture appears to be gone forever :-(
06:32:12 <tennin> ok, thanks
06:32:59 <mux> tibbe: good luck :-)
06:33:14 <scc_> :(
06:34:58 <shapr> scc_: Have you seen the other pix my gf drew on my 770?
06:35:14 <scc_> no
06:35:25 <shapr> They're all under the art tag - http://www.scannedinavian.com/hope/tag/art
06:35:59 <shapr> The comic strip was done in Inkscape, and the vertically taller pix were done on a T610(?) touchscreen phone.
06:37:07 <shapr> She draws all sorts of stuff using watercolors, oils, ink, anything that looks good. I have a stack of nifty drawings from her.
06:42:19 <scc_> I think I like the Booleans best (maybe because I'm a geek). 770?
06:42:33 <shapr> Nokia 770
06:42:41 <tennin> I like the kitten
06:46:06 <scc_> although answer the damn phone does have an air of frustration and the comic is funny
06:46:12 <tennin> in two weeks I'll be moving to Portland and leaving my cats behind =(
06:47:29 <scc_> :
06:47:36 <scc_> oh and (
06:47:50 <xerox> meow
06:48:37 <ValarQ> *chirp*
06:49:23 <tennin> the masked? spotted lizards? are intriguing
06:50:57 <tibbe> http://www.flickr.com/photos/13431271@N00/217756203
06:51:28 * tibbe wonders if someone could tell that he's bored
06:51:35 <tibbe> I should probably move to blah
06:51:41 <tennin> shapr: have you seen "why's poignant guide to ruby"?
06:52:01 * sieni is bored
06:52:16 <xerox> Watch more comics?
06:52:19 * xerox chuckles
06:55:25 <kzm> One quick question: when profiling, I have generally ignored the %alloc column.  But since I have excessive GC time, is that a good place to check more carefully?
07:01:08 <astrolabe> Are there built-in functions for doing union and intersection etc on sets represented as ordered lists?
07:03:46 <xerox> OK, I completely taken out the xmlrpc dependency from cabal-install.
07:03:57 <xerox> (I.e. the remaining bits)
07:04:55 <tibbe> xerox, nice :) what's the current state of cabal-install?
07:06:39 <xerox> I am going to put together a repository today I think, so people can use it
07:07:17 <xerox> It still has some dependencies, and I don't know how to get rid of them, so I need to discuss it, I'll be posting to cabal-devel
07:09:09 <tibbe> what are those dependencies?
07:09:14 <tibbe> I'll be willing to test it
07:09:28 <xerox> Crypto-2.0.0    HTTP-2005.5.5   NewBinary-0.1
07:09:28 <xerox> GnuPG-0.1.1     HaXml-1.2       XmlRpc-2005.5.5
07:09:35 <xerox> XmlRpc is now gone
07:09:59 <xerox> IIRC dcoutts said they made a HTTP bundle with the bits of crypto it needs so they are gone too (but I am not sure)
07:10:19 <dcoutts> yep
07:10:30 <xerox> I want to investigate what is HaXml used for, because I don't know. Then it's just GnuPG (which probably should remain) and newbinary, which also I don't know what it is used for.
07:10:36 <tibbe> how about GHC, is 6.4.1 enough?
07:11:01 <tibbe> I think I had some problems trying to build NewBinary the other day
07:11:35 <dcoutts> HTTP-2006.7.7 has fewer deps
07:12:16 <dcoutts> xerox, what does it need haxml for ?
07:12:23 <xerox> dcoutts: do you have any insight<Interrupted by dcoutts>
07:12:28 <xerox> ... :)
07:12:31 <dcoutts> heh
07:13:02 <dcoutts> and presumably you don't need Crypto now that http no longer needs it
07:13:13 <dcoutts> and indeed NewBinary
07:13:14 <mux> NewBinary is also included in HTTP now
07:13:16 <mux> yes
07:13:20 <xerox> May it's xmlrpc that depended on it
07:13:29 <dcoutts> http never needed newbinary
07:13:38 <dcoutts> it needed crypto which needed newbinary
07:13:48 <xerox> Goooood.
07:13:52 <dcoutts> http never used any of the bits of crypto that needed newbinary
07:14:07 <dcoutts> so that leaves just gnupg right?
07:14:11 <xerox> dcoutts: so GHC people would be fine with the HTTP bundle you were suggesting?
07:14:18 <dcoutts> dunno
07:14:18 <scc_> ski, regarding why 'consequence': Socrates is a man implies he is mortal, Socrates is mortal is a _consequence_ of him being a man. I know Dijkstra used the term I don't know if it originated with him.
07:14:20 <xerox> If so, yes.
07:14:59 <dcoutts> xerox, we could probably persuade ghc binary builds to include http
07:15:07 <xerox> I'll try removing all the dependencies beside GnuPG and update the HTTP bundle ok?
07:15:12 <ski> scc_ : i just thought it a little weird to use 'consequence' as the converse of 'implication'
07:15:17 <dcoutts> ghc now builds its non-core libs with cabal I think
07:15:33 <xerox> Somebody was saying so at anglohaskell i think, yes
07:15:40 <xerox> But not all of them
07:15:43 <dcoutts> xerox, and as for gnupg, I think there's very little code in that package
07:15:54 <xerox> Maybe it was ndm complaining because some of them aren't cabal-builded yet
07:15:57 <dcoutts> if we really need it we could just include it in cabal-install
07:16:07 <dcoutts> xerox, yep, base doesn't build with cabal yet
07:16:11 <xerox> Right
07:16:26 <dcoutts> are we actually using gnupg yet? I thought we were not
07:16:30 * xerox too
07:16:32 <ski> (scc_ : hm, another possible name for 'A and not B' is 'A excluding B')
07:16:41 <dcoutts> the current model is that trusted people can upload
07:16:47 <xerox> That's right
07:16:47 <tibbe> dcoutts, I believe I have the http library on ubuntu, an old version though
07:16:50 <xerox> monk users
07:16:51 <dcoutts> when we relax that we'll introduce signing
07:17:01 <xerox> So it can go away too, prolly
07:17:05 <dcoutts> I think so
07:17:08 <dcoutts> so it's just http
07:17:15 <xerox> yes
07:17:22 <xerox> I'll do that now, I like this thing :)
07:17:24 <dcoutts> @yarr!
07:17:24 <mbot> Gangway!
07:17:28 <xerox> @yarr! indeed!
07:17:29 <mbot> I'll crush ye barnacles!
07:17:36 <xerox> silly mbot :P
07:21:08 <xerox> How do you do comments in cabal files?
07:21:22 <xerox> # -- // /* */ {- -} ?
07:22:48 <tibbe> just out of curiosity, what editors do you guys use?
07:23:02 <xerox> Emacs
07:23:06 <xerox> (and vim)
07:23:32 <tibbe> oh, both?
07:23:52 <xerox> Depends on what I have to do, emacs for long runs, vims for short edits.
07:24:01 <tibbe> I started to use the inf-haskell thing in emacs a week ago and it has been good to me
07:24:14 <xerox> It's pretty nice, yeah
07:26:45 <int-e> xerox: -- works
07:27:12 <xerox> Right, thanks.
07:28:43 <tibbe> > do {1; return ()} :: [Int]
07:28:45 <mbot>  Couldn't match `Int' against `()'
07:28:53 <xerox> That's [()]
07:29:07 <tibbe> hmm
07:29:19 <xerox> ?type return ()
07:29:21 <mbot> forall (m :: * -> *). (Monad m) => m ()
07:29:25 <tibbe> in the list monad is >>= cons and return [] ?
07:29:29 <xerox> ?type \x -> x >> return ()
07:29:30 <mbot> forall a (m :: * -> *). (Monad m) => m a -> m ()
07:29:40 <xerox> Nope.
07:30:02 <xerox> Bind is concatMap and return is box (\x -> [x])
07:30:12 <int-e> (>>=) is flip concatMap and return (:[])
07:30:12 <tibbe> I see
07:30:52 <tibbe> > do {[1]; return 1} :: [Int]
07:30:53 <mbot>  [1]
07:31:36 <xerox> > do { [1..10]; return 1 }
07:31:37 <mbot>  [1,1,1,1,1,1,1,1,1,1]
07:31:44 <xerox> You would have said that? ;)
07:33:28 <scc_> the two unnamed can also be viewed strict orders so "a is weaker than b" and "a is stronger than b" (at least for predicates)
07:34:03 <ski> hm ?
07:35:02 <ski> scc_ : elaborate
07:38:22 <scc_> like strict subset for sets where the truth values would correspond to the empty set and the universe
07:40:15 <mnislaih> Lemmih: ping
07:40:30 <Pupeno> Woa... writting Python in a Haskell-way makes it clearer.
07:42:51 <abcde`> wrong button.
07:44:19 <SamB> Pupeno: you can do that?
07:45:03 <Pupeno> SamB: to some extend in the simple cases.
07:48:01 <basti_> hi
07:48:35 <shapr> tennin: Nope, haven't seen it.
07:48:40 <shapr> tennin: But I have tried Ruby
07:54:28 <kowey> is there a common idiom for something like: modifyIf f m v = if f v then m v else v ?
07:58:49 <shapr> when?
07:58:57 <shapr> @index when
07:58:58 <mbot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
07:59:02 <shapr> @type Control.Monad.when
07:59:04 <mbot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
07:59:50 <kowey> hmm... yeah, but that's for monads... oh well... i guess i'll just call it onlyIf... was just wondering if there was a standard name for it
08:01:09 <shapr> Seems sort of like Control.Monad.guard
08:03:00 <kowey> kinda... i am surprised this isn't a more common notion... "if something has a property, modify it like so, otherwise give me back the same"
08:04:57 <shapr> maybe?
08:05:09 <kowey> yeah, but that's just for Maybe :-)
08:05:24 <kowey> onlyIf (> 4) (+3) 5 == 8
08:05:55 <kowey> (this could be just bad style on my part, maybe why it isn't more common... excessive pointlessness)
08:06:18 <xerox> @remember Pupeno Woa... writting Python in a Haskell-way makes it clearer.
08:06:18 <mbot> Done.
08:06:34 <Pupeno> :)
08:06:40 <xerox> Ops, that's mbot.
08:06:59 <shapr> Pupeno: that's how I got started with Haskell, I was writing purely functional Python.
08:07:48 <Pupeno> shapr: After learning Haskell/Erlang/Lisp I am writting lot's of functional code in Python.
08:07:55 <shapr> Cool!
08:08:33 * dylan uses foldl a lot in perl.
08:09:25 <SamB> purely functional python... is not very convnenient.
08:10:24 <SamB> I mean... no monads... no tailcalls...
08:10:42 <SamB> no purely functional IO...
08:10:50 <shapr> scc_: Ok, I've posted the next creative Haskell visualization from my gf.
08:11:05 <SamB> your girlfriend?
08:11:33 <shapr> yup
08:11:43 <tibbe> is there any useful emacs tricks I should be aware of when writing haskell, like pulling up some docs or something like in Lisp?
08:11:53 <shapr> Zillions
08:11:58 <shapr> @oldwiki HaskellMode
08:11:58 <mbot> http://www.haskell.org/hawiki/HaskellMode
08:12:04 <SamB> oh, funny, I was half expecting you to say gf stood for something else
08:12:10 <ski> shapr : i like it :)
08:12:11 <araujo> hello
08:12:40 <shapr> SamB: http://www.scannedinavian.com/hope/entry
08:12:43 <xerox> hah
08:13:02 <shapr> I like their tracksuits.
08:13:15 <SamB> GF comes to mind...
08:13:35 <SamB> I forgot how to spell galois, though...
08:13:45 * araujo thinking how to use haskell for scripting
08:13:49 <shapr> And I wonder why True and False don't have arms... but sometimes it's better not to question the creative genius...
08:14:03 * shapr learns the answer and realizes that it is in fact better not to know sometimes.
08:14:06 <ski> (the spirals are not really 'G's, right ?)
08:14:23 <tibbe> shapr, useful stuff!
08:14:26 <SamB> hahahah
08:14:31 <xerox> shapr: tell us!
08:14:35 <SamB> shapr: she told you?
08:14:41 <SamB> xerox: "it is better not to know"
08:14:49 <SamB> she is reading over your shoulder?
08:15:03 <basti_> that is.... odd
08:15:05 <shapr> ski: She says that there are spirals on the outfit because the Maybe Monad is fashion conscious.
08:15:10 <xerox> Grab the keyboard!
08:15:11 <SamB> haha
08:15:14 <dcoutts> heh heh
08:15:17 <shapr> SamB: Sure, she's sitting next to me on the futon.
08:15:23 <dcoutts> hia!
08:15:25 <scc_> you don't think there is any underlying message for you do you shapr :P
08:15:26 <SamB> hello!
08:15:27 <ski> if he tells us, we'll all be bound by the monad forever, no escape !
08:15:42 <SamB> ski: heh
08:16:09 <SamB> shouldn't the J guy be carrying something?
08:16:17 <xerox> Fortunately the Maybe one isn't one-way
08:16:27 <shapr> SamB: He dropped it because he's running
08:16:32 <SamB> oh
08:16:49 <SamB> and the guy in red... is he supposed to be the type?
08:17:11 <xerox> She's bind I suppose
08:17:14 <shapr> Nah, that's the monad. C'mon, the lasso and the whip for bind?
08:17:24 <SamB> oh, oops, she
08:17:36 <shapr> Yeah, hips :-)
08:17:46 <SamB> and I guess that is a dress
08:18:06 <xerox> ?remember shapr Nah, that's the monad. C'mon, the lasso and the whip for bind?
08:18:06 <mbot> Done.
08:18:10 <xerox> Out of context will rock
08:18:27 <SamB> xerox: why are we having mbot remember stuff?
08:18:52 <Pupeno> shapr: you'd be able to write "The Illustrated Haskell Dictionary" or maybe "The Graphical Haskell Adventure" or "Haskell: The photobook"
08:18:55 <xerox> lambdabot didn't know enough maths, so we sent her to thehunter to fix it
08:19:07 <xerox> and we got mbot in the meanwhile
08:19:09 <shapr> Pupeno: Not me, my girlfriend can do it!
08:20:19 <SamB> xerox: so is dons going to merge in the quotes from mbot after?
08:20:35 <xerox> Maybe that'll be the case
08:20:40 <SamB> after he deals with this quota problem, that is
08:21:05 <xerox> Lemmih: what was the fix for "Distribution/Simple.hs:61:1: lexical error at character 'f'
08:21:25 <eivuokko> xerox, are you compiling Setup.hs for Cabal?
08:21:36 <xerox> Right.
08:21:41 <xerox> Oh, no, I should?
08:21:46 <russo> hey can you guys recomend me a haskell book
08:21:58 <eivuokko> Lemmih recommends runghc -i Setup configure etc
08:22:14 <eivuokko> I'd do ghc -hide-all-packages -package Cabal -package base Setup -o setup
08:22:36 <xerox> Ah, that's where the -i should go, I couldn't figure out, but I remember it was that option
08:22:40 <xerox> Thank you very much esa
08:22:59 <eivuokko> np
08:23:01 <russo> hey can you guys recommend me a haskell book (i think i wasn't identified i dunno if the channel saw this)
08:23:31 <petekaz> xerox, shapr: you guys _must_ do something about the hideous color scheme of hope, not to mention the logo.
08:23:35 <xerox> russo: yeah we got it, I might suggest `The Haskell Road to Logic, Math & Programming', it's a very good book.
08:23:40 <xerox> petekaz: you're _so_ right.
08:23:45 <petekaz> It hurts my eyes reading your blog.
08:23:58 <shapr> petekaz: Use the RSS feed. Or write your own theme, it's easy!
08:24:03 <xerox> If you want to help with a css theme, hope has them
08:24:09 <xerox> Right :)
08:24:20 <xerox> shapr: FSVO easy :|
08:24:49 <shapr> russo: Thompson's "Craft of Functional Programming" and Hudak's "School of Expression"
08:24:51 <petekaz> I'm not using hope, my point is simply how can you tolerate the colors.  It is absolutely the worst color scheme I have ever seen in my entire life.
08:25:00 <shapr> petekaz: So fix it, it's open source!
08:25:12 <shapr> petekaz: If you produce a theme you like better, I promise to use it. How's that?
08:25:15 <petekaz> I'll get right on that in my free time.
08:25:26 <xerox> shapr: aha-that's an idea.
08:25:39 <petekaz> ah .. incentive.
08:25:47 <petekaz> it would make reading your blog more enjoyable.
08:25:52 <russo> shapr: are they functional programming books or haskell ones
08:26:16 <xerox> I should also try to write one
08:26:22 <Stinger_> school of expression is haskell
08:26:23 <shapr> russo: Specifically Haskell
08:26:37 <Stinger_> and apparently so is the other one :)
08:39:26 <xerox> dcoutts: all the dependencies are gone, HTTP is updated to 2006.7.7 ^_^ yay
08:39:35 <xerox> (And everything builds)
08:44:07 <agocorona> Warning: At 0:00 PM a new day release will be installed: 2006.08.19
08:44:51 <agocorona> Hi all
08:45:03 <tennin> "why's poignant guide to ruby" is a cartoon tutorial for the language
08:45:15 <xerox> Hello :)
08:46:03 <tennin> well, a tutorial with interspersed cartoons
08:48:19 <shapr> tennin: Ohh
08:48:41 <tennin> some of his syntax mnemonics are neat
08:49:22 * mux grumbles
08:49:35 <mux> it's much easier to code the toElem method for XmlContent than the fromElem one :-)
08:50:44 <tennin> I also remember an old FORTH book with cartoon avatars for each command word
08:51:29 <arcatan> it would be nice if there was a tutorial for haskell with cartoon foxes and pet ham and stuff
08:53:30 <mux> I wish the haskell modules were more fully documented, and had examples and such
08:53:32 <shapr> If I started a fund to get my girlfriend to illustrate it, who would contribute?
08:55:42 <tennin> A non-broke alternate universe version of myself?
08:55:54 * shapr grins
08:56:16 <shapr> Anyway, if a few people are willing to contribute, I'd organize such a thing.
08:56:45 <Stinger_> tennin right after you(he) lights a cigar with a 100 dollar note
08:56:51 <kowey> would be great if the cartoons could go to the wikibook once produced
09:06:03 <audreyt> @pl foldr (.) id
09:06:04 <mbot> foldr (.) id
09:06:18 <audreyt> surprised it doesn't have a canonical name.
09:08:57 <xerox> audreyt: it has, in some sense
09:09:00 <xerox> ?wiki Compose
09:09:00 <mbot> http://www.haskell.org/haskellwiki/Compose
09:09:02 <xerox> ^_^
09:10:27 <audreyt> ok :)
09:10:31 <audreyt> xerox++
09:10:51 <xerox> ^_^
09:15:21 <agocorona> Anyway, we have to restrict the cartoons figures to be composed by order -n polinomials with integer parameters
09:15:58 <agocorona> ;-)
09:20:31 * xerox rolls on the floor complaining
09:20:42 <xerox> Irssi uptime: 245d 0h 45m 22s
09:21:00 <xerox> Broadcast message from root (pts/14) (Fri Aug 18 17:18:44 2006): Moving to new machine. The system is going DOWN to maintenance mode in 60 minutes!
09:21:08 <xerox> Life is though.
09:22:07 <basti_> :(
09:22:16 * SamB wishes GADTs could derive show...
09:22:22 <SamB> er, Show
09:32:02 <SamB> hmm, what do derived Show instances do..
09:41:12 <dcoutts> g'evening SyntaxNinja
09:41:39 <dcoutts> we could do with your input on a few questions raised on the libraries list and on cabal-devel
09:51:26 * SamB wonders what the point of conditionals is in a language with no way to get booleans besides literals
09:52:12 <SamB> I suppose that part is left to the imagination...
09:53:54 <SyntaxNinja> y0
09:54:10 <SyntaxNinja> dcoutts: OK. I'll do my best to get to it today.  I've been out of town, and I'm going out of town again next week :(
09:54:22 <dcoutts> SyntaxNinja, ah ok
09:54:25 <dcoutts> so am I :-)
09:54:38 <SyntaxNinja> is this blocking xerox progress on cabal-get?
09:54:45 <dcoutts> no
09:55:08 <dcoutts> I'll be away from Monday for about 10 days
09:55:20 <dcoutts> so we're both not going to be here for the GHC 6.6 RC.
09:55:31 <dcoutts> we'll have to get JaffaCake to tag the repo
09:56:11 * dcoutts is going to Sweden
09:56:13 <dcoutts> yay!
09:57:18 <dcoutts> SyntaxNinja, but if you get some time to look at discussion, ndm and eivuokko could do with some feedback.
09:58:03 <dcoutts> the issue of "runghc Setup.lhs anything" not working in the Cabal repo is a bit annoying and on windows it's very annoying as they don't use make.
09:58:33 <dcoutts> I tried adding {-# OPTIONS -cpp #-} to some modules but it didn't seem to work
09:58:42 <dcoutts> I think we use cpp too much generally
10:13:23 * SamB wonders if he should be writing his program in Omega
10:17:17 <SyntaxNinja> dcoutts: damn, didn't know that was broken :(
10:18:15 <eivuokko> dcoutts, Was it first line in the file?
10:24:56 <dcoutts> eivuokko, yeah
10:25:08 <dcoutts> SyntaxNinja, I don't know when it happened
10:25:19 <dcoutts> but it's fairly pervasive
10:25:26 <dcoutts> most files use cpp
10:25:48 <dcoutts> and runghc Setup.lhs tries to compile them all but without using -cpp
10:26:13 <eivuokko> Well, even if you add -cpp, iirc it doesn't work.  Atleast didn't last time I tried.
10:26:30 <dcoutts> oh, it did for me
10:26:32 * dcoutts tries
10:26:43 <eivuokko> Maybe it got fixed or something
10:27:25 <dcoutts> runghc -cpp Setup.lhs --help
10:27:27 <dcoutts> works
10:27:40 <eivuokko> A sec, I'll try.
10:28:01 <Stinger_> hmm can do syntax can be done like : do { e1 ; e2 ; e3 }
10:28:27 <eivuokko> dcoutts, Right, works for me too.  Nice.
10:28:32 <dcoutts> Stinger_, yes
10:29:29 <SyntaxNinja> hangon, this is for Setup.lhs files that use cpp?
10:29:37 <dcoutts> no
10:29:40 <Stinger_> hmm other problems then :)
10:30:00 <dcoutts> SyntaxNinja, this is because runghc looks for Distribution.Simple
10:30:18 <dcoutts> SyntaxNinja, and finds it locally rather than in any installed Cabal package
10:30:31 <dcoutts> which is good for bootstrapping
10:30:39 <dcoutts> except that everything uses cpp
10:31:38 <dcoutts> using 'make' it's different, since:
10:31:40 <dcoutts> $(HC) $(GHCFLAGS) -i. -odir dist/tmp -hidir dist/tmp Setup.lhs -o setup
10:31:52 <dcoutts> GHCFLAGS= --make -Wall -fno-warn-unused-matches -cpp
10:31:56 <dcoutts> it uses -cpp
10:37:55 <dcoutts> SyntaxNinja, oh btw, can I remove HSBASE from the Makefile. It's not a good default. If you need to override GHC you can use make HC=/usr/bin/local/ghc-6.5
10:38:07 <xerox> @arr
10:38:07 <mbot> Keelhaul the swabs!
10:38:12 <dcoutts> @yarr!
10:38:12 <mbot> Avast!
10:39:00 <dcoutts> SyntaxNinja:
10:39:00 <dcoutts> -HCBASE=/usr/local/bin/
10:39:00 <dcoutts> -HC=$(HCBASE)ghc
10:39:00 <dcoutts> -HC_PKG=$(HCBASE)/ghc-pkg
10:39:04 <dcoutts> +HC=ghc
10:39:04 <dcoutts> +HC_PKG=ghc-pkg
10:39:34 <dcoutts> so by default it'll use ghc & ghc-pkg from the path, which is a sensible default.
10:40:00 <dcoutts> at the moment it says: /usr/local/bin/ghc: no such ... blah blah
10:45:32 <SyntaxNinja> dcoutts: fine.
10:46:05 <SyntaxNinja> dcoutts: oh, you mean trying to use "runghc" for cabal's setup file itself? yeah, I don't think that's ever worked.
10:46:12 <dcoutts> right
10:46:17 <SamB> hmm, I'm pretty sure you can't prove equivalence of two functions in Haskell...
10:46:43 <xerox> SyntaxNinja: hello! Did you see my recent patches?
10:47:06 <SamB> I was wondering if this paper did anything you really can't do in Haskell
10:47:32 <xerox> SyntaxNinja: the only dependency left is HTTP, which is now a self-contained bundle (I am polishing the patch right now).
10:48:13 <xerox> SyntaxNinja: It could either be shipped with cabal-install (is very small), or, as dcoutts suggested, could even be put in base at some point, if the GHC people like it.
10:48:35 <dcoutts> xerox, no I didn't say in base
10:48:48 <SyntaxNinja> xerox: awesome :)
10:48:58 <xerox> Errrr, in packages!
10:48:59 <dcoutts> I said distributed as one of the many packages that will be included in ghc binary builds
10:49:00 <SyntaxNinja> xerox: sorry, haven't seen it yet.  I've been out of town. will try to look today.
10:49:08 <xerox> SyntaxNinja: no problem!
10:59:08 <Lemmih> mnislaih: Greetings.
11:05:53 <xerox> *BOOM*
11:06:00 <abcde`> whoa
11:33:59 <mnislaih> Lemmih: hi
11:34:25 <mnislaih> did you look at the code ?
11:41:29 <astrolabe> @yow
11:41:29 <mbot> Couldn't find fortune file
11:46:15 <lispy> or
11:46:16 <lispy> er
11:46:18 <lispy> sorry
11:47:49 <Lemmih> mnislaih: Not yet. But I've seen your PMs and it's on my TODO list.
11:52:14 <mnislaih> Lemmih? are you receiving my PMs ?
11:52:27 <mnislaih> my PMs as of right now
11:52:30 <Lemmih> Yep.
11:57:31 <Cale> @yow
11:57:32 <mbot> The Korean War must have been fun.
11:57:34 <Cale> @yow
11:57:35 <mbot> Quick, sing me the BUDAPEST NATIONAL ANTHEM!!
11:57:40 <Cale> @yow
11:57:41 <mbot> We place two copies of PEOPLE magazine in a DARK, HUMID mobile home.
11:57:41 <mbot> 45 minutes later CYNDI LAUPER emerges wearing a BIRD CAGE on her head!
11:57:55 <ValarQ> @get-shapr
11:57:55 <mbot> shapr!!
11:58:33 <ValarQ> aw, we lost shapr in the netsplit :/
11:59:46 <musasabi> tibbe: one can do the Request -> IO Response with HAppS.
12:00:06 <tibbe> musasabi, great
12:00:14 <musasabi> tibbe: look under http://www.cs.helsinki.fi/u/ekarttun/haskell for a subdirectory like happs-httpd
12:00:38 <tibbe> I'll look into it as soon as I figure out why all my Firefox fonts have been instantly uglyfied to some bold variant
12:01:00 <musasabi> (I have a text-only terminal so no cut-paste or a graphical browser)
12:05:25 <musasabi> Will be here for 45min, then probably on monday-
12:05:50 <vegai> musasabi: hey, you talked about a patch against fps-0.7 for happs. Is that still around?
12:07:09 <vegai> or has it become a non-issue?
12:07:44 <musasabi> vegai: http://www.cs.helsinki.fi/u/ekarttun/haskell + happs-fps.patch or some such.
12:07:58 <musasabi> vegai: will probably integrate it next week.
12:08:34 <vegai> ok, I'll check it out
12:08:56 <vegai> HAppS looks very nice, but I'm finding it a bit hard to dive in
12:13:20 <tibbe> same here
12:13:38 <tibbe> what's the entry point
12:13:45 <tibbe> I just want to add a handler
12:13:59 <musasabi> tibbe: have you looked at pass.net ?
12:14:03 <musasabi> for app code.
12:14:11 <musasabi> tibbe: what kind of handler?
12:14:13 <vegai> It's weird when the "Hello world" example has neither the word "Hello" or "world" in it ;)
12:14:25 <Cale> vegai: hehe
12:14:31 <musasabi> ;P
12:14:42 <Cale> main = putStrLn "Hello, world!"
12:15:08 <vegai> I mean this, of course: http://happs.org/HAppS/examples/hello.hs
12:15:18 <tibbe> musasabi, I want to handle all incoming HTTP requests, do some conversions using the URI and POST content and return some XML
12:16:22 <musasabi> tibbe: that should be easy enough.
12:16:55 <musasabi> tibbe: do you want to use the MACID stuff or just the pure request/response?
12:17:28 <musasabi> (sorry if I make little sense, quite tired)
12:19:41 <tibbe> musasbi, dunno what that is so I don't think I need it, basically I need the HTTP method, uri and some of the headers (accept content type)
12:20:13 <musasabi> tibbe: then look at the httpd example. It is without the MACID (transactions) stuff.
12:20:19 <tibbe> musasabi, I'll be right back, I'll try to restart X too see if that fixes my problems
12:20:26 <tibbe> the one you linked previously?
12:20:26 <musasabi> ok
12:20:29 <musasabi> yes
12:20:39 <tibbe> thanks I will, brb
12:21:33 <vegai> perhaps you should run, or you'll be answering our questions all night..
12:22:45 <musasabi> vegai: I can't sleep for some time yet. (need to eat lunch which is not yet ready)
12:23:17 <musasabi> But next week I will be better at answering things.
12:23:55 <musasabi> Now I only have 1) text terminal, 2) no GHC, 3) no access to my fileserver, 4) just was setting up a con for 17 hours.
12:25:33 <tibbe> that didn't help, oh well
12:31:31 <vegai> musasabi: cool. What was the con?
12:32:21 <vegai> hmm, in HAppS's hello.hs, where does the function simpleHTTP in the definition of main come from?
12:32:43 <musasabi> vegai: Finncon/Animecon.
12:32:48 <vegai> ah, found it already.
12:33:20 <vegai> does using xslt require special client-side support?
12:34:26 <musasabi> One can either do xslt on the server side (currently via xsltproc) or client-side (for mozilla etc)
12:34:59 <tibbe> musasabi, what are the deps of happs? (hmm, have I already asked this, I forget)
12:35:48 <vegai> tibbe: looking at the cabal file should reveal that
12:36:42 <musasabi> cabal file tells that
12:37:16 <tibbe> :)
12:38:11 <tibbe> dons fps site is down, is there a mirror somewhere?
12:38:50 <vegai> It's in Australia, which is practically the same ;P
12:39:05 <tibbe> :)
12:39:09 <musasabi> I think there is a mirror of a suitable fps version
12:40:00 <musasabi> test.happs.org/fps I think
12:40:53 <musasabi> http://test.happs.org/fps/Data/ByteString.hs etc (iirc)
12:53:06 <chessguy> Cale: i'm taking a 'principles of programming languages' class this fall, but still don't really have a grasp of the difference in paradigms between FP and imperative
12:54:24 <Cale> chessguy: http://www.haskell.org/hawiki/HaskellNewbie_2fObjectOrientedVsFunctionalProgramming -- here's something you could read :)
12:54:42 <musasabi> -> away
12:54:56 <Cale> chessguy: The main difference is that you have way less mutable state
12:55:10 <Cale> You don't use cells whose value changes over time
12:55:20 <Cale> You define things, and they stay as they are forever.
12:55:35 <chessguy> you don't have variables?
12:55:52 <Cale> Right :)
12:55:56 <Cale> at least, not to start with
12:55:56 <SamB> it depends on your point of view
12:56:05 <Cale> You do have functions though
12:56:10 <chessguy> obviously
12:56:12 <SamB> I asked a mathemetician what the difference between a variable and a constant was
12:56:16 <Cale> and those functions have parameters, which are sort of like variables
12:56:28 <Cale> SamB: yeah, it's just your point of view
12:56:29 <Cale> :)
12:56:39 <SamB> thats pretty much what he said too
12:56:46 <chessguy> well, a constant can never change what value it contains
12:57:08 <Cale> Right, and in Haskell, if a function returns a particular value for a given input, it always must return that value.
12:57:22 <SamB> mathemeticians don't go around changing what value a variable has like you do in imperative languages...
12:57:27 <chessguy> do you still have objects in haskell?
12:57:38 <Cale> chessguy: It's not OO
12:57:46 <Cale> Though you can get a lot of OO-like features
12:57:47 <chessguy> that's not what i asked
12:57:52 <SamB> C hasn't got objects either
12:57:53 <Cale> oh, no :)
12:57:53 <ski> there exists FP OO (O'Caml, e.g.)
12:58:20 <SamB> we have values
12:58:36 <chessguy> so, for imperative programming, you would approach a problem by defining a series of steps that need to be taken to solve the problem. how would you do the same in FP?
12:58:41 <Cale> If you're an advanced Haskell programmer, you can have existentially-typed values, which, in my mind, are pretty much like objects.
12:58:59 <Cale> chessguy: You'd break the problem down into smaller parts
12:59:29 <Cale> For example, let's try the problem of determining the length of a list.
12:59:45 <chessguy> ok
12:59:52 <Cale> In an imperative language, you might use something like a loop, and test for the end of the list
12:59:56 <chessguy> so in imperative programming, you'd loop through the list and count them
12:59:59 <Cale> right
13:00:26 <Cale> In Haskell, you'd define the length function for the empty list, and a nonempty list
13:00:28 <Cale> like:
13:00:31 <Cale> length [] = 0
13:00:35 <SamB> or use the one in the library ;-)
13:00:37 <Cale> length (x:xs) = 1 + length xs
13:00:39 <SamB> which already does this ;-)
13:00:53 <chessguy> a recursive definition
13:00:58 <SamB> Cale probably just stole that from the Prelude
13:00:58 <Cale> Where (x : xs) is the list that starts with x and the rest is xs
13:01:02 * SamB kids
13:01:04 <Cale> heh
13:01:15 <SamB> it would be easier to write it again ;-)
13:01:19 <Cale> yes
13:01:27 <ski> > 3 : [2,5,4]
13:01:28 <mbot>  [3,2,5,4]
13:01:31 <SamB> especially if you are allowed to do a bad job
13:01:55 <chessguy> hmm, that does seem more intuitively reusable
13:02:35 <Cale> One cool thing that we do is to recognise common patterns of recursion and bundle them up into functions
13:02:35 <chessguy> but recursion isn't always a good approach, of course
13:02:50 <Cale> Let's say I want to add 1 to all the elements of a list of numbers
13:03:02 <ski> (recursion is the basic looping method, in haskell)
13:03:03 <Cale> I could write it recursively
13:03:09 <Cale> f [] = []
13:03:16 <Cale> f (x:xs) = (x + 1) : f xs
13:03:30 <SamB> chessguy: yeah, there is not much choice about recursion
13:03:32 <chessguy> ok
13:03:40 <SamB> either you do it yourself or you use another function to do it for you
13:03:45 <Cale> However, this sort of thing, applying a function to all the elements of a list, is common
13:03:51 <Cale> So we factor it out like this:
13:03:55 <Cale> map f [] = []
13:03:55 <johnnowak> chessguy: recursion is always a good choice. ;)
13:04:06 <Cale> map f (x:xs) = (f x) : (map f xs)
13:04:21 <SamB> ooh, and:
13:04:35 <SamB> > map (+1) [1,2,3,4]
13:04:36 <mbot>  [2,3,4,5]
13:04:51 <Cale> neat eh?
13:05:02 <chessguy> Cale, and then? to use the map for +1?
13:05:05 <Cale> right
13:05:10 <Cale> like SamB just showed
13:05:13 <Cale> So now we're not thinking at the level of recursion or loops
13:05:18 <SamB> probably most of the functions Cale defines in the near future will already be in the Prelude ;-)
13:05:25 <Cale> We're thinking in terms of bigger operations
13:05:43 <chessguy> hmm
13:05:48 <ski> "transform each element of a list in some given way"
13:05:54 <ski> that's 'map'
13:06:11 <Cale> Let's try a few more examples, how would we add the elements of a list using recursion?
13:06:16 <Cale> sum [] = 0
13:06:22 <Cale> sum (x:xs) = x + sum xs
13:06:33 <SamB> Cale is doing this the silly way, btw ;-)
13:06:35 <Cale> and if we wanted to multiply them instead, we might do
13:06:40 <Cale> product [] = 1
13:06:41 <newsham> if only there was a generic way to write list recursion
13:06:50 <Cale> product (x:xs) = x * product xs
13:06:57 <newsham> with a base case and a function that reduces a pair of arguments
13:06:58 <Cale> so what changed here?
13:07:03 <Cale> and what stayed the same?
13:07:08 <SamB> newsham: I mean, the stack-overflowy way
13:07:10 <Cale> The 0 changed to a 1
13:07:10 <xerox> ...that via the universal property becomes a fold.
13:07:15 <Cale> and the + to a *
13:07:35 <Cale> so one thing we might do is to write a function which abstracts this idea
13:07:45 <Cale> foldr f z [] = z
13:07:46 <xerox> There is a paper that explains this thing very very well.
13:07:48 <SamB> chessguy: is this sounding relevant?
13:07:51 <newsham> its like you took all of the colons in the list and replaced them with + signs, and took the terminal [] and replaced it with 0
13:07:58 <chessguy> yes, i'm listening closely
13:08:00 <xerox> ?google expressiveness universality fold
13:08:00 <mbot> search module failed: IRCRaised getHostByName: does not exist (no such host entry)
13:08:07 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
13:08:09 <SamB> Cale: reconfigure!
13:08:25 <Cale> SamB: I'm not sure what's going on there
13:08:33 <SamB> you have to take out the Just something-or-other for the proxy and replace it with a Nothing
13:08:38 <Cale> SamB: ah
13:09:02 <chessguy> ok, you lost me with the foldr stuff
13:09:03 <SamB> I don't know why dons has to subject us to using his proxy as the default...
13:09:07 <Cale> chessguy: Okay
13:09:34 <Cale> chessguy: But basically, it lets us write  sum xs = foldr (+) 0 xs
13:09:41 <Cale> and product xs = foldr (*) 1 xs
13:09:48 <newsham> chess: both his "product" and "sum" functions looked the same, so why not abstract out the "sameness" in some way.
13:09:56 <newsham> chess: which is what he's trying to do with his "foldr" function
13:10:19 <Cale> Let's go over it again more slowly
13:10:27 <Cale> foldr f z [] = z
13:10:44 <newsham> fold (+) 0 [] = 0
13:10:46 <chessguy> sol foldr just applies a mathematical function with a parameter to everything in a list?
13:10:46 <chessguy> *so
13:10:53 <newsham> fold (+) 12345 [] = 12345
13:11:30 <xerox> foldr f k [1,2,3]  =  foldr f k 1:2:3:[]  =  1 `f` 2 `f` 3 `f` k
13:11:34 <xerox> That's it.
13:11:35 <newsham> foldr: yes, but more than that.  doesnt have to be "a mathematical function"
13:12:05 <newsham> but perhaps thats getting ahead of ourselves
13:12:10 * ski wishes ppl would not "write in each others sentences", so much
13:12:22 * chessguy agrees wholeheartedly with ski
13:13:10 <greenrd> When writing papers about Haskell, is it correct to use the terms "Haskell values" and "Haskell terms" interchangeably?
13:13:23 <SamB> terms?
13:13:29 <SamB> aren't those pieces of AST?
13:13:54 <xerox> Maybe check what the report says?
13:13:57 <greenrd> ah yes, I think you're right
13:14:00 <greenrd> xerox: good idea
13:14:34 <SamB> a term is probably more like an expresion than it is like a value
13:15:08 * chessguy wonders where Cale went
13:15:18 <Cale> chessguy: phone
13:15:22 <chessguy> ah
13:19:39 <newsham> chess: both product and sum used recursion to walk a list and perform an operation on an accumulated value with the next value from the list.
13:19:54 <newsham> they had a base case to handle when the list was empty
13:20:01 <newsham> and a recursive case to handle when the list was not.
13:20:20 <xerox> http://www.cs.nott.ac.uk/~gmh/fold.pdf#search=%22universality%20fold%22
13:20:24 <xerox> Ack...
13:20:26 <newsham> foldr abstracts that out.  You tell foldr a function and a base value.   and it "reduces" the list at each step
13:20:29 <xerox> http://www.cs.nott.ac.uk/~gmh/fold.pdf
13:20:46 <chessguy> fold (+) 12345 [] = 12345 ....this doesn't make sense though. how do you add a value to an empty list?
13:20:47 <newsham> using the previous reduced value (or the base case, if none yet) and the next value from the list
13:21:03 <chessguy> aren't you assuming an entry with a value of 0?
13:21:04 <xerox> (That tutorial explains it very well.)
13:21:09 <newsham> chess:  in "foldr (+) 12345 []"    12345 is the base case.
13:21:18 <newsham> because of the rule:    foldr f b [] = b
13:21:30 <newsham> it will evaluate to whatever the base case is, no matter what th efunction may be
13:22:03 <chessguy> to me, foldr f b [] = [] would make more sense
13:22:18 <xerox> Check the type.
13:22:25 <newsham> lets look at a small example:   foldr (+) 0 [2,4,6]
13:22:45 <chessguy> [2,4,6]
13:22:59 <newsham> sicne foldr f b (x:xs) = f x (foldr f b xs)
13:23:18 <newsham> we get:  fodlr (+) 0 [2,4,6] = 2 + (foldr (+) 0 [4,6])
13:23:58 --- topic: '["Haskell Communities & Activities Report, 10th edition", "http://haskell.org/communities/", "Haskell.org SoC projects", "http://hackage.haskell.org/trac/summer-of-code/", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion", "The ICFP has ended. Who won?"]'
13:23:58 --- topic: set by dons on [Thu Aug 10 22:11:10 2006]
13:23:58 --- names: list (clog Nioate swiert saurik shrimpx jmob Maddas Lemmih cods xinming crem Patterner eno-away ozone Tela liyang osfameron norpan ski kolmodin audreyt gdsx wolverian pmurias lokadin wli _frederik_ ksandstr_ aleator_ magagr_ dcoutts mathrick johnnowak arjanb Jaak NuKeS chessguy mauke jer cmeme mbot shawn Narrenschiff greenrd kpk johs Pete_I bobwhoops SamB sethk Poeir lucca cpatrick dany2k basti_ mux WillKW Prip Itkovian esap daniel_larsson Dino_)
13:23:58 --- names: list (Plareplane dbremner df_ LordBrain nattfodd benja_ Evelf Trixsey bdash george_ lorne kalven emertens Krunch Wallbraker Igloo psnl noradio flux__ Lunar^ kpreid jak_ Spark SimonRC Korollary mattam sieni dylan ohub rjih lispy petekaz scw wilx moonlite1 dvekravy woggle d-bug jgrimes integral giksos ValarQ mlh_ resiak ChilliX Daveman Revision17 Twigathy__ newsham saccade_ musasabi piggybox alec nothingmuch genneth mboes scsibug_ svens profmakx)
13:23:58 --- names: list (triple_ TwigEther eivuokko ibid BCoppens takuan vegai int-e araujo abcde` mnislaih gds cptchaos mornfall Philippa notsmack dcoutts_ tessier lhz juhp xerox Pupeno pingu cschneid tessier__ kzm ricebowl slipstream jwp Averell sellout bolrod nnunley gaal eyck AtnNn arguile astrolabe sm neologism pyronicide madpickle arcatan ulfdoz)
13:24:03 <chessguy> oh, i misunderstood. you're summing everything in the list, not adding a quantity to each element in the list, as we were doing previously
13:24:36 <newsham> chess: should I keep going, or are you saying "i get it" now?
13:25:07 <chessguy> well, you changed what we were doing, so now i have to scroll back up through the netsplit spam and find it again
13:25:23 <newsham> I did?
13:26:04 <chessguy> yes, because before we were adding a quantity to each element in the list, not summing the list
13:26:38 <chessguy> at least, that's what i thought we were doing. it was hard to tell with everyone interrupting Cale
13:26:41 <newsham> the original code for "sum" was adding up th elist
13:26:46 <newsham> sum [] = 0
13:26:52 <newsham> sum (x:xs) = x + sum xs
13:26:55 <RingerE> http://www.wsmfm.com/dogs/entries  vote for molly, the cockerspaniel... if she gets enuogh votes i win crap ;o)
13:27:18 <chessguy> ok, i understand that code
13:27:23 <newsham> sum [2,4,6] = 2 + (4 + (6 + 0))
13:27:46 <newsham> what I was trying to show is that   foldr (+) 0 [2,4,6] = 2 + (4 + (6 + 0))
13:27:54 <newsham> and sum = foldr (+) 0
13:28:06 <chessguy> ok, i can understand that
13:28:24 <newsham> now, we can easily do product.   product = (*) 1
13:28:44 <newsham> because product [2,4,6] = 2 * (4 * (6 * 1))
13:28:48 <chessguy> yes
13:29:14 <newsham> the beautiful thing is, foldr can be used for lots of list recursions that try to reduce a list down with pairwise operations
13:30:43 <chessguy> assuming the operation has some kind of identity value
13:30:50 <newsham> > foldr (\a b -> a ++ ", " ++ b) "" ["hey", "you", "guys"]
13:30:51 <mbot>  "hey, you, guys, "
13:31:07 <newsham> chess: thikn of it as "the base case", not an identity value.
13:31:50 <chessguy> ok
13:32:24 <newsham> there's also a variant of foldr wihch takes no base case.  its called foldr1.  It requires that you have at least 1 element in the list
13:32:34 <chessguy> makes sense
13:32:35 <newsham> > foldr1 (+) [2,4]
13:32:36 <mbot>  6
13:32:45 <newsham> > foldr1 (+) []
13:32:46 <mbot>  Exception: Prelude.foldr1: empty list
13:33:10 <newsham> and there's also another fold that does "left reduction" instead of right reduction called "foldl" (and "foldl1")
13:33:24 <newsham> whereas foldr1 [2,4,6] is  2 + (4 + 6)
13:33:33 <newsham> foldl1 [2,4,6] wold be (2 + 4) + 6
13:34:35 <chessguy> so, say we want to do something like read an input, do some calculation on it, and output it. to me, that seems to be very imperative in nature. 3 steps, in order. how does that translate to the FP way of thinking?
13:34:41 <newsham> i came in towards the middle, but I imagine what Cale was probably getting at is that these functions are used to abstract out common idioms and make them reusable for many tasks
13:35:27 <newsham> chess: well, for one, that whole process "read input, do something, output" is asking to be abstracted over the "something"
13:35:50 <newsham> is Cale back yet?
13:35:50 <chessguy> yes, the beginning of the discussion is that i'm trying to get some idea of the difference in approaching a problem between declarative and functional programming
13:36:07 <LordBrain> imperative
13:36:14 <LordBrain> declaritive is functional.. usually
13:36:24 <chessguy> err, yes, i meant imperative
13:36:49 <newsham> chess: thats not inherently not-functional, though.
13:37:08 <newsham> when thought as functions, you want:   output(something(input))
13:38:08 <SamB> @type interact
13:38:10 <mbot> (String -> String) -> IO ()
13:38:10 <newsham> i dont know if i'm the best person to take this part of the question though..
13:38:20 <SamB> @type interact (map succ)
13:38:21 <mbot> IO ()
13:38:39 <chessguy> hm, that much makes sense
13:39:14 <chessguy> requires some pondering anyway
13:39:24 <chessguy> thanks for the help. i should probably get going now
13:39:27 <LordBrain> in imperative programming you will see x = x + 1, where as in functional/declaritive programming, that should strike you funny.
13:39:39 <xerox> ?type let calc xs = let [x,f,y] = words xs in show $ case f of "+" -> read x + read y in interact calc
13:39:40 <mbot> IO ()
13:39:45 <xerox> Simple calculator ^_^
13:39:57 <chessguy> eh?
13:39:58 <ski> (logic programming is declarative, too)
13:40:28 <newsham> thomas jefferson was declarative
13:40:33 <chessguy> xerox, show me how that's a calculator?
13:40:37 <ski> > let calc xs = let [x,f,y] = words xs in show $ case f of "+" -> read x + read y in calc "2 + 3"
13:40:39 <mbot>  "5"
13:40:45 <xerox> :)
13:41:02 <xerox> You have to extend it and make it more robust, is just a proof of concept.
13:41:11 <chessguy> > let calc xs = let [x,f,y] = words xs in show $ case f of "+" -> read x + read y in calc "2 * 3"
13:41:12 <mbot>  Non-exhaustive patterns in case
13:41:18 <xerox> ....as I said.
13:41:37 <xerox> With parsec is dead easy, anyway.
13:41:50 <chessguy> mmm, ok, whatever
13:41:58 <chessguy> i'm outta here
13:42:26 <newsham> i think you're scaring him with larger test cases.. sounds like he just wants a simple "what is functional programming" answer
13:42:31 <xerox> (Anyone else finds the cute calculator ... cute?)
13:43:47 <abcde`> cute!
13:44:24 <xerox> Someday I'll implement it properly and post it to the wiki.
13:44:25 <ski> acute ?
13:44:45 <newsham> why infix?  rpn is more fun.
13:44:46 <SamB> > let x = x + 1 in x
13:44:47 <mbot>  Terminated
13:45:13 <LordBrain> > let x = x in x
13:45:13 <mbot>  Add a type signature
13:45:17 <xerox> newsham: infix is usable ^_^
13:45:18 <LordBrain> > let x = x in x :: Int
13:45:19 <mbot>  Terminated
13:45:22 <LordBrain> lol
13:46:06 <LordBrain> > let x = x in x :: [Int]
13:46:07 <mbot>  Terminated
13:46:40 <LordBrain> mbot: why'd you change your name?
13:47:00 <dcoutts> dons's machine is down
13:47:16 <LordBrain> so this is a back up lambdabot?
13:48:45 <SamB> actually dons is struggling with quotas on the lambdabot host...
13:48:47 <newsham> ? seend lambdabot
13:48:51 <newsham> ? seen lambdabot
13:48:58 <newsham> @ seen lambdabot
13:49:04 <newsham> how does this thing work again? :)
13:49:08 <SamB> apparantly a visitor used up the quota
13:49:10 <xerox> Hrrrrmmmpfff
13:49:11 <SamB> @seen lambdabot
13:49:11 <mbot> I haven't seen lambdabot.
13:49:16 <SamB> @seen mbot
13:49:16 <mbot> Yes, I'm here. I'm in #haskell, ##engineering and #Math
13:49:32 <xerox> My eyes are hurting too much. I have used a too small font today :( I'll finish tomorrow.
13:49:53 <SamB> so, #math is an official channel sanctioned by the owners of Math?
13:50:06 <SamB> but ##engineering is not sanctioned by the owners of engineering?
13:50:12 <madpickle> IEEE vs. crackpots
13:50:18 * madpickle ducks
13:50:32 <SamB> IEEE is for electrical engineers, isn't it?
13:50:39 <madpickle> well sure
13:50:45 <madpickle> not sure what the global body is
13:50:45 <LordBrain> does freenode have an officially sactioned channel policy?
13:50:45 <johnnowak> SamB: The mathematicians long ago decided they needed a formalized, official channel. The engineers decided that just joining ##engineering would be good enough for all practical purposes.
13:50:57 <newsham> the real engineers are too busy building things
13:51:02 <madpickle> newsham: heheh
13:51:04 <newsham> mathemeticians, on th eother hand, are all unemployed
13:51:16 <SamB> johnnowak: I'm just trying to figure out how they talked freenode into keeping #math
13:51:22 <johnnowak> newsham: Not true -- Some are professors.
13:51:50 <johnnowak> SamB: I like it. :)
13:51:59 <int-e> well, why is #haskell still #haskell? :)
13:52:20 * int-e personally finds the ## channels silly.
13:52:28 <newsham> the whole freenode is silly
13:52:29 <int-e> (err, not the channels, the convention)
13:52:31 <madpickle> this network takes itself a bit too silly
13:52:34 * johnnowak agrees with int-e 
13:52:36 <SamB> well, because haskell.org sounds kind of official
13:52:39 <LordBrain> i don't know the signfiicance of two hash marks...
13:52:40 <madpickle> "please don't stay opped, you might hurt yourself"
13:52:41 <newsham> put up server, tell people its for projects, beg for money, condescend, etc..
13:52:41 <SamB> maybe ;-)
13:52:50 <Guest65435> int-e: well, www.haskell.org points here doesn't it?
13:52:53 <madpickle> silly=serious
13:52:58 <SamB> LordBrain: ## is for "about" channels, # is for official channels
13:53:24 <xerox> SamB: Cale made an official site :)
13:53:24 <newsham> there are useful channels on freenode despite, not because, of freenode
13:53:26 <LordBrain> interesting
13:53:34 <SamB> xerox: hmm?
13:53:57 <SamB> freenode is a nice place to hang out and make fun of lilo
13:54:34 <xerox> SamB: it was on his previous wiki, I can't find it on his new mediawiki.
13:54:49 <SamB> in what way was it official?
13:55:17 <xerox> It was more of a workaround for that lilo bug :P
13:55:39 <SamB> was it just a page on Haskell.org that pointed here?
13:56:14 <SamB> so nobody bothered to mention that the Haskell 98 commity had bad been disolved, I hope?
13:56:34 <SamB> I don't know how to spell
13:56:39 <SamB> @spell commity
13:56:40 <mbot> comity commit commute commits committee
13:56:45 <Pete_I> comedy?
13:56:46 <madpickle> community :P
13:56:46 <SamB> committee is the word
13:56:50 <madpickle> oh
13:56:53 <LordBrain> wow spell check i didnt know it had that
13:57:07 <Pete_I> @spell slpel
13:57:07 <mbot> lapel slope spell spiel scalpel
13:57:12 <Pete_I> hmm
13:57:12 <sjanssen> @spell disolved
13:57:13 <mbot> dissolved dissolves dissolve solved devolved
13:57:14 <Pete_I> interesting.
13:57:18 <madpickle> @spell weiner schnitzel
13:57:19 <mbot> wiener Werner whiner weenier winger
13:57:22 <madpickle> heheh
13:57:38 <Pete_I> @spell pcocsogilahyl
13:57:56 <Pete_I> a permutation of "psychological"
13:58:15 <newsham> weiner-hopf
13:58:25 <Pete_I> @spell a
13:58:25 <mbot> a
13:58:34 <Pete_I> @spell i
13:58:34 <mbot> i
13:58:37 <madpickle> @spell thou
13:58:37 <mbot> thou
13:58:40 <abcde`> @spell antidisestablishmentarienism
13:58:42 <Pete_I> @spell thrice
13:58:42 <mbot> thrice
13:58:47 <madpickle> @spell haskell
13:58:47 <mbot> Haskell Haskel Haskell's Skell Haskel's
13:58:49 <abcde`> hey! not fair
13:58:51 <Pete_I> @spell rince
13:58:51 <mbot> Rance rinse Ranice Rice rice
13:59:12 <newsham> @speel thees
13:59:12 <mbot> thees
13:59:24 <Pete_I> woah
13:59:31 <xerox> @speel lol
13:59:31 <mbot> Lil Lola loll LL ll
13:59:36 <xerox> Crazy.
13:59:39 <Pete_I> @sepll spell
13:59:39 <mbot> Maybe you meant: spell tell
13:59:51 <Pete_I> @spell windows
13:59:51 <mbot> windows
13:59:54 <Pete_I> @spell win32
13:59:54 <mbot> win32
14:00:02 <Pete_I> @spell wind0wz
14:00:03 <mbot> wind0wz
14:00:07 <Pete_I> hmm, crappy.
14:00:15 <Pete_I> i'm sure that's not proper spelling :/
14:00:23 <abcde`> We use the term regularly
14:00:29 <Pete_I> we do?
14:00:49 <abcde`> no, I am being silly for your amusement
14:00:59 <Pete_I> @spell lunix
14:00:59 <mbot> Linux lynx UNIX Unix lungs
14:01:22 <Pete_I> it'd be cool if the google lunar base wrote a unix-based OS and called it lunix.
14:02:56 <dylan> there's already a lunix
14:03:03 <dylan> for the C64 I think
14:04:59 <newsham> yup.  6502 assembly.  pretty nifty considering the platform (no PIC code or base registers) and the limitations
14:05:46 <newsham> tcp/ip stack and everything
14:06:34 <newsham> http://www.thenewsh.com/%7Enewsham/x/art/c64-lunix.jpg
14:07:18 <newsham> i put the box up on the net for kicks for a while
14:08:22 <Pete_I> .....
14:08:51 <Pete_I> interesting.
14:08:59 <LordBrain> ah i remember those green screens
14:10:05 <newsham> its actually running in an emulator (vice), i hacked the emulator to send serial port data over a socket to my linux box, so I could hook up SLIP.
14:10:38 <newsham> lots of duct tape and dental floss, but it was fun
14:11:08 * Pete_I imagines a machine designed from duct tape and dental floss and cringes.
14:17:35 <ivant_> @seen lambdabot
14:17:36 <mbot> I haven't seen lambdabot.
14:27:26 <kpreid> is there a name for (foldr mplus mzero . map return)?
14:27:34 <kpreid> @type foldr mplus mzero . map return
14:27:36 <mbot> forall a (m :: * -> *). (MonadPlus m) => [a] -> m a
14:28:20 <norpan> @type foldr mplus mzero
14:28:21 <mbot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
14:28:25 <norpan> that's sequence
14:28:31 <norpan> @type sequence
14:28:32 <mbot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
14:28:35 <norpan> almost
14:28:55 <kpreid> ah, foldr mplus mzero is Control.Monad.msum
14:29:04 <kpreid> norpan: no, sequence is something else
14:29:13 <norpan> yeah
14:29:17 <kpreid> > (sequence . map return) [1,2,3]
14:29:17 <mbot>  add an instance declaration for (Show (m [a]))
14:29:25 <kpreid> > (sequence . map return) [1,2,3] :: [Int]
14:29:27 <mbot>  Couldn't match `Int' against `[a]'
14:29:30 <norpan> i know
14:29:45 <kpreid> OK, so is there a name for (msum . map return)?
14:30:05 <norpan> @type msum
14:30:06 <mbot> forall a (m :: * -> *). (MonadPlus m) => [m a] -> m a
14:30:19 <norpan> yeah
14:31:47 <kpreid> hm
14:31:50 <kpreid> @type msum . map return
14:31:51 <mbot> forall a (m :: * -> *). (MonadPlus m) => [a] -> m a
14:32:25 * kpreid runs into the monomorphism restriction!
14:54:27 <florenz> hi
14:55:01 <florenz> is there trouble linking static libraries (.a files) with ghci 6.4.2? does someone know?
14:55:32 <florenz> ghci always tries to link a .so file, but mp-mpich has none...
15:07:06 <ivant_> @hoogle CString -> Int -> String -> IO ()
15:07:07 <mbot> search module failed: IRCRaised getHostByName: does not exist (no such host entry)
15:35:23 <ihope> @type (\x y -> y (if x then True else Nothing)) :: (forall a. a -> b) -> b
15:35:24 <mbot>   Couldn't match the rigid variable `b' against `t -> t1'
15:35:24 <mbot>    `b' is bound by the polymorphic type `forall b. (forall a. a -> b) -> b'
15:35:53 <ihope> ...What?
15:38:21 <chessguy> >snd(fst(((1,'a'),"foo")))))
15:38:33 <ihope> > snd(fst(((1,'a'),"foo")))))
15:38:33 <mbot>  Parse error
15:38:47 <ihope> > snd(fst(((1,'a'),"foo")))
15:38:48 <mbot>  'a'
15:39:10 <chessguy> too many parentheses
15:39:23 <chessguy> >snd(fst(((1,'a'),"foo")))
15:39:30 <chessguy> > snd(fst(((1,'a'),"foo")))
15:39:31 <mbot>  'a'
15:39:55 <ihope> @type (\x y -> y (if x then True else Nothing)) :: (forall a. a -> b -> c) -> b -> c
15:39:56 <mbot>   Couldn't match the rigid variable `b' against `t -> t1'
15:39:56 <mbot>    `b' is bound by the polymorphic type `forall b c.
15:40:08 <ihope> @type (\x y -> y (if x then True else Nothing)) :: Bool -> (forall a. a -> b) -> b
15:40:09 <mbot>   Couldn't match `Bool' against `Maybe a'
15:40:09 <mbot>    Expected type: Bool
15:40:14 <ihope> Aww.
15:42:51 <int-e> @type (\x y -> (if x then y True else y Nothing)) :: Bool -> (forall a. a -> b) -> b
15:42:54 <mbot> Bool -> (forall a. a -> b) -> b :: forall b. Bool -> (forall a. a -> b) -> b
15:44:34 <chessguy> > map Char.toUpper "Hello World"
15:44:36 <mbot>  "HELLO WORLD"
15:44:47 <chessguy> hm, not a Hugs compiler
15:45:53 <ivant_> chessguy: how do you know?
15:46:34 <dcoutts> @pl \h w -> (h * 33) + w
15:46:34 <mbot> (+) . (33 *)
15:48:43 <chessguy> according to the tutorial i'm reading, Hugs doesn't like to see Char.toUpper
15:49:10 <ivant_> @pl \c -> fromIntegral (ord c)
15:49:10 <mbot> fromIntegral . ord
15:50:45 <chessguy> > map Char.isLower "Hello World"
15:50:46 <mbot>  [False,True,True,True,True,False,False,True,True,True,True]
15:51:30 <heatsink> > (Char.isLower ' ', Char.isUpper ' ')
15:51:31 <mbot>  (False,False)
15:51:43 <chessguy> nice
15:52:13 <dcoutts> @pl \h w -> (h * 33) + ord w
15:52:14 <mbot> (. ord) . (+) . (33 *)
15:52:37 <dcoutts> @pl \h w -> (h * 33) + fromIntegral (ord w)
15:52:38 <mbot> (. (fromIntegral . ord)) . (+) . (33 *)
15:52:56 <int-e> dcoutts: would you actually write that?
15:52:58 <ivant_> > take 3 [1,2]
15:52:59 <mbot>  [1,2]
15:53:06 <dcoutts> int-e, no, not that
15:53:20 <int-e> @pl \w -> (h * 33) + fromIntegral (ord w)
15:53:21 <mbot> (h * 33 +) . fromIntegral . ord
15:53:39 <chessguy> > length filter Char.isUpper "Hello World"
15:53:39 <mbot>  Couldn't match `Int' against `t -> t1 -> t2'
15:53:46 <chessguy> d'oh
15:53:48 <int-e> that I'd use, perhaps. but after the next step I can't follow the code easily anymore
15:54:40 <int-e> $ is your friend :)
15:54:44 <chessguy> > length(filter char.isUpper "Hello World")
15:54:45 <mbot>  Not in scope: `char'
15:54:53 <chessguy> > length(filter Char.isUpper "Hello World")
15:54:56 <mbot>  2
15:56:47 <chessguy> > foldr max [5,10,8,2,1]
15:56:48 <mbot>  add an instance declaration for (Show ([[a]] -> [a]))
15:57:15 <chessguy> > foldr (max) [5,10,8,2,1]
15:57:16 <mbot>  add an instance declaration for (Show ([[a]] -> [a]))
15:57:17 <heatsink> @type max
15:57:18 <mbot> forall a. (Ord a) => a -> a -> a
15:57:29 <heatsink> oh... use foldr1
15:57:46 <chessguy> > foldr (max) 1 [5,10,8,2,1]
15:57:47 <mbot>  10
15:57:57 <heatsink> > foldr1 max [5,10,8,2,1]
15:57:59 <mbot>  10
15:59:28 <sieni> > product [1..1000]
15:59:29 <mbot>  4023872600770937735437024339230039857193748642107146325437999104299385123986...
16:00:14 <LordBrain> lol
16:02:08 <LordBrain> > map (chr>>=(,)) [65..91]
16:02:09 <int-e> > (length . takeWhile ('0'==) . reverse . show $ product [1..1000], 200+40+8+1)
16:02:10 <mbot>  [('A',65),('B',66),('C',67),('D',68),('E',69),('F',70),('G',71),('H',72),('I...
16:02:10 <mbot>  (249,249)
16:03:27 <ihope> chr >>= (,) is quite the function.
16:03:46 <LordBrain> yeah
16:05:15 <LordBrain> > zip "ABCDEFGHI" [1..]
16:05:17 <mbot>  [('A',1),('B',2),('C',3),('D',4),('E',5),('F',6),('G',7),('H',8),('I',9)]
16:10:41 <stepcut> > let sieve (h:t) = h : [ x | x <- t, x `mod` h /= 0] in take 10 $ sieve [2..]
16:10:43 <mbot>  [2,3,5,7,9,11,13,15,17,19]
16:13:24 <Jaak> um, 15
16:13:41 <int-e> all odd numbers
16:13:44 <Jaak> > let sieve (p:xs) = [x | x <- xs, x `mod` p /= 0] in take 10 . map head $ iterate sieve [2..]
16:13:46 <mbot>  [2,3,5,7,11,13,17,19,23,29]
16:13:51 <Jaak> aha!
16:15:56 <int-e> > let sieve (h:t) = h : let (t',t'') = span (<h*h) t in t' ++ sieve [x| x <- t'', x `mod` h /= 0] in take 20 $ sieve [2..]
16:15:58 <mbot>  [2,3,5,7,9,11,13,15,17,19,21,23,27,29,31,33,37,39,41,43]
16:16:09 <int-e> hmm :)
16:16:42 <LordBrain> > let sieve (p:xs) = [x | x <- sieve xs, x `mod` p /= 0] in take 20 $ sieve [2..]
16:16:45 <mbot>  Exception: stack overflow
16:16:49 <Jaak> hehe
16:16:51 <LordBrain> oops
16:16:53 <stepcut> int-e: have you tested that version -- I think it might actually be slower
16:16:54 <LordBrain> :)
16:17:12 <int-e> stepcut: for the time being it's not even correct.
16:17:15 <stepcut> everything I did to try to make sieve faster made it slower, or had no useful impact
16:17:27 <stepcut> int-e: ah yes, I see a 9 in there :)
16:17:38 <LordBrain> > let sieve (p:xs) = p: [x | x <- sieve xs, x `mod` p /= 0] in take 20 $ sieve [2..]
16:17:39 <mbot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
16:18:09 <Jaak> nice
16:23:03 <int-e> > let primes = 2:sieve [3..] [] primes; sieve (n:ns) l (p:ps) | p*p == n = sieve ns (p:l) ps | True = [n| all ((0/=).(mod n)) l] ++ sieve ns l (p:ps) in primes !! 10000
16:23:06 <mbot>  104743
16:23:37 <int-e> > let sieve (p:xs) = p: [x | x <- sieve xs, x `mod` p /= 0] in sieve [2..] !! 10000
16:23:44 <mbot> Terminated
16:24:06 <joelr1> good evening!
16:26:59 <joelr1> it was a dark and stormy night...
16:27:23 <stepcut> > let sqrt' n = truncate $ sqrt (fromIntegral n) ;isPrime n = all (\x -> n `mod` x /= 0) $ takeWhile (<= sqrt' n) primes ;primes = 2 : filter isPrime [3..] in (primes !! 10000)
16:27:25 <mbot>  104743
16:30:27 <stepcut> that is the fastest version I could come up with -- it can calculate all the primes < 1,000,000 in about ~3 seconds. The sieve method takes around 10mins :(
16:30:28 <int-e> stepcut: remember to add a [Int] type signature to the prime list.
16:30:56 <stepcut> int-e: unless I need really big primes :)
16:31:11 <LordBrain> lol
16:31:14 <int-e> stepcut: then you should seek a different approach
16:32:09 <int-e> takeWhile (\p -> p*p <= n) primes3 is a bit faster (if you force the type to [Int])
16:32:17 <stepcut> the 'fast' version that I pasted, takes the 'dumb' approach. It just individually tests each number from [3..n] and checks if it is prime
16:32:55 <LordBrain> hmmm
16:33:46 <stepcut> it is a bit smart in that in only checks division by primes upto sqrt(n)
16:34:29 <stepcut> but even if you just check everything from 2..sqrt(n) it still whomps the sieve version
16:34:36 <int-e> @type truncate
16:34:37 <mbot> forall a b. (RealFrac a, Integral b) => a -> b
16:36:21 <stepcut> @type ^
16:36:22 <mbot> parse error on input `^'
16:36:28 <stepcut> @type (^)
16:36:29 <mbot> forall a b. (Integral b, Num a) => a -> b -> a
16:42:54 <int-e> > let primes :: [Int]; primes = 2:3:sieve [5,7..] (tail primes); sieve (n:ns) (p:ps) | p*p == b = sieve (filter ((0 /=) . (`mod` p)) ns) ps | otherwise = n:sieve (p:ps) in primes !! 10000
16:42:55 <mbot>  Not in scope: `b'
16:43:10 <int-e> > let primes :: [Int]; primes = 2:3:sieve [5,7..] (tail primes); sieve (n:ns) (p:ps) | p*p == n = sieve (filter ((0 /=) . (`mod` p)) ns) ps | otherwise = n:sieve (p:ps) in primes !! 10000
16:43:11 <mbot>  Couldn't match `[a]' against `t -> t1'
16:44:05 <int-e> > let primes :: [Int]; primes = 2:3:sieve [5,7..] (tail primes); sieve (n:ns) (p:ps) | p*p == n = sieve (filter ((0 /=) . (`mod` p)) ns) ps | otherwise = n:sieve ns (p:ps) in primes !! 10000
16:44:07 <mbot>  104743
16:45:07 <int-e> Streamlined, and quite fast compared to the filter isPrime versions.
16:45:26 <int-e> > let primes :: [Int]; primes = 2:3:sieve [5,7..] (tail primes); sieve (n:ns) (p:ps) | p*p == n = sieve (filter ((0 /=) . (`mod` p)) ns) ps | otherwise = n:sieve ns (p:ps) in primes !! 100000
16:45:33 <mbot> Terminated
16:46:00 <int-e> aww. that runs in 1.4 seconds here (using compiled code)
16:46:15 <stepcut> yeah, it is fast here too
16:48:52 <stepcut> about 2x the version I posted
16:51:03 <stepcut> good space usage too
16:51:40 <midfield> Hi, does anyone have a local copy of Data.ByteString 7.0?  The owner's website appears to be down.
16:51:40 <stepcut> most of the optimizations I tried like that would gobble RAM like crazy
16:52:12 <stepcut> midfield: 0.7 -- the site is down for around ~24 hours due to a planned power outage
16:52:41 <midfield> thanks for the info.  i was just wanted to play with it, if anyone has a local copy.
16:54:35 <midfield> by the way are there any utilities for inverted indices for haskell?  right now i'm experimenting with porting lucene.
16:54:59 <int-e> stepcut: hmm, actually it should eat a lot of memory ... the whole prime list gets shared and kept around.
16:55:41 <stepcut> int-e: yeah, but that is only a few megs, I'm talking about GIGS for a million element list
16:56:43 <stepcut> midfield: http://www.foxthompson.net/freespire/pool/main/h/haskell-fps/
16:57:52 <stepcut> midfield: I believe that is a build somewhere between 0.7 and 0.8
16:58:20 <midfield> stepcut: thanks.  suitable for apt-get install on ubuntu?
16:58:45 <stepcut> midfield: possibly -- I think those are built against 6.4.1
16:59:05 <stepcut> midfield: but, you should be able to downlead the source and rebuild the .debs
16:59:11 <midfield> stepcut: thanks
17:01:53 <midfield> Is that a "no" regarding my question on inverted indices / lucene ports?
17:02:38 <stepcut> inverted indices ?
17:03:20 <int-e> stepcut: hmm, memory usage is quite low indeed but I can't explain why. it certainly allocates and garbage collects like crazy.
17:03:31 <midfield> stepcut: a data structure for doing things like fast full text search.  lucene is a very popular java library for this.
17:03:59 <stepcut> int-e: good garbage collection ;)
17:04:08 <stepcut> midfield ? -> http://www.kimbly.com/code/invidx/haskell/InvIdx.lhs
17:04:18 <stepcut> http://www.kimbly.com/code/invidx/
17:04:44 <int-e> stepcut: 14GB allocated, 16 MB maximum residency.
17:04:59 <lispy> midfield: normally i'd be a snob and say, "Ew...java" but in this case.  Cool, you're bringing good stuff over to Haskell! ;)
17:05:07 <midfield> stepcut: not exactly production code.  to be more precise, lucene can create inverted indices for data sets which are giant, like the whole web, etc.
17:05:30 <stepcut> midfield: heh
17:05:50 <midfield> lispy: well, i'm just giving it a try.  reading java is pretty lame i have to say.  this is my exercise for really learning haskell hard core.
17:06:00 <midfield> lucene is a fantastic library.
17:06:33 <lispy> midfield: i find that figuring out the specification for the java code, then implementing the spec gives the best results, albiet it takes as much if not more work
17:07:33 <midfield> lispy: i'm not exactly sure what you mean.  i am trying to make this a haskell-y library, e.g. not a transliteration, if that is relevant.
17:08:40 <lispy> well, when i go to translate imperative code, i find that i need to figure out what API the code lives up to, then implement that with the appropriate algorithms
17:08:46 <lispy> sounds like thats what you mena to do
17:09:55 <midfield> lispy: yeah, i'm trying to code in a type-driven way, ala hughe's pretty printer.  though i doubt my code will ever be that awesome.  that paper is great!
17:10:49 <lispy> midfield: since you know how the code should behave in specific ways, you could encode that as properties and have quickcheck do a lot of your unit testing for free
17:10:54 <lispy> @where quickcheck
17:10:54 <mbot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
17:13:34 <int-e> stepcut: there's some strange stuff going on there. if I try to replace the 'primes' argument by some other prime generator (to avoid sharing) memory residency jumps up by a factor of 9.
17:13:44 <midfield> lispy: thanks for the pointer.
17:13:55 <stepcut> int-e: hah
17:14:04 <newsham> peek ptr
17:14:24 <stepcut> int-e: your code is possessed
17:14:25 * lispy peeks
17:14:27 <int-e> stepcut: on the other hand if I take a precomputed list of the first 2000 primes it goes down to 30kb.
17:15:04 <int-e> stepcut: I'm mystified :)
17:15:04 <lispy> int-e: you probably need to add some strictness
17:15:14 <int-e> but where? these are lazy lists
17:15:18 <lispy> int-e: have you looked at the strictness that ghc is infering about your functions?
17:15:32 <stepcut> lispy: how do you do that ?
17:15:37 <int-e> not yet.
17:15:50 <lispy> there is a command to dump the translation to core, then you inspect that
17:15:57 <stepcut> lispy: ah
17:15:58 <lispy> or maybe it's not exactly core, but it's somewhat processed
17:16:31 <lispy> each function's signature will be in there with some codes that tell you how strict or lazy the evaluation of the arguments are (according to the imperfect inference)
17:16:35 <int-e> stepcut: of course using that precomputed list is cheating.
17:16:56 <lispy> what does this do?
17:17:00 <lispy> factor?
17:17:23 <stepcut> int-e: I would assume the benefit of the precomputed list decreases as your take bigger lists of primes ?
17:17:48 <int-e> stepcut: err, it just will stop working after a while.
17:17:55 <stepcut> int-e: ah :)
17:18:00 <int-e> > 17389^2
17:18:02 <mbot>  302377321
17:18:13 <int-e> for primes larger than that, it won't work.
17:18:19 <lispy> > 2^17389
17:18:20 <mbot>  4079384120050759917668314774291967170929882417810283577305676826532676869585...
17:18:44 <stepcut> lispy: I was trying to figuer out why, 'sieve (h:t) = h : [ x | x <- t, x `mod` h /= 0]' performs so poorly
17:19:20 <stepcut> lispy: a 'stupid' algorithm that did, 'filter isPrime [2..]' would calculate primes less than a million in a few seconds, and sieve would take 10 mins
17:19:39 <stepcut> lispy: but int-e made a tweak that got it down to 2-3 seconds ;)
17:20:24 <madpickle> what tweak was that?
17:20:40 <stepcut> ?paste
17:20:40 <mbot> http://paste.lisp.org/new/haskell
17:21:28 <stepcut> http://paste.lisp.org/display/24372
17:21:31 <madpickle> thanks
17:21:33 <madpickle> i got it from the list
17:27:11 <stepcut> int-e: thanks for the code -- I thought those two optimizations should help, but I was not able to get my implementations to work in practice
17:32:06 <int-e> stepcut: you're welcome.
17:35:29 <kpreid> How should I test for duplicate items in a list?
17:35:50 <kpreid> I don't need to know what the items are, just whether there are duplicates.
17:36:58 <Lemmih> > let hasDups x = nub x /= x in (hasDups [1,2,3], hasDups [1,2,3,1])
17:37:00 <mbot>  (False,True)
17:37:21 <kpreid> hm, ok
17:37:23 <int-e> > hasdups s = any (\(a:as) -> a `elem` as) (init $ tails s) in map hasdups ["abc", "xyzzy"]
17:37:23 <mbot>  Parse error
17:37:35 <dcoutts> > not . null . filter ((>1).length) . List.group . List.sort $ "foghuydo"
17:37:35 <int-e> > let hasdups s = any (\(a:as) -> a `elem` as) (init $ tails s) in map hasdups ["abc", "xyzzy"]
17:37:36 <mbot>  True
17:37:37 <mbot>  [False,True]
17:38:01 <int-e> \s -> length s == length $ nub s
17:38:11 <int-e> (awful)
17:38:31 <int-e> @pl \s -> length s == length $ nub s
17:38:31 <mbot> liftM2 (length ==) length nub
17:38:58 <int-e> @pl \s -> length s == (length $ nub s)
17:38:58 <mbot> liftM2 (==) length (length . nub)
17:39:03 <int-e> woops.
17:40:26 <stepcut> > let hasDup [] = False ; hasDup (h:t) = (h `elem` t) || hasDup t in hasDup "hello"
17:40:27 <mbot>  True
17:42:21 <Lemmih> > let hasDup s [] = False ; hasDup s (h:t) = S.member h s || hasDup (S.insert h s) t in hasDup S.empty "hello"
17:42:22 <mbot>  True
17:44:15 <stepcut> Lemmih: ah yes -- I think that is similar to how nub works
17:45:22 <int-e> stepcut: not really
17:45:25 <int-e> @type nub
17:45:27 <mbot> forall a. (Eq a) => [a] -> [a]
17:45:41 <int-e> stepcut: can't work without an Ord instance for a
17:46:34 <stepcut> int-e: well, similar in the sense that it has an accumulator that stores the already seen values
17:46:51 <int-e> > hasDup l = let l' = sort l in or (zipWith (==) l' (tail l')) in map hasDup ["hello", "quickbrownfox"]
17:46:51 <mbot>  Parse error
17:46:57 <int-e> > let hasDup l = let l' = sort l in or (zipWith (==) l' (tail l')) in map hasDup ["hello", "quickbrownfox"]
17:46:58 <mbot>  [True,True]
17:55:16 <joelr1> eivuokko: ping
17:55:58 <joelr1> eivuokko: can you take a look at my last email re: unpulling patch? thanks!
17:58:30 <eivuokko> joelr1, Ah, just replied.
17:58:45 <joelr1> looking, thanks
17:59:04 <eivuokko> Good to ask on ml, might be others running on this...espcially Mac/Intel users... ;)
17:59:33 <joelr1> right
17:59:38 <joelr1> eivuokko: thanks
18:00:04 <eivuokko> np
18:00:07 <joelr1> eivuokko: i'll have to reapply for stage2, right?
18:00:12 <eivuokko> Yeah
18:00:38 <eivuokko> stage2 is getting built against new base, which has the array interface changed.
18:00:44 <joelr1> eivuokko: how fast is your dev machine?
18:00:59 <joelr1> eivuokko: how long does it take you to rebuild ghc?
18:01:06 <eivuokko> Um
18:01:20 <dcoutts> 1 hour, 39 minutes
18:01:38 <dcoutts> for a full optimising build with all libs
18:01:46 <eivuokko> I honestly dont know.  I have few machines and I am Windows-based, so build is broken often.
18:01:50 <joelr1> dcoutts: that's kind of fast
18:01:56 <dcoutts> @yarr!
18:01:56 <mbot> Smartly me lass
18:02:02 <joelr1> dcoutts: how do i match that?
18:02:16 <Korollary> It took about 1 hour on my 3Ghz p4
18:02:36 <joelr1> dcoutts: it's overnight on my powerbook G4 1.25Ghz and ~3hours (I think) on mac intel
18:02:52 <eivuokko> Try make -j2
18:02:58 <dcoutts> well obviously having fast cpu and disk helps
18:03:02 <joelr1> dcoutts: i use the standard config, though, autoreconf && configure && make
18:03:03 <dcoutts> maje -j2 helps too
18:03:16 <dcoutts> and not building so many libs helps
18:03:24 <joelr1> j2 runs 2 makes?
18:03:33 <dcoutts> yep
18:03:39 <joelr1> dcoutts: i'm on core duo. 2ghz
18:03:49 <joelr1> 2gb of memory and a 7200rpm disk
18:03:49 <dcoutts> 2 cpu?
18:03:51 <eivuokko> It should help, might even want to consider make -j3
18:03:54 <dcoutts> then that'll help
18:03:58 <joelr1> dcoutts: well, two cores
18:04:10 <joelr1> eivuokko: why j3?
18:04:12 <dcoutts> joelr1, I'm using mostly the standard source build, via gentoo's ghc-darcs ebuild
18:04:15 <eivuokko> And make GhcBootLibs=Yes build minimal set of libs
18:04:24 <eivuokko> Make that YES
18:04:26 <dcoutts> joelr1, standard practice is $NCPUs+1
18:04:39 <joelr1> eivuokko: that's crucial. libs. where is that parameter?
18:04:58 <eivuokko> libraries/Makefile has the source
18:05:15 <dcoutts> or add it to your mk/build.conf
18:05:25 <dcoutts> that's the "right place" to put it
18:05:34 <joelr1> dcoutts: do i need to reconfigure after doing this?
18:05:36 * eivuokko is too lazy to create a new file
18:05:40 <dcoutts> no
18:05:53 <joelr1> dcoutts: you mean mk/build.mk?
18:05:56 <eivuokko> If you don't need OpenGl, it really helps not to build it :-)
18:06:01 <dcoutts> joelr1, er, yes.
18:06:14 <dcoutts> an OpenAL and X11 and ... etc etc
18:06:27 <joelr1> so bootlibs=yes does not build those, right?
18:06:34 <dcoutts> aye
18:06:43 <eivuokko> Is it case sensitive?
18:06:51 <dcoutts> yes
18:07:04 <eivuokko> My Makefile-fu isn't too good, but I write GhcBootLibs=YES
18:07:13 <dcoutts> which is correct
18:08:00 <joelr1> eivuokko: hsSyn/Convert.lhs:625:32: Not in scope: `TH.pkgString'
18:08:00 <joelr1> <<ghc: 49770416 bytes, 8 GCs, 2578002/5045464 avg/max bytes residency (2 samples), 18M in use, 0.00 INIT (0.01 elapsed), 0.10 MUT (0.35 elapsed), 0.08 GC (0.17 elapsed) :ghc>>
18:08:00 <joelr1> make[1]: *** [stage1/hsSyn/Convert.o] Error 1
18:08:10 <joelr1> another patch to unpull?
18:08:28 <eivuokko> No idea
18:08:40 <dcoutts> me neither
18:08:46 <eivuokko> Looks like HEAD isn't correct right now
18:09:21 <joelr1> how do i make darcs tell me the patch this is?
18:09:34 <joelr1> there's an easy way i think but i don't remember it offhand
18:09:40 <eivuokko> darcs annotate is good tool...if you got something to interpret the output
18:09:47 <joelr1> nope
18:09:49 <eivuokko> darcs changes also can show changes on a file
18:09:51 <joelr1> just the terminal
18:09:57 <joelr1> aha, changes
18:10:25 <eivuokko> Annotate is just *so good* when it's graphical.
18:10:36 <eivuokko> Well, might be tad slow on ghc sources ;)
18:13:23 <joelr1> check this out
18:13:30 <joelr1> darcs annotate Convert.lhs
18:13:30 <joelr1> darcs failed:  There is no file or directory named 'compiler/hsSyn/Convert.lhs'
18:13:39 <joelr1> i'm in that directory
18:13:53 <eivuokko> Uhhuh
18:14:06 <joelr1> and more Convert.lhs works
18:14:27 <eivuokko> Maybe it is generated, then.  Would make sense why it has deps wrong (someone managed to commit it, probably from succesfull build)
18:14:35 <joelr1> darcs changes works on this file
18:14:38 <joelr1> annotate doesn't
18:14:41 <eivuokko> Ah, ok.
18:15:28 <joelr1> Lemmih: ping
18:18:57 <int-e> stepcut: I've tricked ghc into doing what I want, by using a separate module.
18:18:58 <Lemmih> joelr1: pong.
18:19:09 <joelr1> Lemmih: are you on ghc-users?
18:19:40 <Lemmih> joelr1: Yes.
18:19:52 <joelr1> Lemmih: i'm getting an error in compiler/hsSyn/Convert.lhs and I see that you have some patches in. or did you just tag it?
18:20:06 <joelr1> my last two messages on digraph
18:20:45 <eivuokko> Did you update the libraries from darcs as well?
18:21:01 <joelr1> eivuokko: i pulled everything, from scratch
18:21:05 <joelr1> brand-new directory
18:21:47 <eivuokko> Right, just the error makes no sense on the first quick glance.
18:23:09 <Lemmih> joelr1: I'm getting the same error as you (TH.pkgString thingy). I believe it's a mistake by SimonM.
18:23:25 <joelr1> ah!
18:24:23 <joelr1> i guess i'll need to wait until simon comes back t hen
18:24:43 <joelr1> btw, why do you think ms research is hiring people and interns to work on ghc?
18:25:01 * Lemmih should've prodded Simon when he had to chance to do it IRL.
18:25:13 <eivuokko> Because it is popular, maybe.  Or maybe Simon's research is so useful.
18:25:18 <joelr1> a new push by simon & simon? they having less time to work on it?
18:25:27 <joelr1> i would bet on simon & simon having less time
18:25:42 <joelr1> but i wonder why. maybe ms pressuring researchers to be more practical?
18:26:35 <eivuokko> Well, from things Ms research does in general, I don't think they need to be anywhere near productino usable.
18:27:05 <joelr1> eivuokko: yes, but i hear about ms pushing researchers to do practical t hings now
18:27:13 <joelr1> at least i got this notion from some press
18:27:40 <joelr1> less time is my version anyway. my question is why.
18:27:49 <joelr1> of course overall it's good, regardless
18:27:59 <joelr1> ocaml has a whole team working on it, for example
18:28:18 <joelr1> whereas ghc officially has simon and simon. more people equals better effort.
18:30:48 <Cale> Wow, a car just totally nailed the electrical pole across the street from my house. I'm amazed we still have power.
18:31:02 <dons> Cale, is the driver ok?
18:31:09 <Cale> The drivers ran off
18:31:16 <Cale> They were probably drunk or something
18:31:16 <dons> ah that kind of driver
18:31:25 <dons> ?localtime Cale
18:31:26 <mbot> Local time for Cale is Fri Aug 18 21:31:03
18:31:35 <Cale> The pole itself snapped in two and the top part is hanging by the tension of the lines.
18:31:44 <dons> huh
18:31:54 <dons> you should blog it! ;)
18:31:57 <stepcut> haha
18:32:16 <spiffy> haha sounds like those quotes on bash.org "my house is now on fire....
18:32:18 <spiffy> "
18:33:55 <int-e> stepcut: http://paste.lisp.org/display/24374
18:34:40 <int-e> (How to use modules to prevent CSE and avoid sharing.)
18:34:44 <joelr1> does anyone know ML/OCaml?
18:35:16 <joelr1> i wonder how it took you to get used to programming with just let ... in ..., without where
18:36:08 <dons> hehe
18:36:19 <stepcut> int-e: cool
18:37:03 * stepcut knows ocaml
18:37:36 <stepcut> learned ocaml and haskell around the same time -- but I only use haskell now ;)
18:37:43 <joelr1> int-e: what's CSE again?
18:37:47 <int-e> stepcut: I think I'm seeing the problem. the [5,7..] gets shared otherwise
18:37:55 <int-e> joelr1: common subexpression elimination
18:38:01 <joelr1> stepcut: so what about the syntax?
18:38:03 <stepcut> int-e: ah
18:38:07 <stepcut> joelr1: hate it
18:38:53 <joelr1> i bought like 3 books on ml/ocaml and i'm finding the syntax too dense. can't grasp the let ins
18:38:55 <int-e> stepcut: hmm, strangely enough, if I put it into one module now, it works. I wonder what I did differently before.
18:39:02 <stepcut> int-e: haha
18:39:11 <stepcut> int-e: I told you, it is possessed
18:39:18 <int-e> stepcut: it's annoying.
18:39:44 <joelr1> stepcut: the module/functor stuff is annoyiing too. makes you want to improve ghc :D
18:40:01 <joelr1> stepcut: instead of using ocaml
18:40:27 <stepcut> joelr1: yep
18:40:31 <joelr1> maybe haskell is a spoiler because i already (sort of) know haskell
18:40:37 <dons> bring on associated types!
18:41:42 <joelr1> but hell, the compiler is fast! and builds in, like, 10 minutes!
18:41:47 <stepcut> joelr1: I eventually decided that O'Caml is really just a better version of C
18:42:28 <joelr1> stepcut: see nothing wrong with that
18:44:08 <newsham> why ml/ocaml?  no erlang?
18:44:56 <stepcut> because erlang does not have static type checking?
18:44:58 <joelr1> newsham: yes erlang! i ported the hipe compiler to mac intel this week
18:45:27 <joelr1> newsham: which emboldened me to rebuild ghc 6.5 again :D
18:45:34 <stepcut> joelr1: if what you need is a better C, then OCaml can be great
18:45:45 <joelr1> newsham: erlang is what i'm moving forward with commercially
18:45:59 <newsham> what's you commerce?
18:46:03 <Adamant> can Erlang be compiled to native code?
18:46:16 <joelr1> Adamant: google for erlang hipe
18:46:30 <joelr1> newsham: a mac ide for erlang
18:46:38 <newsham> you write compiler tools?
18:47:23 <joelr1> nope, i'm just some dude who wanted erlang to compile to native code on his intel mac
18:47:41 <newsham> what did you mean "commrecially"?
18:47:46 <newsham> i thought you meant "for work"
18:48:08 <joelr1> right, for work. what's what i plan to sell and use to build products
18:48:14 <Cale> Well, that was fun, hope the drivers are okay. Not every day that you get to see one of those power transformers explode.
18:48:35 <dons> wow
18:48:37 <newsham> what's your commerce?
18:48:38 <stepcut> Cale: did you get a video for youtube ?
18:48:40 <Adamant> that is some scary crud, isn't it?
18:48:44 <Cale> stepcut: nope, no camera
18:48:57 <joelr1> newsham: http://wagerlabs.com
18:49:07 <Adamant> what's really fun is when they go out in a hurricane
18:49:12 <joelr1> @localtime joelr1
18:49:14 <mbot> Local time for joelr1 is 2006-08-19 02:48:50 +0100
18:49:22 <joelr1> good night everyone!
18:49:26 <Adamant> @localtime Adamant
18:49:27 <mbot> Local time for Adamant is Fri Aug 18 22:37:08
18:49:30 <newsham> ahh, are you the guy who wrote the article about erlang v. haskell for data marshalling (poker server, if I recall)?
18:49:38 <joelr1> newsham: yes
18:49:55 <newsham> i read the article, but still using haskell (and python :)
18:50:05 <joelr1> haskell is dear to my heart
18:50:26 <midfield> ok a newbie monad question!
18:50:29 <newsham> how'd the poker server turn out?  was that for kicks, or work?
18:50:57 <joelr1> newsham: wanted to sell it, did not turn out well.
18:50:59 <joelr1> good night
18:51:09 <dons> heh
18:51:16 <midfield> i want a function which splits a string into words, but collects offsets.
18:51:39 <dons> you'll need to write your own version of 'words' with an accumulator, I think
18:52:06 <midfield> doesn't this sound like a job for monad, accumulating counts?
18:52:31 <dons> seems kind of overkill for a monad
18:52:32 <stepcut> midfield: probably overkill
18:52:34 <newsham> why?  zip and a small (recursive) loop is easy enough
18:52:44 <midfield> i wrote a version of "takeWith" that counts.
18:52:50 <dons> yep, zip would do it
18:52:55 <int-e> stepcut: I probably forget a -no-recomp or a related flag there. putting it all back into a single module doesn't work after all.
18:53:02 <stepcut> int-e: ah
18:53:04 <newsham> or you could map lengths over the result sand accumulate
18:53:05 <stepcut> int-e: that makes sense
18:53:17 <midfield> you mean zip over words plus map length words?  that doesn't work because it looses the whitespace which is important for the offsets.
18:53:33 <dons> just write words, but have an extra :: Int -> argument, starting at 0
18:53:35 <stepcut> midfield: monads tend to be more useful if you have bunch of small functions that you want to compose in different ways, and you want them to all share some common piece of state.
18:54:17 <midfield> stepcut: in a sense that is what i'm trying to do.  this is the most trivial example of a tokenizer, but all the tokenizers need to keep track of offsets.
18:54:59 <stepcut> midfield: so each tokenizer will take in the current offset, and then do some stuff and return the new offset ?
18:55:34 <int-e> stepcut: and finally, http://paste.lisp.org/display/24374#1
18:55:45 <int-e> stepcut: that confirms the theory that the [5,7..] gets shared.
18:55:58 <stepcut> int-e: interesting
18:56:09 <stepcut> why is the sharing bad ?
18:56:14 <stepcut> causes a space leak ?
18:56:19 <midfield> stepcut: i guess i envisioned the type of the tokenizers to be String -> [(String, Int, Int)]
18:57:04 <newsham> midfield: tokenize zip input [1..]
18:57:32 <newsham> or 0.. :)
18:57:48 <int-e> stepcut: yes, it causes the program to hold on to the list of odd numbers from sqrt(p) to p, where p is the current prime in the result list (primes).
18:58:34 <int-e> stepcut: instead of just the primes up to sqrt(p) in filter thunks (which it has to keep track of anyway)
18:59:07 <stepcut> int-e: ah
18:59:39 <int-e> stepcut: and for p ~ 15 million that's quite a big difference :)
18:59:53 <stepcut> int-e: indeed
18:59:54 <midfield> newsham: thanks, i'll work with that idea for a while
19:00:20 <newsham> > zip "hi there bob" [0..]
19:00:20 <mbot>  [('h',0),('i',1),(' ',2),('t',3),('h',4),('e',5),('r',6),('e',7),(' ',8),('b...
19:00:34 <stepcut> midfield: yeah, it does not look like you need to pass the state from one function to another -- so monads are probably not going to help you a lot
19:01:10 <newsham> > takeWhile (fst /= ' ') $ zip "hi there bob" [0..]
19:01:10 <mbot>  Couldn't match `(a, b) -> a' against `Char'
19:01:38 <dons> takeWhile (\(c,_) -> c /= ' ')
19:01:42 <dons> ?pl takeWhile (\(c,_) -> c /= ' ')
19:01:43 <mbot> takeWhile ((' ' /=) . fst)
19:01:58 <stepcut> > takeWhile (/= ' ' . fst) $ zip "hi there bob" [0..]
19:01:58 <mbot>  Couldn't match `b -> c' against `Char'
19:02:10 <stepcut> > takeWhile ((/= ' ') . fst) $ zip "hi there bob" [0..]
19:02:11 <mbot>  [('h',0),('i',1)]
19:02:54 <stepcut> dons:  did you get a chance to peek at that parser at all ?
19:04:52 <dons> not yet, email down for another 3 hours
19:05:07 <stepcut> I remember why I could not adapt Parsec to the job
19:05:47 <dons> stepcut: oh yes?
19:05:54 <stepcut> Pasec expects a list of input tokens, but a ByteString is not a list
19:06:18 <dons> hmm yes
19:06:53 <stepcut> the 'interesting' parser are pTakeWhile and pDropWhile -- they can consume a whole bunch of the input stream and return it
19:07:13 <stepcut> but, that is also a very cheap operation, because it shares the data with the original bytestring
19:07:40 <stepcut> so it only has to create the (BS Ptr Length)
19:08:15 <newsham> > let x = takeWhile ((/= ' ') . fst) $ zip "hi there bob" [0..] in (snd (head x), map fst x)
19:08:16 <mbot>  (0,"hi")
19:09:12 <int-e> stepcut: another idea is -fno-cse - maybe that's a good thing to try for all space leaks.
19:09:43 <stepcut> int-e: good thinking
19:12:31 <midfield> > let ls = zip "hi" [0..] in let (t, os) = unzip ls in (t, head os, last os)
19:12:32 <mbot>  ("hi",0,1)
19:13:01 <newsham> isnt there a function that will group together items from a list by a predicate?
19:13:13 <dcoutts> stepcut, did you start with ByteString for your parser or switch from Parsec?
19:13:21 <LordBrain> groubBy
19:13:30 <LordBrain> i think
19:13:35 <LordBrain> @type groupBy
19:13:36 <mbot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
19:14:08 <LordBrain> that's not a predicate...
19:14:37 <stepcut> dcoutts: I had a Parsec parser that parse the file. But using strings was way to slow and used to much space. So I wrote a custom Parser library for use with ByteStrings and wrote a new parser using that
19:15:06 <dcoutts> stepcut, cool. Do you happen to have any hard or rough numbers on the difference?
19:15:17 <dcoutts> or order of magnitude
19:16:04 <stepcut> dcoutts: rough numbers, BEFORE: 180 MEGS, 30 seconds. AFTER: 10 MEGS 0.5 seconds
19:16:24 <dcoutts> stepcut, wow. and that was for parsing some large deb control file?
19:16:37 <stepcut> dcoutts: I gave dons some actual numbers before -- if he does not have them still, we can search the channel logs
19:16:39 <newsham> linspire stuff?
19:16:47 <dcoutts> stepcut, ah ok. cheers.
19:16:49 <stepcut> dcoutts: yeah, parsing the Packages file for sid/main
19:16:57 <stepcut> newsham: yes
19:18:45 <hyrax42> before = ?
19:18:55 <hyrax42> if I may stick my nose
19:19:32 <stepcut> before is parsing with Parsec and String, after is parsing with ByteString and a ByteString-based parser module
19:21:29 <hyrax42> not a Parsec for ByteString, though?
19:21:41 <stepcut> hyrax42: no, I don't think that is possible
19:22:08 <hyrax42> oh?
19:22:37 <stepcut> hyrax42: Parsec expects the input to be a list of tokens, so you would have to do an 'unpack' on the ByteString and then 'pack' everything back up afterwards
19:23:43 <stepcut> hyrax42: I could not find anyway to get Parsec to work on the ByteStrings directly
19:23:53 <hyrax42> oh ok
19:24:17 <hyrax42> but in theory an equivalent could be written?
19:24:19 <hyrax42> for fps
19:24:22 <hyrax42> bytestring
19:24:49 <stepcut> hyrax42: right -- that is what I did -- although it currently has far fewer features than Parsec
19:25:04 <hyrax42> ah
19:25:05 <hyrax42> kk
19:25:06 <SamB> stepcut: there ought to be typeclasses
19:26:04 <stepcut> SamB: that could be done to a degree. Though different data-types have different features which can be exploited by the parsers
19:26:10 <SamB> hmm
19:26:22 <SamB> well, also just for the basic parser stuff...
19:26:42 <SamB> so for instance ParsecT would be able to share much of the interface...
19:26:54 <stepcut> SamB: yeah, the parser I have is based on the type:
19:26:57 <stepcut> newtype Parser state a = Parser { unParser :: (state -> Either (state,[String]) (a, state)) }
19:27:34 <stepcut> I have thought about (a) adding a ParserT type (b) adding a type class that provides the features needed by the combinators
19:28:21 <stepcut> class ParserThings state tok where nextToken :: state -> (state, tok); peekToken :: state -> tok ; ...
19:28:30 <stepcut> something like that
19:29:46 <stepcut> actually.. I think I already have a type class like that for another project
19:42:02 <midfield> am i doing something wrong with paste? cos when i submit i get a blank screen and no paste.
19:44:06 <lispy> which paste?
19:44:22 <midfield> paste.lisp.org/new/haskell
19:44:39 <Korollary> fine for me
19:44:51 <Korollary> try rafb.net
19:45:03 <Korollary> http://rafb.net/paste/
19:45:05 <lispy> looks broken
19:45:23 <lispy> for me it just hangs on the submit page
19:45:31 <midfield> lispy: me too.
19:45:51 <Korollary> hmm
19:45:55 <lispy> stop using a hippy browser and go back to ff ;)
19:45:56 <Korollary> can't submit. oh well.
19:46:01 <lispy> er i meant IE...geez
19:46:10 <lispy> i can't even make sarcastic remarks today
19:46:16 <Korollary> have some whiskey
19:46:21 <lispy> i should
19:46:31 <midfield> http://rafb.net/paste/results/A9PyCB88.html
19:46:45 <midfield> would appreciate some criticism
19:46:46 <lispy> i read somewhere today, "Decide what is important to you and do it."  So yes, I need whiskey
19:46:57 <lispy> midfield: you did it all wrong
19:47:05 <lispy> midfield: and you smell funny
19:47:15 <midfield> esp from newsham !
19:47:39 <lispy> midfield: first off, what should this function do?
19:47:50 <lispy> splitWithOffsets :: (a -> Bool) -> [a] -> [([a], Int, Int)]
19:47:53 <lispy> i don't really get the type
19:48:04 <lispy> why int, int?
19:48:17 <Korollary> it seems to split on a predicate while recording the offsets of the splits
19:48:33 <midfield> lispy: splitWithOffsets Char.isSpace is like "words" but it keeps track of the offsets, the beginning and end
19:48:46 <lispy> hmm
19:49:18 <newsham> *shrug* looks reasonable to me
19:50:41 <midfield> thanks.  i'm new to this, just want to know if i'm doing braindead stuff or not.
19:50:51 <lispy> @type dropWhile (p . fst)
19:50:52 <mbot> Not in scope: `p'
19:50:59 <SamB> heh
19:51:10 <lispy> @type dropWhile (Data.isSpace . fst)
19:51:11 <mbot> Couldn't find qualified module.
19:51:12 <mbot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.\\)?
19:51:14 <Korollary> autovivy p, lambdabot
19:51:24 <Korollary> +if
19:51:28 <midfield> common lisp is my main language.
19:51:28 <SamB> @type dropWhile (isSpace . fst)
19:51:29 <mbot> forall b. [(Char, b)] -> [(Char, b)]
19:51:34 <lispy> thanks
19:51:42 <SamB> @type dropWhile (Char.isSpace . fst)
19:51:43 <mbot> forall b. [(Char, b)] -> [(Char, b)]
19:51:47 <SamB> @type dropWhile (Data.Char.isSpace . fst)
19:51:48 <mbot> forall b. [(Char, b)] -> [(Char, b)]
19:52:04 * SamB yawns
19:52:44 <lispy> oh, i see
19:52:47 <midfield> as a strict algorithm what i've written seems insanely inefficient.  will deforestation save my day here?
19:52:53 <lispy> you zip them all up with their offsets
19:53:14 <SamB> midfield: who knows?
19:53:19 <newsham> > let x = takeWhile ((/= ' ') . fst) $ zip "hi there bob" [0..] in (snd (head x), map fst x)
19:53:20 <mbot>  (0,"hi")
19:54:02 <midfield> newsham: i mainly copied the source to "words"
19:54:14 <newsham> midfield: thats prob how i'd go about it.
19:54:42 <lispy> not sure if i like the return type
19:54:54 <lispy> [(a, (Int, Int))]
19:55:06 <lispy> er list of a
19:55:13 <lispy> [([a], (Int, Int))]
19:55:43 <lispy> i might like that better, because then you can fst and snd on the return list
19:56:16 <lispy> @hoogle fst3
19:56:16 <mbot> search module failed: IRCRaised getHostByName: does not exist (no such host entry)
19:56:47 <newsham> Token { [a] : value, Int : start, Int : end } ?
19:57:06 <midfield> yeah, in my code it's all wrapped up in datatypes, i kept them out for brevity.
19:57:08 <lispy> no, i think that's over kill
19:57:22 <newsham> lisp: very useful to be able to   "start tok" and "end tok"
19:57:43 <lispy> i want to be able to do, map fst (splitWithOffset Char.isSpace "blah")
19:57:50 <lispy> and get "blah"
19:58:20 <lispy> @type lookup
19:58:21 <mbot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
19:58:26 <Korollary> half a dozen and its variations
19:58:31 <lispy> also, my return value would work with lookup
19:58:51 <newsham> map value (...)
19:59:24 <Korollary> I dont like list lookup as the same word may appear multiple times.
19:59:26 <newsham> dont hate on the records
19:59:45 <lispy> i like records, but i don't think this is a good time for them :)
19:59:51 * lispy uses lots of records in his code
20:00:17 <lispy> value isn't the best name if this is a prelude-ish function, on a side note...
20:00:28 <SamB> or!
20:00:30 <newsham> prelude?
20:00:35 <SamB> M.fromList!
20:00:35 <midfield> By the way, literate haskell built-in rocks, as does the Emacs support.
20:00:38 <newsham> tokval
20:00:45 <SamB> @type M.fromList
20:00:46 <mbot> Couldn't find qualified module.
20:00:46 <mbot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.\\)?
20:00:55 <SamB> > M.fromList []
20:00:56 <mbot>  Add a type signature
20:01:12 * lispy wonders what magic SamB is going to demonstrate
20:01:18 <SamB> > M.fromList [("Hello!", (0,6)]
20:01:18 <mbot>  Parse error
20:01:21 <SamB> ack
20:01:26 <SamB> the magic of parse errors
20:01:27 <lispy> @type M.fromList
20:01:28 <mbot> Couldn't find qualified module.
20:01:28 <mbot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.\\)?
20:01:33 <SamB> > M.fromList [("Hello!", (0,6))]
20:01:33 <lispy> why is that wrong...
20:01:34 <mbot>  {"Hello!":=(0,6)}
20:01:46 <dons> ?type Data.Map.fromList
20:01:47 <Korollary> is M for mathematica?
20:01:47 <mbot> forall a k. (Ord k) => [(k, a)] -> Data.Map.Map k a
20:01:56 <SamB> lispy: because apparantly @type and @eval don't *quite* share import lists
20:02:05 <dons> right. they should
20:02:06 <lispy> oh...why should they...
20:02:07 <SamB> Korollary: Data.Map
20:02:09 <dons> patch away..
20:02:24 <SamB> lispy: so that expressions work in both?
20:02:40 * lispy doesn't get the question
20:02:52 <dons> you can't get qualified imports in ghci/@type anyway, can you?
20:03:03 <SamB> dons: sure you can
20:03:10 <SamB> import a source file with a *U
20:03:12 <SamB> er, *
20:03:15 <SamB> not *U
20:03:26 <SamB> if the source file has qualified imports, you are all set
20:03:44 <lispy> SamB: oh, i was being sarcastic when i asked "why should they"
20:03:46 <SamB> so basically a file consisting of nothing but imports would work
20:03:52 <lispy> and then i was confused...
20:03:59 <SamB> lispy: sarcastic?
20:04:12 <lispy> um...it's my version of sarcastic
20:04:19 <SamB> I don't get how sarcasm was appropriate
20:04:26 <lispy> it's like sarcastic, but with too many vowels
20:04:49 <SamB> @spell sarcastic
20:04:50 <mbot> sarcastic
20:05:01 <SamB> um, you spelled it right
20:05:05 <lispy> @dict-all sarcastic
20:05:06 <mbot> Unknown command, try @list
20:05:17 <SamB> @all-dict sarcastic, for some odd reason
20:05:22 <SamB> @dict-all would make more sense
20:05:22 <mbot> *** "Sarcastic" gcide "The Collaborative International Dictionary of English v.0.48"
20:05:22 <mbot> Sarcastic \Sar*cas"tic\, Sarcastical \Sar*cas"tic*al\, a.
20:05:22 <mbot>   Expressing, or expressed by, sarcasm; characterized by, or of
20:05:22 <mbot>   the nature of, sarcasm; given to the use of sarcasm; bitterly
20:05:22 <mbot>   satirical; scornfully severe; taunting.
20:05:23 <lispy> i can't read today
20:05:24 <mbot> [900 @more lines]
20:05:26 <mbot> Unknown command, try @list
20:05:28 <lispy> i thought i misspelt it
20:05:34 <juhp> dons: are you hosting yi+gtk btw?
20:05:38 <dons> I am
20:05:39 <juhp> darcs failed:  Failed to download URL http://www.cse.unsw.edu/~dons/code/yi+gtk/_darcs/patches/20060723101129-c6932-08084d8346dcd7fce681d9778065bc0a06292fa4.gz
20:05:43 <dons> ah
20:05:46 * dons fixifies
20:05:53 <juhp> thanks :)
20:05:54 <SamB> @all-dict sarcasm
20:05:55 <mbot> *** "Sarcasm" gcide "The Collaborative International Dictionary of English v.0.48"
20:05:55 <mbot> Sarcasm \Sar"casm\, n. [F. sarcasme, L. sarcasmus, Gr.
20:05:55 <mbot>   sarkasmo`s, from sarka`zein to tear flesh like dogs, to bite
20:05:55 <mbot>   the lips in rage, to speak bitterly, to sneer, fr. sa`rx,
20:05:55 <mbot>   sa`rkos, flesh.]
20:05:57 <mbot> [36 @more lines]
20:06:03 <SamB> @devils sarcasm
20:06:04 <mbot> No match for "sarcasm".
20:06:06 <SamB> @devils sarcastic
20:06:07 <mbot> No match for "sarcastic".
20:06:11 <SamB> @devils bitter
20:06:12 <mbot> No match for "bitter".
20:06:14 <lispy> @all-dict sardonic
20:06:14 <SamB> @devils
20:06:15 <dons> juhp: fixed
20:06:15 <mbot> *** "Sardonic" gcide "The Collaborative International Dictionary of English v.0.48"
20:06:15 <mbot> Sardonic \Sar*don"ic\, a. [F. sardonique, L. sardonius, Gr. ?,
20:06:15 <mbot>   ?, perhaps fr. ? to grin like a dog, or from a certain plant
20:06:15 <mbot>   of Sardinia, Gr. ?, which was said to screw up the face of
20:06:15 <mbot>   the eater.]
20:06:17 <mbot> [39 @more lines]
20:06:37 <juhp> dons: thank you
20:06:38 <SamB> dons: there ought to be a way to get a random entry from the devil's dictionary
20:06:38 * lispy always struggled with the difference between sarcasm and sardonic
20:06:53 <dons> SamB: hmm.
20:07:03 <dons> I'm not sure how to query the dictionary server randomly, without copying its index.
20:07:12 <SamB> dons: maybe you can't
20:07:19 <SamB> but it would still be cool
20:07:28 <dons> you could always keep a local copy of the keys, index them randomly, and query
20:07:35 <dons> but seems kind of heavy for a little used feature ;)
20:07:36 <SamB> its not like you need to worry about new entries being added to *that* one
20:07:47 <dons> heh
20:08:17 <SamB> maybe they should be mixed in with the @quotes ;-)
20:08:25 <SamB> @quote
20:08:26 <mbot> Igloo says: [dons: anyone know what happened to [the] Haskell wishlist?]  Igloo: Did it have "Crush Java" listed?
20:08:29 <lispy> apparantly sardonic is bitterly sarcastic...and sarcasim is bitter...so what's the difference? sardonic is mean and sarcasm is playful?
20:08:47 <SamB> lispy: I don't even know what sardonic means
20:09:16 <juhp> sardonic sounds a bit stronger or sterner to me, but I admit to never using the word ;)
20:09:34 <lispy> SamB: well, look it up.  I'll give you the hint that the definition may include, "bitterly sarcastic" ;)
20:09:55 <int-e> sardonic is somewhere between sarcastic and cynical then?
20:10:01 <lispy>            The scornful, ferocious, sardonic grin of a bloody
20:10:03 <lispy>            ruffian.                                 --Burke.
20:10:16 * lispy looks up cynical to cehck
20:10:21 <johnnowak> int-e: no
20:10:50 <SamB> heh, looked up the wrong word
20:10:54 <juhp> there's also ironic...
20:10:56 <SamB> looked up sarcastic instead
20:11:00 <lispy> int-e: cynical seems to targeted
20:11:34 <SamB>      Forced; unnatural; insincere; hence, derisive, mocking,
20:11:34 <SamB>      malignant, or bitterly sarcastic; -- applied only to a laugh,
20:11:34 <SamB>      smile, or some facial semblance of gayety.
20:11:34 <SamB>      [1913 Webster]
20:11:52 <johnnowak> that's better
20:12:12 <SamB> good old webster ;-)
20:12:27 <lispy> so...sardonic only applies to smiling and facial expressions?
20:12:28 <int-e> Oh, sardonic already lost pretty much all humorous touches.
20:12:35 * johnnowak refuses to listen to a dictionary that doesn't define recontextual but takes the space to fit in bootylicious
20:12:39 <SamB> I do remember reading about Talon Karde's sardonic smile in some star wars book...
20:12:58 * johnnowak has HAD IT with dictionaries
20:13:21 <SamB> johnnowak: I don't see *either of those* in any of the dictionaries in the main list for dict.org...
20:13:22 * johnnowak chucks a brick at post-modernism
20:13:33 <lispy> haah
20:13:34 <johnnowak> SamB: perhaps i spelt bootylicious wrong.
20:13:35 <lispy>      Of, pertaining to, or resembling, a kind of linen made at
20:13:35 <lispy>      Colchis.
20:13:36 <lispy>      [1913 Webster]
20:13:46 <johnnowak> SamB: It's in webster's I think.
20:13:57 <SamB> johnnowak: I said *old* websters
20:14:02 <SamB> 1913 did not have such words
20:14:29 <johnnowak> oh. well... yes.
20:14:29 <lispy> wordnet doesn't mention facial expressions in the definition
20:14:32 <johnnowak> and a good thing it didn't!
20:15:52 * johnnowak would briefly describe sardonic as "exhibiting a mean friendliness"
20:17:21 <lispy> hmm..
20:17:23 <lispy> sounds good to me
20:17:37 <tennin> sardonic to me means a more subtle and sophisticated sort of wry sarcasm
20:17:56 <tennin> not sure if that's right
20:18:03 <johnnowak> nope. not so much.
20:19:37 <lispy> do you eat rye bread with your wry sarcasm?
20:20:39 <dons> hehe
20:21:41 <tennin> on occasion
20:30:28 * lispy wonders why "random order" is an oxymoron
20:30:52 <lispy> clearly in haskell it makes sense to have a random sequence...and that's the same thing right?
20:31:09 <dons> but its not ordered..
20:31:31 <dons> I suppose if you sorted it, it would be a random order ;)
20:32:55 <lispy> ah so you have to becareful and say it's a sequence?
20:33:02 <lispy> in the context above, order meant listed out
20:35:26 <midfield> is there a standard place where cabal puts haddock files?
20:37:53 <dons> lispy: yeah, english is silly :)
20:38:18 <dons> are there anonymous functions in lojban?
20:44:04 <lispy> i could see an advanced guide to lojban, "Speaking in lambdas"
20:44:36 <Korollary> Perl6 got lambdas. They chose to call them "pointy functions" or something, though.
20:44:56 <lispy> as in, "don't poke yourself on those pointy functions"?
20:45:17 <Korollary> I should not speculate.
20:47:46 <Cale> Perhaps as opposed to points-free functions?
20:48:24 <Cale> Though even perl 6 never struck me as a particularly points-free language.
20:48:46 <Korollary> It's noit points free
20:49:02 <Korollary> The syntax is something like a.b -> stuff_with_a_b
20:49:05 <Korollary> err a,b
20:49:21 <Korollary> maybe because of the arrow
20:51:49 <Korollary> It's also got macros, lazy lists, a ton of new syntactic sugar.
20:52:06 <Korollary> let bindings
20:52:26 <lispy> does it finally have function calls that accept parameters?
20:52:31 <Korollary> yes
20:52:37 <lispy> or does it still do the ridiculous shift crap?
20:52:37 <lispy> ah
20:52:41 <lispy> 'bout time
20:52:44 <Korollary> also optional static type annotations + inference
20:52:53 <dons> parameters are a great invention
20:52:53 <lispy> wow
20:53:15 <lispy> yeah, but i get nostalgic sometimes and want to build my own activation records
20:53:20 <lispy> don't you?
20:53:40 <Korollary> also named function args
20:53:42 <dons> hehe
20:54:02 <Korollary> lazyness annotation for methods
20:55:03 <Korollary> some heavy sugar for list-like 'junctions' that operators like any, all, none, etc. work on in parallel.
20:55:32 <Korollary> i.e. (1|2|3) + 4 ===> (5|6|7)
20:55:49 <lispy> that's cool
20:55:55 <lispy> is that something you could do with arrows?
20:56:04 <Korollary> and then you can say any(4|5|6) > 5 ===> True
20:56:27 <dons> hmm
20:56:32 <Korollary> it's something you can do with lists and lifted functions afaict
20:56:41 <dons> > map (+4) [1,2,3]
20:56:42 <lispy> Korollary: i would think your parens are wrong
20:56:42 <mbot>  [5,6,7]
20:56:53 <lispy> dons: ah, good call
20:57:16 <lispy> i would expect any ((4|5|6) > 5) ==> True
20:57:48 <Korollary> I don't exactly remember. Nonetheless, it's sugar anyway.
20:58:48 <int-e> > any (>5) [4,5,6]
20:58:49 <mbot>  True
21:00:14 <Korollary> It goes a bit farther than that. Somehow, (1|2) + (3&4) ends up being (4|5) & (5|6). It's in the synopses at dev.perl.org.
21:00:49 <lispy> i think you mean further
21:01:15 <lispy> but i always struggle with further/farther
21:01:18 <int-e> > liftM2 (+) [1,2] [3,4]
21:01:19 <mbot>  [4,5,5,6]
21:01:24 <int-e> sorta
21:01:43 <int-e> It goes a bit beyond that :)
21:01:48 <Korollary> I can say farther when I likes it. (farther is ok when talking about distances afaik)
21:01:51 <dons> yeah, seems kind of (-> a) monad ish. or maybe just list monadis
21:02:11 <dons> ?dicts farther
21:02:11 <mbot> Supported dictionary-lookup commands:
21:02:12 <mbot>  @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @jargon @lojban @vera @web1913 @wn @world02
21:02:12 <mbot> Use "@dict-help [cmd...]" for more.
21:02:19 <dons> ?web1913 farther
21:02:20 <mbot> *** "Farther" web1913 "Webster's Revised Unabridged Dictionary (1913)"
21:02:20 <mbot> Far \Far\, a. [{Farther}and {Farthest}are used as the compar.
21:02:20 <mbot>   and superl. of far, although they are corruptions arising
21:02:20 <mbot>   from confusion with further and furthest. See {Further}.]
21:02:20 <mbot>   [OE. fer, feor, AS. feor; akin to OS. fer, D. ver, OHG.
21:02:22 <mbot> [74 @more lines]
21:03:09 <lispy> but did you really mean distance?
21:03:13 <lispy> this is why it confuses me
21:03:41 <int-e> in a metaphorical way, maybe
21:03:42 <lispy> i pointed it out less to nitpick and more because i hopped someone here could explain :)
21:03:55 <dons> "corruptions arising from confusion with further" huh
21:04:16 <dons> ?web1913 further
21:04:17 <mbot> *** "Further" web1913 "Webster's Revised Unabridged Dictionary (1913)"
21:04:17 <mbot> Further \Fur"ther\, a. compar. [Positive wanting; superl.
21:04:17 <mbot>   {Furthest}.]
21:04:17 <mbot>   1. More remote; at a greater distance; more in advance;
21:04:17 <mbot>    farther; as, the further end of the field. See {Farther}.
21:04:19 <mbot> [35 @more lines]
21:04:36 <lispy> so in 1913 they were the same?
21:04:38 <dons> mutually recursive definitions, eh?
21:04:52 <dons> well, one's a corruption?
21:05:10 <Korollary> This is better: http://www.answers.com/farther
21:05:48 <Korollary> I suppose, as it is meant metaphorically, I should have said further. I feel no remorse, though.
21:06:10 <dons> here's a sneek peek for you bored people, http://www.cs.mu.oz.au/~bjpop/timeline/timeline.4.png
21:06:22 <dons> anyone think of significant projects that have been missed?
21:06:36 <Korollary> what's the x axis?
21:06:43 <dons> there's no x axis
21:06:48 <Korollary> oh
21:07:53 <Korollary> are the colors arbitrary, too?
21:08:07 <Korollary> hmm, no, the reports are all in red.
21:08:09 <dons> yep
21:08:18 <dons> no! they have magical significance
21:08:50 <lispy> ooo...magical...
21:08:53 <dons> they actually denote categories
21:08:53 <lispy> it's pretty cool tho
21:09:07 <int-e> sneak preview.
21:09:15 <dons> right
21:09:34 <int-e> I wonder what orange is, "other remarkable things"?
21:09:44 <int-e> print publications?
21:09:44 <dons> media?
21:09:44 <Korollary> books
21:09:44 <int-e> hmm
21:09:54 <int-e> JFP is a book?
21:09:55 <Korollary> yeah, print
21:10:02 <dons> oh, yellow is community, orange is books
21:10:26 <lispy> is it based on history of haskell paper?
21:10:32 <Korollary> implementations in green. gatherings in blue. libs/tools in purple.
21:10:32 <int-e> as a side note, I find the black on red hard to read here, lacking contrast.
21:10:36 <dons> it is part of the history paper
21:10:50 <lispy> that makes sense
21:11:24 <dons> possibly the irc channel and HWN should be there. not sure
21:12:07 <dons> though its hard to pick things in the last few years that will be significant in 5-10 years
21:12:40 <Korollary> flip a coin
21:12:51 <lispy> the irc channel will remain significant it think, but i don't really feel like it belongs on that list
21:13:00 <dons> yeah
21:13:03 <lispy> otoh, i think lambdabot goes on the list...is she on there
21:13:05 <Korollary> the number of monad tutorials written.
21:13:06 <int-e> @dice 1d2
21:13:06 <mbot> 1d2 => 2
21:13:14 <dons> lambdabot was on there, but got bumped off
21:13:25 <int-e> fps is too new?
21:13:30 <dons> maybe
21:13:45 <dons> i suspect that will be significant, but don't want to make the call
21:13:48 <lispy> i forsee a lot of lambdabot features going into ghci
21:13:48 <Korollary> Where's TH?
21:13:52 <int-e> hmm, maybe not meaningful for outsiders. 'what does it do?'
21:14:13 <dons> oh TH. hmm.
21:14:23 <dons> note that most language extensions aren't there.
21:14:29 <lispy> what about O'Haskell?
21:14:34 <Korollary> true
21:14:46 <int-e> language extensions in general aren't there it seems
21:14:50 <lispy> i'd say lambdabot is more important than, say, VH
21:14:59 <Korollary> hierarchical libs?
21:15:10 <dons> lispy: yeah, VH is a bit weird
21:15:20 <dons> though it means ghc-api, really
21:15:27 <dons> (I think)
21:15:28 <lispy> it's not even finished...and i can't do a lot fo things with it i find out after the fact
21:15:37 <lispy> like that problem i emailed you about is the weirdest one
21:15:49 <dons> lispy: hehe. maybe we should scrub VH and put in yi ;)
21:15:55 <int-e> green card is there?
21:15:55 <lispy> lol
21:16:03 <dons> int-e, yep
21:16:19 <int-e> did that result in the FFI addendum, eventually?
21:16:25 <int-e> or did that exist before?
21:16:34 <dons> green card was the first binding tool,  I think
21:16:34 <int-e> hmm. 1997
21:16:39 <dons> which helped guide the ffi design
21:16:42 <lispy> also ,why is VH purple?
21:16:45 <int-e> that predates the addendum them
21:16:47 <int-e> then
21:16:49 <lispy> purple seems like things built in haskell mostly
21:17:03 <int-e> libraries, I thought
21:17:19 <Korollary> libs & tools I guess
21:17:21 <int-e> or development tools
21:17:24 <int-e> right
21:17:47 <dons> i wonder if lambdabot'll still be running in 10 years.
21:17:51 <Korollary> How big is VH anyway?
21:17:55 <dons> seems possible
21:18:01 <int-e> yellow is internet stuff
21:18:18 * stepcut wants an O(1) version of Data.List.init
21:18:20 <lispy> Korollary: big in what sense?
21:18:31 <Korollary> in the sense of LoC
21:18:35 <dons> stepcut: use Data.ByteString.init ;)
21:18:39 <lispy> oh, that i don't know
21:18:49 * lispy goes for a walk
21:19:09 <dons> @seen sjanssen
21:19:10 <mbot> sjanssen is in #haskell. I last heard sjanssen speak 7 hours, 21 minutes and 56 seconds ago.
21:19:37 <stepcut> dons: hrm I want, O(1) cons, O(1) init, and O(1) head :)
21:20:07 <dons> ah.
21:20:13 <int-e> stepcut: use (Int, [a]) where the int keeps track of the length?
21:20:13 <stepcut> "I want all the groceries in one bag, and I don't want the bag to be heavy"
21:20:14 <dons> well Data.ByteString.Lazy then, almost..
21:20:47 <stepcut> int-e: even then, how do I drop just the last element without lots of memory allocation ?
21:20:48 <dons> cons O(1), init O(1), head O(1) in Data.ByteString.Lazy
21:20:57 <int-e> stepcut: decrement the int by 1
21:21:24 <dons> hmm O(1) init doesn't sound right. hmm
21:21:45 <dons> its O(n/c) init, I think
21:22:02 <stepcut> int-e: I think I am missing something. How do I chop off the end of the list so that it can be garbage collected ?
21:22:43 <int-e> stepcut: provide a copy function. use it occasionally.
21:23:35 <stepcut> int-e: yeah -- i was just about to suggest that -- my list is only around 32-512 elements long -- so I could just let it build up and chop it every once and a while
21:23:45 <stepcut> that would be good enough
21:25:29 <int-e> using bytestring would have the same problem.
21:26:03 <int-e> I think.
21:26:28 <Korollary> chopping off a list is mutating it, right?
21:27:28 <Korollary> I suppose we could use a Data.Vector
21:27:34 <Korollary> I mean if it existed.
21:27:59 <stepcut> Data.Array is close -- but then you have to be inside some sort of state monad to mutate it
21:29:05 <Korollary> Can you resize arrays in O(1)?
21:30:03 <stepcut> Korollary: in theory you would need to realloc
21:30:13 <Cale> Can you even allocate memory in O(1)?
21:30:16 <int-e> Data.Sequence.
21:30:32 <Korollary> yeah
21:31:16 <int-e> but that's new in base-2.0 it seems. (which basically means ghc 6.6)
21:32:46 <int-e> And I'd expect (Int, [a]) to be faster. Finger trees for a restricted deque are probably not the best idea.
21:33:03 <stepcut> int-e: yeah, the (Int,[a]) seems like a good option
21:34:26 <Korollary> It's weird that there is Data.Queue but no stack
21:34:36 <stepcut> stack == Data.List ?
21:34:41 <int-e> right
21:34:52 <stepcut> push = (:), pop = head
21:35:38 <dons> you can shrink arrays in O(1) if you just waste the end
21:35:54 <dons> we do that for bytestrings < 4k, and others that shrink by less than 20%
21:37:06 <stepcut> yeah, int-e's idea of (Int, [a]) is essential the same thing on lists
21:37:20 <dons> yeah
21:37:37 <int-e> dons: does bytestring compare to the original size there?
21:37:41 * Korollary is braindead
21:38:09 <dons> int-e, hmm? original size?
21:38:16 <dons> you mean, if we do lots of shrinks?
21:38:27 <dons> filter . filter  . filter . filter ?
21:38:31 <araujo> hi!
21:38:37 <int-e> dons: if I have a 1 MB bytestring, and shrink it gradually ... yes, lots of shrinks
21:38:40 <stepcut> hi!
21:38:57 <dons> (fusion should take care of this -- you'll by default compare against the original length)
21:39:08 <dons> if you do something sneaky though, you might want to copy
21:39:28 <dons> maybe we should look up the underlying MBA# length though
21:42:06 <int-e> can the copies be avoided somehow (for a user of the library)?
21:42:33 <dons> i'd be interested to know if this was ever an issue
21:42:36 <int-e> say I have a file and want to work with many relatively short but overlapping substrings of that file simultaneously.
21:42:42 <dons> it could be avoided if we looked up the underlying MBA# size
21:42:53 <int-e> building a trie is an example I think.
21:43:31 <dons> hmm. if they're overlapping then you'd be best to share anyway
21:44:09 <dons> i.e. substrings are shared
21:48:14 <int-e> that being said automatically copying seems to be a reasonable default. it'd just be nice to be able to work around that when necessary
21:49:22 <midfield> http://rafb.net/paste/results/orm2Qa84.html
21:49:53 <dons> B.length(word) --> B.length word
21:50:01 <midfield> whitespace tokenizer with offset for data.bytestring.char8s.  would appreciate comments (my first time using bytestrings)
21:50:34 <int-e> but knowing that a bytestring is a mutable byte array together with a length and an offset already ...
21:50:39 <dons> 'acc' isn't a good name for a function :)
21:50:46 <dons> maybe 'go' or 'loop'?
21:50:50 <int-e> layering the same structure again on top of it looks silly :)
21:51:02 <midfield> whoops typo, line 9 should be acc rest )e + 1)
21:51:17 <midfield> dons: otherwise looks reasonable?
21:51:26 <dons> midfield: yep
21:51:39 <dons> possibly i'd strictify the bytestring argument to the loop
21:51:48 <dons> so it'll get unboxed (if performance matters here)
21:52:01 <midfield> dons: i'm not sure i know how to do that.
21:52:08 <dons> acc b n | b `seq` n `seq` False = undefined
21:52:17 <dons> acc b n = case ...
21:52:38 <dons> maybe it doesn't matter for you though
21:52:38 <dons> if you have ghc 6.6 you'd write: acc !b ! = case ..
21:52:47 <dons> acc !b !n = case ... -- I mean
21:53:09 <midfield> dons; using ghc6.4.1, sorry.  should i upgrade?
21:53:18 <dons> no :)
21:53:23 <Korollary> nah you're ok
21:53:31 <dons> you could try the | b `seq` n `seq` False = undefined, if you want to experiment
21:53:39 <dons> but there's no pressing need to do that
21:54:33 <midfield> dons: not sure what you're talking about :P.  btw, this shouldn't do any copying right?
21:55:08 <dons> breakSpace is a substring operation, so no copying.
21:55:30 <dons> it'll build a new structure that shares the underlying larger bytestring
21:55:36 <midfield> dons: great.  love the library by the way.
21:55:39 <dons> :)
21:56:00 <midfield> dons: same with B.drop i assume as well.
21:56:07 <dons> yep
21:56:22 <dons> you can tell by looking at the complexity annotations
21:56:41 <int-e> ok, then I'm confused - which operations create a copy when a bytestring becomes too small?
21:56:42 <dons> maybe I should add "This is a zero-copying implementation" or something to those functions
21:56:52 <dons> int-e, functions that build _new_ bytestrings
21:57:02 <dons> i.e. filter, unfold, and so on
21:57:11 <dons> also, fusible functions
21:57:15 <dons> (if fusion happens)
21:57:20 <dons> otherwise, sharing is the default
21:57:44 <int-e> oh, you mean, filter allocates a buffer that's large enough to hold the original, then filters, then, maybe, resizes?
21:57:51 <dons> yep
21:57:55 <int-e> ahh!
21:58:09 <dons> but all functions that take _substrings_ of a string, by default share
21:58:09 <int-e> ok, then my worries weren't justified.
21:58:36 <dons> _except_ in fps 0.8, where they may fuse with things like filter and map, in which case, they might copy
21:58:42 <dons> (which is a good thing)
21:59:02 <dons> i.e. take doesn't copy, normally
21:59:07 <int-e> ok, but I suspect results of different filters couldn't be shared anyway, so that's fine.
21:59:08 <dons> but take . filter will
21:59:25 <dons> since take . filter is a special kind of filter, essentially
21:59:31 <dons> int-e, right .they can't be shared
22:00:30 <dons> so the library will by default share substrings, unless it notices the user creates an opportunity for fusion, in which case is switches to a copying/fusible version of the function
22:00:34 <dons> (self optimising libraries!)
22:00:34 <int-e> Btw, I thought  shrinking meant 'drop' or 'take' and friends. Hence the confusion.
22:00:40 <dons> ah
22:01:10 <int-e> I.e. I was looking from a user's perspective instead of the implementor's perspective.
22:01:20 <dons> ah ok
22:02:09 <midfield> dons: stupid question -- what is fusion?
22:02:38 <int-e> applying   map f . map g = map (f . g)  is probably the simplest example
22:03:05 <int-e> doing that will avoid an intermediate list (or bytestring, in dons' case) being constructed.
22:03:25 <int-e> We say the two maps are being fused together.
22:03:31 <midfield> int-e: deforestation for bytestrings?
22:03:34 <dons> yep
22:03:51 <dons> (also means only one traversal of the underlying array)
22:04:06 <dons> == good :)
22:04:54 <midfield> dons: but that's .... unpossible!
22:06:01 <dons> hmm?
22:06:18 <midfield> dons: i was trying to be sardonic? sarcastic? :)
22:06:22 <dons> :)
22:06:23 <int-e> @spell unpossible
22:06:23 <mbot> impossible impassible impossibly unfeasible unmissable
22:07:00 <Stinger_> int-e dont watch simpsons?
22:07:24 <int-e> If I did it'd be in the wrong language anyway. But I don't own a TV.
22:07:36 <int-e> (and I don't miss it one bit)
22:08:20 <stepcut> it seems like when I use unboxed things like +# in my function -- the profiler starts ignoring that function and adding the time to the callers SCC instead ...
22:09:20 <dons> could be
22:09:57 <stepcut> I wonder if that is supposed to be a feature
22:10:18 <midfield> omfg reading Java while learning Haskell is killing my brain!
22:11:11 <Korollary> don't do it.
22:11:45 <midfield> Korollary: kind of hard to port lucene without doing it.....
22:12:13 <Korollary> port?
22:13:07 <midfield> Korollary: i'm writing a haskell version of lucene, partly cos i want it, partly to learn haskell better.
22:13:52 <Korollary> Good one.
22:14:29 <Korollary> I suppose lucene is quite non-trivial, tho.
22:17:03 <midfield> Korollary: I think it is not easy but not too hard.  My theory is that a Haskell version should be pretty short, if I get it right.
22:20:16 <stepcut> hrm, I wonder if existentials are cpu/memory expensive
22:20:23 <foxy> It is my understanding that types get erased during compilation, but do the class dictionaries exist in run-time code?
22:21:31 <Korollary> in C++?
22:21:53 <foxy> Korollary, in Haskell
22:22:37 <int-e> afaik, in ghc they do exist, but in jhc they don't.
22:23:10 <foxy> ah
22:24:07 <int-e> jhc has a whole-program approach so the compiler knows all possible constructor tags, which in turn determine the class instance that has to be used. so a class method becomes a huge case statement
22:25:17 <dons> foxy: watching the rugby?
22:25:24 <dons> ah, no you're probably not :(
22:25:38 <dons> crazy nz free to air tv
22:25:41 <int-e> if I remember correctly, that has the consequence that newtype Foo = Foo X is actually implemented as data Foo = Foo X, i.e. the newtype gets an own tag at runtime.
22:26:09 <int-e> having dictionaries makes that unecessary.
22:27:38 <Lemmih> foxy: 'class X a where fn :: a; func :: X a => a -> a' gets compiled to 'data X a = X { fn :: a }; func :: X a -> a -> a'.
22:35:06 <int-e> good night morning day or evening
22:49:21 <Korollary> Ahah
22:49:22 <Korollary> http://lambda-the-ultimate.org/node/1684
22:57:43 <foxy> dons, I'm waiting for free-to-air at 7:30 :(
23:00:05 <dons> ok. good game so far.
23:02:38 <Stinger_> the score is ..
23:02:45 <Stinger_> just kidding!
23:03:07 <dons> ;)
23:03:52 <dons> ?pl \h c -> h * 33 + ord c
23:03:53 <mbot> (. ord) . (+) . (33 *)
23:04:20 <dons> ?pl \h c -> (33 * h) + (ord c)
23:04:20 <mbot> (. ord) . (+) . (33 *)
23:04:30 <dons> ?pl \c h -> (33 * h) + (ord c)
23:04:30 <mbot> (. (33 *)) . (+) . ord
23:04:46 <dons> ?pl \(c,h) -> (33 * h) + (ord c)
23:04:46 <mbot> uncurry ((. (33 *)) . (+) . ord)
23:04:51 <dons> heh
23:05:04 <Stinger_> pl = pointless?
23:05:31 <dons> yep
23:05:54 <Stinger_> man that must confuse a lot of newbs
23:06:06 <Stinger_> "This function is pointless" "why are you telling us about it then
23:06:11 <dons> hehe
23:06:17 <dons> ?wiki Pointfree
23:06:17 <mbot> http://www.haskell.org/haskellwiki/Pointfree
23:07:26 <Stinger_> all you need to do now is interface lambdabot to emacs so you can put the cursor on a function and have it translate it
23:07:33 <dons> can be done, I believe
23:07:38 <dons> certainly works in vim already
23:07:44 <dons> (I use it myself)
23:09:01 * stepcut uses it 'in emacs'
23:09:10 <stepcut> ?pl \x y -> x + y
23:09:11 <mbot> (+)
23:09:11 <dons> lambdabot?
23:09:13 <stepcut> tada!
23:09:17 <dons> ah!
23:09:18 <stepcut> erc
23:09:20 <stepcut> ;)
23:09:20 <dons> hehe sneaky
23:09:53 <stepcut> I guess it would be a little more work to interface haskell-mode to the irc channel
23:10:12 * dons ponders
23:21:44 <Tela> Hmm. Configuring lambdabot for GOA, can I more or less wipe most of the configuration if I'm not going to use it for any IRC right now?
23:22:59 <dons> if you're not using it for irc, then leaving the defaults as they are won't hurt
23:23:27 <dons> putting in garbage values probably won't hurt either ;)
23:24:10 <Tela> hehe, alright. Just wanted to be sure before some rogue lambdabot tries to join 20 channels ;)
23:24:46 <dons> it only goes online if you use --online
23:24:54 <dons> ./lambdabot --online
23:25:09 <dons> which GOA won't do (or will it .... /me imagines sneaky haskell spy ware )
23:25:22 <dons> All your types belong to me!
23:26:03 <Tela> Well, in that case are there any lambdabot analogues that dons doesn't work on? ;)
23:28:18 <dons> heh
23:30:27 <dons> Tela: GOA works ?
23:30:49 <Tela> Ugh, having difficulty with lambdabot right now.
23:30:58 <dons> How so?
23:31:03 <Tela> unknown field hs-source-dirs
23:31:11 <dons> ah, old Cabal
23:31:23 <dons> possibly just changing to: hs-source-dir will work
23:31:34 <dons> or better still, update your Cabal (or install ghc 6.4.2)
23:31:49 <Tela> Hm. 6.4.2 works on an intel mac?
23:33:41 <dons> what are you using at the moment?
23:33:51 <dons> 6.5?
23:33:56 <Tela> 6.4.1
23:34:08 <dons> 6.4.2 should work if 6.4.1 does, surely?
23:34:14 * dons doesn't know
23:34:18 <dons> maybe just update your Cabal
23:34:29 <dons> ?where cabal
23:34:29 <mbot> http://www.haskell.org/cabal
23:34:31 <Tela> there's no binary, I'll try a build, see how far that gets then try updating cabal
23:35:00 <dons> well, updating cabal is the easier option
23:35:47 <lispy> "there is no binary" is that a CS way of quoting the matrix?
23:35:50 <lispy> ;)
23:37:32 <Tela> (Just have a feeling it wont compile without a lot of work that I'm not yet up for)
23:37:50 <dons> cabal should be easier to build though, than ghc itsef, surely?
23:38:41 <Tela> Yeah, I'm sort of winging it, but I likely will just build cabal
23:43:35 <Tela> haha! Configure went without a hitch which I wasn't expecting. I'll try GHC for the fun of it.
23:43:52 <dons> hehe
23:44:16 <dons> this is known as the "False confidence of autoconf" syndrome
23:44:36 <Tela> No, this is the "Having lots of time and little to do" syndrome
23:45:09 <dons> hehe
23:45:14 <Tela> yup
23:45:18 <Tela> build error after 2 seconds
23:45:21 <Tela> Cabal time!
23:46:21 <dons> record time!
23:46:35 <dons> what, you don't have happy?
23:46:39 <dons> or something much worse...
23:46:58 <Tela> Huh?
23:47:23 <dons> I was wondering if the build error was due to 'happy' being missing?
23:47:28 <dons> the parser generator used by ghc
23:47:40 <dons> (that's one of the things that would kill a build early)
23:47:47 <dons> hmm. no, that'd be caught be the configure script
23:48:24 <Tela> it gave me a bit list of "Invalid Register Errors"
23:48:42 <Tela> register name! register -name- errors
23:49:51 <dons> ah
23:49:53 <dons> lovely!
23:49:58 <dons> ?karma+ Tela -- breaking GHC
23:49:59 <mbot> Tela's karma raised to 1.
23:50:33 <Tela> Hm. Is this the sort of Karma I want to be at 0? :)
23:50:44 <Stinger_> haha
23:54:28 <Tela> urk, cabal doesn't like me either. It's complaining about the processor. Line after line of: "/tmp/ghc25601.s:96:no such 386 instruction: `lwz'"
23:57:06 <bdash> Tela: both of those errors you've mentioned make it sound like you're using a PowerPC build of GHC on an Intel Mac?
23:58:30 <Tela> I am using the first one I got working... which likely is the PowerPC. Hmm, how easy is it to get GHC going native?
23:58:56 <bdash> I think there are downloadable binaries of GHC 6.5 for Intel
23:59:39 * edwardk waves ello.
