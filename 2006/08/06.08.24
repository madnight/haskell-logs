00:12:00 <Pseudonym> Nytol.
01:07:10 * boegel notices the quietness in #haskell and coughs loudly
01:10:23 <dons> it was a pretty busy day
01:10:27 <dons> busiest for a week or so
01:11:20 <boegel> ok, nice :)
01:11:29 <boegel> so everyone is tired now? :p
01:11:53 <eivuokko> I just woke up :)
01:11:55 <dons> americans and the pacific finished work and away? europe just waking up.
01:12:28 * Narrenschiff yaaaaaaaawns!
01:14:30 <sieni> waking up?
01:14:47 <sieni> come on, i already insulted people many hours ago
01:16:44 <mnislaih> eivuokko did you see simonmar comment on glasgow-haskell-users about -threaded?
01:17:00 <kolmodin> also, dcoutts is on vacation :)
01:17:07 <eivuokko> mnislaih, in solaris/mac os?
01:17:27 <mnislaih> yep
01:17:37 <dons> and vincenz too
01:18:59 <eivuokko> mnislaih, I saw it.  You have testrun done?, did you report it?
01:19:22 <mnislaih> eivuokko: I am pulling patches and I'll be running the full testsuite as soon as it's finished compiling
01:19:30 <eivuokko> Nice
01:20:26 <eivuokko> From what xerox described me from his testrun results, it seemed mac os x/intel seemed in pretty good shape, tho.
01:21:25 <mnislaih> so what were the testsuite timeouts with THREADED=10 due to ?
01:21:37 <eivuokko> Yeah, I don't know about that :)
01:27:29 <eivuokko> Now that I think it...I think there is a test that builds up a lot of threads, not sure if it includes OS-threads, but I think it does because it failed sometimes in Windows with thread-creation failure.  Maybe that test+other tests together went over some critical value for OS and rts doesn't get error right...but that'd probably required bug in OS rather than rts...so...let's hope it's a bug in my THREADS-stuff or python's handling of multiple processes
01:31:37 * tibbe is tired, hacked until 3AM yesterday
01:36:44 <boegel> tibbe: then go to bed :p
01:56:39 <tibbe> boegel, I'm at work and can't sleep on my desk cause my room mate gives me odd stares then
01:57:02 <dons> you have to sleep _under_ your desk then ;)
02:09:54 <Lemmih> mnislaih: Know if any Windows users has tested your code?
02:10:34 <boegel> tibbe: who cares about your room mates, sjiesh :)
02:11:04 <Oejet> What is the command for starting the inferior Haskell mode in Emacs?  I always forget.
02:11:14 <mnislaih> hi Lemmih: I don't.
02:11:23 <mnislaih> but I can do that at home late this evening
02:15:23 <tibbe> Oejet, C-c C-s
02:16:01 <tibbe> Oejet, C-c C-b jumps to the inferior haskell buffer
02:19:24 <Oejet> tibbe: Hm, it does not do anything.
02:19:49 <Oejet> Is there an initialisation step?
02:23:05 <tibbe> Oejet, yes, let me check
02:24:34 <tibbe> Oejet, I've added "(add-hook 'haskell-mode-hook 'turn-on-haskell-ghci)" to my .emacs (without the quotes of course)
02:25:27 <tibbe> Oejet, I guess it would be similar for hugs
02:25:30 <tibbe> @where haskell-mode
02:25:31 <lambdabot> http://www.iro.umontreal.ca/~monnier/elisp/
02:27:00 <tibbe> I think there's something about it on the Haskell Wiki
02:32:21 <Oejet> Ah, got it.  Thank you, tibbe.
02:33:04 <tibbe> Oejet, You're welcome.
02:38:05 <Oejet> Prefix with C-c:  C-s (start process), C-l (load file), C-r (reload file), C-b (show ghci buffer).
02:43:09 <tibbe> Oejet, yes, C-n is also useful if you're in your .hs buffer and want to jump to the first error, further C-n cycles between errors
02:43:44 <tibbe> i.e C-c C-r, got errors, change buffer C-x C-o, look at error C-c C-n, doesn't always work for some reason
03:00:55 <Phas> @localtyme dons
03:00:57 <lambdabot> Local time for dons is Thu Aug 24 19:58:45 2006
03:01:13 <roconnor> @where UM
03:01:13 <lambdabot> I know nothing about um.
03:01:21 <roconnor> @where dons
03:01:21 <lambdabot> http://www.cse.unsw.edu.au/~dons
03:03:39 <roconnor> http://www.cse.unsw.edu.au/~dons/um.html
03:03:40 <lambdabot> Title: Haskell UM
03:03:51 <roconnor> I want to know which of these are safe and which are not.
03:04:14 <roconnor> Is it fair to say that if I can get a UM to segfault, then the UM is considered unsafe?
03:05:06 <roconnor> I'm interested in the fastest safe implementation.
03:05:11 <ibid> or buggy?
03:05:35 <roconnor> A lot of these machines seem to get their speed by eliminating bounds checking.
03:05:54 <ibid> i guess it depends on the goals
03:06:26 <roconnor> Suppose your goal is to participate in the contest, but not run the risk of executing arbitrary code on your machine.
03:06:44 <roconnor> ... perhaps the right thing to do is make a new user, and hope you have OS support. :/
03:14:02 <mux> dcoutts: ping?
03:17:04 <ricky_clarkson> roconnor: Or virtualisation.
03:17:57 * mux wonders why gtk2hs is crashing on him
03:18:08 <mux> or, more likely, why gtk is crashing
03:20:01 <mux> if I limit to, say, 100 the number of rows I put in my TreeView, it's ok
03:20:16 <mux> if I let the code put all the items I have, it crashes with a segfault
03:22:24 <bassvd> Hi guys, I'm reading haskell-font-lock.el from the haskell-mode in Emacs. It seems that it can rewrite symbols like -> to actual arrows. Is this really so. If so, how do I turn it on?
03:41:25 <musasabi> Why is this invalid:
03:41:26 <musasabi> data E a where E :: Show any => any -> E any
03:41:26 <musasabi> e :: E a -> String
03:41:26 <musasabi> e (E x) = show x
03:42:00 <musasabi> GHC complains that there is no Show instance in the case when there clearly is one.
03:42:18 <dons> hmm
03:42:29 <ibid> istr that gadts don't interact well with type classes, but i could be wrong
03:43:12 <musasabi> ibid: I think that was just fundeps and complex things. But this should be as trivial as things can be.
03:43:20 <dons> so you still need to write, e :: Show a => E a -> String
03:43:35 <musasabi> dons: that is impossible in the real code:
03:44:20 <ibid> musasabi: no, i seem to recall that the data object doesn't include the dictionary, or at least istr reading spj say it a half a year or so ago
03:44:35 <musasabi> data E a where Var :: Typeable t => Name -> E t; App :: E (f -> t) -> E f -> E t; etc
03:44:58 <musasabi> ibid: that would explain it. Is it on the list of things to be fixed?
03:45:31 <ibid> iirc there were some problems involved
03:45:32 <dons> yeah, it may an interaction (to be fixed in the System Fc branch)
03:45:39 * ibid tries to look for the message
03:47:06 <ibid> in 29 dec 2005 spj said: "First I have to get GADTs and type classes to play together nicely,
03:47:09 <ibid> which I am hoping to do during Jan/Feb.  Then..."
03:48:03 <dons> there's been lots of gadt patces to the ghc-fc branch, http://www.haskell.org/pipermail/cvs-all/2006-August/thread.html
03:48:04 <lambdabot> Title: The Cvs-all August 2006 Archive by thread
03:48:12 <dons> if its to be fixed, it'd be in there, i think
03:48:27 <musasabi> yes, ghc-fc2 seems to have lots of cool stuff.
03:48:34 <musasabi> ATs, proper FDs etc
03:48:59 <dons> index types, type level functions, ... lots of wacky fun
03:49:09 <xerox> ?yow!
03:49:10 <lambdabot> I want to kill everyone here with a cute colorful Hydrogen Bomb!!
03:49:34 <xerox> -fc2 '
03:49:35 <xerox> ?
03:49:42 <dons> 2nd branch
03:49:58 <musasabi> xerox: fc + resync with head changes.
03:50:03 <xerox> 'fc' ?
03:50:07 <dons> of the GHC System Fc (c == coerce, iirc) branch
03:50:09 <musasabi> System FC
03:50:16 <xerox> I see
03:50:22 <musasabi> See http://research.microsoft.com/~simonpj/papers/ext-f/fc-popl.ps
03:51:27 <xerox> Type equality! I know people that would kill for that.
03:52:47 <SamB> oh ho!
03:58:36 <mux> haha http://www.theregister.com/2006/08/24/chinese_funeral_clampdown/
03:59:27 <ricky_clarkson> Quite unreasonable.
04:11:10 <xerox> G'day Jaak
04:11:16 <xerox> Woops. JaffaCake
04:11:31 <JaffaCake> hiya
04:15:44 <psi> @paste
04:15:44 <lambdabot> http://paste.lisp.org/new/haskell
04:17:10 <lisppaste2> psi pasted "Why the dramatic difference between fib2 and fib3?" at http://paste.lisp.org/display/24677
04:17:48 <psi> I found a neat way of doing memoization (fib2), but slightly modified (fib3) it doesn't work.
04:18:20 <psi> found, as in, found by googling. I didn't come up with it.
04:22:01 <psi> I would've thought both ways of writing equivalent.
04:24:20 <ibid> psi: the latter recalculates the list at every step
04:25:01 <ibid> ... i think
04:25:40 <ibid> hm
04:25:41 <psi> I don't understand why it's any different...
04:27:37 <ibid> hm, in fact, when i try them, they both work instantaneously
04:27:53 <ibid> how do you see a difference? what implementation are you using?
04:28:14 <psi> hugs
04:28:22 <ibid> ok, i tried in ghc
04:28:31 <psi> I guess you'd need to calculate a few more numbers with ghc.
04:28:33 <psi> let me try...
04:29:14 <ibid> ok, with 25 i see what you mean
04:29:15 <psi> hm, with ghc both fib2 and fib3 are instantaneous.
04:29:39 <psi> or are you seeing a difference?
04:30:18 <ibid> with 25 yes
04:30:27 <ibid> i mean, as the maximum
04:30:58 <psi> ah, without optimizations, fib2 wins.
04:31:12 <psi> with -O2 fib2 and fib3 are equal, as far as I can see
04:31:26 <astrolabe> that's odd
04:31:40 <ibid> psi: oh, i think i see what's happening
04:32:21 <ibid> psi: in fib3 the list you construct with map depends on the fib3 parameter and so is regenerated each time you call it
04:32:57 <ibid> psi: but with optimization on, the compiler realizes that the dependency is illusory and treats fib3 and fib2 the same way
04:33:29 <ibid> psi: this is, of course, just a conjecture. i haven't actually looked at the code produced :)
04:34:56 * psi thinkgs
04:35:01 <ibid> (i *think* this is related to the full laziness transformation)
04:35:01 <psi> -g
04:36:22 <psi> but 'n' isn't used in map fib3' [0..].
04:36:34 <ibid> but it is in scope
04:36:55 <ibid> the dependency is illusory, and the compiler realizes this with -O
04:37:01 <psi> I see.
04:37:06 <musasabi> How is Frisby performance as compared to Happy?
04:37:18 <ibid> but as i said... 14:31  <ibid> psi: this is, of course, just a conjecture. i haven't actually looked at the code  produced :)
04:37:45 <ibid> what's frisby?
04:38:02 <psi> right. thanks :)
04:38:57 <SamB> why isn't there a page for class aliases on the Haskell' wiki?
04:39:14 <SamB> @google "class aliases"
04:39:17 <lambdabot> http://www.clarkconnect.com/developer/api/old/Aliases.html
04:39:17 <lambdabot> Title: : Class Aliases
04:39:39 <SamB> ibid: a new parser thingy that JohnMeacham is working on
04:39:44 <ibid> SamB: because you haven't written it yet?
04:40:01 <SamB> ibid: I don't have write access to that wiki silly
04:40:24 <SamB> @google "class aliases" Haskell
04:40:28 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/ticket/101
04:40:28 <lambdabot> Title: #101 (Class Aliases) - Haskell Prime - Trac
04:40:33 <ibid> SamB: not silly, i haven't tried editing it so i didn't know it is restricted unlike wikis in general
04:40:45 <SamB> ibid: oh, well, I read on the frontpage that...
04:41:04 <SamB>     * This wiki: to document consensus. This system is publicly readable, but only committee writable so that we may present it as the "official" output of the committee. If you ever feel that the wiki is not accurate as to the consensus, please alert the committee! See WikiGuidelines.
04:41:14 <ibid> SamB: who reads wiki frontpages? they're almost all boilerplate :)
04:41:23 <SamB> not this one!
04:41:24 <ibid> SamB: ah, sorry
04:41:35 <SamB> I was hoping for links to things!
04:41:40 <ibid> SamB: i thought you were talking about the haskell wiki, not haskell' wiki
04:41:54 <ibid> SamB: the apostrophe is easy to miss
04:42:00 <ibid> SamB: yes, i did know that is restricted
04:42:02 <SamB> ibid: oh heh
04:42:27 <SamB> I wouldn't likely visit the front page of haskellwiki, no ;-)
04:43:14 <ibid> and frankly, the choice of haskell-prime's name is unfortunate, though clever
04:43:26 <SamB> heh
04:43:40 <ibid> adding an apostrophe to a word is a common typo, at least for me
04:43:40 <SamB> it works better when you say it I guess
04:43:55 <SamB> instead of typing an apostrophe
04:45:36 <SamB> hmm
04:46:12 <SamB> @google site:haskell.org GHC darcs
04:46:15 <lambdabot> http://www.haskell.org/~gentoo/gentoo-haskell/portage/dev-lang/ghc-darcs/
04:46:16 <lambdabot> Title: Index of /~gentoo/gentoo-haskell/portage/dev-lang/ghc-darcs
04:46:26 <SamB> @google site:haskell.org GHC "from darcs"
04:46:28 <lambdabot> http://www.haskell.org/ghc/docs/6.4.2/html/building/index.html
04:46:28 <lambdabot> Title: Building and developing GHC
04:52:46 <SamB> odd...
04:52:50 <SamB> Copying patch 419 of 419... done!
04:52:50 <SamB> Applying patch 418 of 418... done.
04:56:02 <ricky_clarkson> SamB: Threaded?
04:56:07 <ndm> it doesn't have to apply the initial patch, i think
04:56:18 <ndm> since its just a list of files and contents, rather than a diff
04:56:22 <ricky_clarkson> Maybe sometimes you'll see: Copying patch 41Applying patch 418 of 418... done.
04:56:26 <ricky_clarkson> 9 of 419...done!
04:57:38 <ndm> that sounds like you have a terminal bug...
04:58:28 <ricky_clarkson> Fatal?  Oh no. ;)
05:10:56 <tibbe> but I am le tired
05:26:13 <tibbe> @quote
05:26:14 <lambdabot> dcnstrct says: even the #lisp people say go with haskell
05:26:55 <tibbe> @quote
05:26:56 <lambdabot> lambdabot says: tERmIN473d
05:27:08 <Lemmih> @quote
05:27:09 <lambdabot> xahlee says: The Haskell Logo is the perfection of logos
05:28:31 <mux> @seen dcoutts
05:28:31 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow and #haskell. I don't know when dcoutts last spoke.
06:01:21 <Phas> @localtyme dons
06:01:23 <lambdabot> Local time for dons is Thu Aug 24 22:59:16 2006
06:03:18 <ricky_clarkson> @localthyme dons
06:03:20 <lambdabot> Local time for dons is Thu Aug 24 23:01:13 2006
06:03:48 <ricky_clarkson> @what bloody time is it for dons?
06:03:49 <lambdabot> I know nothing about bloody.
06:37:58 <Sn4k3> &t
06:38:07 <ihope> ?
06:38:27 <Phas> hi, anyone can help me understanding why if i make a plugin to be loaded for hsplugin i cannot use lybraries in it?
06:38:47 <Sn4k3> anyone able to give me a hand ?
06:38:59 <Sn4k3> Im getting a compile error and I dont understand why
06:39:09 <Lemmih> Phas: You should be able to use libraries from your plugins.
06:39:18 <Lemmih> Sn4k3: Type error?
06:39:18 <Phas> Lemmih: ok
06:39:26 <Sn4k3> Lemmih: is it ok if I paste ?
06:39:33 <Phas> Lemmih: let me make an example
06:39:34 <ihope> How long is it?
06:39:43 <ihope> If it's more than about three lines, use a pastebin.
06:39:49 <Sn4k3> my code is only 6 lines
06:39:52 <Lemmih> @paste
06:39:52 <lambdabot> http://paste.lisp.org/new/haskell
06:39:53 <Sn4k3> pretty basic stuff
06:40:00 <Phas> Lemmih: if i make resource = plugin {outPlug =(\ip msg -> putStrLn (ip ++ ":" ++ msg))}
06:40:03 <Phas> all is ok
06:40:19 <Phas> Lemmih: if i make resource = plugin {outPlug =(\ip msg->appendFile logFile (format ip msg))}
06:40:35 <Phas> Lemmih: i get at runtime
06:40:36 <Phas> unknown symbol `_SystemziIO_appendFile_closure'
06:40:44 <dons> Phas, on the mac?
06:40:46 <lisppaste2> Sn4k3 pasted "error?" at http://paste.lisp.org/display/24681
06:40:46 <Phas> and the program dies
06:41:00 <Sn4k3> http://paste.lisp.org/display/24681
06:41:01 <Sn4k3> there
06:41:08 <Sn4k3> like I said, very basic stuff
06:41:39 <dons> Sn4k3: apa returns an Int, but you're treating it list a [Int]
06:41:45 <dons> in, sum(sx : apa as bs)
06:41:54 <Sn4k3> hmm
06:41:59 <Sn4k3> so how am I supposed to solve it? :S
06:42:05 <Lemmih> Did you mean: sx + apa as bs?
06:42:22 <dons> and don't use 'sum'
06:42:57 <Sn4k3> I wanna add two lists like [2,3] [2,3] = [2*2,3*3] and then sum them to [13]
06:43:28 <Sn4k3> dons: why not ?
06:43:30 <ProfTeggy> (sum . zipWith (*))
06:43:39 <dons> > let f = sum . zipWith (*) in f [1..10] [10..20]
06:43:40 <lambdabot>    Expecting a function type, but found `b'
06:43:41 <lambdabot>    Expected type: [a1] -> [a...
06:43:56 <Sn4k3> wow
06:44:02 <ihope> Sn4k3: lemme see what I can whip up.
06:44:04 <Sn4k3> thats way too advanced for me ;)
06:44:13 <Sn4k3> I only know the basics
06:44:27 <dons> > zip f [1..10] [10..20]
06:44:28 <Phas> @paste
06:44:28 <lambdabot>  Not in scope: `f'
06:44:28 <lambdabot> http://paste.lisp.org/new/haskell
06:44:32 <dons> > zip  [1..10] [10..20]
06:44:33 <lambdabot>  [(1,10),(2,11),(3,12),(4,13),(5,14),(6,15),(7,16),(8,17),(9,18),(10,19)]
06:44:37 <dons> > zipWith (*)  [1..10] [10..20]
06:44:38 <lambdabot>  [10,22,36,52,70,90,112,136,162,190]
06:44:48 <dons> > sum (zipWith (*)  [1..10] [10..20])
06:44:49 <lambdabot>  880
06:45:06 <Sn4k3> I dont wanna use any predefined functions
06:45:11 <Stinger_> > zipWith (,) [1..10] [1..10]
06:45:12 <lambdabot>  [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
06:45:19 <lisppaste2> ihope annotated #24681 with "fixed" at http://paste.lisp.org/display/24681#1
06:45:22 <Sn4k3> I'm studdying for an exam, and we arent allowed to use such
06:45:27 <dons> Sn4k3: but you used 'sum' :)
06:45:34 <Sn4k3> hehe yeah, but that I can define
06:45:42 <Sn4k3> its alright to use them if you can define em
06:45:43 <dons> well, try to use a list comprehension then
06:45:47 <dons> have you met those?
06:45:52 <Sn4k3> nope :/
06:45:52 <sieni> > zip [1..10] [1..10]
06:45:54 <lambdabot>  [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
06:46:02 <Sn4k3> ^^ that one I've seen
06:46:08 <dons> > [ a * b | (a,b) <- zip [1..10] [10..20] ]
06:46:09 <lambdabot>  [10,22,36,52,70,90,112,136,162,190]
06:46:14 <Sn4k3> ah such
06:46:17 <ihope> Sn4k3: try that annotation thing above.
06:46:34 <Sn4k3> the one dons wrote ?
06:46:42 <dons> no, http://paste.lisp.org/display/24681#1
06:46:53 <lisppaste2> LPhas pasted "hsplugin test" at http://paste.lisp.org/display/24683
06:46:54 <sieni> [ a ^ b | (a,b) <- zip [1..10] [10..20] ]
06:47:01 <sieni> uups
06:47:03 <sieni> > [ a ^ b | (a,b) <- zip [1..10] [10..20] ]
06:47:04 <lambdabot>  [1,2048,531441,67108864,6103515625,470184984576,33232930569601,2251799813685...
06:47:07 <Sn4k3> ah ok
06:47:30 <Phas> if someone can help me with this code, it will be very kind
06:47:43 <dons> Phas: hs-plugins on the mac needs a patch in the latest darcs repo
06:47:47 <ihope> sieni: [1..10] and [10..20] have different lengths.
06:47:49 <dons> have you build hs-plugins from darcs?
06:48:00 <Sn4k3> ihope: tnx alot
06:48:04 <Phas> dons: oh
06:48:04 <Sn4k3> much easier
06:48:05 <dons> (the undefined symbol issue was fixed about a week ago)
06:48:15 <Sn4k3> why didnt I think of that :>
06:48:16 <ihope> > 0 * undefined
06:48:18 <lambdabot>  Undefined
06:48:21 <ihope> Mmh.
06:48:27 <ihope> > undefined * 0
06:48:28 <lambdabot>  Undefined
06:48:42 <ihope> Yay for strictness?
06:50:52 <Sn4k3> ihope: your code, how does those _ _ (Wildcards?) work?
06:51:09 <dons> yep, wildcards. it just means ignore that value
06:51:31 <Sn4k3> then how can it check for diff. lengths if it ignores that?
06:51:52 <dons> the different lengths will be a pattern match failure in that code
06:52:07 <Sn4k3> oh ok
06:52:39 <dons> that doesn't mean you shouldn't add cases to handle it :)
06:52:41 <kowey> Sn4k3: maybe you should try working out a small example on paper, say apa [1,2] [2]... that way you see exactly what happens
06:52:52 <Stinger_> as it recurses it takes off one element till it gets to zero, when it reaches [] in one list the match will fail
06:53:10 <Sn4k3> kowey: I think I know what happens
06:53:25 <Sn4k3> I know how recursions work
06:53:33 <dons> ?quit new code
06:54:08 <kowey> good! it gets easier after that
06:54:16 <Sn4k3> yeah :)
06:54:41 <Sn4k3> its sooo easy when you see a code, but its difficult to come up with it yourself :/
06:54:55 <Sn4k3> "why didnt I think of that :("
06:54:57 <dons> ?version
06:54:58 <lambdabot> lambdabot 4p86, GHC 6.5 (OpenBSD i386 )
06:54:58 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
06:55:00 <Phas> dons: thx now it works
06:57:04 <jberg> i need some help with generating combinations of a list. say i have [1, 2, 3] and want to generate all lists with 5 elements using those numbers, can someone point me in the right direction? im very new to haskell and the whole functional style :X
06:57:33 <ihope> Hmm...
06:57:50 <ihope> > sequence (replicate 5 [1, 2, 3])
06:57:50 <lambdabot> Yeah
06:57:51 <lambdabot>  [[1,1,1,1,1],[1,1,1,1,2],[1,1,1,1,3],[1,1,1,2,1],[1,1,1,2,2],[1,1,1,2,3],[1,...
06:58:06 <ihope> Is that what you want, jberg?
06:58:06 <lambdabot> i dunno, what do you got?
06:58:24 * ihope gives lambdabot a funny look
06:58:28 <ingeB0RG> das ist erschreckend....
06:58:30 <Stinger_> oh no the bots become sentient
06:58:31 <jberg> ah, yeah thanks
06:58:40 <ingeB0RG> that's shocking, I mean.
06:58:59 <jberg> is there a haskell library online where i can look up sequence replicate etc?
06:59:10 <ihope> @docs Prelude
06:59:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
06:59:17 <jberg> thank you
06:59:27 <Stinger_> hoogle is pretty good too
06:59:28 <ihope> Hmm...
06:59:39 <Stinger_> @where hoogle
06:59:39 <lambdabot> http://www.haskell.org/hoogle
06:59:51 <Stinger_> hmm I probably should have guessed that :)
07:00:04 <ihope> And @hoogle.
07:00:09 <dons> ?hoogle sequence
07:00:10 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
07:00:10 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
07:00:10 <lambdabot> Language.Haskell.TH.Syntax.sequenceQ :: [Q a] -> Q [a]
07:00:15 <dons> ?index sequence
07:00:16 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
07:00:22 <dons> ?docs Control.Monad
07:00:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
07:00:28 <dons> ?fptools Control.Monad
07:00:28 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
07:00:30 <ihope> @docs Control.Monad.List
07:00:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-List.html
07:00:45 <Stinger_> what does index do?
07:00:47 <ihope> ?fptools Control.Monad.List
07:00:48 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/List.hs
07:00:57 <ihope> Stinger_: it tells you where a given thing is defined.
07:01:33 <Stinger_> how come hoogle gives a lot less than index
07:01:39 <Stinger_> just to limit spam?
07:01:49 <dons> hoogle looks up functions with the name 'sequence'
07:01:59 <dons> while index tells you everwhere sequence is visible from
07:02:11 <dons> ?hoogle a -> [a]
07:02:11 <Stinger_> ah
07:02:12 <lambdabot> Prelude.repeat :: a -> [a]
07:02:12 <lambdabot> List.intersperse :: a -> [a] -> [a]
07:02:12 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
07:02:19 <dons> ?hoogle+
07:02:19 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
07:02:19 <lambdabot> Prelude.replicate :: Int -> a -> [a]
07:02:19 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
07:02:28 <dons> you can also search on types
07:04:41 <Sn4k3> ihope: how come that code doesnt work with the type Float ?
07:05:28 <Sn4k3> i.e. if you define it to take two lists with floats and return a float
07:05:58 <dons> ?type let f [] [] = 0 ; f (x:xs) (y:ys) = x*y + f xs ys in f [1..10::Float] [2..11::Float]
07:06:00 <lambdabot> Float
07:06:06 <dons> > let f [] [] = 0 ; f (x:xs) (y:ys) = x*y + f xs ys in f [1..10::Float] [2..11::Float]
07:06:07 <lambdabot>  440.0
07:06:20 <dons> ?type let f [] [] = 0 ; f (x:xs) (y:ys) = x*y + f xs ys in f [1..10] [2..11]
07:06:22 <lambdabot> forall a. (Enum a, Num a) => a
07:06:31 <jberg> hm what does sequence do?
07:06:41 <dons> ?type sequence
07:06:43 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
07:06:56 <Stinger_> are floats in enum? : /
07:07:02 <dons> it takes a list of monadic actions, and forces them, giving you a list of results
07:07:13 <ihope> Sn4k3: what code
07:07:18 <Sn4k3> sec.
07:07:26 <ihope> apa should work with floats.
07:07:32 <jberg> so how does sequence work in sequence (replicate 5 [1, 2, 3]) where's the monadic action here?
07:07:32 <Sn4k3> it doesnt
07:07:40 <dons> sure it does, see above.
07:07:46 <dons> did you slip in a type constraint somewhere?
07:07:52 <Sn4k3> ihope: Program error: different lengths
07:07:57 <dons> an Int annotation?
07:08:14 <ihope> Sn4k3: what's the thing you're trying to use it with?
07:08:35 <Stinger_> jberg list is a monad
07:08:36 <Sn4k3> Main> apa [1.1,3.4] [1.3,3.3]
07:08:37 <Sn4k3> Program error: different lengths
07:08:38 <ihope> jberg: well, with lists, sequence gives you every combination of the given list. It's sort of hard to explain... lemme see here.
07:08:40 <Sn4k3> ihope: that
07:09:16 <ihope> Sn4k3: hmm... and you're defining it exactly as I did?
07:09:37 <ihope> > (length [1.1,3.4], length [1.3,3.3])
07:09:38 <lambdabot>  (2,2)
07:09:41 <ihope> Hmm.
07:10:11 <ihope> > sequence [['a'..'z'],[a,e,i,o,u,y],['a'..'z']]
07:10:12 <lambdabot>  Not in scope: `y'
07:10:36 <Stinger_>  > sequence [['a'..'z'],"aeiouy",['a'..'z']]
07:10:38 <Sn4k3> hmm, now it does
07:10:43 <Stinger_> > sequence [['a'..'z'],"aeiouy",['a'..'z']]
07:10:44 <lambdabot>  ["aaa","aab","aac","aad","aae","aaf","aag","aah","aai","aaj","aak","aal","aa...
07:10:46 <Sn4k3> ihope: I rearanged the code a bit
07:10:49 <ihope> > sequence [['b','c','d'],['a','e'],['t','s','w']]
07:10:50 <lambdabot>  ["bat","bas","baw","bet","bes","bew","cat","cas","caw","cet","ces","cew","da...
07:11:06 <LimbicRegion> Build question:  I downloaded ghc-6.5.20060823-i386-unknown-mingw32.tar.gz, read INSTALL, and attempted to run ./configure but there is no configure anywhere in that tarball - am I missing something obvious (GHC neophyte fwiw)
07:11:08 <ProfTeggy> Sn4k3, the order of clauses is important
07:11:22 <ProfTeggy> The cases are matched top-down
07:11:36 <ihope> Putting 'apa _ _ = error "different lengths"' anywhere but the bottom is Bad(TM).
07:11:36 <Sn4k3> apa (a:as) (b:bs) = a*b + apa as bs
07:11:36 <Sn4k3> apa [] [] = 0
07:11:37 <Sn4k3> apa _ _ = error "different lengths"
07:11:52 <Sn4k3> if I put those 2 last lines on top of line 1 then it doesnt work
07:11:55 <Sn4k3> didnt know that
07:12:01 <ProfTeggy> Now you know
07:12:07 <Sn4k3> yeah, but I dont understand why
07:12:17 <ProfTeggy> Pragmatics
07:12:30 <ihope> Well, if you have the apa _ _ definition above the apa (a:as) (b:bs) definition, then the apa _ _ definition will be tried before the other one.
07:12:31 <Stinger_> pattern matching is attempted in the order in the file *dont quote me on this*
07:12:41 <Sn4k3> ihope: ah, I see
07:12:46 <sjanssen> Stinger_: that is correct
07:12:50 <Sn4k3> tnx
07:12:55 <ihope> apa _ _ will always match, so if it gets past apa [] [], it will always give that error.
07:13:11 <Stinger_> ah cool didnt know if there was some weird cases where it would be different or not
07:13:33 <Stinger_> though from what I've seen they've kept the language pretty consistent
07:13:47 <dons> sjanssen: is everything in the soc-fps repo now?
07:13:49 <ihope> Well, lemme go install this expansion pack for The Sims 2 :-)
07:14:47 <LimbicRegion> I hate to sound needy but does anyone have any ideas on my build problem?
07:14:50 <sjanssen> dons: yep
07:16:05 <dons> ok cool. want to mail me a summary of things, so I can write up the report?
07:16:19 <sjanssen> yeah, sure
07:17:16 <dons> looks good. we can plan to move the Vector stuff into the unstable fps branch, then, perhaps?
07:17:42 <dons> LimbicRegion: it sounds strange
07:17:51 <sjanssen> dons: yes, I'd like to do that
07:18:03 <dons> it's possible that windows configures differently, though. I'm not sure.
07:18:05 <sjanssen> I also want to try porting Streams fusion to Vectors
07:18:11 <dons> yes, certainly
07:18:27 <dons> that would be the idea once its in unstable
07:18:59 <dons> you might want to pull some patches from the fps stable branch, btw.
07:19:06 <dons> its had some updates, and gone into ghc
07:19:41 <dons> now, someone was asking for a ByteString Float type, the other day.
07:19:43 <dons> we have the answer now :)
07:21:49 * dons . sleep
07:30:53 <LimbicRegion> thanks dons - I had to wander off for a bit ($work)
07:34:15 <Phas> dons: i really want to do something for Yi, because i think there's needing if a good sobstitute for emacs
07:34:21 <Phas> dons: how can I help?
07:37:07 <LimbicRegion> in any case dons (and all) the file size for the Win32 has dropped 20MB from the beginning of the month till now so perhaps it is a bad snapshot (despite the build log appearing to be ok)???
07:37:43 <LimbicRegion> audreyt suggests that the last known good version then is http://www.haskell.org/ghc/dist/current/dist/ghc-6.5.20060819-i386-unknown-mingw32.tar.gz
07:43:38 <mux> are there planned/existing extensions to Haskell that avoid having to write such things:
07:43:41 <mux> (Eq a, Eq b) => Eq (a, b)
07:43:42 <mux> etc
07:43:43 <mux> ?
07:43:46 <mux> (Eq a, Eq b, Eq c) => Eq (a, b, c)
07:43:48 <mux> (Eq a, Eq b, Eq c, Eq d) => Eq (a, b, c, d)
07:44:02 <mux> those always make me frown, considering how poweful haskell is
07:45:21 <norpan> mux: you can sort-of do it using template haskell
07:45:44 <mux> yep, of course, but I meant a solution that is fully implemented in the language
07:46:04 <norpan> well, template haskell may be?
07:46:41 <mux> let me rephrase this
07:46:58 <mux> a solution that is inside the language itself
07:47:26 <mux> obviously with any templating stuff you could generate the appropriate lines, but that doesn't sound too satisfactory
07:47:53 <mux> I was wondering if maybe there was something planned for this in Haskell'
07:48:47 <LimbicRegion> WRT the snapshot build of Win32 not working - it is definately a problem with the snapshot since the snapshot from the 19th works fine
07:48:57 <LimbicRegion> not sure who the right person to inform on this is though so I am just throwing it out to the channel
07:49:32 <norpan> mux: i don't really see how to do it
07:49:57 <norpan> would you have some kind of special case where all types in the tuple are in the same class or what?
07:50:47 <Philippa_> mux: it's hard to do without it being a hack
07:50:59 <Philippa_> you need polymorphic kinds, I guess
07:52:11 <Philippa_> actually no, even that doesn't let you check the constraints on the individual items
07:52:53 <Philippa_> (necessary to map a function across them and thus do what you want)
07:53:12 <mux> norpan: I have no idea either, if I had, I guess I would have submitted it to the Haskell' guys :)
07:55:12 <mux> btw, this was only an example
07:55:25 <mux> I quite often came accross such hugely repetitive code
07:56:34 <Philippa_> yeah, I was thinking of a tuple class that supported a variant of map
07:56:50 <Philippa_> would that handle it if it could be made to work? (which is likely non-trivial)
08:06:34 <mux> I wouldn't know
08:12:02 <Philippa_> well, what other boilerplate cases are causing problems?
08:12:11 <Philippa_> I suspect Generic Haskell might be a solution?
08:16:37 <araujo> morning!
08:17:59 <kolmodin> morning araujo :)
08:18:08 <kolmodin> @localtime araujo
08:18:09 <lambdabot> Local time for araujo is Thu Aug 24 11:16:12
08:19:28 <araujo> kolmodin!!!!
08:19:33 <araujo> :-)
08:19:41 <araujo> how you doing bud?
08:21:23 <kolmodin> just fine. done at my job for today
08:21:54 <kolmodin> so considerably better than one hour ago :)
08:21:58 <kolmodin> and you?
08:23:09 <araujo> i just woke up , next to eat something, *hungry* :-}
08:23:30 <araujo> kolmodin, i hope to get some haskell coding today too :-D
08:25:02 <kolmodin> I'm sure you will :) I know I will! :D
08:29:50 <Lemmih> @seen CosmicRay
08:29:50 <lambdabot> I saw CosmicRay leaving #haskell-blah, #darcs and #haskell 6 days, 17 hours, 28 minutes and 25 seconds ago, and .
08:31:20 <sek> @seen sek
08:31:21 <lambdabot> You are in #haskell. I last heard you speak just now.
08:33:17 <ricky_clarkson> Hah.
08:37:10 <kowey> my HUnit tests are returning errors where they should be returning failures... any ideas why?
08:47:12 <kowey> oh (answering myself), maybe this is related : http://cvs.haskell.org/trac/ghc/ticket/476
08:47:14 <lambdabot> Title: #476 (HUnit treats failures as errors) - GHC - Trac
08:52:06 <norpan> a failure is not an error? :)
08:52:26 <kowey> :-) depends on perspective
08:53:53 <ricky_clarkson> Failures in test cases may be on purpose.  For example, I often write a test, make it fail, then write the code to make it pass.  *dribbles elsewhere about something else irrelevant*
08:54:23 <kowey> for me, giving a wrong result is a failure; my program crashing is an error
08:54:39 <kowey> well, this is haskell, programs don't crash
09:31:22 * mux summons dcoutts 
09:32:58 * ndm predicts a yarr
09:36:19 <svref> what's the name of the function f such that f 12 [10..20] -> 2?  I.e. f finds the position of an element inside a list?
09:36:51 <roconnor> @hoogle a -> [a] -> Int
09:36:53 <lambdabot> No matches, try a more general search
09:36:59 <roconnor> @hoogle a -> [a] -> b
09:37:01 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
09:37:01 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
09:37:01 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
09:37:07 <roconnor> hmm
09:37:07 <lispy> svref: find?
09:37:11 <roconnor> @type find
09:37:16 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
09:37:19 <lispy> @hoogle find
09:37:20 <Igloo> elemIndex
09:37:20 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
09:37:20 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
09:37:20 <lambdabot> List.findIndices :: (a -> Bool) -> [a] -> [Int]
09:37:28 <lispy> ah, find Index?
09:37:31 <roconnor> @tpe elemIndex
09:37:32 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
09:37:41 <roconnor> oh, of course
09:37:48 <roconnor> @hoogle a -> [a] -> Maybe Int
09:37:49 <lambdabot> List.elemIndex :: Eq => a -> [a] -> Maybe Int
09:37:49 <lambdabot> Data.List.elemIndex :: Eq a => a -> [a] -> Maybe Int
09:38:18 <roconnor> I guess hoogle can't read my mind.
09:38:54 <ndm> it should have done
09:39:11 <svref> Hugs keeps complaining: ERROR - Undefined qualified variable "List.elemIndex"
09:39:12 <ndm> version 4 of hoogle should get that
09:39:27 <ndm> svref: have you imported List?
09:39:29 <ndm> :l List
09:39:34 <ndm> then List.elemIndex
09:43:31 <svref> So in fact "import" means more "load extension library", as well as "pollute my namespace".
09:45:03 <int-e> import qualified comes to rescue with the namespace pollution
09:45:20 <int-e> import qualified Data.List as L ...
09:45:36 <int-e> then use L.<symbol from Data.List you want to use>
09:45:46 <svref> thanks.
09:46:21 <svref> I'm suprised that "List" isn't loaded by default, seeing as its probably used by every implementation...
09:47:48 <ndm> the most useful list functions are in teh prelude, head tail etc.
09:53:20 <Sn4k3> anyone have any online material where I can read about creating your own data (algebraic) types and such?
09:53:50 <ricky_clarkson> @roman numerals
09:53:50 <lambdabot> Unknown command, try @list
10:00:50 <ths> dcoutts: In case you want to give the mips patch I sent to the users list a try on mips64, n32/n64 don't need the clobber of $28 in StgRun, and n64 would need a dla instead of la at the start of that assembly chunk.
10:00:52 <ibid> Sn4k3: any tutorial should cover it
10:01:25 <ths> dcoutts: Also, building registerised on IRIX may need some more work.
10:03:42 <int-e> @seen dcoutts
10:03:43 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow and #haskell. I don't know when dcoutts last spoke.
10:05:08 <syntaxfree> I give up trying to learn Parsec for now. I just need a haskell function that removes (X|HT)ML tags from strings.
10:05:41 <roconnor> What about HTML comments?
10:06:29 <roconnor> And entities?
10:06:36 <roconnor> And marked sections.
10:06:47 <syntaxfree> HTML comments are tags of sorts.
10:06:57 <syntaxfree> I need to remove text between <angly brackets>
10:06:59 <syntaxfree> Just that.
10:07:08 <roconnor> oh, that's much simler.
10:07:49 <roconnor> In CDATA elements, such as script, <foo> is actually part of the data stream, and isn't a tag.
10:07:55 <Sn4k3> ibid: are they easy to understand?
10:08:01 <Sn4k3> I mean, basic stuff
10:08:12 <syntaxfree> CDATA elements?
10:10:19 <roconnor> most HTML elements are PCDATA, which means parsed character data.
10:10:38 <roconnor> As the name suggests the data element is parsed for other elements.
10:11:03 <roconnor> But some elements such as SCRIPT have CDATA content, for character data.
10:11:20 <roconnor> For these elements all parsing is disabled, save for looking for </
10:11:43 <dottedmag> syntaxfree: <data><![CDATA[blahblah <<<< """ >/>/><<<''']]></data>
10:12:24 <syntaxfree> are you talking about Parsec?
10:12:27 <roconnor> Parsing HTML isn't very fun.
10:12:36 <roconnor> syntaxfree: I'm talking about HTML.
10:12:50 <roconnor> Parsing HTML isn't very fun, that is why no one actually does it ;)
10:13:15 <syntaxfree> oh well.
10:13:29 <dottedmag> roconnor: especially given that approximately 0% of Internet is valid HTML :)
10:13:36 <syntaxfree> I just need a Haskell function that removes text between angly brackets from strings.
10:13:44 <roconnor> dottedmag: doesn't my homepage count?
10:14:03 <dottedmag> roconnor: that's why approximately
10:14:04 <roconnor> syntaxfree: ;)
10:14:27 <syntaxfree> @type ;)
10:14:28 <lambdabot> parse error on input `;'
10:14:33 <roconnor> syntaxfree: how hard is it to write two mutually recursive functions to do that?
10:14:44 <syntaxfree> umm.
10:14:45 <syntaxfree> that's a good tip.
10:15:04 <syntaxfree> I'll try to hack something up.
10:15:49 <syntaxfree> I know how to do it already, actually.
10:15:55 * roconnor draws a two state automoton.
10:16:39 <roconnor> the real question is, what is the shortest haskell program that does it?
10:17:44 <syntaxfree> cool.
10:17:45 <syntaxfree> removeLeft (x:xs) = if' (x=='<') (removeRight xs) (removeLeft xs)
10:17:45 <syntaxfree> removeRight (x:xs) = if' (x=='<') (removeLeft xs) (removeRight xs)
10:17:47 <syntaxfree> thanks!
10:18:02 <roconnor> @type if'
10:18:03 <lambdabot> Not in scope: `if''
10:18:14 <syntaxfree> ah, I define if' in my personal library.
10:18:17 <int-e> @seen Cale
10:18:18 <lambdabot> I saw Cale leaving #haskell 20 hours, 22 minutes and 25 seconds ago, and .
10:18:20 <syntaxfree> if' a b c = if a then b else c
10:18:27 <roconnor> shouldn't there be a > in there somewhere?
10:18:35 <roconnor> time for quickcheck.
10:18:36 <syntaxfree> yes, in removeRifbt.
10:18:58 <roconnor> and there should be some characters output.
10:19:03 <roconnor> I give it a 3/10
10:19:04 <int-e> syntaxfree: if' (x=='<') removeRight removeLeft xs
10:19:21 <int-e> syntaxfree: but what's the advantage of using if' over if there?
10:19:40 <syntaxfree> less typing.
10:19:52 <int-e> less readability.
10:20:09 <int-e> (not in this case, but if the expressions become more complex that will become an issue)
10:20:19 <syntaxfree> if' is flippable, too.
10:20:27 <syntaxfree> That also leads to less typing
10:20:44 * roconnor just notices that syntaxfree isn't syntaxninja.
10:20:44 <syntaxfree> roconnor: what do you mean "some characters output"?
10:20:50 <syntaxfree> hahaha
10:21:04 <syntaxfree> ah, yes.
10:21:06 * musasabi likes to have more special purpose conditional operators, if' just does not seem to help in very many places.
10:21:09 <syntaxfree> removeRight (x:xs) = if' (x=='>') (removeLeft xs) (x: removeRight xs)
10:21:11 <roconnor> syntaxfree: At the moment, your code consumes a bunch of data and crashes at the end of the list.
10:21:23 <syntaxfree> I didn't want to paste many lines with base cases.
10:21:40 <roconnor> okay.
10:22:00 <roconnor> still, outputting more than "" would be good.
10:22:02 <roconnor> ;)
10:32:43 <lisppaste2> syntaxfree pasted "final version, if anyone cares" at http://paste.lisp.org/display/24695
10:32:58 <ibid> Sn4k3: depends on which you choose :)
10:33:48 <roconnor> seems reasonable.
10:35:23 <Sn4k3> ibid: hit me with a good one then :)
10:35:26 <Sn4k3> if you know of any
10:41:35 <ibid> Sn4k3: people say good things about http://www.cs.utah.edu/~hal/htut/
10:41:36 <lambdabot> Title: Yet Another Haskell Tutorial
10:42:53 <Sn4k3> ibid: cheers
10:43:06 <ricky_clarkson> I say a bad thing.
10:43:25 <ricky_clarkson> In WinHugs, the instructions for 'map toUpper "hello world"' fail.
10:43:30 <ricky_clarkson> And Char.toUpper..
10:43:41 <ricky_clarkson> You have to do :l Data.Char first.
10:44:37 <ibid> ricky_clarkson: where is that?
10:45:59 <ricky_clarkson> Page 18.
10:46:07 <ricky_clarkson> 3.3.2
10:46:50 <ibid> ok
10:47:01 <ibid> did you report the bug? :)
10:48:16 <ricky_clarkson> Yes.
10:48:21 <ricky_clarkson> I emailed Hal.
10:48:28 <ibid> ok
10:49:50 <ibid> good :)
10:52:47 <svref> hat is annoying.  Is there really no way to put print statements in a program for the purpose of debugging?
10:53:06 <swiert> svref: Test.Debug has "trace"
10:54:07 <int-e> @index trace
10:54:08 <lambdabot> Debug.Trace
10:54:15 <aleko> newbie question: in the State monad, the get function is this: get = State $ \s -> (s, s), so it would appear that it's a lambda wrapped in a State, yet when it's called from a do block, it returns the value stored in the state.  how did it go from lambda to value?
10:54:20 <int-e> what's Test.Debug?
10:54:30 <aleko> i've looked all over, but can't find an explanation
10:55:45 <int-e> aleko: the do block gets desugared into applications of >> and >>= ... now for the State monad these extract the closure and apply it to the current state, then wrap it into the State constructor again.
10:56:40 <int-e> aleko: and finally runState unwraps the complete thing and applies it to the initial state.
10:56:53 <svref> swiert: hallejuah!
10:57:06 <aleko> got it!  saw the runState in the (>>=) definition!
10:57:11 <ndm> @docs Test.Debug
10:57:11 <lambdabot> Test.Debug not available
10:57:15 * aleko hugs int-e
10:57:49 <aleko> i've been having a hard time with monads, but now i feel better
10:58:16 <newsham> man, you must be thick,  monads are so super simple!  ;-)
10:58:26 <newsham> congrats.
10:58:57 <aleko> all i need to do now is understand transformers, and arrows, and combinators, and ...
10:59:20 <ndm> i don't understand monads, and i've been doing haskell for 4 years now...
10:59:27 <aleko> heh
10:59:48 <ndm> combinators are easy, they are just functions which people like to obfustcate by using symbols rather than ascii, usually
10:59:53 * int-e still thinks the main problem with monads is that they don't really do anything by themselves, they just provide glue.
11:00:30 <mwc> ndm, monads and arrows and all that clicked for me when I took a group theory course and realized they're just abstract language for many different concrete cases
11:00:34 <int-e> each interesting monad comes with some other basic operations. State has get and put (I think). Reader has local and ask. etc.
11:00:36 <ValarQ> ?seen dons
11:00:36 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 3 hours, 38 minutes and 52 seconds ago.
11:00:55 <ndm> mwc: we have no group theory course :()
11:01:11 <mwc> int-e, list monad? I think it's just the basic bind/join/return
11:01:43 <aleko> mwc: list monad applies bound functions to all values in the list
11:01:49 <aleko> i think
11:02:19 <svref> How do I write this without syntax error: f :: (Eq a) (Show a) => a -> Int   ?
11:02:36 <newsham> (Eq a, Show a) =>   ?
11:03:12 <int-e> mwc: the list monad comes with `mplus` (append)
11:03:24 <mwc> ah right, it's a MonadPlus
11:03:30 <int-e> mwc: and without that it'd be boring.
11:05:23 <int-e> mwc: alternatively you could say that (:) is a funny monad operator for that monad.
11:09:54 <aleko> is that guy who wanted the html tag stripper still around? i wrote one before i ate breakfast
11:10:16 <vegai_> that's sad.
11:10:30 <mwc> int-e, yeah, and I'd also accept that append and : are equivalent, at least algebraically
11:10:34 <aleko> what is?
11:10:43 <mwc> x : xs = append (return x) xs
11:12:05 <vegai_> son of a...
11:13:52 <aleko> hmm... there's vegai and there's vegai_
11:14:12 <vegai_> not for long.
11:14:33 <aleko> both from the same hostname
11:14:52 <aleko> to resolve this... fight to the death!
11:15:09 <svref> The debugging tool I want, but can't find in haskell, takes a list of top-level functions.  It prints out their arguments when they're called, and prints out their results when they return.
11:15:35 <aleko> svref: you could write one
11:15:35 <svref> preferably with indentation to show the nesting.
11:15:43 <svref> *I* couldn't
11:16:07 <svref> hat is driving me crazy, half of it doesn't work at all, the other answers questions I don't care about
11:24:45 <swiert> svref: check out Buddha. That may be pretty close to what you described.
11:26:02 <swiert> http://www.cs.mu.oz.au/~bjpop/buddha/
11:26:02 <lambdabot> Title: A declarative debugger for Haskell 98
11:26:11 <mux> could anyone give some clue about a crash I'm having with gtk2hs?
11:26:27 <svref> swiert: thanks
11:26:33 <mux> when I add too much items to my TreeView, it crashes
11:26:51 <vegai> what's too much?
11:27:09 <mux> around 800 short strings
11:27:17 <mux> I had it work at 750 or so
11:27:38 <mux> with that much the program is "only" ~45M resident
11:28:23 <vegai> auch.
11:29:26 <mux> yeah that's kinda big and sucky, but at least it shows that it's not an out-of-memory problem
11:31:52 <mux> the TreeView is a simple two-column one with a ListStore as the backend, for what it's worth
11:32:01 <mux> one of the columns is always empty
11:32:50 <mux> I really wish Duncan was here :-)
11:34:09 <mux> oh, the core file shows that the stack is completely corrupted or that gdb shits itself as usual
11:34:22 * mux giggles
11:36:55 <mux> vegai: there's something else I'm wondering, maybe you could help with that one - do you know if it's OK to use forkIO in conjunction with gtk2hs or are there some glib wrappers that one should use to get "glib" threads?
11:37:22 <heatsink> There was a webpage about using gdb with ghc-compiled files http://cvs.haskell.org/trac/ghc/wiki/DebuggingGhcCrashes
11:37:25 <lambdabot> Title: DebuggingGhcCrashes - GHC - Trac
11:37:50 <mux> thanks, I'll take a look at it, but I think this core file is probably useless
11:38:05 <ndm> mux: gtk2hs + -threaded is "unsupported", and in fact regularly crashes
11:38:17 <mux> okay, that's what I thought
11:38:23 <mux> (but it's not my problem, I'm not using forkIO)
11:38:33 <mux> it was just a question for future stuff :-)
11:38:53 <ndm> i am actively bugging dcoutts and simonmar to get them to fix it, but it sounds copmlex
11:40:10 <mux> I suppose it can very easily be so yeah
11:40:16 <mux> don't know the glib api for threads
11:40:20 <mux> always just used pthread
11:40:44 <ndm> the problem is that gtk wants all calls to be made from the same thread
11:40:48 <eivuokko> It doesn't work even if you use bound threads, and always call gui from the same thread?
11:40:52 <ndm> and ghc migrates threads between worker threads
11:41:04 <ndm> eivuokko: bound threads? are they supported in Haskell?
11:41:22 <ndm> with winhaskell, its flawless on one machine, and on another regularly locks up instantly
11:41:26 <eivuokko> They are supported in ghc, and they are in concurrency spec iirc.
11:41:39 <mux> do you mean forkOS?
11:41:41 <eivuokko> Bound meaning haskell thread is ran on OS thread.
11:41:48 <mux> yeah, ok
11:41:50 <eivuokko> forkOS is one way to get bound thread.
11:42:02 <ndm> i guess its more complex
11:42:14 <ndm> and you do really want to be able to call gtk on multiple threads
11:42:21 <mux> considering glib has its own api for threads, yeah
11:42:50 <mux> it ends up calling into the pthread API, but depending on the amount of decoration it puts around, it could be tricky to have it working with haskell
11:43:05 <TauPan> Hello. I have a kind of a newbie question: Is there a haskell interpreter provides a similar integration of haskell and java as sisc (sisc.sourceforge.net) provides for scheme and java, i.e. it allows java objects and methods to be used from scheme code and scheme objects and procedures to be used from within java.
11:43:24 <TauPan> *that provides
11:43:50 <ndm> TauPan: in a word, no
11:44:55 <ndm> it would be nice, but i think the concepts are two different
11:45:28 <TauPan> which two concepts?
11:45:36 <ndm> lazy vs strict evaluation
11:45:42 <ndm> pure vs impure
11:45:48 <ndm> functions vs objects
11:46:08 <ndm> probably the last one would be the hardest to get over
11:46:08 <mux> suckyness vs cleanliness
11:46:09 <mux> oops!
11:46:11 <mux> :-)
11:46:18 <sieni> TauPan: lambada?
11:46:24 <mux> and I meant the other way around even
11:46:34 * mux crawls back under a rock
11:46:35 <sieni> TauPan: http://citeseer.ist.psu.edu/463225.html
11:47:03 <sieni> TauPan: http://research.microsoft.com/~emeijer/Papers/Lambada.pdf#search=%22lambada%20haskell%22
11:47:15 <TauPan> sieni: have you worked with lambada? I've looked at their website and the version number (0.1) and the last release date seemed to indicate both immaturity and lack of support.
11:47:21 <sieni> no
11:47:42 <sieni> maybe you could develop it further ^_^
11:47:53 <TauPan> yeah, basically that's why I'm asking on an irc channel, to find out what people have been using succesfully
11:48:12 <TauPan> I could, if it was worth the effort.
11:48:14 <sieni> I haven't heard anyone using something comparable to sisc
11:48:44 <TauPan> ok, that's the kind of information I was looking for. Thank you! :)
11:49:36 <TauPan> the lambada concept seems to be quite similar to the sisc concept, with the slight difference that it's for compiled code, which is a slight disadvantage for me
11:50:17 <sieni> maybe you could implement a haskell interpreter in r5rs scheme ;-)
11:50:26 <TauPan> *lol*
11:51:05 <TauPan> I'm quite sure that my haskell knowledge is too poor for that kind of project :)
11:52:22 <sieni> maybe yhc (http://www-users.cs.york.ac.uk/~ndm/yhc/) could be tuned for usage with java
11:52:23 <lambdabot> Title: yhc - York Haskell Compiler
11:52:32 <TauPan> I'm thinking of integrating a functional language with a form of higher order petri nets, in a petri net development engine coded in java.
11:52:37 <ndm> sieni: it already has a Java runtime
11:52:42 <ndm> so you could easily go that way
11:52:46 <ndm> and it generates .NET bytecode
11:52:53 <sieni> ndm: cool
11:53:10 <ndm> it also has a python runtime for those who are crazy :)
11:53:17 <sieni> TauPan: check yhc then, it's at least under active development
11:53:45 <ndm> TauPan: but a warning, it wasn't really designed for what you are asking, but might be tweakable to it
11:54:06 <ndm> you can however load a Haskell module and run it pretty easily, all from Java, and inspect the result of a function etc.
11:54:19 <TauPan> hmm
11:56:00 <TauPan> ndm: but there's no way to call java code from haskell, or could there be a monad for that purpose?
11:56:29 <ndm> TauPan: depends what you want - if you were to modify the runtime slightly, you could add a function name that got intercepted and run easily enough
11:56:36 <ndm> but its not easy to do
11:56:49 <ndm> no need for monads, unless you want them, because you're at the virtual machine level
11:57:07 <TauPan> ah
11:57:14 <lispy> well, you could call java via JNI
11:57:18 <ndm> its not been done, yet, but it should be doable
11:57:25 <lispy> i've tohught about this...seems like a waste tho
11:58:03 <lispy> oh, perhaps this is a yhc specific discussion
11:58:11 <lispy> in that case, my knowledge is worthless
12:55:55 <int-e> aww, ghci doesn't like linking to weak symbols.
13:06:38 <cschneid_work> is there a good example of when you'd want to use foldr over foldl?
13:06:49 <TauPan> ok, thanks for your help... I'll continue wasting time elsewhere now :)
13:07:20 <Igloo> cschneid_work: Any time you want to return some result before you reach the end of the list
13:07:46 <Igloo> cschneid_work: e.g. concat is defined in terms of foldr, which makes it lazy and linear, rather than foldl, which would make it strict and quadratic
13:07:47 <cschneid_work> how so? wouldn't foldr start at the far right or am I getting the direction backwards
13:09:19 <int-e> (++) doesn't need it's right argument before its first argument isn't consumed.
13:09:46 <Igloo> cschneid_work: foldr (++) [] (x:xs) = x ++ foldr (++) [] xs
13:11:07 <int-e> *is consumed*
13:11:13 <sieni> cschneider: for example subtraction and division associate to the left, so you need to use left fold to compute the result from the list. Similarly exponentiation is right-associative.
13:11:28 <sieni> > foldr (^) 3 [3,3]
13:11:30 <lambdabot>  7625597484987
13:11:35 <sieni> > foldl (^) 3 [3,3]
13:11:36 <lambdabot>  19683
13:11:38 <Igloo> cschneid_work: Whereas foldl (++) [] (x:xs) = foldl (++) ([] ++ x) xs which can't return any result yet
13:11:41 <sieni> > 3^3^3
13:11:42 <lambdabot>  7625597484987
13:12:22 <sieni> foldl (-) 1 [2,3]
13:12:25 <sieni> > foldl (-) 1 [2,3]
13:12:26 <lambdabot>  -4
13:12:30 <sieni> > foldr (-) 1 [2,3]
13:12:31 <cschneid_work> interesting, with the right vs. left assoicativity
13:12:31 <lambdabot>  0
13:12:39 <sieni> > 1-2-3
13:12:40 <lambdabot>  -4
13:12:57 <heatsink> cschneid_work: You mentioned foldr "starting at the right".  In a way it does: it puts the tail of the list on the inside of the result expression, which is why it can be lazy as int-e described.
13:16:35 <cschneid_work> so foldl (+) 0 [1,2,3] would be (((0+1)+2)+3)? and foldr with the same args would be (0+(1+(2+(3+0))))?  Making sure I do have the definitions straight
13:17:15 <sieni> cschneid_work: no, you have one zero too many in the foldr thingie
13:17:26 <cschneid_work> sorry, no 0 at the beginning
13:17:44 <cschneid_work> just (1+(2+(3+0))) right
13:18:05 <sieni> but since (+) and (*) are associative, it doesn't matter which fold you use as far as the end result is concerned
13:18:25 <cschneid_work> correct, I'm just using it as an example to help me clear up the implicit parens that get added in
13:21:33 <cschneid_work> anyway, thank you for the help clearing up some of this, the lazy vs. strict distinction is one I hadn't made, need to think it over a bit I think
13:44:01 <waern> who should I talk to if I want to put a Trac page for my project on hackage.haskell.org/trac?
13:53:15 <mnislaih> how is your project going waern
13:53:37 <mnislaih> you were working on haddock right ?
13:53:54 <waern> mnislaih, yep.. it's going fine
13:54:12 <waern> mnislaih, I'll send a status report to the Haskell list soon
13:54:38 <mnislaih> did you miss a Typeable instance for HsExpr
13:54:48 <waern> mnislaih, I'm having problems with some GHC api bugs now though
13:55:18 <waern> mnislaih, no.. I haven't dealt with HsExpr that much
13:55:32 <waern> mnislaih, why do you want it?
13:55:37 <mnislaih> curious
13:55:38 <eivuokko> waern, I think SyntaxNinja admins trac at hackage.haskell.org
13:55:46 <waern> ah
13:55:57 <mnislaih> I have myselff worked with HsExpr a bit
13:56:06 <mnislaih> and missed the typeable stuff
13:56:16 <waern> I've never even used Typable :)
13:56:58 <waern> mnislaih, I forgot which project you worked on
13:57:03 <mnislaih> it'd make a lot of sense for HsExpr to offer it actually
13:57:21 <mnislaih> I am working on the ghc.debugger waern
13:57:33 <waern> mnislaih, ah! nice work
13:57:42 <mnislaih> have you seen it ?
13:57:46 <mnislaih> tried it ?
13:57:50 <waern> yep, I saw the movie :)
13:57:53 <waern> not tried it yet
13:58:04 <mnislaih> it's a client of ghc-api too
13:59:49 <mnislaih> arf. I hope someone will play with the debugger before the release candidate
14:00:41 <mnislaih> I need some feedback (i.e. bug) reports
14:01:15 <waern> atleast you got your modifications into the release candidate.. I don't think mine are mature enough yet (well actually I only think I need to make sure they don't cause dramatic slowdowns)
14:01:49 <mnislaih> the good thing about mine is that they are pretty isolated, and unless you use -fdebugging, it won't interfere in anything else
14:01:52 <mnislaih> (hopefully)
14:03:06 <mnislaih> why would your project cause slowdowns, it if is not too involved to explain ?
14:03:45 <mnislaih> oh, you'd need to modify the parser, aint it waern ?
14:04:27 <waern> ah, that's good.. my modifications also need a flag, but they might interfere with things anyway (though they shouldn't if they work correctly)
14:04:38 <waern> mnislaih, yeah, and the lexer
14:05:29 <waern> it's the lexer that I'm worried might have become slower, but I don't know and I'm gonna look at it
14:05:51 <waern> but not right now because I'm trying to debug this GHC api panic
14:06:19 <eivuokko> Out of curiosity, which panic is that?
14:06:30 <mnislaih> ah, you could use the all new ghc debugger ;)
14:06:47 <waern> eivuokko, it's one coming from dfun_lookup in TidyPgm.lhs
14:06:51 <mnislaih> though it'd be a nightmare to set it up for ghc of course..
14:07:00 <eivuokko> You could probably also use my tracer if you're in Windows. ;)
14:07:11 <waern> mnislaih, yep you are right =) but I'd need to merge our repositories
14:07:15 <mnislaih> what is that eivuokko  ?
14:07:43 <eivuokko> mnislaih, It's a native debugging based tracer for ghc built executables...mainly shows evaluation traces
14:08:08 <eivuokko> I dropped when I heard about your SoC project
14:08:11 <mnislaih> eivuokko: that's interesting. Do you have a site with info about it ?
14:08:12 <eivuokko> *dropped it
14:08:26 <mnislaih> we didn't touch traces in my project
14:08:40 <mnislaih> so it is still very relevant
14:08:47 <eivuokko> mnislaih, There's some thread aout it at cvs-ghc@ few months back and tamelambda.net/darcs/tracer is the repo
14:09:03 <eivuokko> mnislaih, It is mainly usefull for finding some error-calls atm
14:09:20 <mnislaih> but why only in windows ?
14:09:27 <eivuokko> It'd be trivial to add some other stuff.  I kinda dream ghc building debug databases with typeinfo etc someday...
14:09:37 <eivuokko> Because Windows Debug API is easy..
14:10:10 <eivuokko> ...And I wrote the bindings for it for playing
15:43:44 <giksos> hi! I see that much of ghc source is actually literate haskell. But how do I produce documents out of these source files? Just running latex over a single source doesn't seem to be enough.
15:47:23 <int-e> giksos: they're mostly plain text ... latex can't handle them.
15:47:51 <int-e> giksos: just view them as text.
15:49:48 <giksos> aah, ok. They just use tex-style commands like \code{} and \section{} so I thought I could produce some neat pdfs out of it...
15:50:52 <giksos> but now I see that the layout is all plaintext
15:53:01 <swiert> lhs2TeX?
15:53:36 <int-e> swiert: that won't handle the ascii graphics that they occasionally use.
15:56:57 <swiert> int-e: ok. If I see LaTeX-like .lhs files, they usually work with that.
15:57:31 <int-e> swiert: they aren't latex-like. they have \section and \subsection and that's about it.
15:58:07 <jberg> say i have a list [1, 5, 10] and i want to generate all lists that contain those numbers, and whose sum is 20, like [5, 5, 10] [10, 1, 1, 1, ...] etc.. but i have no idea how to start, any tips?
15:58:43 <swiert> int-e: fair enough.
15:59:25 <ndm> jberg: list comprehensions are quite handy for that sort of thing
15:59:57 <ndm> sumTo 0 = []
16:00:20 <jberg> ndm, hmm ok
16:00:31 <ndm> sumTo n = [i : sumTo (n-i) | i <- [1,5,10], n-i>= 0]
16:01:11 <ndm> jberg: those two lines are how i'd do it, if they work :)
16:01:34 <ndm> actually, it doesn't
16:01:45 <int-e> > let sumTo 1 = [1]; sumTo n = sumTo (n-1) >>= \(a:as) -> [(a+1):as, 1:a:as] in sumTo 4
16:01:46 <lambdabot>  add an instance declaration for (Num [a])
16:01:47 <lambdabot>   In the definition of `wjy':
16:01:47 <lambdabot>  ...
16:01:52 <ndm> sumTo n = [i : xs | i <- [1,5,10], n-i>= 0, xs <- sumTo (n-i)]
16:02:30 <ndm> that looks better, to generate all the permutations
16:02:36 <cjeris> ndm: pardon a question from another novice.  does that memoize automatically, or do you have to do so explicitly?
16:03:10 <ndm> cjeris: i'd guess at non memoize'd
16:03:39 <int-e> > let sumTo 1 = [[1]]; sumTo n = sumTo (n-1) >>= \(a:as) -> [(a+1):as, 1:a:as] in sumTo 4
16:03:40 <lambdabot>  [[4],[1,3],[2,2],[1,1,2],[3,1],[1,2,1],[2,1,1],[1,1,1,1]]
16:03:45 <ndm> cjeris: only CAF's are memoized, so ifyou did sumTable = map sumTo [0..]
16:04:02 <cjeris> > let sumTo = [] : [i : xs | i <- [1, 5, 10], n - i >= 0, xs <- sumTo!(n - i)] in sumTo 5
16:04:03 <lambdabot>  Not in scope: `n'
16:04:03 <ndm> then used sumTable !! (n-i), instead of sumTo (n-i)
16:04:08 <cjeris> > let sumTo = [] : [i : xs | i <- [1, 5, 10], n - i >= 0, xs <- sumTo!(n - i)] in sumTo!5
16:04:08 <lambdabot>  Not in scope: `n'
16:04:20 <cjeris> eh, not thinking
16:04:51 <jberg> thanks!
16:05:28 <jberg> what is >>= ?
16:05:46 <lament> it's that monad thing.
16:05:55 <int-e> in this case just a fancy way of writing concatMap
16:06:05 <int-e> a >>= b = concatMap b a
16:06:38 <int-e> note that this is just the definition for the list monad.
16:07:15 <jberg> oh ok
16:07:31 <int-e> and my code is solving the wrong problem anyway.
16:07:57 <jberg> hmm yes
16:10:22 <jberg> so, what about generating all the lists with [1, 5, 10] and filter away those whose sum isn't 20?
16:10:33 <int-e> it's not solving that problem efficiently either, it just happens to be a way that makes it obvious that there are 2^(n-1) ordered partitions of n.
16:10:41 <int-e> no, don't do that.
16:11:43 <int-e> just do what ndm proposed. that looked good.
16:13:04 <int-e> the problem with generating all these lists is that you'll end up filtering infinitely many lists ... :)
16:13:42 <jberg> well yeah, i just thought that when the sum > 20 you'd just backtrack to the next elem or something
16:14:48 <int-e> sumTo n = [i : xs | i <- [1,5,10], n-i>= 0, xs <- sumTo (n-i)] does exactly that, although in a somewhat opposite way.
16:15:20 <int-e> the  n-i>= 0 causes the backtracking when the sum becomes too large.
16:16:09 <jberg> but that code doesn't work?
16:16:10 <int-e> instead of keeping track of the sum, the code keeps track of the remainder though. that allows sumTo to call itself recursively directly.
16:16:24 <ndm> jberg: it looks like it should do...
16:16:50 <int-e> > let sumTo 0 = [[]]; sumTo n = [i : xs | i <- [1,5,10], n-i>= 0, xs <- sumTo (n-i)] in sumTo 10
16:16:51 <lambdabot>  [[1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,5],[1,1,1,1,5,1],[1,1,1,5,1,1],[1,1,5,1,1,...
16:16:53 <ndm> how doesn't it work?
16:17:03 <int-e> ndm: you got the base case subtly wrong I think :)
16:17:12 <jberg> oh great, i missed the base case
16:17:13 <ndm> ah, yes, that makes sense
16:24:27 <user317> is there a way to make a regex that says match anything except this sequence?
16:24:30 <user317> [^ab] will match anything except a or b, but i want something thats anything except 'ab'
16:31:45 <giksos> user317: don't know about haskell, but I think in perl you would group the sequence using ()
16:32:13 <giksos> so ^(ab) or similar
16:35:25 <user317> giksos, how do you negate a sequence?
16:36:58 <int-e> with plain regular expressions that's tedious
16:37:36 <int-e> ^(|[^a].*|a|a[^b].*)$ matches anything but ab
16:38:15 <user317> int-e, what is the $
16:38:39 <int-e> ^ marks the beginning of a string, $ the end of it
16:38:53 <int-e> outside of []
16:39:51 <alec> I'd like to keep the ghci prompt short; when I load more than a few modules it spills over a line.  I've searched around but can't find a way to keep module names from showing up before the prompt; is there a way to do it?
16:40:14 <int-e> if you want strings that don't contain ab then it's different ... ^([^a]|a[^b])*a?$
16:40:18 <ndm> alex, :set prompt boo
16:40:26 <ndm> alec, :set prompt boo
16:40:33 <int-e> PCRE has some sort of negations but I forgot how that works.
16:40:40 <alec> ndm: wow.. missed that one - thanks!
16:41:00 <ndm> alec: i did the patch for that one, so am well aware of it
16:42:59 <alec> ndm: no wonder I didn't find it - I'm using 6.4.1 and it doesn't show up in the help in that release; guess I need to upgrade to 6.4.2
16:43:13 <ndm> alec: yeah, 6.4.2 only
16:49:16 <jberg> ndm, i noticed that your solution above contains lists with the same elements, just in different order. is it possible to fix, or will that make the code much more complicated?
16:49:49 <ndm> jberg: its not trivial to fix, but should be possible
16:50:06 <ndm> essentially keep the same logic, and add a list of which elements can be in the list
16:50:13 <ndm> then demand that the list is sorted
16:50:28 <ndm> i.e. sumTo available n = ...
16:50:37 <ndm> where intially available is [1,5,10]
16:50:57 <ndm> and if you pick i = 5, for example, available goes down to [5,10]
16:51:00 <int-e> [10,5,1] is probably better.
16:51:17 <int-e> just to avoid fruitless searches.
16:51:33 <ndm> the recursive available is then just (filter (<=i) available)
16:51:45 <ndm> using int-e's good suggestion of being in descending order
16:52:00 <ndm> sumTo set n = [[]]
16:52:17 <jberg> hmm i will have to think for a while, thanks :)
16:52:33 <ndm> sumTo set n = [i : xs | i <- [1,5,10], n-i>= 0, xs <- sumTo (filter (<= i) set) (n-i)]
16:52:38 <ndm> thats a guess at it
16:52:45 <ndm> oh, thats wrong :)
16:52:53 <ndm> sumTo set n = [i : xs | i <- set, n-i>= 0, xs <- sumTo (filter (<= i) set) (n-i)]
16:53:21 <ndm> thats better, its also more flexible in set, rather than [1,5,10], which is another good thing
16:53:49 <ndm> jberg: let me know if that works or not...
16:56:14 <jberg> hmm i get parse error
16:56:16 <jberg> on =
16:56:59 <jberg> err wait
16:57:58 <jberg> it works great :)
16:58:03 <ndm> yay
16:59:35 <heatsink> @seen SyntaxNinja
16:59:35 <lambdabot> I saw SyntaxNinja leaving #haskell, #darcs and #haskell-blah 9 days, 23 hours, 43 minutes and 42 seconds ago, and .
17:00:02 <heatsink> @. elite seen SyntaxNinja
17:00:02 <lambdabot> I $AW syN+4XNinja 13A\/IN9 #|-|aSKe|L, #d4rCS ANd #h4zKe1L-b|aH 9 dAy5, 23 hOurs, 44 MiNute$ And 9 $Ec0NdS ago, AND .
17:00:09 <heatsink> :)
17:00:29 <int-e> @quote
17:00:29 <lambdabot> glguy says: that's odd, mine is this big : |-----------------------------|
17:00:53 <heatsink> @quote
17:00:53 <lambdabot> Paltas says: i read that the python developer considered to remove nearly all functional programming methods from python.. wondered if he got a stroke or something..
17:02:41 <xerox__> ?yow!
17:02:42 <lambdabot> World War Three can be averted by adherence to a strictly enforced
17:02:42 <lambdabot> dress code!
17:07:43 <xerox__> ?quote
17:07:44 <lambdabot> S.Behrens says: Computer science is the womanizer, and math is the pure-hearted girl he won't call the next day.
17:07:47 <xerox__> ?quote
17:07:47 <lambdabot> sjanssen says: @djinn Haskell -> Curry
17:07:53 <xerox__> ?quote
17:07:54 <lambdabot> JohnMeacham says: Last night I was at this dive bar listening to live music and there was this cute girl I was talking too while this guy was there, we started ribbing each other in the appropriate
17:07:54 <lambdabot> way when confronted with the situation of two guys talking to the same girl, and our jeers eventually turned technical until we were arguing about haskell, perl, and pugs development. it turning out
17:07:54 <lambdabot> he was one of the pugs de
17:08:22 <xerox__> velopers
17:08:25 <xerox__> ?quote
17:08:25 <lambdabot> musasabi says: <musasabi> no reason to reinvent the whole wheel  <musasabi> (usually reinvented wheels end up square)
17:08:33 <xerox__> ?quote
17:08:33 <lambdabot> SamB says: GHC is smart
17:08:38 <xerox__> ?quote
17:08:39 <lambdabot> darius says: Well profiling does add a bit of reflection, but it should have the good sense not too go near the barbed wire fences and armed guards.
17:09:17 <xerox__> ?quote
17:09:18 <lambdabot> madpickle says: Stuff costs more than it used to.
17:14:46 <sjanssen> @quoth ghc
17:14:46 <lambdabot>  Occurs check: cannot construct the infinite kind
17:15:02 <ndm> @quote  xerox
17:15:02 <lambdabot>  I am really interested specifically in bottoms in this very moment.
17:15:08 <xerox__> ...
17:15:27 <int-e> @vixen  I am really interested specifically in bottoms in this very moment.
17:15:28 <lambdabot> really!?
17:16:03 <xerox__> I finally gained access to a computer, I am away from home; also thanks to the unknown neighbour whom I using the wifi of....
17:17:11 <ndm> are you seeing any images upside down?
17:18:11 * edwardk waves ello.
17:18:41 <ptolomy> I really dig Bulat's Streams and ArrayRef libraries.
17:22:02 <xerox__> ndm: haha no
17:22:16 <xerox__> anyway i am too tired nnight
17:23:43 <ndm> night
17:28:44 <aleko> ;(
17:28:49 <aleko> oops
17:28:54 <aleko> never mind
17:30:56 <johnnowak> so long all
17:31:11 <johnnowak> ah - wrong channel, but there you are anyway!
17:33:41 <ramserver> is happs used by anyone here?
17:33:46 <ramserver> the haskell app server?
17:40:08 <ndm> @where happs
17:40:09 <lambdabot> http://happs.org
17:40:56 <edwardk> @seen ski
17:40:56 <lambdabot> ski is in #haskell. I don't know when ski last spoke.
17:40:58 <ndm> ramserver: have you seen hsp, i think its a kind of competing haskell version
17:41:06 <edwardk> @seen shapr
17:41:07 <lambdabot> I saw shapr leaving #haskell and #ScannedInAvian 7 days, 5 hours, 58 minutes and 7 seconds ago, and .
17:41:18 <edwardk> where has shapr been?
17:47:59 <Pseudonym> He has a blog entry from a couple of days ago.
17:48:05 <Pseudonym> Incidentally, bug in lambdabot there.
17:58:36 <edwardk> ?
17:58:48 <edwardk> oh yeah. replying to that now =)
18:13:17 <Frederick> hellow :)
18:16:58 <edwardk> heya
18:48:59 <lispy> has anyone written USB drivers in haskell and have a library laying around that i could extend?
18:49:40 <lispy> i don't see anything relavant with quick google searches...so probably not?
18:52:32 <edwardk> not i ;)
18:53:51 <svref> is it better to write x*x or x^2 ?
18:54:07 <edwardk> x*x will probably win performance wise
18:58:13 <spiffy> shouldnt a decent complier just "Do The Right Thing TM" or is that a harder optimization to do then it looks?
18:58:32 <dons> the compiler should spot this, its pretty trivial
18:58:37 <Patterner> use whatever is more readable for the programmer/QA
18:58:39 <dons> if in doubt, use the fast version
18:59:05 <Patterner> you know what they say about premature optimization, right?
18:59:11 <dons> lispy: hmm. USB drivers eh?
18:59:19 <SamB> Patterner: it is the root of all kinds of evil?
18:59:28 <Patterner> SamB++
18:59:41 <dons> spiffy, right, as Patterner suggests,unless you're writing a language shootout entry, you probably won't care which version you use
19:00:23 <dons> ?users
19:00:25 <lambdabot> Maximum users seen in #haskell: 235, currently: 202 (86.0%)
19:00:33 <dons> ?users #perl6
19:00:34 <lambdabot> Maximum users seen in #perl6: 148, currently: 130 (87.8%)
19:01:32 <dons> lispy: i wonder, lennart wrote much of the usb support in the netbsd kernel, iirc. i'm sure he'd be interested in Haskell usb drivers...
19:06:46 <syntaxfree> hey, dons.
19:06:50 <syntaxfree> you know what lambdabot should have?
19:06:57 <syntaxfree> a pl-like feature, useful for beginners.
19:07:25 <syntaxfree> something that converts do notation to straight expressions.
19:07:48 <monochrom> I can do it for you.
19:08:28 <syntaxfree> You mean you can convert expressions for me, or write the feature?
19:08:36 <lament> lambdabot doesn't have that feature?
19:08:39 <lament> i thought it did
19:08:42 <syntaxfree> not that I know of.
19:08:48 <syntaxfree> It'd have been useful for me at the beginning.
19:09:03 <syntaxfree> Now I've figured it out. Still, it'd be nice to have an automated tool for large expressions.
19:10:02 <dons> oh, a tool to desugar do notation?
19:10:07 <monochrom> I can convert expressions for you.
19:10:27 <sjanssen> the algorithm is incredibly easy
19:10:43 <lispy> dons: ah, cool, i should ask him
19:11:09 <dons> sjanssen: you want to write a little plugin to do it? just using Lib.Haskell in lambdabot?
19:11:30 <lispy> dons: i'm interested because i have this new gps and heartrate gadget that uses usb and the software that came with it in 1) crappy 2) windows only.  Plus the company that makes it gives out the specs and example code for making a usb driver
19:11:51 <dons> lispy: oh cool! that would be really nice to see
19:12:04 <lispy> i thought the logical place to start would be a haskell library for USB drivers so i could start communicating with it
19:12:09 <dons> yeah, have a chat to lennart, he might have some ideas. also, I wonder if the House people have thought about it /
19:12:29 <SamB> @pl (do x <- foo; bar x)
19:12:30 <lambdabot> (line 1, column 13):
19:12:30 <lambdabot> unexpected ";"
19:12:30 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or ")"
19:13:03 <dons>  @pl uses its own parser for some weird reason
19:13:08 <dons> that should be fixed too
19:13:30 <Pseudonym> Hey, lambdabot needs another Haskell parser.
19:13:34 <Pseudonym> Sounds good.
19:13:51 <dons>  no no. it needs one less parser
19:14:04 <SamB> it needs zero Haskell parsers
19:14:14 <SamB> it should use GHC's ;-P
19:14:20 <lispy> yeah
19:14:27 <lispy> lambdabot could use ghc-api?
19:14:49 <SamB> there aren't any releases supporting that yet are there?
19:14:53 <Pseudonym> Unfortunately, the built-in Haskell parser only parses modules.
19:15:04 <SamB> Pseudonym: that isn't GHC's parser
19:15:09 <SamB> or, wait...
19:15:12 <dons> Pseudonym: that's why there's a hacked Language.Haskell in Lib/ for parsing expressions
19:15:15 <Pseudonym> The one in the library.
19:15:33 <SamB> yeah, GHC knows how to parse expressions too doesn't it?
19:15:48 <spiffy> time for spifffy to....*cue dramatic music*....conquor monads
19:15:56 <monochrom> @pl do {x <- foo; bar x}
19:15:56 <lambdabot> (line 1, column 4):
19:15:56 <lambdabot> unexpected "{"
19:15:56 <lambdabot> expecting variable, "(", operator or end of input
19:16:11 <monochrom> It doesn't like do.
19:16:23 <syntaxfree> foo >>= bar  is a lot more "expressive" once you get used to it.
19:16:31 * syntaxfree do notation considered harmful
19:16:45 <lispy> why is foo >>= bar more expressive?
19:17:10 <lispy> often it's more clear to say: do x <- foo; bar x
19:17:12 <SamB> syntaxfree: yeah, I was kinda hoping @pl would come up with that actually ;-)
19:17:18 <syntaxfree> because it makes clear you're using an (a->*) function on an IO a type.
19:17:28 * syntaxfree hopes he got the notation right.
19:17:29 <dons> they're the same... it can't be _more_ expressive
19:17:33 <SamB> lispy: not when you really only have such simple expressions it isn't...
19:18:06 <SamB> though perhaps bar =<< foo is better sometimes
19:18:58 <lispy> well, okay i guess: do x <- foo; bar; baz x, is easier than the alternative
19:19:21 <SamB> yah
19:20:35 <syntaxfree> lispy: um, true. By the way, how do you say that without do notation? :~
19:21:19 <lispy> syntaxfree: use lambdas
19:21:19 <SamB> syntaxfree: write the plugin and see?
19:21:20 <monochrom> @pl foo >>= \x -> bar >> baz x
19:21:21 <lambdabot> (bar >>) . baz =<< foo
19:21:25 <monochrom> That.
19:21:30 <lispy> no, not that
19:21:35 <SamB> monochrom: you silly
19:21:46 <lispy> iirc, @pl doesn't understand bind
19:21:54 <lispy> but maybe that's right
19:22:02 <lispy> yeah, i take it back :)
19:22:08 <monochrom> It is right.  No "understanding" of >>= necessary.
19:22:10 <syntaxfree> I should write a tutorial on Haskell as a shell scripting language.
19:22:14 <syntaxfree> It's about all I do anyway.
19:22:33 * lispy had to write some php today and nearly went bald
19:22:34 <syntaxfree> gosuckit = ["wget www.suck.com/daily/"++ pretty x++"/"++pretty y++"/"++ pretty z ++ "/daily.html >> bigsuck.html\n" | x<-[1995..2001], y<-[1..12], z<-[1..30]]
19:22:47 <lispy> i figure tomorrow when i pick it up again i'll really pull my hair out
19:23:01 <syntaxfree> doing that in bash would be painful.
19:23:04 <lispy> i found that in php you can pass anything to anything and you don't get type errors!
19:23:10 <sjanssen> is there an easy way to apply a function to each occurence of a specific constructor of a data type?
19:23:28 <monochrom> You should pull your hair out inside a transaction.  Then you just need to rollback and your hair is intact again.
19:24:28 <int-e> pulling out hairs is in the IO monad I think :)
19:24:40 <monochrom> Do it in the STM monad.
19:24:43 <SamB> yah, STM doesn't support hair-pulling...
19:24:55 * SamB was going to say that before monochrom said what he just said
19:25:01 <monochrom> unsafeIOtoSTM
19:25:13 <SamB> that doesn't roll it back right, silly!
19:25:50 <lispy> heh
19:25:59 <monochrom> I guess the laws of thermodynamics hold afterall.
19:26:27 <lispy> i read a file in, accidentally as an array of liness, and then passed it to a function that took a string.  So the function thought I passed in the string literal 'Array'
19:26:37 <lispy> to me, that is totally absurd behaviour
19:26:52 <Pseudonym> unsafeTransferHeatFromCoolerBodyToWarmer
19:27:23 <monochrom> unsafeTransferHairFromFloorToHead
19:27:24 <jcreigh> syntaxfree: What about months that don't have 30 days? :)
19:27:53 <lispy> monochrom: does that give you a pure pile of hair?
19:28:19 <SamB> lispy: no, it is all IO Hair
19:28:40 <SamB> or maybe IOHair
19:28:41 <lispy> but it's unsafe so i thought maybe you'd get [Hair]
19:28:54 <SamB> Hair = [Hair]
19:29:08 <lispy> uh, infinite type?
19:29:17 <syntaxfree> jcreigh: OH!
19:29:20 <SamB> breakdown of english, actually
19:29:24 <lispy> > let hair = [hair] in hair
19:29:25 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
19:29:25 <lambdabot>    Expected...
19:29:27 <SamB> (Hair doesn't have a plural)
19:29:40 <syntaxfree> jcreigh: I need to make it 31. When wget gets a 404, it doesn't pass it over to bigsuck.html
19:29:53 <SamB> how about Hair = [Strand]
19:30:01 <lispy> okay
19:30:28 <lispy> > let hair = [hair] in 1
19:30:29 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
19:30:29 <lambdabot>    Expected...
19:30:35 <lispy> ah, that's good to know
19:30:40 <lispy> so i can save typing in the future
19:31:11 * lispy should read some USB documentation
19:31:23 <sjanssen> @hoogle mkT
19:31:24 <lambdabot> Data.Generics.Aliases.mkT :: (Typeable a, Typeable b) => (b -> b) -> a -> a
19:31:24 <lambdabot> Data.Typeable.mkTyCon :: String -> TyCon
19:31:24 <lambdabot> Data.Typeable.mkTyConApp :: TyCon -> [TypeRep] -> TypeRep
19:33:00 <jcreigh> syntaxfree: Also, bash 3.0 has support to expand expressions of the form {x..y}, so you *could* say, in bash: for url in www.suck.com/daily/{1995..2001}/{1..12}/{1..31}; do curl "$url" >> bigsuck.html; done
19:33:32 <SamB> oooooooo
19:33:39 <SamB> does ZSH have that too?
19:33:52 <jcreigh> SamB: Dunno, I just know it's new in bash 3.0
19:34:03 <SamB> oooh
19:34:06 <SamB> yeah it does!
19:34:19 <SamB> thankyou for showing me that!
19:34:27 <SamB> I've been wanting it!
19:37:35 <lispy> i think you could do that with a monad
19:37:50 * lispy is thinking the list monad
19:39:59 <lispy> oh wait, you did exactly what i'm thinking up above
19:40:38 <lispy> at least in haskell you wouldn't have to have the whole url list in memory at once
19:40:47 <lispy> just incase it's huge
19:49:44 * syntaxfree is producing a small book out of all Suck.com content, for personal use.
19:49:58 <syntaxfree> one function.
19:50:04 <syntaxfree> gosuckit = ["echo " ++ px x y z ++ "\necho \\section{"++ px x y z ++"} >> bigsuck.html \ncurl www.suck.com/daily/"++ px x y z ++ "/daily.html >> bigsuck.html\n" | x<-[95..99], y<-[1..12], z<-[1..31]]
19:50:28 <syntaxfree> (well, three functions. pretty x = if x<10 then "0"++show x else show x; px x y z = pretty x ++ "/" ++ pretty y ++ "/" ++ pretty z)
19:53:06 <syntaxfree> (I should have mentioned everything will be de-htmlized later with another Haskell function)
19:55:12 <jcreigh> syntaxfree: Err...not to spoil your Haskell fun or anything, but wget has a recursive mode. So, for instance, you could say "wget --no-parent --recursive --level inf --wait 5 --page-requisites www.suck.com" to fetch everything on www.suck.com, waiting 5 seconds between each request in an attempt to be nice to their server.
19:55:29 <syntaxfree> jcreigh: yes, but then it reproduces the directory structure on the original site.
19:55:40 <syntaxfree> And I want itto be all on one text file.
19:55:54 <syntaxfree> and have the \section{date here}  divider.
19:56:03 <syntaxfree> so I can later basically slap \documentclass{book} \begin{document}
19:56:53 <jcreigh> syntaxfree: Cool. So is that LaTeX markup, then?
19:57:18 <syntaxfree> yes. I have a small shell script (written in Haskell) that removes text between <angly brackets>
19:59:14 <syntaxfree> Suck is updated every weekday between 95 and 2001, so that's about, uh, 250 * 7 = 1750 articles.
19:59:31 <syntaxfree> If it took me one minute to copy-and-paste each article by hand, it'd take me..
19:59:36 <syntaxfree> > 1750 / 60
19:59:37 <lambdabot>  29.166666666666668
19:59:48 <syntaxfree> 30 hours, or about 5 days of intense work.
20:00:02 * syntaxfree repetitive work considered harmful.
20:00:16 <jcreigh> syntaxfree: Amen
20:00:21 <monochrom> This is destined for grad students.
20:00:49 <syntaxfree> this?
20:02:55 <Frederick> hello
20:03:13 * jcreigh thinks that even if it took 30 hours to write the program, it would *still* be worth it, because 30 hours coding is way better than 30 hours copying-and-pasting...
20:03:59 <syntaxfree> well, you do learn some Haskell in the process, even if it's just getting the syntax and semantics you already know into muscle memory.
20:04:36 <Lemmih> @seen CosmicRay
20:04:36 <lambdabot> I saw CosmicRay leaving #haskell-blah, #darcs and #haskell 7 days, 5 hours, 3 minutes and 22 seconds ago, and .
20:05:29 <lispy> i sent an email to haskell-cafe about my usb ambitions, hopefully lennart reads haskell-cafe
20:05:40 <lispy> dons: thanks again for the pointer
20:06:26 <SamB> what kind of Ptr was it ?
20:06:45 <Lemmih> dons: What happened to unsafeUseAsCStringLen?
20:07:00 <dons> its the same as useAsCStringLen
20:07:15 <dons> same implementation, so we ditched the redundant unsafe one (which wsan't unsafe anyway)
20:07:33 <lispy> SamB: heh, Ptr Lennart
20:07:37 <dons> let me know of any other issues you have with what is to become fps 0.6
20:07:50 <int-e> 0.8?
20:08:04 <syntaxfree> wow. SubEthaEdit is slow at doing stuff sed does in seconds.
20:08:04 <dons> yep :)
20:08:26 <dons> hmm. running newfs on my brand new mp3 player doesn't seem to be good for it
20:12:41 <sjanssen> @elite
20:12:42 <lambdabot> Say again?
20:12:45 <syntaxfree> anyway.
20:12:47 <syntaxfree> up and out :)
20:15:23 <lispy> same with vim vs. emacs
20:15:38 <lispy> i've processed huge files in emacs relatively quickly and had vim take ages
20:15:45 <lispy> and presumably sed would be even faster
20:18:23 <syntaxfree> oh god.
20:18:26 <syntaxfree> my little suck.com project?
20:18:38 <syntaxfree> it's only eaten about one fourth of the site and it's already 705 latex pages.
20:19:58 <syntaxfree> Suck.com ends up being larger than most of my textbooks.
20:23:46 <dons> grr. now I need a windows machine. where could I find one of those?
20:24:43 <jcreigh> dons: Why do you need a windows box?
20:25:47 <dons> oh, I managed to newfs my mp3 player, which wiped it (who'd have though?). the install cd runs on windows only, of course :)
20:28:25 <jcreigh> dons: Ah, so you need to reformat it to FAT or whatever?
20:29:40 <dons> well, that's what i did, now it won't boot. so i suspect i deleted something important
20:30:05 <dons> so yeah, i need to reformat it from the backup disk, I think
20:31:47 <dons> ah, I have an idea
20:33:11 <lispy> dons: what type of mp3 device is it?
20:34:09 <dons> its an mcody m20, http://www.advancedmp3players.co.uk/shop/product_info.php?products_id=1493
20:34:12 <lambdabot> Title: Advanced MP3 Players - Mcody M20 2GB MP3 Player
20:34:51 <lispy> oh hm...not one i'm familiar with, sorry
20:35:01 <dons> :)
20:35:13 * lispy tries to build ghc-6.4.2 so he'll have a recent ghc on his ibook
20:35:14 <dons> 'sok, all very fixable
20:38:07 <sjanssen> so why does my lambdabot exit immediately after printing "Initialising plugins"?
20:38:22 <dons> sjanssen: probably your State/seen file is of the wrong type?
20:38:28 <dons> try removing State/seen
20:38:41 <dons> (we don't handle state format errors very well)
20:39:05 * lispy thinks the apple dev documentation is pretty acceptable
20:39:11 <lispy> it reads like a book
20:45:44 <sjanssen> bleh, do I really not have sendmail set up on this machine?
20:46:59 <jcreigh> sjanssen: I hope "sendmail" means "some MTA" and not *the* sendmail...
20:50:06 <sjanssen> jcreigh: whatever I use to make darcs send work (postfix, I think)
20:52:19 <sjanssen> lambdabot> . pl doless \mm -> do m <- mm; x <- m; return x
20:52:21 <sjanssen> join
20:53:08 <dons> oh, nice!
20:53:26 <dons> how about 'undo' as the plugin name?
20:54:27 <edwardk> hahah
20:54:37 <sjanssen> hmm, I wonder why I didn't think of such an obvious name?
20:54:45 <sjanssen> instead of inventing a word
20:54:54 <dons> heh
20:55:26 <jer> jcreigh, out of curiosity, what's wrong with sendmail for that purpose (sending mail)
20:56:46 <jcreigh> jer: Its config file is from hell. (Or used to be, anyway. Maybe they fixed it...)
20:57:11 <lisppaste2> lispy pasted "why does ghc hate me? :-)" at http://paste.lisp.org/display/24721
20:59:22 <jer> well smx (sendmail 10)'s config file is much nicer than posfix's if you like brevity... as far as sendmail 8, for instance, most sane people generate a config file with an m4 script; which any monkey could write
20:59:57 <Lemmih> lisppaste2: Missing readline header files?
21:00:30 <lispy> Lemmih: ah, good idea, i'll check for those
21:00:34 <Lemmih> lispy: Missing readline header files or old version of readline?
21:00:51 <lispy> is readline 5 old?
21:01:20 <lispy> ports only shows a 'readline' and 'readline-5' i don't see a 'readline-dev' package
21:01:31 <sjanssen> dons: you can ignore the first patch I sent you
21:01:52 <lispy> and i have /usr/include/readline/{readline,history}.h
21:02:08 <dons> oh,  ialready took it and moved it over to Undo.hs
21:02:10 <dons> darcs pull
21:04:03 <dons> ?quit add @undo
21:05:33 <dons> ?hep undo
21:05:33 <lambdabot> undo <expr>
21:05:34 <lambdabot> Translate do notation to basic Monad operators.
21:05:46 <dons> ?undo do x <- f ; return x
21:05:46 <lambdabot> f >>= \ x -> return x
21:05:47 <jcreigh> @undo foo <- bar; baz foo
21:05:47 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 5}) "Parse error"
21:05:55 <jcreigh> @undo do foo <- bar; baz foo
21:05:55 <lambdabot> bar >>= \ foo -> baz foo
21:06:01 <Pseudonym> @undo do xs <- xss; x <- xs; return x
21:06:01 <lambdabot> xss >>= \ xs -> xs >>= \ x -> return x
21:06:08 <dons> ?karma+ sjanssen -- patches
21:06:08 <lambdabot> sjanssen's karma raised to 12.
21:06:11 <Pseudonym> @undo do xs <- xss; x <- xs; guard (x > 3); return x
21:06:12 <lambdabot> xss >>= \ xs -> xs >>= \ x -> guard (x > 3) >> return x
21:06:23 <dons> ?. pl undo do xs <- xss; x <- xs; guard (x > 3); return x
21:06:24 <lambdabot> (ap ((>>) . guard . (> 3)) return =<<) =<< xss
21:07:01 <Pseudonym> ?. pl undo \xss -> do xs <- xss; x <- xs; guard (x > 3); return x
21:07:02 <lambdabot> ((ap ((>>) . guard . (> 3)) return =<<) =<<)
21:07:13 <Pseudonym> ?. type . pl undo \xss -> do xs <- xss; x <- xs; guard (x > 3); return x
21:07:14 <lambdabot> forall a (m :: * -> *). (Ord a, Num a, MonadPlus m) => m (m a) -> m a
21:07:57 <Pseudonym> If only we had state, we could then ?free that.
21:08:02 <Pseudonym> Well, not quite.
21:08:55 <lispy> i thought we did have state
21:08:57 <lispy> @store 1
21:09:00 <dons> if we extended the ?free parser..
21:09:08 <lispy> hm.m..can't remember the commands for it tho
21:09:09 <Pseudonym> Yes.
21:09:22 <Pseudonym> Except that ?free still needs the name of the function.
21:09:46 <dons> ah yes
21:10:12 <Pseudonym> What we need, I think, is for ?. to accept curried operations.
21:10:15 <dons> a plugin to allow arbitrary haskell string processing would be useful
21:10:23 <dons> and then a proper parser for .
21:10:40 * Pseudonym thinks a moment.
21:10:45 <dons> we could write: . free (run some. filter.in.haskell) . undo ...
21:10:56 <Pseudonym> What we REALLY want here is for lambdabot to be just a Haskell interpreter.
21:11:03 <dons> yes
21:11:17 <Pseudonym> But allow a special lambdabot monad for plugins.
21:11:26 <dons> ah hmm.
21:12:04 <lispy> @state
21:12:04 <lambdabot> Unknown command, try @list
21:12:06 <dons> yes, so you get arbitrary haskell, as well as a bunch of lambdabot plugins as functions
21:12:07 <Pseudonym> You don't want to allow general IO.
21:12:22 <dons> right, it still has to be restricted in the way @eval is
21:12:22 <Pseudonym> But a special LambdaMon or something which communicates with plugins.
21:12:40 * Pseudonym thinks about that
21:12:45 <Pseudonym> Yup, easy.
21:12:46 <dons>  @eval needs a way to call back into plugins, or somehow expose them to @eval fragments
21:12:52 <Pseudonym> Hang on a moment.
21:13:07 * lispy grabs on to something sturdy
21:13:47 * Pseudonym needs to build this stuff up first
21:14:16 <Pseudonym> Crap.
21:14:25 <Pseudonym> Darcs can't handle proxies, can it.
21:14:32 <dons> yeah it can
21:14:46 <lispy> if you compiled with curl, then do it the way curl would do it
21:14:50 <dons> via curl, which reads the http_proxy env
21:15:01 <dons> i.e. $ echo $http_proxy
21:15:01 <dons> http://www-proxy.cse.unsw.EDU.AU:3128/
21:15:18 <Pseudonym> Oh, guess it does work.
21:15:31 * lispy re-runs configure and notes that it does see readline
21:15:36 * lispy boggles
21:20:54 <sjanssen> @pl \x -> Prelude.x
21:20:54 <lambdabot> (Prelude .)
21:21:18 <sjanssen> pl needs to use a standard parser
21:22:04 * lispy agrees
21:22:28 <lispy> although, it is nice you can @pl a function that lambdabot is unaware of
21:22:47 <lispy> i've always thought that a nice feature
21:23:03 <sjanssen> @undo do x <- someNonExistingThing; return x
21:23:03 <lambdabot> someNonExistingThing >>= \ x -> return x
21:23:08 <Pseudonym> That's irrelevant, though.
21:23:13 <sjanssen> lispy: using just the parser will retain that property
21:23:33 <Pseudonym> The only difference is operators.
21:24:06 <lispy> why \x -> return x?
21:24:10 <lispy> @pl \x -> return x
21:24:10 <lambdabot> return
21:24:43 <sjanssen> lispy: undo is just a simple source -> source translation, no fancy stuff
21:25:07 <lispy> @type return
21:25:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
21:25:11 <lispy> @type const return
21:25:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => b -> a -> m a
21:25:21 <lispy> oh wait, it's not const return
21:25:29 <lispy> sjanssen: hmm...okay
21:25:48 <Pseudonym> @undo do  (a,b) <- someNonExistingThing; return a
21:25:48 <lambdabot> someNonExistingThing >>= \ (a, b) -> return a
21:26:24 <lispy> @undo do x <- foo; bar; baz x
21:26:24 <lambdabot> foo >>= \ x -> bar >> baz x
21:26:34 <lispy> @. pl undo do x <- foo; bar; baz x
21:26:34 <lambdabot> (bar >>) . baz =<< foo
21:26:44 <Pseudonym> @freebconstreturn :: b -> a -> M a
21:26:44 <lambdabot> Unknown command, try @list
21:26:57 <Pseudonym> @free constreturn :: b -> a -> M a
21:26:57 <lambdabot> $map_M g . constreturn x = constreturn (f x) . g
21:27:00 * lispy recommends the space bar ;)
21:27:19 * Pseudonym recommends not typing over a loaded network connection
21:27:31 <lispy> ah
21:27:38 <Pseudonym> Takes me back to my 300 baud days.
21:27:38 <lispy> stop looking at all that library smut ;)
21:27:57 * lispy wishes he had a working ghc at home...
21:28:02 <Pseudonym> It's the apt updating that's doing it.
21:28:22 <lispy> i configured with --disable-readline this time to see if it will build
21:28:38 <lispy> but, the fact that readline is now found is distrubing...configure finds it, i can find it, but make doesn't see it
21:28:49 <lispy> s/now/not
21:30:33 <lispy> maybe --disable-readline is not allowed
21:30:37 <lispy> it still tried to build it
21:54:48 <lispy> oh hm...ghc 6.4.2 finally shows up in dports
21:54:55 <lispy> i'll stop building by hand...
22:12:12 <lispy> --->  Building ghc with target all
22:12:28 <lispy> w00t! start the 6 hour count down!
22:33:13 <tieTYT2> i'm interested in learning haskell and assuming i should download ghc.  Should i be downloading 6.4.1?
22:34:49 <Lemmih> tieTYT2: Current stable is 6.4.2.
22:37:01 <tieTYT2> thanks
22:44:02 <musasabi> What is the status of the fps UTF8 work?
22:45:55 <lisppaste2> jknecht_1729 pasted "monad question" at http://paste.lisp.org/display/24722
22:47:17 <jknecht_1729> I just pasted a couple of functions that I thought should be equivalent, but they're not because they behave differently.
22:47:56 <jknecht_1729> I'm just working through a monad tutorial and learning about monads for the first time...
22:48:54 <Lemmih> jknecht_1729: grandparent1 fails if the sheep doesn't have both parents.
22:51:55 <jknecht_1729> okay, that makes sense. I though that the 2 forms were equivalent, but I guess they're not. I'll try to desugar the first one according to the rules and see what that looks like without the 'do'. Thanks for the help.
23:05:53 <Lemmih> @undo do m <- mother; f <- father; parent m `mplus` parent f
23:05:53 <lambdabot> mother >>= \ m -> father >>= \ f -> parent m `mplus` parent f
23:13:51 <jknecht_1729> I didn't know about @undo. That's handy.
23:15:23 <Korollary> ah. nice.
23:17:36 <jknecht_1729> Why is it that the do version fails if the sheep doesn't have both parents? I thought that since mother and father both have type "Maybe Sheep", that "m <- mother s" would result in assignment of Nothing to m and not a failure.
23:18:21 <jknecht_1729> The sheep doesn't have a mother, so I thought that "d <- mother s" would like "d = Nothing" normally..
23:21:12 <jknecht_1729> I was "reading" the do block in grandparent1 as "first assign the mother of s to m (which may be Just Sheep or Nothing), then do the same with father of s to f (which again may be Nothing or Just Sheep), and then do the 3rd line, with `mplus`, which combines a Nothing and a Just Sheep into the first actual Sheep (which in this case would be the "parent f" one).
23:25:41 <maus> hi all
23:25:53 <maus> is hat supposed to work with ghc-6.4.2?
23:28:31 <Lemmih> jknecht_1729: 'm <- mother s' extracts the Sheep of the Maybe.
23:29:33 <Lemmih> jknecht_1729: If 'mother s' is Nothing (failure) then the code after the bind won't be executed at all.
23:32:07 <jknecht_1729> Oh, I didn't realize that Nothing was considered a failure. I thought it was just as much a Maybe as a Just value.
23:33:22 <Lemmih> jknecht_1729: It is.
23:35:08 <Lemmih> > Nothing :: Maybe ()
23:35:10 <lambdabot>  Nothing
23:35:11 <Lemmih> > fail "Failure for Maybe is Nothing" :: Maybe ()
23:35:12 <lambdabot>  Nothing
23:39:52 <jknecht_1729> Lemmih: okay, i looked at the definition of Maybe in the prelude, and see that where it's declared an instance of Monad, the fail declaration is "fail s = Nothing".
23:44:51 <jknecht_1729> Lemmih: thanks *very* much for your help. I can't say it's crystal clear yet, but it's clearer. thanks...
23:48:39 <dibblego> when talking about higher-order functions, is there some way of saying how much of an order higher they are?
23:49:06 <dibblego> I might say function f1 is a higher order function of f2 by an order of 1? is that correct terminology?
23:57:44 <syntaxfree> @seen lennart
23:57:45 <lambdabot> lennart is in #haskell. I don't know when lennart last spoke.
23:57:51 <syntaxfree> Lennart Carleson Receives 2006 Abel Prize >>
23:57:53 <syntaxfree> could it be?
23:57:56 <syntaxfree> could it? could it?
23:57:57 <Korollary> no
23:58:12 <syntaxfree> oh.
23:58:17 <syntaxfree> ok.
23:58:22 <syntaxfree> bbl, then.
