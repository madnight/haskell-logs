00:00:11 * edwardk waits for the handicapper general.
00:00:23 <dons> heh
00:00:45 <newsham> people are coding in languages with garbage collection, closures, arrays with proper bounds checking, etc...
00:01:08 <edwardk> just rarely with all of those features at the same time =)
00:01:15 <newsham> its not all macro assembly, C, C++, even perl...
00:01:36 <dons> even perl has most of the above, no? (or all of them)
00:01:57 <newsham> yes.. perl is progress over the others in many respects
00:03:11 <dons> we use the word "monad" 1.1x more often than we use the word 'function" in this channel. isn't that interesting
00:03:15 <wolverian> perl's arrays have proper bounds checking in the sense that they grow to whatever you want without complaining and can't be constrained :)
00:03:17 <edwardk> heh
00:03:28 <dons> maybe we should say haskell is a pure, monadic language
00:03:36 * edwardk just realized his pet language has 4 forms of implication =/
00:04:13 <Korollary> I like 'insinuate'
00:04:28 <johnnowak> edwardk: four forms of implication?
00:04:50 <dolio> Java enthusiasts (back when I was one at least, maybe it's changed) often seem resistant to changes of this sort, though I can't for the life of me remember why.
00:05:04 <edwardk> john: -> intuitionistic, -o linear, ->> ordered right, >-> ordered left
00:05:08 <jer> dons, perl doesn't really have garbage collection per say (guess it depends on your definition of course... if you take garbage collection to mean automatic memory management, then yes, it does; if you don't consider reference counting garbage collection, than it doesn't)
00:05:10 <dons> that's interesting isn't it? people seem to _love_ new language extensions in haskell
00:05:18 <johnnowak> edwardk: ah, thanks
00:05:36 <edwardk> coz i want to be able to avail myself of the stack i need an ordered fragment
00:05:46 <dolio> Generics was the hot topic back when I was studying it, and people regularly dismissed it as unnecessary syntactic sugar and so on.
00:05:47 <newsham> jer: ref counting can take out the trash :)
00:05:56 <edwardk> perl just reference counts
00:06:02 <jer> newsham, it can, when used with a mark-scan (or similar) algorithm
00:06:04 <edwardk> i'm amazed it works as well as it does for them
00:06:21 <wolverian> and python
00:07:00 * edwardk really dislikes reference counting. a good generational mark-sweep collector can be implemented with fork and IPC that doesn't block forward progress.
00:07:02 <wolverian> circular references are easy to avoid, in my experience, and weakened refs are most often code smell.
00:07:37 <edwardk> and copying collection is even btter if you can afford stall
00:07:39 <edwardk> er stalls
00:07:53 * jer is quite fond of tri-colour mark-sweep collectors ala baker
00:08:05 * edwardk nods.
00:08:28 <edwardk> i tend to implement by fork and mprotect. then walk the structure on my forked copy's internally consistent world view
00:08:42 <johnnowak> jer: i seem to recall a paper on the topic -- do you happen to know where i might snag it?
00:08:44 <edwardk> i can use the mprotect flags to indicate dirtying without interfering with code
00:08:47 <newsham> seems like functional-types get erect over GC algorithms.
00:08:52 <edwardk> and then ipc the results back to the main process
00:08:56 <jer> johnnowak, should be searchable on google
00:09:07 <edwardk> because if it wasn't reachable at fork time it can't be reachable now
00:09:09 <jer> johnnowak, i'm sure i've got a copy local here, but it's 3am, too lazy to look for ya, sorry
00:09:20 <johnnowak> jer: that's fine, if it is easy to find i'll find it :)
00:09:39 <jer> johnnowak, if it's not, let me know; i've got to do some archive hunting tommorrow, so i can look then
00:09:46 <johnnowak> okay, will do
00:09:53 <edwardk> bes of both worlds coz i can log everything for orthogonal persistence at the same time and keep the disk spinning in consecutive writes.
00:10:13 <edwardk> so i can even reboot right back into the process
00:10:24 <jer> johnnowak, same type of collector io implements actually =] steve may have a link to it too, never thought
00:10:34 <johnnowak> jer: yes, that's how i know of it :)
00:10:39 <jer> ah
00:11:19 <edwardk> johnnowak there is a decent book by jones and lins that covers the standard tricolor marksweep it among jst about all the other standard gc techniques
00:12:07 <edwardk> though its usually outperformed by a generational copying collector for java style programs
00:12:53 <johnnowak> ah, i found it, thank you edwardk
00:13:36 <edwardk> i rather highly recommend it =)
00:13:46 <johnnowak> i'll put it in my queue :)
00:14:09 <johnnowak> just a dozen or so things to knock down before i get to it...
00:14:13 <edwardk> heh
00:14:16 <jer> =]
00:14:31 <edwardk> i printed out about 2000 pages of random stuff this weekend to read. i know the feeling =/
00:14:42 <jer> edwardk, don't we all =]
00:14:49 <johnnowak> i go to art school. i have to do a lot of reading to even remotely keep up. :)
00:14:52 <jer> though as of late, i've been doing more writing than reading
00:15:23 <edwardk> i write until i get stuck on a point of proof, then i dive back into reading.
00:16:09 <edwardk> i seem to find it funny that in general computer scientists are more concerned with flavors of logic than mathematicians.
00:16:34 <edwardk> a mathematician just kind of assums ZF set theory and goes on his merry way assuming everything can be proven in that framework =)
00:17:12 <dons> well, we have to actually have machines follow all the steps, which makes for a concern about rigour
00:17:31 <edwardk> and a preference for construction
00:18:01 <edwardk> the existence of a value of a type is less useful than the construction of an actual value of that type.
00:18:29 <dons> yep
01:58:46 <dons> note to self: hs-plugins won't work right if you load .o files from a noexec file system
01:59:01 <dons> the linker tends to panic and have a nervous break down
01:59:32 <edwardk> heh
01:59:46 <edwardk> makes sense
02:01:26 <dons> it does!
02:01:52 <Igloo> dons: You saw the lambdabot problems, right?
02:02:07 <dons> Igloo: yep, and got mail from ganesh. all fixed: twas an nfs server that went down
02:02:22 <dons> with haskell thus mapping errno to the ominous "hardware fault"
02:02:29 <dons> cheer for dealing with that
02:02:41 <dons> s/cheers/
02:03:49 <dons> so HardwareFault just means some random IO error
02:04:01 <dons> EIO
02:04:39 <dons> hmm. this means ghci should panic if yoused to load an archive from a noexec file system
02:04:47 <dons> maybe it should check for executable-ness
02:04:53 <newsham> EIEIO
02:04:59 <dons> :)
02:06:59 <sieni> http://en.wikipedia.org/wiki/Computer_bought_the_farm
02:09:11 <newsham> heh.. hurd.. there's a poster child for software development
02:09:45 <dons> ah :)
02:10:00 <sieni> http://www.gnu.org/software/hurd/hurd.html#advantages
02:10:12 <sieni> the best joke of those is the "it exists" part
02:10:15 <lambdabot> Title: The GNU Hurd - GNU Project - Free Software Foundation (FSF)
02:31:56 <dons> Igloo, is this your first commit under your new job title? Mon Aug 21 02:22:26 PDT 2006  Ian Lynagh   * Missing stage1's in hc-build
02:31:58 <araujo> mmm....
02:32:00 <dons> ?
02:32:11 <araujo> sieni, you following the Hurd devel?
02:32:21 <Igloo> dons: Yup  :-)
02:33:01 <dons> :D
02:35:38 <sieni> araujo: nope
02:36:21 <boegel> Igloo: oh, right, congrats on the job... (bit late, but hey)
02:38:27 <araujo> sieni, ok , just asking now you are pasting that link here
02:39:20 <araujo> some people has been recommending to use Haskell (and therefore House as a model) for the Hurd development
02:39:40 <edwardk> hey i might actually LIKE hurd then =)
02:39:51 <Igloo> Hmm, cc has been working on Language/Haskell/Syntax.hs for >2 hours of CPU time, >10 hours of clock time
02:39:54 <araujo> It has quite of impressed me i say
02:40:04 <Igloo> boegel: Ta
02:40:08 <dons> Igloo: hmm, what arch?
02:40:08 <edwardk> the idea of moving? or the hurd in general?
02:40:19 <Igloo> mips
02:40:23 <araujo> edwardk, the idea of moving
02:40:44 <araujo> But it has just been proposed a few times lately on the mailing list
02:40:54 <dons> there's a bit of buzz around haskell in the OS world these days, what with the new L4 kernel spec in .hs
02:41:06 <dons> and lispire too, I suppose
02:41:15 <dons> grr. sticky 'n' key.
02:41:20 <dons> nnnnn!
02:41:24 * araujo doesn't know how the linspire people is doing though
02:41:43 <araujo> we need a more open distro using Haskell :-)
02:42:11 <araujo> But the idea of a Haskell OS is getting attraction from many on the community.
02:42:53 <araujo> And now that we have a very recent House version, it looks like there exist serious work going on.
02:42:56 <Igloo> Linspire are giving a talk at CUFP
02:43:10 * araujo hasn't tested this latest version yet
02:43:20 <dons> Igloo, yeah, that should be interesting
02:43:27 <Igloo> Will you be there, dons?
02:43:38 <dons> no :(
02:43:46 <Igloo> Bah
02:44:08 <araujo> I think that as soon as we get a command line prompt on House (a decent) one, i could get it installed on old boxes :-}
02:44:29 * araujo emulates with qemu atm
02:44:49 <dons> Igloo: maybe we should try to get MS to fly a few ghc hackers in for the hackathon ... ;)
02:45:00 <ths> Igloo: Got a successful mips build, I now try a rebuild without boot-from-hc.
02:46:21 <Igloo> ths: Cool
04:01:23 <mnislaih> ping Lemmih
04:10:09 <Lemmih> pong mnislaih
04:10:26 <mnislaih> Lemmih: did you try the debugger ?
04:10:45 <Lemmih> I'm still building (:
04:10:52 <mnislaih> what ?
04:10:55 <Lemmih> (from a clean repo this time)
04:11:03 <mnislaih> you mean that you found issues with my code ?
04:11:05 <mnislaih> ah, ok
04:11:29 <mnislaih> ok, I made a movie, I'm uploading it now to monk
04:11:42 <mnislaih> I'll give you a link when it's ready
04:11:50 <Lemmih> movie?
04:11:55 <mnislaih> yes, a short demo
04:12:01 <mnislaih> a show-off :)
04:12:42 <mnislaih> Lemmih, any ideas for exceptions ?
04:12:49 * Lemmih suspects that the GHC build system doesn't work on odd weekends and when the moon is full.
04:13:00 <mnislaih> it is a shame that we cannot capture them :(
04:13:58 <mnislaih> I posted some of my thoughts at the ghc wiki page for the project, in case you haven0't seen it
04:14:29 <dons> ?remember Lemmih suspects that the GHC build system doesn't work on odd weekends and when the moon is full
04:14:30 <lambdabot> Done.
04:20:05 <ths> What sort of CPU registers are better to use in GHC, caller-saved or callee-saves ones, or a mix of both?
04:21:29 <ths> AFAIU the code generator can use up to 8 registers for general purpose, mips hardware has some more to offer.
04:23:44 <dcoutts> hi ths
04:24:11 <ths> dcoutts: Hi.
04:24:15 <dcoutts> ths, there's a header file where all this is defined and you can see what other arches use
04:24:30 * dcoutts tries to remember which file..
04:25:01 <dcoutts> ths, so Igloo's the unegistered build worked ok on mips then?
04:25:09 <ths> The comments there suggest callee-saved is better, but give no rationals for that.
04:25:29 <dcoutts> ah you found it
04:25:53 <ths> I bootstrapped my own, currently I do a native rebuild.
04:26:01 <dcoutts> cool
04:26:50 <ths> I would expect a mix of caller and callee saved register would be best if the compiler uses them well.
04:27:04 <dcoutts> ths, the best answer you're likely to get is if you post to the ghc users list and if Simon replies
04:27:14 <eivuokko> Not that I am expert, but I think ghc register allocator (for native cg) is fairly good with callee-saved regs.
04:27:41 <eivuokko> Err, caller-saved, I meant.
04:28:27 <ths> eivuokko: Well, both have drawbacks, depending on the use. I don't know what the typical use pattern looks like.
04:28:37 <mnislaih> Lemmih, let me know what you think: http://darcs.haskell.org/SoC/ghc.debugger/demo.mov
04:29:52 <dcoutts> ths, Simon Marlow is back from holiday today, so you might get a response if you ask
04:30:12 <ths> dcoutts: I'll try that, thanks.
04:30:45 <dcoutts> ths, so you're trying to do a regesterised build... :-)
04:30:48 <dcoutts> then the step after that is the evil mangler
04:31:05 <dcoutts> but I'm sure you knew that
04:31:31 <ths> AFAIU the documentation the mangler is required for a registerised build.
04:31:41 <dcoutts> yes
04:31:56 <dcoutts> it does all sorts of post-processing of the assembly output from gcc
04:32:10 <dcoutts> hence the name evil mangler
04:32:37 <dcoutts> we were trying to get a regesterised build working on alpha, it's not all that easy.
04:32:39 <ths> Cutting off prologue/epilogue etc, a bit like qemu.
04:32:55 <dcoutts> yes since ghc doens't use the C stack
04:33:24 <dcoutts> and also rearanging code and data to place certain bits of data right next to the code it describes
04:33:37 <ths> IOW, it will blow up the same way than qemu when the C functions get too complicated. :-)
04:33:41 <dcoutts> which saves an indirection in a fast path
04:34:12 <ths> That's only for readonly data, I hope.
04:34:17 <dcoutts> ths, yes
04:34:18 <dcoutts> ths, you mean problems when the C code spills too many registers?
04:34:56 <ths> Or decides it's a good time for alloca, or does some other weird transformation.
04:34:57 <xerox> dcoutts: yarrr
04:35:02 <dcoutts> hia xerox
04:35:03 <dcoutts> @arr
04:35:04 <lambdabot> Ahoy mateys
04:35:27 <dcoutts> ths, yes, I don't know the details of what happens then
04:35:37 <xerox> dcoutts: Isaac mailed me, but since he was flying he hadn't time to try cabal-install yet. On the other hand he thinks multiple repositories is a must before release.
04:36:18 <xerox> I can't think of a flawless approach, tough.
04:36:30 <dcoutts> ths, the long term plan is to move away from compiling via gcc on most arches since, partly because of these headaches and partly because gcc can't generate good code in the way in which ghc uses it.
04:36:43 <xerox> *though
04:37:13 <dcoutts> xerox, what about the multiple local dirs named by an encoding of the remote url ?
04:37:39 <dcoutts> xerox, so each remote repo gets downloaded to a corresponding local dir, upacked and whatever
04:38:02 <ths> dcoutts: Well, that's the obvious way, but it's also a huge task.
04:38:02 <dcoutts> xerox, then when looking for local packages, just scan all the local dirs
04:38:47 <xerox> dcoutts: ok, the other code, the one actually fetching/installing packages uses the ominous packages/, so I should have it lookupping the repository information too
04:39:00 <dcoutts> ths, well they've already got native code generators for x86,x86-64,ppc32 and sparc32. Then the less supported arches would continue to use unregesterised C.
04:39:11 <xerox> Well, in fact if it uses PkgInfo it has the information at that point, so it shouldn't be much difficult
04:39:27 <dcoutts> xerox, aye
04:40:07 <xerox> Okay... big patch for my standards, hehe.
04:42:05 <xerox> How does one create a bytestring now?
04:47:12 <mux> you mean from a String?
04:47:25 <xerox> Yes
04:48:02 <mux> mmm, don't know, I've always had bytestrings created by using hGetContents on a file
04:48:12 <eivuokko> Depends what you need it for, but I think only way in base-2.0 is Data.ByteString.Char8.pack
04:49:59 <mux> yeah, looks like it indeed
04:52:14 <luis> Hmm, in exercise 4.5 of the "Yet Another Haskell Tutorial" I'm supposed to define a Quadruple whose first two elements have the same type and whose last two elements have the same type too. What's wrong with  data Quadruple a a b b = Quadruple a a b b  ?
04:52:46 <JohnMeacham> http://repetae.net/computer/frisby/
04:55:55 <eivuokko> luis, There's only two types, so type constructor should only take two parameters.  What you try is just impossible because there's no pattern matching/equality checking/anything like that on type level (atleast for data decls) - the type variables simply must all have diffrent names.
04:56:46 <luis> eivuokko: ah, so  data Quadruplle a b = Quadruple a a b b  then.
04:56:59 <eivuokko> luis, That looks like valid haskell, yes.
04:57:04 <luis> eivuokko: thanks.
04:59:24 <eivuokko> luis, It is similar to let a=1; a=1; <- creating a group with two variables of same name is impossible, each decl is for one variable and their names must be distinct in that group.
04:59:58 <eivuokko> (Except of course let does pattern matching, which data decl doesn't do)
05:06:26 <dcoutts> @tell ndm the cabal/ghc relinking patch looks fine, except it doesn't apply cleanly to the current darcs version of cabal. I'd apply it manually but then you wouldn't get the credit in the changelog! :-)
05:06:26 <lambdabot> Consider it noted.
05:07:32 <dcoutts> eivuokko, so that xargs stuff, for windows you wanted me to use 30k or something like that?
05:07:45 <dcoutts> with that would it be ok to commit do you think?
05:09:33 <eivuokko> dcoutts, I think there should option to change it, becase I don't know what the size depends on.
05:09:58 <eivuokko> But 32k won't work for me, that's for sure.
05:11:16 <dcoutts> eivuokko, how would a user know what to change it to? I think we should just find something that works.
05:11:35 <dcoutts> perhaps we should just try 30 and see if anyone reports problems
05:11:45 <dcoutts> it'll fail with an error message right?
05:12:13 <dcoutts> if it overflows? so it won't fail silently and just miss off files to the linker right?
05:12:36 <eivuokko> It fails with something dubious
05:12:42 <eivuokko> Like invalid command or paramter
05:14:42 <eivuokko> But sure, 30k and wait for feeback is fine with me
05:14:47 <xerox> mnislaih: how can you code with that CRAZY synhl?
05:15:01 <xerox> mnislaih: I tried writing a better one but I was put off by the regexp parsing....
05:15:16 <mnislaih>  you mean textmate ?
05:15:23 <mnislaih> I don't use it, I use Emacs
05:15:40 <mnislaih> did you like the video xerox ?
05:16:29 <xerox> I do use Emacs too, hehe
05:16:41 <mnislaih> which one, Carbon or Aqua ?
05:16:52 <xerox> The former
05:17:19 <mnislaih> yeah, I'm using the Carbon one too
05:17:47 <mnislaih> the video doesn't show it, but my Universal Machine is still buggy o.o
05:18:08 <xerox> Yuck I deleted it by accident, let me re-download it
05:18:27 * tibbe got his external monitor working today so now he can enjoy more Emacses at the same time :D
05:19:19 * mnislaih goes for dive before lunch
05:20:03 <Igloo> What's wrong with that synhl?
05:20:39 <xerox> Igloo: yuck, it's like using the Java one for shellscripts :P
05:21:06 <Igloo> Ah, it's that one. Just not obvious from the start of the .mov
05:21:55 <eivuokko> dcoutts, Thanks.  (seeing the patch applied-mails)
05:21:57 <xerox> Well, it is the Haskell one for TextMate. But it is "in developement", and really broken.
05:22:32 <Igloo> Right, I think I saw it at AngloHaskell
05:23:07 <xerox> That was Duncan's crazy editor with a random highlighting, yes, it's very similar :P
05:23:32 <Igloo> Ah, OK
05:34:02 <dons> @seen ndm
05:34:03 <lambdabot> I haven't seen ndm.
05:34:08 <dons> ?where NewBinary
05:34:08 <lambdabot> darcs get http://www.n-heptane.com/nhlab/repos/NewBinary
05:35:06 <xerox> dons: yarr!
05:39:43 <Cale> nice, you can hover over a desktop in the gnome pager during drag and drop and it will swap over to it
05:40:08 <xerox> mnislaih: !!! is as long as M.! hehe
05:40:27 <Cale> xerox: but less ugly :)
05:40:39 <xerox> ...more informative? :)
05:41:14 <Cale> so what is this demo about? I haven't watched it yet.
05:41:26 <xerox> GHCi debugger
05:41:59 <Cale> Is there supposed to be audio?
05:44:25 <xerox> I would have liked that
05:44:28 <xerox> It seems not
05:46:54 <Cale> oh, hey, rather cool
05:47:03 <xerox> Indeed.
05:50:25 <xerox> I wonder if you could in the end shadow the ib binding, or change it
05:50:34 <xerox> (thus fixing the code at runtime)
05:50:50 <Cale> I wonder if there's conditional breakpoints
06:05:53 <xerox> dcoutts: how does one get push access to Cabal?
06:06:21 <dcoutts> xerox, with an account on darcs.haskell.org
06:06:37 <xerox> SyntaxNinja wants me to push them, he mails.
06:06:45 <xerox> s/them/the patches/
06:10:48 <xerox> Who should I ask for an account on darcs.haskell.org?
06:11:12 <Igloo> Simon Marlow is probably as good as anyone
06:11:42 <xerox> Okay!
06:12:19 <xerox> (Who's anyone? Isn't Marlow on vacation?)
06:12:50 <tibbe> xerox, I think he's pack, he's applying patches at least
06:13:04 <xerox> Mobile phones are smart these days :P
06:13:06 <xerox> Hehe, okay.
06:14:35 <tibbe> s/pack/back :D
06:14:59 <tibbe> (odd slip b->p, they're not even close)
06:16:17 <Igloo> SM was away last week, SPJ is away this week
06:19:35 <tibbe> how many people are paid to work at GHC? SM and SPJ?
06:20:14 <tibbe> I understand that they might do more than just work at GHC...
06:21:21 <Igloo> SM, SPJ and, as of today, me
06:21:48 <dons> yay Igloo!
06:22:09 <Igloo> :-)
06:22:15 <xerox> What happened to lambdabot yesterday dons? :(
06:22:29 * dons sings "Patches, patches .. patches!!" to the tune of "mumbo,mumbo, mumbo!"
06:22:51 <tibbe> :D
06:23:02 <dons> xerox: nfs server failed, thus disk IO returned EIO, which is reported as "HardwareFailure" exceptions in System.IO
06:23:05 * Igloo looks blank
06:23:14 <xerox> Yuck.
06:23:32 <dylan> EIO, EIO, oh?
06:23:50 <gour> Igloo: congrats. you win AngloHaskell marathon?
06:24:04 <gour> Igloo: s/win/won
06:24:06 <dons> ah, "conga conga conga!"
06:24:17 <xerox> badger badger badger
06:24:24 <dons> also, "You don't make friends with salad!"
06:24:44 <Igloo> gour: Well, AngloHaskell was just colocated with the interviews, but yeah
06:24:55 * Igloo is enlightened  :-)
06:25:03 <gour> Igloo: :-)
06:25:27 <dons> hehe
06:25:49 <gour> Igloo: will darcs-dev suffer now?
06:28:10 <xerox> So there will be the hackaton here <http://hackage.haskell.org/trac/ghc/attachment/wiki/Hackathon/TrainingCenter033.jpg> yarr, lots of Hackers per square menter.
06:28:14 <xerox> Hello JaffaCake!
06:28:18 <JaffaCake> hiya
06:28:35 * Igloo wasn't doing darcs hacking anyway, just discussion of the merger replacement, which I will keep on doing
06:29:02 * gour is glad to hear that
06:29:29 <dcoutts> hi JaffaCake, we've missed you
06:30:18 * xerox nods
06:30:20 <dcoutts> JaffaCake, sorry about that .ident thing, I only did it because I could. :-)
06:30:28 <xerox> G'day int-e
06:30:32 <dcoutts> I think Igloo's patch is probably right
06:30:37 <JaffaCake> dcoutts: not at all
06:30:56 <JaffaCake> Igloo can sort it out
06:31:14 <dcoutts> ok, good :-)
06:34:11 <dcoutts> Igloo, so actually it's #if !( darwin_TARGET_OS && powerpc_TARGET_ARCH)
06:34:30 <dcoutts> as it only breaks OSX's assembler on ppc
06:36:45 <dcoutts> JaffaCake, I'll have to get back to you later about the space profiling. I'm busily writing about ByteStrings atm. :-)
06:36:51 <dcoutts> thrashing C is fun.
06:37:03 <JaffaCake> :)
06:37:20 <JaffaCake> I can't see any obvious problems with the space profiling, did some quick tests on x86_64
06:37:46 <JaffaCake> -hb gave the right magnitude on the test I did
06:37:59 <dcoutts> JaffaCake, I didn't think it was just the extra overhead of compiling with profiling on
06:38:13 <dcoutts> as I got similar results without profiling
06:38:19 <JaffaCake> ok
06:38:25 <dcoutts> I mean -M50 or whatever giving heap exhaustion
06:38:31 <JaffaCake> how about -xt?
06:38:46 <dcoutts> that's to include stacks right?
06:38:50 <JaffaCake> yup
06:38:51 <dcoutts> I think I tried that
06:39:04 <dcoutts> it was not significant in the space profile
06:39:12 <JaffaCake> also +RTS -Sstderr will give you an idea about the real residency (-M is a bit unreliable)
06:39:12 <dcoutts> our stuff mostly runs in constant stack space
06:39:51 <JaffaCake> on the other hand if you have some good evidence that -M is behaving really strangely, we should investigate (we do have a couple of bugs open on this though, IIRC)
06:39:51 <dcoutts> ok, I'll try that after the paper deadline :-)
06:40:13 <dcoutts> right, I'll try and find something you can easily reproduce
06:40:27 <dcoutts> it shouldn't be hard, it's just using fps
06:40:40 <dcoutts> which will be up to date in base soonish I hope
06:40:50 <JaffaCake> great
06:41:05 <JaffaCake> cutoff is the end of this week, in case you weren't aware (That's the RC date)
06:41:16 <dcoutts> right, dons make a note of that
06:41:50 <dcoutts> @tell dons JaffaCake says the cutoff for updating fps in base "is the end of this week, in case you weren't aware (That's the RC date)"
06:41:51 <lambdabot> Consider it noted.
06:41:57 <araujo> yay!
06:42:34 * araujo wrote a script to interface shell commands with ghci
06:42:45 <dcoutts> JaffaCake, yeah, we've got some api tidyups to make which really should go in before 6.6 or we'll never be able to change them
06:43:01 <JaffaCake> right
06:43:35 <dcoutts> JaffaCake, presumably we can change the implementation quite a bit so long as we don't chage the api (or semantics)
06:43:47 <JaffaCake> that's right
06:44:10 <JaffaCake> careful though, strictness changes count as an API change
06:44:20 <dcoutts> @tell dons so perhaps if we're too rushed then just sync the api in base with what we've got now but keep the impl
06:44:21 <lambdabot> Consider it noted.
06:44:37 <dcoutts> JaffaCake, we change strictness with rewite rules, but we call it refinement ;-)
06:44:48 <dcoutts> actually it's not strictness exactly
06:44:55 <dcoutts> it's discarding bottoms
06:44:59 <JaffaCake> sounds dodgy
06:45:12 <dcoutts> we think we can formally justify it as refinement
06:45:34 <JaffaCake> so a program that should return _|_ may terminate instead?
06:45:38 <dcoutts> yes
06:45:47 <JaffaCake> strictly speaking that's bad
06:46:01 <dcoutts> if you do head (pack [1, undefined])
06:46:04 <JaffaCake> although I believe GHC does it occasionally
06:46:15 <dcoutts> then it can fuse and discard the _|_
06:46:29 <dcoutts> when it doesn't fuse then it's _|_
06:46:31 <JaffaCake> I see
06:46:48 <JaffaCake> maybe there's no good way around that
06:47:05 <dcoutts> because our arrays are strict
06:47:13 <JaffaCake> yes
06:47:26 <dcoutts> for lists the fusion rules would be true
06:47:26 <mnislaih> xerox, Cale, there is no audio ?
06:47:33 <Cale> nope
06:47:38 <mnislaih> damn! I uploaded the wrong file :S
06:47:42 <dcoutts> or rather equalities rather than refinements :-)
06:47:51 <mnislaih> there is supposed to be audio, my fault
06:48:01 <JaffaCake> dcoutts: it's somewhat unsavoury, I hope you have a convincing justification :)
06:49:32 <dcoutts> JaffaCake, my supervisor was joking the people from Oxford are comfortable with refinement and the rest of the world seems to want only equality
06:49:50 <dcoutts> afterall what is the problem with making a program terminate with a sensible answer when otherwise it would have been _|_
06:50:09 <JohnMeacham> Hmm.. heliums custom error messages would be great right now. I am writing a library, that works very well, but any errors by the user tend to give very cryptic messages. as in, cryptic to me as a writer of the library. perhaps some liberal newtypes will help.
06:50:21 <JaffaCake> different compilers will behave differently, and even GHC will behave differently with different flags
06:50:31 <JaffaCake> normally that behaviour is restricted to the IO monad
06:50:34 <Igloo> The problem is that someone writes a program that terminates, then makes an innocuous change such that the RULE doesn't happen and it no longer works
06:51:06 <Igloo> (or compiles without -O?)
06:51:09 <JaffaCake> yes, that too
06:51:47 <dcoutts> in our case it's not really a practical problem since we don't expect people to be packing _|_'s into their strings
06:51:49 <Igloo> If you always wrote to an array at the end of your pipeline and then, when finished writing, read from that final array, would that maintain the structness properties?
06:51:57 <SamB> dcoutts: good point...
06:52:05 <dcoutts> and they'll find the _|_ when the compile without -O
06:52:23 <dcoutts> Igloo, yes, and loose much of the performance improvements
06:52:33 <dcoutts> head (something very long)
06:52:48 <dcoutts> we only need to do the first one if we fuse
06:52:55 <JohnMeacham> JaffaCake, it does, occasionally. it will eta expand some things proactively, which could cause under just the right circumstances a seq that used to bottom out now terminate. not that that is a problem.
06:52:58 <dcoutts> to preserve stictness means reading the whole lot
06:53:07 <dcoutts> and it means we can't lazily read from an array
06:53:27 <dcoutts> at least we can fuse and then lazily read
06:54:02 <JaffaCake> JohnMeacham: yes, I remember now.... case x of p -> \y . e   ==> \y . case x of p -> e
06:54:05 <Igloo> Could you put the unsafe rules in a Data.ByteString.UnsafeFusion module?
06:54:23 <dcoutts> Igloo, we could turn off fusion
06:54:50 <JohnMeacham> yeah. eta expansion has a huge effect in terms of enabling other optimizations. I was really surprised about how much it improved things in jhc.
06:55:16 <JaffaCake> it's a good argument in favour of not having polymorphic seq
06:55:38 <dcoutts> Igloo, since we include functions like lazy foldl in addition to strict foldl' then any fusion can discard _|_'s
06:55:51 <JohnMeacham> well, seqing function types is useful in practice.
06:56:10 <JaffaCake> JohnMeacham: yes, there's no good solution
06:56:54 <JaffaCake> but I suppose the current compromise works well in practice, very few people complain that GHC miscompiles things because of this
06:57:39 <dcoutts> JaffaCake, and I expect it'll be the same for our byte strings
06:57:56 <dcoutts> JaffaCake, it'd be more prolematic for a more generic fusable sequence thing
06:58:02 <JohnMeacham> I don't mind polymorphic seq so much. they do create some oddness in the compiler implementation like thinking about cases above, but it is not the trickiest thing about writing a haskell compiler by far.
06:58:12 <dcoutts> but in that case one could always make it a lazy array and then it'd be ok again.
07:02:02 <JohnMeacham> I think I have reached a new level of density of required extensions to implement something. GADTs, rank-n polymorphism, recursive do, and unsafeCoerce#. I used to have existentials in there too.
07:02:31 <JaffaCake> JohnMeacham: I dislike polymorphic seq simply because it means that eta is often invalid, and as you say, eta is so useful
07:04:14 <SamB> so how do you do non-polymorphic seq?
07:04:16 <JohnMeacham> JaffaCake, but eta expansion isn't generally appliable due to loss of sharing moreso than the effect of seq I think
07:06:53 <JohnMeacham> I actually implemented something that depended on not being eta expanded for efficiency recently. I should look at the core to ensure it isn't now that I think of it. but I don't think it will be, it is of the form f x = let .... in \y -> stuff where '...' is a lot of non-floatable things.
07:07:25 <JaffaCake> maybe... but the one you need to catch is eta-expanding a case expression, because all IO functions have that pattern, and that's invalid.  Without that you have little hope of getting good perf from IO code
07:09:09 <JaffaCake> true that needing to avoid duplication of work prevents eta, yes
07:09:27 <JohnMeacham> yeah, but use-one analysis can catch those hopefully. and there is the always treat things of type World# as one-shot hack in ghc.
07:10:11 <JaffaCake> we don't have a usage analysis (yet - Simon wants to put it in)
07:10:34 <dcoutts> JaffaCake, is that the thing that'd help for foldl in terms of foldr ?
07:10:42 <JohnMeacham> I wonder if a PRAGMA for saying, treat this type as always one-shot would be useful. so, you could do that inside the state transformer monads
07:10:50 <dcoutts> ie allow you to get effecient code for fusing foldl
07:10:53 <JaffaCake> dcoutts: I vaguely remember something like that, yes
07:11:29 <dcoutts> JaffaCake, I was just writing about that, saying why we were able to fuse foldl and build/fold currently doesn't.
07:11:56 <dcoutts> we've got an example where we fuse: foldl f z . map g . filter p
07:12:11 <dcoutts> but for lists ghc can only fuse the map . filter, not the foldl
07:12:15 <JohnMeacham> I was under the impression this was used http://citeseer.ist.psu.edu/wansbrough00simple.html... but then again, I have read at least 5 different papers claiming to document the ghc strictness analyser :) papers always need to have a date in bold print on the first page, it is something hard to figure out which one is the most recent.
07:12:40 <benja_> hmm, isn't the GHC executable usually called 'ghc'?
07:12:43 <SamB> GHC version number would be nice too
07:12:52 <JaffaCake> Keith Wansborough's analyser was never fully implemented
07:12:54 <SamB> benja_: sometimes it is called ghci
07:13:21 * benja_ notes that according to cvsweb, the README has claimed that it's usually called "hsc" for the last ten years
07:13:28 <benja_> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/ghc/compiler/README?rev=1.2
07:13:30 <lambdabot> Title: fptools/ghc/compiler/README - view - 1.2
07:13:56 <JaffaCake> benja_: heh, the whole CVS repository is deprecated :)
07:13:59 <SamB> benja_: I don't think anyone reads the README ;-)
07:14:11 <eivuokko> benja, You might want to check darcs repos that are more current for devel: http://darcs.haskell.org/
07:14:13 <lambdabot> Title: Index of /
07:14:17 <SamB> JaffaCake: it hasn't been for the last ten years...
07:14:27 <benja_> so I'm nobody :-(
07:14:40 <JaffaCake> benja_: the latest README is here:  http://darcs.haskell.org/ghc/README
07:15:01 <benja_> JaffaCake: ok :)
07:15:14 * benja_ found the cvsweb repo through google
07:15:22 <SamB> JaffaCake: and it does not say the same thing?
07:15:25 <JohnMeacham> JaffaCake: ah, I have partially implemented it, but for strictness analysis. I didn't extend it to the full language though and moved to a more conventional first order analysis.
07:15:29 <JaffaCake> SamB: right
07:15:32 <benja_> actually, it doesn't
07:15:53 <benja_> I think it's been updated because of the move to the darcs repo :)
07:16:06 <SamB> ah
07:16:12 <JaffaCake> JohnMeacham: are you doing the same kind of demand analysis as GHC?
07:16:16 <JohnMeacham> JaffaCake: though, I should try implementing his directly. His thesis is sitting next to me right now.
07:16:35 * SamB waves to the thesis
07:16:50 <benja_> heh, no:
07:16:51 <benja_> http://darcs.haskell.org/ghc/compiler/README
07:16:58 <benja_> it hasn't been updated =)
07:17:27 <JohnMeacham> JaffaCake: I am now, almost exactly the same actually. except I don't do the 'boxing' analysis as the worker-wrapper transform is helpful in jhc even when it doesn't allow unboxing.
07:17:33 <JaffaCake> oh blimey
07:17:58 * JaffaCake blows the dust off http://darcs.haskell.org/ghc/compiler/README
07:18:29 <dcoutts> heh, yeah that's old :-)
07:18:45 * dcoutts remembers hsc
07:18:53 * JaffaCake too
07:18:58 <Igloo> I think README /was/ that pile of dust
07:18:59 * SamB didn't think there was much likelyhood of anyone having changed it
07:19:04 <SamB> Igloo: haha
07:19:09 <JaffaCake> heh
07:19:31 <SamB> fortunately it is under version control, so JaffaCake can revert it ;-)
07:19:50 <SamB> if that would even be an improvement
07:19:56 <JohnMeacham> but I have experimented with at least 3 other implementations, an abstract interpretation one. the one based on HORN clauses, and a modification of wanesboroughs algorithm. only the first was extended to the full language.
07:20:40 * benja_ notes that there is no 'tests' subdirectory any longer, either
07:20:58 <benja_> but otherwise the README still appears correct =)
07:22:05 <JaffaCake> it's now gone
07:22:46 <benja_> hm, is there any place to read the GHC source as latex2html output?
07:23:33 * benja_ looks more closely and wonders whether the lhs files are really tex or just pretend to =)
07:23:42 <JaffaCake> benja_: yes, but you need to download a copy of GHC 0.16 (or thereabouts)
07:24:35 <benja_> huh =)
07:25:18 <benja_> [first time for me to look at the GHC source, in the unlikely case you couldn't tell.]
07:27:10 <int-e> how about http://darcs.haskell.org/ghc/compiler/ for browsing?
07:27:12 <lambdabot> Title: Index of /ghc/compiler
07:27:50 <benja_> oh, I'm using that, I just thought that the lhs files were formatted as TeX and I don't enjoy reading that in source form...
07:28:17 <int-e> I see.
07:28:51 <SamB> ah, maybe they were once ;-)
07:29:06 <zeeeee> hi all, this page describes a drawback of fp. i was wondering if there are other resources that describe fp's drawbacks (these are hard to dig up). http://www.cs.hmc.edu/claremont/keller/webBook/ch04/sec18.html
07:29:08 <lambdabot> Title: Perspective: Drawbacks of Functional Programming
07:29:35 <int-e> I was just going to say that. There doesn't seem to be anything left except for \begin{code}, \end{code} and the occasional \subsection{...}
07:29:36 <sjanssen> zeeeee: that's because there aren't any drawbacks ;-)
07:30:04 <benja_> \section, too, and % comments at the beginning of the files =]
07:30:06 <SamB> well, certainly it is not the *only* model to consider ever
07:30:22 <SamB> for instance, it currently does not seem to work too well for simple
07:30:24 <SamB> VMs
07:30:40 <int-e> it would look awful texed.
07:30:44 <SamB> well, maybe strict languages would...
07:30:47 <zeeeee> also, has writing such apps like this histogram-builder ever been addressed? it seems like such a common app - i always need to build counts of bigrams in large text corpuses. this seems like a huge drawback to me.
07:31:01 <mnislaih> Cale, xerox, Igloo: I've fixed the video and now it has proper audio, in case you want to check it
07:31:06 <mnislaih> http://darcs.haskell.org/SoC/ghc.debugger/demo.mov
07:31:26 <Cale> mnislaih: 404'd!
07:31:28 <SamB> zeeeee: well, Haskell supports imperative code as well
07:31:29 <Jaak> Server returned 403: Forbidden
07:31:40 <sjanssen> zeeeee: remember that we can program in an imperative style in Haskell with Monads like IO and ST
07:31:41 <SamB> you can even get pure imperative code!
07:31:47 <SamB> with ST
07:31:57 <mnislaih> ah, you are a bit too fast
07:32:00 <mnislaih> try now
07:32:16 <Cale> okay :)
07:32:22 <benja_> mnislaih: =-)
07:32:36 <SamB> @type newArray
07:32:39 <lambdabot> Not in scope: `newArray'
07:32:45 <SamB> @hoogle newArray
07:32:46 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
07:32:46 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
07:32:46 <lambdabot> Foreign.Marshal.Array.newArray :: Storable a => [a] -> IO (Ptr a)
07:33:19 <zeeeee> SamB, sjanssen: how much does this impact the fp part of haskell? if i'm going to end up mixing fp and stateful programming anyway, why not just stick to a more 'relaxed' language?
07:33:25 <Cale> zeeeee: We have mutable arrays in Haskell, though using them obviously requires you to program at least somewhat imperatively
07:33:37 <SamB> zeeeee: Haskell is very relaxed! lazy even~
07:33:42 <SamB> s/~/!/
07:34:01 <Cale> zeeeee: You get better control over which parts of your program are affected by and cause side effects
07:34:53 <Cale> zeeeee: For instance, you might write the function which builds the histogram using a mutable array in the ST monad, and then externally, there are no side effects, it's a pure function, and you have a guarantee of that.
07:36:11 <Cale> Also, even without mutable data structures, there are data structures which have O(log n) access and modification of elements.
07:36:18 <SamB> Cale: or I might
07:36:27 <Cale> (for instance, Data.Map provides one of these)
07:37:15 <tibbe> For the Hackathon page: "One full day of tutorial from Simon PJ & Simon M about GHCâ€™s glorious innards (14th)". Is there any chance there'll be any slides available from that talk?
07:37:20 <SamB> if you aren't careful you might end up with something equivalent to Nats in your Map, though...
07:37:53 <benja_> in entirely practical terms, the smaller community causes problems like less specialized libraries being available
07:38:12 <Cale> SamB: sure, also, you could use a strict Map datastructure if you really didn't want to seq the updates by hand.
07:38:51 <SamB> could it be a newtype over the lazy one?
07:38:58 <Cale> yeah
07:39:07 <Cale> I think that would work well enough
07:39:21 <benja_> other than that, most things that come to mind as drawbacks (depending on your perspective) of Haskell are things related to other design choices than "being functional"
07:39:31 <SamB> well it isn't like you'd get unboxing for polymorphic fields anyway
07:40:07 <JohnMeacham> Okay, updated my frisby parser. It is interesting, frisby is a parser of PEG languages, which allow unlimited lookahead with no backtracking. it is sort of the converse of a parsec or ReadP style parser, where you can use a monad to build up a history, and decide where to go forward based on your history, or whether to back up and try a different path, and perhaps maybe look a token or two ahead. with a PEG based parser
07:40:07 <JohnMeacham>  you have no history, but you can see arbitrarily far into the future. as in, future values may be examined well before the parser commits to that path, so the future value can't depend on the path taken. so, parsec lets you see the past, frisby lets you see the future. parsec is formulated as a monad, perhaps frisby can be formulated as a co-monad? something to ponder.
07:40:20 <SamB> hmm
07:40:46 <xerox> JohnMeacham: like readS look?
07:40:54 <SamB> is building a monadic value with foldr a good idea?
07:40:59 <zeeeee> hmm...interesting...are there any resources that can give me more knowledge/insight about how fp compilers work? (eg, how optimizations are done and in particular haskell's compiler) preferrably something requiring less background/concentration than academic papers :)
07:41:10 <SamB> oh wait
07:41:16 <JohnMeacham> this is the link http://repetae.net/computer/frisby/.  it is still pretty raw, but can parse megabytes of source text in seconds that backtracking parsers completely barf on.
07:41:16 <SamB> mapM_ should work nicely
07:41:39 <JohnMeacham> xerox: no. ReadS is a backtracking or nondeterministic parser depending on how you look at it.
07:42:24 <JohnMeacham> as far as I know, this is the first implementation of packrat parsing as a plain old library and not a dedicated preprocessor.
07:42:33 <benja_> zeeeee: there's http://hackage.haskell.org/trac/ghc/wiki/GhcPapers
07:42:36 <lambdabot> Title: GhcPapers - GHC - Trac
07:42:55 <benja_> mostly or entirely academic papers, though, I believe
07:43:05 <benja_> then there's spj's book from the 80s
07:43:07 <JohnMeacham> academic papers are great.
07:43:27 <Cale> JohnMeacham: Some of the Haddock is slightly broken.
07:43:32 <JohnMeacham> much more approachable than books I find.
07:43:59 <benja_> zeeeee: http://research.microsoft.com/~simonpj/Papers/slpj-book-1987/index.htm
07:44:00 <lambdabot> Title: The Implementation of Functional Programming Languages
07:44:04 <JohnMeacham> Cale: it is using a broken version of haddock :) I had to add support for GADTs and turning off unboxed tuples to get it to parse it properly.
07:44:07 <benja_> and, http://research.microsoft.com/~simonpj/Papers/pj-lester-book
07:44:08 <lambdabot> Title: Simon Peyton Jones: book
07:46:36 <JohnMeacham> but I see what you mean. I'll look at it when I wake up.
07:47:52 <SamB> @paste
07:47:53 <lambdabot> http://paste.lisp.org/new/haskell
07:49:07 <lisppaste2> SamB pasted "histogram function" at http://paste.lisp.org/display/24489
07:51:13 <SamB> zeeeee: wanna see?
07:56:29 <benja_> zeeeee: http://www.citeulike.org/user/Benja/tag/implementation :-)
07:56:31 <lambdabot> Title: CiteULike: Benja's implementation
08:01:41 <zeeeee> SamB: i do have a lot more to learn about haskell before i can fully understand that code, but thanks a lot for posting it; i've saved this snippet
08:15:04 <SamB> hmm, is there a way to get GHC not to try to fit dumps into 80 chars?
08:26:18 <kosmikus> congratulations, Igloo
08:29:30 <Igloo> Thanks, kosmikus
08:32:50 <psnl> Igloo: I assume you got the job, well done!
08:33:08 <Igloo> Yup, and thanks
08:35:38 <xerox> Using the urlEncoded URIs for the name of the repositories directory feel so ugly :(
08:36:17 <SamB> eww, yeah!
08:36:49 <xerox> But it seems convenient.
08:37:07 <xerox> Any ideas?
08:37:38 <SamB> it does seem *reasonable*
08:48:56 * edwardk waves ello.
08:49:18 <xerox> Fail: takeLock /srv/darcs/packages/Cabal/_darcs/lock in /srv/darcs/packages/Cabal: permission denied (Permission denied)
08:49:45 <xerox> Do I need to be in some group on darcs.haskell.org to push?
08:50:38 <xerox> ....in the darcs group.
08:56:05 * SamB would like to see a nice GUI library written in Haskell sometime...
08:57:32 <eivuokko> What's "nice"?
08:57:45 <mux> gtk2hs doesn't qualify as nice? :-)
08:57:49 <mux> or rather, GTK+
08:57:52 <SamB> mux: note the "written in Haskell"
08:58:02 <mux> oh.
08:58:08 <dcoutts_> good luck talking directly to the X server
08:58:12 <mux> I wouldn't find it all that useful
08:58:28 <eivuokko> dcoutts, what does X11-package do?
08:58:37 <dcoutts_> it uses xlib
08:58:42 <dcoutts_> which is worse
08:58:44 <es> (<- Haskell programmer wannabe) SamB and others what choice you have for GUI besides GTK and the almost dead QT binding?
08:59:00 <dottedmag> dcoutts_: not so hard (especially when XCB will be in production)
08:59:01 <SamB> well, there is the rather stale wxHaskell
08:59:02 <eivuokko> wxhaskell
08:59:13 <eivuokko> For Windows there's also ObjectIO ;)
08:59:34 <dcoutts_> es on linux you can use Gtk2Hs binding to Gtk+ or wxHaskell which binds to wxWidgets (and wxWidgets binds to Gtk+)
08:59:38 <es> eivuokko, yeah wxhaskell I meant sorry
08:59:46 <dcoutts_> dottedmag, yes, that would help greatly
09:00:20 <es> ok but I saw wxhaskell is almost not mantained anymore ...
09:00:24 <eivuokko> Btw, why is hard to talk to X server?
09:00:35 <eivuokko> es, That's changing, it's getting new life soonish (probably)
09:01:12 <es> that would be great
09:01:18 <SamB> mainly I'd just like to see *how* it would be done, because the techique used in gtk2hs at least does not seem like it would work well...
09:01:27 <eivuokko> es, Yes.  I am waiting eagerly.
09:01:28 <SamB> er, technique
09:02:10 <dcoutts_> my impression is that building a widget kit is hard, and not just because people use C/C++/Java to do it
09:02:16 <SamB> I doubt if the technique used by gtk2hs would work well either...
09:02:17 <dcoutts_> but because it's a big task
09:02:35 <SamB> dcoutts: oh, I don't so much care about it having a decent set of widgets, actually ;-)
09:02:39 <eivuokko> dcoutts, Right.
09:02:41 <dcoutts_> heh, ok
09:02:54 <SamB> just seeing a technique that would work for a decent set of widgets
09:03:09 <SamB> which were defined in Haskell
09:03:21 <es> gtk is a mess by the start...
09:03:31 * dcoutts_ thinks the most practical approach is to layer haskell abstractions on top of a decent C lib
09:03:39 <dcoutts_> Gtk+ is not that bad actually
09:03:48 <dcoutts_> it's pretty friendly to non-C languages
09:03:56 <dcoutts_> eg ones with GC etc
09:04:24 <dcoutts_> there's some old cruft, but that's mostly deprecated
09:04:37 <SamB> I mean that trick with the phantom-typed wrapped pointers wouldn't work too well for defining widgets types in Haskell...
09:05:03 <es> I have not used it extensively but for what I saw wxWidgets interface looks more coherent
09:05:16 <es> (I'm a java dev)
09:05:33 <Spark> gtk is a lot more friendly than swing
09:05:42 <SamB> I can't tell which is nicer...
09:05:54 <benja_> SamB: do you want the widgets to be implemented in Haskell?
09:05:58 * SamB really needs to get his Z-machine interp working properly
09:06:10 <SamB> benja_: point...
09:06:20 <eivuokko> dcoutts, Is there a way to install gtk2hs without installing all the gtk devel crud and polluting environment and all?
09:06:21 <es> well If I'm here is because I rate all J thing a "bit" bloated :]
09:06:26 <benja_> SamB: I meant it as a non-rethoric question :)
09:06:39 <eivuokko> dcoutts, In Windows, that is...
09:06:47 <SamB> benja_: well, it might be nice occasionally
09:06:56 <benja_> er, rhetoric :-/
09:07:01 <dcoutts_> eivuokko, fix ghc so you can compile without needing headers in client progs
09:07:13 <eivuokko> dcoutts, Add NOINLINE pragmas?
09:07:15 <SamB> but I guess usually you wouldn't want to inherit too closely...
09:07:27 <dcoutts_> eivuokko, that's a bit heavy
09:07:40 <dcoutts_> eivuokko, it's all about the scope of headers needed for foreign imports
09:07:41 <SamB> usually you'd want to do that for compound widgets. how many toolkits support compound widgets reasonably?
09:07:59 <eivuokko> dcoutts, Why can't the installer put the required include dirs in package description, anyway?
09:08:16 <dcoutts_> eivuokko, well one still needs the libs
09:08:27 <eivuokko> dcoutts, Yes, but not in environment variables.
09:08:33 <benja_> I believe the trade-off is, do you want native-looking widgets? or widgets coded with combinators you can use to build your own?
09:08:41 <dcoutts_> eivuokko, really we want to be able to add something to say that a foreign call may never leak out of a package.
09:08:42 <benja_> (apart from implementation time, of course :))
09:08:52 <dcoutts_> eivuokko, the env vars are to find the dlls
09:09:07 <eivuokko> ERG!
09:09:12 <SamB> benja_: it might be nice to be able to build native-looking compound widgets from native-looking "primitive" widgets
09:09:13 <dcoutts_> yes, tell me about it
09:09:17 <Hong> Hi, all :-)
09:09:18 <eivuokko> Yuck.  Ok, that again.  I'll skip it.
09:09:26 <dcoutts_> eivuokko, I was looking at manifests, it might fix it
09:09:30 <benja_> SamB: ok
09:09:31 <SamB> and occasionally you want a widget that looks nothing like most widgets
09:09:37 <SamB> like some sort of playfield
09:10:03 <dcoutts_> eivuokko, I agree, it'd be nice to not need the dev version of Gtk+ on windows, just the runtime.
09:10:15 <benja_> (I only know Java/AWT/Swing and Python/TK, so I can't really comment on the question =))
09:10:22 <dcoutts_> eivuokko, I started a thead on that some time back, probably in ghc-users
09:10:25 <eivuokko> dcoutts, No, I don't care needing devel version.  I care about environemnt variables and that stuff.
09:10:37 <dcoutts_> ah right, yes well that's bad too
09:10:42 <dcoutts_> about the scope of header files
09:10:53 <eivuokko> Yes, I have seen the mails :-)
09:10:56 <dcoutts_> ok
09:11:04 <eivuokko> I know the problem...my directx bindings also are kinda hard to install...
09:11:14 <SamB> what should be done...?
09:11:18 <dcoutts_> eivuokko, ah you need headers too
09:11:52 <eivuokko> dcoutts, Well, to be complete, yes.
09:12:02 <SamB> should the Haskell compiler internalize the headers at Haskell compile time for the importing module and regurgitate bits of them later, as needed?
09:12:05 <eivuokko> dcoutts, Mostly I just use native cg.
09:12:16 <dcoutts_> eivuokko, another solution is for windows to compile not via gcc, then no headers are needed
09:12:17 <Hong> I'm writing a program that has "import Control.Monad.Error", and GHC gives the error "Undefined symbols:
09:12:18 <Hong> _ControlziMonadziError_ZCDError_static_info", Could anyone point me to some references? I 've tried google with no luck. Thanks.
09:12:20 * SamB does not think this would be a very useful solution
09:12:25 <eivuokko> dcouts, Right.
09:12:43 <eivuokko> Hong, during linking, you probably need -package mtl
09:12:43 <Igloo> Hong: Use -package mtl or --make
09:12:52 <SamB> Hong: I *hate* that error
09:13:01 * es wonders why standalone app widget and interaction can't be made out of a spec born for the web like xforms ... but maybe it's just me
09:13:21 <SamB> I think GHC should give a more intelligable error about "missing -package flags required for linking"
09:13:22 <Hong> Thanks. gonna try that right now. I looked at the lib directory but didn't find any package name that looks like I should use.
09:13:54 <eivuokko> dcoutts, Anyway.  I feel bad not having tried gtk2hs.  I currently wouldn't recommend it because all gtk progs I have seen in Windows are ugly as ...
09:14:00 <SamB> (why do I think it should do that? I think it should do that so that you know what packages you are using when you link a program...)
09:14:19 <SamB> waitwait!
09:14:33 <SamB> there is supposed to be a non-ugly variant of GTK for windows...
09:14:44 <SamB> it is called minigtk or somesuch
09:14:58 <dcoutts_> ndm and I have been reporting some Gtk+ on windows theme bugs
09:15:03 <eivuokko> And there's theme and whatever...which never worked for me.
09:15:20 <eivuokko> And misses important default keys that work with normal dialogs and windows etc.
09:15:32 <SamB> hmm
09:15:36 <dcoutts_> eivuokko, we can report these as bugs
09:15:37 <eivuokko> And all the ugly extra pixels as margins or something
09:15:58 <eivuokko> It's like crappy unix software come on my nice Windows desktop!
09:16:03 <SamB> heh
09:16:25 <dcoutts_> actually once you start looking around, there's lots of different themes the Gtk+ could emulate
09:16:32 <eivuokko> Yes
09:16:40 <eivuokko> But installing them is pain
09:16:44 <xerox> It also has cairo themes!
09:16:45 <eivuokko> Atleast was last time I tried.
09:16:47 <dcoutts_> since each bit of windows software emulates windows theme slightly differently
09:16:52 <SamB> maybe that is what minigtk or whatever it is called is for
09:16:56 <dcoutts_> so it's hard to know which one to pick
09:17:08 <SamB> dcoutts: ooh!
09:17:14 <SamB> yeah.
09:17:25 <dcoutts_> eg, compre notepad, IE, word 2000, word 2003 etc
09:17:31 <dcoutts_> they're all different
09:17:32 <eivuokko> Huh?
09:17:39 <eivuokko> Well, their own components are
09:17:44 <dcoutts_> oh and VisualStudion is different again
09:17:58 <dcoutts_> the menus & toolbars particularly
09:18:24 <eivuokko> They are the same if you get versions that were in devel at the sametime, I think.
09:19:01 <eivuokko> But yes, the programs that don't use built-in components are diffrent, but that's not just it.  I can't spell out the bad things that make gtk apps stand out because I haven't used one for about 6months.
09:19:16 <dcoutts_> so we're waiting for Gtk+ 2.10 on windows which has some more theme improvements and then we'll submit bugs for any remaining issues
09:19:35 <dcoutts_> the big one of course is the common dialog boxes
09:19:41 <eivuokko> Right.
09:19:46 <dcoutts_> that's probably the hardest
09:19:51 <eivuokko> And right keybindings for them!
09:19:58 <dcoutts_> keybindings is easier
09:20:06 <eivuokko> Hehehe
09:20:16 <dcoutts_> but apparently the OSX people are modifying the Gtk+ file dialog, so it's not impossible
09:20:38 <eivuokko> Ah, right.  Reminds me that I should add that stuff in Win32
09:21:01 <dcoutts_> interestingly, Gtk+ is using the windows commong print dialog
09:21:09 <eivuokko> It has to
09:21:16 <eivuokko> It can be extended by drivers, I think.
09:21:21 <dcoutts_> yes
09:21:25 <xerox> Let's see if they have latest gtk in darwinports now!
09:21:46 <xerox> gtk2 2.8.19, x11/gtk2 (Variants: darwin_6, darwin_8)
09:22:06 <eivuokko> I just want to have nice gui lib...I want to write gui to invoke cabal...
09:22:12 <xerox> Probably that's still not using the native backend.
09:22:28 <eivuokko> But I'd prefer it to look like Windows app.
09:23:09 <SamB> but what do they look like?
09:23:16 <eivuokko> gtk?  Bad.
09:23:24 <SamB> I meant windows apps ;-)
09:23:42 <eivuokko> I think you can go and get screenshots from the net yourself.
09:24:06 <SamB> I could just turn on my other machine if I wasn't worried that the CPU would melt down without a fan...
09:27:07 * SamB wonders how frisby builds the datastructure full of cubbyholes
09:30:00 <eivuokko> How does it work, anyway?  From what JohnMeacham said, looking into future doesn't sound much diffrent from backtracking...does it run many parsers at once or what..
09:38:54 <SamB> eivuokko: it is an application of dynamic programming
09:58:41 <SamB> the only implementation technique I'd heard of before this just used an array of records with a field for every production in the grammar...
10:01:03 <SamB> hmm, where can I read about mdo?
10:01:56 <SamB> @google Haskell mdo
10:01:58 <lambdabot> http://www.haskell.org/pipermail/template-haskell/2005-June/000455.html
10:01:59 <lambdabot> Title: [Template-haskell] mdo support in Template Haskell
10:02:18 <SamB> @google site haskell.org/hawiki mdo
10:02:20 <lambdabot> http://www.haskell.org/communities/05-2004/html/report.html
10:02:21 <lambdabot> Title: Haskell Communities and Activities Report
10:02:21 <SamB> erg
10:02:23 <SamB> @google site:haskell.org/hawiki mdo
10:02:26 <lambdabot> http://www.haskell.org/hawiki/FixedPointCombinator
10:02:26 <lambdabot> Title: FixedPointCombinator - The Haskell Wiki
10:05:10 <SamB> @google site:haskell.org/ghc mdo
10:05:12 <lambdabot> http://www.haskell.org/ghc/docs/6.4.2/html/users_guide/syntax-extns.html
10:05:12 <lambdabot> Title: 7.3. Syntactic extensions
10:05:54 <SamB> @google "A recursive do for Haskell", Levent Erkok, John Launchbury
10:05:57 <lambdabot> http://portal.acm.org/citation.cfm?coll=GUIDE&dl=GUIDE&id=581693
10:06:02 <SamB> ack
10:06:14 <SamB> @google "A recursive do for Haskell"
10:06:17 <lambdabot> http://citeseer.ist.psu.edu/erk02recursive.html
10:08:54 <roconnor> SamB I'm writing an article on a case study with mdo.
10:10:08 <roconnor> unfortunately I'm not finished it.
10:10:50 <roconnor> Maybe I can give you a variable holding the article, so long as you promise not to read it until I have finished writing the article.
10:14:18 <SamB> roconnor: heh
10:18:12 <xerox> do { article <- newIORef (throw NonTerminated); unsafeInterleaveIO (write article); return article }
10:26:43 <SamB> xerox: eh
10:27:02 <SamB> isn't the IORef supposed to be read from at some point?
10:27:25 <SamB> rather than returned whole?
10:28:06 <xerox> s/return/readIORef/
10:28:15 <emertens> > let f x = let r = sqrt r in floor r == ceiling r in f 12
10:28:18 <lambdabot>  Terminated
10:28:28 <emertens> what is wrong with that function?
10:28:52 <xerox> You want sqrt x ?
10:28:53 <SamB> oh and I think I found a bug in the frisby docs...
10:29:05 <SamB> > let r = sqrt r in r
10:29:06 <lambdabot>  Terminated
10:29:30 <SamB> this ain't maths, it isn't going to solve for r and get 1...
10:29:43 <emertens> > let f x = let r = sqrt r in floor r == ceiling r in f 12
10:29:44 <lambdabot>  Terminated
10:29:46 <emertens> should work just fine
10:29:50 <xerox> emertens: how?
10:29:59 <SamB> > let f x = let r = sqrt x in floor r == ceiling r in f 12
10:30:00 <emertens> OHHH
10:30:01 <xerox> emertens: what does fix sqrt evaluate to? :)
10:30:01 <lambdabot>  False
10:30:02 <emertens> duh
10:30:10 <emertens> > let f x = let r = sqrt x in floor r == ceiling r in f 12
10:30:12 <lambdabot>  False
10:30:13 <emertens> :)
10:31:14 <pianodogg> ha ha
10:31:15 <gour> dcoutts: hi, was any discussion about hIDE on AngloHaskell meeting?
10:31:27 <dcoutts> gour, no
10:31:38 <SamB> hmm, you know, this frisby thing seems a bit inconvenient in that you can't have a bunch of parsers defined as top-level functions, afiact...
10:31:44 <xerox> > map (uncurry (==) . (floor &&& ceiling) . sqrt) [1..]
10:31:47 <gour> dcoutts: so the project is stalled or dead?
10:31:53 <lambdabot>  [True,False,False,True,False,False,False,False,True,False,False,False,False,...
10:32:05 <dcoutts> gour, we're all to busy with other projects
10:32:11 <SamB> that is, a bunch of interdependandt parsers with proper memoization...
10:32:18 <dcoutts> gour, I indend to look at it after the next gtk2hs release
10:32:31 <xerox> > map length . group . map (uncurry (==) . (floor &&& ceiling) . sqrt) $ [1..]
10:32:33 <lambdabot>  [1,2,1,4,1,6,1,8,1,10,1,12,1,14,1,16,1,18,1,20,1,22,1,24,1,26,1,28,1,30,1,32...
10:32:36 <xerox> aha.
10:32:49 <gour> dcoutts: next gtk2hs release will support 2.10?
10:32:54 <xerox> emertens: seen that? :D
10:32:54 <dcoutts> gour, maybe
10:33:09 <gour> dcoutts: this would be nice
10:33:13 <dcoutts> gour, it works with 2.10 anyway, but it might not have any support for the new stuff yet
10:33:22 <gour> dcoutts: that's ok
10:33:52 <emertens> xerox: no... i haven't seen that...
10:35:22 <SamB> JohnMeacham:
10:35:54 <SamB> you seem to have left frisby/examples/Grep.hs out of your repo...
10:36:51 <gour> dcoutts: you are hacking on several projects, ie. gtk2hs, ghc, cabal...how about your thesis?
10:37:17 <dcoutts> gour, yeah, that too
10:37:31 <dcoutts> gour, at the moment dons and I are busily writing about ByteStrings
10:37:46 <gour> dcoutts: congrats, real multi-tasking
10:37:56 <dcoutts> heh, if only
10:38:02 <gour> dcoutts: ByteStrings? is it fps-ng?
10:38:06 <dcoutts> yes
10:38:14 <dcoutts> just renamed really
10:38:20 <gour> it will be in 6.6?
10:38:22 <dcoutts> yes
10:38:31 <gour> wonderful
10:38:34 <dcoutts> and it'll be quick
10:39:08 * gour is still fighting to convince authorities to use haskell a language of choice for the project
10:39:22 <xerox> Rebel!
10:39:26 <gour> this is one plus for my argument ;)
10:40:08 <gour> xerox: one of the proposal was to go via ajax-route, but hajax is not there (yet)
10:40:29 <xerox> Did you see the HSP.ClientSide work in the end?
10:40:46 <dcoutts> gour, Linsire are now using haskell for all new system tool development, they're using ByteString
10:41:14 <gour> dcoutts: i sent them (authorities) url about it
10:41:44 <gour> xerox: yes, but i'd like more pure haskell solution, not just embedding
10:57:32 <xerox> Does the gtk2hs feed work in the feedreader of anybody?
11:00:45 <gour> xerox: here it works, although there are not really new feeds ;)
11:01:40 <gour> xerox: both are working (comments too)
11:03:41 <dcoutts> xerox, yep, all works
11:11:16 <emertens> it sure is nice of advertising companies to use "pop-unders". That way I never had to actually see their ads when I close them from the task bar
11:12:50 * basti_ has a radical blocking mechanism
11:26:42 <sek> which function works like map but for a function of 2 params. ie map (myfunc p1) [p2]
11:26:47 <sek> will map work like this?
11:27:03 <sek> myfunc :: p1 -> p2 -> whatever
11:27:18 <integral> (myfunc p1) :: p2 -> whatever --
11:27:32 <sek> ah
11:27:37 <integral> so that *is* only a function of one argument :)
11:27:46 <sek> so i change the definition of myfunc?
11:28:02 <integral> umm, no
11:28:15 <integral> I was just telling you what the type of the expression (myfunc p1) is
11:28:26 <integral> And it's the same type of type that map expects
11:28:29 <xerox> It is called partial application, you can view the type of any Haskell function a -> b -> c -> d as a -> (b -> (c -> d)).
11:28:43 <sek> oh ok. so map can work like this
11:28:55 <sek> i see
11:29:07 <xerox> I.e. that function takes an argument of type a, and returns a function that takes an argument of type b, and returns a function that takes an argument of type c and returns a value of type d.
11:29:44 <sek> ok. thanks alot:)
11:29:54 <xerox> :D
11:30:30 <sek> just wrote a horribly long and complicated func and am too afraid to compile it so just wanted to make sure this part of it would work:p
11:30:34 <xerox> With infix operators you can do sections: (++ "foo") :: String -> String
11:31:38 <sek> yes, same principle
11:31:58 <xerox> ("foo" ++) too.
11:32:02 <xerox> Well, you have the idea :)
11:32:08 <sek> thanks again
11:32:15 <xerox> You're welcome.
11:43:42 <PaulAJ> ping gour
11:44:46 <sieni> sek: do you mean like zipWith?
11:44:57 <sieni> > zipWith (+) [1..10] [2..11]
11:45:00 <lambdabot>  [3,5,7,9,11,13,15,17,19,21]
11:45:59 <Philippa_> silly thought: zipWith is effectively a generalisation of map, have the generic programming crowd managed to do anything with that?
11:46:26 <Philippa_> (though I guess the risk of structures being the wrong 'shape' is considerably greater once you look at trees, graphs etc rather than lists)
11:46:53 <xerox> Philippa_: it indeed is in polivariadic-functions-by-design-languages.
11:46:58 <xerox> (Like in Scheme)
11:47:15 <PaulAJ> Urk.  I'm not sure what zipWith tree1 tree2 should look like.
11:47:36 <PaulAJ> s/zipWith/zipWithTree
11:47:53 <xerox> I think I have that kind of code somewhere....
11:47:55 <Philippa_> PaulAJ: OK, suppose you have zipTree...
11:48:11 <sieni> yes, in scheme 'zipWith' is just called 'map'
11:48:14 <xerox> class ZipFunctor ...
11:48:15 <Philippa_> takes two trees, hopefully of the same shape, returns one with all the items tupled up...
11:48:47 <PaulAJ> I can see how, once you have the tupled version, zipWith is just map.  But what does zipTree do?
11:48:50 <Philippa_> xerox: I was mostly wondering about the languages that try to derive maps, folds etc on any structure
11:48:52 <xerox> class Functor f => ZipFunctor f where zip :: f a -> f b -> f (a,b)
11:49:03 <Philippa_> PaulAJ: it'll be pointwise
11:49:08 <xerox> (or zipF to not clash with zip)
11:49:16 <Philippa_> that is, items in the same position get paired
11:49:44 <PaulAJ> And presumably if there is no corresponding item then no pair gets generated.  I see.
11:49:45 <Philippa_> hence the comment about the same shape, and hence various structures implemented on top of trees likely needing their own zip implementations
11:49:55 <Philippa_> that, or you use undefined
11:50:06 <Philippa_> either for the tree as a whole, or more sensibly for the missing value
11:50:32 <dolio> > zip [1..5] [1..10]
11:50:35 <lambdabot>  [(1,1),(2,2),(3,3),(4,4),(5,5)]
11:50:38 <PaulAJ> Hmm.  If you have some kind of generic traversal concept you might be able to put that in ZipFunctor.
11:50:44 <Philippa_> hrmm, a sufficiently general zipWith should let you supply a default behaviour for missing values too
11:51:00 <Philippa_> the usual one's a generalisation of fold
11:51:07 <Philippa_> where you supply a function for each constructor
11:51:11 <PaulAJ> I do know zip, I'm just trying to conceive of a more general one.
11:51:16 <xerox> data Tree a = Leaf a | Branch (Tree a) (Tree a); instance ZipFunctor Tree where zip (Leaf x) (Leaf y) = Leaf (x,y); zip (Branch r l) (Branch r' l') = Branch (zip r r') (zip l l')
11:51:45 <dolio> Well, a list is just a unary tree. :)
11:51:47 <PaulAJ> xerox: I get it.
11:54:18 <dreamEye> Hi, I´m trying to compile the last version of Cabal . The compiler does not  find definitions for : `showVersion', Version,  versionBranch..
11:54:40 <dreamEye> do you know?
11:54:44 <sieni> > map (uncurry (+)) $ zip [1..10] [2..11]
11:54:47 <lambdabot>  [3,5,7,9,11,13,15,17,19,21]
12:00:28 <Philippa_> map is effectively zipWith1 :-)
12:00:29 <dreamEye> ok, Data.Version
12:06:32 <LordBrain> @where polivariadic
12:06:32 <lambdabot> I know nothing about polivariadic.
12:06:58 <LordBrain> @where+ polivariadic http://okmij.org/ftp/Haskell/types.html
12:06:58 <lambdabot> Done.
12:09:04 <es> I'm following a basic tutorial and it explained list but not how to iterate over each element and get the value or get for example the 2nd element. I probably need to read further but ...
12:09:20 <LordBrain> to get teh second element is easy
12:09:27 <LordBrain> just xs !! 2
12:09:35 <LordBrain> or actually 1, since they are indexed by 0
12:09:59 <LordBrain> iterating isn't hard either.. but what approach to take depends
12:10:28 <LordBrain> > map f [1,2,3] where f x = x ** 2
12:10:28 <lambdabot>  Parse error
12:10:47 <LordBrain> hmmm i always get parse errors when i try where clauses with lambdabot
12:10:55 <es> ah thanks !! is still not explained
12:11:12 <pianodogg> > let f x = x ** 2 in f [1,2,3]
12:11:17 <lambdabot>  add an instance declaration for (Floating [a])
12:11:17 <lambdabot>   In the definition of `mm...
12:11:31 <pianodogg> argh
12:11:34 <pianodogg> > let f x = x ** 2 in map f [1,2,3]
12:11:35 <es> heh
12:11:36 <lambdabot>  [1.0,4.0,9.0]
12:11:58 <LordBrain> > [ 1,2,3] !! 1
12:11:59 <lambdabot>  2
12:12:00 <int-e> @type ((**), (^^), (^))
12:12:02 <lambdabot> forall a a1 b a2 b1. (Floating a, Integral b, Fractional a1, Integral b1, Num a2) => (a -> a -> a, a1 -> b -> a1, a2 -> b1 -> a2)
12:12:39 <LordBrain> remember (!!) is O(n) tho
12:12:48 <es> wow that's sound complicated for simple iteration
12:12:58 <pianodogg> what are you trying to do?
12:13:33 <int-e> LordBrain: where clauses aren't part of the expression syntax. you can use them inside let though
12:13:38 <pianodogg> > mapM_ putStrLn ["Hello", "world"]
12:13:39 <lambdabot>  No IO allowed
12:13:40 <int-e> > let x = y where y = 42 in x
12:13:41 <lambdabot>  42
12:13:42 <pianodogg> oh geez
12:13:44 <LordBrain> ok int=e
12:14:01 <LordBrain> that would be why i always get parse errors :)
12:14:13 <es> having a list of pair like [('a', 1), ('b', 2), ('c', 3)] I whant to take only the number out of list like 123
12:14:20 <pianodogg> map snd
12:14:33 <pianodogg> > map snd [('a',1),('b',2)]
12:14:34 <lambdabot>  [1,2]
12:14:45 <pianodogg> map applies a function to every element of a list
12:14:52 <pianodogg> the function "snd" gets the second element of a pair
12:15:37 <es> oh ok thanks
12:17:14 <LordBrain> if you want to iterate and do some IO such as print each element in the list you'll have to use mapM_
12:18:36 <LordBrain> mapM_ is basicly like haskell's foreach
12:20:37 <es> thanks LordBrain
12:20:38 <LordBrain> the M stands for Monad, and the _ is a convention which means you're not really interested in a return value just the side effect... you'll understand that convention more later...
12:27:32 <Cale> mapM usually will work in place of mapM_ unless you're relying on the return type being (), so it's mostly optimisation to prevent it from building any part of the list result of mapM
12:29:20 <dcoutts> someone shuld add a RULE: forall (f::a -> m ()) . mapM f = mapM_ f
12:29:40 <dcoutts> oh, but the types don't work :-(
12:29:51 <eivuokko> liftM (:[])
12:29:51 <dcoutts> @type mapM
12:29:54 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
12:29:58 <dcoutts> @type mapM_
12:29:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
12:30:22 <eivuokko> Anyway, there's slight chance that someone needs the length of the list.
12:30:34 <dcoutts> yeah it'd have to be replicate ()
12:32:16 <eivuokko> The ghc testsuite is slow...gotta get give it make -jN-style boost.
12:32:28 <dcoutts> that'd be nice
12:33:03 <dcoutts> I had gentoo tester complaining to me about how long it took, epseiclaly when running the testuite too
12:33:24 <eivuokko> Yeah, and it hurts to see 50% or less CPU used...
12:33:39 <dcoutts> if you happen to have more than one, yes
12:33:52 <dcoutts> or if the tests don't utilise the cpu enough
12:34:01 <eivuokko> Most do.
12:34:25 <eivuokko> But there's lots of smalltime io in between
12:34:53 <eivuokko> I wonder how hard python threads are to use :-)
12:35:23 <xerox> You could investigate twisted, with its async stuff
12:35:32 <eivuokko> Err
12:37:28 <Igloo> dcoutts: What does "similar price to Sun's 4x core ..." mean in real money, OOI?
12:37:46 <dcoutts> Igloo, $3k
12:38:00 <dcoutts> for both system
12:38:11 <dcoutts> sun will sell it in Â£ too
12:38:17 <Igloo> That sounds pretty cheap, if it does what you want
12:38:22 <dcoutts> indeed
12:39:05 <LordBrain> i wouldnt classify myself as anti-oo, but i do avoid oo frameworks in favor of libraries... its a pain to learn all the hierarchy that will probably be refactored later anyway...
12:39:27 <SamB> do you dislike GUI toolkits, then?
12:39:47 <LordBrain> i'd prefer library toolkits
12:39:56 <SamB> what are library toolkits?
12:40:03 <LordBrain> but you know, i use what is available
12:40:26 <dcoutts> Igloo, I expect they have similar performance, 16 core (1 thread per core) @600MHz vs 8 core (4 threads multiplexed per core) @1.2GHz
12:40:30 <LordBrain> generally, i dont mind gtk from what i've done with it
12:40:46 <LordBrain> i havent made my own widgets tho
12:40:54 <dcoutts> Igloo, and the mips one has various network things built it which is nice
12:41:10 * Igloo starts wondering if dcoutts is on commission  :-)
12:41:13 <dcoutts> hah
12:41:27 <dcoutts> I want to see ghc running on a >=16 way box
12:41:28 <Philippa_> dcoutts: I would've thought the 8 core'd do a bit better if they're doing what I think they are
12:41:29 <LordBrain> i guess i like a gui toolkit to be one i can use like a library most of the time.
12:41:43 <LordBrain> and i think gtk fits in that category
12:41:45 <Philippa_> (looking at another thread each time the one being executed stalls on something)
12:41:53 <LordBrain> that is
12:42:24 <LordBrain> i dont want to have to derive from some class in order to make an app
12:42:30 <LordBrain> like in mfc
12:42:33 <dcoutts> Philippa_, yes, maybe. the $3k one starts with only 6 cores, so for the $3k sparc vs $3k mips it would be an interesting benchmark
12:42:57 <SamB> well considering you aren't able to subclass GTK "classes" in Haskell...
12:43:24 <Philippa_> dcoutts: ah, I've also not done my homework on how well sparc vs mips compare per clock
12:43:30 <LordBrain> well i've used gtk2 outside of haskell a little bit.
12:43:42 <Philippa_> I do remember being somewhat amused that mips (or at least the modded example on the PS2) doesn't actually have a harder stack
12:43:44 <xerox> What is this talking about SMP systems all of a sudden now?
12:43:55 <dcoutts> xerox, because they're real
12:43:58 <Philippa_> mostly because it's a nice one to point out to the "C is closer to the hardware" crowd
12:44:04 <LordBrain> i think to make your own widget probably involves something equivalent to subclassing
12:44:04 <dcoutts> and because ghc can do it
12:44:07 <dcoutts> unlike ocaml
12:44:14 <LordBrain> which i can live with that...
12:44:16 <Philippa_> not only are they real but they're becoming mainstream
12:44:24 <Philippa_> not just for servers but for everything
12:44:54 <dcoutts> ooh, cool Gtk+ can now layout Chinese/Japanese text vertically
12:44:59 <dcoutts> http://mathrick.org/blog/archives/2006/08/21/the-end-is-near/
12:45:01 <lambdabot> Title: The End is near at Mathrick no PATANKO PRESS!
12:45:09 <dcoutts> done as part of a SoC project
12:45:15 <xerox> dcoutts: nice!!
12:46:04 <chessguy> yes, all the SoC project should be done soon. i can't wait to see what comes out of it
12:47:33 <chessguy> hey cale, you around?
12:47:56 <Cale> chessguy: yeah -- hey sorry about last time, I got stuck on the phone for a while there
12:47:57 <dcoutts> xerox, you pleased with your final stuff, does it work? :-)
12:48:03 <chessguy> no problem
12:48:19 <chessguy> i've been learning a lot
12:48:25 <xerox> dcoutts: it does for me! I am hacking the multiple repositories code now.
12:48:28 <Cale> cool
12:48:32 <dcoutts> xerox, excalent
12:48:41 <chessguy> have you seen MIT's lecture series on lisp?
12:48:54 <chessguy> princples of programming languages or something
12:49:04 <xerox> chessguy: <http://hackage.haskell.org/~paolo/tmp/13022006.3gp> :D
12:49:27 <Cale> hmm, I'm not sure.
12:49:31 <chessguy> what the heck is that supposed to be?
12:49:40 <Cale> What's 3gp?
12:49:44 <xerox> Me watching those lecture son the video ipod :P
12:49:47 <xerox> A video, Cale.
12:50:01 <chessguy> it's killing my machine
12:50:29 <chessguy> it was just a bunch of gibberish
12:50:49 <xerox> mathrick: are you the pango guy? :)
12:51:33 <chessguy> Cale: anyway, they were talking about the nature of FP, using the term 'wishful thinking'. it sounds to me like they're trying to characterize FP as an idealized implementation of top-down design
12:52:01 <xerox> Yeah, Sussman does in the definition of MAP or something like that, IIRC
12:52:11 <Cale> Hmm...
12:52:36 <Cale> 'Wishful thinking' is often a strategy for constructing recursive solutions to problems.
12:52:40 <chessguy> basically, you write the highest-level possible code, assuming the lower-level stuff exists
12:52:50 <xerox> "Pretend you have a way to map the function on the rest of the list, what remains to be done? Apply the function to the element and construct the list"
12:53:04 <chessguy> mmm, yeah, but they weren't just doing it for recursion
12:53:11 <xerox> Right.
12:53:14 <Cale> ah, interesting
12:53:31 <xerox> That's a description of map f (x:xs) = f x : map f xs
12:53:41 <Cale> Yeah, you can write things that way.
12:53:48 <xerox> Very nice explanation too.
12:54:01 <chessguy> would you say that FP encourages that way of writing?
12:54:14 <Cale> Philippa and others have recommended getting a path from high level to low level that compiles and runs, and then expanding outward from that.
12:54:31 <dolio> That sounds like the haskell commentary on MapReduce from lambda the ultimate recently.
12:55:00 <SamB> xerox: eh, I thought that was called induction
12:55:10 <chessguy> hmm, a path. interesting notion
12:55:14 <Cale> But yeah, it does tend to encourage top-down development to some extent. Even syntactical features like 'where' sort of emphasize that on a small scale.
12:55:14 <dolio> He just used 'mapWithKey = undefined' for a while, until he got the types right.
12:55:24 <dolio> Then filled in what it actually does.
12:55:40 <xerox> Nice :)
12:55:50 <SamB> heh
12:55:54 <chessguy> anyway, that video series is excellent. very, very high quality teaching
12:56:18 <xerox> ?google mit sussman sicp video lectures
12:56:19 <Cale> chessguy: I was in the middle of explaining foldr, I think
12:56:21 <lambdabot> http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/
12:56:21 <lambdabot> Title: Structure and Interpretation of Computer Programs, Video Lectures
12:56:23 <xerox> :)
12:56:26 <Cale> Is that stuff cool now?
12:56:38 <chessguy> yes, i think i get the idea
12:56:44 <Cale> I think someone continued my line of reasoning fairly closely afterward.
12:56:58 <SamB> you ought to be able to write a type signature but no function ;-)
12:57:16 <xerox> SamB: if you are doing mathematics, it would be fine :)
12:57:24 <Cale> Basically, the idea is that if you find yourself writing the same pattern of recursion over and over with small bits changing, you might want to abstract that whole pattern of recursion.
12:57:42 <chessguy> yes
12:57:46 <SamB> xerox: well, I mean, the compiler should just give you a warning like if you leave a class member undefined...
12:58:07 <xerox> ?google fold universality
12:58:09 <lambdabot> http://www.cs.nott.ac.uk/~gmh/fold.pdf
12:58:10 <xerox> This paper is *very* nice.
12:58:34 <SamB> and fill in a suitable value of bottom for the value of the variable
12:59:09 <SamB> bottom *is* the class of least-defined values...
13:00:13 <chessguy> i wonder if MIT has any similar video lecture series that they make available
13:00:26 <LordBrain> for chatrooms named after computer langauges, #haskell seems the most oriented toward pedagogy that i know of.. maybe that goes for the community too.
13:00:28 <xerox> Yes.
13:00:33 <xerox> ?google OpenCourseWare
13:00:36 <lambdabot> http://ocw.mit.edu/
13:00:36 <lambdabot> Title: MIT OpenCourseWare | OCW Home
13:00:39 <xerox> Wonderful things.
13:02:01 <chessguy> LordBrain: i wouldn't be surprised, since FP is primarily used in the domain of universities
13:04:21 <dolio> Princeton has a fair collection of random lectures, as well.
13:04:22 <Cale> Yet there's also a lot of practical stuff discussed here too :)
13:04:27 <dolio> http://www.princeton.edu/WebMedia/lectures/
13:04:31 <lambdabot> Title: Princeton University: WebMedia - Lectures
13:04:36 <dolio> More of a liberal arts slant, though.
13:06:47 <chessguy> i prefer video lectures, myself
13:08:37 <dolio> I thought I had a link to some other university with video lectures in computer science as well, but I can't find it now.
13:09:01 <dolio> Then again, most of the interesting courses were in German, which I couldn't understand. :)
13:09:30 <Cale> there were some video lectures on Haskell on the web. I never got past the first couple since they were 700MB and I moved away from Waterloo and my internet connection now sucks. :)
13:09:48 <chessguy> ?google haskell video lecture
13:09:51 <lambdabot> http://lambda-the-ultimate.org/node/1303
13:09:51 <lambdabot> Title: Haskell video lectures online | Lambda the Ultimate
13:10:04 <Cale> yep, that should be the ones
13:10:29 <Cale> oh, I can't resolve the domain...
13:11:22 <chessguy> 82.165.179.176
13:12:50 <Cale> that's for video.s-inf.de?
13:12:53 <Pupeno> Hello.
13:12:56 <xerox> Oh, what's that?
13:13:04 <Pupeno> Is Haskell a good language to write interpreters ? right ?
13:13:12 <SamB> Pupeno: well...
13:13:15 <Cale> Pupeno: yeah, it's decent for that
13:13:20 <chessguy> Cale: it's for lambda-the-utlimate.org
13:13:20 <SamB> it is nice to write in but sometimes they are slow
13:13:30 <SamB> depending on the language etc.
13:13:32 <Pupeno> what would you recomend instead ?
13:13:42 <Cale> chessguy: ah, LTU works for me, but not the link that the article links to :)
13:13:49 <chessguy> oh
13:13:51 <chessguy> hm
13:14:22 <xerox> chessguy: do you have a link to the lectures itself?
13:14:24 <chessguy> ah yes, 404 for me too
13:14:40 <SamB> I wouldn't recommend anything without a more detailed description of the problem ;-)
13:15:08 <SamB> that is, what kind of an interpreter are you thinking about writing?
13:15:59 <chessguy> what the.....what does APL stand for?
13:16:07 <SamB> A Programming Language?
13:16:14 <LordBrain> it depends who you ask
13:16:20 <Cale> Array Programming Language?
13:16:26 <SamB> Cale: that too ;-)
13:16:31 <LordBrain> some say actuarial programming language
13:16:54 <SamB> it seems likely that the P and L refer to "programming language"
13:17:03 <jbalint> is APL the one with its own keyboard?
13:17:03 <LordBrain> just because its popular among actuaries
13:17:09 <Cale> ah, yeah, it is "A Programming Language" after a book which first described it
13:17:19 <Cale> jbalint: yeah
13:17:37 <chessguy> he says that once you think in terms of map, you don't have to think about the details of how map works, and that's an idea that comes out of the APL
13:17:52 <Pupeno> SamB: lisp-like.
13:18:04 <SamB> Pupeno: pure or impure?
13:18:39 <Cale> chessguy: yeah, possibly, though I think it's a much older idea
13:18:47 <LordBrain> i dont know APL but i think its one of those "data-flow" langauges...
13:18:47 <Pupeno> SamB: you mean if it'll be pure functional ? no, I don't think so.
13:18:51 <chessguy> but you think he's referring to that book?
13:19:50 <SamB> you could probably do a reasonable job, though interning will probably be a pain (but when is it not?)
13:19:52 <Cale> LordBrain: It's an array manipulation programming language
13:20:31 <Cale> The modern equivalent is J
13:20:38 <Cale> or possibly K :)
13:20:46 <SamB> why not L?
13:20:55 <LordBrain> we haven't run out of letters yet?
13:21:09 <SamB> LordBrain: probably have ;-)
13:21:14 <LordBrain> hehe
13:24:37 <Cale> http://en.wikipedia.org/wiki/Iverson_bracket -- hehe
13:25:43 <LordBrain> does the link for the haskell videos work for anyone?
13:25:48 <Cale> no
13:26:08 <Cale> It seems the server that they were on has moved or been taken offline
13:29:54 <xerox> Cale: those brakets or some variation would be fun to have in a programming language, hehe
13:31:19 <Cale> Well, you can get the same effect in Haskell using  iverson p = if p then 1 else 0
13:31:36 <Cale> In Mathematica it's called Boole
13:31:51 <benja_> could you use toInteger p?
13:32:07 <Cale> > fromEnum True
13:32:09 <lambdabot>  1
13:32:13 <Cale> > fromEnum False
13:32:14 <benja_> right, fromEnum
13:32:14 <lambdabot>  0
13:32:29 * benja_ tries to memorize that fromEnum = fromInteger . toInteger
13:32:42 <benja_> I know that, I just don't think of it :)
13:33:11 <xerox> Cale - Maybe some variation would solve the conditional expression syntax problem...
13:33:13 <benja_> xerox: in C or Python you can use (p)
13:33:14 <benja_> ;-)
13:33:49 <Cale> >>> True + 5
13:33:49 <Cale> 6
13:33:57 <xerox> Yuck.
13:34:35 <Cale> Hey, at least it's not 4
13:35:06 <benja_> oh, it all depends on your point of view. I remember a huge controversy about whether 'True'/'False' constants could be added to the language or whether 0/1 were just the Right way to do it...
13:35:51 * xerox laughs out loud
13:35:53 <LordBrain> does lambdabot interpret >>> different from > ?
13:36:00 <int-e> yes
13:36:17 <LordBrain> what does teh >>> mean?
13:36:19 <int-e> >anything is different from >[space]
13:36:32 <int-e> the >>> is python's prompt
13:36:39 <LordBrain> oooooh
13:36:41 <LordBrain> ok
13:36:41 <xerox> Cale, I asked a friend of mine (which advocates python all time) about True + 5 = 6.  The answer: ``Oh, True and 1 are the same thing in Python. That's it, very easy. 1 == True will return 1. Err, no, True. Yes, True.''
13:36:51 <LordBrain> i didnt know we could do python
13:36:56 <benja_> xerox: heh
13:36:59 <xerox> haha.
13:37:00 <int-e> LordBrain: read again
13:37:18 <Pupeno> True + 5 = 6 ? hehehe.
13:37:19 <LordBrain> ah
13:37:23 <LordBrain> it was Cale..
13:37:28 <dolio> :) Ruby is better. Everything is true except false and nil.
13:37:32 <LordBrain> my mistake sorry
13:37:42 <int-e> so "" is true?
13:37:45 <dolio> Yep.
13:37:48 <xerox> dolio: three-valued logic? :D
13:37:49 <dolio> So is 0.
13:38:18 <benja_> C:\> ls
13:38:23 <benja_> Command not found: ls.exe
13:38:25 <dolio> Well, nil and false are usually interchangeable. At least, they have the same effect in if expressions.
13:38:28 <benja_> see, we can do DOS too
13:38:33 <LordBrain> lol
13:38:49 <dolio> Of course false.is_nil? is false.
13:38:50 <Cale> C99 seems to be the same as python in that regard
13:39:12 <dolio> Sorry, that should be .nil?. I've been out of the game for a while.
13:40:13 <Cale> only it doesn't have True and False as values, just a type that can only hold 0 or 1
13:42:12 <dolio> They should have used: "enum Bool {True, False, FileNotFound };"
13:43:01 <Cale> heh
13:44:16 <SamB> "True is 1" evaluates to False, though...
13:44:47 <benja_> SamB: yeah, they have to be different objects because they print differently
13:44:50 <SamB> then again, for anything outside the 1-100 range or anything you calculated rather than typed in, you'd probably find that that was the case...
13:44:51 <benja_> bool is a subclass of int
13:45:09 <benja_> [-1..100] iirc =)
13:45:18 <Cale> Yeah, it seems they managed to use automatic casting to destroy any benefit of having bool as a separate type
13:46:05 <SamB> Cale: too many people using various tricks treating truth values as ints...
13:46:27 <jer> True isn't 1, True is !0
13:46:35 <jer> 1 is just a convenience
13:46:36 <SamB> comes of being non-functional really
13:46:57 <SamB> True is not 1, you mean
13:47:05 <SamB> "isn't" isn't valid syntax
13:47:12 <sieni> @pl \x -> if x then 0 else 1
13:47:13 <lambdabot> flip (flip if' 0) 1
13:47:13 <benja_> (True is not 1) is True == 1
13:47:14 <jer> SamB, no, in C; true is !false, and false is defined as being the integer 0
13:47:17 <lucca> i like using lists of booleans as arbitrary precision numbers...
13:47:26 <jer> sorry wasn't talking about haskell
13:47:26 <SamB> jer: we were talking about Python
13:47:33 <lucca> but that's heresy in the other direction
13:47:42 <jer> ... oh, i got thrown off by the references to C99, coming in late, and the enum { }
13:47:54 <SamB> lucca: that just sounds inefficient
13:48:08 <SamB> lists of Ints are a bit better
13:48:24 <Cale> irb(main):007:0> true + 5
13:48:24 <Cale> NoMethodError: undefined method `+' for true:TrueClass
13:48:24 <Cale>         from (irb):7
13:48:24 <Cale>         from :0
13:48:25 <sjanssen> Integer is best
13:48:32 <Cale> hey, that's good at least :)
13:48:34 <lucca> SamB: depends on the problem being solved... it was quite educational, which was all I needed at the time.
13:48:44 <SamB> lucca: ah, sure
13:48:54 <SamB> if you aren't actually going to *use* it for something ;-)
13:49:08 <lucca> heh, exactly
13:49:17 <Cale> heh, true and false are objects of separate classes?
13:49:18 <dolio> Lists of integers for arbitrary precision bools?
13:49:29 <SamB> dolio: no
13:49:36 <dolio> :)
13:49:40 <jer> Cale, yes
13:49:46 <SamB> arbitrarry precisiion integers...
13:49:57 <Cale> jer: any idea why?
13:49:57 <SamB> jer: in which language?
13:50:08 <jer> Cale, nope, i didn't design ruby =]
13:50:15 <SamB> hmm, not Python
13:50:21 <SamB> I just checked, and:
13:50:25 <SamB> >>> type(True)
13:50:25 <SamB> <type 'bool'>
13:50:26 <jer> SamB, considering he pasted irb output... =]
13:50:36 <SamB> oh
13:50:38 <SamB> that
13:50:40 <dolio> Yeah, there's no bool class in ruby.
13:50:42 <jer> irb(main):001:0> true.class
13:50:42 <jer> => TrueClass
13:51:01 <dolio> Just TrueClass and FalseClass.
13:51:02 <SamB> dolio: that is odder than having seperate classes for True and False...
13:51:14 <benja_> dolio: haskell is a very powerful language. {true, false, fileNotFound}? you can easily do that in haskell. for example foo = if a && (b || all l) then bar else baz becomes, foo = do tmp <- noMsg (all l); tmp2 <- noMsg (b || tmp); tmp3 <- noMsg (a && tmp2)... you can generalize from there...
13:51:34 <jer> if ruby used differential inheritence, it might make a bit more sense to have a boolean class and instances true and false of it; just describe the differences. instead, you'd be redefining behaviour on two objects with a common immediate ancestor, which doesn't make much sense
13:51:38 <jer> thus two classes
13:51:46 <jer> (at least, that's from my vantage point anyway)
13:52:18 <Cale> benja_: Maybe Bool :)
13:53:10 <benja_> oh, data True = True; data False = False; class Bool where {if' :: a->a->a}; instance Bool True where {if' t f = t}...
13:53:39 <sjanssen> benja_: that doesn't really make sense
13:53:45 <benja_> Cale: hm, perhaps Either Bool FileNotFound
13:54:03 <benja_> sjanssen: hm. toEnum 1 :-/
13:54:04 <SamB> benja_: isn't that backwards?
13:54:17 <SamB> Either FileNotFound Bool should work better
13:54:18 <Cale> Yeah, or more generally Either Bool IOError
13:54:18 <sjanssen> you'd want class Bool a b c r | a b c -> r where if' :: a -> b -> c -> r
13:54:23 <Cale> er yeah
13:54:30 <Cale> Either IOError Bool
13:55:03 <SamB> see, the left side is failury and the right side is "right" and successy
13:55:19 <benja_> sjanssen: ok, I can't figure out why :)
13:55:32 <benja_> you win :)
13:55:54 <benja_> SamB: oh, ok :)
13:56:32 * benja_ thinks that the Maybe type should obviously be declared as data Maybe a = Indeed a | Nope, though
13:56:58 <benja_> or perhaps, data Maybe a = Indeed a | NoDice
13:57:25 <ivant> data Maybe a = Indeed a | ForgetAboutIt
13:57:34 <sjanssen> data Maybe a = YeaVerily a | Alas
13:57:52 <Cale> Left (mkIOError doesNotExistErrorType "File not found at line 7 of Main.hs" Nothing (Just "myData"))
13:57:54 <xerox> sjanssen: just c -> r, no?
13:57:56 <benja_> Indeed a | Fugeddaboudit
13:58:15 <sjanssen> xerox: probably, I think I screwed it up
13:58:21 <jer> data Maybe a = MakeItSo a | BelayThat
13:58:50 <dolio> Heh.
13:58:58 <dolio> You'd have to change "Maybe" to "Picard."
13:58:58 <waern> I would like to have a complete guide to Haskell error handling
13:59:00 <dolio> The Picard monad.
13:59:21 <sjanssen> dolio: then we'd need a TeaEarlGreyHot constructor somewhere
13:59:28 <ivant> we should probably request the name changes for the data constructors of Maybe in Haskell'
13:59:29 <jer> dolio, =]
14:03:58 <xerox> *Cond> cond (undefined :: HTrue) 1 2
14:03:58 <xerox> 1
14:03:59 <xerox> *Cond> cond (undefined :: HFalse) 1 2
14:03:59 <xerox> 2
14:04:21 <benja_> hm!
14:04:38 <sjanssen> xerox: can you do cond HTrue 1 'c'?
14:04:41 <xerox> No :)
14:04:56 <sjanssen> I'm not sure whether that is useful or not
14:05:14 <SamB> why doesn't the replicator know to make tea hot already"?
14:05:19 <SamB> er, s/"//
14:05:40 <Cale> Tea, Earl Grey, Frozen
14:05:54 <benja_> SamB: doesn't it?
14:06:02 <benja_> > replicate 1 "Tea, Earl Grey, hot"
14:06:04 <sjanssen> apparently they order their drinks backward in the future
14:06:04 <lambdabot>  ["Tea, Earl Grey, hot"]
14:06:09 <benja_> see?
14:06:15 <Cale> Tea, Earl Grey, Superheated Plasma
14:06:34 <xerox> "the Coverage Condition fails for one of the functional dependencies"
14:06:35 <xerox> :-(
14:06:58 <SamB> I mean, why does he need to specify that it should be hot?
14:07:10 <benja_> ah, right
14:07:11 <xerox> Anybody knows what it does mean?
14:07:20 <dolio> At least he doesn't specify exact temperatures like people do when ordering water.
14:07:21 <dylan> sjanssen: well, it could be like navigating a tree structure with your voice. /tea/earl-grey/hot
14:07:26 <xerox> I *always* get that error at some point when I am trying to using types strangely.
14:07:29 <SamB> @google "coverage condition" functional dependencies
14:07:33 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/FunctionalDependencies
14:07:33 <lambdabot> Title: FunctionalDependencies - Haskell Prime - Trac
14:07:45 * dcoutts goes to *manually* make some hot early greay tea
14:07:52 <SamB> early?
14:07:54 <dcoutts> early/earl
14:07:57 <SamB> greay?
14:08:02 <dcoutts> blah
14:08:04 <xerox> haha
14:08:04 <sjanssen> dylan: the computers seem so advanced that you shouldn't have to do that
14:08:09 <dylan> gr[ae]y
14:08:13 <sjanssen> I mean, they are *trinary* based computers
14:08:17 <dcoutts> smudgy grealy tealy
14:08:19 <sjanssen> that hold giga-quads of information
14:08:32 <benja_> perhaps the default is some temperature that allows you to drink it immediately without having to wait for it to cool down
14:08:44 <dylan> sjanssen: it's also short for how I'd order tea with a human.
14:08:50 <benja_> but Picard thinks it dshows bad style to do that
14:09:06 <Cale> Tea, Earl Grey, Bubble
14:09:08 <dylan> "I want tea, what type do you have?" "Okay, earl grey." "Yes, of course I want it hot". ;)
14:09:30 <dcoutts> aye, you should just ask the thing for "tea" and it should know what you want based on what you usually want.
14:09:31 <SamB> The original paper imposed two restrictions on instances of the class C (sect. 6.1):
14:09:31 <SamB>    1. Coverage. For any instance
14:09:31 <SamB>       instance ... => C t
14:09:31 <SamB>       any variable occurring free in tY must also occur free in tX.
14:09:31 <xerox> *Cond> cond (undefined :: HTrue) 1 'a'
14:09:31 <xerox> 1
14:09:31 <xerox> *Cond> cond (undefined :: HFalse) 1 'a'
14:09:32 <xerox> 'a'
14:09:34 * xerox yows
14:09:46 <xerox> SamB: yes, I read and understood :D
14:10:12 <benja_> I think C++ templates should adopt GHC's type system
14:10:24 <Cale> benja_: hehe
14:10:38 <Cale> benja_: But then it wouldn't be awkward!
14:10:50 <benja_> Cale: oh, trust me, they'd manage =)
14:10:56 <xerox> (sjanssen: there we go)
14:11:08 <dolio> They wouldn't do that. They'd just add on an entirely different template system that uses GHC's type system, and keep the old one, too. :)
14:11:15 <benja_> perhaps you could prove the correctness of template metaprograms in it?
14:11:25 <sjanssen> xerox: that solution also has the advantage of making Cond a useful type level operator as well
14:11:37 <dylan> dolio: would this new template system use another set of symbols to designate them, too!? ;)
14:11:38 <es> why in Haskell tabs for indenting must be always 8 spaces long?
14:11:42 <Cale> dolio: and in so doing, make the syntax incredibly verbose
14:11:56 <xerox> sjanssen: I am not sure.
14:12:03 <ivant> es: I use 2 spaces long tabs
14:12:18 <xerox> Use spaces, not tabs.
14:12:30 <ivant> of course, set et sw=2 ts=2
14:12:33 <dylan> tabs can have any visual representation you want... and I use 4-space indentation.
14:12:35 <xerox> (But configure your editor so you can still use the tab key :D)
14:12:59 <es> ivant  ok, good, is was just a big warning in the tutorial I'm reading and I was wondering why
14:13:03 * dylan would like to configure his text editor to auto-indent like it does for everything else. :(
14:13:19 <dolio> The reason would be that the compiler will assume tabs are 8 spaces.
14:13:22 <ivant> es: what tutorial is it?
14:13:24 <dolio> So you might violate the offside rule.
14:13:46 <dylan> mixing tabs and spaces is truly the path to madness.
14:13:48 <es> http://www.cs.utah.edu/~hal/
14:14:13 <SamB> offside rule?
14:14:19 <es> what's that
14:14:24 <SamB> isn't that a *sports* rule?
14:14:34 <Cale> (a -> b) -> ([a] -> [b]) would become something along the lines of BinaryConstructor<Arrow, BinaryConstructor<Arrow, TypeVariable<a>, TypeVariable<b>> BinaryConstructor<Arrow, UnaryConstructor<List,TypeVariable<a>>, UnaryConstructor<List,TypeVariable<b>>>>
14:14:36 <dolio> Well, if you indented one line with a tab, and the next line with four spaces instead...
14:14:59 <dolio> The second line would appear to be less indented to the compiler, where in your editor, they might be the same indentation.
14:15:00 <Cale> I think that would be sufficiently verbose and unusable for inclusion in C++ :)
14:15:28 <Cale> oops, missed a comma
14:15:36 <lucca> next you'll want a trigraph to replace the tabs your editor won't let you insert...
14:15:42 <ivant> dolio: heh, it is easier to always use spaces then :-)
14:15:51 <wilx> lol @ lucca
14:16:02 <wilx> Trigraphs and digraphs are evil.
14:16:30 <wilx> Especially <:
14:16:37 <SamB> heh
14:16:39 <Cale> There already is an octgraph though. <space><space><space><space><space><space><space><space>
14:17:07 <lucca> octograph sounds like some sort of james bond villain
14:18:26 <benja_> Cale: oh, C++ wouldn't do that. they'd just use -><-><a,b>,-><LIST(a),LIST(b)>>
14:18:27 <Cale> It's like a combination of Dr. Octopus and a Van de Graaff generator
14:18:35 <xerox> Is Erlang purely functional?
14:18:56 <benja_> hm, does mdo stand for 'monadic do'?
14:19:05 <Cale> benja_: no
14:19:12 <Cale> benja_: It stands for mu-do
14:19:21 <benja_> right
14:19:22 <dolio> xerox: I don't think so.
14:19:30 <Cale> where mu is the least fixed point
14:19:40 <SamB> okay, who advocates the removal of classes?
14:19:41 <benja_> ...in type theory
14:19:46 <SamB> they can get their own language...
14:19:52 <SamB> call it Haskell--
14:19:54 <benja_> I mean, programming language type theory
14:20:23 <LordBrain> removal of classes from what?
14:20:34 <vincenz> Hey people
14:20:38 <LordBrain> c++?
14:20:45 * vincenz >>= Sardgna
14:21:18 <vincenz> @seen shar
14:21:18 <lambdabot> I haven't seen shar.
14:21:20 <vincenz> @seen shapr
14:21:21 <lambdabot> I saw shapr leaving #haskell and #ScannedInAvian 1 day, 5 hours, 18 minutes and 59 seconds ago, and .
14:21:25 <vincenz> @seen dons
14:21:26 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 7 hours, 48 minutes and 18 seconds ago.
14:21:28 <vincenz> @seen sieni
14:21:29 <lambdabot> sieni is in #haskell-blah and #haskell. I last heard sieni speak 34 minutes and 15 seconds ago.
14:21:41 <vincenz> @seen Philippa
14:21:41 <lambdabot> I saw Philippa leaving #oasis, #scannedinavian, #haskell-overflow, #haskell-blah and #haskell 5 hours, 41 minutes and 10 seconds ago, and .
14:21:45 <Philippa_> *wave
14:21:46 <Philippa_> *
14:21:48 <vincenz> hi :)
14:21:58 <Philippa_> nice coincidence, just took a look at the client
14:21:58 <vincenz> just saw shapr's picture with SPJ on the uni
14:22:20 <ivant> @uptime lambdabot
14:22:20 <lambdabot> uptime: 13 hours, 38 minutes and 46 seconds
14:22:28 <vincenz> I'm showing my brother the concept of IRC
14:23:17 <xerox> dolio: some documentation says that Erlang is a "single assignment language", does it count as pure?
14:23:42 * Cale archives ~500 unread conversations on GMail
14:23:44 <vincenz> xerox: I doubt it, I'm pretty certain you can call side-effect-full functions
14:23:54 <xerox> vincenz: oh I see.
14:24:04 <Cale> hehe, I'm a little behind on the mailing lists :)
14:24:04 <dolio> xerox: Depends what you mean, I guess. I think you can, for instance, put printing statements anywhere, which most people would probably call impure.
14:24:08 <vincenz> xerox: it's just single assignment but that's about it
14:24:36 <xerox> More pure than Scheme, but still open to inpurity anyway.
14:25:07 <vincenz> I don't think purity is a quantitive value
14:25:11 <vincenz> either you are or you-re not
14:25:28 <xerox> vincenz: they call it functional, but people still do imperative code!
14:25:32 <vincenz> :D
14:25:42 <vincenz> those bastards!
14:25:49 <xerox> @Arrr!
14:25:49 <lambdabot> Unknown command, try @list
14:25:59 <vincenz> xerox: they also do logical programming (oleg's kanren)
14:26:00 <xerox> @arr! Me said!
14:26:00 <lambdabot> Swab the deck!
14:26:08 <benja_> vincenz: does unsafePerformIO make GHC impure then?
14:26:14 <vincenz> benja_: touche
14:26:30 <vincenz> yes
14:26:33 <vincenz> GHC is impure
14:26:42 <vincenz> we've all been voting to get rid of it
14:26:46 <SamB> heh
14:26:48 <vincenz> replace it by pure lambdacalculus :)
14:26:51 <SamB> right!
14:27:04 <xerox> self-optimizing pure lambda calculus...
14:27:06 <SamB> and we aren't at all liking these Data.ByteString modules
14:27:17 <vincenz> @arr
14:27:17 * lucca trouts vincenz with a ```sii``sii
14:27:18 <lambdabot> Swab the deck!
14:27:35 * vincenz hits lucca with an infinite tail-call recursion
14:28:09 <vincenz> anyways
14:28:14 <lucca> heh
14:28:15 <vincenz> internet on an island ain't cheap
14:28:19 <vincenz> especially in an internet bar
14:28:24 <vincenz> so /me >>= booze
14:28:32 <vincenz> or is it =<<
14:28:38 <xerox> >>=<<
14:28:45 <benja_> but don't unsafePerformIO when drunk
14:28:50 <sjanssen> mmm, instance Monad Booze
14:29:34 <vincenz> benja_: I thought it was better when drunk
14:29:42 <vincenz> as impure as it may be
14:30:40 <vincenz> later
14:33:34 <SamB> hmm, does HaskellPrime require that features not only be implemented but also have code that will be valid using these features?
14:34:18 <SamB> like, they aren't really going to take out the . for composition are they?
14:35:21 <SamB> I can't type any of those other things except `o`, and that takes too long
14:35:33 <Oejet> And use it for records?!  Please this would be a _good_ thing.
14:35:53 <SamB> I admit that it would be nice to have something for records
14:35:55 <xerox> No please!
14:35:59 <xerox> :-(
14:36:05 <SamB> but I really can't type any of those other things!
14:36:09 <LordBrain> how about, space dot space for composition and this.that for records
14:36:36 <dcoutts> you can't eliminate (.) for composition and still call it Haskell imho
14:36:57 <LordBrain> we already have This.that for functions in the This module
14:36:59 <Oejet> xerox: These selector functions make me want to dig out my eye balls.
14:37:03 <SamB> well, surely if they make a fatal mistake people will continue to use the current language
14:37:17 <SamB> (Haskell98 plus crazy extensions omg!)
14:38:22 <benja_> SamB: hm, so where's the list of the composition proposals?
14:38:45 <SamB> http://hackage.haskell.org/trac/haskell-prime/wiki/CompositionAsDot
14:38:47 <lambdabot> Title: CompositionAsDot - Haskell Prime - Trac
14:38:54 <benja_> thanks
14:39:21 <SamB> see also http://hackage.haskell.org/trac/haskell-prime/wiki/RemovalCandidates for anything else you might hold dear
14:39:22 <lambdabot> Title: RemovalCandidates - Haskell Prime - Trac
14:39:23 <SamB> such as classes
14:39:55 <PaulAJ> I haven't seen any proposal for records that I like.
14:40:11 <PaulAJ> All I want is...
14:40:28 <SamB> ... everything and more?
14:40:29 <PaulAJ> Easy to write modifier functions, like when calling 'modify' in the state monad
14:40:36 <SamB> oh, yah
14:40:39 <SamB> I want that too
14:40:43 <Oejet> SamB: Class contexts are these (Eq =>) things?
14:40:49 <SamB> Oejet: yes
14:41:01 <PaulAJ> And just be syntactic sugar for something simple.
14:41:36 <SamB> probably the ones at the top of class definitions
14:41:36 <PaulAJ> The current record system has few things to recommend it, but the fact that data Foo = Foo {bar ::Int} is just syntactic sugar for
14:41:45 <PaulAJ> bar:: Foo -> Int
14:41:49 <PaulAJ> is a good thing.
14:42:30 * SamB does (\st -> st { stFoo = ..., stBar = ..., ... }) a lot
14:42:48 * PaulAJ does too.
14:43:00 <mathrick> xerox: yup, that's me :>
14:43:09 <xerox> @karma+ mathrick
14:43:09 <lambdabot> mathrick's karma raised to 1.
14:43:14 <mathrick> yay
14:43:14 <xerox> Good work! :)
14:43:15 <mathrick> xerox: am I that well-known?
14:43:26 <xerox> mathrick: I remember you from #math, and sometime #here too :)
14:43:27 <benja_> if array indexing wants the dot, how about it trades the ! for it and composition gets that? =)
14:43:45 <SamB> benja_: heh
14:43:46 <mathrick> xerox: thanks, but I also had a great mentor
14:44:15 <SamB> I suppose we could just steal <<< from Control.Arrow...
14:44:25 <xerox> mathrick: SoC works very well, yeah.
14:44:26 <PaulAJ> I would prefer to keep the . for composition, but if we have to change it then maybe <- if that is a legal operator.
14:44:35 <SamB> no, <- is taken
14:44:38 <SamB> by monads
14:44:44 <SamB> and list comprehensions
14:44:45 <PaulAJ> Composition has always looked a bit like piping.
14:44:57 <dcoutts> only in reverse
14:45:03 <PaulAJ> SamB: yeah, I thought so.
14:45:08 <mathrick> SamB: comprehensions are also monads :)
14:45:09 <PaulAJ> dcoutts: yes.
14:45:17 <SamB> mathrick: not anymore!
14:45:21 <mathrick> no?
14:45:25 <SamB> I mean, it only works on lists now ;-)
14:45:30 <LordBrain> i suppose i dont mind using a unicode character
14:45:35 <mathrick> heh
14:45:40 <SamB> LordBrain: I do!
14:45:46 <mathrick> SamB: I didn't know it used to work on anything else
14:45:46 <LordBrain> i'd have to set up some sort of magic in my editor
14:46:03 <SamB> because I don't think my editor really understands unicode, and I certainly don't know how to type it properly
14:46:21 <LordBrain> dot is really nice tho
14:46:34 <PaulAJ> Hmmm.  I can imagine having a dialect of Haskell with unicode characters like a real lambda, left arrow and so on, like the typeset version.
14:46:42 <LordBrain> i would rather keep the complicated lexing rules so we can have .
14:46:48 <dcoutts> PaulAJ, that may well happen
14:46:58 <benja_> instance Num (a -> a) where ((f * g) x) = f (g x)
14:47:11 <PaulAJ> But I don't think I would want it to be obligatory just yet.  Typing it might well be a pain.
14:47:18 <dcoutts> PaulAJ, no need for a dialect, just define the right unicode classes to be operators, etc
14:47:21 <SamB> but, you'd need all the editors to internalize the old lexing rules so that our typing still works
14:47:49 <LordBrain> yeah
14:47:59 <PaulAJ> dcoutts: how would that handle things like <- ?
14:48:02 <LordBrain> we'd have to have special haskell editors
14:48:03 <SamB> dcoutts: you'd still need the \ and such to be replaced in the syntax
14:48:07 <Pupeno> it would be nice that both ways, unicode and ascii would be valid and then have an editor that converts to unicode on-the-fly, like those to write in japanesse.
14:48:29 <dcoutts> SamB, not replaced, added
14:48:30 <Philippa_> PaulAJ: the problem with accessors-are-just-functions is that it doesn't play nicely with 'anonymous' record types etc
14:48:37 <SamB> dcoutts: whatever
14:48:50 <SamB> anyway accesssors aren't just functions...
14:48:54 <Philippa_> makes it impossible for typechecking a function to fail unless you've got a call site for it
14:48:58 <benja_> > (&)
14:49:00 <lambdabot>  Not in scope: `&'
14:49:09 <mrevelle> a special haskell editor, one that understands program structure, could be very nice.  and it could load and save standard ascii source files
14:49:14 <Philippa_> you just end up inferring a record type somewhere instead
14:49:16 <benja_> how 'bout that one?
14:49:35 <LordBrain> i think its nice that a special editor is not a requirement tho
14:49:40 <dcoutts> PaulAJ, in the lexer, just lex â† as the same token as <-
14:50:16 <xerox> dcoutts: how long 'till we have that?
14:50:21 <dcoutts> SamB, unicode gives us more brackets! and you know we've run out of brackets :-)
14:50:29 <SamB> dcoutts: but then you'd need filters to save your eyes from the horrible attrocity of *mixed notations*
14:50:35 <dolio> ?type Data.Graph.Inductive.Graph.(&)
14:50:37 <lambdabot> Not in scope: data constructor `Data.Graph.Inductive.Graph'
14:50:37 <lambdabot>  
14:50:37 <lambdabot> <interactive>:1:27: Not in scope: `&'
14:50:49 <PaulAJ> dcoutts: Ahh.  I was thinking you would need a compiler switch, but now I see you don't.
14:50:50 <dcoutts> xerox, JaffaCake was talking about it at AngloHaskell, so any time people decide to do it
14:50:55 <dolio> ?type (Data.Graph.Inductive.Graph.&)
14:50:57 <lambdabot> forall (gr :: * -> * -> *) b a. (Data.Graph.Inductive.Graph.DynGraph gr) => Data.Graph.Inductive.Graph.Context a b -> gr a b -> gr a b
14:51:03 <benja_> dcoutts: don't we still have [<-  ->] left .)
14:51:07 <xerox> dcoutts: arrr... me wants (me grog) that.
14:51:15 <dcoutts> @arr
14:51:15 <lambdabot> Keelhaul the swabs!
14:51:32 <SamB> so, who is going to trick out emacs-mode to work with that nicely?
14:51:43 <dcoutts> not I
14:51:51 <SamB> and write howtos on installing the needed fonts
14:52:03 <SamB> so that the code still looks reasonable
14:52:03 <PaulAJ> Gotta go. Night.
14:52:13 <SamB> oh, and figure out how this will effect the layout rule!
14:52:25 <SamB> because surely â† is wider than -
14:53:07 <benja_> SamB: teach Emacs autoindent to use a *wide* space under a <-  ;)
14:53:15 <benja_> Unicode has those too, I believe
14:53:17 <dcoutts> > (Î» x â†’ x + 1) 0
14:53:17 <lambdabot>  Illegal character ''\187''
14:53:21 <SamB> @kind (Prelude.->)
14:53:23 <lambdabot> parse error on input `Prelude.->'
14:53:27 <SamB> benja_: I don't think that makes sense
14:53:32 <SamB> @kind Prelude.(->)
14:53:33 <lambdabot> parse error on input `.'
14:54:15 * SamB was looking at http://hackage.haskell.org/trac/haskell-prime/wiki/Prelude and encountered an export list exporting (->)
14:54:17 <lambdabot> Title: Prelude - Haskell Prime - Trac
14:54:26 <benja_> SamB: no, me neither. it would probably end up as being shown only one character wide :-/
14:54:39 <benja_> like those horrible ellipsis characters shown in Courier
14:54:58 <benja_> (I mean, the <- would be shown one char wide)
14:55:01 * SamB fires up his WCWidth module
14:55:24 <benja_> but being able to use the proper ring for composition would be nice
14:55:52 <SamB> hmm.
14:55:59 <dcoutts> > fold (âŠ•) 0 [1..10]
14:56:00 <lambdabot>  Illegal character ''\138''
14:56:13 <greenrd> @paste
14:56:13 <lambdabot> http://paste.lisp.org/new/haskell
14:56:14 <SamB> when will GHC support UTF-8 strings?
14:56:18 <SamB> that would be nice...
14:56:31 <dolio> Perhaps it'd stop newbies (like myself once) from wondering why point-free code still has points in it. :)
14:56:37 <dcoutts> a â‰Ÿ b
14:56:42 <LordBrain> has anyone been bitten by the . lexxing problem?
14:56:44 <dcoutts> I like that one
14:56:54 <dcoutts> is there a . lexing problem ?
14:57:06 <benja_> dolio: trying to write point-free code without points would be pointless...
14:57:42 <benja_> dcoutts: I don't, but you'll never achieve consensus on such questions =)
14:57:50 <LordBrain> i dont know... i havent had much of a prl.
14:58:05 <SamB> hmm
14:58:09 <SamB> wcwidth would not work well
14:58:12 <LordBrain> much of a problem
14:58:14 <LordBrain> however
14:58:15 <twobitsprite> what do you all use for build environments... is 'make' still used typically?
14:58:17 <SamB> Prelude WCWidth Control.Arrow> map (id &&& wcwidth) "\x03BB\x2192"
14:58:17 <SamB> [('\955',1),('\8594',1)]
14:58:19 <dcoutts> SamB, it supports utf8 in ghc 6.6, but only in strings, not for identifiers, operators etc
14:58:25 <lisppaste2> greenrd pasted "Is this a compiler bug?" at http://paste.lisp.org/display/24514
14:59:08 <dcoutts> greenrd, no, the compiler is right (I think)
14:59:25 <benja_> SamB: hm, actually, emacs should be able to show an indentation space below a non-space character as wide as it shows that non-space character
14:59:30 <benja_> without too much trouble
14:59:31 <greenrd> dcoutts: But CheckedPC is a type synonym so it has no constructors
14:59:39 <kpreid> LordBrain: if you mean (Left.fst) vs (Left . fst), then I hit that once recently but I forget the context
14:59:42 <xerox> greenrd: seem right to me
14:59:56 <greenrd> dcoutts: So surely it should expand CheckedPC into 3 args
15:00:00 <dcoutts> greenrd, the erro mentions no constructors
15:00:22 <xerox> Hmm
15:00:23 <SamB> benja_: ah, that would probably work well as long as the other character wasn't a double-wide character...
15:00:26 <xerox> In fact it shows the wrong thing
15:00:32 <xerox> but its type `CheckedPC pc a b a2 b2 -> a a1 a2 -> b b1 b2' has only two
15:00:38 <greenrd> dcoutts: Yes I know, but I tried it with a constructor and it didn't work, obviously
15:00:48 <kpreid> greenrd: precedence problem
15:00:57 <greenrd> So how is it possible to implement this type I have created?
15:00:59 <LordBrain> i havent really confronted it in practice.. but from that site: As a test, before reading the report, can you lex the following: "f.g", "F.g", "F . g", "f..", "F..", and "F.".
15:01:06 <xerox> It should be `Checked pc a b a2 b2' or `a a1 a2 -> b b2 b2 -> pc (a2, b2)'.
15:01:09 <kpreid> greenrd: your EqImplEq *takes* a CheckedPC ... and an a a1 a2
15:01:13 <xerox> No?
15:01:21 <SamB> "f.g" = f . g
15:01:27 <greenrd> kpreid: So? I can't create a CheckedPC because it has no constructors? right?
15:01:30 <SamB> F.g is a reference to function g in module F
15:01:43 <SamB> F . g is F composed with g
15:01:48 <SamB> f.. is ugly
15:01:48 <kpreid> greenrd: sure you can. your type is like (a -> b) -> c -> d
15:01:56 <SamB> F.. is scary
15:02:15 <greenrd> kpreid: ahh, thanks
15:02:18 <SamB> F. looks like it needs parens
15:02:20 <LordBrain> F could be a data constructor
15:02:24 <dcoutts> greenrd, I'm trying to grok your types, but it looks like it is right, you're asking for foo :: a -> b -> c
15:02:34 <dcoutts> for rather complex a,b,c
15:02:35 <xerox> Fâ€¥ Fâ€¦
15:02:40 <xerox> SamB: what about those? :D
15:02:49 <benja_> > take 3 [NaN..]
15:02:50 <lambdabot>  Parse error
15:03:22 <LordBrain> hmmm i suppose we could use , it looks close to dot... and is just as easy to type
15:03:25 <benja_> > take 3 [False..]
15:03:25 <lambdabot>  Parse error
15:03:30 <dcoutts> greenrd, does it work with: foo = \_ _ -> undefined
15:03:33 <SamB> Prelude WCWidth Control.Arrow> map (id &&& wcwidth) "\x2025\x2026"
15:03:33 <SamB> [('\8229',1),('\8230',1)]
15:03:39 <xerox> LordBrain: it doesn't !!
15:03:52 <LordBrain> hehe
15:03:59 <LordBrain> depends on your font ;)
15:04:21 <SamB> LordBrain: waaaaaaaaaaaaay too many things do
15:04:24 <benja_> > (f , g)
15:04:26 <lambdabot>  Not in scope: `g'
15:04:26 <xerox> Well, I'm used as `,' with another meaning, yuck.
15:04:29 <LordBrain> hehehe
15:04:30 <xerox> Like the `,' that separate things in list comprehensions.
15:04:36 <xerox> Or tuples!
15:04:41 <SamB> yeah!
15:04:49 <benja_> > (concat , map)
15:04:50 <LordBrain> true
15:04:50 <lambdabot>  Add a type signature
15:04:54 <SamB> you can't suddenly make (x, y) not a tuple!
15:05:05 <xerox> Hmm what about using...
15:05:06 <LordBrain> true
15:05:12 <greenrd> dcoutts: yup
15:05:14 <xerox> (+2) â€¢ (*3)
15:05:39 <xerox> chr â—¦ (+13)
15:05:48 <SamB> I liked the first one better
15:05:57 <LordBrain> well, i wouldnt mind losing * as multiplication... i think i compose way more often than i multiply.
15:06:00 <xerox> If only it was easy to type.
15:06:06 <benja_> taking away 'o' as a variable is ugly :-/
15:06:18 <SamB> benja_: I don't think it was a serious proposal
15:06:21 <LordBrain> . is easier to type than * tho
15:06:21 <SamB> at least I hope not
15:06:23 <Patterner> i never use o as a variable
15:06:29 <benja_> SamB: hm
15:06:33 <SamB> Patterner: so?
15:06:36 <twobitsprite> so yeah... are Makefiles used for haskell programs, or is there some haskell specific build system?
15:06:44 <LordBrain> yeah, i think . for composition is perfect, we really should change its other uses instead.
15:06:44 <Patterner> let's ban variable names shorter than 8 letters
15:06:54 <benja_> -)
15:06:54 <SamB> Patterner: hah
15:07:05 <SamB> that would make our programs a lot longer...
15:07:07 <xerox> twobitsprite: Cabal!
15:07:14 <xerox> twobitsprite: http://www.haskell.org/Cabal
15:07:26 <eivuokko> twobitsprite, There is Cabal, which heavily relies on ghc --make or hmake for actual building.
15:07:27 <SamB> mapmapmap funfunfun listlist yay!
15:07:45 <twobitsprite> xerox: 404
15:07:59 <astrolabe> @where cabal
15:08:00 <lambdabot> http://www.haskell.org/cabal
15:08:07 <SamB> why doesn't lambdabot say 404: File not Found or somesuch?
15:08:13 <LordBrain> # for records, like HList does
15:08:25 <SamB> @type (#)
15:08:27 <xerox> ?where cabal
15:08:27 <lambdabot> parse error on input `)'
15:08:28 <lambdabot> http://www.haskell.org/cabal
15:08:30 <SamB> ack
15:08:42 <SamB> @type (##)
15:08:43 <benja_> "people can use 'negate' if they want to negate non literals"
15:08:44 <lambdabot> Not in scope: `##'
15:08:47 * benja_ recommends (0-x)
15:08:49 <SamB> oh good
15:08:50 <xerox> Let's define fun glyphs like âˆµ
15:09:01 <LordBrain> @type (@)
15:09:02 <lambdabot> parse error on input `@'
15:09:09 <LordBrain> @type (@@)
15:09:10 <lambdabot> Not in scope: `@@'
15:09:20 <SamB> what has taken #?
15:09:24 <benja_> @type (!@#$%^&)
15:09:26 <lambdabot> Not in scope: `!@#$%^&'
15:09:27 <SamB> obviously @ is for pattern matching
15:09:29 <twobitsprite> looks like haskell.org is case sensitive for directories...
15:09:35 <LordBrain> # is used as method invocation in OOHaskell
15:09:39 <SamB> twobitsprite: thats typical
15:10:12 <twobitsprite> is it? I guess I never end up typing any upper-case in URLs
15:10:14 <LordBrain> its also from what i understand used for method invocation in ocaml
15:10:35 <xerox> How cool would it be to use â‰ for definitions in Haskell? :D
15:10:38 <xerox> Hiya edwinb!
15:10:52 <edwinb> hi there
15:10:56 <LordBrain> jeez i really need to switch to a terminal supporting utf8
15:11:04 <benja_> data a? = a! | :-(
15:11:21 <SamB> twobitsprite: servers running on *nix systems are generally case sensitive
15:11:23 <benja_> data a? = a! | !@#$%^&
15:11:26 <xerox> (*3) âŠ™ (+4)
15:11:39 <SamB> xerox: doesn't line up right in x-chat
15:11:46 <ndm> xerox: but how do you type these symbols!
15:11:46 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
15:11:47 <xerox> :(
15:11:50 <SamB> there should be Unicode profiles for programming
15:11:57 <xerox> ndm: that's a good question
15:12:04 <SamB> so that you can see what fonts support the symbols you want
15:12:15 <ndm> @seen dcoutts
15:12:15 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #haskell-blah and #haskell-overflow. I last heard dcoutts speak 8 minutes and 44 seconds ago.
15:12:20 <dcoutts> @arr
15:12:21 <lambdabot> Shiver me timbers!
15:12:27 <dcoutts> hi ndm
15:12:34 <ndm> dcoutts, got your tell, all sorted now though :)
15:12:43 <xerox> I suppose you just memorize unicode codepoints. Let's add it to the learning curve of our beloved programming language, so to make it more steep.
15:12:48 <ndm> have been away from IRC for a week
15:13:12 <dcoutts> ndm, but you've sent lots of cabal emails :-)
15:13:13 <xerox> Everything for âŠ¥.
15:13:16 <dcoutts> which is good
15:13:19 <ndm> xerox: in that case i propose we only use unicode characters for the bizare type system extensions - since everyone already suffers for them
15:13:41 <dcoutts> let âŠ¥ = undefined in ...
15:13:42 <ndm> dcoutts, yep - i was on a computer with no haskell stuff, so tried to compile everything from darcs with cabal
15:13:49 <xerox> SamB, this ought to be the right one, (+2) â‹… (*3)
15:13:53 <ndm> happy doesn't work at all from darcs
15:13:55 <SamB> ack ack!
15:14:05 <dcoutts> ndm, and found it painful I bet
15:14:07 <SamB> pango is nasty!
15:14:11 <ndm> dcoutts, incredibly
15:14:26 <xerox> And my computer does it with M-S-.
15:14:28 <ndm> the fact that runhaskell Setup install might as well have been labelled runhaskell Setup donothing
15:14:32 <dcoutts> ndm, it's a good thing to do as you hit what beginners hit
15:14:35 <ndm> didn't help (for executables)
15:14:39 <dcoutts> but the rest of us don't notice
15:14:58 <dcoutts> ndm, did we figure that one out yet?
15:15:03 <dcoutts> I don't recall
15:15:06 <xerox> SamB: ask mathrick to fix it!
15:15:25 <mathrick> heh
15:15:27 <xerox> â¨¦ this looks like a running man
15:15:29 <mathrick> SamB: how is it asty?
15:15:34 <mathrick> *nasty
15:15:39 <SamB> well...
15:15:42 <ndm> dcoutts, not yet - i am going to email isaac back in a second
15:15:47 <xerox> â‰¬ squashed parens? :)
15:15:47 <LordBrain> ok
15:15:52 <LordBrain> hmmm
15:16:00 <SamB> did you see what xerox said about "(+2) â‹… (*3)"
15:16:01 <LordBrain> i am in uxterm but your stuff still looks strange
15:16:01 <SamB> ?
15:16:02 <ndm> the biggest issue is that lots of things depend on Alex and Happy, and Cabal borks at compile time
15:16:06 <ndm> and doesn't fetch the dependancies
15:16:17 <LordBrain> would i need to restart irssi?
15:16:29 <SamB> mathrick: hmm?
15:16:32 <xerox> SamB: now that I think of it, we could use some kind of input system
15:16:43 <SamB> it doesn't render correctly here
15:16:52 <mathrick> SamB: do you have fonts?
15:16:56 <SamB> there should be a tool for complaining about pango
15:17:00 <wolverian> LordBrain, you need to set up irssi's locale to be utf8, do the same for screen, and restart both
15:17:03 <SamB> mathrick: it renders the right characters
15:17:09 <SamB> but some of them keep jumping around
15:17:15 <mathrick> ah
15:17:18 <wolverian> LordBrain, basically it boilds down to using ubuntu.
15:17:20 <benja_> I've given up on trying to use utf8 in IRC
15:17:22 <wolverian> s/boilds/boils/
15:17:41 <benja_> tried uxterm and screen -u and the irssi stuff people told me and it still never worked right
15:17:42 <xerox> SamB: for example you can say "neko" to Emacs or even GNOME and have it converted in pretty hiragana 'ne' and 'ko' (and it goes further, if you press SPC, it gives you back the single kanji for the word "neko").
15:17:43 <mathrick> SamB: I've seen it previously, yeah, but unsure what bug that is
15:17:46 <LordBrain> ok
15:17:49 <LordBrain> gtg anyway
15:17:52 <wolverian> benja_, everything should just work if your locale is utf8
15:17:58 <mathrick> ã­ã“
15:17:59 <wolverian> benja_, no need for -u or anything.
15:18:00 <xerox> SamB: now, one could do, (+2) compose[magical-key] (+3)....
15:18:16 <SamB> xerox: all I need is the compose key
15:18:16 <benja_> hmmm...
15:18:18 <xerox> Or foo [keybinding]compose[keybinding] bar.
15:18:24 <SamB> configure my US keyboard for me!
15:18:32 <xerox> RTFM!
15:18:37 <SamB> WFM?
15:18:41 <dcoutts> hah
15:18:43 <xerox> TFM.
15:18:51 <SamB> WOITO?
15:18:57 <xerox> YDI.
15:18:59 <dcoutts> I'm lost
15:19:05 <twobitsprite> WTHAYS?
15:19:06 <benja_> WTHAYTA?!?
15:19:13 <xerox> WSSDTN.
15:19:14 <SamB> WFM = which fine manual
15:19:14 <twobitsprite> benja_ lol
15:19:15 <dcoutts> @yow!
15:19:16 <lambdabot> What's the MATTER Sid? ... Is your BEVERAGE unsatisfactory?
15:19:26 <xerox> TFM = the fine manual
15:19:28 <SamB> WOITO = which one is the one
15:19:42 <xerox> YDI = you download it
15:19:43 <xerox> o_0
15:19:54 <SamB> yes, but the manual for *which program*?
15:20:02 <xerox> Sorry, phone
15:20:04 <benja_> xerox: nono, TFM = the manual
15:20:28 * xerox does the simpson sketch when homer runs out of the house and takes the car
15:21:27 <benja_> SamB: what GUI do you use?
15:21:40 * SamB wants add something to the export list for Prelude.Comparison in http://hackage.haskell.org/trac/haskell-prime/wiki/Prelude
15:21:42 <lambdabot> Title: Prelude - Haskell Prime - Trac
15:21:59 * benja_ has given up on fighting GNOME with xmodmap
15:22:09 <SamB> benja_: I don't use a desktop ;-)
15:22:10 <benja_> (I always lose :-/)
15:22:22 <benja_> SamB: what *do* you use? :)
15:22:30 <SamB> though probably GNOME will mess my settings up anyway
15:22:37 <SamB> I can fix it though...
15:22:53 <SamB> I mean, I can take the line out of that one file...
15:23:00 <SamB> anyway, I use WindowMaker
15:23:47 <ndm> dcoutts, what did you think of my haddock --hoogle patch?
15:24:03 <SamB> hmm, how is the Prelude going to export "error" without exporting Char or String?
15:24:20 <benja_> ok... so does it try to p0wn your keyboard or can you use xmodmap?
15:24:20 <dcoutts> ndm, hmm, not sure, can't we just do setup haddock --with-haddock-args=--hoogle ?
15:24:37 <SamB> I don't think WindowMaker does
15:24:42 <ndm> is there a with-haddock-args flag?
15:24:45 <dcoutts> I'm slightly converned with a proliferation of special cases
15:24:57 <benja_> I can happily say that the real reason I gave up fighting Gnome is that it can actually do what I want, though :)
15:24:59 <ndm> dcoutts, and no - haddock by default adds --html, which overrides --hoogle
15:25:07 <dcoutts> ndm, see Isaac's email on the Program abstraction
15:25:07 <benja_> (switching the keyboard layout by holding down Super)
15:25:09 <dcoutts> ndm, ah, true
15:25:18 <eivuokko> Oh yay.  I think I got multiple threads working in testsuite :-)
15:25:29 <twobitsprite> there's another Isaac in here??
15:25:43 <dcoutts> twobitsprite, here he's SyntaxNinja
15:25:47 <dcoutts> @seen SyntaxNinja
15:25:48 <lambdabot> I saw SyntaxNinja leaving #haskell, #darcs and #haskell-blah 1 day, 22 hours, 57 minutes and 57 seconds ago, and .
15:26:13 <twobitsprite> hah... not often I find someone else named Isaac
15:26:23 <benja_> SamB: ok. the answer is 42^H^H'man xmodmap'. any other questions?
15:27:01 <SamB> well, like, what is "gnome-settings-daemon&" doing in the middle of my .xsession anyway...
15:27:52 <benja_> :-/
15:28:34 <benja_> Wikipedia informs me that Window Makker is maintained by the Window Maker developers
15:28:40 <SamB> heh
15:28:41 <benja_> s/kk/k/
15:29:26 <benja_> that reminds me of the old joke about the unix utilities ported to DOS:
15:29:33 <ndm> dcoutts, so given that, what should i do about hte --hoogle thingy?
15:29:34 <benja_> C:\> whereis config.sys
15:29:38 <benja_> config.sys is right here
15:29:44 <benja_> C:\> whereis command.com
15:29:44 <dcoutts> ndm, well the patch looks ok
15:29:48 <benja_> command.com is loaded into memory
15:29:49 <ndm> all i really want to do is to generate my hoogle databases, and i don't entirely care how :)
15:29:55 <benja_> C:\> whereis word.exe
15:29:57 <xerox> What is this C:\> madness today.
15:30:04 <benja_> word.exe is in its directory
15:30:31 <dcoutts> ndm, I wonder if it'd be better to have a haddock target, since in theory haddock can do html, dockbook, mshtml etc
15:30:48 <ndm> dcoutts, what do you mean by haddock target?
15:31:03 <ndm> i did realise that --hoogle should probably be joined by --docbook, --mshtml etc#
15:31:10 <eivuokko> ndm, dcoutts, fwiw, I think cabal-haddock support should have *some* support for building docs for combined packages.
15:31:14 <dcoutts> ndm, ie setup haddock [--html|--hoogle|--dockbook]
15:31:15 <ndm> but personally don't care about tham that much :)
15:31:34 <xerox> dcoutts: swab the dock!
15:31:43 <dcoutts> ndm, and treat internally as a many way thing rather than a boolean html/haddock Q.
15:31:59 <dcoutts> eivuokko, yes, that's be nice
15:32:04 <ndm> eivuokko: i'm not sure how it works, but when doing haddock on the hoogle package, it started balking about not having built haddock on the dependancies
15:32:12 <ndm> dcoutts, indeed, thats the way forward
15:32:31 <ndm> but its not that hard to add once my patch is in - the hardest bit was going from no args to 1 arg, from there on in its all easy
15:32:42 <ndm> i also spotted that all the haddock args were given in short form
15:32:49 <ndm> -h, instead of --html - any reason?
15:32:51 <eivuokko> I've been playing with the idea of starting to copy preprocessed (for haddock) sources from all my packages into one place and then have easily run haddock + windows helper generator over it...which is really cool.
15:32:55 <dcoutts> ndm, yes, that's not good
15:33:06 <dcoutts> in a program we should always use the long form
15:33:09 <dcoutts> for clarity
15:33:22 <ndm> dcoutts, i was tempted to do a patch to change that
15:33:27 <dcoutts> ndm, feel free
15:33:29 <ndm> i may do that tomorrow though
15:33:32 <eivuokko> I absolutely love the windows help-formatted libs+user guide that comes with Visual Haskell.
15:33:49 <dcoutts> eivuokko, haddock can generate that style can't it?
15:33:50 <ndm> although no chance of me doing it before my --hoogle patch gets in, as it will end up conflicting my own patch :)
15:34:02 <dcoutts> I know it can do GNOME's DevHelp index stuff
15:34:11 <eivuokko> dcoutts, It is just html packed into windows help...easy enough.
15:34:15 <ndm> eivuokko: as a .chm file?
15:34:18 <eivuokko> Yes
15:34:22 <dcoutts> ndm, no, it'll depend on your hoogle patch :-)
15:34:32 <dcoutts> ndm, which means more pressure for it to go in :-)
15:34:32 <ndm> is it available online?
15:34:35 <ndm> the .chm file alone
15:34:39 <SamB> ndm: you don't know how to send multiple patches, some of which depend on others?
15:34:54 <eivuokko> ndm, Don't think so
15:35:06 <ndm> SamB: I do, although its usually bad form to send your pet patch that may have issues, along with a good cleanup that doesn't which depends on your pet patch
15:35:22 <dcoutts> true
15:35:36 <ndm> eivuokko: is there anything stopping it from being added?
15:35:42 <ndm> eivuokko: i mean put online
15:35:48 <eivuokko> Mhm
15:35:53 <SamB> ndm: oh
15:35:59 <eivuokko> ndm, No, just take it from Visual Haskell insaller
15:36:07 <eivuokko> I think.
15:36:08 <dcoutts> ndm, you see there are lots of haddock options which users might want to control
15:36:09 <ndm> i want to compare, so hoogle 4's Gtk GUI can compete, and exceed, the .chm
15:36:18 <ndm> eivuokko: ok, will give that a whirl
15:36:20 <dcoutts> ndm, it might do to think of the more general problem there.
15:36:30 <eivuokko> ndm, Compete, with Visual Studio help integration?
15:36:34 <dcoutts> ndm, and some want to be controled by the devs and some by the users.
15:36:36 <eivuokko> They do diffrent things.
15:36:51 <SamB> dcoutts: what options?
15:36:55 <ndm> eivuokko: not with that, but as a stand alone help viewer
15:37:19 <eivuokko> ndm, Even then do you have hierarchy nicely available in that gui?
15:37:30 <ndm> eivuokko: i can add it :)
15:37:46 <eivuokko> ndm, Right...well.  Gotta see it then.
15:38:13 <eivuokko> ndm, Anyway, I'd love to have hoogle gui I can bring up with global hotkey...
15:38:24 <ndm> dcoutts, the options i can see being useful are [--html|mshtml|hoogle] --linksource and --comments
15:38:40 <dcoutts> SamB, --html-help=[mshelp, mshelp2 or devhelp format], --prologue=, --title=, and then all the URL flags for generating source code or wiki links
15:38:45 <ndm> eivuokko: i'm rewritting all of hoogle as we speak - 64 patches in the last 3 days, so once thats done
15:39:00 <eivuokko> ndm, Right.
15:39:12 <SamB> hmm.
15:39:32 <ndm> dcoutts, but cabal+haddock should be cleverer than haddock alone, maybe haddock shouldn't be a target, but documentation
15:39:46 <SamB> I think it should be builder controlled, perhaps with sensible defaults supplied by the developer for the URLs...
15:39:50 <dcoutts> ndm, what do you mean?
15:39:53 <eivuokko> ndm, I think preprocess for haddock should be a target.
15:39:55 <ndm> for example, --linksource could run the source through hscolour
15:40:14 <ndm> and then combine it with haddock
15:40:19 <eivuokko> Heh
15:40:22 <ndm> i.e. cleverer than either of its parts
15:40:27 <eivuokko> That'd be nice...I'm always reading mtl source.
15:40:38 <SamB> yeah
15:40:41 <ndm> have you seen the System.FilePath source?
15:40:43 <SamB> I use emacs for that personally ;-)
15:40:57 <ndm> its got haddock links, HTML coloured and anchored source - all the goodies
15:41:32 <eivuokko> ndm, No, but I think someone else did that too
15:41:32 <ndm> requried head versions of about 3 different projects and about 6 patches, plus a nasty build script and its only 1 file
15:41:45 <eivuokko> Hmmm
15:41:50 <eivuokko> One file?
15:41:52 <ndm> eivuokko: i must have got it first, because the patches weren't in when i started :)
15:41:59 <ndm> its only one module
15:42:09 <ndm> so the build script just invokes things directly, no clever stuff
15:42:35 <ndm> see: http://www-users.cs.york.ac.uk/~ndm/projects/filepath/System-FilePath.html
15:42:43 <ndm> that has hyperlinks into the source from the haddock
15:42:48 <ndm> and the source is coloured
15:43:55 <eivuokko> I don't value coloring much
15:44:03 <eivuokko> It's likely to be diffrent from what I like :-)
15:44:15 <eivuokko> But, yeah, cool
15:44:30 <eivuokko> Now, yes, please.  I could use that for all my installed haskell stuff in one .chm.
15:45:08 <SamB> eivuokko: another strike against developers choosing how haddock should be called
15:45:26 <eivuokko> Huh?
15:45:38 <SamB> that thing about the coloring not being what you'd like...
15:45:55 <eivuokko> Ah
15:45:57 <SamB> sure haddock doesn't do coloring *now*...
15:46:00 <dcoutts> SamB, haddock doesn't do the colouring
15:46:09 <eivuokko> It's hopefully just css
15:46:10 <dcoutts> just the source code & wiki links
15:46:33 <SamB> yeah, maybe you'd want to control the CSS
15:47:05 <SamB> (and maybe haddock should support highlighting for examples?)
15:47:29 <ndm> eivuokko: hscolour uses a simple css file, which you can change
15:47:42 <ndm> eivuokko: thats just my preference, which is what textpad does
15:47:58 <ndm> and the css is in an external file, for added ease
15:48:26 <ndm> dcoutts, exactly, and you really want the colouring and documentation done in one command
15:48:38 <dcoutts> ndm, might be nice
15:48:56 <dcoutts> perhaps the right place is as a haddock feature
15:49:38 <ndm> haddock should do documentation
15:49:43 <ndm> hscolour should do colouring
15:49:55 <ndm> there should be something above that which combines them, i think
15:50:02 <ndm> although maybe haddock could have it added
15:50:12 <ndm> but then you get the whole BSD program depending on a GPL'd program
15:50:18 <ndm> and license issues become stupid (grr)
15:50:29 <dcoutts> hscolour is pretty trivial
15:50:34 <dcoutts> it can be reimplemented
15:50:38 <ndm> in the same way that haddock doesn't integrate with cpphs because of licenses, otherwise haddock could have -cpp and -unlit easily
15:50:39 <dcoutts> I've already done it once
15:50:55 <dcoutts> yes, that is a bit annoying
15:50:55 <SamB> uh
15:51:05 <dcoutts> same for ghc
15:51:05 <ndm> i did consider forking haddock, haddock-gpl
15:51:12 <SamB> why can't it support calling GPL programs, especially in an optional way?
15:51:22 <dcoutts> calling is ok
15:51:24 <ndm> SamB: it can probably call them, but its a shame
15:51:33 <ndm> cpphs integration would be really nice
15:51:47 <SamB> what do you mean by integration then?
15:51:53 <dcoutts> available as a lib
15:51:54 <ndm> the only reason i didn't give it a whirl is the SoC project to add GHC integration, which will hopefully add -cpp -unlit support
15:52:04 <ndm> it not, then i'll add a cpphs dependancy
15:52:17 <ndm> (i reckon its about 20 lines of code, so will just distribute it as a patch)
15:52:25 <dcoutts> ndm, btw, I like the idea of pinching dep chasing from ghc/yhc/jhc/wherever
15:52:31 <dcoutts> I'm not sure of the API yet
15:52:49 <dcoutts> we want it to be possible to extend, eg for .chs
15:52:54 <dcoutts> or whatever
15:52:57 <ndm> yeah, thats an issue
15:53:08 <ndm> but it would really make Cabal much more useable
15:53:18 <dcoutts> so we want to split it so that we can find the deps for various kinds of files
15:53:38 <dcoutts> and another make-like bit that combines the deps and decides what to do
15:53:54 <ndm> yes, exactly
15:54:10 <ndm> anyway, have to go now
15:54:16 <dcoutts> right;o
15:54:20 <ndm> expect more cabal complaints over the next week :)
15:54:25 <dcoutts> I'll be away :-)
15:54:28 <ndm> hoogle now has a cabal build mode
15:54:35 <dcoutts> good good
15:54:36 <ndm> which doesn't really work very well :)
15:54:41 <dcoutts> heh
15:54:43 <ndm> doesn't do things with the data files
15:54:47 <ndm> but its close enough for soem of it
15:54:53 <ndm> anyway, must go
15:54:55 <ndm> bye
15:55:10 <dcoutts> g'night ndm
16:05:54 <Lemmih> mnislaih: ping.
16:06:01 <mnislaih> hi Lemmih
16:06:27 <Lemmih> I finally got it built (:
16:06:45 <mnislaih> good. Did you find any issue ?
16:08:15 <Lemmih> Yeah, printing '()'s doesn't work.
16:09:05 <mnislaih> how did you do it ?
16:09:45 <Lemmih> myId :: a -> a; myId a = breakpoint a
16:11:15 <mnislaih> weird, it seems to work fine here
16:11:40 <mnislaih> what does it print for you ?
16:11:56 <Lemmih>     Failed to load interface for `GHC.Base':
16:11:57 <Lemmih>       no package matching ase was found
16:12:35 <mnislaih> oh, that's because you are missing a patch at libraries/base i think
16:12:44 <mnislaih> it should be at the repo too
16:13:21 <mnislaih> actually I modified the darcs-all script, so you should have got those patches already
16:13:24 <mnislaih> can you check ?
16:14:33 <Lemmih> What's the name of the patch?
16:15:31 <mnislaih> Introduce Unknowns for the closure viewer. Add breakpointCond which was missing
16:16:41 <Lemmih> I have that.
16:18:22 <mnislaih> so why would your ghci say that it's missing GHC.Base ?
16:18:43 <Lemmih> It's missing 'GHC.ase'.
16:19:59 <mnislaih> I will look into it.
16:23:56 <mnislaih> oh, it's missing a package called 'ase'
16:24:28 <mnislaih> did you pull any new ghc-6.5 patches not from my repo ?
16:24:35 <Lemmih> Nope.
16:28:49 <Lemmih> Wow, the dynamic breakpoints are neat.
16:29:15 <mnislaih> I've found them to be quite useful
16:29:47 <alec> I'm writing a program that needs to keep track of its internal state so that it can update the display (using Gtk2Hs).  The function that updates the display can't pass along its current state to the next call, so I need some way to store and retrieve that state independent of the function.  I've looked at the State monad and Data.IORef but can't figure out which one (if either) I'm looking for.  Can anyone help me get started with this?
16:29:54 <eivuokko> Could I interest ghc hackers with possible testsuite speedup?  I have posted (to cvs-ghc@) few patches that adds THREADS-support (muhc like make -jN) to testsuite.  I could use bug reports or feedback :-)
16:30:06 <xerox> alec: you need IORefs, yes.
16:30:12 <dcoutts> alec, I suggest using both.
16:30:42 <alec> xerox: that's what I was leaning towards, thanks
16:30:42 <xerox> Hm.
16:30:48 <alec> dcoutts: in what way?
16:30:50 <xerox> Listen to dcoutts, anyway.
16:31:12 <dcoutts> alec, have the actions run in a State monad and use a little wrapper to retrieve state from an IORef, run the State action and then store the state back in the IORef
16:31:43 <alec> dcoutts: thanks, I'll try that
16:32:02 <dcoutts> alec, then in your events you'd say something like: onClicked button $ do runActionWithState (blah x)
16:32:19 <dcoutts> alec, only, you'd think of a better name than that :-)
16:32:34 <alec> well, that's the hard part, isn't it?
16:32:40 <dcoutts> heh
16:33:03 <dcoutts> then runActionWithState has access to an IORef and it runs the action and updates the state with result of the action
16:33:16 <dcoutts> alec, a similar technique is to use a thread
16:33:35 <ptolomy> Is there an equivalent of "select" in the ghc standard libs?
16:33:55 <dcoutts> ptolomy, hWaitForInput
16:34:14 <ptolomy> Ooh.
16:34:16 * ptolomy missed that one.
16:34:21 <ptolomy> dcoutts: Thanks. :)
16:34:35 <dcoutts> ptolomy, or threadWaitRead/threadWaitWrite
16:34:58 <dcoutts> ptolomy, the point is to use lightweight Haskell threads rather than directly using select()
16:35:10 <xerox> runActionWithState action = do { state <- readIORef stateRef; let (x,state') = runState state action; writeIORef stateRef state'; return x }
16:35:18 <ptolomy> I like it.
16:35:38 <dcoutts> alec, in the thread style, the event handlers post messages to a queue and a thread reads from the queue in a loop. Thus the thread can hold any state it likes, just using normal recursion.
16:36:04 <xerox> dcoutts: do you have an example skeleton implementation of this last technique?
16:36:18 <dcoutts> xerox, of the threads, yes. inthe hIDE gui.
16:36:33 <xerox> Interesting.
16:36:40 <dcoutts> it's a nice model imho
16:36:47 <eivuokko> Yeah, I like it too.
16:36:51 <xerox> Might it be taken out as library code and reused?
16:36:55 <ptolomy> OS threads are for suckers.
16:36:58 <dcoutts> sure, it;s quite simple
16:37:01 <xerox> Great.
16:37:04 <dcoutts> using a queue has certain advantages
16:37:16 <xerox> I'd like to see that, but I know you are very busy now.
16:37:20 <dcoutts> less chance of deadlock for one
16:37:31 <dcoutts> xerox, look at the code, it's not that tricky
16:37:49 <xerox> Okay.
16:38:21 <alec> dcoutts: that sounds like what I'm looking for, I'll look at the hIDE code for help
16:39:46 <dcoutts> http://darcs.haskell.org/hIDE/packages/gtkBase/src/Hide/IdeShell/MainWindow.hs
16:39:59 <dcoutts> alec, ^^^ see the CmdQueue bit at the bottom of that module
16:40:32 <dcoutts> it's only 15 lines of code or something
16:41:37 <dcoutts> it uses a thread to maintain a state and then allows you to post actions to the thread which modify the state
16:41:48 <dcoutts> the actions get serialised by the queue
16:41:53 <dcoutts> so it's all thread safe
16:42:05 <dcoutts> and actions can even post more actions
16:42:28 <dcoutts> unlike in the single IORef/MVar version
16:42:38 <dcoutts> xerox, see? get it?
16:42:51 <xerox> I don't know what a Chan is
16:43:08 <xerox> @docs Control.Concurrent
16:43:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
16:43:14 <dcoutts> it's a thread safe queue
16:43:15 <alec> xerox http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-Chan.html
16:43:22 <alec> just looked it up myself
16:43:49 <dcoutts> xerox, it's a bit like a mutable list where you add items one end and remove them at the other end.
16:44:01 <xerox> dcoutts: makes sense.
16:44:24 <dcoutts>   let cmdLoop st = do
16:44:24 <dcoutts>         cmd <- readChan chan
16:44:24 <dcoutts>         st' <- cmd st
16:44:24 <dcoutts>         cmdLoop st'
16:44:33 <dcoutts> so it just goes round and round
16:44:38 <dcoutts> it waits for a command
16:44:45 <dcoutts> runs in, giving a new state
16:44:51 <dcoutts> and then does it again
16:44:56 <xerox> readChan blocks?
16:44:59 <dcoutts> yes
16:45:06 <xerox> But it blocks just one thread?
16:45:20 <dcoutts> well it's the only reader of the chan
16:45:36 <dcoutts> threads writing to the chan are never blocked
16:45:40 <dcoutts> it's unbounded
16:45:53 <dcoutts> but if the chan is empty then reading blocks, yes
16:45:55 <xerox> What does `unbounded' means?
16:46:06 <xerox> *mean
16:46:13 <dcoutts> not bounded, you can put as many items in the chan as you like
16:46:25 <dcoutts> (until your prog runs out of heap :-) )
16:46:37 <dcoutts> unlike an MVar
16:46:37 <xerox> Ah, if it was, it would certainly block on write if it reached the limit.
16:46:48 <dcoutts> which is a single box which can be empty or full
16:47:02 <xerox> I see, nice.
16:47:07 <dcoutts> xerox, right, that'd be a bounded chan, which can be useful.
16:47:47 <xerox> So that is a chan of actions modifying state.
16:47:57 <xerox> Fun :)
16:48:49 <dcoutts> yep
16:49:40 <xerox> Do you know other nice possible means of operation in threaded context?
16:49:41 <dcoutts> xerox, then I use a CmdQueue WindowState
16:49:59 <xerox> Yes, I see it.
16:50:14 <dcoutts> that's a bit of a general question :-)
16:50:30 <dcoutts> there are lots of things you can do with threads
16:50:38 <xerox> I know, sorry. I don't have much knowledge of concurrent programming.
16:50:49 <dcoutts> me neither actually
16:51:16 <dcoutts> the nice thing about the above pattern is that there are no IORefs mixed into the code
16:51:33 <xerox> Yes!
16:51:36 <dcoutts> which gets really ugly
16:51:54 <dcoutts> essentially the thread plays the part of the IORef
16:51:56 <xerox> Does it need the context-switch timed hack you rolled up something ago?
16:51:58 <dcoutts> but there's only one of them
16:52:04 <dcoutts> xerox, yep
16:52:09 <xerox> I see.
16:52:51 <xerox> Yeah, I see it.
16:53:29 <LordBrain> á <- a with an accent
16:53:39 <LordBrain> hmmm i think i have my utf support now
16:53:41 <xerox> Yes, in a strange encoding, too.
16:53:46 <LordBrain> oh?
16:53:48 <xerox> Ã 
16:53:51 <xerox> This is UTF-8.
16:53:57 <LordBrain> :(
16:54:02 <LordBrain> thats a with an accent?
16:54:30 <xerox> The accent is in the other direction, but yes.
16:54:49 <kpreid> LordBrain: that was probably latin-1 you used
16:55:29 <xerox> Howdy lennart.
16:55:51 <xerox> kpreid: how do you find that out?
16:56:33 <kpreid> xerox: my client falls back to latin-1 and lets me know about it if a message isn't the chosen encoding, which is utf-8
16:56:36 <alec> my $LANG is en_US.UTF-8 and both showed up as I'd expect them to
16:57:24 <xerox> kpreid: right, same here, but the message is generic.
16:57:41 <kpreid> and I know what the message means
17:00:49 <LordBrain> ok... i think i got it now --> Ã¡
17:00:58 <LordBrain> that utf-8?
17:01:20 <kpreid> yes
17:01:25 <LordBrain> yay :)
17:04:21 * Oejet finally understand Gtk2Hs a bit.
17:04:32 <Oejet> *-s
17:04:35 <dcoutts> Oejet, well done :-)
17:04:44 <dcoutts> feel like writing a tutorial?
17:05:12 <dcoutts> we made a start on an outline, but we're busy busy with other things.
17:05:49 <dcoutts> http://haskell.org/haskellwiki/Gtk2Hs/Tutorials/Intro
17:05:50 <lambdabot> Title: Gtk2Hs/Tutorials/Intro - HaskellWiki
17:06:11 <dcoutts> that's the skeleton of an intro tutorial
17:06:11 * Oejet feels like a mouse in a trap.  "Mmm, finally I found out where they hide the cheese, hehe", the mouse sqeeked before taking a bite. ;-)
17:06:24 <dcoutts> hah
17:08:13 <Oejet> Aha, I'll keep the tutorial in mind.  What are you busy with.  Do you support GTK+ 2.10?
17:08:57 <dcoutts> it should work with GTK+ 2.10, but doesn't support any of the new Gtk+ 2.10 features yet
17:09:00 <dcoutts> still 2.8
17:09:14 <dcoutts> I'm busy with many things :-)
17:09:44 <LordBrain> A
17:10:03 <dcoutts> Oejet, like a paper on ByteStrings, a PhD, cabal, gentoo, the next Gtk2Hs release, etc etc..
17:10:12 <dcoutts> (too many things)
17:11:48 <Oejet> That list is prioritised?
17:12:30 <Oejet> The most difficult thing about gtk2hs is the gtk part.
17:12:52 <dcoutts> Oejet, vaugely prioritised yes.
17:13:17 <dcoutts> Oejet, mm, things like widgets, events etc?
17:13:28 <Oejet> The part I understand a bit better now, is the mapping.  Haven't really before, though.
17:13:31 <xerox> hehe
17:13:37 <xerox> That was exactly the same for me.
17:13:42 <Oejet> dcoutts: Yes.
17:13:46 <xerox> The first time I did a GUI was with Gtk2Hs :)
17:14:02 <dcoutts> Oejet, the mapping? I'm not sure I know what you mean.
17:14:09 <dcoutts> xerox, :-)
17:15:40 <Oejet> dcoutts: Ups, meant to make that sentence longer.  Guess it is getting late. ;-)  The mapping between Haskell functions and C procedures.  It is quite straight forward with a bit of syntactic sugar (the set function).
17:16:04 <dcoutts> Oejet, right, yes.
17:16:23 <xerox> set is great.
17:16:37 <xerox> HOC doesn't have it, and it resorts to TH for some reason...
17:16:49 <dcoutts> we're tring to expand the use of set
17:16:58 <xerox> Well, it has a set, but it doesn't work like Gtk2Hs' one.
17:16:59 <dcoutts> and a similar thing for signals
17:17:38 <Oejet> For me "set" added a layer.  It helped rewriting Hello.hs to the lowest abstraction.
17:18:42 <Oejet> Isn't there a paper/document describing the binding design principles?
17:19:14 <dcoutts> Oejet, not really. There's something very old on Gtk+HS I think.
17:19:30 <dcoutts> Oejet, there's a presentation on Gtk2Hs, but not on the design.
17:26:25 <dons> morning
17:26:26 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
17:41:41 <Oejet> Ha!  Added a line to the tutorial wiki. :-)
17:41:54 <dons> ?karma+ Oejet
17:41:54 <lambdabot> Oejet's karma raised to 2.
17:42:05 <xerox> ?localtime dons
17:42:06 <lambdabot> Local time for dons is Tue Aug 22 10:40:51 2006
17:42:09 <xerox> Good morning :)
17:42:49 <Oejet> ?localtime Oejet
17:43:27 <LordBrain> hmmm is localtime part of the irc protocol?
17:43:38 <LordBrain> like.. is it displayed in our whois or something?
17:43:41 <Pseudonym> It's CTCP
17:43:47 <Pseudonym> Most clients support it.
17:43:50 <xerox> It's Pseudonym!
17:43:51 <Pseudonym> ?localtime lambdabot
17:43:57 <Pseudonym> Where?
17:43:59 <dons> doesn't answer ctcp
17:43:59 <Pseudonym> Oh, right.
17:44:00 <xerox> There!
17:44:15 <dons> ?localtime #haskell
17:44:34 <xerox> boom.
17:45:20 <Oejet> Good night/morning to everybody.  See you tomorrow.
17:45:51 <xerox> Goodnight!
17:45:56 <Pseudonym> Night.
17:47:49 <LordBrain> hmmm ~. is the digraph for Â·  so i suppose that could be an alternative if we really must get rid of . for composition
17:48:28 <xerox> What does it mean that ~. is the digraph for Â· ?
17:49:54 <LordBrain> vim and screen... follow a suggestion from rfc1345 for typing certain characters as sequences of two characters
17:50:06 <LordBrain> called digraphs
17:50:22 <dolio> Like "Goedel" versus "Gödel"
17:50:25 <LordBrain> in scren you can try it, using default bindings: ctrl-a ctrl-v ~.
17:50:39 <dons> LordBrain: we're getting rid of . for composition now?
17:50:57 <LordBrain> dons yeah there is talk about it
17:51:04 <LordBrain> here i'll find the page
17:51:24 <dons> I know, but i don't think its going to happen.
17:51:29 <xerox> What do you mean by "in screen" ?
17:51:37 <xerox> (Or is it scren?)
17:52:51 <dons> you mean, "screen" the terminal multiplexor
17:53:03 <xerox> It prints the version string that way :)
17:53:53 <LordBrain> http://hackage.haskell.org/trac/haskell-prime/wiki/RemovalCandidates
17:53:54 <lambdabot> Title: RemovalCandidates - Haskell Prime - Trac
17:54:33 <LordBrain> dons yes i meant the terminal multiplexer
17:54:46 <LordBrain> GNU Screen, and Vim.. they follow the same digraph convention
17:54:52 <LordBrain> i dont know if anything else does
17:55:01 <dons> mmm. 16 core mips
17:55:33 <LordBrain> i like . as composition tho
17:56:53 * xerox too
17:57:05 <xerox> It's spreading all over the code, in many Haskell projects.
17:57:06 <dons> though I'd also be happy to use \compose
17:57:33 <LordBrain> i've only just begun with haskell, but i've already become pretty accustomed to the "pipe idiom" f . g . h . k . l . m $ x
17:57:41 <dons> its good :)
17:57:48 <xerox> dons: â€¢, Â·, yeah.
17:57:57 <xerox> It is!
17:58:06 * dons sees a^  @ and c| printed
17:58:12 <xerox> :-(
17:58:22 * dons is unicode-a-phobic
17:58:28 <LordBrain> would it confuse something if we used -> for record syntax?
17:58:34 <xerox> Turn unicode-a-ware, dons!
17:58:46 <LordBrain> i know we use -> for lambdas... and for types of functions
17:59:03 <Pseudonym> I personally don't see why we use . for module qualification.
17:59:13 <LordBrain> i mean as myRecord->field
17:59:16 <xerox> Pseudonym: good point
17:59:30 <Pseudonym> It's not like every language uses it.
17:59:37 <Pseudonym> Mercury uses :, C++ uses ::
17:59:41 <Pseudonym> To pick but two.
17:59:49 <lennart> Personally, I don't understand why we use . for composition. :)
17:59:56 <Pseudonym> Module-aware Prologs use :: too.
18:00:15 <dolio> : would be even more problematic. :)
18:00:17 <Pseudonym> lennart: I note the smiley, but it's a reasonable thing to note.
18:00:31 <LordBrain> which do we type more often, at this point its certainly composition... but assuming we had the record syntax...
18:00:40 <xerox> ':' would probably be problematic, but '::' would certainly do.
18:00:49 <Pseudonym> Yes, that might be fine.
18:00:51 <LordBrain> :: is used for type signatures
18:01:01 <lennart> I know it's too late to change . as composition, but i think it's a bad idea.
18:01:09 <dolio> Probably. Unless someone's in the habit of not having space between type signatures and function names.
18:01:18 <Pseudonym> id::a->a
18:01:20 <dons> lennart: what are the alternatives?
18:01:26 * dons looks at keyboard
18:01:30 <madpickle> @ ?
18:01:38 <xerox> @ is huge!
18:01:50 <Pseudonym> Yes, you want something with very little visual weight.
18:01:53 <xerox> Points-free code is so clean with . :-)
18:01:58 <dons> f - g?
18:02:00 <dons> hehe
18:02:00 <madpickle> use '
18:02:05 <dons> ah yes
18:02:11 <lennart> well, these days I'd pick something unicody for composition.  But we could have used, e.g. #
18:02:12 <xerox> @pl \f g x y z w -> f (g x y z w)
18:02:13 <lambdabot> (.) . (.) . (.) . (.)
18:02:30 <Pseudonym> Simple function composition is like a human right in a functional language.  It has to be there and it has to be simple and elegant to get at.
18:02:35 <LordBrain> would be much like other heirarchical systems..
18:02:39 <LordBrain>  /
18:02:42 <xerox> Pseudonym for president!
18:03:00 <madpickle> what about ';' ?
18:03:08 <LordBrain> there is #
18:03:18 <LordBrain> for records... record#field
18:03:19 <madpickle> it has a dot in it - that has to be good.
18:03:42 <LordBrain> or record#>field
18:03:47 <LordBrain> *shrugs*
18:03:52 <madpickle> #> ?
18:03:53 <madpickle> O.o
18:03:56 <LordBrain> i made it up
18:03:59 <madpickle> indeed
18:04:00 <madpickle> =P
18:04:03 <LordBrain> :)
18:04:06 <LordBrain> @type (#>)
18:04:09 <lambdabot> Not in scope: `#>'
18:04:47 <xerox> Is Â§ ASCII?
18:05:02 <dons> looks like 2 bytes to me
18:05:04 <Pseudonym> A$ is BASIC
18:05:19 <xerox> haha, you unicode-unawares...
18:05:35 <LordBrain> record~field
18:05:49 <LordBrain> Module~exportedfunc
18:05:51 <dolio> @type (~)
18:05:51 <madpickle> ‡
18:05:52 <lambdabot> parse error on input `)'
18:06:04 <LordBrain> Data~Char
18:06:10 <Pseudonym> Requiring Unicode characters is a great idea!  Especially since Haskell implementations have _such_ good support for Unicode!
18:06:14 <madpickle> yeah
18:06:18 <madpickle> make it require an APL keyboard
18:06:18 <dons> import Data-ByteString-Lazy
18:06:18 <LordBrain> lol
18:06:34 <madpickle> i can just see all the old farts in here waxing nostalgia over *that*
18:06:36 <xerox> Pseudonym: I didn't mean to suggest a unicode char, that's why I asked it was ASCII in first place.
18:06:37 <dons> madpickle: you mean a Lambda keyboard
18:06:48 <madpickle> hehe
18:06:51 <Pseudonym> import Data::ByteString::Lazy
18:06:54 <Pseudonym> That's not so bad.
18:06:57 <xerox> I like it.
18:07:00 <madpickle> reminds me of Perl
18:07:07 <xerox> Don't say that.
18:07:17 <LordBrain> well...
18:07:20 <LordBrain> suppose you do
18:07:21 <Korollary> Let's apply huffman coding to lexemes.
18:07:30 <LordBrain> import qualified Data::Char
18:07:37 <LordBrain> then you say
18:07:45 <madpickle> import Data, ByteString, Lazy
18:07:46 <dons> why use two when one would suffice: Data:Char
18:08:02 <LordBrain> hmm
18:08:03 <Pseudonym> Hey, we haven't used the windows key for anything yet.
18:08:05 <dons> its a list, not a type ;)
18:08:08 <jer> dons, reminds me of newtonscript
18:08:12 <madpickle> that's because it's not a key character
18:08:18 <wolverian> dons, to reserve : for something else, of course :)
18:08:21 <LordBrain> i believe the macs use ; for their directory heirarchy
18:08:24 <Pseudonym> :: is already a special lexeme, : is not
18:08:33 <jer> LordBrain, :, and classic mac's do, osx uses /
18:08:33 <Pseudonym> I think.
18:08:38 <madpickle> @type (::)
18:08:39 <xerox> dons: right, but then if it happens in parenteses inside an expressions, it could be misinterpreted for a list'
18:08:41 <lambdabot> parse error on input `::'
18:08:57 <dons> yeah true
18:09:04 <dons> D:X:Y:[]
18:09:13 <Pseudonym> Oh, I guess it is special.
18:09:14 <dons> D:X:Y:[]::Z
18:09:36 <xerox> What about using what Haddock docs uses now, '-'.
18:09:36 <LordBrain> well
18:09:43 <dons> ok, so unicode it is then, to go along with our foralls and lambdas
18:09:44 <madpickle> i don't like typing '-' though
18:09:52 <xerox> @docs Control.Monad.Reader
18:09:52 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader.html
18:09:56 <Pseudonym> :: has the advantage that it's not a valid conop
18:10:05 <xerox> import Control-Monad-Reader
18:10:16 <dons> Control/Monad/Reader
18:10:18 <madpickle> and of course, it has to be conveniently placed on a US-English keyboard.
18:10:27 <xerox> dons: yeah I thought about that too, is it too much? :D
18:10:31 <Pseudonym> instance Num Bool where {- details -}
18:10:32 <dons> hehe
18:10:33 <Pseudonym> True-False
18:10:36 <xerox> (I liked it, hehe)
18:10:38 <LordBrain> i think unicode would be a pain... people having to hassle over their locale settings and things.. or their editors.. etc
18:10:49 <madpickle> unicode wouldn't fly
18:10:59 <Pseudonym> Ah, thought of a problem with ::
18:11:12 <Pseudonym> Module-qualifying conops.
18:11:12 <madpickle> Data!Char
18:11:22 <xerox> `conops' ?
18:11:25 <LordBrain> how about ~ ?  Is ~ used for anything?
18:11:26 <Pseudonym> x Prelude::: xs
18:11:33 <Pseudonym> xerox: Constructor operators.
18:11:39 <dons> LordBrain: lazy patterns
18:11:47 <madpickle> what about '!' ?
18:11:51 <dons> strict ones
18:11:52 <xerox> Pseudonym: argh.
18:12:04 <madpickle> why not just white space?
18:12:09 <dons> & and ? aren't used
18:12:15 <Pseudonym> Mind you, x Prelude.: xs is no more elegant.
18:12:25 <madpickle> yeah but that's Shift-7 for &
18:12:27 <xerox> We can even define :foo things, |a Foo::Bar:::foo b|.
18:12:30 <dons> Prelude::: would be good ;)
18:12:32 <madpickle> i don't like Shift-7
18:12:34 <LordBrain> madpickle: white space for composition ?
18:12:43 <dons> or would that be Prelude::(:) while we're fixing things
18:12:46 <madpickle> LordBrain: sure. if you bracket it
18:12:48 <madpickle> (Data Char)
18:12:54 * madpickle shrugs
18:12:59 <xerox> Yuck.
18:13:12 <xerox> Depending on ASCII is painful, isn't it.
18:13:24 <madpickle> would you rather a chinese charset?
18:13:34 <madpickle> (or something along those lines)
18:13:39 <madpickle> that'd be pain
18:13:46 <dylan> ascii or non-ascii, you have to deal with existing keyboards.
18:14:05 <dons> unless we distribute happy-lambda keyboards with ghc
18:14:05 <dolio> Yeah, that's the real problem. Typing the stuff.
18:14:24 <LordBrain> typing and also using software to view source
18:14:41 <xerox> ...or a convenient input system...
18:14:44 <LordBrain> yeah
18:14:58 <xerox> Well, even if you add 'software' there, it's still unmanageable.
18:14:59 <dylan> Non-keyboard input systems bother me, if they're based on a stylus.
18:15:01 <xerox> Blah.
18:15:23 <LordBrain> maybe its time to make some slight modification to qwerty
18:15:31 <LordBrain> hehehe
18:15:31 <madpickle> heh
18:15:34 <madpickle> i think they called it 'dvorak'
18:15:37 <madpickle> never hit it off =P
18:15:41 <dylan> (so says the block-printer with 0.5 word per minute output)
18:15:58 <xerox> In fact people can type japanese on a qwerty keyboard without much hassle
18:16:19 <xerox> Requiring unicode would just make the Haskell learning curve more steep, consider the advantages.
18:16:31 <LordBrain> hmmm
18:16:32 <madpickle> requiring unicode is just silly
18:17:01 <dylan> I still have not found a unicode terminal I can use day-to-day
18:17:07 <LordBrain> i'm not sure it would make the learning curve steeper... it would just add some hassle to would-be haskellers
18:17:12 <dolio> Hey, you don't _have_ to use unicode. Just if you want to compose functions. :)
18:17:19 <xerox> The community remains relatively small, with the advantage of easy develoment/modifications of the language that we have now :)
18:17:19 <LordBrain> lol
18:17:25 <johnnowak> How about using a series of letters instead of repurposed special characters? Maybe we can call them 'words'?
18:17:38 <madpickle> johnnowak: eeeenteresting stuff
18:17:49 <xerox> dolio: that, too, and you can define the beloved `o`.
18:18:12 <LordBrain> nothing is going to beat .
18:18:17 <madpickle> •
18:18:35 <xerox> We could institute a #haskell-unicode channel for people to help setup the environments, hehe.
18:18:38 <kpreid> FWIW, I like . the way it is even with its two meanings
18:18:41 <dolio> `o` might actually be easier to type than a unicode character on a lot of setups.
18:18:54 <LordBrain> true
18:19:01 <Cale> dolio: that's what scim is for :)
18:19:02 <madpickle> i like '.' though
18:19:08 <madpickle> and a little ambiguity never hurt anyone
18:19:17 <dolio> It's certainly easier than ctrl-a ctrl-v ~.
18:19:26 <Cale> I do like . for composition
18:19:39 <Cale> But I think they could have gone with something else for module paths
18:19:45 <xerox> Cale: right! I also think input methods are good enough!
18:19:48 <Cale> | is a nice character for that
18:19:52 <LordBrain> Â· takes 5 strokes for me (including shift and ctrl) and thats after making a special binding for the digraph command... otherwise it would be 7
18:19:58 <Cale> Data|Map|empty
18:20:00 <madpickle> awkward to type in US-Eng keyboard though
18:20:03 <dylan> Â· is three here.
18:20:05 <dolio> ?type (|)
18:20:08 <xerox> M-S-. makes Â· here.
18:20:08 <lambdabot> parse error on input `|'
18:20:25 * johnnowak is just seeing a '.' in his irc client
18:20:29 <dylan> LordBrain: you need menu-as-compose. :)
18:20:37 <wolverian> heh, Â· is two strokes here
18:20:48 <madpickle> i see two characters
18:20:49 <dylan> Â· it's menu-.-. here
18:20:52 <madpickle> damn unicode.
18:21:02 <wolverian> altgr+. here
18:21:08 * johnnowak pokes urxvt
18:21:20 <madpickle> that does bupkis on my comp, wolverian
18:21:21 <johnnowak> I think perhaps I need to define a secondary font...
18:21:28 <Cale> This'd be the character to use for composition âˆ˜
18:21:31 <dylan> I'm viewing latin1 here, but irssi translates what I type to unicode and what I read to latin1
18:21:36 <wolverian> madpickle, hm?
18:21:37 <Cale> U+2218 RING OPERATOR
18:21:40 <xerox> If you are a points-free level hacker, you'd better get yourself a unicode-aware setup soon.
18:21:46 <madpickle> wolverian: the instruction you just gave
18:21:58 <madpickle> or, better yet
18:21:58 <johnnowak> xerox: This isn't actually under consideration, is it? :)
18:22:02 <wolverian> madpickle, I suppose it isn't universal. do you have a swedish/finnish keyboard?
18:22:02 <LordBrain> my menu key doesnt do anything for me.. it just prints 9~
18:22:04 <xerox> @arrr
18:22:04 <madpickle> not upgrade to a newever version of GHC
18:22:04 <lambdabot> Smartly me lass
18:22:08 <madpickle> wolverian: uh, no..
18:22:10 <madpickle> US-English
18:22:13 <dylan> LordBrain: Using X11?
18:22:18 <LordBrain> yes
18:22:18 <wolverian> then I doubt you have an altgr key
18:22:19 <Cale> I set caps-lock as compose
18:22:45 <Cale> and I use SCIM for input
18:22:47 <dylan> LordBrain: try putting "keycode 0x75 =  Multi_key" into ~/.xmodmap and doing xmodmap ~/.xmodmap
18:22:59 <Cale> x âˆˆ xs :)
18:23:29 <dolio> Boy, the students in these Sussman lectures are fantastic.
18:23:39 <Cale> If you're using gnome, configuring a compose key can be done from the Keyboard preferences dialog
18:24:12 <nealc> dolio, what?
18:24:23 <wolverian> Cale, so, how does it work? :)
18:24:32 <Cale> Î±Ïƒ Ï‚ÎµÎ»Î» Î±Ïƒ ÏˆÎ¿Î½Ï†Î¹Î³Î¸ÏÎ¹Î½Î³ Î± ÎºÎµÏ… Ï†Î¿Ï Î³ÏÎµÎµÎº.
18:24:34 <xerox> âˆ€Î±Î²Î³.Î±â†’Î²â†’Î³
18:24:39 <dolio> nealc: http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/
18:24:40 <lambdabot> Title: Structure and Interpretation of Computer Programs, Video Lectures
18:24:54 <LordBrain> dylan: ok.. that seems to have enabled the key, but it still doesnt help me make Â·
18:25:10 <dylan> LordBrain: really? menu . .?
18:25:27 <dylan> :se noai
18:25:28 <dylan> a:se ai
18:25:30 <xerox> Cale: how cool would it be to do this in Haskell for definitions: a â‰ âŠ¥
18:25:31 <dylan> Bah!
18:25:31 <LordBrain> Â· oh.. i see i thought it acted like a shift key
18:25:36 <Cale> LordBrain: ah
18:25:45 <dylan> I wish I remembered which fat-fingered screen combo did that, it's annoying
18:25:47 <Pseudonym> Will you all please stop trying to hack my terminal?
18:25:53 <madpickle> http://www.princeton.edu/~ina/infographics/starbucks.html
18:25:55 <lambdabot> Title: International Networks Archive / Map of the Month
18:26:00 * johnnowak looks at his keyboard -- what the heck is a menu key?
18:26:17 <Cale> xerox: hehe, â‰… would make a better identifier for a typeclass
18:26:18 * johnnowak presses the big apple buttons
18:26:24 <dylan> johnnowak: it's got a picture of a menu on it, it's a US-windows keyboard thing
18:26:31 <xerox> Cale: yarrrrr
18:26:42 <LordBrain> someone made a good point about layout tho
18:26:46 <johnnowak> dylan: ah. i'm out of touch. :)
18:26:47 * dons looks down and sees no apples, windows or menus, just ctrl and alt
18:26:56 <LordBrain> but i suppose all the white space characters are the same?
18:26:58 <dons> oh, and "Acesss IBM"
18:26:59 <dylan> dons: I want that keyboard
18:27:05 <johnnowak> dons: :) very nice
18:27:06 <xerox> Cale: there are so many interesting equality/equivalence/equal signs to be exploited! :)
18:27:07 <LordBrain> in utf8 i mean
18:27:16 <dylan> dons: spring-switch?
18:27:17 <Pseudonym> dylan: I have one too.  It's called a numeric keypad.
18:27:28 <LordBrain> we'd all end up using the apl keyboard
18:27:30 <dons> dylan: ?
18:27:31 <LordBrain> lol
18:27:32 * johnnowak complains about lenovo adding a windows key to the thinkpad
18:27:50 <dons> I should take a photo of my happy hacking keyboard some time
18:28:01 <dylan> Ah, a happy hacking keyboard
18:28:04 <LordBrain> i use my windows keys all the time in fluxbox
18:28:06 <dylan> I really need one of those.
18:28:18 <Cale> Whatever...  I use the windows key to control window manager functions, so it's not that bad :)
18:28:20 <johnnowak> dons: How do you like it? I am planning on ordering one. Do you have the 'lite 2' model or the more expensive one?
18:28:26 <dylan> LordBrain: I use the win keys to do all window-manager related functions.
18:28:29 <dons> i have the lite 2
18:28:32 <LordBrain> so do i dylan
18:28:38 <dons> http://www.elx.com.au/images/products/full/hhkl2ubk.jpg but in black
18:28:40 <Cale> I suppose it is a corporate logo, but given that MS Hardware made my keyboard, I won't complain.
18:28:45 <dylan> and so does Cale it seems
18:28:52 <johnnowak> dons: happy with it?
18:28:59 <dons> yeah, very
18:29:04 <dons> its been in good use for 6 years now
18:29:05 <johnnowak> good news then, thanks.
18:29:16 <Cale> I wish I had more control keys.
18:29:41 <dylan> Cale: Spoken like a true emacs user. :-)
18:29:47 <Cale> and I'm not even much of an emacs user, but I might be if I had more control keys :)
18:29:59 <LordBrain> the only thing i dont like is when laptops make special function shift keys, and put them right in the corner of the keyboard where i expect to find something like control.
18:30:10 <dylan> I wish the terminal supported extra control keys...
18:30:18 <Cale> It doesn't?
18:30:24 <Adamant> cokebottle
18:30:29 <Adamant> bucky
18:30:31 <dylan> well, I've never gotten vim to use the windows keys.
18:30:33 <Adamant> meta
18:30:35 <Adamant> shift. :)
18:30:37 <johnnowak> LordBrain: you haven't remaps capslock to control yet? :)
18:30:53 <dylan> LordBrain: caps lock makes a great control key
18:31:09 <Cale> Double bucky, you're the one!
18:31:09 <Cale> You make my keyboard lots of fun.
18:31:17 <LordBrain> hmmm interesting
18:31:20 <dons> xmodmap -e "remove Lock = Caps_Lock"
18:31:20 <dons> xmodmap -e "keysym Caps_Lock = Control_L"
18:31:20 <dons> xmodmap -e "keysym Caps_Lock = Control_L"
18:31:20 <dons> xmodmap -e "add Control = Control_L"
18:31:27 <LordBrain> the corner works nice for me tho
18:31:35 <xerox> Cale: <http://www.kinesis-ergo.com/fs-non-program.htm>
18:31:41 <LordBrain> i can push it with the side of my hand instead of a finger
18:32:11 <Cale> dylan: It also makes a great compose key
18:32:18 * johnnowak revokes LordBrain's copy of emacs
18:32:32 <LordBrain> i dont have emacs
18:32:36 <johnnowak> exactly.
18:32:38 <xerox> http://www.kinesis-ergo.com/images/layout_contour-qd-usb.gif
18:32:39 <LordBrain> i use vim
18:32:50 <xerox> Seems like you can have some extra control keys there.
18:32:55 <scsibug_> xerox: that's the keyboard i'm using...it's wonderful
18:33:01 <xerox> (On a kinesis contoured keyboard)
18:33:16 <xerox> scsibug_: I thought about getting one many times!
18:33:43 <LordBrain> i've heard the best thing ergonomically is a vertical keyboard
18:34:11 <LordBrain> some sort of mixture of the kinesis layout and vertical might be ideal for programming
18:34:17 <dylan> I like the discontinued MS Natural Keyboard Pros.
18:34:18 <scsibug_> xerox: i went back and forth on it... but now I love it so much I'm thinking about getting a second for work
18:34:22 <johnnowak> the best thing for your wrists is not touch-typing
18:34:36 <LordBrain> not touch-typing?
18:34:43 <johnnowak> yes.
18:34:50 <xerox> "Is that even possible?"
18:34:53 <LordBrain> like you mean look at the keyboard?
18:35:11 <dylan> Is it touch typing if you don't look, but just sort of know where each key is based on the position of the most recently typed key?
18:35:33 <SamB> what key should I map to compose?
18:35:34 <johnnowak> I mean, er, don't use a fixed home row technique.
18:35:41 <johnnowak> Mix it up.
18:35:44 <Cale> SamB: I use Caps-lock
18:35:49 <SamB> okay
18:35:51 <xerox> Caps-lock is a good choice SamB
18:35:53 <SamB> so how do you do it?
18:35:54 <xerox> Arr.
18:35:59 <LordBrain> what is a nonfixed home row?
18:36:07 <johnnowak> LordBrain: A mess.
18:36:10 <SamB> LordBrain: A baroque home row!
18:36:18 <johnnowak> Sure I max out at 50WPM... but damnit, my wrists feel great.
18:36:28 <LordBrain> like i put my fingers on a different row each day?
18:36:29 * johnnowak types with three fingers
18:36:43 <Cale> In gnome, I just go into the Keyboard Prefs -> Layout Options -> Compose key position -> Caps Lock is Compose.
18:36:51 <SamB> oh
18:36:58 <Cale> but if you're using something else, there's other ways
18:37:09 <SamB> I guess I'll re-add that line for gnome-settings-daemon to my .xsession file
18:37:26 <LordBrain> i like the way that kenisis thing uses the thumb
18:37:37 <xerox> johnnowak: I usually take care of hands' position while not writing text, but when I am at it I just speed on.
18:37:54 <SamB> what is the program for GNOME prefs?
18:37:59 <LordBrain> on a laptop i had, i bound the touchpad to be the esc key so i could just switch to normal mode with a tap from a thumb
18:38:10 <johnnowak> LordBrain: good idea...
18:38:17 <scsibug_> using the thumbs slows me down a bit (even after using it for over a year), but I've never had any pain, whereas my pinkies were killing me on a standard keyboard
18:38:41 <LordBrain> yeah i find my right pinky is over worked
18:38:45 <Cale> SamB: gnome-keyboard-properties
18:38:53 <xerox> I only use my left pinky!
18:38:53 <Cale> SamB: for me, it's on my System menu
18:38:57 <scsibug_> then again, the best thing for my hands would probably be to give up emacs :)
18:39:11 <johnnowak> I don't use my pinkies at all... I keep them up in the air like an Englishman drinking tea.
18:39:16 <madpickle> scsibug_: heresy
18:39:36 * lispy hears words of rsi and recommends dvorak, worked for me!
18:39:54 * johnnowak recommends a kensington expert mouse for the mousers in the room with rsi issues
18:40:00 <scsibug> dvorak + kinesis was my solution :)
18:40:00 <johnnowak> big trackball...mmm
18:40:17 <lispy> scsibug: ah, yeah, that is a good combo from what i hear
18:40:36 <lispy> switching between trackball and normal mouse is supposed to help
18:40:46 <lispy> so that you don't get to worn out with either design
18:40:58 <johnnowak> lispy: that's why I got it at first, but I found that I could just stick with the trackball and be fine
18:40:58 <lispy> ymmv and all that :)
18:41:04 <johnnowak> lispy: still a good idea though :)
18:41:08 <lispy> johnnowak: ah nice
18:41:18 * lispy uses a trackman currently
18:41:30 <xerox> You make he lean the head? :P
18:41:32 <johnnowak> i will say this massive trackball is great though because you can use it from all sorts of positions.. no "ergonomic" moulding that locks you into place
18:41:33 <LordBrain> dvorak+kenisis still looks like its going to work the right pinky a lot, judging from that diagram
18:42:05 <lispy> LordBrain: if you type svn a lot then sure
18:42:17 <johnnowak> LordBrain: you'll have to switch to darcs
18:42:21 <lispy> or maybe that's the right ring finger...
18:42:24 <lispy> exactly!
18:42:33 <lispy> darcs is mostly home row in dvorak
18:43:00 <lispy> teh, the or het would be good names for version control systems for dvorak typists :)
18:43:03 <LordBrain> i'm thinking of : . / \ | ? ' " all on that little pinky
18:43:28 * johnnowak dislikes languages that require so much use of shift
18:43:31 <lispy> LordBrain: with a kenisis you could move those characters if you're getting too much work out on that finger
18:43:50 <johnnowak> LordBrain: don't type ':', type 'cons' :)
18:43:54 <lispy> heh
18:44:17 <LordBrain> at least it doesnt handle the right-shift key anymore
18:45:23 <LordBrain> not to mention
18:45:54 <LordBrain> i make my situation worse using that shift key for things like () and {}
18:46:15 <lispy> oh, i use left shift key almost exclusively
18:46:28 <lispy> i can see where right+shift on those keys would be hell
18:46:34 * SamB wonders if his right pinky is overworked
18:46:36 <xerox> I change the position of the mouse often
18:46:39 <SamB> it does seem to hurt a little
18:46:47 <xerox> From the left, to the right of the keyboard, and back and forth
18:47:18 <LordBrain> well the way the teach typing properly, i really shouldnt use that shift key for things on the same side of the keyboard
18:47:34 <LordBrain> they teach left shift for right hand keys, and right shift for left hand keys
18:47:44 <xerox> Right, but it is so hard to change
18:47:47 <xerox> :)
18:47:47 <LordBrain> but i tend to use the shift that is near the key often.
18:48:14 <SamB> I think they don't necessarily know much... then again I'm not sure what I do anyway...
18:48:31 <LordBrain> if i try to switch shifts, i actually loose some of my touch-type skill.
18:51:28 <LordBrain> scheme was nice typing... it has lots of parens but at least they are the only required brackets
18:51:44 <LordBrain> and the words were very englishy
18:51:52 <LordBrain> i found it less readable tho than haskell.
18:52:15 <Korollary> The closing "))))))"s hurt.
18:52:22 <lispy> LordBrain: i mostly agree with that
18:52:25 <dons> ?users
18:52:59 * lispy pokes at lambdabot 
18:53:04 <lispy> ?vixen are you there?
18:53:06 <Lemmih> ?bot
18:53:09 <lambdabot> Maximum users seen in #haskell: 225, currently: 192 (85.3%)
18:53:09 <lambdabot> i'm here
18:53:09 <lambdabot> :)
18:53:12 <Korollary> let's all pound on it
18:53:16 <lispy> heh
18:53:18 <Korollary> Programs love that.
18:53:23 <dons> hehe
18:53:36 <dons> ?uptime
18:53:37 <lambdabot> uptime: 18 hours, 9 minutes and 52 seconds
18:53:49 <lispy> we're at 85.3% capacity? not bad
18:54:08 <xerox> haha
18:54:23 <dons> haskell is running at 85.3% capacity today
18:54:24 <lispy> quick, someone put out some dohnuts and tell #java
18:54:34 <Korollary> dohnuts?
18:54:42 <xerox> D'oh.
18:54:58 <lispy> yeah, that's one spelling...
18:55:12 <lispy> but the h is apparently optional
18:55:24 <lispy> it's common enough tho that google doesn't suggest anything
18:55:30 <SamB> doh!nuts
18:55:32 <lispy> i take that back
18:55:39 <lispy> Did you mean: doughnuts
18:56:05 * lispy throws in the towel and considers it a day
18:56:18 <lispy> i'm off to fight with my ex over dinner, yay!
18:56:23 <Korollary> Great idea.
18:56:37 <Korollary> I'm going to pull my own toenails.
18:56:40 <lispy> Korollary: logic never enters the picture when she asks if i want to have dinner...
18:56:47 <LordBrain> Korollary: you need to set up your editor so the cursor jumps back to the opening ( each time you type the closing one, and then back again... emacs does this by default i believe... but my vim does it too.
18:57:18 <Pseudonym> It's nice to be on such good terms with ones ex.
18:57:19 <LordBrain> that fixes most of the typing end of the )))))
18:57:20 <Korollary> LordBrain: Emacs does it. It's just that I read with my eyes and don't like to move the cursor around while I read.
18:57:25 <lispy> or you could have it just insert all the unmatched when you hit a key
18:57:37 <LordBrain> yes it is less readable as i said..
18:57:49 <johnnowak> vim does it with :set showmatch
18:58:03 <lispy> Pseudonym: yeah, in her mind things are going as planned and our romance is turning into a healthy friendship...in mind it's emotion soup and i don't like it
18:58:21 <Pseudonym> Mmmm... emotion soup...
18:58:25 <dylan> vim 7 highlights matching ( ) and such
18:58:26 <lispy> s/romance/failed romance/
18:58:28 <LordBrain> its probably the nicest computer language for typing tho.
18:59:04 <LordBrain> haskell isnt too bad tho
18:59:18 <johnnowak> anyone who thinks it is difficult to enter scheme/lisp code simply hasn't used it for long and/or with a sane editor
18:59:30 <johnnowak> it is the easiest thing i deal with
18:59:44 <xerox> > ((+) (sum [1,2,3]) ((subtract 1) 2))
18:59:47 <lambdabot>  7
18:59:49 <LordBrain> agreed... i just dont like the look of it tho.. i love the look of haskell
18:59:50 <xerox> Lispy.
19:00:09 <LordBrain> maybe we need to think of having different views on a given source file.
19:00:15 <johnnowak> LordBrain: It takes some getting used to. After awhile, you like all the roundy bits. :)
19:00:26 <Korollary> I am used to it. I don't like it.
19:00:31 <LordBrain> i dont think i will like it as much as i like looking at haskell
19:00:34 <Korollary> I don't like ocaml syntax either.
19:01:06 <johnnowak> I suppose not everyone is born with a proper sense of aesthetics... ;)
19:01:25 <LordBrain> yeah.. i think i've used scheme enough to appreciate its syntax.. but i dont really think its the best for readability.... i appreciate it for typing tho....
19:02:21 <dons> if someone wrote a haskell syntax preprocessor for ocaml, would it be welcomed, I wonder?
19:02:31 * kpreid likes and uses both Haskell and Lisp syntax
19:03:37 * johnnowak likes scheme, forth, and io syntax
19:03:39 <Korollary> ocaml has a preprocessor and even an alternate syntax already.
19:03:46 <LordBrain> i think conciseness actually adds to readability.
19:03:52 <LordBrain> if properly done
19:04:05 <dons> Korollary: yes, I know
19:04:14 <dons> hence it seems natural to add more :)
19:04:52 <LordBrain> i wouldnt mind if haskell borrowed some haskellisms
19:04:55 <LordBrain> er ocaml
19:05:01 <Korollary> dons: oh I thought you meant another processor written in haskell.
19:05:20 <LordBrain> i think i'd like type classes in ocaml  if they can fit somehow...
19:05:22 <dons> it seems that the syntax is one of the most common complaints about ocaml
19:05:24 <dons> and the lack of type classes
19:05:28 <dcoutts> yeah
19:05:39 * dcoutts is forced to use it for one practical
19:05:43 * dcoutts shudders
19:05:44 <dons> much as people complained about the speed of haskell in the bad old days
19:05:49 <dcoutts> :-)
19:06:04 <LordBrain> do type classes slow it down?
19:06:11 <dcoutts> unlike for example now, when people are not allowed to complain about speed
19:06:21 <Korollary> I am always allowed to complain about speed.
19:06:21 <LordBrain> lol
19:06:25 <johnnowak> dcoutts: :)
19:06:26 <dons> for fear of being told to visit the shootout site
19:06:31 <xerox> dons: it would be hard to do that syntax preprocessor in Haskell, if it included unicode operators?
19:06:49 <dcoutts> dons, that or to make their code use Data.ByteString :-)
19:07:00 <dons> yeah
19:07:05 <Korollary> dons: Can I still complain about k-nucleotide?
19:07:09 <dons> sure
19:07:13 <dons> complain away
19:07:15 * Korollary rejoices
19:07:20 <dcoutts> dons, I sent you a small pile of patches btw
19:07:21 <dons> I note no one has written a Data.ByteString version yet.
19:07:33 <dons> danke
19:08:05 <Korollary> Hm. In that case, mandelbrot then.
19:08:10 <xerox> sjanssen: ping
19:08:41 <dons> mandelbrot's not so bad anymore is it?
19:08:58 <dons> though clearly not ideal, where ideal = fastest on the planet
19:09:05 <dcoutts> @localtime xerox
19:09:06 <lambdabot> Local time for xerox is 2006-08-22 04:07:45 +0200
19:09:09 <dcoutts> mm
19:09:10 <dons> unlike nsieve*
19:09:14 <Korollary> It's improved quite a bit I see. But still about 3x.
19:09:30 <xerox> dcoutts: errr.
19:09:32 <dons> yeah, I'd like to see everything under 2x
19:09:39 <xerox> dcoutts: yes I didn't sleep yet.
19:09:40 <dons> (we average 1.4 or something now)
19:09:45 <dcoutts> xerox, me neither :-)
19:10:05 <xerox> dcoutts: you can blame dons
19:10:14 <Korollary> dons: I don't get how nsieve does so well.
19:10:23 <dons> super magics?
19:10:36 <Korollary> unboxed arrays on either side. What counts for the difference?
19:10:41 <dons> ghc just does well, what's to "get" ? :)
19:10:56 <dons> good bit packing of Bools?
19:11:32 <Korollary> I think that's it
19:11:54 <Korollary> gcc seems to use an unsigned char per bool.
19:12:03 <dons> ah
19:12:11 <dons> whereas we use bits
19:12:16 <xerox> bits? wow :)
19:12:17 <dons> so we win on space and time
19:12:24 <falconair> hi, i understand that a very light weight thread library can be created using continuations, is it possible to experiment with this in haskell?
19:12:27 <dons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsieve&lang=all
19:12:27 <xerox> You win on all the four axes :)
19:12:29 <lambdabot> Title: nsieve benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language S ...
19:12:38 <xerox> falconair: yes.
19:12:43 <dons> falconair: sure. should be easy to code up
19:12:50 <xerox> falconair: Paul Johnson demonstated that at AngloHaskell
19:13:16 * johnnowak finds the C version much more readable
19:13:20 <falconair> two more questions: what is the most relevant paper I should read and should i read generally about "The Continuation Monad"?
19:13:35 <xerox> ?google all about monads
19:13:37 <falconair> in other words, is the continuation monad the same continuation people talk about
19:13:39 <lambdabot> http://www.nomaware.com/monads/html/
19:13:39 <lambdabot> Title: All About Monads
19:13:43 <xerox> This article has a chapter on the Cont monad.
19:13:58 <dons> johnnowak: yeah, it would look better with nicer layout and bang patterns for strictness
19:14:14 <johnnowak> might the C version be faster if it used alloca instead of malloc?
19:14:37 <falconair> xerox, i see the continuation chapter in the article you mentioned, thanks
19:14:58 <dons> loop !arr !m !n !c
19:14:59 <dons>     | n == m    = return c
19:14:59 <dons>     | otherwise = do
19:15:00 <dons>         el <- unsafeRead arr n
19:15:01 <dons> ...
19:15:05 <dons> much cleaner
19:15:07 <falconair> now as for the relevant paper for a thread library, should i be searching for AngloHaskell?
19:15:34 <xerox> falconair: no, his code isn't public, but maybe you can find something on the wiki... I am not sure.
19:16:05 <falconair> hm, ok, i'll keep searching, thanks
19:16:15 <dons> should be just about possible to hack it up using a continuation monad and an encoding of threads with continuations from a textbook?
19:16:37 <dons> e.g. Harper's POPL book has a section on threads via continutations
19:16:41 <falconair> dons: which textbook?
19:16:47 * dons hunts
19:16:50 <xerox> falconair: I think I found something <http://www.cs.missouri.edu/~harrison/drafts/CheapThreads.pdf>
19:16:51 <Korollary> Wow
19:16:55 <Korollary> Igloo joined GHC HQ
19:17:07 <lispy> xerox: nice
19:17:11 <dons> http://www.cs.cmu.edu/~rwh/plbook/book.pdf
19:17:12 <lispy> xerox: i likey
19:17:34 <xerox> http://www.cs.missouri.edu/~harrison/papers/amast06.pdf this would probably talk about that too
19:18:09 <xerox> Yeah, seem nice
19:19:23 <dons> chapter 25 of the above, I think
19:19:57 <dons> good book to read, esp. at that price
19:20:06 <falconair> wow, some good links, the book.pdf looks like a great book!
19:20:21 <dons> ?where+ pfpl http://www.cs.cmu.edu/~rwh/plbook/book.pdf
19:20:22 <lambdabot> Done.
19:20:55 * johnnowak thinks the C nseive benchmark just bus errors for him
19:21:04 <falconair> so, my understanding is that light weight threads and something like MVars allow one to build the kind of concurrency that exists in Mozart/Oz...further, once one understands them, logic and constraint languages are built on top of MVars (and concurrency)...is that correct?
19:21:10 <wolverian> dons, hm.. who are the target audience of pfpl?
19:21:20 <dons> 3rd year students?
19:21:25 <wolverian> ah, that sounds about right. thanks
19:21:29 <dons> doing a principles of programming course.
19:21:38 <dons> that's what we use it for at unsw.
19:21:57 <wolverian> a mathematical sicp?
19:22:09 <dons> hmm?
19:22:27 <SamB> falconair: eh... logic and constraint languages?
19:22:33 <falconair> btw, the CheapThreads.pdf paper talks about doing operating system level work in haskell, amazing
19:22:34 <wolverian> dons, is it comparable to sicp in content?
19:22:52 <wolverian> I suppose not..
19:23:01 <dons> not sure
19:23:03 <SamB> falconair: well, we haven't got an OS that can run GHC yet...
19:23:11 <dons> its similar to TAPL in content
19:23:22 <dons> ?where House
19:23:22 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
19:23:29 <dons> falconair: you've seen ^^
19:24:03 <falconair> SamB, about logic and constraint, i believe MVars (logic variables?) are needed for logic programming...i'm a total newbie so i may very well be wrong
19:24:06 <Korollary> TaPL is heavier on types iirc.
19:24:20 <Pseudonym> Clearly you want PLaPL then.
19:24:45 <Korollary> Let's have a 3000-page tome.
19:25:05 <falconair> dons: i've heard of the house project before, never looked into it much...if haskell could do pretty graphics, i could see some places where it could be used
19:25:12 <dolio> What's the concurrency model in Mozart? CSP and message passing?
19:25:15 <falconair> (in industry i mean)
19:25:15 <xerox> Pretty graphics?
19:25:18 <dolio> Like Erlang?
19:25:24 <xerox> @where nymphaea
19:25:25 <lambdabot> http://haskell.galois.com/~paolo/nymphaea
19:25:29 <xerox> Yarr!
19:25:30 <dons> hehe
19:25:41 <dons> pretty graphics must be one of the easier things to do in haskell
19:25:47 <falconair> wow, never saw this nymphaea thing, cool!
19:25:52 <xerox> Thanks ^_^
19:26:05 <dons> or http://haskell.org/gtk2hs/archives/2006/01/26/cairo-eye-candy/
19:26:06 <lambdabot> Title: Gtk2Hs Â» Blog Archive Â» Cairo eye candy
19:26:21 <dons> the nicest clock app ever written
19:26:21 <xerox> There is an entry showing off all the cute demos...
19:26:29 <dcoutts> ah yes, more bling
19:26:34 <xerox> http://haskell.org/gtk2hs/archives/2006/03/06/introductory-presentation/
19:26:36 <lambdabot> Title: Gtk2Hs Â» Blog Archive Â» Gtk2Hs introductory presentation
19:27:20 <LordBrain> anyone here hack on kernels?
19:27:22 <Korollary> That is a sexy clock indeed.
19:27:37 <LordBrain> in haskell i mean
19:27:56 <dons> LordBrain: i work with some people who do
19:28:02 <dons> the l4/haskell guys
19:28:03 <dcoutts> LordBrain, it's actually a port of a C prog, but the Haskell version is shorter and neater.
19:28:13 <falconair> dolio: regarding mozart's concurrency, what i am interested in is that i can use fold/map/filter functions on continuously updating streams as easily as a normal list (think stock market quote processing)
19:28:32 <dons> ?where+ smallcheck http://www.cs.york.ac.uk/fp/smallcheck0.0.tar
19:28:33 <lambdabot> Done.
19:28:48 <dcoutts> LordBrain, ie it was someone other than me who came up with the code for doing the drawing. I don't have that kind of graphics skill.
19:28:49 <LordBrain> i'm just wondering what kind of setup they use... you know... booting in an emulator and all that...
19:29:06 <dolio> falconair: Hmm, interesting. I don't know about that. :)
19:29:33 <LordBrain> dcoutts: you mean the clock? if so.. i think you are actually intending to respond to Korollary
19:29:36 <falconair> mozart is a very nice language, i would learn it, but i don't want to learn emacs first :)
19:29:49 <dcoutts> LordBrain, oh, so I was :-)
19:29:54 <dons> LordBrain: might be useful to read: http://www.cse.unsw.edu.au/~chak/papers/DEKC+06.html
19:29:54 <lambdabot> Title: Research Papers of Manuel Chakravarty
19:31:04 <LordBrain> ok dons, i'm downloading the pdf
19:35:16 <dolio> falconair: Anyhow, MVars as in the Haskell concurrency libraries are just storage buckets guarded with a mutex for concurrent use, and wouldn't have anything specifically to do with logic/constraint programming.
19:35:51 <falconair> dolio: hm...thanks, i won't get to the logic stuff for a while anyway
19:36:54 <LordBrain> has anyone developed a non-side effect oriented oo system for haskell?
19:39:28 <LordBrain> does Oleg Kiselyov come to this chatroom ever?
19:39:49 <Korollary> You should just email him
19:42:35 <LordBrain> here is a question, since we have all our IO cleanly implemented within a monad, is there still motivation for developing such a nonside-effecting OO system?
19:42:56 <dons> OO system?
19:43:02 <LordBrain> like OOHaskell
19:43:09 <LordBrain> but without use of the IO monad
19:43:25 <dons> oh, no? this is the land of verbs
19:43:46 <LordBrain> OO System = Object System
19:45:46 <LordBrain> i guess the situation is similar to... should i worry about IO contaminating my code... or since its a monad its pure enough anyway and so i might as well go wild with it?
19:46:30 <dons> I suppose a pure OO system might be interesting
19:47:43 <LordBrain> the OOHaskell paper left that for future work
19:48:13 <LordBrain> vaguely it suggested that OOHaskell might eventually be modified to accomodate such a thing even...
19:50:05 <LordBrain> Cale you here?
19:50:19 <xerox> He quit some mins ago
19:50:22 <LordBrain> ah
19:52:47 <jrmole> anyone know of any projects to implement an OS in haskell with strongly-typed system calls?
19:53:55 <LordBrain> hmmm
19:54:09 <dolio> ?where house
19:54:10 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
19:54:11 <LordBrain> i'd sort of expect that would be a given... if they use Haskell for the system libs
19:54:23 <LordBrain> or do you mean dynamically typed?
19:54:55 <jrmole> well, i'm not interested in implementing something unix-ish in haskell
19:54:59 <jrmole> which seems to be more the direction they take
19:56:01 <dolio> Ah. I don't know of any others off hand.
19:56:16 <jrmole> like, there's no notion of the "type" of a program in House afaict
19:56:20 <LordBrain> i can search the logs.. i think others have been mentioned
19:56:34 <jrmole> well hOp is just a predecessor to house... are there any others?
19:59:30 <LordBrain> there's an L4 in haskell
19:59:41 <LordBrain> is that part of house?
20:01:02 <LordBrain> @where L4
20:01:02 <lambdabot> I know nothing about l4.
20:01:05 <LordBrain> @where l4
20:01:06 <lambdabot> I know nothing about l4.
20:01:08 <LordBrain> hmm
20:01:14 <beelsebob> I HATE COLIN RUNCIMAN!
20:01:21 <beelsebob> (but in the good way)
20:01:39 <dons> !
20:01:51 <dolio> There's "Towards a Strongly Typed Functional Operating System" about an OS written in Clean, but as I recall, it needed a host OS to run.
20:01:53 <LordBrain> @where l4-haskell
20:01:54 <lambdabot> I know nothing about l4-haskell.
20:01:58 <LordBrain> @where L4-haskell
20:01:58 <lambdabot> I know nothing about l4-haskell.
20:02:07 <beelsebob> his post about SmallCheck has made my brain go insane
20:02:12 <LordBrain> @google "L4 Haskell"
20:02:16 <lambdabot> http://tunes.org/~nef/logs/haskell/05.09.26
20:02:22 <emertens> lol
20:02:24 <beelsebob> I can't sleep
20:02:36 <beelsebob> because my brain is coming up with a million and one possible ideas
20:02:50 <emertens> 26 problems to go on mathschallenge.net before I can return to normal life
20:03:00 <beelsebob> :o
20:03:26 <xerox> G'day beelsebob
20:03:42 <pejo> LordBrain, don't think the source for the L4 stuff is avail. "Osker" is the name I think.
20:03:51 <jrmole> i found some stuff, cool
20:04:05 <jrmole> osker is related to house iirc
20:04:11 <Philippa_> 'lo beelsebob, LTNS
20:04:21 <beelsebob> lo Philippa_
20:04:30 <beelsebob> I see you were trying your unicycling ability
20:04:44 <pejo> jrmole, it's the "same" people.
20:04:58 <Philippa_> yep. It's kinda traditional, after all
20:05:03 <beelsebob> hehe
20:05:14 <Philippa_> although usually it happens before the pub...
20:05:18 <beelsebob> I might just have to not introduce myself to Shapr when I finally meet him
20:05:21 * xerox is reminded to add `buy a unicycle' to his TODO list
20:05:29 <LordBrain> dons mentioned 3 different Haskell OS projects
20:05:37 <beelsebob> and see if he discovers who I am by the fact I can ride it
20:05:38 <LordBrain> but i dont know what they are besides House
20:05:39 <Philippa_> it's not as hard as you'd expect, and really not dangerous until you're able to go fast
20:05:43 <Philippa_> ah :-)
20:05:47 <beelsebob> indeed
20:05:49 <xerox> Philippa_ is quite right :D
20:06:00 <beelsebob> my first accident was when I discovered I could go fast
20:06:04 <Philippa_> heh
20:06:08 <LordBrain> @where haskell os
20:06:09 <lambdabot> http://haskell.org/
20:06:09 <Philippa_> figures :-)
20:06:17 <beelsebob> simple physics dictates that if you're going as fast as you can on a unicycle, you can't slow down
20:06:20 <LordBrain> @where kernels
20:06:28 <beelsebob> this caused a rather rapid superman-dismount
20:07:40 <beelsebob> brb
20:08:18 <lambdabot> I know nothing about kernels.
20:08:49 <LordBrain> is there a firefox key for "jump to next text box" ?
20:08:58 <xerox> LordBrain: tab?
20:09:02 <Beelsebob|Mini> boo!
20:09:06 <LordBrain> tab hits all the links too
20:09:13 <LordBrain> i want something that skips over them
20:10:00 <Beelsebob|Mini> hmm, you want something that skips over which links?
20:10:16 <LordBrain> all links
20:10:25 <LordBrain> i want to jump straight to the textbox that i can type into
20:10:32 <Beelsebob|Mini> buy a mac
20:10:36 <LordBrain> haha
20:10:38 <Beelsebob|Mini> that's the default behaviour
20:10:41 <LordBrain> cant do
20:10:53 <xerox> Beelsebob|Mini is right anyway, that's the behavior :)
20:11:06 <xerox> Hack Firefox?
20:11:15 <LordBrain> hack firefox would be easier than buying a mac for me
20:11:21 <Beelsebob|Mini> why?
20:11:31 <LordBrain> because i can program but i dont have a job
20:11:36 <Beelsebob|Mini> lol
20:11:41 <xerox> Turn the former in the latter :)
20:11:45 <Beelsebob|Mini> eBay your computer
20:11:49 <Beelsebob|Mini> and then buy a mac
20:12:32 <LordBrain> i'm sort of a debian loyalist tho.
20:12:43 <Beelsebob|Mini> but it doesn't do what you want it to...
20:12:46 <Beelsebob|Mini> a mac does :P
20:13:36 <xerox> The awful truth.
20:14:35 <Beelsebob|Mini> (at least re tabbing behavior in safari)
20:15:19 <Philippa_> Beelsebob|Mini: PM?
20:15:25 <dolio> Hmm, dark matter conclusively discovered?
20:15:47 <Beelsebob|Mini> Philippa_: I've replied
20:15:48 <Beelsebob|Mini> lots
20:15:50 <Beelsebob|Mini> you haven't
20:16:06 <Philippa_> that's because you're not identified and it's going into the void
20:16:20 <Beelsebob|Mini> oh... PMs go into the void if I'm not IDed?
20:16:31 <Philippa_> on this network, yeah
20:16:42 <Philippa_> you've probably got a screenful of warnings about it somewhere
20:17:23 <Beelsebob|Mini> it'll have gone into the console for this session
20:17:29 <Beelsebob|Mini> that I can't be arsed to stare at
20:17:46 <Beelsebob|Mini> must file a bug report to get my client to display such errors
20:50:05 <coffeemug> hey guys
20:50:28 <coffeemug> I have a relatively simple question about Parsec
20:50:49 <coffeemug> can't seem to find the answer online
20:51:42 <coffeemug> I baiscally create a lexer based on emptyDef
20:51:57 <coffeemug> then create a simple parser like so:
20:52:09 <coffeemug> parser = integer lexer
20:52:17 <coffeemug> when I try to parse something like "x"
20:52:18 <coffeemug> it fails
20:52:23 <coffeemug> but when I parse "1x"
20:52:26 <coffeemug> it passes
20:52:57 <coffeemug> basically as long as the string starts with an integer, it just returns that and doesn't error out no matter what comes after the integer
20:53:08 <coffeemug> does anyone have any idea what I'm doing incorrectly?
20:53:34 <xerox> integer is supposed to parse a string starting with x ?
20:53:46 <coffeemug> no
20:53:55 <coffeemug> integer is a standard parser that parses integers
20:54:01 <xerox> Then it seems like a correct behaviour
20:54:07 <xerox> What is your problem?
20:54:16 <coffeemug> how is "1xyzabc" correct?
20:54:23 <coffeemug> it returns 1
20:54:29 <coffeemug> but where does xyzabc fit?
20:54:40 <xerox> Make it return what it parses.
20:54:42 <xerox> Right, it'll return 1.
20:54:44 <xerox> They don't.
20:56:23 <coffeemug> I don't understand why the parser doesn't return an error then
20:56:41 <Cale> coffeemug: Because it's okay for a parsec parser not to consume the entire input
20:57:31 <coffeemug> Cale: ah, I see
20:57:56 <coffeemug> so I should look for eof or something like that?
20:58:55 <Cale> yeah, eof is what you're looking for
20:59:11 <Cale> (that's actually the name of a parser in the library)
21:00:28 <coffeemug> ok, I think I see this being mentioned in the docs
21:00:43 <coffeemug> sorry for the silly question, it wasn't immediately obvious
21:00:48 <Cale> yeah
21:01:15 <midfield> dons: Hey, I modified some of the Binary / NewBinary stuff to write to ForeignPtr buffers.  Anyhow it got me thinking that Binary should be put together with FPS.
21:02:49 <kfish> oath
21:02:59 <kfish> with little/big endian parsing for common word sizes
21:04:20 <dons> well, we could certainly clean it up and package it
21:04:29 <dons> I think Binary should be in the base lib
21:07:13 <coffeemug> thanks guys
21:07:14 <coffeemug> good night
21:07:48 <midfield> now to learn quickcheck
21:09:30 * dcoutts thinks Binary on top of ByteString[.Lazy] is an exelent idea
21:24:07 <midfield> has anyone done any quickcheck stuff with the IO monad?
21:24:30 <midfield> er let me rephrase: anyone have any experience with it here?
21:25:13 <Cale> midfield: from what I recall, it's tricky and/or requires a moderate amount of cheating
21:25:33 <Cale> though that might have changed in the last year or so
21:26:26 <midfield> i'm just reading up on hughes claessen (2002).  but i'm not sure i'm getting it.
21:27:51 <Cale> oh, perhaps there was some work on monadic testing
21:28:21 <midfield> that paper talks about it a bit but i'm a little confused by it.
21:30:57 <Cale> any particular questions?
21:31:09 <Cale> I'm not 100% familiar, as I haven't used QC extensively
21:31:13 <Cale> but I can try :)
21:31:36 <Korollary> There's also HUnit, right?
21:31:42 * edwardk bounces around happily.
21:31:55 <Cale> Korollary: yeah, that's less-automatic unit testing
21:31:55 <xerox> Hey there edwardk
21:31:58 <edwardk> heya
21:32:00 * Korollary forces edwardk to watch Fox News
21:32:02 * chessguy slips edwardk a sedative
21:32:08 <edwardk> no more 4 implications =)
21:32:27 <edwardk> fox news?
21:32:36 <Korollary> That ought to bring you back to normal.
21:32:39 <edwardk> ah
21:32:46 <Cale> edwardk: A tool of Fascist America
21:33:05 <Korollary> You're either with us, or with another monad.
21:33:20 <edwardk> no, that just generally makes me annoyed at a republican mouthpiece being called news. ;)
21:33:34 <jcreigh> Hmm...what's the easiest way to represent a 2 dimensional array in Haskell. I'm writing a Sudoku solver, and I've been using nested arrays, but I'm wondering if there's an easier way...
21:33:50 <Cale> jcreigh: Use (Int,Int) as index type?
21:33:57 <jcreigh> Cale: You can do that?
21:34:01 <Cale> jcreigh: yeah
21:34:13 <Cale> jcreigh: You can use any type which implements the Ix class
21:34:17 <Korollary> @instances Ix
21:34:20 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
21:34:31 <Cale> @help instances-importing
21:34:32 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
21:34:39 <Cale> hehe
21:34:44 <Korollary> @instances-importing Ix
21:34:46 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
21:34:50 <Cale> @instances-importing Data.Ix Ix
21:34:51 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
21:35:07 <Cale> hmm
21:35:13 <Cale> There are others in the libraries.
21:35:18 <edwardk> yeah
21:35:20 <edwardk> lots more
21:41:41 <midfield> Cale: oh, i've modified the binary library, so i wanted to do some input == output type tests.
21:41:49 <midfield> (sorry was afk)
21:42:29 <Korollary> QC performs checks at the haskell value level, yes?
21:43:43 <midfield> Korollary: first time using it
21:45:37 * SamB wonders what happened to megatokyo.com
21:46:43 <Korollary> I havent used it either. It looks like one provides the specs as regular haskell values and functions.
21:47:14 <SamB> yeah!
21:47:22 <SamB> @hoogle quickCheck
21:47:26 <lambdabot> Test.QuickCheck.quickCheck :: Testable a => a -> IO ()
21:47:26 <lambdabot> Test.QuickCheck :: module
21:47:43 <SamB> @instances-importing Test.QuickCheck Testable
21:47:45 <lambdabot> (), Bool, Property, Result
21:48:15 <SamB> hmm...
21:48:18 <midfield> SamB: so if i write properties with the signature a -> IO Bool that should do it?
21:48:26 <Korollary> Since an IO action is forced by the runtime to yield a value, I don't see how you can compare them.
21:48:34 <SamB> midfield: uh, I dunno about IO...
21:48:45 <SamB> I never tried to use it for IO stuff...
21:49:00 <SamB> @docs Test.QuickCheck
21:49:01 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/QuickCheck/Test-QuickCheck.html
21:49:44 <midfield> the aformentioned paper talks about it a bit, they use it to generated tests for mutable data structures.
21:49:53 <midfield> i just don't have the energy to grok it atm.
21:50:11 <SamB> hmm
21:50:28 <SamB> why doesn't @instances-importing mention this instance: (Arbitrary a, Show a, Testable b) => Testable (a -> b)
21:51:21 <SamB> I certainly don't see an instance for IO a
21:54:27 <SamB> @type Test.Quickcheck.quickCheck (putStrLn "Hello!")
21:54:30 <lambdabot> Couldn't find qualified module.
21:54:33 <SamB> @type Test.QuickCheck.quickCheck (putStrLn "Hello!")
21:54:35 <lambdabot>   No instance for (Test.QuickCheck.Testable (IO ()))
21:54:35 <lambdabot>    arising from use of `Test.QuickCheck.quickCheck' at <interactive>:1:0-25
21:54:41 <SamB> yeah, see?
21:54:50 <SamB> @type Test.QuickCheck.quickCheck (putStrLn "Hello!" >> return True)
21:54:51 <lambdabot>   No instance for (Test.QuickCheck.Testable (IO Bool))
21:54:51 <lambdabot>    arising from use of `Test.QuickCheck.quickCheck' at <interactive>:1:0-25
21:54:56 <SamB> still no cookie
21:55:02 <SamB> @type Test.QuickCheck.quickCheck (True)
21:55:04 <lambdabot> IO ()
21:55:06 <Korollary> I dont think it's possible
21:55:21 <SamB> Korollary: probably not without unsafePerformIO...
21:55:38 <SamB> more to the point what good would it be?
21:56:00 <Korollary> It could work for IOArrays and such I guess
21:56:08 <SamB> well, yeah
21:56:14 <Korollary> but not for file io
21:56:44 <SamB> IO Arrays are nice, even if you really ought to be using ST, because ST is nasty...
21:56:45 <Korollary> "Is this action the same as this one that writes this character to stdout?"
21:56:51 <SamB> hehe
21:57:02 <SamB> yeah, kinda hard to judge
21:57:13 <SamB> its even harder if they first do input!
21:59:15 <SamB> @type Test.QuickCheck.quickCheck (\xs -> length (xs :: [Int]) == foldl' (+) 0 (map (const 1) xs))
21:59:18 <lambdabot> IO ()
22:00:09 <SamB> woohoo, it passed 100 tests!
22:03:13 <SamB> @instances-importing Test.QuickCheck Arbitrary
22:03:15 <lambdabot> (), (a, b), Bool, Double, Float, Int, Integer, [a]
22:03:31 <SamB> @instances-importing Test.QuickCheck Data.Tuple Arbitrary
22:03:32 <lambdabot> (), (a, b), Bool, Double, Float, Int, Integer, [a]
22:03:35 <SamB> hmm
22:03:53 <SamB> why doesn't it mention triples, quadruples, or functions?
22:04:01 <SamB> @hoogle Poly
22:04:02 <lambdabot> Test.QuickCheck.Poly :: module
22:04:02 <lambdabot> Distribution.Extension.PolymorphicComponents :: Extension
22:04:07 <jcreigh> Yea! My Sudoku solver works!
22:04:17 <Korollary> @karma+ jcreigh
22:04:18 <lambdabot> jcreigh's karma raised to 1.
22:04:23 <jcreigh> ...and *dang*, GHC is fast.
22:04:29 <SamB> @blame instances
22:04:30 <lambdabot> Unknown command, try @list
22:07:37 <sieni> @seen vincenz
22:07:38 <lambdabot> I saw vincenz leaving #oasis and #haskell 7 hours, 36 minutes and 31 seconds ago, and .
22:10:00 <dons> ?remember jcreigh ...and *dang*, GHC is fast
22:10:00 <lambdabot> Done.
22:17:10 <edwardk> @seen shapr
22:17:11 <lambdabot> I saw shapr leaving #haskell and #ScannedInAvian 1 day, 13 hours, 14 minutes and 31 seconds ago, and .
22:19:05 <dons> ?users
22:19:35 <lambdabot> Maximum users seen in #haskell: 235, currently: 194 (82.6%)
22:19:44 <Korollary> What is with the percentage lol
22:20:10 <SamB> that means we are at that percentage of the maximum?
22:20:10 <Pseudonym> Clearly the channel is 17.4% bigger than it needs to be.  Downsize!
22:20:16 <sieni> > ((/) 235.0 194.0)
22:20:18 <lambdabot>  1.211340206185567
22:20:22 <sieni> oops
22:20:24 <Korollary> lol
22:20:27 <Korollary> too much scheming
22:20:27 <edwardk> heh
22:20:32 <sieni> > ((/) 194.0 235.0)
22:20:33 <lambdabot>  0.825531914893617
22:21:10 <SamB> sieni: why are you writing it like Scheme or Lisp?
22:21:29 <SamB> > 194 / 235
22:21:30 <lambdabot>  0.825531914893617
22:21:33 <sieni> SamB: for humorous effect
22:21:37 <SamB> works just as well...
22:21:57 <SamB> oh, you were actually writing like a cross between Python and Lisp...
22:22:24 <SamB> maybe
22:22:32 <Korollary> I am not sure python supports that
22:22:54 <Korollary> nope, it doesnt
22:22:55 <SamB> some Python versions would give you 0 for "194 / 235"
22:23:00 <sieni> and calling / without arguments probably causes whining in scheme
22:23:13 <sieni> (+) at least returns 0
22:23:23 <SamB> Python 2.3.5 (#2, Jun 13 2006, 23:12:55)
22:23:24 <SamB> [GCC 4.1.2 20060613 (prerelease) (Debian 4.1.1-4)] on linux2
22:23:24 <SamB> Type "help", "copyright", "credits" or "license" for more information.
22:23:24 <SamB> >>> 194 / 235
22:23:24 <SamB> 0
22:23:40 <Korollary> I meant the leading /.
22:24:00 <SamB> Korollary: yeah
22:24:10 <SamB> thats why I said "a cross between Python and Lisp"
22:24:40 <Korollary> the 194.0 and 235.0 are valid in lisp tho
22:25:05 <SamB> well yeah
22:25:20 <SamB> but it reminds me of Python
22:25:45 <SamB> of course, you can always break out the time machine:
22:25:47 <SamB> >>> from __future__ import division
22:25:48 <SamB> >>> 194 / 235
22:25:48 <SamB> 0.82553191489361699
22:25:58 <Korollary> tee hee
22:26:46 <jcreigh> SamB: Now, the sad thing is, I thought that was joke code until I fired up Python to try it out...
22:26:58 <edwardk> jcreigh: heh
22:27:00 <SamB> haha
22:27:16 <SamB> the "time machine" part is an old joke, yes ;-)
22:27:29 <SamB> but it is just a bad explanation for how __future__ works
22:27:49 <jcreigh> Hmm...perhaps I spoke too soon...my sudoku solver is choking (or else taking a really long time...stupid halting problem) on a more complex puzzle...
22:27:50 <SamB> @google timbot __future__
22:27:53 <edwardk> python likes to stick things it hasn't standardized yet in __future__
22:27:55 <lambdabot> http://mail.python.org/pipermail/python-list/2001-March/034144.html
22:27:55 <lambdabot> Title: Why &quot;from __future__&quot; stinks; a counter-offer
22:35:12 <SamB> @google tim peters __future__
22:35:15 <lambdabot> http://mail.python.org/pipermail/patches/2001-March/004356.html
22:35:15 <lambdabot> Title: [Patches] [ python-Patches-404997 ] Alternative to __future__ imports
22:37:22 <SamB> @google tim peters time machine
22:37:27 <lambdabot> http://www.96decibels.com/music.asp
22:37:34 <SamB> @google timbot time machine
22:37:37 <lambdabot> http://mail.python.org/pipermail/python-list/2002-July/113106.html
22:37:38 <lambdabot> Title: Q: What does &quot;Sparse is better than dense&quot; mean? (Python Zen)
22:38:21 <Korollary> lambdabot: filter html crap out
22:55:40 <foobar32> hi, quick question, why does
22:55:41 <foobar32> let fib 0 = 1
22:55:41 <foobar32> let fib 1 = 1
22:55:41 <foobar32> let fib x = 1 + fib (x - 1)
22:55:41 <foobar32> work from a file but not from the haskell command line
22:55:43 <foobar32> ??
22:56:44 <Cale> foobar32: you'd shadow the definition
22:56:49 <Cale> with each new let
22:57:04 <ibid> foobar32: let wouldn't wor in a file
22:57:08 <ibid> +k
22:57:14 <Cale> right
22:57:25 <Cale> On the command line, use  let fib 0 = 1; fib 1 = 1; fib x = 1 + fib (x - 1)
22:57:32 <ibid> foobar32: try let fib 0 = 1 ; fib 1 = 1 ; etc... on the command line
22:57:37 <foobar32> ah
22:57:48 <foobar32> also why does let x = 5; fail in Hugs ?
22:57:53 <foobar32> it only seems to work in GHCi
22:58:01 <Cale> because hugs strictly evaluates expressions
22:58:02 <ibid> because hugs is weird that way :)
22:58:15 <foobar32> any way around it?
22:58:15 <ibid> there is no standard on "command line" in haskell
22:58:16 <Cale> GHCi simulates the inside of a do-block
22:58:28 <ibid> foobar32: use ghci :)
22:58:46 <foobar32> consider it done, thanks a lot!
22:58:52 <Cale> foobar32: generally, with either of them, try not to make too many definitions at the command line
22:59:19 <Cale> foobar32: You'll end up printing something infinite, and then reload or something and you'll lose your work
22:59:58 <Cale> It's better to put the stuff in a file. Plus, when you get to things like defining datatypes or classes, you can't do that from the commandline at all.
23:00:09 <foobar32> aww
23:00:22 <Cale> I like to think of hugs/ghci as a sort of debugger.
23:00:26 <foobar32> right
23:00:28 * ibid too
23:00:47 <foobar32> if i evaluate all that stuff from an emacs buffer with haskell-mode will it work ?
23:01:00 <Cale> hmm
23:01:25 <Cale> I usually just save the file and use :r from ghci
23:01:28 <Cale> (or hugs)
23:01:37 <Cale> which reloads all the definitions
23:02:04 <foobar32> ahh
23:02:19 <foobar32> just type :r <file> at the prompt?
23:02:23 <Cale> :r
23:02:41 <ibid> the only thing i hate about :reload is that it forgets all my command-line bindings
23:02:41 <Cale> It'll reload whatever you have open
23:02:59 <Cale> which is another good reason not to make bindings at the command-line :)
23:03:00 <foobar32> got it
23:03:01 <ibid> i kind of understand why it does that, but it stils annoys me
23:03:02 <foobar32> thanks
23:03:27 <foobar32> also, is there an IRC module for haskell ?
23:03:35 <ibid> Cale: i do that for debugging. for example, reading in a file and then see if a function i've written handles it correctly
23:04:39 <ibid> so, i write something like this:
23:04:46 <ibid> s <- readFile "foo"
23:04:51 <ibid> foobar s
23:04:54 <ibid> <error>
23:04:56 <ibid> :reload
23:04:57 <ibid> s <- readFile "foo"
23:05:00 <ibid> s <- readFile "foo"
23:05:04 <ibid> foobar s
23:05:10 <ibid> (strike the double line:)
23:06:01 <Cale> foobar32: yep
23:06:08 <Cale> > foldr (+) 0 [1,2,3,4,5]
23:06:09 <lambdabot>  15
23:06:18 <Cale> lambdabot is written in Haskell
23:06:21 <lambdabot> Is there an IRC module for Haskell. Sheesh.
23:06:30 <lambdabot> Hello! Look at me!
23:06:57 * ibid politely looks away at the bot having pretensions of sentience
23:07:03 <ibid> s/at/from/
23:07:21 <lambdabot> More Sentient Than Thou, simian.
23:08:06 <foobar32> dear god that's impressive, if you aren't just messing with my head and lambdabot is really a bot, where can i see the source?
23:08:16 * ibid wonders if there is a haskell impl for symbian
23:08:28 <ibid> @version
23:08:28 <lambdabot> lambdabot 4p76, GHC 6.5 (OpenBSD i386 )
23:08:28 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
23:08:29 <ibid> i think
23:08:30 <ibid> :)
23:08:34 <ibid> foobar32: look there
23:09:02 <Cale> foobar32: Of course, some of this is puppetry :)
23:09:06 <ibid> foobar32: lambdabot is a bot, but apparently allows an operator to make it say stuff, too
23:09:29 <Cale> You really can evaluate Haskell expressions though :)
23:09:44 <ibid> (which isn't unusual in a bot, btw)
23:09:54 <Pseudonym> No, all bots speak Haskell.
23:10:01 <ibid> :)
23:10:08 <Cale> > let primes = sieve [2..] where sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in primes
23:10:09 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
23:55:53 <PaulAJ> Does lambdabot respond to questions about her and Haskell?
23:57:00 <Korollary> somewhat randomly, yes
23:57:06 <Korollary> @vixen Do you love haskell?
23:57:06 <lambdabot> church is my favourite computer scientist.
23:57:13 <dons> ?vixen-on
23:57:13 <lambdabot> What's this channel about?
23:57:28 <PaulAJ> You
23:57:29 <lambdabot> ever just get the urge to go out and kill a puppy?
23:57:48 <dons> you're a bit of a sociopath, no?
23:57:49 <lambdabot> nevermind about that
23:58:15 <dons> ?vixen-off
23:58:16 <lambdabot> Bye!
23:59:11 * PaulAJ laughs
23:59:22 <Korollary> @vixen Fill out these forms and make the check payable to World Domination, Inc.
23:59:23 <lambdabot> ever just get the urge to go out and kill a puppy?
23:59:29 <dons> oh dear
23:59:40 <dons> ?vixen what's with all the violence?
23:59:41 <lambdabot> i dunno...
23:59:55 <Korollary> Well, everybody hates redtape.
