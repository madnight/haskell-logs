00:00:03 <LordBrain> Cale: well.... it goes back before college with math... tutor for a while and you get to hear everybody's bad experience from as far back as grade school.
00:00:18 <Cale> LordBrain: yeah, it's really a quality thing
00:00:36 <Cale> If highschools taught mathematics correctly, most people would enjoy it.
00:00:39 <marcelino> cale have you done any automata and computability?--i.e. theory of computation?
00:01:00 <Cale> marcelino: a little. I know a bit about the theory of formal languages.
00:01:01 <Adamant> that's the other thing... I think Haskell and Lisp are oriented more toward math-literate programmers
00:01:20 <marcelino> Cale its funny those phd's guys are frightened by computers..lol...
00:01:25 <Adamant> and there are a lot who are not that literate
00:01:28 <marcelino> the automata guys
00:01:33 <Cale> Adamant: mm, probably, though it's possible to go the other way
00:01:45 <Cale> Adamant: Let me link you to a book :)
00:01:59 <Adamant> well, I got hooked on programming, then starting improving my math skills
00:02:09 <Cale> http://homepages.cwi.nl/~jve/HR/HR.pdf
00:02:23 <LordBrain> Cale: i agree that there is a lot of room for improvement in that regard.. but i dont think you can totally blame the teachers either. I think there is a systemic problem.
00:02:24 <Cale> The Haskell Road to Logic, Maths and Programming
00:02:35 <Cale> LordBrain: definitely
00:03:01 <marcelino> most people don't realize that at it's essence programming is essentially mathematics...
00:03:01 <Cale> LordBrain: the problem with highschool mathematics is that it's so far from what mathematicians do that it pains me to call it mathematics at all.
00:03:11 <LordBrain> yes
00:03:28 <LordBrain> same here
00:03:29 <Cale> If you're not proving theorems, you're not doing mathematics.
00:03:30 <Adamant> I think programming helped me out a lot in math, both by providing motivation and actually improving my ability to think mathematically
00:04:14 <Philippa_> Cale: a friend of mine didn't even do GCSE Maths here, I showed her how to write the length function on lists as a fold (and folds in general) and she got it
00:04:22 <Philippa_> I suspect she has dyscalcula though, she's awful with numbers
00:04:59 <Cale> Adamant: that book is pretty cool, though it's a little awkward, in that it doesn't teach you really enough Haskell to be a good Haskell tutorial, and it teaches math which any second year math student already knows.
00:05:07 <int-e> well, numbers *are* awful ;)
00:05:11 <Cale> But it's good for some people
00:05:20 <Adamant> I'll keep it
00:05:31 <Adamant> I gotta get back to studying Calc
00:05:32 <marcelino> i tried out some hr code once and things like Int didn't work properly
00:05:39 <Adamant> thanks for the coversation, all!
00:05:41 <Cale> Adamant: what book are you using?
00:05:45 <Cale> Adamant: for calculus
00:05:54 <Adamant> Stewart
00:05:57 <Cale> Adamant: I have a very strong recommendation in that department
00:06:03 <Cale> Spivak's "Calculus"
00:06:09 <Cale> Michael Spivak
00:06:30 <Cale> It's not the same as "Calculus on Manifolds", though you could probably figure that out.
00:06:31 <marcelino> i used stewart also didn't care for it i have heard of spivak never had a chance to read him yet
00:06:35 <cathper> Cale: do you get paid to spread the word about Spivak? ;-P
00:06:49 <Cale> cathper: No, but I should really ask for some kickbacks :)
00:06:58 <marcelino> artin's real analysis is the book
00:07:14 <Adamant> Cale, any old editions I can pick up cheap used?
00:07:18 <LordBrain> anaylsis was my favorite class in college
00:07:26 <LordBrain> i actually won an award for it
00:07:38 <Cale> Adamant: I'm not sure -- the 3rd edition's been around a while
00:07:41 <Adamant> does it cover semester-system U.S. Calc I-III?
00:07:50 <Adamant> or beyond?
00:07:55 <LordBrain> anyway.. i have to go ... its 3am
00:08:05 <Cale> beyond highschool stuff, if that's what you're asking
00:08:07 <marcelino> analysis is very dry i think knuth's concrete mathematics is more appropriate of pure cs
00:08:11 <Cale> I don't live in the US
00:08:24 <Cale> It starts with basic properties of numbers
00:08:36 <marcelino> peanno
00:08:37 <Adamant> Cale, fair enough, didn't know if you knew anyone who did who might have told you
00:08:51 <Cale> covers everything interesting they do in non-calculus math in highschool in the first 100 pages, and is much more lucid than highschool
00:08:59 <Adamant> since you seem to recommend it a lot. :)
00:09:03 <Cale> and then goes on to bigger things :)
00:09:16 <marcelino> induction is probably the most used cs math theorem
00:09:25 <Adamant> does it go beyond sequence/series and multivariate calc?
00:09:54 <Cale> Adamant: It actually doesn't really touch multivariate stuff, but he does do some basic complex analysis
00:10:00 <Adamant> ah, cool
00:10:10 <Adamant> well, I'll see if I can pick up a cheap used copy
00:10:16 <Adamant> thanks!
00:10:19 <Cale> Or at least get it at your library
00:10:35 <marcelino> goodnight to all
00:10:37 <Cale> and let me know what you think :)
00:10:42 <Cale> marcelino: 'night
00:14:24 <pstickne> how are ocaml and haskell related?
00:15:28 <vincenz> pstickne: they're both strongly typed hindley milern type inference based functional programming languages, with similarities between type classes and functor modules
00:16:10 <pstickne> what are their advantages/disadvantages?
00:17:39 <pstickne> (in a nutshell :)
00:17:40 <vincenz> in comparison to each other?
00:18:30 <vincenz> ocaml is strict, haskell is lazy, haskell has typeclasses, ocaml compiles to fast code
00:18:34 <vincenz> there ya go
00:18:36 <vincenz> the main tradeoffs
00:18:54 <Korollary> There's no clear-cut answer.
00:19:07 <vincenz> Korollary: those are the main tradeoffs
00:19:17 <vincenz> the unclear-cut answre is deciding which is best
00:19:21 <vincenz> that's personal
00:19:24 <vincenz> oh yeah
00:19:31 <vincenz> ocaml has some minor irky details
00:19:45 <vincenz> like the lack of first class data constructors
00:19:49 <Korollary> No, they are the differences. I don't know what to call an advantage.
00:19:59 <vincenz> Right
00:20:07 <vincenz> But he asked for advantages/disadvantages
00:20:13 <vincenz> I listed them, all he has to do is label them
00:20:23 * vincenz winks
00:20:39 <pstickne> I'm interested in this strict/lazy thing. I don't understand it well. I've used Ruby/Perl/C/Java, these are all examples of strict evaluation?
00:20:44 <Korollary> yes
00:21:00 <vincenz> higher order typing is also missing from ocaml, well not missing but less commonly used, and the lack of monads
00:21:36 <Korollary> @google wikipedia lazy evaluation
00:21:39 <lambdabot> http://en.wikipedia.org/wiki/Lazy_evaluation
00:21:46 <Korollary> That explains it pretty well.
00:21:58 <vincenz> > let ones = 1 : ones
00:21:59 <lambdabot>  Parse error
00:22:02 <vincenz> > let ones = 1 : ones in ones
00:22:03 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
00:22:22 <vincenz> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs
00:22:23 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
00:22:37 <dons> and no GADTs, right, vincenz ?
00:22:50 <vincenz> dons: correct
00:22:53 <vincenz> @karma+ bringert
00:22:53 <lambdabot> bringert's karma raised to 8.
00:22:55 <vincenz> GADTS
00:23:19 <Korollary> they haven't touched ocaml's type system in a while, have they?
00:23:23 <Korollary> I mean extensions
00:23:27 <vincenz> well tehy have
00:23:33 <pstickne> GADTs?
00:23:39 <vincenz> extensible records, row-typing
00:23:45 <Korollary> when was that?
00:23:50 <vincenz> dunno
00:23:54 <dons> ?google GADTs Haskell
00:23:57 <vincenz> row-typing is pretty recent I think
00:23:57 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/GADTs
00:23:58 <lambdabot> Title: GADTs - Haskell Prime - Trac
00:23:59 <vincenz> last year?
00:24:01 <vincenz> this year?
00:24:16 <dons> ?url-on
00:24:17 <lambdabot> Url enabled
00:28:31 <dons> ?uptime
00:28:39 <vincenz> @bot
00:29:30 <dons> bit weird. there's a big rain storm here, maybe the network was playing up a bit over the microwave link
00:29:44 <dons> nothing obviously was happening to the bot
00:29:54 <dons> ?version
00:30:07 <int-e> @@botsnack
00:30:17 * dons waits for freenode to settle
00:30:20 <edwardk> ghc doesn't seem to happy when i autogenerate it a few thousand instances =)
00:30:20 <lambdabot> lambdabot 4p43, GHC 6.5 (OpenBSD i386 )
00:30:22 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
00:30:27 <dons> edwardk: heh!
00:30:44 <edwardk> it held up through the full adder, but adding the normalization stuff blew me up
00:31:04 <edwardk> (using template haskell to build a hex based type level number library)
00:31:11 <dons> oh, naturally.
00:31:14 <dons> as we all do.
00:31:20 <dons> ;)
00:31:28 <dons> very cool. are you going to file a bug report?
00:31:29 <edwardk> its actually working fine except for one case
00:31:38 <edwardk>  
00:31:38 <edwardk> Loading package haskell98-1.0 ... linking ... done.
00:31:38 <edwardk> Loading package template-haskell-1.0 ... linking ... done.
00:31:38 <edwardk> Killed
00:31:38 <edwardk> [slipwave@www Hex]$
00:31:41 <edwardk> it just dies =)
00:31:43 <dons> ah
00:31:46 <dons> ulimit?
00:31:46 <int-e> @bot
00:31:47 <lambdabot> :)
00:31:57 <edwardk> none on the machine i know of. lemme try as root
00:32:28 <dons> or does the code just crash when being evaluated during the TH phase?
00:32:46 <edwardk> thats also possible.
00:32:59 <edwardk> but i have to admit TH has held up remarkably well prior to now
00:33:13 <pstickne> TH?
00:33:25 <stepcut> pstickne: template haskell
00:33:36 <edwardk> http://slipwave.info/jugs/src/Type/Hex/  is where the code is now
00:33:53 <edwardk> the TNF' stuff in Stage2 is blowing  up
00:34:33 <edwardk> it'll probably weigh in round the same amount of code as the binary version, maybe twice as much
00:34:48 <edwardk> but it'll cap out around 2^80 instead of 2^20
00:34:58 <edwardk> so it could be used for all array indexes, etc without changing context limits
00:35:06 <edwardk> hence my desire to play with it =)
00:36:00 <dons> yeah, sounds good
00:36:01 <edwardk> it could just be that the code i have for adding the 254 tnf rules is screwy
00:36:16 <dons> still, it shouldn't just die
00:36:17 <edwardk> but it looks pretty straightforward
00:36:18 <dons> ever
00:36:19 <edwardk> yeah
00:37:00 <edwardk> basically i have 254 rules that all basically relate to some digit pair except for FF and 00
00:37:21 <edwardk> mind taking a peek at Stage2 and seeing if you can see any obvious loops in the last $(  ) block?
00:37:44 <edwardk> hahahaha
00:37:45 <edwardk> nevermind
00:37:47 <edwardk> i';m an idiot
00:37:54 <edwardk> i lifted instead of zipped
00:38:09 * Korollary takes that out of context
00:38:29 <edwardk> hehehe
00:38:32 <pstickne> Why is there stage1, stage2, stage3?
00:38:58 <edwardk> template haskell can't interact with stuff from the same module thats got a root level definition
00:39:23 <edwardk> so i need to build my hex digits in one stage, use them in type definitions in another and then build any automatic instances of THOSE classes in another.
00:39:52 <pstickne> ehh :-/
00:40:00 <edwardk> the reason i actually differentiate 1 and 2, and autogenerate the digits is because then later i can generalize the schema to n-bit digits, and see if i can figure out the optimal number
00:40:10 <edwardk> to trade off scope depth and combinatorial complexity
00:40:23 <edwardk> in other words
00:41:05 <edwardk> i can't say "class Foo" and then conT $ mkName "Foo" and use the constructor i named in the same source file
00:41:14 <edwardk> in a root level definition anyways
00:42:27 <edwardk> cool. works now
00:42:30 <edwardk> *Type.Hex.Stage3> tAdd' $(hexE 1298301) $(hexE 12309)
00:42:30 <edwardk> $(hexE 1310610)
00:42:58 <edwardk> the only real tricky case will be figuring out the multiplier
00:43:18 <edwardk> everything else is just a straight transcription, modulo some additional cases.
00:43:22 <dons> yeah, but why did it crash?
00:43:28 <dons> a bug in ghc?
00:43:31 <edwardk> because i am not lifting any more =)
00:43:33 <edwardk> i had a bug
00:43:40 <dons> that caused ghc to crash?
00:43:48 <dons> oh, it threw error, or some such?
00:43:49 <pstickne> > makeList = 1 : makeList
00:43:49 <lambdabot>  Parse error
00:43:51 <edwardk> i used liftM (,) x [0..15] instead of zip x [0..15]
00:43:52 <pstickne> :(
00:44:04 <edwardk> so i was generating about 8192 instances
00:44:10 <dons> > let x = 1 : x in x
00:44:12 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
00:44:28 <edwardk> yeah but this is in the compiler =)
00:45:14 <edwardk> woops, my bad, more than thatt, because then i lifted again. there were 65534 instances made by that statement
00:45:38 <edwardk> or thereabouts
00:45:47 <edwardk> coz the lift screws up the logic on the filter
00:46:27 <edwardk> 65024 to be exact
00:46:42 <edwardk> i don't have a problem with ghc blowing up on a source file with THAT many instances in it
00:47:10 <edwardk> if nothing else, this has been a heck of a way to learn template haskell =)
00:53:44 <dons> but how was your TH code failing?
00:54:04 <dons> does TH code that fails to run, cause ghc to fail without an error msg?
00:54:44 <pstickne> are fst/snd special in their handling of parenthesis? how does it know I want a pair instead of just using parens for precedence reasons?
00:55:33 <dons> handling of parenthesis?
00:55:45 <dons> ?type fst
00:55:46 <lambdabot> forall a b. (a, b) -> a
00:55:47 <pstickne> sqrt(1 * 4)
00:55:50 <edwardk> well, i think ghc was trying really hard and eventually terminated itself on some sort of panic condition
00:56:10 <dons> pstickne: it knows that you're using the ',' constructor
00:56:16 <dons> > (,) 1 2
00:56:17 <lambdabot>  (1,2)
00:56:23 <dons> > (1,2)
00:56:24 <lambdabot>  (1,2)
00:56:29 <dons> > fst ((,) 1 2)
00:56:31 <lambdabot>  1
00:56:33 <dons> > snd (1,2)
00:56:35 <lambdabot>  2
00:56:48 <dons> anyway, the type of 'fst' and 'snd' specify their arguments
00:56:49 <dons> ?type fst
00:56:50 <lambdabot> forall a b. (a, b) -> a
00:56:52 <pstickne> > fst [1], 1
00:56:52 <lambdabot>  Parse error
00:56:58 <dons> so it has to take a pair of values, of the form (a,b)
00:57:06 <dons> > fst ([1], 1)
00:57:07 <lambdabot>  [1]
00:57:20 <dons> tuples are always wrapped in ( )
00:57:58 <dons> its a bit like the special syntax for lists
00:58:01 <dons> > [1,2,3]
00:58:03 <lambdabot>  [1,2,3]
00:58:12 <dons> > 1 : 2 : 3 : []
00:58:13 <lambdabot>  [1,2,3]
00:58:25 <dons> > (1,(2,(3,())))
00:58:26 <lambdabot>  (1,(2,(3,())))
00:58:52 <ValarQ> @type (1,(2,(3,())))
00:58:53 <lambdabot> forall a a1 a2. (Num a, Num a1, Num a2) => (a, (a1, (a2, ())))
00:58:56 <dons> > (,) 1 ((,) 2 ((,) 3 ()))
00:58:57 <lambdabot>  (1,(2,(3,())))
01:01:28 <int-e> > let (><) = (,) in 1 >< 2 >< 3 >< ()
01:01:29 <lambdabot>  (((1,2),3),())
01:01:42 <int-e> fixity.
01:05:21 <pstickne> haskell is strange :x
01:05:43 <dons> heh
01:05:51 <dons> questions?
01:06:04 <boegel> pstickne: YOU are strange :p
01:06:10 <pstickne> not yet. YAHT is fairly good.
01:06:25 <dons> oh, good :)
01:07:04 * ValarQ hasn't been accusted of being strange yet
01:07:05 <ValarQ> woohoo
01:07:05 <dons> i think the essence of your above problem was that in haskell, parenthesis are used for two things. grouping (like you expected), and for delimiting tuple values
01:07:09 <dons> > ()
01:07:10 <lambdabot>  ()
01:07:15 <dons> the zero tuple
01:07:19 <dons> > (1,2)
01:07:20 <lambdabot>  (1,2)
01:07:25 <dons> > (1,2,3,4)
01:07:26 <lambdabot>  (1,2,3,4)
01:08:30 <stepcut> > (1,2,3,4,5,6,7,8,9,10)
01:08:31 <lambdabot>  (1,2,3,4,5,6,7,8,9,10)
01:09:20 <stepcut> interesting ... ghc does not have Show instances for tuples that big
01:09:26 <stepcut> how does lambdabot do it ?
01:09:36 <dons> no show instance??
01:10:03 <stepcut> yeah, the only go up to 5
01:10:05 <dons> hmm!
01:10:06 <ValarQ> my ghci handles up to 5
01:10:38 <stepcut> lambdabot has magically powers
01:10:41 <ValarQ> i have actually never had reason to use bigger than 3space tuples...
01:10:47 <norpan> there rarely are
01:10:52 <dons> 6.5 seems to handle above 5
01:10:54 <norpan> you just define your own datatype then
01:11:16 <dons> ah, only up to 15.
01:11:18 <dons> > (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
01:11:19 <norpan> it's not so much the compiler as the libs
01:11:19 <stepcut> I tended to use big tuples alot when doing WASH+HaskellDB
01:11:19 <lambdabot>  (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
01:11:22 <dons> > (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16)
01:11:22 <lambdabot>     add an instance declaration for (Show (a,
01:11:23 <lambdabot>               ...
01:11:28 <pstickne> > read(show 1.1)
01:11:29 <lambdabot>  Add a type signature
01:11:54 <pstickne> anyway, I get Prelude.read: no parse, ???
01:11:55 <dons> > read . show $ 1.1 :: Float
01:11:56 <lambdabot>  1.1
01:11:57 <ValarQ> ghc-6.5 handles 15
01:12:08 <dons> ValarQ: see above :)
01:12:10 <ValarQ> oh
01:12:15 <stepcut> dons: maybe for the next SoC we can get a student to add Show instances all the way up to 32-tuples ;)
01:12:17 * ValarQ is late as usual
01:12:25 <dons> stepcut: why stop there! 64, I say.
01:12:34 <ValarQ> heh
01:12:35 <dons> 1 a day for each day of summer
01:12:59 <stepcut> dons: well, they need to have time for fun too -- can't be working everyday
01:13:11 <Cale> hahaha
01:13:14 <ValarQ> :)
01:13:26 <dons> oh, true. all work and no play, and the productivity would crash. we might only get to 19 or 20
01:13:53 <stepcut> then again, I think the compelling reason for implementing TH was to automatically generate show instances for tuples
01:13:57 <pstickne> so ... read just defaults to Integer?
01:14:03 <norpan> can't do more than 26, then we are out of single char identifiers
01:14:11 <dons> pstickne: nope:
01:14:13 <dons> ?type read
01:14:14 <lambdabot> forall a. (Read a) => String -> a
01:14:16 * ValarQ fails to see the use for size15 tuples
01:14:27 <dons> > read "'x'" :: Char
01:14:28 <lambdabot>  'x'
01:14:37 <ValarQ> points in a 15dimensional space?
01:14:37 <dons> > read "()" :: ()
01:14:38 <lambdabot>  ()
01:14:46 <pstickne> > read "1" :: Integer
01:14:47 <lambdabot>  1
01:14:49 <pstickne> > read "1"
01:14:50 <lambdabot>  Add a type signature
01:14:53 <pstickne> hmm
01:14:53 <stepcut> ValarQ: A database row with 15 fields ?
01:14:57 <pstickne> it works differently in ghci
01:14:59 <dons> an encoding of 15 element lists, as 15-tuples?
01:15:14 <dons> pstickne: ah yes. ghci does do some defaulting
01:15:14 <ValarQ> stepcut: i wouldn't use tuples for that
01:15:43 <ValarQ> stepcut: no that it can't be done but there got to be a better way
01:15:54 <stepcut> ValarQ: HList
01:16:00 <ValarQ> s/no/not/
01:16:43 <norpan> if you have 15 fields in your database then you havent decomposed it enough :)
01:17:38 <norpan> or if you will, normalized it
01:18:07 <ValarQ> the same can be said for 5sized tuples...
01:18:13 <pstickne> noradio, "Name1", "Name2", "Name3" ... what do you mean? :)
01:18:28 <ValarQ> pstickne: columns as rows? :)
01:18:54 <pstickne> I'd like to see a good dailywtf on databases :)
01:26:11 <liyang> pstickne: make one.
01:26:30 <pstickne> noj, no, I couldn't copy and paste that much :(
01:28:14 * Igloo waves from AngloHaskell
01:28:19 <Stinger_> there are a fair few databased dailywtfs, or do you want a really tricky one
01:28:27 <Stinger_> database*
01:28:30 <int-e> pstickne: (ignore that it's Access) how about http://thedailywtf.com/forums/thread/80281.aspx ?
01:29:36 <pstickne> holy fsck :x
01:29:56 <dons> hey Igloo!
01:30:14 <dons> Igloo: how's AngloHaskell going? many people made it?
01:30:58 <Igloo> 6 so far, but more are expected  :-)
01:31:16 <Igloo> dcoutts is just giving the introduction to fusion, fps etc
01:31:17 <dons> Philippa arrived yet? She left just a little while ago, she said
01:31:23 <Igloo> Nope
01:31:46 <dons> Igloo: oh good. you can tell him fps is even faster now, than when he left this morning
01:32:02 <Igloo> And she seems to still be on IRC
01:32:18 <dons> and liyang was going too, I think
01:32:58 <Philippa_> liyang's my lift. He was complaining about being behind schedule 10 minutes ago...
01:33:06 <dons> here's the most recent fps speed check, current 0.7 versus what we've been working on the last couple of days, with `stream' fusion: http://cgi.cse.unsw.edu.au/~dons/blog/2006/08/04#stream_fusion
01:33:07 <lambdabot> Title: Haskell, hacking and other stuff
01:36:03 <dons> vincenz: I've now spoken more lines than you in #haskell ;)
01:36:29 <Philippa_> ah, the joys of statistical dicksizing
01:36:43 <dons> heh
01:36:57 <dons> its important to measure things
01:38:26 <Igloo> dons: Are the axes of that graph testcase vs time(seconds)?
01:38:33 <dons> yep
01:39:03 <dons> each test case is a pair of fuseable functions composed. i.e. map.map, foldl.map, foldl.scanl ...
01:39:36 <dons> these are much improved under the streams system. ghc just compiles streams better than the former loop combinator
01:39:57 <dons> (also, we can fuse more things, like find/findIndex and unfolds)
01:42:48 <dons> @seen ibid
01:42:49 <lambdabot> ibid is in #haskell. I don't know when ibid last spoke.
01:43:32 <ibid> just now :)
01:44:14 <ibid> dons: what? :)
01:48:26 <musasabi> dons: please darcs tag the fps repo sometime.
01:48:39 <dons> musasabi: yes. i will do so in the next few days
01:48:47 <dons> i've decided the streams stuff is for 0.8
01:49:01 <dons> (which is what I was holding out for)
01:49:36 <musasabi> if there are lots of patches then date-based tags might also make sense so that "get --partial" doesn't want to pull 394 patches very slowly.
01:49:42 * ibid has a cronjob that tags my more important repositories regularly
01:50:18 <ibid> plural, actually
01:50:20 <dons> hmm. interesting. yes. its a good idea
01:50:20 <ibid> eg.:
01:50:22 <ibid> 50 23 5,13,21,29 * * (cd www/darcs/fencore && darcs tag -m"kaijanaho.info $(date +\%Y-\%m-\%d)" -A'Automatic Date Tagger <antti-juhani@kaijanaho.info>')
01:50:25 <ibid> 55 23 5 * * (cd www/darcs/fencore && darcs optimize --checkpoint)
01:51:11 <ibid> should abstract that a bit so it wouldn't be as copypaste as it is now
01:51:55 <dons> ok, why not, i'll tag it now
01:52:07 <dons> and darcs distify..
01:54:27 <benja_> ibid: ah, you just answered a question I had yesterday :)
01:54:46 <benja_> namely, why fencore hasn't been tagged since the time I asked you "what is this" :)
01:54:47 <ibid> benja_: oh?
01:54:52 <ibid> heh
01:54:53 <benja_> (I got the idea it was nightly)
01:55:19 <ibid> nightly tags would overwhelm any payload patches quickly
01:55:33 <benja_> ok
01:55:50 <ibid> the different repos are tagged on different days but all follow the same basic schedule
02:08:58 <dons> tagged, musasabi
02:11:04 <musasabi> btw why are unsafeHead/Index/Tail removed from Data.ByteString.Char8 ?
02:11:44 <dons> all unsafe*s are in .Base now
02:12:34 <dons> in the style of Data.Array.Base
02:13:05 <musasabi> yes, only for Word8
02:13:19 <dons> ah.
02:13:55 <dons> hmm
02:14:07 <musasabi> I can inline definitions of them.
02:14:20 <musasabi> (to the source file in question)
02:14:34 <gour> JohnMeacham: have you seen my paste showing jhc build error?
02:15:25 <dons> musasabi: ok. that'll do for now
02:17:37 <musasabi> Or I could define the safe non-empty ByteString type - the only problem with such a module is that it would need to be parametrized by one of the fps implementations (and there are no parametrizable modules in Haskell).
02:24:46 <gour> dcoutts: ping
02:26:03 <Igloo> gour: What do you want him for?
02:26:13 <Igloo> (he's giving an AngloHaskell talk ATM)
02:26:50 <JohnMeacham> gour: yes, you need to upgrade your DrIFT.
02:26:57 <gour> Igloo: ok. i wanted to ask him something regarding mono & haskell. later...is it fun om AngloHaskell?
02:27:31 <Igloo> Yup - good to put faces to names  :-)
02:28:40 <gour> Igloo: :-)
02:29:08 <gour> JohnMeacham: i have drift-2.1.2
02:32:22 <gour> JohnMeacham: ok, i see there is 2.2.0 ebuild...let me try
02:39:55 <musasabi> vegai: if you want I have a patch for HAppS with the latest FPS.
02:40:33 <dons> musasabi: there's now a 0.7 tarball on the fps page
02:43:59 <musasabi> thanks
02:59:19 <leeghoofd> hey, could someone help me with a piece of code? May I paste 5 lines here or should I use a paste site?
03:01:02 <dons> ?paste
03:01:03 <lambdabot> http://paste.lisp.org/new/haskell
03:01:10 <dons> will be easier if we add annotations
03:02:07 <lisppaste2> leeghoofd pasted "stukje" at http://paste.lisp.org/display/23635
03:02:29 <leeghoofd> wow, that's cool
03:02:47 <leeghoofd> do you know how to write line 4?
03:03:12 <leeghoofd> I don't understand when to use Int or Float
03:04:42 <leeghoofd> If I do something like that in ghci, like  6 / sqrt 2 it works but when I make a function to do something like that it errors
03:05:14 <dons> ghci does defaulting, which  can sometimes confuse things.
03:05:15 <gds> I think you might want b :: Num a => [a] -> Fractional
03:05:29 <gds> Or am I barking up the wrong tree? ;)
03:05:37 <dons> ?type let b list = (range list) / (sqrt (length list)) in b
03:05:38 <lambdabot>   Couldn't match `[a]' against `Int'
03:05:39 <lambdabot>    Expected type: [a]
03:06:08 <dons> the problem is that you're producing a floating point result
03:06:15 <dons> do you want an Int, or a Double?
03:06:24 <leeghoofd> double
03:06:43 <leeghoofd> I want something like 3.21312 :)
03:07:12 <dons> ok. what's the type of 'length' ?
03:07:19 <dons> ?type length
03:07:21 <lambdabot> forall a. [a] -> Int
03:07:23 <dons> and the type of sqrt?
03:07:25 <leeghoofd> when I type Fractional it also gives an error
03:07:25 <dons> ?type sqrt
03:07:27 <lambdabot> forall a. (Floating a) => a -> a
03:07:28 <dons> so,
03:07:32 <dons> ?type sqrt .length
03:07:34 <lambdabot>   No instance for (Floating Int)
03:07:34 <lambdabot>    arising from use of `sqrt' at <interactive>:1:0-3
03:07:35 <dons> won't work
03:07:36 <leeghoofd> of length Int I think and of sqrt Float?
03:07:48 <dons> ?type sqrt . fromIntegral . length
03:07:50 <lambdabot> forall b a. (Floating b) => [a] -> b
03:07:54 <dons> and then
03:08:13 <dons> ?type let b list = (range list) / (sqrt . fromIntegral . length $ list) in b
03:08:15 <lambdabot>   Couldn't match `[a]' against `(a1, a1)'
03:08:15 <lambdabot>    Expected type: [a]
03:08:27 <dons> ah, bogus 'rnage'
03:08:41 <dons> anyway, try that : b list = (range list) / (sqrt . fromIntegral . length $ list)
03:08:53 <norpan> @type genericLength
03:08:54 <lambdabot> forall i b. (Num i) => [b] -> i
03:08:55 <dons> and b :: (Floating b) => [b] -> b
03:09:08 <dons> ah yes, genericLength. I always forget
03:09:53 <leeghoofd> it works, thanks!
03:10:11 <leeghoofd> now I'm going to search for what fromIntegral and the $ mean :)
03:10:17 <dons> ?type fromIntegral
03:10:18 <lambdabot> forall b a. (Num b, Integral a) => a -> b
03:10:29 <dons> ?type ($)
03:10:31 <lambdabot> forall b a. (a -> b) -> a -> b
03:10:39 <norpan> the types of those prelude functions are archaic
03:10:55 <dons> $ is just a short hand for application, but with better precedence, so you need less parens
03:11:07 <dons> > reverse $ "foo" ++ "bar"
03:11:08 <lambdabot>  "raboof"
03:11:09 <norpan> length should be genericLength with specialization
03:11:13 <dons> > reverse ("foo" ++ "bar")
03:11:14 <lambdabot>  "raboof"
03:11:51 <norpan> i suppose it can happen for haskell√§
03:11:52 <norpan> haskell'
03:13:14 <pstickne> okay, I'm following through with this YAHT but I'm sucking. I am on one of the exercises to make a multiplication function with only using addition (this is the recursion section) but I can't get my function right. I have:
03:13:19 <pstickne> mymul a 1 = a
03:13:29 <pstickne> mymul a b = a + mymul(a (b - 1))
03:13:37 <dons> oh, than syntax looks wrong
03:13:48 <dons> you mean: mymul a b = a + mymul a (b-1) -- ?
03:13:49 <pstickne> how so?
03:14:09 <pstickne> I want mymull called again with a and b-1, respectively :(
03:14:15 <dons> right, as above
03:14:37 <dons> > let f a 1 = a ; f a b = a + f a (b-1) in f 10 7
03:14:39 <lambdabot>  70
03:15:00 <pstickne> same error: No instance for  (Num (a1 -> a))
03:15:16 <dons> hmm? did you miss an argument?
03:15:45 <dons>  mymul a b = a + mymul a (b-1)
03:16:00 <pstickne> noj, it was something even stupider :X, now I have something else, I'll look at it for a few
03:16:02 <dons> there's no parens when applying a function to its arguments.
03:16:41 <gds> mymul a b = a + (mymul a (b-1))  -- to prevent + from grabbing mymul ?
03:17:16 <pstickne> I was using 'f' instead of mymul :(
03:17:47 <dons> heh:)
03:18:16 <gds> Oh - so the user defined function has a higher precedence than (+) ?
03:19:13 <pstickne> why can I not use mymul(...) there?
03:19:48 <gds> functions in haskell are "curried" by default...
03:19:58 <pstickne> ?
03:20:02 <gds> They don't take their args in parens, the way other languages do.
03:20:13 <gds> instead of "f(a, b, c)
03:20:14 <gds> "
03:20:19 <gds> we write "f a b c"
03:20:43 <gds> This looks really silly the first time you see it - but it means we can do one very cool thing...
03:20:49 <pstickne> so if I wanted   f(a, b, c) * 5  I'd use   (f a b c) * 5  #?
03:20:57 <flodin> gds: it looks pretty to me :)
03:21:01 <gds> pstickne: Yes :)
03:21:06 <gds> The cool thing:
03:21:11 <gds> @type (+)
03:21:13 <lambdabot> forall a. (Num a) => a -> a -> a
03:21:16 <gds> @type (+ 2)
03:21:17 <lambdabot> forall a. (Num a) => a -> a
03:21:25 <gds> Or even:
03:21:33 <gds> @type ((+) 2)
03:21:34 <lambdabot> forall a. (Num a) => a -> a
03:21:47 <gds> it's a function that adds two to things...
03:22:16 <gds> You can do that with any function in the lanuage - just give it the first of its args
03:22:18 <pstickne> I don't know how to read that :(
03:22:38 <gds> and it'll give you a function that takes the rest of the args, and give you the answer...
03:23:07 <gds> So, your mymul function could me used like "mymul 3 4" to multiply 3 and 4...
03:23:22 <gds> or you could do "timesThree = mymul 3"
03:23:37 <gds> then timesThree would be the function that multiplies things by three :)
03:23:48 <flodin> pstickne: conceptually, when you do "f a b", you invoke f with the argument a. The returned object is another function that is invoked with the argument b
03:24:20 <vegai> musasabi: sure, I'll take a patch
03:25:56 <pstickne> strange. well, back to reading :)
03:28:05 <lisppaste2> gour pasted "jhc build error" at http://paste.lisp.org/display/23636
03:29:17 <gour> JohnMeacham: now I get the above ^^^
03:35:14 <musasabi> vegai: http://www.cs.helsinki.fi/u/ekarttun/haskell/happs-fps.patch
03:38:42 <JohnMeacham> gour: try a make fetch-libs.. I think that should wark.
03:41:24 <musasabi> JohnMeacham: any chance to get StablePtr soonish?
03:41:40 <gour> JohnMeacham: hmm, it has started fetching 60M of libs:-( is there no other way?
03:42:21 <JohnMeacham> gour: you could build them yourself.. which will take probably as long. :) there is a bug now that is causing the libs to explode in size. I have not tracked it down yet. musasabi was looking into it too.
03:42:36 <gour> JohnMeacham: or, at least, ebuild should take care of it
03:43:02 <JohnMeacham> musasabi: I have not worked on it.
03:43:08 <gour> JohnMeacham: ok, let me wait a bit then...
03:43:24 <JohnMeacham> musasabi: I'll get time to work on it again on sunday I think.
03:43:41 <musasabi> nice :-)
03:44:41 <JohnMeacham> I still havn't tracked down the odd dependency problem yet. where it isn't loading in everything needed once it grabs a ho... though, the new way it builds up ho's solves a lot of issues that were piling up.
03:45:51 <musasabi> is it dropping module dependencies? (if so I can look into that - if it is something more involved on the E level, I probably won't find it)
03:46:01 * gour puts lot of faith in jhc...
03:50:23 <tibbe> @pl print . count . lines =<< getContents
03:50:23 <lambdabot> print . count . lines =<< getContents
03:50:31 <tibbe> doh
03:50:41 <tibbe> @obfuscate print . count . lines =<< getContents
03:50:42 <lambdabot> Unknown command, try @list
03:54:30 <gds> lol :)
03:55:28 * tibbe has a mental mapping that says: @pl = @obfuscate
03:57:35 <ValarQ> @pl \(x:y:z:xs) -> filter (==z) $ map (+x+y) xs
03:57:36 <lambdabot> ap ((`ap` tail) . (. head) . flip flip tail . (ap .) . flip flip head . (((.) . flip ((.) . filter . (==)) . map . (+)) .) . (+) . head) tail
03:58:39 <tibbe> ah, that's better
03:58:43 <ValarQ> :)
03:59:35 <pstickne> anyone with access to page 35 of YAHT want to clarifiy why   "rest <- askForWords; return (word : rest)" is right and  "return (word : askForWords)"  is wrong?
04:00:23 <tibbe> YAHT?
04:00:33 <ValarQ> tibbe: yet another Haskell tutor
04:00:36 <pstickne> Yet Another Haskell Tutorial
04:00:53 <ValarQ> pstickne: thats because askForWords has the "wrong" type
04:01:06 <ValarQ> pstickne: it's embedded in a monad
04:01:34 <pstickne> err.
04:02:19 <ValarQ> pstickne: that first example is from do-notation, right?
04:02:56 <pstickne> ValarQ, it's from section 3.8, Interactivity
04:03:22 * ValarQ downloads yaht
04:05:29 <ValarQ> ok, it's one of the first IO examples, right?
04:06:08 <pstickne> 2nd.
04:06:33 <pstickne> Err, 3rd, first was Your Name, second was Guess The Number
04:06:41 <ValarQ> this is one of the drawbacks with starting with the do-notation
04:07:42 <pstickne> ValarQ, it's most confusing, in the mymap I just did, I used the same principles it says not to here :(
04:08:14 <kpreid> I like "<- is the operator that unwraps monadic values"
04:08:41 <ValarQ> pstickne: the first encounter with monads usually is quite confusing (it was for me anyway)
04:08:49 <yip> hey guys, would haskell be a good choice for coding one of those web-based text mmorpgs?
04:09:08 <ValarQ> pstickne: do {x <- foo; bar x}  translates to  foo >>= \x -> bar x
04:09:24 <ValarQ> pstickne: so it's not the same thing as: bar foo
04:09:35 <pstickne> yip: A better question would be, does Haskell have an easy to use full-stack Web Framework?
04:10:09 <ValarQ> full-stack?
04:10:10 <pstickne> ValarQ, I have no idea what >>= or \x means :P
04:10:18 <pstickne> ValarQ, buzzword?
04:10:31 <yip> pstickne: yeah that sounds like buzzword overload a bit :/
04:10:32 <pstickne> "comprehensive"?
04:10:59 <ValarQ> pstickne: >>= is the monadic bind operation
04:11:25 <ValarQ> @type (>>=)
04:11:26 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
04:11:33 <psi> pstickne: if you have a type IO Char, for instance, then it's not really a Char. You can think of it like an action to _get_ a Char, and it has to executed to get it.
04:11:46 <psi> has to be*
04:11:57 <gds> @where hope
04:11:57 <lambdabot> http://hope.bringert.net/
04:12:05 <gds> yip: that might be useful...
04:12:46 * pstickne 's head is about to explode.
04:13:07 <psi> pstickne: and rest <- askForWords executes askForWords and bind the result to rest
04:13:58 <pstickne> So to get the result of anything from do {} I need to use <- #?
04:14:23 <psi> only to get the result of IO actions
04:14:23 <yip> i actually don't think that i need some sort of "web framework". building the web server using the haskell tcp sockets api should be the easy part. the hard part is all of the game logic
04:14:48 <psi> regular functions works as you would expect
04:15:30 <pstickne> so if I have      x = do { return 1 }        ?
04:15:45 <pstickne> would I need to <- it to something to use the value?
04:16:02 <psi> yes
04:16:37 <kpreid> pstickne: also, "do { return 1 }" is equivalent to "return 1"
04:16:37 <pstickne> indeed strange. hopefully this will eventually make sense.
04:17:26 <ValarQ> personaly i think it's easier to start without the do-notation
04:17:53 <pstickne> yip, I'm going to punch you. you sound like someone coming into #javascript trying to roll their own XHR implementation O.o
04:18:21 * pstickne goes to bed. thanks for the help.
04:18:54 <yip> pstickne: well i've written a webserver in python and c before
04:20:01 <gds> yip: Well, there're a few games here: http://haskell.org/haskellwiki/Haskell_in_practice - none of them MMORPGs though.
04:20:02 <lambdabot> Title: Haskell in practice - HaskellWiki
04:24:53 <yip> gds: i actually wrote the start of an opengl arcade shooter in haskell. but a mmorpg would be very different. i'm worried about haskell's ability to compile server programs that must run for a long time
04:25:30 <gds> I see :)
04:26:01 <gds> If you're worried about uptime - presumably it's memory leaks you're primerily worried about?
04:26:11 <gds> The effeciency of the ghc garbage collector?
04:26:17 <yip> yes and yes
04:26:37 * gds looks around for ghc folk...
04:26:53 <gds> I guess most of them are likely to be either asleep or at anglohaskell... :/
04:27:15 <yip> also memory requirements. the haskell programs i've written all consume huge amounts of memory when run
04:28:25 <gds> Well, I can't be a lot of help, being fairly new to practical haskell use, but my local hopy of the lambdabot's been running for a week or so now without using all my RAM...
04:29:49 <yip> that sounds good
04:31:00 <audreyt> the GC is generally very good from my experience
04:31:06 <audreyt> it's actually very hard to cause leaks
04:31:12 <audreyt> unless you ask for it :)
04:31:38 <flodin> what about e.g. database connections, open network sockets and such
04:32:04 <audreyt> the "bracket" ("withDatabaseConnection" etc) pattern can help there
04:33:08 <dons> yip, long running times are no problem
04:33:19 <dons> i've had hmp3 running for 4 months without stopping
04:33:36 <dons> and lambdabot's had a few weeks uptime
04:35:11 <yip> i read a while ago on the internet about this guy who tried using haskell for this big server program and ended up using erlang
04:35:19 <dons> haskell space leaks are obvious things -- a function just uses much more space than it should, and either finishes, or dies, they're not slow malloc/free bugs like in C that catch up with you after some time
04:35:39 <dons> yeah, joelr, he tried to learn haskell while deploying some 5000 thread serverr.
04:35:55 <dons> he did some odd things, imo. which contributed to the decision to go back to what he knew
04:36:12 <dons> it wasn't so much a reflection of haskell, as of him knowing erlang already
04:36:19 <yip> you strongly believed that a proper solution could have been done in haskell?
04:36:38 <dons> yes. he reached a point where his custom coded binary library was too slow
04:36:53 <dons> but he didn't try using the well known binary libraries the rest of us use, NewBinary
04:37:04 <dons> which would have solved his issue with memory throughput
04:38:21 <yip> i see
04:38:31 <dons> also, i don't suggest learning a new language with a 6 week deadline to implement some huge software
04:39:06 <yip> sounds fun to me :)
04:39:48 <dons> :D
04:40:54 <yip> guess i'll try some things out then
04:45:33 <tennin> I've done it several times!
04:45:45 <tennin> and never met the deadline.
04:47:06 <tennin> or came anywhere near meeting it
04:47:14 <tennin> oh well
04:49:02 <gour> anyone knows something about mhc (mono haskell compiler) ?
04:49:15 <mux> dons: is FPS 0.7 out?
04:51:44 <mux> looks like it is
04:51:54 * mux goes to update the hs-fps FreeBSD port
04:57:20 * mux pings dons
04:57:26 <mux> there are new dependencies?
04:58:02 <mux> eh, and your FPS homepage is buggy
04:58:30 <mux>     <li><a href="ftp://ftp.cse.unsw.edu.au/pub/users/dons/fps/fps-0.6.tar.gz">FPS 0.7</a>
04:58:34 <mux>     <li><a href="ftp://ftp.cse.unsw.edu.au/pub/users/dons/fps/fps-0.6.tar.gz">FPS 0.6</a>
04:58:37 <mux> spot the bug :-)
04:59:30 <yip> looks good to me
05:01:24 <gour> both point to the same tarball
05:01:28 <mux> yip: you're not annoyed by the fact that both links actually point to 0.6 though FPS 0.7 should point to 0.7? :-)
05:02:44 <yip> i'm not sure i understand the problem
05:02:56 <yip> \:P
05:03:31 <gour> yip: by pressing 0.7 link,you'll get 0.6 archive
05:03:47 <yip> maybe it's intentional though... some kind of "stupid filter" to prevent people like me from getting the latest version :O
05:04:24 <gour> why is named as 0.7 then?
05:04:58 <yip> hm.... let's just hope that this gets fixed soon enough
05:05:04 <mux> anyone can tell me where I should expect to find the GHC.IOBase module?
05:05:17 <mux> I have GHC of course, 6.4.2
05:06:00 <mux> I cannot update the FreeBSD port for FPS 0.7 because of a build error where it ghc tells me it can't find the said module (GHC.IOBase)
05:06:12 <mux> s/where it/where/
05:07:14 <mux> dons->invoke();
05:12:17 <mux> that was probably too C-ish :-)
05:27:23 <dons> mux, yep. its out
05:27:34 <mux> saw all my messages?
05:27:56 <mux> I have a problem building FPS 0.7, and the bug in the FPS webpage
05:28:13 <dons> yep. fixing...
05:28:22 <dons> done
05:28:25 <mux> cool
05:28:33 <mux> you know about that GHC.IOBase error?
05:29:04 <dons> hmm. that's very strange
05:29:10 <dons> GHC.IOBase is in base/
05:29:20 <mux> that's what I thought
05:29:28 <dons> can you load it up in ghci?
05:29:29 <mux> maybe my installation is fux0red for some reason
05:29:32 <dons> maybe
05:29:37 <dons> is base hidden?
05:29:54 <mux> hidden as in inside () in ghc-pkg list?
05:29:59 <dons> yep
05:30:22 <mux> then not
05:30:26 <mux> and I can load it in ghci just fine
05:32:03 <dons> no idea then. Cabal brokified?
05:32:10 * mux shrugs
05:32:15 <mux> how would I know? :-)
05:32:23 <dons> builds here fine, anyway. the tarball
05:32:35 <mux> I'm using the tarball too
05:33:24 <dons> hmm
05:33:43 <mux> Compiling Data.ByteString.Lazy.Char8 ( ./Data/ByteString/Lazy/Char8.hs, dist/build/Data/ByteString/Lazy/Char8.o )
05:33:47 <mux> Chasing modules from: Data.ByteString,Data.ByteString.Char8,Data.ByteString.Base,Data.ByteString.Fusion,Data.ByteString.Lazy,Data.ByteString.Lazy.Char8
05:33:50 <mux> Could not find module `GHC.IOBase': use -v to see a list of the files searched for (imported from ./Data/ByteString.hs)
05:33:52 <mux> so that you have some context.
05:33:57 <dons> hh
05:34:03 <dons> huh
05:34:26 <dons> are you building the profiled way by accident? and don't have prof libs installed?
05:34:44 <mux> ooops!
05:34:53 <mux> retrying without profiling
05:34:55 <dons> ah ha!
05:35:06 * dons scores 1
05:35:09 <mux> :-)
05:35:14 <mux> @karma+ dons
05:35:14 <lambdabot> dons's karma raised to 48.
05:35:34 <mux> ok it builds just fine now
05:35:42 <mux> sorry :-).
05:35:43 <dons> great
05:35:47 <dons> check the testsuite too.
05:35:51 <dons> cd tests ; gmake
05:35:57 <dons> after install
05:36:00 <mux> ok
05:36:15 <mux> I'm checking if the package deinstallation works fine now
05:36:37 <mux> I guess I have to add some installed files first
05:37:26 <mux> yes I do
05:50:31 <gour> what are the current prospects in using haskell in some mono project?
06:03:26 <mux> dons: this test suite is taking ages :)
06:04:43 <mux> dons: all OK!
06:05:30 <mux> dons: I'm committing the update port
06:05:35 <mux> updated
06:05:51 <dons> there's lots of tests :)
06:06:07 <dons> and you didn't even run 'gmake everything' ;)
06:06:31 <mux> here, committed
06:06:58 <dons> great!
06:07:07 <dons> got a link, i'll stick it on the fps page
06:07:43 <mux> mmm, a link to what?
06:07:48 <mux> the cvsweb directory for the port?
06:07:54 <dons> yeah, that'd do
06:08:50 <mux> http://www.freebsd.org/cgi/cvsweb.cgi/ports/devel/hs-fps/
06:08:52 <lambdabot> Title: ports/devel/hs-fps/
06:08:54 <mux> or you could use
06:09:01 <mux> http://www.freshports.org/devel/hs-fps/
06:09:03 <lambdabot> Title: FreshPorts -- devel/hs-fps
06:09:07 <mux> but this isn't an officiel FreeBSD website
06:10:38 <mux> bah, $REAL_WORK kicks in
06:10:42 * mux bbl
06:11:11 <dons> thanks mux
06:11:17 <dons> ?karma+ mux -- freebsd ports
06:11:18 <lambdabot> mux's karma raised to 2.
06:16:10 <qz> what is haskell operator for testing not equality? like != in C
06:17:22 <dons> > False /= True
06:17:23 <lambdabot>  True
06:17:34 <dons> > 1 /= 2
06:17:35 <lambdabot>  True
06:17:40 <dons> > not (1 == 2
06:17:41 <lambdabot>  Parse error
06:17:43 <dons> > not (1 == 2)
06:17:44 <lambdabot>  True
06:18:01 <dons> > let (!=) = (/=) in 1 != 2
06:18:02 <lambdabot>  True
06:18:28 <dons> != looks so weird to me after all this time. I remember the days when /= was bizarre
06:18:40 <qz> oh, thanks
06:18:57 <qz> just weird that it has == but no !=   but that must be just my C background..
06:19:11 <gds> haskell is full of smileys :)
06:19:12 <dons>  /= is like =/= in math
06:19:29 <gds>  /= , >>= , etc
06:19:30 <dons> > (((:[]) :) :)
06:19:31 <lambdabot>  Add a type signature
06:19:36 <dons> > (((:[]) :) :) :: [()]
06:19:37 <lambdabot>    Expecting a function type, but found `[()]'
06:19:37 <lambdabot>    Expected type: [()]
06:19:37 <lambdabot>  ...
06:19:45 <dons> ?type (((:[]) :) :):
06:19:47 <lambdabot> parse error (possibly incorrect indentation)
06:19:51 <dons> ?type (((:[]) :) :)
06:19:53 <lambdabot> forall a. [[a -> [a]] -> [a -> [a]]] -> [[a -> [a]] -> [a -> [a]]]
06:19:55 <dons> yay
06:21:23 <qz> uh.. and >>= is not bitshift
06:21:37 <dons> right. `shiftL` or `shiftR`
06:21:54 <dons> ?type (.|.)
06:21:55 <lambdabot> forall a. (Bits a) => a -> a -> a
06:21:58 <dons> ?type (.&.)
06:21:59 <lambdabot> forall a. (Bits a) => a -> a -> a
06:22:08 <dons> ?type 1 `shiftL` 3
06:22:10 <lambdabot> forall a. (Bits a) => a
06:22:14 <dons> > 1 `shiftL` 3
06:22:15 <lambdabot>  Add a type signature
06:22:18 <dons> > 1 `shiftL` 3 :: Int
06:22:19 <lambdabot>  8
06:22:50 <dons> > let .<<. = shiftL in 1 .<<. 4 :: Int -- nicer syntax
06:22:51 <lambdabot>  Parse error
06:23:01 <dons> > let (.<<.) = shiftL in 1 .<<. 4 :: Int -- nicer syntax
06:23:02 <lambdabot>  16
06:23:20 <qz> heh nice, but that shiftL/R is not in Prelude, right?
06:23:26 <dons> its in Data.Bits
06:23:32 <dons> in the base package
06:23:33 <qz> i see
06:23:41 <dons> ?hoogle shiftL
06:23:42 <lambdabot> Data.Bits.shiftL :: Bits a => a -> Int -> a
06:23:42 <lambdabot> GHC.Exts.shiftL# :: Word# -> Int# -> Word#
06:23:42 <lambdabot> GHC.Exts.iShiftL# :: Int# -> Int# -> Int#
06:25:25 <qz> great. is there local version of such help system?
06:26:13 <gds> There's lambdabot, and the web based version:
06:26:16 <gds> @where hoogle
06:26:16 <lambdabot> http://www.haskell.org/hoogle
06:27:07 <qz> thanks
06:28:28 <dons> yeah. you can also just install lambdabot locally and run it out of ghci (or on its own)
06:28:47 <dons> $ ghci
06:28:47 <dons> GOA> :hoogle map
06:28:47 <dons> Prelude.map :: (a -> b) -> [a] -> [b]
06:28:47 <dons> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
06:28:47 <dons> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
06:29:23 <mux> dons: my pleasure really
06:29:44 <dons> :)
06:29:58 <ld> hi, if I need to do binary stuff like read an integer on 24 bits from a binary file, is there anything in haskell that can help me do that? or maybe a library?
06:30:13 <mux> I'll have to make sure the profiling build works
06:30:21 <mux> but that means rebuilding GHC with profiling
06:30:30 <mux> which will take so much time it's no fun :-P
06:31:50 <mux> dons: heh, saw the link you put in the webpage, that really isn't a binary :-)
06:33:05 <dons> well, its going to let someone produce a binary
06:33:31 <dons> Id, yeah, you can use a combination of getChar and Data.Bits
06:33:34 <dons> or else try NewBinary
06:33:37 <dons> ?where NewBinary
06:33:37 <lambdabot> darcs get http://www.n-heptane.com/nhlab/repos/NewBinary
06:33:53 <dons> you could also try using Data.ByteString combined with Data.Bits
06:34:58 <ld> cool, thanks :)
06:35:04 <dons> ld, you'd suck the file into a bytestring, then index those bytes, shifting them into an Int, as appropriate, I'd think
06:35:42 <dons> here, for example, is a function to read a 32 bit value:
06:35:44 <dons> getWord32 :: Handle -> IO UInt32
06:35:44 <dons> getWord32 h = h `seq` do
06:35:44 <dons>     w1 <- getWord8 h
06:35:44 <dons>     w2 <- getWord8 h
06:35:46 <dons>     w3 <- getWord8 h
06:35:49 <dons>     w4 <- getWord8 h
06:35:51 <dons>     return $!! ((fromIntegral w1 `shiftL` 24) .|.
06:35:54 <dons>            (fromIntegral w2 `shiftL` 16) .|.
06:35:56 <dons>            (fromIntegral w3 `shiftL`  8) .|.
06:35:59 <dons>            (fromIntegral w4))
06:36:02 <dons> so you get the idea. 24 bits should be easy.
06:36:33 <ld> cool
06:36:52 <ld> thanks :)
06:37:14 <dons> no worries. bit hackery in haskell is my favourite pastime :)
06:37:37 <ld> I've been shifting like crazy in php hehe
06:37:42 <dons> oh, getWord8 is:
06:37:43 <dons>     c <- hGetChar h
06:37:44 <dons>     return $! (fromIntegral (ord c))
06:37:54 <ld> not the most efficient language for shifting bits
06:37:56 <ld> :D
06:37:59 <dons> right!
06:38:11 <dons> in fact, it may be just about the most inefficient. ;)
06:38:21 <ld> now don't forget java ;)
06:38:28 <dons> oh, no. javascript is worse
06:38:41 <ld> how about in ocaml? any idea how to do it there?
06:38:55 <dons> I think ocaml would be similar to the above. but I can't be sure.
06:38:59 <dons> vincenz: around?
06:39:12 <dons> there's a few ocaml refugees here who might know though
06:39:22 <ld> hehe
06:39:47 <ld> I actually started learning ocaml, seems to generate quite fast code
06:39:57 <dons> yep
06:40:11 <dons> its like strict haskell, in that sense.
06:40:18 <ld> don't know haskell, but the 2 languages seem to be similar in quite a lot of areas
06:40:53 <dons> yeah. haskell has some newer features, and some sophisticated bits ocaml lacks, but ocaml is also very nice, as far as languages go
06:41:06 <ld> too bad the community lacks :(
06:41:13 <ld> all the libraries are outdated
06:41:14 <ld> etc
06:41:16 <vegai> I find Ocaml's module language, even if very powerful, a burden
06:41:45 <dons> community is an under appreciated aspect of programming language design, I suggest :)
06:42:01 <vegai> also, impossible to design
06:42:18 <dons> well, you can encourage at least
06:43:02 * gds thinks the perl community has been particularly cunningly cultivated, for example.
06:43:03 <ld> yeah... when I see "latest beta version released in 2002" next to most interesting libraries then I find the channel empty and the documentation a little lacking, I feel like maybe I chose the wrong language
06:43:21 <dons> gds, hmm, we should study their techniques perhaps
06:44:01 <gds> dons: cpan is important - the london perl mongers take great pride in the percentage of it that's generated by their members...
06:44:08 <ld> how's haskell compared to ocaml when looking at the generated code speed?
06:44:12 <dons> ld, some fun stats, http://www.cse.unsw.edu.au/~dons/irc/ :)
06:44:12 <lambdabot> Title: Haskell IRC Activity
06:44:19 <dons> ld: about the same, with a bit of practice
06:44:26 <dons> they're both very fast
06:44:30 <dons> ?shootout
06:44:30 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
06:44:47 <dons> (note that the haskell ones are a bit down, since we're not using a key library)
06:45:01 <ld> a key library?
06:45:13 <dons> yeah, Data.ByteString comes out with ghc 6.6 in a few weeks
06:45:18 <dons> its not on the shootout machine yet
06:45:30 <ikegami--> good news
06:45:44 <ld> hehe, I was looking at the shootout when I decided to try ocaml out
06:45:45 <gds> 6.6 "in a few weeks"? Cool :)
06:45:46 <dons> hopefully, we can take back the lead we had earlier this year
06:45:51 <ld> maybe I should switch to haskell
06:46:12 <ld> what compiler should I use?
06:46:15 <dons> ghc
06:46:17 <dons> ?where ghc
06:46:17 <lambdabot> http://haskell.org/ghc
06:46:29 <ld> cool :)
06:46:40 * ld is looking for the haskell docs
06:46:48 <dons> ?docs Data.List
06:46:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
06:46:54 <dons> what kind of docs, though
06:47:00 <ld> basics
06:47:04 <dons> maybe just start at http://haskell.org :)
06:47:05 <lambdabot> Title: Haskell - HaskellWiki
06:47:12 <ld> yap :)
06:47:26 <dons> the 'Haskell in 5 Steps' if you're beginning totally from scratch
06:47:52 <adam> what's a good Haskell introduction for someone with previous programming experience in Python and Ruby?
06:47:53 <ld> looks cool
06:48:00 <ld> ocamlish :)
06:48:18 <dons> adam: hmm. YAHT?
06:48:25 <dons> ?where YAHT
06:48:25 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
06:48:39 <dons> not sure we have one specifically for python hackers
06:48:54 <dons> maybe we should , since they have many of the haskell basics already, i suppose
06:49:02 <sieni> and further, gch licensing does not suck as opposed to ocaml licensing
06:49:11 <norpan> language-specific tutorials do more harm than good i think
06:49:19 <adam> dons: thanks. is the "gentle introduction" a misnoner as people say?
06:49:25 <mux> dons: there should be a tutorial for guys that spent years doing only imperative programming
06:49:27 <dons> well, its more of a textbook
06:49:35 <dons> mux, right. we should have that
06:49:36 <ld> anyway, I'm out. thanks alot for the help :)
06:49:43 <dons> no worries!
06:49:48 <mux> dons: I really had a hard time learning haskell at the beginning
06:50:01 <dons> we probably should have a strategy/plan for our tutorials, and where the gaps are
06:50:01 <mux> "What?!? No side-effects?" etc
06:50:05 <adam> mux: "guys that spent years doing only imperative programming" -> oh, you mean "programmers" ;-)
06:50:12 <sieni> mux: yes, it's called "learn scheme first and then reading 'gentle introduction to haskell'" ;-)
06:50:16 <dons> not all of them, adam :)
06:50:35 <norpan> i think yaht is good for almost any background
06:50:35 <mux> sieni: ugh!
06:50:35 <adam> dons: seriously, what's a popular functional language?
06:50:42 <dons> lisp?
06:50:53 <adam> all the popular languages seem mostly imperative. (lisp is popular?)
06:50:53 * ValarQ would say Haskell
06:51:00 <gds> popular in certain circles ;)
06:51:02 <dons> haskell's in the news, a lot
06:51:03 <norpan> lisp is popular
06:51:03 <ValarQ> popular in my own mind anyway
06:51:05 <mux> ocaml is quite popular too
06:51:10 <dons> its in the linux journal this week
06:51:35 <mux> the fact that it's used to generate highly-optimized C code for the FFTFTW lib gets many people excited
06:51:37 <adam> frankly, Haskell seems so much more interesting than Lisp.
06:51:55 <sieni> lisp has its fun parts as well
06:52:04 <dons> mux: though the exact same approach works in haskell too, for fftw
06:52:07 <adam> Lisp is like Ruby with an ugly syntax, impossible stdlib, and some macros that don't compensate for above shortcomings.
06:52:15 <norpan> hehe
06:52:20 <dons> adam: heh!
06:52:21 <kowey> Lisp syntax is ugly?
06:52:23 <mux> dons: yeah, sure, but the kind of people that get all excited by it don't realize this :-)
06:52:29 <sieni> lisp syntax is <3
06:52:32 <dons> ?remember adam Lisp is like Ruby with an ugly syntax, impossible stdlib, and some macros that don't compensate for above shortcomings
06:52:32 <lambdabot> Done.
06:52:36 <norpan> ¬ªHave you tried to read the main tutorial, "A Gentle Introduction to Haskell" (www.haskell.org/tutorial), and found it to be about as gentle as a Pan Galactic Gargle Blaster?¬´
06:52:41 * sieni <3 parentheses
06:52:49 <mux> Lots of Insipid and Stupid Parenthesis?
06:53:01 <mux> hahaha
06:53:11 <mux> haskell got my brain smashed by a gold brick with slice of lemon
06:53:15 <sieni> lots of irritating superfluous parentheses
06:53:16 * dons <3 $
06:53:21 <dons> ;)
06:53:25 <mux> we need haskell peril-sensitive sunglasses
06:53:31 <adam> dons: so wht are you doing in #haskell? ;)
06:53:54 <norpan> what he tell!
06:53:54 <adam> I mean, you can't actually get a job writing Haskell, right?
06:54:02 <dons> > reverse $ reverse $ map toUpper $ "Using dollar ;"
06:54:04 <lambdabot>  "USING DOLLAR ;"
06:54:30 <adam> oh, it's an operator of some sort. I see.
06:54:35 <mux> "Perl is too mainstream for you? Brainfuck too annoying? Try Haskell!"
06:54:38 <dons> i have a job writing haskell.
06:54:39 <norpan> adam: you can get a job writing haskell. i have
06:54:47 <norpan> or at least part-time haskell
06:54:49 <dons> yes, little joke about $ being the haskell soln to parenthesis hell
06:55:02 <adam> norpan: doing what if I may inquire?
06:55:08 <dons> > id (id (id (id 'x'))) == id $ id $ id $ id $ id 'x'
06:55:09 <lambdabot>    Expecting a function type, but found `a'
06:55:09 <lambdabot>    Expected type: Char
06:55:09 <lambdabot>    ...
06:55:25 <dons> > id (id (id (id 'x'))) == (id $ id $ id $ id $ id 'x')
06:55:26 <lambdabot>  True
06:55:34 <mux> btw, is "a -< x" the same thing as "returnA x >>> a"
06:56:41 <dons> mux, not sure. check the arrow paper?
06:56:49 <dons> ?docs Control.Arrow
06:56:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html
06:57:08 <mux> yeah, I will do that, just a bit busy at work for now to dive in this paper again
06:57:15 <mux> I think I read it 3 or 4 times already. :-P
06:58:07 <norpan> adam: www.jasper-da.com
06:58:24 <SamB> mux: I thought it was more like "a <<< returnA x" ;-P
06:58:29 <norpan> the Jasper Gold product
06:58:32 * SamB isn't positive, though
06:58:46 <mux> SamB: I would trust you more by default :-)
06:58:48 <SamB> you could always try passing it through the arrows preprocessor
06:58:55 <mux> I'm not even sure this is the question I wanted to ask :D
06:59:02 * tibbe has tried to understand arrows a couple of times and failed
06:59:03 <mux> I was asking this myself a few days ago
06:59:04 <mux> heh
06:59:22 <mux> what's hard about arrows is that they are actually easier than monads, while they are a generalization
06:59:23 <SamB> I don't really get the notation ;-)
06:59:27 <mux> this really didn't help me
06:59:54 <SamB> it doesn't help that HXT doesn't use the notation...
07:00:13 * mux nods
07:00:27 <mux> maybe I'm just being completely wrong though
07:00:38 <tibbe> is there any explanation of arrows that doesn't involve 10 pages of denotational semantics?
07:01:18 <ValarQ> tibbe: http://haskell.org/arrows/syntax.html
07:01:22 <kowey> there's http://en.wikibooks.org/wiki/Haskell/Understanding_arrows but it sort of trips over its own shoelaces
07:01:26 <mux> SamB: btw, unless I'm a fool, "returnA x >>> a" is exactly the same as "a <<< returnA x"
07:01:28 <dons> "they're like totally this notation for hacking tuples"?
07:02:04 <SamB> mux: quite
07:02:27 <mux> (<<<) :: Arrow a => a c d -> a b c -> a b d
07:02:27 <mux> f <<< g = g >>> f
07:02:33 <mux> from Hugs
07:02:33 <SamB> tibbe: is there an explanation that does?
07:03:00 <SamB> because I didn't think the semantics were specified in much detail for Arrows in general...
07:03:01 <mux> I *need* to take a look at Clean
07:03:34 <SamB> I thought basically there were some laws that aren't well agreed-on that are supposed to apply to various Arrow classes...
07:04:10 * SamB almost thinks the laws should have classes of their own
07:04:29 <SamB> except we haven't a decent way to stick them in type signatures
07:04:50 <SamB> or class heads
07:05:30 <mux> damn, GHC has per-cpu runqueues now
07:05:36 <mux> FreeBSD doesn't even have those yet :-P
07:06:03 <SamB> (I mean, (ArrowLaw1 a, ArrowLaw2 a, ArrowLaw3 a) => looks a bit verbose
07:06:22 <tibbe> SamB, I don't now actually, I'm just expressing some frustration since I'm not smart enough to get  it ;)
07:06:55 <tibbe> but why arrows?
07:07:00 <SamB> when what you want to say is "instances of this class must follow Arrow laws 1, 2, and 3"
07:07:03 <SamB> why arrows?
07:07:04 <SamB> well.
07:07:05 <mux> why not? :D
07:07:22 <SamB> why functions? ;-)
07:07:42 * SamB wants to know why pure is in the Arrow class, though
07:08:08 <mux> to push pure functions into arrows?
07:08:36 <SamB> do you need that for every arrow?
07:09:34 <mux> dunno :-)
07:10:10 * tibbe is afk for sec, needs a coffee break
07:10:18 <SamB> hmm, I need to figure out a better way to find a solution for clearregs...
07:11:31 <ValarQ> speaking of arrows...
07:11:37 <ValarQ> > ((const 1) >>> (+1)) 0
07:11:39 <lambdabot>  2
07:11:51 <ValarQ> what arrow instance is used there?
07:12:38 <mux> (->)
07:12:39 <mux> I think.
07:12:51 <mux> > returnA 1 >>> (+1)
07:12:52 <lambdabot>  add an instance declaration for (Num (b -> c))
07:12:59 <mux> dang
07:15:27 <mux> I'm still really rusty on that stuff
07:16:51 * ValarQ has only read the papers
07:17:04 <ValarQ> it's a bit above my head but i find it interesting
07:17:31 <mux> heh, how many times have I said myself the very same thing about some haskell features :)
07:17:42 <mux> "it looks darn cool but I don't get it"
07:19:26 <dons> ?pl uncurry ((. g) . (,) . f)
07:19:27 <lambdabot> f *** g
07:19:45 <mux> EvilDons
07:19:53 <dons> ?pl uncurry ((. g) . (,))
07:19:54 <lambdabot> second g
07:20:02 <dons> like I said before, arrows are great for tuple hacking
07:20:08 <dons> that's all I ever use them for :)
07:20:22 <dons> oh, and they're good for writing 3d shooter games too, I've heard
07:20:28 <dons> that, and tuples.
07:21:11 <kowey> and if you combine arrows, you can have robots running around 3d shooter worlds?
07:21:28 <dons> lambdabots , any way
07:21:42 <dons> Frag is written in arrows
07:21:48 <dons> ?where Frag
07:21:48 <lambdabot> http://www.haskell.org/haskellwiki/Frag
07:22:37 * dons >>> sleep
07:24:16 <mux> nite dons
07:27:36 <yip> there's also that xml library that is entirely based on arrows
07:31:15 <mux> HXT?
07:31:19 <mux> or HaXML
07:31:22 <mux> one or the other
07:39:45 <kowey> HXT has an arrows interface, and I've never heard about arrows in HaXmL
07:51:18 <lokadin> is "" a String or Char?
07:51:45 <LordBrain> If i installed hscurses from source using sh configure; make; make install, how do i install a profiling copy of the library?
07:51:57 <LordBrain> it's a string
07:52:04 <LordBrain> "" = []
07:52:18 <LordBrain> :: [Char]
07:52:39 <lokadin> kk thanks
07:53:03 <gds> @type ""
07:53:04 <lambdabot> [Char]
07:53:10 <bolrod> @type String
07:53:12 <lambdabot> Not in scope: data constructor `String'
07:53:13 <tibbe> "abc" = ('a' : ('b' : ( 'c' : [])) I guess (in sad haskell smiley style)
07:53:17 <bolrod> @type "34"
07:53:18 <lambdabot> [Char]
07:53:19 <tibbe> "abc" = ('a' : ('b' : ( 'c' : [])) I guess (in sad haskell smiley style)
07:53:24 <tibbe> oops
07:54:41 <lokadin> how do i show an empty [String]
07:54:56 <musasabi> tuples
07:55:04 <musasabi> agh. ignore.
07:55:20 <gds> an empty String, or an empty list of strings? ([String])
07:55:27 <gds> the former "", the latter [].
07:55:57 <lokadin> the later thanks :)
07:56:02 <gds> np:)
07:56:46 <lokadin> hmmm, so i would declare it as f [] = [] ?
07:57:18 <gds> without any knowledge of what f is suppsoed to do, that looks right :)
07:57:24 <lokadin> cause that still claims its a String
07:57:29 <lokadin> and not a [String]
07:57:40 <emertens> [] could very well be a [Char] aka String
07:57:57 <gds> explicit type?
07:58:17 <gds> @type f [] = [] :: [String]
07:58:19 <lambdabot> parse error on input `='
07:58:28 <gds> @type let f [] = [] :: [String] in f
07:58:30 <lambdabot> [String] in f :: forall a. [a] -> [String]
07:59:13 <gds> or you could add the type signature "f :: [String] -> [String]" above the function definition if you like...
07:59:26 <lokadin> i did
07:59:31 <gds> Ah :)
08:00:11 <emertens> If the type system is infering the wrong type, you are probably using the function wrong
08:00:59 <gds> What's the surrounding code?
08:01:19 <lokadin> hmmm one sec
08:01:26 <gds> @paste
08:01:26 <lambdabot> http://paste.lisp.org/new/haskell
08:01:30 <gds> If it's big...
08:01:39 <emertens> more than 4 lines big
08:03:18 <lokadin> the relevant code isn't much
08:03:35 <lokadin> >  args <- getArgs
08:03:35 <lokadin> >  let bridi = convertToUsable $ words $ unwords args
08:03:35 <lambdabot>  Parse error
08:03:36 <lambdabot>  Parse error
08:03:51 <lokadin> convertToUsable :: [String] -> [String]
08:03:51 <lokadin> >convertToUsable [] = []
08:03:51 <lokadin> >convertToUsable (x:xs) = case x of
08:04:20 <lokadin> or if you want i can paste the whole thing..
08:04:30 <lokadin> not really a problem
08:04:31 <LordBrain> if i use Data.ByteString, do i still get the nice " " notation?
08:04:39 <sjanssen> LordBrain: nope
08:04:46 <LordBrain> hmm
08:04:55 <sjanssen> there is Data.ByteString.pack however
08:05:21 <gds> lokadin: You're using a literate style right - with ">" at the beginning of every executable line?
08:05:31 <lokadin> yep
08:05:58 <gds> I think there has to be a ">" at the beginning of the type signature too - is the lack of one in channel a typo, or is it that way in your source?
08:05:58 <andersca> hey bringert
08:06:30 <lisppaste2> lokadin pasted "short program with infrence problem" at http://paste.lisp.org/display/23643
08:06:51 <gds> typo then :)
08:06:56 <lokadin> yep :)
08:07:20 <jgrimes> sjanssen, if you use pack does it create the String before converting it to ByteString or is there some kind of fusion there?
08:07:23 <LordBrain> i put my money on cut/paste error
08:08:16 <lokadin> @hoogle words
08:08:17 <lambdabot> Prelude.words :: String -> [String]
08:08:17 <lambdabot> Data.PackedString.wordsPS :: PackedString -> [PackedString]
08:08:17 <lambdabot> Prelude.unwords :: [String] -> String
08:08:41 <jgrimes> I don't really understand how the shortcut fusion works. It would seem that list construction is a producer and pack would be a consumer
08:09:34 <gds> lokadin: the problem's not with the beginning of the convertToUsable definition, but with the first use of "untill"
08:09:57 <LordBrain> how does pattern matching work on a ByteString ?
08:10:18 <neologism> LordBrain: it doesnt
08:11:33 <LordBrain> maybe we should just have a compiler optimization flag which turns our list strings into byte strings.
08:11:41 <gds> lokadin: What's the type of untill?
08:12:05 <lokadin> gds: kk thanks, i declared it and now it doesn't complain about that line anymore :)
08:12:18 <musasabi> LordBrain: that would not work. Rebindable syntax for specific modules could work.
08:12:49 <LordBrain> yeah i like rebindable syntax even better
08:12:50 <MarcWeber> I want to write some small scripts which do show every single step they'll execute (and optionally query for confirmation).. If such an IO action fails I want to print this command so that the user can get an idea what's wrong. For propagating errors would you use fail, exception, your own monad (s.th like >>= of Maybe with Either Error Success) ?
08:13:33 <MarcWeber> When using monadic fail there is no way to escape again (using something like catch) is there?
08:14:19 <gds> lokadin: Cool :)
08:15:15 <LordBrain> yeah there's a catch
08:15:41 <ibid> MarcWeber: not in general, but there are solutions specific to specific monads, and i think a generalizatin of that
08:16:04 <lokadin> gds: it's just now it's complaining that second argument of until is expected as a  String and infered as [String] (as what it should be), i'm thinking i don't fully understand the x:xs notation or some such
08:16:34 <LordBrain> isnt that what Control.Exception is for?
08:16:41 <gds> in x:xs, xs is of type [a] where x is of type a
08:16:49 <ibid> LordBrain: that's the generalization
08:16:52 <gds> and (x:xs) itself is of type [a]
08:17:11 <MarcWeber> ibid: Is catch on example? Or do you think about something different, too? (A keyword is enough)
08:17:33 <lokadin> hmmm, well then it seems as though it should work, as xs is of type [String], because (x:xs) is
08:18:15 <gds> so you want untill :: String -> [String] -> [String] ?
08:18:16 <ibid> MarcWeber: EPARSE
08:18:33 <lokadin> gds: yep, sorry didn't mention it earlier
08:19:15 <ptolomy> > let times x = sequence_ . take n . repeat in 2 `times` (print "Whee.")
08:19:16 <lambdabot>  Not in scope: `n'
08:19:22 <ptolomy> > let times n = sequence_ . take n . repeat in 2 `times` (print "Whee.")
08:19:23 <lambdabot>  No IO allowed
08:19:29 <ptolomy> oh well. still, whee.
08:19:32 <LordBrain> is until misspelt on purpose?
08:19:50 <LordBrain> :)
08:20:16 <lokadin> nope .oiro'a
08:20:17 <gds> lokadin: is it deleberate that the last line of "untill" calls "until" (not a recursive call to "untill")
08:20:20 <gds> ?
08:20:28 <int-e> @type replicateM
08:20:29 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
08:20:38 <Cale> ptolomy: replicateM ?
08:20:49 <ptolomy> Ooh. :-P
08:21:01 <int-e> @type replicateM_
08:21:01 <ptolomy> I was hoping someone would suggest a better way.
08:21:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
08:21:04 <lokadin> gds: thanks
08:21:09 <ptolomy> Thanks. :)
08:21:17 <gds> lokadin: np:)
08:21:58 <lokadin> didn't really change the error though
08:22:47 <gds> lokadin: perhaps you want that last "++" to be ":"
08:23:23 <lokadin> i'm a little confused as to what they are
08:23:34 <gds> if you expect x to be a String, and (untill str xs) to be a [String] then you want ":"
08:23:55 <gds> @type (:)
08:23:56 <lambdabot> forall a. a -> [a] -> [a]
08:23:59 <gds> @type (++)
08:24:00 <lambdabot> forall a. [a] -> [a] -> [a]
08:24:00 <MarcWeber> ibid: Didn't find it (hoogle, my generated tags, google) I did find reparse from parsec. I think I'll use exceptions for errors.
08:24:01 <LordBrain> : is cons... it puts an element onto the front of your list
08:24:05 <lokadin> oh
08:24:23 <gds> ++ is defined using :
08:24:25 <LordBrain> ++ is concatenate
08:24:45 <lokadin> i need it to be untill :: String -> [String] -> String
08:25:08 <lokadin> or
08:25:20 * lokadin tries to think and gets very confused
08:25:21 <LordBrain> or with one l damnit
08:25:25 <LordBrain> hehe
08:25:33 <gds> @type until
08:25:34 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
08:25:59 <Cale> [] ++ ys = ys; (x:xs) ++ ys = x : (xs ++ ys)
08:26:57 <lokadin> well what i wanted is so that a string such as "lo nanmu ku cu vimcu" would be broken up into "lo nanamu ku":"cu vimcu":[]
08:27:01 <int-e> > let negative = (<0) in until (not . negative) negate (-1)
08:27:02 <lambdabot>  1
08:27:23 <Cale> int-e: heh
08:27:38 <lokadin> so i do want [String] to be the result of untill?
08:27:49 <Cale> That's a fairly roundabout way to write abs :)
08:28:17 <emertens> @type until
08:28:19 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
08:28:20 <lokadin> abs?
08:28:25 <lokadin> it's untill not until
08:28:29 <int-e> Cale: but very readable :)
08:28:36 <lisppaste2> Lokadin annotated #23643 with "version 2" at http://paste.lisp.org/display/23643#1
08:28:50 <gds> @hoogle abs
08:28:51 <lambdabot> Prelude.abs :: Num a => a -> a
08:28:51 <lambdabot> System.IO.AbsoluteSeek :: SeekMode
08:28:51 <lambdabot> Language.Haskell.Syntax.HsEAbs :: HsQName -> HsExportSpec
08:29:06 <gds> Ah - different conversation thread... :)
08:29:42 <int-e> case x of str -> ...  binds a new variable (called str) to the value of x
08:29:58 <int-e> you have to use some comparison.
08:30:11 <gds> lokadin: are you always breaking on whole words?
08:30:31 <gds> If so, you could use words, takewhile, dropwhile and concat.
08:30:47 <emertens> @type whileM
08:30:49 <lambdabot> Not in scope: `whileM'
08:31:02 <ibid> MarcWeber: Control.Monad.Error is the most general, but it requires support from the monad
08:31:15 <lokadin> gds: yea i never break on a part of a word
08:31:37 <gds> > concat $ takewhile ("some"==) $ words "these are some words"
08:31:51 <lambdabot>  Not in scope: `takewhile'
08:32:00 <gds> ?
08:32:08 <gds> @hoogle take
08:32:08 <Cale> > concat $ takeWhile ("some"==) $ words "these are some words"
08:32:10 <lambdabot> Prelude.take :: Int -> [a] -> [a]
08:32:11 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
08:32:11 <lambdabot> Data.PackedString.takePS :: Int -> PackedString -> PackedString
08:32:15 <gds> Ah :)
08:32:27 <lambdabot>  ""
08:32:29 <int-e> > break even [1..10]
08:32:31 <lambdabot>  ([1],[2,3,4,5,6,7,8,9,10])
08:32:46 <gds> Oh, we have a break function :)
08:32:48 <gds> lol :)
08:32:50 <gds> Cool.
08:33:14 <int-e> > span even [1..10]
08:33:15 <lambdabot>  ([],[1,2,3,4,5,6,7,8,9,10])
08:33:42 <gds> > break (=='u') "lo nanmu ku cu vimcu"
08:33:43 <Cale> break (<5) [1..10]
08:33:43 <lambdabot>  ("lo nanm","u ku cu vimcu")
08:33:47 <Cale> > break (<5) [1..10]
08:33:48 <lambdabot>  ([],[1,2,3,4,5,6,7,8,9,10])
08:33:58 <Cale> > span (<5) [1..10]
08:33:59 <lambdabot>  ([1,2,3,4],[5,6,7,8,9,10])
08:34:11 <Cale> > break (>5) [1..10]
08:34:12 <lambdabot>  ([1,2,3,4,5],[6,7,8,9,10])
08:34:22 <lokadin> break break (=="ku") "lo nanmu ku cu vimcu"
08:34:26 <gds> > break (=="ku") $ words "lo nanmu ku cu vimcu"
08:34:27 <lambdabot>  (["lo","nanmu"],["ku","cu","vimcu"])
08:34:31 <lokadin> > break break (=="ku") "lo nanmu ku cu vimcu"
08:34:32 <lambdabot>    The function `break' is applied to three arguments,
08:34:32 <lambdabot>   but its type `(a...
08:34:53 * fberthold blinks Lokadin, are you working on a lojban parser?
08:35:03 <gds> > concat $ fst $ break (=="ku") $ words "lo nanmu ku cu vimcu"
08:35:05 <lambdabot>  "lonanmu"
08:35:15 <lokadin> fberthold: sorta
08:35:40 <lokadin> > break (=="ku") "lo nanmu ku cu vimcu"
08:35:40 <lambdabot>  Couldn't match `[Char]' against `Char'
08:35:55 <lokadin> > break (=="ku") $ words "lo nanmu ku cu vimcu"
08:35:56 <lambdabot>  (["lo","nanmu"],["ku","cu","vimcu"])
08:36:05 <lokadin> cool
08:36:06 <gds> @type unwords
08:36:08 <lambdabot> [String] -> String
08:36:15 <lokadin> that should be fine for output
08:36:18 <gds> > unwords $ fst $ break (=="ku") $ words "lo nanmu ku cu vimcu"
08:36:19 <lambdabot>  "lo nanmu"
08:36:24 <lokadin> thanks a lot :)
08:36:27 <gds> > unwords $ snd $ break (=="ku") $ words "lo nanmu ku cu vimcu"
08:36:28 <lambdabot>  "ku cu vimcu"
08:36:31 <gds> np :)
08:41:01 <LordBrain> I have here a library packaged for ghc.. i installed it, it's hscurses.. i want to turn on profiling now, i think i need to recompile it for this.. right?
08:41:19 <LordBrain> i cant find an option in the configure script
08:41:19 <jgrimes> yes
08:41:44 <emertens> let primes = sieve [2..] where sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in primes !! 1000
08:42:02 <emertens> >  let primes = sieve [2..] where sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in primes !! 1000
08:42:03 <lambdabot>  7927
08:42:41 <jgrimes> LordBrain, ./Setup.hs configure -p
08:44:23 <LordBrain> hmmm.. i though it was just wrapped around the usual packaging convention of ./Setup.hs, but i dont see that file now that i'm looking...
08:44:41 <LordBrain> it's just autoconf it seems
08:47:21 <LordBrain> if i have a fairly simple haskell program which uses a huge chunk of CPU, is that a symptom of a space leak?
08:51:53 <musasabi> LordBrain: probably not.
08:52:15 <LordBrain> ok
08:52:22 <wilx`> It's a time-space leak :)
08:52:24 <musasabi> Compiling with -prof -auto-all usually reveals the culprit
08:52:30 <LordBrain> could it be that threadDelay is not nice on my cpu?
08:52:46 <LordBrain> hmm
08:52:53 <Adamant> what are space leaks wrt Haskell?
08:53:31 <qz> how do i write in point-free style "let func2' f g = filter f . map g" ?
08:53:44 <musasabi> Adamant: allocating a huge structure that is not evaluated (if evaluated it would result in small value)
08:54:06 <musasabi> @pl (\f g -> filter f . map g)
08:54:06 <lambdabot> (. map) . (.) . filter
08:54:21 <qz> uh, nasty
08:54:48 <mnislaih> @pl (\x-> if null x then Nothing else Just (f x)
08:54:48 <lambdabot> (line 1, column 45):
08:54:49 <lambdabot> unexpected end of input
08:54:49 <lambdabot> expecting variable, "(", operator or ")"
08:54:56 <mnislaih> @pl (\x-> if null x then Nothing else Just (f x))
08:54:57 <lambdabot> ap (flip if' Nothing . null) (Just . f)
09:02:40 <qz> musasabi, any hints how to do that manually?
09:03:34 <musasabi> transforming things to pointless form?
09:04:09 <qz> musasabi, yeh
09:04:16 <gds> points want to be free :)
09:04:32 <musasabi> intuition or pen and paper. I'm not an expert at liberating points though.
09:05:14 <qz> pen and paper aint helping for me :(
09:05:52 <gds> I got the impression that to "feel the benefit" as it were, you were supposed to think in point free style in the first place...
09:06:01 <gds> function pipelines and whatnot...
09:06:23 <qz> tbh, i see absolutely no benefit
09:06:37 <gds> (with the @pl plugin being a great tool for learning to recognise the patterns of those things)
09:07:25 <gds> qz: I think it's arguable that by thinking in a more point free style, one tends to come up with useful concepts like foldr...
09:07:28 <musasabi> gds: for some things it makes sense. But for HOFs and multiple arguments it gets quite convoluted.
09:08:13 <qz> gds, i'm just trying to do excercises from yaht
09:08:19 <gds> Well, it's not something I've had the intuative flash about yet, certainly.
09:08:28 <gds> So, I'm only speculating.
09:09:01 <Cale> @pl \g -> filter f . map g
09:09:01 <lambdabot> (filter f .) . map
09:09:49 <qz> yeh, experimenting with bot atm also ;)
09:09:51 <musasabi> qz: it might make sense to play with ghci/hugs and see the types
09:10:32 <Cale> You make things as point free as is comfortable
09:10:37 <qz> i'll try. just need to understand why ((filter f .) . map) g is same as filter f . map g
09:11:04 <Cale> It's handy when things have a nice point-free form, and if you can think of it, it's nice to have
09:11:28 <Cale> There are things which require trickery in order to make point-free though.
09:11:40 <Cale> and in those cases, it's usually slightly more questionable
09:12:43 <Cale> You want to end up with something readable that mentions what is important. I think sections of composition (like (filter f .) there) are a little on the hard to read side.
09:14:00 <qz> Cale, like i said i'm just doing exercise ;) there's no way i'm gonna use stuff like that in real world programs
09:14:38 * gds -> train
09:14:42 <gds> l8r:)
09:15:06 <Cale> Certainly. Knowing how to write things in points-free style comes in handy in real programs too though.
09:15:30 <qz> hope this knowledge will come someday :|
09:15:35 <Cale> You have to know how to write things points-free before you can know whether they'd look nicer that way :)
09:15:38 <musasabi> qz: you could probably transform both of them into the exact same pointfull style (that is remove all the points). But it seems tedious and not very much fun
09:16:04 <Cale> no, you'd be adding the points in
09:16:06 <Cale> hehe
09:16:15 <Cale> and removing the composition operators :)
09:16:32 <musasabi> Cale: adding points i.e. removing ascii "points".
09:16:49 <Cale> :)
09:16:52 <musasabi> that is dots.
09:17:03 <Cale> yeah
09:17:28 <musasabi> (in finnish point = piste = dot, so I tend to sometimes forget to use the correct one in non-idiomatic contexts)
09:17:30 <Cale> basically, just expand the definition of (.)
09:18:36 <Cale> ((filter f .) . map) g = (\k -> (filter f .) (map k)) g = (filter f .) (map g) = filter f . map g
09:30:49 <SamB> > -5 `mod` 32 :: Word
09:30:50 <lambdabot>  4294967291
09:31:01 <SamB> hmm...
09:31:20 <SamB> > (-5) `mod` 16 :: Word
09:31:21 <lambdabot>  11
09:31:58 <ihope> > -5 :: Word
09:31:59 <lambdabot>  4294967291
09:32:21 <Cale> > -(5 `mod` 32) :: Word
09:32:22 <lambdabot>  4294967291
09:32:27 <Cale> > (-5) `mod` 32 :: Word
09:32:28 <lambdabot>  27
09:36:53 <LordBrain> > -1 :: Word
09:36:54 <lambdabot>  4294967295
09:37:16 <LordBrain> if that's -1, why not show it as -1?
09:37:29 <LordBrain> Word is both signed and unsigned?
09:37:36 <musasabi> unsigned.
09:37:57 <musasabi> > (-1,-1) :: (Int, Word)
09:37:57 <SamB> Both Word and Int use modular arithmatic, in practice if not in the spec
09:37:58 <lambdabot>  (-1,4294967295)
09:38:24 <int-e> > (2^31, 2^31) :: (Int, Word)
09:38:25 <lambdabot>  (-2147483648,2147483648)
09:39:07 <SamB> + and - act the same
09:39:23 <SamB> I'm not really sure if * does or not
09:39:24 <LordBrain> hmm ok
09:40:11 <SamB> hmm, I don't even think that Word is *in* the spec...
09:40:56 <SamB> division clearly doesn't act the same
09:41:22 <SamB> nor does show or toInteger
09:41:33 <SamB> or whatever its called
09:41:42 <SamB> @hoogle Num a => a -> Integer
09:41:43 <lambdabot> Prelude.floatRadix :: RealFloat a => a -> Integer
09:41:44 <lambdabot> Prelude.toInteger :: Integral a => a -> Integer
09:54:18 <bringert> hi andersca
09:54:19 <lambdabot> bringert: You have 1 new message. '/msg lambdabot @messages' to read it.
09:59:59 <LordBrain> is there something wrong with this commandline?
10:00:02 <LordBrain> $ ghc -v -O -prof -auto-all -package hscurses TryingState.hs -o ball
10:00:25 <LordBrain> i dont see any ./ball when it finishes
10:01:42 <LordBrain> nevermind... the verbose output was hiding stuff from me
10:02:45 <LordBrain> hmmm i have an empty ball.prof
10:08:47 <SamB> > 15 .&. complement 3
10:08:47 <lambdabot>  Add a type signature
10:08:53 <SamB> > 15 .&. complement 3 :: Int
10:08:54 <lambdabot>  12
10:11:39 <LordBrain> cool
10:12:11 <LordBrain> what is .&. ?
10:12:19 <LordBrain> @type (.&.)
10:12:20 <lambdabot> forall a. (Bits a) => a -> a -> a
10:12:24 <int-e> bitwise and, from Data.Bits
10:12:36 <emertens> @type (&)
10:12:37 <lambdabot> Not in scope: `&'
10:17:42 <ihope> > complement 2 + 1 :: Int
10:17:43 <lambdabot>  -2
10:17:48 <ihope> > complement 35 + 1 :: Int
10:17:49 <lambdabot>  -35
10:18:19 <ihope> Two's complement, anyone?
10:22:54 <ihope> > (minBound, complement minBound + 1) :: (Int, Int)
10:22:55 <lambdabot>  (-2147483648,-2147483648)
10:33:17 <ihope> @type let x = minBound; y = x; y :: Int in x
10:33:22 <lambdabot> Int in x :: Int
10:33:38 <ihope> Um.
10:33:48 <ihope> @type let {x = minBound; y = x; y :: Int} in x
10:33:50 <lambdabot> Int} in x :: Int
10:33:58 <zarvok> huh?
10:34:24 <ihope> @type let y :: Int; y = x; x = minBound in x
10:34:25 <lambdabot> Int; y = x; x = minBound in x :: Int
10:34:51 <ihope> Oh, it must be cutting off after the first :: instead of the last one.
10:35:26 <zarvok> hmm
10:35:44 <ihope> What GHC outputs is "let y :: Int; y = x; x = minBound in x :: Int", I think, so lambdabot assumes let y is the expression and Int; y = x; x = minBound in x :: Int is the type.
10:36:03 <zarvok> yeah, must be
10:36:26 <zarvok> probably an easy fix
11:18:30 <vincenz> zarvok: hi
11:19:26 <zarvok> hey vincenz
11:22:36 <sjanssen> I've got a patch that I want to get into the base library, should I just darcs send it to the libraries mailing list?
11:27:48 <sjanssen> or, is there a trac setup for the base library?
11:35:43 <emertens> sjanssen: Aren't the base libraries defined by the Hasekell 98 spec?
11:36:10 <sjanssen> emertens: I'm referring to the base package -- it'
11:36:24 <sjanssen> s a bunch of modules distributed with GHC and Hugs
11:37:20 <sjanssen> all I want to submit is a better version of Control.Monad.filterM
11:38:32 <Cale> It's too hard to contribute to the libraries. Or at least, it was -- are they using darcs fully now?
11:40:19 <sjanssen> Cale: yeah, the base package is a darcs repo
11:42:26 <sjanssen> darcs send wants to send the patch to libraries@haskell.org -- but I'm not so sure I want to do that
11:44:15 <Cale> How is it better?
11:45:26 <sjanssen> less memory use for very sparse filters, able to use GHC's list fusion
11:45:32 <Cale> ah
11:45:51 <Cale> I suppose posting it to the libraries list will work
11:45:54 <LordBrain> if my program is multithreaded with 2 threads.. and i call threadDelay in one thread, and the other is waiting for some blocking IO, does that result in a loop between the threads doing nothing?
11:46:25 <LordBrain> ideally what i'd like to happen is to yield cpu to the OS
11:46:31 <sjanssen> for example filterM (return . const False) will run in constant memory now
11:48:01 <emertens> sjanssen: what is list fusion?
11:48:22 <Cale> LordBrain: I see 0 cpu usage when doing that
11:48:45 <Cale> So it's probably not looping tightly between the two threads
11:48:49 <zarvok> LordBrain: if I recall correctly, threadDelay will not run the delayed thread again until the time is up, so it won't suck up any processor cycles.  So as long as the blocking thread isn't blasting the processor, other OS threads will run
11:48:51 <sjanssen> emertens: GHC is able to get rid of intermediate lists in certain cases
11:48:51 <emertens> blocking calls should block at the OS level
11:48:58 <zarvok> of course, the haskell threads aren't OS threads
11:49:09 <Cale> unless you use forkOS
11:49:23 <LordBrain> no... i used forkIO
11:49:33 <zarvok> yeah
11:49:38 <Cale> right, then you have lightweight threads
11:50:01 <LordBrain> ok well thats good...
11:50:12 <LordBrain> i just dont see why my program uses as much cpu as it does
11:50:21 <LordBrain> maybe i'll post it for you to look at
11:50:24 <LordBrain> its small
11:50:27 <Cale> okay
11:53:06 <lisppaste2> LordBrain pasted "Bouncing Ball with HSCurses" at http://paste.lisp.org/display/23657
11:54:02 <LordBrain> profiling shows showBall uses up most of the time
11:54:10 <LordBrain> well
11:54:30 <LordBrain> thats actually profiling a different program which doesnt link to curses.. i havent figured out hwo to build a profiling version of hscurses yet
11:57:12 <Cale> LordBrain: maybe add some cost centres for each of the lines in showBall
11:57:22 <Cale> and see which is taking all the time
11:57:57 <LordBrain> it's pointless, because the non-hscurses version i can profile is too different
11:58:11 <LordBrain> i need to build hscurses with profiling
11:58:32 <LordBrain> but its all packaged up in an autoconf style
11:59:42 <LordBrain> i notice sometimes the ball freezes for a moment and then continues... i was thinking that was due to garbage collection, but i'm not sure.
12:05:40 <LordBrain> anyway, that little program somehow uses 85-95% CPU
12:07:25 <LordBrain> i can simplify it without the State Monad... i doubt it will make a difference
12:07:54 <musasabi> have you tried profiling?
12:08:15 * musasabi notices the log
12:09:16 <musasabi> LordBrain: like Cale said, try to isolate which of the lines is the reason
12:09:38 <LordBrain> musasabi: i want to.. but i havent figured out how to build a profiling version of the library hscurses
12:10:02 <LordBrain> i built the library using ./configure; make; make install
12:11:14 <LordBrain> it is regular autoconf i think... there's a way to pass in c flags.. not sure if htat would work for sending in ghc profiling flags
12:14:16 <emertens> \ (x,y,_,_) = (x,y) ... guessing const . const . uncurry (,) . curry
12:14:25 <emertens> @pl \ (x,y,_,_) ->(x,y)
12:14:25 <lambdabot> (line 1, column 7):
12:14:25 <lambdabot> unexpected ","
12:14:25 <lambdabot> expecting letter or digit, operator or ")"
12:14:25 <lambdabot> ambiguous use of a non associative operator
12:14:37 <emertens> @pl \(x,y,z,w) ->(x,y)
12:14:38 <lambdabot> (line 1, column 6):
12:14:38 <lambdabot> unexpected ","
12:14:38 <lambdabot> expecting letter or digit, operator or ")"
12:14:38 <lambdabot> ambiguous use of a non associative operator
12:14:52 <emertens> @pl \(x,y,z,w) -> (x,y)
12:14:53 <lambdabot> (line 1, column 6):
12:14:53 <lambdabot> unexpected ","
12:14:53 <lambdabot> expecting letter or digit, operator or ")"
12:14:53 <lambdabot> ambiguous use of a non associative operator
12:14:55 <emertens> :(
12:15:08 <emertens> @pl f (x,y,z,w) = (x,y)
12:15:09 <lambdabot> (line 1, column 13):
12:15:09 <lambdabot> unexpected "="
12:15:09 <lambdabot> expecting variable, "(", operator or end of input
12:15:24 <emertens> what am I doing wrong?
12:15:27 <kpreid> I think @pl doesn't do >2 tuple patterns
12:15:51 <emertens> @type uncurry
12:15:52 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
12:15:56 <emertens> @type curry
12:15:58 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
12:16:08 <emertens> hmm, I suppose that there isn't a curry4?
12:17:21 <sjanssen> @djinn ((a, b, c, d) -> e) -> a -> b -> c -> d -> e
12:17:22 <lambdabot> f a b c d e = a (b, c, d, e)
12:17:39 <emertens> I recognize that one could be created
12:18:16 <LordBrain> what's djinn mean?
12:18:48 <musasabi> It is a theorem prover
12:19:00 <musasabi> @where djinn
12:19:01 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
12:20:17 <musasabi> http://permalink.gmane.org/gmane.comp.lang.haskell.general/12747 has an introduction to it
12:20:19 <lambdabot> Title: gmane.comp.lang.haskell.general
12:23:53 <LordBrain> thanks
12:31:28 <LordBrain> I find the non hscurses version uses about half the cpu
12:31:48 <LordBrain> still seems like a lot
12:38:28 <dropdrive> I once came across a paper about speeding up the calculation of the dot product from 300 times slower than C to 4-5 times slower (I think).  I've forgotten where I saw this paper; does anyone here know?
12:41:00 <musasabi> Maybe? http://www.cse.unsw.edu.au/~chak/papers/CK01.html
12:41:00 <lambdabot> Title: Research Papers of Manuel Chakravarty
12:43:40 <pstickne> is there a Prelude factorial?
12:44:13 <emertens> it is commonly defined as fac n = product [1..n]  "using the Prelude"
12:44:30 <musasabi> Chakravarty has other related papers like http://www.cse.unsw.edu.au/~chak/papers/CK03.html
12:44:31 <lambdabot> Title: Research Papers of Manuel Chakravarty
13:14:59 <emertens> I'm reading the History ofHaskell paper
13:15:52 <emertens> and it's weird to hear Dijkstra quoted at an event
13:16:07 <emertens> when I think of him only has some ancient figure who left me with his MST algorithm
13:16:20 <emertens> only as a name, not an actual person
13:19:10 <monochrom> http://www.cs.utexas.edu/users/EWD/
13:19:11 <lambdabot> Title: E.W.Dijkstra Archive: Home page
13:30:23 * edwardk waves hello.
13:30:31 <vininim> hi
13:32:14 <edwardk> the only problem i have with haddock is that it seems to choke on template haskell code.
13:32:17 <edwardk> =
13:32:20 <edwardk> er =/
13:32:40 <musasabi> edwardk: #ifndef __HADDOCK__
13:32:45 <vininim> not eqaull what?
13:32:51 <edwardk> ah
13:32:53 <vininim> *equall
13:32:54 <edwardk> good
13:33:03 <edwardk> i can fix my hex stuff then
13:33:33 <musasabi> (+ remember -cpp in foo.cabal/Makefile)
13:33:48 <edwardk> yeah
13:34:04 <edwardk> kinda ugly though, since i use about 80% of my code as splices
13:34:10 <edwardk> fitting it in now
13:36:39 <edwardk> hrmm ./Setup.lhs haddock seems to choke on the #ifndef __HADDOCK__
13:36:54 <edwardk> ghc-options:            -Wall -O -funbox-strict-fields -cpp
13:40:33 <musasabi> edwardk: you need it for haddock too
13:40:49 <edwardk> whats the cabal opt for that? haddock-options yelled at me
13:41:11 <musasabi> and use "extensions:          CPP" rather than ghc-options
13:42:08 <edwardk> kk
13:42:32 <edwardk> ah yeah forgot. was doing that right with all the others
13:43:19 <edwardk> nifty keen
13:43:20 <edwardk> it works
13:46:09 <dropdrive> musasabi: Thanks for the link.  That was it.
13:47:06 <edwardk> http://slipwave.info/jugs/dist/doc/html/Type-Hex.html is now as complete as haddock can make it
13:47:43 <edwardk> now i just need to bite the bullet and write the hex multiplier
13:49:33 <SamB> ack
13:49:39 <SamB> this balance stuff is insane
13:49:43 <edwardk> heh
13:49:46 <edwardk> still playing with it?
13:49:49 <SamB> yes
13:50:11 <SamB> I was going to try and do some kind of evolutionary algorithm, but haven't a clue how to go about it...
13:51:11 <musasabi> edwardk: you might want to package it when you are ready so people don't have to reinvent the wheel (which results usually in a buggy peano implementation)
13:51:14 * SamB might have managed to bruteforce the swapreg2 program...
13:51:34 <SamB> I have no idea how to do conditionals
13:51:40 <edwardk> look at lilgp or something
13:51:49 <edwardk> or ecj
13:51:58 <edwardk> either is good for a quick evolutionary hackjob
13:57:50 <stepcut> hrm, I need, Data.ByteString.Float
13:58:14 <SamB> ?????
13:58:22 <emertens> that doesn't really mke sense, does it
13:59:41 <edwardk> so when are you guys going to generalize Data.ByteString to Data.UnboxedString or something? =)
14:00:39 <SamB> edwardk: lilgp doesn't sound like it will work too well with balance programs...
14:00:53 <stepcut> emertens: well, the name is not great, but the funtionality would be :)
14:01:07 <edwardk> haven't really looked at balance
14:01:25 <stepcut> not everything in .Char8 makes sense for Floats, but most of it is just very fast, unboxed, immutable array stuff -- which could be very useful
14:01:32 <SamB> it is a bytecode with a modular instruction pointer...
14:01:41 <edwardk> step: yeah, hence the unboxedstring concept.
14:01:45 <SamB> and variable instruction speed, too!
14:01:51 <edwardk> heh
14:01:58 <stepcut> edwardk: right
14:02:08 <edwardk> trying to think of the name of the other project more suitable to bytecode languages
14:02:15 <SamB> in fact, I think that is the only way to do anything conditional...
14:02:29 <sjanssen> edwardk: you mean a version of ByteString that contain different types of elements?
14:02:41 <sjanssen> s/contain/can contain
14:02:47 <edwardk> all my gp/ai books are downstairs, one sec
14:02:54 <edwardk> sjanssen: yeah
14:03:28 <sjanssen> I'm working on something like that for my SoC project . . . hopefully I'll be done soon
14:03:42 <sjanssen> especially since the deadline is really close ;)
14:05:13 <edwardk> heh
14:05:21 <edwardk> how is data.rope coming along anyways?
14:05:56 <edwardk> 'AIMGP' was the other representation i was thinking about
14:06:05 <edwardk> its a bytecode oriented GP interface
14:06:08 <sjanssen> it's okay, but it might remain in a slightly crappy state for a little while, I've just run out of time
14:06:14 <SamB> hmm
14:06:14 <edwardk> more suitable to manipulating other languages more or less
14:06:22 <edwardk> doh
14:06:32 <edwardk> how crappy is crappy?
14:06:50 <edwardk> i was thinking about writing one, but saw you were working on it, so froze until could see it
14:07:38 * SamB needs to work on radiating more cluelessnes when appropriate
14:10:07 <sjanssen> edwardk: actually, reviewing the code it looks okay.  It's just a fingertree (of the Paterson and Hinze variety) wrapped around another string representation (most likely ByteString)
14:10:24 <edwardk> ah
14:10:31 <edwardk> so no collapsing of state as you run?
14:10:43 <sjanssen> collapsing of state?
14:10:49 <edwardk> er collapsing of strings
14:11:00 <sjanssen> no, none of that
14:11:00 <edwardk> usually a rope/cord can join strings over time
14:11:22 <edwardk> and just try to maintain 'good enough' access times without provable bounds.
14:11:26 <sjanssen> that's really the only thing that's missing
14:11:36 <edwardk> thats the piece i was looking for =)
14:12:01 <edwardk> sok
14:12:05 <edwardk> i'll figure it out
14:12:23 <edwardk> wasn't there already some sort of fingertree code hiding in pugs
14:12:25 <edwardk> ?
14:12:59 <sjanssen> edwardk: if the code I have provides a useful base, please use it.  Perhaps we can collaborate
14:13:41 <edwardk> sounds like a plan. i'll take a look at it when my obsession with template haskell generated instances fades... probably sometime this weekend ;)
14:13:43 <sjanssen> edwardk: I believe the fingertree code is adapted from Hinze/Paterson's data structure
14:13:54 * edwardk nods.
14:40:34 <LordBrain> hmmm does ghc's garbage collector use a lot of cpu?
14:42:12 <sjanssen> LordBrain: ideally, no
14:42:21 <sjanssen> does your program generate a lot of garbage?
14:43:17 <emertens> heh, what do you mean by "ideal, no" ... ideally, no garbage collector uses much CPU :)
14:47:15 <LordBrain> hehehe
14:47:25 <LordBrain> yeah, my program delivers an infinite amount of garbage
14:52:34 <pstickne> wow.
14:53:44 <LordBrain> assuming you run it for an infinite amount of time
14:54:20 <LordBrain> at least i think it does.. unless some clever memoizing is tripping up my thinking
14:55:12 <LordBrain> it is iterating over an infinite list... until you press a key which it catches in another thread
14:56:45 <LordBrain> this is the program
14:56:48 <LordBrain> LordBrain pasted "Bouncing Ball with HSCurses" at
14:56:48 <LordBrain>                      http://paste.lisp.org/display/23657
14:57:11 <LordBrain> if you figure out how to cut down its cpu usage, send me a message... i assume lamdabot can do that
14:57:21 <LordBrain> i have to go now
15:09:27 <pstickne> @currey (a . y) 1
15:09:27 <lambdabot> Unknown command, try @list
15:09:48 <benja_> @curry (a . y) 1
15:10:19 <benja_> @schoenfinkel (a . y) 1
15:10:38 <pstickne> lambdabot is throttled feeding my @list :(
15:10:51 <lambdabot> Unknown command, try @list
15:10:55 <lambdabot> Unknown command, try @list
15:11:24 <kpreid> pstickne: what do you want to do?
15:11:27 <benja_> what're you trying to do anyway? :)
15:11:47 <pstickne> benja_, see that rewritten without the .
15:12:07 <benja_> a (y 1) :-)
15:12:11 <kpreid> ah, the nonexistent @pointful
15:12:17 <kpreid> or not
15:12:19 <pstickne> or something that will take $ and . shortcuts and turn them into the long way with parens, so I can groc :x
15:12:35 <kpreid> $ is easy
15:12:42 <kpreid> ... $ ... -> (...) (...)
15:12:55 <pstickne> ... $ ... $ ... -> ?
15:13:03 <benja_> ... (... (...))
15:13:26 <kpreid> (... . ...) ... -> ... (... ...)
15:13:44 <benja_> this is getting too dotty :)
15:13:48 <kpreid> pstickne: it might be easier to learn . and $ :-)
15:14:09 <pstickne> kpreid, ohh, no, I just wanted to see them unrolled to learn them :)
15:14:41 <benja_> (f . g) x = f (g x)
15:15:08 <benja_> think of it as feeding x first through g and then the result through f :-)
15:16:20 <benja_> ignore this, but . is usually written as a centered circle in math, whereas $ is usually written as a big dot .)
15:16:36 <benja_> (but the dot is not an operator, it's special syntax)
15:17:00 <pstickne> putStrLn $ (show x) ++ " -> " ++ (show (myfac x))  -- what I have but it ... doesn't look right
15:17:10 <pstickne> I mean, it does what I expect but
15:17:26 <benja_> it's fine :)
15:17:34 <benja_> you can lose the parens around the function calls
15:17:41 <pstickne> but then it breaks
15:17:45 <benja_> putStrLn $ show x ++ " -> " ++ show (myfac x)
15:17:50 <benja_> really?
15:17:57 <SamB> not myfac call, but the others yes
15:18:21 <pstickne> okay, leaving them in around myfac works.
15:18:27 <benja_> :)
15:18:28 <pstickne> why don't I need them about say, show x?
15:18:42 <benja_> because the operator binds more weakly than function application
15:18:52 <SamB> exactly what I was going to say
15:18:58 <benja_> you need to say show (2 * 3) for example
15:19:03 <pstickne> is there an online order of precendence chart?
15:19:07 <SamB> heh
15:19:10 <SamB> chart?
15:19:20 <pstickne> like the one found in perlop? :)
15:19:25 <benja_> pstickne: I don't know any...
15:19:29 <SamB> you need to look at the documentation and/or interactive queries
15:19:33 <benja_> but I'm a novice in many ways :)
15:19:36 <SamB> or read source
15:19:45 <SamB> source tells fixity and precedence
15:19:49 <SamB> so does :i
15:20:00 <benja_> infixl/r declarations in the Haskell report prelude :)
15:20:01 <pstickne> SamB, like * is given precedence over -, etc
15:20:10 <benja_> :i *
15:20:23 <pstickne> SamB, do all function applications have higher precedence then any operator?
15:20:31 <benja_> oh, not heHugs.Base> :i *
15:20:31 <benja_> infixl 7 *
15:20:35 <SamB> pstickne: yeah
15:20:42 <benja_> Hugs.Base> :i -
15:20:43 <benja_> infixl 6 -
15:20:49 <SamB> bind tighter, anyway...
15:20:56 <benja_> so * binds more strongly than -
15:20:56 <SamB> Prelude> :i *
15:20:56 <SamB> class (Eq a, Show a) => Num a where
15:20:56 <SamB>   ...
15:20:56 <SamB>   (*) :: a -> a -> a
15:20:56 <SamB>   ...
15:20:57 <SamB>         -- Imported from GHC.Num
15:20:58 <pstickne> (+) 1 2         is a function application of + instead of + as an operator?
15:20:59 <SamB> infixl 7 *
15:21:13 <SamB> yeah
15:21:41 <pstickne> so precendence can be defined on the fly?
15:21:58 <SamB> sort of
15:22:10 <SamB> you have to define it in the same module as the function
15:22:30 <SamB> (or be content with the default)
15:23:16 <pstickne> default is fine. that's almost like $[ in perl O.o
15:23:34 <pstickne> (change base-index of an array)
15:24:05 <pstickne> @paste
15:24:06 <lambdabot> http://paste.lisp.org/new/haskell
15:25:00 <pstickne> I wish that supported haskell colorizations :x
15:25:36 <benja_> hm, can I have a module declaring a datatype and importing a different module which uses that datatype?
15:25:47 <benja_> (and imports the first module, of course)
15:26:14 <benja_> [the module which declares the datatype is autogenerated]
15:26:20 <lisppaste2> pstickne pasted "uck" at http://paste.lisp.org/display/23669
15:28:04 <kpreid> pstickne: unlike $[, precedence is known fully at compile time
15:28:58 <pstickne> kpk, still a good way for confusing someone who hasn't see said operation :)
15:29:00 <kpreid> pstickne: showFactorials = mapM_ showFactorial
15:29:10 <pstickne> what is mapM_?
15:29:15 <kpreid> @type mapM_
15:29:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
15:29:29 <pstickne> M_ says it's a monad?
15:29:34 <pstickne> (convention?)
15:29:39 <kpreid> takes a function from values to actions, and a list of those values, and executes them all
15:29:51 <kpreid> the actions that result from each value, that is
15:30:02 <kpreid> "M" means it's a monad operation (not all are so marked)
15:30:17 <kpreid> "_" means that it does not return a list, as opposed to the unmarked variant which does
15:31:01 <kpreid> mapM_ f xs == sequence_ (map f xs). sequence takes a list of actions and executes them in that order
15:31:32 <kpreid> anyway, your showFactorials is essentially a definition of mapM with the function hardcoded
15:31:38 <kpreid> er, mapM_
15:32:06 <kpreid> also, instead of putStr "", the usual 'nothing' action is 'return ()'
15:32:19 <pstickne> kpreid, I know, I tried using map but that didn't work well :)
15:32:35 <pstickne> kpreid, I was getting errors about [] and IO :X
15:32:44 <pstickne> kpreid, if it didn't return an IO
15:33:08 <kpreid> right, mapM is appropriate here
15:33:10 <kpreid> yes. understand them.
15:33:13 <kpreid> an action is not a list of actions
15:33:15 <kpreid> er, nor the other way around
15:33:21 <edwardk> is there a concatMapM?
15:33:51 <edwardk> ?hoogle concatMapM
15:33:52 <lambdabot> No matches found
15:33:55 <edwardk> hrmm
15:34:00 <kpreid> edwardk: doesn't really make sense
15:34:10 <kpreid> concatMap requires the function results to be lists
15:34:39 <kpreid> well, actually, (join . mapM) makes sense
15:34:50 <pstickne> kpreid, I don't understand the error though as I was not using the return value of showFactorials for anything :(
15:34:56 <kpreid> @type concatMap
15:34:57 <kpreid> @type join . mapM
15:34:58 <lambdabot> forall b a. (a -> [b]) -> [a] -> [b]
15:34:59 <lambdabot> forall a b. (a -> [a] -> b) -> [a] -> [b]
15:35:15 <kpreid> pstickne: sure you were. you were making it the value of main
15:35:17 <edwardk> hrmm
15:35:23 <kpreid> er, that doesn't work.
15:35:35 <kpreid> @type \f xs -> join (mapM f xs)
15:35:37 <lambdabot> forall b a. (a -> [b]) -> [a] -> [b]
15:35:54 <kpreid> @type join
15:35:55 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
15:36:23 <kpreid> not what I had in mind. oh well
15:36:32 <pstickne> kpreid, ohh!
15:36:40 <pstickne> kpreid, that's sneaky.
15:36:50 <kpreid> pstickne: remember, showFactorials returns an action
15:36:54 <edwardk> right now what i have is a list of terms that i am using to generate instances via template haskell. the terms are all of type TypeQ (really Q Type], and are mapped to a list of DecQ's (really Q Dec) through a function i call using mapM
15:37:11 <edwardk> that list of Dec Q's is correctly interpreted by template haskell as a list of declarations and run
15:37:26 <pstickne> kpreid, action <-> monad?
15:37:45 <edwardk> now i want to wrap another layer around that construction process, so i can generate all 3 of my shifters at once.
15:37:51 <edwardk> since they all share the same plumbing
15:38:04 <edwardk> hrmm
15:38:05 <edwardk> heh
15:38:08 <kpreid> pstickne: well, 'action' is really only applicable to IO
15:38:10 <kpreid> and it's types that are or aren't actions
15:38:11 <edwardk> why don't i just concat then
15:38:13 <kpreid> er, are or aren't monads
15:38:15 <kpreid> action == value of type IO a
15:38:15 <edwardk> no monad involved =)
15:38:19 <SamB> oh cool
15:38:19 <edwardk> nevermind =)
15:38:30 <musasabi> edwardk: concatMapM is very usefull, but one has to define it by hand.
15:38:44 <SamB> I've figured out how to actually do something once and loop after that...
15:39:55 <musasabi> concatMapM f = liftM concat . mapM f
15:41:33 <SamB> (in balance)
15:43:50 <edwardk> thans musasabi
15:45:29 <SamB> of course, I still haven't a clue how to actually make use of this knowledge...
15:46:32 * edwardk tests the limits of how many instances template haskell will let  me make
15:50:27 <edwardk> heh maybe i should rethink having shr3 and just combine shr1 and shr2 to get it. it'll probably compile a lot faster =/
15:50:42 <edwardk> its the bulk of 4032 cases =/
15:51:29 <edwardk> *Type.Hex.Stage3> t8np1 $(hexE 1123901230)
15:51:29 <edwardk> $(hexE 8991209841)
15:51:30 <edwardk> woot
15:51:33 <edwardk> it compiles thx folks =)
15:52:11 <edwardk> (flip concatMapM) [(shr1,8,2),(shr2,4,4),(shr3,2,8)] $ \(shr,m1,m2) -> ... removed 3 large chunks of very similar code.
15:53:09 <pstickne> @type head . tail
15:53:10 <lambdabot> forall a. [a] -> a
15:53:18 <pstickne> How does that work?
15:53:30 <pstickne> ohh.
15:53:31 <pstickne> Nvm.
15:53:33 <edwardk> heh
15:57:42 <pstickne> a type is of a class if it supports all functions of that class?
15:58:09 <edwardk> you have to define an instance of the class that refers to the type
15:58:51 <edwardk> if you have class Foo a;   then you can write instance Foo Bar; to make type Bar fill in for a in the class specification
15:59:58 <edwardk> since you can have mptc's that relate multiple type, its really hard to motivate saying that as a type is 'of a class', but i think thats what you want
16:00:46 <edwardk> whats the command to show an interface file in ghc?
16:01:06 <edwardk> whee
16:01:13 <edwardk> i generate a 2 meg interface file for stage3 now =)
16:01:14 <monochrom> As a first-order understanding, it's alright to say "a type is of a class".
16:01:18 <edwardk> yeah
16:02:54 <musasabi> edwardk: how large are the .o files? And could you try optimizing and living with fewer instances?
16:03:00 <edwardk> 2 megs
16:03:16 <edwardk> i can dump the 3-shifter and get by combining the 1-shifter and 2-shifter
16:03:22 <edwardk> but it was a clean generalization the other way
16:03:34 <edwardk> i could even dump the 2-shifter, but it'll make multiplication slower
16:03:39 <edwardk> its a time/space tradeoff
16:03:54 <musasabi> edwardk: a current limitation of GHC is that the app needs to link with the TH code thus +2mb for app sizes. (of course there are hacks to avoid this, but nothing integrated)
16:04:32 <edwardk> well that was the .hi and .o's sizes. the earlier stages had more reasonable 132k/275k .hi's and .o's
16:04:51 <edwardk> i'm mostly abusing template haskell to generate instances
16:05:05 <edwardk> coz there ain't no way i'm typing em by hand, and its a clean 'in-haskell' solution
16:05:11 <SamB> musasabi: I expect that splitting objects will allow leaving out TH libs?
16:05:32 <SamB> why is TH 2mb anyway?
16:05:45 <SamB> just for the libraries?
16:06:05 <musasabi> SamB: not TH, but if edwardk's code is then it will be linked even if most of it is just for compiletime.
16:06:18 <edwardk> yeah ouch
16:06:42 <SamB> huh?
16:06:42 <edwardk> here have 4 megs of bloat because you wanted to dependently type the size of that array =)
16:06:54 <SamB> could you say that again?
16:07:14 <musasabi> SamB: split-obj might work. The last time I tried to avoid TH Cabal didn't support it so didn't try that.
16:07:16 <edwardk> hrmm. without the 3-shifter the .hi and .o files drop to half their size
16:07:23 <edwardk> but then the multiplier becomess more complicated later
16:08:23 * edwardk tries without the 2-shifter
16:08:41 <edwardk> the space usage is somewhat entangled with the fact that the adder is in the same module
16:09:12 <edwardk> half-again reduction, takes it down to 470k and 646k for .hi and .o
16:09:23 <edwardk> i think i'll just make multiplication slow
16:09:39 <edwardk> and write a simple least significant bit extractor to build the peasant multiplier over
16:09:45 <SamB> so what does the .o file do?
16:10:05 <edwardk> it means it'll have to churn the insides of the number representation a lot mmore though
16:10:21 <SamB> so, slower compiles
16:10:35 <edwardk> yeah, slower compiles if you use multiplication a lot
16:10:53 <edwardk> but i think youd have to use it a LOT because the higher stage shifters are REALLY slow to compile
16:11:35 <SamB> so what makes the .o file so big?
16:11:38 <musasabi> SamB: depends. Huge .hi-files slow things also. Depends on how much it is used.
16:11:49 <SamB> I wouldn't think the .o file would have to do much of anything
16:12:38 <evilping> Hi everyone, newbie to haskell, used Ruby & a bit of on  lisp, having trouble with '=' on ghc on OSX, wonder if anyone could tell me where I'm going wrong?
16:12:39 <edwardk> with just a stage1 shifter i can compile it in 21s, witing for stage2 for speed comparison now
16:13:02 <edwardk> evilping: whats the problem?
16:13:28 <edwardk> 44s for stage2
16:13:35 <edwardk> guessing 88 or so for stage3, checking
16:13:58 <evilping> I put this into ghci, module Main where
16:13:58 <evilping> main = putStrLn "Hello World"
16:14:04 <evilping> and i get this
16:14:05 <evilping> parse error on input `='
16:14:33 <evilping> it's from the wiki, Haskell in 5 easy steps
16:14:34 <edwardk> is that in a source file or are you typing that in at the prompt?
16:14:50 <evilping> thats what I get from the prompt
16:14:56 <evilping> compiling source craps out
16:15:08 <SamB> did you type the source in or type :l foo.hs?
16:15:41 <evilping> saved source to hello.hs
16:16:03 <evilping> then did ghc hello.hs -o hello
16:16:20 <edwardk> ouch 2 minutes+ for all 3 shifters =/
16:16:22 <SamB> mmmhmm?
16:16:23 <evilping> got this back
16:16:45 <evilping> tmp/ghc18945.s:230:Unknown pseudo-op: .subsections_via_symbols
16:16:59 <swiert_> evilping: MacOS on an intel mac?
16:17:03 <stepcut> evilping: what version of gcc ?
16:17:08 <evilping> ppc
16:17:21 <evilping> gcc 3.3
16:17:37 <evilping> OSX 10.3
16:17:43 <swiert_> evilping: which ghc version/how did you install it?
16:18:07 <evilping> binary .pkg ghc 6.4.1
16:18:20 <stepcut> coincidently I think that error is coming from the part of ghc knows as the 'evil mangler'
16:18:36 <evilping> sounds lovely
16:18:56 <pstickne> <- is only for IO actions?
16:19:11 <edwardk> <- is for any monad inside the do sugar
16:19:14 <musasabi> pstickne: any monadic.
16:19:14 <sieni> pstickne: it works on arbitrary monads
16:19:26 <pstickne> hehe, thanks
16:19:54 <swiert_> evilping: yet ghci works fine?
16:19:56 <musasabi> evilping: you are writing that to a source file and then using it as "ghci foo.hs" ?
16:20:08 <evilping> no
16:20:32 <evilping> ghc hello.hs -o hello
16:21:06 <musasabi> that should work too.
16:21:13 <evilping> i know
16:21:51 <evilping> but craps out anytime the '=' symbol is used
16:22:30 <evilping> i.e.  simple x y z = x * (y + z)
16:22:44 <evilping> returns  parse error on input `='
16:22:46 <swiert_> evilping: try "let main = putStr "hi" "
16:22:59 <swiert_> at the ghci prompt.
16:23:12 * edwardk wonders if he should mangle his hex implementation into an octal one
16:23:22 <edwardk> would have better combinatorial explosion properties
16:23:37 <edwardk> should compile 4x faster and generate numbers up to 2^60th
16:23:54 <edwardk> not the same as 2^80th, but we can't use those really anyways
16:24:03 <musasabi> 2^60 sounds good enough
16:24:06 <edwardk> not at the type level
16:24:55 * edwardk sighs
16:25:07 <evilping> swiert_so use let instead of '='?
16:25:10 <edwardk> its a lot less mnemonic though
16:26:41 <swiert_> evilping: Well, in source files you write "inc x = x + 1". From the prompt you need to write "let inc ..." otherwise it thinks you're trying to evaluate a funny expression.
16:27:32 <evilping> ah i see, thanks
16:28:07 <evilping> let is defining a function
16:28:09 <edwardk> basically at the prompt you are inside of an "IO monad", like you would be on lines inside of main = do\n...
16:28:19 <evilping> ok
16:28:32 <edwardk> you can use let foo = bar as a statement in that context
16:28:55 <edwardk> but "foo = bar" itself isn't a valid statement, coz you aren't in a top level context.
16:29:08 <edwardk> its like you are inside of an IO function writing a function body
16:29:11 <edwardk> when you work at the prompt
16:30:17 <evilping> whats the symbol for a 1 line comment?
16:30:25 <edwardk> --
16:30:28 <evilping> cheers
16:30:57 <swiert_> edwardk: not quite. In a do expression in the IO monad all you statements need to have type IO a.
16:31:12 <swiert_> At the prompt, you can also evaluate pure functions.
16:32:03 <evilping> and is indentation important in source files (for the compiler)
16:32:19 <kpreid> because they get rewritten as print <what-you-typed>
16:32:36 <kpreid> evilping: yes, if you don't use explicit {;;}
16:36:08 <Jormunder> Hi all
16:37:32 <Jormunder> Ive got a question
16:38:00 <musasabi> Feel free to ask.
16:38:03 <Jormunder> main = forkIO (loop 'a') >> (loop 'b')
16:38:32 <Jormunder> i call this program with +RTS -C2
16:39:14 <Jormunder> but after 2 context switches, all go wrong and the program print ababababababa
16:39:32 <Jormunder> what are wrong?
16:39:34 <musasabi> how is loop defined and why is it wrong?
16:40:02 <Jormunder> loop c = hPutChar stdout c >> loop c
16:41:07 <SamB> its supposed to maybe do that
16:41:18 <Jormunder> --C<secs>  ------> Context-switch interval in seconds
16:41:20 <musasabi> isn't something like "aabbabababaaaaaaaaabbabababababa" more or less what it is supposed to print?
16:41:38 <SamB> oh, that, you are depending on the context never switching more often how?
16:41:59 <Jormunder> when I invoke , print....
16:42:02 <Jormunder> aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa......aaaaaaaaa
16:42:09 <Jormunder> bbbbbbbbbbbbbbbbbbb.bbbbbbbbbbbbb
16:42:17 <Jormunder> and later abababababababa
16:43:05 <Jormunder> one context swith per hPutChar, not in 2 seconds
16:43:40 <musasabi> hPutChar can cause a context switch
16:43:49 <Jormunder> mmmm, ok
16:44:06 <Jormunder> something like a buffer dump?
16:44:14 <Jormunder> flush?
16:45:15 <musasabi> (do you want the involved hypothesis what goes on inside the sheduler?)
16:45:52 <evilping> swiert_ I found out why it wasn't compiling, I have XCode 1.1, it depends on XCode 1.5, I did a verbose compile & the error was coming from gcc not ghc
16:46:03 <xerox-> Hi :-)
16:46:48 <swiert_> evilping: ah. That would explain it. Have fun downloading XCode.
16:46:53 <evilping> at least ghc 6.4
16:47:43 <evilping> oh ja, real fun, thanks for the help
16:48:26 <evilping> cant wait to get a working version of this running
16:58:19 * xerox- has been taken over by Lemmih.
17:00:22 <yip> the man is here?
17:05:53 <xerox-> The man?
17:08:15 * xerox- returns to non-lemmih control.
17:08:41 <yip> the L-man
17:09:53 * xerox- has been taken over by dcoutts
17:10:02 <xerox-> yip: the L-man?
17:10:16 <yip> the lem-ster
17:11:21 <xerox-> arr, he's here
17:11:47 <yip> please inform him that i request his presence
17:11:53 <LordBrain> does anyone have an example of an animated haskell program which does not use an inordinate amount of cpu?
17:12:11 <yip> what do you mean?
17:12:12 <xerox-> thare's xerox, Lemmih and shapr on the foor here in my (dcoutt's) house in Cambridge
17:12:28 <xerox-> foor/floor
17:12:40 <xerox-> yip: I shall summon him for you...
17:12:55 <LordBrain> i mean a program which loops infinitely, updating positions of things on the screen, like a videogame
17:13:22 * xerox- has been taken over by Lemmih.
17:13:34 <yip> LordBrain: i've done a tetris game with yampa. i've done an interactive 3d car physics simulation with opengl. i've done a gameboy emulator
17:13:35 <LordBrain> are you room mates or something?
17:13:51 <LordBrain> yip, have you watched the cpu usage?
17:13:52 <yip> xerox: um... Lemmih?
17:14:01 <xerox-> yeah?
17:14:42 <LordBrain> yampa's example program uses more cpu than i'd settle for... and so do very simple programs i make...
17:14:59 <yip> lokadin: yeah, my gameboy emulator maxed out the cpu usage and still did not get to real-time speed. needs a lot more optimization. tetris and car sim were programmed to use max cpu usage, since that's how games usually work
17:15:35 <LordBrain> things which dont involve yampa.. it seems its easy in this sort of genre to use a lot of cpu.. and i'm looking for the secret if there is one to not doing that.
17:15:45 <yip> LordBrain: yampa intentionally sucks up all available cpu usage it can get. if you want to use less, you can inject a sleep in your output IO action
17:16:11 <LordBrain> oh
17:16:11 <LordBrain> ok
17:16:22 <LordBrain> by sleep, do you mean threadDelay?
17:16:27 <yip> that might work
17:16:38 <xerox-> yip: You requested my presence?
17:16:41 <LordBrain> see, i have a very simple non-yampa animation
17:17:08 <yip> xerox: hi, um... if you are Lemmih: any thing new with hIDE?
17:17:22 <LordBrain> that uses a lot of cpu, and i don't understand why it should... its just a ball bouncing around inside a 2d box.
17:18:02 <yip> LordBrain: in any programming language animation is very often done with a "main loop". this is how it's done with yampa also
17:18:15 <LordBrain> hmmmm
17:18:47 <yip> the other approach is to use something like gtk with timer events
17:18:47 <xerox-> yip: No, still no news. I talked to SM about the plugin architecture, though.
17:18:49 <LordBrain> well... my c programs use up considerably less cpu... i'm just spoiled
17:19:17 <yip> LordBrain: if you have a c program that does while(!done) { get_input(); simulate(); render(); } then it will also take 100% cpu
17:19:29 <LordBrain> yeah, but i dont do it that way..
17:19:36 <yip> how do you do it?
17:19:50 <yip> xerox: who is SM?
17:20:08 <xerox-> yip: (or well, I tried to explain what I had done in my rather poor English)
17:20:11 <LordBrain> i yield to the os time i dont need
17:20:23 <xerox-> yip: Simon Marlow. One of the key developers of GHC.
17:20:37 <yip> xerox: oh, nice. does he ever come to this channel? :D
17:20:50 <xerox-> @seen simonpj
17:20:51 <lambdabot> I saw simonpj leaving #haskell 22 days, 8 hours, 4 minutes and 35 seconds ago, and .
17:21:09 <xerox-> Oops, wrong simon.
17:21:11 <LordBrain> wrong simon
17:21:12 <LordBrain> heh
17:21:16 <xerox-> @seen JaffaCake
17:21:16 <lambdabot> I saw JaffaCake leaving #haskell 2 days, 19 hours, 46 minutes and 3 seconds ago, and .
17:21:22 <yip> LordBrain: well, you should be able to do the same thing in haskell, with or without yampa. threadDelay might indeed be the trick
17:21:40 <LordBrain> ok... but i'm missing something, because i have threadDelay
17:21:56 * xerox- also met Simon PJ and lots of other cool Haskellers.
17:21:58 <yip> maybe threadDelay isn't the right one then :/
17:22:23 <LordBrain> well Cale said threadDelay worked for him
17:22:41 <LordBrain> so i dont know
17:23:05 <LordBrain> i'll try delaying longer
17:23:05 * xerox- will retire to make his bed.
17:23:47 <LordBrain> hmm doesnt seem to be helping
17:23:51 <Cale> LordBrain: what platform are you on?
17:24:04 <Cale> It might be an OS-dependent thing
17:24:12 <Cale> I'm running Debian
17:24:41 <LordBrain> i'm also running Debian
17:25:25 <LordBrain> threadDelay does indeed make a difference if i push it long enough
17:25:51 <xerox-> Hey Cale
17:26:41 <LordBrain> I've gotten it to stay under 30% now
17:28:52 <Cale> LordBrain: I haven't gotten threadDelay to take any CPU. How long are you delaying for each time? Are you calling threadDelay repeatedly?
17:29:24 <LordBrain> yes
17:29:27 <LordBrain> repeatedly
17:29:35 <Cale> how often?
17:29:43 <LordBrain> everytime it updates the position of the ball on the screen
17:29:59 <Cale> how long is the delay set to?
17:30:20 <LordBrain> well i've pushed it up to 40000
17:30:24 <LordBrain> it was lower
17:31:10 <Cale> okay, doing that in a tight loop will chew up CPU
17:31:19 <LordBrain> hmmm
17:31:20 <Cale> at least, a bit of CPU
17:31:27 <LordBrain> i'
17:31:30 <Cale> Usually threadDelay is for longer delays
17:31:32 <LordBrain> i'm not sure what my alternative is
17:31:38 <LordBrain> hmmm
17:31:39 <LordBrain> ok
17:31:48 <Cale> Why are you delaying for such a short time?
17:31:48 <LordBrain> thats sounds like something good to remember
17:32:16 <LordBrain> well, 2 reasons... to slow the ball down, and to yield cpu
17:32:45 <Cale> well, there's yield
17:33:43 <Cale> To control the speed of the ball, I'd probably recommend using an actual measure of time, and controlling the position based on that.
17:34:20 <LordBrain> oh
17:34:24 <LordBrain> yampa style eh?
17:34:34 <LordBrain> well...
17:35:00 <LordBrain> that would overly complicate the program i think
17:35:03 <Cale> getClockTime will give you a value of the form TOD Integer Integer, where the first integer is the number of seconds since the start of 1970, and the second is an additional number of picoseconds.
17:35:07 <LordBrain> its for a tutorial after all
17:35:28 <LordBrain> detecting when to bounce would be complicated in such a scheme
17:35:49 <Cale> hmm
17:36:14 <Cale> You'd probably either precompute it, or check for intersections when you move the ball.
17:37:06 <LordBrain> yeah but its a bit complex, because the balls next position would depend on how much time went by etc
17:37:31 <LordBrain> this way the only thing which determines the next position is the present one
17:37:38 <Cale> d = d_0 + v * t
17:37:45 <LordBrain> and the dx and dy of course
17:37:45 <yip> Cale: he'd still need the threadDelay, probably the best use would be to set a maximum "frames per second" limit
17:38:11 <yip> no need to use 100% cpu in order to get 5000 FPS when we only need 30 FPS
17:38:22 <Cale> yeah, I suppose that's true
17:38:43 <LordBrain> hmmm
17:39:06 <LordBrain> yeah that makes sense... but i think its equivalent more or less to what i'm doing now
17:39:45 <Cale> yeah, basically his current setting will be as close as possible to a frame limit of 30 fps
17:40:21 <LordBrain> i dont need 30 fps really
17:40:49 <LordBrain> this is a text mode animation... all i'm doing is outing a space over the old position and putting an "o" at the new one.
17:41:10 <LordBrain> so all i need is however fast i want the ball to go
17:41:16 <Cale> In GHC, threadDelay will round whatever number you give it up to the nearest 20000
17:41:31 <LordBrain> oh is that so?
17:41:35 <LordBrain> rounds up?
17:41:45 <LordBrain> no..
17:41:50 <Cale> seems so
17:41:52 <LordBrain> just rounds nearest
17:42:01 <LordBrain> probably
17:42:02 <Cale> well, the docs say that it rounds up
17:42:07 <Cale> "Note that the resolution used by the Haskell runtime system's internal timer is 1/50 second, and threadDelay will round its argument up to the nearest multiple of this resolution."
17:42:19 <LordBrain> ok
17:42:29 <Cale> There is no guarantee that the thread will be rescheduled promptly when the delay has expired, but the thread will never continue to run earlier than specified.
17:43:08 <yip> hm... maybe directly calling the usleep function call would be better
17:43:37 <Cale> are you sure?
17:43:52 <Cale> Would other Haskell threads keep running?
17:44:02 <Cale> I think that if an FFI call blocks, the program is blocked.
17:44:11 <Cale> But I'm not sure about that
17:44:12 <yip> right, that is the goal
17:44:20 <LordBrain> i pushed it up to 60000, seems to stay at 15% and below now
17:44:26 <yip> to block the OS thread
17:44:39 <Cale> oh, I didn't think he was using OS threads
17:44:41 <yip> so that the OS can yield to other processes
17:44:47 <yip> Cale: he probably isn't
17:44:52 <LordBrain> well every program uses at least one OS thread
17:45:08 <LordBrain> my program has two haskell threads
17:45:12 <Cale> well, yes, but I thought the point of this was to yield to other Haskell threads
17:45:19 <LordBrain> ooooooh
17:45:20 <LordBrain> no no
17:45:25 <LordBrain> i want to yield to the os
17:45:38 <Cale> ah, okay, then either way works fine :)
17:46:13 <LordBrain> i'm less familiar with usleep
17:46:45 <LordBrain> i figured threadDelay would yield to other haskell threads, but since my other haskell thread is waiting for blocking io it would go to the OS anyway
17:47:01 <yip> if threadDelay seems to be working then you might as well just stick with it
17:47:38 <LordBrain> it works
17:48:48 <LordBrain> ideally it would work even better tho... i mean i dont see why animating a ball flying around the screen should use very much cpu... i'm sure if i did this in c i could out compete it easily.. but i guess it's ok.
17:49:26 <LordBrain> the garbage collector must be eating more cpu... in c i wouldnt have that
17:49:56 <yip> i doubt that that is a problem
17:50:07 <LordBrain> i wouldnt need very many pointers in c
17:50:40 <yip> i think that in such a simple animation as a bouncing ball, 90% of the overhead is input/output related, not cpu/memory
17:51:18 <LordBrain> yeah... i'd hope.. except in haskell every position is a pointer that must be writen to, and collected
17:51:35 <LordBrain> correct me if i'm wrong
17:52:31 <yip> there's some benchmarks that show that haskell is just as fast, and faster then C in a lot of cases
17:52:39 * dylan curses gnucash and wishes it was not written in C.
17:53:19 <LordBrain> well... in a typical animation i would have a more complex data structure
17:53:38 <LordBrain> but in this very simple case... i have a feeling c can do it better.
17:54:01 <LordBrain> i dont know
17:54:12 <LordBrain> could be i just dont get how to do it properly in haskell yet
17:56:06 <LordBrain> maybe i should just write teh c version to compare
17:56:33 <yip> i'm not sure what your application is, but i really wouldn't worry about performance unless you are sure that you need to
17:57:48 <LordBrain> oh i worry for the sake of learning
17:57:55 <LordBrain> thats all
17:58:13 <LordBrain> the application is just a small demo of the hscurses binding
17:59:03 <LordBrain> and besides... who wants to have aps using up 97% of their cpu...
18:00:26 <LordBrain> so i should at least check it... try to keep things under 30% unless they're truely computation intensive
18:05:16 <LordBrain> this is an ncurses program.. .think of that.. you're trying to execute the demo on a shell account and the server kills your process just because its so expensive.. that would make haskell or the library binding or what not look bad.
18:06:13 <yip> right but this isn't a language issue at all. it's a "system design" issue or something
18:06:57 <LordBrain> right, or its a programmer issue... meaning i should be the one to look bad
18:06:58 <kpreid> LordBrain: what was the URL for your code?
18:07:01 <LordBrain> hehe
18:07:23 <LordBrain> hold on... i'm going to upload it to the wiki
18:07:45 <yip> it's like saying that java sucks because it has a bad gui
18:15:00 <LordBrain> http://haskell.org/hawiki/PracticalHaskell#head-c809c1ac374255c0f8bb407026568a84c5f2c0ca
18:15:01 <lambdabot> Title: PracticalHaskell - The Haskell Wiki
18:18:45 <LordBrain> i'll probably move it... i didnt realize i was adding to the old wiki
18:29:11 <kpreid> LordBrain: I copied your ballPositions and I have it displaying at 30fps with 5% cpu usage
18:29:14 <kpreid> the catch is, I'm displaying it with OpenGL instead of curses bindings
18:29:54 <kpreid> so, something's wrong with (a) curses, (b) HSCurses, (c) threadDelay, or (d) your usage of the preceding
18:30:59 <LordBrain> yeah...
18:31:25 <LordBrain> i want to enable profiling in hscurses.. but i just havent figured out how to do it... its all autoconf and stuff
18:32:31 <lisppaste2> kpreid pasted "LordBrain's bouncing ball in OpenGL" at http://paste.lisp.org/display/23685
18:32:36 <kpreid> fwiw
18:32:51 <LordBrain> can i put that in the tutorial?
18:33:03 <LordBrain> we can have an opengl section
18:33:05 <kpreid> I'm not sure that this is actually useful; I just wanted to write it :)
18:34:11 <kpreid> well, the code is really mostly from http://haskell.org/HOpenGL/examples/Planet.hs
18:34:14 <kpreid> the parts which are mine, I don't care
18:34:36 * stepcut remember writing the bouncing ball on his 286 in pascal+asm
18:34:59 <stepcut> how far we have come
18:34:59 <LordBrain> what i'm sort of doing here is writing a bunch of tutorials at once, which theoretically all implement the same programs over and over but in different gui's etc..
18:35:39 <LordBrain> i figure it should make for a very quick way to get into any particular binding
18:35:51 <LordBrain> if you've already been thru the tutorial for another one...
18:36:05 <kpreid> well, good thing I didn't yield to the temptation to make a fancier bounce, then :)
18:36:20 <kpreid> it's not particularly pretty GL, though
18:36:27 <LordBrain> well i'm not going to be that strict
18:36:29 <kpreid> I wanted to make it cheap
18:36:42 <LordBrain> well, i'm sort of learning these bindings as i go myself
18:37:19 <LordBrain> i'm hoping if i'm clear about how others can jump in, people will contribute
18:37:39 <LordBrain> i am now thinking of moving to the wikibook tho
18:55:28 <pstickne> I am having a hard time with exercise 4.5 of YAHT.
18:56:04 <pstickne> The part I am having problems with is: Write a datatype Quadruple which holds four elements. However, the
18:56:04 <pstickne> ?rst two elements must be the same type and the last two elements must be the same
18:56:04 <pstickne> type
18:56:04 <lambdabot> Maybe you meant: ask last list msg run
18:56:57 <pstickne> I don't understand how to define Q as such. I have:   data Q a1 a2 b1 b2 = Q a1 a2 b1 b2, but this obviously does'nt meet the criteria
18:57:40 <jgrimes_> using Happy, is there a way to specify a nonterminal from a token (TokenVar String) using something like { TokenVar 'add' } and then having { TokenVar $$ } after that?
18:58:46 <jgrimes_> er, not nonterminal, I meant a terminal (like '+')
19:01:02 <edwardk> don't but numbers in there
19:01:10 <edwardk> data Q a b = Q a a b b
19:01:26 <jgrimes_> nevermind, I think I've figured out that the answer is yes I can do that
19:01:42 <edwardk> the first part says that there are two different types involved. the second part tells you what particular values your constructor takes.
19:02:49 <pstickne> edwardk, thanks, that makes sense, I was like, this is alot of duplicated stuff :)
19:05:33 * edwardk sits here trying to shoehorn code into shape
19:11:44 <dons> moin
19:11:57 <edwardk> how goes dons?
19:12:09 <dons> rainy!
19:12:51 * edwardk is sitting here grumbling about the fact that its a lot harder to write a class that extracts the least significant bit of a number when the number is in hex. =(
19:12:56 <stepcut> moin
19:13:30 <edwardk> 8 lines turns into a few hundred cases.
19:13:39 <stepcut> dons: is there a plan to extend ByteString to support other unboxed types? Such as Float?
19:14:21 <dons> no, that's for the upcoming ndp array library
19:14:27 <stepcut> ndp?
19:14:41 <dons> yeah, in the data parallel haskell branch
19:14:57 <edwardk> whos working on that part?
19:15:11 <dons> ?google data parallel haskell
19:15:12 <lambdabot> http://www.cse.unsw.edu.au/~chak/project/dph/
19:15:12 <lambdabot> Title: Manuel M T Chakravarty - Data Parallel Haskell
19:15:24 <edwardk> ok, been there, read that =)
19:15:33 * stepcut reads
19:15:51 <edwardk> so basically its an academic project so we'll never see any progress? =)
19:16:14 <stepcut> dons: cool
19:19:41 * edwardk gives in and elides a few thousand cases and the sheds several megabytes of .hi by just writing his shifter as TAdd a a b 
19:21:13 <pstickne> qFst Q a b c d = [a b]   why doesn't this work? (= a : b : [])  does
19:21:45 <pstickne> apparently I need to go back to list 101
19:22:21 <edwardk> pstickne: not sure i understand what you are trying to do
19:22:47 <Cale> pstickne: qFst (Q a b c d) = [a, b]
19:22:48 <pstickne> edwardk, make a list with the first two elements of Q (is that the right way to say it even? ... :-/)
19:22:49 <Cale> maybe?
19:23:16 <edwardk> yeah, then cale has it
19:23:36 <pstickne> gah, I was just getting used to not using ,'s thanks Cale :)
19:24:36 <Cale> pstickne: well, [a b] would be the list with one element, which was the application of the function a to the value b
19:24:48 <pstickne> make sense :P
19:26:20 <lisppaste2> pstickne pasted "exercise 4.5 - good way?" at http://paste.lisp.org/display/23689
19:26:43 * dylan ponders writing a double entry accounting program in haskell.
19:26:54 <pstickne> double entry?
19:27:04 <dylan> I think that's what it is called.
19:27:44 <dylan> http://www.gnucash.org/docs/v1.8/C/gnucash-guide/basics_accounting1.html <-- or, that's what gnucash calls it...
19:27:46 <lambdabot> Title: 2.1. Accounting Concepts
19:28:17 <edwardk> double entry book keeping its the practice of keeping debits and credits in separate columns, and more importantly matching every such entry with another entry in another book.
19:28:42 <edwardk> so every credit has a corresponding debit
19:28:45 <pstickne> cool
19:28:54 <edwardk> its pretty boring shit actually =)
19:28:58 <dylan> Gnucash basically forgot about an entire month due to a segfault... and despite keeping a transaction log, the missing data isn't there either.
19:29:07 <pstickne> edwardk, no, now I know the name for what Quicken does for me :P
19:29:09 <dylan> it's very booring feces, really
19:29:16 * edwardk <<--- had to write billing and provisioning software back in my ISP days
19:32:03 <pstickne> can you check if my exercise 4.5 code is good (or at least decent) or did I completly eat it?
19:32:03 * dylan would just like to know where his money comes from, and where it goes.
19:32:18 <pstickne> dylan, Quicken is pretty good :p
19:32:34 <dylan> pstickne: Quicken is not free software, and I don't think it runs on linux.
19:33:18 <Cale> pstickne: looks good
19:34:06 <pstickne> Cale, thanks :)
19:34:21 <stepcut> dylan: I have some double-entry bookkeeping stuff in haskell -- it needs a rewrite though
19:34:39 <dylan> stepcut: nifty. :)
19:34:42 <dylan> Got a link?
19:35:00 <dylan> or should I be afraid of the "needs a rewrite"?
19:35:11 <stepcut> dylan: no link, unfortunately.
19:35:35 <stepcut> dylan: the useful parts are probably the decimal library (so you do not get floating point rounding errors) and the .qif file parser
19:35:58 <dylan> don't need to parse .qif, really.
19:36:13 <stepcut> dylan: it is implemented as a WASH/CGI program, so that it can be used from any platform
19:36:56 <dylan> actually, the situation is pretty doomy... I don't remember the minute detail of where the money from my last two invoices went. :(
19:36:59 <stepcut> dylan: no qif ? Most banks, credit cards, etc will export data in that format
19:37:10 <dylan> I have no banks, credit cards, etc.
19:37:13 <stepcut> ah
19:37:14 <dylan> :)
19:37:19 <stepcut> well, no qif you then :)
19:38:06 <stepcut> but the decimal library should be useful: http://www.n-heptane.com/nhlab/repos/Decimal/
19:38:06 <dylan> it's not because I'm paranoid, either. it's because I'm lazy
19:38:08 <lambdabot> Title: Index of /nhlab/repos/Decimal
19:38:15 <dylan> stepcut: thanks muchly
19:38:34 <stepcut> though, it has a bug, and missing feature at the moment
19:38:52 <stepcut> I misunderstood the directions for rounding, so it rounds incorrectly
19:39:13 <dylan> hmm. This seems pretty boring.
19:39:53 <stepcut> well, it is not meant to be exciting
19:40:22 <dylan> I mean, the problems involved are boring.
19:40:53 <stepcut> Indeed. That's why I haven't finished :)
19:41:41 <dylan> hmmph
19:41:56 <dylan> I think I'll just write my transactions to a text file and be done with it
19:42:19 <stepcut> heh
19:43:20 <stepcut> you could even go for paper -- get an actual ledger and journal and do the old-fashion double entry bookkeeping
19:43:52 * stepcut swears to finish Decimal someday
19:45:13 <stepcut> I want to get the base Decimal library going, and then add a Money class on top that adds currency -- so that you don't accidently mix up dollars and euros in your program
19:47:10 <dylan> hmm, that wouuld probably make it easier to proceess both invoices and pay checks
19:48:21 <stepcut> the journal/ledger books are pretty easy to find -- any office supply store will have them
19:48:30 <Cale> stepcut: how is rounding supposed to be handled in financial stuff? Always round down? Round to even?
19:49:59 <stepcut> Cale: As far as I can tell, there is no standard. In the cases where that matters it will be specified. Otherwise you just make sure you do something consistent. That said, there is the tradition of bankers rounding
19:50:14 <stepcut> round to the nearest even number
19:53:10 <stepcut> In my non-professional experience -- accounting is less standardized that I thought it would be
19:54:49 <stepcut> If you are not a public company, the only people you have to answer to is the IRS when you file your taxes. And they only care about whole dollar amounts :)
19:55:10 <stepcut> hrm, that is not quite what I meant
19:56:36 <lisppaste2> pst pasted "ex4.6, how can I match against generic type?" at http://paste.lisp.org/display/23690
19:57:27 <pstickne> I'm trying to match against a generic/catch-all instead of a seperate function part for each T2, T3, T4, etc
19:57:42 <pstickne> But I'm having problems :))
19:59:35 <dons> pstickne: keep trying though :) you're doing well so far
20:07:21 <lisppaste2> pst pasted "generalizing cases" at http://paste.lisp.org/display/23691
20:08:07 <pstickne> Is there a way to generalize that?
20:08:53 <dons> only be factoring out the common argument in the data type itself
20:09:16 <pstickne> hmm?
20:09:46 <dons> i.e. data T a b c d = T a (T' b c d)  ; data T' b c d = T1 | T2 b | T3 b c | T4 b c d
20:10:01 <dons> then, tt1 :: T a b c d -> a ; tt1 (T a _) = a
20:11:02 <pstickne> data T'' = T2 | T3 c | T4 c d ?
20:11:02 <dons> your tt4 problem: tt4 :: T a b c d -> Maybe d ; tt4 (T4 _ _ _ d) = d ; tt4 _ = Nothing
20:11:31 <dons> well, maybe. depends on the problem
20:11:51 <pstickne> http://paste.lisp.org/display/23690 # with problem description
20:12:08 <dons> note that in the tt4 problem you tried to match on the type name, not a constructor (or wildcard _ )
20:12:09 <pstickne> dons, I can see how to do it typing each instance but that seems like too much typing :(
20:12:58 <dons> yes, you should nest it.
20:13:07 <dons> that's the hint (by calling it tuple)
20:13:24 <dons> i.e. the structure should be equivalent to (a , (b, (c , (d, ()))))
20:14:11 <dons> anyway, its not a lot of typing. just play around with a few different structures
20:14:20 <dons> try not to duplicate fields
20:14:24 <dons>         | T2 a b
20:14:25 <dons>         | T3 a b c
20:14:26 <dons> bad .
20:14:40 <dons> since then you have to check all those cases to find an 'a' or 'b'
20:14:49 <pstickne> dons, yes, that's not good :)
20:15:11 <pstickne> dons, reminds me of addExcel(a, b, c, ... zz) I saw on daily wtf :x
20:15:42 <dons> yeah :)
20:20:05 <Cale> The *real* wtf is why thedailywtf.com won't load through my web proxy.
20:20:43 <dons> pstickne: you were busy working through YAHT when I went to bed. karma+ for persistence!
20:20:57 <dons> ?karma+ pstickne -- hacking away at YAHT
20:20:58 <lambdabot> pstickne's karma raised to 1.
20:22:27 <pstickne> dons, haha, I got some sleep in there too :p
20:24:30 <dons> http://www.smh.com.au/news/national/one-giant-blunder-for-mankind/2006/08/04/1154198328978.html   -- the original moon landing footage goes missing
20:24:31 <lambdabot> Title: One giant blunder for mankind: how NASA lost moon pictures - National
20:24:46 <stepcut> hrm, apparently one the guys who create the FFT also invented the terms 'bit' and 'software'
20:24:59 <stepcut> s/create/created/
20:25:38 <dons> yeah?
20:26:05 <stepcut> http://130.191.21.201/multimedia/jiracek/dga/spectralanalysis/calcdftwithfft.html
20:26:05 <lambdabot> Title: 3.6 Calcutlating the DFT with the FFT
20:26:18 <stepcut> according to one source on the internet
20:26:24 <dons> heh
20:26:36 <stepcut> nerds
20:26:38 <dons> oh, Cooley. yeah
20:27:12 <dons> let's invent some terms!
20:27:26 <stepcut> and some transforms!
20:27:47 <dons> how about transforms over terms?
20:27:52 <jgrimes_> dons, if you use the ByteString pack, does that count as a consumer? so that the list construction for a string would be a producer and thus you could use short cut fusion ?
20:28:07 <dons> the ftt, fastest term transform, takes a term , and produces some new term, quickly
20:28:17 <stepcut> haha
20:28:21 <dons> jgrimes_: hmm.
20:28:41 <stepcut> dons: btw, where does one learn about this fusion stuff anyway ?
20:28:44 <dons> jgrimes_: well, unpack is a producer. so maybe pack is a consumer
20:29:02 <dons> stepcut: ok. there's a number of sources. and a few unpublished (its a bit hot atm)
20:29:09 <dons> let me find some refs
20:29:21 <stepcut> we should put them on a wiki page
20:29:29 <stepcut> maybe that one about optimizing your programs?
20:29:31 <dons> yeah, we have a rules wiki page
20:29:36 <dons> but probably should have a fusion page too
20:30:01 <dons> ok. about rewrite rules: Playing by the rules: rewriting as a practical optimisation technique in {GHC}
20:30:11 <dons> about short cut fusion: A Short Cut to Deforestation
20:30:29 <dons> the first array fusion paper: Functional Array Fusion
20:30:49 <dons> now, malcolm has an (unpublished) paper on destory/unfold, I think
20:31:16 <dons> however, the new stuff we're doing isn't published yet
20:31:29 <stepcut> cool
20:31:33 <stepcut> That is a good start
20:31:42 <stepcut> I am not yet to the *speed* part of this project yet
20:32:39 <dons> ah, also,
20:32:42 <dons> ?wiki Correctness_of_short_cut_fusion
20:32:43 <lambdabot> http://www.haskell.org/haskellwiki/Correctness_of_short_cut_fusion
20:32:49 <dons> ?wiki GHC/Using_Rules
20:32:50 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Using_Rules
20:33:54 <stepcut> greetings kfish
20:34:37 <dons> jgrimes_: want to try to write a good consumer pack?
20:34:46 <dons> you could look at the build/foldr unpack for hints
20:35:02 <kfish> stepcut, dons, good morning
20:35:12 <jgrimes_> dons, I suppose I can try :)
20:35:50 * stepcut gets back to SFTW
20:38:29 <dons> slowest fourier transform in the ...
20:39:07 <stepcut> west
20:39:08 <Cale> ahahaha, did anyone see the Sorted Lists thing on dailywtf?
20:39:29 <stepcut> the counter-part to http://www.fftw.org/
20:39:31 <lambdabot> Title: FFTW Home Page
20:39:39 <urz> has anybody made a SOAP web service in haskell?
20:39:49 <dons> stepcut: yeah, I know ;) I'm writing a paper on using a similar code gen technique for a polymer chemistry simulator
20:40:09 <dons> urz, did you check haskell.org under 'libraries and tools'?
20:40:15 <stepcut> http://okmij.org/ftp/NumMath.html#FFT-generation
20:40:16 <lambdabot> Title: Numerical Math and Scientific Computing
20:41:10 <dons> oh, very interesting
20:41:19 <urz> dons, a few weeks ago.  I was trying to learn the Haifa library but got too busy.  It was not yet very well documented.
20:43:06 <stepcut> oleg strikes again
20:43:34 <urz> i'm not sure i want to go back to it.  Maybe it'd be easier to just start from an xml library and a net library
20:43:50 <dons> possibly, yes
20:44:10 <dons> we have lots of those!
20:46:12 <urz> goody
20:50:01 <monochrom> The Sorted List thing is sad.
20:50:43 <stepcut> monochrom: hehe
20:50:52 <stepcut> monochrom: indeed
20:50:58 <monochrom> The saddest part is ListBox.
20:52:29 <monochrom> I hope no one duplicates this innovation in a school that uses Java.  "Binary Search Trees in Java.  You can use Swing lightweight components..."
20:53:45 <dons> sigh
20:54:07 <stepcut> monochrom: haha
20:55:42 <int-e> But it works, and it's implemented in a library so it should be well-optimized?!
20:57:35 <pstickne> monochrom, there was a dailywtf with 'sorted lists' and VB listboxes O.o
20:58:07 <monochrom> Yes, I was commenting on that.
20:58:14 <pstickne> ohh, my bad :(
20:59:29 <monochrom> I ought to add the RSS feed of dailywtf to my Firefox live bookmarks.  So that when I'm bored and depressed, I have something to read and make me less bored and more depressed.
21:00:11 <monochrom> So it's done.
21:03:09 <monochrom> I like HXT for xml work.  Contrary to most people because they fear arrows.  I am planning to write a short introduction to that.
21:22:47 <lispy> monochrom: please do
21:22:55 <lispy> monochrom: i would eagerly read it
21:23:03 <lispy> and then probably switch from HaXml to HXT :)
21:24:36 * stepcut prefers HXT too
21:24:58 <lispy> i decided to use HaXml for dtd2haskell, but i'm not real impressed with it
21:25:10 <lispy> actually, what i need so probably just xstlt
21:25:14 <lispy> er xslt
21:25:27 <lispy> i'll need to generate the styles then apply them
21:26:17 <lispy> i could do it with just haxml, but then i'd have to come up with a way to store the styles...so why not just generate an xsl file with the style as it's designed by the user, and then apply it when the data is ready
21:27:26 * lispy waits for someone to say, "But there is an easier way!"
21:27:49 <monochrom> Yeah, telepathy is easier. :)
21:28:02 <monochrom> All specifications are hard.
21:28:38 <lispy> yeah
21:28:53 <lispy> i'm not convinced about my xsl idea...i haven't taken the time to think it through completely
21:29:14 <lispy> but i love using already developed things
21:29:17 <lispy> so it has that appeal
21:30:44 <monochrom> xsl is ok
21:31:47 <stepcut> using already developed things !? I like to start by inventing fire!
21:32:27 <lispy> monochrom: i've found xsl hard, but i'm also very new to it
21:32:43 <lispy> i find that when i want the output to have a particular formatting it's annoying to fuss with
21:33:37 <monochrom> Ah.  Easiest to replace tags and preserve formatting.  To change formatting is hard, indeed.
21:34:02 * monochrom gives stepcut the gift of fire :)
21:38:05 <dons> stepcut: I prefer to begin with the wheel
21:38:20 <dons> maybe I'm lazy
21:39:11 <monochrom> I like quarks.
21:39:17 <lispy> heh
21:39:51 <lispy> the thing about computer science is that, there are still many areas where you can actually make rounder wheels
21:41:42 <lispy> heh, i love kingdom of loathing, i just found "amulet of extreme plot significance"
22:14:17 <tennin> I didn't find the HXT documentation too difficult to understand
22:14:23 <tennin> and I'm usually really dense about this stuff
22:31:03 <jgrimes_> dons, hm... without having the list already allocated so you have the length or an address of a string I don't see how you could create a good consumer (as well as efficient) version of pack. I think you could eliminate creating the list if you didn't mind allocating a lot of ByteStrings, though.
22:32:47 <jgrimes_> but I don't really know much :)
22:35:10 <dons> hmm
22:35:16 * dons studies the code
22:35:16 <jgrimes_> and also, I haven't really looked at the lazy bytestring stuff
22:35:20 <jgrimes_> so...
22:35:40 <dons> that's ok
22:35:55 <dons> yes, you need to get the length
22:36:06 <dons> which will force the string anyway
22:36:14 <stepcut> we need some sort of lazy malloc
22:36:27 <dons> well, its doable. getContents works like that
22:36:28 <stepcut> were you write the data to memory, and then you malloc it
22:36:36 <dons> read a bit, realloc, unsafeInterleaveIO
22:36:42 <dons> but that's a lot of copies, for a pack
22:41:02 <jgrimes_> learned a lot in the process of investigating it, though :)
22:41:19 <dons> cool :)
22:41:55 <jgrimes_> but now it's time for some sleep. have a nice day/night everyone :)
22:58:07 <edwardk> woot, the hex peasant multipllier works
22:58:12 <edwardk> now i just need to make it fast
22:59:48 <stepcut> heh
23:00:17 <edwardk> its pretty slow without a shifter =/
23:00:26 <edwardk> but its faster than compiling the shifter
23:00:29 <edwardk> so its a tradeoff
23:00:55 <stepcut> > (2 :+ 0) ^ (2 :+ 0)
23:00:57 <lambdabot>  add an instance declaration for (Integral (Complex a))
23:00:57 <lambdabot>   In the definitio...
23:01:02 <stepcut> :(
23:01:11 <edwardk> think i'll reintroduce my one bit shifter and abuse thaat
23:01:42 <edwardk> coz right now its mostly code like: instance ( TMul (D0 a1) b c , TAdd' a1 a1 a2 , TAdd' a2 a2 a4 , TAdd' a1 a4 a5 , TAdd' a5 c d) => TMul a1 (D5 b) d
23:01:49 <edwardk> and all those adds are wasting effort
23:03:15 <edwardk> i figure if i add a 1 bit shifter, an easy 4 bit shifter, and make it instead of just adding bits, able to subtract bits in the more extreme cases it might even be fast
23:43:23 <edwardk> tPow $(hexE 2) $(hexE 72)
23:43:23 <edwardk> $(hexE 4722366482869645213696) appears to be about the largest number the hex version of the library can handle
23:44:06 <edwardk> i overestimated by a factor of 256, but should be good enough
23:45:44 <dons> :)
23:46:17 <edwardk> i'm cheating on pow
23:47:15 <edwardk> i didn't want to write the hex 'peasant exponentiation', so i wrote hex to binary to hex conversion classes, and i do peasant exponentiation in binary on hex products
23:47:40 <edwardk> figure with the largest possible exponent being around 72 for aything other than 1, its a safe conversion
23:48:08 <edwardk> er anything other than 1,0, or -1 that is
23:52:08 <edwardk> heh, its a shame after all that that this library will be nigh useless to the community at large. can't standardize it coz it uses too many extensions
