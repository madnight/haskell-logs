00:03:03 * edwardk now wonderswhy everyone told him that uniqueness typing was just another name for linear types. they are totally backwards.
00:03:16 <edwardk> in a good way, yes, but still backwards =)
00:04:02 * Korollary is glad that he didn't say anything
00:04:20 <edwardk> ?
00:04:34 <Korollary> 'everyone'
00:04:44 <Korollary> Silence is golden.
00:04:51 <edwardk> ok, well, everyone who said anything to me on the subject ;)
00:04:58 <musasabi> Has anyone got "initC: srt" panic with GHC version 6.5.20060822 ?
00:05:41 <edwardk> uniqueness types let you add weakening and contraction to a type that is already in circulation, linear types let you take them away from an 'exponential' that is already in circulation.
00:06:07 <edwardk> now i have yet another case to add to my ever exploding intermediate logic
00:09:08 <Pseudonym> You should publish the definitive work on exploding intermediate logic.
00:09:48 <edwardk> heh
00:09:59 <edwardk> at this rate that may be what this thesis turns into ;)
00:10:23 <edwardk> a 'what happens if you throw all of these weird extensions into a melting pot' kinda thing
00:14:06 <dons> yay. success. my mp3 player runs in openbsd
00:14:58 <edwardk> woot
00:15:24 <edwardk> not that i have had an excuse to run openbsd lately... or a use for an mp3 player. =)
00:15:31 <dons> the lesson is: don't just randomly hack the disklabel. not good
00:17:15 <Pseudonym> Last time I installed openbsd was on a firewall/router.
00:17:17 <Pseudonym> That's all it did.
00:17:35 <Pseudonym> Given that it didn't have to play mp3s, it seemed like a decent idea.
00:17:58 <musasabi> dons: what is the status of the fps + utf8 work?
00:18:26 <dons> sjanssen's written a Storable a => ByteString a library
00:18:45 <dons> and there's code for utf8, I think. I'm waiting on a final report on the status of everything
00:19:16 <dons> Pseudonym: yeah, I started off with just the firewall, but now run openbsd on everything
00:19:37 <musasabi> mmh, but nothing ready yet? Was thinking of trying to benchmark jhc with fps.
00:19:47 <musasabi> But it is married with utf
00:19:55 <dons> we still need to merge it in to the fps unstable branch
00:25:57 <Pseudonym> Better head off.  Night.
00:31:44 <dons> ?users
00:31:44 <lambdabot> Maximum users seen in #haskell: 235, currently: 194 (82.6%)
00:38:34 <benja_> edwardk: what sort of typing work do you do?
00:39:19 * benja_ read a paper by Scott about the untyped lambda calculus yesterday which thanked ETH Zurich for proving the environment where his paper could be written "and typed"
00:39:32 <dons> heh
01:00:03 <dons> musasabi: so the changes to the fps api (removing redundant bits) this week are ok with HAppS?
01:05:07 <benja_> dons: "Dynamic code replacement is always a tricky business; in a purely functional language, the semantic consequences are even more subtle." don't you mean "in a non-strict programming language"?
01:05:20 <benja_> being pure seems to me to solve more problems than it generates -)
01:06:07 <vegai> benja_: oh, hi.
01:06:14 <benja_> moi vegai :)
01:06:14 <dons> heh. there are issues with unevaluated closures
01:06:32 <dons> laziness of course, is a problem too
01:06:38 <benja_> hm, right, you can get those with strict functional langs too
01:06:44 <dons> yep
01:06:52 <benja_> ok
01:07:04 <dons> but the main thing is that it is easier to do dynamic update, since you've got good control of your program's state
01:07:26 <benja_> yeah, that's why the "purely" part doesn't track for me .)
01:07:53 <dons> the consequences are subtle, not bad :)
01:08:01 <benja_> heh =)
01:08:34 <profmakx> I just typed "he wrote subtle not bad"...
01:08:53 <profmakx> strange ...
01:09:23 <dons> I OWN YOUR BRAIN
01:09:30 <mux> @seen dcoutts
01:09:30 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow and #haskell. I don't know when dcoutts last spoke.
01:09:41 <profmakx> now i am scared -.-
01:09:42 <dons> dcoutts is on holidays till at least the 1st, mux
01:09:46 <mux> oooh
01:09:47 <mux> thanks
01:09:56 <dons> he'll be popping up in sweden then, for a few weeks
01:10:20 <mux> I guess I'll have to wait for him to come back then
01:13:11 <benja_> hm. anyone here think that a formal system and proof checker integrated with Haskell -- for formalizing the usual informal reasoning about functions -- would be useful?
01:13:57 <benja_> I'm currently working on one in my own untyped pure language, but I'm wondering whether I would make it useful for others if I used Haskell instead
01:14:17 <mux> isn't QuickCheck already doing that?
01:14:19 <benja_> (my goal is for it to be useful for myself, but y'know, useful for others would be nice :))
01:15:20 <benja_> mux: I'm looking for something in which you can give formal proofs and have them checked. but QuickCheck may be more interesting to others. I'll have a look at it...
01:16:02 <mux> QuickCheck allows you to state rules such as "foo . foo = id" or such, and it tries to verify the rules hold by testing them with random values
01:16:26 <benja_> yeah, got that much from the website already =)
01:16:30 <mux> maybe that's not what you want?
01:16:33 <mux> oh, sorry.
01:16:37 <dons> benja_: you might be interested in the (huge) QuickCheck set fps uses, http://www.cse.unsw.edu.au/~dons/code/fps/tests/Properties.hs
01:16:52 <dons> there's some 700 properties or so of the library, that get tested
01:17:09 <mux> yes, and I can tell it takes ages to run the tests :-)
01:17:33 <dons> i can't even compile them on some boxes , ghc takes too long
01:18:00 <mux> dons: I saw FPS will maybe get integrated in Haskell'
01:18:17 <mux> that's quite an achievement :-)
01:18:35 <dons> :) well, its in hugs and ghc already
01:18:39 <mux> yeah
01:18:46 <mux> in GHC 6.5 though, right?
01:18:58 <dons> yep, to be released shortly
01:19:04 <mux> that's cool
01:19:41 <dons> oh, nice, Roman Leshchinskiy has the nested data parallel ghc branch running on a 32 processor solaris machine!
01:19:59 <dons> ?where ndp
01:19:59 <lambdabot> I know nothing about ndp.
01:20:20 <dons> ?where dph
01:20:20 <lambdabot> I know nothing about dph.
01:20:28 <dons> ?where+ ndp http://www.cse.unsw.edu.au/~chak/project/dph
01:20:29 <lambdabot> Done.
01:20:32 <dons> ?where+ dph http://www.cse.unsw.edu.au/~chak/project/dph
01:20:33 <lambdabot> Done.
01:57:49 <musasabi> dons: will test on the weekend.
01:59:25 <kzm> dons: is that a reasonably updated ghc?
01:59:47 <kzm> and is there a binary snapshot for sparc/solaris?
02:00:18 <kzm> (I can access an 8-cpu Sun, but the GNU software (including gcc) on it is bit-rotted)
02:15:03 * mux shakes fist at gtk2hs
02:16:56 <vegai> try Siberia first, i.e. gtk+ in C :P
02:17:44 <mux> I don't want to do this in C
02:17:48 <mux> I know C well enough, it's no fun
02:17:59 <Pupeno> Is there any try, even obsolete and abandoned, to make a pure or almost pure functional GUI toolkit (in any language) ?
02:19:02 <benja_> Pupeno: wxFruit?
02:19:34 <Pupeno> benja_: that sounds like based on wxWidgets.
02:19:54 <yip> the original Fruit is probably a better answer :)
02:20:02 <mux> I can't quite see the needs for such a thing, unless it interfaces with an existing GUI, in which case it's not 100% pure
02:20:04 <benja_> Pupeno: it's an adapter for it, but presents a pure interface
02:20:50 <benja_> yip: well, that just uses Java and Swing and a foreign function interface instead of wxWidgets, doesn't it? ;)
02:20:59 <yip> fruit is a pure functional GUI. it appears to be possibly abandoned, but it is definitely not obsolete. it pretty much lays down an excellent design
02:21:40 <yip> benja_: it only uses Java for the low-level IO: getting mouse movements and clicks and outputting primitive graphics
02:21:54 <benja_> yip: so what's different to wxFruit and wxWidgets?
02:22:37 <yip> when you use wxFruit, you write your programs using code in the style of Fruit
02:22:51 <yip> when you use wxWidgets, you write your programs using code in the style of wxWidgets C++ API
02:23:21 <benja_> yip: I'm not asking for the difference between wxFruit and wxWidgets, but between Fruit/Swing and wxFruit/wxWidgets
02:24:06 <benja_> (and I'm asking seriously, I don't quite understand whether there's a fundamental difference =))
02:24:27 <yip> well, the "Swing" part of "Fruit/Swing", and the "wxWidgets" part of "wxFruit/wxWidgets" is i guess an implementation detail of each of the libraries
02:25:45 <benja_> ok
02:26:27 <Pupeno> benja_: from what I see you have wxFruit built *on top* of wxWidgets and Fruit built *on top* of Swing. It doesn't make much sense to see the differences between wxFruit and wxWidgets... one is a Haskell library and the other is a C++ library.
02:26:35 <yip> actually, i don't think that Fruit uses Swing. it uses some other parts of the java API
02:27:11 <Pupeno> yip: ok.
02:27:25 <benja_> yip: the fruit paper shows swing buttons :-)
02:27:31 <benja_> in the screenshots
02:27:51 <yip> benja_: those are not swing buttons. they only look similar :)
02:28:13 <benja_> really? ok
02:28:44 <benja_> I suppose Fruit then implements more inside the functional environment than wxFruit
02:32:25 <kuribas> I have trouble trying to write a simple function that uses a STArray to map values from an array.
02:32:53 <lisppaste2> kuribas pasted "STArray" at http://paste.lisp.org/display/24724
02:33:41 <kzm> Was there a performance benefit to zero-indexed arrays vs one-indexed?  (i.e. indices [0..n-1] vs [1..n])
02:34:21 <sieni> no?
02:36:39 <lisppaste2> kuribas annotated #24724 with "errors from ghci" at http://paste.lisp.org/display/24724#1
02:36:53 <kzm> Okay - [1..n] it is, then. :-)
02:37:07 <kzm> Anybody interested in neural networks?
02:43:36 <benja_> does anyone know what it means if 'runghc Setup.hs configure' fails with "*** Exception: Line 16: Parse of field 'extensions' failed", on Ubuntu?
02:59:27 <kuribas> I read somewhere that haskell isn't a good choice for writing large numerically applications.  Does that mean that haskell is also not good for image manipulation?
03:00:07 <kuribas> (Since an image is basically a large matrix of pixel values)
03:05:57 <dons> kuribas: image manipulate, anything, should be fine. see Frag for example
03:06:01 <dons> ?where Frag
03:06:02 <lambdabot> http://www.haskell.org/haskellwiki/Frag
03:06:11 <ibid> kuribas: the more you need raw computing power, the less pleasant haskell gets. it isn't impossible, certainly
03:08:45 <kuribas> Well, I am fine with less power, as long as I am just prototyping my application.
03:11:01 <kuribas> Perhaps it is useful to rewrite the number crunching parts in C, and bind it to haskell using the FFI...
03:11:27 <dons> yeah, if you find a bottleneck, that's exactly how to solve it
03:11:38 <Pupeno> kuribas: you have to give some context... why haskell isn't a good choice and what's the alternative (if the alternative is assemble because it is supper dupper fast, then the reason doesn't make much sense).
03:12:02 <Pupeno> kuribas: that's optimization, that's good, BUT: "Premature optimization is the root of all evil."
03:13:10 <kuribas> Pupeno: I need to do analysis on large images (2400 * 3500 pixels).
03:14:40 <Pupeno> kuribas: my knowledge ends here, I am not really a Haskeller... net yet at least... but I've know many people that would say every language is not suitable for any task because it is not as fast as C.
03:15:17 <sieni> and C isn't as fast as Fortran 77
03:16:10 <Pupeno> sieni: that one without procedures ? only gotos ?
03:16:49 <kuribas> Pupeno: If it is about two times as slow, it's ok for me.  But if it is 20 times or more I will think of a different solution...
03:17:21 <dons> 2x slow should be reasonable to aim for
03:17:40 <dons> pick the right data struture , a ByteString or unboxed array
03:17:47 <sieni> Pupeno: it has procedures, yes
03:18:22 <Pupeno> kuribas: I'd search, first, for a language that lets me express what I need to express correctly. And then do some testing.
03:18:30 <dons> Pupeno: though Haskell beats  ~30% of the time on the language shootout
03:18:53 <dons> beats C
03:19:23 <kuribas> dons: I am trying to use a STUArray, but I don't understand the errors I am getting.
03:20:32 <kuribas> http://paste.lisp.org/display/24724
03:20:38 <Pupeno> Here: http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all Haskell is well positioned.
03:21:16 <dons> those benchmarks don't include DAta.ByteString or the new regex library, either.
03:21:57 <kuribas> dons: Is ByteString more efficient that an unboxed array?
03:22:14 <dons> for bytes, yes.
03:22:19 <Pupeno> I am not sure about Clean and OCalm, but the rest are static typed languages and since Haskell parametric typing gets closer to dynamic typing (for the user I mean), that would make Haskell a winner.
03:23:04 <Pupeno> read: the faster language in which you can code without worring about types/classes (except in some particular cases).
03:23:53 * johnnowak wonders when one does *not* worry about types
03:24:28 <dons> when one doesn't worry about bugs :)
03:24:32 <norpan> the point with types is that you need not worry
03:24:42 <johnnowak> dons: exactly :)
03:25:06 <johnnowak> in an untyped language, one would worry about "types" most of all
03:25:10 <dons> "oh, my program works on the one input I've given it. must be finished"
03:25:15 <Pupeno> johnnowak: most of the time when I write functions I don't define the types in and out, I let the compiler find out. It does a good job.
03:25:32 <johnnowak> Pupeno: not keying in the type and not worrying about it are not the same thing
03:25:34 <dons> ah, Pupeno you mean type inferene makes things easier for the user?
03:25:53 <Pupeno> ok, "not worring" was not the right wording.
03:26:02 <Pupeno> "without having to define" is better.
03:26:22 <Pupeno> you are right, I think I have worried more about types in Python than in Haskell.
03:29:05 <kuribas> Speaking of type inference, does anyone have an idea why my code above doesn't work? (http://paste.lisp.org/display/24724)
03:29:23 <Pupeno> Haskell doesn't do very good at BZip benchmark... :S
03:29:50 <kuribas> A static type system can make things more complicated sometimes...
03:30:28 <johnnowak> does anyone know of a good paper that addresses some of the issues with static typing?
03:30:36 <johnnowak> where it falls down, etc?
03:30:41 <jrmole> kuribas: with ST[U]array one often has to annotate the type of runSTUArray
03:31:30 <jrmole> looks like it's inferring unrestricted element type 'e' and therefore can't find a concrete instance
03:34:16 <kuribas> hmm, I'll trying adding more type information.
03:35:17 <jrmole> you can define your own runSTUArray' = runSTUArray and give it a more specific type signature
03:35:25 <dons> Pupeno: there's a bzip benchmark?
03:35:29 <dons> url?
03:35:42 <Pupeno> sorry, GZip
03:35:50 <Pupeno> http://shootout.alioth.debian.org/gp4/faq.php#gzbytes
03:35:52 <lambdabot> Title: Frequently Asked Questions | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer  ...
03:35:55 <Pupeno> it's funny.
03:36:06 <jrmole> actually, the problem seems to be with writeArray
03:36:10 <jrmole> but same issue
03:36:11 <dons> oh, you mean, when they gzip the src, it doesn't compress well?
03:36:25 <kuribas> jrmole: I added a type signature for myAmap, that seemes to work.
03:36:35 <jrmole> ah
03:36:55 <lisppaste2> kuribas annotated #24724 with "myAmap with typesignature" at http://paste.lisp.org/display/24724#2
03:37:11 <dons> gzip is a bogus way to measure the size of the entry anyway, it penalises semantically rich languages, and boosts repetitive code
03:37:33 <dons> on raw lines of code, we rank first or second, I think
03:37:44 <Pupeno> dons: yes. Thereby, I proclaim that we should use Ruby instead of Haskell to save the world from the catastrophic desaster of running out of bandwidth.
03:37:52 <dons> heh
03:38:24 <dons> we should use S K I combinators
03:38:54 <qwr> unlambda ;)
03:39:12 <kuribas> jrmole: thanks.  Now that I think of it, it is quite logical that it needs to know the element size for an unboxed array :)
03:40:37 <dons> yeah, we could submit haskell entries in an embedded compressable dsl
03:40:45 <dons> like unlambda or ski
03:45:53 <mnislaih> To which paper would make reference a "See section 9 of static semantics paper for more details." comment in the ghc sources ?
03:46:34 <dblhelix> mnislaih: faxen's?
03:47:10 <dblhelix> mnislaih: k.f. faxen, "a static semantics for haskell"
03:47:24 <mnislaih> ah, thanks
03:47:38 <dblhelix> mnislaih: that one's not for the faint of heart, though
03:48:36 <mnislaih> heh, I only pasted the first part of the comment. It goes on with "(You can get a PhD for explaining the True Meaning
03:48:36 <mnislaih> 	--  of this last construct.)"
03:49:14 <dblhelix> mnislaih: just curious... which construct?
03:49:35 <dons> mnislaih: heh!
03:49:44 <mnislaih> it is the AbsBinds in the HsBinds datatype
03:50:07 <mnislaih> I just want to capture implicit parameters, don't really need to understand it fully
03:50:43 <dons> ?remember ghc You can get a PhD for explaining the True Meaning of this last construct
03:50:43 <lambdabot> Done.
03:50:51 <dons> ?users
03:50:52 <lambdabot> Maximum users seen in #haskell: 235, currently: 195 (83.0%)
03:54:00 <jrmole> SKI code is exponentially larger than lambda calculus
03:54:43 <jrmole> and probably in a way that gzip can't compress ;)
03:56:55 <kuribas> How do I write a where construct inside do notation that depends on the value inside the do-notation?
03:57:21 <jrmole> i don't think you can; use let instead
03:57:36 <jrmole> where is declaration-level whereas let is expression-level
03:57:51 <kuribas> ah...
03:58:05 <kuribas> I have this, but it looks ugly: http://paste.lisp.org/display/24724#2.  Can I get rid of the parens?
03:58:12 <jrmole> also let is more intuitive with the order of computations in a monad
04:00:11 <kuribas> Yes, I see.
04:00:59 <lisppaste2> jrmole annotated #24724 with "reformatted using layout" at http://paste.lisp.org/display/24724#3
04:01:39 <jrmole> unfortunately you can't use the standard f (g x)  ==> f $ g x code transformation with runST and friends because of rank-2 types
04:02:43 <kuribas> jrmole: I found that out :)  I wouldn't have found the solution withouth googling though.
04:03:38 <jrmole> almost makes me wish ($) was sugar
04:09:29 <Philippa> really the "because" isn't rank-2 types, it's the type system being predicative
04:09:57 <lisppaste2> kuribas annotated #24724 with "same code, rearranged" at http://paste.lisp.org/display/24724#4
04:10:43 <kuribas> jrmole: Oh, you already wrote that :)
04:11:31 <jrmole> what makes a type system predicative?
04:30:05 <kosmikus> jrmole: in a predicative type system, universally quantified type variable range only over monotypes
04:32:18 <kosmikus> jrmole: if you want to apply ($), which is an ordinary Haskell function with type "forall a b. (a -> b) -> a -> b" to runST, you'd have to instantiate "a" and "b" to polymorphic types ...
04:38:34 <qwr> > id (+) 1 2
04:38:36 <lambdabot>  3
04:38:58 <qwr> > ($) (+) 1 2
04:38:59 <lambdabot>  3
04:40:04 <ski> @pl ($)
04:40:05 <lambdabot> id
05:01:33 <roconnor> @vixen what's up
05:01:34 <lambdabot> not much, what's up with you?
05:09:32 <yip> there are these things called "template engines" that are popular in web programming. a lot of them have simple programming languages embedded into them, that allow you to do things like ifs and loops
05:10:00 <yip> these programming languages all seem to be imperative, i'm wondering if it's possible to design a template engine with an embedded functional programming language
05:10:25 <liyang> links :-/
05:11:06 <resiak> yip: xsl? :)
05:13:09 <yip> hm... i'm not really sure that xsl qualifies as a template engine
05:42:47 <xerox> ?yow!
05:42:48 <lambdabot> Do I have a lifestyle yet?
05:44:42 <jrmole> yip: http://www.cs.chalmers.se/~d00nibro/hsp/
05:44:45 <lambdabot> Title: HSP - Haskell Server Pages
06:09:51 <SamB> hmm, dynCompileExpr looks like a potential security hole...
06:10:43 <eivuokko> What do you mean?
06:11:03 <SamB> well it doesn't check to make sure the expression is actually an expression
06:11:36 <SamB> maybe not...
06:11:37 <araujo> morning
06:11:39 <eivuokko> Uhm
06:11:46 <eivuokko> Could you give an example?
06:12:16 <SamB> well. I'm not sure it *is* a hole. it just resembles one...
06:16:12 <Sn4k3> can anyone help me with a really simple math problem, my damn brain has stuck. I've been thinking for over an hour and I cant f*ing solve it :@
06:17:03 <SamB> what is the problem? though maybe #math is more appropriate...
06:17:08 <Sn4k3> nah not really
06:17:13 <Sn4k3> you're gonna solve it with recursion
06:17:29 <sieni> goa head and ask
06:17:36 <Sn4k3> sec.
06:17:40 <Sn4k3> gotta translate it
06:18:04 <SamB> oh no! swedish math problems!
06:18:14 <Sn4k3> :D
06:18:15 <johnnowak> haha, "nah not really -- you're gonna solve it with recursion"
06:18:17 <sieni> svenska matematiska problemer :-)
06:18:33 <Sn4k3> sieni: kan du svenska? :)
06:18:47 <sieni> javvist, lite ;-)
06:18:55 <Sn4k3> ah well
06:18:58 <Sn4k3> ill do it in english instead
06:19:40 * SamB 's ADD meds haven't kicked in yet
06:20:08 <sieni> maybe you should snort them?
06:20:20 <SamB> nah
06:20:26 <Sn4k3> if you pile up small balls (which forms like a pyramid) the 'n' layer got exactly n more balls than the n-1 layer
06:20:29 <Sn4k3> ^^
06:20:31 <Sn4k3> how do I solve it
06:20:44 <Sn4k3> Im losing my mind soon cuz I cant figure it out :@
06:20:48 <sieni> solve what? the number of balls?
06:20:52 <Sn4k3> yeah
06:20:58 <Sn4k3> how many balls are in the pyramid
06:21:20 * johnnowak is completely confused
06:21:24 <Sn4k3> haha
06:21:27 <roconnor> Sn4k3: how many balls in the first layer?
06:21:31 <Sn4k3> 1
06:21:38 <Sn4k3> 1 3 6 10 15
06:21:45 <Sn4k3> etc etc
06:21:53 <sieni> 1, 3, 6, 10, 15, etc.
06:22:08 <Sn4k3> so layer 4 got exaclty 4 more balls than layer 3
06:22:09 <roconnor> let f 1 = 1 ; f n = n + f (n-1) in sum [f n | n <-[1..5]]
06:22:12 <roconnor> > let f 1 = 1 ; f n = n + f (n-1) in sum [f n | n <-[1..5]]
06:22:13 <lambdabot>  35
06:22:31 <roconnor> > map (\i->let f 1 = 1 ; f n = n + f (n-1) in sum [f n | n <-[1..i]]) [1..]
06:22:33 <lambdabot>  [1,4,10,20,35,56,84,120,165,220,286,364,455,560,680,816,969,1140,1330,1540,1...
06:23:41 <roconnor> > map (\i->(i,let f 1 = 1 ; f n = n + f (n-1) in sum [f n | n <-[1..i]])) [1..]
06:23:42 <lambdabot>  [(1,1),(2,4),(3,10),(4,20),(5,35),(6,56),(7,84),(8,120),(9,165),(10,220),(11...
06:24:08 <roconnor> you just write the statement of the problem in haskell, and you get the answer.
06:24:20 <Sn4k3> not really :)
06:24:30 <Sn4k3> and that code, I dont understand much of
06:24:32 <roconnor> f 1 = 1
06:24:38 <roconnor> f n = n + f (n-1)
06:24:53 <roconnor> f defines the number of balls on the nth layer
06:25:12 <roconnor> [f n| n <-[1..5]]
06:25:21 <roconnor> that is a list of numbers of balls in the first five layers
06:25:26 <roconnor> sum [f n| n <-[1..5]]
06:25:30 <roconnor> that adds them up.
06:26:17 <ski> > take 10 $ scanl1 (+) . scanl1 (+) $ [0..]
06:26:18 <lambdabot>  [0,1,4,10,20,35,56,84,120,165]
06:26:36 <ricky_clarkson> Stupid Java programmer alert..
06:26:50 <ricky_clarkson> Does Haskell's Maybe type rely on dynamic dispatch?
06:26:51 <roconnor> ski :)
06:27:11 <roconnor> ricky_clarkson: nope.
06:27:14 <dons> ricky_clarkson: heh, no.
06:27:37 <ricky_clarkson> If you implemented it in Java, would it look like the visitor pattern?
06:28:09 * roconnor wonders how to do union types in Java.
06:28:24 <dons> roconnor: there's a really heavy encoding
06:28:34 <boliver> yes
06:28:43 <roconnor> that doesn't seem like fun at all.
06:29:04 <dons> yay for the land of verbs
06:29:10 <boliver> ricky_clarkson: yes, the visitor pattern is mostly a way to implement sum types in java
06:29:12 <ricky_clarkson> interface Maybe<T> { void visit(MaybeVisitor<T> visitor); } Implementations of Maybe (there would be two, one for T and one for Nothing) would call the right visitor method.  I think.
06:30:09 <boliver> ricky_clarkson: I thing your "visit" should be called "accept"
06:30:16 <ricky_clarkson> Yes.
06:31:26 <ricky_clarkson> An irritant in that is that the visitor has to have side effects, it takes more generic wrangling to make it able to return stuff instead.
06:31:39 <ricky_clarkson> s/side //
06:33:13 <ski> hm, one can't do something like
06:33:15 <ski> interface Maybe<T> { O visit(MaybeVisitor<T,O> visitor); }
06:33:16 <Philippa> yeah, the ordinary visitor pattern effectively has arbitrary functions
06:33:17 <ski> ?
06:33:32 <boliver> ski: yes
06:33:42 <boliver> that's a functional visitor
06:33:44 <ski> (or can't one universally quantify ?)
06:33:44 <ricky_clarkson> ski: Yes, one can do that.
06:34:13 <ricky_clarkson> interface Maybe<T> { <O> O visit(MaybeVisitor<T,O> visitor); }
06:34:20 <ricky_clarkson> Just added the <O>
06:34:29 <ski> ah, ok
06:35:04 <ski> newtype Maybe a = NewMaybe {visit :: forall o. o -> (a -> o) -> o}
06:35:48 <ski> (unfolded impl.s of visitor)
06:35:59 <boliver> in other words, the Church encoding of Maybe
06:36:16 <ski> m, more or less
06:41:17 <ski> newtype Maybe a = NewMaybe {accept :: forall o. MaybeVisitor o a -> o}
06:41:22 <ski> data MaybeVisitor o a = NewMaybeVisitor {visitNothing :: o , visitJust :: a -> o}
06:41:39 <ski> (maybe that's somewhat more close)
06:43:12 <ski> nothing = NewMaybe {accept = \mv -> visitNothing mv}
06:43:33 <ski> just a = NewMaybe {accept = \mv -> visitJust mv a}
06:50:58 <benja_> "This presentation contains content that your browser may not be able to show properly. This presentation was optimized for more recent versions of Microsoft Internet Explorer."
06:51:01 <benja_> -- http://web.cecs.pdx.edu/~sheard/OmegaHaskellWkShp.htm
06:51:10 <benja_> gosh, firefox is such an ancient version of microsoft internet explorer
06:51:28 <benja_> I suppose I need to upgrade. perhaps I should upgrade my OS to windows at the same time.
06:52:11 <xerox> That is... frameS?
06:52:13 <xerox> *frames
06:53:14 <vegai> benja_: he's a "Full Professor", he's knows better
06:53:47 <benja_> I see...
06:55:03 <Maddas> That warning page is generated automatically by PowerPoint.
06:56:11 <Philippa> strictly speaking, "optimised for more recent versions of MSIE" doesn't necessarily mean that it's being viewed in an older version
06:56:12 <Maddas> (As a quick search immediately reveals :-))
06:56:22 <Philippa> but it's still pretty stupid
06:56:37 <Philippa> OTOH, if firefox is pretending to be MSIE for whatever reason then you get what you deserve :-)
06:57:19 <benja_> =)
06:57:33 <dons> sigh. standards.
06:57:46 * Maddas doubts PowerPoint pays fparticular attention to non-IE browsers :-)
06:57:50 <Maddas> particular, even.
06:58:47 * carp_ wonders if being a full professor is dependent on having a large lunch
06:59:24 <vegai> I remember wondering about that earlier too
06:59:44 <vegai> universities in US tend to have their own titles, iirc
07:09:22 <SamB> carp_: haha
07:38:31 <lisppaste2> benja_ pasted "type checks interactively but not in a module" at http://paste.lisp.org/display/24730
07:39:23 <benja_> the above contains a term which type-checks when I paste it into ghci, but doesn't if I put it into the module and try to :load it
07:39:27 <benja_> anybody got an idea whY?
07:39:31 <benja_> s/Y/y/
07:42:55 <Lemmih> How did you paste it into ghci?
07:43:28 <benja_> :t Forall $ \x -> Forall $ \y -> all (\x -> x == x) (x ++ y) `Equals` all (\x -> x == x ) (y ++ x)
07:44:36 <Lemmih> Try with -fno-monomorphism-restriction
07:46:10 <yip> hi Lemmih
07:46:22 <ski> maybe it would be good to know what the type error was
07:48:25 <lisppaste2> benja_ annotated #24730 with "Details" at http://paste.lisp.org/display/24730#1
07:50:03 <benja_> Lemmih: same result
07:50:28 <benja_> (I'm not surprised by the type error, though, I'm surprised that ghci doesn't give it)
07:53:54 <Sn4k3> whats the diff between using the . operator and using parenthesis?
07:55:08 <xerox> Composition is nice to the eyes, in mild forms.
07:55:25 <xerox> It also eases code changing to some degree.
07:56:13 <lightstep> http://okmij.org/ftp/Haskell/Mr-S-P.lhs  --<-- this article is so cool
08:02:54 <xerox> It *is*!
08:04:23 <ski> very fun !
08:04:33 <araujo> hi hi
08:12:42 <Sn4k3> (head.reverse.take) n l why doesnt that work, while head (reverse (take n l))  does?
08:12:45 <Sn4k3> isnt that the same?
08:14:31 <ski> '(head.reverse.take) n l' is the same as 'head (reverse (take n)) l'
08:16:22 <Sn4k3> why do you need the '' ?
08:17:30 <ski> no
08:17:42 <ski> it's just quoting
08:17:45 <Sn4k3> oh
08:17:46 <Sn4k3> well
08:17:49 <Sn4k3> it doesnt work
08:18:07 <xerox> (reverse .) . take
08:18:20 <xerox>  = \n l -> reverse (take n l)
08:18:20 <ski> > let n = 3; l = "abcdefgh"; (.:) = (.) . (.) in  (head .: (reverse .: take)) n l
08:18:22 <lambdabot>  'c'
08:18:40 <ski> > let n = 3; l = "abcdefgh"; (.:) = (.) . (.) in  ((head . reverse) .: take) n l
08:18:41 <lambdabot>  'c'
08:19:16 <ski> (you can define fixity to avoid the extra parens)
08:19:31 <Sn4k3> ehm
08:19:38 <Sn4k3> where can I post my code
08:19:41 <xerox> ?paste
08:19:42 <lambdabot> http://paste.lisp.org/new/haskell
08:20:50 <roconnor> Sn4k3: have you put spaces around the .'s?
08:21:02 <roconnor> oh wait
08:21:04 <roconnor> nevermind.
08:21:19 <xerox> ski: that's intriguing
08:21:24 <lisppaste2> Sn4k3 pasted "meep" at http://paste.lisp.org/display/24736
08:21:31 <ski> xerox : what's ?
08:21:32 <Sn4k3> there
08:21:47 <roconnor> > let n = 3; l = "abcdefgh"; (..) = (.) . (.) in  (head .. (reverse .. take)) n l
08:21:47 <xerox> ski: one could use the number of dots as index of the number of arguments of the composed function :D
08:21:47 <lambdabot>  Parse error
08:21:53 <Sn4k3> I cant see the diff.
08:22:08 <roconnor> .. is taken I guess.
08:22:09 <ski> '..' is reserved
08:22:44 <Sn4k3> xerox: http://paste.lisp.org/display/24736
08:22:57 <ski> xerox : hrm ? ('(.:)' has three dots)
08:23:32 <xerox> ski: unfortunately
08:23:42 <roconnor> so does (.) . (.)
08:23:48 <roconnor> :)
08:23:49 <ski> but, two "lower" dots :)
08:23:57 <xerox> True :D
08:24:20 <ski> roconnor : that's why i choose '(.:)' (and '(.::)' etc)
08:24:40 <roconnor> Too bad I use (.:) for my contraction operator.
08:24:53 <ski> which is that ?
08:25:44 <ski> Sn4k3 : the problem is that '.' only passes one argument through the composition, so it doesn't work (easily) with multiple (curried) arguments
08:26:10 <ski> Sn4k3 : so, either tuple your arguments, or use one of the suggestions
08:26:21 <Sn4k3> so to be on the safe side always use () ?
08:26:35 <roconnor> ski: Um, it's an operator in differential geometry.
08:26:46 <Sn4k3> I have an exam tomorrow, and I cant complie with my pen and paper ;)
08:27:09 <ski> (roconnor : *synthetic* differential geometry, mayhaps ?)
08:27:14 <xerox> Sn4k3: the problem is the type of the functions.
08:27:17 <xerox> ?type (.)
08:27:18 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
08:27:32 <ski> ?type (.) . (.)
08:27:33 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
08:27:36 <xerox> Sn4k3: the first two arguments of (.) have type b -> c and a -> b.
08:27:54 <xerox> Sn4k3: take has type Int -> [a] -> [a], which is not in the form a -> b.
08:28:10 <roconnor> ski: I guess more generaly I use it for geometric algebra.
08:28:27 <xerox> Sn4k3: we can use the definition of (.) to reduce the expression to points free form, though.
08:28:36 <cjeris> roconner: interior product of vector + covector, \lrcorner ? (just curious)
08:28:38 <Sn4k3> xerox: my mind is spinning :)
08:28:44 <cjeris> s/conner/connor/ # sorry
08:28:51 <roconnor> yes, the interior product.
08:28:53 <Sn4k3> xerox: I'll stick to parantehsis instead then from now on to be safe
08:28:59 <xerox> Sn4k3: I.e. (f . g) = \x -> f (g x).  Then let's apply it to \n l -> reverse (take n l).
08:29:18 <xerox> Sn4k3: \n -> reverse . take n
08:30:19 <xerox> Sn4k3: do you understand that first phasE?
08:30:51 <lisppaste2> roconnor pasted "my 3D contraction operator" at http://paste.lisp.org/display/24738
08:31:00 <Sn4k3> xerox: hehe no, not really
08:31:17 <Sn4k3> I'm way too basic for that
08:31:19 <xerox> Sn4k3: Plug f = reverse; g = take n; in (f . g) = \l -> f (g l)
08:31:28 <xerox> What do you get?
08:31:42 <Sn4k3> whats the \ ?
08:32:14 <xerox> Lambda abstraction, it defines an anonymous function.
08:32:17 <xerox> f x = x + 2   ===   f = \x -> x + 2
08:32:35 * ski wonders what this 'interior product' is
08:32:38 <xerox> Those are equivalent.
08:32:57 <Sn4k3> fuck it, tnx for your time though
08:32:58 <cjeris> roconnor: just curious, it looks like you're silently dualizing (punning vectors and 1-forms). what are you using it for?
08:33:03 <Sn4k3> we arent on the same level ;)
08:33:33 <xerox> Sn4k3: do you understand better (f . g) x = f (g x) ?
08:33:53 <Sn4k3> yeah
08:33:55 <Sn4k3> that I got
08:33:56 <xerox> OK good.
08:33:57 <roconnor> cjeris: yep, it appears that way.  I have an inner product, so the there is a natural isomorphism with the dual space.
08:34:04 <norpan> xerox: those are almost equivalent, one is a function binding and one is a pattern binding :)
08:34:26 <roconnor> cjeris: but I was wrong when I said I was doing differential geometry.
08:34:30 <xerox> Sn4k3: now, take f = reverse, g = take n, and substitute that in the right hand side of that equation. What do you get'
08:34:32 <roconnor> I'm doing geometric algebra.
08:34:43 <roconnor> I was going to use it to write a ray-tracer.
08:34:55 <giksos> hi, what is the read instance for datatypes with infix constructors? What should I type to read the value @A `And` A@ for instance?
08:34:56 <roconnor> But I never got past the geometry.
08:34:59 <Sn4k3> xerox: reverse ( take n)
08:35:09 <xerox> Sn4k3: you miss one parameter, the x
08:35:26 <cjeris> roconner: gotcha :)  looks like this could benefit from, what do you call it, dependent types.  like the rank should be a number parameter of the type, so you don't have to write all those instanes.
08:35:29 <Sn4k3> hmm
08:35:30 <cjeris> s/nes/nces/
08:35:44 <Sn4k3> xerox: isnt n=x the argument?
08:35:56 <xerox> Sn4k3: \x -> f (g x); f = reverse; g = \n -> take n
08:35:58 <xerox> :)
08:35:59 <roconnor> cjeris: yep.  But it isn't so bad for the 3D case.
08:36:17 <roconnor> I actually have a general case too, but without the dependent types of course.
08:36:25 <Sn4k3> xerox: mind spinning again :)
08:36:27 <xerox> What does that expand to?
08:36:28 <roconnor> newtype Clifford = Clifford (Map (Set Index) Scalar) deriving Show
08:36:30 <xerox> Yuck.
08:36:31 <Sn4k3> xerox: no clue
08:36:34 <xerox> \x -> reverse (\n -> take n x)
08:36:42 <xerox> (Just substitute)
08:36:46 <Sn4k3> I'm hitting the gym, gotta get rid of the anger
08:36:47 <roconnor> cjeris: I love it. Map and Set.
08:36:48 <cjeris> how do you generate the instances? or do you give up the type system enforcement of rank stuff and throw exceptions when something doesn't match up?
08:36:51 <Sn4k3> tnx for your efford
08:36:55 <xerox> Sn4k3: have fun!
08:36:58 <Sn4k3> tnx :)
08:36:59 <Sn4k3> ciao
08:37:10 <roconnor> cjeris: I put everything into one type.
08:37:13 <xerox> Italiano? :)
08:37:14 <Daveman> xerox :D
08:37:15 <roconnor> called Clifford.
08:37:24 <xerox> Hey Daveman
08:37:33 <Daveman> :)
08:37:37 <roconnor> such is life without dependent types.
08:37:48 <cjeris> roconnor: newtype BigRedDog = -- ... :)
08:37:56 <roconnor> I suppose I could fake it with haskells crazy type classes.
08:38:07 <roconnor> cjeris: :)
08:45:00 <giksos> now that it's a bit calmer, I try to ask again: what is the read instance for datatypes with infix constructors? What should I type so that the value @A `And` A@ gets parsed?
08:47:33 <dons> giksos: I'm not sure. I've not seen it done before. Perhaps query haskell-cafe@
08:48:09 <dons> (what does the deriving Show instance for show print?)
08:48:18 <ValarQ> dons!
08:48:24 <dons> ValarQ!!
08:48:31 <dons> ?users
08:48:32 <lambdabot> Maximum users seen in #haskell: 235, currently: 207 (88.1%)
08:48:42 <ValarQ> dons: im having some silly plugs problems again
08:49:22 <ValarQ> dons: runplugs keep saying: ghc-6.4.2: unknown package: lambdabot
08:49:22 <audreyt> giksos: see Report. figure 8.
08:49:26 <audreyt> http://www.haskell.org/onlinereport/derived.html
08:49:27 <lambdabot> Title: The Haskell 98 Report: Derived Instances
08:49:37 <audreyt> section 10.5.
08:49:42 <dons> ValarQ: lambdabot package?
08:49:55 <dons> that's very odd
08:50:27 <ValarQ> maybe my cabal file is corrupt, i think i had some conflict in it
08:51:26 * dons -> sleep
08:51:37 <ValarQ> dons: g'dnite
08:55:28 <giksos> dons: show prints "A And A". Feeding it back to read produces "no parse"
08:55:44 <giksos> audreyt: I read the report, but it didn't help
08:56:17 <giksos> do I have to use @:A:@ as my constructor, not just @A@?
08:57:56 <audreyt> aye. or write your own Read instance
08:58:11 <audreyt> that parses both @A x y@ and @x `A` y@
08:58:17 <audreyt> the report shows how, I think
09:04:47 <giksos> hm, in fact, even the example from the report fails with my ghc 6.4.1
09:06:45 <lispy> bleh, my 6.4.2 compile failed due to lack of disk space :(
09:07:43 * lispy begins to wonder if he was meant to ever have a working copy of 6.4.2 ;)
09:08:13 <xerox> Why don't you go for 6.5-darcs?
09:09:23 <lispy> every time i've tried to build by hand it has failed
09:09:40 <xerox> What architecture do you need it for?
09:09:43 <lispy> i'm giving up on building by hand using using whats in darwinports
09:09:46 <lispy> osx
09:09:51 <xerox> PPC or Intel?
09:09:57 <lispy> PPC
09:10:11 <xerox> I am sorry I can't help you there.
09:10:19 <lispy> :)
09:11:24 <lispy> the funny thing is, closing ff freed up over 300megs of disk space...
09:11:37 <xerox> Yuck.
09:12:16 <lispy> the next thing i need to do to free up space is move my iphoto library
09:12:39 <lispy> but really i just want a bigger harddrive...but being an ibook i'm not sure it's worth it
09:12:48 <lispy> maybe wait a couple more years and just buy a new one
09:17:07 <lispy> grr...500 megs was not enough to complete the install step....
09:18:08 <lament> so i'm trying to convert my python program to haskell
09:18:35 <lament> i have Scale objects, and by far the most scales are based on an underlying 12-semitone chromatic scale.
09:18:39 <lament> but it doesn't really have to be 12.
09:19:02 <lament> So, i have number of semitones as an optional parameter to the constructor of the Scale class with the default value of 12.
09:19:46 <ricky_clarkson> The annoying thing is that Bach compensated for harmonics, so calculating good scales isn't as easy as multiplying by this value all the time:
09:19:47 <xerox> lambdabot: what about using a list for semitones?
09:19:56 <lament> i am not lambdabot :(
09:19:56 <ricky_clarkson> > 2^(1/12)
09:19:59 <lispy> lament: there is a way to do optional parameters with type classes, but i've never looked into it...it's sort of a trick
09:20:01 <lambdabot>  Add a type signature
09:20:12 <ricky_clarkson> No, I don't know how.
09:20:25 <xerox> lispy: it's really simple, if you mean doing polyvariadic functions.
09:20:43 <lament> oh, also, the scales themselves:
09:20:44 <lispy> xerox: i mean the thing with ?x
09:21:03 <lament> ideally i want to have a set of semitones (numbers) that are in the scale. It's an infinite set
09:21:10 <xerox> Oh, those.
09:21:24 <lament> in Python, I subclassed the list class, and made it sort of infinite
09:21:38 <xerox> lambdabot: then use a list!
09:21:42 <xerox> SIGH.
09:21:50 <xerox> Why do I keep talking to lambdabot now.
09:21:52 <lament> i am SO not lambdabot.
09:22:08 <lament> so yeah, the problem is that this list is infinite in both directions.
09:22:24 <xerox> Oh, interesting.
09:22:33 <int-e> lament: @botsnack
09:22:35 <xerox> ?oldwiki TyingTheKnot
09:22:36 <lambdabot> http://www.haskell.org/hawiki/TyingTheKnot
09:22:48 <int-e> lambdabot: @botsnack
09:22:49 <lambdabot> :)
09:22:49 <xerox> ^- circular data structures
09:22:52 <lament> int-e: yo momma
09:23:39 <lament> i guess i won't bother making it a data structure at all. i'll just make a function that takes a semitone and returns whether the semitone is in the scale.
09:23:59 <xerox> As you please.
09:24:28 <lament> but it's not as cool :)
09:25:17 <int-e> implicit parameters are just an ugly way to avoid typing in places where a Reader or ReaderT should be used.
09:25:46 <int-e> that's typing as in 'hacking on a keyboard' btw.
09:26:49 <xerox> As in "giving types" :D
09:31:28 <xs> cabal can't deal with -Wl,-rpath,/usr/blah/blah in ld-options? it seems to strip away the commas at some point, so things depending upon such a library cannot build. (though the library itself will build)
09:33:22 <lispy> hmm..i have lots of free space now...at 1.5 GB and still going up :)
09:33:45 <lispy> ah, and finally ghc 6.4.2
09:35:25 <xerox> Yarrr!
09:41:19 <ski> @yarr
09:41:19 <lambdabot> Avast!
09:41:51 <xerox> ?quote
09:41:52 <lambdabot> ozone says: joelr1: our C++ guru at work is getting a bit sick of me saying "ah, so that's like <x> in haskell, but not quite as elegant..."
09:44:03 <ski> @ghc
09:44:04 <lambdabot>  Implicit parameters escape from the monomorphic top-level binding(s)
09:45:50 <xerox> Implicit parameters! That's how they are called, lispy :D
09:46:32 <int-e> I already said that. :/
09:46:52 <xerox> Wops.
09:47:06 <vegai> how do those things work, by the way?
09:47:44 <xerox> http://haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#implicit-parameters
09:47:48 <lispy> no idea, i just saw them mentioned in the history of haksell paper
09:48:11 <lambdabot> Title: 7.4. Type system extensions
09:48:12 <int-e> don't ask. Haskell' voted them down.
09:48:14 <int-e> :-P
09:48:26 <vegai> Yeah. Papers.
09:51:42 <xerox> :(
09:51:49 <xerox> TheHunter will not like that. Yarr.
09:51:52 <int-e> To be precise, the second straw poll indicates that pretty much all of the committee members don't like them. 3 didn't vote on it.
09:52:06 <lispy> whoa
09:52:09 <lispy> they seem so useful
09:52:15 <int-e> all other answers are N (no) or R (definitely reject)
09:53:09 <xerox> You've got a 6.4.2 to play with them too :P
09:53:11 <int-e> in my opinion, they make it hard to follow the flow of information in pure haskell code and thus eliminate one of the biggest advantages that haskell has.
09:53:29 <lispy> one nice thing about darwin ports is that it leaves all old version of libraries laying around when it upgrades :(
09:53:47 <lispy> now i see where all my disk space went...i've freed over a gig by deleting this old libs
09:53:55 <int-e> lispy: yay, all backward compatible. but you want a bigger hard drive :)
09:54:16 <ski> (they aren't *pure* haskell code, though)
09:54:33 * lispy expected darwinports to do reasonable things like, say, apt
09:54:37 <int-e> they also add complexity to the type system.
09:55:21 <xerox> Yay, this looks good.
09:55:42 <ski> (but they are like commutative 'Reader')
09:58:53 <xerox> Hrrrmmmpf bus errors.
10:00:34 <xerox> The only Gtk2Hs demo working on macintel with gtk2.10 seem to be the cairo clock, it's unfortunate, but looks nice :)
10:05:55 <mnislaih> eivuokko ping
10:06:17 <xerox> http://darcs.haskell.org/~paolo/tmp/osxcairoclock.png
10:06:43 * lispy makes the mental note that darwinports is extremely wastefull with diskspace
10:07:08 <xerox> Yarr, looks nice... looks also in a square for some reason, but it's nice nevertheless.
10:07:55 <roconnor> xerox: look pretty awful to me.
10:08:16 <roconnor> the minute hand looks pretty off center.
10:08:31 <xerox> roconnor: I just noticed that too O_o
10:08:42 <int-e> heh, it looks the same here. I have no composite extension.
10:09:03 <roconnor> and the shadow of the second hand is not right.
10:09:09 <roconnor> and it's not ticking ;)
10:09:28 <vegai> xerox: anything more informative?
10:09:34 <vegai> (regarding implicit parameters)
10:09:39 <xerox> vegai: nope.
10:09:42 <vegai> ok :)
10:09:50 <int-e> the hour hand shadow is too wide *shrugs*
10:10:10 <roconnor> wait, the minute hand is in the place of the shadow of the minute hand.
10:10:15 <int-e> and the 3d effect in the center is disturbing
10:10:21 <xerox> haha
10:10:28 <xerox> This clock is disgusting! In the end.
10:10:36 <roconnor> I think someone made a coding error.
10:10:40 <roconnor> in Haskell!
10:10:44 <roconnor> omg
10:10:45 <xerox> It is a translation from a C source.
10:10:52 <roconnor> oh, that explains it.
10:10:56 * xerox phews.
10:11:01 <int-e> and the C clock has evolved since.
10:11:22 <xerox> Fell free to submit a patch...
10:11:45 <roconnor> it's too far gone... Time for a rewrite ;)
10:12:29 <xerox> That too! New demos are always welcome.
10:12:39 <int-e> http://macslow.thepimp.net/?page_id=23
10:12:41 <lambdabot> Title: digital home of MacSlow Â» MacSlow&#8217;s Cairo-Clock
10:12:58 <xerox> Yuck.
10:15:10 <xerox> It even uses svg for the clock parts.
10:15:44 <xerox> That's how they provide theming...
10:15:47 <int-e> why yuck?
10:15:53 <xerox> Good work :)
10:16:22 <int-e> anyway, it was that clock that inspired the gtk2hs one ... only the gtk2hs one didn't evolve further.
10:16:31 <xerox> Yes.
10:16:53 <xerox> We have SVG support, though.
10:17:04 <xerox> It could be possible to write _that_ in Haskell now.
10:17:52 <int-e> I agree, but who's interested in clocks?
10:18:02 <xerox> Timekeepers?
10:18:17 <xerox> It's a nice demo to show off anyway.
10:19:32 <roconnor> the swiss?
10:21:39 <xerox> The white rabbit!
10:22:03 <tennin> mom says my first word was "tick-tock"
10:24:08 <eivuokko> mnislaih, pon
10:24:13 <eivuokko> *pong
10:24:55 <mnislaih> ah Esa, I saw your "testsuite in windows" thread at some haskell mailing list
10:25:09 <mnislaih> I had a question but I think I found the answer myself
10:25:26 <mnislaih> my python executable is not the cygwin version
10:25:55 <eivuokko> Huh!
10:26:06 <mnislaih> but thanks anyway for starting the thread in the first place! it has saved me hours, or possibly days
10:26:07 <eivuokko> How'd you run testsuite if it's not?
10:26:21 <eivuokko> (Except if you fix the driver yourself)
10:26:23 <mnislaih> I had another python executable around, and that's what msys is using
10:26:37 <mnislaih> the testsuite  does not run!
10:26:42 <eivuokko> lol
10:26:59 <mnislaih> I'm in the process of installing the cgwin py
10:27:25 <eivuokko> You can try my patch from "Enable timeout in Windows and don't require cyginw python"
10:27:56 <mnislaih> no need. I already went for the patch spj suggested
10:28:13 <eivuokko> Ah, I couldn't pull that.
10:28:31 <eivuokko> Not that I understand how it can exactly help.
10:28:42 <eivuokko> (It was for ghc iirc, not for testsuite)
11:01:45 <aleko> can someone help me with this type? it says "inferred type is less polymorphic than expected".  ([String] -> s) -> State Parser (Maybe s)
11:02:22 <aleko> wait! wrong one.  hang on
11:08:37 <aleko> never mind, fixed it (i think)
11:38:50 <LordBrain> I stumbled once upon a book on creating a compiler which had Simon Peyton Jones among others among the authors and was available online.. in pdf. It covered topics like graph reduction among other things... Does anyone know where it might have been?
11:39:33 <xs> http://research.microsoft.com/~simonpj/papers/slpj-book-1987/ ?
11:39:34 <lambdabot> Title: The Implementation of Functional Programming Languages
11:39:49 <LordBrain> ah that might be it...
11:40:13 <LordBrain> yes i believe it is
11:40:15 <LordBrain> thankyou
11:45:58 <LordBrain> drats.. all jpegs...
11:46:01 <LordBrain> heh
11:52:21 <tibbe> ?users
11:52:22 <lambdabot> Maximum users seen in #haskell: 235, currently: 204 (86.8%)
11:52:46 <jrmole> LordBrain, it's fairly out of date
11:53:04 <jrmole> and iirc inconsistently updated from miranda to haskell or gofer or something
11:53:57 <jrmole> http://citeseer.ifi.unizh.ch/peytonjones92implementing.html is a good paper about the code generator at the core of ghc
11:53:59 <lambdabot> Title: Implementing lazy functional languages on stock hardware: the Spineless Tagless  ...
11:54:39 <jrmole> and has references to a lot of other stuff
11:55:48 <psi> jrmole: out of date in what sense? I have the book, but I haven't had the energy the read it yet.
11:57:29 <jrmole> afaik the STG-machine is strictly an improvement over the stuff from that book (G-machine and TIM)
11:57:39 <mwc> Trying to debug an off by one error, is there a way to get a line number where the exception originated from?
11:57:40 <mwc> *** Exception: Ix{Int}.index: Index (16) out of range ((0,15))
11:58:07 <jrmole> i only read about half of it, but it was pretty confusing.  i understood the STG paper a lot better even though it's a more "advanced" abstract machine
11:58:42 <jrmole> mwc: you won't get line numbers, but you can use Debug.Trace.trace around your array indexing
11:58:50 * psi nods
11:59:37 <psi> I don't know what any of that stuff is.
12:00:04 <mwc> jrmole, I was trying (desperately) to avoid that
12:00:08 <cathper> I made a merge function that merges two sorted non-empty lists into another of the same type. Then I made "hammingList :: [Int]; hammingList = 1 : merge (map (2*) hammingList) (merge (map (3*) hammingList) (map (5*) hammingList))". Since I used [Int] there is a overflow and the list begins containing negative numbers. I figured that out since I used "length (takeWhile (0 <=) hammingList)", but my first try was "max (takeWhile...)". Hugs gives an error 
12:00:20 <jrmole> psi: which stuff?
12:01:22 <psi> jrmole: STG-machine, G-machine or TIM.
12:04:30 <cathper> Hmm, did it all show up?
12:04:57 <jrmole> various abstract machines, with operational semantics simple enough to be realized in a language like C, but which express graph reduction, etc. well enough to serve as an easy compilation target for a language like Core (which is basically heavily desugared Haskell)
12:05:00 <int-e> Hugs gives an error ...
12:05:24 <int-e> cathper: probably not
12:05:35 <cathper> Hugs gives an error like this: "ERROR - Cannot find "show" function for: *** Expression : max (takeWhile (0 <=) hammingList) *** Of type    : [Int] -> [Int]". So, how do I define a show function that fixes that?
12:06:01 <int-e> you don't
12:06:08 <int-e> you use maximum instead ;)
12:06:13 <int-e> @type max
12:06:15 <int-e> @type maximum
12:06:18 <lambdabot> forall a. (Ord a) => a -> a -> a
12:06:19 <lambdabot> forall a. (Ord a) => [a] -> a
12:06:24 <xerox> cathper: what is merge?
12:06:39 * cathper is stupid.
12:06:45 <cathper> int-e: thanks :-)
12:07:48 <xerox> http://fooling.lambdabot -- cathper, about stupidity: http://video.google.com/videoplay?docid=342080286217914779
12:07:49 <psi> jrmole: so, are these machines intended to execute code which was originally written in haskell, basically?
12:07:50 <int-e> in general when it wants a show function for a function, the mistake is probably that the result is a function, not that there's no show for the result :)
12:08:47 <cathper> xerox: which pastebin are preferred?
12:08:59 <xerox> @paste
12:08:59 <lambdabot> http://paste.lisp.org/new/haskell
12:09:04 <int-e> > succ
12:09:06 <lambdabot>  Add a type signature
12:09:10 <int-e> > succ :: Int -> Int
12:09:12 <lambdabot>  <Int -> Int>
12:09:22 <int-e> of course there may be exceptions like this
12:09:31 <jrmole> psi: or any lazy, pure functional language with pattern matching and algebraic data types
12:09:40 <jrmole> but that's pretty much synonymous with haskell these days ;)
12:09:45 <jrmole> by construction in fact
12:10:01 <int-e> Clean?
12:10:05 <lisppaste2> cathper pasted "merge" at http://paste.lisp.org/display/24746
12:10:09 <psi> ok, thanks :)
12:10:17 <jrmole> > succ :: (Num a) => a -> a
12:10:18 <lambdabot>  add (Enum a) to the expected type of an expression
12:10:18 <lambdabot>   In the expression: s...
12:10:26 <jrmole> > succ :: (Enum a) => a -> a
12:10:27 <lambdabot>  Add a type signature
12:10:29 <jrmole> heh
12:10:34 <jrmole> int-e, good point
12:10:44 <int-e> was/is Miranda lazy?
12:10:52 <jrmole> don't know how Clean is implemented, other than that it's bloody fast
12:11:00 <psi> it was
12:11:02 <jrmole> yeah, but it's been subsumed by haskell more or less
12:11:22 <xerox> > undefined :: Typeable a => a -> a
12:11:23 <lambdabot>  Add a type signature
12:11:23 <jrmole> i don't think Miranda is better for anything, and you can probably automatically translate from miranda to haskell
12:11:25 <xerox> Yarrr.
12:11:40 <jrmole> > undefined :: Int -> Int
12:11:41 <lambdabot>  <Int -> Int>
12:11:58 <xerox> Of course :)
12:12:23 <int-e> of course, one of Haskell's goals was to have a common lazy pure functional programming language - I guess that's what you meant with 'by construction'.
12:12:37 <cathper> xerox: did you see it? http://paste.lisp.org/display/24746
12:13:21 <jrmole> yeah
12:13:30 <jrmole> this implementation stuff was originally done for LML, i believe
12:14:10 <jrmole> a lot of things specific to haskell (monads, typeclasses, etc.) are more or less desugared before you get to the STG level anyway
12:16:14 <xerox> Thank cathper
12:21:11 <tibbe> does Cabal build by creating a dir with the full paths (i.e. dist/build/usr/local/bin/myprog) or does it create something like dist/build/myprog and add prefixes when copying?
12:22:18 * tibbe is trying to figure out where the install paths are computed so he can save them to a file
12:23:58 <xerox> The latter
12:24:53 <tibbe> hmm, ok
12:26:14 <eivuokko> You're trying to do the same as 2.2 in user guide?
12:28:10 <tibbe> eivoukko, who, me?
12:29:33 <tibbe> eivuokko * (my autocompletion isn't working, sorry)
12:30:18 <tibbe> I'm not just trying to get to the data-files, I need a complete list of all files installed (including) their full paths
12:30:50 <tibbe> I've written a function the does that assuming that packages are built with their full paths inside some build dir
12:30:59 <tibbe> however they aren't built that way
12:35:56 <jbalint> what is id?
12:36:20 <xerox> Are you referring to the `id :: forall a. a -> a' function?
12:36:36 <jbalint> yeah
12:36:47 <xerox> It is the only meaningful function of type forall a. a -> a :)
12:37:08 <mnislaih> @seen Lemmih
12:37:08 <lambdabot> Lemmih is in #ypn, #haskell-overflow and #haskell. I last heard Lemmih speak 3 hours, 25 minutes and 55 seconds ago.
12:38:18 <xerox> jbalint: the type says "for all values of type a, you give me a value of that type, and I'll return a value of the same one."
12:39:25 <jbalint> can you show me a simple use of it?
12:39:43 * monochrom is at a Xavier Leroy talk :)
12:39:43 <xerox> Try yourself with "> id whatevervalue" here
12:39:55 <ths> Is there some way to convince GHC to not deleting intermediate assembler files?
12:39:59 <xerox> > id 1
12:40:01 <lambdabot>  1
12:40:01 <jbalint> Yeah, but it just seesm to do nothing?
12:40:09 <xerox> jbalint: that's the point of it :)
12:40:19 <jbalint> Then how is it meaningful?
12:40:33 <xerox> jbalint: what other implementations of 'forall a. a -> a' can you think of, beside errors?
12:41:17 <jbalint> i dont know.
12:41:19 <ths> Ah, even the manpage could have told me. Never mind. :-)
12:42:00 <xerox> jbalint: for ever value of *whatever* type you get in input, you have to return a value of the same type.
12:42:25 <xerox> jbalint: but I see your point, per-se seem unuseful.
12:42:39 <jbalint> alright. thanks.
12:43:46 <xerox> > map (id &&& length) [[1,2,3],[4,5],[6,7,8,9],[0]]
12:43:47 <lambdabot>  [([1,2,3],3),([4,5],2),([6,7,8,9],4),([0],1)]
12:44:01 <xerox> Dunno :)
12:44:11 <jbalint> what's &&&?
12:44:21 <xerox> (f &&& g) x = (f x, g x)
12:44:23 <monochrom> an operator for arrows
12:44:28 <mux> Starting program: /usr/home/mux/haxml/haxml
12:44:28 <mux> haxml: internal error: ASSERTION FAILED: file GC.c, line 1726
12:44:37 <monochrom> Ah, but can be specialized to what xerox gives
12:44:51 <xerox> Right, it is more general than that, that is the Arrow (->) instance definition.
12:44:53 <mux> now that i compiled with -debug, GHC suggests tht I report my problem as a compiler bug
12:45:02 <xerox> Which is quite a nice instance to use :)
12:45:09 <jbalint> xerox: thanks, that example makes meaningful use of it :)
12:45:19 <xerox> There are more!
12:45:39 <jbalint> Yeah, I see the pattern.
12:45:59 <tibbe> @seen Lemmih
12:45:59 <lambdabot> Lemmih is in #ypn, #haskell-overflow and #haskell. I last heard Lemmih speak 3 hours, 34 minutes and 46 seconds ago.
12:46:08 <mux> is there some GHC option to request only debugging symbols but no assertions checks?
12:46:09 <tibbe> Lemmih, ping
12:46:20 <xerox> > map (even *** odd) $ zip [1..4] [4..1]
12:46:21 <lambdabot>  []
12:46:25 <xerox> Duh.
12:46:43 <xerox> This is unespected...
12:46:54 <xerox> Oh yes.
12:46:58 <xerox> > map (even *** odd) $ zip [1..4] [4,3..1]
12:46:59 <lambdabot>  [(False,False),(True,True),(False,False),(True,True)]
12:47:30 <xerox> > first (*2) (1,'<-')
12:47:30 <lambdabot>  Improperly terminated character constant
12:47:34 <xerox> > first (*2) (1,"<-")
12:47:36 <lambdabot>  (2,"<-")
12:47:47 <xerox> > second (/2) ("->",2)
12:47:48 <lambdabot>  ("->",1.0)
12:47:52 * xerox grins
12:48:16 <xerox> > ((*3) >>> sutract 10 >>> (*2)) 1
12:48:17 <lambdabot>  Not in scope: `sutract'
12:48:21 <xerox> > ((*3) >>> subtract 10 >>> (*2)) 1
12:48:23 <lambdabot>  -14
12:48:27 <xerox> Too many typos, sorry.
12:48:35 <madpickle> ***? interesting
12:48:45 <xerox> Yesh!
12:49:23 <xerox> instance Arrow (->) where (f &&& g) (x,y) = (f x,g y); (f *** g) x = (f x,g x); first f (x,y) = (f x,y); second f (x,y) = (x,f y); (>>>) = flip (.)
12:49:48 <xerox> (Some are derived from the others so you probably won't see all of them implemented manually, usually.)
12:50:30 <madpickle> @type (***)
12:50:31 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:50:50 <xerox> A nice way to read Arrow type is this one:
12:51:44 <xerox> ?type (***) :: (Arrow (~>)) => (a ~> b) -> (c ~> d) -> ((a,c) ~> (b,d))
12:51:45 <lambdabot> (Arrow (~>)) => (a ~> b) -> (c ~> d) -> ((a,c) ~> (b,d)) :: forall (~> :: * -> * -> *) a b c d. (Arrow ~>) => ~> a b -> ~> c d -> ~> (a, c) (b, d)
12:51:55 <xerox> If you have a nice `~' char :)
12:55:36 <lightstep> @seen lumi
12:55:36 <lambdabot> lumi is in #perl6. I don't know when lumi last spoke.
12:58:14 <tibbe> anyone know in which timezone Lemmih lives?
13:00:18 <xerox> .dk, GMT+1 ?
13:00:21 <xerox> @localtime Lemmih
13:00:24 <lambdabot> Local time for Lemmih is Fri Aug 25 21:58:11 2006
13:03:50 <tibbe> xerox, ok, thanks
13:39:00 <dcoutts__> @arr
13:39:00 <lambdabot> Ahoy mateys
13:39:11 <dcoutts__> @localtime dons
13:39:13 <lambdabot> Local time for dons is Sat Aug 26 06:36:40 2006
13:39:21 <dcoutts__> far too early
13:41:52 <mux> dcoutts__: !
13:42:04 <mux> I've been hunting you for a few days :-)
13:42:35 <dcoutts__> mux: I'm away :-)
13:42:41 <mux> heh
13:42:46 * dcoutts__ is currently in Stockholm
13:43:03 <mux> could I talk with you about some crash I'm haivng with a gtk2hs program?
13:44:13 <mux> I have a simple 53 lines testcase
13:44:21 <mux> it could be even shorted
13:44:25 <mux> shorter, rather
13:45:59 <mnislaih> dcoutts:
13:46:07 <dcoutts__> mux: great, send it to the devel list
13:46:08 <mnislaih> Stockholm is great at this time of the year
13:46:18 <mux> dcoutts__: ok, doing it now
13:46:43 <dcoutts__> mnislaih: I've only seen the train station and hostle so far. Just arrived.
13:46:44 <mnislaih> I stayed for a year there. Really ought to go back
13:46:53 <dcoutts__> I'll be here for 5 weeks
13:47:09 <mnislaih> wow, great fun
13:47:12 <dcoutts__> but for the next few days I'm on holiday
13:47:16 <dcoutts__> going north!
13:47:23 <dcoutts__> artic circle
13:47:24 <mnislaih> specially love the barbeques in public parks
13:47:45 <mux> dcoutts__: it may be a bug in GHC's garbage collector
13:47:52 <dcoutts__> mux: I'll have a look when I get back, (unless Axel figures it out first)
13:48:00 <dcoutts__> mux: is it a segfault?
13:48:04 <mux> I'm going to do a few more tests
13:48:07 <mux> yep, it is
13:48:07 <dcoutts__> ok
13:48:10 <ndm> dcoutts__: where are you now?
13:48:15 <dcoutts__> ah, probably our fault then
13:48:20 <dcoutts__> ndm: Stockholm
13:48:22 <mux> compiling with -debug produces an assertion failure in GHC though
13:48:36 <dcoutts__> mux: hmm, ghc version?
13:48:43 <mux> 6.4.2
13:48:52 <dcoutts__> that's usually ok
13:49:02 <mux> yep :-P
13:49:04 <dcoutts__> likely a ref counting bug or similar
13:49:13 * dcoutts__ is intregued now
13:49:21 <dcoutts__> you've sent the code?
13:49:24 <mux> not yet
13:49:27 <mux> if you want I can do it now
13:49:36 <dcoutts__> sure, why not
13:49:43 <mux> it simply crashes when I add too much stuff in my treeview
13:49:50 * dcoutts__ scans through his 500 other emails
13:49:53 <dcoutts__> mux: ah
13:49:58 <dcoutts__> mux: gtk2hs-0.9.10 ?
13:50:04 <dcoutts__> or darcs version
13:50:39 <mux> what makes me think GHC might be causing troubles is that if I lower the amount of items to enter os that it doesn't crash at first when clicking the button that fillls the treeview, and if I click several times, it also crashes but I'm clearling the liststore each time
13:50:56 <mux> 0.9.10 yes
13:51:15 <mux> damn typos
13:51:32 <dcoutts__> mux: there's a known bug in that area, fixed in the dev version
13:51:39 <dcoutts__> but we've got a seperate patch...
13:51:44 * dcoutts__ finds said patch
13:52:01 <mux> damn!
13:52:03 <mux> so cool
13:52:08 <mux> I'll add it to the FreeBSD port
13:56:10 <mux> you'd better not disappear or I'll get angry :D
13:56:44 <dcoutts__> mux: http://haskell.org/~duncan/gtk2hs/gtk2hs-0.9.10-store.patch
13:57:07 <mux> thank you so much
13:57:12 <mux> going to test it right now.
13:57:58 <mux> omg it's a one-line patch :-)
13:58:14 <mux> not allocating enough actual memory to hold the thing?
14:07:47 <svref> Can someone type a "case" expression that uses a guard w/o a syntax error?
14:07:57 <svref> (this is suprising hard to google)
14:08:29 <mauke> > case 1 of _ | True -> "ok"
14:08:30 <lambdabot>  "ok"
14:08:38 <int-e> > case () of () | False -> 23 | True -> 42
14:08:39 <lambdabot>  42
14:08:48 <svref> thanks!
14:18:10 <dcoutts__> mux, yep, it was a c2hs bug. It wasn't calculating the struct size correctly. so we're doing it manually 'til c2hs is fixed.
14:18:35 <mux> dcoutts__: ow, nasty :)
14:18:55 <dcoutts__> aye, axel found it. It was a tricky one to track down.
14:19:02 <mux> I'll tell you if the patch worked OK as soon as gtk2hs is done building, and I'll have the patch added in a few days at most
14:19:18 <mux> yeah, this typically sounds like very annoying to find
14:19:22 <dcoutts__> cool
14:19:44 <dcoutts__> mux: we're using that patch in the gentoo ebuild
14:19:48 <mux> if the maintainer is responsive it should be done soon, if not, I'll wait for a few days worth of timeout before committing it myself
14:19:53 <mux> and you didn't tell me!!! :-)
14:20:04 <dcoutts__> sorry :)
14:22:29 <dcoutts__> @tell shapr I'll be back in Stockholm on the 1st, and will be done with the ByteString paper by the 4th, so we should meet up! :-)
14:22:30 <lambdabot> Consider it noted.
14:22:48 <dcoutts__> @tell shapr oh, and I brought my unicycle
14:22:49 <lambdabot> Consider it noted.
14:25:18 <mux> dcoutts__: shock! your patch works wonders ;-)
14:25:38 <dcoutts__> mux: great
14:25:38 <mux> if only I hard corenered you earlier, I wouldn't have banged my head on this heh
14:25:43 <dcoutts__> heh
14:25:44 <mux> mailing the maintainer
14:26:14 <ndm> dcoutts__, does anyone have any kind of list of things which need doing to put Gtk2hs in cabal? and how much work is it likely to be?
14:26:33 <dcoutts__> mux: if you emailed the gtk2hs dev or users list you might like to post a follow-up with that patch url.
14:26:41 <mux> I didn't
14:26:47 <dcoutts__> ndm: there's a list in my head somewhere
14:27:22 * ndm attempts to read dcoutts__'s brain
14:27:27 <mux> btw, I've been meaning to ask you if there are known interaction problems when using forkOS with gtk2hs
14:27:32 <mux> I expect forkIO to not work
14:27:51 <mux> but I don't know how much decoration glib puts in his pthread wrapper libraries
14:28:02 <mux> or are there glib bindings one should use?
14:28:44 <dcoutts__> mux: the threaded runtime does not work with gtk2hs yet.
14:29:13 <dcoutts__> mux but ordinary forkIO is fine if you read about the necessary magic in the gtk2hs FAQ
14:29:24 <mux> ok, I will
14:29:59 <mux> it's pretty darn needed to have at least one mean of doing threading in a gui :)
14:30:46 <ndm> mux, i second that!
14:31:13 <ndm> GuiHaskell has unfortunately stalled until Gtk can do something thread like
14:31:36 <mux> this FAQ entry looks very nice
14:32:15 <mux>   timeoutAddFull (yield >> return True)
14:32:16 <mux>                  priorityDefaultIdle 50
14:32:17 <mux> hahahha
14:32:20 <dcoutts__> @arr
14:32:20 <lambdabot> Yeh scurvy dog...
14:32:24 <mux> sorry, but this is very funny :è)
14:32:27 <dcoutts__> aye
14:32:30 <dcoutts__> it's a hack
14:32:33 <mux> clearly
14:32:36 <mux> I love it
14:32:38 <dcoutts__> heh
14:32:44 * mux adds it to his most-loved hacks list
14:33:01 <dcoutts__> it works quite nicely (except on windows as ndm discovered)
14:33:09 <mux> ouch, poor ndm :-(
14:33:14 <ndm> yes, poor me!
14:33:17 <dcoutts__> I talked to JaffaCake about a better solution
14:33:47 <ndm> oh, btw, i have an initial version of a Hoogle Gtk2Hs gui
14:33:53 <dcoutts__> cool
14:40:27 <mux> dcoutts__: those two lines are especially funny when you consider this is more or less how threading is implemented in many userland threading implementations
14:40:37 <mux> many just use SIGALARM
14:45:58 <cathper> Hmm, my first thought was that " (\x -> ( \x -> x*x)) 2 3" would produce an error because x is used as the name of an argument twice. Though "(\x x -> x*x) 2 3" produces an error.
14:47:47 <dcoutts__> mux: right :-)
14:48:23 <dcoutts__> cathper: one \x shadows the other one
14:48:38 <dcoutts__> (\x -> ( \x -> x*x) = (\_ -> ( \x -> x*x)
14:49:05 <cathper> Yeah, I see.
14:49:43 <cathper> But the outer x isn't "shadowed" when using \x x ->.
14:50:07 <jrmole> yeah, haskell requires patterns be linear
14:53:43 <araujo> cathper, they are in the same scope.
14:56:05 <cathper> Yes, but why? Why is \x -> (\x -> ...) different from \x x -> ...? As far as I know, \x -> (\y -> ...) is "equal" to \x y -> ... but I might be wrong.
14:56:38 <ndm> cathper: would \x x -> where the first x is ignored make sense?
14:56:54 <ndm> surely if the user had meant that, then \_ x -> would have been written
14:57:12 <ndm> so its almost certainly the user getting it wrong, so beep them
14:59:11 <cathper> Sure, and \x -> (\x -> ...) isn't as easy to discover, therefore it is just "ignored" as a special case. Might that be the reason?
14:59:49 <araujo> cathper, (\ x x ... ) isn't even a valid lambda abstraction
15:00:28 <araujo> @type (\ x x -> x)
15:00:29 <lambdabot>   Conflicting definitions for `x'
15:00:30 <lambdabot>   In a lambda abstraction
15:00:40 <araujo> @type (\ x y -> x * x)
15:00:42 <lambdabot> forall a t. (Num a) => a -> t -> a
15:00:44 <ndm> cathper, it is possible that the user uses both x's, in different places
15:00:58 <araujo> @type (\ x -> (\ x -> x * x))
15:00:59 <lambdabot> forall a t. (Num a) => t -> a -> a
15:01:00 <ndm> \x -> (\x -> x) x * x
15:02:53 <cathper> IIRC from Barendregt, \ x_1 ... x_n is just notation for \x_1 -> ( ... ( \x_n.
15:04:10 <cathper> ndm: Good point.
15:04:52 <cathper> So it really isn't just notation because of the scopes ...
15:05:59 <cathper> Thank you dcoutts__, jrmole, araujo and ndm!
15:06:56 <jrmole> well, it is if the x_i are distinct
15:07:16 <araujo> welcome cathper
15:07:19 <tmoertel> /?
15:07:25 <tmoertel> /? leave
15:08:15 <jrmole> if you write your lambda abstractions with de bruijn numerals then it's not possible to have shadowed variables
15:09:31 <cathper> How are de bruijn numerals defined?
15:10:04 <dcoutts__> @tell dons recent changes look good. Down to 19 pages I see. I'll be back in contact on the 1st.
15:10:04 <lambdabot> Consider it noted.
15:11:09 <jrmole> instead of names your variables are indexed by integers, where k refers to the variable bound by the kth-innermost lambda abstraction
15:11:21 <jrmole> so \ -> \ -> 1 is the K combinator, for example
15:11:26 <jrmole> aka \x -> \y -> x
15:11:51 <jrmole> this is not valid haskell, but it's an internel representation used by some lambda calculus manipulation programs because it allows you to ignore alpha reduction entirely
15:16:49 <cathper> Oh, ok. I see.
16:02:48 <ivant> Hi guys
16:03:06 <heatsink> hello ivant
16:14:21 <ndm> hi ivant
16:16:38 <jbalint> hi
16:17:11 <jbalint> what rule makes these two logically equivalent (\ p q r -> p ==> (q ==> r)) (\ p q r -> q ==> (p ==> r))
16:17:24 <jbalint> eh, ==> is logic implication
16:19:53 <heatsink> Well, you could derive it with boolean logic.  I don't know if it has a name.
16:20:33 <jbalint> how do you transform it?
16:22:14 <heatsink> using (a ==> b) === (b or not a)
16:22:40 <jbalint> Ok, let me see it for a second.
16:23:43 <mauke> IpIqr -> IpOrNq -> OOrNqNp ;; IqIpr -> IqOrNp -> OOrNpNq
16:23:59 <heatsink> what syntax is that?
16:24:20 <mauke> something weird :-)
16:25:21 <mauke> oh, I got it wrong
16:25:22 <jbalint> Ah, great. Thanks.
16:25:30 <mauke> "or" is D, not O
16:25:39 <mauke> http://www.spoj.pl/problems/TAUT/
16:25:40 <jbalint> Well stil makes sense.
16:25:43 <heatsink> D:
16:25:43 <lambdabot> Title: Sphere Online Judge (SPOJ) - Problem TAUT
16:28:50 <heatsink> That's a useful encoding.
16:30:14 <mauke> yeah, it has the advantage of being regexable
16:30:20 <mauke> unfortunately it's too slow :-)
16:31:55 <jbalint> Hrm.. what about IpqIp and p?
16:32:30 <mauke> Ip is a syntax error
16:32:50 <heatsink> IIpqCpq?
16:33:24 <jbalint> (p ==> q) ==> p
16:33:32 <mauke> IIpqp
16:33:38 <jbalint> Ok, wasn't sure.
16:33:54 <jbalint> How are IIpqp and p equivalent?
16:34:25 <heatsink> I think (forall q. p ==> q) ==> p
16:34:46 <heatsink> oh no
16:34:50 <heatsink> nevermind
16:35:58 <jrmole> what do you mean by regexable?
16:36:10 <mauke> IIpqp -> IDqNpp -> DpNDqNp -> DpCNqp -> hmm, what now?
16:36:35 <heatsink> It's an anagram of exegrable, which means "awful"
16:36:43 <mauke> jrmole: you can transform expressions by repeated application of regex substitutions
16:37:07 <jrmole> really?
16:37:22 <jrmole> the language of valid strings in that language is not regular
16:37:25 <jrmole> what are the transformations?
16:37:30 <mauke> yeah, I had to cheat a bit
16:37:37 <mauke> let me find the source
16:39:22 <jbalint> NDqNp = CqNP ?
16:39:38 <jbalint> er.. CNqp
16:39:47 <jbalint> Ah, ok.
16:40:24 <mauke> !a || !b == !(a && b)
16:40:44 <jbalint> yep
16:41:59 <mauke> jrmole: ok, this thing cheats a lot by using experimental features of perl's regex engine
16:42:42 <jrmole> which allow it to recognize any context-free language iirc
16:42:44 <jbalint> So -> CDCpNqpp ?
16:42:50 <jrmole> of course if you have that power the transformations are easy
16:43:03 <cathper> With a somewhat more intuitive notation: p ==> (q ==> r)  ===  p ==> (¬q v r)  ===  ¬p v (¬q v r)  ===  ¬q v (¬p v r)  ===  q ==> (¬p v r)  ===  q ==> (p ==> r).
16:43:34 <jbalint> You used the real negation sign? I see a big grey box. =)
16:44:45 <cathper> Yep.
16:44:46 <jbalint> cathper: Thanks. I've got that one. Any input on (p ==> q) ==> === p?
16:46:10 <stepcut> hrm, mixing IORef, unsafePerformIO and Data.Dynamic can be evil :)
16:46:38 <mauke> jbalint: heh, my program transforms IIpqp into p, I just have to find out how :)
16:46:51 <heatsink> stepcut: toil & trouble.
16:47:12 <ndm> stepcut: no unsafeCoerce# ?
16:47:15 <jbalint> mauke: Hrm. thats intersting, is it online?
16:47:32 <stepcut> ndm: not yet :p
16:48:35 <cathper> (p ==> q) ==> p is false if p is false since then p ==> q is trivially true, so the outer implication must be "true ==> false" which is false.
16:48:44 <mauke> derivation: ONONpq;p; -> ONON0q;p; -> ON1p; -> p
16:49:01 <mauke> O...; is multi-arg "or"
16:49:08 <jrmole> yeah, you can prove these kinds of things with a simple truth table
16:49:22 <jrmole> how do you uniquely parse an arbitrary number of args?
16:49:51 <jrmole> bbl
16:50:14 <jbalint> cathper: Ah... and if it's true (p ==> q) could be either and the statement is still true. Thanks!
16:53:13 <mauke> jbalint: my program: http://rafb.net/paste/results/R9bYLa11.html
16:54:01 <jbalint> Hrm... will take a week to digest that.
16:54:21 * edwardk waves hello.
16:54:24 <edwardk> @seen shapr
16:54:24 <lambdabot> I saw shapr leaving #haskell and #ScannedInAvian 8 days, 5 hours, 10 minutes and 35 seconds ago, and .
16:54:39 <mauke> this code is pretty awful
16:55:06 <cathper> Yet another proof of that perl is "write only" ;-)
16:56:21 <mauke> do you want to see some of my haskell code? >:)
16:57:03 <heatsink> heh
16:57:39 * heatsink has some nice write-only code
16:58:15 <heatsink> I wrote a function to do topological sort, but I never really figured out how it worked.
16:59:38 <heatsink> It's really elegant, though.
17:07:35 <cathper> http://iohcc.mgoetze.net/winners.html
17:07:37 <lambdabot> Title: International Obfuscated Haskell Code Contest
17:07:46 * cathper goes to bed.
17:07:55 <heatsink> It wasn't intentional, sheesh.
17:08:04 <heatsink> night.
17:10:46 <int-e> heatsink: and it did work?
17:11:09 <heatsink> int-e: yea
17:12:12 <madpickle> bleh
17:12:18 <madpickle> just make the code available online
17:12:22 <madpickle> i'm not gonna download any of that
17:12:54 <madpickle> (referring to Remorse)
17:14:05 <ndm> madpickle: Remorse is worth it, its got a readme which is quite important too
17:14:23 <madpickle> i'm lazy
17:15:29 <edwardk> remorse was funny
17:25:22 <mauke> complete derivation of (p => q) => p: http://rafb.net/paste/results/Yw54Tw43.html
17:32:23 <jbalint> O=D??
17:32:47 <mauke> O = vararg D
17:33:04 <mauke> D takes exactly two arguments, O takes a list terminated by ;
17:33:37 <jbalint> Alright.
18:15:09 <edwardk> mauke: that looks like your cat walked across the keyboard ;)
18:15:34 <mauke> hah, joke's on you: I don't have a cat!
18:15:56 <edwardk> fell asleep face down on it then? =)
18:16:17 <mauke> dude, it totally makes sense
18:16:27 <edwardk> what notation is that?
18:16:53 <edwardk> ah
18:16:55 <mauke> which one? (it's debugging output from my program)
18:17:35 <edwardk> what program then? =)
18:17:44 * edwardk has no context for the current discussion.
18:19:01 <edwardk> ah i see a previous paste of a bunch of perl
18:19:26 <edwardk> ok, makes sense now =)
18:19:30 <mauke> current version: http://rafb.net/paste/results/0Zl2ig74.html
18:19:52 <edwardk> regexp reduction rules then?
18:20:40 <mauke> yeah
18:21:26 <edwardk> I see N for not, O =?
18:21:59 <mauke> Oxyz; is (or [x,y,z])
18:22:06 <edwardk> ahhh
18:54:00 <dons> morning
18:54:00 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
18:54:12 <madpickle> morning, eh?
18:54:17 <madpickle> oh right
18:54:18 <madpickle> aussie
18:54:21 <edwardk> evening =)
18:54:25 <madpickle> night =)
18:54:26 <dons> :)
18:57:17 <ndm> hardly morning here, am just contemplating sleep
18:58:00 <lscd> 4am around here; sounds like morning to me
19:00:09 <ndm> its not morning until after you've had breakfast
19:00:15 <ndm> 4am is most definately night
19:00:21 <lscd> isn't morning the time you sleep? ;)
19:01:39 <lispy> whoa
19:01:44 <lispy> emacs kinda freaked out...
19:02:00 <madpickle> M-x sedate-frame
19:02:07 <lispy> heh
19:02:19 <lispy> emacs(22102) malloc: *** error for object 0x12800804: pointer being reallocated was not allocated
19:02:22 <lispy> emacs(22102) malloc: *** set a breakpoint in szone_error to debug
19:02:29 <lispy> emacs(22102) malloc: ***  Deallocation of a pointer not malloced: 0x12800804; This could be a double free(), or free() called with the middle of an allocated block; Try setting environment variable MallocHelp to see tools to help debug
19:02:43 <lispy> i've never seen that before
19:02:57 <lispy> and now ^C does nothing
19:03:56 * lispy installs emacs 22
19:04:03 <lispy> maybe that will be the solution :)
19:20:10 <johnnowak> It was my understand that ghc is moving to c-- as a compiler target language. Is this information old and inaccurate?
19:20:18 <johnnowak> I
19:20:30 <johnnowak> ... I'm trying to ascertain the state of C--.
19:21:52 <lispy> seems like it would be hard to move away from gcc.  Perhaps the movement to C-- depends on gcc supporting C--?
19:22:08 <dons> nope, the C-- compiler would be used
19:22:28 <lispy> and it's got all the desired platform support?
19:22:36 <dons> however, c-- is moving slowly enough that instead concentrating on improving ghc's own code generator is seen as more of an option
19:22:48 <johnnowak> dons: that's what I was fearing.
19:22:52 <dons> (internally ghc already uses a C-- type for code generation)
19:23:33 <dons> lispy: the C route would always remain, afaik, since we need to bootstrap sometimes
19:25:02 <ndm> i think that the bootstrap C isn't much of a problem, as its easy to generate inefficient C
19:25:24 <ndm> but once C-- became the main stay the evil mangler dies
19:25:58 <johnnowak> C certainly has its (possibly necessary) advantages
19:27:22 <ndm> portability and bootstrapping are about the only two i can think of
19:28:05 <johnnowak> is there anything else besides C-- that looks promising?
19:28:33 <edwardk> javascript! =) j/k
19:28:55 <ndm> it seems that the GHC people have gone the C-- route
19:29:21 <ndm> however Yhc has .NET, JVM, Python, C all as code executions and .NET as a native bytecode
19:29:48 <ndm> and someone was working on a javascript one - so not that much of a joke!
19:30:52 <johnnowak> yikes.
19:31:21 <edwardk> i actually was looking at compiler STG to javascript mysellf a little while ago, but the amount of cruft that has to be implemented to make GHC happy is a little terrifying.
19:32:00 <edwardk> s/compiler/compiling/
19:32:17 <ndm> do it in Yhc, would be relatively trivial
19:32:28 <edwardk> yeah but i like ghc's features =)
19:32:34 <ndm> like what?
19:32:38 <ndm> (and then add them to Yhc)
19:32:54 <edwardk> mptcs, fundeps, active maintenance, etc. ;)
19:33:04 <ndm> ah, we have active maintenance
19:33:13 <ndm> mptcs and fundeps are hopefully coming
19:33:21 <edwardk> stg fits javascript's execution model closely enough that its not so painful of a conversion.
19:33:30 <edwardk> well, add them and we'll talk ;)
19:33:38 <dada> http://www.djdada.dl.am RnB/HipHop Songs to Download & Musicclips! check it out ;)
19:33:47 <ndm> we have builds that fire every 10 minutes - cmopare that to GHC's nightly builds!
19:33:58 <Korollary> @keal
19:33:58 <lambdabot> better be atleast 16x16 color with extended ascii set
19:34:52 <edwardk> i allso looked at GRIN->javascript, since jhc generates very small object files, that might be more suited to a javascript implementation, but its syntax isn't as amenable to a straight port. the expensive things in javascript are the function calls, and i'd need one for every use of the invocation monad in GRIN.
19:35:01 <edwardk> heh
19:40:37 <edwardk> anyone here read much of the uniqueness type stuff?
19:41:11 <ndm> a bit
19:41:21 <ndm> seems more intuative than monads initially
19:41:37 * edwardk has been trying to retrofit uniqueness typing into an already substructural logic.
19:41:54 <ndm> i don't understand much about how the type checking is done
19:41:58 <ndm> more about its uses
19:42:02 <edwardk> coz linear says one thing, and uniqueness says another. both are useful, one for garbage collection, and one for inplace updates
19:42:10 <ndm> and optimisation potential
19:42:15 <edwardk> yah
19:42:16 <ndm> yeah, in place updates are good
19:42:35 <ndm> i considered adding refcounts to Yhc, to see if we would get an in place update benefit
19:42:46 <ndm> unfortunatelyl refcounts are too slow
19:43:03 <edwardk> you don't need to refcount, you can track uniqueness in the type system
19:43:27 <ndm> yeah, i didn't want to touch the type system
19:43:43 <edwardk> contract and its not unique any more.
19:44:15 <edwardk> well, if you do it in the type system thenthere is no runtime impact, and its a pure performance win
19:44:28 <edwardk> thats why i've been obsessing about substructural types.
19:44:30 <ndm> and also refcounts might pick up runtime situations of only 1, which are not static guarantees
19:45:01 <edwardk> true, but refcounts screwup cache coherence and require writebacks into previously unmutated regions of memory
19:45:18 <ndm> yep
19:45:24 <dons> ?users
19:45:24 <ndm> and thats why its a bad idea
19:45:26 <lambdabot> Maximum users seen in #haskell: 235, currently: 193 (82.1%)
19:45:45 <edwardk> hence why mangling the type system to gain an optional benefit seems so attractive.
19:46:09 <dons> are there ay detailed comparisions between monads and uniqueness types?
19:46:37 <ndm> dons, uniqueness types are more powerful
19:46:38 <edwardk> i'm mostly trying to play with the interaction of the traditional substructural types with the features of a uniqueness type. linear says that contraction and weakening wont happen in the future. uniqueness says it hasn't happened in the past.
19:46:57 <ndm> have you seen the haskell -> clean translator? hacle, that gives a translation shceme
19:47:15 <edwardk> so uniqueness is a comonad, like the ! exponential modality in linear logic.
19:47:56 <edwardk> but with a different intent.
19:49:42 <edwardk> mostly trying to pick out a set of monads and comonads that can describe the set of desirable featuress to track about types when you want to be able to optimize for all the combinations of past and future weakening and contraction.
19:50:02 <edwardk> some of those are less useful than others.
19:50:50 <edwardk> but i wonder if uniqueness can be broken apart like linear ws to yield affine and relevant, in a meaningful way.
19:53:04 * edwardk shuts up and returns to puttering with random squiggles and symbols. ;)
19:55:27 <dons> ?remember Miod [On the vax] How many processors come with a built-in instruction which computes polynomials of degrees up to 31?
19:55:27 <lambdabot> Done.
19:55:35 <dons> http://undeadly.org/cgi?action=article&sid=20060825232507
19:55:37 <lambdabot> Title: Developer blog: miod [on VAXen and frame buffers]
20:12:42 <lispy> @tell dons I just saw the speeding lambda on the Data.ByteString page, that's awesome.
20:12:43 <lambdabot> Consider it noted.
20:17:00 <dons> hehe :)
20:17:01 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
20:17:06 <dons> you like that?
20:17:09 <lispy> yeah
20:17:12 <lispy> it's great
20:17:16 <lispy> i lol'd
20:17:26 <dons> logos are very important :)
20:17:42 <lispy> dons: trying to build fps-0.8 on amd64 but it didn't seem to build Data.ByteString.Char8
20:17:52 <dons> oh, strange.
20:18:00 <lispy> Installing: /usr/local/lib/fps-0.8/ghc-6.4.2 & /usr/local/bin fps-0.8...
20:18:02 <lispy> Setup.hs: Error: Could not find module: Data.ByteString.Char8 with any suffix: ["hi"]
20:18:13 <lispy> yeah, fwiw, i think ghc might have crashed during the install
20:18:17 <lispy> er build
20:18:18 <dons> ah
20:18:20 <dons> yeah, maybe
20:18:29 <lispy> i tihnk i'll try the 0.7 release
20:18:39 <lispy> ghc 6.4.2, also
20:19:11 <dons> hmm, ok. any ideas why ghc died?
20:19:17 <lispy> no idea
20:19:24 <dons> can you reproduce it?
20:19:25 <lispy> cabal didn't say anything...so maybe it didn't
20:19:31 <lispy> i could try
20:19:39 <dons> (fps 0.8 is the one that's in the ghc base libs right now, so it needs to work)
20:19:55 <lispy> when i did the compile my server becaume unresponsive for a while, which usually happens right before ghc crashes on a complie
20:19:56 <dons> it'll be tagged next week if nothing happens
20:20:07 <dons> hmm. so amd64 issue ?
20:20:39 <lispy> could be, i hoped upgrading to 6.4.2 would fix it
20:20:48 <lispy> in the past i had to change gcc versions to compile something
20:21:28 <dons> i wonder what setup dcoutts has -- he's been able to build without troubles on amd64
20:21:33 <dons> or x86-64, actually
20:22:28 <lispy> my processor is EM64T, but i run the amd64 stuff
20:22:31 <lscd> hm, download url? i'm using ghc 6.4.2 on amd64, so i could try to reproduce
20:23:34 <lispy> i think ghc is doing it again, on 0.7 this time
20:25:51 <Adamant> madpickle!
20:25:56 <madpickle> me!
20:26:04 <lispy> http://www.cse.unsw.edu.au/~dons/fps.html
20:26:05 <lambdabot> Title: Data.ByteString
20:26:10 <Adamant> :)
20:26:23 <Adamant> didn't know you were on #haskell
20:26:27 <madpickle> heheh
20:26:38 <madpickle> you seem to be in every channel =P
20:27:08 <Adamant> I would be in more, but they have a 20-chan limit. :(
20:27:25 <madpickle> heheh
20:27:30 <madpickle> give lilo beer money
20:27:53 <Adamant> hah, I'll just live with it.
20:28:36 <lispy> dons: same problem with 0.7
20:28:36 <lscd> Adamant: you've seen the no glsa for kernel issues stuff?
20:28:51 <Adamant> yes.
20:28:58 <lispy> dons: testing for it sucks, my server (which others depend on) goes unresponsive for a bit
20:29:05 <Adamant> I know of the policy, at least.
20:29:34 <Adamant> they just don't have enough kernel guys right now, AFAIK.
20:29:40 <dons> lispy: hmm. sounds like an rts bug in ghc, perhaps?
20:30:02 <lispy> dons: from past experience, i would bet it's related to gcc
20:30:27 <lispy> but i have a really recent gcc: gcc 4:4.0.2-2
20:30:29 <lispy> so i dunno
20:30:44 <lispy> the end result is that i can't build fps :(
20:31:35 <dons> yeah, sounds like a scary version of gcc
20:31:54 <johnnowak> gcc isn't scary?
20:31:58 <hitodama> I know about the Peyton-Jones paper, but does anyone else know of any online resources about Haskell and financial engineering?
20:32:08 <dons> well, I'd need more info to solve this. i.e. full transcript, including -v4 output
20:32:23 <dons> hitodama: hmm, no, only the paper you mention
20:32:45 <dons> hitodama: possibly check scholar.google.com for papers that cite Peyton Jones?
20:32:47 <lispy> dons: okay, where do i use that, which command line, runghc -v4 Setup.hs build?
20:32:57 <dons> build -v4, yes
20:32:57 <hitodama> good idea, thanks
20:33:10 <lispy> dons: okay, i may get logged off, but i'll try it :)
20:33:16 <dons> lispy: hmm ok :)
20:33:38 <dons> ?karma+ lispy -- bug chasing in the face of danger
20:33:38 <lambdabot> lispy's karma raised to 5.
20:33:40 <monochrom> the paper is not online resource?
20:33:41 <lisppaste2> petekaz pasted "How do you write this using =<<" at http://paste.lisp.org/display/24762
20:33:44 <lispy> lol
20:33:46 <madpickle> lol
20:34:14 <dons> ?undo do mvalue <- getInput var ; return $ fromMaybe defval mvalue
20:34:14 <lambdabot> getInput var >>= \ mvalue -> return $ fromMaybe defval mvalue
20:34:21 <dons> ?. pl undo do mvalue <- getInput var ; return $ fromMaybe defval mvalue
20:34:21 <lambdabot> fromMaybe defval `fmap` getInput var
20:34:27 <dons> thats how you write it :)
20:34:43 <dons> petekaz: 6^
20:35:21 <dons> petekaz: to actually use =<<, you reverse the result of @undo: (\ mvalue -> return $ fromMaybe defval mvalue) =<< getInput var
20:35:32 <dons> but that's ugly
20:35:37 <petekaz> I was far off.  I thought it was going to be something like: return $ fromMaybe defval =<< getInput var
20:35:46 <dons> ?pl (\ mvalue -> return $ fromMaybe defval mvalue) =<< getInput var
20:35:46 <lambdabot> fromMaybe defval `fmap` getInput var
20:36:03 <petekaz> I guess I need to look up fmap.
20:36:15 <dons> return . fromMaybe defval =<< getInput var --might be enough
20:36:23 <madpickle> so, like, when, exactly, will this bot reach sentience?
20:36:33 <dons> ?vixen-on
20:36:34 <lambdabot> What's this channel about?
20:36:37 <dons> are you sentient?
20:36:38 <lambdabot> i truely am
20:36:46 <dons> when did that happen?
20:36:47 <lambdabot> about a year ago
20:36:53 <dons> cool!
20:36:53 <lambdabot> how cool?
20:36:54 <madpickle> how much wood can a woodchuck chuck if a wood chuck can chuck wood?
20:36:55 <lambdabot> how? it depends...
20:36:56 <dons> ?vixen-off
20:36:56 <lambdabot> Bye!
20:36:59 <madpickle> hehehe
20:37:04 <lispy> dons: http://paste.lisp.org/display/24763
20:37:13 <lispy> dons: i don't see any useful info though
20:37:41 <dons> argh, can you try -v9?
20:37:48 <dons> or maybe its just -v
20:38:10 <lispy> oh
20:38:15 <lispy> right after runghc
20:38:19 <lispy> then we get tons
20:38:27 <dons> yeah, -v9
20:38:37 <dons> ./Setup.hs build -v9
20:39:14 <dons> ?free myfun var = fromMaybe defval `fmap` getInput
20:39:15 <lambdabot> Expected OpColonColon
20:39:19 <dons> ah yes
20:39:46 <lispy> well, that's the problem
20:39:48 <lispy> i can't even build Setup.hs
20:39:57 <lispy> Linking ...
20:39:59 <lispy> collect2: ld terminated with signal 9 [Killed]
20:43:44 <lispy> dons: http://paste.lisp.org/display/24763#2
20:44:01 <dons> ld!
20:44:09 <dons> memory issues, perhaps
20:44:46 <dons> can you add, -optl--no-keep-memory to the ghc options in the cabal file?
20:44:55 <lispy> sure thing boss
20:45:05 <dons> (and check it gets passed to ld in the -v9 output)
20:45:26 <lispy> consider it done
20:46:25 <lispy> actually, i can't do thot
20:46:38 <lispy> because i can't compile Setup.hs to a file
20:46:46 <lispy> so i can only pass the -v9 to runghc
20:47:02 <lispy> oh, but i have an idea
20:47:37 <lispy> okay, i can build Setup.hs if i use that option
20:47:41 <lispy> so what does that do?
20:50:26 <lispy> that option does get passed to some things, but it doesn't seem to be doing the trick in the case of fps
20:54:01 <dons> hmm
20:54:06 <dons> more info?
20:54:18 <dons> you're sayign --no-keep-memory does get passed to ld when compiling fps?
20:54:20 <dons> but it still fails?
20:55:36 <lispy> unfortunately, i can't get cabal to print out the cabal line
20:55:52 <lispy> er the ld line
20:56:20 <lispy> -v9 seems to only work with ghc
20:56:33 <lispy> but i can show you the latest output with that line in the cabal file
20:57:16 <lispy> http://paste.lisp.org/display/24763#3
20:57:24 <lispy> looks like a gcc bug
20:57:33 <dons> not too unsuspected then
20:57:47 <lispy> should i upgrade or downgrade do you think?
20:57:51 <lispy> i don't see anything newer in apt
20:58:23 <dons> downgrade gcc if possible?
20:58:31 <lispy> Version: 4:3.3.5-3?
20:58:44 <dons> maybe?
20:59:02 <lispy> do you think that sound reasonable? I think that means it's a 3.3 series...don't know what the first 4 means
20:59:36 <dons> oh, 3.3.5, yes, that may work
21:00:50 <lispy> okay, downgrading
21:01:20 <lispy> cc1: error: unrecognized option `-fno-unit-at-a-time'
21:01:28 <lispy> i should probably clean and reconfigure
21:01:59 <lispy> hmm...
21:02:03 <lispy> still getting that error
21:03:30 <dons> can you get more info about what gcc and ld are doing?
21:03:45 <edwardk> I never really understood people who go and back-port operating systems to dead platforms.
21:04:18 <lispy> dons: i can't see a way
21:04:27 <lispy> dons: but --verbose even seems undocumented
21:04:34 <lispy> so maybe there is a way
21:04:35 * edwardk realizes that he has had his window stuck in scrollback and that the conversation has moved on for a couple hours now ;)
21:05:44 <lispy> dons: i'm really not sure what to make of this error, it's like ghc is depending on a feature my gcc doesn't support now that i've downgraded
21:06:27 <johnnowak> edwardk: i hate when that happens.
21:06:28 <lispy> my gcc should be new enough according to the depends in the ghc package
21:06:28 * johnnowak hits irssi
21:06:32 <edwardk> gah. does anyone know a way to keep firefox from launching external applications for every tom-dick-and-harry's mimetype it doesn't know how to deal with and just view it as a text file? i am so sick of it launching visual studio to view a c file.
21:06:56 <edwardk> or trying to invoke hugs for .hs, etc.
21:07:13 <lispy> edwardk: yeah, it's annoyngi...i ended up changing the mime types on my apache install because it was so annoying...i guess changing it in ff makes more sense tho :)
21:07:41 * johnnowak hits firefox
21:07:43 <edwardk> i can't seem to find an extension for it, no one seems to mention it, and googling for it is impossible because the search terms are too general
21:07:54 <edwardk> i noticed the behavior was getting worse after around 1.0
21:07:59 <edwardk> back then it was still usable
21:08:00 <johnnowak> edwardk: just use elinks :)
21:08:24 <lispy> dons: oh actuall, the 6.4.2 ghc package doesn't mention gcc in the depends, i was looking at the wrong line
21:08:28 <edwardk> nowadays i can't read a frickin thing without clicking on a link to what should be sent as a text file and launches some random application
21:08:35 <edwardk> (or rathr prompts me to)
21:13:14 * lispy goes shopping on the debian server for gcc packages
21:13:43 <edwardk> https://launchpad.net/products/firefox/+bug/28972
21:14:10 <edwardk> convoluted
21:18:39 <edwardk> ok got c and haskell fixed., now i have to waste a half hour getting the other extensions fixed. how dumb is that?
21:19:15 <johnnowak> edwardk: just throw it out
21:19:32 <edwardk> i like firefox though, for the most part =)
21:20:11 <Adamant> I can't live without FF extensions anymore.
21:20:38 <dons> I rather like fasterfox plugin
21:20:39 <lscd> yeah; it's a pity that FF is so bad
21:20:50 <Adamant> eh, it improves.
21:20:56 <lscd> slowly
21:21:04 <lscd> sometimes
21:21:19 <Adamant> I like it better than Safari or Konqueror, although KHTML is probably a better rendering engine.
21:21:24 <lscd> but it's better than netscape 4, so hey, progress is being made
21:21:36 <Adamant> it's better than IE 7.
21:21:41 <lscd> hm, debatable; and yeah - it's a lot nicer than safari and konqueror
21:21:42 <Adamant> and that's mostly what it has to beat.
21:21:56 <lscd> for widespread use, sure
21:22:36 <Adamant> so, you a Opera fan?
21:22:43 <Adamant> I never got into it myself.
21:22:54 <Adamant> it's nice, but it doesn't have the extensions I need.
21:23:32 <edwardk> i wonder if i should try removing the c/c++ entry from my registry to see if that helps.
21:23:34 <madpickle> opera is great
21:24:06 <lscd> Adamant: i use firefox; i just loath it - it's a memory hog, it's unstable, it's insecure; it's also the least bad option
21:24:44 <Adamant> sadly, pretty much any web browser worth using is somewhat insecure.
21:24:48 <johnnowak> opera is a ui disaster.
21:24:57 <Adamant> Opera doesn't have a great record there either.
21:25:08 <johnnowak> (i downloaded it today and tried to configure it properly)
21:25:41 <johnnowak> i don't see how FF is nicer than konqueror or safari
21:26:01 <johnnowak> but then again, i do not use extensions.
21:26:16 <Adamant> extensions are indispensible.
21:26:23 <lscd> Adamant: yeah - i know; mere malformed input that isn't malicious can crash all of them :/
21:26:25 <johnnowak> Obviously not, because I'm not using anyway. :)
21:26:38 <Adamant> if you do any Javascript stuff, try Firebug.
21:26:47 <johnnowak> I don't do any javascript stuff
21:26:58 <Adamant> Flashblock is excellent, allows you to run only the Flash you want.
21:27:00 <lscd> JohnMeacham: FF is nicer than konqueror or safari because gecko still renders more sites, better, than khtml does
21:27:09 <johnnowak> Adamant: no flash on ppc linux anyway...
21:27:09 <Adamant> lscd is correct.
21:27:11 <lscd> plus firefox extensions
21:27:19 <edwardk> i use firefox, simply because i used to do a lot of extension work in it, so i know its limitations, they just changed a lot of stuff in 1.5 like the file opening stuff, and its irritating =/
21:27:30 <lscd> Adamant: hm - i'm just using noscript these days, which can block flash as well
21:27:38 <johnnowak> That's certainly not a reason it is "better". If it renders the sites you need, who cares if it isn't perfect on some non-standard things?
21:27:43 <JohnMeacham> lscd: ?
21:27:51 <lispy> dons: switching to gcc-3.4 seems to be working
21:27:52 <Adamant> because I need the "non-standard" things.
21:28:10 <johnnowak> Adamant: I've never hit a page that doesn't work in Safari. Is Konqueror that much different nowadays?
21:28:12 <lscd> JohnMeacham: what is the "?" referring to?
21:28:28 <johnnowak> lscd: the fact that you referenced him when you meant me.
21:28:46 <lscd> ah, sorry; 6:30am + tab complete = bad
21:28:51 <Adamant> my favorite website has serious problems wrt KHTML engines, both of them. it has never been fixed.
21:28:59 <johnnowak> which site?
21:29:01 <Adamant> works fine in IE, Firefox, Safari.
21:29:02 <lispy> dons: or at least, this is the farther than before
21:29:14 <Adamant> a bit private. :)
21:29:31 <johnnowak> I see you value porn over stability, memory usuage, and security. :)
21:29:44 <Adamant> hah, funnily enough, it's not porn. :)
21:29:51 <Adamant> just a discussion board.
21:30:27 <Adamant> err, not Safari, Opera.
21:30:29 <Adamant> :(
21:30:40 <johnnowak> Ah well. The entire web is a mess anyway. HTML is shit, CSS is shit, the current browsers are shit... just tear it all down and start over.
21:30:48 <lscd> johnnowak: konqueror seems to slow down when i have several dozen tabs open, while i routinely use a few hundred in firefox
21:30:48 <lispy> dons: for future referenc, you have to add the -v9 in the cabal file...duh, why didn't we realize that...
21:31:00 <johnnowak> lscd: there is no reason to use a few hundred tabs at once.
21:31:07 <lscd> johnnowak: agreed, until the tear it down part
21:31:07 <edwardk> john: ain't gonna happen. so accept it, find a piece of it you can work with and abstract over that ;)
21:31:14 <Adamant> you and Marcus J. Ranum would get along famously. :)
21:31:14 <lscd> johnnowak: look, it's how i work - like it or not
21:31:20 <johnnowak> edwardk: there isn't one :)
21:31:41 <johnnowak> lscd: you may find that adopting sane usage patterns uses less memory :)
21:31:46 <lispy> lscd: i wish i had GC for my tabs that i don't care to go back to
21:31:48 <edwardk> heh
21:31:48 <johnnowak> lscd: no browser is meant to show 300 pages at once
21:31:56 <dons> lispy: oh, -v9 in the cabal file too?
21:32:01 <lscd> johnnowak: firefox handles it pretty well, generally
21:32:04 <dons> 13:41  dons:: can you add, -optl--no-keep-memory to the ghc options in the cabal file?
21:32:11 <edwardk> john: you could always just exile yourself to siberia or something and avoid computers for the next 20 years ;)
21:32:11 <dons> :)
21:32:13 <lispy> dons: yeah, now it's generating a ridiculous amount of memory
21:32:19 <lispy> er outut
21:32:22 <dons> hehe
21:32:22 <Adamant> he made a "ha-ha-only-serious" presentation to the effect that we should reboot the Net using redesigned secure protocols and use Y2K as an excuse for it.
21:32:27 <johnnowak> lscd: well at least i know where you're coming from now...
21:32:27 <JohnMeacham> lscd: you said my name.
21:32:41 <lscd> JohnMeacham: i apologize
21:32:54 <johnnowak> edwardk: i'm going to replace my website with just my ip -- connect via telnet if you want anything :)
21:33:29 <edwardk> heh
21:33:29 <johnnowak> just think of the interaction possibilities! it is like web 3.0.
21:33:30 <lscd> johnnowak: the land of people who -always- click "open in new tab", yes
21:33:34 <edwardk> back to the good old bbs days
21:33:43 <lispy> dons: it seems to have compiled with this version of gcc
21:33:47 <JohnMeacham> yes. my name should never be spoken out loud. it's sacreligous. :)
21:33:51 <johnnowak> lscd: ok
21:33:59 <johnnowak> edwardk: if it works :)
21:34:07 <lscd> JohnMeacham: fortunately, i didn't speak it out loud; at most, i typed it, and in fact, i really only tab-completed it :)
21:34:08 <lispy> dons: so i'm going to try building 0.8 again
21:35:46 <lispy> did someone say web3.0?
21:35:57 <johnnowak> lispy: i did.
21:36:03 * lispy cringes
21:36:04 <lscd> lispy: web 3.1415926....
21:36:11 <johnnowak> lispy: what? :)
21:38:14 <monochrom> hahaha
21:39:17 * johnnowak hopes lispy realizes he was joking
21:39:53 <JohnMeacham> true. otherwise I would have been summoned in person. actually, to do that, you have to turn out all the lights and say my name 3 times fast. the only way to send me back to my own dimension (california)  is to trick me into saying my own name backwards.
21:40:22 <lscd> JohnMeacham: unfortunately, it's just after sunrise here, so it's beyond my ability to turn out the lights; otherwise, i might try it
21:40:47 <monochrom> You can go into a dark room.
21:41:23 <lispy> JohnMeacham: are you related to beetlejuice?
21:41:45 <lscd> monochrom: but is that really turning out the light? or just avoiding it?
21:42:16 <monochrom> They're observationally equivalent :)
21:42:32 <edwardk> nah, mxyztplk =)
21:42:33 * monochrom had too much FM'06
21:42:50 <lscd> monochrom: hm. depends on how good your observational tools are, i guess
21:42:55 <lscd> FM'06?
21:43:39 * edwardk wonders if johnmeacham is from the '5th dimension'.. then realizes he should just drop it =)
21:44:46 <monochrom> fm06.mcmaster.ca
21:46:12 <lscd> ah, yeah; i went to something a bit like that about a month ago
21:53:06 <lispy> dons: it generated a 32M build log but i don't see 'no-keep' anywhere in the log so i don't think it passes that flag correctly
21:53:36 <lispy> dons: and it failed to build everything
21:53:51 <lispy> dons: so, 3.4 does seem to fair better, but not good enough
21:55:03 <lispy> i wonder if i should look at the binutils package too
21:56:31 <dons> very weird
22:02:31 <lispy> upgrading binutils didn't help
22:09:52 * edwardk gives up and installs Opera after wasting an hour skimming bugzilla
22:10:35 * lispy has no idea what to think of his ghc issues
22:11:04 <lispy> both downgrading and upgrading gcc doesn't fix it, but it's cc1 that often the failure point
22:11:25 <lispy> gcc: Internal error: Killed (program cc1)
22:11:34 <lispy> i've even changed my version of binutils
22:11:46 <lispy> basically, ghc is the thing that hasn't really changed version
22:13:00 <dons> we might just be generating some code that gcc can't handle.
22:13:02 <dons> its happened before
22:13:03 <lispy> i guess i could try downgrading to 6.4.1 and see what happens
22:13:15 <dons> but what i don't know is why dcoutts (or any of the other amd64 guys) haven't see this
22:13:26 <lispy> yeah, excatly what's bugging me
22:13:43 <lscd> i've built 6.4.2 on amd64 successfully too
22:14:04 <lispy> i'm using the 6.4.2 built by Igloo for debian
22:14:23 <dons> does tweaking the compilation flags in the .cabal file help?
22:14:30 <lispy> no
22:14:35 <dons> I.e. switching off -O ? (not a good idea, but maybe it helps gcc/)
22:14:38 <lispy> well, not the no-keep-memory option
22:14:44 <lispy> i could try that
22:14:52 <dons> see if its ghc generating some hard C
22:15:42 <lispy> lol, it works now
22:15:44 <lispy> damn
22:15:47 <lispy> good guess :)
22:15:58 <dons> ok. so now try -O (not -O2) ?
22:16:03 <dons> and no -optc-* flags
22:16:29 <dons> and then you could try -O2 -fasm
22:16:34 <dons> to avoid gcc altogether...
22:17:33 <lispy> mmm...-O seems to be bad
22:18:07 <dons> can you try -O -fasm then?
22:18:20 <dons> and -O -optc-O0
22:18:49 <lispy> i'll try -fasm next...but i have to wait for this one to fail...
22:19:57 <lispy> -O -fasm seems okay
22:20:05 <lispy> i'll try the othre one
22:21:15 <lispy> -O -optc-O0 is okay
22:21:50 <dons> so gcc dies on one of its optimisation passes, over the clever C ghc produces
22:21:53 <dons> ?
22:22:03 <lispy> that's what i'm thinking
22:22:03 <dons> try -optc-O1 .. -O3
22:22:16 <lispy> right now i'm trying -O2 -optc-O0
22:22:36 <dons> (i've had gcc produce haskell binaries that segfault wtih -optc-O3)
22:24:17 <lispy> not sure if that makes sense but i thought i'd try it :)
22:24:32 <lispy> -O2 -optc-O0 fails
22:24:44 <lispy> trying -O -optc-O1 next
22:25:30 <lispy> it amazes me how buggy gcc remains after all these years
22:25:46 <lscd> why? :/
22:25:51 <lscd> par for the course in software
22:26:13 <dons> :/ so true
22:26:35 <_spydr_> am I in the right for n0ob questions?
22:26:35 <dons> its the wrong language to write a complex compiler in, C.
22:26:40 <dons> _spydr_: yep
22:26:48 <dons> some people might be interested, http://cgi.cse.unsw.edu.au/~dons/blog/2006/08/26#32cpu
22:26:48 <_spydr_> ok :)
22:26:49 <lambdabot> Title: Haskell, hacking and other stuff
22:26:52 <lscd> dons: yeah
22:27:17 <dons> so not too surprising that segfaults happen on hard input. but sort of depressing
22:27:48 <lispy> dons: fails with -O -optc-O1, sohuld i bother with -optc-O2 and 3?
22:27:56 <lscd> cool, re: free, dons
22:28:04 <_spydr_> I just downloaded Haskell (and ReadLine)
22:28:12 <dons> lispy: hmm, you could try -O3, but it probably only gets worse...
22:28:12 <_spydr_> and everythings fine with
22:28:15 <_spydr_> hgci
22:28:29 <dons> _spydr_: what's the error?
22:28:34 <_spydr_> but whenI compile I get asm output and invalid symbol errors
22:28:47 <dons> did you try: -package readline ?
22:29:06 <_spydr_> hmm no
22:29:09 <_spydr_> lemme see
22:29:12 <lispy> dons: the next question...should i start develving into the optimizations done by -O1?
22:29:34 <lispy> dons: try to pin it down?
22:29:51 <dons> you could do that, if you want. or try to find a basic test case
22:30:03 <dons> (you could start by commenting out fps modules in the .cabal file, to pin it down to one particular module)
22:30:10 <_spydr_> still fails. same output
22:30:16 <dons> _spydr_: paste it
22:30:18 <dons> ?paste
22:30:18 <lambdabot> http://paste.lisp.org/new/haskell
22:30:22 <dons> there ^^
22:30:42 <dons> including the command line you used
22:33:12 <lisppaste2> _spydr_ pasted "compile question/error" at http://paste.lisp.org/display/24767
22:33:40 <dons> 'hsc' ??
22:33:59 <dons> what machine are you on?
22:34:06 <_spydr_> sorry, ghc
22:34:11 <_spydr_> mac
22:34:40 <dons> is it just me, or do those look like x86 instructions?
22:35:00 <_spydr_> Intel acrh
22:35:07 <_spydr_> should be, yes?
22:35:12 <dons> you have a ghc-for-mac binary?
22:35:14 <_spydr_> (MacBok)
22:35:19 <_spydr_> yes
22:35:42 <dons> can you try compiling via C, adding the -fvia-C flag?
22:35:57 <dons> i.e. ghc hello.hs -fvia-C -o hello
22:36:50 <dons> you might have to wait till one of the mac/x86 users is around though, to find out which ghc is best for the new macs
22:36:58 <_spydr_> In file included from /usr/local/lib/ghc-6.4.1/include/Stg.h:149,
22:36:58 <_spydr_>                  from /tmp/ghc749.hc:3:
22:37:07 <_spydr_> that is the start...
22:37:23 <_spydr_> invalid register errors follow
22:37:23 <dons> oh, ghc 6.4.1, that sounds too old
22:37:40 <_spydr_> hmm, site suggested 6.4 was too old and 6.4.1 was fine
22:37:42 <dons> there's either a 6.4.2 or 6.5 build for the mac that people use instead, i think
22:37:48 <_spydr_> nothing yet for 6.4.2 :(
22:38:00 <_spydr_> Where can I get?
22:38:33 <_spydr_> http://www.haskell.org/hawiki/HaskellOnMac
22:38:34 <lambdabot> Title: HaskellOnMac - The Haskell Wiki
22:38:44 <_spydr_> Thats where I checked
22:39:08 <dons> let me check the mailing list archives
22:39:16 <_spydr_> thx
22:39:20 <dons> look through http://www.haskell.org//pipermail/haskell-cafe/
22:39:22 <dons> or
22:39:22 <lambdabot> Title: The Haskell-Cafe Archives
22:39:29 <_spydr_> for future reference, where are they located?
22:39:38 <dons> http://www.haskell.org//pipermail/glasgow-haskell-users/
22:39:41 <lambdabot> Title: The Glasgow-haskell-users Archives
22:39:50 <_spydr_> thank you
22:40:36 <lispy> dons: i'm kinda stumped
22:40:58 <lispy> dons: i individually turned on all the optimizations that gcc manual says are implied by -O1 and it builds just fine
22:41:06 <lispy> dons: (turned them all on at the same time)
22:41:13 <dons> heh. maybe some other things magically happen too
22:41:18 <dons> you can't trust these compiler people
22:41:24 <lispy> lol
22:42:06 * lispy starts adding -O2 optimizations
22:43:28 <dons> ?version
22:43:28 <lambdabot> lambdabot 4p86, GHC 6.5 (OpenBSD i386 )
22:43:28 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:44:07 <lispy> lol, -fexpensive-optimizations
22:45:24 <dons> is there "-fbreak-fp-languages" ?
22:45:36 <lispy> heh
22:45:56 <lscd> dons: but if that were buggy and it didn't break fp languages, that would be really great
22:46:03 <dons> hehe
22:49:58 <lispy> oh, i think i found one
22:51:38 <_spydr_> thanks for suggestions/links all
22:51:44 <_spydr_> cheers
23:23:30 * lispy feels like this is voodoo hacking...-O -optc-O0 used to build right?
23:23:47 <lispy> because now it fail
23:23:48 <lispy> arg
23:24:31 <eivuokko> Morning
23:25:24 <lispy> morning
23:25:30 * lispy is about to sleep
23:25:37 <lispy> @localtime eivuokko
23:25:39 <lambdabot> Local time for eivuokko is Sat Aug 26 09:23:27 2006
23:25:48 <lispy> oh, how is saturday/
23:25:57 <lispy> @localtime lispy
23:25:58 <lambdabot> Local time for lispy is Fri Aug 25 23:23:01 2006
23:26:08 <lispy> i feel like i'm living in the past
23:27:02 <eivuokko> Heh
23:29:30 <dottedmag> @localtime dottedmag
23:29:31 <lambdabot> Local time for dottedmag is Sat Aug 26 13:26:36 2006
23:29:38 * dottedmag is a man from the future.
23:30:08 <lispy> dottedmag: do you have flying cars yet?  what is peak-oil really like?
23:31:05 * lispy asks the important questions
23:31:37 <dottedmag> lispy: no, no flying cars, no even just cars. those things do not help several gigantic mediacorporations to get more money.
23:35:19 <lispy> @karma mediacorporations
23:35:20 <lambdabot> mediacorporations has a karma of 0
23:35:29 <lispy> @karma- mediacorporations
23:35:30 <lambdabot> mediacorporations's karma lowered to -1.
23:35:36 <lispy> ;)
23:36:27 <dottedmag> :)
23:58:45 <newsham> "when FORTAN has been called an infantile disorder, PL/1 must be called a fatal disease and for COBOL I have no words"
