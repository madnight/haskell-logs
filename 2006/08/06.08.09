00:08:39 <astrolabe> Is there a way to make lambdabot produce random numbers?
00:11:50 <dons> hmm
00:11:52 <dons> there should be
00:11:55 <dons> you can sort of use
00:12:01 <dons> ?dice 100d100
00:12:01 <lambdabot> 100d100 => 4972
00:12:10 <dons> ?dice 100d100
00:12:10 <lambdabot> 100d100 => 4910
00:12:20 <astrolabe> Ah yes.  Thanks alot.
00:12:58 <dons> ?dice 1d10000000000000
00:12:58 <lambdabot> 1d10000000000000 => 6731695958909
00:13:01 <dons> ?dice 1d10000000000000
00:13:01 <lambdabot> 1d10000000000000 => 1372565348366
00:13:03 <dons> ?dice 1d10000000000000
00:13:03 <lambdabot> 1d10000000000000 => 3456690306165
00:13:06 <dons> yeah, that works
00:15:15 <roconnor> ?. dice eval "1d"++(show (2^64))
00:15:16 <lambdabot> unexpected end of input: expecting number
00:15:24 <roconnor> ?eval "1d"++(show (2^64))
00:16:04 <dons> ....
00:16:06 <dons> ?bot
00:16:07 <lambdabot> :)
00:16:13 <roconnor> ?botsnack
00:16:13 <lambdabot> :)
00:16:14 <dons> > "1d"++(show (2^64))
00:16:15 <lambdabot>  "1d18446744073709551616"
00:16:22 <dons> ?run "1d"++(show (2^64))
00:16:23 <lambdabot>  "1d18446744073709551616"
00:16:29 <dons> ?. unquote run "1d"++(show (2^64))
00:16:30 <lambdabot>  1d18446744073709551616
00:16:37 <dons> ?. dice . unquote run "1d"++(show (2^64))
00:16:38 <lambdabot>  1d18446744073709551616
00:16:38 <lambdabot>  => 8694247843115216010
00:16:40 <Heffalump> ?compose dice run "1d"++(show (2^64))
00:16:41 <lambdabot> unexpected "\"": expecting number
00:16:42 <dons> :)
00:16:59 <dons> ?. dice . unquote run "1d"++(show (2^8))
00:17:00 <lambdabot>  1d256
00:17:00 <lambdabot>  => 251
00:17:08 <lispy> oh, you fixed dice?
00:17:22 <lispy> i mean, is that what you are testing?
00:17:25 <dons> int-e added a nice couple of patches
00:17:33 <dons> oh, just trying to generate maxBound dice
00:17:39 <lispy> ?. dice . unquote run "1d" ++ (show ( 2^100))
00:17:40 <dons> ?. dice . unquote run "1d"++(show (2^128))
00:17:40 <lambdabot>  1d126765060022822940149670... => 602288225167145930868312627488
00:17:41 <lambdabot>  1d340282366920938463463374... => 31145394400126310288523317508648521759
00:17:48 <dons> haskell rules
00:18:09 <lispy> haskell does rule
00:18:29 <kfish> oath!
00:18:34 <Korollary> blatant fanboism
00:18:37 <dons> hehe
00:19:21 <dons> ?. dice . unquote run "1d"++(show (maxBound :: Int)))
00:19:21 <lambdabot> compose module failed: IRCRaised Prelude.read: no parse
00:19:57 <dons> ?. dice . unquote run "1d"++(show (maxBound :: Int))
00:19:58 <lambdabot>  1d2147483647
00:19:59 <lambdabot>  => 1756028116
00:22:09 <dons> roconnor: ?eval is a nop these days, for compatibility with other bots that use eval , and that run in the same channel as lambdabot (i.e. #perl6)
00:22:13 <dons> ?eval nothing
00:22:23 <dons> does nothing, quickly
00:23:38 <roconnor> dons do you use the noop lib?
00:23:51 <vincenz> hi
00:24:00 <lispy> dons: i'd like to implement megahal in lambdabot...but every time i've tried to understand the algorithm i've found that i'm AI retarded...
00:24:03 <dons> no, i rolled my own noop. is that bad? maybe i should have gone for code reuse
00:24:12 <dons> lispy: what about a binding to MegaMonad?
00:24:13 <lispy> heh
00:24:24 <lispy> dons: url?
00:24:32 <dons> i'm not sure if we have one. hmm
00:24:41 <dons> have to check the logs from a couple of years ago..
00:24:42 <lispy> i had a lisp version of megahal that shell'd out to the megahal binary
00:24:45 <dons> ?google megamonad
00:24:48 <lambdabot> http://www.haskell.org/hawiki/MegaMonad
00:24:48 <lambdabot> Title: MegaMonad - The Haskell Wiki
00:24:55 * lispy reads
00:25:21 <dons> oh, its a megaHal
00:25:23 <vincenz> hey dons
00:25:39 <dons> hey
00:25:41 * vincenz is happy as he got another email from the girl accross the globe :)
00:25:58 <dons> :)
00:25:59 <lispy> it would be fun to reimplement megahal, i just have a hard time reading the C source...it uses a lot of globals and static variables
00:26:01 <vincenz> extremely busy?
00:26:12 <lispy> vincenz: i have a crush now too...yay, we're twins ;)
00:26:22 <vincenz> lispy: woot :)
00:27:04 <vincenz> dons: so how do I do the blosxom thing?
00:27:15 <lispy> well, it would be really fun to reimplement megahal and train it using google's 1 trillion word 5-gram dataset
00:27:39 <lispy> then it would probably talk perfect blogger english
00:27:42 <dons> vincenz: just install it :) and follow the docs.
00:27:52 <vincenz> it's cgi?
00:27:55 <vincenz> or offline generation?
00:27:56 <dons> yep
00:28:00 <dons> you can do offline too
00:28:02 <vincenz> ah so I'd have to install it on uni server
00:28:06 * vincenz hopes they allow cgi
00:28:13 <dons> you could do it offline, if you wish
00:28:36 <vincenz> how do you get it to work with your template?
00:28:52 <Korollary> you should train it using AOL user search history
00:28:53 <vincenz> (btw do you use ome kind of templating system to fill your content while keeping the over al template of your system))
00:30:14 <lispy> Korollary: my previous megahal bot i trained in #gentoo for a bit, man...that was just wrong
00:30:27 <lispy> Korollary: it kept reciting these HUGE commandlines to compile things
00:30:46 <lispy> it was also very condecending
00:33:55 <vincenz> damn
00:33:59 <vincenz> no cgi support on uni server
00:34:18 <lispy> not even with ~/public_html/cgi-bin/ ?
00:35:01 <vincenz> no
00:35:46 <lispy> :(
00:36:49 <dons> just generate offline, into a darcs repo, and push
00:37:14 <vincenz> good idea :)
00:37:27 <vincenz> so just push the entire html directory into my public_html :)
00:38:18 <roconnor> is MegaHAL a crazy old man on a subway?
00:39:13 <vincenz> dons: could you email me the stuff (configuration/template) you use to generate the /blog page on your website?
00:40:01 <kfish> dons: which blosxom do you use?
00:41:15 <dons> kfish: hmm. which version?
00:41:43 <vincenz> @karma+ dons for all the help on the webpage
00:41:43 <lambdabot> dons's karma raised to 49.
00:42:15 <dons> blosxom 2.0, i think
00:48:48 <mcnster> ?malloc
00:48:49 <lambdabot> Unknown command, try @list
00:48:56 <mcnster> @malloc
00:48:57 <lambdabot> Unknown command, try @list
00:49:01 <mcnster> argh
00:49:02 <vincenz> ???
00:49:05 <vincenz> @type malloc
00:49:07 <lambdabot> Not in scope: `malloc'
00:49:09 <eugene_beast> @list
00:49:09 <lambdabot> list [module|command]. Where modules is one of:
00:49:10 <lambdabot> babel base compose dice dict djinn drhylo dummy elite eval fact fresh haddock help hoogle instances karma lambda localtime log more pl poll pretty quote search seen slap spell state system tell todo
00:49:10 <lambdabot> topic type unlambda url version vixen where
00:49:10 <vincenz> @hoogle malloc
00:49:11 <lambdabot> Foreign.Marshal.Alloc.malloc :: Storable a => IO (Ptr a)
00:49:11 <lambdabot> Foreign.ForeignPtr.mallocForeignPtr :: Storable a => IO (ForeignPtr a)
00:49:12 <lambdabot> Foreign.ForeignPtr.mallocForeignPtrArray :: Storable a => Int -> IO (ForeignPtr a)
00:49:18 <kfish> dons: blosxom in perl, python, haskell?
00:49:34 <mcnster> hoogle??
00:50:07 <dons> kfish: oh, perl.
00:50:16 <mcnster> sometimes when watch my screen in this room i think i'm having a flashback :-)
00:51:55 <kfish> dons: ah :) i wrote a C version, an experience that made me not like C any longer: http://bother.kfish.org/browser/blossom/trunk/src/libblossom
00:51:56 <lambdabot> Title: /blossom/trunk/src/libblossom - kfish - Trac
00:52:18 <kfish> dons: chak's rss code is pretty close in functionality to blosxom, but in haskell
00:52:31 <dons> ah, right. I should investigate
00:52:41 <dons> he recommended it to me, but i got blosxom working faster
00:53:00 <kfish> http://www.cse.unsw.edu.au/~chak/haskell/lambdaFeed/
00:53:00 <lambdabot> Title: Manuel M T Chakravarty - lambdaFeed
00:53:39 <dons> ?where lambdaFeed
00:53:39 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/lambdaFeed/
00:53:48 <kfish> nice :)
00:55:21 <mcnster> pop quiz:  how many bytes in a C short on x86-64?
00:56:18 <mcnster> lemme see...
00:57:10 <dons> ?karma+ QuickCheck -- spotted a bug for me
00:57:10 <lambdabot> QuickCheck's karma raised to 8.
01:03:23 <Itkovian> mcnster: that would be 2
01:03:26 <Itkovian> imo
01:05:18 <mcnster> Itkovian, thanks
01:05:32 <Itkovian> mcnster: I haven't checked though
01:05:42 <Itkovian> but I can do so quickly if you need it
01:05:44 <Itkovian> a sec.
01:06:02 <mcnster> Itkovian, i checked a few minutes ago, but didn't want to break my flow
01:06:18 <mcnster> ... so i thought i'd break somebody else's :-D
01:06:21 <Itkovian> yep 2
01:06:57 <Itkovian> I think it's all the same except maybe long, and of course long long, which is a native 64 bits
01:07:14 <Itkovian> long is 8
01:07:28 <Itkovian> long long too
01:07:57 <Itkovian> the c standard says int has the native width, but on x86-64 it's still 32
01:08:03 <Itkovian> the other sizes are relative to that
01:08:31 <Itkovian> as in sizeof(char <= sizeof(short) <= sizeof(int) <= sizeof(long) <= sizeof(long long) afaik
01:08:46 <mcnster> Itkovian, yep yep
01:09:05 <Itkovian> which sucks and doesn't suck in a strange way :-)
01:09:58 <roconnor> ?karma+ Haskell
01:09:59 <mcnster> Itkovian, i love c because it has the flexibility of a chinese contortionist...
01:09:59 <lambdabot> Haskell's karma raised to 6.
01:10:12 <Itkovian> hehe
01:10:17 <mcnster> Itkovian, ...but i wouldn't want to have to maintain it
01:11:35 <Itkovian> true
01:11:43 * Itkovian loves c too :-)
01:15:46 <mcnster> foreign q:  if i have "foreign import ccall unsafe "do_foo" doFoo" and do_foo() returns void, what should the last element of type signature of doFoo be?
01:16:17 <dons> IO ()
01:16:23 <mcnster> oh doh!
01:16:28 <mcnster> thanks, dons :)
01:16:36 <dons> types -- they're fun :)
01:17:13 <mcnster> bowling for types
01:25:43 <vincenz> hmm
01:25:50 <vincenz> dons: how abou the blosxom settings and the commandline?
01:26:16 <dons> Data.ByteString now has 551 equivalence properties describing the libraries behaviour :)
01:26:41 <dons> vincenz: blosxom settings, oh, i'll send the file
01:26:50 <dons> command line? for offline mode? you'll have to work that out, since i use cgi
01:27:33 <vincenz> okies
01:27:45 <dons> sent.
01:28:01 <dons> the web page for blosxom has a simple guide to using offline mode
01:28:52 <vincenz> thx
01:29:29 <Cale> I just finished watching a guy beat both Megaman X and Megaman X2 at the same time with a single sequence of input.
01:29:38 <Philippa> wow
01:30:00 <dons> is Cale MegaMonad?
01:30:00 <Philippa> sequels in "just like the original" shocker? :-)
01:30:11 <Cale> hehe
01:30:14 * Philippa is annoyed they're not putting out the MMX Collection over here though
01:37:30 <mcnster> thread q:  i have a thread that makes a foreign call to poll(), but it seems to block the other threads from running.  help
01:40:28 <mcnster> nm.  i made "forkIO $ foo bar" instead of "forkIO (foo bar)"
01:40:53 <mcnster> but as an additional complication.  my gtk2hs window no longer responds to events  :-(
01:41:54 <mcnster> so i'm still stuck.  any ideas?
01:43:19 <mcnster> yeah, if i give data to the poll(), the interface responds.  argh
01:47:01 <vincenz> dons: it's working, but not using the template
01:47:05 <vincenz> dons: suggestions for template usage?
01:47:49 <mcnster> vincenz, do you know how to wait on a file descriptor natively in haskell?
01:47:54 <vincenz> mcnster: fraid not
01:48:45 <Lemmih> @type System.IO.hWaitForInput
01:48:47 <lambdabot> GHC.IOBase.Handle -> Int -> IO Bool
01:49:13 <mcnster> ok, 'cept i need to wait on a bunch of them
01:51:07 <mcnster> and a haskell Handle is not a file descriptor
01:57:33 <Saulzar> mcnster, It's because you're using use threads and poll is not yielding, you could use -threaded with forkOS and use system threads
01:57:58 <Saulzar> Er, user threads
01:58:06 <Lemmih> -threaded doesn't go well with gtk2hs.
01:58:11 <Saulzar> Hmm
01:58:15 <vincenz> dons: one thing that bugs me about darcs: you can't darcs push remotely if there is no darcs installed there
01:58:20 <vincenz> dons: personally I find that a bit weak
01:58:31 <vincenz> after all ftp does it without remote darcs
01:58:41 <Saulzar> It should be ok, provided you don't call gtk2hs from other threads than the "main" thread
01:58:55 <xerox> vincenz - it needs to check the state of the remote darcs repository somehow.
01:59:34 <Saulzar> As far as I know most gui toolkits act like that, gtk2hs should have no problem if you're not calling any gtk functions from other threads (you just have to funnel them to the main thread)
02:01:25 <mcnster> Saulzar, I tried setting a 1ms timeout on the poll() but now the poll() never detects data on the fd
02:01:31 <vincenz> xerox: ftp does it fine without remote darcs tool
02:01:52 <xerox> vincenz: what do you mean?
02:02:02 <mcnster> brb
02:02:20 <xerox> It also need to apply the patches to the source code.
02:03:44 <vincenz> xerox: again, you can push over ftp without remote invocation
02:03:56 <xerox> I.e. you overwrite the remote repository?
02:04:01 <vincenz> well duh
02:04:17 <xerox> You might use rsync for that, I think.
02:04:26 <xerox> ....or scp or something.
02:11:04 <vincenz> dons: fixed!
02:11:34 <mcnster> got the timeout on poll() to jive with gtk2hs!
02:11:42 * mcnster sets karma +1 mcnster
02:15:58 <vincenz> xerox: yeah finally using rsync :D
02:20:37 <dcoutts__> Saulzar: no it's worse than that
02:21:02 <dcoutts__> since the 'main' Haskell thread can migrate from one OS thread to another
02:21:52 <dcoutts__> linking using -threaded can seriously break Gtk2Hs progs as ndm discovered
02:22:29 <dcoutts__> it may not show up normally but eg on a hyperthreaded cpu it is very likely to break
02:23:52 <dcoutts__> the right thing to do is use threads with the trick described in the FAQ
02:24:42 <dcoutts__> mcnster: http://haskell.org/gtk2hs/archives/2005/07/24/writing-multi-threaded-guis/
02:24:43 <lambdabot> Title: Gtk2Hs » Blog Archive » Writing multi-threaded GUIs
02:24:59 <dcoutts__> mcnster: do not link using -threaded
02:25:32 <mcnster> dcoutts__, thanks for the tip.  i solved the problem by setting a timeout in poll()
02:25:42 <dcoutts__> I recently changed Gtk2Hs's init function to fail if you link using -threaded to prevent people shooting them selves in the foot! :-)
02:26:12 <dcoutts__> mcnster: huh? which poll?
02:26:12 <mcnster> cool
02:26:25 * dcoutts__ is missing some context here
02:26:51 <mcnster> sorry, i needed to poll some foreign file descriptors, but was getting hung up without a timeout and yield
02:27:39 <dcoutts__> so what do you use to poll the FDs?
02:28:03 <mcnster> poll() as a foreign import
02:28:12 <dcoutts__> oh, right
02:28:40 <dcoutts__> if you're doing it that low level you might prefer to use the glib main loop features for that
02:28:49 <dcoutts__> see inputAdd
02:29:05 <mcnster> ahso!  i wondered about that....
02:29:14 <dcoutts__> so you gave up on using Haskell threads?
02:29:23 <dcoutts__> that's the usual way to do poll in Haskell
02:29:37 <mcnster> not all all.  i fork off a thread ala the faq which listens for events on the midi port
02:29:39 <dcoutts__> one thread per FD and thread-bocking io
02:29:46 <dcoutts__> ok
02:30:29 <mcnster> what i'm trying to figure out now is:  can i change the state of the interface within my forked off thread?
02:34:30 <Saulzar> dcoutts, Ouch, that's painful.
02:35:09 <Saulzar> What happens when -threaded becomes "default" ?
02:35:09 <dcoutts__> mcnster: so long as you're not linking with -threaded then you can just call any gui function from any thread
02:35:12 <dcoutts__> so it's easy
02:35:33 <mcnster> set button [ active := True ]     doesn't seem to compile.... hints?
02:35:33 <dcoutts__> Saulzar: I was talking to JaffaCake about this the other day
02:36:02 <Saulzar> Hmm, you could always create another thread specifically for gtk2hs
02:36:15 <Saulzar> Which isn't the "main" thread, would that work?
02:36:18 <dcoutts__> mcnster: look up the attribute you want in the docs, it's organised by widget and there is a search feature (hoogle)
02:36:51 <mcnster> i looked it up.  the property is "active".  yet nolo comileo
02:36:55 <dcoutts__> Saulzar: the problem is what happens when you make a GUI call and you're not in the same OS thread that initialised Gtk+
02:37:01 <mcnster> compileo
02:37:07 <Saulzar> Yep..
02:37:27 <Saulzar> So if you fork at the beginning, and then do everything from the "other" thread - will it go walkabouts?
02:38:52 <mcnster> @hoogle active
02:38:52 <lambdabot> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
02:38:53 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
02:38:53 <lambdabot> System.Win32.Info.cOLOR_ACTIVEBORDER :: SystemColor
02:38:53 <dcoutts__> yes, if it's not a bound thread
02:39:23 <mcnster> @hoogle gtk2hs
02:39:24 <lambdabot> No matches found
02:39:31 <mcnster> @hoogle set
02:39:32 <lambdabot> Data.Set :: module
02:39:32 <lambdabot> Data.Set.Set :: data Set a
02:39:32 <lambdabot> Directory.setCurrentDirectory :: FilePath -> IO ()
02:39:52 <mcnster> argh
02:40:14 <mcnster> the property *is* "active"
02:41:35 <dcoutts__> mcnster: do you not mean sensitivity?
02:43:07 <dcoutts__> I do not know where you're getting this active property from
02:43:10 <mcnster> nope.  i actually want to change the state of a radio button group when an event hits my handler
02:43:28 <mcnster> http://developer.gnome.org/doc/API/2.0/gtk/GtkToggleButton.html#GtkToggleButton--active
02:43:29 <lambdabot> Title: GtkToggleButton
02:44:03 <dcoutts__> mcnster: toggleButtonActive
02:45:24 <mcnster> dcoutts__, well holy smoke--it works!  where did you get toggleButtonActive from?
02:45:46 <dcoutts__> mcnster: from the Gtk2Hs docs rather than the Gtk+ docs
02:45:48 <mcnster> oh i see what he's done
02:45:54 <mcnster> makes sense
02:46:31 <mcnster> thank you, dcoutts, i'm one step closer to total world domination :-D
02:46:33 <dcoutts__> it's actually a limitation of Haskell's module system in my opinion
02:46:53 <dcoutts__> the fact that it's toggleButtonActive rather than ToggleButton.active
02:47:13 <mcnster> yes, the module system is broken in exactly the way i think you are suggesting
02:47:21 <mcnster> i was thinking that this afternoon
02:47:23 * vincenz has a new website
02:47:25 <vincenz> :)
02:47:31 <vincenz> ripoff from dons' design
02:47:58 <dcoutts__> Saulzar: so yeah you could fork a bound thread to run mainGUI but then you can't bind any more Haskell threads to that same OS thread, so we still would not be able to use threads
02:48:23 <mcnster> thank you, dcoutts__
02:48:29 <dcoutts__> mcnster: np
02:48:41 <dcoutts__> Saulzar: and using a GUI function in any other thread would be unsafe
02:49:47 <dcoutts__> what I was talking to JaffaCake about was the possability of binding multiple Haskell threads to a single OS thread
02:50:08 * xerox thinks of jaffacakes .... yummy!
02:50:13 <dcoutts__> :-)
02:50:13 <xerox> 'morning :)
02:50:28 <dcoutts__> hia xerox, got the patches?
02:50:33 <xerox> Yup!
02:51:27 <xerox> I need breakfast now, I'll miss your crunchy cereals :D
03:00:13 <mnislaih> Lemmih: are you around ?
03:09:48 <int-e> dcoutts__: Where would that threaded init check be? In initGUI?
03:10:00 <shapr> @yow !
03:10:00 <lambdabot> What's the MATTER Sid? ... Is your BEVERAGE unsatisfactory?
03:10:03 <dcoutts__> int-e: let me check
03:10:13 <shapr> dcoutts__: Hey, is the cabal-get code from your laptop pushed?
03:10:30 * int-e can't find it.
03:12:06 <dcoutts__> shapr: yes
03:12:21 <mnislaih> Lemmih: how's the hacking on breakpoint going ?
03:12:35 <dcoutts__> int-e: seems I didn't push it, pushed now
03:13:01 <shapr> dcoutts__: spiffy, thanks.
03:13:08 <shapr> hej polli, long time no see.
03:13:34 <polli> shapr: yes, a very long time no see :) how's code?
03:13:44 <shapr> Code is good, how's yours?
03:14:02 <polli> it's good
03:14:29 <int-e> dcoutts__: Ok, then I'll complain now that I know what I'm doing and want to do exactly that. :-P
03:14:33 <polli> wow, the number of users in the channel has exploded :)
03:14:47 <shapr> I think our max is 226 so far.
03:14:53 <dcoutts__> int-e: huh?
03:15:20 <int-e> dcoutts__: I'm running it in a bound thread and communicating with an MVar so everything is executed in the right bound thread.
03:15:25 <polli> wow, I think we where about 30 or so when I was idling here.
03:15:37 <polli> is AngloHaskell done?
03:15:46 <shapr> Yup, it's over. It was fun!
03:15:48 <shapr> Want to see pix?
03:15:59 <polli> sure
03:16:04 <shapr> http://www.undecidable.org.uk/edwin/photo/anglohaskell.php
03:16:05 <lambdabot> Title: AngloHaskell
03:16:13 <dcoutts__> int-e: you're running initGUI + mainGUI in a bound thread and then doing what exactly?
03:16:23 <shapr> I'm writing up a summary of AngloHaskell.
03:16:29 <dcoutts__> shapr: cool :-)
03:16:32 <polli> I regularly check your blog :) just to keep up with Haskell stuff
03:16:44 <int-e> then the thread continues to poll an MVar (IO ()) and executing everything it receives there.
03:16:46 <shapr> dcoutts__: Did I already ask you if I should use dons' fusion slides or if you have something more/other?
03:17:03 <dcoutts__> shapr: nothing more recent that is written down
03:17:13 <shapr> Ok
03:17:25 <dcoutts__> int-e: so mainGUI blocks, so are you using the polling yield thing?
03:17:44 <basti_> hey, be sure to annouce something like that early next time huh
03:18:08 <basti_> i know i wasnt there for quite a while but ^^
03:18:12 <mwc> Holy god. http://www.undecidable.org.uk/edwin/photo/anglohaskell.php?photo=IMG_0406.jpg
03:18:14 <lambdabot> Title: AngloHaskell
03:18:22 <int-e> dcoutts__: I have a timeout but it doesn't yield, instead it does a tryTakeMVar.
03:18:27 <mwc> I've never seen that many bikes in one place... evre.
03:18:40 <mwc> I think that just doubled the number of bikes I've seen in my lifetime
03:18:57 <dcoutts__> int-e: ok, right. yes, that sounds safe so long as you always do all gui stuff via that mechanism
03:19:21 <shapr> mwc: It's common at train stations in Europe.
03:19:37 <dcoutts__> int-e: hence you don't want that check, yes I see. Hmm.
03:19:55 <mwc> shapr, how well do unicycles do hills, say something light like a 20% grade (1 vertical meter for 5 horizontal meters)
03:20:02 <dcoutts__> int-e: I suggest you don't pull that patch for now :-) I'll think of something.
03:20:20 <dcoutts__> mwc: 20% is rather steep on a normal bike too!
03:20:31 <int-e> dcoutts__: I didn't pull it. I can change my code, mind you, but I wanted to let you know that there's a way to use that safely.
03:20:55 <shapr> mwc: With 175mm cranks, I can go up hills where mountain bikes have trouble.
03:21:00 <dcoutts__> int-e: yes, but it's not a very nice solution, I wouldn't want to ask everyone to use it
03:21:04 <mwc> dcoutts__, and I get to haul a CroMoly framed bike up it every day. My quads are just obscene.
03:21:26 <dcoutts__> mwc: I find unicycles are good uphill and harder downhill
03:21:28 <int-e> dcoutts__: agreed
03:21:33 <shapr> dcoutts__: Yeah, I agree.
03:21:37 <shapr> Maybe if I could glide...
03:21:41 <dcoutts__> hah
03:21:50 <mwc> shapr, so changing your crank size is how you change your gearing ratio?
03:22:04 <Saulzar> I can imagine the consequences of going 75k/h on a unicycle down hill...
03:22:18 <mwc> Saulzar, especially since you'll be running pretty fast :P
03:22:19 <Saulzar> People are stupid enough to do it on 2 wheel bikes :)
03:22:29 <mwc> I've done it at 60 on that hill
03:22:38 <dcoutts__> mwc: or changing the wheel size
03:22:49 <mwc> luckily for me, when I had my tire blowout, it was on level ground and not on that
03:22:57 <dcoutts__> mwc: I've got two unicycles with different wheel sizes
03:23:00 <mwc> I kind of wisened up about the dire consequences of that sort of behaviour
03:23:01 <shapr> mwc: Sort of...
03:23:17 <shapr> Longer cranks and smaller wheels are easier uphill.
03:23:30 <edwinb> mwc: There was another bike park just like it on the other side of the road...
03:23:48 <mwc> Hmmm, isn't it hard to use a large crank since your stride length is much longer?
03:23:55 <mwc> I'd think that'd give you balance problems
03:24:26 <shapr> Yes, longer cranks require a longer stride. That's irritating when you want to go fast.
03:24:48 <mwc> I suppose with a unicycle, you could do s-curves across the face of the hill in order to lessen the effective gradient
03:25:02 <shapr> That's right, that's the easiest way to get more torque.
03:25:34 <shapr> Once the slope gets to steep for that you start 'pecking' where you use the unicycle more like a pogo stick.
03:25:37 <shapr> too*
03:25:46 <mwc> sounds like something that'd be fun to try, I just need to get safe on bicycles first.
03:25:52 <mwc> shapr, that sounds really difficult
03:26:12 <mwc> (Wrecked my bike 3 times requiring $100s in repairs)
03:26:17 <shapr> As you can guess, the s-curves are done at each stride to get your weight most directly uphill.
03:26:32 <shapr> You should try my unicycle, it should be near indestructible.
03:26:32 <mwc> Hmm, sounds like a neat physicsy sort of problem
03:26:42 <mwc> I'm more worried about the operator
03:26:43 <shapr> There are some neat research papers about unicycle physics.
03:27:03 <shapr> The simplest way to jump in is with the inverse pendulum approach.
03:27:49 <mwc> Hmm, sounds like fun. My balance is terrible though. You should have seen the number of backflops I did last time I attempted a front flip dive.
03:28:13 <shapr> Unicycling is more about training than innate balance.
03:28:17 <shapr> Much like walking :-)
03:28:37 <shapr> hiya greenrd, did you end up with an all-night trip back?
03:29:12 <greenrd> shapr: yeah, got into dublin at 6am
03:35:11 <int-e> dcoutts__: To be honest I don't like that interface either. But it allows writing an application that does big computations in background, while staying responsive, and with the ability to kill those background jobs easily.
03:37:22 <int-e> dcoutts__: with a single thread I run the risk of gtk+ never getting a chance to run at all, or, alternatively, spending most of my precious CPU time in gtk's idle loop.
03:48:07 <Itkovian> suppose I want to read Integers from a ByteString, what's the best way to proceed? simply embracing and extending  Data.ByteString.Lazy.Char8.readInt is not a good idea - takes up 37% of execution time. readInt (which gets called just as much, takes only 4.9%)
04:06:30 <dcoutts__> Itkovian: which readInt is slow vs fast? do you mean the lazy one is slow compared to the non-lazy one?
04:07:12 <dcoutts__> int-e: I find that the polling thing doesn't take much cpu time and is reasonably responsive
04:11:24 <Itkovian> dcoutts: no, no, readInt is doing very fine, thank you very much. However, my bytestring contains values that are too large to hold in 32 bit, so I'd like to use an Integer for that ... as a test I copied readInt and modified it to readInteger, which reduced the runtime of my app significantly, but a new profile shows that readInteger is far slower than readInt - imo because it repeatedly multiplies an Integer with 10 and add the next digit.
04:11:45 <dcoutts__> right yes
04:12:01 <Itkovian> I thought of using an Int and promoting it to an Integer accumulator each time the Int will overflow, i.e. when the i argument of the loop is a multiple of say 9
04:12:11 <dcoutts__> Itkovian: have you looked at how the normal read works for Integer on String
04:12:12 <Itkovian> or, better, 8
04:12:29 <Itkovian> dcoutts__: nope. good idea
04:12:31 <dcoutts__> or GMP might have an effecient impl
04:13:34 <int-e> there's little magic in the standard readInt, it just unboxes a lot of stuff.
04:14:27 <dcoutts__> int-e: so whay not just use the single threaded rts and use the polling yield thing?
04:14:43 <dcoutts__> you're not using mulple cpus for performance are you?
04:16:13 <int-e> dcoutts__: Because I'm not trusting the RTS scheduler. Either it gives the gtk thread a chance to run, then my program will be sleeping most of the time, or it won't, then it'll be irresponsive.
04:18:33 <int-e> dcoutts__: the first gets in the way of long computations. It's not a problem for the usual interactive GUI programs.
04:21:41 <int-e> dcoutts__: if the gtk main loop was implemented on the Haskell side (using gtk's select interface. it has one, I don't remember the details) the story might be different.
04:22:14 <int-e> dcoutts__: because then the RTS could do the select, notice there's nothing new for gtk and resume my computation.
04:22:28 <dcoutts__> int-e: well it's notquite that bad, the yielding several times per second means that if you've got runnable Haskell threads then they get most of the cpu time
04:22:49 <dcoutts__> int-e: yes, if we could do the select on the Haskell side that'd be a good integration point
04:23:00 <dcoutts__> howeer we can't do that either at the moment
04:23:41 <dcoutts__> if the IO manager thread allowed us to block on several FDs at once then that might work
04:23:59 <dcoutts__> it's certainly one of the more promising techniques
04:24:03 <int-e> can't you spawn several IO threads for that? hmm.
04:24:13 <dcoutts__> yeah but that'd be horribly slow
04:24:21 <int-e> would it?
04:24:29 <dcoutts__> one Haskell thread per fd per select()
04:25:23 <int-e> hmm. maybe it would. strangely I'm not concerned about speed on the UI end.
04:26:07 <dcoutts__> but as I say, if we can get a little more cooperation from the IO manager then it's quite plausable
04:42:07 <roconnor> @where jhs
04:42:07 <lambdabot> I know nothing about jhs.
04:42:09 <roconnor> @where jhc
04:42:10 <lambdabot> http://repetae.net/john/computer/jhc/
04:45:17 <shapr> @users
04:45:19 <lambdabot> Maximum users seen in #haskell: 221, currently: 215
04:52:00 <boegel> shapr: y0
04:55:01 <mathrick> "One cannot write a program which is particularly lacking in assignment statements, or particularly referentially transparent."
04:55:03 * mathrick giggles
04:58:56 <shapr> y0 y0
05:00:28 <shapr> mathrick: Where's that from?
05:00:52 <mathrick> http://www.md.chalmers.se/~rjmh/Papers/whyfp.html
05:00:54 <lambdabot> Title: Why Functional Programming Matters
05:05:51 <shapr> mathrick: I wonder if the languages of the future will do just that. I know that code in Perl means different things in different places. I'd like to be able to mix and match type systems, laziness, etc.
05:06:37 <mathrick> perhaps, but considers also what incredible mental burden a short piece of perl can be
05:06:56 <mathrick> context alone should be a reason to kill people responsible for their inception
05:06:59 <mathrick> *contexts
05:07:44 <shapr> On the other hand, most people consider a short piece of Haskell to be a mental burden because there are so many concepts you need to know before you can read it.
05:08:20 <mathrick> yes, but mixing and matching doesn't exactly help things here :)
05:08:47 <shapr> That's true.
05:09:07 <shapr> On the other hand, Haskell does let you define DSLs, so you probably could already have chunks that were typed differently.
05:09:22 <shapr> It could definitely be done with a preproc.
05:10:39 <mathrick> DSL == ?
05:10:44 <shapr> domain specific language
05:11:20 <mathrick> aha, I don't know that part of haskell at all
05:11:41 <shapr> you probably do...
05:12:19 <edwinb> It's the best approach to programming: First, write the language that's best for your program, then write your program in it ;)
05:12:34 <edwinb> Haskellers do that all the time without realising it...
05:13:05 <mathrick> shapr: maybe, if you could give me a better idea of where it occurs
05:14:53 <edwinb> At one extreme, you could think of an algebraic datatype as the abstract syntax for a language, and a function over it as an interpreter.
05:15:09 <edwinb> that's perhaps going a bit far
05:15:58 <mathrick> damn you, I'm playing a puzzle game and you're making me think
05:16:08 * mathrick frowns upon edwinb 
05:16:51 <mathrick> oh damn, and now also the language of the music I listen to changed
05:16:59 * mathrick dies from excessive context switches
05:17:29 <shapr> y0 pstickne
05:17:32 <shapr> ahem psnl
05:17:47 <shapr> edwinb: I don't think that's going too far.
05:18:03 <vincenz> Unable to apply inverse patch!
05:18:05 <vincenz> why is this?
05:18:07 <shapr> psnl: Nice to meet you in person.
05:18:18 <psnl> and you
05:18:20 <mathrick> vincenz: depends on what you're trying to do
05:18:25 <shapr> mathrick: Look at this - http://www.haskell.org/haskore/onlinetutorial/index.html
05:18:26 <lambdabot> Title: The Haskore Tutorial
05:18:34 <psnl> oh, that reminds me: is greenrd around?
05:18:35 <vincenz> mathrick: I want to rollback to an older version
05:18:38 <edwinb> shapr: I might argue that 'length' as an interpreter function for 'lists' is a little too, er, abstract
05:18:39 <vincenz> mathrick: like a really old one
05:18:56 <edwinb> but it's usually the way I think when I write more complicated things
05:19:00 <shapr> mathrick: type Pitch = (PitchClass, Octave)
05:19:04 <shapr> edwinb: ok, good point
05:19:16 <shapr> mathrick: data PitchClass = Cf | C | Cs | Df | D | Ds | Ef | E | Es | Ff | F | Fs | Gf | G | Gs | Af | A | As | Bf | B | Bs
05:19:23 <psnl> greenrd: I have some ribena that must be yours
05:19:38 <shapr> mathrick: Since you were talking about music, I figured Haskore would be a good way to introduce DSLs.
05:19:44 <mathrick> vincenz: here you go, it's probably too discrepant by now
05:19:51 <mathrick> vincenz: can you get incremental patches?
05:20:18 <mathrick> shapr: umm, I only listen to music, I have no idea about music itself
05:20:21 <mathrick> but let's see
05:20:40 <shapr> Look at http://www.haskell.org/haskore/onlinetutorial/basics.html
05:20:41 <lambdabot> Title: Haskore Tutorial: Basics
05:20:49 <vincenz> mathrick: I have all the patches!
05:20:56 <vincenz> mathrick: it's pissing me off
05:21:07 <vincenz> I want a really old version, what's the use of this if you can't back old versions :(
05:21:10 <shapr> The original version of Haskore is lots of fun in GHCi.
05:21:23 <mathrick> vincenz: okay, so you're trying to revert the most recent one and it barfs?
05:21:29 <vincenz> unrecord
05:21:31 <vincenz> not revert
05:21:31 <shapr> You can play demo music that comes with Haskore, or write your own.
05:21:35 <vincenz> sam with unpull
05:21:37 <vincenz> same
05:21:41 <mathrick> vincenz: unwhat?
05:22:50 <vincenz> unpull
05:22:52 <vincenz> and unrecord
05:23:43 <mathrick> are we talking patch(1) here?
05:24:03 <shapr> Sounds like darcs
05:24:09 <shapr> hiya tennin, how's code?
05:35:02 <greenrd> psnl: yes, it is. however, it's not worth posting it to me, surely
05:35:39 <greenrd> psnl: I knew I'd forgotten something
05:35:51 * psnl shrugs
05:36:31 <psnl> I take it you got home safely and nothing whent wrong
05:38:18 <greenrd> psnl: yeah, well I had to take the night ferry so arrived at 6am, but apart from that, yeah :)
05:44:33 <shapr> greenrd: Hey, did I already ask you for your slides?
05:44:56 <greenrd> shapr: they're on the wiki - I need to fix the bugs tho
05:45:12 <greenrd> I'll do that soon
05:45:53 <shapr> spiffy
05:57:28 <vincenz> what's the HTML for having something as is
05:57:35 <shapr> <pre></pre>
05:57:39 <vincenz> thx
06:01:53 <vincenz> shapr: got a new website :)
06:02:02 <vincenz> http://www.esat.kuleuven.ac.be/~cpoucet/
06:02:06 <lambdabot> Title: Christophe Poucet
06:02:11 <vincenz> I copied dons' design
06:02:18 <vincenz> tho I'll prolly change it a bit so it's less of a clone
06:02:29 <vincenz> much more organized than a crappy pmwiki, though it requires manual maintenance
06:04:31 <shapr> Hope is great! But hard to install :-(
06:04:39 <shapr> xerox: Code faster! ;-)
06:04:57 <vincenz> who's in charge of planet haskell
06:05:04 <shapr> ibid
06:07:57 <shapr> I've been teaching Haskell to my girlfriend. When I showed her how Python, etc have mutable variables she thought that was insane.
06:08:11 <jgrimes_> :)
06:08:12 <musasabi> :-)
06:08:21 <Itkovian> @paste
06:08:21 <lambdabot> http://paste.lisp.org/new/haskell
06:08:25 <shapr> "How can you write usable code when something might have been changed without you knowing it?"
06:08:56 <jgrimes_> thinking back, it does seem kind of odd.
06:09:12 <musasabi> @karma+ shapr
06:09:13 <lambdabot> shapr's karma raised to 21.
06:09:20 <shapr> It's funny to see Haskell through the eyes of someone new to programming. Many things she accepts without question as being the only way to do it.
06:09:21 <int-e> that *is* a good question.
06:09:41 <shapr> Amusingly, she thinks types are insufficiently descriptive.
06:09:49 <shapr> She wants the type to be a full derivative of the function.
06:10:00 <vincenz> shapr: I've convinced the girl I'm in love with to learn haskell :)  AS soon as I see her I get to teach her haskell \o/
06:10:12 <shapr> I'm going to show Epigram to my gf, I think she'll like it.
06:10:13 <lisppaste2> itkovian pasted "readInteger" at http://paste.lisp.org/display/23869
06:11:00 <Itkovian> dons: can you pass me your thoughts on the paste? it assembles an Integer from a ByteString by extending the readInt function
06:11:57 <Itkovian> It's still not up to speed imo, but I don't readily see a better way to code it.
06:12:11 <musasabi> shapr: well once we get the system FC wrapping more descriptive types in Haskell should be easier.
06:12:19 <shapr> How so?
06:12:45 <shapr> From what I understand of Epigram, I get to freely mix code and types in a definition.
06:12:52 <musasabi> shapr: with the current translation hiding parts of a type is harder since there are limitations for the use of fundeps.
06:13:03 <shapr> wah?
06:13:39 * musasabi tried to do some fancy type<->value reflection and it was quite fun in Haskell
06:13:46 <shapr> oh tell me more!
06:13:53 <shapr> Speaking of which, do you want to write another TMR article?
06:14:02 <shapr> Type value reflection sounds way spiffy.
06:14:11 <shapr> @users
06:14:12 <lambdabot> Maximum users seen in #haskell: 221, currently: 216
06:14:40 <Itkovian> keen on how many people you reach with a TMR question shapr?
06:14:47 <shapr> hm?
06:15:06 <shapr> ik begrijp het niet?
06:15:07 <musasabi> shapr: yes, I do want to write an article. Unfortunately the comonad stuff does not work at the moment. (or it works but the size of the types was exponential in the worst case)
06:15:22 <shapr> musasabi: Anything that furthers understanding would be good.
06:15:33 <shapr> Have you seen the comonads & AGs article by Uustalu & Vene?
06:15:35 <vincenz> shapr: seen my blog?
06:15:39 <shapr> vincenz: Not yet
06:15:56 <kosmikus> shapr: which article?
06:15:59 <musasabi> shapr: yes. But I want to generalize over all possible AGs.
06:16:20 <shapr> kosmikus: http://www.scannedinavian.com/hope/entry/76
06:16:31 <musasabi> shapr: basically I want to have transformers from one AG to an another AG that are polymorphic.
06:16:35 <shapr> musasabi: I haven't gotten enough out of U&V's paper to know what you mean.
06:16:45 <musasabi> while keeping the entire structure of said AGs in the types.
06:17:00 <shapr> Itkovian: What do you mean?
06:17:15 <vincenz> shapr: I plan to blog like you do :)
06:17:16 * shapr hasn't had enough sleep recently.
06:17:18 <shapr> vincenz: Oh cool!
06:17:22 <shapr> How do I blog?
06:17:24 <vincenz> @karma+ shapr for blogging
06:17:24 <lambdabot> shapr's karma raised to 22.
06:17:27 <Itkovian> shapr: well, you check how many people may have read your TMR question :-)
06:17:29 <vincenz> shapr: about stuff you read
06:17:44 <Itkovian> my question seemed to lack a verb
06:17:46 <shapr> Itkovian: oh!
06:17:50 <shapr> vincenz: Oh right
06:17:54 <vincenz> Itkovian: verbs are overrated
06:18:04 <Itkovian> they're better than nouns
06:18:08 <shapr> vincenz: I think of lots of things to post, but I mostly forget them before I get to a keyboard.
06:18:09 <vincenz> nah
06:18:12 <vincenz> nouns can be verbified
06:18:21 <vincenz> shapr: likewise, I always have conversations in my head
06:18:23 <Itkovian> verbs can be nounified
06:18:28 <vincenz> shapr: maybe I have some form of ADD
06:18:53 <shapr> vincenz: Ask a qualified doc
06:19:00 <vincenz> what kind of doc?
06:19:03 <vincenz> like a house medic?
06:19:28 <shapr> I went to an ADD specialist in Birmingham, AL. But you can probably talk to a general doc and see if he can refer you to a good specialist.
06:20:22 <dons> vincenz: nice website! :)
06:20:51 <greenrd> shapr: Well, when you think about it, x = x + 1 IS a pretty strange statement. It does throw people at first.
06:20:55 <shapr> dons: What happened with Hope?
06:21:11 <shapr> greenrd: Sure, I agree. We learn equations when we're kids, and then programming doesn't do that.
06:21:14 <dons> it all got too hard. esp. needing to set up mysql
06:21:25 <shapr> Oh, there's FlatDB and pgsql backends as well.
06:21:40 <vincenz> dons: =D
06:21:43 <shapr> I've been wondering about a reiserfs backend.
06:21:48 <vincenz> dons: yeah yeah
06:21:53 <vincenz> dons: I plan to change the colors, no worries :)
06:22:00 <shapr> kosmikus: Seen that article already?
06:22:01 <dons> so i instead went with a 400 line perl script (though i might switch to lambdaFeed)
06:22:16 <dons> vincenz: :) good to see you got the blog working
06:23:18 <shapr> I wonder if Halfs could be a db backend?
06:23:48 <shapr> vincenz: Speaking of profiling, have you read Trevor Blackwell's thesis?
06:24:49 <vincenz> shapr: maybe, don't know
06:24:54 <vincenz> dons: thanks :)
06:27:59 <LordBrain> I dont suppose anyone knows how to make irssi page up a whole screen instead of half way
06:28:15 <vincenz> LordBrain: page up twice
06:28:19 <LordBrain> lol
06:28:34 <vincenz> =D
06:28:46 <LordBrain> that is assuming the number of lines in the window is even
06:28:47 <musasabi> Who was the HDBC person?
06:29:19 <kosmikus> shapr: I must have missed it somehow. I don't think I have ...
06:29:36 <shapr> musasabi: CosmicRay
06:29:46 <musasabi> @seen CosmicRay
06:29:47 <lambdabot> I saw CosmicRay leaving #haskell-blah, #darcs and #haskell 15 hours, 26 minutes and 19 seconds ago, and .
06:40:46 <kosmikus> hi boliver
06:46:33 <musasabi> Is there really no generic connection function for HDBC?
06:47:11 * musasabi would like to make HAppS support HDBC, but it seems quite painful if I have to write #ifdefs for each database backend
06:47:35 <Lemmih> There really isn't.
06:47:49 <musasabi> so what is one supposed to do?
06:48:00 <musasabi> lots of autoconf magic and #ifdefs?
06:48:13 <musasabi> (and does anyone have such code available?)
06:48:58 <Lemmih> Detecting what packages/backends are available is a bit tricky.
06:49:31 <Lemmih> How about letting the user supply the 'connect' function?
06:49:54 <musasabi> Lemmih: the parameter should be serializable.
06:50:18 <musasabi> of course I could refactor things.
06:53:53 <mnislaih> Lemmih: how is the breakpoint stuff, anything new?
06:55:52 <xerox> shapr: hey, long nap, I also hadn't got enough sleep :)
06:56:30 <ricky_clarkson> I looked at lisp a bit, and I've looked at Haskell even less.  Haskell's syntax seems more obscure than Lisp's or any imperative language's (maybe even Clean is less strange).  Is this an artefact of static typing?
06:56:34 <Lemmih> mnislaih: Nope, nothing that you aren't already aware of.
06:57:08 <mnislaih> so when do you plan to work on this?
06:57:22 <Lemmih> mnislaih: Soon (:
06:57:25 <mnislaih> I really need it as soon as possible Lemmih
06:58:08 <mnislaih> do you have design ideas ?
06:58:19 <mnislaih> maybe I can give it a try if you give me some few pointers
06:59:04 <xerox> Lemmih: hey there, did you push your patch?
06:59:11 <Lemmih> ricky_clarkson: Nope, our syntax isn't really related to static typing.
06:59:31 <musasabi> is executeMany automatically inside one transaction?
06:59:56 <Lemmih> xerox: I'll do that right now.
07:00:11 <xerox> Thank you, I don't remember the exact details.
07:00:14 <SamB> how are you supposed to find out if a given character is a double-width character or a single-width character?
07:00:41 <SamB> isn't that supposed to be in a database somewhere?
07:01:48 <norpan> that would depend on the font, no?
07:03:02 <norpan> or call wcswidth :)
07:03:03 <kosmikus> I'm always surprised that people find Haskell's syntax obscure ...
07:03:09 <SamB> someone had earlier given me the impression that, for character-matrix applications, there were some chars that were always supposed to take two cells, and others that were supposed to take one...
07:03:25 <SamB> (in Unicode)
07:03:39 <norpan> wcwidth()
07:04:02 <SamB> is there a Haskell equivalent, just out of curiosity?
07:04:51 <SamB> there ought to be something in Data.Char...
07:05:15 <norpan> i don't think there is a standard for the width
07:05:27 <Lemmih> xerox: Pushed.
07:05:28 <SamB> huh
07:05:31 <norpan> http://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c
07:05:52 <xerox> Lemmih: thanks!
07:05:56 <SamB> norpan: huh
07:06:03 <SamB> someone must have been confused!
07:06:20 <norpan> many people are confused
07:06:35 <SamB> true, dat
07:06:35 <norpan> but at least there is a call in posix to get the width
07:06:36 <Lemmih> ricky_clarkson: Lots of mainstream languages (C/C++/Java etc) are statically typed.
07:07:05 <SamB> but C's static typing gives it little safety
07:07:36 <dons> ricky_clarkson: the syntax issue is just that: syntax. haskell's was chosen to be nice for humans. most others are chosen to be nice for machines ;)
07:07:53 <ricky_clarkson> Lemmih: Yes, and in comparison to dynamically-typed languages C/C++/Java tend to be verbose.
07:08:21 * SamB goes to write a Haskell module to try it in
07:08:30 <ricky_clarkson> I use and like the safety, I am just wondering whether the syntax 'overhead' is a necessary one.
07:08:36 <dons> the type system has nothing to do with the syntax though, ricky_clarkson
07:08:38 <kosmikus> ricky_clarkson: I think that's just coincidence
07:08:40 <dons> they're completely separate
07:08:41 <SamB> oops
07:08:57 <SamB> I wcwidth is what I am trying, I meant to say that in #nsrt
07:08:59 <LordBrain> dons, pull from my yi repo again... your Vim.hs is broken due to the Direction ADT changes
07:09:21 * dons was pondering a C with do-notation today
07:09:31 <ricky_clarkson> It's a pretty big coincidence.
07:09:41 <ricky_clarkson> Can you think of any language that breaks this coincidence?
07:09:46 <Lemmih> ricky_clarkson: Statically typed languages aren't more verbose than dynamically typed ones. They just tend to be more low-level.
07:09:51 <kosmikus> ricky_clarkson: Haskell?
07:09:53 <SamB> ricky_clarkson: coincidence?
07:09:58 <SamB> what coincidence?
07:10:32 <ricky_clarkson> Can you think of any statically typed language with simple syntax, or any dynamically typed language with complex syntax?
07:10:32 <musasabi> Does anyone have a small HDBC example code fragment to post?
07:10:36 <ricky_clarkson> SamB: Scroll up.
07:10:52 * SamB kind of thought the reason Haskell was about the same as dynamically typed languages in terms of verbosity was the type inference
07:10:53 <Lemmih> ricky_clarkson: I think you'll find that Haskell is more terse than most dynamically typed languages (eg. Python).
07:11:01 <ricky_clarkson> kosmikus: Haskell, to me, does not have simple syntax.  There is bias in this though.
07:11:15 <dons> by simple, do you mean concise?
07:11:15 <kosmikus> ricky_clarkson: certainly not verbose, though
07:11:16 <SamB> ricky_clarkson: it *is* simple to read
07:11:29 <dons> or do you mean, the grammar is small?
07:11:38 <SamB> that is, my internal parser likes it well
07:13:33 <ricky_clarkson> Ok, I'll go off and think, thanks for the input.
07:13:48 <SamB> isn't the number one reason C code is so verbose the fact that you need to declare the type of every variable before using it?
07:14:20 <SamB> the lack of closures doesn't help either
07:14:23 <kosmikus> not the only reason
07:14:35 <kosmikus> no layout
07:14:43 <SamB> that doesn't help
07:14:44 <LordBrain> types do add readability tho, in haskell we can leave them off
07:15:06 <SamB> well, it seems superflouos for local variables a lot of the time...
07:15:15 <SamB> @spell superflouos
07:15:17 <lambdabot> superfluous supercilious superfluously superfluities superfluity
07:15:22 <SamB> heh
07:15:24 <LordBrain> it requires prototypes for functions too
07:15:35 <SamB> swapped 'o' and 'u' in that last part...
07:15:47 <LordBrain> you cant do forward referencing
07:15:53 <SamB> yeah, function prototypes are annoying too
07:15:58 <LordBrain> so you have to use headers and things
07:16:12 <SamB> either I have to write them or I have to put my functions in an illogical order
07:16:23 <SamB> I noticed ASM doesn't have this problem
07:16:42 <yozora> I'm playing with an expression interpreter, with class Eval t r where eval :: t -> r
07:17:01 <yozora> and I'm doing IfThenElse
07:17:37 <yozora> instance (Eval c Bool, Eval a r) => Eval IfThenElse a r
07:17:54 <yozora> but this gives an undecidable instance because of the Bool in the constraint
07:18:01 <yozora> what's the right way to do this?
07:18:22 <dons> ricky_clarkson: btw, if your syntax question was about conciseness/verbosity, its interesting to see the shortest languages on the great language shootout: perl, haskell, python, forth, ocaml, ruby, sml. so the typing has nothing to do with the brevity :)
07:19:21 <dons> however, static typing does seem to correlate with fast languages: for speed: D , C , C++, Eiffel, SML, Fortran, Ocaml, Haskell
07:20:06 <dons> so that would make an interesting intersection for both short && fast languages ;)
07:20:36 <yozora> sorry, instance (Eval c Bool, Eval a r) => Eval (IfThenElse c a) r
07:22:39 <kosmikus> also, short languages all start with lowercase letters, whereas fast languages start with uppercase letters ;)
07:23:00 <dons> heh
07:23:08 <SamB> hmm, what type do I use to pass wint_t via FFI?
07:23:24 * dons -> sleep
07:24:03 <boliver> yozora: Is there any reason why you are not using GADTs instead of type classes?
07:24:31 <boliver> I think for that problem GADTs would be more adequate
07:24:58 <boliver> unless your interpreter needs to be extensible
07:25:01 <kosmikus> good night dons
07:25:32 <yozora> i just read that Software Extensibility with Type Classes paper
07:25:42 <yozora> didn't know that Haskell could solve the expression problem
07:25:47 <SamB> hmm, apparantly Char works for me...
07:25:58 <yozora> so I was playing with an expression interpreter
07:26:05 <SamB> yozora: expression problem?
07:26:16 <yozora> extend both data and functions
07:26:26 <yozora> without having to modify or recompile existing code
07:26:39 <yozora> in FP languages extending data is hard, in OO adding functions is hard
07:26:44 <SamB> it can?
07:26:51 <yozora> yeah
07:26:59 <yozora> you write class Exp
07:27:09 <yozora> and write your data types individually
07:27:13 <yozora> rather than using a sum type
07:27:17 <SamB> oh
07:27:24 <yozora> have them instance the Exp class
07:27:43 <SamB> but how do you pass them around?
07:27:48 <yozora> and use Exp as a precondition for the added functionality
07:27:49 <LordBrain> anyone studied the hlist version of oo in haskell?
07:28:04 <boliver> well, you can take a look at the paper: "Generics as a Library"
07:28:05 <SamB> hlist is wierd
07:28:39 <boliver> where the something similar happens
07:28:44 <yozora> normally, I think; it was just a toy, but it worked just fine
07:28:58 <boliver> and we basically need to solve the Expression problem in Haskell
07:29:11 <yozora> there are problems with returning one of these types though
07:29:19 <boliver> it can avoid some extra type class machinery
07:29:24 <SamB> joelr showed us that, after a certain point, GHC's typechecker took *waay* too many resources to check things using it...
07:30:08 <kgu> hi, i need some help with hat
07:30:15 <xerox> What is the expression problem?
07:30:52 <yozora> expression problem: making both data and functions on data extensible
07:31:00 <yozora> without recompiling or modifying existing code
07:31:14 <boliver> yozora: see http://web.comlab.ox.ac.uk/oucl/work/bruno.oliveira/Generics.pdf
07:31:36 <LordBrain> why is hlist weird?
07:31:56 <SamB> oh, nevermind
07:31:56 <xerox> yozora - what about higher-order-functions for the latter part?
07:32:15 <yozora> which latter part?
07:32:40 <SamB> I think yozora meant "the ability to add more functions and have them work on appropriate kinds of data"
07:33:46 <xerox> yozora - extending functions.
07:33:48 <yozora> I guess I'm wondering why constraints in instance declarations disallow instantiated types
07:33:52 <kosmikus> xerox: if you extend a datatype with a new alternative (data constructor), it's necessary to adapt previously written functions to work on the new constructor. if a function is parameterized by another functions, this isn't really an issue ...
07:34:28 <yozora> yeah, what he said ;)
07:35:26 <xerox> ?lisppaste
07:35:26 <lambdabot> Unknown command, try @list
07:35:30 <xerox> ?paste
07:35:30 <lambdabot> http://paste.lisp.org/new/haskell
07:37:27 <LordBrain> are ? and @ interchangeable to lambdabot or do they have special meanings?
07:37:43 <yozora> the GHC notes say it's to make sure context reduction terminates, but my understanding of this type theory stuff is very shallow
07:37:55 <xerox> My idea is that you add a new function wrapping the previously-defined cases in clauses that call the old one.
07:38:06 <xerox> But it needs writing a new function, and a series of clauses.
07:39:35 <kosmikus> xerox: then you need (1) a way to make pattern match failure explicit (for instance by manually returning a Maybe value), and (2) you have to handle recursion manually, because when you define a preliminary version of a function, you don't know the final version yet ...
07:40:49 <yozora> i read about OCaml's polymorphic variants, but I'm still not quite sure now it handles function extension without wrappers...
07:41:00 <kosmikus> xerox: sounds very much like the "polymorphic variants" approach ... (see papers by Jacques Garrigue)
07:41:29 <kosmikus> yozora: it uses wrappers
07:41:44 <yozora> is that really solving the extension problem?
07:42:23 <yozora> cuz you end up having lots of different versions of the same function
07:42:34 <yozora> operating on more and more types
07:42:41 <kosmikus> to a certain extent.
07:43:19 <kosmikus> it's not bad per se to have all these versions. sometimes, you might still want to work on a smaller version of a type. it depends on how much work you have to do as a programmer to get it all sorted out.
07:43:54 <kosmikus> I'm not sure how well polymorphic variants behave in practice, because I'm not an O'Caml programmer.
07:44:21 <kosmikus> btw, there's a Haskell Workshop paper this year by Koji Kagawa on polymorphic variants in Haskell ...
07:44:51 <yozora> sounds all polymorphic variants get you is that type coalescing thing
07:45:31 <yozora> i was hoping it would do pattern match clause analysis so it would restrict the return type if you restricted the input type
07:48:35 <LordBrain> ocaml doesnt have type classes does it?
07:48:46 <kosmikus> no
07:48:54 <yozora> it uses functors, I think
07:48:58 <kosmikus> but an ML-like module system
07:49:41 <LordBrain> its been a while since i tried ocaml, i know it didnt then, i thought maybe they decided to add it tho
07:50:29 <dylan> type classes + the object system would probably be insane
07:50:30 <LordBrain> i cant remember how ocaml does polymorphism
07:50:51 <LordBrain> does any ocaml programmer use their object system tho?
07:51:03 <LordBrain> lol
07:51:03 <dylan> LordBrain: the people that write things like lablgtk do
07:51:14 <LordBrain> ok
07:51:27 <dylan> otherwise people use functors.
07:52:28 <dylan> There's actually a very vocal minority (one person) calling for the removal of the object system.
07:53:11 <LordBrain> hmmm
07:53:12 <boliver> dylan: wouldn't you basically get ML?
07:53:41 <kowey> i saw a gerard huet talk once, and he made a very big deal out of "there are objects in this code! only functors"
07:53:48 <dylan> well, you'd get caml.
07:53:49 <kowey> s/there are/there are no/
07:53:57 <LordBrain> well i know someone who came from doing a lot of OO, and didnt like Ocaml because he felt the OO system was tacked on to lure OO people into a functional pardigm, while its being sold as you get to pick your paradigm
07:54:20 <dylan> the object system seems to have been imp,emented to explore virtual types.
07:54:36 <LordBrain> he felt it was crippled...
07:55:00 <boliver> dylan: what is the difference between caml and ml?
07:55:07 <LordBrain> he wanted to use the Object system for various things, and was just told to use the modules instead.
07:55:46 <dylan> boliver: hmm, not much. Ocaml has pattern guards, SML doesn't... ocaml only has one type of type declaration, SML has two (one for types that are comparable, another for ones that arn't)
07:56:18 <LordBrain> i think he would agree with your vocal minority, either improve the object system or remove it.
07:56:20 <dylan> I'm only really familiar with ocaml.
07:56:34 <dylan> the object system is quite powerful.
07:56:47 <kosmikus> http://www.ps.uni-sb.de/~rossberg/SMLvsOcaml.html
07:56:48 <lambdabot> Title: SML vs. Ocaml
07:56:56 <boliver> ok, thanks
07:57:04 <dylan> it's possible to have 'functional objects',  where every method call just returns a mutated object.
07:57:25 <boliver> I knew that Ocaml had the extra object stuf
07:57:40 <dylan> there's also polymorphic variants.
07:57:42 <boliver> but didn't know where did SML and caml differ
07:57:54 <dylan> Which I think they added to make interfacing with C easier, but that's just my theory
07:59:21 <dylan> (polymorphic variants, in C code, are an integer which is a hash of a string, e.g. vhash("Foo") is the C equiv of `Foo. This is easier than regular variants, which are integers based on the order of definition... e.g. type foo = Foo | Bar, in C, Foo == 1, etc.)
08:07:48 <kgu> well, a question,  can i implement a enterprise application in haskell, with a database and a good GUI? somebody did it?
08:09:32 <vincenz> gui => gtk2hs
08:10:58 <gds> @where HDB
08:10:59 <lambdabot> I know nothing about hdb.
08:11:41 <gds> @where HDBC
08:11:41 <lambdabot> http://quux.org/devel/hdbc
08:11:45 <gds> Ah :)
08:11:50 <kgu> yes, but i think that gtk2hs is too much low level, it's like C,
08:12:22 <Spark> make a nice wrapper for your needs
08:12:22 <kgu> something a bit elegant?
08:13:23 <kgu> yes, iknow hdbc too, but ... it's MVC really suitable for FP ?
08:13:56 <kgu> some opinion?
08:14:25 <kgu> somebody knows Functional Reactive Programming ?
08:14:52 <kgu> is FRP really useful?
08:15:37 <kgu> @where hat
08:15:38 <lambdabot> http://haskell.org/hat
08:51:40 <vincenz> \o/
08:51:43 <vincenz> I'm on planet.haskell
08:53:19 <stepcut> heh
08:54:40 <xerox> You made it! :)
08:58:04 <dgoldsmith> SamB, norpan: re: single- vs. double-cell characters, Unicode defines the East Asian width property: http://www.unicode.org/reports/tr11/
08:58:05 <lambdabot> Title: UAX #11: East Asian Width
08:58:07 <xerox> Lemmih: do you know what OutputGen is in CabalInstall/Types.hs?
09:01:34 <Lemmih> xerox: It's evil and should be removed.
09:02:13 <xerox> Lemmih: I agree, lots of scary IO.
09:02:47 <shapr> Speaking of which, what's the next step to get cabal-{get,put} working for the average user?
09:03:32 <xerox> I am writing a mail to the list to explain it now, I started coding but there are some unknown things I need to ask explanation of.
09:03:45 * shapr eagerly awaits
09:04:03 * basti_ reads the paper about the relation of comonads to dataflow programming
09:04:14 <shapr> Cool paper, yeah?
09:04:22 <Lemmih> shapr: An up-to-date packages repo, I would say.
09:04:37 <xerox> Lemmih: what about the index creation?
09:05:08 <xerox> Lemmih: you have to choose wethere to create the current index format and fix the url entries by hand, or wait for the new tarball-index format.  I think.
09:05:15 * SamB could use a hint as to how to follow the blueprint when he can't read it and doesn't know what format it is in
09:05:18 <shapr> Lemmih: Will the repo work with any legal cabal package?
09:05:19 <Lemmih> xerox: Well, a tool to automate the index creation would be convenient.
09:05:45 <xerox> Lemmih: you tried it, it has the url problem, right?
09:05:53 <Lemmih> shapr: The packages need to be tgz'ed and added to an index.
09:06:17 <shapr> The index will be built by a cron job or something, yeah?
09:06:43 <basti_> shapr: yes
09:06:44 <xerox> The new index is just a tarball, so you just have to do tar to make it.
09:06:44 <Lemmih> xerox: We can drop the URL completely by making it relative (I think).
09:06:50 <Lemmih> shapr: No.
09:06:59 <xerox> The URL is somewhat a problem.
09:07:55 <shapr> Ok, how do I add packages to the repo?
09:08:00 <kowey> has anybody played with mogul, the oz user library thing? http://www.mozart-oz.org/mogul/
09:08:04 <lambdabot> Title: MOGUL: the MOzart Global User Library
09:08:20 <xerox> The Let me see if I can explain it.
09:08:23 <Lemmih> shapr: You upload a tarball and run 'cabal-server-install'.
09:08:29 <kowey> i only ask because of this relevant-looking quote "maintenance of a MOGUL Archive should require no work. It must be fully automated"
09:08:43 <xerox> With the current index format you can have multiple packages from different repositories
09:09:01 <Lemmih> shapr: 'cabal-server-install' will check that the tarball is valid and update the index accordingly.
09:09:18 <SamB> vincenz: do you have any hints?
09:09:29 <xerox> Well I suppose it's okay if we discuss this on the mailing list
09:09:44 <vincenz> SamB?
09:09:51 <shapr> Is there a script to automate creating and uploading a tgz from a darcs repo with cabal file?
09:10:04 <vincenz> SamB: oh no idea
09:10:09 <Lemmih> shapr: Not yet.
09:10:26 <Lemmih> shapr: (we don't even have a working 'cabal-server-install')
09:10:42 <SamB> I wish I could read the proof myself instead of having the process of reading it described to me
09:10:48 <sjanssen> shapr: there is darcs dist to make the tarball
09:11:03 <SamB> (the supposed proof of the Censory Engine's correctness)
09:11:18 <xerox> I am summarizing the ideas for the mailing list.
09:12:20 <shapr> What should cabal-server-install actually do?
09:12:46 <xerox> Now it should add a package to the hierarchy and generate the index file
09:13:12 <Lemmih> shapr: It should check that the tarball is valid and then update the index.
09:13:50 <xerox> After changing the index file format no code will be needed, except if we want to do some QA.
09:13:52 <shapr> How much of that code is already written?
09:14:04 <Lemmih> shapr: Almost all of it.
09:17:09 <tibbe> any Cabal devs here?
09:18:46 <Lemmih> Yep.
09:19:52 <tibbe> Lemmih, any easy way to build a .deb package for Ubuntu? I spotted a debian dir in there
09:20:23 <shapr> xerox: Do you have any code that's not checked into the repo?
09:20:30 <Lemmih> There's a tool called dh_haskell for building .deb files from Cabal projects, I think.
09:22:15 <basti_> what is a least fixed point?
09:22:54 <xerox> shapr: yes.
09:23:44 <basti_> ...operator.
09:23:44 <shapr> basti_: http://en.wikipedia.org/wiki/Least_fixed_point
09:23:48 <basti_> ah
09:24:51 <basti_> :-o
09:38:59 <emertens> What does it mean if someone says that "You hold your mug like you've been drinking coffee all your life" ?
09:39:46 <emertens> .
09:40:05 <basti_> i don't have a clue.
09:40:12 <emertens> Me neither
09:40:16 <basti_> maybe that you're hugging it like a teddy bear?
09:48:22 <xerox> SyntaxNinja: hi
09:48:23 <heatsink> Who maintains the documentation at haskell.org/ghc/docs/?  I want to make a correction to the porting guide.
09:48:25 <SamB> oh man, apparantly this involves the playing cards...
09:48:40 <xerox> I am writing the email, it's huge. Lots of ideas and problems.
09:51:56 <SyntaxNinja> w00t
09:52:13 <SyntaxNinja> heatsink: it's probably in ghc source.
09:53:21 <SyntaxNinja> xerox: how's cabal-install coming? :)
09:54:49 <heatsink> SyntaxNinja, found it, thx
09:56:30 <xerox> SyntaxNinja: sent!
09:57:21 <xerox> I hope I have made some sense.
09:57:30 <xerox> shapr: your questions should be answered there.
09:59:23 <gaal> Hi folks, trying my luck again. I have a class definition that I want to put in a boot file, but GHC rejects it:
09:59:27 <gaal> class (Monad m, Functor m, Eq a, Data a, Typeable a) => ICoercible m a | a -> m
09:59:32 <gaal> any idea why?
10:00:13 <xerox> @localtime SyntaxNinja
10:01:01 <gaal> (declaration, that is.)
10:01:13 <xerox> I'm sorry I never used boot files.
10:01:56 <gaal> I'm sorry I have to :-)
10:01:57 <heatsink> gaal: What's the error message?
10:02:35 <gaal> Illegal class definition I think, let me reproduce the exact message
10:02:43 <gaal> not very detiled anyway.
10:04:05 <tibbe> Lemmih, I ran dh_haskell and it created some stuff under debian/, what now?
10:04:12 <tibbe> no .deb file though
10:04:28 <SyntaxNinja> tibbe: "debuild"
10:05:28 <tibbe> no such command
10:07:11 <kzm> dh_haskell?
10:07:40 <tibbe> already ran that
10:07:48 <SyntaxNinja> xerox: thanks!
10:07:50 <tibbe> it put some stuff under debian/
10:08:01 <SyntaxNinja> tibbe: apt-get install devscripts;debuild
10:08:19 <gaal> heatsink: the precise error is "Illegal class declaration in hs-boot file"
10:08:34 <SyntaxNinja> tibbe: debuild is the debian tool that takes a source directory with a debian directory, and creates a binary .deb from it.  that's what you want to do, right?
10:09:05 <musasabi> CosmicRay: any HDBC example code lying around?
10:09:19 <boegel> I'm surprised there's nothing in the Prelude which generates all possible combinaties of elements in a list...
10:09:29 <CosmicRay> musasabi: http://darcs.complete.org/hpodder/DB.hs
10:09:37 <boegel> > let l = [[1],[2],[3]] in (++) l $ concat $ [map (x++) l | x <- l]
10:09:39 <lambdabot>  [[1],[2],[3],[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
10:09:42 <CosmicRay> musasabi: http://darcs.complete.org/hdbc-testsuite/testsrc/
10:09:43 <lambdabot> Title: Index of /hdbc-testsuite/testsrc
10:09:48 <xerox> SyntaxNinja: I hope I have made some sense, I really need feedback and some explanations at this point.
10:09:57 <kzm> No, no, the name piqued my curiousity.  I didn't know about it, and from the name, I think I need it. :-)
10:09:58 <boegel> I've gotten this far, but I want all possible combinations, i.e. up to elements
10:10:01 <boegel> any pointers?
10:10:09 <musasabi> thanks
10:10:16 <CosmicRay> musasabi: http://darcs.complete.org/gopherbot/DB.hs
10:10:30 <kzm> boegel, it's left as an excercise for the reader/student/etc
10:10:36 <CosmicRay> musasabi: that's it, from the top of my head.
10:10:40 <boegel> kzm :)
10:11:14 <boegel> kzm: well, I'm very rusty on Haskell, but it has been a good exercise so far... I guess foldl/foldr would be usefull here?
10:11:44 <emertens> I'm sure this is a silly question, but is there any value of 'a' such that: \x -> (x < a) && (x > a) is True?
10:11:56 <SyntaxNinja> xerox: yes, you made sense. I don't know what that function is, I emailed audrey.
10:12:04 * vincenz LAUGHS OUT LOUD at the spam he just got
10:12:07 <emertens> @type (<)
10:12:09 <lambdabot> forall a. (Ord a) => a -> a -> Bool
10:12:13 <SyntaxNinja> xerox: what does outputGen look like it does
10:12:18 <vincenz> "Have you always wanted to sexually perform on demand? Has your cum ever dribbled and you wish it had  shot out?"
10:12:20 <SyntaxNinja> vincenz: must be nice
10:12:23 <heatsink> gaal: Hmm, I don't know what that means.  You might want to make sure -fglasgow-exts is set, just in case.
10:12:30 <xerox> SyntaxNinja: sorry I don't understand
10:12:32 <SyntaxNinja> er vincenz why bother reading those?
10:12:33 <kzm> emertens, dependss on the implementation of (<)?
10:12:45 <SyntaxNinja> xerox: tell me more about outputgen
10:12:50 <tibbe> I guess I failed to edit the SyntaxNinja, yes it is, although I get this: dpkg-checkbuilddeps: warning: can't parse dependency ghc6 (6.4)
10:12:50 <vincenz> SyntaxNinja: it wasn't spammified in thunderbird
10:12:58 <vincenz> SyntaxNinja: so when clicking on it to move it to spam, I read part of it
10:13:20 <SyntaxNinja> tibbe failed to edit the SyntaxNinja, and you will all fail to edit me!!!
10:13:23 <tibbe> SyntaxNinja, I'm quite new to debian (you couldn't guess that could you ;)
10:13:37 <tibbe> oops :D
10:13:49 <dcoutts> xerox, yep that cabal-install email sumarises things well I think
10:13:53 <xerox> SyntaxNinja: I have encountered it in Update.hs, as gettingPkgList.
10:13:53 <tibbe> should I touch the rules file?
10:13:56 <SyntaxNinja> vincenz: open up your debian/control file and delete the (6.4) or something and see if it parses then.  also, you could read the manual on making debian packages :)
10:14:05 <xerox> dcoutts: we decided to not touch that function for some reason, right?
10:14:31 <gaal> heatsink: -fglasgow-exts does not help :(
10:14:38 <SyntaxNinja> xerox: why is it evil?
10:14:40 <tibbe> SyntaxNinja, I read the (very very long) manual once and was no wiser afterwards
10:14:52 <vincenz> SyntaxNinja: wrong peson?
10:15:00 <xerox> Lemmih thought so :) Do you have a wordy explanation?
10:15:10 <SyntaxNinja> xerox: did he write it?
10:15:20 <vincenz> SyntaxNinja: waas that intended for me?
10:15:20 <xerox> SyntaxNinja - I think he said he didn't.
10:15:41 <SyntaxNinja> vincenz: oops, no that was for tibbe
10:15:45 <xerox> Maybe I can find it out via darcs who wrote it.
10:15:45 <SyntaxNinja> vincenz: but you shuold do it too.
10:15:47 * xerox tries
10:15:54 <heatsink> gaal: What happens if you remove the fundep from the boot file?
10:16:04 <gaal> heatsink: no luck.
10:16:08 <vincenz> SyntaxNinja: using ubuntu, momentarily have 6.4.1
10:16:10 <gaal> first thing I tried :/
10:16:57 <dcoutts> xerox, you mean the OutputGen functions?
10:16:58 <SyntaxNinja> xerox: got a link to the file?
10:17:05 <heatsink> I dunno then...
10:17:09 <xerox> dcoutts: yes. gettingPkgList
10:17:11 <xerox> SyntaxNinja: sure, a sec
10:17:17 <dcoutts> I think the main issue we had with it that it's just a bunch of .. -> IO () actions
10:17:27 <dcoutts> and it's totally undocumented what they're supposed to do
10:17:38 <dcoutts> when we should call them etc
10:17:48 <xerox> SyntaxNinja: the definition http://darcs.haskell.org/packages/Cabal/Network/Hackage/CabalInstall/Types.hs
10:17:53 <vincenz> ok
10:17:57 * vincenz going home
10:17:57 <vincenz> bbl
10:18:03 <gaal> what's the correct mailing list to ask about this? glasgow-haskell-users?
10:18:08 <xerox> SyntaxNinja: one use http://darcs.haskell.org/packages/Cabal/Network/Hackage/CabalInstall/Update.hs
10:18:10 <dcoutts> and it's not explained why we need a class rathe than just simple functions, multiple front ends perhaps?
10:18:41 <xerox> dcoutts: which class?
10:19:02 <dcoutts> xerox, oh sorry, it's not a class is it, it's a record of IO actions
10:19:08 <xerox> Right.
10:19:16 * vincenz curses at scheme's horrible documentaiton
10:24:08 <_frederik_> is there a shorter way to write "(\x y -> compare (fst x) (fst y))"?
10:24:36 <vincenz> _frederik_: nope :/
10:24:44 <emertens> @pl \(x,y) -> max x y
10:24:44 <lambdabot> uncurry max
10:24:48 <vincenz> @pl (\x y -> compare (fst x) (fst y))
10:24:48 <lambdabot> (. fst) . compare . fst
10:25:10 <xerox> ?wiki LicensedPreludeExts
10:25:10 <lambdabot> http://www.haskell.org/haskellwiki/LicensedPreludeExts
10:25:36 <xerox> comparing :: (Ord a) => (b -> a) -> b -> b -> Ordering
10:25:37 <xerox> comparing p x y = compare (p x) (p y)
10:25:41 <xerox> This is the usual solution
10:25:48 <xerox> Which aims to get in the library at some point.
10:26:55 <vincenz> xerox: it should be generalized
10:27:03 <vincenz> distribute f g x y = f (g x) (g y)
10:27:12 <vincenz> or
10:27:15 <vincenz> over
10:27:23 <xerox> Yeah I thought we had a name for that too
10:27:29 <vincenz> f `over` g x y = f (g x) (g y)
10:27:35 <vincenz> so you can do
10:27:43 <vincenz> (compare `over` fst) x y
10:27:55 * heatsink thought the name was "on"
10:27:58 <xerox> Maybe it was dmhouse that had it.
10:32:01 <emertens> @index trace
10:32:02 <lambdabot> Debug.Trace
10:32:36 <_frederik_> hmm thanks
10:32:46 <_frederik_> i will create 'over' or 'on'
10:32:47 <emertens> what package is trace in?
10:33:43 <musasabi> _frederik_: want to edit the TLS wiki-page? I added some questions for you under proposal 2.
10:33:50 <_frederik_> ok
10:33:51 <_frederik_> sigh
10:34:14 <_frederik_> making a suggestion always turns into a huge project
10:38:19 <SyntaxNinja> dcoutts, xerox: I don't know this function.
10:39:00 <dcoutts> SyntaxNinja, which one? I've missed the contex
10:39:44 <xerox> It is also evil because you don't see it in the import list at first
10:39:59 <xerox> It just comes from OutputGen(..) anyway
10:40:23 <SyntaxNinja> dcoutts: I don't know the OutputGen stuff I definitely didn't write that.  Maybe Audrey will reply.  Lemmih, you didnt' write that/
10:40:43 <edwardk> OutputGen?
10:40:58 <SyntaxNinja> edwardk: some cabal-install stuff
10:41:10 <edwardk> ah
10:41:19 <xerox> http://darcs.haskell.org/packages/Cabal/Network/Hackage/CabalInstall/Types.hs
10:41:54 <_frederik_> musasabi: i've responded. i'm actually using the new IOParam module in my code now, thanks for motivating me to write it
10:42:23 <_frederik_> although i've only tested it a little in situations with threads
10:43:08 <emertens> @pl f (x,y) = (f x, f y)
10:43:08 <lambdabot> f = fix ((`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .)))
10:43:20 <emertens> X-|
10:44:36 <xerox> emertens: use &&& !
10:44:45 <emertens> @type (&&&)
10:44:46 <lambdabot> forall (a :: * -> * -> *) c' c b. (Arrow a) => a b c -> a b c' -> a b (c, c')
10:44:48 <emertens> arrow related?
10:44:51 <emertens> ah yeah
10:45:00 <xerox> Oops
10:45:02 <xerox> *** I mean.
10:45:04 <emertens> (I'm definately not comfortable in Arrow world yet)
10:45:09 <emertens> @type (***)
10:45:10 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
10:45:19 <xerox> > ((*2) *** (+3)) 4
10:45:20 <lambdabot>  add an instance declaration for (Num (b, b'))
10:45:23 <xerox> > ((*2) *** (+3)) (3,4)
10:45:24 <lambdabot>  (6,7)
10:45:30 <xerox> > ((*2) &&& (+3)) 3
10:45:31 <lambdabot>  (6,6)
10:45:43 <musasabi> _frederik_: thanks for responding.
10:45:43 <emertens> interesting...
10:45:49 <xerox> There also are:
10:45:58 <xerox> > first (+2) (1,'a')
10:45:59 <lambdabot>  (3,'a')
10:46:17 <xerox> > second (:"b")) (1,'a')
10:46:18 <lambdabot>  Parse error
10:46:23 <xerox> > second (:"b") (1,'a')
10:46:24 <lambdabot>  (1,"ab")
10:46:36 <edwardk> arrows can be fun
10:46:47 <musasabi> _frederik_: some clarifications: 1) default values - e.g. I have a thread local variable named "cur_id" which should be "IORef Int" and if not initialized I would like it to be set to "newIORef 0".
10:46:51 <xerox> > ((+2) >>> (subtract 10) >>> (*2)) 10
10:46:53 <lambdabot>  4
10:47:36 <emertens> what about a way to turn do  maximum' [(1,2),(3,0)] -> (3,2)
10:47:39 <edwardk> heh, never really played with their unsugar syntax much
10:47:47 <xerox> ?type maximum
10:47:49 <lambdabot> forall a. (Ord a) => [a] -> a
10:48:41 <emertens> (maximum . map fst) *** (maximum . map snd)
10:48:41 <xerox> > (maximum *** maximum) . unzip $ [(1,2),(3,0)]
10:48:41 <emertens> ?
10:48:42 <lambdabot>  (3,2)
10:48:49 <xerox> :)
10:48:52 <emertens> ah
10:48:55 <emertens> done and done!
10:48:59 <musasabi> _frederik_: for the unsafePerformIO, the module using the TLS data would probably need to include the IOParam at toplevel. But creating IOParams appears to be in IO. Thus unsafePerformIO for their actual use?
10:49:16 <emertens> @index (***)
10:49:16 <lambdabot> Control.Arrow
10:49:32 <emertens> @pl \f -> f *** f
10:49:33 <lambdabot> join (***)
10:49:37 <xerox> Ye :D
10:49:43 <xerox> I wasn't sure about advicing that
10:49:52 <xerox> They say it's monad-abuse.
10:50:00 <edwardk> yeah
10:50:08 <xerox> Well it's just join f x = f x x.
10:50:09 <_frederik_> musasabi: i only see one use of unsafePerformIO
10:50:11 <xerox> ?type join
10:50:12 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
10:50:22 <xerox> Substitute (e ->) for m.
10:51:20 <_frederik_> musasabi: yeah do { r <- newIORef 0; newIOParam r }
10:51:42 <_frederik_> then it will have the value of 'r' by default
10:52:14 <musasabi> ok. That is good.
10:52:29 <_frederik_> that's at least what i intended
10:52:47 <musasabi> For the unsafePerformIO I was meaning code that actually uses Fu.IOParam. Does that typically need unsafePerformIO?
10:53:15 <_frederik_> yeah, just as code which uses global IORef's uses unsafePerformIO
10:53:37 <_frederik_> _dbs = unsafePerformIO $ newIOParam (undefined::DBState)
10:53:58 <musasabi> + NOINLINE + no-cse probably.
10:54:10 <_frederik_> sure
10:54:27 <musasabi> The Key proposal seems better in that regard. But on the other hand it is too vague.
10:54:53 * edwardk really needs to get more comfortably (ab)using the lesser used arrow symbols in normal code.
10:55:02 <edwardk> s/bly/ble/g
10:56:06 <_frederik_> musasabi: i haven't read http://www.haskell.org/hawiki/GlobalMutableState
10:56:07 <lambdabot> Title: GlobalMutableState - The Haskell Wiki
10:57:18 <_frederik_> musasabi: i figured a top-level "<-" would someday become available, but in any case my design is modelled after the IORef design
10:57:21 <musasabi> _frederik_: if you look at TLSVar it doesn't require unsafePerformIO in the client code. Neither do proposals 1 and 3.
10:57:54 <musasabi> Top level <- will probably become available for some subset of IO at some time.
10:58:37 <musasabi> (but I don't know of any concrete plans)
10:58:47 <jgrimes_> how can you pattern match on a value in a monad?
10:59:04 <jgrimes_> in a case statement
10:59:16 <musasabi> jgrimes_: like do x <- monadicAction; case x of ...;
10:59:29 <jgrimes_> ah ok.
11:00:01 <xerox> liyang had a proposal for caseM, fixM, and a bunch of other neat things, using idiom brackets.
11:01:49 <_frederik_> musasabi: but the other proposals add new syntax. i didn't want to do that. plus, what i said in "Comparison to Proposal 3" - i think an abstract data type that hides the internal implementation is better
11:01:52 <mcnster> hello
11:02:24 <_frederik_> (i'll check back but i'm going to work for a while)
11:02:57 * mcnster just installed his new Das Keyboard II... tremble at my l33tness :-)
11:04:21 <musasabi> c
11:04:41 <emertens> you "installed" in?
11:05:00 <emertens> is that "l33t" for "plugged it in" ? ;)
11:05:11 <mcnster> well, plugged into the usb port is kind of like doing an install... :)
11:05:16 * stepcut trembles
11:06:04 <mcnster> but but but... how many nanotubes in a wibble!  i know i know!
11:06:25 <mcnster> :)
11:08:09 <mcnster> wow, these Foosh energy mints really pack a punch!  i'm breathing in stereo!
11:11:49 <boegel> @hoogle [Bool] -> Bool
11:11:50 <lambdabot> Prelude.and :: [Bool] -> Bool
11:11:50 <lambdabot> Prelude.or :: [Bool] -> Bool
11:13:43 * edwardk returns to the channel from dealing with people. bah
11:13:44 * SamB tries uploading his rml file
11:13:51 <edwardk> > join (***) maximum $ unzip [(1,2),(3,0)]
11:13:52 <lambdabot>  (3,2)
11:29:21 <vincenz> Hi
11:30:09 <edwardk> heya vincenz
11:30:30 <vincenz> How are things
11:30:36 <edwardk> not bad
11:30:38 <vincenz> dons: ping?
11:30:40 <vincenz> Cale: ping?
11:31:11 * vincenz has finished Reasoned SChemer and is considering writing a kanren like system in haskell.  A) Has anyone done this?  B) Anyone interested in collaborating?
11:32:39 <mcnster> kanren?
11:32:40 <edwardk> hrmm. its just a logic programming system right?
11:33:17 <vincenz> yeah
11:33:26 <edwardk> i don't know of any implementation of it, but prolog clones abound. =)
11:33:35 <vincenz> not quite like prolog
11:33:37 <edwardk> (implementations in haskell that is)
11:33:38 <edwardk> yeah
11:33:40 <vincenz> schelog (also in scheme) is more like it
11:33:42 <vincenz> edwardk: oh?
11:34:31 <edwardk> the prolog thing? i've found half a dozen different papers on prolog -> haskell implementationes written over the last 8 years or so
11:34:47 <emertens> > ( ((+1) . fst) &&& uncurry max ) (3,7)
11:34:48 <lambdabot>  (4,7)
11:34:52 <edwardk> with varying degrees of power.
11:34:54 <emertens> any arrow magic for that?
11:34:56 <vincenz> edwardk: oh?
11:35:04 <emertens> > ( (first (+1)) &&& uncurry max ) (3,7)
11:35:06 <lambdabot>  ((4,7),7)
11:36:01 <edwardk> vincenz: heh, thats about it. if i find one in my documents folder i'll holler, but I stopped reading them after they hammered home their respective points.
11:36:04 <emertens> ( ((+1) . fst) &&& uncurry max ) (3,7) is the simplest I see
11:36:17 <vincenz> edwardk: I don't care about theory, I care about a usable system
11:37:22 <edwardk> dunno. haven't had to use any of them, so not sure about how well they work
11:38:49 <edwardk> http://lambda-the-ultimate.org/node/112 is the first one i came across iirc
11:38:50 <lambdabot> Title: Embedding Prolog in Haskell | Lambda the Ultimate
11:41:43 <emertens> what is the difference in >>> and >>^ ?
11:42:00 <xerox> ?type (>>^)
11:42:00 <SamB> @type (>>>)
11:42:01 <lambdabot> forall d b (a :: * -> * -> *) c. (Arrow a) => a b c -> (c -> d) -> a b d
11:42:02 <lambdabot> forall (a :: * -> * -> *) d b c. (Arrow a) => a b c -> a c d -> a b d
11:42:10 <SamB> which is which?
11:42:12 <xerox> None if you are using the (->) arrow.
11:42:14 <emertens> >>> is more general?
11:42:17 <xerox> Yes.
11:42:29 <edwardk> the type of the arguments. one is pure
11:42:32 <emertens> then why would you even need >>^
11:42:39 <SamB> you wouldn't
11:42:41 <xerox> emertens: for expressivity I believe
11:42:54 <edwardk> >>^ is used if you use a different kind of arrow
11:43:04 <edwardk> @type >>^
11:43:04 <mnislaih> vincenz: didn't you receive that book only a few days ago?
11:43:06 <lambdabot> parse error on input `>>^'
11:43:06 <SamB> p >>^ q = p >>> pure q
11:43:09 <emertens> so... (.) is just a specific case of (<<<)
11:43:10 <emertens> ?
11:43:11 <SamB> I think
11:43:14 <xerox> SamB: right.
11:43:26 <edwardk> yep
11:43:42 <emertens> what is (|||)
11:43:46 <emertens> I ont' know what ARrowChoice a is
11:44:02 <SamB> it is a *convenience* function for when you aren't just using the arrow combinators to make your code pointless
11:44:26 <emertens> pointfree?
11:44:32 <xerox> Yes.
11:44:37 <emertens> :-p
11:44:50 <SamB> pointfree, pointless
11:44:59 <xerox> (I don't see what does it have to do with points-free code, but whatever.)
11:45:02 <SamB> neither has a point, whats the diff?
11:45:23 <emertens> one is an judgement ;)
11:45:38 <SamB> anyway, its an old joke ;-)
11:45:46 <emertens> i know, that's why I brought it up
11:45:57 <SamB> see e.g. the @pointless command
11:46:06 <emertens> @pl f (x:xs) = (((+x) . fst) &&& uncurry max) $ f xs
11:46:07 <lambdabot> f = fix ((`ap` tail) . (. head) . flip ((.) . (&&& uncurry max) . (. fst) . (+)))
11:46:34 <vincenz> mnislaih: yes, finished it in the same day:)
11:46:53 <mnislaih> :O
11:46:54 <SamB> hmm, wouldn't that make more sense as a foldr?
11:46:54 <emertens> The _____ Schemer books are very thin
11:46:59 <emertens> and they read like comic books
11:47:05 <vincenz> reasoned
11:47:15 <emertens> I'll have to try that out
11:47:17 <emertens> good point
11:47:31 <xerox> ...or even a fix :)
11:48:25 <mnislaih> I have a pending order at Amazon, which ___ schemers do you recommend ?
11:48:45 <mnislaih> not all of them please, I cannot afford using all my money in books
11:49:07 <xerox> SICP!
11:49:36 <Adamant> SICP is the best
11:50:05 <mnislaih> I always think I should buy SICP to trick myself into reading it completely
11:50:12 <monochrom> Gosh, >>^ looks like an emoticon.  :^)
11:50:33 <emertens> f' = foldr (\x (a,b) -> (x + b, max a b)) (0,0)
11:50:37 <xerox> ((:) >>^)
11:50:48 <monochrom> mnislaih: it won't work.  I have read only 10% of what I buy. :)
11:50:56 <monochrom> s/buy/have bought/
11:50:59 <mnislaih> I was enjoying the SICP videos a lot... until some storm came, and I had to abandon in the middle of the course
11:51:23 <mnislaih> monochrom: it's been working for me lately
11:51:32 <monochrom> Ah ok good.
11:51:38 <mnislaih> I bought 'Types and programming languages' and I'm rocking now at chapter 21
11:51:55 <xerox> monochrom: same here! Unfortunately. I think it's party due to the computer.
11:52:18 <emertens> f' = foldl' (\(a,b) x -> (x + b, max a b)) (0,0)  even better
11:52:43 <monochrom> need someone to DDoS the freenode servers for several months
11:52:53 <mnislaih> lol :O
11:52:54 <sjanssen> emertens: that's only strict on the tuple, not on the elements inside it
11:52:57 <monochrom> then we'll actually read books and write Haskell libraries and tutorials!
11:53:08 <xerox> Now, that's an idea!
11:53:11 <emertens> sjanssen: what do you recommend then?
11:53:54 <monochrom> and, above all, get you people to learn ghci rather than leeching from lambdabot!
11:54:15 <sjanssen> emertens: foldl' (\(a, b) x -> a `seq` b `seq` (x + b, max a b)) (0, 0)
11:54:21 <emertens> I'll run ghci when someone fixes ghci on OpenBSD
11:54:36 <monochrom> oops heehee
11:54:54 <emertens> till then... lambdabot is my bitch ;)
12:07:37 <mcnster> foreign q:  i need to access various fields of a C struct that i have been passed a Ptr CChar to.  is there any easy way of doing this, besides calculating field-byte offsets?  could i create an unboxed type whos fields are ctypes?
12:08:32 <xerox> More or less, you can marshal complex foreign data structure to Haskell-land ones via Storable instances.
12:08:57 <mcnster> ahso
12:09:13 <mcnster> i will reread ffi and see if i can grok this, thanks
12:09:20 <sjanssen> @hoogle bounds
12:09:21 <lambdabot> Array.bounds :: Ix a => Array a b -> (a, a)
12:09:21 <lambdabot> Data.Array.bounds :: Ix i => Array i e -> (i, i)
12:09:21 <lambdabot> Data.Array.IArray.bounds :: (HasBounds a, Ix i) => a i e -> (i, i)
12:09:27 <xerox> There are some tools that ease this, c2hs is a good one, for example.
12:09:41 <xerox> (It also has a nice manual explaining most of the issues/uses.)
12:10:05 <mcnster> odd, i don't remember very much in the way of a manual for c2hs....
12:10:13 <mcnster> just a paper
12:10:22 <xerox> Well, that :)
12:10:28 <mcnster> oh ok :)
12:11:10 <stepcut> mcnster: you can also checkout hsc2hs
12:11:47 <mcnster> stepcut, cool, i will thanks :)
12:31:21 <kosmikus> anyone familiar with ml-style modules around? are functors in ml always first-order?
12:38:01 * xerox <- liftIO (head (random book)) >> sleep
12:38:53 <shapr> @users
12:38:54 <lambdabot> Maximum users seen in #haskell: 228, currently: 225
12:38:58 <shapr> Wow, 228
12:39:13 * kosmikus remembers when we celebrated the 100 ...
12:39:16 * shapr grins
12:39:33 <shapr> I was pretty happy when we broke five....
12:39:43 <kosmikus> :)
12:39:58 <kosmikus> obviously, you're around much longer than I am ...
12:39:59 <shapr> I wasn't convinced #haskell would ever have more than ten people.
12:40:27 <stepcut> shapr: haha
12:40:37 <Pete_I> that's pretty funny
12:40:44 <kosmikus> 38 people when I first joined; just looked it up in the logs ;)
12:40:55 <shapr> Zero people when I first joined :-)
12:41:02 <stepcut> ;p
12:41:35 <shapr> I didn't know about irc.haskell.org then.
12:41:47 <shapr> There was already a #haskell channel on a different server.
12:41:48 <kosmikus> maybe we should compute this number for all persons and call it a person's "channel age"
12:42:10 <shapr> It would be an inverse number?
12:42:14 <kosmikus> yeah
12:42:31 <Pete_I> :/ i'm not sure i like the idea.
12:42:48 <kosmikus> why not?
12:42:51 <mcnster> perhaps all these lurkers are messysoft spies....
12:42:55 <Pete_I> mine wouldn't be that old...
12:43:25 <kosmikus> it will be in a few years (months) when all the new people get numbers around 1000 ...
12:43:28 <mcnster> ... after all, haskell *is* the way of the future (should there be one)
12:43:35 <shapr> I'd rather index people by the amount of stuff they've written that people still use, whether code, research papers or wiki articles.
12:43:53 <kosmikus> shapr: no, that concept has a serious problem
12:43:54 <Pete_I> that sounds more reasonable.
12:43:55 <shapr> hiya sek, learning Haskell?
12:43:57 <shapr> kosmikus: Why so?
12:44:03 <kosmikus> shapr: it'd be actually useful
12:44:06 <shapr> oh I see
12:44:08 <shapr> That's a good point.
12:44:31 <shapr> The belt color index was fun, it was halfway between useless and useful.
12:44:54 <kosmikus> glad you agree
12:45:02 <kosmikus> ah right, the belts
12:45:11 <kosmikus> but I think they were somewhat outdated even when I joined
12:45:21 <shapr> Yeah, they stayed that way.
12:45:58 <shapr> hiya Foxyloxy, learning Pascal?
12:46:13 <shapr> @users
12:46:14 <lambdabot> Maximum users seen in #haskell: 228, currently: 228
12:46:16 <shapr> Neat
12:46:21 <Cale> shapr: haha, you've become a caricature of yourself :)
12:46:33 * shapr grins
12:47:19 <kosmikus> the funny thing about this channel is that it doesn't feel that much different than in the good old times
12:47:26 <kosmikus> I guess that's a positive thing
12:48:11 <jer> kosmikus, it's my experience that channels filled with programmers tend to more often than not top off around a maximum of 300 (or float around it). not because of lack of new individuals, but because of just the amount of noise that's generated with much more
12:48:37 <jer> so #haskell being filled with 1000 users... perhaps; but experience tells me otherwise =]
12:49:01 <shapr> I think the attitude here fits into "steps of the parthenon"
12:49:30 <shapr> Anyone can show up and ask questions and spout nonsense... as long as their goal is to develop their understanding and knowledge.
12:49:35 <kosmikus> jer: you're probably right. but most of the noise is produced by very few users ...
12:49:38 <mcnster> covered with spraypaint?
12:49:43 <shapr> mcnster: point..
12:49:53 <stepcut> jer: we also have  #haskell-blah and #haskell-overflow to try to keep the off topic noise level down
12:49:58 <jer> kosmikus, i realize that =]
12:50:00 <shapr> Speaking of noise and point, have you seen the throwleds?
12:50:06 <jer> stepcut, nod.. those channels, i could see getting bigger
12:50:10 <jer> (than 300)
12:50:21 <kombinator> @users
12:50:22 <lambdabot> Maximum users seen in #haskell: 228, currently: 228
12:50:39 <kosmikus> I've never been on any of those two ...
12:50:52 <kosmikus> how many users do they have usually?
12:51:02 <stepcut> kosmikus: not many
12:51:29 <stepcut> #haskell-blah is for completely off-topic discussions
12:51:34 * do_i_win_somethi ?
12:51:41 <do_i_win_somethi> @users
12:51:42 <lambdabot> Maximum users seen in #haskell: 229, currently: 229
12:51:43 <stepcut> and #haskell-overflow tends to be used when two big conversations are overlapping
12:51:50 <do_i_win_somethi> :-)
12:52:08 <kosmikus> do_i_win_somethi: you win an "ng"
12:52:19 <mcnster> ng?
12:52:20 <shapr> heh
12:52:23 <shapr> mcnster: twins!
12:52:43 <mcnster> (my evil twin is so materialistic...)
12:52:47 <kosmikus> mcnster: for your nick ...
12:53:16 <mcnster> oh "ng" :)
12:56:16 <mcnster> this is the most focused # i have ever encountered.  takes some gettiing used to
12:57:41 <kosmikus> #latex is quite focused too, but is much smaller
12:57:57 <Pete_I> #perl is usually focused.
12:58:02 <Cale> The most focused # I have ever encountered is probably 1, with 1332763 coming in a close second.
12:58:26 * shapr grins
12:58:29 <mcnster> gotta be pi
12:58:30 <sjanssen> I've always preferred the # in I#
12:58:46 <kosmikus> Cale: hmm, I always find 1 pretty unfocused, because it can't decide where to be neutral element in today ...
12:59:20 <Cale> kosmikus: But it takes its job pretty seriously.
12:59:36 <kosmikus> oh yes, no argument there
12:59:51 <kosmikus> sometimes even gets into arguments with 0 about this
13:00:08 <Pete_I> ...talking about numbers like people :/
13:00:12 <Pete_I> you guys are wierd.
13:00:13 <norpan> please people
13:00:53 <Cale> And then they get into a big fight, like 1 throws a + at 0 and maybe 0 throws a * back, or something.
13:01:09 <kosmikus> :)
13:01:17 <Pete_I> 1 will win by throwing a / at 0
13:01:35 <Pete_I> or maybe it'll explode and they both become undef
13:01:38 <norpan> hey, that reminds me of the joke about the deriving operator
13:02:24 <kosmikus> yes, but that's the difference between the two: it doesn't. 1 wants to make the game going for a while, but is surprised that 0 is so destructive ...
13:02:41 <kosmikus> ok, I'll stop now
13:04:52 <shapr> @users
13:04:53 <lambdabot> Maximum users seen in #haskell: 230, currently: 230
13:04:55 <shapr> neat
13:14:29 <Pete_I> @users
13:14:29 <lambdabot> Maximum users seen in #haskell: 232, currently: 232
13:15:07 <Pete_I> channel seems quite inactive for having so many people
13:15:21 <SamB> everyone is idling or hacking?
13:15:28 <Pete_I> likely.
13:15:29 <shapr> I'm just being sick.
13:15:31 <SamB> no time for yacking when you are busy hacking
13:15:37 <shapr> I caught something in the UK.
13:16:48 <Pete_I> it wasn't humanoid was it?
13:16:58 <Pete_I> there might be issues with customs if it was.
13:17:02 <CosmicRay> shapr: ugh
13:17:08 * SamB makes a stupid joke about fishing
13:21:11 <bobwhoops> Some people are at work
13:29:35 <eivuokko> Anyone here knows how to get ghc testsuite running in Windows (msys/mingw)?
13:30:09 <eivuokko> I could use some help :-)
13:34:47 <Heffalump> hmm, anyone know of an easy way to make Template Haskell pretty printing not qualify names that are in scope (perhaps just those from the Prelude)
13:34:50 <Heffalump> ?
13:38:04 <Igloo> I don't think you can without hacking the source
13:39:33 <SamB> you would need to be able to pass the scope to the pretty printer...
13:46:11 <tibbe> @hoogle IO a -> IO a -> IO a
13:46:12 <lambdabot> Control.Exception.finally :: IO a -> IO b -> IO a
13:46:12 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
13:46:12 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
13:46:13 <vincenz> Igloo: nice beard ;)
13:46:25 <vincenz> Heffalump: you a TH expert?
13:49:05 <Heffalump> vincenz: if only.
13:49:12 <vincenz> :/
13:49:30 <vincenz> I was hoping that maybe I could rebuild minikanren in haskell and use TH to automatically generate a unifier over a type with holes for variables
13:52:15 <tibbe> @hoogle listenOn
13:52:16 <lambdabot> Network.listenOn :: PortID -> IO Socket
13:52:33 <tibbe> why doesn't listenOn accept the literal 3000 as PortID?
13:53:01 <tibbe> n/m
13:53:13 <Heffalump> ooh. /me figures out Control.Monad.Writer(T)
13:56:40 <emertens> is listArray lazy?
13:56:57 <emertens> as in... can i use the resulting array while generating
13:57:01 <emertens> the array
13:57:07 <emertens> (to memoize a function)
13:57:25 <SamB> depends on the type of the array
13:59:15 <emertens> is there a version of (!) that doesn't return the index as well as the array?
13:59:22 <emertens> like: snd . (!)
13:59:33 <Cale> what?
13:59:40 <sjanssen> @type (Data.Array.!)
13:59:41 <lambdabot> forall e i. (Ix i) => Array i e -> i -> e
13:59:54 <emertens> oh, I'm misusing listArray then :)
13:59:55 <Cale> It doesn't return the index
13:59:56 <emertens> i just want array
13:59:59 <Cale> yes
14:00:47 <Cale> listArray just lets you skip explicitly specifying the indices when the elements in the list are in the order you want them in the array
14:00:58 <emertens> sweet, it worked
14:01:33 <emertens> but it might not be memoizing like I'd hoped...
14:02:02 <emertens> @paste
14:02:02 <lambdabot> http://paste.lisp.org/new/haskell
14:02:16 <Cale> Working on the crossword puzzle solver?
14:02:21 <emertens> no :)
14:02:39 <lisppaste2> emertens pasted "Dynamic Programming with array" at http://paste.lisp.org/display/23888
14:02:43 <Cale> I was thinking about writing a solver for those puzzles that have a specific list of words to be used.
14:02:50 <Cale> (and a framework)
14:03:01 <emertens> the first version of that function just uses simple recursion, no memoization, and works fine for small values
14:03:10 <emertens> the second is my attempt to use array to memoize for me
14:03:17 <Heffalump> hmm, anyone experienced with Scrap Your Boilerplate coding?
14:03:18 <emertens> am I doing something obviously wrong?
14:03:28 <DukeDave> tally ho all :)
14:03:49 <sjanssen> emertens: looks correct to me
14:04:13 <Cale> emertens: Looks okay to me
14:04:30 <sjanssen> emertens: you may be interested in this post: http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737/match=memo
14:04:30 <emertens> :-/ then why doesn't it run in a reasonable amount of time
14:04:32 <lambdabot> Title: Gmane -- Mail To News And Back Again
14:04:49 <Cale> emertens: Of course, you'll only get memoisation within a specific call to badRoads'
14:04:55 <DukeDave> what is the cleanest way to express something like:     dropWhile (Nothings) [Maybe]   ?
14:05:08 <emertens> sjanssen: I'll give that a shot
14:05:11 <DukeDave> (I'm using my own data type)
14:05:21 <Cale> DukeDave: dropWhile isNothing ?
14:05:22 <shapr> @users
14:05:23 <lambdabot> Maximum users seen in #haskell: 235, currently: 230
14:05:25 <Heffalump> make a boolean query
14:05:29 <sjanssen> DukeDave: or a list comprehension
14:05:40 <Heffalump> a list comprehension can't express dropWhile
14:05:46 <sjanssen> [Just x | Just x <- myList]
14:05:51 <Heffalump> that's filter
14:05:53 <Heffalump> not dropWhile
14:05:58 <sjanssen> Heffalump: you're right, of course
14:06:04 <SamB> dropWhile (==Nothing)?
14:06:16 <Heffalump> SamB: that introduces a needless Eq constraint
14:06:30 <SamB> true
14:06:32 <Cale> hehe, I was going to say that, but you're too fast :)
14:06:39 <SamB> dropWhile isNothing then
14:06:50 <DukeDave> need a test   data -> Bool
14:06:54 <Cale> similarly, one should use null in place of (== [])
14:07:03 <DukeDave> where we can test for any constructor
14:07:21 <SamB> you just have to write each one out
14:07:25 <SamB> two lines a piece
14:07:28 <Heffalump> DukeDave: as it happens the Data class from Scrap Your Boilerplate (Data.Generics) supports this
14:07:34 <Cale> DukeDave: it's been suggested that such a feature would be useful
14:07:37 <SamB> well, or you could use that...
14:07:52 <Cale> something like (@ Nothing)
14:08:02 <Heffalump> but it's a bit heavyweight
14:08:02 <Cale> as a function Maybe a -> Bool
14:08:12 <Cale> but it's not implemented
14:08:30 <DukeDave> erk
14:08:44 <DukeDave> so, suggestions on a clean way to perform such a task
14:08:51 <SamB> would (@ Just) work too?
14:08:54 <Cale> DukeDave: write a conditional function :)
14:09:03 <Cale> SamB: (@ Just _)
14:09:13 <SamB> Cale: oh
14:09:24 <SamB> could you just write (@Just{})?
14:09:28 <Cale> sure
14:09:39 <Cale> It would be (@ <pat>) where pat was a pattern
14:09:42 <SamB> using GHC's extension of that notation
14:09:44 <DukeDave> > dropWhile (@ Just _)  [Just 1, Just 2, Nothing]
14:09:45 <lambdabot>  Parse error
14:09:54 <Heffalump> @type Data.Generics.toConstr
14:09:56 <lambdabot> forall a. (Data.Generics.Basics.Data a) => a -> Data.Generics.Basics.Constr
14:10:05 <Cale> DukeDave: We're in subjunctive land again, ignore us :)
14:10:12 <DukeDave> this all seems very heavy
14:10:37 <emertens> omg, i thnk that my solution was working, but I hadn't switched the large values test to use it
14:10:37 <Cale> DukeDave: Just write a function using case which does the test
14:10:37 * DukeDave puts his 'idle while professionals talk' hat on  :)
14:11:03 <Cale> > dropWhile (\x -> case x of Just _ -> True; _ -> False)  [Just 1, Just 2, Nothing]
14:11:04 <lambdabot>  [Nothing]
14:11:06 <emertens> but this dp code is better for generalizing the process
14:11:22 <Heffalump> @type (== Data.Generics.ConIndex 3) . Data.Generics.constrIndex . Data.Generics.toConstr
14:11:22 <SamB> > let isJust (Just{}) = True; isJust _ = False in dropWhile isJust [Just 1, Just 2, Nothing]
14:11:24 <lambdabot> Not in scope: data constructor `Data.Generics.ConIndex'
14:11:24 <lambdabot>  [Nothing]
14:11:34 <Heffalump> @type (== 3) . Data.Generics.constrIndex . Data.Generics.toConstr
14:11:35 <lambdabot> forall a. (Data.Generics.Basics.Data a) => a -> Bool
14:11:55 <Cale> > dropWhile isJust [Just 1, Just 2, Nothing]
14:11:56 <lambdabot>  [Nothing]
14:12:03 <Heffalump> that's a function that returns True if the value is from the third constructor (in textual order of the declaration) of its type.
14:12:04 <Cale> of course, isJust already exists :)
14:12:13 <DukeDave> cheers! :)
14:12:18 <Cale> Heffalump: for instances of Data?
14:12:23 <Heffalump> Cale: right.
14:12:27 <DukeDave> are we agreed that's the sanest way to do it then?
14:12:28 <Heffalump> as you can see from the type :-)
14:12:36 <DukeDave> just seems very un-haskell
14:12:40 <Heffalump> DukeDave: which?
14:12:51 <Heffalump> I wouldn't suggest using my code unless you are really keen to save extra function declarations.
14:12:51 <SamB> Cale: yes, but we are illustrating strategies for general use, not the helper functions in the library for specific types
14:12:59 <Cale> DukeDave: the sanest way to do it is to write an equivalent of 'isJust' for your type
14:13:14 <DukeDave> okay :)
14:13:15 <Cale> SamB: right :)
14:13:18 <DukeDave> thanks again!
14:13:40 <SamB> of course, you don't really use a let/in for that
14:13:58 <Heffalump> I think there's a trick you can use to make the function look like (isConstr Foo)
14:14:02 <emertens> That dp generalization post that you linked me to is a wonderful example of what makes higher order functions amazing
14:14:03 <Cale> It'd be really cool for someone who knows GHC to implement that pattern-matching function syntax
14:14:26 <sjanssen> emertens: yeah, that example is sexy
14:14:26 <Cale> then it could possibly be considered for Haskell', or Haskell''
14:14:44 <emertens> sjanssen: and it's why Haskell isn't a supported language on topcoder.com
14:14:46 <emertens> ;)
14:14:50 <emertens> just wouldn't be fair
14:15:25 <sjanssen> emertens: there's at least one programming site that accepts Haskell solutions.  http://www.spoj.pl
14:15:28 <lambdabot> Title: Sphere Online Judge (SPOJ)
14:15:40 <roconnor> emertens: I have a secret plan to get a c interpreter for haskell byte code, and use that.
14:15:44 <Cale> spoj has ridiculous constraints on most of its problems though
14:15:49 <roconnor> then write the haskell in comments.
14:16:04 <sjanssen> Cale: you mean time constraints?
14:16:28 <Cale> sjanssen: yeah, they'll be more doable with ByteString
14:17:01 <Cale> I found it really hard to get [Char] IO to be fast enough to emit solutions in time for a bunch of the problems, and gave up :)
14:18:12 <Cale> but that was a long time ago, maybe they're more reasonable now, I don't know
14:18:43 <sjanssen> you still run into that on occasion
14:19:00 <emertens> I've only done one topcoder competition
14:19:08 <emertens> the rest of the time I just use their problem archive
14:21:23 <emertens> out of curiousity , can you think of a nicer way to do this:
14:21:24 <emertens> badRoads' rs x y = vals ! (x,y) where rs' = parseRoads rs
14:21:24 <emertens>  bad a b = (a,b) `elem` rs' || (b,a) `elem` rs'
14:21:24 <emertens>  vals = array  ((-1,-1),(x,y)) [((a,b), val a b) | a <- [-1..x], b<-[-1..y]]
14:21:24 <emertens>  val :: Int -> Int -> Int
14:21:26 <emertens>  val 0 0 = 1
14:21:29 <emertens>  val (-1) _ = 0
14:21:31 <emertens>  val _ (-1) = 0
14:21:34 <emertens>  val x y = (if (bad (x,y) (x-1,y)) then 0 else (vals ! (x - 1, y)))
14:21:36 <emertens>          + (if (bad (x,y) (x,y-1)) then 0 else (vals ! (x, y - 1)))
14:21:39 <emertens> err
14:21:42 <emertens> sorry
14:21:44 <emertens>   | otherwise          = (if (bad (x,y) (x-1,y)) then 0 else (rec (x - 1, y)))
14:21:47 <emertens>                        + (if (bad (x,y) (x,y-1)) then 0 else (rec (x, y - 1)))
14:22:14 <sjanssen> emertens: how long is rs', usually?
14:22:45 <emertens> I didn't represent it as a Data.Set.Set because I didn't want to have to use qualified functions :)
14:22:59 <emertens> but in this case it's 0 to 50 elements
14:23:00 <sjanssen> doing all those elem operations might become expensive
14:23:29 <sjanssen> you could also use an Array (Int, Int) Bool instead of a list
14:23:38 <emertens> very true
14:23:54 <sjanssen> that is asymptotically best
14:24:08 <emertens> constant time lookups are the best I can think of
14:25:01 <emertens> @type newArray
14:25:03 <lambdabot> Not in scope: `newArray'
14:25:08 <emertens> @type array
14:25:10 <lambdabot> forall e i. (Ix i) => (i, i) -> [(i, e)] -> Array i e
14:25:13 <emertens> (looking for the one with a default
14:25:20 <emertens> actually, nevermind
14:25:52 <sjanssen> @type accumArray
14:25:53 <lambdabot> forall e i a. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
14:26:17 <sjanssen> @type accumArray (flip const)
14:26:19 <lambdabot> forall a i. (Ix i) => a -> (i, i) -> [(i, a)] -> Array i a
14:26:26 <emertens> this will be rather ugly because elements of this array will have the index type of ((Int,Int),(Int,Int))
14:27:00 <emertens> actually
14:27:08 <emertens> since the coordinates are always adjacent
14:27:12 <emertens> two arrays would be better
14:33:27 <PaulAJ> Hi.  Thought I'd drop in briefly, before going to bed.
14:33:51 <Philippa_> 'lo
14:34:22 <PaulAJ> I've finally got my raw monad version of SimT to typecheck.
14:34:31 <Philippa_> cool
14:34:56 <PaulAJ> Mostly I cribbed it from ContT.  Now I've got to find out if it works.
14:35:06 <Heffalump> bah. I want the class constraint solver to backtrack.
14:35:11 <Philippa_> heh
14:35:18 <Philippa_> to both, in fact :-)
14:36:21 <PaulAJ> Its actually a funny feeling: looking at a piece of code with several dozen lines and having a fair degree of confidence that it will work first time.
14:36:31 <Heffalump> does it typecheck
14:36:41 <PaulAJ> Yes (at last)
14:37:25 <PaulAJ> And it follows ContT quite closely too.  Which is good because I still don't fully understand ContT.
14:38:31 <PaulAJ> There is a comment in the Haskell humour file about ContT requiring just "20,000 IQ hours" to invent.  I have spent quite a few hours staring at ContT and Cont, and I do feel that inverse proportional relationship.
14:39:12 <SamB> so does this time include downtime?
14:39:36 <PaulAJ> Hmmm.  It involves some background computation whilst driving to and from work.
14:40:15 <SamB> I meant the figure of 20,000 IQ hours for ContT
14:40:21 <PaulAJ> Sec.
14:40:24 <SamB> and ContT isn't even done right yet!
14:43:50 <PaulAJ> Back.
14:44:42 <PaulAJ> I don't know about the 20,000 IQ hours.  I do want to understand delimited continuations though.  But I need to understand the plain sort first.  I'm almost there.
14:45:06 <Pegazus> hi, does anyone remember by chance how was it the demostration that AA with A <- {a, b}* wasn't a context-free language?
14:47:57 <emertens> hurry for monads! :-D legal (x,y) = and ([(>=0),(<size)] `ap` [x,y])
14:48:12 <PaulAJ> I don't know about the specific demonstration.  Do I understand that an "A" could be any sequence of a or b?
14:48:27 <Pegazus> yes
14:48:35 <Pegazus> the idea is that you can't recognize id id
14:48:47 <Pegazus> not even id SEPARATOR id
14:48:59 <PaulAJ> Well AA is obviously ambiguous because given aaabbbababb you can't tell where one A ends and the next begins.
14:49:13 * dcoutts is amused by xerox and Lemmih describing code as evil
14:49:15 <Pegazus> a context free grammar can be ambigous :)
14:49:36 <Pegazus> my example is a simplification of that problem, with a language consisting only of as and bs...
14:50:07 <PaulAJ> I don't see why you can't recognise id SEPARATOR id
14:50:21 <Pegazus> id is any string of the language
14:50:37 <Pegazus> id = {a, b}* then recognize id SEPARATOR id
14:50:48 <PaulAJ> Well if id can include SEPARATOR then I see how the problems are the same.
14:51:10 <Pegazus> it can't
14:51:17 <Pegazus> id = {a, b}* then recognize idcid
14:51:21 <Pegazus> do you like it now? :)
14:51:30 <Pegazus> id isn't a terminal, it is a string
14:52:15 <PaulAJ> So "c" is the separator?  I don't see a problem.  But I'm not a parsing guru.
14:52:53 <Pegazus> it's not a context-free language
14:52:56 <Pegazus> you can parse it
14:53:03 <Pegazus> but it's not a context-free language
14:53:29 <PaulAJ> Maybe its related to the "*".  Presumably there are an infinite number of possible parses which include empty ids.
14:53:46 <Pegazus> ?
14:53:49 <Pegazus> well
14:53:54 <Pegazus> id = {a, b}+ then recognize idcid
14:53:55 <Pegazus> now?
14:54:26 <PaulAJ> That looks like there will be only one parse.  But of course it can't parse cababa
14:55:05 <Pegazus> do you know what i'm talkign about?
14:55:06 * PaulAJ pulls down his old copy of the DRagon Book
14:55:50 <monochrom> Haha the mythical IQ-hour.
14:56:12 <monochrom> w00t!  So it's the IQ-month, not the man-month, that matters!
14:59:58 <PaulAJ> Found it.  Example 4.11 in the dragon book.
15:01:37 <PaulAJ> L1 = wcw where w is in (a|b)*.  However "it is beyond the scope of this book to prove" that this is not context free.
15:02:23 <PaulAJ> Ahh.  Got it.  So it has to be the *same* string.  Bang! the light goes on.
15:11:36 * edwardk_ walks in in the middle of a pumping lemma question he thinks.
15:11:49 * basti_ thought so too
15:12:06 * basti_ just couldnt remember pumping lemma enough
15:14:57 <edwardk_> For any cfg C there exists a K depending on C such that for any string generated by G with length greater than K, the string can be written uvxyz, in such a manner than |vy| >= 1 and u(v^n)x(y^n)z is in the language generated by G for all n >=0.
15:15:23 <basti_> yea thats the part where i stop thinking
15:15:24 <basti_> ^^
15:15:26 <edwardk_> basically the pumping lemma for cfgs is like the one for regular languages, but you have to pump two places.
15:15:35 <basti_> yes
15:15:46 <basti_> it's not that i found the regular one really intuitive either
15:15:52 <basti_> i mean, i can grasp what it does
15:16:07 <basti_> but i never saw every piece at once
15:16:45 <edwardk_> so in that case, start with the grammar wcw, get k, because it exists, then choose the string a^kca^k. then the pumping lemma says that you can inflate the left hand side and remain in the grammar.
15:16:56 <kosmikus> basti_: it's not that difficult. if you have something that's representable by an automaton with n states, then you can't process something longer than n without having a loop. then you can also pass the loop multiple times ...
15:17:01 <edwardk_> which violates the grammar being context free
15:17:08 <basti_> yes i know the idea.
15:17:32 <basti_> but, somehow i never managed to be aware of all the stuff at once
15:17:48 <edwardk_> er rather that violates the grammar wcw being context-free.
15:19:36 <edwardk_> i always rather liked automaton stuff
15:22:34 <edwardk_> (if it makes you feel better i only remembered the cfg pumping lemma because of i've been playing with ordered lambda calculi in my substructural logic binge, which can only generate a subset of cfg grammars, etc)
15:22:51 <edwardk_> er rather a subset of context-free languages
15:24:48 <basti_> I'll go to sleep. But I'll come back these days. I think I'm with you guys again now.
15:25:14 <shapr> Where were you before?
15:25:17 * edwardk_ is bored.
15:25:31 <basti_> I don't really know
15:25:36 <basti_> suppose i was a little depressed
15:25:58 <shapr> I can understand that.
15:26:09 <kosmikus> edwardk_: don't you need some additional condition on |vxy| or something like that?
15:26:11 <shapr> IRC is still a bit lonely. In person discussion is best.
15:26:22 <basti_> i wasn't depressed about IRC.
15:26:27 <basti_> ^^
15:26:41 <shapr> I just mean that as much as I enjoy text chat, hanging out with people in person is better.
15:26:50 <musasabi> true
15:26:50 * Heffalump is confused.
15:26:59 <edwardk_> |vy|>=0 => |vxy|>=0 =)
15:27:16 <musasabi> But itc is nice for meeting people and organizing rl meetings
15:27:22 <musasabi> *irc
15:27:30 <shapr> yeah
15:27:57 <Cale> Hmm, here's a question. Suppose that M is a monoid. Find (useful) necessary and sufficient conditions on M which guarantee that M is the syntactic monoid of a context-free language.
15:28:08 <edwardk_> with the pumping lemma for cfgs its just that v or y is pumpable.
15:28:20 <basti_> syntactic monoid.
15:28:21 <basti_> woah
15:28:37 <emertens> While in person conversations are better, I would lose my job if I had in person conversations about haskell all day long :)
15:28:46 <edwardk_> cale and monoids again =)
15:28:58 * basti_ will now go search his mattrestic monoid
15:29:08 <emertens> that would be very bad
15:29:10 <kosmikus> no, more like that the middle part is not too long ...
15:29:11 <emertens> monoids are one way
15:29:15 <emertens> you'd never get out of your bed...
15:29:36 <edwardk_> hrmm
15:29:36 <basti_> o.o
15:29:37 * kosmikus kosmikus consults google
15:29:38 <edwardk_> lemme go check online
15:29:39 <basti_> whatever.
15:29:40 <basti_> ;)
15:30:08 <Cale> edwardk_: See, I really like the definition of regular languages as the preimages of subsets of finite monoids under a homomorphism from the free monoid on your alphabet.
15:30:33 <edwardk_> yeah you used that line already =)
15:30:43 <Cale> yeah, probably mentioned it before :)
15:30:51 <edwardk_> i grasp it somewhat in the abstract, but i haven't internalized it
15:31:02 <edwardk_> its like your endofunctor on the category of types line =)
15:31:18 <edwardk_> though, that one i am comfortable with
15:31:36 <emertens> because you are mapping from haskell's type system, to haskell's type system
15:32:40 * araujo sees other recommedation to use Haskell as the language for OS design 
15:32:41 <edwardk_> that much isn't a problem. its just that they are a restricted class of endofunctors on that category, so while the statement is factual it doesn't appear to be complete.
15:34:15 <edwardk_> If L is  context-free language with infinitely many strings then there must be a string in L of the for svuwt where s,v,u,w,t are substrings at least one of v and w is non empty and sv^nuw^nt is in L for each n in N+.
15:34:23 <Cale> It's a little tough to say exactly which class they are though, especially as the answer will change drastically with small changes to the type system.
15:34:43 <edwardk_> there are like 3-4 definitions basically in accord with my earlier statement without size cap restrictions on the center.
15:35:12 <edwardk_> just that at least one of the pumpable pieces isn't empty, so you have something to pump =)
15:35:59 <edwardk_> yeah
15:38:24 <edwardk_> at present it seems that the addition of some outer layer gives you a nice predicative tower of classes, so it might be possible to use that to give a better definition.
15:39:08 <Cale> A theory of syntactic monoids for context-free languages, in Information Processing 77, Proc. of IFIP Congress 77, North Holland, 1977.
15:39:10 <Cale> hmm
15:39:39 <edwardk_> makes me think of russell style classes
15:40:07 <edwardk_> which of course motivated type theory, so its to be expected =)
15:44:16 <kosmikus> edwardk_: sure, the lemma holds without the size restriction. I think you get the size restriction relatively easily though from the proof. I'm not sure if it's actually stronger then, or if both versions are equivalent.
15:44:43 <edwardk_> i don't know the size restriction in question
15:44:48 <PaulAJ> I'm trying to define a class for both STRef and IORef.
15:44:52 <PaulAJ> class (Monad m) => MemRef ref m | ref -> m where
15:44:52 <PaulAJ>    newMemRef :: a -> m (ref a)
15:44:52 <PaulAJ>    
15:45:00 <edwardk_> i recall one vaguely on regular langs
15:45:02 <PaulAJ> Does that look like the right sort of thing?
15:45:09 <edwardk_> but not context-free
15:45:09 <kosmikus> edwardk_: the Wikipedia version has it, for instance.
15:45:15 * edwardk_ goes to check
15:45:35 <PaulAJ> I think I need functional dependencies, but they are not well documented yet.
15:45:35 <edwardk_> pumping lemma page?
15:45:39 <Cale> btw, if anyone can get that paper online, I'd like to read it :)
15:46:04 <kosmikus> http://en.wikipedia.org/wiki/Pumping_lemma_for_context-free_languages
15:46:35 <edwardk_> interesting
15:47:17 <edwardk_> i think you get the size cap on x from the same process that gives you v and y
15:47:27 <edwardk_> coz its from the reduction to chomsky normal form, right
15:47:29 <edwardk_> ?
15:48:10 <PaulAJ> Bye,
15:49:57 <edwardk_> might be that you can catch some case inwhich the center grows with the extended version
15:50:04 <edwardk_> yeah
15:50:17 <edwardk_> you're right
15:51:13 <kosmikus> ogden's lemma is supposed to be yet stronger, according to wikipedia, and although I remember the name somehow, I'm quite certain I never needed it ...
15:51:55 <edwardk_> yeah, I've never had to appeal to it either.
15:52:39 <kosmikus> ok, night
15:52:42 <edwardk_> heh, i have two books here, one has the |vxy| condition, the other doesn't
15:53:07 <edwardk_> don't believe everything you read =)
15:53:47 <Cale> Is there a nice example of a language which is not context-free and which Ogden's lemma catches but the pumping lemma doesn't?
15:53:53 <kosmikus> why? it's both correct in this case.
15:54:06 <kosmikus> anyway, I'm really away now ...
15:54:14 <edwardk_> thats true, both lemmas work, just the one is a fair bit stronger.
15:55:14 <Cale> Hmm... Ogden, W. (1968). "A helpful result for proving inherent ambiguity". Mathematical Systems Theory 2: 191-194.
15:55:30 <Cale> That's given as a reference for Ogden's lemma
15:56:56 <Cale> Is Ogden's lemma a sufficient condition for a language to be context-free?
15:57:50 <Cale> that is, is the converse true?
15:58:38 <edwardk_> i seem to recall the answer being no otherwise in true mathematical fashion they would be stating it as such coz mathematicians love symmetry =)
15:58:52 <Cale> hmm http://portal.acm.org/ft_gateway.cfm?id=319073&type=pdf&coll=GUIDE&dl=GUIDE&CFID=15151515&CFTOKEN=6184618
15:59:18 <Cale> Well, that, or it's unknown :)
15:59:28 <edwardk_> yeah
15:59:54 <Cale> Okay, this paper is actually showing that the converse fails.
16:00:00 <edwardk_> i recall the pumping lemma converse not holding, ogden's i am less familiar with, but you just gave a nice paper that said no =)
16:00:19 <Cale> Both for regular languages and Ogden's lemma for CFGs.
16:00:34 <edwardk_> unless you limit yourself to a single symbol.
16:01:27 <Cale> hmm, Parikh's theorem looks interesting
16:03:04 <Cale> I wonder what conditions have been found that *are* equivalent to being a CFL.
16:03:38 <edwardk_> equivalence i dunno in this case
16:04:48 <Cale> That is, for which conditions P can we prove that "L is a context-free language if and only if P(L)"
16:05:18 <jgrimes> is it generally a good idea to take care of as many error cases as possibly in a parser? (such as number of arguments for primitives)
16:05:21 <Cale> There's the pushdown automata thing.
16:05:30 <edwardk_> yeah
16:06:12 <edwardk_> and you can show that that every language the lambek calculus can generate is context-free, but i don't know if the converse holds there.
16:06:24 <edwardk_> i admit to not thinking it out
16:11:44 <Heffalump> do the GHC libraries define a MaybeT?
16:12:29 <edwardk_> can't find one
16:12:31 <edwardk_> http://www.cs.vu.nl/Strafunski/documentation/MonadMaybe.html
16:12:46 <Heffalump> yeah, I found that with google
16:13:04 <Heffalump> I was justchecking that my negative result for the GHC libs was correct
16:14:05 <edwardk_> pugs bothers to define it itself as well
16:14:06 <Cale> Once a paper is cited enough times, it should be made available on the web :)
16:14:09 <edwardk_> so likely you are right
16:14:12 <edwardk_> heh
16:14:19 <edwardk_> and whenever it gets over 20 years old
16:14:39 <Cale> J. Lambek, The mathematics of sentence structure, Amer. Math. Monthly 65 (1958), no. 3, 154–170.
16:14:48 * edwardk_ hates driving over to u.mich to get papers all the time.
16:14:52 <edwardk_> heh
16:14:58 <edwardk_> the lambek calculus stuff? =)
16:15:01 <Cale> yeah
16:15:13 <Cale> Do you have a good online reference?
16:15:15 <edwardk_> there are lots of references if you don't mind not going back to source material
16:15:40 <Cale> http://lpcs.math.msu.su/~pentus/abstr.htm#Pentus93LICS is decent, but none of them seem to bother defining the Lambek calculus in the first place.
16:15:43 <lambdabot> Title: Lambek calculus papers by Mati Pentus
16:15:48 <edwardk_> but you can also get there by taking a substrucutral lambda calculus without exchange weakening or contraction.
16:16:20 <edwardk_> leaving the fact that you can only treat your Gamma with a stack discipline
16:16:27 <edwardk_> the rest of the properties follow pretty quickly
16:16:46 <edwardk_> yeah thats one of the biggest resources on the web.
16:17:41 <edwardk_> lemme know what you find. i've been obsessing about this substructural stuff and its the least structure i can give and still have something resembling a lambda calculus
16:17:47 <edwardk_> and has the potential to do something useful
16:18:00 <edwardk_> i think attapl mentions the idea as ordered types in the first paper in it
16:18:09 <edwardk_> but it doesn't make the lambek connection
16:18:33 <edwardk_> the major use is since they have to be set up and torn down in stack order, you might as well use a stack. =)
16:18:44 <edwardk_> so you can use linear types as heap allocatable knowing they'll be freed.
16:18:46 <edwardk_> ordered for a stack
16:18:56 <edwardk_> relevant allows strict evaluation
16:19:07 <edwardk_> affine allows you to know you can throw it away when you are done to aid gc
16:19:14 <edwardk_> and then you have the classical unrestricted types
16:19:43 <edwardk_> all together it forms a fairly elegant model, at least if i can wrap something resembling a pure type system around it to avoid something that looks like refURAL =(
16:20:41 <edwardk_> mix in a linear region allocator, and you get a calculus for an intermediate language that has lots of nice memory reclamation properties
16:21:26 <edwardk_> but is way too complicated without getting some sort of PTS benefits to prune the case count.
16:22:25 <edwardk_> oh and you get properties with affine and linear types capping you at polynomial time if they are all you use, so you could freely let the end user run amok with them at compile time without risking decidable type inference/checking, etc.
16:23:44 <edwardk_> i've been digging further and further back in pure type system papers because to mix the two requires you to change the rule set at a fairly basic level to get rid of contraction.
16:24:04 <edwardk_> and then reintroduce it in a more limited context.
16:24:23 <Cale> hmm, I'm not sure I'm familiar enough with the area to understand all of what you're saying, but it sounds interesting enough. :)
16:24:50 <Cale> I have to go to dinner :)
16:24:54 <edwardk_> mostly want to play with mixing two ways to extend the lambda calculus to see if they can mix well enough to form a better intermediate language.
16:24:57 <edwardk_> yeah
16:24:58 <edwardk_> likewise
16:25:00 <edwardk_> later cale.
16:29:51 <jgrimes> is there no kleene star in happy?
16:31:08 <heatsink> jgrimes: There isn't. You can use recursion.
16:31:54 <jgrimes> heatsink, ok
16:48:04 <SyntaxNinja> can anyone explain getLock and setLock in System.Posix.IO? I expected one of them to be for checking if a lock exists, but why would getLock take a FileLock?
16:48:53 <SyntaxNinja> oh, I think I get it, I need to tell it what kind of lock I'm expecting and what region
16:49:24 <vincenz> ping!
16:50:25 <heatsink> um... pong?
16:50:43 <vincenz> :)
16:50:49 <vincenz> thoughts on
16:50:50 <vincenz> http://homes.esat.kuleuven.be/~cpoucet/blog/index.html
16:50:52 <lambdabot> Title: Compilers, Programming Languages and Other Stuff
16:52:22 <LordBrain> hi
16:52:42 <SyntaxNinja> so if I setLock and then getLock right away, will it always return Nothing in this process? do I have to start another process to see if this lock is working?
16:57:08 <heatsink> SyntaxNinja, I think posix locks are uniformly visible across processes
16:58:59 <vincenz> so..thoughts on the layout?
16:59:29 <SyntaxNinja> heatsink: any idea why I'd be getting 'Nothing' with this sequence:
16:59:42 <SyntaxNinja>   setLock fd (WriteLock, AbsoluteSeek, 0, 1)
16:59:43 <SyntaxNinja>   m <- getLock fd (WriteLock, AbsoluteSeek, 0, 1)
16:59:43 <SyntaxNinja>   print $ isJust m
17:02:02 <svref> I don't understand why this isn't working: data Point x y = Point x y deriving (Shows)
17:02:11 <SyntaxNinja> deriving Show
17:02:29 <heatsink> svref: It's not guaranteed that x and y derive Show.
17:02:44 <svref> SyntaxNinja: aha
17:02:55 <heatsink> vincenz: It would be nice if the left margin were the same everywhere...
17:03:53 <SyntaxNinja> if I use forkIO, then it is Nothing, if I use forkProcess, then it is Just.
17:04:08 <svref> "data Point x y = Point x y" this parametric polymorphism is great, but I know x and y are going to be float in practice.  Is it useful to tell Haskell that now?
17:04:10 <heatsink> vincenz: I like the top and bottom bars, but they don't resize with the window.
17:05:13 <heatsink> SyntaxNinja, I'm looking at the manpages for fcntl.  The lock functions seem to be an interface to F_GETLK, F_SETLK, and F_GETLKW, respectively.
17:06:10 <vincenz> heatsink: ?
17:06:18 <heatsink> svref: It's probably useful to just go with float float.
17:06:26 <vincenz> heatsink: sure they do
17:06:52 <svref> heatsink: I can't figure out how to write that... (I'm new!)
17:07:01 <SyntaxNinja> heatsink: what's your name irl?
17:07:10 <LordBrain> data Point = Point Float Float
17:07:35 <heatsink> svref: A good way to figure out how general you want your type to be is to decide what "makes sense" for the type variables.
17:08:10 <heatsink> svref: For example, does Point String (Maybe Int) make sense?  How about Point Int Double?
17:08:17 <LordBrain> the Point on the left side is a type constructor, on the right is a data constructor, they are two different things but they are in different namespaces so you can reuse the name if you like.
17:08:26 <heatsink> vincenz: It resizes horizontally, but not vertically.
17:08:51 <vincenz> ah
17:08:51 <vincenz> hmm
17:08:53 <vincenz> thx
17:08:57 <vincenz> the layout is from dons' site :)
17:09:03 <vincenz> was more asking about colorscheme
17:09:03 <heatsink> heh.
17:10:12 <br1> Hi.  Does someone know PolyP here?  If so, can you explain me why doesn't the class FunctorOf has the f -> d dependency?
17:10:26 <heatsink> vincenz, I like the color scheme a lot, but: The boundaries of the background image are distracting, and there's not enough contrastbetween text and background.
17:11:17 <br1> Don't listen to me, it's explained in a paper.  Sorry about the noise.
17:16:49 <lisppaste2> syntaxfree pasted "simple IO doubt" at http://paste.lisp.org/display/23896
17:17:54 <syntaxfree> did my paste get through?
17:17:59 <stepcut> yes
17:18:11 <syntaxfree> okay! :)
17:18:13 <br1> syntaxfree: The paste isn't properly indented.  Is the original code?
17:18:28 <stepcut> br1: doubt it, look at the error
17:18:32 <syntaxfree> Well, I sure hope so.
17:18:45 <syntaxfree> I wonder if paste.lisp.org screws up indenting.
17:18:55 <stepcut> syntaxfree: tabs perhaps ?
17:19:23 <syntaxfree> can I leave "do" as the end of one line and begin the do block in the next line?
17:19:44 <emertens> yeah
17:20:48 <syntaxfree> One more thing; when using getArgs, if I invoke the program without command-line arguments, I get
17:20:55 <syntaxfree> hcat: Prelude.head: empty list
17:21:21 <musasabi> dcoutts: ping
17:21:30 <dcoutts> musasabi, pong
17:22:27 <br1> stepcut: I fixed the indentation and the error changed.
17:22:50 <vincenz> heatsink: thx
17:23:07 <musasabi> dcoutts: why are programs in Cabal configure expressed like WithHappy and not With "happy" ?
17:23:33 <musasabi> Seems like the current way just adds more code (and lacks extensiblity) without any reason
17:23:46 <dcoutts> musasabi, I don't quite follow, you mean the configure command line syntax or in the code itself?
17:23:55 <dcoutts> ah ok, in the code
17:23:56 <musasabi> code itself
17:24:29 <dcoutts> musasabi, feel free to implement a more generic with 'program' adt
17:24:48 <dcoutts> musasabi, actually there is already some concept in the code of a support program
17:25:08 <musasabi> ok
17:25:21 <musasabi> But first I will try to hack the configurations support.
17:25:27 <dcoutts> cool
17:26:40 <dcoutts> musasabi, don't assume that all the cabal code was well thought out :-)  do feel free to propose and preferably implement refactorings
17:30:01 <syntaxfree> I have a function of type String->String->String
17:30:14 <syntaxfree> I want to produce a function of type IO String->IO String->IO String
17:30:45 <dcoutts> do you reall? why not just  String->String->IO String  ?
17:30:51 <svref> Can I write a methods on "+" and "*" for types I've defined  myself?
17:31:08 <dcoutts> svref, yes, make yur type an instance of the Num class
17:31:15 <syntaxfree> because the function parameters are read from stdin.
17:31:23 <dcoutts> syntaxfree, that's ok
17:31:40 <syntaxfree> if I wanted String->String->IO String, I could just do  newFunc = putStr . func
17:31:51 <kpreid> @type liftM2
17:31:53 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
17:31:53 <syntaxfree> so I thought of liftM
17:31:58 <syntaxfree> @type liftM
17:32:00 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
17:32:02 <syntaxfree> What's the edifference?
17:32:08 <dcoutts> syntaxfree, that's generally the style in the IO monad, pure inputs and efectful result
17:32:19 <kpreid> syntaxfree: liftM2 does the same thing to a 2-arg function like you have
17:32:23 <syntaxfree> oh!
17:32:37 <syntaxfree> I was pretty sure I wanted liftM, I just didn't think it'd be sensitive to number of arguments.
17:32:50 <kpreid> *everything* is sensitive to "number of arguments"
17:33:03 <kpreid> as far as Haskell is concerned, they are utterly different
17:33:15 <syntaxfree> um, that is true, I guess.
17:33:17 <dcoutts> syntaxfree, since to get IO for the input you just use do notation: do {s1 <- getLine; s2 <- getLine; foo s1 s2}
17:33:20 <syntaxfree> Well, not really.
17:33:26 <syntaxfree> plusOne f = (+1) . f
17:33:46 <kpreid> ?
17:33:48 <syntaxfree> f can be a function of any number of arguments, as long as it returns something that (+1) handles.
17:33:51 <syntaxfree> :t (+)
17:33:51 <kpreid> nope
17:33:55 <kpreid> try it
17:33:55 <syntaxfree> @type (+)
17:33:56 <lambdabot> forall a. (Num a) => a -> a -> a
17:34:17 <dcoutts> syntaxfree, and if you can get away with not doing IO in the result that's even better; do { s1 <- getLine; s2 <- getLine; putStr (foo s1 s2) }
17:34:19 <kpreid> > let plusOne f = (+1) . f in (plusOne (+)) 9 1
17:34:19 <lambdabot>  add an instance declaration for (Num (a -> a))
17:34:20 <lambdabot>   In the definition of `vp...
17:34:36 <kpreid> syntaxfree: to make that work you'd need a ".2" just like liftM2
17:34:38 <syntaxfree> dcoutts: I'm trying to hack up an "horizontal cat" .
17:34:54 <dcoutts> what does that do?
17:35:03 <syntaxfree> something that concatenates two files line per line.
17:35:34 <mlh> like paste
17:35:36 <lisppaste2> syntaxfree pasted "hcat" at http://paste.lisp.org/display/23899
17:36:38 <syntaxfree> I have one additional problem.
17:36:43 <syntaxfree> @type putStr
17:36:44 <lambdabot> String -> IO ()
17:36:57 <syntaxfree> so how do I show a IO String? liftM putStr?
17:37:16 <kpreid> putStr . show
17:37:23 <syntaxfree> @type show
17:37:24 <lambdabot> forall a. (Show a) => a -> String
17:37:32 <syntaxfree> oh. thanks!
17:37:39 <kpreid> "show an IO String" isn't really possible
17:37:46 <LordBrain> syntaxfree: i have gotten that kind of error message, re-indented, and it was fixed.
17:37:54 <LordBrain> oops, i was reading up in the buffer
17:38:10 <syntaxfree> Another paste, LordBrain. But thanks!
17:40:00 <LordBrain> yeah... i didnt realize i had irssi paged-up
17:40:05 <LordBrain> :D
17:40:13 <syntaxfree> I seem to be getting into a dead end.
17:40:55 <syntaxfree> >let a = putStr "Hello world!" in putStr (show a)
17:41:05 <kpreid> "stop wanting that"
17:41:08 <syntaxfree> > let a = putStr "Hello world!" in putStr (show a)
17:41:09 <lambdabot>  No IO allowed
17:41:25 <kpreid> once you have 'a', you can run it but you can't change what it does
17:41:32 <syntaxfree> "No instance for (Show (IO ()))"
17:41:44 <syntaxfree> well, how would you do horizontal concatenation from two files?
17:41:47 <kpreid> or, if you actually want to see what it does: you can't do that
17:42:13 <kpreid> (Show (IO a)), if it existed, would be describing the action it takes
17:42:39 <syntaxfree> um?
17:42:55 <kpreid> why do you want to show anything?
17:43:33 <kpreid> I'm looking at your paste now
17:43:41 <kpreid> "putStr (lineConcat a b)" should work fine
17:45:14 <syntaxfree> " Couldn't match `String' against `IO String'
17:45:14 <syntaxfree>       Expected type: String
17:45:14 <syntaxfree>       Inferred type: IO String"
17:45:19 <syntaxfree> well, you can't.
17:45:32 <kpreid> where?
17:45:38 <syntaxfree> putStr :: String -> IO String, if I'm not wrong.
17:45:41 <syntaxfree> @type putStr
17:45:42 <lambdabot> String -> IO ()
17:45:50 <kpreid> you're wrong
17:46:00 <kpreid> where does the compiler say the problem is?
17:46:08 <syntaxfree> you can't just feed an IO String to a function that asks for a String.
17:46:09 <kpreid> or, paste the exact program you're trying to compile
17:46:13 <kpreid> yes, that's true
17:46:23 <syntaxfree>     Couldn't match `String' against `IO String'
17:46:24 <syntaxfree>       Expected type: String
17:46:24 <syntaxfree>       Inferred type: IO String
17:46:24 <syntaxfree>     In the application `ioConcat a b'
17:46:24 <syntaxfree>     In the first argument of `putStr', namely `(ioConcat a b)'
17:46:25 <kpreid> a and b are of type String in paste 2899
17:46:34 <kpreid> yes, don't use ioConcat
17:46:37 <kpreid> use lineConcat
17:46:37 <syntaxfree> I'll change variable names.
17:46:39 <dcoutts> syntaxfree, that's what do notation is for
17:46:50 <syntaxfree> then you'll see.
17:46:53 <dcoutts> syntaxfree, bind the result of your IO String action to a var and then use that
17:46:58 <kpreid> dcoutts: he is:
17:47:05 <kpreid> s/://
17:47:19 <dcoutts> syntaxfree, do {foo <- (thing :: IO String); print foo}
17:47:20 <lisppaste2> syntaxfree pasted "this one" at http://paste.lisp.org/display/23900
17:47:21 <kpreid> syntaxfree: if you look above, I said to use lineConcat on a and b
17:47:54 <syntaxfree> dcoutts: d'oh. You're right!
17:48:25 <kpreid> also, you can write [aName, bName] <- getArgs instead of using head and ht
17:48:47 <syntaxfree> um, interesting.
17:48:49 <syntaxfree> thanks.
17:49:22 <LordBrain> yeah thats nice
17:49:37 <syntaxfree> ok, it does what I  needed.
17:49:39 <LordBrain> i new you could do (aName:bName:_)
17:50:07 <syntaxfree> Now I'm thinking that Haskell is the worst possible language for this kind of one-off hack,  but it's pretty much the only language I can actually use.
17:50:26 <LordBrain> you could also do (thing:: IO String) >>= print
17:50:33 <emertens> args !! 1 works too
17:50:35 <kpreid> hmmm
17:50:45 <emertens> (regarding head . tail
17:50:57 <LordBrain> haha
17:51:05 <LordBrain> yeah
17:51:13 <LordBrain> head . tail, is lisp-like
17:51:22 <emertens> cadr
17:51:25 <LordBrain> yeah
17:51:37 <emertens> I think lisp also just has a second
17:51:44 <kpreid> and destructuring-bind
17:51:48 <syntaxfree> Lisp has cadadr.
17:51:52 <LordBrain> yeah
17:52:00 <kpreid> syntaxfree: yes, but if you use it...
17:52:02 <LordBrain> scheme has them up to 8 levels i think
17:52:06 <syntaxfree> my Scheme teacher used to allow arbitrary cadadadadadadddddrs.
17:52:08 <emertens> Lisp has 4 levels
17:52:11 <syntaxfree> On written exams.
17:52:21 <emertens> cmeaninglostr
17:53:28 <LordBrain> maybe it does have arbitrary, i forget now... i remember they have first, second, third, fourth, ...
17:53:44 <kpreid> @type do args <- getArgs; texts <- mapM readFile args; (putStr . unlines . concat . List.transpose) texts
17:53:45 <lambdabot> Not in scope: `getArgs'
17:53:46 <emertens> up to tenth
17:53:54 <emertens> then it's nth 11
17:53:58 <kpreid> @type do args <- System.getArgs; texts <- mapM readFile args; (putStr . unlines . concat . List.transpose) texts
17:53:59 <lambdabot>   Couldn't match `String' against `Char'
17:54:00 <lambdabot>    Expected type: [[String]]
17:54:17 <kpreid> @type do args <- System.getArgs; texts <- mapM readFile args; (putStr . unlines . concat . List.transpose . map lines) texts
17:54:19 <lambdabot> IO ()
17:54:37 <kpreid> syntaxfree: I think that does what your program does
17:55:32 <kpreid> (except for N files)
17:56:09 <kpreid> > (unlines . concat . List.transpose . map lines) ["a\nb\nc", "1\n2\n3"]
17:56:10 <lambdabot>  "a\n1\nb\n2\nc\n3\n"
17:56:51 <kpreid> apparently not
17:57:02 <kpreid> > (List.transpose . map lines) ["a\nb\nc", "1\n2\n3"]
17:57:03 <lambdabot>  [["a","1"],["b","2"],["c","3"]]
17:57:08 <kpreid> > (concat . List.transpose . map lines) ["a\nb\nc", "1\n2\n3"]
17:57:09 <lambdabot>  ["a","1","b","2","c","3"]
17:57:12 <kpreid> oh
17:57:22 <kpreid> > (unlines . map concat . List.transpose . map lines) ["a\nb\nc", "1\n2\n3"]
17:57:23 <lambdabot>  "a1\nb2\nc3\n"
17:57:40 <kpreid> OK, so main = do args <- System.getArgs; texts <- mapM readFile args; (putStr . unlines . map concat . List.transpose . map lines) texts
17:57:46 <vincenz> > concat . map unlines . List.transpose . map lines $ ["a\nb\nc", "1\n2\n3"]
17:57:47 <lambdabot>  "a\n1\nb\n2\nc\n3\n"
17:58:31 <vincenz> > map unlines [["a", "b"]]
17:58:32 <lambdabot>  ["a\nb\n"]
17:59:10 <vincenz> > unlines. concat. List.transpose . map lines $ ["a\nb\nc", "1\n2\n3"]
17:59:11 <lambdabot>  "a\n1\nb\n2\nc\n3\n"
17:59:35 <dcoutts> syntaxfree, putStr . unlines . map concat . List.transpose . map lines =<< mapM readFile =<< System.getArgs
18:00:32 <kpreid> dcoutts: hah.
18:00:35 <kpreid> anyway, I started this to point out that Haskell can be reasonably short for the one-off hack if you think about it properly
18:00:58 * dcoutts loves one liners
18:01:08 <dcoutts> especially really fast ByteString one liners
18:01:12 <vincenz> dcoutts: tell that to the women
18:01:17 <dcoutts> hah
18:01:25 <vincenz> dcoutts: check out my site!
18:01:36 <vincenz> http://homes.esat.kuleuven.be/~cpoucet/
18:01:37 <lambdabot> Title: Christophe Poucet
18:02:16 <dcoutts> vincenz, very pretty
18:02:20 <vincenz> :)
18:02:35 <dcoutts> actually the above one liner should work quite well with ByteString too
18:02:57 <kpreid> @pl cat = System.getArgs >>= (\x -> if null x then putStr getContents else putStr =<< liftM concat (mapM readFile x))
18:02:58 <lambdabot> cat = ap (flip if' (putStr getContents) . null) ((putStr =<<) . fmap join . mapM readFile) =<< System . getArgs
18:03:39 <emertens> @type fmap join
18:03:41 <lambdabot> forall (f :: * -> *) (m :: * -> *) a. (Functor f, Monad m) => f (m (m a)) -> f (m a)
18:04:49 <emertens> @type fmap ap
18:04:50 <lambdabot> forall (f :: * -> *) (m :: * -> *) a b. (Functor f, Monad m) => f (m (a -> b)) -> f (m a -> m b)
18:05:10 <musasabi> dcoutts: would using Data.Monoid instead of the emptyFoo and unionFoo make sense?
18:05:11 <emertens> @type map map
18:05:12 <lambdabot> forall a b. [a -> b] -> [[a] -> [b]]
18:05:33 <dcoutts> musasabi, probably
18:06:14 <kpreid> @. pl . djinn . type pl \x -> if null x then [] else [length x]
18:06:15 <lambdabot> Cannot parse command
18:08:35 <syntaxfree> kpreid: wow. Thanks!
18:09:21 <syntaxfree> I had forgot about mapM.
18:09:50 <syntaxfree> @type mapM
18:09:51 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
18:09:58 <syntaxfree> mapM requires Control.Monad?
18:10:19 <Cale> yeah
18:10:24 <Cale> It's in Control.Monad
18:10:28 <syntaxfree> thanks!
18:10:48 <syntaxfree> Can I call it directly? Control.Monad.mapM  instead of import Control.Monad?
18:11:41 <Lemmih> Only in GHCi.
18:11:52 <syntaxfree> vincenz: your site looks odd-ish on higher resolutions.
18:12:16 <syntaxfree> you should make the top and bottom bars more "floaty" as browsers resize.
18:12:39 <syntaxfree> oh. Cool research papers, though!
18:12:54 <vincenz> syntaxfree: hmm
18:12:59 <syntaxfree> http:///www.navarro.mus.br/diego/blog  <-- my site.
18:13:03 <vincenz> syntaxfree: omre to come soon :)
18:13:33 <syntaxfree> one slash too many.
18:14:10 <Pseudonym> (forall f_1 :: (A_2 -> A_3). forall v1_4 :: A_2. f_1 (id (| A_2 |) v1_4) = id (| A_3 |) (f_1 v1_4))
18:14:26 <Pseudonym> That's the free theorem for id.
18:14:59 <syntaxfree> Theorems for nothing and lemmas for free.
18:15:08 <Pseudonym> That ain't working.
18:15:08 <syntaxfree> I want my ... I want my ... I want my PhD  ...
18:15:13 <petekaz> @where fps
18:15:14 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
18:15:19 <Pseudonym> Still a bit of simplifcation to do.
18:15:27 <Pseudonym> That theorem is actually nicer in pointless form.
18:16:04 <Pseudonym> f_1 (id v1_4) = id (f_1 v1_4)  ==>  f_1 . id = id . f_1
18:17:36 <Pseudonym> (forall f_1 :: (A_2 -> A_3). forall f_4 :: (B_5 -> B_6). forall v1_7 :: (A_2 -> B_5). forall v2_8 :: (A_3 -> B_6). (forall v1_9 :: A_2. forall v2_10 :: A_3. f_1 v1_9 = v2_10 => f_4 (v1_7 v1_9) = v2_8 v2_10) => (forall v1_11 :: [A_2]. forall v2_12 :: [A_3]. (forall f_13 :: (A_2 -> A_3). (forall x_14 :: A_2. forall y_15 :: A_3. f_1 x_14 = y_15 => f_13 x_14 = y_15) => $map f_13 v1_11 = v2_12) => (forall f_16 :: (B_5 -> B_6). (forall x_17 :: B_5. forall y
18:18:06 <Pseudonym> $map f_16 (map (| A_2 |) (| B_5 |) v1_7 v1_11) = map (| A_3 |) (| B_6 |) v2_8 v2_12)))
18:18:13 <Pseudonym> That's the free theorem for map.
18:18:25 <Pseudonym> yikes.
18:18:41 <vincenz> Pseudonym: o.O
18:18:49 <syntaxfree> I don't understand that notation at all.
18:19:01 <syntaxfree> what implies what?
18:19:13 <Pseudonym> It simplifies to: f2 . v1 = v2 . f1  => $map f2 . map v1 = map v2 . $map f1
18:19:22 <Pseudonym> Where $map is the standard map.
18:19:47 <vincenz> Pseudonym: wha tlangauge was that
18:20:04 <Pseudonym> data Theorem
18:20:04 <Pseudonym>     = ThForall Var Type Theorem
18:20:04 <Pseudonym>     | ThImplies Theorem Theorem
18:20:04 <Pseudonym>     | ThEqual Expr Expr
18:20:09 <Pseudonym> With an appropriate "show".
18:20:10 <vincenz> o.O
18:20:45 <vincenz> syntaxfree: should have another paper on there soon, getting presented in october :)
18:21:08 <vincenz> and btw
18:21:17 <vincenz> note that that background picture was mousedrawn by me :
18:21:18 <vincenz> :)
18:22:20 <syntaxfree> vincenz: with ArtRage?
18:23:03 <vincenz> no
18:23:05 <vincenz> erm
18:23:09 <vincenz> paintshop pro or photoshop
18:23:11 <vincenz> can't remember
18:23:14 <vincenz> maybe paint
18:24:12 <syntaxfree> not Paint.
18:24:17 <vincenz> just I drew the contour
18:24:23 <vincenz> then started pixelling
18:24:24 <syntaxfree> ArtRage is really cool for mouse drawing.
18:24:26 <vincenz> this is like 5 years ago
18:24:29 <vincenz> pixelling was hot then
18:24:35 <vincenz> though I did use some smoothing
18:24:41 <vincenz> but mostly pixelling
18:24:46 <syntaxfree> http://www.ambientdesign.com/artrage.html
18:24:47 <lambdabot> Title: ArtRage 2
18:25:27 <vincenz> espanol?
18:25:42 <syntaxfree> Rage. Art.
18:25:56 <vincenz> you
18:25:57 <syntaxfree> It doesn't say ArteRabia, it says ArtRage.
18:26:00 <vincenz> your blog
18:26:05 <syntaxfree> no, portuguese.
18:26:14 <vincenz> oh
18:26:17 <vincenz> from portugal?
18:26:24 <syntaxfree> nope.
18:26:38 <vincenz> brazil
18:26:47 <syntaxfree> that youtube embedded film is something I made too.
18:26:51 <syntaxfree> Watch it :)
18:27:19 <vincenz> you're eil
18:27:20 <vincenz> evil
18:28:15 <syntaxfree> me? why?
18:28:23 <vincenz> what are those
18:29:35 <syntaxfree> it's  socialism  striving to change human nature ;)
18:30:57 <LordBrain> what would be a fixed point that is not a least fixed point?
18:31:28 <vincenz> syntaxfree: so... do brazilians have a lot of contact with portuguese due to language?
18:31:30 <LordBrain> i'm trying to understand the concept
18:31:47 <vincenz> LordBrain: another fixed poitn
18:31:55 <vincenz> it's simple
18:31:59 <vincenz> x  = fixed point of F
18:31:59 <vincenz> if
18:32:01 <syntaxfree> what is a "least" fixed point?
18:32:02 <vincenz> F(x) =x
18:32:29 <LordBrain> yeah ok, but what makes it least or not?
18:32:33 <vincenz> x is least fixed point of F iff: x is fixed point of F, for all y: if y fixed point of F then x<=y for some measure <=
18:32:44 <vincenz> typically you have a CPO
18:32:52 <vincenz> so you have _|_ as least value
18:33:04 <syntaxfree> Ugh. Proofs in game theory always end up involving the ugliest fixed point theorems.
18:33:15 <vincenz> (_|_)
18:33:18 <vincenz> that one?
18:33:19 <syntaxfree> I might kill someone the next time Kakutani's FPT comes up.
18:33:33 <LordBrain> ok, i'm loooking at the function, Control.Monad.Fix.fix
18:33:42 <LordBrain> @type Control.Monad.Fix.fix
18:33:44 <lambdabot> forall a. (a -> a) -> a
18:33:45 <vincenz> (_!_)
18:34:03 <vincenz> LordBrain: got nothing to do with it
18:34:15 <LordBrain> the docs say it gives least fixed point, but you said some measure <=, and a is not necessarily having that
18:34:30 <vincenz> sure it does
18:34:36 <LordBrain> hmm?
18:34:37 <vincenz> it's the square <=
18:34:43 <LordBrain> square <= ?
18:34:45 <vincenz> and the bottom for that relationship
18:34:46 <vincenz> is
18:34:47 <vincenz> _|_
18:34:52 <vincenz> aka infinite recursion
18:34:57 <syntaxfree> S&M?
18:34:58 <vincenz> yes
18:35:04 <vincenz> syntaxfree: no bdsm
18:35:53 <LordBrain> i dont know what square <= means
18:36:01 <vincenz> it looks squarish
18:36:03 <vincenz> imagine
18:36:04 <vincenz> an =
18:36:07 <vincenz> with the left side closed
18:36:09 <vincenz> and a _
18:36:10 <vincenz> under it
18:36:26 <vincenz> but that's ust a symbol
18:36:31 <vincenz> there is a <= relationship for all values
18:36:37 <vincenz> namely _|_ being the least
18:36:43 <LordBrain> oh
18:36:56 <vincenz> got nothing to do with Ord
18:36:56 <LordBrain> but how does it know what relationship to use?
18:37:09 <vincenz> it dosn't need to
18:37:14 <vincenz> it's a theoretical guarantee
18:37:20 <LordBrain> so its alwayas the same partial ordering?
18:37:30 <vincenz> o.O
18:37:43 <vincenz> this is not haskell code
18:37:50 <vincenz> this is like theoretical <=
18:37:53 <vincenz> and yes
18:37:58 <vincenz> they all share _|_ as bottom
18:38:13 <LordBrain> if you have f (_|_) = _|_ then fix is just always going to return _|_
18:38:19 <vincenz> http://en.wikipedia.org/wiki/Complete_partial_order
18:38:27 <vincenz> right
18:38:44 <vincenz> and in this case
18:38:48 <vincenz> _|_ = infinite recursion
18:38:50 <LordBrain> _|_ is like undefined right?
18:39:03 <vincenz> _|_ = no value
18:39:06 <LordBrain> ok
18:39:09 <vincenz> either through a crashing undefined
18:39:13 <vincenz> or a hanging application
18:39:35 <LordBrain> suppose i have a function with a nice fixed point.. say x |-> x^2
18:40:02 <syntaxfree> http://www.nber.org/papers/w12387
18:40:04 <lambdabot> Title: Handedness and Earnings
18:40:06 <LordBrain> if i apply fix to that i get 1? but _|_ is less, why shouldnt i get _|_ ?
18:40:12 <syntaxfree> Left-handed men earn 15% more than right-handed ones in the US.
18:40:22 <LordBrain> cool
18:40:25 <Lemmih> Really?
18:40:36 <LordBrain> well its correlated with creativity
18:40:53 <LordBrain> maybe creative people earn more... that makes kinda makes sense, doesnt it?
18:40:55 <vincenz> huh?/
18:41:10 <LordBrain> it still is surprising tho
18:41:12 <vincenz> syntaxfree: that's cause they jerkoff less at work
18:41:25 <LordBrain> maybe its not true
18:42:15 <LordBrain> hmmm only applies to men
18:42:48 <vincenz> in Brazil, left-breasted women earn 15% more than right-breastd ones
18:43:11 <syntaxfree> it's an econometric study published by the National Bureau of Economic Research.
18:43:13 <vincenz> I bet I could make a study that proves that
18:43:28 <syntaxfree> You can't. Not with proper statistical practices.
18:43:40 <vincenz> population studies are only as good as the used populations
18:43:55 <syntaxfree> Um, not with proper statistical practices.
18:44:06 <syntaxfree> Do you even know anything about statistical inference?
18:44:06 <vincenz> meaningless in human populations
18:44:06 <LordBrain> are you left handed syntaxfree ?
18:44:11 <syntaxfree> Or probability theory?
18:44:17 <vincenz> syntaxfree: no I do not, I took ee
18:44:18 <vincenz> of course
18:44:28 <LordBrain> hehe
18:44:40 <syntaxfree> Last time I checked EE students took  stochastic processes and  time-series analysis.
18:44:40 <Lemmih> What about ambidextrous people?
18:44:59 <dons> ?users
18:44:59 <syntaxfree> anyway, there's hard maths behind statistical inference.
18:45:02 <lambdabot> Maximum users seen in #haskell: 235, currently: 200
18:45:02 <LordBrain> done properly, i think statistical studies do give us good information...
18:45:07 <dons> 235!
18:45:16 <Korollary> some EE students do. Not all.
18:45:21 <vincenz> syntaxfree: yes we do, and I'm telling you, you need a serious sample size to get anything relevant.
18:45:25 <vincenz> Korollary: I was being sarcastic
18:45:29 <vincenz> dons: check out my new look
18:45:32 <vincenz> http://homes.esat.kuleuven.be/~cpoucet/index.html
18:45:33 <syntaxfree> well, actually you don't.
18:45:33 <lambdabot> Title: Christophe Poucet
18:45:37 <syntaxfree> You need serious sample variability.
18:46:08 <vincenz> whih typically these studies don't accomplish as only certain demographics care for enrolling in these stupid tests or answering faithfully.
18:46:10 <syntaxfree> If you take all the employees in one company, you have a large sample size, but squat inference.
18:46:22 <LordBrain> mayube i should practice writing with my left hand
18:46:25 <LordBrain> hehehehe
18:46:25 <dons> vincenz: very nice :)
18:46:34 <Korollary> LordBrain: I do that. It's crazy.
18:46:45 <Korollary> I'm pretty good at it.
18:46:48 <LordBrain> cool
18:46:51 <vincenz> not to mention that lower income people might have switched to right hand.  I know from first person stories of people switching to righthand cause they were told that using the lefthand was work of the devil in school
18:46:56 <vincenz> dons: thx :)
18:46:56 <Korollary> but still slower than with my right
18:47:09 <LordBrain> oh thats true vincenz i've heard of that too
18:47:28 <LordBrain> maybe we are really supposed to have more left-handers
18:47:33 <aFlag> I write like crap with my both hands
18:47:39 <vincenz> aFlag: =D
18:48:37 <aFlag> Also I don't have a good kick in either legs. So I actually don't have a good side
18:48:57 <Korollary> I bet one of your hand is stronger than the other, nonetheless.
18:48:59 <LordBrain> > fix g where g x = x^2
18:48:59 <lambdabot>  Parse error
18:49:21 <LordBrain> >let g x = x * x in fix g
18:50:14 <Lemmih> Third time's the charm.
18:50:32 <LordBrain> > let g x = x^2 in fix g
18:50:34 <lambdabot>  Exception: <<loop>>
18:51:56 <vincenz> _|_
18:51:59 <LordBrain> shouldn't that function have a fixed point of 1 ?
18:52:02 <vincenz> no
18:52:13 <LordBrain> g 1 = 1
18:52:13 <vincenz> _|_ is a fixed point
18:52:16 <LordBrain> ok
18:52:19 <vincenz> besides
18:52:27 <vincenz> notice that <= does not count on numbers
18:52:32 <vincenz> all the numbers are not comparable to each other
18:52:34 <vincenz> using this <=
18:52:38 <vincenz> that is why it's a PARTIAL order
18:52:43 <LordBrain> i know that
18:52:45 <vincenz> it's one flat line of numbers all >= |_|
18:52:47 <vincenz> _|_
18:52:48 <vincenz> ok :)
18:52:51 <vincenz> just checking
18:53:01 <vincenz> anywas
18:53:03 <vincenz> g is strict
18:53:06 <vincenz> so g _|_ = _|_
18:53:09 <LordBrain> but i dont yet see why fix is useful, isnt it always going to give me _|_ ?
18:53:18 <vincenz> fix (1:)
18:53:18 <LordBrain> hmmmmm
18:53:20 <vincenz> > fix (1:)
18:53:21 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:53:28 <Lemmih> |_| = boxed? (:
18:53:29 <LordBrain> oh
18:53:34 <vincenz> Lemmih: :)
18:53:52 <LordBrain> so [1..] is considered <= _|_, why?
18:53:58 <vincenz> erm
18:54:01 <vincenz> _|_ is not a solution
18:54:08 <vincenz> f x = 1:x
18:54:12 <vincenz> 1:_|_ is not _|_
18:54:16 <dons> > take 10 $ [1..]
18:54:16 <vincenz> lists are lazy
18:54:17 <LordBrain> what is it?
18:54:17 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
18:54:22 <vincenz> it
18:54:24 <vincenz> it's a partial list
18:54:26 <dons> > take 10 $ undefined
18:54:27 <lambdabot>  Add a type signature
18:54:31 <dons> > take 10 $ undefined :: ()
18:54:32 <lambdabot>  Couldn't match `()' against `[a]'
18:54:37 <dons> boo on defaulting
18:54:42 <vincenz> :P
18:54:52 <dons> i should install a new ghc, with the extended-defaults flag
18:55:02 <vincenz> another interesting one
18:55:49 <LordBrain> ok i think i'm understanding... starting to
18:56:33 <vincenz> > fix (\l -> (map return ['a'..'z']) ++ (map concat . sequence $ [l, (map return ['1'..'9'])]))
18:56:34 <lambdabot>  ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s"...
18:56:40 <vincenz> > fix (\l -> (map return ['a'..'b']) ++ (map concat . sequence $ [l, (map return ['1'..'9'])]))
18:56:41 <lambdabot>  ["a","b","a1","a2","a3","a4","a5","a6","a7","a8","a9","b1","b2","b3","b4","b...
18:56:46 <vincenz> > fix (\l -> (map return ['a'..'b']) ++ (map concat . sequence $ [l, (map return ['1'..'2'])]))
18:56:47 <lambdabot>  ["a","b","a1","a2","b1","b2","a11","a12","a21","a22","b11","b12","b21","b22"...
18:56:57 <vincenz> @pl (\l -> (map return ['a'..'b']) ++ (map concat . sequence $ [l, (map return ['1'..'2'])]))
18:56:58 <lambdabot> (map return ['a'..'b'] ++) . map join . sequence . (: [map return ['1'..'2']])
18:57:02 <vincenz> ooh
18:58:01 <vincenz> > fix $ (["a"] ++) . map join . sequence . (: [["1"]])
18:58:02 <lambdabot>  ["a","a1","a11","a111","a1111","a11111","a111111","a1111111","a11111111","a1...
18:58:16 <LordBrain> > fix (\x -> 1/(1+x))
18:58:17 <lambdabot>  Exception: <<loop>>
18:58:21 <LordBrain> oops
18:58:23 <vincenz> strict
18:58:27 <LordBrain> yeah.....
18:58:33 <LordBrain> oh thats not what i meant
18:58:58 <LordBrain> > fix f where f = 1/(1+(f x))
18:58:58 <lambdabot>  Parse error
18:59:09 <vincenz> o.O
18:59:20 <vincenz> that makes no sense
18:59:21 <vincenz> x is undefined
18:59:33 <LordBrain> > let f x = 1/(1+ (f x)) in fix f
18:59:34 <lambdabot>  Exception: stack overflow
18:59:37 <vincenz> you're not gonna use fix to do arithmetics
18:59:44 <vincenz> it's not meant for newton rhapson and such
18:59:45 <LordBrain> hehehe
18:59:49 <vincenz> you don't have a starting value
19:01:09 <LordBrain> i caused a runtime exception... hmmm
19:01:32 <vincenz> I'm off
19:03:10 <LordBrain> hmmmm
19:04:22 <LordBrain> > let f x = x:f x in fix f
19:04:23 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
19:04:24 <lambdabot>    Expected...
19:04:33 <Pseudonym> (forall f_1 :: (A_2 -> A_3). forall f_4 :: (B_5 -> B_6). forall v1_7 :: ((,) [A_2] [B_5]). forall v2_8 :: ((,) [A_3] [B_6]). (forall f_9 :: (A_2 -> A_3). (forall x_10 :: A_2. f_9 x_10 = f_1 x_10) => $map f_9 ($fst v1_7) = $fst v2_8) && (forall f_12 :: (B_5 -> B_6). (forall x_13 :: B_5. f_12 x_13 = f_4 x_13) => $map f_12 ($snd v1_7) = $snd v2_8) => (forall f_15 :: ((,) A_2 B_5 -> (,) A_3 B_6). (forall x_16 :: ((,) A_2 B_5). forall y_17 :: ((,) A_3 B_6)
19:04:45 <Pseudonym>  && f_4 ($snd x_16) = $snd y_17 => f_15 x_16 = y_17) => $map f_15 (zip (| A_2 |) (| B_5 |) v1_7) = zip (| A_3 |) (| B_6 |) v2_8))
19:04:56 <monochrom> What is Pseudonym doing?  X|
19:05:03 <Pseudonym> That's the free theorem for zip.
19:05:22 <Pseudonym> *FreeTheorems> tZip
19:05:23 <Pseudonym> (forall A. forall B. (,) [A] [B] -> [(,) A B])
19:05:27 <LordBrain> > let f x = x:x in fix f
19:05:27 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
19:05:28 <lambdabot>    Expected...
19:05:46 <Pseudonym> Need to fix the display of pair types.
19:05:48 <LordBrain> > let f = (1:) in fix f
19:05:49 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
19:06:15 <monochrom> f xs = 1 : xs   you have
19:06:22 <LordBrain> > let f x = 1:x in fix f
19:06:23 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
19:06:46 <LordBrain> > let f x = 1:2:x in fix f
19:06:47 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
19:07:29 <monochrom> Note that fix does not check equality for convergence.  It is futile to try to do numerical methods with fix.
19:07:33 <vincenz> > let f x = 1:(map (2*) x) in fix f
19:07:34 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
19:07:55 <vincenz> > drop 1000000 $ let f x = 1:(map (2*) x) in fix f
19:07:57 <lambdabot>  Exception: stack overflow
19:07:59 <vincenz> > drop 1000\0 $ let f x = 1:(map (2*) x) in fix f
19:08:00 <lambdabot>  Parse error
19:08:02 <vincenz> > drop 10000 $ let f x = 1:(map (2*) x) in fix f
19:08:03 <lambdabot>  [199506311688075838488374216268358508382349683188619245485200894985294388302...
19:08:07 <vincenz> > drop 100000 $ let f x = 1:(map (2*) x) in fix f
19:08:11 <lambdabot> Terminated
19:08:17 <vincenz> > drop 50000 $ let f x = 1:(map (2*) x) in fix f
19:08:20 <lambdabot>  [316069943685631789613592465994569178898467638783493566684774315556494393790...
19:08:24 <LordBrain> well, so far, i see, fix gives us a way to construct infinite lists...
19:08:34 <vincenz> > 2 ^ 50000
19:08:36 <lambdabot>  3160699436856317896135924659945691788984676387834935666847743155564943937902...
19:08:37 <LordBrain> which we already had...
19:08:43 <LordBrain> hmmm
19:10:02 <monochrom> Yes, you never "need" fix.
19:10:33 <monochrom> fix gives all recursion. but you already have recursion.
19:10:58 <dons> clearly its not needed, since its : fix f = let x = f x in x
19:11:09 <lisppaste2> petekaz pasted "confused, shouldn't the fps version be faster?" at http://paste.lisp.org/display/23906
19:11:09 <dons> but that doesn't mean it isn't useful some times
19:11:17 <lisppaste2> LordBrain pasted "Yi uses fix" at http://paste.lisp.org/display/23907
19:11:57 <dons> tails is damn slow though, petekaz
19:12:07 <petekaz> oh.
19:12:18 <petekaz> I thought with laziness and all it wouldn't matter.
19:13:03 <dons> petekaz: i'll have a look though.
19:13:16 <dons> tails is much much faster under 6.5, due to a chance in the ForeignPtr representation
19:13:17 <petekaz> I was just trying to think of a trivial example of laziness (e.g. readFile) to show some Java terds at work.
19:13:36 <petekaz> oh. I'll run it on my 6.5 then.
19:14:13 <dons> why are you using putStrLn . show ?
19:14:19 <dons> why not L.putStrLn
19:14:28 <dons> that show is an 'unpack', which is sloooow
19:14:38 <petekaz> I dunno ... I just print True or False.
19:14:48 <petekaz> if the word is in the file.
19:15:11 <petekaz> it only happens once, didn't think it was a big deal.
19:15:36 <dons> oh, any is a True. my mistake ;)
19:15:49 * dons takes coffee
19:15:58 * shapr takes nap
19:16:03 <Pseudonym> (forall f_1 :: (A_2 -> A_3). f_1 (undefined (| A_2 |)) = undefined (| A_3 |))
19:16:09 <Pseudonym> That's actually quite a pretty theorem.
19:16:20 <stepcut> dons: it took a whole roll of duct tap, but I got lambdabot talking in a jabber chat room :)
19:16:25 <Pseudonym> If undefined :: a, then for all f, f undefined = undefined
19:16:38 <stepcut> s/tap/tape/
19:16:42 <Pseudonym> Well, bottom
19:17:01 <petekaz> We had a company outing today, and I was chatting with the java kids trying to explain laziness, realized I was not successful, so I wanted to followup with an example of doing 'something' to a huge file in a lazy manner.
19:17:24 <lisppaste2> monochrom annotated #23907 with "two ways of looping" at http://paste.lisp.org/display/23907#1
19:18:06 <petekaz> I thought 'any' with 'readFile' was cool because as I understand it, once the word is found, the file is not read anymore.
19:18:32 <dons> stepcut: cool!
19:19:09 <dons> petekaz: well, a simpler, nicer example might be to filter something from the file
19:19:20 <dons> since that will use constant space in a lazy language
19:19:38 <dons> but in C or so, you'd have to either simulate laziness, or deal with O(n) space
19:19:49 <petekaz> my example is a bad one?
19:20:00 <petekaz> I must not understand something then.
19:20:20 <stepcut> dons: the jabber<->irc translater only handles privmsg so far (and is a big hack), but it is still pretty cool :)
19:20:37 <dons> are you using isPrefixOf . tails as an isSubString, petekaz ?
19:20:44 <petekaz> yes.
19:21:42 <petekaz> If I call 'tails' on the contents of a file (readFile), it doesn't read the whole file into memory right, unless I end up traversing the whole list of tails, right?
19:22:09 <dons> right, i think that's the case, unless i've made tails too strict
19:22:14 <petekaz> I thought 'any' would pull just enough characters of the first element of tails from readFile.
19:22:52 <dons> yep
19:22:58 <petekaz> The speed of my fps version is slower than nonfps.
19:23:23 <petekaz> wall clock.  sys time is less with fps though.
19:23:38 <LordBrain> Data.List.tails returns the whole list as the first element
19:23:41 <LordBrain> hmm
19:23:52 <LordBrain> thats because i ran it thru show tho
19:23:55 <LordBrain> hmmm
19:24:03 <dons> ah. hmm.
19:24:44 <LordBrain> if it wasnt evaluated, it would just have maybe the first element?
19:24:45 <petekaz> Oh, and is there a way to see how much memory was used?  I want to see for myself that laziness prevents the whole file from being read into memory.  Is there an easy flag for this?
19:24:46 <LordBrain> like
19:25:11 <dons> petekaz: this seems to run very quickly:
19:25:13 <dons> import qualified Data.ByteString.Char8 as P
19:25:13 <dons> main = do
19:25:13 <dons>   [str,file] <- P.getArgs
19:25:13 <dons>   contents   <- P.readFile (P.unpack file)
19:25:15 <dons>   print . (P.isSubstringOf str) $ contents
19:25:28 <LordBrain> (1:restThisTail):restOfTails
19:26:49 <petekaz> dons: ok, nice to know, but in chatting with them, I specifically brought up the example of the implementation of isSubString in haskell using tails as being totally crazy in a strict language, so I was trying to include that in my example.
19:27:22 <lisppaste2> monochrom annotated #23907 with "two ways of mutual-looping" at http://paste.lisp.org/display/23907#2
19:27:33 <emertens> Anyone here use irssi and know if it's possible to perform a search on the backlog?
19:27:38 <dons> sure. its reasonable. there's probably better examples we could find.
19:28:48 <dons> petekaz: oh, the lazy version still seems to run quickly here.
19:29:00 <dons> what are you compiing it with, and how large is the file?
19:29:36 <monochrom> > take 10 (map head (tails [1..]))
19:29:37 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
19:29:54 <monochrom> That's showing how tails can be used without hanging.
19:30:20 <petekaz> dons: the lazy version as I had it?  or your version?
19:30:20 <LordBrain> emertens: well.. i know you could just grep the log file
19:30:27 <Pseudonym> Meeting.  BBS
19:30:37 <emertens> LordBrain: that's only effective if you log :)
19:30:51 <petekaz> dons: the input file is only /usr/dict/words (pretty small), I compile with ghc -O2 --make
19:31:17 <dons> oh, yes, I see the list version is still faster. though they're all pretty good
19:31:53 <syntaxfree> I fear the day Gentoo drops Python for Haskell for its tools.
19:32:09 <petekaz> dons: so the fps version I posted is faster than the nonfps version I posted on your machine?
19:32:09 <syntaxfree> This channel's gonna get full of Gentoo kiddies asking about optimization flags.
19:32:09 <dons> you fear that day?
19:32:13 <stepcut> syntaxfree: haha
19:32:21 <araujo> syntaxfree, muahaha
19:32:33 <dons> petekaz: nope. the char version is faster than the lazy fps, is faster than the strict fps
19:32:35 <syntaxfree> (Linspire uses Haskell already)
19:32:42 * araujo laughs devilishly 
19:33:05 <emertens> What does Linspire use Haskell for?
19:33:07 <LordBrain> emertens: its /lastlog
19:33:11 <petekaz> dons: isn't that backwards?
19:33:14 <SamB_XP> well, hopefully if gentoo picks up haskell they'll also pick up an interest in correctness
19:33:23 <syntaxfree> Nah.
19:33:26 <dons> but the kiddies don't ask about python flags, do they? ;) they're happy for it to run dog slow
19:33:40 <syntaxfree> There are Python flags?
19:33:47 <dons> emertens: the package tools and other distro tools
19:33:48 <LordBrain> you can use /lastlog -regexp REGEXP
19:33:51 <emertens> LordBrain: thank you! that's perfect
19:33:52 <syntaxfree> They just need to find Haskell more helpful than Python for the distribution tools.
19:33:55 <SamB_XP> syntaxfree: not really
19:34:01 * araujo laughs devilishly 
19:34:01 <dons> ?last 3
19:34:02 <lambdabot> I haven't got any logs for that channel.
19:34:06 <dons> ?last #haskell3
19:34:06 <lambdabot> I haven't got any logs for that channel.
19:34:07 <dons> ?last #haskell 3
19:34:12 <lambdabot> 02:32:45 <syntaxfree> They just need to find Haskell more helpful than Python for the distribution tools.
19:34:12 <emertens> i did a /help lastlog
19:34:12 <lambdabot> 02:32:49 <SamB_XP> syntaxfree: not really
19:34:12 <lambdabot> 02:32:54 <araujo> ACTION laughs devilishly 
19:34:16 <dons> hehe
19:34:16 <SamB_XP> there is maybe one or two but they buy little and lose debuggability in a major way
19:34:39 <araujo> :-}
19:35:36 <SamB_XP> and double the installed size of debian Python packages, probably, too... well, maybe not quite...
19:35:39 <dons> petekaz: compiling with -O -funbox-strict-fields, on ghc 6.5, all the versions seem to run very nicely.
19:35:48 <petekaz> dons: sorry for being dense, but I am not sure of the conclusion here, my code that I pasted (the lazy fps and nonfps), should I expect the lazy fps to be faster?
19:35:53 <dons> and the [Char] version (being laziest), being fast, is also nice
19:35:55 <araujo> now you mention about it, ive found interesting the fact that some people has suggested Haskell as a good alternative for OS design in one of the kernel mailing list i am subscribed.
19:36:00 <dons> petekaz: not always
19:36:07 <araujo> a revolution is coming :-)
19:36:11 <SamB_XP> and if there are any optimizations which break correct programs, those optimizations are broken and should be STOMPED
19:36:28 <dons> in particular, here you want to be as lazy as possible. lazy bytestrings still read in 32k chunks strictly
19:36:32 <syntaxfree> araujo: there was a Haskell toy OS some time ago.
19:36:37 <petekaz> dons: what is the [Char] version?  is that the lazy fps, strict fps, or nonfps?
19:36:37 <syntaxfree> araujo: it even had a GUI of sorts.
19:36:45 * araujo only thought Haskell-OS ideas were for Haskell-out-of-mind-zealots
19:36:45 <dons> petekaz: the nonfps
19:36:54 <stepcut> there is also a haskell-l4 port I think
19:37:04 <araujo> syntaxfree, well, we got House right?
19:37:15 <syntaxfree> yeah, that's what I was talking about, I guess.
19:37:16 <SamB_XP> unfortunately it comes with its own GHC too
19:37:25 <SamB_XP> and it doesn't have a C library so no GHCi
19:37:30 <araujo> yeah, ive used it.
19:37:39 <araujo> or better said... tested it
19:37:48 <petekaz> dons: ok ... so in this trivial example, the overhead of fps implementation is killing its benefits compared to the non fps version.
19:37:57 <syntaxfree> I wonder how a Haskell shell would work.
19:37:59 <petekaz> dons: that was a question
19:38:03 <dons> petekaz: i think so. you want to be lazy on the char level
19:38:07 <araujo> syntaxfree, checl hashell!
19:38:09 <syntaxfree> Maybe one should start with a haskell shell for unices.
19:38:19 <emertens> there isn't one?
19:38:21 <syntaxfree> !
19:38:22 <petekaz> dons: ok ... thanks!  I can show this to the weenies tomorrow!
19:38:22 <syntaxfree> :)
19:38:33 <dons> petekaz: you show those weenies!
19:38:48 <emertens> http://www.informatik.uni-bonn.de/~ralf/software/examples/Hsh.html
19:38:49 <lambdabot> Title: Hsh.hs
19:38:57 <araujo> emertens, we almost got one for this SoC :-}
19:38:58 <syntaxfree> "Map the contents of a file into a list of strings:
19:38:58 <syntaxfree> -> :p words (-cat file.txt-)
19:39:00 <syntaxfree> oh, cool!
19:39:22 <emertens> according to http://lambda-the-ultimate.org/node/299 there seem to be multiple haskell os attempts
19:39:23 <lambdabot> Title: House , hOp - the Haskell Operating System | Lambda the Ultimate
19:39:47 <araujo> syntaxfree, yay, many thing can still be improved, so suggestions welcome :-)
19:39:57 <syntaxfree> I was pretty impressed with the one-line "horizontal cat" people coughed up earlier today here.
19:40:18 <syntaxfree> I'm thinking of replacing bash scripting with Haskell for good.
19:40:26 <araujo> yay!
19:40:31 <SamB_XP> for great justice!
19:40:41 <emertens> send all zig!@
19:40:53 <araujo> syntaxfree, i think that's something we need to pursuit
19:40:57 <LordBrain> it seems to me that haskell can be optimized a lot further... i get the impression that there is a lot of information that ghc doesnt make use of that could improve it's code even more... not that i know very well...
19:41:04 <araujo> In the haskell community i meant
19:41:15 <LordBrain> do others get that impression too?
19:41:27 <emertens> that GHC isn't optimizing enough?
19:41:34 <LordBrain> well whats enough?
19:41:43 <LordBrain> can we optimize too much?
19:42:07 <syntaxfree> well, is interpreted Haskell (with runghc or something) on par with Ruby and Python for performance?
19:42:09 <araujo> Real applications of daily use, will make the needs of our community to show up, and so we can give them a purely functional alternative.
19:42:39 <araujo> And show to Dennis we can take functional programming out to the street :-)
19:42:47 <dons> syntaxfree: does it matter? its a compiled language. the interpreted stuff isn't even optimised.
19:43:04 <syntaxfree> Well, it's just because most scripting languages aren't compiled.
19:43:18 <syntaxfree> and, um, comparing *whatever*  with C isn't quite fair.
19:43:33 <syntaxfree> http://www.cse.ogi.edu/~hallgren/House/P/screendump-oct2005.png
19:43:41 <syntaxfree> jesus, they put COMIC SANS on that? :(
19:43:42 <dons> i think ghci does compare very well with python. i don't have numbers though
19:43:47 <emertens> C isn't the end-all of speed potential
19:43:51 <SamB_XP> the only reason comparing with C isn't fair is because C would do badly
19:43:58 <SamB_XP> because it sucks as a scripting language
19:44:03 <emertens> a lot of the meaning is lost in C, at least to the compiler
19:44:14 * araujo thinks we could be using a Haskell OS within the next few years!
19:44:16 <dons> sure. haskell beats C 35% of the time on the shootout, even.
19:44:26 <SamB_XP> mots likely GHCi beats Python hands down
19:44:46 <SamB_XP> considering the library is not interpreted in GHCi's case...
19:44:54 <dons> yeah.
19:44:59 <SamB_XP> well, assuming you don't use too many lazy lists for IO
19:45:12 <syntaxfree> dons: um, what shootout?
19:45:19 <dons> great language shootout
19:45:23 <emertens> @google programming shootout
19:45:25 <SamB_XP> of course, GHCi doesn't do fusion
19:45:28 <SamB_XP> maybe it ought to
19:45:29 <lambdabot> http://programming.reddit.com/user/sbrown123/
19:45:29 <lambdabot> Title: overview by sbrown123 (on programming.reddit.com)
19:45:32 <SamB_XP> ;-)
19:45:42 <emertens> http://shootout.alioth.debian.org/
19:45:47 <LordBrain> hmmmmm
19:45:49 <SamB_XP> of course, then it wouldn't be much of an interpreter, I guess...
19:46:04 <SamB_XP> it would be more of a compiler masquerading as an interpreter
19:46:21 <dons> you can compare things here, http://shootout.alioth.debian.org/gp4/haskell.php
19:46:22 <syntaxfree> Fusion?
19:46:35 <SamB_XP> syntaxfree: list fusion and all that jazz
19:47:14 <SamB_XP> for elimination of unneeded intermediate lists?
19:48:05 <syntaxfree> ah ok.
19:48:08 <syntaxfree> I don't understand.
19:48:13 <syntaxfree> Java is hard to learn.
19:48:26 <emertens> ?
19:48:28 <syntaxfree> according to that shootout it's slower than GHC, too.
19:48:32 <LordBrain> java is easy if you know c++ already
19:48:34 <syntaxfree> Why is Java SO predominant?
19:48:40 <emertens> because it's easy
19:48:48 <emertens> it was written "for average programmers"
19:49:00 <emertens> and because it scales well in terms of large groups of programmers
19:49:21 <syntaxfree> I find Haskell easier.
19:49:22 <emertens> because you can swap out one java coder for another :)
19:49:22 <dons> still, there's no java software i use on a daily basis...
19:49:24 <musasabi> dcoutts: fist version of the configurations stuff ready :-)
19:49:26 <syntaxfree> I have no formal training. I'm an idiot.
19:49:27 <LordBrain> hmmm well i think the industry muscle behind it was the most important factor
19:49:44 <dcoutts> musasabi, cool, tell me more
19:49:56 <dcoutts> musasabi, or post to cabal-devel
19:50:11 <Lemmih> Cabal config?
19:50:13 <syntaxfree> industry muscle?
19:50:51 <LordBrain> yeah, the bigboys teamed up on it, except for microsoft.., but IBM and Sun especially.
19:51:01 <syntaxfree> so?
19:51:02 <emertens> Microsoft used it until Java sued them
19:51:07 <emertens> sun that is
19:51:11 <syntaxfree> for web apps it's irrelevant what you use.
19:51:12 <LordBrain> yeah
19:52:52 * syntaxfree is running House on Virtual PC now!
19:53:05 <emertens> syntaxfree: OS X or Windows?
19:53:17 <syntaxfree> OS X.
19:53:19 <emertens> os x
19:53:27 <syntaxfree> How do I close a program in House?
19:54:42 <LordBrain> They sort of rammed it down everyone's throats... it seems to me. Plus, it was fairly close to c++, so it was/is no big deal for c++ programmers to move into java. and c++ was the most common language.
19:55:04 <LordBrain> i'd say probably java is the most common now?
19:55:07 <emertens> House boots fast
19:55:16 <emertens> java is the most common language last I saw
19:55:28 <LordBrain> yeah
19:56:02 <LordBrain> i never liked java, tho i must admit i liked c++
19:56:27 <LordBrain> it was an improvement over what i knew before...
19:56:40 <emertens> which was?
19:57:03 <LordBrain> non-oo, procedural langauges, c, asm, pascal
19:57:37 <syntaxfree> I hear all the time C++ isn't really oo.
19:57:47 <LordBrain> and c++ at least originally seemed to hold on to the promise of being as efficient as c.
19:58:14 <LordBrain> ie, you could do anything c in c++
19:58:33 <emertens> I haven't figured out how to close something in House
19:58:34 <emertens> either
19:58:36 <LordBrain> it contains a non-standard version of C as a subset
20:00:27 <LordBrain> well... syntaxfree, we might not have wanted real oo, if it meant a loss in our ability to write nicely optimized code.
20:00:31 <syntaxfree> GHC outperforms C++ in most of the tests.
20:00:48 <__snake> re
20:01:11 <musasabi> Sent it to cabal-devel.
20:01:16 <__snake> Does anybody have experience using GSL Haskell?
20:01:35 <LordBrain> well... it may be that the situation has changed because it has gotten so complex to optimize by hand.
20:02:10 <Marudubshinki> I have a vaguely functional question to ask: are the reduce and fold operations (in general) mostly identical?
20:02:35 <dons> I think we would consider 'reduce' to be a synonym for 'fold'.
20:02:42 <dons> but google's map and reduce are different
20:02:55 <syntaxfree> When I first used Haskell, I rewrote fold.
20:03:09 <Marudubshinki> dons: That's what I was thinking, but how then does one express the foldl and foldr operators as reduce?
20:03:20 <syntaxfree> reduce = foldl.
20:03:24 <syntaxfree> or foldl1.
20:03:33 <LordBrain> possibly its impractical... tho i'm skeptical... i think if you have a person using good algorithms who is also an expert on a particular platform, and allowed to go into c/asm, they can still out do the guy who is stuck in ghc, imo.
20:03:40 <Marudubshinki> foldl1?
20:04:00 <syntaxfree> > foldl1 (*) [1..10]
20:04:02 <lambdabot>  3628800
20:04:16 <syntaxfree> LordBrain: you can see the code they used.
20:04:24 <dons> LordBrain: given infinite time...
20:04:25 <LordBrain> but then is it worth it... its a lot more effort
20:04:30 <__snake> u::Vector->Vector->Vector--returns unit length vector in direction from q to p
20:04:30 <__snake> u q p = x / (norm x)
20:04:30 <__snake>         where   x = p-q
20:04:41 <syntaxfree> http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsieve&lang=gpphttp://shootout.alioth.debian.org/gp4/benchmark.php?test=nsieve&lang=gpp
20:04:42 <lambdabot> Title: nsieve C++ g++ program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ...
20:05:05 <__snake> my problem is that GSL defines (/) operator for vectors as well
20:05:24 <__snake> as element-by-element division
20:05:50 <dons> syntaxfree: I think the better link is: http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsieve&lang=all ;)
20:05:51 <lambdabot> Title: nsieve benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language S ...
20:06:08 <LordBrain> especially if you take the learning of the platform into account.... and the art of hand optimizing and all that... if you have two average programmers, one is allowed to go to asm, and the other can use ghc, ghc has a good chance to win that contest.
20:06:20 <__snake> I need somehow to convince compiler, that x / (norm x) refers to (/)::Vector->Double->Vector
20:06:31 <dons> add a type annotation?
20:06:44 <dons> x / (norm x) :: Vector
20:06:47 <dons> for example
20:07:14 <LordBrain> tho asm guy would produce a smaller binary most likely.
20:07:15 <__snake> dons: let me try
20:07:41 <__snake> Numeric.hs:52:13:
20:07:41 <__snake>     Couldn't match `Vector' against `Double'
20:07:41 <__snake>       Expected type: Vector
20:07:41 <__snake>       Inferred type: Double
20:07:41 <__snake>     In the application `norm x'
20:07:41 <__snake>     In the second argument of `(/)', namely `(norm x)'
20:10:18 <LordBrain> syntaxfree: if you go back in time to 1988, and try to find a compiler that can outdo average asm, you wont find anything that even comes close.
20:10:25 <emertens> are you allowed to overload (/) like that?
20:11:00 <LordBrain> syntaxfree: beyond that, there was C was the closest, a distant second, and then there was everything else.. way out there.
20:12:04 <__snake> emertens: apparently you can
20:12:44 <emertens> let (/) a b = a + b in (/) 4 5
20:12:51 <emertens> > let (/) a b = a + b in (/) 4 5
20:12:52 <lambdabot>  9
20:13:23 <emertens> > let (/) a b = a ++ b in (/) [4] [5]
20:13:24 <lambdabot>  [4,5]
20:14:00 <Lemmih> > let a/b = a++b in [4]/[5]
20:14:01 <lambdabot>  [4,5]
20:14:36 <LordBrain> in fact, i would say that still held true in the early 90s.. maybe as far up until the Pentium II came out. not sure when it happened, but studies started reporting that awesome-asm-hackers were being outperformed by compilers.
20:14:49 <emertens> but when you do that, you lose the standard / operator...
20:14:55 <emertens> seems like a bad idea
20:14:57 <Lemmih> > let (/) a b = (++) a b in (/) ((:[]) 4) ((:[]) 5)
20:14:58 <lambdabot>  [4,5]
20:15:32 <emertens> > let a/b = a ++ b in return 4 / return 5
20:15:33 <lambdabot>  [4,5]
20:16:28 <__snake> emertens: at least they've defined the dot product without overloading (*)...
20:16:52 <Adamant> I read something interesting recently by Micheal Abrash, an assembly demigod who wrote one of the best ASM optimizing guides for games - he says that he will regularly try to optimize a program with ASM and find either no speedup, or an actual speed DECREASE.
20:17:13 <Korollary> Marudubshinki: read this: http://www.cs.vu.nl/~ralf/MapReduce/
20:17:14 <lambdabot> Title: Google's MapReduce Programming Model -- Revisited
20:17:45 <Adamant> Abrash was the guy hired by iD to get Quake I out on time, so he knows his stuff
20:18:02 <Korollary> Adamant: I believe it.
20:18:22 <__snake> this asks for Glasgow extensions:
20:18:28 <__snake> u::Vector->Vector->Vector--returns unit length vector in direction from q to p
20:18:28 <__snake> u q p = x / n
20:18:28 <__snake>         where   x = p-q
20:18:28 <__snake>                 n::Double = norm x
20:18:43 <aFlag> Adamant, what's the address for that?
20:18:48 <dons> right, for the type annoation, __snake
20:18:55 <dons> you just add -fglasgow-exts
20:18:58 <dons> or else write:
20:19:03 <dons> n = norm x :: Double
20:19:17 <__snake> dons: but being provided the extensions, the same error reappears!
20:19:29 <Adamant> aFlag, it was in a Dr. Dobb's from this year or late last year, IIRC
20:19:37 <LordBrain> i remember asm people getting upset too that intel changed the rules of the game in terms of optimizing heh
20:19:51 <emertens> how so
20:19:55 <Marudubshinki> Korollary: actually, I've already downloaded it
20:19:59 <syntaxfree> quick research: left-handed, right-handed or ambidextrous? (Please reply in a private message)
20:20:03 <Cale> __snake: hmm... anyway, you really ought to move the type sig. I'll try that.
20:20:17 <emertens> quick survey, a/s/l
20:20:23 <dons> ?vixen-on
20:20:23 <lambdabot> What's this channel about?
20:20:26 <dons> a/s/l
20:20:26 <lambdabot> 19/f/California
20:20:30 <dons> ?vixen-off
20:20:31 <lambdabot> Bye!
20:20:39 <Lemmih> @karma+ musasabi -- Cabal hacking.
20:20:39 <Adamant> quick survey, boxers or briefs
20:20:40 <lambdabot> musasabi's karma raised to 12.
20:20:47 <emertens> depends
20:20:49 <Adamant> just kidding
20:20:58 <Marudubshinki> am I correct in understanding that "fold" should refer to a family of higher order functions which includes foldl and foldr, and not just those two?
20:21:03 <LordBrain> meaning, they expected backward compatability to mean that what was fastest on the old computer is still fastest on the new one.. that way they can write fastest code for the whole intel family, rather than for a particular cpu in the family.
20:21:06 * dcoutts mumbles something about #haskell-blah
20:21:19 <Cale> __snake: the code works for me with -fglasgow-exts on
20:21:23 <syntaxfree> Not the right sample.
20:21:36 <dcoutts> LordBrain, which of course is a silly expectation
20:21:42 <dons> Marudubshinki: yes, that sounds reasonable
20:21:51 <LordBrain> *nods
20:21:51 <dons> we generally use fold = foldl, in Haskell
20:21:58 * Marudubshinki sighs in relief. finally got this straight!
20:22:08 <dons> :)
20:22:18 <Marudubshinki> you can't imagine the confusions I've endured trying to rectify some of the operator articles on Wikipedia
20:22:33 <Marudubshinki> I don't even want to think about what I'd have to do if there were already a reduce article
20:22:36 <emertens> foldtree f g a = aux where aux (Node r s) = f r $ foldr (g . aux) a s
20:22:47 <Cale> dons: not foldr?
20:22:52 <Marudubshinki> as it is, I can just redirect it to a fold article, and the foldl and foldr articles as well.
20:22:57 <Cale> foldr is way more natural
20:23:01 <emertens> I agree
20:23:17 <emertens> since it simply replaces the (:) and [] with the first two arguments
20:23:24 <Cale> yeah
20:23:41 <emertens> it's easy to explain to someone by writing the list out with conses
20:23:49 <emertens> and then changing them to some other operator
20:23:54 <Marudubshinki> btw, which fold was the one you can't use with infinite lists? foldl?
20:23:55 <dcoutts> and it generalises to other data types
20:23:55 <__snake> Cale: could you please through the piece of code that works in priv?
20:24:07 <Cale> Marudubshinki: right, foldl doesn't work with infinite lists
20:24:09 <dcoutts> foldl is peculuiar to lists
20:24:13 <dons> hmm. maybe yes. foldr . foldl is just a product of the list structure.
20:24:21 <Cale> __snake: the one you pasted
20:24:31 <Cale> __snake: I didn't edit it
20:24:41 <syntaxfree> @hoogle unfold
20:24:41 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
20:24:42 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
20:24:42 <lambdabot> Data.Tree.unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
20:24:42 <emertens> I prefer to think of "fold"ing as "dragging"
20:24:59 <dons> i think of it as reducing :)
20:25:21 <Cale> I tend to think of folding as replacing the parts of the datatype with other functions.
20:25:23 <syntaxfree> > unfoldr (+1) 1
20:25:24 <lambdabot>    Occurs check: cannot construct the infinite type: b = Maybe (a, b)
20:25:24 <lambdabot>    ...
20:25:33 <Cale> Though that means that foldl isn't quite really a fold :)
20:25:37 <syntaxfree> What does unfoldr do?
20:25:44 <Cale> @type unfoldr
20:25:45 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
20:25:56 <dcoutts> musasabi, looks good, so what needs to be done with the parser?
20:26:05 <emertens> I just don't like suggesting that it generates a less complicated result than the list that generated it
20:26:27 <syntaxfree> I think of folds as a generalization of sum and product.
20:26:32 <syntaxfree> sum = foldl1 (+)
20:26:34 <emertens> foldr (:) [] [1,2,3]
20:26:41 <emertens> > foldr (:) [] [1,2,3]
20:26:41 <Cale> unfoldr f x = case f x of Nothing -> []; Just (u,y) -> u : unfoldr f y
20:26:42 <lambdabot>  [1,2,3]
20:27:17 <musasabi> dcoutts: 1) it needs to combine --enable-foo with --enable-foo (for foo and !foo to work), and 2) the package(...) syntax does not seem to work.
20:27:20 <syntaxfree> You could always think of folds as looping constructs.
20:27:37 <musasabi> dcoutts: I can see to that later, but need to sleep first.
20:27:40 <emertens> > unfoldr (\x -> guard (x < 10) >> return (x,x+1)) 0
20:27:41 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
20:27:41 <Cale> That's not so natural if you're folding a tree.
20:27:59 <emertens> foldtree Node (:) []
20:28:15 <dcoutts> musasabi, the other use case is Win32/Posix one, would that map to a configuration of win32 or !win32? it'd be annoying for users to have to specify that manually. hmm.
20:28:35 <dcoutts> musasabi, yes, sleep is good :-)
20:29:04 <Cale> data Tree a = Nil | Branch a (Tree a) (Tree a); foldTree n b Nil = n; foldTree n b (Branch x u v) = b x (foldTree n b u) (foldTree n b v)
20:29:44 <__snake> Cale: any ideas why it might not work for me (besides mistakes in my DNA)?
20:30:12 <Cale> __snake: are you sure you're passing -fglasgow-exts as a commandline parameter to the compiler?
20:30:19 <Cale> __snake: what error are you getting?
20:30:54 <syntaxfree> http://www.haskell.org/haskellwiki/Monads_as_Containers
20:30:55 <lambdabot> Title: Monads as Containers - HaskellWiki
20:31:02 <musasabi> dcoutts: I think one could juse use to os(win32) and !os(win32). But the parser needs the fixes.
20:31:03 <syntaxfree> great article. I finally understand monads.
20:31:07 <Cale> syntaxfree: :)
20:31:15 <__snake> Numeric.hs:52:12:
20:31:15 <__snake>     Couldn't match `Vector' against `Double'
20:31:15 <__snake>       Expected type: Vector
20:31:15 <__snake>       Inferred type: Double
20:31:15 <__snake>     In the second argument of `(/)', namely `n'
20:31:25 <dcoutts> musasabi, right
20:31:29 <Marudubshinki> (if anyone has a spare minute, I'd appreciate you going over http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29 )
20:31:39 <Cale> __snake: yeah, that would be because you're applying division with a vector and a double
20:31:39 <__snake> numeric: Mother.hs Numeric.hs
20:31:39 <__snake>         ghc  -fglasgow-exts --make  Numeric.hs -o numeric
20:31:45 <Cale> __snake: so fix that
20:32:09 <monochrom> "generally ... list" is not very generally.
20:32:18 <__snake> Cale: but that's exactly what I want - to divide vector by a double
20:32:27 <emertens> don't call it /
20:32:42 <emertens> call it scaleVector or something :)
20:32:51 <Cale> or ./
20:33:21 <monochrom> When you begin with "fold is a family of HOFs", I expect it is a "family" because you will be talking about many folds, one for lists, one for trees, ...  and then you let me down.
20:33:23 <syntaxfree> Marudubshinki: not all functional languages deal with infinite lists.
20:33:35 <syntaxfree> Marudubshinki:  you might have meant lazy languages there.
20:33:42 <Marudubshinki> syntaxfree: ah. good point.
20:33:53 <emertens> not all languages that allow lazy lists are functional :)
20:34:00 <Marudubshinki> hmm. are there any lazily evaluated non-functional languages?
20:34:06 <Marudubshinki> er, what emertens said
20:34:08 <monochrom> So, either you stick with lists and say "fold is one HOF" and don't mention "generally"; or you truely generalize.
20:34:23 <__snake> Cale: but GSL Haskell is not my package, I'm just trying to use it...
20:34:38 <Cale> __snake: hm?
20:34:57 <LordBrain> Marudubshinki: you can make lazy lists in scheme, they are not the default... and are often called streams there i have noticed.
20:35:01 <emertens> "Toshiba has what kids need to succeed, like laptops with finger-print scanners for security"
20:35:08 <__snake> Cale: you said that I shouldn't use (/)
20:35:32 <Cale> __snake: right, because its type is (Fractional a) => a -> a -> a
20:35:37 <Cale> @type (/)
20:35:38 <lambdabot> forall a. (Fractional a) => a -> a -> a
20:35:40 <Marudubshinki> LordBrain: really? interesting. does scheme use iteration to decide how much of the stream to generate or both iteration and recursion?
20:35:57 <__snake> Cale: GSL Haskell overloads it
20:36:01 <emertens> Does scheme know what iteration is?
20:36:18 <Marudubshinki> emertens: I'm faily sure it has some loop constructs, doesn't it?
20:36:18 <Cale> __snake: oh, so it's not the one from the Prelude?
20:36:23 <Cale> __snake: then I don't know
20:36:33 * Marudubshinki is none too familiar with scheme. I'm better with CL, but that's still not saying much
20:36:38 <emertens> Marudubshinki: recursion is a loop construct
20:36:46 <__snake> Cale: http://dis.um.es/~alberto/GSLHaskell/doc/
20:36:50 <Cale> __snake: make sure that you're loading the right libs
20:37:51 <Cale> __snake: I don't see a new definition of / in those docs
20:38:05 <LordBrain> Marudubshinki: i dont think i understand your question... scheme generally uses recursion to express iteratation
20:38:09 <__snake> Vectors and matrices admit the operators in the Num and Floating classes in the element by element sense:
20:38:30 <syntaxfree> Recursion is a loop  construct?
20:38:31 <__snake> Cale: http://dis.um.es/~alberto/GSLHaskell/doc/GSL-Base.html
20:38:33 <syntaxfree> What is a loop construct?
20:38:41 <dons> syntaxfree: recursion is _the_ loop construct
20:38:42 <emertens> __snake: the type signature of the function is
20:38:56 <emertens> a -> a -> a, the arguments and result have to have the same type
20:39:03 <__snake> Cale: Why oh why somebody may need to divide vector by vector element by element :(
20:39:04 <Marudubshinki> LordBrain: I think what I was asking was how one dealt with streams - did one specify a specific number of numbers or whatever to be generated or did it continue generating until a condition was met?
20:39:36 <Cale> __snake: does scalar multiplication work?
20:39:43 <LordBrain> Marudubshinki: no, they are true lazy lists... you generate only on an as-need basis, this way you can have infinite lists in scheme.
20:39:56 <Marudubshinki> LordBrain: neat.
20:40:02 <emertens> syntaxfree: I'm saying that recursion can be used to perform loops is all
20:40:15 <Cale> __snake: it might be that they defined Vector as an instance of Num with fromInteger being n |-> (n,n,n,...,n)
20:40:16 <LordBrain> Marudubshinki: they have keywords for constructing them, force and delay
20:40:23 <emertens> that's all.... i might have used the wrong phrase
20:40:25 <Cale> __snake: and pointwise multiplication
20:40:27 <syntaxfree> I thought recursion was used to " perform" induction.
20:40:39 <Marudubshinki> LordBrain: no need to ask what force and delay do. :)
20:40:45 <Cale> __snake: in which case you can't really multiply a Vector by a Float or something
20:40:53 <Cale> you have to use another Vector
20:41:06 <emertens> syntaxfree: if we throw enough out there, someone is sure to correct one of us :)
20:42:01 <Cale> __snake: try applying realToFrac to the Double on the right
20:42:09 <Cale> __snake: and see if that fixes things
20:42:17 <LordBrain> Marudubshinki: the only disadvantage is they are not as pretty.... you cant simply say things like x = 1:x to your interpretter, even if it is what you have in mind.
20:42:42 <Marudubshinki> LordBrain: well, I suppose one has to pay *some* price
20:43:00 <emertens> for what advantage?
20:43:09 <LordBrain> Marudubshinki: so it becomes a matter of taste, do we prefer a langauge that is strict by default that can be made lazy, or one that is lazy by default and can be made strict?
20:43:17 <Marudubshinki> emertens: infinite streams in a non-lazy language if I'm understanding LordBrain right
20:43:38 * Marudubshinki looks at http://www.cs.nott.ac.uk/~gmh/bib.html#semantics  <-- oh christ, there's an "unfold" operator too? how the hell does that work?
20:43:40 <lambdabot> Title: Graham Hutton: Publications
20:43:50 <syntaxfree> some language are not "purely" lazy but can have lazy behaviours, from what I gather.
20:44:02 <Cale> The answer to LordBrain's hypothetical question is of course that we prefer a lazy by default language ;)
20:44:08 <LordBrain> :)
20:44:26 <LordBrain> thats to be expected from people in this room Cale, but try the same question in #scheme
20:44:27 <emertens> @google rhetorical
20:44:30 <lambdabot> http://www.uky.edu/AS/Classics/rhetoric.html
20:44:30 <lambdabot> Title: Kentucky Classics
20:44:39 <emertens> not what I wanted :)
20:44:52 <Marudubshinki> LordBrain: well, there you get into advantages and disadvantages. AFAIK, disadvantages is "hard to reason about space and time usage" and maybe "hard to do IO"? I don't know any others. :(
20:45:14 <LordBrain> hmmmmm
20:45:49 <emertens> syntaxfree: ahh, dons cleared out the loop construct thing already, and I didn't see it:
20:46:03 <emertens> ?last recursion is _the
20:46:04 <lambdabot> I haven't got any logs for that channel.
20:46:10 <emertens> ?last #haskell recursion is _the
20:46:10 <lambdabot> log module failed: IRCRaised Prelude.read: no parse
20:46:16 <emertens> :-/
20:46:16 <__snake> Cale: YES! this helps, thanks!
20:46:20 <emertens> oh well
20:46:32 <LordBrain> if you have to construct a lazy list in order to have it, you at least become conscious as to when it is better to have one..... maybe thats a bonus to people who learn scheme and then haskell..
20:47:03 <Korollary> I have a principle objection to call-by-value. I don't understand why something should be evaluated if not needed. 'Performance' seems to be the wrong reason.
20:47:04 <Cale> Well, you can get the same benefit in reverse :)
20:47:07 <LordBrain> i'm not really sure...
20:47:11 <LordBrain> yeah
20:47:36 <emertens> Korollary: you don't know if it's needed
20:47:40 <emertens> Korollary: there can be side-effects
20:47:46 <Cale> If you have to optimise a Haskell program, you start finding places where occasionally strict would be better (generally in structure-collapsing folds)
20:48:02 <emertens> deepSeq is a probably yes in Haskell'
20:48:20 <emertens> and that relates to that need if I understand correctly...
20:48:59 <Cale> Basically, the places where strictness is preferred is in cases where you have some large structure or expression with lots of separately evaluatable components, and you want to reduce it to a small structure, one with few separately evaluatable pieces.
20:49:17 <Cale> In all other cases, laziness is equivalent or preferred.
20:49:36 <emertens> that behavior is one of the reasons that Clean is doing better than Haskell in the shootout, i believe
20:49:48 <dons> they have a packed IO library too
20:49:52 <emertens> ah
20:50:09 <emertens> at a glance, Clean code looks like Haskell with arrows :)
20:50:30 <Marudubshinki> has anyone here heard of the inverse of folds, "unfold"? I've found a few academic papers, but they are as clear as mud and I can't tell whether anyone actually uses it.
20:50:37 <dons> ?type unfoldr
20:50:38 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
20:50:40 <dons> ?karma unfoldr
20:50:41 <lambdabot> unfoldr has a karma of 3
20:50:45 <emertens> lol
20:50:46 <dons> we love unfoldr!
20:51:02 <LordBrain> we can karma functions?
20:51:06 <emertens> I made this example earlier
20:51:08 <emertens> >  unfoldr (\x -> guard (x < 10) >> return (x,x+1)) 0
20:51:09 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
20:51:32 <emertens> and since I really just got a grip on guard last night, I decided to include it
20:51:47 <Marudubshinki> emertens: er... what does that do?
20:51:54 <emertens> unfoldr generates a list
20:52:12 <emertens> it applies the starting value (0) to the function over and over
20:52:14 <Marudubshinki> -_- that makes sense.
20:52:23 <emertens> if the function returns two values
20:52:27 <Cale> The other way around :)
20:52:29 <emertens> it adds the right value to the list
20:52:33 <Stinger_> it doesnt apply the functio.. yeah
20:52:39 <emertens> and repeats with the left value
20:52:42 <Stinger_> the other way around
20:52:45 <emertens> if Nothing is returned, it stops
20:53:15 <emertens> sorry, repeats with the right value
20:53:46 <emertens> (\x -> if x < 10 then Just (x,x+1) else Nothing) 1
20:53:51 <emertens> > (\x -> if x < 10 then Just (x,x+1) else Nothing) 1
20:53:52 <lambdabot>  Just (1,2)
20:54:06 <emertens> so.. it adds the 1 to the end of the list and repeats that function on the 2
20:54:11 <emertens> > (\x -> if x < 10 then Just (x,x+1) else Nothing) 10
20:54:13 <lambdabot>  Nothing
20:54:18 <emertens> so it stops generating the list
20:54:33 <LordBrain> ?karma haskell
20:54:34 <lambdabot> haskell has a karma of 2
20:54:39 <LordBrain> hmm
20:54:43 <LordBrain> ?karma Haskell
20:54:43 <lambdabot> Haskell has a karma of 6
20:54:46 <emertens> lol
20:54:51 <emertens> ?karma emertens
20:54:51 <lambdabot> You have a karma of 2
20:55:04 <emertens> I've got as much karma as haskell does :)
20:55:22 <Marudubshinki> ?karma Marudubshinki
20:55:22 <lambdabot> You have a karma of 0
20:55:25 <LordBrain> ?karma LordBrain
20:55:26 <lambdabot> You have a karma of 1
20:55:29 <LordBrain> aw
20:55:31 <Marudubshinki> nya
20:55:31 <LordBrain> hehehe
20:55:35 <emertens> ?karma lambdabot
20:55:35 <lambdabot> lambdabot has a karma of 18
20:55:40 <emertens> damn ;)
20:55:54 <Marudubshinki> still, I think my head now hurts. night everyone
20:55:59 <emertens> ?karma+ lambdabot
20:55:59 <lambdabot> lambdabot's karma raised to 19.
20:56:27 <emertens> I like that someone is writing about folds... but he seems like the wrong guy to do it
20:57:40 <Cale> The thing about unfoldr is that it's almost always clearer to use iterate and takeWhile.
20:58:02 <dons> or replicate
20:58:16 <Cale> replicate?
20:58:38 <LordBrain> > replicate 4 'a'
20:58:39 <lambdabot>  "aaaa"
20:58:48 <emertens> i think that Cale knows what replicate does
20:58:56 <LordBrain> *shrugs*
20:59:01 <dons> just thinking of a case in yi where I used to have an unfold for packed strings, but switched to replicate
20:59:06 <Cale> ah
20:59:14 <emertens> i think that unfoldr is useful when the outputs can't be figured out from what generates that output well
21:00:28 <emertens> in that case I suppose a map over an iterate would work well
21:00:49 <monochrom> unfoldr is a while loop that produces. of course it is most useful when there is no easy way (other than unfolding) to tell how many iterations it will take.
21:01:45 <monochrom> Example: binary search over an array, but you have to output the list of all elements you looked at, not just the answer.
21:02:07 <Cale> iterate f = unfoldr (Just . ap (,) f)
21:02:09 <LordBrain> yeah
21:02:30 <emertens> @type ap (,)
21:02:32 <lambdabot> forall a a1. (a1 -> a) -> a1 -> (a1, a)
21:02:48 <Cale> > ap (,) (+1) 16
21:02:49 <lambdabot>  (16,17)
21:02:56 <emertens> why does *that* work
21:03:01 <emertens> @type ap
21:03:03 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
21:03:05 <Cale> Reader monad :)
21:03:13 <emertens> dirty... ;)
21:03:19 <emertens> in a sexy way
21:03:27 <Cale> heh
21:03:41 <Cale> It's a nice trick to remember
21:03:49 <Cale> good for producing index/value pairs
21:03:58 <emertens> @pl \f x -> (x,f x)
21:03:59 <lambdabot> ap (,)
21:04:24 <emertens> good for making sure people don't know wtf is going on ;)
21:04:26 <Cale> the other one to keep in mind is that  join f x = f x x
21:04:35 <Cale> so,
21:04:38 <emertens> that one seems to not work a lot of the time
21:04:39 <Cale> > join (,) 5
21:04:40 <lambdabot>  (5,5)
21:04:50 <Cale> > join (*) 5
21:04:51 <lambdabot>  25
21:05:07 <Cale> You need to import Control.Monad.Reader
21:05:12 <monochrom> Why do you subject us to this torture? :)
21:05:19 <Cale> but this really *ought* to be in the prelude :)
21:05:34 <dons> well, its in base now, at least
21:05:38 <dons> Control.Monad.Instances
21:05:40 <Cale> oh?
21:05:41 <Cale> ah
21:05:55 <monochrom> This is very sick!
21:06:02 <Cale> sick?
21:06:08 <emertens> @type join ap
21:06:09 <dons> the -> a was really underappreciated, I think
21:06:09 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
21:06:10 <lambdabot>    Expected type: m (a -> b) -> m (a -> b) -> a1
21:06:15 <dons> until we started playing with it here
21:06:22 <monochrom> One man's sick is another man's slick.
21:06:45 <Cale> (->) a gives you a bunch of combinators that have been used for a long time by other names
21:06:58 <emertens> @type Reader
21:06:59 <lambdabot> forall a r. (r -> a) -> Reader r a
21:07:02 <dons> yep.
21:07:02 <emertens> @type (->)
21:07:03 <lambdabot> parse error on input `->'
21:07:27 <emertens> oh, I guess Reader is the constructor?
21:07:32 <Cale> like ap is just S.
21:07:34 <Cale> yeah
21:07:53 <Cale> It's actually not Reader itself, but a monad equivalent to reader
21:07:58 <emertens> ah
21:08:19 <Cale> instance Monad ((->) e)
21:08:42 <Cale> which, if sections were allowed at the type level could be written
21:08:46 <Cale> instance Monad (e ->)
21:08:58 <dons> ?remember Cale ... if sections were allowed at the type level ...
21:08:58 <lambdabot> Done.
21:09:12 <Cale> heh, why is that memorable? :)
21:09:32 <emertens> @quote dons
21:09:32 <lambdabot>   its like you can really see the guy's brain melting
21:09:41 <emertens> @quote Cale
21:09:41 <lambdabot>  ... if sections were allowed at the type level ...
21:09:47 <Cale> hehe
21:10:20 <emertens> @type join
21:10:21 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
21:10:23 <Cale> I swear @quote does not choose quotes randomly, but in some mysteriously intelligent fashion.
21:10:32 <dons> i want sections in rewrite rules, actually. came up yesterday
21:10:47 <Cale> Once we add enough quotes to the database, we'll be able to communicate with it.
21:10:49 <dons> Cale, hehe. you're seeing patterns, but there aren't any ;)
21:11:01 <monochrom> @quote Cale
21:11:01 <lambdabot>  The perfect programming language is mathematics, but that only runs on mathematicians.
21:11:11 <monochrom> @quote monochrom
21:11:11 <lambdabot> monochrom hasn't said anything memorable
21:11:29 <emertens> burn!
21:11:37 <monochrom> @quote emertens
21:11:38 <lambdabot> emertens hasn't said anything memorable
21:12:04 <dons> ?quote
21:12:05 <lambdabot> jrmole says: any program that could read minds would just evolve into a porn downloader
21:12:11 <dons> ?quote
21:12:11 <lambdabot> HavocPennington says: Haskell is the least-broken programming language available today.
21:13:32 <emertens> Wow... Leno's guest has absolutely nothing interesting to talk about
21:13:43 <emertens> Just a pretty face
21:13:58 <emertens> she's forcing Jay to tell lame jokes and stories
21:14:34 <Cale> http://www.marriedtothesea.com/080806/ahoooyyyyyyyyy.gif
21:17:38 <emertens> is that from your mud? they are moving up from text only to static graphics? ;)
21:18:29 <kpreid> dons?
21:19:24 <emertens> Is there some explaination for those "comics"
21:19:39 <dons> kpreid?
21:19:48 <kpreid> I have an annoyingly vague bug report
21:20:12 <dons> oh, goody :)
21:20:13 <emertens> You'll have to wait until after Sept (3?) like the rest of us
21:20:30 <kpreid> namely, I was building lambdabot, and found that the build process would stop immediately after ghc produced a 'warning'
21:20:37 <dons> yes.
21:20:40 <dons> since it uses -Werror
21:20:45 <kpreid> so I didn't realize that it hadn't just finished, and wondered why my changes weren't taking effect
21:21:00 <dons> you can remove -Werror from the cabal file
21:21:29 <kpreid> so, complaint #1: ghc didn't say it's quitting on -Werror; #2: lambdabot build doesn't say it's quitting (e.g. make does)
21:21:41 <Cale> emertens: no, it's just a strange webcomic
21:21:54 <Cale> emertens: they're often sort of nonsensical like that
21:21:57 <kpreid> hm, cabal, so both of these things have nothing to do with lambdabot in particular. oh well.
21:22:00 <emertens> well... i was joking about the mud, but wtf, i looked through  afew
21:22:01 <dons> kpreid: well. hmm. is that a bug? :)
21:22:14 <dons> anyway, now you know about -Werror.
21:22:20 <emertens> dons, I can't run ghci on OpenBSD
21:22:22 <emertens> ;)
21:22:27 <kpreid> well, I figured it was something of the sort
21:22:33 <dons> emertens: so I've heard rumoured.
21:22:36 <dons> I can though :)
21:22:43 <kpreid> but at the time I had no information that told me it wasn't successful
21:22:52 <dons> yeah. that's a bit annoying.
21:22:54 <emertens> but I've got a fresh tar.bz2 extracted if you wanted to tell me what to try sometime ;)
21:23:00 <dons> maybe we should check exit status in ./build ?
21:23:05 <dons> or set -o e ?
21:23:07 <kpreid> YEAH!!!
21:23:30 <dons> kpreid: want to add both those then, to ./build and darcs send me a patch?
21:23:39 <kpreid> ...er, um...
21:23:49 <kpreid> OK, I'll replace the todo item reminding me to tell you about this!
21:24:18 <kpreid> done
21:24:30 <kpreid> I'll stop bothering you now
21:24:55 <dons> patches are good :)
21:26:26 <dons> totally OT, mm. nicer than an ipod, http://www.advancedmp3players.co.uk/shop/product_info.php?products_id=1493&usersessid=166271ad3f65d0a8b756c7e600c2dcc1
21:26:29 <lambdabot> Title: Advanced MP3 Players - Mcody M20 2GB MP3 Player
21:38:47 <stepcut> dons: http://www.surpluscomputers.com/store/main.aspx?p=ItemDetail&item=CES11167
21:38:50 <lambdabot> Title: Error
21:39:06 <stepcut> *way* nicer than an ipod
21:39:23 <dons> heh!
21:39:58 <emertens> as I prefer apple computers, I like how my ipod ties in well to my computers
21:40:08 <dons> it shouldn't have to tie though.
21:40:24 <dons> its just a filesystem, after all.
21:40:26 <SamB_XP> you should be able to just plug it in
21:40:29 <emertens> an portable audio device would have to have some pretty compelling features for me to want to switch
21:40:52 <SamB_XP> not have to tie and untie bothersome knots
21:41:02 <pstickne> dons, but then who's specification for directory layout will we use? :)
21:41:02 <emertens> it also helps that the iPod was free
21:41:18 <SamB_XP> pstickne: how about the user's?
21:41:19 <pstickne> dons, what about features such as playlists and smart playlists?
21:41:32 <dons> shrug.
21:41:36 <SamB_XP> textfiles!
21:41:38 <dons> yeah
21:41:40 <SamB_XP> with simple formats
21:41:45 <stepcut> .m3u .pls etc :)
21:41:46 <emertens> there would have to be some really compelling features for me to replace a free iPod with anything else
21:41:48 <SamB_XP> maybe sorta-proprietary
21:41:52 <emertens> (which is why they give them away)
21:42:00 <SamB_XP> but if its a textfile it isn't *really* proprietary
21:42:02 <pstickne> well, that's all iPod does now. only of course they are using whatever format it uses instead.
21:42:05 <dons> emertens: they're giving them away now?
21:42:10 <emertens> dons: to students
21:42:17 <emertens> dons: with the purchase of a computer :)
21:42:19 <dons> oh, at some funny universities?
21:42:25 <emertens> no
21:42:27 <dons> oh, with the purchase of a mac?
21:42:29 <pstickne> and the directory structure is defined and used in their iTunes and iPod software *shrug*
21:42:31 <dons> in the states?
21:42:34 <emertens> yeah
21:42:38 <lispy> yeah, i could have gotten one "free" with mail in rebate...so i said "hell no"
21:42:53 <emertens> the rebate came back really fast for me
21:42:56 <lispy> perhaps apple is honest about rebates, but i avoid the mail in kind on principle...
21:42:57 <pstickne> lispy, mail in rebates aren't bad .. if you get them :))
21:43:04 <dons> having to use gtkpod to get stuff on and off my gf's ipod is annoying. (though at least its doable)
21:43:22 <lispy> every mail in rebate i've sent off for i never got...and there went my proof of purchase with it
21:43:27 <emertens> gtkpod, that sounds like something a linux luser might use ;)
21:43:35 <lispy> dons: i've heard amarok is much better than gtkpod
21:43:36 <pstickne> dons, it really no different then Media Player and MP-compatible devices, except that it's different software.
21:43:37 <dons> a bsd user
21:43:59 <emertens> dons: as your workstation?
21:44:05 <SamB_XP> emertens: any sort of *nix user that isn't running the Candy OS
21:44:14 <dons> $ uname
21:44:14 <dons> OpenBSD
21:44:16 <lispy> dons: linux sauvy friend of mine has all manner of issues with gtkpod...but apparently amarok is mostly seamless
21:44:32 <emertens> We've been over this already, but I use OpenBSD for some stuff, but I use it from OS X
21:44:32 <dons> oh ok. i'll check it out
21:45:28 <dons> yeah, i've only got openbsd running here. so having non-proprietary access to devices is important
21:45:58 <dons> lambdabot feels the same way
21:46:10 <SamB_XP> lambdabot is able to use iPod now?
21:46:17 <emertens> ?playlist
21:46:17 <lambdabot> Unknown command, try @list
21:46:20 <SamB_XP> heh
21:46:23 <emertens> ;)
21:46:29 <emertens> ?nowplaying
21:46:29 <lambdabot> Unknown command, try @list
21:46:34 <dons> i should run lambdabot on my gf's ipod. though secretly i want to run hmp3
21:46:37 <SamB_XP> @list play
21:46:38 <lambdabot> No module "play" loaded
21:46:38 <lispy> ?play random queen
21:46:38 <lambdabot> Maybe you meant: pl slap
21:47:04 <lispy> ?slap lispy
21:47:05 * lambdabot beats up lispy
21:47:07 <SamB_XP> @slap lispy, dons, and emertens
21:47:07 * lambdabot beats up lispy, dons, and emertens
21:47:23 <lispy> @slap exon for excessive profits
21:47:24 <dons> lambdabot is a very aggressive person
21:47:24 * lambdabot slaps exon for excessive profits
21:47:40 <SamB_XP> @slap exxon for excessive profits
21:47:41 <lambdabot> why on earth would I slap exxon for excessive profits
21:47:46 <stepcut> :p
21:47:54 <SamB_XP> heh
21:48:11 <SamB_XP> so how do you cancel the normal response?
21:48:14 <stepcut> big oil has bought out everyone
21:48:20 <SamB_XP> @slap exxon for excessive profits
21:48:21 * lambdabot slaps exxon for excessive profits
21:48:35 <stepcut> slap randomly picks 1 of 4 responses
21:48:40 <SamB_XP> oh
21:48:58 <SamB_XP> @hit me!
21:49:00 <lambdabot> No match for "me!".
21:49:09 <SamB_XP> what does "hit" do?
21:49:23 <lispy> they had a net profit of like 99 billion this quarter or some crap
21:49:29 <lispy> it's just ridiculous how much they are making
21:49:49 <stepcut> lispy: yeah, let's drill for oil in my backyard -- we're going to be rich!
21:50:08 <pstickne> lispy, wow, that's like a 8x increase over their last "record high" last quarter O.o
21:50:27 <pstickne> lispy, I bet the CEO is getting a good bonus.
21:50:39 <pstickne> lispy, and of course we'll see no change on pump gas prices :)
21:51:41 <lispy> yup
21:51:47 <dons> you'll see a change. upwards
21:51:55 <SamB_XP> I was just going to say
21:52:21 <emertens> that's how a closed market on an essential commodity works...
21:52:45 <lispy> they should make our gas tax like the ones found in europe..as a percent of the price instead of a percent of the volume...then people would be really annoyed at the prices
21:52:56 <SamB_XP> we must all learn to unicycle
21:53:10 <emertens> medical bills are higher than gas bills
21:53:29 <SamB_XP> we should all learn to tough it out
21:53:45 <lispy> i say we change the freeways to have a electric hook up and then switch people to electric cars...the batteries take you on "short range" travel off the freeways and  you get a "free ride" on the freeway
21:54:01 <SamB_XP> okay, so maybe bicycling is safer
21:54:17 <lispy> i passed 3 different cyclist today when i was jogging :)
21:54:36 <emertens> were they sitting down?
21:54:38 <stepcut> lispy: were you going the opposite direction?
21:54:41 <dons> heh
21:54:42 <SamB_XP> you jog fast or they are extremely skilled at slow biking?
21:54:59 <emertens> yeah... at a certain point you aren't "jogging"
21:55:13 * lispy was definitely jogging
21:55:20 <lispy> these cyclists were going very slow
21:55:30 <SamB_XP> you'd think it would be easier to go faster
21:55:35 <lispy> i had to get down off the side walk and pass them in the bike lane :)
21:55:37 <emertens> did you show them how to shift as you passed them?
21:55:46 <lispy> lol
21:56:30 <SamB_XP> heh
21:56:49 <emertens> if my neighbors aren't going to have the decency to stop slamming their doors around at midnight
21:56:56 <emertens> I'm turning my subwoofer back up
21:57:04 <lispy> "slamming doors"
21:57:10 <lispy> "moving furniture"
21:57:16 <lispy> newly weds eh?
21:57:34 <SamB_XP> uh, some people actually slam door
21:57:37 <SamB_XP> er, doors
21:58:07 * SamB_XP better go to bed
21:58:16 <emertens> "go to bed"
21:58:19 <emertens> newly wed
21:58:46 <SamB_XP> no, it is just that it is an hour past midnight and I have a really exciting book too
21:59:31 <syntaxfree> um.
21:59:47 <syntaxfree> map f list = list >>= (\x->[f x])
21:59:48 <syntaxfree> ?
22:01:04 <emertens> what are you asking
22:01:18 <emertens> in the [] monad, >>= is concatMap
22:01:37 <emertens> > concatMap (\x -> [x+1]) [1..4]
22:01:38 <lambdabot>  [2,3,4,5]
22:01:55 <emertens> > [1..4] >>= (\x -> [x+1])
22:01:56 <lambdabot>  [2,3,4,5]
22:02:03 <syntaxfree> > [1..4] >>= (\x->[x+1])
22:02:04 <lambdabot>  [2,3,4,5]
22:02:06 <SamB_XP> you know, (\x -> [f x]) = return . f
22:02:17 <lispy> > (\x -> [x+1]) `concatMap` [1..4]
22:02:19 <syntaxfree> umm.
22:02:19 <lambdabot>  [2,3,4,5]
22:02:26 <syntaxfree> > [1..4] >>= return . (+1)
22:02:28 <lambdabot>  [2,3,4,5]
22:02:58 <lispy> good thing we have so many ways to express that
22:02:59 <syntaxfree> coo.
22:03:21 <syntaxfree> > [x+1 | x<-[1..4]]
22:03:22 <lambdabot>  [2,3,4,5]
22:03:41 <emertens> > return (+1) `ap` [1..4]
22:03:42 <lambdabot>  [2,3,4,5]
22:03:53 <syntaxfree> @type ap
22:03:54 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
22:04:05 <syntaxfree> ap is like reverse liftM?
22:04:16 <emertens> [(+1),(+2)] `ap` [1..4]
22:04:21 <emertens> > [(+1),(+2)] `ap` [1..4]
22:04:22 <lambdabot>  [2,3,4,5,3,4,5,6]
22:04:25 <emertens> ap is sweet
22:04:53 <syntaxfree> umm.
22:04:53 <emertens> liftM on lists is just map
22:05:04 <emertens> liftM (+1) [1..4]
22:05:09 <emertens> > liftM (+1) [1..4]
22:05:11 <lambdabot>  [2,3,4,5]
22:05:20 <syntaxfree> > [\x->x+y | y<-[1..10]]  `ap` [1..10]
22:05:22 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9,10,11,12,4,5,6,7,8,9,10,11,12,13,5,6,7,...
22:05:27 <lispy> > fmap (+1) [1..4]
22:05:28 <lambdabot>  [2,3,4,5]
22:05:30 <syntaxfree> now there is something.
22:05:46 <lispy> is everything on lists just map in disguise?
22:05:47 <syntaxfree> @type liftM
22:05:48 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
22:05:51 <syntaxfree> @type ap
22:05:52 <lispy> well, map or sequence
22:05:53 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
22:06:43 <emertens> > join (liftM2 (+)) [1..4]
22:06:44 <lambdabot>  [2,3,4,5,3,4,5,6,4,5,6,7,5,6,7,8]
22:07:09 <syntaxfree> what's the definition of liftM2?
22:07:27 <syntaxfree> @pl \f xs->xs>>= (return . f )
22:07:27 <lambdabot> fmap
22:08:26 <syntaxfree> umm.
22:08:38 <syntaxfree> > [1,2,3,4] >>= (\x->x)
22:08:39 <lambdabot>  add an instance declaration for (Num [b])
22:08:39 <lambdabot>   In the list element: 4
22:08:50 <syntaxfree> > [[1,2,3,4]]>>=(\x->x)
22:08:51 <lambdabot>  [1,2,3,4]
22:09:13 <emertens> [[1,2],[3,4]] >>= id
22:09:16 <emertens> > [[1,2],[3,4]] >>= id
22:09:17 <lambdabot>  [1,2,3,4]
22:09:29 <syntaxfree> @type id
22:09:29 <lispy> fmap == liftM
22:09:30 <lambdabot> forall a. a -> a
22:09:31 <emertens> concatMap id = concat
22:09:45 <syntaxfree> fmap == liftM for lists, or for every monad?
22:10:07 <emertens> i think for every...
22:10:11 <ski> every, yes
22:10:11 <user317> i cant find any documentation on c2hs syntax, does anyone know if any exists?
22:10:50 <ski> @type liftM2
22:10:51 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
22:11:11 <syntaxfree> so liftM is just a fancier name for fmap?
22:11:18 <syntaxfree> @pl liftM
22:11:19 <lambdabot> fmap
22:11:34 <ski> liftM2 f ma mb = ma >>= \a -> mb >>= \b -> return (f a b)
22:11:53 <ski> liftM2 f ma mb = return f `ap` ma `ap` mb
22:12:05 <emertens> one is for Functors, one is for Monads, but Monads are functors and functors are monads...
22:12:17 <ski> not all functors are monads
22:12:19 <emertens> errr
22:12:20 <emertens> yeah
22:12:26 <emertens> you beat me to it :)
22:12:33 <ski> all monads are (mathematically speaking) functors
22:12:38 <syntaxfree> @type fmap
22:12:39 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
22:12:43 <syntaxfree> oh, ok.
22:13:03 <emertens> @instances-importing Functor
22:13:04 <lambdabot> ((->) r), Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
22:13:08 <emertens> @instances-importing Monad
22:13:09 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
22:13:12 <ski> but for technical reasons, haskell currently doesn't require instances of 'Monad' to be instances of 'Functor'
22:13:15 <syntaxfree> apparently a monad is a functor with some operations.
22:13:22 <ski> hence 'liftM' additionally to 'fmap'
22:13:26 <ski> yes
22:13:50 <emertens> I believe that Cale said that ArrowMonad's not being a functor was an oversight
22:14:00 <ski> there are two common ways of expressing a monad
22:14:20 <emertens> monad's used to require functor, b ut they removed that restriction
22:14:28 <emertens> so that if you were oging to define a monad
22:14:32 <emertens> and not use the functor functions
22:14:33 <dons> ski, for technical reasons?
22:14:34 <ski> I) a monad 'm' is a functor (i.e. it has an 'fmap', (with two laws))
22:14:42 <emertens> you wouldn't have to define those functions
22:15:05 <ski>   with the additionall operations
22:15:08 <dons> note that in Haskell 1.2 we had class Functor m => Monad m where
22:15:10 <ski>    return :: a -> m a
22:15:17 <dons> so I presume technical reasons == error messages
22:15:20 <ski>    join :: m (m a) -> m a
22:15:38 <emertens> bind = join . fmap
22:15:47 <emertens> err
22:15:55 <emertens> (join .) . fmap?
22:16:24 <ski> dons : afaiu, we'd really want to get a default implementation of 'fmap' for monad instances, but the default system doesn't handle this
22:16:33 <emertens> > ((join .) . fmap) (\x -> [x + 1]) [1..4]
22:16:34 <lambdabot>  [2,3,4,5]
22:16:58 <emertens> > (>>=) (\x -> [x + 1]) [1..4]
22:16:59 <lambdabot>  Couldn't match `[a] -> a -> b' against `[a1]'
22:17:08 <ski> flip
22:17:24 <ski> (or '(=<<)')
22:17:28 <emertens> well sure, if you are just going ot shout out the answer, you'll beat me to typing it in
22:17:32 <emertens> :)
22:17:46 <dons> ski, oh hmm. hadn't thought of that. yes.  that's a good reason too
22:18:18 <dons> yeah, they had no default in haskell 1.2
22:18:26 <dons> any anyway,
22:18:26 <dons> class Functor f where
22:18:27 <dons>     map :: (a -> b) -> (f a -> f b)
22:18:28 <dons> :)
22:18:47 <ski> yes, i thought 'wow', when i saw that in old prelude :)
22:18:57 <edwardk_afk> ski: ?
22:19:03 * edwardk_afk is curious
22:19:08 <ski> edwardk_afk : sorry ?
22:19:11 <dons> http://www.cse.unsw.edu.au/~dons/data/cc.prelude
22:19:13 <emertens> because it was map instead of fmap?
22:19:19 <ski> yes
22:19:20 <edwardk_afk> ah
22:19:27 <emertens> I don't like that the more general version has a longer name
22:19:34 <dons> and things like:
22:19:35 <edwardk_afk> yeah i agree
22:19:35 <dons> filter           :: Monad0 m => (a -> Bool) -> m a -> m a
22:19:36 <dons> filter p xs       = [ x | x<-xs, p x ]
22:19:39 <ski> (but, i understand the reasoning for 'fmap')
22:19:45 <dons> bring on the monad comprehensions!
22:19:57 <edwardk_afk> heh I kinda like Monad0
22:19:58 <edwardk_afk> =)
22:20:02 <emertens> @type filter
22:20:03 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
22:20:22 <emertens> @hoogle (a -> Bool) -> m a -> m a
22:20:23 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
22:20:40 <edwardk_afk> Eq a, Text a => Num a is a little weird
22:20:44 <dons> losing monad comprehensions seems like a mistake.
22:20:51 <ski> yes, think i'd like a 'MonadZero' back (plus somthing like 'MonadPlus' and 'MonadElse')
22:21:05 <emertens> yeah... according to "History of Haskell" they did it ot make the language easier for newcomers
22:21:14 <dons> emertens: right.
22:21:15 <emertens> which seems counter to the rest of Haskell
22:21:17 <ski> (same as with 'fmap' vs. 'map', i think)
22:21:22 <dons> but now we give them GADTs without caring.
22:21:28 <edwardk_afk> I like Functor m => Monad m a lot
22:21:38 <edwardk_afk> it always bugs me the other way
22:21:41 <emertens> time for ghc to re-adopt monad comprehensions... ;)
22:21:44 <edwardk_afk> where Functor is disconnected
22:21:48 <edwardk_afk> yeah
22:21:59 <dons> and in comparison, monad comprehensions seem easy, compared to some of the type hackery we get up to now
22:22:04 <syntaxfree> it's weird that they actually remove language features.
22:22:16 <emertens> because they are "hard"
22:22:41 <edwardk_afk> I like the functor left, functor right => adjoint too
22:22:55 <dons> maybe we should really bring back moand comprehensions. just with -fglasgow-exts would be ok
22:23:37 <edwardk_afk> yeah. i looked at the desugaring bit, it should be possible there are two paths through the code, one doesn't do MUCH.
22:23:48 <ski> syntaxfree : anyway, one formulation of the monad concept says that is is a functor (with 'fmap'), together with additional 'return' and 'join', the other formulation says that it has a 'return' and a 'bind' (aka '(>>=)', or in converse form as 'extend' or '\f -> f^*')
22:23:48 <edwardk_afk> so it could be gutted to yield comprehensions
22:23:54 <edwardk_afk> the other is setup for fusion
22:24:22 <ski> edwardk_afk : adjoint ?
22:25:13 <edwardk_afk> class (Functor left, Functor right) => Adjoint left right where { unit... univ... counit... couniv... }
22:25:14 * ski has ideas about a "monadic reflection" syntax
22:25:42 <edwardk_afk> and they had a Natural transformation class
22:25:59 <edwardk_afk> class (Functor f, Functor g) => NatTransf f g where eta :: f a -> g a
22:26:00 <ski> edwardk_afk : ok .. i've seen that called 'adjunction' or 'adjoit situation', i think
22:26:04 <ski> yuck!
22:26:23 <edwardk_afk> well makes sense for adjoint functors
22:26:24 <ski> why should there be a canonical natural transformation between two functors ?
22:26:58 <emertens> > let filter' p xs = do { a <- xs; guard (p a); return a } in filter (<3) [1..4]
22:26:59 <lambdabot>  [1,2]
22:27:01 <emertens> > let filter' p xs = do { a <- xs; guard (p a); return a } in filter' (<3) [1..4]
22:27:02 <dons> who says there's a canonical one ?
22:27:02 <lambdabot>  [1,2]
22:27:03 <edwardk_afk> i will concur that that one seems a little strange
22:27:07 <dons> that's the issue.
22:27:14 <edwardk_afk> because you can't set up multiple nattrans
22:27:16 <ski> dons : 'eta' singles a certain out
22:27:19 <dons> i've needed this class thoug. its useful
22:27:25 <edwardk_afk> yeah
22:27:39 <ski> edwardk_afk : exactly
22:27:58 <emertens> it's neat that: do { a <- xs; guard (p a); return a} is so close to [a | a <- xs; p a]
22:27:59 <dons> yeah, its no huge loss. but its an interesting class that people should be aware of
22:28:00 <Cale> ski: What's wrong with singling one out? :)
22:28:11 <ski> dons : you couldn't pass it around explicitely ?
22:28:26 <ski> Cale : what when you want to use another one in the same context ?
22:28:27 <dons> i use it for magic model checking in Data.ByteString
22:28:34 <dons> there's nat trans from ByteString <-> String
22:28:54 <Cale> ski: well, obviously, they're just polymorphic functions, so you can still use others
22:29:00 <ski> if you call it something more specific than 'NatTransf', i don't mind
22:29:02 <edwardk_afk> i like mapl and mapr on Monad as well
22:29:09 <Cale> The only advantage of using a class is to single out one that you like
22:29:13 <emertens> @type mapl
22:29:14 <lambdabot> Not in scope: `mapl'
22:29:23 <dons> instance NatTrans [] []             where eta = id
22:29:29 <dons> instance NatTrans ((->) W) ((->) W) where eta = id
22:29:36 <dons> instance Model f g => NatTrans ((,) f) ((,) g) where eta (f,a) = (model f, a)
22:29:39 <edwardk_afk> mapl             :: Monad m => (a -> m b) -> ([a] -> m [b]);mapr             :: Monad m => (a -> m b) -> ([a] -> m [b])
22:29:43 <dons> instance (NatTrans m n, Model a b) => Model (m a) (n b) where model x = fmap model (eta x)
22:29:47 <dons> :)
22:30:09 <ski> Cale : but then you have to much around with 'newtype', if you want to use a different one
22:30:22 <emertens> > let filter' p xs = do { a <- xs; guard (p a); return a } in filter' (<3) (Just 2)
22:30:23 <lambdabot>  Just 2
22:30:44 <Cale> ski: well, yeah, or you just pass it around explicitly
22:30:57 <edwardk_afk> though wonders if that should be modified somewhat to use a monad transformer and abstract away the [] portion
22:30:58 <emertens> > filterM (<3) (Just 2) -- ?
22:30:58 <lambdabot>  Couldn't match `m Bool' against `Bool'
22:31:05 <emertens> oh
22:31:14 <Cale> ski: But it's rather like how you can't hame more than one instance of Monoid
22:31:18 <Cale> have*
22:31:25 <ski> (Cale : not if lib code wants it as instance ..)
22:31:32 <ski> yes, it's a similar issue
22:31:48 <ski> (or 'Ord' for that matter)
22:31:50 <emertens> I've used filterM to write my implementation of Kruskal's algorithm :-)
22:34:05 <Cale> ski: In this case, having a special natural transformation between two types is often all right.
22:34:26 <Cale> Like for what dons used it for, it seems quite acceptable
22:34:34 <syntaxfree> oh wow. Haskell is really something at times.
22:34:43 <Cale> syntaxfree: what?
22:34:46 <edwardk_afk> syn: ?
22:34:59 <syntaxfree> it seems it'll take me years to learn it all.
22:35:12 <dons> i'm not sure you can learn it all
22:35:16 <dons> since its growing
22:35:26 <syntaxfree> sometimes it seems that by the time someone actually figures it all,  he's Philip Wadler.
22:35:41 <edwardk_afk> heh
22:35:45 <Cale> syntaxfree: Well, what does "Haskell" include?
22:36:17 <Cale> It's certainly possible to learn what features are implemented in GHC -- maybe becoming masterful with them all is a bit much.
22:36:25 <emertens> "Haskell" = Haskell98 + research extentions?
22:36:28 <dons> and understanding deeply all aspects.
22:36:37 <edwardk_afk> wadler seems to have have made some evolutionary leap into the form of an xpath programmer. i'm sure we'll all understand the motivation in 10 years or something
22:36:41 <syntaxfree> I guess I'm thinking more about the theoretical underpinnings.
22:36:42 <Cale> You can certainly grasp the report.
22:36:48 <Cale> That only takes a couple of years.
22:36:58 <dons> just things like the effect of seq on the compiler, which you'd think we'd have down, still pops us new results
22:37:03 <emertens> "xpath programmer"?
22:37:23 <dons> like the breakage to build/foldr that came up recently.
22:37:29 <edwardk_afk> he works on xpath/xquery type stuff these days doesn't he?
22:37:59 <syntaxfree> it's reallty weird for me, because I'm not a programmer. By now, Haskell is just about the only language I really know.
22:38:08 <edwardk_afk> yeah, coz they aren't safe in the face of pointed computations.
22:38:26 <edwardk_afk> thats why we need substructural types here, so we can say oh, that can't be pointed. =)
22:47:37 <dons> ?uptime
22:47:38 <lambdabot> uptime: 3 days, 19 hours, 43 minutes and 13 seconds
22:48:52 <Korollary> I believe there's some amount of junk in current research, which we won't be using in five years. So, it's not that important to know every bit of detail.
22:49:17 <dons> i'd hope so
22:49:31 <Korollary> In fact, HR departments of almost all companies would contend that it's not important to know any of it.
22:49:40 <dons> heh
22:49:56 <xerox> G'day.
22:50:13 <Korollary> Ciao!
22:50:14 <dons> ?localtime xerox
22:50:18 <lambdabot> Local time for xerox is Thu Aug 10 06:49:53 2006
22:50:26 <dons> rise and shine!
22:51:17 <ski> Cale : if it's a specific use, it should have a specific name describing that use
22:58:42 * edwardk_afk takes the opposite point of view and kind of throws himself at minutiae, fitting it into what little context he has. Its not very efficient through. =)
22:59:15 <Korollary> It'll probably wane after a while.
22:59:22 <edwardk_afk> Right now I'm kind of enjoying being neck deep in Haskell.
22:59:35 <edwardk_afk> Well, I've been doing it for the last 22 years.
22:59:52 <Korollary> Ah. Then maybe you're a language lawyer.
23:00:25 <edwardk_afk> Ever since I lied and told a friend in gradeschool that I had written an assembler in c64 basic and used it to write an assember in assembly and then had to make good on the claim =)
23:00:46 <Korollary> You could have just asked for forgiveness
23:00:52 <edwardk_afk> not really in my nature =)
23:01:07 <Korollary> I enjoy being satan at times.
23:01:30 <dons> ?remember Korollary I enjoy being satan at times
23:01:30 <edwardk_afk> the end result was that by the next time i saw him, I had, so you could say it spurned an awful lot of learning for a 7 year old
23:01:30 <lambdabot> Done.
23:01:34 <edwardk_afk> er spurred
23:01:59 * edwardk_afk does math. wow getting old. thats going on 24 years now
23:02:59 <satan> huh? who enjoys being me? wtf
23:03:01 <satan> poseurs
23:03:12 <edwardk_afk> heh
23:03:17 <satan> :)
23:03:31 <edwardk_afk> I admit I learned much of computer science that way in my early years.
23:07:35 <xerox> ?quote TimToady
23:07:36 <lambdabot>  learning Haskell itself is easy--I've done it several times already
23:07:46 <edwardk> heh
23:07:55 <piggybox> lol
23:09:55 <Korollary> d00d, in gradeschool you didn't need to speak nonsense like that. High school? Maybe. But grade school?
23:11:18 <edwardk> was the crowd i was dealing with at the time
23:11:20 <edwardk> *shrug*
23:11:25 <edwardk> worked out well in retrospect
23:11:47 <edwardk> probably would have been disasterous had I ever not managed to make good on one of those claims though
23:11:55 <Korollary> wow
23:13:02 <edwardk> trying to find one of the old compute's gazette articles this spree led to =)
23:13:48 <Korollary> I called a kid in highschool on his claims to have broken into a bank via his c64.
23:13:57 * edwardk wound up using that aforementioned assembler/disassembler to read through the basic rom, the kernel rom, and then the 1541 diskdrive rom
23:14:17 <edwardk> I used that to figure out ways to speed up the diskdrive, by techniques that in retrospect were barely stable.
23:14:51 <edwardk> in fact I would never use them now, since they aren't stable. they just worked because of the rigidity of the clock and how tightly synchronized the cpus were on the main unit and disk drive.
23:15:49 <Korollary> I had a 1541-II
23:16:51 * edwardk had lots of commodore hardware.
23:17:03 <edwardk> I basically used the money from the magazine articles to buy more hardware
23:17:11 <Korollary> The only other thing I had was a reset switch
23:17:23 <Korollary> well, and a few broken joysticks
23:17:42 <edwardk> in retrospect I kind of wish I had moved away from commodore earlier, but it worked out
23:17:57 <Korollary> poke 53281,0
23:18:42 * edwardk cleaned out his mom's attic a few months back and found a bunch of old commodores
23:18:57 * edwardk watches the channel go black
23:19:28 <Korollary> 1Mhz is nothing to sneeze at... literally.
23:19:43 <edwardk> well, you could do the jump to 2 mhz if you blanked the screen
23:20:02 <edwardk> and since you could time the vertical retrace, you could turn it on ONLY during the vertical retrace and steal a good fraction of a mhz =)
23:20:31 * edwardk abused that for the disk stuff
23:20:46 <Korollary> I suppose that why the de-crunchers used to blank
23:20:56 <edwardk> it was enough that you could take the 1541 out of the mode it used to talk to the c64 and put it back in the faster vc-20 mode
23:21:15 <edwardk> because the 1541 is a 1540 slowed down so it can talk to the c64 which is slower coz it has to refresh more ram
23:21:27 * edwardk is surprised this is still archived in his brain.
23:22:17 <edwardk> basically the neatest thing to me about the c64 was that the disk drive had its own 6502. it was just as powerful as the main computer
23:22:27 <Korollary> whoa. I didnt know that.
23:22:30 <edwardk> in fact, slightly faster, just only had 1.25k of ram available to it as buffers =(
23:23:11 <dons> so no ghc then?
23:23:16 <edwardk> but the same cpu doubling trick works there since there IS no screen to blank, so you can do some serious bit churning there
23:23:18 <edwardk> fraid not =)
23:23:22 <Korollary> No C, iirc
23:23:50 <edwardk> you basically had to fit whatever you wanted in 2-3 of those buffers and get enough of a performance boost from that code to justify the loss of buffer space
23:24:30 <edwardk> i wound up using that, abusing the assumption there was nothing else on the 9-pin serial din connector, and used the data, device selection and clock bits all to send data.
23:24:35 <edwardk> which of course wasn't stable.
23:24:42 <edwardk> but it seemed to work
23:25:29 <Korollary> Those were the days. Elegance meant squat :)
23:25:48 <edwardk> between that and only reading  one of the two copies from disk, and accelerating the cpu on both sides, it made a hefty speed increase in disk access.
23:26:19 <edwardk> oh, and a cheesy what-now-in-retrospect looks like a poor man's huffman coding for common basic bytecodes
23:26:20 <edwardk> =)
23:26:40 <edwardk> couldn't fit a huffman code in the space i had, so i guess, i must have hit a sweet spot
23:27:12 <edwardk> in fact, you couldn't do much of anything robustly in the space available, so the fact that it worked at all can basically be chalked up to a happy accident
23:27:22 <edwardk> and the obsession of an 8 year old
23:28:35 <Korollary> lol
23:28:38 <Korollary> oh man
23:29:08 <Korollary> Geraldo Rivera talking trash about Jon Stewart/Stephen Colber on O'Reilly
23:29:27 <edwardk> i wrote a vt100 emulator for the c64 so i could get on the bbss of the day. ever tried to read a 3x7 bit font? =)
23:29:35 <edwardk> oh?
23:31:10 <Korollary> that's a no win situation
23:31:11 <emertens> @hoogle even
23:31:12 <lambdabot> Prelude.even :: Integral a => a -> Bool
23:31:12 <lambdabot> GHC.ConsoleHandler.ConsoleEvent :: data ConsoleEvent
23:31:12 <lambdabot> System.Console.Readline.setEventHook :: Maybe (IO ()) -> IO ()
23:31:42 <Stinger_> sorry edwardk when did you do all this?
23:32:10 <edwardk> would be 84-89 or so
23:32:23 <Stinger_> you were how old?
23:32:39 <edwardk> 8-13 by the end i think of my commodore phase
23:33:03 <Stinger_> crazy : /
23:33:36 <Korollary> a 'disturbed' childhood ;)
23:33:41 <edwardk> heh, i didn't know squat about comp sci though. sad in retrospect. since i learned programming by how the commodore roms were put together =)
23:33:46 <edwardk> whats a variable? =0
23:33:59 <edwardk> scribble in memory over here, got what i want... =)
23:40:07 <Korollary> I remember wanting to sort some numbers, and not being able to invent even bubblesort on my own. No little Gauss, there.
23:40:54 <xerox> Korollary: I always had an HARD time with permutations/combinations/whatnot.
23:40:59 <edwardk> heh i remember discovering how to permute a list of numbers and being all happy about it =)
23:41:05 <xerox> ...
23:41:23 <edwardk> a little problem that at the time was the first time i encountered something i couldn't brute force and had to think about
23:41:46 <edwardk> finding all the 1 digit numers times 4 digit numbers that yield 5 digit answers using 0-9 each once.
23:42:17 <xerox> Numbers put me off.
23:42:21 <edwardk> couldn't brute force it at the time, so it was probably the first time i had to think about a problem
23:42:31 <edwardk> at least one of 'algorithmic' flavor
23:43:13 <edwardk> i still remember that there are 2 ambiguous solutions depending on if you let the lead digit of the 5 digit number be 0
23:43:52 <edwardk> that also has the dubious honor of being the first program i wrote in pascal, now that i think about it
23:48:32 <xerox> > length $ filter (uncurry (&&) . ((all ((1==) . length) . group . sort) &&& ((5==) . length)) . show . fst) [(x*y,(x,y)) | x <- [0..9], y <- [0..9999]]
23:48:33 <lambdabot>  19112
23:50:46 <emertens> You'll probably want to clarify that with a name :)
23:51:41 <xerox> "ed's problem"
23:53:58 <edwardk> ?
23:54:08 <edwardk> ah
23:54:42 <edwardk> so, where is the whole list? =)
23:54:51 <xerox> After '$' :D
23:55:22 <edwardk> answers in the  form x * yyyy = zzzzz would bring back a lot of nostalgia =)
23:55:37 <xerox> > filter (uncurry (&&) . ((all ((1==) . length) . group . sort) &&& ((5==) . length)) . show . fst) [(x*y,(x,y)) | x <- [0..9], y <- [0..9999]]
23:55:38 <lambdabot>  [(10234,(2,5117)),(10236,(2,5118)),(10238,(2,5119)),(10246,(2,5123)),(10248,...
23:55:41 <edwardk> ah
23:55:46 <xerox> Ehrm.
23:55:52 <emertens> > length $ filter ((==10) . length) $ map (group . sort . concatMap show) [[x,y,x*y] | x <- [0..9], y <- [0..9999]]
23:55:54 <lambdabot>  13
23:56:01 <edwardk> 2,5117?
23:56:05 <xerox> Woops.
23:56:07 <edwardk> 5119?
23:56:09 <edwardk> =)
23:56:31 <edwardk> the length of the list seems right though
23:56:53 <edwardk> vaguely recall it being 13 elements with allowed leading 0s, 11 without
23:57:01 <xerox> > all ((1==) . length) . group . sort . show $ 5112
23:57:02 <lambdabot>  False
23:57:05 <xerox> It should work...
23:57:50 <int-e> > nub "9348120" == "9348120"
23:57:51 <lambdabot>  True
23:57:52 <edwardk> i think you might ahve  over-folded that, having trouble mining that for useful information =)
23:58:05 <xerox> int-e: allright.
23:58:42 <int-e> Sorting is more efficient for long lists of course.
23:59:39 <xerox> Ah
23:59:49 <xerox> edwardk: can you restate the problem?
23:59:59 <xerox> I thought the result 5-digit-number should not have duplicate digits.
