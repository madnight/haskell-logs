00:00:36 <Korollary> @vixen Please empty your pockets before going through the metal detector.
00:00:36 <lambdabot> i like that type of music too
00:00:47 <Korollary> Not that kind you dufus
00:13:34 <dolio> Does anyone have any good solutions that they use for organizing pdfs/papers? I've downloaded a ton, and my method of dumping them in a vague directory hierarchy is becoming a bit unwieldy.
00:14:24 <pejo> dolio, www.citeulike.org
00:14:39 <therp> dolio: hm not really, same problem here. I try to change the pdf file names into the title of the papers. maybe I should look into beagle
00:15:48 <dolio> pejo: Hmm, interesting. Thanks.
00:16:03 <pejo> dolio, or just a big pile on your desk. :-)
00:16:29 <dolio> Heh.
00:28:53 <ValarQ> dons: i'm having some local lambdabot problems
00:29:11 <dons> yeah?
00:29:30 <ValarQ> dons: it just prints "Initialising plugins ......." and then exits with exitcode 1
00:29:41 <dons> remove State/seen
00:29:44 <dons> and try again
00:30:07 <ValarQ> yay, it works
00:30:11 <dons> :)
00:30:16 <ValarQ> how do i turn of a module?
00:30:22 <ValarQ> (or remove it)
00:30:31 <dons> remove it from the list in Modules.hs and recompile
00:30:55 <ValarQ> that was easy...
00:32:08 <ValarQ> and it works :)
00:32:14 <ValarQ> @karma+ dons
00:32:14 <lambdabot> dons's karma raised to 51.
00:32:41 <Pseudonym> Yikes, that's a lot of karma.
00:32:49 <ValarQ> sure is
00:32:51 <dons> ?karma-all
00:32:51 <lambdabot>  dons                   51
00:32:52 <lambdabot>  shapr                  21
00:32:52 <lambdabot>  xerox                  21
00:32:52 <lambdabot>  lambdabot              20
00:32:52 <lambdabot>  Lemmih                 19
00:32:52 <Pseudonym> You're coming back as something really awesome.
00:32:53 <lambdabot> [212 @more lines]
00:32:59 <dons> :S
00:33:01 <Pseudonym> @more
00:33:01 <lambdabot>  dcoutts                18
00:33:02 <lambdabot>  int-e                  14
00:33:02 <lambdabot>  Cale                   12
00:33:02 <lambdabot>  musasabi               12
00:33:03 <lambdabot>  SamB                   10
00:33:05 <lambdabot> [207 @more lines]
00:33:06 <ValarQ> @karma
00:33:10 <lambdabot> You have a karma of 1
00:33:13 <Pseudonym> @karma
00:33:13 <lambdabot> You have a karma of 3
00:33:13 <sieni> @karma
00:33:14 <lambdabot> You have a karma of 0
00:33:15 <sieni> @karma
00:33:16 <lambdabot> You have a karma of 0
00:33:18 <sieni> :-(
00:33:29 <Pseudonym> @karma+ sieni
00:33:29 <lambdabot> sieni's karma raised to 1.
00:33:30 <ValarQ> woohoo, positive karma :)
00:33:33 <Pseudonym> Happy now?
00:33:39 <sieni> ^_^
01:18:33 <Igloo> Morning JaffaCake
01:18:41 <JaffaCake> hi there
01:18:58 <JaffaCake> lovely day for hacking GHC :)
01:19:06 <mnislaih> hi JaffaCake
01:19:07 <Igloo> JaffaCake: Do xchg and friends in SMP.h need to be defined for all arches now, including unregisterised?
01:19:34 <JaffaCake> I've just been thinking about this
01:19:49 <JaffaCake> we'll probably need to be selective about which arches we support SMP on
01:20:23 <JaffaCake> currently SMP works properly on arches with full memory ordering guarantees, but AFAIK that only includes x86 and x86_64
01:20:41 <Igloo> Does SMP mean -threaded, or is it something else?
01:20:51 <JaffaCake> to support weaker memory ordering we need to implement a workaround  in the update code
01:21:06 <JaffaCake> SMP means -threaded with +RTS -N2 or greater
01:21:17 <Igloo> Ah, OK
01:21:49 <JaffaCake> so with +RTS -N1, it would be safe to use a non-atomic xchg() and cas() in SMP.h
01:23:46 <JaffaCake> would you like to sort this out?  we need to keep a list of arches that support SMP, the best place is probably in config.mk.in where we set GhcWithInterpreter and GhcWithNativeCodeGen
01:24:02 <JaffaCake> and then disable +RTS -N2 and greater if the arch doesn't support SMP
01:24:28 <JaffaCake> then we can provide fallback impls of cas() and xchg() for non-SMP-supporting builds
01:25:20 <JaffaCake> also the threaded2 way in the testsuite should only be enabled for SMP archs
01:26:06 <Igloo> OK
01:28:45 <pejo> JaffaCake, care to define what "full memory ordering" is?
01:30:03 <JaffaCake> pejo: from the application's perspective, all reads and writes appear to take place in the order they occur in the instruction steam, including reads and writes performed by other CPUs
01:37:44 <pejo> JaffaCake, are there data dependencies all over the place, or would a memory barrier in a couple of places do?
01:38:11 <JaffaCake> pejo: memory barriers tend to be expensive, we want to avoid them if possible
01:38:31 <JaffaCake> but yes, memory barriers are one workaround
01:39:08 <JaffaCake> pejo: see http://www.haskell.org/~simonmar/papers/multiproc.pdf
01:39:50 <pejo> Doh, should have realized and rtfa before commenting.
01:40:31 <JaffaCake> no problem :)
02:01:59 * dons is reminded how much cvs sucks
02:02:50 <sieni> as much as 1000 industrial-grade vacuum cleaners?
02:04:02 <profmakx> black hole?
02:04:30 <sieni> 10000 Russian prostitutes?
02:06:14 <ulfdoz> I could imagine russian prostitutes are comparably uncomplicated...
02:07:23 <profmakx> depends ulfdoz
02:12:21 <dons> ?userrs
02:12:22 <lambdabot> Maximum users seen in #haskell: 235, currently: 200 (85.1%)
02:15:25 --- topic: set to '' by ProfTeggy
02:15:34 <ProfTeggy> woops
02:15:42 <ProfTeggy> Sorry :-/
02:16:14 --- topic: set to '["Haskell Communities & Activities Report, 10th edition", "http://haskell.org/communities/", "Haskell.org SoC projects", "http://hackage.haskell.org/trac/summer-of-code/", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion", "The ICFP has ended. Who won?"]' by wolverian
02:16:29 <ProfTeggy> Thanks...
02:17:12 <wolverian> no problem
02:17:56 <nilsi> Hi there
02:19:23 <nilsi> what about <>  for function composition?  in my font  f<>g looks good
02:21:59 <nilsi> @botsnack
02:22:00 <lambdabot> :)
02:27:12 <nilsi> f <> g <> h  $  123
02:34:03 * benja_ prefers & currently
02:34:29 <benja_> f & g & h $ 123
02:35:17 <nilsi> but my one is like a circle somehow :-)
02:35:43 <benja_> yeah but it's harder to type and it's also like 'not equal' somehow :)
02:36:56 <benja_> actually, I wonder. I might even like `o`.
02:37:46 <nilsi> and you complain about typeability of <> ?  :)
02:38:17 <benja_> =)
02:38:29 <benja_> nilsi: no, lambdabot does:
02:38:33 <benja_> > concat . map
02:38:34 <lambdabot>    Expecting a function type, but found `b'
02:38:34 <lambdabot>    Expected type: (a1 -> b) ...
02:38:49 <benja_> see =)
02:39:33 <benja_> > concat . (map (+1))
02:39:34 <lambdabot>  add an instance declaration for (Num [a])
02:39:48 <nilsi> aha
02:39:56 <benja_> > concat . (map (++))
02:39:57 <lambdabot>    Expecting a function type, but found `b'
02:39:57 <lambdabot>    Expected type: [a1] -> [a...
02:40:05 <benja_> > concat . (map (++" "))
02:40:06 <lambdabot>  <[[Char]] -> [Char]>
02:40:11 <benja_> aha!
02:40:33 <benja_> nilsi: on the other hand, `o` doesn't need shift
02:40:59 <nilsi> not on an us keyboard, perhaps
02:41:19 <benja_> nilsi: not on a finnish keyboard either, as long as you use us layout =-]
02:41:53 <benja_> designing for typability on non-us keyboards is fighting a lost fight imho :-(
02:43:03 * benja_ uses the windows key as a mode key to switch to an international keyboard layout
02:43:56 <nilsi> i clearly think we should prefer readability  over  us-typability (being german using an us keyboard that is)
02:44:31 <benja_> so use `o` then =)
02:45:38 <nilsi> i do not find `o` readable, unfortunately,  let's keep  f.g
02:45:46 <benja_> =-)
02:46:17 <benja_> the problem, of course, is that it's so subjective
02:46:31 <benja_> that's why the haskell committe had its syntax czar :)
02:46:32 <nilsi> in R (statistical package)  the record syntax is   adress$name and i got used to it astonishingly fast
02:47:06 <nilsi> i like having a syntax czar, as long as I am the one :)
02:47:12 <benja_> :)
02:47:48 <nilsi> who needs semantics, if you can have syntax instead
02:48:19 <ibid> just use the ring operator :)
02:49:00 <benja_> there's always !@#$%^& when you get tired of having this discussion. :)
02:50:34 <benja_> the ring operator is *great* for readability. whenever by chance your system gets the encoding right and has the right font.
02:51:32 <benja_> how about `u_2218`
02:52:43 <ibid> encoding and font problems will disappear
02:52:50 <ibid> eventuall
02:52:51 <ibid> y
02:53:07 <benja_> ok, let's use the ring operator then
02:53:09 <benja_> eventually
02:53:14 <benja_> ;)
02:53:27 <nilsi> let's have another discussion: is optimistic evaluation compatible with jhc's RTS  ?  IMHO Haskell needs a compiler that makes unoptimized code fast, not "comonadic-dependant-algebraic-types" one phd is not enough to understand
02:53:59 <nilsi> encoding problems will disappear in 50 years or later I think
02:54:58 <benja_> wp doesn't know what optimistic evaluation is :-/
02:55:14 <nilsi> wp?
02:55:30 <benja_> wikipedia
02:57:16 <nilsi> basically it is something like speculative evaluation of lazy computations, using a runtime profiler to prevent programs that actually need laziness from becoming to slow
02:58:19 <nilsi> http://www.cambridge.intel-research.net/~rennals/talk_opt.pdf
02:59:17 <nilsi> for me it is the only option to get haskell into mainstream
03:00:16 <norpan> i'm not sure i want haskell into mainstream
03:00:19 <benja_> you think haskell's *not* doomed to succeed? :)
03:00:54 <norpan> sidestream is slower and more comfortable
03:01:30 <nilsi> no, it is just not bad enough for mainstream yet - so propose additions
03:01:53 <norpan> we NEED introspection
03:02:05 <norpan> and multi-class inheritance
03:02:20 <norpan> and macros. MACROS"!
03:02:54 <benja_> and casting
03:02:55 <dons> we need JOBS!
03:03:10 <benja_> dons: I don't think we can get him
03:03:26 <eivuokko> Heh
03:03:31 <dons> he
03:03:36 <nilsi> hehe
03:04:26 <profmakx> what about imperative features? this darned functional style -.-
03:04:30 <profmakx> oh wait
03:04:34 <ibid> we need a uniform syntax such as parentesized prefix notation... er ...
03:04:39 <sieni> I thought haskell macros go by the name "template haskell"
03:05:36 <nilsi> we should forbid a function to call itself
03:05:49 <benja_> ha!
03:05:56 <gour> is this haskell-2.x discussion?
03:05:56 <profmakx> yeah, recursion causes bubbles in your brain -.-
03:06:03 <profmakx> mope
03:06:09 <profmakx> its haskell 2015
03:06:15 <benja_> nilsi: that'll make it mainstream *and* ensure termination for all programs!
03:06:22 <benja_> theory *and* practice!
03:06:28 <ibid> and the damned garbage collector slows everything down ... just use new and delete!
03:06:38 <gour> profmakx: ahh, good. i though i'd have to re-learn many things
03:06:47 <benja_>  itself
03:06:47 <benja_> 13:04 < benja_> ha!
03:06:47 <benja_> 13:04 < gour> is this haskell-2.x discussion?
03:06:52 <benja_> argh
03:07:00 <benja_> I should stop playing with the mouse pad
03:07:24 <norpan> hmmmm, where are you
03:07:26 <norpan> eastern europe?
03:07:39 <profmakx> i need global variables... i¥m just reviewing code which is full of them
03:07:40 <norpan> finland?
03:07:45 <nilsi> we need a better industrial name like Jaskell 2 Starwars Edition
03:07:46 <gour> norpan: i'm from croatia
03:07:51 <norpan> hey, nice
03:08:12 <ibid> and then there is the matter of lack of segfaults. A LANGUAGE CANNOT SURVIVE WITHOUT SEGFAULTS! THE SAFETY PEOPLE HAVE CORRUPTED OUR PRECIOUS BODILY FLUIDS!!!!!!!!!!
03:08:38 <norpan> ibid: you can get segfaults with foreign import
03:08:44 <psnl> owah, put the brakes on the negativity express
03:09:05 <gour> we need haskell IDE
03:09:16 <profmakx> psnl, i am really depressed by this code im reviewing right now
03:09:18 <nilsi> the "unsafe" word is the problem, change it to "useful"  usefullPerformIO
03:09:19 <psnl> gour: thats a good suggestion
03:09:36 <ibid> norpan: and do you expect a five-day wonder to learn foreign import
03:09:47 <ibid> ?
03:09:50 <ibid> DO YOU?
03:09:51 <psnl> profmakx: I know what you mean
03:09:51 <ibid> :)
03:09:54 <sieni> just send SEGV to your Haskell program. Problem solved.
03:10:01 <norpan> you can teach them to import Segfault and use Segfault.segfault
03:10:06 <gour> psnl: hIDE needs some help (from experienced guys)
03:10:08 <profmakx> SIGKILL me now
03:10:45 <nilsi> is there a inline assembler yet?
03:10:48 <ibid> hm. we need a SIGHASKELL
03:10:52 <benja_> Haskell only supports monadic segfaults
03:10:58 <ibid> (not kidding this time)
03:11:26 <psnl> gour: I'll take a look when I have time
03:11:33 <ibid> benja_: damn, i need ternary segfaults. are you saying haskell cannot deliver?
03:11:51 <benja_> although there's discussion about using arrows to pinpoint blame for segfaults in haskell'
03:12:09 <norpan> we need gdb support for haskell
03:12:15 <gour> psnl: thanks. i'd also like to join after i learn something more. still didn't finish that craft of fp book :-( many distractions on the road
03:12:19 <benja_> ibid: there's usefulPerformIO segfault
03:12:30 <ibid> benja_: that's ternary?
03:12:32 <norpan> unsafePerformSegfault
03:12:35 <Lemmih> norpan: Seen mnislaih code?
03:12:37 <gour> norpan: what about debugger for ghci from gsoc project?
03:12:53 <nilsi> no need to wonder why mainstream ignores us  *sigh*
03:12:56 <benja_> ibid: no unary, but you can use currying
03:13:03 <ibid> hm
03:13:27 <norpan> Lemmih, gour: no
03:13:29 <mnislaih> @where Ghci.Debugger
03:13:29 <lambdabot> http://haskell.org/haskellwiki/Ghci/Debugger
03:13:51 <ibid> why do we have only unsafePerformIO? i want safelyPerformIO that does what i want even if i say it wrnog!
03:14:05 <benja_> ^ hm, someone from Bielefeld
03:14:31 <ibid> wrong too
03:14:46 <sieni> ibid: We already have safelyPerformIO; it's called 'id'.
03:15:14 <nilsi> ah the name is to short
03:15:28 <nilsi> it is overlooked
03:15:36 <ibid> sieni: it doesn't typecheck
03:15:53 <benja_> ibid: that's what makes it safe
03:16:16 * gour downloads the video
03:16:28 <gour> mnislaih: did you use some video editor?
03:16:31 <nilsi> can you switch off the typechecker to improve compiling?  :)
03:16:37 <ibid> benja_: i wonder i just almost started writing "we want information, information, information... you won't get it!"
03:16:56 <ibid> +why
03:17:22 <ibid> (by hook or by crook we will)
03:17:35 <ibid> well. time for me to start reading this thesis here...
03:17:51 <benja_> you still haven't? :-o
03:17:55 <benja_> energize! :)
03:18:45 <ibid> :)
03:32:26 <nilsi> I like this paper:   http://delivery.acm.org/10.1145/1120000/1111563/p121-luca.pdf?key1=1111563&key2=0452426511&coll=&dl=ACM&CFID=15151515&CFTOKEN=6184618
03:32:52 <nilsi> Title: Program Transformation by Solving Recurrences
04:04:46 <psnl> anyone know where you get unregistered .hc files for ghc?
04:06:53 <sieni> the gghdrms (the glorious glasgow haskell digital restrictions management system) prevents you from using unregistered .hc files
04:06:59 <sieni> (just kidding)
04:08:31 <psnl> oh, other meaning of unregistered
04:11:03 <Igloo> psnl: unregister*is*ed
04:11:07 <Igloo> psnl: What are you trying to do?
04:11:54 <psnl> Igloo: build ghc on an sprace box running openbsd
04:12:11 <psnl> sparc, even
04:12:52 <Igloo> You need to follow http://www.haskell.org/ghc/docs/latest/html/building/sec-porting-ghc.html#unregisterised-porting then
04:12:53 <lambdabot> Title: 10. Porting GHC
04:13:36 <psnl> Igloo: are you suggesting cross compiling?
04:14:21 <Igloo> It's not exactly cross-compiling. You generate .hc files on a machine with ghc, copy them to the sparc/openbsd machine and compile them there
04:14:38 <psnl> ok, cool
04:15:26 <Igloo> psnl: Oh, and where it says "make boot UseStage1=YES", you need to do "make boot UseStage1=YES EXTRA_HC_OPTS='-O -fvia-C -keep-hc-files'"
04:23:15 <audreyt> Igloo: just saw the announcement. congrats! :)
04:25:22 <Igloo> thanks  :-)
04:25:51 <audreyt> JohnMeacham: would it make sense to have a frisby-bytestring port?
04:28:15 <JohnMeacham> audreyt: well, lazyness is one of its selling points. but PEGs are so expressive, I can't imagine not wanting to use them always, they subsume pretty much everything else. :) I would like more feedback on the API and algorithms before I commit to an interface, but it will probably look more or less like it does now.
04:30:00 <audreyt> well, there's ByteString.Lazy
04:30:13 <JohnMeacham> audreyt: I sort of want to try extending yi with a syntax highlighter based on it, because it wouldn't just know syntax, it would be able to do a full parse, and fast, and PEGs are very good at dealing with errors and recovering gracefully, so you could highlight just the parse errors in red or something.
04:30:27 <audreyt> yeah. I've written a wiki parser in packrat
04:30:46 <JohnMeacham> using 'pappy'?
04:30:49 <audreyt> yup
04:30:53 <JohnMeacham> cool.
04:30:54 <audreyt> actually no, its monadic equiv
04:31:32 <audreyt> at that time I remember I've pined for a commit" primitive
04:31:43 <audreyt> that blocks its rhs // from backtracking
04:31:52 <audreyt> I understand there's no speed penalty for backtracking
04:31:59 <audreyt> but sometimes I'd like it not to
04:50:10 <JohnMeacham> audreyt: ? it never backtracks, just do a &foo to test whatever you want, then go for it.
04:51:17 <JohnMeacham> I guess it depends on how you look at it in a sense, but looking into the future is different in that it can skip over stuff, and there are multiple potential futures.
04:51:41 <JohnMeacham> or you can do // return 'x' to have it stop and return x.
04:51:56 <JohnMeacham> or // unit 'x' in frisby actually.
04:55:30 <JohnMeacham> like, expressions can end in // unit 'invalid expression'  to make expressions always parse, embedding error messages within the syntax tree.
05:08:29 <Oejet> @karma+ dcoutts
05:08:30 <lambdabot> dcoutts's karma raised to 19.
05:08:54 <Oejet> Gtk2Hs is fun to use!
05:09:19 <kolmodin> @karma kolmodin
05:09:19 <lambdabot> You have a karma of 0
05:09:22 <kolmodin> argh!
05:09:23 <kolmodin> :)
05:09:42 <ValarQ> @karma+ kolpudding
05:09:43 <lambdabot> kolpudding's karma raised to 1.
05:09:48 <kolmodin> hah :)
05:09:51 <ValarQ> ops, miss
05:10:54 * gour sees kolmodin is liberated - no karma
05:21:23 <audreyt> JohnMeacham: sorry. I mean possesitve quantifiers
05:21:27 <audreyt> like \d++ in regex
05:21:39 <audreyt> i.e. a "many1" that does not give anything back
05:21:53 <audreyt> equiv to the parsec "many1"
05:22:10 <audreyt> such that /\d++\d/ never matches
05:22:44 <audreyt> how would you write such a many1 in frisby?
05:22:57 <musasabi> notFollowedBy or somesuch?
05:23:27 <kpreid> audreyt: what regex system does "++"?
05:23:34 <audreyt> kpreid: pcre, among other places
05:23:36 <audreyt> perl5 too
05:23:39 <kpreid> huh
05:23:49 <kpreid> never seen it before
05:23:52 <audreyt> in perl5 it's called (?>\d+)
05:23:56 <audreyt> but essentially same thing
05:24:02 <kpreid> er...then that's not the same thing
05:24:12 <audreyt> how is it not?
05:24:21 <audreyt> it's the same underlying semantics, that is.
05:24:26 <kpreid> sorry, clarification: I was asking about the particular syntax, not the behavior
05:24:38 <audreyt> oh ok. sorry. then yes, pcre-based ones.
05:25:29 <audreyt> musasabi: many1 x `notFollowedby` x ?
05:25:54 <musasabi> something like that, if I understand correctly what you want.
05:26:10 <audreyt> in frisby I guess it's spelled peek . doesNotMatch
05:26:18 <audreyt> but yeah. hm.
05:26:51 <audreyt> the analogy fails on \d{2,3}+ though
05:27:18 <dons> psnl, there should already be binaries for ghc on sparc/openbsd
05:27:21 <dons> at least for ghc 6.2.2
05:27:25 <audreyt> though that can be decomposed into two subparsers
05:27:33 <dons> and there's already some .hc files for you
05:28:38 <dons> psnl: ah , here, .hc files for 6.2.1, ftp://ftp.cse.unsw.edu.au/pub/users/dons/ghc/6.2.1/
05:29:03 <audreyt> JohnMeacham: state. the reason I used packret's monads is that it allows userdefined state
05:29:15 <audreyt> that threads through the parse
05:29:30 <audreyt> I understand each "modify" will duplicate the linear cache space
05:29:52 <audreyt> but is it possible for P to carry userState in addition to the existential s?
05:40:41 <dons> mmm! 'Formalising a High-Performance Microkernel written in Haskell, using Isabelle/HOL'
05:40:54 <dons> yay performance
05:41:01 <psnl> dons: ooh
05:41:59 <dons> psnl: yeah , ghc/sparc was working on openbsd till recently. if you check the package archives, you might find a binary (otherwise building from .hc should be possible)
05:42:13 <psnl> dons: thanks
05:46:20 <dons> ?where house
05:46:21 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
05:48:39 <roconnor> oh wow, house is under development!
05:50:24 <dons> some papers, http://haskell.org/haskellwiki/Research_papers/Program_development#Operating_Systems
05:50:26 <lambdabot> Title: Research papers/Program development - HaskellWiki
05:50:39 <boegel> cool :)
05:53:47 <dylan> "Composing the User Interface with Haggis" gives me very strange mental images
05:54:15 <gour> :-)
05:54:25 <dons> heh
05:59:37 <Stinger_> "no no click the sheep guts"
06:04:40 <dylan> "no, no click the yowe intimmers"
06:06:28 <psnl> yum, haggis
06:06:30 <dylan> bah, ghostview is being a pain
06:07:05 <dylan> I'd actually like to try haggis (and I'd also like to read this paper...) but real haggis is illegal here.
06:08:15 <tibbe> here?
06:08:27 <dylan> the US
06:08:38 <dons> is that reasonable?
06:08:53 <SamB> what is haggis?
06:08:57 <dylan> It's a public health thing about not eating lungs of certain animals
06:09:02 <dons> ?google haggis severe illness
06:09:05 <lambdabot> http://www.phac-aspc.gc.ca/bid-bmi/dsd-dsm/nb-ab/2003/nb0603_e.html
06:09:19 <dons> that sounds reasonable, then
06:09:41 <psnl> SamB: the scottish national dish
06:09:50 <dons> so no sweetmeats in general?
06:09:59 <SamB> is it illegal to buy or illegal to make?
06:10:15 <xerox> Do you have a link to that 16 cpu mips station sold at 3k$ ?
06:10:26 <psnl> SamB: its normally made from all the bits left over after taking the good stuff from a sheep
06:10:26 <dylan> To sell, I think.
06:10:27 <dons> its illegal to produce a device that circumvents the haggis protection mechanisms
06:10:46 <SamB> dons: you are confused with copyright, I think
06:10:52 <dylan> dons++ -- haggis drm
06:11:08 <dylan> @karma+ dons -- haggis drm
06:11:08 <lambdabot> dons's karma raised to 52.
06:11:12 <dons> heh
06:12:18 <dylan> whee, this semester is going to be fun. Biking to class every day.
06:12:47 <dylan> well, tuesday and thursday. But that's an aproximation of every day
06:12:59 <SamB> heh
06:13:05 <dcoutts> xerox, http://www.movidis.com/products/rev.asp
06:13:07 <lambdabot> Title: Movidis
06:13:29 <xerox> dcoutts: thanks
06:38:08 <Oejet> Gtk2Hs UTF-8 question: I have a string, "\209\135\209\130\208\190", which shows like —á—Ç–æ with putStr, but which shows like √ë¬á√ë¬Ç√ê¬æ in the textView.
06:39:44 <Oejet> Do I somehow have to parse the string into unicode?  Those escaped numbers in the string are byte values, right?
06:40:12 <dcoutts> Oejet, you've double encoded the string
06:40:39 <dcoutts> or rather you've started with it encoded as UTF8 but in a String
06:40:47 <dcoutts> where as String is already unicode
06:41:04 <dcoutts> so when Gtk2Hs turns the String into UTF8, your thing gets double encoded
06:41:26 <dcoutts> the trick is to start with a normally unicode string
06:41:41 <dcoutts> so if you're reading from a file then decode from utf8
06:41:50 <ookk> what is the benefit of having monads and syntax-suger to make it look like imperative operations instead of just adding imperative features to the language?
06:42:01 <Oejet> I have parsed the string from a text file.
06:42:22 <dcoutts> Oejet, then you'll need to decode the UTF8 into a normal Haskell unicode String
06:42:39 <Oejet> Hm, so I need a library?
06:42:51 <dcoutts> or pinch the code from somehwere
06:43:06 <kowey> does this help? http://repetae.net/john/recent/out/HsLocale.html (i'm planning to use it for wxhaskell)
06:43:07 <dcoutts> there's plenty of UTF8 encoder/decoders about
06:43:07 <lambdabot> Title: HsLocale
06:43:19 <kzm> I guess there are no plans to make haddock support .lhs directly?
06:43:19 <lambdabot> kzm: You have 1 new message. '/msg lambdabot @messages' to read it.
06:43:36 <dons> kzm, wouldn't you just unlit it first?
06:43:45 <dcoutts> Oejet, sadly there's not UTF8 enc/dec stuff in the standard libs yet, bu you can easily get the code elsewhere
06:44:00 <nilsi> @seen nilsi
06:44:00 <lambdabot> You are in #haskell. I last heard you speak just now.
06:44:04 <dons> just have to hunt for the haskell warz
06:44:14 <dons> warez..
06:44:18 <kzm> I guess I'm not completely clear on how to invoke haddock from a Makefile.  Should I explicitly unlit .lhs to create .hs?
06:44:46 <kzm> Currently, I just do:   haddock -h `find src -name \*.hs` -o docs
06:44:56 <kzm> Perhaps I should be more refined?
06:45:18 <Oejet> kowey: Was that for me?  bytesToString looks somewhat related to my problem. :-)
06:45:30 <kowey> Oejet: yes
06:45:43 <Oejet> kowey: Thank you.
06:45:59 <kowey> :-)
06:48:51 <Oejet> kowey: That looks a bit like overkill, I'm afraid.  And also:
06:49:39 <Oejet> ]$ make
06:49:39 <Oejet> hsc2hs -C ""  -o CWString.hs CWString.hsc
06:49:39 <Oejet> ghc-6.4.2: file `' does not exist
06:50:11 <kowey> Oejet: ick... i'm afraid I haven't tried to use it yet... i guess i too am looking for a way to read UTF-8 strings in
06:52:15 <SamB> @google "CWString.hs"
06:52:15 <Oejet> The function shouldn't be more than a couple of lines, I think.  String -> String, but interpreting the input as bytes, and accumulating according to the utf-8 escape bits.
06:52:17 <lambdabot> http://repetae.net/john/repos/HsLocale/Makefile
06:52:18 <kowey> Oejet: fwiw, i removed the -C "$(CFLAGS)" from the Makefile
06:52:55 <kowey> ... which leads to other haskelly errors
06:53:33 <SamB> Oejet: I believe there is supposed to be one in gtk2hs
06:54:02 <dcoutts> though it's not exported
06:54:16 <SamB> dcoutts: which module was it in again?
06:54:18 <kowey> perhaps, this too? http://www.darcs.net/darcs-unstable/UTF8.lhs
06:54:49 <dcoutts> SamB, glib/System/Glib/UTFString.hs.pp
06:54:58 <SamB> kowey: doesn't quite look like it
06:55:16 <SamB> it looks like that one uses [Word8] for
06:55:28 <SamB> the utf-8
06:57:23 <norpan> SamB: well yes, because UTF-8 is byte based
06:57:31 <SamB> norpan: yeah
06:57:45 <SamB> it makes *sense*, it just doesn't compose well :-(
06:58:27 <kowey> SamB: interesting... elaborate?
06:58:51 <SamB> kowey: well, depending on what you are doing
06:59:52 <SamB> I mean, the String -> String interface works well for data that was just read as if in ISO 8859-1 or is about to be written as such...
07:01:22 <norpan> SamB: just use map (toEnum.fromEnum)
07:01:31 <SamB> yeah yeah...
07:02:28 * kowey still does not understand :-(
07:02:40 <SamB> take a look
07:02:43 <kowey> i'm having trouble seeing what would compose well, given the varying-number-of-bytes thing
07:02:58 <SamB> what does that have to do with anything?
07:03:36 <kowey> uh... perhaps nothing! ok, i think this means i *really* don't see what compose well means
07:03:40 <kowey> :-)
07:03:55 <SamB> @type let decode = undefined :: String -> String in liftM decode . readFile
07:03:57 <lambdabot> String -> String in liftM decode . readFile :: FilePath -> IO String
07:04:39 <SamB> hmm...
07:05:00 <SamB> could really use a parser for @type, couldn't it?
07:06:27 <Oejet> I will write a simple translator.  I'll be back in a bit.
07:06:31 <SamB> anyways... if it was [Word8] -> String, you'd need to coerce all the Chars read from the file into Word8s first, which is, if nothing else, unneeded clutter...
07:06:39 <SamB> Oejet: eh?
07:06:49 <SamB> glib/System/Glib/UTFString.hs.pp has one
07:07:50 <kowey> oh... is there nothing like a readFile8 that would give [Word8] ?
07:08:14 <kowey> (this gets rather uncomfortable if you're not primarily using utf-8, i imagine...)
07:18:42 <SamB> hmm?
07:21:05 <mnislaih> ping Lemmih
07:21:16 <SamB> Lemmih: ping
07:21:24 * SamB takes mnislaih literally
07:21:40 <mnislaih> o¬øo
07:22:00 <mnislaih> I hope the rest of the channel won't, or we'll flood poor Lemmih
07:24:20 <Lemmih> Yo
07:24:56 <mnislaih> ah Lemmih
07:25:02 <mnislaih> I think I've found the issue
07:25:10 <mnislaih> with the "ase" thing
07:25:12 <SamB> well I think we are smart enough to tell that Lemmih only needs to be pinged once ;-)
07:25:31 <mnislaih> it looks like RTS symbols don't get the same names in all the archs
07:25:43 <Lemmih> mnislaih: Oh?
07:25:56 <mnislaih> and my hand made parsing routines are not solid enough
07:26:10 <Oejet> SamB: Do you mean readUTFString?
07:26:17 <mnislaih> I'm trying to get a Linux build at ender4
07:26:26 <mnislaih> and then I'll push a patch fixing it
07:26:40 <Stinger_> heh I read that as readWTFString
07:26:45 <Lemmih> Okay.
07:27:14 <mnislaih> Lemmih: for instance, I get '_base_GHCziBase_False_static_info' for Bool.False
07:27:41 <mnislaih> (I'm in Mac Intel)
07:27:43 <dons> mm. Z encoding!
07:27:53 <SamB> mnislaih: what is so wierd about that?
07:27:58 <dons> now with packages!
07:28:08 <SamB> but why is the version number missing?
07:28:12 <mnislaih> it's not, but looks like it's not the same in Lemmih's system
07:28:22 <SamB> dons: do you know?
07:28:39 * dons has a poster of the Z encoding on the wall of his office space
07:28:45 <Igloo> mnislaih: How does it differ?
07:28:59 <SamB> should not the version number of the package be included in the symbol?
07:29:03 <mnislaih> I think the leading underscore is not present, but I'm not sure yet
07:29:13 <SamB> mnislaih: oh, just that?
07:29:14 <Igloo> Right, that depends on the arch/OS
07:29:20 <mnislaih> yes, just that
07:29:39 <SamB> that sounds like a C thing
07:29:54 <SamB> sometimes C symbols have _ prepended, other times not
07:30:04 <Igloo> mnislaih: You can find out whether it's included from Config.cLeadingUnderscore
07:30:17 <mnislaih> cool, thanks Igloo!
07:34:08 * SamB looks at http://hackage.haskell.org/trac/haskell-prime/wiki/RemovalCandidates again
07:34:10 <lambdabot> Title: RemovalCandidates - Haskell Prime - Trac
07:34:30 <dcoutts> JaffaCake, the ghc 6.6 packages plan looks good to me.
07:34:42 <SamB> they aren't seriously considering removal of k patterns for the next Haskell, are they?
07:34:45 <JaffaCake> great, thanks
07:34:51 <SamB> with no replacement in sight and all?
07:35:17 <dcoutts> JaffaCake, oh and nice that we might get a better working mips port thanks to ths :-)
07:35:28 <JaffaCake> yep
07:35:37 * SamB wonders where JohnMeacham is
07:36:08 <mnislaih> Lemmih: fix up
07:36:51 <SamB> oh, wait, he seems to have fixed the problem I found in the docs...
07:38:58 <SamB> oh, well, one of them anyway...
07:39:44 <SamB> hmm, my mail server still ain't working?
07:44:03 <Oejet> SamB: Which one of the functions in glib/System/Glib/UTFString.hs would I need?  I tried to do this: utf8str <- withCString str readUTFString, but that gave me a segmentation fault.
07:44:41 <SamB> Oejet: oh, you have a C string encoded in UTF-8?
07:45:06 <Oejet> No, I use readFile to get "str".
07:45:12 <SamB> oh
07:45:22 <SamB> right...
07:46:30 <SamB> Oejet: copy+paste toUTF and fromUTF
07:47:10 <Oejet> SamB: Ah, so I should look into the source. :-)
07:47:24 <SamB> hehe, yes ;-)
07:47:50 <tibbe> JaffaCake, you wrote something about relying on the distributions package managers for distributing packages in your GHC 6.6 email
07:48:06 <tibbe> I'm not sure that's a good thing
07:48:38 <JaffaCake> I didn't mean to imply that we wouldn't be providing binary distributions as usual - we certainly will
07:48:54 * SamB wonders what JaffaCake meant
07:49:08 * musasabi thinks a ghc-minimal-6.6.tar.bz2 and a ghc-all-6.6.tar.bz2 could be one way to proceed.
07:49:31 <JaffaCake> we supply binary tarballs for Linux, and Windows installers - that will continue
07:49:50 <JaffaCake> and the other dists that people contribute
07:50:14 <SamB> hmm
07:50:18 <JaffaCake> but if you're on a system with a package manager, you're better off getting GHC from there
07:50:21 <SamB> I need an excuse to write a parser
07:50:46 <JaffaCake> do I make sense?
07:51:30 <tibbe> I don't think it's a very good idea to have package managers manage libraries (but they should manage GHC), in the long run I think haskell is better of with a package managers of its own
07:51:37 <musasabi> JaffaCake: but it is nice to have multiple different versions of GHC and in that case the tarball-method makes most sense for the extra versions.
07:51:44 <JaffaCake> musasabi: yes, we might well do that (if it doesn't add too much complexity to the build/dist setup)
07:51:47 <tibbe> it doesn't work well for the ruby community
07:52:06 <SamB> tibbe: I agree
07:52:10 <JaffaCake> tibbe: on that I disagree
07:52:11 <tibbe> lots of outdated and missing packages, package maintainers can't keep up
07:52:12 <mnislaih> JaffaCake: I've introduced a dependency on mtl since I used a State monad in my code. Should I refactor it ?
07:52:35 <Lemmih> We've got cabal-install.
07:52:42 <tibbe> JaffaCake, everybody just uses RubyGems, although I know that the debian people disagree as well
07:53:00 <tibbe> Lemmih, yes :) and as soon as we have cabal-uninstall it
07:53:07 <tibbe> AFD@#!@$EF return key
07:53:09 <JaffaCake> mnislaih: which code?
07:53:24 <tibbe> Lemmih, as soon as we have cabal-uninstall it'll be great
07:53:35 <mnislaih> in some code for stage2 in the ghc.debugger
07:53:37 * tibbe could write it if he was good enough
07:53:54 <JaffaCake> tibbe: the problem is that then Cabal packages can't interact with the package system, specifying dependencies on non-Haskell libraries for example
07:54:10 <SamB> JaffaCake: what OS do you *use*?
07:54:16 <tibbe> JaffaCake, hmm, true, do you have a good solution?
07:54:33 <JaffaCake> tibbe: yes, automatic generation of OS packages from Cabal packages
07:54:36 <qwr> hmm i've used ruby libraries from debian packages
07:54:45 <Lemmih> mnislaih: It works.
07:54:48 <JaffaCake> SamB: several OSs
07:54:58 <dons> each more diabolical than the last!
07:54:59 <tibbe> JaffaCake, that would be great indeed, my experience of building debian packages is that it's all but automatic
07:54:59 <SamB> oh, maybe you could do like Debian's Lisp stuff?
07:55:07 <Lemmih> mnislaih: (your patch, that is)
07:55:14 <JaffaCake> SamB: desktop: Windows, under the desk: Linux, laptop: Gentoo, at home: FreeBSD
07:55:17 <mnislaih> Lemmih: cool, thanks for trying it
07:55:22 <tibbe> qwr, me too, until I find that too many are missing or old
07:55:38 <mnislaih> Lemmih, do you think we should make some kind of announcement ?
07:55:45 <SamB> JaffaCake: what version of Debian do you run? ;-P
07:56:06 <JaffaCake> Debian I don't have, except an old laptop at home that I installed Ubuntu on
07:56:13 <SamB> I thought not
07:56:18 <Lemmih> mnislaih: Yeah.
07:56:50 <Oejet> Hm, using toUTF I still get giberish: √É¬ê√Ç¬æ√É¬ë√Ç¬Ç√É¬ê√Ç¬¥√É¬ê√Ç.
07:57:00 <mnislaih> Lemmih: I hope people aren't too scared by the perspective of building ghc manually
07:57:14 <JaffaCake> mnislaih: sorry yeah, I try to avoid mtl dependencies in GHC
07:57:26 * SamB does *not* want to deal with binary packages of Haskell libraries in Debian
07:57:47 <mnislaih> JaffaCake don't worry,  it shouldn't take more than two minutes
07:57:52 <tibbe> JaffaCake, for example I have to manually create packages for libraries that exist in Ubuntu development but not in stable (which I use), so distributions that rely on periodical releases are not very satisfactory when I want to do edge developent as it stands right now
07:57:53 <JaffaCake> mnislaih: what's the prospect for getting your breakpoint patches into 6.6?
07:58:27 <dons> JaffaCake: btw, I'm working right now on a few little clean ups of Data.ByteString, to push in the next 48 hours
07:58:30 <dons> does that fit?
07:58:42 <SamB> perhaps my perspective is odd due to having been stuck on dialup...
07:58:46 <JaffaCake> tibbe: right, in that case you will want cabal-install, or manually install Cabal packages
07:59:04 <JaffaCake> dons: sure
07:59:06 <tibbe> JaffaCake, yes, and cabal-uninstall when I want to remove them ;)
07:59:16 <JaffaCake> well, maybe
07:59:33 <mnislaih> JaffaCake: I have finished the users guide documentation. The coding work is mostly complete. I'm halfway done with tests. But I'm not sure it is completely bug free, I want to get some people to try the debugger and see how it goes before recommending its inclusion in 6.6
07:59:45 <tibbe> the whole spray your filesystem or make install like procedure makes me a little nervous
07:59:52 <tibbe> s/or/of
07:59:54 <SamB> but I really don't think Debian should be distributing these libraries as binaries...
08:00:09 <JaffaCake> mnislaih: as long as it doesn't break anything else, experimental code is not really a problem
08:00:44 <mnislaih> JaffaCake, then maybe we should try to include it the release candidate and see how it goes
08:01:02 <JaffaCake> tibbe: yes indeed, but that's why we have /usr/local
08:01:13 <mnislaih> but I'm a bit nervous since not many people have used it yet apart from *me*
08:01:15 <JaffaCake> mnislaih: sounds good to me
08:01:46 <JaffaCake> it isn't likely to impact anything else, right?
08:02:03 <mnislaih> I think so
08:02:40 <mnislaih> unless we want to have '-fdebugging' as a default option
08:02:59 <mnislaih> but even so, -fdebugging is pretty solid
08:03:46 <SamB> so how do breakpoints ... um ... work?
08:03:57 <Cale> SamB: why not?
08:04:01 <mnislaih> @where ghci.debugger
08:04:01 <lambdabot> http://haskell.org/haskellwiki/Ghci/Debugger
08:04:05 <Cale> SamB: I certainly don't feel like compiling anything :)
08:04:07 <mnislaih> there is a video SamB :)
08:04:18 <JaffaCake> mnislaih: we might still want to change how the dynamic breakpoints are done
08:04:20 <Lemmih> The code seems very stable and it shouldn't affect other areas of GHC.
08:04:33 <SamB> Cale: well, because whenever I wanted to install one they'd have just switched compilers in testing...
08:04:50 <JaffaCake> but for the first cut I think it's ok to label this as a "very experimental"
08:05:39 <JaffaCake> what does -fdebugging do?  enable dynamic breaks?
08:05:43 <tibbe> JaffaCake, yes but that still doesn't solve versioning and upgrading
08:05:50 <musasabi> Was there a decision on the Cabal optional dependencies stuff? Even something minimal would be nice to have for fps - or provide an empty fps package by default.
08:05:56 <mnislaih> JaffaCake I agree, as I said in the wiki this is "the simplest thing that could possibly work", i.e. in a sense it is a very crude implementation
08:05:57 <dcoutts> JaffaCake, just checking: you said you applied ndm's "setup haddock --hoogle" patch. I've not seen it come through.
08:06:14 <mnislaih> yes, -fdebugging enables the instrumentation of code with breakpoints
08:06:23 <JaffaCake> dcoutts: I got a minor conflict, need to modify and push
08:06:31 <dcoutts> ok
08:06:47 <dcoutts> The conflict was probably my fault :-)
08:06:48 <JaffaCake> mnislaih: so without -fdebugging you can still add breakpoints to the code?
08:06:58 <JaffaCake> dcoutts: yes
08:07:14 <mnislaih> manual breakpoints are always available, but dynamic breakpoints are there only with -fdebugging
08:08:03 <mnislaih> you should check the documentation JaffaCake  ;)
08:08:28 <mnislaih> I posted a link to a snapshot in the wiki page
08:08:28 <JaffaCake> dcoutts: pushing now
08:08:35 <dcoutts> ok
08:08:41 <JaffaCake> mnislaih: right, RTFM :)
08:09:01 <mnislaih> ah wait a minute, there is something wrong with the snapshot
08:09:04 <mnislaih> I'll be rebuilding the docs
08:10:08 <tibbe> how's in charge of cabal-install right now?
08:10:37 <SamB> tibbe: "who"!
08:10:41 <SamB> not "how"
08:10:53 <tibbe> yes, sorry
08:11:03 <SamB> > permutations "who"
08:11:04 <lambdabot>  Not in scope: `permutations'
08:11:17 <Oejet> dcoutts: f <- readFile "abe.utf8"; let s = toUTF f.  Feeding s to a textBuffer gives a worse result than without toUTF.
08:11:23 <mnislaih> JaffaCake: documentation fixed
08:11:56 <dcoutts> Oejet, no, you want  fromUTF8
08:12:11 <dcoutts> Oejet, you've got a text from encoded in UTF8. You want to *decode* it.
08:12:17 <Oejet> Doh.
08:12:18 <dcoutts> from/file
08:13:17 <tibbe> SamB, so *who* is in charge of cabal-install?
08:13:19 <Oejet> Beautiful!
08:13:28 * Oejet cries.
08:13:34 <Lemmih> tibbe: Define 'in charge'.
08:13:35 <SamB> was it xerox?
08:13:52 <Lemmih> gsoc ended yesterday.
08:14:28 <SamB> well, who is to be yelled at?
08:14:36 <tibbe> Lemmih, working on it, understands it etc
08:17:05 <Lemmih> tibbe: Lots of people understand it.
08:17:30 <Oejet> dcoutts, kowey, SamB: Thank you!
08:17:56 <Oejet> dcoutts: to/fromUTF should really be exposed in the Gtk2Hs API, I think.
08:17:58 <Lemmih> tibbe: It's less than 1k lines so there isn't really that much to understand.
08:18:16 <dcoutts> Oejet, we're hoping it'll be part of some improve IO lib
08:18:41 <tibbe> alright, what I'd like to know it who keeps track of what packages and versions are installed, cabal-install or ghc?
08:19:36 <Lemmih> tibbe: ghc (or hugs or nhc or jhc or whatever backend you use).
08:21:21 <tibbe> was that a delibirate choice or did they just happen to manage it already?
08:22:43 <Lemmih> The latter.
08:22:44 <dons> we came in to work one day, and there it was: ghc-pkg. ready to go, and fully bug free. that was a strange day.
08:23:45 <SamB> @google site:haskell.org xml
08:23:48 <lambdabot> http://www.haskell.org/haxr/
08:23:48 <lambdabot> Title: HaXR - the Haskell XML-RPC library
08:24:11 <dons> ?gsite haskell.org xml
08:24:13 <lambdabot> http://www.haskell.org/haxr/
08:24:13 <lambdabot> Title: HaXR - the Haskell XML-RPC library
08:24:23 <dons> ;)
08:24:48 <tibbe> Lemmih, do you think it would be a good thing to have the package manager handle it later if possible? doesn't it have to keep track of some installed-packages-information anyway?
08:24:49 <dons> unfortunately, gwiki doesn't quite work as well
08:25:09 <dons> ?gwiki Lambda
08:25:11 <lambdabot> No Result Found.
08:25:15 <dons> now I know that can't be right
08:25:32 <dons> ?google site:haskell.org/haskellwiki lambda
08:25:34 <lambdabot> http://www.haskell.org/haskellwiki/Untypechecking
08:25:35 <lambdabot> Title: Untypechecking - HaskellWiki
08:25:44 <dons> ?google site:haskell.org/haskellwiki Lambda
08:25:47 <lambdabot> http://www.haskell.org/haskellwiki/Untypechecking
08:25:47 <lambdabot> Title: Untypechecking - HaskellWiki
08:25:49 <dons> hmm
08:26:05 <Lemmih> tibbe: Handle what later?
08:26:10 <dons> ?google site:haskell.org/haskellwiki/ Lambda
08:26:15 <lambdabot> http://www.haskell.org/haskellwiki/Untypechecking
08:26:15 <lambdabot> Title: Untypechecking - HaskellWiki
08:26:49 <dons> oh, it ssearching google.ca for some bizarre reason
08:26:51 <dons> I blame Cale
08:27:08 <Cale> heh
08:27:15 <Cale> I didn't touch it :)
08:27:20 <dons> hunk ./Plugin/Search.hs 26
08:27:21 <dons> -   ,("http://www.google.ca/search?hl=en&q=site%3A", "&btnI=I%27m+Feeling+Lucky"))
08:27:24 <dons> +   ,("http://www.google.com/search?hl=en&q=site%3A", "&btnI=I%27m+Feeling+Lucky"))
08:27:41 <dons> hehe
08:29:20 <tibbe> Lemmih, what exactly is the purpose of cabal-install, to do a dependency lookup and wget packages?
08:29:28 <Lemmih> tibbe: Yep.
08:29:48 <tibbe> so no versioning or anything?
08:29:57 <Lemmih> tibbe: And then installed the fetched packages.
08:30:02 <Lemmih> tibbe: Versioning?
08:30:03 <tibbe> yes
08:30:18 <tibbe> I want to update installed packages to the latest version
08:30:35 <tibbe> or update this package if there's a new version
08:30:44 <tibbe> or remove this package
08:30:48 <Lemmih> It can do that too.
08:30:57 <Lemmih> (not the removal part, tho)
08:32:17 * Lemmih isn't even sure how to remove nhc or yhc packages.
08:33:15 <tibbe> what I'm trying to get to is me not having to remember to remove old package versions when I upgrade, and look for the corresponding files and remember dependencies
08:33:31 <tibbe> cabal-install seems to solve this in one directions (install)
08:35:14 <Lemmih> tibbe: Feel free to patch Cabal.
08:37:11 <Lemmih> tibbe: As long as Cabal can't uninstall packages, none of the tools layered on it can't either.
08:37:59 <tibbe> Lemmih, I've probably mentioned this earlier but it's here I've difficulties in recognizing what piece of software is responsible for what functionality
08:38:43 <tibbe> Lemmih, I see Cabal (as in runhaskell Setup.hs build) as a more sophisticated make, but then it contains some package info in form of .cabal files...
08:39:03 <tibbe> and cabal-install looks more like a package manager
08:39:37 <Lemmih> tibbe: Cabal is a gateway to the individual implementations. It maps commands (such as 'build' or 'install') to backend specific actions.
08:39:47 <tibbe> so which one is really responsible for such a thing as uninstalling, that software need a list of installed packages
08:39:57 <tibbe> hmm
08:40:19 <tibbe> I need a nice illustration to understand all of this! :D
08:42:27 <Lemmih> tibbe: We have multiple Haskell implementations. That means that there isn't a single list of installed packages and there isn't a general way of uninstalling a package.
08:43:08 <dons> rm -rf works, when combined with vi, generally
08:43:16 <dons> are there any systems where that doesn't apply, I wonder?
08:43:32 <dons> shapr's nokia, perhaps.
08:45:13 <tibbe> Lemmih, couldn't I just do a ghc/nhc/whatever-pkg remove for all installed installations and then remove the files?
08:45:53 <Lemmih> tibbe: Sure you could. Send the patches to Cabal.
08:47:07 <tibbe> I'm trying to understand what has been done before doing something so I can figure out if it's worth doing or not
08:47:55 <Lemmih> It's not very needed, I think.
08:48:36 <dons> why would you want to remove haskell software from your system... ever?
08:48:38 <tibbe> here's where I'm coming from: it works well with RubyGems which makes the barrier to entry on hacking Ruby smaller, I'd like that for haskell too
08:48:39 <dons> its just not logical!
08:48:43 <tibbe> dons, old?
08:48:50 <dons> ;)
08:48:55 <tibbe> :p
08:49:16 <Igloo> Early twenties, I think
08:49:23 <Lemmih> heh
08:49:27 <tibbe> for uninstall I need to store a list of files somewhere
08:49:35 <dons> mid-twenties ;)
08:49:54 <tibbe> so Setup.hs uninstall probably wouldn't make sense if the source isn't available anymore (and thus Setup.hs)
08:50:16 <tibbe> so the list of packages and files has to be kept independently somewhere
08:50:24 <tibbe> probably with cabal-install
08:50:34 <Lemmih> *the lists
08:52:22 <Lemmih> tibbe: Cabal is a library. The Setup script just calls the install function.
08:53:44 <tibbe> what I meant was that I can't dump a file with uninstallation information in the source directory and then expect it to be there when I need to uninstall
08:53:55 <tibbe> so it has to be kept elsewhere
08:55:03 <Lemmih> I'm not even sure how to get that uninstall information.
08:55:43 <tibbe> well, it has to be created when the package is built
08:56:38 <SamB> it ought to be stored by ghc-pkg or whatever facility...
08:56:46 <tibbe> so if cabal-install pulls a source package from a mirror, creates a binary package and installs/registers it some info needs to be generated and stored even if the source package is then removed
08:57:50 <SamB> or wherever cabal-install keeps its database if it has one
08:57:55 <tibbe> SamB, that's the question I've been thinking about, storing it with cabal-install might be better, again perhaps not
08:58:03 <Lemmih> SamB: ghc-pkg keeps the information. But what about hugs and jhc?
08:58:21 <SamB> Lemmih: does ghc-pkg keep *all* the information?
08:58:51 <SamB> does cabal-install already have a database?
08:59:00 <Lemmih> SamB: Pretty much.
08:59:14 <tibbe> something like cabal-install/ghc/nhc/<package>/file-list
08:59:17 <SamB> okay, so maybe cabal-install should just hold onto it then...
08:59:26 <tibbe> oh s/ghc/
08:59:51 <snk_kid> ahoy
08:59:53 <tibbe> one binary lib is built per implementation right?
09:00:33 <Lemmih> tibbe: You choose what implementation to use, yes.
09:00:35 <tibbe> cabal support executables as well so rm -rf /usr/local/<lib> isn't enough
09:00:48 <SamB> yah
09:01:02 <tibbe> Lemmih, is the implementation a flag to cabal-install as well?
09:01:07 <SamB> what happens with profiling builds etc. ?
09:01:15 <Lemmih> tibbe: Yes.
09:01:19 * tibbe is getting tired
09:01:22 <snk_kid> you know what amazing? absolute lack of jobs in haskell or O'caml, i've only seen one commerical job for Ocaml
09:02:06 <SamB> hmm, what is a good excuse to write a parser?
09:02:09 <lispy> snk_kid: what part of the world do you want to work in?
09:02:12 <dons> type "Haskell" into google ;)
09:02:13 <dons>                Sponsored Links
09:02:13 <dons>        Functional Prog. Jobs
09:02:13 <dons>        Haskell hackers welcome!
09:02:17 * Lemmih is actually getting paid for Haskell work.
09:02:21 <lispy> snk_kid: i know of a place in Oregon that does haskell
09:02:30 <madpickle> Lemmih: academia?
09:03:03 <Lemmih> madpickle: Nope, "real world".
09:03:04 <SamB> I expect that wherever I end up working will pay me to do Haskell at some point or other
09:03:09 <madpickle> Lemmih: interesting.
09:03:12 <tibbe> my ride home is here, I'll think about some more
09:03:12 * Igloo wonders how much that ad costs them
09:03:21 <SamB> if only to figure out how to solve a problem
09:03:29 <snk_kid> all the software developement jobs in the UK are the same typical lame jobs
09:03:34 <tibbe> think about *it*, sigh
09:03:35 <lispy> madpickle: i was able to choose the technologies used on my current work project and hence i get paid to write haskell code at the moment
09:03:35 <dons> Igloo: yeah, I'd have thought a quick email to haskell@ would have been cheaper ...
09:03:36 <Lemmih> snk_kid: And Igloo just got a Haskell-ish support job.
09:03:59 <SamB> they don't control what lanuage you use to ponder a problem do they?
09:04:13 <madpickle> sure they do
09:04:15 <madpickle> maintenance
09:04:24 <snk_kid> i'm not interested in getting corned with Java or anything related to  finance
09:04:27 <SamB> ponderings require maintenance now?
09:04:41 <madpickle> SamB: well... no. then again, it might.. for some.. consultants.
09:04:45 <dons> snk_kid: though haskell is used in some of the investment firms now
09:04:49 <SamB> madpickle: what?
09:04:56 <madpickle> 'twas a joke
09:05:04 <madpickle> i was referring to using haskell in jobs
09:05:04 <SamB> dons: did they read that enron article?
09:05:18 <madpickle> and that after you/your crew moves on somebody has to maintain your haskell code
09:05:19 <snk_kid> It's all the same in the UK java, c#, sometimes C++ in finance/banking, i have no interest in those what so ever
09:05:24 <dons> oh, the email from april, SamB?
09:05:27 <benja_> sheesh, academic papers. are first sentences like "Program errors are common in software systems, including those that are constructed from advanced programming languages, such as Haskell" really useful except to proclaim that the author likes H? :-)
09:05:43 <SamB> dons: I suppose it was probably in april
09:05:48 <SamB> @google site:haskell.org enron
09:05:51 <lambdabot> http://www.haskell.org/haskellwiki/Humor/Enron
09:05:51 <lambdabot> Title: Humor/Enron - HaskellWiki
09:05:57 <dons> yah, that one.
09:06:04 <benja_> (/me is reading http://www.cl.cam.ac.uk/~nx200/research/escH-hw.ps )
09:06:17 <dons> its a great line :)
09:06:21 <snk_kid> dons: in which part of the world, i don't see anything in the UK for it
09:06:31 <dons> google.com ?
09:07:04 <dons> via www.janestcapital.com/ocaml.html
09:07:11 <SamB> benja_: it mentions errors!
09:07:34 <SamB> presumably the next sentance is going to talk more about errors
09:07:39 <dons> ?quote DanaXu Program errors are common in software systems, including those that are constructed from advanced programming languages, such as Haskell
09:07:39 <lambdabot> DanaXu Program errors are common in software systems, including those that are constructed from advanced programming languages, such as Haskell hasn't said anything memorable
09:07:40 <snk_kid> dons: yeah that was the place i said was the only commerical use of ocaml i've seen
09:07:52 <dons> ?remember DanaXu Program errors are common in software systems, including those that are constructed from advanced programming languages, such as Haskell
09:07:52 <lambdabot> Done.
09:07:56 <SamB> leading up to some kind of strategy for dealing with errors or preventing them
09:08:08 <dons> snk_kid: ah well. there's lots of places (as many in this channel are employed to do hack haskell)
09:08:13 <Igloo> Oh, IIUC it costs them almost nothing per click, and they probably don't get many clicks
09:08:17 <dons> not as many as there should be, of course
09:08:29 <benja_> SamB: yeah, it does, and it sounds like an interesting paper
09:08:37 <snk_kid> dons: i don't mind that but i can't seem to find many in haskell either
09:08:59 <sieni> Is "bottom" the answer to "WWSPJD?". At I'd like to "do bottom".
09:09:51 <snk_kid> it makes me angry how dumb these recruitment agencies are
09:11:30 <madpickle> snk_kid: then start your own business specializing in haskell
09:11:39 <madpickle> or run a consultancy
09:11:41 <SamB> does anyone have any decent excuses for me to write a parser?
09:11:46 <madpickle> or, HAH, start an agency that: "does not suck"
09:11:51 <madpickle> SamB: fun?
09:11:59 <SamB> well...
09:12:06 <madpickle> do you need more reason than that?
09:12:16 <SamB> usually a good excuse to write a parser involves something to parse
09:12:17 <snk_kid> SamB: to gain experinice in writing one ;)
09:13:31 <SamB> someone suggest something nicer than XML please ;-)
09:13:44 <snk_kid> a purely functional subset of C
09:13:51 <SamB> ah
09:14:10 <SamB> that would be odd!
09:14:23 <snk_kid> not really
09:14:28 <SamB> how would it work?
09:14:53 <SamB> also I don't really want to parse C types...
09:15:12 <snk_kid> well i'm just throwing out some answers for you ;)
09:15:16 <SamB> er, declarations...
09:15:31 <snk_kid> get rid of ambiguties
09:17:06 <snk_kid> didn't haskell communty want a C parser anyways?
09:17:13 <snk_kid> i'm sure i read in the news
09:17:26 <SamB> there was someone doing that for SoC
09:18:06 <nilsi> maybe reading some file format?  bmp or jpeg or something?
09:18:40 <SamB> with a parser?
09:18:48 <SamB> I want to do something with frisby...
09:18:57 <snk_kid> well i don't think that helps, i'm assuming he/she wants to write parser combinator library?
09:19:22 <SamB> huh?
09:19:38 <xerox> SamB: lojban!
09:19:47 <benja_> heh :)
09:20:00 <SamB> that isn't a natural language?
09:20:05 <snk_kid> or a handwritten parser in something?
09:20:15 <benja_> SamB: an artificial language
09:20:31 <benja_> it *is* supposed to be computer-parsable IIRC
09:20:37 <SamB> hmm
09:20:52 <snk_kid> parser combinators like parsec
09:21:10 <SamB> snk_kid: who wants to write a combinator library?
09:21:16 <xerox> SamB: I can send you a starting ByteStringParser, if you are willing to enhance it...
09:21:33 <SamB> ooh
09:21:36 <kpreid> benja_: s/supposed to be //
09:21:41 <snk_kid> SamB:i don't know, i'm tryying to find what you want to do exactly
09:21:44 <xerox> SamB: that would be useful.
09:22:02 <SamB> oh, I wanted to write a parser using the "frisby" library
09:22:03 <benja_> kpreid: I only recall that it's supposed to be ;-)
09:22:09 <benja_> ("IIRC")
09:22:19 <SamB> xerox: hmm
09:22:26 <SamB> I could probably do that too...
09:22:36 <benja_> kpreid: but you could s/supposed to be // `o` s/ IIRC//
09:22:40 <xerox> SamB: that would bring you a _lot_ of positive karma
09:22:56 <SamB> xerox: you don't have a repo I can just grab?
09:23:15 <xerox> SamB: it's relatively short, and just one module, featuring a minimal design.
09:23:19 <SamB> ah
09:24:29 <SamB> okay, so how do you want to send it?
09:24:52 <xerox> email?
09:25:13 <SamB> okay... naesten at gmail dot com
09:26:30 <ricky_clarkson> Hi.  I'm looking for a particular tutorial, Yet Another Haskell tutorial or something.
09:26:41 <ricky_clarkson> It was here: http://isi.edu/~hdaume/htut/tutorial.pdf I think, but it's not.
09:26:52 <xerox> ?where yaht
09:26:52 <lambdabot> http://www.cs.utah.edu/~hal/htut/
09:27:15 <ricky_clarkson> Cheers.
09:30:01 <SamB> @type interact
09:30:06 <lambdabot> (String -> String) -> IO ()
09:33:15 <SamB> how odd...
09:34:06 <SamB> I ran "ghc -e 'interact (unlines . map (drop 2) . lines)' > ByteStringParser.hs", pasted part of that email, and typed ^D... but all that happened when I typed ^D was that ^D appeared on the screen...
09:37:04 <kpreid> SamB: I've had that happen too
09:37:25 <SamB> something wierd about the implementation of interact?
09:37:41 <SamB> or perhaps getContents?
09:38:08 <kpreid> it's disabling some terminal features. I don't know enough unix to say exactly what it's doing
09:38:16 <kpreid> for example, no line buffering and backspace
09:38:40 <SamB> hmm, there really ought to be a typeclass for strings...
09:38:59 <kpreid> also, it's not specific to interact
09:39:04 <SamB> oh?
09:39:11 <kpreid> ghc -e 'print =<< getContents' is also funny
09:39:16 <SamB> oh
09:39:28 <SamB> is it getContents or is it ghc -e?
09:39:32 <kpreid> I wonder if getContents is trying to make the input less buffered
09:39:33 <kpreid> dunno
09:39:38 <kpreid> I haven't tried
09:42:08 <SamB> xerox: so...
09:42:23 * SamB wonders what to do with this
09:45:07 <xerox> Create more complicated combinators in a smart way
09:46:08 <ookk> why does this work: mapM (\(x,y) -> return.length =<< getPossiblesAt a (x,y)) [(x,y) | x <- [1..9], y <- [1..9]]
09:46:10 <ookk> but not this:
09:46:20 <ookk> mapM (return.length =<< getPossiblesAt a) [(x,y) | x <- [1..9], y <- [1..9]]
09:46:43 <xerox> mapM ((return . length =<<) . getPossibles At a) ..
09:47:02 <xerox> (Or even ((return . length) =<<) I am not sure.)
09:47:17 <ookk> okay and the reason for that is?
09:47:18 * SamB wonders what the laws would be for typeclasses for combinators...
09:47:27 <SamB> er, parsers...
09:47:34 <SamB> typeclasses for parsers...
09:47:35 <xerox> ookk: sure, look at the types, or do the expansion.
09:47:54 <ookk> ok
09:47:58 <xerox> SamB: I think one nice goal would be having more Parsec features.
09:48:02 <xerox> ookk: I can show you those.
09:48:48 <ookk> it worked anyway
09:49:00 <xerox> ookk - The definition we are using is (f . g) = \x -> f (g x).  The expression is \(x,y) -> return . length =<< getPossiblesAt a (x,y).
09:49:46 <SamB> hmm...
09:50:29 <xerox> \(x,y) -> (=<<) (return . length) (getPossiblesAt a (x,y))
09:50:39 <xerox> \(x,y) -> ((=<<) (return . length)) (getPossiblesAt a (x,y))
09:50:51 <xerox> ((=<<) (return . length)) . (getPossiblesAt a)
09:51:10 <xerox> ((return . length) =<<) . (getPossiblesAt a)
09:51:39 <xerox> (return . length =<<) . getPossiblesAt a
09:52:04 <xerox> ?pl ((return . length) =<<)
09:52:05 <lambdabot> (length `fmap`)
09:52:10 <xerox> Yarrr.
09:52:33 <xerox> map length . getPossiblesAt a
09:53:10 <SamB> what is with the "p"s?
09:53:33 <xerox> SamB: I suppose it'd be extremely cool for projects like pugs to be able to use ByteStringParse*c* as a drop-in replacement for Parsec. But I didn't investigate the details of such a goal yet.
09:53:51 <xerox> SamB: good question :)
09:53:59 <SamB> in particular, how come satisfy doesn't have one but most other things do?
09:54:23 <xerox> p* are parsers?
09:54:31 <xerox> No idea.
09:54:34 <SamB> and satisfy isn't?
09:54:41 <xerox> It indeed is.
09:55:26 <xerox> OK, let's do like you said...
09:55:28 <SamB> hmm, how am I supposed to figure out where to stick new things?
09:56:57 <JohnMeacham> audreyt: actually, frisbys many1 behaves just like that. you need manyUntil to have it stop matching early
09:57:50 <JohnMeacham> audreyt: I don't bother with posix-esque combinators, the posix semantics for regexes is braindead, having the worst of maximal and minimal munch modes.
09:59:04 <SamB> hmm, I thought oneOf had error messages... whatever...
10:00:29 <xerox> darcs get http://hackage.haskell.org/~paolo/darcs/ByteStringParser
10:00:32 <lambdabot> Title: Index of /~paolo/darcs/ByteStringParser
10:00:53 <xerox> So we can put together patches with code, comments, and whatnot.
10:01:36 <JohnMeacham> audreyt: hmm.. I should update the frisby regex docs to mention that.
10:01:56 <xs> monadicparser type class?
10:02:06 <SamB> xs: would be nice
10:02:13 <SamB> but I don't know what laws it would need
10:03:10 <xerox> darcs changes # for the informations
10:06:02 <JohnMeacham> SamB: got your patch, applied it.
10:06:10 <SamB> yeah, I see
10:06:21 <SamB> JohnMeacham: oh, you left out the .txt files for the test cases...
10:06:44 <JohnMeacham> SamB: compile and run the 'gentestcases' program.
10:06:50 <SamB> oh
10:10:08 <SamB> okay...
10:10:22 <SamB> why is haddock not running on ByteStringParser?
10:10:36 <SamB> it dies near the end of the comment at the top...
10:10:39 <xerox> What is the problem?
10:10:41 <xerox> Ah.
10:10:47 <xerox> Can you figure it out?
10:11:10 <SamB> hmm, maybe if I read the docs for haddock...
10:11:25 <xerox> Implementing more things would be fun too.
10:11:32 <xerox> I should hack cabal-install, yarrr
10:11:33 <SamB> yeah, I plan on it
10:12:16 <ski> @yarr
10:12:17 <lambdabot> Swab the deck!
10:13:00 <xerox> I think the deck should be clean enough at this point....
10:13:42 <ski> Swab away the bugs!
10:13:42 <lambdabot> ski: You have 1 new message. '/msg lambdabot @messages' to read it.
10:14:05 <xerox> !!!
10:14:07 <ski> huh, a message, to me ?
10:14:39 <ski> apparent from four days ago
10:14:56 <ski> wonder why lambdabot didn't say that upon my '@yarr'
10:15:11 <xerox> Yeah, that's a known bug, someone should swab it
10:15:23 <ski> :D
10:16:24 <SamB> oh apparantly haddock only wants one copyright line...
10:16:31 <SamB> very good error reporting, this...
10:16:36 <SamB> ByteStringParser.hs:15:1: parse error in doc string: [TokPara,TokString "Primitive parser combinators for ByteStrings loosely based on Parsec.\n",TokPara]
10:17:17 <benja_> SamB: there you have your next parser project =)
10:17:23 <SamB> eh
10:17:47 <SamB> I'm not sure I can do much better using Happy...
10:18:40 <dons> SamB, btw, do you have a copy of stepcut's bytestring parser to look at?
10:19:08 <xerox> dons <http://hackage.haskell.org/~paolo/darcs/ByteStringParser/ByteStringParser.hs>
10:19:18 <dons> ah
10:19:54 <xerox> SamB: how do you invoke haddock?
10:20:19 <SamB> well at first I was invoking it just plain "haddock ByteStringParser.hs"
10:20:25 <SamB> but I see that that doesn't produce output
10:20:45 <SamB> so I decided to use "haddock --odir haddock --html ByteStringParser.hs" instead
10:22:27 <JohnMeacham> please. haddocks parser is way too finicky.
10:22:48 <xerox> Hmmm.
10:23:15 <xerox> http://hackage.haskell.org/~paolo/darcs/ByteStringParser/ByteStringParser.html
10:23:18 <JohnMeacham> I had to create my own patched version in order to get it to not choke on frisby.
10:24:18 <SamB> xerox: you need to add your email to the repo
10:24:29 <SamB> so that darcs send will send you email!
10:24:44 <xerox> SamB: I think there is!
10:25:19 <SamB> why is darcs asking me what the target email address is?
10:25:22 <eivuokko> http://hackage.haskell.org/~paolo/darcs/ByteStringParser/_darcs/prefs/email is missing
10:25:50 <xerox> eivuokko: is cp author email enough?
10:26:01 <eivuokko> Yes
10:26:03 <xerox> Done.
10:30:00 <SamB> @pl \a -> (a,a)
10:30:01 <lambdabot> join (,)
10:30:54 <xerox> SamB: pushed, thanks.
10:36:49 <xerox> SamB: I've added the haddock docs to the repo, is it allright?
10:37:19 <SamB> I would sooner add a script to build them personally...
10:37:47 <xerox> Just if you don't have haddock, the html is handy, oh well, I don't know.
10:37:56 <SamB> not a big deal
10:38:05 * xerox removes
10:38:10 <SamB> might be a pain to have to merge them though
10:38:15 <xerox> Yes.
10:42:58 <SamB> hmm.
10:43:06 <SamB> maybe I should now test my combinator...
10:44:49 <SamB> it seems to work fine, as expected ;-)
10:46:12 <SamB> xerox: got it?
10:46:25 <xerox> ...pushed!
10:51:07 <SamB> hmm, error printing could use work...
11:31:37 <svref> Hm... how to compute (mod x y) for x and y of type Float?
11:34:35 <Amran> how about subtracting y from x until y is greater than x, then returning the remainder?
11:35:10 <Amran> so (mod 9.5 5) == 4.5
11:35:48 <LordBrain> i assume you dont want to just convert them to integers
11:35:49 <Oejet> Amran: Perhaps use a more efficient algorithm?
11:36:10 <Amran> Oejet: yeah there are probably way more efficient ones
11:36:16 <Amran> this just off the top of my head
11:36:43 <svref> or maybe y*(x/y - (floor x/y))
11:36:55 <PaulAJ> > (\ x y -> x (floor $ x / y) * y) 9.5 5
11:36:57 <lambdabot>    Occurs check: cannot construct the infinite type: a = b -> a
11:36:57 <lambdabot>    Expec...
11:37:12 <svref> probably the most efficient way is to figure out how to call C's function.
11:37:31 <PaulAJ> > (\ x y -> x - (floor $ x / y) * y) 9.5 5
11:37:32 <lambdabot>  Add a type signature
11:38:03 <svref> PaulAJ: What's that '$' do?
11:38:33 <PaulAJ> OK, I give in trying to program on the fly.  But the basic idea is to find out highest multiple y that is less than x.
11:38:37 <LordBrain> he's using it instead of parens
11:38:52 <LordBrain> $ is application
11:39:00 <PaulAJ> > (\ x y -> x - (fromIntegral $ floor $ x / y) * y) 9.5 5
11:39:02 <lambdabot>  4.5
11:39:04 <LordBrain> f $ x = f x
11:39:06 <PaulAJ> Bingo!
11:39:11 <LordBrain> but it has different precedence
11:39:40 <PaulAJ> It could have been ...
11:39:55 <PaulAJ> > (\ x y -> x - (fromIntegral (floor (x / y))) * y) 9.5 5
11:39:56 <lambdabot>  4.5
11:40:47 <PaulAJ> Easiest way to read an expression with $ in it is to see it as a pipeline running right to left.  So (x/y) gets piped into floor, and then into fromIntegral.
11:41:15 <svref> okay, I'll try thinking about it that way.
11:41:19 <mnislaih> eivuokko: ping
11:41:25 <Amran> PaulAJ: How about '.'
11:41:34 <PaulAJ> OK, here goes...
11:41:48 <PaulAJ> > (\ x y -> x - ((fromIntegral . floor) x / y) * y) 9.5 5
11:41:50 <lambdabot>  0.5
11:41:53 <LordBrain> i tend to use . and only use $ on the last thing...
11:42:00 <PaulAJ> Nope.  Didnt work.
11:42:10 <PaulAJ> Ahhh.
11:42:19 <PaulAJ> > (\ x y -> x - ((fromIntegral . floor) (x / y)) * y) 9.5 5
11:42:20 <lambdabot>  4.5
11:42:48 <LordBrain> @pl (\ x y -> x - (fromIntegral . floor $ x / y) * y)
11:42:49 <lambdabot> liftM2 (.) (-) (join . (((*) . fromIntegral . floor) .) . (/))
11:43:06 <PaulAJ> What does @pl do?
11:43:16 <LordBrain> shows the pointfree
11:43:31 <LordBrain> which is not really very readable in this instance
11:43:37 <LordBrain> but i was curious
11:43:41 <PaulAJ> Which is why its often known as pointless notation.
11:44:20 <PaulAJ> @pl  (\ x y -> x - (fromIntegral $ floor $ x / y) * y)
11:44:20 <lambdabot> liftM2 (.) (-) (join . (((*) . fromIntegral . floor) .) . (/))
11:44:37 <PaulAJ> Interesting.  I suppose its one way of proving equivalence of functions.
11:46:23 <Amran> so it seems '$' and '.' both pipe, but '.' has higher precedence?
11:46:28 <Amran> is this correct?
11:46:51 <SamB> not really
11:47:15 <PaulAJ> Not quite.  . is function composition.  Its defined as f . g = \x -> f (g x)
11:47:28 <SamB> > map ((+1) $ (*2)) [1,2,3]
11:47:29 <lambdabot>  add an instance declaration for (Num (a -> a))
11:47:34 <SamB> > map ((+1) . (*2)) [1,2,3]
11:47:35 <lambdabot>  [3,5,7]
11:47:47 <PaulAJ> Whereas $ is simple application.   f $ x = f x
11:48:06 <PaulAJ> (f . g) x = f $ g x
11:48:08 <LordBrain> you cant say something like ord . 'a' but you could say ord $ 'a'
11:48:17 <PaulAJ> but f . x /= f x
11:48:19 <Amran> aha - I think I see
11:48:19 <LordBrain> > ord 'a'
11:48:21 <lambdabot>  97
11:48:32 <Amran> > id . 6
11:48:33 <lambdabot>  add an instance declaration for (Num (a -> b))
11:48:39 <LordBrain> > ord $ 'a'
11:48:40 <lambdabot>  97
11:48:43 <LordBrain> hmm
11:48:50 <LordBrain> > ord . 'a'
11:48:50 <lambdabot>  Couldn't match `a -> Char' against `Char'
11:48:53 <LordBrain> see
11:48:57 <LordBrain> :)
11:49:00 <Amran> now confused - that worked in hugs (id . 6)
11:49:15 <Amran> id $ 6
11:49:19 <Amran> > id $ 6
11:49:20 <lambdabot>  6
11:49:26 <LordBrain> > id . 6
11:49:27 <lambdabot>  add an instance declaration for (Num (a -> b))
11:49:42 <Amran> ah no - my mistake
11:49:49 <Amran> '$' worked in hugs, '.' didn't
11:49:52 <Amran> same as here
11:50:07 <Amran> :(
11:50:10 <PaulAJ> id . 6 tries to become id ( 6 x)
11:50:20 <PaulAJ> > id ( 6 4)
11:50:21 <lambdabot>  add an instance declaration for (Num (t -> a))
11:50:44 <PaulAJ> In other words 6 is not  a function.
11:50:51 <Amran> ok
11:51:00 <PaulAJ> @type .
11:51:02 <lambdabot> parse error on input `.'
11:51:07 <PaulAJ> @type (.)
11:51:09 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
11:51:28 <swiert> I always like the error messages when an undergraduate tries to evaluate sin .3
11:51:34 <Amran> > sin .3
11:51:36 <lambdabot>  add an instance declaration for (Num (a -> b))
11:51:38 <PaulAJ> Ignore the forall bit.  What it says is that the two arguments to . are both functions.
11:51:40 <SamB> PaulAJ: you mean, in other words the compiler doesn't see *how* 6 could be a function
11:51:48 <Amran> > sin 0.3
11:51:49 <lambdabot>  0.29552020666133955
11:51:55 <Amran> > sin (.3)
11:51:56 <lambdabot>  add an instance declaration for (Num (a -> b))
11:52:10 <PaulAJ> No, the compiler knows perfectly well that 6 :: Integer
11:52:27 <PaulAJ> Or to be more precise, (Num a) => 6 :: a
11:52:30 <PaulAJ> @type 6
11:52:32 <lambdabot> forall t. (Num t) => t
11:52:36 <LordBrain> yeah
11:52:52 <LordBrain> suppose (a->b) were an instance of Num
11:53:13 <Beelsebob|Mini> @jam radar
11:53:14 <lambdabot> Maybe you meant: faq map
11:53:15 <PaulAJ> Well, for starters it would have to define fromIntegral (id)
11:53:17 <Beelsebob|Mini> :(
11:54:17 <PaulAJ> As far as the types go you could do it, but I can't imagine anything very meaningful for an implementation.
11:54:58 <PaulAJ> Gotta go.  Bye.
11:55:45 <SamB> hmm hmm
11:55:51 <SamB> I didn't know which was a built-in command...
12:28:56 <SamB> hmm, the error handling in Frisby isn't great is it?
12:29:15 <SamB> Prelude Text.Parsers.Frisby> runPeg (return (text "hi")) "hello"
12:29:15 <SamB> "*** Exception: runPeg: no parse
12:53:25 * xerox has under his hands a new Hope css theme...
13:22:38 <mGem> @users
13:22:41 <lambdabot> Maximum users seen in #haskell: 235, currently: 209 (88.9%)
13:25:26 <norpan> wow, percentage
13:25:38 <norpan> everybody loves a good percentage
13:30:00 <xs> i have f :: b -> IO a, and i want to make g :: b -> IO [a], that produces a list lazily. i'm currently using: g b = unsafeInterleaveIO (f b >>= \x -> g b >>= \xs -> return (x:xs)); then, else where: g b >>= mapM_ process, but this really leaks space. i can't see why. any ideas?
13:32:35 <swiert> xs: do you really want the unsafeInterleaveIO?
13:32:50 <xs> swiert, is there another way to get lazy io sematics?
13:33:15 <norpan> if you're using that, you need to do unsafeInterleaveIO g b
13:33:21 <norpan> not on the whole composition
13:34:05 <swiert> why won't g b = sequence (map f (repeat b)) work?
13:34:37 <xs> because IO is strict, so it doesn't terminate?
13:35:00 <norpan> yes, io is strict so you need unsafeInterleaveIO, but you need to put it on g b
13:35:28 <xs> norpan, but it is? g b unsafeInterleaveIO (...blah..)?
13:35:35 <xs> s/g b/& =/
13:35:37 <norpan> because that is the action you need to make non-strict
13:36:25 <xs> hmm. i don't understand?
13:37:01 <norpan> err, i mean on f b of course
13:37:19 <xs> ahh, hmm.
13:37:24 <norpan> sorry
13:37:40 <xs> ooh.
13:37:52 <xs> i'll try this, thanks
13:42:03 <xs> i do not thing this will work. it attempts to strictly construct the entire list before returning. this computation will not terminate.. so the unsafeInterleaveIO must cover the recursion, not f a?
13:42:30 <norpan> no
13:43:08 <norpan> unsafeInterleaveIO will bind to x without actually performing the action f b
13:43:28 <norpan> so that you will get the list immediately without any actions being performed
13:43:46 <norpan> as the only "real" IO being done is by f
13:44:25 <dolio> Won't that still construct an infinite list?
13:44:29 <xs> but in, g b = f b >>= \x -> g b >>= \x -> return (x:xs), g b is infinite?
13:44:53 <dolio> He needs to delay the tail of the list, too.
13:45:12 <norpan> oh, yeah
13:46:05 <norpan> actually, delaying the tail is sufficient
13:46:22 <norpan> so i was right from the beginning, but i was wrong
13:46:40 <norpan> it's too late in the evening for this
13:46:58 <xs> :)
13:47:07 <xs> alas, this solution has a space leak
13:49:14 <norpan> hey, i should know, I did exactly that unsafeInterleaveIO stunt in http://norpan.org/~martin/fps/Data/ByteString/UTF8.hs
13:49:17 <norpan> stupid me
13:50:16 <xs> hehe :)
13:51:03 <xs> hm maybe tail recursion will help
13:51:44 <norpan> how will you make it non-strict with tail recursion
13:51:52 <norpan> if you figure that out, please show me :)
13:53:59 <jbalint> hi, how can i write a function that gives abbcccdddd for abcd?
13:55:17 <norpan> that sounds like a pretty pointless function
13:55:53 <jbalint> i cant think of a way to express it
13:56:07 <basti_> is that a homework problem?
13:56:12 <jbalint> basically
13:56:19 <basti_> is it your homework?
13:56:24 <xs> jbalint, foldl?
13:56:28 <jbalint> not from a class
13:56:37 <basti_> I'd use [1..], map, repeat, (++)
13:56:43 <basti_> and maybe some others
13:56:48 <basti_> oh no replicate
13:56:53 <xs> yeah ;)
13:57:00 <xs> replicate, (++) and foldl
13:57:04 <jbalint> ok, thanks
13:57:04 <norpan> join . zipWith replicate [1..]
13:57:30 <norpan> hand that in for homework
13:57:53 <norpan> > join . zipWith replicate [1..] $ "abcd"
13:57:54 <lambdabot>  "abbcccdddd"
13:58:00 <norpan> hey, it worked :)
13:58:20 <norpan> master of the join
13:58:22 <dolio> ?type putStrLn . show
13:58:24 <lambdabot> forall a. (Show a) => a -> IO ()
13:58:33 <xs> join == concat?
13:58:50 <dylan> ?type join
13:58:52 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
13:58:59 <norpan> yeah
13:59:09 <xs> ohh, right
13:59:11 <xs> heh
14:04:03 <dolio> xs: What kind of code is using g that you get space leaks?
14:23:54 <ihope> So "class Foo a b | a -> b" means that for every possible a, there's only one b that can go with it?
14:25:20 <dolio> That sounds right.
14:25:29 <dolio> Given a, you can determine what b is.
14:25:37 <ihope> Ah.
14:42:45 <xs> dolio, g produces a list of images, i then process and render these images. the processing is an arrows implementation of a stream processor and the rendering is blitting to gtk2hs
14:46:40 * alec loves gtk2hs
14:48:09 <dolio> Ah, hmm...
14:48:46 <dolio> That's a lot more complicated than the toy examples I was playing around with.
14:50:17 <benja_> in re my earlier groaning about scientific articles, /me recognizes the fact that other textual sources can be just as weird. I just found this on Wikipedia:
14:50:20 <benja_> "Not everyone enjoys hearing soundbites. [citation needed]"
14:50:50 <benja_> s/just as weird/just as weird about the obvious/
14:51:36 <dolio> Heh. I was browsing the star trek articles recently, and one of them has something roughly equivalent to: "Fact: Beverly Crusher is hot."
14:52:05 <benja_> ouch =)
14:52:54 <dolio> Oh no. Somebody took it down.
14:53:32 <SamB> @google "Fact: Beverly Crusher is hot."
14:53:34 <lambdabot> No Result Found.
14:53:47 <lucca> clearly a conspiracy
14:53:48 <dolio> Well, it wasn't that blunt. But that was the general idea.
14:55:57 <dolio> Here we go:
14:56:02 <dolio> http://en.wikipedia.org/w/index.php?title=Beverly_Crusher&oldid=61658316
14:56:13 <dolio> "Crusher's look develops all the way through the series, until being thought of as the sexiest of the Star Trek women in the final series and the first STTNG movie, Generations. Troi, Uhura and Seven of Nine have also held this title on seperate occasions."
14:58:10 <benja_> lol
14:59:05 <benja_> if I didn't take Wikipedia so seriously, I would be tempted to slap a "[citation needed]" on that now ;)
14:59:47 <benja_> (although I suppose they might be able to find one...)
15:00:03 <dolio> That would be even more bizarre.
15:00:38 <dolio> I suppose they could cite The Offical Doctor Crusher Fan Page or something. :)
15:11:25 <joelr1> good evening!
15:15:50 <joelr1> does anyone know how to make darcs generate patches in a format suitable for input to patch?
15:16:07 <SamB> what kind of patches?
15:16:24 <heatsink> patch patches?
15:16:35 <SamB> I mean, does "darcs diff" do what you want?
15:22:33 <joelr1> SamB: well, it sort of does but the output does not look like a patch that i received
15:22:48 <SamB> oh?
15:22:52 <joelr1> this is a patch that i'm looking at http://www.it.uu.se/research/group/hipe/snapshots/patch-otp-0804-4-x86-sse2-exceptions
15:23:01 <joelr1> it looks nothing like the darcs diff output
15:24:27 * SamB doesn't have darcs diff output handy to compare
15:26:08 <joelr1> ok, darcs diff -u does it
15:26:10 <eivuokko> You might want to use -u
15:26:16 <joelr1> eivuokko: thanks!
15:26:40 <eivuokko> Heh, I was late anyway :-)
15:55:20 <eivuokko> mnislaih, Pong.
15:55:59 <mnislaih> eivuokko: did you mention early today or yesterday that you have added parallelism to the testsuite maybe ?
15:56:14 <eivuokko> Yeah
15:56:22 <eivuokko> It's buggy, I have revised patch.
15:56:39 <mnislaih> cool, are the patches up in the main repo ?
15:57:10 <eivuokko> Nope, the bad patches (with few bugs) are in an email, and revised patch is on my hd :-)
15:57:29 <mnislaih> I'd like to give it a try tomorrow hopefully. Send me the patches if you will, mnislaih@gmail.com
15:58:10 <eivuokko> Gladly :-)
15:58:40 <mnislaih> thanks :)
16:00:26 <lispy> this came as a surprise to me today
16:00:44 <lispy> > groupBy (==) [1,2,1,1,1,3,3]
16:00:46 <lambdabot>  [[1],[2],[1,1,1],[3,3]]
16:00:57 <lispy> are you expected to sort before you groupby?
16:01:03 <eivuokko> Yes.
16:01:26 <eivuokko> Well, that's the common case, anyway.
16:01:27 <lispy> hmm...okay
16:01:47 <lispy> > groupBy (==) (sort [1,2,1,1,1,3,3])
16:01:48 <lambdabot>  [[1,1,1,1],[2],[3,3]]
16:02:32 <alec> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v%3Agroup says "group function takes a list and returns a list of lists such that the concatenation of the result is equal to the argument"
16:02:43 <alec> (group is a special case of groupBy)
16:02:58 * lispy implemented splitOn :: Eq a => a -> [a] -> [[a]] and found it to be much easier to use than some of the others proposed
16:03:24 <lispy> alec: cool
16:03:47 <lispy> > group [1,1,3,3,2,1,3]
16:03:48 <lambdabot>  [[1,1],[3,3],[2],[1],[3]]
16:04:26 <lispy> i also found <+> :: String -> String -> String, (as opposed to the pretty printer version) worth having
16:04:44 <benja_> lispy: seems to me that when wrangling strings, the more general :: Eq a => [a] -> [a] -> [[a]] would be more useful and really not much harder to use in the special case
16:05:03 <lispy> benja_: perhaps
16:05:27 <lispy> benja_: in my case it takes just as many key strokes
16:05:31 <lispy> benja_: so i wouldn't notice
16:05:40 <benja_> then again, I come from the Python world and miss my 'split' and 'join' all the time ;)
16:05:50 <lispy> @type join
16:05:51 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
16:05:55 <lispy> we have join! ;)
16:06:00 <benja_> ;)
16:06:27 <lispy> > join $ group [1,1,3,3,2,1,3]
16:06:27 <lambdabot>  [1,1,3,3,2,1,3]
16:06:43 <lispy> ah nice, join . group = id for lists :)
16:07:02 <lispy> but with the Eq constraint
16:07:28 <benja_> @type (join . group)
16:07:29 <lambdabot> forall a. (Eq a) => [a] -> [a]
16:07:31 <syntaxfree> "The 2006 Fields medals, awarded every four years and described as the Nobel Prize for Mathematics, have been awarded at the International Congress of Mathematicians. The winners are Grigory Perelman (famous for the ideas underlying the proof of the Poincare and Thurston geometrization conjectures) ? who declined the prize, Terence Tao (a child prodigy famous for proving there are arbitrarily long arithmetic progressions of primes, but who works main
16:08:05 <lispy> syntaxfree: so he did decline
16:08:08 <lispy> odd
16:08:19 <lispy> guess he'll be even more famous now :)
16:08:22 <syntaxfree> "John Ball, president of the International Mathematical Union, said that he had urged Perelman to accept the medal, but Perelman said he felt isolated from the mathematics community and "does not want to be seen as its figurehead." Ball offered no further details of the conversation."
16:08:28 <syntaxfree> yeah, smart marketing.
16:36:36 <kfish> morning all
16:36:48 <kfish> does anyone have an example of using HUnit with cabal?
16:37:08 <kfish> ie. how/where to specify runTests
16:45:47 <lispy> if i have a cabalized project, is there a way to easily ghci load it?
16:45:58 <lispy> maybe just load the main module?
16:46:55 <lispy> hmm...that doesn't seem to be honoring {-# OPTIONS_GHC ... #-}
16:47:06 <lispy> maybe i need to tell ghci to allow extensions...
16:48:21 <eivuokko> OPTIONS_GHC doesn't work?  Is it on the first line of the file?
16:48:54 <eivuokko> Anyway, ghci know nothing about Cabal, so it's not always straightforward to load it in ghci if you got files to preprocess.
16:48:56 <lispy> ah, i neded -fglasgow-exts
16:49:06 <lispy> that's too bad
16:49:16 <lispy> ghci should become cabal aware :)
16:49:20 <eivuokko> Rather, Cabal should know about cabal.
16:49:25 <eivuokko> Err, know about ghci
16:49:31 <eivuokko> setup ghci ..
16:49:35 <lispy> well, how would :r work in that case?
16:49:56 <eivuokko> Hmm, good point.
16:50:32 <eivuokko> It's mainly a problem with preprocessing, anyway.
16:50:42 <eivuokko> Or is there other catches?
16:53:50 <lispy> hmm..
16:54:10 <lispy> well, i told ghci to load my Main.hs but it doesn't load all my modules since some of them aren't used from anywhere yet
16:54:28 <eivuokko> Hm
16:54:37 <lispy> if ghci were cabal aware, i would expect those modules to be known about even if not currently in scope
16:54:46 <lispy> but right now i have to load them by themselves to get them up
16:54:56 <lispy> and doing that unloads all my other modules :(
16:55:56 <eivuokko> :m +Foo.Bar
16:56:22 <lispy> in this case all i really want is to load some boiler plate i'm using to talk to my database and run some sql queries to see how i need to construct the real queries my program will do ;)
16:56:42 <lispy> but i find this is somewhat of a problem in general...i've wanted similar functionality with the darcs source
16:57:07 <eivuokko> Yes, with darcs sources it would often be nice.
16:58:24 <lispy> okay, so i added the module i want to load to Main.hs and hit :r and it's kinda what i wanted
16:58:29 <lispy> so i guess that's my workaround for now
16:58:53 <eivuokko> :)
17:01:01 <lispy> although, now when i run code from main i get:
17:01:03 <lispy> <interactive>:
17:01:05 <lispy> Main_stub.o: unknown symbol `_Main_zdftraveltimes_closure'
17:01:07 <lispy> so not all is well
17:01:38 <eivuokko> Hmm.
17:02:09 <lispy> hmm...now even cabal failed with undefined references (but to a different module)
17:02:13 <lispy> i should make clean...
17:02:19 <eivuokko> I think so..
17:02:32 <lispy> oh, i bet i need to configure
17:02:33 <eivuokko> I sort of fail to see why your ghci found .o
17:02:52 <eivuokko> Unless you pointed it to search for them in dist
17:03:24 <eivuokko> When using Cabal, you shouldn't have .o .hi etc next to the source, those should go in dist.
17:03:26 <lispy> no
17:03:42 <lispy> yeah, i let VH build this project so it should be fine
17:04:22 <lispy> okay so this is what happened
17:04:42 <lispy> looks like VH updated the .cabal file
17:04:49 <lispy> then i tried building outside of VH
17:05:15 <lispy> but i needed to do runghc Setup.lhs clean; runghc Setup.lhs configure; runghc Setup.lhs build
17:07:43 <lispy> well, doing that solved one of my problems but not the Main_stub.o problem
17:08:38 <eivuokko> Where is the Main_stub.o?
17:08:56 <lispy> oh weird
17:08:58 <lispy> it's in src
17:09:03 <lispy> with all my other source
17:09:42 <lispy> iirc i have it because i'm building a dll
17:09:57 <lispy> i think it's generated by ghc when it wants to compile with my DllMain.c
17:09:57 <eivuokko> It is because of foreign export/wrapper
17:10:06 <lispy> okay, yeah
17:10:13 <lispy> that makes sense
17:13:30 <swiert> \quit leaving
17:14:55 <eivuokko> Btw, how do you build dll?  Same way as vshaskell build does?
17:15:37 <lispy> it's probably similar, but i built the post-compile hook thingy from scratch
17:15:49 <eivuokko> Right
17:16:02 <eivuokko> Build lib, then call ghc --mk-dll with the lib and other things?
17:16:10 <lispy> yeah
17:16:22 <eivuokko> I was hoping we could get DLL-builds in Cabal for 6.6, and hence for new VH...but there's not a whole lot of support for it.
17:16:22 <lispy> i do that  in Setup.lhs
17:16:52 <eivuokko> Yeah, that's the way VH build does it as well.
17:16:55 <lispy> ah, i asked about it on one of the mail lists and Krashmir didn't say much other than he had to do something similar for VH
17:17:46 <eivuokko> With new ghc 6.6 you might have a bit easier time.  --make works with --mk-dll, and your probably just need to change the name of executable.
17:18:58 <aleko> i'm just learning haskell and i'm captivated by it, but i can't think of any good learning projects to practice it.  does anyone have any suggestions?
17:19:09 <aleko> *please
17:19:22 <lispy> aleko: what is your background?
17:19:29 <lispy> aleko: what are you interested in?
17:19:39 <aleko> lispy: C#, python (imperative)
17:19:59 <lispy> aleko: for a learning project i wrote an embedded language that compiles down to procmail syntax so that i could filter my mail more easily
17:20:55 <aleko> that's in the same field as what i'm doing: i'm writing a lexer/parser that outputs xml
17:21:00 <lispy> aleko: http://codersbase.com/index.php/Autoproc
17:21:36 <lispy> aleko: do you like math? you could write some library for math
17:22:11 <aleko> lispy: i've never done any math coding, so I wouldn't know what to write
17:22:33 <lispy> hmm..okay
17:22:51 <lispy> whatelse do you like?  You could write something to look at your mp3 collection and generate playlists
17:23:29 <lispy> aleko: what i'm getting at is, a good starting project involves something you're already interested in and have a decent idea how to do it
17:23:35 <lispy> then start hacking away with haskell
17:24:14 <aleko> thanks for the help.  i might to something with the internet protocol stack... maybe an irc client
17:24:29 <lispy> aleko: ah, yeah that could be fun
17:24:37 <lispy> aleko: make a general purpose IRC library
17:25:53 <aleko> but the problem is, I wouldn't feel like I was programming functionally (I checked lambdabot's source code, and pretty much every function looks imperative)
17:27:33 <lispy> well, haskell is pretty good at imperative coding
17:27:50 <lispy> but you definitely want to learn functional if you're just starting out
17:28:53 <aleko> i think i'll keep at my current project, which I have some background in (and I can look at your procmail language for inspiration)
17:29:01 <aleko> thank you *very* much
17:29:37 <lispy> np, i hope you enjoy haksell
17:29:39 <lispy> haskell*
17:31:04 <stepcut> haskell *is* the world's finest imperative language :)
17:31:31 <aleko> damn straight
17:31:47 <lispy> hence the "pretty good"...now if we could just get the finest to be "good" or "great" ;)
17:32:19 <lispy> when it can read my mind, it will be ready ;)
17:32:35 <aleko> the first time i read the "gentle introduction" (not so gentle) it blew my mind after years of imperative coding
17:34:06 <ihope> Blew your mind how?
17:34:17 <aleko> everything was different
17:34:44 <aleko> a language with complete referential transparency, with such powerful functions...
17:35:05 <aleko> and no side-effects without monads was a change
17:35:16 <aleko> but i must eat dinner now
17:36:17 <edwardk> aleko: yeah it kinda rocked me to the core too, hence why i'm still here ;)
17:47:10 <lispy> is there way to have apache automatically serve up syntax highlighted files when just looking at .hs files?
17:47:50 <lispy> so for example, if you browse to a directory on my server with source code in it and click on a .hs file i want to serve up a page taht looks just like the raw source but with some syntax highlighting added
17:48:07 <eivuokko> You could rewrite the urls atleast...but then you better have some way of downloading the originals.
17:48:33 <lispy> well, it's a darcs repo, so if they want the source, they can use darcs or get the tar ball
17:48:51 <lispy> so i don't feel so bad about giving them a htmlize version...
17:48:56 <lispy> but maybe it's more hassle than its worth
17:49:28 <eivuokko> I don't know solution right away, but I'd assume it's fairly easy to code up yourself.
17:49:46 <shekmalhen> it is possible, tho
17:50:03 <lispy> shekmalhen: any idea what it's called or where to look to learn to set it up?
17:50:17 <shekmalhen> one second
17:50:59 <lispy> code2html maybe? http://www.palfrader.org/code2html/manual.html
17:51:01 <lambdabot> Title: Code to HTML converter
17:51:45 <shekmalhen> lispy, well, you'll need an handler
17:52:10 <shekmalhen> but... what I can't figure out is a way to get the raw file, without syntax hilighting
17:57:39 <lispy> shekmalhen: hmm..
17:57:51 <lispy> i can use geshi for syntax highlighting i bet
17:57:57 <lispy> i have a geshi file for most languages
17:59:19 <shekmalhen> might do the trick :)
17:59:45 * kfish finds numericprelude (HUnit + cabal) fu
18:00:02 <lispy> but i should work on this later
18:00:38 <dolio> Would hscolor work?
18:01:50 * edwardk wonders if kfish is making a martial arts reference, or is missing one, or possibly 4 letters on the end there ;)
18:02:00 <lispy> coloring the files isn't the hard part (i don't think).  It's letting the  user get to the raw version and how to turn it on in the first place
18:02:22 * lispy notes that kung fu actually means 'hard work'
18:02:33 <shekmalhen> lispy, fu = ?
18:02:34 <shekmalhen> :)
18:02:41 <lispy> the chinese use a different word...'wushu'? for martial arts
18:02:53 <LordBrain> wikipedia gets vanadalized a lot.. but they do do a pretty good job of cleaning it up quickly.
18:03:21 <LordBrain> sorry was responding to an old thread
18:03:56 <dolio> I don't think setting a file type handler is too hard in apache.
18:04:15 <dolio> Although I don't have it installed right now to test.
18:04:55 <lispy> yeah it should be pretty easy
18:05:03 <lispy>      Action add-footer /cgi-bin/footer.pl
18:05:04 <lispy>      AddHandler add-footer .html
18:05:10 <lispy> that's an example from the apache manual
18:05:22 <lispy> that adds a footer to all .html files
18:05:27 <shekmalhen> yeah
18:05:29 <dolio> Yeah.
18:05:53 <shekmalhen> lispy, maybe with a bit of modrewrite magic? (to have access to the raw file)
18:07:26 <lispy> so i'm sort of thinking that clicking on the file should give you the output of geshi highlight and then maybe in that output is a link to the original...but yeah how to link up to the original is not clear
18:07:40 <lispy> because if i understand these handlers they would get in the way
18:09:38 <lispy> oh, or maybe the original source could be placed in a text box in side the page and you have to copy&paste to get it? that would be annoying tho
18:09:49 <eivuokko> Incredibly o.O
18:10:10 <shekmalhen> lispy, no
18:10:11 <shekmalhen> :)
18:10:30 <syntaxfree> can't javascript manipulate clipboards by now?
18:11:41 <shekmalhen> you had any problems installing ghc on debian sid recently?
18:12:21 <lispy> shekmalhen: yeah, i run amd64 so i'm a second class citizen...
18:12:53 <dylan> Likewise.
18:12:58 <shekmalhen> lispy, but... I'm on a plain old IA32 machine... but it seems to have a problem with libgmp and libgmp-dev
18:13:24 <dylan> my debian etch box can't be upgraded because ntp-server depends on ntp, and ntp conflicts with ntp-server.
18:13:36 <shekmalhen> dylan, something similar
18:13:39 <dylan> (in 32bit land)
18:14:34 <dylan> I assume people uploaded a new version of one without a new version of the other
18:14:52 <lispy> so it looks like i can use modrewrite + cgi to redirect the source requests to a geshi script that could maybe accept a parameter for "raw" output
18:16:03 <dylan> thankfully, ghc is still working fine.
18:16:12 <shekmalhen> :/
18:17:18 <eivuokko> lispy, How about having highlighting via rewrite and Foo.hs?hl, and add READMEs or something in directory listings to tell the user?
18:18:51 <dylan> apt-get just gives up on this box...
18:22:43 * syntaxfree has given up apt-get and package management in general.
18:22:58 <syntaxfree> Linux distros should just use .app bundles like OS X does.
18:23:29 <syntaxfree> I'm trying to figure Parsec out but I can't make sense of the docs.
18:25:10 <ibid> ugh
18:25:23 <SamB> yeah, installing in global places sucks!
18:25:45 <SamB> uninstalling sucks worse!
18:26:37 <SamB> you should just be able to remove the application icon, and maybe a directory in off your homedir if it is taking too much space...
18:26:37 <ibid> dylan: iirc ntp-server is obsolete and should be removed
18:26:50 <dylan> ibid: yes, but ntp seems to require it
18:27:53 <ibid> dylan: how does that manifest itself?
18:28:10 <dylan> ibid: it seems to be a recursively incorrect dependency.
18:28:15 <dylan> *recursive.
18:28:27 <dylan> but, after an update, it seems sane now
18:28:27 <ibid> dylan: that's not what i asked, how do you see it requires it?
18:29:00 <dylan> yes, earlier it said "ntp requires ntp-server, but ntp-server cannot be installed"
18:29:35 <ibid> dylan: but this is fixed now, you say?
18:29:38 <dylan> yeah
18:29:46 <dylan> it looked like an incomplete upload.
18:30:26 <ibid> and you say you are on testing?
18:30:36 <dylan> yes, on the x86 machine.
18:30:38 <ibid> that should not happen then
18:31:00 <ibid> i'd like to see the evidence myself, but cannot now if it is fixed :)
18:31:03 <dylan> it's not as bad as on amd64 -- a new vim-runtime comes around that is too new for the vim-perl package...
18:31:22 <ibid> dylan: are you sure you are on testig and not unstable?
18:31:32 <dylan> yes, only 'etch' sources on that server.
18:31:49 <dylan> it probably was close to 2 days since I last did an update, until just now
18:32:08 <ibid> hm
18:32:32 <ibid> i mean, on unstable that kind of stuff is common, but it should not happen in testing
18:33:00 <syntaxfree> why are Parsec parsers do actions?
18:33:06 <dylan> x86-testing usually works great. The only problems I have is amd64, and that is usually caused by cross-architecture stuff like vim-runtime being newer than compiled stuff.
18:33:16 <SamB> syntaxfree: because it is convenient to write them that way
18:33:20 <ibid> dylan: and that should not happen in testing
18:33:28 <ibid> (even in amd64)
18:33:31 <syntaxfree> as opposed to >>= I figure.
18:33:34 <SamB> also because parsec's parser types are in Monad
18:33:44 <syntaxfree> But why aren't they like String->Bool or something?
18:33:46 <dylan> It's the reason I use sid on my 64bit machine now
18:33:59 <ibid> dylan: huh?
18:34:20 <SamB> ... because String->Bool is not very useful?
18:34:43 <SamB> you want to get the parsed value, you know!
18:34:53 <dylan> ibid: at the time -- back in June or so, to upgrade my testing box required removing vim.
18:35:00 <dylan> ibid: so I upgraded to sid.
18:35:10 <syntaxfree> I can make absolutely no sense of Parsec!
18:35:10 <SamB> like, if you were parsing a program, you'd want the parser to return the program!
18:35:21 <syntaxfree> @paste
18:35:21 <lambdabot> http://paste.lisp.org/new/haskell
18:35:22 <SamB> not just say "yes this is a program!"
18:35:35 <SamB> @where ByteStringParser
18:35:36 <lambdabot> I know nothing about bytestringparser.
18:35:46 <lisppaste2> syntaxfree pasted "what is this doing??" at http://paste.lisp.org/display/24579
18:35:56 <SamB> @where+ ByteStringParser http://hackage.haskell.org/~paolo/darcs/ByteStringParser
18:35:56 <lambdabot> Done.
18:36:04 <SamB> @where ByteStringParser
18:36:05 <lambdabot> http://hackage.haskell.org/~paolo/darcs/ByteStringParser
18:36:11 <syntaxfree> first it says "char '('"
18:36:26 <syntaxfree> then it calls the parser function itself.
18:36:33 <syntaxfree> THEN it has another "char" function. Huh?
18:37:11 <SamB> ByteStringParser is a much shorter module
18:37:14 <syntaxfree> the Parsec docs are written like a research paper, not like  a user's guide. What does "char" do?
18:37:28 <ibid> dylan: well, that's strange anyway :)
18:37:29 <syntaxfree> @type Parsec.char
18:37:30 <SamB> char parses a single character?
18:37:30 <lambdabot> Couldn't find qualified module.
18:37:40 <syntaxfree> char :: Char->Bool?
18:37:48 <SamB> @type Text.ParserCombinators.Parsec.char
18:37:49 <lambdabot> forall st. Char -> Text.ParserCombinators.Parsec.Char.CharParser st Char
18:38:09 <SamB> Prelude Text.ParserCombinators.Parsec> parseTest (char 'a') "a"
18:38:09 <SamB> 'a'
18:38:19 <SamB> Prelude Text.ParserCombinators.Parsec> parseTest (char 'a') "b"
18:38:19 <SamB> parse error at (line 1, column 1):
18:38:19 <SamB> unexpected "b"
18:38:19 <SamB> expecting "a"
18:38:23 <syntaxfree> I've seen that behaviour, but I don't understand it.
18:38:45 <syntaxfree> the parser expects a char 'a'. Then, when it recognizes, it returns 'a'?
18:39:51 <SamB> yeah
18:40:03 <SamB> sources may be useful for understanding!
18:40:48 <SamB> char :: Char -> CharParser st Char
18:40:48 <SamB> char c              = satisfy (==c)  <?> show [c]
18:40:52 <greenrd> I know that (forall a. Maybe a -> [a]) means a function that turns maybes into lists and works for all a, but what does simply (forall a. Maybe a) mean? Is it even inhabited?
18:41:27 <SamB> perhaps isJust inhabits it?
18:41:29 <SamB> @type isJust
18:41:31 <lambdabot> forall a. Maybe a -> Bool
18:41:37 <syntaxfree> aorb = do { char 'a'; aorb;} <|> do { char 'b'; aorb;} <|> return ()
18:41:39 <SamB> er, no...
18:41:47 <SamB> but isJust should be able to *take* one...
18:41:53 <SamB> @type Nothing
18:41:54 <lambdabot> forall a. Maybe a
18:41:55 <syntaxfree> *Main> parseTest aorb "aba"
18:41:56 <greenrd> well, it's not a function type at all
18:41:56 <syntaxfree> ()
18:41:57 <syntaxfree> gr!
18:42:02 <SamB> ah, yeah, there we go! Nothing!
18:42:26 <greenrd> aha
18:42:44 <SamB> eh
18:42:49 <SamB> syntaxfree: try this instead
18:43:04 <SamB> many (char 'a' <|> char 'b')
18:43:36 <syntaxfree> many?
18:43:43 <syntaxfree> the docs don't mention that.
18:43:58 <SamB> @type Text.ParserCombinators.Parsec.many
18:44:00 <lambdabot> forall a st tok. Text.ParserCombinators.Parsec.Prim.GenParser tok st a -> Text.ParserCombinators.Parsec.Prim.GenParser tok st [a]
18:44:04 <SamB> syntaxfree: what docs are you reading?
18:44:07 <SamB> @google parsec docs
18:44:11 <lambdabot> http://imagine.gsfc.nasa.gov/docs/dictionary.html
18:44:11 <lambdabot> Title: Imagine the Universe! Dictionary
18:44:12 <syntaxfree> http://www.cs.uu.nl/~daan/download/parsec/parsec.html#UserGuide
18:44:17 <SamB> @google daan parsec
18:44:20 <lambdabot> http://www.cs.uu.nl/~daan/parsec.html
18:45:07 <SamB> http://www.cs.uu.nl/~daan/download/parsec/parsec.html#many
18:45:28 <ibid> greenrd: forall a. Maybe a is inhabited by Nothing and Just undefined
18:45:55 <dons> and undefined
18:46:01 <ibid> yes
18:46:07 <SamB> dons: but that is difficult to work with
18:46:13 <dons> :)
18:46:26 <syntaxfree> I think I don't understand what a Parser is to begin with. That's not clear in the docs.
18:46:41 <SamB> what does it sound like?
18:46:53 <dons> ?foldoc parser
18:46:54 <SamB> it is a thing that you can use to parse input!
18:46:55 <lambdabot> *** "parser" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
18:46:55 <lambdabot> parser
18:46:55 <lambdabot>  
18:46:55 <lambdabot>     <language> An {algorithm} or program to determine the
18:46:55 <lambdabot>     syntactic structure of a sentence or string of symbols in some
18:46:55 <ibid> syntaxfree: are you familiar with predictive parsing and LL(1)?
18:46:57 <lambdabot> [7 @more lines]
18:46:57 <SamB> usually text
18:47:05 <syntaxfree> that I understand.
18:47:12 <syntaxfree> I don't understand what the Parser type in Parsec is :)
18:47:29 <SamB> it is the way Parsec represents parsers
18:47:41 <syntaxfree> apparently it's not a type, it's a monad like IO. Or at least a functor.
18:47:48 <ibid> syntaxfree: in parsec, a parser is an abstract entity
18:47:49 <SamB> it is a type constructor
18:48:01 <SamB> @kind Text.ParserCombinators.Parsec.Parser
18:48:03 <lambdabot> * -> *
18:48:06 <SamB> @kind Text.ParserCombinators.Parsec.GenParser
18:48:08 <lambdabot> * -> * -> * -> *
18:48:15 <SamB> @kind Text.ParserCombinators.Parsec.CharParser
18:48:17 <lambdabot> * -> * -> *
18:48:24 <syntaxfree> Oh,  god. Maybe I need to go back to monad school.
18:48:32 <SamB> actually, Parser itself is type synonym
18:48:33 <syntaxfree> I was getting along just fine with IO and Random.
18:48:34 <ibid> syntaxfree: and there is a function (i forget which) that turns this abstract entity into a function
18:48:34 <SamB> @hoogle Parser
18:48:36 <lambdabot> Language.Haskell.Parser :: module
18:48:36 <lambdabot> Text.ParserCombinators.Parsec.Prim.Parser :: type Parser a
18:48:36 <lambdabot> Distribution.InstalledPackageInfo.ParseResult :: data ParseResult a
18:49:01 <SamB> ibid: runParser, maybe?
18:49:35 <SamB> runP does too, but I think that is probably exported
18:49:44 <SamB> er, probably *not* exported
18:50:31 <ibid> syntaxfree: the reason Parser is declared as a monad is that the programmer can reuse generic monad thingies for Parser if they so choose
18:50:50 <ibid> syntaxfree: it's for convenience, not an absolute requirement
18:50:53 <SamB> such as finger-memories!
18:50:55 <syntaxfree> I don't understand do notation for Parsers.
18:51:07 <SamB> translate it into >> and >>= then
18:51:20 <syntaxfree> I probably won't understand those either. I'll try though.
18:51:22 <ibid> syntaxfree: do notation is just syntactic sugar for >>=
18:51:27 <syntaxfree> I know.
18:52:03 <SamB> @google Parsec tutorial
18:52:07 <ibid> syntaxfree: but the basic idea is "do a ; b" means the parser that parses input that matches a and b in sequence
18:52:08 <lambdabot> http://pcl.cs.ucla.edu/slides/Parsec99.html
18:52:08 <lambdabot> Title: PARSEC Workshop '99 Slides
18:52:16 <SamB> @google Haskell Parsec tutorial
18:52:19 <lambdabot> http://conferences.oreillynet.com/cs/os2006/view/e_sess/8898
18:52:19 <lambdabot> Title: O'Reilly Open Source Convention - July, 24-28, 2006 - Portland, OR
18:52:31 <SamB> @google site:haskell.org Parsec tutorial
18:52:36 <lambdabot> http://www.haskell.org/haskellwiki/Books_and_tutorials
18:52:36 <lambdabot> Title: Books and tutorials - HaskellWiki
18:52:40 <SamB> hmm...
18:52:44 <ibid> hrm, google offline and then paste the url perhaps?
18:52:51 <SamB> @google site:haskell.org/tmrwiki Parsec
18:52:53 <lambdabot> http://www.haskell.org/tmrwiki/ArrowsIntroduction
18:52:54 <lambdabot> Title: ArrowsIntroduction - TmrWiki
18:52:57 <SamB> hmm...
18:53:03 <ibid> SamB: !
18:53:16 <SamB> sorry
18:53:21 <SamB> incidentally...
18:53:25 <SamB> how does one google offline?
18:53:31 * ibid never understood the usefulness of @google
18:53:36 <ibid> SamB: off the irc line :)
18:53:51 <lispy> who uses google anyway?  i use webcrawler
18:53:55 <ibid> ie on a web browser
18:54:11 <syntaxfree> webcrawler?
18:54:13 <SamB> lispy: me, duh!
18:54:15 <syntaxfree> webcrawler??
18:54:18 <SamB> I coded up @google after all!
18:54:24 <ibid> syntaxfree: did what i said two minutes ago make any sense to you?
18:54:42 <syntaxfree> oh, I lost it in the flood.
18:54:52 <ibid> syntaxfree: but the basic idea is "do a ; b" means the parser that parses input that matches a and b in sequence
18:54:58 <ibid> (repost)
18:54:58 <syntaxfree> so.
18:55:08 <syntaxfree> x = do {a; x; b}  means?
18:55:36 <ibid> that parser never succeeds :)
18:56:02 <ibid> there is no finite input that contains itself as a substring
18:56:04 <SamB> the usefullness of @google is to demystify the process of finding information? or maybe to save typing for finding easy to find things...
18:56:16 <SamB> and telling people where they are
18:56:24 <ibid> SamB: yes, it makes sense when you do find it the first time
18:56:33 <SamB> obviously I was carried away
18:56:37 <ibid> SamB: but not if you flood the channel with failed attempts
18:57:21 <syntaxfree> parens  = do{ char '('; parens; char ')'; parens} <|> return ()
18:57:28 <syntaxfree> isn't that the same thing, ibid?
18:57:42 <ibid> syntaxfree: no, because you now use <|>
18:57:46 <SamB> ack
18:57:49 <syntaxfree> oh.
18:57:52 <ibid> syntaxfree: are you familiar with gramars?
18:57:56 <ibid> +m
18:58:04 <ibid> context-free ones
18:58:07 <SamB> I really need to find the notebook where I wrote more material for http://www.haskell.org/tmrwiki/SamBronson_2fInProgress
18:58:09 <lambdabot> Title: SamBronson/InProgress - TmrWiki
18:59:40 <syntaxfree> context-free grammars, yes. Parsers, no.
18:59:52 <syntaxfree> I learned that stuff in linguistics, a long long time ago :)
19:00:39 <SamB> syntaxfree: well, in computer programming, we like to construct *parse trees* or other results out of parsed things
19:00:59 <SamB> we don't like to just say "yeah it parsed" or "no that did not parse!"
19:01:01 <dons> heh, when I tried to look for some mac related stuff in google, why do I always type "Appel" ?
19:01:11 <SamB> @google Appel
19:01:11 <lispy> heh
19:01:13 <lambdabot> http://www.cs.princeton.edu/~appel/
19:01:13 <lambdabot> Title: Andrew Appel's Home Page
19:01:29 <syntaxfree> and parse trees are?
19:01:45 <ibid> syntaxfree: you may know them as structral trees
19:01:48 <SamB> syntaxfree: they are datastructures!
19:01:54 <Korollary> Wood
19:02:00 <SamB> for instance...
19:02:07 <SamB> type BFInstrs = [BFInstr]
19:02:07 <SamB> data BFInstr = Loop BFInstrs
19:02:07 <SamB>              | Prev | Next
19:02:07 <SamB>              | Decr | Incr
19:02:07 <SamB>              | GetC | PutC
19:02:10 <ibid> syntaxfree: for example, the phrase tree in natural language analysis
19:02:16 <SamB>                deriving (Show)
19:03:07 <ibid> syntaxfree: but my point was, if you have a production foo -> a b 'c' d in a grammar, the corresponding parser is foo = do { a; b; char 'c'; d }
19:03:28 <syntaxfree> hmm.
19:03:39 <ibid> syntaxfree: and if you have two productions foo -> bar and foo -> blah, then that becomes foo = bar <|> blah
19:03:39 <syntaxfree> It's getting late, here.
19:03:45 <ibid> it's early here :)
19:03:47 <ibid> 5am
19:03:53 <syntaxfree> ah, that part I understood :)
19:03:58 <SamB> ibid: nono! that is EXTREMELY late
19:04:04 <syntaxfree> @localtime syntaxfree
19:04:08 <ibid> SamB: i woke up at 4am
19:04:12 <SamB> syntaxfree: do you know BF?
19:04:24 <ibid> what's BF?
19:04:29 <syntaxfree> I know BNF.
19:04:32 * dcoutts is going to bed a 6:30 once he gets on a train
19:04:33 <SamB> brainf*ck
19:04:37 <ibid> ach
19:04:45 <syntaxfree> Ah. Heard about it.
19:05:19 <ibid> syntaxfree: the tricky point is, the translation i gave works only if the gramar is not left-recursive
19:05:54 <ibid> syntaxfree: so that requires grammar massage for most languages :)
19:06:06 <SamB> the one with [] for loops, + and - for changing the value at the address, < and > for changing the address, and , and . for I/O?
19:06:14 <ibid> well, infix operator stuff at least
19:11:22 <SamB> or, you know...
19:11:46 <dolio> BF is no Shakespeare.
19:11:52 <dolio> ?google shakespearelang
19:11:55 <lambdabot> http://shakespearelang.sourceforge.net/report/shakespeare/shakespeare.html
19:11:55 <lambdabot> Title: The Shakespeare Programming Language
19:13:01 <ibid> ?google perligata
19:13:04 <lambdabot> http://www.csse.monash.edu.au/~damian/papers/HTML/Perligata.html
19:13:05 <lambdabot> Title: Lingua::Romana::Perligata -- Perl for the XXIimum Century
19:15:25 <Korollary> That is funny.
19:30:38 <dons> ?users
19:30:40 <lambdabot> Maximum users seen in #haskell: 235, currently: 195 (83.0%)
19:32:05 <Korollary> Hah. Perelman indeed turned down the Fields Medal.
19:32:44 <dons> now he's _really_ famous
19:33:43 <dolio> It's all part of his devious plan.
19:34:09 <dons> maths guys are so wacky
19:34:21 <dons> I wonder if Oleg would turn down a Lambda Medal?
19:35:22 <dons> anyone want to go to St. Petersburg and install GHC on Perelman's laptop (and give him a laptop?).
19:35:31 <dons> I think he'd make a good haskell programmer
19:35:40 <Korollary> Now that he doesn't want to do math
19:35:46 <dons> right!
19:36:00 <Korollary> Because monads etc are so far from it
19:36:06 <dons> yeah
19:36:14 <dons> it'll be a refreshing oasis
19:36:26 <Korollary> I bet he'd rather become and ajax hacker
19:36:34 <dons> hah
19:37:58 <Korollary> "arXiv.org servers are currently under very heavy load due to demand for Grisha Perelman.s papers, published only as arXiv.org e-prints, which are available below.."
19:38:51 <dons> heh
19:39:22 <dons> maybe its a viral marketing campaign
19:39:29 <Korollary> Somebody who 'can' read that paper didn't know about it until the award was given?
19:39:30 <dons> and the papers are for some new flavour of Coke
19:39:43 <dons> seems unlikely, doesn't it ..
19:40:03 <Korollary> slashdotted
19:40:19 <dons> I wonder if there'd be a rush on type systems papers if we had a real Lambda Medal
19:40:45 <dons> oh, that's the Turing prize, I suppose
19:40:50 <Korollary> You are really sold on this Lambda Medal idea
19:40:56 <dons> hehe
19:41:13 <dons> you're not saying you don't want one??
19:41:26 <Korollary> I am not worthy, whatever it is.
19:41:42 <dons> I suggest you refuse to accept it then
19:41:55 <dons> it will make you only more worthy
19:42:15 <Korollary> And I shall also denounce the whole lambda deal and write explicit for loops.
19:42:47 <dons> that would be in character
19:43:50 <coffeemug> hey everyone
19:44:16 * Korollary whips up his enterpricey IDE that inserts public void interface extends zigzag() everywhere
19:44:30 <coffeemug> I get weird issues when compiling with ghc 6.5
19:44:40 <coffeemug> basically I have a simple function
19:45:14 <coffeemug> main = do putStr "> "
19:45:14 <coffeemug>                  x <- getLine
19:45:14 <coffeemug>                  putStr x
19:45:22 <dons> indenting is wrong
19:45:31 <coffeemug> when I evaluate main from ghci or hugs
19:45:35 <coffeemug> it behaves as I would expect
19:45:42 <coffeemug> ">" shows up
19:45:45 <coffeemug> I type something in
19:45:52 <coffeemug> and the program prints it back
19:46:02 <coffeemug> but when I compile it using ghc and run the exe
19:46:03 <dons> oh, that's buffered IO outside of ghc, though
19:46:17 <dons> you'll want to: putStr "> " >> hFlush stdout
19:46:21 <coffeemug> I get a blank screen
19:46:24 <dons> or set the IO to be unbuffered
19:46:42 <coffeemug> stdout is bufferred by default?
19:46:47 <coffeemug> hmm
19:46:53 <coffeemug> does putStrLn flush automatically?
19:46:56 <dons> yep
19:47:00 <coffeemug> because that's the behavior I encounter
19:47:02 <coffeemug> ahhh, I see
19:47:21 <dons> but you want to either explictly flush, or set unbuffered IO
19:47:32 <dons> ?hoogle Buffere
19:47:33 <lambdabot> No matches found
19:48:00 <dons> hSetBuffering NoBuffering
19:48:25 <dons> hSetBuffering stdout NoBuffering -- actually
19:48:35 <dons> ?docs System.IO
19:48:36 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
19:48:50 <coffeemug> hmm
19:49:00 <coffeemug> what would you recommend?
19:49:09 <dons> I'd just do an hFlush stdout
19:49:12 <coffeemug> and why is bufferring turned on by default?
19:49:18 <coffeemug> this seems sort of unintuitive
19:49:21 <dons> efficiency, presumably
19:49:22 <coffeemug> not something one would expect
19:49:40 <dons> same thing in perl, if I remember my perl
19:49:47 <dons> you have to set $| = 1 or something
19:49:50 <Lemmih> Isn't stdout line-buffered by default?
19:49:55 <kfish> the problem is that handles aren't flushed automatically on the automatic close that comes from program exit
19:50:10 <coffeemug> efficiency makes sense :)
19:50:19 <dons> Lemmih: yeah, I think so
19:50:41 <kfish> which is the expected behaviour with any system based on C stdio
19:51:04 <dons> yeah
19:51:41 <kfish> ie. it's nothing to do with efficiency
19:51:50 <coffeemug> well
19:51:53 <coffeemug> if I were to do
19:52:07 <coffeemug> printf "..."; read...
19:52:14 <coffeemug> it will work as expected
19:53:28 <dons> import System.IO
19:53:28 <dons> main = do
19:53:28 <dons>     hSetBuffering stdout NoBuffering
19:53:28 <dons>     putStr "> "
19:53:28 <dons>     s <- getLine
19:53:30 <dons>     print (reverse s)
19:53:36 <dons> $ ./a.out
19:53:36 <dons> > xyz
19:53:37 <dons> "zyx"
19:53:37 <lambdabot>  Not in scope: `xyz'
19:54:05 <Korollary> That is true
19:54:56 <coffeemug> yeah, I understand
19:55:00 <coffeemug> I fixed it by doing hFlush
19:55:22 <coffeemug> it's just a general concern
19:55:37 <coffeemug> this kind of stuff turns off newcomers
19:56:04 <coffeemug> when default behavior is pretty much at odds with what one would expect
19:56:08 <dons> it only comes up if you try to print a line without a \n, as in many languages though
19:56:12 <dons> i.e. perl and C
19:56:17 <Korollary> I actually don't know why cout flushes when a cin intervenes in C++.
19:57:05 <dons> coffeemug: oh, you might want to use 'readline' instead :)
19:57:06 <kfish> dons: the same thing happens when, say, you blat binary data to stdout with fps and don't hClose stdout
19:57:09 <dons> since then you get line editing
19:57:26 <dons> kfish: sure. yay for buffering
19:57:46 <dons> though now, what was the recent change to buffering SimonM put in
19:57:53 <dons> Lemmih: rememeber that?
19:58:10 <kfish> dons: well, no, i'd suggest that on program exit opened handles should be flushed and closed (as they are in stdio)
19:58:43 <Lemmih> dons: Simon changed the buffering?
19:58:45 <dons> that may well be true. do we need to submit a patch, you think?
19:58:56 <dons> Lemmih: yeah, maybe just in gHC though
19:58:58 <kfish> ie. forcing the user to close a handle they didn't explicitly open is a bit wierd
19:59:23 <dons> hmm
19:59:43 <dons> "  * patch applied (packages/base): default to NoBuffering on Windows for a read/write text file
19:59:46 <dons>     Simon Marlow
19:59:47 <coffeemug> readline?
19:59:49 <dons> "
19:59:49 <dons> http://www.haskell.org/pipermail/cvs-all/2006-June/047985.html
19:59:51 <lambdabot> Title: patch applied (packages/base): default to NoBuffering on Windows for a read/writ ...
19:59:52 <coffeemug> where's that?
19:59:58 <dons> coffeemug: yep, in -package readline
20:00:04 <dons> let me find an example for you
20:00:11 <Korollary> lisppaste2: url
20:00:11 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
20:00:17 <coffeemug> it's ok, I'll find on hoogle
20:00:18 <coffeemug> thanks
20:00:23 <dons>         s <- readline "lambdabot> " -- read stdin
20:00:24 <dons>         case s of
20:00:24 <dons>             Nothing -> error "<eof>"
20:00:25 <dons>             Just x ->  ...
20:00:38 <dons> a better putStr, since you get history and editing and so on
20:01:01 <lisppaste2> Korollary pasted "cout flushes because of cin" at http://paste.lisp.org/display/24582
20:02:04 <coffeemug> hmm
20:02:07 <coffeemug> what do you mean?
20:02:23 <coffeemug> I get history and editing with regular getLine/putStr
20:02:45 <dons> hmm?
20:02:51 <dons> do you have some fun termio setup?
20:03:05 <coffeemug> just plain old windows xp with Visual Haskell
20:03:08 <dons> ah
20:03:22 <coffeemug> but I can build without visual haskell, still works
20:03:26 <coffeemug> so I guess it's a windows thing
20:03:37 <dons> yeah
20:04:07 <coffeemug> ok, so according to the patch default is no bufferring now, it just didn't make it to 6.5 yet, right?
20:05:09 <dons> wasn't it a patch for file IO though?
20:05:34 <Pseudonym> I don't know if this is namedropping or not, but I met Terry Tao once.
20:05:42 <Korollary> Pseudonym: Get out!
20:05:54 * Pseudonym hangs head in shame
20:05:59 <Pseudonym> He won't remember me.
20:06:00 <Korollary> Pseudonym: You should not wash that hand!
20:06:14 <Pseudonym> It's the same hand I shook Phil Wadler's with.
20:06:27 <Pseudonym> And Phil's hand shook both Curry and Howard.
20:06:34 <dons> the same hand!? wow!
20:06:42 <Pseudonym> At the same conference, no less.
20:06:52 <Korollary> There you go. 6 degrees of Pseudonym
20:06:56 <Pseudonym> Indeed.
20:06:57 <dons> whoa Curry <- Psudonym -> Howard
20:07:09 <Pseudonym> No, Curry <- Wadler -> Howard
20:07:17 <coffeemug> dons: should I send an email to GHC list about this?
20:07:31 <dons> coffeemug: possibly, yes. simonM should reply with something interesting
20:07:42 <Pseudonym> As far as reflected glory goes, I feel like a raytraced sphere over an infinite chessboard.
20:07:47 <coffeemug> ok, I'll do that
20:07:53 <coffeemug> and now for some positive feedback
20:07:59 <coffeemug> haskell is pretty freakin' amazing
20:08:06 <dons> coffeemug: perhaps mention that you felt the behaviour wasn't desirable for a newbie?
20:08:12 <dons> but be delicate about it.. ;)
20:08:27 <coffeemug> I gave it a whirl by trying to write a small Lisp interpreter
20:08:33 <dons> if you can produce some evidence that other languages get it right (i.e. C++) that would be good
20:08:40 <dons> coffeemug: oh, how'd that go?
20:08:40 <coffeemug> and I literally couldn't believe how far I got in so little time
20:08:43 <coffeemug> with so little code
20:08:54 <dons> hehe. have you seem the 'Scheme in 48 hours.. in haskell" tutorial?
20:08:58 <coffeemug> that's considering that I'm pretty much a Haskell newbie
20:09:09 <coffeemug> I heard about it but I didn't look at it
20:09:28 <Pseudonym> Oh, dons, where's the plugin?  Hmmm?
20:09:30 <coffeemug> I'm doing it on my own and given that I'm new to haskell the speed I'm progressing at is really unbelievable
20:09:34 <kfish> coffeemug, dons: `man stdio` might provide some evidence :)
20:09:57 <kfish>  If the main function returns to its original
20:09:57 <kfish>        caller, or the exit(3) function is called, all open  files  are  closed
20:09:57 <kfish>        (hence  all  output  streams  are  flushed) before program termination.
20:09:57 <kfish>        Other methods of program termination, such as abort(3)  do  not  bother
20:09:57 <kfish>        about closing files properly.
20:10:07 <dons> ok. so that's one issue
20:10:22 <coffeemug> my last Lisp interpreter was in C++ and I even though I'm a pretty advanced C++ programmer it took me an order of magnitude more time
20:10:25 <dons> (and I actually thought they were flushed -- seems like a bug)
20:10:25 <Pseudonym> coffeemug: That's not surprising.  I think how fast you progress in Haskell is a function of how bad your habits were before you started.
20:10:38 <Pseudonym> The worse your habits, the slower you are.
20:10:56 <dons> $ ./freetheorem
20:10:56 <dons> id :: a -> a
20:10:56 <dons> f_1 . id = id . f_1
20:11:05 <dons> now, to plugin-inafy
20:11:06 <Pseudonym> Cool.
20:11:14 <Pseudonym> BTW, you don't have to make it a process.
20:11:16 <coffeemug> my habbits were average
20:11:17 <Pseudonym> It's a library.
20:11:26 <coffeemug> just the language is amazing
20:11:35 <coffeemug> I'm still not sure if it's specific to the problem domain I chose
20:11:36 <dons> Pseudonym: yeah, but will it diverge?
20:11:39 <Pseudonym> Nope.
20:11:47 <coffeemug> because haskell seems to be very good specifically at this kind of stuff
20:12:05 <Pseudonym> I can't guarantee that a future bug won't make it diverge, but it's designed not to.
20:12:08 <dons> ok
20:12:40 <Pseudonym> My local copy now supports arrows, BTW./
20:12:51 <Pseudonym> I've already discovered two interesting things.
20:12:55 <dcoutts> dons, I don't believe that ghc guarantees flushing/closing file handles before program terminatin. It's related to it apparently being impossible to guarantee finalisation in GC.
20:13:07 <Pseudonym> Two of the arrow axioms aren't axioms.  They're consequences of the free theorem for first.
20:13:10 <dcoutts> or something like that
20:13:30 <dons> hmm.
20:13:37 <dcoutts> I've seen cases where one must explicitly flush before terminating
20:13:45 <dons> yeah, I think I have too
20:15:15 <dons> dcoutts: so no holida
20:15:23 <dons> ys, but all patches pushed?
20:15:39 <dcoutts> dons, I'm getting on a train in two hours
20:15:44 <dons> cool
20:15:51 <dcoutts> dons, no more patches, I've been packing
20:16:08 <dcoutts> I did look at the python string api
20:16:10 <dons> right, just checking :)
20:16:13 <dons> ah, yes
20:16:14 <dcoutts> some things we might consider later
20:17:25 <dons> i'll make a todo now
20:17:25 <dcoutts> we've got join but not split right?
20:17:25 <dons> we have a split, but not _the_ split
20:17:25 <dcoutts> ah, our split is on a single byte/char
20:18:17 <dcoutts> python's is on a string, though I expect people usually use just a char
20:18:48 <coffeemug> ok, just sent an email about the bufferring issue
20:19:02 <dons> coffeemug: yeah, that's fine
20:19:14 <coffeemug> god I love this
20:19:24 <coffeemug> I literally got a lisp interpreter in half a day
20:19:29 <dons> though the larger issue of flushing on existing seems to be a harder problem (and not one you were thinking about)
20:19:33 <dons> exiting.
20:19:44 <dons> coffeemug: want to write a tutorial?? :)
20:19:52 <coffeemug> dons: I absolutely will
20:19:54 <dons> "Lisp in 6 Hours... In Haskell"
20:19:57 <Pseudonym> It's a rite of passage to write a Haskell tutorial.
20:20:05 <dons> or a lambdabot plugin
20:20:09 <Pseudonym> Right.
20:20:16 <coffeemug> I'll publish it on defmacro.org
20:20:25 <dons> hmm, someone should really write a plugin to write tutorials...
20:20:43 <coffeemug> I owe it to the haskell community anyway after posting an article about some minor roadblocks that turn people off
20:20:45 <dons> coffeemug: you should also CC. haskell-cafe@haskell.org (or at least here)
20:20:47 <Korollary> coffeemug: Are you the guy who wrote that intro to fp article at defmacro.org?
20:20:52 <Pseudonym> *FreeTheorem> putStrLn $ freeTheoremStr "idArr :: A a a"
20:20:53 <Pseudonym> idArr >>> arr f_1 = arr f_1 >>> idArr
20:20:59 <coffeemug> yeah, I'm the same coffeemug
20:21:08 <dons> Pseudonym: nice!
20:21:33 <Korollary> coffeemug: We've exchanged emails about it (re: lazy eval and i/o, etc.)
20:21:53 <coffeemug> Korollary: what's your email address, let me look it up :)
20:22:05 <Korollary> coffeemug: koray ... @gmail
20:22:09 <Pseudonym> It assumes that any type with one polymorphic argument is a Functor, and any type with two arguments is an Arrow.
20:22:22 <Pseudonym> Because they have the nice mapping properties that make nice free theorems.
20:23:39 <coffeemug> yep, I remember that
20:23:57 <coffeemug> it's actually pretty amazing how such tutorials open up people's minds a little
20:24:13 <coffeemug> I received like 200 emails from people just saying they'll pick up a book on haskell or lisp
20:24:24 <dons> presenting a problem from their home domain, in the new language, is a good idea
20:24:27 <coffeemug> now if we could only get rid of the minor roadblocks
20:24:30 <dons> since they understand the difficulties already
20:24:57 <coffeemug> I had to get through quite a few annoying things to start doing some "real" haskell stuff
20:25:05 <coffeemug> and I feel these are completely unnecessary
20:25:14 <dons> coffeemug: that's interesting. care to elaborate?
20:25:24 <dons> (its a known issue that windows support is not as good as it could be)
20:25:40 <dons> so I see you're running 6.5? why's that?
20:26:00 <coffeemug> dons: well, one issue was that standard graphics library that's bundled with ghc and hugs doesn't work on windows
20:26:08 <coffeemug> in ghc a window takes 5 minutes to open
20:26:20 <dons> right, you mean SOE?
20:26:21 <coffeemug> and in latest stable hugs release some dll is missing from the build
20:26:25 <dons> (its not so standard)
20:26:32 <coffeemug> SOE as well as the HGL
20:26:36 <coffeemug> SOE is just a wrapper
20:26:47 <dons> gtk2hs and wxHaskell are the standard graphics libs now days
20:27:05 <coffeemug> well, it may or may not be standard but when I go to haskell.org and click on "Standard libraries"
20:27:07 <dons> SoE is really really old and barely maintained, as you found
20:27:21 <dons> right. we do have an issue with making clear what is considered standard now
20:27:24 <coffeemug> HGL is there
20:27:34 <dons> though just yesterday a page has started with 'recommendations'
20:27:38 <dcoutts> I have a new implementation of SOE that works with Gtk2Hs-0.9.10
20:27:52 <coffeemug> well, I understand that and don't really have a problem with it
20:27:55 * dcoutts tries to find where he put it
20:28:06 <coffeemug> but this single issue *will* turn off 95% of people that try haskell
20:28:08 <dons> coffeemug: yeah, but its a general problem you identify
20:28:27 <coffeemug> another issue is lack of a haskell-in-a-box
20:28:29 <coffeemug> so to speak
20:28:34 <dons> right. they should know to use gtk2hs, but don't know that. how do we fix that then? short of hackage-cpan
20:28:37 <coffeemug> Visual Haskell is excellent
20:28:44 <coffeemug> but you can't do some trivial things in it
20:28:48 <coffeemug> like evaluate expressions
20:29:02 <dons> visual haskell, again, is a rather new project, and window specific
20:29:09 <dons> so i'd jot that down as a windows issue
20:29:17 <coffeemug> sure
20:29:18 <dons> more windows users need to step up and contribute patches
20:29:25 <coffeemug> but windows has 90% market share :)
20:29:35 <dons> right, but not 90% of the developers unfortunately
20:29:41 <dons> they're more like 10% of the developers
20:29:51 <coffeemug> plus visual haskell code is closed
20:30:22 <dons> I wonder what the hardcore windows hackers like ndm and eivuokko use?
20:30:30 <dons> ndm, eivuokko ping?
20:31:04 <coffeemug> Visual Haskell + WinHugs == greatness
20:31:08 <coffeemug> :)
20:31:43 <dons> its a pity that windows tool support, and the lack of windows developers, for some reason reflects on the language
20:31:55 <coffeemug> also refactoring could be a killer feature but Visual Haskell doesn't support that either (I'm aware of the command line project)
20:31:56 <dons> but we're addressing that I think
20:32:17 <coffeemug> does Microsoft fund haskell development?
20:32:30 <dons> eivuokko and ndm, in particular, are improving tool support on windows
20:32:46 <SamB> does paying simons count as funding Haskell development?
20:32:46 <dons> they fund the cambridge research lab
20:32:46 <coffeemug> if I were MS/Google/Sun I'd jump on the opportunity to fund such projects
20:32:51 <dons> where some haskell dev takes place
20:33:23 <coffeemug> well, do Simon's primary duties involve working on Haskell?
20:33:39 <dons> doing research, and improving ghc, I'd say
20:33:48 <coffeemug> then I guess it counts :)
20:34:10 <coffeemug> another issue I found is that you can't really do any serious work without use of numerous extensions
20:34:18 <SamB> there are at least two of them, you know...
20:34:19 <coffeemug> many of which are supported only in GHC
20:34:25 <dons> it is a pity, that if you'd been running linux, you could turn on emacs and ghci, and away you'd go
20:34:34 <dons> coffeemug: right. that's being addressed too. Haskell'
20:34:45 <dons> but in practice, only ghc is used for serious development anyway
20:34:51 <dolio> haskell mode is pretty nice.
20:34:52 <SamB> dons: but ... but ... fundeps!
20:35:05 <dolio> I've been using vim/kate of late, but haskell mode is tempting.
20:35:23 <coffeemug> well
20:35:35 <coffeemug> writing code for one compiler
20:35:35 <dons> coffeemug: so the extensions thing is a valid concern, and something actively being fixed
20:35:38 <coffeemug> is kind of scary :)
20:35:44 <dons> ?where haskellexts
20:35:45 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/HaskellExtensions
20:35:51 <dons> for a list of what things support what other things
20:36:00 <coffeemug> hmm
20:36:05 <coffeemug> there were some other things I noticed
20:36:06 <dons> expect to see standardisation in the next 12 months though
20:36:06 <coffeemug> ohh
20:36:46 <coffeemug> latest wxHaskell binary for windows is compiled with like 6.2 verison of GHC
20:36:59 <coffeemug> I'd have to double check
20:37:02 <coffeemug> may be it's 6.4 :)
20:37:12 <coffeemug> but certainly not a recent version
20:37:22 <dons> if its not, then that's another windows dev issue.
20:37:26 <coffeemug> which is a yet another annoyance for a person who just wants to try out the language
20:37:37 <dons> not enough windows users distributing binaries
20:37:54 <coffeemug> btw, please don't think that I'm "bashing" Haskell
20:37:56 <coffeemug> I'm really not
20:38:04 <dons> no no, its fine.
20:38:10 <coffeemug> I'm just giving a fresh impression that will hopefully help advance it
20:38:14 <dons> its very interesting seeing the language from this perspective
20:38:17 <dons> yeah
20:38:30 <dons> ie. .a cheap to install, working ghc+libs for windows sounds like a good idea
20:38:44 <dons> which provides gtk2hs, fps .... whatever
20:38:54 <dons> so people can try it out, get a gui clock demo written
20:39:01 <dcoutts> mm
20:39:11 <coffeemug> basically like lisp in a box
20:39:21 <dcoutts> we need some work to make it easy to use Gtk+ on windows, or indeed wxHaskell
20:39:22 <coffeemug> except lisp in a box uses emacs which is a turn off for most people
20:39:31 <dcoutts> there are dll problems
20:39:45 <dcoutts> possibly solvable dll problems
20:39:51 <dons> we'd need 3 or 4 windows developers, or access to windows boxes remotely (cough)
20:39:57 <dons> and then a list of tools that people expect
20:40:05 <dcoutts> I got limited access to a Win2k3 box
20:40:13 <dcoutts> non admin account makes things annoying
20:40:28 <dons> coffeemug: so what would you expect to have working in a haskell-in-a-box?
20:40:43 * dcoutts writes & publishes a cabal package in 5min flat
20:41:21 <dons> I'd think: stable ghc, some gui ide, gtk2hs/wxHaskell, haddock, happy, alex, ... ?
20:41:29 <dons> what else?
20:41:39 <dcoutts> cabal-install
20:41:43 <dcoutts> so you can get more
20:41:49 <coffeemug> dons: a simple IDE where I can create projects, add files, and just hit "build" to create an exe, relatively easy indentation (this part of visual haskell sucks), highlighting errors as I type, some refactoring, working examples of GUI programs
20:41:54 <dons> a full cabal system, yep
20:42:24 <coffeemug> and I should be able to download an installer, double click, and have all this stuff
20:42:30 <dons> coffeemug: so its mostly just a standard gui lib, and a nice IDE you're concerned about?
20:42:42 <dons> and one standard compiler that just installs and works
20:43:00 <coffeemug> dons: well, I already set that up for myself, I just had to jump through many barriers to do it
20:43:05 <dons> yes
20:43:18 <Korollary> a la DrHaskell
20:43:22 <coffeemug> yeah
20:43:28 <dons> right
20:43:56 <coffeemug> think of Joel's article (don't have a link off the top of my head) where he said that every little annoyance people run into halves the number of users
20:44:20 <dons> so perhaps we can talk to ndm or eivuokko and find out what they think about preparing at a start, a haskell-on-windows page, making it easy to find things and get started with recommend tools
20:44:33 <coffeemug> this is of course if the primary goal is to make Haskell a more mainstream language
20:44:44 <coffeemug> which obviously may not necessarily be the case
20:45:10 <dons> well, for some reason, lack of easy windows installation turns into bad blog buzz against the haskell language itself. which is something that would be good to avoid
20:45:47 <Korollary> You can certainly clear some hurdles, but there are people who can't configure simple stuff on their own boxes right. It makes you wonder whether they'll ever hack in haskell.
20:45:49 <dons> its getting easier, but some concrete goals for windows support would perhaps help focus the efforts of the few windows people who are writing haskell tools
20:46:24 <dons> perhaps if haskell-in-a-box first installed darcs, and configued darcs send .. ;)
20:46:29 <coffeemug> I gotta tell ya though, once I got through these minor issues I've been teleported to heaven :)
20:46:58 <coffeemug> definetly going to write an article on creating a mini-lisp interpreter with haskell
20:47:32 <dcoutts> where soe
20:47:35 <dcoutts> @where soe
20:47:35 <lambdabot> http://haskell.org/soe/
20:47:38 <dcoutts> @where soegtk
20:47:39 <lambdabot> http://haskell.org/~duncan/soe/
20:47:40 <dons> coffeemug: and perhaps make some advice about what to use on windows, so people pick the right things first time
20:47:51 <dcoutts> @where+ soegtk http://haskell.org/~duncan/soegtk/
20:47:52 <lambdabot> Done.
20:47:59 <coffeemug> yeah
20:48:08 <coffeemug> of course after people get through this stuff
20:48:14 <coffeemug> you'll probably get other crap
20:48:18 <coffeemug> syntax is ugly
20:48:21 <coffeemug> monads are hard
20:48:24 <coffeemug> stuff like that
20:48:30 <dons> and if you want to try out dcoutts' new http://haskell.org/~duncan/soegtk/ :)
20:48:31 <lambdabot> Title: Index of /~duncan/soegtk
20:48:31 <coffeemug> but that's already in people's hands
20:48:35 <dcoutts> so, due to popular demand! I present soegtk aka Graphics.SOE.Gtk
20:48:36 <dcoutts> darcs get http://haskell.org/~duncan/soegtk/
20:48:36 <lambdabot> Title: Index of /~duncan/soegtk
20:48:47 <dcoutts> dons beat me to it :-
20:49:01 <dons> ?karma+ dcoutts
20:49:01 <lambdabot> dcoutts's karma raised to 20.
20:49:26 <dons> coffeemug: soe for gtk. cutting edge, might be worth playing with
20:49:42 <coffeemug> yeah, I see that
20:49:51 <dons> dcoutts: got some demo graphics some where?
20:49:58 <coffeemug> so what happened to hIDE
20:50:00 <coffeemug> or hIDE2
20:50:06 <coffeemug> or whatever it was supposed to be called?
20:50:28 <dons> stalled, awaiting some new developements in the underlying embedded haskell environment
20:50:48 <coffeemug> actually
20:50:52 <coffeemug> I had a question about haskell
20:51:01 <coffeemug> how would one load modules "dynamically"?
20:51:03 <dcoutts> dons, of SOE or Gtk2Hs/cairo ?
20:51:22 <dons> either. so coffeemug has an idea of what can be achieved in soe+gtk
20:51:32 <dons> coffeemug: you'd use hs-plugins, our dynamic linker library
20:51:36 <dons> ?where hs-plugins
20:51:37 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
20:51:43 <coffeemug> thanks
20:51:44 <dons> ?gooooooogle dynamic loading haskell
20:51:45 <lambdabot> Unknown command, try @list
20:51:51 <dons> ?google dynamic loading haskell
20:51:55 <lambdabot> http://portal.acm.org/citation.cfm?id=1088353&dl=ACM&coll=&CFID=15151515&CFTOKEN=6184618
20:51:55 <lambdabot> Title: Haskell server pages through dynamic loading
20:51:56 <dons> let's see...
20:51:59 <dons> close
20:52:08 <dons> ?google dynamic loaded modules haskell
20:52:13 <lambdabot> http://www.dtek.chalmers.se/~d00ram/dynamic/dynamiclinker.pdf
20:52:16 <dons> bah
20:52:33 <dcoutts> http://haskell.org/~duncan/soe-demo/frakt-1-cairo.png
20:52:34 <dons> these chalmers guys own google, it seems ;)
20:52:53 <Pseudonym> ?google dynamic loading haskell dons
20:52:59 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/paper/
20:52:59 <lambdabot> Title: Plugging Haskell In
20:53:00 <Pseudonym> Happy now?
20:53:02 <dons> :)
20:53:14 <Pseudonym> ?google dynamic loading haskell paper
20:53:16 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/paper/
20:53:16 <lambdabot> Title: Plugging Haskell In
20:53:20 <Pseudonym> Also interesting.
20:53:38 <coffeemug> is hs-plugins library as nice as lisp's  (eval (read "(+ 1 2 3)")) paradigm? :)
20:53:54 <dons> it provides eval, yep
20:53:59 <dons> lambdabot uses it:
20:54:07 <dons> > (+) 1 2
20:54:17 <dons> helps if the network isn't slow
20:54:20 <lambdabot>  3
20:54:42 <dcoutts> dons, coffeemug: there's this one:
20:54:44 <dcoutts> http://haskell.org/~duncan/gtk2hs/SOE-cairo.png
20:54:59 <dcoutts> it's just showing the difference in quality between the old and new implementations
20:55:06 <dcoutts> it's not otherwise exciting
20:55:09 <dons> ah nice!
20:55:11 <coffeemug> that's pretty cool
20:55:20 <coffeemug> I was thinking more like minesweeper kind of stuff
20:55:23 <dons> that's SOE versus GTK+SOE?
20:55:34 <coffeemug> something more "real world"
20:55:44 <dons> coffeemug: oh, have you seen Frag?
20:56:09 <dcoutts> dons, yes.
20:56:23 <dons> might be nice to play with , http://haskell.org/haskellwiki/Frag
20:56:24 <lambdabot> Title: Frag - HaskellWiki
20:56:42 <dons> or one of the other games, http://haskell.org/haskellwiki/Libraries_and_tools/Games
20:56:43 <lambdabot> Title: Libraries and tools/Games - HaskellWiki
20:57:02 <dons> a quick minesweeper would be a good tutorial too
20:57:06 <coffeemug> yeah
20:57:11 <coffeemug> all right guys
20:57:13 <coffeemug> time to sleep
20:57:16 <coffeemug> work tomorrow :(
20:57:20 <coffeemug> back to Java I go
20:57:21 <coffeemug> lol
20:57:42 <coffeemug> thanks for everyone's help
20:57:54 <dons> looking forward to more blog entries :)
20:58:00 <coffeemug> will do :)
20:58:02 <coffeemug> good night
20:58:08 <dons> night!
21:02:58 <dons> Pseudonym: so the problem with using freetheorem as a plugin, is that it has to fit under the Plugin.* namespace, making later darcs pull's from your master repo trickier
21:03:36 <Pseudonym> Right.
21:03:39 <Pseudonym> Fair enough.
21:03:55 <dons> well, I'm doing it anyway
21:04:06 <dons> we'll see how hard it is in practice
21:04:16 <Pseudonym> You could make Plugin.FreeTheorem and re-import.
21:04:31 <dons> hmm
21:04:52 <SamB> Plugin.FreeTheorem?
21:05:10 <dons> you'll see... almost done with the binding
21:05:14 <Pseudonym> OK
21:05:26 <SamB> @google freetheorem
21:05:31 <lambdabot> http://portal.acm.org/ft_gateway.cfm?id=224225&type=pdf&coll=&dl=ACM&CFID=15151515&CFTOKEN=6184618
21:05:34 <SamB> hmm.
21:05:35 <Pseudonym> @google theorems for free
21:05:39 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/free/free.ps
21:06:00 <SamB> portal.acm.org is not a location that I would ordinarily associate with the word free
21:06:29 <dons> heh
21:06:38 <jbalint> lets just say that link is magical
21:09:43 <SamB> why doesn't he use a readable type system?
21:09:54 <Pseudonym> Look at the year on the paper.
21:10:04 <SamB> oh
21:10:12 <Pseudonym> It was written at a time when most FPLs used Miranda's type system, which is even LESS readable.
21:10:13 <SamB> I wasn't three yet at the time
21:10:26 <Pseudonym> map :: (* -> **) -> [*] -> [**]
21:10:39 <Pseudonym> Wadler's is an improvement.
21:13:23 <dcoutts> dons, I like your contest idea
21:13:58 <dcoutts> @hwn add soegtk announcement
21:14:02 <lambdabot> *** "ADD" wn "WordNet (r) 2.0"
21:14:02 <lambdabot> ADD
21:14:02 <lambdabot>    n : a condition (mostly in boys) characterized by behavioral and
21:14:02 <lambdabot>      learning disorders [syn: {attention deficit disorder}, {attention
21:14:02 <lambdabot>      deficit hyperactivity disorder}, {ADHD}, {hyperkinetic
21:14:04 <lambdabot> [35 @more lines]
21:14:08 <dcoutts> hah
21:14:18 <dcoutts> @help hwn
21:14:19 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:14:41 * dcoutts wonders what hwn is being auto-corrected to
21:14:49 <liyang> WordNet
21:14:49 <wolverian> @help wn
21:14:50 <lambdabot> I perform dictionary lookups via the following 13 commands:
21:14:50 <lambdabot>  @all-dicts .. Query all databases on dict.org
21:14:50 <lambdabot>  @devils ..... The Devil's Dictionary
21:14:50 <lambdabot>  @easton ..... Easton's 1897 Bible Dictionary
21:14:50 <lambdabot>  @elements ... Elements database
21:14:52 <lambdabot> [9 @more lines]
21:15:03 <wolverian> probably that.
21:15:29 <wolverian> shouldn't @help use the autocorrection too?
21:15:46 <SamB> you can't define fix in system F?
21:16:11 <Pseudonym> Nopr.
21:16:12 <Pseudonym> Nope.
21:16:33 <Pseudonym> Otherwise you can prove Russell's paradox.
21:17:02 <SamB> so?
21:17:23 <Korollary> Russell gets upset. Twists in his grave.
21:17:30 <SamB> heh
21:17:33 <dons> ?quit new free theorems plugin
21:18:58 <dons> ?free id :: a -> a
21:19:10 <dons> now we play the freenode-waiting-game
21:19:15 <Pseudonym> Sorry, I did a @list behind the scenes.
21:19:23 <dons> no harm
21:19:35 <Pseudonym> It's not finished yet.
21:19:39 <dons> ah
21:19:41 <dons> harm
21:20:09 <Pseudonym> Almost done.  In the t's now.
21:20:23 <lambdabot> f_1 . id = id . f_1
21:20:24 <SamB> should do that via DCC!
21:20:35 <dcoutts> dons, so what bits of the paper should I be looking at while on the train?
21:20:40 <Pseudonym> ?free swap :: (a,b) -> (b,a)
21:20:41 <lambdabot> ( f_1 ($proj_2_1 v1_7) = $proj_2_1 v2_8
21:20:41 <lambdabot>  &&
21:20:41 <lambdabot>  f_4 ($proj_2_2 v1_7) = $proj_2_2 v2_8
21:20:41 <lambdabot> )
21:20:41 <lambdabot> =>
21:20:43 <lambdabot> [4 @more lines]
21:20:46 <Pseudonym> @more
21:20:46 <lambdabot> ( f_4 ($proj_2_1 (swap v1_7)) = $proj_2_1 (swap v2_8)
21:20:47 <lambdabot>  &&
21:20:49 <lambdabot>  f_1 ($proj_2_2 (swap v1_7)) = $proj_2_2 (swap v2_8)
21:20:51 <lambdabot> )
21:21:13 <dcoutts> dons, I presume we do still want a paragraph about the strictness/bottom-discarding issues?
21:21:22 <dons> dcoutts: yes, that bit
21:21:39 <dcoutts> dons, I guess we wont talk about zipWith etc
21:21:42 <dons> Pseudonym: can we make it prettier?
21:21:50 <dons> dcoutts: yeah maybe not.
21:21:52 <dons> not sure
21:21:56 <dcoutts> since we've not really done them
21:22:01 <dcoutts> maybe further work
21:22:02 <dons> oh that too
21:22:08 <dcoutts> we think we can
21:22:09 <dons> we've got lots in there anyway
21:22:12 <dcoutts> heh
21:22:20 <SamB> hey
21:22:20 <dons> further work is ok
21:22:23 <SamB> Haskell is that old?
21:22:31 <dons> ?
21:22:36 <SamB> did it not yet have the [] syntax in 89?
21:22:46 <dons> yeah,  i think so.
21:23:13 <SamB> you think it did or you think it didn't have the [] syntax?
21:23:22 <Pseudonym> Unfortunately, tuples aren't very elegant.
21:23:33 <Pseudonym> What you ideally want is f X g notation.
21:23:44 <Pseudonym> If you only have lists, it's much prettier:
21:23:51 <Pseudonym> ?free map :: (a -> b) -> [a] -> [b]
21:23:52 <lambdabot> f_4 . v1_7 = v2_8 . f_1
21:23:52 <lambdabot> =>
21:23:52 <lambdabot> $map f_4 . map v1_7 = map v2_8 . $map f_1
21:24:07 <Pseudonym> ?free return :: a -> M a
21:24:07 <lambdabot> $map_M f_1 . return = return . f_1
21:24:36 <SamB> @free (==) :: Eq a => a -> a -> Bool
21:24:37 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:55:20-34
21:24:50 <Pseudonym> Can't handle typeclasses.
21:24:57 <Pseudonym> but you can do this:
21:25:03 <Pseudonym> ?free a -> a -> Bool
21:25:03 <lambdabot> Expected OpColonColon
21:25:11 <Pseudonym> ?free equal :: a -> a -> Bool
21:25:11 <lambdabot> equal v1_4 v1_6 = equal (f_1 v1_4) (f_1 v1_6)
21:25:16 <Pseudonym> And:
21:25:17 <SamB> shouldn't it give a syntax error or something?
21:25:28 <SamB> instead of saying "<lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:55:20-34"
21:25:29 <Pseudonym> ?free sort :: (a -> a -> Bool) -> [a] -> [a]
21:25:30 <lambdabot> v1_4 v1_6 v1_8 = v2_5 (f_1 v1_6) (f_1 v1_8)
21:25:30 <lambdabot> =>
21:25:30 <lambdabot> $map f_1 . sort v1_4 = sort v2_5 . $map f_1
21:25:34 <dons> perhaps bettter alpha renaming would help?
21:25:37 <Pseudonym> Yes, probably should.
21:25:47 * dons finds a good freshname generator
21:25:54 <Pseudonym> By all means.
21:26:11 <Pseudonym> Incidentally, take a look at the theorem for sort.
21:26:25 <dons> -- Generate a fresh type variable
21:26:25 <dons> freshName :: TC Id
21:26:25 <dons> freshName = TC $ \s ->
21:26:25 <dons>   let i     = unique s
21:26:25 <dons>       fresh = mkId $ if i < 26 then [chr (ord 'a' + i)] else 't' : show i
21:26:28 <dons>   in (fresh, s {unique = i + 1})
21:26:35 <Pseudonym> Basically it says if f doesn't change the comparison function, then map f commutes with sort.
21:26:43 <dons> hmm!
21:26:49 <dons> that's nice
21:26:51 <SamB> ?free sortBy :: (a -> Ordering) -> [a] -> [a]
21:26:51 <lambdabot> v1_4 v1_6 = v2_5 (f_1 v1_6)
21:26:52 <lambdabot> =>
21:26:52 <lambdabot> $map f_1 . sortBy v1_4 = sortBy v2_5 . $map f_1
21:27:10 <Pseudonym> I think you meant a -> a -> Ordering
21:27:14 <SamB> oh
21:27:19 <SamB> ?free sortBy :: (a -> a -> Ordering) -> [a] -> [a]
21:27:19 <lambdabot> v1_4 v1_6 v1_8 = v2_5 (f_1 v1_6) (f_1 v1_8)
21:27:20 <lambdabot> =>
21:27:20 <lambdabot> $map f_1 . sortBy v1_4 = sortBy v2_5 . $map f_1
21:27:27 <Pseudonym> ?free pierce :: ((a -> b) -> a) -> a
21:27:27 <lambdabot> ( f_4 . v1_9 = v2_10 . f_1
21:27:27 <lambdabot>  =>
21:27:27 <lambdabot>  f_1 (v1_7 v1_9) = v2_8 v2_10
21:27:27 <lambdabot> )
21:27:27 <lambdabot> =>
21:27:29 <lambdabot> f_1 (pierce v1_7) = pierce v2_8
21:27:33 <Pseudonym> Work that one out.
21:27:58 <SamB> its amazing what it can come up with just from the types...
21:28:16 <SamB> well, I mean, a human can come up with a lot of things based on types
21:28:25 <Pseudonym> ?free reverse :: [a] -> [a]
21:28:26 <lambdabot> $map f_1 . reverse = reverse . $map f_1
21:28:27 <SamB> but often that is based on guessing what the function might do
21:28:41 <Pseudonym> ?free fst :: (a,b) -> a
21:28:42 <lambdabot> ( f_1 ($proj_2_1 v1_7) = $proj_2_1 v2_8
21:28:42 <lambdabot>  &&
21:28:42 <lambdabot>  f_4 ($proj_2_2 v1_7) = $proj_2_2 v2_8
21:28:42 <lambdabot> )
21:28:42 <lambdabot> =>
21:28:44 <lambdabot> f_1 (fst v1_7) = fst v2_8
21:28:52 <SamB> hey how does it know what map is?
21:28:59 <Pseudonym> It doesn't.
21:29:02 <Pseudonym> It knows what $map is.
21:29:03 <Pseudonym> :-)
21:29:06 <Pseudonym> Which is the built-in map.
21:29:08 <SamB> well, whatever
21:29:16 <Pseudonym> ?free map :: (a -> b) -> [a] -> [b]
21:29:17 <lambdabot> f_4 . v1_7 = v2_8 . f_1
21:29:17 <lambdabot> =>
21:29:17 <lambdabot> $map f_4 . map v1_7 = map v2_8 . $map f_1
21:29:41 <SamB> what an... odd theorem...
21:29:46 <Pseudonym> Not really.
21:30:04 <Pseudonym> Basically: if f . g = h . k, then $map f . map g = map h . $map k
21:30:15 <Pseudonym> It's easier to read if you instantiate f = h and g = k.
21:30:23 <Pseudonym> But it's actually a slightly stronger theorem.
21:30:24 <SamB> I guess it says that if you have two things with the type of map and if (f . g) = (h . i) then map1 f . map2 g = map2 h . map1 i?
21:30:28 <Pseudonym> Right.
21:30:32 <Pseudonym> ?free undefined :: a
21:30:33 <lambdabot> f_1 undefined = undefined
21:30:38 <Pseudonym> That's a nice theorem.
21:31:02 <SamB> it looks like one of them workaholic theorems
21:31:07 <Pseudonym> Oh, and if it's not polymorphic, you can't tell anything:
21:31:11 <Pseudonym> ?free not :: Bool -> Bool
21:31:12 <lambdabot> not = not
21:31:31 <SamB> ?free a -> Bool
21:31:31 <lambdabot> Expected OpColonColon
21:31:38 <SamB> ?free p :: a -> Bool
21:31:38 <lambdabot> p v1_4 = p (f_1 v1_4)
21:31:57 <Pseudonym> I should optimise that to p = p . f
21:31:58 <SamB> definately need a better renamer
21:32:05 <SamB> even GHC can do better than that.
21:32:06 <dons> p x = p (f x)
21:32:14 <dons> ghc user's the above fragment I posted
21:32:19 <Pseudonym> ?free void :: a -> ()
21:32:19 <dons> grr. braino
21:32:19 <lambdabot> void v1_4 = void (f_1 v1_4)
21:32:27 <Pseudonym> Same theorem.
21:32:31 <SamB> yah
21:32:45 <SamB> ?free coerce# :: a -> b
21:32:46 <lambdabot> Expected OpColonColon
21:32:48 <SamB> aww
21:32:51 <SamB> ?free coerce :: a -> b
21:32:51 <lambdabot> f_4 . coerce = coerce . f_1
21:33:01 <SamB> oookay
21:33:02 <Pseudonym> That's a pretty cool theorem, too.
21:33:13 <SamB> it isn't ... true, though!
21:33:21 <Pseudonym> Sure it is.
21:33:29 <Pseudonym> It makes more sense if you call it unsafeCoerce
21:33:31 <SamB> well... not if coerce = unsafeCoerce#
21:33:46 <SamB> f_4 and f_1 are totally unrelated
21:33:51 <Pseudonym> Correct.
21:33:58 <Pseudonym> And it's true for all f_4 and for all f_1.
21:34:06 <SamB> I can assure you that that isn't what unsafeCoerce# does
21:34:31 <Pseudonym> I can assure you that it's true.  The fact that it makes no sense just proves that unsafeCoerce# is impossible to express in Haskell.
21:34:39 <SamB> hehe
21:34:54 <Pseudonym> ?free returnC :: a -> (forall r. (a -> r) -> r)
21:34:55 <lambdabot> f_6 . v1_9 = v2_10 . f_1
21:34:55 <lambdabot> =>
21:34:55 <lambdabot> f_6 (returnC v1_4 v1_9) = returnC (f_1 v1_4) v2_10
21:35:28 <SamB> @free fix :: (a -> a) -> a
21:35:29 <lambdabot> f_1 . v1_4 = v2_5 . f_1
21:35:29 <lambdabot> =>
21:35:29 <lambdabot> f_1 (fix v1_4) = fix v2_5
21:36:06 <Pseudonym> ?free callcc :: ((a -> (forall r. (b -> r) -> r)) -> (forall r. (a -> r) -> r)) -> (forall r. (a -> r) -> r)
21:36:06 <lambdabot> ( ( f_13 . v1_16 = v2_17 . f_4
21:36:07 <lambdabot>   =>
21:36:07 <lambdabot>   f_13 (v1_9 v1_11 v1_16) = v2_10 (f_1 v1_11) v2_17
21:36:07 <lambdabot>  )
21:36:07 <lambdabot>  =>
21:36:08 <lambdabot> [8 @more lines]
21:36:11 <Pseudonym> @more
21:36:11 <lambdabot>  f_20 . v1_23 = v2_24 . f_1
21:36:12 <lambdabot>  =>
21:36:14 <lambdabot>  f_20 (v1_7 v1_9 v1_23) = v2_8 v2_10 v2_24
21:36:16 <lambdabot> )
21:36:18 <lambdabot> =>
21:36:21 <lambdabot> [3 @more lines]
21:36:25 <Pseudonym> @more
21:36:26 <lambdabot> f_27 . v1_30 = v2_31 . f_1
21:36:26 <lambdabot> =>
21:36:27 <SamB> that is a very LOOOOONG theorem
21:36:28 <lambdabot> f_27 (callcc v1_7 v1_30) = callcc v2_8 v2_31
21:36:33 <Pseudonym> Yes it is.
21:36:40 <Pseudonym> And it's a complicated type.
21:36:58 <SamB> @free ByteString -> Char
21:36:59 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:55:20-34
21:37:05 <SamB> @free head :: ByteString -> Char
21:37:05 <lambdabot> head = head
21:37:19 <Pseudonym> ?free head :: [a] -> a
21:37:19 <lambdabot> f_1 . head = head . $map f_1
21:37:31 <SamB> okay, so it doesn't care what the hell I say so long as it looks like a potential type?
21:37:38 <Pseudonym> Right.
21:37:50 <SamB> @free bs :: BS a -> BS b c
21:37:51 <lambdabot> free module failed: IRCRaised Plugin/Free/FreeTheorem.hs:(82,0)-(148,31): Non-exhaustive patterns in function freeTheorem'
21:38:06 <SamB> needs better kind checking!
21:38:08 <Pseudonym> Can't handle type constructors with more than one argument.
21:38:14 <SamB> oh
21:38:15 <Pseudonym> Unless it's a typle.
21:38:17 <Pseudonym> tuple
21:38:18 <SamB> @free bs :: BS a -> BS
21:38:18 <lambdabot> bs v1_4 = bs ($map_BS f_1 v1_4)
21:38:28 <SamB> still needs kind checking!
21:38:37 <Pseudonym> There it assumes BS is a functor, and has a $map.
21:39:03 <Pseudonym> That, BTW, is a consequence of not having to declare types.
21:39:11 <SamB> why does it assume that?
21:39:26 <Pseudonym> Because otherwise you can't assume anything about it.
21:39:33 <SamB> hmm
21:39:48 <Pseudonym> If you assume it's a functor, then it has a nice mapping property that you can do something with.
21:39:56 <Pseudonym> My personal version also supports arrows for the same reason.
21:41:20 <Pseudonym> ?free null :: [a] -> Bool
21:41:20 <lambdabot> null v1_4 = null ($map f_1 v1_4)
21:41:55 <Pseudonym> ?free foldr :: (a -> b -> b) -> b -> [a] -> b
21:41:55 <lambdabot> f_4 . v1_7 v1_9 = v2_8 (f_1 v1_9) . f_4
21:41:56 <lambdabot> =>
21:41:56 <lambdabot> f_4 . foldr v1_7 v1_13 = foldr v2_8 (f_4 v1_13) . $map f_1
21:42:38 <SamB> it *really* needs to rename the names again at the end...
21:42:43 <dons> Pseudonym: oh, you wrote your own haskell parser?
21:42:56 <dons> that means lambdabot now has 3
21:43:16 <Pseudonym> No, I wrote my own Haskell lexer.
21:43:19 <Pseudonym> It only parses types.
21:43:25 <dons> ha yes
21:43:27 <Pseudonym> And I wrote my own parser combinators.
21:43:29 <SamB> heh
21:43:35 <dons> of course
21:43:36 <SamB> why your own combinators?
21:43:38 * Pseudonym was bored on Sunday afternoon
21:43:42 <dons> :)
21:44:18 <SamB> @free "hello" :: String
21:44:18 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:55:20-34
21:44:22 <SamB> hmm
21:44:30 * dons hacks the fresh name supply
21:44:30 <Pseudonym> It's usually easier for me to write a simple parser combinator library than to learn Parsec.
21:44:31 <SamB> you really need to work on those parse errrors
21:44:35 <Pseudonym> dons: Please.
21:44:40 <Pseudonym> And send me a patch. :-)
21:44:49 <SamB> dons: nono
21:44:49 <dons> yep
21:44:57 <Pseudonym> Feel free to modify the monad.
21:44:58 <SamB> should make nice names *after* the theorem is made!
21:45:08 <dons> possibly
21:45:11 <Pseudonym> It optimises out a lot of intermediate names.
21:45:12 <dons> we'll see how it turns out
21:45:19 <Pseudonym> You should see these theorems _before_ they're optimised.
21:45:20 <SamB> so that you don't waste nice names on things that go out of existance!
21:45:25 <dons> well then, a Map and a new fresh name, renamer would be good
21:45:37 <dons> i've got code for that somewhere
21:45:45 <SamB> yeah, something like that
21:46:02 <dons> right, Pseudonym so after theoremSimplify?
21:46:16 <Pseudonym> Yeah.
21:46:30 <SamB> also names like "f" should be used for functions and names like "x" should be used for variables...
21:46:42 <dons> i'll keep that in mind, SamB :)
21:46:53 <Pseudonym> SamB: I kind of do that.
21:46:57 <SamB> Pseudonym: yeah
21:47:09 <Pseudonym> The thing is, here, id takes a "value":
21:47:12 <SamB> but it only works about 75% of the time, or something...
21:47:14 <Pseudonym> ?free id :: a -> a
21:47:14 <lambdabot> f_1 . id = id . f_1
21:47:19 <Pseudonym> but here, id takes a function:
21:47:26 <Pseudonym> ?free id :: (a -> b) -> (a -> b)
21:47:26 <lambdabot> f_4 . v1_7 = v2_8 . f_1
21:47:26 <lambdabot> =>
21:47:26 <lambdabot> f_4 . id v1_7 = id v2_8 . f_1
21:47:41 <lispy> i noticed today that there is no list rotation function in the prelude or Data.List (cycle doesn't really count)
21:48:05 <Pseudonym> It's not smart enough to notice that the type of what is passed to id is a function.
21:48:17 <Pseudonym> But it uses f everywhere it knows it's a function because of the structure of the theorem.
21:48:45 <SamB> > let rotate n xs = drop n xs ++ take n xs
21:48:46 <lambdabot>  Parse error
21:48:56 <SamB> > let rotate n xs = drop n xs ++ take n xs in rotate 3 [1..10]
21:48:57 <Pseudonym> ?type rotate
21:48:57 <lambdabot>  [4,5,6,7,8,9,10,1,2,3]
21:48:59 <lambdabot> forall a. (Bits a) => a -> Int -> a
21:49:08 <lispy> i wrote rrotate and lrotate and created two instances of Enum and then it was pretty simple to have cyclical lists given my enumerations
21:49:09 <Pseudonym> ?type take
21:49:10 <lambdabot> forall a. Int -> [a] -> [a]
21:49:20 <Pseudonym> ?free take :: Int -> [a] -> [a]
21:49:21 <lambdabot> $map f_1 . take v2_5 = take v2_5 . $map f_1
21:49:26 <Pseudonym> Just checking.
21:49:50 <SamB> a very good theorem
21:50:01 <SamB> does GHC use this technique for optimization?
21:50:05 <Pseudonym> Yeah.  The simpler the type, the nicer the theorem.
21:50:14 <Pseudonym> No, because the theorem is untrue in Haskell.
21:50:19 <SamB> oh
21:50:24 <Pseudonym> The problem is that Haskell has seq.
21:50:26 <lispy> SamB: that's a bit shorter than my implementation...for some reason i avoided the drop/take way of doing it i see that it has meric now
21:50:30 <lispy> merit*
21:50:33 <Pseudonym> That screws wieth these theorems.
21:50:48 <SamB> oh, seq is nasty indeed
21:51:07 <SamB> or is it bottom that is nasty...
21:51:17 <Pseudonym> Believe it or not, bottom isn't so much of a problem.
21:51:37 <Pseudonym> ?google fast and loose reasoning is moral
21:51:40 <lambdabot> http://www.cs.chalmers.se/~nad/publications/danielsson-popl2006-talk.pdf
21:51:58 <lispy> SamB: oh, actually that implementation would fail if you rotate by an arbitrary distance
21:52:02 <Pseudonym> That's the one.
21:52:10 <SamB> lispy: oh true...
21:52:37 <dons> best monad name ever: type MyMon a = StateT ...
21:52:41 <SamB> so maybe ...
21:52:48 <Pseudonym> I warned you I was bored.
21:53:40 <Pseudonym> The free theorem for id is id . f = f . id, not id x = x
21:53:48 <Pseudonym> The reason is that the former is true if id _ = undefined
21:55:18 <Pseudonym> ?free choose :: a -> a -> a
21:55:18 <lambdabot> f_1 . choose v1_4 = choose (f_1 v1_4) . f_1
21:55:36 <Pseudonym> That would actually be more elegant if it wasn't curried.
21:55:37 <SamB> > let rotate1 (x:xs) = xs ++ [x]; rotate 0 = id; rotate n = rotate1 . rotate (n-1) in rotate 13 [1..10]
21:55:38 <lambdabot>  [4,5,6,7,8,9,10,1,2,3]
21:55:44 <Pseudonym> f (choose x y) = choose (f x) (f y)
21:56:37 <lispy> SamB: i that's close to my implementation...i don't have it in front of me but i seem to remember having 3 cases
21:56:48 <SamB> lispy: yeah
21:57:01 <lispy> rotate _ [], rotate 0 xs, and rotate n (x:xs)
21:57:15 <SamB> what? no negative case?
21:57:28 <lispy> not yet, my enums are positive :)
21:57:34 <SamB> I admit that I forgot entirely about []
21:58:05 <lispy> but i have both rrotate and lrotate so agruably i could use a negative and skip one implementation, reducing my code size and hence my maintenance effort
22:00:55 * SamB needs to GOTO BED
22:01:18 <lispy> BED: label not defined
22:01:28 <lispy> damn, i forgot to make the BED
22:01:31 <Pseudonym> GOTO sadly doesn't have a free theorem.
22:01:40 <sieni> SamB: you need to put the instruction COMEFROM COMPUTER onto your bed
22:01:48 <lispy> heh
22:02:26 <SamB> sure it does! GOTO FOO = insanity!
22:02:47 <Pseudonym> That theorem isn't free.  It'll cost you dearly.
22:02:57 <SamB> hah
22:03:41 <lispy> instructions without free theorems considered harmful
22:08:13 <dons> Pseudonym: are all variables bound with Forall?
22:08:31 <dons> ThForall
22:10:04 <Pseudonym> Yes.
22:10:08 <Pseudonym> But they're not pretty printed.
22:10:39 <dons> ok
22:10:49 <Pseudonym> Oh, the only ones that aren't are builtins (e.g. $map, (.)) and the function which actually has the theorem.
22:10:59 <dons> ok, i can live with that
22:11:03 <Pseudonym> i.e. nothing that has to be renamed.
22:11:06 <dons> yep
22:58:31 <dons> k . a c = b (f c) . f
22:58:31 <dons> =>
22:58:32 <dons> p . genSwap a d = genSwap b (f d) . f
22:59:36 <Pseudonym> Nice.
23:05:22 <dons> http://www.cse.unsw.edu.au/~dons/tmp/rename.patch
23:05:32 <dons> feel free to darcs apply
23:06:41 <Pseudonym> Thanks.
23:07:21 <dons> ?quit new renamer
23:08:19 <dons> ?free id :: a -> a
23:08:25 <Pseudonym> Applied.
23:08:44 <lambdabot> f . id = id . f
23:10:20 <dons> ?free pierce :: ((a -> b) -> a) -> a
23:10:21 <lambdabot> ( f . f = f . f
23:10:21 <lambdabot>  =>
23:10:21 <lambdabot>  f (f f) = f f
23:10:21 <lambdabot> )
23:10:23 <lambdabot> =>
23:10:26 <lambdabot> f (pierce f) = pierce f
23:10:35 <Pseudonym> That doesn't look right for some reason.
23:10:55 <Pseudonym> ?free idPair :: (a,b) -> (a,b)
23:10:55 <lambdabot> ( f ($proj_2_1 x) = $proj_2_1 y
23:10:55 <lambdabot>  &&
23:10:55 <lambdabot>  f ($proj_2_2 x) = $proj_2_2 y
23:10:55 <lambdabot> )
23:10:55 <lambdabot> =>
23:10:57 <lambdabot> [4 @more lines]
23:11:02 <Pseudonym> @more
23:11:02 <lambdabot> ( f ($proj_2_1 (idPair x)) = $proj_2_1 (idPair y)
23:11:02 <lambdabot>  &&
23:11:03 <lambdabot>  f ($proj_2_2 (idPair x)) = $proj_2_2 (idPair y)
23:11:05 <lambdabot> )
23:11:11 <Pseudonym> Apparently all functions are "f".
23:11:14 <dons> ah
23:12:20 <dons> yeah, old output for pierce: "( f_4 . v1_9 = v2_10 . f_1\n =>\n  f_1 (v1_7 v1_9) = v2_8 v2_10\n)\n=>\nf_1 (pierce v1_7) = pierce v2_8"
23:13:30 <dons> ah, spotted it
23:13:37 <dons> 2 chars off
23:14:19 <dons> ( g . p = q . f
23:14:20 <dons>  =>
23:14:20 <dons>   f (h p) = k q
23:14:20 <dons> )
23:14:20 <dons> =>
23:14:22 <dons> f (pierce h) = pierce k
23:14:24 <dons> looks better
23:15:16 <Pseudonym> Yeah.
23:15:41 <dons> http://www.cse.unsw.edu.au/~dons/tmp/typo.patch
23:15:59 <dons> oh, not sure if that will apply. its partial
23:16:29 <dons> no, its fine.
23:21:12 <dons> ?quit fix some little wibbles
23:22:31 <dons> ?free pierce :: ((a -> b) -> a) -> a
23:22:34 <lambdabot> ( g . p = q . f  =>   f (h p) = k q ) => f (pierce h) = pierce k
23:25:18 <Pseudonym> What did you do to the layout?
23:25:51 <dolio> ?free callcc :: ((a -> (forall r. (b -> r) -> r)) -> (forall r. (a -> r) -> r)) -> (forall r. (a -> r) -> r)
23:25:51 <lambdabot> ( ( f1 . f2 = f3 . g    =>     f1 (p x f2) = q (f x) f3   )  =>   f4 . f5 = f6 . f  =>   f4 (h p f5) = k q f6 ) => f7 . f8 = f9 . f => f7 (callcc h f8) = callcc k f9
23:28:20 <dons> ?free [a] -> [a]
23:28:20 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:57:20-34
23:28:28 <dons> ?free reverse :: [a] -> [a]
23:28:29 <lambdabot> $map f . reverse = reverse . $map f
23:28:56 <dons> ?free concatMap :: (a -> [b]) -> [a] -> [b]
23:28:56 <lambdabot> $map g . h = k . f => $map g . concatMap h = concatMap k . $map f
23:29:21 <dons> ?free filter :: (a -> Bool) -> [a] -> [a]
23:29:22 <lambdabot> g x = h (f x) => $map f . filter g = filter h . $map f
23:29:37 <Pseudonym> ?free sort :: (a -> a -> Bool) -> [a] -> [a]
23:29:37 <lambdabot> g x y = h (f x) (f y) => $map f . sort g = sort h . $map f
23:29:48 <Pseudonym> Very nice.
23:29:53 <dons> yeah, that's lovely
23:30:03 <dons> ?karma+ Pseudonym -- free theorems for all
23:30:04 <lambdabot> Pseudonym's karma raised to 4.
23:30:13 <Pseudonym> It's the complicated ones like pierce that really need the layout, though.
23:30:27 <dons> yeah
23:30:32 <dons> ?free concat :: [[a]] -> [a]
23:30:32 <lambdabot> $map f . concat = concat . $map ($map f)
23:30:58 <Pseudonym> ?free bind :: M a -> (a -> M b) -> M b
23:30:58 <lambdabot> $map_M g . h = k . f => $map_M g (bind x h) = bind ($map_M f x) k
23:31:19 <dons> ?free (a -> b -> a) -> a -> [b] -> a
23:31:20 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:57:20-34
23:31:27 <dons> ?free foldl :: (a -> b -> a) -> a -> [b] -> a
23:31:28 <lambdabot> f . h x = k (f x) . g => f . foldl h y = foldl k (f y) . $map g
23:31:31 <Pseudonym> I'll fix up the error messages.
23:32:01 <dons> could the built in names by nicer? $map -> map
23:32:14 <dons> (fmap)
23:32:17 <Pseudonym> ?free map :: (a -> b) -> [a] -> [b]
23:32:17 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
23:32:26 <Pseudonym> That's the reason why I did that.
23:33:16 <dons> ?free scanl :: (a -> b -> a) -> a -> [b] -> [a]
23:33:16 <lambdabot> f . h x = k (f x) . g => $map f . scanl h y = scanl k (f y) . $map g
23:33:35 <dons> ?free unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
23:33:36 <lambdabot> ( ( ( g ($proj_2_1 y) = $proj_2_1 z       &&       f ($proj_2_2 y) = $proj_2_2 z     )    =>     p y = z   )  =>   $map_Maybe p (h x) = k (f x) ) => $map g . unfoldr h = unfoldr k . f
23:33:39 <dons> ooh
23:34:15 <dons> do any of these proj functions have nice names?
23:34:31 <Pseudonym> No.
23:34:42 <Pseudonym> It's $proj_arity_index
23:34:55 <Pseudonym> ?free idTriple :: (a,b,c) -> (a,b,c)
23:34:56 <lambdabot> ( f ($proj_3_1 x) = $proj_3_1 y   &&   g ($proj_3_2 x) = $proj_3_2 y   &&   h ($proj_3_3 x) = $proj_3_3 y ) => ( f ($proj_3_1 (idTriple x)) = $proj_3_1 (idTriple y)   &&   g ($proj_3_2 (idTriple x))
23:34:56 <lambdabot> = $proj_3_2 (idTriple y)   &&   h ($proj_3_3 (idTriple x)) = $proj_3_3 (idTriple y) )
23:35:13 <benja_> that's peirce, not pierce, I believe :)
23:35:18 <dons> hmm, perhaps then, fst, snd, fst3, snd3, thd3 ?
23:35:34 <dons> for the common cases?
23:35:42 <Pseudonym> Probably a good idea.
23:35:49 <Pseudonym> ?free fst :: (a,b) -> a
23:35:49 <lambdabot> ( f ($proj_2_1 x) = $proj_2_1 y   &&   g ($proj_2_2 x) = $proj_2_2 y ) => f (fst x) = fst y
23:35:59 <Pseudonym> Maybe $fst, $snd, $thd etc
23:36:03 <dons> yeah
23:36:09 <Pseudonym> OK.
23:41:42 <Pseudonym> Gotta go.
23:41:43 <Pseudonym> Night.
23:57:31 <ski> ?free reverse :: [a] -> [a]
23:57:31 <lambdabot> $map f . reverse = reverse . $map f
