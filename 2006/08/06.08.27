00:00:06 <Korollary> A social engineer is one who builds better societies based on mathematical models.
00:00:14 * edwardk nods.
00:00:43 <Korollary> While mechanical engineers build weapons, he builds voters.
00:01:02 <edwardk> ahh. so he works for diebold =)
00:01:20 <Korollary> he's a supplier of diebold.
00:01:25 <edwardk> even worse
00:01:37 <Korollary> I don't think all of diebold's suppliers are bad.
00:01:42 <edwardk> fair enough
00:01:53 <edwardk> the diebold thing was just intended to be a wisecrack on the voters thing
00:01:57 <Korollary> I'd sell them too if they paid good money.
00:02:06 <edwardk> didn't realize it would actually hit the mark ;)
00:02:07 <Korollary> diebold is too tragic.
00:02:29 <Korollary> DOn't you think that diebold is a very bad name for a company?
00:03:05 <Korollary> Even Initech is better.
00:04:02 <edwardk> i just wonder how much crap a company has to try to pull before it just can't survive under the weight of the lawsuits. oh wait, they are trying to indemnify them
00:06:46 <Korollary> I would love to be able to pull crap like that.
00:07:29 <newsham> got any former senators on your board?  how big's your legal staff?
00:07:38 <Korollary> I own half a judge.
00:08:39 <sslow> hi all, I am trying to build the latest ghc 6.5 (the darcs version using freebsd), but I get a bizarre error, "./configure: Permission denied gmake[1]:*** [boot] Error 126 ..." does anyone have any idea on how to fix this?
00:08:48 <edwardk> thats a start ;)
00:10:03 <dons> chmod +x configure ?
00:11:49 <sslow> let me try it, but first i need to find which configure causes the problem (if this is the problem)
00:14:42 <sslow> thanks dons, that solved it
00:44:30 <newsham> "Most safe languages rely intensively on dynamic memory allocation. In some cases this reliance is embedded so deeply that it is impossible to write programs that do not allocate memory dynamically. Kernels must be capable of operating with predictable variance in a fixed-memory environment. Dynamic allocation renders this problematic." -coyotos paper
00:45:01 <sieni> that is true
00:45:32 <dons> mmm, ghc reports: 20086 BetaReduction ocurred while optimsing  some code. good compiler!
00:46:02 <sieni> if you have closures, you are pretty much doomed to have garbage collection
00:46:31 <dons> or the alternative is a region based system, I suppose. like Cyclone
00:46:47 <sieni> even though parallel garbage collection is difficult it doesn't need to be
00:46:50 <newsham> a stack is an optimization.  why cant a compiler optimize parts of the code that dont require heap allocation?
00:46:51 <Korollary> It's a bit difficult to contain everything in a fixed memory env
00:46:51 <musasabi> One could live with region allocation and analyzing the bounds of memory allocation for a subset of programs
00:46:52 <edwardk> regions, linear and substructural types, etc.
00:46:59 <sieni> if you have operating system support
00:47:51 <sieni> just provide support for write barriers on the operating system level to the userland
00:47:58 <newsham> you could implement C using GC'd activation frames, but since its LIFO, a stack is more efficient..
00:48:11 <newsham> surely the property of LIFO isnt hard to verify
00:48:20 <edwardk> i've been playing with trying to see if uniqueness and linear types can work with regions to bring the memory footprint down closer to garbage collected levels.
00:48:39 <edwardk> if you can do a good portion of your region allocation in fixed sized regions those turn into stack allocations.
00:48:53 <sieni> and for that matter safe way to recover from stack overflow (yes, I'm thinking of Chicken)
00:49:26 <edwardk> newsham its tricky to get a LIFO stack if you want substructure, because all of the non-commutative linear logics have the wrong properties (as i've been discovering) =/
00:49:32 <musasabi> JHC has many plans with regions
00:49:37 <edwardk> yeah
00:50:40 <newsham> edw: that last statement didn't quite sink in...  non-commutative linear logic having wrong props..
00:51:01 <edwardk> to get a proper stack discipline you need a non-commutative affine logic which is only affine at the top of the stack and can only combine at the top of the stack.
00:51:03 <newsham> smaller words and more of them? :)
00:51:13 <edwardk> non-commutative logics allow operations anywhere on the stack
00:51:33 <edwardk> brb then i can explain more
00:52:04 <sieni> cons should not cons it arguments!
00:52:15 <newsham> sounds roughly like you're saying that you should only be omdifying things at the top of the stack and not deeper down?
00:52:19 <musasabi> Any good papers on functional operating systems rather than "implementing the old *nix system in a functional language" ?
00:52:39 <dons> musasabi: there's a little on Clean and typed filesystems
00:53:22 <edwardk> newsham: well, what i'm saying that is if you turn a linear logic into a non-commutative linear logic then it doesn't quite match up to a stack discipline
00:53:41 <edwardk> so my current answer is somewhat different
00:53:58 <johnnowak> musasabi: i'm waiting for a file system without side-effects.
00:54:06 <Korollary> heh
00:54:24 <edwardk> if you modify the linear logic into a non-commutative linear logic that can only weaken the top of the stack you get some interesting properties when its mixed with region support
00:54:41 <edwardk> regions can give you the modifiable middle-of-the-stack stuff
00:54:47 <newsham> so lets say you're writing an runtime or an OS, couldnt you pick a decent subset of the language that could be optimized into LIFO and use that to implement things like the GC that the full language would rely on?
00:55:07 <edwardk> you can just use a fixed size region that you allocate linear, relevant, affine, unrestricted stuff in, then it can be placed inline on the stack, and modified in place
00:55:14 <edwardk> then the region gets freed as you weaken the stack.
00:56:09 <edwardk> newsham: the lambek calculus is basically that, its purely non-commutative and linear, but the resulting calculus can't generate anything stronger than a CFG. so you need something more.
00:56:19 <musasabi> dons: link/name ?
00:56:24 <newsham> pretend I'm not a mathemetician and "non-commutative linear logic" doesnt immediately evoke a coordinated firing of neurons
00:56:28 <edwardk> newsham: you could get there with globals, etc.
00:56:29 <edwardk> heh
00:56:30 <edwardk> ok
00:56:36 <sieni> but I don't think that concurrent garbage collection is too difficult if you provide proper support for write barriers on operating system level
00:56:37 <edwardk> do you know what linear logic is?
00:56:52 <newsham> ed: not sure I do.
00:56:52 <musasabi> serializing and types seems very problematic to me with all the versioning issues.
00:56:56 <sieni> imao, that should be part of any decent operating system
00:56:57 <edwardk> kk
00:57:12 <musasabi> at least in the haskell context without subtyping
00:57:30 <edwardk> ok. basically i'll describe what i'm going for, but i'll break it apart into laymans terms as much as possible. its a bit of a generalization of the linear concept.
00:58:13 <edwardk> ok, the lambda calculus is built up over 'intuitionistic logic'. do you know the curry-howard 'isomorphism' or 'proofs-as-types'?
00:58:32 <newsham> nope.
00:59:03 <edwardk> the idea is that you can view types as propositions in logic and the existence of a value of that type as a 'proof' of the proposition.
00:59:14 <edwardk> if you strengthen the type system you can prove more things
00:59:25 <newsham> ok.  makes sense
00:59:52 <edwardk> ok, well, it stands to reason that if you change the rules of the logic involved, you can get different type systems this way.
01:00:20 <edwardk> well, in most logics, proof is free. you can prove A, then use A -> B with A to get B and keep using A over and over.
01:00:29 <edwardk> er truth is free, not proof is free =)
01:00:38 <edwardk> once you know A, you know it forever.
01:00:50 <newsham> ok
01:00:54 <edwardk> but the problem is that this sort of logic is very poor at reasoning about space requirements.
01:01:06 <edwardk> because you have to keep everything you ever proved.
01:02:03 <edwardk> so mathematicians (in particular Jean-Yves Girard) came up with an alternative logic called linear logic, that restricts the operations in logic that make proof 'free'. there are two contributing factors. one is 'contraction', and the other is called 'weakening'
01:02:15 <xerox> ?yow
01:02:16 <lambdabot> I believe in wash fulfillment.
01:02:18 <edwardk> contraction lets you use something more than once, and weakening lets you ignore a fact.
01:03:02 <edwardk> so writing \x -> (x,x) you contract. or writing \_ -> 12 you weaken the value passed in
01:03:31 <newsham> ok, the first because it makes x available more than once, and the second because it discards knowledge?
01:03:48 <edwardk> if you can show that a value is never weakened, then you know it is 'relevant'. any relevant type will always be used, so you might as well compute it eagerly.
01:03:53 <edwardk> yep =)
01:04:11 <edwardk> if you can show the value is never contracted, then you know it will only be used once, so you can throw it away after first use.
01:04:26 <newsham> ok, so this is going towards a strategy for lazy evaluation?
01:04:39 <edwardk> if you have both of those properties then the type is 'linear'. and so you know you can eagerly compute it, and then you can throw it away immediately after use.
01:04:45 <edwardk> yeah kind of circuitously =)
01:05:13 <newsham> interesting
01:05:41 <edwardk> now, traditionally, intuitionistic logic allows contraction and weakening whenever you want it, so the typed lambda calculus which has intuitionistic logic for a type system doesn't have great control over those operations.
01:06:23 <edwardk> but if you restrict their availability you can say an awful lot about memory usage. now you still need to have unrestricted contraction and weakening. and linear logic allows them through so-called 'exponential' types.
01:06:49 <edwardk> exponentials are the 'unrestricted' types you are used to. use it or not, lazily and it'll gc it for you later.
01:07:10 <edwardk> but lots of types fall into those strategies i mentioned so far.
01:07:34 <edwardk> for the sake of completeness i should probably mention the last 2 types of substructural types that get bandied about.
01:07:52 <edwardk> the first is a so-called 'uniqueness' type. have you heard of clean or looked at it?
01:08:21 <newsham> i've heard of it but havent investigated further.
01:08:38 <newsham> just heard that uniqueness typing lets them have side effects (or do IO?) without the monads
01:08:40 <edwardk> uniqueness types are a lot like linear types. they say that the type hasn't been weakened or contracted YET, while linear says that it won't be weakened or contracted in the future. in the uniqueness case it means that it can be modified in place, because there is only one reference to the type, the one you are trying to modify it with ;)
01:09:02 <newsham> ahh, makes sense.
01:09:11 <edwardk> well, in a uniqueness type system i can pass a uniqueness typed IO object around and i know i can't copy it =)
01:10:19 <edwardk> now the whole linear logic thing is based on some fairly heady mathematics involving coherent spaces and proof nets and things, but in the end the resulting calculus has commutative products. kind of like how a and b = b and a in classical logic.
01:10:34 <edwardk> you can weaken that further by allowing a non-commutative product type.
01:10:45 <edwardk> thats where we get into non-commutative linear logics.
01:11:03 <edwardk> the problem is that there are tons of models here and very few of them correspond to anything useful in computer science ;)
01:11:16 <edwardk> so i've been banging on them trying to turn them into a stack model.
01:11:27 <newsham> ah ha.
01:11:42 <newsham> i take it you're a compiler guy?   (cleen?)
01:11:53 <edwardk> the best approximation of a traditional stack on a traditional CPU that i can come up with is to add in regions, and a non-commutative type system
01:12:01 <edwardk> i'm kinnd of a dabbler in about everything ;)
01:12:35 <edwardk> at the moment i decided last month it would be a nice thing to write a thesis on mixing these features to try to get a decent intermediate language  for compiling functional languages to modern hardware.
01:13:14 <edwardk> the main reason i want a non-commutative type system is that i want to be able to model a stack, and i would like to be able to store 'ordered' continuations on the stack.
01:13:23 <newsham> so a replacement for the spineless-tagless system then?
01:13:27 <edwardk> then i can associate with those continuations fixed or variable sized regions.
01:14:29 <edwardk> if i then allow those continuatios to be affine (allowing weakening but not contraction) but only at the top of the stack, you can safely discard the top of the stack like a traditional stack machine.
01:15:00 <edwardk> the only tricky parts being freeing any heap allocation associated with the intervening regions allocated
01:15:27 <edwardk> regions do a pretty good job, but in general suffer about a 70% memory bloat over garbage collection
01:15:39 <newsham> analogous to freeing any malloc'd regions referenced from the current stack frame?
01:15:44 * johnnowak pays edwardk five dollars for giving him something to drink his coffee to
01:16:05 <sieni> newsham: yes, I think so
01:16:07 <newsham> 70% is a big number.
01:16:22 <edwardk> if i can mix in the substructural (linear, relevant, affine, uniqueness) types then perhaps it can get down to about where gc gets
01:16:36 <edwardk> newsham: was basing that on the ML mixed region and gc comparison papers i've read
01:16:41 <edwardk> might be closer to 50%
01:16:45 <edwardk> but its big
01:17:06 <sieni> but I don't think you can make region inference working as the only way of freeing memory, because of turing's theorem
01:17:11 <newsham> (decent wikipedia on linear logic)
01:17:24 <edwardk> sieni: both regions and gc have pathological cases.
01:17:45 <newsham> For example, suppose I have a quart of milk from which I can make a pound of butter. If I decide to make butter out of all of my milk, I cannot then conclude that I have both milk and butter! Yet, the logical schema outlined above lets me conclude that milk, milk . butter . milk . butter
01:17:51 <edwardk> sieni: i mostly want to see how many of the region-based-memory problems can be plugged by adding ubstructural types to a region system
01:18:32 <edwardk> newsham: its a pretty good start, and that article works well at motivating all of the connectives except par as i recall.
01:18:36 <sieni> edwardk: yes, but I'm not complaining about region inference in itself, it's a good optimization, but I think you still need to do occasional garbage collection
01:19:05 <edwardk> sieni: yeah, probably will, but i want to see how far i can get without it, then graft it on. ;)
01:19:09 <newsham> ed: so in your system you can manage memory without GC..    question I have is -- can you use this to implement GC in haskell for other haskell code?
01:19:44 <edwardk> avoiding tagging, etc. really helps out regional performance, it can usually be a lot faster than gc. you get than 50% overhead back as about a 50% speed jump in a lot of cases.
01:20:10 <edwardk> newsham: well, jhc is or was planning on using, region based memory management for haskell
01:20:30 <edwardk> and there are some issues with inferring these types using hindley-milner.
01:20:32 <musasabi> there have been some recent commits that mention the region stuff
01:20:44 <edwardk> uniqueness can be inferred by a variant, so can linearity, but i don't know one for relevant/affine
01:21:01 <edwardk> and the ordered stuff is totally up in the air
01:21:16 <edwardk> since i don't know of any research into mobility inference.
01:21:50 <foxy> @where F_{\omega}
01:21:50 <lambdabot> I know nothing about f_{\omega}.
01:21:57 <sieni> edwardk: operating system support is essential for getting garbage collection work efficiently on multiprocessor systems
01:22:06 <edwardk> anyways i needed to work on something since the ecma committee never got around to replying to my inquiries, so i've been killing time working on this ;)
01:22:07 <foxy> @where System F
01:22:08 <lambdabot> I know nothing about system.
01:22:12 <edwardk> sieni: yeah
01:22:25 <foxy> \query lambdabot
01:22:28 <newsham> ecma == common language runtime stuff?
01:22:51 <edwardk> sieni: i've implemented an OS kernel with built in GC as part of a SASOS project
01:23:02 <edwardk> sieni: and multiprocessing is a nightmare
01:23:15 <edwardk> newsham: ecmascript 4 == javascript in my case.
01:23:36 <sieni> edwardk: if you get paid for that stuff, then it's ok
01:24:14 <edwardk> sieni: heh, get paid? =) i never have been actually paid for working on anything in comp sci that i found fun ;)
01:24:56 <edwardk> so anyways, what i've been trying to do with the regions and linear types
01:25:12 <edwardk> if you use regions with both fixed and variable size
01:25:23 <edwardk> where the variable sized regions are heap allocated page chains
01:25:30 <sieni> well I'd rather spend my time with juggling, but one has to pay bills and all that stuff
01:25:41 <edwardk> and the fixed sized regions are just allocated on the stack
01:25:52 <edwardk> and you modify a substructural type system to use region tagging
01:26:09 <edwardk> then you can have linear, unrestricted, etc types that are allocated and placed in these stack based regions.
01:26:48 <edwardk> so you can manipulate any point on the stack and still obey these substructural disciplines
01:27:07 <edwardk> without requiring a new complicated categorical model for a non-commutative logic.
01:27:33 <edwardk> and the uniqueness types let you update lots of stuff in place as you build it
01:27:42 <edwardk> relevant types let you do strictness analysis
01:28:02 <edwardk> affine types let you prove polynomial time bounds if you really want to ;)
01:28:35 <edwardk> and linear/affine types let you assist collection efforts by recycling them before the region even gets returned.
01:29:27 <edwardk> and most continuations are used in a linear fashion according to a stack discipline, so they can be letregioned onto the stack
01:29:34 <musasabi> edwardk: commit such support into jhc, it would be very nice for working with different things :-)
01:30:02 <edwardk> well, GRIN is somewhat inimical to my model =/
01:30:35 <edwardk> so, in any event, was that at least coherent? =)
01:31:36 <edwardk> as far i know, no one in the linear and uniqueness camps have tried talking to each other, but surprisingly their approaches complement each other quite nicely
01:33:31 <musasabi> edwardk: the revised grin or the old one?
01:33:33 <edwardk> you can have a type start life unique, contract into an unrestricted type then undergo dereliction to a linear type that you know you can clean up after.
01:33:49 <edwardk> musasabi: the one jhc uses is strongly typed with some extra case stuff right?
01:34:19 <edwardk> i poked around in the jhc internals for a bit when i wanted to see how bad it would be to compile GRIN to javascript
01:34:40 <edwardk> before i decided that STG to javascript would perform better
01:34:59 <musasabi> edwardk: the one at http://repetae.net/dw/darcsweb.cgi?r=jhc;a=headblob;f=/Grin/Grin.hs#l134
01:35:02 <lambdabot> Title: darcs - jhc
01:35:53 <edwardk> yeah thats the one
01:36:01 <musasabi> Grin -> C is quite easy and simple, so Grin -> JS should not be that bad.
01:36:17 <edwardk> its not that its bad, its just that STG -> js has more optimization potential
01:36:22 <edwardk> grin does lots of single parameter function calls
01:36:34 <edwardk> STG does fewer invocations of mmore monolithic closures
01:36:50 <edwardk> javascript pays a lot for the argument marshalling independent of number of arguments
01:36:56 <edwardk> so STG is a more suitable approach.
01:37:06 <musasabi> actually the new Grin variant tries to collect argument and avoid the multiple applying of one arg.
01:37:11 <edwardk> and GHC is a more stable compiler
01:37:31 <edwardk> hrmm
01:37:41 <musasabi> of course GHC is more stable :-)
01:38:44 <edwardk> oh whoa, that is a dfferent GRIN by far =)
01:38:51 <edwardk> i just dug into my source here =)
01:38:52 <edwardk> heh
01:39:06 <edwardk> Call NewRegion, etc.
01:39:13 <edwardk> i didn't scroll the screen down far enough =)
01:41:31 <edwardk> my current language syntax is more like the $\lambda\Lambda$ calculus of samin ishtiaq coz of the need to deal with substructural types in the pure type system part of the calculus though
01:41:48 <edwardk> so i guess you could say i'm trying to optimize in a language closer to the level of jhc's E.
01:41:56 <edwardk> if they are even still using E.
01:42:09 <edwardk> given howradical these changes are to GRIN =)
01:42:35 <edwardk> ah good its there =)
01:43:56 * edwardk goes off to watch anime until someone says something ;)
01:47:42 <newsham> this bitc stuff is interesting.  they allow you to write scheme code (a subset) that doesnt require dynamic allocation
01:47:47 <newsham> including some limited closures
01:48:00 * edwardk nods.
01:49:24 <newsham> this seems like it would be very exciting for people who are interested in functional programming and OS's (even if they're not interested in formal verification)
01:49:28 <musasabi> E is still used.
02:01:45 <musasabi> Is the frisby additive example just a bad example being slow or is it just a little bit faster than parsec?
02:04:18 <musasabi> (it = Frisby)
02:21:03 <Cale> "Spineless Tagless G-Machine" would make a great name for a band.
02:21:28 <edwardk> heh
02:22:02 <sieni> hit my g-machine babe!
02:47:36 <gmak> hello guys
02:48:23 <ndm> hi gmak
02:48:38 <gmak> hi mate
02:48:54 <gmak> been reading the tutorial ricky_clarkson gave me about haskell
02:48:57 <gmak> very interesting
02:49:10 <gmak> and the tests you gave me regarding speed, very interesting too
02:49:53 <ndm> yeah, those tests will be more impressive once GHC6.6 comes out
02:49:57 <gmak> and the best part is that GHC is BSD licensed from what I checked out, my favourite license :)
02:49:58 <ndm> which is within a month
02:50:24 <ndm> and the main people are all employed by microsoft - which ensures it will remain BSD
02:50:31 <gmak> have you done any gui work with haskell
02:50:38 <gmak> ndm: amen to BSD license
02:50:41 <ndm> yep, quite a bit
02:50:45 <ndm> @where gtk2hs
02:50:46 <lambdabot> http://haskell.org/gtk2hs/
02:51:00 <edwardk> yeah, the BSD license is something i have grown to like more and more over the years
02:51:01 <gmak> hmm gtk? something non - *gplish?
02:51:17 <ndm> its not gplish
02:51:33 <ndm> (actually, i'll check)
02:51:41 <ndm> i think you can do whatever you want with it
02:51:43 <ndm> http://www-users.cs.york.ac.uk/~ndm/temp/carrot.png
02:51:55 <gmak> well guys, the GPL license is a braindead model that survived only because the linux kernel is licensed with that; so much for the hype of the moment; despite the fact I am a linux user, this does not mean I embrace that license at all
02:52:04 <gmak> i think it is LGPL ndm
02:52:30 <ndm> gmak: but, i think, you can pretty much ignore it
02:52:32 <edwardk> gmak: you won't get any disagreement from me
02:52:57 <gmak> nice thing, windows thingie ndm
02:53:36 <ndm> i kinda like the GPL :)
02:53:43 <gmak> I heard of haskell quite a while ago, but I did not have the time to study it, now I will
02:53:50 <gmak> you like it ndm, i do not
02:53:58 <ndm> http://www-users.cs.york.ac.uk/~ndm/temp/carrot2.png
02:54:10 <gmak> try making a KDE application that is fully BSD licensed: response: you cannot
02:54:11 <sieni> what's wrong with gpl? it's a fair license
02:54:21 <ndm> thats the same GUI, running under Linux - and i don't even run Linux, the same code just ran, without any issues
02:54:29 <gmak> BSD inhibits all other OSI licenses that is all
02:54:37 <gmak> now i do not wish to get offtopic guys
02:54:42 <gmak> whhops
02:54:50 <gmak> GPL inhibits all other OSI licenses that is all
02:54:52 <gmak> correction :P
02:54:54 <edwardk> seini: there are times when i don't want to be party of RMS's army of evangelists and just want to give something away.
02:55:11 <ndm> oh, i hate the GPL ramble at the front
02:55:29 <ndm> "i am RMS, i am important, you will bow to my moral way of thinking"
02:55:30 <sieni> I like RMS's attitude, even though I don'
02:55:34 <gmak> ndm: hmm any Qt bindings?
02:55:39 <sieni> don't share his opinions on other matters
02:55:39 <edwardk> seini: moreover the GPL gets in MY way when i want to give something away under something that will offer me patent protection, like an apache license 2.0
02:55:40 <jrmole> ndm, how does gtk2hs compare to wxhaskell?
02:55:43 <edwardk> or use apache 2.0 software
02:55:48 <ndm> gmak: no, there are wx bindings, but no gtk
02:55:55 <ndm> jrmole: supported vs unsupported
02:56:03 <sieni> ndm: you are free not to use or modify gpl-licensed software
02:56:16 <jrmole> by whom?
02:56:26 <ndm> jrmole: there is no windows build for wxHaskell, but is for gtk2hs
02:56:35 <ndm> jrmole: by dcoutts, and a few other people
02:56:43 <edwardk> i can appreciate his willingness to take a stance and admire his willingness to stick with it, even when i think he makes an ass out of himself, and embarrasses the entire open source community on a regular basis ;)
02:56:46 <ndm> while your wxhaskell issues are likely to fall away
02:56:48 <gmak> guys do not start a flame ware for that GPL license, it is braindead and it will kill linux because of the lack of touch with reality; that said and done I wait for nexenta/opensolaris to come up and flourish while checking out the BSD family again
02:57:09 <ndm> sieni: hoogle is under GPL, i think the license is good, just not the preamble!
02:57:10 <gmak> ndm: cool i will go with wx, since it is not gpl at all :P
02:57:18 * edwardk nods.
02:57:28 <ndm> gmak: really, you'll want gtk2hs, because its updated
02:57:35 <ndm> not sure of the license though...
02:57:40 <edwardk> i've released a fair chunk of code under it in the past, but nowadays i generally prefer a bsd or apache license.
02:57:41 <sieni> I'm a libertarian myself and what I like about GPL is that it brings up a sense of communitiy without anybody forcing anybody else.
02:57:57 <gmak> gtk+ is lgpl in its base; i expect all derived projects to be so
02:58:12 <edwardk> the GPL/LGPL make static linking into a license issue in awkward ways.
02:58:18 <gmak> perhaps when I learn haskell i try to make simple bindings for this one: upp.sourceforge.net
02:58:24 <ndm> yeah, gtk2hs is lgpl, although they don't actually tell anyone
02:58:33 <edwardk> and the GPL makes SASOS models into a licensing issue in awkward ways
02:58:38 <gmak> ndm: exaclty, GPL butt out of my software
02:58:56 <ndm> you can use teh lgpl gtk2hs, and just ignore the GPL, and license your code under the bsd
02:58:59 <sieni> but of course for a library LGPL is fine'
02:59:09 <sieni> with a static linking clause
02:59:12 <edwardk> so i basically try to stay away from both on account of the fact that i LIKE being able to statically link my code and build toy SASOSes without licensing all my code.
02:59:26 <gmak> ndm: still, i do not see the reason to have anything *GPL infecting my code like cancer
02:59:52 <gmak> hmm well ok cancer is not infectious unless virus - based :P
02:59:53 <edwardk> sieni: those are the two cases where the GPL doesn't serve my purposes, coz i can't put a static linking clause in someone else's code.
02:59:56 <ndm> gmak: fair enough, then wxhaskell is the choice for you - but only license should prompt you to take that decision
03:00:10 <gmak> ndm: infact
03:00:15 <sieni> edwardk: well, you can require that from the contributors
03:00:17 <gmak> lets get back on topic now
03:00:32 <edwardk> sieni: yeah but i can't go back and insert that clause into 3rd party projects that i use =)
03:00:39 <gmak> where can I find example haskell apps that outside haskell.org?
03:00:46 <edwardk> the static linking clause is just annoying
03:01:13 <ndm> gmak: using wxhaskell, or just any sample app?
03:01:22 <edwardk> and half of the code i write is in languages like javascript where the LGPL has no meaningful interpretation anyways
03:01:27 <sieni> edwardk: that's their choice, although I agree that static linking against a LGPL software can be a PITA
03:01:42 <sieni> (PITA == Pain In The Neck)
03:01:53 <edwardk> yet people dump out javascript under the GPL as a default 'give it away' license.
03:02:14 <gmak> ndm: anything, for now starting from the console apps
03:02:29 <ndm> gmak: large or small?
03:02:46 <gmak> hmm lets start with the small ones first, i am a beginner
03:02:54 <ndm> edwardk: you can go back to a GPL project and free it, you can't go back to a BSD project and restrict it as easily
03:03:43 <jrmole> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
03:03:45 <lambdabot> Title: Write Yourself a Scheme in 48 hours
03:04:09 <edwardk> ndm: actually, i see it the other way. i can write stuff and append it to a BSD project under a GPL license. if i do that enough it might as well be GPLed, but you can almost never relicense a GPL project uness you can track down EVERY contributor.
03:04:21 <edwardk> or you get copyright assignments
03:04:34 <edwardk> so to me it seems that the BSD license is more appropriate to give stuff away under
03:04:51 <edwardk> if you truly mean to give it away and not evangelize RMS's viewpoints ;)
03:04:57 <ndm> edwardk: http://haskell.org/haskellwiki/Hoogle#Developers
03:04:58 <lambdabot> Title: Hoogle - HaskellWiki
03:05:05 <ndm> thats how i did it for hoogle
03:05:17 <ndm> i require contributions to be under the BSD, while the project is under the GPL
03:05:24 <ndm> then I can flip it later if i feel like it
03:05:27 * edwardk nods.
03:05:45 <sieni> edwardk: yes, because bsd license allows you to relicense under gpl
03:05:54 <edwardk> technically you need a physical assignment for copyright assignment to be binding and hold up in court.
03:05:58 <gmak> ndm: that is a dangerous mix, bsd allows you to relicense, gpl does not
03:05:59 <ndm> i just want to give stuff away, but if anyone makes any money out of it then i want a cut!
03:06:12 <reppie> lol
03:06:14 <ndm> gmak: but i own all the GPL code, hence i can relicese that too
03:06:23 <ndm> my supervisor once released some code
03:06:28 <ndm> without any protections on it
03:06:30 <jrmole> if you truly mean to give it away and nothing else, make it public domain
03:06:35 <edwardk> ndm: then i'm surprised you chose GPL and not a Mozilla style license
03:06:36 <gmak> ndm: correction: yes you can, and then give away peopl a fork of your code you have no control in (previous GPL eds remain gpl)
03:06:45 <ndm> and it ended up being on the front page of a book, and he got nothing!
03:06:55 <edwardk> ndm: *nods*
03:07:07 <Heffalump> what book, OOI?
03:07:25 <ndm> no idea, but he was cautioning me when i was about to release the hoogle code
03:07:30 <Stinger_> what kind of book puts code on a front page
03:07:32 <edwardk> i just find the encumbrances it gives me outweigh the benefits it gives me, so i choose to adopt similar licenses with different encumbrances.
03:08:14 <ndm> edwardk: originally i chose the creative-commons-no-commerical license, since thats exactly what i want, but thats just too much work since no one knows it
03:08:22 <edwardk> yah
03:08:35 <edwardk> i have no problem with commercial users i guess
03:08:46 <ndm> and neither google or sourceforge recognise it as an open source license
03:08:53 * edwardk nods
03:08:57 <gmak> ndm: CC is what google uses
03:09:15 <gmak> in some of their projects
03:09:19 <ndm> gmak: really? they only accept about 4 open source licenses
03:09:21 <gmak> but they do not recognize it lol
03:09:33 <gmak> i think they do use CC licenes
03:09:36 <gmak> licenses too
03:09:41 <gmak> you have to check that out
03:10:01 <ndm> nah, time spent on licenses is time wasted on code
03:10:14 <ndm> thats why i liked the cc licenses, pretty pictures :)
03:10:55 <gmak> well it is the most important thing, and I am either doing this the BSD way or some other non - *GPL way. Religious Idealism leads to prolonged comatose situations
03:11:12 <gmak> hmm what is hoogle exaclty again?
03:11:24 <ndm> @where hoogle
03:11:24 <lambdabot> http://www.haskell.org/hoogle
03:11:35 <ndm> gmak: a haskell search engine, for example:
03:11:42 <ndm> @hoogle (a -> b) -> [a] -> [b]
03:11:43 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
03:11:43 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
03:11:43 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
03:11:52 <ndm> @hoogle sort
03:11:53 <lambdabot> List.sort :: Ord a => [a] -> [a]
03:11:53 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
03:11:53 <lambdabot> System.Win32.NLS.sORTIDFROMLCID :: LCID -> SortID
03:12:26 <gmak> oh nice
03:12:28 <edwardk> well, my main concern is i want to be able to license code that i write so that people can't remove the copyright, can do textual library inclusion for things in scripting languages, can't sue me for patent conflicts after contributing the code that caused the infringement, and that allows me or others to statically link the library or use it in a SASOS.
03:12:40 <edwardk> all of those fronts the GPL gets in my way
03:12:47 <gmak> edwardk: BSD
03:12:50 <edwardk> yeah
03:13:02 <edwardk> thats why i use the BSD license for stuff i care little about
03:13:17 <gmak> if you care a lot, roll your own
03:13:18 <edwardk> and i use an apache 2.0 license with some extra clauses when i want the rest.
03:13:36 <ndm> i want to keep the option open for google to buy up hoogle, should they feel the desire
03:13:49 <gmak> there is also krugle
03:14:00 <edwardk> oh, and i'd like to be able to minimize the boilerplate forced into my code on a per-file basis.
03:14:30 <edwardk> hence why my code is usually written with the per-file license being copyright edward kmett. all rights reserved. and the only licensing rights i give being on the whole package.
03:14:32 <ndm> ah, i never put the GPL boilerplate in
03:14:47 <edwardk> ndm: you have to be careful there, that can legally weaken your case, etc.
03:15:37 <edwardk> coz the whole package can be stripped out into some source repository then and your licensing lost. then people can make claims of good faith effort that they couldn't figure out the license ont he source file when they opened it on some code-search site, etc.
03:15:50 <edwardk> thats why all those stupid licenses have boilerplate clauses. =/
03:16:07 <edwardk> and the shortest thing i know thats legally binding is an all rights reserved. =)
03:16:09 <ndm> -- released under the GPL 2.0, (C) Neil Mitchell
03:16:37 <ndm> i did for a while used to license things under the GPL prime number license
03:16:38 <edwardk> you're probably safe but i wouldn't want to defend it in court ;)
03:16:53 <ndm> I can't pay for anyone to go to court, so its rather a moot point
03:17:08 <edwardk> well, thats what the EFF is for ;)
03:17:20 <ndm> This code is released under the GPL 2.0, or at your option, any later prime numbered version of the GPL
03:17:21 <xerox> ?yow!
03:17:22 <lambdabot> Once upon a time, four AMPHIBIOUS HOG CALLERS attacked a family of
03:17:22 <lambdabot> DEFENSELESS, SENSITIVE COIN COLLECTORS and brought DOWN their PROPERTY
03:17:22 <lambdabot> VALUES!!
03:17:37 <edwardk> heh
03:18:46 <gmak> lol i better license software under the Microsoft EULA than GPL
03:19:04 * edwardk climbs down from his soapbox. ;)
03:19:08 <gmak> lol
03:19:34 <edwardk> the main reason i like the haskell community is that so much of it is BSD licensed.
03:19:41 <edwardk> its very free and open
03:19:49 <edwardk> more concern with writing code than hashing out licenses.
03:19:58 <gmak> ndm: is there any supporting IDE for haskell, are there for example eclipse plugins for that
03:20:21 <gmak> edwardk: yes I see the point, and I could not agree more
03:20:25 <edwardk> no clause of the BSD license conflicts with any usage i have for the code, so i am more than willing to give back to the community
03:20:55 <ndm> gmak: there is Visual Haskell, which integrates with Visual Studio
03:21:03 <ndm> but i just use TextPad + WinHugs
03:21:17 <ndm> someone is doing eclipse stuff, but its not quite ready yet, i belive
03:21:20 <gmak> yes  but i would like to use it on unix environments
03:21:36 <edwardk> yeah the eclipse haskell plugin blew up my eclipse install =/
03:21:46 <gmak> oh it did?
03:21:49 <sieni> there is also Christianity, which integrates with the Republican Party, but I fail to see how either is desirable
03:22:12 <gmak> oh crap, you mixed politics with religion, bad BAD thing
03:22:14 <edwardk> well, i have a pretty mangled setup coz i was using a lot of adobe flex stuff
03:22:36 <gmak> edwardk: nonetheless, where is the eclipse plugin for haskell?
03:22:52 <ndm> sieni: a reasonable proportion of haskell developers are Christian
03:23:12 <edwardk> now now, all you have to do is take anything a republican says and stick the words 'by killing people for Christ' to the end of it and it makes a lot more sense. think of the 'in bed' game people play with fortune cookies.
03:23:22 <Heffalump> higher than the proportion fo the general population that is Christian?
03:23:27 <Heffalump> s/fo/of/
03:23:29 <ndm> in my experience, yes
03:24:12 <ndm> although outside of haskell i know roughly as many satan worshipers as christians]
03:24:25 <ndm> so that might be just the kind of people i hang around with
03:24:26 <gmak> lol
03:24:34 <Heffalump> :-)
03:24:38 <edwardk> heh
03:24:49 <gmak> chinese will rule the world
03:24:53 <gmak> :)
03:25:01 <gmak> hmm correction
03:25:04 <gmak> chinese rule the world
03:25:14 <dons> hehe
03:25:32 <dons> ?remember ndm outside of haskell i know roughly as many satan worshipers as christians.
03:25:33 <lambdabot> Done.
03:25:57 <gmak> anyway I really like the chan, i really like the lang so far
03:26:11 <gmak> cannot wait to be able to understand House :)
03:26:30 * Heffalump thinks he'll have to start an atheist offshoot of Haskell ;-)
03:26:34 <gmak> ndm: are haskell features to be ported to C# 3.0 ?
03:26:43 * edwardk joins heff's project ;)
03:26:54 <ndm> gmak: no, there are haskell like influences, but thats about it
03:26:54 <dons> #haskell-athiests eh?
03:27:10 <gmak> hmm #haskell-shintoists
03:27:28 <edwardk> gmak: they did already, well, into VB anyways, they are called query comprehensions. you might have heard of them as 'monad comprehensions' back in the day. ;)
03:27:41 <mnislaih> Lemmih: ping
03:27:53 * edwardk views religious debates as about as useful as license debates ;)
03:27:54 <xerox> There's the #ideology channel too.
03:28:04 <xerox> #ideologies, sorry.
03:28:13 <edwardk> I choose not to adopt certain religions because they get in my way more than they help ;)
03:28:41 <gmak> edwardk: never used VB
03:29:00 <ndm> gmak: lambda expressions are very obviously haskell like
03:30:32 <gmak> ndm: prolly
03:32:43 <ndm> Heffalump: i managed to write my own BDD code, was reasonably easy - thanks for the help
03:32:48 <Heffalump> cool
03:32:58 <Heffalump> BDDs rock :-)
03:33:05 <ndm> of course, its now got a lot more complex because my thing doesn't really like "not" on terms
03:33:14 <Heffalump> wdym?
03:33:19 <gmak> http://eclipsefp.sourceforge.net/haskell/index.html <--- is that it?
03:33:21 <lambdabot> Title: Haskell support in Eclipse
03:33:29 <ndm> each atom in the BDD is \forall x, f(x)
03:33:37 <edwardk> looks right
03:33:43 <ndm> so the not of a term is \exists x,¬f(x)
03:33:43 <Heffalump> I don't follow
03:33:56 <Heffalump> I thought you didn't have quantifiers.
03:34:05 <ndm> i don't which scope over the terms
03:34:14 <ndm> but i do inside the individual terms
03:34:19 <gmak> i hope by xmas to have spent enough time to be able to work with haskell as easily as doing math on paper :)
03:34:20 <ndm> and the quantifiers are implicit
03:34:30 * Heffalump doesn't really follow
03:34:42 <ndm> anyway, not is entirely broken, but other than that bdd's are great
03:34:52 <ndm> and not is only broken because of my semantics for the terms
03:35:04 <ndm> the only thing i can't do is show them to the user nicely
03:35:15 <ndm> although that may be my brain not understanding bdd's
03:35:19 <Heffalump> so what exactly are your BDD variables?
03:35:51 <ndm> Req Expr Path [Ctor]
03:35:57 <ndm> where Expr is a Haskell expression
03:36:01 <ndm> Path is a regular expression
03:36:06 <ndm> and Ctor is a set of constructors
03:36:17 <Heffalump> I see, so your logical expressions are combinations of these things?
03:36:25 <ndm> and the semantics say \forall x \in Path, Expr.x \in Ctor
03:36:28 <ndm> yep
03:36:52 <ndm> but that \forall, if you flip the high and low of a BDD that should be not
03:36:58 <Heffalump> if you don't put nots into the BDD, I don't think you'd get nots out.
03:37:02 <ndm> but it doesn't work if you have quantifiers
03:37:08 <ndm> i do put nots in :)
03:37:30 <Heffalump> ok, so can't you implement \exists x \in Path, Expr.x \not \in Ctor ?
03:37:33 <ndm> but you can not one of those things in a speical maner, by taking the complement of Ctor
03:37:47 <ndm> that doesn't work, because of complications with fixed pointing
03:37:49 <Heffalump> Expr.x is always some Ctor?
03:37:57 <ndm> yes
03:38:09 <ndm> well, not quite
03:38:22 <ndm> for example [].hd is considered to be all constructors
03:38:31 <Heffalump> huh?
03:38:38 <ndm> yeah, its a quirky system
03:38:44 <Heffalump> anyway, where does the fixpointing come from?
03:38:57 <ndm> thats an entirely different phase, detached from the BDD's
03:39:21 <Heffalump> so what do you actually extract from the BDDs, a logical expression?
03:39:28 <gmak> YES! Fc5 fully supports Haskell
03:39:29 <gmak> :P
03:39:36 <Heffalump> or do you evaluate them directly?
03:39:45 <Heffalump> the BDDs that is
03:39:49 <ndm> all of the above, and more :)
03:40:12 <ndm> i want to simplify the expression, so find out if its true or false as soon as possbile, and reject redundant terms - which BDD's are _GREAT_ for
03:40:23 <ndm> show it to the end user
03:40:33 <ndm> and combine them, as the calculation progresses
03:41:03 <edwardk> heff: did you ever work out the lambda problems with that TH [| run () |] code?
03:41:18 <Heffalump> edwardk: I got distracted by another project, as is common with me
03:41:22 <edwardk> kk
03:41:26 <edwardk> understand completely =)
03:42:05 <edwardk> bbl
03:53:20 <foxy> dons, you said at some point that (I think) associated types allow predicates over types, or is it something else?
03:54:17 <gmak> installing ghc642...
03:54:48 <gmak> ndm: i did not read much on how ghc works, does it work like cfront by producing c code or it does things on its own?
03:55:07 <ndm> its a full 100% compiler
03:55:12 <ndm> which can output either ASM
03:55:20 <ndm> or C, but very very low level C
03:55:27 <ndm> more like portable assembler
03:55:54 <gmak> hmm make it simple, it works without a C compiler, correct?
03:56:15 <ndm> maybe, but probably not
03:56:20 <gmak> ok
03:56:36 <reppie> ndm C is ALWAYS low level :)
03:56:38 <ndm> but it just uses your existing gcc
03:57:01 <gmak> reppie: LOL
03:57:27 <reppie> gmak you think i'm joking?
03:57:58 <gmak> nope, not at all
03:58:07 <gmak> C has managed to survive because it is low level
03:58:19 <gmak> C & asm aint going to go away soon
03:58:37 <reppie> C survived because the most popular OS is written in it!
03:58:50 <gmak> lol
03:58:51 <ndm> yeah, windows is written in C
03:59:01 <gmak> windows is written in C++ too :P
03:59:06 <reppie> ndm UNIX..
03:59:13 <gmak> lol
03:59:15 <gmak> i love this
04:00:07 * gmak is reading about darcs
04:00:34 <nilsi> @quote
04:00:35 <lambdabot> TuringTest says: They got it work in Haskell without understanding Haskell.  It is quite an achievement, of some description.
04:00:52 <reppie> @quote
04:00:53 <lambdabot> SamB says: Boy, point-free Arrows are worse than Forth...
04:01:52 <gmak> http://repetae.net/john/computer/jhc/jhc.html <--- what about this guys
04:01:54 <lambdabot> Title: Jhc
04:02:24 <ndm> highly alpha
04:02:26 <ndm> fast code
04:02:32 <ndm> more readable C output
04:02:36 <ndm> smaller binaries
04:02:36 <nilsi> wonderfull
04:03:08 <gmak> it is alpha - quality compiler?
04:03:08 <nilsi> windows port, anyone?
04:03:24 <gmak> meaning that ghc is the standard for 100% compliance?
04:03:30 <gmak> and working binaries of course
04:03:50 <nilsi> ghc is standard
04:04:08 <Heffalump> sadly, yes (not that it isn't very good, but it'd be nice to have two equally reliable compilers)
04:04:17 <ndm> Jhc is GPL as well :)
04:04:21 <Heffalump> Hugs isn't bad.
04:04:42 <nilsi> and ghc has many extensions real world apps use,  so other compilers have a hard time
04:04:53 <gmak> ok jhc is dead then
04:05:07 <Heffalump> why?
04:05:22 <ndm> he's not a GPL fan :)
04:05:22 <nilsi> well no, jhc provides those extensions :)
04:05:26 <gmak> i am not using GPL software unless I have to
04:05:45 <nilsi> you have to :)
04:05:57 <Heffalump> you run Windows then?
04:06:11 <ndm> and browse things with IE :)
04:06:33 <musasabi> gmak: none of Haskell compilers is 100% standard compliance.
04:07:10 <ndm> but nowadays everyone wants GHC compliant, not haskell compliant
04:07:18 <gmak> well ghc is the standard right now no? not many C++ compilers are 100% compliant either :P
04:07:19 <musasabi> gmak: and GHC uses gcc ;)
04:07:35 <gmak> musasabi: i know, but i do not care about gcc
04:07:48 <nilsi> boooo
04:07:48 <musasabi> hmm?
04:07:49 <gmak> that is where i limit gpl for
04:07:59 <nilsi> ?
04:08:05 <musasabi> GPL in a C compiler is ok, but not in a Haskell compiler?
04:08:09 <musasabi> What is the logic?
04:08:11 <gmak> yup
04:08:16 <gmak> simple
04:08:32 <gmak> i do not like GPL unless I have to because there is no alternative
04:08:33 <nilsi> simplistic, maybe
04:08:37 <Heffalump> you'll have to avoid darcs too..
04:08:50 <gmak> the C code produced by GHC could be well compiled by intel C compilers I presume
04:08:58 <ndm> no chance
04:09:00 <musasabi> no
04:09:00 <Heffalump> I think it uses GNU extensions.
04:09:05 <gmak> heffalump: i said, do not use GPL unless you have to
04:09:08 <Heffalump> and GHC hacks on the output of gcc further.
04:09:17 <ndm> if you use hugs, thats not GPL
04:09:23 <musasabi> gmak: well there are many non-GPL version control systems
04:09:33 <gmak> then it aint producing 100% ANSI C code, which on its homepage says it does
04:09:36 <Heffalump> I'll use GPL as much as I like, you're the one that doesn't want it :-)
04:09:48 <gmak> musasabi: i want to learn first, evaluate, adopt later
04:09:51 <ndm> does it really claim that, isn't that Jhc
04:10:03 <nilsi> seems so
04:10:17 <Heffalump> I guess it's just possible that an unregisterised build would work with non-gcc.
04:10:43 <gmak> guys, i really do not care about the GPL license, i can use the end products without accepting the license, says so in the contract; i am not allowd to make any work based on them that is non - GPL
04:10:44 <ndm> i wouldn't like to be the one trying that...
04:11:10 <gmak> seems fair enough to me to use gpl products only when i absolutely have to, hey I am using linux...
04:11:23 <ndm> gmak: just use Hugs, its possibly better for learning, 100% BSD - I use Hugs all the time
04:11:25 <Heffalump> but you don't have to use Linux..
04:11:40 * musasabi uses *BSD on the desktop, no need for Linux.
04:11:47 <gmak> i do, supports all of my hardware, FreeBSD does not, yet, and OpenSolaris is in the works for that
04:12:02 <gmak> musasabi: once all drivers work on FreeBSD i move there
04:12:14 <musasabi> well one can choose supported harware, that is usually easy and cheap.
04:12:46 <Maddas> Unless you require software that only runs on Linux. (Yes, I know about the compatibility layer of FreeBSD)
04:12:48 <gmak> heh easy said, not easy done at times
04:14:05 <gmak> guys, is the eclipse plugin for haskell do anything more than syntax highlighting perhaps?
04:26:59 <ivant> @seen igloo
04:26:59 <lambdabot> igloo is in #darcs and #haskell. I don't know when igloo last spoke.
04:27:25 <Igloo> Hello
04:29:48 <mnislaih> @seen Lemmih
04:29:48 <lambdabot> Lemmih is in #ypn, #haskell-overflow and #haskell. I last heard Lemmih speak 2 hours, 19 minutes and 23 seconds ago.
04:30:42 <Lemmih> mnislaih: Hiya.
04:31:02 <mnislaih> Lemmih: I have a question about the dynamic linker
04:31:56 <mnislaih> can I expect 'relinking' things to have effect immediately ?
04:32:15 <mnislaih> it seems to have effect only after reloading modules
04:32:47 <Lemmih> Relinking?
04:32:48 <mnislaih> btw Lemmih, I have just pushed a bunch of patches
04:33:15 <mnislaih> relinking in the sense of using extendLinkEnv
04:33:49 <mnislaih> it would be cool to have :break on and :break off to disable breakpoins temporarily
04:34:27 <mnislaih> relinking the jump function to a don't stop closure is a possible implementation idea
04:35:00 <ivant> Igloo: I was trying to find out is there the ghc 6.5 distribution for debian (may be in experimental?)
04:35:23 <Lemmih> Changing the linkenv doesn't affect the already linked code.
04:36:21 <Igloo> ivant: Not currently, but there should be in a day or two. Are you on the debian-haskell list?
04:36:29 <mnislaih> so, I'll discard that route then
04:36:46 <ivant> Igloo: no, where do I find it?
04:36:57 <ivant> @where debian-haskell
04:36:58 <lambdabot> I know nothing about debian-haskell.
04:37:04 <Igloo> http://urchin.earth.li/mailman/listinfo/debian-haskell
04:37:06 <lambdabot> Title: debian-haskell Info Page
04:38:01 <Lemmih> mnislaih: You haven't yet pushed the code to the main repo, right?
04:38:16 <mnislaih> no, I haven't. Should I do that ?
04:38:18 <ivant> @where+ debian-haskell http://urchin.earth.li/mailman/listinfo/debian-haskell
04:38:18 <lambdabot> Done.
04:39:26 <mnislaih> simply darcs send http://darcs.haskell.org/ghc, right ?
04:39:28 <lambdabot> Title: Index of /ghc
04:39:36 <Lemmih> mnislaih: I think so, yes. Unless there are some outstanding issues we need to address first.
04:41:12 <Lemmih> mnislaih: darcs push.
04:42:01 <lhp> hi, i have a question about the ListT monad transformer
04:42:32 <lhp> what is the equivalent of (x <- [1,2,3]) within a ListT?
04:46:42 <musasabi> @type (do x <- lift [1,2,4]; return ())
04:46:43 <lambdabot> forall (t :: (* -> *) -> * -> *). (MonadTrans t, Monad (t [])) => t [] ()
04:47:56 <musasabi> hmm, that is wrong.
04:49:39 <lhp> yeah it's sort of the opposite of lifiting i think
04:52:13 <dons> ?undo do x <- lift [1,2,4]; return ()
04:52:13 <lambdabot> lift [1, 2, 4] >>= \ x -> return ()
04:52:31 <dons> ?compose pl undo do x <- lift [1,2,4]; return ()
04:52:31 <lambdabot> lift [1, 2, 4] >> return
04:52:38 <dons> ?type lift [1, 2, 4] >> return
04:52:39 <lambdabot>   Expecting a function type, but found `m b'
04:52:39 <lambdabot>    Expected type: t [] b
04:53:16 <dons> ?type lift [1, 2, 4] >> return ()
04:53:18 <lambdabot> forall (t :: (* -> *) -> * -> *). (MonadTrans t, Monad (t [])) => t [] ()
04:54:11 <lhp> it's not lifting because the monad the ListT is built on top of isn't (necessarily) a list monad
05:02:59 <lhp> ah, i think you can just use the ListT constructor
05:04:50 <lhp> so (x <- ListT [1,2,3])
05:06:06 <lhp> oh, not quite
05:08:24 <lhp> ok, (x <- ListT $ return [1,2,3])
05:08:32 <lhp> if anyone cares hehe
05:18:59 <jrmole> what's the interpretation of ListT?
05:19:20 <jrmole> i understand the List monad all right, but I'm having a hard time understanding what you could do with a value of type, say, ListT Maybe a
05:20:19 <lhp> it's nondeterminism basically
05:20:45 <lhp> instead of binding a variable to a value you bind it to a set of possible values
05:21:25 <lhp> hmm, sorry, that's just an explanation of what you know already
05:21:55 <jrmole> i'm trying to understand ListT Maybe a versus [Maybe a]
05:22:24 <jrmole> is the former just the latter with more monadic machinery accessible?
05:23:00 <lhp> Well, i /think/ ListT (Maybe a) is redudant, because you already have failure in the plain List monad
05:23:05 <lhp> so it would probably just be confusing
05:23:12 <lhp> (certainly got me confused)
05:23:27 <jrmole> yeah, but just for didactic purposes, Maybe is the simplest monad to combine it with
05:25:42 <lhp> I think it is a lost like [Maybe a], yeah
05:25:52 <lhp> but i haven't tried it and i'm a bit confused
05:26:12 <lhp> a lot like
05:26:31 <jrmole> actually, by experimentation it's a lot like Maybe [a]
05:27:59 <lhp> oh
05:28:03 <jrmole> your individual computations return nondeterministic results, or a differentiated failure value
05:28:52 <jrmole> and the overall result is all the nondeterministic results from all possible paths, or that failure value if any computation failed
05:29:16 <lhp> hmm, sounds like it might even be useful for something
05:29:39 <jrmole> yeah, if for some reason you want to distinguish "no nondeterministic results" from actual failure
05:29:58 <lhp> i was combining it with the ST monad myself
05:30:39 <jrmole> sounds tricky
05:31:08 <jrmole> backtracking and mutable variables don't play well together
05:31:38 <lhp> this is true, it might not work very well
05:31:58 <jrmole> i think i'd have a hard time understanding the semantics of such a value
05:32:01 <jrmole> but good luck ;)
05:32:19 <lhp> no you're right, i hadn't thought of that problem
05:32:51 <jrmole> you could use a pure State monad
05:33:11 <lhp> well, if i'm going to use STArrays, then it has to be within ST
05:33:19 <lhp> but maybe i shouldn't use STArrays...
05:34:00 <lhp> this is the thing that bugs me about haskell sometimes, using an array for something is like some kind of mini research project
05:34:07 <jrmole> yeah
05:34:39 <jrmole> on the other hand, you don't need them nearly as often as in some other languages
05:34:45 <lhp> true
05:34:58 <lhp> what i'm doing really is searching the array and updating elements with certain properties
05:35:08 <lhp> and the nondeterminism helps in the search
05:35:29 <jrmole> O(log n) lookup is often good enough, and Data.Map / Data.Set are wonderfully easy to use
05:36:03 <xerox> ?yow!
05:36:03 <lambdabot> I want a mega-meal in a mega-mall.
05:36:35 <lhp> well, it's not so much the lookup time as the time it takes to remove an element (or replace it with a new one)
05:36:38 <jrmole> if only one branch actually updates, i don't see a problem with ListT ST
05:36:46 <jrmole> yeah
05:37:10 <lhp> no, i think it will be ok as long as each thread of the computation only updates one element of the array
05:37:21 <lhp> and it's clear which thread is responsible for which element
05:37:45 <jrmole> though that's more along the lines of "using mutable variables is like some kind of mini research project"
05:37:58 <lhp> yeah hehe
05:38:02 <jrmole> but i agree, it's worse with arrays, especially if you want them to be as fast as C arrays
05:38:33 <lhp> well, the data structure in question is a chart in a chart parser
05:38:49 <lhp> so i guess the "haskell way" would be to design the chart so you didn't need to remove anything or update it in place
05:40:30 <jrmole> well you can always remove by creating a new persistent data structure, but the efficiency will be bad
05:40:38 <jrmole> what sort of chart is this?
05:41:35 <lhp> it's for a "minimalist grammar" (a formalism for parsing natural languages)
05:41:49 <jrmole> and if you're just using nondeterminism to traverse the structure, you might want to make that a separate pass... build a list of elements that need updates, then mapM
05:42:00 <lhp> it's quite simple, basically just a pair of input stream positions and a structure
05:42:13 <lhp> as in, that is what each element in the chart consists of
05:42:45 <lhp> *thinks* is it possible to do that and escape the ST monad?
05:43:00 <lhp> or are you suggesting not using ST?
05:43:09 <jrmole> why do you need to escape the ST monad?
05:43:31 <lhp> well, my array is an STArray (let's assume), so I have to be in the ST monad to get at it
05:43:50 <lhp> there's no way of getting the array out of the ST monad without making it immutable
05:43:52 <jrmole> do { nodes <- findUpdateNodes; mapM_ update nodes }
05:44:22 <jrmole> where findUpdateNodes :: ST s [NodeIdentifier], and update :: NodeIdentifier -> ST s ()
05:44:40 <jrmole> is basically the structure of what i was suggesting
05:44:47 <jrmole> but i don't know if it actually fits your task
05:45:01 <lhp> i think it does, let me think...
05:45:23 <lhp> well in a slightly different form yeah
05:45:44 <lhp> i think i'd get the array a list, then pass the list to an ordinary computation in the List monad, so i could do my nondeterministic searching
05:45:56 <lhp> that, assuming each element of the list was paired with the array index, no problem
05:46:02 <lhp> **then
05:46:20 <jrmole> should work
05:46:31 <lhp> (hopefully laziness would mean there wasn't too much overhead in converting it to a list?)
05:46:40 <lhp> otherwise i might as well not bother with the STArray
05:46:56 <jrmole> i guess what i suggested still involves something like ListT ST, but you've made the ST-ness read-only, which makes it easier to reason about imho
05:47:09 <jrmole> in fact you could probably get away with unsafePerformST in that case
05:47:25 <lhp> ok, right, then converting to a list might not be necessary
05:47:51 <lhp> except insofar as ListT makes lots of lists anyway
05:47:54 <lhp> *head explodes*
05:48:27 <jrmole> well, i'm not really sure how you're using nondeterminsm.  i was assuming there's some overall predicate telling whether a given node needs an update
05:48:42 <lhp> ah right, no
05:49:16 <lhp> it's more like "find nodes that satisfy P, then pair them with nodes that satisfy Q, then apply R to the pairs to filter them"
05:49:26 <lhp> and then do some updates based on the pairs
05:49:50 <lhp> so using the list monad you can avoid a lot of boilerplate mapping functions over lists, etc.
05:49:54 <jrmole> yeah
05:50:57 <lhp> ok well i think i should be able to sort it out now, thanks
05:51:05 <jrmole> something like [ (a,b) | a <- filter p nodes, b <- filter q nodes, r a b] ?
05:51:15 <lhp> yeah just like that
05:52:29 <jrmole> all right, good luck
05:52:47 <lhp> hehe thanks
06:04:28 <lennart> good morning
06:08:05 <xerox> ?type (.) . (=<<)
06:08:06 <lambdabot> forall a a1 (m :: * -> *) b. (Monad m) => (a1 -> m b) -> (a -> m a1) -> a -> m b
06:18:08 <MAGMAG> i'm looking for a program named "Load Runner".
06:18:20 <MAGMAG> does any1 know this prog?
06:19:09 <ValarQ> MAGMAG: what does it do?
06:20:00 <MAGMAG> I think it should be some kind of attacking toolkit.
06:20:49 <ValarQ> what kind of attack?
06:21:36 <MAGMAG> web attacks (I think)
06:23:06 <MAGMAG> by the way, I've one more important question to ask.
06:23:14 <ValarQ> ok, have you searched packetstorm?
06:23:47 <MAGMAG> I don't think i find it there. but i'll surely do that.
06:23:56 <MAGMAG> have you read "SHELLCODER'sHANDBOOK" book?
06:25:37 <ValarQ> nope, i know enough shellcoding for my needs
06:26:33 <MAGMAG> hmm, I just think there is a mistake in that book (in explaining stack and how it grows).
06:26:49 <sieni> ot
06:26:59 <lennart> I played Lod Runner on the original Mac.  It was a fun game. :)
06:27:26 <ValarQ> sieni: srry
06:27:34 <MAGMAG> :D
06:29:07 <sieni> ValarQ: yr wlcme
06:29:26 <MAGMAG> sieni :ot ??
06:29:39 <sieni> ot == offtopic
06:30:33 <MAGMAG> hmmm]
06:33:20 <MAGMAG> ok, thanks ValarQ,sieni,lennart.
06:33:25 <MAGMAG> bye for now ;)
06:49:11 <mcnster> morning.  is there a standard fn to read a String into an Int where the representation in String is hex?
06:50:07 <lennart> > read "0x100" :: Integer
06:50:08 <lambdabot>  256
06:50:17 <xerox> > read "0x<Interrupted by lennart>
06:50:18 <lambdabot>  Improperly terminated string
06:50:45 <lennart> so the fn would be read . ("0x" ++)
06:51:37 <xerox> > readHex "FFFF" ""
06:51:38 <lambdabot>    The function `readHex' is applied to two arguments,
06:51:38 <lambdabot>   but its type `Re...
06:51:46 <xerox> > readHex "FFFF"
06:51:47 <lambdabot>  [(65535,"")]
06:52:00 <sieni> > fst . readHex "FFFF"
06:52:01 <lambdabot>    Expecting a function type, but found `[(a, String)]'
06:52:01 <lambdabot>    Expected type...
06:52:05 <sieni> oops
06:52:14 <xerox> s/./$/
06:52:19 <lennart> readHex is a little more cumbersome
06:52:36 <mcnster> excellent, thanks.  (i thought everyone was at church)  :D
06:52:38 <lennart> you need a head in there too
06:52:38 <sieni> > fst . readHex $ "FFFF"
06:52:39 <lambdabot>  Couldn't match `(a, b)' against `[(a1, String)]'
06:52:52 <sieni> fst (readHex "FFFF")
06:52:56 <xerox> head it
06:52:59 <sieni> > fst (readHex "FFFF")
06:53:00 <lambdabot>  Couldn't match `(a, b)' against `[(a1, String)]'
06:53:02 <lennart> alonzo is our church
06:53:04 <sieni> aaaaaargh
06:53:12 <sieni> yes, right
06:53:19 <xerox> > fst . head . readHex $ "deadbeef"
06:53:20 <lambdabot>  3735928559
06:53:21 <sieni> I didn't notice the brackets
06:59:45 <dons> ?remember lennart alonzo is our church
06:59:46 <lambdabot> Done.
07:00:20 <sieni> If I ever found a religion, I'll name it Alonzo,
07:00:22 <sieni> .
07:11:18 <zeeeeee> hi all, are there any libraries with common string routines, like checking if one ends with another? or is the shortest way: pat == drop (length str - length pat) str?
07:11:55 <mnislaih> ?type isSuffixOf
07:11:56 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
07:12:00 <lennart> isSuffixOf
07:12:17 <dons> zeeeeee: yeah, Data.List is the lib you're looking for, probably
07:12:23 <dons> ?docs Data.List
07:12:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
07:12:57 <zeeeeee> thanks all
07:13:30 <dons> lennart: we have a new plugin you might like, its a bit Djinn-ish:
07:13:33 <dons> ?free id :: a -> a
07:13:34 <lambdabot> f . id = id . f
07:13:41 <dons> ?free sortBy :: (a -> a -> Ordering) -> [a] -> [a]
07:13:42 <lambdabot> g x y = h (f x) (f y) => $map f . sortBy g = sortBy h . $map f
07:13:54 <dons> ?free free sequence_ :: [M a] -> M ()
07:13:54 <lambdabot> Expected OpColonColon
07:13:55 <lennart> cool!!!
07:14:01 <dons> ?free sequence_ :: [M a] -> M ()
07:14:01 <lambdabot> g y = y => $map_M g (sequence_ x) = sequence_ ($map ($map_M f) x)
07:14:08 <lennart> ?free const
07:14:08 <lambdabot> Expected OpColonColon
07:14:15 <dons> ?help free
07:14:16 <lambdabot> free <id :: a -> a>. Generate theorems for free
07:14:27 <lennart> ?free const :: a -> b -> a
07:14:28 <lambdabot> f . const x = const (f x) . g
07:14:57 <dons> ?free unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
07:14:57 <lambdabot> ( ( ( g ($proj_2_1 y) = $proj_2_1 z       &&       f ($proj_2_2 y) = $proj_2_2 z     )    =>     p y = z   )  =>   $map_Maybe p (h x) = k (f x) ) => $map g . unfoldr h = unfoldr k . f
07:15:00 <zeeeeee> is it possible to have the interpreter load two modules at once? (i.e., :m Data.Char then :m Data.List makes ghci forget the first)
07:15:04 <dons> proj_2_1 == fst
07:15:11 <dons> zeeeeee: yep, :m + Data.List
07:15:16 <zeeeeee> dons: thanks again
07:16:04 <lennart> ?free maybe :: a -> (b -> a) -> Maybe b -> a
07:16:05 <lambdabot> f . h = k . g => f . maybe x h = maybe (f x) k . $map_Maybe g
07:16:05 <dons> ?free foldl :: (a -> b -> a) -> a -> [b] -> a
07:16:06 <lambdabot> f . h x = k (f x) . g => f . foldl h y = foldl k (f y) . $map g
07:16:42 <lennart> And $map is the map function for a type?
07:16:43 <mnislaih> zee use :m +Data.Char Data.List
07:16:49 <dons> lennart: yep.
07:17:01 <dons> ?where free
07:17:02 <lambdabot> http://andrew.bromage.org/darcs/freetheorems
07:17:04 <lennart> ?free noway :: a -> b
07:17:05 <lambdabot> g . noway = noway . f
07:17:40 <dons> ?free undefined :: a
07:17:40 <lambdabot> f undefined = undefined
07:18:11 <lennart> hmmm
07:18:21 <kosmikus> interesting
07:18:22 <lennart> what functions does f range over?
07:18:57 <dons> hmm
07:19:10 <dons> ?free undefined :: a -> a
07:19:11 <lambdabot> f . undefined = undefined . f
07:19:31 <lennart> maybe only strict functions
07:20:03 <dons> ?free id :: (a -> b) -> (a -> b)
07:20:04 <lambdabot> g . h = k . f => g . id h = id k . f
07:20:08 <lennart> the whole theorems for free is only valid (without tons of side conditions) for Set
07:20:48 <kosmikus> yes, Wadler says in his paper that he assumes everything to be strict, iirc
07:21:06 <dons> ?free callcc :: ((a -> (forall r. (b -> r) -> r)) -> (forall r. (a -> r) -> r)) -> (forall r. (a
07:21:06 <lambdabot> free module failed: IRCRaised Plugin/Free/Type.hs:(153,16)-(161,44): Non-exhaustive patterns in case
07:21:09 <dons> -> r) -> r)
07:21:11 <dons> grr
07:21:26 <dons> ?free callcc :: ((a -> (forall r. (b -> r) -> r)) -> (forall r. (a -> r) -> r)) -> (forall r. (a -> r) -> r)
07:21:26 <lambdabot> ( ( f1 . f2 = f3 . g    =>     f1 (p x f2) = q (f x) f3   )  =>   f4 . f5 = f6 . f  =>   f4 (h p f5) = k q f6 ) => f7 . f8 = f9 . f => f7 (callcc h f8) = callcc k f9
07:21:32 <dons> heh
07:22:20 <lennart> urgh!
07:24:01 <kpreid> dons: re putting leading spaces before the output of lambdabot commands which can produce arbitrary output: why not just disallow \1 instead?
07:24:23 <lennart> > "\1"
07:24:24 <lambdabot>  "\SOH"
07:24:51 <flux__> > "\2"
07:24:52 <lambdabot>  "\STX"
07:25:23 <lennart> > ['\0' .. '\31']
07:25:25 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
07:26:31 <dons> kpreid: not a bad idea!
07:27:01 <kpreid> dons: this thought inspired by the patch that I just saw in darcs pull which Messing With The Purity Of My @unquote :-)
07:27:14 <dons> right :)
07:27:24 <dons> yes, so maybe that's a better idea.
07:28:07 <lennart> ?free r :: (Monad m) => a -> m a
07:28:08 <lambdabot> Extra stuff at end of line
07:28:17 <kpreid> dons: also, does "Remove hs-plugins dependency by default." affect @run
07:28:19 <kpreid> ?
07:28:22 <dons> ?free r :: a -> M a
07:28:22 <lambdabot> $map_M f . r = r . f
07:28:29 <dons> kpreid: yes.
07:28:46 <kpreid> so what do I need to do? not apply it, or do something after applying it?
07:28:51 <dons> you only get @run if you build with hs-plugins (which most home users don't care about)
07:29:04 <dons> ah, you just switch to the .plugins cabal file, install hs-plugins, and proceed as normal
07:29:24 <lennart> ?free join :: M (M a) -> M a
07:29:24 <lambdabot> $map_M f . join = join . $map_M ($map_M f)
07:30:25 <lennart> ?free f :: Bool -> Bool
07:30:25 <lambdabot> f = f
07:30:40 <ValarQ> dons: is runplugs replaced in lambdabot?
07:30:49 <dons> ValarQ: hmm, replaced?
07:31:12 <dons> no, but you only get it if you explicitly use the .plugins cabal file (and install hs-plugins)
07:31:37 <ValarQ> dons: how do i excpicitly use that cabal file?
07:31:51 <dons> $ mv lambdabot.cabal.plugins lambdabot.cabal
07:31:54 <dons> :)
07:31:58 <ValarQ> ah :)
07:33:25 <dons> ?. pl undo  do e1' <- rnExp e1 ; e2' <- rnExp e2 ; return $ ThEqual e1' e2'
07:33:26 <lambdabot> (`fmap` rnExp e2) . ThEqual =<< rnExp e1
07:35:16 <lennart> fmap?  that can't be strictly right :)
07:35:43 <araujo> morning!
07:36:20 <lennart> ?undo do Just x <- f y; return x
07:36:20 <lambdabot> f y >>= \ Just x -> return x
07:37:36 <kpreid> missing parentheses?
07:37:50 <dons> ?type f y >>= \ Just x -> return x
07:37:51 <lambdabot> Not in scope: `f'
07:37:51 <lambdabot>  
07:37:51 <lambdabot> <interactive>:1:2: Not in scope: `y'
07:37:57 <lennart> that is just plain wrong
07:38:08 <dons> ?type \f y -> f y >>= \ Just x -> return x
07:38:10 <lambdabot>   Constructor `Just' should have 1 argument, but has been given 0
07:38:10 <lambdabot>   When checking the pattern: Just
07:38:19 <dons> ?type \f y -> f y >>= \(Just x) -> return x
07:38:20 <lennart> failed pattern matching calls the fail function in the monad
07:38:21 <lambdabot> forall t a (m :: * -> *). (Monad m) => (t -> m (Maybe a)) -> t -> m a
07:38:35 <dons> yeah, that's missing from the desugaring
07:38:42 <dons> sjanssen: ping :) ^^^
07:39:03 <lennart> > (do Just x <- return Nothing; return x) :: [ Int ]
07:39:04 <lambdabot>  []
07:39:37 <lennart> I don't like it, but that's how Haskell is.
07:40:21 <lennart> @undo do Just x <- return Nothing; return x
07:40:22 <lambdabot> return Nothing >>= \ Just x -> return x
07:40:56 <lennart> > (return Nothing >>= \ (Just x) -> return x) :: [Int]
07:40:57 <lambdabot>  Non-exhaustive patterns in lambda
07:44:14 <lennart> @undo (do Just x <- return Nothing; return x) :: [ Int ]
07:44:15 <lambdabot> (return Nothing >>= \ Just x -> return x) :: [Int]
07:44:52 <lennart> dons: is there a sed plugin for lambdabot?
07:45:07 <dons> funny you ask that. I'm going to add one
07:45:51 <dons> we had a hack where you could insert arbitrary haskell to hack strings, but it was a bit prone to abuse (you could have lambdabot generate ctcp pings)
07:45:55 <lennart> Hmm, it will need two arguments.  Can @. handle that
07:46:05 <dons> no, but that's the other thing to add
07:46:15 <dons> a bit of parsing
07:46:18 <ricky_clarkson> Are there any non-FP languages that do tail-recursion optimisation?
07:46:55 <lennart> like @. undo (sed "s/Just x/(Just x)/") (do Just x <- return Nothing; return x) :: [ Int ]
07:47:06 <dons> right.
07:47:28 <dons> or more useful , if the output of say, @djinn doesn't match what @pl wants, it can be mangled a bit
07:47:39 <lennart> ricky_clarkson: some implementations do tail-recursion opt
07:47:51 <dons> gcc does it in some cases
07:47:58 <lennart> like gcc does it under certain circumstances
07:48:20 <ricky_clarkson> Can you force it to, or tell whether it does?
07:48:34 <lennart> you can tell by looking at the assmbly code :)
07:49:06 <dons> I think you can see gcc doing it here, http://shootout.alioth.debian.org/gp4/benchmark.php?test=recursive&lang=all
07:49:07 <lambdabot> Title: recursive benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Languag ...
07:49:48 <lennart> I'm not sure when gcc does it these days.  It used to be very limited, but I hear it's better now.
07:51:40 <ricky_clarkson> I wonder whether gcj can do it for Java.
07:52:04 <lennart> It's hard to do for Java.  Very hard.
07:52:23 <lennart> Because the the security model is built on stack inspection
07:52:46 <ricky_clarkson> Hmm.
07:52:50 <lennart> So calls to the security manager expects the stack frames to be there.,
07:53:04 <ricky_clarkson> An article suggests that IBM's JVM for 1.3 does it in the JIT.
07:53:29 <lennart> yeah, with a JIT you might have a chance, because you see the context of the call.
07:54:13 <ricky_clarkson> I'll try their test case with newer Sun VMs.
07:54:17 <ricky_clarkson> http://www-128.ibm.com/developerworks/java/library/j-diag8.html
07:54:19 <lambdabot> Title: Diagnosing Java Code: Improve the performance of your Java code
07:54:35 <lennart> but gcj is an AOT isn't it?
07:55:30 <ricky_clarkson> I'm not sure what you mean about the security model being related to the stack.
07:55:47 <ricky_clarkson> If at least one stack frame is there it should be able to do what it needs.
07:59:03 <lennart> well, you mustn't squeeze out the frame that is the one that shows the security check is ok
07:59:11 <lennart> but it's not impossible: http://www.csc.calpoly.edu/~clements/papers/cf-toplas04.pdf
08:08:36 <kpreid> darcs seems to be taking a Very Long Time thinking about the ~62 lambdabot patches I pulled
08:18:41 <rictic> Is there a way to express that if a type is an instance of one class if it is an instance of another?
08:19:02 <rictic> instance (Enum b) => Example b where
08:19:02 <rictic>    ...
08:19:06 <rictic> Gives me an error
08:19:24 <rictic> instance (Example a) => Example [a] where
08:19:26 <rictic> Does not
08:23:25 <zeeeeee> when i try loading the PreludeExts module i get a syntax error on the line defining 'composeM' (there's a "in -"). how should this be fixed?
08:24:01 <zeeeeee> http://www.haskell.org/hawiki/PreludeExts
08:24:02 <lambdabot> Title: PreludeExts - The Haskell Wiki
08:47:11 <ivant> @index isJust
08:47:11 <lambdabot> Data.Maybe
08:51:08 <ivant> @index sprintf
08:51:09 <lambdabot> bzzt
08:51:13 <ivant> @index printf
08:51:14 <lambdabot> Text.Printf
08:51:36 <ivant> @hoogle printf
08:51:37 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
08:51:37 <lambdabot> Text.Printf :: module
08:51:37 <lambdabot> Text.Printf.hPrintf :: HPrintfType r => Handle -> String -> r
08:55:02 <ivant> @seen ndm
08:55:02 <lambdabot> I saw ndm leaving #haskell 4 hours, 23 minutes and 8 seconds ago, and .
09:00:13 <gmak> back
09:03:25 <gmak> what else do i need to write a program in haskell asides ghc and vim ?
09:04:08 <gmak> is there anything I should be taking care of after having installed the ghc compiler?
09:04:53 <gmak> guess not :)
09:05:01 <mnislaih> gmak: you need a tutorial, a good editor, and your brain
09:05:49 <dylan> mmm, brains
09:06:20 <gmak> mnislaih: done, done, born with
09:06:22 <gmak> :)
09:06:58 <mnislaih> mine only works at certain times of the day, only a few days a week
09:07:03 <gmak> lol
09:07:12 <gmak> what, the editor ? (lol)
09:07:34 <gmak> with these new union rules, our brains may call a strike when we most need them...
09:08:00 <ivant> gmak: they do strike a lot when I'm programming haskell
09:09:08 <gmak> well i have not been into FP before, so i guess it will call on strikes because of this change
09:09:30 <gmak> but since i am an absolute dictator, neurons will either have to conform to my regime or else
09:09:50 * gmak is being off topic
09:10:05 <ivant> gmak: do you want to quick-check if they are going to strike?
09:10:13 <dylan> it is amusing, at least.
09:11:08 <ivant> gmak: try understanding what "Y combinator" is
09:11:16 <ivant> @wikipedia Y combinator
09:11:19 <lambdabot> No Result Found.
09:11:22 <ivant> shoot
09:11:24 <gmak> ivant: i started the haskell thing yesterday
09:11:32 <ivant> http://en.wikipedia.org/wiki/Y_combinator
09:11:34 <gmak> so we are in study phase
09:11:51 <ivant> it is not quite about Haskell
09:13:24 <gmak> did I mention i am not a master of lambda calculus (yet)
09:14:35 <gmak> the fun part about haskell is that it is going to make me study more math for fun; right now it seems that the two are happily married
09:17:39 <ivant> hmm, why do I get runtime error "non-exaustive pattern search" when i have two patterns:
09:17:54 <ivant> | someBooleanValue = ...
09:18:00 <ivant> | otherwise = ...
09:18:03 <ivant> ?
09:19:44 <norpan> those are not patterns
09:19:47 <norpan> those are guards
09:21:48 <ivant> @index isNothing
09:21:49 <lambdabot> Data.Maybe
09:22:54 <ivant> aren't they translated into "case val of ..." ?
09:27:36 <gmak> hmm ok I think I found a book I would like to study with the tutorials: Purely functional Data structures by Chris Okasaki; I downloaded his phd thesis from a website, does anyone know if the book is different than the thesis?
09:28:51 <ivant> hmm, I think I tried to read it but it was extremely complex for my poor brain at that time
09:29:42 <gmak> i am first going to do the math work on this; i believe that there is fat chance i master haskell unless i feel at home with the math theory behind it
09:29:48 <ivant> you'd better start from classics, like "Gentle introduction to Haskell" and when you got bored reading it, start actually implementing something
09:30:11 <gmak> i got a tutorial from ricky_clarkson
09:30:20 <gmak> a 192 page one, i am currently readin
09:30:47 <gmak> then i will start with hello - worldish proggies
09:30:48 <ivant> the one with problems which you should solve and write on the pages?
09:30:57 <ivant> s/write/write the solution/
09:31:04 <gmak> wait i tel you the name
09:31:09 <gmak> *title
09:31:42 <ivant> gmak: I can suggest you a great task which helped me to understand lots of things when I implemented it
09:32:38 <ivant> after you have done with hello-worldish programs, you can try writing a program which randomly sorts (using the Knuth shuffle algorithm) the lines in a file
09:33:24 <gmak> yet another haskell tutorial <--- title
09:33:41 <ivant> it is not very complex, but it makes use of some concepts which you'd need to use in real programs (IO and ST monads)
09:33:56 <gmak> ivant: yeah i think that algorithm implementations in haskell may be of help in acquiring knowledge
09:34:01 <gmak> i will try, most definitely
09:34:20 <gmak> to be honest I was thinking of re - writing an XML parser project I have completed in C++ to Haskell
09:34:29 <ivant> good luck then, it was fun when I tried to do it
09:34:54 <gmak> how much time did it take you to be able to write your first algorithm in haskell on your own?
09:35:56 <ivant> it took less than half an hour to write a program which prints out all the solutions of Queens problem for NxN board
09:37:15 <ivant> and then, after a very long pause (couple of years), it took me 3 hours to write the program which raomized the lines in a file
09:38:01 <ivant> s/rao/rando/
09:38:20 <gmak> lollol 3 years pause?
09:38:49 <gmak> anyway i must first finish this tutorial ricky_clarkson was kind enough to give and trhe introduction to lambda
09:40:13 <ricky_clarkson> gmak: You are probably already further in it than I am.
09:42:03 <gmak> lol ricky_clarkson i am honoured, but you are probably a very good programmer from what I see in #Java :)
09:42:17 <ricky_clarkson> Optical illusion. ;)
09:44:14 <gmak> lol
09:45:53 <lokadin> anywhere i could find a sockets tutorial for making a basic server?
09:46:16 <lokadin> in haskell preferably
09:46:48 <ivant_> lokadin: why don't you look at the sources of HAppS for example?
09:47:14 <lokadin> it's so overwhelming to look at the source of those huge applications
09:47:15 <lokadin> :(
09:47:37 <lokadin> hmmm and it doesn't seem like i have a package for it
09:48:21 <ivant> @where HApps
09:48:21 <lambdabot> http://happs.org
09:48:34 <lokadin> thanks' i found it already
09:48:39 <ivant> it is an application server written in Haskell
09:48:56 <lokadin> what exactly is that?
09:49:02 <lokadin> an application server that is
09:49:37 <ricky_clarkson> Typically, a HTTP server that supports plugins.
09:49:50 <ivant> it is a web server that serves HTTP and also allows to write some business logic in haskell
09:49:52 <ricky_clarkson> The plugins are called applications.
09:49:57 <gmak> anyway guys I am off for a bit, it is clean - install time for all the oses of this box (w2k3r2, fc5, freebsd)
09:50:12 <gmak> thanks for all the tips, bbl
09:50:18 <lokadin> hmmm
09:51:12 <ivant> i.e., it is a piece of software which wraps all the low-level stuff which you need when you want to write so web-application
09:52:10 <ivant> @wikipedia Application server
09:52:12 <lambdabot> No Result Found.
09:52:27 <lokadin> it's all good thanks, you guys explained it sufficiently
09:52:28 <lokadin> :)
09:52:39 <ivant> argh, what's wrong with this wikipedia plugin?!
09:53:01 <ricky_clarkson> @uncyclopedia Haskell
09:53:01 <lambdabot> Unknown command, try @list
09:54:18 <dmwit> @pl enumerate array = zip ((enumFromTo (0::Coord) . length) array) array
09:54:18 <lambdabot> enumerate = zip =<< enumFromTo (0 :: Coord) . length
10:03:26 <ricky_clarkson> Does hugs in interactive mode just evaluate stuff - it can't create functions?
10:04:11 <Igloo> Yes
10:04:34 <ricky_clarkson> Damn.
10:04:38 <Igloo> You can still use let expressions, though
10:04:41 <Igloo> ghci also lets you use let statements
10:08:45 <ivant> is there an easy way to define a "test" target in Cabal?
10:08:47 <gmak> ricky_clarkson: u in here?
10:08:55 <ricky_clarkson> Just about.
10:09:01 <gmak> care to pm?
10:09:08 <ivant> so that I could say something like "./Setup.hs test"?
10:09:10 <gmak> came back just for this :)
10:09:29 <ricky_clarkson> gmak: I'm on my way out, but if you like I'll read it later/tomorrow/next year sometime.
10:09:36 <ricky_clarkson> gmak: Or email - ricky.clarkson@gmail.com
10:09:42 <ivant> oops, it seems that I'm blind
10:09:49 <gmak> hmm better leave this in pm
10:09:53 <ivant> I've found it myself :-)
10:11:29 <gmak> ricky_clarkson: check your pm, i am gone now :)
10:12:07 <mnislaih> Igloo: do you know what to do if darcs takes forever to run a pull ?
10:12:39 <SamB> @tell gmak /msg lambdabot @help tell
10:12:40 <lambdabot> Consider it noted.
10:13:54 <SamB> @tell gmak or maybe just /msg lambdabot help tell
10:13:55 <lambdabot> Consider it noted.
10:23:18 <ivant> @hoogle filter
10:23:19 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
10:23:19 <lambdabot> Data.IntMap.filter :: (a -> Bool) -> IntMap a -> IntMap a
10:23:19 <lambdabot> Data.IntSet.filter :: (Int -> Bool) -> IntSet -> IntSet
10:25:28 <ivant> @pl f de = not $ name de `elem` z
10:25:28 <lambdabot> f = not . (`elem` z) . name
10:29:50 <ivant> @pl s de = p a (n de) (t de)
10:29:50 <lambdabot> s = ap (p a . n) t
10:30:31 <ivant> @list pointless
10:30:32 <lambdabot> pl provides: pointless pl-resume pl
10:30:37 <ivant> @pl-resume
10:30:38 <lambdabot> pointless: sorry, nothing to resume.
10:35:22 <ivant> @haddock ap
10:35:22 <lambdabot> Unknown command, try @list
10:35:27 <ivant> @index ap
10:35:27 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
10:35:27 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
11:06:19 <bringert> hi #haskell
11:06:26 <bringert> long time no see
11:07:16 <eivuokko> Hiya
11:11:49 <Korollary> back in sweden eh
11:16:30 <kosmikus> bringert: I booked the hotel, btw.
11:18:18 <Karlik> Is here somebody from Russian?
11:18:35 * bringert speaks russian
11:18:45 <bringert> but I'm swedish
11:18:59 <Karlik> Privet
11:19:06 <bringert> privet
11:19:14 <Karlik> Mozhesh ob'yasnit' odnu fignu po povodu monad
11:19:16 <Karlik> ?
11:19:33 <bringert> the language of this channel is english
11:19:48 <Pupeno_> #haskel.ru maybe ?
11:19:53 <Karlik> Kak komputernoe opredelenie soglasuetsa s matematicheskim
11:20:20 <ivant> Karlik: I'm from Russia
11:20:41 <Karlik> русский виден?
11:20:57 <Karlik> Ya ne nashel russkogo kanala
11:20:59 <Pupeno_> Do you, anyone there, suffer when finding code with different purposes in the same file/module/library ?
11:21:35 <lisppaste2> zeeeee pasted "beginner program" at http://paste.lisp.org/display/24827
11:21:50 <Pupeno_> am I alone ?
11:21:51 <bringert> Karlik: da, no my zdec govrim tolko po anglijskij
11:22:00 <ivant> Pupeno_: sorry, didn't quite get it
11:22:20 <Heffalump> Pupeno_: I can't think of any specific instance of it happening, but yes
11:22:35 <Heffalump> zeeeeee: did you want help with something with your code?
11:22:36 <Karlik> ivant do you have icq?
11:22:44 <Karlik> or jabber
11:22:56 <zeeeeee> hi all, i'm looking for critiques of my program. i'm a beginner so anything helps. this script is supposed to (if possible) merge the 4th and 5th columns of a csv, depending on the suffix. however it's been made very ugly due to Maybes.
11:23:01 * Heffalump agrees with the #haskell.ru suggestion
11:23:11 <zeeeeee> Heffalump: sorry, i forgot the pastebin would announce the paste :)
11:23:29 <Heffalump> zeeeeee: np :-) One trick with the Maybes is to use do notation. Do you know anything about monads?
11:23:39 <zeeeeee> Heffalump: i've been trying to avoid that :)
11:23:47 <Heffalump> generally I think your code looks ok, if a little fragile (the list pattern match)
11:23:47 <zeeeeee> Heffalump: monads that is
11:24:07 <Heffalump> I think all those fromJusts are rather fragile too
11:24:31 * bringert is alone in #haskell.ru
11:24:52 <zeeeeee> Heffalump: what should i do about those?
11:25:07 <Heffalump> well, my primary suggestion would be using the monad ;-)
11:25:29 <Pupeno_> I was asked to make a config class (not in Haskell) and since config reloading was a needed feature, now the config class is a mix of config and application reloading system in which resources are re-loaded and before the previous is dumped and well, it just doesn't go there and I hate it. Looking at that code makes me 'vomit'.
11:27:28 <Heffalump> zeeeeee: somehow, you have to handle the possibility of failure
11:27:42 <zeeeeee> Heffalump: i'm willing to learn monads of course... it'll just be a while before i get through those sections in YAHT. i was just wondering if maybe i wasn't "thinking in Haskell" enough (maybe there was another way to write it without Maybes)
11:28:02 <Heffalump> not that I can think of
11:28:10 <Heffalump> fundamentally, you have to handle the possibility of failure
11:28:27 <zeeeeee> Heffalump: i think i saw something about a try clause in haskell...is that what you're referring to?
11:28:28 <Pupeno_> or a colegue has a directory for mixins, called "mixins" but since he also codded a set of components at the same time (and some mixins load some compenents) the components are in "mixins" as well. It drives me crazy. Doesn't that kind of thing drive you crazy ?
11:28:40 <Heffalump> no, try is to do with exceptions, which you don't really need here
11:28:54 <Heffalump> (though the Maybe monad is a kind of exception monad, but viewing it that way is overkill here)
11:30:32 <zeeeeee> Heffalump: hmmm...so i just need to add another case to processFields to return Nothing when the pattern doesn't match. is that what you're getting at?
11:32:29 <Heffalump> yeah
11:34:29 <lisppaste2> Heffalump annotated #24827 with "rewritten version" at http://paste.lisp.org/display/24827#1
11:34:46 <Heffalump> I had a very quick run through your program rewriting it in terms of the Maybe monad
11:34:58 <Heffalump> which obviously doesn't help you understand the monad directly, and I didn't actually check my rewritten version works
11:35:04 <Heffalump> but it might be of use to you
11:35:14 <Heffalump> (it does at least typecheck :-)
11:35:46 <Heffalump> I also changed your isJust/fromJust pair near the top to use a pattern-matching guard in the list comprehension
11:35:54 * Heffalump gets dragged away for dinner, back in a while
11:36:02 <zeeeeee> Heffalump: ooh...i'll go figure out what's going on
11:36:05 <zeeeeee> Heffalump: thanks
11:36:45 <bringert> Network.NewCGI is now Network.CGI in the hierarchical libraries, and will come with GHC 6.6. The problem is that I don't know what to do with the current standalone library. I can't change it to contain Network.CGI, since that clashes with the existing module in the network package. And I don't want to keep the old name around for ever, and I don't want to maintain two bracnhes.
11:36:57 <bringert> any ideas?
11:37:47 <Igloo> Make a pre_ghc_6_6.sh that just does a little sed on the library?
11:40:20 * bringert shudders
11:40:39 <bringert> yeah, that could work
11:40:59 <bringert> but then people with pre 6.6 ghc have to stick with the old mdoule name
11:41:32 <bringert> and if they distribute their code, it has to use Network.NewCGI to be compilable with old compilers
11:42:05 <bringert> well, if anyone distributes code really
11:43:06 <Igloo> You could put it in a newnetwork package, then
11:43:17 <Igloo> But you'd have to also copy everythign else in the network package
11:43:31 <ndm> bringert: what do you mean by "old" - some compilers, like Yhc are brand new but only support Haskell 98
11:44:26 <bringert> I meant compilers which come with the old hierachical libraries, specifically versions which include the old Network.CGI
11:44:42 <ndm> ah, in that case i forgive you :)
11:45:31 <bringert> ndm: the new cgi package won't work under Yhc then, since it uses MPTCs
11:45:40 <bringert> though that can be stripped away
11:45:49 <ndm> or added to Yhc, which is a better option
11:45:55 <ndm> and hopefully will happen, one day
11:48:52 <bringert> the library is useful without it though
11:49:06 <bringert> it's just for the monad transformer sugar on top
11:49:12 <dylan> hmm. I have noticed something. Event-based systems need to be flat, or relatively flat, otherwise it's a major mind fsck to understand them.
11:49:31 <musasabi> many new libraries seem to use MPTC+FD, which are very nice for powerful things, but not needed in all those libraries.
11:51:09 <ndm> its like any new toy, people want to play
11:51:35 <ndm> what concerns me is that the type system seems to be an unending source of new toys...
11:51:36 <ivant> ndm: Why System/FilePath.hs:466 is "x ++ [pathSeparator] ++ y", not "x ++ (pathSeparator : y)"?
11:51:50 <ndm> ivant: better symetry
11:52:01 <ivant> is performance the same?
11:52:07 <ndm> ivant: i am willing to stake money that GHC generates the same Core output
11:52:16 <musasabi> MPTC+FD creates more complex error messages
11:52:48 <ndm> ivant: i am having a FilePath rewrite at some point, so after i've got all the semantics concrete, might change a few things like that - for the benefit of Hugs/Yhc
11:52:52 <musasabi> of course in some cases one wants the whole GADT+FD+MPTC+... to do really fancy things
11:52:55 <ndm> but not until the semantics are pinned down
11:53:01 <ivant> ndm: yeah, I guess it is quite a simple optimization idea
11:53:28 <ndm> ivant: a really basic case of inling, GHC wins well on things like that
11:53:55 <ndm> you wouldn't need the brackets btw, the priorities and fixities of : and ++ are designed to avoid that
11:53:55 <Karlik> people. Can anybody told me about Monad on haskell.ru
11:54:07 <ndm> musasabi: darcs is going that way...
11:54:24 <Karlik> Please
11:54:34 <musasabi> ndm: yes, but Roundy seems to want to use GADT for useful things, so it is not that bad.
11:54:45 <musasabi> ndm: and toys in applications are not such a problem.
11:54:52 <Igloo> Have you got an example of where GADTs/MPTCs are used frivolously?
11:54:55 <musasabi> in libraries they are much harder.
11:54:56 <bringert> Karlik: there doesn't seem to be anyone here who can answer your question in russian.
11:54:56 <ndm> musasabi: true
11:55:25 <bringert> Karlik is asking about the relationship between Haskell's monads and the monads in category theory
11:55:33 <ivant> Karlik: I gave you my jabber id, does it work for you?
11:55:35 <ndm> is there a null monad?
11:55:44 <ndm> for example, at the mo I do fromJust at teh end
11:55:51 <ndm> and it will never become nothing
11:55:58 <Igloo> There's the ID Monad
11:56:02 <bringert> ndm: Control.Monad.Identity
11:56:04 <ndm> @hoogle ID
11:56:04 <musasabi> Igloo: e.g. the streams package seemed to use them extensively when I looked the last time.
11:56:05 <lambdabot> Prelude.id :: a -> a
11:56:05 <lambdabot> Control.Monad.Identity :: module
11:56:05 <lambdabot> Text.Html.identifier :: String -> HtmlAttr
11:56:18 <ndm> @docs Control.Monad.Identity
11:56:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Identity.html
11:56:40 <Karlik> ivant: my jabber don't work
11:56:40 <ndm> Igloo, bringert: perfect :)
11:56:49 <Igloo> Fair enough; I'm not familiar with that
11:57:02 <Karlik> ivant: answer my pleas on /join #haskell.ru
11:59:06 <ivant> @ehelp window
11:59:07 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:59:10 <ivant> oops
12:00:09 <Karlik> all
12:04:04 <ndm> people have now done 75,000 hoogle searches on teh web page
12:05:18 <ndm> including:
12:05:20 <ndm> instale windows xp y grub ya no aparece
12:05:29 <bringert> haha
12:05:41 <ndm> potatoe
12:05:48 <bringert> ndm: do you have a count of unique users?
12:06:08 <ndm> is Alaska in danger
12:06:16 <ndm> nope, i just record the query strings that come in
12:06:24 <ndm> i deliberately don't want to record unique users
12:06:38 <lennart> what's the answer to "is alaska in danger"? :)
12:06:51 <ndm> the answer to every question in Hoogle 3 is:
12:07:06 <lennart> hahaha
12:07:06 <ndm> Did you mean: Is Alaska In Danger
12:07:32 <lennart> top answer is "undefined"
12:07:41 <ndm> since it figures your type sig is all free variables, free variables are usually one letter long, so you probably meant the type constructor Is with 3 args
12:07:54 <ndm> yep, thats the answer to "random question"
12:08:03 <ndm> followed by bottom
12:08:10 <ell-hask> So, if I have a list, and entries in the list need to be deleted at certain times, how is that best accomplished?  In 'C' I would set an alarm, lock, and alter the global variable as needed.  In Haskell I would catch the alarm signal?
12:08:38 <ndm> ell-hask: typically, you wouldn't have a global variable, and you'd keep maybe a Map, and delete from that
12:08:40 <ndm> and pass it around
12:08:40 <int-e> forkIO, threadDelay, modify.
12:10:18 <ell-hask> ?where modify
12:10:18 <lambdabot> I know nothing about modify.
12:10:33 <ndm> @hoogle modify
12:10:33 <lambdabot> Control.Monad.State.modify :: MonadState s m => (s -> s) -> m ()
12:10:34 <lambdabot> Data.IORef.modifyIORef :: IORef a -> (a -> a) -> IO ()
12:10:34 <lambdabot> Data.STRef.modifySTRef :: STRef s a -> (a -> a) -> ST s ()
12:10:45 <int-e> modify was a placeholder for the modification of the global variable
12:11:03 <ndm> two amusing queries one after another: simon peyton Jones, then next is: simon peyton Jones genius
12:11:06 <int-e> @index modifyMVar
12:11:07 <lambdabot> Control.Concurrent.MVar, Control.Concurrent
12:19:19 * Heffalump reappears
12:21:18 <ell-hask> And what about databases with multiple indexes?  Such as if I want to look up an entry based on its 'validity time' or based on its IP address?
12:21:33 <ell-hask> Sets and Bags don't do me much good.
12:22:08 <ell-hask> Do I have to make my own with zipper, interact with a non-haskell component such as SQL, or is there a Haskell piece I can use?
12:22:11 <bringert> Igloo: congratulations on the GHC job btw
12:22:17 <bringert> when do you start?
12:23:41 <Igloo> Thanks, and last Monday
12:24:00 <ndm> Igloo: how much time are you GHC'ing a week? (if you don;t mind me asking, of course)
12:24:02 <bringert> oh, that was fast
12:24:31 <bringert> man, you are going to be getting a lot of support questions in here
12:24:45 <Igloo> ndm: Contract says 5 days a week
12:24:54 <ndm> so full time?
12:24:57 <Igloo> Yup
12:25:24 <mux> dcoutts_: fwiw, I have just committed your patch to the FreeBSD port of gtk2hs
12:26:44 * Igloo was hoping to get lots of successful builds+testsuite-runs this weekend before the RC is announced, but everything seems to be breaking instead
12:27:21 <ndm> Igloo: have you seen buildbot? its what Yhc is using
12:27:27 <ndm> and is much better than GHC nightlyl builds
12:27:50 <ndm> in fact, its so good that we can fix systems we don't have access to, and have done a couple of times
12:27:59 <ndm> http://indiegigs.co.uk:8010/
12:28:06 <Igloo> I've only done a couple of builds per machine, so any infrastructure wouldn't be worthwhile for me
12:28:06 <lambdabot> Title: BuildBot: Yhc
12:28:23 <ndm> its an infrastructure for replacing nightly builds
12:28:27 <ndm> and getting real time feedback
12:28:39 <ndm> you get build slaves, which can be anyone, and buildbot controls them
12:28:57 <ndm> could get you nightly builds, but on many machines, without complex setup for each slave
12:29:13 <wolverian> I get slaves?! sign me up!
12:29:20 <musasabi> ndm: is that released separately from Yhc?
12:29:32 <ndm> musasabi: its nothing to do with Yhc, its a python project
12:29:40 <musasabi> sounds interesting for non-haskell things too to replace a mess of shell-scripts.
12:29:43 <ndm> so it actually works :)
12:29:58 <ndm> it basicallyl can invoke the shell script in phases
12:30:07 <ndm> and report on success/failure of each
12:30:38 <ndm> adding a slave is about 5 minutes
12:30:44 <ndm> so you can get a wide variety of platforms
12:31:03 <ndm> we did the Linux ppc port by getting a build slave, which failed, and prodding it remotely with new builds until it worked
12:31:18 <ndm> much easier than the conversations over a mailing list "can you try this, etc."
12:32:57 <eivuokko> Hmm.
12:33:36 <eivuokko> That is nice in principle, but it really takes up the machine.
12:33:53 <eivuokko> And GHC build takes a lot of time (depending on options, tho)
12:34:13 <ndm> eivuokko: i run it on my main desktop machine
12:34:23 <ndm> one goes on teh York comp sci server
12:34:32 <ndm> one on a web server that feeds web pages as well
12:34:41 <ndm> one on someones bittorrent mac mini
12:34:51 <ndm> its really easy, and you can nice it up
12:34:56 <ndm> and runs in the background
12:35:00 <ndm> even on windows :)
12:36:02 <ndm> admitedly Yhc is a lot quicker to build than GHC, but when niced highly, its not too important
12:36:20 <ndm> we do builds every 10 minutes if there has been a change, GHC might want 6/12/24 hours instead of that
12:36:25 <ndm> and you can still invoke a full bold
12:36:44 <ndm> plus we have different systems - some do clean, some do full clean, some do just an update
12:38:46 <eivuokko> Yeah, well, my point was that GHC build takes 3-4h on some configs, and buildin when things change means they can't neccesarily pinpoint problem and harass correct person.
12:39:42 <ndm> why can't they pinpoint?
12:39:59 <ndm> thats one of the things buildbot does - blame list, for the authors of patches that have been included
12:40:08 <ivant> eivuokko: wow, building the JDK only takes 35 minutes on my laptop!
12:40:19 <musasabi> eivuokko: of course most of the libraries and optimization could be omitted for the builds - and if one can specify "only build between 3-7AM" there would be little problem.
12:40:49 <ndm> oh, i should have mentioned, build slaves do  not have to be available all the time - if they are disconnected it just builds when it reconnects
12:40:55 <eivuokko> musasabi, That seems exactly like reading cvs-ghc mailing list...once a day you see what went in and what builds failed.
12:41:24 <mnislaih> eivuokko: if it takes 3-4h you are probably using Windows to build it
12:41:33 <musasabi> eivuokko: except that more exotic platforms are rarely tested.
12:41:35 <mnislaih> here it takes far less than an hour
12:41:37 <eivuokko> I have nothing against automated builds, ime it just doesn't help for slowly building programs like GHC.
12:41:48 <eivuokko> *help to build more often than once a day
12:42:00 <musasabi> and thus things bitrot.
12:42:02 <ndm> eivuokko: just think of it as nightly builds that are easier to set up, and easier for people to offer machines for
12:44:27 <eivuokko> ndm, Sure.  I just meant that GHC might not benefit from all the benefits you get.  Easier setting up of slaves would be cool, of course.
12:44:34 <eivuokko> *you get with yhc
12:45:12 <Igloo> How is it easier, OOI? I don't think I've looked at the nightly scripts in detail, but I assume it's just a matter of setting the paths and adding the cronjob it tells you?
12:45:38 <eivuokko> Igloo, It isn't really clear in Windows, and looking into scripts I think they require cygwin.
12:45:42 <ndm> Igloo: much easier, and better reporting, and Windows/Unix compatible, and can invoke additional builds at whim, and easier to keep track of
12:46:06 <ndm> http://www.haskell.org/haskellwiki/Yhc/Buildbot
12:46:07 <lambdabot> Title: Yhc/Buildbot - HaskellWiki
12:46:08 <ndm> its that easy
12:46:30 <ndm> one command line, once
12:46:35 <ndm> plus ask for a user name/password
12:46:50 <eivuokko> Not sure how it has better error reporting, except sending people mails if it deems their patches caused the problem.
12:46:58 <ndm> a web status
12:47:12 <ndm> showing the build state of each platform, errormessages, what failed etc.
12:47:53 <ndm> we just send the build problems to a mailing list, not to invididuals
12:48:02 <eivuokko> Ah, ok.  I quite like the emails with links to los.
12:48:30 <eivuokko> But, sure, we could have nice webpage.
12:48:45 <ndm> the best bit is how easy it is to add and manage new slaves
12:48:48 <ndm> its trivial
12:49:04 <ndm> which means that when people email in with a compiler error - you just reply "set it up as a buildbot slave"
12:50:11 <ndm> i think buildbot could really enhance the reliability of GHC, and keep it more solid over long periods of times on loads of platforms - but thats just my guess :)
12:57:45 <kuribas> > (+)0o69
12:57:46 <lambdabot>  15
12:58:48 <AtnNn> lol
13:00:26 <int-e> nasty.
13:01:34 <int-e> > (-)0o777777777778589934591
13:01:35 <lambdabot>  0
13:03:26 <xerox> ?arrr
13:03:26 <lambdabot> Drink up, me 'earties
13:05:36 <xerox> ?type Data.List.sort
13:05:37 <lambdabot> forall a. (Ord a) => [a] -> [a]
13:05:45 <xerox> ?fptools Data.List
13:05:45 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
13:06:49 <eivuokko> ndm, Are you going to suggest the buildbot for GHC on a mailing list?
13:07:24 <ndm> eivuokko: shall i?
13:07:55 <ndm> i am happy to, although thought that asking Igloo might be the best way - since he'd probably end up doing it (if i understand his responsibilities within GHC HQ)
13:07:55 <eivuokko> ndm, I'm just curious.  Setting slave easily would be nice.
13:09:05 <ndm> eivuokko: ok, will do that - which mailing list would be best?
13:09:14 <Igloo> Oh, sorry, didn't realise you were suggesting GHC HQ use it
13:09:43 <ndm> Igloo: its not really much use for individuals - should have made my suggestion clearer :)
13:10:09 <Igloo> I'd just e-mail Simon Marlow as he'd probably be the one with privs to set it up somewhere suitable
13:10:45 <eivuokko> I'd run slave most of the time, I think.
13:10:56 <ndm> I'd certainly be happy to
13:11:06 <ndm> you can even have multiple slaves for one target
13:11:09 <xerox> What's the idea?
13:11:19 <ndm> and it can pick just one - to spread the load
13:11:52 * Igloo doesn't see it is much easier personally, but I also don't know how much effort you'd need to expend on Windows beyond what you need to get GHC to build in the first place
13:13:34 <eivuokko> Well, quite a lot.
13:25:36 <ndm> email sent off to cvs-ghc
13:28:13 <eivuokko> ndm, Thanks.
13:40:13 <xerox> ?docs Data.List
13:40:14 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
13:45:26 <bringert> Igloo: I'm trying to compile darcs ghc on OS X/i386, following http://hackage.haskell.org/trac/ghc/wiki/X86OSXGhc and I get ghc-6.5: unknown package: regex-compat-0.71 at the first make step
13:45:28 <lambdabot> Title: X86OSXGhc - GHC - Trac
13:45:47 <bringert> xerox: you wrote that, right?
13:47:10 <eivuokko> I thought that was fixed on friday.
13:47:31 <bringert> maybe I need to make clean or something
13:48:08 <mnislaih> bringert: do a darcs-all get and pull
13:48:20 <bringert> mnislaih: did that already
13:49:03 <Igloo> Do you have libraries/regex-compat?
13:49:16 <mnislaih> I didn't do a clean build, so I don't know. Here I built regex-compat, regex-posix and regex-base a bit by hand
13:50:00 <bringert> Igloo: yes
13:50:02 <mnislaih> regex-posix includes an autoconf and a configure
13:51:09 <Igloo> bringert: Does it work without the -j3?
13:51:28 <bringert> trying...
13:52:04 <bringert> nope
13:52:13 * Igloo can't think of anything else - can we see the log?
13:52:19 <eivuokko> After darcs-all's, did you do a new autoreconf?
13:52:36 <bringert> yes
13:52:48 <bringert> pastebin?
13:52:51 <bringert> @where paste
13:52:51 <lambdabot> http://paste.lisp.org/new/haskell
13:55:06 <bringert> hmm, "paste too large"
13:55:16 <bringert> I did see a few failure earlier
13:55:20 <bringert> s
13:55:58 <bringert> the regex-compat build apparentely fails with ghc-6.5: unknown package: regex-posix
13:59:55 <bringert> where does ghc-inplace keep its installed packages?
14:00:08 <urz> I need to convert back and forth between a unix pid and a haskell ProcessHandle
14:00:13 <Igloo> utils/ghc-pkg/ghc-pkg-inplace -l
14:00:14 <urz> is it doable?
14:00:49 <urz> or is there a way to spawn processes and such and get pids instead of ProcessHandles
14:01:33 <bringert> I'll just make clean and hope that it was some weird fluke
14:02:37 <ndm> urz: i tried to do the same for Windows process handles, and i couldn't
14:02:51 <ndm> you mgiht be able to unsafeCoerce# and see if that value happens to be the right one...
14:04:40 <Igloo> urz: You can use stuff in System.Process.Internals, but this is non-portable and liable to break in teh future
14:05:18 <Igloo> unsafeCoerce# probably won't work
14:05:50 <urz> this page mentions a System.Posix.Process module that might be helpful to me, but i can't find it in hoogle: http://www.haskell.org/hawiki/HaskellUnixDaemon
14:05:51 <lambdabot> Title: HaskellUnixDaemon - The Haskell Wiki
14:07:27 <Igloo> Oh, good point, I was only looking in base. System.Posix.Process is in the unix package - ndm, does hoogle only index packages available on Windows?
14:07:33 <ndm> hoogle doesn't index Unix modules
14:07:36 <ndm> Igloo: yep, currently
14:08:04 <ndm> Igloo: am rewriting so you can including the unix/win32 packages properly in your searches
14:08:32 <ndm> although someone else will have to contribute the unix package specs
14:14:46 <urz> System.Posix.Process is not really good for me.  It has forkProcess and executeFile, but executeFile does not return any kind of handle, and i want to execute a process and obtain the pid for it
14:15:45 <norpan> urz: you forkProcess and then executeFile
14:16:07 <norpan> at least that's what you do in posix
14:16:35 <urz> does execv keep the same pid for the spawned process?
14:16:46 <norpan> execv does not spawn a process
14:16:56 <norpan> that's why you fork first
14:17:23 <urz> well whatever it does, it keeps the pid constant?
14:17:26 <norpan> yes
14:17:48 <norpan> and never returns
14:18:24 <norpan> unless there is some error
14:19:26 <norpan> so you do forkProcess (executeFile ...)
14:23:30 <urz> hm
14:23:45 <ihope> Yay for static typing!
14:23:50 <ihope> That is all.
14:24:15 <urz> do i need to search the path myself for executeFile to get the full filename of the command?  And do i have to seperate my arguments into a list or can i just put it all in one simple string?
14:25:15 <norpan> you have to read the docs to see exactly how to invoke it
14:25:42 <eivuokko> System.Directory.findExecutable helps in search if you need to do it.
14:25:54 <urz> the docs are not that detailed
14:26:04 <norpan> then the docs should be improved :)
14:27:21 <norpan> it seems it takes a bool to determine if it should search the path
14:27:30 <norpan> and a list of arguments
14:28:08 <norpan> and an environment
14:30:25 <urz> if i give it a Nothing environment, will it use an empty one or will it copy mine?
14:31:38 <norpan> it vill use execv without 'e'
14:32:38 <norpan> so it will just use the existing env
14:33:17 <urz> hm
14:33:35 <urz> my program is running without error, but nothing is happening
14:33:36 <beelsebob> you need to give it Just [] to get the empty env
14:52:11 <ihope> > (-1) :: Num a => a -> a
14:52:12 <lambdabot>     add (Num (a -> a)) to the expected type of an expression
14:52:12 <lambdabot>    or add ...
14:52:18 <ihope> > (- 1) :: Num a => a -> a
14:52:19 <lambdabot>     add (Num (a -> a)) to the expected type of an expression
14:52:19 <lambdabot>    or add ...
14:52:22 <ihope> Hmm...
14:53:03 <ihope> > 'H' + 'z'
14:53:03 <lambdabot>  add an instance declaration for (Num Char)
14:53:04 <lambdabot>   In the definition of `rxb': ...
14:53:13 <ihope> > 'H' + 'z' :: Num Char => Char
14:53:13 <lambdabot>    Non-type variables in constraint: Num Char
14:53:14 <lambdabot>   (Use -fglasgow-exts to pe...
14:53:19 <ihope> :-)
15:01:24 <bringert> got the build working now. make clean seems to have done the trick
15:01:55 <bringert> thanks Igloo, eivuokko and mnislaih
15:02:31 <mnislaih> good to hear bringert
15:02:36 <Igloo> Cool
15:03:00 <bringert> Igloo: I went with your sed suggestion for he cgi package
15:29:52 <pflanze> Hello
15:30:10 <pflanze> I'm trying to catch exceptions, but this won't work:
15:30:12 <pflanze> > catch (do{ return (head "")} ) (\e -> return 'z' )
15:30:12 <pflanze> > it
15:30:12 <pflanze> *** Exception: Prelude.head: empty list
15:30:14 <lambdabot>  Not in scope: `it'
15:30:14 <lambdabot>  No IO allowed
15:31:55 <pflanze> Why doesn't it return 'z' ?
15:33:12 <AtnNn> maybe you need to use Control.Exception.catch
15:33:34 <stepcut> AtnNn: that does not seem to work either
15:37:01 <AtnNn> you also need to seq it before it exists the catch
15:37:35 <AtnNn> Control.Exception.catch (return $! head "") (const $ return 'z')
15:38:11 <AtnNn> exits*
15:38:45 <int-e> and you need the right catch, hmm.
15:38:48 <int-e> @index catch
15:38:48 <lambdabot> Control.Exception, System.IO.Error, Prelude
15:38:56 <AtnNn> @index fromJust
15:38:57 <lambdabot> Data.Maybe
15:38:57 <stepcut> ah yes,s the imprecise part of imprecise exceptions :)
15:39:01 <int-e> @type Control.Exception.catch
15:39:02 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
15:39:19 <int-e> this one I think
15:40:06 <int-e> @type Prelude.catch
15:40:07 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
15:40:49 <AtnNn> hmm.. is it possile to catch these kinds of exceptions inside ST?
15:40:53 <pflanze> Thanks AtnNn (it's over my head right now, though, but I've taken notes).
15:41:24 <int-e> @hoogle unsafeST
15:41:25 <lambdabot> No matches found
15:41:28 <int-e> @hoogle unsafeIO
15:41:29 <lambdabot> GHC.Conc.unsafeIOToSTM :: IO a -> STM a
15:41:29 <lambdabot> Control.Monad.ST.unsafeIOToST :: IO a -> ST s a
15:42:17 <int-e> maybe you can cheat using unsafeIOToST ... but I'm not completely sure that this is safe.
15:42:58 <stepcut> pflanze: due to laziness, the code you wrote does not required (head "") to be evaluated, so catch will just return the not-yet-evaluated (head ""). But when ghci tries to print the result, it then has to evaluate it. And so the error gets thrown. But, by then, catch is already out of the picture, so it does not get caught
15:43:30 <pflanze> heh. Thanks stepcut
15:45:34 <pflanze> (so catch acts upon the dynamic environment of the evaluation, not the static one. strange, sounds lowlevel)
15:45:56 <stepcut> yeah
15:47:47 <stepcut> if you had code like this:
15:47:49 <stepcut> > map (\d -> 1 `div` d) [1,2,0]
15:47:50 <lambdabot>  Exception: divide by zero
15:47:56 <stepcut> that is an error
15:48:04 <stepcut> but if you do this:
15:48:05 <stepcut> > take 1 $ map (\d -> 1 `div` d) [1,2,0]
15:48:06 <lambdabot>  [1]
15:48:18 <stepcut> it is ok, because the division by zero case never actually gets used
15:48:53 <stepcut> but, in most cases, it is very difficult for the compiler to know that
15:49:26 <stepcut> so, it just waits tell the error actually occurs
15:50:09 <pflanze> It's ok. I'm just amazed. It behaves like delay (or thunks) and with-exception-catcher in Scheme; promises or thunks created inside a dynamic env but evaluated outside loose the dynamic env.
15:50:31 <pflanze> Some people suggested to change that, in Scheme.
15:51:00 <pflanze> But if Haskell doesn't do it that way, why bother? ;)
15:52:28 <stepcut> it would probably be more odd to go back to the original catch block when the error gets raised, because you will have already used the output once
15:54:55 <stepcut> > catch (mapM (\d -> return  (1 `div` d)) [1,2,0]) (\_ -> return [10]) >>= \l -> (print (take 1 l) >> print l)
15:54:55 <lambdabot>  No IO allowed
15:55:04 <stepcut> oops, forgot about no IO :)
15:55:54 <stepcut> in that example, it will have already done the first print, before the exception gets raised in the second print
15:57:47 <stepcut> so, should it go back and redo the first print with [10] instead ? Or, should it print [1] for the first print and [10] for the second print, even though they are both supposedly printing the same l ? Neither of those options seem like good choices
15:58:10 <pflanze> It feels a bit like it's higly sensitive to whether the evaluation is forced or not inside the catch; sometimes (libraries etc.) that might not be easy to know in advance.
15:58:24 <stepcut> right, it is highly sensitive
15:58:36 <stepcut> that is why they are called 'imprecise' exceptions
15:59:07 <pflanze> ah. What are precise exceptions?
16:00:26 * pflanze googles
16:01:04 <stepcut> http://research.microsoft.com/~simonpj/Papers/except.ps.gz
16:02:45 <stepcut> comes from CPU exceptions -- has to do with how precisely you can determine the instruction that raised the exception
16:04:40 * edwardk waves ello
16:06:41 <ivant> is there some configuration file loader/parser library?
16:07:01 <edwardk> hsplugins? =)
16:07:35 <ivant> edwardk, I just did darcs get hs-plugins :-)
16:07:52 <edwardk> heh
16:08:18 <ivant> but writing configuration files in haskell didn't come into my mind
16:08:26 * edwardk nods.
16:08:39 <edwardk> depends on whether or not you need to meet an existing config file spec
16:08:46 <edwardk> but writing them in haskell can be quite clean
16:09:40 <ivant> I don't have a spec, but I envision the benefits from writing configs in haskell
16:09:48 * edwardk nods.
16:09:49 <ivant> great idea
16:09:58 <edwardk> blame/thank dons =)
16:10:17 <ivant> @tell dons thank you for the hs-plugins!
16:10:17 <lambdabot> Consider it noted.
16:15:43 <Korollary> MissingH also has a config parser module iirc
16:16:01 <edwardk> but its not as much fun =)
16:16:44 <Korollary> I havent used it
16:19:12 <Pupeno> I would write configurations as language structures of some kind: In lisp as lists, in Erlang as list/tuples, in Haskell as... I am not sure.
16:19:21 <musasabi> Is system-daemon or hsdaemon or something entirely else a good name for a small package providing System.Daemon which does chroot/setuid/setsid/fork/... ?
16:19:43 <Pupeno> Writing it as source code might be easy, but might lead to having half-a-program in the configuartion file, which might not be desiderable.
16:20:01 <edwardk> the hsdaemon seems kinda redundant
16:20:08 <stepcut> halting problem in your config files ;)
16:20:12 <edwardk> so probably System.Daemon
16:20:21 <edwardk> er system-daemon
16:20:35 <Korollary> just daemon?
16:20:51 <edwardk> or that
16:21:02 <Pupeno> hsdaemon looks good to me.
16:21:09 <Korollary> minor-deity
16:21:16 <ivant> stepcut: lol :-)
16:21:33 <edwardk> well, for a package name i never see hs in the name as making much sense, since cabal implies hs ;)
16:21:37 <stepcut> musasabi: none of those functions seem very daemon specific to me
16:21:51 <Pupeno> by package you mean the name of the tarball ?
16:22:11 <edwardk> or cabal config file/package name
16:22:31 <ivant> @where hsql
16:22:32 <lambdabot> http://htoolkit.sourceforge.net
16:22:36 <edwardk> that you pass to ghc with the -package foo
16:22:39 <Pupeno> stepcut: combined correctly they are.
16:22:40 <ivant> @where hsql-darcs
16:22:41 <lambdabot> I know nothing about hsql-darcs.
16:23:00 <jrmole> if we named our products after what they do with no prefix, we'd be microsoft ;)
16:23:09 <jrmole> besides, it makes searching for a package's website a lot easier
16:23:21 <stepcut> Pupeno: but is he providing those functions? Or just using them ?
16:23:22 <Korollary> iAgree
16:23:29 * edwardk shrugs. i always kinda liked minimalist names.
16:23:52 <edwardk> acronyms and such are funny while the community remains small but don't grow well.
16:23:58 <urz> hi
16:23:58 <Pupeno> stepcut: you'll have to ask him, but I believe he is providing higher level functions that use those functions to build a proper daemon.
16:24:51 <musasabi> stepcut: they are part of a higher level abstraction. 5min to the haddock docs on the web.
16:25:13 <urz> Given a unix process id (System.Posix.Types.ProcessID) i need to determin if there is a running process with that id.  getProcessStatus seems apropriate but it aparently only recognizes 3 statuses: exited, terminated, or stopped.  What if the process is currently running?
16:25:42 <urz> should i just give up on a haskellish way to do it and invoke the shell with the ps command?
16:26:01 <urz> getProcessStatus is aparently a wrapper on the c function waitpid
16:27:15 <jrmole> edwardk, java programs all start with j, and java has a pretty big community
16:27:24 <jrmole> though whether this constitutes growing "well" is debatable
16:27:27 <edwardk> jrmole: and i find it just as annoying there ;)
16:27:33 <jrmole> very true
16:27:44 <stepcut> urz: there is a non-blocking version of getProcessId i think
16:27:48 <edwardk> the acronym space there is so overloaded, you can't find ANYTHING and most good acronyms have two or three things using it ;)
16:28:08 <stepcut> urz: getProcessExitCode
16:28:24 <edwardk> plus they use 4-5 related acronyms at a time for things like their debugger interface or xml, etc.
16:28:53 <stepcut> urz: hrm, I think there may be a better choice, hold on
16:29:12 * edwardk is admittedly boring though.
16:29:22 <edwardk> I used to use all sorts of fancy acronyms and in-jokes for project names
16:29:23 <stepcut> urz: getProcessStatus
16:29:28 <Korollary> group hug
16:29:48 <urz> stepcut, ok, getProcessStatus is back where i started
16:29:51 * tibbe hugs
16:30:01 <urz> I dont know how to use it to determin if a process is running or not
16:30:11 <Korollary> ok whose hand was that?
16:30:14 * edwardk ghci's.
16:30:27 <urz> waitpid apaerntly returns an error ECHILD if the pid doesnt exist
16:31:14 <edwardk> yeah but it blocks waiting if it does no?
16:31:17 <ndm> is there any way i can have a constructor that you can pattern match on, but not create?
16:31:18 <stepcut> urz: one of the arguments is whether to run it in blocking-mode or not. In non-blocking mode, it will return 'Nothing' if the process is still running
16:31:27 <ndm> for example: data Foo = Foo Bool
16:31:29 <edwardk> h
16:31:45 <ndm> I want to be able to do "f (Foo x) = x"
16:31:53 <ndm> but not "f x = Foo x"
16:31:58 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/System-Daemon/doc/html/System-Daemon.html
16:32:05 <edwardk> ndm: don't pass the constructors out of the module
16:32:09 <urz> stepcut: what if the process is fully completed.. i'd think that the exit code doesnt stick around forever and it might not be available in which case i'd expect it to also return Nothing
16:32:22 <ndm> edwardk: but then i can't do "f (Foo x) = x"
16:32:26 <edwardk> ah
16:32:27 <ndm> pattern matching on the constructor
16:32:30 <Korollary> then he cant maych either
16:32:31 <edwardk> then yer screwed =)
16:32:42 <edwardk> hrmm
16:32:52 <edwardk> what if you had a second parameter in the constructor
16:32:59 <edwardk> that you didn't export ITS constructor =)
16:33:10 <stepcut> urz: the exit code will stick around until you call getProcessStatus on it after it has exited -- then it goes away
16:33:16 <Korollary> ndm: maybe export a function and use it as a guard?
16:33:27 <stepcut> urz: if you never check the exit code, then the process shows up in the process table as 'zombie'
16:33:46 <edwardk> i.e. data Managed = Managed ; data Foo = Foo Bool Managed
16:33:50 <ndm> edwardk: thats quite a clever plan
16:33:52 <edwardk> then don't export Managed
16:34:00 <edwardk> and you can pattern match Foo x _
16:34:06 <ndm> of course I can do Foo x y = Foo True y
16:34:19 <ndm> but thats a deliberate get around - i can live with that
16:34:24 <ndm> i just want to not do it by accident
16:34:35 <edwardk> i use a similar trick to close my set of booleans and 2s complement integers you might look at it
16:34:39 <ndm> Korollary: too ugly
16:34:43 <urz> stepcut: Here is the situation.  This program was launched by some other process which long since quit but which saved the pid.  Now i am a new process checking that pid.  Will this still work?
16:34:44 <edwardk> there its a little more robust though
16:34:55 <ndm> link?
16:35:13 <edwardk> http://slipwave.info/jugs/src/Type/
16:35:14 <lambdabot> Title: Index of /jugs/src/Type
16:35:19 <edwardk> look in Boolean.hs for the trivial example
16:35:31 <edwardk> Closed and TCBool and TBool
16:35:52 <edwardk> sign TCSign and TSign use the same trick for a very small set
16:36:21 <stepcut> urz: yes and no. I don't think you will be able to figure out the exit code. But if it is running, getProcessStatus will return 'Nothing', and if it is not running anymore, and has been removed from the process table, getProcessStatus will throw and exception. So you just need catch the exception...
16:36:22 <urz> Process1 lauchnes Process2 and saves process2_pid.  Process3 reads process2_pid and wants to determin if Process2 is still running
16:36:36 <edwardk> http://slipwave.info/jugs/src/Type/Binary/Internals.hs uses it to close the binary numbers with a Closure parameter despite the fact that its unbounded.
16:36:43 <edwardk> that approach may be closer to what you need
16:36:48 <edwardk> TCBinary TBinary, etc.
16:36:50 <ndm> edwardk: thanks, will try that out in the next tweaks i do
16:37:18 <edwardk> no problem
16:37:44 <urz> hm
16:37:50 <urz> the docs dont mention any exceptions
16:37:54 <edwardk> now i just need to find someone bored enough to write a 2s complement divmod in the type level ;)
16:38:11 <edwardk> or get off my ass and do it myself
16:38:46 <stepcut> urz: no, the docs are a bit weak. If you look at the code, though, you will see that it calls 'throwErrnoIfMinus1Retry "getProcessStatus" (c_waitpid pid wstatp (waitOptions block stopped))'
16:39:02 <stepcut> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C-Error.html#v%3AthrowErrnoIfMinus1Retry
16:40:02 <stepcut> urz: so you need to catch the error and then check if errno is eCHILD
16:40:48 <edwardk> gah, shoot me, starting week after next i have to teach a couple of intro programming classes ;)
16:40:50 <stepcut> urz: although, the waitpid man page makes me wonder if you can call waitpid on a process that is not your child...
16:41:06 <ndm> edwardk: in what?
16:41:08 <stepcut> urz: just see if /proc/<pid> exists ;)
16:41:10 <edwardk> java =/
16:41:26 <ndm> i had to do some teaching of intro programming in Ada
16:41:42 <edwardk> i used to teach cobol and fortran way back in the day
16:42:04 <ndm> that wins :)
16:42:05 <urz> thanks for your help, stepcut
16:42:07 <edwardk> but i am just having a hard time getting motivated this year =)
16:42:21 <urz> heh
16:42:39 <urz> should i do /proc/<pid> instead of this stuff?
16:43:01 <urz> or use the shell and ask the ps command
16:43:07 <edwardk> two 1st semester classes and a 2nd semester class in a java sequence. i really think java should be taught via servlets though.
16:43:43 <stepcut> urz: I would get the source to 'ps' and see what it does
16:43:45 <edwardk> then you can gradually introduce functions and classes without loading students down with boilerplate and chained constructors right off the bat
16:44:00 <stepcut> urz: I think ps uses /proc since I have gotten errors when proc is missing ;)
16:44:27 <urz> heh
16:44:27 <edwardk> urz: if you know you're on linux /proc/<pid> is there and fast =)
16:44:56 <stepcut> edwardk: is *usually* there -- might be inside a chroot or something where it is not mounted ;)
16:44:57 <ndm> the first thing to teach anyone in any programming language is basic string manip stuff, since you can visualise the result
16:45:02 <ndm> Ada sucks for that entirely
16:45:16 <edwardk> stepcut: well, if you're chrooted you typically know it and know why
16:45:29 <edwardk> ndm: yeah
16:46:32 <urz> is there a quick command to verify if a file/directory exists?
16:46:34 <stepcut> edwardk: ?? I run processes in chroot's all the time, and I am sure the original authors have no idea :)
16:47:07 <edwardk> stepcut: well, when i do its usually for an x86-64/32 bit linux embedding
16:47:13 <stepcut> urz: getFileStatus
16:47:17 <edwardk> stepcut: and there i always map proc again
16:47:17 <urz> thanks
16:47:37 <stepcut> edwardk: yeah, because all the other authors assume /proc will be there ;)
16:48:30 <edwardk> yep =) so i figure i'm in good company ;)
16:48:47 <stepcut> urz: stat'ing /proc/pid may in fact be the only way to do what you want
16:49:01 <int-e> @index doesFileExist
16:49:01 <lambdabot> System.Directory, Distribution.Compat.Directory
16:50:08 <stepcut> int-e: ah yes, though in this case he probably wants doesDirectoryExist
16:50:13 <urz> stepcut: fileExist is listed in the docs too
16:50:14 <edwardk> yeah
16:50:25 <urz> oh
16:51:15 <stepcut> urz: also, process ids wrap around after 32K (or maybe 65K), so it is possible the process id has been recycled and is in used by something else
16:51:32 <edwardk> takes a pretty long time
16:51:43 <urz> hm
16:51:44 <stepcut> no way, I have had that happen in a single day
16:51:59 <urz> not sure what to do about that
16:52:16 <stepcut> if you do lots of compile/debug cycles on the machine
16:52:17 <edwardk> well you can always look inside the proc dir at the cmdline ;)
16:52:29 <edwardk> yeah was going to say its really dependent on system load
16:53:17 <stepcut> hrm, my freebsd system is upto 78513 -- I wonder how many bits they use for the pid
16:53:32 <edwardk> probably just went 32 bit
16:53:51 <stepcut> could be, I only have a 64 day uptime and I don't use the machine much
16:53:55 <pflanze> edwardk: some people say the qmail Maildir format is bad because it's creating id's with the time and the pid - they fear wrapping pid's in 1 second..
16:54:17 <edwardk> pflanze: i welcome them to try =)
16:54:33 <edwardk> just please, not on any production server of mine ;)
16:54:56 <pflanze> edwardk: well my system can fork about 10k processes per second. So it's not far away actually.
16:55:01 <stepcut> I recently debugged a problem where a script would do a check-out, modify the code, and check it in. Only it failed to detect any changes because it took less than a second ;)
16:55:38 <stepcut> not quite the same though
16:55:41 <Pupeno> I think you can have wrapping PIDs very fast in Linux by using a desktop with lot's of programs like KDE, and that's without having one program spawning lots of dieing process (the load won't get really noticed, the pid change will).
16:55:51 <Pupeno> On OpenBSD the PIDs are random :)
16:56:04 <pflanze> stepcut: linux will allocate more than 32K or even 64K numbers if that many pids are actually in use. It just doesn't make use of pids over 2^15 unless really necessary, iirc.
16:56:31 <edwardk> ah
16:56:46 <edwardk> tradition, mnemonic usage and all that
16:57:32 <stepcut> I wonder how else you could tell if a process has finished besides checking the pid
16:57:58 <Korollary> Chuck Norris just knows.
16:58:55 <edwardk> and Bruce Schneier can kill them just by looking at them. ;)
16:59:00 <pflanze> stepcut: one can open the lock file and flock it; if subsequent starts can't get the flock, it's still running.
16:59:37 <pflanze> (that won't work across nfs, though)
17:00:02 <edwardk> urz: whats the usage for all of this anyways?
17:04:53 <edwardk> whee
17:05:10 <gmak> shit! amazing parts/joins :P
17:05:12 <gmak> hey edwardk
17:05:22 <edwardk> heya
17:05:24 <gmak> hmm i have to disable this...
17:05:27 <gmak> wb ndm
17:05:39 <lambdabot> gmak: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:06:40 <gmak> 2 messages? saying ho0w to use the tell command
17:06:42 <gmak> what is this
17:06:42 <ndm> hi gmak
17:06:47 <gmak> hi ndm
17:06:53 <ndm> type what is says
17:06:54 <gmak> lambdabot said about messages
17:07:11 <gmak>  SamB said 6 hours, 53 minutes and 34 seconds ago: /msg lambdabot @help tell <--- ?
17:07:14 <ndm> just type: /msg lambdabot @messages
17:07:22 <gmak> i did, this is what comes up
17:07:26 <ndm> he was telling you how to use lambdabot's tell
17:07:31 <gmak> ah
17:07:43 <gmak> user SamB ?
17:08:10 <ndm> yep
17:08:32 <gmak> boh whatever
17:08:37 <gmak> my box is back online now
17:08:38 <musasabi> Is there a way to tell GHC "please ignore all environment variables" ?
17:09:08 <gmak> hmm it is about time I went to sleep though
17:09:20 <gmak> guess it will be tomorrow haskellers! so long!
17:13:21 <Pupeno> how would you call a function that turns a string like "1day", "2weeks", "100megabytes" into a propres structure representing that information ?
17:13:54 <ndm> > break isDigit "100megabytes"
17:13:55 <lambdabot>  ("","100megabytes")
17:14:01 <ndm> > span isDigit "100megabytes"
17:14:02 <lambdabot>  ("100","megabytes")
17:14:09 <ndm> Pupeno: like that^^^
17:14:18 <ndm> along with a read, and probably a lookup for the name
17:15:05 <Pupeno> ndm: the proper structures will be reduced to seconds and bytes, and I'd like to give a name to the function.
17:15:27 <ndm> give it a name
17:16:13 <urz> hm
17:16:17 <ndm> and store a list of [("days",(24*60*60, Seconds), ("megabytes",(1024*1024,Bytes)]
17:16:20 <urz> i want to redirect my stdout to /dev/null
17:16:42 <ndm> then your function split up the string, reads the first half, does lookup to get the mode of the second half
17:16:45 <ndm> and puts it all back together
17:16:47 <Pupeno> ndm: that is what I was asking for, what name would you give it ? stringsToUnits ? stringToMessurements ?
17:17:03 <ndm> Pupeno: names is the bit i am hopeless at :)
17:17:11 <ndm> if you made a data structure
17:17:19 <ndm> data Unit = Second Integer | Byte Integer
17:17:26 <ndm> then you could do it as a Read instance
17:17:35 <ndm> then you don't have to come up with a name :)
17:17:41 <Pupeno> indeed!
17:18:08 <jrmole> you could do the lookup as a pattern-match "function" instead of a list like that
17:18:39 <ndm> jrmole: but then the size of the code is the size of the data - and ifyou change the format you have to change everything
17:19:13 <jrmole> and you'd get more type safety if you split the units into two types (and you can use newtype for efficiency)
17:19:35 <ndm> nah, not really more type safety
17:19:55 <ndm> oh, unless you do data Second = Second Integer, data Byte = Byte Integer
17:20:01 <ndm> then data Unit = Second | Byte
17:20:08 <ndm> yeah, that buys you a bit
17:20:09 <jrmole> or just use Either Second Byte
17:20:12 <jrmole> more descriptive
17:20:27 <jrmole> you can also use newtype instead of data for Second / Byte, which will get rid of the boxing / unboxing overhead
17:20:33 <ndm> but then why is Second Left and Byte Right ?
17:20:40 <ndm> thats the bit i dislike about Either
17:21:06 <jrmole> fair enough
17:21:37 <jrmole> this is also moot if you always know whether a given string is a time or a byte count
17:28:44 <pflanze> Is there some haskell naming style guide?
17:29:12 <pflanze> fooToBar or bar_of_foo or foo_as_bar or what?..
17:29:28 <Cale> pflanze: The convention is generally the first of those
17:29:34 <Cale> er
17:29:55 <Cale> Though I don't really get the distinction with the second two.
17:30:32 <Cale> there's lots of functions like toRational and realToFrac, if you're talking about conversions.
17:30:53 <pflanze> csvfileToTextmatrix
17:30:56 <pflanze> for example
17:31:02 <Cale> sure
17:31:05 <pflanze> for parsing it.
17:31:23 <pflanze> ok
17:31:41 <Cale> Or you could do something like a typeclass and remove one of the conversion types from the name
17:32:01 <Cale> (or both, if multiparameter, but that's not always the most convenient thing)
17:32:09 <Cale> like fromCSV
17:32:30 <Cale> as a generic "interpret this CSV as something" type function
17:33:28 <pflanze> yeah. btw can one parameterize on the result type? (not that I would expect that to be the most brilliant idea)
17:33:32 <urz> hm
17:33:35 <Cale> Yeah
17:33:48 <Cale> (In fact, that's sort of what I'm suggesting)
17:33:51 <urz> I am having trouble figuring out how to redirect stdout
17:34:26 <urz> i dont mind a linux-specific solution
17:34:28 <Cale> urz: In what context?
17:34:41 <Cale> The shell?
17:35:10 <urz> well, i am launching another ap with System.Posix.Process.executeFile and i want to redirect stdout for it before hand
17:35:10 <musasabi> grah. Seems that there is no pretty solution to writing a setuid program with GHC :-(
17:35:17 <ndm> pflanze: see read for an example of it - read "1" + 1, read "'c'" : "list"
17:35:24 <xian> does haskell has a sleep function for unix? (hoogling only resulted in System.Win32.Process.sleep)
17:35:39 <xian> s/has/have/
17:35:40 <ndm> @hoogle sleep
17:35:40 <lambdabot> System.Win32.Process.sleep :: DWORD -> IO ()
17:35:43 <ndm> @hoogle wait
17:35:43 <lambdabot> System.Process.waitForProcess :: ProcessHandle -> IO ExitCode
17:35:44 <lambdabot> Control.Concurrent.QSem.waitQSem :: QSem -> IO ()
17:35:44 <lambdabot> Control.Concurrent.QSemN.waitQSemN :: QSemN -> Int -> IO ()
17:35:50 <musasabi> Impossible to ignore RTS-flags - and thus need to rewrite main in C...
17:35:56 <ndm> @hoogle+
17:35:56 <lambdabot> System.Win32.NLS.sUBLANG_ARABIC_KUWAIT :: SubLANGID
17:35:57 <lambdabot> IO.hWaitForInput :: Handle -> Int -> IO Bool
17:35:57 <lambdabot> Control.Concurrent.threadWaitRead :: Fd -> IO ()
17:35:58 <urz> hoogle doesn't do unix stuff
17:36:03 <ndm> @hoogle delay
17:36:04 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
17:36:04 <lambdabot> Network.Socket.NoDelay :: SocketOption
17:36:04 <lambdabot> System.Win32.File.mOVEFILE_DELAY_UNTIL_REBOOT :: MoveFileFlag
17:36:11 <ndm> xian: threadDelay
17:36:20 <ndm> that is essentially sleep
17:36:23 <ndm> urz: yet :)
17:36:28 <Cale> Yeah, in Control.Concurrent
17:36:30 <xian> cool, thank you :)
17:36:35 <Cale> I was about to suggest it :)
17:36:48 <ndm> delay/wait/sleep
17:36:56 <ndm> some words are just too overloaded
17:37:03 <urz> any ideas on stdout redirection?
17:37:16 <Cale> urz: Give me more information about what you're trying to do
17:37:22 <ndm> is that even possible inside a program
17:37:28 <ndm> its just a handle at that point
17:37:33 <Cale> urz: redirection is up to the shell
17:37:34 <ndm> the caller controls where the handle goes
17:37:37 <Cale> Right
17:37:44 <urz> Cale: i am launching a foreign ap that is a bit noisy and i want to redirect it's output to /dev/null
17:37:52 <musasabi> just create a pipe and put that into stdout...
17:38:01 <Cale> How are you running the process?
17:38:15 <urz> executeFile
17:38:18 <Cale> ah
17:38:44 <urz> i use forkProcess and executeFile because i want to get and save the pid
17:38:45 <Cale> Look at the stuff in System.Process
17:39:10 <urz> for i/o redirection?
17:39:31 <Cale> Well, the functions there will give you the option of specifying handles for things
17:39:58 <urz> i dont want to switch away from System.Posix
17:40:02 <Cale> @hoogle executeFile
17:40:03 <lambdabot> No matches found
17:40:07 <Cale> Where is that?
17:40:15 <urz> System.Posix.Process.executeFile
17:40:19 <Cale> ah
17:40:19 <urz> it's a unix thing
17:40:23 <urz> hoogle doesnt know the unix stuff
17:40:28 <Cale> right
17:40:53 <urz> it is a wrapper on execv*
17:41:00 <Cale> I normally try not to use OS-specific stuff
17:41:40 <musasabi> urz: http://www.cs.helsinki.fi/u/ekarttun/util/AFilter/afilter-0.3.tar.gz has examples on how to do things like that iirc.
17:41:57 <Cale> executeFile doesn't give you handles to the process' stdout/stderr, so it won't be useful there.
17:42:10 <beelsebob> is there a channel for darcs use?
17:42:20 <musasabi> #darcs
17:42:27 <Cale> unless the posix lib has some other way to capture those
17:42:48 <ndm> Beelsebob, i never got a response on that channel
17:43:13 <pflanze> I've got a problem with "Couldn't match `[[String]]' against `IO [[[Char]]]'", I guess it's only the IO type which I'm missing. But how can I map over a IO matrix being returned by a Parsec parser?
17:43:13 <Cale> Given that you're simply throwing the output away, you could just create a shell script wrapper around your program and execute that instead.
17:43:18 <Pupeno> newbie question: does Haskell have symbols ala Lisp/Erlang ?
17:43:30 <Cale> Pupeno: no
17:43:38 <Pupeno> oh :(
17:43:40 <Cale> Pupeno: though you can create custom datatypes
17:43:56 <Cale> Pupeno: with arbitrary symbolic values in them
17:44:00 <beelsebob> ndm: hmm, yes, looks that way
17:44:04 <Pupeno> I imagine that suplants it to some extend.
17:44:09 <beelsebob> you seen what I posted?
17:44:29 <Cale> yeah, for the most part. It's also usually a little safer, but a bit less flexible, I'll admit.
17:44:42 <Cale> pflanze: hmm
17:44:56 <Cale> pflanze: fmap ?
17:44:58 <urz> Cale: executeFile doesnt make a new process, it replaces the current one.  If only i could redirect the current processes stdout before i call executeFile everything would be great
17:45:04 <ndm> nope, but repaste it and i'm  sure someone will answer it
17:45:09 <Cale> urz: ah
17:45:30 * Pupeno remembers not having a need for symbols when codding a DNS server in Haskell... but after my recent coding in Python I am hungry for symbols, strings suck as poor-man-symbols.
17:45:42 <musasabi> urz: you can.
17:46:03 <urz> musasabi: how?  interface with c?
17:46:05 <Cale> Pupeno: well, depends what you're after
17:46:23 <pflanze> Cale: thanks, that fixes the IO thing. (Still some "Couldn't match `Char' against `[Char]'" but I'll try to find out that myself)
17:46:40 <musasabi> urz: just 1) create a pipe to /dev/null, 2) close stdout, 3) dup the pipe input-side.
17:46:53 <Cale> Pupeno: Usually the user interface for a Haskell program is expected to be a little farther from the core than with a scheme program, I think
17:47:01 <Pupeno> Cale: I end up using a lot of strings as keys in dictionaries or as a set of different options passed to a function, like open("file.txt", mode="write").
17:47:16 <Pupeno> Cale: but I don't yet have had the need in Haskell, I was just wondering.
17:47:31 <Cale> Pupeno: Well, in Haskell, you have a value called WriteMode
17:47:35 <Cale> for instance :)
17:47:59 <Cale> data IOMode
17:47:59 <Cale> = ReadMode
17:47:59 <Cale> | WriteMode
17:47:59 <Cale> | AppendMode
17:47:59 <Cale> | ReadWriteMode
17:48:22 <Cale> There's no potential for passing something inappropriate to openFile
17:48:58 <Pupeno> Cale: right... that might be even better... safer at least as you have said.
17:49:18 <jrmole> what are symbols, briefly?
17:49:43 <Cale> jrmole: Basically, they're unquoted strings which are treated as values in the language
17:49:59 <urz> musasabi: can you give me some hints on where to find the documentation for creating a pipe and duping a handle
17:50:37 <Cale> jrmole: Usually they can at least be tested for equality
17:50:53 <Pupeno> jrmole: symbols are atoms (they are basic units in the language, like numbers and characters, not like strings or lists, which are collections) and they should be so a symbol evaluates to itself. That is a symbol is equal to the same symbol and nothing else.
17:51:37 <Pupeno> jrmole: in most implementations, comparing symbols is O(1) instead of the O(n) of strings (of size n).
17:52:12 <Pupeno> maybe there's a table lookup for symbols or something like, I am not sure.
17:53:39 <Cale> Yeah, they're generally compiled to integers.
17:54:06 <Cale> Or small datastructures, anyway
17:54:52 <musasabi> urz: do f <- openFd "/dev/null" WriteOnly Nothing defaultFileFlags; dupTo f stdOutput; closeFd f
17:57:01 <urz> where do i get openFd ?
17:57:28 <musasabi> under System.Posix.
17:57:37 <pflanze> (Pupeno: the reason that symbols are firstclass values in lisp is that program code is/are firstclass values.)
17:58:25 <Pupeno> and names (of variables and functions) are symbols, right ?
17:58:58 <pflanze> yes.. in sexpr's that is.
17:59:04 <jrmole> you could write an easy preprocessor to give you symbols in haskell
17:59:57 <Pupeno> jrmole: would that need Template Haskell ? (I am not particulary interested on this, but I may be on other preprocesors).
18:00:07 <jrmole> replace any occurance of 'foo with Symb_foo, then add a declaration data Symbol = Symb_foo | ...
18:00:33 <jrmole> i don't know TH but this is much simpler than what people usually use TH for
18:00:39 <jrmole> i don't know if it can do this or not
18:00:46 <Pupeno> oh, ok.
18:01:01 <Pupeno> I'll look into it when I am yet again more used to Haskell.
18:01:02 <jrmole> you have problems passing symbols across modules this way
18:01:17 <jrmole> but you probably shouldn't do that anyway
18:01:54 <jrmole> is there some way to implement symbols with O(1) comparison that allows incremental compilation?
18:02:53 <musasabi> sure
18:03:03 <musasabi> one can just leave things to the linker
18:03:47 <jrmole> if my compiler decides that 'foo translates to 1, and yours decides that 'bar translates to 1, how can we link those two object files?
18:04:30 <pflanze> the same way every other function is handled, probably?
18:04:39 <urz> musasabi: thanks a bunch
18:04:44 <jrmole> problem is, if i have a function named foo and you have one named foo, that's an error
18:04:58 <jrmole> but if i have a symbol named foo and you have a symbol named foo, they're supposed to be the same value
18:05:30 <pflanze> when would that be the case?
18:05:51 <jrmole> when you're passing symbols between code in different object files?
18:06:11 <musasabi> jrmole: just prefix it internally by the compiler as __package__module__foo ?
18:06:12 <pflanze> if you're after runtime creatable symbols, you'll need some runtime datastructure anyway, probably a hashtable.
18:07:09 <jrmole> well, i'm saying you have to know the set of possible symbols at compile time to get O(1) comparison
18:07:16 <jrmole> whereas musasabi is saying you can do it at linktime somehow
18:07:18 <pflanze> Or how would you recognize you're talking about the same symbol without either comparing it's representation, or using a common definition?
18:07:21 <jrmole> runtime is a whole different issue
18:09:02 <Pseudonym> Some operating environments provide APIs for this.  They're usually called "atoms".
18:09:07 <Pseudonym> Win32 and X11 both provide them.
18:09:22 <Pseudonym> But they depend on a common server.
18:09:33 <jrmole> yeah
18:11:02 <jrmole> the cheap way to get O(1) symbols would just be to compile the symbol to a 32-bit hash of its name
18:11:05 <jrmole> and hope there's no collision
18:11:32 <Pseudonym> The problem with hashing is that it really has to be a very good hash function.
18:11:39 <jrmole> woah, people use IPv6? (hi kisu)
18:11:42 <jrmole> yes
18:11:51 <Pseudonym> As all compiler writers know, people tend to use variable names like x1, x2, y1, y2 etc.
18:11:58 <Pseudonym> Simple hash functions fail quickly.
18:12:09 <kisu> hi jrmole
18:12:29 <Pseudonym> And for an O(2^n) hash space, even if it's a good one, you expect a collision after O(2^(n/2)) values.
18:12:30 <jrmole> so the idea of an atom server is that you give it a string, and it spits back an int or whatever that's uniquely associated with that string?
18:12:37 <Pseudonym> right.
18:12:42 <Pseudonym> @foldoc atom
18:12:44 <lambdabot> No match for "atom".
18:12:47 <Pseudonym> Hmm.
18:13:50 <jrmole> you could make such a thing part of the GHC runtime, i guess
18:14:18 <Pseudonym> Hell, you can implement it.
18:14:33 <jrmole> and if you're linking with ghc as well, you can cheat and factor it out once all the object files are together
18:14:35 <Pseudonym> internAtom :: String -> IO Atom
18:14:44 <jrmole> but that requires some heavy magic
18:14:45 <Pseudonym> So long as Atom supports Eq.
18:14:53 <Pseudonym> Not as much as you'd think.
18:15:01 <Pseudonym> One unsafePerformIO will do it.
18:15:15 <jrmole> i meant for the link-time trick
18:15:50 <jrmole> you'd need to tag the parts of the object files that make calls to the atom server, and reprocess them to remove those once you know what all the atoms are
18:17:20 <jrmole> anyway, bbl
18:21:51 <dons> ?users
18:21:52 <lambdabot> Maximum users seen in #haskell: 235, currently: 189 (80.4%)
18:23:21 <lennart> yeah, but how many are idle?
18:23:38 <SamB> I am!
18:23:51 * Pseudonym is idol
18:24:46 <Korollary> I am idle beyond all recognition
18:26:02 * mrevelle is idle
18:26:50 * lennart is idle and lazy
18:33:40 <lennart> does anyone of a presburger decision procedure written in haskell?
18:36:20 <dons> I suppose @users could even filter out people who've not said anything in the last day or two
18:36:21 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
18:36:25 <dons> that would be interesting
18:36:53 <SamB> it should mention all users, but then mention the number of "active" users...
18:37:02 <dons> yeah
18:37:15 <SamB> and whethor or not it has been down in the period it uses to figure out who is "active"
18:37:18 <dons> now, I think we can work that out pretty easily
18:37:21 <lennart> I would even go so far as to say that if you've been quiet for 2 hours you're idle :)
18:37:28 <dons> @seen
18:37:29 <lambdabot> Lately, I have seen dons, korollary, lennart, mrevelle, pseudonym and samb.
18:37:33 <dons> that's the last 5 mins
18:37:44 <dons> so I'll just tweak that code for @users
18:40:26 <pflanze> Is there a way to ease migration from functional code to IO code? fmap is a good start, but I have to replace all mapping functions with IO ones..
18:40:48 <Pseudonym> Why do you want to migrate all of it?
18:41:04 <pflanze> Because the input is from a file. Parsec returns IO stuff..
18:41:26 <lennart> so?
18:41:27 <Pseudonym> Surely you only need to convert those points where you need it.
18:41:28 <pflanze> Previously I had tested with literal datastructures.
18:41:35 <Pseudonym> let expressions work just fine in monads.
18:41:51 <pflanze> ah. let. /me goes off trying
18:42:20 <dylan> So, is it very insane for me to ponder writing an I/O intensive server in haskell, as a second 'real' haskell program? XD
18:42:50 <Pseudonym> It's more sane to attempt a tricky job in Haskell than in many languages.
18:43:22 <dylan> It's possibly useful that I've implemented this server in perl, and python, before...
18:43:22 <lennart> I'd give it a try
18:43:25 <Pseudonym> Lambdabot was my first attempt at using multi-threadedness in Haskell.
18:43:28 <dons> dylan: seems highly reasonable
18:43:34 <Pseudonym> Not that it was very sophisticated at the time.
18:43:34 <dylan> both became unimaginably horrible.
18:43:54 <Pseudonym> Either you used the wrong languages, or you write horrible code.
18:44:01 <Pseudonym> Time will tell which.
18:44:13 <dons> you migth want to look at HAppS or some of the other IO-heavy ByteString stuff.
18:44:13 <dylan> well, it's probably my own metric of horrible.
18:44:28 <newsham> hws? :)
18:44:33 <Pseudonym> It depends what kind of IO you're doing.
18:44:58 <Pseudonym> I know that a couple of people are working on subsets of ASN.1.
18:45:08 <newsham> why asn.1?
18:45:11 <Pseudonym> Having that in a library cleans up certain kinds of server.
18:45:20 <Pseudonym> Because some protocols are defined in terms of ASN.1.
18:45:38 <newsham> ahh, they're implementing a particular protocol
18:45:44 <Pseudonym> If you're doing X.500, LDAP, Z39.50, SNMP etc etc...
18:45:56 <newsham> h323, kerberos
18:46:07 <Pseudonym> Nobody ever got fired for building a protocol on top of ASN.1.
18:46:20 <Pseudonym> I'm sure some did for using sunrpc, though.
18:46:23 <newsham> yah, cause if i saw it on their resume i wouldnt hire em ;-)
18:46:40 * Pseudonym shrugs
18:47:01 <Pseudonym> There's actually nothing wrong with ASN.1 except that it's bloated and looks ugly.
18:47:07 <dylan> well, it's a basically a chat server, line-based. XD
18:47:11 <newsham> and overly complex.
18:47:23 <Pseudonym> The former is fixed by the fact that all published protocols use subsets.
18:47:27 <newsham> but at least it has a formal spec
18:47:31 <Pseudonym> Right.
18:48:09 <newsham> if "nothing wrong with asn.1" then there wouldnt have been so many kerberos, snmp and ldap bugs in the protocol parsers
18:48:57 <Pseudonym> Sounds like an inadqeuate test suite to me.
18:49:12 <dylan> actually, the root question would be: "would an IRC-like server in haskell be insane".
18:49:37 <urz>  Prelude.(!!): index too large
18:49:45 <urz> is there a way to handle that like an exception?
18:49:47 <newsham> definitely..  but thast reality.  reality #2 is that encodings such as BER/DER are easy to make mistakes in
18:49:53 <dons> an irc client isn't too insane, so a server might be reasonable
18:50:06 <newsham> you can make encodings that are easier to get right.
18:50:12 <dons> urz: you're stepping past the end of a list, you sure you want to catch that?
18:50:13 <dylan> it helps that the protocol is wholey defined by me, so. :)
18:50:41 <urz> dons, well i could calculate the length of the list first and do some conditioning
18:50:52 <zeeeee> it seems FiniteMaps can act as hash tables/dictionaries, but is there a standard hash table implementation of the more "familiar" variety that costs an amortized O(1)?
18:50:55 <dons> dylan: i'd say dive in an do it. you might want to use the fast network code based over bytestrings. you could ask musasabi for hints
18:51:05 <urz> but i conceived of doing that test as an exception try/catch type of thing
18:51:06 <lennart> urz: you should not index outside the list :)
18:51:21 <lennart> urz: that's not the Haskell way
18:51:25 <urz> ok
18:51:39 <dylan> dons: The reason I even thought of this was the major abuse of mutable state in twisted (python async networking library)
18:52:08 <lennart> urz: you might want to consider Data.IntMap
18:52:13 <newsham> example of what i mean is udp.  the udp length field counts the header bytes, so the payload length is udp_length - sizeof header.  which leads to an underflow if there is not a full header's worth of data..  if the protocol was defined to have a payload length that didnt include the header length, that mistake would not be there to be made.
18:52:17 <dylan> things like self.parent.talker = self...
18:52:27 <newsham> BER has lots of places for mistakes to be made.
18:52:53 <newsham> (err rather, underflow if the length field is smaller than a full header)
18:57:00 <dons> ?quit new code
18:57:43 <dons> ?version
18:58:08 <lambdabot> lambdabot 4p93, GHC 6.5 (OpenBSD i386 )
18:58:10 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:58:17 <dons> ?users
18:58:22 <lambdabot> Maximum users seen in #haskell: 235, currently: 188 (80.0%), active: 1 (0.4%)
18:58:30 <lennart> hehe
18:58:35 <dons> ?users
18:58:36 <lambdabot> Maximum users seen in #haskell: 235, currently: 188 (80.0%), active: 2 (0.9%)
18:58:53 <dons> its a 4 hour limit
18:58:53 <lennart> we're so inactive!
18:59:00 <lennart> sounds good
18:59:30 <lennart> lambdabot is really very cool
18:59:36 <pflanze> Why does ghci suppress printing of IO return types?
19:00:13 <dons> that was a bug in 6.4.x (or feature). It works now:
19:00:15 <dons> Prelude> return 'x'
19:00:15 <dons> 'x'
19:00:21 <dons> pflanze: is that what you meant?
19:00:33 <pflanze> yes. I see.
19:00:50 * pflanze is running 6.2.2 though
19:01:08 <dons> ah right. the solution is then : myCode >>= print
19:01:10 <pflanze> entering  it  will show it, luckily.
19:01:34 <dons> ?users
19:01:35 <lambdabot> Maximum users seen in #haskell: 235, currently: 188 (80.0%), active: 3 (1.3%)
19:02:04 <lennart> is it keeping track of maximum active too?
19:02:12 <dons> nope
19:02:20 <dons> it probably should
19:02:32 <lennart> it could be interesting
19:02:58 <dons> ?users #perl6
19:02:59 <lambdabot> Maximum users seen in #perl6: 148, currently: 126 (85.1%), active: 3 (2.0%)
19:03:12 <dons> ?users #darcs
19:03:13 <lambdabot> Maximum users seen in #darcs: 43, currently: 32 (74.4%), active: 3 (7.0%)
19:03:25 <dons> hmm
19:03:33 <dons> ?users #haskell-overflow
19:03:34 <lambdabot> Maximum users seen in #haskell-overflow: 19, currently: 13 (68.4%), active: 3 (15.8%)
19:03:50 <dons> ah, the active number isn't checking the channel
19:04:39 <dons> yeah, I forgot to filter out other chans
19:05:17 <ndm> how does it do maximum users seen in other channels?
19:05:30 <dons> it only logs channels its in
19:05:44 <dons> (its in #perl6 and #darcs too :)
19:05:49 <dons> @seen lambdabot
19:05:49 <ndm> ah
19:05:50 <lambdabot> Yes, I'm here. I'm in #ScannedInAvian, #perl6, #oasis, #darcs, #gentoo-haskell, #haskell_ru, #haskell.es, #haskell.se, #haskell.it, #haskell-overflow, #haskell-blah and #haskell
19:06:08 <ndm> so why can't ?users randomchannel go off and see that channel :)
19:06:19 <ndm> ?users perl6
19:06:20 <lambdabot> Maximum users seen in perl6: 1, currently: 0 (0.0%), active: 4 (400.0%)
19:06:24 <ndm> ?users vb
19:06:24 <lambdabot> Maximum users seen in vb: 1, currently: 0 (0.0%), active: 4 (400.0%)
19:06:31 <Korollary> lol
19:06:44 <Cale> ?users #perl6
19:06:45 <lambdabot> Maximum users seen in #perl6: 148, currently: 125 (84.5%), active: 6 (4.1%)
19:06:48 <dons> oh, maybe it doesn't check invalid chans very well
19:07:02 <ndm> #perl6 should be equal to perl6, surely
19:07:17 <Cale> Where is it getting that 4?
19:07:33 <dons> that's the active count in this chan :)
19:07:35 <dons> bug
19:08:01 <ndm> anyway, i should sleep
19:08:20 <ndm> bye
19:12:22 <dons> ?quit try again
19:13:06 <dons> ?bot
19:13:32 <lambdabot> :)
19:13:48 <dons> ?users
19:13:48 <lambdabot> Maximum users seen in #haskell: 235, currently: 186 (79.1%), active: 1 (0.4%)
19:14:00 <dons> ?users #haskell-overflow
19:14:00 <lambdabot> Maximum users seen in #haskell-overflow: 19, currently: 14 (73.7%), active: 1 (5.3%)
19:14:07 <Pseudonym> lambdabot does not count herself.
19:14:19 <dons> grr, still wrong. hmm.
19:14:28 <dons> oh maybe not
19:14:34 <dons> ?users #darcs
19:14:35 <lambdabot> Maximum users seen in #darcs: 43, currently: 32 (74.4%), active: 0 (0.0%)
19:14:38 <dons> ah good
19:14:55 <dons> so if your'e in any channel, then you're considered active in all those you're in
19:15:26 <dons> Pseudonym, yeah, she's weird like that
19:15:33 <dons> she doesn't log herself either
19:15:45 <dons> quirky
19:16:11 <Pseudonym> OK, debian question.
19:16:21 <Pseudonym> I seem to have cruft from ghc 6.0.1 present.
19:16:30 <Pseudonym> Though the package is not installed.
19:16:37 <Pseudonym> e.g. /usr/lib/ghc-6.0.1 is present
19:16:49 <Pseudonym> And ghc is pointing to the old version, not the new one.
19:17:00 <Pseudonym> What's the officially sanctioned way of changing an /etc/alternative?
19:21:47 <Pseudonym> Ah, got it.
19:24:53 <Daniel21> http://www.DJDada.dl.am - HipHop & RnB MusicVidz and MusicTracks to Download!!!
19:27:48 <lennart> in haskell?
19:30:59 <Pseudonym> DJ Haskell.  Word!
19:31:33 <pflanze> How can it be I suddenly do not get any output anymore from some IO monad stuff using putStr and print. Do I need to flush stdout?
19:32:12 <pflanze> putStr alone in the repl still works as usual
19:34:36 <Pseudonym> stdout should be auto-flushing.
19:34:46 <Pseudonym> Did you check putStrLn?
19:34:58 <Pseudonym> That is, it should flush on newline.
19:35:05 <Pseudonym> If you have no newlines, you may need to flush.
19:35:28 <pflanze> putStr alone works. I'm outputting to stdout (I hope).
19:36:02 <lennart> try an 'hFlush stdout'
19:36:15 <pflanze> where is it?
19:36:22 <pflanze> (not in scope)
19:36:26 <lennart> import IO
19:36:52 <pflanze> ok, nothing happened.
19:37:12 <lennart> are you sure you get to the code that prints?
19:37:28 <pflanze> I'll try to summarize:
19:37:40 <pflanze> *Main> sequence (printResultRowIO (do { return ("hallo",10) }))
19:37:40 <pflanze> hallo,10
19:37:47 <pflanze> works as expected, but:
19:38:15 <pflanze> printResultsIO resultate = fmap printResultRowIO resultate
19:38:21 <pflanze> printResultsOfcsvfile path =
19:38:21 <pflanze>     printResultsIO (resultate (csvfileToBetriebeIO path))
19:38:36 <pflanze> *Main IO> printResultsOfcsvfile "test.csv"
19:38:39 <pflanze> does nothing.
19:38:54 <urz> is there an == for functions?
19:38:56 <lennart> well, you don't want fmap
19:39:02 <lennart> No == for functions
19:39:04 <emu> does function equality make sense?
19:39:11 <urz> it does in C
19:39:25 <Cale> urz: no
19:39:29 <lennart> emu: it makes sens for functions with finite domain and range
19:39:47 <urz> i have a string to function table and i wanted to filter the notimplemented
19:39:50 <johnnowak> urz: In C you can compare function address, but that's it.
19:40:05 <Cale> urz: It largely doesn't make sense in Haskell because it's not computable (unless as lennart suggested, the domain is finite)
19:40:20 <Cale> urz: Use Maybe
19:40:38 <urz> naw
19:40:41 <Cale> Make it a table from strings to Maybe functions.
19:40:42 <pflanze> lennart: why not? and why does it not print anything? (should I put up my full code?)
19:40:46 <urz> I intend to implement everything
19:40:55 <urz> that was just a temporary thing, but clearly its not convenient
19:40:55 <Cale> and represent nonimplementation by Nothing
19:40:57 <lennart> pflanze: I'm not sure exactly what you're doing.  But using fmap with for an IO action is not likely what you want
19:41:00 <Cale> ah
19:41:07 <Cale> then just have it fail :)
19:41:38 <pflanze> lennart: the funny thing is that in some parts of the programs it works exactly as expected.
19:41:47 <emu> let f x = f x; g x = g x -- can you compute the equality of these functions? =)
19:41:58 <johnnowak> emu: You can, but can Haskell? :)
19:42:54 <lennart> pflanze: well, it looks very suspicious to me :)
19:43:59 <Cale> pflanze: look closely at the types
19:44:02 <pflanze> lennart: how would you work with an IO [[String]] value (from Parsec from a file)? I have to map over it, do some calculations, then output it again to a file.
19:44:11 <pflanze> someone said, use let.
19:44:14 <Cale> pflanze: What's the type of printResultsOfcsvfile?
19:44:27 <pflanze> but I wanted to finish with my fmap track first, and it even worked at some point.
19:44:46 <Cale> pflanze: You'd define an action which executed it, getting the [[String]], and then doing whatever
19:44:49 <pflanze> (Text.ParserCombinators.Parsec.Pos.SourceName -> IO [IO ()])
19:44:54 <lennart> pflanze: I'd use ' do xss <- callParsec; print xss'  or something like that
19:45:05 <Cale> do xss <- myIOListListString
19:45:09 <Cale>    print xss
19:45:10 <lennart> inside the do, xss has type [[String]] and is easy to work with
19:45:12 <Cale> like that
19:45:49 <Cale> pflanze: That seems possibly quite inappropriate -- it's an IO action returning a list of IO actions
19:46:07 <pflanze> yes, strange.
19:46:18 <Cale> pflanze: The reason nothing is printed is that IO actions don't print their result when run, by default -- not that its result is even printable
19:46:41 <pflanze> yes I see. Must have broken something along the lines.
19:46:47 <Cale> You probably want to apply (join . fmap sequence) to that
19:47:00 <Cale> though it might be better to just rework what you've done a bit
19:47:10 <lennart> or use the do notation
19:47:20 <pflanze> Ok thanks for the tips.
19:47:25 <pflanze> I'll take a quick break then see again.
19:47:27 <lennart> and limit the IO to the input and output parts
19:49:22 <lennart> Cale: have you heard of anyone implementing Omega (or some other decision procedure for Presburger arithmetic) in Haskell?
19:53:31 <Cale> lennart: nope
19:54:05 <lennart> I'll just do it myself then.  i just wanted to play with it
19:55:33 <hitodama> Hmm, I'm trying to download a haskell library and I get to some sort of "darcs" page
19:55:43 <hitodama> is there anyway to just get everything in a tarball?
19:56:10 <Cale> hitodama: just darcs get the page, and it'll download everything
19:56:31 <Cale> Which library, btw?
19:56:51 <hitodama> the haskell interface for supercollider
19:57:05 <hitodama> supercollider is an audio synthesizer
19:57:55 <Cale> It could be that nobody has made a release tarball of it. Most Haskell projects use darcs for revision control.
20:00:26 <hitodama> ahh, got it, that wasn't so bad
20:03:01 <urz> whats a nice silent way to consume a list so that every value is read
20:03:12 <dons> length ?
20:03:23 <dons> or last?
20:03:30 <urz> ok
20:03:40 <Cale> Those only force the conses though, not the elements
20:04:24 <urz> well i have a readFile
20:04:32 <urz> and i want to force the file to close
20:04:40 <dons> or use a strict string type
20:04:40 <Cale> oh
20:04:41 <urz> it gives me a lazy list
20:04:47 <jcreigh> Cale: Oh, so when you length a list that's not otherwise evaluated, Haskell cons a list of thunks?
20:04:49 <Cale> yeah, length'll do it
20:05:02 <dons> do s <- readFile "X" ; evaluate $ length s ; return s
20:05:04 <Cale> jcreigh: yeah
20:05:23 <Cale> jcreigh: which *may* evaluate some or all of the elements, but that's not guaranteed
20:05:37 <dons> > let s = [1..] in 1+2
20:05:38 <lambdabot>  3
20:05:45 <dons> > let s = [1..] in length s `seq` 1+2
20:05:49 <lambdabot> Terminated
20:05:57 <urz> hm
20:06:07 <Cale> > let s = [undefined, undefined, undefined] in s
20:06:08 <lambdabot>  Add a type signature
20:06:11 <urz> i have it as an s <- readFile
20:06:12 <Cale> > let s = [undefined, undefined, undefined] in length s
20:06:13 <lambdabot>  3
20:06:26 <Cale> > let s = [undefined, undefined, undefined] in s :: [Integer]
20:06:27 <lambdabot>  Undefined
20:06:39 <urz> how do i make it a strict string
20:06:56 <Cale> urz: You'd have to use something like the ByteString library for that
20:07:02 <dons> you don't need to. I was just pointing out that strict string types, like Data.ByteString, don't suffer this issue
20:07:09 <dons> (though of course data.ByteString.Lazy does)
20:07:16 <Cale> which doesn't come with GHC yet, unless 6.6 has come out while I was away :)
20:07:46 <dons> urz, all you need is: do s <- readFile "x" ; length s `seq` return s
20:08:07 <dons> oh maybe bang patterns would be nice for this job
20:08:07 <Cale> You might find it saner to use openFile, together with strict actions to read the file, followed by an hClose
20:08:20 <Cale> but yeah, you can just seq the length
20:09:37 <dons> oh, we'd need deep bang patterns
20:11:16 <dons> do !!s <- readFile "x" ; ... :)
20:16:56 <Cale> Basically, readFile is more appropriate when you *want* to read the file lazily.
20:17:45 <Cale> If you're not going to use the file lazily for a bit before forcing it all, you're probably better off using openFile and operations to read the stream of characters from the handle.
20:17:52 <dons> readFile  and lazyReadFile might have been a good idea
20:18:13 <Cale> Well, I'd suggest a strict version called readFile'
20:18:15 <dons> or readFile strictReadFile
20:18:16 <dons> yeah
20:18:22 <Cale> and (h)GetContents'
20:18:37 <dons> would solve a bunch of newbie issues
20:18:57 <dons> Haskell' !
20:19:37 <dons> Cale, what do you think of adding forM and forM_
20:20:15 <dons> to Control.Monad, http://www.haskell.org/pipermail/cvs-all/2006-August/049142.html
20:20:17 <lambdabot> Title: Add Control.Monad.forM and forM_
20:20:22 <Cale> Oh, that should definitely be done
20:20:31 <Cale> and repeatM
20:20:38 <dons> since that's another newbie issue : no "loops" :)
20:20:45 <Cale> hehe
20:21:12 <dons> I'd like to get forM and repeatM into ghc 6.6
20:21:26 * dons adds repeatM and resends the patch
20:22:07 <zeeeee> it seems FiniteMaps can act as hash tables/dictionaries, but is there a standard hash table implementation of the more "familiar" variety that costs an amortized O(1)?
20:22:21 <dons> ?hoogle HashTable
20:22:22 <lambdabot> Data.HashTable :: module
20:22:23 <lambdabot> Data.HashTable.HashTable :: data HashTable key val
20:22:28 <mlh> eagerReadFile?
20:22:33 <dons> ?docs Data.HashTable
20:22:33 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-HashTable.html
20:22:35 <zeeeee> dons: doh..thanks
20:22:47 <lennart> but HashTable has a weird interface
20:22:57 <dons> no worries. but its weird for hsakell. use Data.Map or Data.IntMap :)
20:23:05 <lennart> Use Data.Map and switch only when your performance needs it
20:23:21 <zeeeee> lennart: what do you mean?
20:23:24 <dons> which is hardly every the case -- Data.IntMap almost alwayswins anyway
20:23:24 <zeeeee> seems fine
20:23:38 <zeeeee> oh wait
20:23:42 <lennart> I mean, don't use Data.HashTable
20:23:43 <dons> (though I've not tried the HashTable speed ups recently committed)
20:23:46 <zeeeee> never mind, i see what you're both talking about
20:24:01 <dons> the new judy binings might be a better HashTable, if you really need a mutable table
20:24:29 <zeeeee> i'm still going through the chapter on monads, so it may be a while before i know how to use this
20:25:03 <dons> do x <- H.new ; H.insert  key val ; ... -- if i remember my HashTable correctly
20:26:15 <zeeeee> hmm...i'm a bit confused what IntMap is about...i thought it only accepts ints as keys, but that's not the case
20:27:21 <Cale> zeeeee: it is the case
20:27:33 <Cale> type Key = Int
20:27:51 <dons> zeeeee: are you mising up Map and IntMap ?
20:28:06 <Cale> Map is the general finite map implementation
20:28:12 <dons> maybe IntMap should have been called MapInt, since its Map @ Int
20:28:20 <zeeeee> oh! waddya know...hsjudy is a soc project
20:28:36 <Cale> dons: Really, it shouldn'
20:28:41 <zeeeee> cale, dons: my mistake
20:28:41 <Cale> dons: Really, it shouldn't be visible at all
20:28:52 <dons> yeah, RULES for ever!
20:29:08 <dons> (I've just removed a bunch of fps api stuff, in favour of rules)
20:29:30 <dons> so you just get the fast version of stuff, without trying
20:29:51 <zeeeee> dons: rules?
20:29:56 <dons> so it would be doable to have a RULE for Map Int -> IntMap
20:30:07 <dons> though messing with the types might be a bit ... hmm. iffy
20:30:31 <dons> zeeeee: ghc lets library authors add custom optimisations in the library src
20:30:36 <zeeeee> is it this? http://www.haskell.org/haskellwiki/GHC/Using_Rules
20:30:38 <lambdabot> Title: GHC/Using Rules - HaskellWiki
20:30:42 <dons> yep.
20:31:13 <dons> Data.ByteString has a rule, for example:
20:31:14 <dons> {-# RULES
20:31:14 <dons> "FPS specialise zipWith" forall (f :: Word8 -> Word8 -> Word8) p q .
20:31:14 <dons>     zipWith f p q = unpack (zipWith' f p q)
20:31:14 <dons>   #-}
20:31:36 <dons> that says, if you ever try to use zipWith on two ByteStrings to generate a list, instead, use the fast, monomorphic zipWith' and unpack instead
20:31:55 <zeeeee> dons: fps == fast packed strings?
20:32:01 <dons> yep
20:33:08 <dons> here's another rule:
20:33:09 <dons> "FPS specialise pack.zipWith" forall (f :: Word8 -> Word8 -> Word8) p q .
20:33:09 <dons>     pack (zipWith f p q) = zipWith' f p q
20:33:29 <dons> which removes an intermediate list
20:33:48 <dons> (these are just little examples of ad hoc optimisations you can add to library code)
20:34:06 <Cale> dons: Another way to get that effect uses class associated types or fundeps
20:34:16 <dons> yep
20:34:29 <dons> the Map -> IntMap thing could be done with ATs
20:35:05 <dons> (much cleaner than rules, since you get checking as well)
20:35:11 <dons> (and it operates on types, not expressions)
20:35:36 <dons> rules are good for some TH-ish transforms , without heavy TH overhead
20:48:07 <dons> here's a nice graph showing the speed up in Data.ByteString between the stable and unstable branches: http://cgi.cse.unsw.edu.au/~dons/blog/2006/08/28#more_stream_fusion
20:48:08 <lambdabot> Title: Haskell, hacking and other stuff
20:48:20 <dons> purely due to stream combinators and better fusion rules
20:48:27 <dons> and improvements in ghc's rule matcher
20:50:29 <jgrimes> dons, wow, thats pretty cool
20:53:13 <dons> i'm amazed at how much we keep squeezing out of ghc
20:53:33 <dons> (it seems to get faster on a weekly basis)
20:56:17 <urz> does getDirectoryContents give me a sorted list?
20:56:58 <dons> it does if you sort it
20:57:12 <dons> sort `fmap` getDirectoryContents ...
20:57:17 <dons> getDirectoryContents >>= return . sort
21:08:26 <Cale> dons: is it just me, or have you effectively doubled the speed of fps repeatedly?
21:09:18 <Cale> It seems like every week or two, you'll have some graphs which show a bunch of fps tests running in about half the time they used to :)
21:10:36 <dons> Cale. yes!
21:11:32 <dons> rewrite rules + ghc 6.5 really kick butt
21:12:05 <dons> we're getting down in to territory now where we start getting concerned about branch prediction and such like
21:12:10 <Cale> :)
21:13:12 <Pseudonym> Phil Wadler once had a go at the Mercury group for being concerned about delay slots.
21:13:13 <dons> dcoutts even posted a reqest for {-# UNLIKELY #-} pragmas, just to work around an issue with fast code paths we were having
21:13:18 <dons> heh
21:14:03 <dons> I should benchmark against fps 0.1 at some point
21:14:11 <dons> (i.e. what darcs uses)
21:23:28 <Cale> dons: definitely
21:23:49 <Cale> dons: It'd be cool to see just what order of magnitude the difference is.
21:24:11 <dons> yeah, let me see if I can whip that up now
21:24:19 <Cale> Do you know if darcs plans on switching to the new bytestring when 6.6 is released?
21:24:37 <dons> no idea. hopefully they will.
21:24:46 <dons> David certainly has been following the fps work
21:24:54 <dons> (and sent a few patches)
21:25:12 <kpreid> dons: have you thought about making the config bits of lambabot not directly under version control? it's a bit of a pain :)
21:25:22 <dons> kpreid: I have thought about it yes :)
21:25:37 <dons> they need to be under version control to distribute them in darcs though
21:25:49 <SamB> but then dons would need to come up with a new backup/default strategy
21:25:54 <dons> yep
21:26:00 <dons> something like hmp3's .config files
21:26:02 * kpreid particularly notes "Changes to the Seen module." which also fiddles with config
21:26:08 <dons> would be doable fairly easily
21:26:26 <SamB> if you are talking about Config.hs, though, it would be *really* nice if dons would keep his proxy settings to himself
21:26:29 <kpreid> one way would be to make the config files, if present, themselves represent diffs from the default config
21:26:51 <dons> SamB: its there  so people know how to add the proxy.
21:26:59 <dons> but i'll default it to Nothing then, since you complain :)
21:27:34 <SamB> yeah, its been a source of annoyance at least twice...
21:27:42 <dons> Mon Aug 28 14:23:27 EST 2006  Don Stewart <dons@cse.unsw.edu.au>
21:27:43 <dons>   * proxy = Nothing, to keep SamB happy
21:27:56 <Cale> maybe just add some documentation to Config.hs in the form of comments
21:27:58 <SamB> oh, it is the 28th already is it?
21:28:01 <dons> yeah, done.
21:28:16 <SamB> I mean, even here in the US...
21:28:25 <dons> ?localtime SamB
21:28:28 <lambdabot> Local time for SamB is Mon Aug 28 00:25:33
21:28:46 <SamB> but only in this time zone, so far!
21:28:57 <SamB> there are three more to go in the continental US!
21:32:35 <dons> ok cool fps 0.1 actually builds and runs :)
21:41:44 <kpreid> dons: grr. I repeat the request for a report of exactly which plugin's serialized state is bad
21:42:11 * kpreid guessed seen
21:45:46 <dons> seen
21:46:07 <dons> would you like to add a handle to the state reading code, to report the error ?
21:46:10 <dons> it'd be one line
21:47:06 <kpreid> noted. but I have a new problem now :)
21:47:31 <kpreid> when I run it --online it exits immediately after "Initializing plugins ....[...]... done."
21:48:19 <dons> are you trying to connect as 'lambdabot' to freenode?
21:48:30 <dons> or slashnet
21:48:54 <kpreid>         name            = "swhask",
21:48:54 <kpreid>         host            = "chat.freenode.net",
21:48:59 <kpreid> that hasn't changed
21:49:11 <dons> you sure the seen state is working?
21:49:13 <kpreid> also, if I run 'online' in ghci:
21:49:20 <kpreid> Initialising plugins ............................................ done.
21:49:21 <kpreid> *** Exception: exit: ExitFailure 1
21:49:24 <kpreid> I deleted the seen state
21:58:29 <kpreid> dons: it's not the state; I just tried removing it entirely and the same failure occurs
22:00:09 <dons> ok. no idea then, other than that the network is being bad to you
22:01:00 <kpreid> aha
22:01:30 <kpreid> first IP for chat.freenode.net is not up
22:02:06 <kpreid> so, it's lambdabot's [network library's] fault for not trying the rest :)
22:02:14 <dons> heh
22:02:15 <dons> ok
22:02:18 <dons> darcs send
22:02:35 <dons> (we could do that, you know, have a list of servers..)
22:02:47 <dons> and at least report the failure a bit better
22:02:47 <kpreid> er
22:02:52 <kpreid> 'that'?
22:03:01 <dons> try a few servers if the first one fails
22:03:21 <kpreid> what I mean is: DNS returns a list; lambdabot is ignoring all but the first element
22:03:45 <dons> ah
22:03:54 <dons> the underlying network lib is
22:05:08 <kpreid> I see
22:05:58 <emu> who wrote the problem for this year's ICFP
22:07:10 <kpreid> dons: works now. however, the offline mode is broken (and, iirc, has been prevously) -- after I type a command I get the "IrcMessage {...}" but then no response and no prompt
22:11:53 <dons> what command do you type?
22:12:13 <dons> (since there's some that will attempt to do network stuff and time out or block..)
22:12:20 <dons> lambdabot> bot
22:12:20 <dons> IrcMessage {msgPrefix = "null!n=user@null", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@bot"]}
22:12:23 <dons> :)
22:12:42 <kpreid> lambabot> free a :: [a] -> Foo a
22:12:47 <kpreid> lambdabot> > 1 + 1
22:12:51 <kpreid> lambdabot> id 1
22:13:06 <dons> works here. something else must be busted on your box
22:13:21 <dons> lambdabot> free a :: [a] -> Foo a
22:13:21 <kpreid> -- some things I've tried
22:13:21 <dons> IrcMessage {msgPrefix = "null!n=user@null", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@free a :: [a] -> Foo a"]}
22:13:25 <dons> $map_Foo f . a = a . $map f
22:13:35 <kpreid> hm
22:13:51 <dons> are you installing lambdabot into the pwd?
22:13:54 <kpreid> yes
22:22:00 <lispy> dons: i still haven't been able to get this compilation problem solved on my amd64 machine
22:22:36 <dons> well, you found a gcc bug, right?
22:22:42 <lispy> maybe
22:22:50 <dons> did you reduce it to the particular module causing trouble?
22:22:53 <lispy> doesn't seem to depend on the gcc version
22:22:58 <lispy> nope
22:23:03 <lispy> not yet
22:23:15 <dons> ok, try that. then we can narrow it down to a particular bit of C
22:23:22 <dons> and whatever ghc is generating
22:24:01 <lispy> okay, i bet i can get it to happen with hello world
22:25:25 <dons> that would be the way to do it, yes.
22:26:03 <lispy> damn, it's not quite that easy :)
22:27:25 <dons> ooh, MS is recruiting at my uni, "We invite you to join us as we move toward the .NET age". should I apply?? ;)
22:27:39 <lispy> heh
22:28:02 * lispy got in an email fight with a MS recruiter once
22:28:03 <dons> oh, I can test: Design and develop test plans/test suites to test various components of one
22:28:07 <dons> of our primary products- Windows , Office, Visual Studio, .NET, etc.
22:28:07 <dons> "
22:28:48 <lispy> i showed the email log to a friend and he annonymized it and sent it out to our local ACM group
22:29:08 <dons> email log?
22:29:21 <lispy> fast forward to a few years later and i will occasionally hear a story about "JHACKER" that got in a fight with the MS recruiter...I just nod and smile :)
22:29:28 <lispy> well, the email messages
22:29:43 <dons> heh
22:29:51 <lispy> "Good story, wish i'd been there.."
22:30:15 <Korollary> "Join us to fix Vista. Please."
22:30:32 <Pseudonym> I once had dinner with the principal Java evangelist at Microsoft.
22:30:38 <Pseudonym> Obviously this was some time ago.
22:31:20 <Pseudonym> The experience was... well, imagine what it would be like to have dinner with a spy.
22:31:26 <dons> ?topic-tell #haskell
22:31:26 <lambdabot> ["Haskell Communities & Activities Report, 10th edition", "http://haskell.org/communities/", "Haskell.org SoC projects", "http://hackage.haskell.org/trac/summer-of-code/", "Haskell is still the
22:31:26 <lambdabot> language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion", "The ICFP has ended. Who won?"]
22:31:43 <Pseudonym> You'd be talking and talking, and at the end of the evening, you'd realise that you'd said a lot but hadn't learned a thing.
22:31:51 <Korollary> Pseudonym: When was this?
22:31:59 <Pseudonym> Uhm... 1998?
22:32:08 <dons> ?topic-cons #haskell "Join as we move forward toward the Age of the Lambda"
22:32:09 --- topic: set to '["\"Join as we move forward toward the Age of the Lambda\"","Haskell Communities & Activities Report, 10th edition","http://haskell.org/communities/","Haskell.org SoC projects","http://hackage.haskell.org/trac/summer-of-code/","Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","We put the Funk in Funktion","The ICFP has ended. Who won?"]' by lambdabot
22:32:33 <Pseudonym> Quote escaping goodness.
22:32:45 <dons> ?topic-tail #haskell
22:32:46 --- topic: set to '["Haskell Communities & Activities Report, 10th edition","http://haskell.org/communities/","Haskell.org SoC projects","http://hackage.haskell.org/trac/summer-of-code/","Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","We put the Funk in Funktion","The ICFP has ended. Who won?"]' by lambdabot
22:32:51 <lispy> anyone know which debian package contains ld?  binutils by any chance?
22:32:57 <dons> ?topic-cons #haskell Join as we move forward toward the Age of the Lambda
22:32:58 --- topic: set to '["Join as we move forward toward the Age of the Lambda","Haskell Communities & Activities Report, 10th edition","http://haskell.org/communities/","Haskell.org SoC projects","http://hackage.haskell.org/trac/summer-of-code/","Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","We put the Funk in Funktion","The ICFP has ended. Who won?"]' by lambdabot
22:33:02 <dons> there we go.
22:33:05 <Korollary> lispy: I think so.
22:33:10 <dons> binutils, surely
22:33:11 <Pseudonym> I'm pretty sure it's binutils, yes.
22:33:16 <Pseudonym> But ld.so is in libc
22:33:30 <lispy> currently ld is the program crashing
22:33:38 <Pseudonym> Right.
22:34:04 <lispy> ah yeah, ld is in binutils
22:34:23 <lispy> $ ghc --make Setup.hs -O2
22:34:24 <lispy> Chasing modules from: Setup.hs
22:34:25 <lispy> Compiling Main             ( Setup.hs, Setup.o )
22:34:26 <lispy> Linking ...
22:34:28 <lispy> collect2: ld terminated with signal 9 [Killed]
22:36:22 <lispy> if i undersnand things, ld was terminated by the oom killer
22:37:05 <lispy> okay, so it still crashes with -fasm, so the fact that it's ld and -fasm doesn't help means that gcc is not to blame?
22:40:53 <Korollary> Firefox crashed. Yay.
22:49:06 <lispy> i should upgrade lib64 and try this again
22:53:03 <dons> lispy, right. an ld issue eh?
22:53:23 <dons> i thought it worked with -fasm before?
22:53:34 <lispy> dons: yeah, today...last time it was cc1, but i did upgrade/downgrade things since then
23:07:54 <lispy> dons: adding -static allows things to compile
23:08:05 <lispy> dons: so...could it be that dynamic linking is borked on my machine?
23:08:30 <lispy> or could it be that i just freed up a bunch of ram...
23:09:43 * lispy tries it with fps
23:11:36 <lispy> dons: hmm...hmmm..hhmmm...yes, adding -static the compile now goes through even with -O2
23:11:45 <dons> yeah, I think its a ram issue
23:11:55 <dons> not sure wihy -no-keep-memory wasn't working though...
23:12:04 <lispy> i have that in there too
23:12:16 * lispy tries without it
23:13:15 <lispy> i don't think it was a ram issue, i mean, really when it happens the runaway process (ld in this case) would just start consuming ram until something killed it
23:14:30 <lispy> or not
23:14:32 <lispy> geez
23:14:47 <lispy> i hate this
23:15:57 * lispy makes a note that its time to buy more ram for the server
23:18:51 <lispy> i mean, how many hours did i just wait debugging something that ends with, "Kill emacs because it's using too many resources"
23:19:10 <johnnowak> lispy: i could've told you that :)
23:19:34 <lispy> i wish emacs had better GC
23:19:46 <SamB> lispy: also, use gkrellm and top!
23:20:00 <sieni> 800 megabytes and constantly swapping
23:20:02 <lispy> SamB: it's a server
23:20:05 <johnnowak> lispy: make is list of the essential features and rewrite it in haskell :)
23:20:23 <lispy> SamB: i was using top, and i knew emacs was using a ton, i just didn't realize that it was the issue
23:20:40 <SamB> lispy: if emacs is at the TOP, you should kill it
23:20:54 <SamB> at least... if its many times the other things...
23:21:23 <lispy> in that case i should probably stop running ntop
23:21:30 <SamB> sieni: I thought it stood for eleven megabytes and constantly swapping
23:21:37 <lispy> it's using about 300megs between the two instances
23:22:07 <dons> ?karma+ Lemmih -- fixing prof and C issue that plagued fps :)
23:22:07 <lambdabot> Lemmih's karma raised to 21.
23:24:33 <lispy> br
23:24:36 <lispy> oops
23:25:19 <johnnowak> hm.. i see vim is eating up 1200K again
23:25:25 <sieni> SamB: it goes up during the years ^_^
23:26:52 <lispy> heh, part of the reason emacs uses so much is because i use it for irc and it doesn't correctly flush its memory and data comes in
23:27:08 <johnnowak> eep
23:27:16 <lispy> after a few weeks it will be using 100 megs...then after a month or two 300 megs
23:28:03 <johnnowak> what are you using so i know to avoid it? :)
23:28:52 <dons> ?karma+ inline -- five times faster lazy dropWhile/takeWhile/all/any with one little pragma
23:28:52 <lambdabot> inline's karma raised to 1.
23:30:02 <lispy> johnnowak: ERC Version 5.0 $Revision: 1.743 $
23:30:11 <johnnowak> roger
23:30:54 * lispy goes back to trying to build lambdabot
23:33:59 <dibblego> what is a procedure called if it is not referentially transparent?
23:34:34 <dons> impure?
23:34:39 <dons> side-effecting?
23:34:44 <dons> evil?
23:34:51 <dons> hell-bound?
23:34:53 <lispy> in lisp we call it 'destructive'
23:35:37 <dons> I think we should use the term 'angelic' for referentially transparent code now, and 'hell-bound' for side effecting stuff
23:36:26 <dons> "I used an angelic reader monad, rather than that hell-bound IO thingy"
23:36:40 <lispy> dons: when i installed fps it wasn't set world readable so when i tried building lambdabot i got errors.  Is this my fault or should we do something about the fps installer?
23:36:59 <dons> I think its a Cabal issue that's been fixed in later Cabals
23:37:05 <lispy> oh
23:37:11 <lispy> yeah, i should upgrade cabal
23:37:13 <dons> (or maybe its a macin-issue)
23:37:31 <dons> (not "macin-tosh")
23:37:47 <lispy> macin?
23:38:47 <kzm> Is this channel archived anywhere?
23:39:01 <lispy> @where logs
23:39:01 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
23:39:02 <kzm> (and: good morning, everybody)
23:39:16 <dons> bye!
23:39:19 <lispy> heh
23:39:51 <SamB>  "@tell kzm bye!" ?
23:40:07 <dibblego> dons, they are all adjectives - what noun do they apply to?
23:40:19 <dibblego> "impure function" is oxymoronic
23:40:27 * kzm arghs.
23:40:32 <kzm> @where logs
23:40:33 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
23:40:44 * lispy gets the "Distribution/Simple.hs:61:1: lexical error" and goes to check the mail archive because he remembers seeing a fix...
23:40:44 <SamB> kzm: hello again!
23:41:05 <eivuokko> lispy, Try with -cpp
23:41:20 <dons> noun = code, procedure, routine ... and yes, function.
23:41:21 <kzm> Yes, yes.  New WM, new keys doing new things.
23:41:40 <kpreid> dons, lambdabot patch coming up shortly
23:41:50 <lispy> eivuokko: ah, yeah.  Thanks
23:42:25 <dibblego> dons, isn't a function is referentially transparent by definition?
23:42:51 <SamB> dibblego: unless it is hell-bound!
23:42:58 <araujo> mathematically speaking, yes dibblego
23:42:59 <dibblego> then is it a function?
23:43:03 <lispy> dibblego: in C lots of non-referentially transparent things are called "functions" so...the definition gets muddled! ;)
23:43:48 <dibblego> so, "impure function" makes no sense
23:43:50 <araujo> But many others stream have taken the word... and twisted it a _tiny_ bit :-)
23:43:59 <kzm> @seen ivant
23:43:59 <lambdabot> I saw ivant leaving #haskell 6 hours, 42 minutes and 17 seconds ago, and .
23:44:02 <dons> comp sci people use 'function' in a non-mathematical sense. which is confusing in FP langs, where a function regains its math sense, but is still used to mean any routine
23:44:11 <kzm> (what's the 'and .' thing?)
23:44:12 <dibblego> I refuse to follow misguided masses
23:44:28 <lispy> @type (and .)
23:44:28 <dons> go nuts then. use 'routine' or 'procedure' or 'code' :)
23:44:28 <lambdabot> forall a. (a -> [Bool]) -> a -> Bool
23:44:35 <dibblego> dons, will do, thanks :)
23:44:37 <dons> kzm: typo.
23:44:47 <araujo> I wouldn't consider it a misguided thing. It is a more a 'convenience' thing
23:45:03 <dons> ?foldoc function
23:45:04 <lambdabot> *** "function" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
23:45:05 <lambdabot> function
23:45:05 <lambdabot>  
23:45:05 <lambdabot>     1. <mathematics> (Or "map", "mapping") If D and C are sets
23:45:05 <lambdabot>     (the domain and codomain) then a function f from D to C,
23:45:06 <lambdabot> [25 @more lines]
23:45:10 <dons> ?more
23:45:11 <lambdabot>     normally written "f : D -> C" is a subset of D x C such that:
23:45:11 <lambdabot>  
23:45:12 <lambdabot>     1. For each d in D there exists some c in C such that (d,c) is
23:45:14 <lambdabot>     an element of f.  I.e. the function is defined for every
23:45:16 <lambdabot>     element of D.
23:45:18 <Pseudonym> ?free anddot :: (a -> [Bool]) -> a -> Bool
23:45:18 <lambdabot> [20 @more lines]
23:45:23 <lambdabot> ( k y = y  =>   $map k (g x) = h (f x) ) => anddot g z = anddot h (f z)
23:45:37 <kzm> Come on - every field invents their own terminology, mostly by twisting existing words.
23:45:40 * kzm shrugs.
23:46:17 <araujo> It is for convenience .. that way we don't need to re-invent new words everyday
23:46:19 <dibblego> kzm, but I do not baa
23:46:31 <kzm> Which is why I think it is nice to import terminology (typically from English); that way, one tends to not get too much overlap with existing vocabulary.
23:47:07 <kzm> And, hey, comp.sci "functions" are functions as well, but they take an additional implicit parameter.
23:47:18 <dons> right.
23:47:27 <dons> all programming is function with the RealWorld#
23:48:00 <kzm> It makes exhaustive testing a bit harder, that's all.
23:48:25 <kzm> ..but as Moore's law progresses, surely that won't be a problem in the future.
23:48:33 <kzm> :-P
23:49:35 <kzm> dons: ivant was looking for latin* for BS?
23:50:12 <mnislaih> Lemmih ping
23:51:06 <dons> kzm, yep I think so
23:51:41 <kzm> I still have my repo, but it's been fallow for some time, and would need synching up.
23:52:21 <kzm> Hmm...there's a messaging service on \bot these days, isn
23:52:28 <kzm> ...'t there?
23:53:27 <kzm> @botsnack
23:53:28 <lambdabot> :)
23:54:26 <kpreid> dons: sent. it makes "@free id" work
23:57:35 <Lemmih> mnislaih: pong.
23:57:42 <dons> cheers
23:57:51 <basti_> greetings.
23:58:05 <mnislaih> I ran into Darcs issues with the merger Lemmih, that's why I haven't pushed my patches yet
23:59:08 <Lemmih> mnislaih: Conflicts?
23:59:25 <mnislaih> darcs just hangs ...
23:59:38 <mnislaih> "doppleganger patches" would be the term
23:59:44 <mnislaih> The issue is with a single patch in the main repo, and the easiest solution would be to unpull that patch and do the merger manually (I am lucky and it is a very simple patch), but I guess that unpulling patches in the main repo is not an option
