00:01:21 <erider> fraxtal: have you thought about using lush?
00:02:04 <fraxtal> what's that
00:02:44 <erider> lisp universal shell
00:03:27 <erider> fraxtal: http://lush.sourceforge.net/
00:03:28 <lambdabot> Title: Lush: Lisp Universal SHell
00:04:31 <fraxtal> cool i'll check it out whenever my dns is working again
00:30:43 <lucca> hmmm, I tried darcs getting http://darcs.haskell.org/ghc.ghc-6.4/ but it failed to apply patches
00:30:45 <lambdabot> Title: Index of /ghc.ghc-6.4
00:31:05 <lucca> am I grabbing from the wrong spot?
00:31:26 <dons> yep, I think so
00:31:34 <dons> I didn't even think 6.4 was in darcs.
00:31:52 <dons> did you follow the darcs checkout instructions on the ghc page?
00:32:23 <lucca> looking for that now.
00:33:51 <dons> here, http://hackage.haskell.org/trac/ghc/wiki/GhcDarcs
00:33:53 <lambdabot> Title: GhcDarcs - GHC - Trac
00:34:04 <lucca> ahhh, okay.  No; hadn't found that before
00:34:26 <lucca> just saw you talking about 6.5 and went hopping about to a promising looking directory, heh
00:34:38 <dons> :)
00:35:56 <dons> ?version
00:35:56 <lambdabot> lambdabot 4p43, GHC 6.5 (OpenBSD i386 )
00:35:56 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
00:41:10 <lucca> dons: that worked quite well!
00:43:00 <dons> great!
00:55:02 <gour> dcoutts: ping
01:02:29 <kyagrd> join #functional
01:07:16 <gour> Lemmih: jhc still does not build, true?
01:11:51 <foxy__> ?seen dcoutts
01:11:51 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell-blah and #haskell. I last heard dcoutts speak 5 hours, 1 minute and 53 seconds ago.
01:12:51 <dons> sleeping :)
01:17:57 <foxy__> but it's 8:17pm ;)
01:20:53 <norpan> @localtime foxy__
01:20:54 <lambdabot> Local time for foxy__ is Thursday, 3 August 2006 8:20:36 p.m.
01:22:02 <Mibori> > let f i = (let f' 0 l = l; f' i l = f' (div i 10) (chr (mod i 10 + ord '0'): l) in f' i []) in map f (map (2^) [24 .. 32])
01:22:06 <lambdabot> Terminated
01:23:14 <Mibori> > let f 0 = []; f i = f (div i 10) ++ [chr (mod i 10 + ord '0')] in map f (map (2^) [24 .. 32])
01:23:16 <lambdabot>  Exception: stack overflow
01:23:38 <int-e> negative numbers aren't so great ...
01:23:46 <dons> heh
01:24:30 <int-e> > let f i = (let f' 0 l = l; f' i l = f' (quot i 10) (chr (rem i 10 + ord '0'): l) in f' i []) in map f (map (2^) [24 .. 32])
01:24:32 <lambdabot>  ["16777216","33554432","67108864","134217728","268435456","536870912","10737...
01:24:37 <int-e> > let f i = (let f' 0 l = l; f' i l = f' (quot i 10) (chr (rem i 10 + ord '0'): l) in f' i []) in map f (map (2^) [30 .. 32])
01:24:38 <lambdabot>  ["1073741824","./,),(-*,(",""]
01:24:44 <int-e> :-P
01:25:10 <Mibori> =)
01:36:05 <dcoutts> gour, pong
01:36:07 <dcoutts> foxy__, pong
01:36:35 <gour> dcoutts: i wanted to upgrade wp to 2.0.4, but someone was quicker than me...
01:36:49 <dcoutts> gour, heh :-)
01:37:05 <dcoutts> gour, does it look like I did it ok? did you have a special method?
01:37:15 <gour> dcoutts: i just found out about hdbus. cool?
01:37:22 <dcoutts> aye
01:37:37 <gour> again, someone quicker than me
01:38:17 <gour> i see that you plan to clean gtk2hs a bit?
01:38:44 <dcoutts> do i? what do you mean?
01:39:34 <gour> dcoutts: some signals which are not required. saw something on ml..
01:39:48 <dcoutts> right
01:40:30 <gour> you plan to use hdbus in gtk2hs?
01:40:46 <dcoutts> not sure yet
01:41:12 <gour> ok, when anglohaskell starts?
01:41:26 <dcoutts> tomorrow
01:41:35 <gour> ohh, have a fun
01:41:40 <dcoutts> but I'm off in 30min to meet xerox in Cambridge! :-)
01:42:16 <gour> greet him. see you later. i also have to go to bring laptop for repair
02:00:45 <boegel> dcoutts: oh, the interviews are today?
02:00:54 <boegel> dcoutts: take pics and then show 'em to us!
02:07:58 <foxy__> dcoutts, you sound like a busy person... but, I tried notebookSetCurrentPage and I still get those errors (remember?)
02:16:23 <vincenz> boegel: any news from andy?
02:22:23 <boegel> vincenz: I think he's working on his home... haven't heard from him since we got back from Italy
02:28:09 <foxy__> @hoogle app
02:28:09 <lambdabot> Control.Arrow.app :: ArrowApply a => a (a b c, b) c
02:28:10 <lambdabot> Prelude.appendFile :: FilePath -> String -> IO ()
02:28:10 <lambdabot> Ratio.approxRational :: RealFrac a => a -> a -> Rational
02:29:48 <dcoutts_> foxy__, have you tried using notebookSetCurrentPage and then not using setfocus?
02:29:51 <vincenz> boegel: ah k
02:30:05 <foxy__> dcoutts, yes
02:30:24 <vincenz> boegel: How about email?
02:30:43 <dcoutts_> foxy__, hmm, and it still comaplains about focus? that's very odd.
02:35:33 <JohnMeacham> gour: is khc not building? what error are you getting? there are some issues with library dependencies, but I don't think they should affect people using it directly
02:48:20 <bortzmeyer> Could not find module `Distribution.GetOpt': it is hidden (in package Cabal-1.1.3)
02:48:42 <bortzmeyer> What does it mean? Cabal is installd and I can see /opt/ghc/lib/ghc-6.4.1/imports/Distribution/GetOpt.* So, what could be wrong?
02:50:57 <dons> an old version of Cabal is hiding your new version?
02:50:59 <dons> ghc-pkg list
02:51:04 <dons> check the Cabal versions
02:51:36 <bortzmeyer> ghc-pkg list shows only Cabal-1.1.3
02:51:44 <dons> no Cabal-1.0 ?
02:51:58 <lambda_the_insig> -package flag?
02:52:13 <dons> bortzmeyer: Cabal 1.1.3 is a bit old. you could try installing Cabal-1.1.4
02:52:32 <dons> or, if you really have only 1 cabal installed, try unhiding it
02:52:45 <dons> ghc-pkg expose Cabal-1.1.3 -- I think
02:52:47 <bortzmeyer> dons: this is the version currently in Gentoo. I just did a 'emerge Cabal'
02:52:58 <bortzmeyer> I do not have the problem on my Debian machines
02:53:34 <dons> so ghc-pkg only lists one Cabal? and it is hidden (in parens in the list?)
02:54:05 <bortzmeyer> ghc-pkg shows only one Cabal and not hidden (no paren) ghc exposes changes nothing
02:54:24 <dons> ok. then this 'it is hidden' msg is very strange
02:54:40 <dons> do you have the option of getting ghc 6.4.2?
02:54:48 <dons> you'll get a new compiler, and new cabal, out of the box
02:57:18 <dons> yay. array fusion, stream style, works! :D
02:57:24 * dons hacks happily away
03:00:12 <fig> Does anybody know if shapr is okay?
03:00:20 <dons> yeah, he's fine :)
03:00:29 <fig> Great.  I'm glad to hear that. :)
03:00:41 <dons> shapr, lemmih, dcoutts, Phillipa, Igloo, probably others are off to AngloHaskell for a few days
03:00:51 <fig> Cool.
03:01:09 <fig> I'm here because shapr invited me a few months ago, because he believed in my project.
03:01:12 <boegel> fig: he's always ok :)
03:01:19 <dons> fig, that's cool!
03:01:22 <dons> what's your project?
03:01:24 <boegel> fig: which is?
03:01:33 <boegel> goodmorning mathrick
03:01:48 <mathrick> hey there
03:01:48 <fig> http://fig.org/ for short, http://fig.org/figure/CircleOfPromises.{tex,pdf} for long.
03:01:50 <lambdabot> Title: FIG :: Philosophy
03:03:39 <fig> I'm a cybernetician.
03:03:42 <vincenz> fig: and fig stands or?
03:03:44 <vincenz> for..
03:04:07 <fig> vincenz: It's a versatile acronym.  It's supposed to stand for whatever means something to you.
03:04:21 <fig> Fractal Identity Generalization might appeal most to the scientists here.
03:04:32 <fig> Or FIG Is GNU/FIG Isn't GNU.
03:04:41 <dons> heh
03:04:48 <tennin> mightn't Russell's Paradox be a problem for this philosophy?
03:04:54 <dons> :D
03:04:56 <fig> Do explain?
03:05:22 <fig> I don't grok Russell.
03:05:30 <tennin> Neither do I, actually.
03:05:31 <boegel> do you guys know the smurfs?
03:05:48 <dons> la la la-la-la-lala oh no gargamel!
03:05:54 <boegel> dunno of it's international... because speaking smurf is like using the words FIG in a sentence :)
03:06:03 <dons> i always thought azrael  was a cool name
03:06:06 <fig> Ahh, but Google groks Russell's Paradox.
03:06:13 <dons> then I read Milton, and Azrael was just scary
03:06:32 <fig> The answer in FIG: exploit the use of fractals.  It's a member of itself at one scale, and not a member at a different scale.
03:06:53 <fig> s/It's a/It appears to be/
03:08:14 <boegel> sounds complicated :)
03:08:30 <fig> Only as complicated as psychology. ;)
03:08:34 <boegel> so, does your project have a goal? or is it just all about fucking with people's mind?
03:08:45 <fig> ROTFL.
03:08:48 <dons> oh, that's funny. wikipedia knows that Azrael was in the smurfs, but not in Paradise Lost. does this reflect something about wikipedia?
03:09:04 <fig> The goal is to create an operating system, and a governance model for corporations.
03:09:30 <boegel> you changed your name to FIG? isn't that bloody confusing, since everything is FIG?
03:09:41 <fig> I'm leading by example. ;)
03:09:50 <dons> boegel: I assume that shadowing applies to resolve identifiers
03:09:58 <fig> Bingo.
03:10:12 <fig> It's just my last name.  Michael FIG.
03:10:13 <boegel> whatever :)
03:10:22 <dons> there'd be some kind of fig scope. and only one fig can be in scope at any point?
03:10:24 <boegel> not Michael Fig?
03:10:34 <fig> No, it's capitalized.
03:10:41 <boegel> heh :) funny
03:10:49 <vincenz> fig: is it intended to be serious?
03:10:57 <fig> It's a fruity acronym for a fruity person. :)
03:11:11 <fig> Just kidding, only serious.
03:11:24 <vincenz> how much did you smoke?
03:11:33 <fig> Zero.  I did sleep deprivation.
03:11:38 <vincenz> ah, that works too
03:11:41 <dons> ah. i get it.
03:11:59 <fig> dons: Get what?
03:12:00 <tennin> heavily caffeinated?
03:12:05 <fig> Zero caffeine.
03:12:14 <vincenz> caffeine is not fig?
03:12:20 <fig> Sure it is. :)
03:12:33 <vincenz> then you should assimilate it
03:12:40 <fig> I have, just not when I wrote the stuff.
03:13:25 <dons> #haskell gets weird some times
03:13:35 * fig looks guilty.
03:13:52 <dons> > (\x -> x) 1
03:13:53 <lambdabot>  1
03:13:57 <boegel> dons: people get weird sometimes
03:13:58 <dons> ah :) I feel better now
03:13:59 <fig> I'm really just here because I wanted to get in touch with shapr.
03:14:13 <boegel> fig: he seems like your kinda person :)
03:14:20 <dons> fig, its cool. he's on a plan from sweden to the uk at the moment, I think
03:14:21 <fig> Shapr's friends are just as good, though. :)
03:14:22 <boegel> maybe we should take this to #haskell-blah?
03:14:27 <dons> but we might not hear from him for a few days
03:14:35 <dons> boegel: ah yes! that's a good idea
03:14:43 <vincenz> dons: here
03:14:47 <vincenz> > repeat "cookie"
03:14:48 <lambdabot>  ["cookie","cookie","cookie","cookie","cookie","cookie","cookie","cookie","co...
03:14:49 <boegel> fig: join us at #haskell-blah
03:14:49 <vincenz> "take 1"
03:14:51 <fig> boegel: How do I do that in zenirc?
03:15:03 <boegel> "/join #haskell-blah" I guess :)
03:15:07 <dons>  /join #haskell-blah ?
03:15:12 <dons> vincenz: thank you!
03:15:18 <foxy__> fig, Russell's paradox: take a library, make an index of the books, make an index of the indexes including the index that lists all indexes that don't list themselves.  It this index listed in itself?
03:15:22 * dons is filled with lambda juice now!
03:15:43 <vincenz> coffee?
03:16:13 <boegel> foxy__: to continue, please join #haskell-blah
03:16:18 <vincenz> > (\x -> x x) (\x -> x x)
03:16:19 <lambdabot>    Occurs check: cannot construct the infinite type: t = t -> t1
03:16:19 <lambdabot>    Expe...
03:16:20 <dons> foxy__: oh, did I miss the russel's paradox in that Borges story about the infinite library. hmm
03:17:02 <dons> vincenz: no! you'll break #haskell if you run that combinator. luckily we have types. phew!
03:17:10 <dons> that was close
03:17:14 <tennin> is Shapr still planning to attend ICFP, anyone know?
03:17:24 * vincenz bows down to the hindley milner overlords
03:17:57 <foxy__> my algebra lecturer today said that algorithms didn't give rise to proofs.  I pointed at Curry-Howard
03:18:18 <dons> heh
03:18:19 <vincenz> what'd he say
03:18:46 <foxy__> he blushed and said, well you people don't know that yet...!
03:19:07 <dons> ?karma+ foxy -- way to cite Curry-Howard!
03:19:08 <lambdabot> foxy's karma raised to 4.
03:20:32 <gds> though they said it like this: "mightn't Russell's Paradox be a problem for this philosophy?"
03:20:42 * gds moves to the correct window...
03:30:22 <dons> the 'translating haskell into english' tutorial, part 2, is out. some interesting conclusions. http://www.linuxjournal.com/article/9242
03:30:23 <lambdabot> Title: Translate the Haskell into English Manually, Part II | Linux Journal
03:31:09 <dons> like:"it's fair to say that Haskell has some flaws (forinstance, you have to be smart to use it)"
03:31:43 <int-e> wait, how's that a flaw?
03:31:54 <neonka> what's the best online tutorial to begin with, pls ?
03:31:58 <dons> well, I'm not sure its even true.
03:32:12 <dons> neonka: got to http://haskell.org and read 'Haskell in 5 Steps' :)
03:32:13 <lambdabot> Title: Haskell - HaskellWiki
03:32:21 <dons> which then points to the best tuts
03:32:30 <neonka> dons: i have done already.. what's next :)
03:32:36 <dons> ok, YAHT
03:32:39 <dons> ?where YAHT
03:32:39 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
03:32:55 <neonka> ok, thanks
03:33:03 <dons> then, hang out here and ask questions, and hack! :)
03:33:28 <neonka> i'll see if haskell will enjoy me :)
03:33:34 <dons> hehe :)
03:33:40 <neonka> i just learn it for fun
03:33:44 <dons> cool!
03:33:56 <dons> its a fun langugage. we all smile all the time whenwe use it
03:34:13 <dons> > map (^2) [1..5]
03:34:14 <lambdabot>  [1,4,9,16,25]
03:34:17 <dons> lovely!
03:34:30 <neonka> seems cool :)
03:34:35 <dons> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
03:34:36 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
03:34:40 <dons> delicious!
03:34:43 <neonka> dons: what are u using it for ?
03:34:47 <neonka> i mean haskell
03:34:50 <mauke> > take 5 $ map (^2) $ [1..]
03:34:51 <nil> dons: some people think that ada or cobol are lovely languages...
03:34:51 <lambdabot>  [1,4,9,16,25]
03:35:02 <dons> oh, I'm using haskell for work on extending haskell
03:35:16 <dons> nil, oh yes. there's no accounting for taste
03:35:18 <neonka> you are looped :)
03:35:28 <nil> dons: hehe....
03:35:30 <dons> recursion :)
03:36:08 <dons> neonka: have you met lambdabot?
03:36:19 <neonka> i am mainly working on web projects.. could haskell be of any use ?
03:36:28 <int-e> @botsnack
03:36:28 <neonka> dons: it's a bot ?
03:36:28 <lambdabot> :)
03:36:34 <dons> yes, there's a bitof web stuff happening in haskell these days
03:36:37 <dons> like hope,
03:36:38 <dons> ?where hope
03:36:39 <lambdabot> http://hope.bringert.net/
03:36:42 <nil> yes, a smiling bot
03:36:50 <dons> ?type map
03:36:51 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
03:36:53 <dons> ?where lambdabot
03:36:54 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
03:37:10 <dons> its actually a top-secret haskell IDE, in disguise as an irc bot
03:37:19 <neonka> aha
03:37:23 <dons> ?pl \f x -> f x + x
03:37:24 <lambdabot> ((+) =<<)
03:37:55 <dons> there's no haskell golf (unlike perl). we just let the bot do the work
03:38:20 <tennin> gds: though they said it like this: "mightn't Russell's Paradox be a problem for this philosophy?"
03:38:31 <tennin> whoa
03:38:44 <tennin> I'm plural =D
03:38:50 <dons> freaky.
03:39:18 <foxy__> dons, I reckon you should get ndm to make his haskell terminal a Yi plugin, then we can have GoA while editing haskell
03:39:52 <dons> yeah. I was wondering if you were going to somehow embed the terminal in gtk yi
03:40:19 <foxy__> it's a matter of copyright, I suppose...
03:40:21 <dons> though, with the GoA, you don't even need it to run in a terminal -- just call the functions directly in the libHSgoa lib
03:40:41 <foxy__> ooh, that's cool
03:40:54 <dons> GoA's interface is just: lambdabot "string"
03:40:59 <dons> and: wakeup
03:41:13 <dons> so you'd fork lambdabot on startup, then call lambdabot "@pl text", for exampe
03:42:02 <dons> next step: take over the world
03:42:08 <dons> ?brain
03:42:09 <lambdabot> Uh, I think so Brain, but this time, you wear the tutu.
03:42:10 <foxy__> mu ha ha
03:42:17 * foxy__ rubs his hands
03:42:20 <dons> hehe
03:42:35 <fig> ... so I'd like to implement an operating system as an Arrow.  Is there anything comprehensible to a proof-illiterate person to describe how to avoid the black box problem?  I'm aware of HOS, BTW.
03:42:43 <foxy__> dons, I'm trying to restrict hacking to weekends
03:43:06 <dons> foxy__: yeah? what do you do during the week?
03:43:23 <foxy__> dons, go to class and write Matlab functions
03:43:27 <dons> ah
03:43:41 * fig reminisces about being a student.
03:43:46 <dons> fig, hmm. you could look at Frag, the 3d game written in Arrows
03:43:59 <fig> dons: Oooh, that sounds good.
03:44:01 <dons> and House, the OS written in Haskell. then combine them. done.
03:44:18 <dons> Its that easy (TM)
03:44:22 <dons> ?where Frag
03:44:23 <fig> dons: Right.  I meant House, not HOS.
03:44:23 <lambdabot> http://www.cse.unsw.edu.au/~pls/repos/frag
03:44:31 <fig> ?brain
03:44:31 <lambdabot> What can I do for fun, Pinky? That's it! I'll send several
03:44:31 <lambdabot> bills to Senate for ratification, then veto them all!
03:44:43 <dons> oh, i wondered what higher-order syntax had to do with it..
03:45:15 <fig> heh
03:46:06 <fig> dons: That's a Darcs repository?
03:46:14 <dons> ah, yes. it is
03:46:22 <dons> ?wiki Frag
03:46:22 <lambdabot> http://www.haskell.org/haskellwiki/Frag
03:46:26 <dons> might have more details :)
03:46:30 <fig> dons: Too bad I'm terrible at reading Haskell. :(
03:46:40 <dons> ?where+ Frag http://www.haskell.org/haskellwiki/Frag
03:46:41 <lambdabot> Done.
03:47:02 <kowey> hmm... that could be a good tutorial... how to read Haskell
03:47:14 <kowey> i wonder what one would put in it
03:47:20 <dons> not a bad idea. hmm
03:47:29 <fig> kowey: I'll buy 34 copies, if you write it. :)
03:47:35 <dons> x :: Int == "v has type Int"
03:47:44 <dons> and then proceed through the grammar :)
03:47:54 <dons> s/v/x/ -- or it gets too confusing
03:48:11 <kowey> also would have to figure out what confuses people when looking at Haskell code
03:48:22 <fig> If somebody did that for proofs, too, I'd be eternally grateful.  I stumbled my way through TaPL without a prof, and failed miserably at getting better at reading proofs.
03:48:30 <dons> that would be interesting,kowey
03:49:05 <fig> Proofs are pretty close to Haskell anyway.  Do I get karma for an allusion to Curry-Howard?
03:49:10 <dons> people sometimes complain about the lack of `;' -- they don't know where to mentally end expressions
03:49:22 <dons> fig, heh.
03:49:23 * kowey creates a stub
03:49:40 <fig> I love Pliant (http://fullpliant.org/), where I learned to love layout instead of semicolons.
03:49:52 <fig> It's parenthesis-reduced Lisp.
03:50:49 <dons> didn't know about that. very interesting
03:50:53 <dons> i guess someone had to do it
03:51:04 <fig> And waiting for Arc is like waiting for Godot.
03:51:10 <musasabi> fig: about the OS ideas, getting a nice transactional+functional interface for various things seems the hardest part.
03:51:27 <fig> Erlang proved that that's actually trivial when you have message passing.
03:51:34 <musasabi> as one wants a minimal interface, but there needs to be a dirty IO variant too for things which are not transactional or pure
03:51:38 <fig> Oleg proved that that's trivial when you have monads.
03:51:44 <dons> the l4 kernel in haskell though, musasabi, just uses monads all over. same with House
03:52:21 <kowey> http://www.haskell.org/haskellwiki/How_to_read_Haskell
03:52:22 <musasabi> dons: but that is reinventing the wheel.
03:52:22 <lambdabot> Title: How to read Haskell - HaskellWiki
03:52:23 <fig> Oleg ditched the IO monad when he wrote the Zipper OS.
03:52:28 <dons> musasabi: this is true.
03:52:50 <fig> Figure, the OS I'm working on, would be a drop-in replacement (arrow-based) for the IO monad.
03:53:10 <musasabi> fig: true. But I want more than replacement IO.
03:53:27 <fig> What else is there besides pure functions and message-passing?
03:53:51 <musasabi> I want the OS to be mostly functional and support a transactional interface instead of the normal way
03:54:32 <fig> musasabi: I think all I can do is point you to http://erlang.org/ for the proof (the problem you cite being the proposition).
03:54:34 <lambdabot> Title: Erlang
03:54:44 <fig> Curry-Howard strikes again.
03:55:14 <fig> Look at Mnesia if you want to see how they do transactions.
03:55:43 <musasabi> Mnesia transactions are not really good for an OS
03:55:47 <fig> Ditch object-orientation for the low-level hack it is, and embrace processes!  Erlang saved my life and my company!
03:55:54 <fig> musasabi: Why not?
03:56:29 <fig> They use list comprehensions for everything.
03:57:37 <musasabi> Erlang is quite nice, but I like having more static guarantees about things.
03:57:50 <fig> musasabi: I would agree that Oleg's Zipper would be better than Mnesia, and you'd get transactions for free.
03:58:40 <fig> musasabi: I see Erlang as the scripting language, and Haskell as the "real" implementation.  But until Haskell completely subsumes Erlang's features, I need to use it.
03:59:53 <fig> musasabi: So what if the Figure arrow had a Zipper interface for its arbitrary graph-like memory structure (the "O" component in my CotP paper).
04:00:11 <musasabi> well one can do most of things in Haskell. What is really missing is the bit-syntax and industrial quality of various implementations
04:00:43 <fig> Exactly.  The live software upgrade (9 9's reliability) is a plus, too.
04:01:08 <musasabi> hs-plugins = live upgrade. But no such guarantees as Erlang.
04:01:15 <fig> But I guess dons has done that with Yi and lambdabot.
04:01:34 <fig> Ahh, you type/think faster than me.  I'm dynamically typed. ;)
04:02:30 <musasabi> With HAppS we thought about live upgrade via hs-plugins, but decided that the ~2 sec downtime for restart was not reason enough to implement it (and it would have been very involved due to complications)_
04:03:12 <fig> Hmm.  That's unfortunate.  It'll get better, I'm sure.
04:04:06 <musasabi> fig: mostly it was related to FFI side of things and versioning of datatypes.
04:04:12 <fig> musasabi: Where can I learn more about what you know about Haskell?  You seem very well-educated in things.
04:04:13 <musasabi> and concurrency
04:04:43 <fig> You've probably seen Erlang's datatype upgrade/downgrade callback function architecture...
04:04:52 <fig> it's pretty.
04:05:19 <musasabi> Yes, it is quite nice. But implementing it in Haskell without touching GHC internals is quite hard.
04:05:33 <fig> Gulp.  GHC internals.
04:05:50 <fig> GHC needs an operating system, so that it can be understood by ordinary people.
04:06:08 <musasabi> fig: I have mostly learned Haskell stuff from reading various papers, lots of coding practice and numerous discussion on the mailing lists and here.
04:06:41 <fig> Do you mind if I ask you your real name?  I'm Michael FIG, or Gordon-William: Matzigkeit (author of GNU libtool).
04:07:01 <musasabi> Einar Karttunen
04:07:13 * fig googles musasabi.
04:07:56 <fig> Yum.  Join calculus.  I don't grok that yet.
04:08:18 <fig> Ahh, SerTH was what I was thinking of for bit-syntax.
04:08:34 <fig> _You_ did PArrows?!!  Cool.
04:09:04 <fig> ?karma+ musasabi -- for being cool
04:09:05 <lambdabot> musasabi's karma raised to 11.
04:10:03 <musasabi> SerTH is mostly for serializing Haskell values and concentrating on cyclic representations. Usually for simple binary serialization with fixed format I use a simpler encoder/decoder library.
04:11:42 <fig> musasabi: I would greatly appreciate if you spent some time reading my cybernetic autobiography/thesis.  Don't do it unless you want to: http://fig.org/figure/CircleOfPromises.{tex,pdf}
04:12:09 <fig> I start with English and work my way into law, philosophy, and hopefully soon Erlang and Haskell.
04:13:02 * fig wishes they taught cybernetics in Canadian universities.  Any Canadian university.
04:14:15 <musasabi> Will look into reading that later tonight, have some paperwork to do before evening.
04:14:26 <fig> Thank you.
04:14:43 <fig> Thanks all for being so helpful.  I'll be back, because, like Latin, Haskell is a Living Language!
04:18:02 <dons> ?yow
04:18:03 <lambdabot> I need to discuss BUY-BACK PROVISIONS with at least six studio
04:18:03 <lambdabot> SLEAZEBALLS!!
04:36:01 <boegel> that fig character was a weird one... I suspect him to be shapr in disguise
04:40:49 * vincenz nods
04:41:05 <vincenz> I found it curious he gave that text as a serious link to musasabi
04:42:09 <void> Hi, is there a standard (or atleast usable) matrix or numerical computation library for haskell? Or do you recommend using Array for that?
04:51:49 * boegel tries to answer void's question, but the answer gets lost somehow
05:02:29 <void> boegel: well you tried atleast =)
05:10:10 <boegel> void: for some reason it's pretty quiet now... it usually isn't
05:10:40 <boegel> but the regulars or off the Cambridge rigth now, having an informal meeting and fighting eachother for a job :)
05:13:24 <void> heh
05:14:43 <norpan> i haven't seen a matrix library in recent times
05:15:01 <norpan> i saw something that had matrixes instances of Num etc.
05:15:17 <norpan> but i can't remember where or what it was called
05:15:21 <void> writing a simple one should not be that hard, but getting good performance is another matter
05:15:29 <norpan> surely
05:16:05 <norpan> using unboxed arrays and direct mapping to a high performance c library is probably the best way to go, i suppose there are a few of those
05:16:27 <void> hmmm. yeah
05:16:38 <void> might be a good reason to learn FFI =)
05:16:45 <norpan> exactly :)
05:18:55 <void> that would mean that I need a pure C one, C++ might be a bit too hard?
05:19:36 <norpan> well you need to write c wrappers if you're going to use c++
05:19:55 <norpan> google says "BLAS"
05:20:07 <norpan> or "LAPACK"
05:20:22 <void> yeah... seen those before
05:20:28 <void> I've used ublas for c++
05:21:15 <norpan> http://www.isi.edu/~hdaume/HBlas/index.html
05:21:15 <lambdabot> Title: HBlas - Linear Algebra for Haskell
05:21:39 <norpan> you're welcome
05:22:01 <void> nice
05:23:45 <void> heh... all monads
05:25:18 <norpan> wow, nice operators
05:25:29 <norpan> (==<<^>>) etc.
05:31:37 <gds> @type (==<<^>>)
05:31:38 <lambdabot> Not in scope: `==<<^>>'
05:31:40 <gds> :(
05:34:08 <dons> not every haskell module ever written is in scope in lambdabot :)
05:35:49 <gds> a depressing fact, which I've noticed before ;)
05:36:22 <dons> feel free to implement the "suck in all haskell code in the universe" plugin. i accept patches!
05:36:28 <gds> :)
05:36:43 <gds> Did someone mention an upcoming cabal-get the other day?
05:36:55 <ndm> dons: that would slow GHCi to a crawl (i've done it before)
05:37:03 <ndm> much better is to add them all into hoogle :)
05:37:09 <dons> ndm :)
05:37:33 <dons> gds, yep.xerox is hacking away
05:38:05 <gds> You know if it'll take URLs or module names?
05:38:37 <dons> i presume urls are easier
05:38:45 <gds> I suppose in either case, such a thing would open up the option of an @add-module command...
05:38:45 <dons> not sure though. maybe its super magic, based on @where
05:38:55 <gds> That would be very cool :)
05:38:56 <dons> but that's more for cabal-put
05:39:20 <dons> put it all into haskell-cpan, without the 'p'
05:39:49 <dons> chan : comprehensive haskell archive network. not a bad acronym.
05:40:03 <gds> Well that's what I was wondering - but I've noticed a haskellish tendancy toward distributivity in haskell folk...
05:40:19 <dons> distributivity?
05:40:28 <gds> like darcs vs svn
05:40:32 <musasabi> 'chan might make people think of other things
05:40:34 <dons> ah yes.
05:40:40 <dons> musasabi: yeah. but still, sounds cool :)
05:40:48 <gds> :)
05:41:09 * gds imagines cabal-get working like darcs, with URLs...
05:41:19 <gds> then the urls being indexed by multiple instances of hoogle...
05:41:45 * dons -> sleep
05:41:49 * gds waves
05:42:12 <ndm> gds, i do want that
05:42:31 <ndm> i want every project on chan to be automatically indexed by hoogle and available on teh website
05:42:54 <gds> ndm: with some sort of back end hoogle-sync protocol, so the whole mass grows like an IRC network? ;)
05:43:25 <ndm> gds, not really, i was just going to get people to dump hoogle data files in a directory on teh haskell.org server
05:43:27 <gds> (that way I can add my funkynewmodule to my hoogle, and it'll propagate till other people can see it...)
05:43:38 <gds> also works :)
05:44:52 <ndm> i want it so as soon as you upload funky to chan, it gets into hoogle within a day or so automatically
05:44:55 <kowey> anybody here working on a natural language stuff?
05:45:09 <kowey> i'm wondering how much interest there would be in a port of the Zen toolkit to Haskell http://sanskrit.inria.fr/ZEN/
05:45:11 <lambdabot> Title: The Zen Computational Linguistics Toolkit
05:45:52 <kowey> (actually, the real question is if somebody would please port Zen to Haskell, but i'm trying to ask it in a sneaky way)
05:46:58 <gds> ndm: would be very cool - particularly since you already have the framework to allow people to host their own code if they want (not on chan)
05:47:18 <gds> (and still be indexed)
05:47:32 <ndm> yep, thats the goal
05:47:37 <ndm> i already have hoogle for gtk2hs
05:47:46 <ndm> but its not very modular, kind of hacky
06:42:46 <jmob> Anyone familiar with the behavior of readFile as it relates to windows "text mode" and EOF (^Z)?
06:43:54 <ndm> should end the file
06:44:03 <ndm> it just uses the underlying Windows implementation
06:44:16 <jmob> ...which sucks :(
06:44:49 <jmob> Makes creating an MD5 of a 2gb binary file really hard
06:44:51 <ndm> jmob: why?
06:44:57 <ndm> oh, thats really easy then
06:45:01 <ndm> @hoogle openBinaryFile
06:45:02 <lambdabot> System.IO.openBinaryFile :: FilePath -> IOMode -> IO Handle
06:45:16 <ndm> jmob: just use that, and it will be really easy
06:46:19 <jmob> ndm: Yes, except I need to figure out how to update an MD5, rather than "streaming" the file data to the MD5 function
06:46:51 <jmob> hGetContents or the like would attempt to read the whole file in to the heap, which doesn't make Windows too happy.
06:46:52 <ndm> jmob: expplain? not quite sure what you mean
06:47:05 <ndm> jmob: lazy IO, it doesn't work like that :)
06:47:13 <ndm> just do hGetContents and it will work fine
06:47:22 <jmob> except it doesn't :(
06:47:42 <SamB_XP> jmob: are you using Data.ByteString?
06:47:55 <SamB_XP> if so, try Data.ByteString.Lazy instead
06:48:08 <jmob> ?paste
06:48:09 <lambdabot> http://paste.lisp.org/new/haskell
06:48:37 <lisppaste2> jmob pasted "md5" at http://paste.lisp.org/display/23592
06:50:03 <lisppaste2> jmob pasted "md5sum" at http://paste.lisp.org/display/23593
06:50:30 <jmob> hrmm, giving it a 1 gig heap might get it farther.
06:50:44 <jmob> (if, according to ndm, the IO is truely lazy)
06:51:10 <ndm> jmob: it really is, i have relied on that being the case in a program only yesterday
06:51:26 <ndm> which rather than requiring a big heap, would have blocked indefinately on a strict getContents
06:51:54 <jmob> ndm: getContents on a stream? :)
06:51:57 <ndm> jmob: you aren't lazy enough!
06:52:12 <ndm> jmob: there is no difference
06:52:18 <ndm> but its nothing to do with getContents
06:52:38 <ndm> comment out the size and you'll suddenly find it works :)
06:52:53 <ndm> jmob: do that, confirm it for yourself, and i'll then explain the reasons behind it :)
06:53:12 <jmob> Gee, willis.
06:53:27 <ndm> confusing at first, but makes sense after a while
06:53:47 <SamB_XP> yeah... finding the length sorta brings the list into existance...
06:55:15 <jmob> ndm: Yeah, I get it, thanks
06:56:05 <ndm> no probs
07:01:53 <jmob> hrmm, I guess there might be something wrong with the MD5 implementation, a 256m heap isn't enough
07:02:49 <SamB_XP> why are you implementing it again?
07:03:42 <ndm> you might find you need a few seq's to get it working
07:04:03 <jmob> There is no why.  Just curiosity.
07:04:34 <bringert> hi #haskell
07:04:36 <SamB_XP> oh, okay, because if you actually needed an MD5, i'm pretty sure its been done already and Haskell code is quite reusable
07:04:53 <bringert> yes, Igloo has written an MD5 module
07:05:10 <SamB_XP> I believe I've used it
07:05:11 <bringert> it's available in the Crypto package, and some other places
07:05:26 * bringert is back in sweden
07:05:30 <bringert> @seen shapr
07:05:30 <lambdabot> I saw shapr leaving #haskell-blah and #haskell 1 day, 4 hours, 1 minute and 38 seconds ago, and .
07:05:35 <jmob> I'm using Igloo's code, just trying to get it to work on large files
07:05:46 <SamB_XP> what, it doesn't?
07:06:02 <jmob> I guess this is an earlier version.  It much simpler than the latest stuff.
07:06:09 <SamB_XP> ah
07:08:42 <Philippa_> bringert: he's probably in interview atm
07:09:00 * jmob waits for windows to stop page faulting
07:09:49 <jmob> I haven't seen shapr around, he'd be happy I'm attempting to learn Haskell.
07:11:10 <boegel> Philippa_: weren't you going too?
07:11:55 <ndm> AngloHaskell is tomorrow
07:13:12 <void> so everybody wants to work flr MS research maintaining ghc? =)
07:13:15 <void> *for
07:13:42 <bringert> I thought it was just Lemmih and shapr
07:13:47 <ndm> everybody wants a paid haskell job
07:13:52 <ndm> there aren't that many around...
07:13:59 <bringert> did any other #haskellers apply?
07:14:38 <bringert> SyntaxNinja said in here a few weeks ago that Galois is looking for Haskell programmers
07:14:45 <void> yeah, i'm trying to push haskell in my company... se how it'll go
07:15:13 <Philippa_> boegel: I'm going to AngloHaskell
07:15:24 <Philippa_> I'm not applying for a job because I wouldn't be able to do it properly
07:15:25 <bringert> void: I trust you have seen the announcement from Linspire?
07:15:37 <void> bringert: yes I did
07:16:10 <boegel> Philippa_: and AngloHaskell isn't starting today? or are you in Cambridge already?
07:18:09 <ndm> its tomorrow and saturday
07:18:33 <quetzal> is there any good tutorian on function types? like explaining why :t (+) gives a -> a -> a and not a a -> a ?
07:18:38 <quetzal> *tutorial
07:20:02 <kowey> quetzal: maybe try this: http://en.wikibooks.org/wiki/Haskell/Type_basics#Functional_types
07:20:30 <gds> quetzal: good words to google for might be "currying" and "uncurrying"...
07:21:08 <quetzal> oh, thanks. would've never thought of that search keyword
07:34:04 <emertens> Does anyone know how to deal with this error when running ghc 6.4.2 on OpenBSD? Loading package base-1.0 ... linking ... ghc-6.4.2: /usr/local/lib/ghc-6.4.2/HSbase_cbits.o: unknown symbol `__errno'
07:40:15 <zzxxcc> Are there any Haskell programming exercises and their solutions material?
07:43:00 <kowey> @where yaht
07:43:00 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
07:43:09 <kowey> zzxxcc: this might help
07:44:28 <gds> zzxxcc: Maybe not quite what you're asking for, but I quite like this stuff:
07:44:30 <gds> http://haskell.org/haskellwiki/Example_code
07:44:31 <lambdabot> Title: Example code - HaskellWiki
07:44:53 <gds> To turn that into an exercise, read the spec, write your first go, then read the example, I guess...
07:45:32 <gds> What sort of thing do you want to be able to write?
07:45:36 <ndm> @seen dons
07:45:37 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 2 hours, 3 minutes and 51 seconds ago.
07:47:41 <gds> ndm: asleep, I'm afraid.
07:47:52 <emertens> anyone know what causes ghci to break on OpenBSD? (not necessarily ghc)
07:52:54 * edwardk waves ello.
07:53:01 <zzxxcc> 6 The type of the formula foldr1 (.) [f, g, h, k] is
07:53:01 <zzxxcc> a String -> String
07:53:01 <zzxxcc> b the same as the type of f ? correct answer
07:53:01 <zzxxcc> c the same as the type of the composition operator
07:53:01 <zzxxcc> d [a] -> [b]
07:53:01 <zzxxcc> 7 If the type of f is String -> String, then the
07:53:44 <zzxxcc> The answer says choice b is correct. Why?
07:54:22 <edwardk> the list can only hold one type
07:54:37 <norpan> f,g,h, and k have all the same type
07:54:53 <zzxxcc> oh, got it
07:54:55 <jmob> zzxxcc: Look at the type of foldr aswell
07:55:07 <jmob> ?type foldr
07:55:08 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
07:55:27 <norpan> ?type foldr1
07:55:28 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
07:55:36 <norpan> there is your answer :)
07:56:21 * edwardk is jealous i would have liked to have had haskell in class =)
07:57:43 <emertens> do you have split personalities?
07:58:18 <edwardk> yep.
07:58:30 * edwardk used to be schizophrenic, but we're ok now.
07:59:07 * emertens and I and myself know how you two feel
07:59:12 <edwardk> =)
07:59:24 <edwardk> there was meant to be a period in that first statement.
07:59:28 <edwardk> this keyboard sucks ass =)
07:59:41 <emertens> I knew there was, but I was bored.
07:59:44 <emertens> and I still am :)
07:59:46 <edwardk> heh
08:00:09 <edwardk> hp dv8000. the keyboard on it is noticably bad at registering keystrokes.
08:00:14 <emertens> this project takes a good five minutes to build, so any time I have to build it, it's a free IRC break
08:00:40 <edwardk> had i read the reviews before buying one, i probably wouldn't have, but then I buy everything on impulse anyways.
08:00:43 <gaal> hi. where's the actual code for the library described in http://haskell.org/haskellwiki/Library/Compression ?
08:00:45 <lambdabot> Title: Library/Compression - HaskellWiki
08:01:24 <edwardk> ok, what features would you expect out of a type level integer library?
08:01:33 <edwardk> while i'm sitting here i might as well polish it off
08:02:37 <emertens> is it an instance of Ix?
08:02:52 <edwardk> and, or, xor, pow, mul, add, sub, divmod, gcd, even, odd, ispositive, isnegative, iszero, a template haskell constructor, negation, not
08:03:03 <edwardk> can't be i don't think. because every index is a distinct type
08:03:20 <emertens> ah..
08:03:34 <edwardk> unique successors, and showable, is what i have so far or plan
08:04:05 <jgrimes_> edwardk: that sounds pretty interesting, what motivated this?
08:04:11 <edwardk> oh, and i have equality and ordering
08:04:47 <Stinger_> fixed bitlength integers?
08:04:51 <edwardk> i wanted an integer type level thing for dependant types and figured out i could use a 2s complement rep to get negative numbers without losing my ability to have everything unique
08:05:04 <edwardk> stinger: no, infinite (well, up to your context-length)
08:05:20 <Stinger_> how do you manage to do 2s comp then
08:05:20 <edwardk> stinger: can handle about 2^21 with default ghc settings
08:06:13 <edwardk> stinger: http://slipwave.info/jugs/src/Type/Binary.hs    just don't stop transforming. =) i have a tail that represents an infinite tailof 0s or 1s in the MSB position
08:06:33 <edwardk> everything you can do with a infinite positive binary rep can be done with an infinite negative rep by duality
08:06:43 <Stinger_> hmm interesting
08:06:47 <edwardk> negation and successor are defined symmetrically
08:06:55 <edwardk> so succ is reversible
08:07:02 <edwardk> the adder shows remarkable symmetry
08:07:21 * SamB_XP thought edwardk had given up on a symmetrical adder
08:07:25 <edwardk> prepending a zero always means 2n, prepending a 1 means 2n+1, 0 is the fixpoint of the former, -1 is the fixpoint of the latter.
08:07:43 <edwardk> samb: not symmetrical in one respect, but its symmetrical with regards to positive and negative
08:08:05 <edwardk> if you look at it every operation and its dual are included. you can swap letter for letter one to the other
08:08:26 <edwardk> addition with carry can be viewed as addition in the dual representation of the negated bit sequence.
08:08:46 <edwardk> its something i never realized prior to doing this =)
08:09:25 <SamB_XP> I don't understand what you just said ;-)
08:09:29 <edwardk> i'm mostly just looking for whatever polish i can add
08:09:55 <edwardk> well, swap every 1 for a 0 in the number, and addition becomes addition with carry and vice versa.
08:10:44 <edwardk> 0+0=0, well -1+-1+(1 {carry})=-1
08:10:50 <edwardk> the other identities hold
08:11:43 <SamB_XP> what is "the dual representation of the negated bit sequence"?
08:12:07 <edwardk> the dual representation is swapping 0s for 1s and vice versa.
08:12:12 <SamB_XP> ah.
08:12:22 <SamB_XP> so the complement
08:12:36 <edwardk> its a boolean ring, has a natural automorphism
08:12:39 <edwardk> yeah
08:14:04 <edwardk> you know, the only reason i want type level real's now is so i can extend TPow to negative exponents =)
08:14:04 <SamB_XP> @type complement
08:14:06 <lambdabot> forall a. (Bits a) => a -> a
08:15:35 <SamB_XP> > complement 0 :: Integer
08:15:36 <lambdabot>  -1
08:15:59 <SamB_XP> so you didn't know complement x+1 = -x?
08:16:20 <edwardk> no, that one is obvious
08:16:25 <edwardk> coz of the definition =)
08:16:43 * SamB_XP doesn't know the definition
08:16:50 <edwardk> neg x = not x + 1
08:17:08 <edwardk> its how 2s complement is defined
08:18:00 <SamB_XP> okay, so what equation have you discovered? I don't understand your english ;-)
08:18:25 <edwardk> its not an equation so much as if you look at the code for the TAddC full adder
08:18:36 <edwardk> you'll note that every other line is a mirror image of the line above it
08:18:50 <edwardk> the 2nd line is obtained from the duality i mentioned
08:18:51 <SamB_XP> hmm
08:19:39 <SamB_XP> you mean that this holds for many of the binops?:
08:20:03 <edwardk> wel, all of them have some form of duality, all boolean functions do. =)
08:20:40 <edwardk> and <-> or, xor <-> xor, const T <-> const F, etc.
08:21:31 <SamB_XP> p f x y = complement (complement x `f` complement y) == x `f` y -- is that close?
08:22:10 <SamB_XP> you'd apply it to individual binops to get quickCheck properties...
08:22:16 <SamB_XP> er, QuickCheck...
08:22:42 <SamB_XP> btw, did you hear that QuickCheck is illegal?
08:22:55 <roods> i'd like to learn haskell
08:23:19 <roods> that is all i got.
08:24:03 <edwardk> > let p n m = complement((complement n) + (complement m) + 1) == n + m in p (1::Int) 2
08:24:04 <lambdabot>  True
08:24:12 <emertens> SamB_XP: patent violation?
08:24:13 <edwardk> quickcheck that =)
08:24:36 <edwardk> thats the additive version
08:25:15 <edwardk> the other ops come from the more obvious boolean automorphism t<->f and<->or
08:25:46 <jgrimes_> roods: have you been to haskell.org yet? it is a pretty good place to start in my opinion.
08:26:23 <edwardk> how is it illegal
08:26:54 <roods> to be honest i'm just looking to improve my programming. i use c++ at work and started looking at template meta programming then go interested in haskell. i haven't had much time.
08:26:55 <emertens> violates haskell 98?
08:27:05 <jgrimes_> roods: http://haskell.org/haskellwiki/Books_and_tutorials specifically for tutorials, but the rest is good for all kinds of information.
08:27:13 <edwardk> yeah, i kinda came in the same way roods =)
08:27:24 <edwardk> i can't bring myself to do template mp any more though
08:27:35 <edwardk> too much easier in haskell
08:27:49 <lambdabot> Title: Books and tutorials - HaskellWiki
08:28:02 <emertens> lambdabot: is laggin'
08:28:10 <edwardk> well, all except for class associated types
08:28:13 <edwardk> c++ still wins there
08:29:10 <Philippa_> will that be true if/when GHC has ATs with all the usual extensions as well as fundeps?
08:29:52 <edwardk> haskell has no clean way to associate 'type traits' except carrying them around in the class everywhere and all other classes that use that class have to carry the plumbing.
08:30:20 <edwardk> well, simon pj and co wrote a paper on class associated types that supposedly addressed the issue, but it wasn't something they were planning for 6.5 of possibly even 6.6 =/
08:30:33 <edwardk> er or possibly
08:30:42 <Philippa_> 6.6 is just the release version of 6.5, no?
08:30:45 <edwardk> yeah
08:30:49 <edwardk> hence no real new stuff =)
08:31:07 <Philippa_> well yeah, but "even 6.6" stops being relevant :-)
08:31:21 <edwardk> basically the email i saw said that they wouldn't have it done before they cut over to 6.6
08:31:26 <edwardk> thats how i should have said it =P
08:32:15 <roods> edwardk: thanks for the info
08:33:15 <edwardk> ok, mining through Data.Bits for things i could add to the code, a type level testbit, setbit, complementBit, bit and shift are about all that transport over
08:33:25 <edwardk> rotate makes no sense with an infinite bitrep
08:45:11 <kuribas> Is there a good reason to use Hugs instead of Ghci?
08:45:57 <edwardk> starts up faster, not sure thats a good reason though =)
08:46:10 <edwardk> nostalgia, the cuddly name...
08:46:30 <sek> hugs has been around longer. as a sign of respect :D
08:48:23 <kuribas> ghci seems fast enough.  I am thinking to remove it from my system.
08:48:39 <norpan> if you find ghci sufficient, there is no reason to use hugs
08:48:47 <bringert> dons: is this a known warning when building fps on amd64: Compiling Data.ByteString.Lazy.Char8 ( ./Data/ByteString/Lazy/Char8.hs, dist/build/Data/ByteString/Lazy/Char8.o )
08:48:47 <bringert> /tmp/ghc14485.hc: In function ‘sBgU_ret’:
08:48:47 <bringert> /tmp/ghc14485.hc:163: warning: cast to pointer from integer of different size
08:56:09 <SamB_XP> huh
08:56:28 * SamB_XP wonders what function that is really from
08:56:28 <gds> @where+ jvm-bridge http://sourceforge.net/projects/jvm-bridge/
08:56:29 <lambdabot> Done.
08:56:50 * SamB_XP thinks GHC ought to keep track and annotate the gcc warnings accordingly
08:57:09 <bringert> I looked in the hc file, and it didn't help me a whole lot
08:57:16 <SamB> of course not
08:57:53 <SamB> well, you could have tried to find out what function with a name referred to that one...
08:59:56 <bringert> it's not used anywhere in the file
09:00:22 <SamB> heh
09:00:52 <SamB> you could just grep for 'sBgU'.
09:01:13 <bringert> yeah, things with related names are used in what seems to be foldl1
09:01:34 <SamB> that name is not related to anything
09:01:41 <SamB> it is pretty much a serial number...
09:02:39 <bringert> I meant names like sBgU_info
09:02:45 <bringert> i.e. with the same prefix
09:02:51 <SamB> oh, that one *is* related ;-)
09:03:50 <bringert> I can't see anything in foldl1 that uses a pointer as an integer though. sBgU is probably the lambda expression
09:04:01 <bringert> foldl1 :: (Char -> Char -> Char) -> ByteString -> Char
09:04:01 <bringert> foldl1 f ps = w2c (L.foldl1 (\x y -> c2w (f (w2c x) (w2c y))) ps)
09:04:13 <SamB> well, maybe something got inlined...
09:07:00 <bringert> here's the offending generated C:
09:07:07 <bringert> _s54n = R1.p[1];
09:07:07 <bringert> R1.p = (P_)((StgWord32)(_s54n));
09:07:14 <bringert> (the second line)
09:07:21 <SamB> that definately looks bad
09:08:22 <bringert> I'm using ghc 6.4.1, guess I should try at least 6.4.2
09:14:51 <SamB> maybe so
09:15:15 <SamB> that does kinda look like a compiler bug...
09:17:40 <zzxxcc> A. f . g . h. k
09:17:53 <zzxxcc> B. foldr1 (.) [f g h k]
09:18:20 <SamB> zzxxcc: whatcha up to?
09:18:23 <zzxxcc> A and B are not equal, right?
09:18:29 <SamB> well...
09:18:35 <zzxxcc> B is more restrictive
09:19:03 <SamB> it depends on the types of f, g, h, and k.
09:19:09 <SamB> also you forgot the commas in B.
09:19:18 <zzxxcc> In B, f/g/h/k have to be of the same type
09:19:23 <SamB> yes
09:19:35 <zzxxcc> SamB: oh, yes. Thank you to point this out.
09:19:44 <zzxxcc> SamB: oh, yes. Thank you for point this out.
09:20:11 <SamB> s/point/pointing/, while we are correcting your grammar ;-)
09:20:30 <zzxxcc> SamB: Thank you, again. :-D
09:22:39 <wferi> Hi, I've got a :: Maybe (IO b), and would like to execute the IO action (if present) and get an a' :: Maybe b. The manual unwrap-case-return is awkward enough to suggest a better way. Is there a predefined function which could put to work in this case?
09:22:57 <SamB> on the other hand, f . g . h . k might not work if the functions are too polymorphic
09:23:15 <SamB> @type fromIntegral . fromIntegral
09:23:19 <Stinger_> cant you do something like ... no I have no idea :P
09:23:20 <lambdabot> forall b a. (Num b, Integral a) => a -> b
09:23:27 <bringert> wferi: should that be a' :: IO (Maybe b)?
09:23:29 <SamB> huh
09:23:33 <SamB> oh, bad example
09:23:46 <SamB> that is resolved by that icky numeric defaulting
09:24:01 <wferi> bringert: yep.
09:24:05 <SamB> @type read . show
09:24:06 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> a
09:24:11 <int-e> > (fromIntegral . fromIntegral) (2^40 :: Integer) :: Integer
09:24:13 <lambdabot>  1099511627776
09:24:20 <SamB> @type show . read . show . read
09:24:22 <lambdabot> String -> String
09:24:25 <SamB> now...
09:24:27 <SamB> no.
09:24:37 <zzxxcc> SamB: you mean type ambuguous
09:24:39 <int-e> interesting, shouldn't the intermediate result be Int (and 0)?
09:24:52 <SamB> zzxxcc: usually when this happens the compiler complains
09:24:53 <int-e> or is Integer the default?
09:24:54 <Stinger_> how do you generally execute an IO b ?
09:25:01 <SamB> int-e: I don't know!
09:25:14 <wferi> do
09:25:21 <int-e> > (fromIntegral . (id :: Int -> Int) . fromIntegral) (2^40 :: Integer) :: Integer
09:25:22 <lambdabot>  0
09:25:22 <SamB> @google site:haskell.org numeric defaulting
09:25:24 <lambdabot> http://www.haskell.org/pipermail/glasgow-haskell-users/2004-August/007044.html
09:25:24 <lambdabot> Title: overzealous defaulting?
09:25:27 <wferi> :)
09:25:30 <SamB> heh
09:25:52 <bringert> @type (>>= maybe (return Nothing) (return . Just))
09:25:53 <lambdabot> forall a (m :: * -> *). (Monad m) => m (Maybe a) -> m (Maybe a)
09:25:59 <SamB> yes, I blame my failure to get a type error on overzealous defaulting
09:26:02 <bringert> eh
09:26:03 <SamB> okay...
09:26:04 <bringert> sorry
09:26:09 <zzxxcc> SamB: I can understand this. There is a similar problem in overloaded function resolution in C++ world.
09:26:11 <wferi> bringert: not much better...
09:26:36 <SamB> zzxxcc: most of the time though you don't have that
09:26:40 <SamB> say...
09:26:49 <SamB> @type fromIntegral . complement . fromIntegral
09:26:51 <lambdabot> forall b a. (Num b, Integral a) => a -> b
09:26:53 <wferi> bringert: I hoped for something more general.
09:26:55 <SamB> huh huh
09:27:11 <SamB> I thought Bits wasn't defaulted?!?!?
09:27:17 <bringert> wferi: mine was even wrong
09:27:53 <SamB> Hugs chooses this funny, but IMHO more correct, type:
09:27:53 <SamB>     Prelude> :t show . read
09:27:53 <SamB>     show . read :: (Read a, Show a) => [Char] -> [Char]
09:27:54 <SamB> heh
09:27:56 <bringert> wferi:  maybe (return Nothing) (fmap Just)
09:28:05 <SamB> (that is from the mail above)
09:28:10 <SamB> that isn't correct
09:28:11 <bringert> @type maybe (return Nothing) (fmap Just)
09:28:12 <lambdabot> forall (f :: * -> *) a. (Monad f, Functor f) => Maybe (f a) -> f (Maybe a)
09:28:17 <Stinger_> hmm
09:28:36 <bringert> eh, change fmap to liftM to make it prettier
09:28:38 <wferi> bringert: getting closer
09:28:52 <SamB> @type freeze >>= thaw
09:28:53 <lambdabot> Not in scope: `freeze'
09:28:54 <lambdabot>  
09:28:54 <lambdabot> <interactive>:1:11: Not in scope: `thaw'
09:28:56 <bringert> @type maybe (return Nothing) (liftM Just)
09:28:56 <SamB> aww
09:28:57 <lambdabot> forall (m :: * -> *) a1. (Monad m) => Maybe (m a1) -> m (Maybe a1)
09:29:03 <SamB> @hoogle freeze
09:29:04 <lambdabot> Data.Array.MArray.freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
09:29:04 <lambdabot> Data.Array.MArray.unsafeFreeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
09:29:11 <wferi> bringert: you did it!
09:29:15 <bringert> wferi: have you seen fmapM?
09:29:21 <bringert> @type fmapM
09:29:22 <lambdabot> Not in scope: `fmapM'
09:29:25 <SamB> @type Data.Array.MArray.freeze >>= Data.Array.MArray.thaw
09:29:27 <lambdabot> forall (a :: * -> * -> *) i e (b :: * -> * -> *) (a1 :: * -> * -> *) i1 (b1 :: * -> * -> *). (Data.Array.Base.IArray b e, Data.Array.Base.MArray a e (a1 i1), Ix i, Data.Array.Base.MArray b1 (b i e) (
09:29:27 <lambdabot> (->) (a i e)), Data.Array.Base.IArray a1 (b i e), Ix i1) => a i e -> b1 i1 (b i e)
09:29:30 <wferi> :( neither did I
09:29:36 <bringert> @type Data.FunctorM.fmapM
09:29:38 <lambdabot> forall (f :: * -> *) b (m :: * -> *) a. (Data.FunctorM.FunctorM f, Monad m) => (a -> m b) -> f a -> m (f b)
09:30:37 <SamB> @type Data.Array.MArray.thaw >>= Data.Array.MArray.freeze
09:30:38 <lambdabot> forall (a :: * -> * -> *) i e (b :: * -> * -> *) (a1 :: * -> * -> *) i1 (b1 :: * -> * -> *). (Data.Array.Base.MArray b e (a1 i1), Data.Array.Base.IArray a e, Ix i, Data.Array.Base.IArray b1 (b i e),
09:30:38 <lambdabot> Data.Array.Base.MArray a1 (b i e) ((->) (a i e)), Ix i1) => a i e -> b1 i1 (b i e)
09:30:41 <SamB> what?
09:30:49 * SamB is suspicious
09:30:54 <edwardk> woot
09:30:55 <edwardk> *Type.Binary.TH> fromTBinary $ tShift $(binaryE 256) $ tNeg $(binaryE 4)
09:30:55 <edwardk> 16
09:30:57 * SamB really should have got a type error by now
09:30:59 <edwardk> got shifting working =)
09:31:01 <wferi> @type Data.FunctorM.fmapM return
09:31:02 <lambdabot> forall (f :: * -> *) (m :: * -> *) a. (Data.FunctorM.FunctorM f, Monad m) => f a -> m (f a)
09:31:21 <bringert> @type fmapM id
09:31:23 <lambdabot> Not in scope: `fmapM'
09:31:27 <ski> @type Data.FunctorM.fmapM id
09:31:29 <lambdabot> forall (f :: * -> *) (m :: * -> *) b. (Data.FunctorM.FunctorM f, Monad m) => f (m b) -> m (f b)
09:31:38 <SamB> zzxxcc: okay, I apparantly can't demonstrate the problem with lambdabot
09:31:48 <wferi> could be
09:31:49 <SamB> but I assure you there is supposed to be a problem
09:32:01 <SamB> there must be something wrong with lambdabot :-(
09:32:21 <wferi> I'll put this into code.
09:34:47 <wferi> it works, guys! Thanks.
09:35:27 <wilx`> Hmm, I wonder if there is a good presentation about Haskell for C/Java programmers.
09:36:08 <SamB> well, for java programmers, you could ask them if they've ever been frustrated about having to create a class just to hold a single method
09:36:46 <SamB> and that every piece of software that uses this technique uses a different name for the method, even if it has the same type
09:36:57 <wilx`> Hm.
09:46:35 <nealc> @where logs
09:46:36 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
10:04:04 <vegai> there's one thing that amazes me very much about pass.net
10:04:15 <vegai> that the domain was available.
10:07:23 <fig> Hi, all... if you love languages, please check out http://lambda-the-ultimate.org/node/1654.
10:07:24 <lambdabot> Title: Convergence | Lambda the Ultimate
10:08:51 <nealc> fig, why "convergence"?
10:09:59 <norpan> unify all programming languages? you jest
10:10:04 <fig> Because completing TUNES will mean that the features of every programming language will be accomodated.
10:10:33 <fig> TUNES is not mine, it's the product of some brilliant minds who understand category theory.
10:10:40 <norpan> what if programming languages have incompatible features
10:11:03 <fig> Ignore the ones that suck.
10:11:04 <nealc> @what tunes
10:11:04 <lambdabot> I know nothing about tunes.
10:11:18 <norpan> ah
10:11:19 <fig> www.tunes.org
10:11:23 <norpan> good luck then :)
10:11:29 <fig> They host the chat logs for this channel.
10:12:04 <fig> norpan: Thanks. :)
10:12:20 <norpan> i think i misunderstood the word unify here
10:12:21 <fig> I can't write the software, but I sure as heck know how to manage a project.
10:12:57 <fig> What's your new understanding?
10:13:04 <norpan> it's just project trying to build a full system from programming language to hardware
10:13:20 <norpan> then it's just very hard
10:13:23 <fig> Right.  And Arrow is the user interface, but still a programming language.
10:13:39 <fig> All the design is in place and has been reviewed for years.
10:13:53 <nealc> @what imnsho
10:13:53 <lambdabot> I know nothing about imnsho.
10:13:59 <fig> It's just a matter of putting together the pieces, and that's what my announcement is on.
10:14:08 <fig> imensho.
10:14:24 <nealc> fig, what is it?
10:14:33 <fig> What is what?
10:14:39 <norpan> so it's really not about unifying programming languages at all, yet that's the first sentence of the announcement
10:15:05 <fig> Well, you have to start with some kind of opening statement, and yes, it's about unification.
10:15:27 <fig> (On the Programming Languages Weblog, nonetheless.)
10:15:55 <nealc> @google define:imnsho
10:15:56 <lambdabot> No Result Found.
10:16:02 <fig> If people can get past the first line, hit the word "reasonable" and do the homework, I will have done my job.
10:16:05 <norpan> maybe the computing system uses unification, but that's a different matter :)
10:16:09 <nealc> @google acron imnsho
10:16:10 <fig> Heh.
10:16:12 <lambdabot> http://www.thefiringline.com/library/acro/acron.html
10:16:12 <lambdabot> Title: ==License/Permit Abbreviations==
10:16:48 <fig> nealc: what is what?  IMNSHO is In My Not So Humble Opinion.
10:17:21 <nealc> fig, thanks. How can I teach it to Lambdabot?
10:17:33 <fig> I don't know Lambdabot's interface.
10:17:47 <nealc> @help @what
10:17:47 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:18:32 <nealc> @help learn
10:18:47 <nealc> @help @learn
10:19:08 <fig> @help list
10:19:22 <lambdabot> learn. The learning page url
10:19:26 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:19:30 <lambdabot> list [module|command]
10:19:32 <lambdabot> show all commands or command for [module]
10:22:03 <nealc> @dict imnsho
10:22:03 <lambdabot> Supported dictionary-lookup commands:
10:22:03 <lambdabot>  @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @jargon @lojban @vera @web1913 @wn @world02
10:22:03 <lambdabot> Use "@dict-help [cmd...]" for more.
10:22:12 <nealc> @all-dict imnsho
10:22:14 <lambdabot> *** "imnsho" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
10:22:15 <lambdabot> IMNSHO
10:22:15 <lambdabot>    In My Not So Humble / Honest Opinion (telecommunication-slang, Usenet,
10:22:15 <lambdabot>    IRC)
10:22:15 <lambdabot>  
10:22:16 <lambdabot> [5 @more lines]
10:22:27 <nealc> lambdabot, you rules.
10:22:46 <norpan> lambdabot has their act together
10:23:01 <madpickle> @jargon 1337
10:23:02 <lambdabot> No match for "1337".
10:23:06 <madpickle> @jargon BOFH
10:23:08 <lambdabot> *** "BOFH" jargon "Jargon File (4.3.1, 29 Jun 2001)"
10:23:08 <lambdabot> BOFH // n. [common] Acronym, Bastard Operator From Hell. A system
10:23:08 <lambdabot>   administrator with absolutely no tolerance for {luser}s. "You say you
10:23:08 <lambdabot>   need more filespace? <massive-global-delete> Seems to me you have plenty
10:23:08 <lambdabot>   left..." Many BOFHs (and others who would be BOFHs if they could get
10:23:10 <lambdabot> [9 @more lines]
10:23:13 <ski> hm, there's 'where' and 'where+' commands, but only 'what' and no 'what+' it seems
10:23:30 <nealc> @jargon luser
10:23:31 <lambdabot> *** "luser" jargon "Jargon File (4.3.1, 29 Jun 2001)"
10:23:31 <lambdabot> luser /loo'zr/ n. [common] A {user}; esp. one who is also a {loser}.
10:23:31 <lambdabot>   ({luser} and {loser} are pronounced identically.) This word was coined
10:23:31 <lambdabot>   around 1975 at MIT. Under ITS, when you first walked up to a terminal at
10:23:31 <lambdabot>   MIT and typed Control-Z to get the computer's attention, it printed out
10:23:33 <lambdabot> [16 @more lines]
10:23:41 <norpan> please
10:23:45 <nealc> 1975!
10:24:04 <nealc> @more
10:24:05 <lambdabot>   some status information, including how many people were already using
10:24:05 <lambdabot>   the computer; it might print "14 users", for example. Someone thought it
10:24:05 <lambdabot>   would be a great joke to patch the system to print "14 losers" instead.
10:24:05 <lambdabot>   There ensued a great controversy, as some of the users didn't
10:24:05 <lambdabot>   particularly want to be called losers to their faces every time they
10:24:07 <lambdabot> [11 @more lines]
10:24:23 <norpan> quit flooding already
10:44:31 <erider> hola araujo como te vaj?
10:52:01 <zarvok> @where lambdabot
10:52:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
11:03:08 <vegai> HAppS doesn't have a dedicated channel, I suppose?
11:03:24 <vegai> nor really any other kind of community to speak of?
11:03:26 <yip> what are you doing with happs?
11:03:38 <vegai> evaluating it
11:03:51 <vegai> for some hazy commercial schemes
11:07:34 <sm> vegai: I don't think so
11:07:43 <sm> I also tried it
11:08:19 <vegai> How did you like it?
11:08:47 <sm> quite a lot.. there is a known hanging problem when you run it compiled and threaded, though
11:08:59 <sm> wait, a mailing list was set up recently
11:09:22 <vegai> oh, right.
11:11:04 <SamB> ooh, heh, no wonder my balance brute-forcer doesn't work...
11:11:13 <SamB> I forgot to increment the PC...
11:11:33 <SamB> or maybe I just forgot to set IS to 1 to start with
11:11:35 <Buzzons> if i were to do this.. lookup "coffee" [("coffee",10),("soap",50),("bread",5)] .. it returns Just 10 .. now is there a way to take the "just 10" and split it so i have the Int on its own
11:11:45 <SamB> ah, yeah, thats the problem
11:12:06 <vegai> Seems like HAppS is not very happy with fps-0.6
11:12:41 <emertens> Buzzons: you might want "maybe" or "fromJust"
11:13:07 <emertens> > maybe "Not Found" id (lookup "coffee" [("coffee
11:13:07 <lambdabot>  Improperly terminated string
11:13:13 <emertens> > maybe "Not Found" id (lookup "coffee" [("coffee",1)])
11:13:13 <lambdabot>  add an instance declaration for (Num [Char])
11:13:14 <lambdabot>   In the list element: ("cof...
11:13:32 <emertens> > maybe 0 id (lookup "coffee" [("coffee",1)])
11:13:33 <lambdabot>  1
11:13:38 <emertens> > maybe 0 id (lookup "coffee2" [("coffee",1)])
11:13:39 <lambdabot>  0
11:13:43 <swiert> fromJust really should have been called unJust.
11:13:44 <lambdabot> swiert: You have 1 new message. '/msg lambdabot @messages' to read it.
11:14:48 <emertens> lookupWithDefault def key assoc = maybe def id (lookup key assoc)
11:16:09 <Buzzons> s'not working
11:16:28 <emertens> You'll have to be much more clear than that
11:16:32 <Buzzons> :p
11:16:37 <Buzzons> ill go poke things
11:17:07 <Buzzons> ok i typed brackets badly  :) thanks
11:19:42 <vegai> hmm, I now tried fps-0.4, 0.5, 0.6 and HAppS builds out-of-the-box with none of them
11:20:02 <edwardk> sweirt: noticed that myself =)
11:20:33 <ski> > case lookup "coffee" [("coffee",10),("soap",50),("bread",5)] of Nothing -> "sorry"; Just n -> "it's" ++ show n
11:20:34 <lambdabot>  "it's10"
11:23:18 <zarvok> vegai: isn't the latest version 0.7?
11:24:41 <vegai> zarvok: ah, I'll try the darcs latest then, too. 0.7 hasn't been tarballed yet
11:25:05 <zarvok> yeah, I think it's only in the darcs repo
12:24:12 <gour> @where paste
12:24:13 <lambdabot> http://paste.lisp.org/new/haskell
12:24:52 <lisppaste2> gour pasted "jhc build error" at http://paste.lisp.org/display/23608
12:25:31 <gour> JohnMeacham: here ^^^ is the error I get in building jhc
12:44:47 <Buzzons> Hugs> :t isUpper
12:44:47 <Buzzons> ERROR - Undefined variable "isUpper"
12:44:49 <Buzzons> why???
12:44:50 <Buzzons> why???
12:44:56 <Buzzons> Hugs> :t isUpper
12:44:56 <Buzzons> ERROR - Undefined variable "isUpper"
12:45:00 <Buzzons> oops
12:45:10 <Buzzons> Hugs.Prelude.isUpper shows under :n is*
12:45:12 <Buzzons> so its loaded
12:45:38 <araujo> hola erider :-)
12:45:58 <SamB> hmm, what is a good way to hexdump an array...
12:46:10 <Buzzons> whats a good way to unbreak hugs! :p
12:46:16 <Buzzons> my question owns yours :p
12:46:46 <SamB> :m Prelude?
12:47:02 <Buzzons> Hugs> :m Prelude
12:47:02 <Buzzons> Prelude>
12:47:04 <Buzzons> then what?
12:47:10 <benja_> Buzzons: you're using haskell 98?
12:47:12 <benja_> it's in Char
12:47:19 <Buzzons> yea
12:47:23 <Buzzons> i have to, for my course
12:47:27 <Buzzons> its outdated and poo
12:47:33 <benja_> Buzzons: just import Char
12:48:19 <benja_> Hugs moved it into the Prelude because it didn't support recursive modules
12:48:31 <Buzzons> thanks :)
12:48:48 <benja_> welcome. I figured it out a couple of days ago when I had the same problem ;-)
12:51:17 <emertens> recursive modules?
12:51:43 <benja_> emertens: modules importing each other
12:52:04 <benja_> I probably didn't use the right word
12:52:16 <benja_> "mutually dependent" perhaps?
12:53:09 <emertens> is there a circular dependancy?
12:53:28 <benja_> 'pparently
12:53:42 <benja_> I'll see whether I can google my source
12:54:03 <benja_> http://cvs.haskell.org/Hugs/pages/hugsman/diffs.html
12:54:11 <benja_> "mutually recursive" is the word =)
12:56:08 <emertens> The Double type is implemented as a single precision float (this isn't forbidden by the standard but it is unusual). X-|
12:59:33 <SamB> @hoogle (a,b) -> (b,a)
12:59:34 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
12:59:50 <SamB> @djinn (a,b) -> (b,a)
12:59:51 <lambdabot> f (a, b) = (b, a)
13:00:01 <SamB> @pl f (a, b) = (b, a)
13:00:01 <lambdabot> f = uncurry (flip (,))
13:04:13 <monochrom> Usually you need no function for (a,b)->(b,a).
13:04:33 <SamB> you think?
13:04:37 <monochrom> I think.
13:04:56 <SamB> well, who cares about usually?
13:05:06 <SamB> sometimes you want one...
13:05:20 <monochrom> usually you care about usually
13:05:47 <monochrom> sorry for all sorts of tautologies :)
13:13:10 <emertens> @pl \x y z -> z y x
13:13:10 <lambdabot> flip (flip . flip id)
13:15:57 <emertens> @pl \w x y z -> z y x w
13:15:58 <lambdabot> flip (flip . (flip .) . flip (flip . flip id))
13:16:31 <emertens> @pl \w x y z -> z z z z
13:16:32 <lambdabot> const (const (const (join (join (join id)))))
13:19:26 <jgrimes_> how would one get a partial result (not complete, because it is infinite) of a function using fix?
13:19:55 <SamB> try iterate instead?
13:20:14 <SamB> or just trim the result
13:20:21 <SamB> @type fix
13:20:22 <lambdabot> forall a. (a -> a) -> a
13:20:26 <emertens> jgrimes_: what are you trying to do?
13:20:39 <jgrimes_> emertens: sqrt function using fixed point
13:20:47 <SamB> > take 10 (fix ("hi" ++))
13:20:48 <lambdabot>  "hihihihihi"
13:21:20 * SamB doesn't know if fix is a good way to do sqrt
13:21:20 <emertens> jgrimes_: specifically as an exersice to play with fix?
13:21:27 <Cale> > fix (\f n -> if n == 0 then 1 else n * f (n-1)) 5
13:21:28 <lambdabot>  120
13:21:54 <jgrimes_> emertens: yeah, just playing around with fix. I've read some about it and now I'm trying it out for different things
13:22:06 <Cale> You can compute approximations to sqrt using Newton's method
13:22:10 <emertens> the cleaner sqrt solutions that I've seen involve defining an infinite sequence of closer approximations, and then traveling down the list
13:22:19 <emertens> until the error is within some limit
13:22:34 <Cale> yeah
13:22:37 <SamB> which is extremely easy in Haskell
13:22:57 <Cale> You can use iterate
13:23:18 <SamB> you can really just search along an infinite list ;-)
13:23:56 <emertens> the more interesting uses of fix, in my opinion, are were it's used for circular programming, and not simply anonymous recursion
13:23:57 <jgrimes_> yeah, just made a version using iterate as per SamB's suggestion
13:24:59 <jgrimes_> I had already defined my own fix point function that only computes to a certain precision
13:25:19 <jgrimes_> I was just going to see if there was some way to use the built-in fix to do the same
13:25:31 <monochrom> Don't use fix for numerical methods.
13:26:18 <emertens> What is the "least fixed point" of a function?
13:26:25 <emertens> I've heard the term, I don't know waht it means
13:26:37 <monochrom> Ok, there is a way, but you will see from it that "fix" is beside the point.
13:26:41 <benja_> emertens: depends on what it's a function of :)
13:27:01 <benja_> the least fixed point of (\x -> x*2) is 0
13:27:45 <emertens> because it's the smallest value whose input == its output?
13:27:50 <benja_> yes
13:28:15 <benja_> x is a fixed point of f if (f x) equals x
13:28:49 <benja_> the least fixed point is the least of these, according to some order on the argument type, and you're supposed to know which order is meant
13:29:42 <benja_> in the mathematical theory, the arguments and results are often sets
13:30:01 <benja_> where you use 'is subset of' as a partial order
13:30:40 <emertens> so... you want the smallest input set
13:30:43 <emertens> in that case?
13:31:02 <emertens> such that f "set" = "set"
13:31:02 <emertens> ?
13:31:13 <Cale> In this case "least" is using a different ordering than you might expect
13:31:23 <Cale> It's "least" as in "least defined"
13:31:33 <emertens> so the largest set?
13:31:43 <benja_> the smallest set is right
13:31:51 <benja_> but the idea is, think of a function as a set of pairs
13:32:13 <benja_> i.e. {(1,2), (3,4)} is a function which maps 1 to 2 and 3 to 4
13:32:18 <benja_> and is undefined for 7, say
13:32:48 <benja_> then {(1,2), (3,4)} is "less defined" than {(1,2), (3,4), (7,9)}
13:32:48 <Cale> Examples with numbers aren't particularly enlightening here
13:32:56 <Cale> oh, I see what you're doing :)
13:32:58 <Cale> okay
13:33:05 <benja_> :)
13:33:10 <emertens> ok, that makes sense enough
13:33:44 <benja_> the "least fixed point" is interesting when you do induction:
13:33:54 <Cale> http://cale.yi.org/autoshare/%5bBool%5d.png
13:34:08 <Cale> there's a picture of part of the type [Bool] ordered by definedness
13:34:25 <benja_> say we have the definition "f 0 = 0; f (x+1) = f x + 2"
13:34:50 <benja_> the "f (x+1) = f x + 2" can be seen as a function on pairs:
13:35:04 <benja_> on sets, sorry
13:35:54 <benja_> g set = set `union` {(x+1,y+2) | (x,y) `in` set}
13:35:57 <emertens> Cale: so if   f bottom = bottom, then that would be the least fixed point?
13:36:52 <Cale> Let me think about that... yes.
13:36:56 <benja_> or perhaps (g set = {(0, 0)} `union` {(x+1,y+2) | (x,y) `in` set}) is what you're interested in
13:37:08 <monochrom> iterate f x = x : iterate f (f x).  This is equivalent to: iterate f x = fix (\g x -> x : g (f x)) x.  That is about the closest association between fix and numerical approximation.
13:37:11 <benja_> now, 'f' is the least fixed point of g
13:37:59 <benja_> emertens: yes, if (f bottom = bottom), then bottom is the least fixed point
13:38:01 <monochrom> In fact the only association is: fix is recursion, numerical approximation uses recursion.  Well all programs use recursion.
13:38:39 <Cale> emertens: This is roughly the same as not taking care of the base cases.
13:38:56 <Cale> In a recursive definition
13:39:00 <monochrom> But least fixed point theory is fun!
13:39:34 <monochrom> If f bottom = bottom, then the least fixed point is bottom.
13:39:42 <emertens> Cale: so in a factorial, the least fixed point is 1 (which is possible because 1 is the stopping case)
13:39:52 <emertens> and because fac 1 = 1
13:40:17 <Cale> > fix (\f n -> if n == 0 then 1 else n * f (n-1)) 7
13:40:18 <lambdabot>  5040
13:40:30 <Cale> That's how you compute factorial using a fixed point
13:40:34 <emertens> right
13:40:40 <emertens> I was here about a year ago
13:40:43 <emertens> reading SoE
13:40:49 <emertens> and they brought up the fix operator
13:40:49 <monochrom> Note.  In applying fixed point theory to recursion, you construction the least fixed point of a higher-order function, like the (\f -> \n -> ...) Cale just showed.
13:40:52 <Cale> Note that \f n -> if n == 0 then 1 else n * f (n-1) is not bottom when you pass it bottom
13:40:53 <emertens> and you walked me through it
13:41:23 <benja_> NB that the fixed point is of a function transformer
13:41:27 <Cale> It's a function which is defined for n = 0
13:41:28 <benja_> not of the factorial function itself
13:41:34 <Cale> and gives 1
13:41:49 <emertens> wait, why is fac bottom /= bottom
13:41:51 <Cale> (and is undefined elsewhere)
13:41:59 <Cale> Oh, fac bottom = bottom
13:41:59 <benja_> emertens: fac bottom is bottom
13:42:11 <benja_> this does NOT apply fix to 'fac'
13:42:11 <Cale> but the function we're passing to fix is not fac
13:42:20 <monochrom> Yeah, start with bottom, then the first iterate is a function defined at 0 but undefined elsewhere.  Subsequent iterates are more well-defined functions, larger and larger domains.
13:42:24 <emertens> ok
13:42:30 <Cale> fac = fix q
13:42:37 <Cale>   where q = \f n -> if n == 0 then 1 else n * f (n-1)
13:42:55 <Cale> q bottom /= bottom
13:43:04 <emertens> because it's actually a function?
13:43:15 <benja_> q bottom = \f n -> if n == 0 then 1 else n * bottom (n-1)
13:43:16 <Cale> It's a not-completely-undefined function
13:43:18 <benja_> sorry
13:43:22 <benja_> q bottom = \n -> if n == 0 then 1 else n * bottom (n-1)
13:43:41 <Cale> so, q bottom = \n -> if n == 0 then 1 else bottom
13:43:48 <Cale> since * is strict
13:43:52 <emertens> can a function that takes two arguments and returns one result have a least fixed opint?
13:43:59 <benja_> Cale: y
13:44:05 <benja_> emertens: no
13:44:12 <emertens> didn't think so
13:44:13 <emertens> ok
13:44:15 <benja_> it has to have type (a -> a) for some a
13:44:23 <monochrom> Recall fix :: (a->a) -> a.  If you want fix q = fac :: Int->Int, you are saying a = (Int->Int).  Thus q :: (Int->Int) -> (Int->Int).
13:44:57 <Cale> So in some sense, it's taking two arguments, and returning one result :)
13:45:12 <monochrom> fac is a fixed point of a functional.
13:45:21 <Cale> It's taking a function and an Integer and returning an Integer
13:45:38 <Cale> but that's not a terribly lucid way to think of it here
13:45:39 <benja_> Cale: heh, true
13:45:43 <emertens> :)
13:46:06 <benja_> emertens: if you think of functions as sets, bottom is {}
13:46:10 <monochrom> This takes a while to digest.  This is because you didn't learn it from highschool.  Oh wimpy highschool, no higher-order functionals, ...
13:46:20 <benja_> q bottom = {(0, 1)}
13:46:34 <emertens> that makes sense
13:46:44 <benja_> q (q bottom) = {(0, 1), (1, 1)}
13:47:01 <monochrom> You see, even I took a while to write down the fix formulation for iterate...
13:47:03 <SyntaxNinja> xerox: y0
13:47:19 <benja_> q (q (q (q bottom))) = {(0, 1), (1, 1), (2, 2), (3, 6)}
13:47:30 <benja_> now (fix q) gives you the whole infinite thing
13:47:42 <emertens> yeah, that seems clear
13:47:53 <benja_> :)
13:48:07 <monochrom> #haskell clears up all the scary math.
13:48:10 <benja_> =)
13:49:11 <monochrom> I don't recommend writing recursive functions in terms of fix.
13:50:07 <Cale> "functional" is sort of an odd term. I usually think of linear functionals when I hear it, though the original meaning is indeed how you used it.
13:50:16 <musasabi> vegai: fps changed APIs very quickly.
13:50:29 <monochrom> I'm an old-style guy.
13:50:44 <Cale> I usually wouldn't use any special term to refer to functions which take functions as parameters.
13:50:56 <musasabi> vegai: I think it worked fine with what happened to be fps 0.5.
13:51:05 <monochrom> I did it to scare. :)
13:51:12 <Cale> I suppose higher-order is fine, when you have to make the distinction
13:51:32 <musasabi> dons / dcoutts: what is the status of the fps API? How stable is it?
13:51:51 <musasabi> Lemmih: you had a patch and an UNDO path for fps API changes in the fps repo?
13:52:48 <monochrom> I acquired an old book from a century ago.  The author was Hamilton.  The Hamilton.
13:54:30 <vincenz> @join #oasis
13:54:31 * benja_ doesn't recommend writing programs in continuation-passing style
13:54:48 <benja_> which I needed to do in my toy programming language until today, when I got a version of 'do' implemented :)
13:54:50 <monochrom> I have also read a bit of lambda calculus from an old book in the library.  So old, the book had no Library of Congress call number, the library put it in the "legacy" section.
13:54:59 <monochrom> The author was Alonzo Church.
13:55:14 <zarvok> benja_: why not? cps is hot
13:55:31 <benja_> (that being in response to < monochrom> I don't recommend writing recursive functions in terms of fix.)
13:55:45 <benja_> zarvok: it's annoying =)
13:55:51 <zarvok> heh
13:55:53 <benja_> 'do'-style is so much more readable
13:56:26 <zarvok> I sometimes TA a course in programming languages.  The CPS assignment is always the students' least favorite
13:56:27 <benja_> ok, I also don't have 'let' or 'where' and didn't have lambda, so all the auxiliary functions had to be top-level
13:56:44 <benja_> that made it even more annoying than it would otherwise have had to be
13:56:59 <mahogny> zarvok, hey, I loved it. it's just that I wanted to commit suicide in the process :)
13:57:05 <monochrom> When you reason about a recursive function you've written, you'd like to use structural induction.  To do that, you have to decode your fix formulation into the ordinary case split anyway.
13:57:25 <benja_> (my 'do' *outputs* continuation-passing style, I just don't want to write it =))
13:57:34 <zarvok> mahogny: heh, what did they make you do with continuations?
13:57:46 <zarvok> mahogny: we almost always do some sort of game tree search
13:57:49 <mahogny> zarvok, faked threads for a webserver, and the webserver
13:58:40 <mahogny> zarvok, and then I got taste for it and chose to make a scripting language and an rpg engine for the last assignment ^_^
13:58:42 <zarvok> mahogny: heh.  Are you talking about first class continuations or cps, though?  I most often see concurrency discussed in relation to first class continuations, though I imagine it could be done either way
13:59:10 <mahogny> zarvok, a bit lost there, what is the difference?
13:59:30 <benja_> ah, more scary stuff for #haskell to clear up :)
13:59:46 <benja_> in CPS, the continuation is one of the arguments to a function
13:59:57 <monochrom> Yes that's right.
14:00:11 <zarvok> mahogny: well, did you use callcc or something equivalent, or pass around a contunuation as a function argument?
14:00:18 <monochrom> But that's the end of what I know about CPS.
14:00:55 * benja_ thinks CPS is an illuminating way of thinking about referentially transparent IO
14:00:56 <monochrom> Oh, I think I also know that when you do "callcc f", f has to take a continuation as an argument.
14:00:56 <zarvok> also, what language, out of curiosity?
14:00:57 <mahogny> zarvok, well. no callcc. passed around it as a function argument
14:01:01 <mahogny> zarvok, haskell
14:01:05 <zarvok> mahogny: yeah, that's cps
14:01:11 <benja_> yup
14:01:15 <zarvok> neat
14:01:17 <mahogny> zarvok, it was the advanced course on functional programming here at chalmers
14:01:28 <zarvok> here at CMU our PL courses are in SML
14:01:40 <mahogny> never tried it
14:02:02 <zarvok> cps is prettier in a call-by-name language, since you don't have to explicitly delay all the functions
14:02:31 <benja_> zarvok: are you subsuming lazy under call-by-name?
14:02:36 <zarvok> err
14:02:38 <zarvok> a mistake
14:02:43 <zarvok> of course
14:02:59 <zarvok> though the two generally go together
14:03:17 <benja_> I thought call-by-name meant that the argument can be evaluated multiple times
14:03:18 <zarvok> (which is easy to say, since there are so few commonly used functional languages :) )
14:03:28 <benja_> but I'm confused about whether it means that, frankly :)
14:03:32 <zarvok> no, in call-by-name, the argument is evaluated once
14:03:42 <zarvok> at most once
14:03:44 <zarvok> rather
14:03:56 <benja_> so what's the difference between call-by-name and lazy?
14:04:02 <zarvok> I'm not sure
14:04:04 <zarvok> that there is one
14:04:08 <benja_> =)
14:04:12 <Cale> > let getCC = callCC (return . fix) in (`evalState` 1) . (`runContT` return) $ do loop <- getCC; n <- get; if n > 10 then return n else do put (n+1); loop
14:04:13 <lambdabot>  11
14:04:20 <benja_> so does call-by-substitution have a real name? =)
14:04:22 <zarvok> but I find the best strategy when questioned is to immediately backtrack :)
14:04:33 <benja_> zarvok: =-]
14:04:58 <zarvok> ah, well, OK
14:05:00 <zarvok> this time I did mess up
14:05:03 <zarvok> haskell is call-by-need
14:05:05 <JohnMeacham> gour: ah, upgrade your DrIFT
14:05:10 <zarvok> call by name is the direct substitution
14:05:17 <benja_> yeah, that sounds right :-)
14:05:18 <benja_> thanks
14:05:34 <zarvok> I need to learn to pay more attention when I talk on IRC
14:05:51 <Cale> > let getCC = callCC (return . fix) in (`evalState` (1,[])) . (`runContT` return) $ do loop <- getCC; (n,xs) <- get; if n > 10 then return xs else do put (n+1,n:xs); loop
14:05:52 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
14:06:38 <Cale> Who says Haskell doesn't have goto? :)
14:06:46 <zarvok> heh
14:06:49 <benja_> =)
14:07:22 <zarvok> well, after all, isn't Lambda the ultimate GOTO?
14:07:30 <zarvok> :)
14:07:43 <monochrom> also the ultimate programming language
14:08:12 <Cale> http://lambda-the-ultimate.org/
14:08:13 <lambdabot> Title: Lambda the Ultimate | Programming Languages Weblog
14:08:20 <emertens> i thought that was "unlambda" ;)
14:08:29 <emertens> (ultimate programming language)
14:08:58 <zarvok> I remember the day I first got that joke
14:09:05 <zarvok> lambda-the-ultimate.org I mean
14:09:21 <zarvok> Suddenly I realized why the site was called this, and felt very dumb for days
14:09:26 <emertens> why do people at work that speak in foreign languages think that I need to be able to hear their phone conversations from 6 cubes away?
14:10:12 <mahogny> emertens, so you can learn the language too?
14:10:19 <monochrom> Why was the site called this?  I don't get it.
14:10:21 <emertens> aparently
14:10:39 <zarvok> monochrome: the lambda papers
14:10:40 <zarvok> http://library.readscheme.org/page1.html
14:10:41 <lambdabot> Title: The Original 'Lambda Papers' by Guy Steele and Gerald Sussman
14:11:05 <zarvok> the papers are subtitled things like "lambda: the ultimate declarative" and "lambda: the ultimate goto"
14:11:10 <zarvok> they talk about the implementation of scheme
14:11:17 <benja_> "Was schreit Herr Maier denn so rum?" -- "Oh, der spricht gerade mit Amerika." -- "Kann er dazu nicht das Telefon benutzen?"
14:11:33 <emertens> @help babel
14:11:41 <emertens> @modules
14:11:44 <lambdabot> babel <lang1> <lang2> <phrase>.
14:11:46 <lambdabot> Translate a phrase in lang1 to lang2.
14:11:48 <lambdabot> Language is an element of"german","de" "greek","el" "english","en" "spanish","es" "french","fr" "italian","it" "dutch","nl" "portuguese","pt"
14:11:51 <lambdabot> Unknown command, try @list
14:11:59 <emertens> @babel german english  "Was schreit Herr Maier denn so rum?" -- "Oh, der spricht
14:12:01 <lambdabot>  "which walk Mr. Maier so rum?" -- "Oh, which speaks
14:12:01 <benja_> ("Does Smith *have* to shout like that?" -- "Oh, he's talking to America." -- "Can't he use the telephone?")
14:12:02 <emertens>                 gerade mit Amerika." -- "Kann er dazu nicht das Telefon
14:12:05 <emertens>                 benutzen?"
14:12:13 <emertens> ah
14:12:22 <benja_> it seemed appropriate =)
14:13:06 <monochrom> Haha I see
14:19:00 <Cale> > let getCC = callCC (return . fix) in runCont (join getCC) id
14:19:01 <lambdabot>  Add a type signature
14:19:22 <Cale> > let getCC :: (MonadCont m) => m (m a); getCC = callCC (return . fix) in runCont (join getCC) id
14:19:22 <lambdabot>  Add a type signature
14:19:48 <Cale> > let getCC :: (MonadCont m) => m (m a); getCC = callCC (return . fix) in runCont (join getCC) id :: Integer
14:19:49 <lambdabot>  Exception: <<loop>>
14:19:53 <Cale> :)
14:20:17 <monochrom> Cale you're tempting me to learn the Cont monad.  As such, I'll yield to it!
14:24:01 <Cale> > let getCC = callCC (return . fix) in (`runCont` id) . (`evalStateT` (1,[])) $ do loop <- getCC; (n,xs) <- get; if n > 10 then return xs else do put (n+1,n:xs); loop
14:24:02 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
14:24:12 <Cale> It appears that they commute to some extent
14:25:18 <Cale> hmm, I would have figured at least one of the ways would let you jump back while resetting the state to the condition it was in when the continuation was grabbed.
14:27:38 <Cale> hmm, of course, you could set up something like that anyway
14:28:08 <emertens> Who are you talking to?
14:28:37 <Cale> nobody in particular :)
14:32:46 <nealc> :)
14:38:18 <Cale> > let getCC = callCC (return . fix); getSCC = do s <- get; jump <- getCC; put s; return jump in (`runState` 1) . (`runContT` return) $ do x <- get; jump <- getSCC; put (x+1); if (x > 3) then return True else jump
14:38:22 <lambdabot> Terminated
14:38:29 <Cale> good :)
14:38:38 <Cale> So it's strictly more general that way anyway
14:47:42 <vincenz> dons: ping
14:54:15 <emertens> Whoa, HP is simplifying the integration of open source and linux
14:54:26 <emertens> I'm glad that someone is tackling that challenge
14:54:29 <benja_> what?
14:54:39 <emertens> (I'm reading a HP banner ad)
14:54:44 <benja_> lol
14:54:51 <emertens> I'm tempted to "Find out more"
14:55:39 <Cale> emertens: hahaha
14:55:45 <Cale> which banner ad?
14:55:54 <emertens> http://m.2mdn.net/1251058/us_104_200603_30_hp_simplify_yellow_leader2_7_.gif
14:56:31 <emertens> I can't tell if that's a guy with his hands behind his head, or a scary open source moth
14:56:42 <SamB> maybe they mean the integration of open source and linux into existing companyies' infrastructures?
14:56:48 <benja_> yeah
14:57:18 <emertens> I'm pretty sure that they are trying to integrate open source into linux
14:57:20 <emertens> or visa versa
14:57:28 <emertens> I wish them the best of luck
14:57:37 <SamB> oh, that is so hard!
14:57:38 <benja_> emertens: that sounds too hard
14:57:51 <benja_> I think HP is too small a company to do that
14:57:54 <benja_> IBM perhaps
14:57:55 <emertens> they'd probably be better off just sticking with windows
15:01:35 * sieni really wants a "WWSPJD?"-t-shirt
15:01:49 <emertens> :)
15:05:20 <benja_> OSWeekly.com asks: "What is the future of closed source software and Linux?"
15:05:29 <benja_> HP: "Bleak! (Just watch us!)"
15:29:03 <ptolomy> Is there a reasonable way to construct a DAWG (directed acyclic word graph) without using ST or IO in Haskell?
15:33:34 * benja_ reads up on dawgs :)
15:35:17 <benja_> could you build up a trie of suffixes?
15:35:48 <benja_> hm
15:36:12 <benja_> no, that didn't make sense, sorry :)
15:36:48 <benja_> (dunno, I suppose)
15:46:00 <vincenz> Cale: use scheme ever?
16:01:10 <dons> moin
16:01:54 <stepcut> moin
16:02:48 <stepcut> with a bit of hacking, we could compile yi with GHD and have a distributed text editor ;)
16:03:24 <dons> just a bit of hacking, eh?
16:04:23 <stepcut> well... I have never used GDH, so maybe it is bit more than a bit
16:05:32 <benja_> does anybody here know of a definition of a 'do'-like construct that allows for multiple assignment to the same variable?
16:05:34 <stepcut> Using mobile haskell could be fun too...
16:05:57 <dons> benja_: you want mutable variables?
16:06:09 <benja_> dons: y
16:06:23 <dons> there are several ways. use Data.IORef, a StateT monad, an MVar
16:06:32 <dons> there was a thread on the mailing list this week, let me find it ...
16:06:34 <benja_> [well, I think I do, I may be mistaken ;-)]
16:06:51 <dons> maybe you are. why do you need to mutate a variable?
16:06:56 <benja_> dons: no, what I mean is I'm looking for a way to define 'do' in a new programming language
16:07:03 <dons> ah
16:07:30 <dons> 'do' as in Haskell's `do'?
16:07:31 <ndm> dons: Haskell is something like 7th now on the shootout, what happened :)
16:07:46 <dons> ndm, oh, I suppose other languages keep trying.
16:07:54 <dons> also, one of our entries got disqualified
16:08:01 <ndm> so the solution to get permanent dominance is to kneecap the other languages?
16:08:07 <Cale> why disqualified?
16:08:11 <benja_> as in Haskell's do, but as sugar for CPS not monads, and allowing multiple assignment
16:08:13 <ndm> I did ask about hte windows shootout, but got no response
16:08:21 <dons> oh it broke the spec some how, Cale
16:08:31 <dons> anyway, I'm holding off spending time on this until 6.6 comes out
16:08:42 <benja_> to allow for using the usual patterns from imperative languages where you mutate variables in a loop
16:08:42 <ndm> how far away is 6.6?
16:08:54 <Cale> Yeah, 6.6 will make it easier to crush the other languages :)
16:09:01 <ndm> I have started at looking at adding Yhc benchmarks
16:09:05 <Cale> ByteString is going into 6.6 right?
16:09:12 <dons> yes. it is in.
16:09:20 <ndm> which will loose, but who cares, i'm going to aim for elegance
16:09:23 <benja_> (my current implementation is essentially Haskell's do, except for CPS)
16:09:24 <Cale> With all the cool fusion tricks?
16:09:28 <dons> dcoutts and I are furiously hacking away on a big speed up using a new rewrite rule system
16:09:34 <Cale> cool
16:09:39 <dons> some fuseable functions run 3-4x faster now
16:09:42 <ndm> then people can see Haskell GHC (fast, hacked), or Haskell Yhc (slow, pure)
16:09:58 <Cale> It's awesome that you can actually beat the obvious C code for some things.
16:10:09 <stepcut> dons:  sweet!
16:10:28 <dons> let me find the latest stats..
16:10:46 <Cale> Eventually, people will program in Haskell rather than C in order to get better performance :)
16:11:48 <dons> so these are the old benchmarks (fps 0. 7): http://www.cse.unsw.edu.au/~dons/tmp/fusionbench.results.WrapElimMapFilter.ghc-6.5
16:12:01 <dons> and the new system: http://www.cse.unsw.edu.au/~dons/tmp/fusionbench.results.Streams.ghc-6.5
16:12:42 <Cale> hmm
16:12:45 <dons> the few that got slower are using scanl/r, which we broke
16:12:52 <dons> but i'm fixing that today :)
16:14:48 <ndm> my housemate is learning C++ at the mo
16:14:50 <ndm> its scary
16:14:59 <ndm> 15 lines of C++ == half a line of haskell
16:15:08 <benja_> "half a line" =-)
16:15:34 <ndm> `elem` xs is the half line i was thinkign of for the particular function he was writing
16:15:50 <benja_> )
16:15:53 <benja_> er, :)
16:15:57 <benja_> [half a smiley]
16:18:55 <kfish> dons: hmp3's README suggest's configuring with --prefix=/home/dons ... what if my username isn't dons?
16:20:05 <dons> that's not support :P
16:20:09 <dons> -ed
16:20:19 <dons> hehe
16:21:03 <dons> kfish: I think hmp3 comes with debian and gentoo these days, you might not even have to build it by hand.
16:21:08 <dons> (though its not that hard, of course)
16:21:54 <kfish> dons, that's ok, i'm just reading the source
16:22:02 <emertens> dons: I tried ghc on OpenBSD yesterday, and ghci had link errors when it would try to load "base"
16:22:10 <emertens> dons: does that sound familiar?
16:22:30 <dons> emertens: yes this is a known bug. i've not been able to reproduce it here. when i update my box, i'll fix it.
16:22:36 <dons> which will happen after i finish the paper i'm writing
16:22:49 <emertens> OK, cool
16:22:54 <dons> i suspect its a missing symbol from the rts Linker.c list
16:23:39 <musasabi> dons: how stable is the current FPS api (and are GHC HEAD and external fps api-wise in sync) ?
16:23:51 <dons> it is stable now, and they're in sync
16:24:12 <musasabi> ok. Will have to upgrade HAppS soon.
16:24:34 <dons> right. we don't intend to change the api now.
16:27:10 <emertens> What is FPS? I have heard it brought up a few times today
16:27:27 <dons> ?where fps
16:27:28 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
16:28:05 <emertens> Oh, that's the ByteString you told me about last night
16:28:23 <dons> yep :)
16:28:46 <emertens> FPS: Foreign Pointer _______
16:28:55 <emertens> strings?
16:29:08 <dons> fast, packed strings
16:29:51 <ndm> should fast packed strings be Yhc compatible?
16:30:34 <dons> yep. once you get a ForeignPtr, and associated code
16:30:43 <dons> it runs in hugs, for example
16:30:45 <ndm> we got a regression failure today with Packedstring on Mac OS X ppc, so its tempting to ditch that and move to FPS
16:30:53 <ndm> we have ForeignPtr, I think....
16:31:49 <dons> last time i checked other things were missing, mallocForeignPtrBytes?
16:32:16 <dons> it was only a few things missing
16:35:02 <ndm> we added FFI since then
16:35:12 <dons> ah ok. maybe it will build
16:35:15 <ndm> and we'll be doing a "get haskell.org libraries working" push at some point
16:35:24 <ndm> so we'll try and pull bytestring in then
16:35:48 <dons> ok, i'll have a look and see what's missing
16:36:12 <ndm> you could also become an OpenBSD buildbot :) - http://www.indiegigs.co.uk:8010/
16:36:15 <lambdabot> Title: BuildBot: Yhc
16:36:24 <dons> oh, that's a good idea
16:36:40 <ndm> its very cool, rebuilds as soon as someone commits a chance
16:37:17 <ndm> and its very handy, because we can even debug machines we don't have access too, albeit slowly and painfully
16:37:46 <ndm> thats what i spent today doing, getting Mac OS X ppc working, from a distance
16:40:22 <vincenz> dons: how hard is it to invoke generic haskel lcode
16:42:28 <dons> hmm?
16:53:46 <dons> @tell bringert re. the amd64 gcc warning -- we might be able to reproduce it on dcoutts' amd box. looking into it
16:53:47 <lambdabot> Consider it noted.
16:59:44 <kfish> hmm, i get " Unknown field 'data-files' " with Cabal 1.1.3 ... how do i find out what cabal version a field depends on? (if that's the problem)
17:00:24 <dons> sounds like you need Cabal-1.1.4
17:00:49 <dons> the cabal versioning issue itself is only fixed in recent cabals
17:00:57 <dons> (i.e. they can now state which version they need)
17:01:07 <kfish> ok, 1.1.3 is old? (i'm just using what's in debian/ubuntu)
17:01:27 <dons> yeah, just a bit. 1.1.4 is the usual now.
17:01:33 <dons> many fixes went in
17:01:56 <musasabi> hmm. Would a build-depend: in Cabal make sense?
17:02:11 <musasabi> For depending upon a library that contains only TH and is not needed at runtime.
17:02:21 <kfish> dons: thanks
17:02:29 * musasabi is packaging some TH-utilities to a library
17:02:32 <dons> hmm
17:04:07 <musasabi> needs some GHC hackery to drop the TH depency I think, but that hackery is needed in any case.
17:04:45 <dons> yeah
17:05:04 <musasabi> also build-depends would make sense for tools.
17:05:16 <musasabi> i.e. happy, alex etc
17:05:33 <dons> having a concept of build-depends and run-depends is used elsewhere (i.e. ports systems), so it makes sense
17:05:48 <musasabi> yes, most package systems have it.
17:06:35 <musasabi> -libraries was the right list to talk about Cabal?
17:07:15 <dons> sounds right
17:07:22 <dons> or maybe on the cabal dev list?
17:07:55 <dons> kfish: so any chance we can use your new ogg decoder as a pure haskell ogg backend to hmp3?...
17:08:32 <dons> it would be nice to remove the external tool dependency hmp3 has, and just ship a haskell decoder
17:10:36 <kfish> dons, eventually ;-) i'm not intending to rewrite libvorbis in haskell, but a wrapper for libfishsound is doable (http://www.annodex.net/software/libfishsound/html)
17:10:37 <lambdabot> Title: libfishsound: Main Page
17:11:52 <kfish> dons: btw considered using libmad instead of mpg123? it's got a pretty nice callback interface
17:12:30 <kfish> (where "nice" is relative to C libraries generally)
17:12:51 * stepcut has some working haskell-mad bindings
17:12:55 <dons> I should, I suspect. The original mpg123 thing was to get something working fast (which happened), but in hindsight a generic backend is much more preferable
17:13:34 <dons> stepcut: repo online?
17:13:38 * stepcut checks
17:14:44 <stepcut> the repo is not publicly accessible, I will publish something that is tomorrow
17:14:51 <dons> cheers
17:15:24 <dons> yes, i'd like to remove the restricted mp3-only backend to hmp3 for v2.D0
17:15:50 <stepcut> I have (a) minimal bindings to libmad (b) an example file that decodes and .mp3 to a .raw file, and (c) a very computationally expensive version that plays back in real-time via jackd
17:16:44 <stepcut> (d) an example file that scans all the headers and calculates what byte-offset/time each frame starts at -- so you can seek or even play the things backwards
17:17:00 <dons> oh,that's nice.
17:18:13 <kfish> stepcut, very nice
17:18:17 <stepcut> I am also working on a native haskell version of libresample, so you can match the sampling rate to your sound card (or, just play the mp3 faster and slower)
17:18:35 <stepcut> I will try to clean up some of the stuff and publish it tomorrow
17:19:05 <stepcut> the resample stuff is at least a week away from working though
17:19:35 <kfish> stepcut, libresample not libsamplerate? http://www.mega-nerd.com/SRC/
17:19:36 <lambdabot> Title: Secret Rabbit Code (aka libsamplerate)
17:19:59 <kfish> from memory the SRC algorithm is pretty tight
17:20:16 <stepcut> kfish: same thing -- Julius wrote resample which got turned into libresample which got turned into libsamplerate I think
17:21:02 <kfish> yeah, libsamplerate's had a lot of tweaking, it's a bit more than just a re-implementation
17:21:16 <kfish> s/yeah/nah/ :)
17:21:36 <stepcut> true
17:21:53 <stepcut> mostly I just got the names mixed up, I meant SRC
17:22:13 <kfish> heh :)
17:23:20 <stepcut> SRC is good stuff -- except for the license :p
17:24:13 <kfish> stepcut, yeah, many people have asked Erik to move it from GPL to LGPL
17:25:01 <stepcut> anyway, I am trying to get back into DSP, so it is a good warmup exercise
17:25:05 <kfish> i have hackfests with Erik a lot
17:25:19 <kfish> he has been writing his filter design tools in ocaml recently
17:25:40 <stepcut> cool
17:25:59 <stepcut> ocaml drives me nuts
17:26:31 <qz> you mean its good language? ;)
17:26:47 <vincenz> stepcut: why?
17:27:15 <kfish> stepcut, i look forward to seeing Erik's reaction when you release a version of SRC in haskell :))
17:27:19 <stepcut> vincenz: lack of type-classes, function signatures in a seperate file (.ml vs .mli), stuff like that
17:27:31 <stepcut> kfish: hehe
17:28:38 <emertens> function signatures in separate files??
17:28:48 <emertens> that's so C++
17:28:51 <dons> Haskell learnt much from the vagaries of the MLs
17:28:59 <kfish> d'oh, i'd better head to work ... later
17:29:19 <emertens> What does ``ML'' stand for?
17:29:24 <sh10151> meta language
17:29:44 <sh10151> think a dragon book was written using it
17:29:56 <dons> hmm?
17:30:08 <dons> there's appel's book "Modern Compiler construction in ML"
17:30:25 <vincenz> stepcut: ah
17:30:29 <sh10151> maybe that's what I am thinking of
17:30:53 <dons> it sits next to the dragon book on my desk, sh10151. so, close :)
17:31:04 <sh10151> there's a new dragon book coming out
17:31:28 <stepcut> vincenz: and the ocaml version of Data.List sucks in comparision :)
17:37:04 <emertens> anyone know a site that outlines some of the differences in haskell and ML?
17:37:12 <emertens> I know that's probably a pretty specific request
17:38:30 <ndm> emertens: would be a good page for the Haskell wiki, if you do figure out the answers
17:38:54 <dons> emertens: there's been some papers comparing specific features. and the 'history of haskell' paper probably mentions some more
17:39:10 <emertens> I've got the history of haskell paper downloaded
17:39:17 <emertens> I'll have to give that a skim
17:39:36 <dons> strictness, syntax, no type classes, functors, more magic typery happening in haskell
17:43:10 <Cale> Various flavours of ML use their module system somewhat like we use typeclasses. It's less wieldy for classes/modules with few functions, but perhaps better for larger classes/modules.
17:44:03 <Cale> They don't use it in order to solve the problem with operator overloading.
17:44:21 <Cale> So you end up with separate operators to act on floating point values.
17:44:58 <dons> yeah, haskell implements a number of solutions to issues in the MLs, being a newer language
17:47:35 <zarvok> instructive comparisons of specifically modules and type classes can be found here: http://www.cse.unsw.edu.au/~chak/papers/WC06.html and here: http://www.cs.cmu.edu/~rwh/papers/mtc/apr06.pdf
17:47:36 <lambdabot> Title: Research Papers of Manuel Chakravarty
17:47:48 <zarvok> of course, these are full papers, and probably more than what you want
17:51:46 <emertens> I'll download the paper, I like to have stuff to read when things get slow
17:58:11 <dons> zarvok: you were hoping to get into the cmu PL research group, this year - is that right? how'd you go?
17:58:38 <zarvok> dons: almost, I'll be applying in the fall
17:58:49 <zarvok> currently I am an undergrad at CMU and work with the group
17:59:32 <zarvok> in particular, I'm working currently on implementing some features commonly associated with haskell for the group's pet ML compiler
17:59:34 <dons> ah right. good luck. Bob's visited us here at UNSW several times. It's always interesting.
17:59:41 <zarvok> yeah, Bob is a great guy
18:00:04 <dons> what features commonly associated with haskell?
18:00:09 <dons> laziness!? ;)
18:00:12 <zarvok> haha
18:00:34 <zarvok> implementing the typeclasses paper mentioned above, for one, and also restructuring the basis library to use monads
18:00:50 <dons> oh excellent.
18:01:01 <zarvok> monads are pretty easy to think of as signatures in module system
18:01:07 <zarvok> yeah, it's fun
18:02:46 <zarvok> Bob was nice enough to let me work on things related to my haskell fetish
18:03:17 <dons> have you met stefanw? he hangs out there some times (the guy who did the original typeclass/modules encoding)
18:03:42 <zarvok> I haven't
18:04:13 <dons> I'll have to introduce you next time he's around. I'm sure he'd be interested to know someone's working on the ML side of the story.
18:05:22 <zarvok> yeah, it would be interesting to talk with him, it's neat stuff
18:31:44 <erider> araujo:  ping
18:35:11 <whoopsbob> Does anyone have any suggestions for haskell projects to get familiar with the language for programmers who aren't used to functional programming? Not something that'll take me a month to implement though
18:37:18 <zarvok> whoopsbob: maybe a sudoku solver? Or some other similar thing?
18:37:39 <zarvok> I've always found writing game solvers an instructive way to learn languages
18:38:09 <dons> or look at the language shootout and try to improve some of the programs?
18:38:54 <dons> if you're interested in web stuff, you coudl work on hope
18:39:27 * zarvok keeps meaning to set up a hope blog
18:39:50 <dons> ?where hope
18:39:50 <lambdabot> http://hope.bringert.net/
18:40:00 <dons> whoopsbob: you could look at writing a lambdabot plugin too
18:40:01 <whoopsbob> Hm, sudoku solver sounds good
18:40:08 <dons> ?wiki Sudoku
18:40:08 <lambdabot> http://www.haskell.org/haskellwiki/Sudoku
18:40:18 <dons> to get you started
18:40:46 <whoopsbob> dons: Eh, that'll involve learning the hooks of the bot and stuff
18:41:03 <whoopsbob> I've done a sudoku solver in c before, so it shouldn't be so bad
18:41:25 <dons> no no. plugins are easy
18:41:34 <dons> a sudoku solver plugin would be cool!
18:41:55 <zarvok> heh
18:41:55 <whoopsbob> Haha
18:42:10 <whoopsbob> And that page looks really long for just a sudoku solver
18:42:36 <whoopsbob> Oh, they're different programs
18:42:37 <dons> there's lots of sudoku solvers there
18:42:39 <zarvok> whoopsbob: if you do write a solver, be sure to compare it to some of the others afterwards.  Your solution as someone who writes C is sure to be very different than long time haskell hackers, and the difference will be instructive
18:43:04 <dons> yeah, no back tracking no deterministic monads, for example :}
18:43:10 <whoopsbob> Yeah. I'm thinking I should just look a bunch of random programs before attempting something by myself
18:43:32 <whoopsbob> No backtracking? That doesn't sound like fun
18:43:58 <zarvok> heh, I think he meant you're unlikely to use backtracking as a haskell hacker would
18:44:14 <dons> well, you can use backtracking all you want.
18:45:04 <whoopsbob> Oh, misread what you said
18:45:07 <dons> that was just a joke about a particuarly haskellish soln that's up there.
18:45:19 * dons drowns in wifi lag
18:49:05 <SamB_XP> dons: it just searches a tree?
18:54:01 <dons>  not sure. ask Cale :)
19:19:30 * edwardk waves sleepily hello.
19:20:52 <dons> hello edwardk
19:28:42 <Korollary> dons: I think haskellwiki could use a highly visible cookbook wiki like this: http://schemewiki.org/Cookbook/RecipeIndex
19:28:46 <lambdabot> Title: RecipeIndex - Cookbook - s c h e m a t i c s : c o o k b o o k
19:28:57 * dons looks
19:29:29 <dons> yes!
19:29:49 <dons> we actually sort of had this discussion on the wiki, but didn't relalise we need a cookbook
19:29:57 <dons> the Idioms category is filling up with 'recipes'
19:30:03 <dons> which isn't quite the right place
19:30:11 <dons> Category:Cookbook is actually what is needed
19:30:41 <dons> which can start with some of the example code items from the idioms category
19:30:45 <dons> and then we extend as we go
19:30:48 <Korollary> It should be accessible from the first page, though. That would eliminate a ton of "I'm in the middle of a do-block with an IO String. What do I do?" questions.
19:30:54 <dons> yep.
19:31:01 <dons> we can stick it on the front page
19:32:02 <dons> i'll see if we can create the new Cookbook category
19:35:37 <Korollary> hi mathewm
19:36:13 <mathewm> heya, Korollary
19:36:33 <Korollary> how is code?
19:36:47 <mathewm> :)
19:38:05 <lispy> yeah, after i got the idea of what to do with the IO String in the middle of a do block, it was just a matter of practice before i didn't care about being in the IO monad
19:38:16 <lispy> i'd say...that's a huge learning point for haskelleres
19:40:25 <mathewm> I think my biggest Haskell hurdle now is learning how/when to apply strictness and unboxed types - and performance in general
19:40:34 <mathewm> my code is always SLOOOOW
19:44:22 <dons> have you learnt about profiling?
19:44:41 <dons> and the various optimised data structures, like Data.Array.Unboxed, Data.IntMap, Data.ByteString?
19:44:46 <dons> ?wiki Performance
19:44:46 <lambdabot> http://www.haskell.org/haskellwiki/Performance
19:45:00 <dons> the number 1 thing to learn is profiling
19:45:07 <mathewm> nope haven't profiled yet
19:45:21 <mathewm> thanks
19:45:59 <dons> ok, it easy. a) make sure you have the profiling libs installed. b) compile with -O -prof -auto-all c) run your code with +RTS -p -RTS
19:46:20 <dons> d) read a.out.prof e) tweak code f) see point a)
19:50:40 <mathewm> any way to profile a program that doesn't terminate normally?
19:51:42 <dons> in ghc 6.5, it shoudl still get profiled.
19:51:56 <dons> otherwise, there are some flags that will have the output produced on the fly
19:52:07 <dons> you'll have to check the profiling manual for those.
19:52:07 <mathewm> kewl, I am in 6.5 anyways
20:04:32 <dons> ?yow
20:04:33 <lambdabot> Loni Anderson's hair should be LEGALIZED!!
20:15:25 <edwardk> ok, dumb question, whats a function that given ["foo","bar"] yields ["fb","fa","fr","ob","oa","or",...]
20:15:27 <edwardk> i forgot =)
20:15:36 <emertens> sequence?
20:15:40 <edwardk> thank you =)
20:15:45 <emertens> > sequence ["foo","bar"]
20:15:46 <lambdabot>  ["fb","fa","fr","ob","oa","or","ob","oa","or"]
20:16:02 <edwardk> i knew it was something silly and monadic, justnot used to thinking in the list monad
20:17:44 <edwardk> there isn't one that takes two arguments, "foo" and "bar" and returns a list of pairs is there?
20:17:55 <edwardk> or should i just derive it from sequence
20:18:16 <emertens> f x y = [ u : v: [] | u <- x, v <- y] ?
20:18:18 <dons> > [ (a,b) | a <- "foo", b <- "bar" ]
20:18:19 <lambdabot>  [('f','b'),('f','a'),('f','r'),('o','b'),('o','a'),('o','r'),('o','b'),('o',...
20:18:34 <emertens> ah, list of pairs
20:18:50 <int-e> @type liftM2
20:18:51 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
20:19:13 <int-e> @type liftM2 (,) :: [a] -> [a] -> [(a,a)]
20:19:14 <lambdabot> [a] -> [a] -> [(a,a)] :: forall a. [a] -> [a] -> [(a, a)]
20:19:18 <emertens> > liftM2 (,) "foor" "bar"
20:19:19 <lambdabot>  [('f','b'),('f','a'),('f','r'),('o','b'),('o','a'),('o','r'),('o','b'),('o',...
20:19:27 <dons> nice.
20:19:40 <emertens> now that is some slick list monad usage
20:19:44 * dons sings "Monad magic, monad magic" to the tune of Monkey magic.
20:20:01 <kpreid> beautiful
20:20:10 <emertens> idling in this channel is starting to have a positive effect on me :)
20:20:17 <stepcut> :p
20:20:22 <edwardk> rock =)
20:20:49 <edwardk> playing in template haskell, trying to do things on large numbers of instances at once.
20:28:15 <emertens> Does anyone here know of the problem where a man is holding a rubber band and walking at a given speed, and a spider is walking along the band at a given speed, solve for the time that the spider reaches the end of the band (if ever)
20:29:07 <LordBrain> haha
20:30:12 <emertens> i just saw the question on topcoder, and was hoping to confirm that this was a 1st order linear differential equation
20:30:36 <LordBrain> i thought it was a joke
20:30:45 <LordBrain> the rubber band has an end?
20:31:06 <dons> oh, its not a mobius strip or something?
20:31:16 <emertens> one end is fixed (the end that the spider walks on)
20:31:23 <dons> i assumed joke as well :)
20:31:25 <emertens> the other end is held, the end that the spider walks to
20:32:08 <emertens> obviously if the spider was not moving, and was positioned at the center of the band, the band would grow longer, but the spider would stay in the center
20:32:11 <LordBrain> oooooh
20:32:23 <LordBrain> one end of hte rubber band is like pinned to the wall or something?
20:32:26 <emertens> right
20:32:46 <dons> interesting
20:33:10 <mathewm> does the spiders velocity relative to the man change depending on where the spider sits on the band?
20:33:19 <emertens> yeah
20:34:01 <emertens> (spider position) / (total length) = fraction of man's speed that spider gets for free
20:34:01 <mathewm> I just cannot visualize it...
20:34:26 <emertens> the band starts at 1 foot long
20:34:35 <emertens> so the length is 1 + speed of man * time
20:34:46 <emertens> the spider starts at position 0
20:35:46 * mathewm suffers a zeno's paradox flashbacks
20:35:49 <kpreid> > liftM id ["abc"]
20:35:50 <lambdabot>  ["abc"]
20:36:01 <kpreid> > liftM id ["foo","bar"]
20:36:03 <lambdabot>  ["foo","bar"]
20:36:23 <emertens> liftM reverse ["foo","bar"]
20:36:28 <emertens> > liftM reverse ["foo","bar"]
20:36:29 <lambdabot>  ["oof","rab"]
20:36:46 <emertens> > map reverse ["foo","bar"]
20:36:47 <lambdabot>  ["oof","rab"]
20:36:56 <kpreid> > liftM (liftM id) ["foo","bar"]
20:36:58 <lambdabot>  ["foo","bar"]
20:37:02 <kpreid> OK, I'm not thinking sufficiently
20:37:15 <emertens> on lists, liftM is just a map
20:37:45 <edwardk> has anyone here used forallT in template haskell? all the docs and tutorials seem to shy away =)
20:40:10 <kpreid> > (sequence . inits) "abcd"
20:40:11 <lambdabot>  []
20:40:21 <kpreid> > (sequence . tail . inits) "abcd"
20:40:22 <lambdabot>  ["aaaa","aaab","aaac","aaad","aaba","aabb","aabc","aabd","aaca","aacb","aacc...
20:40:30 <edwardk> basically trying to splice together an instance declaration like LSN (X0 (X0 a)) H0 (X0 a), but i can't figure out the right way to refer to 'a' there
20:40:53 <edwardk> i thought i could just use a varT to get it, but then its not bound, so i figure i need some form of forallT round that but
20:41:02 <edwardk> forall a . LSN (XF (XF a)) HF (XF a)
20:41:05 <edwardk> is malformed
20:41:12 <edwardk> when spliced in
20:44:31 <edwardk> woot, nm
20:45:01 <emertens> woot, my answer was right!!
20:45:42 <emertens> time = ( e^(man's speed / spider's speed) -1) / man's speed
20:46:15 <emertens> might seem trivial to you guys, but I love math, I just don't ever have the occasion to use it
20:46:20 <edwardk> heh
20:48:46 <emertens> @index join
20:48:47 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
20:52:50 <marcelino> how well does haskell support expert systems development compared to more traditional symbolic lanaguages such as lisp or prolog
20:56:50 <Korollary> Did you search haskell-cafe mailing list archives?
20:57:05 <edwardk> whats the option to get ghc to dump the core output from your code?
20:57:23 <dons> I would expect if you can do it in lisp, you can do it as easily, or easier in haskell
20:57:26 <dons> edwardk: -ddump-simpl
20:57:35 <edwardk> thx, hard to find stuff in the docs
21:00:27 <emertens> dons: would you be willing to post that statement on a Lisp mailing list, and defend it?
21:00:51 <edwardk> heh
21:07:00 <dons> emertens: its just a programming language. why wouldn't haskell be suitable?
21:07:12 <dons> unless there are special libraries that are missing
21:07:43 <Korollary> But you'd think that there is a reason why they dpn
21:07:49 <Korollary> don't write them in C
21:08:43 <dons> yeah, symbolic manipulation sucks in C
21:09:03 <dons> so you'd get static typing and pattern matching, if they used haskell. seems like a clear win -- much like when writing a compiler in haskell
21:09:28 <emertens> dons: My first read of your statement was basically "Anything Lisp can do Haskell can do or better", it seemed fairly sweeping
21:09:34 <emertens> and I dont even know if you are right or not :)
21:09:49 <emertens> just seemed really general, like something that I'd like to see argued :)
21:10:13 <dons> nono, I meant for the case of expert systems programming.
21:10:23 <dons> I see nothing special that gives lisp an advantage.
21:10:27 <emertens> oh, sure ;)
21:10:27 <dons> perhaps there's something I'm missing
21:10:56 <dons> prolog however, I can see an advantage
21:11:33 <Korollary> nah. I think somebody should argue that point purely to troll people.
21:12:15 <dons> lisp is just a haskell, with all the good stuff disabled, right?
21:12:54 <Korollary> every lisp program contains half of the spineless tagless g-machine and the prelude! ;)
21:13:39 <dons> ;)
21:17:07 <LordBrain> what's the g-machine?
21:17:36 <dons> one of the abstract machines describign how haskell executes
21:18:17 <dons> g for 'graph', as in graph reduction (a haskell program can be seen as a graph of nodes that reduce to the final program value)
21:19:00 <stepcut> who needs prolog when you have oleg's LogicT monad transformer ;)
21:19:04 <LordBrain> i want to learn that eventually
21:19:06 <LordBrain> hehe
21:19:53 <LordBrain> there is so much i want to know...
21:20:27 <Korollary> just a matter of time
21:21:24 <LordBrain> i wish i discovered haskell years back
21:23:04 <Korollary> I wish I discovered PLT years back. I didn't know I'd be interested in it.
21:23:08 <Korollary> +had
21:23:21 <Cale> yeah, it's a little annoying when you run into people who are convinced that they should learn Java or C++ and not Haskell.
21:23:48 <marcelino> i have played around a bit with haskell not sure what to think about it
21:24:15 <Korollary> Especially those who complain about being taught scheme in school. They dont know how lucky they are.
21:24:20 <marcelino> does haskell have records now?
21:24:28 <marcelino> or is it still a hack?
21:24:46 <Cale> marcelino: proper records? Not yet. People have argued and argued about exactly how they should be done.
21:25:15 <Cale> There's a really decent proposal (at least, I think it's good) now though.
21:25:31 <Cale> Just needs someone to implement it in GHC
21:25:36 <stepcut> some people have even argued that they already exist (HList)
21:25:52 <stepcut> Cale: which proposal?
21:25:56 <zarvok> Cale: where does this proposal live?
21:25:59 <Cale> Let me find it
21:26:15 <marcelino> other than lisp comprehensions and implicit pattern matching i don't see much benefit of haskell over lisp
21:26:27 <Cale> http://www.cs.uu.nl/~daan/download/papers/scopedlabels.pdf
21:26:32 <Korollary> marcelino: It takes unusually long to propery get a good idea of haskell. For most people, anyways.
21:26:36 <stepcut> Cale: yeah, I liked those
21:26:54 <stepcut> (those records, aka, that proposal)
21:26:56 <sieni> marcelino: what about type inference and laziness by default?
21:27:01 <zarvok> Cale: thanks
21:27:12 <Korollary> I'd say laziness and type classes.
21:27:15 <stepcut> Cale: he has actually implemented that in another language, right ?
21:27:32 <Cale> stepcut: I'm unsure, I think the Clean folks were going to steal it
21:27:34 <marcelino> sieni type inference is built into lisp laziness is simply another term for nondeterminism streams etc something easy to implement in lisp and scheme if you want it
21:27:41 <dons> hey guys, int-e kindly graphed our current bytestring speed results. this shows the difference between fps 0.7 as used with 6.4.2, and fps-unstable, to appear with ghc 6.6: http://img236.imageshack.us/img236/3241/ghc2gm6.png
21:27:49 <Cale> stepcut: Oh, they're in Morrow
21:27:58 <sieni> marcelino: o rly? where in lisp can you see type inference?
21:27:59 <LordBrain> one benefit i liked over scheme right away was readability... writing in scheme was fun and easy, but i didn't really think it was all that readable.. haskell has a lot of symbols which makes it harder to type, and arguably the sugar is complexity.. but i like it.
21:28:08 <Cale> dons: holy crap :)
21:28:11 <stepcut> Cale: yeah, that's the one :)
21:28:24 <Korollary> dons: nice
21:28:25 <dons> Cale, uh hu. stream fusion is the future!
21:28:42 <stepcut> heh
21:28:45 <zarvok> dons: nice
21:29:33 <Cale> dons: I wonder how often it'll beat C?
21:29:46 <dons> ghc just generates a lot better code using the streams abstraction. its very nice.
21:29:53 <dons> Cale, well, very interesting question!
21:29:57 <Cale> Well, naive C programs anyway
21:30:08 <stepcut> that graph could use a few labels ;)
21:30:22 <dons> labels schmabels
21:30:34 <Cale> hehe
21:30:44 <Cale> communism schmommunism
21:31:03 <marcelino> sieni lisp has parametric polymorphism built in
21:31:09 <stepcut> What is the y-axis ? Seconds? furlongs ?
21:31:11 <LordBrain> i like haskell's thread performance and the STM monad stuff too... i havent ever done common lisp tho.. i dont know what it has to compare
21:31:12 <marcelino> (+ 2.0 234 )
21:31:14 <marcelino> etc
21:31:29 <Cale> marcelino: that's not parametric polymorphism, that's ad-hoc polymorphism
21:31:36 <marcelino> clos has multimethods
21:31:44 <marcelino> which gives you type dispatching
21:31:49 <dons> y=seconds, x=individual bytestring functions in 2-element pipelines
21:31:50 <Cale> and it gets away without parametric polymorphism most of the time by lack of typing
21:32:05 <stepcut> dons: thanks!
21:32:32 <sieni> marcelino: I'm talking about the fact that if you compile a common lisp/scheme source, the system fails to detect even basic type errors, which is impossible in haskell or ml, since everything is statically type-checked. For me that's the main advantage of ml or haskell over lisps
21:32:33 <Cale> marcelino: How easy is it to enforce, at compile time, that a list has only strings as elements?
21:32:36 <marcelino> regardless of fancy academic labels what does haskell do that can be done in another language?
21:32:45 <marcelino> can't
21:32:54 <dons> heh
21:33:03 <Cale> marcelino: *any* other language?
21:33:07 <marcelino> cale you can add type declarations in lisp to limit scope typing etc
21:33:20 <Cale> Not any one thing. There's Clean, which is pretty close to Haskell in most regards.
21:33:21 <marcelino> lisp is strongly typed
21:33:31 <Cale> Statically?
21:33:35 <sieni> marcelino: but still it's dynamically typed, not statically
21:33:36 <marcelino> strongly
21:33:41 <Cale> but not statically
21:33:45 <sieni> marcelino: http://en.wikipedia.org/wiki/Type_inference
21:33:49 <Cale> note that I said *at compile time*
21:34:05 <Cale> That is, the code hasn't made it to production yet.
21:34:18 <marcelino> i've got all the haskell books so i am familiar with the concepts
21:34:24 <LordBrain> hmmm... there is a saying that all those parenthesis in lisp hypnotize people
21:34:47 <LordBrain> what are all the haskell books?
21:34:59 <sieni> lisp is fun, i agree: i'm currently reading "lisp in small pieces" <3
21:35:03 <Cale> One of the things which really annoyed me when programming in lisp is that most of my bugs were things that would easily have been caught and pointed out at compile time if there'd been static typechecking with a decent typesystem.
21:35:15 <marcelino> the books on haskell you find on amazon etc
21:35:19 <sieni> LordBrain: there aren't any. there are good lisp books, though
21:35:26 <marcelino> published books
21:35:44 <Cale> Instead, I had to stare at backtraces to work out what was going on.
21:36:09 <LordBrain> yeah Cale... i didnt like how scheme allows undefined symbols and considers it a language feature...
21:36:10 <dons> marcelino, yeah, its really the static typing that's the main feature. and compared to just about any language out there, you can check more things statically in haskell.
21:36:14 <marcelino> in the haskell world is it true that ghc is the only compiler recommended for doing commercial development?
21:36:21 <stepcut> Cale: that's what is so funny about the erlang movie -- the error they fix is a run-time type error :p
21:36:25 <dons> marcelino: yep.
21:36:37 <sieni> "ml for the working programmer" and "modern compiler implementation in ml" can be useful for a haskell programmer
21:36:42 <Cale> stepcut: erlang movie?
21:36:44 <dons> though possibly nhc on embedded systems
21:36:55 <stepcut> Cale: yes, scary stuff, hold on
21:37:07 <marcelino> sieni i own the working programmer and have perused the ml compiler book
21:37:12 <dons> Cale, its _stunning_....
21:37:13 <LordBrain> yeah i'm surprised they made a movie about a programming langauge
21:37:20 <stepcut> Cale: http://lambda-the-ultimate.org/node/197
21:37:21 <lambdabot> Title: Erlang the Movie | Lambda the Ultimate
21:37:40 <stepcut> Cale: though, I recommend finding it on google video so you don't have to d/l the 200MB version
21:37:57 <stepcut> http://video.google.com/videoplay?docid=-5830318882717959520&q=erlang+the+movie
21:37:58 <lambdabot> Title: Erlang: The Movie - Google Video
21:38:36 <Cale> Man, what is this? Attack Cale's home machine week? I've had one dictionary attack after another.
21:39:07 <stepcut> ?erlang
21:39:07 <lambdabot> Unknown command, try @list
21:39:14 <dons> Cale, you're actually seeing people try to log in?
21:39:18 <Cale> dons: yes
21:39:35 <marcelino> dons static typing is more or less a way of avoiding bad things from happening
21:39:35 <marcelino> but
21:39:39 <Cale> Does anyone know if there's a decent list of IP ranges for China?
21:39:51 * stepcut thinks ?erlang should return "Hello Joe. Hello Mike. Hello Mike. Hello Robert. Hello Joe, Hello Mike. Hello."
21:39:53 <dons> Cale. huh.
21:39:57 <Cale> I'm just going to add all of China to hosts.deny
21:40:01 <Cale> that'd fix the problem
21:40:04 <marcelino> what does haskell have in the way of making it better to implement dsl's for example?
21:40:11 <marcelino> o'haskell? template haskell?
21:40:13 <Cale> marcelino: Typeclasses
21:40:22 <Cale> marcelino: and specifically, the monad typeclass
21:40:48 <dons> flexible syntax? rebindable syntax. dsl's are one of haskell's strong points
21:40:52 <Cale> Typeclasses allow styles of combinator library to be abstracted out into separate libraries.
21:41:06 <Cale> The Monad library is one of these
21:41:10 <Cale> Arrows are another
21:41:12 <Cale> Idioms
21:41:23 <Cale> and so on, you could come up with your own if you'd like
21:41:44 <Cale> which means that once you decide that you want a monadic EDSL, you don't have to write all the combinators
21:41:48 <marcelino> Cale but typeclasses in terms of expressiveness don't really seem to offer more power all your getting is different syntax for doing things that can be done in oop already
21:42:08 <Cale> Huh?
21:42:17 <dons> also, laziness and hofs make implementing dsl control structures easy
21:42:18 <Cale> No you're not, you're getting something far more expressive.
21:42:27 <Cale> Look at the MonadTrans class
21:42:34 <Cale> How would you implement that in OO?
21:42:43 <Cale> Or MonadState?
21:42:53 <stepcut> http://homepages.cwi.nl/~ralf/gpce06/
21:42:56 <lambdabot> Title: Software Extension and Integration with Type Classes
21:43:26 <Cale> You can have multiparameter typeclasses, which essentially express *relations* between types -- and whenever that relation holds, functionality is provided.
21:44:04 <Cale> Actually, MonadState might not be too much of a problem, you could try to approximate it with an abstract base class.
21:44:18 <Cale> But it has a functional depedency
21:44:29 <Cale> Classes without functional dependencies will be harder.
21:44:46 <Cale> (or with more complicated dependencies)
21:44:55 <marcelino> well if you look at the roots of haskell combinators etc..it's really category theory..etc...
21:45:02 <Cale> yes
21:45:11 <Cale> and of course, you can program these ideas in other languages
21:45:21 <marcelino> but a turing machine can do the same thing!
21:45:25 <Cale> but it tends to be unwieldy
21:45:40 <marcelino> then inject nondeterminism
21:45:48 <marcelino> and you get succinctnes
21:46:02 <Cale> The thing is, typeclasses make it easy to use these abstractions in Haskell, which in basically every other language are quite uncomfortable
21:46:43 <stepcut> that paper I posted has a number of case studies comparing OO to haskell type-classes
21:46:51 <marcelino> in many respect prolog is more powerful than haskell
21:46:52 <Cale> Well, in lisp, you tend to use macros to get similar effects.
21:47:08 <Cale> marcelino: But prolog is just the list monad ;)
21:47:21 <Cale> (okay, not quite)
21:47:35 <stepcut> Cale: LogicT
21:47:40 <Cale> Or LogicT
21:47:54 <Cale> NondetT comes quite close too.
21:48:12 <Cale> (well, it's just the list monad, but faster)
21:48:25 <marcelino> you have unification with logical variables when combined with recursive procedures and a surface syntax for data structures, the symbol manipulation possibilities of prolog surpass those over other languages
21:48:28 <Cale> er, with the advantage of being a transformer)
21:48:54 <Cale> I found prolog's type system lacking
21:49:05 <Cale> and you can't define new data structures, iirc.
21:49:14 <marcelino> plus prolog pattern matching is more powerful than haskell's because it's bidirectional
21:49:27 <Cale> Well, that much is true
21:49:37 <Cale> Have you seen Mercury and friends?
21:49:42 <marcelino> a relation is a superset of a function
21:49:57 <marcelino> i have seen mercury never used it
21:50:10 <Cale> Well, a function is a special type of relation sure.
21:50:26 <Cale> But what would you rather have, a semigroup, or a group?
21:50:33 <marcelino> cale you can define any data structure you want in prolog
21:50:38 <marcelino> its all based upon TERM
21:50:39 <Cale> Sometimes adding axioms makes things easier to work with.
21:51:07 <marcelino> e.g. it's easy to implement AVL trees efficiently in prolog
21:51:13 <LordBrain> just finished the erlang movie
21:51:28 <int-e> how do functions form a group?
21:51:33 <Cale> Okay, I'll take your word for it there, since I haven't really written anything serious in Prolog.
21:51:41 <Cale> int-e: they don't, it was an analogy
21:51:47 <int-e> ah.
21:51:53 * int-e feels a bit stupid.
21:52:05 <Cale> int-e: "group" has more axioms than "semigroup", in the same way that "function" has more axioms than "relation"
21:52:22 <int-e> I know that :)
21:52:22 <Cale> Functions are nicer to work with than arbitrary relations
21:52:32 <dons> marcelino: are you learning haskell? interested in learning it? trying to work out where it fits?
21:52:36 <Cale> Just like groups are nicer to have than semigroups.
21:53:24 <LordBrain> someone told me in europe the mathematicians dont even define function and just work with relations.. but i dont believe it.
21:53:39 <Cale> LordBrain: that's a lie
21:53:45 <marcelino> dons i have played around with haskell for a bit. for implementing algorithms or mathematical stuff haskell seems ideal but for general purpose stuff not sure
21:54:08 <dons> ah well. we use it for general purpose stuff. all the time. :)
21:54:46 <Cale> marcelino: well, you can look at some of the general-purpose-type programs people have written. I like the pretty clock that dcoutts wrote using Gtk+Hs
21:54:52 <dons> check out http://haskell.org,under the 'libraries and tools' link for an idea of the range of things being written in Haskell
21:55:18 <Cale> er, Gtk2Hs, rather
21:55:35 <Cale> http://haskell.org/gtk2hs/archives/2006/01/26/cairo-eye-candy/
21:55:35 <dons> the range being from operating systems to theorem provers to pretty clocks to shooter games
21:55:36 <lambdabot> Title: Gtk2Hs » Blog Archive » Cairo eye candy
21:55:52 <marcelino> question what is the preffered enviroment for developing with haskell?
21:55:57 <marcelino> haskell + emacs?
21:56:06 <dons> ghc + vim/emacs?
21:56:09 <Cale> There's a start at a first person shooter game called Frag
21:56:11 <Korollary> there
21:56:16 <stepcut> haskell + lambdabot
21:56:16 <Cale> looks like it needs more developers
21:56:18 <dons> with some tags installed. and darcs
21:56:19 <Korollary> 's also an eclipse plugin I think
21:56:20 <dons> stepcut: heh!
21:56:21 <Cale> but it's a good start
21:56:31 <Korollary> @google eclipsefp
21:56:33 <lambdabot> http://eclipsefp.sourceforge.net/
21:56:34 <lambdabot> Title: EclipseFP - Functional programming support for Eclipse
21:56:36 <dons> Cale: yeah, we need some game hacker to step up
21:56:47 * stepcut often logs onto irc for the sole purpose of talking to lambdabot
21:56:48 <Cale> http://haskell.org/haskellwiki/Frag
21:56:49 <lambdabot> Title: Frag - HaskellWiki
21:56:50 <dons> oh, dcoutts clock _is_ very nice, isn't it.
21:56:56 <Cale> dons: yes :)
21:57:03 <dons> stepcut: you might be interested in the new ghci binding to lambdabot, then.
21:57:07 <dons> ?where goa
21:57:07 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
21:57:08 <Cale> dons: He ported it from C and made it 10x faster :)
21:57:26 <Cale> http://www.cse.unsw.edu.au/~dons/images/frag/mun-frag1.jpg
21:57:34 <dons> stepcut: $ ghci
21:57:35 <dons> GOA> :pl \f x y -> y (f x)
21:57:35 <dons> (flip id .)
21:57:47 <Cale> Despite the blatantly stolen graphics, that's pretty cool :)
21:58:05 <stepcut> dons: I've seen that link before, but I am still not clear on what GoA is
21:58:06 <dons> no no. the graphics are freely available
21:58:12 <Cale> http://www.cse.unsw.edu.au/~dons/images/frag/mun-frag4.jpg -- and blatantly stolen maps :)
21:58:25 <int-e> so it's 'blatantly copied'
21:58:30 <dons> stepcut: its a little library that loads on ghci starting up, forking lambdabot, and a set of ghci bindings to lambdabot functions
21:58:32 * int-e giggles
21:58:42 <stepcut> dons: neat, I will have to check that out
21:58:54 <dons> so you can do:  :pl  which actually calls @pl in lambdabot
21:58:55 <stepcut> dons: I also need to port lambdabot to jabber someday :p
21:59:20 <stepcut> I will definately try out GoA though
21:59:26 <Korollary> dons: isn't forking lambdabot a bit of an overkill? Can't @pl and its ilk be separated into a separate lib?
21:59:35 <Cale> marcelino: I think that's a pretty decent proof of concept for writing 3D games in Haskell though :)
21:59:45 * Korollary likes the word, separate.
21:59:52 <dons> Korollary: well, we wanted to use any and all of lambdabot
22:00:00 <dons> its not terribly expensive. you certainly don't notice it happen
22:00:05 <marcelino> cale i am interesting in writing business application software for profit
22:00:10 <marcelino> not games
22:00:11 <Korollary> dons: what am I going to do with @vixen in ghci, though? :)
22:00:17 <dons> i.e. lambdabot is forked every time i run ghci, and I don't notice
22:00:21 <Cale> marcelino: all right, that's doable too, of course :)
22:00:30 <dons> Korollary: use your imagination
22:00:52 * Korollary suddenly gets up and moves away from the keyboard.
22:00:59 <Cale> marcelino: Gtk2Hs gives you a rather decent way to program a GUI. Obviously, program logic is no problem.
22:01:12 <Cale> There are decent libraries for interacting with databases and so on
22:01:13 <dons> Korollary: you could teach her to discuss Leibniz, for example
22:01:19 <dons> Korollary: what were you thinking??
22:01:21 <zarvok> dons: if I'm running lambdabot inside ghci, is there anyway to make it think people are exiting and entering the "channel" so @seen will have useful results?
22:01:37 <dons> zarvok: hmm. nope
22:01:44 <dons> could be done, I suppose
22:01:47 <Cale> marcelino: Have you seen SPJ's paper on encoding contracts in Haskell?
22:01:54 <zarvok> eh, not a big deal, I was just fooling around with it earlier
22:02:07 <dons> cool. goa? did it all work according to plan?
22:02:15 <Korollary> dons: it's quite obvious what 'vixen' may make one think, you silly geek :)
22:02:28 <dons> :P
22:02:55 <zarvok> ah, I'm not clear on what goa is, I just darcs got the lambdabot source and followed the readme instructions to load it in ghci
22:03:02 <dons> ah, ok.
22:03:09 <dons> that's not quite what I'm talking about
22:03:14 <zarvok> yeah, I guessed as much
22:03:20 <dons> once you've got lambdabot installed and built, then you can install goa
22:03:23 <Cale> hum
22:03:27 <dons> and you get ghci itself as a lambdabot
22:03:31 <dons> ?where goa
22:03:31 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
22:03:36 <zarvok> I see, cool.  I'll probably play with it later
22:03:44 <Cale> I can't connect to the Erlang movie torrent and the other link to it seems dead too.
22:03:51 <marcelino> cale was that the one they recoded in ocaml for performance?
22:04:05 <Cale> marcelino: which one?
22:04:15 <marcelino> the contracts
22:04:27 <marcelino> lexfi
22:04:32 <dons> high performance contracts, eh?
22:04:44 <stepcut> Cale: odd, try just going to http://video.google.com and seearching for erlang the movie
22:04:45 <lambdabot> Title: Google Video
22:04:50 <Cale> I'm not sure there's actually a downloadable place to get the source. It's a paper.
22:04:53 <LordBrain> Cale: use the google video one, thats what i had to do
22:05:34 <marcelino> i am not how well haskell scales up
22:05:38 <marcelino> sure
22:06:03 <dons> marcelino: I think maybe you should just try it for a while first :)
22:07:07 <marcelino> can haskell implement an interactive repl driven by business rules?
22:07:12 <Cale> marcelino: I think it's reasonable for basically all practical uses. If you really end up with a tight loop which you need to make more efficient, you can always use FFI and C, but this is extremely rare, and I wouldn't expect it to come up in a business application.
22:07:30 <dons> marcelino: its a general purpose language. you can do anything in it.
22:07:35 <Cale> marcelino: sure
22:08:04 <dons> we should have a business-haskell faq :}
22:08:07 <Cale> In fact, with ByteString, we're beating the obvious C programs for a few tasks now.
22:08:08 <marcelino> there is a company by the name of galois
22:08:21 <LordBrain> yeah
22:08:26 <marcelino> they are into rsa encryption stuff i think written in haskell
22:08:27 <LordBrain> they hire haskellers
22:08:28 <Cale> Yeah, they make high-assurance software with Haskell.
22:08:50 <Cale> Not just encryption, I don't think.
22:08:56 <LordBrain> SyntaxNinja works there
22:08:57 <dons> lots of things, they do
22:09:06 <Cale> But basically, mission critical stuff which needs to be proven correct.
22:09:13 <marcelino> curious what guis interface well with ghc--wxwidgets win32? etc
22:09:28 <Cale> GTK2, I already mentioned, of course
22:09:39 <dons> so many questions!
22:09:40 <Cale> and those two
22:09:55 <Cale> and OpenGL
22:10:03 <Cale> if it counts :)
22:10:18 <marcelino> cale would you ever trade haskell for ocaml?
22:10:20 <LordBrain> there is a wx binding too
22:10:24 <marcelino> or ml
22:10:34 <dons> marcelino: I think the community is mostly moving the other way at the moment
22:10:38 <Cale> marcelino: Probably not.
22:10:39 <int-e> Cale's too lazy I think
22:10:55 <Cale> I tend to write code which relies heavily on laziness. :)
22:11:09 <int-e> ;)
22:11:14 <LordBrain> maybe if ocaml had type classes.... but i would miss haskells notation
22:11:18 <dons> marcelino: see these stats, which might be arguably refective of the community overall, http://www.cse.unsw.edu.au/~dons/irc/
22:11:19 <lambdabot> Title: Haskell IRC Activity
22:11:22 <Cale> Which means that strict languages are just slightly more frustrating.
22:11:26 <stepcut> I used to use ocaml, but I do not think I would ever choose to use it over haskell -- I have even pondered rewriting a bunch of legacy ocaml in haskell recently :)
22:11:37 <dons> we tend to keep picking up ocaml, ml and lispers. but few seem to go the other way
22:11:44 <marcelino> there has been much dissension amongst lispers that lisp is somewhat bloated..what is the state of bloatness in the haskell world?
22:11:47 <LordBrain> yeah
22:11:50 <Cale> I end up turning all these data structures in my head into control structures.
22:11:52 <LordBrain> i did ocaml for a little while
22:12:12 <LordBrain> i am still new to haskell.. but i love it... i'm totally sold
22:12:33 <Cale> Well, GHC has lots and lots and lots of stuff in it, but that's mostly because it's where all the experimental features are tried out.
22:13:04 <Cale> The standard is quite small, but unfortunately doesn't have everything you'll end up using on a regular basis.
22:13:19 <Cale> Which is the reason for the current effort to write a new standard.
22:13:49 <Cale> The language "feels" small in some sense.
22:13:52 <marcelino> how well does haskell interact with say linux kernal via system calls?
22:14:02 <Cale> via the FFI
22:14:12 <Cale> or IO primitives in the language
22:14:53 <Cale> With the FFI, you can call anything you can call from C.
22:15:09 <dons> marcelino: are you looking at programming the kernel in business logic while checking for language bloat and switching from ocaml, using a win32 gui?
22:15:19 <Cale> hehe
22:15:19 <LordBrain> lol
22:15:39 <LordBrain> he just wants to make sure its ready when he does
22:15:50 <dons> good to be prepared, I suppose
22:16:45 <marcelino> i want a simple gui with a repl i want to implement an expert system business app..obviously we're dealing with a symbolic system not sure if haskell is a best fit for this? eg. are there any clips style shells available for it? i don't think so
22:17:10 <LordBrain> interfacing to the kernel is not something that i'd expect to have an easier time with in lisp
22:17:37 <LordBrain> you'd still have to use an FFI
22:18:33 <LordBrain> haskell has a lot out there.. i think.. but the information could use better organization and centralization
22:19:48 <LordBrain> when i want some howto info, i'm still not sure what the first place to look is.. the wiki.. the ghc docs.. googling...
22:20:08 <marcelino> http://foldr.org/~michaelw/log/programming/lisp/reverse-complement-benchmark
22:20:09 <lambdabot> Title: Random Bits and Pieces: Lisp As Fast As C (Almost)
22:20:13 <LordBrain> hoogle..
22:20:18 <marcelino> lisp as fast as c not sure if haskell can compete
22:21:08 <marcelino> http://shootout.alioth.debian.org/gp4/benchmark.php?test=revcomp#about
22:21:09 <lambdabot> Title: reverse-complement benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Compute ...
22:21:44 <Korollary> why not look at the overall benchmarks than a single one?
22:21:48 <dons> the reverse complement benchmark will be fixed in ghc 6.6
22:21:51 <Cale> Look at, say, the chameneos benchmark on the same site :)
22:22:03 <dons> as you probably are aware, haskell ranks extremely well, marcelino
22:22:09 <marcelino> the haskell code can be found at http://shootout.alioth.debian.org/gp4/benchmark.php?test=revcomp&lang=ghc&id=3
22:22:10 <lambdabot> Title: reverse-complement Haskell GHC #3 program | Gentoo : Intel&#174; Pentium&#174;&n ...
22:22:11 <dons> in fact, it was first for a period this year
22:22:41 <Cale> marcelino: dons is one of the people who's written a lot of code for those benchmarks
22:22:54 <marcelino> i'll have to have a look
22:23:12 <Cale> marcelino: There's a problem with that one which will be fixed with the next release of GHC, since a library for fast string processing will be available.
22:23:35 <dons> yeah. good idea to look. we beat C in 40% of the benchmarks, last time I checked
22:23:44 <dons> I think we beat lisp in just about everything
22:24:44 <marcelino> one of the things i heard annoying about haskell is that if you try to implement algorithms in a mathematically elegent fashion you pay a price in performance...to get better perfomance you get ugly look code with built in optimizations etc
22:25:08 <dons> that's being improved. perhaps you'd like to try haskell for a while?
22:25:20 <Cale> marcelino: sometimes that's true, dons' library helps that situation greatly
22:25:32 <marcelino> dons' library?
22:25:36 <Cale> ByteString
22:25:41 <marcelino> ok
22:25:48 <dons> some good information here, http://shootout.alioth.debian.org/gp4/haskell.php
22:25:48 <marcelino> is that bundled with ghc?
22:25:57 <Cale> It will be with ghc 6.6
22:26:03 <Cale> which isn't out yet
22:26:49 <Cale> Most of the performance issues with Haskell came from the fact that it uses linked lists of 32 bit characters for strings.
22:26:56 <LordBrain> is it just me, or isnt ugly haskell still generally better to look than other languages?
22:27:10 <Cale> LordBrain: sometimes, sometimes not
22:27:16 <vegai> python's pretty pretty
22:27:40 <marcelino> there is something annoying i find about haskell and that is indentation
22:27:48 <Cale> marcelino: then don't use it
22:27:52 <LordBrain> layout..
22:28:00 <Cale> it's optional, you can use braces and semicolons
22:28:18 <LordBrain> only thing that annoys me about it is my editor doesnt understand the rules
22:28:20 <Cale> or just semicolons, if that's appropriate
22:28:33 <marcelino> is emacs the preffered haskellers ide?
22:28:39 <dons> you asked that one already
22:28:41 <Cale> emacs and vim are both nice
22:28:42 <LordBrain> *shrugs*
22:28:46 <LordBrain> i only use vim
22:28:53 <Cale> I think people use TextPad on windows
22:29:11 <LordBrain> yeah someone was in here the other day raving about TextPad
22:29:16 <Cale> There are lots of nice editors. Basically, any editor which can convert tabs to spaces is good.
22:29:20 <marcelino> well in lisp i use emacs because i like fuzzy pattern matching symbolic auto-completion etc
22:29:22 <dons> you could use cat. it works most everywhere
22:29:29 <stepcut> ed
22:29:34 <Cale> ?
22:29:35 <LordBrain> lol
22:29:37 <stepcut> (or edlin for dos users)
22:29:40 <dons> ed rocks
22:29:43 <Cale> ?
22:29:48 <Cale> hehe
22:29:48 <stepcut> Cale: :p
22:29:53 <dons> ed, like sed without the 's'
22:30:12 * stepcut tries to figure out if Cale is making a joke or not
22:30:15 <LordBrain> i remember edlin...
22:30:21 <jgrimes> I think he was making a joke
22:30:23 <dons> :)
22:30:24 <Cale> stepcut: of course I am :)
22:30:34 <stepcut> ;)
22:30:57 <Cale> actually, I take that back...
22:30:59 <Cale> stepcut: ?
22:31:21 <dons> $ ed
22:31:21 <dons> :q
22:31:21 <dons> ?
22:31:21 <dons> ^C
22:31:21 <dons> ?
22:31:23 <dons> ^C
22:31:26 <dons> ?
22:31:28 <dons> die!!!
22:31:35 <stepcut> ^D maybe?
22:31:36 <dons> now _that's_ a gui
22:31:39 <jgrimes> :p
22:31:40 <int-e> no colon
22:31:45 <int-e> just q :)
22:31:57 <marcelino> http://shootout.alioth.debian.org/gp4/benchmark.php?test=revcomp&lang=ghc&id=3
22:31:58 <lambdabot> Title: reverse-complement Haskell GHC #3 program | Gentoo : Intel&#174; Pentium&#174;&n ...
22:32:00 <stepcut> dons: can use some ideas from ed in hmp3 2.0
22:32:10 <marcelino> http://supybot.com/Members/jemfinch/haskell-sucks/document_view
22:32:11 <lambdabot> Title: Why I Believe that Haskell Sucks &mdash; Supybot Website
22:32:24 <LordBrain> haha
22:32:28 <dons> marcelino: http://shootout.alioth.debian.org/gp4/benchmark.php?test=chameneos&lang=all
22:32:29 <lambdabot> Title: chameneos benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Languag ...
22:32:47 <int-e> but the best thing about ed is that 'i' at the beginning of a file is an error - you have to use 'a'.
22:33:02 <int-e> (for an empty file)
22:33:10 <Cale> marcelino: that's obviously written by someone who doesn't really know Haskell too well.
22:33:26 <marcelino> he says: I've been dealing with Darcs lately, and it has convinced me that real-world programs should not be written in Haskell.
22:33:43 <marcelino> and numerous other issues
22:33:49 <Cale> marcelino: yeah, and then provides a bunch of examples of things which are non-issues
22:33:55 <jgrimes> they all seem like pretty trivial things to me
22:33:58 * stepcut has been dealing with _____ lately, and it has convinced me that real-world programs should not be written.
22:33:59 <dons> marcelino: http://www.cse.unsw.edu.au/~dons/tmp/good.html
22:33:59 <lambdabot> Title: Why I Believe Haskell Rules, And marcelino is a Troll
22:34:07 <Cale> hahaha
22:34:26 <int-e> silly dons :)
22:35:33 <Cale> okay, so the issues with space leaks one is something to consider. It takes a while to really learn how lazy evaluation works. Once you know how lazy evaluation works, and/or learn to use the profiler, space leaks are not a problem.
22:35:37 <marcelino> dons read the link is this true of the current haskell world?
22:35:58 <edwardk> cale: heh i still haven't gotten there myself =(
22:35:59 <Cale> If you write Haskell code the same way you'd write o'caml code, you'll get space leaks.
22:36:14 <LordBrain> hmmm
22:36:25 <LordBrain> i havent touched the profiler yet
22:36:45 <Cale> and they're really not as common as the guy seems to claim
22:37:00 <Cale> It's just when you're hit by one the first time, it can be jarring
22:37:45 <Cale> and hard to figure out, since you're usually altogether unaware of how to fix it
22:37:50 <Cale> (the first time)
22:38:22 <LordBrain> he doesnt even seem to know about import qualified
22:38:37 <Cale> yes, I completely ignored that one, because he's just ill-informed
22:38:40 <LordBrain> its supposed absence is one of his complaints
22:38:46 <Cale> the one about $ is also silly
22:38:55 <Cale> and where clauses
22:39:12 <Cale> The one about operators might have a point to it, but not much of one.
22:39:34 <vegai> interestingly, it seems like jemfinch is the only person in the WORLD who doesn't like Haskell
22:40:09 <dons> vegai: that may be true.
22:40:36 <vegai> students and other peons excluded, of course :P
22:40:39 <Cale> and various people who haven't really tried it since they had to learn a bit of it for their courses, and didn't study hard enough
22:41:12 <dons> vegai: oh, I get 25 hits on google for "don't like haskell"
22:41:16 <jgrimes> yeah, I've noticed a lot of people complaining about having it for classes. Same with scheme.
22:41:21 <dons> we better work harder ;)
22:41:47 <edwardk> heh
22:41:52 <dons> oh, only 2 are serious
22:41:54 <marcelino> cale i'll play around with the new haskell and see what it can do...
22:42:02 <Cale> marcelino: cool
22:42:28 <Cale> marcelino: If you're learning, I recommend "Yet Another Haskell Tutorial", to get you off the ground.
22:43:01 <Cale> There are lots of others, that one tends to be the gentlest one which isn't completely boring.
22:43:11 <dons> oh, interesting. one hit is vegai talking to garbeam on #wmii
22:43:15 <Cale> The "gentle intro" quite plainly isn't very gentle.
22:43:20 <vegai> dons: oops :)
22:43:27 <Cale> But it's good if you know an ML already.
22:43:29 * dons noticed recently garbeams rant about all higher level language's being bad 
22:43:38 <int-e> I see one real issue there - space leaks caused by lazyness.
22:43:51 <Cale> int-e: I discussed that already :)
22:43:58 <Cale> hehe :)
22:44:14 <vegai> dons: peer pressure, I suppose.
22:44:18 <dons> heh
22:44:30 <Cale> int-e: It's also sort of not an issue, really just part of the learning curve.
22:44:30 <int-e> Yep, I wasn't paying attention.
22:44:44 <vegai> #wmii is a hard place to talk in if you don't fit the crowd
22:44:47 <dons> vegai: I really like the whole wmii/10k loc movment. but don't get the idea of sticking to C. 10koc as a movement seems born for haskell/fp
22:44:51 <LordBrain> well
22:45:06 <vegai> well, in Haskell, it would be 1K
22:45:10 <dons> that's true.
22:45:20 <Cale> what's #wmii?
22:45:25 <dons> they just talk a lot about refactoring and removing code as a goal. which is what we talk about all the time here
22:45:40 <dons> Cale: its a minimalist window manager, a bit like ion
22:45:48 <vegai> the channel's at OFTC, not Freenode
22:46:00 <dons> and it spawned a philosophy about  writing programs with no more than 10k lines of code
22:46:11 <dons> and using refactoring to reduce code size at all times
22:46:36 <marcelino> http://wiki.alu.org/Conrad%20Barsk
22:46:38 <lambdabot> Title: ALU Wiki: Conrad Barsk
22:46:49 <pstickne> 10koc?
22:46:51 <Cale> That seems silly, by various theorems about incompressibility.
22:47:17 <dons> heh
22:47:29 <Cale> Eventually, you're going to run into a program which simply cannot be expressed in your language in less than 10k lines of code.
22:47:57 <dons> ah, here we go http://www.10kloc.org/
22:47:58 <lambdabot> Title: 10kloc.org - 10000 lines of code
22:48:00 <stepcut> Cale: depends on the per line character limit of your language
22:48:03 <vegai> would it be cheating if one cut the program into separated modules, then, Cale?
22:48:22 <vegai> s/modules/programs/
22:48:32 <dons> it just seems these guys were destined to move into fp. but they seem to resist. maybe i should come up with an assimilation/borg plan for them
22:48:58 <Cale> I think I'll generate a number with very high entropy that's longer than 10k lines and write a program that simply prints that number, then challenge them to refactor it.
22:49:11 <dons> evil Cale
22:49:22 <marcelino> http://groups.google.com/group/comp.lang.lisp/msg/cd76077521c3773b?hl=en&
22:49:24 <lambdabot> Title: Google Groups: comp.lang.lisp
22:49:30 <stepcut> http://www.jwz.org/doc/cadt.html
22:49:31 <pstickne> fp?
22:49:32 <lambdabot> Title: The CADT Model
22:49:37 <stepcut> hehe
22:49:40 <dons> marcelino: why are you posting random links at us?
22:49:42 <vegai> Cale: just remove the linefeeds and it's one line :P
22:49:50 <dons> pstickne: Functional Programming
22:49:52 <marcelino> i want you to read some of these comments
22:49:57 <marcelino> they are not random
22:50:09 <marcelino> its comparison of haskell with some other languages
22:50:41 <Cale> vegai: limit lines to 80 chars.
22:50:49 <dons> oh, I made a terrible mistake! Why have I spent my youth hacking this silly language. I should have used Lisp! Long live macros! Boo on types!
22:51:17 * dons is going to enter a 12 step plan to overcome his static typing addiction
22:51:41 <dons> the first step is to acknowledge that there is a problem
22:51:52 * stepcut is too stupid to write in a language with out static types
22:51:57 <int-e> Oh, I like the comment where it basically says Haskell is a bad language because it's hard to learn.
22:52:00 <dons> "All these type checks make my code too easy!"
22:52:01 <Cale> hehe
22:52:05 <pstickne> does Haskell have any REPL interface?
22:52:08 <dons> "I won't have a job if there are no bugs to fix"
22:52:13 <marcelino> dons the last link points out some serious limitations of haskell
22:52:13 <Cale> pstickne: yes
22:52:15 <dons> pstickne: sure, lambdabot
22:52:17 <dons> > 1+2
22:52:18 <lambdabot>  3
22:52:20 <stepcut> I'd have to, like, remember what type everything is
22:52:21 <Cale> pstickne: but it only does evaluation
22:52:31 <pstickne> Cale, as opposed to ..?
22:52:33 <Cale> pstickne: for declarations, you need to add them to a file
22:52:49 <dons> thank you marcelino. I will use and study this. Hopefully I can finish the 12 step plan without any relapse
22:52:54 <vegai> http://en.wikipedia.org/wiki/Twelve-step_program
22:53:36 <vegai> , 7 of which are religious, 6 of which mention a monotheist God
22:53:40 <dons> YEs, I admit that my life has become unmanegable without static typing
22:54:07 <dons> vegai: yeah, that's weird.
22:54:10 <stepcut> vegai: so, we can trim it down to 5 ?
22:54:21 <dons> so this should help. I can certainly manage 5 steps
22:54:42 <Cale> yes
22:55:08 <dons> I can make a list of all the programs I've harmed by making them statically typesafe
22:55:27 <Cale> haha
22:55:30 <vegai> I could make a list of all the people I've harmed by coding in C...
22:55:32 <stepcut> marcelino must be on step 12, "Having had a spiritual awakening as the result of these steps, we tried to carry this message to static type checkers, and to practice these principles in all our affairs."
22:55:41 <marcelino> its not about safety its about expressiveness
22:55:49 <vegai> marcelino: what is?
22:55:54 <int-e> > fail :: [Int] -- is that list complete?
22:55:55 <lambdabot>    Expecting a function type, but found `[Int]'
22:55:55 <lambdabot>    Expected type: [Int]
22:55:55 <lambdabot> ...
22:56:00 <int-e> > fail "" :: [Int] -- is that list complete?
22:56:01 <lambdabot>  []
22:56:23 <dons> marcelino: you are in the program, then, too?
22:56:27 <marcelino> i would rather have a language that gives me sharp sword as opposed to a blunt one
22:56:41 <dons> I recommend ASM
22:56:44 <Stinger_> until you cut yourself
22:56:44 <dons> very shapr.
22:56:49 <Cale> marcelino: It's about the same thing giving you safety and expressiveness.
22:56:51 <stepcut> I wrote 1 + 1 in php once, and got 11 -- wasn't quite what I was hoping for
22:56:51 <dons> shapr? brain explosion
22:56:58 <Cale> marcelino: Types express things about your programs.
22:57:03 <Korollary> @get-shapr
22:57:03 <lambdabot> shapr!!
22:57:04 <vegai> dons: we all miss him
22:57:09 <Cale> marcelino: Things which the compiler enforces.
22:57:14 <dons> ?remember stepcut I wrote 1 + 1 in php once, and got 11 -- wasn't quite what I was hoping for
22:57:14 <lambdabot> Done.
22:57:17 * int-e does bit manipulation in C right now, and will be pondering an asm implementation later
22:57:33 <vegai> stepcut: that was "1" + "1", no?
22:58:04 <dons> I understand now that I need the freedom to encode bugs in my programs. And that types have been denying me this. All the while I've been telling myself this is a "good thing" -- I was wrong
22:58:22 <stepcut> vegai: well, there were two variables, which I thought should be ints, and php thought should be strings apparently
22:58:33 <vegai> ah
22:59:26 <marcelino> as anyone here ever wrote and shipped a full fledged haskell application?
22:59:45 <vegai> stepcut: actually, it seems like "1" + "1" => 2 these days in php
23:00:11 <pstickne> haskell is strongly typed then?
23:00:13 <Korollary> sethk has. I don't know if he's around.
23:00:20 <Cale> pstickne: strongly and statically
23:00:31 <stepcut> vegai: heh
23:01:10 <ndm> marcelino: yes!
23:01:21 <dons> morning ndm
23:01:31 <ndm> morning dons
23:01:40 <dons> ?vixen are you written in haskell?
23:01:40 <lambdabot> church is my favourite computer scientist.
23:01:44 <marcelino> ndm those are my initials
23:01:46 <dons> ?vixen so that's a yes?
23:01:47 <lambdabot> isn't it obvious?
23:01:50 <ndm> (and very morning it is too)
23:01:50 <marcelino> nelson debrito marcelino
23:01:56 <dons> ?vixen but you're not fully fledged?
23:01:57 <lambdabot> isn't it obvious?
23:02:07 <dons> ?vixen well, not really. how old are you?
23:02:08 <lambdabot> 19, you?
23:02:15 <dons> ?vixen ah, that's fully fledged, I suppose
23:02:15 <lambdabot> what were you saying?
23:02:16 <Cale> marcelino: I haven't yet written commercial software in Haskell, but I have written useful software in Haskell :)
23:02:51 <marcelino> Cale is writing commercial software something that interests you?
23:02:53 <ndm> marcelino: Linspire recently standardised on Haskell for their stuff
23:03:04 <Cale> marcelino: only moderately
23:03:09 <Korollary> The haskell activities report lists applications, commercial and otherwise.
23:03:12 <Cale> marcelino: I'd rather prove theorems :)
23:03:15 <LordBrain> marcelino: i read that last link. I am new to haskell, but i can still answer it. you can use hs-plugins to load haskell code at runtime. Haskell's syntax being difficult is a matter of opinion, its actually one of my favorite things about the langauge.. the sugar makes it so math like.
23:03:16 <dons> ?where hcar
23:03:17 <lambdabot> http://www.haskell.org/communities/
23:04:06 <dons> its been another weird afternoon on #haskell
23:04:06 <LordBrain> making imperative programs in haskell is not difficult
23:04:45 <marcelino> one of the strengths haskell has in mathematical programming but symbolic i am not so sure
23:05:08 <Cale> marcelino: It has algebraic datatypes, what more could you want?
23:05:08 <dons> perhaps you should try before you buy?
23:05:16 <marcelino> in lisp for example a symbol has an associated property list in haskell you don't have that
23:05:17 <dons> and pattern matching..
23:05:28 <dons> ah, its the tower of languages syndrom
23:05:31 <dons> e.
23:05:32 <stepcut> `Haskell is the world's finest imperative programming language.'' - SPJ
23:05:49 <marcelino> algebraic types gives you recursive data structures but their a pain to use often times
23:05:59 <Cale> marcelino: It's not like maintaining that sort of datastructure is hard.
23:06:02 <Stinger_> heh
23:06:08 <dons> X has property P. Y doesn't have P. therefore Y isn't as powerful as X
23:06:08 <Cale> A pain? How?
23:06:32 <dons> heh, this gets weirder and weirder
23:06:37 <marcelino> cale if you like proving theorems you should look into prolog
23:06:51 <Cale> marcelino: I've written small things in prolog.
23:07:05 <dons> yeah, like one of the key features people cite as being an advantage in haskell is its crucial flaw, eh, marcelino ?
23:07:05 <stepcut> nah, if you like theorem proving you should look into epigram :)
23:07:09 <marcelino> things like context free grammars are trivial to implement
23:07:11 <LordBrain> in haskell, you cant have an undefined symbol floating around in your code... is that a bad thing from a symbolic point of view?
23:07:43 <Cale> marcelino: I like Haskell because it's easy to prove that things behave correctly.
23:07:44 <dons> LordBrain: only in a symbolic expert system doing kernel programming with business logic
23:07:54 <ndm> marcelino: in prolog, as soon as you want to do addition you have to break its properties and polymodality, Haskell even has IO which is pure!
23:08:00 <marcelino> cale this is so only in the non-monad world
23:08:10 <Cale> marcelino: no, it's true of monadic code too
23:08:22 <Cale> Monads have to satisfy specific laws
23:08:34 <marcelino> just curious cale how familiar are use with semantics?
23:08:37 <Cale> Which allow you to manipulate code symbolically
23:08:50 <Cale> What kind of semantics?
23:09:03 <marcelino> eg operational, axiomatic, or denotational semantics
23:09:15 <dons> marcelino: that's basically all we talk about here.
23:09:23 <LordBrain> haskell takes longer to compile
23:09:28 <marcelino> floyd hoare proofs etc
23:09:28 <Cale> Reasonably familiar, I'm not a total expert or anything.
23:09:32 <LordBrain> generally..
23:09:35 <ndm> LordBrain: try Hugs :)
23:09:38 <LordBrain> yeah
23:09:39 <Cale> I'm a mathematician :)
23:09:43 <LordBrain> i know about hugs
23:09:48 <Korollary> Cale: no, you're a bum, imho ;)
23:09:51 <dons> LordBrain: yeah, ghc takes longer to compile. but it thinks carefully...
23:09:56 <Cale> Korollary: hehe
23:10:01 <marcelino> cale i also have a mathematics background
23:10:09 <ndm> anyway, i'm off - won't be back for at least a week, have fun!
23:10:10 <Cale> marcelino: You'll like Haskell
23:10:11 <dons> Cale, that's good! you've made it past step 1 on the program
23:10:12 <marcelino> as well as computer science
23:10:25 <Stinger_> lol
23:10:28 <Cale> dons: hehe, what was that again?
23:10:29 <dons> step 2, you have to apologise to all the people you've harmed with your numbers and categories
23:10:47 <Cale> hehe
23:10:47 <Stinger_> Hello my name is Cale, and ... I am a .... mathematician *claps*
23:10:52 <Korollary> heh
23:11:03 <dons> we can come back to the Monads Anonymous program after you've done Mathematicians Anonymous
23:11:04 <Korollary> "Let's thank Cale for sharing himself with us."
23:11:13 <Cale> ahaha
23:11:32 * Korollary hugs Cornelius and starts to cry
23:11:37 <Stinger_> I started back in high school you know
23:11:43 <dons> hehe
23:12:02 <dons> I haven't written a proof in 3 weeks now .. thanks guys!
23:12:05 <Stinger_> simple algebra calculus, some people at uni got me hooked on pure maths
23:12:45 <marcelino> if you want to know haskell really well then it is incumbent that you are well versed in category theory...thinks monoids, rings, groups etc
23:12:52 <dons> it is?
23:12:57 <Stinger_> *I'd continue along that vein, but I dont know enough maths to make it sound good :)
23:12:58 <Cale> marcelino: why is that?
23:13:03 <Cale> marcelino: Really, it's not.
23:13:05 <dons> marcelino: did you find you had to do that when you got really good at haskell?
23:13:13 <marcelino> well what are the theoritical roots of haskell?
23:13:22 <marcelino> schoefinkal?
23:13:33 <dons> oh, so that was a question posed as a statement. I see.
23:14:00 <Korollary> theoretical roots? like call-by-need lc?
23:14:02 <dons> yes, you should import Data.Shoenfinkel before you try that stuff, though
23:14:08 <Cale> Knowing about monoids and categories, functors and monads in their general setting will help put their use in Haskell in context, but you don't really need them unless you're doing research.
23:14:11 <stepcut> dons: haha
23:14:37 <Cale> You only need their restrictions to Haskell, which are quite simple
23:15:00 <pstickne> all types begin in uppercase? do they use camel case?
23:15:06 <Cale> as for groups and rings, well... I don't know, what kinds of programs are you writing?
23:15:10 <Stinger_> you dont need to know all topology theory to do an integral.. well an ordinary integral anyway
23:15:22 <dons> pstickne: yep, if you like. types, constructors, modules: upper case first letter
23:15:23 <marcelino> well we have mu-recursive functions, lambda calculus, combinatory logic stuff pioneered by the likes of Church, Kleene, Schonfinkel, Curry...
23:15:45 <Cale> marcelino: all of which it's completely unnecessary to know about in order to write practical applications
23:16:00 <marcelino> well but you mentioned theorem proving
23:16:04 <Cale> sure
23:16:21 <Cale> so?
23:16:25 <dons> ... Cale battles on ...
23:16:27 <marcelino> i think that for mathematical programming there are definite benifits syntax wise for using haskell
23:16:28 <stepcut> Cale: how can you possibly implement business logic with out knowing about Schonfinkel!?
23:16:39 <Cale> stepcut: haha
23:16:44 <marcelino> list comprehensions uses zermelo frankel sytnax for example
23:16:44 <dons> stepcut: that's SO TRUE
23:16:58 <stepcut> Cale: that's one the questions we ask all php jobs candidates
23:16:59 <dons> marcelino: are you MegaMonad?
23:17:03 <Korollary> @keal
23:17:03 <lambdabot> intuitive != imperative
23:17:05 <Cale> marcelino: yeah, but those are just the minor syntactical things.
23:17:13 <Stinger_> stepcut if they know you dont hire them?
23:17:29 <marcelino> dons i am nelson debrito marcelino
23:17:33 <stepcut> Stinger_: hehe
23:17:38 <dons> that's exactly what MegaMonad would say..
23:17:51 <Cale> marcelino: there are really good reasons that mathematical ideas can be put to work in Haskell -- just look at the Monad class, for instance
23:18:27 <marcelino> cale these are great things that very few other languages have
23:19:01 <Cale> Essentially, I can create abstractions which apply to code differently based on the types involved, but in a very careful, and well-defined way through bounded parametric polymorphism. This is something which is done (perhaps a little more implicitly) in mathematics all over the place.
23:19:19 <marcelino> http://www.lambdassociates.org/aboutqi.htm
23:19:21 <lambdabot> Title: Qi FAQ
23:19:27 <marcelino> read the blurb about haskell you might be interested
23:20:42 <marcelino> http://www.lambdassociates.org/advtypes.htm
23:20:43 <lambdabot> Title: Advanced Types in Qi
23:21:11 <dons> I already told you I was sold on this, marcelino. I'm abandoning static typing. I was a fool to limit myself this way! Your url pastes have been very convincing.
23:21:14 <Cale> yeah, I've seen Qi
23:21:20 <marcelino> Qi has the most powerful type theory of any language that will ever be invented.
23:21:53 <marcelino> dons i don't know you very well--you might be pulling my leg, no?
23:22:43 <Cale> marcelino: He's been outright sarcastic for the last half hour.
23:23:03 <dons> I think I will visit #lisp and paste links to random haskell pages
23:23:30 <marcelino> Cale sequent types are very powerful...interesting contrast to haskell type classes i think
23:23:56 <Cale> marcelino: there's something to be said for compiler termination :)
23:24:09 <dons> actually, Cale, the last 50 mins it seems. oh my
23:24:24 <Cale> But sure, there are more expressive type systems
23:24:47 <Cale> There are even more powerful type systems in Haskell-like languages, not just lisp-like languages.
23:25:05 <marcelino> i think the great think about programming languages is that if you keep an open mind you can share ideas between them and this can overall make you an even better haskell programmer
23:25:15 <Cale> of course
23:26:02 <Adamant> ok, serious question about Haskell.. why is it staticially typed? What were the advantages and tradeoffs of that in response to the design?
23:26:16 <marcelino> dons i think you would like jon harrop
23:26:21 <Cale> I'm not defending Haskell because it's the only language I know, I'm defending it because it's an excellent language -- it's right on the cusp between advanced features and practicality for everyday programming, and it does quite well at both.
23:26:32 * Adamant Schemer/Lispnik interested in the language.
23:26:39 <Adamant> is a, rather
23:26:48 <Cale> Adamant: It prevents you from putting code into production which has bugs which could be discovered earlier.
23:27:18 <dons> Adamant: advantages: less bugs -- you have your code checked before you run. disadvantages: some programs don't type check, although you can imagine ways they would evaluate safely
23:27:24 <Cale> and since the compiler gets to report the problem, it has your source code, and is able to provide more information to you
23:27:25 <marcelino> btw http://readscheme.org/ has a huge haskell section i think you would enjoy perusing
23:27:26 <lambdabot> Title: Readscheme.org - Functional Programming Resources
23:27:44 <marcelino> http://haskell.readscheme.org/
23:27:45 <lambdabot> Title: Online Bibliography of Haskell Research
23:27:49 <dons> ?url-off
23:27:50 <lambdabot> Url disabled
23:28:04 <Cale> Know about it :)
23:28:30 <Korollary> The name Jon Harrop is familiar.
23:28:53 <Adamant> what about expressivity? does it limit any techniques common in the Lisps, like macros?
23:29:03 <marcelino> if you want to know about harrop go here http://www.ffconsultancy.com/free/ray_tracer/languages.html
23:29:21 <Korollary> oh, he's an ocaml guy.
23:29:27 <Cale> Adamant: Well, some, but only fairly rarely. I'd have a really hard time coming up with something you can't also do with existential types.
23:29:31 <Korollary> I remember him
23:29:41 <Cale> Adamant: (which is a feature implemented in GHC)
23:29:52 <Cale> Adamant: But largely, no, not really.
23:30:11 <Adamant> is Haskell's standard more like CL's or Scheme's?
23:30:22 <Adamant> (complete vs. minimalist)
23:30:23 <Korollary> more like Scheme's, but a bit larger
23:30:49 <Adamant> I kind of wish Scheme had two standard, a Base language and an Extended one
23:30:55 <Korollary> me too
23:31:11 <marcelino> one of the benefits of scheme or lisp is if you want to extend the language you can do it no problem..with other languages you have to wait for new releases...
23:31:12 <stepcut> and, perhaps, a module standard
23:31:24 <Korollary> that too.
23:31:29 <Cale> marcelino: How is that not true of other languages?
23:31:43 <stepcut> the advantage of scheme is everyone can invent their own module mechanism
23:31:47 <LordBrain> he means macros in lisp
23:31:55 <Korollary> the disadvantage is that everybody does it differently
23:31:59 <pstickne> how is GHC thread support?
23:32:10 <LordBrain> excellent!
23:32:12 <marcelino> lets say you want to implement a for loop built in indistinguishable and same status as the core level how do that in other languages?
23:32:12 <Cale> Most of the things people do with lisp macros can be handled in Haskell with laziness and monads.
23:32:22 <pstickne> LordBrain, are they soft threads or native threads?
23:32:33 <dons> pstickne: go to http://haskell.org, click on 'libraries and tools', and then on 'concurrency'
23:32:36 <LordBrain> soft
23:32:42 <LordBrain> it gives you native tho if you want it
23:32:58 <Cale> For example, there's a Cont monad in which you have callCC and first class continuations, but Haskell doesn't have first-class continuations.
23:33:05 <marcelino> well if you compare these languages perhaps its like comparing ferraris to lamborghinis your pick
23:33:35 <Adamant> what are some good intros for someone interested in Haskell with a Lisp/Scheme background? won't have time to use them anytime soon, unfortunately
23:33:50 <marcelino> rex page has a nice haskell tutorial
23:33:53 <Cale> Yeah, there's lots of good things about these languages, and it just comes down to which ends up being closer to the way you think once you've learned them all.
23:34:08 <dons> Adamant: there's a 'Scheme in 48 hours' tutorial, where you write scheme in haskell
23:34:12 <dons> people seem to like that tut
23:34:13 <Cale> Adamant: I recommend "Yet Another Haskell Tutorial" too.
23:34:30 <pstickne> YAHT is not a tutorial dammit :(
23:34:31 <Cale> at least to get you off the ground
23:34:42 <Cale> YAHT is more of a book than a tutorial
23:34:46 <Cale> but whatever :)
23:34:53 <pstickne> ohub, I mean a Gentel Introduction isn't a tutorial ;)
23:34:58 <dons> a comprehensive tutorial ;)
23:35:06 <Cale> oh, the Gentle introduction is not gentle
23:35:14 <LordBrain> lol
23:35:20 <Cale> unless you already know something like ML
23:35:22 <dons> its a little joke ;)
23:35:34 <Adamant> thanks guys
23:35:37 <Adamant> or gals
23:35:39 <Cale> in which case, Haskell will, for the most part, not be hard to learn anyway.
23:36:23 <marcelino> Procedural programming is a monumental waste of human energy.
23:36:30 <marcelino> --rex page
23:36:38 <Cale> marcelino: This is something that most of us will agree with.
23:37:01 <marcelino> my observation has been though that industry loves waste
23:37:09 <Cale> There are things which are procedural, but there are things which are really not, and when you code those things procedurally, you're wasting effort in lots of ways.
23:37:11 <marcelino> the reason is that it managers build empires
23:37:22 <Cale> marcelino: Economics hates waste.
23:37:40 <Cale> and economics trumps the industry in the long run :)
23:37:43 <marcelino> crappy languages make maintenance costs higher meaning more headcount...bigger budget..large bonuses....
23:38:04 <marcelino> feudalism at its finest
23:38:10 <Cale> marcelino: until your competitors start using good languages, and crush you
23:38:18 <marcelino> indeed
23:38:19 <Adamant> eh, I dunno if I buy that. if you are looking strictly from a business perspective, there are good reasons to use Java
23:38:53 <Cale> There's a lot of inertia because you actually need to be able to hire people to maintain your programs
23:39:00 <Adamant> Cale, definitely
23:39:20 <Adamant> that is one reason to hire Java programmers
23:39:22 <stepcut> Cale: yeah, but you have to filter through that many more unqualified candidates :)
23:39:27 <Cale> But that's what we're here for, teaching people Haskell, so that there will be enough people to hire people to use it :)
23:39:35 <marcelino> i work at a shop that uses j2ee/java let me tell you it sucks the big one
23:40:09 <Adamant> I venture that anyone trained in CS here had to program a fair amount of Java, unless they were in a UT, CMU, or MIT program
23:40:21 <Adamant> (if they're from the U.S.)
23:40:23 <stepcut> UIUC, no java
23:40:45 <Adamant> Stanford went Java, which surprised me
23:40:45 <Cale> If they were from Europe or Australia, it's very likely they used Haskell in most of their courses.
23:40:49 <marcelino> my cs background was mostly c/c++ based
23:40:57 <Korollary> The industry would rather have everybody master java before leaving school. Vocational style.
23:41:12 <stepcut> I did have to implement a graphical representation of quick sort in i386 assembly though :-/
23:41:20 <Cale> hehe
23:41:20 <LordBrain> fun
23:41:24 <LordBrain> hehehe
23:41:28 <marcelino> there are still some things like kernel development os i think that haskell is not suitable for
23:41:39 <LordBrain> probably
23:41:48 <Cale> Some people disagree. There are people writing an L4 kernel in Haskell :)
23:41:59 <marcelino> but there are oses coming out that use it for scripting and package management ala python gentoo
23:42:26 <Adamant> BitC looks interesting
23:42:32 <LordBrain> linspire has embraced haskell from what i understand
23:42:35 <Adamant> if you're into OS building
23:42:39 <Cale> http://www.cse.ogi.edu/~hallgren/House/
23:42:45 <marcelino> so does bitchx
23:42:58 <Adamant> wtf?
23:43:01 <stepcut> Adamant: yeah, that seems like an interesting project -- given Shapiro's background
23:43:02 <LordBrain> joke?
23:43:14 <Cale> LordBrain: joke?
23:43:20 <LordBrain> bitchx
23:43:35 <LordBrain> it's an irc client... not sure what it is interesting for
23:43:46 <dons> http://www.ertos.nicta.com.au/research/sel4/tech.pml -- the L4/Haskell project
23:43:53 <Cale> It's not interesting, at least, it wasn't last time I looked at it
23:44:00 <Cale> (bitchx)
23:44:06 <Adamant> I think BitC will probably succeed before a HaskellOS or LispOS
23:44:39 <Adamant> since I think they are trying to orient the language toward pulling in existing systems programmers
23:44:48 <stepcut> Adamant: BitC is a language...
23:44:59 <Adamant> well, I mean, something based on it
23:45:11 <marcelino> anyone here have opinions on lua?
23:45:12 <Adamant> the CoyotOS they are writing
23:45:20 <dons> oh, that's nice "Haskell, as a functional programming language, is not a large paradigm shift for typical kernel programmers"
23:45:30 <Adamant> lololol
23:45:46 <stepcut> Adamant: Well, coyotos has more serious pursuit than HaskellOS anyway
23:45:48 <Stinger_> bitC has piqued my interest slightly, since I come from the c/c++ background
23:45:52 <Cale> dons: what?
23:46:07 <stepcut> Adamant: I think that is the most important factor
23:46:10 <marcelino> scripting is on the rise i think haskell could carve a niche for itself
23:46:18 <Cale> dons: what are you quoting?
23:46:42 <dons> Cale, I think since these guys are used to doing verification of their kernels, and most of them were taught haskell in comp1A
23:46:46 <dons> Cale, oh the l4/haskell page
23:47:09 <Adamant> I think there is recognition by systems guys that C is increasingly problematic
23:47:14 <Philippa_> dons: that, and you see macros with names like cons in a hell of a lot of code
23:47:16 <Adamant> and something needs to replace
23:47:20 <Stinger_> wish I was taught haskell in comp sci 1 :(
23:47:28 <LordBrain> yeah me too
23:47:34 <Adamant> I'm glad I wasn't
23:47:35 <marcelino> in the academic world scheme is very popular
23:47:40 <Cale> marcelino: and I actually find that surprising, since scripting-like tasks are not immediately easy with any Haskell implementation I know. Now, you can write libraries to make it easy, but it's not the first thing I'd think to use the language for.
23:47:44 <LordBrain> why's that Adamant ?
23:47:48 <Adamant> nor Scheme/Lisp
23:47:52 <Stinger_> I wish I was taught scheme in comp sci :P
23:48:00 <Adamant> I think imperative stuff is easier to teach
23:48:12 <Adamant> and learn, initally
23:48:12 <LordBrain> hmmm well i already knew C
23:48:13 <Cale> Adamant: It depends...
23:48:15 <marcelino> in fact http://www.scsh.net/ is really cool
23:48:16 <Stinger_> scheme is imperetive ;)
23:48:24 <Cale> Adamant: what's more natural, a loop, or map?
23:48:28 <LordBrain> gosh my school used pascal...
23:48:29 <dons> have you tried to teach it though? kids think like maths at first, out of high school
23:48:39 <marcelino> scheme is imperative functional logical whatever you want it to be
23:48:40 <dons> except the ones who were damages programming Basic
23:48:43 <Adamant> Cale - a loop, if you aren't good with math
23:48:51 <Cale> Adamant: If I go to wash my dishes, I don't start out by numbering them, and incrementing a counter.
23:48:59 <Cale> I just wash all the dishes
23:49:08 <Cale> which is somewhat like  map wash dishes
23:49:08 <dons> map wash dishes
23:49:16 <dons> jinx!
23:49:20 <LordBrain> lol
23:49:21 <Cale> hehe :)
23:49:24 <Adamant> but people number and count things all the time
23:49:37 <sebell> I still wouldn't count my dishes before washing them :)
23:49:39 <marcelino> cale that is why i like lispish languages there very general purpose and can handle scripting admirably
23:49:42 <Cale> Sure, they do, and you still can, it's a common idiom to zip [1..] xs
23:49:51 <Cale> :)
23:49:55 <LordBrain> scsh is nice
23:50:08 <Cale> and in some sense, you're ordering them by putting them in a list in the first place
23:50:09 <LordBrain> i enjoyed its regexes
23:50:19 <Adamant> I think it's bit like learning language
23:50:28 <Cale> but the thing is, we don't really think in recursion or loops
23:50:35 <Cale> we think in higher order functions
23:50:44 <dons> yeah. fold and map
23:50:52 <Cale> (or at least, something much closer to them)
23:50:53 <LordBrain> good point
23:50:56 <Adamant> some people do better with phoneics (sp..), others whole language
23:50:58 <dons> accumulating things, and transforming things
23:51:25 <LordBrain> and we think lazily too... meaning only when we have to j/k
23:51:31 <Adamant> and I think more people do better with imperative than Haskell/Scheme
23:51:39 <Adamant> convention imperative
23:51:43 <Cale> LordBrain: that's truer than you'd think
23:52:01 <marcelino> map is in scheme
23:52:01 <Cale> I think Haskell's a fine first language
23:52:03 <LordBrain> no actually, i do think it is true.. the joke was the play on the word...
23:52:09 <Cale> marcelino: of course,
23:52:09 <dons> Adamant: many universities teach functional languages first, since this seems to fit better, for the reasons described above
23:52:12 <Adamant> phoenics drove me nuts as a kid, because I learned whole language
23:52:21 <marcelino> foldl foldr that can all be simulated
23:52:23 <Cale> marcelino: we're discussing the imperative/functional divide
23:52:41 <Cale> marcelino: scheme has fold-left and fold-right, usually
23:52:52 <Adamant> dons - I talked to someone who did Haskell as a intro language at college
23:53:10 <marcelino> just read sicp it covers all that and more
23:53:12 <Adamant> the impression I got from him was that the failure rate was well above average
23:53:15 <Philippa_> Adamant: sample size of one. You can tell me what the statistical significance there is, right?
23:53:20 <LordBrain> the functional is probably less, since they should learn math anyway, they're required to go to calculus at least..
23:53:31 <Philippa_> yes. Guess what? A lot of the other courses let through people who can't code
23:53:39 <dons> yeah, nothing to be said there. failure rates are high in first year college in lots of places :)
23:53:40 <Philippa_> watched that happen enough...
23:53:50 <Adamant> dons - I know
23:54:04 <dons> we fail something like 30-40% in the first semester here. whether we teach them Haskell or C :)
23:54:08 <dons> the more the better, I say!
23:54:15 <Adamant> what struck me was that it was like 70%
23:54:17 <Cale> I'm fairly sure failure rates are even high at Waterloo, and they're using Java.
23:54:20 <Adamant> if he could be believed
23:54:43 <marcelino> waterloo is overated
23:54:43 <Adamant> and that's way higher that here or any other college I've seen
23:54:45 <LordBrain> its actually good for existing developers if the langauge has a barriar to entry, economically... it's professionalization resulting in higher salaries. hehehe
23:54:51 <Cale> (though Scheme is actually an option now for those, it wasn't when I took them)
23:55:43 <Adamant> Philippa_, how many schools put people through Haskell in their first course? not many, that I know of
23:55:46 <marcelino> if you like a lisp uni i think cmu is good
23:55:54 <Adamant> CMU is ML heavy
23:56:08 <marcelino> there actually very lispy as well
23:56:14 <Cale> marcelino: It's decent. CS 241 was good. I took it along with a good chunk of all the mathematics students there, and you write a small compiler while learning scheme and unix.
23:56:15 <Philippa_> Adamant: the ones that do include some pretty notable places though. I believe Oxford do, for example
23:56:36 <marcelino> caltech is very mlish
23:56:39 <Cale> marcelino: The later courses in the CS program seem very interesting too, but I didn't get to take them, so I don't really know.
23:56:43 <Adamant> Philippa_, right, but they're not trying to create the next generation of average programmers, they're trying to create (and only accept) the elite
23:56:47 <Cale> marcelino: Like the real-time OS course.
23:56:49 <LordBrain> thats good tho... forcing it upon students is just going to create a lot of haskell hating... unless of course you want to hire me to teach haskell, i'll change my attitude :)
23:57:22 <Cale> LordBrain: Well, I don't think it's necessary that they hate it.
23:57:31 <dons> forcing Java created a generation of Java haters, I know.
23:57:33 <Philippa_> Adamant: given what the actual average is like, no biggie
23:57:40 <LordBrain> Cale: i'm sure you know what i mean..... you're a mathematician
23:57:44 <marcelino> cale i think uni only takes you so far..the rest your on your own...if you like haskell portland area seems good
23:57:50 <Philippa_> dons: wasn't helped by Java as was being even more neutered than it is now
23:58:03 <dons> true.
23:58:12 <Cale> LordBrain: I actually think that a lot of it has to do with whether the professors and TAs really know the language that well.
23:58:12 <LordBrain> yeah... i'm thinking of moving to oregon
23:58:22 <Philippa_> when all your containers're written in terms of Object, the phrase "safety my arse!" comes to mind
23:58:31 <dons> hehe
23:58:41 <Cale> LordBrain: I've seen Haskell assignments which were constructed by people obviously unfamiliar with the Prelude.
23:58:50 <Adamant> is anyone a Erlang fan here?
23:58:56 <marcelino> you can actually get a phd specializing in functinal languages/haskell in oregon unis
23:59:05 <dons> I love Erlang the movie, if that counts
23:59:20 <Adamant> it interests me, since it seems to be used for the kind of stuff I am interested in in the field
23:59:39 <Cale> LordBrain: as in, the assignment descriptions included functions which were given to you, but which were exactly the same as Prelude functions, only named more awkwardly.
