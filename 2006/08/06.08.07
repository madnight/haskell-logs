00:00:11 <dons> forall s . if dn g s == up g s then bi g s is valid
00:00:41 <dcoutts__> right
00:00:42 <dons> that's associativity?
00:00:49 <dons> on g. hmm
00:00:59 <dcoutts__> for strConsumerBi I think it is
00:01:14 <dons> oh, for ConsumerBi, hmm.
00:01:19 <dcoutts__> it's like foldl vs foldr
00:01:28 <dcoutts__> they're == if the op is associative
00:01:40 <dcoutts__> as for strTransformerBi
00:02:05 <dons> i'll see if I can state this as a QC property
00:02:13 <dcoutts__> a sufficient condition is if it has no state it passes along
00:02:26 <dons> oh, we had a similar rule for the old rewrite system
00:02:27 <dcoutts__> that it's only a per-element function
00:02:52 <dons> for sequenceloops
00:03:43 <dcoutts__> ah yes
00:03:43 <dons> right.
00:04:09 <dons> hmm. no state passed along.
00:04:23 <dons> what about length in terms of a foldl ?
00:05:00 <dons> oh, no state is requried for transformers for transformers.
00:06:10 <dcoutts__> dons: oh, did you meet with the ogg chap?
00:06:26 <dons> yes!
00:06:28 <dons> ?seen kfish
00:06:28 <lambdabot> I saw kfish leaving #haskell 2 hours, 22 minutes and 29 seconds ago, and .
00:06:39 <dons> he's happily working away on the haskell code
00:06:43 <dcoutts__> cool
00:06:45 <dons> seems quite advanced
00:06:57 <dcoutts__> so pure haskell ogg decoder?
00:07:02 <int-e> For strConsumerBi, If I understand it correctly, your *S functions are basically folds of some underlying function - I think you need to talk about that underlying function. If that's associative, using strConsumerBi is ok. Actually I think that's true for the transformers, too.
00:07:02 <dons> right
00:07:22 <dons> int-e, yes. I think that's right.
00:07:32 <dons> so that's what we meant by : bi g, g is associative
00:07:40 <dcoutts__> though for transformers the condition is not quite the same
00:07:44 <dcoutts__> I think
00:09:04 <dcoutts__> dons: actually it's not even quite that simple for the consumer
00:09:17 <dcoutts__> because it's not an element function that you pass to fold
00:09:26 <dcoutts__> but a Stream consumer function
00:09:59 <dcoutts__> so the property needs to be expressed in terms of Streams
00:10:16 <int-e> I meant folds on Streams btw :)
00:10:19 <dons> well, I can write: prop_bi (Stream f) s = strConsumerUp f s == strConsumerDn f s
00:10:39 <dons> however, if we want to state associativity on streams
00:10:45 <dons> i'll need a different formulation
00:12:27 <dcoutts__> and it's only true for finite streams?
00:13:01 <dcoutts__> which is ok for strict byte strings
00:13:37 <dons> well, it will be true for the existing StreamConsumerBis we have: lengthS, maximumS, minimumS
00:13:47 <dons> all of which are finite
00:16:01 <dcoutts__> yes
00:27:28 <dons> ?bot
00:27:28 <lambdabot> :)
00:27:35 <dons> good bot
00:27:49 * Heffalump wonders if there's any sensible way to make UArray an instance of Data
00:28:35 <int-e> I changed my mind - you need (x `f` a) `f` b = (x `f` b) `f` a  for the underlying function (x is the initial value, a and b are stream elements), which is some sort of commutativity. This is for stream consumers, and ensures that stream reversal doesn't change the result.
00:28:40 <int-e> (for finite streams)
00:30:36 <dons> oh, that sounds reasonable
00:31:08 <dons> yes, so that's not associativity though
00:31:24 <int-e> and for stream consumers that leaves map and filter. producing more than one element from a source element will fail, as does carrying state along.
00:31:29 <int-e> *transformers
00:31:59 <dcoutts__> I think it's associativy with a left & right unit
00:33:15 <dcoutts__> ((0 % a) % b) % c == a % (b % (c % 0))
00:33:21 <roconnor> ?what Data
00:33:21 <lambdabot> I know nothing about data.
00:35:10 <int-e> what's the %?
00:36:44 <int-e> for Transformers you need something like f . reverse = reverse . f :)
00:37:08 <dons> quite so.
00:37:32 <int-e> which means f [a] = reverse (f [a]) ... hence only 0 and 1-element lists are allowed as results
00:37:44 <int-e> and the state thing should be obvious.
00:37:57 <int-e> (using list notation for streams)
00:38:58 <musasabi> dcoutts__: "[Bytestring] -> ByteString.Lazy is just a O(n) lazy check" <- what kind of check?
00:39:26 <dons> stripping []
00:39:38 <dons> no empty chunks can appear in a lazy bytestring
00:40:04 <musasabi> point
00:40:34 <musasabi> but that is just List.filter (not . null)
00:40:41 <dons> right
00:41:13 <int-e> Ok, the state thing isn't absolutely true. You can do some fun stuff with lazy evaluation there. But it won't be efficient. (you can, I think, write a StrTransformerBi that produces the stream [length <original stream>])
00:42:30 <int-e> carrying no state around and never producing more than one element for a source element is sufficient though.
00:43:48 <int-e> Ah, of course, every consumerBi can in principle be turned into a transformerBi that produces a one-element stream :)
00:45:27 <dons> bbl
00:49:14 <saurik> there wouldn't happen to be a way anyone knows of to _bypass_ an IO monad? I'm working on a C++ parser, and I had the preprocessor returning a [Token], which the parser could start working on immediately (as it was handled lazily), but now that I implemented #include in the preprocessor step I have to return IO [Token] and the preprocessor has to finish completely before the compiler starts
00:50:46 <ProfTeggy> System.IO.Unsafe.unsafePerformIO :: IO a -> a
00:50:56 <saurik> AWESOME!
00:51:01 <saurik> thank you so much
00:51:30 <musasabi> saurik: You might want to look at http://www.cs.york.ac.uk/fp/cpphs/
00:52:52 <Heffalump> saurik: do you know about lazy IO?
00:53:10 <Heffalump> unsafeInterleaveIO would probably be a better thing to use
00:53:27 <Heffalump> or one of the things built  on it, like hGetContents
00:53:35 * ProfTeggy nods
00:53:44 <saurik> musasabi: thanks as well; I'm at least half working on this simply to learn haskell, however; (although, looking at it, it's much more text oriented than what you'd want from an integrated compiler step)
00:54:22 <saurik> Heffalump: no, I'll look at the differences between those two
00:54:39 <saurik> Heffalump: thanks as well
00:54:58 <musasabi> I think cpphs has some solution to the #include-problem.
00:56:27 <Heffalump> saurik: basically, there's no reason why IO [Token] can't produce the list of tokens lazily.
00:57:28 <saurik> Heffalump: hmmm... I was basing my conclusion off experimental evidence, combined with an understanding that the IO monad explicitly sequenced the operations bound through it
00:58:24 <audreyt> hm. this is fun:
00:58:25 <audreyt> class ((:>:) a) b where cast :: b -> a
00:58:28 <audreyt> class ((:<:) a) b where castBack :: a -> b
00:58:30 <audreyt> instance (b :<: a) => (:>:) a b where cast = castBack
00:58:33 <audreyt> instance (:<:) a a where castBack = id
00:58:43 <audreyt> only "cast" is used
00:58:46 <saurik> do { source <- getSourceSet cpp; tokens <- toTokens source; putTokens tokens } -- approximately what I'm doing
00:59:14 <saurik> getSourceSet uses hGetContent and does all the really low-level character transforms, returning IO [String]
00:59:23 <audreyt> but that allows
00:59:25 <audreyt> newtype N = N T deriving ((:>:) T, (:<:) T)
00:59:49 <saurik> toTokens returns IO [Token], and putTokens just iterates the list and outputs them
00:59:51 <audreyt> which seems to be a win over the mkN/unN style boxers
01:00:45 <saurik> when I had  do { source <- getSourceSet cpp; let tokens = toTokens in putTokens tokens } and toTokens returned [Token] putTokens output all the tokens up until an error (as the error didn't happen until it was request)
01:01:21 <saurik> but now error happens immediately and no output is performed, which indicates to me that the toTokens had to complete before it could do putTokens
01:02:20 * saurik gets the source of cpphs to see if they bothered to address this (I don't really think they had to... what looked like the main interface returned IO String and it can just output the tokens as it gets them as it probably doesn't need to be flexible about people re-parsing the output in haskell)
01:04:37 <saurik> ok, they _do_ handle this, and they use unsafePerformIO
01:09:00 <Heffalump> audreyt: a win in what sense?
01:09:46 <musasabi> audreyt: seems like an empty win when it cannot be used in method type signatures (at least yet)
01:10:58 <musasabi> e.g. I can have "instance Foo x where foo :: Wrap x -> Bar" but not "instance Foo x where foo :: Wrap x w => w -> Bar"
01:11:25 <musasabi> then again that should be fixed in the future
01:11:51 <saurik> thanks everyone again, unsafePerformIO worked great (and I'll still spend some time researching unsafeInterleaveIO to see if I need it instead)
01:12:46 <musasabi> (where in the second case Wrap is defined as "class Wrap a b | a -> b, b -> a"
01:15:08 <audreyt> Heffalump: a win in the sense of having a derivable upcast
01:15:38 <audreyt> newtype N = N T deriving ((:>:) T, (:<:) T)
01:15:42 <audreyt> newtype N2 = N2 N deriving ((:>:) T, (:<:) T, (:>:) N, (:<:) N)
01:15:58 <audreyt> and N2/T can be used also interchangeably with "cast"
01:17:38 <Heffalump> hmm, might be handy, but doesn't seem all that important to me
01:17:58 <audreyt> *nod*
01:18:21 <audreyt> very handy here, as a perl6 Str object is five time removed from a ByteString
01:18:28 <audreyt> three of them are newtypes :)
01:19:02 <Heffalump> why is it that removed?
01:19:31 <audreyt> variants
01:20:26 <audreyt> ByteString is first made into a NativeBuf (newtype, for a different Show), then into a PureStr (data, for string segments and unicode)
01:21:08 <audreyt> then to Val (data, existential type constructor), then to Object (adding metaclass)
01:21:38 <audreyt> then newtype'd to a boxed object
01:21:40 <audreyt> hm. only two newtypes.
01:22:06 <audreyt> but anyway. letting "cast" figure out all the intermediate constructors for me is nice :)
01:49:09 <Manyfold> what is a monad ?
01:49:59 <User20> hello
01:50:43 <User20> like to make friends with a hacker
01:51:36 <User20> who is from vietnam
01:54:09 <User20> any hacker online
01:55:16 <wilx> o_O
01:55:44 <kowey> Manyfold: there are many ways to answer your question... first of all have you done a little Haskell programming?
01:56:06 <Manyfold> very little
01:56:53 <kowey> is there a language you are more comfortable with, like ruby or python?
01:57:04 <Manyfold> java
01:57:42 <Manyfold> but java is not pissy about side-effects
01:58:14 <kowey> ah, ok, so you've got some awareness about what monads are for, then, right?
01:58:28 <kowey> one way of explaining it is that monads are useful for letting in a wee bit of
01:58:42 <kowey> imperative-style programming into a pissy-about-side-efects language
01:58:46 <kowey> but only just enough
01:58:53 <kowey> and still keeping it cleanly separated
01:58:56 <sieni> Manyfold: I found the explanation of monads as containers helpful: http://www.haskell.org/haskellwiki/Monads_as_Containers
01:59:04 <lambdabot> Title: Monads as Containers - HaskellWiki
02:02:04 <saurik> I havefound a lot of strong positive references to http://www.nomaware.com/monads/html/index.html, which I found helpful
02:02:22 <lambdabot> Title: All About Monads
02:02:49 <kowey> this one might also be useful, if you're more comfortable with java than Haskell
02:02:52 <kowey> http://www.linuxjournal.com/comment/reply/8850
02:03:09 <lambdabot> Title: Add new comment | Linux Journal
02:03:20 <kowey> oops: http://www.linuxjournal.com/article/8850
02:03:21 <lambdabot> Title: Everything Your Professor Failed to Tell You About Functional Programming | Linu ...
02:05:00 <boegel> @seen shapr
02:05:01 <lambdabot> I haven't seen shapr.
02:05:05 <boegel> :/
02:05:10 <boegel> @seen Lemmih
02:05:11 <lambdabot> Lemmih is in #haskell-overflow, #haskell-blah and #haskell. I last heard Lemmih speak 8 hours, 51 minutes and 21 seconds ago.
02:05:34 <boegel> Lemmih: do you know anything about the job interviews at Cambridge? how did it go?
02:05:39 <boegel> @where AngloHaskell
02:05:55 <lambdabot> http://haskell.org/haskellwiki/AngloHaskell
02:41:52 <dons> ?users
02:41:54 <lambdabot> Maximum users seen in #haskell: 216, currently: 201
02:51:47 <mux> dons: I'll have to add FreeBSD ports for the HTTP module and HXT
02:51:57 <mux> now that HXT only needs that module, I have no excuses anymore
02:52:12 * mux notes the new releases of HXT and HTTP were done the day of his birthday
02:52:15 <mux> look like some kind of gift
02:52:46 <flabian> Hi. Which editor do Haskellers use?
02:52:52 <mux> vim!
02:53:04 <flux__> emacs and vi. and yi I suppose (or hIDE?)
02:53:33 <roconnor> I use kate
02:53:35 <flabian> Does Vim have a good Haskell mode?  I thought most Haskellers were using Emacs, and therefore the Haskell support on it is much better.
02:53:47 <roconnor> I hate all editors.
02:53:59 <mux> well, vim works flawlessly here
02:55:31 <flabian> mux: I don't doubt it does, but someone told me the Emacs Haskell mode is niftier.
02:56:43 <mux> well, you'd have to define niftier :-)
02:57:19 <kosmikus> it automatically finds all indendations you don't want
02:58:46 <flabian> mux: I'm an Emacs Ruby user, so I know very little about Haskell on Vim :)
02:58:58 <mux> heh
02:59:24 <dons> vim works fine. quite a few people use it.
02:59:26 <mux> I'm a big emacs hater
02:59:41 <musasabi> The emacs mode seems nicer (ghci integration + auto-indent)
02:59:46 <mux> don't like the feeling of it, of course this is totally subjective
02:59:58 <Stinger_> your opinion is wrong! :)
03:00:00 <flabian> I like Emacs very much, and it has more features, but it also has more issues.
03:00:04 <mux> I do all my development with vim, whatever the language is
03:00:09 <norpan> vim rox
03:00:17 <mux> saying emacs has more features over vim or the opposite sounds like bullshit to me
03:00:26 <dons> yeah, emacs has more haskellish features set up
03:00:28 <dons> the vim/haskell commuity should really get its act together ;)
03:00:32 <mux> both editors have an incredibly large list of features and both can be tweaked to death
03:00:44 <flabian> mux: but it does; you don't have inferior modes in Vim.
03:01:00 <mux> I don't even know what "inferior modes" means
03:01:01 <Stinger_> minor modes?
03:01:09 <mux> probably something I wouldn't even use :-P
03:01:12 <norpan> emacs is one big inferior mode, yes :)
03:01:14 * musasabi would like to switch to vim (or yi) for my Haskell needs, but auto-indent + ghci are something that I want.
03:01:20 <mux> norpan: haha, <3
03:01:26 <flabian> interaction modes: e,g, opening a shell inside an Emacs buffer
03:01:27 * kowey indents by hand (vim)
03:01:31 <mux> vim has auto-indentation, duh
03:01:36 <lde> mux: i like vim, but emacs has a lot more features
03:01:37 <mux> flabian: of course you can do that with vim!
03:01:42 <flabian> mux: you would use them, trust me.
03:01:49 <flabian> mux: I asked and I was told you can't.
03:01:54 <mux> who said that?
03:02:06 <flabian> people on #vim
03:02:06 <dons> there's a partial vim indenting I worked on
03:02:12 <mux> uh?
03:02:18 <mux> I use shell commands very often in vim
03:02:30 <mux> I filter text through commands, run commands to get output etc etc
03:02:32 <norpan> i use vim with autoindent
03:02:33 <dons> but i gave up once i realised I was part way through rewriting a haskell lexer in vimscript..
03:02:33 <flabian> mux: yeah, but you can't interact with a shell withing Vim.
03:02:44 <mux> flabian: how so?
03:02:46 <dons> norpan: not haskell autoindenting though
03:02:55 <norpan> i.e. vim indents a new line to the same level as the previous one
03:02:56 <lde> mux: how many irc clients for vim are there? :-)
03:03:03 <dons> a couple?
03:03:08 <mux> yes, several
03:03:10 <ValarQ> ed(1) !
03:03:11 <flabian> mux: with Emacs, I can open an e.g. Python interpreter and actually script it from Emacs.
03:03:12 <mux> and it's braindead anyways
03:03:14 <norpan> why would you run an irc client in your editor
03:03:18 <mux> so emacs is better because it has irc clients
03:03:19 <mux> rofl
03:03:19 <flabian> it's super convenient.
03:03:21 <dons> i've used one.
03:03:21 <dmhouse> ValarQ: cat(1)! :)
03:03:22 <lambdabot> dmhouse: You have 1 new message. '/msg lambdabot @messages' to read it.
03:03:28 <mux> that's a good example of how fucked up the emacs community is :-)
03:03:46 <lde> oh, i tought there was only one
03:03:48 <flabian> nope, it's a good exmaple of how you can do everything with Emacs.
03:03:52 <kowey> wait, so is there anything vim'ers here would agree, we "need" most?
03:03:55 <ValarQ> dmhouse: less(1) is also a good editor, to bad it can't edit files thought :/
03:03:58 <mux> it's a good example of things you shouldn't do with an editor
03:04:10 <dmhouse> mux: IRC clients inside your editor are actually convenient, but I wouldn't say it's the killer feature of Emacs.
03:04:13 <mux> emacs is a decent OS, too bad it doesn't come with a correct text editor
03:04:17 <flabian> mux: who said so? :)
03:04:20 <mux> :-P
03:04:26 <mux> flabian: I do
03:04:28 <norpan> since haskell syntax depends on indenting, how can you have automatic indenting for haskell
03:04:43 <flabian> mux: choice is good, the problem with Emacs is that you can write IRC clients for it, but the basic stuff sometimes doesn't work.
03:04:56 <Stinger_> norpan press tab and it cycles through sensible points
03:04:56 <ValarQ> norpan: you can't have completely automatic indenting
03:05:05 <flabian> with all due respect for erc, I'd like to see syntax highlighting working in 2006.
03:05:17 <dmhouse> norpan: it finds the multiple possible points where it could indent to. Pressing TAB once indents as deep as possible, then you keep pressing tab to cycle through the possible points.
03:05:36 <lde> there should be something like godwin's law for the phrase "emacs is a decent OS, too bad it doesn't come with a correct text editor" :-)
03:05:48 <mux> I so like this sentence
03:05:57 <mux> it sums things up neatly
03:05:59 <int-e> lde: that's too late. we want to stop vim vs. emacs discussions way earlier.
03:06:22 <mux> mm, lunch time
03:06:23 <ValarQ> the old "haskell-mode"s isn't that great thought (prior to 2.1)
03:06:28 <flabian> I'd never look beyond Emacs if the basic stuff would work at long last.
03:06:31 <gds> int-e: We could have the lambdabot point at the yi archive whenever anyone mentions them?
03:06:34 <gds> ;)
03:06:44 <norpan> i wonder if you can have that semi-automatic indenting stuff for vim
03:06:45 <ValarQ> the default indentation for do-notation was a bit irritating
03:07:28 <dmhouse> flabian: the 'basic stuff'?
03:07:35 <mux> any vim vs emacs discussion where arguments consist of "X has more features" is doomed to fail horribly
03:07:49 <flabian> dmhouse: syntax highlighting, especially for multi-modes.
03:08:03 <dmhouse> I wouldn't call multiple major modes 'basic functionality'.
03:08:17 <flabian> after all these years, even single-mode Python SH is partly broken.
03:08:18 <musasabi> mux: the discussion could be helpful if it did motivate someone to fix thing in the one lagging behind.
03:08:41 <mux> musasabi: *nods* maybe #haskell isn't such a  good place for this in that case then :-)
03:08:44 <dmhouse> flabian: well, fix it! Elisp is easy to hack on.
03:08:57 <mux> unless Bram is in here and I didn't notice?
03:09:02 <dmhouse> (What's the 'SH'?)
03:09:06 <flabian> dmhouse: if GvR and Tim Peters didn't manage to, I don't think I will :)
03:09:25 <flabian> dmhouse: also, I actually asked about this, and it seems the problem is that the SH algos are limited.
03:09:27 <int-e> dmhouse: that's easy to deduce from the context ;)
03:09:55 <flabian> they can handle certain hueristics, but when a decision about how to color a piece of syntax is too compelx, they're just not up to it.
03:10:04 <dmhouse> int-e: shell?
03:10:14 <int-e> dmhouse: syntax highlighting
03:10:14 <dmhouse> Oh, syntax highlighting :)
03:10:18 <musasabi> mux: #haskell is a good place to complain about Vim haskell support as there are multiple people who think Vim > Emacs here and one of them may get motivated enough to actually fix things. </hopeful>
03:10:19 <dmhouse> I was used to 'font locking'.
03:10:43 <kowey> but what actually needs fixing?
03:10:45 <mux> musasabi: tough luck :)
03:11:06 <kowey> (i do sense vaguely, the vim/haskell situation could be improved, but can't put my finger on it)
03:11:43 <norpan> i'd rather have hide/yi though
03:11:44 <dmhouse> kowey: I got your message. Did you see the 'Translating Haskell to English' tutoriall?
03:12:00 <kowey> i glance through it
03:12:07 <kowey> what was my message about, again?
03:12:12 <dcoutts__> dons: another thing I talked to JaffaCake about, was allocating and triming mutable byte arrays
03:12:16 <dmhouse> norpan: I'd love to be able to use Haskell to hack on Emacs, but I don't think that's feasible. Beyond that, Emacs is good enough for me.
03:12:30 <dons> ah, yes?
03:12:32 <dcoutts__> dons: so trimming should be easy, though reclaiming memory less so
03:12:36 <dons> dcoutts__: --> overflow
03:12:40 <dcoutts__> arr
03:12:42 <Bacta> sex
03:12:43 <Bacta> sex
03:12:43 <Bacta> sex
03:12:44 <Bacta> sex
03:12:44 <Bacta> sex
03:12:45 <Bacta> sex
03:12:46 <Bacta> sex
03:12:46 <Bacta> sex
03:12:48 <Bacta> sex
03:12:50 <Bacta> sex
03:12:52 <mux> hrm.
03:12:52 <Bacta> sex
03:12:54 <Bacta> sex
03:12:56 <Bacta> sex
03:12:56 --- mode: ChanServ set +o musasabi
03:12:58 <Bacta> sex
03:13:00 <Bacta> sex
03:13:02 <Bacta> sex
03:13:02 --- kick: Bacta was kicked by musasabi (musasabi)
03:13:05 <dcoutts__> yay
03:13:06 <mux> cheers
03:13:09 --- mode: musasabi set -o musasabi
03:13:13 <flabian> wtf?
03:13:15 <dmhouse> musasabi wins the first-to-op-up race.
03:13:21 <dons> yeah, way to slow over here
03:13:23 <flabian> what's the point of that?
03:13:25 <norpan> only because i can't
03:13:29 --- mode: ChanServ set +o dmhouse
03:13:35 <Stinger_> lol dm
03:13:51 <Stinger_> omg precognitive
03:14:01 <cm> salut
03:15:33 <flabian> Bacta: what sort of mental satisfaction do you obtain by flooding a channel like that?
03:15:36 <Bacta> s e x
03:15:38 --- mode: dmhouse set +b *!*=silvermo@*.bliink.ihug.co.nz
03:15:39 --- kick: Bacta was kicked by dmhouse (dmhouse)
03:16:11 <Itkovian> he jerks off by seeing the word sex on screen, I guess
03:16:27 <musasabi> dmhouse: thanks
03:16:41 <flabian> Itkovian: we should suggest Notepad the next time :)
03:16:43 --- mode: dmhouse set -o dmhouse
03:17:03 <Itkovian> flabian: good thinking
03:17:17 <Itkovian> supposedly he can type one-handedly
03:17:27 <dmhouse> My very first kickban. :)
03:17:29 <mnislaih> it reminds me of http://bash.org/?627168
03:17:43 <lambdabot> Title: QDB: Quote #627168
03:17:52 <flabian> haha
03:17:57 <ValarQ> dmhouse: congratulations
03:17:59 <kowey> well, all three letters are on the left of the keyboard
03:18:14 <dons> ?karma+ dmhouse
03:18:30 <lambdabot> dmhouse's karma raised to 2.
03:18:40 <ValarQ> reminds me of that documentationwriter for databases
03:19:35 <ValarQ> he got pretty tired in his left hand after writing "databases" in the documentation often :)
03:21:10 <Cale> "Woe to you, my Princess, when I come... you shall see who is the stronger, a gentle girl who doesn't eat enough or a big wild man who has cocaine in his body." - Sigmund Freud, in a letter to his fiancée.
03:22:32 <flabian> Cale: any special reason for that quote?
03:22:59 <Cale> It just struck me as interesting
03:23:07 <qz> just ran across some 'real world' haskell application and it scared me :| http://www.cse.unsw.edu.au/~pls/repos/frag/ObjectBehavior.hs   now i wonder if language really has application besides being pure and functional and all that
03:23:39 <flabian> Cale: Frankly, there are a lot more interesting Freud quotes :)
03:23:57 <Cale> qz: wow, arrows code without any of the syntax sugal
03:23:58 <flabian> this just sounds like a mundane piece of personal correspondence.
03:24:01 <Cale> sugar*
03:24:07 <Cale> flabian: heh
03:25:25 <dmhouse> qz: that's because they're using the points-free arrowic style instead of the nicer, but newer, sugar.
03:26:13 <qz> dmhouse, you think newer sugar can improve readability of that code alot?
03:26:20 <dmhouse> qz: yeah, I think so.
03:26:24 <Cale> certainly
03:26:40 <dmhouse> qz: would make a nice exercise to translate one or two of those functions.
03:26:59 <flabian> Cale: "How bold one gets when one is sure of being loved! ", "If youth knew; if age could.", "Love and work are the cornerstones of our humanness."
03:27:07 <flabian> and on that note, laters :)
03:27:23 <kowey> the arrow sugar seems to be less straightforward than the monads one
03:27:28 <Cale> None of those quotes mention his cocaine addiction :)
03:27:31 <kowey> but maybe i'm just more used to the latter
03:28:43 <Cale> kowey: it really is
03:28:56 <dmhouse> kowey: well, arrows are structurally more complicated than monads.
03:29:05 <kowey> Cale: it really is straightforward? or less so?
03:29:11 <Cale> less so
03:29:13 <Cale> http://www.haskell.org/arrows/sugar.html
03:29:15 <lambdabot> Title: Haskell Proposal: Syntactic Sugar for Arrows
03:29:28 <kowey> oh :-( yeah, I kept trying to read that page and digest it for the wikibook
03:30:11 <Cale> I almost wonder if the translation is really meant to be well-understood.
03:30:15 <kowey> one thing that confuses me is the two different ways to translate, for example
03:30:17 <kowey> http://www.haskell.org/arrows/syntax.html
03:30:18 <lambdabot> Title: Arrow syntax
03:30:28 <kowey> does the one here require arrows that are equivalent to monads?
03:30:44 <kowey> from all the tuple stuff you see, i get that impression
03:30:56 <Cale> arrows satisfy a bunch of laws
03:31:12 <Cale> and you can use those laws to prove things like that those two functions are the same
03:31:42 <Cale> see that pretty diagram they draw?
03:31:51 <kowey> yeah
03:31:56 <Cale> That's what the code is "really describing"
03:32:14 <dmhouse> It'd be cool to be able to program with diagrams like that.
03:32:28 <Cale> that's kind of what the sugar gives you, kind of
03:32:48 <Cale> Of course, flattened down a bunch into a list of arrows
03:33:49 <kowey> i guess, comparing that to monads, forgetting about the syntax stuff...
03:34:14 <kowey> we could also write something like \x -> do { y <- f x ; z <- g x ; return (y+z) }, but...
03:34:23 <Cale> yes
03:34:28 <kowey> the difference is that here we're making things sequential when they're really not?
03:34:53 <Cale> for one, yeah
03:35:24 <Cale> note that that's the difference between the two translations
03:35:41 <Cale> The first does f and g in sequence
03:35:53 <Cale> while the second combines them with &&&
03:36:21 <kowey> and is the preprocessor still "not that smart?"
03:36:34 <Cale> I don't know
03:36:51 <kowey> do those two translations correspond to the two translations on the http://www.haskell.org/arrows/sugar.html page ?
03:36:52 <lambdabot> Title: Haskell Proposal: Syntactic Sugar for Arrows
03:38:39 <Cale> hmm, is there really more than one?
03:39:12 <kowey> well, the page says there are two cases (so i guess it's pretty hard and fast),
03:39:24 <kowey> the first being "if Vars(f) and Vars(p) disjoint"
03:39:32 <kowey> and the other being "otherwise"
03:39:59 <kowey> uh... in proc p -> f -< e that is
03:40:19 <musasabi> The arrow class should include the operations the arrow syntax is compiled to.
03:40:47 <dmhouse> They do, don't they?
03:40:59 <dmhouse> Not in the papers, but in reality, things like second are in the class.
03:41:00 <musasabi> thus we would have: pure_fst :: a (t,any) t, pure_snd, and maybe pure_flip
03:41:29 <musasabi> dmhouse: the syntax compiles into lots of things like "arr fst"
03:41:41 <dmhouse> Ah.
03:46:24 <kowey> oh! the two translations on the Arrow syntax page make much more sense if you understand &&& as being implemented in terms of the other arrow functions
03:46:34 * kowey advances by 3 cm!
03:49:37 <cm> o0
03:53:13 <dmhouse> ?type (&&&)
03:53:14 <lambdabot> forall (a :: * -> * -> *) c' c b. (Arrow a) => a b c -> a b c' -> a b (c, c')
03:54:42 <dmhouse> ?type (<<)
03:54:45 <lambdabot> Not in scope: `<<'
03:55:16 <dmhouse> ?hoogle (<<)
03:55:33 <lambdabot> Did you mean: (<<)
03:55:33 <lambdabot> Prelude.undefined :: a
03:55:33 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
03:56:10 <lisppaste2> dmhouse pasted "Weird hoogle output" at http://paste.lisp.org/display/23776
03:56:37 <dmhouse> ?ask ndm whether http://paste.lisp.org/display/23776 is correct or a bug. Specifically the first line, but the other two results are a bit weird too.
03:56:38 <lambdabot> Consider it noted.
04:31:27 <dons> Cale, yay!
04:31:42 <dons> spj writes: "You caught me at a succeptible moment. I've implemented -fextended-default-rules as you suggest."
04:33:16 <Cale> :)
04:33:18 <boegel> dons: do you know who got the job this weekend?
04:33:51 <dons> I do, but I'm not sure I should say. I wasn't even in Cambridge :)
04:33:51 <postman> Shouldn't this work in Hugs? :m Hugs.ST
04:34:04 <dons> boegel: they'll probably be an anouncement soon enough
04:34:21 <dons> postman: hmm. no.
04:34:28 <dons> what module are you looking for?
04:34:31 <dons> ?hoogle ST
04:34:34 <lambdabot> Control.Monad.ST :: module
04:34:34 <lambdabot> Data.Array.ST :: module
04:34:34 <lambdabot> Control.Monad.ST.ST :: data ST s a
04:34:50 <boegel> dons: who? shapr? or the company?
04:35:03 <postman> dons: Control.Monad.ST.Lazy
04:35:15 <dons> boegel, brain-typo: there'll probably be ..
04:35:17 <postman> dons: (this is how it's called in GHC)
04:35:29 <boegel> dons: hmm, ok
04:35:35 <dons> postman: hmm. maybe hugs doesn't have it?
04:35:43 <vincenz> Itkovian: !!!!!!!!!
04:35:46 <dons> oh, you need a package flag.
04:36:35 <Itkovian> vincenz: hi
04:36:40 <Itkovian> I just received word from Koen
04:38:33 <dons> postman: maybe check with ndm. he knows hugs quite well
04:41:05 <boegel> Itkovian: keep me posted :)
04:41:20 <postman> Is there otherwise any way to get plain Haskell 98 in GHC? Since now it accepts a program which is not Haskell 98 and I have no extensions enabled.
04:41:57 <musasabi> yhc is more picky I think
04:43:04 <musasabi> or nhc
04:44:36 <dons> postman: it should be just haskell98, unless you turn on -fglasgow-exts
04:44:46 <dons> except for some minor things , which you will be warned about
04:45:13 <mux> you do +98 with hugs, IIRC
04:46:04 <mux> yeah
04:46:09 <mux> and -98 to have extensions
04:46:14 <mux> just checked
04:48:24 <vincenz> boegel: seems you won't meet me
04:48:32 <postman> dons: I imported runST, and put in in a list. According to Qualified Typed for MLF, this shouldn't work in "Haskell" (which I assume is Haskell98). It seems that when you import some non-Haskell 98 thing, your module becomes "infected" automatically.
04:49:13 <Philippa> if the module's not typeable in Haskell98 then it has to be that way
04:49:36 <dons> postman, its also possible that QualifiedTypes for MLF doesn't describe H98.
04:49:49 <boegel> vincenz: why's that?
04:49:51 <dons> since it was written, when? 96?
04:50:09 <vincenz> boegel: I'm not here when my supervisor is coming to ghent and it seems the meeting will take place then
04:50:21 <boegel> oh, too bad
04:50:34 <postman> dons: It was presented at ICFP 2005, I think. Would be rather late?
04:50:42 <boegel> well, atleast I don't have to thae the train all the way to Ghent
04:50:44 <vincenz> yeah :/
04:50:54 <dons> postman, oh. brain explosoin :)
04:51:18 <dons> postman, hmm. "Haskell" might then even refer to some extended haskell, if the paper is that new.
04:51:32 <dons> unless it specifically says "works in Haskell 98"
04:51:57 <postman> dons: It says "doesn't work in Haskell", but it does.
04:52:23 <postman> dons: I think GHC just assumes extentions when you import some module which requires extensions.
04:52:39 <postman> dons: (as Philippa said)
04:52:47 <dons> yeah. maybe.
04:53:24 <postman> Although, it makes testing this impossible.
04:53:32 <musasabi> Has anyone looked at "A Modal Calculus for Effect Handling" by Nanevski? It looks quite interesting, but also as something that will take some time to understand.
04:54:05 <dons> postman. hmm. still, this sounds strange. I'd expect a type error
04:54:09 <dons> as hugs does
04:54:14 * dons thinks
04:55:17 <postman> dons: How do you get hugs to have runST in scope?
04:56:07 <dons> oh, I've just noticed on other occasions that hugs will fail on standard modules, that use extensions (since its interpreting it all)
04:57:32 * mux finally set up a haskell environment on his work box so that he can have some fun when he's bored
05:04:53 <Stinger_> heh 70 odd % of my uni account is occupied by ghc :)
05:05:00 <vincenz> woo
05:05:05 * vincenz received the reasoned schemer
05:05:09 <vincenz> it read so funny
05:05:20 <vincenz> even has like empty parts at the bottom of the page [THIS IS A NAPKIN]
05:05:46 <vincenz> or
05:05:52 <vincenz> [THIS SPACE RESERVED FOR CARROT STAINS]
05:07:11 <vincenz> anyways
05:07:17 <vincenz> the content of the book is incredibly drooly :)
05:07:20 <vincenz> recommended buy
05:08:16 <kosmikus> vincenz: that book was about how to do logic programming in scheme, right?
05:08:28 <vincenz> kosmikus: yeah
05:08:39 <vincenz> kosmikus: third author is oleg
05:08:42 <kosmikus> yes, I saw it recently at a bookstore. looked nice.
05:09:01 <vincenz> are the other *schemer boooks as nice?
05:09:07 <vincenz> or are they too newbie oriented?
05:09:33 <kosmikus> I only have the first, and that's too easy
05:09:38 <kosmikus> I mean, it's still a nice book
05:09:50 <vincenz> *has to order all books at amazon so needs to know in advance which books are nice* no good english language CS store around here
05:10:17 <kosmikus> but it explains stuff that's trivial if you're usually working in a statically typed language
05:10:25 <BCoppens> vincenz: no het computerwinkeltje near you?
05:10:42 <vincenz> BCoppens: don't think so no
05:10:49 <mux> it's hard to find very technical books in bookstores
05:10:52 <vincenz> but don't they typically have old stuff or like java in 10 days
05:11:00 <mux> I know of a *single* place in Paris that has those
05:11:18 <vincenz> learn how to do game programming in 21 days
05:11:19 <BCoppens> vincenz: Mechelen, Gent and Brugge
05:11:35 <vincenz> BCoppens: ah mechelen ain't too far :) is it good?
05:12:03 <vincenz> BCoppens: cause mainstream it literature on stuff like javascript, perl and how to do use apache are not my interest
05:12:06 <BCoppens> vincenz: well they usually need to order the books I want =) But yeah, it has a pretty collection usually
05:12:26 <BCoppens> vincenz: my last book I bought there was on computational complexity, so I'd say they have a nice choice ;)
05:12:27 <vincenz> *is an amazon-addict*
05:12:50 * BCoppens doesn't have a credit card, so amazon is not really as fun ;(
05:12:54 * mornfall spots BCoppens 
05:12:58 * BCoppens spots mornfall 
05:13:04 <vincenz> and the other nice thing of amazon is their suggestions :)
05:13:13 <BCoppens> vincenz: that's true
05:13:56 <mux> People that bought "Haskell programming" also loved: "Windows XP for newbies", "Marvel Comics"
05:14:05 <vincenz> my recommnedations state: zen buddhism, c++ stuff, functional programming stuff, and some physics stuff*
05:14:14 <mux> zen buddhism heh :)
05:14:22 <vincenz> mux: my recommendations are pretty on topic
05:14:26 <BCoppens> hah =)
05:14:37 <vincenz> tho I don't care about a lot of c++ books
05:14:46 <mux> vincenz: I sometimes saw stupid suggestions, but really not often, I was just kidding.
05:14:47 * vincenz just got hte c++ standard and then the alexandrescu book
05:14:53 <BCoppens> yeah they usually are; I tend to check amazon before actually buying stuff
05:15:59 <BCoppens> vincenz: yup, alexandrescu is nice. I also have a book on C++ templates, though, and stroustrup's book (all bought with hcw)
05:16:02 <vincenz> problem with amazon: hard to browse
05:16:14 <vincenz> BCoppens: oh yeah and stroustrpu (tho the illegal pdf)
05:16:29 <BCoppens> vincenz: heh =)
05:16:45 <vincenz> BCoppens: I used some of alexandrescus' stuff (typelists) to make functors, and then I made a template to curry functors :)
05:16:48 <vincenz> something like
05:16:56 <BCoppens> cool :)
05:17:14 <vincenz> > a(1,2)(&X::method)(3)(4)(5) == (new X(1,2))->(3,4,5)
05:17:14 <lambdabot>  Parse error
05:17:23 <vincenz> ack
05:17:33 <vincenz> a(1)(2)(&X::method)(3)(4)(5)
05:17:44 <BCoppens> =)
05:17:55 <vincenz> X(1,2).method(3,4,5)
05:18:06 <BCoppens> the stroustrup one is a nice reference, I used it on my exam on C++
05:18:25 <Stinger_> cheating? :P
05:18:26 <vincenz> tho it was kinda neat cause you could easily make a functor that worked as a factory into smart pointers
05:18:39 <BCoppens> Stinger_: it was allowed ;)
05:18:42 <vincenz> BCoppens: you mean like
05:18:53 <vincenz> [StrouStrup:] : "The C++ Programming Language"
05:18:58 <vincenz> at the bottom?
05:19:00 <qz> template metaprogramming in c++ is dead ugly though
05:19:05 <vincenz> qz: yeah
05:19:16 <vincenz> qz: not to mention when you get like pages and pages of errors
05:19:18 <vincenz> for 1 ;
05:19:24 <BCoppens> =)
05:19:33 <qz> alexandrescu stuff is interesting, but to really useful in real projects :|
05:19:38 <qz> *not really
05:19:50 <BCoppens> vincenz: and yeah, the c++ programming language
05:19:51 <vincenz> there's some useful stuff in there
05:20:03 <mornfall> what? c++? in this channel?
05:20:04 <vincenz> like the singleton stuff
05:20:04 <BCoppens> I haven't actually used much of it, but it's cool to read about :)
05:20:11 <BCoppens> mornfall: =)
05:20:26 <qz> vincenz, ya. there's some
05:20:37 <vincenz> BCoppens: I meant"used as reference" as in you quoted it as reference with a bib-entry
05:20:45 <BCoppens> vincenz: oh no
05:20:48 <BCoppens> vincenz: hehe
05:20:48 <vincenz> :D
05:20:50 <BCoppens> =)
05:20:57 <qz> but most is pure academic knowledge (like haskell) :-)
05:21:05 <dons> heh
05:21:10 <vincenz> qz: you mean mental mastur..
05:21:17 * qz hides
05:21:18 <vincenz> *cough*
05:22:18 <BCoppens> vincenz: btw, we also have the story (www.story.be) but I haven't actually ordered anything with them myself
05:23:03 <BCoppens> a friend of mine ordered the science of computer programming with it, though
05:23:15 <BCoppens> or whatever the name was =)
05:23:19 <vincenz> BCoppens: wouters just shut down in leuven :(
05:23:24 <BCoppens> vincenz: :(
05:23:43 <vincenz> for the rest we have crap like: standard, fnac
05:23:48 <vincenz> in a UNIVERSITY TOWN!
05:23:52 <vincenz> oh yeah, acco
05:23:58 <vincenz> but that's typically only for course
05:23:59 <vincenz> s
05:24:11 <BCoppens> =)
05:24:24 <BCoppens> actually, Standaard has some nice random stuff, usually
05:24:45 <BCoppens> but more maths/physics related
05:26:51 <BCoppens> vincenz: so, in Leuven, where do the students buy their books then?
05:28:55 <vincenz> *is not a student*
05:29:01 <vincenz> but: courses: ACCO
05:29:34 <vincenz> but they focus on books used by courrses
05:29:44 <vincenz> thne of course student parties
05:29:47 <vincenz> like VTK for engineers
05:30:35 <BCoppens> yeah, sounds like story, but story apparently has a huge section of orderable books (hopefully that is not just the ones they could, at one point in time, order ;)
06:15:20 * dmhouse discovers a new declaration
06:15:25 <dmhouse> 'default'. Weird.
06:15:34 <wolverian> what does it do?
06:15:55 <dons> dmhouse: :)
06:15:58 <Philippa> lets you set which type numeric literals default to
06:16:00 <vincenz> dmhouse: lol, seen jethr0's comment on the oasis page?
06:16:03 <Philippa> IMO it should be generalised somewhat
06:16:05 <dons> dmhouse, did you read planet.haskell ?
06:16:07 <dmhouse> vincenz: no, URL?
06:16:18 <dmhouse> dons: no, URL?
06:16:33 <vincenz> http://www.notvincenz.com/wiki/pmwiki.php/Icfp/Main
06:16:39 <dons> oh, I've been ranting on about default recently
06:16:42 <lambdabot> Title: Not Vincenz's Wiki | Icfp / Main
06:16:47 <dons> planet.haskell.org
06:17:05 <vincenz> or just type "planet haskell" in firefox :)
06:17:33 <vincenz> dons: ooh nice, full planet haskell compliance on your blog?
06:17:39 <vincenz> dons: how do you make the rss?
06:17:51 <dons> blosxom does it
06:18:01 <qz> vincenz, not planning to write up a report about icfp? ;)
06:18:03 <qz> like adept did
06:18:16 <vincenz> he did?
06:18:30 <qz> ya, pretty big one
06:18:35 <vincenz> where
06:18:42 <qz> in his livejournal
06:18:45 <vincenz> link?
06:18:47 <qz> sec
06:18:55 <qz> wait.. can you read russian?
06:19:11 <dmhouse> dons: ah, cool.
06:19:31 <dons> default has been the obscure-haskell-thought-for-the-day, it seems
06:19:35 <vincenz> qz: yes, it's called google translate
06:19:49 <qz> vincenz, then http://users.livejournal.com/_adept_/24049.html#cutid1
06:19:50 <lambdabot> Title: _adept_: Participating in ICFPC-2006 for fun and profit :)
06:19:54 <qz> there are 3 big parts
06:19:56 <dmhouse> ?ask shapr whether there's going to be an official report from AngloHaskell.
06:19:56 <lambdabot> Consider it noted.
06:20:45 <vincenz> crap
06:20:47 <vincenz> no russian to english
06:20:55 <qz> heh ;)
06:21:01 <vincenz> they removed it!
06:21:10 <qz> they want you to write english report i think :)
06:21:13 <vincenz> I remember translating someone else's russian livejournal
06:21:13 <SamB_XP> it must have been too silly
06:22:08 <vincenz> crap
06:22:11 <vincenz> altavista has a translator
06:22:12 <qz> vincenz, btw you still got your UM code somewhere? wonder if haskell one is faster than c# one
06:22:23 <vincenz> but it's blacksited by company
06:22:28 <vincenz> qz: C++
06:22:31 <vincenz> qz: ask dons
06:22:44 <qz> oh, thought you used haskell :|
06:22:53 <SamB_XP> @google dons UM benchmark
06:22:55 <lambdabot> http://www.cse.unsw.edu.au/~dons/um.html
06:22:55 <lambdabot> Title: Haskell UM
06:23:19 <dons> good google
06:23:24 <vincenz> qz: so do I look good or bad on the pag?
06:23:25 <SamB_XP> exactly the page I wanted
06:23:41 <dons> @google dons
06:23:47 <lambdabot> http://www.mkdons.premiumtv.co.uk/
06:23:48 <lambdabot> Title: Milton Keynes Dons | Home
06:23:48 <qz> vincenz, adept said you were best of all other team members ;)
06:23:50 <dons> ah well
06:24:17 <vincenz> how was anglohaskell?
06:24:31 <vincenz> qz: cool :)
06:24:57 <vincenz> suggestions about this book: http://www.amazon.co.uk/gp/product/0954300696/202-1154136-3559820
06:25:07 <SamB_XP> @google dons haskell
06:25:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
06:25:09 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules
06:25:10 <qz> vincenz, and some rant about lazy jyp :)
06:25:16 <vincenz> qz: ah yeah...
06:25:17 <vincenz> heh
06:26:28 <SamB_XP> how come the UMs actually used in the competetition are slower than the ones written in C that weren't?
06:27:00 <dons> people didn't profile during the competition?
06:27:13 <dons> heh, hs-plugins eh?
06:27:15 <SamB_XP> I didn't profile either!
06:27:19 <dons> so google says that's my best work.
06:27:44 <SamB_XP> dons: not necessarily
06:27:46 <dmhouse> > reverse []
06:27:49 <lambdabot>  Add a type signature
06:27:57 <SamB_XP> it may just have given that because of the "Haskell" in the name
06:28:07 <vincenz> qz: truth be told I'm a bit upset about him too.. If we had had another member instead, and we hadn't lost time on two particular things, we would've had a seriously better score
06:28:11 <dons> dmhouse: not yet. the patch hasn't landed in darcs yet
06:28:20 <vincenz> qz: maybe top5
06:28:20 <dmhouse> dons: right.
06:28:43 <qz> vincenz, nice :) apart from vm, did you do rest in haskell?
06:29:26 <vincenz> qz: and prolog
06:29:31 <vincenz> grr
06:29:37 <vincenz> all the translating sites are blackboxed
06:29:46 <SamB_XP> blacklisted
06:30:02 <SamB_XP> blackboxed means you can't see the software inside, which is kindof a given ;-)
06:30:21 <vincenz> righ
06:30:25 <vincenz> I know that :)
06:31:42 * vincenz ssh's to uni box and launches lynx
06:32:27 <SamB_XP> ewww
06:32:36 <SamB_XP> lynx is... almost forgotten!
06:32:42 <SamB_XP> don't remind me!
06:33:19 <neologism> use elinks instead :)
06:33:34 <SamB_XP> even the regular one!
06:33:56 <SamB_XP> probably even w3m is better tham lynx
06:35:15 <mux> because lynx can't handle frames?.
06:35:28 <mux> because lynx has had major security issues over the years? :)
06:35:31 <vincenz> grr
06:35:33 <SamB_XP> I don't remember
06:35:35 <vincenz> not working
06:35:36 <mux> I do
06:35:39 <vincenz> qz: do me a big favour?
06:35:42 <SamB_XP> but it didn't look very nice...
06:35:47 <mux> w3m/links is the way to go
06:35:59 <qz> vincenz, like?
06:36:20 <vincenz> qz: run the site through http://babelfish.altavista.com/translate.dyn
06:36:21 <lambdabot> Title: AltaVista - Babel Fish Translation
06:37:04 <vincenz>  The site you are trying to access (babelfish.altavista.com) has been categorised under the following category. "Adult/Mature Content;Social Networking".
06:37:05 <vincenz> DUH
06:37:11 <qz> lol
06:37:19 <BCoppens> which reminds me
06:37:20 <mux> hahah
06:37:21 <vincenz> it's a translation site, how can you categorise a translation site
06:37:23 <BCoppens> boegel: ey there?
06:37:23 <qz> filtering everywhere. so i run babel and what to do with results?
06:37:26 <BCoppens> boegel: erm
06:37:32 <vincenz> qz: copy paste?
06:37:46 <vincenz> http://rafb.net/paste/
06:40:40 <vincenz> dons: NOW I know!
06:40:52 <dons> vincenz: ??
06:40:54 <vincenz> dons: I know why bulat sounds so strange!  He runs his text through an automatic translator
06:41:01 <vincenz> just copy pasted adept's stuff
06:41:03 <dons> oh!
06:41:04 <vincenz> and it sounds like bulat
06:41:08 <dons> hehe
06:42:11 <qz> stupid babel says 'error decoding translated text'
06:42:18 <vincenz> qz: did it it :)
06:42:21 <vincenz> used babel and copy pasted
06:42:26 <vincenz> that seems to work
06:42:28 <vincenz> oddly
06:42:41 <vincenz> google -> gugl
06:42:43 <vincenz> LOL
06:42:47 <qz> oh, copy pasted
06:42:48 <qz> lol
06:44:10 <vincenz> More no useful information we found.
06:44:22 <vincenz> russian to english is funk
06:44:25 <vincenz> it's like yoda
06:45:01 <qz> true. i can try to translate sentences where babel failed ;)
06:45:09 <SamB_XP> heh
06:45:22 <vincenz> pozhiraniya
06:45:23 <vincenz> ?
06:45:27 <SamB_XP> gugl is phoneticaly valid?
06:45:39 <Philippa> that explains a lot
06:45:59 <qz> vincenz: '..after few minutes of 100% cpu load..'
06:46:15 <SamB_XP> forgot an "a", did it?
06:46:30 <qz> SamB_XP, phonetically valid, yep
06:47:00 <SamB_XP> google or googol makes more sense, though
06:47:29 * SamB_XP wonders why google doesn't have googley eyes
06:50:13 <SamB> heh, this UM stuff has me calling RAM a cache...
06:50:57 <vincenz> Does remain a question - that did smoke the authors? :)
06:51:10 <SamB> heh
06:51:29 * qz giggles
06:51:30 <SamB> does that mean "There remains one question that stumps the authors"
06:51:45 <SamB> or perhaps "author"
06:51:49 <SamB> ?
06:52:53 <qz> nah, he was wondering what kind of weed did they smoke
06:53:13 <SamB> oh
06:53:14 <qz> its difficult to come up with um and other stuff otherwise
06:53:37 <vincenz> erm
06:53:38 <SamB> yeah, why did they make their architecture so wierd?
06:53:45 <vincenz> qz: he doesn't say anything about me nor rant about jyp
06:53:46 <SamB> it can't have been good for speed
06:53:53 <SamB> and it isn't like programming it was one of the puzzles
06:55:01 <SamB> (there being, after all, no way to get a publication for programming it...)
06:55:25 <qz> vincenz, read next part
06:55:38 <SamB> unless they wrote an extremely inefficient UM-in-UMIX simulator which actually cleans up after itself?
06:55:39 <Philippa> 'lo ChilliX
06:55:57 <SamB> likely if they had written a UM-on-UMIX, it wouldn't clean up after itself properly...
06:55:58 <ChilliX> Hi Phillippa!
06:56:06 <vincenz> qz: where?
06:56:17 <ChilliX> How are you?
06:56:28 <qz> vincenz: part2 - http://users.livejournal.com/_adept_/24313.html#cutid1, part3 - http://users.livejournal.com/_adept_/24321.html#cutid1
06:56:29 <lambdabot> Title: _adept_: ICFPC-2006, продолжение
06:56:31 <vincenz> ah ok
06:56:54 <vincenz> blgh
06:56:56 <vincenz> this is annoying
06:57:06 <vincenz> qz: don't feel like sending them through babel and sending me the .htmls?
06:57:23 <SamB> why does lambdabot only give one title when two URLs are mentioned?
06:57:25 <SamB> dons: hmm?
06:57:30 <qz> vincenz, could try
06:57:38 <dons> SamB, its a bug. what else?
06:57:51 <SamB> hehe
06:58:00 <dons> ChilliX: hey
06:58:21 <Philippa> ChilliX: er, mostly a bit bored. Got home from AngloHaskell and don't have much to do today
06:58:23 <ChilliX> Hi dons
06:58:24 <vincenz> lol
06:58:25 <SamB> 'course, I wouldn't expect anyone to mention multiple URLs in a single message either...
06:58:26 <Philippa> (but I've got a busy week ahead)
06:58:27 <vincenz> russian to english:
06:58:33 <vincenz> Lazy Bottom -> Blind alley
06:58:41 <ChilliX> How did AngloHaskell go?
06:58:44 <Philippa> vaguely planning a possible TMR article after discussion there, too
06:58:46 <Philippa> 'twas good
06:59:10 <ChilliX> article about what>
06:59:11 <Philippa> missed a couple of talks due to liyang waking up too late on friday though
06:59:21 <qz> vincenz, lol ;)
06:59:23 <Philippa> hacking up PTS implementations and playing around
06:59:34 <SamB> point-to-shoot?
06:59:47 <qz> vincenz, babel is failing for me for some reason :|
07:00:08 <Philippa> so essentially the same idea I'd talked to you about before taking a bit more shape. Assuming it gets written, of course
07:00:26 <vincenz> qz: vpryagayetsya ??
07:00:29 <dons> ChilliX: we're making good progress on the stream fusion stuff. much faster, and more things fusing (like zipWith/takeWhile/find/elem :
07:00:32 <dmhouse> Any good talks at AngloHaskell?
07:00:38 <qz> vincenz: works hard
07:00:43 <ChilliX> Philli: sounds cool
07:00:45 <vincenz> ah
07:01:00 <Philippa> I enjoyed edwin's, Alex's talk about HApps was good and Paul Johnson's was fun
07:01:07 <qz> vincenz: was saying that he is not really trying to work hard there..
07:01:15 <dmhouse> Philippa: subjects? :)
07:01:29 <ChilliX> dons: Which of the frameworks are you using now?
07:01:36 <ChilliX> Or rather which variant?
07:01:37 <vincenz> yeah
07:01:55 <Philippa> edwinb's was an intro to dependant types and a plug for Ivor the Proof Engine. Paul's was on an app he'd written for work
07:01:57 <dons> we've finished with the loopU stuff for now, and switched over to stream based fusion
07:02:29 <dons> basically, specialising and improving it, for up and down loops
07:02:54 <ChilliX> ok, so basically a sophisticated version of the approach rl proposed?
07:02:59 <dons> yes
07:03:12 <qz> vincenz, you used skype to talk? not just irc or other chat..
07:03:23 <ChilliX> BTW, rl should be in Cambridge today, shouldn't he?
07:03:36 <dons> rl's approach, as used in ndp, but for multiple directions, lazy data types, and more fuseable forms (in particular, short cut functions, like elem/find/takeWhile)
07:03:53 <dons> ChilliX: yes i think so.
07:04:00 <dons> the 6th or 7th?
07:04:40 <vincenz> qz: dostignuv
07:05:08 <dmhouse> type enum { false, true, wow
07:05:08 <dmhouse> } bool;
07:05:10 <dmhouse> hehe :)
07:05:25 <vincenz> qz: we did briefly in beginning, not for long
07:05:30 <qz> vincenz: reach, achieve
07:06:02 <qz> past tense though
07:06:06 <ChilliX> dons: when is the PPDP deadline again?
07:06:11 <dons> ChilliX: dcoutts got some feedback from spj. some useful comments about compare and contrasting with build/foldr
07:06:16 <dons> 3 Sep now.
07:06:22 <dons> it got pushed back a fortnight!
07:06:31 <dons> oh, PPDP? hmm
07:06:42 <dons> you mean, PADL?
07:07:35 <ChilliX> yes, sry
07:07:44 <ChilliX> acronym confusion %)
07:07:48 <dons> yeah, I think we missed PPDP ;)
07:07:51 <qz> dons, your um implementation in haskell looks dead ugly :| wonder if that's because of optimization hacks or just because haskell is not quite suitable for such programs
07:08:15 <dons> qz, its ugly :) i'm not sure haskell's not suitable, but its certainly a hard problem
07:08:29 <ChilliX> qz: show me a language in which it looks nicer!
07:08:50 <dons> ChilliX: in this case, almost everything else looks nicer ;)
07:09:12 <qz> ChilliX, check out edwards um
07:09:25 <Philippa> URLs?
07:09:32 <dons> ?google dons UM benchmarks
07:09:34 <vincenz> qz: I enjoyed collabing with lemmih and adept ;)
07:09:38 <lambdabot> http://www.cse.unsw.edu.au/~dons/um.html
07:09:38 <lambdabot> Title: Haskell UM
07:10:12 <ChilliX> dons: ok, did you already adapt the paper skeleton to the "new" approach?
07:10:29 <qz> vincenz, this year your team performed better than last one?
07:10:31 <dons> not yet. we're thinking of talking about both solutions.
07:10:35 <dons> but we should discuss this
07:10:42 <Philippa> I'm surprised team roflcopter's haskell implementation was that slow. Guess I should sandmark mine sometime
07:10:52 <pharm> Is Happy usually regarded as the best haskell parser generator? I've got a large pile of (bison) BNF which I'd like to use to generate a haskell parse tree for the language in question...
07:10:59 <dcoutts__> dons: ChilliX, the 'old' loopUp/Dn and the streams you mean?
07:11:08 <dcoutts__> i think we should probably mention both, no?
07:11:20 <dcoutts__> at least to say why our new one is better
07:11:27 <dons> right. since we have numbers for all forms, and can contrast and compare
07:11:31 <ChilliX> dons: hmmm, usually it doesn't work well to explain two things (esp two version of teh same thing) in one paper.
07:11:38 <dcoutts__> hmm
07:11:44 <ChilliX> Oh, yes, in the benachmarks both of course
07:11:49 <ChilliX> Or maybe the following:
07:11:50 <dcoutts__> right, ok
07:11:53 <dons> yes. there's so many details with the streams, that we could just concentrate on that
07:12:09 <ChilliX> Explain the current approach first (and focus on it in the intro)
07:12:11 <dons> it raises all the technical and theoretical issues we'd like to talk about
07:12:29 <ChilliX> Then before benachmarks maybe have a short sect on how the other stuff worked and the have benchamrks for both
07:12:56 <dons> yeah.
07:13:00 <dcoutts__> ok with me
07:13:03 <ChilliX> Then, there is still the focus on one, but the kind of experience report on the other, too
07:13:06 <vincenz> qz: much
07:13:12 <dcoutts__> ChilliX: right
07:13:20 <ChilliX> dons, dcoutts: btw, check out http://www.pllab.riec.tohoku.ac.jp/~ohori/research/OhoriSasanoFusionJuly2006.pdf
07:13:34 <vincenz> qz: next year I want a new team, hopefully with Lemmih and adept
07:13:40 <roconnor> Philippa: apparently unsafeArrayRead/Write is the way to go :/
07:13:41 <vincenz> qz: and 2-3 more people, 4 is slim
07:14:04 <Philippa> yeah, if I'd known where to find them I would've used them
07:14:09 <vincenz> dcoutts_ how was anglo?
07:14:15 <dcoutts__> vincenz: cool
07:14:41 <roconnor> dons: there needs to be a distinction between safe UM implementations, and UM implemenations that can 0wn you.
07:14:47 <dons> heh
07:14:48 <vincenz> dcoutts_: :)
07:15:48 <dons> roconnor: unsafeWrite isn't bad, if you've got bounds checks on the outside. I mean, who actually relies on catching a writeArray exception, for _correctness_?
07:16:10 <Philippa> dons: the FAIL specs? They said maybe
07:16:23 <Philippa> so I for one hadn't bothered at all...
07:16:27 <dons> oh, that should all be handled, of course
07:16:32 <roconnor> dons: are people doing bounds checks on the outside?
07:16:38 <LordBrain> UM = Unified Messaging?
07:16:55 <qz> vincenz, so you had no plans about writing similar report? ;)
07:16:56 <Philippa> Universal Machine. This won't make much sense if you didn't do the ICFP contest
07:17:08 <LordBrain> oh ok
07:17:38 <Philippa> dons: actually, I think I did have an outermost catch. But my C++ implementation didn't bother at all
07:18:38 <vincenz> qz: maybe, I don't know, I always tell myself to write more in blogs, but I never write
07:18:50 <vincenz> and I have a really crappy memory
07:18:58 <vincenz> besides...paper deadline
07:19:19 <qz> what paper?
07:19:24 * dons -> sleep
07:19:25 <dons> nytol!
07:19:56 <Philippa> seq not good enough?
07:20:10 <vincenz> qz: undisclosed
07:20:28 <dcoutts__> g'night dons
07:21:21 <dcoutts__> ChilliX: so in that paper their approach is more theoretical and general
07:21:22 <ChilliX> dons: night
07:21:42 <ChilliX> well, they implemented it, so it's not all theoretical
07:21:56 <dcoutts__> they've got promising benchmarks in a toy compiler
07:22:02 <ChilliX> It's very hard to compare to it of course
07:22:15 <dcoutts__> yeah
07:22:50 <ChilliX> but it's quite a different approach to all the other related work, so I think it is worthwhile discussing even if hard to compare and, as of now, still unpublished
07:23:51 <Philippa> *blink* oh yeah, I just remembered something that occurred to me yesterday on the way home that I should check through
07:24:05 <dcoutts__> ChilliX: aye
07:26:04 <Philippa> currently GHC needs an invariant subsumption mechanism, and as I've understood it the biggest reason for that's so dictionary passing doesn't turn into a complete mess?
07:26:39 <Philippa> (or require all values to come with a dictionary, at least)
07:27:39 <ChilliX> What do you mean by "invariant subsumption"?
07:30:04 <Philippa> gimme a mo to grab the boxy types paper and get it precisely right?
07:33:15 <Philippa> hrmm. There's a slightly different story on it in the rewritten version of the paper
07:37:54 <sehute> hi, if I wish to have a function that is able to manipulate many types of data, should I just omit the type declaration? Should I create several functions with different type declaration? What's the "right" way to do it?
07:38:21 <kpreid> omit the type declaration or use type variables in it
07:38:42 <sjanssen> sehute: what do you mean by several types of data?
07:39:18 <sjanssen> if you want to write a function that accepts, say, both Double and Integer, you need to use class overloading
07:39:42 <gds> "Num" ?
07:40:42 <sehute> kpreid: thanks
07:41:03 <sehute> sjanssen: for instance if I wish to wrap up the "has" function, with "my_has", that does the exact same thing
07:52:21 <gds> Is there any map-like functionality for tuples?
07:52:42 <sjanssen> > fmap (+1) (1, 2)
07:52:42 <lambdabot>  add an instance declaration for (Functor ((,) a))
07:52:43 <lambdabot>   In the definition of ...
07:53:11 <gds> @type fmap
07:53:12 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
07:53:16 <sjanssen> hmm, probably need an extra import for that
07:54:19 <sjanssen> gds: there aren't any builtin functions for mapping on tuples
07:54:21 <kpreid> of course, that could only work for tuples with all the same elements
07:54:24 <kpreid> types
07:54:49 <sjanssen> kpreid: actually, the Functor instance for tuple only applies the function to the last item
07:55:05 <gds> I was just thinking about a question we got on here on Friday - resulted in two lines of code, which were mostly identical...
07:55:06 <kpreid> "the"?
07:55:14 <vincenz> cool
07:55:20 <vincenz> the reasoned schemer uses a monadic approach
07:55:32 <sjanssen> @. pl djinn (a -> b) -> (a, a) -> (b, b)
07:55:33 <lambdabot> f = (`ap` snd) . (. fst) . (const .) . (ap =<< ((,) .))
07:55:37 <sjanssen> ouch
07:55:42 <sehute> see you later alligator(s)
07:56:54 <gds> Oh - are there any ubuntuists around? I was wondering about the state of ghc in that distro (I know that Igloo keeps debian users pretty happy) - trying to decide which way to go for my next install...
07:57:06 <sjanssen> @. pl djinn (a -> b) -> (c -> d) -> (a, c) -> (b, d)
07:57:06 <lambdabot> f = flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
07:58:27 <Philippa> "ScannedInAvian: yeah, I'm okay, work to do means I can't show up on #haskell" <- shapr's home OK if anyone's still worried
08:05:50 <Itkovian> any man who can ride uphill on a unicycle in snow is not a man to be worried about, methinks
08:14:50 <dmhouse> Wow, this is really cool: http://www.joelonsoftware.com/items/2006/08/01.html
08:15:02 <lambdabot> Title: Joel on Software
08:15:10 <dmhouse> It's great to see someone like Joel Spolsky with such strong advocacy for functional programming.
08:15:35 <dmhouse> A shame he doesn't explain explicitly what he's talking about, though, and say 'look, there really are languages that do this!'.
08:17:22 <roconnor> he should say, look at that ; operation, let's abstract that, call it >>
08:23:05 <vincenz> tbh
08:23:09 <vincenz> I found the article rather weak
08:23:31 <vincenz> plus he inroduces all these concepts as if they're new
08:23:35 <vincenz> instead of referring where they came from
08:24:07 <vincenz> basically: "check out hwo cool js is it can do these novel things"
08:24:09 <vincenz> insteado
08:24:19 <emertens> I don't think that anyone will be convinced by his abstraction of cook
08:24:24 <vincenz> "these things I can do in js come from fp"
08:24:50 <emertens> Javascript can do some surprising things
08:25:23 <vincenz> yeah but not ONCE does he refer to functional programming languages
08:25:28 <vincenz> he makes it sound as if he invets the foldr
08:25:30 <madpickle-> joel's a hack
08:25:38 <madpickle-> his writings are regurgitated crap he read elsewhere
08:25:42 <madpickle-> the man has skill, no doubt about it
08:25:54 <madpickle-> i've read his website (well, really his forum more than his site) since he started
08:26:00 <emertens> vincenz: I think that since he says that "this is what Google does" that he's not trying to take any credit
08:26:07 <sjanssen> @keal
08:26:08 <lambdabot> i can explain why something is without knowing what the rules decided by man are
08:26:09 <madpickle-> in the beginning he asked on his forum if people could recommend good software dev books
08:26:16 <vincenz> emertens: I think there's a whole world of FP he's not referring to
08:26:16 <madpickle-> the same books you see him flog on his site now as his own thoughts
08:26:31 <therp> I haven't had the impression that joel on software articles are more than just above average
08:26:41 <madpickle-> they're not
08:26:49 <vincenz> his management stuff is ok to read
08:26:59 <madpickle-> it's ok to read because it's a carbon copy of prevailing theories and concepts
08:27:03 <madpickle-> it's hardly mind shattering
08:27:06 <madpickle-> he's a pretty good writer
08:27:14 <madpickle-> for all intents he's doing a good thing (tm)
08:27:45 * therp prefers reading paul graham's stuff
08:27:50 <emertens> I believe that is "Good Thing (TM)" :-D
08:28:12 * emertens prefers some of Paul Graham's stuff, but definitely not as a rule
08:28:30 <therp> emertens: right
08:30:10 <xerox> @yarr!
08:30:10 <lambdabot> This is the END for you, you gutter-crawling cur!
08:49:20 * gds darcs pulls the latest lambdabot patches, and watches as the resulting binary refuses to run...
08:50:29 <gds> "Initialising plugins ..............................*** Exception: exit: ExitFailure 1"
08:50:33 <gds> Hm.
08:57:38 <SamB> something tried to call exitWith (ExitFailure 1) ?
08:57:48 <SamB> @hoogle ExitFailure
08:57:49 <lambdabot> System.Exit.ExitFailure :: Int -> ExitCode
08:57:50 <lambdabot> System.exitFailure :: IO a
08:58:01 <SamB> or maybe just exitFailure
08:58:40 * gds tries rebuilding without a couple of the plugins...
09:06:23 <emertens> is anyone else idling around macrumors waiting to findout what Leopard has in store?
09:08:04 <gds> Ah - something in the "Seen" plugin...
09:08:45 <SamB> hmm, another problem with missing state files?
09:10:41 <gds> SamB: Possibly, I suppose...
09:10:52 <gds> I've been running a lambdabot on another IRC server for a while...
09:11:02 <gds> So there should be /some/ state files.
09:11:13 <gds> Possibly one of the latest patches isn't compatible with them ;)
09:12:35 <gds> Ah well - I'll hunt that bug later - ta-ta all ;)
09:31:24 <Cufisz> Simple monad example (http://www.rafb.net/paste/results/YCDqPo33.html) is this the expected behaviour?
09:32:03 <Cufisz> or even more precisely IO example. I would think that the putStr would have to happen before the getLine... no?
09:33:23 <kpreid> you need "hFlush stdout"
09:34:19 <Cufisz> haha
09:34:21 <Cufisz> yes!
09:34:27 <Cufisz> thankyou
09:34:46 <Cufisz> hehe, just like endl's in c++...
09:36:34 * emertens uses irssi
09:56:07 * dylan swears at HP warranty policy
09:56:13 <dylan> err, wrong channel.
10:37:01 <musasabi> SyntaxNinja: do you know whether a version of Cabal with the conditional depency-stuff will be going into GHC 6.6 ?
10:39:52 * dcoutts__ puts on his cabal release manager hat
10:40:16 <dcoutts__> musasabi: not unless the conditional dep stuff gets finnished and tested really quick
10:40:23 <dcoutts__> want to help?
10:40:33 <dcoutts__> 6.6 is on a short schedule
10:44:07 <musasabi> dcoutts__: I would like to get it very much included.
10:44:10 <musasabi> What needs to be done?
10:44:23 <dcoutts__> did you read the thread on cabal-devel?
10:44:33 <dcoutts__> JaffaCake sent in an initial patch
10:44:57 <dcoutts__> (unless I'm very confused and that was about something else)
10:44:57 <musasabi> dcoutts__: otherwise dependencies on e.g. fps will become very hard as one needs separate cabal files for 6.4 and 6.6 - if it goes in one can just say "upgrade cabal" to 6.4 users.
10:45:14 <dcoutts__> musasabi: true
10:46:05 <musasabi> I remember the thread.
10:46:12 <musasabi> (looking it up in the mailbox)
10:46:37 <dcoutts__> I've not had a serious look at it yet
10:46:55 <dcoutts__> there was also a good thread on conditional syntax a while ago
10:46:57 <musasabi> "first cut at configurations patch, and a couple more"
10:47:25 <dcoutts__> yeah, as I said, I may be confused and configurations may be something else entriely
10:47:40 <dcoutts__> but I thought it was closely related
10:47:54 <dcoutts__> if not then there has been no real progress on it
10:48:04 <dcoutts__> but mostly due to lack of dev time
10:48:14 <dcoutts__> so if you write the code it'll get done
10:48:17 * dcoutts__ -> dinner
10:48:18 <musasabi> configurations seem like the right thing.
10:48:26 * musasabi will look at it later tonight
10:48:37 <dcoutts__> great
10:54:57 <SyntaxNinja> musasabi: no idea
10:55:33 <Lemmih> I doubt it.
10:59:57 <gaal> is ghc's symbol mangling convention documented somewhere? e.g. 'zi' for '.' etc.
11:01:20 <Igloo> I think it's in the commentary; if not then the source
11:03:25 <mnislaih> gaal: it is in the Encoding module at compiler/utils
11:04:54 <gaal> thanks!
11:05:19 <lambda_the_insig> so I'm looking at various timeout code, where I want to qualify the number of solutions found in a particular timeout window:
11:05:19 <lambda_the_insig> data SolType = None | Single | Multiple | Timeout deriving Show
11:05:19 <lambda_the_insig> quantifySolutions :: Int -> (a -> [b]) -> a -> IO SolType
11:05:19 <lambda_the_insig> quantifySolutions t f i = do { res <- timeout t (return $ take 2 $ f i) ; -- processing of result value to return the appropriate SolType }
11:06:00 <lambda_the_insig> the idea being that I don't care if I don't find an answer within a specific timeframe; I'll just return the Timeout response.
11:06:38 <lambda_the_insig> the problem is when I have a computation that exceeds the timeout value, we still are waiting for it to complete before we can get out of the timeout.
11:07:06 <lambda_the_insig> it's a pure function in this case; is there any way to abort the function processing with a "hard" timeout?
11:07:24 <lambda_the_insig> (I'm using the definition of timeout from HWS, I believe)
11:09:16 <LordBrain> does darcs have to use sendmail? what if i have exim installed?
11:09:47 <gaal> LordBrain: exim provides a 'sendmail' command, as do most mailers
11:10:25 <LordBrain> hmmm
11:10:29 <LordBrain> exim4 does too?
11:10:41 <LordBrain> because... it seems exim4 is installed but i have no sendmail command
11:11:08 <LordBrain> maybe the command is auto generated after some configuration that was not done?
11:11:21 <LordBrain> i'm on debian stable
11:12:29 <musasabi> LordBrain: at least Debian unstable + exim4 + darcs works fine.
11:12:50 <LordBrain> well, maybe i just need to work on exims config
11:20:20 <LordBrain> oh it has sendmail.. but only as root...
11:26:34 <mux> it's probably just that it's in /usr/sbin
11:26:50 <mux> many (all?) Linux distros don't put the sbin directories in the PATH
11:26:54 <mux> it doesn't mean you can't use it
11:27:49 <LordBrain> hmmm
11:28:47 <LordBrain> its strange to be there, if its allowable for users... anyway, can i tell darcs where it is?
11:29:03 <mux> historical reasons
11:29:16 <mux> darcs will probably expect it there already
11:29:20 <mux> for the same historical reasons :-)
11:29:44 <LordBrain> oh.. well.. darcs is having trouble some reason, when i try to send patches
11:30:01 <mux> did you check if you had any logs with respect to mail?
11:30:43 <mux> /var/log/maillog maybe?
11:31:01 <mux> is darcs giving any specific error?
11:31:19 <mux> maybe you have received an error notification mail in /var/mail/<youruser> ?
11:32:12 <LordBrain> the directory doesnt exist...
11:32:17 <mux> pentane% strings /usr/local/bin/darcs | grep sendmail                         ~
11:32:18 <mux> /usr/sbin/sendmail
11:32:24 <mux> that's what I thought
11:32:30 <LordBrain> or file i mean
11:32:45 <mux> darcs will indeed run /usr/sbin/sendmail
11:33:27 <erider> what are monads and how are they used
11:33:46 <mux> erider: phew! now that's a broad question
11:34:20 <erider> can you give me a brief rundown
11:34:24 <mux> there are several different analogies, but monads can be seen as a way to abstract a computation
11:34:35 <LordBrain> @google All about Monads
11:34:41 <lambdabot> http://www.nomaware.com/monads/
11:34:41 <lambdabot> Title: Nomaware | Monads
11:34:42 <emertens> I just read through the new features in OS X Leopard...
11:34:46 <mux> allowing you to combine several computations from the same monads
11:34:53 <LordBrain> @wiki Monads as Containers
11:34:53 <lambdabot> http://www.haskell.org/haskellwiki/Monads as Containers
11:34:57 <mux> in an easy way
11:35:00 <emertens> :( huge letdown :(
11:35:14 <emertens> Monads aren't containers... functors are containers :)
11:35:21 <mux> monads can be seen as containers
11:35:53 <erider> ok thanks guys
11:35:58 <LordBrain> i found both of those tutorials helpful, read them both.
11:36:00 <johnnowak> emertens: indeed
11:36:02 <Cheery> mux: how monads are used in haskell?
11:36:18 <mux> what do you mean, how are they used?
11:36:27 <mux> there's a Monad type class
11:36:28 <emertens> I always thought that some monads were containers, but conly because they were instances of Functor also
11:36:42 <mux> and the return and (>>=) methods
11:36:57 <Cheery> I mean, I've thought they are quite complex.
11:37:00 <mux> emertens: well, it's just an analogy, check the paper, I found it nice
11:37:04 <mux> they are
11:37:21 <mux> and I'm certainly not pretending to be the top boss of the monads in here, far from it :-)
11:37:32 <Cheery> Would they be useful in non-functional language?
11:37:36 <LordBrain> yes
11:38:03 <Cheery> ok, thank you. :)
11:38:12 <Cheery> I read the links you pasted.
11:38:21 <mux> well, given that monads are highly useful in allowing to express computations with side-effects without losing referential transparency, I don't see how they would be much useful for imperative languages
11:38:36 <mux> but maybe I'm not being creative enough :-P
11:38:46 <LordBrain> they are useful for a couple of different purposes, in general they ensure that IO is done in a lawful way, so that you can reason about your program despite the fact that it uses IO.
11:38:59 <mux> yeah, precisely
11:39:09 <LordBrain> well, just because your language is imperative, doesnt mean you have to be...
11:39:17 <mux> I guess you could use that fact in imperative language to at least reason about that part
11:39:32 <Cheery> LordBrain: yes.
11:39:38 <Cheery> I were thinking same way.
11:39:58 <mux> but they also useful just for the powerful abstraction they allow
11:40:24 <mux> like the State monad, etc - I guess that could be useful for imperative languages as well
11:40:35 <mux> but really, at this point, I'd just use Haskell :-)
11:41:24 <LordBrain> yes
11:41:37 <LordBrain> the paper on STM was particularly impressive to me
11:41:57 <LordBrain> @google Composable Memory Transactions
11:42:00 <lambdabot> http://research.microsoft.com/~simonpj/papers/stm/index.htm
11:42:01 <lambdabot> Title: Papers on transactional memory
11:42:40 * mux nods
11:42:48 <LordBrain> ~-/~~
11:42:52 <mux> the tackling the I/O squad paper or whatever is way good too
11:43:02 <mux> comes from a microsoft guy as well
11:44:18 <LordBrain> well.. before being employed at microsoft research, simonpj invented haskell... so i think of him as a haskell guy.
11:44:26 <LordBrain> hehe
11:46:59 <LordBrain> @google monads in python
11:47:06 <lambdabot> http://lukeplant.me.uk/blog.php?id=1107301643
11:47:06 <lambdabot> Title: Understanding Monads Via Python List Comprehensions
11:47:57 <LordBrain> http://sleepingsquirrel.org/monads/monads.html
11:47:58 <lambdabot> Title: Monads in Perl
11:48:15 <Cheery> ooh, LordBrain, you're the best. :)
11:48:42 <Cheery> I've more experience from python than haskell, so this comes to helpful introduction before reading that stuff in wiki.
11:54:31 <Cale> Cheery: learning about monads?
11:54:46 <Cale> Cheery: have you seen my tutorial "Monads as Containers"?
11:54:55 <Cheery> yes, my interest rised to them once again.
11:55:07 <Cheery> Cale: I don't know.
11:55:34 <Cheery> is it this in wiki?
11:57:13 <LordBrain> http://www.haskell.org/haskellwiki/Monads_as_Containers
11:57:14 <lambdabot> Title: Monads as Containers - HaskellWiki
11:57:30 <LordBrain> lambdabot posted it earlier.. but with spaces instead of _'s
11:58:16 <Cale> Cheery: yeah, that's it there :)
11:58:44 <Cale> After that, I recommend "All About Monads"
12:05:29 <emertens> Cale: "Every monad is a functor." ?
12:05:37 <SyntaxNinja> @seen shapr
12:05:38 <lambdabot> shapr is in #ScannedInAvian. I last heard shapr speak 3 hours, 53 minutes and 24 seconds ago.
12:07:10 <LordBrain> yeah emertens
12:07:18 <emertens> not by definition tho
12:08:04 <emertens> since ArrowMonad isn't
12:08:37 <Cheery> ooh! These monads are worth of understanding. :) They are really useful! Even if my language wouldn't be completely functional.
12:09:23 <Heffalump> Monads are very functional.
12:11:00 <Cale> emertens: by definition yes.
12:11:17 <emertens> so by "law" you mean?
12:11:21 <Cale> yes
12:11:33 <emertens> but that is not enforced in code?
12:11:41 <Cale> I didn't say that every instance of the Monad class is an instance of the Functor class
12:12:05 <emertens> why isn't it?
12:12:09 <LordBrain> it used to be that was the case didnt it?
12:12:14 <Cale> Yeah, it did
12:12:30 <Cale> The thing is, defining return and bind is enough to get fmap
12:12:44 <Cale> But there's no way to have this happen automatically
12:13:13 <Heffalump> it's a shame superclasses can't define defaults for subclasses
12:13:14 <Cale> So to avoid forcing you to define an instance of Functor even when you had no intention of using it, they decided to decouple them.
12:13:24 <emertens> alright
12:13:35 <Heffalump> can I get ghci to tell me which class members have defaults?
12:14:55 <LordBrain> hmmmmm, well, they could require that monads in the standard libraries also be functors.. so that we can say it's the case at least for standard monads..
12:15:18 <emertens> the monads in the std libraries are functors, except for arrowmonad
12:15:32 <emertens> but arrowmonad might not be standard :)
12:15:39 <sjanssen> LordBrain: all the types in the prelude that can be monads are also functors
12:15:41 <emertens> i just found it when asking lambdabot for examples
12:16:04 <Cale> ArrowMonad should be a functor too
12:16:09 <LordBrain> yeah, but arrowmonad comes with ghc.. i guess thats what i mean
12:16:18 <Cale> It might not be an instance, but that would be a mistake
12:16:21 <LordBrain> yeah, its an oversight maybe
12:16:30 <LordBrain> yeah, thats what i was thinking
12:16:33 <Cale> You can trivially implement the Functor class for any correct instance of Monad
12:16:47 <Cale> instance Functor M where
12:16:52 <Cale>    fmap = liftM
12:18:14 <petekaz> Cale: when are you going to write the "Monads as Computation" sibling?
12:19:09 <Cale> hmm :)
12:19:29 <Cale> I was sort of leaving it for someone else to fill in, but yeah, I could write it.
12:19:43 <emertens> Cale: can a rose tree be a monad?
12:19:50 <Cale> yes
12:20:14 <bighead> hi guys, I've been going over some of the haskell tutorials linked on the main haskell website
12:20:24 <emertens> what would bind mean on such a tree? (data Tree a = Node a [Tree a])
12:20:27 <LordBrain> for a thurough understanding of monads, should we learn some category theory?
12:20:41 <bighead> trying to "pickup"/learn haskell. But what I've noticed is that all have the usual math based short examples
12:20:49 <Cale> LordBrain: You could, it would help you understand the more general setting for them
12:21:18 <Cale> bighead: my favourite tutorial for newcomers is "Yet Another Haskell Tutorial"
12:21:20 <bighead> I was wondering if you guys know of any reposistories of haskell code with medium-sized libraries' whos code I could read to become more familiar with the Haskell Way. E.g. A small library for handling Complex numbres etc
12:21:30 <bighead> Cale: I was reading exactly that
12:21:30 <Cale> which yes, has mathematics based examples in it :)
12:21:36 <petekaz> bah
12:21:50 <petekaz> however, YAHT is good in my opinion.
12:22:05 <bighead> Cale: but something non-math based, more practical examples. Like a log parser, or something. Or say a small simple web server
12:22:19 <petekaz> but I still get confused on the monad transformer section towards the end of it.
12:22:23 <LordBrain> the wiki is full of examples of things like that
12:22:31 <Cale> emertens: It's possibly easier to ask what join would do
12:23:16 <Cale> emertens: Suppose you have a rose tree of rose trees, and you want to put them together into a single tree somehow
12:23:40 <Cale> There are a bunch of natural ways it might be done.
12:25:26 <shapr> So I heard that Haskell is like, way better than Java. Is that true?
12:25:26 <LordBrain> maybe we should sort them better.... start with http://www.haskell.org/haskellwiki/Example_code
12:25:27 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
12:25:40 <Cale> shapr: :)
12:25:50 <emertens> shapr: you can't be a troll if lambdabot takes your messages :)
12:25:57 <emertens> it gives you away :)
12:25:58 <Cheery> shapr: anything is better than java except an another BCPL language. :D
12:26:08 <shapr> emertens: dang
12:26:10 <Cale> emertens: One would be to simply grab the value at the root vertex of each, forming a new tree.
12:26:14 <LordBrain> yeah, except java probalby has more practical libs done for you at this point in time..
12:26:37 <monochrom> List and string processing examples for bighead: http://haskell.org/onlinereport/standard-prelude.html#sect8.1 http://haskell.org/onlinereport/list.html
12:26:38 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
12:27:25 <shapr> @tell dmhouse Yes, I'm working on an official AngloHaskell report. I'm trying to collect urls to slides/papers/photos.
12:27:26 <lambdabot> Consider it noted.
12:27:38 <emertens> Cale: I'm forgetting that fmap would be Tree (Tree a) -> Tree a
12:28:02 <SamB> it would?
12:28:07 <Cale> emertens: that's join
12:28:17 <LordBrain> this has some examples too: http://haskell.org/hawiki/ImperativeHaskell
12:28:18 <lambdabot> Title: ImperativeHaskell - The Haskell Wiki
12:28:18 <SamB> yeah, that is definately join ;-)
12:28:20 <emertens> excuse me
12:28:34 <emertens> either way, it's what we were talking about :)
12:28:37 <shapr> PaulAJ: hiya!
12:28:41 <PaulAJ> Hi.
12:28:46 <emertens> fmap :: (a -> b) -> Tree a -> Tree b
12:28:52 <PaulAJ> You got home OK?
12:28:54 <LordBrain> my links were for bighead
12:29:14 <Cale> emertens: There might be more interesting ways to define join, like trying to splice the trees together into a larger tree, but you have to be more careful about things like associativity if you do that.
12:29:26 <Cale> fmap is easy enough to define
12:29:28 <pejo> bighead, Simon Marlow has written a webserver and an article about it - http://www.haskell.org/~simonmar/papers/web-server-jfp.pdf. Not sure if the source code is available.
12:29:30 <bighead> LordBrain: ah. thanks. But I don't like the sound of that link, I wanna do Functional Haskell, not Imperative =) I'll still take a look
12:29:34 <Cale> as is return :)
12:29:54 <LordBrain> in haskell, you might have to break down and write your own bindings for c libraries... in java that stuff is pretty much unnecessary.
12:30:06 <SamB> LordBrain: huh?
12:30:08 <Cale> bighead: There are lots of code examples on the old wiki, (and some on the new one too)
12:30:08 <LordBrain> for most purposes
12:30:23 <LordBrain> i mean, that in java, someone has done the work for you usually.
12:30:33 <SamB> I thought it was more like "never done by sane individuals" than "unneccessary"
12:30:47 <LordBrain> no, i just meant its already done
12:31:00 <postman> Cale: What do you think about this? http://www.het.brown.edu/people/andre/patterns/imperative.html Is this "run" equivalent to runST?
12:31:09 <SamB> well, that has to do with the relative sizes of the communities, most likely ;-)
12:31:10 <LordBrain> because the java community is so huge.. haskell is still playing catch up i think.
12:31:19 <LordBrain> well yes
12:31:20 <LordBrain> exactly
12:31:41 <postman> LordBrain: My experience with Java software is that you have to pay for quality software outside what Sun gives you.
12:31:43 <Cale> postman: yes
12:31:43 <SamB> at least it is relatively easy in Haskell, I think...
12:31:51 <postman> LordBrain: this holds up in general.
12:32:10 <LordBrain> yeah, i think its easy too... i'm thinking of making a binding for the PCRE library
12:32:19 <shapr> PaulAJ: Yes, I survived, thanks :-)
12:32:28 <LordBrain> then we can use PCRE inside Yi
12:32:35 <LordBrain> swell, yes?
12:32:55 <postman>  (there are exceptions of course)
12:33:07 <jlhamilton> ?users
12:33:08 <shapr> Speaking of Yi, skew (Brandon Moore) is interested in hacking on it as well. Seems there may be a resurgence of interest in that project.
12:33:25 <lambdabot> Maximum users seen in #haskell: 221, currently: 220
12:33:28 <LordBrain> oh
12:33:28 <shapr> neato
12:33:55 <LordBrain> i fixed the word movement 'b' 'w' and 'e' now behave like vim, except they handle blank lines a bit differently.
12:34:18 <LordBrain> but i dont think my patches have been applied yet
12:34:49 <LordBrain> i am having trouble for some reason mailing them to don
12:34:49 <shapr> LordBrain: Is your repo available?
12:35:05 <LordBrain> no
12:35:36 <shapr> dcoutts_: Hey, should I grab dons' slides as the reference for your AngloHaskell talk?
12:35:43 <LordBrain> maybe my email is being blocked by dons provider... someone mistaking me for spam?
12:35:58 <postman> Cale: you can read fast...
12:37:26 <lisppaste2> petekaz pasted "How should I deal with exceptions in this library routine?" at http://paste.lisp.org/display/23795
12:37:54 <petekaz> shapr: I'm still writing my article for the monad reader (newbie stuff).
12:37:55 <shapr> edwinb: Hey, are your AngloHaskell slides online?
12:37:58 <shapr> petekaz: Spiffy
12:38:04 <shapr> @seen greenrd
12:38:35 <postman> Cale: did you see the link earlier?
12:38:37 <petekaz> The code I just posted let's one run a list of IO actions in a fixed-size thread pool.
12:39:01 <petekaz> If you were using this, how would you want exceptions to be handled?
12:39:17 <lambdabot> I haven't seen greenrd.
12:40:05 <Cale> postman: hehe, well, they're defining a monad which keeps track of the values of variables and allows you to set and get them. :)
12:40:20 <Cale> postman: which is essentially what ST does.
12:41:00 <postman> Cale: only in Haskell it does it compile time, and you need to supply type signatures.
12:41:22 <Cale> postman: well, yeah, this isn't doing exactly the same thing as ST
12:43:02 <postman> Cale: I wondered whether the Scheme "references" (STRefs in Haskell) could also be passed and "manipulated" to other state threads.
12:43:41 <Cale> Possibly. In Haskell, that's explicitly disallowed.
12:43:51 <postman> Cale: I think it does, since garbage collection + the higher order functions would make it work.
12:44:08 <postman> Cale: no, in Haskell that's not disallowed.
12:44:16 <Cale> Well, in the scheme implementation, they have an explicit dictionary.
12:44:22 <postman> Cale: "manipulated" as per Lazy Functional State Threads
12:44:23 <edwinb> shapr: Not yet, but they will be Real Soon Now
12:44:47 <edwinb> I'll put a link on the wiki later this evening
12:44:52 <Cale> Yes it is, if I know what you're saying. You can't return an STRef from an ST computation and apply runST to it.
12:45:04 <postman> Cale: That paper shows that you can toss around STRefs all you want, as long as you don't dereference them.,
12:45:19 <Cale> @type Control.Monad.ST.runST
12:45:20 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
12:45:45 <Cale> s can't occur as a variable in a
12:46:15 <Cale> So if I try to do:
12:46:30 <Cale> runST (newSTRef 5)
12:46:38 <edwinb> In fact, I'll do it now. Ideal brief procrastination opportunity.
12:46:42 <postman> Cale: What were you answering with "Yes it is"?
12:46:43 <Cale> it'll be a type error
12:46:54 <Cale> postman: It is disallowed
12:47:23 <stepcut> Cale: I wanted to update this wiki page http://www.haskell.org/hawiki/HaskellNewbie_2fInfiniteCartesianProduct but it is immutable (and you made the last edit). Am I supposed to migrate it to the new wiki or something ?
12:47:33 <Cale> stepcut: are you logged in?
12:47:41 <stepcut> I can't find the login button :)
12:47:47 <Cale> stepcut: top right corner
12:48:03 <stepcut> ah, the 'UserPreferences' lik
12:48:04 <stepcut> link
12:48:10 <Cale> yep
12:48:17 <stepcut> wacky
12:48:22 <anborn> hi! I'm trying to install hugs98-May2006 under Linux, but I'm getting this error: http://paste.lisp.org/display/23796 . Any idea about what's happening?
12:49:13 <LordBrain> old and new wiki articles should be searchable from one cgi type interface
12:49:14 <Cale> anborn: that's curious
12:49:15 <postman> Cale: that's true, but page 4 of that paper has an example which gets a STRef as an argument and gives that as an argument to newSTRef
12:49:45 <stepcut> so, is it OK to edit articles on the old wiki? Or am I supposed to take some steps to migrate data ?
12:49:46 <anborn> Cale, I've tried with both available packages (both full an "essential")
12:50:26 <LordBrain> stepcut: it allows editing...
12:50:31 <Cale> postman: which example?
12:51:14 <postman> Cale: f v = runST (newVar v `thenST` \w-> readVar w)
12:51:16 <Cale> stepcut: People sort of have to migrate their own content due to licensing issues
12:51:31 <tibbe> I just checked out GHC and got a build error, any chance there are some devs here?
12:51:40 <postman> Cale: (with MutVar s a -> MutVar s a) as type
12:52:14 <postman> tibbe: if you are on a standard platform, you are most likely cause of the error.
12:52:15 <Cale> postman: in fact, it might as well have type a -> a
12:52:56 <Lemmih> tibbe: Did you get the error while building the libraries or GHC?
12:53:35 <Cale> Prelude Control.Monad.ST Data.STRef> let f v = runST (do w <- newSTRef v; readSTRef w)
12:53:35 <Cale> Prelude Control.Monad.ST Data.STRef> :t f
12:53:35 <Cale> f :: a -> a
12:54:06 <Cale> That they chose (MutVar s a) as a specialisation is irrelevant
12:54:32 <tibbe> Lemminh, the libraries
12:54:50 <tibbe> postman, actually I just got the nightly build report from GHC, it failed with the same error
12:55:08 <postman> tibbe: then I haven't said anything.
12:55:16 <Cale> However, you can't really get hold of a value of type (MutVar s a) without being inside a runST anyway.
12:55:34 <postman> tibbe: If you want to build it to _use_ it, check out an older version with darcs.
12:55:47 <tibbe> postman, I'm going to hack on it ;)
12:56:14 <postman> tibbe: don't break things ;)
12:56:43 <tibbe> postman, I'm actually going to try to add some polish by writing docs and looking for bugs
12:56:47 * Lemmih wonders if chak is patch spamming him.
12:56:49 <tibbe> postman, to libraries
12:57:13 <tibbe> btw, what's the best way of getting cabal-get?
12:57:56 <tibbe> argh, someone is spamming my inbox with patches
12:58:17 <ChilliX> Lemmih: :)
12:58:18 <Lemmih> cabal-get has been renamed to cabal-install, and cabal-install is distributed with Cabal.
12:58:20 <tibbe> 1 per / second
12:58:24 <ChilliX> Just 128 patches....
12:58:29 <ozone> ChilliX: greetings from san francisco
12:58:34 <ChilliX> Hi ozone
12:58:59 <ChilliX> the 1sec rhythm is courtesy dcoutts' dracs mail script
12:59:12 <tibbe> Lemmih, is Cabal distributed together with GHC?
12:59:28 <ChilliX> ozone: How is the meeting?
12:59:40 <Lemmih> tibbe: Yep.
12:59:50 <postman> Cale:  but that Scheme code also doesn't let references escape, right?
13:00:10 <ozone> awesome so far.  next version of mac os x looks like it'll have interesting features
13:00:44 <ChilliX> Lemmih: It's the patch set merging the HEAD with the branch on which we implement the new Core, GADT translation, and associated types
13:00:56 <lisppaste2> asbeta pasted "how does ghci option called to resolve this?" at http://paste.lisp.org/display/23797
13:01:32 <ChilliX> ..aka the ghc-fc2 branch
13:01:53 <postman> asbeta: import Prelude hiding (or), IIRC
13:02:02 <tibbe> Lemmih, my 6.4.1 version on Ubuntu doesn't have it, at least no binary called cabal-install
13:02:48 <asbeta> postman, sometimes there's two implementations of function with the same name... i don't want to make type-class for every such function
13:02:57 <Lemmih> tibbe: cabal-install is still a work-in-progress. You can get a development version from the latest Cabal repo.
13:03:10 <asbeta> as far as i know there was some extension in GHCi that solves that problem
13:03:19 <Cale> postman: well, it doesn't provide for it, but it doesn't really *prevent* it per-se
13:03:33 <stepcut> Lemmih: does cabal-get have to deal with 'or' dependencies ? For example, packageA | packageB ?
13:04:31 <tibbe> Lemmih, so I get cabal-install using darcs and then install it using runhaskell Setup.hs install?
13:04:33 <Cale> postman: The STRefs are sort of identified with the labels, so they simply cease to have meaning when leaving the context of run
13:04:56 <Cale> but you could easily write functions which import and export variables
13:05:13 <tibbe> Lemmih, or get it from here http://hackage.haskell.org/packages/cabal-get-0.2.1.tgz ?
13:05:18 <Cale> just return a pair consisting of the label and its value
13:05:27 <Cale> and then set it again
13:05:27 <Lemmih> stepcut: No, but that's because Cabal doesn't. Once it's implemented in Cabal, we'll merge it to cabal-install.
13:05:29 * tibbe hasn't used Cabal before
13:05:51 <Lemmih> tibbe: cabal-get is dead. Don't use it.
13:06:33 <Cale> Which is something that you can't quite do in ST in Haskell, since you can't record the name of an STRef -- it doesn't really have a name.
13:07:25 <Cale> (you can of course, dereference it and return the value, and then create a new STRef with that value inside another runST)
13:07:28 <postman> Cale: is it possible to run runST with a reference while staying in ST?
13:07:40 <tibbe> Lemmih, where exactly do I find cabal-install, I'm running around on the wiki in circles
13:07:44 <stepcut> Lemmih: I have some haskell code that solves debian dependencies -- if you need something like that, let me know
13:08:03 <Cale> Not really -- you can return an external reference, but not an internally created one.
13:08:29 <Lemmih> stepcut: Great, I'll remember that.
13:10:22 <postman> Cale: I don't understand why your Scheme example would work.
13:12:29 <postman> Cale: oh, I think I see, but that's not a disadvantage of Scheme.
13:12:37 <postman> Cale: I mean of this approach.
13:13:00 <Cale> yeah, it's not really a problem so much
13:13:46 <Cale> of course, it points at one difference
13:14:04 <Cale> The scheme approach requires all variables to have (computation global) names.
13:17:44 <Cale> It's an advantage of ST that you can control which parts of a computation have access to a variable by passing or not passing it into them.
13:19:23 <musasabi> One fun variation is a monad that allows reading any variables, but writing only to local ones.
13:19:53 <postman> Cale: yes, in other words ST provides more locality. I wonder whether this Scheme implementation could be changed s.t. it does.
13:20:03 <postman> s/does/does too
13:20:05 <musasabi> Type signatures like with ST but readVar :: Var anyst type -> MyM otherst type
13:20:08 <Cale> yeah, it almost certainly could
13:20:18 <Cale> well, hmm
13:21:41 <postman> When you accept this line of reasoning then C could be considered "pure" and "referentially transparent" too. :P
13:23:05 <Cale> postman: well, it's certainly possible to program in C in a pure and referentially transparent way
13:23:10 <Cale> but nobody does :)
13:25:14 <Cale> The thing is, the language doesn't enforce it, which is the real concern. The ability to express restrictions in a language is a measure of expressiveness too, and one which is often forgotten.
13:25:27 <Pupeno> every time I read about Haskell I wish I was still codding in Haskell.
13:25:44 <Cale> What are you coding in now?
13:25:55 <postman> Cale: right, I think that having more local code, has more code quality. STRef encourages you to do so.
13:26:40 <Philippa> postman: not really. There's a surprising number of pure terms involved in any given chunk of monadic code
13:26:47 <Pupeno> Cale: my job is in Python.
13:28:28 <Pupeno> Cale: and I've tried to use Haskell for a personal project, but doing binary io was a pain and eventually I picked Erlang. But Haskell still remains as one of the coolest of the languages I ever used... just little below lisp :)
13:29:12 <roconnor> will haskell' have binary IO?
13:29:27 <ChilliX> roconnor: pretty likely
13:29:37 <Heffalump> will I burn in hell for changing some of the constructors of Name in template-haskell to not use unboxed ints?
13:29:40 <Philippa> roconnor: if not, I think several people'll be obliged to commit seppuku
13:30:48 <Cale> Pupeno: yeah, binary IO's been a problem, which is silly, because it seems like something easy, it's just that nobody got around to taking care of it until recently.
13:31:01 <stepcut> For ghc 6.8 we would solve the 'binary i/o' problem
13:31:05 <Cale> Pupeno: Don Stewart's ByteString is a pretty cool library.
13:31:08 <Cale> 6.6
13:31:12 <roconnor> Does this mean that Data.Word8 becomes part of the standard?
13:31:16 <stepcut> s/would/should/
13:31:29 <Pupeno> Cale: the "until" at the end gives hope. How much time is recently ?
13:31:35 <postman> Philippa: What do you mean by that? Mixing pure and non-pure code can't be avoided always.
13:31:45 <Cale> Pupeno: last few months?
13:32:24 <Cale> Pupeno: http://www.cse.unsw.edu.au/~dons/fps.html
13:33:13 <Cale> We can beat naive C programs at some tasks now.
13:33:26 <Pupeno> Cale: what is FPS exactly ?
13:33:28 <roconnor> what does fps have to do with binary IO?
13:33:37 <Cale> Data.ByteString
13:33:48 <Cale> It's not just character strings now.
13:33:49 <Philippa> postman: once you've got your input in, odds are a very large chunk of what you do with it's pure. Even the stuff you do in a do statement before applying an action to it
13:34:05 <sjanssen> roconnor: the IO functions in Data.ByteString do binary IO
13:34:19 <roconnor> ByteString will be our IO interface?
13:34:27 <Pupeno> well, when I have time, I'll take a further look at it and try to turn my code that did binio to it and see how it looks. Thanfully, I still have my code.
13:35:08 <ChilliX> roconnor: Data.Word8 is already part of the language if language = H98 + FFI addendum + hierachical libs addendum (which is pretty much what everybody assumes)
13:35:21 <roconnor> ByteString is for fast binary IO, but right now we have no binary IO.  Shouldn't we get slow binary IO first?
13:35:30 <Cale> Pupeno: It's a library for manipulating strings of bytes quickly
13:35:47 <Cale> roconnor: isn't it?
13:35:49 <sjanssen> we do have binary IO, it just isn't in the standard
13:35:58 <Cale> hGet :: Handle -> Int -> IO ByteString
13:36:10 <Cale> hPut :: Handle -> ByteString -> IO ()
13:36:39 <Philippa> sjanssen: we don't have much vaguely convenient binary IO though
13:36:51 <Philippa> at least, in the absence of FPS
13:36:54 <Philippa> er, ByteString
13:37:00 <ChilliX> roconnor: Here is the Haskell' status re bin io: http://hackage.haskell.org/trac/haskell-prime/wiki/BinaryIO
13:39:31 <postman> Philippa: yes, but what's your point? Are you implying that lots of Haskell code currently being written doesn't work in that way?
13:39:59 <postman> http://www.youtube.com/watch?v=f3A6vvslIYQ&mode=related&search= <- this guy is pretty funny.
13:40:36 <emertens> Hugs> :module List
13:40:37 <emertens> ERROR - Cannot find module "List"
13:40:40 <roconnor> @hoogle Handle -> [Word8]
13:40:42 <emertens> what might I be doing wrong in WinHugs
13:40:47 <roconnor> @hoogle Handle -> IO [Word8]
13:40:53 <lambdabot> No matches, try a more general search
13:40:59 <roconnor> @vixen come here baby
13:41:01 <lambdabot> No matches, try a more general search
13:41:02 <lambdabot> People think I'm weird...   do you?
13:41:24 <roconnor> There is no function hGetBinaryContents is there?
13:41:43 <Cale> emertens: I think module is for loading modules that are in the current directory
13:41:49 <Cale> emertens: try :alse
13:41:52 <Cale> emertens: try :also
13:42:06 <emertens> Cale: that works, thank you
13:42:17 <Philippa> postman: my point is that C et al don't work that way at all
13:43:08 <Cale> roconnor: there is in ByteString :)
13:43:18 <roconnor> oh
13:43:19 <postman> Philippa: I agree fully with that. I don't think Scheme would be in that category. Would you?
13:43:19 <roconnor> :)
13:43:39 <Cale> roconnor: there's even a lazy one in Data.ByteString.Lazy
13:43:53 <Cale> roconnor: and it'll be in 6.6
13:44:01 <norpan> People.Programmer.Lazy.norpan
13:44:40 <sjanssen> roconnor: how about import Data.ByteString as B; hGetBinaryContents h = fmap BS.unpack $ BS.hGetContents h
13:47:58 <Philippa> postman: it's not significantly easier to spot pure code in Scheme than in C, frankly. It may even be harder.
13:50:01 <dcoutts__> ChilliX: heh, the 1-sec thing was to try and make sure the emails would all get time stamped in order
13:50:14 <ChilliX> dcoutts: I know :)
13:50:30 <ChilliX> Neverthless a nice effect when pushing 128 patches :)
13:50:35 <dcoutts__> indeed
13:50:45 <dcoutts__> ChilliX: I've been hearing bad things about the darcs ghc/ghc-fc merging
13:51:06 <Heffalump> ChilliX: but it's ok now, dcoutts__ doesn't think darcs has any problems, so he can do the merge!
13:51:12 <dcoutts__> at AngloHaskell Heffalump was talking about the difficulties in the design of marging/conflicting in darcs
13:51:12 * Heffalump gd&r
13:51:23 <dcoutts__> hah
13:51:37 <dcoutts__> Heffalump: s'ok you explained it, I believe you now :-)
13:51:42 <ChilliX> Well, the fact that darcs doesn't handle conflicts in large projects well made it quite laborous
13:51:46 <Heffalump> oops, sorry ChilliX...
13:51:53 <Heffalump> it doesn't handle conflicts well at all, really.
13:52:16 <Heffalump> you can get badly nested conflicts in small projects if you have a lot of conflicting patches, too
13:52:22 <ChilliX> Heffalump: if they don't spawn children and grandchilden it'd be ok, I guess...
13:52:32 <ChilliX> Heffalump: yeah, that's true
13:53:26 <ChilliX> dcoutts: besides, this was the 2nd merge.  During the first onme SPJ ran into the darcs problem, gave up and made on large monster patch including all changes on the branch so far.
13:54:08 <ChilliX> As that patch has lots of core infrastructure changes, (1) almost all later patches dependent on it and (2) as it was so big it of course had lots of confliucts with the HEAD
13:54:13 <petekaz> sounds like I should not have switched from svn to darcs with all these glowing reviews.
13:54:34 <ChilliX> Pete_I: darcs is still the best source contro system I know
13:54:43 <ChilliX> oops, petekaz, I mean
13:55:00 <ChilliX> svn wouldn't have helped a bit
13:56:06 <Heffalump> OTOH it wouldn't have let you get into this situation, but only because it handles conflicts by just dumping them on the user and saying "I won't do anything until you fix these"
13:56:29 <petekaz> so pick your poison?
13:56:38 <Heffalump> indeed.
13:56:43 <ChilliX> Heffalump: well, the result would have been that I would have had to do the same thing
13:58:17 <ChilliX> If the thing with the monster patch from the previous merge attempt wouldn't have been the case, I would probably have spent the large majority of the time on the actual semantic conflicts - ie, those due to simultaneous changes in both branches that are incompatible and require to write new code anyway
13:59:17 <postman> I'd like Haskell Prime to have a sane array interface or user-definable syntax. readArray a i, where C uses a[i] kills readability.
13:59:21 <ChilliX> In any case, it'd be worthwhile to document the problem and how to handle it for other uses
13:59:52 <Heffalump> yeah. kowey seems to have volunteered to do that.
14:00:07 <ChilliX> dcoutts: Nevertheless, it'd be *very* much appreciated if you guys can figure out a way to solve this merge problem.
14:01:11 <tibbe> Lemmih, Is the "Thin out cabal-get and integrate in GHC" Google SoC project really about cabal-install then since cabal-get is dead?
14:01:12 <LordBrain> on nix, binary and text arent distinguished...
14:03:00 <kpreid> postman: binding readArray to an infix name isn't sufficient?
14:05:22 <Philippa> kpreid: I can see how it might be aggravating if you're used to C, and I can see why hanging on to the C-style bracketing might have advantages
14:05:44 <danb> @pl (a -> b -> c) -> b -> a -> c
14:05:47 <norpan> what's wrong with the a!i syntax?
14:05:48 <Philippa> tbh though it doesn't get you all that much without something like idiom brackets though
14:05:51 <LordBrain> hmmmm, in Scheme anything impure is prefixed with a !, its a convention... but everybody follows it.. and it makes it easy to spot impure code.. if someone really wanted to mess things up in haskell they could throw unsafePerformIO's everywhere...
14:05:53 <lambdabot> (line 1, column 4):
14:05:53 <lambdabot> unexpected ">"
14:05:53 <lambdabot> expecting variable, "(", operator or ")"
14:06:23 <Philippa> LordBrain: not in standardised Haskell. And you have to import unsafePerformIO before using it
14:06:24 <danb> @djinn a -> a
14:06:29 <danb> @help
14:06:38 <danb> @commands
14:06:41 <lambdabot> f a = a
14:06:41 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:06:41 <lambdabot> Unknown command, try @list
14:07:02 <Trevion> @pl \f a b c -> f c a b
14:07:03 <danb> privating...
14:07:32 <kpreid> > let cSyntax l[i] = l !! i; a = cSyntax ["abc","def"] in a[1][1]
14:07:40 <kpreid> :-)
14:07:50 <kpreid> er, that won't work, actually
14:08:03 <LordBrain> i should say its postfixed with a !
14:08:05 <LordBrain> sorry
14:08:24 <lambdabot> (flip .) . flip
14:08:28 <lambdabot>    The function `a' is applied to two arguments,
14:08:30 <lambdabot>   but its type `[Int] ->...
14:09:35 <kpreid> > let cSyntax l[i] = l !! i; a = cSyntax $ map cSyntax ["abc","def"] in a[1][1]
14:09:41 <lambdabot>  'e'
14:10:01 <Cale> http://www.youtube.com/watch?v=mg7UMiluQK4&NR -- more Colbert
14:10:21 <Lemmih> tibbe: Yes.
14:11:23 <postman> norpan: Oh, I didn't found that one yet. I came up with a <> i though. a ! i is better. :)
14:11:38 <norpan> ! is already used for array indexing in haskell
14:11:52 <mux> yay, I can use HXT
14:12:04 <LordBrain> its !! for array indexing..
14:12:14 <mux> at least, the arrow interface
14:12:15 <LordBrain> or no, thats list
14:12:17 <kpreid> @hoogle (!)
14:12:19 <lambdabot> Did you mean: (!)
14:12:19 <lambdabot> Prelude.undefined :: a
14:12:19 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
14:12:28 <LordBrain> @hoogle (!!)
14:12:29 <lambdabot> Did you mean: (!!)
14:12:30 <lambdabot> Prelude.undefined :: a
14:12:30 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
14:12:33 <norpan> @type (!)
14:12:34 <lambdabot> forall e i. (Ix i) => Array i e -> i -> e
14:12:44 <LordBrain> why does it say Did you mean?
14:12:44 <danb> yay fun
14:12:45 <danb> @compose pl djinn (a -> b -> c -> d -> e -> f -> g -> z -> r) -> z -> a -> b -> c -> d -> e -> f -> g -> r
14:12:52 <postman> @info MArray
14:12:58 <lambdabot> f = ((((const .) .) .) .) . flip . ((flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .)) .) . flip flip id . ((flip . ((flip . (ap .)) .)) .)
14:12:58 <kpreid> lots of !s in various modules
14:13:00 <lambdabot> Unknown command, try @list
14:13:03 <LordBrain> anybody write a precedence plugin yet?
14:13:21 <LordBrain> @prec (||)
14:13:21 <lambdabot> Unknown command, try @list
14:13:22 <mux> wow, that @compose got lambdabot seriously thinking
14:13:39 <LordBrain> lol
14:14:38 * danb brain-explodes
14:15:02 <postman> norpan: It seems ! is only for immutable arrays.
14:15:03 <LordBrain> hey, point free starts looking like lisp
14:15:35 <kpreid> postman: ! has many different definitions
14:16:09 <SamB> except in lisp you only write the dots out if you need an improper list
14:16:14 <postman> kpreid: Does it work for MArray in a recent GHC release? I don't think so.
14:16:33 <SamB> postman: indeed not
14:16:33 <ChilliX> www/mi
14:16:38 <ChilliX> oops
14:16:48 <kpreid> postman: you can define it yourself
14:16:59 <SamB> kpreid: but, it still wouldn't work right
14:17:10 <kpreid> oh. monadic. right.
14:17:16 * kpreid shuts up
14:17:27 * Heffalump waits for ghc to recompile
14:17:59 <ChilliX> Heffalump: don't we all
14:18:17 <mux> heh, I managed to get some small HXT code to finally parse and print all the game names from the xmame XML gamelist
14:18:29 <mux> but it's still taking 1.2G memory and taking a looong time :-)
14:18:40 <LordBrain> hmm i still find it easier to think in oop... but i'm reluctant to try oop concepts in haskell...
14:18:41 <mux> I suppose there are various stuff I could do to improve situation
14:18:45 <SamB> mux: wow
14:19:02 <mux> 1.2G total, 740M resident
14:19:12 <mux> and my swap is getting used!
14:19:14 <mux> outrageous!
14:19:35 <LordBrain> geez
14:19:37 <sehute> which sane heterosexual male would wish to wear this t-shirt: http://www.cafepress.com/statictypes ? :-)
14:19:37 <SamB> mux: like rewriting HXT to use interned identifiers (tag and attribute names) and packed strings?
14:19:41 <postman> kpreid: ok
14:19:41 <postman> Still, using a ! i =  readArray a i, only eliminates readArray calls from your code. You still are left with writeArray calls. It's not symmetric.
14:19:42 <postman> mux: how large is the file?
14:19:47 <LordBrain> i wish i had 740M... i'm working with 160 i think.
14:20:03 <mux> SamB: I think there is much more low-hanging fruits to collect first
14:20:20 <mux> postman: 24M
14:20:30 <mux> 429203 lines
14:20:49 <postman> mux: ouch
14:21:09 <mux> my HXT code probably sucks though
14:21:18 <postman> mux: that's indeed outrageous.
14:21:41 <SamB> well it does use unpacked strings
14:21:51 <mux> postman: IIRC, HaXml was completely shitting itself
14:21:54 <SamB> and unpacked strings take, what, 24 bytes a char?
14:22:10 <SamB> > 24 * 24
14:22:11 <lambdabot>  576
14:22:17 <postman> mux: "shitting itself"?
14:22:19 <mux> except in an ideal world, HXT shouldn't ever need to remember more than a few lines
14:22:25 <SamB> mux: well.
14:22:27 <mux> postman: couldn't even got it to parse & print the file
14:22:44 <mux> SamB: I'm just matching some tag names and attributes, and printing the game name with an arrIO
14:22:47 <mux> and then >>> none
14:22:58 <postman> mux: you didn't understand the interface, or just memory problem?
14:23:19 <mux> postman: just memory problem, my code was correct
14:23:20 <SamB> mux: but it needs to put much of that in its tree
14:23:36 <SamB> you do realize HXT builds a tree in-memory, right?
14:23:50 <Heffalump> ChilliX: I just hit ^C in the window by accident :-)(
14:24:03 <Heffalump> and I'm building a debian package so I have to start again. Grmph.
14:24:12 <ChilliX> urgh
14:24:12 <mux> I don't, I don't know much how it works internally, I was supposing the lazy nature of Haskell would preclude from it trying to do too much work
14:24:15 <sehute> how can I find out which classes that belongs in Num? (I've got GHC and a browser)
14:24:22 <postman> mux: Hmm, annoying. I am using HaXml too now, but my files will be <1MB so it would be much of a problem.
14:24:26 <SamB> mux: Parsec doesn't work like that
14:24:36 <SamB> unfortunately
14:25:10 <postman> > length [1..] == length [1..]
14:25:12 <sehute> > 1 quot 2
14:25:16 <mux> that's too bad it's using Parsec, which has a monadic interface with known efficiency issues that led to arrows development, while HXT itself is all arrows
14:25:23 <lambdabot>  add an instance declaration for (Num ((a -> a -> a) -> t -> a1))
14:25:23 <lambdabot>   In the...
14:25:25 <mux> anyways, I'm going to try a few things.
14:25:26 <lambdabot> Terminated
14:26:05 <SamB> well, I doubt either of the others does any better
14:26:26 <SamB> I kinda suspect they do worse
14:26:52 <mux> mmm, there's not much left to disable in the readDocument arrow
14:26:58 <mux> I already turn validation off
14:27:25 <mux> maybe recoding the readDocument arrow to use FPS would do good
14:27:25 <postman> SamB: what others?
14:27:52 <SamB> other XML libraries
14:28:00 <SamB> HaXml is one
14:28:05 <SamB> HXML is the other
14:28:44 <mux> SamB: considering you seem to know about HXT a fair bit, I'd be happy if you could take a look at the code and give ideas
14:28:47 <mux> http://mu.org/~mux/Main.hs
14:29:01 <SamB> I don't know that much...
14:29:17 <mux> it's so simple I don't know what horrible things could lurk in there though..
14:29:18 <SamB> just because I've looked at it long enough to know that it uses Parsec...
14:29:27 <mux> I've seen it uses Parsec too :-)
14:29:35 <mux> it was clear already at the building stage
14:30:07 <SamB> I suspect the most horrible thing to be the fact that Parsec insists that you finish parsing *before* returning a result
14:30:32 <mux> are you 100% positive the fact tht HXT is using Parsec forces that behaviour?
14:30:41 <SamB> well.
14:31:25 <SamB> there might be some extremely clever hack that could be used to get around this, but I don't see what sort. and it would be horribly evil.
14:31:46 * SamB wonders what the *real* way to allow lazy parsing is
14:32:04 <mux> well, arrow-based parsers should, unless I'm missing something
14:32:20 <SamB> what do they do with parse errors?
14:32:51 <mux> I suppose the output type of the arrow could contain it?
14:33:09 <mux> similarly to what Parsec does for its Parser type
14:33:15 <mux> GenParser
14:33:17 <mux> whatever
14:33:24 <SamB> well...
14:33:42 <postman> I don't like HXT as it doesn't separate the pure code from the IO code.
14:33:45 <mux> @last dons
14:33:45 <lambdabot> I haven't got any logs for that channel.
14:33:51 <SamB> how would it know whether there was a parse error before parsing, though?
14:33:52 <mux> @seen dons
14:33:53 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 7 hours, 14 minutes and 28 seconds ago.
14:34:02 <SamB> postman: yeah, that is kinda icky too
14:34:20 <postman> SamB: Actually, there is a pure interface, but it's hard to find.
14:34:41 <postman> The interface is way too bloated.
14:34:43 <sehute> #haskell-se
14:34:44 <SamB> maybe we should make yet another XML library that doesn't expose so much guts unless you ask for it
14:35:14 <sehute> (typo)
14:35:31 <mux> go, go, gadget-o-HXT!
14:35:37 <SamB> I mean, much of what is exported by many of the modules ought to be in something with a more private-sounding name
14:35:43 <mux> postman: that's true, it's waaaay too versatile
14:35:50 <SamB> mux: that isn't all of it
14:35:52 <postman> HaXml is apparently ultra-slow and HXT is badly designed.
14:36:00 <tibbe> argh, I keep running around in circles, where do I get cabal-install, I currently do Cabal->Hackage->HackageDb->cabal-get->Cabal loops on the wiki
14:36:15 <postman> And then we have HXML, which is a toy, AFAIK.
14:36:18 <SamB> also it exports many things that don't want exporting...
14:36:40 <mux> well that situation ain't satisfactory.
14:36:57 <postman> I rather had that people didn't release these "libraries", since they are _not_ reusable.
14:37:23 <SamB> anyway, such a new library should support not using IO as the foundation of its Arrow...
14:37:42 <SamB> and should have a publicly accessible darcs repo to which patches are gladly accepted
14:37:46 <postman> That new String library by dcoutts__ and dons is something which can qualify being a library.
14:37:49 <SamB> as long as they don't mess up the interface
14:37:58 <mux> as long as it's still possible to stick some IO actions into the mix
14:38:03 <postman> It actually does something useful, as does the Prelude.
14:38:25 <mux> Parsec sucks for that, since there is no ParsecT, you can't put IO actions
14:38:33 <SamB> mux: yeah
14:38:45 <SamB> but apparantly I'm no good at selling ParsecT
14:38:45 <Cale> postman: What's wrong with HXT exactly?
14:38:58 <SamB> oh, okay, so actually there were a ton of SoC applicants...
14:39:06 <mux> Cale: try to parse a 24M XML file with it
14:39:26 <mux> Cale: even if only for printing a few attributes on the script and discarding all the input
14:39:32 <mux> arg
14:39:35 <mux> s/script/screen/
14:39:47 <SamB> Cale: also the modules export much more than is desirable
14:39:55 <Cale> mux: Where are you going to get such an abusively large XML file? :)
14:40:06 <mux> Cale: the XML game list from MAME :-)
14:40:24 <mux> this was just the very first thing I could think of to try to do some HXT code
14:40:37 <mux> and it now seems like it as a good idea - a lot of fun!
14:40:49 <mux> I don't get to use my swap slice often
14:40:53 <SamB> I still want to know how you are supposed to deal with parse errors lazilly
14:40:57 <postman> Cale: 1) have a look at the Haddock documentation for evidence for it's bloated interface. 2) It incorporates the IO monad unnecesarily  3) mux claims it's also slow.
14:41:00 <Cale> Hmm, so HXT is really slow?
14:41:13 <mux> Cale: that should give you an idea :
14:41:19 <mux> 38657 mux           1 -20    0  1260M   739M swread   1:23  1.07% hmame
14:41:35 <SamB> Cale: it eats the whole file, or tries
14:41:53 <SamB> because Parsec doesn't know any other way
14:41:57 <mux> I didn't measure yet, will run time to see, but it's taking like 10 minutes or something
14:42:10 <mux> and that's when disabling validation, namespace checks etc
14:43:20 <stepcut> spaeking of XML, it would be nice to have an 'online' xml parser that can return results before it is done parsing the whole file -- so it can be used on streams like jabber/xmpp
14:43:39 <Cale> Are there XML libraries in existence which have not-stupidly-bloated interfaces? I've always sort of figured that it's because XML is a bloated standard.
14:43:45 <mux> HXT can print stuff before it's done parsing
14:43:58 <SamB> Cale: XML isn't that complicated
14:44:07 <mux> you can easily stick IO actions with arrIO, arrIO0, arrIO2 etc
14:44:27 <SamB> mux: and those happen before parsing is complete?
14:44:46 <Cale> SamB: so I should just ignore the dozen or so long papers by the w3c?
14:44:56 * stepcut is trying to install HXT to see it could work for jabber, but cabal is bombing out with an error trying to invoke 'ar'
14:44:57 <stepcut> :(
14:45:01 <mux> SamB: before your parsing, so your dealing with [XmlTree], is complete - so I suppose that's after Parsec is done
14:45:10 <SamB> Cale: hmm, which papers?
14:45:29 <Cale> http://www.w3.org/TR/2004/REC-xml11-20040204/ -- this is one
14:45:38 <SamB> stepcut: it doesn't support lazy parsing anyway
14:45:40 <postman> mux: HaXml also has a SAX interface, I don't know whether that also depends on Parsec.
14:45:43 <SamB> Cale: okay
14:45:44 <SamB> that is one
14:45:51 <mux> that's XML 1.1
14:45:56 <mux> we would do with XML 1.0 :-P
14:46:16 <SamB> what is wrong with XML 1.1? does it add something?
14:46:35 <mux> I wasn't meaning that
14:46:46 <mux> just that if we had a proper XML 1.0 parser life would be great already
14:46:49 <SamB> anyway, that is one
14:46:53 <Cale> Then there's XSL and XSLT, and XPath and XPointer and XML Schema, and Query, and on and on
14:46:58 <mux> I don't have anything against XML 1.1, but I suppose it's a bit more work at least
14:47:04 <mux> Cale: RDF!
14:47:18 <SamB> XSLT and XSL:FO are not needed, exactly...
14:47:25 <SamB> mux: RDF is just an application of XML...
14:47:40 <SamB> none of those things need to be in the XML library
14:47:42 <mux> yeah yeah, just adding more fun on Cale's plate
14:47:47 * edwardk waves hello.
14:48:03 <sehute> hi
14:48:42 <postman> Regarding XML libraries: I read that SXML's XPath implementation completely obliterated popular implementation in Java and C.
14:48:57 <Cale> Well, you'd probably want schemas
14:49:06 <mux> we should get Uwe Schmidt in here
14:49:26 <postman> I believe the Java and C implementations used exponential space in the depth of the expression.
14:49:53 <edwardk> ouch
14:50:10 <SamB> and certainly all of those things cannot explain the needless exports from unrelated HXT modules
14:50:25 <SamB> those things would generally be in their own modules...
14:50:27 <mux> Cale: I think that initially we would only care about XML 1.0 and DTD support (parsing it and using it for validation)
14:50:33 <postman> (where the Scheme version scaled linearly)
14:50:59 <stepcut> maybe we can just make a scheme interpreter in haskell and run the scheme xml parser on that :p
14:51:11 <mux> I don't mind the parser using arrows etc, can be really useful, but when it's using so much new stuff you actually need to learn a new language (the HXT language!) maybe it's overkill
14:51:24 * edwardk has to cobble together a fair chunk of xml support as a part of the javascript haskell thing, at least enough for e4x. whats out there now that does xml in haskell?
14:51:28 <SamB> mux: I would only care about getting the entities right as far as the DTD goes...
14:51:34 <mux> this is a problem with Haskell
14:51:58 <mux> EDSL are cool, but you can be completely lost with some piece of haskell code :-)
14:51:58 <SamB> too many EDSLs?
14:52:04 <mux> whereas C is just always plain C
14:52:13 <edwardk> i found a couple of projects, haxml etc,
14:52:13 <mux> except when stupid guys use macros oto much though.
14:52:17 <SamB> but you get lost in the reams anyway
14:52:25 <mux> not as much at least
14:52:35 <mux> but anyways, I'm digressing
14:53:21 <SamB> yeah, HXT is disgusting
14:53:44 <mux> I learnt the arrow interface by reading the thesis of the guy who designed it
14:53:50 <LordBrain> hmm... i wonder if it would make sense to have a highly threaded text buffer in yi, which always keeps track of where the beginning or end of your word is or paragraph or sentence or selection...
14:53:51 <mux> every damn new line he introduces a new arrow
14:53:53 <postman> mux: me too
14:53:53 <mux> or nearly
14:54:02 <SamB> ouch
14:54:03 * edwardk chases down the hxt website, and realizes that the uwe schmidt in question isn't the DJ =)
14:54:11 <mux> that gets seriously annoying when you reach ArrowIf
14:54:23 <postman> mux: I had to laugh very hard when he said something along the lines that it was very easy.
14:54:40 <mux> I'm happy to hear I'm not the only one lost in there
14:54:56 <mux> I'm quite a newcomer to haskell so I thought it would maybe be much more straightforward for other people
14:55:13 <mux> 92.91s user 7.43s system 19% cpu 8:36.55 total
14:55:18 <SamB> the code is not much better
14:55:19 <mux> ouch.
14:55:25 <SamB> in fact it is porbably much worse
14:55:30 <Heffalump> the thesis of which guy?
14:55:52 <mux> Manuel Ohlendorf
14:55:56 <edwardk> i think they mean http://www.fh-wedel.de/~si/HXmlToolbox/cookbook/doc/thesis.pdf
14:56:01 <mux> A Cookbook for the Haskell XML Toolbox
14:56:01 <mux>    with Examples for Processing RDF
14:56:01 <mux>               Documents
14:56:04 <mux> yeah
14:56:15 * edwardk is reading it now
14:56:50 <Philippa> the problem with C being always plain C is that it doesn't carry any of the domain info
14:57:07 <SamB> nevermind that prolog is probably more suited to RDF processing
14:57:28 <SamB> Philippa: and that it lacks polymorphism
14:57:32 <SamB> and a million other things
14:57:43 * edwardk has come to hate rdf.
14:57:51 <mux> Philippa: I think that precise thing can be an advantage
14:57:56 <edwardk> afk a bit
14:58:15 <mux> gah! fucking stupid shitty netscreen firewall
14:59:24 <lokadin> how could i make a [String] into a [[String]],
14:59:43 <Philippa> mux: I don't think it generally can. May as well just read the implementation of the EDSL
14:59:54 <postman> lokadin: f x = [x]
15:00:05 <LordBrain> it could keep going... say you open a readonly buffer, it could figure out where all the word boundaries are, all the paragraph boundaries, all the sentence boundaries, section boundaries etc... so its all there once open, rather than figure it out as you need it...
15:00:18 <lokadin> postman: very smart :) kk i'll go try that
15:00:52 <stepcut> sooooo, how are we going to get from where we are to having a top-notch XML library ?
15:00:55 <mux> @djinn [a] -> [[a]]
15:00:55 <lambdabot> -- f cannot be realized.
15:01:53 <SamB> Philippa: which brings us back to the problem with HXT: there are too many damn exported functions
15:02:07 <mux> > inits "foo"
15:02:10 <lambdabot>  ["","f","fo","foo"]
15:02:15 <LordBrain> hmmm or just go starting with where your cursor is... and stop after a certain point on either side..
15:02:27 <mux> bah
15:02:34 <Cale> SamB: so just go through it and delete things from the export list?
15:02:48 <SamB> Cale: that might not be sufficient
15:02:59 <SamB> maybe some modules do need some of them
15:03:11 <Philippa> SamB: is there at least an identifiable core?
15:03:13 <mux> you know, you can chose not to important the main HXT module which imports all the rest
15:03:19 <mux> s/important/import/
15:03:20 <SamB> Philippa: its difficult to say
15:03:29 <LordBrain> then it could be modified for different formats... tag boundaries in xml, etc..
15:04:24 <SamB> anyway, I think a nice public repo would help a lot...
15:04:36 <postman> HXT seems build with the idea: let's build something with arrows. No real purpose.
15:04:47 <SamB> postman: well. the arrows interface, yeah.
15:05:21 <postman> I mean that it does not have the goal, nor is tested for, actual applications of the library.
15:05:45 <SamB> everything is like: hey, i need to write a paper, so how about if I also write all this bad code and send it in
15:05:49 <LordBrain> if done right, the threads could mabye just be lazy anyway... so you can let it go on infinitely to fill the file... lets see...
15:05:55 <postman> SamB: indeed
15:06:15 <musasabi> How is ghc-fc2 different from ghc-fc ?
15:06:19 <SamB> did anyone respond to my post to the libraries list?
15:06:24 <LordBrain> since you might be interested in only one side of a region, we could have separate lists for beginnings and ends.
15:06:32 <postman> SamB: What post?
15:06:36 <SamB> I sent in a darcs repo, I think...
15:06:41 <postman> SamB: (not that I read libraries)
15:06:52 <SamB> it had to do with a RNG Compact implementation
15:07:57 <SamB> it seems to me like RNG support without RNG Compact support is pretty useless
15:08:11 <musasabi> Seems like chak's own changes branch.
15:08:43 <SamB> anywaay we need a better XML library
15:08:57 <LordBrain> and because you might go backward or forward from the cursor, we might have four lazy lists for a given region type... wordsTheLeft = ([beginWord],[endWord]), wordsToTheRight = ([beginWord],[endWord])
15:09:10 <ChilliX> musasabi: ghc-fc2 is ghc-fc merged with the head of last Friday
15:09:40 <ChilliX> musasabi: but you remind me that I should mark ghc-fc as obsolete
15:10:07 <Jonex> Is it possible to write a nice looking maze solver with haskell?
15:10:17 <stepcut> Jonex: yes
15:10:29 <LordBrain> yeah.. i'd think that kind of thing would be really nice in haskell
15:11:12 <SamB> just build the maze graph and then build the solution tree and do a breadth-first search ;-)
15:11:36 <edwardk>  m
15:11:43 <Jonex> Hmm, then I gotta be doing something wrong. Because I can't come up with a way to go trhough all directions without having loops.
15:12:07 <stepcut> Jonex: does the maze have only one solution ?
15:13:00 <stepcut> ?google maze solving algorithms
15:13:04 <lambdabot> http://www.astrolog.org/labyrnth/algrithm.htm
15:13:04 <lambdabot> Title: Think Labyrinth: Maze Algorithms
15:13:53 <SamB> Jonex: loops are why I said a breadth-first search
15:14:08 <lokadin> if i have a string "lo nanmu ku cu klama" i ran words on it to make it a [String], then i run a function to make it [[String]], what does it look like? and how do i access the parts of the string to evaluate them?
15:14:43 <SamB> > words "lo nanmu ku cu klama"
15:14:45 <Jonex> stepcut: Well, really, I'm not solving a maze, but I think some of the problems I'm seeing are common to a maze.
15:14:50 <chessguy> one approach to generating a maze with only one solution: http://cs.hbg.psu.edu/comp440/ProblemSet5.pdf
15:14:51 <lambdabot>  ["lo","nanmu","ku","cu","klama"]
15:15:09 <stepcut> Jonex: http://www.cse.ogi.edu/PacSoft/publications/2001/modular_lazy_search_jfp.pdf
15:15:19 <lokadin> > f x = [x]
15:15:20 <lambdabot>  Parse error
15:15:39 <lokadin> hmmm
15:16:17 <lokadin> i tried doing that in ghci, but i don't really know how to declare functions in it or anything
15:16:19 <stepcut> Jonex: that paper has some nice algorithms for doing searching... that might help
15:16:22 <musasabi> ChilliX: thanks.
15:17:14 <SamB> > (:[]) "hello"
15:17:16 <lambdabot>  ["hello"]
15:17:31 <ChilliX> lokadin: put the fun defs in a file and load in ghci that with :l <filename>
15:17:51 <Jonex> If you could give me advice by watching the python code, that'd be nice: http://www.deadbeefbabe.org/paste/1443
15:17:53 <lokadin> > (:[]) $ words "lo nanmu ku cu klama"
15:17:54 <lambdabot>  [["lo","nanmu","ku","cu","klama"]]
15:17:56 <ChilliX> that=<epsilon>
15:18:08 <Jonex> I'm planning of rewriting it in Haskell to get speed.
15:18:41 <postman> That's a new one :P
15:19:09 <SamB> well, you have to admit that with python, it is reasonable to want to do that...
15:19:18 <postman> Must have been the language shootout having its effect on people...
15:19:43 <ChilliX> postman: fps has shown, we can even beat C
15:19:45 <stepcut> Jonex: I would recommend the modular lazy search paper -- it should give you some ideas on how to tackle that type of problem
15:19:56 <Jonex> Yeah, Python is the wonderfullest language there is. ;) But it's achilles heel is in the speed, and it lacks full recursion.
15:20:03 <hitodama> is there anyway to get access to an interpreter inside Visual Studio when using Visual Haskell?
15:20:17 <Jonex> I don't like things in pdf, but I guess I'll have a look at it.
15:20:31 <stepcut> Jonex: Well, there are goods things inside that pdf :)
15:21:08 <Jonex> But in an unpractical format, pdf files are so hard to read on screen imo.
15:21:22 <postman> Jonex: what's a better format?
15:21:42 <postman> Jonex: I actually don't like PostScript (and only because I can't search in it)
15:21:49 <lokadin> > span (== ku) $ words "le nanmu ku cu klama"
15:21:52 <Jonex> I prefer html, then I can apply my own font, color and size to the text.
15:21:53 <lambdabot>  Not in scope: `ku'
15:22:02 <lokadin> > span (== "ku") $ words "le nanmu ku cu klama"
15:22:03 <lambdabot>  ([],["le","nanmu","ku","cu","klama"])
15:22:07 <stepcut> Jonex: you might also look at the sudoku solver page
15:22:09 <SamB> Jonex: that doesn't work so well for maths
15:22:26 <Jonex> SamB: I don't lika maths :P
15:22:28 <stepcut> http://www.haskell.org/haskellwiki/Sudoku
15:22:29 <lambdabot> Title: Sudoku - HaskellWiki
15:22:35 <postman> Jonex: documents rendered by LaTeX should be readable better than possible with HTML.
15:22:51 <ChilliX> Jonex: It's a journal paper...journals usually don't accept html as they need good print quality.
15:22:59 <Jonex> postman: Not for screen.
15:23:10 <SamB> Jonex: well, I guess you don't want me to tell you that maths are sometimes just Haskell in disguise, then, do you?
15:23:24 <postman> Reading documents created by people who used Word to create them isn't worth the effort most of the time, anyways.
15:23:58 <Jonex> As I said, html is my preffered format.
15:24:16 <lokadin> > span (!= "ku") $ words "le nanmu ku cu klama"
15:24:17 <lambdabot>  Not in scope: `!='
15:24:20 <lokadin> ?
15:24:30 <lokadin> why is != not in scope?
15:24:30 <ChilliX>  /=
15:24:32 <lokadin> o
15:24:32 <Jonex> If I want to print it I open it in Open Office and use a font I like for it. :)
15:25:49 <Jonex> I've managed to fit 8 pages of text into a single doublesided page just by changing fonts, columns and size, still pleasantly readable.(to me)
15:26:15 <edwinb> It's difficult to imagine how a pdf could be hard to read if that's easy to read! ;)
15:27:49 <Jonex> edwardk: That's on print, on screen I wan't san-serif fonts and large size so I can lean back.
15:28:42 <edwinb> I see your point anyway; but you'll rarely find academic papers in html format
15:28:57 <edwinb> I usually prefer to print things out if I'm reading them in any serious way
15:29:57 <SyntaxNinja> hey, Lemmih, dcoutts: Be sure to post details to cabal-devel for any cabal-get stuff you did :)
15:30:16 <Jonex> edwardk: I don't have any printer, otherwise I'd do that.
15:31:43 <gds> It'd definitely be nice to have some kind of system for making accademic papers easier to screen-read...
15:32:04 <gds> Maybe doing some cool search stuff on the way....
15:32:20 <Jonex> Well, they could make an html version avaible and I'd be satisfied.
15:32:31 <postman> I liked shapr's idea of "The Last Margin", IIRC.
15:32:44 <postman> Not completely related, though.
15:32:51 <gds> Jonex: It's very difficult to change the habits of large numbers of people - particularly accademics ;)
15:33:08 <Jonex> If there's an tex. version avaible I guess it's possible to make you own conversion, but that requires latex.
15:33:11 <gds> I reckon we'd have more success writing an app to convert pdf into HTML, hard as that may be.
15:33:11 <postman> It would be nice to have a "comment" system associated with every paper.
15:33:13 <edwinb> html just isn't good enough for a lot of stuff though
15:34:07 <edwinb> although I haven't tried any latex to html converters for a while, maybe they're getting better
15:34:35 <postman> I don't like it when papers say: when condition X occurs, then Y, and then they don't give an example of when X can actually happen. Sometimes it's completely non-trivial to find out.
15:35:03 <Jonex> gds: I'd guess it's quite hard. Pdf doesn't keep a lot of the sematical concepts I bleive.
15:35:27 <mux> XML -- The last frontier
15:35:34 <Jonex> Look att the google conversion for instance. It's ok for a quick preview, but not really usable for more than that.
15:35:36 <postman> mux: hehe
15:36:36 <Jonex> edwinb: Well, theoretically you could use MathML in the HTML source, though that will practicallky require and extra plugin for that.
15:37:14 <postman> Jonex: do you have any idea of how much work went into TeX?
15:37:19 <edwinb> theoretically, but latex is very powerful.
15:37:49 <edwinb> and you'd be giving up an awful lot to use something that's just a markup language
15:38:18 * gds thinks of latex as the least-worst ATM, but would still like something better ;)
15:38:18 <postman> Jonex: it has a gazillion lines of code for layout, while HTML doesn't even have columns.
15:38:34 <dcoutts__> SyntaxNinja: yeah, good point
15:38:41 <Jonex> Well, of course you won't use html as a source format if you need more than that, even though it is quite powerful combined with css.
15:38:47 <edwinb> latex irritates me a lot, quite often. But it's still the best thing out there.
15:39:10 <Jonex> css3 has columns iirc.
15:39:18 <dcoutts__> SyntaxNinja: we hacked on using a tarball index format and how to deal with multiple repos under that scheme
15:39:19 <edwinb> Anyway, if you want academics to change their ways, you'd need publishers to tell them to.
15:39:33 <dcoutts__> SyntaxNinja: I think we had most of the ideas thrashed out
15:39:41 <dcoutts__> xerox: post it to cabal-devel ! :-)
15:40:46 <dcoutts__> I was of the opinion that we might as well use .tar format since we'll need tar reading code for windows anyway
15:40:47 <Jonex> Well, I don't mind them using tex as a source format, and pdf for the printing, but it'd be nice if they'd supply a html-version for the web.
15:41:09 <dcoutts__> and for cabal sdist we need tar writing and indeed gziping
15:41:16 <Philippa> it's only fairly recently that's been plausible for a lot of stuff
15:41:33 <dcoutts__> Igloo said that he's got some pure haskell gunzip code that we could use too
15:41:34 <edwinb> if you could press a button and get an html document that looked a bit like the paper, I'm sure they would...
15:41:58 <Jonex> edwinb: Is the latex html conversion that broken?
15:43:06 <edwinb> Jonex: last time I tried the tools they struggled with some of the mathsy stuff I did.
15:43:37 <Jonex> Hmm, can't it, likw MediaWiki convert maths to PNG:s?
15:43:39 <edwinb> might be worth another go
15:45:26 * edwardk has never been fond of the 'render math to png' solution
15:45:35 <edwardk> then again mathml support sucks ass these days
15:45:45 <edwardk> and mathml is horrific to begin with
15:45:56 <bejs> mathml is yucky
15:46:06 * edwardk tried, really tried to be a mathml fanboy once.
15:46:18 <bejs> It's death by <these>.
15:46:29 <edwardk> wrote a toy computer algebra system that rendered everything using mathml and xul in mozilla
15:46:39 <bejs> Officer, we found thirty pairs of less than symbols embedded in the spine
15:46:42 <edwardk> then i realized that mathml support there is completely fuxx0red on macs.
15:47:11 <edwardk> and it looks terrible on most every other platform, and requires the end user to download fonts, etc.
15:48:00 <edwinb> okay, I just tried latex2html, and it failed entirely
15:48:11 <edwinb> because I'd defined macros it didn't like
15:48:15 <edwardk> I formatted my undergraduate thesis in it, and it didn't even have that much math and even choosing the layout engine, choosing the fonts, with ample time before hand it still looked like crap compared to anything someone spent 2 minutes on in latex.
15:48:19 <edwinb> htlatex also failed
15:48:31 <edwardk> so i gave up and went back to latex.
15:49:04 <edwinb> if someone were to make it as easy to generate html from latex as it is to make ps or pdf, I'm sure more people would do it.
15:49:17 <edwardk> then i proceeded to format 100 pages of very heavy math stuff in about the time it took to generate 10 pages in mathml =/
15:49:28 * edwardk nods.
15:49:59 * sm uses a wiki that renders latex to html
15:50:19 <edwardk> i started writing a formula renderer for svg at one point, once firefox has it stably implemented i might go back and revisit it
15:50:19 <edwinb> epilogue does it, but I'm not sure how
15:50:22 <edwinb> some wordpress magic I think
15:50:31 <edwardk> the file sizes are ridiculous though
15:50:41 <edwardk> without using lots of client side javascript tricks to render it
15:51:36 <madpickle> the problem with html to latex is the absolute nature of styling in a LateX document (things like floats).
15:51:39 <edwardk> sm lots of them do, but they can't let you do things that are more complicated than basic expressions.
15:51:46 <madpickle> makes it tricky to convert that to HTML
15:51:52 <sm> edwardk: like what ?
15:51:52 <edwardk> i was trying to use one of them to format a bunch of Pluckerspace stuff for the web once.
15:52:02 <edwardk> and i need bold greek subscripts
15:52:11 <edwardk> and you can't get them without hopping in and out of math mode
15:52:22 <edwardk> and that chokes up every one of those i've seen
15:52:29 <Jonex> madpickle: If it's tricky to convert, the writer has done a poor job marking up his code properly.
15:52:31 <madpickle> sounds like hell, edwardk.
15:53:01 <sm> http://wiki.axiom-developer.org/LaTeX is all about math mode.. but probably doesn't handle a full LaTeX document, as you say
15:53:06 <lambdabot> Title: MathAction and Axiom LaTeX
15:53:08 <edwardk> yeah
15:53:24 <madpickle> no, if it's tricky to convert then it is because HTML is not a typographical tool
15:53:34 <madpickle> and if you use CSS, you risk breaking compatibility with some browsers
15:53:40 <madpickle> use "too much" CSS, that is.
15:53:54 <madpickle> my experience with latex2html is that of disdain
15:54:04 <edwinb> sure, you can't always get away with "just" markup with latex, you have to be a bit careful to get the layout you want
15:54:24 <Jonex> madpickle: Html is a sematic too, css is the typographic tool.
15:54:32 <edwinb> in theory, changing the document class shouldn't cause a problem. In practice, of course, it usually does...
15:54:36 <edwardk> starting in chapter 7 this becomes unformattable with any latex->html renderer i've seen http://slipwave.com/~harmless/thesis.pdf
15:54:50 <madpickle> Jonex: quite so. yet, try writing a proper converter that works on most modern browsers in a uniform way
15:55:08 <edwardk> mad: you can get there with svg if you try hard enough
15:55:22 <madpickle> that's the thing right there.
15:55:32 <madpickle> latex2html shouldn't be about bodging your latex or your html code to "make it fit"
15:55:41 <madpickle> it should be a (somewhat) smooth transition. unfortunately it is not.
15:55:44 <edwardk> i have a cheesy ttf font converter that combined with some heavy javascript can do the work
15:55:55 <madpickle> and that is why there are very inadequate Latex2HTML renders out there
15:56:01 <edwardk> its one of the reasons why i started writing javascript-in-javascript recompilers, etc
15:56:08 <Jonex> I don't know about latex, but when writing html you mark up the code in such way thet it always gets renderad in a good way, even without any css. Then you add css to make styling, like indented paragraphs and stuff.
15:56:27 <edwardk> jonex: the problem is, the layout for html isn't exact enough for mathematical rendering.
15:56:38 <Jonex> It's not hard to make html and css that works across all browsers.
15:56:44 <madpickle> tell that to LaTeX
15:56:59 <Jonex> edwardk: Yeah, you you'd need to render math formulas into pngs.
15:57:09 <edwardk> latex was explicitly created to work around the crappy photographic reproduction techniques that started to be used at the time
15:57:11 <madpickle> LaTeX is fickle enough as it is, without having to use all kinds of render hacks to make the converter engine treat the LaTeX code in a ccertain way
15:57:20 <madpickle> LaTeX was made to keep hacks from using stuff like HTML
15:57:26 <madpickle> (or the flavor du jour back then)
15:57:36 <Jonex> I'm guessing something i latex is broken if it's so hard converting to html, it shouldn't be a problem in any sufficiently sematically marked up language.
15:57:49 <edwardk> jonex: thats not good enough though. what is an acceptable formula at 300dpi is not an acceptable looking formula at 72, you really need to be able to zoom and pan at times
15:57:51 <madpickle> no more broken than HTML!
15:57:56 <madpickle> TeX is 20+ years old
15:58:00 <edwardk> and pngs lose that
15:58:45 <Jonex> madpickle: html isn't very broken, ie:s viewing of some of the css is a bit broken though.
15:58:54 <edwardk> jonex: latex isn't broken, its just a tool for a different job. its actually amazing at what it does.
15:59:03 <Jonex> edwardk: Could render to flash or svg then.
15:59:09 <madpickle> flash?
15:59:14 <madpickle> that's too artfag for an academic
15:59:18 <edwardk> that is kind of the direction i'm going with it =)
15:59:22 <madpickle> and moreso, prevents search engine spidering
15:59:26 <Jonex> edwardk: A markup language that doesn't do sematic markup seems broken to me.
15:59:45 <Jonex> madpickle: Spidering mathematical formulas?
15:59:49 <edwinb> latex is rather more than a markup language
15:59:53 <madpickle> the page as a whole
15:59:53 * Philippa hands Jonex a macro
16:00:01 <madpickle> isn't LaTeX turing complete?
16:00:04 <edwinb> yes
16:00:05 <Philippa> you can build abstractions in LaTeX, define your own semantics if you want 'em
16:00:07 <madpickle> i belive PostScript is aswell
16:00:08 <edwinb> (I think so).
16:00:09 <edwardk> yeah it is mad
16:00:12 <madpickle> well there you go
16:00:13 <edwardk> mad: both are
16:00:13 <edwinb> it's essentially lisp ;)
16:00:15 <Jonex> Maddas:  Of course you wouldn't do that, that'd be no better than pdf.
16:00:18 <sehute> good night. Happy hasking
16:00:36 <madpickle> HTML can't cope with LaTeX
16:00:42 <edwardk> whats wrong with pdf? its just a crippled postscript without recursion =)
16:00:48 <Jonex> Bad idea to make a markup language turing complete imo. :/
16:00:50 <SamB> postscript, though, doesn't usually support HTML output...
16:00:59 <SamB> Jonex: maybe so
16:01:03 <edwardk> oh, and the ability to reference forward and backwards in the file with a global object lookup table
16:01:04 <edwinb> since when has it been a markup language? you were the one who said it was...
16:01:04 <SyntaxNinja> dcoutts__: coolness
16:01:04 <edwardk> and hashes
16:01:09 <SamB> but apparantly nobody told Knuth...
16:01:21 <madpickle> i think Knuth knew what he was doing
16:01:28 <edwardk> and you can do hyperlinking in latex if you really want to =)
16:01:29 <madpickle> but i dare any one of you to tell him otherwise.
16:01:32 <Jonex> edwardk: People use it as such, they markupo their ducuments using it, poorly as it seems, but still.
16:01:33 <SamB> he knew he was making it turing complete?
16:01:44 <edwardk> samb: sure, it was by design.
16:01:48 <madpickle> SamB: LaTeX gained sentience about 10 years ago :P
16:01:50 <Jonex> Maybe that's what's docbook is a all about?
16:01:51 <edwinb> Knuth, I gather, knew a thing or two about computer science...
16:02:07 <madpickle> if The Man made it Turing Complete for a reason, then by golly that's good enough for me.
16:02:22 <SamB> edwinb: that doesn't necessarily prevent accidental turing-completenes from occuring
16:02:30 <Philippa> is .dvi turing complete?
16:02:34 <edwardk> he said so at some point, remember it was designed to generate postscript and postscript is a real programming language masquerading as a 'markup' =)
16:02:35 <SamB> nope
16:02:39 <stepcut> edwinb: knew ? You think he forget it all ?
16:02:42 * edwardk doesn't know dvi so well
16:02:49 <SamB> edwardk: it doesn't generate postscript
16:03:03 <Philippa> stepcut: I think he's probably forgotten more CS than most people ever know
16:03:12 <stepcut> Philippa: that I believe :)
16:03:27 * edwinb should remember not to make flippant comments like that...
16:03:33 <edwardk> samb: well, it can, and yes, i accept your clarification =)
16:04:36 <edwardk> docbook has its place, but its a far different place than latex occupies
16:04:44 <SamB> anyway, it doesn't take a turing-complete input format to create turing-complete output
16:05:25 <SamB> you could probabyl write a docbook processor in LaTeX
16:05:31 <madpickle> i feel like crunchy nut cereal with whole milk
16:05:33 <edwardk> well, you can slap together S, K, and I in a few few lines of latex.
16:05:35 <madpickle> hrm
16:05:42 <madpickle> how about writing a LaTeX engine in LaTeX
16:05:44 <edwardk> samb: there are already xml tools in it
16:05:50 <madpickle> somebody should get started on that
16:06:11 <edwardk> well, heh, the whole la of latex is written in it =)
16:06:21 <madpickle> I seem to recall Niklaus Wirth writing the first Pascal compiler on a piece of paper, then hand-compiling it
16:06:28 <madpickle> not sure if it's just a myth.
16:07:00 <SamB> madpickle: how big a piece of paper
16:07:01 <SamB> ?
16:07:03 <Jonex> Hmm, don't know if I could make my parent's print 31 pages, too bad the document's not avaible as html.
16:07:10 <madpickle> SamB: probably not too big
16:09:07 * edwardk used to really like Pascal.
16:09:14 <madpickle> delphi ftw :)
16:09:22 <SamB> madpickle: you think someone should write a TeX implementation in LaTeX?
16:09:23 * edwardk can't see himself ever writing in it again though =-)
16:09:27 <erider> good afternoon Philippa
16:09:34 <Jonex> Delphi was nice, too bad it costs money though.
16:09:36 <madpickle> SamB: well, write the LaTeX engine in LaTeX itself
16:09:47 <musasabi> dirty
16:09:47 <madpickle> Jonex: yes, people tend to charge money so they in turn can pay their bills.
16:09:52 <madpickle> it was a bit on the expensive side though
16:09:57 <SamB> the difference between TeX and LaTeX is already written in TeX
16:10:06 <edwardk> yeah
16:10:09 <Jonex> madpickle: Yeah, that's a terrible problem, people should stop doing that.
16:10:20 <edwardk> and TeX itself is pretty straightforward
16:11:04 <Jonex> But really, it's hard to motivate paying a lot of dough for delphi, when you got so many good free alternatives.
16:11:10 * edwardk used turbo pascal for all sorts of stuff back in the day. wrote my bbs in it. 
16:11:12 * edwardk feels old.
16:11:23 <madpickle> beating delphi in terms of raw productivity is bloody hard
16:11:27 <Jonex> oold indeed
16:11:47 <madpickle> if i were to write windows shrinkwrap, i'd use delphi
16:11:51 <SamB> I would have tried to use it if I'd had it
16:11:51 <Jonex> madpickle: Productivity doesn't fill my pockets with money to pay for it though.
16:11:57 <madpickle> no libraries needed - compile once, run everywhere (on windows).
16:11:59 * dcoutts__ graduated from VB to tubo pascal to delphi to Haskell
16:12:10 * madpickle tips his hat to dcoutts_
16:12:24 <madpickle> jonex: quite true
16:12:26 <madpickle> i wish it were cheaper too
16:12:28 <madpickle> borland are idiots
16:12:31 <madpickle> but this, we all know.
16:12:37 <SamB> VB to turbo pascal?
16:12:40 <Jonex> I had a delphi version that came with a magazine, but sadly I lost the key.
16:12:41 <dcoutts__> actually I used BBC Basic prior to VB
16:12:49 <SamB> that is a bit of a strange switch, if you ask me...
16:12:51 * madpickle remembers printing colored text in MS-DOS with Turbo C
16:12:57 * edwardk went from c -> cobol -> fortran -> pascal -> c++ -> perl/java/python/buzzwordoftheday -> javascript -> haskell
16:12:58 <SamB> did they used to have a DOS version?
16:13:02 <dcoutts__> SamB: aye, we used TP at sixth-form
16:13:04 * edwinb has fond memories of BBC BASIC
16:13:05 <madpickle> edwardk: this dates you
16:13:06 <SamB> of VB
16:13:08 <SamB> I mean
16:13:13 <edwardk> heh
16:13:14 <edwardk> oh
16:13:17 <edwardk> and i forgot RPG =)
16:13:21 <edwardk> yeah
16:13:23 <edwardk> like i said
16:13:25 <Jonex> I think delphi was my first real programming languge.
16:13:25 <edwardk> feeling old =)
16:14:07 <dcoutts__> SamB: the A-level computing course used Turbo Pascal because at the time it was the best teaching language
16:14:20 <dcoutts__> indeed it still is in many ways
16:14:30 <madpickle> Turbo Pascal is a well-made language
16:14:37 * edwardk never attended his intro comp sci course coz of turbo pascal.
16:14:39 <dcoutts__> we use Oberon at Oxford, which is not far removed from Pascal
16:14:46 <madpickle> and borland did well using Pascal for Delphi
16:14:48 <Jonex> Ooh, how bad I was back then, didn't really understand that concepts of lists and listboxes, so in some program I tried to use Listboxes as a datatype, by putting them on the form.
16:14:48 <SamB> you do?
16:15:01 <edwardk> the course was taught in it, and i had just finished writing my mod player for the pc speaker in turbo pascal. i showed the prof, he said to show up for the midterm and the final.
16:15:07 <SamB> how do you get past the wierd GUI?
16:15:11 <edwinb> We learned Modula-2 first, but it all went java a few years later.
16:15:12 * edwardk dates himself again.
16:15:36 <madpickle> didn't the guy who wrote bash use the C preprocessor to convert the language to Algol?
16:15:58 <madpickle> imagine the shock and horror when you crack open the code in Emacs
16:16:39 <Cale> Jonex: did you see the recent post on thedailywtf.com?
16:17:12 <SamB> dcoutts__: how do you get past the wierd UI?
16:17:23 <edwardk> heh when i first returned to c from pascal i admit i did much the same thing for c -> pascal to my retrospective horror.
16:17:25 <Jonex> Cale: Haven't visited it yet today.
16:17:25 <dcoutts__> SamB: the wierd UI of what? TP?
16:17:31 <SamB> no no
16:17:32 <SamB> oberon
16:17:40 <dcoutts__> there is no wierd UI
16:17:43 <SamB> oh.
16:17:44 <edwardk> what about oberon?
16:17:47 <dcoutts__> it's just a command line compiler
16:17:54 <SamB> I thought it had an OS too
16:17:57 <edwardk> it does
16:17:58 <dcoutts__> obc -c foo.m -o foo
16:17:58 <Cale> Jonex: it wasn't just today, a little while back, about the very issue you brought up there
16:17:58 <madpickle> Turbo Pascal had a text-based IDE like that of Turbo C
16:18:03 <madpickle> blue background
16:18:05 <madpickle> mmm
16:18:07 <madpickle> blue
16:18:08 <SamB> you can just compile from the command line too?
16:18:09 <edwardk> he wrote a book on oberon-0, etc.
16:18:32 <edwardk> yeah the oberon environment is pretty simple to bootstrap in or on anything
16:18:33 <dcoutts__> SamB: aye, just like with a Pascal, C or Haskell compiler
16:18:48 <edwardk> its a crappy stripped down pascal, but its there =)
16:18:52 <Jonex> Cale: Heh, yeah that was in live code though. :)
16:18:57 <dcoutts__> I know nothing of any oberon "environment"
16:19:15 <Jonex> I can at least blame the fact that I was like, 14 or something at the pint.
16:19:22 <dcoutts__> we use an implementation that compiles to bytecode
16:19:42 <edwardk> dcoutts: what for?
16:20:00 <SamB> dcoutts: oh, well, probably the environment uses that too...
16:20:11 <dcoutts__> edwardk: for teaching imperitive programming (after first teaching functional programming with Haskell)
16:20:24 <edwardk> http://en.wikipedia.org/wiki/Image:OberonScreen.PNG
16:20:47 <dcoutts__> wierdy
16:20:49 <edwardk> dcoutts: i'm trapped at a university that views functional programming as an oddity
16:20:52 <dcoutts__> we use emacs and obc
16:21:05 <dcoutts__> or emacs and hugs/ghc
16:21:10 <madpickle> edwardk: at our uni it's the converse; they research type theory
16:21:13 * edwardk nods.
16:21:26 <edwardk> i need to find a good type theory place to go do my ph.d
16:21:48 <madpickle> edwardk: http://www.swan.ac.uk/compsci/
16:21:50 <lambdabot> Title: Swansea University, Department of Computer Science, UK
16:21:53 <madpickle> might have what you are looking for?
16:22:00 <musasabi> edwardk: same here.
16:22:04 <edwardk> i'll add it to the queue
16:26:52 <edwardk> i am finding myself stuck here teaching classes with the option to collect a 3rd masters degree and no real ph.d prospects in the area and thinking i'd better just get out, get my ph.d and get on with it =)
16:28:13 <edwardk> if i don't get out of here i'll add a grad cert in bioinformatics and a masters in english linguistics to my list and it'll be obvious that i'm fishing for pieces of paper ;)
16:29:36 <Jonex> edwardk: Well, functional programming _is_ an oddity, isn't it?
16:29:50 <edwardk> arguably
16:30:01 <madpickle> edwardk, my dept. may have what you are looking for.
16:30:02 <edwardk> but its more mainstream than the computational geometry stuff i did before
16:30:41 <edwardk> mad: been mining throiugh the research interests there, the extensions to dependent types stuff piqued my curiosity
16:31:03 <madpickle> may want to check out the staff page
16:31:08 <edwardk> trying to see what i can do with substructral pure (or monadic) type systems for my current thesis
16:31:26 <madpickle> Dr. Berger does work on this functional code generator that generates code from proofs
16:31:33 <madpickle> Minlog i think its name is
16:31:35 <hyrax42> hm
16:31:36 <madpickle> @google Minlog
16:31:40 <lambdabot> http://www.mathematik.uni-muenchen.de/~minlog/minlog/
16:31:40 <lambdabot> Title: Minlog System
16:31:41 <hyrax42> sound like it was a pretty boring keynote
16:31:53 <syntaxfree> I remember someone here being profficient with GNU R.
16:32:19 * SamB wonders what that is
16:32:30 <hyrax42> is this time machine thing filesystem-level
16:32:37 <syntaxfree> GNU R is this statistical package/language.
16:32:47 <hyrax42> oh
16:32:48 <swiert> edwardk: you may want to check out Chalmers and Nottingham.
16:32:48 <hyrax42> got
16:32:50 <hyrax42> god
16:32:53 <hyrax42> wrong channel
16:32:54 <edwardk> syntaxfree: what do you need to know?
16:33:07 <edwardk> my math masters was half stats, lived in it for er.. 3 months =)
16:33:12 <madpickle> the people at swan are friendly; if you want to know more just email them and ask
16:33:21 <SamB> hyrax42: I wondered what you were talking about
16:33:22 <swiert> they both have strong fp/type theory departments.
16:33:22 <Pseudonym> "got god" sounds like a failed religious marketing campaign.
16:33:23 <syntaxfree> well, I need help  loading this humongous data set.
16:33:37 <hyrax42> Sam: :o
16:33:38 <syntaxfree> SPSS seems to handle it just fine, but R seems to want to put EVERYTHING on RAM at once.
16:33:44 <edwardk> swiert: chalmers is on my list from simply knowing the names of so many people there
16:34:23 <syntaxfree> It's not even _that_ humongous, it's a 3 million observations, 1.6 gigabyte file.
16:34:41 <edwardk> problem is, being a dumb american i've never heard of half of these places ;)
16:34:58 <edwardk> syntaxfree; yep it'll do that
16:35:29 <syntaxfree> I reckon SPSS just loads from disk as needed.
16:36:05 * edwardk loves how nowadays .a gig and a half isn't a very big file
16:36:09 <syntaxfree> I don't have SPSS  on my home machine, though, and I like that R has higher-order functions (I don't know how the hell anyone gets anything done without'em)
16:36:15 * edwinb wants more type theorists to come to St Andrews!
16:36:36 * edwardk doesn't even know where St. Andrews is =)
16:36:39 <madpickle> you might even meet royalty
16:36:49 <syntaxfree> Can R be persuaded to behave like that?
16:36:49 <edwinb> that seems very unlikely
16:36:57 <edwinb> (to madpickle)
16:36:59 <madpickle> improbably, but not impossible ;P
16:37:03 <edwardk> syntaxfree: :not to my knowledge
16:37:15 <syntaxfree> bah.
16:37:17 <swiert> edwardk: sure. If you want to stay in the US, you may want to consider Carnegie Mellon.
16:37:24 <madpickle> btw
16:37:31 <syntaxfree> Anyway, thanks.
16:37:35 * syntaxfree grumbles.
16:37:35 <madpickle> the swansea website maintains a list of all research institutions in type theory and logic
16:37:39 <madpickle> *somewhere*
16:37:53 <edwardk_> heh
16:37:58 <edwardk_> if you track it down lemme know
16:38:01 <madpickle> effort
16:38:04 <madpickle> on my part
16:38:05 <syntaxfree> madpickle: type logic?
16:38:06 <madpickle> :p
16:38:19 <syntaxfree> (there's this great pop psychology site called typelogic.com)
16:38:23 <edwardk_> i admit i was kinda disappointed when i went to the research interest page and it just had a list of topic teasers and the name of the chief researcher
16:38:24 <madpickle> http://www.swan.ac.uk/compsci/research/theory/
16:38:26 <lambdabot> Title: Research - Logic and Computation
16:39:13 <madpickle> the research topics have their own sites here and there. they restructured their website a while back, and since then nobody has been able to find anything
16:39:24 <madpickle> http://www.cs.swan.ac.uk/~csetzer/logic-server/
16:39:25 <madpickle> there we go
16:39:26 <lambdabot> Title: Research groups in Logic and Theoretical Computer Science
16:43:43 * edwardk_ is keeping an open mind but may just wind up going someplace here in the states
16:44:06 <mcnster> hello.  any gtk2hs guru's awake?
16:44:14 <dcoutts__> @yarr!
16:44:15 <edwardk_> just somewhat of a shortage of type theory places over here comparatively
16:44:30 <madpickle> it's a german thing
16:44:31 <lambdabot> Aye Aye Cap'n
16:44:45 <dcoutts__> mcnster: you can take that as a yes
16:44:56 <mcnster> dcoutts, heh.  cool
16:44:59 <vincenz> @join #oasis
16:45:22 <vincenz> @tell dons autojoin #oasis for lambdabot ?
16:45:22 <lambdabot> Consider it noted.
16:45:44 <mcnster> my q is this:  what strategy should i consider for running a gtk2hs app that needs to respond to async signals coming in from a port?
16:46:02 <mcnster> running = coding
16:46:47 <dcoutts__> mcnster: Haskell threads (or something else low level and ugly if you don't like our threading solution)
16:46:59 <dcoutts__> mcnster: see the FAQ about Gtk2Hs and threading
16:47:11 <mcnster> dcoutts, excellent thanks
16:47:16 <dcoutts__> I've seen IRC clients written with Gtk2Hs using both methods
16:47:46 <syntaxfree> @tell syntaxfree that this command really works?
16:47:46 <lambdabot> You can tell yourself!
16:48:29 <mcnster> dcoutts, i figured i was going to use threads, which is great, but i wondered how it fit into gtk_main?
16:48:44 <dcoutts__> mcnster: yeah, see the FAQ it explains
16:49:03 <dcoutts__> and there's a concurrency demo you can look at
16:50:01 <mcnster> dcoutts, the faq == the info on the gtk2hs re threading, or elsewhere?
16:50:18 <mcnster> gtk2hs site
16:50:19 <dcoutts__> on the Gtk2Hs website
16:50:24 <dcoutts__> @where gtk2hs
16:50:25 <lambdabot> http://haskell.org/gtk2hs/
16:50:32 <mcnster> dcoutts, cool
16:50:53 <dcoutts__> http://haskell.org/gtk2hs/archives/2005/07/24/writing-multi-threaded-guis/
16:50:54 <lambdabot> Title: Gtk2Hs » Blog Archive » Writing multi-threaded GUIs
16:51:12 <mcnster> got it
16:59:28 <petekaz> what is the state of unicode in haskell?
16:59:43 <petekaz> can I read and write files of various encodings?
17:00:16 <petekaz> does the Char type match up to all the unicode chars?
17:00:21 <dcoutts__> yes
17:00:41 <dcoutts__> petekaz: if you find/write the encoders/decoders then it's easy
17:00:59 <petekaz> (just read a blurb on common lisp support of unicode and wondered about haskell).
17:01:03 <dcoutts__> fmap decodeUTF8 (readFile "foo")
17:01:30 <dcoutts__> so you need to explicitly use an encoding/decoding function
17:01:48 <petekaz> ahh ..
17:02:00 <petekaz> is that generally seen as a positive?
17:02:12 <petekaz> I think I like the common lisp way better.
17:02:38 <dcoutts__> how does it guess the encoding?
17:03:00 <petekaz> you specify when opening a file.
17:03:20 <dcoutts__> so do I by applying a function :-)
17:03:28 <Lemmih> Doesn't Bulat's streams do something like that?
17:03:32 <dcoutts__> yeah
17:03:42 <dcoutts__> I'm not convinced it's necessary
17:03:54 <hyrax42> why fmap an dnot just map
17:03:59 <hyrax42> oh it's IO Strin
17:03:59 <hyrax42> g
17:04:02 <hyrax42> ?
17:04:04 <dcoutts__> yep :-)
17:04:12 * dcoutts__ suggests decodeUTF8 :: ByteString -> PackedString
17:04:19 <petekaz> ok, cool.  I guess as long as long as they get mapped to single Chars thats all I care about.
17:04:28 <dcoutts__> right
17:04:39 <hyrax42> what is this packed string
17:05:04 <dcoutts__> It's a string type based on a packed array representation
17:05:19 <dcoutts__> though the current impl of PackedString is very slow
17:05:22 <hyrax42> also dcoutts__ when is bytestring being added to ghc standard libs
17:05:29 <dcoutts__> it's in now
17:05:37 <hyrax42> 6.4 or 6.5
17:05:41 <dcoutts__> there will be a new PackedString based on ByteString
17:05:51 <dcoutts__> it's in 6.5 now
17:05:54 <hyrax42> hm
17:06:01 <hyrax42> packedstring is higher level than bytestring
17:06:02 <hyrax42> ?
17:06:16 <hyrax42> why "based on"
17:06:20 <dcoutts__> no, it's just unicode string rather than strings of bytes
17:06:27 <hyrax42> oh
17:06:33 <dcoutts__> they're different data types
17:06:42 <hyrax42> cool
17:06:53 <dcoutts__> based on in the sense of techniques etc
17:07:00 <hyrax42> that bytestring is really cool
17:07:06 <dcoutts__> I know :-)
17:07:11 <hyrax42> I flicked through the slides on loop fusion
17:07:20 <dcoutts__> and it keeps getting faster
17:07:21 <hyrax42> very nify
17:07:34 <dcoutts__> current benchmarks are about 10x faster than in those slides
17:07:49 <hyrax42> so someone should go and rewrite some of the shootout benchmarks in bytestring[.lazy]
17:07:54 <dcoutts__> indeed
17:08:00 * hyrax42 will try
17:08:01 <dcoutts__> for 6.6 I think that will happen
17:08:08 <hyrax42> oh hm
17:08:44 <dcoutts__> presumably the shootout only accepts released versions of compilers
17:08:57 <hyrax42> I guess so
17:09:02 <dcoutts__> so we wait 'til 6.6
17:09:07 <hyrax42> 6.5 still only in darcs?
17:09:16 <hyrax42> or is it even/odd like kernel
17:09:17 <dcoutts__> yes, or snapshot tarballs
17:09:31 <hyrax42> linux kernel, that is
17:09:35 <dcoutts__> yes 6.5 is the dev version leading up to stable 6.6
17:09:42 <hyrax42> kk
17:13:13 <joelr1> howdy folks
17:13:45 <joelr1> does anyone know of haskell bindings for spread (www.spread.org)
17:15:47 <edwardk_> none i know of
17:17:36 <joelr1> ok
17:18:28 * edwardk_ sighs and kicks the broken ecmascript 4 spec.
17:51:47 <musasabi> edwardk: same here.
17:56:57 <edwardk_> musasabi: looked at it?
17:57:20 <edwardk_> its so close to being a good language
17:59:41 <woggle>  2
17:59:48 <woggle> Er, oops.
18:01:28 <hyrax42> 3, I'd say
18:08:17 <emertens> anyone seen this? http://scienceblogs.com/goodmath/2006/08/_my_favorite_strange_number_1.php
18:10:24 * heatsink has heard of it
18:11:28 <heatsink> I didn't know about the uncompressible property
18:26:44 <Korollary> emertens: I read his blog daily.
18:28:23 <Marc1> hola!
18:33:16 <Marc1> chau!!??
18:33:28 <Korollary> hi
18:34:19 <Marc1> speak español??
18:35:00 <Korollary> no
18:35:04 <heatsink> un poco
18:36:02 <Marc1> what is "haskell"? i am of Argentina ...Conoces??
18:36:53 <mlh> Marc1: http://haskell.org/
18:36:55 <lambdabot> Title: Haskell - HaskellWiki
18:37:53 <Marc1> Gracias! i see my conexion . I have some  problem!
18:38:22 <Marc1> you are of ...?
18:41:51 <Marc1> well . good bye . thank!
18:43:28 <Cale> \x -> well (good bye (thank x))
18:52:13 <syntaxfree> @pl \x -> well (good bye (thank x))
18:52:29 <lambdabot> well . good bye . thank
18:52:44 <hyrax42> ha
18:53:30 <syntaxfree> @pl \x -> well (good bye (thank! x))
18:53:30 <lambdabot> well . good bye . (thank !)
18:53:39 <syntaxfree> hmm. not good enough.
18:53:57 <syntaxfree> @pl \x-> hmm (not good enough)
18:53:58 <lambdabot> const (hmm (not good enough))
18:55:06 <syntaxfree> @pl \x-> hmm (not good enough x)
18:55:14 <lambdabot> hmm . not good enough
18:55:23 <syntaxfree> How do we add the trailing dot?
18:55:59 <heatsink> That would also put parentheses around it
18:56:15 <heatsink> @pl (x .)
18:56:15 <lambdabot> (x .)
18:56:16 <Cale> \x f y -> well (good bye (thank x)) (f y)
18:56:21 <Cale> @pl \x f y -> well (good bye (thank x)) (f y)
18:56:21 <lambdabot> (.) . well . good bye . thank
18:56:25 <Cale> hmm, no
18:56:43 <syntaxfree> we should make a simple reverse-pl./
18:57:28 <Cale> (x .) = \y -> x . y = \y k -> x (y k)
18:57:38 <Cale> @pl \f y x -> well (good bye (thank x)) (f y)
18:57:38 <lambdabot> (flip (well . good bye . thank) .)
18:57:46 <syntaxfree> @pl \y -> x . y = \y k -> x (y k)
18:57:46 <lambdabot> (line 1, column 13):
18:58:01 <Cale> @pl \f x y -> well (good bye (thank x)) (f y)
18:58:01 <lambdabot> unexpected "="
18:58:01 <lambdabot> expecting variable, "(", ".", "`", "!!", operator or end of input
18:58:02 <lambdabot> flip ((.) . well . good bye . thank)
18:59:58 <dons> good morning
19:00:04 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
19:00:10 <dons> crikey!
19:00:49 <syntaxfree> @tell syntaxfree he's great!
19:00:50 <lambdabot> You can tell yourself!
19:03:02 <heatsink> @pl (\y -> you y off)
19:03:05 <lambdabot> flip you off
19:03:42 <dons> heh
19:05:42 <Pseudonym> @pl \y -> ernation
19:05:42 <lambdabot> const ernation
19:05:47 * Pseudonym hmms
19:05:51 <heatsink> pahaha
19:06:05 <Pseudonym> @pl \y -> ipation
19:06:05 <lambdabot> const ipation
19:06:33 <Cale> http://www.youtube.com/watch?v=x0p3qdFnf4Q&NR -- ahaha
19:06:36 <lambdabot> Title: YouTube - The Devil vs. Balrog
19:09:48 <RyanT5000> are there lazy implementations of Set and Map?
19:10:09 <Cale> lazy in what sense?
19:10:19 <Cale> I think Set and Map are as lazy as possible
19:10:27 <dons> yep
19:10:36 <RyanT5000> hm
19:11:01 <Pseudonym> @pl \f x -> join (fmap f x)
19:11:04 <RyanT5000> i understand why the keys need to be strict, but why do the branches?
19:11:20 <RyanT5000> er, wait
19:11:27 <RyanT5000> nevermind, i don't understand anything
19:11:27 <RyanT5000> lol
19:11:28 <Pseudonym> Errr...
19:11:36 <lambdabot> (=<<)
19:11:39 <Pseudonym> Ah.
19:11:41 <Pseudonym> There we go.
19:19:06 <dons> ?bot
19:19:07 <lambdabot> :)
19:20:16 <syntaxfree> http://it.slashdot.org/article.pl?sid=06/08/07/2126253
19:20:17 <lambdabot> Title: Slashdot | Xcode Update Gives Objective-C Garbage Collection
19:20:28 <syntaxfree> so, I know Lisps have garbage collection.
19:20:42 <syntaxfree> Is that relevant to Haskell? GHC's memory management is a form of GC?
19:21:13 <dons> definitely.
19:22:06 <syntaxfree> I don't understand manual memory management at all.
19:23:00 <kpreid> @help remember
19:23:06 <lambdabot> quote <nick>
19:23:07 <lambdabot> remember <nick> <quote>
19:23:07 <lambdabot> Quote somebody, a random person, or save a memorable quote
19:23:17 <syntaxfree> I already have a quote.
19:23:22 <syntaxfree> @quote syntaxfree
19:23:22 <kpreid> @remember heatsink @pl (\y -> you y off)
19:23:38 <lambdabot>  Many people think the core ideas behind Haskell came from academic luminaries such as Philip Wadler and Simon Peyton-Jones. What actually happened is that during a functional programming conference,
19:23:38 <lambdabot>  some key academics were teleported to the Deep Complex Universe. In the Deep Complex Universe some Gnomes were having Tangling problems. Wadler & friends solved their problems and as a reward the
19:23:38 <lambdabot> Tangled Gnomes gave them the S
19:23:38 <lambdabot> Done.
19:24:09 <RyanT5000> syntaxfree: what do you mean you don't understand manual memory management?
19:25:04 <syntaxfree> I don't understand what *is* manual memory management. I've always done automatically managed stuff in dynamic languges.
19:25:12 <RyanT5000> ah, ok
19:25:29 <RyanT5000> it's pretty simple (to describe - extremely hard to use properly in a large app)
19:25:41 <RyanT5000> basically you allocate something, and then later you free it
19:26:07 <syntaxfree> malloc and free. Well, yes, I know that.
19:26:08 <RyanT5000> do you know IORefs in haskell?
19:26:24 <syntaxfree> But you have to allocate memory when you define a variable?
19:26:29 <syntaxfree> no, I don't.
19:26:46 <RyanT5000> ok well, in C++, for example, there are 3 kinds of allocation (simply speaking)
19:26:53 <RyanT5000> the first is global variables
19:27:07 <RyanT5000> which are assigned an address by the linker
19:27:26 <RyanT5000> the second is stack variables; you define them in a function, and they are reserved on the stack when they come into scope
19:27:47 <RyanT5000> those aren't really considered "manual memory management"
19:28:28 <RyanT5000> the third kind if heap variables, which are defined with malloc and free - you can't refer to them directly, you have to have a pointer to them in a global or stack variable
19:29:06 <RyanT5000> so in a function, you'd declare something like
19:29:14 <RyanT5000> int *x; (a pointer to an integer)
19:29:21 <syntaxfree> so that's why I can do for (i=0; i<=10, i++) { printf "Hello world";}  without worrying about memory management?
19:29:28 <RyanT5000> right
19:29:33 <RyanT5000> i is on the stack
19:29:33 <syntaxfree> because they're stack variables.
19:29:35 <RyanT5000> right
19:29:39 <syntaxfree> There's a limit on stack variables?
19:29:55 <RyanT5000> yeah, there's usually an upper limit on the size of the stack
19:30:13 <RyanT5000> but unless you have a very deeply recursive function or are allocating giant arrays on the stack, you probably won't run into it
19:30:26 <RyanT5000> (by "very deeply recursive" i usually mean that you forgot a base case)
19:30:32 <syntaxfree> People do recursive functions in C?
19:30:35 <RyanT5000> yeah
19:30:43 <syntaxfree> Yes, I've ran out of stack space  forgetting base cases in Scheme.
19:30:54 <RyanT5000> but there's no tail-recursion optimization in C, or at least no guarantee of it in the language spec
19:31:15 <syntaxfree> I see. Is recursion still used in practice?
19:31:20 <Pseudonym> Yes and no.
19:31:24 <RyanT5000> yeah, but usually only on recursive datastructures
19:31:30 <syntaxfree> Oh, ok.
19:31:37 <Pseudonym> It's usually reserved for some specific algorithm.
19:31:42 <RyanT5000> right
19:31:47 <RyanT5000> like tree traversals
19:31:50 <syntaxfree> But if stack spaces are large enough never to run into, why bother with heap variables at all?
19:31:54 <Pseudonym> Yeah, or diff.
19:32:12 <Pseudonym> In multi-threaded programming, C stacks can be quite small.
19:32:14 <RyanT5000> syntaxfree: several reasons
19:32:23 <Starglider> Objects on the heap are persistent.
19:32:30 <syntaxfree> persistent meaning?
19:32:37 <Pseudonym> Actually, Appel commented that if it weren't for continuations, ML memory could be entirely managed on the stack.
19:32:43 <Pseudonym> Sorry, for closures.
19:32:44 <RyanT5000> meaning you can pass a pointer to them around
19:32:54 <Pseudonym> If it were just for data, you could allocate entirely on the stack.
19:33:05 <syntaxfree> closures are like currying, right?
19:33:11 <Pseudonym> The heap decouples the organisation of code from the organisation of data.
19:33:20 <syntaxfree> you can pass a pointer to them between where and where?
19:33:25 <Pseudonym> You don't have to structure your code around object lifetimes.
19:33:54 <Pseudonym> Yeah, closures are partially-applied functions, conceptually.
19:35:02 <RyanT5000> syntaxfree: pretty much anywhere - between processes in certain cases
19:35:15 <RyanT5000> the point is you don't have to keep copying the whole datastructure
19:35:22 <syntaxfree> oh!
19:35:26 <syntaxfree> I get it!
19:35:39 <syntaxfree> You just store it into memory and address it.
19:35:42 <RyanT5000> right
19:35:47 <syntaxfree> Instead of, say, keeping many copies.
19:35:51 <RyanT5000> yep
19:36:05 <syntaxfree> Somehow, lazy evaluation seems ot make that less relevant.
19:36:05 <RyanT5000> because in C++, whenever something is copied, it is really copied
19:36:11 <RyanT5000> lol yes, yes it does
19:36:38 <syntaxfree> Lazy evaluation still feels like some sort of miracle to me.
19:36:50 <Starglider> Lazy evaluation is rather more difficult when structs/objects (and in theory, code) can be modified.
19:36:50 <syntaxfree> I can't relate it to the way I've seen programming work since I was 8.
19:36:54 <RyanT5000> in C++, if you return a 1 MB datastructure (iff your compiler even supports that), it will really copy 1 MB of data
19:37:09 <syntaxfree> (Mostly 8-bit computer basics, VB and modern scripting languages  la Python/Perl/etc.)
19:38:04 <syntaxfree> okay. Now I think I don't understand what structs are.
19:38:16 <dons> syntaxfree: well, it comes from a simple question: what if we didn't evaluate all our arguments, before we apply them? what would that look like?
19:38:37 <syntaxfree> If you're tired of this C programming 101 session, just stop. It's just something I've been wishing I knew for a while.
19:38:54 <RyanT5000> you should just try writing some C; i'm sure there are a billion C tutorials on the web
19:39:22 <syntaxfree> Well,  I know some of the C syntax, and can "translate" Python or Basic code to C.
19:39:36 <syntaxfree> the C tutorials I've seen stop there, too.
19:39:48 <syntaxfree> is all this memory allocation and structs stuff relevant to Pascal?
19:39:52 <RyanT5000> hm, look around at some freshman-level CS courses
19:39:56 <syntaxfree> Apparently a lot of serious stuff used to be done in Pascal.
19:39:58 <RyanT5000> add "site:edu" to your google search
19:40:32 <Starglider> Structures are essentially objects with no functions.
19:41:11 <RyanT5000> although the "accessor functions" are language syntax
19:42:51 <syntaxfree> There's actually a LOT of stuff about mainstream programming concepts I don't quite understand.
19:42:54 <Starglider> Most languages implement 'objects' simply a means of associating a set of functions with a particular type of data structure, plus sometimes some access control that allows you to enforce basic constraints on the data's state.
19:43:03 <syntaxfree> I don't understand OOP either, beyond some stuff in VB.
19:43:09 <Pseudonym> I think the one model of lazy evaluation that most people understand is the idea of a stream.
19:43:13 <Pseudonym> Such as a Unix pipe.
19:43:21 <syntaxfree> Functional programming and lazy evaluation makeme feel comfortable.
19:43:33 <Pseudonym> C++ programmers also understand iterators, which can model lazy evaluation.
19:43:40 <syntaxfree> I'm even comfortable trying to read academic-type stuff, even though I can't parse most of it.
19:43:56 <Pseudonym> Yeah, I have to agree with the comfort thing.
19:44:04 <Pseudonym> I often use GHCi like a calculator.
19:44:16 <Pseudonym> I code up the primitive operations in a script, then play on the command line.
19:44:31 <Pseudonym> And I put pieces together, knowing that lazy evaluation will take care of the tricky bits,.
19:44:51 <syntaxfree> I don't know the first thing about the tricky  bits, I think.
19:45:16 <johnnowak> Pseudonym: will it?
19:45:18 <syntaxfree> Higher-order functions, recursion and lazy evaluation enabled me to do stuff I couldn't do with the sparse programming knowledge I had.
19:45:30 <Starglider> A full lazy evaluation implementation of C/C++ is possible in principle, but the compiler would need a complete causal model of program execution, which is really hard to do without combinatorial explosion.
19:45:32 <syntaxfree> I actually can't figure out how anyone gets anything done without higher-order functions.
19:46:04 <Starglider> Everyone else uses state :)
19:46:06 <heatsink> syntaxfree: Mostly, by replicating code and then inlining the higher-order stuff.
19:46:20 <syntaxfree> inlining?
19:46:53 <Pseudonym> johnnowak: In the usual composing-stuff-at-random-on-the-command-line case, it will.
19:47:22 <johnnowak> Pseudonym: well i've never had a problem without it :)
19:47:25 <syntaxfree> I found myself having to do a lot of copy-and-paste programming in PHP before discovering it could do some basic passing-functions-as-arguments stuff, even though it can't return functions from functions.
19:47:45 <Pseudonym> The other way that people get by is spending the time to write a hard-to-maintain reusable thing which turns the abstraction inside-out.
19:47:56 <heatsink> Where you had a call to "map", you write code that's equivalent to map.  Now you don't need to use higher-order functions.
19:48:43 <Pseudonym> In Haskell, you'd implement map.  In C++, you'd give your container an iterator.
19:49:08 <Pseudonym> Which, if you know anything about C++ iterator semantics, you'd realise is an error-prone and arguably heroic exercise.
19:49:19 <Cale> But you still have to use your iterator correctly, yeah
19:49:28 <syntaxfree> I wonder if I'm missing too much out on my CS self-education by skipping C/C++ and OOP altogether.
19:49:30 <johnnowak> heatsink: That's not necessarily true. I wouldn't say that C has first class functions, but I don't need to re-implement quicksort each time I use it.
19:49:32 <syntaxfree> What is an iterator?
19:49:52 <Pseudonym> syntaxfree: for (i = container.begin(); i != conainter.end(); ++i) { ... }
19:50:01 <Pseudonym> That might loop over all elements in a container.
19:50:04 <Pseudonym> i is called an "iterator".
19:50:10 <syntaxfree> oh.
19:50:12 <Pseudonym> Implementing i is the tricky bit.
19:50:13 <Starglider> It is strange to see someone who understands functional programming mystified by imperative programming. The reverse is much more common.
19:50:26 <johnnowak> Starglider: indeed
19:50:34 <Cale> It's essentially an object which indexes an element of the datastructure, and knows how to increment itself
19:50:57 <Pseudonym> That's like saying that a functor is essentially a polymorphic container.
19:51:02 <Cale> putting a total order on the elements in the structure
19:51:18 <Pseudonym> It's both true and not true at the same time.
19:52:03 <Cale> What else is it?
19:52:26 <Cale> You have element access and element traversal. That's all I'd ever think of it as.
19:52:30 <johnnowak> syntaxfree: if you're skipping C and OOP altogether, yes, you're missing something :)
19:52:39 <Pseudonym> Iterators don't need to be attached to containers.
19:52:43 <syntaxfree> let me show you an example.
19:52:43 <Pseudonym> An integer is an iterator.
19:53:06 <RyanT5000> Cale: functors don't need to be ordered
19:53:16 <Cale> RyanT5000: that's true
19:53:25 <Cale> RyanT5000: I'm describing an iterator.
19:53:34 <Cale> In the C++ sense.
19:53:48 <Pseudonym> A functor is a type which has certain operations which support certain laws.
19:53:51 <Cale> (or slightly more general than that)
19:53:52 <Pseudonym> An iterator is something similar.
19:54:06 <lisppaste2> syntaxfree pasted "how would I get this done without higher-order functions?" at http://paste.lisp.org/display/23813
19:54:14 <syntaxfree> that's not Haskell, but the syntax is obvious enough.
19:54:40 <RyanT5000> ah ok, i misread your statement above as implying that as a simmilarity (i was only pointing it out because i think it's a critical property)
19:55:16 <syntaxfree> basically, I need functions that return functions. I can't think of another way to calculate cumulants.
19:55:52 <Cale> syntaxfree: you compute the specific values you need?
19:56:17 <Cale> You'd just uncurry
19:56:32 <syntaxfree> well, an nth-order cumulant is the nth-derivative of a cumulant generating function.
19:56:36 <Cale> and if that's not good enough, you might make a table of some sort
19:56:43 <syntaxfree> the cumulant generating function is a function generated by your vector.
19:57:04 <heatsink> syntaxfree, I've got a problem with knowing too much about haskell now.  I started with C, learned python and haskell, learned how execution actually happens for python and haskell.  Now I write very difficult-to-read code in C because I'm doing what I would do in python and haskell, but without the language support.
19:57:10 <Cale> I'm not saying it wouldn't be a pain :)
19:57:30 <RyanT5000> does constructing a Set from an ordered list get optimized away?
19:57:40 <Cale> heatsink: heh
19:57:49 <Cale> RyanT5000: use fromAscList
19:57:51 <heatsink> RyanT5000, there's a function to do that that's O(n) instead of O(log N)
19:58:03 <RyanT5000> heatsink: hm, alright
19:58:10 <heatsink> what Cale said.
19:58:11 <RyanT5000> yeah i guess you couldn't do it faster than that
19:58:18 <RyanT5000> yeah i knew of that function
19:59:44 <Starglider> Heatsink: at least you're not doing it with self-modifying assembly code.
20:00:19 <heatsink> Yes, I'm grateful for that.
20:00:21 <Starglider> But yes it's often worth learning new languages even if you're not going to use them just for the concepts.
20:02:59 <Cale> I haven't really tried writing anything significant in C since I learned Haskell.
20:03:33 <Pseudonym> Yeah, but that's just C.
20:03:34 <heatsink> I'll bet you're glad you don't have to.
20:03:48 <Pseudonym> People say the same about not going back to C after learning C++, too.
20:04:14 <Cale> I'm just wondering what a program might look like if I wrote one in C now :)
20:04:20 * Starglider is learning Haskell because some of the concepts look useful for a pseudolanguage he's developing for an AI project.
20:04:29 <heatsink> heh
20:04:42 <heatsink> Cale: It'd be gibbardish, of course.
20:04:42 <Starglider> And I'd like to understand a decent existing implementation.
20:04:50 <Cale> heatsink: heh
20:05:18 <Pseudonym> Right.
20:05:18 * heatsink goes to bed
20:05:27 <Cale> I'd probably end up spending half my time defining datastructures involving unions of function pointers with values.
20:06:06 <RyanT5000> lol
20:06:27 <Starglider> Ah, function pointers, for when gotos just don't have enough obfuscation potential.
20:06:51 <RyanT5000> one word: longjmp
20:07:08 <Cale> Lazy algorithms in C :)
20:09:16 <mwolak> are there any darcs-friendly free open-source hosting sites?
20:18:07 <LordBrain> is it possible to have IO [Int] where [Int] is lazy? or does the IO on the outside sort of imply its sequenced?
20:18:19 <Cale> LordBrain: yes
20:18:34 <Cale> LordBrain: even in nontrivial ways
20:18:34 <LordBrain> yes to which?
20:18:36 <dons> it can be a lazy list if its based over something using unsafeInterleaveIO
20:18:39 <Cale> It's possible
20:18:47 <Cale> return [1..]
20:18:54 <LordBrain> ok
20:18:56 <Cale> there's the trivial sense in which it's possible
20:19:05 <LordBrain> ok cool
20:19:14 <Cale> fmap (read . lines) getContents
20:19:20 <Cale> there's a less trivial sense
20:19:31 <Cale> er
20:19:35 <Cale> fmap (map read . lines) getContents
20:20:00 <Cale> @type fmap (map read . lines) getContents
20:20:02 <lambdabot> forall a. (Read a) => IO [a]
20:20:11 <Cale> good :)
20:20:40 <Cale> that'll be a lazy list, with IO occurring as elements are demanded, because of the evil way in which getContents works
20:20:54 <dons> evil is as evil does
20:21:03 <dons> or something like that.
20:21:22 <Cale> But don't mix up devils with balrogs.
20:21:38 <dons> that's important, yes.
20:21:54 <kpreid> getContents's result cannot actually be demonstrably impure unless your program affects its own stdin
20:22:01 <Cale> (in case you missed it before: http://www.youtube.com/watch?v=x0p3qdFnf4Q&NR)
20:22:03 <lambdabot> Title: YouTube - The Devil vs. Balrog
20:30:02 <dons> wow, this whole gpl/bsd thing is about the closest to a flame war i've seen on haskell-cafe@
20:30:46 <RyanT5000> if you have a type that implements classes A and B, and you have (class (A c, B c) => C c where ;)
20:30:58 <RyanT5000> e.g.: there are no functions in the resultant class
20:31:10 <RyanT5000> does it automatically implement C?
20:31:20 <Azimech> In Chapter 3 of Craft of Functional Programming, the 'ord' and 'toUpper' functions are mentioned, but they're not defined in the prelude (using hugs).  Is there a module I need to import?
20:31:31 <dons> Azimech: they're in Data.Char
20:31:32 <RyanT5000> or, alternatively, is there another way to make class synonyms?
20:31:34 <dons> or just Char
20:31:39 <dons> ?hoogle toUpper
20:31:40 <lambdabot> Char.toUpper :: Char -> Char
20:32:10 <dons> RyanT5000: hmm. there's some technique that Oleg has
20:32:19 <dons> you'll have to trawl his website for the synonym details
20:32:25 <dons> but its something like the above ,yes
20:33:21 <Cale> It doesn't automatically construct that instance normally at least
20:33:32 <RyanT5000> Cale: alright
20:35:10 <dons> hmm "Haskell does project a cutting edge image". maybe that's our brand!
20:35:26 <Cale> who said that?
20:35:31 <Azimech> dons: Thanks.
20:35:33 <dons> be on the cutting edge of programming language development -- use Haskell
20:35:45 <dons> Cale: haskell-cafe@, Hans van Thiel
20:36:04 <dons> bored of your language? Try something new: Haskell!
20:36:08 <Cale> hehe
20:36:14 <Cale> It's true though :)
20:36:15 <dons> Haskell, its new , its fun, it'll scare you
20:37:42 <kpreid> can't you say 'instance (A c, B c) => C c' under allow-undecidable-instances?
20:38:15 <RyanT5000> ah, good point
20:39:09 <dons> now we just need some nice shiny ipod-ish hardware
20:39:20 <dons> and firmly cement our language as the outsider
20:39:27 <dons> while making millions
20:40:16 <dons> oh, nice paper name "Adventures in Time and Space"
20:40:19 <dons> wish I'd thought of that.
20:40:35 <dons> almost could be the name of the bytestring paper
20:41:33 <dons> ?users
20:41:37 <lambdabot> Maximum users seen in #haskell: 221, currently: 194
20:43:25 <Korollary> dons: what are you talking about?
20:46:15 <monochrom> Like this? http://www.amazon.com/gp/product/0517491060/002-0218727-0681605?v=glance&n=283155
20:46:29 <dons> Korollary: hmm?
20:46:51 <monochrom> Or this? http://www-lipn.univ-paris13.fr/~baillot/GEOCAL06/SLIDES/Royer.pdf
20:48:12 <dons> ah no. its a new paper
20:48:20 <dons> on the types mailing list
20:48:28 <dons> ?google types mailing list
20:48:31 <lambdabot> http://www.cis.upenn.edu/~bcpierce/types/
20:48:31 <lambdabot> Title: The Types Forum
20:48:42 <dons> Cale, subscribed ^^
20:48:45 <dons> ?
20:49:04 <Cale> dons: to that list? nope
20:49:11 <dons> ah yes. monochrom tha last link is the right one.
20:50:11 <Cale> I haven't been keeping up with any of the lists I'm already subscribed to. My inbox has about 450 messages in it now.
20:50:14 <dons> Cale, its fun. you get to see all-star tag team battles, by type theorists
20:50:35 <dons> Pfenning versus Moggi, death match.
20:50:40 <dons> actually, not sure of Moggi is on the list
20:51:32 <Korollary> recent thread?
20:51:56 <dons> no, just a joke. you do see the big guys debate some things though.
20:52:00 <dons> pretty low volume
20:52:32 * Cale pictures type theorists having q3a deathmatches :)
20:52:40 <Cale> heh
20:53:20 <Korollary> I've read about 20% of its archives
20:53:36 <Korollary> a lot of it was way over my head
20:53:40 <Korollary> as expected
20:53:44 <Pete_I> archives of what?
20:53:58 <Korollary> the types forum
20:55:00 <Korollary> lightweight languages is also a good one. Guy Steele used to post often. It's dead nowadays.
21:00:59 <syntaxfree> is the Silmarillion part of the canon?
21:02:04 <Cale> syntaxfree: yeah, what he said there isn't quite right
21:02:18 <syntaxfree> he ?
21:02:41 <Cale> oh, I thought you were referring to the Colbert link I posted
21:03:13 <Cale> but yeah, I think the Silmarillion is generally accepted as part of that story
21:03:15 <syntaxfree> oh well, I was.
21:04:40 <syntaxfree> 1970s LotR culture is frequently very inexact, anyway.
21:06:48 <syntaxfree> Peter Jackson is such a geek :)
21:06:52 <Cale> There's conflicting information about various things in the books anyway
21:07:27 <syntaxfree> I'm not a deep tolkienologist.
21:07:37 <syntaxfree> I am, though, a unclescroogeologist.
21:09:02 <syntaxfree> I mostly support Keno Don Rosa's biografy of Uncle Scrooge, though I dispute certain statements about the early headquarters. It's unnecessary and doesn't help resolving conflicts to ignore the entire 1970s-era spherical headquarters buildings.
21:09:24 <Azimech> Another problem with CFP:  fromInt is not in the prelude either.  Is there an easy way to search on a function name and find what module it's in?
21:09:35 <Cale> http://flyingmoose.org/tolksarc/movie.htm
21:09:37 <lambdabot> Title: The Lord Of The Rings Movie - Available Now!
21:09:37 <syntaxfree> There's also some conflicts with an earlier unification attempt, "History and glory of the Duck Dinasty".
21:09:51 <Cale> Azimech: that function doesn't exist anymore
21:09:55 <Cale> Azimech: use fromIntegral
21:10:08 <syntaxfree> I really don't mind having someone making decisions as to how to resolve inconsistencies, but when unnecessary, non-Carl Barks documents should still be preserved.
21:11:13 <Azimech> Cale:  thank you.
21:12:46 * syntaxfree sometimes gets the feeling he's the only Uncle Scrooge geek in existence.
21:14:32 <Cale> 12. And if, as is likely, a bacterium had landed on the inner surface of the Ring, would the Ring corrupt it into an evil bacterium? Would it be invisible to other bacteria? Would its' life stretch out and become an unending weariness? Would it use its' increased strength and stature to rule over other bacteria? Would it fight to keep other bacteria from adhering to the Ring? Would it still evolve genetically, or would it instead b
21:14:33 <Cale> ecome a Bacteria-wraith?
21:15:39 <Cale> That's from http://flyingmoose.org/tolksarc/test.htm :)
21:15:40 <lambdabot> Title: The Definitive Middle-earth Test
21:15:50 <syntaxfree> wow. Peter Jackson is lost a lot of weight between LotR and King Kong.
21:17:07 <Cale>  13. When the Dwarves of beautiful Khazad-Dum built their Western door, why did they allow it to be inscribed with the insulting name of "Moria" ("Black Pit"), a name that would only be earned long years afterwards?
21:18:59 <LordBrain> Is it explicitely stated that they did that? Otherwise maybe it wasnt inscribed until later...
21:32:23 <syntaxfree> does anyone know of a place where I can find movie spoilers?
21:32:31 <syntaxfree> I don't want to watch Bitter Moon, I just want to know the story.
21:32:40 <gzl> http://www.themoviespoiler.com/
21:32:42 <lambdabot> Title: The Movie Spoiler
21:35:54 <syntaxfree> I can't find a good spoiler googling.
21:36:01 <syntaxfree> Anyone saw that movie?
21:48:56 <emertens> BBC World Service is running a story now about how media center pc's and PDA's are going to overtake the PC...
21:48:58 <RyanT5000> oleg, ping
21:49:12 <RyanT5000> @seen oleg
21:49:12 <lambdabot> I haven't seen oleg.
21:49:21 <RyanT5000> wait, what's his handle?
21:50:11 <emertens> I wonder if Linux is going to unseat microsoft next year too !
21:53:08 <Korollary> emertens: That, and the network is the computer.
21:53:42 <emertens> cell phones will soon be the prefer method to browse the www
21:53:50 <Korollary> and play fps games
21:53:51 <emertens> preferred*
21:53:55 <emertens> exactly
21:54:00 <emertens> i think we are on the same page
21:54:09 <Korollary> visionary, as some say
21:54:10 <stepcut> network pda's running haskell software on the linux kernel will be unseating microsoft in 2007 -- that's what I heard at least
21:54:27 <emertens> by 2007, haskell will have it's own kernel
21:54:31 <stepcut> by?
21:54:37 <stepcut> haskell kernels is so 2005
21:54:47 <emertens> I'm talking mainstream
21:54:49 <Korollary> unseating MS is aiming low. if anything, you must unseat MS, GOOG and Time Warner.
21:55:06 <stepcut> emertens: i see
21:55:12 <RyanT5000> GOOG i can live with, for now
21:55:23 <stepcut> MS, Oracle, Time Warner, and SBC
21:55:31 <RyanT5000> they still seem on a distinctly lower level of evil than MS and TW
21:55:32 <Korollary> and eBay
21:55:53 <emertens> I'm not interested in what Linux distros and Vista has to offer atm... AAPL is excitement enough ;)
21:56:07 <Korollary> Vista offers something?
21:56:14 <stepcut> American Association of Professional Landmen
21:56:29 <stepcut> http://www.landman.org/
21:56:30 <lambdabot> Title: AAPL - America's Landmen
21:56:47 <emertens> Korollary: a way for normal PC users to experience some of Mac's functionality next year
21:56:59 <Korollary> emertens: like what?
21:57:00 <emertens> Korollary: to wet their appetites
21:57:42 * stepcut is holding out for coyotos
21:57:47 <emertens> coyotos?
21:58:06 <Korollary> GNU hurd!
21:58:12 <stepcut> new capabilities based micro-kernel from Jonathon shapiro
21:58:28 <stepcut> *possibly* the new micro-kernel for Hurd
21:58:51 <emertens> Based on my limited understanding of Hurd, I would expect that it would be best suited to make use of the 8-core and beyond systems of the future
22:00:23 <stepcut> Yeah, the current hurd needs about 8-cores to get reasonable performance :p
22:00:34 <emertens> heh
22:01:55 <emertens> anyone know if the guy that said "Those who do not understand UNIX are doomed to reinvent it badly"
22:02:13 <emertens> and the "Any reasonably sized application will contain an ad-hoc"
22:02:26 <emertens> "and buggy half-implementation of CL"
22:02:30 <emertens> are related?
22:02:31 <emertens> :)
22:02:50 <emertens> (obviously neither of those quotes were verbaitum)
22:02:56 <stepcut> good question
22:03:28 <RyanT5000> the second guy is probably Paul Graham (though i can't say i remember explicitly that it's him)
22:03:30 <emertens> I wonder if either of those subsumes the other :-D
22:04:33 <Korollary> no, it's not PG
22:04:49 <Korollary> it could be MacCarthy
22:05:11 <emertens> it was somebody's nth law
22:05:20 <Korollary> Philip Greenspun's Tenth Rule of Programming
22:05:39 <emertens> yeah, that one
22:06:18 <Korollary> 1993
22:06:40 <Korollary> I am not sure if PG has said anything memorable
22:06:45 <Korollary> @quote PaulGraham
22:06:46 <lambdabot>  An algorithm for lazy evaluation of research papers: Just write whatever you want and don't cite any previous work, and indignant readers will send you references to all the papers you should have
22:06:46 <lambdabot> cited.
22:07:13 <emertens> @quote PaulGraham
22:07:13 <lambdabot>  An algorithm for lazy evaluation of research papers: Just write whatever you want and don't cite any previous work, and indignant readers will send you references to all the papers you should have
22:07:13 <lambdabot> cited.
22:07:15 <emertens> any more?
22:07:16 <emertens> :(
22:07:43 <Korollary> http://www.paulgraham.com/better.html
22:07:45 <lambdabot> Title: Better Bayesian Filtering
22:07:54 <Korollary> the first paragraph
22:08:24 <Korollary> It's not quite accurate, eh
22:08:30 <emertens> I still maintain that the Israeli/Palestinian conflict could be resolved with mdo :)
22:09:13 * emertens is still listening to BBC and it is influencing his typing
22:09:17 <Korollary> I don't get what he's saying. Is he evaluating somebody else's paper or writing his own?
22:09:45 <emertens> lazy evaluation seems like the wrong phrase
22:09:55 <emertens> lazy generation might actually make sense
22:10:28 <emertens> I imagine he simply doesn't know what lazy evaluation means
22:10:40 <Korollary> Perhaps, but if you don't actually refer to those papers, you don't need to cite them anyway.
22:11:29 <emertens> I think he's suggesting you just write something
22:11:33 <emertens> and if it's related to previous work
22:11:42 <emertens> "indignant readers" will tell you
22:11:56 <Korollary> But his essay is on spam filters, which he hasn't invented. So I am guessing "the algorithm" applies to many papers he had to read.
22:13:12 <emertens> wikipedia says that haskell was influenced by gofer...
22:13:19 <emertens> isn't gofer an implementation of haskell?
22:13:33 <Korollary> I thought so
22:13:36 <syntaxfree> oh no, Stephen Colbert is telling people to vandalize Haskell on Wikipedia!
22:13:43 <emertens> seems kind of backwards to me then
22:13:52 <emertens> syntaxfree: old news yo :)
22:13:58 <Korollary> syntaxfree: Yes, we should turn Haskell's popularity into a wikiality.
22:14:14 <emertens> syntaxfree: I didn't read your whole comment
22:14:42 <syntaxfree> That's lazy evaluation of IRC.
22:14:51 <syntaxfree> You reply as you read.
22:15:23 <RyanT5000> so could anyone tell me oleg's handle?
22:15:31 <Korollary> RyanT5000: Oleg hangs out here?
22:15:36 <RyanT5000> oh, he doesn't?
22:15:37 <emertens> I've never seen him here
22:15:38 <RyanT5000> nvm then
22:16:00 <emertens> but my idling here is relatively recent as Haskell history goes
22:16:01 <syntaxfree> I remember an Oleg.
22:16:03 <syntaxfree> @seen Oleg
22:16:03 <lambdabot> I haven't seen Oleg.
22:16:11 <RyanT5000> it's nothing important; i just wanted to tell him that his criticism of sort-based shuffling is flawed :P
22:16:21 <Korollary> RyanT5000: you should just email the list
22:16:29 <Korollary> oh
22:16:35 <Korollary> his shuffling article
22:16:39 <emertens> I didn't really like his basic assumption of how shuffling works
22:16:56 <RyanT5000> emertens, what "basic assumption" do you mean?
22:17:18 <emertens> that most people assign a random number to each element and sort the list accordingly
22:17:25 <emertens> allowing the initial state
22:17:30 <emertens> to influence the final results
22:17:43 <RyanT5000> oh, no, i don't think that's what "most people" do
22:17:47 <RyanT5000> but that can certainly work
22:17:53 <Korollary> I dont know what most people do.
22:17:58 <emertens> that's what he suggests is the common and wrong way to sort I thought
22:18:04 <emertens> err
22:18:05 <emertens> shuffloe
22:18:26 <RyanT5000> and in fact, i'm pretty sure it's the only way to get a perfect shuffle assuming your RNG only generates numbers between 0 and 2^n-1 for some n
22:18:53 <RyanT5000> however, it's only valid if you throw away the computation any time your RNG generates a duplicate value
22:19:02 <emertens> right
22:19:38 <RyanT5000> or, i suppose, if you were to shuffle each thing in one of those duplicate-value-groups recursively
22:21:11 <emertens> RyanT5000: what point did you disagree on?
22:21:32 <emertens> with Oleg
22:21:47 <RyanT5000> the part where he says sort-based algorithms are bad :P
22:22:07 <RyanT5000> here's the real reason i prefer sort-based algorithms
22:22:28 <RyanT5000> swap-based algorithms can't work on fundamentally unordered sets
22:22:45 <RyanT5000> which are a datastructure i love, but have never seen actually implemented
22:23:10 <RyanT5000> (not that it'd be hard to black-box away all the things in, e.g. haskell's Set, that make it not that)
22:23:27 <emertens> if you are using a sort algorithm ,the nyou would be putting your unordered data set into an ordered one anyway... right?
22:23:38 <RyanT5000> right
22:23:56 <emertens> so you might as well put it in an ordered one and use the swap algorithm?
22:24:30 <RyanT5000> right, but if you have an unordered one, how do you make it ordered to use the swap algorithm?
22:24:48 <emertens> and for the data structure to be shuffled it must be ordered...
22:25:10 <emertens> it would seem, by definition...
22:25:17 <RyanT5000> hm? no
22:25:31 <emertens> if a data structure isn't ordered... how do you shuffle it ever?
22:25:41 <emertens> what does it mean to shuffle an unordered data set
22:25:58 <syntaxfree> @hoogle Set
22:25:58 <lambdabot> Data.Set :: module
22:25:59 <lambdabot> Data.Set.Set :: data Set a
22:25:59 <lambdabot> Distribution.Setup :: module
22:26:04 <RyanT5000> it means to construct an ordering of its elements
22:26:12 <RyanT5000> that does not depend on the elements' contents
22:26:38 <emertens> I'm just saying that the ordered point seemed moot because you have to store the results in an ordered data structure anyway
22:26:52 <RyanT5000> well yes, physically in ram it needs to be ordered
22:27:08 <Pseudonym> Not necessarily.
22:27:17 <RyanT5000> huh?
22:27:25 <Pseudonym> A set of booleans can be implemented as a pair of Integers.
22:27:38 <Pseudonym> No "ordering in ram" needed.
22:27:56 <emertens> I'm not talking about hardware representations
22:28:03 <RyanT5000> a pair of integers? i can think of several ways that involve a single integer, but none that involve a pair
22:28:04 <Pseudonym> Actually, that's a bag of booleans.
22:28:08 <Pseudonym> A set only needs two bits.
22:28:14 <SamB_XP> heh
22:28:14 <RyanT5000> Pseudonym: which would be ordered ;)
22:28:30 <SamB_XP> RyanT5000: not likely
22:28:39 <emertens> I can think of one set that needs no bits :)
22:28:54 <SamB_XP> most systems don't have a particular bit order at the byte level...
22:29:08 <RyanT5000> SamB_XP: they do if you have an electron microscope :P
22:29:26 <RyanT5000> they're still fundamentally ordered
22:29:50 <SamB_XP> heh
22:29:58 <emertens> all I'm trying to say is that the process of shuffling data results in giving that data order...
22:30:15 <RyanT5000> emertens: yes, that's the whole point
22:30:23 <RyanT5000> but if you start with fundamentally unordered data
22:30:27 <emertens> so why does it matter that the source of that data was unordered
22:30:36 <emertens> you are going to order it
22:30:43 <RyanT5000> it doesn't; what i'm saying is that you can't use the swap algorithm on it if it's unordered
22:30:45 <RyanT5000> you can use the sort algorithm
22:30:52 <SamB_XP> heh
22:31:01 <RyanT5000> sorting an unordered set is a totally well-defined and valid operation
22:31:11 <SamB_XP> unordered usually just means there is no guarentee about what order things are in
22:31:13 <emertens> and the result is an ordered set
22:31:18 <RyanT5000> emertens: yes
22:31:36 <RyanT5000> and what i'm saying is that you can't do a swap sort - direclty - on an unordered set
22:31:38 <emertens> so I didn't see the difference in having an unorderd set, copying it to an ordered one and swapping
22:31:45 <emertens> directly, yeah that
22:31:49 <emertens> why does it matter if it's direct
22:31:52 <RyanT5000> emertens: you can't just copy an unordered set to an ordered one
22:31:59 <RyanT5000> what order do you put it in?
22:32:04 <SamB_XP> emertens: well... you'd need to convert to an appropriate representation
22:32:38 <RyanT5000> by copying an unordered set to an ordered representation, you are imposing an order; the only way to do that (that i can think of right now) is by sorting
22:32:39 <emertens> fine
22:33:02 <SamB_XP> usually "unordered" representations *are* sorted...
22:33:21 <RyanT5000> SamB_XP: that's an artifact of implementation, though, which i'm not concerned with at the moment
22:33:33 <SamB_XP> you is crazy
22:33:35 <RyanT5000> lol
22:33:36 <emertens> so how do you copy the data from your set into a list even with sorting
22:33:58 <emertens> how would you ask for specific elements?
22:34:04 <SamB_XP> emertens: with an implementation, which RyanT5000 isn't concerned with at the moment ;-)
22:34:30 <RyanT5000> emertens: well, sort could be a primitive of the set type
22:34:32 <emertens> it seems like you'd need to ask for an ordered representation to sort
22:34:57 <Pseudonym> This makes more sense in a logic language, BTW.
22:35:14 <emertens> RyanT5000's point?
22:35:17 <Pseudonym> ?- make_set(List, Set).
22:35:18 <lambdabot> Maybe you meant: . v
22:35:23 <Pseudonym> If you supply a list, you get a set.
22:35:34 <emertens> list -> set makes sense to me
22:35:42 <Pseudonym> If you supply a set, you get (nondeterministically) all possible lists that could make that set.
22:35:57 <RyanT5000> emertens: if you have a totally unordered set, you need to have some primitives to operate on it, right?
22:36:04 <SamB_XP> Pseudonym: *all*
22:36:05 <SamB_XP> ?
22:36:09 <Pseudonym> All.
22:36:14 <emertens> RyanT5000: why make sort a primative? why not set -> arbitrary list
22:36:16 <SamB_XP> or just all of the ones without duplicate elements?
22:36:26 <Pseudonym> Logically, you'd get all.
22:36:37 <SamB_XP> but can you *do* that?
22:36:38 <RyanT5000> emertens: that's a good point: because set -> arbitrary list isn't functional
22:36:53 <SamB_XP> RyanT5000: heh
22:36:59 <Pseudonym> Sure you can.
22:37:01 <SamB_XP> well, thats why the list should be sorted
22:37:05 <RyanT5000> unless by "arbitrary" you mean "implementation dependent"
22:37:10 <Pseudonym> In Haskell, you could do it this way:
22:37:13 <RyanT5000> which means you're revealing the structure of the datastructure
22:37:20 <RyanT5000> which isn't allowed
22:37:22 <Pseudonym> setToList :: (MonadNondet m) => Set a -> m [a]
22:37:26 <SamB_XP> RyanT5000: sure it is
22:37:37 <emertens> RyanT5000: what isn't allow is to make assupmtions on what is revealed.. right?
22:37:40 <Pseudonym> Or MonadPlus, I guess.
22:37:53 <SamB_XP> Pseudonym: I was thinking more of the fact that there would be an infinite number of such lists
22:37:58 <Pseudonym> So?
22:38:05 <Pseudonym> Haskell programmers don't have a problemw tih that
22:38:07 <Pseudonym> with
22:38:13 <SamB_XP> and the one you want might be near the end of it
22:38:14 <Pseudonym> Prolog programmers don't either.
22:38:19 <SamB_XP> in a place you can't get to
22:38:24 <Pseudonym> So?
22:38:27 <RyanT5000> emertens: i'm saying that you're not allowed to reveal, in any way, how the datastructure is constructed
22:38:35 <Pseudonym> I'm just saying it makes sense logically.
22:38:35 <RyanT5000> that's what i mean by "fundamentally unordered"
22:38:53 <SamB_XP> RyanT5000: you play by odd rules
22:38:55 <SamB_XP> you know that?
22:38:57 <Pseudonym> Yes, there are pragmatic problems due to infinite success or infinite failure.
22:39:06 <RyanT5000> SamB_XP: i play by extremely strict rules
22:39:20 <SamB_XP> Haskell isn't a strict language, go use ML!
22:39:22 <RyanT5000> lol
22:39:30 <emertens> RyanT5000: so you are saying that you must specify the order
22:39:36 <RyanT5000> emertens: yeah,  pretty much
22:39:41 <emertens> ok
22:39:47 <emertens> I'm comfortable with that
22:40:05 * SamB_XP expects RyanT5000's code to be littered with chicken/egg dilemas
22:40:16 <RyanT5000> SamB_XP: i try not to actually code like this :P
22:40:22 <SamB_XP> oh okay
22:40:26 <emertens> RyanT5000: but I don't think that you can use that set -> sorted list functionality to shuffle
22:40:33 <RyanT5000> emertens: why not?
22:40:46 <emertens> RyanT5000: how are you going to set this random values on each element?
22:40:48 <SamB_XP> emertens: sure you can
22:40:59 <emertens> that you would then sort with
22:41:08 <SamB_XP> well, you'd need to shuffle after, most likely...
22:41:21 <emertens> no, because then theh swap algorithm would be just as good
22:41:29 <SamB_XP> because by RyanT5000's rules, folding isn't allowed either
22:41:30 <emertens> so he's thinking of something else
22:41:42 <SamB_XP> emertens: huh?
22:41:46 <RyanT5000> emertens: mapping over a set is legal
22:42:12 <RyanT5000> however, i'll admit that you do get stuck at this point with haskell as i know it
22:42:27 <SamB_XP> of course, in my rules you are allowed as long as you don't really care what order the set is in...
22:42:29 <emertens> RyanT5000: but in a pure functional language, the random assignment of numberes must be ordered
22:42:40 <emertens> right?
22:42:57 <emertens> or rather the assignment of random numbers
22:43:02 <RyanT5000> emertens: perhaps, but i think that depends on your definition of "pure functional"
22:43:11 <RyanT5000> certainly you must operate in something simmilar to IO
22:43:17 <Korollary> no, I think it depends on your definition of set.
22:43:17 <SamB_XP> heh
22:43:23 <emertens> if you aren't threading the state generator through each assignment
22:43:31 <emertens> then you don't have referential integrity
22:43:32 <SamB_XP> emertens: but you are
22:43:46 <emertens> what order do you thread said generator through the set?
22:43:49 <RyanT5000> emertens: this is equivalent to concurrency
22:43:58 <SamB_XP> emertens: you can't do that
22:44:03 <SamB_XP> because you aren't allowed to fold
22:44:07 <emertens> right
22:44:30 <RyanT5000> effectively you need to run each instance of the map function in a separate thread
22:44:45 <SamB_XP> what have threads to do with anything?
22:45:09 <RyanT5000> SamB_XP: you have to assume that the order in which the mapping is applied is irrelevant
22:45:34 <SamB_XP> I don't think threads have anything to do with anything
22:45:51 <RyanT5000> "indeterminate order" is the same as threads
22:46:03 <RyanT5000> at least for the purposes i'm using them for here
22:46:12 <RyanT5000> assuming an idealized "thread" abstraction
22:46:15 <emertens> RyanT5000: then you expose the implementation of the threads?
22:46:15 <SamB_XP> but obviously folding is illegal if orders are not allowed to affect the program
22:46:42 <SamB_XP> you have an odd idea of threads
22:46:56 <RyanT5000> emertens: i'm pretty sure that could be hidden to
22:46:57 <RyanT5000> in fact
22:47:02 <RyanT5000> the way that would be hidden
22:47:14 <RyanT5000> is that mapping over unordered sets would be the way of spawning threads
22:47:33 <RyanT5000> SamB_XP: i'm an odd guy :P
22:47:36 <syntaxfree> http://en.wikipedia.org/wiki/Nemerle
22:47:39 <syntaxfree> cool.
22:47:55 <SamB_XP> you don't need anything like threads to express the parallism of a map, or the fact that mapping (and possibly also concatMapping) is the only thing allowed...
22:48:06 <SamB_XP> well, I suppose testing if something is in the set might be allowed as well
22:48:16 <emertens> i think you are trying to use "ryan-threads" to avoid the issue
22:48:18 <emertens> ;)
22:48:27 <RyanT5000> emertens: perhaps :P
22:48:35 <emertens> why not just map a choose function over the set
22:48:38 <RyanT5000> RNGs are actually rather special in this regard
22:48:41 <emertens> and the threads will return the elements
22:48:43 <RyanT5000> because they aren't functional
22:48:46 <emertens> in an unspecified ideal order
22:48:47 <RyanT5000> but they're also stateless
22:49:01 <RyanT5000> (if i meant PRNG i would've said it :P)
22:50:05 <SamB_XP> oh you *are* crazy
22:50:08 <emertens> if you had a true RNG... shuffling a list seems like the least of your concerns
22:50:10 <syntaxfree> "Linspire GNU/Linux chose Haskell for system tools developmen"
22:50:23 <SamB_XP> that isn't allowed in a pure language
22:50:25 <RyanT5000> emertens: true RNGs aren't exactly hard to come by
22:50:41 <SamB_XP> I mean, you'd need to use it in the IO monad
22:50:44 <RyanT5000> there's one in the new intel chipset - not necessarily great quality
22:50:49 <RyanT5000> and obviously there's a driver in the way
22:50:54 <emertens> SamB_XP: he's not talking about doing this in Haskell... is he
22:50:54 <RyanT5000> which is decidedly not functional
22:50:56 <emertens> ?
22:50:58 <RyanT5000> lol no
22:51:18 <SamB_XP> you can't do it in any pure language...
22:51:24 <emertens> right
22:51:29 <RyanT5000> i'm not talking about a particular language here
22:51:42 <SamB_XP> you can't do it in any pure *calculus* either
22:51:49 <emertens> given this RNG, just assign each element a random, unbounded number
22:51:54 <SamB_XP> or algebra or what-have-you
22:51:55 <emertens> the probability of collision is 0, right?
22:52:06 <SamB_XP> uh
22:52:10 <RyanT5000> emertens: i don't require that my RNG be unbounded
22:52:14 <emertens> why?
22:52:16 <SamB_XP> how do you get a random unbounded number?
22:52:19 <RyanT5000> it's unnecessary
22:52:30 <emertens> we aren't talking about the physical contraints of hardware
22:52:50 <SamB_XP> me either
22:52:50 <RyanT5000> assign the numbers, check for collisions, if there are, go back to the beginning
22:52:56 <SamB_XP> it isn't called "pure" if you do that
22:53:02 <SamB_XP> end of story
22:53:05 <emertens> SamB_XP: i don't think we are worried about pure
22:53:18 <emertens> i thought we were, but now I don't think that that is the case
22:53:45 <RyanT5000> are there any other stateless non-pure things?
22:54:05 <RyanT5000> or do you guys not buy my assertion that an RNG is stateless  and non-pure
22:54:09 <SamB_XP> what makes you think an RNG is stateless?
22:54:28 <SamB_XP> maybe you can't tell what state it is in, though, so it probably might as well be
22:54:31 <RyanT5000> well, it has no input
22:54:40 <SamB_XP> sure it has input...
22:54:43 <emertens> an RNG is definitely not pure (as opposed to a PRNG)
22:54:44 <SamB_XP> noise input...
22:55:27 <SamB_XP> what do you think they do? pull numbers out of the air? oh wait, isn't that what they actually do?
22:55:34 <SamB_XP> hmm, I better go to bed...
22:55:39 <RyanT5000> yeah, or out of quantum fluctuations
22:55:48 * SamB_XP goes to bed
22:55:54 <RyanT5000> the point is that the output of a RNG doesn't depend on its previous output
22:56:03 <RyanT5000> which is actually the definition of stateless in signal theory
22:56:09 <emertens> more importantly, it doesn't depend on it's inputs
22:56:11 <RyanT5000> (woot! actually used some knowledge from my signal theory class!)
22:56:29 <emertens> the function that is
22:56:46 <RyanT5000> yeah
22:56:47 <Korollary> it's obviously not referentially transparent
22:56:56 <RyanT5000> Korollary: true
22:56:57 <emertens> and thus not pure
22:57:12 <emertens> and that's why we've moved beyond my arguments
22:57:28 <Korollary> I dont think RT is equivalent to pure
22:57:29 <emertens> becaus I don't fully understand the ryan-architecture that we are dealing with
22:58:21 <RyanT5000> emertens: i'm sorry about that, i wish i could formalize my ideas better
22:58:35 <RyanT5000> Korollary: what do you mean by RT?
22:58:43 <emertens> referentially transparent
22:58:47 <RyanT5000> ah right
22:58:53 <emertens> pure relates to immutable values
22:59:01 <RyanT5000> hm
22:59:20 <Korollary> See this: http://en.wikipedia.org/wiki/Talk:Referential_transparency
23:00:03 <RyanT5000> well my question is, is there anything other than an RNG that's not RT but is stateless?
23:00:14 <RyanT5000> oh nice
23:00:18 <RyanT5000> lol it's this exact discussion
23:00:19 <emertens> "This is not strictly true: you could include an impure function and discard its value."
23:02:00 <emertens> RyanT5000: one problem with recursively shuffling
23:02:09 <emertens> might be that it's not guarenteed to halt
23:02:32 <RyanT5000> that's true
23:02:42 <RyanT5000> in fact it definitely isn't guaranteed to halt
23:03:02 <emertens> it could collide over and over
23:03:26 <emertens> so your worst case run-time is ... infinite ;)
23:03:28 <RyanT5000> neither is anything that produces a random number from 0 to N from a random number from 0 to M where N and M are relatively prime (<-- i just made that up but i'm nearly certain it's true, and is in fact a special case of a more general theorem)
23:05:37 <emertens> that would be a good instance to use "coprime"
23:05:46 <emertens> iirc
23:05:53 <RyanT5000> yeah, possibly
23:06:26 <emertens> infact they are synonyms :) (I just like the sound of "coprime")
23:06:47 <RyanT5000> are you sure? well i know relative prime isn't stronger than coprime, anyway
23:07:40 <Cale> they're the same
23:07:41 <emertens> mathworld seems to link coprime directly to relatively prime
23:07:46 <RyanT5000> k
23:08:22 <emertens> Cale was keeping quiet.. but he couldn't resist stopping us from misusing common math terms
23:08:26 <Cale> They both mean that the gcd of the numbers is 1
23:08:40 <RyanT5000> :)
23:08:51 <RyanT5000> k, that's what i meant :)
23:09:04 <RyanT5000> and i'm pretty sure i'm right about my assertion above
23:09:10 <emertens> ooh, or you can call them "strangers" :)
23:09:14 <syntaxfree> how do you feel about Helium?
23:09:37 <dons> re.
23:09:49 <emertens> It didn't dawn on me at first that Helium was a Haskell library
23:09:53 <emertens> or application
23:10:02 <emertens> (I don't actually know what it does, I've just heard of it)
23:10:13 <emertens> @where helium
23:10:13 <lambdabot> http://www.cs.uu.nl/research/projects/helium/
23:10:29 <syntaxfree> I thought Helium was a subset of Haskell.
23:10:40 <emertens> ah, it's for learning haskell
23:10:57 <emertens> and it doesn't support type classes
23:11:12 <syntaxfree> "Bastiaan Heeren, Daan Leijen, and Arjan van IJzendoorn in 2003 also observed some stumbling blocks for Haskell learners. [8] To address these, they developed an advanced interpreter called Helium which improved the user-friendliness of error messages by limiting the generality of some Haskell features, and in particular removing support for type classes."
23:11:24 <emertens> which "History of Haskell" seems to suggest are among Haskell's greatest contributions
23:11:49 <dons> right :)
23:11:50 <syntaxfree> so they're basically saying you can go terribly wrong if you try to  learn Haskell directly (and you are somewhat naive about it) you're bound to screw up eventually.
23:12:09 <dons> syntaxfree: well, its for an introductory comp. sci course. with careful tutoring
23:12:10 <syntaxfree> Should I get my cat theory right or something else before proceeding with Haskell?
23:12:17 <dons> so in that situation, perhaps a mini-haskell is useful
23:12:24 <dons> but for your everyday hacker, just program in Haskell
23:12:46 <syntaxfree> The thing is, I get by hacking around with Haskell alright.
23:12:48 <dons> (its quite common in teaching to use mini versions of languages, after all. but that doesn't mean the average guy should program in mini-Foo)
23:12:48 <Cale> syntaxfree: I wouldn't worry too much about category theory. It's nice to know, but it's not really essential to understanding Haskell.
23:12:54 <emertens> type classes aren't particularly challenging
23:12:54 <syntaxfree> But I have nearly no formal background.
23:13:07 <Korollary> To me it sounded something like DrScheme
23:13:11 <emertens> I can only see that being useful if you have never programmed before
23:13:18 <dons> its just a language. you don't need to understand the theoretical aspects of imperative languages to program C either :)
23:13:23 <Heffalump> it is possible to build ghc normally using a ghc that doesn't support TH, right?
23:13:29 <dons> emertens: right. that's what its for, yes?
23:13:34 <dons> Heffalump: yep
23:13:36 <emertens> dons: Ain't that the truth :)
23:13:38 <syntaxfree> my cat theory is half-baked and was learned in a game-theoretical context.
23:13:48 <emertens> dons: yeah, so it looks like we agree
23:13:49 <dons> Heffalump: you want the flags?
23:13:50 <Cale> Category theory is also one of those things which is best studied after taking courses in linear algebra, groups, rings, metric spaces, graphs, etc.
23:14:03 <Cale> Oh, and topology of course :)
23:14:08 <dons> oh, of course.
23:14:12 <Korollary> Cale: Today I saw a book draft that teaches CT first :)
23:14:21 <dons> ;) /me thinks category theory comes after adv. functional programming
23:14:26 <dons> but maybe i'm biased ;)
23:14:27 <Cale> You could do it first, it would just be dry.
23:14:34 <Korollary> It's dry either way
23:14:39 <syntaxfree> Cat theory often arises outside computer science.
23:14:44 <Heffalump> dons: by "normally" I meant "do I need to change anything?"
23:14:46 <Cale> You really need lots of examples to make it colourful.
23:14:48 <syntaxfree> My cat theory comes from advanced game theory.
23:14:51 <dons> Heffalump: yes you do.
23:14:55 * dons hunts for flags
23:14:55 <emertens> i use it a lot while driving
23:15:08 <Heffalump> my host compiler does actually support TH, but I've changed the TH datatype
23:15:16 <dons> Heffalump: GhcWithInterpreter = NO, I think
23:15:18 <syntaxfree> http://urchin.earth.li/pipermail/debian-haskell/2006-May/000169.html
23:15:20 <lambdabot> Title: [Debian-haskell] Linspire/Freespire Core OS Team and Haskell
23:15:22 <dons> means no ghci, which implies no TH
23:15:28 <emertens> dons: have you finished enough of your PhD to get ghc working on current OpenBSD? :-D
23:15:36 <Heffalump> first time round I got a type error in the stage 2 compiler, so I'm worried that now I'll get a problem in the stage 1 compiler
23:15:51 <dons> Heffalump: hmm. type error?
23:16:06 <dons> emertens: you mean ghci on openbsd?
23:16:12 <emertens> dons: yes
23:16:20 <dons> emertens: in which case, not till after the PADL deadline, Sep 3
23:16:38 <dons> after which, I'll be installing 4.0 and fixing things
23:16:45 <Heffalump> dons: yes, cos I'd changed the TH datatype, but not changed the compiler to match up
23:17:02 <emertens> dons: let me know if you just want an account on an existing 4.0 box :)
23:17:06 <dons> oh hmm. I think disabling the interpreter as above, should work
23:17:31 <dons> ?localtime Heffalump
23:17:33 <lambdabot> Local time for Heffalump is Tue Aug  8 07:17:10 2006
23:17:41 <Heffalump> so do I need to do a total of 3 builds then?
23:17:49 <dons> 2 should be ok, no?
23:17:52 * Heffalump is a bit confused about the ghc building process now.
23:17:58 <dons> stage1, build everything. stage2, rebuild compiler/
23:18:07 <dons> stage3 is to test stage2
23:18:15 <Heffalump> ok, so I just need to make sure that stage1 has the interpreter off?
23:18:18 <dons> you can then throw away stage3
23:18:28 <Heffalump> but stage2 will have everything
23:18:44 <dons> well, it'll rebuild the compiler. but not if you've got GhcWithInterpreter = NO
23:18:44 * Heffalump --> investigate the debian package, which is what I'm rebuilding
23:18:53 <dons> it'll rebuild the compiler, but not ghci
23:19:10 <Heffalump> but if I build stage1 without the interpreter, but stage2 with it, it'll be ok?
23:19:47 <dons> not sure. probably ok
23:20:12 * Heffalump decides to just see what happens
23:20:41 <Korollary> Heffalump: You could use the generic linux glibc2.3 binary to bootstrap a build
23:21:10 <emertens> that's what I should do... run ghci in linux emulation mode on my openbsd box
23:22:20 <dons> it works, but very painfully
23:22:26 <dons> though, ghci maybe not so painfully
23:22:34 <dons> emertens: or you could attempt to fix the problem, with my guidance
23:22:40 <dons> since i suspect its pretty simple
23:22:51 <dons> i've run ghc itself under linux emul.
23:22:55 <dons> producing nice linux binaries
23:23:00 <dons> which in turn run under linux emul
23:23:20 <Korollary> why are you guys running bsd anyway? (I know nothing about bsd)
23:23:33 <dons> Korollary: why are you using Haskell? ;)
23:23:53 <dons> OpenBSD is the Haskell of the operating system world ;)
23:24:01 <emertens> dons, I've got a fresh 6.4.2 src tree ready
23:24:02 <Korollary> As I said, I know nothing about it
23:25:00 <dons> the BSDs tend to be simpler and cleaner than linux, as a rule. Also, it helps that the distro and kernel are written by the same people -- the code stays more coherent
23:25:10 <dons> that's my view, anyway
23:25:11 <emertens> I use OpenBSD because it's a very "clean" operating system. everything is easily configured with simple text files
23:25:18 <emertens> the man pages are very well kept
23:25:33 <dons> ?version
23:25:34 <lambdabot> lambdabot 4p49, GHC 6.5 (OpenBSD i386 )
23:25:34 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
23:25:38 <dons> lambdabot likes bsd too :)
23:25:58 <emertens> and OpenBSD has an excellent packet filter and ipsec support
23:26:30 <emertens> along with driver support for wireless devices and other reasons I bet you don't care about :)
23:26:57 * dons has been tempted to write a haskell edsl for the packet filter, actually
23:26:58 <Korollary> But I don't even configure anything
23:27:20 <emertens> then you are a perfect candidate for openbsd
23:27:26 <emertens> it's got sane default configuration
23:27:27 <Korollary> what is it in linux that has a non-textfile config file?
23:28:01 <emertens> many times the config is hidden behind guis (both curses and x11)
23:28:50 <Krunch> emertens: not really at the OS level, that's more a problem with desktop environments (and they are not really linux-specific)
23:29:01 <dons> i always found it nice that the openbsd slogan was something like "functional, minimal, secure" or so
23:29:07 <emertens> pick 3
23:29:10 <dons> since i tend to like functional thingamies
23:29:16 <dons> yeah, choose 3.
23:29:23 <Korollary> It's a slogan.
23:29:25 <Krunch> free, functional, secure
23:29:32 <dons> ah , that's right
23:29:35 <dons> like haskell!
23:29:46 <dons> dons@openbsd.org should know that :S
23:30:20 <Korollary> Who runs 'minimal' OS' nowadays? Are we still on 800MB harddrives?
23:30:21 <norpan> functional, fast, futuristic, pick 3
23:30:44 <mcnster> what about furry?
23:30:46 <emertens> for my desktop, I prefer OS X, but I do a lot of my stuff through an ssh session to OpenBSD
23:30:47 <mcnster> i want furry
23:30:50 <norpan> fuzzy
23:30:53 <emertens> like this irc client :)
23:31:07 <dons> Korollary: its the same approach as a minimal prelude
23:31:13 <Krunch> minimal means less potential bugs
23:31:14 <mcnster> i have a q
23:31:26 <mcnster> why did the haskell programmer cross the road?
23:31:29 <norpan> minimal means less potential features
23:31:39 * RyanT5000 restrains himself from starting a microkernel debate
23:31:41 <emertens> it means you add the features you want
23:31:59 <norpan> mcnster: why?
23:32:08 * mcnster makes popcorn and chants "Go RyanT5000, Go!"
23:32:13 <emertens> neither the BSDs nor Linux are microkernels
23:32:22 <mcnster> a: to get out of the IO monad
23:32:30 <Korollary> Who cares about 'potential' bugs? Everybody knows what bugs are out there. No need to gamble based on size.
23:32:55 <emertens> for example, Ubuntu starts a bittorrent tracker by default on startup
23:33:04 <norpan> Korollary: you serious?
23:33:13 <emertens> that is the exactly opposite of what you would expect from obsd
23:33:39 <int-e> ouch.
23:33:40 <norpan> if everybody knew what bugs were out there there'd be no new bugs found
23:33:54 <Korollary> norpan: Yes. I have not discovered a bug myself yet. And for any distro out there, you could browse their buglist. It's not something you have to guess.
23:33:58 <dons> yikes, a bittorrent tracker by default on startup?
23:34:09 <mcnster> what if the microkernel approach was applied at the build layer, instead of the exec layer?
23:34:11 <dons> that's windows-ish
23:34:18 <Korollary> emertens: I run ubuntu. It doesn't run BT. Maybe you are talking about a particular installation profile.
23:34:23 <mcnster> using something like.... ummm.... haskell!
23:34:32 <norpan> Korollary: known bugs is not a problem, the bugs not found are
23:34:33 <RyanT5000> mcnster: that would only work if you had ways of simulating protected-mode
23:34:40 <emertens> Korollary: maybe I am, but the "default" install on this powerbook does it
23:34:41 <norpan> especially when it comes to security
23:35:08 <mcnster> RyanT5000, elabourate pls
23:35:16 <emertens> Korollary: but that was just one example, it does start a lot of services by default
23:35:24 <Korollary> norpan: I am not running a website on my linux box. I haven't had a security issue on my winxp laptop let alone a linux box.
23:35:29 <RyanT5000> mcnster: well, if you have a microkernel architecture, but any module can segfault, what's the point?
23:35:57 <RyanT5000> the point of a microkernel is that if any error happens in a module, only the things which explicitly depend on it can break
23:35:59 <norpan> Korollary: not anyone you know about anyway :)
23:36:22 <RyanT5000> otherwise you're just talking about modular design, which i doubt anyone would argue against
23:36:23 <emertens> if a tree falls and no one is around to hear it , does it make a sound?
23:36:26 <Korollary> emertens: So what? It takes perhaps 10 minutes to disable things.
23:36:36 <emertens> Korollary: i shouldn't have to is all
23:36:38 <mcnster> RyanT5000, ok.  i see your point
23:37:36 <Korollary> emertens: Sure. But is saving 10 minutes on an OS installation that you'll be running for months on really that big a deal?
23:37:42 <dons> Korollary: anyway, the reason to use openbsd is like the reason to use Haskell. Sure you can get the job done with other OSs/languages, but the philosophy is different.
23:37:55 <mcnster> has anyone ever tried engineering the rts to run on bare metal?
23:38:02 <dons> mcnster: done and done.
23:38:05 <dons> try House. :)
23:38:09 <dons> ?where House
23:38:09 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
23:38:24 <dons> i think the paper is actually called "Haskell on bare metal"
23:39:30 <mcnster> dons, serves me right for thinking i'm original :-)
23:39:42 <dons> heh
23:40:21 <vincenz> dons: I have the reasoned schemer :)
23:40:24 <vincenz> dons: and got my @msg?
23:41:00 <dons> ?spell fuseable
23:41:01 <lambdabot> fuse able fuse-able fusible usable feasible
23:41:19 <dons> vincenz: autojoin #oasis for lambdabot: done.
23:41:35 <dons> vincenz: how's the reasoned schemer going?
23:41:41 <dons> and why is there no reasoned haskeller??
23:41:53 <mcnster> well then, what about running haskell on top of a kernel using the directory/file system for modules/vars?
23:42:02 <vincenz> dons: good I read half of it
23:42:07 <vincenz> dons: I'm considering writing it in haskell :)
23:42:50 <glguy> One of the problems with leaving your server behind when you graduate from college at a fraternity is that there is no telling when someone is going to kill it off
23:43:09 <vincenz> dons: truth be told, rebindable ifthenelse and pattern syntax would rock for that
23:43:35 * glguy is emertens
23:44:32 * mcnster smells another dissertation brewing
23:49:06 <Heffalump> morning
