00:00:41 <dons> there' also hsp
00:00:52 <dons> and now hsp.clientside, for ajax-ish, javascript stuff
00:02:37 <tessier> Man...someone needs to write some software to condense mailing lists into stuff you are likely to be interested in...I subscribe to a zillion and don't have time to read them all.
00:02:46 <tessier> I wonder if I could use some sort of bayesian thing to do that...
00:03:19 <tessier> Maybe it could look at threads or emails I have read in the past and take that as an indication that I am likely to be interested in them in the future.
00:04:37 * edwardk laughs. Eric Meijer has fallen very far.
00:04:56 <edwardk> http://msdn.microsoft.com/archive/default.asp?url=/archive/en-us/vbtv/episode1.asp episode 1. 'the head in the box' is him =)
00:05:34 <Stinger_> visual basic? : /
00:05:48 <edwardk> stinger: yeah
00:06:13 <dolio> If your client/downloader supports running mail through external programs in a filter, you could probably cook up some commands to use existing bayesian filters to categorize your mailing lists.
00:06:40 <dolio> Make it use a different database for each mailing list, and then mark things you read as ham/don't as spam. :)
00:10:10 <dolio> Not exactly seamless, of course.
00:10:24 <midfield> dons: I'm writing a function which memcmp's the various sub-arrays of the BinHandles which represent my serialized structures.  i think it should work
00:12:32 <monochrom> with procmail, everything is seamless
00:43:37 <goltrpoat> say i have data Var = forall x. (Show x) => Var (String, [x]) and instance Show Var where show = ... etc.  is there a way to drop Show from the existential context for Var?  i.e. i don't care if any x are instances of Show -- there's no reason for them to be if i don't need to show them
00:44:26 <goltrpoat> in other words, i want to delegate the responsibility of making sure that the types they're using, when they want to pretty print something or other, are Showable
00:46:50 <edwardk> ah i see the problem. you don't have a data Var a = Var (String, [a]) so you have nothing to chain the instance off of for Show
00:46:58 <edwardk> hrmm
00:47:18 <goltrpoat> sorry, that was a somewhat ass-backwards way to put it.  let me try again:  i don't want to force the client code to declare instances of Show for every type that's being used, when chances are the client code doesn't need to pretty print anything
00:48:07 <edwardk> yeah
00:48:53 <edwardk> why forall in the data type?
00:49:16 <edwardk> can't carry an explicit Var a around?
00:49:35 <goltrpoat> nah.. need heterogeneous lists of Vars
00:49:43 <edwardk> k
00:55:57 <newsham> *sigh* no response to hawiki question
00:59:06 <goltrpoat> i guess i'll just keep Show x in there and deal with that later
00:59:41 <edwardk> well if you never need to show, then you can just strip it
00:59:59 <edwardk> but you want the ability to show if everything in it is showable, which blows up that reasoning =)
01:00:10 <goltrpoat> hehe yeah
01:00:21 <edwardk> hrmm
01:00:29 <edwardk> what about putting a different type class in
01:00:55 <edwardk> then letting that get the user showable if it has a type level boolean flag set
01:02:37 <goltrpoat> i was thinking of that, but then if they (i use the word "they" very lightly, since it's just me, and the "client code" is the other file in the project) want to pass in, say, Var ("x", [1,2,3]::[Int]), followed by Var ("y", ['a','b','c']), suddenly they have to write declare Int and Char as instances
01:02:55 <goltrpoat> er.. -write
01:03:23 <edwardk> data T; data F; class TMaybeShow a b | a -> b
01:03:37 <goltrpoat> seems like more typing on the wrong side of the interface, basically
01:04:02 <edwardk> then use something where data Var = forall x. (TMaybeshow x b) => Var (String, [x])
01:04:09 <edwardk> yeah
01:05:40 <edwardk> you could always use HList =)
01:05:42 <goltrpoat> but this is probably a better option than just arbitrarily deciding that all variable domains in a constraint program must be pretty printable
01:07:12 <goltrpoat> HList looks cool, thanks
01:22:24 <newsham> reading the monadic sectionof QuickCheckST is making my head explode
01:22:32 <edwardk> ?
01:27:45 <gour> is there some written report what happend on AngloHaskell event?
01:36:11 <ookk> do a <- newArray (1, 81) 0; return a Why does this produce this error:
01:36:12 <ookk> Ambiguous type variables `t', `a', `m' in the constraint:
01:36:12 <ookk>       `MArray a t m'
01:36:54 <edwardk> gour: heh well you can skim the logs here, but i don't recall anyone saying everything all in one place or in much detail
01:37:03 <edwardk> programmers make poor secretaries ;)
01:42:39 <JohnMeacham> What is a clever name for a haskell library involving 'packrat' 'parsing' and 'peg'?
01:43:29 <xerox> G'day.
01:43:31 <Stinger_> pregnentrat :)
01:43:57 <Stinger_> nant*
01:45:22 <Cale> ookk: It doesn't know what kind of array you want
01:46:01 <Cale> ookk: Adding a type signature is the fastest way to fix that
01:47:10 <edwardk> heya john
01:47:49 <edwardk> btw- i just wanted to mention, the PTS way of handling dictionaries in jhc is cool =)
01:49:31 <araujo> hello!
01:51:03 <dons> JohnMeacham: we have a project name generator:
01:51:05 <dons> ?fresh
01:51:05 <lambdabot> Haa
01:51:09 <dons> is one option
01:51:12 <dons> ?fresh
01:51:12 <lambdabot> Hab
01:51:12 <edwardk> ahha
01:51:15 <dons> perhaps?
01:51:17 <dons> ?fresh
01:51:17 <lambdabot> Hac
01:51:20 <dons> maybe?
01:51:44 <dons> possibly even
01:51:46 <dons> ?fresh
01:51:46 <lambdabot> Had
01:51:55 <edwardk> ou could always take those words to an anagram generator and look for something =)
01:52:19 <dons> An anagram generator would be a nice plugin!
01:52:40 <xerox> ....and a nice code to have in the library, looking to LicensedPreludeExts :)
01:52:55 <edwardk> heh
01:53:49 <Pupeno__> Good morning.
01:54:06 <Pupeno__> Does someone use any other editor that Emacs for haskelling ?
01:56:09 <dons> vim?
01:56:41 <vegai> what, no-one says 'yi'?
01:57:34 <xerox> vegai: somebody should hack in syntax highlighting
01:58:07 <xerox> (....and ghci interaction maybe? I'm not sure.)
01:58:40 <JohnMeacham> my project name generator is saying,  preobilcacil, unhesimfaur, or miucfacmo.  did I mention my project name generator is the same as my password generator?
01:59:44 <dons> heh
02:06:16 <Cale> edwardk: hey, you had the same idea I did :)
02:06:45 <Cale> prepackaging traps
02:06:59 <edwardk> ?
02:07:57 <Cale> spark capping grate
02:08:04 <edwardk> ah
02:08:25 <Cale> packaging's trapper
02:08:38 <Cale> hmm, not terribly obvious :)
02:08:48 <xerox> What are you talking about?
02:08:59 <edwardk> cale is rambling off anagrams for meacham
02:09:11 <Cale> these are anagrams for "packrat parsing peg"
02:09:43 <Cale> grape parking pacts
02:10:01 <JohnMeacham> I am going to go with 'frisby' or 'nicodemus'
02:10:49 <Cale> zomby woof
02:12:00 * edwardk looks for something less direct
02:12:24 <edwardk> the 'bryan ford clinic' sounds a little pathetic
02:12:27 <edwardk> nevermind =)
02:16:39 <dons> are there any haskell implementations that provide the keyword 'exists' for introducing existential data types?
02:16:53 <dons> or do they all reuse 'forall' in the negative position?
02:17:09 <JohnMeacham> jhc does.
02:17:15 <dons> it has 'exists'?
02:17:21 <JohnMeacham> jhc actually has support for first class existentials
02:17:39 <JohnMeacham> so (exists a . a) is a valid type that may be used anywhere another type can.
02:17:44 <dons> ok. great.
02:17:54 <dons> ?karma+ JohnMeacham
02:17:55 <lambdabot> JohnMeacham's karma raised to 1.
02:18:05 <dons> 'exists' is good
02:18:19 <dons> \footnote{For historical reasons \code{exists} is
02:18:20 <dons> written as \code{forall} in GHC Haskell.}
02:18:26 <dons> :)
02:18:30 <JohnMeacham> however, the back end can't handle it in all positions yet, it also has similar restrictions to rank-n polymorphism when it comes to type signatures.
02:18:39 <dons> yeah, fair enough
02:21:47 <xerox> No jhci ?
02:23:47 <gour> JohnMeacham: is jhc buildable without fetching libs?
02:25:25 <goltrpoat> i don't suppose there's a way to trick the typechecker into verifying that a given list is a subset of another list?
02:25:29 <goltrpoat> can't afford to do it at runtime
02:25:36 <goltrpoat> both lists come from the same module
02:26:08 <goltrpoat> and obviously both lists are known at compile time
02:27:06 <edwardk> you could do it in template haskell =/
02:27:18 <goltrpoat> yeah, but TH scares me
02:27:38 <xerox> ...or in Epigram :)
02:27:39 <goltrpoat> i really should look into it more at some point, i keep putting it off
02:27:46 <edwardk> its not really all that bad in this case
02:28:03 <xerox> edwardk: how'd one do that in TH?
02:28:25 <goltrpoat> i was gonna ask how one would do it in Epigram
02:28:25 <goltrpoat> hehe
02:28:31 <goltrpoat> not that i'm terribly familiar with it, just curious
02:28:38 <edwardk> well put in some junk code in another module that included the first, then walked each list like you would at compile time.
02:29:18 <xerox> Ah, just check if the string is a substring of some given fixed strings.
02:29:21 <edwardk> you can then fail if they don't match, coz you do TH in the Q monad.
02:29:33 <JohnMeacham> gour: if you want to build the libs yourself..
02:29:41 <edwardk> er walk each list like you would at runtimme
02:30:07 <gour> JohnMeacham: no problem, if it can do it. last few times ebuild was failing. i'll try again...
02:31:54 <JohnMeacham> gour: it is possible it is still failing, I have been modifying it a bunch recently, but am taking a break to write some parser combinators.
02:37:50 <gour> JohnMeacham: ok, i'll try anyway
02:40:19 <goltrpoat> why is it illegal to use named fields in existential types?
02:40:54 <boliver> yes
02:41:39 <dons> goltrpoat: hmm, they'd have to generate funny field acccessor functions?
02:43:12 <dons> or perhaps for the same reasons you can't pattern match in let or where on existentials
02:44:10 <goltrpoat> hmm
02:44:10 <Cale> goltrpoat: next ghc will support that
02:45:06 <goltrpoat> ah ok
02:45:20 <dons> (oh, was this something audreyt fixed?)
02:45:32 <dons> or was that accessors on GADTs?
02:45:43 <Cale> Those are related
02:46:00 <Cale> and yeah, at the very least he requested it, if not coded it himself
02:46:19 <wilx> She, now, I think...
02:46:43 <Cale> yeah, whatever :)
02:50:18 <Pupeno_> http://pupeno.com/blog-en/trying-to-find-exceptions-in-haskell/
02:50:20 <lambdabot> Title: Trying to find exceptions in Haskell &mdash; Pupeno's web site
02:52:25 <goltrpoat> importing a module compiled for 6.4 in 6.5 does the trick for me
02:53:13 <goltrpoat> (re the trying to find exceptions thing)
02:55:05 <Cale> http://www.haskell.org/hawiki/Existentially_20quantified_20record_20constructors
02:55:06 <lambdabot> Title: Existentially quantified record constructors - The Haskell Wiki
02:57:37 <Cale> Pupeno: Infinity is an IEEE floating point value
02:57:46 <Cale> Pupeno: as is NaN
02:58:01 <Cale> Pupeno: to get an exception try  head []
02:58:07 <Cale> > head []
02:58:13 <lambdabot>  Add a type signature
02:58:16 <wilx> Heh.
02:58:18 <goltrpoat> cale:  that's odd.  i'm running 6.5, and it doesn't compile that
02:58:38 <goltrpoat> "Can't combine named fields with locally-quantified type variables or context"
02:59:06 <Pupeno> Cale: thanks for the information. I didn't know that. I wrote it down because it was funny to try to generate an exception and fail (generally, the problem is the reverse, but this is Haskell).
02:59:32 <Pupeno> I haven't seen support for Infinity and NaN, even if they are IEEE floating point values, in other languages.
02:59:40 <Cale> Pupeno: I think you'll find that many programming languages are like that with regard to floats though
02:59:45 <Cale> oh, hm
03:00:22 <Pupeno> Cale: maybe we live by different languages. :P
03:01:59 <goltrpoat> the only language i can think of that will throw an exception on divide by zero is java
03:02:13 <goltrpoat> and i'm not completely sure about that one, haven't used it in ages
03:02:35 <Cale> C seems to
03:02:37 <goltrpoat> both c and c++ will happily return 1.#INF000
03:02:40 <Cale> as does python
03:02:43 <Pupeno> goltrpoat: erlang and python rise exceptions as well.
03:02:56 <goltrpoat> ah ok
03:03:09 <Pupeno> goltrpoat: common lips seems to return two values, I am not sure about the first one, the second is nil.
03:03:12 <Cale> Processor architecture probably has something to do with it at least in C
03:03:24 <Cale> whether floating point exceptions are signalling or not
03:03:34 <goltrpoat> oh, i do remember some floating point weirdness in lisp
03:03:41 <goltrpoat> and yeah cale.. quiet nans versus nans
03:03:42 <Pupeno> my mistake. common lisp raises an exception.
03:04:55 <Pupeno> DrScheme throwns an error as well (not sure if it is an exception).
03:04:56 <goltrpoat> but infinity is a well-defined value in IEEE, right..  sign bit for + or - infinity, all 1s in the exponent, all zeroes in the mantissa
03:05:34 <goltrpoat> er.  scratch that last comment, i'm not sure what i was trying to say by "well-defined".
03:06:47 <goltrpoat> i guess the point was that the distinction between QNaN and NaN seems to be specifically there to distinguish signalling vs non-signalling exceptions
03:37:10 <araujo> morning
03:37:16 <tibbe> morning
03:38:19 <boliver> araujo: are u Portuguese?
03:38:45 <araujo> boliver, no , why?
03:39:02 <boliver> it seems a Portuguese name
03:39:10 <boliver> where is it from then?
03:39:32 <araujo> oh, yeah
03:39:39 <araujo> boliver, venezuela
03:40:08 <boliver> ok :)
03:41:21 <lisppaste2> gour pasted "jhc build error" at http://paste.lisp.org/display/24430
03:41:41 <gour> JohnMeacham: fyi, it still fails ^^^
03:53:08 <basti_> hi
04:00:10 <ookk> how do i return () ?
04:00:29 <basti_> uhm
04:00:34 <basti_> () has one value which is called ()
04:00:36 <basti_> so you just write ()
04:00:57 <dons> you just: return ()
04:00:57 <ookk> i want an action that doesnt return anything just does stuff
04:01:02 <ookk> and then it has to return () i guess?
04:01:06 <dons> yep
04:01:14 <basti_> yes, if it's a monad, then you have to write "return"
04:01:19 <dons> ie.. : do something ; return ()
04:01:38 <ookk> The last statement in a 'do' construct must be an expression
04:01:39 <dons> or , if something evaluates to (), you can just write: f = something
04:01:41 <ookk> still it says that
04:01:50 <dons> maybe you're layout is messed up?
04:01:52 <dons> ?paste
04:01:52 <lambdabot> http://paste.lisp.org/new/haskell
04:02:20 <ookk> yeah i had
04:02:28 <ookk> :P
04:02:38 <dons> ok, easy to fix
04:08:21 <xerox> let ⊥ = let ⊥ = ⊥ in ⊥
04:10:14 <Cale> let ⊥ = ⊥ in ⊥
04:25:31 <dons> oh hehe: "The Mac makes it all easy ... I've had to reboot twice in two weeks, down from twice a day under Windows."
04:25:52 <dons> Hmm. so the idea of rebooting only when you upgrade hasn't quite made it there yet
04:30:09 <wilx> Why did you need to reboot twice a day on Windows?
04:30:35 <wilx> I am able to run my XP month at a time without any need to reboot.
04:30:46 <wilx> Though, I do not update too often...
04:32:31 <ookk> how can i use a if-statement withing a do-block?
04:34:21 <ibid> ookk: you just use it. what is your specific problem?
04:34:44 <ibid> it's an expression, not a statement, really, btw :)
04:35:50 <ookk> ibid, okay it gives me alot of errors
04:36:03 <ookk> so i thought it must be because of that
04:36:11 <ookk> i used if the wrong way
04:36:55 <ibid> there are tons of things that can be done wrong. which is it?? :)
04:37:08 <ibid> show the first error that is relevant here
04:37:43 <lisppaste2> ookk pasted "errors" at http://paste.lisp.org/display/24431
04:37:57 <ookk> http://paste.lisp.org/display/24431
04:38:03 <dons> then has to line up with 'else'
04:38:09 <dons> if x
04:38:11 <dons>    then y
04:38:13 <dons>    else z
04:38:19 <dons> layout rule
04:38:39 <ookk> hasnt complained about that before
04:38:40 <ibid> what dons said
04:38:54 <dons> though, hmm, your type error could be just about anything
04:38:58 <dons> want to post the code?
04:39:02 <ibid> actually, just make sure that then and else are indented more than if
04:39:18 <ibid> then and else don't have to align
04:39:26 <ibid> (they don't participate in layout)
04:39:36 <lisppaste2> ookk pasted "the_code" at http://paste.lisp.org/display/24432
04:39:42 <dons> yeah, its a convention though :)
04:39:44 <ibid> lisppaste2: indent else more than if
04:39:49 <ibid> gah
04:39:53 <ibid> ookk: ^
04:40:22 <dons> you have too many arguments to primen I think
04:40:28 <dons>                                 then primen a n radn b n sieve a b (n+1)
04:40:30 <ookk> i have used if-expression before but then it did not complain
04:40:43 <dons> but primen only takes 2 arguments, primen :: IOArray Int Bool -> Int -> IO ()
04:40:44 <ookk> primen takes two arguments
04:40:58 <dons> you're applying it to 9 :)
04:41:05 <dons>  primen a n radn b n sieve a b (n+1) should be hmm,
04:41:07 <ookk> i had each call to primen and radn on separate row
04:41:17 <ibid> ookk: the point is that in do, if you align the else with the if, else begins a new command, which is not allowed
04:41:25 <ookk> but then you said i shoud have expressions of type then x; else y
04:41:56 <dons> " primen a n radn b n sieve a b (n+1)" is wrong. you're misssing either ; or separate lines.
04:42:06 <dons> should that not be:
04:42:09 <dons>   
04:42:10 <lisppaste2> ookk pasted "still_complains" at http://paste.lisp.org/display/24433
04:42:13 <dons>   radn b n
04:42:19 <dons>   sieve a b (n+1)
04:42:20 <dons> ...
04:42:33 <ibid> ookk: you need do in then too
04:42:38 <ookk> yes i did that first
04:42:42 <dons> and 'do', yes.
04:42:54 <dons> yep, you're missing a 'do' now, after 'then'
04:42:57 <ookk> ahh now it worked :)
04:43:08 <ibid> ookk: think of do ... as { ... } in Java, or begin ... end in pascal
04:43:11 <dons> since you're opening up a new monadic block, you need to start with 'do'
04:43:11 <ookk> i though it was enough with the upper do?
04:43:32 <ookk> do returns an action? and if branches between two actions
04:43:49 <ibid> ookk: think of do as a block
04:43:51 <ookk> so therefore i have to have one action in then and one action in else
04:44:27 <ibid> ookk: do just combines actions into one action
04:44:31 <dons> ook, you might be interested in http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsieve&lang=all
04:44:32 <lambdabot> Title: nsieve benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language S ...
04:44:47 <ibid> ookk: and therefore is like Java's {...} blocks
04:45:10 <ookk> okay
04:45:25 <ookk> dons, i want to generate an array of values for the radical function
04:45:45 <ibid> ookk: in Java you need {...}'s if you want to put more than one statement in then or else, you need do if you want to put more than one command in then or else in Haskell
04:46:05 <ookk> ibid, yeah do is like a composition function?
04:46:12 <ookk> that takes two actions and combines them to one?
04:46:24 <dons> its just syntax for opening up a monadic block
04:46:28 <ibid> ookk: yes, sequential composition
04:46:31 <dons> >>= is syntax for combining actions though
04:46:37 <ibid> ookk: not a function but syntactic sugar
04:46:42 <ookk> at least it works now and i know why, thx :)
04:46:52 <ibid> ookk: it's rather like (begin ...) in scheme
04:46:57 <ookk> okay
04:47:33 <ibid> ookk: of course, as dons says, do is just syntactic sugar, but you can pretend it isn't most of the time :)
04:47:35 <dons> I'm glad they chose 'do' and not 'begin' or 'start' or 'proceed-from-here' or ...
04:47:52 <ookk> hehe
04:48:32 <ibid> but shopping time, bbl
04:49:42 <ookk> an IOArray is like an array in C?
04:49:55 <ookk> it doesnt copy itself to make changes?
04:50:30 <dons> its not mutable anyway
04:50:39 <ookk> and when i pass it to functions i just pass a reference to the array not a copy of the array?
04:50:57 <dons> yep
04:51:01 <ookk> so write isnt O(1) ?
04:51:31 <dons> hmm. it isn't?
04:51:34 <bourbaki> moin
04:51:41 <ookk> i was just wondering
04:51:52 <ookk> it should be like a C array because it is of type IO
04:52:05 <ookk> that enables it to change itself
04:52:20 <ookk> and then i should, cause otherwise there would be no point in it beeing of type IO
04:52:31 <ookk> if it just made copies of itself to change a value
04:52:51 <ookk> wich is O(n) to write a value which is bad
04:54:19 <eivuokko> Anyone here familiar with ghc garbage collector?  Would it be hard to make it return memory to OS?
04:54:59 <JohnMeacham> gour: I am not sure what is running jhc there, but that is not where the libraries have been for a while.
04:58:25 <ookk> it is almost 100x slower then my implementation in C++
04:58:36 <ookk> and there i use two arrays in the same way
05:00:01 <basti_> ookk: what are you trying to do?
05:00:21 <ookk> produce an array with 100000 values of the radical function
05:00:35 <basti_> "radical function"?
05:02:14 <ookk> the product of the unique prime factors of n
05:02:31 <ookk> so rad(2*5*5) = 2*5
05:02:37 <basti_> ah ok
05:02:45 <basti_> did you profile your program?
05:03:25 <ookk> nope
05:03:33 <basti_> i'd try that before complaining ;)
05:04:57 <bourbaki> hi basti_
05:05:32 <ookk> basti_, that just tells me how much % the main module has used
05:05:42 <ookk> wich is 100%
05:05:50 <basti_> ookk: no it doesn't you, just have to give a few options
05:05:58 <basti_> theres one that gives you everything
05:06:09 <ookk> which one is that?
05:06:15 <basti_> phew.
05:06:39 * basti_ looks up
05:06:56 <basti_> ghc -prof -auto-all
05:08:13 <ookk> still only gives me the % for main
05:08:31 * basti_ wonders
05:08:41 <ookk> ghc <file>.hs -prof -auto-all -o <file>
05:08:50 <ookk> ./<file> +RTS -p
05:09:04 <basti_> yea that ought to do it...
05:09:05 <ookk> then when i cat <file>.prof only main statistics is there
05:09:10 <basti_> strange
05:10:22 <basti_> anyone?
05:11:06 <basti_> ookk: i'm not sure what the problem is
05:11:56 <basti_> ookk: would you maybe send me your code?
05:12:08 <ookk> ?paste
05:12:09 <lambdabot> http://paste.lisp.org/new/haskell
05:12:40 <lisppaste2> ookk pasted "radicals" at http://paste.lisp.org/display/24434
05:12:58 <basti_> letsseeee
05:13:01 <ookk> basti_, my implementation in C++ takes ~20ms
05:13:10 <ookk> and it does the exact same thing to two arrays
05:13:57 * basti_ has a look
05:14:09 <ookk> im calculating the radicals while doing a simultainious sieve of erasthotenes (or how it is spelled)
05:14:50 <basti_> @info unsafeRead
05:14:51 <lambdabot> Unknown command, try @list
05:14:53 <basti_> ..
05:14:56 <basti_> where is that?
05:15:16 <ookk> i uesd readArray and writeArray first, but then i tried unsafe*
05:15:28 <basti_> i need to import it, though, to compile your program
05:15:33 <ookk> beacuse they used that in the programing language shootout for the prime sieve
05:15:39 <xerox> basti_: @info left us eons ago
05:15:46 <ookk> import Data.Array.IO
05:16:01 <basti_> Data.Array.Base obviously
05:16:11 <xerox> ?index unsafeRead
05:16:12 <lambdabot> bzzt
05:16:18 <xerox> ?hoogle unsafeRead
05:16:19 <lambdabot> No matches found
05:17:00 <basti_> i get 4 lines of info in the profile
05:18:03 <ookk> hmm now i get a complete profile
05:18:03 <basti_> that is more than just the info about "main"
05:18:23 <ookk> i wonder if it thought that it didnt need to compile the binary when i updated the parameters?
05:18:57 <ookk> so radn is the sloppy function
05:19:16 <basti_> maybe, yea
05:19:33 <basti_> you could introduce a few more cost centers
05:19:37 <basti_> to get a better look
05:20:14 <ookk> that is beacuse it both reads and writes to the array
05:20:19 <ookk> and that seems to be dog slow
05:21:24 <basti_> did you try compiling in optimisations?
05:21:56 <ookk> no im not aware of what optimisations there are in ghc yet
05:22:02 <basti_> -O2 eg
05:22:06 <ookk> i have only used haskell a week
05:22:08 <ookk> okay
05:22:19 <ookk> same as gcc then
05:22:34 <basti_> yea
05:22:34 <ookk> i hate that is says compilation is NOT required
05:22:40 <ookk> even though i change the flags
05:24:19 <ookk> because i think compilation is required
05:24:24 <basti_> isn't terribly effective anyway lol
05:24:32 <ookk> nope
05:24:39 <ookk> 20ms in C++
05:25:19 <ookk> is there any way to force compilation? i cant find any flag for it
05:25:38 <eivuokko> -no-recomp
05:25:40 <ookk> because ghc refuses to recompile my code even though i change the flags of ghc
05:25:48 <ookk> thx
05:25:48 <eivuokko> Short for no recompilation checking
05:25:48 <basti_> now try IOUArray instead of IOArray
05:25:56 <basti_> how's that.
05:26:04 <ookk> with O3 it runs in 343ms
05:26:34 <basti_> and with O3 and IOUArray?
05:26:46 <ookk> not much faster
05:26:53 <ookk> 10ms faster perhaps
05:27:09 <ookk> 15x slower then C++ then
05:27:30 <sieni> ookk: optimization in haskell: http://users.aber.ac.uk/afc/stricthaskell.html
05:27:30 <lambdabot> Title: Making Haskell programs faster and smaller
05:27:33 <ookk> more reasonable but i think haskell could be faster
05:27:37 <sieni> ookk: optimization in ml: http://www.hurmio.org/~ville/strictml.html
05:27:37 <lambdabot> Title: Making ML programs faster and smaller
05:27:51 <basti_> now you can still unbox other stuff
05:29:08 <ookk> hmm
05:29:44 <basti_> the point is: you should optimize as late as possible, and as few as possible, to maintain maximal flexibility
05:30:22 <basti_> if maximum speed is what you desire, use bareback C
05:30:56 <basti_> there is no other way
05:31:37 <basti_> unboxing the array indices might help, for example
05:31:55 <ookk> im not familiar with "unboxing"
05:32:19 <sieni> you can also write speed critical parts in c and call them from haskell using the ffi
05:32:30 <basti_> well, basically every haskell value is a pointer to the real value
05:32:50 <ookk> ultimate speed is not my goal, i just want to see what minimal efforts can speed this program up
05:32:57 <basti_> you can stop this behaviour with "unboxing" which comes down to writing # after (or before) the types of the values you intend to unbox
05:32:58 <sieni> ookk: http://en.wikipedia.org/wiki/Boxing_%28Computer_science%29
05:33:02 <ookk> i still like that it takes less effort to code something in haskell
05:33:42 <ookk> so n :: #Int?
05:33:50 <basti_> #Int iirc yes
05:33:56 <ibid> Int#
05:34:00 <basti_> Int# ok
05:34:07 <basti_> I can never remember this stuff :(
05:34:49 <ookk> that reduced it another 10ms
05:35:03 <basti_> then maybe unbox the contents too
05:36:55 <ookk> 15ms gain with all unboxed vs all boxed
05:37:15 <basti_> sad :|
05:37:21 <ookk> on the other hand i was running it with profiling on *doh*
05:37:31 <ookk> 170ms without profiling on :P
05:37:53 <basti_> how fast was C++ again?
05:37:56 <ookk> that is quite acceptable
05:38:01 <ookk> 20ms
05:38:19 <basti_> k
05:38:25 <basti_> x 8.5
05:38:38 <basti_> would certainly be acceptable, i think, too.
05:38:51 <basti_> I'm sure some of the speedup experts in here could help even more
05:38:57 <ookk> maybe there is a better function then mapM_ to write the values inte to array?
05:39:10 <ookk> mapM_ (\i -> unsafeWrite a (n*i) False) ([2*n,3*n..m] :: [Int#])
05:39:23 <basti_> i think mapM should be quite fast
05:39:42 <basti_> i think there's a mapArray or something too
05:40:05 <ookk> but i want to map actions to an array of Int#
05:40:14 <ibid> hm, [Int#] shoud not be possible
05:40:17 <ibid> +l
05:40:17 <ookk> and the actions does writes on those positions in the array
05:40:31 <ibid> iirc unboxed stuff cannot be put in polymorphic containers
05:40:31 <ookk> it compiles
05:40:41 <ibid> ok
05:40:43 <ibid> nice, then :)
05:41:01 <basti_> hmm
05:41:07 <ibid> you're using IOArray?
05:41:15 <ookk> IOUArray
05:41:31 <ibid> nice
05:41:55 <basti_> ok ibid now you'll help him optimize even more ;)
05:41:57 <gour> JohnMeacham: then it must be something is wrong with the ebuild itself
05:42:05 * xerox growls at the spam on the summer-of-code trac
05:42:13 <ibid> hm, why unsafeWrite?
05:42:20 <xerox> I cleaned it up but it still shows up in the RSS reader if you pulled the rss before the cleaning.
05:42:26 <xerox> ....which is annoying.
05:42:28 <ookk> ibid, i think it is faster
05:42:34 <ookk> ?paste
05:42:35 <lambdabot> http://paste.lisp.org/new/haskell
05:42:44 <lisppaste2> ookk pasted "the_code" at http://paste.lisp.org/display/24435
05:43:11 <ibid> ookk: faster than writeArray?
05:43:57 <ookk> ibid, yes and the reason for that is that they used unsafe* in the programming language shootout
05:44:05 <ookk> for their prime-sieve
05:44:14 <ookk> so i guess it got to be faster
05:44:45 <ibid> did you measure the difference?
05:45:24 <ookk> not with the latest optimizations
05:45:34 <ookk> but when i changed it it got a litte faster
05:46:17 <ookk> now there doesnt seem to be any difference
05:46:29 <ookk> actually read/write Array seems to be faster
05:46:42 <ibid> what else imports do you use?
05:46:57 <ibid> i can't compile that as is :)
05:46:57 <ookk> nothing
05:47:04 <ibid> what command line?
05:47:24 <ookk> bash
05:47:30 <ookk> everything is in what i pasted
05:47:31 * basti_ needed import Data.Array.Base
05:47:36 <ookk> import Data.Array.IO
05:47:41 <basti_> i don't know why ookk can compile it as-is
05:47:42 <ibid> ookk: what compiler command line
05:47:58 <ookk> what do you mean?
05:48:14 <ibid> hrm
05:48:16 <basti_> ookk: your program doesn't compile as-is, not for me and not for ibid
05:48:22 <basti_> ibid: import Data.Array.Base
05:48:28 <ibid> ookk: how do you call the compiler!
05:48:34 <ookk> ghc <file>.hs -no-recomp -O3 -o <file>
05:48:36 <ibid> ookk: what command-line options etc
05:48:41 <ibid> hm
05:48:58 <ibid> not even -fglasgow-exts?!
05:48:58 <ookk> ~/Documents/Haskell > ghc --version
05:48:58 <ookk> The Glorious Glasgow Haskell Compilation System, version 6.5.20060608
05:49:01 <ookk> nope
05:49:24 <ibid> 6.5, eh?
05:49:25 <ookk> what version do you guys have?
05:49:32 <ibid> the latest in debian unstable
05:49:44 <ibid> Glasgow Haskell Compiler, Version 6.4.1, for Haskell 98, compiled by GHC version 6.4.1
05:49:57 <basti_> 6.4.1 too
05:50:10 <ookk> hmm
05:50:16 <basti_> maybe that's the reason
05:50:19 <ibid> ookk: i'd recommend using a stable compiler for production coding
05:50:19 <ookk> i installed my ghc via darwinports
05:50:35 <ookk> ibid, there isnt another for intel-macs
05:50:58 <ookk> and i dont do any productions coding :)
05:51:08 <ookk> this i my idea of fun :P
05:51:16 <ookk> im just testing haskell
05:51:21 <ibid> hrm
05:51:47 <ibid> ookk: i call anything that isn't hacking on the compiler itself 'production coding' :)
05:52:08 <ookk> hehe
05:52:09 <basti_> people on here routinely modify their compilers you know...
05:53:04 <ibid> Bool#?
05:53:08 <ibid> where is that defined?
05:53:15 <xerox> GHC.Prim ?
05:53:16 <dons> primitive?
05:53:19 <xerox> ?index Bool#
05:53:19 <lambdabot> bzzt
05:53:30 <ibid> not in GHC.Exts at least
05:53:39 <dons> there's no Bool# is there?
05:53:49 <dcoutts> primitives are not defined in Haskell
05:53:51 <dons> primop   IntLtOp  "<#"   Compare   Int# -> Int# -> Bool
05:53:59 <dons> i.e. even the primops refer to Bool
05:54:02 <dcoutts> they are magically said to be exported from GHC.Prim
05:54:17 <ibid> dcoutts: obviously
05:54:18 <dcoutts> yes data Bool = True | False
05:54:26 <dcoutts> there is no Bool#
05:54:30 <ookk> hmm i compiled another version of the file *DOH*
05:54:35 <dons> yeah, so there is no Bool#, but the Bool type is semi-wired in anyway
05:54:38 <ookk> so # does in fact not work
05:54:39 <ibid> ookk: can't help you as i can't compile that
05:54:56 <ookk> sorry guys i was wrong when i said that Int# compiled
05:55:08 <ookk> i accidentally didnt change the new version of the file
05:56:11 <ookk> i will paste the correct version
05:57:17 <ookk> ?paste
05:57:17 <lambdabot> http://paste.lisp.org/new/haskell
05:57:25 <lisppaste2> ookk pasted "correct" at http://paste.lisp.org/display/24436
05:57:50 <ookk> that runs in 149ms
05:58:03 <ookk> optimization flags seems to do alot more to haskell code then c++ code
05:58:25 <ibid> that's not surprising
05:58:37 <ibid> there is much more room for optimization:)
05:58:40 <ookk> yeah haskell code is alot more high level
06:01:39 <ibid> ookk: simply doing s/IOArray/IOUArray/ makes that code a lot faster here
06:02:10 <ookk> ohh damn, here to :)
06:02:17 <ookk> from 159ms to 28ms
06:02:25 <ookk> that is C++ speed :)
06:02:31 <ookk> with much shorter code
06:02:36 <ookk> C++ -O3 speed :)
06:02:40 <ibid> fast enough?
06:02:53 <ookk> yeah im satisfied :)
06:02:59 <ibid> good :)
06:03:13 <basti_> :D
06:03:26 <ookk> when i started it ran in 2s
06:03:57 <ookk> and the optimizations didnt clutter the code
06:04:23 <ibid> btw, the two type ascriptions in main are redundant
06:04:31 <ibid> you can remove both
06:04:37 <Igloo> It'll probably be a lot faster with unsafe array reading and writing (doesn't do bounds checking)
06:05:35 <ookk> okay
06:05:40 <ibid> where is that defined?
06:05:42 <ookk> i do the bounds cheking myself
06:05:54 <ookk> what is the difference between IOUArray and IOArray?
06:05:56 <basti_> what did the trick now ook?
06:05:59 <basti_> k
06:06:11 <ibid> ookk: IOArray elements are boxed
06:06:22 <ibid> ookk: IOUArray elements are "bare metal"
06:06:59 <ookk> basti_, IOUArray
06:07:02 <ibid> ookk: the compiler can optimize away a lot of boxing, but i doubt it can do that to containers, so it helps here
06:07:10 <basti_> didn't i tell you to use IOUArray? ^^
06:07:28 <Igloo> Data.Array.Base.unsafeRead / Data.Array.Base.unsafeWrite (the first element in the array is 0, the nex 1, and so on, so it looks like you'll have to subtract 1 all over the place)
06:07:32 <ookk> unsafeRead/Wirte was 22ms, read/writeArray was 28ms
06:07:36 <ookk> basti_, hehe yeah
06:07:49 <ookk> basti_, but i was compiling an old version of the file then that i didnt change :P
06:07:54 <ookk> basti_, so my bad there
06:07:57 <basti_> lol
06:08:25 <ibid> hm, no Data.Array.Base in library docs?
06:08:44 <ookk> Igloo ok
06:10:21 <dcoutts> ibid, no, it's hidden.
06:10:27 <dcoutts> to stop people abusing it :-)
06:10:35 <dcoutts> you can look at the code though
06:10:42 <ibid> dcoutts: ah
06:11:01 <ibid> dcoutts: why not hide all unsafe* stuff, then? ;)
06:11:31 <dcoutts> :-)
06:12:17 <dcoutts> I think it's mostly to not make the internals too public, but allow them to be used if you're extending the interface to add your own array types or need unsafe indexing
06:13:17 <ibid> unsafeWrite and usafeRead could be visible :)
06:14:24 <shapr> Dang, I had a question...
06:14:33 <dcoutts> ibid, true, though they're not drop-in replacements for arrayRead/arrayWrite
06:14:53 <dcoutts> as they take Int offsets rather than Ix i indexes
06:15:07 <dcoutts> shapr, log off again, it'll come back to you :-)
06:15:20 <ibid> dcoutts: so document it :)
06:15:39 <dcoutts> ibid, suggest it on the libs list when JaffaCake gets back.
06:15:41 <shapr> Probably true.
06:15:53 <ibid> dcoutts: too much work, that :)
06:15:57 <dcoutts> hah hah
06:16:04 <dcoutts> just complain here :-)
06:16:10 * ibid is just vacuuming cats here
06:16:22 * ibid should be writing fencore/toy M2
06:16:22 <dcoutts> right'o, as you do
06:16:54 <shapr> Oh I remember, I'm writing some shell scripts in Haskell and wondering about the best way to fork off a shell command and exit.
06:17:03 <ookk> Igloo, unsafeRead/Write produces the same list of radicals as read/writeArray
06:17:16 <ibid> radicals?
06:17:41 <ookk> ibid, rad(2*5*5) = 2*5
06:17:48 <ookk> the product of unique prime factors of n
06:18:01 <dcoutts> shapr, runProcess then exit ?
06:18:13 <dcoutts> oh, shell, use runCommand
06:18:16 <shapr> ok
06:18:32 <dcoutts> it doesn't wait for it to terminate
06:46:48 <shapr> What's the fix for this error? (50) (warning/warning) Error caught in `font-lock-pre-idle-hook': (error No such face haskell-default-face)
06:47:27 <sieni> install a package that installs haskell-default-face :-)
06:47:27 <dcoutts> use vim?
06:47:47 <shapr> :-P
06:49:10 <sieni> use java instead of haskell?
06:49:59 <dcoutts> heresy! heresy!
06:51:56 <xerox> shapr: have you (required 'haskell-mode) ?
06:53:37 <xerox> shapr: $ tar -xzf xhtml-2006.7.5.tar.gz xhtml-2006.7.5/xhtml.cabal  $ mv xhtml-2006.7.5 xhtml  $ mv xhtml-2006.7.5.tar.gz xhtml  I'm adding all hope dependencies :)
06:56:13 <ookk> ?paste
06:56:13 <lambdabot> http://paste.lisp.org/new/haskell
06:56:21 <lisppaste2> ookk pasted "what is wrong?" at http://paste.lisp.org/display/24439
06:56:35 <ookk> Couldn't match expected type `Int' against inferred type `Maybe a'
06:56:42 <ookk> In the first argument of `return', namely `Nothing'
06:57:04 <ookk> if i change to IO Maybe Int
06:57:12 <ookk> it complains about IO having to many arguments
06:58:35 <kpreid> you have to write IO (Maybe Int), just like f (g x)
06:58:37 <ookk> gah i was using doing a <- unsafeRead a n
06:58:51 <ookk> i fixed it now thx anyway :)
06:59:06 <dcoutts> shapr, yeah, ghc-smp would be fun on a machine like that. The sun 32-way-on-a-chip would be fun too, and slightly more afordable.
06:59:19 <dcoutts> but out of the range of a fun budget though
06:59:58 <Stinger_> hmm my tour of the haskell syntax link has disappeared : /
07:00:02 <dcoutts> but if you ever get a contract for a haskell web app that needs >=16 cpus then the sparc or mips things might be fun
07:00:15 <dcoutts> ghc works ok on sparc, mips is a bit dodgy
07:12:30 <lisppaste2> luis pasted "YAHT -- Guess.hs example" at http://paste.lisp.org/display/24440
07:13:08 <luis> Any tips?
07:14:28 <dcoutts> indent the then and else
07:14:35 <dcoutts> if foo > bar
07:14:37 <dcoutts>   then ...
07:14:41 <dcoutts>   else
07:15:05 <luis> Hmm, haskell-mode won't indent it any further. Any idea why?
07:15:11 <dcoutts> luis, otherwise it looks like another command in the do block
07:15:37 * dcoutts knows nothing about emacs
07:16:33 <luis> dcoutts: what do you use to write haskell code?
07:16:35 <Stinger_> haskell mode gets it wrong sometimes :(
07:16:51 <dcoutts> luis, nedit and vim
07:16:55 <dcoutts> mostly nedit
07:16:58 <luis> dcoutts: ok, thanks.
07:17:15 <luis> dcoutts: outside a do block though, is that if ... then ... else indentation correct?
07:17:37 <dcoutts> outside of a do or let, yeah
07:17:44 <dcoutts> but just get used to indenting it that way
07:17:48 <dcoutts> it'll save pain
07:17:53 <luis> Ok, that's what I wanted to know.
07:17:55 <luis> Thanks.
07:18:12 <dcoutts> or the other commong style is:
07:18:24 <dcoutts> if foo > bar then ...
07:18:31 <dcoutts>              else ...
07:18:55 <dcoutts> or even all one one line sometimes if it's short
07:20:16 <luis> dcoutts: thanks
07:22:11 <ookk> how can i do this?: do x <- [1..100]; y <- [x..100]; print (x,y)
07:22:50 <xerox> mapM_ print [(x,y) | x <- [1..100], y <- [x..100]]
07:23:16 <ookk> okay thx!
07:24:02 <dons> ?remember JohnHughes I would guess that the majority if compiler runs for beginners (and perhaps for the rest of us too!) end in a type error
07:24:03 <lambdabot> Done.
07:24:23 * dons `really` sleep
07:24:23 <ookk> how can i write long haskell lines in several lines?
07:24:39 <xerox> s/if/of/ ?
07:24:44 <dons> ookk: just break it up however you like, and indent further to the right each time
07:24:53 <ookk> okay
07:24:53 <dons> xerox: ah yes. typo in john's mail
07:25:12 <dons> some
07:25:13 <dons>    long
07:25:16 <dons>          line
07:28:57 <ookk> xerox, that is alot slower then my previous solutions where i had a recursive function for each level x,y
07:29:08 <midfield> dons: I'm trying to modify the Binary file to write to ForeignPtrs, for easy converstion to / from ByteStrings.  Should my BinHandle take a ForeignPtr or a !ForeignPtr?
07:29:13 <ookk> it has to create that big list and then map it
07:29:31 <ookk> and acctually im not doing print im doing read and write to an array
07:29:33 <xerox> unsafeInterleaveIO?
07:29:55 <ookk> xerox, what is that?
07:29:59 <xerox> Lazy IO
07:30:18 <dons> you could sequence in the list comprehension
07:30:28 <xerox> Isn't it the same?
07:30:36 <xerox> sequence [print (x,y) | ...]
07:30:41 <dons> sequence_ [ unsafeWrite arr i n | (i , n) <- zip [1.100] [1..100] ]
07:30:44 <ookk> i have a strict increasing function f(x,y,z,n) and i want to evaluate its integer solutions
07:30:49 <Stinger_> whats a fn for justifying text?
07:30:57 <ookk> so i loop thorugh x,y,z,n and add solutions to an array
07:31:13 <ookk> previously i had 4 recursive functions for each level of x,y,z
07:31:14 <dons> you'll probably get better code using an explicit loop though
07:31:15 <ookk> n
07:31:29 <dons> (I think that's what we found in the shootout nsieve entry)
07:31:55 <dons> though the issues with mapM_ have been fixed since, iirc
07:31:57 <ookk> how do i make 4 nestled loops then?
07:32:26 <dons> the usual way
07:32:38 <ookk> ?paste
07:32:39 <lambdabot> http://paste.lisp.org/new/haskell
07:32:39 <dons> its just an extension of a normal recursive loop, right?
07:32:47 <lisppaste2> ookk pasted "blah" at http://paste.lisp.org/display/24441
07:33:06 <ookk> solutions2 runs in 800ms while solutions runs in 80ms
07:33:08 <dons> hmm. looks like lots of repeated code
07:33:18 <dons> ah
07:33:24 <ookk> yes that is why im trying to write solutions2
07:33:29 <ookk> but it is 10x slower
07:33:46 <dons> oh sure. all those wacky list comprehensions
07:33:52 <dons> why bother with that?
07:34:20 <ookk> how could i do it then?
07:34:26 <ookk> without having 4 recursive functions
07:35:01 <ookk> i dont want to create a list
07:35:05 <ookk> and solutions2 does that
07:35:14 <dons> right. you want to thread a parameter around a bunch of loops
07:35:15 <midfield> dons?
07:35:20 <ookk> is there any way to loop through x,y,z,n without creating a list first?
07:35:58 <ookk> i want to look through all values x,y,z,n where x<=y<=z and f(x,y,z,n) <= M
07:36:06 <ookk> and f is increasing
07:36:52 <basti_> ookk: you could recurse
07:37:08 <ookk> basti_, that is what i did
07:37:21 <ookk> i made 4 recursive functions solutions solutions' solutions'' solutions'''
07:37:34 <ookk> but that is kind of bloated
07:37:49 <dons> you should make a higher order 'solutions' function instead then
07:37:56 <dons> and parameterise it on the code that differs
07:38:11 <dons> since each of those loops is almost identical
07:38:40 <dons> instead, pass it the functions it needs to compute the 'then' arm
07:38:48 <dons> and perhaps use 'when' instead of 'if then else'
07:38:56 <petekaz> dolio: re: maybe monad, thanks, I figured that out.  I was really tired last night.
07:39:19 <ookk> what does when do?
07:39:22 <petekaz> dolio: once I thought about the non-do notation, then it was obvious to me.
07:39:37 <dons> solutions a n = when (layer 1 1 1 n <= limit) $ do
07:39:37 <dons>       solutions a (n+1)
07:39:37 <dons>       solutions' a 1 n
07:39:47 <dons> is a start
07:40:59 <ookk> not in scope when
07:41:05 <dons> ?hoogle when
07:41:06 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
07:41:06 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
07:41:07 <dcoutts> nah, one should just write in the high level style and let the compiler deforest for you, right dons :-)
07:41:17 <dons> right :)
07:41:40 <dons> ookk: now, solutions .. solutoins'' are almost identical
07:41:44 <dons> so factor out the differences
07:42:49 * dons $!! sleep
07:42:55 <dcoutts> quite
07:43:16 <ookk> i was thining if it is possible to do: do x <- [..]; y <- [..] ... writeArray blah
07:45:01 <shapr> dcoutts: Is a Niagara system with 2gb of ram cheaper than $3k USD?
07:45:10 * dcoutts checks
07:46:26 <shapr> xerox: Hey that's cool, is hope cabal-get'able now?
07:46:42 <xerox> All of its dependencies are, if I did things correctly.
07:46:51 <xerox> I am still adding packages, hdbc & friends now.
07:46:59 <shapr> I'm hacking on hope right now, trying to put together a commercial website for a friend.
07:47:20 <shapr> It's troublesome to build a bunch of static pages.
07:47:21 <xerox> shapr - OTOH one would probably only want to fetch hope, not install it automatically, it needs configuration
07:47:38 <shapr> Yeah, true
07:47:49 <xerox> I don't even know if it is cabalized...
07:52:55 <dcoutts> shapr, no, they're $3k
07:52:59 <dcoutts> starting at
08:16:14 <gour> is someone doing some work in the Hajax field?
08:20:24 <xerox> Puff, pant.
08:20:33 <xerox> gour: the SoC project HSP.ClientSide, maybe?
08:21:20 <gour> xerox: thanks, i'll take a look
08:27:06 <gour> xerox: although i'd like to avoid javascript and have support like the one described in wiki
08:27:37 <dcoutts> hia gour, long time no see
08:27:43 <xerox> G'day ski
08:27:57 <dcoutts> gour, btw if you want to keep your haskell.org account you'll need to say so
08:28:04 <ski> hiya xerox
08:28:11 <xerox> dcoutts: that is not monk, right?
08:28:25 <dcoutts> nope
08:28:32 <xerox> OK.
08:31:48 <gour> dcoutts: hi, well, busy with other things
08:32:33 <gour> dcoutts: i also had problems with mail server and receiving list's messages (some romanian left some trojan on the server)
08:32:48 <gour> dcoutts: what about haskell.org account?
08:33:30 <dcoutts> gour, http://haskell.org/haskellwiki/Haskell.org
08:33:31 <lambdabot> Title: Haskell.org - HaskellWiki
08:35:56 <xerox> Do you have any Haskell software you would like to cabal-get easily?
08:37:14 <dcoutts> ghc
08:37:21 * dcoutts grins
08:37:21 <xerox> Yuck.
08:37:25 <eivuokko> Anyone in Windows and would care to test my memory allocator patch for ghc rts?
08:37:31 <xerox> Little cute software.
08:37:36 <xerox> @version
08:37:37 <lambdabot> lambdabot 4p72, GHC 6.4.2 (Linux i686 2.80GHz)
08:37:37 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
08:37:50 <dcoutts> eivuokko, oh, well done. How did you fix it?
08:38:03 <eivuokko> dcoutts, Brute force? o.O
08:38:09 <dcoutts> heh
08:38:21 <gour> dcoutts: thanks. done
08:38:22 <eivuokko> Just writing the c that keeps enough info around...
08:38:28 <dcoutts> so windows now uses the MBlock stuff now
08:38:41 <dcoutts> where it previously used a fixed 256Mb heap?
08:38:43 <eivuokko> Well, if my patch is accepted, yeah.
08:38:45 <xerox> Hm, how does lambdabot keep track of its darcs-version-number?
08:38:51 <xerox> That's interesting.
08:40:38 <eivuokko> Ah, that reminds me.  Ghc should have --exact-version like darcs has...showing the context where it was built from.  Mmmm...easy to add, but requires building source distro and checking that it works...yuck Makefile stuff again.
08:41:42 <xerox> -rw-r--r--   1 paolo  paolo     2286 Aug 20 17:40 lambdabot-4.0.cabal
08:41:42 <xerox> -rw-r--r--   1 paolo  paolo  1968955 Aug 20 17:40 lambdabot-4.0.tar.gz
08:41:43 <xerox> :D
08:42:02 <eivuokko> Mhm
08:42:37 <eivuokko> xerox, How can I submit packages? :-)
08:42:46 <xerox> I am asking for them!
08:43:10 <mnislaih> ping Lemmih
08:44:25 <lispy> moin moin
08:44:43 <lispy> xerox: likely a post apply hook
08:45:32 <lispy> guess it could also be part of the make file...
08:45:43 <xerox> dcoutts: where is fps-0.8 ?
08:45:48 * gour wonders what is the preferred rss reader program here . liferea crashes way too often :-(
08:45:57 <dcoutts> xerox, darcs
08:46:09 <xerox> gour: I use NewsFire, but it's probably not what you want :P
08:46:13 <eivuokko> darcs isn't Cabalised :-(
08:46:19 <dcoutts> http://www.cse.unsw.edu.au/~dons/code/fps-unstable
08:46:19 <lambdabot> Title: Index of /~dons/code/fps-unstable
08:46:35 <xerox> eivuokko: :-| anything else?
08:47:02 <pmurias_> any yhc people around?
08:47:08 <lispy> eivuokko: nope, but the makefile should be pretty robust
08:47:20 <eivuokko> You're kidding, right?
08:47:24 <gour> xerox: mac only?
08:47:26 <lispy> eivuokko: but i'd like to see it cabalized too
08:47:36 <xerox> gour: right
08:47:38 <eivuokko> It's one of the most broken autotools projects I have seen! (Windows-wise atleast)
08:47:46 <lispy> eivuokko: no, its makefile has worked for me on sox, windows, linux and solaris
08:48:00 <lispy> s/sox/osx/
08:48:03 <eivuokko> Let me guess, you copied headers and libraries to your ghc distro?
08:48:08 <gour> xerox: i need something from portage-tree ;)
08:48:10 <lispy> no
08:48:28 <lispy> but i guess i haven't built it on windows for several versions
08:48:31 <lispy> maybe things have changed
08:48:35 <xerox> gour: firefox has sage as an extension
08:48:41 <eivuokko> Heh, I don't udnerstand how you can say it's robust then.  It breaks even if paths have / after them or PATH has spaces
08:48:46 <lispy> eivuokko: if you cabalize it, i will accept the patches to the branch i maintain
08:48:49 <xerox> gour: thunderbird has rss functionality too (it has many functionalities in fact)
08:48:57 <eivuokko> lispy, Ehm, well
08:49:00 <lispy> eivuokko: huh
08:49:11 <lispy> eivuokko: i've never had that problem :)
08:49:18 <eivuokko> lispy, I might work on darcs iff someone respodes my mails on cabal-devel
08:49:32 <lispy> ah
08:49:35 <eivuokko> lispy, Took me 20mins to get configure right :-)
08:49:36 <gour> xerox: i'd prefer some stand-alone 'cause epiphany is my default browser. liferea is nice but too unstable
08:49:57 <lispy> eivuokko: probably just due to neglect on win32 then
08:50:10 <eivuokko> lispy, Right.
08:50:27 <eivuokko> But my patch was for ghc 6.6/base 2.0 issues :-)
08:50:36 <eivuokko> Should be the same in all platforms
08:50:39 <xerox> gour: try straw
08:50:43 <lispy> eivuokko: i see
08:51:01 <lispy> eivuokko: imo, darcs isn't being maintained very well of late
08:51:05 <eivuokko> lispy, Might be I just write offensive mails or something.  I have this problem often.
08:51:24 <lispy> which problem?  autotools projects suck on win32?
08:51:40 <eivuokko> That my mails on Windows issues don't get attention :-)
08:51:48 <lispy> ah
08:51:55 <xerox> Awwww
08:51:58 <xerox> Yi isn't cabalized!
08:52:11 * gour will try straw
08:52:12 <xerox> I wanted to make a surprise and enable people to cabal-install yi, yarr :D
08:52:28 <eivuokko> xerox, Did you add the cabalised packages in darcs.haskell.org already?
08:52:38 <xerox> eivuokko: which ones?
08:52:42 <eivuokko> Most of them?
08:53:00 <xerox> I haven't added any of them so far in fact
08:53:00 <eivuokko> Some of them don't work in Windows or under ghc when Cabalised, tho.
08:53:08 <eivuokko> But I know Win32 does :-)
08:53:33 <lispy> eivuokko: oh, was my (unfinished) win32 patch useful at all?
08:53:52 <eivuokko> lispy, I'm not sure.
08:54:09 <lispy> wouldn't surprised me if you had to do a lot of work to get it working
08:54:23 <eivuokko> lispy, I didn'tr truly understand the msdn docs and your implementation totally, anyway.
08:54:34 <lispy> oh hmm...
08:54:39 <eivuokko> Sorry, didn't put much time on it.
08:54:53 <lispy> i thought it was pretty straight forward except for the resizing of the string to handle arbitrary file names
08:55:08 <eivuokko> There isn't much time before ghc 6.6, and I'd like some Cabal and ghc issues fixed rather than work on wierd interface.  Although it would be *very* useful
08:55:19 * lispy nods
08:55:39 <xerox> dcoutts: you recently hacked h4sh right? Why does it have Setup.hs but no .cabal file?
08:55:40 <eivuokko> lispy, Yeah, but the structures are big, so it takes time to go through them and check how diffrent things work together.
08:55:57 <lispy> eivuokko: that's true
08:55:58 <dcoutts> xerox, I've never hacked on h4sh
08:56:03 <xerox> OK, nevermind
08:56:22 <eivuokko> lispy, the resizing is fairly easy by using ffi to turn haskell functions into FunPtrs
08:56:44 <lispy> hmm...okay, with unicode support  even?
08:56:47 <lispy> that'd be cool
08:56:50 <eivuokko> Sure, why not.
08:57:02 <eivuokko> And yes, imo Win32 only works on unicode.
08:57:11 <lispy> good good
08:57:42 <eivuokko> Well, and in actuality, Win32 does compile Windows.h in unicode mode, but I usually use the unicode funcs explicitly anyway.
08:58:42 <eivuokko> lispy, But in the end, I think it will not get into Win32-2.0 that gets shipped with ghc 6.0
08:59:29 <lispy> well, as long as i can download it and upgrade the version that shipped with ghc i'll always been content
08:59:39 <eivuokko> Yeah, you can do that.
09:00:10 <eivuokko> ghc-api depends on Win32, but that shouldn't matter with ghc 6.6 as long as you keep Win32-2.0 installed as well.
09:03:42 <araujo> hi hi!
09:06:15 <xerox> eivuokko: so, what packages would be cool to have from darcs.haskell.org? I am not going on adding them all now, but if some would be useful for having people testing cabal-install, I'd be glad to add them
09:09:15 <eivuokko> xerox, Win32 is way important ;-)  seriously, tho, time, HaXml (but I am not sure it works), html packges, parsec are probably fairly popular.  Especially if ghc 6.6 ships without them (as it might).  I think they with Cabal and hugs, but some of the packages might not work with cabal & ghc.
09:09:41 <eivuokko> hunit and quickcheck too.
09:10:06 * araujo thinks, to or not to blog
09:11:34 <xerox> eivuokko: right, I am not adding the ones ghc-6.6 will need separately now, it'll be easy to do it afterwards anyway, or do you need them now?
09:11:38 <xerox> (I've got HaXml and HTTP.)
09:12:12 <eivuokko> xerox, No.  I don't need any of that right now
09:12:16 <xerox> OK.
09:12:19 * araujo wondering if there exist some haskell appli for web posting
09:12:26 <xerox> Yup!
09:12:30 <xerox> ?where hope
09:12:31 <lambdabot> I know nothing about hope.
09:12:43 <xerox> ?where+ hope http://hope.bringert.net/
09:12:43 <lambdabot> Done.
09:12:46 <araujo> ha
09:12:49 <araujo> get it :-)
09:13:07 <xerox> As you see we have 4 hope instances, you'd be the fifth! :D
09:13:23 <araujo> yay!
09:13:28 <eivuokko> xerox, But if I can submit my own packages, I'd be interested in putting up ia32-asm, dx9 and tracer.  I don't know anyone using them besides me.
09:13:30 <araujo> definitely
09:13:44 <xerox> P.S. if you have time to spend on making a decent CSS, all the other users would love that, and use it :)
09:14:00 <xerox> eivuokko: sure! may you send them to me?
09:14:22 <eivuokko> xerox, tamelambda.net/darcs has repos, would that be ok?
09:14:23 <xerox> eivuokko: I am not sure cabal-install works on win32 yet, but well :)
09:14:30 <xerox> eivuokko: yes.
09:14:39 <eivuokko> xerox, Erg.  Should it go into ghc 6.6?
09:14:44 <xerox> eivuokko: yes.
09:14:48 <eivuokko> xerox, ARGHG
09:14:55 <eivuokko> More Windows non-working bits, I guess :-S
09:15:02 <xerox> No well, I said *yet*
09:15:11 <eivuokko> Who is working on it :-)
09:15:14 <xerox> <-
09:15:22 <eivuokko> Ah, ok.  Good!
09:15:30 <araujo> xerox, hah ok
09:15:33 <eivuokko> I'll try test it a bit in few days.
09:15:46 <xerox> eivuokko: ok cool, I'm going to post instruction on cabal-devel next
09:15:57 <araujo> that hope looks nice
09:16:14 * araujo probably isn't too demanding with this kind of stuff
09:16:36 <eivuokko> xerox, RC for ghc-6.6 is scheduled for 25th, so there's not much time to fix issues.
09:16:47 <xerox> 25th?!?!
09:17:02 <eivuokko> Right.  http://www.haskell.org/pipermail/glasgow-haskell-users/2006-August/010698.html
09:17:03 <xerox> Well, I have free time in fact.
09:17:03 <lambdabot> Title: 6.6 plans and status
09:17:25 <xerox> If only people told me what they wanted exacly on the cabal-devel list :-/
09:17:51 <Igloo> xerox: "what they wanted exacly" in what sense?
09:18:25 <eivuokko> xerox, My exact need is: Works in Windows without mucking up my system or installed programs :-)
09:18:29 <xerox> Igloo: after making cabal-install work on a single tarball-indexed repository, I asked what would be useful to do next
09:19:18 <xerox> Igloo: I have then stripped off all the dependencies and cleaned the code, but I haven't mailed that patch yet
09:20:04 <eivuokko> xerox, Are you changes available in some repo?
09:20:16 <xerox> Igloo: so now the only dependency is HTTP, for which its latest version bundle contains the bits of crypto & whatnot it depends on
09:21:07 <xerox> Igloo: HTTP could even be shipped as darcs.haskell.org/packages/ are, so it's not a big concern, or just shipped with cabal-install for this release.
09:21:25 <Igloo> xerox: I'm not sure what the options are exactly, but the most important bits IMO are the ability to upload a package and the ability to install a package by package name. Fancy browsing interfaces etc can wait
09:21:40 <xerox> Now I just finished building a test repository so you can test cabal-install.
09:22:02 <xerox> I'll check things work and publish it, and mail the cabal-devel list, okay?
09:22:57 <Igloo> OK
09:23:07 <xerox> Stay tuned.
09:29:16 * xerox growls at .cabal files missing a synopsis ...
09:30:05 <xerox> OK, things seem to work :)
09:32:52 <xerox> Slow upload is no fun... hrrmmppf.
09:33:25 <xs> given, once :: IO a, is it possible to define, lots :: IO [a], in some way like, lots = sequence (repeat once), that has lazy semantics?
09:33:41 <xerox> Yes.
09:33:46 <xs> how?
09:33:54 <xs> my brain is not working :)
09:33:55 <xerox> unsafeInterleaveIO
09:33:59 <xs> eugh.
09:34:08 <xs> there is no nice way?
09:34:08 <xerox> It's not as unsafe as the name makes it.
09:34:13 <xs> hmm
09:34:13 <xerox> It is the nice way :)
09:34:27 <xs> why is it called unsafe?
09:34:49 <xerox> It enables a consumer to consume data while the IO actions are producing it.
09:35:36 <xs> ahh. ok. hm, thank you very much :)
09:36:12 <xerox> See fixIO
09:36:16 <xerox> It does that for you
09:36:17 <lispy> why is that unsafe?
09:36:27 <lispy> what is a situation where it's a bad idea/
09:36:50 <xerox> fixIO :: (a -> IO a) -> IO a
09:36:50 <xerox> fixIO k = do { ref <- newIORef (throw NonTermination); ans <- unsafeInterleaveIO (readIORef ref); result <- k ans; writeIORef ref result; return result }
09:37:54 <lispy> so then if you have just IO a as foo you'd say, fixIO (const foo) ?
09:38:30 <xerox> ?type let foo = undefined :: IO a in fixIO (const foo)
09:38:32 <Igloo> do x <- unsafeInterleaveIO (readFile foo); writeFile foo "bar"; print x   may go wrong
09:38:37 <lambdabot> fd:16: hClose: resource vanished (Broken pipe)
09:38:44 <xerox> Yuck
09:39:19 <xs> hm, so maybe mdo is a nicer way of doing this.
09:39:36 <xerox> I think you'd have to say unsafeInterleaveIO in mdo
09:39:42 <xerox> But you don't with fixIO
09:39:58 <xerox> What does mdo desugar to?
09:40:11 <xs> wraps it in fixIO, i guess
09:40:56 <xerox> Well, there you go then :)
09:42:11 <lispy> heh
09:42:44 <xerox> ?type fixM
09:42:51 <lambdabot> fd:16: hClose: resource vanished (Broken pipe)
09:42:57 <xerox> What happened to lambdabot :(
09:44:08 <lispy> @vixen you okay babe?
09:44:08 <lambdabot> ok what?
09:44:38 <lispy> @hoogle (a -> b) -> [a] -> [b]
09:44:41 <xerox> gour: do you have an OPML list of feeds somewhere?
09:44:46 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
09:44:46 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
09:44:46 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
09:44:54 <xerox> ?hoogle fixM
09:44:54 <lambdabot> No matches found
09:44:59 <xerox> ?hoogle mfix
09:44:59 <lambdabot> Control.Monad.Fix.mfix :: MonadFix m => (a -> m a) -> m a
09:45:14 <lispy> sometimes you just need your monad fix
09:45:20 <xerox> mdo surely desugars to mfix, yeah, which is fixIO for IO.
09:45:22 * lispy shoots up a lambda
09:46:18 <lispy> > scanr (+) 1 [1..3]
09:46:25 <lambdabot>  /home/pls/lib/ghc-6.4.2/package.conf: openFile: hardware fault (Input/output...
09:46:35 <lispy> hardware fault?
09:46:36 <lispy> whoa
09:46:49 <xerox> Oh noes!
09:46:57 <xerox> Somebody wake up dons!
09:47:14 <Heffalump> eek..
09:47:37 <xerox> Some lambdabot master should gently kill her, prolly.
09:47:48 <Heffalump> oh, good plan
09:47:53 <Heffalump> @die
09:47:53 <lambdabot> unexpected end of input: expecting number
09:47:55 <xerox> @quit
09:47:56 <lambdabot> Not enough privileges
09:47:58 <Heffalump> @quit
09:48:03 <xerox> Thanks master.
09:48:17 <xerox> Oh well, it may be wrapped in a while $(true) now that I think of it.
09:48:33 <xerox> I hope we didn't cause further problems o_0
09:49:39 <Patterner> > scanr (+) 1 [1..3]
09:49:39 <Heffalump> balls.
09:49:53 <Patterner> It's dead, Jim...
09:50:06 <lambdabot>  /home/pls/lib/ghc-6.4.2/package.conf: openFile: hardware fault (Input/output...
09:50:15 * Heffalump emails dons
09:51:34 <xerox> Phone him!  Call a medium!
09:52:33 * lispy gets out a crystal ball
09:53:38 <ookk> is there any action to sort an IOArray in haskell?
09:54:13 <Patterner> > scanr (+) 1 [1..3]
09:54:14 <ersatzlambdabot> Terminated
09:54:20 <lambdabot>  /home/pls/lib/ghc-6.4.2/package.conf: openFile: hardware fault (Input/output...
09:54:25 <xerox> ?docs Data.Array
09:54:25 <ersatzlambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
09:54:25 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
09:54:35 <xerox> She's back?
09:54:48 <Patterner> not really... "Terminated" isn't good, right?
09:55:02 <ookk> it does not seem to be any such function built in
09:55:38 <xerox> Do you want to sort it? Hmm.
09:55:48 <ookk> yes i do
09:55:52 <xerox> In which sense?
09:55:55 <Patterner> ersatz was my try...
09:56:05 <ookk> in the sense that i want it sorted :)
09:56:25 <ookk> and i dont want to convert it to a list which i then sort
09:57:39 <Heffalump> anyone have channel privileges to ban lambdabot from it?
09:58:15 <ookk> i guess i have to write my own quicksort for the IOArray
09:59:50 <gour> xerox: i have opml of my subscriptions
10:00:20 <xerox> gour: do you publish it?
10:00:41 <gour> xerox: no, why?
10:01:00 <xerox> gour: I have not many feeds, so I was wonder with other Haskellers read :)
10:01:49 <gour> xerox: i don't have many feeds at all, few haskell related, i can paste my list if you want it
10:02:41 <xerox> I have: ltu, dataisnature.com, planet.haskell.org, improbable.com
10:03:16 <xerox> ...oh and pugs.blogs.com/pugs.
10:03:44 <gour> xerox: i have only ltu, gtk2hs
10:04:28 <xerox> Oh right, gtk2hs!
10:05:23 <xerox> gour: and do you have your own blog?
10:05:46 <gour> xerox: then gnomefiles.org, slashdot, gentoo packages...
10:06:20 <greenrd> Is there any tool (apart from cpp/cpphs) which would help me to generate multiple copies of the same code, but with different identifiers and different kinds (e.g. * -> * -> * instead of *) for the type arguments?
10:06:25 <lisppaste2> gour pasted "rss feeds" at http://paste.lisp.org/display/24452
10:06:28 <greenrd> Template Haskell doesn't seem to support explicit kinds
10:06:46 <xerox> Thanks gour
10:27:30 <Daveman> xerox :D
10:27:36 <xerox> Hello!
10:31:23 <Daveman> :)
10:31:51 <xerox> How's code, Daveman?
10:32:01 <xerox> Are you finally hacking pugs? :)
10:32:35 <hyrax42> null = (==[])
10:32:50 <hyrax42> ah crqap
10:32:55 <hyrax42> window stopped scrolling
10:33:24 <int-e> > null [id]
10:33:38 <hyrax42> that was abouyt 18 hours out of context
10:33:47 <Korollary> heh
10:33:48 <hyrax42> > null []
10:33:55 <int-e> > [] == [id]
10:34:22 <hyrax42> ?
10:34:24 <int-e> well, [] == [id] is a type error, so null is not the same as (==[])
10:34:51 <Heffalump> how is that a type error?
10:34:58 <hyrax42> hm
10:34:59 <int-e> there's no Eq instance for a -> a
10:34:59 <lambdabot>  /home/pls/lib/ghc-6.4.2/package.conf: openFile: hardware fault (Input/output...
10:35:00 <lambdabot>  /home/pls/lib/ghc-6.4.2/package.conf: openFile: hardware fault (Input/output...
10:35:00 <lambdabot>  /home/pls/lib/ghc-6.4.2/package.conf: openFile: hardware fault (Input/output...
10:35:05 <Heffalump> oh, right
10:35:28 <Korollary> just a '?' did that?
10:35:30 <Korollary> ?
10:35:43 <int-e> @botsnack
10:35:43 <lambdabot> :)
10:35:43 <Korollary> oh, the > above
10:36:44 <Patterner> > null []
10:36:45 <ersatzlambdabot> Terminated
10:36:46 <hyrax42> so then null must be defined as null [] = True; null _ = False?
10:36:51 <lambdabot>  /home/pls/lib/ghc-6.4.2/package.conf: openFile: hardware fault (Input/output...
10:37:06 <int-e> hyrax42: right
10:37:12 <hyrax42> @type null
10:37:12 <lambdabot> fd:10: hClose: resource vanished (Broken pipe)
10:37:24 <hyrax42> oookk
10:37:27 <int-e> poor dons
10:37:41 <hyrax42> it's forall a. [a] -> Bool
10:38:06 <lispy> it's funny how dependent we are, as a channel, on lambdabot
10:38:20 <Korollary> I am not. I've been clean for months.
10:38:23 <hyrax42> I want @hoogle :(
10:38:33 <int-e> null [] = True; null (_:_) = False  (from GHC.List)
10:38:38 <lispy> Korollary: c'mon don't you need your MonadFix?
10:38:55 <hyrax42> why is the (_:_) needed
10:39:02 <hyrax42> does'nt it check cases in order?
10:39:29 <int-e> hyrax42: I don't know why it's defined that way. It's not necessary.
10:39:34 <hyrax42> kk
10:39:47 <lispy> hmm..
10:39:52 <audreyt> going back to maintain my first haskell program written 18 months ago really made me appreciate the language :)
10:39:54 <Korollary> why is not necessary?
10:40:11 <xerox> Do you want some unicycles to compensate... ?
10:40:16 <int-e> null [] = True; null _ = False  defines exactly the same function.
10:40:17 <audreyt> except for the very painful part that it took a couple days to make it compile under GHC 6.5, it was stress free ;)
10:40:25 <xerox> http://haskell.galois.com/~paolo/media/riding.jpg
10:40:29 <ths> Hello. I try to bootstrap ghc 6.4.2 for mips-linux, and it fails in the build system.
10:40:42 <Korollary> oh I thought you meant the entire line.
10:41:02 <Korollary> It's more explicit that way, tho.
10:41:24 <int-e> lispy: it's not a dependency, but lambdabot is very convenient.
10:42:22 <lispy> int-e: speak for yourself :)
10:42:33 <lispy> int-e: i only come here for lambdabot ;)
10:42:50 <Korollary> lispy: You can run your own lambdabot if you need hoogle et al that much
10:42:51 <Patterner> > 1+1
10:42:51 <ersatzlambdabot> Terminated
10:42:57 <lambdabot>  /home/pls/lib/ghc-6.4.2/package.conf: openFile: hardware fault (Input/output...
10:43:11 <ths> The libcompat Makefile system lacks some rules for .hs -> .o, I couldn't figure out a working version of them.
10:44:29 <Patterner> what is runplugs?
10:44:45 <lispy> Korollary: yeah, i was going to do that on windows so i could have lambdabot at work, but i suck at porting...
10:44:50 <int-e> runplugs is the helper for @run
10:44:56 <lispy> and ran into some really bizarre problems in my defenese
10:45:26 <Heffalump> @time dons
10:45:27 <lambdabot> Local time for dons is Mon Aug 21 03:45:04 2006
10:45:31 <int-e> (also known as >)
10:46:12 <xerox> (int-e: > and run are two different things.)
10:46:31 <int-e> @help run
10:46:32 <lambdabot> run <expr>
10:46:32 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
10:46:33 <lispy>  > == eval right?
10:46:39 <int-e> no, @eval does nothing
10:46:41 <int-e> @help eval
10:46:42 <lambdabot> eval. Do nothing (perversely)
10:46:48 <lispy> heh
10:46:51 <xerox> ?help runstate
10:46:51 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:46:55 <xerox> Hm.
10:47:01 <int-e> (it clashed with a bot on #perl6 I think)
10:47:08 <lispy> oh
10:47:12 <xerox> ?state (++" or no?")
10:47:12 <Patterner> "runplugs: magic number mismatch: old/corrupt interface file?" :(
10:47:12 <lambdabot> (++" or no?")
10:47:22 * dcoutts wonders what is the difference between doing nothing and doing nothing perversely
10:47:25 <xerox> ?. run . ++ "yes"
10:47:25 <lambdabot> compose module failed: IRCRaised Parse error: "\"yes\""
10:47:36 <Igloo> ths: FWIW, I'm hoping my mips bootstrap will finish overnight, in which case I'll start building debs tomorrow all going well
10:47:37 <xerox> ?. run . ++ show yes
10:47:42 <dcoutts> Igloo, yay
10:47:43 <lambdabot>  /home/pls/lib/ghc-6.4.2/package.conf: openFile: hardware fault (Input/output...
10:47:56 <dcoutts> oh dear
10:47:59 <Korollary> @eval halting httpd
10:48:00 <Heffalump> can someone ban lambdabot from the channel?
10:48:00 <xerox> int-e: I believe run is a scary attempt to do lambdabot metaprogramming
10:48:13 --- mode: ChanServ set +o Igloo
10:48:15 <int-e> dcoutts: the latter makes you feel filthy
10:48:24 <dcoutts> int-e, ah, thanks. :-)
10:48:33 --- mode: Igloo set +b lambdabot!*@*
10:48:37 --- kick: lambdabot was kicked by Igloo (Igloo)
10:48:43 --- mode: Igloo set -b lambdabot!*@*
10:48:57 <xerox> <http://hackage.haskell.org/~paolo/darcs/packages/> cabal-install packages I've put together so far.
10:49:01 <int-e> xerox: you're not up-to-date
10:49:14 * xerox darcs pulls
10:49:15 <int-e> xerox: @run is the command that was formerly @eval.
10:49:25 <gour> dcoutts: doing nothing perversely is much more dangerous and one should be prosecuted for that
10:49:42 <xerox> int-e: I think @runplugs is the command that was formerly known was @eval.
10:49:43 <ths> Igloo: How did you work around the libcompat problem?
10:49:57 <int-e> http://www.cse.unsw.edu.au/~dons/lambdabot/Plugin/Eval.hs disagrees.
10:50:00 <Igloo> ths: What stage of the bootstrapping process are you at?
10:50:20 <xerox> Oh well, okay.
10:50:38 <int-e> (hmm, the plugin got renamed, too)
10:50:46 <ths> Igloo: Building ghc on the target, linking the ghc-inplace fails due to missing libcompat.
10:51:01 <xerox> int-e: dons added cons, snoc, and ++ to work on state
10:51:15 <Igloo> I think you just need to run make in ghc/lib first
10:51:28 <ths> Igloo: Building libcompat before the compiler fails with missing make rules.
10:51:34 <xerox> int-e: yes, run didn't need modification, you are right
10:51:57 <xerox> Basically we wanted to do @state "rock/paper/scissors Int -> String function", get a result out of @dice 1d3, and run a composition.
10:52:20 <int-e> I know :)
10:52:33 <ths> Igloo: mk/suffix.mk mentions the rules were replaced by the ones in bootstrap.mk, but there are none.
10:52:42 <audreyt> @pl \k a -> f k
10:53:09 <xerox> const . f
10:53:48 <xerox> AHA, now I can do it in place of lambdabot! This is going to be fun.
10:54:01 <Igloo> ths: Ah, the problem is earlier, when it tells you to do "make boot UseStage1=YES" then "make -k UseStage1=YES EXTRA_HC_OPTS='-O -fvia-C -keep-hc-files'"
10:54:05 <xerox> I secretly hated her for her fast @pl answers.
10:54:13 <Igloo> ths: You need to replace the first with "make boot UseStage1=YES EXTRA_HC_OPTS='-O -fvia-C -keep-hc-files'" instead
10:54:48 <ths> Igloo: I'll try that, thanks.
10:55:09 <audreyt> xerox: thanks :) *botsnack*
10:55:13 <xerox> :)
10:55:44 <ookk> Couldn't match expected type `Int' against inferred type `t Int'
10:55:47 <ookk> what does that mean?
10:56:21 <lispy> ookk: hard to say without seeing the code
10:56:38 <ookk> ?paste
10:57:07 <lisppaste2> ookk pasted "code" at http://paste.lisp.org/display/24455
10:57:18 <ookk> that is the code
10:57:43 <ookk> it complains about swap l h arr
10:58:05 * lispy is looking now
10:59:22 <lispy> what is the type of lesser and higher?
10:59:48 <ookk> maybe i should add a type definition of them in the code?
11:00:03 <int-e> @type when -- does this work?
11:00:10 <int-e> (probably not :)
11:00:28 <int-e> when :: (Monad m) => Bool -> m () -> m ()
11:00:34 <int-e> and that's your problem I think
11:00:53 <lispy> ookk: yeah, if you want them to have a certain type add it, and then see if it still type cehcks
11:01:35 <ookk> lesser and higher must be of type IO Int
11:01:42 <ookk> because they read from the IOArray
11:01:50 <nomeata> hi. Has anyone tried to create a "Haskell Challange", similar to the Python Challenge? (http://www.pythonchallenge.com/)
11:01:54 <lispy> i thnk int-e has a point
11:02:01 <ookk> but how can i call swap with the results of lesser and higher?
11:02:20 * int-e has found `when' to be of very limited use.
11:03:26 <ookk> then you have to do if blah then do stuff else return ()
11:03:28 <lispy> if (l < h) then {- do what you do now -} else return (l, h) ?
11:04:00 <int-e> almost. {- do what you do now except return (l,h) -}
11:04:11 * ibid uses when all the time
11:04:29 <lispy> well, he does return (l, h) now when (l < h)
11:04:55 * lispy uses male genered pronoun by default..if you're not male no sexism intended
11:04:57 <ookk> my problem now is that i complains about me giving swap an IO Int as a parameter
11:05:00 <int-e> it's not what he wants though
11:05:14 <heatsink> Is it supposed to return (l,h) in all cases, or only when (l < h)?
11:05:26 <ookk> l <- lesser; h <- higher; swap l h array
11:05:34 <ookk> it complains about l beeing IO Int
11:06:02 <int-e> add type signatures.
11:06:26 <int-e> that usually shifts the error messages closer to the actual mistake
11:06:44 * lispy is a little confused about wether (Int, Int) needs to be returned and why you only do it in the when
11:06:46 <ookk> int-e,  i have
11:06:55 <ookk>  lesser :: Int -> Int -> Int -> IO Int
11:07:00 <ookk> i cant get away from that
11:07:17 <ookk> but i how do i use the value returned by it in a function that takes Int as paramters?
11:07:25 <heatsink> ook: what is the type of (lesser lo p) ?
11:07:34 <ookk> i have done l <- lesser lo p
11:07:40 <ookk> IO Int
11:07:48 <lispy> ookk: give it one more parameter...
11:08:31 <lispy> if it's really Int -> Int -> Int -> IO Int, then lesser lo p, has type Int -> IO Int, right?
11:08:55 <ookk> yeah thats right
11:09:25 <lispy> then you see the problem right?
11:09:50 * lispy has gotten very confused on this example
11:11:03 <ookk> i need 3 paramters for lower and higher but i had used them with 2
11:11:39 <ookk> now i get another error instead :P
11:12:59 <ookk> now it compiles, lets se if it works the way i want it to :P
11:13:16 <int-e> your next problem is the when problem.
11:13:39 <xerox> Igloo: mail sent!
11:13:44 * xerox heads to dinner
11:15:03 <int-e> by providing type signatures for loop and lesser, I got the error in exactly the right place.
11:15:49 <lispy> int-e: oh, i see what you ment when you ammended my suggestion
11:15:52 <int-e> and it was more relevant, too:    Couldn't match `IO' against `(->) Int'
11:17:04 * lispy wonders if he should try to hack some code today
11:17:26 <lispy> oh, maybe i should try to understand patch theory
11:17:31 <lispy> that would be a good use of a sunday
11:21:30 <midfield> anyone here familiar with ForeignPtrs, mallocByteString and IORefs?
11:21:54 <heatsink> yea
11:22:15 * heatsink is not familiar with mallocByteString.
11:25:22 <midfield> heatsink: <generating paste>
11:26:50 <lisppaste2> midfield pasted "expandBin" at http://paste.lisp.org/display/24456
11:26:55 <lispy> eivuokko: so where you able to cabalize darcs?
11:28:05 <lispy> s/where/were
11:28:10 <midfield> heatsink: i'm working with byte arrays via foreign pointers for the first time.  these functions should allocate and resize the buffers.
11:28:38 <heatsink> ok
11:29:31 <ookk> what types can a IOArray contain?
11:29:34 <midfield> heatsink: do they look right to you?
11:29:51 <ookk> apparently i complains when i try to make an IOArray Int (Int,Int)
11:30:14 <int-e> you mean IOUArray, right?
11:30:22 <ookk> yes
11:30:23 <heatsink> midfield: should mem' have size off, or size sz'?
11:30:56 <int-e> basic types. Double, Float, Int, Char ... stuff from Data.Word and Data.Int
11:31:18 <eivuokko> lispy, Huh.  I didn't try.  Well, yet anyway.
11:31:29 <lispy> eivuokko: yeah, maybe i'll try it today
11:31:30 <ookk> okay  i would have liked to have it contain (Int, Int)
11:31:44 <lispy> eivuokko: i'll make a patch available if i get it working
11:31:47 <ookk> maybe you can have multidimensional arrays?
11:31:49 <int-e> then use IOArray
11:31:55 <int-e> that's what boxed arrays are for.
11:31:58 <eivuokko> lispy, If I was to do it, I'd try make configure go away, but that's not trivial.
11:31:58 <ookk> ok
11:32:22 <eivuokko> lispy, And having cabal with configure wins nothing for me (as I am in Windows)
11:32:36 <eivuokko> Well, not nothing, but little.
11:32:40 <int-e> or use two arrays, if you're worried about consuming too much memory.
11:32:50 <heatsink> midfield: They mostly look okay.
11:33:14 <lispy> eivuokko: hmm...so darcs need some things that cabal isn't really ready to handle?
11:33:18 <ookk> ill use two arrays instead
11:33:21 <midfield> heatsink: mostly?
11:34:24 <heatsink> midfield: It looks wrong to pass the offset to mallocByteString
11:34:36 <eivuokko> lispy, I haven't really looked into what other checks configure does, but atleast haskell package selection mechanism (configurations as they're called at cabal-devel) for current Cabal is at the momment too weak
11:34:55 <lispy> interesting
11:35:07 <lispy> man, i really need ghc 6.4.1...grrr
11:35:37 <lispy> why isn't in darwinports
11:35:41 <eivuokko> lispy, I'd start from introducing deps to posix/Win32 and other already existing packages, to get rid of some crud.
11:35:58 <midfield> heatsink: offset should be the new size to grow to.
11:36:25 <heatsink> midfield: what is sz'?
11:36:32 <lispy> eivuokko: you didn't happen to discuss the problem in your email to cabal-devel did you?  if so i'll go read it
11:36:45 <eivuokko> lispy, Why don't you build it yourself?  (the ghc 6.4.1 ... why not 6.4.2?)
11:36:55 <midfield> heatsink: instead of growing minimall i double in size.  sz' is the 2*2*2*...sz until it is bigger than off
11:37:14 <eivuokko> lispy, Err?  No, this isn't in any mail.
11:37:18 <lispy> eivuokko: i think i'll have to build it myself, i don't see much for options...but that means today is wasted for doing any darcs dev on my ibook
11:37:32 <lispy> eivuokko: it takes at least 6 hours to build :(
11:37:36 <eivuokko> o.O
11:37:44 <lispy> no joke :)
11:37:51 * lispy checks for a binary
11:37:55 <heatsink> midfield: That's how you calculate it, yes.  But you don't allocate that much memory.
11:38:16 <midfield> heatsink: yer right.  whoops.
11:39:36 <lispy> ah yup, 6.4.2 is listed as "Coming soon" on OSX
11:40:10 <midfield> heatsink:  thanks.  anything else?
11:40:12 * lispy grabs the latest source
11:40:19 <heatsink> midfield: the rest looks okay.
11:40:33 <eivuokko> lispy, You could bootstrap without all the libs.  make GhcBootLibs=YES leaves out a bunch.
11:40:49 <heatsink> imperative code in haskell is hard to read, I could easily have missed something.
11:40:51 <eivuokko> Check libraries/Makefile in source tree
11:41:13 <lispy> thanks
11:41:15 <lispy> i will
11:42:18 <eivuokko> It's a bit braindead set, imo, tho.  Editing the makefile might be better, especially if you can live without OpenGL.  But stuff like stm, mtl and fgl are pretty nice to have...
11:42:36 <lispy> yeah
11:42:38 <eivuokko> And mtl takes like seconds to build
11:42:48 <lispy> hmm..maybe i'll just let it do the full compile and try to build darcs on a different machine
11:43:09 <midfield> heatsink: thanks!
11:43:21 <heatsink> np
11:43:38 <lispy> i mean, _maybe_ i should just wait for 6.6, but that seems like a long way off and it may not be stable until 6.6.1
11:48:33 <ookk> what is the type called that has values GT, LT, EQ ?
11:48:45 <Igloo> Comparing
11:48:46 <heatsink> @type compare
11:49:05 <Igloo> Err, IM Ordering
11:49:18 <ookk> ok
12:09:57 <lispy> Igloo: do you have access to build ghc packages for debian-amd64?
12:10:11 <Igloo> Yes
12:10:16 <lispy> Igloo: if so, looks like amd64 is still on 6.4.1
12:10:34 <Igloo> According to what?
12:10:45 <Igloo> I probably uploaded ghc 6.4.2 myself
12:11:00 <dylan> debian amd64 is a never-ending adventure.
12:11:32 <dylan> and ghc is 6.4.2 in sid.
12:12:06 <lispy> hm...what should i be using as my amd64 server then?
12:12:19 <lispy> i've tried a couple of the mirrors but none of them have 6.4.2
12:12:29 <dylan> well, if you've alredy got it installed, that's half the battle.
12:12:33 <lispy> and finding sid for amd64 has been interesting...
12:12:43 <dylan> err, it's just the normal mirror.
12:12:57 <lispy> humor me, and that mirror is at?
12:13:00 <Igloo> I have "deb http://ftp.de.debian.org/debian sid main" in my unstable chroot
12:13:18 <lispy> isn't that just x86?
12:13:21 <dylan> deb http://ftp.us.debian.org/debian sid main is in my main system's /etc/apt/sources.list
12:13:23 <Igloo> No
12:13:41 <lispy> hmm...how does apt know what to grab?
12:13:51 * lispy has no "normal" x86 on this box
12:14:04 <lispy> i guess that makes it a "pure" amd64 install
12:14:09 <dylan> the arch is specified elsewhere.
12:14:26 <Igloo> The arch name is in subdirectories of the above URL
12:15:14 <dylan> I wonder if the etch installer works now...
12:16:14 * lispy updatse his sources
12:17:55 <lispy> wow, this will be a huge update
12:18:14 <lispy> wish i had known you don't need the debian-amd64 crap anymore :)
12:18:17 <dylan> lispy: were you using unofficial amd64?
12:18:22 <lispy> apparently yeah
12:18:25 <dylan> um
12:18:34 <lispy> don't upgrade?
12:18:37 <dylan> that was the last one I had working right
12:18:45 <dylan> I upgraded and it's been a nightmare sense then
12:18:46 <lispy> hmm...
12:18:55 <dylan> I even had to re-install
12:18:59 <lispy> ouch
12:19:02 <dylan> yes
12:19:02 <lispy> i can't reall afford to do that
12:19:18 * Igloo recommends not running unstable outside of a chroot
12:19:31 <dylan> and a few weeks ago, if I did a dist-upgrade, it wanted to remove xorg and aptitude.
12:19:45 <dylan> etch only recently got vim working again
12:20:09 <dylan> also python 2.4 in etch was broken... dunno what the state is now.
12:20:24 * lispy switches back to the unofficial and leaves it all alone for now
12:24:24 <Igloo> The unofficial probably isn't being updated at all
12:25:29 <dylan> it isn't
12:27:41 <lispy> hmm...so what should a person do?
12:28:33 <Igloo> Run stable on the machine and unstable in a chroot
12:29:27 <lispy> Igloo: as in stable amd64 with unstable amd64 chroot?
12:29:34 <Igloo> Yup
12:29:53 <lispy> hmm...in the past i always just used testing
12:30:12 <dylan> Igloo's is probably the sanest solution
12:33:17 <newsham> for example: http://www.thenewsh.com/~newsham/x/machine/bmap.py
12:33:22 <newsham> err, wrong channel, misfire
12:38:03 <blackdog> sala'am aleykum. where my homies at?
12:39:25 <Heffalump> 'lo
12:39:29 <Heffalump> you seen dons?
12:39:39 <blackdog> not lately. i'm in qatar.
12:39:46 <Heffalump> ah.
12:39:58 <Heffalump> do you know anything about the machine lambdabot runs on?
12:40:08 <blackdog> is it one of the pills?
12:40:15 <Heffalump> lambdabot was reporting hardware errors when we asked it stuff
12:40:36 <Heffalump> we tried to make it quit, but it just came back, so we banned it from the channel to reduce the level of requests it would get
12:41:01 <Heffalump> i=dons@pill00.orchestra.cse.unsw.EDU.AU
12:41:02 <blackdog> one of the cse machines went bye-bye recently, but not one don has access to...
12:41:02 <Heffalump> so yes
12:41:10 <ivant> @seen lambdabot
12:41:21 <Heffalump> ivant: it's a bit ill
12:41:42 * ivant sighs
12:42:13 <dcoutts> Heffalump, dons will be up in about 4 or 5 hours.
12:42:20 <Heffalump> dcoutts: yeah, I guessed.
12:42:30 <blackdog> hm. there was a general network shutdown on saturday, sydney time. how long has it been stuffed?
12:42:37 <Heffalump> I just thought it would be useful if someone could kill lambdabot off properly.
12:43:05 <Heffalump> blackdog: not sure. Not that long, I don't think
12:43:10 <Heffalump> oh well. I'm sure it'll live.
12:43:34 <blackdog> yeah, my cse access was revoked a few months ago. sorry i couldn't help.
12:43:54 <xerox> Seems like TH code needs to be ported to ByteStrings
12:43:57 <blackdog> contact would be ss@cse.unsw.edu.au, if you'd like someone to murder it.
12:43:59 <xerox> It is full of PacketString warnings
12:44:16 <Heffalump> are PackedStrings deprecated?
12:44:21 <xerox> Yep.
12:44:33 <xerox> Language/Haskell/TH/Syntax.hs:46:0:
12:44:33 <xerox>     Warning: Module `Data.PackedString' is deprecated:
12:44:34 <xerox>                  use Data.ByteString, Data.ByteString.Char8, or plain String.
12:44:45 <Heffalump> I think it just uses them for names
12:44:58 <Heffalump> in fact I'm fairly sure it does, after spending a while trying to make the TH datatypes implement Data
12:52:20 <xerox> Oh.. ghc-darcs uses Cabal-1.1.4, not .5, duh.
12:59:21 <xerox> @karma+ eivuokko
13:02:26 <ivant> xerox: lambdabot is sleeping :-(
13:03:33 <xerox> She took summer vacations? Yarrr, we must re-think the contract.
13:10:03 <lispy> Igloo: do you think you could make the x86_64 .deb for ghc 6.4.2 available on the ghc binary download page?
13:11:29 <Igloo> lispy: You can grab the binary from any Debian mirror that carries amd64, e.g. http://ftp.debian.org/debian/pool/main/g/ghc6/ghc6_6.4.2-2_amd64.deb
13:15:45 <lispy> oh, good idea
13:15:52 <lispy> thanks for the link
13:30:16 <nomeata> hi. Has anyone tried to create a "Haskell Challange", similar to the Python Challenge? (http://www.pythonchallenge.com/), or thought about it?
13:30:40 <Korollary> I know some people did the python challenge using haskell.
13:30:57 <nomeata> Korollary: that is cool, too
13:32:15 <int-e> Korollary: it uses python's serializing at some point IIRC.
13:32:33 <int-e> most of the stuff can be done in haskell anyway.
13:33:21 <nomeata> but wouldn't it be interesting to have something like that for haskell, too?
13:33:25 <Korollary> int-e: Does an exercise give you a python-serialized string as input?
13:34:01 <nomeata> a bunch of interesting tasks that introduce the novice to more and more details of haskell
13:34:44 <int-e> Korollary: if my memory doesn't fail me, yes. but I could be wrong.
13:34:46 <Korollary> nomeata: of course. problems with answers always help.
13:35:02 <int-e> Korollary: There are too many programming challenges out there.
13:35:16 <Korollary> yeah. no dearth of puzzles.
13:35:32 <stepcut> nomeata: you might like http://www.mathschallenge.net/
13:36:23 <stepcut> nomeata: though, python challenge is an interesting variation
13:37:40 <Korollary> thousands of problems: http://acm.uva.es/problemset/
13:38:39 <stepcut> I have a book that I found at the coffee shop in the 'free' pile named "Elementary Pascal" -- which attempts to teach you how to use Pascal by having Sherlock Holmes use it to solve a murder mystery
13:39:12 <xerox> Hey stepcut, is there any news about ByteStringParsec?
13:39:18 <Korollary> hah
13:39:45 <stepcut> xerox: I can send you what I have -- it only does the bare minimum at the moment
13:40:01 <xerox> stepcut: I'd *love* it!
13:52:31 <lispy> bleh, i hate compling ghc my self...ghc-6.4.2: unknown package: OpenAL
13:53:16 <ivant> @type mapM_
13:53:17 <xerox> I am compiling ghc in this very moment too
13:53:24 <ivant> ahh
13:53:44 <xerox> mapM_ :: (Monad m) => (a -> m ()) -> [a] -> m ()
13:53:59 * xerox dress himself as lambdabot
13:54:19 <eivuokko> Isn't that (a -> m b)
13:54:20 <ivant> :-)
13:54:52 <xerox> mapM :: (Monad m) => (a -> m b) -> [a] -> m [b]
13:55:00 <newsham> :t mapM_
13:55:16 <newsham> mapM_ :: (Monad m) => (a -> m b) -> [a] -> m ()
13:55:20 * lispy has no clue what he should have done differently...do i need to install some OpenAL package...did i just need to run configure differently...who knows...
13:55:25 <xerox> Uh.
13:55:30 <xerox> Makes sense, anyway.
13:55:43 <newsham> it doesnt use the bs but they can be there
13:55:44 <eivuokko> Point of mapM_ isn't that the mapper-funciton returns (), but that it runs in constant space because it doesn't keep the intermediate resources.
13:56:09 <eivuokko> lispy, edit libraries/Makefile maybe
13:56:41 <ivant> hmmm, lets try something different with lambdabot then
13:56:46 <ivant> > undefined
13:57:00 <ivant> :-)
13:57:21 <newsham> :seen a bot
14:00:51 <xerox> lispy: I just finished
14:00:52 <xerox> :D
14:01:43 <xerox> Does 'make install' blow the previous ghc installed, or is it safe?
14:02:04 <xerox> (I'm on mac intel, but it's just like any other unix. It's just that I never installed ghc this way.)
14:02:51 <Tela> it'll probably blow the old one unless you changed the prefix
14:03:02 <xerox> I did not
14:03:19 <Tela> which version are you compiling? I'm having all sorts of "fun" trying to get ghc going on that architecture
14:03:34 <xerox> darcs.haskell.org/ghc
14:03:55 <xerox> eivuokko helped with the one and only error, the rest went very smooth
14:03:58 <xerox> It took 2 hours
14:04:03 <Tela> Hmm..
14:04:21 * Tela tinkers some more
14:06:00 <eivuokko> Tela, have you been following the email discussions at ghc-users?
14:06:11 <Tela> I haven't
14:06:16 <eivuokko> Ok.
14:06:17 <Tela> Something interesting?
14:06:45 <eivuokko> There was talk how to get ghc-6.5 compiled with the prebuilt binary someone else had compiler and distributed.
14:07:07 <Tela> ahhhh, intersting indeed! :)
14:07:11 <eivuokko> We found a way with xerox, at least it compiled...let's see the tests.
14:07:39 <eivuokko> Basically, the email miss one info, it's that you really need to edit mk/config.mk, line 790, and change version from 5 to 4.
14:07:43 <newsham> how do they usually bootstrap a new processor?
14:07:55 <eivuokko> And then unpull the "Fix Array imports" for stage1 and pull it back for stage2
14:08:13 <ivant> can anyone tell me what fixIO does? documentation does not say a word about it
14:08:14 <eivuokko> newsham, ghc can generate C that isn't really platform dependant (sort of)
14:08:18 <xerox> ivant: sure
14:08:27 <xerox> ivant: it's what mdo desugars to for the IO monad.
14:08:35 <eivuokko> newsham, So you generate those on other platform, then run configure and make in certain mode.
14:08:40 <newsham> so they generate the C code, ship it over and build?
14:08:49 <ivant> xerox: sorry?
14:08:55 <eivuokko> newsham, It's a bit more complicated, but yeah.
14:08:56 <xerox> http://darcs.haskell.org/packages/base/System/IO.hs
14:09:03 <xerox> ivant: it's defined there if I remember correctly
14:09:25 <Tela> eivuokko, hmm.. Reading that now. Thanks
14:11:13 <ivant> xerox: it is there but I cannot understand it yet. Will try to do it when I'll reach another level of enlightenment then
14:11:29 <Tela> whois eivuokko
14:11:32 <Tela> oops
14:11:50 <xerox> ivant: it's not difficult, I believe....
14:12:10 <Tela> eivuokko, I think I got the right thread. Building GHC on OS X?
14:12:27 <ivant> it uses IORefs and unsafeInterleaveIO which I haven't read about yet
14:13:15 <eivuokko> Tela, I think Digraph.lhs broken? and Circular dependency between the compiler and TH?
14:13:18 <xerox> ivant: IORef is a mutable reference, that you can access with readIORef :: IORef a -> IO a; and writeIORef :: a -> IORef a -> IO ().
14:13:33 <xerox> ivant: unsaveInterleaveIO makes IO lazy.
14:13:48 <eivuokko> Tela, I suspect xerox or I will post updated instructions later.
14:13:57 <ivant> putting "throw NonTermination" into the mutable variable is funny :-)
14:14:04 <Tela> Alright. I'll wait on one of you two.
14:14:10 <xerox> ivant: indeed :)
14:14:11 <ivant> that's what fixIO does first
14:14:15 <Tela> will you post them to the wiki?
14:14:18 <newsham> trying to think.. there was a paper or tutorial with a good overview of iorefs.   was that the "awkward squad" paper?
14:14:31 <xerox> ivant: I have it before my eyes too
14:14:34 <eivuokko> Tela, that might be a good idea...
14:15:15 <newsham> yah, seciton 2.5 of "tackling the awkward squad"  http://research.microsoft.com/~simonpj/Papers/marktoberdorf/mark.pdf#search=%22monad%20squad%20ioref%22
14:15:15 <Tela> http://hackage.haskell.org/trac/ghc/wiki/X86OSXGhc seems like the most current page - and it's not very current
14:15:26 <xerox> ivant: you would maybe have a better time if you start with fix, then mfix.
14:15:34 <xerox> Tela, that's true.
14:16:14 <ivant> xerox: good idea, thanks
14:16:34 <xerox> ivant: you might then appreciate fix expressed in lojban :D
14:16:54 <xerox> (Here <http://paolo.is-a-geek.com/mu/entry>)
14:17:15 <ivant> wow, unsafeInterleaveIO is a neat function
14:17:44 <ivant> especially when it defers throwing a NonTermination exception :-)
14:17:45 <stepcut> heh
14:18:11 <xerox> hehehe
14:18:14 <xerox> Today is all about mdo...
14:18:24 <newsham> they said "unsafe" right?
14:18:25 <xerox> I got the mdo test fail in my just built ghc, heh
14:18:34 <xerox> newsham: it's not unsafe as `unsafe' makes it
14:20:45 <ivant> xerox: just wondering, how fix relates to lojban?
14:21:05 <xerox> ivant: lojban is a logic(?) spoken language
14:22:22 <ivant> wow, I remember there was a theorem about the fixed point in mathematical analysis courses
14:22:44 <eivuokko> Tela, updated the wiki page http://hackage.haskell.org/trac/ghc/wiki/X86OSXGhc
14:24:16 <ivant> it was a sufficient condition of existence of the fixed point for the function
14:26:24 <kpreid> xerox: the recursive definition is, by definition, not the Y combinator
14:26:31 <kpreid> xerox: it is a fixpoint combinator
14:26:55 <xerox> Only the nonrecursive one is?
14:26:58 <kpreid> Yes.
14:27:00 <kpreid> xerox: also, you should say x1, not xn
14:27:04 <xerox> I thought they were equivalent
14:27:10 <kpreid> they are equivalent, yes
14:27:44 <kpreid> but one is Y and one isn't
14:29:00 <kpreid> xerox: standard textual notation for places in Lojban is x1 ..., or x<sub>1</sub> if you can do that.
14:30:44 <xerox> If there is a unicode glyph for it I can use it, else, it's just x1.
14:30:53 <xerox> Hmm, I am not sure, maybe I can use HTML.
14:30:56 <kpreid> that's fine.
14:31:05 <xerox> Let's try
14:32:57 <xerox> It doesn't grok the <sub>s :(
14:33:21 <kpreid> then better to just write x1. $x_1$ is markup for jbovlaste
14:33:56 <kpreid> also, what are you trying to communicate with "x_n" instead of x_1?
14:33:57 <xerox> Do you want me to change the first paragraph too?
14:34:10 <kpreid> I don't want. I state that it is false.
14:34:18 <kpreid> It is up to you to choose whether to correct it.
14:34:25 <xerox> Thanks for the comments!
14:37:53 <Tela> eivuokko, excellent. I'll try that a little later
14:38:12 <xerox> kpreid - Unfortunately the rss readers (like planet haskell) will keep the erroneous version. I am sorry.
14:38:13 <eivuokko> Sure, it was just FYI.
14:38:32 <Tela> Thanks :)
14:38:44 <kpreid> xerox: um,sure, but that doesn't stop you from updating the text, as you did with x1
14:39:44 <xerox> kpreid: it's still erroneous?
14:40:45 <kpreid> Oh. Sorry, I didn't read closely enough after reloading.
14:41:19 <kpreid> I missed that you swapped the text, rather than replacing "Y combinator" with "fixed point combinator"
14:41:36 <kpreid> .u'u
14:42:08 <newsham> anyone use the HAT tracer?  any opinions on it?
14:42:10 <xerox> ".u'u" ? :)
14:52:16 <stepcut> It would be interesting to debug haskell code by writing unit tests for each function until you find the bug -- because then, at least, you would have a bunch of unit tests afterward
14:52:21 <xerox> Anybody knows how to make the mac bundle of GHC?
14:52:48 <stepcut> xerox: Is 'bundle' some sort of mac thing ?
16:08:05 --- topic: '["Haskell Communities & Activities Report, 10th edition", "http://haskell.org/communities/", "Haskell.org SoC projects", "http://hackage.haskell.org/trac/summer-of-code/", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion", "The ICFP has ended. Who won?"]'
16:08:05 --- topic: set by dons on [Thu Aug 10 22:11:10 2006]
16:22:19 <tessier__> Anyone have any comments on how efficient it is to use ghc-smp as far as how much overhead threading introduced?
16:22:28 <tessier__> And to what degree will it thread?
16:23:54 <tessier__> If I apply something like map to a list of 100 integers and I just want to increment each element by 1 on a 100cpu machine would it actually create 100 threads?
16:24:12 <dcoutts> it does not automatically parallelise code
16:24:48 <tessier__> You mean you have to give it the --threaded option or do you mean that you have to do something specific in your code to make it parallelize?
16:24:56 <dcoutts> it just schedules Haskell threads on multiple OS threads simultatiously which means it can take advantage of multiple CPUs
16:25:28 <dcoutts> to use concurrency or parallelism in your code you need to do it explicitly
16:25:33 <tessier__> hrm
16:25:37 <dcoutts> for parallelism, see the par function
16:25:51 <dcoutts> and there's a whole module on paralell evaluation strategies
16:26:14 <tessier__> I was hoping that with big multi-core chips coming down the pipe functional programming would make it much easier to take full advantage of them.
16:26:24 <tessier__> Perhaps it still can, it just won't be quite as automatic as I thought.
16:26:34 <dcoutts> well it is much easier to parallelise pure functional code
16:26:41 <dcoutts> there are some research projects to do it mostly automatically
16:26:46 <dcoutts> but it's harder than it looks
16:27:02 <dcoutts> to do it automatically I mean
16:27:35 <tessier__> http://news.zdnet.com/2100-9584-6104832.html
16:27:44 <tessier__> Wondering how developments like this will affect functional programming
16:27:51 <dcoutts> it'll be cool
16:27:53 <dcoutts> that's what
16:27:57 <tessier__> I agree
16:28:10 <dcoutts> ghc ought to run on those mips things
16:28:22 <tessier__> Functional programming needs something to push it along. I hope this is it.
16:28:24 <dcoutts> Igloo is testing it at the moment on mips
16:28:31 <tessier__> nice
16:28:34 <dcoutts> though not on those 16x core things :-)
16:29:33 <xerox> http://video.google.com/videoplay?docid=8639494575376908189&q=analytical+engine
16:29:44 <newsham> tessier: how would that affect functional programming more or less than it affects all other computing technology?
16:30:00 <newsham> seems like its just another faster computer
16:30:05 <tessier__> Since power and heat etc. scale with the square of clockspeed I'm hoping multi core and lower clockspeed will take off and functional programming is in a great place to take advantage.
16:30:18 <tessier__> newsham: It is harder to take advantage of multiple cores with something like C isn't it?
16:30:27 <tessier__> You have to do a lot more work and be a lot more careful.
16:30:33 <newsham> so because of ease of parallel programming?
16:30:39 <tessier__> Right
16:31:05 <dcoutts> yes, that's the promise
16:31:05 <tessier__> At least that is my impression as a functional programming newbie. No side effects is a big win.
16:31:06 <newsham> there's already a large amount of multithreaded and multi-process programs.
16:31:10 <newsham> in many languages.
16:31:21 <tessier__> newsham: Sure there are. But at great expensive to time, money, and reliability.
16:31:40 <dcoutts> but those are often for embarassingly parallel tasks like web serving
16:31:47 <newsham> (also, you can run unrelated tasks on your cores, too, like your media player while you are running a compiler.. or various compiles which are independant)
16:31:58 <dcoutts> when every box is an 8 core thing, people will want all progs parallelised
16:32:24 <newsham> I dont entirely disagree..  but I dont think its a huge hurdle for traditional programming, either.
16:32:42 <newsham> run MS word and count the threads in that (not that you care if word scales with # of processors well)
16:32:55 <tessier__> newsham: I have often been told to avoid threads at all costs. In C/C++/Java/Python.
16:32:57 <dcoutts> IBM core cpus will be harder for C
16:33:09 <dcoutts> the local memory breaks the C memory model
16:33:12 <tessier__> Because you have to be very careful about locking and synchronizing on everything.
16:33:19 <newsham> tessier: thats generally good advice.. but when you get out into the big bad world, lots of people are using threads.
16:33:30 <tessier__> newsham: Sure. Like I said, at great expense.
16:33:39 <tessier__> With haskell it seems like you should be able to do so much more easily.
16:33:49 <newsham> (also, java people tend not to avoid threads :)
16:34:07 <newsham> c++ windows programmers, too..
16:34:11 <dottedmag> And Unix C/C++ folks do often avoid threads because of buggy pthreads on many platforms.
16:34:15 <dcoutts> java does provide better thread support than C
16:34:19 <int-e> dcoutts: C has a memory model?
16:34:23 <dcoutts> hah hah
16:34:25 <dcoutts> yeah
16:34:29 <tessier__> newsham: And look at how reliable Java/Windows are. :)
16:34:34 <dcoutts> it expects a flat memory
16:34:37 <int-e> you can't even compare pointers reliably.
16:34:40 <int-e> not really
16:34:45 * edwardk thinks that haskell would do very well on some form of massively multi-core simple stack machine based cpu
16:34:50 <newsham> tessier: and look a the market size.  goes to show that technology doesnt really matter :)
16:35:07 <tessier__> newsham: I'm not sure that market will persist for much longer.
16:35:20 <tessier__> Not that people will stop using computers.
16:35:31 <tessier__> But I have to believe that at some point people will get tired of expensive and unreliable software.
16:35:32 <dcoutts> int-e, well there's something in the C standard about not comparing char pointers with some others or something, but local memory is a different kettle of fish.
16:35:39 <newsham> tessier: you're way to optomistic
16:35:47 <int-e> I think it'll break a lot of C code, but the ISO C standard is, afaik, weak enough to support this.
16:35:53 <tessier__> newsham: Money is a big motivator.'
16:35:54 <edwardk> dcoutts: you mean restricted pointers?
16:36:09 <tessier__> Most people don't really live much of their lives on computers yet.
16:36:11 <newsham> tessier: yes it is, but technology is not.  good technology doesnt (necessarily) win in the mraketplacet.
16:36:32 <Korollary> yes it does
16:36:33 <tessier__> newsham: I know. But money does. And failures and bugs cost money.
16:36:36 <dottedmag> tessier__: to be tired of expensive and unreliable software it is required to know the software you use is expensive and unreliable. Most of people think "it's the software, it just can't be cheap and rock-stable".
16:37:01 <newsham> tessier: thats redundant.  "money wins in the marketplace".. thats sort of the definition of the marketplace.
16:37:08 <tessier__> newsham: Indeed it is.
16:37:15 <tessier__> newsham: And it's right. :)
16:37:18 <int-e> dcoutts: you are not allowed to compare pointers unless they point to the same 'memory object'. which is basically a compile time constant or something allocated by malloc or alloca.
16:37:43 <int-e> dcoutts: so I think in that regard it's fine, and even conversions from and to integers can be done. I don't see a problem.
16:38:14 <newsham> I dont see how that translate into people choosing superior technology.
16:38:26 <newsham> failures and bugs cost money..  but it is not th eonly cost.
16:39:02 <Korollary> There's no point in arguing about a single dimension of a product.
16:39:06 <newsham> you cant just say "better technology == less failures, failures == money, therefore the market favors better technologies"
16:39:19 <int-e> dcoutts: it'll break many C coders though, or rather, their assumptions :)
16:39:38 <newsham> the market doesnt optimize for the single cost of failures.  it optimizes over all of the costs.
16:40:16 <newsham> (not to mention non-market forces, transient effects, etc..)
17:01:53 <reilly> any hints on configuring lambdabot (local) for ghc-6.5 on mac intel?
17:02:03 <lennart> howdy
17:02:52 <Korollary> hi lennart
17:03:33 <Korollary> how are the haskell slaves in the cruel world of finance?
17:10:07 <lennart> we are surviving :)
17:12:20 <Korollary> how many are 'we'?
17:17:13 <lennart> well, i guess there are only two proper haskell slaves so far, me and Gabi
17:18:25 <xerox> To make a binary dist of ghc, do I need to do cp mk/build.mk.sample mk/build.mk and add BIN_DIST=1 to that last file?
17:25:31 <xerox> ``Mechanical and super-natty! Inspect the result and *if* happy; freeze, sell and get some sleep!'' hahaha
17:26:07 <eivuokko> You might need to set bunch of other BIN_DIST_ variables as well.
17:27:47 <xerox> Is it explained somewhere?
17:28:24 <eivuokko> No idea.
17:28:57 <eivuokko> Quickly glancing build-guide, there is nothing much for building binary distro
17:32:31 * SamB wonders how to get MAME to use a video mode that actually works
17:34:09 * mux notes MAME works just fine for him :)
17:35:03 <SamB> with svgalib?
17:35:14 <mux> nope, playing in x11
17:35:24 <mux> most of the time with the gl output plugin
17:35:27 <SamB> oh, well, I was hoping to get some extra speed...
17:35:38 <mux> you'll get some extra speed by using gl
17:35:42 <SamB> and have no GL with this amount of VRAM and size...
17:35:43 <mux> not by using svgalib :-P
17:35:48 <SamB> desktop size, that is
17:35:59 <mux> well x11 and xv output plugin is just fine otherwise
17:36:14 <SamB> slow computer :-(
17:36:21 <mux> heh.
17:36:35 <mux> MAME requires a fast machine, especially with recent games
17:36:46 <mux> it's not supposed to be fast but accurate :-)
17:36:51 <SamB> hmm
17:44:29 * SamB wonders if it is safe to start another X instance...
17:46:05 <xerox> What could ${INSTALL_STAGE:-3} expand in make?
17:50:21 <ihope> Igloo! What'd you do to lambdabot?
17:52:01 <xerox> Goedel:~/Code/ghc paolo$ tar -rvzf ghc-6.5.tar.gz
17:52:02 <xerox> Abort trap
17:52:05 <xerox> O_O
17:52:34 <int-e> cool.
17:56:04 <int-e> it does that here, too, for combinations of r with z. or r with j.
17:57:53 <xerox> Is ghc-6.5.20060821-i386-apple-darwin8.7.1.tar.gz a good name?
17:58:16 <xerox> GHC makefile doesn't want to collaborate and do it for me
17:58:21 <int-e> apple- is redundant, isn't it?
17:58:33 <int-e> it's good, I think.
17:58:36 <xerox> OK.
17:59:10 * xerox packs
18:00:49 <SamB> how do you control the size of X's framebuffer?
18:00:50 <xerox>  38M    ghc-6.5.20060821-i386-apple-darwin8.7.1.tar.gz
18:08:35 <int-e> xerox: what system and distribution is that? plain gnu tar doesn't do it. one of the patches that gentoo adds introduces the segfault.
18:09:08 <xerox> tar (GNU tar) 1.14
18:09:12 <xerox> OS X
18:09:23 <xerox> Intel
18:09:35 <int-e> right. hmm.
18:17:00 <xerox> ~~goodnight.
18:25:28 <int-e> xerox: I retract my remark about plain gnu tar not showing that behaviour.
18:26:11 <int-e> xerox: and the really funny thing is that it's caused by a line that reads,
18:26:21 <int-e>           abort (); /* Should not happen */
18:26:46 * SamB wonders why xorg freaks out about font paths being twice referenced if you start a second instance
18:28:56 <SamB> I also wonder why x-chat looks to have the same text size as usual...
18:32:37 <int-e> hmm, clear the fontconfig cache? *guesses*
18:33:54 <SamB> fontconfig cache?
18:34:27 <SamB> also, why does MAME not like my asoundlib headers...
18:34:53 <int-e> ~/.fonts.cache-1 here.
18:35:33 <int-e> hmm, but it's empty now, I must be remembering an old fontconfig version.
18:38:08 <dons> ?uptime
18:38:08 <lambdabot> uptime: 8 hours, 48 minutes and 32 seconds
18:38:14 <int-e> @botsnack
18:38:15 <lambdabot> :)
18:38:16 <dons> > map (+1) [1..10]
18:38:18 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
18:38:26 <Korollary> @hallelujah
18:38:26 <lambdabot> Unknown command, try @list
18:38:48 <dons> nothing was wrong with lambdabot, but one of the file servers went down, leading to IO errors
18:41:27 <SamB> oh, oops, wrong mame...
18:42:40 <Pupeno> @list
18:42:41 <lambdabot> list [module|command]. Where modules is one of:
18:42:41 <lambdabot> babel base compose dice dict djinn drhylo dummy elite eval fact fresh haddock help hoogle instances karma lambda localtime log more pl poll pretty quote search seen slap spell state system tell todo
18:42:41 <lambdabot> topic type unlambda url version vixen where
18:42:50 <Pupeno> @list babel
18:42:50 <lambdabot> babel provides: babel
18:42:59 <Pupeno> @list babel babel
18:42:59 <lambdabot> No module "babel babel" loaded
18:43:13 <Pupeno> @babel
18:43:13 <lambdabot>  bzzt.
18:43:17 <Pupeno> @babel
18:43:17 <lambdabot>  bzzt.
18:55:43 <dons> ?babel en pt hello
18:55:45 <lambdabot>  hello
18:56:10 <dons> ?babel en de all is well
18:56:11 <lambdabot>  alles ist gut
18:56:37 <Pupeno> ?babel de es alles ist gut
18:56:39 <lambdabot> babel module failed: IRCRaised Prelude.head: empty list
18:56:39 <Korollary> ?babel de en Wir brauchen den anderen auch
18:56:40 <lambdabot>  We need the other one also
19:15:14 <Tela> Anyone able to compile Happy 1.15 on X86 OS X?
19:17:18 <dons> how does it fail?/
19:17:22 <dcoutts> Yay, as of 30 sec ago, ghc-6.4.2 in gentoo is marked stable on all the major arches.
19:17:44 <dons> cool!
19:17:53 <dons> Tela: is this useful, http://hackage.haskell.org/trac/ghc/wiki/X86OSXGhc ?
19:17:55 <lambdabot> Title: X86OSXGhc - GHC - Trac
19:18:11 <Tela> I'm following that
19:18:22 <Tela> but on the configure step, it need Happy 1.15
19:18:26 <Tela> needs
19:18:30 <dons> ?where+ ghc-osx86 http://hackage.haskell.org/trac/ghc/wiki/X86OSXGhc
19:18:30 <lambdabot> Done.
19:18:33 <dons> Tela: right.
19:19:21 <sjanssen> @karma+ xerox -- I can actually build GHC now!
19:19:22 <lambdabot> xerox's karma raised to 16.
19:19:57 <Tela> Am I missing something? I don't see anything there showing how to fix happy :S
19:20:00 <dons> hey sjanssen
19:20:10 <dons> Tela, how does happy fail?
19:20:15 <sjanssen> hey dons
19:20:24 <dons> sjanssen: how's code?
19:20:25 <sjanssen> I suppose you want some code from me in about 13 hours
19:20:30 <dons> uhhu.
19:20:33 <dons> :)
19:20:36 <Tela> The Darcs version fails on the linking with a big list of undefined symbols
19:20:52 <Tela> The src tarball fails by rejecting the architecture
19:20:59 <Tela> Unrecognised platform: i686-apple-darwin8.7.1
19:21:06 <dons> src tarball you can edit the configure script by hand
19:21:12 <dons> (or copy the one from the darcs repo)
19:21:28 <Tela> Alright
19:21:54 <sjanssen> dons: code is going well, you don't have to worry (too much)
19:22:07 <dons> good ! :)
19:22:13 <dons> I'm not worried too much ;)
19:22:26 <sjanssen> is there a way too "unget" a few Word8's from a handle?
19:22:46 <dons> not that I know of
19:22:53 <dons> sounds possible though
19:23:22 <dons> you might need to do your own buffering :(
19:23:31 <sjanssen> reading in UTF-8 is a bit tricky, because you can end up in the middle of a character
19:23:38 <dcoutts> sjanssen, yes, you can.
19:24:15 <dcoutts> (I think)
19:24:25 <dons> unget?
19:24:28 <sjanssen> I recall seeing such a function in C
19:24:51 <dons> yep, ungetc(3)
19:25:05 <dcoutts> ah, no it was hLookAhead I was thinking of
19:25:18 <dcoutts> so you can only lookaead by one
19:25:26 <dons> ah
19:25:28 <dcoutts> or quivalently unget by one
19:25:48 <LordBrain> hey, in the context of haskell, what does RTS refer to?
19:25:51 <dcoutts> sjanssen, can you not read it in and then split?
19:25:58 <dcoutts> LordBrain Run Time System
19:26:17 <LordBrain> ok that's what i thought
19:26:29 <dcoutts> LordBrain, as in the bit of C code that manages memory allocation & collection, threads etc
19:26:41 <LordBrain> i see
19:26:55 <sjanssen> dcoutts: I suppose that depends on the API that I provide
19:27:15 <dons> xerox's hackage is looking good, http://hackage.haskell.org/~paolo/darcs/packages/
19:27:17 <lambdabot> Title: Index of /~paolo/darcs/packages
19:27:21 <dcoutts> sjanssen, so where would you need to read char by char as you get it from a handle?
19:27:35 <dcoutts> sjanssen, you can't provide lookahead of course
19:28:12 <dcoutts> oh, hGetChar
19:28:24 <dcoutts> well ok, but is there any other than that?
19:28:52 <dcoutts> sjanssen, I thought you were doing UTF32, so there's no multi-byte issue
19:29:04 <sjanssen> I guess there isn't a situation where I'll grab too much input, just too little
19:29:19 <sjanssen> dcoutts: I want to provide IO for UTF-8
19:30:08 <dcoutts> well, with an input buffer that is possible
19:30:42 <dcoutts> but you can always tell from looking at a byte if there should be a following byte
19:31:01 <sjanssen> right
19:31:10 <dcoutts> so actuall you can do it unbuffered
19:52:56 <dons> closures for java, eh?
19:53:27 <dylan> instead of anonymous classes? whee.
19:53:37 <dons> "For programming in the small, closures allow one to abstract an algorithm over a piece of code; that is, they allow one to more easily extract the common parts of two almost-identical pieces of code. For programming in the large, closures support APIs that express an algorithm abstracted over some computational aspect of the algorithm. We propose to add function types and closures to Java"
19:54:06 <Tela> Ugh. Okay, here's the problem: I need a version of GMP.framework that is set up for intel...
19:54:10 <dons> so java's now only 30 years behind the game ;)
19:54:20 <dylan> instead of 40?
19:54:27 <dons> hehe
19:54:55 <sjanssen> Tela: did you start from audreyt's build?
19:55:02 * dons is now waiting for the 'Monads for Java" paper to appear
19:55:08 <sjanssen> because I think the tarball automatically installs GMP for you
19:55:19 <dylan> dons: what about laziness in java?
19:55:19 <Tela> Yeah
19:55:24 <dons> "For programming in the smalle, monads allow one to abstract an algorithm .... We propose to add monads to Java"
19:56:07 * sjanssen can't wait for "Enterprise Java Monads"
19:56:24 <dylan> I wonder if I should start doing the 'hello world' of static typed functional languages... a language interpreter. ;)
19:56:47 <dons> hehe
19:57:00 <dons> ?remember sjanssen can't wait for "Enterprise Java Monads"
19:57:00 <lambdabot> Done.
19:57:05 <dylan> only took a few months and 3,000 lines of code to get something like JS without objects...
19:57:10 <dolio> I was amused by the guy at lambda the ultimate saying that Java already has closures in the form of anonymous inner classes, so this new proposal probably isn't needed.
19:57:15 <sjanssen> @quote sjanssen
19:57:16 <lambdabot>  can't wait for "Enterprise Java Monads"
19:57:20 <sjanssen> @quote sjanssen
19:57:21 <lambdabot>  can't wait for "Enterprise Java Monads"
19:57:31 <sjanssen> I need to work on being more quotable
19:57:33 <dons> dolio: yeah, that was my understanding too
19:57:36 <dylan> dons: easy anonymous inner class results in a .class file when compiled.
19:57:42 <dylan> err
19:57:43 <dylan> dolio:
19:57:55 <dylan> and without the word 'easy'.
19:58:42 <dylan> where could I find some medium-sized examples of parsec parsers?
19:58:45 <dolio> Yeah, well, he was arguing that Java isn't a functional language, so you don't need easy-to-use closures.
19:59:00 <dons> > let z = (\y x -> y ++ x) "closures" in z "forever"
19:59:03 <lambdabot>  "closuresforever"
20:00:51 <SamB> I thought not being a functional language meant merely that you did not *have* easy-to-use closures...
20:24:34 <dons> huh, http://www.smh.com.au/articles/2006/08/20/1156012411120.html?from=top5
20:24:34 <lambdabot> Title: Maths genius living in poverty - World - smh.com.au
20:25:06 <dons> sounds like Perelman could almost have been a functional programmer ;)
20:37:45 <jbalint> Hi, I am new at this. Is there a better way to write this: cntChars c (x:xs) = if x == c then 1 + cntChars c xs else 0 + cntChars c xs
20:38:46 <dons> you're trying to count the occurences of 'c' in a string?
20:39:00 <dons> > length . filter (=='x') $ "hasexkelllxx"
20:39:03 <lambdabot>  3
20:39:40 <dons> > foldl' (\c a -> if c == 'x' then 1+a else a) 0 "hasexkelllxx"
20:39:41 <lambdabot>  add an instance declaration for (Num Char)
20:40:09 <dons> > foldl' (\a c -> if c == 'x' then 1+a else a) 0 "hasexkelllxx"
20:40:11 <lambdabot>  3
20:40:19 <jbalint> what is $ called?
20:40:26 <dons> hmm "dollar" ?
20:40:30 <jbalint> yeah, what is that
20:40:50 <dons> its function application with low precedence, so you can avoid some parenthesis
20:41:00 <dons> > length $ "xy" ++ "zz"
20:41:01 <lambdabot>  4
20:41:05 <dons> > length ("xy" ++ "zz")
20:41:06 <lambdabot>  4
20:41:16 <dons> ?type ($)
20:41:17 <lambdabot> forall b a. (a -> b) -> a -> b
20:41:24 <dons> takes a function, and an argument, and applies them
20:41:29 <dons> f $ x = f x
20:42:09 <jbalint> ok, thanks for the info
20:42:33 <dons> do you understand the fold or filter implementations of your cntChars function?
20:43:08 <jbalint> No, I don't really care to count any chars, it's just an excerise I saw. But I am reading about monads in the wikibook and then I will review the rest of your implementations.
20:43:37 <dons> > filter (=='x') "hasexkelllxx"
20:43:40 <lambdabot>  "xxx"
20:43:45 <dons> > length (filter (=='x') "hasexkelllxx")
20:43:46 <lambdabot>  3
20:43:53 <jbalint> ah, so whats .
20:44:02 <dons> function composition
20:44:10 <dons> it takes two functoins, combines them, producing a new function
20:44:31 <jbalint> right, i couldnt write it because i am not pefectly familiar with the precedences yet but i see what it means now
20:44:39 <jbalint> whats \a
20:44:56 <dons> that's a lambda abstraction, an anonymous function whose argument is 'a'
20:45:02 <dons> > (\x -> x) 1
20:45:03 <lambdabot>  1
20:45:04 <sjanssen> @pl \i e -> (i + 1, f i e)
20:45:04 <lambdabot> ap ((.) . (,) . (1 +)) f
20:45:14 <dons> > let f x = x in f 1
20:45:15 <lambdabot>  1
20:45:38 <dons> or, for exampe
20:45:46 <dons> > map (\x -> x + 1) [1..5]
20:45:47 <lambdabot>  [2,3,4,5,6]
20:46:19 <jbalint> ok, thanks. this is enough for now, or you will be keeping me up all night
20:46:25 <dons> hehe
20:46:37 <dons> you might want to check out the YAHT tutorial
20:46:39 <dons> ?where yaht
20:46:39 <lambdabot> http://www.cs.utah.edu/~hal/htut/
20:46:50 <dons> its the most recommended place to begin
20:46:51 <Korollary> let me tell you about a business opportunity with a Nigerian family, then.
20:47:09 <jbalint> i have this book called: The Haskell Road to Logic, Math and Programming
20:47:18 <dons> ah, that's also good
20:47:29 <jbalint> Great, that's good to know.
20:47:53 <Korollary> the wiki is great. Most overlooked by learners.
20:48:06 <jbalint> what wiki?
20:48:24 <dons> Korollary: you mean the wikibook? or the haskell wiki?
20:48:26 <Korollary> haskell.org is actually awiki
20:49:25 <Korollary> the haskell-cafe mailing list is very responsive to beginners.
20:50:36 <syntaxfree> Can I have "hierarchical" names for my own modules?
20:50:49 <syntaxfree> Like, Stravinsky.SQL, Stravinsky.HTML, etc?
20:51:12 <dolio> Yes.
20:51:13 <dons> syntaxfree: certainly
20:51:25 <syntaxfree> module Stravinsky.SQL where?
20:51:33 <dons> right
20:51:42 <dons> in the file Stravinsky/SQL.hs
20:51:46 <syntaxfree> ahhh.
20:51:48 <syntaxfree> cool.
20:51:59 <dons> examples: http://www.cse.unsw.edu.au/~dons/code/lambdabot/Lib/Serial.hs
20:52:04 <syntaxfree> I'm going to attempt some code generation.
20:52:16 <syntaxfree> PHP and MySQL code generation from blueprints in CSV files.
20:52:41 <syntaxfree> I wanted an online bibliography system for myself, one that'd generate BibTeX files later.
20:52:50 <syntaxfree> (So I could annotate bibliography entries in any library)
20:53:34 <syntaxfree> but the BibTeX specification is so large I thought it'd be fun to automate the process of generating code to store certain tabular-like data structures.
20:55:19 <syntaxfree> (and forms to handle it,  etc. etc.)
20:55:33 <syntaxfree> any suggestions for project name?
20:56:08 <dons> ?fresh
20:56:09 <lambdabot> Hae
20:56:12 <dons> A
20:56:16 <dons> ?fresh
20:56:16 <lambdabot> Haf
20:56:19 <dons> perhaps?
20:56:24 <syntaxfree> @fresh
20:56:24 <lambdabot> Hag
20:56:25 <dons> ?fresh
20:56:25 <lambdabot> Hah
20:56:29 <dons> maybe?
20:56:41 <LordBrain> what does @fresh do?
20:56:41 <syntaxfree> I'm thinking of something russian.
20:56:50 <LordBrain> oh
20:56:53 <dons> LordBrain: generates unique haskell project names
20:57:12 <LordBrain> interesting
20:57:19 <dons> :) its a joke
20:57:24 <LordBrain> hehe
20:57:53 <syntaxfree> (I might have some form of ADD. I need to write some bibliography-intensive projects. Then I proceed to try to automate some of the process of organizing bibliographies. Then I proceed to try and automate generating the code to etc. etc.)
20:57:53 <LordBrain> they all start with H?
20:58:02 <syntaxfree> They all start with Ha.
20:58:08 <syntaxfree> Hawiki, Haskore, etc.etc.
20:58:22 <dons> ?fresh
20:58:23 <lambdabot> Hai
20:58:25 <dons> seems so!
20:58:39 <dons> these are all good names, hag haf hai
20:58:41 <syntaxfree> now, suggestions for a PHP/SQL code generator?
20:58:47 <syntaxfree> @fresh
20:58:48 <lambdabot> Haj
20:58:49 <syntaxfree> @fresh
20:58:49 <lambdabot> Hak
20:58:53 <syntaxfree> @fresh
20:58:53 <lambdabot> Hal
20:58:54 <dons> hasql?
20:58:56 <syntaxfree> NOW, there's a name!
20:59:17 * dons is surprised no one's written "Hasql" yet.
20:59:30 <syntaxfree> It's  not Hasql proper.
20:59:41 <dons> ?google hasql
20:59:44 <lambdabot> http://members.tripod.com/~sproot/hasql.htm
20:59:45 <lambdabot> Title: HaSQL Project
20:59:48 <dons> ha!
21:00:04 <syntaxfree> It's this very unpretentious, for-personal-use-mostly parallell of Ruby on Rails, I think.
21:00:05 <dons> silly me. HaSQL is a Haskell to ODBC interface
21:00:14 <dons> ?where+ hasql http://members.tripod.com/~sproot/hasql.htm
21:00:14 <lambdabot> Done.
21:01:13 <syntaxfree> Boris it is.
21:03:36 <dons> ?users
21:03:43 <lambdabot> Maximum users seen in #haskell: 220, currently: 219 (99.5%)
21:05:17 <syntaxfree> will report to the channel later.
21:05:33 <syntaxfree> Do you think it's appropriate to create a wiki page for the project, when I have some code to show?
21:06:00 <dons> sure
21:07:29 <syntaxfree> are types created inside a module available when I import it elsewhere?
21:07:47 <dons> if you export them, yes.
21:07:57 <syntaxfree> :~
21:07:59 <dons> (or if you have no explicit export list)
21:08:07 <lispy> @type (:~)
21:08:07 <dons> so, for the simmple case: module M where
21:08:11 <dons> then they're all exported
21:08:13 <lambdabot> Not in scope: data constructor `:~'
21:08:18 <syntaxfree> ah, ok!
21:08:18 <lispy> ;)
21:08:19 <syntaxfree> :)
21:11:27 <syntaxfree> paste.lisp.org no longer auto-announces in channels?
21:11:38 <dons> ?paste
21:11:38 <lambdabot> http://paste.lisp.org/new/haskell
21:11:42 <dons> seesm to, doesn't it?
21:11:56 <lispy> it was evenbroken about 2 days ago
21:12:02 <dons> 06.08.19:22:43:23 <lisppaste2> petekaz pasted "ghc error message" at http://paste.lisp.org/display/24423
21:12:04 <lispy> so it might be a bug?
21:12:07 <dons> could be
21:12:24 <dons> though, it was working yesterday
21:12:26 <lisppaste2> syntaxfree pasted "huh?" at http://paste.lisp.org/display/24473
21:12:31 <dons> and today
21:15:03 <syntaxfree> it wasn't even a .LHS file.
21:19:07 <petekaz> I'm working on a haskell syntax aware pastebin.  I just started working on it.  It'll colorize haskell code now, that's it.  It can't save pastes or share them yet, I've wasted a ton of time on CSS (and I have to see if it works on IE).
21:19:16 <petekaz> http://www.kazmier.com/~kaz/pastebin.cgi
21:19:49 <dons> nice idea!
21:20:00 <dons> you could just use hscolour for the sytax highlighting
21:20:03 <dons> ?where hscolour
21:20:03 <lambdabot> I know nothing about hscolour.
21:20:04 <petekaz> I did.
21:20:12 <petekaz> Did you try pasting something?
21:20:13 <dons> ah good
21:20:20 <dons> i'll try
21:20:46 <dons> ok. but there's no 'submit' button?
21:20:55 <petekaz> Yeah, 'create'.
21:21:02 <dons> oh, it seeds javascript?
21:21:03 <petekaz> Up above in the navbar.
21:21:12 <petekaz> yes. I hate buttons.
21:21:23 <dons> doesn't work in w3m then...
21:21:36 * dons turns on firefox
21:21:47 <lispy> 'seeds javascript' ?
21:21:51 <petekaz> well, I'll make it work with <a> tags so it'll work with w3m.
21:21:51 <lispy> oh
21:21:51 <lispy> needs
21:21:55 * lispy is slow today
21:22:10 <dons> nice!
21:22:34 <dons> though white on black is a bit hard on the eyes
21:22:47 <petekaz> white?
21:22:52 <petekaz> it should be colorized
21:23:03 <dons> yeah, colors on black
21:23:11 <dons> maybe this would be easier : http://cgi.cse.unsw.edu.au/~dons/blog
21:23:11 <lambdabot> Title: Haskell, hacking and other stuff
21:23:18 <dons> (hscolour used on white bg)
21:23:24 <petekaz> well, it's just a CSS style that can be tweaked.
21:23:30 <dons> yeah
21:23:39 <dons> ?karma+ petekaz -- haskell paste!
21:23:40 <lambdabot> petekaz's karma raised to 2.
21:23:48 <petekaz> I gotta go to bed, my wife is yelling at me.
21:23:53 <dons> heh ok
22:00:47 <Pupeno> ?karma+ petekaz -- haskell paste!
22:00:47 <lambdabot> petekaz's karma raised to 3.
22:12:21 * edwardk waves ello.
22:16:42 <Pupeno> hi edwardk
22:20:40 <edwardk> how goes?
22:21:14 * edwardk was thinking about naming his little intermediate language after the guy who came up with the first non-commutative intuitionistic linear logic.. but the bastard is still alive ;)
22:21:46 <Korollary> Name it after a hot chick.
22:22:30 <edwardk> heh
22:22:38 <edwardk> my fiancee might get offended ;)
22:22:59 <edwardk> and naming it after her would seem like a cheap shot =)
22:23:03 <edwardk> or a cop out
22:24:00 <lispy> named it Madonna
22:24:06 <lispy> or however you splel it
22:24:09 <edwardk> heh
22:24:13 * lispy hates the keyboard tonight
22:24:25 <edwardk> just found it amusing that Lambek is still alive, he's gotta be ~85 now.
22:24:58 <edwardk> 84 it seems
22:25:03 <edwardk> so i guess that wasn't far off
22:29:44 <lispy> that's wa off
22:29:44 <lispy> esp. when you consider the 9 month incubation for humans
22:30:08 <edwardk> heh
22:30:47 <dons> ?remember Wadler Write down the definition of a polymorphic function on a piece of paper. Tell me its type, but be careful not to let me see the function's definition. I will tell you a theorem that the function satisfies.
22:30:47 <lambdabot> Done.
22:31:18 <edwardk> dons: the free theorems paper?
22:31:22 <dons> yep
22:31:54 <edwardk> too bad he didn't consider pointed types =/ though i guess there have been enough published since to patch that hole.
22:42:29 <edwardk> anyone here know anything about noncommutative sequence calculus or the calculus of structures?
22:43:42 <edwardk> anyone here awake? =)
22:44:17 <Korollary> I am
22:44:23 <Korollary> But I know nothing
22:44:46 <edwardk> sok.
22:45:10 <dons> ?yow!
22:45:11 <lambdabot> Will this never-ending series of PLEASURABLE EVENTS never cease?
22:45:32 <Korollary> I am watching Comedy Central's roast of William Shatner
22:45:54 * edwardk is trying to get some elements of a non-commutative intuitionistic linear logic without giving up sequent calculus for the comparatively hideous calculus of structures. =/
22:46:08 <edwardk> in otherwords work in a lambda calculus without exchange
22:46:43 <edwardk> (or rather no exchange weakening or contraction, unless you add them back in via modalities)
22:47:36 <edwardk> i swear there is a good motivation in there somewhere ;)
22:52:47 <lispy> edwardk: you're speaking in tounges as near as i can tell :)
22:52:52 <lispy> tongues?
22:52:54 * lispy can't spell
22:52:59 <edwardk> lispy: the latter
22:53:10 <lispy> thanks
23:08:16 <tibbe> @seen dons
23:08:16 <lambdabot> dons is in #haskell and #haskell-overflow. I last heard dons speak 23 minutes and 5 seconds ago.
23:08:35 <tibbe> dons, could you explain the issue with building FPS and cbits?
23:08:51 <tibbe> dons, I'm trying to debianize the package
23:09:59 <edwardk> jean yves girard seems to have posted a few hundred pages on logics (linear and other wise) in english at http://iml.univ-mrs.fr/~girard/coursang/coursang.html
23:10:01 <lambdabot> Title: The Blind Spot
23:10:24 <edwardk> in case anyone around here cares about such things =)
23:18:41 <dons> tibbe, issue?
23:18:50 <dons> it should just build under cabal and link to a archive magically
23:20:16 <dons> i thought fps was already debianised
23:20:42 <dons> http://darcs.complete.org/debian/haskell-fps/ ?
23:20:43 <lambdabot> Title: Index of /debian/haskell-fps
23:23:49 <kfish> dons: i've got a new logo for you:
23:23:51 <kfish> http://msig.info/web2v2/(reflect)Data.ByteString.Lazy2.0BETA.png
23:25:54 <dons> heh!
23:26:02 <dons> 2.0 beta??
23:26:24 <kfish> it's a requirement for first-round investor funding
23:26:30 <wolverian> haha
23:26:31 <tibbe> dons, I have to be in the fps dir to install the .deb file or it'll choked on cbits
23:29:39 * edwardk definitely thinks girard has run out of things to do in his old age: http://iml.univ-mrs.fr/%7Egirard/mustard/page1.html
23:29:40 <lambdabot> Title: Untitled Document
23:31:01 <dons> tibbe: ah yes. someone else reported this. but surely its a Cabal bug?
23:31:17 <dons> kfish: hehe investor funding eh?
23:50:00 <dolio> Ahh... Paraphrased: 'Java shouldn't have closures because they're too complicated for the legions of corporate programmers to use.'
23:50:06 <dolio> I like that argument.
23:51:30 * edwardk is rather sick of the legions of corporate programmers ;)
23:51:59 <dolio> 'Besides, nobody has actual examples of where they're more useful than using interfaces and classes for everything.' :)
23:52:06 <edwardk> heh
23:54:09 <Itkovian> mening
23:54:12 <Itkovian> erm, meuning
23:57:07 <newsham> edward: i heard they dont like you much either ;-)
23:57:38 <edwardk> newsham: fair enough =)
23:57:52 <edwardk> I am just sick of the fact that everything in the world is dumbed down.
23:58:08 <edwardk> We have to dumb it down for this group or that group or the other group
23:58:12 <newsham> progress..  its slow but sure...
23:58:14 * edwardk sighs.
23:59:08 <dons> mustard watches, eh? nice!
23:59:50 <edwardk> No, the Flynn effect has run its course. Dysgenics says it'll only get worse from here ;)
