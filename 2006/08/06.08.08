00:01:15 <glguy> good night everyone
00:53:49 <lokadin> hey
00:58:34 <ValarQ> hi
00:59:30 <lokadin> i have a  convertToUsable :: [String] -> [String] , when i do in a case statment within the function "zo" -> [x , (head xs)] : (convertToUsable $ tail xs), then it tells me that expected type is [[String]], though tail xs is [String], (from my understanding)
01:00:33 <lokadin> hmmm
01:00:50 <lokadin> this whole programming thing is terribly long
01:01:31 <lokadin> .uinai
01:01:35 <lokadin> oh well
01:01:44 <lokadin> i guess there is no way of progressing without utilizing it
01:01:52 <int-e> I think you mean x : (head xs) : (...) or [...] ++ (...)
01:02:01 <lokadin> hmmm
01:02:10 <lokadin> that could be it
01:02:14 <lokadin> one sec
01:02:17 <int-e> [...] : ... is always a list of lists.
01:03:22 <lokadin> hmmm, well didn't change the error message, i think that was necessary anyways though
01:03:46 <lokadin> i might have to rethink how i'm doing this entire program though
01:03:54 <lokadin> cause it just isn't happening
01:04:31 <int-e> we'd need more information to help with that.
01:05:22 <lokadin> well it's really a humoungous project, i just don't know where to start, cause i'm afraid if i try explaining all of it nothing will ever get done and so on
01:05:55 <ValarQ> can't you isolate the function causing problems?
01:06:05 <lokadin> well i don't really have any yet
01:06:08 <lokadin> that's the problem
01:06:44 <lokadin> i guess i do, but they are really nothing impressive
01:07:07 <lokadin> i guess since they already work i can just improve them
01:07:23 <lokadin> i'll go look into it. thanks for the support :)
01:10:37 <l33t_h4x0r> i kno more about computas than u all im da best hacker eva
01:11:09 --- mode: ChanServ set +o shapr
01:11:53 <lokadin> l33t_h4x0r: maybe you can write this for me then :)
01:12:02 <l33t_h4x0r> wots that?
01:12:56 <lokadin> it shouldn't be that difficult, i just need to accept a line of text, then break it up into sections,
01:13:13 <lokadin> and the sections all have beginning and end signifiers
01:13:13 <l33t_h4x0r> in wot lang?
01:13:19 <lokadin> haskell preferably
01:13:23 <lokadin> but i don't actually care
01:13:26 <l33t_h4x0r> pfft =/
01:13:31 <l33t_h4x0r> i dun code lame languages.. kthx
01:13:42 <lokadin> well what language you wanna code it in?
01:13:56 <dons> ?elite i kno more about computas than u all im da best hacker eva
01:13:56 <l33t_h4x0r> i use x86 asm for everythin
01:13:57 <lambdabot> I KNO MOr3 A8OU7 COMPUT4z0rz tHAN U a11 i/\/\ d4 83zt HAckER e\/a
01:14:02 <dons> that's how you spell it
01:14:07 <l33t_h4x0r> lmfao
01:14:17 <ValarQ> :)
01:14:24 <shapr> l33t_h4x0r: Would you rather use monads or arrows for parsers?
01:14:40 <l33t_h4x0r> but to keep _lines_ of code to a minimum.. u cud use php's explode()
01:14:43 <lokadin> k so you think you can handle say making a sentance like "lo nanmu ku cu klama" into "lo nanmu ku" "cu klama"
01:14:43 <l33t_h4x0r> go google it -_-
01:14:45 <int-e> shapr: :)
01:15:29 --- mode: ChanServ set +o dons
01:15:32 <shapr> l33t_h4x0r: If you write x86 asm, how would you compare the instruction sets of the Itanium to the x86-64 extensions?
01:15:37 <lokadin> so if you had an app that would accept the string, and return just the strings say seperated by commas i'd like that
01:15:47 <shapr> lokadin: Parser monad would do it for you.
01:16:27 <l33t_h4x0r> as i say.. look into php's explode() .. then also count() and run a for loop to append each word with ','
01:16:31 <lokadin> shapr: really? i was thinking it might but i can't begin to compredend how to use it. i'll go look at the docs some more .a'u
01:16:42 <l33t_h4x0r> u can explode it using the space as a token
01:16:47 <shapr> je'e
01:17:03 <shapr> l33t_h4x0r: How would you handle backtracking?
01:17:33 <lokadin> shapr: Language.Haskell.Parser ?
01:17:37 <shapr> Or what about ambiguous parses?
01:17:39 <l33t_h4x0r> wot the fuck r u on shapr?
01:17:44 <l33t_h4x0r> lmmfao
01:17:49 <dons> *sigh*
01:17:53 <shapr> l33t_h4x0r: It's standard computer stuff, you know this, right?
01:18:08 <l33t_h4x0r> maybe if uve had some professor teach u bullshit in uni yea
01:18:18 <l33t_h4x0r> i learned on my own.. k.. i dun give a shit bout terms :p i just code
01:18:23 <shapr> I've never had any computer classes.
01:18:27 <shapr> I learned on my own also.
01:18:43 <shapr> lokadin: Read the Parsec tutorial, it'll tell you how to create a parser.
01:18:44 <MarcWeber> I need your help ( http://rafb.net/paste/results/peiDJ028.html ) Line 56 makes trouble (see error at the bottom) I can't understand this error message as this line is working fine on line 39
01:18:55 <lokadin> shapr: kk
01:18:57 <mcnster> l33t_h4x0r, which gets tripped first, #GP on cs limit violation or #PG on not present given the two apply to the same opcode position?
01:19:00 <RyanT5000> l33t_h4x0r: write a C++ compiler
01:19:04 <shapr> lokadin: After that, you'll be able to turn the yacc grammar into a parsec parser.
01:19:09 * int-e thinks Itanium is a dead end - explicit parallelism is an interesting idea but a VLIW architecture isn't the right way to do it.
01:19:22 <ValarQ> l33t_h4x0r: could you help me port GHC to the AVR architecture?
01:19:24 <int-e> but we'll see :)
01:19:28 <shapr> int-e: True, but the Itanium does have some amazingly efficient opcodes.
01:19:32 * shapr laughs
01:19:36 <mcnster> i got's 2 no
01:19:54 <shapr> Mister h4x0r runs away!
01:19:59 <ValarQ> guess i have to port ghc myself, oh well
01:20:06 <mcnster> bah.  amateur
01:20:07 <lokadin> shapr: where, is the parsec tutorial?
01:20:18 <shapr> @google parsec tutorial daan
01:20:20 <int-e> Hmm. Now I wonder how many Haskell programmers actually know and occasionally use assembly language.
01:20:22 <mcnster> (the answer btw is #GP)
01:20:22 <lambdabot> http://www.ainewsletter.com/newsletters/aix_0605.htm
01:20:23 <lambdabot> Title: AI Newsletter
01:20:30 <shapr> um, wrong url..
01:20:38 <shapr> mcnster: Nifty trivia
01:20:40 <therp_zivi> nice parody of a script kiddy hacker.. at least I hope it was a parody, l33t
01:20:41 <MarcWeber> http://www.cs.uu.nl/people/daan/download/parsec/parsec.html
01:20:54 <lokadin> MarcWeber: ki'e
01:20:57 <shapr> therp_zivi: Probably not a parody.
01:21:19 <shapr> lokadin: ma nuzba
01:21:21 <mcnster> shapr, that's on a amdx2.  your mileage with pentium4 may vary :)
01:21:44 <ValarQ> int-e: i guess there isn't many programmers at all that "occasionally use assembly"
01:22:09 <int-e> mcnster: hmm. the page fault would come from loading the cs segment descriptor?
01:22:25 <MarcWeber> Do you have any idea what might be wrong? Am I right that it should be a IO monad on line 56?
01:22:34 <mcnster> int-e, nobody said anything about loading descriptors.  i'm talking fetch cycle
01:23:13 <int-e> mcnster: yes, but that's the only way I see that a page fault could apply to that instruction fetch.
01:23:29 <int-e> as you described it.
01:23:51 <int-e> ah, wth. it's not important :)
01:23:52 <shapr> In any case, that whole incident was amusing. l33t_h4x0r was out geeked on #haskell, with very little effort from the #haskell regulars.
01:24:03 <dons> heh
01:24:10 --- mode: ChanServ set -o dons
01:24:13 --- mode: shapr set -o shapr
01:24:19 <mcnster> int-e, given 2 byte insn where 1st byte is at segment and page limit...
01:24:27 <Itkovian> hi shapr!
01:24:28 <mcnster> int-e, and page is np
01:24:48 <int-e> mcnster: it shouldn't even start fetching then.
01:24:57 <shapr> hoi Itkovian, hoe gaat het?
01:25:20 <MarcWeber> I'm struggling for hours now
01:25:21 <mcnster> int-e, you want to run the code on your box and see?  i've been writing it all evening
01:25:40 <shapr> @remember l33t_h4x0r maybe if uve had some professor teach u bullshit in uni yea \n i learned on my own.. k.. i dun give a shit bout terms :p i just code
01:25:40 <lambdabot> Done.
01:26:02 <int-e> mcnster: I'd *expect* the GP to come. I'd check the manuals though.
01:26:47 <mcnster> int-e, i don't do manuals.  i only do actual testsuites since mariner 2 blew up 9 seconds after launch
01:26:52 <int-e> (sorry. it has to start fetching of course.)
01:27:06 * int-e remembers the channel's name.
01:27:37 <Itkovian> shapr: just restarted working so ... busy :-)
01:27:45 <shapr> Has anyone tried HFuse? I was wondering about using reiserfs as an efficient database backend for Haskell. Is that not likely to work?
01:28:08 <mcnster> int-e, np :)
01:28:51 <shapr> Itkovian: Did you tune that code any further?
01:29:01 <Itkovian> shapr: I made some more improvements to my code - Integers are now read directly from fps, by duplicating the readInt stuff
01:29:16 <neologism> pls.. tsp = tablespoon or teaspoon?
01:29:23 <Itkovian> so yeah, it's getting to be workable I think
01:29:32 <shapr> neologism: I think teaspoon?
01:29:51 <neologism> thnx
01:29:54 <shapr> Itkovian: Good to hear. I think being able to explicitly see the laziness of that code would help. Did you end up trying --show-iface?
01:30:26 <Itkovian> shapr: yes, most of the stuff is lazy ...
01:34:47 <shapr> musasabi: Did you ever compare the performance of your arrow parser to that of Parsec?
01:36:26 <int-e> ?users
01:36:28 <lambdabot> Maximum users seen in #haskell: 221, currently: 196
01:38:27 <shapr> That's a neat plugin, who wrote it?
01:38:43 <shapr> Maybe help should include credits? :-)
01:39:49 <dons> yeah, just a small extension to the @seen plugin
01:40:03 <dons> only been running for a few days
01:40:13 <dons> so i suspect we'll beat our 226 record this week :)
01:42:48 <shapr> Spiffy!
01:43:39 <shapr> btw, was it ever publically announced who got the GHC Support Engineer job?
01:43:58 <dons> not yet
01:44:21 <shapr> In case it wasn't, Igloo got the job! congrats Igloo!
01:44:33 <shapr> SPJ announced it at AngloHaskell.
01:45:14 <dons> freaky. people talking business models on haskell-cafe. what ever is happening to the world??
01:46:02 <dons> i mean: business+haskell. that's weird ;)
01:46:26 <eivuokko> Do you mean the thread around licensing etc?
01:46:27 <shapr> I'd say people are getting their C++ blinders off...
01:46:35 <shapr> heippa hei eivuokko!
01:46:40 <shapr> It was nice to meet you at AngloHaskell!
01:47:00 <eivuokko> Hiya shapr.  Likewise :)
02:01:28 <musasabi> shapr: yes, I did some comparisons. But I don't remember the results.
02:02:07 <Itkovian> shapr: for a 70M trace, it takes now about 40 seconds (user time) when pushing the output to a file
02:06:52 <musasabi> Is it possible to look at Recent changes in haskellwiki so that each page is only listed by the most recent change made to it?
02:10:19 * mcnster grumbles... damned amd manual is wrong wrong wrong
02:13:44 * int-e comforts mcnster 
02:14:18 <giksos> I need a parser in my program for reading in haskell values. Is it possible to reuse some ghci api?
02:15:50 <mcnster> giksos, what kind of values?
02:17:33 <giksos> mcnster: values of some haskell types, like "Foo 1 2". I don't want to use default read instances, because for record syntax types they create record syntax reads, so I'd have to write "Foo {x = 1, y = 2}".
02:18:54 <mcnster> giksos, might Language.Haskell.Parser suit your needs?
02:19:33 <giksos> I'm not sure. First, it only parses whole modules, second it gives me a syntax tree, not a value.
02:20:02 <mcnster> hmm
02:20:25 <lokadin> say i'm having trouble getting one of the examples in the Parsec Tutorial to works.
02:20:30 <lokadin> work*
02:21:17 <lokadin> the one that uses Infix, when i load it into ghci, it says Infix does not exist and neither does AssocLeft
02:23:35 <lokadin> any ideas?
02:23:59 <mcnster> lokadin, been a while since i used parsec...
02:24:29 <lokadin> @hoogle buildExpressionParser
02:24:29 <lambdabot> Text.ParserCombinators.Parsec.Expr.buildExpressionParser :: OperatorTable tok st a -> GenParser tok st a -> GenParser tok st a
02:25:05 <lokadin> ah, i think i answered my own question .oiro'e
02:25:10 <mcnster> cool
02:30:19 <Ulfalizer> http://www.youtube.com/watch?v=n0vEJneflBw is pretty interesting. i've noticed the same thing when watching old speeches and interviews.
02:30:20 <lambdabot> Title: YouTube - What a difference 10 years makes!
02:35:17 <gds> Ulfalizer: I don't have sound on this box - can you summerise?
02:38:31 <Ulfalizer> gds: basically what the text says. ten years ago he spoke fast, didn't have any problems with complicated sentences, didn't mess up every other sentence somehow, etc.
02:38:53 <Ulfalizer> the difference is quite stunning, and i've seen many other examples apart from that video
02:39:05 <norpan> but does he do haskell?
02:39:17 <Ulfalizer> he probably did 10 years ago :P
02:39:19 <int-e> who is it?
02:39:28 <Ulfalizer> int-e: dubya
02:39:50 <int-e> okay.
02:40:08 <int-e> now I don't have to watch it ;)
02:40:45 <gds> I heard that he lost his first go at the Texas govenorship to a "local guy" who derided him for being a slick harvard city-boy....
02:41:15 <gds> The implication of the article was that a lot of the more recent bumblingness is an affectation, to appear less threatening.
02:42:15 <int-e> Are you insinuating that the guy is actually smart? I'd never have guessed.
02:43:00 <pstickne> It is dangerous to label people as being stupid. In the sense of lacking intelligence.
02:45:00 <gds> int-e: It's a possibility - he's hung on to power for as long as anyone in that country is allowed to - it's difficult to tell. Just like the Pink Panther ;)
02:45:11 <Ulfalizer> gds: that sounds a bit far-fetched though. there's a difference between bumblingness and plain ineptitude. it would be one thing if he just spoke slowly and carefully, but i don't think he messes up sentences on purpose.
02:45:41 <gds> indeed - and it could be a duff theory, or it could be a combination of a number of things.
02:45:49 <int-e> pstickne: Heh, just because the guy is stupid doesn't mean he's not dangerous. If he is stupid he has smart advisors.
02:46:59 <pstickne> int-e, very true :)
02:47:59 <pstickne> I just get annoyed when other people call (most usually) GB dumb. You might not like his politics and he might seem to less-than-ideal oratory skills but... *shrug*
02:48:16 <pstickne> where is my have? :(
02:49:58 <roconnor> Yea, GB is a simple man with simple thoughts.
02:53:41 <Itkovian> I did like the first points he made in the 10-year-ago speech on the funding of schools
02:53:51 <Itkovian> I'd rather have him fund school than the military
02:57:13 <lokadin> can i make a :: Parser [String]
02:57:13 <lokadin> ?
02:58:03 <lokadin> i just don't know how to actually parse anything in it
02:59:25 <lokadin> and the error message isn't really helpful cause it says the entire function is wrong :(
03:04:25 <lokadin> oh well
03:05:05 <lokadin> i'm going to go to sleep, i think i've accomplished at least a little bit today :)
03:20:57 <dmhouse> "
03:21:02 <dmhouse> Oops :)
03:21:04 <dmhouse> "In the remotest regions, beyond the Functional Kingdoms, lies a fabled realm called Lambda the Ultimate. In this place it is said that there are no nouns at all, only verbs! There are "things" there, but all things are created from verbs, even the very integers for counting lambs, which are the most popular form of trading currency there, if the rumors speak truth."
03:22:48 <dons> so at the point the java people think he is just joking ..
03:22:56 <dons> s/at this point/
03:23:09 <MarcWeber> @tell lokadin No you can't, Parser <input token> <state> <resulttype>, See also CharParser which is a synonym for Parser Char ...
03:23:10 <lambdabot> Consider it noted.
03:25:04 <dmhouse> That quote was from http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html, which is a nice read.
03:25:04 <lambdabot> Title: Stevey's Blog Rants: Execution in the Kingdom of Nouns
03:26:20 <gds> dons: Can I ask about the serialised state of the lambdabot "Seen" plugin?
03:26:42 <gds> in particular, why would the latest patches cause my copy to do:
03:26:43 <dons> sure.
03:26:46 <gds> "Initialising plugins ..............................*** Exception: exit: ExitFailure 1"
03:26:48 <dons> it will break it :)
03:26:56 <dons> since the type of the state changed
03:26:59 <gds> Oh good :)
03:27:04 <dons> you'll need to just remove the old State/seen file
03:27:10 <gds> Cool - cheers :)
03:27:30 <dons> see, now the seen state tracks the user count as well
03:27:45 <dons> so when the new code tries to read the old state value, hmm. badness
03:27:49 <gds> :)
03:27:57 <dons> hmm maybe the persistent state should be Typeable
03:28:08 <gds> Would be cool...
03:28:08 <dons> we would have got a better error message back
03:28:17 <dons> but we'd have to version the state type anyway
03:28:19 <dons> hmm
03:28:27 <dons> persistence is fun, but tricksy
03:28:35 <gds> Gilad Baracha (spl? the Sun guy) has talked about software as services...
03:29:01 <gds> He envisioned an upgrade path - so the software updates and transforms persistant data as part of the process...
03:29:06 <musasabi> dons: see e.g. HAppS for a way to have typed persistent state and hiding the state type from the API
03:29:10 <int-e> couldn't you just store a version number in the seen file instead of dying so badly?
03:29:29 <gds> He was using office apps as his example - word95 -> word98 etc...
03:29:30 <musasabi> (or rather we have state type, but nothing depends on it)
03:29:36 <dons> musasabi: oh, yes? sounds good. so if i change the type version, things won't break.
03:29:44 <dons> they'll be caught?
03:30:46 <musasabi> dons: one can impleement versioning on top of the serialization and it works nicely.
03:31:12 <xerox> musasabi: Alex has done a nice talk about HAppS at AngloHaskell!
03:31:14 <lokadin> so you can't have :: Parser [String] ?
03:31:15 <lambdabot> lokadin: You have 1 new message. '/msg lambdabot @messages' to read it.
03:31:35 <dons> musasabi: sounds very nice
03:32:15 <lokadin> .a'onai
03:32:16 <MarcWeber> xerox: But there aren't any recordings, are there?
03:32:36 <xerox> MarcWeber: nothing except the microsoft surveillance videos I suspect %-)
03:35:11 <MarcWeber> ;) http://rafb.net/paste/results/6HbQAq93.html I'm trying to create a small tree using the state monad.. But it does'nt compile http://rafb.net/paste/results/6HbQAq93.html
03:36:14 <MarcWeber> I'd like to learn more about HAppS.. At least I did succeed in compiling it recently (after figuring out which versions of dependencies to use there  was no problem left)
03:36:49 <int-e> MarcWeber: why did you paste the same URL twice?
03:36:54 <norpan> MarcWeber: what compilation error do you get
03:37:37 <kosmikus> why would you apply State to createTree ?
03:38:02 <norpan> is the state a tree or an int?
03:38:18 <norpan> because if it's an int, your type should be State Int (Tree Int)
03:38:36 <kosmikus> that too
03:38:47 <kosmikus> and you probably want "level - 1" rather than "level + 1"
03:38:55 <kosmikus> in the recursive calls
03:38:59 <musasabi> hmm. Should push the patches for the recent FPS to the main repo I guess.
03:40:06 <norpan> also, if createTree returns a State, why does it call runState
03:40:11 <dons> musasabi: you have patches?
03:40:14 <norpan> you have meny mistakes :)
03:40:37 <musasabi> dons: for HAppS fps support, not fps.
03:41:03 <MarcWeber> Lack of concentration I think. norpan You're right..  Should be State Int (Tree Int)
03:41:40 <norpan> or Int -> Int -> Tree Int
03:41:46 <norpan> since you run state inside it
03:41:55 <norpan> anyway
03:41:58 <lokadin> .uisai!!! i think i accomplished something
03:42:21 <xerox> musasabi - Alex was telling me happs uses fps 0.6 instead of the latest 0.7 for some reason, but I can't remember the reason. Do you know it ?
03:44:01 <musasabi> xerox: The API was unstable for a long time and we wanted a version without C dependencies (makes in tree builds with other stuff much easier).
03:44:29 <xerox> dcoutts__: you see?
03:44:45 <dcoutts__> huh?
03:44:54 <dcoutts__> oh
03:45:08 <dcoutts__> musasabi: it's used C bits for ages
03:45:45 <dcoutts__> we could probably make a variant -DGO_SLOW that didn't need any C bits
03:45:59 <dcoutts__> or at least not any *extra* C bits
03:46:13 <lokadin> MarcWeber: thanks for the note btw, it helped a lot :)
03:46:17 <musasabi> dcoutts__: there was a version with #ifdefs to avoid the non-libc C bits.
03:46:34 <dons> yep. there's very few c bits now. 4 functions i think
03:46:36 <dcoutts__> musasabi: yeah, presumably using C bits from the clib is ok, it's the fpstring.c that you don't like
03:46:49 <dons> i guess you won't care, musasabi , once you install 6.6?
03:47:12 <musasabi> dcoutts__: yes. Especially since HAppS didn't use any of those bits (at least so much it would have shown on profiles).
03:47:43 <musasabi> dons: yes, once 6.6 has it prepackages things will be fine
03:47:54 <xerox> :)
03:48:05 <MarcWeber> kosmikus, dons musasabi, norpan Got it working now.
03:49:10 <lokadin> mi ba zi sipna .i fe'o
04:25:19 <mGem> ?where logs
04:25:19 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
04:45:50 <MarcWeber> Is there a shorter way to do the same as this foldr expression on line 22 ? http://rafb.net/paste/results/VWzTLt71.html. It generates level subtrees using the state monad
04:47:36 <madpickle> http://www.pcmag.com/article2/0,1895,2000232,00.asp
04:47:38 <lambdabot> Title: New Borland Line Salutes Turbo Pascal Spirit
04:47:38 <madpickle> wow
04:47:42 <MarcWeber> lokadin: Which language are you speaking? I don't unnderstand anything
04:48:03 <wolverian> MarcWeber, sure unfoldTree doesn't work for you?
04:49:27 <kosmikus> MarcWeber: this all looks very strange. why are you using a monad if you're never using any of the monad's functionality. you're constantly wrapping and unwrapping the State constructor and always explcitly transform the state ...
04:49:54 <MarcWeber> kosmikus: To learn more about it ;)
04:53:31 <kosmikus> don't use "runState" in createTree, let it return a monadic value instead. then you don't need the explicit wrappers around the recursive calls anymore. then use get/put/update to modify the state, rather than doing something like "State $ (\s -> (s,s+1))". I'm not sure what you do in the "forest" line because you don't seem to be using the result anywhere ...
04:56:20 <MarcWeber> This is doing : do { a <- createTree (level+1); return [a] } for level 1 and do { a <- createTree (level+1); b <- createTree  [..];  return [a,b] } for level 2 ...
04:57:20 <MarcWeber> So the forest at level n will exist of n Nodes
04:58:12 <MarcWeber> I know its close to unreadable.. That's why I was asking..
05:06:02 <turol> Is there a nice way to do mmapped IO in haskell?
05:46:31 <dons> turol: no tutorials.
05:47:09 <dons> code has been written though.
05:47:21 <dons> you could install Data.ByteString, and just use mmapFile
05:49:53 <kpreid> dons: wrt lambdabot state, it would be nice if the error reported which plugin had the problem
05:50:04 <kpreid> when I hit that, lacking any more information, I had to throw out the entire state dir
05:51:38 <nealc> hi sek
05:52:30 <dons> ah. hmm
05:52:47 <dons> kpreid: good idea. i'll see if i can add it now
05:53:12 <kpreid> BRB
05:56:36 <sek> hello nealc
05:57:18 <nealc> hello
05:59:17 <dons> ?users
05:59:21 <lambdabot> Maximum users seen in #haskell: 221, currently: 209
06:00:33 <nealc> dons, why there is so much users and no talking?
06:00:47 <dons> people are busy working? :)
06:01:07 <dons> ?yow!
06:01:19 <gds> ?yow !
06:01:23 <lambdabot> -- I have seen the FUN --
06:01:23 <lambdabot> ... I don't know why but, suddenly, I want to discuss declining I.Q.
06:01:23 <lambdabot> LEVELS with a blue ribbon SENATE SUB-COMMITTEE!
06:01:44 <dons> ?vixen-on
06:01:45 <lambdabot> What's this channel about?
06:01:46 <dons> talk to me
06:01:47 <lambdabot> what type of music do you like?
06:02:01 <dons> what kind of music do you like?
06:02:03 <lambdabot> i like Tom Petty
06:02:15 <dons> heh. really? do you listen very often?
06:02:19 <lambdabot> yup, really
06:02:27 <dons> silly bot
06:02:27 <lambdabot> i can't stand bots
06:02:48 <dons> ?vixen-off
06:02:48 <lambdabot> Bye!
06:02:55 * dons $!! sleep
06:03:33 <nealc> why buzzy people let irc client in the most logged channel?
06:04:40 <jewel> so that if they are bored they can skim through the chat
06:04:51 <erider> hi nealc
06:05:17 <nealc> hi erider
06:05:39 <erider> bom dia
06:06:04 <erider> como vai voce
06:06:14 <nealc> :)
06:07:03 <erider> todu otimo ala
06:13:27 <Philippa> that, and so we can dive into the conversation at any point, like so
06:18:35 <erider> hi Philippa
06:28:50 <boegel> @seen shapr
06:28:50 <lambdabot> shapr is in #ScannedInAvian and #haskell. I don't know when shapr last spoke.
06:29:09 <boegel> @vixen you don't know shit, you useless piece of crap!
06:29:09 <lambdabot> yeah, i know
06:29:20 <boegel> *sigh*
06:29:36 <therp> the "monads in functional programming" paper is nice
06:31:30 <Philippa> boegel: anything urgent? I suspect he's got work to do since the weekend
06:41:02 <Stinger_> hmm kline problems eh mauke
06:43:52 <boegel> Philippa: nah, not really, just checking :)
06:58:37 <ValarQ> i get more mails from the ghc-cvs mailing list about commits than i get spam these days
06:58:47 <ValarQ> impressive indeed :)
07:03:13 <LordBrain> is the changelog online?
07:04:41 <shapr> xerox: Is the latest cabal-get in the repo?
07:10:18 <LordBrain> http://www.haskell.org/ghc/survey2005/devmodel_comments.html
07:10:37 <LordBrain> It seems half the participants interpretted the question to mean the model used in developing ghc
07:11:22 <LordBrain> while the other half... they thought it was talking about the model that everyone uses while if they use the dev-tools that the ghc package provides...
07:11:34 <int-e> . o O ( 300 line makefile?! )
07:11:42 <LordBrain> lol
07:15:26 <Stinger_> heh "less than great, but much better than so-so."
07:21:24 <xerox> shapr: yes, I don't know wethere Lemmih pushed his patch we thought in the pub.
07:21:56 <xerox> shapr: and the work from duncan & me is still in dcoutts's laptop.
07:22:21 <dmhouse> Afternoon channel.
07:22:39 <madpickle> http://echosphere.net/star_trek_insp/star_trek_insp.html
07:22:40 <madpickle> lmao
07:22:41 <lambdabot> Title: Star Trek Inspirational Posters
07:23:46 <shapr> xerox: It seemed that cabal-get was working on Saturday morning, so I'd like to put in Hope packages.
07:25:14 <wferi> Hi, any Wash experts here? I'd like to have "active" radio buttons, which submit the form as soon as clicked. The problem seems to be that radioButton returns HTMLField cgi x y (), and () is not an InputHandle, what activate expects. Is there a way around? Or do I misunderstand something?
07:25:37 <xerox> shapr: Then you can use the current code (lemmih's patch would be handy because it fix how it searches for the configuration files/directories but it's not strictly needed). You can then add the tarballs to the hierarchy of packages, and generate the index with cabal-server-install. The only problem is that it doesn't get the url right, so you have to add it manually to the index file for the new packages.
07:26:19 <shapr> Is there a 'real' onlien repository that's configured for the default cabal-get code?
07:26:37 <shapr> My goal is for people to be able to darcs get cabal-get and then cabal-get hope.
07:26:42 <xerox> Yep, the pub.tar.gz or pub/ directory under the cabal-server-install repository.
07:43:00 <shapr> @users
07:43:00 <lambdabot> Maximum users seen in #haskell: 221, currently: 209
07:45:20 <tibbe> @idlers
07:45:28 <lambdabot> Unknown command, try @list
07:47:09 <wferi> Ok, other question: is the following sane? I'd like to capture the full stdout and stderr of a process. Is there a simpler/better way?
07:47:10 <wferi> (inp,out,err,pid) <- runInteractiveProcess ...
07:47:10 <wferi> diag <- hGetContents err
07:47:10 <wferi> res <- hGetContents out
07:47:10 <wferi> length diag `seq` length ldif `seq` mapM_ hClose [inp,out,err]
07:47:11 <wferi> exit <- waitForProcess pid
07:47:33 <wferi> Is it race/deadlock free at all?
07:47:56 <kpreid> wferi: hGetContents closes it for you
07:48:11 <wferi> halfway, yes.
07:48:26 <kpreid> oh, right
07:48:37 <wferi> I'm not sure it frees all the resources eventually.
07:48:52 <Lemmih> It does.
07:49:09 <wferi> when?
07:49:24 <Lemmih> It closes the Handle when it's done with it. If you close it before then the stream will be truncated.
07:50:07 <wferi> it means I could forget about the long line with the seq's and return (diag,res,exit) from the function, does it?
07:50:13 <emertens> is there a good way to find the dot product of two vectors expressed in spherical coordinates?
07:50:21 <emertens> without converting to cartesian coords?
07:50:59 <SamB> probably not
07:51:04 <wferi> emertens: if you can compute their angle, then yes.
07:51:12 <Stinger_> surely you could compute the angle between them from polar somehow
07:51:24 <emertens> wferi: i want to use this to compute their angle :)
07:51:29 <wferi> :)
07:51:34 <wferi> then no.
07:51:44 * SamB thinks it would likely be easier to convert to rectangular
07:51:49 <emertens> I'm going to
07:51:55 <emertens> I was just curious
07:51:56 <emertens> :)
07:52:14 <SamB> even if there is a way, it must surely be roundabout
07:52:26 <Stinger_> you cant just do something like ang = sqrt(latdiff^2 + longdiff^2) ? :)
07:52:42 <Lemmih> wferi: You need to close the handles (one way or another) because calling 'waitForProcess'.
07:52:44 <tibbe> any news on the HaskellNet project?
07:52:49 <wferi> back to hGetContents, they can't block each other, can they?
07:53:16 <wferi> Lemmih: you mean waitForProcess won't return until I close my ends of the pipes?
07:53:25 <Stinger_> actually I reckon that might almost work, lemme think about it :)
07:53:39 <int-e> wferi: they can: your process blocks on its stdout once the pipe is full and stops writing to stderr; your programm will block on stderr then
07:53:40 <SamB> I think hGetContents closes read-only files
07:53:46 <SamB> at EOF
07:53:49 <Lemmih> wferi: Yes, afaik.
07:53:52 <SamB> check docs
07:54:05 <SamB> or source or something
07:54:41 <SamB> but, well, it does that lazily
07:54:41 <wferi> int-e: yep, that's what I want to avoid with all the above. Should I forkIO one of the two hGetContents?
07:54:43 <int-e> wferi: you need multiple threads (IO threads should be enough - I think there's a select in the RTS for this stuff) for reading both outputs, I believe.
07:55:24 <SamB> @hoogle fork
07:55:24 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
07:55:25 <lambdabot> Control.Concurrent.forkOS :: IO () -> IO ThreadId
07:55:43 <int-e> so forkIO (diag `seq` return()); res`seq`whatever
07:55:58 <Stinger_> ok you have two polar angles (a,b) (c,d) then consider the points on the unit sphere with polar angles (a,b) (a,d) (c,b) (c,d) as a quad
07:56:03 <wferi> So is the above (peppered with a forkIO) the best I can do?
07:56:11 <wferi> Ugh, lemme see...
07:56:12 <int-e> I'd expect that to work but I've never needed it.
07:56:29 <SamB> Stinger_: the unit sphere is kind of... curved?
07:56:37 <Stinger_> inscribed within
07:56:45 <SamB> oh okay
07:56:48 <wferi> I should have to seq the lengths, shouldn't I?
07:56:48 <musasabi> wferi: you might want to google for solutions. It is slightly nontrivial.
07:56:53 <SamB> I suppose that works...
07:56:58 <SamB> yeah
07:57:08 <int-e> if you don't need the diagnostic output ... can you open stderr as /dev/null somehow? hmm.
07:57:08 <SamB> carry on
07:57:27 <wferi> int-e: I do need the diagnostic output.
07:57:33 <int-e> I see
07:57:34 <Stinger_> then it seems to me the projection from the origin through the diagonal of the quad is the arc you want
07:57:39 <dmhouse> http://sztywny.titaniumhosting.com/2006/07/23/stiff-asks-great-programmers-answers/ worth reading.
07:57:48 <int-e> I think you really need forkIO or forkOS for that.
07:57:56 <Stinger_> and the length of the diagonal on the quad is directly related to that angle
07:58:33 <int-e> at least when using hGetContents. If you do the reading yourself, non-blocking, that'll be possible as well. But it's more work.
07:58:45 <wferi> int-e: that's what I suspected, no problem, forkIO is standard AFAIK. So:
07:59:08 <musasabi> wferi: if you can live with GPL then http://happs.org/HAppS/src/HAppS/Util/Common.hs runCommand
07:59:31 <Stinger_> wait now I'm not so sure ;)
08:00:56 <wferi> runProc args =
08:00:56 <wferi>     do (inp,out,err,pid) <- runInteractiveProcess blah...
08:00:56 <wferi>        diag <- forkIO (hGetContents err)
08:00:56 <wferi>        ldif <- hGetContents out
08:00:56 <wferi>        length diag `seq` length ldif `seq` mapM_ hClose [inp,out,err]
08:00:56 <wferi>        exit <- waitForProcess pid
08:00:58 <wferi>        return (ldif,diag,exit)
08:01:07 <wferi> But forkIO's type doesn't fit in.
08:01:45 <SamB> Stinger_: how are you going to find this length anyway?
08:02:36 <wferi> musasabi: GPL is acceptable, I'm having a look.
08:02:58 <Stinger_> my theory was that you could lift the properties of the circumscribed quad, to the shere surface, to put it in a haskell way ;D
08:03:06 <Stinger_> I have to think about it a bit :)
08:03:55 <wferi> musasabi: I see, you have to go the full forkIO route. Really nontrivial, heh.
08:04:29 <Stinger_> SamB hmmm I think my theory is full of crap :)
08:04:52 <int-e> forkIO on the hgetContents won't help at all
08:05:05 <SamB> I think you still probably need to do some kind of spherical -> rectangular conversion...
08:05:05 <Stinger_> but, there is someway of doing it thats not that hard surely :)
08:05:08 <int-e> hGetContents is already using unsafeInterleaveIO for you
08:05:29 <int-e> it's the actual `seq` that will cause the deadlock - so you need to put that seq into it's own IO thread.
08:05:50 <wferi> int-e: NOW that makes sense!
08:06:59 <wferi> that opens way to a simpler solution, as I don't have to return anything from the other thread.
08:07:01 <musasabi> int-e: I think there was some non-trivial things on windows with waitForProcess and closing the handles.
08:08:04 <int-e> wferi: right. for returning stuff you'd need an IORef or something like that.
08:08:13 <int-e> wferi: but you don't need it.
08:09:37 <wferi> yes, HApps uses MVars...
08:10:21 <int-e> MVars are nice because they can also tell you when the thread is done :)
08:10:57 <musasabi> but it might be that int-e is right. I remember there were some dodgy issues with that but that is too long ago.
08:10:58 <wferi> I guess I'd better try it.  First I deadlock my current impl., then solve the prob.
08:10:58 <wferi> Yes, the HApps code is pretty, owing to this.
08:11:23 <int-e> musasabi: I know close to nothing about windows.
08:11:40 <wferi> musasabi: concerning closing the handles?
08:13:11 <musasabi> int-e: maybe: 1) hGetcontents (is lazy), 2) fork T2 to seq, 3) waitForProcess, 4) the process exits, 5) seq in T2 (from hGetcontents) gets EPIPE
08:13:38 <musasabi> But it is too long since I have touched the code to remember the issues.
08:18:19 <wferi> musasabi: and how do you avoid this race?
08:18:56 <kosmikus> ?hoogle (a -> m b) -> [a] -> m b
08:18:57 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
08:18:58 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
08:18:58 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
08:31:38 <gaal> ghc is rejecting this in a hs-boot file:
08:31:39 <gaal> class (Monad m, Functor m, Eq a, Data a, Typeable a) => ICoercible m a
08:31:48 <gaal> any ideas why? and what I can do about it?
08:32:05 <gaal> actually there should be a fundep there:
08:32:07 <gaal> class (Monad m, Functor m, Eq a, Data a, Typeable a) => ICoercible m a | a -> m
08:32:41 <gaal> the error is simply "Illegal class declaration in hs-boot file".
08:33:47 <SamB> did you import the needed modules for the Data and Typeable classes?
08:35:47 <musasabi> wferi: the HAppS code does not have it.
08:35:59 <musasabi> wferi: because output is forced before waitforprocess.
08:36:10 <musasabi> I think.
08:37:33 <gaal> SamB: importing them didn't help :(
08:41:49 <petekaz> Is there an equivalent to python decorators in haskell?
08:42:04 <int-e> no
08:42:30 <int-e> what'd you want them for?
08:42:47 <petekaz> It seems like they would be hard to implement (nevermind syntactic sugar) because there is no way to define a function and capture all of its args.
08:42:52 <xerox> ?where SearchPath
08:42:55 <lambdabot> I know nothing about searchpath.
08:42:56 <petekaz> i.e. def test(*args)
08:43:03 <xerox> musasabi: do you know where it is?
08:43:44 <petekaz> int-e: I don't know, but I use them a lot in python.  Adding functionality to functions already built by wrapping them with stuff.
08:44:21 <int-e> petekaz: but haskell has first class functions
08:45:04 <int-e> > let twice f = f . f; g = twice (+1) in g 0
08:45:18 <lambdabot>  2
08:45:29 <xerox> > join (+) 1
08:45:41 <int-e> monad abuse
08:45:46 <lambdabot>  2
08:46:02 <xerox> Abuse? :(
08:46:39 <petekaz> I guess I'm having a hard time thinking of a decorator use.  I use them to timeout functions, enable tracing, adding meta-data that I can later pull out.
08:46:42 <xerox> Are some instances illegal now?!
08:47:08 <int-e> petekaz: monads, higher order functions.
08:47:34 <xerox> Right, some of those things might well be expressed in term of types.
08:47:42 <petekaz> Is there a haskell equivalent of:
08:47:49 <petekaz> def test(*args):
08:47:55 <petekaz> scratch that.
08:48:02 <petekaz> def wrapper(fn):
08:48:15 <petekaz>   def wrapped(*args):
08:48:22 <petekaz>     return fn(*args)
08:48:27 <petekaz>   return wrapped
08:48:31 <int-e> id
08:48:35 <xerox> Right :)
08:48:45 <petekaz> humor me, pretend that 'wrapped' did something else.
08:49:29 <petekaz> wrapped invokes a fn without knowing anything about the number of args it takes.
08:49:38 <int-e> same for id ;)
08:49:42 <petekaz> i.e. *args, &rest in lisp, etc.
08:49:46 <xerox> I see your point...
08:49:49 <int-e> variadic arguments are a problem.
08:50:02 <petekaz> int-e: pretend that wrapped did something before invoking the original fn.
08:50:03 <xerox> Variadic functions are typeable nevertheless.
08:50:12 <int-e> type classes can help (see printf); template haskell is the proposed solution.
08:51:25 <Stinger_> is template haskell currently around as a lib? or is it going to be implemented as a language feature in the next haskell
08:51:25 <petekaz> I guess this whole conversation is not really suited for a static language like haskell.
08:51:53 <petekaz> Its definitely more characteristic of things like python, ruby, lisp/scheme.
08:51:59 <int-e> ghc has -fth. it's a mixture of libraries (for manipulating expressions) and new syntax
08:52:51 <int-e> the problem is that you can't really tell syntactically how many arguments a function takes.
08:53:04 <petekaz> But I guess in haskell, there are alternate means of dealing with the same types of problems.
08:53:07 <int-e> because there are partial applications
08:53:31 <int-e> @type (liftM, liftM2, liftM3)
08:53:35 <petekaz> I really love partial applications too.  One of my favorite features.
08:53:36 <lambdabot> forall a1 r (m :: * -> *) a11 a2 r1 (m1 :: * -> *) a12 a21 a3 r2 (m2 :: * -> *). (Monad m, Monad m1, Monad m2) => ((a1 -> r) -> m a1 -> m r, (a11 -> a2 -> r1) -> m1 a11 -> m1 a2 -> m1 r1, (a12 ->
08:53:37 <lambdabot> a21 -> a3 -> r2) -> m2 a12 -> m2 a21 -> m2 a3 -> m2 r2)
08:53:48 <int-e> that's why there are families of functions like these
08:54:23 <petekaz> yeah, that is the ugly wart of haskell.
08:54:25 <Stinger_> and zip3 etc.
08:54:34 <petekaz> erlang has the same problem.
08:54:47 <int-e> I think it's not a wart, it's a logical consequence of having partial application.
08:55:05 <petekaz> erlang doesn't have partial application, but they have the same problem.
08:55:16 <petekaz> zip2, zip3, zip4, ...
08:56:01 <Stinger_> similar with c++ templates
08:56:02 <petekaz> IMO, it's hacky looking, but I'm a newbie so maybe at some point I'll see the elegance.
08:56:58 <Stinger_> ditto :)
08:57:45 <int-e> it's a small price to pay for lots of other elegant things
08:58:33 <ValarQ> petekaz: never heard of zip2 actually :)
08:58:55 <int-e> hah. we should make zip0 an alias for repeat () :)
08:58:58 <petekaz> you should have seen the look on my face when I saw zip1!
09:00:00 <musasabi> xerox: where what is?
09:00:19 <musasabi> http://searchpath.org/ ?
09:00:26 <emertens> what's zip 1?
09:01:13 <int-e> zip1 = id (there are no 1-tuples)
09:01:30 <int-e> (both zip0 and zip1 are made up)
09:01:43 <xerox> musasabi: ah, that was easy... thanks :)
09:01:46 <dcoutts__> xerox: ah yes, I need to send you the changes we did on my laptop
09:01:50 <ValarQ> liftM2 is one of the few such functions that i use
09:01:53 <xerox> Right :)
09:02:26 * int-e had the occasional use of zipWith3 and even zipWith4.
09:02:33 <ValarQ> so i don't see it as a very large problem
09:04:16 <ValarQ> @hoogle uncurry3
09:04:17 <lambdabot> No matches found
09:05:22 <int-e> oh, and I wanted that function at least once.
09:05:27 <int-e> :)
09:13:10 <dmhouse> ?fptools Data.Bits
09:13:11 <lambdabot> http://darcs.haskell.org/packages/base/Data/Bits.hs
09:14:14 <dmhouse> Is .&. on Ints defineable in terms of arithemetic operations/
09:17:03 <LordBrain> sure
09:17:37 <LordBrain> getting at the bits is just a matter of deviding by 2 and taking the remainder
09:17:50 <LordBrain> repeatedly
09:18:03 <araujo> hello
09:18:17 <emertens> I don't think that's what he meant
09:18:29 <emertens> I've been known to be wrong
09:19:20 <dmhouse> emertens: well, it would work.
09:21:39 <dmhouse> http://www.harley.com/harley-quotes/unix-sysadmin.html hehe :)
09:21:42 <lambdabot> Title: The Unix Sysadmin Song
09:26:02 <emertens> I didn't realize that you were just asking if an Int could be converted into a binary representation
09:26:29 <LordBrain> for bits a and b, a & b= ab(a+b)/2
09:27:53 * edwardk waves hello.
09:28:20 <ValarQ> hello mr K
09:28:25 <edwardk> how goes?
09:29:12 <LordBrain> actually since its ints anyway, you could just do (a+b)/2
09:29:50 <emertens> what would that tell you?
09:30:20 <LordBrain> an arithmetic formula for bitwise and
09:30:24 <emertens> ??
09:30:33 <emertens> 1010 .&. 101 = 1111
09:30:48 <mauke> wtf people
09:30:48 <LordBrain> a and b are only one bit
09:31:23 <emertens> (1+0)/2 -> 0.5? 0?
09:31:26 * edwardk tries to figure out the conversation out of context.
09:31:47 <emertens> and is multiplication
09:31:48 <LordBrain> well if you use integer division, thats 0
09:31:56 <dmhouse> edwardk: defining bitwise and in terms of arithemetic operations.
09:32:06 <edwardk> good luck with that
09:32:12 <edwardk> =)
09:32:29 <emertens> they are breaking the int into binary representation first
09:32:36 <edwardk> they are in completely different rings
09:32:44 <emertens> so it's not what it seems
09:32:49 <LordBrain> (1 + 0) `div` 2 = 0
09:32:59 <emertens> 1 * 0 = 0
09:33:21 <edwardk> and is multiplication element by element if thats what you mean.
09:33:36 <LordBrain> oh, yeah, 0 and 0 is 1
09:33:48 <emertens> 0 and 0 = 0
09:34:01 <LordBrain> oh yes i was right at first then, why are you confusing me
09:34:01 <ihope> 0+0 = 0, 0*0 = 0...
09:34:06 <LordBrain> hehehe
09:34:15 <ihope> (|0> + |0>)/sqrt 2 = |0>...
09:34:27 <emertens> ihope: 0 - 0 = 0
09:34:37 <ihope> Oh, yeah.
09:34:40 <edwardk> ihope: qubits? =)
09:34:42 <monochrom> |0>
09:34:43 <emertens> so it must follow that 0 / 0 = 0, right?
09:34:55 <emertens> ;)
09:34:56 <LordBrain> 0 /0 is nan
09:34:58 <ihope> edwardk: yep.
09:35:04 <LordBrain> in haskell
09:35:11 <edwardk> thought so when i saw the ket
09:35:12 <ihope> > 0/0
09:35:17 <lambdabot>  NaN
09:35:26 <ihope> > 0%0
09:35:27 <lambdabot>  Exception: Ratio.%: zero denominator
09:35:29 <mauke> > div 0 0
09:35:30 <lambdabot>  Exception: divide by zero
09:35:31 <LordBrain> and in general... i would say anythign divided by 0 is undefined
09:35:39 <LordBrain> but in haskell...
09:35:39 * edwardk should hope so
09:35:45 <emertens> dy definition 0 / 0 is undefined
09:35:57 <ihope> See? Haskell is stupid! :-P
09:36:14 <LordBrain> > 1/0
09:36:15 <lambdabot>  Infinity
09:36:30 <edwardk> > -1/0
09:36:35 <emertens> > (1/0)^2
09:36:46 <lambdabot>  -Infinity
09:36:46 <emertens> lambdabot: is laggin :)
09:36:46 <lambdabot>  Infinity
09:37:03 <ihope> > -1/0 == 1/0
09:37:09 <lambdabot>  False
09:37:11 <ihope> > 1/-0 == 1/0
09:37:12 <lambdabot>  Not in scope: `/-'
09:37:16 <emertens> replicate (1/0) 1
09:37:25 <ihope> > 1/(-0) == 1/0
09:37:26 <emertens> > replicate (1/0) 1
09:37:26 <lambdabot>  False
09:37:27 <lambdabot>  add an instance declaration for (Fractional Int)
09:37:32 <mauke> hmm, I can do & in terms of +, -, ^ and /
09:37:38 <edwardk> you have to watch out lambdabot doessn't agree with ghc or mathematics in a lot of places
09:37:39 <emertens> > replicate (1.0/0.0) 1
09:37:40 <lambdabot>  add an instance declaration for (Fractional Int)
09:37:40 <mauke> but by ^ I mean xor :/
09:37:41 <edwardk> > log (-1)
09:37:43 <ihope> mauke: bitwise AND?
09:37:50 <mauke> yeah
09:37:57 <lambdabot>  -Infinity
09:38:07 <LordBrain> i thought lambdabot uses ghci?
09:38:28 <edwardk> nope
09:38:34 <emertens> if a,b are {0,1} then xor is /=
09:38:48 <ihope> > logBase 2 (-1) -- the number of ordinal numbers, sort of... but not really
09:38:49 <lambdabot>  -Infinity
09:38:53 <LordBrain> what does lambdabot use? hugs?
09:38:56 <emertens> ghc
09:38:58 <emertens> @version
09:38:58 <lambdabot> lambdabot 4p49, GHC 6.5 (OpenBSD i386 )
09:38:59 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
09:39:07 <edwardk> lambdabot uses its own thing for the parser iirc
09:39:15 <LordBrain> ok
09:39:16 <ihope> Parser?
09:39:19 <edwardk> it doesn't seem to agree with anyone on the mathy stuff
09:39:29 <edwardk> the > stuff
09:39:50 <edwardk> Prelude> log (-1)
09:39:50 <edwardk> NaN
09:40:06 <edwardk> Hugs> log (-1)
09:40:06 <edwardk> Program error: argument out of range
09:40:17 <edwardk> > log (-1)
09:40:18 <lambdabot>  -Infinity
09:40:57 <edwardk> so i wouldn't take its behavior wrt division by 0 as normative =)
09:41:08 <edwardk> but
09:41:13 <edwardk> then it does agree with ghci and hugs there
09:41:19 <edwardk> whee for broken numerical towers
09:43:18 <mauke> > let x = 5; y = 7 in (x + y - (x `xor` y)) `div` 2 :: Int
09:43:35 <lambdabot>  5
09:44:06 <sjanssen> > typeOf $ log (-1)
09:44:14 <lambdabot>  Add a type signature
09:44:21 <emertens> lol :)
09:44:23 <edwardk> at least ghci gets it right when you do:
09:44:25 <edwardk> Prelude Complex> log ((-1) :+ 0)
09:44:26 <edwardk> 0.0 :+ 3.141592653589793
09:44:34 <sjanssen> > log (-1) :: Double
09:44:34 <xerox> pee!
09:44:35 <lambdabot>  -Infinity
09:44:41 <sjanssen> > log (-1) :: Float
09:44:43 <lambdabot>  -Infinity
09:45:09 <sjanssen> umm, that is a bit strange
09:45:13 <edwardk> > log (-1) :: Complex Double
09:45:14 <lambdabot>  0.0 :+ (-3.141592653589793)
09:45:42 <sjanssen> what architecture is lambdabot running on?
09:45:43 <edwardk> thank you euler =)
09:45:58 * SyntaxNinja rocks hard
09:45:59 <edwardk> its built in ghci, but i have no idea where it gets its math from
09:46:00 * SyntaxNinja rocks out
09:46:07 <xerox> Howdy SyntaxNinja!
09:46:08 <edwardk> er in ghc
09:46:39 <edwardk> heh Complex needs a :- constructor for symmetry =)
09:47:12 <edwardk> guess it wouldn't work, but still
09:47:20 <sjanssen> why doesn't lambdabot default the type of "typeOf $ log (-1)" correctly?
09:47:30 <xerox> ?type log
09:47:31 <lambdabot> forall a. (Floating a) => a -> a
09:47:47 <edwardk> Prelude Complex> :type log
09:47:47 <edwardk> log :: (Floating a) => a -> a
09:48:31 <sjanssen> mm, nevermind, lambdabot is right
09:48:37 <edwardk> ?
09:49:18 <sjanssen> asking for a type signature for "typeOf $ log (-1)".  I was confused by ghci's behavior
09:50:36 * edwardk just wish mptcs and fundeps were in when the prelude was standardized so it could actually be a reasonable reflection of mathematics
09:51:28 <edwardk> as little as i like docon and the derived BAL stuff, they are at least reasonably faithful to abstract algebra
09:51:57 <SyntaxNinja> hey xerox
09:52:22 <edwardk> otoh, half of that bias may just come from the author's poor grsap of english. =/
09:52:36 <edwardk> and my poor grasp of spelling apparently =)
09:52:37 <ChilliX> Hi SyntaxNinja!
09:52:56 <xerox> SyntaxNinja: I am _very_ near to a working cabal-install using the new tarball index format :)
09:53:06 <edwardk> woohoo
09:53:15 <SyntaxNinja> xerox: coolness.  we could work to target ghc 6.6?
09:53:20 <xerox> AngloHaskell was productive!
09:53:21 <SyntaxNinja> heya ChilliX
09:53:27 <xerox> SyntaxNinja: yes indeed.
09:53:30 <SyntaxNinja> I heard, you guys should post your results.
09:53:36 <SyntaxNinja> to cabal-devel. get ppl excited.
09:54:06 <xerox> Duncan is working on the fusion paper I believe, I need him to send the code.
09:54:26 <xerox> Allright :)
09:55:10 <SyntaxNinja> dcoutts, dcoutts_: dcoutts__: send the code!
09:55:13 <SyntaxNinja> no code hording!
10:25:08 <tibbe> um, what's the purpose of .hsc files?
10:28:03 <dmhouse> I think those are the intermediate C if you do -fvia-c.
10:30:28 <tibbe> dmhouse, it looks very much like Haskell ;)
10:30:44 <dmhouse> tibbe: then I'm probably wrong :)
10:30:58 <tibbe> but one is generated from the other from the looks of it
10:33:14 <edwardk> is anyone here planning on going to icfp this year?
10:36:27 <syntaxfree> Concord!
10:36:38 <edwardk> guess not =)
10:36:56 <syntaxfree> Concord is a much better name than "Haskell".
10:37:10 <edwardk> what would i pertain to?
10:37:11 <syntaxfree> Think of the glossy brochures!
10:37:26 <syntaxfree> I was reading the "History of Haskell" draft.
10:37:38 <edwardk> ah and saw the candidate names?
10:37:48 <syntaxfree> They considered a bunch of names in the early Haskell meetings, including Mirabelle, Nouveau and Concord.
10:38:13 <edwardk> remember the list, forgot that one as n it
10:38:49 <syntaxfree> Concord is the winner!
10:38:54 <syntaxfree> I wonder if there's time to change it :)
10:39:05 <edwardk> heh
10:39:46 <syntaxfree> it's much better for the glossies.
10:39:57 <edwardk> you could go off and write a haskell derivative with that name
10:40:04 <edwardk> won't stop you. might even cheer you on =)
10:44:01 <edwardk> i still think a haskell derivative would be better named Simon at this point though =)
10:44:28 <syntaxfree> well, given that GHC is probably released under a relatively liberal license, I could just awk through the source code and produce the Genius Concord Compiler.
10:44:50 <edwardk> good luck installing that as gcc on any machine i know of =)
10:45:24 * edwardk wonders if all of the simon says jokes would be worth it though
10:45:36 <syntaxfree> some Macs used to ship without gcc.
10:45:49 <edwardk> yeah but you could download the dev kit and install it anyways
10:45:59 <syntaxfree> which is all the more bizarre since it ships with Python, Ruby, etc.etc.
10:46:04 * edwardk nods.
10:47:07 <dgoldsmith> The developer tools have been shipping both preinstalled and on the OS install CD for several years now...
10:47:07 <lambdabot> dgoldsmith: You have 1 new message. '/msg lambdabot @messages' to read it.
10:47:18 <edwardk> yeah
10:47:34 <edwardk> so you probably need another acronym =)
10:48:28 <edwardk> or limit your usser base to the one or two people still running 10.0 or 10.1 who didn't download the dev kit and are interested in haskell and prefer your renamed version =)
10:49:11 <emertens> who's still running OS X 10.[01] ?
10:49:34 <edwardk> exactly =)
10:49:46 <emertens> If you can afford a Mac, you can afford at least 10.3
10:50:04 <edwardk> well, tell that to the academics who keep coming to the linguist list site =(
10:50:20 <syntaxfree> dgoldsmith: my 18-months old Mac didn't' ship with dev tools.
10:50:22 <edwardk> field linguists are a wacky bunch
10:50:24 <syntaxfree> (It did ship with 10.3)
10:50:40 <emertens> the OS X dev tools are a free download either way tho, right?
10:50:54 <edwardk> yeah
10:50:55 <syntaxfree> the dev tools come in the DVD.
10:51:10 <syntaxfree> (The OS install DVD that comes in the box with the computer)
10:51:15 <emertens> I started using OS X at 10.4, and I bought it for it's dev tools :)
10:51:28 <emertens> so I've never realy had any time with my mac where they weren't installed
10:51:37 <edwardk> heh
10:52:06 <edwardk> i defected to a mac around 10.0, then defected back to a pc due to conflicts with applecare over my hunges.
10:52:18 <edwardk> somewhere around 10.3's release
10:52:20 <emertens> I don't know what hunges are
10:52:24 <edwardk> er hinges
10:52:30 <edwardk> on my powerbook
10:52:33 <emertens> ah
10:52:38 <syntaxfree> @google Haskerl
10:52:40 <lambdabot> http://www.dcs.gla.ac.uk/~partain/haskerl.html
10:52:41 <lambdabot> Title: The Haskerl index
10:52:43 <edwardk> i can't type very well on this keyboard =(
10:53:03 <emertens> I would love it if my powerbook's hinges went out
10:53:12 <emertens> it would give me justification to buya macbook pro
10:53:23 <edwardk> at the time the intel macs hadn't been released.
10:53:49 <edwardk> had they coe out a year earlier i would probably be using a mac right now
10:53:50 <emertens> I bought my powerbook knowing that it would going to be obsoleted in less than a year... but I really needed a laptop at that point
10:54:12 <emertens> and I wanted my next computer to be a mac
10:54:46 <dgoldsmith> syntaxfree: check on the disks that came with the machine. The installer will be there.
10:54:50 <edwardk> my next one will be if they actually are putting decent video cards in them at the time
10:54:57 <syntaxfree> I just said that.
10:54:58 <edwardk> dgold: he mentioned it was
10:55:16 * tibbe is looking for a GHC library to document
10:55:56 <edwardk> heh you could document my type level 2s complement stuff =) its not official or anything though =)
10:56:23 <dgoldsmith> sorry, trying to get ready for work while IRC'ing == less than stellar attention... :-(
10:56:27 <musasabi> tibbe: TH
10:56:33 * edwardk needs to figure out a way to generate haddock from template haskell code.
10:56:54 <edwardk> i was thinking i might mine the .hi file since all i use th for is to generate several thousand instances.
10:56:57 <tibbe> um, I probably should start with a basic one that needs attention
10:57:01 <musasabi> edwardk: #ifndef __HADDOCK__ blocks
10:57:03 <tibbe> a networking lib or something
10:57:07 <edwardk> musasabi: i have those
10:57:19 <edwardk> but it doesn't cause it to output the instances that the $()'s contain =)
10:57:36 <musasabi> tibbe: well network is just plain bad from code perspective and I hope it will be killed ;)
10:57:41 <edwardk> but i can see those instances in the .hi files, and you use them, so they should probably be part of my documentation =)
10:57:53 <musasabi> tibbe: unix?
10:58:15 <edwardk> so i figured i might generate a fake .hs file for haddocks' benefit by mining the info from the .hi, maybe with perl or something
10:59:13 <edwardk> musasabi: you commiserated when i griped about es4 the other day, did you dig through the spec?
11:00:11 <sehute> Hi, anyone wish to try out Gobby for coding in Haskell with me?
11:00:20 <edwardk> gobby?
11:00:52 <tibbe> musasabi, documenting a unix lib would be good, anything that's basically a wrapper over C would be a good candidate
11:01:00 <syntaxfree> @google Gobby
11:01:07 <lambdabot> http://darcs.0x539.de/trac/obby/cgi-bin/trac.cgi
11:01:07 <lambdabot> Title: obby - Trac
11:01:33 <musasabi> edwardk: I was commenting on the "uni without functional programming" thing.
11:01:39 <edwardk> ahh
11:01:45 <edwardk> was wondering =)
11:02:24 * dgoldsmith is off to work...
11:03:18 <tibbe> System.Posix.Files looks like a good target
11:04:09 <sehute> I've set up a Gobby server if anyone wish to try (Gobby is a collaborative editor)
11:04:26 <sehute> (Gobby's in my apt)
11:07:30 <syntaxfree> @google Gobby editor
11:07:40 <lambdabot> http://www.freshports.org/phorum/read.php?f=2&i=247&t=247
11:07:41 <lambdabot> Title: FreshPorts
11:08:45 <sehute> syntaxfree: http://en.wikipedia.org/wiki/Gobby
11:09:02 <sehute> @wikipedia Gobby
11:09:12 <lambdabot> No Result Found.
11:09:47 <sehute> Would be nice if lambdabot could do that as well. :)
11:10:11 * sehute closes eyes and makes a wish
11:13:20 <syntaxfree> the History of Haskell pdf draft is messed up.
11:13:25 <syntaxfree> I can't read the examples/
11:13:28 <edwardk> ?
11:13:38 <edwardk> worked for me, did they release a new version?
11:14:28 <syntaxfree> maybe because I'm not using Adobe's reader.
11:14:55 <edwardk> that could do it
11:14:59 <emertens> worked for me on my mac and windows... what reader are you using?
11:15:08 <syntaxfree> Preview.
11:17:47 <syntaxfree> http://img284.imageshack.us/my.php?image=messedupwb1.png
11:17:49 <syntaxfree> looky there.
11:18:52 <LordBrain> its not like debian would ever not support ppc
11:19:05 <emertens> ?
11:19:08 <LordBrain> i ran debian on a mac for a while...
11:19:15 <LordBrain> sorry was reading the log
11:20:06 <LordBrain> people talking about ppc macs being obsolete... i dont think that's an overstatement..
11:20:13 <LordBrain> i mean i do
11:20:16 <emertens> heh
11:20:22 <LordBrain> but tehn i never used mac os anyway
11:20:33 <emertens> the issue is simply the ther performance of the new computer is so much better
11:20:39 <emertens> not that there won't be software support
11:20:43 <LordBrain> oh
11:20:56 <emertens> and I can't really think of a compelling reason to run linux on a computer that you can run oS x on
11:21:03 <emertens> I've tried Ubuntu on my opwerbook
11:21:31 <LordBrain> well... i got the computer when the harddrive failed... so i put my own in
11:21:32 <emertens> unless you are a gnome developer or a kernel developer
11:22:22 <LordBrain> i didnt have an os x install disk floating around
11:22:36 <emertens> that would be a compelling reason to run Linux :)
11:22:42 <emertens> not having an OS X install cd :)
11:22:57 <LordBrain> yeah
11:23:37 <edwardk> http://slipwave.info/worksinadobe.gif
11:23:43 <monochrom> syntaxfree: Haha, how could you manage to get those lambdas? :)
11:23:46 <edwardk> for syntaxtree =)
11:23:46 <LordBrain> i would want debian archive anyway... tho i think there is a debian on os x project... forget what its called.
11:24:06 <syntaxfree> 	oooh. prettier  text too!
11:24:09 <monochrom> report: evince on ubuntu is ok.
11:24:20 <emertens> evince ?
11:24:29 <syntaxfree> what happened to PDF being an universal format?
11:24:34 <edwardk> thats kinda how adobe made their name for themselves.
11:24:42 <LordBrain> i dont know how flexible os x is with gui... is it possible to install fluxbox?
11:24:49 <syntaxfree> I mean, the white-on-black subtitle.
11:24:51 <edwardk> pdf has always had things that are in flux
11:24:53 <syntaxfree> That should show in any PDF reader.
11:25:05 <emertens> why would you want fluxbox on OS X?
11:25:15 <syntaxfree> I have fluxbox on OS X right now.
11:25:17 <edwardk> i.e. i can do realtime 3d graphics in newer versions of adobe, with javascript support and everything
11:25:18 <emertens> so you can right click on your desktop for a list of your programs?
11:25:24 <edwardk> but i can't do squat in preview =)
11:25:58 <syntaxfree> Sometimes I run  full-screen X11 because GNU R has awful Aqua support for graphics.
11:26:08 <edwardk> the white on black subtitle came from me syntax highlighing extensible records to find the section
11:26:19 <syntaxfree> edwardk: oh, bah.
11:26:26 <emertens> syntaxfree: how do you run fullscreen X11? (I don't have my mac in front of me to try)
11:26:36 <syntaxfree> well, when you start X11, it asks you.
11:26:41 <syntaxfree> Rootless or full screen.
11:26:45 <emertens> ?
11:26:52 <emertens> by default it asks you?
11:26:54 <syntaxfree> I'll take yet another screenshot ;)
11:26:59 <edwardk> heh
11:27:08 <emertens> Mine never asks me
11:27:14 <emertens> it just starts in rootless mode
11:27:23 <emertens> and if I click on the icon in the dock it starts xterm
11:28:01 <LordBrain> well, i dont konw, i like the ability to use different guis... my mom uses gnome, and i use fluxbox which starts much faster... my brother uses ion2 ... how would you talk an ion2 person into using mac gui?
11:28:17 <syntaxfree> Before my Mac I ran Gentoo with ion2.
11:28:30 <syntaxfree> http://img128.imageshack.us/my.php?image=x11vw5.png
11:28:39 <lambdabot> Title: ImageShack - Hosting :: x11vw5.png
11:28:44 <emertens> I ran ion3 on my linux box
11:28:49 <emertens> but only because I didn't use it for much
11:28:53 <syntaxfree> ion3, actually.
11:29:01 <emertens> when I have real stuff to do, I found ion3 limiting
11:29:06 <emertens> but when I was just chatting in irssi
11:29:11 <emertens> and had xosview open
11:29:14 <emertens> it was fine
11:30:06 <monochrom> From my experience, ubuntu is poor man's mac os x :)
11:30:18 <emertens> syntaxfree: is that dialog asking you if you want to be asked every time?
11:30:28 <syntaxfree> yep.
11:30:32 <syntaxfree> (Because I do)
11:30:38 <emertens> syntaxfree: and that is 10.4.7?
11:30:43 <syntaxfree> That's 10.3.9
11:30:46 <emertens> oh
11:30:59 <emertens> 10.4 has "X11" not "XFree86"
11:31:18 <emertens> I'm aware that those are just different names
11:31:21 <emertens> but it uses those different names
11:31:46 <syntaxfree> Maybe "X11" is based on Xorg.
11:32:08 <emertens> that's actually very likely
11:32:15 <LordBrain> hmm
11:32:27 <emertens> I would imagine that there is a way to go full screen still
11:32:32 <emertens> it just never occured to me to do it :)
11:32:37 <LordBrain> it would be nice if all the windows users started switching to mac
11:33:34 <LordBrain> i dont think it works that way tho
11:33:40 <LordBrain> heh
11:33:51 <emertens> I've been moving family and friends to mac
11:33:59 <emertens> as they decide that they want a new computer
11:34:07 <emertens> after the first one it's really easy
11:34:16 <emertens> because while they believe me when I talk about computers
11:34:44 <emertens> they really believe the "testimonials" of other family members who don't live on comptuers
11:36:22 <edwardk> heh
11:39:07 <LordBrain> hmm, well i think there is a lot of people who just sort of trap themselves using things that only run on windows..
11:39:19 <petekaz> agreed.
11:39:26 <petekaz> I have my whole family using macs now.
11:40:00 <roconnor> LordBrain: makes me think of ipods.
11:40:07 <LordBrain> yeah
11:40:21 <LordBrain> the best thing would have them all in a free os
11:40:43 <roconnor> start with free formats
11:41:27 <petekaz> yeah, thet one thing that irritates me most about apple is how .Mac is intertwined into the apps.
11:41:57 <LordBrain> really casual users dont want to have to think about it at all.. they'll just use whatever pops up at them... some of them are crazy enough to install random things that get emailed to them even..
11:43:54 <LordBrain> if someone has to do your thinking for you, i'd rather it be debian maintainers, or say gnu darwin heh...
11:45:25 <LordBrain> rather that than coorporations that just want to get in your pockets basicly or sell you as a market to someone else who wants to get your pockets...
11:48:23 <LordBrain> free formats, open source, fall right in with transparency, and i think it's increasingly a basic democracy issue.
11:48:56 <monochrom> There are still the majority of people who don't know you can have tabs in web browsers, and the search box allows you to pick the search engine/vendor.
11:49:08 <monochrom> That is, IE 6 users.
11:49:14 <LordBrain> yeah
11:49:16 <LordBrain> lol
11:49:23 <monochrom> OH!  The IE 6 users have never heard of RSS.
11:49:26 <LordBrain> but IE 7 maybe will fix that
11:49:34 <wolverian> monochrom, their browser doesn't have a search box, I think.
11:49:46 <LordBrain> it used to
11:49:50 <LordBrain> they remove it?
11:49:52 * edwardk admits he doesn't use tabbed browsing much
11:49:59 <LordBrain> i use it intensively
11:50:04 <LordBrain> tabbed browsing
11:50:11 <LordBrain> and i've started using the search box too
11:50:20 <edwardk> but then its a factor of browser support. i don't like the fact that i can't undock a tab from a window and look at the other tab for reference without reloading the page.
11:50:39 <wolverian> I haven't used IE in ages, I'm not sure. :)
11:50:41 <edwardk> the search box i use a lot. i google/hoogle from there all the time
11:50:43 <emertens> i don't need the search box because google is my homepage... i just press COMMAND SHIFT H, google comes up and I type my query in
11:50:55 <emertens> i have a search box, i just don't use it
11:51:01 <LordBrain> emertens: i use the searchbox for the haskell wiki
11:51:05 <edwardk> my home machine doesn't even have IE installed in a runnable state
11:51:12 <emertens> that seems cool
11:51:58 <monochrom> I'm on a web forum.  Recently it was upgraded to a new version of the forum software, and the new version provides RSS.  You won't believe it: the whole forum was like "what is RSS?"  They're all IE 6 users.  This happened just three months ago.  To think we're supposed to be living in 2006...
11:51:58 <wolverian> I like Epiphany's alternative search model. you bookmark the search site, make it into an active bookmark (this step is where the UI fails); after that you type the search term in the URL bar and press down to highlight the search bookmark from the automatically popupped list of bookmarks and/or matching bookmark names.
11:52:00 <LordBrain> its very easy to write your own plugin for most web pages which provide some form of search ... i can search IMDB too
11:52:32 <edwardk> at work i have the collection of i.e.'s back to 3 in a sidebyside config so i can test web crud, but i would never use one of those to browse the web 'in the wild'
11:52:56 <LordBrain> i liked bookmarks in epiphany
11:53:13 <LordBrain> they were fast, convenient
11:53:50 <edwardk> weren't they originally going to replace the bookmark system in firefox for 2.0 but scrapped it?
11:54:07 <LordBrain> i dont know
11:54:12 <edwardk> so we're stuck with the same old fashioned ones we have now
11:54:16 <LordBrain> i'd vote for that tho
11:54:22 <wolverian> LordBrain, were?
11:54:37 <LordBrain> wolverian: well i mean when i used epiphany, i use firefox mostly now
11:55:21 <edwardk> ok, its been almost 4 weeks since i posted my query to the ecmascript dev mailing list with no reply. i have come to the conclusion that they really don't care to field any hard questions =(
11:55:45 <wolverian> LordBrain, switch back to the dark side. :-)
11:56:05 <edwardk> now i need to decide if i want to go ahead and implement the language my way or not just to be told after the fact that its non-normative behavior
11:56:31 <LordBrain> there was a minor interface issue with me on epiphany, but i cant recall it now..
11:56:47 <LordBrain> i think it had to do with being already accustomed to mozilla
11:58:19 <monochrom> non-normative behaviour is the game :)
11:58:30 <LordBrain> i think there was something gnome-like, that i didnt actually like..
11:58:57 <edwardk> mono: heh
11:59:02 <edwardk> well, at least my way it'll be fast =)
11:59:33 <edwardk> a little weird, yes, but fast
11:59:36 <wolverian> LordBrain, impossible!
11:59:41 <monochrom> Perhaps you should implement it, demo it, get everyone excited, and get it adopted as normative in the near future :)
11:59:46 <edwardk> heh
11:59:52 <LordBrain> hmm i'll fire it up, i have it installed, maybe i can remember
12:00:40 <edwardk> basically the commitee can't make up its mind on how to support eval right. the adobe actionscript/microsofts jscripts of the world and the web browser community want different things
12:00:41 <Igloo> Is   data Foo where Foo :: forall a . a -> Foo   different to    data Foo where Foo :: a -> Foo?
12:02:12 <edwardk> they are the same thing no? isn't a lowercase letter just an implicit forall?
12:02:25 <int-e> *Main> :i Foo
12:02:25 <int-e> data Foo = Foo : forall a. a -> Foo     -- Defined at x.hs:1:5
12:02:32 <int-e> that's what I get for the second one :)
12:03:01 <int-e> (and that's the same as for the first.)
12:03:06 <LordBrain> ok i remember now
12:03:11 <Igloo> Hmm, OK, that's pretty good empirical evidence
12:03:29 <emertens> if you do: data Foo = Foo a, isn't a implicitly existential?
12:03:45 <Igloo> You can't do that
12:04:05 <monochrom> I don't understand this syntax.
12:04:14 <LordBrain> apparently gnome has a standard way of doing tabs, moving between them... i dont like it tho because its different from all the other mozilla based browsers
12:04:46 <edwardk> and epiphany is out to implement the whole gnome human interface guideline suite isn't it?
12:04:47 <LordBrain> it uses the same system as gnome-terminal
12:04:48 <wolverian> how is it different from firefox?
12:05:05 <wolverian> edwardk, where it applies to a web browser. :)
12:05:21 <edwardk> true
12:05:23 <LordBrain> firefox, switching between tabs is ctrl-tab, or ctrl-shift-tab
12:05:34 <wolverian> ah.
12:05:45 <LordBrain> same with mozilla, and all the other mozilla based browsers
12:05:45 <wolverian> yes, gnome uses ctrl+pageup/down, and alt+#.
12:05:52 <LordBrain> yeah
12:06:08 <LordBrain> i have even forgotten, because i dont use gnome
12:06:08 <monochrom> I prefer ctrl-pageup/down.  More ergonomic, at least for me.
12:06:13 <wolverian> if you have rebindable menu hotkeys enabled, you can change that in epiphany.
12:06:18 <LordBrain> hmmmm do you?
12:06:19 <wolverian> monochrom, me too.
12:06:25 <LordBrain> i dont
12:06:27 <edwardk> alt-# i like, the ctrl-pageup/down is horrid on most laptops though
12:06:39 <LordBrain> why is it more ergonomic? those buttons arent even in a standard place
12:06:39 <monochrom> ctrl-tab is still ok.  ctrl-shift-tab is a finger-twister.
12:06:43 <emertens> My major "ergonomic" change to all the computers that I use is to remap the control key to capslock
12:06:44 <wolverian> edwardk, they don't have a proper pageup/down group?
12:06:45 <LordBrain> it depends on your keyboard
12:07:06 <wolverian> LordBrain, ctrl+shift sucks on a laptop with a fn key where ctrl is normally.
12:07:20 <wolverian> I suppose it is mostly a matter of keyboard. :)
12:07:21 <edwardk> wolverian: usually not, most ditch and mash home.end.pgup.down iinto a row or column on the right hand edge
12:07:28 <wolverian> edwardk, ew.
12:07:32 <emertens> if you use capslock for control, you don't have issues on laptops :)
12:07:35 <wolverian> @karma+ thinkpad
12:07:40 <lambdabot> thinkpad's karma raised to 1.
12:07:44 <edwardk> my current one runs them along above the numeric keypad that it wastes a good 5th of my keyboard space with
12:07:57 <LordBrain> but laptops move pg-up and down around too!  and at least you have more opportunitites to become accustomed to the shift position as its needed for typing.
12:08:28 <wolverian> I generally don't use ctrl+pageup/down, though. I use alt+# much more
12:08:37 <monochrom> I am on a laptop and I still find pgup/dn more convenient than dontshift/shift
12:08:44 <emertens> alt # ??
12:08:47 <LordBrain> alt-# doesnt bug me
12:08:49 <edwardk> i would happily trade in the numeric keypad for standard positioned arrows and a home/end/pgup/pgdn/insert/delete block
12:08:56 <emertens> is that ALT SHIFT 4?
12:09:06 <edwardk> alt-# i like
12:09:09 <wolverian> emertens, alt + numeral
12:09:12 <edwardk> no alt-1, alt-2, etc.
12:09:16 <emertens> OHHHHH
12:09:17 <emertens> lol
12:09:30 <wolverian> edwardk, get a thinkpad, then
12:09:32 <emertens> alt-'#' seemed really lame :)
12:09:36 <LordBrain> in irssi i end up using esc number sometimes due to my terminal
12:09:50 <LordBrain> i do prefer generally to cycle thru tabs tho
12:09:53 <wolverian> I used to have to do that. then I switched to gnome-terminal. :)
12:10:02 <edwardk> use to love my thinkpad way back when, nowadays i use whatever is cheap and has a big screen
12:10:14 <wolverian> I'm still a sucker for good manufacturing
12:10:17 <LordBrain> and hey, look at the tab key, it says Tab right on it, and mine has arrows too  pointing to the left and the right
12:10:23 <wolverian> 1024x768 does hurt though.
12:10:27 <LordBrain> hehe
12:10:37 <edwardk> i'm at 1440x900 on my laptop now
12:11:27 <edwardk> and i use a 16001200 conventional crt turned on its side to give e something to read papers on
12:11:45 <LordBrain> how about this, epiphany can support the gnome style tab movement, and the mozilla style. I would be satisfied with that.
12:11:50 <edwardk> and irc from
12:12:26 <LordBrain> but in general, what i really want is firefox with epiphany style book  marks
12:13:47 <wolverian> LordBrain, as I said, you can rebind gtk menu bindings if you enable that.
12:13:53 <Cale> What's special about Epiphany's bookmarks?
12:14:21 <wolverian> Cale, they are tag-based, not hierarchical. a hierarchical menu is created based on the tagset for you automatically.
12:14:38 <LordBrain> Cale: ctrl-b pops up a window with checkboxes, you check all that apply, they're overlapping.. and you can add your own cateogories of course.
12:14:39 <wolverian> http://peter.a.harvey.googlepages.com/epiphany
12:14:41 <lambdabot> Title: peter.a.harvey - Epiphany's &quot;Hierarchical&quot; Bookmark System
12:14:47 <Cale> Oh, that would be sort of annoying for me :)
12:14:59 * dmhouse just uses del.icio.us for that
12:15:14 <LordBrain> it tends to lend toward a quicker system, less folders within folders if ind
12:15:18 <wolverian> I really like tags. writing 'haskell' into the URL bar pops up all the haskell-related pages under it, and I can add 'tutorial' to get all the haskell tutorials.
12:15:21 <Cale> I have the entire hierarchical libraries in my bookmarks
12:15:43 <Cale> (arranged hierarchically)
12:15:44 <LordBrain> yeah but that means navigating a menu
12:15:45 <wolverian> pfft. let's just redo the hierarchical libraries with tags.
12:16:30 <wolverian> hrm. that is kind of interesting, actually.
12:16:48 <LordBrain> navigating menu is slower in my experience, epiphany's bookmarks are nice, you should try them for a while, and you might agree.
12:16:50 * edwardk is a big fan of tag based navigation
12:16:55 <wolverian> yup.
12:16:56 <edwardk> (as evidenced by my website)
12:17:09 <dmhouse> Epiphany's system does indeed look nice,.
12:17:11 <wolverian> I suppose tags don't really work for importation though. kind of ad-hoc compared to hierarchical names.
12:17:39 <edwardk> in a hierarchy you need to remember where in the hierarchy you classified something
12:18:17 <LordBrain> thats true too
12:18:37 <Cale> with a tags based system, you have to remember which tags you gave the thing :)
12:18:57 <int-e> you could write them down
12:19:01 <Cale> heh
12:19:02 <int-e> make tagged lists of tags
12:19:06 <int-e> muhahaha
12:19:07 <LordBrain> lol
12:19:15 <wolverian> make a hierarchical list of tags
12:19:24 <LordBrain> try it tho, its easier going in my experience
12:19:38 <int-e> hierarchical is bad, it leads to single points of failures
12:19:46 <int-e> like what if I ever forgot my main tag?
12:19:47 <int-e> :)
12:20:10 <edwardk> i usually use something that has an index of distinct tags given
12:20:12 <edwardk> or a tag cloud
12:20:25 <wolverian> tag clouds are nice to see how popular your language of choice is.
12:20:39 <edwardk> heh
12:20:49 <LordBrain> whats a tag cloud?
12:21:17 <edwardk> http://slipwave.info/#%5B%5Btag%20cloud%5D%5D
12:21:57 <dmhouse> The size of the text reflects the number of tagged members.
12:22:23 <wolverian> sometimes the colour is used too
12:22:27 <edwardk> yeah
12:22:45 <edwardk> or you can code them on two axis size for number color for how recently modified, etc.
12:22:46 <LordBrain> i also think bookmarks in epiphany are more user friendly... how many people want to "manage their bookmarks".  if someone is a new user and lazy, in epiphany they can pretty much go with the default tags, and it works out fine.
12:22:49 <edwardk> that way it can 'cool', etc.
12:23:16 <edwardk> well, the two systems aren't mutually exclusive
12:23:28 <edwardk> once you have tagged data a tag cloud is just a tool for organizing it
12:23:35 <edwardk> or rather browsing it
12:23:38 <vincenz> tag cloud
12:23:42 <vincenz> that is a cool name
12:23:43 <vincenz> :)
12:23:56 <vincenz> "Hey man, have you updated your tag cloud today, the internet seems stormy"
12:24:01 <edwardk> heh
12:24:15 <edwardk> look at the side of that tag cloud, we're in for rough weather.
12:24:18 <LordBrain> later on, as they want to say all their haskell links, they can do that without having to re-organize a hierarchy.
12:24:26 <LordBrain> tag them all i mean as haskell
12:24:44 <vincenz> I need a tagging app though
12:24:47 <vincenz> to organize pdfs
12:24:48 <edwardk> lordbrain: well, in a tag system you usually just tag things as haskell and whatever else is appropriate
12:24:58 <LordBrain> yeah
12:25:07 <mnislaih> I saw one for Mac Os a few days ago vincenz
12:25:10 <vincenz> edwardk: know any offline system for tagging files?
12:25:10 <LordBrain> its easier to manage imo
12:25:19 <vincenz> mnislaih: oh? link?
12:25:20 * edwardk nods.
12:25:46 <mnislaih> it looked pretty damn nice, let me find it
12:28:13 <LordBrain> bookmarks shouldnt ever really be two levels deep if its avoidable anyway...
12:28:49 <mnislaih> doh I can't find it. Obviously I am not tagging my browsing...
12:30:14 <LordBrain> i would like epiphany to be more firefox compatable tho... use the search plugins for example, and have similar default keys where they dont interfere with gnome guidelines
12:31:26 <LordBrain> having a gnomie-compliant browser isnt a big sell to anyone unless they use a lot of other gnome compatable apps...
12:31:29 <vincenz> LordBrain: write a xul plugin to do tagging ala epiphany for FF
12:31:46 <shapr> @users
12:31:48 <lambdabot> Maximum users seen in #haskell: 221, currently: 213
12:31:58 <vincenz> > replicate 213 "cookie"
12:31:59 <lambdabot>  ["cookie","cookie","cookie","cookie","cookie","cookie","cookie","cookie","co...
12:32:08 <shapr> I tried to do @users in privmsg, but it said <lambdabot> Maximum users seen in shapr: 0, currently: 0
12:32:18 <vincenz> well yeah
12:32:24 <vincenz> lambdabot is in multiple channels
12:32:36 <vincenz> privmsg is just another channel, albeit userless
12:32:47 <dylan> let's all get inside shapr! ;)
12:32:50 <LordBrain> why do we need lambdabot to tell that, doesnt the irc client and server tell you that anyway?
12:32:53 <edwardk> well, at least it hasn't seen anyone in you, that would be embarassing. =)
12:32:55 <shapr> Yeah, but I'd like to do @users #haskell
12:32:57 <vincenz> LordBrain: not really
12:33:07 <vincenz> LordBrain: /who is just one long list of spa
12:33:15 <shapr> dylan: I have been accused of being expansive, but ...
12:33:18 <vincenz> besides, lambdabot is historical, keeps maxcount
12:33:20 <LordBrain> spa?
12:33:28 <shapr> Oh, I weighed myself at dcoutts' house, I'm 95 kilos.
12:33:40 <shapr> dcoutts is tremendously fun to hang out with.
12:33:46 <mnislaih> ah, vincenz: http://www.thekip.com/Site/about%20kip.html
12:33:48 <lambdabot> Title: about kip
12:34:00 <LordBrain>  /names #haskell tells me the total...
12:34:09 <shapr> Yeah, but it doesn't give the max.
12:34:17 <LordBrain>  /mode #haskell
12:34:22 <vincenz> shapr: @users #channel is a lot more usecases.....like channels lambdabot is not in and is private, or inexistent channels
12:34:34 <dylan> shapr: hah, you're about the same weight as me
12:34:34 <vincenz> LordBrain: and spams the hell out of my window
12:34:46 <edwardk> i don't think the channel has exceeded the 225 from the other day since lambdabot got the persistent user counter
12:34:58 <shapr> dylan: Do you unicycle also?
12:35:17 <vincenz> edwardk: let's do a mass spammers invite and then kick em all to push up our maxcount
12:35:18 <dylan> shapr: nah, I prefer lap-swimming.
12:35:26 <edwardk> woohoo =)
12:35:34 <shapr> I'm 95 kilos and not at all plump.
12:35:42 <shapr> lap-swimming?
12:36:01 <LordBrain> how can i configure my gtk?
12:36:10 <vincenz> irc is such a funny medium, you can have 200 people in aroom, and it's still silent enough to hold conversations
12:36:16 <vincenz> shapr: swimming in a person's lap
12:36:20 <wolverian> LordBrain, configure?
12:36:20 <dylan> shapr: My form of exercise is to swim. And I'm a bit chubby, but I have enough muscle to sink lot a rock.
12:36:42 <LordBrain> not the source...
12:36:42 <shapr> dylan: pix?
12:36:46 <dylan> *lot=like
12:36:51 <wolverian> LordBrain, I mean, what kind of properties?
12:36:52 <LordBrain> i mean how do modify key bindings
12:36:55 <roconnor> shapr: I've been working on my article.  It's a lot of fun.
12:37:03 <dylan> shapr: Hah
12:37:16 <wolverian> LordBrain, gtk doesn't specify global keybindings, I think. do you mean application-specific keybindings?
12:37:21 <shapr> dylan: Very recent pic of me - http://www.undecidable.org.uk/edwin/photo/anglohaskell.php?photo=IMG_0390.jpg
12:37:23 <lambdabot> Title: AngloHaskell
12:37:25 <LordBrain> ok yeah
12:37:32 <LordBrain> application specific then
12:37:40 <dylan> shapr:
12:37:41 <shapr> three or four days ago, not exactly sure.
12:37:46 <wolverian> (gnome-keybinding-properties configures global hotkeys)
12:37:59 <dylan> shapr: I probably look your inverse. I have rather weak legs and fairly strong arms. XD
12:38:06 <vincenz> shapr: you don't get stopped at night with your unicycle for it not having lights?
12:38:19 <shapr> roconnor: Cool. I had to repost your DMCA blog entry on my own blog btw.
12:38:23 <wolverian> LordBrain, you can only make bindings to actions in menus. enable the changing of the hotkey for menu items in gnome-ui-properties, hover over a menu action and press the ctrl+whatever+foo combo to change it.
12:38:24 <shapr> vincenz: How can they see me? =)
12:38:32 <wolverian> LordBrain, that's as far as the widget system takes you, as far as I know.
12:38:37 <vincenz> people here get fined :/
12:38:47 <roconnor> shapr: heh, I got that link from someone else
12:38:50 <roconnor> the system works
12:38:55 <shapr> roconnor: Is the in-progress article online?
12:39:21 <vincenz> @where shapr
12:39:22 <lambdabot> http://www.ScannedInAvian.com/
12:39:25 <vincenz> yuck
12:39:28 <vincenz> where is the new one?
12:39:35 <shapr> I'd like to write an article for the next TMR, I wonder what I should write about. Maybe I should finish the HUnit article?
12:39:39 <roconnor> shapr: nope.  I'll get someone like greenrd to review my article when it is done.
12:39:43 <shapr> vincenz: http://www.ScannedInAvian.com/hope
12:39:44 <LordBrain> i just want to add ctrl-tab and ctrl-shift-tab to epiphany.. how do it?
12:39:58 <shapr> I had fun talking to greenrd during and after AngloHaskell.
12:40:03 <roconnor> shapr: Is anyone else preparing articles?
12:40:21 <shapr> We went to a vegan restaurant in London.
12:40:35 <emertens> LordBrain: it's open-source, just make the change
12:40:38 <shapr> roconnor: I know petekaz is doing one, but I'm not sure who else is.
12:40:43 <LordBrain> oh
12:40:50 <shapr> @where+ shapr http://www.ScannedInAvian.com/hope
12:40:50 <LordBrain> i thought it was configurable
12:40:55 <lambdabot> Done.
12:40:57 <emertens> it might be
12:40:58 <petekaz> I am writing one.
12:40:58 <roconnor> shapr: should you put a call for papers in the topic?
12:40:59 <LordBrain> someone said that i thought
12:41:06 <shapr> roconnor: Yes, I should.
12:41:17 <petekaz> This is what I've done so far: http://www.haskell.org/tmrwiki/ThreadedRtsAndFfi
12:41:19 <lambdabot> Title: ThreadedRtsAndFfi - TmrWiki
12:41:31 <petekaz> Still working on it though.
12:41:55 <shapr> Oh, I could finish the ArrowsIntroduction, I've had a zillion requests for that.
12:42:18 <roconnor> I think monthly issues was a bit aggressive.  Perhaps quaterly or semianual would've been better. ;)
12:42:29 <shapr> Yeah, that's what swiert suggested in the beginning.
12:42:31 <shapr> But I had to try it.
12:43:03 <roconnor> Even 2600 is quarterly.
12:43:20 <roconnor> shapr: should I be editing my article online in the wiki?
12:43:23 <dylan> shapr: I have no recent (recent being less then 2 years old) picture of myself handy, but I have this: http://hardison.net/~spoony/milk.jpg
12:43:45 <LordBrain> hmmm.. i've also has bad luck with gtk themes... i like that its themable, but the themes often are buggy etc..
12:43:51 <shapr> roconnor: That's not necessary, but it will get you comments from the other authors and the editor.
12:44:09 <shapr> dylan: Nice kitty.
12:44:16 <dylan> shapr: those cats are not related.
12:44:35 <shapr> roconnor: I thought 2600 stopped?
12:44:38 <roconnor> shapr: I would need an account?
12:44:42 <roconnor> 2600 stopped!
12:44:43 <dylan> (the kitten also nurses the dog)
12:44:46 <roconnor> no way
12:45:12 <emertens> http://www.2600.com/ seems alive
12:45:14 <lambdabot> Title: 2600: The Hacker Quarterly
12:45:54 * dylan got a 2600 issue from a book store a few months ago.
12:45:58 <roconnor> http://www.2600.com/covers/covers.html shows summer 2006
12:45:59 <lambdabot> Title: 2600 Covers, Past and Present
12:47:49 <dylan> so, I'm writing a program with a lot of I/O, in haskell... my first haskell program. and so far everything is easy and not terribly confusing.
12:48:03 <emertens> oh, you must be doing something wrong
12:48:05 <emertens> ;)
12:48:33 <dylan> It's like a puzzle, I can't fit two things togither that don't fit, so... :)
12:49:27 * edwardk hopes that dylan is being facetious
12:49:52 <edwardk> oh wait, is easy, heh
12:50:05 <dylan> No, I read the "All About Monads" thing, and I've not having terrible problems getting this thing to work. :)
12:50:09 <vincenz> shapr: I have the reasoned schemer :)
12:50:32 <edwardk> heh
12:50:40 <edwardk> all about monads made my life a lot easier too
12:51:07 <dylan> [this thing == recursively make symlinks to files in one directory in another, prepending '.' to them. Also it recursively looks for broken symlinks.)
12:51:08 <LordBrain> yeah
12:51:12 <LordBrain> i third that
12:51:16 <dylan> eek, wrong parens.
12:51:28 <LordBrain> that and also Cale's "Monads as Containers"
12:53:09 <dylan> my current mental model is "things not wrapped in IO arn't 'real'", which is probably not good, but functions right now. :)
12:53:26 <edwardk> hehehehe
12:53:28 <LordBrain> ehhehe
12:53:31 <roconnor> I'm glad that Monads as Containers is actually helping people. ... especially given that Monads aren't containers ;)
12:53:40 <edwardk> yeah
12:54:05 <LordBrain> oh yeah its very helpful, its one of the few places that points out the relation between monads and functors too.
12:54:06 <vincenz> roconnor: aah holland
12:54:13 <LordBrain> in terms of tutorials
12:54:15 <edwardk> thats the box of boxes of apples article right?
12:54:31 <Cale> roconnor: Well, it's really "monads as kinds of containers" :)
12:55:00 <Cale> Actually "containers" is a good enough mental model of them, if you're able to stretch your idea of "container" enough :)
12:55:34 <edwardk> hehe
12:55:37 <SamB> how about "actions with results of various types"?
12:55:44 <Cale> That works too :)
12:56:11 <SamB> you have to stretch your idea of an action to include lists, but at least they are lazy lists ;-)
12:56:23 <dylan> haskell / monads behave more like I expected programming languages to behave like, before I learned one.
12:56:26 <Cale> Though it's harder to understand verbs than nouns at first :)
12:56:41 <SamB> dylan: heh
12:56:53 <roconnor> vincenz: I'm actually in Gelderland.
12:56:54 <SamB> monads are very like programming languages, but you probably didn't mean it that way
12:57:06 * edwardk keeps trying to find a nice way to hack monads into a scripting language style environment.
12:57:16 <LordBrain> how so dylan ?
12:57:41 <therp> is there some nice printable version for all about monads?
12:57:57 <dylan> it's hard to explain, but it reminds me of how I thought programming would work when I was 14, before I learned anything about programming
12:58:10 <LordBrain> in what way tho?
12:58:11 <SamB> dylan: this is a good thing
12:58:13 <SamB> ;-)
12:58:20 <dylan> LordBrain: perhaps in the declarative way
12:58:24 <LordBrain> oh
12:58:34 <LordBrain> i guess i dont associate that with monads so much
12:58:41 <dylan> But also perhaps in the composition of abstractions
12:59:03 <Cale> dylan: yeah, I had a fairly good time teaching monads to some smart elementary school kids :)
12:59:11 <dylan> But monads do allow a composition of abstractions, no? Like parsec.
12:59:37 <SamB> parsec is not what I'd pick for an example of that statement
12:59:38 <LordBrain> yeah
12:59:51 <SamB> probably because there is no ParsecT yet
13:00:27 <LordBrain> you could compose polymorphic functions without monads tho
13:00:28 <int-e> . o O ( ParsecT [] )
13:00:40 <SamB> hmm
13:00:40 <edwardk> parsec is kind of like one abstraction, beaten to death, twisted, stomped on and ground up into pulp
13:00:45 <Cale> You can still put transformers on top of Parsec... come to think of it, I don't think I've ever tried using that fact.
13:00:52 <edwardk> it doesn't seem very abstract to me
13:00:57 <SamB> Cale: probably because it isn't very convenient
13:00:59 <edwardk> hrmm
13:01:11 <int-e> it's hard to wrap IO around anything
13:01:25 <Cale> well, not IO of course :)
13:01:27 <int-e> I think that'd be the most natural monad to try
13:01:48 <int-e> to try using with Parsec that is.
13:01:56 <SamB> maybe
13:01:57 <Cale> heh, how about NondetT? :)
13:02:07 <SamB> hmm
13:02:09 <LordBrain> i think STM gives a nice simple demonstration of monad power
13:02:15 <Cale> That'd be funny :)
13:02:21 <tibbe> is the GHC library docs built when running make?
13:02:23 <SamB> I really haven't a clue how ParsecT would work
13:02:25 <int-e> I used list above
13:02:26 <tibbe> if so where are they? :)
13:02:38 <int-e> and I have no idea what that'd be good for :)
13:03:00 <edwardk> what i woul like to see would be a transformer for the token crap thats in parsec. the current boilerplate usage pattern is ugly
13:03:08 <SamB> I was just going to wrestle with it until it typechecked, I think...
13:03:43 <dmhouse> Does Chris Kuklewicz IRC?
13:05:54 <SamB> well, I mean, I was going to try and keep it working okay...
13:06:13 <musasabi> edwardk: how would backtracking be handled if it was a transformer (and used e.g. with IO)
13:06:33 <SamB> I figured you just tell people not to do anything stupid ;-)
13:06:59 <musasabi> :-)
13:07:29 <edwardk> not sure =)
13:07:37 <edwardk> i just hate the current syntax
13:07:49 <edwardk> =)
13:08:00 <edwardk> but it looks like the transformer idea is out
13:08:04 <int-e> musasabi: you backtrack. the IO actions will happen. you might provide some primitve undoing stuff on backtracking.
13:08:07 <SamB> is it now?
13:08:18 <edwardk> at least for that case
13:08:26 <LordBrain> i saw yi use partial applications of Left and Right as booleans, how did they pull that off?
13:08:32 <int-e> lift foo; undo foo'; ... (foo' will be called on backtrack)
13:08:37 <SamB> what do you mean?
13:08:39 <int-e> just an idea.
13:08:45 <LordBrain> say i want type, LeftOrRight
13:08:50 <LordBrain> how do i define it?
13:08:50 <Itkovian> any idea what I can do to move for Strictness U(SLLL) to U(SLSS) when the data def is something like Data Foo = !Bar1 !Bar2 !Bar3 !Bar4
13:08:55 <LordBrain> declare it
13:08:56 <dmhouse> LordBrain: as a function?
13:09:15 <dmhouse> I.e., isLeft (Left _) = True; isLeft (Right
13:09:23 <dmhouse> isLeft (Right _) = False
13:09:37 <LordBrain> well, Left and Right are type constructors, but they somehow used them as boolean values..
13:09:58 <dmhouse> LordBrain: got some code?
13:10:05 <LordBrain> well, what would be the type signature for the function tho?
13:10:30 <dmhouse> LordBrain: do you have some specific code you're talking about?
13:10:31 <musasabi> @type either (const True) (const False)
13:10:33 <LordBrain> that takes as one of its parameters a Left or a Right
13:10:34 <dmhouse> You're being a little unclear.
13:10:43 <LordBrain> for example
13:10:48 <lambdabot> forall a b. Either a b -> Bool
13:11:04 <xerox> ?djinn Either a b -> Bool
13:11:05 <lambdabot> f a =
13:11:06 <lambdabot>   case a of
13:11:06 <lambdabot>   Left _ -> False
13:11:06 <lambdabot>   Right _ -> True
13:11:06 <LordBrain> i want something like
13:11:08 <xerox> :-)
13:11:23 <dmhouse> xerox: well, that's backwards ;)
13:11:28 <LordBrain> f :: a -> Bool -> b
13:11:30 <LordBrain> except
13:11:33 <LordBrain> instead of Bool
13:11:40 <LordBrain> i'll be passing in either a Left or a Right
13:12:07 <dmhouse> Ah.
13:12:11 <musasabi> LordBrain: can you paste the type?
13:12:15 <xerox> ?type (. not) . const undefined
13:12:17 <lambdabot> forall c a. a -> Bool -> c
13:12:19 <xerox> :-)
13:12:33 <dmhouse> Well, define an isLeft function and run the Either through that
13:13:12 <roconnor> ?. pl djinn Either a b -> Bool
13:13:13 <lambdabot> (line 3, column 10):
13:13:13 <lambdabot> unexpected "_"
13:13:13 <lambdabot> expecting variable, "(", operator or end of input
13:13:20 <LordBrain> what would be the type signature tho for that parameter?
13:13:43 <roconnor> pl doesn't like case statements I guess.
13:13:46 <dmhouse> Either c d or something.
13:13:47 <edwardk> Either x y
13:13:48 <musasabi> @pl either (constr True) (const False)
13:13:48 <lambdabot> either (constr True) (const False)
13:13:49 <LordBrain> @type Right
13:13:50 <lambdabot> forall b a. b -> Either a b
13:13:57 <LordBrain> @type Left
13:13:58 <lambdabot> forall b a. a -> Either a b
13:14:12 <musasabi> I don't think there is a nice way to combine those consts.
13:14:47 <LordBrain> the a and b are switched around
13:15:16 <LordBrain> maybe i could do something like a -> Either b c ?
13:15:43 <musasabi> no
13:15:45 <dmhouse> musasabi: what you pasted is already points-free, but you misspelt const anyway.
13:16:03 <musasabi> true
13:16:22 <dmhouse> LordBrain: you basically want to define a function for turning Eithers into Bools? How should it behave? Be precise.
13:16:39 <LordBrain> no.. i dont want to convert them
13:16:44 <_roconnor> @pl \a b c d e f -> c
13:16:44 <lambdabot> const (const (const . const . const))
13:16:52 <LordBrain> i thought i saw yi do this
13:17:01 <LordBrain> just use them as they are
13:17:24 <LordBrain> kinda like as if, someone had done data LeftOrRight = Left | Right
13:17:37 <LordBrain> and then made functions
13:17:46 <dmhouse> If you've actually got the code in front of you, that'd be useful.
13:17:48 <LordBrain> f:: LeftOrRight -> b
13:19:05 <xerox> I think there could be...
13:19:36 <LordBrain> here it is
13:19:39 <LordBrain> this is what they did:
13:19:43 <LordBrain> type Direction = () -> Either () ()
13:19:46 <edwardk> heh
13:19:51 <ebel> .join #lugradio
13:20:01 <ebel> Sorry!
13:20:03 <LordBrain> then they have functions where Direction is passed in as one of the arguments
13:20:04 <Itkovian> heh
13:20:16 <LordBrain> i'm trying to emulate this style
13:20:24 * edwardk isn't sure why =)
13:20:40 <LordBrain> you mean you're not sure why try to emulate it?
13:20:43 <edwardk> it seems mainly that they wanted to have Left or Right as their constructors
13:20:48 <LordBrain> yes
13:20:48 <xerox> \f -> f (const True) (const False)
13:20:48 <edwardk> but they were already taken
13:20:49 <LordBrain> haha
13:20:53 <xerox> ?pl \f -> f (const True) (const False)
13:20:55 <LordBrain> i know
13:21:01 <xerox> zZzZ
13:21:06 <LordBrain> its a hackerish seeming trick
13:21:07 <edwardk> so they populated them with units
13:21:09 <lambdabot> flip ($ const True) (const False)
13:21:22 <_roconnor> edwardk: that seems a bit awkard
13:21:27 <edwardk> i agree
13:21:28 <LordBrain> but when i try to do it, i get problems.. do i need a special switch on my compiler?
13:21:34 <_roconnor> import Prelude hiding (Left, Right)
13:22:09 <_roconnor> although that is also a little akward
13:22:15 <edwardk> roconnor: which works until you need Either
13:22:17 <xerox> ?type liftM2 either ($ True) ($ False) const
13:22:19 <lambdabot> forall a. Either a a -> Bool
13:22:21 <xerox> :D
13:22:32 <_roconnor> edwardk: Prelude.Left and Prelude.Right still works?
13:22:36 <edwardk> xerox: haha
13:22:41 * xerox grins
13:22:52 <edwardk> true
13:22:53 <dmhouse> Why not call them L and R, or Links and Rechts, or Gauche and Droit, or West and East or Truthity and Falsity or Yin and Yang or something?
13:23:09 <edwardk> not my program. not my practice to defend =)
13:23:19 <dmhouse> *Truth
13:23:21 <_roconnor> if not adding import qualified Prelude will make Prelude.Left and Prelude.Right work.
13:24:00 * edwardk shrugs. i was just trying to get inside the head of the author.
13:24:02 <_roconnor> dmhouse: I thiink Truthity and Falsity are taken in the Haskell' prelude.
13:24:16 * edwardk winces.
13:24:26 <edwardk> truthity?
13:24:38 <LordBrain> yes its a strange thing, yi does it tho
13:24:41 <emertens> and falsishness?
13:24:55 <dmhouse> ?index Truth
13:24:56 <lambdabot> bzzt
13:24:59 <dmhouse> ?index Falsity
13:25:00 <lambdabot> bzzt
13:25:14 <_roconnor> ?index Truthiness
13:25:14 <lambdabot> bzzt
13:25:18 <LordBrain> it seems to work fine for them
13:25:39 <edwardk> yes but why perpetuate this practice? =)
13:26:06 <LordBrain> i think i need -fglasgow-exts
13:26:12 <LordBrain> lol
13:26:27 <LordBrain> well i'm trying to prototype ideas i might add to yi
13:26:38 <edwardk> ah
13:26:40 <emertens> Who do you guys things this is making fun of? http://youtube.com/watch?v=Mt1bgsvsWms
13:26:47 <lambdabot> Title: YouTube - Prangstgrup Powerbook Start up Sound Prank!!
13:27:04 <emertens> I want to do this at work :)
13:27:19 <emertens> or set it as the start up sound on a friends laptop
13:27:21 <xerox> ?pl \(go:_) -> go to_bed
13:27:27 <lambdabot> flip head to_bed
13:28:01 <_roconnor> @seen shapr
13:28:02 <lambdabot> shapr is in #ScannedInAvian and #haskell. I last heard shapr speak 43 minutes and 26 seconds ago.
13:28:35 <_roconnor> I was thinking of submiting my TMR article to a conference ...
13:28:47 <_roconnor> to make sure it is below academic article quality.
13:28:52 <greenrd> heh
13:29:03 <edwardk> heh
13:29:49 <_roconnor> I'm not sure what to do if it gets accepted.
13:31:30 <edwardk> roconoor: erm, enjoy havng an article published? =)
13:32:14 <edwardk> you could always throw in some outlandish wolframish claims in the end, and claim to have invented the entire discipline or something to ensure it gets rejected.
13:32:15 <LordBrain> yeah that would kickass
13:32:50 <greenrd> hehe
13:33:10 <LordBrain> if it gets accepted will it lower your over all esteem of academia?
13:33:17 <LordBrain> lol
13:34:02 <roconnor> ``As we all know, I invented the idea of domain specific langauges in Haskell, ... and recursive do ... and monads ... and Haskell ... and functional programming'''
13:34:33 <roconnor> > 2^64
13:35:04 <lambdabot>  18446744073709551616
13:35:04 <edwardk> roconnor: now you're getting into the spirit of it
13:35:10 <edwardk> 'and discovered the number  18446744073709551616 through my extensive personal investigation into mathematics'
13:36:04 <roconnor> edwardk> I wrote an antomiton to generate that number.
13:36:09 <edwardk> ahh
13:36:10 <LordBrain> jeez i'm still having trouble getting this LeftOrRight thing to work
13:37:49 <anborn> anyone has ever seen a "INTERNAL ERROR: discrArity" while using runhugs?
13:37:59 <roconnor> LordBrain: thank goodness.  I'd be upset if it was easy.
13:38:05 <LordBrain> lol
13:38:10 <sjanssen> LeftOrRight?
13:38:25 <LordBrain> its what yi does, it defines Direction
13:38:36 <LordBrain> Direction = () -> Either () ()
13:38:57 <LordBrain> and then it uses partial applications of Left and Right as Booleans
13:39:27 <sjanssen> hmm, that is clever/bizarre
13:39:33 <LordBrain> yes...
13:39:56 <sjanssen> @where yi
13:39:57 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
13:40:09 <LordBrain> but i'm emulating it because i want to test out ideas for potential integration into yi
13:40:55 <roconnor> LordBrain: so, what's the problem?
13:41:31 <LordBrain> well... i'm having difficulty getting the types to match.. i dont want to have to put a signature every time i call a function
13:41:48 <LordBrain> maybe this is a monomorphism restriction sort of issue?
13:42:17 <roconnor> LordBrain: which types?
13:43:29 <LordBrain> i have things like f(Right) = 1 for examle
13:43:37 <LordBrain> or f Right = 1
13:43:41 <LordBrain> since i dont need parens i know
13:44:09 <roconnor> hmm
13:44:20 <roconnor> you won't be able to pattern match I don't think.
13:45:37 <sjanssen> > case Left of Left -> 2; Right -> 3
13:45:42 <lambdabot>  Couldn't match `a -> Either a b' against `Either a1 b1'
13:45:42 <LordBrain> ok
13:46:25 <LordBrain> so hmmmm without pattern matching...
13:46:40 <LordBrain> is that even possible?
13:46:41 <edwardk> roconor: maybe something more like, `and since we all know that this number is (2^2^2)^2^2^2, this demonstrates the fundamentalness of the number 2 in computer science, an idea that i have long championed, since I invented the internet.'
13:46:46 <roconnor> you will need to do something like f x | isLeft (x ()) = ...
13:47:14 <roconnor> edwardk: no one will believe that.  Everyone knows that Al Gore invented the internet.
13:47:28 <LordBrain> f x = case (x ()) of  Right () -> "Yay"
13:47:31 <sjanssen> hmm, so why does Yi use this partially applied Either rather than an ADT?
13:47:32 <edwardk> roconnor: hence your post will get rejected and you can post it to the reader =)
13:47:44 <roconnor> Or at least everyone knows that Wired invented the story that Al Gore invented the internet.
13:47:44 <LordBrain> ask don...
13:47:52 <edwardk> yeah i was going to say =)
13:47:53 <roconnor> edwardk: brilliant.
13:50:38 <edwardk> so what praytell is this non-academic quality jewel that we are trying to reserve for the reader?
13:52:33 <roconnor> edwardk: I illustrate how to use recursive do to write a toy assembler in Haskell.
13:52:40 <edwardk> ah cool =)
13:52:53 <edwardk> wish i would have had that when i was writing the jit =)
13:53:18 <edwardk> bbiab
13:53:28 <LordBrain> an assembler that is a toy? or one that makes toys?
13:53:33 <LordBrain> hehe
13:55:12 <roconnor> :)
13:57:06 <LordBrain> ghc does a fine job with error catching
14:13:11 <edwardk> @users
14:13:19 <lambdabot> Maximum users seen in #haskell: 221, currently: 212
14:13:54 <sjanssen> LordBrain: this () -> Either () () is ridiculously stupid
14:14:02 <edwardk> sjanssen: heh
14:14:20 <sjanssen> I just spent 10 min. fixing it, I'll probably send a patch
14:14:31 <LordBrain> lol
14:14:35 <edwardk> good =)
14:14:48 <edwardk> any idea who added it?
14:14:49 <LordBrain> dont forget to change the remark about it
14:15:13 <sjanssen> LordBrain: yeah, I'll try to hunt down comments about it
14:15:44 <LordBrain> doesnt that break the interface tho? what about all these plugins?
14:15:53 <LordBrain> you changing it everywehre?
14:15:58 <sjanssen> I fixed all the keymaps too
14:16:05 <LordBrain> ok
14:16:11 <LordBrain> you using L and R ?
14:16:19 <sjanssen> I chose GoLeft and GoRight
14:16:26 <sjanssen> but maybe L and R is better
14:16:37 <LordBrain> or just Forward and Backward
14:16:43 <LordBrain> *shrugs*
14:16:45 <LordBrain> i dont know
14:16:46 <sjanssen> I chose those because I could easily search replace them if I change my mind
14:16:57 <LordBrain> yeah
14:17:04 <sjanssen> forward/backward is probably better
14:17:27 <LordBrain> i dont know
14:17:31 <LordBrain> GoLeft works for me
14:18:08 <sjanssen> I'm not too familiar with Yi, I just added the ADT in Yi.Core.  Is that the right place?
14:18:24 <LordBrain> i assume you should replace the definition of Direction
14:18:33 <LordBrain> and then fix everything that depends on it
14:19:25 <sjanssen> Yi.Core uses Direction.  The place that originally had the type def imports Yi.Core
14:19:36 <sjanssen> so I have to dodge the cyclic dependency
14:20:11 <LordBrain> hmmm yeah
14:20:18 <sjanssen> that's another funny part about all this, only Yi.CharMove used a nice name like Direction.  The other modules just wrote out () -> Either () ()
14:21:02 <LordBrain> well the other modules probably dont even make use of it directly except via api calls, and so dont need it in any of their signatures
14:22:19 <shapr> roconnor: Oh, phrack stopped.
14:28:42 <LordBrain> my bindings for 'b' 'e' and 'w' dont like tabs...
14:29:21 <LordBrain> hmmm
14:30:01 <LordBrain> shapr: how well does your yi handle it if you have a word followed by some tabs?
14:30:04 <LordBrain> and you use '
14:30:16 <LordBrain> 'w' to move from the previous line to the beginning of that word
14:30:42 <LordBrain> er i meant sjanssen
14:33:05 <sjanssen> LordBrain: same way as vim (I think)
14:33:55 <LordBrain> well i meant do you get an error
14:34:12 <LordBrain> apparently not
14:34:36 <sjanssen> LordBrain: do you want me to CC you on this patch?
14:35:14 <LordBrain> sure
14:35:21 <LordBrain> lordbrain <> riseup . net
14:36:41 <sjanssen> done
14:39:37 <dcoutts__> SyntaxNinja: xerox: the code is sent!
14:41:42 <SyntaxNinja> sweeeeet
14:42:05 <mcnster> hello
14:42:52 <mcnster> how many loads could a boot loader load if a boot loader could load boots?
14:43:27 <emertens> boot loaders don't load loads
14:43:57 <emertens> shesh
14:44:09 <shapr> Boot loaders would be handy for shoe stores.
14:46:05 <mcnster> good one, shapr :)
14:47:26 <dcoutts__> SyntaxNinja: so cabal and ghc 6.6...
14:49:27 <dcoutts__> SyntaxNinja: I'd tend to agree, we're not likely to get configurations in
14:49:54 <dcoutts__> I'd have to check our trac milestones but I think we're not at our 1.2 release goals
14:49:57 <dcoutts__> so just 1.1.6
14:51:59 <SyntaxNinja> yeah.
15:00:01 <emertens> @type ((*)
15:00:02 <lambdabot> parse error (possibly incorrect indentation)
15:00:02 <emertens> @type (*)
15:00:03 <lambdabot> forall a. (Num a) => a -> a -> a
15:00:14 <emertens> @type sum
15:00:15 <lambdabot> forall a. (Num a) => [a] -> a
15:42:29 <LordBrain> aaaah the fresh yi checkout has the tab bug...
15:42:34 <LordBrain> i thought it was something i had introduced
15:43:31 <LordBrain> apparently hitting 'w' on a line with tabs in it gives "user error (wmove)"...
15:45:44 * dcoutts__ investigates a yi+gtk tab bug
15:54:36 <LordBrain> nothing to do with gtk
15:54:45 <LordBrain> there's a tab bug with ncurses too
15:54:49 <LordBrain> unless you mean a different bug
15:55:46 <benja_> hi
15:55:59 <benja_> anybody know what it means when runghc gives me 'error 127'?
15:56:07 <benja_> like this
15:56:08 <benja_> runghc -fglasgow-exts Translator.hs ../parserA.toy TranslatedParser > TranslatedParser.hs
15:56:12 <benja_> make: *** [translator] Error 127
15:56:54 <dcoutts__> LordBrain: a different bug I think
15:57:23 <LordBrain> wmove is an ncurses function right?
15:59:58 <LordBrain> i wonder what would cause it to fail
16:00:01 * dcoutts__ knows nothing about ncurses
16:00:58 <LordBrain> aaaaack
16:01:03 <LordBrain> gtk took over my firefox!@
16:01:13 <LordBrain> how hte heck..
16:01:16 <benja_> huh, it seems that just adding -fglasgow-exts gives the 'error 127'
16:01:17 <dcoutts__> mwahahaa
16:01:37 <LordBrain> its acting like epiphany with the tabs
16:01:53 <LordBrain> (
16:01:55 <LordBrain> :(
16:01:59 <LordBrain> i want my firefox back
16:02:20 <benja_> (i.e., on a source file not actually using any of the exts, it works without that flag and gives the error with the flag)
16:03:46 <LordBrain> i had to kill that gnome daemon
16:03:49 <LordBrain> that fixed it
16:03:51 <LordBrain> whew
16:04:11 <LordBrain> thats nutty
16:06:18 <benja_> *oh*. argh.
16:06:45 <benja_> runghc -fglasgow-exts says that glasgow-exts is the path to ghc...
16:06:57 <LordBrain> lol
16:07:05 <benja_> ah, putting the option in the source works
16:07:07 <benja_> whew
16:07:36 <LordBrain> hmmmmmm
16:26:26 <benja_> anybody know a good way to convert [Maybe a] to Maybe [a]?
16:26:49 <benja_> i.e., if there are any nothings, give nothing, otherwise give a list
16:27:17 <dcoutts__> @hoogle [Maybe a] -> [a]
16:27:18 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
16:27:40 <dcoutts__> benja_: you probably want that type rather than Maybe [a]
16:27:48 <dcoutts__> what would the extra Nothing be?
16:27:51 <dylan> @hoogle [Maybe a] -> Maybe [a]
16:28:02 <benja_> dcoutts__: a matching error
16:28:08 <lambdabot> No matches, try a more general search
16:28:32 <benja_> but I see that most people would want catMaybes, so I'll have to write my own I suppose
16:28:36 <dcoutts__> benja_: you mean if any of them are Nothing then you get Nothing?
16:28:43 <benja_> dcoutts__: yup
16:28:46 <dcoutts__> ah ok
16:28:51 <dcoutts__> try sequence
16:28:57 <dcoutts__> @type sequence
16:28:59 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
16:29:12 <dcoutts__> @type (sequence ::  [Maybe a] -> Maybe [a])
16:29:14 <lambdabot> forall a. [Maybe a] -> Maybe [a]
16:29:33 <dcoutts__> benja_: since Maybe is a monad
16:29:52 * benja_ searches the definition of sequence
16:29:56 <dcoutts__> > sequence [Just 'a', Just 'b']
16:29:57 <lambdabot>  Just "ab"
16:30:03 <dcoutts__> > sequence [Just 'a', Just 'b', Nothing]
16:30:05 <lambdabot>  Nothing
16:30:06 <benja_> there
16:30:43 <benja_> interesting :)
16:30:57 <benja_> anyway, seems right, thanks!
16:31:20 <Heffalump> if that's what you want, probably you are using Maybe in a monadic sort of way
16:31:34 <Heffalump> so you may want to consider using monad syntax generally
16:31:54 <benja_> Heffalump: hmm, point
16:33:23 <LordBrain> hmmmm i dont know... just because you can be general doesnt mean you should
16:33:45 <LordBrain> i dont know tho, you're probably right
16:34:07 <benja_> it makes for easier code than having lots of pattern guards :)
16:34:11 <LordBrain> i use sequence to perform a list of io actions sometimes
16:34:15 <Heffalump> I'm not suggesting using the generality, just that monad syntax might be nicer to use.
16:34:30 <Heffalump> the type of a monad computation can be limited to a single monad
16:34:40 <LordBrain> sure
16:35:06 <Heffalump> can anyone see any reason why the template haskell datatypes shouldn't be instances of the Data class? (from Data.Generics, the Scrap Your Boilerplate stuff)
16:36:17 <dcoutts__> nope
16:38:47 <Heffalump> where is the ghc 6.4 darcs repo?
16:39:11 <Heffalump> oh, http://darcs.haskell.org/ghc.ghc-6.4/ I guess
16:39:13 <lambdabot> Title: Index of /ghc.ghc-6.4
16:44:29 <heatsink> I know that sequence is a single function, but it seems to be a family of functions, all useful, but with completely unrelated behaviors.
16:44:38 <benja_> =)
16:44:51 <LordBrain> j,,,
16:44:53 <LordBrain> hmmm
16:45:14 <Heffalump> heatsink: they are all related by the general behaviour of monads
16:47:39 <lisppaste2> LordBrain pasted "String of Cases" at http://paste.lisp.org/display/23849
16:47:59 <LordBrain>  ^ is this a common haskell idiom?
16:49:22 <Cale> LordBrain: not so common
16:49:47 <kuribas> Can emacs indent that?
16:50:09 <LordBrain> i probably would have done a let clause ... with maybe one case
16:50:25 <Cale> yes, there's no need for all that
16:50:40 <LordBrain> it's not bad looking tho
16:50:50 <Cale> let/where would work fine, because no pattern matching is happening
16:50:54 <LordBrain> it lines up and things.. it threw me for a sec tho
16:51:15 <LordBrain> the last one has a pattern match
16:51:43 <Cale> perhaps it was determined that cases were slightly faster
16:52:18 <LordBrain> interesting...
16:52:31 <Cale> Was this written by dons? He might have looked at the translation to core.
16:53:12 <LordBrain> dons name is on the top yeah
16:54:27 <LordBrain> cleaning up ncurses code is under design plan in the TODO file, but i'm not sure what he has in mind.
16:57:30 <musasabi> non-ncurses console graphics lib (just ascii-escapes) might be a fun project to do in Haskell.
16:58:42 <LordBrain> hmmm i dont have that desire... except to possibly fix the Esc delay problem..
16:58:58 <LordBrain> in Yi
17:02:11 <musasabi> probably solvable in curses
17:02:44 <Cale> http://tasvideos.org/movies.cgi?id=380 !!
17:03:20 <LordBrain> well... i dont know, might have to write our own getch
17:03:30 <heatsink> Cale: wow
17:13:26 <dons> thanks guys for the Direction patch. It was just a game I was playing ;)
17:13:37 * dons -> back in 20
17:19:33 <SamB> ack
17:19:54 <SamB> I tried to write a case statement with -> instead of => in RML
17:20:00 <SamB> at least it gives a line number...
17:21:16 <Heffalump> are the ghc6 darcs repos (ghc.ghc-6.4 and ghc) related if I don't do a darcs get --partial?
17:22:21 <LordBrain> hey dons, i'm looking at UI.hs now. I was annoyed by the tab problem... anyway, i can write a function that determines display-width from a string... not sure how to integrate it into your program tho... as i'm not fully clear on which of these functions require actual width in terms of chars and which require their screen representation width
17:24:11 <LordBrain> dons: did you ever get my other patches by the way?
17:25:31 <LordBrain> looks like i missed him.. it was a drive by
17:25:34 <LordBrain> hehe
17:36:48 <benja_> "Obscure XML character encoding: ascii"
17:36:52 <benja_> -- feedvalidator.org
17:37:23 <dons> LordBrain: no patches have arrived yet :/
17:37:36 <dons> you might have to post your repo, and I'll darcs pull from there?
17:38:26 <kpreid> benja_: you want "us-ascii"
17:39:14 <benja_> hmm, true
17:40:07 <Heffalump> dons: is it ever useful to have GhcWithInterpreter enabled for the stage1 build? Or does it have to be the same for both stage1 and stage2?
17:41:09 <LordBrain> is posting a repo any more involved than putting all the files into a directory on an http server?
17:41:28 <kpreid> no
17:42:01 <LordBrain> ok
17:42:39 <benja_> LordBrain: (if you want to push there, you'll need to have darcs installed on the server)
17:43:04 <dons> Heffalump: not sure. I can't see why it would ever be needed for stage1
17:44:24 <petekaz> Is building GHC out of the question for a newbie?  I'd like to build the current head on my dual core mac book.  Should I not bother?
17:45:23 <dons> I don't think its that hard these days.
17:45:29 <dons> do you have a ghc on this machine already?
17:45:34 <petekaz> no.
17:45:39 <dons> ok. then its harder
17:45:43 <petekaz> brand new mac book.
17:45:53 <dons> you might just want to get a ghc from one of the other core duo users
17:45:58 <dons> ?seen seafood
17:46:00 <lambdabot> seafood is in #haskell. I don't know when seafood last spoke.
17:46:02 <dons> for example ^^
17:46:06 <petekaz> ok.
17:46:25 <dons> @tell seafood do you have a ghc for the new mac built?
17:46:33 <lambdabot> Consider it noted.
17:46:47 <petekaz> thanks.
17:47:49 <dgoldsmith> audreyt's tarball seems to work well, but I haven't tried building anything big. It's at: http://hackage.haskell.org/trac/ghc/wiki/X86OSXGhc
17:47:53 <lambdabot> Title: X86OSXGhc - GHC - Trac
17:48:08 <dgoldsmith> Specifically, http://pugs.blogs.com/dist/ghc-6.5.20060608.tar.bz2
17:48:09 <dons> ah, there you go :)
17:48:19 <dons> yeah, that sounds highly reasonable
17:48:24 <petekaz> ok. thanks.
17:48:28 <petekaz> I'll give that a try.
17:48:29 <LordBrain> ok here http://urz.jerkface.net/yi/
17:48:34 <audreyt> glad to be of help :)
17:48:38 <dons> LordBrain: ok. cheers
17:48:39 <LordBrain> dons, that's my yi repo
17:48:40 * dons pulls
17:49:01 <LordBrain> i didnt apply the patch to change the Direction
17:49:23 <dgoldsmith> The only other thing that works is installing 6.4.1 and running ghci under Rosetta. That's what I was doing before. You can't run ghc because it generates PPC assembly and then that doesn't assemble.
17:49:39 <dgoldsmith> I suppose -fvia-c might work; I didn't try that.
17:49:41 <alec> liyang: trying to build amd64 packages for gtk2hs_0.9.10-2, but gtk2hs_0.9.10.orig.tar.gz has the wrong file size - any ideas?
17:49:52 <LordBrain> do i use darcs to apply it?
17:50:40 <dons> LordBrain: ah ok.
17:50:44 <dons> you need to: darcs whatsnew -s
17:50:46 <dons> to get an idea.
17:50:49 <dons> darcs record
17:50:50 <dons> to record it
17:50:55 <dons> and maybe darcs push
17:51:05 <dons> to push it to the public repo, a tthe url above
17:51:18 <dons> ah, patches!   * Adding highlighting of selected text.
17:51:23 <LordBrain> ok i applied it
17:51:26 <dons> * Added a modified flag to buffer info data structure in Yi/Core.hs
17:51:42 <LordBrain> neat o
17:51:44 <LordBrain> i want those
17:51:48 <alec> liyang: and by gtk2hs_0.9.10-2 I meant -1; when I try to get the -2 dsc I get a forbidden error
17:54:00 <LordBrain> dons, i've been bouncing it around in my head some, vim has this notion of a "Text Object" which means word, sentence, paragraph, or any of a number of things, as an abstraction it could even apply to chars... the really in normal mode what we're realy doing is navigating text objects in terms of all our movement... you notice you cant stick the cursor outside the text and it backs up when you hit Esc
17:54:28 <dons> right
17:54:40 <dons> that's to do with end of line handling
17:55:01 <dons> and the way vi/vim treat \n
17:55:07 <dons> though, isn't it?
17:55:50 <LordBrain> i'm not following you exactly
17:55:57 <LordBrain> i havent looked at hte source for vim or vi
17:56:04 <LordBrain> what i'm doing is reading the help
17:56:15 <dons> ok. anyway. continue with your brain bouncing..
17:58:20 <LordBrain> well, i am thinking we might want to have a design that deals with text objects in general in a mostly unified way, ie, there are many analogous operations except instead of for chars or words its for paragraphs etc... have the notion of text object actually in our source at a lower level... it seems like somethign that would be useful to any of the editors.
17:58:58 <petekaz> any TextMate users here?
17:59:23 <LordBrain> i even wrote a little type class
17:59:42 <petekaz> is there a Haskell syntax for it?  I'm debating whether or not I should commit blasphemy and try TextMate instead of using me precious emacs.
17:59:42 <dons> if you can code up a useful example, where it does simplify things. then that sounds good
17:59:49 <LordBrain> but its too buggy, i wouldnt want to contaminate yi with it right now or possibly ever.
17:59:56 <dons> heh ok.
17:59:59 <dons> well, its a nice idea.
18:00:08 <dons> we do want to move to emacs-ish levels of abstraction
18:00:12 <gzl> petekaz: google haskell textmate
18:00:34 <gzl> petekaz: and check out the textmate bundles repository
18:00:44 <gzl> petekaz: if there's nothing in there, you're stuck
18:00:48 <petekaz> ok.
18:01:17 <gzl> err, there may be something listed on google that's not in the textmate repository
18:02:28 <LordBrain> anyway, it offers a lot of potential, as we can add new text objects, various different langauges can have differetn kinds of text objects, and it gives a unified way to deal with pretty much every chunk of text, a onscreenline, a textline, a screen-page... i wonder if it would be nice to work with all these types of things via one general textobject interface.
18:03:51 <dons> yeah, if you can think up an api, or mybe a typeclass to it. maybe it would be a layer above CharMove.hs ?
18:04:06 <LordBrain> yeah it could be
18:05:54 <LordBrain> btw, the 'w' 'b' and 'e' keys dont handle blank lines the same way as vim... but i'm not entirely sure if vims way is better... should we aim for as much compatability as possible tho?
18:11:42 <liyang> alec: oops. :-/
18:12:17 <liyang> alec: I thought mini-dinstall would fix my permissions... :(
18:12:32 <liyang> Fixed now. Investigating a permanent solution.
18:14:55 <dons> LordBrain: yes. compatible=good
18:14:56 <liyang> (and by fixed I mean the 0.9.10-2 version. I know the -1 sources are `broken'.)
18:31:04 * edwardk waves hello.
18:31:07 <LordBrain> Vimacs is just vim with lots of settings to make it emacs like, right?
18:31:16 * edwardk twitches.
18:31:21 <edwardk> thats like tits on a pig =)
18:31:45 <edwardk> going the other way i could understand, vi at least takes fewer keystrokes =)
18:31:53 <LordBrain> hehehe yah
18:31:56 <alec> liyang: thanks so much!
18:32:16 <LordBrain> well edwardk vimacs doesnt effect normal mode, only insert
18:32:17 <LordBrain> i think
18:33:06 <edwardk> lord: ah
18:33:34 <LordBrain> i'm not entirely sure the Vimacs.hs plugin in yi is intended to emulate the other Vimacs tho
18:33:40 <edwardk> ah
18:33:52 <LordBrain> i would assume it is
18:34:34 <LordBrain> no its not
18:34:43 <LordBrain> its an entirely new thing with the same name
18:34:50 <dons> wasn't ozone the author of the real vimacs?
18:35:00 <dons> ?seen ozone
18:35:02 <lambdabot> ozone is in #haskell. I last heard ozone speak 1 day, 5 hours, 34 minutes and 53 seconds ago.
18:35:39 <LordBrain> http://www.algorithm.com.au/vimacs/
18:35:39 <lambdabot> Title: Vimacs: Vim-Improved eMACS
18:35:43 <DukeDave> Hey gang, I have a question about a puzzle solver I am writing - not sure if my current implementation is very smart...
18:35:46 <dons> ah ha. yes.
18:36:02 <LordBrain> i think thats what i think of as the "real" vimacs.. tho i think there are a number of things with this name
18:36:25 <DukeDave> I need to filter a list of String based on conditions, that they should have a certain Char and a certain index
18:36:44 <dons> DukeDave: ok.
18:37:06 <DukeDave> so I've defined a 'test' function    (String -> Int) -> String -> Bool
18:37:16 <alec> DukeDave: what do you mean by 'certain index'?
18:37:30 <LordBrain> i dont like vimacs
18:37:45 <DukeDave> alec, for example:    "haskell"  has 'a' at index 1
18:38:08 <LordBrain> i tried it... it must undo some vimisms or something that are important to me
18:38:13 <DukeDave> "haskell" !! 2 = 's'  == True
18:38:47 <alec> DukeDave: gotcha
18:38:50 <DukeDave> then I map my test func over the list of conditions to produce [String -> Bool]
18:39:10 <dons> DukeDave: would you like to paste the code?
18:39:12 <dons> ?paste
18:39:13 <lambdabot> http://paste.lisp.org/new/haskell
18:39:15 <dons> it might help
18:39:20 <DukeDave> heh, yeah, I was just thinking that
18:39:21 <DukeDave> :)
18:41:47 <LordBrain> what about, myfilter ch index = filter ((==ch).(!! index)
18:42:38 <dons> hmm.
18:43:19 <lisppaste2> DukeDave pasted "Some messy code" at http://paste.lisp.org/display/23853
18:43:30 <DukeDave> I know it can be cleaned up a lot
18:43:49 <DukeDave> the real issue is that I have a list of conditions for a list of words
18:44:35 <DukeDave> currently I'm using 'and' to produce a test for all the conditions, and then filtering on that
18:44:51 <edwardk> ok
18:45:00 <DukeDave> but if anyone feels like showing off with a more experienced and elegant solution I'd be grateful :)
18:47:48 <edwardk> hrmm
18:49:13 <LordBrain> how about a comprehension [ s :  s <- Strings, c <- Conditions, c s]
18:49:41 <LordBrain> er with a | instead of a :
18:50:05 <dons> nice idea LordBrain
18:50:44 <DukeDave> ah, so that would pair each string with each condition?
18:51:19 <LordBrain> yeah
18:51:38 <LordBrain> the cases are wrong, and the : should be |
18:51:44 <LordBrain> heh, but you get the idea
18:52:02 <DukeDave> lol, not giving it all away ;)
18:52:48 <edwardk> map snd $ filter (\x -> (foldr (\y z -> y x && z) True tests)) $ zip [1..] words
18:52:54 <edwardk> or something like that?
18:53:02 <edwardk> you can probably pointless it more
18:53:14 <edwardk> @pl \y z -> y x && z
18:53:14 <lambdabot> (&&) . ($ x)
18:54:13 <dons> @pl \z y -> z && y x
18:54:18 <lambdabot> (. ($ x)) . (&&)
18:54:20 <edwardk> heh
18:54:25 <edwardk> yeah tied that by im =)
18:55:28 <edwardk> there might be a fancier way to get that with map and and
18:55:33 <edwardk> i just didn't think of it first
18:56:30 <LordBrain> > [ s | s <- ["how","Now","Brown","Cow"] cond <- [(
18:56:33 <LordBrain> oops
18:56:34 <lambdabot>  Parse error
18:56:38 <LordBrain> heh, hard to type all that
18:56:52 <edwardk> map snd $ filter (\x -> and (map ($ x) tests)) $ zip [1..] words
18:57:14 <madpickle> what would be the best way to test if a number is palindromic?
18:57:27 <madpickle> convert to a string first and compare?
18:57:27 <edwardk> @pl \x -> and $ map ($x) tests
18:57:28 <lambdabot> and . flip map tests . flip id
18:57:48 <LordBrain> > [ s | s <- ["how","Now","Brown","Cow"] cond <- [((=='o').(!! 2)), ((==3).length)] ]
18:57:51 <lambdabot>  Parse error
18:57:53 <edwardk> map snd $ filter (and . flip map tests . flip id) $ zip [1..] words
18:57:55 <edwardk> whee
18:58:01 <edwardk> no points at least
18:58:06 <LordBrain> > [ s | s <- ["how","Now","Brown","Cow"] cond <- [((=='o').(!! 2)), ((==3).length)], c s]
18:58:07 <edwardk> except for the tests and words
18:58:11 <LordBrain> > [ s | s <- ["how","Now","Brown","Cow"] cond <- [((=='o').(!! 2)), ((==3).length)], cond s]
18:58:16 <dons> missing comma after the list
18:58:22 <lambdabot>  Parse error
18:58:23 <lambdabot>  Parse error
18:58:26 <LordBrain> > [ s | s <- ["how","Now","Brown","Cow"], cond <- [((=='o').(!! 2)), ((==3).length)], cond s]
18:58:28 <lambdabot>  ["how","Now","Brown","Cow"]
18:58:30 <dons> not sure why lambdabot's slow hmm.
18:58:44 <dons> ?uptime
18:58:45 <lambdabot> uptime: 2 days, 15 hours, 54 minutes and 18 seconds
18:58:45 <edwardk> thats the best use for a list comprehension i've seen in a while.
18:58:49 <LordBrain> @type length
18:58:50 <lambdabot> forall a. [a] -> Int
18:59:03 <dons> ?users
18:59:08 <lambdabot> Maximum users seen in #haskell: 221, currently: 199
18:59:11 <LordBrain> why would "Brown" show up there?
18:59:13 <DukeDave> yeah, I like the list comprehension form :)
18:59:54 <edwardk> hrmm
18:59:58 <edwardk> not sure thats right
19:00:03 <DukeDave> hang on, will a string be allowed through on passing at least one test?
19:00:04 <DukeDave> :|
19:00:12 <LordBrain> i wouldnt expect it to
19:00:19 <edwardk> it seems that you are generating a list of conditions, so if it passes both conditions, one it generate two entries of the same value?
19:00:45 <edwardk> > [ s | s <- ["how","Now","Brown","Cow"], cond <- [((=='o').(!! 2)), ((==5).length)], cond s]
19:00:46 <lambdabot>  ["Brown","Brown"]
19:00:48 <LordBrain> ooooh
19:00:49 <DukeDave> [i  |  i <- [0..5], i <3, i > 3]
19:00:54 <DukeDave> > [i  |  i <- [0..5], i <3, i > 3]
19:01:01 <edwardk> yeah thought so
19:01:14 <LordBrain> darn
19:01:18 <lambdabot>  []
19:01:48 <LordBrain> well, i guess we can take an intersection after filtering each cond
19:02:16 <mauke> @type all
19:02:18 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
19:03:31 <edwardk> > [ s | s <- ["how","Now","Brown","Cow"], and $ map ($s) [(=='o').(!!2),(==5).length] ]
19:03:32 <lambdabot>    GHC stage restriction: `s'
19:03:32 <lambdabot>    is used in a top-level splice, and must...
19:03:40 <edwardk> hrmm
19:03:55 <edwardk> oh, heh th
19:04:06 <edwardk> > [ s | s <- ["how","Now","Brown","Cow"], and $ map ($ s) [(=='o').(!!2),(==5).length] ]
19:04:14 <mauke> @type \fs xs -> filter (\x -> all (flip id x) fs) xs
19:04:14 <lambdabot>  ["Brown"]
19:04:16 <lambdabot> forall a. [a -> Bool] -> [a] -> [a]
19:04:17 <LordBrain> could still use a comprehension yeah
19:04:35 <LordBrain> oh is the word and allowed in there?
19:04:37 <edwardk> can still use a comprehension you just can't use the tests as a list in the comprehension
19:04:38 <LordBrain> "and"
19:04:43 <LordBrain> yeah
19:04:45 <edwardk> @type and
19:04:46 <LordBrain> you have to map it
19:04:46 <lambdabot> [Bool] -> Bool
19:04:50 <edwardk> yep
19:05:08 <mauke> > (\fs xs -> filter (\x -> all (flip id x) fs) xs) [(=='o').(!!2),(==5).length] ["how","Now","Brown","Cow"]
19:05:09 <lambdabot>  ["Brown"]
19:05:19 <LordBrain> cleaner if you have the lists set seprately
19:05:25 <edwardk> now the list comprehension above lacks the ability to get the string's # in sequence that the original hackish version did
19:06:02 <LordBrain> [ s | s <- strings, and $ map ($s) conditions]
19:06:14 <edwardk> yep
19:06:20 <edwardk> pretty clean
19:06:46 <mauke> [ s | s <- strings, all (flip id s) conditions]
19:06:50 <LordBrain> you can make anohter function called holds
19:06:59 <LordBrain> oh all, hmm
19:07:02 <LordBrain> @type all
19:07:03 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
19:07:42 <edwardk> also pretty clean
19:07:43 <edwardk> =)
19:07:55 <mauke> <3 flip id
19:08:00 <edwardk> heh
19:08:12 <DukeDave> is there no prelude function :: ([a -> b]) -> a -> [b]  ?
19:08:26 <mauke> @hoogle ([a -> b]) -> a -> [b]
19:08:27 <lambdabot> No matches, try a more general search
19:08:38 <DukeDave> (I couldn't find one)
19:08:56 <mauke> @type \fs x -> map (flip id x) fs
19:09:02 <lambdabot> forall c b. [b -> c] -> b -> [c]
19:09:16 <mauke> @pl \fs x -> map (flip id x) fs
19:09:16 <lambdabot> flip (map . flip id)
19:09:25 <DukeDave> basically.... map (\f -> f c)
19:09:37 <mauke> yeah, that's what map (flip id x) is
19:09:55 <dons> ?pl flip id
19:09:56 <lambdabot> flip id
19:10:09 <DukeDave> all this flip id talk is hurting me :)
19:10:22 <edwardk> again with the writing of code in haskell and watching it asymptotically shrink towards nothing
19:10:39 <dons> ?type (flip id)
19:10:39 <LordBrain> [s | s <-strings, s `meets` conditions ] where meets s = and . map ($s)
19:10:40 <lambdabot> forall b c. b -> (b -> c) -> c
19:10:44 <dons> ?type (flip $)
19:10:45 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
19:11:27 <edwardk> cute lb =)
19:11:28 <mauke> (flip $) = id flip = flip
19:12:04 <dons> ?p flip $
19:12:05 <lambdabot> Maybe you meant: palomer part paste pl pl-resume pointless poll-add poll-close poll-list poll-remove poll-result poll-show pretty print-logs print-notices purge-notices . v
19:12:08 <dons> ?p flip $
19:12:08 <lambdabot> Maybe you meant: palomer part paste pl pl-resume pointless poll-add poll-close poll-list poll-remove poll-result poll-show pretty print-logs print-notices purge-notices . v
19:12:11 <dons> ?pl flip $
19:12:12 <lambdabot> (line 1, column 7):
19:12:12 <lambdabot> unexpected end of input
19:12:12 <lambdabot> expecting white space or simple term
19:12:17 <dons> ?pl flip ($)
19:12:17 <lambdabot> flip id
19:12:28 <dons> we need to start teaching @pl some new tricks
19:12:33 <edwardk> heh
19:12:55 <DukeDave> what is @pl doing?
19:13:08 <mauke> it removes function arguments
19:13:34 <DukeDave> @pl id x
19:13:35 <lambdabot> x
19:13:58 <mauke> @pl f x = x + x
19:13:58 <lambdabot> f = join (+)
19:14:11 <mauke> see? no more x
19:14:12 <edwardk> yea
19:14:22 <edwardk> but it should warn when it uses stuff from Control.Monad.Reader =/
19:14:35 <DukeDave> lol, I've never even heard of join   *_*
19:14:49 <LordBrain> hey thats nice, maybe i should put it on the wiki
19:14:54 <mauke> > join ["foo", "bar", "baz"]
19:14:55 <lambdabot>  "foobarbaz"
19:15:08 <edwardk> @type join
19:15:09 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
19:15:14 <edwardk> note that join is just the monad join
19:15:22 <dons> edwardk: its your pass to level 4 haskell hackerdom, once you dig the (- a) monad
19:15:26 <dons> -> a
19:15:30 <edwardk> being applied to the ((->) e) monad
19:15:49 <edwardk> yeah
19:15:52 <emertens> I still don't understand how ((->) e) is different than Reader e
19:15:59 <emertens> or even related at all
19:16:26 <dons> ?source Control.Monad.Reader
19:16:27 <lambdabot> lambdabot 4p49, GHC 6.5 (OpenBSD i386 )
19:16:27 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:16:32 <dons> ?fptools Control.Monad.Reader
19:16:32 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Reader.hs
19:16:42 <mauke> isn't Reader just an interface?
19:16:53 <dons> via:
19:16:54 <dons> instance MonadReader r ((->) r) where
19:16:54 <dons>         ask       = id
19:16:54 <dons>         local f m = m . f
19:16:59 <edwardk> Reader wraps it with that runReader crap no?
19:17:17 <dons> yeah
19:17:20 <edwardk> so its like runId, runState, etc.
19:17:48 <edwardk> lets it be all safe and type-classy and reusable code-wise.
19:18:29 <emertens> can you show a simple example of it used on lambdabot?
19:19:32 <LordBrain> hmm what if we liftM all so that it acts inside the list
19:19:42 <LordBrain> liftM all conditions s
19:19:49 <LordBrain> does that work?
19:19:51 <Cale> what's up?
19:20:23 <dons> Cale smells some monadery hackery going down
19:20:27 <edwardk> heh
19:20:52 <Cale> btw, fmap is better than liftM :)
19:21:19 <Cale> You don't have to import Control.Monad for it, and it's more general :)
19:21:31 <mauke> I think you want filter, not map
19:21:36 <mauke> and then you get my version
19:21:47 <Cale> what are you writing?
19:22:30 <edwardk> [ s | s <- strings, and $ map ($s) conditions]
19:22:34 <edwardk> more or less
19:23:03 <LordBrain> > fmap all conditions strings where conditions = [(>=3).length, ('a' `elem`)]; strings = ["a","BBBBBBBB","BableFish","BingoBaby"]
19:23:04 <lambdabot>  Parse error
19:23:04 <edwardk> given a list of strings and a list of boolean functions that must all pass for each to be in the result list, return the result list.
19:23:24 <LordBrain> > fmap all conditions strings where { conditions = [(>=3).length, ('a' `elem`)]; strings = ["a","BBBBBBBB","BableFish","BingoBaby"] }
19:23:25 <lambdabot>  Parse error
19:23:29 <emertens> [(>10)] `ap` [9]
19:23:35 <emertens> > [(>10)] `ap` [9]
19:23:36 <lambdabot>  [False]
19:23:36 <mauke> you can't "where" expressions
19:23:43 <LordBrain> whats the parse error?
19:24:01 <emertens> > and $ [(>10), (<15)] `ap` [11]
19:24:02 <lambdabot>  True
19:24:31 <emertens> > and $ [(>10), (<15)] `ap` [10,11]
19:24:33 <lambdabot>  False
19:24:36 <LordBrain> let { conditions = [(>=3).length, ('a' `elem`)];strings = ["a","BBBBBBBB","BableFish","BingoBaby"] } in fmap all conditions strings
19:24:46 <LordBrain> > let { conditions = [(>=3).length, ('a' `elem`)];strings = ["a","BBBBBBBB","BableFish","BingoBaby"] } in fmap all conditions strings
19:24:47 <lambdabot>  Couldn't match `(->) t' against `[]'
19:26:33 <Cale> > let swing f c a = (f ($ a)) c; conditions = [(>=3) . length, ('a' `elem`)]; strings = ["a","BBBBBBBB","BableFish","BingoBaby"] in filter (swing all conditions) strings
19:26:34 <lambdabot>  ["BableFish","BingoBaby"]
19:26:57 <LordBrain> whew, i'll stick with the comprehension :)
19:27:01 <Cale> hehe
19:27:46 <dons> we should try to popularise swing
19:28:08 <dons> ?type let swing f c a = (f ($ a)) c in swing
19:28:10 <lambdabot> forall a b t t1. (((a -> b) -> b) -> t -> t1) -> t -> a -> t1
19:28:11 <LordBrain> let { conditions = [(>=3).length, ('a' `elem`)];strings = ["a","BBBBBBBB","BableFish","BingoBaby"] } in        [s | s <- strings, s `meets` conditions] where meets = and . map ($s)
19:28:24 <LordBrain> > let { conditions = [(>=3).length, ('a' `elem`)];strings = ["a","BBBBBBBB","BableFish","BingoBaby"] } in        [s | s <- strings, s `meets` conditions] where meets = and . map ($s)
19:28:24 <lambdabot>  Parse error
19:28:28 <LordBrain> gaah
19:28:46 <Cale> why use braces there?
19:28:49 <edwardk> dons: weirdo
19:30:11 <Cale> > let conditions = [(>=3).length, ('a' `elem`)]; strings = ["a","BBBBBBBB","BableFish","BingoBaby"]; meets s = and . map ($ s) in [s | s <- strings, s `meets` conditions]
19:30:12 <lambdabot>  ["BableFish","BingoBaby"]
19:30:17 <emertens> What is the goal?
19:31:08 <edwardk> the goal was to clean up http://paste.lisp.org/display/23853
19:31:36 <DukeDave> (sorry)
19:31:37 <DukeDave> :)
19:31:58 <edwardk> like all haskell code it has been systematially reduced to one line.
19:32:03 <DukeDave> :)
19:32:11 <edwardk> s/ially/ically/g
19:32:37 <edwardk> and then beaten to death
19:32:40 <emertens> yeah... this is better, now you don't have to worry about people "reading" your code ;)
19:33:07 <dons> reduced to one line, rewritten to use (-> a) monad, pointfreed, and then beaten to death
19:33:08 <DukeDave> I think I might write up the puzzle and my strategy and current attempt at a solver - then go for a tea while you guys take it to pieces :)
19:33:21 * kpreid plays around:
19:33:30 <kpreid> > let q x = (x, reverse x); ~(al,ar) +|+ ~(bl,br) = (al++bl,br++ar) in let thing = q "[" +|+ thing +|+ q "]" in (take 10 $ fst thing) ++ "..." ++ (reverse $ take 10 $ snd thing)
19:33:31 <lambdabot>  "[[[[[[[[[[...]]]]]]]]]]"
19:33:35 <dons> heh
19:33:50 <dons> lazy patterns in lambdabot! a rare site
19:33:53 <kpreid> infinite sequence from both ends, sort of
19:33:54 <dons> sight? grr
19:34:01 <lisppaste2> LordBrain pasted "the comprehension" at http://paste.lisp.org/display/23855
19:34:04 <DukeDave> I seem to be at a cruel stage in my haskell learning where I can think functionally - but can't express it :(
19:34:16 <Cale> > let meet f g x = f x && g x; conditions = [(>=3).length, ('a' `elem`)]; strings = ["a","BBBBBBBB","BableFish","BingoBaby"] in filter (foldr meet (const True) conditions) strings
19:34:17 <lambdabot>  ["BableFish","BingoBaby"]
19:34:44 <DukeDave> nice LordBrain :)
19:35:51 <kpreid> @pl q x = (x, reverse x)
19:35:51 <lambdabot> q = ap (,) reverse
19:37:03 <emertens> [ s | s <- ["a","BBBBBBBB","BableFish","BingoBaby"], all ($ s) [(>=3).length, elem 'a']]
19:37:08 <emertens> > [ s | s <- ["a","BBBBBBBB","BableFish","BingoBaby"], all ($ s) [(>=3).length, elem 'a']]
19:37:09 <lambdabot>  ["BableFish","BingoBaby"]
19:37:15 <Cale> > second reverse . join (,) $ "Hello"
19:37:16 <lambdabot>  ("Hello","olleH")
19:38:02 <emertens> @pl \s -> all ($ s) [(<10)]
19:38:02 <lambdabot> flip all [(< 10)] . flip id
19:38:38 <emertens> > filter (flip all [(>=3).length, elem 'a'] . flip id) ["a","BBBBBBBB","BableFish","BingoBaby"]
19:38:39 <lambdabot>  ["BableFish","BingoBaby"]
19:38:44 <Cale> The (->) e monad ought to be in the Prelude :)
19:38:46 <emertens> is that what you guys were doing?
19:38:58 <Cale> yes
19:39:09 <emertens> but you wanted to do it using (->) ?
19:39:12 <Cale> You're rediscovering swing
19:39:25 <Cale> swing f c a = (f ($ a)) c
19:39:31 <emertens> ahh...
19:39:31 <Cale> swing all
19:39:32 <Cale> :)
19:39:43 <emertens> why do you call it swing?
19:39:52 <Cale> It's sort of an arbitrary name
19:39:53 <emertens> @pl f c a -> (f ($ a)) c
19:39:53 <lambdabot> (line 1, column 7):
19:39:54 <lambdabot> unexpected ">" or "-"
19:39:54 <lambdabot> expecting variable, "(", operator or end of input
19:39:58 <emertens> @pl \f c a -> (f ($ a)) c
19:39:58 <lambdabot> flip . (. flip id)
19:40:00 <Cale> it swings the parameters around :)
19:40:06 <emertens> @type flip id
19:40:08 <lambdabot> forall b c. b -> (b -> c) -> c
19:40:28 <Cale> @type let swing f c a = (f ($ a)) c in swing all
19:40:29 <lambdabot> forall a. [a -> Bool] -> a -> Bool
19:40:32 <Cale> @type let swing f c a = (f ($ a)) c in swing map
19:40:33 <lambdabot> forall a b. [a -> b] -> a -> [b]
19:40:37 <Cale> @type let swing f c a = (f ($ a)) c in swing zipWith
19:40:38 <lambdabot> forall a b c. [a -> b -> c] -> a -> [b] -> [c]
19:40:41 <Cale> @type let swing f c a = (f ($ a)) c in swing find
19:40:42 <lambdabot> forall a. [a -> Bool] -> a -> Maybe (a -> Bool)
19:40:47 <Cale> @type let swing f c a = (f ($ a)) c in swing foldr
19:40:48 <lambdabot> forall a b. b -> a -> [a -> b -> b] -> b
19:40:53 <Cale> @type let swing f c a = (f ($ a)) c in swing partition
19:40:54 <lambdabot> forall a. [a -> Bool] -> a -> ([a -> Bool], [a -> Bool])
19:41:09 <emertens> @type filter ((flip . (. flip id)) all)
19:41:10 <lambdabot>   Expecting a function type, but found `Bool'
19:41:10 <lambdabot>    Expected type: a -> Bool
19:41:25 <emertens> @type filter ((flip . (. flip id)) all [(<10])
19:41:26 <lambdabot> parse error on input `]'
19:41:30 <emertens> @type filter ((flip . (. flip id)) all [(<10)])
19:41:32 <lambdabot> forall a. (Ord a, Num a) => [a] -> [a]
19:41:42 <emertens> fun fun
19:41:44 <LordBrain> hehehehe
19:42:12 <emertens> @type flip ($)
19:42:14 <lambdabot> forall b b1. b1 -> (b1 -> b) -> b
19:42:18 <emertens> @type flip id
19:42:20 <lambdabot> forall b c. b -> (b -> c) -> c
19:42:45 <emertens> > 10 $
19:42:45 <lambdabot>  Parse error
19:43:23 <kpreid> and now, the other end of the infamous v!
19:43:36 <kpreid> > let q x = (x, reverse x); ~(al,ar) +|+ ~(bl,br) = (al++bl,br++ar) in let qshow x = q "\"" +|+ qConcatMap (\c -> case c of '"' -> "\\\""; _ -> [c]) x +|+ q "\""; qConcatMap f (l,r) = (concatMap f l,concatMap (reverse . f) r); unq x = (take 10 $ fst x) ++ "..." ++ (reverse $ take 10 $ snd x) in unq (fix qshow)
19:43:37 <lambdabot>  "\"\\\"\\\\\"\\\\\\\"...\\\\\\\"\\\\\"\\\"\""
19:45:51 <dons> huh. haskell _almost_ got mentioned on TheRegister, http://www.regdeveloper.co.uk/2006/08/08/cplusplus_loops/
19:46:01 <dons> 1 indirection away
19:47:04 <dons> after introducing lambdas (in C++) as some kind of soln, there's a link to the Joel rant about lambdas, which we talked about earlier this week
19:47:06 <DukeDave> lol
19:47:22 <kpreid> hm, I didn't get it quite right
19:47:44 <kpreid> > let q x = (x, reverse x); ~(al,ar) +|+ ~(bl,br) = (al++bl,br++ar) in let qshow x = q "\"" +|+ qConcatMap (\c -> (if elem c "\\\"" then "\\" else "") ++ [c]) x +|+ q "\""; qConcatMap f (l,r) = (concatMap f l,concatMap (reverse . f) r); unq x = (take 10 $ fst x) ++ "..." ++ (reverse $ take 10 $ snd x) in unq (fix qshow)
19:47:46 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\...\\\\\"\\\\\\\"\\\"\""
19:47:51 <dons> ?v
19:47:52 <lambdabot> Exception: <<loop>>
19:47:55 <dons> ?v
19:47:55 <kpreid> (let me know if I should stop)
19:47:56 <lambdabot> Just 'J'
19:48:02 <dons> ?v
19:48:03 <lambdabot> "\""
19:48:06 <dons> almsot
19:56:03 * Cale plays q3a... 10-0 and 10-(-1) wins vs. Uriel on q3tourney5 hardcore, and a 10-0 perfect vs. Anarki on q3tourney4 hardcore.
19:56:11 <Cale> I should get a new game :P
19:56:29 <lisppaste2> dukedave pasted "A challenge.." at http://paste.lisp.org/display/23856
19:57:05 <Cale> Use the Nondet/List monad
19:57:22 * DukeDave has a really nice solution floating in his head but can't express it in haskell..
19:57:26 <Cale> Look at my Sudoku solver for ideas about how to do this :)
19:57:48 <DukeDave> on the Wiki?
19:57:51 <Cale> yeah
19:57:52 <gzl> how does yours work? Dancing Links?
19:57:59 <DukeDave> that's already helped me :D
19:58:29 <Cale> gzl: no, it's just brute force, but the important bit is how I've used monads to do it
19:58:29 <emertens> is there an efficient algorithm for generally solving a cross-word puzzle?
19:58:47 <emertens> I was under the impression that you had to brute force them
19:58:56 <gzl> Cale: ok.
19:59:28 <DukeDave> I was going for a depth first search - but I thought you could take advantage of laziness by maintaining only a list of preconditions for each word
19:59:46 <Cale> http://www.haskell.org/haskellwiki/Sudoku
19:59:48 <lambdabot> Title: Sudoku - HaskellWiki
20:00:08 <DukeDave> then try ' head $ filter conditions adictionary'
20:00:13 <Cale> The monad is a State transformed list/nondet monad
20:00:33 <DukeDave> based on that update the conditions of the remaining unfilled words
20:00:34 <Cale> with additional restrictions -- it enforces the Sudoku rules
20:00:52 <LordBrain> DukeDave: are you named in hommage to David Duke? http://en.wikipedia.org/wiki/David_Duke
20:01:20 <Cale> wow
20:01:41 <emertens> I'm almost sure that the general case of sudoku is NP-Complete
20:01:48 <DukeDave> haha, erm, LordBrain : no one has ever pointed that out :|
20:01:53 <DukeDave> yes emertens it is :)
20:02:34 <DukeDave> it's my handle because:   a. my name is dave   b. I used to play duke nukem
20:02:37 <DukeDave> ;)
20:03:18 <LordBrain> well i'm relieved... at least you're not the kkk kingpin himself
20:03:24 <LordBrain> lol
20:03:38 <emertens> why were you worried?
20:04:04 <LordBrain> a little, that he might say yes, and then go on about how great the kkk is and so on
20:04:53 <LordBrain> anyway, sorry i brought it up
20:06:15 <DukeDave> s'okay - something to watch out for in the future
20:06:38 <emertens> I'd watch out for LordBrain ... he seems to know a lot of KKK trivia
20:06:46 <emertens> like... who the hell David Duke is ;)
20:06:54 <DukeDave> Cale, thankyou - I have now progressed to headache factor 5 :|
20:07:01 <Cale> hehe
20:07:29 <DukeDave> it is exactly what I had in mind though
20:07:38 <LordBrain> i watch opera :P
20:07:40 <LordBrain> sometimes
20:07:50 <DukeDave> but I must confess I though writing a solver would be a 20min job
20:07:57 <DukeDave> and now it's day 3 :|
20:08:02 <Cale> You can construct a monad which enforces the constraints in your system while trying things.
20:08:26 <emertens> how do you build constraits into the monad
20:08:28 <emertens> example?
20:08:40 <LordBrain> i've not yet managed to construct my own monad usefully
20:08:42 <emertens> or are you talking about List + guards etc
20:08:51 <DukeDave> emertens,   http://www.haskell.org/haskellwiki/Sudoku#Serious.2C_Non-Deterministic_Solver
20:08:52 <lambdabot> Title: Sudoku - HaskellWiki
20:08:53 <Cale> look at 'place'
20:08:58 <Cale> in my solver
20:09:10 <Cale> It's a modified version of 'put'
20:09:27 <Cale> which enforces the Sudoku constraints
20:09:36 <emertens> ah
20:09:58 <Cale> Since the 'Sudoku' data constructor isn't exported, 'put' can't be used from outside that module
20:10:04 <DukeDave> wow, is this a bit much for someone who only just started understanding the IO monad last week :)
20:10:46 <Cale> and so there's a guarantee that the current state is always a valid Sudoku position. (In the sense that no two elements of any row, column, or box are ever labelled the same)
20:11:13 <Cale> yeah, it would be a bit of a stretch :)
20:13:09 <DukeDave> interestingly I would have thought the 'depth first search' pattern would have been a very haskell friendly problem*_*
20:13:25 <Cale> Oh, it is
20:13:27 <emertens> the important thing is that your computer has a lot of cycles
20:13:31 <DukeDave> go on...
20:13:32 <emertens> or that the problem is small
20:13:40 <Cale> You can do this recursively too :)
20:13:51 <DukeDave> that's what I've been trying
20:13:54 <Cale> The monad just gives you a rather cute result in the end.
20:14:14 <edwardk> i mostly find sudoku problems interesting in the abstract... that you can get people to obsess about them
20:14:40 * edwardk put together a number of linguistic ones for a fund drive this year and was amazed at the volume of responses.
20:14:42 <gzl> I never cared much for the puzzle. but it was a fun little homework assignment to write a solver.
20:14:43 <augustss> howdy!
20:14:55 <DukeDave> gah
20:14:56 <gzl> I had to do it for a class once.
20:15:10 <DukeDave> I just can't get my head round how to express it in haskell
20:15:12 <LordBrain> what's a inguistic sudoku problem?
20:15:17 <LordBrain> linguistic
20:15:29 <edwardk> did a 9x9 one using the word 'phonetics', and a 28x28 4x7 grid of 7x4 grids for part of the international phonetic alphabet.
20:15:44 <edwardk> well, sudoku has no tie to numbers it just needs unique symbols.
20:15:51 <LordBrain> oh yes
20:15:54 <edwardk> the letters of the word 'phonetics' are all unique and there are 9 of them.
20:15:59 * merus is much more interested in the hexagon puzzle of Cale's, but cannot find it anymore...
20:16:16 <Cale> http://cale.yi.org/wiki.pl?MyPuzzles
20:16:18 <lambdabot> Title: Wiki: MyPuzzles
20:16:29 <merus> Oh, heh.
20:16:32 <Cale> I should really make some more of them
20:16:35 <edwardk> the grid doesn't have to be square, just rectangular, you can mirror the rectangular axis on the parent grid level and get something with the right number of constraints per line. (that is of course ignoring the existence of super-sudoku, etc
20:16:49 <LordBrain> before they were called soduku i encountered them in combinatorics as "Latin Squares"
20:16:59 <merus> Cale: I've been thinking about a solver for those, but finding a suitable representation of the map is poking my lobes.
20:17:01 <Cale> sudoku
20:17:03 <dons> Cale, you should write a book, algorithmic puzzles, or something. where you describe new puzzles, and how to solve them with programs/haskell
20:17:23 <gzl> that's a good idea
20:17:28 <dons> for non programmers. i was thinking.
20:17:39 <edwardk> hrmm
20:17:45 <dons> or haskell as a language for non programmers to solve puzzles
20:17:47 <gzl> that reminds me of Paradigms of AI Programming by Norvig
20:17:47 <edwardk> trying to start em young?
20:17:55 <dons> people like puzzles
20:18:15 <dons> my gf likes puzzles, and is even willing to pick up a little haskell to solve some things
20:18:21 <emertens> when I need stuff to code, I go to topcoder.com/tc
20:18:22 <gzl> I dunno. I think algorithmic puzzle solving in Haskell would be too much for most nonprogrammers.
20:18:23 <dons> so i suspect there is a $market for this ;)
20:18:31 <gzl> I suspect it's tiny.
20:18:42 <dons> not if it was just new kinds of puzzles
20:18:48 <Cale> The puzzle on that page there would be annoying to encode :)
20:18:49 <dons> and a bit of haskell to go about solving them.
20:19:15 <dons> its the kind of book i would have bought at age 13-14
20:19:21 <merus> Cale: Well, one could do it with a graph... it's just irritating to think about, s'all :)
20:19:25 <dons> maybe the Puzzle Road to Maths and FP
20:19:35 <merus> Also, my Haskell skillz are insufficient.
20:19:44 <DukeDave> lol, get them while they're young :)
20:20:05 <LordBrain> :)
20:21:29 <Cale> merus: note that it's not quite enough just to encode region adjacency
20:21:51 <Cale> though with the puzzles I've produced so far, that's been the case
20:22:02 <Cale> http://cale.yi.org/autoshare/maps.png -- consider these two maps, for instance
20:22:12 <edwardk> hrmm. does yi do unicode?
20:22:24 <merus> Cale: Oh, dear.
20:22:43 <gzl> Cale: how'd you do those graphics?
20:22:52 <Cale> gzl: inkscape
20:23:05 <dons> edwardk: nope
20:23:13 <gzl> ok.
20:23:37 <edwardk> dons: shucks
20:23:46 <dons> inkscape, eh/
20:23:48 <dons> looks nice.
20:23:51 <edwardk> its come a long way
20:23:57 <Cale> inkscape rules :)
20:24:14 <Cale> It's better now than illustrator was when I started using it.
20:24:36 <emertens> what are those maps for?
20:24:57 <Cale> which maps? The ones I linked to just now?
20:25:27 <Cale> They're an example of an inequivalent pair of maps which have the same region adjacency graph.
20:28:49 <Cale> It shows that a correct solver for the puzzle would have to consider not just which regions are next to one another, but the order of the adjacencies as one travels around the boundary of a given region.
20:30:08 <DukeDave> ah, looks neat
20:30:12 <Cale> http://cale.yi.org/autoshare/Torraent.png -- something else I did in inkscape. (It's a map of a city on a mud that I've been playing)
20:30:17 * DukeDave apt-gets inkscape :)
20:31:13 <Cale> inkscape is also a decent tool to use while solving puzzles found on the internet.
20:31:44 <DukeDave> okay Cale I give up; I can neither come up with, or find, a way to 'simply' express a depth first search in haskell :|
20:32:04 <Cale> In particular, I use it for the puzzles by Zotmeister: http://zotmeister.livejournal.com/tag/puzzles and GLMathGrant http://glmathgrant.livejournal.com/tag/puzzles
20:33:24 <Cale> DukeDave: aside from direct recursion?
20:33:55 <DukeDave> yes, as in, with a bounding function
20:35:48 <edwardk> dfs f x = x :(dfs f =<< f x)
20:35:48 <Cale> well, actually, if you're going to do it non-monadically, one approach is to build a tree of all possible moves, and then prune that (say, when moves are considered invalid)
20:35:52 <edwardk> abuse the list monad
20:35:56 <edwardk> er
20:36:42 <Cale> If you're not afraid to use a monad, the list monad is a really good one.
20:37:06 <lisppaste2> dukedave pasted "A java implementation" at http://paste.lisp.org/display/23857
20:37:22 <Cale> All you really need to write in order to use the list monad is the following: a function which given a particular game state, gives a list of potential next states.
20:37:36 <DukeDave> that sounds perfect
20:37:38 <DukeDave> :)
20:37:54 * edwardk wonders what a short alpha-beta, negascout or MTDf implementation would look like in haskell.
20:38:07 <edwardk> yeah the above implementation assumes that f is of the form a -> [a]
20:38:38 <Cale> Then what you do is recursively apply that function to the initial state, applying span to get out any finished solutions, and recursing on the rest of the list.
20:39:02 <DukeDave> @type span
20:39:03 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
20:39:05 <Cale> Or if every solution will be the same length, you can just keep applying it until the first solution is cooked.
20:39:32 <Cale> You'd give span the predicate which determines if a game state is "finished"
20:39:50 <DukeDave> > span (>3) [1..5]
20:39:51 <lambdabot>  ([],[1,2,3,4,5])
20:40:01 <Cale> > span (<3) [1..5]
20:40:02 <lambdabot>  ([1,2],[3,4,5])
20:40:12 <Cale> > span (<3) [1,2,3,4,5,2,3,1,2,1]
20:40:13 <lambdabot>  ([1,2],[3,4,5,2,3,1,2,1])
20:40:30 <Cale> Now, you might think "Why not partition?"
20:40:34 <Cale> > partition (<3) [1,2,3,4,5,2,3,1,2,1]
20:40:35 <lambdabot>  ([1,2,2,1,2,1],[3,4,5,3])
20:40:55 <Cale> The problem with partition is that it will force more of the list to be evaluated than you probably want.
20:41:48 <edwardk> dfs f x = x : (dfs f =<< filter condition $ f x)
20:41:49 <edwardk> ?
20:41:50 <DukeDave> so span ensures the fst of the result is a set?
20:41:59 <Cale> a list
20:42:14 <DukeDave> (which contains no duplicates? )
20:43:05 <DukeDave> ah, takewhile dropwhile :)
20:43:26 <Cale> dfs f p xs = let (finished, keepgoing) = partition p (xs >>= f) in finished ++ dfs f p keepgoing
20:43:55 <Cale> Where f is a function  State -> [State]  which takes a step in all possible ways
20:44:03 <LordBrain> i thought you werent going to use partition
20:44:15 <Cale> and p is a function State -> Bool which determines if the State is final
20:44:20 <Cale> er
20:44:25 <Cale> dfs f p xs = let (finished, keepgoing) = span p (xs >>= f) in finished ++ dfs f p keepgoing
20:44:27 <Cale> yes
20:44:35 <Cale> sorry :)
20:44:40 <edwardk> heh
20:44:51 <Cale> Ignoring myself again :)
20:44:56 <LordBrain> hehehe
20:45:09 <DukeDave> wow I'm in pain :)
20:45:11 <Cale> Do you see how that works?
20:45:15 <merus> That (<3) is a function amuses me to no end.
20:45:17 <Cale> >>= is just concatMap
20:45:28 <Cale> xs >>= f = concatMap f xs
20:45:28 * merus is easily amused.
20:45:44 <DukeDave> it makes about as much sense as my ex-girlfriends dumping speech :|
20:45:50 <edwardk> heh
20:45:51 <LordBrain> lol
20:46:00 <Cale> So it's going to take a step in all possible ways from all possible current states, and concatenate those together.
20:46:15 <DukeDave> right
20:46:35 <Cale> The function f will return an empty list if it gets stuck
20:46:37 <DukeDave> such that you have a list of vaild next states
20:46:53 <Cale> and should return a singleton list if the thing is finished and successful
20:47:04 <Cale> yeah
20:47:21 <Cale> and what this does is it prunes off all the finished ones from the start of the list that it can
20:47:24 <DukeDave> I assume this presumes knowledge of the state monad :)
20:47:25 <Cale> and recurses on the rest
20:47:30 <Cale> There's no state monad here
20:47:35 <emertens> this is just the list monad
20:47:38 <Cale> This is purely in the list monad
20:47:58 <DukeDave> why is it things always stop making sense when someone says monad :)
20:48:18 <Cale> the States that I was referring to are your own datatype for holding information about the game
20:48:27 <DukeDave> gotcha
20:48:35 <DukeDave> I'd better go away and digest :)
20:48:46 <LordBrain> just rewrite it with concatmap and there's no monad to worry about
20:48:49 <Cale> Have you read Monads as Containers over and over?
20:48:58 <edwardk> they need to start people off in monadscript or monadbasic or something =)
20:49:04 <DukeDave> lmao
20:49:07 <DukeDave> yeah
20:49:10 <Cale> right, we could use concatMap, and forget that it's actually a monad
20:49:23 <Cale> even though we're doing something that's still rather monadic in nature :)
20:49:24 <DukeDave> I 'get' the monad concept afaik
20:49:38 <merus> Cale: Monads as Containers?
20:49:47 <DukeDave> the chopstick factory ?
20:50:13 <Cale> http://haskell.org/haskellwiki/Monads_as_Containers
20:50:15 <lambdabot> Title: Monads as Containers - HaskellWiki
20:50:19 <Cale> that one :)
20:50:25 <merus> ah.
20:50:42 <DukeDave> ah
20:51:10 <Cale> The list monad is really one of the best examples of a monad.
20:51:19 <Cale> IO is one of the worst
20:51:59 <Cale> IO is still a monad, but it's a rather complicated one, and is hard to actually describe formally.
20:52:29 <Cale> Lists are fairly simple, and the definitions of all the monad functions are rather easy.
20:53:01 <LordBrain> maybe seems easier to me
20:53:10 <emertens> let filter' p xs = xs >>= (\x -> guard p x >> return x) in filter (<3) [1,2,3]
20:53:12 <emertens> > let filter' p xs = xs >>= (\x -> guard p x >> return x) in filter (<3) [1,2,3]
20:53:13 <lambdabot>  Couldn't match `m a' against `()'
20:53:28 <emertens> > let filter' p xs = (xs >>= (\x -> guard p x >> return x)) in filter (<3) [1,2,3]
20:53:29 <lambdabot>  Couldn't match `m a' against `()'
20:53:33 <emertens> > let filter' p xs = (xs >>= (\x -> guard p x >> return x)) in filter' (<3) [1,2,3]
20:53:34 <lambdabot>  Couldn't match `m a' against `()'
20:53:37 <emertens> :(
20:53:47 <LordBrain> or at least, i dont find i have to relearn it... i always get Maybe, i have to reminded still that >>= is concatmap with lists...
20:53:56 <emertens> > [1,2,3] >>= \x -> guard (x < 3) >> return x
20:53:58 <lambdabot>  [1,2]
20:54:09 <LordBrain> i remember.. but it takes me a couple of seconds longer...
20:54:49 <emertens> @pl \p xs -> xs >>= \x -> guard (p x) >> return x
20:54:50 <lambdabot> (=<<) . (`ap` return) . (((>>) . guard) .)
20:55:10 <Cale> > let filter' p xs = do x <- xs; guard p x; return x in filter' (<3) [1..10]
20:55:11 <lambdabot>  Couldn't match `m a' against `()'
20:55:16 <Cale> > let filter' p xs = do x <- xs; guard (p x); return x in filter' (<3) [1..10]
20:55:18 <lambdabot>  [1,2]
20:55:26 <Cale> heh, made the same mistake :)
20:56:00 <Cale> > let filter' p xs = xs >>= \x -> guard (p x) >> return x in filter' (<3) [1..10]
20:56:01 <lambdabot>  [1,2]
20:56:05 <LordBrain> @type guard
20:56:06 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
20:56:21 <Cale> > let filter' p xs = xs >>= \x -> if p x then [x] else [] in filter' (<3) [1..10]
20:56:22 <lambdabot>  [1,2]
20:56:48 <emertens> yeah, but that's not nearly as fun
20:56:55 <Cale> > let filter' p xs = xs >>= \x -> if p x then return x else mzero in filter' (<3) [1..10]
20:56:56 <lambdabot>  [1,2]
20:57:00 <LordBrain> > guard (True) :: [Int]
20:57:00 <lambdabot>  Couldn't match `Int' against `()'
20:57:08 <LordBrain> hmm
20:57:13 <LordBrain> > guard (True)
20:57:14 <lambdabot>  add an instance declaration for (Show (m ()))
20:57:17 <Cale> > guard (True) :: [()]
20:57:18 <lambdabot>  [()]
20:57:20 <emertens> > guard false >> return 1
20:57:21 <lambdabot>  Not in scope: `false'
20:57:25 <emertens> > guard False >> return 1
20:57:26 <lambdabot>  add an instance declaration for (Show (m a))
20:57:43 <emertens> > guard False >> return 1 :: [Int]
20:57:44 <lambdabot>  []
20:57:49 <emertens> > guard True >> return 1 :: [Int]
20:57:51 <lambdabot>  [1]
20:58:06 <Cale> > guard False [()]
20:58:06 <lambdabot>  add an instance declaration for (MonadPlus ((->) [()]))
20:58:07 <lambdabot>   In the definiti...
20:58:09 <Cale> > guard False :: [()]
20:58:10 <Cale> > guard True :: [()]
20:58:11 <lambdabot>  []
20:58:11 <lambdabot>  [()]
20:59:09 <LordBrain> hmmmmmmmmmmmmmmmmmmmmmmmmmm
20:59:11 <emertens> and that works because [()] >>= \_ -> [1]
20:59:20 <emertens> > [()] >>= \_ -> [1]
20:59:21 <lambdabot>  [1]
20:59:24 <emertens> > [] >>= \_ -> [1]
20:59:25 <lambdabot>  []
20:59:30 <LordBrain> oooooh
20:59:44 <emertens> >>   is  >>= \_ ->
20:59:46 <LordBrain> the function is operating on nothing and returns nothing
21:00:07 <emertens> [] >> [1]
21:00:11 <emertens> > [] >> [1]
21:00:12 <lambdabot>  []
21:00:15 <emertens> > [2] >> [1]
21:00:17 <lambdabot>  [1]
21:00:20 <emertens> :-D
21:00:25 <emertens> it's the simple things
21:00:29 <edwardk> heh
21:00:33 <emertens> > [1,2,3] >> [1]
21:00:34 <lambdabot>  [1,1,1]
21:00:42 <LordBrain> its FAlse -> MonadZero ?
21:01:17 <emertens> > let replicate' n x = [1..n] >> [x] in replicate' 4 3
21:01:18 <lambdabot>  [3,3,3,3]
21:01:21 <emertens> :-D
21:02:00 <emertens> > let replicate' n = enumFromTo 1 n >> return in replicate' 4 3
21:02:01 <lambdabot>    Expecting a function type, but found `m b'
21:02:01 <lambdabot>    Expected type: [b]
21:02:01 <lambdabot>   ...
21:02:12 <emertens> > let replicate' n = (enumFromTo 1 n >> return) in replicate' 4 3
21:02:13 <lambdabot>    Expecting a function type, but found `m b'
21:02:13 <lambdabot>    Expected type: [b]
21:02:13 <lambdabot>   ...
21:02:16 <emertens> jm
21:02:18 <emertens> hm
21:02:38 <emertens> @pl \n x -> enumFromTo 1 n >> [x]
21:02:38 <lambdabot> (. return) . (>>) . enumFromTo 1
21:04:21 <Cale> > [1,1,1] >> [1,2]
21:04:22 <lambdabot>  [1,2,1,2,1,2]
21:04:31 <Cale> > [1,1,1] >> "Hello"
21:04:32 <lambdabot>  "HelloHelloHello"
21:04:55 <Korollary> Hah
21:04:59 <Korollary> Check this guy out: http://www.imdb.com/name/nm0685004/
21:05:01 <lambdabot> Title: Dan Piponi
21:05:05 <Korollary> He wrote a monad tutorial
21:05:09 <Korollary> http://sigfpe.blogspot.com/
21:05:10 <lambdabot> Title: A Neighborhood of Infinity
21:05:22 <Korollary> Enter the matrix, baby.
21:06:03 <Cale> heh, that's awesome
21:07:44 <emertens> @type [1,1] >> return 1
21:07:46 <lambdabot> forall a. (Num a) => [a]
21:10:54 <dons> ?quote DanPiponi Writing introductions to monads seems to have developed into an industry
21:10:55 <lambdabot> DanPiponi Writing introductions to monads seems to have developed into an industry hasn't said anything memorable
21:11:03 <dons> ?remember DanPiponi Writing introductions to monads seems to have developed into an industry
21:11:03 <lambdabot> Done.
21:11:28 <edwardk> http://www.loria.fr/%7Ekow/monads/index.html made me laugh
21:11:29 <stepcut> dons, what is the state of jabber support in lambdabot ?
21:11:30 <lambdabot> Title: Of monads and spacesuits
21:11:37 <stepcut> I see a few lines, but not much
21:11:43 <dons> that's it
21:11:53 <stepcut> is anyone actively working on it ?
21:11:59 <dons> nope
21:12:05 <dons> ADept was for a while
21:12:11 <edwardk> painfully painfully stretched analogy
21:12:44 <stepcut> dons: was there a reason beyond lack of interest for stopping ?
21:13:04 <dons> no
21:13:07 <dons> seems very doable
21:13:07 <stepcut> ok
21:13:25 <dons> i'd suggest the easiest path to be just translating the irc message output to and from jabber, if possible
21:13:39 <stepcut> yeah, I was looking at that possibility
21:14:14 <stepcut> something like the offline mode, except with a jabber backend ?
21:14:43 <emertens> Does anyone know what song this is? http://www.metacafe.com/watch/86033/pepsi_commercial/
21:15:13 <dons> stepcut: right
21:15:52 <stepcut> dons: ok, I will work on that tomorrow. I have a haskell binding for the loudmouth jabber library that I can use to get started
21:16:47 <dons> oh cool
21:18:14 <Cale> emertens: Heh, I'm told that I don't have a new enough flash player, and then when I click the link, I'm brought to a download for the version I currently have :)
21:18:21 <edwardk> jabber isn't so hard to speak. if you get stuck, just ask
21:18:54 * edwardk has cobbled together jabber clients in various languages.
21:18:58 <emertens> Cale: what browser?
21:19:06 <stepcut> edwardk: I got some haskell code going that can join a chat room, say hi, and listen to the responses. So I think I am in a good position now
21:19:21 <stepcut> edwardk: but a real haskell jabber library would be nice :)
21:19:23 <emertens> http://www.youtube.com/w/Jimmy-Fallon's-Pepsi-Ad?v=2YM0f3rEihw&search=jimmy%20fallon%20pepsi if you tube works for you
21:19:24 <Cale> emertens: Firefox
21:19:24 <lambdabot> Title: YouTube - Jimmy Fallon's Pepsi Ad
21:19:49 <Cale> yeah, that works
21:19:57 <emertens> Someone claims that it's Streamline by Newton
21:19:58 <emertens> on this page
21:20:58 <Cale> hmm, I have no idea
21:21:03 <stepcut> The biggest obstacle to a native haskell jabber library is a haskell XML parser that can returned the succesfully parsed portions of the XML as it receives them...
21:21:19 <emertens> a lazy parser?
21:21:25 <stepcut> but, maybe Text.Xml.HaXml.SAX could do the job
21:21:33 <stepcut> emertens: yeah, a lazy xml parser...
21:22:09 * edwardk hasn't really looked at the state of xml in haskell
21:22:19 <stepcut> hah, from the Text.Xml.HaXml.SAX haddock documentation: "A streaming XML parser, using a method known as SAX. SAX isn't really a standard, but an implementation, so it's just an "SAX-like" parser. This module allows you parse an XML document without having to evaluate it as a whole. This is needed for protocols like jabber, which use xml streams for communication."
21:22:27 <emertens> when it's discussed here it's mostly people bitching about it :)
21:22:28 <edwardk> i need to put together some for the javascript stuff, because of e4x but its totally different than dom and sax anyways
21:22:44 <edwardk> hehe
21:24:16 <Korollary> why does something like jabber use xml anyways?
21:24:28 <edwardk> kor: you can use jabber to exchange xml document fragments
21:24:32 <stepcut> well, I will use the binding for now -- because it takes care of a bunch of stuff like the network connection, SSL, etc. But a native library shouldn't be that hard if HaXml works as advertised
21:24:40 <edwardk> so its actually sort of a meta-protocol, when looked at the right way
21:24:55 <edwardk> but basically when it started they were just wanting to see what a streamed xml protocol would look like
21:25:21 <edwardk> i like jabber when it comes to dealing with data that is already xml. you can just bundle it up and send it over the wire
21:25:32 <edwardk> no proxy/firewall issues, etc.
21:25:35 <Korollary> How different is that from sending arbitrary binary files?
21:25:56 <edwardk> not much, except for the fact that its one simple tcp based protocol.
21:26:31 <edwardk> i wouldn't have designed the protocol the way it is, but i have no real good free alternative with servers out there to relay lightweight doc fragments with
21:27:13 <stepcut> question #6 -> http://www.jabber.org/developer/devfaq.shtml#id2754448
21:27:14 <lambdabot> Title: Jabber Development FAQ
21:27:58 <stepcut> the answer appears to be mostly, 'because' :p
21:28:15 <Korollary> because we wants it. end of story.
21:28:35 <edwardk> heh when it first started i mostly told them they were dumb for trying to use xml for that purpose when i was asked. =)
21:28:52 <stepcut> edwardk: did you suggest s-exps instead ?
21:28:54 <emertens> here we go
21:28:56 <edwardk> heh
21:29:05 <edwardk> nah, not much of a lisp guy
21:29:20 <edwardk> here we go?
21:29:28 <emertens> xml hating :)
21:29:30 <edwardk> heh
21:29:31 <edwardk> nah
21:29:35 <edwardk> i don't hate xml
21:29:36 <emertens> and i found the mp3
21:29:58 <Korollary> I dont hav xml when it is properly used.
21:30:01 * stepcut gets back to other work
21:30:01 <Korollary> hav=hate
21:30:37 <edwardk> i mostly abuse xml to have a way to format documents in utf-8 and use entities to fake its presence when i don't have access to a utf-8 editor
21:30:39 <edwardk> =)
21:30:40 <stepcut> 'xml' is ok. DTD's blow chunks.
21:30:44 <edwardk> yeah
21:30:47 <edwardk> i'll agree with that
21:30:50 <emertens> xsd is better?
21:30:52 <edwardk> but entities are needed
21:31:00 <edwardk> and the alternatives lack any sort of equivalent
21:31:18 <edwardk> http://relaxng.org/ is pretty good
21:31:19 <lambdabot> Title: RELAX NG home page
21:31:32 <edwardk> very regexpy
21:31:51 <edwardk> nicely generates your boilerplate classes if you have to use java, etc.
21:32:19 <edwardk> XMLSchema is overkill and underkill at the same time
21:32:36 <edwardk> it wastes SOO much effort on features no one uses and document design methodologies that no one should use.
21:33:03 <edwardk> complexTypes spring to mind as an example of its excesses
21:33:21 <LordBrain> there's an s-expression version of xml... SXML
21:34:00 <stepcut> LordBrain: an oleg invention, I believe ?
21:34:24 <LordBrain> i think thats right....
21:34:27 <edwardk> the thing is that xml isn't about xml, its about xpath and xquery and the xml namespace stuff, etc.
21:34:36 <edwardk> those are things that are somewhat new
21:34:52 <edwardk> and are mostly overlooked by the functional language bigots who just see the crufty surface syntax.
21:36:18 <edwardk> software goes through cycles, we returned to s-expressions but call it XML now, we drifted from relational models back to the network model of CODASYL and rebranded it as RDF. it'll cycle back
21:36:59 <edwardk> at least its not ASN.1
21:37:22 <stepcut> :p
21:37:36 * stepcut knows nothing about ASN.1 except that people hate it
21:37:40 <edwardk> heh
21:37:43 <edwardk> with good reason =)
21:38:48 <edwardk> if you ever had to write a bunch of SNMP stuff you'd never ever want to hear the name ASN.1 again =)
21:39:48 <edwardk> but it gets some things right in the fact that it has a nice large library of assigned numbers. its one of the largest specifications thats actually _reasonably_ consistently implemented
21:41:10 <Korollary> This guy has issues with PCRE: http://article.gmane.org/gmane.comp.lang.caml.inria/27274
21:41:12 <lambdabot> Title: Gmane -- Mail To News And Back Again
21:42:10 * edwardk goes off to get some code written before morning
21:42:44 <Korollary> He's apparently the maintainer of http://felix.sf.net/papers/
21:42:45 <lambdabot> Title: Index of /papers
21:42:46 <Korollary> err
21:43:00 <Korollary> http://felix.sf.net
21:43:01 <lambdabot> Title: Felix Language Homepage
21:50:19 <LordBrain> he needs a "Why Felix?" section
21:51:51 <LordBrain> anyway... goodnight
22:26:08 <Cale> The pseudo-English word of the day is: queuesque
