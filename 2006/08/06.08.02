00:04:19 <zeeeee> dammit
00:05:42 <int-e> @yow
00:05:43 <lambdabot> World War III?  No thanks!
00:09:28 <Cale> http://www.boasas.com/ -- intuitionist logic? :)
00:09:29 <lambdabot> Title: [Boy on a Stick and Slither]
00:10:16 <dons> wacky
00:12:20 <dons> oh, i like the 'recent studies suggest ...' tshirt
00:14:56 <dons> we should really have a @boasas command, i'm thinking..
00:14:58 <beschmi> anyone working on an xmpp library for haskell? (read something about adding xmpp support to lambdabot)
00:15:08 <dons> ADept was
00:16:51 <Cale> hmm, someone should add boasas to ohnorobot
00:17:02 <Cale> That would be a whole lot of typing though.
00:17:46 <Cale> Though, not much typing per comic :)
00:17:51 <dons> heh
00:18:31 <lispy> beschmi: i was looking at it last night...there are lots of good libraries...i was thinking it might be easiest to find one with a suitable license and translate it to haskell :)
00:19:53 <beschmi> i had the same idea. cl-xmpp (and cl-sasl) looked ok
00:21:27 <beschmi> i started with sasl (digest-md5) and i'm looking at HaXml right now to see if i can use it to parse the stanzas
00:21:47 <lispy> heh, cl-xmpp is the one i looked at too :)
00:22:22 <lispy> with HaXml i think you want readXml
00:22:57 <lispy> beschmi: are the stanzas fixed?
00:23:14 <lispy> if so you could create a dtd and then use dtd2haskell to generate types for manipulating them
00:23:32 <Cale> dons: http://www.boasas.com/?c=274
00:23:34 <lambdabot> Title: [Boy on a Stick and Slither]
00:24:26 <dons> hehe
00:24:48 <Cale> I love the "Kid's Tip" ones :)
00:24:51 <Cale> http://www.boasas.com/?c=324
00:24:52 <lambdabot> Title: [Boy on a Stick and Slither]
00:24:57 <dons> yeah, they're lovely
00:25:28 <Cale> Oh, and the whole Frickles Mudcat for president of the US campaign :)
00:26:21 <lispy> i like the pollution shirt
00:26:55 <Cale> The funny part is that his campaign is more convincing than either of the US candidates' were at the time.
00:28:39 <lispy> oh wow
00:28:40 <lispy> http://www.boasas.com/?c=330
00:28:41 <lambdabot> Title: [Boy on a Stick and Slither]
00:28:43 <lispy> i like
00:29:00 <Cale> hehe
00:29:12 <dons> heh
00:31:04 <beschmi> lispy: i'm not sure about the stanzas, could be that unknown attributes and tags are allowed and have to ignored by the client
00:31:14 <beschmi> in some cases
00:32:13 <Cale> I love how god is depicted as a cloud with lightning bolts coming out of it, along with a cigarette and a bottle of beer.
00:32:27 <dons> :D
00:32:38 * lispy <3 the social comentary
00:32:47 <vincenz> <3 == ?
00:32:50 <lispy> beschmi: okay, well the combinator library isn't bad
00:33:02 <lispy> vincenz: it's d00d sp34k for heart
00:33:33 <vincenz> 1337
00:33:40 <lispy> totally
00:33:44 <Cale> http://www.boasas.com/?c=659
00:33:46 <lambdabot> Title: [Boy on a Stick and Slither]
00:33:47 <vincenz> like yeah, dude
00:33:53 <lispy> @leet heart
00:33:53 <lambdabot> Maybe you meant: last list seen
00:33:59 <lispy> @elite heart
00:34:00 <lambdabot> |-|ear+
00:34:09 <dons> mnah, but you could submit a patch...
00:34:44 <vincenz> @elite @elite
00:34:45 <lambdabot>  @e|i+E
00:34:51 <vincenz> @elite leet
00:34:52 <lambdabot> |e3t
00:34:55 <vincenz> it's off
00:34:58 <lispy> @. elite vixen
00:34:59 <lambdabot> wHa+ 7Ype Oph (Ar DO u DRIvE?
00:35:30 <lispy> @. elite elite foo
00:35:30 <lambdabot> f00
00:35:40 <lispy> @elite f00
00:35:40 <lambdabot> ph00
00:35:46 <lispy> @elite ph00
00:35:47 <lambdabot> f00
00:35:51 <lispy> interesting
00:35:58 <Cale> http://www.boasas.com/?c=650
00:35:59 <lambdabot> Title: [Boy on a Stick and Slither]
00:36:00 <vincenz> @elit flipflop
00:36:00 <lambdabot> flipFLoP
00:36:11 <vincenz> @elit flipflop
00:36:11 <lambdabot> FLIPFloP
00:36:13 <vincenz> hmm
00:36:14 <vincenz> no ph now
00:36:18 <vincenz> that's phat
00:36:37 <roconnor> add a vowel
00:37:02 <vincenz> I'll take an e for 100
00:37:25 <roconnor> @elit felipfelop
00:37:26 <lambdabot> ph3liPfe|0P
00:37:42 <dons> BZZZZ no 'e'. spin the wheel!
00:37:54 <lispy> @wheel
00:37:55 <lambdabot> Maybe you meant: where where+
00:38:29 * lispy sees various gambling plugins in lambdabot's future
00:38:40 <dons> heh
00:38:48 <roconnor> @roll them bones
00:38:49 <lambdabot> Consider it noted.
00:38:55 <roconnor> ?
00:38:59 <lispy> lol
00:39:13 <roconnor> @dice them bones
00:39:14 <lambdabot> "dice" (line 1, column 1):
00:39:14 <lambdabot> unexpected "t"
00:39:14 <lambdabot> expecting digit
00:39:28 <lispy> i could just see us going, @deal, @hold, @fold to play a game of poker :)
00:40:42 <lispy> okay, my last one for tonight
00:40:42 <lispy> http://www.boasas.com/?c=654
00:40:43 <lambdabot> Title: [Boy on a Stick and Slither]
00:40:45 <int-e> @dice 3w24
00:40:45 <lambdabot> 3w24 => 3
00:40:56 <lispy> w?
00:40:57 <int-e> @dice 3w20
00:40:57 <lambdabot> 3w20 => 3
00:41:01 <lispy> why not d?
00:41:02 <int-e> @dice 3d20
00:41:02 <lambdabot> 3d20 => 53
00:41:11 <int-e> yes. forgot to translate that. thanks.
00:41:15 <lispy> @dice 3d6
00:41:16 <lambdabot> 3d6 => 10
00:41:49 <roconnor> @dice 3d6 + 5d2
00:41:50 <lambdabot> 3d6 + 5d2 => 20
00:41:57 <int-e> but, why does that parse?
00:42:03 <roconnor> @dice 3d6 * 5d2
00:42:04 <lambdabot> 3d6 * 5d2 => 11
00:42:14 <int-e> @dice d107
00:42:14 <lambdabot> "dice" (line 1, column 1):
00:42:14 <lambdabot> unexpected "d"
00:42:14 <lambdabot> expecting digit
00:42:19 <int-e> @dice 1d107
00:42:20 <roconnor> @dice 3d6 ^ 5d2
00:42:20 <lambdabot> 1d107 => 103
00:42:21 <lambdabot> 3d6 ^ 5d2 => 4
00:42:35 <roconnor> @dice 3d(5d2)
00:42:36 <lambdabot> "dice" (line 1, column 3):
00:42:36 <lambdabot> unexpected "("
00:42:36 <lambdabot> expecting digit
00:42:51 <lispy> @dice 3d2 + 5d6i
00:42:52 <lambdabot> 3d2 + 5d6i => 25
00:43:04 <lispy> heh, complex dice
00:43:11 <dons> huh
00:43:28 <lispy> @dice 3d1i
00:43:28 <lambdabot> 3d1i => 3
00:43:32 <lispy> and imaginary dice
00:44:22 <dons> @dice 3d1abc
00:44:23 <lambdabot> 3d1abc => 3
00:44:35 <dons> @dice 3d1abcdefghijklmnopqrstuvwxyzPI
00:44:37 <lambdabot> 3d1abcdefghijklmnopqrstuvwxyzPI => 3
00:47:46 <lispy> i like throwing i and there and making math puns :)
00:48:06 <lispy> @dice 3d1 * pi
00:48:06 <lambdabot> 3d1 * pi => 3
00:48:20 <lispy> @dice 3aoeuaoeuaoeu
00:48:20 <lambdabot> 3aoeuaoeuaoeu => 3
00:48:42 <lispy> wow, that's a very forgiving parser as long as you start with a number
00:48:49 <lispy> @dice -3d4
00:48:49 <lambdabot> "dice" (line 1, column 1):
00:48:49 <lambdabot> unexpected "-"
00:48:49 <lambdabot> expecting digit
00:49:09 <dons> it just stops after ndm
00:49:27 <lispy> @dice 3d1 + 3d1
00:49:28 <lambdabot> 3d1 + 3d1 => 6
00:49:33 <int-e> @dice 42d107+100
00:49:33 <lambdabot> 42d107+100 => 2403
00:49:37 <lispy> but it does seem to recognize more than just ndm
00:49:37 <int-e> @dice 42d107+100000
00:49:38 <lambdabot> 42d107+100000 => 102223
00:49:40 <dons> maybe we should allow our programs to have random gunk at the end
00:49:46 <dons> hmm
00:50:09 <lispy> @dice 3steves4
00:50:09 <lambdabot> 3steves4 => 3
00:50:16 <int-e> @unlambda `.aigarbage at end?
00:50:16 <lambdabot> a
00:50:29 <int-e> :)
00:50:30 <lispy> @dice 4'2
00:50:31 <lambdabot> 4'2 => 4
00:50:38 <lispy> @dice 4'2
00:50:38 <lambdabot> 4'2 => 4
00:50:38 <ValarQ> @dice 1.8d25
00:50:39 <lambdabot> 1.8d25 => 1
00:50:42 <ValarQ> @dice 1.8d25
00:50:42 <lambdabot> 1.8d25 => 1
00:51:46 <lispy> @dice 3 3
00:51:46 <lambdabot> 3 3 => 33
00:52:11 <lispy> wow
00:52:13 <ValarQ> heh
00:52:21 <lispy> @dice 1 2 3 4 5
00:52:21 <lambdabot> 1 2 3 4 5 => 12345
00:52:36 <int-e> @dice 3d3+42d1000
00:52:36 <lambdabot> 3d3+42d1000 => 21444
00:52:48 <lispy> @dice 3d3 4d4
00:52:48 <lambdabot> 3d3 4d4 => 41
00:52:52 <int-e> @dice 101d101
00:52:52 <lambdabot> 101d101 => 0
00:53:01 <lispy> wait?
00:53:03 <lispy> 0?
00:53:12 <int-e> I read the source code :)
00:53:17 <int-e> http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Dice.hs
00:53:25 <Cale> @dice 10d10
00:53:26 <lambdabot> 10d10 => 74
00:53:29 <Cale> @dice 10d101
00:53:29 <lambdabot> 10d101 => 690
00:53:32 <Cale> @dice 101d10
00:53:32 <lambdabot> 101d10 => 0
00:54:04 <int-e> (it could try to approximate by a normal distribution instead for large n ...)
00:55:29 <lispy> why do you think it returns 0 for n > 100?
00:55:38 <int-e> because the code says so
00:55:49 <int-e> if n > 100 then return 0 else ...
00:56:07 <lispy> yeah, but why do you think the code says so?
00:56:24 <int-e> @dice 100000000000000d10
00:56:24 <lambdabot> 100000000000000d10 => 0
00:56:27 <dons> becaues of the replicate..
00:56:40 <Cale> lispy: what?
00:57:14 <Cale> @dice 100d10
00:57:15 <lambdabot> 100d10 => 582
00:57:18 <Cale> @dice 101d10
00:57:18 <lambdabot> 101d10 => 0
00:57:19 <Cale> @dice 101d10
00:57:19 <lambdabot> 101d10 => 0
00:57:20 <Cale> @dice 101d10
00:57:20 <lambdabot> 101d10 => 0
00:57:36 <lispy> Cale: we're looking at the source
00:57:43 <dons> oh no! the NUMBERS are broken!
00:57:47 <Cale> eval :: [(Int, Int)] -> IO Int
00:57:47 <Cale> eval = foldM ef 0
00:57:47 <Cale>     where ef acc (v,1) = return (acc+v)
00:57:47 <Cale>           ef acc (n,d) = if n > 100
00:57:47 <Cale>                             then return 0
00:57:49 <Cale>                             else do ls <- replicateM n (randomRIO (1,d))
00:57:51 <Cale>                                     return (acc + sum ls)
00:57:59 <Cale> it says right there :)
00:58:31 * lispy sighs
00:58:35 <lispy> yes, i see that it tests
00:58:42 <lispy> but why?
00:58:50 <Cale> To avoid long loops
00:58:51 <lispy> dons suggested because of the replicateM
00:59:01 <dons> consider... return (acc + sum ls)
00:59:06 <int-e> the plugins aren't execution-time limited per so
00:59:13 <int-e> se
00:59:18 <dons> threads are. yep
00:59:19 <Cale> Computing 100000000000000000 random values on dons' machine would be not fun
00:59:33 <lispy> ah
00:59:36 <Cale> Well, they're Ints, so they're bounded, but still
00:59:41 <lispy> @dice 100d10000000
00:59:42 <lambdabot> 100d10000000 => 501409665
01:00:06 <int-e> @dice -1d10
01:00:06 <lambdabot> "dice" (line 1, column 1):
01:00:06 <lambdabot> unexpected "-"
01:00:06 <lambdabot> expecting digit
01:00:18 <lispy> @dice 0d0
01:00:18 <lambdabot> 0d0 => 0
01:00:26 <lispy> @dice 2d0
01:00:26 <lambdabot> 2d0 => 1
01:00:30 <lispy> ;)
01:00:48 <int-e> @dice 2147483648d10
01:00:48 <lambdabot> 2147483648d10 => 0
01:01:08 <int-e> @dice 2147483648
01:01:09 <lambdabot> 2147483648 => -2147483648
01:01:17 <lispy> clever
01:01:52 <int-e> @dice 1d2147483648
01:01:52 <lambdabot> 1d2147483648 => -1746470696
01:01:56 <lispy> The tarrasque hits you for 2147483648d10 damage!
01:08:43 <beschmi> lispy: just found the xmpp library by ADept, seems to be pretty advanced already
01:18:47 <shapr> Good morning #haskell!
01:19:48 <psi> good morning
01:21:44 <SamB_XP> shapr: good... morning... if you call it that already...
01:26:12 <gour> morning #haskell
01:30:47 <dons> good morning gour :)
01:31:05 <gour> dons: morning
01:31:58 <gour> dons: when will you release hs-plugins 1.0 ?
01:32:21 <dons> well, i've tagged 1.0rc0 (or rc1, I can't remember)
01:32:22 <beschmi> morning shapr, morning gour
01:32:24 <dons> so i should do it soon
01:33:02 <gour> great. do you have something for 2.0 ?
01:33:21 <dons> my plan is a rewrite based on ghc-api
01:33:51 * gour returned to zagreb to 19C and rain after spending some time on the coast with ~35C every day :-(
01:34:26 <gour> dons: something similar to Lemmih's hack for hIDE?
01:34:52 <dons> i was imagining providing the hs-plugins api, but using ghc-api for most of the underlying work
01:35:03 <dons> so something like hIDE, but more comprehensive, i think
01:36:13 <gour> that's very nice to hear. i'm definitely planning writing some app for which i'd like to have working plugin system
01:37:14 <dons> ok. good
01:37:47 <dons> shapr, hope has a lot of dependencies, doesn't it?
01:41:12 <gour> dons: will rewrite become 2.0? any eta?
01:41:34 <dons> hmm. hard to see. within a 6 months, hopefully.
01:41:54 <dons> shouldn't be too hard to do, though
01:42:50 <gour> fine
01:45:49 <dons> this is quite fun http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html
01:45:50 <lambdabot> Title: Stevey's Blog Rants: Execution in the Kingdom of Nouns
01:47:11 <gour> it's quite long too :-(
01:47:56 <gour> this is fun: "In short, object oriented thinking is essentially the burden of the 'white man'."
01:48:14 <SamB_XP> what the what?
01:48:31 <dons> advocating Object-Oriented Programming is like advocating Pants-Oriented Clothing"
01:48:32 <SamB_XP> does that qualify as a racist comment?
01:50:35 <dons> oh, down in the comments
01:50:39 * dons finally gets to the end
01:52:16 <dons> oh, heh:If you've twisted your head around haskell's monads, you'll have learned that "everything is a noun" isn't the strangest world. Stranger still is "everything is a plenum of abstract functions, where time sequence can only be modelled by composing functions as consequents of one another, and nothing is computed unless it's needed to solve the one single function that defines the universe".
01:54:32 * Cale winces at the notion of solving a function
02:01:45 * int-e hands Cale some H2SO4.
02:04:02 <Pete_I> ...
02:04:31 <Pete_I> think i agree with whoever said "you can't handle the truth"
02:04:52 <shapr> hiya beschmi, ltns
02:05:29 <shapr> dons: Yup, hope makes me wish for cabal-get on a regular basis.
02:06:45 <shapr> dons: It sure does kick butt though.
02:06:57 <dons> ok i'll battle through the dependencies :)
02:08:19 <shapr> The README should mention all the deps, I think.
02:08:37 <dons> yeah
02:08:37 <psi> @where hope
02:08:38 <lambdabot> http://hope.bringert.net/
02:08:39 <shapr> Also, it used to be worse, bringert had each of the Hope modules in its own repo.
02:08:45 <dons> heh
02:08:56 <dons> I think maybe they should be nested, a la fptools
02:09:01 <dons> and we just run ./darcs-all get
02:09:38 <shapr> As soon as cabal-get starts working, I'll upload the whole collection.
02:09:53 <shapr> xerox: Any idea when that will happen?
02:12:17 <dons> shapr: we've improved goa a bit. you should check it out.
02:12:23 <dons> demo on the lambdabot home page
02:12:32 <shapr> Oh hey
02:12:41 <shapr> Can you do a @plugs version of ghci?
02:12:49 <dons> hmm?
02:13:10 <dons> you can call @plugs from goa, from ghci, you mean?
02:13:49 <shapr> Did you hear about my idea to do shared #haskell teaching by putting GHCi into a flash applet?
02:14:08 <dons> yes, i think you mentioned it.
02:14:13 <dons> how would it work? a demo?
02:14:15 <shapr> I was just wondering about a 'safe' GHCi.
02:14:18 <dons> ah
02:16:03 <mux> oh my, I *have* to try this Hope thing
02:17:47 <psi> hope looks cool
02:18:54 <mux> Compiler ghc
02:18:55 <shapr> Is there a good single paper to read about dependent types?
02:18:56 <mux> Complier version 6.4
02:18:59 <mux> heh, nice typo
02:19:57 <psi> the hope sites listed there all seem to use the same color scheme
02:20:07 <psi> can you not change it?  (easily)
02:21:43 <shapr> psi: You can, and there are two color schemes. But this is the neatest.
02:21:50 <shapr> It's also easy to make your own.
02:22:40 <psi> cool
02:24:34 <dons> bernie pope is evil. making students implement polymorphic zipWith in C!
02:24:50 <dons> http://www.cs.mu.oz.au/~bjpop/ (the (Zipping Lists) entry)
02:24:51 <lambdabot> Title: Bernie Pope's home page
02:24:56 <mux> whoa, the generated HTML code is wonky
02:25:05 <dons> that'll learn them to use haskell..
02:31:51 <int-e> Oh, function pointers in C are so intuitive ...
02:32:06 <Cale> I think it's a decent example :)
02:33:07 <Cale> The C code isn't *that* terrible, but it's certainly looks clumsy in comparison with the Haskell implementation :)
02:33:58 <int-e> yep. it's fair.
02:34:10 <dons> Cale: its fun, I agree. have you ever written polymorphic list functions in C, though?
02:34:31 <dons> anyway, it makes the point clear :)
02:35:14 <int-e> qsort exists - although that's an array function.
02:35:17 <Cale> hmm... possibly I have. I've done something similar in some imperative language before, using a type not unlike void *, but I can't recall which language :)
02:35:21 <dons> qsort exists.
02:37:38 <mux> void *(*)(void *) !
02:37:43 <int-e> Hmm. I dislike function pointers. So in C, I tend to copy&paste coding, or resorting to C++ templates.
02:38:04 <dons> oh, in C, I tend to resort to Haskell
02:38:08 <Cale> hehe
02:38:09 <int-e> hehe
02:38:22 <int-e> mux: declaration resembles use :)
02:39:06 <Cale> C's notation for types is annoying
02:39:29 <Cale> despite its simplicity
02:39:32 <ProfTeggy> unsigned short int, int short unsigned, short int unsigned, ... all valid
02:39:40 <int-e> ml's notation for types is also annoying :)
02:39:45 <ProfTeggy> How can that be annoying?  it's flexible.
02:39:46 <ProfTeggy> :-)
02:39:54 <int-e> don't forget unsigned short
02:40:00 <ProfTeggy> All permutations actually
02:40:09 <int-e> the int is still optional even though omitting it is frowned upon.
02:40:30 <mux> don't forget char, the only type whose default signedness is implementation defined!
02:40:48 <ProfTeggy> That's why kosmikus could publish a paper on a permutation parser combinator ;-)
02:40:48 <int-e> huh, int has to be signed?
02:40:53 <mux> no
02:41:09 <mux> but any other types are signed by default, if you don't specify anything
02:45:24 <shapr> mux: Generated html from Hope is broken?
02:45:31 <mux> not broken
02:45:44 <mux> just very weird
02:45:45 <shapr> expliquez!
02:45:55 <shapr> It's generated from Bringert's haskell-xhtml library.
02:45:59 <mux> <html
02:45:59 <mux> ><head
02:45:59 <mux>   ><title
02:46:00 <mux>     >Hope - Entries from July 2006</title
02:46:07 <mux> see my point? :-P
02:46:09 <dons> looks like an easy one to fix
02:46:13 <shapr> Oh yeah, there's a very good reason for that.
02:46:13 <mux> yep
02:46:17 <dons> patchify!
02:46:24 <int-e> mux: thanks. I knew that, but somehow I was on the brink of assuming that the same applies to the other integer types as well.
02:46:28 <shapr> html ignores whitespace between tags, but it is significant in xml.
02:46:49 <shapr> Thus the only way to get decent indentation/spacing/readability in xml is to put whitespace inside the tag itself.
02:47:22 <mux> I don't get your point
02:47:56 <shapr> gotta go to the UK, no time
02:48:09 <mux> the webpage would clearly work with a more conventional generated XHTML
02:48:18 <mux> see you
02:49:53 <dons> @seen dcoutts
02:49:54 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-overflow, #haskell-blah and #haskell. I last heard dcoutts speak 10 hours, 13 minutes and 49 seconds ago.
03:00:17 <dons> haskell-cafe "Haskell is the most powerfull and interesting "thing" I've ever encountered in IT world."
03:00:49 <dons> that's the way i would like all newbies to start their questions about monads... ;)
03:03:44 <xerox> nwin 25
03:03:48 <xerox> Woops.
03:03:50 <xerox> Good morning.
03:18:23 <dons> oh, hmm, main :: IO Integer
03:33:28 <dons> quiet for this time of the day.. everyone at anglo haskell?
03:33:41 <dons> on unicycles? and not juggling their wifi?
03:36:00 <alar> everyone is listening to you :)
03:36:10 <musasabi> hello dons
03:37:32 <dons> ?brain
03:37:32 <lambdabot> Brain! Brain! You aren't going to leave me!!!???You know what happened to Jerry Lewis after Dean Martin left him!!!
03:37:37 <dons> heh
03:38:06 <Adamant> ?brain
03:38:07 <lambdabot> The game does not conclude until the woman with the eating disorder ululates.
03:38:31 <Adamant> someone has to put that one into sarahbot
03:39:11 <dons> :)
03:40:40 <Adamant> Animaniacs is now on DVD! </shill>
04:17:00 <dons> ping #haskell
04:17:17 <Pete_I> pong dons
04:17:21 <Pete_I> :)
04:17:28 <dons> :)
04:20:10 <alar> icmp reply error
04:20:43 <dons> ?where+ lazy-regex http://sourceforge.net/projects/lazy-regex
04:20:44 <lambdabot> Done.
04:21:09 <alar> oh, lazy regexp
04:21:11 <alar> nice
04:21:31 <alar> I thought of writing my own pure regexps once
04:31:33 <kfish> dons: hi
04:32:24 <kfish> when switching from [Word8] to ByteString.Lazy, what's the best way to replace pattern matches against [] and (x:xs) etc?
04:33:02 <gour> @where jhc
04:33:03 <lambdabot> http://repetae.net/john/computer/jhc/
04:33:17 <dons> hey kfish :)
04:33:28 <dons> ok, let me roll some code..
04:35:01 <dons> ok, fastest/maybe the best:
04:35:03 <dons> f []     = []
04:35:03 <dons> f (x:xs) = x : f xs
04:35:03 <dons> f ps | B.null ps = []
04:35:03 <dons>      | otherwise = x : f xs
04:35:05 <dons>     where (x,xs) = (B.unsafeHead ps, B.unsafeTail ps)
04:35:13 <dons> so the top code becomes the bottom
04:35:25 <dons> the key is that (x:xs) --> where (x,xs) = (B.unsafeHead ps, B.unsafeTail ps)
04:35:48 <dons> this is safe here, since we have already checked the [] case, with B.null
04:35:50 <musasabi> dons: have you played with branding ByteStrings with their lenghts?
04:36:00 <kfish> dons: ack
04:36:00 <dons> hmm. in the type??
04:36:03 <musasabi> yes
04:36:21 <dons> musasabi: no. interesting! what were you thinking ?
04:36:59 <dons> oleg-style type level decimals?
04:37:00 <musasabi> dons: mostly the simple ideas from http://okmij.org/ftp/papers/lightweight-static-capabilities.pdf
04:37:08 <dons> mm!
04:37:16 * dons reads
04:38:47 <musasabi> dons: the section 2 is direcly usable for the normal "I checked B.null - now why I have to write unsafeHead/Tail instead of the normal ones".
04:40:53 <mahogny> hm. was there a function to swap the order of the arguments to a 2-argument function?
04:41:07 <musasabi> @type flip
04:41:09 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
04:41:17 <mahogny> right
04:41:50 <mahogny> hm. it would be kind of nice if there was a larger set of functions to permutate arguments, like this would be say sw21
04:42:13 <musasabi> easier to just use a lambda abstraction usually.
04:42:26 <dons> musasabi: so basicaly define a new type, NonEmptyByteString, that can only be produced via a smart constructor
04:42:28 <mahogny> well. this is shorter :)
04:42:46 <dons> and then turn partial functions like head/tail into total functions on NonEmptyByteString.
04:42:53 <musasabi> dons: yes.
04:43:48 <musasabi> then there is the index branding stuff used in the section 3 (for example for binary search)
04:46:32 <liyang> mahogny: I'm tempted to say, Faking It, end of section 3.
04:46:52 <liyang> http://cs.nott.ac.uk/~ctm/faking.ps.gz
04:47:28 <liyang> But it's not going to work anymore as of GHC 6.5.
04:48:04 <mahogny> :(
05:45:19 <eivuokko> Has anyone tried to actually write an efficient bigint library in haskell?  (Possibly using ghc's unboxed types and primities)
05:45:35 <dons> i don't think so. i think its possible though
05:45:57 <eivuokko> I actually do, too.
05:46:01 <musasabi> eivuokko: don't things like GMP have actual implementations written with assembler for most platforms?
05:46:07 <dons> they do
05:46:19 <dons> so I don't think we could ever hope to beat that
05:46:24 <dons> right, eivuokko ?
05:46:41 <eivuokko> musasabi, Yes, many have.  But some C-libs have got similar performance, but they usually use extra space in order to conviently exress overflow/carry.
05:46:51 <dons> eivuokko: were you looking at ANF for your compiler back end, btw?
05:46:58 <eivuokko> Warning: I have not done objective benchmarks.
05:47:11 <musasabi> then again with Haskell one could implement fancier algorithms easier
05:47:34 <eivuokko> dons, I have been lazying and enjoying sun and working on Win32 lately.  I'm thinking over exact ANF-specs I'd like to have.
05:47:36 <musasabi> but without carry etc it would be painful
05:47:42 <dons> i spoke to the author of the anf paper, he's back in the anf game, and is interested to hear of any users.
05:48:05 <musasabi> btw does C-- have math with carry?
05:48:09 <eivuokko> No
05:48:24 <dons> he said to mail him ( patrykz <> cse.unsw.edu.au  ) if you're get serious with it
05:50:14 <musasabi> would Haskell generating assembler for different platforms work?
05:50:49 <eivuokko> That doesn't differ from designing special language for the task
05:51:06 <dons> well, it'd be cool though :)
05:51:14 <eivuokko> Yes :)
05:51:31 <dons> we need Language.Ams
05:51:38 <dons> grr. *.Asm
05:51:40 <eivuokko> I have Asm.Ia32 :)
05:51:57 <dons> oh, that's right!
05:51:59 <eivuokko> Which might or might not be what you want, tho.
05:53:04 <mux> now go bang your head against the wall and write ASM.Ia64 :-)
05:53:16 <mux> that would be both annoying, complicated and useless
05:53:20 <eivuokko> Will you supply a machine?
05:53:23 <mux> sounds like a nice project :-)
05:53:40 <musasabi> Ia64 seems more or less dead
05:53:47 <eivuokko> Yeah, probably.
05:55:04 <eivuokko> dons, About ANF.  My problem is that my primary target is ia32 ;)  On it, register allocation (on cool solutions) should take into account combining load/store with actual operations, and reusing register more aggressively (ie as instruction source and target), which most reg allocs seem to be unable to handle.
05:55:14 <musasabi> Would using SSE for bignum ops be possible?
05:55:23 <mux> yeah
05:55:32 <mux> you could use SSE to speed up byte copies for instance
05:56:01 <mux> now sure how else it could be useful, but there's probably more tricsk to use
05:56:30 <musasabi> .&. and .|. perhaps
05:56:37 <musasabi> (as they don't have carry)
05:57:12 <musasabi> not sure about addition etc
05:57:14 <dons> yeah, I thought a bit about SSE in bytestring
05:57:28 <mux> eivuokko: maybe I could lend you a shell onan ia64 box, but I'd risk getting my head cut off
05:57:30 <dons> improving Data.Bits is something to look at, actually
05:57:37 <mux> so that doesn't sound too hot :-P
05:57:43 <eivuokko> mux, Heh.
05:58:12 <dons> ?index lazy
05:58:13 <lambdabot> bzzt
05:58:15 <dons> ?index inline
05:58:16 <mux> FreeBSD 6.1-STABLE #1: Thu Jul 27 02:20:56 UTC 2006
05:58:16 <lambdabot> bzzt
05:58:16 <mux>     marcel@pluto2.freebsd.org:/q/obj/q/6.x/src/sys/PLUTO2
05:58:16 <mux> CPU: McKinley (900.00-Mhz Itanium 2)
05:58:16 <mux>   Origin = "GenuineIntel"  Revision = 7
05:58:16 <mux>   Features = 0x1<LB>
05:58:22 <mux> FreeBSD/SMP: Multiprocessor System Detected: 2 CPUs
05:58:22 <mux> cpu0: SAPIC Id=0, SAPIC Eid=0 (BSP)
05:58:22 <mux> cpu1: SAPIC Id=1, SAPIC Eid=0
06:00:21 <eivuokko> dons, Anyway, ANF-based regalloc is maybe slightly harder on ia32 (the wya I'd like to do it) than on more RISCish archs, compared to typical SSA-style representation.
06:01:52 <dons> maybe. i think that's something patryk wants to find out more about, though.
06:01:57 <dons> you could mail him your thoughts
06:06:57 <eivuokko> Ok.  I'll put it on todo-track for anf-stuff.
06:07:16 <eivuokko> Don't feel like writing mails right now, it's too tiring.
07:06:41 <damian_> who the hell uses haskell
07:07:38 <dons> hello damian_
07:07:57 <damian_> hello
07:08:01 <dons> that's a provocative way to introduce yourself.
07:08:10 <damian_> i know
07:08:18 <damian_> i was wondering what people would say
07:08:25 <dons> are you interested in haskell, or just trolling our channel?
07:08:32 <damian_> both
07:08:57 <dons> perhaps you can leave the 2nd part out, and you'll have a much better experience here.
07:09:07 <damian_> i suppose
07:09:26 <SamB_XP> I use Haskell
07:09:32 <damian_> i should probably find out what haskell is even used for
07:09:43 <dons> check http://haskell.org
07:09:45 <lambdabot> Title: Haskell - HaskellWiki
07:09:55 <dons> its a general purpose language, so its used for just about everything
07:10:25 <dons> in particular, under 'libraries and tools' you'll get a sense of what is being done
07:10:41 <dons> ranging from operating systems to music composition to theorem provers
07:11:01 <SamB_XP> its a nice imperative language, though sadly it is apparantly not very efficient for VMs...
07:11:07 <dons> heh
07:11:12 <dons> yeah, an interesting puzzle
07:11:21 <damian_> why not
07:11:36 <dons> it's a little joke about the icfp contest recently
07:11:43 <dons> in general you'll find haskell very efficient.
07:11:45 <dons> ?shootout
07:11:46 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
07:11:54 <dons> for example. we average 1.3x C last time I checked
07:12:04 <SamB_XP> oh, well, maybe it isn't too bad then
07:12:20 <dons> good to know, SamB_XP ;)
07:12:24 <damian_> is haskell is compiled then
07:12:36 <dons> it is compiled, interpreted, all things :)
07:12:37 <SamB_XP> when speed is an issue, yes ;-)
07:12:46 <dons> the most common system is ghc, which has both a compiler and interpreter
07:12:52 <dons> > map (+1) [1..10] -- compiled
07:12:54 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
07:13:17 <SamB_XP> certainly you want to compile it before comparing speeds between Haskell and C
07:13:56 <damian_> of course
07:14:17 <dons> speed is fun. but the expressivity is the main reason to hack haskell
07:14:57 <damian_> did y'all learn to program in school or as a hobbie?
07:15:05 <damian_> offtopic but i'm curious
07:15:11 <dons> hmm. it's probably half and half here
07:15:24 <SamB_XP> and you ought to know that, yes, Haskell must be compiled (at least sometimes) if it is 1.3 times slower than C for the same thing, when said thing is easy to do efficiently in C
07:15:49 <dons> 1.3x also implies that a bit less than half the time we beat C
07:16:05 <dons> particularly for concurrent and data structure problems
07:16:06 <SamB_XP> hmm?
07:16:10 <dons> but also some tight numeric code
07:16:39 <dons> SamB_XP: you didn't see the full shootout analysis i posted recently?
07:16:44 <dons> simon posted, i should say
07:16:48 <SamB_XP> nope
07:16:55 * genneth would also like a link
07:16:56 <dons> let me find you the link
07:17:05 <musasabi> bit handling is quite poor and that probably affects the UM quite seriously
07:17:16 <SamB_XP> hmm
07:17:36 <jgrimes_> damian_: I'm learning haskell as hobby, but my uni's classes are oriented around Java and C (with an emphasis on Java)
07:17:38 <SamB_XP> musasabi: how can bit handling be poor? doesn't it just pass through to C?
07:17:47 <genneth> i think the UM just wasn't very amenable to any cleverness
07:18:04 <damian_> i learned scheme in my introductory cs class
07:18:08 <damian_> i thought it was a poor choice
07:18:11 <dons> SamB_XP: i think its more that we don't get access to the unchecked bit shifting code
07:18:12 <damian_> since no one uses scheme
07:18:23 <dons> damian_: right. no one uses scheme.
07:18:25 <genneth> the potential for self-modifying code just destroys JIT, requiring complex analysis
07:18:26 <SamB_XP> dons: what? what is this about checking?
07:18:46 <SamB_XP> genneth: huh?
07:18:50 <dons> ah, we had 30% speed ups replacing `shiftR` with `uncheckedLRShift#`
07:19:02 <dons> SamB_XP: the um had self modifying code
07:19:10 <dons> which suckified, i think is the technical term
07:19:16 <SamB_XP> heh
07:19:20 <int-e> hmm. have we tried putting that into sjanssen's code? I guess not. Maybe we should :)
07:19:27 <SamB_XP> in the actual mashed codex?
07:19:38 <dons> int-e, i expect it would get to about what mine does
07:19:39 <genneth> i did work out a possible way to do it, but it would have given dubious levels of speed ups
07:20:47 <genneth> damian_: a CS education isn't all to do with learning languages that people "use"
07:20:51 <SamB_XP> I suppose that increasing the performance of the UM for the actual codex would really involve somehow increasing the locality of reference...
07:21:09 <SamB_XP> genneth: but Scheme has no syntax!
07:21:24 <SamB_XP> couldn't they at least teach languages with syntax?
07:21:29 <dons> heh
07:21:34 <kpreid> Scheme has syntax, it's just split into layers
07:21:35 <damian_> genneth an introductory cs class should teach you a language that people use in real life because it provides a solid base
07:21:41 <dylan>  scheme has a syntax, although a very simple one
07:21:47 <genneth> SamB_XP: and the reason it's got no syntact is why all the masters of the language loves it...
07:21:54 <damian_> i won't be able to do anything with the scheme i've used
07:21:55 <dons> heya dylan
07:21:58 <damian_> because it's obscure
07:22:05 <SamB_XP> kpreid: but the lower layers are impervious to the human brain
07:22:05 <genneth> damian_: i'd say in a foundational class you ought to be taught the foundations
07:22:14 <dons> yeah. its the concepts.
07:22:20 <damian_> i could be taught both AND a practical language
07:22:24 <damian_> i hate theory
07:22:28 <dylan> I think CS courses that each Java et al are evil and horrible, personally.
07:22:30 <SamB_XP> at least, they aren't visually apparant
07:22:32 <kpreid> damian_: then why are you in a CS class?
07:22:35 <int-e> dons: a quick cut&paste hack from my code: http://int-e.home.tlink.de/haskell/UM32.unsafeShiftR.hs
07:22:37 <kpreid> SamB_XP: taste.
07:22:45 <SamB_XP> scheme I suppose is better than Java.
07:22:49 <damian_> because i like coding much better than theorizing about coding
07:22:54 <SamB_XP> maybe ythey should teach dylan ;-)
07:23:02 <genneth> damian_: without the theory you will only get so far
07:23:03 <dons> damian_: you could drop out then. and hack visual basic
07:23:06 <SamB_XP> Java has syntax but it doesn't do any good.
07:23:06 <dylan> Dylan is a pretty horrible language too
07:23:17 <kpreid> damian_: the theory helps you understand how to code well
07:23:24 <damian_> why does visual basic have such a bad rep
07:23:28 <SamB_XP> dylan: do you enjoy bearing the name of a horrible language?
07:23:28 <damian_> i've never used it
07:23:33 <SamB_XP> damian_: it is icky
07:23:36 <damian_> why
07:23:38 <int-e> dons: i.e. that is sjannsen's code with the unsafeShiftR that I wrote :)
07:23:38 <dylan> SamB_XP: I existed before the language.
07:23:38 <SamB_XP> or at least, pre-.NET is
07:23:48 <genneth> damian_: believe me -- i spent 8 years coding C++ and C before i started learning haskell; I only learnt because I needed to...
07:23:50 <dons> ok, here's the stats, http://www.mail-archive.com/haskell-cafe@haskell.org/msg14872.html
07:23:52 <lambdabot> Title: [Haskell-cafe] Re: Haskell performance in heavy numerical computations
07:23:56 <dons> but the formatting got a bit wacked
07:23:59 <SamB_XP> dylan: hehe
07:24:06 <dylan> only just, though
07:24:13 <dylan> like 1 year older or so.
07:24:15 <dons> we're faster than C in 6 of the benchmarks
07:24:22 <dons> 7
07:24:24 <SamB_XP> actually, I haven't used VB 7 either
07:24:45 <damian_> how much theory is actually involved in programming large pieces of software
07:24:50 <damian_> lots of concepts i'm sure
07:24:55 <damian_> but abstract theory?
07:25:05 <genneth> damian_: how do you organise the concepts?
07:25:13 <musasabi> SamB_XP: bit ops are not optimized very well as compared to Int operations. The uncheckedLRShift# point.
07:25:27 <damian_> theory is fine in small doses
07:25:31 <dons> damian_: what's abstract theory, in your view? recursion?
07:25:46 <damian_> ok dons
07:25:48 <damian_> from now on
07:25:51 <damian_> no more coding
07:25:56 <damian_> i will theorize about coding instead
07:25:59 <damian_> and get nowhere
07:26:08 <SamB_XP> the trouble with VB is that it is more of a bad "form designer" than a programming language. oh, and it claims to be OO but has neither prototypes nor inheritance.
07:26:28 <dons> damian_: you can do both. you _must_ do both, to be good at this game
07:26:32 <dylan> damian_: I think you are confusing the vernacular meaning of "theorize" with the academic usage...
07:26:33 <genneth> dons: i see that FPS will help the worst stragglers quite a bit...
07:26:33 <emertens> VB 6 doesn't have inheritence, but who uses VB 6 anymore?
07:26:39 <SamB_XP> well.
07:26:40 <dons> genneth: right
07:26:47 <SamB_XP> I just said I hadn't used vB 7 ;-)
07:26:51 <SamB_XP> is VB 7 better?
07:26:54 <damian_> dylan that's what i mean
07:27:01 <damian_> i use its academic meaning
07:27:08 <emertens> VB.NET is almost unrelated to VB 6 :)
07:27:15 <dylan> you seem to be using the vernacular meaning
07:27:19 <damian_> no
07:27:24 <SamB_XP> oh, and I think VB prevented me from actually learning to program properly for a while...
07:27:31 <dons> damian_: what's some theory that's been bugging you?
07:27:37 <emertens> I perfer C#, but VB.NET is a big step forward from VB 6
07:27:46 <dons> ah, better formatting http://www.haskell.org/pipermail/haskell-cafe/2006-July/016562.html
07:27:47 <lambdabot> Title: [Haskell-cafe] Re: Haskell performance in heavy numerical computations
07:27:55 <SamB_XP> wait, I think I have my versions mixed
07:28:00 <damian_> i don't like designing programming languages
07:28:02 * genneth sees MS taking C# and VB into a DSL for business apps
07:28:08 <damian_> which is what we did a lot in intro. cs
07:28:11 <damian_> i like working with them
07:28:13 <SamB_XP> s/VB 6/VB 5/, s/VB 7/VB 6/
07:28:29 <genneth> damian_: there is a gradual progression between libraries and languages
07:28:33 * dylan hasn't had any CS classes yet, but has designed a very simple dynamic language.
07:28:58 <genneth> damian_: inevitably, one evolves into the other
07:29:03 <SamB> dylan: oh, can I see the design?
07:29:18 <SamB> genneth: which evolves into which now?
07:29:30 * SamB can't tell which is "one" and which is "the other"
07:29:55 <genneth> SamB: i tend to see libraries evolving bigger to become DSLs and then entire languages
07:30:02 <dylan> SamB: Okay, design is a bad word. How about "stole semantics from javascript and used different keywords and the slowest possible lexical variables"
07:30:11 <SamB> dylan: hmm?
07:30:30 <SamB> what was the problem with Javascript?
07:30:34 <damian_> don't diss javascript
07:30:43 <damian_> OSs have been written in them
07:30:45 <dons> how can you steal semantics from javascript ;)
07:30:48 <dylan> SamB: this was a domain specific language.
07:31:04 <SamB> I mean, why bother to just change the keywords/
07:31:11 <SamB> s|/|?|
07:31:21 <dylan> dons: Perhaps I used the wrong word. It has the same behavior as javascript, just with a different syntax.
07:31:44 <dylan> SamB: Well, because I wrote things in the language before it existed.
07:31:52 <dylan> and it didn't start out like javascript, exactly.
07:32:04 <genneth> ah...
07:32:06 <genneth> that old game
07:32:14 <dylan> I found 'let foo = bar;' and 'fun foo(...) { ... }' nicer than 'var' and 'function', as keywords.
07:32:37 <int-e> fun fun!
07:32:53 <musasabi> JavaScript has a nice simple object model.
07:32:58 <dylan> fun foo(...) { ... } became sugar for let foo = fun(...) {...};
07:33:02 <musasabi> But is not nice for debugging things.
07:33:03 <genneth> i tend to find that if you find yourself making a looping construct in your "small" language, then it's time to investigate an implementation as an embedding in a larger, more thought-out language
07:33:22 <dons> genneth: oh, that's an interesting rule of thumb!
07:33:30 <dons> that's about the point I make the switch too
07:33:50 <dylan> My language had a 'for ... in' loop, like in python. But it was really sugar for defining a function.
07:34:34 <dylan> I'm somewhat proud, in a very strange way, of how slow lexical variables were in it. XD
07:34:44 <Philippa_> I'd've thought it depends on the nature of the loop, but yeah
07:35:02 <Philippa_> it's that or you're effectively specialising one of the well-known typed lambda calculi with a bit of sugar, or doing something of that ilk
07:35:16 <genneth> the specific case in mind I'm thinking of are the PHP template libraries
07:35:19 <dylan> lookup was O(n), where n is the number of parent scopes. XD
07:35:24 <tibbe> I need an XML parser and an SQLite access layer, what libraries can you recommend? Oh yeah, it would be nice if I could find a HTTP request parser too.
07:35:34 <genneth> first you had PHP, which was just a few sprinkles of code
07:35:40 <genneth> then it evolved...
07:35:46 <genneth> so now we've got templates in PHP
07:35:53 <int-e> dylan: so what, let's just write spaghetti code.
07:36:03 <genneth> which themselves have for loops and special tag formats...
07:36:09 <genneth> so the cycle continues
07:36:20 <dylan> int-e: hmm? Well, I wanted to have closures and stuff.
07:36:52 <int-e> dylan: I'd still be more worried about the constant factor I think.
07:37:09 <dylan> I also had exceptions, crappy/slow first class modules (a la python), etc.
07:37:23 <int-e> dylan: but maybe I underestimate the order of magnitude of the number of scopes you dealt with.
07:37:33 <dylan> int-e: scopes == 4 .. 5
07:37:40 <dylan> Always at least 2.
07:37:42 <int-e> I didn't then.
07:38:08 <dylan> interestingly, each scope could be turned into a module.
07:38:30 <int-e> . o O ( perl. )
07:38:36 <dons> heh
07:38:47 <dylan> it's perl-like, except I lack a global package namespace.
07:39:23 <int-e> I hope it had a saner syntax :)
07:39:30 <int-e> or has.
07:39:48 <dylan> it still exists, but it is written in ocaml and I find that ocaml's compiler is under the QPL
07:40:54 <jgrimes_> is this the "Wobbly types" paper referred to on the wikibook? http://citeseer.ist.psu.edu/jones04wobbly.html
07:41:02 <dons> sounds right
07:41:20 <jgrimes_> sounds good.
07:41:20 <dons> jgrimes_: yes, it is.
07:41:26 <Philippa_> there're two versions, they're both worth reading IMO
07:43:28 <dylan> heh, whee. No one has asked 'why' I wrote an interpreter for a toy language. That's nice, for a change... usually people ask why, or tell me that it's not useful (but it was fun! I say)
07:43:30 <genneth> dons: it looks like the other languages have been making a push for the shootout too...
07:43:39 <kowey> jgrimes_: was that you that made that comment about +1 and arrows yesterday?
07:43:41 <dons> genneth: yeah, recently there's been some interest
07:43:54 <kowey> jgrimes_: and if so, was that in reference to the wikibook?
07:43:55 <dons> when 6.6 comes out, we can restart our campaign.
07:43:57 <SamB> dylan: heh
07:43:58 <genneth> dons: i'm sure the idea that we were beating them was just too much to take... :D
07:44:05 <dons> i've got a couple of faster entries already up my sleeve
07:44:14 <edwinb> dylan: that's because it's always worth writing interpreters for toy languages... whether just to learn how to do it or play with new features.
07:44:14 <SamB> dylan: I was asking about your language design so *I* could write one too ;-)
07:44:17 <dons> genneth: i reckon so
07:44:21 <edwinb> and being fun is a good reason too...
07:44:24 <jgrimes_> kowey: Umm, I've made a reference to the wikibook arrows page, not sure of that particular instance though
07:44:35 <dylan> SamB: Well, you could use the test case programs.
07:45:03 <kowey> jgrimes_: oh ok, i was just going to say, sorry about that, i'm mostly writing that page as a way to learn about arrows
07:45:13 <kowey> jgrimes_: as you can probably tell, i haven't gotten very far
07:45:17 <SamB> dylan: why does your language remind me of RML?
07:45:37 <dylan> http://svn.gna.org/viewcvs/bake/trunk/src/t/scripts/
07:45:39 <lambdabot> Title: SVN Repositories at Gna! - directory - bake: trunk/src/t/scripts
07:45:41 <dylan> SamB: RML?
07:46:00 <jgrimes_> kowey: yeah, the understanding arrows page is what I commented on a few days ago.
07:46:43 <lisppaste2> SamB pasted "gc.rml" at http://paste.lisp.org/display/23546
07:48:25 <dons> oh fun. lots of darcs patches today
07:49:06 <dons> SamB: heh
07:49:13 * dons has flashbacks to rml
07:50:04 <dylan> I don't see any resemblance to my toy language in RML
07:50:57 <nealc> good hacking day!
07:51:48 <SamB> dylan: well, notice the "let" and "fun" keywords?
07:52:33 <emertens> I was looking at some of the Clean code on the "shootout" site. It seem almost identical to Haskell code. Has anyone used it enough to elaborate on a few of the major differences between it and Haskell?
07:53:10 <SamB> well, the IO scheme is different. IIRC they use something called uniquenes types?
07:53:28 <SamB> @spell uniquenes
07:53:28 <emertens> yeah, I saw something about those
07:53:29 <lambdabot> uniqueness unicorns unquietness enqueues unguents
07:53:32 <SamB> heh
07:53:34 <SamB> unicorns
07:53:44 <norpan> we use unicorsns for IO!
07:53:46 <genneth> "unguents"
07:53:47 <genneth> ?
07:53:48 <norpan> unicorns
07:53:49 * edwinb decides to implement a language with unguent types
07:54:05 <SamB> @web1913 unguents
07:54:06 <lambdabot> No match for "unguents".
07:54:16 <SamB> @wn unguents
07:54:17 <lambdabot> No match for "unguents".
07:54:19 <emertens> @help web1913
07:54:20 <lambdabot> I perform dictionary lookups via the following 13 commands:
07:54:20 <lambdabot>  @all-dicts .. Query all databases on dict.org
07:54:20 <lambdabot>  @devils ..... The Devil's Dictionary
07:54:20 <lambdabot>  @easton ..... Easton's 1897 Bible Dictionary
07:54:20 <lambdabot>  @elements ... Elements database
07:54:22 <lambdabot> [9 @more lines]
07:54:25 <edwinb> that'd be types that automatically fix your errors or something
07:54:26 <norpan> "An unguent is stiffer than a liniment, but softer than a cerate."
07:54:32 <emertens> @more
07:54:32 <lambdabot>  @foldoc ..... The Free On-line Dictionary of Computing
07:54:33 <lambdabot>  @gazetteer .. U.S. Gazetteer (1990)
07:54:33 <lambdabot>  @hitchcock .. Hitchcock's Bible Names Dictionary (late 1800's)
07:54:33 <lambdabot>  @jargon ..... Jargon File
07:54:33 <lambdabot>  @lojban ..... Search lojban.org
07:54:34 <lambdabot> [4 @more lines]
07:54:37 <emertens> @more
07:54:38 <lambdabot>  @vera ....... V.E.R.A.: Virtual Entity of Relevant Acronyms
07:54:40 <lambdabot>  @web1913 .... Webster's Revised Unabridged Dictionary (1913)
07:54:42 <lambdabot>  @wn ......... WordNet (r) 1.7
07:54:43 <SamB> @all-dicts unguents
07:54:44 <lambdabot>  @world02 .... CIA World Factbook 2002
07:54:48 <lambdabot> No match for "unguents".
07:54:56 <norpan> @all-dicts unguent
07:54:57 <lambdabot> *** "Unguent" gcide "The Collaborative International Dictionary of English v.0.48"
07:54:57 <lambdabot> Unguent \Un"guent\ (?; 277), n. [L. unguentum, from unguere,
07:54:57 <lambdabot>   ungere, to anoint: cf. F. onguent. See {Ointment}, and cf.
07:54:57 <lambdabot>   {Unction}, {Unctuous}.]
07:54:58 <lambdabot>   A lubricant or salve for sores, burns, or the like; an
07:55:01 <lambdabot> [25 @more lines]
07:55:04 <norpan> there you go
07:56:27 <dons> emertens: yeah, no monads. they have uniqueness types. they seem to have better low level io, and persistence. we have infinite reflective towers of type theory
07:56:44 <dons> and lots more papers/code written in haskell
07:56:56 <norpan> uniqueness types are cool
07:56:59 <dons> and haskell's always been open source
07:57:01 <norpan> monads are cool too
07:57:36 <dons> monads _are_ cool
07:57:39 <genneth> i'm wondering why they're faster than us...
07:57:39 <dons> ?karma+ monads
07:57:40 <lambdabot> monads's karma raised to 1.
07:57:50 <dons> genneth: they have a Data.ByteString library
07:57:54 <genneth> ah
07:57:58 <musasabi> Uniquenes types an make things complex.
07:58:03 <musasabi> +s
07:58:24 <musasabi> combining them with HOFs and laziness can be nontrivial
07:58:25 <genneth> i've not really come across them; the only time i've seen them is in mercury
07:58:39 <dons> and they've had bang patterns and the like for ages
07:58:47 <genneth> but that's got a much different underlying concept
07:59:17 <roconnor> @karma+ pwadler
07:59:18 <lambdabot> pwadler's karma raised to 1.
07:59:23 * dons =<< sleep
08:00:17 <musasabi> http://www.cs.ru.nl/~clean/CleanExtra/report20/chapter9/index.html has quite nice description of the Clean uniqueness types.
08:00:21 <lambdabot> Title: Clean Language Report 2.0/chapter 9
08:01:10 <roconnor> @karma+ emoggi
08:01:10 <lambdabot> emoggi's karma raised to 1.
08:01:42 <nealc> emertens, karma is good?
08:01:46 <cods> Hi. I remember reading a webpage about monad explained with Python code some months ago. I'm unable to find it again. (It was not the ASPN page.) Does anyone knows what web page it is ?
08:01:59 <nealc> emertens, is karma good?
08:02:09 <vegai> somebody mentioned a web framework on Haskell once (a 'haskell-on-rails', if you pardon the horror). Anything come out of that?
08:02:18 <norpan> karma is by definition good
08:02:32 <norpan> unless it'
08:02:35 <norpan> s bad karma
08:03:18 <nealc> norpan, is higher karma number good?
08:03:19 <roconnor> @what wash
08:03:20 <lambdabot> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
08:03:27 <norpan> nealc: undoubtedly
08:03:37 <nealc> @karma+ emertens
08:03:38 <lambdabot> emertens's karma raised to 2.
08:03:39 <roconnor>  http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
08:03:44 <lambdabot> Title: Web Authoring System Haskell (WASH)
08:04:02 <musasabi> vegai: there are at least WASH, HAppS, Hope, HSP, and a few others.
08:04:16 <emertens> nealc: I'm back. Karma is good (when it's positive)
08:04:23 <genneth> go go HAppS!
08:04:24 <emertens> nealc: so thanks for the boost :)
08:04:35 <vegai> ah, lots of options
08:05:46 <vegai> any anecdotes?
08:06:37 <jgrimes_> vegai: I've enjoyed using Hope, but I haven't used any of the others, either.
08:06:49 <norpan> i like that clean has a graph rewriting semantics
08:07:04 <musasabi> WASH is bad if you have lots of state, HAppS is bad if you have SQL (not yet integrated), haven't used enough of Hope and HSP to comment enough of them.
08:08:50 <musasabi> A simple "keep this code free but allow linking with anything" licence would be nice for some Haskell projects (to get rid of LGPL problems).
08:08:51 <emertens> norpan: From my limited overview of Clean, graph rewriting was Clean's original purpose
08:09:36 <norpan> well, then it's no wonder it has such a semantics
08:09:36 * emertens prefers the BSD license
08:10:21 <musasabi> emertens: BSD3 is nice for most code, but some people seem to want to keep code free and something with less problems than LGPL would be nice for that.
08:10:42 <norpan> endless license struggles
08:11:11 <norpan> haskell has at least three usable compilers, while clean has only one, right?
08:11:30 <musasabi> since LGPL + GHC with -O2 = no real solution.
08:11:45 <emertens> musasabi: why is that?
08:12:41 <dons> norpan: ghc, nhc, yhc, jhc, uhc, hbc, hugs, gofer, ...
08:12:55 <emertens> so yes, *at least* 3
08:13:06 <vegai> usable?
08:13:58 <musasabi> emertens: cross module inlining of things.
08:14:05 <norpan> hugs is not a compiler, and gofer is that really haskell?
08:14:12 <dons> well, take isUseable $ enumFromTo minBound maxBound :: HaskellCompiler
08:14:24 <dons> gofer yeah. you can use it as hugs for most of a haskell course
08:14:44 <norpan> but not a compiler still
08:15:09 <dons> drop (not.compiler) . take useable $ enumFromTo minBound maxBound :: HaskellCompiler
08:15:18 <emertens> dropWhile?
08:15:20 <dons> == [ghc, nhc, yhc, jhc, hbc] ?
08:15:23 <dons> dropWhile.
08:15:36 <norpan> when i started cs in 1995, we used gofer and had a dutch teacher called johan jeuring and he said "gofer" in the most amusing way
08:15:36 <emertens> that command was giving me type errors in GHC ;)
08:15:42 <cods> Is there a PDF version available for the Nomaware "All About Monads" tutorial ? (Or anything printer-friendly rather than a set of HTML pages.)
08:16:01 <fasta> Can this be done neater?  graphdata2edgelist graphdata = [(x,var,())  | (var,(_,preds))<-graphdata,x<-preds]
08:16:02 <dons> norpan: you mean _the_ johan jeuring. he's still around :)
08:16:08 <norpan> i mean the
08:16:22 <norpan> and i know he is around, but not around here
08:16:36 <dons> oh, i meant, he's around here.
08:16:41 <dons> at least, the lists
08:16:50 <norpan> sure
08:16:56 <SamB> um, wouldn't you want "filter compiler" rather than "drop (not.compiler)"?
08:17:05 <norpan> but you don't get to hear his "gofer" pronunciation on the lists :)
08:17:19 <vegai> HAppS seems to have some sort of internal database thingie
08:17:28 <emertens> dons: tough crowd, eh?
08:17:37 <vegai> "(Experimental) Table and Index - Do relational operations safely on in memory Haskell Data.Set(s) rather than dealing with an external SQL relational database. Define custom indices for your Haskell datatypes (e.g. geographic/geometric types). Use in combination with MACID for a robust relational DBMS customized for your application."
08:17:37 <norpan> > drop (>3) [5,4,3,2,1,2,3,4,5]
08:17:38 <lambdabot>    Expecting a function type, but found `Int'
08:17:38 <lambdabot>    Expected type: Int
08:17:38 <lambdabot>   ...
08:17:51 <dons> > enumFromTo minBound maxBound :: [Ordering] -- btw, a nice trick for getting all values inhabiting a type
08:17:53 <lambdabot>  [LT,EQ,GT]
08:18:01 <dons> > enumFromTo minBound maxBound :: [Bool] -- btw, a nice trick for getting all values inhabiting a type
08:18:02 <lambdabot>  [False,True]
08:18:21 <dons> > enumFromTo minBound maxBound :: [Data.Word.Word8]
08:18:22 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
08:18:31 <dons> emertens: heh
08:18:43 <norpan> [minBound..maxBound] is what I use, but it's the same
08:18:57 <dons> yeah, oops. maybe i should just remember the sugar some times :)
08:19:21 <norpan> goooofrrrrrrr
08:19:24 <SamB> @type (&&&)
08:19:26 <lambdabot> forall (a :: * -> * -> *) c' c b. (Arrow a) => a b c -> a b c' -> a b (c, c')
08:19:27 <dons> i've been trying to reduce my sugar intake
08:19:40 <SamB> @type curry
08:19:42 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
08:20:40 <xerox> norpan: dropWhile (>3) ...
08:21:09 <xerox> dropUntil = dropWhile . not
08:21:30 <SamB> @type \x y -> uncurry (&&) <<< (x &&& y)
08:21:31 <musasabi> vegai: yes. But most of HAppS code does not use the rdbms thing. (It is from before I started to hack on HAppS - haven't touched it much)
08:21:32 <lambdabot> forall b. (b -> Bool) -> (b -> Bool) -> b -> Bool
08:21:45 <norpan> xerox: i know, but somewone asked why not drop instead of filter
08:21:45 <dons> that is a nice function SamB
08:21:47 * SamB thinks there ought to be an infix op that does that
08:22:02 <xerox> Oh, nevermind then
08:22:14 <dons> can you use it in a sentence?
08:22:24 <xerox> both ?
08:22:53 <SamB> well seeing as I don't know what to call it...
08:23:38 <dons> i.e. "Today I went to the shop and bought a loaf of bread, a container of milk and \x y -> uncurry (&&) <<< (x &&& y)"
08:23:54 <SamB> dons: it needs a name or it is not useful
08:24:04 <xerox> > let both = ((uncurry (&&) <<<) .) . (&&&) in both (>2) even 10
08:24:05 <lambdabot>  True
08:24:09 <dons> it needs a name. naming concepts is good
08:24:29 <SamB> hmm, both is a nice name
08:25:30 <norpan> isn't that just liftM2 (&&)
08:25:35 <SamB> hmm, true
08:25:35 <dons> "Today I went to the shop and bought a loaf of bread, a container of milk and (both (<10) (>2) [bread,milk]) dollars"
08:25:41 <SamB> @type liftM2 (&&)
08:25:42 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
08:25:58 <SamB> @type liftM2 (&&) :: (b -> Bool) -> (b -> Bool) -> b -> Bool
08:25:59 <lambdabot> (b -> Bool) -> (b -> Bool) -> b -> Bool :: forall b. (b -> Bool) -> (b -> Bool) -> b -> Bool
08:26:25 <SamB> dons: why does it do that?
08:26:26 <dons> ?karma+ (->a)
08:26:27 <lambdabot> (->a)'s karma raised to 1.
08:26:38 <norpan> hehe
08:26:42 <dons> SamB: the gods of the regular expressions decide it to be so
08:27:14 <norpan> (->a) is a good monad
08:27:22 <SamB> how about you bracket the munging with reverses?
08:27:46 <SamB> or does it sometimes mention kinds too?
08:28:19 <SamB> oh, yeah, it does
08:28:20 <SamB> ick.
08:28:25 <SamB> thats no good then
08:28:45 <SamB> there should be a way to suppress the echoing of the expression
08:28:48 * dons both (falls asleep) (turnsOff lights)
08:28:55 <vegai> musasabi: what do they usually use for data persistance, then?
08:29:00 <SamB> you make it look so easy
08:30:51 <kpreid> > typeOf (liftM2 (&&) :: (b -> Bool) -> (b -> Bool) -> b -> Bool)
08:30:52 <lambdabot>  Add a type signature
08:30:53 <roconnor> norpan: (->a) is a monad?
08:31:10 <roconnor> do you mean (->)a
08:31:24 <SamB> @type typeOf
08:31:28 <musasabi> vegai: typeclass for serialization and HAppS just takes care of keeping the state safe.
08:31:34 <lambdabot> forall a. (Typeable a) => a -> TypeRep
08:31:39 <kpreid> > Data.Typeable.typeOf (liftM2 (&&) :: (b -> Bool) -> (b -> Bool) -> b -> Bool)
08:31:42 <kpreid> ok, so much for that
08:31:43 <lambdabot>  Add a type signature
08:31:50 <norpan> roconnor: well, yea
08:31:52 <kpreid> SamB: typeOf isn't useful because it doesn't do polymorphic types, which I forgot
08:31:52 <norpan> that
08:32:12 <jgrimes_> vegai: Hope uses haskelldb (which provides access to various DBs, including flat file) for data persistance
08:32:26 <musasabi> vegai: works even with randomly killing it in the midle.
08:32:32 <norpan> i mean (a->)
08:32:53 <norpan> or (->)a
08:33:05 <roconnor> @karma (a->)
08:33:06 <lambdabot> (a->) has a karma of 0
08:33:10 <roconnor> @karma (->)a
08:33:10 <lambdabot> (->)a has a karma of 0
08:33:26 <norpan> i've had too little coffee today i think
08:33:31 <norpan> gofrrrrrrrrr
08:33:51 <musasabi> jgrimes_: how does one guarantee transactional semantics in Hope with SQL databases? (it seems non-trivial as one needs 2-phase commit)
08:35:18 <vegai> jgrimes_, musasabi: both nice.
08:37:01 <vegai> I think I like HAppS's approach more.
08:37:50 <jgrimes_> musasabi: I'm not sure exactly. I haven't looked at much of the database interaction with Hope other than what is automated by defining tables in a module.
08:38:18 <vegai> Hmm, is pass.net using the RDBM method?
08:39:14 <vegai> I see instance Serialize State where but also import HAppS.DBMS.RSMap as Map hiding(split)
08:40:33 <musasabi> no RDBM method
08:41:06 <musasabi> RSMap = Map with more sane Show/Read
08:42:00 <musasabi> one can do binary formats too with the Serialize class, but I don't think any of the public code has good examples of that.
08:42:52 <vegai> Ohh. Ok.
08:43:42 <vegai> Well, it's fun that there are at least some important things in the world nobody has written about yet...
08:55:38 <wferi> Hi! Is it possible to define a record updater function, like eg.: updateRec field rec val = rec { field = val } or similar?
08:57:11 <fasta> wferi: no
08:57:27 <fasta> wferi: In TH, you can I think.
08:57:36 <fasta> wferi: Not in Haskell 98
08:58:01 <wferi> do the new record proposals contain such a feature?
08:58:15 <fasta> I don't know
08:59:00 <Pupeno> is the new haskell going to have a binary io standard ?
08:59:44 <wferi> And can you propose a neat way to attach some static data (like human names of the fields) to a record?
09:00:38 <SamB> wferi: heh
09:01:19 <SamB> wferi: you can't even look at the fields without knowing what they are...
09:01:20 <wferi> Or do I have to accompany my record with a series of definitions with similar names to the fields?
09:01:20 <fasta> Why don't you send these questions to the haskell prime list?
09:01:50 <wferi> SamB: what do you mean?
09:02:10 <wferi> fasta: it's a sidetrack only, i'm using haskell 98 now.
09:02:52 <wferi> SamB: updateRec :: (Options -> String) -> Options -> String -> Options, I guess.
09:03:45 <SamB> wferi: well, I guess I mean you can't just loop over the fields or anything like that...
09:04:34 <binary42> ls
09:04:40 <wferi> surely not, but I have the accessor functions, and the above definition, taken as a macro substitution, works.
09:04:43 <binary42> err... alt-tab
09:05:10 <nealc> binary42, :)
09:06:00 <binary42> waiting for some haskell code to compile ... thought I would drop in. Then it died and I ls'ed to see if I had cleaned first.
09:06:12 <roconnor> why is recursive do not going to be in haskell prime?
09:06:38 <norpan> recursive do?
09:06:57 <fasta> mdo
09:07:07 <fasta> mdo has some disadvantages
09:07:13 <musasabi> roconnor: probably because there are more important issues to be solved. (and a timetable?)
09:07:21 <norpan> using mfix?
09:07:27 <fasta> For one, there is only a "simple" implementation.
09:07:33 <roconnor> I thought mdo was solved.
09:07:52 <fasta> A more complex implementation would incorporate backwards compatibility with do
09:08:03 <roconnor> oh
09:08:12 <roconnor> so all do's would be recursive?
09:08:14 <fasta> Well, that's the situation as I read in a paper about mdo.
09:08:39 <roconnor> hmmm
09:08:39 <fasta> It could be that someone already implemented it, but I don't think so.
09:08:44 <norpan> and if the monad used is a MonadFix it would be recursive?
09:08:57 <fasta> yes
09:09:13 <fasta> Just like let and letrec
09:09:20 <fasta> let and letrec are the same in Haskell
09:09:30 <fasta> The idea for do and mdo was to do the same.
09:09:41 <fasta> Only, at this point it's _not_ the same.
09:09:47 <norpan> but there is a difference, do is not recursive
09:09:55 <norpan> for a good reason
09:10:06 <roconnor> good reason?
09:10:20 <norpan> the reason is that you can't make it recursive :)
09:10:28 <norpan> unless you have a special monad...
09:10:32 <roconnor> sure
09:10:52 <roconnor> make it an error to recursively use values if it isn't monadfix.
09:11:05 <norpan> that would certainly break compatibility
09:11:36 <roconnor> no, forbiding variable shadowing breaks compatibility
09:11:37 <fasta> I don't really like the compatibility argument.
09:12:11 <fasta> I don't really see why it would be impossible to build a source to source transformation for every incompatible change.
09:12:39 <fasta> If you just have a Haskell 98 -> Haskell Prime converter, there's no problem.
09:13:00 <norpan> we like compatibility
09:13:07 <fasta> If it's too hard to implement something like that, then maybe Haskell is not the right language in the first place.
09:13:14 <roconnor> fasta conversion would have to invent variables names
09:13:38 <roconnor> variable names that humans won't like
09:14:28 <fasta> roconnor: I doubt that. Examples?
09:14:56 <roconnor> do { i <- getChar; putChar i; i <- getChar; putChar i}
09:15:10 <ndm> fasta: i often do that
09:15:11 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
09:15:39 <ndm> @seen xerox
09:15:39 <lambdabot> xerox is in #haskell.it, #perl6, #haskell-overflow, #haskell-blah and #haskell. I last heard xerox speak 51 minutes and 36 seconds ago.
09:15:56 <fasta> ndm: What do you do often?
09:15:58 <ndm> @tell xerox, yeah, haskell has issues with - and > because of console interfactions
09:15:58 <lambdabot> Consider it noted.
09:16:10 <ndm> fasta: redefining variables in a monad
09:16:27 <norpan> yes
09:16:41 <norpan> disallowing shadowing bindings is a big change
09:16:57 <fasta> What makes you think that I am against shadowing bindings?
09:17:21 <norpan> because how will you choose between shadowing and recursion?
09:19:02 <fasta> norpan: you only get recursion when you use a variable that hasn't been defined yet.
09:19:28 <norpan> really?
09:19:38 <norpan> how do you do mutual recursion then?
09:19:42 <fasta> norpan: recursive binding we are talking about
09:20:48 <edwinb> can I persuade a profile from ghc to summarise how many times a function was called? All I'm getting is %time...
09:21:02 <fasta> norpan: Why would mutual recursion be a problem?
09:21:36 <norpan> if i say let a = 1 in do x <- a; a <- 1; return a, would the a in x <- a refer to the a bound with let or to the a bound with recursion?
09:23:18 <roconnor> norpan: um, a always refers to the inner most binding.
09:23:32 <fasta> Normal scoping rule.
09:23:51 <roconnor> do { let a = l; x <- a; a <- l; return a } is a little better
09:23:52 <norpan> but which one is the innermost after desugaring?
09:24:06 <norpan> ok, maybe better
09:25:11 <norpan> so, if the monad is in MonadFix, then a will refer to the recursive binding, but if it is not, then it will refer to the let-binding?
09:27:03 <norpan> and if i do { a <- 1; a <- a + 1 } then will it fall back to non-recursive do even if my monad is in MonadFix?
09:27:20 <norpan> or will it be an error?
09:27:25 <int-e> that would be evil. generalizing or specializing a type could affect semantics.
09:28:04 <roconnor> norpan: well, obviously reusing variable names would become disallowed.
09:28:06 <norpan> int-e: but that's a given if we want do to have different desugarings depending on if the monad is in MonadFix
09:28:19 <int-e> norpan: yes. I wouldn't want that.
09:28:38 <norpan> well, that was the suggestion if i'm not mistaken
09:29:00 <roconnor> My point was to translat H98 code would require renaming the later occurences of a variable.
09:29:26 <roconnor> and that renaming those variables would make users unhappy.
09:29:32 <norpan> sure
09:29:58 <danb> @pl \a b -> a + f b
09:29:59 <lambdabot> (. f) . (+)
09:30:00 <roconnor> ... although there would still be module comptability.
09:30:03 <norpan> introducing a keyword mdo is maybe better
09:30:15 * int-e agrees.
09:30:18 <roconnor> for haskell prime, I think mdo would be better, or recdo
09:30:22 <fasta> roconnor: In this case it would be possible to do it in a backwards compatible way.
09:30:46 <norpan> of course, we will have problems with people using mdo as a variable name
09:30:50 <fasta> I would say that an identifier that's bound later than it's used, would introduce recursive bindings, and thus translate ultimately to some mfix expression.
09:30:54 <roconnor> but for haskell2, I would make every do a potential mdo, and disallow variable shadowing.
09:31:21 <norpan> roconnor: even for lambda expressions?
09:31:38 <roconnor> norpan: variable shadowing within a scope.
09:31:55 <roconnor> > \(x,x) ->x
09:31:57 <lambdabot>    Conflicting definitions for `x'
09:31:57 <lambdabot>   In a lambda abstraction
09:32:11 <roconnor> already disallowed for lambda expressions.
09:32:12 <norpan> i mean \x -> (\x -> x) x
09:32:25 <roconnor> x refers to the inner most binding.
09:32:33 <norpan> i know
09:32:38 <norpan> but would you disallow it too?
09:32:39 <roconnor> do { a<- foo; do { a<-bar ; return a} }
09:32:50 <roconnor> would return the inner most a.
09:32:56 <norpan> look
09:33:42 <fasta> OTOH, I think it's a very slippery slope to just introduce new syntax everytime some "need" arises.
09:33:45 <roconnor> I would only disallow variable shadowing for variables in the same do block (for haskell2)
09:33:47 <norpan> do { a <- x; a <- y; z } translates to x >>= \a -> y >>= \a -> z that is why i'm asking
09:34:12 <roconnor> norpan: desurgaring can do whatever alpha conversion it feels like.
09:34:40 <roconnor> yes, that's how it is translated.
09:34:57 <roconnor> however, in my future haskell2, the first code would be disallowed.
09:35:07 <roconnor> while the second would be fine.
09:35:09 <norpan> and it's very convenient to reuse variable names in do
09:35:21 <roconnor> you can use nested to blocks.
09:35:31 <roconnor> do blocks
09:35:32 <norpan> ...which are not very convenient
09:36:07 <int-e> @instances Control.Monad.Fix.MonadFix
09:36:08 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
09:36:21 <int-e> @instances-importing Control.Monad.Fix MonadFix
09:36:22 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
09:36:40 <norpan> it would affect a lot of code no doubt
09:36:58 <monochrom> May I ask what is the subject?
09:37:15 <norpan> making "do" be "mdo"
09:37:45 <roconnor> norpan: or one can use ' to mark successive variables.
09:38:05 <norpan> roconnor: yes, one can, but then one will make a mistake and use the wrong number of '
09:38:07 <roconnor> I mean, I would love to reuse variable names in where blocks to, but that's not the way it works.
09:38:20 <norpan> but it's the way it works in do blocks
09:38:26 <norpan> because do is sequential
09:38:41 <roconnor> do won't be as sequential as it used to be.
09:38:58 <roconnor> it won't be so bad.
09:39:29 <roconnor> we often use where clauses as if they were sequential, but still have to use a'.
09:39:39 <norpan> we do?
09:39:43 <roconnor> sure
09:39:46 <norpan> i never use where clauses :)
09:40:05 <roconnor> norpan, you're crazy :)
09:40:09 <monochrom> where { a = 1; a = a+1; a = a+1 }   -- taboo
09:40:15 <int-e> > let a = 42 in let b = a+3 in let a = b+10 in a
09:40:17 <lambdabot>  55
09:40:44 <norpan> ok, i sometimes use where clauses
09:40:50 <norpan> but never in that sequential way
09:40:53 <monochrom> do { a <- return 1; a <- return (a+1); a <- return (a+1); }   -- fooey!
09:41:01 <roconnor> even outside a where clause
09:41:02 <norpan> but i use do blocks like that all the time
09:41:10 <roconnor> lines            :: String -> [String]
09:41:10 <roconnor> lines ""         =  []
09:41:11 <roconnor> lines s          =  let (l, s') = break (== '\n') s
09:41:11 <roconnor>                       in  l : case s' of
09:41:11 <roconnor>                                 []      -> []
09:41:11 <roconnor>                                 (_:s'') -> lines s''
09:41:19 <roconnor> lots of ''s
09:41:42 <norpan> although the s'' is not needed
09:41:49 <roconnor> ah good point
09:41:50 <emertens> using the same variable over and over is dirty
09:42:15 <norpan> emertens: except it's not the same
09:42:30 <norpan> just has the same name :)
09:42:37 <emertens> and it's dirty
09:42:40 <emertens> i agre
09:42:40 <emertens> e
09:42:50 <emertens> because it's not the same
09:42:53 <emertens> and has the same name
09:42:59 <norpan> yeah, you can never use (x:xs) again, because i used it in my "head" definition
09:43:16 <emertens> in the same scope, not globally
09:43:37 <norpan> aha, it's dirty if it's in the same scope
09:43:41 <norpan> but not otherwise
09:43:59 <emertens> that goes without saying
09:44:14 <norpan> well, i don't see why it's dirty
09:44:33 <emertens> it makes each variable's purpose less clear
09:44:41 <norpan> do { a <- x; a <- f a; return a } is perfectly clear to me
09:44:53 <emertens> right, in that simple onliner, it's clear
09:45:14 <emertens> but you know what'm more clear in that one-liner is : x >>= f
09:45:31 <norpan> it's the programmers responsability to be clear, and that's not accomplished by arbitrary rules
09:46:40 <norpan> i think even allowing pattern match failures in do notation is a bit fishy
09:46:51 <emertens> norpan: you aren't responsible for any major haskell libraries, are you?
09:47:08 <norpan> imagine how fishy recursive bindings in do is
09:47:17 <norpan> emertens: i don't think so
09:47:27 <emertens> good, then it doesn't matter to me how you use variables :)
09:47:35 <norpan> but i can easily point to places where these libraries use shadowing
09:47:57 <norpan> or at least could, maybe somebody has cleaned them up
09:48:12 <emertens> either way, no sense in trying to convince you one way of the other
09:48:19 <roconnor> norpan, isn't let a = 1; a= a+1 in a clear?
09:48:29 <roconnor> obviously it is 2 right?
09:48:41 <norpan> roconnor: obviously it's a double definition of a
09:48:47 <norpan> let is not sequential, do is
09:48:58 <SamB> > let a = 1; a= a+1 in a
09:48:59 <lambdabot>    Conflicting definitions for `a'
09:48:59 <lambdabot>   In the binding group for: a, a
09:49:09 <emertens> obviously this is clearer:
09:49:10 <emertens> > 2
09:49:11 <roconnor> sure let is sequential I wrote one before the other.
09:49:12 <lambdabot>  2
09:49:14 <SamB> > let a = 1; a = 1 in a
09:49:15 <lambdabot>    Conflicting definitions for `a'
09:49:15 <lambdabot>   In the binding group for: a, a
09:49:17 <SamB> hmm
09:49:29 <norpan> the whole point with do is to do sequencing
09:49:47 <SamB> shouldn't it just say "Multiple definitions of `a'"?
09:49:48 <norpan> but i'd rather have let and letrec if that's what you mean
09:49:57 <roconnor> so why isn't mdo { a <- x; a <- f a; return a } clear
09:50:03 <roconnor> it is still sequenced.
09:50:22 <roconnor> the fact that it is sequenced doesn't make the variable bindings clear.
09:50:24 <norpan> because mdo is recursive binding by definition
09:50:42 <monochrom> Multiple definitions can be non-conflicting.  let f 0 = 0; f x = f (x-1) in ...   multiple, non-conflicting.  The problem is conflicting, not multplie.
09:50:53 <roconnor> why not split let into let and letrec?
09:51:00 <norpan> yes why not
09:51:06 <norpan> because it breaks compatibility
09:51:19 <SamB> > mdo { x <- "Hi! " ++ y; y <- "Hello! " ++ x; return x }
09:51:20 <lambdabot>  Parse error
09:51:20 <norpan> maybe letnonrec
09:51:23 <SamB> hmm
09:51:33 <roconnor> what would you prefer in haskell2, the not backwards compatable language?
09:51:35 <int-e> letseq
09:51:43 * int-e shrugs
09:51:46 <norpan> monochrom: let f 0 = 0 is a function binding, let f = 0 is a pattern binding
09:51:52 <norpan> but you know that of course
09:52:24 <norpan> roconnor: i would prefer haskell2 to be as backwards compatible as possible :)
09:52:27 <monochrom> Doesn't contradict multiplicity.
09:52:44 <roconnor> norpan: the whole point of haskell2 would be a fresh start, wouldn't it?
09:52:47 <SamB> monochrom: I don't think that counts as multiple definitions, though
09:52:50 <emertens> I would prefer Haskell2 to focus on finding the best solutions to problems and eschewing backwards compatibility
09:52:53 <roconnor> otherwise haskell2 is haskell'.
09:53:16 <roconnor> emertens: exactly
09:53:19 <norpan> then call it something else than haskell
09:53:33 <roconnor> haskell++
09:53:33 <SamB> except Haskell' will always be available as a name to stand for the next Haskell
09:53:52 <norpan> even c++ strives to be backwards compatible with c
09:53:55 <int-e> Personally, I don't think a nonrecursive let is needed.
09:54:03 <SamB> int-e: me either
09:54:05 <monochrom> let f x = 1; f x = 2; in ...   How about this?  :)
09:54:05 <SamB> it would be silly
09:54:13 <norpan> monochrom: that's allowed
09:54:16 <musasabi> do -> mdo is good for Haskell2
09:54:20 <roconnor> Howard
09:54:21 <musasabi> Bad for Haskell'
09:54:23 <emertens> haskell is supposed to be a language research vehicle, not bogged down like windows is
09:54:24 <monochrom> Yes!  Multiple, non-conflicting, allowed.
09:54:33 <SamB> > let f x = 1; f x = 2 in f ()
09:54:34 <lambdabot>    Warning: Pattern match(es) are overlapped
09:54:35 <lambdabot>        In the definition...
09:54:39 <norpan> monochrom: because it's a function binding, not a pattern binding
09:54:52 <SamB> that isn't multiple definitions though
09:54:58 <musasabi> emertens: true. And the language is evolving. Standardization should come behind.
09:55:00 <monochrom> Yes yes yes.  So, multiple, non-conflicting, allowed.
09:55:09 <SamB> > let f x = 1; foo = "bar"; f x = 2 in f ()
09:55:10 <lambdabot>    Conflicting definitions for `f'
09:55:11 <lambdabot>   In the binding group for: f, foo, f
09:55:17 <monochrom> I'm explaining why the error message doesn't say "multiple".
09:55:19 <SamB> see, I told you
09:55:30 <monochrom> Ha ok
09:55:37 <musasabi> Finding a nice way to MPTC+FD+AT+GADT into the standard is much more interesting
09:56:03 <roconnor> norpan: would you prefer let and letrec in Howard, the not Haskell language?
09:56:06 <monochrom> Oh actually, I didn't say "multple ==> non-conflicting".  I never said that.  Right?
09:56:25 <monochrom> I am just saying "not (multiple == conflicting)"
09:56:29 <norpan> roconnor: yes, i like letrec
09:56:40 <roconnor> :)
09:56:44 <monochrom> Sorry for applying logic.
09:56:45 <SamB> if "f x = 1; f x = 2" counted as two definitions, they would be conflicting
09:56:46 <roconnor> okay
09:56:49 <SamB> but they don't
09:57:02 <SamB> they are just two parts of the same one
09:57:19 <norpan> i never do function definitions that way anymore
09:57:28 <norpan> i always do f x | case x of ->
09:57:46 <monochrom> You are ripe for OCaml.
09:57:53 <SamB> any two definitions of the same thing in the same binding group are conflicting
09:58:17 <norpan> i've done the "change function name on just the first definition" thing to many times
09:58:34 <norpan> also, the indentation shows me clearly where the next function def. starts
09:59:09 <monochrom> OK SamB I admit you're right :)
09:59:46 <norpan> err, i mean f x = case x of -> of course
10:00:04 <emertens> peeling an orange with a knife makes such a sweet smell _-D
10:00:10 <monochrom> Yeah, I was wondering whether you had "-fglasgow-exts" by default.
10:00:20 <norpan> i do
10:00:42 <norpan> i like pattern guards
10:00:48 <roconnor> wow
10:00:58 <roconnor> I was about to say, norpan must hate pattern guards.
10:01:07 <norpan> well you are wrong
10:01:16 <norpan> i like them
10:01:18 <roconnor> I don't get you :)
10:01:40 <norpan> i don't know much about programming, but i know what i like :)
10:02:05 <roconnor> don't you need patterns to use pattern guards?
10:02:18 <norpan> sure
10:02:31 <monochrom> f x | case x of x -> x   heheheh
10:02:36 <roconnor> wait, can you get away with one function name with pattern gaurds?
10:02:37 <monochrom> (talking about many x's)
10:02:38 <norpan> you get's lots of patterns when you do case x of
10:02:45 <norpan> roconnor: yes
10:02:47 <roconnor> ah
10:02:57 <roconnor> norpan: you're still crazy :P
10:03:11 <norpan> one function to define - one function name
10:03:11 <int-e> . o O ( f x | x' <- x = case x' of x -> x )
10:03:23 <roconnor> *l*
10:03:30 <norpan> let f x :: a -> a = case x of ...
10:03:48 <norpan> then you can define anything
10:04:23 * roconnor can't wait for epigram2
10:04:45 <norpan> i find it easier to follow than to have to read multiple function definition statements and decide which one is the one used
10:05:00 <int-e> I don't understand that
10:05:18 <norpan> the patterns are first on the line so they are more visible
10:05:28 <int-e> and I don't want to know what your case looks like when more than one argument is involved in pattern matching
10:05:49 <norpan> it depends
10:06:03 <norpan> most of the time the case is only on on of the arguments
10:06:10 <norpan> or at most two, in that case i use a tuple
10:07:22 <norpan> also, although i don't use it often, using that style makes it easier to write "where" clauses
10:07:59 <norpan> and let clauses
10:08:10 <norpan> if a binding is the same for more than one pattern match
10:08:55 <norpan> let's say i have two arguments and for two different pattern matches of the first argument i want to use the same function of the second
10:09:10 <norpan> easily done with let or where if i only have one function definition line
10:09:52 <zarvok> norpan: that's why I love the "local in end" syntax in SML
10:09:56 <int-e> I'd use  f x y = f' x y where f' ...; auxillary function   then.
10:10:43 <norpan> int-e: then you can't use x and y as formals for f' because that is dirty, i've heard
10:11:04 <norpan> i suppose you don't need them at all in that case
10:11:10 <int-e> But I have opposite preferences - I dislike case, and often avoid it by introducing another function.
10:11:40 <norpan> i dislike arbitrary introduced functions :)
10:12:08 <int-e> norpan: pretend they are coordinates ;)
10:12:32 <norpan> http://norpan.org/fluxx/Fluxx.hs
10:13:08 <dylan> @hoogle [a] -> [a] -> [a]
10:13:09 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
10:13:09 <lambdabot> List.intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
10:13:09 <lambdabot> List.unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
10:13:20 <norpan> just a simple example
10:13:49 <norpan> do+case used heavily
10:14:18 <norpan> you probably find it appaling
10:14:29 <norpan> appalling
10:14:35 * lispy is a huge fan of 'where'
10:14:48 <lispy> name those lambdas!
10:14:49 <roconnor> norpan: It looks surprisingly nice.
10:15:02 <emertens> norpan: one of your case statements says _ -> something
10:15:06 <norpan> note, no use of "where" except in module Fluxx where :)
10:15:06 <emertens> do you prefer that to otherwise?
10:15:26 <norpan> it's not the same as otherwise
10:15:36 <norpan> otherwise is guard, _ is pattern match
10:15:47 <roconnor> > otherwise == True
10:15:49 <lambdabot>  True
10:15:56 <roconnor> :)
10:16:01 <int-e> > Prelude.otherwise
10:16:02 <lambdabot>  True
10:16:47 <lispy> i like a lot of it, but doTurn and a few others are too huge!
10:17:07 <lispy> how do you keep it all in your head when you read their code?
10:17:17 <norpan> you don't
10:17:31 <int-e> Yes, and there are too few functions with meaningful names. I don't want to read the code in detail to find out what's going on.
10:17:31 <lispy> _ -> something is like otherwise for patterns
10:18:04 <norpan> well, you could use otherwise -> something, but that would give a pattern binding unused warning :)
10:18:29 <int-e>     [player] -> throwError (PlayerWon player)   feels dirty
10:18:39 <norpan> dirty?
10:19:19 <lispy> norpan: i don't you otherwise -> somethnig makes sense unless you're pattern matching on a bool
10:19:33 <int-e> ouch, otherwise ->  is dangerous
10:19:38 <norpan> in that case otherwise is just another binding name
10:19:46 <norpan> shadowing the prelude definition
10:19:50 <lispy> oh
10:19:53 <lispy> got ya
10:20:22 <norpan> it was some time ago i wrote that fluxx code though
10:20:45 <norpan> but throwing error out of my monad is not dirty
10:20:52 <norpan> it's used for terminal conditions
10:21:27 <int-e> > let f x = case x of True -> 12; otherwise -> let g x | otherwise = 42; g x = 23 in g x in (f True, f False)
10:21:28 <lambdabot>  (12,23)
10:22:11 <roconnor> int-e: that will be a nice technique for the obsucated haskell contest
10:23:02 <emertens> norpan: what settings does vim: sts=2 et
10:23:03 <emertens> apply?
10:23:20 <norpan> tab stop 2, expand tab to spaces
10:23:29 <emertens> ah, cool
10:23:37 <norpan> nowadays i use 3
10:23:52 <emertens> when you aren't expanding tabs, the tabstop needs to be 8, right?
10:24:04 <norpan> yes, but i am expanding :)
10:24:13 <emertens> I was asking in general
10:24:18 <norpan> yes, in haskell source
10:24:27 <norpan> for the layout rule
10:24:31 <emertens> right
10:24:31 <SamB> what did they do in Python?
10:24:43 <SamB> ban tabs or decree that they would be 8 spaces wide?
10:25:29 <Twanvl> they are 8 spaces in Python as well
10:26:49 <norpan> well, it's nice that haskell caters for different styles of programming
10:26:59 <paj> Shae Erisson (aka shapr) is stuck at London City Airport without cash.  Does anyone know anyone in that area who could get some money to him?
10:27:14 <norpan> yikes
10:27:41 <SamB> @map
10:27:41 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
10:28:07 <musasabi> ick
10:28:21 <lispy> if there was anyway i could help i would...but i'm in the US
10:31:55 <franka> Philippa_, perhaps?
10:32:18 <norpan> hmmmm, i can't remember my user name on that wiki
10:32:22 <franka> I think she's in London.
10:32:38 <edwardk> paj: how'd he go and find himself in that predicament?
10:32:38 <norpan> oh, i got it
10:32:52 <paj> She's already on #anglohaskell and working on the problem
10:32:57 <edwardk> ah
10:33:02 <edwardk> wish him luck
10:33:03 <paj> Something to do with paying a bill he hadn't meant to.
10:33:25 <paj> Current plan: Heffalump sends money by Western Union.
10:34:46 <lispy> @karma shapr
10:34:47 <lambdabot> shapr has a karma of 20
10:34:55 <lispy> good thing he has a karma of 20 here :)
10:35:06 <lispy> @karma+ Heffalump
10:35:06 <lambdabot> Heffalump's karma raised to 4.
10:35:11 <lispy> @karma+ paj
10:35:12 <lambdabot> paj's karma raised to 1.
10:35:22 <lispy> @karam+ Philippa_
10:35:22 <lambdabot> Maybe you meant: karma karma+
10:35:30 <lispy> @karma+ Philippa_
10:35:30 <lambdabot> Philippa_'s karma raised to 2.
10:35:57 <roconnor> maybe Microsoft can bail him out.
10:36:35 <roconnor> maybe Sweeden should have adopted the euro ... oh nevermind.
10:37:28 <lispy> heh
10:38:21 * roconnor starts his Monad Reader article.
10:39:33 <norpan> had we adopted the euro, we would have even less money, one SEK is like 0.1 euro
10:40:20 <roconnor> but shapr has no money ;)
10:40:24 <norpan> there were one orientation left for gothenburg in the haskell map
10:42:35 <roconnor> which is better, swords or sleeping kittens?
10:43:21 <musasabi> sleeping kittens of course?
10:43:52 <vegai> swords can be very good, though
10:44:03 <norpan> is this some kind of inkblot test?
10:45:28 <asbeta> depends on use :)
10:46:17 <vegai> sword can survive a .50 bullet
10:46:53 <fasta> I give this to the [Strings] argument of runProcess: ["-jar","/home/foo/bar/que/dist/foobar.jar","-nBNs 6"]... the bad stuff is that it doesn't work, while java -jar foobar.jar -nBNs 6 does work on the command line.
10:47:12 <roconnor> http://bestthing.info/
10:47:14 <lambdabot> Title: bestthing.info: comparing apples to oranges and oranges to racecars
10:47:15 <fasta> The jar is executed, but that's about all.
10:47:22 * edwardk has 2 sleeping kittens and a couple dozen swords, so i guess individually the kittens must be more precious.
10:47:26 <edwardk> sure cost more to feed =)
10:47:40 <fasta> The jar says "invalid options" when called from Haskell, and gives me what I want when run from the shell.
10:47:52 <kpreid> fasta: "-nBNs 6" is probably the problem
10:48:21 <fasta> kpreid: sure, but what's wrong with it?
10:48:37 <kpreid> hint: your shell doesn't know about parameters to options
10:48:56 <fasta> kpreid: hint: where's that documented?
10:49:24 <kpreid> I don't know that it is
10:49:34 <fasta> kpreid: and what exactly do you mean?
10:49:51 <fasta> kpreid: do you meant that Haskell adds '-' to the final string?
10:49:58 <kpreid> fasta: the shell splits your command line into "-jar","foobar.jar","-nBNs","6"
10:50:31 <fasta> kpreid: ok, so spaces are not preserved?
10:50:39 <kpreid> not "-jar","foobar.jar","-nBNs 6"
10:50:40 <fasta> kpreid: (in the Haskell version)
10:50:43 <kpreid> no, they are
10:51:19 <kpreid> your Haskell program is the equivalent of java -jar foobar.jar "-nBNs 6" in the shell
10:51:34 <fasta> kpreid: what does runProcess call then? The kernel?
10:51:40 <kpreid> yes
10:51:45 <kpreid> exec() or some variant thereof
10:51:49 <fasta> kpreid: oh, then it makes some sense. :)
10:51:51 <kpreid> as does a shell
10:52:05 <kpreid> shells have parsing rules to split what you type into the list of arguments
10:52:30 <fasta> kpreid: thanks
10:52:37 * fasta reads exec
10:53:13 <kpreid> look at it this way: when you use an exec-based interface it's easy to write code that doesn't break when, say, there's a space in a filename, or other argument
10:54:27 <fasta> spiffy it works
10:56:49 <fasta> kpreid: so the argc in C programs corresponds to the length of the list of arguments I pass to runProcess, right?
10:57:01 <kpreid> yup
10:59:11 <fasta> kpreid: One problem: When I do runProcess .... ; putStrLn "foobar", foobar is not being printed.
11:00:39 <kpreid> fasta: perhaps it's waiting for the process to finish (I don't know runProcess)
11:01:15 <fasta> kpreid: the process finishes in a few ms on the shell.
11:01:30 <fasta> in, even
11:01:57 <kpreid> I don't know, then.
11:02:36 <kpreid> I've never used runProcess, I just know how posix processes work :)
11:03:16 <monochrom> Let me try.
11:04:22 <fasta> Finally TAB completion in ghci :) When was that implemented?
11:05:16 <vegai> not at 6.4.2 at least?
11:05:26 <vegai> or I'm not using it right
11:05:34 <fasta> Hmm, foobar is being printed.
11:05:38 <vegai> ah, you mean filesystem TAB completion?
11:05:44 <vegai> that might just be readline
11:05:50 <fasta> But it's printed before the output of runProcess.
11:06:08 <fasta> That doesn't make much sense to me.
11:06:13 <kpreid> fasta: ah, that's it then. runProcess *doesn't* wait
11:06:25 <kpreid> you want waitForProcess
11:06:27 <monochrom> Works for me.
11:07:33 <monochrom> I didn't use waitForProcess.  But that doesn't stop me from putStrLn "foobar".  It is still printed, albeit at an unexpected time.
11:07:54 <fasta> kpreid: indeed, that works.
11:08:37 <fasta> In this case I am dependent on the output of that program. It generates files, which I need to process further.
11:09:16 <fasta> If my Haskell code would read the files before they are generated... well.. I would have a problem.
11:09:23 <fasta> Right?
11:09:42 <monochrom> Yes, need to wait.
11:10:11 <roconnor> @hoogle Word32 -> IO()
11:10:12 <lambdabot> No matches, try a more general search
11:10:27 <fasta> vegai: I can do call<TAB> in ghci 6.5 and have it expanded to callSomeLargerThingie
11:10:51 <fasta> vegai: I think it's pretty standard readline functionality.
11:11:53 <vegai> fasta: nice.
11:13:30 <fasta> I think Haskell's dev. env. is a bit too weak for the mere mortal though. Dynamic languages seem to do a lot better.
11:14:34 <musasabi> fasta: running ghci under emacs solves much of the problem
11:14:37 <fasta> I tried EclipseFP but got NullPointerExceptions pretty soon, and that's supposed to "solve" this problem.
11:14:45 <fasta> musasabi: Yes, I noticed. I like it.
11:14:54 <fasta> musasabi: Have you seen Factor?
11:14:55 <vegai> Haskell doesn't try to be nice, it seems
11:17:22 <fasta> It seems dynamic languages have better development tools in general.
11:17:34 <fasta> I wonder what the real cause for that is.
11:18:33 <musasabi> Factor?
11:19:01 <fasta> factorcode.org It's only 3 years old, but has arguably better tools already.
11:19:36 <fasta> (ignoring the compiler as a tool)
11:19:41 <Philippa_> fasta: the tools're lighterweight for a given level of power, or to put it another way easier to write
11:19:47 <musasabi> ag. that one. Looked at it a little bit when hacking on Joy-stuff.
11:19:54 <Philippa_> because dynamic tends to mean reflective
11:20:14 <musasabi> Functional programmers tend to be lazy
11:20:42 <musasabi> While this can be a good thing it also can translate into lazyness to get IDE-projects finished
11:21:12 <edwardk> funny, i find that they tend to be strict. =) its just the ones around here that are lazy
11:22:04 <jgrimes_> :)
11:23:13 <fasta> For example in Factor I called a certain function (they are called "words"), and I got a restart that gave me the equivalent of a namespace plus calling that word. Merely clicking on it called the right word.
11:23:25 <fasta> In Haskell, all I get is: not in scope foobar
11:27:28 <fasta> musasabi: Do you know how I can send <TAB> to ghci in Emacs?
11:27:45 <fasta> musasabi: (to get tab completion work in Emacs too)_
11:27:54 <musasabi> fasta: completion? like M-/
11:28:12 <musasabi> M=meta=alt
11:28:21 <fasta> musasabi: no, I mean the equivalent of pressing <TAB> in ghci when run via the shell.
11:28:22 <roconnor> oooh, no poorly-thought-out features.
11:28:28 <roconnor> awesome
11:28:36 <fasta> roconnor: yes, that's funny, I know.
11:28:50 <fasta> roconnor: it's called marketing.
11:28:54 <emertens> HQ9+ doesn't have any poorly-thought-out-features either :)
11:28:57 <roconnor> ;)
11:29:08 <fasta> HQ9+ ?
11:29:58 <musasabi> fasta: no idea. Usually I just open the relevant source files to emacs so editing is easier.
11:30:11 <emertens> HQ9+ has 4 commands, H prints hello world, 9 prints 99 bottles of beer, Q prints the source code of the program, + increments the accumulator
11:30:28 <emertens> the acculumator can not be read because HQ9+ enforces data encasulation
11:30:32 <roconnor> co-operative multithreading!
11:30:38 <roconnor> has that ever worked?
11:30:43 <fasta> musasabi: You mean the ones from base too?
11:31:07 <fasta> musasabi: I suppose you can hide those buffers in Emacs. Do you do that?
11:31:26 <fasta> emertens: oh, right, I read about that. L)
11:31:35 <roconnor> > +++++++Q
11:31:35 <lambdabot>  Parse error
11:32:05 <emertens> lambdabot doesn't know HQ9+
11:32:30 <emertens> roconnor: that program would output : +++++++Q
11:34:47 <musasabi> fasta: isn't the completion related to :r?
11:35:27 <fasta> musasabi: :r reloads a module. I don't understand.
11:35:54 <musasabi> s/r/l
11:36:06 <fasta> musasabi: the completion is based on all the modules in scope.
11:41:47 <musasabi> fasta: but if you have import statements of them then the emacs completion should also work
11:44:55 <fasta> musasabi: It does? Wow
11:45:27 <fasta> musasabi: no, it doesn't.
11:46:34 <musasabi> fasta: how have you configured emacs?
11:47:01 <fasta> musasabi: I use ghci instead of hugs and I use haskell-mode-2.1
11:48:14 <lisppaste2> fasta pasted "config" at http://paste.lisp.org/display/23556
11:48:23 <fasta> musasabi: complete answer ^^
11:50:01 <musasabi> At least I can get the modules names in the import statements with M-/
11:50:19 <musasabi> that looks ok
11:51:26 <jgrimes_> M-/ works for me, including in the ghci buffer
11:52:23 <fasta> musasabi: What Emacs version?
11:58:16 <fasta> musasabi: What exactly do you mean? Suppose that you have import System.Process in your Haskell file, can you do term M-/ and have it expanded to terminateProcess?
11:58:27 <musasabi> 21.4.1 from Debian
11:58:59 <musasabi> fasta: for that I can use TAGS files.
11:59:18 <musasabi> http://www.cse.unsw.edu.au/~dons/tmp/tag-fptools etc
11:59:41 <fasta> musasabi: that's _so_ useful. Thanks
11:59:43 <musasabi> the normal solution only works for identifiers and module names mentioned in the open buffers.
11:59:55 <fasta> musasabi: Ok, that already works here.
12:00:37 <musasabi> You probably want to change htags = hasktags in that script.
12:03:13 <fasta> musasabi: What's the end result? One HTAGS file?
12:04:36 <fasta> musasabi: and how do I tell Emacs about it?
12:04:56 <fasta> musasabi: (it's all_tags I see now)
12:07:41 <fasta> M-x visit-tags-table all-tags gives me invalid tags table.
12:08:10 <fasta> M-x visit-tags-table TAGS gives me a rather empty tags table
12:09:29 <musasabi> works for me, don't understand much about TAGS files in general
12:10:11 <fasta> musasabi: Indeed M-/ works.
12:10:20 <fasta> musasabi: I was trying M-. term
12:10:34 <fasta> musasabi: but apparently that only finds complete terms
12:10:40 <fasta> musasabi: thanks :)
12:15:00 <fasta> musasabi: only now, I need to do M-x visit-tags-table everytime I open my Haskell project.
12:16:23 <fasta> musasabi: did you automate that? Or am I doing somethign else wrong? I now have generated a TAGS file in ~/haskell/ghc and have my project in some other unrelated directory. I visited one of the project files, and did M-x visit-tags-table there.
12:17:13 <musasabi> fasta: #emacs might be a better place to get answers. Sorry, too tired.
12:17:20 <musasabi> Some elisp-foo probably
12:18:41 <fasta> I don't think #emacs knows hasktags...
12:20:06 <musasabi> well they are just TAGS.
12:21:46 <fasta> Sure, nm, I will read the Emacs manual regarding TAGS.
12:22:00 <fasta> Explaining the problem to #emacs takes longer, I guess.
12:22:22 <fasta> musasabi: I was just asking whether _you_ changed something in your .emacs files.
12:22:32 <fasta> (regarding TAGS)
12:23:50 <musasabi> fasta: I usually keep my emacs instances running for a few weeks and use a emacs server so once visiting things is not so bad.
12:24:22 <fasta> musasabi: so you run emacsclient normally, instead of emacs?
12:26:06 <musasabi> yes. but usually just switch between windows and don't kill the emacs off.
12:41:52 <edwardk> woot, the adder works
12:42:18 <edwardk> problem wasn't the adder it was trying to keep it symmetrical. then i realized i didn't need symmetry in the adder. i have 2s complement numbers.
12:42:20 <edwardk> =)
12:54:20 <edwardk> ok. i've found my cap,i get context reduction overflows at 21 digits.
12:54:52 <edwardk> but *Type.Binary> fromTBinary $ tMul (tMul (tMul (tMul (tMul (tMul (tMul (tMul twenty_ twenty_) twenty_) twenty_) twenty_) twenty_) twenty_) twenty_) twenty_
12:54:52 <edwardk> 512000000000
12:54:53 <edwardk> is ok
12:55:11 * zarvok wonders what edwardk is working on
12:55:27 <edwardk> type level 2s complement arithmetic
12:55:38 <edwardk> so i can have negative numbers for free
12:55:51 <zarvok> ah, interesting
12:56:09 <edwardk> *Type.Binary> tAdd sixteen (tNeg twenty_)
12:56:09 <edwardk> O (O T)
12:56:09 <edwardk> *Type.Binary> fromTBinary $ tAdd sixteen (tNeg twenty_)
12:56:09 <edwardk> -4
12:56:56 <edwardk> adding exponentiation and then going back and filling in the boolean operations now that the adder works
12:57:09 <edwardk> i love the symmetry of it now
12:58:43 <edwardk> http://slipwave.com/jugs/src/Type/Binary.hs
13:00:38 <zarvok> pretty
13:00:49 <edwardk> i need to add a divider to it next
13:01:25 <edwardk> musasabi helped me fix the trichotomy law the other night
13:01:56 <edwardk> once i have the divider, exponentiation (easy) and the remaining boolean functions, I think it'll be almost usable
13:02:03 <edwardk> then i get to consider type level rationals =)
13:02:14 <edwardk> but those are harder to find a use case for
13:02:44 <zarvok> I can't think of any, off the top of my head
13:03:33 <cathper> Is there any reason why the function null (in hugs at least) is defined with `null (_:_) = False' rather than `null _ = False'? Is it "just" about aesthetics?
13:04:06 <zarvok> well, the two type differently
13:04:15 <zarvok> I couldn't say if that's the reason though
13:04:24 <eivuokko> Because the other case is null [], it is the same.
13:04:28 <cathper> Well, `null :: [a] -> Bool; null [] = True' before ...
13:04:40 * zarvok was not paying attention at all
13:04:44 <zarvok> heh
13:04:46 <Cale> cathper: It's mostly about aesthetics
13:05:06 <eivuokko> Maybe about warnings.
13:07:06 <cathper> Cale: mkay, I still miss that when it comes to Haskell, but probably that comes after I've programmed more.
13:08:40 <Cale> cathper: well, using the pattern (_:_) means that the order of the lines no longer matters
13:09:08 <Cale> and sort of makes it explicit what's going on
13:09:15 <cathper> Cale: sure, but often they matters anyway.
13:09:26 <cathper> Yes, I see.
13:10:33 <cathper> Btw. do you ever write an algorithm with tail recursion in the first run or only after profiling?
13:11:09 <Cale> Tail recursion is usually less important than ability to evaluate structures lazily
13:11:18 <psnl> w/win 23
13:11:25 <Cale> hehe, null = foldr (const (const False)) True
13:11:37 <roconnor> > let null (_:_) = False in null undefined
13:11:38 <lambdabot>  Undefined
13:11:45 <roconnor> > let null (_:_) = False in null [undefined]
13:11:46 <lambdabot>  False
13:11:55 <roconnor> > let null _ = False in null undefined
13:11:58 <lambdabot>  False
13:12:01 <Cale> ah, that's a good point
13:12:03 <roconnor> > let null _ = False in null [undefined]
13:12:04 <lambdabot>  False
13:12:43 <cathper> For sure.
13:12:59 <eivuokko> It only matters because there's not other case, null [].
13:13:54 <roconnor> eivuokko: ah right
13:14:23 <roconnor> > let null [] = True; null (_:_) = False in null undefined
13:14:25 <lambdabot>  Undefined
13:14:35 <roconnor> > let null [] = True; null _ = False in null undefined
13:14:36 <lambdabot>  Undefined
13:14:38 <roconnor> same
13:19:00 <cathper> regarding tail recursion vs. laziness, is it your intuition, empirical knowledge or test result from runs of large programs or something else?
13:21:13 <Philippa_> cathper: intuitively, the lazy version is not much worse than the tail-recursive version because there's only one "stack frame" that isn't garbage at any given time
13:21:49 <Philippa_> or rather, at most two - the one you're working on and the one in the thunk for the rest of the list
13:24:33 <cathper> Hmm, I can't follow you. I think the "core" of the difference is whether the intermediate result is actually calculated (and reduced) or not---if it is, it could potentially save lots of space, right?
13:25:00 <cathper> Well, in my brain, that makes sense at the moment :-)
13:25:55 <Itkovian> @seen boegel
13:25:55 <lambdabot> I saw boegel leaving #haskell and #haskell-blah 1 hour, 52 minutes and 11 seconds ago, and .
13:32:33 <Philippa_> cathper: it can, but also the garbage collector can pick up all the stuff used to calculate the start of the list any time after the start's been calculated
13:32:49 <Philippa_> which is exactly what tail recursion's used for
13:40:46 <cathper> Correct, but the earlier the element is processed for the last time (calculated or just thrown away or whatever), the earlier it can be GC'ed. If the normal recusion builds up the tree, for instance with a `fun (x:xs) = x + fun xs' structure, the addition is done only when there is no more x'es. In a tail recursive way, we could potentially GC much earlier. And now I've almost argued agains myself since GC'ing probably wouldn't happen while executing t
13:42:11 <SamB> nevermind the stack smashing...
13:43:49 <Philippa_> heh
13:43:53 <cathper> SamB: that confuses me, could you clarify?
13:44:18 <SamB> "fun (x:xs) = x + fun xs" is going to smash the stack, if the list is long enough
13:44:18 <Philippa_> you'll never have more thunks to deal with at once than there are leaf nodes in the tree
13:45:08 <Philippa_> and that's worst-case
13:45:45 <Philippa_> the tail-recursive version's probably better in fairness - there your maximum's the depth of the tree
13:46:16 <cathper> SamB: Yeah, and a tail recursive way isn't. (Well, unless the result grow in size in the same rate.)
13:46:28 <cathper> Yep.
13:46:34 <SamB> cathper: well, if the result grows in size it probably isn't going to be stack allocated ;-)
13:47:03 <cathper> Good point :-)
13:47:28 <fasta> Is there anybody else who uses hasktags on the entire ghc libraries source tree?
13:47:28 <Itkovian> Has anybody written a readInteger instead of readInt for the fps library?
13:47:30 <dylan> hmm, how do you add type information for @pl?
13:47:56 <SamB> type information?
13:48:04 <fasta> The all_tags file is not in a valid format for Emacs.
13:48:14 <dylan> err, a signature.
13:48:29 <dylan> @pl readdir dir = liftM (map (prefix dir)) $ readdir' dir
13:48:30 <lambdabot> readdir = ap (fmap . map . prefix) readdir'
13:48:36 <emertens> @pl \x -> x :: Int -> Int
13:48:37 <lambdabot> (line 1, column 16):
13:48:37 <lambdabot> unexpected ">" or "-"
13:48:37 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
13:48:39 <monochrom> "add (x:xs) = x + add xs" this is bad.  "list (x:xs) = x : list xs" this is good.  Time to grow out of the endian war of "tail call is good" vs "tail call is bad".
13:48:48 <emertens> something like that :)
13:49:01 <SamB> monochrom: well tail calls when building a list are okay too
13:49:19 * cathper appreciates all the inputs very much! Thanks to Cale, roconnor, eivuokko, Philippa_ and SamB!
13:49:23 <SamB> ... especially in the implementation of reverse
13:50:16 <monochrom> Not sure about that.
13:51:31 <monochrom> A whole chapter in Okasski's thesis/book is devoted to circumventing reverse because of that behaviour.
13:59:35 <cathper> monochrom: purely functional data structures? (Okasaki)
13:59:49 <monochrom> Yes
14:00:38 <cathper> that's the next book waiting to be read :-)
14:01:09 <musasabi> it is a very nice book
14:01:35 <emertens> what is the negative behavior of reverse?
14:01:35 <roconnor> monochrom: is reverse ever needed?
14:02:27 <monochrom> That is an open question. Someone should do a PhD on it.
14:02:39 <musasabi> roconnor: quite frequently reverse is nice to have.
14:05:34 <monochrom> reverse is an all-or-nothing deal. Once it is unleashed, you have to wait for it to process the whole list.  This is good if you use it as part of amortized O(1) operations.  This is bad if you use it as part of worst-case O(1) operations.
14:07:41 <emertens> hm, and why is that differnt than any computation that acts over a whole list?
14:08:10 <Philippa_> some of them don't have to process the entire list before they start yielding results
14:08:14 <Philippa_> maps, for example
14:08:19 <monochrom> "map f xs" does not make you wait for the whole list, for example.
14:08:34 <SamB> there doesn't have to be a "whole list"
14:09:16 <monochrom> Of course, there is little you can do to "sum xs".
14:09:27 <roconnor> O(n) is slow when n=infinity
14:09:31 <dylan> > reverse [1..]
14:09:35 <lambdabot> Terminated
14:10:25 <emertens> so shouldn't that argument be more general... like "foldls are bad" ?
14:10:35 <SamB> apparantly not
14:10:51 <monochrom> I am precisely speaking against such naive over-generalizations.
14:11:00 <emertens> oh, good
14:11:01 <emertens> :)
14:11:09 <zarvok> @remember roconnor  O(n) is slow when n=infinity
14:11:09 <lambdabot> Done.
14:11:29 <monochrom> foldl is no worse than the desire of the sum of a list.
14:11:37 <monochrom> s/of/for/
14:11:44 <emertens> sum is a fold..
14:12:01 <monochrom> If you absolutely desire the sum of a list, are you bad?
14:12:13 <emertens> you are if you have an infinite list
14:12:21 <roconnor> emertens: foldls are bad.
14:12:23 <monochrom> Heh
14:12:31 <emertens> because the upper bound on it's running time is infinite , as lambdabot know remembers
14:12:41 <SamB> roconnor: show me *your* definition of reverse
14:12:44 <roconnor> foldl' is better
14:13:04 <emertens> I've read that wiki page oto
14:13:07 <SamB> hmm
14:13:35 <SamB> > foldl' (flip (:)) [1..1000000]
14:13:37 <lambdabot>  Add a type signature
14:13:43 <SamB> > foldl' (flip (:)) [1..1000000] :: [Integer]
14:13:44 <lambdabot>    Expecting a function type, but found `[Integer]'
14:13:44 <lambdabot>    Expected type: [I...
14:13:49 <emertens> foldl' (:) [] [1..]
14:13:53 <mwc> I think the key thing to do is distinguish two completely different uses for lists in Haskell. One is as an ordered sequence of values. The other is as a construct that implements looping in other languages
14:13:55 <SamB> > foldl' (flip (:)) [] [1..1000000] :: [Integer]
14:13:56 <emertens> > foldl' (:) [] [1..]
14:13:57 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
14:13:58 <lambdabot>    Expected...
14:13:58 <lambdabot>  [1000000,999999,999998,999997,999996,999995,999994,999993,999992,999991,9999...
14:14:12 <SamB> > foldl (flip (:)) [] [1..1000000] :: [Integer]
14:14:14 <lambdabot>  [1000000,999999,999998,999997,999996,999995,999994,999993,999992,999991,9999...
14:14:15 <emertens> > foldl (:) [] [1..]
14:14:16 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
14:14:16 <lambdabot>    Expected...
14:14:18 <emertens> ?
14:14:20 <mwc> sometimes an infinite loop is exactly what you want, but you should never have infinite lists of significant values you need to keep around
14:14:22 <emertens> > foldr (:) [] [1..]
14:14:24 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:14:37 <emertens> there, I performed a fold on an infinite list :) woot
14:14:49 <SamB> > foldl (flip (:)) [] [1..]
14:14:53 <lambdabot> Terminated
14:14:57 <SamB> > foldl' (flip (:)) [] [1..]
14:15:01 <lambdabot> Terminated
14:15:27 <emertens> you think that it'd be smart enough to allow this to work: reverse (cycle [1,2,3])
14:15:30 <emertens> ;)
14:15:39 <SamB> absolutely not
14:15:44 <monochrom> Yes, it is rather hard to find an application of foldl (as opposed to foldl')
14:15:49 <mwc> how about this:
14:15:57 <mwc> > cycle $ reverse [1,2,3]
14:15:58 <lambdabot>  [3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2,1,3,2...
14:16:23 <SamB> last time we were talking about it someone seemed to think it was actually useful...
14:16:23 <mwc> of course, that kind of assumes that you cycling produces an integer number of iterations of the input list
14:17:21 <monochrom> reverse (repeat 1) ought not be the same as repeat 1.  I am speaking denotationally.
14:19:56 <monochrom> reverse (repeat 1) should be the limit of this sequence: reverse (_|_), reverse (1:_|_), reverse (1:1:_|_), ...
14:20:15 <monochrom> I'm pretty sure every term, and therefore the limit, is _|_.
14:20:21 <sieni> > reverse (repeat 1)
14:20:25 <lambdabot>  out of memory (requested 1048576 bytes)
14:20:53 <monochrom> That's catastrophic :)
14:21:01 <sieni> > take 1 $ repeat 1
14:21:02 <lambdabot>  [1]
14:21:03 <emertens> > let a = cycle a in a
14:21:04 <lambdabot>  Add a type signature
14:21:07 <sieni> > take 1 $ reverse repeat 1
14:21:07 <lambdabot>    The function `reverse' is applied to two arguments,
14:21:07 <lambdabot>   but its type `[a...
14:21:16 <sieni> > take 1 $ reverse (repeat 1)
14:21:16 <cathper> emertens: my version of hugs actually segfaults on `reverse (cycle [1..3])'.
14:21:19 <lambdabot>  out of memory (requested 2097152 bytes)
14:21:29 <dylan> It's somewhat disturbing that bottom looks like a butt.
14:21:30 <sieni> so they are not the same
14:21:40 <dylan> especially inside parens...
14:21:52 <sieni> dylan: why is that? I like butts, especially female ones ^_^
14:21:59 <monochrom> It's satisfying that bottom equals butt :)
14:22:11 <sieni> lambdabot: @type (.)(.)
14:22:13 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
14:22:20 <sieni> so boobs are also typeable
14:22:26 <cathper> :-D
14:22:26 <dylan> sieni: would that be 'top'?
14:22:40 <emertens> that would be top-less
14:22:47 <dylan> hehe
14:23:01 <monochrom> Haskell is topless.  Most programming languages are.
14:23:09 <dylan> also, _|_ without parens looks like 'the finger'
14:23:51 <dylan> which is appropriate in some cases.
14:23:52 <dylan> :)
14:24:37 <monochrom> "Mom! My computer is giving me the finger!"
14:32:48 <ndm> I prefer to write (_|_) - looks more like a bottom
14:33:30 <norpan> yeah
14:33:38 <norpan> i've pondered that ascii art before
14:34:31 <ndm> i spend all my working phd thinking about bottom, so i've pondered it more than most :)
14:35:37 <roconnor> can datatypes be declared in any order?
14:35:45 <ndm> roconnor: yes
14:37:46 <monochrom> You should do your PhD on the usefulness of reverse. :)
14:38:04 <Cale> roconnor: they can even be declared after the point in the module in which they are used
14:38:10 <monochrom> It is related to bottom, so everything fits.
14:38:34 <norpan> reverse (repeat 1) == (_|_)
14:38:35 <monochrom> Yes, I like forward references :)
14:39:18 <ndm> monochrom: I spend ages working on reverse, its really hard!
14:39:22 <monochrom> Now, if only imports can be placed at the end too...
14:39:58 <ndm> (although i have solved it now, even teh accumulating version)
14:40:03 <sieni> Personally, I think they should have chosen (_!_) as the symbol of the bottom instead of (_|_)
14:40:18 <ndm> and ironically, i do use ! as the ASCII for bottom
14:40:25 <ndm> (for pattern match bottom)
14:40:36 <ndm> and # for non-termination bottom
14:40:50 <monochrom> Dude
14:41:06 <monochrom> You should, like, work on better devel tools for Haskell
14:41:10 <monochrom> rather than, like,
14:41:13 <ndm> say Hoogle?
14:41:16 <ndm> or WinHugs?
14:41:18 <ndm> or Hat?
14:41:20 <ndm> of Yhc?
14:41:22 <ndm> or GuiHaskell?
14:41:23 <monochrom> spend all your time on ascii arts for bottom!
14:41:25 <ndm> or Gtk?
14:41:45 <emertens> ndm: yeah, stop working on those and get to work on Haskell
14:42:07 <ndm> emertens: officially i should stop working on them and work on my phd :)
14:48:40 <emertens> ndm: what topic are you researching for your PhD?
14:49:00 <ndm> @where catch
14:49:00 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
14:49:06 <ndm> emertens: that one ^^^
14:50:00 <emertens> cool
14:50:39 <emertens> is this something that would be integrated into yhc one day? or would this be implemented as a separate tool?
14:50:47 <ndm> separate tool, but it uses Yhc
14:51:16 <ndm> not integrated, but dependant on
14:51:20 <emertens> sure
14:52:29 <emertens> so in the trivial case: case Just 1 of ; Just x -> x    would not be flagged because the checker would know all of the possible values?
14:53:57 <ndm> yes
14:54:08 <ndm> and also far less trivial cases are spotted as safe
14:54:16 <ndm> map head $ map (:[]) xs
14:54:18 <SamB> @hoogle (a -> Bool) -> [a] -> a
14:54:20 <lambdabot> No matches, try a more general search
14:54:29 <SamB> @hoogle Eq a => (a -> Bool) -> [a] -> a
14:54:31 <ndm> if null xs then [
14:54:31 <lambdabot> No matches, try a more general search
14:54:40 <ndm> if null xs then 1 else head (reverse xs)
14:55:12 <ndm> but also where the pattern match and safety are miles appart - for example one function removes a constructor
14:55:18 <ndm> another relies on that not being there
14:55:20 <SamB> @hoogle Eq a => (a -> Bool) -> [a] -> Int
14:55:21 <lambdabot> No matches, try a more general search
14:55:26 <SamB> @hoogle (a -> Bool) -> [a] -> Int
14:55:28 <lambdabot> No matches, try a more general search
14:55:36 <SamB> @hoogle a -> [a] -> Int
14:55:38 <lambdabot> No matches, try a more general search
14:56:09 <SamB> @djinn (a -> Bool) -> [a] -> a
14:56:10 <lambdabot> Cannot parse command
14:56:10 <lambdabot> -- f cannot be realized.
14:57:33 <ndm> @hoogle findIndex
14:57:34 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
14:57:34 <lambdabot> Data.Map.findIndex :: Ord k => k -> Map k a -> Int
14:57:45 <ndm> SamB, ^^
14:57:47 <SamB> @hoogle find
14:57:48 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
14:57:49 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
14:57:49 <lambdabot> List.findIndices :: (a -> Bool) -> [a] -> [Int]
14:57:56 <SamB> oh, right, Maybe
14:58:28 * SamB thinks hoogle should include things returning Maybe of whatever was requested
14:58:35 <SamB> @hoogle (a -> Bool) -> [a] -> Maybe a
14:58:36 <ndm> SamB, although Hoogle is specifically DESIGNED to fix that
14:58:36 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
14:58:43 <ndm> @hoogle (a -> Bool) -> [a] -> a
14:58:44 <lambdabot> No matches, try a more general search
14:59:05 <ndm> http://haskell.org/hoogle/?q=%28a+-%3E+Bool%29+-%3E+%5Ba%5D+-%3E+Maybe+a
14:59:07 <lambdabot> Title: (a -> Bool) -> [a] -> Maybe a - Hoogle
14:59:15 <ndm> thats just lamdabot hoogle, normal hoogle gets it right :)
14:59:33 <SamB> lambdabot should use the real thing, or something
14:59:40 <ndm> it does, but with tweaks
14:59:44 <ndm> to demand closer matches
14:59:48 <ndm> which breaks that exampole
15:00:13 <emertens> if lambdabot worked like hoogle the website, lambdabot would be kicked for flooding
15:00:28 <ndm> lambdabot limits to 3 results anyway
15:00:30 <SamB> why's it need closer matches? it only ever returns three results
15:00:46 <ndm> anyway, hoogle 4 has a new type matching algorithm for maybes
15:00:48 <SamB> just so long as the most exact matches are highest...
15:00:51 <ndm> which is way cool :)
15:01:00 <ndm> and should pick up maybe stuff even better
15:10:58 <lispy> ndm: what about an option to get H98 vs. modern module names?
15:15:04 <emertens> is it easy to build Hat on Windows?
15:16:05 <lispy> i've found that most things are easy to build on windows with mingw + recent cabal and recent ghc
15:17:10 <emertens> what is hmake
15:17:12 <ndm> emertens: no, impossible, download a prepackaged version
15:17:23 <emertens> Oh, I didn't see one
15:17:24 <ndm> don't listen to that!
15:17:31 <ndm> @where windows
15:17:31 <lambdabot> I know nothing about windows.
15:17:57 <ndm> emertens: i rewrote Hat, write hat-make to compile programs, wrote a GUI and ported all the console tools
15:18:09 <ndm> its possible to build if you have a brand new cpphs, and use hte makefile.bat
15:18:17 <ndm> but you need cpphs from the last 3 days to get it working
15:18:25 <emertens> I don't want to fool with that
15:18:25 <ndm> http://www-users.cs.york.ac.uk/~ndm/projects/windows.php
15:18:28 <emertens> where is the binary?
15:18:28 <lambdabot> Title: Neil Mitchell - Windows Packages
15:18:36 <emertens> cool
15:18:38 <ndm> just download form that page, should be nice and simple
15:18:52 <ndm> lispy: H98 vs modern module names? what are you meaning? for what?
15:19:05 <lispy> Data.Char vs. CHar
15:19:07 <emertens> ndm: what tool would you recommend for haskell development on windows?
15:19:08 <lispy> for example
15:19:19 <lispy> @hoogle ord
15:19:19 <lambdabot> Char.ord :: Char -> Int
15:19:20 <lambdabot> Prelude.Ord :: class Eq a => Ord a
15:19:20 <lambdabot> Text.Html.ordList :: HTML a => [a] -> Html
15:19:23 <lispy> @index ord
15:19:23 <lambdabot> Data.Char
15:19:41 <ndm> emertens: TextPad + WinHugs is a solid combination
15:19:45 <ndm> with GHC/GHCi if you need it
15:20:03 <ndm> lispy: Hoogle 4 will move to modern, i.e. alwyas Data.Char, not Char
15:20:13 <lispy> cool
15:20:17 <ndm> since I think thats the way to go, now every compiler supports it
15:20:39 <ndm> (the last release of WinHugs didn't support it, which is why i used H98, now thats fixed, it goes in)
15:20:53 <lispy> heh, so you're a hugs user?
15:20:58 <ndm> emertens: just to warn you, hat isn't fantastically useful on real programs
15:21:00 <lispy> i find ghc extensions are nice...
15:21:01 <ndm> of course :)
15:21:14 <ndm> I never use any of the extensions, apart from heirarchical modules
15:21:14 <monochrom> I would say H98 is modern, and Data.Char is postmodern. :)
15:21:38 <ndm> Hugs is maybe 100 times faster to compile things that GHC
15:21:41 <emertens> does textpad have any sort of color codign?
15:21:41 * lispy hates the term postmodern ;)
15:21:46 <ndm> hence Hugs makes me 100 times more productive
15:21:57 <emertens> ndm: because all you do is compile over and over?
15:22:01 <ndm> emertens: yes, download a Haskell Sytnax module,, and its got pretty nice colouring
15:22:02 <monochrom> I do too, but what the heck :)
15:22:09 <lispy> ndm: i spend very little time compiling :)
15:22:20 <ndm> emertens: because I fix bugs, and WinHugs gives me a hyperlink and brings up the exact line in my editor
15:22:37 <ndm> the number of times i get to the end of a compile/load is relatively low :)
15:22:41 <lispy> visual haskell does that too
15:22:46 <ndm> yes, but slower
15:22:53 <ndm> and by slower, i mean 100 times slower
15:22:58 <lispy> yeah long lines kills VH
15:23:13 <ndm> as in i actually mean i timed it for Yhc, and its a factor of just over 100
15:23:14 <lispy> that's when i switch back to emacs or textpad
15:24:58 <ndm> emertens: if you get any success with hat, i'd be interested to hear - its rare that it works...
15:25:04 <emertens> sweet :)
15:25:08 <ndm> but of course, i'm working on that...
15:25:19 <emertens> well stop, and get back to work on haskell...
15:25:26 <ndm> too drunk tonight
15:25:27 <emertens> ;)
15:25:33 <ndm> and am focusing on my phd tonight
15:25:41 <emertens> anyway, it's definitely time to go home!
15:25:42 <emertens> woot
15:26:40 <edwinb> too drunk is a good time to focus on your phd
15:27:32 <ndm> yeah, i think i almost have my design finished
15:28:21 <edwinb> I didn't say it was necessarily a good time to do it ;)
16:34:47 <mahogny> syntax example, records, anyone?
16:34:54 <mahogny> with strictness
16:35:38 <mahogny> would just ! in front of the constructor do?
16:37:05 <dons> let me find one
16:37:09 <audreyt> data Moose = MkMoose { antler :: !Antler }
16:37:10 <monochrom> data Dinner = Dinner { time: !Int, venue: String }
16:37:23 <monochrom> time is strict, venue is non-strict.
16:37:25 <dons> data HState = HState {
16:37:25 <dons>         music           :: !FileArray
16:37:25 <dons>        ,folders         :: !DirArray
16:37:25 <dons>        ,size            :: !Int                  -- cache size of list
16:37:25 <dons>        ,current         :: !Int                  -- currently playing mp3
16:37:28 <dons>        ,cursor          :: !Int                  -- mp3 under the cursor
16:37:30 <dons>        ,clock           :: !(Maybe Frame)        -- current clock value
16:37:31 <monochrom> also s/:/::/
16:37:38 <mahogny> aaaaah. thanks
16:37:54 <dons> and then -funbox-strict-fields to get the real benefit
16:37:59 <mahogny> so one for every member is needed? no shortcut for getting them all?
16:38:03 <mahogny> hmm. ok
16:38:22 <dons> no shortcuts. well, deepSeq... but that's a different game
17:03:38 <quetzal> a question here.. if i have list data structure as:
17:03:39 <quetzal> data List a = Nil
17:03:39 <quetzal>     | Cons a (List a)
17:03:45 <quetzal> how do i define list of 2 items?
17:04:03 <quetzal> reading yaht and kinda stuck on that
17:05:03 <edwardk> Cons foo $ Cons bar $ Nil
17:05:19 <edwardk> or replace $'s with ... Cons foo (Cons bar Nil)
17:05:47 <audreyt> foo `Cons` bar `Cons` Nil
17:05:55 <edwardk> or that =)
17:05:59 <edwardk> heya audrey
17:06:05 <audreyt> hi :) how goes?
17:06:29 <edwardk> not bad. got sidetracked with various jits for the icfp contest so haven't made much headway on the js implementation
17:06:54 <dons> quetzal: yeah, just translate the usual list notation: a : b : [] --> (:) a (((:) b [])) --> Cons a (Cons b Nil)
17:07:02 <audreyt> cool!
17:07:03 <quetzal> oh, i have to explicitly state Nil. thanks
17:07:10 * audreyt wonders if Hs will still be the langOfChoice this yer
17:07:13 <dons> that's the end node on the list, yep.
17:07:23 <edwardk> been playing with type level 2s complement arithmetic, got everything working except my divider so far
17:07:40 <dons> ?remember edwardk been playing with type level 2s complement arithmetic
17:07:41 <lambdabot> Done.
17:07:48 <dons> edwardk: have you seen oleg's type level rsa?
17:07:53 <edwardk> yeah
17:08:02 <edwardk> mines a bit different, but has similar properties
17:08:12 <dons> ie. wackiness?
17:08:23 <edwardk> the 2s complement makes the addition trivially reversible
17:08:32 <edwardk> and shows off the duality i didn't know was present in a full adder
17:09:24 <edwardk> http://slipwave.info/jugs/src/Type/Binary.hs
17:09:38 <edwardk> I''m rather fond of the TAddC implementation there
17:09:46 <edwardk> very symmetrical between the negative and carry cases.
17:10:06 <edwardk> so i don't need to build a subtractive borrower, i can just add the negation of a number.
17:10:48 <edwardk> the TRMul stuff on the bottom probably doesn't compile yet, but the rest is clean
17:11:11 <audreyt> fundep is strange... it tempts programmers of this highly advanced functional programming environment to instead program in a primitive logic programming environment
17:11:25 <dons> uh hu.
17:11:27 <edwardk> i do like the fact that i was able to state trichotomy laws right in the code
17:11:28 <edwardk> heh
17:11:30 <edwardk> yeah =)
17:11:33 <dons> bring on the System Fc!
17:11:36 <edwardk> its like i'm in prolog all over again =)
17:11:46 <edwardk> but with no backtracking
17:11:55 <audreyt> also the typechecker is not as helpful
17:11:59 <edwardk> yeah
17:12:07 <audreyt> hence "primitive"
17:12:16 <edwardk> type checker sucks ASS when something happens about 3 steps into type resolution
17:12:44 <edwardk> you get an error thats 6 resolution steps away from where the relevant definitions are, and you're left to guess your way back to the cause.
17:13:09 <edwardk> anyways, i'm just happy as a clam that addition worked. by contrast multiplication took like 20 seconds =)
17:13:13 <audreyt> kinda like "Prelude.head" errors.
17:13:50 <dons> interesting point, audreyt. hmm
17:13:52 <edwardk> i'll finish adding and, or, xor, implies, etc then stick this thing on a shelf and forget about it for a while =)
17:14:15 <dons> edwardk: no! add a @type-eval plugin
17:14:18 <edwardk> its not really infinite precision, it dies around 2^21
17:14:23 <dons> so we can play with this stuff in channel
17:14:54 <edwardk> but multiplication works all the way out there
17:15:12 <edwardk> hrmm, how would that work?
17:15:25 <dons> well, it'd run the typechecker with the fragment you give it... ?
17:15:27 <edwardk> this all has witness functions so you need not recompile to use it
17:16:25 <dons> audreyt: what you you estimate the size of the average perl package is? one module?
17:16:25 <edwardk> *Type.Binary> tMul sixteen (tNeg nineteen)
17:16:25 <edwardk> O (O (O (O (I (O (I (I (O T))))))))
17:16:25 <edwardk> *Type.Binary> fromTBinary $ tMul sixteen $ tNeg nineteen
17:16:25 <edwardk> -304
17:16:36 <dons> cool :)
17:17:06 <dons> but its not being run in the typechecker ;)
17:17:20 <dons> i want something like the type level quicksort, you know:  :type ....
17:17:23 <edwardk> i just need to figure out a motivating example for type level rationals so i can have an excuse for type level gcd
17:17:26 <edwardk> heh
17:17:43 <edwardk> type level quicksort eh?
17:17:50 <dons> you've not seen it?
17:17:53 <edwardk> nope
17:17:56 <audreyt> dons: 300 to 500 lines
17:18:18 <dons> audreyt: ah ok. I think haskell packages are shrinking in size.
17:18:22 <edwardk> i just kinda started hacking away at this stuff when i realized that using 2s complement i could generalize everyone else's type level math stuff
17:18:52 <dons> edwardk: http://www.haskell.org/haskellwiki/Type_arithmetic#An_Advanced_Example_:_Type-Level_Quicksort
17:18:53 <lambdabot> Title: Type arithmetic - HaskellWiki
17:19:26 <dons> in particular:
17:19:26 <dons> > :t listQSort list1
17:19:26 <dons> Cons
17:19:26 <dons>     (Succ Zero)
17:19:27 <dons>     (Cons (Succ One) (Cons (Succ Two) (Cons (Succ Three) Nil)))
17:19:27 <lambdabot>  Parse error
17:19:39 <dons> ditch the backend entirely!
17:19:44 <edwardk> heh
17:19:47 <edwardk> i like
17:20:09 <dons> the lambda calculus implementation on the type level is also super cool
17:20:17 <dons>  > :t undefined :: Eval (App (Lam X) X) u => u
17:20:18 <dons> undefined :: Eval (App (Lam X) X) u => u :: X
17:20:32 <edwardk> yeah that i kinda figured was pretty trivial
17:20:37 <dons>  > :t undefined :: Eval (App (Lam (App X X)) (Lam (App X X)) ) u => u
17:20:38 <dons> ^CInterrupted
17:20:43 <edwardk> the quicksort is just neat =)
17:21:21 <edwardk> some of my earlier versions of the type arithmetic stuff were getting out there in complexity before i started spotting dualities
17:21:29 <dons> we challenged roman (I work with him) to do it. and he hacked it up in about 30 minutes
17:21:35 <edwardk> heh
17:21:36 <audreyt> edwardk: I like your closure type.
17:21:48 <audreyt> class Closed a | -> a
17:21:57 <audreyt> mildly surprised that fundep allows that
17:22:00 <chessguy> that sounds like a pickup line
17:22:01 <edwardk> i stole the idea from the mailing list
17:22:26 <edwardk> but the idea of deriving a second class that drops the closure parameter is new afaik
17:22:31 <chessguy> hey there sweetheart....i like your closure type, can i buy you a drink?
17:22:36 <audreyt> chessguy: nah. "I like your endofunctor" is more like it
17:22:51 <dons> oh my
17:23:10 * edwardk tucks back his endofunctor.
17:23:12 <dons> oh, that works? | -> a
17:23:15 <edwardk> yeah
17:23:17 * dons learns something new
17:23:22 <edwardk> neat eh?
17:23:29 <dons> hmm. tricksy!
17:23:38 * chessguy whispers to edwardk....your epidermis is still showing
17:23:55 <edwardk> data Closure; class Closed a | -> a; instance Closed Closure
17:24:05 <audreyt> chessguy: surely you mean "epimorphism"
17:24:35 <chessguy> oh, how embarrassing
17:25:11 <musasabi> Having the ablity to do functional programming instead of logic programming on the type level would be nice.
17:25:20 <edwardk> the biggest problem i am having with the type math stuff is, somewhat embarrassingly the type and/or stuff.
17:25:24 <audreyt> musasabi: isn't that what ATs are partially for?
17:25:30 <edwardk> because i was trying to do xor, etc in a reversible fashion
17:25:48 <dons> audreyt: exactly
17:25:53 <edwardk> i gave up and now just do them 3 times to get the reversible version
17:26:05 <dons> there are now proper type level functions, in the AT branch, I think
17:26:43 <dons> (which seems very active at the moment, too)
17:26:45 <musasabi> audreyt: yes. But I want nice type level functions with function syntax and not to abuse the class syntax.
17:27:10 <musasabi> (this comes more relevant with extensible kinds)
17:27:17 <fraxtal> Do you guys know if there is a mirror to http://haskell.org/ghc/dist/6.4.2/ghc-6-4-2.msi ? I am trying to get it over dialup, and the server doesn't seem to support resuming
17:27:40 <dons> hmm. I don't know if we have a mirror.
17:27:49 <dons> we should have one!
17:28:04 <edwardk> setting up a copy for you frax
17:28:16 <fraxtal> that would be great
17:28:21 <edwardk> will take about 2-3 minutes
17:28:24 <fraxtal> can you leave it up overnight?
17:28:27 <edwardk> sure
17:28:30 <dons> why don't we have a mirror. how very strange
17:29:03 <fraxtal> I'd go with Hugs but the interactive feature isn't that great
17:29:21 <dons> ghc is a good choice.
17:29:35 <dons> fraxtal: you don't like the hugs ui?
17:29:41 * edwardk <<3 ghc
17:29:41 <dons> WinHugs?
17:30:05 <fraxtal> It seems that I am unable to define anything in interactive mode
17:30:11 <dons> right. you can't
17:30:15 <dons> you need to load it from a file
17:30:21 <fraxtal> right
17:30:22 <edwardk> same with ghc really
17:30:37 <dons> edwardk: ?
17:30:39 <edwardk> aside from that hack of marlow's
17:30:49 <edwardk> no?
17:30:58 <dons> hmm, hack? ghci sits in the IO monad. so there's a natural encoding of new decls
17:31:15 <dons> oh, you mean that :reload hack the other day?
17:31:18 <edwardk> interesting
17:31:25 <dons> ghci supports:  let f x = x
17:31:26 <fraxtal> I'd like to be able to play freely with the language without having to constantly load files
17:31:27 <dons> which hugs doesn't
17:31:28 <fraxtal> ya know
17:31:47 <dons> fraxtal: the main issue is that haskell supports mutually recursive declarations
17:32:03 <dons> so in general you need to see all  bindings to work out the type of any particular binding, roughly
17:32:06 <fraxtal> oh lawd is that like voodoo
17:32:16 <dons> which is not so nice with an interactive system
17:32:23 <edwardk> http://slipwave.info/ghc-6-4-2.msi
17:32:29 <fraxtal> thanks edwardk
17:32:42 <edwardk> i'll leave it up until tomorrow afternoon. thats on a fairly current apache, should resume just fine
17:33:02 <edwardk> he
17:33:07 <edwardk> never knew about the let thing =)
17:33:14 <edwardk> that makes life a little easier.
17:33:18 <dons> heh
17:33:35 <fraxtal> about to test the resume
17:33:37 <dons> edwardk: you should read the 'Haskell in 5 Steps' tut ;)
17:33:43 <edwardk> probably
17:33:54 <edwardk> still a n00b. *sigh* =)
17:33:58 <dons> :)
17:33:58 <edwardk> i'm trying though
17:34:08 <dons> yep, monads: hard. type level hackery: fun!
17:34:21 <dons> ?wiki Haskell_in_5_steps
17:34:22 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_5_steps
17:34:25 <edwardk> didn't find monads hard
17:34:46 <edwardk> its figuring out what arbitrary seeming restriction will trip me up today on other stuff that gets me =)
17:34:54 <dons> sorry, monadic let
17:35:25 <dons> @seen Cale
17:35:26 <lambdabot> Cale is in #haskell. I last heard Cale speak 2 hours, 57 minutes and 21 seconds ago.
17:35:38 <fraxtal> So I am reading The Art of Computer Programming and learning Haskell
17:35:40 <edwardk> i still don't know WHY i had to change the type signature of a random witness function that should be irrelevant to change the order in which my trichotomy type class resolved its dependencies =)
17:35:45 <jmob> > (length "123) / 2
17:35:46 <dons> anyone have an opinion on the "Making a Short Story Long" section of that tut?
17:35:46 <lambdabot>  Improperly terminated string
17:35:55 <jmob> > (length "123") / 2
17:35:56 <lambdabot>  add an instance declaration for (Fractional Int)
17:35:56 <lambdabot>   In the definition of `...
17:36:05 <dons> i'm not convinced it should be there. seems like a "please just trust us" kind of thing
17:36:22 <dons> fraxtal: cool!
17:36:33 <dons> i did the same back in 1999 :)
17:36:37 <fraxtal> ok thanks edwardk, i'll finish this up tonight
17:36:53 <edwardk> if tIsZero has its type annotation as tIsZero = undefined :: TIsZero a b => a -> b instead of having two statements, one for the type annotation and one for the value, then my TYPE blows up
17:36:54 <edwardk> weird =)
17:36:56 <fraxtal> I shall return
17:37:01 <edwardk> no problem frax
17:37:16 <fraxtal> awesome
17:37:23 <edwardk> and its not even that type that blows up, its the Trichotomy class
17:37:23 <fraxtal> peace
17:37:27 <edwardk> thats 2 levels up =)
17:38:12 <edwardk> because it starts trying to resolve the two dependencies in the wrong order.
17:38:28 <edwardk> musasabi here saved my bacon on that one, but neither of us knows WHY
17:39:33 <Cale> dons: looking for me?
17:39:37 <jmob> So, how does an Int become and "Integer" so I can use / ?
17:39:49 <Cale> You can't use / with Int or Integer
17:39:59 <Cale> You use `div` for integer division
17:41:46 <monochrom> > 5 `div` 2
17:41:47 <lambdabot>  2
17:42:00 <monochrom> > fromIntegral 5 / fromIntegral 2
17:42:00 <lambdabot>  2.5
17:42:05 <monochrom> Pick one.
17:42:09 <fnord123> > 1 `div` 0
17:42:11 <lambdabot>  Exception: divide by zero
17:42:57 <monochrom> If you have seen this and wondered:
17:42:59 <monochrom> > 5/2
17:43:00 <lambdabot>  2.5
17:43:18 <Cale> @type 5
17:43:19 <lambdabot> forall t. (Num t) => t
17:43:23 <monochrom> That's because for literals the computer inserts "fromIntgral" silently.
17:43:24 <Cale> @type 5/2
17:43:25 <fnord123> >x <- 100
17:43:26 <lambdabot> forall a. (Fractional a) => a
17:43:27 <fnord123> x
17:43:28 <fnord123> >x
17:43:30 <Pete_I> why doesn't it return fractions? lisp returns fractions...
17:43:41 <jmob> I'll be damned.  I don't understand why this didn't seem to be working 2 hours ago.
17:43:42 <Cale> @type 5/2 :: Rational
17:43:43 <lambdabot> Rational :: Rational
17:43:47 <Cale> > 5/2 :: Rational
17:43:48 <lambdabot>  5%2
17:43:55 <Cale> there you go, fractions :)
17:44:11 <Cale> Just have to use the Rational type.
17:44:15 <monochrom> > 5/2 + 5/3 :: Rational
17:44:16 <lambdabot>  25%6
17:44:22 <monochrom> "It works"
17:44:25 <Pete_I> > 3.14159265 :: Rational
17:44:26 <Cale> The default Fractional type is Double
17:44:26 <lambdabot>  62831853%20000000
17:44:34 <Pete_I> cool
17:44:43 <Cale> You can set what the default is with the default keyword.
17:45:16 <Cale> On a per-module basis, at least.
17:46:50 <fnord123> import Directory (removeFile)
17:47:01 <fnord123> > import Directory (removeFile)
17:47:02 <lambdabot>  Parse error
17:47:13 <Cale> fnord123: It only evaluates expressions
17:47:29 <Cale> That only works inside a module
17:48:25 <Cale> fnord123: the x <- 100 thing only works inside a do-block, and only if you're in a monad which is an instance of Num, which is actually pretty unlikely.
18:16:59 <nealc__> good hacking night!
18:17:13 <dons> night nealc__ !
18:30:29 <LordBrain> ok, if anyone is interested, i've uploaded the beginnings of the "Practical Haskell" Tutorial... I tried to mark it clearly to indicate how poeple can contribute.
18:30:33 <LordBrain> http://haskell.org/hawiki/PracticalHaskell?action=show#head-b0948275453706bb1313f2ec17cce7715d81a0ed
18:30:34 <lambdabot> Title: PracticalHaskell - The Haskell Wiki
18:31:02 <dons> cool
18:34:33 <dibblego> what's the opposite of "referentially transparent"?
18:35:07 <dibblego> referentially opaque? untransparent?
18:35:17 <LordBrain> dibblego: how about "Side-effecting"
18:35:54 <dibblego> that sounds good
18:36:05 <dibblego> I once used "effectual"
18:37:00 <tennin> I'm not sure side-effecting necessarily covers it
18:37:30 <sm> referentially nontransparent  ?
18:37:48 <tennin> a procedure could itself have no side effects, but still be affected by external state
18:43:43 <LordBrain> hmmm... well, that's a little like a side effect tho... being propagated from somewhere else.. but still..
18:45:31 <tennin> yeah, it's just some other procedure's side effect.
18:47:56 <LordBrain> hmmm
18:48:45 <dibblego> I think "effectual"
18:48:49 <LordBrain> well say f produces side effect A, and because of that g behaves differently, couldnt we say that g's new behavior is another side effect B that belongs to g?
18:48:50 <dibblego> or "effecting"
18:49:53 <LordBrain> effectual has another meaning...
18:50:02 <dibblego> what is it?
18:50:40 <LordBrain> effectual means, sufficient to produce a result... so we'd hope all our functions are effectual
18:51:04 <LordBrain> i think "side-effecting" is the clearest...
18:51:47 <dibblego> fair enough
18:53:01 <LordBrain> in haskell.. i distinguish between a->b and a->M b, calling the latter an Action, and the prior a function..
18:54:00 <LordBrain> the reason being that the word function is suggestive of "functional" which implies referential transparency...
18:55:42 <SamB_XP> well the M b *will* be referentially transparent...
18:55:55 <LordBrain> hmmm
18:56:16 <monochrom> he he he
18:57:17 <LordBrain> i'm not sure what you're driving at actually... when will putStrLn be referentially transparent?
18:58:36 <monochrom> Consider (\s -> putStrLn s) :: String -> IO ()
18:58:54 <SamB_XP> well if you say 'greet = putStrLn "Hello, World!"', and then say 'greet >> greet', that is exactly the same as if you said...
18:59:00 <SamB_XP> hold on, I've just got an email
18:59:16 <monochrom> The two greets are the same.
18:59:28 <LordBrain> same as what?
18:59:37 <SamB_XP> eachother ;-)
18:59:52 <monochrom> putStrLn "x" == putStrLn "x"
19:00:18 <LordBrain> does putStrLn "Hi" == put
19:00:27 <LordBrain> does putStrLn "Hi" == putStrLn "There"?
19:00:31 <monochrom> No.
19:00:35 <LordBrain> they're both IO ()
19:00:54 <monochrom> That's fine.
19:01:56 <LordBrain> ok, what do you say to this:
19:02:04 <LordBrain> i say: greet
19:02:28 <monochrom> It is not an important point :)
19:02:32 <LordBrain> the cursor position was at 1,1... now it moves down to the next line, its at 2,1
19:02:43 <LordBrain> i repeate
19:02:46 <LordBrain> greet
19:02:57 <LordBrain> now the cursor moves from like 2 to line 3
19:03:33 <LordBrain> so in the sense that the cursor is in a different position afterword, the two greets are not the same.
19:04:37 <LordBrain> if it was the last line in the terminal window, there is a scroll, so the cursor is in the same position.. if i had the programs output directed to a file, the cursor is not effected by the program.
19:04:46 <SamB_XP> LordBrain: heh
19:05:01 <LordBrain> so in what sense are they, "the same" ?
19:05:08 <SamB_XP> the value "greet" does not represent the resulting screen contents...
19:05:24 <SamB_XP> in fact, it is rather opaque
19:05:32 <SamB_XP> so it isn't clear *what* it represents
19:05:40 <SamB_XP> thats the beauty of monads ;-)
19:05:47 <SamB_XP> they are clear as mud when you need them to be
19:06:28 <LordBrain> i dont mean to be thick
19:06:38 <LordBrain> but i still dont see how that is referential transparency
19:07:50 <SamB_XP> well, it is referentially transparent because you can't tell the difference between two "greet" values
19:07:51 <LordBrain> i suppose if you think of it as a sort of identifier for another program that is to be run....
19:08:07 <SamB_XP> that is pretty much it
19:08:52 <SamB_XP> your program (if you want to be able to compile it and run it as an executable) is after all of type IO ()
19:09:09 <SamB_XP> (the program is Main.main)
19:09:39 <dons> btw, I noticed yesterday that this works:
19:09:39 <dons> main :: IO [Char]
19:09:40 <dons> main = return "foo"
19:09:54 <dons> $ runhaskell A.hs
19:09:55 <dons> "foo"
19:10:20 <LordBrain> well, i am not sure i buy this... it seems like a bit of an equivocation... the side effect still happens as a result of something in our langauge, you are asking me to just pretend it isnt there.
19:11:13 <LordBrain>  why should i pretend?
19:11:41 <SamB_XP> you do not like programs as values?
19:12:07 <LordBrain> hmmm
19:12:28 <LordBrain> i like functional programming
19:12:45 <SamB_XP> only with unsafePerformIO is there a problem
19:13:09 <SamB_XP> and that only got standardized with FFI, IIRC
19:13:48 <SamB_XP> (Before that you needed to use #ifdefs to use it in a program intended to be used with multiple implementations of Haskell)
19:16:58 <LordBrain> well, i need a decent definition for "purely functional" in the statement "haskell is a purely functional language" so.. i guess i could say that means from the standpoint of values it is completely referentially transparent... but if i say a program is referentially transparent when it produces random numbers.. that just seems confusing.
19:17:35 <Korollary> dons: It doesn't work for me (6.4.2).
19:17:35 <SamB_XP> well, the IO stuff allows you to hide referential opacity from the maths ;-)
19:17:37 <LordBrain> hmmm not even sure stand point of values is the way to put it ... if htere is a way to put it... i'm not clear.
19:18:10 <LordBrain> yeah
19:18:16 <dons> Korollary: right. I was surprised!
19:18:16 <Korollary> LordBrain: Referential transparency does not apply to prgrams. It applies to expressions.
19:18:24 <dons> Korollary: bug? feature? magic?
19:18:35 <int-e> LordBrain: the side effects take place outside of Haskell. Think of IO a as a value that describes an action on the outside world.
19:18:48 <SamB_XP> you hide it in warm fuzzy bundles, and it does not come out until you run the program
19:18:51 <Korollary> dons: H98 says main :: IO a, but it doesn't say what the implementation does if a is not ().
19:19:02 <dons> ah ha
19:19:08 <LordBrain> hmm
19:19:22 <LordBrain> ok
19:19:24 <dons> $ runhugs A.hs
19:19:24 <dons> $ runghc A.hs
19:19:24 <dons> "foo"
19:19:30 <SamB_XP> heh
19:19:54 <SamB_XP> that could be a bug but it isn't a violation by any means...
19:19:55 <Korollary> dons: even main :: IO (a -> a), main = return id works. (does nothing of course)
19:20:14 <SamB_XP> and I kinda doubt that it is a bug
19:20:24 <LordBrain> well i will accept this... but i cant really say teh program itself is referentially transarent.. becuase it's going to be run outside of haskell, i'm going to go to my prompt and type in $./giveMeRandomNumber
19:20:40 <LordBrain> its run in bash
19:20:46 <Korollary> dons: Does it work for every instance of Show? Try [String] or (Bool, Bool) or something.
19:20:58 <LordBrain> (some other shell for you possibly)
19:21:06 <SamB_XP> well, we could give you a bunch of rhetoric about the program being a function of the environment
19:21:15 <int-e> Sure, it's not. But everything you wrote was referentially transparent - it's the run time system (that executes the IO .. from main) that causes the side effects.
19:21:18 <SamB_XP> but it wouldn't be true, because the environment changes ;-)
19:22:47 <int-e> You can do that, too.
19:23:34 <SamB_XP> Korollary: it obviously doesn't work for ()
19:24:45 <LordBrain> well i understand what you are saying, but i think the terminology probably should be improved some... i did write the program that was executed after all, by the usual understanding of what that phrase means.
19:24:51 <dons> SamB_XP: right. which is weird, ()
19:25:13 <dons> yep, (Integer,Integer) works
19:25:22 <Korollary> LordBrain: Terminology is fine. as I said, RT applies to expressions, not to programs.
19:25:28 <SamB_XP> LordBrain: well, you don't question the dual nature of light, do you?
19:26:25 <dons> main = return (M.empty :: M.Map Int (Either () Bool))
19:26:26 <dons> $ runhaskell A.hs
19:26:26 <dons> fromList []
19:26:28 <dons> !
19:26:38 <dons> so looks like we have a fun little feature.
19:26:51 <LordBrain> Korollary: that works...
19:26:51 <dons> nice and old school, these programs that print their value
19:27:37 <SamB_XP> Korollary: what is the difference between an expression and a function?
19:27:42 <SamB_XP> er, program...
19:27:47 * SamB_XP is silly
19:28:07 <mcoury> @listcommands
19:28:07 <lambdabot> Unknown command, try @list
19:28:09 <LordBrain> i find Korollary's terminology clearer
19:28:20 <mcoury> @list
19:28:20 <lambdabot> list [module|command]. Where modules is one of:
19:28:21 <lambdabot> babel base compose dice dict djinn drhylo dummy elite eval fact fresh haddock help hoogle instances karma lambda localtime log more pl poll pretty quote search seen slap spell state system tell todo
19:28:21 <lambdabot> topic type unlambda url version vixen where
19:29:20 <LordBrain> tho i understand why you would ask that too SamB_XP ... i've seen a lot of usage of terms in different ways, its not always clear... sometimes "program" does refer to teh expression, and sometimes not.
19:29:28 <dons> $ runhaskell A.hs
19:29:29 <dons> fromList [((True,Just (8,"foo")),Left [<<Char>>])]
19:29:36 <dons> for example :)
19:29:54 <SamB_XP> LordBrain: I suppose the program is the *value* of the expression, and the expression is some version of the syntax tree
19:30:04 <SamB_XP> most likely
19:30:07 <LordBrain> if i just say main = ... lamdabot will write it to a file called A.hs?
19:30:19 <SamB_XP> huh?
19:30:24 <SamB_XP> > main = ...
19:30:24 <lambdabot>  Parse error
19:30:38 <LordBrain> i'm looking at what dons is doing
19:30:40 <SamB_XP> > main = putStrLn "Hi!"
19:30:41 <lambdabot>  Parse error
19:30:51 <LordBrain> main = putStrLn "Hi"
19:31:02 <LordBrain> $ runhaskell A.hs
19:31:07 <SamB_XP> heh
19:31:14 <dons> hehe. not quite
19:31:16 <SamB_XP> notice that dons is the one saying the results too?
19:31:18 <LordBrain> maybe my eyes got fooled.
19:31:29 <SamB_XP> if it were lambdabot...
19:31:30 <dons> or is it donsbot!
19:31:32 <dons> who knows!?
19:31:41 <SamB_XP> lambdabot would tell you the results
19:31:41 <dons> yah, I like
19:31:46 <LordBrain> yeah.. i remember lamdabot cant do IO
19:31:49 <dons> functional programmers are so hot!
19:32:02 <LordBrain> lol
19:32:09 <SamB_XP> dons: do you like lazy evaluation?
19:32:33 <dons> yah, i like
19:32:40 <SamB_XP> that took you a long time
19:32:51 <dons> where on a map is Panama?
19:32:53 <SamB_XP> I was expecting you to say that right away!
19:33:03 <dons> i'm always right!
19:33:06 <SamB_XP> probably somewhere in central america?
19:33:16 <dons> oh, how far is that from California?
19:33:25 <SamB_XP> dunno
19:33:36 <SamB_XP> my geography skills are practically none
19:33:38 <dons> If something takes a lot of effort to do, it probably ain't worth doing.
19:33:47 <dons> why do you keep repeating yourself?
19:34:00 <dons> donsbot: @quit
19:34:02 <dons> Byte!
19:34:28 <dons> huh. I had "byte" in my spinal memory, instead of "bye"
19:34:41 <dons> i think i'm suffering geek syndrome
19:34:45 <SamB_XP> heh
19:35:23 <SamB_XP> I know someone who say she wants to learn to program, just to complete her geekiness ;-)
19:35:33 <dibblego> nobody has ever thought they were suffering geek syndrome and they weren't
19:35:39 <edwardk> hrmm. anyone feel like helping me figure out a type level xor? =)
19:35:56 <SamB_XP> dibblego: I contend that dons isn't suffering ... much ;-)
19:35:58 <LordBrain> right on cue
19:36:31 <dons> btw, more geekiness, i tweaked these graphs just a tad, http://www.cse.unsw.edu.au/~dons/irc/
19:36:31 <dibblego> SamB, the very thought is inextricably linked with geek syndrome; it is itself descriptive - not just a symptom
19:36:31 <lambdabot> Title: Haskell IRC Activity
19:36:44 <dons> dibblego: indeed!
19:36:51 <dibblego> I should not talk crap on IRC during lunch breaks
19:37:14 <dons> my gf  says that just using the word "geek" is the mark, the sign
19:37:39 <dibblego> that is an oxymoron
19:37:49 <dibblego> a girlfriend cannot tell a geek that they are a geek
19:37:56 * edwardk wants type level roman numbers.
19:37:56 <dibblego> since the girlfriend is mutually exclusive
19:37:57 <edwardk> rmm.
19:37:58 <edwardk> =)
19:38:16 <SamB_XP> dibblego: clearly your knowledge of geekdom is lacking in depth ;-)
19:38:18 <dons> heh
19:38:19 <edwardk> (to one up qvickbasic) =)
19:38:28 <dibblego> SamB, quite possibly :)
19:38:35 <dons> unless the gf too is a closet geek..
19:38:47 <dons> living in denial
19:38:58 <SamB_XP> dons: I don't see how that changes anything
19:39:19 <SamB_XP> I mean, dibblego said a having a gf and being a geek are mutually exclusive
19:39:30 <SamB_XP> never said anything about the gf being a geek or not
19:39:45 <dons> sure. i contend that this does indeed change the rule
19:39:47 <dibblego> perhaps the generalisation needs refining
19:40:27 <SamB_XP> I don't think it is true either way
19:40:40 <SamB_XP> because I'm pretty sure there are some geeks who have un-geeky GFs
19:40:47 <SamB_XP> maybe they don't stay that way forever
19:40:47 <dons> it may be so
19:40:48 <dibblego> http://books.slashdot.org/books/06/08/02/1455241.shtml "Remember, these are objects, and Java never passes objects by value -- always by refence."
19:40:49 <lambdabot> Title: Slashdot | Java Regular Expressions
19:40:59 <dibblego> oops, you guys don't care
19:41:18 <SamB_XP> there are a *lot* of poeple in the world, after all...
19:41:22 <edwardk> depends, the geek gf is a strange creature. she usually has something she is geeky about, be it art, linguistics, capoeira, or in my gf's case all 3 =)
19:41:34 <dibblego> edwardk, and has hairy underarms
19:41:48 <SamB_XP> there are people without hairy underarms?
19:41:49 <edwardk> some of them perhaps =)
19:42:26 <LordBrain> lol
19:43:02 <SamB_XP> is *that* why they always call us stinky!
19:45:10 <dibblego> just remembered I gotta go pick up my headset - there are bets on whether it will "just work" (on my Linux machine)
19:45:20 <dibblego> so no more talking crap! bye!
20:01:06 <LordBrain> head set as in speaker and mic... that should just work as long as your sound card works
20:17:37 <SamB> oh, hmm...
20:19:46 * SamB finds a problem in his solver...
20:20:13 <SamB> apparantly I need to sort the lists of missing things...
20:23:20 <int-e> :)
20:25:12 <SamB_XP> I was getting "Prelude.head: empty list" and the only call that could have done that is the one that takes the first result that matches the criterion... and it was much too quick to have gone through the whole tree, unless I've really trimmed the tree... plus I'm pretty sure all of these puzzles are solvable ;-)
20:25:25 <SamB> oh, cool
20:25:30 <SamB> I got something already!
20:28:13 <SamB> it goes faster now that it will only incinerate items that have just been picked up, and will only combine an item with another if one has just been picked up...
20:28:33 <SamB> this keeps it from having all kinds of differently ordered trees leading to the same result...
20:28:52 <SamB> er, differently ordered paths...
20:29:56 <SamB> oh actually it also considers combining when one of the items is the result of a recent combination
20:30:31 <SamB> of course, I suppose it still has a little bit of redundancy in the tree...
20:30:57 <SamB> with incineration being able to be exchanged with combination still...
20:31:02 <SamB> but meh...
20:32:37 <edwardk> samb: you know template haskell, right? =)
20:32:45 <SamB> not too much
20:32:52 <SamB> why?
20:32:53 <edwardk> heh, saw your name on the wiki page =)
20:33:03 <SamB> oh, well, I did contribute something there yes ;-)
20:33:09 <edwardk> trying to get something to work but i know crap about TH
20:33:17 <SamB> it may be of use to you too
20:33:31 <edwardk> basically want something like $(tBinary 23)
20:33:38 <edwardk> to generate my type level binary
20:33:42 <edwardk> tBinary :: Integral a => a -> ExpQ
20:33:43 <edwardk> tBinary n = [|parse n|]
20:33:43 <edwardk>         where
20:33:43 <edwardk>                 parse 0  = conP "F" []
20:33:43 <edwardk>                 parse -1 = conP "T" []
20:33:43 <edwardk>                 parse n  = conP (parse $ n `div` 2) [if (n `mod` 2) == 0 then "O" else "I"]
20:33:48 <edwardk> was my random guess at syntax =)
20:33:52 <edwardk> but it doesn't seem to like me =)
20:34:13 <SamB> uh
20:34:23 <edwardk> probably totally on crack
20:34:32 <SamB> could you paste that to the pasteboard?
20:34:35 <edwardk> woops
20:34:36 <edwardk> sure
20:34:41 <edwardk> @paste
20:34:42 <lambdabot> http://paste.lisp.org/new/haskell
20:34:46 * SamB is too lazy to take out all the <edwardk>s before changing it ;-)
20:35:02 <lisppaste2> edwardk pasted "crap" at http://paste.lisp.org/display/23577
20:35:40 <edwardk> basically T and F are data types without type constructors (now that i think about it) and O and I are also data types without constructors
20:36:01 <edwardk> the other thing is its complaining at the [| point, not later so i figure i'm seriously being dense
20:36:41 <SamB> okay, don't you want things with names ending in T?
20:36:50 <SamB> @hoogle TH
20:36:51 <lambdabot> Language.Haskell.TH :: module
20:36:51 <lambdabot> Text.Html.th :: Html -> Html
20:36:51 <lambdabot> Data.Graph.Inductive.Internal.Thread :: module
20:36:58 <SamB> @docs Language.Haskell.TH
20:36:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/template-haskell/Language-Haskell-TH.html
20:37:05 <edwardk> the types are T F O and I
20:37:16 <edwardk> if the function should be named with a T on the end by convention so be it
20:38:54 <edwardk> my ideal version would just return the type, but returning an undefined of the appropriate type woud be cool too
20:39:11 <edwardk> not sure if the former is possible with TH
20:39:15 <edwardk> since i know very little about it
20:39:38 <SamB> you wanted this to give you a type didn't you?
20:39:41 <SamB> rather than a value?
20:39:49 <edwardk> would be preferable
20:40:08 <edwardk> otherwise it'll have to be manipulated through the witness functions
20:40:08 <glguy> Are there technical reasons that ghc 6.4.2 isn't in OpenBSD's ports yet? or is the maintainer just not interested anymore?
20:40:24 <dons> the maintainer is too busy
20:41:05 <dons> however, ghc's head branch is kept working on openbsd -- support won't disappear
20:41:39 <glguy> What do you think that the most interesting feature added in 6.5 is?
20:41:55 <dons> hmm. there's so many!
20:42:05 <lisppaste2> SamB annotated #23577 with "hopefully less crap" at http://paste.lisp.org/display/23577#1
20:42:08 <dons> Data.ByteString :)
20:42:21 <glguy> to allow for efficient binary IO?
20:42:21 <dons> maybe that's not so interesting. smp rts?
20:42:29 <glguy> rts?
20:42:29 <dons> efficient string/binary IO
20:42:31 <SamB> edwardk: how is that?
20:42:45 <dons> the smp runtime system. threads run on multi cores now
20:42:51 <edwardk> will give it a shot =)
20:43:48 <glguy> can I download ghc HEAD with darcs?
20:43:53 <glguy> (openbsd)
20:43:54 <dons> indeedy
20:44:25 <dons> $ cat _darcs/prefs/repos | head -1
20:44:25 <dons> http://darcs.haskell.org/ghc
20:44:25 <dons> $ uname -msr
20:44:25 <dons> OpenBSD 3.8 i386
20:44:28 <lambdabot> Title: Index of /ghc
20:45:14 <glguy> 3.8 , eh?
20:45:44 <dons> too busy to update
20:45:56 <edwardk> wrestling with my limited knowledge of patterns, one sec sam
20:46:14 <SamB> patterns?
20:46:27 <glguy> are there any known major bugs in 6.5 that i should look out for?
20:46:48 <dons> well, its very unstable at the moment
20:46:57 * SamB did not test his, but hopes it is at least closer to the mark
20:46:58 <dons> i'd use 6.4.2 if at all possible
20:47:14 <dons> or else pick a src snapshot from before the 25th
20:47:20 <glguy> if you had to choose between 6.2.2 and 6.5 on this machine, what would you say
20:47:30 <dons> I'd use 6.4.2
20:47:32 <SamB> edwardk: yours would have made patterns appropriate for a case construct
20:47:35 <dons> though, actually, I do use 6.5
20:47:38 <SamB> if it worked
20:47:52 <SamB> and those brackets were not good
20:47:54 <glguy> What generating all the instability, any particular feature?
20:48:09 <dons> yes, there's a rewrite of the package handling code happening
20:48:16 <dons> any reason not to use the stable branch?
20:48:29 <glguy> does it compile on openbsd?
20:48:33 <edwardk> do i have to app the type constructor to the list sam?
20:48:33 <dons> yes
20:48:39 <glguy> just not in ports?
20:48:46 <dons> $ ghc-6.4.2 --version
20:48:47 <dons> The Glorious Glasgow Haskell Compilation System, version 6.4.2
20:48:51 <dons> its just not in ports.
20:48:53 <edwardk> and yeah its become a case =)
20:48:57 <glguy> ok, that works then
20:49:04 <dons> the compilers all work on openbsd since around 4.08.2
20:49:12 <SamB> edwardk: I don't remember what the list is for, to tell the truth
20:50:12 <SamB> actually conT doesn't take a list
20:50:15 <SamB> okay...
20:50:24 <glguy> the ByteString support sounds interesting, how many months are we talking before 6.6 comes around?
20:50:45 <dons> about 1.5months
20:50:52 <SamB> edwardk: oh, you might need to do more work on the names...
20:50:56 <dons> but ByteString is available for 6.4.x as well
20:51:01 <dons> you just have to install it separately
20:51:02 <glguy> 1.5 months, eh, that sounds pretty exact :)
20:51:06 <SamB> just work through any type errors you encounter and you should figure it out ;-)
20:51:09 <glguy> are you sure it's not 1.50 months ;)
20:51:46 <SamB> > ::True
20:51:47 <lambdabot>  Parse error
20:51:52 <SamB> > :True
20:51:52 <lambdabot>  Parse error
20:51:53 <glguy> True isn't a type
20:52:00 <SamB> dons: you don't parse TH! why!
20:52:21 <SamB> I suppose I already asked this question?
20:52:41 <dons> you did
20:52:51 <dons> and I said: "patchify!"
20:53:01 <SamB> oh is that what you said?
20:53:10 <SamB> hard-disk-ify!
20:53:28 <lisppaste2> edwardk annotated #23577 with "it compiles... not sure it means what i think it means" at http://paste.lisp.org/display/23577#2
20:53:34 <edwardk> =)
20:54:01 <edwardk> i can't use template haskell in the interactive thingy can i?
20:54:26 <dons> sure
20:54:46 <glguy> could you show an example?
20:54:53 * glguy has never seen Template Haskell
20:54:54 <edwardk> parse error on $( hrmm
20:54:57 <edwardk> what am i missing?
20:55:14 <edwardk> glguy: sure as soon as it works =)
20:55:39 <glguy> I mean an example one-liner with lambdabot
20:56:07 <glguy> nevermind, edwardk was probably asking if you could use template haskell in ghci
20:58:37 <SamB> edwardk: :set -fth
20:58:40 <SamB> I think
20:59:19 <SamB> > $(conE "True")
20:59:20 <lambdabot>  Parse error
20:59:23 <SamB> hmm
20:59:30 <SamB> > id $(conE "True")
20:59:31 <lambdabot>  Couldn't match `Name' against `[Char]'
20:59:35 <SamB> cool
21:00:20 <edwardk> holy crap it worked =)
21:00:47 <lisppaste2> edwardk annotated #23577 with "neat" at http://paste.lisp.org/display/23577#3
21:01:04 <edwardk> now i can $(tNum 12) to get back an undefined value of the appropriate type
21:01:11 <edwardk> despite my lack of type constructors, etc.
21:01:28 <edwardk> ugly as sin
21:01:35 <SamB> > id $(conE $ mkName "True")
21:01:37 <lambdabot>  True
21:01:47 <SamB> see, that is a silly one-liner for lambdabot
21:01:53 <edwardk> heh
21:01:53 <glguy> > undefined `asTypeOf` 1
21:01:55 <lambdabot>  Undefined
21:02:04 <SamB> the id is only there to trick lambdabot into thinking that it is ordinary Haskell
21:02:12 <dons> good idea SamB
21:02:15 <edwardk> my type is distinct per number glguy, not so easy =)
21:02:24 <glguy> ah
21:04:42 <edwardk> *Type.Binary> $(thNum 123900)
21:04:42 <edwardk> O (O (I (I (I (I (I (I (I (I (O (O (O (I (I (I (I F))))))))))))))))
21:05:23 <edwardk> much handier than: one `hundred` twenty three `thousand` nine `hundred` twenty two =)
21:06:13 <dons> heh
21:10:24 <SamB_XP> I'm thinking it is also nicer to implement?
21:10:48 <glguy> and much more useful than a boring old Int
21:11:05 <edwardk> yeah
21:11:19 <edwardk> i just want it for array bounds, and well, to see if i could do it
21:11:51 <glguy> this is something that would be common in epigram, right?
21:12:06 <SamB_XP> edwardk: are you studying up to become the next oleg?
21:12:15 <SamB_XP> or just trying to picture yourself in the role?
21:12:31 <edwardk> just bored easily
21:12:53 <edwardk> and i find the fastest way to learn a language is to spend a lot of time poking around its dark corners
21:15:22 <monochrom> The Dark Side of Haskell!
21:15:23 <SamB_XP> try the light corners as well
21:15:25 <SamB_XP> they are fun too
21:15:31 <edwardk> heh
21:15:35 <edwardk> i'll get there
21:15:46 <edwardk> the jit and this are just my walk on the absurd side =)
21:16:01 <monochrom> Oleg is using his telepathy to whisper to you: come join the Dark Side!
21:16:08 <SamB_XP> and watch out for the killer dustbunnies
21:16:25 <SamB_XP> monochrom: I didn't know you could achieve telepathy via the type system!
21:17:19 <monochrom> He's using the kind system!
21:17:30 <SamB_XP> that sounds even more farfetched
21:17:41 <SamB_XP> I don't think the kind system is even turing complete!
21:17:51 <edwardk> yeah, i think he has been communing with me through my substructural pure type system.
21:18:04 <monochrom> heh heh heh
21:24:06 <edwardk> i just can't figure out xor =(
21:24:38 <edwardk> i have a dumb one, but the fundeps only go one ay
21:24:57 <edwardk> i can't seem to figure out how to make them go a b -> c, b c -> a, c a -> b
21:25:04 <edwardk> like my boolean one
21:25:15 <SamB_XP> maybe you need to turn your numbers inside out?
21:25:24 <SamB_XP> or did you do that already?
21:25:42 <edwardk> well, the problem isn't the directionalty i think, its the fact that i normalize them by collapsing their length
21:25:57 <SamB_XP> oh oh
21:26:02 <edwardk> and getting that to work via fundeps in 3 directions is hard
21:26:11 <SamB_XP> that does sound tricky
21:26:25 <edwardk> i got the adder working before i had a working and
21:26:28 <SamB_XP> maybe you should have helper classes
21:26:29 <edwardk> sad eh?
21:26:43 <edwardk> yeah got one, i can't use it repeatedly to get the right behavior though
21:26:45 <edwardk> tried =)
21:28:06 <edwardk> trying one more trick
21:30:56 <edwardk> hahahhahaa
21:30:58 <edwardk> it works!
21:31:11 <edwardk> i had to derive from all three for the parent class AND construct the instance
21:31:26 <edwardk> class (TXOr' a b c, TXOr' b c a, TXOr' c a b) => TXOr'' a b c | a b -> c, b c -> a, c a -> b
21:31:26 <edwardk> instance (TXOr' a b c, TXOr' b c a, TXOr' c a b) => TXOr'' a b c
21:31:50 <edwardk> so i just have to change my boolean base class to provide a semi-xor
21:31:55 <edwardk> and i can recycle it
21:32:57 <edwardk> woops
21:36:51 <glguy> when discussing the curry-howard isomorphism, how would I read:   |->
21:41:32 <Cale> glguy: that symbol generally means "maps to"
21:41:40 <glguy> thanks
21:41:58 <LordBrain> dons you here?
21:42:17 <LordBrain> anyone here use hscurses?
21:42:50 <LordBrain> i seem to be missing a function called color_set
21:43:20 <dons> hmm
21:43:39 <dons> /usr/include/ncurses.h:extern NCURSES_EXPORT(int) color_set (short,void*);
21:44:26 <LordBrain> should this be in HSCurses.Curses ?
21:44:33 <LordBrain> as say.. colorSet ?
21:44:47 <dons> I use attrSet in my curses bindings
21:45:00 <LordBrain> ok.. i wasnt sure color counted as an attribute
21:45:05 <dons> so its possible this is a linux/gnu extension?
21:45:16 <LordBrain> well i read about it in a bsd man page
21:45:38 <LordBrain> curses is huge tho.. it's fine with me if you dont support the whole thing
21:47:06 <LordBrain> here's my problem.. i used color "cyan" and that gave me something of type Color (newtyped from int) ... without color_set i'm not sure if that value is any good to me
21:47:16 <dons> yeah, if you look at the Curses.hsc in hmp3, it uses a minimal portable set.
21:47:27 <dons> i think hscurses attempt to bind to the whole lib
21:47:35 <dons> the ncures/linux api too
21:47:46 <LordBrain> hmm
21:48:19 <dons> so probably if you're careful, and follow hmp3'/Curses.hsc, you can use hscurses too in a portable manner
21:48:42 <dons> http://www.cse.unsw.edu.au/~dons/code/hmp3/Curses.hsc
21:52:12 <LordBrain> the Attr type has no constructors?
21:52:26 <LordBrain> is that equivalent to data Attr = Attr ?
21:53:19 <dons> hmm? newtype Attr = Attr CInt
21:53:35 <dons> you use the functions to get at this thing
21:55:15 <LordBrain> for example, how do i use attrSet to set the foreground to cyan, supposing i know that: color "cyan" == p
21:55:42 <LordBrain> i dont know what the Attr parameter on attrSet is
21:55:58 <LordBrain> atterSet (something) p
21:56:13 <dons> I use the withStyle functions
21:56:32 <dons> http://www.cse.unsw.edu.au/~dons/code/hmp3/Style.hs
21:57:10 <dons> which call attrSet >> color >> attrReset
21:57:12 <dons> i think
21:58:15 <LordBrain> ok
21:58:44 <LordBrain> in hscurses its in the CursesHelper module
21:59:10 <LordBrain> is hmp3 mosly compatible to a subset of hscurses ?
21:59:17 <dons> right
21:59:30 <dons> its the minimal subset that gets color working
21:59:38 <dons> enough to do hmp3's ui
21:59:38 <LordBrain> maybe i should be using it instead for the tutorial
22:00:01 <dons> possibly. but its not packaged up as its own package
22:00:19 <LordBrain> well.. what does yi use?
22:00:23 <dons> which is a little annoying. i should do that at some point
22:00:34 <dons> yi uses a variant of hmp3s
22:00:39 * edwardk gets bored and looks around for more unexplored corners of haskell.
22:00:40 <dons> actually, it might be the same
22:01:02 <dons> edwardk: write something with GADTs , FDs and implicit params.
22:01:20 <SamB_XP> dons: :-P
22:01:38 <edwardk> tried implicit params, don't like em. using LOTS of FDs, and using GADTs in the js stuff
22:01:50 <dons> ok. how about STM?
22:01:56 <LordBrain> hmp3 doesnt have widgets tho right?
22:01:58 <edwardk> STM i'm comfortable with
22:02:00 <SamB_XP> yeah, I don't like implicit params either
22:02:10 <dons> LordBrain: no not really. it uses a pretty printer (UI.hs) to draw boxes
22:02:21 <edwardk> first thing i did when i got here was that hash thingy
22:02:25 <SamB_XP> they are an abuse of the typeclass system...
22:02:31 <dons> edwardk: hmm, ok, write a lambdabot plugin then...
22:02:31 <LordBrain> that sounds much simpler tho less powerful
22:02:43 <edwardk> hehehe
22:02:58 <edwardk> had my fling with plugins
22:03:16 <edwardk> the 2 days trying to find my missing Maybe kinda turned me off them for the nonce
22:03:21 <LordBrain> anyway, since i'm going to use stefan's ContactsManager.hs as a base for one of the examples, i should stick to hscurses... but maybe i should make the simpler programs run in both... and make a note about it
22:03:42 <dons> LordBrain: yeah good idea. just stick to the portable subset that hmp3 also uses
22:04:33 <LordBrain> you say you dont have it packaged... is everythign in those two modules you showed me?
22:05:02 <dons> UI.hs Style.hs and Curses.hsc, I think
22:05:44 <dons> and UI.hs isn't just an example of how to use the other two
22:05:49 <dons> s/is/
22:06:14 <LordBrain> ok.. well give me a link to each, i'll download them to a directory to play with
22:06:30 <dons> ?where hmp3
22:06:31 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
22:06:38 <dons> grab the darcs repo, delete things you don't need
22:09:10 <LordBrain> oh... i used the tar ball
22:09:17 <LordBrain> better i use darcs?
22:10:52 <LordBrain> the three files in question are the same either way..
22:11:03 <LordBrain> anyway.. i got the darcs version
22:13:34 <dons> yeah, its all fine
22:13:58 <dons> one thing is that my Curses.hsc uses bytestrings, so I can do more efficient drawing
22:14:07 <dons> not sure if that's needed for a tutorial
22:16:43 <LordBrain> i'm going to have to play with things more
22:17:27 <LordBrain> i made a hscurses version of the bouncing ball... but it could demonstrate more if i put colors in and things like that.
22:17:57 <dons> right.
22:18:14 <SamB_XP> now all you need is some music ;-)
22:29:14 <LordBrain> i think it might run more smoothly if i give i tell it when to garbage collect
22:29:25 <LordBrain> i remember seeing something like that...
22:29:34 <LordBrain> anyone know how to do that?
22:30:04 <LordBrain> i suppose its not important
22:30:08 <dons> ?index performGC
22:30:09 <lambdabot> System.Mem
22:30:11 <dons> you mean?
22:30:20 <fraxtal> serious question
22:30:38 <fraxtal> why shouldn't I be able to do this
22:30:42 <fraxtal> [1..5] : 6
22:31:02 <dons> the types :)
22:31:05 <dons> ?type (:)
22:31:07 <lambdabot> forall a. a -> [a] -> [a]
22:31:08 <LordBrain> because : is cons not snoc
22:31:11 <dons> takes an element, and a list
22:31:19 <dons> you've got it the other way around
22:31:28 <dons> > [1..5] ++ [6]
22:31:29 <lambdabot>  [1,2,3,4,5,6]
22:31:42 <dons> > 6 : [1..5]
22:31:43 <lambdabot>  [6,1,2,3,4,5]
22:31:56 <dons> its a singly linked list, so you can only cons onto the front
22:32:04 <fraxtal> right
22:32:12 <fraxtal> but why can't there be another version of it
22:32:21 <dons> there could be
22:32:23 <fraxtal> that sticks an element on the end of a list
22:32:23 <LordBrain> a snoc list?
22:32:38 <dons> > let snoc xs c = cs ++ [c] in [1..5] `snoc` 6
22:32:39 <lambdabot>  Not in scope: `cs'
22:32:43 <dons> > let snoc xs c = xs ++ [c] in [1..5] `snoc` 6
22:32:45 <lambdabot>  [1,2,3,4,5,6]
22:33:05 <dons> > let xs <: c = xs ++ [c] in [1..5] <: 6
22:33:07 <lambdabot>  [1,2,3,4,5,6]
22:33:27 <LordBrain> you want it to be the same symbol?
22:33:35 <fraxtal> yea is that possible
22:33:37 <dons> remember the efficiency issues though. it's O(n), whilst cons is O(1)
22:34:07 <LordBrain> you can make your own list type tho so that snoc is O(1)
22:34:22 <dons> sure, difference lists. Show uses this
22:35:50 * xerox yawns
22:35:51 <xerox> 'morning
22:36:10 <fraxtal> could there exist a list type where snoc and cons is O(1)
22:36:15 <LordBrain> yes
22:36:24 <LordBrain> a doubly linked list
22:36:35 <fraxtal> ok
22:38:20 <fraxtal> couldn't that be the norm?
22:39:08 <SamB_XP> LordBrain: not in Haskell, I don't think...
22:39:12 <LordBrain> well, remember how [1,2,3,4] is sugar for 1:2:3:4:[]
22:39:16 <dons> not as nice for inductive reasoning
22:39:20 <dons> think about the pattern matching
22:39:53 <SamB_XP> that is, not doubly-linked lists
22:40:01 <LordBrain> if i snoc on to that, i get 1:2:3:4:[]<:5
22:40:21 <LordBrain> where <: is snoc
22:41:07 <LordBrain> now... you can define = for this type so that that is compared equally to 1:2:3:4:5:[]
22:41:40 <LordBrain> but what about when you are iterating and things.... pattern matching like dons said
22:42:21 <fraxtal> No idea, i've only been playin with it for a few minutes
22:42:38 <LordBrain> you will make every function which iterates over a list more complicated
22:43:12 <Cale> actually, 2-3 finger trees do it too
22:43:21 <Cale> and are more natural in Haskell
22:43:36 <Cale> Data.Sequence in the development GHC implements such a structure
22:43:54 <Cale> http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Sequence.html
22:44:25 <Cale> It has O(1) cons and snoc, O(log(min(n1,n2))) concatenation, and lots of other good properties
22:44:41 <Cale> But it can't handle infinite lists, I don't think.
22:44:42 <LordBrain> cool
22:45:42 <Cale> splitAt is O(log(min(i,n-i))), from which you can derive the fact that lots of other common functions have that complexity too
22:46:01 <fraxtal> So if we had O(1) cons and snoc lists as the norm, the code would actually become more complicated instead of less complicated
22:46:09 <LordBrain> i'm not sure what i and n are
22:46:23 <Cale> LordBrain: position of index, and length of the sequence
22:46:30 <LordBrain> ok
22:47:03 <Cale> fraxtal: It's not easy to write cute recursive functions, or lazy functions.
22:47:16 <Cale> The reason lists are popular in Haskell is the same reason loops are popular in C.
22:47:50 <Cale> They're the data structure embodiment of linear recursion
22:49:12 <LordBrain> what will ++ do?
22:49:49 <Cale> hm?
22:49:52 <Cale> on what? :)
22:50:02 <LordBrain> i saw an example of a mixed snoc and cons data structure somewhere
22:51:25 <LordBrain> i dont recall exactly but i think it allowed strange things .. it became not so much a list any more but a tree, because you could have cons then snoc then cons then snoc...
22:52:04 <Cale> yeah
22:52:54 <Cale> ah, you could make ++ primitive rather than :
22:53:19 <Cale> You'd essentially get binary trees with labelled leaves
22:56:09 <Cale> from which it would be possible to get good performance, but good performance wouldn't be automatic -- you'd need to try to keep things balanced if you wanted to keep things like indexing fast.
22:58:58 <LordBrain> i suppose you could have the compiler take over the data structure
22:59:08 <LordBrain> make it an optimization decision
23:01:02 <ibid> Cale: isn't that the idea in ropes
23:02:51 <edwardk> pretty much is, but rope have more than just the tree type
23:03:07 <LordBrain> since everything is boxed and pointers all the same size on x86 usually... really lookup shouldnt have to be O(n)... it doesnt seem to me.
23:03:24 <edwardk> you have some point and region replacement primitives, one for tail appenditures, usually some reference counting so you can do inplace updates
23:03:37 <LordBrain> we could just use arrays of pointers for lists
23:04:36 <LordBrain> just run into a problem if we run out of allocated memory
23:08:24 <dons> I think 'realloc' is usually preferred to 'problem' ;)
23:08:41 <LordBrain> maybe.. have some standard block size of contiguous memory for optimizing lists into linked-lists of arrays
23:09:06 <dons> anyway, arrays of ptrs is roughly the data parallel haskell library :)
23:09:21 <LordBrain> data parallel?
23:09:25 <dons> a list interface to (fuseable, parallel) arrays of boxed (and unboxed) values
23:11:29 <LordBrain> realloc might necessitate moving memory around
23:11:55 <dons> quite so
23:12:27 <LordBrain> well.. i'm off to bed
23:12:41 <LordBrain> see yas tomorrow
23:31:08 <lispy> hi
23:33:02 <dons> heya lispy
23:34:37 <lispy> looks like darcs has new blood
23:34:57 <lispy> someone is trying to get the command hooks to pass env variables
23:35:05 <lispy> but System.Cmd.system won't let you set the env
23:35:18 <vincenz> grr
23:35:24 <dons> yeah
23:35:28 <lispy> so he tried using System.Process.runProcess, but that doesn't invoke the shell :(
23:35:43 <vincenz> Wake up early to get to work early, and there's no water cause they
23:35:47 <lispy> do you think it would work to set the env in the parent process before calling system?
23:35:48 <vincenz> 're working on the pipes
23:35:53 <dons> hey vincenz, blog integration into my .css, http://cgi.cse.unsw.edu.au/~dons/blog
23:35:54 <lambdabot> Title: Haskell, hacking and other stuff
23:35:59 <lispy> vincenz: wow, that sounds very familiar
23:36:05 <vincenz> dons: neat :)
23:36:13 <lispy> vincenz: our water was out on Monday
23:36:23 <lispy> vincenz: and I have to be at work by 7:30 am tomorrow :)
23:36:25 <lispy> @localtime lispy
23:36:28 <lambdabot> Local time for lispy is Wed Aug  2 23:36:03 2006
23:36:33 <vincenz> lispy: ouch
23:36:35 <lispy> perhaps i should sleep soon :)
23:36:42 <vincenz> dons: how do you do syntax coloring
23:37:29 <dons> HsColour
23:37:32 <dons> ?where HsColour
23:37:33 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/hscolour/
23:40:38 <fraxtal> Do you guys think that GHC can produce code that's fast enough to do motion tracking in video
23:40:56 * xerox departs for AngloHaskell!
23:40:58 <xerox> Byeeee.
23:41:04 <dons> fraxtal: maybe?
23:41:09 <dons> what does that involve?
23:41:41 <vincenz> dons: imageblock matching
23:41:51 <vegai> hmm, you know the lisp "Made with Alien Technology" -logo?
23:42:15 <vegai> somebody oughta make one for Haskell, with an Ur-Quan posing as the alien
23:42:18 <fraxtal> lots of convolutions and correlations
23:42:31 <dons> what do you normally write such code in? C++?
23:42:56 <dons> what kind of data structures?
23:43:06 <Korollary> matrices
23:43:18 <fraxtal> probably
23:43:23 <dons> you'd probably want to bind to a fast C matrix lib
23:43:30 <mahogny> hm. I think motion tracking can be done in many ways
23:43:39 <fraxtal> I'm not too familiar with it, but i'm taking a class on Imaging and Machine Learning in the fall
23:44:11 <mahogny> but just matrices might not be enough. it is likely that you might have to manipulate them manually. in that case, I guess some FFI:ing to C is needed
23:46:11 <vincenz> fraxtal: use matlab?
23:46:15 <fraxtal> that may cause some nausea
23:46:36 * vincenz did all his ML and CV stuff with matlab
23:46:58 <edwardk> vegai: heh
23:47:09 <mahogny> fraxtal, does it have to be realtime?
23:48:15 <fraxtal> pry will end up using matlab
23:48:51 <mahogny> matlab(+C) is the best option probably, C only if you do some weird shit
23:48:52 <Korollary> I am not sure how matlab compares to a C implementation
23:49:12 <fraxtal> mahogny, maybe, maybe not.
23:49:58 <fraxtal> C just turns me off
