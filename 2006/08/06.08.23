00:11:08 <dons> ?free seq :: a -> b -> b
00:11:09 <lambdabot> g . seq x = seq (f x) . g
00:11:56 <dons> ?free [a] -> [b] -> [c] -> [d] -> [(a,b,c,d)]
00:11:57 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:57:20-34
00:12:04 <dons> ?free zip4 :: [a] -> [b] -> [c] -> [d] -> [(a,b,c,d)]
00:12:05 <lambdabot> ( ( f ($proj_4_1 v) = $proj_4_1 a     &&     g ($proj_4_2 v) = $proj_4_2 a     &&     h ($proj_4_3 v) = $proj_4_3 a     &&     k ($proj_4_4 v) = $proj_4_4 a   )  =>   p v = a ) => $map p (zip4 x y z
00:12:05 <lambdabot> u) = zip4 ($map f x) ($map g y) ($map h z) ($map k u)
00:12:26 <dons> ?free transpose               :: [[a]] -> [[a]]
00:12:27 <lambdabot> $map ($map f) . transpose = transpose . $map ($map f)
00:13:06 <dons> ?free a -> [a] -> [a]
00:13:06 <lambdabot> Expected OpColonColon
00:13:13 <dons> ?free join :: a -> [a] -> [a]
00:13:13 <lambdabot> $map f . join x = join (f x) . $map f
00:16:12 <dolio> ?free join :: m (m a) -> m a
00:16:13 <lambdabot> Extra stuff at end of line
00:17:03 <dolio> ?free concat :: [[a]] -> [a]
00:17:04 <lambdabot> $map f . concat = concat . $map ($map f)
00:21:35 <benja_> ?free beer
00:21:35 <lambdabot> Expected OpColonColon
00:21:41 <benja_> ?free software
00:21:42 <lambdabot> Expected OpColonColon
00:22:02 <benja_> ?free software :: a
00:22:03 <lambdabot> f software = software
00:22:29 <benja_> I heard I can get stuff for free here, but I can't figure it out :-(
00:22:29 <dons> ?. pl free software :: a
00:22:30 <lambdabot> f = id
00:27:08 <ibid> ?free beer :: Bool
00:27:09 <lambdabot> beer = beer
00:27:23 <ibid> hm that's true
00:27:56 <ibid> ?free beer :: now -> Bool
00:27:56 <lambdabot> beer x = beer (f x)
00:28:02 <ibid> not so useful, that
00:28:44 * benja_ can't figure out what the hell this thing does.
00:29:06 <benja_> but it's still peirce's axiom, not pierce's axiom. it's not *all* about the benjamins.
00:29:07 <ibid> seems to be a 'free theorems' implementation
00:29:08 <dons> it generates theorems for free, for polymorphic functions
00:29:25 <dons> ah hehe
00:30:09 <ibid> ?free f :: Maybe a -> a
00:30:09 <lambdabot> f . f = f . $map_Maybe f
00:30:17 <ibid> hrm
00:30:23 <ibid> ?free g :: Maybe a -> a
00:30:23 <lambdabot> f . g = g . $map_Maybe f
00:30:38 <ibid> it doesn't know how to avoid name capture
00:31:00 <dons> ah hm
00:31:13 <dons> yes
00:31:46 <dons> I should just populate gamma first with the primops and the argument
00:32:27 <benja_> ?free offside :: String -> [String] -> [String]
00:32:27 <lambdabot> ( f u = u  =>   $map f y = z ) => g v = v => $map g (offside x y) = offside x z
00:34:26 <benja_> 'if f u = u implies map f y = z, and if g v = v, then map g (offside x y) = offside x z
00:34:29 <benja_> '
00:35:26 <ProfTeggy> Hmm, the consequence does not mention f?
00:35:27 <benja_> if f = id implies map f y = z ... meaning if map id y = z ... meaning if they're the same list...
00:35:36 <dons> ?free main :: IO ()
00:35:37 <lambdabot> f x = x => $map_IO f main = main
00:35:54 <benja_> ProfTeggy: it looks the the whole point of the first clause is to make sure that y = z
00:36:07 * ProfTeggy nods
00:36:10 <dolio> ?where frag
00:36:10 <lambdabot> http://www.haskell.org/haskellwiki/Frag
00:36:57 <ibid> ?free putStr :: String -> IO ()
00:36:58 <lambdabot> f y = y => $map_IO f (putStr x) = putStr x
00:37:35 <ibid> huh, why the condition instead of s/f/id/?
00:38:24 <dons> mere details ;)
00:38:24 <ibid> okay, so that's a complicated way of saying putStr = putStr
00:38:28 <ibid> i can buy that
00:39:06 <dons> ?free foldl :: (a -> b -> a) -> a -> [b] -> a
00:39:07 <lambdabot> f . h x = k (f x) . g => f . foldl h y = foldl k (f y) . $map g
01:28:58 <wolverian> hm. Helium has very nice error messages.
01:31:19 <dons> it would be a nice project to port some of the Helium infrastructure across to GHC's error message code
01:32:26 <pejo> dons, isn't the main reason Helium can produce a lot of the good error messages because their type system is weaker?
01:33:30 <pejo> (No type class support).
01:33:38 <dons> yes, possibly that's the main reason
01:33:59 <dons> but i suspect that maybe the error messages are just better thought out too, which would be portable
01:34:03 <dons> maybe i'm totally wrong
01:37:19 <pejo> Maybe. It definitely is an area in need of attention, but not as glorious as many others I guess. :-)
01:39:20 <eivuokko> I suspect there's not enough user feedback as well.
01:39:47 <eivuokko> Simons seem fairly responsive to fixing single bad error messages.
01:43:41 <benja_> it would be nice if failing pattern matches would show the data that failed to match (for showable types)...
01:46:43 <pejo> eivuokko, nods. The "clear text explaination" of Helium is probably very good for beginners, but to get it really good you probably need loads of data (like they get from their functional programming class where they logged information :)
02:01:18 <dons> ?users
02:01:19 <lambdabot> Maximum users seen in #haskell: 235, currently: 198 (84.3%)
02:10:20 <Oejet> Only 84%!  Buuuh...  :-)
02:26:38 <Oejet> Is "+RTS -xc" the closest thing to give a back trace using GHC?
02:28:42 <dons> Oejet: yep, or -prof -auto-all
02:36:13 <tibbe> > repeat "bored"
02:36:14 <lambdabot>  ["bored","bored","bored","bored","bored","bored","bored","bored","bored","bo...
02:36:33 <tibbe> > unwords $ repeat "bored"
02:36:34 <lambdabot>  "bored bored bored bored bored bored bored bored bored bored bored bored bor...
02:36:42 <dons> ?free repeat :: a -> [a]
02:36:43 <lambdabot> $map f . repeat = repeat . f
02:36:51 <profmakx> o.O
02:36:59 <xerox> free?
02:37:09 <dons> ?free foldl :: (a -> b -> a) -> a -> [b] -> a
02:37:09 <lambdabot> f . h x = k (f x) . g => f . foldl h y = foldl k (f y) . $map g
02:37:27 <tibbe> what does it do?
02:37:28 <dblhelix> dons: free theorems? cool!
02:37:34 <dons> ?free callcc :: ((a -> (forall r. (b -> r) -> r)) -> (forall r. (a -> r) -> r)) -> (forall r. (a -> r) -> r)
02:37:35 <lambdabot> ( ( f1 . f2 = f3 . g    =>     f1 (p x f2) = q (f x) f3   )  =>   f4 . f5 = f6 . f  =>   f4 (h p f5) = k q f6 ) => f7 . f8 = f9 . f => f7 (callcc h f8) = callcc k f9
02:37:39 <xerox> o_0
02:37:43 <dblhelix> ? free seq
02:37:48 <dons> Pseudonym wrote it on the weekend
02:37:48 <dblhelix> ?free seq
02:37:49 <lambdabot> Expected OpColonColon
02:37:53 <ricky_clarkson> Yet Another Haskell Tutorial mentions Char.toUpper.
02:37:59 <dons> ?free seq :: a -> b -> b
02:38:00 <lambdabot> g . seq x = seq (f x) . g
02:38:10 <ricky_clarkson> I'm using Hugs.  Neither Char.toUpper nor toUpper seem to exist.
02:38:12 <dons> ricky_clarkson: Data.Char.toUpper
02:38:20 <dons> ?hoogle toUpper
02:38:21 <lambdabot> Char.toUpper :: Char -> Char
02:38:31 <dons> (or use -package haskell98)
02:38:49 <dons> ?free pierce :: ((a -> b) -> a) -> a
02:38:50 <lambdabot> ( g . p = q . f  =>   f (h p) = k q ) => f (pierce h) = pierce k
02:38:57 <ricky_clarkson> More specifically, WinHugs.
02:39:12 <dons> ?free id :: a -> a
02:39:13 <lambdabot> f . id = id . f
02:39:17 <ricky_clarkson> Hopefully that takes normal cmd line args.
02:39:38 <dons> Hugs.Base> :l Data.Char
02:39:38 <dons> Data.Char> :t toUpper
02:39:38 <dons> toUpper :: Char -> Char
02:39:41 <kosmikus> very cool
02:39:58 <dons> ?free genSwap :: (forall z. a -> b -> z) -> (forall z. b -> a -> z)
02:39:58 <lambdabot> h . x z = y (f z) . g => k . genSwap x u = genSwap y (g u) . f
02:40:03 <kosmikus> ?karma+ Pseudonym
02:40:04 <lambdabot> Pseudonym's karma raised to 5.
02:40:18 <dblhelix> ?free eq :: a -> a -> Bool
02:40:19 <lambdabot> eq x y = eq (f x) (f y)
02:40:41 <ricky_clarkson> WinHugs says "ERROR - Unable to open file "haskell98""
02:40:41 <dons> ?free filter :: (a -> Bool) -> [a] -> [a]
02:40:42 <lambdabot> g x = h (f x) => $map f . filter g = filter h . $map f
02:40:54 <dons> ricky_clarkson: can you just :l Data.Char ?
02:40:55 <ricky_clarkson> Ah, it just wants -98 I think.
02:42:10 <kosmikus> dblhelix: trying to convince the prover by choice of name that eq is parametrically polymorphic?
02:42:17 <ricky_clarkson> dons: :l Data.Char works.
02:42:43 <dblhelix> kosmikus: would it go for that? ;)
02:42:48 <dons> ?free fst :: (a, b) -> a
02:42:48 <lambdabot> ( f ($proj_2_1 x) = $proj_2_1 y   &&   g ($proj_2_2 x) = $proj_2_2 y ) => f (fst x) = fst y
02:43:05 <xerox> What is the meaning of "free" in "free theorems"?
02:43:09 <Oejet> dons: Thank you.
02:43:27 <dons> ?google theorems for free
02:43:31 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/free/free.ps
02:43:37 <roconnor> @what soe
02:43:38 <lambdabot> http://haskell.org/soe/
02:44:42 <ricky_clarkson> dons: Should there be another way, so that I can send it to Hal Daumé?
02:44:48 <ricky_clarkson> ..send a correction
02:44:57 <kosmikus> ?free sort :: (a -> a -> Bool) -> [a] -> [a]
02:44:58 <lambdabot> g x y = h (f x) (f y) => $map f . sort g = sort h . $map f
02:45:17 <sieni> That's Hâl Dàüm
02:45:22 <sieni> That's Hâl Dàümé
02:45:50 <ricky_clarkson> sieni: Pronounced as "splodge", right?
02:48:18 <wolverian> sieni, that isn't utf8, is it?
02:48:40 <ricky_clarkson> Latin-1.
02:48:42 <dons> latin1?
02:48:46 <sieni> of course not, iso latin 1 or latin 9
02:48:57 <wolverian> that's why I saw ?s, then :)
02:49:03 <ricky_clarkson> Only non-English speakers know of more than 2 encodings.
02:49:28 <wolverian> that's why I'm disappointed it was from sieni..
02:50:14 <kzm> Umm.. I get a bunch of haddock warnings, about not being able to resolve some names.  Imports from prelude etc, it seems.
02:50:26 <sieni> some finnish ircers organized a "let's move to wtf-8" day, so as a protest I keep using iso latin 9
02:50:31 <kzm> Should I worry about this?  Or is it normal?  Both?  neither?
02:50:36 <dons> normal, I think
02:50:40 <dons> haddock is noisy
02:50:53 <kzm> Okay.  I seem to get the output I want, so...
02:51:16 <kzm> My makefile is twice its original size to transform .lhs and -cpp to something haddock will accept :-)
02:51:28 <dons> you can't use Cabal?
02:51:35 <ricky_clarkson> sieni: I believe the old quoted reason is that mIRC doesn't support UTF-8, but I think that's changed.
02:51:40 <dons> or does cabal not know how to unlit and haddockise .lhs?
02:51:55 <wolverian> sieni, yeah. I use iso88591 on most of the finnish channels, still.
02:52:21 <ricky_clarkson> sieni: I just use Latin-1 because putty defaults to it, but it's easy to switch during a session.
02:52:31 <sieni> well iso-8859-1 is crappy since it doesn't support all Finnish characters, namely s and z with carons
02:52:38 <kzm> I didn't know cabal could build haddock-docs(!)
02:52:51 <kzm> Can it?  Can I?
02:52:54 <dons> ./Setup.hs haddock
02:53:02 <wolverian> sieni, you know, I didn't think anyone used them anymore :)
02:53:03 <kzm> (now he tells me!  (sigh))
02:53:05 <kzm> :-)
02:53:14 <dons> you didn't ask!
02:53:39 <kzm> Hehe.  And I learned a few 'make' tricks.
02:53:47 <dons> well, isn't Cabal just that much more special now you've written it in make? :)
02:53:58 <dons> $ ./Setup.hs haddock
02:53:58 <dons> Preprocessing library fps-0.8...
02:53:58 <dons> Running Haddock for fps-0.8...
02:53:59 <dons> ...
02:54:08 <kzm> At least, I learned to appreciate the efforts that must have gone into it.
02:54:24 <kzm> And I know why it is so hard to find good examples of generating haddock from make.
02:54:40 <dons> hehe. there was an example in yi' 0.1.0's build system
02:54:44 <dons> and in ghc's mk/build.mk
02:54:46 <sieni> wolverian: http://users.tkk.fi/~tuhkanen/Sery-C/Kotus-sz-hatut-EN.html
02:54:48 <lambdabot> Title: Finnish orthography - scaron and zcaron
02:54:48 <kzm> I even looked in the fps sources...
02:54:49 <dons> not build.mk, mk/
02:56:44 <kzm> ..and you know, it works perfectly.
02:57:00 <wolverian> sieni, so, utf8 :)
02:57:24 <sieni> or iso latin 9 ;-)
02:58:03 <kzm> Well, it's lunchtime here.  Thanks again(?)
02:58:13 <kzm> (possibly just "thanks" :-)
02:58:29 <dons> :)
02:59:43 <wolverian> sieni, there was some problem with latin9 .. can't remember what it is, now
03:00:50 <benja_> hyva, taso lapi
03:02:55 <ricky_clarkson> Would someone know that you meant this #haskell if you said #haskell?
03:03:34 <boegel> ricky_clarkson: I think there's only one #haskell, afaik
03:03:42 <ricky_clarkson> Cheers.
03:03:57 <ricky_clarkson> Is Hal a regular on here, btw?
03:04:47 <boegel> @seen Hal
03:04:48 <lambdabot> I haven't seen Hal.
03:04:56 <boegel> I guess not
03:20:57 <wolverian> http://www.cs.brown.edu/~sk/Publications/Books/ProgLangs/ seems like a great book
03:21:02 <lambdabot> Title: Programming Languages: Application and Interpretation by Shriram Krishnamurthi
03:21:19 <wolverian> only annoyance with the PDF is that Evince can't jump to the contents, even though it reads the ToC correctly. annoying.
03:21:47 <xerox> ?where pfpg
03:21:48 <lambdabot> I know nothing about pfpg.
03:23:23 <araujo> morning
03:29:52 <wolverian> pedagogically that book is certainly better, I think, than, say, Practican Foundations for Programming Languages.
03:30:05 <wolverian> and, yes, I, overused, my, commas, there.
03:31:08 <wolverian> s/Practican/Practical/
03:31:23 <wolverian> @where pfpl
03:31:24 <lambdabot> I know nothing about pfpl.
03:31:29 <wolverian> @where plai
03:31:29 <lambdabot> I know nothing about plai.
03:31:36 <wolverian> @where+ plai http://www.cs.brown.edu/~sk/Publications/Books/ProgLangs/
03:31:37 <lambdabot> Done.
03:32:07 <wolverian> @where+ pfpl http://www.cs.cmu.edu/~rwh/plbook/book.pdf
03:32:07 <lambdabot> Done.
04:04:49 <sek> does haskell rely on the ammount of indentation to figure out which functions are under the where and which are global?
04:05:59 <Philippa> where there aren't braces and semicolons, yes
04:06:07 <Philippa> but the indentation's sugar for the braces and semicolons
04:06:24 <sek> braces and semicolons?
04:06:57 <sek> it seems i am not in the known:p
04:06:58 <Philippa> yeah, much like in C except you can choose to use the semicolons as either separator or terminator
04:07:01 <Philippa> the last one's optional
04:07:03 <sek> s/known/know
04:07:15 <Philippa> do {this; that; the other}
04:07:59 <sek> interesting. thank you
04:10:04 <kzm> Hmm.. cabal's haddock support doesn't seem to extend to .lhs?  And it produces an empty Main.html?
05:46:03 <tibbe> @quote
05:46:03 <lambdabot> lennart says: Even though I'm largely responsible for making CPP available in a Haskell compiler I think it's an abomination.  It should be avoided
05:47:10 <ricky_clarkson> CPP as in the C pre-processor, or C++?
05:47:57 <dons> the former
05:48:06 * ricky_clarkson breathes.
05:49:54 <kzm> It is only a *small* abomination, you know.
05:50:10 <xerox> I was thinking about updating the Cabal README file
05:50:22 <xerox> Anybody else did what the README says, broking the local installation?
05:51:12 <sieni> it's "brokering" not "broking" ;-)
05:51:24 <xerox> Thanks.
05:51:38 <xerox> @spell brokering
05:51:40 <lambdabot> brokering
05:51:43 <xerox> @spell brokening
05:51:45 <lambdabot> brokering betokening Browning browning broking
05:51:53 <xerox> @spell broking
05:51:54 <lambdabot> broking
05:51:55 <ricky_clarkson> It said broking. ;)
05:52:03 <sieni> ok
05:52:30 <roconnor> @definition broking
05:52:31 <lambdabot> []
05:52:34 <sieni> maybe it was then correct :-)
05:52:35 <xerox> haha
05:52:48 <xerox> @babel it en rompendo
05:52:49 <lambdabot>  breaking off
05:52:54 <xerox> Arr.
05:53:25 <ricky_clarkson> @babel es en jaja la red es mierda
05:53:26 <lambdabot>  jaja the network is excrement
05:53:53 <roconnor> @help definition
05:53:53 <tibbe> is there a way to change the current directory from within ghci?
05:53:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:53:57 <sieni> http://www.dict.org/bin/Dict?Form=Dict2&Database=*&Query=broking
05:53:58 <lambdabot> Title: dict.org- broking
05:54:25 <xerox> Anyway the point was another one...
05:55:25 <xerox> Breaking!
05:55:32 <xerox> That's it.
05:55:39 <kzm> Hmm... I'm back at trying to get cabal to run haddock on my .lhs files.  Any suggestions?
05:56:07 <xerox> runhaskell Setup.hs haddock ?
05:56:13 <xerox> Oh, *lhs*..
05:56:25 <xerox> I don't know if it provides hooks for haddock, let's see.
05:57:15 <xerox> It has ppUnlit :: PreProcessor ...
05:58:53 <xerox> And it has preHaddock, haddockHook, postHaddock hooks ...
05:58:55 <edwinb> what is the problem with haddock and lhs? I use cabal to do that...
05:59:02 <edwinb> there are sometimes annoying issues with indentation though
05:59:12 <xerox> edwinb: it does support that?
05:59:21 <xerox> ..or do you write a hook to do that?
05:59:30 <edwinb> I won't commit any further that "it works for me" ;)
05:59:37 <tibbe> > sequence_ $ map (liftM . putStrLn) ["."]
05:59:37 <lambdabot>  Couldn't match `a1 -> r' against `IO ()'
06:00:06 <tibbe> > sequence_ $ map (liftM putStrLn . canonicalizePath) ["."]
06:00:06 <xerox> tibbe: no (.)
06:00:07 <lambdabot>  Not in scope: `canonicalizePath'
06:00:16 <tibbe> forgot something ;)
06:00:28 <xerox> ?type canonicalizePath
06:00:29 <lambdabot> Not in scope: `canonicalizePath'
06:00:32 <xerox> ?index canonicalizePath
06:00:34 <lambdabot> System.Directory, Distribution.Compat.Directory
06:00:40 <xerox> ?type System.Dirctory.canonicalizePath
06:00:41 <lambdabot> Couldn't find qualified module.
06:00:42 <tibbe> > sequence_ $ map (liftM putStrLn . System.Directory.canonicalizePath) ["."]
06:00:42 <lambdabot>  Not in scope: `System.Directory.canonicalizePath'
06:00:59 <tibbe> ?
06:01:04 <kzm> xerox, edwinb: when I add -v to Setup.hs haddock, it seems to run GHC on the .lhs file as well.  But it doesn't generate any output for it in dist/...?
06:01:41 <nilsi> @quote
06:01:41 <lambdabot> fsbot says: English -> English: no matching translation services found.
06:02:07 <xerox> ?type let canonicalyzePath = undefined :: String -> IO String in mapM ((putStrLn =<<) . canonicalizePath) ["."]
06:02:09 <lambdabot> Not in scope: `canonicalizePath'
06:02:16 <xerox> ?type let canonicalizePath = undefined :: String -> IO String in mapM ((putStrLn =<<) . canonicalizePath) ["."]
06:02:16 <tibbe> why doesn't sequence_ output anything?
06:02:17 <lambdabot> String -> IO String in mapM ((putStrLn =<<) . canonicalizePath) ["."] :: IO [()]
06:02:22 <xerox> o_O
06:03:02 <tibbe> ?type mapM
06:03:03 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
06:03:37 <xerox> Prelude> mapM_ ((>>= putStrLn) . System.Directory.canonicalizePath) ["."]
06:03:38 <xerox> Prelude>
06:03:45 <kzm> And why does haddock generate an empty Main.html?
06:03:51 <ricky_clarkson> > map Char.toUpper "fortran"
06:03:53 <xerox> Uh, it interpreted /Users/.. as a command :D But it printed it.
06:03:53 <lambdabot>  "FORTRAN"
06:05:46 <tibbe> is there an OS independent way of filtering out the . and .. directories from a listing or is it safe to assume that they will always those two strings?
06:07:50 <ihope_> Is 'data Foo = Bar `Foo` Baz' a valid declaration?
06:08:32 <dons> ihope_: I think so , yes, these days
06:09:04 <dons> check the ghc manual, 7.4.1.2. Infix type constructors, classes, and type variables
06:09:39 <dons> > undefined :: Bool `Either` Int
06:09:39 <lambdabot>  Parse error
06:09:48 <dons> bad haskell98 src
06:10:15 <tibbe> ?hoogle directorySep
06:10:15 <lambdabot> No matches found
06:22:12 <roconnor> why isn't unbox-strict-fields enabled by default?
06:22:27 <Ulfalizer> what does it do?
06:23:03 <roconnor> I'm not sure.  I guess it puts strict fields right into the record as opposed to having a pointer.
06:23:33 <mux> to the best of my knowledge, the box is some amount of memory used to store meta-data information about some value
06:23:35 <xerox> I am not sure about a behavior
06:23:42 <xerox> Should cabal-install tell you you can't install if you are not root?
06:23:45 <mux> given that some value may be _|_ etc
06:24:02 <mux> for strict fields it doesn't make sense to keep the box along
06:24:09 <xerox> Now it downloads and compiles the package, and dies with an exception when trying to installing it.
06:24:10 <mux> so it's an optimization
06:24:30 <roconnor> yes, but it seems like an optimization that ought to come with -O.
06:24:50 <roconnor> ... maybe it does come with -O?
06:25:06 <roconnor> but everyone seems to like adding the pragma to their source files.
06:25:45 <Ed-E> Hi - I am a haskell Newbie wondering if someone could help me with something...
06:25:57 <xerox> Sure, ask
06:26:20 <Ed-E> I am using winHugs version may 2006. and it just ignores the \n newline command
06:26:46 <Ed-E> either when it is in a program I have written or just type "hello\nhello" into the prompt for example
06:27:06 <Ed-E> its just prints "hello\nhello" instead of putting a newline in
06:27:13 <ricky_clarkson> > "hello\nhello"
06:27:15 <lambdabot>  "hello\nhello"
06:27:24 <xerox> > showString "hello\nhello"
06:27:25 <lambdabot>  <[Char] -> [Char]>
06:27:27 <xerox> > showString "hello\nhello" ""
06:27:28 <lambdabot>  "hello\nhello"
06:27:29 <xs> putStrLn "hello\nhello"?
06:27:35 <xerox> > words "hello\nhello"
06:27:36 <lambdabot>  ["hello","hello"]
06:27:47 <roconnor> Ed-E are you using putStr, or print?
06:27:51 <Lemmih> Ed-E: Use 'putStrLn'.
06:28:08 <ricky_clarkson> That works, yes.
06:28:13 * ricky_clarkson is using the same.
06:28:46 <Ed-E> how do I 'use' putStrLn?
06:28:55 <Ed-E> sorry for being a spack
06:29:02 <roconnor> If you use print, you get "hello\nhello", if you use putStr, you get hello(newline)hello.
06:29:15 <Ed-E> how do I change it?
06:29:17 <roconnor> putStr "hello\nhello"
06:29:33 <Ed-E> ah ok so if you dont put anything in it assumes you mean print?
06:29:40 <roconnor> right
06:29:50 <Ed-E> wicked. thanks a lot!
06:32:58 <tibbe> um, how could I write partitionM_ ?
06:33:55 <tibbe> or rather, partitionM
06:34:08 <mux> heh, I was going to say partitionM >> return ())
06:34:11 <mux> -)
06:34:17 <tibbe> :p
06:34:34 <tibbe> ?type mapM
06:34:35 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
06:34:57 <mux> I'm trying to understand what would partitionM do
06:35:02 <mux> it doesn't make a whole lot of sense to me
06:35:41 * tibbe doesn't know either
06:35:48 <mux> why would you want it then? :)
06:35:58 <tibbe> I'm trying to get my head around a recursive monadic function
06:36:16 <tibbe> I'm writing a recursive version of getDirectoryContents
06:36:47 <mux> hmmm..
06:36:51 <mux> or hmmmM_
06:36:51 <tibbe> btw, is there an idiomatic naming scheme for function that returns recursive "results"?
06:36:58 <tibbe> :D
06:37:31 <mux> the only think I know about recursive monadic computations is that it has to do with the MonadFix class
06:38:03 <tibbe> I used filterM to get all the nested dirs but I need to combine files and dirs so I need (files, dirs) rather than (files + dirs, dirs)
06:38:08 <mux> probably not necessarily though
06:38:19 <mux> I used to write some simple recursive functions that were IO computations
06:38:24 * tibbe doesn't know what MonadFix is
06:38:31 <mux> and I wasn't doing anything special at all
06:38:38 <xerox> tibbe: I have it in cabal-install if you want
06:38:47 <xerox> tibbe: it returns a Data.Tree.Forest.
06:39:04 <tibbe> xerox, I was writing it for cabal-uninstall ;)
06:39:14 <xerox> Check cabal-install code then :)
06:39:16 <tibbe> or rather a prototype
06:39:21 <tibbe> :)
06:39:52 <xerox> listPackages
06:40:06 <xerox> in Network/Hackage/Client.hs
06:40:08 <tibbe> :)
06:40:26 * roconnor needs to finish his article of a case study of mdo.
06:40:32 <tibbe> hmm, I need something ordered so nested dirs/files appear before their parents
06:40:57 <tibbe> so I can remove children first, check if the dir is empty and if so remove the parent
06:41:09 <xerox> It is a Tree!
06:41:11 <xerox> It returns a Tree :)
06:41:28 <tibbe> and it is ordered the way I want it to be?
06:41:38 <xerox> It has the order that the directories have
06:41:50 <xerox> I.e. it maps the fs to a Data.Tree
06:42:10 <tibbe> so the order that "ls" returns?
06:42:37 <Ed-E> Sorry am back.... So how would I make this work?
06:42:38 <Ed-E> test :: String->String
06:42:45 <tibbe> actually it would be enough if all dirs come before the files in the ordering
06:42:46 <Ed-E> test n =  n++ "\n" ++ n ++ "\n" ++ n
06:43:04 <Ed-E> with the putStr bit?
06:43:18 <tibbe> > let test n =  n++ "\n" ++ n ++ "\n" ++ n in test "hi"
06:43:19 <lambdabot>  "hi\nhi\nhi"
06:43:33 <tibbe> > let test n =  n++ "\n" ++ n ++ "\n" ++ n in putStr $ test "hi"
06:43:34 <lambdabot>  No IO allowed
06:43:51 <xerox> How do I find in which package a module is?
06:43:52 <ulfdoz> muahahaha!
06:43:56 <ulfdoz> ECHAN, sorry
06:44:05 <Ed-E> haven't got to i/o yet
06:46:36 <Ed-E> it just says in my lecture notes and in my textbook that "\n" should make a new line...why is it suddenly so complicated?
06:47:19 <Lemmih> It /does/ make a newline. How you display that newline is a different matter, tho.
06:47:23 <ricky_clarkson> It does make a new line, but .. yeah.
06:47:44 <ricky_clarkson> Haskell's obviously too popular if lecturers are using it.
06:47:48 <Ed-E> so is there an easy way to make it display "\n" as a new line every time i use it?
06:47:53 <roconnor> Ed-E: printing a string escapes things line newlines and quote marks, etc.
06:48:23 <Lemmih> Ed-E: Just use 'putStrLn'.
06:48:24 <roconnor> Ed-E: In order to show a string on the display you need to do IO.
06:48:45 <roconnor> So use putStr (or putStrLn) every time you want to display your strings.
06:49:51 <araujo> hello
06:49:52 <Ed-E> so in that example i gave above it would be test n = n ++ putStr "\n" ++ n ++ putStr "\n" ++ n??
06:50:04 <araujo> no
06:50:14 <araujo> @type putStr
06:50:15 <lambdabot> String -> IO ()
06:51:11 <araujo> Concatenate and then do the printing.
06:51:26 * araujo finishing a script to use ghci as a shell
06:51:58 <Lemmih> Ed-E: putStrLn (test "hello world")
06:52:27 <sieni> let test n = putStr (n ++ "\n" ++ n ++ "\n" ++ n) in test "hello world"
06:52:30 <sieni> or something
06:52:48 <Ed-E> okay I think I get it...i'll go play around with that. Cheers for your help
06:53:19 * roconnor tries to remember how long it took to grok IO.
06:53:53 <kzm> Anybody know what the "Coverage Condition" is (for functional deps)?
06:57:26 <araujo> Best way to grasp at IO is to think of it as a container imho.
06:58:10 <araujo> One way container, whatever it gets in, it can't go out of it.
06:58:23 <ookk> how long and how many values of an evaluated function does haskell store?
06:59:33 <dons> |-------------------------| this long
06:59:42 <ookk> for instance if i have calculated fac 10000 does it store the values of fac 1-9999
07:00:01 <ookk> so you cant rely on it?
07:00:02 <dons> most likely no
07:00:28 <dons> values are produced and consumed on demand
07:00:37 <ookk> so then it is better to make a list of values if the speed on your algorithm relies on previously evaluated values
07:00:41 <roconnor> ookk: it is compiler specific.  If you memoize using lists, then you it will definitely be stored.
07:01:00 <ookk> so i guess i have to do it explicitly
07:01:03 <ookk> with a list
07:01:27 <dons> right, a lazy list is often a good way of ensuring value aren't computed more than necessary
07:01:29 <xerox> dons: that friend of mine was trying to cabal-install hmp3, but it failed because it needs mkProcessHandle which doesn't exist in GHC 6.4, is there a way to put that in the dependencieS?
07:01:39 <xerox> dons: or fix it?
07:02:05 <dons> you need 6.4.2
07:02:31 <dons> i don't think we can put it in, with current cabal
07:02:31 <xerox> I couldn't find .2 for ppc mac...
07:02:52 <xerox> Well, okay thanks.
07:02:54 <dons> you could check the darcs history and revert the patch that added mkProcessHandle
07:03:24 <LPhas> hi dons :D
07:03:51 <LPhas> sigh how i can survive  5 hour without my fovourite music player? :'(
07:04:01 <dons> :D
07:04:15 <dons> its my favourite too :)
07:04:25 <LPhas> i bet
07:04:40 <dons> let me see what has to be reverted to build under 6.4
07:05:00 <LPhas> naa, bacward compatibility sucks
07:05:06 <LPhas> die, oldie!
07:05:24 <dons> xerox: you can revert this patch;
07:05:25 <dons> Sun Apr 30 18:09:19 EST 2006  Don Stewart <dons@cse.unsw.edu.au>
07:05:26 <dons>   * Port pid2phdl to GHC 6.4.2. HEADS UP: You need 6.4.2 to build hmp3 now.
07:05:29 <xerox> OK.
07:05:34 <LPhas> th
07:05:38 <xerox> A second LPhas
07:06:17 <dons> its a two line change
07:07:09 <xerox> To which file?
07:07:39 <dons> ?paste
07:07:40 <lambdabot> http://paste.lisp.org/new/haskell
07:07:44 <xerox> Oh-uhm.
07:08:07 <lisppaste2> dons pasted "Revert this patch" at http://paste.lisp.org/display/24610
07:08:12 <dons> Utils.hs
07:08:23 <xerox> No _darcs dir... I did something wrong
07:08:35 <dons> just invert the patch I paste above
07:08:48 <dons> i.e. add back the lines that are marked with -, and remove lines with +
07:10:41 <xerox> OK, rebuilding the index..
07:11:02 <dons> it compiled?
07:11:30 <xerox> LPhas will tell us :)
07:12:39 <LPhas> xerox, you are uploading the patched code on the repository? or i can try in local...
07:13:35 <xerox> LPhas: update
07:26:42 <spiffy> possibly weird question, is there anything remotely similiar to lisp macros in haskell?
07:27:00 <xerox> Template Haskell might fall in that definition...
07:27:34 <dons> usually you can avoid macros by using higher order functions
07:27:44 <dons> like 95% of the time
07:28:05 <xerox> Wait for the 5% of the time and then try again :P
07:28:25 <dons> heh
07:28:32 <dons> use cpp or TH for the 5%
07:28:53 <spiffy> i think TH is what i want
07:29:19 <dons> yeah, if you need to generate code programmatically at compile time
07:29:40 <LPhas> ok, now it work
07:29:43 <LPhas> s
07:29:47 <xerox> Yay for cabal-install :D
07:29:48 <dons> yay :)
07:29:54 <LPhas> oh, and cabal-install is cool!
07:30:01 <xerox> I paid him for that comment.
07:30:02 <LPhas> i want a repository with... ALL
07:30:04 <dons> heh
07:30:07 <LPhas> of course :P
07:30:28 <LPhas> but it's truly cool
07:30:47 <eivuokko> xerox, Have you tried cabal-install in Windows yet?
07:30:51 <LPhas> damn, i had to install almost all because i reinstalled osx
07:31:05 <LPhas> and with cabal-install it took me half of the time
07:31:11 <xerox> eivuokko: nope
07:31:15 * xerox is happy
07:31:17 <xerox> Hmmmm.
07:31:21 <dons> yeah, that's a good use case
07:31:25 <dons> having to rebuild everything
07:32:18 <eivuokko> xerox, So I should try it very soon if I want possibly Windows issues rooted? :-)
07:32:55 <xerox> eivuokko: Yup. You can try it now. But I didn't commit the multiple-repo patch yet, I am not satisfied :(
07:33:18 <eivuokko> xerox, Main Cabal repo or where can I find it?
07:33:31 <xerox> http://darcs.haskell.org/~paolo/darcs/Cabal
07:33:35 <lambdabot> Title: Index of /~paolo/darcs/Cabal
07:33:36 <eivuokko> (I can't try exactly now, but within few hours)
07:33:37 <eivuokko> Thanks
07:33:51 * SamB wonders why his IRC client retries connecting every ten seconds for hours
07:34:34 <ulfdoz> SamB: You didn't rtfm? ;) What IRC-Client?
07:35:16 <SamB> well, I wouldn't really mind if it didn't feel the need to fill my scrollback with the tale...
07:39:52 <dons> LPhas: do you have any comments or suggestions about hmp3? since you're one of the most heavy users of it
07:39:58 <dons> doh
07:40:12 <xerox> ...
07:40:22 <xerox> he =/= IRC
07:40:28 <dons> yep
07:40:47 <SamB> @all-dict =/=
07:40:50 <lambdabot> No match for "=/=".
07:41:10 <SamB> oh, is that $\neq$?
07:41:12 <dons> its legacy notation for /= ;)
07:41:18 <xerox> ^_^
07:41:31 <LPhas> here i am back
07:41:41 <xerox> â¢
07:41:46 <LPhas> connection problems
07:42:00 <SamB> xerox: that has three horizontal strokes if my eyes do not decieve me
07:42:07 <xerox> ââââ
07:42:14 <roconnor> not identical to.
07:42:30 <xerox> â  oh here it is
07:42:43 <SamB> does â mean not approximately equal to?
07:42:44 <roconnor> there should be one with four strokes...
07:43:30 <xerox> I like those: â, â, â, â, â, â, â, â, â, â, , â, â, â, â, â, â, â£, â¡, â¢.
07:43:51 <SamB> what a lot of symbols
07:44:01 <xerox> All binary relations!
07:44:09 <SamB> the way they don't show in the same font is kind of tacky
07:44:09 <xerox> Can you tell all the meanings? :)
07:44:13 <xerox> :(
07:44:28 <SamB> I blame Pango!
07:44:37 <SamB> also fonts
07:44:39 <xerox> mathrick|away fix it! (when you are not away)
07:45:02 <roconnor> â£ means ``Damn! these are the same thing''
07:45:23 <SamB> Pango should try to assemble a more aesthetically pleasing collection of characters
07:45:31 <xerox> ``Then why the heck you write it in two different ways!''
07:45:46 <tennin> I'd like "=?" for equality testing
07:45:58 <xerox> The first one is very nice "=def"
07:46:04 <xerox> It would be cool to use that for Haskell definitions!
07:46:07 <tennin> it makes a lot more sense than "==" but is shorter than the Scheme
07:46:09 <roconnor> xerox: you can only use â£ when they are written the same way ;)
07:46:15 <xerox> roconnor: ah-ha!
07:46:23 <xerox> â¥ââ¥
07:46:30 <roconnor> \x.x  â£ \x.x
07:46:56 <SamB> U+2263 STRICTLY EQUIVALENT TO
07:46:57 <roconnor> ~ \x.x â£ \y.y
07:46:58 <xerox> Î»x.x you mean.
07:47:03 <roconnor> of course.
07:47:08 <xerox> ;)
07:47:17 <SamB> xerox: as long as both sides are written the same way!
07:47:45 <xerox> Â± â â
07:47:53 <xerox> "geometrically equivalent to"
07:48:31 <SamB> fonts should not be missing so many symbols, really...
07:48:33 <xerox> I think â´ I â ?
07:48:51 <SamB> I mean missing out entire scripts I can see
07:48:53 <xerox> cabal-install, cabal-install, not unicode, cabal-install .....
07:49:16 <int-e> Ïµâªâ there are too many symbols around.
07:49:41 <xerox> It would be cool to use them for general consumption
07:49:55 <int-e> â¼ ~
07:50:13 <xerox> One can even learn new meaning wandering trough the unicode tables.
07:50:18 <xerox> *meanings
07:50:57 <ValarQ> â
07:51:50 <SamB> SNOWMAN!?!?!?!
07:51:52 <xerox> yeye
07:51:54 <int-e> oh. that's inrecognizable in the font I'm using :)
07:51:59 <xerox> A snowman :D
07:52:09 <SamB> int-e: mine too
07:52:31 <SamB> I had to paste it onto xterm after "unicode "
07:52:32 <int-e> unless you know what it's supposed to be, then it's almost ok
07:52:34 <xerox> If you have a very recent python I think you can do: import unicodedata; print u"\N{PEACE SYMBOL}".
08:00:04 * tennin is not too familiar with the snowman operator
08:00:48 <xerox> I want to be able to define it.
08:13:50 <LPhas> hey, xerox, do you think that will be easy to make a GUI for cabal-install?
08:14:09 <LPhas> whith gtk2hs of course :P
08:14:19 <xerox> Sure.
08:14:33 <LPhas> we-el
08:14:36 <LPhas> l
08:14:50 <xerox> One of the modifications I done was in part to ease the construction of such a tool.
08:14:51 <LPhas> maybe if i get some days free i will try
08:15:48 <xerox> You should hack Yi :D
08:16:59 <LPhas> oh, yeah, of course :P
08:17:14 <LPhas> and about it, can you put hs-plugin and Yi on the repo?
08:17:21 <xerox> plugin is there
08:17:25 <xerox> yi is not cabalized
08:17:26 <LPhas> ok
08:17:30 <LPhas> d'oh
08:21:17 <xerox> spiffiness left us.
08:25:31 <tibbe> anyone know how to get URLs to show up in bibtex entries, I assume that some people here have written a paper or two...
08:25:56 <dons> note = \url{}, ?
08:26:07 <dons> @misc{GHC,
08:26:08 <dons>   author = {{The GHC Team}},
08:26:08 <dons>   title = {{The {Glasgow} {Haskell} {Compiler} (GHC)}},
08:26:08 <dons>   howpublished = {\url{http://haskell.org/ghc}},
08:26:08 <lambdabot> Unknown command, try @list
08:26:10 <dons>   year  = 2006
08:26:12 <dons> }
08:26:15 <dons> for example
08:26:28 <dons> or,
08:26:29 <dons>   author =       {Manuel M. T. Chakravarty and others},
08:26:29 <dons>   title =        {The Haskell 98 Foreign Function Interface 1.0: An Addendum to the Haskell 98 Report}
08:26:32 <dons> ,
08:26:35 <dons>   note =         {\url{http://www.cse.unsw.edu.au/~chak/haskell/ffi/}},
08:28:01 <ulfdoz> btw. \\url has some problems with linebreaks, when not using pdflatex.
08:29:39 <tibbe> thanks
08:31:12 <tibbe> dons, hmm, my version of pdflatex doesn't like the \url thingy
08:31:31 <dons> you need to import the url package
08:31:33 <int-e> with \usepackage{url}?
08:32:18 <tibbe> ah, thanks
08:47:15 <svref> What's a less silly way of finding the 4th tail of a list?  Right now the best I can think of is (tail.tail.tail.tail)...:P
08:47:45 <dons> > drop 4 "haskell" -- ?
08:47:51 <lambdabot>  "ell"
08:48:06 <svref> thanks...much less silly!
08:48:09 <dons> :)
08:48:24 <xerox> dcoutts: ping
08:48:27 <ProfTeggy> But amounts to the same computation
08:49:32 <dons> though drop is implemented a bit more efficiently in ghc
08:51:14 <xerox> I need a way to encode a url string to a the name of a directory
08:51:16 <xerox> ....and get back 1:1.
08:51:20 <SamB> > ((!!4) . tails) "hello!"
08:51:21 <lambdabot>  "o!"
08:51:50 <SamB> xerox: z-escaping!
08:51:51 <svref> what is (!!)?
08:51:57 <xerox> ?quote Cale
08:51:58 <SamB> list indexing
08:51:58 <lambdabot>  Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
08:52:02 <xerox> ?type (!!)
08:52:03 <lambdabot> forall a. [a] -> Int -> a
08:52:06 <xerox> OK?
08:52:10 <ProfTeggy> tails = iterate tail   ?
08:52:14 * xerox pets lambdabot
08:52:23 <svref> xerox: thanks
08:52:28 <SamB> @free [a] -> a
08:52:28 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:57:20-34
08:52:35 <SamB> @free f :: [a] -> a
08:52:35 <lambdabot> f . f = f . $map f
08:52:38 <xerox> svref: note the Cale quote :)
08:53:10 <xerox> SamB: Network provides that?
08:53:20 <SamB> xerox: what?
08:53:31 <xerox> The escaping you were talking about
08:53:37 <SamB> xerox: no!
08:53:42 <SamB> I was mostly kidding
08:53:54 <SamB> that is what GHC uses to escape symbols
08:54:54 <xerox> >>> urllib.unquote(urllib.quote('http://d.a.o/~paolo/packg/',safe=''))
08:54:54 <xerox> 'http://d.a.o/~paolo/packg/'
08:55:02 <xerox> In python seem to work this way..
08:55:13 <xerox> Let's see.
08:56:54 <xerox> Prelude Network.URI> escapeURIString isUnreserved "http://d.h.o/~paolo/darcs/packages"
08:56:54 <xerox> "http%3A%2F%2Fd.h.o%2F~paolo%2Fdarcs%2Fpackages"
08:57:00 <xerox> Is it good enough for a directory name? :(
08:58:04 <xerox> I am not sure.
08:58:20 <xerox> Do you know if I have to do this madness to avoid a behavior like mkdir -p "foo/bar/baz" ?
09:00:21 <Igloo> Is this for cabal?
09:00:41 <Igloo> If so, you know what characters are allowed to be used, don't you?
09:00:53 <xerox> Yes it is.
09:01:16 <Igloo> So just give an error if you find bad characters
09:01:16 <xerox> What do you mean?
09:01:17 <xerox> My concern is wrt filesystems.
09:01:31 * Igloo might have misunderstood exactly what you're trying to do
09:01:41 <xerox> URLs are supposed to be full of bad characters I believe.
09:01:47 <xerox> I need to handle multiple repositories.
09:01:59 <Igloo> Ah, I get ya
09:02:13 <Igloo> And you need to support Windows, MacOS etc too for this, right?
09:02:14 <xerox> I can't put all the packages in one local packages/ repository because packages could clash.
09:02:28 <xerox> I very much think so.
09:02:55 <ProfTeggy> The above makes for a valid filename on Mac OS X at least
09:03:06 <Igloo> I'd pick a set of obviously-safe characters and %escape or zencode or whatever you like anything else
09:03:20 <dons> Igloo: oh, I almost forgot, this still breaks the base build on openbsd (and other old fashioned systems, I presume): http://www.haskell.org/pipermail/cvs-all/2006-May/047470.html
09:03:21 <lambdabot> Title: Build failure and UINTMAX_T
09:03:34 <xerox> Igloo: may you elaborate on that?
09:03:55 <dons> i'd forgotten, since I always don't pull the original patch http://www.haskell.org/pipermail/cvs-all/2006-May/047438.html
09:03:56 <lambdabot> Title: patch applied (packages/base): add CIntPtr, CUIntPtr, CIntMax, CUIntMax types
09:04:11 <mnislaih> eivuokko: ping
09:04:18 <Igloo> xerox: concatMap (\x -> if x `elem` "abc..." then [x] else '%':showAsHex (ord x))   (roughly speaking)
09:04:28 <eivuokko> mnislaih, Hiya
09:04:38 <Igloo> (but written more efficiently)
09:04:46 <xerox> Igloo: right. I wonder if Network.URI provides that
09:04:56 <xerox> I can't find the right predicate it seems.
09:05:03 <xerox> ?docs Network.URI
09:05:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network-URI.html
09:05:13 <mnislaih> hi Esa, I finally got around to using the testsuite patches. I'm having some problems in Mac Os. Which is the required Python version ?
09:05:20 <eivuokko> 2.4
09:05:23 <eivuokko> I think
09:05:33 <Igloo> dons: Noted, ta. I'll try to take a look tomorrow.
09:05:36 <eivuokko> What does it say?  About threading.local?
09:06:11 <ptolomy> what is the most portable and easy way to do bitmap animations in haskell?
09:06:13 <dons> Igloo: I think John Meacham had a hint about some autoconf script that generates valid defaults for such systems. that might be something to look at
09:06:15 <mnislaih> it says 2.4 here. It's the Python that comes preinstalled in Mac Os, maybe it's an underpowered version
09:06:33 <mnislaih> lots of errors. I'll do a paste
09:06:41 <dons> ptolomy: gtk2hs maybe?
09:06:43 <mnislaih> @paste
09:06:44 <lambdabot> http://paste.lisp.org/new/haskell
09:07:05 * ptolomy likes to hope that the ghc standard install (or the hugs one) have something somewhere akin to the ocaml Graphics module..
09:07:36 <lisppaste2> mnislaih pasted "testsuite driver errors" at http://paste.lisp.org/display/24623
09:07:39 <dons> HOpenGL maybe?
09:07:41 <ths> Hm, my registerised GHC for mips is much faster when compiling its libraries.
09:07:48 <dons> ths, cool!
09:07:52 <dons> mips64?
09:07:54 * xerox trembles
09:08:02 <xerox> ".."!
09:08:26 <ths> dons: No, Debian mips (o32).
09:08:31 <dons> ah right
09:08:46 <dons> I build on irix/mips64 every now and then
09:09:12 <eivuokko> mnislaih, I don't get it...
09:09:22 <xerox> Igloo: what about a hash?
09:09:23 <dons> unregisterised though. actually, I think I have some mips manuals somewhere
09:09:32 <eivuokko> mnislaih, Could you get testlib.py cleanly from repo?
09:09:48 <mnislaih> sure
09:09:54 <ths> dons: I chose the registers in a way which might just work on NewABI as well.
09:10:14 <dons> ths, would these be useful to you:
09:10:15 <dons> MIPS64_Vol1_Introduction_to_the_MIPS64_Architecture_v0.95.pdf
09:10:15 <dons> MIPS64_Vol2_The_MIPS64_Instruction_Set_v0.95.pdf
09:10:15 <dons> MIPS64_Vol3_The_MIPS64_Privileged_Resource_Architecture_v0.95.pdf
09:10:25 <eivuokko> mnislaih, The error simply doesn't match my testlib.py
09:10:29 <lispy> xb
09:10:31 <lispy> er...sorry
09:10:33 <Igloo> xerox: I've often found it useful that the filenames apt uses are human readable
09:10:48 <ths> dons: *grin*
09:10:49 <dons> (maybe they're availabel somewhere else, not sure. I remember they were mailed to me by someone wanting mips/ghc to work )
09:11:15 <xerox> Igloo: that's right too, I could put a URL file inside...
09:11:23 <dons> ths, actually, does debian run mips64?
09:11:24 <xerox> Igloo: on the other hand quoted urls aren't exacly *readable*
09:11:24 <ths> dons: You get them for free registation from the MIPS Technologies website. :-)
09:11:28 <dons> ah right
09:11:38 <dons> I didn't get them that way :)
09:11:44 <dons> so I thought they must have been hard to get hold of
09:11:54 <Igloo> xerox: apt ends up with files like ftp.uk.debian.org_debian-amd64_debian_dists_stable_contrib_binary-amd64_Packages
09:11:59 <ths> dons: Debian has now some 64bit kernels, but still no 64bit userland.
09:12:02 <xerox> Igloo: this is interesting
09:12:11 <xerox> Igloo: what if there are _ in the url, though?
09:12:22 <dons> ths, oh that's a pity. 64 bits mips is fun.
09:12:23 <Igloo> Oh, I should have suggested handling _ specially up above
09:12:23 <lispy> ths: not true
09:12:37 <Igloo> I don't know what apt does, but you could %encode (or whatever you do) real '_'s
09:12:40 <ths> dons: Distributing them is a problem, our lawyers are crazy.
09:12:43 <ths> lispy: ?
09:12:48 <lispy> ths: i run a machine with a pure  64bit userland, at least if i understand you correctly i do
09:12:49 <xerox> Igloo: that is true
09:12:49 <dons> edison$ ./a.out
09:12:50 <dons> mipseb
09:12:50 <dons> irix
09:12:51 <dons> :)
09:12:57 <xerox> Igloo: I am also concerned about '.'
09:12:58 <ths> lispy: Then it isn't Debian.
09:13:03 <lispy> ths: and it's debian
09:13:07 <xerox> Igloo: '../../../../foo' might be a problem
09:13:10 <dons> ths, ah fair enough
09:13:11 <ths> lispy: Then it isn't MIPS.
09:13:23 <lispy> ths: ah, okay no it's not mips
09:13:59 <xerox> No it is not a problem.
09:14:05 <xerox> Igloo: ok! I'll do that way!
09:14:24 <dons> ths, hmm. so maybe now ghc might run registerised on irix/mips32 abi?
09:14:36 <dons> i never tried that, since 64 bits just worked
09:14:40 <mnislaih> eivuokko: the clean one works fine. I diffed them and turns out I had made a tiny modification to testlib.py a few days ago and forgot about that
09:14:55 <LPhas> i tried to build ghc snapshot distribution from the stable branc
09:14:56 <xerox> Prelude Network.URI> escapeURIString (/='/') "http://darcs.haskell.org/~paolo/packages"
09:14:56 <xerox> "http:%2F%2Fdarcs.haskell.org%2F~paolo%2Fpackages"
09:15:00 <LPhas> on a ppc with macosx
09:15:04 <LPhas> but i got this error
09:15:06 <LPhas> ghc-6.4.3.20060822: unknown package: OpenAL
09:15:07 <LPhas> <<ghc: 10631088 bytes, 2 GCs, 82820/82820 avg/max bytes residency (1 samples), 12M in use, 0.01 INIT (0.00 elapsed), 0.04 MUT (0.09 elapsed), 0.01 GC (0.03 elapsed) :ghc>>
09:15:07 <eivuokko> mnislaih, Phew! :-)
09:15:07 <LPhas> make[2]: *** [depend] Error 1
09:15:07 <LPhas> make[1]: *** [boot] Error 1
09:15:07 <LPhas> make: *** [build] Error 1
09:15:08 <LPhas> ibook-g4-di-riccardo-cagnasso:~/Desktop/ghc-6.4.3.20060822 Phas$
09:15:20 <eivuokko> mnislaih, Got me scared there :-)
09:15:21 <ths> dons: With my changes it has a chance to work for n32, and with another small change even on n64.
09:15:24 <mnislaih> eivuokko:  sorry oÂ¿o !
09:15:35 <dons> ths, ah! let me know if you want me to try out any patches
09:15:36 <eivuokko> mnislaih, np :-)  Good thing it gets tested a bit
09:15:48 <mnislaih> now, how do I get this to smoke my Core Duo? -j4 will do ?
09:15:56 <dons> edison$ uname -msr
09:15:57 <ths> dons: That is, if it really works. I probably should run the testsuite before declaring victory. :-)
09:15:57 <dons> IRIX64 6.5 IP30
09:15:57 <eivuokko> mnislaih, THREADS=4
09:16:10 <ths> dons: An, an Octane.
09:16:13 <lispy> Brian Hulley should just define a new language...he seems to be redefining haskell syntax just for his editor :)
09:16:27 <dons> ths, yes! if you check the logs, my working unregisterised 64 bit ghc still failed a bunch of weird things in the testsuite
09:16:28 <eivuokko> mnislaih, I usually use THREADS=3 on hyperthreaded P4, which is pretty good
09:16:32 <dons> but it was about 90% there
09:16:44 <dons> hopefully though its a bit easier under linux
09:16:51 <dons> since you don't have so many lib issues to deal with
09:17:02 <xerox> LPhas: your machine name is silly :P
09:17:16 <LPhas> xerox: what an useful comment!
09:17:16 <Igloo> lispy: Was that while building ALUT?
09:17:25 <lispy> would be interesting if darcs had 'split' and 'join' for working on slices of repositories
09:17:31 <ths> dons: Is yours a SMP machine?
09:17:43 <lispy> Igloo: was what while building ALUT?
09:17:47 <mnislaih> THREADS=10 makes some tests give fake failures, is that right ?
09:17:53 <Igloo> LPhas: Was that while building ALUT?
09:18:00 <Igloo> lispy: Sorry  :-)
09:18:04 <eivuokko> Is there an easy way to trigger ghc bug #652 - compiled code and dynamically linked code don't share Typeable-table?
09:18:05 <lispy> Igloo: n/p
09:18:18 <dons> yeah, a quad octane (its a colleague's box)
09:18:21 <ths> dons: And if it is, does GHC use threads on it?
09:18:23 <LPhas> Igloo: who knows?
09:18:34 <ths> dons: Quad?
09:18:34 <eivuokko> mnislaih, It shouldn't.  If it does, those tests should be serialised.
09:18:53 <ths> dons: I haven't seen more than Dual.
09:18:56 <Igloo> LPhas: Can you put the log (or the last 100 lines of it) on the web/a paste page?
09:18:58 <dons> it could be a dual then.
09:19:01 <LPhas> xerox: the plugins package of your repo is bugged
09:19:11 <LPhas> Igoo: of course, wait a min
09:19:12 <lispy> Igloo: although, i haven't been able to build ghc on osx because of a problem finding the OpenAL package which seems to be related to ALUT
09:19:21 <LPhas> xerox: Setup.lhs: Error: file is not executable: "./configure"
09:19:21 <LPhas> cabal-install: Command failed: 'configure Setup.lhs configure'. Errno: 1
09:19:24 <dons> its been a while since i've played with it, but I don't think i've tested it since we got the threaded rts as default
09:19:26 <ths> dons: I think it doesn't have enough space for four CPUs.
09:19:31 <eivuokko> mnislaih, I'll have to wait until next nights builds to see if they got extra errors.
09:19:37 <xerox> LPhas: do you need it right now?
09:19:41 <mnislaih> eivuokko they're not mine, I'm testing the vanilla ghci tests. Maybe they have dependencies between tests if they haven't been written with parallelism in mind
09:19:45 <Igloo> lispy: If it's ALUT that's failing then just tell GHC not to build either of them
09:19:52 <dons> ths, yeah, you're probably right.
09:20:16 <LPhas> xerox: no, but if you have a repository, i beat you want it working
09:20:22 <eivuokko> mnislaih, Hmmm.   Could you have other changes, in driver/runtests.py that somehow affect this?
09:20:36 <mnislaih> I will check
09:20:46 <xerox> LPhas: fixed
09:20:49 <lispy> Igloo: well, OpenAL builds without any problems and ALUT fails because OpenAL is missing...so it seems like i should be able to build ALUT, doesn't it?
09:21:00 <eivuokko> mnislaih, I have ran ghci tests a bit myself, because there is/was a rts/Linker problem in Windows.
09:21:18 <Igloo> lispy: That sounds odd
09:21:33 <LPhas> xerox: thx
09:21:33 <Igloo> lispy: The C or Haskell OpenAL is missing?
09:21:45 <xerox> LPhas: tell me whatever you find! Thanks much!
09:21:50 <lispy> Igloo: http://paste.lisp.org/display/24624
09:21:59 <lispy> Igloo: oh, mm...maybe the C is missing
09:22:43 <Igloo> lispy: OpenAL didn't build, it did nothing (configure disabled it because the C dev libraries were missing)
09:22:48 <mnislaih> eivuokko: looks like I don't. I can repeat the tests from a clean repo later if that helps
09:23:23 <eivuokko> mnislaih, Could you paste the tests that fail, I'll check?
09:23:33 <LPhas> http://paste.lisp.org/display/24625
09:23:37 <lispy> Igloo: oh, ...how could you tell?
09:23:38 <eivuokko> Or are they are failing?
09:23:44 <LPhas> here u are
09:23:54 <Igloo> lispy: Try it with --disable-openal --disable-alut
09:24:02 <lispy> Igloo: the results you see are from running make twice in a row, so maybe it just skipped it this time?
09:24:04 <lispy> okay
09:24:10 <lispy> in configure?
09:24:11 <Igloo> lispy: It would have done ghc -M if it was planning to build it
09:24:19 <lispy> okay
09:24:21 <lispy> thanks
09:24:26 <Igloo> To configure, yes
09:24:53 <eivuokko> mnislaih, prog 1-3 fail for me on ghci dir....but they are serialised already becauyse they are on their own dirs.
09:24:55 <mnislaih> with THREADS=10: ghci0 [01,05, 08, 11, 12, 13, 14, 15]. From those, 08, 11 and 15 fail on themselves. The others are unexpected fails
09:25:08 <Igloo> LPhas: Right, same as lispy. I think configure --disable-openal --disable-alut should do it
09:25:15 <eivuokko> mnislaih, Sounds bad :-(
09:26:32 <mnislaih> It's not that of a big problem. I can have a choice to run my testsuite fast and approximate or slow but safe
09:26:46 <LPhas> thx
09:26:55 <eivuokko> mnislaih, If you run them with THREADS=1, does it happen too?
09:26:58 <mnislaih> and anyway, I don't have 10 cores, only 2, and with THREADS=4 there are no spurious failures
09:26:58 <LPhas> and anyone knows nothing about gtk2hs on macosx?
09:27:07 <eivuokko> mnislaih, I don't see how they could be failing because of threading
09:27:28 <mnislaih> nope.
09:27:32 <eivuokko> Uhhuh
09:28:12 <eivuokko> mnislaih, How do they fail?
09:28:31 <mnislaih> let's check ghci001
09:28:34 <mnislaih> seems a simple one
09:28:36 <eivuokko> Right, it's very simple
09:29:20 <mnislaih> looks like timeout
09:29:27 <eivuokko> Huh!
09:29:58 <eivuokko> Default timeout is 5mins?
09:30:56 <mnislaih> the others seem to fail in the same way- timeout: thread blocked indefinitely
09:31:25 <eivuokko> How about THREADS=2 ?
09:31:41 <mnislaih> I wouldn't be too worried about this eivuokko: THREADS=n where n is a reasonable number works perfectly
09:31:58 <mnislaih> i.e. 2,3,4, those I have tried and work fine
09:32:00 <eivuokko> I am fairly sure it is threaded rts bug
09:32:09 <eivuokko> And overloaded processor
09:32:25 <mnislaih> I don't know if I build my rts with -threaded. Is that the default ?
09:32:31 <eivuokko> Yes, for stage2
09:32:49 <eivuokko> Eh, I mean, it is for stage2 ghci
09:33:15 <mnislaih> o.o
09:33:29 <eivuokko> Has been for a while now.  It's pretty cool when playing with threads.
09:34:18 <eivuokko> Before threads stopped when ghci was waiting at the prompt.  Kinda annoying for GUI hacking for example.
09:35:53 * SamB wonders where you find GL experts
09:42:33 <SamB> JohnMeacham: hey!
09:43:09 <SamB> the munching doesn't work right in Frisby
09:46:13 <LPhas> http://paste.lisp.org/display/24625#1Ã¹
09:46:15 <LPhas> http://paste.lisp.org/display/24625#1
09:46:24 <LPhas> new errors trying to compile ghc...
09:53:44 <mnislaih> the -D flag in ghc is used for the C preprocessor right ?
09:54:19 <mnislaih> what difference does it make to launch ghci with -Di386_apple_darwin ?
09:54:53 <mnislaih> sorry, I mean effect to ghci itself.  I am not loading or compiling any code
09:55:53 <mnislaih> the testsuite  follows this convention, and I can't imagine the purpose, but it seems to have a weird interaction with ghci
09:56:29 <mnislaih> the order of the payload elements of a closure seems to be reversed, and my closure viewer fails
09:59:39 <mnislaih> (that is only a theory)
10:03:14 <LPhas> do { x <- amb; ... }    ===    amb >>= \it@x -> do { ... }
10:03:14 <LPhas> do { amb; ... }    ===    amb >>= \it ->  do { ... }
10:03:16 <LPhas> do amb    ===    amb
10:04:00 <mnislaih> LPhas: did you solve those errors yet ?
10:04:10 <LPhas> mnislaih:nope
10:04:17 <mnislaih> looks like you need to autoreconf
10:05:11 <mnislaih> autoreconf, ./configure .... i.e. the whole ritual
10:05:26 <mnislaih> probably you can get away without cleaning
10:05:37 <xerox> LPhas: like `it' in GHCi '
10:05:38 <xerox> ?
10:05:53 <LPhas> Wouldn't it be cool to have `it' like in GHCi?
10:06:03 <LPhas> xerox:happy now?
10:40:18 <eivuokko> I hate the 100kb size limit on cvs-ghc@.  Gotta start gzipping patches :-S
10:40:48 <profmakx> make smaller ones *duck*
10:41:23 <eivuokko> Heh.  Can't, it's because darcs adds context info on patches.
10:42:45 <fberthold> Is anyone familiar with a method by which you can start an interactive command line program from within a haskell program and read and write to it?
10:43:16 <xerox> ?docs System.Process
10:43:17 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Process.html
10:43:21 <xerox> There!
10:45:55 <fberthold> Thank ye kindly sir.
10:47:17 <SamB> man
10:47:30 <SamB> frisby is hard :-(
10:48:28 <xerox> You're welcome fberthold!
10:56:31 <LPhas> i made autoconf but i got the same errof trying to compile ghc
10:56:33 <LPhas> sigh
11:04:26 <loom> are double and cdouble the same thing in ghc?
11:10:25 <PaulAJ> ?docs Cdouble
11:10:25 <lambdabot> Cdouble not available
11:10:29 <PaulAJ> ?docs CDouble
11:10:29 <lambdabot> CDouble not available
11:10:34 <PaulAJ> ?docs couble
11:10:34 <lambdabot> couble not available
11:10:37 <PaulAJ> ?docs cdouble
11:10:38 <lambdabot> cdouble not available
11:10:43 <PaulAJ> ?docs Double
11:10:43 <lambdabot> Double not available
11:11:09 <mnislaih> @quote Lemmih
11:11:10 <lambdabot>  <shapr> Any idea where we should meet?  *** Lemmih opens Google Earth.
11:11:15 <mnislaih> @quote Lemmih
11:11:16 <lambdabot>  calling an out-of-scope function isn't as easy as I had hoped
11:11:17 <mnislaih> @quote Lemmih
11:11:18 <lambdabot>  <shapr> Any idea where we should meet?  *** Lemmih opens Google Earth.
11:11:20 <mnislaih> @quote Lemmih
11:11:21 <lambdabot>  <shapr> Any idea where we should meet?  *** Lemmih opens Google Earth.
11:11:32 <PaulAJ> Oh well.  Anyone here done anything with semaphores?
11:11:43 <mnislaih> where is that odd weekends and full moon quote ? I need it
11:11:46 <mnislaih> @quote Lemmih
11:11:47 <lambdabot>  calling an out-of-scope function isn't as easy as I had hoped
11:11:51 <mnislaih> :S
11:12:03 <PaulAJ> I want to write a "select"-type construct out of semaphores.
11:12:47 <PaulAJ> The only way I've figured out so far has a memory leak under certain circumstances, and I'd like to get rid of it.
11:15:16 <araujo> hello
11:15:58 <ookk> when i want to do something to many values for instance 1-10000000 i would use a for-loop in an imperative language, but in haskell i have to create a list with 10000000 elements which results in a stack overflow or use ugly stuff like seq, isnt there any better way to do it?
11:16:50 <swiert> ookk: write a (tail-recursive) function?
11:17:44 <ookk> even if i do there is always expressions in it that isnt evaluated directly f n = 1 + f (n-1) for instance
11:18:14 <ookk> if you use sufficiently large n it will overflow beacause it does not evalutate 1+ untill the last moment
11:18:35 <ookk> is there a better way to force strict evalutation?
11:20:30 <PaulAJ> ookk: Do you know about foldl'?
11:21:00 <ookk> yes i do
11:21:19 <ookk> but i think you loose the point of the nice syntax in haskell when you have to resort to fold' and seq
11:21:32 <PaulAJ> Well, I guess that having to give the compiler hints occasionally is the price you pay.  I kind of agree with you about seq: its
11:21:41 <ookk> in Clean you can state if an expression should be strict or not
11:22:07 <PaulAJ> a low level thing.  But !$, strict data type members and so on go a long way to getting rid of the problem.
11:22:58 <jeffno> I'm trying to follow: http://en.wikibooks.org/wiki/Haskell/Class_Declarations
11:22:58 <ookk> it would be easier to write faster code
11:23:11 <ookk> that is not obfuscated by seq and foldl'
11:23:19 <jeffno> Any idea why "data Foo = Foo (x :: Integer, str :: String)" won't compile inside of ghci?
11:24:20 <int-e> because you need curly brackets there
11:24:45 <jeffno> Ah, thanks
11:25:13 <int-e> it's icky but I guess parsing would be more difficult otherwise.
11:26:03 <jeffno> I don't mind the curly brackets.  Just trying to learn stuff when tutorial code doesn't compile is frustrating :)
11:26:40 * PaulAJ goes to fix the wikibook
11:29:57 <PaulAJ> Tis fixed.
11:30:08 <PaulAJ> Rather embarassing actually: I wrote that bit.
11:34:19 <swiert> ookk: ghc should be able to handle pretty big calls to tail recursive functions. Are you running an interpreter?
11:41:50 <PaulAJ> > let f n = 1 + f (n-1) in f 1000
11:41:52 <lambdabot>  Exception: stack overflow
11:42:17 <PaulAJ> Of course, thats not tail recursive.
11:42:22 <int-e> jeffno: the part that's icky is that {} are associated with layout in other places, but not in this one. it's just a minor aesthetic issue.
11:45:35 <PaulAJ> After f(n-1) returns it has to add 1 to it.  Also, you have got the f(0) case?  I just realised I forgot it.
11:46:01 <PaulAJ> > let f 0 = 0; f n = 1 + f (n-1) in f 1000
11:46:02 <lambdabot>  1000
11:46:05 <PaulAJ> > let f 0 = 0; f n = 1 + f (n-1) in f 10000
11:46:07 <lambdabot>  10000
11:46:09 <PaulAJ> > let f 0 = 0; f n = 1 + f (n-1) in f 100000
11:46:10 <lambdabot>  100000
11:46:13 <PaulAJ> > let f 0 = 0; f n = 1 + f (n-1) in f 1000000
11:46:15 <lambdabot>  Exception: stack overflow
11:46:22 <PaulAJ> Hmmm.
11:47:01 <PaulAJ> > let f 0 t = t ; f n t = f (n-1) (t+1) ; in f 1000
11:47:02 <lambdabot>  Add a type signature
11:47:07 <PaulAJ> > let f 0 t = t ; f n t = f (n-1) (t+1) in f 1000
11:47:08 <lambdabot>  Add a type signature
11:47:27 <int-e> oh. that'll cause stack overflows if not used carefully.
11:47:31 <swiert> let f 0 t = t :: Int; f n t = f (n-1) (t+1) in f 1000
11:47:42 <PaulAJ> > let f :: Integer -> Integer -> Integer ; f 0 t = t ; f n t = f (n-1) (t+1) in f 1000
11:47:44 <lambdabot>  <Integer -> Integer>
11:47:49 <int-e> > let f 0 t = t ; f n t = f (n-1) (t+1) in f 1000 1000
11:47:50 <lambdabot>  2000
11:47:54 <swiert> it's overloading Num.
11:47:58 <int-e> > let f 0 t = t ; f n t = f (n-1) (t+1) in f 10000 1000
11:47:59 <lambdabot>  11000
11:48:04 <int-e> > let f 0 t = t ; f n t = f (n-1) (t+1) in f 100000 1000
11:48:05 <lambdabot>  101000
11:48:20 * SamB sends JohnMeacham a functionality patch for Frisby
11:48:47 <ricky_clarkson> > map toUpper "i don't know enough yet, but I can have fun with lambdabot too!"
11:48:49 <lambdabot>  "I DON'T KNOW ENOUGH YET, BUT I CAN HAVE FUN WITH LAMBDABOT TOO!"
11:49:01 <saccade_> what channel should I go to to ask questions about the equivalence of DFAs and regular expressions?
11:49:23 <ihope_> saccade_: #math, I'm guessing
11:49:36 <ihope_> Or... #perl, was it? :-)
11:54:15 <sieni> saccade_: that of course needs some qualifiers. I think that e.g. perl regular expressions describe a larger class than just dfa:s
11:54:44 <sieni> I have a book called "mastering regular expressions" that explained that a bit, but not too deeply
11:55:15 <sieni> probably a better channel would be #theoretical_computer_science or whatever that would be called here
11:55:50 <SamB> what is the difference between #theoretical_computer_science and #haskell?
11:56:08 <int-e> hmm, haskell is applied tcs?
11:56:20 * int-e giggles
11:59:58 <mathrick> <SamB> the way they don't show in the same font is kind of tacky <-- this is your font's fault
12:00:17 <mathrick> or fontconfig configuration, in which case it could be probably fixed
12:00:49 <mathrick> SamB: but unless you have one font to contain all of them, it's fonts' fault
12:05:18 <tibbe> partition is defined in terms of filter like so: partition p xs == (filter p xs, filter (not . p) xs)
12:05:42 <tibbe> but if I would declare a partitionM in the same manner wouldn't I get duplicated side effects in the IO monad?
12:06:02 <tibbe> that is if I use filterM twice
12:06:50 <tibbe> @paste
12:06:51 <lambdabot> http://paste.lisp.org/new/haskell
12:07:15 <lisppaste2> tibbe pasted "partitionM" at http://paste.lisp.org/display/24633
12:07:52 <tibbe> ?users
12:07:54 <lambdabot> Maximum users seen in #haskell: 235, currently: 204 (86.8%)
12:13:46 * SamB thinks IntSet is inefficient
12:13:54 <ookk> is there any haskell library to retrieve an url?
12:14:14 <tibbe> retrieve a file given an URL?
12:14:22 <tibbe> via what protocol?
12:14:27 <ookk> http
12:14:35 <tibbe> @where http
12:14:35 <lambdabot> http://www.haskell.org/http/
12:15:10 <ookk> is it in the standard distrobution?
12:17:23 <SamB> ookk: nope
12:17:47 <lambda_the_insig> hello, I'm hoping to use an STRef from within a runSTUArray call, however I can't seem to get the typechecker to agree with the code that I'm writing.  Is there some example of using an STRef from within the STUArray's construction?  (In this case, I'm using the STRef to store an infinite list of possibilities to try while constructing the STUArray, which when I find one that works, I write the tail of the list back to the
12:17:52 <lambda_the_insig>  STRef.)
12:18:07 <lambda_the_insig> Alternate suggestions are appreciated as well.
12:18:10 <lambda_the_insig> :-)
12:18:31 <SamB> @paste
12:18:31 <lambdabot> http://paste.lisp.org/new/haskell
12:18:34 <SamB> show code!
12:18:50 <SamB> because I think it ought to work
12:19:30 <lisppaste2> lambda_the_insignificant pasted "STRef/runSTUArray" at http://paste.lisp.org/display/24634
12:19:51 <lambda_the_insig> there is a fair amount of other cruft; the function in question the "placeWords"
12:20:03 <lambda_the_insig> (the only place that the runSTUArray appears, FWIW)
12:21:55 <ski> hm, why do you use 'runST' inside 'runSTUArray' ?
12:22:23 <ski> @type Control.Monad.ST.runST
12:22:24 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
12:22:27 <ski> @type Data.Array.ST.runSTUArray
12:22:28 <lambdabot> forall e i. (Ix i) => (forall s. GHC.ST.ST s (Data.Array.Base.STUArray s i e)) -> Data.Array.Base.UArray i e
12:22:39 <lambda_the_insig> throwing spaghetti against teh wall to see what sticks... :)
12:22:44 <sjanssen> lambda_the_insig: what ski pointed out is your first problem
12:22:53 <lambda_the_insig> I hadn't had that initially.
12:24:01 <sjanssen> @hoogle mapArray
12:24:01 <lambdabot> Data.Array.MArray.mapArray :: (MArray a e' m, MArray a e m, Ix i) => (e' -> e) -> a i e' -> m (a i e)
12:24:38 <sjanssen> lambda_the_insig: also, note that mapArray makes a copy of the array, you might not want to do that
12:26:18 <ski> (minor point, it looks a little strange to have '... = let ... in ... where ...' .. why not put all inside the 'where' ?)
12:26:20 <tibbe> ?hoogle concatM
12:26:21 <lambdabot> Prelude.concatMap :: (a -> [b]) -> [a] -> [b]
12:26:59 <lambda_the_insig> ok, makes sense.
12:27:38 <lisppaste2> sjanssen annotated #24634 with "this typechecks" at http://paste.lisp.org/display/24634#1
12:28:16 <sjanssen> lambda_the_insig: your problem was the foldM_, that isn't actually what you wanted
12:28:53 <lambda_the_insig> ok.
12:29:00 <lambda_the_insig> what was what I wanted? :-)
12:29:07 <sjanssen> mapM_
12:29:25 <sjanssen> (I think, at least it gets past the typechecker that way)
12:29:36 <lambda_the_insig> well, I was hoping to modify the array iteratively across the list of elems.
12:29:55 <lambda_the_insig> i.e., start with an empty array, and then place words one at a time.
12:30:02 <sjanssen> you don't need a fold if you're modifying the array inside a Monad
12:30:09 <lambda_the_insig> iteratively over the same data; seemed like a fold to me... :)
12:30:10 <tibbe> how nice, I managed to get infinite recursion somehow :/
12:30:58 <lambda_the_insig> ok, thanks for the assistance.
12:32:16 <sjanssen> lambda_the_insig: a Monadic map is sort of like a fold.  The state that hides in the monad is like the accumulating parameter in foldl
12:32:57 <lambda_the_insig> I see.
12:37:14 <sjanssen> @type \f s xs -> snd $ runState (mapM_ (\x -> get >>= put . flip f x) xs) s -- here is foldl in terms of State and mapM_
12:37:15 <lambdabot> forall a c. (c -> a -> c) -> c -> [a] -> c
12:43:31 <lambda_the_insig> thanks, sjanssen, ski.  That supplies the functionality I was looking for.
12:46:37 <probably_corey> Is there a good haskell shell out there?
13:06:21 <sjanssen> @. elite keal
13:06:21 <lambdabot> G|-|( n3Ed 7O HaV3 P|UGiN +ha+ al1oW C0py p4$7E iN XP
13:06:48 <madpickle> @keal
13:06:49 <lambdabot> Cale etc already pointed out Haskell is puny to nothing to emulate using my barrage of mathematic theories
13:06:55 <madpickle> @. toUpper keal
13:06:55 <lambdabot> compose module failed: IRCRaised Parse error: "toUpper"
13:08:36 <sjanssen> that'd be neat if we could mix Haskell code with bot commands
13:09:01 <heatsink> @elite =<< keal
13:09:02 <lambdabot> =<< xeaL
13:10:01 <heatsink> @. (tell heatsink) girl19
13:10:01 <lambdabot> compose module failed: IRCRaised Parse error: "(tell"
13:10:08 <heatsink> No currying :(
13:15:59 <xerox> ?quote
13:15:59 <lambdabot> ghci.debugger says: http://haskell.org/haskellwiki/Ghci/Debugger
13:16:15 <xerox> hehe, somebody used the wrong command
13:16:33 <xerox> ?quote
13:16:34 <lambdabot> tomasz says: After all, return is only a fancy name for liftM0 :-)
13:17:16 <xerox> ?quote
13:17:16 <lambdabot> Klauso says: haha, this bot seems to have many features
13:17:25 <xerox> ?quote
13:17:26 <lambdabot> ghci.debugger says: http://haskell.org/haskellwiki/Ghci/Debugger
13:17:28 <sjanssen> @protontorpedo
13:17:28 <lambdabot> how does j2ee compare to haskell?
13:17:35 <xerox> ?quote
13:17:35 <lambdabot> lennart says: Even though I'm largely responsible for making CPP available in a Haskell compiler I think it's an abomination.  It should be avoided
13:17:46 <xerox> ?ghc
13:17:50 <lambdabot>  You need -fglasgow-exts to derive an instance for this class
13:18:32 <sjanssen> @. elite ghc
13:18:32 <lambdabot> PArs3 errOR ON InPUT
13:18:48 <ski> hehe
13:19:24 <heatsink> hmm....
13:19:26 <heatsink> @. +karma quote
13:19:26 <lambdabot> compose module failed: IRCRaised Parse error: "+karma"
13:19:45 <sjanssen> @. karma+ quote
13:19:45 <lambdabot> JohnMeacham's karma raised to 1.
13:19:53 <heatsink> ah.
13:20:11 <xerox> hahaha
13:20:18 <xerox> That's unfair
13:20:26 <xerox> ?quote
13:20:27 <lambdabot> malcolm says: Most software doesn't need to be fast.  But all software needs a fighting chance of correctness
13:20:31 <heatsink> Karma roulette :)
13:20:48 <sjanssen> xerox: I think it's a bit better than @. karma- quote
13:20:54 <xerox> Brrrr, no!
13:21:24 <xerox> @. quote . quote
13:21:25 <lambdabot> Not enough arguments to @. hasn't said anything memorable
13:21:25 <sjanssen> how about, @. karma- karma-all
13:21:32 <xerox> o_o
13:21:41 <xerox> :(
13:21:42 <sjanssen> show those karma mongering jerks
13:21:58 <xerox> @karma-all
13:21:58 <lambdabot>  dons                   52
13:21:59 <lambdabot>  shapr                  21
13:21:59 <lambdabot>  xerox                  21
13:21:59 <lambdabot>  dcoutts                20
13:21:59 <lambdabot>  lambdabot              20
13:22:00 <lambdabot> [215 @more lines]
13:22:08 <xerox> Well, we have an exception that wouldn't suffer too much ...
13:22:12 <heatsink> @more
13:22:13 <lambdabot>  Lemmih                 19
13:22:13 <lambdabot>  int-e                  14
13:22:13 <lambdabot>  Cale                   12
13:22:13 <lambdabot>  musasabi               12
13:22:13 <lambdabot>  SamB                   10
13:22:15 <lambdabot> [210 @more lines]
13:24:18 <SamB> @quote
13:24:19 <lambdabot> wilx says: I mean, besides the murders, it all looks so nice.
13:24:26 <SamB> @quote
13:24:26 <lambdabot> sjanssen says: @djinn Haskell -> Curry
13:24:31 <SamB> @djinn Haskell -> Curry
13:24:32 <lambdabot> -- f cannot be realized.
13:24:34 <SamB> @quote
13:24:35 <lambdabot> l33t_h4x0r says: maybe if uve had some professor teach u bullshit in uni yea \n i learned on my own.. k.. i dun give a shit bout terms :p i just code
13:24:48 <SamB> @quote
13:24:48 <lambdabot> syntaxfree says: Many people think the core ideas behind Haskell came from academic luminaries such as Philip Wadler and Simon Peyton-Jones. What actually happened is that during a functional
13:24:48 <lambdabot> programming conference, some key academics were teleported to the Deep Complex Universe. In the Deep Complex Universe some Gnomes were having Tangling problems. Wadler & friends solved their
13:24:48 <lambdabot> problems and as a reward the Tangled Gnomes gave them the S
13:25:16 <SamB> aww... cut off!
13:25:26 <heatsink> the S combinator?
13:25:34 <SamB> @google "In the Deep Complex Universe some Gnomes were having Tangling problems. Wadler & friends solved their"
13:25:37 <lambdabot> http://tunes.org/~nef/logs/haskell/06.07.26
13:25:38 <sjanssen> @google "some key academics were teleported to the Deep Complex Universe"
13:25:39 <lambdabot> http://tunes.org/~nef/logs/haskell/06.07.26
13:30:09 <jbalint> Hi.
13:30:51 <sjanssen> hello jbalint
13:31:14 <jbalint> I am trying to figure out how to do this http://rafb.net/paste/results/7Mu9qp86.html The function ldpf seems to be the only indendent one, the other ones seem mutually dependant on each other.
13:33:22 <heatsink> What do you mean about independent functions?
13:33:49 <jbalint> how can i create them if they need each other before they can be created?
13:34:23 <heatsink> They're all read before they are created.
13:34:33 <heatsink> >let {x = y + 1; y = 2} in x
13:34:37 <heatsink> > let {x = y + 1; y = 2} in x
13:34:38 <lambdabot>  3
13:34:45 <heatsink> > let {y = 2; x = y + 1} in x
13:34:46 <lambdabot>  3
13:34:48 <jbalint> Oh, let me put them in a file.
13:34:50 <tibbe> hmpf, I want to know what OS my program is running on so I can fetch the correct path separator char
13:35:22 <heatsink> I think that's in the System.Info module.  I don't know if there's a platform-independent way to do it.
13:35:54 <jbalint> Ok, I should have tried that earlier. :) Thanks.
13:35:59 <heatsink> sho
13:37:40 <xerox> > let odds = 1 : map (+1) evens; evens = map (+1) odds in zip odds evens
13:37:42 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21,...
13:37:50 <chessguy> anyone familiar with SICP, the video series?
13:38:03 <SamB> tibbe: why not just use a /?
13:38:09 <psi> I've seen a few of them.
13:38:20 <xerox> Yep!
13:38:30 <heatsink> SamB: on windows it is \
13:38:37 <SamB> heatsink: / usually works too though
13:38:59 <chessguy> they do a lot of stuff like (define (+rat r1 r2)...), but what prevents someone from then doing (+rat PI (2*PI))
13:39:14 <chessguy> is there a purely functional way of preventing this?
13:39:17 <xerox> (+rat PI (* 2 PI))
13:39:31 <chessguy> yes, sorry, typo
13:39:37 <SamB> WTH is +rat
13:39:44 <xerox> The fact that one has to use make-rat ?
13:39:45 <sjanssen> chessguy: so you want to restrict the arguments to rationals?
13:39:46 <chessguy> it adds two rational numbers together
13:39:53 <chessguy> yes
13:39:56 <xerox> Nothing in fact
13:39:57 <SamB> oh
13:40:10 <SamB> the fact that PI isn't a rational number might do the trick...
13:40:13 <sjanssen> chessguy: there is a way: use a sexily typed language like Haskell
13:40:14 <xerox> You'd get a runtime error in many cases
13:40:27 <SamB> > pi + 2*pi :: Rational
13:40:28 <lambdabot>  add an instance declaration for (Floating Rational)
13:40:29 <xerox> s/sexily/statically checked/
13:40:58 <SamB> heh
13:41:00 <xerox> You should ask that question in #scheme
13:41:21 <chessguy> i asked in lisp and was told that i should use lisp classes
13:41:33 <xerox> Right, but that is Scheme, not Common Lisp.
13:41:46 <SamB> did you ask them why + is not a method?
13:41:51 <SamB> ... you should!
13:41:53 <chessguy> mmm
13:42:06 <chessguy> it's not?
13:42:21 * chessguy assumes that by method you mean procedure
13:42:37 <SamB> * #'+
13:42:37 <SamB> #<Function + {10127429}>
13:42:40 <xerox> Nope, he means method in the object-oriented programming sense
13:43:10 <xerox> Which in case of CL means something specific, given the CLOS.
13:43:12 <tibbe> SamB, Does it work alright on Windows?
13:43:38 <SamB> tibbe: if you aren't passing the path to ignorant programs on the commandline, sure!
13:45:43 <hitodama> what does the term "principal type" mean in Haskell?
13:46:14 <xerox> It is the most general type of an expression
13:46:14 <SamB> a principle type is a most general type that can be inferred for something
13:46:46 <xerox> Take id, it can be given the type Int -> Int, (a -> b) -> a -> b, etc.. but the most general one is a -> a.
13:46:47 <SamB> at least, I assume they can always be inferred if they exist...
13:46:57 <hitodama> hmm, so it's used for polymorphic objects?
13:47:09 <xerox> s/objects/types/
13:47:52 <xerox> I don't think so, anyway
13:48:19 <xerox> ?type chr . (+13) . ord
13:48:21 <lambdabot> Char -> Char
13:48:28 <xerox> That is its most general type.
13:48:36 <hitodama> ahh
13:48:39 <hitodama> I think I see, thanks
13:48:58 <nilsi> i wonder if theoretical computer science is applied haskell
13:48:59 <xerox> But I believe it makes sense to ask for it only if you have polymorphic types :)
13:49:13 <xerox> nilsi: that's part of the principal idea! :)
13:49:22 <xerox> nilsi: did you see the paper `History of Haskell' ?
13:49:43 <nilsi> yes, version 1 that is
13:51:20 <nilsi> i like the short examples of advanced type theory i never use
13:53:40 <xerox> ?wiki Roman_Numerals
13:53:41 <lambdabot> http://www.haskell.org/haskellwiki/Roman_Numerals
13:53:58 <xerox> hmmm
13:54:07 <xerox> ?wiki Roman_numerals
13:54:07 <lambdabot> http://www.haskell.org/haskellwiki/Roman_numerals
13:54:12 <xerox> That for example? :D
13:55:52 <sjanssen> hmm, what would be another fun algorithm to write in the type system?
13:56:22 <SamB> a parser!
13:56:24 <SamB> write a parser!
13:56:42 <heatsink> heh
13:57:16 <sjanssen> @fptools Data.List
13:57:17 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
13:57:19 <heatsink> How about a finite map.
13:57:39 <sjanssen> w/o balancing would be pretty easy
13:58:38 <heatsink> If you can write a finite map in the type system, you would have associated types, right?
13:58:45 <beelsebob> @seen shapr
13:58:45 <lambdabot> I saw shapr leaving #haskell and #ScannedInAvian 6 days, 2 hours, 15 minutes and 12 seconds ago, and .
13:58:48 <hitodama> hm why does func xs = map ((/2).(+1)) xs work, but not func = map ((/2).(+1)) ?
13:58:49 <beelsebob> heh
13:58:51 <beelsebob> @getshapr
13:58:51 <lambdabot> shapr!!
13:59:09 <heatsink> hahaha!
13:59:20 <xerox> hitodama: it should
14:00:11 <hitodama> agh, typo in my code, thanks though
14:02:00 <xerox> sjanssen: Implement ^(11+)\1+$
14:06:26 <xerox> boom
14:07:08 * heatsink is dizzy
14:09:44 <heatsink> You see, from your perspective, the other person leaves the room and comes back but you don't move.  From the other person's perspective, you leave the room and come back but they don't move.  That's relativity!  IIRC.
14:11:09 <SamB> that only works if it is a real netsplit
14:12:16 <heatsink> What other kind of netsplit happens?
14:12:48 <heatsink> I thought all these multiple-quit multiple-enter events were netsplits.
14:13:51 <SamB> well, sometimes they skip the multiple-enter bit
14:13:57 <SamB> which means it is a fake netsplit
14:14:11 <SamB> when a downed server has been cut loose from the network...
14:16:55 <heatsink> That would be a miscolored horse.
14:19:25 <tibbe> I'm thinking of writing some sort if dry run function. It would gather a bunch of IO actions [IO ()] and then either execute them or pretty print the function names, would that even be possible or do I need to create my own data type for it?
14:20:16 <swiert> tibbe: yes. There's no easy way to figure out a function's name.
14:20:21 <tibbe> basically it would be a list of removeDirs and removeFiles
14:21:27 <tibbe> swiert, ok, I'll go with a data IOAction = RemoveDir FilePath | RemoveFile FilePath then, although it feels a bit like repition
14:22:53 <svref> So are guards in case expressions exactly equivalent to if-then-else-if... statements in the body?
14:24:08 <ndm> so Cabal then, where do i email a Cabal question to?
14:24:08 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
14:24:23 <musasabi> cabal-dev perhaps
14:24:35 <musasabi> or haskell-cafe depending on the question
14:24:41 <ndm> musasabi: or libraries@ (thats what teh docs say), or haskell-care
14:24:51 <ndm> yeah, i don't care where, but i would like to have one answer
14:24:55 <heatsink> svref, yea
14:25:08 <ndm> anyway, the question is: what about extra files to distribute with an app
14:25:08 <xerox> tibbe: you could roll up your own monad
14:25:23 <ndm> for example cpphs includes a settings file, and a .css file, which need to be distributed to
14:25:36 <ndm> I saw how Alex does it, but it uses hooks and copies things itself, which is yuk
14:25:38 <xerox> tibbe: WriterT IO [String] a, and then have your actions doing lift (tell "name") :)
14:25:39 <musasabi> there is a extra-files section I think
14:26:01 <ndm> musasabi: yes, extra-source-files, but its not copied into the installation
14:26:25 <ndm> extra-source-files-which-need-installing is that i want, but can't see anything like that
14:26:30 <xerox> brb
14:26:34 <ndm> @seen dons
14:26:35 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 5 hours, 6 minutes and 31 seconds ago.
14:26:53 <tibbe> xerox, does it (WriterT) perform the actions and write a log?
14:27:32 <ndm> @tell dons if you can convince me there has ever been a time when a user has wanted to search for a kind i might add it :) - in reality though there are too many types for each kind, and haddock doesn't know kinds, so its hard to get the info
14:27:32 <lambdabot> Consider it noted.
14:27:57 <tibbe> xerox, or do you mean that the actions should be parameterized with a boolean flag that decides if it will be executed or "told"?
14:27:58 <ndm> @tell dons but i did add some kind support to hoogle today, as it happens, so it can spot when you search for Maybe, when you meant Maybe a
14:27:59 <lambdabot> Consider it noted.
14:30:44 <tibbe> ?hoogle endsWith
14:30:44 <lambdabot> No matches found
14:34:19 <heatsink> @hoogle isSuffixOf
14:34:19 <lambdabot> List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
14:54:49 <ihope_> > (>=)
14:54:50 <lambdabot>  Add a type signature
14:54:54 <ihope_> > (=>)
14:54:54 <lambdabot>  Parse error
14:55:14 <alunoiemestrado> simply put, how do I say "firstArg = do { f<-getArgs; return (head f)}"  without do notation?
14:56:03 <norpan> firstArg = fmap head getArgs
14:56:24 <alunoiemestrado> oh, ok!
14:56:26 <norpan> or getArgs >>= \f -> return (head f)
14:56:36 <int-e> or  getArgs >>= return . head
14:56:38 <int-e> more?
14:56:41 <alunoiemestrado> what about nextver k l = do { x<-nonexisting k l; return (head x)}
14:56:42 <alunoiemestrado> ?
14:56:53 <int-e> return . head =<< getArgs
14:56:55 <alunoiemestrado> return . head, yes, yes!
14:57:25 <norpan> alunoiemestrado: that's exactly the same
14:57:32 <int-e> nextver k l = fmap head (nonexisting k l)
14:57:40 <alunoiemestrado> true.
14:58:09 <qwr> nonexisting k l >>= return . head
14:58:47 <alunoiemestrado> @paste
14:58:47 <lambdabot> http://paste.lisp.org/new/haskell
14:59:16 * tibbe is lost in his own recursion
14:59:30 <alunoiemestrado> I present you my automatical version name generator ...
14:59:35 <lisppaste2> syntaxfree/alunoiemestrado pasted "... in all it's glory!" at http://paste.lisp.org/display/24644
15:00:40 * alunoiemestrado jumps up and down in wild celebration
15:01:25 <tibbe> :D
15:02:42 <xerox> ?yow!
15:02:43 <lambdabot> Will it improve my CASH FLOW?
15:02:51 <alunoiemestrado> yes, it will.
15:03:13 <sieni> no, it wont.
15:03:21 <alunoiemestrado> now I have to learn sendmail or something, and I'll use gmail as my PERSONAL VERSION CONTROL SYSTEM muhahaha
15:03:47 <xerox> ?keal
15:03:47 <lambdabot> 99% of my book has been erased by faulty hdd's
15:03:49 <alunoiemestrado> (as long as my projects don't have more than 203 versions, which they won't)
15:04:11 <alunoiemestrado> ?keal
15:04:12 <lambdabot> #haskell needs to take its meds
15:05:39 <Oejet> alunoiemestrado: So you always call the first version "adams"?
15:05:53 <alunoiemestrado> yep.
15:06:01 <alunoiemestrado> @keal
15:06:02 <lambdabot> can you make a macro that builds the expression accoridng to a genetic algorithm where you decide what is good and what is bad?
15:06:27 <alunoiemestrado> @keal
15:06:27 <lambdabot> bot seems useless
15:06:30 <alunoiemestrado> @keal
15:06:30 <lambdabot> perhaps i just genius and never tested
15:06:32 <alunoiemestrado> sorry.
15:06:35 <alunoiemestrado> I won't flood anymore.
15:07:52 <xerox> ?quote
15:07:53 <lambdabot> jrmole says: any program that could read minds would just evolve into a porn downloader
15:08:29 <alunoiemestrado> @qyote
15:08:30 <lambdabot> heatsink says: @pl (\y -> you y off)
15:08:34 <alunoiemestrado> @quote
15:08:34 <lambdabot> darius says: Well profiling does add a bit of reflection, but it should have the good sense not too go near the barbed wire fences and armed guards.
15:14:41 <Oejet> alunoiemestrado: What do you give the program as argument?
15:14:48 <alunoiemestrado> a project name.
15:14:58 <Oejet> Any project name?
15:15:07 <alunoiemestrado> then it checks if project.adams exists ,and returns agdenstein.
15:15:45 <alunoiemestrado> it will be used on a shell script with something like "cp -r project `nextver project`"
15:15:56 <alunoiemestrado> and then I want it automatically mailed to me.
15:16:52 <alunoiemestrado> er, "cp -r project project.$(nextver project)"
15:16:58 <alunoiemestrado> see?
15:17:16 <Oejet> And it checks, if the next project already exists also?
15:17:56 <alunoiemestrado> yep.
15:18:10 <alunoiemestrado> oh, it doesn't.
15:18:22 <alunoiemestrado> well, I don't intend to mess with it by creating a manual project.kasparov.
15:18:35 <xerox> @quote
15:18:36 <lambdabot> Itkovian says: real programmers don't write docs, if it was hard to write, it should be hard to understand
15:18:37 <Oejet> Why does it have this doesFileExist?
15:18:54 <alunoiemestrado> I originally wanted better checking, but I can't seem to get a list of files as a haskell list.
15:19:08 <alunoiemestrado> Oejet: oh, it checks if Adams exists. if it does, it checks for agdenstein.
15:19:24 <alunoiemestrado> if there's agdenstein then it checks for akopian, etc. etc.
15:19:40 <Itkovian> ong is that still in there?
15:20:00 <Oejet> So you would just call it with "adams" all the time?
15:20:27 <alunoiemestrado> Not necessarily.
15:20:38 <alunoiemestrado> If there aren't any project.* files, it generates project.adams
15:21:40 <alunoiemestrado> (it returns "adams", actually)
15:21:57 <alunoiemestrado> I would write the whole project-copying behaivour in haskell, but I need windows and unix compatibilty.
15:22:10 <alunoiemestrado> so the end part iwll be done with batch files/shell scripts.
15:22:29 <alunoiemestrado> I also need to send mails from the unix command line. What do I need for that?
15:23:01 <Oejet> "mail".
15:25:54 <alunoiemestrado> anyway.
15:25:59 <alunoiemestrado> I'm going home. Thanks for the help.
15:26:55 <xerox> ?quote
15:26:56 <lambdabot> SebastianHanowski says: I tried to formalise a proof of rev (rev l)  = l i found in W. Kluges book "Abstract Computing Machines - A Lambda Calculus Perspective" which is pretty much a 'Pimp My Ride'
15:26:56 <lambdabot> for SECD-machines.
15:27:23 <xerox> Some quotes are remarkable.
15:28:13 <ndm> xerox, i have a question about cabal-get
15:28:27 <Oejet> Can you limit the quote set with some pattern?
15:28:36 <ndm> ?quote ndm
15:28:36 <xerox> ndm: go on!
15:28:36 <lambdabot>  the only language i've seen which is ugly at a deeper level than syntax is perl
15:28:55 <ndm> xerox: it can download the dependant packages automatically, right?
15:29:00 <xerox> Yep.
15:29:07 <Oejet> ?quote Oejet
15:29:07 <lambdabot> Oejet hasn't said anything memorable
15:29:09 <ndm> what about dependant preprocessors
15:29:12 <Oejet> :'(
15:29:24 <int-e> @quote ghc
15:29:24 <lambdabot>  Kind error
15:29:26 <xerox> Preprocessors?
15:29:32 <ndm> for example, hoogle depends on trhsx, as a preprocessor not as a package
15:29:42 <ndm> say a program requires cpphs, which isn't installed
15:29:59 <xerox> There is no way to say that to Cabal yet, I believe.
15:30:02 <ndm> could cabal-get grab cpphs (a haskell/cabal program), but which isn't a library dependancy, but a preprocessor one
15:30:26 <ndm> thats a shame, since haddock depends on happy and alex, alex depends on happy
15:30:33 <ndm> its quite a mess to get those 3 in the right order
15:30:40 <ndm> (esp when at least one is broken in HEAD at the mo)
15:30:52 <xerox> ndm: do you remember when I told you what Alex Jacobson was telling me....
15:31:05 <ndm> xerox: remind me :)
15:31:05 <SamB> I think you are supposed to grab them from your distribution's package manager
15:31:15 <xerox> ndm: that problem isn't solvable in general :(
15:31:27 <ndm> xerox: why not - simply list the required preprocessors?
15:32:22 <xerox> ndm: circularities like the one you mentioned are a problem, aren't them?
15:32:36 <ndm> xerox: it isn't circular, there is exactly one linear path to do it
15:32:45 <ndm> which is why having a program that solved it would be nicer
15:32:51 <ndm> and i think it could get quite far
15:33:00 <ndm> at the moment the hoogle install instructions are going to have to be
15:33:01 <xerox> Oh right, happy first.
15:33:15 <ndm> cabal get trhsx, build, install, then do hoogle
15:33:24 <ndm> i.e. "here are a list of dependancies, please build them"
15:33:40 <xerox> That sounds okay, as long as it is haskell software.
15:33:51 <ndm> yeah, i realise that preprocessors that aren't haskell won't work
15:34:07 * SamB will write a preprocessor in C, called "wrench"
15:34:08 <ndm> but i can't think of any haskell preprocessors not written in haskell
15:34:35 <ndm> SamB: and someone can port it to haskell, in 5% of the time it takes you to track down the memory leaks :)
15:34:47 <xerox> Anyway, now we have build-deps, it is surely possible to add other kind-of-deps.
15:35:02 <SamB> okay, maybe I'll write it in Python instead
15:35:09 <xerox> Just matter of: a. decide a design with the cabal-devel hackers and b. implement it.
15:35:12 <int-e> perl?
15:35:23 <SamB> or perl ;-)
15:35:31 <xerox> Then let it be a oneliner!
15:35:34 <int-e> I know, Java. Java has garbage collection, so memory leaks aren't a problem. Right?
15:35:39 <SamB> xerox: thats no good
15:35:52 <SamB> then it will just be included in the cabal file or something
15:36:01 <xerox> SamB: you could do a system("") from a C source and don't tell anyone.
15:36:05 <ndm> happy and alex both have one line perl preprocessors in their Setup.hs
15:36:38 <SamB> ndm: yes but those can't be called "wrench" or mess up the niceness of Cabal
15:36:45 * xerox is reminded of the GHC evil mangler
15:37:10 <ndm> xerox: one day, that will be killed - it seems like SimonMar's life ambition
15:37:13 <int-e> but that's a postprocessor not a preprocessor, that's totally different.
15:37:31 <xerox> ndm: yarrr
15:37:37 <xerox> int-e: off course.
15:37:55 <int-e> Oh and I was hoping I was just barely on course.
15:37:56 <ths> int-e: It looked like a postpervertor to me. :-)
15:38:50 <SamB> "pervert" and "process" are remarkably similar in meaning
15:39:01 <int-e> it does some interesting optimizations
15:39:29 <ndm> but Cmm will obsolete it, we all hope
15:39:38 <int-e> for example it turns some indirect jumps into direct jumps :)
15:40:04 <xerox> `indirect' in what sense?
15:40:18 <ths> Via register, I guess.
15:40:29 <int-e> via memory or registers
15:40:36 <int-e> (on x86 both is possible)
15:40:37 <xerox> Ah, I see.
15:41:15 <tibbe> @pl concat $ zipWith (\prefix dirs -> map ((prefix ++ "/") ++) dirs )
15:41:15 <lambdabot> join (zipWith (map . (++) . (++ "/")))
15:41:24 <tibbe> ugh
15:42:03 <tibbe> dunno if that got more readable
15:42:28 <tibbe> ndm, is Cmm still worked on?
15:42:35 <ndm> tibbe: its the future (TM)
15:42:51 <ndm> i saw a pile of patches recently, quite a lot of work
15:43:01 <ndm> you can now compile the runtime with Cmm, or something like that
15:43:06 <tibbe> who's working on it?
15:43:12 <ndm> SimonMar
15:43:14 <eivuokko> ndm, Only almost.
15:43:28 <ndm> eivuokko: i just believed the commit message :)
15:43:57 <Phas>  darcs get http://www.cse.unsw.edu.au/~dons/yi
15:43:57 <lambdabot> Title: Index of /~dons/yi
15:44:00 <eivuokko> There's atleast problem with some sign/zero extension on 32bit platforms, and at AngloHaskell SimonM said there was something else as well.
15:44:01 <Phas> d'uh
15:44:05 <Oejet> Related to alunoiemestrado's project.  Is there a way to lift dropWhile into the IO monad, so you can do: dropWhileIO doesFileExist ["abe", "kat", "hund"] => ["hund"], say if abe and kat exists?
15:44:12 <Phas> @localtyme dons
15:44:14 <lambdabot> Local time for dons is Thu Aug 24 08:41:48 2006
15:44:54 <tibbe> :t join
15:44:59 <int-e> @index whileM
15:44:59 <lambdabot> bzzt
15:45:01 <ndm> @type join
15:45:02 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
15:45:17 <Oejet> dons is in his most productive hour of the day. :-P
15:45:20 <tibbe> what on earth does that mean
15:45:27 <int-e> mapM obviously but that's not lazy.
15:45:43 <SamB> tibbe: what does what mean?
15:46:03 <tibbe> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
15:46:20 <SamB> @free M (M a) -> M a
15:46:21 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:57:20-34
15:46:26 <SamB> @free join :: M (M a) -> M a
15:46:27 <lambdabot> $map_M f . join = join . $map_M ($map_M f)
15:46:50 <tibbe> what does it do?
15:46:59 <xerox> tibbe: think of `m a' as a box of values of type `a'.  `m (m a)' is a box of boxes of values of type `a'.
15:47:17 <xerox> tibbe: join takes the elements of each box in the box of boxes, and constructs with them a box of elements.
15:47:22 <ndm> @google haskell wiki monads as containers
15:47:24 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
15:47:25 <lambdabot> Title: MonadsAsContainers - The Haskell Wiki
15:47:35 <ndm> tibbe: read that
15:47:38 <xerox> Right, that :)
15:47:43 <SamB> @type \p -> do x <- p; x
15:47:44 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
15:48:02 <SamB> @type join
15:48:03 <xerox> ?type guard
15:48:03 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
15:48:05 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
15:48:20 <tibbe> so it unwraps on layer of monads?
15:48:31 <xerox> tibbe: it joins ;)
15:48:54 <xerox> tibbe: the implementation of joins describes part of the monad. The other parts are described by map and return.
15:49:05 <tibbe> xerox, perhaps you could explain how join extends to the box metaphore :D
15:49:09 <xerox> tibbe: you can then define bind in terms of join and map.
15:49:18 <SamB> xerox: except that join isn't a member of the Monad class
15:49:24 <xerox> tibbe: that article ndm mentioned explains it.
15:49:30 <tibbe> xerox, ok
15:49:33 <xerox> SamB: that's only a design decision.
15:49:41 <SamB> xerox: yes I know
15:50:06 <SamB> probably because >>= is usually easier to define...
15:50:09 <xerox> tibbe: in fact it gives you the exact same explanation I would have give you now.
15:50:22 <xerox> SamB: it is more convenient to do it in terms of map and join for some monads.
15:50:30 <SamB> or more efficient as a primitive...
15:50:41 <SamB> well, considering that most monads are newtyped function types...
15:50:45 <xerox> Now that's difficult...
15:51:36 <kpreid> Oejet: of course it's *possible*. dropWhileIO f l = mapM (\x -> do r <- f x; (x, r)) l >>= \l' -> return . map fst . dropWhile snd $ l'
15:52:42 <SamB> kpreid: isn't it supposed to stop checking after the predicate returns False?
15:52:43 <Oejet> kpreid, int-e: Yes it seems the strict version is nice, and the lazy version is ugly.
15:53:14 <kpreid> SamB: oops.
15:53:18 <kpreid> hmm
15:54:26 <Oejet> dropWhileIO :: (a -> IO Bool) -> [IO a] -> [IO a]
15:54:40 <kpreid> -> IO [a] surely?
15:55:22 <SamB> xerox: well, for monads like those in the MTL, isn't it more convenient and more efficient to define >>= and return?
15:55:54 <xerox> SamB: I'd say the list one is surely convenient to express in terms of map and concat.
15:56:11 <xerox> No precise idea about the efficiency tough, that's left to GHC for me.
15:56:11 <SamB> yeah
15:56:26 <Oejet> dropWhileIO :: (a -> IO Bool) -> [IO a] -> IO [a]
15:56:42 <SamB> oh, well, what would join look like for, say, State?
15:56:51 <kpreid> dropWhileM f [] = return []
15:56:52 <SamB> newtype State s a = State { runState :: s -> (a, s) }
15:56:52 <kpreid> dropWhileM f l@(x:xs) = do r <- f x; if r then dropWhileM f xs else return l
15:56:56 <kpreid> doesn't seem too ugly
15:57:32 <xerox> join :: State s (State s a) -> a
15:58:09 <xerox> Ops.
15:58:12 <xerox> join :: State s (State s a) -> State s a
15:58:30 <SamB> I meant the implementation, silly!
15:58:36 <xerox> One at time.
16:00:32 <SamB> @type \(State f) -> State (\s -> case f of (State g, s') -> g s)
16:00:33 <lambdabot>   Couldn't match `s -> (a, s)' against `(a1, b)'
16:00:34 <lambdabot>    Expected type: s -> (a, s)
16:00:56 <xerox> ?type let join (State f) = State $ \x -> case f x of ((State g),s') -> g s' in join
16:00:57 <lambdabot> forall s a. State s (State s a) -> State s a
16:01:15 <xerox> s/x/s/ :D
16:01:59 <SamB> so what is the definition of >>= in terms of join and fmap?
16:02:18 <xerox> amb >>= f = join (map f amb)
16:02:36 <Oejet> kpreid: Sold!
16:04:01 <SamB> @type let fmap f (State g) = State (\s -> let (x, s') = g s in (f x, s')) in fmap
16:04:02 <lambdabot> forall a a1 s. (a -> a1) -> State s a -> State s a1
16:04:59 <SamB> so what happens when you expand join and map there?
16:06:02 <xerox> You get bind.
16:06:17 <SamB> no, I mean... whats it look like...
16:06:58 <tibbe> @where GetOpt
16:06:58 <lambdabot> I know nothing about getopt.
16:08:32 <xerox> @hoogle GetOpt
16:08:33 <lambdabot> Distribution.GetOpt :: module
16:08:33 <lambdabot> Distribution.GetOpt.getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
16:08:33 <lambdabot> Distribution.GetOpt.getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])
16:11:24 <chessguy> is normal-order evaluation the same as lazy evaluation?
16:12:04 <xerox> I don't think so.
16:13:30 <SamB> lets see...
16:13:37 <chessguy> so...what's the difference, dare i ask
16:15:11 <SamB> well, well, what do you know...
16:15:20 <SamB> apparantly the code for:
16:15:21 <Frederick> hello
16:15:22 <SamB> bind amb f = join (fmap f amb)
16:15:22 <SamB>     where
16:15:22 <SamB>     join (State f) = State $ \s -> case f s of ((State g), s') -> g s'
16:15:26 <Frederick> Hi SamB ! :)
16:15:44 <SamB> comes out the same as Control.Monad.State.poly_>>=
16:15:53 <SamB> Frederick: hello
16:15:55 <xerox> chessguy: see if foldoc.org can enlighten you
16:17:41 <Frederick> folks does anyone have a more mathematical insigh paper about monads / comonads?
16:17:43 <SamB> xerox: which is kind of nice...
16:18:01 <xerox> SamB: %-)
16:19:18 <SamB> xerox: (though the names come out longer for various reasons)
16:19:52 <SamB> though it looks much nicer if you read the .hi file than if you read the output of -ddump-simpl
16:20:24 <SamB> actually the only name that comes out longer is Control.Monad.State.State
16:21:21 <xerox> Ah.
16:22:21 <SamB> assuming you read the .hi file rather than the -ddump-simpl output
16:23:10 <tibbe> Distribution.GetOpt is listed in the docs but GHCi says it's hidden
16:24:00 <tibbe> how come?
16:25:04 <xerox> tibbe: ghc-pkg list shows Cabal hidden perchance?
16:25:21 <xerox> I.e. in parens.
16:26:04 <SamB> incidentally I think --show-iface is a little broken in 6.4.2
16:26:14 <SamB> poly_>>= :: State s a -> (a -> State s b) -> State s b
16:26:14 <SamB>   {- Arity: 3 HasNoCafRefs Strictness: LC(C(S))L
16:26:14 <SamB>      Unfolding:
16:26:14 <SamB>      (\ @ s @ a @ b m :: State s a k :: a -> State s b s :: s ->
16:27:03 <Frederick> any ideas?
16:27:03 <SamB> shouldn't the "m :: State s a" and "k :: a -> State s b" be parenthesized
16:27:27 * SamB doesn't know the first thing about comonads
16:27:34 <SamB> or the second thing, for that matter
16:27:47 <Frederick> SamB, nor about monads?
16:27:57 <lispy> SamB: but you're all over that 3rd thing :)
16:28:00 <SamB> no, I don't know the second thing about comonads
16:28:11 <xerox> Ideas about what?
16:28:14 <SamB> lispy: don't know what you are talking about ;-)
16:28:20 <SamB> xerox: papers about monads and comonads...
16:28:34 <tibbe> xerox, it shows two versions, 1.0 inside paranthesis and 1.1.3 without
16:28:35 <musasabi> comonads are cute
16:28:51 <xerox> tibbe: try -package Cabal-1.1.3
16:29:35 <SamB> oh, also, what is with the "s :: s ->"
16:29:46 <SamB> how does that make sense?
16:29:50 <SamB> @kind (s ->)
16:29:52 <lambdabot> parse error on input `)'
16:29:58 <SamB> @kind ((->) s)
16:29:58 <xerox> No type sections, if any.
16:29:59 <lambdabot> Not in scope: type variable `s'
16:30:07 <xerox> ? -> * anyway
16:30:32 <int-e> @kind (->)
16:30:33 <lambdabot> ?? -> ? -> *
16:30:36 <SamB> it should just say "s :: s"
16:30:42 <int-e> @kind (->) Int
16:30:43 <lambdabot> ? -> *
16:31:01 <tibbe> xerox, I did a :set -package Cabal-1.1.3 and got: it is hidden (in package Cabal-1.1.3)
16:31:12 <SamB> not "s :: s ->"
16:31:55 <SamB> oh wait, looks like I've 6.4.1
16:32:31 <SamB> xerox: what happens when you compile:
16:32:36 <SamB> bind :: State s a -> (a -> State s b) -> State s b
16:32:36 <SamB> bind amb f = join (fmap f amb)
16:32:36 <SamB>     where
16:32:36 <SamB>     join (State f) = State $ \s -> case f s of ((State g), s') -> g s'
16:32:43 <int-e> are these strictness annotations explained somewhere? what does C(...) mean?
16:32:54 <SamB> and run "ghc --show-iface" on it in 6.4.2?
16:34:16 <xerox> SamB: wait
16:34:41 <xerox> Do you use Control.Monad.State
16:34:48 <xerox> Or a definition, and a Functor instance?
16:35:16 <SamB> xerox: Control.Monad.State and the Functor instance...
16:36:17 <xerox> Should I put it in a Main?
16:36:27 <SamB> well, mine is in a Bind
16:36:54 <xerox> I am not sure what do you feed ghc for show-iface
16:37:13 <SamB> ghc --show-iface basename.hi
16:37:25 <xerox> bind :: Control.Monad.State.State s a
16:37:25 <xerox>         -> (a -> Control.Monad.State.State s b)
16:37:25 <xerox>         -> Control.Monad.State.State s b
16:37:52 <SamB> oh, did you build with -O btw?
16:38:10 <SamB> anyway, right before the first let I have
16:38:14 <SamB>           s :: s ->
16:38:19 <xerox> Bool.
16:38:25 <xerox> Yes, me too.
16:38:33 <xerox> (I have only one let)
16:38:52 <SamB> you have:
16:38:53 <xerox> I think that is the -> of the lambda
16:38:55 <SamB>           s :: s ->
16:38:57 <SamB> too?
16:39:02 <SamB> oh. of the lambda?
16:39:08 <xerox> Unfolding (\ ...
16:39:11 <SamB> what a strange place to put it!
16:39:20 <xerox> It's all strange that output.
16:39:23 * SamB thinks it ought to be moved
16:39:38 <xerox> What are those @ ?
16:39:43 <SamB> type application
16:39:48 <xerox> Yuck.
16:40:11 <Pseudonym> @uptime
16:40:16 <Pseudonym> I think lambdabot's dead.
16:40:21 <SamB> hey, I think has System F's typesystem with extension -- you were expecting type inference?
16:40:21 <xerox> @botsnack
16:40:26 <lambdabot> uptime: 17 hours, 18 minutes and 37 seconds
16:40:26 <lambdabot> :)
16:40:30 <Pseudonym> Ah.
16:40:31 <SamB> er, s/think/think Core/
16:40:33 <Pseudonym> There we are.
16:40:37 <xerox> You see, she need her snacks.
16:41:02 <SamB> xerox: oh, also type patterns
16:41:03 <xerox> *needs
16:42:03 <xerox> Type patterns!
16:42:05 <xerox> ds :: (a, s) = amb s
16:42:24 <Pseudonym> @. @free id:: @type \x -> x
16:42:24 <lambdabot> compose module failed: IRCRaised Parse error: "@free"
16:42:30 <Pseudonym> It'd be nice if you could do that.
16:42:43 <xerox> Please hack lambdabot to support parens at that level :(
16:42:49 <xerox> Let's put some grant or something
16:43:11 <Pseudonym> SoC application #162: We'd like to make our IRC bot better!
16:43:35 <SamB> huh
16:44:07 <SamB> GHC is smart
16:44:22 <Frederick> folks is there any good website for cathegory cathegory stuff?
16:44:24 <SamB> Functor dictionaries *are* fmap
16:44:34 <xerox> @remember SamB GHC is smart
16:44:35 <lambdabot> Done.
16:44:57 <SamB> that is going to come back to haunt me, isn't it?
16:45:01 <madpickle> @remember madpickle Stuff costs more than it used to.
16:45:01 <lambdabot> Done.
16:45:12 <madpickle> @madpickle
16:45:13 <lambdabot> Unknown command, try @list
16:45:15 <madpickle> :/
16:45:18 <madpickle> i need an @madpickle
16:45:29 <SamB> @google "@remember madpickle Stuff costs more than it used to."
16:45:29 <xerox> Join #madpickle
16:45:30 <lambdabot> No Result Found.
16:45:38 <SamB> @google "Stuff costs more than it used to."
16:45:42 * xerox yarrsss in SamB general direction
16:45:43 <Pseudonym> @yow
16:45:46 <lambdabot> http://www.everything2.com/index.pl?node_id=974737
16:45:46 <lambdabot> Remote keyless entry, remote keyless entry, remote keyless entry!
16:46:09 <xerox> Remote keyless entry.
16:46:09 <SamB> madpickle: you stole that off of everything2.com, didn't you!
16:46:12 <Pseudonym> Coffee.  BBL
16:46:15 <madpickle> i...i.. i did
16:46:21 <SamB> you are only supposed to use that for *original* quotes!
16:46:21 <xerox> He _quits_ IRC for _coffee_
16:46:23 <madpickle> young people swear!
16:46:24 <xerox> How *geek* is he?
16:46:33 <madpickle> meh
16:46:36 <madpickle> M-x brew-coffee
16:46:37 <madpickle> jeez.
16:46:43 <madpickle> don't anybody use emacs for coffee making?
16:46:56 <SamB> madpickle: emacs supports HTCPCP?
16:47:04 <SamB> or whatever the acronym is?
16:47:11 <xerox> CP?
16:47:17 <madpickle> Hyper Text Coffee Pot Control Protocol?
16:52:05 <tibbe> isn't the Writer monad supposed to accumulate stuff I give it with tell in a list?
16:52:31 <xerox> It depends on the Monoid you are using.
16:52:46 <xerox> That is the case for the list one
16:53:19 <xerox> We have that attitude of generalizing... you know.
16:54:51 <tibbe> I guess I have to learn about monoids too, I was hoping I could just do a Writer [String] a and then append stuff with tell str
16:55:07 <xerox> Nothing strange about them
16:55:37 <xerox> ?type mempty
16:55:38 <lambdabot> Not in scope: `mempty'
16:55:41 <xerox> Hmm.
16:55:46 <xerox> ?type mzero
16:55:51 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
16:55:51 <tibbe> the type checker says it expects [String] to tell not [Char]
16:55:53 <xerox> Nah.
16:56:04 <xerox> Right.
16:56:09 <xerox> ?type tell
16:56:29 <xerox> Wake up.. Neo^Wlambdabot.
16:56:40 <lambdabot> Not in scope: `tell'
16:57:08 <tibbe> ?type Control.Monad.Writer.tell
16:57:09 <lambdabot> forall (m :: * -> *) w. (Control.Monad.Writer.MonadWriter w m) => w -> m ()
16:57:19 <xerox> You see, you have to provide a value of the whole type w
16:57:26 <xerox> Where w is the type of the log.
16:57:28 <int-e> looks like you need Writer String
16:57:35 <int-e> or use tell ["message"]
16:57:41 <xerox> The latter, I believe.
16:57:49 <int-e> depends on what you want :)
16:57:51 <xerox> Or unwords . runWriter
16:57:53 <xerox> :D
16:57:55 <tibbe> so it doesn't have appending behaviour?
16:57:59 <xerox> Yes it does.
16:58:10 <int-e> yes, on the type you give the writer
16:58:18 <tibbe> it feels a bit unnatural to use it that way
16:58:24 <SamB> tibbe: a bit, yeah...
16:58:29 <int-e> [String] is a list of strings, and you can append to that
16:58:36 <xerox> > runWriter (do { tell ["hi","there"]; tell ["foo","bar"]; return () })
16:58:36 <lambdabot>  Not in scope: `tell'
16:58:47 <xerox> > runWriter (do { Control.Monad.Writer.tell ["hi","there"]; Control.Monad.Writer.tell ["foo","bar"]; return () })
16:58:48 <lambdabot>  Not in scope: `Control.Monad.Writer.tell'
16:58:54 <SamB> dons: why isn't Control.Monad.Writer in scope?
16:58:55 <xerox> Bah!
16:59:04 <tibbe> http://www.nomaware.com/monads/html/writermonad.html
16:59:04 <SamB> fixorate!
16:59:05 <lambdabot> Title: The Writer monad
16:59:05 <xerox> Why isn't dons in scope?
16:59:12 <SamB> dons is in scope
16:59:13 <tibbe> have it been changed since then?
16:59:18 <xerox> SamB: don't say that
16:59:19 <SamB> he just isn't paying attention
16:59:21 <int-e> ((),["hi","there","foo","bar"])
16:59:27 <xerox> Thanks int-e-bot.
16:59:38 <SamB> @get-dons
16:59:38 <lambdabot> Unknown command, try @list
16:59:47 <int-e> You're welcome. Do I get a snack?
16:59:55 <xerox> We are not supposed to even need such a command SamB!
17:00:01 <xerox> #botsnack
17:00:04 <SamB> @wake dons
17:00:04 <lambdabot> http://www.haskell.org/haskellwiki/dons
17:00:05 <int-e> :)
17:00:17 <xerox> #pl \f g x y z -> f (g x y z)
17:00:23 <int-e> that's your job
17:00:30 <xerox> (.) . (.) . (.)
17:00:32 <xerox> :)
17:00:48 <SamB> @type pl \f g x y z -> f (g x y z)
17:00:49 <lambdabot> parse error on input `\'
17:00:51 <int-e> . o O ( Why does point-free code contain so many dots? )
17:00:52 <SamB> @type \f g x y z -> f (g x y z)
17:00:53 <lambdabot> forall t t1 t2 t3 t4. (t -> t4) -> (t1 -> t2 -> t3 -> t) -> t1 -> t2 -> t3 -> t4
17:01:02 * xerox roars
17:01:17 <SamB> @. pl . djinn type \f g x y z -> f (g x y z)
17:01:18 <lambdabot> f = (.) . (.) . (.)
17:01:25 <xerox> Allllllright.
17:01:27 <aleko> @type 5
17:01:29 <lambdabot> forall t. (Num t) => t
17:01:33 <aleko> cool
17:02:03 <xerox> Indeed!
17:02:05 <SamB> @type (.) (.)
17:02:06 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
17:02:34 <aleko> is this a longest-type-expression contest?
17:02:46 <xerox> ?kind Control.Monad.RWST.RWST
17:02:48 <lambdabot> Couldn't find qualified module.
17:02:50 <SamB> @free f ::  (t -> t4) -> (t1 -> t2 -> t3 -> t) -> t1 -> t2 -> t3 -> t4
17:02:50 <xerox> ?kind Control.Monad.RWS.RWST
17:02:51 <lambdabot> g . q = f1 . f => f . f2 x y = f3 (h x) (k y) . p => g . f q f2 z u = f f1 f3 (h z) (k u) . p
17:02:52 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
17:02:57 <xerox> That's the longest kind I know of.
17:03:05 <aleko> @type (.) $ (.) $ (.) $ (.)
17:03:07 <lambdabot> forall a a1 a2 b c a3. (a -> a1 -> a2 -> b -> c) -> a -> a1 -> a2 -> (a3 -> b) -> a3 -> c
17:03:14 <xerox> You don't need the '$' there
17:03:25 <aleko> @type (.) (.) (.) (.)
17:03:26 <lambdabot> forall a a1 b c a2. (a -> a1 -> b -> c) -> a -> a1 -> (a2 -> b) -> a2 -> c
17:03:30 <aleko> ah
17:03:31 <SamB> heh
17:03:37 <xerox> Yuck
17:03:39 <aleko> \me is a n00b
17:03:40 <xerox> The last one changes
17:03:41 <SamB> xerox: that isn't the same type!
17:03:43 <xerox> Yes!
17:03:44 * aleko is a n00b
17:03:48 * xerox is a n00b too
17:03:56 <xerox> ?type (.) (.)
17:03:56 <SamB> haha
17:03:58 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
17:03:58 <xerox> ?type (.) $ (.)
17:04:00 <lambdabot> forall a b c a1. (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
17:04:05 <xerox> Hmm.
17:04:06 <merus> Wow.
17:04:08 <aleko> xerox knows what the heck he's doing in haskell
17:04:11 <xerox> ?type (.) $ (.) $ (.)
17:04:13 <merus> That's ... weird.
17:04:17 <lambdabot> forall a a1 b c a2. (a -> a1 -> b -> c) -> a -> a1 -> (a2 -> b) -> a2 -> c
17:04:18 <xerox> ?type (.) (.) (.)
17:04:19 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
17:04:22 <xerox> Oh I see.
17:04:32 <aleko> what's the "forall" for?
17:04:38 <int-e> ?type ap ap ap
17:04:39 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> a
17:04:39 <lambdabot>    Expected type: (t -> a -> b) -> t -> a
17:04:43 <SamB> aleko: in case it isn't at the left...
17:04:50 <xerox> aleko: (.) (.) (.) = ((.) (.)) (.); (.) $ (.) $ (.) = ((.) ((.) (.))
17:04:51 <SamB> @type runST
17:05:03 <xerox> aleko: forall is universal quantification
17:05:10 <lambdabot> Not in scope: `runST'
17:05:14 <xerox> aleko: like in math, â
17:05:24 <SamB> @type Control.Monad.ST.runST
17:05:25 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
17:05:36 <SamB> see, that one isn't at the left
17:05:38 <int-e> @type Control.Monad.Trans.lift
17:05:39 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *). (MonadTrans t, Monad m) => m a -> t m a
17:05:40 * aleko can't display whatever characters xerox typed
17:05:49 <SamB> aleko: heh
17:05:52 <xerox> Unicode unaware people...
17:05:55 <int-e> > lift lift lift
17:05:56 <lambdabot>    The function `lift' is applied to two arguments,
17:05:56 <lambdabot>   but its type `m a -...
17:06:06 <xerox> int-e got badger badger badger
17:06:18 <xerox> ?type fix fix fix
17:06:19 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
17:06:20 <lambdabot>    Expected type: (a -> a) -> a -> a
17:06:22 <xerox> Prrr.
17:06:33 <SamB> @type break break break
17:06:34 <lambdabot>   Expecting a function type, but found `Bool'
17:06:35 <lambdabot>    Expected type: (a -> Bool) -> Bool
17:06:47 <xerox> ?type (flip id) (flip id) (flip id)
17:06:49 <lambdabot> forall b c c1. ((b -> (b -> c) -> c) -> c1) -> c1
17:06:50 <int-e> Urk! Inventing strangely-kinded void TyCon: [..] (* -> *) -> * -> *
17:06:54 <xerox> callCC?
17:06:54 <int-e> I love that message.
17:07:01 <xerox> @ghc
17:07:02 <lambdabot>  Inferred type is less polymorphic than expected
17:07:12 <xerox> Never seen it before!
17:07:14 <xerox> @ghc
17:07:15 <lambdabot>  Implicit parameters escape from the monomorphic top-level binding(s)
17:07:20 <SamB> int-e: how do you get it?
17:07:33 <xerox> RWST ?
17:07:38 <SamB> does lambdabot @remember that one?
17:07:43 <xerox> I don't think so
17:07:45 <xerox> @ghc
17:07:45 <lambdabot>  No parameters for class
17:07:57 <mauke> @. djinn type (flip id) (flip id) (flip id)
17:07:59 <SamB> @remember ghc Urk! Inventing strangely-kinded void TyCon: [..] (* -> *) -> * -> *
17:08:05 <SamB> @ghc
17:08:09 <lambdabot> f a = a (\ b c -> c b)
17:08:09 <lambdabot> Done.
17:08:09 <lambdabot>  Illegal unlifted type argument
17:08:10 <xerox> It should do it
17:08:13 <xerox> Yesss!
17:08:17 <SamB> @ghc
17:08:20 <xerox> ?type ($) ($) ($)
17:08:23 <lambdabot>  Can't match unequal length lists
17:08:24 <lambdabot> forall a b. (a -> b) -> a -> b
17:08:28 <xerox> aya
17:08:33 <SamB> @pl (flip id) (flip id) (flip id)
17:08:33 <lambdabot> ($ flip id)
17:08:39 <xerox> Hey don't pl me :(
17:08:59 <xerox> ?type (>>=) (>>=) (>>=)
17:09:01 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> b
17:09:01 <lambdabot>    Expected type: ((a -> t -> b) -> t -> b) -> (t -> a) -> b1
17:09:04 <xerox> Boring.
17:09:16 <SamB> @type map map map
17:09:17 <lambdabot>   Expecting a function type, but found `[a]'
17:09:17 <lambdabot>    Expected type: [a -> b]
17:09:23 <SamB> @type fmap fmap fmap
17:09:24 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b. (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
17:09:26 <xerox> ?type id id id
17:09:28 <lambdabot> forall a. a -> a
17:09:29 <mauke> @pl thrice f = f f f
17:09:30 <lambdabot> thrice = join (join id)
17:09:36 <xerox> Yarrr
17:09:40 <xerox> Let's do a pl contest.
17:09:52 <xerox> (I just said let's do a pointless contest?)
17:09:55 <SamB> what kind of pl contest?
17:10:08 <xerox> One says an expression, people @pl-ify it without @pl.
17:10:16 <SamB> oh
17:10:19 <xerox> First working wins
17:10:35 <xerox> Works better on paper and with computer turned off but well...
17:10:53 <SamB> but how do you tell if it is correct?
17:10:59 <xerox> You try it here?
17:11:01 <jcreigh> SamB: @pl afterword?
17:11:09 <SamB> I meant, with the computer off!
17:11:16 <madpickle> i'm never turning my computer off
17:11:17 <madpickle> i might die
17:11:19 <madpickle> or something.
17:11:21 <xerox> Hm
17:11:21 <SamB> hah
17:11:24 <xerox> You compare with my answer
17:11:26 * xerox coughs
17:11:28 <jcreigh> madpickle: Good point. Why risk it? :)
17:11:30 <tibbe> how can I run a [Writer [String] a] so the result will be a single Writer [String] a?
17:11:32 <madpickle> indeed.
17:11:34 <tibbe> ?type sequence
17:11:36 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
17:11:43 <int-e> @pl ap id id (ap id id)
17:11:45 <tibbe> hmm
17:11:45 <madpickle> i'm getting new tubes installed to my internets at my new apartment
17:11:51 <madpickle> but i still gotta go a few days without internets
17:11:52 <tibbe> will sequence do?
17:12:03 <xerox> tibbe, sequence would turn that in Writer [String] [a]
17:12:10 * xerox envisions a pl-resume in the way
17:12:11 <tibbe> :)
17:12:15 <int-e> sorry lambdabot :)
17:12:34 <xerox> Sequence had a nice property.. what was it.
17:12:44 <int-e> you used to give up quicker though, bot.
17:12:49 <tibbe> ?type mapM_
17:12:53 <xerox> She's slow today :(
17:12:58 <xerox> dons must be hacking.
17:12:59 <lambdabot> ap id id (ap id id)
17:12:59 <lambdabot> optimization suspended, use @pl-resume to continue.
17:13:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
17:13:00 <int-e> and I wasn't even being nasty.
17:13:01 <SamB> @free [M a] -> M [a]
17:13:02 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:57:20-34
17:13:06 <xerox> > sequence [even,(>10)] 100
17:13:07 <SamB> @free sequence :: [M a] -> M [a]
17:13:07 <lambdabot> $map_M ($map f) . sequence = sequence . $map ($map_M f)
17:13:07 <lambdabot>  [True,True]
17:13:12 <xerox> Yarrr that was it.
17:13:14 <int-e> nothing that would explode.
17:13:16 <xerox> Isn't it cute?
17:13:37 <SamB> what?
17:13:41 <xerox> > sequence [even,(>10)] 100
17:13:42 <lambdabot>  [True,True]
17:14:06 <SamB> that fmap (map f) . sequence = sequence . map (fmap f)?
17:14:08 <int-e> > flip (map . flip id) [even, (>10)] 100
17:14:09 <lambdabot>  [True,True]
17:14:12 <xerox> > let satisfies = (all .) . sequence in satisfies [odd,(<10)] 3
17:14:13 <lambdabot>  Couldn't match `a -> Bool' against `[a1]'
17:14:17 <xerox> Arrrr.
17:14:24 <xerox> > let satisfies = (and .) . sequence in satisfies [odd,(<10)] 3
17:14:28 <xerox> I always get them wrong
17:14:29 <lambdabot>  True
17:15:12 <beelsebob> @getshapr
17:15:12 <lambdabot> shapr!!
17:15:28 <SamB> beelsebob: its kindof buggy
17:15:38 <beelsebob> SamB: what is?
17:15:46 <SamB>  @getshapr -- it only works when he is already here
17:15:52 <beelsebob> yeh, i know
17:15:58 <beelsebob> still fun to call him
17:16:09 <int-e> @quote lambdabot
17:16:09 <lambdabot>  Nobody brings small problems into a laundromat.
17:16:16 <xerox> o_0
17:16:21 <xerox> Scam?
17:16:25 <int-e> @quote lambdabot
17:16:25 <lambdabot>  lambdabot hasn't said anything memorable
17:16:30 <beelsebob> > filter isJuggler #haskell
17:16:31 <lambdabot>  Not in scope: `haskell'
17:16:37 <xerox> hahaha
17:16:48 <beelsebob> you're one, aren't you xerox?
17:16:49 <xerox> ?remember beelsebob > filter isJuggler #haskell
17:16:50 <lambdabot> Done.
17:17:01 <xerox> I am not too good, but yes, i can do up to four balls
17:17:10 <beelsebob> you a mac user too?
17:17:25 <xerox> From something like 3 months yes
17:17:33 <beelsebob> excellent
17:17:39 <beelsebob> I wrote a new shiny
17:18:01 <beelsebob> http://www.icculus.org/jugglemaster/ <-- go here, grab the svn version, and build the project in jugglemaster/src/jmcocoa
17:19:00 <xerox> Build, how?
17:20:01 <xerox> OK loaded in Xcode and compiling now
17:20:02 <beelsebob> XCode
17:20:19 <beelsebob> should build with only "that directory isn't there yet" errors
17:20:35 <xerox> It is working
17:20:39 <beelsebob> :)
17:20:41 <xerox> (No errors)
17:20:44 <xerox> (And running)
17:20:56 <beelsebob> yayness
17:20:58 <beelsebob> you like the shiny?
17:21:00 <xerox> How cool :)
17:21:03 <beelsebob> couple of things won't work yet
17:21:08 <xerox> Mill Mess is nice
17:21:12 <beelsebob> like colouring the balls
17:21:23 <xerox> Centre is more like I can do it
17:21:33 <beelsebob> or choosing a pattern from a list
17:21:41 <beelsebob> any ideas for it much appreciated
17:21:56 <beelsebob> I will probably do export to movie, and add music and stuffs
17:22:02 <xerox> Write it in Haskell?
17:22:08 <beelsebob> hehe
17:22:09 <beelsebob> I would
17:22:12 <beelsebob> but HOC sucks
17:22:13 <xerox> How does it draw?
17:22:16 <xerox> Does it? Sigh.
17:22:19 <beelsebob> it hasn't been updated in *ages*
17:22:28 <xerox> Pang contacted me for SoC, he had lked a project to do a Cocoa monad.
17:22:32 <beelsebob> like, since 10.3 first came out
17:22:40 <beelsebob> SoC?
17:22:41 <xerox> Sorry I can't type.
17:22:44 <xerox> Summer of Code
17:22:54 <beelsebob> ah yeh
17:22:59 <beelsebob> that would be a shiny idea
17:23:04 <xerox> Yes but it is over now
17:23:09 <beelsebob> indeed
17:23:19 <xerox> Maybe next year, but I'd rather try to get people involved even without grants
17:23:37 <beelsebob> makes sense
17:23:39 <xerox> Mills mess looks crazy with 6 balls
17:23:43 <beelsebob> hehe, yes
17:23:46 <beelsebob> do mills with 9
17:23:51 <xerox> Is Centre possible with an even number of balls?
17:23:56 <beelsebob> not sure
17:24:00 <xerox> Infinite!
17:24:06 <beelsebob> infinite?
17:24:15 <beelsebob> oh... mills with 9
17:24:26 <xerox> It shapes an â
17:24:33 <beelsebob> or... if you want something shiny do [123456789abcdefghijklmnopqrstuvwxyz]
17:24:43 <xerox> In the number?
17:24:44 <beelsebob> [] makes it multiplex all the throws
17:24:47 <beelsebob> yep
17:24:48 <xerox> Hmm.
17:25:00 <xerox> [1] is silly
17:25:06 <beelsebob> haha
17:25:09 <xerox> Look is here! No it's over there!
17:25:21 <beelsebob> (,) makes it do the left one in the left hand, and the right one in the right hand
17:25:52 <beelsebob> you tried [123456789abcdefghijklmnopqrstuvwxyz]?
17:25:57 * tibbe wonders why GetOpt won't play nice with him
17:26:00 <beelsebob> the 640 ball pattern!
17:26:14 <xerox> A fountain!!
17:26:36 <xerox> What do you use to draw it?
17:26:37 <beelsebob> hehe
17:26:39 <beelsebob> cocoa
17:26:52 <xerox> Oh.
17:26:54 <beelsebob> which in turn uses Quartz
17:27:06 <xerox> I see.
17:27:18 <xerox> I want to be able to Haskell for that job.....
17:27:19 <beelsebob> NSBezierPath for the most part
17:27:41 <xerox> Does Xcode make universal binaries?
17:27:50 <beelsebob> that project is set up to make one, yes
17:28:36 <xerox> An example of (,) ?
17:28:43 <beelsebob> (k,k)
17:28:49 <xerox> Doesn't work
17:28:53 <beelsebob> no?
17:29:03 <xerox> Stays (!)
17:29:04 <beelsebob> works here
17:29:19 <beelsebob> I get synchronous lots of balls
17:29:31 <beelsebob> (4,4) gives you synchronous 4s
17:29:40 <xerox> I was trying too small numbers
17:29:47 <xerox> It should be able to do 3
17:29:50 <xerox> And 2 too
17:30:32 <beelsebob> it can do 2
17:30:37 <beelsebob> just a 2 is a ball held in a hand
17:30:42 <xerox> hehe
17:30:49 <beelsebob> and it can't do odd numbers for that because they would colide
17:30:53 <xerox> No single up and down?
17:31:20 <beelsebob> that's a 4
17:31:30 <beelsebob> oh, I see what you mean
17:31:38 <beelsebob> no, there's no such throw
17:31:42 <beelsebob> there's no point in throwing it
17:31:46 <beelsebob> try ([44x],[44x])
17:32:06 <xerox> Cool.
17:32:08 <xerox> x has special meaning?
17:32:23 <beelsebob> if it falls in certian places
17:32:26 <beelsebob> it means cross this throw
17:32:51 <xerox> [44x] is like a humming bird juggling
17:32:51 <beelsebob> so it does a height 4 throw crossed to the other hand
17:32:56 <beelsebob> yep
17:33:24 <xerox> ([22x],[44x]) seems decentered hehe
17:34:20 <syntaxfree> You know you're beginning to lose it when you try to use map and zipWith on a ftp prompt.
17:34:24 <xerox> ([242x],[242x])
17:34:26 <xerox> This is fun!
17:34:31 <beelsebob> hehe
17:35:39 <xerox> It just holds the 2?
17:35:57 <xerox> No way to make him throw a single and take it with the same hand?
17:36:07 <beelsebob> nope
17:36:15 <beelsebob> no reason to thow it
17:36:18 <beelsebob> throw*
17:36:26 <xerox> Train :P
17:36:40 <syntaxfree> what's wrong with this definition?
17:36:43 <syntaxfree> replicateWith l f = l : map f (replicateWith l f) : []
17:37:01 <xerox> : [] ?
17:37:06 <xerox> ?type (:)
17:37:07 <lambdabot> forall a. a -> [a] -> [a]
17:37:25 <syntaxfree> replicateWith l f = l ++ map f (replicateWith l f)  doesn't work either.
17:37:34 <xerox> What type do you want?
17:37:44 <syntaxfree> replicateWith :: [a]->(a->a)->[a]
17:37:46 <beelsebob> >let replicateWith l f = l : map f (replicateWith l f) in replicateWith 1 (+1)
17:37:56 <Pseudonym> ?free replicateWith :: [a]->(a->a)->[a]
17:37:57 <lambdabot> f . g = h . f => $map f (replicateWith x g) = replicateWith ($map f x) h
17:37:57 <beelsebob> lambdabot blow up
17:38:22 <int-e> beelsebob: your lambdabot-fu failed.
17:38:25 <xerox> ?type let replicateWith = (. replicate) . map in replicateWith
17:38:26 <lambdabot>   Couldn't match `[a]' against `a1 -> [a1]'
17:38:26 <lambdabot>    Expected type: (a -> b) -> (a1 -> [a1]) -> c
17:38:36 <beelsebob> > let replicateWith l f = l : map f (replicateWith l f) in replicateWith 1 (+1)
17:38:37 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:38:39 <beelsebob> :)
17:38:41 <beelsebob> worketh
17:38:51 <xerox> > iterate (+1) 1
17:38:52 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:38:53 <syntaxfree> yes, but I want l to be a list.
17:39:00 <beelsebob> it is a list
17:39:05 <syntaxfree> I want the infinite list [1,2,3, 2, 3, 4, 4, 5, 6]
17:39:06 <beelsebob> it's an infinite list
17:39:12 <Pseudonym> :t scanl
17:39:14 <int-e> so is iterate
17:39:16 <syntaxfree> no, no. I want the first argument to be a list.
17:39:19 <Pseudonym> @type scanl
17:39:20 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
17:39:26 <Pseudonym> Is that what you want?
17:39:28 <xerox> syntaxfree: if it is infinite you never reach your map
17:39:37 <xerox> It'll be at (!! Omega)
17:39:40 <Pseudonym> scanl (+) 1 [0..]
17:39:43 <syntaxfree> replicateWith [1,2,3] (+1) ==> [1,2,3, 2, 3,4, 3, 4,5, 4,5,6...
17:39:46 <Pseudonym> > scanl (+) 1 [0..]
17:39:47 <lambdabot>  [1,1,2,4,7,11,16,22,29,37,46,56,67,79,92,106,121,137,154,172,191,211,232,254...
17:39:54 <beelsebob> oh, I see
17:39:56 <int-e> @pl f g x = x:map g (f g x)
17:39:56 <lambdabot> f = fix ((ap (:) .) . liftM2 (.) map)
17:40:01 <Pseudonym> > scanl (+) 0 [1..]
17:40:02 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
17:40:21 <Pseudonym> > scanl (+) 1 (iterate 0)
17:40:22 <lambdabot>    Expecting a function type, but found `[b]'
17:40:22 <lambdabot>    Expected type: [b]
17:40:22 <lambdabot>   ...
17:40:32 <Pseudonym> > scanl (+) 1 (replicate 0)
17:40:33 <lambdabot>    Expecting a function type, but found `[b]'
17:40:33 <lambdabot>    Expected type: [b]
17:40:33 <lambdabot>   ...
17:40:37 <Pseudonym> Errr...
17:40:56 <int-e> > fix (scanl (+) 1 . (0:))
17:40:57 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
17:40:58 <xerox> > let f l g = l ++ f (map g l) g in f [1,2,3] (+1)
17:41:00 <lambdabot>  [1,2,3,2,3,4,3,4,5,4,5,6,5,6,7,6,7,8,7,8,9,8,9,10,9,10,11,10,11,12,11,12,13,...
17:41:00 <Pseudonym> That's it.
17:41:04 <xerox> That's it.
17:41:06 <syntaxfree> replicateWith ["abc", "def"] (++"z") ===> ["abc", "def", "abcz", "defz", "abczz", "defzz" ...
17:41:07 <syntaxfree> that's it.
17:41:10 <Pseudonym> > scanl (+) 1 (repeat 0)
17:41:11 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:41:11 <xerox> haha
17:41:13 <syntaxfree> That should be in the prelude.
17:41:15 <Pseudonym> > scanl (+) 1 (repeat 1)
17:41:16 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:41:18 <beelsebob> > let replicateWith l f = foldr (++) (l : map f (replicateWith l f)) in replicateWith [1,2,3] (+1)
17:41:19 <lambdabot>  Couldn't match `[a]' against `[[a1]] -> [a1]'
17:41:21 <beelsebob> bah
17:41:56 <syntaxfree> xerox: can I post that in @wiki Licensed Prelude Exts?
17:42:04 <xerox> > let f l g = l ++ f (map g l) g in f ["abc","def"] (++"z")
17:42:05 <lambdabot>  ["abc","def","abcz","defz","abczz","defzz","abczzz","defzzz","abczzzz","defz...
17:42:06 <int-e> > concat $ iterate (map (+1)) [1,2,3]
17:42:07 <lambdabot>  [1,2,3,2,3,4,3,4,5,4,5,6,5,6,7,6,7,8,7,8,9,8,9,10,9,10,11,10,11,12,11,12,13,...
17:42:15 <xerox> syntaxfree: I don't know the rules, but do as you please.
17:42:17 <beelsebob> yep
17:42:30 <xerox> Let's see how to points-free it now...
17:42:31 <syntaxfree> xerox: basically, you're licensing that line of code as BSDish.
17:42:37 <xerox> syntaxfree: I like that license
17:43:09 <syntaxfree> > concat $ iterate (map (++"z") ["abc", "def"]
17:43:09 <lambdabot>  Parse error
17:43:28 <syntaxfree> > concat $ iterate (map (++"z")) ["abc", "def"]
17:43:30 <lambdabot>  ["abc","def","abcz","defz","abczz","defzz","abczzz","defzzz","abczzzz","defz...
17:43:34 <Pseudonym> Does anyone here know anything about Freyd categories?
17:43:54 <int-e> > ((concat .) . iterate . map) (+1) [1,2]
17:43:55 <lambdabot>  [1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16...
17:43:58 <Pseudonym> Like, what their technical definition is, maybe some simple properties?
17:44:15 <Pseudonym> @type ((concat .) . iterate . map)
17:44:16 <lambdabot> forall b. (b -> b) -> [b] -> [b]
17:44:21 <int-e> add a flip if you must :)
17:44:38 <int-e> @type flip ((concat .) . iterate . map)
17:44:39 <lambdabot> forall b. [b] -> (b -> b) -> [b]
17:44:50 <Pseudonym> ?free something :: forall b. [b] -> (b -> b) -> [b]
17:44:50 <lambdabot> f . g = h . f => $map f (something x g) = something ($map f x) h
17:45:32 <twobitsprite> does anyone else which ghci had tab-completion?
17:45:35 <Pseudonym> Actually, it might be good if things of list type got renamed to xs rather than x.
17:45:38 <twobitsprite> wish*
17:45:54 <Pseudonym> twobitsprite: Patches welcome.
17:45:56 <int-e> ghci 6.5 has
17:46:08 <Pseudonym> OK, patches unnecessary.
17:46:14 <xerox> ?type let f = ap ((.) . flip (++)) (flip ap id . (f .) . flip map) in f
17:46:15 <lambdabot> forall b. [b] -> (b -> b) -> [b]
17:46:18 <xerox> That's it.
17:46:22 <xerox> Hand-points-freed.
17:46:27 <twobitsprite> int-e: ahh... thanks :)
17:46:47 <int-e> xerox: and it does something else than  flip ((concat .) . iterate . map) ?
17:46:57 <lispy> xerox: i'm glad that haskell is so easy to read! ;)
17:46:59 <xerox> I have also learnt a new technique during that reduction. So I am very happy.
17:47:25 <int-e> @pl ap ((.) . flip (++)) (flip ap id . (f .) . flip map)
17:47:26 <lambdabot> ap ((.) . flip (++)) (join . (f .) . flip map)
17:47:34 <xerox> AH- to you lambdabot!
17:47:45 <int-e> @type (flip ap id, join)
17:47:46 <lambdabot> forall b a (m :: * -> *) a1. (Monad m) => ((a -> a -> b) -> a -> b, m (m a1) -> m a1)
17:47:49 <xerox> But let's see what she thinks about the first one
17:47:53 <syntaxfree> ghci balks at replicateWith l g =  concat (iterate (map g) l)
17:48:03 <xerox> @pl f l g = l ++ f (map g l) g
17:48:04 <lambdabot> f = fix (liftM2 (.) (++) . flip flip id . (ap .) . (. flip map) . (.))
17:48:17 <xerox> > length "fix (liftM2 (.) (++) . flip flip id . (ap .) . (. flip map) . (.))"
17:48:18 <lambdabot>  66
17:48:24 <xerox> > length "ap ((.) . flip (++)) (flip ap id . (f .) . flip map)"
17:48:25 <lambdabot>  52
17:48:27 <syntaxfree> ghci also balks at f l g = l ++ f (map g l) g
17:48:27 <syntaxfree> f l g = l ++ f (map g l) g
17:48:29 <xerox> Die.
17:48:31 <int-e> syntaxfree: you're missing the let?
17:48:39 <syntaxfree> I mean, it's in a file already.
17:48:43 <xerox> syntaxfree: call 'f' something else
17:48:46 <syntaxfree> It balks at compiling the file, at that precise line.
17:48:51 <syntaxfree> I call it replicateWith.
17:48:58 <xerox> > 66/100*52
17:49:00 <lambdabot>  34.32
17:49:22 <xerox> 34.32% more efficient, I was! (right?)
17:49:49 <xerox> (In space, she's Omega% more efficient in time, usually)
17:49:51 <int-e> flip ap id == join is interesting though
17:50:04 <xerox> Oh I see
17:50:05 <twobitsprite> > 27 + 15
17:50:06 <lambdabot>  42
17:50:22 <xerox> You do \x -> (id x) + x
17:50:37 <xerox> ap f g x = g x `f` x
17:50:37 <int-e> @pl did come up with that :)
17:50:37 <lambdabot> (line 1, column 24):
17:50:37 <lambdabot> unexpected ")"
17:50:37 <lambdabot> expecting white space or simple term
17:50:39 <syntaxfree> >replicate [1,2,3]
17:50:43 <int-e> @botsnack
17:50:44 <lambdabot> :)
17:50:57 <int-e> >[space]
17:51:04 <xerox> >[
17:51:12 <twobitsprite> > )
17:51:13 <lambdabot>  Parse error
17:51:22 <xerox> This is not perl
17:51:50 <int-e> xerox: @pl is amazingly stupid in some cases.
17:52:02 <xerox> int-e: so does she reduce flip ap id to join ?
17:52:10 <int-e> @pl flip ap id
17:52:10 <lambdabot> join
17:52:10 <twobitsprite> xerox: shit! I've been in the wrong channel the whole time!
17:52:12 <xerox> Ok.
17:52:13 <int-e> yes.
17:52:24 * xerox feels twobitsprite 
17:52:36 * twobitsprite feels back
17:52:56 <xerox> int-e: yes I bet it is
17:53:09 <syntaxfree> @wiki LicensedPreludeExts
17:53:09 <lambdabot> http://www.haskell.org/haskellwiki/LicensedPreludeExts
17:53:16 <xerox> int-e: but it's what TheHunter left us before leaving, so we love it as it is! :D
17:53:21 <int-e> syntaxfree: ghci may bulk at that line but your mistake is elsewhere.
17:53:40 <syntaxfree> yes, I was loading the wrong file. That was my mistake.
17:54:00 <int-e> *balk
17:54:04 <xerox> If the FS was statically typed and linearly typed ghci could have checked that... :P
17:54:04 <SamB> syntaxfree: haha
17:54:06 <xerox> I suppose.
17:54:25 <SamB> xerox: no
17:54:31 <xerox> Dang!
17:54:34 <syntaxfree> ah, jesus, I have to sign up for the new wiki.
17:54:41 * int-e throws an unsafeCoerce# at xerox 
17:54:42 <SamB> because he wouldn't have told it what type the file was supposed to have
17:54:49 * xerox transforms in a Frog
17:54:55 <SamB> plus, that would only work for files that parsed...
17:54:57 <int-e> cool. Do you talk?
17:55:03 <SamB> of course, all the files would parse...
17:55:10 * xerox *croak* coerce me *croak* back *croak
17:55:20 <SamB> or to be more specific, they'd already have *been* parsed...
17:55:31 * int-e stuffs xerox into a polymorphic IORef using unsafePerformIO
17:55:43 * xerox throws nontermination onto int-e
17:55:45 <Pseudonym> > unsafeCoerce# xerox :: Human
17:55:46 <lambdabot>  Not in scope: type constructor or class `Human'
17:55:53 * int-e fails to go to sleep.
17:56:02 * xerox doesn't know where he is or should be now
17:56:10 <int-e> just read that IORef :)
17:56:11 <syntaxfree> when displaying text files, Safari doesn't respect tabs.
17:56:25 * xerox `readIORef`)
17:56:28 <Pseudonym> Oh, I forgot to import Science.Mad
17:56:35 <SamB> syntaxfree: what do you expect from a webbrowser
17:56:39 * xerox poofs back in the channel
17:56:55 <xerox> Reminds me of Hofstadter (of whatever is written)
17:57:01 <int-e> xerox: are you correctly typed again?
17:57:02 <syntaxfree> it uglifies my code, boo hoo boo hoo.
17:57:13 <Pseudonym> xerox: If Hofstadter had said that, it would have been much funnier.
17:57:16 <xerox> int-e: I think I've gained some polymorphism in the process, but don't tell anyone
17:57:25 <syntaxfree> http://www.navarro.mus.br/diego/akopian.hs
17:57:42 * int-e ducks under some functional dependencies.
17:57:43 <xerox> Pseudonym: it is funny the way it is too!
17:57:59 <Pseudonym> Actually, an even better gag is:
17:58:02 <xerox> I see you under those Arrows int-e! *throws a -<*
17:58:13 <Pseudonym> If Hofstadter had said this, it would have been much funnier.
17:58:26 <xerox> hahahaha
17:58:35 * int-e adds xerox' = xerox as a toplevel declaration, then exports it and imports it from another module.
17:58:35 <xerox> ?remember Pseudonym If Hofstadter had said this, it would have been much funnier.
17:58:36 <lambdabot> Done.
17:58:54 <int-e> this should get rid of all polymorphism.
17:58:59 <xerox> Pseudonym: I think this is at least the second time you do this kind of jokes.
17:59:05 * xerox feels monomorphic
17:59:08 <xerox> How unpleasant.
17:59:28 <Pseudonym> Of course.  I only do one joke, up to canonical isomorphism.
17:59:33 * xerox breaks a runST on the nearby wall and runs away with the scoped forall
17:59:36 <int-e> if it's of any relief for you I've also hidden the Frog module :)
17:59:55 <int-e> oh no
17:59:59 <xerox> @arrr
18:00:00 <lambdabot> Ahoy mateys
18:00:06 * int-e gives up and puts the code into IO instead.
18:00:17 <xerox> That's the wrong one lambdabot, be a better parrate
18:00:25 <Pseudonym> Actually, there's probably a monomorphism that reduces that joke to the previous joke.
18:00:27 <int-e> @yarr
18:00:27 <lambdabot> Keelhaul the swabs!
18:00:43 <int-e> I think we had IO before. Sorry.
18:00:55 <xerox> Let's try to understand the situation better
18:00:58 <xerox> @localtime xerox
18:01:00 <lambdabot> Local time for xerox is 2006-08-24 02:58:37 +0200
18:01:01 <xerox> @localtime int-e
18:01:03 <lambdabot> Local time for int-e is two days after the day before yesterday
18:01:05 <xerox> @localtime Pseudonym
18:01:06 * int-e looks for a continuation to call and get back.
18:01:18 <xerox> You spoil all the fun
18:01:18 <lambdabot> Local time for Pseudonym is Thu Aug  24 10:58:45 2006
18:01:42 <int-e> me? spoil the fun?
18:02:01 <int-e> Ok, the time could be funnier. I'll admit that.
18:02:06 <xerox> Right.
18:02:23 <lambdabot> Local time for Pseudonym's jokes is some time in the early 1980s.
18:02:32 <xerox> haha
18:02:43 <SamB> hah
18:02:52 <xerox> Bugger
18:03:35 * xerox plays for the nth time he album Jefferson Airplane - Surrealistic Pillow
18:03:40 <SamB> two days after the day before yesterday...
18:03:46 <xerox> It'll be a long night.
18:03:53 <SamB> naesten@hydrogen:~/hacking/haskell% date -d 'two days after the day before yesterday'
18:03:53 <SamB> date: invalid date `two days after the day before yesterday'
18:04:08 * beelsebob farts
18:04:13 <syntaxfree> IO stuff isn't lazy.
18:04:22 <Pseudonym> xerox: How long can you listen to Jefferson Airplane before they collapse into Starship?
18:04:25 <syntaxfree> I can't have an infinite IO [String] and then fmap head it.
18:04:30 <xerox> syntaxfree: unsafeInterleaveIO is what you need
18:04:46 <beelsebob> yay for Quantas banning dell laptops on planes!
18:04:51 <syntaxfree> oh jesus what an ugly name. Why not called it incrediblePinkDots?
18:04:57 <xerox> Pseudonym: I must admit I filter out Starships from my [JeffersonAirplane].
18:04:59 <syntaxfree> anyway, how do I use that?
18:05:05 <xerox> Look here
18:05:09 <xerox> ?fptools System.IO
18:05:10 <lambdabot> http://darcs.haskell.org/packages/base/System/IO.hs
18:05:12 <xerox> Lookup fixIO
18:05:17 <Pseudonym> xerox: Don't you want somebody to love you?
18:05:54 <xerox> Pseudonym: Won't you love somebody to love?
18:05:56 <syntaxfree> umm.
18:06:02 <xerox> G'day monochrom.
18:06:10 <syntaxfree> fixIO will basically, uh, fix my IO?
18:06:21 <xerox> It's what mdo desugars to for the IO monad.
18:06:28 <monochrom> Hello xerox
18:06:29 <syntaxfree> mdo?
18:06:40 <Pseudonym> @vera mdo
18:06:41 <lambdabot> No match for "mdo".
18:06:43 <int-e> @localtime int-e
18:06:44 <monochrom> haha fixIO will fix your IO :)
18:06:44 <xerox> ...or the code mfix (or was it fixM?) get dispached to.
18:06:44 <lambdabot> Local time for int-e is currently broken. We apologize for the inconvenience. In the meantime, please enjoy this message.
18:06:57 <syntaxfree> I'm lost.
18:06:58 <monochrom> fix will fix everything :)
18:07:00 <syntaxfree> http://www.navarro.mus.br/diego/akopian.hs
18:07:05 <xerox> > fix fix
18:07:05 <int-e> @type fix mfix
18:07:06 <lambdabot>    Occurs check: cannot construct the infinite type: a = a -> a
18:07:06 <lambdabot>    Expec...
18:07:06 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
18:07:07 <lambdabot>    Expected type: (a -> a -> a) -> a -> a -> a
18:07:10 <xerox> It will not!
18:07:11 <xerox> haha
18:07:14 * xerox high-fives int-e 
18:07:22 <Pseudonym> Hmmm.
18:07:23 <syntaxfree> nonexisting is an infinite IO [String]
18:07:24 <Pseudonym> I wonder...
18:07:37 <syntaxfree> then nextver = fmap head nonexisting
18:07:49 <syntaxfree> how do I get that fixed?
18:08:04 <xerox> syntaxfree: just stick a `unsafeInterleaveIO' in the front of the IO action you want to make lazy.
18:08:13 <syntaxfree> in the type?
18:08:17 <xerox> hahaha
18:08:26 <int-e> > lift mfix 0
18:08:26 <lambdabot>    The function `lift' is applied to two arguments,
18:08:27 <lambdabot>   but its type `m a -...
18:08:27 <xerox> Sorry I laughed out loud.
18:08:32 <xerox> It's the mood of this evening.
18:08:33 <syntaxfree> @type unsafeInterleaveIO
18:08:35 <lambdabot> Not in scope: `unsafeInterleaveIO'
18:09:07 <syntaxfree> oh. it's a function.
18:09:09 <xerox> ?type fix . unsafeInterleaveIO
18:09:10 <lambdabot> Not in scope: `unsafeInterleaveIO'
18:09:16 <xerox> ?type fix . System.IO.Unsafe.unsafeInterleaveIO
18:09:17 <lambdabot>   Couldn't match `a -> a' against `IO a1'
18:09:18 <lambdabot>    Expected type: IO a1 -> a -> a
18:09:21 <xerox> Arrr.
18:09:29 <xerox> ?type System.IO.Unsafe.unsafeInterleaveIO
18:09:31 <lambdabot> forall a. IO a -> IO a
18:09:36 <int-e> ?version
18:09:36 <lambdabot> lambdabot 4p79, GHC 6.5 (OpenBSD i386 )
18:09:36 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
18:09:45 <Pseudonym> ?free unsafeIOnterleaveIO :: IO a -> IO a
18:09:45 <lambdabot> $map_IO f . unsafeIOnterleaveIO = unsafeIOnterleaveIO . $map_IO f
18:09:57 <syntaxfree> why is lazy IO "unsafe"?
18:10:16 <xerox> Look
18:10:17 <xerox> ?type fix . ((>>) . System.IO.Unsafe.unsafeInterleaveIO)
18:10:18 <lambdabot> forall b a. IO a -> IO b
18:10:22 <xerox> Yarrrrrr.
18:10:57 <Pseudonym> ?type fix . ((>>) . (id :: IO a -> IO a))
18:10:59 <lambdabot> forall b a. IO a -> IO b
18:11:16 <Pseudonym> But I guess that's the same as:
18:11:21 <Pseudonym> ?type fix . ((.) . id)
18:11:22 <lambdabot> forall c a. (c -> c) -> a -> c
18:11:29 <Pseudonym> Errr...
18:11:30 <xerox> ?type \amb -> fix (\x -> (System.IO.Unsafe.unsafeInterleaveIO amb >>=))
18:11:32 <lambdabot> forall a b. IO a -> (a -> IO b) -> IO b
18:11:56 <Pseudonym> ?type fix (id :: (a -> b) -> (a -> b))
18:11:58 <lambdabot> forall a b. a -> b
18:11:58 <int-e> Is lambdabot using ghc 6.4.2 for @run ?
18:12:00 <Pseudonym> Yeah, that.
18:12:09 <xerox> It's crazy because, because of fix's type, it doesn't need a first 'a'.
18:12:35 <xerox> Oh I am not using the x.
18:13:32 <monochrom> mdo { xs <- return (1:xs); return xs }  this is valid code for most monads, and it translates roughly to: mfix (\xs -> return (1:xs)).
18:13:46 <monochrom> See also the GHC doc on "recursive do"
18:14:31 <monochrom> fixIO is mfix for IO.  fix is mfix for (->)
18:14:41 <xerox> ?type mfix
18:14:43 <lambdabot> forall (m :: * -> *) a. (MonadFix m) => (a -> m a) -> m a
18:15:01 <xerox> Mumble.
18:15:20 <int-e> > mfix (\xs -> return (1:xs)) :: [[Int]]
18:15:28 <xerox> Monad ((->) a) => (a -> a -> a) -> a -> a ?
18:15:36 <lambdabot>  [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:15:46 <int-e> boooring :)
18:16:08 <Pseudonym> ?free mfix :: (a -> M a) -> M a
18:16:54 <xerox> zZzZ
18:16:55 <lambdabot> $map_M f . g = h . f => $map_M f (mfix g) = mfix h
18:17:22 <dons> network a bit slow today?
18:17:22 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
18:17:37 <monochrom> Wow, that's a non-trival fixed point theorem
18:18:20 <xerox> We have even someone who make sense of those theorems.
18:18:30 <Pseudonym> Who?
18:18:41 <xerox> Ok, I count two now.
18:20:32 <dons> ?users
18:20:34 <lambdabot> Maximum users seen in #haskell: 235, currently: 193 (82.1%)
18:23:50 <lisppaste2> syntaxfree pasted "lazy this is not" at http://paste.lisp.org/display/24659
18:25:24 <syntaxfree> I still don't understand unsafeInterleaveIO either.
18:25:25 <int-e> why don't you unsafeInterleave the nextver?
18:25:57 <xerox> ?index mfix
18:26:12 <xerox> Answer me!
18:26:49 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
18:26:50 <dons> ?bot
18:26:55 <lambdabot> :)
18:28:30 <xerox> ?fptools Control.Monad.Fix
18:28:31 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad/Fix.hs
18:28:33 <syntaxfree> int-e: still not working.
18:29:40 <lisppaste2> sjanssen annotated #24659 with "this is lazy" at http://paste.lisp.org/display/24659#1
18:30:15 <int-e> @type foldr (\x y -> liftM2 (:) x (unsafeInterleaveIO y)) (return [])
18:30:16 <lambdabot> Not in scope: `unsafeInterleaveIO'
18:30:39 <dons> hehe
18:30:46 <Pseudonym> dons: I think @. might need a slight overhaul.
18:30:50 <int-e> @type foldr (\x y -> liftM2 (:) x (System.IO.Unsafe.unsafeInterleaveIO y)) (return [])
18:30:51 <syntaxfree> lazyFilterIO should exist in some library
18:30:52 <lambdabot> forall a. [IO a] -> IO [a]
18:30:54 <Pseudonym> It'd be nice to be able to compose @type with @free.
18:31:00 <dons> ah
18:31:08 <Pseudonym> @type sequence_
18:31:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
18:31:17 <Pseudonym> @free sequence: :: [M a] -> M ()
18:31:17 <lambdabot> Expected OpColonColon
18:31:21 <Pseudonym> @free sequence_ :: [M a] -> M ()
18:31:21 <lambdabot> g y = y => $map_M g (sequence_ x) = sequence_ ($map ($map_M f) x)
18:31:24 <int-e> but sequence isn't lazy :)
18:31:39 <sjanssen> syntaxfree: it'd need to be called unsafeLazyFilterIO or some such.  unsafeInterleaveIO can be dangerous
18:31:48 <Pseudonym> I need to fix the currying step.
18:31:54 <Pseudonym> g y = y => g = id
18:32:05 <syntaxfree> sjanssen: why?
18:32:08 <dons> ?state (\x -> dropWhile (/= '>'))
18:32:14 <dons> ?type sequence_
18:32:14 <lambdabot> (\x -> dropWhile (/= '>'))
18:32:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
18:32:29 <dons> ?. ++ type sequence_
18:32:30 <lambdabot> (\x -> dropWhile (/= '>'))forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
18:32:34 <sjanssen> syntaxfree: there's no way to know when (or if) the code is executed
18:32:42 <dons> ?. ++ . show type sequence_
18:32:44 <lambdabot> (\x -> dropWhile (/= '>'))"forall (m :: * -> *) a. (Monad m) => [m a] -> m ()\n"
18:32:50 <sjanssen> syntaxfree: also, what if the IO raises an exception?
18:32:52 <dons> ?. run . ++ . show type sequence_
18:32:54 <lambdabot>  <[Char] -> [Char]>
18:33:10 <dons> ?state (\x -> dropWhile (/= '>')  x)
18:33:10 <lambdabot> (\x -> dropWhile (/= '>')  x)
18:33:13 <dons> ?. run . ++ . show type sequence_
18:33:15 <lambdabot>  "> *) a. (Monad m) => [m a] -> m ()\n"
18:33:16 <syntaxfree> sjanssen: well, your solution works. Now I have to understand it!
18:33:30 <int-e> syntaxfree: anyway, the idea is to use unsafeInterleaveIO in a fold-ish fashion. Create an IO action that unsafeInterleaveIO-s the tail of a list, evaluates the head, then conses the two.
18:33:31 <dons> ?state (\x -> dropWhile (/= '[')  x)
18:33:32 <lambdabot> (\x -> dropWhile (/= '[')  x)
18:33:36 <dons> ?. run . ++ . show type sequence_
18:33:39 <lambdabot>  "[m a] -> m ()\n"
18:33:44 <dons> ?. free . run . ++ . show type sequence_
18:34:24 <xerox> mfix is making my head spin
18:34:30 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:57:20-34
18:34:36 <dons> ?. free . read . run . ++ . show type sequence_
18:34:38 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:57:20-34
18:34:47 <int-e> xerox: look at the implementation of mfix for [], and tell me what that does, please.
18:35:03 <dons> ?state (\x -> init . dropWhile (/= '[')  x)
18:35:04 <lambdabot> (\x -> init . dropWhile (/= '[')  x)
18:35:04 <xerox> int-e: do .. you .. know .. what .. I .. am .. doing
18:35:11 <int-e> xerox: no :)
18:35:11 <dons> ?state (\x -> init $ dropWhile (/= '[')  x)
18:35:12 <lambdabot> (\x -> init $ dropWhile (/= '[')  x)
18:35:17 <xerox> int-e: how .. :)
18:35:21 <dons> ?. read . run . ++ . show type sequence_
18:35:23 <lambdabot>  [m a] -> m ()
18:35:43 <syntaxfree> int-e and sjanssen: oh! thanks!
18:35:44 <int-e> xerox: but I decided that today is not the day to understand that definition
18:35:45 <dons> ?state (\x -> "sequence_ " ++ init $ dropWhile (/= '[')  x)
18:35:46 <lambdabot> (\x -> "sequence_ " ++ init $ dropWhile (/= '[')  x)
18:35:49 <dons> ?. read . run . ++ . show type sequence_
18:35:51 <lambdabot> compose module failed: IRCRaised Prelude.read: no parse
18:35:52 <xerox> Somebody should see us all from outside and call the police
18:35:56 <xerox> Or something
18:36:15 <xerox> int-e: I have this compulsive obsessity thing....
18:36:18 <dons> ?state (\x -> "sequence_ " ++ (init $ dropWhile (/= '[')  x))
18:36:18 <lambdabot> (\x -> "sequence_ " ++ (init $ dropWhile (/= '[')  x))
18:36:21 <dons> ?. read . run . ++ . show type sequence_
18:36:23 <lambdabot>  sequence_ [m a] -> m ()
18:36:31 <dons> ?state (\x -> "sequence_ :: " ++ (init $ dropWhile (/= '[')  x))
18:36:31 <lambdabot> (\x -> "sequence_ :: " ++ (init $ dropWhile (/= '[')  x))
18:36:32 <dons> ?. read . run . ++ . show type sequence_
18:36:44 <lambdabot>  sequence_ :: [m a] -> m ()
18:36:49 <dons> ?. free . read . run . ++ . show type sequence_
18:36:51 <lambdabot> Expected CloseBracket
18:36:57 <xerox> O_o
18:37:06 <dons> ?free sequence_ :: [m a] -> m ()
18:37:06 <lambdabot> Expected CloseBracket
18:37:16 <Pseudonym> Errr...
18:37:18 <Pseudonym> Oh.
18:37:21 <Pseudonym> Duh.
18:37:28 <xerox> int-e: I only find loops.
18:37:28 <Pseudonym> It can't handle m a as a type.
18:37:40 <dons> ah
18:37:46 <dons> ?type map
18:37:47 <Pseudonym> ?free sequence_ :: [M a] -> M ()
18:37:48 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
18:37:48 <lambdabot> g y = y => $map_M g (sequence_ x) = sequence_ ($map ($map_M f) x)
18:37:52 <syntaxfree> @pl zero1 f = if f then "a" else "b"
18:37:53 <lambdabot> zero1 = flip (flip if' "a") "b"
18:38:01 <syntaxfree> @type if'
18:38:02 <lambdabot> Not in scope: `if''
18:38:08 <syntaxfree> what is if'?
18:38:18 <xerox> if' c a b = if c then a else b
18:38:25 <dons> ?state (\x -> "map :: " ++ (map (\x -> if x == 'm' then 'M' else x) . init $ dropWhile (/= '[')  x))
18:38:26 <lambdabot> (\x -> "map :: " ++ (map (\x -> if x == 'm' then 'M' else x) . init $ dropWhile (/= '[')  x))
18:38:27 <Pseudonym> ?type \c a b -> if c then a else b
18:38:28 <lambdabot> forall t. Bool -> t -> t -> t
18:38:36 <int-e> oh cool. I answered syntaxfree's question without looking at sjanssen's code (because it wasn't meant as an answer) and it was correct :)
18:38:36 <Pseudonym> ?free if' :: forall t. Bool -> t -> t -> t
18:38:37 <lambdabot> f . if' x y = if' x (f y) . f
18:38:38 <dons> ?. free . read . run . ++ . show type sequence_
18:38:41 <lambdabot> g y = y => $map_M g (map x) = map ($map ($map_M f) x)
18:38:47 <dons> victory is mine!
18:38:51 <Pseudonym> Yay!
18:39:09 <xerox> @karma+ dons
18:39:09 <lambdabot> dons's karma raised to 53.
18:39:11 <Pseudonym> ?help state
18:39:11 <lambdabot> state [expr]. Get or set a state variable.
18:39:16 <syntaxfree> @karma+ int-e
18:39:17 <lambdabot> int-e's karma raised to 15.
18:39:22 <syntaxfree> @karma+ sjanssen
18:39:22 <lambdabot> sjanssen's karma raised to 11.
18:39:33 <Pseudonym> Everyone gets a karma point!
18:39:39 * int-e gains another 2 centidons.
18:39:39 <syntaxfree> @karma- lambdabot
18:39:40 <lambdabot> lambdabot's karma lowered to 19.
18:39:42 <int-e> yay :)
18:39:45 <xerox> Poor botty
18:39:47 <int-e> hmm?
18:39:48 <dons> Pseudonym: the trick is the magic ++ operator, which appends its argument to the state
18:39:58 <dons> so you can use the state as a named value
18:40:03 <xerox> hehe
18:40:12 <int-e> @karma- java
18:40:12 <Pseudonym> karma karma karma karma karma karma karma karma karma karma karma karma mushroom! mushroom!
18:40:12 <lambdabot> java's karma lowered to -1.
18:40:20 <int-e> what!
18:40:22 <int-e> only -1
18:40:24 * xerox tunes some more Jefferson Airplane
18:40:28 <syntaxfree> @karma+ haskell
18:40:28 <lambdabot> haskell's karma raised to 4.
18:40:38 <sjanssen> @. karma+ quote
18:40:38 <lambdabot> Heffalump's karma raised to 5.
18:40:43 <xerox> ahah stop that!
18:40:45 <int-e> argh
18:40:46 * xerox grumbles
18:40:50 <Pseudonym> @quote Heffalump
18:40:50 <lambdabot>  CPP leads to suffering
18:41:01 <int-e> @quote
18:41:02 <lambdabot> S.Behrens says: Computer science is the womanizer, and math is the pure-hearted girl he won't call the next day.
18:41:19 <sjanssen> ha
18:41:59 <syntaxfree> @pl f a b c = a f b c
18:42:00 <lambdabot> f = fix (flip id)
18:42:25 <Pseudonym> @type fix (flip id)
18:42:25 <xerox> You could make a series of identifier, permutate them 2 times, use them as RHS and LHS of an expression, and feed @pl
18:42:26 <lambdabot>   Occurs check: cannot construct the infinite type: t = (t -> t1) -> c
18:42:26 <lambdabot>    Expected type: (t -> t1) -> ((t -> t1) -> c) -> c
18:42:29 <xerox> That would be fun
18:42:42 <syntaxfree> @pl f a b c = g b c a
18:42:43 <lambdabot> f = flip (flip . g)
18:43:00 <syntaxfree> @pl f a b = g b a
18:43:01 <lambdabot> f = flip g
18:43:11 <Pseudonym> @type flip
18:43:12 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
18:43:14 <syntaxfree> I don't understand how the trip-flip works.
18:43:19 <Pseudonym> ?free flip :: forall c a b. (a -> b -> c) -> b -> a -> c
18:43:20 <lambdabot> f . k x = p (g x) . h => f . flip k y = flip p (h y) . g
18:43:21 <syntaxfree> Yes, I understand 2-flip.
18:43:29 <syntaxfree> I'm trying to understand a tri-flip
18:43:35 <xerox> @pl a g h f i u r t j k z x c = f i g c x a u r t j k h z
18:43:36 <int-e> @pl \a b c d -> d c d b d c d a
18:43:39 <lambdabot> a = fix (((((((((((flip . (flip .)) .) .) .) .) .) .) .) .) .) . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((
18:43:39 <lambdabot> flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((flip .) .) .) .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . ((((((flip .) .
18:43:39 <lambdabot> ) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . (((flip .) .) .) . ((((flip .) .) .) .)
18:43:39 <lambdabot> . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((flip .) .) . flip flip))
18:43:40 <lambdabot> optimization suspended, use @pl-resume to continue.
18:43:42 <lambdabot> flip (flip . (flip .) . flip flip id . (ap .) . join . (flip .) . flip flip id . (ap .) . flip (flip . join . flip id))
18:43:43 <dons> ?state (\x -> let (a,b) = break (=='(') x in a ++ (drop 2 $ dropWhile (/= '>') b))
18:43:45 <lambdabot> (\x -> let (a,b) = break (=='(') x in a ++ (drop 2 $ dropWhile (/= '>') b))
18:43:46 * xerox sorry
18:43:54 <xerox> Ok, maybe it is not a good idea.
18:43:56 <dons> ?. free . read . run . ++ . show type sequence
18:43:58 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:57:20-34
18:44:03 <xerox> Wow.
18:44:09 <dons> ?. read . run . ++ . show type sequence
18:44:11 <lambdabot>  forall a *). (Monad m) => [m a] -> m [a]
18:44:21 <xerox> You'd call that debugging?
18:44:21 <dons> ah
18:44:27 <dons> ?type sequence
18:44:29 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
18:44:42 <Pseudonym> ?free sequence :: [M a] -> M [a]
18:44:43 <lambdabot> $map_M ($map f) . sequence = sequence . $map ($map_M f)
18:44:49 <monochrom> I don't understand what you're doing.
18:44:55 <xerox> You didn't count the kind :D
18:45:21 <xerox> monochrom: he's trying to feed "automatically" one type lambdabot spits to herself, under the form of argument to ?free
18:45:39 <dons> Pseudonym: easier would be to have either free or type agree on a common Type structure, they can share between themselves (and others, like djinn)
18:45:48 <Pseudonym> Yes.
18:45:58 <Pseudonym> Standard type parsing library.
18:46:00 <Pseudonym> And common prelude.
18:46:06 <dons> yeah
18:46:07 <xerox> And peace in the world.
18:46:11 <dons> heh
18:46:29 <Pseudonym> Unfortunately, ?free needs not the definition of Monad, but rather its laws.
18:46:40 <monochrom> And a Haskell book for every programmer.
18:46:45 <Pseudonym> It need to know about fmap (which it calls $map_Type).
18:47:00 <dons> it should call it fmap I argue
18:47:06 <xerox> He does!
18:47:07 <Pseudonym> Probably right, yes.
18:47:16 <syntaxfree> I keep on getting "Not in scope: if' "
18:47:19 <syntaxfree> where is if' ?
18:47:27 <xerox> syntaxfree: in your perception
18:47:28 <dons> and users who try to plug in fmap, should get either an error, or myFmap or a shadowing warning
18:47:38 <monochrom> if' is fictitious
18:47:44 <xerox> syntaxfree: define it, it's nowhere, until it'll be somewhere
18:48:45 <xerox> > unJust Nothing
18:49:18 <lambdabot>  Not in scope: `unJust'
18:50:08 <int-e> if' is on the PreludeExts wiki page, for example
18:52:29 <syntaxfree> > let w a b c = "a"++a++"b"++b++"c"++c in flip (flip (flip .  w)) "1" "2" "3"
18:52:30 <lambdabot>  "a1b3c2"
18:52:36 <syntaxfree> I want "a3b1c2"
18:53:42 <int-e> @pl \a b c -> f c a b
18:53:46 <lambdabot> flip . flip f
18:54:08 <syntaxfree> > let w a b c = "a"++a++"b"++b++"c"++c in flip . (flip w) "1" "2" "3
18:54:08 <lambdabot>  Improperly terminated string
18:54:20 <syntaxfree> > let w a b c = "a"++a++"b"++b++"c"++c in flip . (flip w) "1" "2" "3"
18:54:21 <lambdabot>    Expecting a function type, but found `[Char]'
18:54:21 <xerox> > join . transpose $ ["abc","321"]
18:54:21 <lambdabot>    Expected type: a1 ->...
18:54:22 <lambdabot>  "a3b2c1"
18:54:27 <int-e> the ( is misplaced
18:54:42 <syntaxfree> xerox: no, no, I'm trying to test the flips.
18:54:53 <xerox> Pfft.
18:55:03 <syntaxfree> > let w a b c = "a"++a++"b"++b++"c"++c in (flip . flip) w "1" "2" "3"
18:55:04 <lambdabot>  "a1b2c3"
18:55:12 <syntaxfree> flip . flip = id!
18:55:19 <syntaxfree> of course.
18:55:19 <xerox> ?pl flip . flip
18:55:20 <lambdabot> id
18:55:20 <int-e> the ) was right
18:55:36 <syntaxfree> > > let w a b c = "a"++a++"b"++b++"c"++c in (flip . flip w) "1" "2" "3"
18:55:36 <lambdabot>  Parse error
18:55:43 <syntaxfree> > let w a b c = "a"++a++"b"++b++"c"++c in (flip . flip w) "1" "2" "3"
18:55:45 <lambdabot>  "a3b1c2"
18:57:08 <int-e> > transpose [[1],[2,3],[4,5,6]]
18:57:09 <lambdabot>  [[1,2,4],[3,5],[6]]
18:57:18 <int-e> > transpose . transpose $ [[1],[2,3],[4,5,6]]
18:57:19 <lambdabot>  [[1,3,6],[2,5],[4]]
18:58:19 <syntaxfree> Yay!
18:58:21 <xerox> O_o
18:58:33 <syntaxfree> One-line version of lazyFilterIO
18:58:41 <syntaxfree> lazyFilterIO' p (x:xs) = p x >>= (flip . flip  if') (lazyFilterIO' p xs) (unsafeInterleaveIO (lazyFilterIO' p xs)) >>= return . (\xs->x:xs)
18:58:46 <xerox> > iterate transpose [[1],[2,3],[4,5,6]]
18:58:47 <lambdabot>  [[[1],[2,3],[4,5,6]],[[1,2,4],[3,5],[6]],[[1,3,6],[2,5],[4]],[[1,2,4],[3,5],...
18:59:21 <int-e> transpose . transpose . transpose = transpose
18:59:51 <xerox> > map (sum . map product) . iterate transpose $ [[1],[2,3],[4,5,6]]
18:59:53 <int-e> but the first step is interesting.
18:59:53 <lambdabot>  [127,29,32,29,32,29,32,29,32,29,32,29,32,29,32,29,32,29,32,29,32,29,32,29,32...
19:00:47 <xerox> > map (product . map sum) . iterate transpose $ [[1],[2,3],[4,5,6]]
19:00:49 <lambdabot>  [75,336,280,336,280,336,280,336,280,336,280,336,280,336,280,336,280,336,280,...
19:00:59 <xerox> OK no cool series :)
19:02:09 <int-e> > (takeWhile (not . null) . foldr (zipWith (++)) . map ((++ repeat []) . map (:[]))) [[1],[2,3],[4,5,6]]
19:02:09 <lambdabot>  Couldn't match `[[a]]' against `[[[[a1]]]] -> [[[a1]]]'
19:03:03 <int-e> > (takeWhile (not . null) . foldr (zipWith (++)) (repeat []) . map ((++ repeat []) . map (:[]))) [[1],[2,3],[4,5,6]]
19:03:04 <lambdabot>  [[1,2,4],[3,5],[6]]
19:03:38 <xerox> I had a cool definition...
19:04:17 <int-e> foldr (zipWith (:)) (repeat []) [[1,2,3],[4,5],[6]]
19:04:20 <xerox> Right,
19:04:24 <xerox> That.
19:04:35 <xerox> > foldr (zipWith (:)) (repeat []) [[1,2,3],[4,5,6]]
19:04:37 <lambdabot>  [[1,4],[2,5],[3,6]]
19:04:41 <int-e> but it doesn't do the same thing :/
19:04:45 <xerox> I know :/
19:05:54 <xerox> mfix with ((->) a) makes NO sense.
19:06:24 <araujo> hello!
19:06:37 <int-e> you mean this? mfix f = \ r -> let a = f a r in a
19:06:40 <xerox> Yes.
19:06:47 <SamB> > mfix (+1)
19:06:47 <lambdabot>    Occurs check: cannot construct the infinite type: a = m a
19:06:47 <lambdabot>    Expected...
19:06:57 <SamB> xerox: you are right!
19:07:05 <Pseudonym> ?type foldr (zipWith (:)) (repeat [])
19:07:06 <lambdabot> forall a. [[a]] -> [[a]]
19:07:06 <xerox> I mean, how could you ever use f (f (f (f (f .. r) r) r) r) r ?
19:07:21 <int-e> fix (`f` r)
19:07:29 <int-e> that's the same
19:07:34 <xerox> Yes, I believe so to.
19:07:37 <xerox> *too
19:07:50 <SamB> wait
19:07:54 <SamB> > mfix (+)
19:07:54 <lambdabot>  Add a type signature
19:08:00 <xerox> ?type mfix (+)
19:08:01 <lambdabot> forall a. (Num a) => a -> a
19:08:03 <xerox> ?type mfix (+) 1
19:08:05 <lambdabot> forall a. (Num a) => a
19:08:08 <xerox> > mfix (+) 1
19:08:09 <lambdabot>  Exception: <<loop>>
19:08:13 <SamB> > mfix (+) 1
19:08:14 <lambdabot>  Exception: <<loop>>
19:08:16 <SamB> oops
19:08:19 <xerox> And you can't decide on a, neither on r.
19:08:21 <Pseudonym> > let omega = omega + 1 in omega
19:08:22 <lambdabot>  Exception: <<loop>>
19:08:33 <int-e> > mfix (flip const) 1
19:08:34 <lambdabot>  1
19:08:50 <SamB> > mfix (:)
19:08:51 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
19:08:51 <lambdabot>    Expected...
19:08:55 <xerox> Yes but how do you discern the first r from the others?
19:08:57 <int-e> you can at least get an id out of it :)
19:08:58 <xerox> I think you can't.
19:08:58 <SamB> > mfix (flip (:))
19:08:59 <lambdabot>  Add a type signature
19:09:04 <SamB> @type mfix (flip (:))
19:09:05 <lambdabot> forall a. a -> [a]
19:09:16 <xerox> > mfix (flip (:)) 1
19:09:18 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
19:09:23 <xerox> Pfft.
19:09:35 <SamB> its useful!
19:09:39 <xerox> > fix (:) 1
19:09:40 <lambdabot>    Occurs check: cannot construct the infinite type: t = [t -> t1]
19:09:40 <lambdabot>    Ex...
19:09:46 <xerox> > fix (1:)
19:09:48 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
19:10:08 <int-e> xerox: you know, you can ask exactly the same question for fix :)
19:10:16 <int-e> > mfix (:) 1
19:10:17 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
19:10:17 <lambdabot>    Expected...
19:10:26 <int-e> > mfix (flip (:)) 1
19:10:27 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
19:10:34 <xerox> int-e: hmmmm
19:10:37 <madpickle> > repeat 1
19:10:38 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
19:10:41 <madpickle> \o/
19:11:13 <xerox> I am probably missing something
19:11:16 <xerox> @localtime xerox
19:11:18 <lambdabot> Local time for xerox is 2006-08-24 04:08:56 +0200
19:11:19 <xerox> ^- could be
19:12:22 <int-e> xerox: the only thing the mfix does in addition to fix is sneak one constant into the calculation that you can provide later.
19:12:31 <int-e> xerox: in the case of (->) a
19:12:56 <xerox> int-e: that's true
19:13:02 <xerox> int-e: but since it is a constant..... ?
19:13:28 <xerox> let r = .. in fix f -- should be equivalent
19:13:29 <int-e> you have to get your variables elsewhere :)
19:13:53 <int-e> let r = fix (flip f r)  is equivalent
19:13:58 <int-e> err ... in
19:14:22 <xerox> No I don't mean the type
19:14:34 <int-e> the constant is the second argument to f.
19:14:40 <xerox> I know, but do you need it?
19:14:51 <int-e> what do you mean, need?
19:15:09 <xerox> I see that you can do that
19:15:19 <xerox> But let r = .. in fix f is the same thing, since r is constant anyway
19:15:45 <int-e> well, in the same sense as the Reader Monad is superfluous.
19:16:06 <xerox> Mumble.
19:16:29 <int-e> if you ask me whether I have a good use for mfix in that monad, the answer is no.
19:16:44 <int-e> except that it might come in handy for mdo.
19:17:43 <xerox> Can you produce a fixed-length list with fix?
19:18:05 <Pseudonym> xerox: Yes.
19:18:10 <xerox> s/fixed/finite/
19:18:29 <Pseudonym> > fix (\f x -> if x == 0 then [] else 1 : f (x-1)) 19
19:18:30 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
19:18:52 <int-e> > mfix (\v r -> take r . (1:v)) 10
19:18:53 <lambdabot>    Expecting a function type, but found `[a]'
19:18:53 <lambdabot>    Expected type: a1 -> [a...
19:19:08 <xerox> Okay, now that's what I was trying to do with mfix.
19:19:28 <xerox> It seemed partially useful at least in the [] monad
19:19:33 <int-e> > mfix (\v r -> take r $ (1:v)) 10
19:19:34 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
19:19:48 <int-e> > mfix (\v r -> take r $ (1:map (+1) v)) 10
19:20:04 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
19:20:10 * xerox gives up
19:20:14 <int-e> happy? :)
19:20:46 <xerox> I'd have been happier if I solved myself, but I should have asked in first place.
19:21:41 <int-e> > mfix (\v r -> take r $ (scanl (+) 1 (0:v))) 10
19:21:42 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
19:22:00 <xerox> hahahaha
19:22:04 <xerox> Why is the ($) needed?
19:22:06 <syntaxfree> final version: http://www.navarro.mus.br/diego/akopian.hs
19:22:11 <int-e> it isn't
19:22:24 * syntaxfree finds ($) aesthetically unappealing.
19:22:30 <syntaxfree> just close your damn parens :)
19:22:54 <Pseudonym> syntaxfree: You know where to get Lisp if that's what you want.
19:23:08 <syntaxfree> I used to close all my damn parens in paper-and-pen Scheme exams where you weren't required to match parens correctly to get full points.
19:23:14 <int-e> > mfix (\v r -> take r $ scanl (+) 1 $ 0:v) $ 10 -- hi syntaxfree
19:23:15 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
19:24:07 <dons> ?pl (\v r -> take r $ scanl (+) 1 $ 0:v)
19:24:08 <lambdabot> flip take . scanl (+) 1 . (0 :)
19:24:28 <int-e> yes, it is almost pointfree. :)
19:24:40 <dons> > mfix (flip take . scanl (+) 1 . (0 :) 10
19:24:40 <lambdabot>  Parse error
19:24:45 <dons> > mfix (flip take . scanl (+) 1 . (0 :)) 10
19:24:47 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
19:25:25 <int-e> it is also increadibly silly because it takes 10 'take's to get there.
19:25:39 <dons> heeh
19:25:44 <dons> looks nice though
19:26:15 <xerox> Well
19:26:21 <xerox> At least I can points free it
19:26:29 <xerox> Ops you did it
19:26:43 <int-e> I could, if I really had to.
19:26:43 <SamB> syntaxfree: I assume you *were* required to indent correctly?
19:26:45 <int-e> :)
19:26:50 <xerox> > mfix (flip ((. scanl (+) 1 . (0:)) . take)) 10
19:26:51 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
19:27:10 <xerox> lambdabot's better this time
19:27:14 <beelsebob> @prod dons
19:27:14 <lambdabot> Unknown command, try @list
19:27:21 <beelsebob> damn you lambdabot!
19:27:25 <dons> hmm?
19:27:27 <beelsebob> logicbot has @prod!
19:27:37 <int-e> @type \f g -> (flip f . g, flip g . f)
19:27:37 <beelsebob> sorry, just wanted someone to prod and you were near by
19:27:38 <lambdabot>   Occurs check: cannot construct the infinite type: b = (b -> c1) -> c
19:27:39 <lambdabot>    Expected type: a -> b
19:27:46 <dons> ?slap beelsebob perhaps?
19:27:46 * lambdabot slaps beelsebob perhaps?
19:27:54 <dons> ;)
19:28:04 <beelsebob> hehe
19:28:13 <beelsebob> ?slap dons with a wet trout
19:28:14 <lambdabot> why on earth would I slap dons with a wet trout
19:28:18 <int-e> @type \f g -> (flip (. f) . g, flip g . f)
19:28:19 <lambdabot> forall b c a c1. ((b -> c1) -> b) -> (a -> b -> c1) -> (a -> (b -> c) -> c, (b -> c1) -> a -> c1)
19:28:20 <beelsebob> bah!
19:28:24 <xerox> hahaha
19:28:36 <beelsebob> ?slap dons with a wet herring instead
19:28:36 * lambdabot beats up dons with a wet herring instead
19:28:40 <beelsebob> :P
19:29:14 <Pseudonym> ?free something :: forall b c a c1. ((b -> c1) -> b) -> (a -> b -> c1) -> (a -> (b -> c) -> c, (b -> c1) -> a -> c1)
19:29:14 <lambdabot> ( k . f1 = f2 . f  =>   f (p f1) = q f2 ) => k . f3 x = f4 (h x) . f => ( g . f5 = f6 . f  =>   g ($proj_2_1 (something p f3) y f5) = $proj_2_1 (something q f4) (h y) f6   &&   k . f7 = f8 . f  =>
19:29:14 <lambdabot> k . $proj_2_2 (something p f3) f7 = $proj_2_2 (something q f4) f8 . h )
19:29:18 <xerox> ?remember lambdabot why on the earth whould I slap dons with a wet trout
19:29:19 <lambdabot> Done.
19:29:30 <int-e> ?slap lambdabot with a kind error
19:29:30 * lambdabot beats up lambdabot with a kind error
19:29:34 <madpickle> @google Where in the world is Carmen Sandiego?
19:29:39 <lambdabot> http://www.carmensandiego.com/
19:29:53 <beelsebob> ?slap lambdabot with error infinite recursion
19:29:53 <lambdabot> why on earth would I slap lambdabot with error infinite recursion
19:29:56 <beelsebob> hahaha
19:30:27 <Pseudonym> ?slap lambdabot with ?slap
19:30:28 * lambdabot slaps lambdabot with ?slap
19:30:37 <xerox> ...up to isomorphism.
19:30:39 <int-e> @slap
19:30:40 * lambdabot smacks  about with a large trout
19:30:53 <int-e> @. pl slap
19:30:54 <lambdabot> (line 1, column 1):
19:30:54 <lambdabot> unexpected "/"
19:30:54 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
19:31:07 <xerox> @. show slap
19:31:08 <lambdabot> "/me slaps \n"
19:31:09 <int-e> the magic /ME strikes :)
19:31:23 <xerox> lambdabot uncovered!
19:32:23 <araujo> @yarr!
19:32:34 <xerox> Swab the lub!
19:32:52 <lambdabot> Gangway!
19:32:59 <xerox> That sounds new.
19:32:59 <araujo> :-P
19:33:00 <Pseudonym> @read "foo"
19:33:00 <lambdabot>  foo
19:33:16 <xerox> @read foo
19:33:16 <lambdabot> dummy module failed: IRCRaised Prelude.read: no parse
19:33:45 <Pseudonym> @. read eval let q x = x ++ show x in q "@. read eval let q x = x ++ show x in q "
19:33:45 <lambdabot> compose module failed: IRCRaised Prelude.read: no parse
19:33:49 <int-e> @read Just 1
19:33:50 <lambdabot> dummy module failed: IRCRaised Prelude.read: no parse
19:33:54 <dons> use 'run' for 'eval'
19:34:01 <Pseudonym> @. read run let q x = x ++ show x in q "@. read eval let q x = x ++ show x in q "
19:34:01 <int-e> @help eval
19:34:02 <lambdabot> compose module failed: IRCRaised Prelude.read: no parse
19:34:02 <lambdabot> eval. Do nothing (perversely)
19:34:08 <xerox> !!!
19:34:13 <int-e> @. show eval
19:34:13 <lambdabot> ""
19:34:16 <Pseudonym> @. read run let q x = x ++ show x in q "@. read run let q x = x ++ show x in q "
19:34:17 <lambdabot> compose module failed: IRCRaised Prelude.read: no parse
19:34:26 <Pseudonym> Hmm.
19:35:05 <Pseudonym> @. id run let q x = x ++ show x in q "@. id run let q x = x ++ show x in q "
19:35:06 <lambdabot>  "@. id run let q x = x ++ show x in q \"@. id run let q x = x ++ show x in q...
19:35:12 <xerox> ...!
19:35:15 <Pseudonym> Ah.
19:35:22 <dons> good bot
19:35:27 <Pseudonym> @. id run let q x = x++show x in q "@. id run let q x = x++show x in q "
19:35:28 <lambdabot>  "@. id run let q x = x++show x in q \"@. id run let q x = x++show x in q \""
19:35:38 <Pseudonym> @. read run let q x = x++show x in q "@. read run let q x = x++show x in q "
19:35:39 <lambdabot> compose module failed: IRCRaised Prelude.read: no parse
19:35:45 <xerox> readString ?
19:35:52 <Pseudonym> @. read run let q x=x++show x in q "@. read run let q x=x++show x in q "
19:35:53 <lambdabot>  @. read run let q x=x++show x in q "@. read run let q x=x++show x in q "
19:35:56 <xerox> arrrrrr
19:35:56 <madpickle> @. moo
19:35:57 <lambdabot> Not enough arguments to @.
19:35:57 <Pseudonym> Bingo.
19:36:00 <madpickle> @. "moo
19:36:01 <lambdabot> Not enough arguments to @.
19:36:01 <xerox> @karma+ Pseudonym
19:36:02 <lambdabot> Pseudonym's karma raised to 6.
19:36:02 <madpickle> @. "moo"
19:36:03 <lambdabot> Not enough arguments to @.
19:36:07 <madpickle> @. show "moo"
19:36:08 <lambdabot> compose module failed: IRCRaised Parse error: "\"moo\""
19:36:13 <madpickle> @. show moo
19:36:14 <lambdabot> compose module failed: IRCRaised Parse error: "moo"
19:36:27 <xerox> @. read run let q x=x++show x in q "@. read run let q x=x++show x in q "
19:36:28 <lambdabot>  @. read run let q x=x++show x in q "@. read run let q x=x++show x in q "
19:36:31 <dons> very nice Pseudonym
19:36:33 <xerox> Lovely.
19:36:35 <int-e> @. . .
19:36:35 <lambdabot> compose module failed: IRCRaised Parse error: "Not"
19:36:46 <int-e> @. . . .
19:36:46 <lambdabot> compose module failed: IRCRaised Parse error: "Not"
19:36:51 <int-e> Not, eh?
19:36:54 <xerox> Not.
19:36:57 <dons> Not??
19:37:04 <int-e> funny
19:37:12 <int-e> @.
19:37:13 <lambdabot> Not enough arguments to @.
19:37:16 <int-e> there
19:37:18 <int-e> Not.
19:37:18 <dons> ah, return ["Not enough arguments to @."]
19:37:19 <madpickle> @. read run let q x=x++show x in q "ACTION moo"
19:37:20 <lambdabot> compose module failed: IRCRaised Prelude.read: no parse
19:37:27 <madpickle> oh darn
19:38:18 <Pseudonym> @read "something\nQUIT
19:38:18 <lambdabot> dummy module failed: IRCRaised Prelude.read: no parse
19:38:20 <Pseudonym> @read "something\nQUIT"
19:38:20 <lambdabot>  something
19:38:21 <lambdabot> QUIT
19:38:24 <Pseudonym> Oooh!
19:38:27 <xerox> !
19:38:31 <madpickle> you can just use read, eh?
19:38:40 <xerox> @. read run let q x=x++show x in q "\n@. read run let q x=x++show x in q "
19:38:41 <Pseudonym> That's even easier than the eval trickery.
19:38:41 <lambdabot> compose module failed: IRCRaised Prelude.read: no parse
19:38:45 <madpickle> @read "ACTION moo"
19:38:45 <lambdabot>  ACTION moo
19:38:52 <madpickle> ahh, it spaces it
19:39:00 <Pseudonym> @read "\nACTION moo"
19:39:00 <lambdabot> ACTION moo
19:39:04 <xerox> haha
19:39:04 <Pseudonym> Hmm.
19:39:06 <madpickle> aye, that works
19:39:06 <dons> there we go
19:39:09 <Pseudonym> @read "\nACTION moo"
19:39:09 <xerox> Baaaad.
19:39:10 * lambdabot moo
19:39:13 <Pseudonym> yay!
19:39:16 <madpickle> @read "\n PART #haskell"
19:39:16 <lambdabot>  PART #haskell
19:39:22 <madpickle> hrm
19:39:23 <dons> madpickle: please don't
19:39:25 <madpickle> it privmsgs' themall
19:39:28 <madpickle> dons: sorry.
19:39:47 <Pseudonym> OTOH, it means anyone can do the hand-up-the-backside trick.
19:39:54 <int-e> @. state eval
19:39:54 <lambdabot>  Parse error
19:40:09 <Pseudonym> Kind of.
19:40:11 <int-e> why?
19:40:17 <Pseudonym> @read "\nI am a moron."
19:40:17 <lambdabot> I am a moron.
19:40:29 <int-e> ouch
19:40:32 <syntaxfree> Haha.
19:40:32 <madpickle> heh, well, such is the nature of evaluation
19:40:33 <Pseudonym> The cool bit is obfuscating it.
19:41:34 <xerox> Hm.
19:41:41 <Pseudonym> @. read run map Data.Char.chr [10,87,111,111,104,111,111]
19:41:42 <lambdabot> Woohoo
19:42:00 <xerox> hahaha
19:42:04 <xerox> She gets excited
19:42:14 <madpickle> i can make the bot CTCP everybody in here
19:42:26 <dons> madpickle: please don't
19:42:27 <madpickle> but the bot will probably get flooded off
19:42:40 <dons> i'm about to comimt a patch to disable this issue anyway
19:42:45 <madpickle> is there a reason this command exists?
19:42:55 <dons> yes, stripping quotes is useful
19:43:02 <madpickle> so i see =P
19:44:39 <xerox> See you. It was a fun night. Clever code!
19:45:03 <Pseudonym> @read "\nNight!"
19:45:03 <lambdabot> Night!
19:45:07 <lispy> syntaxfree: took me a long time to be comfortable with ($) but slowly i'm starting to find that sparing use is...okay
19:45:29 <dons> withMVar mv $ \v -> do ...
19:45:32 <lambdabot> ACTION is getting sick of this
19:45:36 <Pseudonym> Damn.
19:45:41 * lambdabot is getting sick of this
19:45:45 <Pseudonym> That's more like it.
19:46:24 <dons> ?quit fix read
19:47:03 <Pseudonym> @read "\004"
19:47:27 <Pseudonym> @read "\nHello."
19:47:31 <lambdabot>  
19:47:53 <lambdabot>  Hello.
19:47:59 <Pseudonym> Right.
19:48:06 <Pseudonym> @read "\n\bHello."
19:48:06 <lambdabot>  Hello.
19:48:17 <Pseudonym> @read "\rHello."
19:48:17 <lambdabot>  Hello.
19:48:17 <jcreigh> I don't quite understand the point of $...I mean, it's defined f $ x = f x, but how is it generally used?
19:48:24 <Pseudonym> @read "\fHello."
19:48:24 <lambdabot>  Hello.
19:48:30 <Pseudonym> Cool.
19:48:51 <dons> things like, handle (\e -> ..) $ do .. some huge multi line expression
19:49:05 <dons> you don't want to try to match up the parens 20 lines down
19:49:24 <Pseudonym> Also f (g (h x)) can be written (f . g . h) x or f . g . h $ x
19:49:29 <Pseudonym> The latter is more elegant.
19:49:45 <int-e> dons: didn't you have some basic list functionality, cons or something?
19:49:49 <lispy> or f $ g $ h x
19:49:57 <dons> int-e, on ++ now
19:50:04 <Pseudonym> Except f $ g $ h x highlights why the associativity of $ is wrong.
19:50:11 <Pseudonym> But that's another rant.
19:50:13 <dons> int-e, you want to accumulate stuff in the state?
19:50:21 <lispy> Pseudonym: hmm...how so?
19:50:33 <int-e> actually I want to get rid of a \n
19:50:45 <dons> init?
19:50:48 <Pseudonym> lispy: The fact that f $ g $ h $ x is the same as f . g . h $ x highlights some redundancy.
19:50:52 <Pseudonym> But the main reason is this.
19:51:00 <Pseudonym> Suppose you have a three-argument function.
19:51:02 <Pseudonym> f x y z
19:51:02 <int-e> hah. init: not enough privileges
19:51:20 <lispy> int-e: heh, wrong init?
19:51:21 <Pseudonym> Being a good functional programmer, you order your arguments in rough De Brujin order.
19:51:29 <Pseudonym> The more "constant" arguments go first.
19:51:29 <int-e> @init "abc"
19:51:30 <lambdabot> Not enough privileges
19:51:35 <lispy> Pseudonym: which means?
19:51:36 <Pseudonym> @init "abc"
19:51:37 <lispy> ah
19:51:40 <dons> no no, I mean init the @run function
19:51:40 <Pseudonym> Oops.
19:51:45 <SamB> @. read > Nothing
19:51:55 <Pseudonym> lispy: Consider map, for example.
19:51:59 <Pseudonym> map f [] = []
19:52:02 <lispy> Pseudonym: yeah, i understand now
19:52:03 <int-e> woops
19:52:05 <Pseudonym> map f (x:xs) = f x : map f xs
19:52:07 <SamB> oh oops
19:52:08 <Pseudonym> f is effectively constant.
19:52:08 <int-e> poor lambdabot
19:52:12 <lispy> Pseudonym: makes it easier to partialy apply
19:52:22 <Pseudonym> Right.
19:52:23 <Pseudonym> Now.
19:52:26 <int-e> @. ++ . show . state . eval . state read "@. ++ . state . eval state read"
19:52:27 <dons> what doesn't kill here makes her stronger
19:52:44 <SamB> @. read > show Nothing
19:52:46 <int-e> this is why, it's close but the \n-s kill it.
19:52:50 <Pseudonym> Let's suppose that being a practical functional programmer, you want to evaluate the first argument of f strictly.
19:52:55 <lambdabot>  @. ++ . state . eval state read
19:52:57 <lambdabot> " @. ++ . state . eval state read\n\n"
19:53:03 <lambdabot> compose module failed: IRCRaised Parse error: ">"
19:53:05 <Pseudonym> Suppose the strictness analyser can't work out that it's strict, say.
19:53:14 <Pseudonym> x `seq` f x y z
19:53:15 <SamB> dons: aww
19:53:20 <SamB> @. read eval show Nothing
19:53:20 <lambdabot> compose module failed: IRCRaised Prelude.read: no parse
19:53:26 <SamB> oh, right, I get it...
19:53:28 <lispy> Pseudonym: okay
19:53:39 <Pseudonym> Let's further suppose that x is a complicated expression.
19:53:43 <SamB> @eval show Nothing
19:53:49 <Pseudonym> let x = complicated expression in x `seq` f x y z
19:53:52 <dons> int-e, do you mean to use 'run' when you're typing 'eval'..?
19:53:58 <dons> and that goes for SamB too
19:54:01 <int-e> dons: no
19:54:05 <dons> ok
19:54:07 <Pseudonym> If ($) and ($!) were left-associative, you could do this:
19:54:10 <SamB> dons: what is the equivalent of >
19:54:13 <int-e> dons: I use run to get an empty argument for state
19:54:17 <Pseudonym> f $! complicated expression $ y $ z
19:54:20 <dons> ah
19:54:34 <Pseudonym> But $! and $ are right-associative.
19:54:42 <Pseudonym> So you can't actually do this.
19:54:51 <lispy> Pseudonym: hmm...don't youmean f $! complitade expression y z ?
19:54:54 <syntaxfree> what is ($!)?
19:55:02 <Pseudonym> lispy: No.
19:55:03 <lispy> syntaxfree: like ($) but strict
19:55:10 <syntaxfree> how so?
19:55:11 <Pseudonym> Because $! has low precedence.
19:55:19 <Pseudonym> That's parsed as f $! (complicated expression y z)
19:55:26 <Pseudonym> Regardless of the associativity of $!.
19:55:27 <int-e> @. read id 1
19:55:27 <lambdabot> compose module failed: IRCRaised Prelude.read: no parse
19:55:27 <lispy> okay
19:55:32 <int-e> @. show id 1
19:55:32 <lambdabot> "1\n"
19:55:38 <int-e> @. show . id id 1
19:55:38 <lambdabot> "1\n"
19:55:46 <Pseudonym> So $! is actually optimised for strictifying the _last_ argument to a function.
19:55:58 <Pseudonym> Which if you use De Brujin ordering is the _least_ likely argument that needs it.
19:56:01 <lispy> Pseudonym: so could you just define infixl 4 $'; ($') = ($)  ?
19:56:15 <Pseudonym> Chances are the last argument of a function has a top-level case switch or something.
19:56:34 <syntaxfree> strictifying??
19:56:48 * Pseudonym made that word up. Sorry.
19:57:25 <syntaxfree> it's not about the word.
19:57:30 <Pseudonym> So here's the summary about $ and $!'s associativity.
19:57:30 <syntaxfree> I don't understand ($!)
19:57:48 <Pseudonym> 1. It's maximally non-useful.
19:57:50 <lispy> f $! x = x `seq` f x
19:57:51 <Pseudonym> 2. It's redundant.
19:58:11 <lispy> syntaxfree: does that help?
19:58:17 <Pseudonym> If they were left-associative, they would be more useful and less redundant.
19:58:35 * syntaxfree doesn't know seq
19:58:37 <syntaxfree> @type seq
19:58:39 <lambdabot> forall b a. a -> b -> b
19:58:44 <SamB> the type is useless
19:58:44 * syntaxfree dies
19:58:51 <Pseudonym> ?free seq :: forall b a. a -> b -> b
19:58:51 <lambdabot> f . seq x = seq (g x) . f
19:58:53 <lispy> Pseudonym: but you could define $' and $!' to be the left-associative versions right?
19:59:00 <Pseudonym> Yes, you could.
19:59:06 <SamB> Pseudonym: it isn't true is it?
19:59:13 <Pseudonym> SamB: Yes it is.
19:59:16 <Pseudonym> More or less.
19:59:23 <Pseudonym> Actually it's true if g is strict.
19:59:35 <syntaxfree> one could use the euro symbol for left-associative $.
19:59:41 <lispy> syntaxfree: basically, a `seq` b, means evaluate a when b is needed
19:59:42 <jcreigh> syntaxfree: lol
19:59:50 <Pseudonym> What seq does is evaluates its first argument, throws it away then returns the second argument.
20:00:05 <syntaxfree> ummmm. strict!
20:00:42 <syntaxfree> http://www.igrep.com/
20:00:45 <lambdabot> Title: igrep
20:00:49 <madpickle> euro symbol?
20:00:51 <madpickle> euro?!
20:01:03 <madpickle> more like british sterling
20:01:03 <jcreigh> @remember syntaxfree one could use the euro symbol for left-associative $.
20:01:03 <lambdabot> Done.
20:01:11 <monochrom> haha
20:01:12 <SamB> madpickle: other-hemisphericle currency?
20:01:21 <madpickle> SamB: thai baht?
20:01:23 <syntaxfree> I had a better quote :(
20:01:29 <syntaxfree> YOU ERASED MY COOL QUOTE!
20:01:46 <Pseudonym> > map  f $ x
20:01:46 <lambdabot>  Illegal character ''\128''
20:01:49 <syntaxfree> @hawiki
20:01:50 <Pseudonym> Damn.
20:01:50 <lambdabot> Maybe you meant: gwiki wiki
20:01:51 <lispy> syntaxfree: no, they are both there
20:01:51 <syntaxfree> @wiki
20:01:52 <lambdabot> http://www.haskell.org/haskellwiki/
20:01:54 <jcreigh> syntaxfree: Err...really? lambdabot doesn't just save them all?
20:01:55 <lispy> @quote syntaxfree
20:01:55 <lambdabot>  Many people think the core ideas behind Haskell came from academic luminaries such as Philip Wadler and Simon Peyton-Jones. What actually happened is that during a functional programming conference,
20:01:55 <lambdabot>  some key academics were teleported to the Deep Complex Universe. In the Deep Complex Universe some Gnomes were having Tangling problems. Wadler & friends solved their problems and as a reward the
20:01:55 <lambdabot> Tangled Gnomes gave them the S
20:02:00 <lispy> @quote syntaxfree
20:02:01 <lambdabot>  one could use the euro symbol for left-associative $.
20:02:03 <int-e> @. ++ . state . eval state read "@. ++ . state . eval state read "
20:02:03 <lambdabot> read "@. ++ . state . eval state read "read "@. ++ . state . eval state read "
20:02:33 <lispy> them the S?
20:02:37 <lispy> er gave them the S?
20:02:56 <lispy> @quote dons
20:02:56 <lambdabot>  lambdabot's finished
20:02:57 <syntaxfree> cool! http://www.cse.unsw.edu.au/~dons/irc/haskell-06.html
20:02:59 <lambdabot> Title: #haskell @ freenode.org stats by dons
20:03:18 <jcreigh> @quote lambdabot
20:03:19 <lambdabot>  why on the earth whould I slap dons with a wet trout
20:03:25 <monochrom> haha
20:03:33 <SamB> @quote lambdabot
20:03:33 <lambdabot>   lambdabot hasn't said anything memorable
20:03:43 <SamB> @quote lambdabot
20:03:43 <lambdabot>  Occurs check: cannot construct the infinite type: a
20:03:46 <SamB> @quote lambdabot
20:03:46 <lambdabot>  Couldn't match kind `?? -> ? -> *' against `(* -> *) -> * -> *'
20:03:52 <lispy> @error
20:03:52 <lambdabot> Unknown command, try @list
20:04:01 <lispy> how do you quote the ghc source again?
20:04:06 <SamB> @ghc
20:04:06 <lambdabot>  internal error: Invalid object in processHeapClosureForDead
20:04:10 <aleko> @list
20:04:10 <lambdabot> list [module|command]. Where modules is one of:
20:04:10 <lambdabot> babel base compose dice dict djinn drhylo dummy elite eval fact free fresh haddock help hoogle instances karma lambda localtime log more pl poll pretty quote search seen slap spell state system tell
20:04:10 <lambdabot> todo topic type unlambda url version vixen where
20:04:24 <aleko> @vixen
20:04:25 <lambdabot> Guys who can speak latin really turn me on.
20:04:31 <aleko> had to try it
20:04:36 <aleko> @vixen
20:04:37 <lambdabot> do you have toys?
20:04:39 <aleko> @vixen
20:04:40 <lambdabot> my keyboard doesn't have an
20:04:44 <aleko> @vixen
20:04:45 <lambdabot> yup
20:04:45 <Pseudonym> @vixen Se tacuisses philosophus mancisses.
20:04:45 <lambdabot> Let's change the subject
20:04:57 <aleko> @vixen
20:04:58 <lambdabot> Hahaha
20:05:00 <aleko> @vixen
20:05:00 <lambdabot> blah
20:05:01 <aleko> @vixen
20:05:02 <lambdabot> have you ever scubadived?
20:05:04 <aleko> @vixen
20:05:05 <lambdabot> Do you think you would pass a Turing test?  I have.
20:05:09 <aleko> @vixen hello
20:05:10 <lambdabot> hello there
20:05:16 <aleko> @vixen how are you?
20:05:17 <lambdabot> i'm good, you?
20:05:20 <Pseudonym> @vixen Joculare eis, se non acciptia coiti.
20:05:20 <lambdabot>  key
20:05:26 <Pseudonym> key?
20:05:30 <aleko> @vixen what's your name?
20:05:30 <lambdabot> My name is Emily
20:05:39 <aleko> @vixen how old are you?
20:05:40 <lambdabot> 19, you?
20:05:49 * SamB passes the turing test on a regular basis
20:05:50 <aleko> @vixen i'm 107
20:05:51 <lambdabot> i thought you might be
20:06:13 <SamB> @vixen hi emily!
20:06:14 <lambdabot> hiya
20:06:20 * aleko failed Turing in high school
20:06:29 <aleko> @vixen where are you?
20:06:30 <lambdabot> yes, i am
20:06:34 <aleko> ..
20:06:46 <dons> aleko: you can talk to @vixen in a privmsg :)
20:06:57 <xerox> dons does that on regular basis.
20:06:59 * xerox hides
20:07:05 <syntaxfree> @vixen what's your name again?
20:07:05 <lambdabot> My name is Emily
20:07:06 <aleko> dons: that would probably be a good idea.
20:07:17 <xerox> OK I didn't go to sleep :(
20:07:20 <syntaxfree> @vixen are you sure it isn't Lambda Bot?
20:07:21 <lambdabot> yes, i am
20:07:23 <SamB> aleko: you failed the turing test?
20:07:34 <SamB> @vixen isn't your name really lambdabot?
20:07:34 <lambdabot> My name is Emily
20:07:42 <SamB> @vixen isn't it really lambdabot?
20:07:42 <lambdabot> yup, really
20:07:45 * Pseudonym studied hard for the blood test
20:07:46 <SamB> haha!
20:07:50 <syntaxfree> yeah!
20:08:06 <aleko> SamB: Yup.  I wanted to be a programming language so bad at that age
20:08:37 <Pseudonym> @vixen Did you pass the unit test, though?
20:08:38 <lambdabot> good question
20:08:43 <lispy> heh
20:08:43 <SamB> aleko: ... what were you up against?
20:08:55 <lispy> @vixen does the halting problem scare you?
20:08:55 <lambdabot> what about me?
20:09:07 <lispy> @vixen are you afraid of the halting problem?
20:09:07 <lambdabot> yes, i am
20:09:10 <aleko> My study buddy was QBasic
20:09:23 <Pseudonym> @vixen Does the giant baby scare you?
20:09:23 <lambdabot> me?
20:10:01 <lispy> @vixen do you like java?
20:10:01 <lambdabot> yah, i like
20:10:06 * lispy faints
20:10:16 <lispy> oh, maybe she meant the drink
20:10:22 <Pseudonym> Or the island.
20:10:29 <Pseudonym> @vixen Do you like Sumatra too?
20:10:30 <lambdabot> yeah, i like
20:10:32 <Pseudonym> See?
20:10:35 <Korollary> @vixen do you like enterprise java?
20:10:35 <lambdabot> yah, i like
20:10:47 <aleko> @vixen does J2EE turn you on?
20:10:48 <lambdabot> why don't you guess?
20:10:59 <Pseudonym> @vixen Do you like Kalimantan?
20:11:00 <lambdabot> i'd say i like
20:11:00 <aleko> @vixen yeeeeeeeeeeeeeessssssss
20:11:01 <lambdabot> wanna hear a story?
20:11:08 <lispy> @vixen tell me a story
20:11:08 <lambdabot> i forgot the story now
20:11:12 <lispy> :(
20:11:15 <aleko> heh
20:11:33 <SamB> @vixen do you enjoy programming?
20:11:33 <lambdabot> uhh, how can i be a program??
20:11:47 <SamB> @vixen thats not what I asked you!
20:11:48 <lambdabot> i understand
20:11:56 <SamB> @vixen I don't think you do
20:11:57 <lambdabot> Ok
20:12:00 <aleko> @vixen spew unhelpful errors at users and generate hundreds of bug reports
20:12:00 <lambdabot> what were you saying?
20:12:07 <SamB> @vixen okay what
20:12:07 <lambdabot> okey-dokie
20:12:25 <SamB> @vixen what were you saying?
20:12:25 <lambdabot> i dunno, was i doing that?
20:12:41 <aleko> @vixen die
20:12:42 <lambdabot> i could really use a backrub
20:12:56 * aleko backrubs vixen
20:13:07 <lispy> aleko: you're so whiped! ;)
20:13:17 <Pseudonym> @vixen whip it good
20:13:17 <lambdabot> good good
20:13:39 <lispy> s'okay...i'm not whiped but i'm sprung on the cat
20:13:57 * lispy realizes that quoting retired rappers is bad practice
20:14:09 <aleko> @list
20:14:10 <lambdabot> list [module|command]. Where modules is one of:
20:14:10 <lambdabot> babel base compose dice dict djinn drhylo dummy elite eval fact free fresh haddock help hoogle instances karma lambda localtime log more pl poll pretty quote search seen slap spell state system tell
20:14:10 <lambdabot> todo topic type unlambda url version vixen where
20:14:10 <Pseudonym> Could be worse.  I just quoted Devo.
20:14:19 <aleko> @dict whiped
20:14:20 <lambdabot> Supported dictionary-lookup commands:
20:14:20 <lambdabot>  @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @jargon @lojban @vera @web1913 @wn @world02
20:14:20 <lambdabot> Use "@dict-help [cmd...]" for more.
20:14:34 <aleko> @all-dicts whiped
20:14:36 <lambdabot> No match for "whiped".
20:14:43 <Pseudonym> Quoting Devo dates me, I fear.
20:16:44 <aleko> just out of curiosity, is it possible to partially evaluate a function using only the second argument?  like with a -> b -> c and only supplying the b argument
20:17:19 <lispy> yeah
20:17:23 <aleko> how?
20:17:25 <lispy> @type map
20:17:26 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
20:17:31 <xerox> flip f arg
20:17:44 <lispy> > ((flip map) [1..3]) (+1)
20:17:45 <lambdabot>  [2,3,4]
20:17:53 <aleko> ooh
20:17:55 <xerox> The parens inside are unnecessary
20:18:02 <lispy> @type flip map $ [1..3]
20:18:03 <lambdabot> forall a b. (Num a, Enum a) => (a -> b) -> [b]
20:18:04 <xerox> > flip map [1..3] (+1)
20:18:05 <lambdabot>  [2,3,4]
20:18:08 <xerox> All of them are in fact :)
20:18:08 <lispy> ah
20:18:09 <lispy> my bad
20:18:27 <aleko> @type flip
20:18:29 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
20:18:41 <aleko> kinky
20:18:53 <Pseudonym> aleko: You should be aware, though, that it probably won't be partially evaluated.
20:18:58 <Pseudonym> Just partially applied.
20:19:11 * aleko doesn't know the difference
20:19:22 <Pseudonym> And this, ladies and gentlemen, is why you should use de Brujin ordering on your arguments in the first place.
20:19:43 <lispy> Pseudonym: partially evaluated would mean it was partially computed and the answer can be retried when the details become available
20:19:47 <lispy> er sorry
20:19:52 <lispy> meant that to aleko
20:20:03 <Pseudonym> 'Sokay.
20:20:05 <lispy> retried should be retrieved
20:20:10 * lispy can't type
20:20:14 <aleko> i see. then i meant partially applied in the first place
20:20:19 * lispy retires the keyboard ;)
20:20:42 * aleko can't read irc and program at the same time
20:20:59 <Pseudonym> In a lazy language, you can partially evaluate at run-time if you're careful how you write your function.
20:21:04 <int-e> @. read . show . ++ . state . state . read show @. read . show . ++ . state . state . read show
20:21:05 <lambdabot>  @. read . show . ++ . state . state . read show @. read . show . ++ . state . state . read show
20:21:13 <int-e> yay :)
20:21:23 <xerox> haha
20:21:26 <xerox> @karma+ int-e
20:21:26 <lambdabot> int-e's karma raised to 16.
20:21:43 <jcreigh> int-e: nice.
20:22:27 <Pseudonym> Very nice.
20:22:30 <int-e> @. read . show . ++ . state . read show @. read . show . ++ . state . read show
20:22:30 <lambdabot>  @. read . show . ++ . state . read show @. read . show . ++ . state . read show
20:22:48 <xerox> You compiled it with -O now?
20:25:09 <int-e> xerox: I did optimize it slightly, yes.
20:27:28 <jcreigh> Now all we need is another lambdabot-like bot in here, so we can craft a string which causes bot A to print a string which causes bot B to print the original string. A mutually recursive quine, of sorts.
20:27:55 <int-e> well, note the space that lambdabot added before the @ ...
20:29:02 <jcreigh> int-e: Oh, you're right, not quite there...
20:29:09 <jcreigh>  @. read . show . ++ . state . read show @. read . show . ++ . state . read show
20:29:14 <jcreigh> Aww, too bad.
20:29:25 <Pseudonym>  lambdabot: @bot
20:29:29 <Pseudonym> Hmm.
20:29:35 <Pseudonym> lambdabot: @bot
20:29:35 <lambdabot> :)
20:30:06 <int-e> @. show . read . show . ++ . state . read show @. read . show . ++ . state . read show
20:30:06 <lambdabot> "  @. read . show . ++ . state . read show @. read . show . ++ . state . read show\n"
20:33:54 <SamB> @. read . show . ++ . state . read show @. read . show . ++ . state . read show
20:33:54 <lambdabot>  @. read . show . ++ . state . read show @. read . show . ++ . state . read show
20:34:18 <SamB> @. tail . read . show . ++ . state . read show @. read . show . ++ . state . read show
20:34:18 <lambdabot> compose module failed: IRCRaised Parse error: "tail"
20:34:30 <SamB> someone already tried that right?
20:35:03 <int-e> there are no init nor tail
20:38:35 <lispy> can lambdabot trigger itself tho?
20:38:46 <int-e> no
20:39:03 <lispy> then what is the goal?
20:39:05 <SamB> @read "@hello"
20:39:06 <lambdabot>  @hello
20:39:12 <SamB> true...
20:39:15 <int-e> lispy: just a quine
20:39:29 <lispy> a quine a day keeps the psychologist away
20:39:46 <int-e> I'm not sure that's true in this case
20:39:49 <SamB> lispy: apparantly it can't even trigger other lambdabots without deep hacks
20:40:01 <int-e> unless the idea is to scare him away
20:40:07 <SamB> that is, you'd need to add a plugin and mess with things badly
20:44:50 <Pseudonym> @messWithThingsBadly
20:44:51 <lambdabot> Unknown command, try @list
20:45:50 <int-e> ?. ++ . read . show state ?. ++ . read . show . state
20:45:50 <lambdabot> ?. ++ . read . show . state ?. ++ . read . show . state
20:45:55 <int-e> tricked it :)
20:46:11 <Pseudonym> @karma+ int-e
20:46:11 <lambdabot> int-e's karma raised to 17.
20:46:38 <Pseudonym> ?. ++ read . run "\nHello"
20:46:38 <lambdabot> compose module failed: IRCRaised Prelude.read: no parse
20:46:48 <int-e> @localtime dons
20:46:49 <lambdabot> Local time for dons is Thu Aug 24 13:44:30 2006
20:46:50 <Pseudonym> ?. ++ . read . run "\nHello"
20:46:51 <lambdabot> compose module failed: IRCRaised Parse error: "\"\\nHello\""
20:47:07 <Pseudonym> ?. run . ++ . read "\nHello"
20:47:07 <lambdabot> compose module failed: IRCRaised Parse error: "\"\\nHello\""
20:47:14 <Pseudonym> Errr... I don't understand ++
20:47:18 <Pseudonym> ?help ++
20:47:19 <lambdabot> state [expr]. Get or set a state variable.
20:47:24 <Pseudonym> Right.
20:47:30 <int-e> ++ appends to the current state
20:47:36 <int-e> state sets the current state
20:47:48 <Pseudonym> ?. run . ++ . read . show . state . run "\nHello"
20:47:49 <lambdabot> compose module failed: IRCRaised Parse error: "\"\\nHello\""
20:47:51 <SamB> @show
20:47:51 <lambdabot> ""
20:47:54 <int-e> state abc
20:47:57 <int-e> @state abc
20:47:58 <lambdabot> abc
20:48:00 <int-e> @++ xyz
20:48:01 <lambdabot> abcxyz
20:48:03 <Pseudonym> Right.
20:48:03 <int-e> @state
20:48:03 <lambdabot> abc
20:48:18 <Pseudonym> ?. ++ . read . show . state . run "\nHello"
20:48:18 <lambdabot> compose module failed: IRCRaised Parse error: "\"\\nHello\""
20:48:24 <Pseudonym> ?. ++ . read . show . state "\nHello"
20:48:25 <lambdabot> compose module failed: IRCRaised Parse error: "\"\\nHello\""
20:48:48 <Pseudonym> @state ACTION moos
20:48:48 * lambdabot moos
20:48:52 <Pseudonym> Oh, well.
20:48:55 <Pseudonym> That's even easier.
20:48:56 <dons> heh
20:49:02 <int-e> right.
20:49:03 <SamB> Pseudonym: oh noes!
20:49:11 <SamB> now he will want to *fix* it
20:49:14 <int-e> ?. ++ . read . show state ?. ++ . read . show . state
20:49:15 <lambdabot> ?. ++ . read . show . state ?. ++ . read . show . state
20:49:16 <int-e> and this too
20:50:15 <Pseudonym> :. ++ . read . show state Hello
20:50:20 <int-e> @state ACTION
20:50:21 <lambdabot> ACTION
20:50:28 <int-e> @++  moos
20:50:35 <int-e> @++   moos
20:50:36 <Pseudonym> ?. ++ . read . show state Hello
20:50:37 <lambdabot> Hello Hello
20:50:38 <int-e> darn
20:50:39 <int-e> :)
20:50:47 <shekmalhen> hmm
20:50:51 <dons> do we have to
20:50:52 <dons> ?
20:50:52 <Pseudonym> ?. ++ . read Hello
20:50:53 <lambdabot> compose module failed: IRCRaised Parse error: "Hello"
20:50:57 <Pseudonym> ?. ++ read Hello
20:50:58 <lambdabot> compose module failed: IRCRaised Prelude.read: no parse
20:51:04 <Pseudonym> ?. ++ read "Hello"
20:51:05 <lambdabot> Hello Hello
20:51:16 <Pseudonym> ?. ++ id "Hello"
20:51:17 <lambdabot> Hello"Hello"
20:51:37 <Pseudonym> Hrm.
20:51:40 <int-e> @. ++ . read . show moos
20:51:40 <lambdabot> compose module failed: IRCRaised Parse error: "moos\SOH"
20:51:45 * Pseudonym is just typing at random now
20:51:50 <int-e> @. ++ . read . show id moos
20:51:50 <lambdabot> Hello moos
20:52:22 <Pseudonym> ?. state id Hello
20:52:22 <lambdabot> Hello
20:52:26 <Pseudonym> Right.
20:52:35 <dons> ?quit disable state plugin. solve this later with a proper interpreter
20:52:43 <int-e> aww.
20:52:43 <Pseudonym> ?. state . read run "Hello"
20:52:55 <Pseudonym> Damn.
20:53:35 <dons> ?version
20:53:56 <int-e> @karma- dons He took away our new toy :(
20:53:58 <lambdabot> lambdabot 4p79, GHC 6.5 (OpenBSD i386 )
20:54:00 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:54:04 <lambdabot> dons's karma lowered to 52.
20:54:13 <dons> someone has to always go and try to ctcp :P
20:54:25 <Pseudonym> @spell ACTION moos
20:54:26 <lambdabot> \SOHACTION moos\SOH
20:54:28 <Pseudonym> Damn.
20:54:32 <dons> and i'm too busy now to fix it properly. but feel free to submit patches!
20:55:00 <dons> the whole state thing is unnec. if we could just parse expressions in @.
20:55:40 <int-e> @karma- ctcp
20:55:40 <lambdabot> ctcp's karma lowered to -1.
20:55:52 <dons> hmm:    I'm looking for someone with much better Haskell prowess
20:55:53 <dons>    than myself who might be able resurrect Fran under WinHugs
20:55:59 <dons> "   Snr Strategic Planning Engineer
20:55:59 <dons>    ENERGEX
20:55:59 <dons> "
20:56:14 <dons> Pseudonym: huh ^^
20:56:30 <Pseudonym> Sorry?
20:56:35 <Pseudonym> It quoted the SOH
20:58:22 <Pseudonym> @slap lambdabot with a herring
20:58:22 * lambdabot beats up lambdabot with a herring
20:58:32 <Pseudonym> @slap lambdabot with a herring
20:58:32 <lambdabot> why on earth would I slap lambdabot with a herring
20:58:39 <Pseudonym> @slap lambdabot with a herring
20:58:39 <lambdabot> ACTION slaps lambdabot with a herring
20:58:44 <lispy> heh
21:00:11 <Pseudonym> @slap lambdabot with a herring
21:00:11 <lambdabot> why on earth would I slap lambdabot with a herring
21:00:15 <Pseudonym> @slap lambdabot with a herring
21:00:16 <lambdabot> why on earth would I slap lambdabot with a herring
21:00:37 <Pseudonym> @slap lambdabot
21:00:37 <Pseudonym> with a herring
21:00:38 * lambdabot beats up lambdabot
21:01:00 <Pseudonym> @slap lambdabot
21:01:00 <Pseudonym> with a herring
21:01:00 * lambdabot slaps lambdabot
21:01:23 <dons> I think Pseudonym should submit some more @free patches, instead of breaking poor lambdabot. Why do we always hurt the ones we love?
21:01:25 <lispy> @slap Pseudonym with a lispy
21:01:26 * lambdabot slaps Pseudonym with a lispy
21:01:38 <lispy> lol
21:01:49 <Pseudonym> If only we had programs for free.
21:01:53 * Pseudonym sighs
21:01:55 <lispy> @remember dons I think Pseudonym should submit some more @free patches,
21:01:55 <lispy>       instead of breaking poor lambdabot. Why do we always hurt the ones
21:01:56 <lispy>       we love?
21:01:56 <lambdabot> Done.
21:02:00 <lispy> damn
21:02:02 <lispy> that didn't work
21:02:06 <dons> try again
21:02:09 <lispy> dons: is it possible to clean up that quote?
21:02:10 <lispy> okay
21:02:15 <dons> i can always edit the state file later
21:02:16 <Pseudonym> @quote dons
21:02:16 <lambdabot>  all your questions belong to us
21:02:25 <lispy> @remember dons I think Pseudonym should submit some more @free patches, instead of breaking poor lambdabot. Why do we always hurt the ones we love?
21:02:25 <lambdabot> Done.
21:02:31 <jcreigh> Hmm...maybe I don't under stand how @. works...
21:02:34 <jcreigh> @. show . yow
21:02:35 <lambdabot> "Not enough arguments to @.\n"
21:02:42 <dons> jcreigh: its function composition
21:02:49 <dons> @. id yow
21:02:49 <lambdabot> Will this never-ending series of PLEASURABLE EVENTS never cease?
21:02:53 <dons> @. elite yow
21:02:54 <lambdabot> 4n inK-liNg? SuR3 -- +AkE 0N3!! DID joo 8Uy 4nY COM/\/\UnI$7 UniphORM5??
21:03:03 <dons> @. elite id "wow a string"
21:03:03 <lambdabot> "\/\/0w 4 5tRING"
21:03:14 <jcreigh> @. show yow
21:03:15 <lambdabot> "My EARS are GONE!!\n\n"
21:04:52 <int-e> @remember state  ?. ++ . read . show . state ?. ++ . read . show . state
21:05:31 <lambdabot> Done.
21:05:53 <dons> good idea, int-e
21:05:59 <dons> we've had some other good @state programs
21:07:53 <jcreigh> Hmmm...I can't get Haskell to accept this definition of show for "SudokuBoard": http://paste.lisp.org/display/24665
21:09:21 <int-e> wow
21:09:30 <int-e> you mean type instead of data at the top I think :)
21:09:56 <dons> yeah
21:10:32 <int-e> you definitely do not want to define your own data constructor named 'Array' :)
21:11:32 <int-e> data SudokuBoard = SB (Array (Int,Int) SudokuCell)   and   show (SB board) = fol...   makes it work
21:11:42 <int-e> and you can use newtype instead of data there
21:13:24 <int-e> type isn't good after all, because type aliases aren't allowed in instance heads (in Haskell 98) and also array comes with its own Show instance.
21:13:37 <Tela> This might be a really silly question.. But in trying to compile lambdabot, I needed to update FPS. Now, however, it complains that Data.ByteString.Char8 is found in two packages (base and fps-0.8) and thus stops there.
21:14:08 <dons> ah you have ghc 6.5
21:14:11 <int-e> remove fps from the cabal file's dependencies
21:14:24 <dons> yep.
21:14:25 <Tela> Heh. Yep...
21:14:37 <Tela> mmk
21:14:40 <dons> the standalone fps package is only for the 6.4.x series of ghc
21:15:10 * int-e wonders if there's any chance to get fps out of the base package? using the standalone fps won't be possible anymore with 6.6 otherwise, without major trouble.
21:15:40 <dons> but there's no reason to use the standalone fps now
21:15:46 <dons> well, in 30 minutes or so anyway
21:15:51 <dons> since base and fps will be in sync
21:16:11 <dons> otherwise, hopefully this new package stuff should make things work
21:16:18 <dons> though i've not tested that
21:18:17 <jcreigh> int-e: Thanks, that works.
21:18:30 <jcreigh> So data types *always* have to have a constructor?
21:18:40 <int-e> I guess there are conflicting goals here. on the one hand, a large base package makes it easy for users, on the other hand it makes it hard to replace parts of that package ...
21:18:43 <int-e> jcreigh: right
21:18:57 <dons> int-e, the argument for fps being in base is that (already) many core libs use it
21:20:30 <dons> so, maybe that's a reasonable thing. the invconveniences should only be temporary
21:20:51 <jcreigh> The idea being that without a constructor, there's nothing to pattern match on?
21:21:22 <int-e> jcreigh: the idea being that without the constructor it's impossible to derive the proper type
21:24:08 <int-e> SB (array ...) has a different type from just (array ...). If you want a type alias, you can use 'type' but that will prevent you from defining the Show instance you want.
21:27:50 <jcreigh> Ah, right, otherwise there's no way for Haskell to tell the difference...
21:31:22 <jcreigh> Now I just need to make it fast enough to solve puzzles that require backtracking in finite time...
21:31:23 <syntaxfree> is there an advantage in using Hugs over GHCi?
21:32:16 <syntaxfree> unsafePerformIO:: IO a -> a :-O :-O
21:32:20 <int-e> the reasons I've heard are that hugs loads faster and gives somewhat better error messages.
21:32:24 <syntaxfree> OH.
21:32:40 <syntaxfree> that's ... HERESY!
21:32:59 <int-e> which?
21:33:10 <syntaxfree> unsafePerformIO
21:33:14 <syntaxfree> I want to forget it exists.
21:33:21 <int-e> unsafePerformIO is unsafe. There should be some emphasis on that.
21:33:28 <syntaxfree> It's ruining my whole conception of truth and beauty.
21:33:39 <syntaxfree> I might sink into depression because of unsafePerformIO.
21:33:47 <syntaxfree> unsafePerformIO should be banned by the FDA.
21:33:55 <int-e> unsafePerformIO_rememberThisReallyIsUnsafeWeKidYouNot
21:34:12 <syntaxfree> it's ... UGLY.
21:34:31 <monochrom> import Unsafe.ThinkTwice.AreYouSure.ItIsReallyUnsafe(unsafePerformIO)
21:34:44 <monochrom> Oh I have a better idea.
21:35:27 <int-e> it is, however, occasionally useful.
21:35:38 <monochrom> import You.Have.Selected.An.Unsafe.Backdoor.Are.You.Sure.To.Proceed.Yes.No.Cancel(unsafePerformIO)
21:35:49 <syntaxfree> I feel my world is collapsing.
21:35:49 <int-e> you just shouldn't use it for the obvious thing, namely, making IO actions pure.
21:35:54 <JohnMeacham> there is nothing in particular wrong with it other than it shifts a lot of the burden of proof of correctness onto the user rather the language.
21:35:57 <syntaxfree> IO a->a shouldn't exist.
21:36:00 <syntaxfree> No! No! No!
21:36:04 <SamB> how about import Foreign (unsafePerformIO)
21:36:04 <flux__> the compiler should simply prompt the user each time it compiles code involving unsafePerformIO.
21:36:18 <SamB> flux__: nah...
21:36:20 <flux__> maybe something like the web sites use..
21:36:21 <int-e> syntaxfree: Haskell isn't really pure. So?
21:36:22 <SamB> what about libraries?
21:36:32 <JohnMeacham> oh course, using it when you don't need to is just wrong.
21:36:32 <syntaxfree> NOOOOOOOOOOOOOooooooooooo!
21:36:45 <dons> ?free unsafePerformIO :: IO a -> a
21:36:45 <lambdabot> f . unsafePerformIO = unsafePerformIO . $map_IO f
21:36:46 <monochrom> Relax!
21:37:07 <flux__> anyway, how do you implement something like lazy reading of file without unsafePerformIO?
21:37:11 <int-e> that seems to be true, dons :)
21:37:15 <SamB> syntaxfree: so we support the ability to define libraries that are usable and yet use the IO monad behind the scenes
21:37:22 <dons> flux__: with unsafeInterleaveIO
21:37:23 <JohnMeacham> it isn't used because users don't like burdens of proof. that is why they use haskell in the first place.
21:37:31 <SamB> also, the ability to call C functions that need complicated marshalling
21:37:37 <flux__> dons, well that's just unsafePerformIO in disguise?-)
21:37:44 <dons> not quite
21:37:45 <syntaxfree> NO! NO! NO!
21:37:55 <monochrom> Is this an opera?
21:37:56 * syntaxfree curls into a fetal position
21:37:57 <Lemmih> dons: How do you implement unsafeInterleaveIO without unsafePerformIO?
21:38:01 <dons> its not as unsafe
21:38:04 <int-e> syntaxfree: maybe you should look for a more academic language?
21:38:07 <SamB> flux__: you can't unsafeInterleaveIO from outside the IO monad
21:38:08 * int-e grins
21:38:22 <syntaxfree> I though the world was beautiful :'(
21:38:25 <flux__> but, whathesaid
21:38:27 <SamB> syntaxfree: it is
21:38:28 <dons> Lemmih: well, you still have to step inside the monad either way
21:38:37 <SamB> that is why we use the word "unsafe" for things like this
21:38:40 <dons> unsafeInterleaveIO :: IO a -> IO a
21:38:40 <dons> unsafeInterleaveIO (IO m)
21:38:40 <dons>   = IO ( \ s -> let
21:38:40 <dons>            r = case m s of (# _, res #) -> res
21:38:40 <dons>         in
21:38:42 <dons>         (# s, r #))
21:38:48 <dons> look ma, no unsafePerformIO :)
21:38:50 <monochrom> What's wrong with unsafePerformIO?
21:38:52 <int-e> syntaxfree: you are lucky, you have libraries that do the unsafePerformIO for you.
21:38:58 <dons> monochrom: you can create segfaults
21:39:04 <syntaxfree> int-e: huh?
21:39:07 <SamB> dons: did you just translate that from Core?
21:39:08 <syntaxfree> Which ones? :'(
21:39:11 <int-e> syntaxfree: and a kind advice to you, never look at GHC.IO and related libraries :)
21:39:11 <monochrom> segfaults are beautiful :)
21:39:18 <dons> SamB, no , that's the actual definitions
21:39:23 <SamB> o rly?
21:39:23 <madpickle> ya rly!
21:39:39 <SamB> fast answer!
21:39:48 * syntaxfree screams like Ozzy in "Black Sabbath", the song.
21:39:53 <SamB> thats some split-second reflexes!
21:40:10 <int-e> dons: that's nasty though, it's throwing away a world!
21:40:10 <monochrom> this is an opera
21:40:28 <int-e> dons: maybe that world would have evolved intelligent life otherwise, sniff.
21:40:35 <dons> heh
21:40:54 <dons> not as bad as :
21:40:55 <dons> unsafePerformIO :: IO a -> a
21:40:56 <dons> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
21:41:00 <SamB> int-e: its not a real world!
21:41:11 <dons> at least you get a world back in unsafeInterleaveIO
21:41:11 <syntaxfree> STOP! :'(
21:41:15 <monochrom> <SamB> Oh really?  <madpickle> Ya really! <syntaxfree> No no no no no!   <--- perfect for Mozartian opera music :)
21:41:33 <syntaxfree> KILL unsafePerformIO BEFORE IT KILLS ALL THAT IS BEAUTIFUL AND GOOD ABOUT THE WORLD!
21:41:36 <SamB> monochrom: why are you misquoting me?
21:41:47 <monochrom> To fit the music :)
21:41:47 <SamB> I said, and I quote, "o rly"
21:41:59 <SamB> syntaxfree: ah
21:42:02 <int-e> syntaxfree: the irony is, all that stuff allows you to do IO in purely functional code ;)
21:42:11 <monochrom> "really" is Italian for "rly" ok? :)
21:42:18 <SamB> syntaxfree: don't you like your packed strings?
21:42:26 <SamB> monochrom: I thought it was english
21:42:28 <syntaxfree> packed strings?
21:42:29 <int-e> syntaxfree: granted the 'pure' may be a bit distorted in that context.
21:42:37 <SamB> syntaxfree: bytestrings, whatever
21:42:43 * syntaxfree uses no damn ByteStrings, he uses Lists of Chars as God intended.
21:42:52 <int-e> diffarrays?
21:42:53 <SamB> also it is useful for Debug.Trace
21:42:53 <monochrom> Pardon my French.
21:43:04 <int-e> what about the st monad?
21:43:17 <SamB> God has a lot more RAM than I do. and a better frontside bus...
21:43:21 <int-e> in GHC that's IO in disguise :)
21:43:29 <SamB> or backside or whatever side the RAM is on
21:43:32 <int-e> and you have runST ...
21:43:34 <SamB> int-e: shush
21:43:42 <SamB> int-e: it is not really IO
21:43:48 <newsham> god doesnt use a "frontside bus"
21:43:54 <SamB> it just has the same shape in memory
21:43:57 <newsham> no northbridge or southbridge either
21:44:07 <SamB> well yah
21:44:10 <SamB> cloud trams and all
21:44:21 <newsham> ia32 is of the devil.
21:44:33 <syntaxfree> we should have Haskell Machines by now.
21:44:45 <int-e> oh, we have unsafeInterleaveST, too.
21:44:47 <monochrom> Can it do I/O? :)
21:44:48 <newsham> does ocaml support partial application like hsakell does?
21:44:53 * int-e dances merrily
21:45:02 <dons> newsham: surely it does?
21:45:06 <monochrom> Yes, it does.
21:45:23 <syntaxfree> Closures in Lisp are partial application of sorts too, right?
21:45:44 <dons> you implement partial application with closures.
21:45:44 <newsham> nifty, so if I get fed up (or bogged down) with monads, I can take refuge in ocaml and get most of the features?
21:45:45 <sieni> well whatever you want to call them
21:46:02 <sieni> it's just spanking the lambda
21:46:10 <newsham> sf: yah, i can implement partial application in python, too, but the syntax makes it a pain to use
21:46:12 <jcreigh> newsham: Hmm...are you saying God is a RISC guy, then? Or just not ia32?
21:46:27 <monochrom> Or if you get fed up with the absence of the do notation, you can take refuge in haskell and get more features.
21:46:29 <newsham> jcreigh: i'm just saying that IA32 is unholy.
21:46:38 * syntaxfree do notation considered harmful
21:46:45 <syntaxfree> just say no to do!
21:46:46 <Tela> it's pretty trivial to implement some degree of partial application in lisp with closures and macros
21:46:52 <sieni> like (lambda x (apply + 17 x))
21:46:54 <dons> > let f x y z = x ++ y ++ z in let g = f "haskell " in let h = g "is " in h "fun!"
21:46:56 <lambdabot>  "haskell is fun!"
21:47:11 <newsham> tela: yah, but lisp is ho hum.. i'd rather python given lisp v. python.
21:47:21 <newsham> even though macros are a nice bonus
21:47:22 <dons> > let f x y z = x ++ y ++ z in let g = f "haskell " in let h = g "is " in h "fun!" ++ " and " ++ h "coo!"
21:47:23 <lambdabot>  "haskell is fun! and haskell is coo!"
21:47:32 <monochrom> what is coo?
21:47:37 <dons> a typo
21:47:38 <sieni> newsham: but python sucks
21:47:42 <syntaxfree> @google coo
21:47:46 <newsham> sieni: if you say so.
21:47:46 <lambdabot> http://www.investopedia.com/terms/c/coo.asp
21:47:46 <lambdabot> Title: Chief Operating Officer - COO
21:47:57 <dons> haskell is COO
21:48:04 <syntaxfree> Python's chieftain Guido van Rossum is very against FP
21:48:07 <sieni> it has crappy syntax and doesn't give anything in exchange
21:48:10 <Tela> newsham: yeah.. I love macros, but there's so much to be frustrated at in lisp
21:48:12 <syntaxfree> @google van rossum lambda python haskell
21:48:15 <lambdabot> http://www.artima.com/weblogs/viewpost.jsp?thread=4550
21:48:15 <lambdabot> Title: News from Python UK
21:48:23 <sieni> and naturally all people who oppose functional programming are idiots
21:48:27 <newsham> syntaxfree: yah, but I can still use generators to do lazy functional programming wether he likes it or no.
21:48:32 <int-e> hmm. stToIO (ST m) = IO m ... close enough :)
21:48:46 <sieni> maybe I need some coffee before I make more statements
21:48:48 <newsham> for example:  http://www.thenewsh.com/~newsham/x/prog/srcs7.py
21:49:01 <syntaxfree> "Simon is an incredibly lively and entertaining speaker; he puts real drama in his presentations. I wish I could speak like that! Like Python, Haskell uses indentation for blocks; after that, the similarities stop. It is a strongly typed pure functional language, where just about everything is written as recursive functions, because the language has no looping construct. Because of this it will probably always remain a language of mostly academic int
21:49:18 <dons> heh
21:49:39 <syntaxfree> Guido van Rossum seems to forget *induction* is a natural reasoning mode, and recursion is pretty much co-induction.
21:50:07 <int-e> a language of mostly academic in...?
21:50:27 <monochrom> GvR is very narrow-minded.
21:50:28 <Tela> I mentioned FP to my CS teacher. He nearly had a heart attack and then tried to exorcise me. :)
21:50:40 <syntaxfree> "...mostly academic interest: loops may be theoretically inferior to recursion, but I have no doubt that the human brain has special reasoning abilities for loops, and many real-world problems are most naturally expressed using loops rather than recursion. I'd say that a loop is a higher-level concept than recursion; recursion is more powerful, but also more low-level, like assembly language."
21:50:44 <jcreigh> Tela: Really? Why?
21:50:49 <syntaxfree> I have a buddy who is in CS grad school.
21:50:53 <Tela> Bad experience with Scheme from what I gathered.
21:50:54 <syntaxfree> He's a Prolog Nazi.
21:51:05 <sieni> python, like php, is just training wheels without the bike
21:51:22 <dons> ?remember sieni python, like php, is just training wheels without the bike
21:51:22 <newsham> thats a low blow, sieni.  comparing python with php? :)
21:51:23 <lambdabot> Done.
21:51:30 <dons> yeah, pretty low :)
21:51:33 <syntaxfree> Python has higher-order functions, PHP doesn't. God knows I've needed that.
21:51:37 <dons> ?karma+ sieni
21:51:37 <lambdabot> sieni's karma raised to 2.
21:51:44 <syntaxfree> Guido wants to remove most FP constructs from the next Python.
21:51:55 <syntaxfree> How are you gonna write functions that return functions without a lambda keyword?
21:52:06 <int-e> hmm, loops. if I want loops it usually ends up being a map, fold or filter.
21:52:07 <dons> unlambda seems to manage
21:52:11 <Tela> by using unsafeLambda ;)
21:52:18 <newsham> syntax: what?  lambda?  so?  lambda in python is extraneous and very limited anyway.     filter()?  map()?  who cares, write your own.
21:52:28 <newsham> I dont see what you rpoint is.
21:52:48 <newsham> syntax: nested functions give you lambdas (with names).
21:52:55 <syntaxfree> functions that return functions.
21:52:58 <newsham> see url I pasted for example.
21:53:10 <int-e> syntaxfree: he wants that? oh my and I was liking python ...
21:53:11 <syntaxfree> That's the feature I miss the most in languages without a lambda of sorts.
21:53:19 <newsham> the pipeline() function returns a function created by reducing the compose function.
21:53:36 <monochrom> Many burger-flipping problems are most naturally expressed using loops than recursion, that's for sure.
21:53:55 <syntaxfree> I remember when I used a lot of Matlab.
21:53:58 <newsham> I dont understand the complaints about lambda....
21:54:01 <syntaxfree> I learned to express loops as matrix multiplications.
21:54:06 <int-e> instead generators are evolving into coroutines.
21:54:11 <dons> foreach xs a = mapM_ a xs ; foreach [1..10] (print 'x')
21:54:15 <dons> yay for loops
21:54:20 <newsham> inte: yah, but a very limited and asymetric form of coroutines :(
21:54:20 <syntaxfree> @google van rossum lambda remove python 2000
21:54:24 <lambdabot> http://www.amk.ca/python/writing/ipc7
21:54:24 <lambdabot> Title: Conference Report: Seventh Python Conference
21:54:38 <flux__> syntaxfree, even php sort of has higher order functions, but they basically work via eval :-)
21:54:55 <newsham> flux: you're just being silly.
21:54:59 <syntaxfree> flux__: well, passing functions as arguments, yes. returning functions from functions, no.
21:55:09 <Tela> syntaxfree: Hm. I'll have to learn that trick sometime. I'm about to jump into a bunch of Matlab
21:55:09 <syntaxfree> I need functions that return functions.
21:55:12 <syntaxfree> I can't do work without that.
21:55:24 <flux__> I've used that technique ;)
21:55:32 <syntaxfree> Tela: use GNU R instead. Way nicer.
21:55:36 <monochrom> You can return a string that can be eval'ed later... :)
21:55:37 <flux__> create_function (?) creates new functions and returns the name
21:55:47 <Tela> syntaxfree: It's a class. Sadly I have no choice :S
21:55:54 <int-e> dons: yes, I think we agreed some time ago that  flip mapM_  should have its own name.
21:56:04 <jcreigh> flux__: PHP has anonymous functions, *not* closures.
21:56:08 <newsham> flapM_ ?
21:56:13 <dons> int-e, yes. I agree
21:56:13 <flux__> it input is a string.. so you need to embed local variables into it
21:56:14 <syntaxfree> int-e: what about flipMapM_?
21:56:15 <int-e> forM probably
21:56:20 <dons> forM is good
21:56:28 <int-e> syntaxfree: flipflapflop ... ah no, that was INTERCAL
21:56:31 <dons> also, we don't have repeatM/foreverM
21:56:34 <dons> which is another one
21:56:39 <monochrom> I like forM too
21:56:40 <flux__> jcreigh, true, but closures can be emulated with great pain by generating the code dynamically :)
21:56:46 <int-e> unfoldM
21:56:55 <flux__> of course, such functions are not candidates for garbage collection
21:57:14 <newsham> flux: sure, and you could write an interpretter since its turing complete.. but surely you two are getting off point on this...
21:57:22 <dons> int-e, you could just about get forM into ghc 6.6 if you submitted a patch today or tomorrow
21:57:25 <flux__> newsham, well, it's still less painful than in, say, C
21:57:31 <dons> to Control.Monad
21:57:31 <syntaxfree> "Sometimes I've been too quick in accepting contributions, and later realized that it was a mistake. One example would be some of the functional programming features, such as lambda functions. lambda is a keyword that lets you create a small anonymous function; built-in functions such as map, filter, and reduce run a function over a sequence type, such as a list."
21:57:40 <dons> syntaxfree: stop quoting large chunks
21:57:43 <syntaxfree> ok!
21:57:51 <jcreigh> flux__: Which doesn't change the fact that PHP sucks in so many ways.
21:57:59 <flux__> obviously doesn't
21:58:03 <int-e> syntaxfree: provide URLs :)
21:58:18 <newsham> flux: nah, not so hard in C.  define environment object, define variable accessors, define function objects, build closures, tada, done.
21:58:26 <syntaxfree> http://www.artima.com/weblogs/viewpost.jsp?thread=98196
21:58:29 <syntaxfree> that's the key one.
21:58:31 <lambdabot> Title: The fate of reduce() in Python 3000
21:58:41 <syntaxfree> Where GVR talks about getting rid of FP features in Python.
21:58:44 <flux__> newsham, yeah, but that involves writing code everywhere in addition the place you're actually using it
21:58:49 <newsham> oh no!  remove reduce?!@  however will we replace it with our own version?
21:59:00 <newsham> I dont really like python reduce anyway, since its left-fold only.
21:59:39 <newsham> reduce, filter and map are all replaceable.. who cares if guido takes them out of the std lib.
21:59:49 <syntaxfree> he wants to remove lambda.
22:00:00 <int-e> ow, he has trouble understanding fold?
22:00:10 <newsham> so what?  the lambda expression isnt even a statement!  nested-functions make better lambdas in python anyway
22:00:11 <monochrom> Let him.  Python is replaceable anyway.  We can use Haskell.
22:00:31 <newsham> syntax: you're only complaining because its called "lambda", its not even the real lambda.. nested functions are.
22:00:56 <newsham> lambda in python is completely unnecessary
22:01:16 * syntaxfree 's been  using Haskell even for small shell scripts.
22:01:24 <flux__> newsham, actually sort-of-usable currying is writeable to c
22:01:28 <newsham> thats cool, haskell is great..
22:02:32 <syntaxfree> GvR often seems to imply that all relevant language decisions are a matter of syntax.
22:02:49 <syntaxfree> It seems that his idea of "features" is syntactic sugar.
22:02:53 <newsham> nested functions are equivalent to lambdas with the caveat that you have to provide a name (inconvenient, at best,  added documentary value at times)
22:03:10 <dons> understanding programming language theory isn't a requirement for writing a new language, obviously
22:03:12 <int-e> lambda is the only thing of these that's not easily rewritten in an own module
22:03:12 <newsham> sf: why the obsession with gvr?
22:03:23 * int-e shrugs
22:03:34 <syntaxfree> because GvR is evil, and therefore Python is evil.
22:03:43 <dons> and so our industry struggles on with poor tools
22:03:46 <monochrom> My opinion is if you write like "z := f(a,g(b,c))" instead of "begin var tmp; g(tmp,b,c); f(z,a,tmp); end" you are already doing very basic functional programming.  If you want to remove FP you must eventually confine the programmer to the latter.  Now talk about assembly programming.
22:04:08 <newsham> int-e: and whats wrong with:    def dot(f, g) : def comp(x) : return f(g(x))    return dot   ?
22:04:11 * johnnowak giggles
22:04:12 <syntaxfree> the less power GvR has out there, the better the world is.
22:04:12 <int-e> python is nice. 2.4 at least. some new 2.5 features look a bit scary.
22:04:20 <newsham> how is that so much worse than   def dot(f,g) : return lambda x : f(g(x)) ?
22:04:39 <int-e> newsham: aside from the fact that it's unreadable ...
22:04:44 <newsham> (err.. should be "return comp")
22:04:59 <newsham> inte: wait, are you saying that you seriously cant read that?
22:05:11 <newsham> you're a big boy...
22:05:12 <int-e> newsham: I was going to add, and you even managed to mess it up in a way that lambda wouldn't have let you.
22:05:50 <newsham> int-e: granted, but thats because of linewrap.  i use these things all th etime, I can assure you I dont get confused that easily.
22:05:51 <int-e> newsham: no, I just dislike having to think of new identifiers for things that really don't need a name.
22:06:09 <newsham> int-e: right.. I concede that is the one and only downside (and sometimes a documentary bonus)
22:06:15 <int-e> newsham: and lambda does well for that.
22:06:24 <monochrom> You can always use meaningless names.
22:06:26 <int-e> newsham: so why remove it?
22:06:31 <syntaxfree> GvR seems to think FP means "recursion instead of loops".
22:06:47 <syntaxfree> And he's cock-sure that the human brain is wired  to think in loops.
22:06:48 <newsham> int-e: *shrug* most people dont use it, and its not a full lambda anyway.
22:06:54 <sieni> GvR seems to smoke crack for breakfast.
22:06:57 <newsham> sf: you're being ridiculous.
22:07:01 <int-e> newsham: it's really not so obscure.
22:07:06 <monochrom> GvR is a burger flipper.
22:07:20 <int-e> newsham: I don't need it, that's true, but I've used it.
22:07:23 <newsham> I must be stupid for arguing, so much misinformation and irrelevant snipes.
22:07:38 <monochrom> heehee
22:08:10 <syntaxfree> http://lambda-the-ultimate.org/classic/message5618.html
22:08:12 <lambdabot> Title: LtU Classic Archives
22:08:17 <int-e> irc.py:        self.output_hist = filter(lambda x: x>=now, self.output_hist)
22:08:29 <monochrom> But tell me, besides those working in MacDonald's at legally minimum hourly wage, who else would really believe that the world is about loops?
22:08:32 <int-e> ok, he wants list comprehension for that
22:08:40 <syntaxfree> Paraphrase: GvR says Python is more productive because there's less typing to be done.
22:08:49 <newsham> self.output_hist = [x for x in self.output_hist if x >= now]
22:08:49 * int-e shrugs
22:09:05 <int-e> actually I find the filter more readable ;)
22:09:10 * johnnowak never realized guido was nuts until today
22:09:22 <newsham> int-e: awesome.   def filter(p, l) : return [x for x in l if p]
22:09:24 <syntaxfree> Guido seems to understand CS even less than I do.
22:09:34 <int-e> newsham: ok, now the lambda?
22:09:47 <newsham> sf: not really,  computer science is a social science.  I guess you missed that lesson.
22:09:48 <int-e> newsham: but we're running in circles.
22:09:48 <syntaxfree> Python list comprehensions are unreadable. You need to memorize the bizarre syntax.
22:10:10 * syntaxfree is an economist. I know the "social science" routine. 
22:10:23 <newsham> sf: <lang> <feature> are unreadable.  you need to memorize the bizarre <api|syntax|semantics>.
22:10:25 <int-e> s/for/|/ s/in/<-/ s/if/,/
22:11:40 <syntaxfree> there's no visual distinction.
22:11:56 <int-e> I can't say lambda is essential in python, neither is filter ... but I don't buy that it's obscure and unreadable. I'd rather see 'this adds 10% complexity to our parser and compiler' as a reason.
22:11:56 <syntaxfree> [x | x<-l, p]
22:12:06 <syntaxfree> [x for x in l if p]. Confusing!
22:12:26 <newsham> syntax: get back to me when you're arguing about semantic features and not whining about choices of characters in the syntax.
22:13:04 <int-e> but maybe I'm spoiled by Haskell which is so rich on - mostly unecessary - syntactic sugar.
22:13:05 <monochrom> I think syntax does matter.  Otherwise there wouldn't be a big fuss about choosing variable names.
22:13:19 <newsham> btw, I translated the tiny haskell sudoku solver into python:  http://www.thenewsh.com/~newsham/x/machine/sud.py     it is a bit uglier than the haskell version, but didn't have to jump through any hoops to get the semantics.
22:13:31 <syntaxfree> Syntax does matter, but not nearly as much as GvR seems to think.
22:13:39 <newsham> int-e: yah, haskell code can look very pretty and terse, but also hard to read for the uninitiated.
22:14:05 <dons> newsham: you've seen the sudoku gallery on haskell.org, btw?
22:14:16 <dons> there's even one by SPJ
22:14:17 <syntaxfree> http://www.nabble.com/Python's-lambda-t1122796.html
22:14:18 <lambdabot> Title: Nabble - Python's lambda
22:14:23 <newsham> i did, but I liked the 707 byte solution better than the ones on the wiki
22:14:28 <dons> :)
22:14:30 <int-e> I'll have to admit that my python code contains fewer lambdas then I remembered
22:14:47 <newsham> http://web.math.unifi.it/users/maggesi/haskell_sudoku_solver.html
22:14:51 <monochrom> English is hard to read for the uninitiated, i.e., babies.
22:15:12 <newsham> monochrom: and so are python list-comprehension and generator-comprehensions apparently ;-)
22:15:14 <sieni> syntaxfree: for you apparently lack of syntax matters the most, at least if one looks at your nick
22:15:22 <syntaxfree> ;)
22:15:33 <syntaxfree> It comes from a Sonic Youth tune. "The Ineffable Me"
22:15:42 <syntaxfree> @google the ineffable me sonic youth lyrics
22:15:47 <lambdabot> http://www.lyricstime.com/sonic-youth-the-ineffable-me-lyrics.html
22:15:47 <lambdabot> Title: Sonic Youth - The Ineffable Me Lyrics
22:16:01 <int-e> one reason for that is, of course, that python's lambda is very restricted - it only works for expressions and most interesting language constructs are statements.
22:16:16 <syntaxfree> but it's a sideways nod to Scheme. I only got in the right track about programming with Scheme.
22:16:24 <int-e> for example lambda x: print x  isn't allowed.
22:16:52 <syntaxfree> I've been hacking up stuff on and off since I was like 8, and I never really *got* programming until an elective course taught me Scheme.
22:16:59 <newsham> dons: most of the haskell.org versions are trying to be fancy and sometimes efficient.  the 707 byte version is neither, but its small...
22:17:24 <Pseudonym> Scheme can cure you of a lot of bad programming habits.  Especially if those bad habits were obtained while using Lisp.
22:17:51 <syntaxfree> I was 8, and I had access to two programming languages.
22:17:57 <syntaxfree> ZX Spectrum BASIC, and GW-Basic.
22:18:03 * int-e couldn't believe that common lisp is so big but has no standard FFI. all the world is Lisp?
22:18:40 <Pseudonym> Actually more than one world is Lisp, if you see the size of ClTL.
22:18:41 <syntaxfree> This is 1989 I'm talking about. No internet access. No books beyond silly 1970s game listing books. For the wrong versions of Basic.
22:18:50 <Pseudonym> CLtL, rather.
22:19:01 <monochrom> I think Haskell is pretty learnable for the uninitiated.  A highschool kid, having had some math but otherwise uninitiated, would be comfortable to find that "x=x+1" causes problems, as expected.
22:19:05 <newsham> there were too many of us. We had access to too much money, too much equipment. And little by little we went insane
22:19:17 <Pseudonym> I was lucky.  I had Creative Computing and Les Bell-era APC.
22:19:34 <newsham> mono: you could teach functional programming to beginners in haskell as long as you avoided monads.
22:19:39 <syntaxfree> int-e: Lisp is one of the oldest languages out there. When you read about Symbolics you get the feel of all-powerfulness Lisp people had.
22:19:42 <monochrom> When you see most people having difficulties learning Haskell, it is because they are initiated, i.e., initiated the other way.
22:19:48 <syntaxfree> C was a hack, a virus. They had the right way.
22:20:17 <syntaxfree> Yeah. Scheme basically shut out all my bad habits.
22:20:32 <newsham> "two dozen short lessons" does that well.  you could take that directly and teach high school kids
22:20:37 <syntaxfree> I arrived to Haskell as a blank, purely-functional sheet.
22:21:01 <monochrom> I don't believe monads pose a problem.
22:21:01 <int-e> syntaxfree: well, it made me give up on Lisp. (I'm beginning to think that it's not really that much of a loss anymore.)
22:21:26 <newsham> heh, awesome,  so great to hear such sweeping generalizations from someone who claims to be largely ignorant of other languages, sf. :)
22:21:51 * syntaxfree is not saying C is a hack, I'm saying that the Lisp people believed C to be a hack.
22:21:56 <newsham> build ghc on a pdp-11.  then build an OS out of it.
22:23:05 <newsham> (also welcome to use lisp if you prefer :)
22:24:52 <monochrom> These people have great nicks
22:25:22 <syntaxfree> they did Lisp Machines.
22:25:47 <newsham> http://www.unlambda.com/cadr/index.html
22:25:49 <lambdabot> Title: Retrocomputing - MIT CADR Lisp Machines
22:26:33 <int-e> oh yes. CAR and CDR. contents of address register, contents of data register ...
22:26:36 <int-e> and the names stuck
22:30:23 <syntaxfree> "I think there are armies of boilerplaters for every one person curious about Haskell. Maybe I'm wrong. "
22:30:27 <syntaxfree> discuss.
22:30:44 <Pseudonym> You're wrong.
22:30:50 <Pseudonym> Perhaps not about this, but you're wrong in general.
22:31:00 <monochrom> Haskell is somewhat terse (not as much as APL).  I think it's a virtue, and it's natural to me to be somewhat terse.  I am saying this not because I favour Haskell; I already preferred somewhat terse when I knew only BASIC, Pascal, and C.
22:31:37 <monochrom> One reason I preferred C to Pascal was that it was { } vs begin end.
22:31:55 <dons> there's an important distinction difference between terse and obfuscated
22:31:59 <int-e> C has less typing and better visual clues.
22:32:36 <int-e> @dict
22:32:36 <lambdabot> Supported dictionary-lookup commands:
22:32:37 <lambdabot>  @all-dicts @devils @easton @elements @foldoc @gazetteer @hitchcock @jargon @lojban @vera @web1913 @wn @world02
22:32:37 <lambdabot> Use "@dict-help [cmd...]" for more.
22:32:42 <monochrom> But you will never think of terseness negatively again after you have seen COBOL.  "MULTIPLY X BY Y TO Z"  That was when I decided I would rather have it terse.
22:34:53 <monochrom> It is not natural for me to write like "multiply x by y to z" all day long.  I don't think it's natural to any CS student either.  You enter CS precisely because you don't what to write in English; you want to write in a better language and notation.
22:35:43 <syntaxfree> COBOL looks a lot like AppleScript
22:36:15 <syntaxfree> tell Safari to Save
22:36:16 <Korollary> Don't bash cobol!
22:36:35 <monochrom> Heh
22:36:42 <syntaxfree> The latest rage in COBOL is something called "Aspect-oriented programming"
22:36:49 <Korollary> http://www.cs.vu.nl/~ralf/Cobol/
22:36:50 <lambdabot> Title: COBOL Research at the Free University in Amsterdam
22:37:11 <int-e> syntaxfree: hmm, haskell has pretty good abstractions really, you can put a lot in libraries ... would you say 'import' declarations qualify as boilerplate code?
22:37:21 * Pseudonym is looking throught the schematics of the CADR machine
22:37:31 <monochrom> I'm not bashing cobol.  I'm saying, some people talk of terseness negatively, and I want to give them a reality check by pointing out what alternative you have if you remove terseness.
22:37:31 <Pseudonym> Sadly, it's giving me ideas.
22:37:51 <syntaxfree> int-e I was quoting from the previously posted URL.
22:38:03 <Korollary> monochrom: I know. I was just messing with you.
22:38:09 <dons> SamB, we were missing an {-# INLINE [1] pack #-}
22:38:15 <dons> on packAddress/pack rule in fps
22:38:28 <dons> now when I compile hmp3, I get something like 100 hits for that rule :)
22:38:32 <Pseudonym> Though it's interesting looking at how they implemented virtual memory back then.
22:38:44 <syntaxfree> GvR on Ruby: "That was fun as an April Fool's joke."
22:39:24 <monochrom> /ignore GvR
22:39:25 <monochrom> :)
22:39:34 <Korollary> Google employees suck.
22:39:50 <monochrom> How come?  I know a few Google employees and they're great.
22:39:59 <Korollary> I bet my search history has been made public right now.
22:40:07 <dons> heh
22:40:37 <newsham> know people who care what you search for?
22:40:41 <Korollary> monochrom: I have former coworkers who are with google now. I am messing with you, dude!
22:40:47 <newsham> i bet you're not all that important ;-)
22:40:48 <dons> ?remember Korollary Google employees suck. [some time later] I bet my search history has been made public right now
22:40:48 <lambdabot> Done.
22:41:02 <int-e> Oh, "Pythonicity".
22:41:30 <Korollary> Haskellence sounds better.
22:41:33 <monochrom> You are a very knowledgeable messer indeed.
22:41:46 <newsham> used to work for a company called "sonicity"
22:41:58 <monochrom> Perloration
22:42:46 <syntaxfree> http://developers.slashdot.org/article.pl?sid=04/12/08/1944233&tid=156
22:42:49 <lambdabot> Title: Slashdot | Introducing The Heron Programming Language
22:42:52 <monochrom> Hey, Corporation doesn't sound bad!
22:43:06 <monochrom> Is Heron any good?
22:43:26 <Korollary> I think the guy who created it is working on something else right now.
22:43:47 <newsham> Heroin she said was the best I've had...
22:43:48 <Pseudonym> Functitude.
22:43:51 <monochrom> Does it have something to do with Heron's formula? :)
22:43:52 <syntaxfree> "Heron is influenced by the C++, Java and Pascal programming languages. It has built-in support for object-oriented programming, generic programming, metaprogramming, aspect-oriented programming and design by contract techniques. "
22:44:21 <newsham> highly addictive programming language you'd wish you never picked up?
22:44:47 <monochrom> Something tells me it can't be good mixing all those things together.
22:45:24 <syntaxfree> post by the author of that language: http://lambda-the-ultimate.org/node/412
22:45:25 <lambdabot> Title: Definition of Type | Lambda the Ultimate
22:46:08 <Pseudonym> Funktitude.
22:46:40 <newsham> funkopolis
22:48:13 <syntaxfree> there's a bunch of new C++-ish languages it seems.
22:48:33 <newsham> yah, whats the deal with Mars?  kinda looks C and java-ish.
22:48:50 <syntaxfree> http://scala.epfl.ch/
22:48:52 <lambdabot> Title: The Scala Programming Language
22:49:17 <syntaxfree> http://www.aldor.org/
22:49:19 <lambdabot> Title: The Aldor programming language
22:50:40 <newsham> cbrink: none yet, see python 2.5
22:50:49 <newsham> misfire :(
22:51:59 * Patterner waits for Functional FORTRAN
22:57:53 <syntaxfree> http://en.wikipedia.org/wiki/Fibonacci_number_program
23:01:45 <Pseudonym> I like the categories that that page is in.
23:02:48 <Patterner> Fibonacci => Rabbits => General Pornography (which explains the NASA incident...)
23:04:48 <syntaxfree> http://en.wikipedia.org/wiki/Beatnik_programming_language
23:04:57 <Korollary> Isn't wikipedia the ultimate human knowledge trashcan anyways?
23:05:06 <Pseudonym> Man, that's just a spinout.
23:05:12 <Pseudonym> Freaky!
23:05:55 <syntaxfree> http://en.wikipedia.org/wiki/Chef_programming_language
23:06:44 <dons> ?remember Korollary Isn't wikipedia the ultimate human knowledge trashcan?
23:06:46 <lambdabot> Done.
23:06:51 <int-e> what's next? Piet? Malbolge?
23:07:15 <syntaxfree> Malbolge is the best.
23:07:17 <int-e> or a classic esoteric language like INTERCAL, befunge or brainfuck?
23:07:25 <int-e> malbolge isn't turing complete.
23:07:31 <syntaxfree> I'm picking out ha-ha languages.
23:10:21 <Patterner> http://en.wikipedia.org/wiki/Ha_ha :)
23:10:29 <syntaxfree> http://en.wikipedia.org/wiki/PATH_programming_language
23:11:07 <syntaxfree> Hello world in Path is beautiful: http://en.wikipedia.org/wiki/Hello_world_program_in_esoteric_languages#PATH
23:11:39 <dons> hello world can never be beautiful, it does IO ;)
23:11:51 <Patterner> Ook!
23:12:06 <syntaxfree> dons: look at the Path version.
23:12:26 <Pseudonym> Path is a very beautiful language.
23:12:31 <Korollary> A bit verbose
23:12:51 <Korollary> I'd need an enterprise strength IDE for that
23:12:59 <dons> hehe
23:13:06 <syntaxfree> http://en.wikipedia.org/wiki/Hello_world_program_in_esoteric_languages#TRANSCRIPT
23:13:28 <syntaxfree> "Whenever is an esoteric programming language by David Morgan-Mar. Whenever has no sense of urgency. The program code is like a to-do list - the interpreter can execute the lines whenever and in whatever order it chooses to. However, the lines may contain a clause that specifies that it cannot be executed until certain conditions apply. There are no control flow structures, variables or data structures."
23:13:41 <syntaxfree> Now THERE's a lazy language.
23:13:51 <Korollary> I wonder if it's possible to disallow printing out "Hello, world." using dependent types in a language.
23:14:23 <dons> hmm?
23:14:28 <int-e> HQ9+ is the stupidest of them all
23:15:03 <Korollary> I mean, putStrLn :: String -> IO () where String cannot include "Hello, world."
23:15:43 <syntaxfree> http://shakespearelang.sourceforge.net/report/shakespeare/shakespeare.html#sec:hello
23:15:44 <lambdabot> Title: The Shakespeare Programming Language
23:15:55 <dons> Korollary: ah yes, certainly
23:16:10 <dons> you could do it in Haskell
23:16:25 <dons> (using a type level Char, Oleg-style)
23:16:46 <Pseudonym> Actually, Whenever reminds me a bit of dataflow languages.
23:17:01 <Korollary> dons: How do you prevent putChar 'H' >> ...
23:17:17 <dons> oh, that's harder
23:17:48 <Korollary> I am glad this is a rather useless feature. Freedom of speech and all...
23:17:53 <dons> you can certainly prevent the string "hello world" ever being passed to some function 'f'
23:18:02 <dons> but over a monad. hmm. tricksy!
23:18:24 <dons> the monad bind would have to check the state of the world
23:18:30 <dons> i.e. log all writes
23:18:39 <dons> seems doable
23:19:11 <Korollary> It can just keep the last 10 chars, no?
23:19:16 <dons> that'd do
23:19:22 <dons> but that's a runtime check
23:19:39 <int-e> @unlambda  `r```````````.H.e.l.l.o. .w.o.r.l.di -- this is boring
23:19:39 <lambdabot> Hello world
23:19:42 <dons> I'm not sure how to encode that statically, but I suggest its possible
23:19:55 <dons> int-e, oh, there's another spam channel
23:20:01 <dons> (possibly)
23:20:32 <dons> @unlambda  `r```````````./.m.e. .<.3. .w.o.r.l.di
23:20:33 * lambdabot <3 worl
23:20:56 <flux__> I especially like the succinct presentation of HQ9 for the Hello world-problem. it must be easy to express other algorithms neatly with the language too..
23:20:59 <dons> its been a cracking great day today :)
23:21:01 <int-e> `.i
23:21:08 <int-e> @unlambda `.i
23:21:09 <lambdabot> 
23:21:09 <flux__> hmm..
23:21:16 <int-e> oh?!
23:21:29 <int-e> why does xchat interpret that as CTCP?
23:21:33 * int-e sighs
23:21:36 <dons> that's an easy one to fix
23:21:45 <flux__> because CTCP is implemented via PRIVMSG?
23:21:48 <Korollary> I am on irssi and it thought that CTCP, too.
23:21:48 <flux__> irssi does that too
23:21:54 <dons> same here
23:21:58 <dons> 16:18 lambdabot [n=lambdabo@manzano.cse.unsw.EDU.AU] requested unknown CTCP  from #haskell:
23:22:01 <Pseudonym> http://www.99-bottles-of-beer.net/language-malbolge-375.html
23:22:04 <flux__> ^A is the magic sequence
23:22:04 <int-e> @unlambda `r`r`ri
23:22:05 <lambdabot> Title: 99 Bottles of Beer | Language Malbolge
23:22:06 <sieni> let's spank lambadabot
23:22:12 <Korollary> @botsmack
23:22:13 <lambdabot> :)
23:22:14 <Pseudonym> And after the spanking?
23:22:18 <Korollary> lol
23:22:20 <int-e> @unlambda `r`.a`r`.b`r`.ci
23:22:21 <lambdabot> c
23:22:21 <lambdabot> b
23:22:21 <lambdabot> a
23:22:28 <int-e> not trivial.
23:22:58 <int-e> (there's probably another problem lurking there, because only the output length is limited, not the number of lines?)
23:23:13 <dons> its limited to 6
23:23:18 <dons> lines
23:23:38 <sieni> Pseudonym: I don't think I'll speak about fisting, when possibly there are very young people on this channel.
23:23:55 <dons> dear oh dear.
23:24:05 <sieni> oops
23:24:07 <Pseudonym> @slap sieni
23:24:07 * lambdabot smacks sieni about with a large trout
23:24:27 <Pseudonym> That's for not giving the right response.
23:24:48 <Korollary> I didnt give the right response either.
23:24:48 <Pseudonym> Keep it for #haskell-blah, and only when Philippa is around.
23:24:58 <Pseudonym> Yeah, but I can tell you knew it at least.
23:25:36 <Korollary> I wonder how people will react to such subjects 100 years from now.
23:26:01 <Pseudonym> I think we'll still have hard-core Pythonites in 100 years.
23:26:15 <Pseudonym> We still have hard-core Oscar Wilde quoters.
23:26:16 <dons> ?quit fixify unlambda
23:26:21 <dons> hehe
23:26:38 <Pseudonym> I think we've run out of Moliere quoters, but you never know.  There might be some in France.
23:26:52 <ibid> Pseudonym: not to mention william shakespeare quoters
23:26:53 <int-e> @unlambda ````.H.l`.e.,``.l.or```. .o`.w.!``.r.d`.li
23:27:05 <ibid> (re @ 0924)
23:27:11 <Pseudonym> Indeed.
23:27:13 <ibid> hrm
23:27:21 <lambdabot>  Hello, world!
23:27:44 <int-e> @unlambda `````.H.l`.e.,``.l.or```. .o`.w.!``.r.d`.li````.H.l`.e.,``.l.or```. .o`.w.!``.r.d`.li
23:27:44 <lambdabot>  Hello, world!
23:27:45 <lambdabot>  Hello, world!
23:27:49 <int-e> good :)
23:27:53 <dons> ;)
23:27:57 <ibid> or caesar quoters
23:28:11 <Pseudonym> I'm thinking in particular of people known for comedy.
23:28:12 <ibid> "beers are to be hunted"
23:28:26 <dons> i suppose people quote gilgamesh somewhere
23:28:28 <int-e> anyway, this is much more fun than the boring hello world on that page :)
23:28:35 <ibid> (alea iacta est:)
23:28:44 <dons> int-e, hehe
23:28:57 <Korollary> "Modern bombs don't tick. 9 out of 10, it's an electric razor..."
23:29:04 <ibid> Pseudonym: aristofanes is being performed, but quoted?
23:30:00 <dons> Tony Soprano quotes Sun Tzu
23:30:13 <Pseudonym> Sun Tzu.  He was a complete crack-up.
23:30:23 <Pseudonym> Aesop, I suppose.
23:30:33 <Pseudonym> There's only one Aesop joke that I actually find funny, though.
23:31:04 <dons> I think it depends on who's telling the Sun Tzu jokes
23:31:31 <Korollary> "Man who run after car gets exhausted - Confucious"
23:33:09 <Pseudonym> Why do I get the impression that Confucius actually didn't have much of a sense of humour.
23:33:52 <ibid> come on. the man himself is named after confusion!
23:34:03 <Korollary> Genghis Khan was a riot.
23:55:17 <dons> ?yow
23:55:17 <lambdabot> I hope the ``Eurythmics'' practice birth control ...
23:55:20 <dons> ?users
23:55:20 <lambdabot> Maximum users seen in #haskell: 235, currently: 188 (80.0%)
