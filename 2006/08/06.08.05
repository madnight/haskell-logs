00:16:02 <flodin> rewrite and use less extensions :)
00:16:20 <edwardk> not likely
00:16:50 <edwardk> i need MPTCs, fundeps are necessary, undecidable-instances, can't be eliminated and do any real work
00:17:04 <edwardk> the only 'optional' piece is template haskell
00:17:18 <edwardk> but without it, the code woud balloon to ridiculous proportions
00:17:24 <edwardk> at least hex side
00:18:16 <edwardk> about the only things i'm not using are GADTS and implicit parameters =)
00:18:17 <dons> mptcs are pretty standard
00:18:41 <dons> ?where exts
00:18:42 <lambdabot> I know nothing about exts.
00:18:46 <dons> ?where haskell-exts
00:18:46 <lambdabot> I know nothing about haskell-exts.
00:18:59 <edwardk> i can't get rid of the undecidable-instances because i have many instance heads that are all type classes.
00:19:00 <edwardk> oh
00:19:08 <edwardk> and i use missing constructors a lot
00:19:12 <dons> ?where haskellexts
00:19:12 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/HaskellExtensions
00:19:24 <dons> gives you a hint about what non-standard things are close to being standard
00:19:42 <edwardk> yeah
00:20:02 <dons> I use MPTCs in fps' testsuite, and know they'll run in hugs et al
00:20:06 <edwardk> mined through that when i started playing with haskell
00:20:16 <dons> looking for things to try to combine ?? ;)
00:20:38 <edwardk> yeah
00:20:47 <edwardk> in case you haven't noticed i like to go out on a limb =)
00:21:07 <dons> we have a few like that around here
00:21:13 <edwardk> yeah
00:21:22 <dons> TheHunter learnt immplicit params by rewriting lambdabot to use them
00:21:31 <dons> maybe that wasn't great idea.
00:21:33 <edwardk> main reason i haven't gotten bored and wandered off. =)
00:21:38 <edwardk> doh
00:21:52 <edwardk> what are you using them for in lambdabot?
00:24:06 <dons> every plugin has an internal state type
00:24:27 <dons> you can refer to this type, and to the module 'ref' itself, inside a module, via that implicit parameter
00:24:37 <dons> edwardk: actually, you'd probably find the lambdaobt monads very interresting
00:24:56 <dons> first class modules, existentials, some impredicativity, implicit params
00:24:56 <edwardk> ?
00:25:00 <dons> monad stacks
00:25:05 <edwardk> fun stuff
00:25:29 <dons> here, http://www.cse.unsw.edu.au/~dons/code/lambdabot/Lambdabot.hs
00:25:39 <dons> e..g
00:25:40 <dons> -- lbIO return :: LB (LB a -> IO a)
00:25:40 <dons> -- CPS to work around predicativiy of haskell's type system.
00:25:40 <dons> lbIO :: ((forall a. LB a -> IO a) -> IO b) -> LB b
00:25:40 <dons> lbIO k = LB . ReaderT $ \r -> k (\(LB m) -> m `runReaderT` r)
00:25:44 <dons> for a start :)
00:26:06 <dons> and our `first class module' type, data MODULE = forall m s. (Module m s) => MODULE m
00:26:42 <dons> and then, to use any plugin, you jump into that plugin, setting up some implicit params:
00:26:46 <dons> withModule dict modname def f = do
00:26:48 <dons>       Just (ModuleRef m ref name) -> let ?ref = ref; ?name = name in f m
00:26:49 <dons>       _                           -> def
00:26:50 <dons>     maybemod <- gets (M.lookup modname . dict)
00:26:53 <dons>     case maybemod of
00:26:54 <edwardk> I must admit I kinda burned out on IRC bots around 93, but lambdabot is pretty cool
00:27:07 <dons> its more a haskell ide, then an irc bot
00:27:12 <dons> the irc stuff is incidental
00:27:15 <edwardk> I read your paper on it
00:27:18 <edwardk> yeah
00:27:22 <edwardk> I understand
00:27:43 <dons> i'd love a type hacker to come in and clean things up... hint hint
00:27:56 * int-e chuckles merrily
00:27:57 <dons> someone who just loves to hack for hours
00:28:03 <int-e> *Main> Var "x" ^ 5
00:28:03 <dons> and work on crazy projects
00:28:03 <int-e> Mult (Mult (Mult (Var "x") (Var "x")) (Mult (Var "x") (Var "x"))) (Var "x")
00:28:09 <dons> heh
00:28:28 <edwardk> My old irc bot was an exercise in data mining to see how well i could automate the generation of conversational rules for a grossly extended eliza. it would basically try to figure out what people were responding to and why
00:28:41 <edwardk> heh
00:28:50 <edwardk> i don't know any type hackers off hand =)
00:29:09 <musasabi> morning
00:29:11 <edwardk> and i wouldn't say my haskell code is very clean
00:29:20 <dons> good morning musasabi
00:29:33 <int-e> (that's the standard (^) - Haskell classes provide some fun reflecting abilities)
00:29:41 <edwardk> so any result would be kinda like a kid cleaning his room when he wants to go out to play. i'd likely just sweep everything into a corner.
00:29:43 <dons> int-e , oh!
00:29:59 <int-e> I forgot who pointed that out. Someone mentioned it on haskell-cafe a while ago.
00:30:10 <dons> edwardk: ah well. if you're bored one day, feel free to take lambdabot apart
00:30:57 <edwardk> i took it apart far enough to understand the structure, but i didn't want to get too involved in the internals, since i don't want to release my code under the gpl and i'd rather not structure my thinking precisely in the way your code works as a result.
00:31:03 <edwardk> if you know what i mean
00:31:44 <dons> ah. no gpl eh? what do you mean "as a result"?
00:32:43 <edwardk> well, i just don't want code popping up in the javascript implementation that looks nigh identical to your gpl lambdabot code
00:33:10 <dons> :) i see
00:33:38 <edwardk> i don't mind the gpl, but i typically release stuff under bsd or apache licenses when i get bored with it
00:33:58 <edwardk> the former doesn't obligate anyone, the latter gives patent protection
00:34:43 <edwardk> and after my last shouting match with stallman i kinda just stopped using the gpl on my projects.
00:34:47 <dons> heh
00:35:37 <dons> with all your haskell explorations, have you come to any opinions about the language?
00:35:38 <edwardk> he didn't seem to like the observation that because of precedents he himself set, you can basically demonstrate that the GPL devolves to the LGPL in a single-address-space operating system context.
00:35:45 <edwardk> i like large portions of it
00:35:49 <edwardk> i love the syntax
00:36:02 <edwardk> i don't like some of the dark corners of type classes and how they interact with types.
00:36:18 <edwardk> i miss nominal types at times.
00:36:21 <dons> you certainly poked around in the dark corners, the last week or two
00:36:38 <dons> hopefully associated types help clean this all up a bit
00:36:50 <edwardk> haskell gets so obsessed ith implementing this right and making people tie the knot, that they lose sight of the fact that easy things should be easy.
00:36:55 <musasabi> BSD3 is usually preferred for Haskell things.
00:38:05 <edwardk> the weirdest part is that its easy think of the type system and class system separately, and you can build up classes that depend on types, but you really can't do much in the other direction right now. class associated types will help, but they aren't here yet
00:38:27 <dons> well, almost here, if you follow the cvs commits list :)
00:38:32 <edwardk> heh
00:38:48 <edwardk> not a big fan of the fact that monad isn't a subclass of functor ;)
00:38:57 <int-e> Hmm, is there a license with the same basic intentions as the GPL/LGPL (if you use the code in substantial parts, make the result available to the public under the same conditions) but without the political discussions?
00:39:01 <edwardk> fail in Monad bugs me, but i accept it needs to be there.
00:39:08 <edwardk> int-e: Apache License 2.0
00:39:15 <edwardk> is my favorite open source license
00:39:34 <edwardk> basically gpl with a patent indemnification clause
00:39:50 <edwardk> but its not gpl compatible because of that patent clause
00:39:51 <Stinger_> shouting match? was it in person? :)
00:39:57 <edwardk> yes =)
00:40:01 <edwardk> and one online
00:40:08 <edwardk> the online one simmered a while
00:40:55 <edwardk> he basically took my argument and added it as 'one more thing to fix in gpl3' and wandered away, i don't see any verbage addressing it though yet
00:41:19 <edwardk> at the time i was obsessed with orthogonal persistence and SASOS models
00:41:34 <edwardk> before i proved to myself they can't scale to the real world i went pretty far down that path.
00:43:08 <pstickne> input <- getLine; map Char.toUpper input    -- type error, why?
00:43:36 <int-e> because the result of map is a list, not an IO action
00:43:55 <int-e> you probably want putStrLn (map Char.toUpper input)
00:44:13 <int-e> or a let binding
00:44:53 <int-e> or, maybe, input <- fmap (map Char.toUpper) getLine
00:45:03 <int-e> guessing intentions is hard :)
00:45:06 <pstickne> hehe
00:45:36 <pstickne> That's in a function, readInput, I want to just return a string, the uppercase version of it in fact
00:45:46 <pstickne> I am calling it   let action = readInput
00:45:52 <musasabi> edwardk: actually classes taking GADT parameters are fun, but not really constrained by them as we don't yet have extensible kinds
00:46:21 <dons> input <- getLine; return $ map Char.toUpper input
00:46:42 <dons> pstickne: have to 'return' in a monad
00:46:48 <edwardk> oh, and i'd like to be able to set some sort of fundep and class constraints on data types while i'm at it =)
00:47:03 <musasabi> data T; data F; data BoolT t where T :: BoolT T; F :: BoolT F; class Foo a where a :: BoolT a -> ...
00:47:05 <edwardk> i guess class-associated types will let me mimic that though
00:47:15 <pstickne> dons, I don't want a IO whatever :(
00:47:41 <dons> pstickne: but you're doing IO, you have to be in IO
00:48:04 <dons> what are you trying todo with the toUpper'ified string?
00:48:19 <pstickne> it goes to a case which chooses between actions
00:48:22 <edwardk> hrmm
00:48:58 <dons> pstickne: ok. so: do v <- getLine ; let u = map Char.toUpper v; case u of ....
00:49:17 <dons> for more help, you'd have to @paste
00:51:06 <edwardk> the only real weirdness i've found in haskell so far is that one bizarre case musasabi helped me out with where haskell was just insisting on picking the wrong type class to resolve from the instance head regardless of what i did until something fairly random was changed in a witness function =/
00:51:18 <pstickne> http://pastie.caboo.se/7325 # the lisp paste seems down
00:51:47 <dons> oh, your readInput is a function in IO?
00:51:55 <dons> to get a value out of the monad you need to use <-
00:52:03 <dons> as in, action <- readInput
00:52:10 <dons> not 'let', let is for non-monadic values
00:52:34 <dons> and your readInput should end in: return $ map Char.toUpper input
00:52:51 <dons> so, in summary, readInput :: IO String
00:53:00 <dons> and actionLoop :: IO ()
00:53:15 <dons> and 'action' itself :: String, once you do actoin <- readInput
00:53:45 <pstickne> why can't I just pass out action as a String?
00:54:01 <int-e> Because your function isn't pure.
00:54:10 <int-e> It does IO, hence you're stuck in the IO monad.
00:54:12 <edwardk> pstickne because if you don't have the io monad, you can't do io =)
00:54:16 <pstickne> ayy, so it's like taining :x
00:54:19 <dons> because you're in the IO monad, so your function has to indicate that it does side effects via a type of IO ...
00:54:23 <edwardk> very much like tainting
00:54:28 <dons> right
00:54:52 <edwardk> the io monad keeps things sorted and going on in order, etc. it has a stronger theoretical background than that
00:55:02 <pstickne> how did it figure out it was an IO monad instead of something random?
00:55:02 <edwardk> but you can reason about it in those terms and not go far wrong
00:55:11 <int-e> the getLine did that
00:55:14 <musasabi> @type getLine
00:55:15 <lambdabot> IO String
00:55:17 <dons> pstickne: it looked at the type of getLine
00:55:39 <pstickne> is there other monads like IO but not IO as far as this goes?
00:55:46 <dons> yep . lots.
00:55:50 <dons> ST, forexample
00:56:00 <dons> just does state, but no 'external' side effects
00:56:01 <musasabi> And one can define even more monads.
00:56:04 <edwardk> pstickne: there are ones for transactions (STM), ST for state transformers, readers, writers, et.
00:56:08 <musasabi> They are just library stuff.
00:56:08 <pstickne> If I used a ST function, and an IO action... ?
00:56:18 <edwardk> another state monad for tracking a single piece of state, etc.
00:56:23 <int-e> you'd get into trouble with the type checker
00:56:34 <dons> pstickne: you stack up your monads, to do that. or else use a monad that already has both
00:56:35 <pstickne> okay. that makes sense.
00:56:52 <pstickne> thanks for all your input :)
00:57:00 <int-e> @type Control.Monad.ST.stToIO
00:57:01 <lambdabot> forall a. GHC.ST.ST GHC.Prim.RealWorld a -> IO a
00:57:06 <pstickne> s/input/help & gentel explantations/
00:57:15 <edwardk> you would have to use a monad transformer of some sort to put them together, or use an appropriate runFoo call to run the other monad inside of your IO monad.
00:57:35 <int-e> you'll have to use stToIO (which exists because ST and IO are actually very similar)
00:59:00 * edwardk randomly asks if anyone here has played much with substructural type systems?
00:59:08 <int-e> Oh, monad transformers are a slightly different story :)
00:59:40 <musasabi> which should be locked away behind a newtype most of the time they are used a lot
01:00:25 <musasabi> (usually it takes ~10 lines of code and make things much more modular)
01:00:31 <pstickne> `return` knows whatever monad we're in instead of just IO, right?
01:00:32 <edwardk> interesting. you advocate newtyping a wrapper and then proxying the MonadFoo transformer classes?
01:00:44 <int-e> @type return ()
01:00:46 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
01:00:56 <int-e> return only knows that it'll be a monad
01:01:03 * edwardk just type wraps them, rather than newtype so i don't have to deal with the proxy
01:01:11 <int-e> any monad will do - so you get a type like the one lambdabot just gave.
01:02:03 <dons> the more I hack haskell, the more I use newtype
01:02:05 <int-e> ('return knows' is badly worded. The type checker knows that of return because return is declared with that type signature in the libraries)
01:02:11 <dons> I guess that's a result of pushing more things into the type checker
01:02:12 <musasabi> edwardk: usually I just use app/library specific actions rather than those inside the Monad classes. Thus 9 of the 10 lines are such actions. (and maybe some lift-functions if needed)
01:02:25 <int-e> newtypes also make great phantom types :)
01:02:29 <edwardk> fair enough
01:02:34 <shapr> Good morning #haskell!
01:02:34 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
01:02:35 <edwardk> how goes it shapr?
01:03:00 <shapr> Microsoft paid for me to fly to the UK, it goes well!
01:03:02 <dons> good morning shapr/xerox- (conjoined?)
01:03:12 <musasabi> edwardk: changing the monad stack can be quite frequent when refactoring things and without the explicit newtype it becomes very hard to do.
01:03:23 <edwardk> i mostly seem to find myself in some sort of (StateT Foo IO) monad
01:03:27 <musasabi> morning shapr
01:03:46 <dons> edwardk: yeah, in fact, I think we should encourage its use more.
01:03:50 <edwardk> musasabi, yeah. noticed that when i wrote my um jit
01:03:53 <shapr> dons: We're all at duncan's house.
01:03:56 <dons> there should be a StateT for beginners
01:04:02 <shapr> hiya genneth
01:04:03 <dons> shapr: nice :)
01:04:12 <int-e> instance MonadState IO where ...
01:04:19 <genneth> shapr: morning
01:04:20 <int-e> ugh
01:04:28 <int-e> ignore that.
01:04:42 <genneth> shapr: sorry i didn't turn up at the pub last night; got sidetracked...
01:04:43 <int-e> it's MonadState <monad> <state> and that just won't work out :)
01:04:52 <edwardk> heh
01:04:52 * musasabi usually changes between wrapping StateT Foo IO, StateT Bar IO, ReaderT Foo IO, ReaderT Foo STM, ...
01:04:54 <genneth> shapr: what's happening today
01:04:57 <shapr> Yesterday I got to meet genneth, liyang, Dana N. Xu, greenrd, and lots of other people.
01:05:00 <tennin> are you still planning to attend ICFP in Portland, shapr?
01:05:22 <shapr> genneth: No worries, we had fun.
01:05:36 <genneth> shapr: aha -- I see the plan from the other channel.. :D
01:06:05 <shapr> I don't really know what we'redoing today, maybe pair programming?
01:06:14 <shapr> tennin: I don't know yet.
01:06:42 <edwardk> i did wind up cobbling together a MonadWriter instance for one of the aforementioned typed StateT Foo IO cases, so i could recycle the builtin functions, but it was just a hack to accumulate the text for the jit
01:07:44 <musasabi> things like MonadState are usually too low level for app code.
01:07:50 <edwardk> yeah
01:08:13 <int-e> right, because the state is usually internal
01:08:31 <musasabi> I want to control 1) which fields of the State record may be accessed directly, 2) control modification even more strictly, 3) have one centralized place to add debugging, and so on
01:08:37 <int-e> you're probably going to provide some projections of the state.
01:08:38 <shapr> Someone has pictures of Simon Peyton-Jones trying my unicycle. Hopefully I can get a copy.
01:08:46 <edwardk> i just swaddled it in functions to provide me with a bunch of IORefs I could keep track of
01:09:16 <edwardk> makes sense
01:09:29 <edwardk> in a program beyond one module i'd probably do the same =)
01:09:35 <shapr> xerox made a video of paj on the unicycle. AngloHaskell has been great fun so far.
01:09:45 <musasabi> edwardk: next exercise would be to mark functions that don't write to those IORefs on the type level ;)
01:10:01 <edwardk> heh
01:10:13 <musasabi> (actually it is quite easy, and only made slightly harder if one wants to have local IORefs which may be written)
01:10:20 * edwardk nods.
01:10:39 <int-e> iPromiseIWillBePure $ do <non-IO stuff here>
01:10:39 <edwardk> I'm mostly playing around with more complex monads for the javascript stuff now.
01:10:44 <edwardk> heh
01:11:23 <edwardk> i actually have that, i swap out IO for STM in some code in a similar manner
01:11:42 <edwardk> er.. well, had
01:11:53 <edwardk> coz i largely shelved STM in my javascript stuff
01:11:59 <dons> shapr, oh cool :) unicycles!
01:12:06 <edwardk> too many places i can get forced to perform io
01:12:36 <edwardk> since just about every hash access can result in spurious function invocations,etc.
01:13:07 <shapr> duncan is really good at unicycling. He was idling my monster uni. We had races between his speedy road uni and mine.
01:13:36 <shapr> dons: Come to the next one when you have a chance?
01:13:44 <dons> for sure!
01:13:54 <dons> hopefully I'll be over there next year, anyway
01:14:07 <edwardk> so how many of you folks are up for the job anyways?
01:14:25 <shapr> Three of us interviewed, Igloo got hired.
01:14:37 <edwardk> ah
01:15:02 <dons> well done Igloo! commiserations Lemmih, shapr
01:15:08 <edwardk> well, at least that takes the pressure off
01:15:18 <shapr> Yeah, maybe next year :-)
01:20:28 <dons> you having a hackathon?
01:20:43 <anglohaskellers> <xerox> Breakfast for now
01:20:50 <anglohaskellers> bbl
01:23:25 * edwardk tries to come up with other (ab)uses for template haskell
01:24:35 <musasabi> edwardk: implement Erlang bit-syntax with TH
01:25:18 <edwardk> thats the << >> stuff right?
01:25:26 <musasabi> yes
01:25:34 <dons> musasabi: is that like the bitdata stuff at ICFP last year?
01:25:54 <dons> i.e. you could specify how to pack bits, and patter match on them.
01:26:40 * edwardk arches an eyebrow
01:27:01 <musasabi> dons: yes, although more focus on the byte-level.
01:28:25 * edwardk isn't so sure that erlang bit sequences would be very useful in a direct th implementation.
01:28:46 <edwardk> maybe some sort of autogenerated packer/unpacker stuff sure
01:30:37 * musasabi only looked at the ICFP article when travelling back from ICFP'05 in the hydrofoil
01:31:59 <dons> heh
01:32:38 <edwardk> urgh, and even just doing the autogenerated packing/unpacking stuff is ugly coz it couldn't be used in the same module, etc.
01:32:40 <musasabi> edwardk: creating the putWord2LE etc stuff is very easy. Making it easy to use and compact like the Erlang bit-syntax is the hard part.
01:32:56 <edwardk> yeah
01:33:09 <musasabi> edwardk: well it would be defined in a library module not user code - so not an issue.
01:34:14 <edwardk> well, the problem you run into is there isn't a nice way to extend the syntax from template haskell so th doesn't really give you the tools to get anywhere near the bit syntax
01:35:04 <int-e> $(foo "my own syntax here") (eek)
01:35:10 <edwardk> heh
01:35:15 <edwardk> thats basically what i was writing up
01:35:32 <edwardk> $(bit .....)()
01:35:33 <musasabi> parsing can be made quite pretty (just return a N-tuple like (foo,bar,baz) <- $(bs "L32:W16:I64")
01:35:48 <musasabi> but creating the values seems harder to do prettily
01:36:10 <edwardk> maybe just the perl pack/unpack syntax.
01:36:18 <int-e> but probably an ADT is prettier. $(bs [L 32:W 16:I 64])
01:36:28 <int-e> err s/:/,/g
01:37:21 <int-e> it's less flexible, of course.
01:37:28 <edwardk> yeah
01:38:18 <edwardk> pack was the syntax that came to mind when i first heard you mention the idea, but a lot of its power comes from being able to supply it arbitrary patterns at runtime
01:39:52 <musasabi> One solution would be to actually extend the syntax and use it like drift with -pgmF
01:41:20 <edwardk> it seems to me that most haskell preprocessor type things require a fairly high level of commitment to develop, to start to use,and to maintain in the face of so many random extensions
01:41:36 <dons> right. bring on Haskell'
01:41:59 <dons> of course, if you just want to handle Haskell98, that's easy (use Language.Haskell), but it won't work on anyone's code
01:42:07 <edwardk> heh
01:42:12 <musasabi> edwardk: actually with haskell-src-exts one can do an adequate result quite fast.
01:42:14 <edwardk> i won't write anything i can't use myself =)
01:42:19 <dons> nonetheless, imagine a preprocessor for C++ or perl...
01:42:20 <int-e> hmm. are the Language.Haskell.Parser things extensible?
01:42:29 <dons> at least its possible to do such a thing for Haskell :)
01:42:34 <edwardk> yeah
01:42:45 <dons> int-e, no. but we do have extended variants
01:42:51 * int-e wonders how an extensible parser would look like. it would probably have to provide a ton of hooks.
01:42:56 <dons> i.e. Language.Haskell.Exts -- nibros
01:43:03 <dons> and you can always just call ghc-api's parser now
01:43:09 <int-e> or some clever way to descibe contexts.
01:43:54 <int-e> tough
01:44:22 <musasabi> int-e: just providing labelling and a variant approach might work. (should write up about that, but have to go)
01:46:08 <int-e> > [p|p<-[2..10],odd p]
01:46:09 <lambdabot>  parse error on input `<-'
01:46:33 <int-e> I wonder if there's any chance of changing TH to use capital letters for that stuff.
01:47:33 <dons> > id [p|p<-[2..10],odd p]
01:47:33 <lambdabot>  parse error on input `<-'
01:48:00 <int-e> > [p | p<-[2..10],odd p]
01:48:02 <lambdabot>  [3,5,7,9]
01:48:15 <dons> yeah
01:48:21 <dons> boo on TH
01:48:36 <dons> if only the keyboard had more kinds of parens
01:48:47 <int-e> [P|...] is far more unlikely to appear in actual code (same for [D| )
01:48:59 <pstickne> YAHT turns into a brick come chatper 7 :(
01:49:19 <dons> int-e, hmm yes!
01:52:42 * edwardk goes to catch a few hours sleep
01:52:45 <edwardk> night all
01:54:03 <nealc> @localtime erider
01:54:09 <lambdabot> Local time for erider is Sat Aug  5 13:23:44
01:55:11 <nealc> good day erider
02:02:54 <stepcut> @localtime stepcut
02:02:55 <lambdabot> Local time for stepcut is Sat Aug  5 02:02:34 2006
02:03:02 * stepcut goes to bed :)
02:03:14 <nealc> night
03:34:18 <nealc> @all-dic trap representation
03:34:21 <lambdabot> *** "Trap" gcide "The Collaborative International Dictionary of English v.0.48"
03:34:21 <lambdabot> Trap \Trap\, v. t. [AS. treppan. See {Trap} a snare.]
03:34:21 <lambdabot>   [1913 Webster]
03:34:21 <lambdabot>   1. To catch in a trap or traps; as, to trap foxes.
03:34:21 <lambdabot>    [1913 Webster]
03:34:23 <lambdabot> [382 @more lines]
03:34:36 <nealc> @help dict
03:34:37 <lambdabot> I perform dictionary lookups via the following 13 commands:
03:34:37 <lambdabot>  @all-dicts .. Query all databases on dict.org
03:34:37 <lambdabot>  @devils ..... The Devil's Dictionary
03:34:37 <lambdabot>  @easton ..... Easton's 1897 Bible Dictionary
03:34:37 <lambdabot>  @elements ... Elements database
03:34:39 <lambdabot> [9 @more lines]
03:34:44 <nealc> @more
03:34:44 <lambdabot>  @foldoc ..... The Free On-line Dictionary of Computing
03:34:44 <lambdabot>  @gazetteer .. U.S. Gazetteer (1990)
03:34:45 <lambdabot>  @hitchcock .. Hitchcock's Bible Names Dictionary (late 1800's)
03:34:47 <lambdabot>  @jargon ..... Jargon File
03:34:49 <lambdabot>  @lojban ..... Search lojban.org
03:34:51 <lambdabot> [4 @more lines]
03:34:58 <nealc> @help lojban
03:34:58 <lambdabot> I perform dictionary lookups via the following 13 commands:
03:34:58 <lambdabot>  @all-dicts .. Query all databases on dict.org
03:34:59 <lambdabot>  @devils ..... The Devil's Dictionary
03:35:01 <lambdabot>  @easton ..... Easton's 1897 Bible Dictionary
03:35:03 <lambdabot>  @elements ... Elements database
03:35:05 <lambdabot> [9 @more lines]
03:35:11 <nealc> @more
03:35:11 <lambdabot>  @foldoc ..... The Free On-line Dictionary of Computing
03:35:12 <lambdabot>  @gazetteer .. U.S. Gazetteer (1990)
03:35:12 <lambdabot>  @hitchcock .. Hitchcock's Bible Names Dictionary (late 1800's)
03:35:13 <lambdabot>  @jargon ..... Jargon File
03:35:15 <lambdabot>  @lojban ..... Search lojban.org
03:35:17 <lambdabot> [4 @more lines]
03:35:28 <nealc> lambdabot, pvt please
03:44:09 <leeghoofd> hey, do you know how I can tell that a var must be both FLoating and Ord?
03:49:05 <wilx> fooo :: (Ord a, Floating a) => a?
03:49:31 <int-e> btw, Floating implies Ord ...
03:50:09 <int-e> (because Ord is a prerequisite of the Num class which in turn is required by the Floating class)
03:50:49 <wilx> Prelude> :info Num
03:50:50 <wilx> class (Eq a, Show a) => Num a where
03:50:50 <leeghoofd> FLoating implies Ord?
03:50:53 <wilx> I don't think so.
03:50:58 <wilx> At least not in my GHCi.
03:51:20 <leeghoofd> thanx wilx, I tried that but I forgot the ()
03:51:27 <int-e> Grr. I'm wrong, only Eq is required for Num.
03:51:31 <int-e> I'm sorry.
03:51:42 <leeghoofd> Now it works
03:51:49 <int-e> (and Show)
03:52:47 <int-e> (The grr was directed at myself for not checking that first in case anyone wondered.)
03:53:26 <leeghoofd> :)
04:08:59 <erider> hi nealc
04:12:50 <nealc> hi
04:13:59 <nealc> erider, what is #keow about?
04:14:22 <erider> programming theory
04:16:03 <erider> they are purposing a new OS that has  relate data structure. Kind of like plan 9 nealc
04:16:31 <nealc> i dont know "plan 9"
04:16:50 <nealc> @google "plan 9" operating system
04:16:52 <lambdabot> http://cm.bell-labs.com/plan9/
04:16:53 <lambdabot> Title: Plan 9 from Bell Labs
04:17:12 <erider> oops propose
04:18:40 <nealc> you dont know (and i have to express) how interesting is this to me!
04:19:02 <erider> nealc: they were the owns of #programming-theory
04:19:20 <nealc> "they"?
04:19:53 <erider> there is two ops on that channel
04:20:13 <erider> thats way I say they :)
04:20:20 <nealc> do you have typed right? if you look, i am the op of #programming-theory now.
04:20:45 <erider> really
04:20:46 <nealc> s/do/did/
04:21:14 <erider> they have moved to keow for some odd reason
04:37:45 <Buzzons> is here a command to do this ... [1,2,3] => 123
04:50:13 <foxy__> > concat ['1','2','3']
04:50:14 <lambdabot>  Couldn't match `[a]' against `Char'
04:50:40 <foxy__> > concat ["1"2","3"]
04:50:41 <lambdabot>  Improperly terminated string
04:50:53 <foxy__> > concat ["1","2","3"]
04:50:54 <lambdabot>  "123"
04:52:02 <foxy__> > foldl (\x y -> 10*x + y) 0 [1,2,3]
04:52:03 <lambdabot>  123
04:52:27 <foxy__> @pl \x y -> 10*x + y
04:52:27 <lambdabot> (+) . (10 *)
06:03:40 <musasabi> University server down for some reason, thus alternative hostmask.
06:13:00 <musasabi> Are there other papers about open data types in Haskell than "Open Data Types and Open Functions" by Löh and Hinze ?
06:16:19 <nealc> http://lambda-the-ultimate.org/node/1453
06:16:20 <lambdabot> Title: Open data types and open functions | Lambda the Ultimate
06:16:32 <nealc> others?
06:17:21 <musasabi> nealc: that is the same paper
06:24:06 <ihope_> So does having ((a -> b) -> a) -> a really break anything?
06:30:48 <musasabi> ihope_: how would that be done?
06:31:01 <ihope_> musasabi: it couldn't be done.
06:31:18 <musasabi> (without undefined)
06:32:07 <ihope_> But could you use something of that type to break things?
06:32:30 <ihope_> To get "forall a. a", that is?
06:39:07 <musasabi> Found "Polymorphic Variants in Haskell"
06:44:20 <nealc> humm.
07:21:05 <dons> ?yow!
07:21:05 <lambdabot> I own seven-eighths of all the artists in downtown Burbank!
07:25:48 <LordBrain> @seen dons
07:25:49 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 4 minutes and 44 seconds ago.
07:26:00 <dons> @seen LordBrain
07:26:01 <lambdabot> LordBrain is in #haskell. I last heard LordBrain speak 12 seconds ago.
07:26:09 <LordBrain> dons, i downloaded hs-plugins
07:26:18 <LordBrain> i'm trying to build the docs
07:26:25 <dons> oh, ok.
07:26:38 <dons> you could just pull them off the website, I suppose
07:26:40 <LordBrain> its using tex2page tho which doesnt exist on my system
07:26:44 <dons> ok.
07:26:48 <LordBrain> hmm thats true
07:26:55 <dons> the docs are on the website :) then you don't need tex2page
07:27:07 <dons> (it was a phase I went through before I learnt haddock)
07:27:49 <LordBrain> hehe
07:27:59 <LordBrain> i havent learned haddock yet
07:28:33 <LordBrain> has hs-plugins ever been tested on windows?
07:28:42 <dons> yep. works
07:28:46 <LordBrain> coolness
07:31:34 <dons> very quiet with so many off at AngloHaskell...
07:32:16 <LordBrain> AngloHaskell?
07:32:46 <dons> yeah, there's a workshop-ish thing happening at cambridge
07:33:01 <dons> a lot of the channel regulars are gone for the weekend
07:33:29 <edwinb> they've just gone punting...
07:33:35 <dons> yeah, maybe :)
07:33:46 <edwinb> no, really :)
07:33:49 <dons> oh!
07:34:00 * edwinb has escaped to a cafe with free wireless...
07:34:00 <dons> ok. well then. sounds fun
07:38:47 * dons punts off to sleep
07:38:59 <mux> nite don :)
08:04:26 <Dr_Pi> "sum (  top : rest ) = top + sum rest." Isn't this Prolog? ;-)
08:08:30 <mux> Dr_Pi: are you writing or reading this?
08:09:43 <Dr_Pi> mux: I read it on one of Audrey's slides. From the Learning Haskell series.
08:10:23 <mux> ok
08:10:30 <mux> because we usually prefer implicit recursion
08:10:48 <mux> such as foldl (+) 0
08:10:58 <mux> and sum is already defined in the base libs anyways
08:27:06 <therp> excuse me, what's the name of the syntactic construct ":=>", or else what does stuff like "data Qual = [Pred] :=> t" mean?
08:28:21 <musasabi> therp: it is an infix constructor.
08:29:58 <therp> and what does it construct? PDF searching for it in gentle introduction and language report is unsuccessful, hm.
08:33:32 <musasabi> therp: it does just what normal constructors do, but it is infix.
08:33:59 <musasabi> "data Qual = [Pred] :=> t" == "data Qual = (:=>) [Pred] t"
08:35:00 <therp> ah! so it's a user defined construct(or), I thought it'd be some haskell operator that I have no clue of
08:36:02 <therp> and how does haskell 'know' it's supposed to be infix? would "data Qual = a B c" also cause an infix construction B?
08:36:27 <therp> s/construction/constructor/
08:36:55 <arjanb> only constructors starting with : are infix
08:38:31 <int-e>  (:=>) is a strange face ...
08:41:04 <therp> arjanb: that's a piece of information that's hard to find, thanks. even now (barely having an idea what to search for) it's hard to find
08:41:09 <therp> int-e: typing haskell in haskell paper
08:42:20 <Cale> therp: you might want to read the Haskell Report for stuff like that.
08:43:56 <therp> cale: that's what I was searching in.. but reading it from the beginning till the end wouldn't be a bad idea, only the motivation is missing. lang. specs are always a bit dry
08:44:24 <Cale> therp: Yeah, I think I've read it all now, but never all at once.
08:45:19 <musasabi> Is there a way to delete a range efficiently from a Data.Map?
08:45:35 <musasabi> That is deleteRange :: Ord k => k -> k -> Map k v -> Map k v
08:46:26 <Cale> musasabi: split would probably help
08:46:58 <Cale> a couple of splits followed by a union
08:48:26 <musasabi> Cale: does not seem very efficient. Maybe just using nested Maps
08:48:38 <Cale> hum
08:50:18 <therp> I wonder why "instance Someclass a => Someclass [a] where .." isn't written "instance Someclass (Someclass a => [a]) where .." - I was confused about the symmetric between the left and right part of => and assumed that I'd be some kind of function mapping between "Someclass a" and "Someclass [a]" - but that mental modell is totally wrong, isn't it?
08:51:01 <Cale> therp: The mental model is that classes are predicates -- statements about types
08:51:05 <musasabi> What was the reason for no Ord instance on Typeable?
08:51:14 <lightstep> in haskell 98 you don't have overlapping instances, so you can go in the opposite direction of the arrow
08:51:21 <Cale> you read it as  "if Someclass a, then Someclass [a]"
08:52:12 <musasabi> that is TypeRep.
08:52:13 <therp> cale: yes that'd make more sense
08:53:07 <therp> unfortunately, "=>" only reminds me of an implication symbol in the second place
08:55:03 <therp> however thanks for the hint with :=>, that gives much more sense to the code in front of me :)
09:28:03 <postman> int-e: Is there any example code of some algorithm implemented in the ST monad? The interface Control.Monad.ST doesn't seem to let me do a lot (besides unsafe operations).
09:29:53 <lightstep> ?wiki ImperativeHaskell
09:29:53 <lambdabot> http://www.haskell.org/haskellwiki/ImperativeHaskell
09:30:30 <lightstep> i thought it still exists
09:31:04 <lightstep> here it is: http://haskell.org/hawiki/ImperativeHaskell
09:31:05 <lambdabot> Title: ImperativeHaskell - The Haskell Wiki
09:31:28 <postman> lightstep: thanks
09:32:23 <Cale> postman: The ST monad isn't interesting unless you have Data.STRef and Data.Array.ST
09:32:29 <int-e> postman: btw, small correction: http://paste.lisp.org/display/23704#1 (the idea of using 0 wasn't so good, it can fail occasionally I think)
09:33:43 <Cale> postman: (so look both of those up in the docs)
10:02:09 <postman> int-e: initialize to 1, n+1, n+1, .. Don't you mean initialize to n followed by all zeros?
10:02:58 <int-e> postman: no. I mean 'one past the last element' which is n+1 in the beginning.
10:03:58 <postman> int-e: I don't understand.
10:04:43 <postman> int-e: the first index of nodes with weight k. In the beginning all nodes have weight 0.
10:05:06 <int-e> postman: in the beginning, elements 1 to n have weight 0. All elements of larger weight come after that, so their associated index should be larger thant n.
10:05:35 <int-e> postman: that simplifies the check later; I just have to check idx>l+1 and not idx==0 as well.
10:07:53 <postman> int-e: I don't see the point of ever using an index larger than any valid index.
10:10:28 <int-e> postman: the values aren't there to be used, they're there to be clearly distinguishable as unused. And it turns out it's better to use a large value (every value larger than n will work) than to use 0.
10:11:47 <postman> int-e: ok, so they could also be Nothing
10:12:13 <int-e> yes, but you'll still need the > l+1 check so that isn't worth doing (I think)
10:12:15 <postman> int-e: if you would change the type
10:13:51 <postman> int-e: you also claim that whenever an element had only l neighbors visited, that it's impossible that another will be visited more than l times.
10:14:13 <int-e> no.
10:14:15 <postman> int-e: nm
10:14:20 <postman> int-e: you don't claim that
10:14:27 <int-e> l is the number of vertices left, not a weight.
10:15:03 <postman> int-e: ok, I see.
10:19:32 <norpan> @localtime norpan
10:19:36 <lambdabot> Local time for norpan is Sat Aug  5 19:19:11 2006
10:23:32 <int-e> postman: (the 0 idea fails because a vertex of weight, say, 4 could be followed by a vertex of weight 2 in the processing - idx[3] would never be cleared. Clearing it would jeopardize the O(1) bound, although I suspect everything is ok if amortized costs are used)
10:49:07 <qz> different datatypes in haskell cant have named fields with same name?
10:49:40 <norpan> not if they are in the same module
10:49:41 <int-e> not within the same module
10:49:45 <postman> qz: probably not in the same module
10:50:04 <qz> i see, sad
10:51:30 <qz> how this problem is usually solved then? say i need to define multiple datatypes and all of them name name :: String. just name the field differently?
10:51:44 <qz> *have name :: String i mean
10:52:13 <norpan> yes name differently or put the data types in different modules
10:54:04 <Cale> qz: the reason for this is that the field labels are also functions
10:54:50 <Cale> qz: If you really need the polymorphism, you can create a class Named with a member  name :: (Named a) => a -> String
10:55:11 <qz> and say that all my classes are instance of that one?
10:55:21 <Cale> all your types are instances of that class
10:55:22 <int-e> which solves half the problem. x { name = foo } will still not work.
10:55:57 <Cale> right, you might also want to include a member like   rename :: (Named a) => String -> a -> a
10:56:00 <postman> int-e: would you make array length an STRef? Or just pass it around?
10:56:11 <int-e> postman: pass it around
10:56:41 <postman> when would one use STRefs then?
10:57:18 <int-e> to hold local state in coroutines.
10:57:46 <int-e> and possibly to manage actual pointers
10:57:59 <int-e> linked lists.
11:00:58 <int-e> local state could look like this: mkCounter = do x <- newSTRef 0; return $ do c <- readSTRef x; let c' = c+1; c' `seq` writeSTRef x c'; return c
11:01:20 <int-e> to use: ctr <- mkCounter; ...; id <- ctr; other_id <- ctr; ...
11:01:24 <int-e> (untested)
11:01:52 <Cale> Shouldn't strictness analysis add that seq anyway?
11:02:03 <int-e> I don't think it does.
11:02:41 <int-e> because: if you'd start with nesSTRef undefined, and then call ctr 1 Mio times, but never use a result, the code should work.
11:02:44 <int-e> so it can't.
11:03:49 <Cale> but if you actually do use the result in the module, it ought to be able to work that out
11:03:50 <int-e> but I should use $! instead
11:03:55 <Cale> But perhaps it can't.
11:04:51 <int-e> I'd add the seq, I've been bitten by a similar thing with an IORef.
11:06:05 <Cale> Yeah, it's the sort of thing that can easily lead to stack overflows if you're not careful.
11:11:35 <LordBrain> qz: it's unfortunate i agree.. i've seen people mangle field names with prefixes for the type... like vip_name etc..
11:13:03 <mwc> Hah, I ran into something like that... I'm working through appel's compiler text using Ocaml instead of SML
11:13:55 <mwc> not only do you need to prefix fields with types, but you need to either open the module they're declared in or reference them directly: field.Absyn.fld_typ
11:14:43 <mwc> I wish haskell had SML's record system, but I don't know enough about the type theoretical aspects to know if there'd be a fundamental conflict
11:15:47 <LordBrain> yeah.. you have to import qualified too
11:19:55 <postman> http://php.mandelson.org/wordpress/?p=46 <- rant
11:20:02 <lambdabot> Title: Jacob&#8217;s blog Â» Haskell vs. C readability stawman
11:21:21 <LordBrain> if he kept reading they do explain that on the page
11:21:58 <LordBrain> ie that its not in place, and its not as efficient etc etc..
11:22:49 <qz> LordBrain, yeh. sad that every language out there has ugly kludges :|
11:26:14 <angloxerox> Yow
11:26:21 <angloxerox> @yow
11:26:21 <lambdabot> I feel like I'm in a Toilet Bowl with a thumbtack in my forehead!!
11:28:00 <norpan> LordBrain: well but the blog entry has a good point
11:28:15 <norpan> haskell does not use the standard method called "quicksort"
11:28:24 <norpan> the haskell code
11:28:40 <norpan> they are quite different algorithms
11:30:28 <LordBrain> hmmm. well even from a comment on that guy's page from another C coder, referencing the wikipedia page on quick sort, the in place aspect is not part of the algorithm but is a possible implementation optimization.
11:31:01 <Korollary> The people who designed haskell obviously didn't write that haskell intro page. Why would anybody assume that?
11:31:02 <LordBrain> anyway, the haskell intro came right out and said it wasn't really fair if i recall
11:32:17 <norpan> it's really comparing apples and oranges, that quicksort example
11:32:30 <norpan> it would be better to show the bottom-up merge sort or something
11:32:47 <norpan> and show why it's very nice in haskell with good properties on getting the k first elements and lazyness etc
11:32:59 <norpan> if you're going to discuss sorting, that is
11:33:16 <musasabi> norpan: of course one point is that one can get trivial correct (even if slow) things in Haskell very fast and then optimize those that matter
11:33:17 <norpan> but then again, i'm not writing it so i should shut up
11:33:30 <norpan> musasabi: yes, that is a good point
11:33:49 <Korollary> Personally I hate quicksort and fibonacci examples.
11:36:29 <LordBrain> "It isn't all roses, of course. The C quicksort uses an extremely ingenious technique, invented by Hoare, whereby it sorts the array in place; that is, without using any extra storage. As a result, it runs quickly, and in a small amount of memory. In contrast, the Haskell program allocates quite a lot of extra memory behind the scenes, and runs rather slower than the C program." -- thats right there on the page he's complaining about.. i
11:37:16 <norpan> well yes, so there are better examples of haskell's advantages
11:37:28 <LordBrain> So the quicksort example is being used doubly to show the advantages of C.
11:39:22 <Korollary> The standard "cost of everything, value of nothing" argument goes there I believe.
11:39:58 <LordBrain> they could update the c, but they could update the haskell too... how long ago was it written? They dont mention the light wieght threads.. that seems like a pretty nice advantage over C, they dont mention...
11:41:24 <LordBrain> i think if you had Cale right it, we'd see something a lot harsher on C
11:41:28 <LordBrain> hehe
11:41:41 <Korollary> We should have no advocacy
11:42:25 <LordBrain> the paper is about why learn haskell.. you have to have something.
11:43:14 <Korollary> That's like tv ads on tv about other tvs. You can't show how good the other tv really looks!
11:43:20 <postman> Something like:"You could build the next Unreal Engine with this."
11:43:25 <LordBrain> if you mean we shouldnt have "haskell is better than everything else for any purpose" then well i agree, but it doesnt even come close to doing that.
11:43:29 <Cale> What's up?
11:44:08 <Korollary> Haskell: 99% of people who tried it liked it.
11:44:16 <LordBrain> lol
11:44:28 <postman> Korollary: I don't think that's accurate ;)
11:44:39 <Cale> I think the quicksort example is being used to show off how concise Haskell can be. Personally, I don't think I ever really understood quicksort properly until I'd read the Haskell version
11:44:56 <postman> More like:  Haskell: 99% of people who tried it ran away as hard as they could.
11:45:07 <Korollary> They didnt try it
11:45:21 <Korollary> Try = writing about 200-300 lines of code.
11:45:22 <Cale> postman: More like: Haskell: 99% of people haven't tried it.
11:47:55 <gzl> "Haskell: 99% of people are not named this."
11:47:55 <norpan> haskell: you have to be really smart to use it
11:48:21 <Korollary> Haskell: Even Haskell Curry didn't like the name
11:48:56 <LordBrain> Haskell: We put the Funk in Funktion
11:49:01 <LordBrain> from the /topic
11:49:03 <LordBrain> hehe
11:49:19 <norpan> i like my catch phrase
11:49:26 <postman> Learn Haskell in 10 years
11:49:28 <LordBrain> yeah
11:49:33 <LordBrain> lol
11:49:36 <LordBrain> make it 21
11:49:42 <LordBrain> so its like the 21 days series
11:50:15 <Korollary> "Haskell for Dummies... for some definition of dummy."
11:50:29 <postman> @google norwig 10 years
11:50:31 <lambdabot> http://www.gopsusports.com/pressreleases/pressrelease.cfm?anncid=9487
11:50:32 <lambdabot> Title: Press Release - 9
11:50:40 <postman> Nm
11:50:51 <norpan> haskell for smarties
11:51:12 <Cuckoo> @wikipedia De Moivre's formula
11:51:14 <lambdabot> No Result Found.
11:51:21 <postman> @google norvig 10 years program
11:51:23 <lambdabot> http://www.norvig.com/21-days.html
11:51:24 <lambdabot> Title: Teach Yourself Programming in Ten Years
11:51:33 <gzl> Peter Norvig is good.
11:51:36 <gzl> I like his book.
11:51:42 <postman> I was referring to that
11:51:49 <postman> gzl: I didn't like it.
11:51:59 <gzl> why?
11:51:59 <postman> gzl: Uh, what book?
11:52:02 <gzl> AIMA
11:52:23 <postman> gzl: What's there to like about?
11:52:39 <Cuckoo> why didn't the bot fetch me: en.wikipedia.org/wiki/De_Moivre's_formula ?
11:52:57 <gzl> it's a well written survey of a large number of topics, and it does a pretty good job at giving an overview of the whole field while still including a good number of details.
11:52:59 <postman> gzl: I don't think it learn one anything on any non superficial level.
11:53:29 <gzl> that's not totally fair. it covers many of the major algorithms and schools.
11:53:29 <postman> learns, even
11:53:40 <gzl> it's not supposed to be something like Hastie's book
11:53:55 <gzl> survey books have value too
11:54:41 <postman> gzl: I don't like reading a book where almost everything is trivial. It could be a well written book, which makes it easy to grok, but I don't remember it like that.
11:55:16 <gzl> it's really not that trivial, though. as I said, it covers many of the classic algorithms.
11:56:07 <postman> gzl: I read it almost completely (more than was required)
11:56:16 <gzl> ...congratulations.
11:56:44 <gzl> you're more than entitled to dislike it. but I think calling it trivial is unfair.
11:57:31 <postman> I think that people presenting complicated things in a sane way are good writers. If you start presenting some easy subject, you can't prove you write good.
11:57:39 <postman> gzl: ok, trivial is a bit over the top.
11:57:41 <gzl> it's not an easy subject...
11:58:34 <postman> gzl: Does it also handle approaches like CopyCat? I don't recall it doing that.
11:59:03 <postman> gzl: it's logic biased
11:59:22 <gzl> I don't think so. it has a few big chapters on logic, but it has a lot of chapters on probabilistic techniques.
11:59:48 <gzl> certainly as much as the logic part
12:00:04 <gzl> and I'm pretty sure there's a good bit more
12:15:53 <postman> int-e: It's not possible to use such an array value without binding it, right? Thus the typical usage a[b[c[i]]] translates to the use of three redundant bindings?
12:18:32 <int-e> basically, yes. you can do stuff like  readArray c i >>= readArray b >>= readArray a  though.
12:19:34 <postman> int-e: yes, I figured that was possible too. I like that more.
12:20:23 <int-e> you can also use t <- readArray a =<< .. =<< readArray c i. some people prefer that.
12:22:39 <Cale> If you're going to use bind on the right side of a <-, it's often nicer to use the =<< version
12:23:36 <postman> Cale: not familiar with that. But I will look it up
12:23:55 <Cale> well f =<< x = x >>= f
12:24:04 <Cale> It's the same thing, but flipped :)
12:24:39 <Cale> It's just nicer because all the arrows line up that way :)
12:26:22 <Cale> If you're not familiar with either of those, you want to look up monads. I wrote a nice starting tutorial "Monads As Containers", and after that, I generally recommend "All About Monads"
12:28:10 <postman> Cale: I am familiar with >>=
12:28:42 <postman> Cale: well, "familiar", since I haven't produced more than a few KLOC in Haskell.
12:44:28 <postman> I want to use STArray, but I don't really see what type I should give it. testArray = newArray (0,5) 1
12:52:10 <postman> testArray::ST s (STArray s Int Int) works, but it seems I can't do it without wrapping ST s around it
12:59:24 <Cale> postman: that's sort of the point
12:59:37 <Cale> postman: you can only use STArrays from inside the ST monad
13:00:08 <Cale> postman: runST will run the computation as a whole at the end
13:00:38 <Cale> but you can't return an STArray, as it would either be useless or else lose referential transparency
13:03:40 <Cale> so, if you're in the ST monad, you can run that as an action to get hold of the actual STArray itself
13:16:10 <int-e> @type Data.Array.ST.runSTArray
13:16:11 <lambdabot> forall e i. (Ix i) => (forall s. GHC.ST.ST s (GHC.Arr.STArray s i e)) -> Array i e
13:34:49 <dcoutts__> eivuokko: ping
13:35:11 <dcoutts__> edwinb: ping!
13:35:32 <dcoutts__> are you chaps still at the pub?
13:35:40 <dcoutts__> we're about to head off
13:36:06 <dcoutts__> (2 by bike, 2 by unicycle)
13:36:26 * dcoutts__ goes to get bike lights
13:42:52 <Cuckoo> ./Setup.hs configure --bindir=`pwd`
13:42:53 <Cuckoo> err
13:42:59 <Cuckoo> ./Modules.hs: file name does not match module name `Main'
13:43:02 <Cuckoo> why is this?
13:46:39 <int-e> Main is the standard module name - you probably want a  module Modules (..) where  at the top (or maybe some restricted list of exports instead of (..))
13:51:54 <Cuckoo> int-e - I am not sure what I am supposed to do, all I did was edit Config.hs and tried to ghci Main.hs
13:53:29 <edwinb> dcoutts__: sorry, nipped out for a bit!
13:53:33 <edwinb> but we're still here
15:08:04 <monochrom> Nice, mapAccumL uses O(1) space.
15:08:35 * monochrom is doing "yes | runghc x.lhs" where x.lhs uses mapAccumL to process input.
15:09:54 <benja_> is it a ghc error message if a program whose binary is called 'fencore' says "fencore: <<loop>>"
15:09:57 <benja_> ?
15:10:23 <yip> yes
15:10:31 <benja_> what's it mean?
15:11:16 <benja_> (google is no big help unfortunately since it doesn't search for the angle brackets and 'loop' isn't quite unique enough a search term :))
15:11:17 <yip> it means that ghc detected that the program entered an infiniate loop
15:11:36 <benja_> yip: meaning infinite recursion?
15:11:47 <yip> yes
15:11:53 <benja_> ok, thanks!
15:15:33 <monochrom> > let x = True && x in x
15:15:34 <lambdabot>  Exception: <<loop>>
15:15:38 <monochrom> Like that.
15:16:59 <monochrom> Some obvious infinite loops are detected.  There is a precise, operational definition of what is caught.
15:28:51 <Dr_Pi> What's the semantic difference between => and =?
15:34:28 <LordBrain> depends on the context... usually => is read "implies" where = is read "equals"
15:36:44 <LordBrain> in type signatures, you usually have type classes for type variables before the =>, they basicly tell you information about what that a or b is in your type signature... which class it blelongs to... Implicitely, in most places in haskell where you have A => ... it can be read with a "for all" universal quantifier before it.. forall A => ...
15:37:14 <LordBrain> it has nothing to do with =
15:37:45 <LordBrain> are you reading a tutorial?
15:38:33 <LordBrain> = defines a function
15:38:44 <Dr_Pi> LordBrain: In "A Gentle Introduction to Haskell" => is read as evaluates to or reduces to.
15:38:51 <LordBrain> ooh
15:38:55 <LordBrain> yeah see it is context
15:39:31 <LordBrain> thats not part of haskell itself, thats just a convention of that tutorial
15:40:09 <LordBrain> which isnt really that gentle if you havent had experience programming with a similar langauge
15:41:31 <Dr_Pi> LordBrain: Well I've seen some Lisp and some Prolog. I wonder which came first, Prolog or Haskell?
15:41:58 <LordBrain> i suspect prolog
15:42:12 <LordBrain> you might be ok...
15:42:15 <Dr_Pi> LordBrain: Not enough to pull me out of newbie status though.
15:42:27 <LordBrain> well....
15:42:36 <LordBrain> i cant remember the tutorial i used... hold on tho
15:42:43 <postman> Prolog is from 1972 (Wikipedia)
15:43:03 <benja_> lisp from 59?
15:43:49 <benja_> [mccarthy's original paper, that is, and only iirc]
15:44:55 <LordBrain> Dr_Pi: have you looked at "Yet Another Haskell Tutorial"?
15:45:00 <Krunch> prolog predates haskell by 17 years according to Levenez http://www.levenez.com/lang/history.html#02
15:45:01 <araujo> 56 i think
15:45:02 <lambdabot> Title: Computer Languages History (preview)
15:45:15 <araujo> hough first implementation is 59
15:45:22 <benja_> ok
15:45:36 <LordBrain> i think thats the one i used... on advice from someone more experienced in here
15:45:48 <Dr_Pi> LordBrain: I've downloaded YAHT. And will be tackling it soon.
15:46:40 <LordBrain> the gentle intro was ok.. tho it was a bit dense in terminology i found... might be fine since you're a doctor anyway :)
15:47:14 <Dr_Pi> But does the list syntax in Haskell recall that of Prolog?
15:47:21 <Cale> Dr_Pi: Haskell's from about 1990
15:47:33 <LordBrain> i haven't learned prolog..
15:47:42 <Cale> Prolog's from the early 70's
15:47:57 <postman> Prolog has [X|XS], right?
15:48:05 <Cale> yeah
15:48:11 <postman> Haskell has (x:xs)
15:48:17 <LordBrain> ah
15:48:36 <postman> Although, I wouldn't say Haskell is similar to Prolog.
15:48:43 <LordBrain> i noticed ds in someone's code once and it wasnt a list... that convention can trick you...
15:48:56 <Cale> It's not entirely dissimilar.
15:49:19 <ski> both use pattern-matching
15:49:30 * Cale is reminded of the drink which tasted almost, but not completely unlike tea.
15:49:40 <Cuckoo> hi Cale, Anil here ;)
15:49:49 <Cale> Cuckoo: hello
15:49:56 <Cuckoo> how are you?
15:50:03 <Cale> Cuckoo: Why don't you choose one nick and stick with it? :)
15:50:04 <Cale> hehe
15:50:06 <LordBrain> maybe ghc should have a warning for when you ahve a two letter symbol ending with an s that is bound to something that's not a list :P
15:50:06 <Cale> I'm fine
15:50:26 <Cuckoo> hehe :P
15:50:29 <Cuckoo> good good ;)
15:50:57 <psi> Cale: is that from hitchhikers? :)
15:51:06 <LordBrain> this was an acronym... like dynamic syntax but not
15:52:12 <Cuckoo> Cale - I am trying to compile lambdabot and I get this:
15:52:13 <Cuckoo> Loading package base-1.0 ... linking ... done.
15:52:13 <Cuckoo> ./Modules.hs: file name does not match module name `Main'
15:53:03 <postman> readVar v:ST s Bool "Now, in order to apply runST we have to be able to generalize the type of readVar v w.r.t. s, but we cannot as s is free in type environment". Why is s free in the type environment?
15:53:39 <postman> example code: let v = runST (newVar True) in runST (readVar v)
15:55:03 <Cuckoo> any ideas?
15:56:28 <LordBrain> Cuckoo: what are you building?
15:56:32 <postman> Cuckoo: the module containing Main should be named Main.hs or you have to give compiler options.
15:57:15 <postman> Cuckoo: IIRC
15:57:52 <LordBrain> actually i think there is an exeption... your main module doesnt need to have the same file name.... most modules do
15:58:06 <Cuckoo> now I get ghc-6.4.1: could not execute: ./BotPP
15:58:17 <ski> postman : 'newVar :: forall a s. a -> ST s (Var s a)', yes ?, so type 'ST s0 (Var s0 a0)' should somehow be matched against 'forall s1. ST s1 a1', so we can try matching 'a1' with '(Var s0 a0)', but then we can't generalize on 's0' (/'s1')
15:58:23 <foxy_> @where goa
15:58:23 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
15:59:10 <ski> postman : so your 's' is free since it has been unified with my 'a1', whose scope is wider than the scope of 'a1'
16:03:04 <Cuckoo> Could not find module `Lib.Regex':
16:03:15 <monochrom> Yuck, mapAccumL uses more than O(1) space.
16:03:57 <Cuckoo> what I forgot now?
16:04:17 <postman> Cuckoo: reading README (which most projects come with)
16:05:15 <postman> Cuckoo: I don't know whether it comes with it, but most likely there's. Or there's INSTALL, but I can't imagine lambdabot being completely broken.
16:05:35 <ski> (monochrom : with strict function arg ?)
16:06:03 <monochrom> with pretty much strict function arg.
16:06:15 <postman> ski: What's the most easy example for creating some type with a free type variable?
16:06:48 <monochrom> Got to go.  I'll ponder it later :)
16:06:56 <ski> postman : free wrt what ?
16:08:37 <ski> foo x = bar where bar y = x + y  -- try putting a type-signature on 'bar' here  (and 'foo's type-signature should be 'foo :: Num a => a -> a -> a')
16:09:38 * ski wonders if ghc's new tyvar scoping rules actually allows this
16:13:24 <ski> (just as 'x' is a free var in def. of 'bar', so the tyvar which occurs in (actually *is*, in this case) the type of 'x' will occur in the type of 'bar', but it can't be quantified at that place, so it is a free tyvar wrt 'bar's def.)
16:13:27 <postman> ski: I would say bar::(Num a)=>a->a
16:13:46 <ski> try it !
16:13:57 <postman> ski: GHC doesn't agree
16:14:02 <postman> ski: :)
16:14:24 <postman> ski: I already tried it.
16:14:39 <ski> that is because ghc thinks that means 'bar :: forall a. Num a => a -> a', and that isn't the case
16:15:25 <ski> usually tyvars that are free at the point of a type-signature are implicitely 'forall'-quantified, at that point
16:15:33 <ski> but that isn't the correct type, in this case
16:15:55 <postman> postman: bar::Int->Int does work
16:15:55 <ski> the 'a' in the type of 'bar' must be the *same* 'a' as in the type of 'foo'
16:16:01 <postman> ski: bar::Int->Int does work
16:16:13 <ski> yes, since then there's no tyvar to quantify
16:16:20 <ski> if one writes
16:16:26 <ski> foo (x :: a) = bar
16:16:28 <ski>   where
16:16:40 <ski>   bar :: a -> a
16:16:44 <ski>   bar y = x + y
16:16:52 <ski> i think it will work
16:17:24 <ski> (then the outer 'a' scopes over then inner declaration, including the type-signature)
16:18:06 <postman>  A pattern type signature cannot bind scoped type variables `a'
16:18:08 <postman>       unless the pattern has a rigid type context
16:18:22 <ski> (though, upon thought, i'm not sure about how this interacts with the class constraint)
16:18:58 <postman> ski: You mean the one introduced by +?
16:19:07 <ski> (did you include type-sig for 'foo' ?)
16:19:15 <ski> yes
16:19:15 <Jormunder> Hi
16:19:35 <ski> to avoid any possible class-constraint issue, for now, try
16:19:42 <ski>   bar :: a -> [a]
16:19:48 <ski>   bar y = [x,y]
16:19:52 <Jormunder> I'm reading "Imperative Functiona Programming" paper...
16:20:01 <ski> (which is a better, more clean example)
16:20:41 <Jormunder> GHC actually implement IO with ccall language construct?
16:20:52 <postman> ski: same result
16:21:22 <ski> Jormunder : it did .. i think it uses 'foreign' declarations, now, but not sure
16:22:10 <Jormunder> ski: some paper?
16:23:38 <ski> postman : hm, have you provided '-fglasgow-exts' command line flag ?
16:23:49 <postman> ski: I did
16:24:26 <ski> maybe 'tis because they changed the semantics of pattern type signautures, then, bah
16:24:42 <ski> (i have ghc 6.2.2 here)
16:25:14 <ski> (since it seems to work fine, here)
16:25:36 <postman> ski: I still need to include the foo part, right?
16:26:58 <postman> postman: or paste your code.
16:27:04 <postman> ski: or paste your code
16:29:51 <Jormunder> ski: foreing import call
16:30:20 <Jormunder> random: IO Int
16:30:21 <Jormunder> :)
16:32:18 <ski> Jormunder : http://www.cse.unsw.edu.au/~chak/haskell/ffi/
16:32:19 <lambdabot> Title: The Haskell 98 Foreign Function Interface 1.0
16:32:34 <Jormunder> Thanks, I'm reading :)
16:32:39 <Jormunder> ski: (y)
16:32:43 <mux> hey cool
16:32:57 * mux wasn't aware of the new 2006.07.07 release of the HTTP module
16:33:06 <mux> this makes things much easier for installing HXT
16:36:21 <mux> no need to tedisouly install NewBinary, Crypto etc
16:45:09 <Cuckoo> my lambda bot throws me out fd:5: hClose: resource vanished (Broken pipe) for what ever input I give
16:45:56 <madpickle> no expert on the bot, but that's a lost tcp/ip connection, possibly.
16:46:31 <Cuckoo> Initialising plugins ........Plugin.Djinn: couldn't find djinn binary
16:46:37 <Cuckoo> does this mean something?
16:48:17 <musasabi> that it didn't find a djinn binary.
16:48:44 <musasabi> you might want to look/grep at the source - lambdabot is very modular and readable most of the time.
16:57:56 <dcoutts__> @localtime dons
16:57:57 <lambdabot> Local time for dons is Sun Aug  6 09:56:44 2006
16:58:04 <dcoutts__> dons!
16:59:04 <dcoutts__> dons: you may be interested to know that I gave a whiteboard (as opposed to slides) talk at AngloHaskell and had some interesting to and fros with spj
16:59:17 <dcoutts__> he's incedentally on the comittee for PADL
16:59:32 <dcoutts__> he's quite impressed
16:59:48 <dcoutts__> he suggested we try to tackle zipWith and concatMap
17:00:10 <dcoutts__> build/fold doesn't deal with zipWith well but streams does ok
17:00:25 <dcoutts__> though the skip gets in the way actually
17:01:10 <dcoutts__> and that's a point spj was interested in, when streams does well / badly compared to build/fold
17:01:43 <dcoutts__> he was particularly impressed with the point that the stream transformers, eg mapS, etc are non-recursive
17:01:54 <dcoutts__> only writeStr/readStr are recursive
17:02:17 <dcoutts__> so when we inline mapS with filterS etc we get really good fusion
17:02:27 <dcoutts__> that was his take/impression
17:11:44 <LordBrain> hmm darcs can be pretty slow..
17:12:24 <monochrom> Interesting!  My program using mapAccumL uses O(1) space if I tell it +RTS -M3M or something, and compile with -O
17:12:55 <LordBrain> how do you know?
17:14:43 <LordBrain> was that a dumb question?
17:15:13 <Korollary> profiling probably
17:15:38 <monochrom> I fired up some process list and watched.
17:16:04 <LordBrain> what OS?
17:16:08 <monochrom> Linux
17:16:19 <LordBrain> how did you watch it? ps?
17:16:29 <monochrom> "system monitor"
17:17:06 <LordBrain> that a gnome thing?
17:17:11 <monochrom> Yes
17:17:49 <LordBrain> how do you know that its O(1) tho... couldnt the garbage collector be freeing space as fast as it allocates it or something?
17:18:37 <LordBrain> maybe i'm missinterpretting you
17:18:54 <monochrom> Now that's a dumb question, I would say, regrettedly.
17:19:09 <LordBrain> why?
17:19:17 <LordBrain> i'm missing something
17:23:47 <Korollary> it doesnt matter. all that matters is that the process can compute within constant space.
17:24:03 <musasabi> LordBrain: that is O(1)
17:24:33 <LordBrain> by space we dont mean memory?
17:24:45 <musasabi> LordBrain: O(1) in space = the computation needs a fixed amount of space (which it may allocate and free in any way it wants)
17:25:01 <monochrom> by space we dont mean orphaned memory.  By space we mean live memory.
17:25:30 <musasabi> O(n) space = the process needs a linear amount of space depending on the data size.
17:25:45 <monochrom> For a programming environment with automatic GC and without manual deallocation, that is the only relevant definition.
17:26:00 <LordBrain> ok
17:28:36 <wolverian> hm, why does my opengl app not compile with ghc, when it works fine with runghc?
17:28:44 <wolverian> (in general, what is the difference?)
17:29:36 <musasabi> wolverian: what does it complain about?
17:29:59 <wolverian> wolverian@pupu:~$ ghc opengl.hs
17:29:59 <wolverian> opengl.o: In function `r5z1_info': undefined reference to `GraphicsziRenderingziOpenGLziGLziVertexSpec_zdfColorComponentFloat_closure'
17:30:00 <_frederik_> are input and output of UTF-8 characters handled properly in Haskell? in GHC-compiled programs?
17:30:04 <wolverian> lots of lines like that
17:30:22 <musasabi> wolverian: -package something or --make
17:30:30 <Korollary> use --make
17:30:36 <wolverian> oh. thanks
17:30:54 <musasabi> _frederik_: no. But one can do it easily for a program.
17:31:40 <musasabi> Char = Unicode char, but IO = 8 bits ignoring encodings etc-
17:32:58 <musasabi> so one can write a readFileUTF8 fn = decodeUTF8 =<< readFile fn and writeFileUTF8 fn x = writeFile fn =<< encodeUTF8 x
17:34:27 <musasabi> googling should reveal suitable encode/decode function definitions.
17:47:23 <_frederik_> googling for...?
17:49:39 <Twanvl> http://repetae.net/john/repos/jhc/UTF8.hs
17:50:32 <_frederik_> oh thanks
17:53:46 <_frederik_> and to read and write Word8?
17:59:51 <_frederik_> i guess i can 'map (fromIntegral.ord)' but that seems backwards
18:02:16 <mathewm> anyone know of a programmer-friendly online broker?
18:09:35 <_frederik_> john says "No, but popular cheap ones like scottrade have a lot of people writing web
18:09:38 <_frederik_> scraping apps to control them."
18:10:14 <mathewm> hmm
18:10:25 <mathewm> tell John "thanks" :)
18:10:44 <mathewm> any pointers to such a scraper?
18:13:55 <_frederik_> he says search for perl and scottrade
18:14:02 <_frederik_> and try freshmeat.net
18:16:51 <nealc> @where thread
18:16:51 <lambdabot> I know nothing about thread.
18:38:31 <edwardk> bored now. sing, dance, entertain me ;)
18:54:09 <mathewm> what is the modern equivalent of the old Ports library?  I want a non-blocking Control.Concurrent.Chan, if that makes any sense
18:55:24 <Saulzar> Hmm, trying the HaXml example program gets into an infinite loop...
19:03:56 <Cale> mathewm: couldn't you just use Chan and insert some calls to isEmptyChan?
19:04:29 <Cale> (or more likely, wrap readChan with something which does that)
19:10:41 <mathewm> I guess I am after Erlang-like channels and processes; I am not quite sure how to simulate that in haskell
19:16:00 <mathewm> duh...
19:16:11 <mathewm> firkIO + Chan and I am all good
19:27:03 <dons> morning!
19:27:26 <LordBrain> dons!
19:27:34 <LordBrain> hey, i'm reading over yi source some
19:27:59 <dons> oh good :)
19:28:04 <LordBrain> looking at UI.hs, i notice there is something about modeline... does that mean the bottom line that says '-- INSERT --' ?
19:28:17 <LordBrain> in vim?
19:28:55 <dons> yep
19:29:01 <LordBrain> ah cool
19:29:07 <dons> you've tried using it?
19:29:19 <wildcat> oyi
19:29:24 <dons> or when you :split the window, you get two modelines, describing the position of the cursor and so on
19:29:24 <LordBrain> well.. yah.. i checked out the darcs... and installed it
19:29:40 <edwardk> heya dons
19:29:44 <dons> dcoutts__ very interesting!
19:29:49 <LordBrain> ooo split support, good
19:30:00 <wildcat> hell yeah
19:30:10 <wildcat> i'm  drunk
19:30:32 <wildcat> so i'm going to sleep
19:30:35 <LordBrain> those are called status-lines in vim
19:30:40 <wildcat> good night
19:31:38 <LordBrain> the term "modeline" is used for those lines of text which embed editor settings in your text file
19:32:47 <dons> also for that
19:32:52 <LordBrain> anyway, we need another status line thats not attached to a particular window, which overlaps with the command line.. that's where "-- INSERT --" appears.
19:32:57 <dons> modelines/minibuffer are other names for the status line
19:33:08 <wildcat> bkelhµ
19:33:09 <LordBrain> ok
19:33:13 <dons> LordBrain: ah yes. we have that tooo
19:33:22 <LordBrain> its in there?
19:33:30 <dons> you just read/write the prompt line currently .. its just a buffer in the editor state
19:33:41 <dons> its not an overlayed buffer
19:33:48 <LordBrain> ok
19:34:29 <LordBrain> ok, but it will keep until changed tho right?
19:35:00 <LordBrain> like, if i write somethign to it.. that thing is going to stay there... hmmm wait let me sort my thought here
19:35:03 <dons> yep
19:35:12 <dons> it stays there till something else writes to it
19:35:15 <dons> much as vi does
19:36:15 <LordBrain> ok i think that will work well enough
19:36:45 <dons> seems to work ok for the existing vi/vim and emacs modes
19:37:15 <dons> since the author can just implement whatever functionality on top (i.e. virtual overlapped status lines, or whatever)
19:37:18 <LordBrain> well, it should be written to in certain situations
19:37:29 <LordBrain> yeah
19:37:35 <dons> have a look at Core.hs to get a sense of the api
19:37:41 <LordBrain> virtual overlapped might be the best way to go
19:37:51 <LordBrain> yeah i was looking at it too
19:38:20 <LordBrain> i want to improve the Vim.hs
19:38:35 <LordBrain> im a big vim addict you know
19:38:37 <LordBrain> hehe
19:38:50 <dons> oh great!
19:38:53 <LordBrain> it should have visual mode support
19:38:55 <LordBrain> for one
19:39:49 <LordBrain> and, i want the feedback to go to that prompt line ... ideally an overlapped status-line, but for now, it could just be well enough to say -- INSERT -- when you switch to that mode.
19:44:45 <dons> ok. i think something approaching visual mode was added to one of the emacs modes recently
19:44:51 <dons> so you should be able to hack that up
19:45:07 <dons> we have regions already, just not the visual highlighting selecting
19:45:36 <LordBrain> so like we can do cut paste?
19:46:46 <dons> yes, already that is fine
19:46:49 <dons> yy and so on
19:47:04 <dons> the vi emulation is 80% or more complete
19:48:07 <LordBrain> i never used vi... i started in vim.. and made a home there
19:48:24 <edwardk> heh
19:48:38 <dons> well, its kinda like vim, you know ;)
19:48:48 <LordBrain> yeah i know.. but there's no visual mode right?
19:48:52 <dons> npoe
19:48:59 <dons> very old school. and easy to implement too
19:49:01 <LordBrain> so i dont even know how they do cut and paste
19:49:09 <dons> yank and put
19:49:10 * edwardk gets stuck using vi not vim at work and keeps trying to select regions.
19:49:18 <edwardk> then i have to remember to do it by line ranges, etc.
19:49:23 <edwardk> pain in the neck
19:49:32 <dons> oh, i started in vi and hardly ever use visual mode
19:49:36 <dons> maybe never
19:49:41 <LordBrain> well vim uses yank and put too.. but you select the region using visual mode
19:49:44 <dons> i just cut things by paragraph counts
19:49:45 * edwardk started in vi way back when too
19:49:54 <dons> LordBrain: you don't hvae to select by visual mode though
19:49:59 <edwardk> but i find visual mode to be fast for doing indenting and outdenting of large blocks
19:50:00 <dons> 5y} for example
19:50:06 <edwardk> thats about all i tend to use it for
19:50:09 <dons> or to indent, 5>}
19:50:18 <edwardk> vkkkkkkkkkkkkkkkk< =)
19:50:29 <dons> v10k< ?
19:50:37 <edwardk> yeah
19:50:41 <dons> heh
19:50:55 <dons> its a fun little language, but has some dark corners
19:50:58 <edwardk> well, i'm usually scrolling down counting lines that way
19:51:04 <LordBrain> its nice for doing substitutions within an area too
19:51:06 <LordBrain> also
19:51:09 <edwardk> i cut and paste blocks with numbers, etc.
19:51:23 <dons> yeah, i use it for substitutions with an area
19:51:29 <LordBrain> if you use Control-V you get the nifty Visual Block mode..
19:51:33 <Cale> I use visual mode lots.
19:51:55 <LordBrain> yeah.. me too
19:51:59 <Cale> I hate trying to work out how many characters/lines something is.
19:52:00 <dons> a good knowledge of the underlying vi interface is very useful though
19:52:10 <edwardk> yeah hate getting stuck in old school via and having to :f to find out my line, go down to the end, :f to find out the line, then :line1,line2s/...//g etc
19:52:19 <edwardk> er old school vi
19:52:51 <dons> edwardk: oh you can display the current line and column??
19:52:52 <LordBrain> right
19:53:13 <edwardk> yeah
19:53:26 <edwardk> :f tells you how many total lines and what line you are on, etc.
19:53:36 <dons> no, I mean, why would you need that, since the status line has it anyway?
19:53:50 <edwardk> not always depends on the platform's vi =)
19:53:57 <dons> ah, yes. vi.
19:54:06 <edwardk> vim yes, vi no
19:55:06 <dons> yep. i've read the entire vi source when implement yi :)
19:55:16 * edwardk just realized he's been using vi for 23 years.
19:55:16 <dons> there's dark corners ... ;)
19:55:18 <edwardk> heh
19:55:19 <LordBrain> Visual Block mode is handy if you have a sort of graphical diagram or something.. or a block of comments placed sort of as a separate column in the text.. (not really a good practice)
19:55:20 <edwardk> yeah
19:55:21 <dons> heh cool
19:55:35 <LordBrain> but nice to look at
19:57:16 * edwardk also just realized that he is only a year older than vi =)
20:13:09 <LordBrain> whats the vi way to yank a line anyway? I always highlight with visual mode, and then press y
20:13:49 <dylan> yy yanks a line, in vim at least.
20:14:02 <sieni> LordBrain: do you mean something like dd + P or something?
20:14:06 * dylan has his vim with a permenant blue status bar, similar to irssi/slrn/mutt.
20:14:37 <LordBrain> oh i see
20:15:13 <dylan> http://hardison.net/vim.png <-- vim which looks a bit like mutt
20:15:24 <dons> just to copy a line, 'yy' as dylan says
20:15:34 <dons> same in yi :)
20:16:15 <LordBrain> and how do you yank 2 lines?
20:16:22 <dylan> 2yy
20:16:25 <LordBrain> i see
20:16:25 <dons> y1j ?
20:16:58 <dons> dylan: you might be interested in hmp3, it look like mutt too: http://www.cse.unsw.edu.au/~dons/hmp3.html
20:16:59 <lambdabot> Title: hmp3 - curses/ncurses mp3 player
20:17:02 * dons pimps hmp3
20:17:15 <dylan> dons: I use ncmpc currently, but I'm following that link now
20:17:28 <dons> ?google ncmpc
20:17:31 <lambdabot> http://hem.bredband.net/kaw/ncmpc/
20:17:31 <lambdabot> Title: ncmpc - About
20:17:49 <dylan> ncmpc == music player daemon client.
20:17:51 <LordBrain> ncmpc is an interface to the mpd
20:17:53 <LordBrain> yeah
20:18:03 <dons> right. yeah, we need an mpd backend to hmp3, actually
20:18:09 <dons> its often requested.
20:18:19 * edwardk stopped listening to music years ago, no mp3 player problems here. =)
20:18:27 <dylan> I want to write a thingy that auto-detects an mpd running on a LAN and uses it to connect to
20:18:29 <LordBrain> your ears go bad?
20:18:32 <edwardk> nah
20:18:37 <edwardk> just realized it distracted me
20:18:39 <LordBrain> music go bad?
20:18:43 <edwardk> that too =)
20:18:46 <dylan> I sing while programming. :)
20:18:57 <dons> heh, me too :)
20:18:59 <edwardk> i went 13 years without watching television before i hooked up with my fiancee
20:19:06 <edwardk> i just generally try to avoid mass media
20:19:09 <LordBrain> i used to do that.. while in college... it bugged my brother... i'd like hum while doing proofs
20:19:21 <dylan> I don't listen to any really ... common songs.
20:19:24 <LordBrain> he'd be like doing them too and get distracted
20:20:10 <dylan> 90% of my music is irish/scottish/newfoundland/etc folk music.
20:20:21 * edwardk realizes that between those two statements he might as well have put a beanie on his head and twirled the propeller.
20:20:49 <dylan> edwardk: I often have no idea what people are talking about with regard to TV and music.
20:21:03 <LordBrain> i like classical and old jazz, and euro jazz
20:21:31 <dylan> I find classical too structured and inhuman, but that's probably because I'm insane.
20:21:36 <edwardk> i get a little of it as background noise, coz my fiancee still listens to it, and i'm not a hermit, but i just don't see the point of another random distraction while coding
20:22:18 <dons> dylan: listen to `sons and daughters'?
20:22:19 <LordBrain> a varied environment is good for your creativity
20:22:26 <dylan> dons: Never heard of that.
20:22:30 <edwardk> its bad enough that I leave irc open
20:22:51 <edwardk> lordbrain: heard that argument, never bought into it
20:22:58 <LordBrain> you know who django reinhartd is?
20:23:04 <dons> scottish electric folk-ish/indie band
20:23:04 <edwardk> i vary my environment by switching projects every 3 days =)
20:23:20 <LordBrain> edwardk: well.. it shows to be the case for rat-brains.. probably applies to ours too
20:23:25 <LordBrain> hehe
20:23:32 <dylan> dons: interesting. Sounds a bit like Silly Wizard / Andy Stewart?
20:24:03 <LordBrain> django was this great guitar player way back in the 30s
20:24:19 <dylan> lately I obsessively listen to the Mandelbrot Set song by Jonathon Coulton...
20:24:21 * edwardk shrugs. I just find that  can't code as long when their is noise in the background.
20:24:41 <LordBrain> yeah i know... i dislike it when people are wathcing tv in the same room
20:25:09 <dylan> It just provides an interesting source of variable names.
20:25:14 <edwardk> I can sit down and code 16 hours at a stretch modulo breaks for biological purposes, but add music and i stop about 4 hours in.
20:25:20 <dylan> or function names
20:25:32 <LordBrain> yeah
20:25:41 <edwardk> if i can even get started
20:25:51 <LordBrain> yeah
20:25:59 <edwardk> i realize its probably some weird mental block of mine
20:25:59 <LordBrain> i wish i didnt have so many distractions
20:26:06 <dylan> I tend to let music punctuate the coding
20:26:12 <dons> dylan, oh hmm, probably not so much andy stewart. more like a scottish nick cave :)
20:26:29 <dylan> I mean Andy M. Stewart
20:26:31 <dylan> who is scottish
20:26:36 <LordBrain> but nothing but coding... would mean missing out on some fine things
20:26:48 <dylan> http://andymstewart.com/
20:27:09 <dons> ah. not sure then.
20:27:13 <dylan> LordBrain: like baking!
20:27:16 <edwardk> well, the 13 years of missed television worked out rather well, i basically got to bunge through many years of the better tv shows when i started watching it again ;)
20:27:21 <dylan> or squirrel fishing
20:27:24 <edwardk> s/bunge/binge/g
20:27:45 <edwardk> er. and even some of the bad ones
20:28:00 * dons being don stewart, should have known there were 2 andy stewart's :)
20:28:14 <edwardk> heh
20:29:13 <LordBrain> dons, how would i write to the prompt line, i havent figured it out yet?
20:29:28 <dons> LordBrain: check the vim mode for where it does :ex-style commands
20:29:45 <LordBrain> ok thanks
20:29:56 <dons> dylan: http://www.sonsanddaughtersloveyou.com/media.php -- samples
20:29:57 <lambdabot> Title: sons and daughters: media
20:30:13 <dylan> dons: thanks
20:30:14 <dylan> :)
20:30:59 <edwardk> so, basically, yi isn't dead?
20:31:10 <dons> not dead!
20:31:15 <dons> long live yi1
20:31:20 <edwardk> heh
20:31:22 <dylan> I love unix. GET http://www.sonsanddaughtersloveyou.com/audio/fight.m3u | mpc add
20:31:37 <dons> heh
20:31:57 <dons> I think they're only snippets of songs though. maybe there's a couple of full ones
20:32:14 <dylan> hmm
20:32:18 <dylan> doesn't seem to want to play
20:34:07 <dons> hmm
20:37:02 <LordBrain> dons, its using errorE.. but that doesnt seem appropriate
20:37:11 <dons> there's also (acoustic versions) here http://www.kexp.org/aspnet_client/KEXPViewMediaGroup.aspx?rID=2806&pID=528&fID=1139&artist=SZ
20:37:12 <lambdabot> Title: KEXP 90.3 FM - where the music matters
20:37:20 <dons> dylan: which can be ripped to mp3
20:37:41 <dons> LordBrain: let me check the src
20:37:52 <LordBrain> maybe msgE would work?
20:38:09 <dylan> dons: ooh, I think I've heard this on the local indie-ish station.
20:38:11 <dons> msgE
20:38:24 <dons> LordBrain: msgE is the way to go.
20:38:26 <dylan> mmm, msg
20:38:26 <LordBrain> just make sure i call cmdLineFocusE
20:38:55 <dons> LordBrain: right
20:40:16 <dons> dylan: listening to it now, the live stuff at the kexp link above, I think is quite a good performance
20:40:39 * Cale listens to Herbie Hancock's 1973 album "Headhunters"
20:40:40 <dons> though the energy is different to the electric versions
20:44:29 <dons> ?uptime
20:44:29 <lambdabot> uptime: 1 day, 20 hours, 15 minutes and 18 seconds
20:45:34 <stepcut> greetings dons!
20:47:47 <dons> hello stepcut!
20:48:19 <stepcut> I worked on cleaning up the mad bindings a bit
20:48:30 <dons> ah, cool
20:48:41 <stepcut> I wrote the code a few years ago -- I can see that I have gotten better in the meantime :)
20:48:48 <dons> heh
20:48:54 * dons has that feeling sometimes too
20:49:29 <dons> Cale, do you think we could get some sort of ghci-style defaulting going in runplugs with a default (X,Y,Z) tweak?
20:51:12 <dons> ?remember wadler Curried food and curried functions are both aquired tastes
20:51:13 <lambdabot> Done.
20:53:25 <Cale> dons: I don't think I know enough about how hs-plugins eval works to tell
20:54:02 <Cale> dons: But I think it should be possible
20:54:11 <dons> I'd not considered multiple default(...)s before. I'm not even sure of the semantics actually
20:54:14 * dons looks up the report
20:54:43 <dons> the eval mechanism is nothing magic. finding out what ghci does might be the trick
20:55:24 <Cale> Whenever you have an ambiguous variable which is constrained only by prelude classes, it tries each of the defaults in turn, and the first one to satisfy the contexts wins.
20:55:52 <SamB_XP> any Prelude classeS?
20:56:07 <Cale> hmm, might have to be numeric ones, let me check
20:56:13 <dons> ah right. so we could probably do it then. requires a little hs-plugins tweak
20:56:17 * SamB_XP thought it was just numeric-related ones and Read/Show
20:56:33 <SamB_XP> but then again, maybe that *is* pretty much all of the Prelude classes
20:56:45 <Cale> Oh, if Read and Show are there, then it's all of them. :)
20:56:53 <SamB_XP> heh
20:57:05 <dons> "at least one ... is a numeric class"
20:57:07 <SamB_XP> I think so
20:57:15 <SamB_XP> what what?
20:57:22 <Cale> oh, nope Num
20:57:25 <Cale> yeah
20:57:33 <Cale>     * v appears only in constraints of the form C v, where C is a class, and
20:57:33 <Cale>     * at least one of these classes is a numeric class, (that is, Num or a subclass of Num), and
20:57:33 <Cale>     * all of these classes are defined in the Prelude or a standard library (Figures 6.2--6.3, pages -- show the numeric classes, and Figure 6.1, page , shows the classes defined in the Prelude.)
20:57:45 <SamB_XP> oh, ack
20:57:50 <SamB_XP> that last one is annoying
20:58:07 <SamB_XP> because I'd like Bits to count :-(
20:58:12 <Cale> defaulting is very specialised
20:58:20 <dons> hmm, but defauling to Integer,Double doesn't seem to help us at the moment
20:58:34 <Cale> > 1 + 2
20:58:36 <lambdabot>  3
20:58:42 <dons> oh, well, maybe it does
20:58:44 <Cale> seems to help a bit :)
20:58:49 <SamB_XP> it would be nice if there was a way to declare something as part of the "standard" library...
20:59:00 <SamB_XP> > 1/2
20:59:01 <lambdabot>  0.5
20:59:18 <SamB_XP> > sqrt (-1)
20:59:19 <lambdabot>  NaN
20:59:40 <SamB_XP> not DWIMy enough :-P
20:59:42 <Cale> > sqrt (-1) :: Complex Double
20:59:43 <lambdabot>  -0.0 :+ 1.0
20:59:52 <dons> > 1 `shiftL` 3
20:59:53 <lambdabot>  Add a type signature
20:59:58 <dons> Bits.
21:00:04 <Cale> There's no way for it to tell that you didn't want it to be Double
21:00:10 <SamB_XP> doesn't that seem a bit annoying?
21:00:26 <SamB_XP> Cale: just kidding about the sqrt (-1) thing ;-)
21:00:52 <Cale> I don't know, the Bits thing seems a bit justified.
21:00:55 <SamB_XP> if saying "not DWIMy enough" did not make that clear
21:01:03 <SamB_XP> Cale: what?
21:01:06 <Cale> Besides, Bits isn't even defined for Integer, is it?
21:01:12 <SamB_XP> sure is
21:01:16 <dons> it is using a "crude hack"
21:01:21 <SamB_XP> > complement 1 :: Integer
21:01:23 <lambdabot>  -2
21:01:23 <Cale> Oh, all right :)
21:01:24 <dons> ?fptools Data.Bits
21:01:25 <lambdabot> http://darcs.haskell.org/packages/base/Data/Bits.hs
21:01:40 <SamB_XP> if by "crude hack" you mean leaving the member for width of the type in bits undefined...
21:01:51 <dons> no no, that's actually what it says in the src
21:02:14 <dons> > maybe [] id Nothing
21:02:15 <lambdabot>  Add a type signature
21:02:22 <SamB_XP> well, it produces the correct results generally
21:02:24 <dons> that's really the problem. not the Num stuff
21:02:29 <dons> since the above works in ghci
21:02:58 <Cale> oh right
21:03:05 <dons> > reverse []
21:03:06 <Cale> ghci does more defaulting than normal
21:03:06 <lambdabot>  Add a type signature
21:03:09 <dons> yep
21:03:19 <SamB_XP> it doesn't say "crude hack" it says "crude implementation"
21:03:20 <Cale> In fact, I think it'll try Integer for any ambiguous variable.
21:03:24 <SamB_XP> it is not the same thing at all
21:03:31 <dons> If the
21:03:31 <dons> expression yields a set of type constraints that are all from standard classes (Num, Eq etc.), and at
21:03:34 <dons> least one is either a numeric class or the Show, Eq, or Ord class, GHCi will try to use one of the
21:03:37 <dons> default types
21:03:44 <dons> " or the Show, Eq, or Ord class"
21:04:02 <dons> that's the magic bit we don't get access to
21:04:21 <SamB_XP> dons: hello?
21:04:24 <dons> they should have extended the default() mechanism perhaps.
21:04:30 <dons> SamB_XP: hello!
21:04:38 <SamB_XP> -- Crude implementation of bitwise operations on Integers: convert them
21:04:38 <SamB_XP> -- to finite lists of Ints (least significant first), zip and convert
21:04:38 <SamB_XP> -- back again.
21:04:43 <Cale> The current default declaration seems stupidly constrained.
21:04:45 <SamB_XP> where in there is the word "hack"?
21:04:52 <Cale> SamB: nowhere
21:04:58 <dons> ah, my memory is bad.
21:05:01 <SamB_XP> thats what I thought ;-)
21:05:03 <dons> I just rememberd "crude"
21:05:18 <ozone> dons: agreed, that's what patrykz and i thought a long time ago
21:05:21 <dons> I'm sorry. My photographic memory for fptools source code is failing, apparently
21:05:22 <SamB_XP> it does use the word crude, but it is only talking about the details of the implementation...
21:05:24 <ozone> in particular, it'd be really useful for strings
21:05:31 <ozone> default "foo" to be data.bytestring...
21:05:32 <dons> ozone: right.
21:05:40 <ozone> especially useful for unicode stuff: utf-8 vs utf-16
21:05:52 <dons> so how dare ghc HQ extend this in ghci , but not to user land :)
21:06:22 <SamB_XP> oh, and that isn't even the one it uses for GHC!
21:06:47 <SamB_XP> GHC actually has primitives for it
21:06:57 <dons> @tell Lemmih I have a task for you. Extend ghc's 'default' mechanism to expose the Eq,Show,Ord extensions used in ghci
21:06:58 <lambdabot> Consider it noted.
21:07:21 <dons> then @eval would behave exactly like ghci
21:07:49 <ozone> dons: it would be way cool if string literals could use data.bytestring :}
21:08:02 <ozone> especially if you can extend pattern matching to work on it, but that's a bit more of a pipe dream...
21:08:03 <dons> quite so.
21:08:09 <SamB_XP> ozone: well, first you'd need string literals in a class...
21:08:34 <SamB_XP> which I think everyone has recognized for a while now, probably ;-)
21:08:39 <dons> we'd need Views or something
21:08:44 <dons> to get pattern matching
21:08:45 <ozone> dons: maybe not
21:08:46 <SamB_XP> but yeah, you'd need vies
21:08:48 <dons> not even sure if that would work
21:08:50 <SamB_XP> er, views
21:08:58 <SamB_XP> it could work
21:09:05 <ozone> dons: desugar a pattern match on a list to an overloaded method
21:09:07 <dons> there's just no type structure to bytestrings to take advantage of
21:09:17 <dons> ozone: maybe. like enums / [..]
21:09:24 <SamB_XP> it would work quite fine
21:09:30 <ozone> class PatternMatch where ...
21:09:44 <SamB_XP> but you'd need views or it'd be an absolutely awful hack
21:09:48 <hellish> Are views the same as active patterns?
21:09:51 <ozone> dunno, haven't thought about it enough.  might as well propose it for haskell 2
21:10:03 <SamB_XP> haskell 2?
21:10:14 <ozone> haskell prime
21:10:17 <ozone> whatever it's called :)
21:10:29 <SamB_XP> if we were going to come up with a new language, wouldn't we call it something else?
21:10:37 <ozone> how about 'curry'
21:10:42 <SamB_XP> anyway, Haskell prime only takes *implemented* features
21:10:49 <SamB_XP> isn't curry taken?
21:11:45 <dons> we'd have to name it after someone younger, perhaps. "Lennart", the language.
21:11:57 <dons> hehe
21:12:09 <ozone> kiselyov
21:12:16 <ozone> but that might be a bit too weird for practical usage
21:12:22 <dons> heh, I think "Oleg" would be a good name for a language
21:12:28 <SamB_XP> ooooh
21:12:37 <SamB_XP> shouldn't that be the successor to epigram?
21:12:44 <dons> ah... maybe!
21:12:50 <ozone> oleg doesn't believe in dependent types does he?
21:13:09 <SamB_XP> oh, well, I just meant since he likes to do so much with the type system...
21:22:49 <LordBrain> hmmm dons, when i press escape it should clear the command line and it does, but it seems like curses needs a refresh to make it more instant...
21:23:15 <LordBrain> i tried to stick a refresh in UI.hs at drawCmdLine... but it didnt change anything
21:23:17 <dons> its the usual curses problem with interpreting ESC
21:23:26 <LordBrain> oh
21:23:31 <dons> it has to assume that it could be the start of an escape sequence, so it must wait
21:23:40 <dons> to disambiguate the key sequence
21:23:48 <dons> hence no real editors are written in curses..
21:23:54 <dons> they all use their own termio
21:24:08 <LordBrain> ok
21:24:17 <SamB_XP> ouch!
21:24:27 <dons> there may just be some way around it, though i've not found it yet
21:24:41 <dons> anyway, just ignore the delay (you see the same thing in vi too, I seem to recall)
21:24:44 <SamB_XP> so how do theirs get around it?
21:24:51 <LordBrain> well i put my beloved "-- INSERT --" in
21:24:53 <LordBrain> hehehe
21:24:55 <dons> they don't do meta sequence interpreting
21:25:07 <dons> LordBrain: ah cool. for the Vi and Vim modes?
21:25:11 <dons> sounds like a useful patch
21:25:22 <LordBrain> sure
21:25:25 <dons> oh, maybe vi doesn't use -- INSERT --
21:25:32 <LordBrain> i dont know
21:25:37 <LordBrain> i put it in Vim.hs
21:25:50 <dons> ok. cool.
21:25:54 * SamB_XP doesn't know if anyone uses plain vi anymore anyway
21:26:01 <LordBrain> i dont think vi users would mind... its not like that line is being used for something else while you are in insert mode
21:26:02 <dons> check that it behaves like the real vim, and then darcs send!
21:26:16 <dons> SamB_XP: true. but its good to follow a 'standard' :)
21:27:34 <LordBrain> it's not exactly like the real vim which gives you not just -- INSERT -- but also status, like line number etc... i didnt really do very much... i just got it to output that when you switch to insert mode
21:28:02 <dons> well, you already get line numbers and status, no?
21:28:07 <dons> i.e. try :split
21:28:14 <LordBrain> in split yeah
21:29:37 <LordBrain> in the real vim, you you have a sort of extra status line of sorts when you're not in split windows present where the command-line is
21:29:52 <dons> yeah
21:30:06 <dons> we should be able to do that.. all the code to compute those value is there
21:30:13 <dons> just a matter of dumping it into the minibuffer
21:30:26 <dons> do you want to try to add that?
21:30:43 <SamB_XP> you guys have odd minibuffers
21:30:47 <dons> ie. look at how its computed for the modeline, then just hook into that to get it in the minibuffer
21:30:48 <LordBrain> yeah sure, but its not the highest priority.. i think visual mode is more important
21:30:58 <dons> ok. it seems like that is true
21:31:12 <dons> I didn't realise most people _didn't_ use vi-style numeric indexing to do selecting
21:32:00 <LordBrain> anyway.. i will do a darcs send.. so you get the minor change
21:32:08 <dons> ok good
21:32:16 <dons> ?karma+ LordBrain -- yi hacking
21:32:17 <lambdabot> LordBrain's karma raised to 1.
21:33:04 <dons> I think its a practical, realisable goal to make curses yi a reasonable vim
21:33:14 <dons> syntax highlighting and a few things more, only , is needed
21:33:21 <dons> and we know how to do all of that
21:33:49 <dons> the whole emacs-killer is more more more work. and is really for Yi 2.0, the proposed rewrite on top of ghc-api
21:34:01 <LordBrain> finding away around the <ESC> is pretty important too.. even if we have to bypass ncurses...
21:34:13 <dons> ok
21:34:25 <dons> I'd not found it a problem. but maybe I use the editor in atypical ways
21:34:33 <LordBrain> i think its posisble to do lowlevel termio without totally abandoning curses
21:34:49 <dons> if we could just use curses for rendering, and something else for reading input..
21:35:21 <LordBrain> oh.. its just an annoyance, because the whole point of my patch was instant feedback on both switching to insert and back to normal.. but because esc is not instant, i only get half of that.
21:35:38 <dons> how funny, the screen shot of yi on yi.html actually shows the getCh fragment I'd like to replace with lower termio code
21:36:19 <dons> we need to implement a wrap mode too, or at least be able to scroll right...
21:46:12 <LordBrain> yeah
21:46:45 <LordBrain> also, remember the column position when you move from a long line to a shorter one etc.
21:47:05 <dons> yep
21:47:36 <LordBrain> that becomes especially essential if we ever want to implement Visual Block mode.
21:48:09 <LordBrain> but i think standard visual and visual line are the more important ones... most people can live without the block mode i think.
21:48:55 <jgrimes_> know of any compilers that compile to haskell?
21:50:57 <dons> epigram
21:51:10 <dons> I wrote a MiniML compiler that produced Haskell, once
21:51:26 <dons> edwardk wrote a JIT system for the UM, that produced Haskell, on the fly
21:51:42 <dons> and pugs produced Haskell, at least at one point
21:51:44 <jgrimes_> I saw the JIT :) it was pretty interesting
21:52:09 <jgrimes_> I keep hearing more about epigram...
21:52:13 <jgrimes_> eventually I'll have to check it out
21:52:38 <jgrimes_> this gives me a good reason
21:53:42 <LordBrain> i'm not familiar with darcs.. it keeps saying "No recorded local changes to send!"
21:54:09 <Saulzar> darcs record, first
21:54:15 <LordBrain> thanks
21:55:08 * edwardk hears his name mentioned.
21:55:12 <dons> darcs whatsnew -s
21:55:32 <LordBrain> are the patch names allowed to have spaces?
21:55:32 <edwardk> i don't think haskell is ready to serve as a jit
21:55:43 <edwardk> jgrimes: i'm working on a javscript->haskell compiler s well
21:55:52 <edwardk> for ecmascript 4
21:56:10 <jgrimes_> edwardk, oh yes I seem to recall that. Where is the website for that again?
21:56:17 <hellish> edwardk: Why do you need to run javascript under haskell?
21:56:28 <edwardk> well, slipwave.info has my general website and says about as much on it as anything
21:56:50 <edwardk> hellish: well, i'm writing a compiler for ecmascript 4, i just happen to be writing it in haskell, targeting haskell
21:57:21 <edwardk> hellish: the fact that i'm using haskell is motivated by much the same reason that pugs uses haskell
21:57:51 <hellish> edwardk: Your compiler produces haskell? Or machine code?
21:58:04 <edwardk> gah. cat, keyboard, etc.
21:58:06 <hellish> edwardk: Your compiler produces haskell? Or machine code?
21:58:32 <monochrom> Interesting!  My mapAccumL-using program attains O(1) space given +RTS -G1 too!
21:58:51 <edwardk> currently the design has it producing haskell (well, abusing template haskell) and then using hsplugins to load that back in.
21:59:13 <hellish> Weird. I'll have to look at that sometime.
21:59:19 <edwardk> because i have to be able to eval and do some other things its not quite idiomatic haskell
21:59:33 <edwardk> i haven't released it yet, but as soon as its functional i'll throw it on my site
21:59:46 <LordBrain> dons, are the (Int,Int) pairs for regions referring to character positions in the file or line numbers?
21:59:54 <dons> all this rules programming I'm doing really stresses ghc out. it must be producing fast code! ;)
21:59:59 <jgrimes_> edwardk, I'll have to check that out when you do :)
22:00:07 <dons> LordBrain: hmm, don't remember.
22:00:07 <edwardk> i've been obsessing about template haskell as the others around here have noted =)
22:00:14 <dons> there'll be comments somehwere, LordBrain
22:00:54 <edwardk> the jit was an excuse to see how fast hsplugins could load in new coe
22:00:55 <edwardk> er code
22:01:28 <edwardk> my type level 2s complement stuff has been an excuse to learn my way around the type system and template haskell
22:01:50 <edwardk> now i just need to put the pieces together and translate parts of my old javascript recompiler from javascript to haskell
22:02:06 <edwardk> and figure out how to handle all the extensions in ecmascript 4
22:03:12 <mwolak> is there a clean way to change the name of a project in darcs?
22:03:26 <edwardk> heh, would like to know that myself =)
22:03:45 <mwolak> I have a project with the unhelpfull name of "haskell"
22:03:50 <mwolak> (oops!)
22:04:29 <edwardk> heh
22:05:02 <edwardk> i personally started something inside of another repository and just want to copy and rename it to disconnect it from the other project without losing my history
22:11:12 <dons> int-e: cheers
22:11:40 <dons> mwolak: change the names of a darcs project? how about : mv foo bar ?
22:11:57 <int-e> :)
22:12:16 <LordBrain> dons: are you sure cbreak or raw mode wont help with the escape problem?
22:12:25 <mwolak> you mean just rename the directory?
22:12:52 <dons> LordBrain: I'm not 100% sure.
22:12:54 <dons> mwolak: yup
22:13:23 <mwolak> who knew it would be so easy! :P
22:13:35 <dons> :) darcs is very flexible that way
22:13:55 <dons> @tell dcoutts__ ok, i think i've a fuseable concatMap
22:13:55 <lambdabot> Consider it noted.
22:14:20 <dons> @tell dcoutts__ concatMapA f = foldrA (\w acc -> appendA (f w) acc) emptyA
22:14:20 <lambdabot> Consider it noted.
22:15:03 <dons> int-e, want to dive in and clean up Lambdabot.hs ?
22:15:20 <dons> i'd like to get rid of the implicit params (they'll break if we ever setting on Haskell')
22:15:31 <edwardk> heh
22:15:49 <edwardk> dons is really going all out to pawn this task off on someone =)
22:16:09 <dons> I'm just fully saturated with projects atm
22:16:16 <dons> getting this Data.ByteString paper done, for one
22:17:18 <edwardk> fair enough
22:17:33 <edwardk> i really should be writing papers and not just hacking away on fun stuff =/
22:17:52 <dons> ?quit int-e patch
22:19:22 <LordBrain> hmmm i read on some list archive that vim waits just like ncurses does.. it just does it for a half a second instead of a full second...
22:19:40 <dons> ah, very interesting!
22:19:49 <dons> want to grab the vim source and investigatify?
22:20:41 <LordBrain> yeah maybe.. kinda late here now tho
22:20:43 <int-e> implicit params are icky. :)
22:21:05 <LordBrain> are the licenses compatable? what if we just snuck some vim code into yi?
22:21:10 <LordBrain> hehe
22:21:24 <LordBrain> or is that like cheating?
22:21:59 <int-e> And mostly it looks like a StatT could do the job. I might do something next week.
22:22:11 <int-e> *StateT
22:23:12 <LordBrain> another approach would be to actually change ncurses... you think that would annoy people?
22:23:43 <LordBrain> that half second seems to make so much difference to me.. its suprising.
22:24:59 <audreyt> dons: hey
22:25:03 <audreyt> what's the status of unicode fps?
22:25:05 <dons> heya audreyt
22:25:08 <LordBrain> basicly all we need to do is change a 1 to a .5
22:25:23 <dons> sjannsen's hacking away on a Storable a => ByteString a
22:25:27 <dons> and unicode is under way.
22:25:32 <dons> we expect to get both done by the end.
22:25:38 <dons> ropes on top is drifiting though, I thin
22:25:38 <audreyt> cool
22:25:51 <audreyt> that's fine :)
22:26:05 <audreyt> I'll use Char8 now and hope for the best, then
22:26:09 * audreyt is upgrading Pugs's AST
22:26:10 <dons> ah ok.
22:26:20 <dons> btw, fps 0.7 is out, tagged and online
22:26:27 <audreyt> woot
22:26:27 <dons> so you can fixate on that
22:26:34 <audreyt> will do
22:26:37 <audreyt> but I really need
22:26:39 <audreyt> ultiversioning
22:26:42 <audreyt> multiversioning in GHC
22:26:48 <dons> yep
22:26:52 <audreyt> which has landed in trunk, I think
22:26:56 <dons> almost, I think.
22:26:57 <audreyt> by jaffacake last month
22:26:59 <dons> or maybe its done
22:27:06 <dons> which will solve many issues
22:27:27 <audreyt> yeah. definitely ditching 6.4 as soon as 6.6 binary build is up for the three or so major platorms
22:27:37 <dons> cool
22:27:42 <audreyt> Cabal is currently #1 annoyance in pugs development ;)
22:27:50 <audreyt> and #1 reason for that is lack of multiversioning
22:27:53 <dons> ah
22:27:59 <dons> right
22:28:29 <LordBrain> its true...
22:28:41 <LordBrain> if i sit and wait, the cmdline gets cleared...
22:28:49 <LordBrain> i'm just used to seeing it happen faster
22:29:25 <dons> LordBrain: ok, read curses docs? or src..
22:29:41 <LordBrain> dons: there's no way around it... because the up arrow and down arrow are all communicated via escape codes... so we have to delay for some time to make sure its not an escape code...
22:29:50 <dons> right
22:29:54 <dons> that's what I thought
22:29:59 <dons> stupid arrows
22:30:14 <LordBrain> its just vim is more responsive because it doesnt delay for quite as long
22:30:38 <LordBrain> maybe we can just persuade the ncurses coders that they are delaying for too long.
22:31:30 <mwolak> Oh, so that's why '`' chars I accidentally hit trying for the escape key disappear in vim! I had been wondering about that
22:31:43 <dons> yeah, that'd be it
22:34:05 <LordBrain> its curious that vi would have used the escape key in the first place considering the issue
22:34:32 <dons> no delay in vi, though
22:34:35 <LordBrain> its an issue with all the unix terminals...
22:34:55 <LordBrain> well there is no feedback in vi, so you dont notice
22:34:55 <dons> fire up vi, I don't get a delay (unless i'm being silly)
22:35:10 <dons> maybe a 100ms delay
22:35:26 <LordBrain> well i dont have true vi.. my vi links to vim in vi mode
22:35:27 <dons> you notice switching out of insert mode, since the cursor has to go back 1 column
22:35:33 <dons> oh, I have nvi
22:35:49 <dons> I.e. ixyzESC
22:35:52 <stepcut> emacs has a one-second delay on the ESC- key
22:36:14 <LordBrain> yeah you can see the delay in nvi
22:36:16 <LordBrain> here's what you do
22:36:20 <LordBrain> go to insert mode
22:36:29 <LordBrain> type a word and watch teh cursor
22:36:35 <int-e> M-x is immediate though
22:36:37 <int-e> :)
22:36:49 <LordBrain> its at the end of the word.. but if you push esc to go to normal mode it backs up one, thats your feedback
22:36:57 <dons> yes, like I said :)
22:37:00 <stepcut> int-e: Actually, I the ESC is too if you actually type something after it
22:37:09 <dons> LordBrain: but its not a 1s delay, right?
22:37:19 <LordBrain> its a delay, but not as long
22:37:20 <LordBrain> yeah
22:37:20 <dons> its definitely a lot less, but still noticeable
22:37:30 <LordBrain> same thing in vim
22:37:31 <dons> we could look at the nvi termio code then
22:37:33 <dons> its readable
22:37:36 <int-e> stepcut: not really, unless it's a command that requires input
22:37:53 <dons> you'd think that ncurses itself would be tunable on this delay value...
22:38:13 <int-e> stepcut: that's perfectly ok though.
22:38:21 <dons> man timeout
22:38:43 <LordBrain> ok, i'm going to email the ncurses people about it tho, it seems like a lot of ncurses users have been annoyed.. we might as well fix it for everyone...
22:38:57 <dons>        While interpreting an input escape sequence, wgetch sets a
22:38:58 <dons>        timer  while  waiting  for the next character.  If notime-
22:38:58 <dons>        out(win, TRUE) is called,  then  wgetch  does  not  set  a
22:38:58 <dons>        timer.
22:39:23 <dons> LordBrain: I think it is so well known there are known solutions, surely
22:39:36 <LordBrain> yeah
22:39:39 <LordBrain> ok
22:39:44 <dons> man notimeout ?
22:39:49 <LordBrain> so we'll just fix it for ourselves then
22:39:54 <dons> though I seem torecall trying it. hmm
22:40:06 <LordBrain> is that from ncurses dons?
22:40:17 <dons> yep. ma
22:40:22 <dons> n notimeout
22:40:47 <dons> ?google ncurses escape timer
22:40:49 <lambdabot> http://www.mkssoftware.com/docs/man3/curs_getch.3.asp
22:40:49 <lambdabot> Title: getch(), mvgetch(), mvwgetch(), ungetch(), wgetch() -- get (or push back) charac ...
22:42:43 <LordBrain> notimeout sounds like it might delay forever essentially assuming the escape key is an escape sequence
22:42:54 <LordBrain> unless i didnt read correctly
22:43:24 <dons> yeah, i didn't find a tunable timeout
22:45:01 <LordBrain> well there is timeout and wtimeout but its not clear to me that they are escape sequence related
22:45:11 <dons> right
23:02:32 <LordBrain> well i better go to bed
23:02:44 <LordBrain> goodnight dons, everyone
23:02:57 <LordBrain> happy hacking
23:52:33 <edwardk> @paste
23:52:34 <lambdabot> http://paste.lisp.org/new/haskell
23:53:03 <lisppaste2> edwardk pasted "parse error at stringChar t possible incorrect indentation?" at http://paste.lisp.org/display/23724
23:53:10 <edwardk> any ideas?
23:53:23 <dons> gimmeasec..
23:53:26 <dons> ?quit @users
23:54:04 <dons> error msg would help?
23:54:13 <dons> ?users
23:54:26 <edwardk>  
23:54:26 <edwardk> ../../Language/ECMAScript/Lexer.hs:32:0:
23:54:26 <edwardk>     parse error (possibly incorrect indentation)
23:54:35 <edwardk> the error occurs on the line of stringChar t
23:54:39 <lambdabot> 193
23:54:44 <dons> the line, <|> be
23:54:44 <edwardk> hence the comment in the paste =)
23:54:57 <dons> messes up the layout
23:55:03 <dons> indent :
23:55:04 <dons> <|> between (char '\'')
23:55:05 <dons>                        (char '\'' <?> "end of a single-quoted string")
23:55:05 <dons>                        (many stringChar '\'')
23:55:06 <edwardk> <|> is meant to separate the betweens within the <-
23:55:11 <dons> sure.
23:55:14 <edwardk> whats the right fix?
23:55:23 <dons> but you have to keep to the right of the start of the first 'between'
23:55:25 <wolverian> you're missing a ) on the foldr
23:55:30 <edwardk> ahh
23:55:37 <dons> ah!
23:55:38 <dons> that too
23:55:49 <dons> :$
23:55:51 <edwardk> that might also help =)
23:55:56 <wolverian> I don't see a reason for the opening (, actually
23:56:03 <dons> ?users
23:56:03 <lambdabot> 193
23:56:11 <edwardk> i ripped it from parsec internally
23:56:43 <edwardk> and yeah it was the (
23:56:53 <edwardk> feel kinda stupid for not looking at the line
23:57:06 <edwardk> but i had presumed it was something funky with layout =)
23:57:24 <edwardk> i went and replaced the ()s with a $ and missed one
23:57:34 <wolverian> well, to haskell, the layout was very funky :)
23:57:41 <edwardk> heh
23:58:48 <wolverian> yow, I had forgotten transpose. no wonder this map zip felt so ugly
