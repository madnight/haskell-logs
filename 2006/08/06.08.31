00:00:01 <Cale> However, there are things which even templates can't express easily despite being Turing complete :)
00:00:07 <dolio> template <typename T, typename S> vector<S> map(S (*f(T)), vector<T>) ... :)
00:00:14 <dolio> My C++ is rusty.
00:00:15 <Cale> dolio: right
00:00:21 <Cale> Something like that
00:00:23 <dolio> So beautiful.
00:00:33 <Adamant> cool, thanks Cale.
00:00:38 <dons> what about darcs' GADT-patch-commute properties
00:00:42 <tieTYT> Korollary: that page is huge, which one should i read?
00:00:55 <dons> that's only just encodable in haskell with GADTs, so could hardly be done anywhere else short of epigram?
00:01:06 <Adamant> when I am less time crunched, I need to sit down and read the Haskell lit I have.
00:01:19 <Cale> Adamant: of course, to really get a sense of it, you have to program for a long while in Haskell, and then program in some other language, and note your frustration at bugs cropping up that should be type errors :)
00:01:35 <Korollary> tieTYT: Sorry, this is the particular example: http://lambda-the-ultimate.org/node/1527#comment-17843
00:01:37 <lambdabot> Title: Type checking and logical errors | Lambda the Ultimate
00:01:38 <Adamant> Cale, I figured. :)
00:01:46 <edwardk> qz: sure. but my whole point is that i find java generics to be nigh useless.
00:01:57 <edwardk> qz: better than casting back and forth to Object mind you
00:02:12 * kowey winces at the memory
00:02:12 <edwardk> but useless for all of the higher order ideas that you can get out of c++ templates.
00:02:15 <qz> edwardk, why? they provide some kind of runtime type checking
00:02:25 <Cale> Adamant: How about another example, actually...
00:02:28 <dons> ?users
00:02:30 <lambdabot> Maximum users seen in #haskell: 235, currently: 187 (79.6%), active: 28 (11.9%)
00:02:31 <edwardk> qz: yes, but i guess i got hooked on template metaprogramming in c++ =)
00:02:36 <Cale> length :: [a] -> Integer
00:02:42 <Cale> length [] = 0
00:02:46 <qz> and template metaprogramming in c++ is dead ugly
00:02:47 <Cale> length (x:xs) = x
00:02:59 <edwardk> qz: perhaps but it is a powerful tool.
00:03:07 <tieTYT> edwardk: i disagree. they're a definate improvement
00:03:13 <Korollary> I use templates more often than inheritance in c++
00:03:14 <Cale> in an untyped language, this might pass for okay :)
00:03:22 <dons> or in a dynamically typed language
00:03:32 <dons> it'll just do something wrong
00:03:35 <Cale> in a language like C or C++, you could cast the x to an int or something
00:03:36 <edwardk> qz: and when it comes right down to it, java generics don't scale, coz you can't build a generic with lots of parameters without having to refactor every usage of it when you want to change system parameters
00:03:40 <dolio> Automatically convert x to a number. :)
00:03:43 <qz> edwardk, personally i see no reason to use it in real world projects. no ability to debug, 10x times increased compilation time..
00:03:48 <edwardk> tie: they are an improvement, they just aren't enough for me to keep using java.
00:04:11 <Cale> but in Haskell, with that type signature there, there's actually no way to make the function depend on an element of the list
00:04:21 <edwardk> qz: depends on the scope. I find a lot of boost libraries to be quite useful in production code, and the stl doesn't suck if you have a team that is used to using it.
00:04:38 <edwardk> qz: but we've gone pretty far afield of the channel topic here
00:04:44 <qz> edwardk, stl is not a template metaprogramming :) its like using templates 'as intended' and its fine
00:04:49 <vincenz> Moin
00:04:51 <dons> Cale, a tutorial on static-typing-as-bug-prevention/testing would be useful
00:04:52 <Korollary> dons: In Scheme, I have this bad habit of returning a list on success and #f on failure. Heh.
00:05:02 <Cale> Adamant: So basically, the type variable expresses not only the idea that any type will work, but that the function will not depend on the specific the values of that type.
00:05:25 <Cale> on any specific*
00:05:35 <Cale> er, that was mangled, sorry :)
00:05:46 <Adamant> ok, so a = 'a in O'caml?
00:05:48 <edwardk> qz: type traits are a good example of where you want to use typedefs to shorten your templates. c++ stl objects usually have 4-5 parameters, you typically only use 1-2 and can get away with that because it CAN access types from type traits and allocator traits templates.
00:05:53 <Cale> Adamant: yes
00:06:12 <Cale> Adamant: With typeclasses, you get even more expressiveness
00:06:28 <qz> edwardk, yup. still when i say template metaprogramming i mean something like boost::mpl. and it IS ugly
00:06:30 <edwardk> qz: you lose that with the crippled java implementation. so if you like the stl then you should damn the java generics implementation as not going far enough to implement even that
00:07:01 <Korollary> qz: There's some inherent ugliness of C++ syntax that no amount of Revlon can conceal.
00:07:04 <vincenz> Adamant: if you have more ocaml -> haskell questions, feel free to ask, I switched from o'caml to haskell :)
00:07:07 <Cale> sort :: (Ord a) => [a] -> [a] -- you can't quite express that it's sorting the list, but whatever it does can only depend on the natural ordering of the elements.
00:07:07 <edwardk> qz: sure. i've had to resort to it, and i like to have access to it, but usually the farthest i go is http://www.flipcode.com/articles/harmless_issue03.shtml or so
00:07:10 <lambdabot> Title: flipcode - Harmless Algorithms
00:07:19 <qz> Korollary, how true..
00:07:43 <vincenz> Korollary: especially template c++
00:07:43 <dons> vincenz: you should blog your thoughts on OCaml v Haskell at some point, that would be a useful read
00:07:43 <Adamant> ok, I think I have a decent inkling of the value now.
00:07:55 <edwardk> kor: agreed
00:07:57 <gour> anyone uses leo (http://leo.sourceforge.net) for haskell programming?
00:07:58 <dons> vincenz, ... or even "Haskell for OCaml Programmers: A Tutorial"
00:07:58 <vincenz> dons: good idea :)
00:08:00 <lambdabot> Title: Leo's Home Page
00:08:01 <Adamant> thanks Cale. :)
00:08:07 * vincenz adds to his TODO
00:08:13 <Cale> you're quite welcome
00:08:18 <Korollary> gour: I used Leo for C++ programming years ago. Does it support literate haskell now?
00:08:26 <dons> Cale, I like the length bug example. that's a good intro
00:08:28 <qz> and edwardk, why do you keep comparing templates with java generics? generics is not a crippled templates implementation
00:08:32 <lispy> ouch, this guy doesn't know what 'correctness' means: "But without a full set of unit tests (at the very least), you can't guarantee the correctness of a program."
00:08:33 <sieni> @help quote
00:08:34 <lambdabot> quote <nick>
00:08:34 <lambdabot> remember <nick> <quote>
00:08:34 <lambdabot> Quote somebody, a random person, or save a memorable quote
00:08:44 <edwardk> qz: i don't see how its anything but =)
00:08:45 <dons> lispy: oh my
00:08:55 <sieni> @remember Korollary There's some inherent ugliness of C++ syntax that no amount of Revlon can conceal.
00:09:03 <edwardk> templates were introduced primarily to solve the same problem of type unsafe casting
00:09:17 <qz> edwardk, well.. single fact that templates are instantiated in compile time while generics in runtime makes em pretty different
00:09:20 <dons> lispy, yeah, hehe, "full sets" of unit tests really go down well with the high assurance and formal methods people ;)
00:09:22 <sieni> what happen
00:09:36 <sieni> or do you need to quote the quote?
00:09:36 <vincenz> heh
00:09:53 <lispy> dons: yeah, i just hate when people talk about correctness and testing
00:09:57 <vincenz> dons: well technically speaking if you have -FULL- set of tests, then you are guaranteed correctness.  The problem is determining when said tests are a FULL set
00:10:11 <gour> Korollary: i tried yesterday to emerge latest leo, but none of the plugins work
00:10:12 <vincenz> basically you shift the problem!
00:10:20 <lispy> dons: testing just gives you a probability of that your program will behave as intended...it can't give you correctness without, say, infinite work :)
00:10:22 <dons> vincenz: right, hence the ""'s ;)
00:10:24 <vincenz> proving correctness -> proving full set of tests
00:10:36 <dons> since there's kind of a big assumption in the "full sets" phrase..
00:10:40 <edwardk> qz: a lot of that is an accident of the jvm though. the main extension there is ? and bounded wildcards right?
00:10:41 <tieTYT> vincenz: you also have to be sure that your tests are correct
00:10:45 <tieTYT> your tests can have bugs in them too
00:10:47 <Korollary> dons: such as a finite set?
00:10:50 <Adamant> ok. safety dance time - how much support does Haskell give to proofs of safety and security?
00:10:50 <gour> Korollary: although, iirc, there should be easy to add it
00:10:52 <tieTYT> and i find they often do, cause they're boring as shit to write
00:11:01 <vincenz> tieTYT: true, so you basically multiply yoyur work, it's a split-shift :D
00:11:06 <edwardk> qz: i personally internally compare them with eiffel not c++, so it takes me a minute to switch gears ;)
00:11:09 <Adamant> and how much does the type system help in that regard?
00:11:20 <qz> edwardk, what do you mean an accident? jvm generics were copied off c# generics
00:11:30 <dons> Korollary: such as you have a full set of tests. seems like you'd have to write a proof.... so then you write some unit tests to check you've written all the unit tests... but how do you know you're done? you write some unit tests to check this and ...
00:11:36 <tieTYT> edwardk: if you're employed, what language do you use at work?
00:11:45 <qz> its more correct to say copied off .net 2.0 generics even :|
00:11:52 <Korollary> dons: Hey, that's guaranteed employment.
00:11:54 <Cale> Adamant: well, there's some nice things which can be done
00:12:16 <dolio> qz: Were they? I thought when the proposal first came out, it was based on some research paper or other.
00:12:24 <Cale> Adamant: because all IO happens in the IO monad, things which don't have IO occurring in their type actually can't perform any
00:12:39 <Adamant> sweet. like tainting on acid.
00:12:39 <Korollary> Adamant: Oleg Kiselyov does some of that stuff using haskell/ocaml. See this: http://lambda-the-ultimate.org/node/1635
00:12:41 <lambdabot> Title: Lightweight Static Capabilities | Lambda the Ultimate
00:12:43 <tieTYT> vincenz: if you are confident in your tests (and you have a right to be) the big benefit of them is you can make a change in your code that many things depend on, run your tests, and "Know" that you didn't break something in the process
00:12:47 <Cale> Adamant: which is basically why we can have a bot sitting in here evaluating Haskell expressions all day long :)
00:12:50 <edwardk> tie: java, php, coldfusion, perl, haskell, python and c++ mostly
00:12:55 <qz> dolio, there were ideas floating around for quite some time. but implementation time matched .net 2.0 perfectly
00:12:58 <edwardk> tie: i wear a lot of hats at the moment.
00:13:00 <dolio> qz: With different notation that I liked better. T+ and T- instead of extends T and T extends, or something like that.
00:13:02 <qz> and i dont believe in such concidence
00:13:06 <Cale> > readFile "/etc/passwd"
00:13:07 <lambdabot>  No IO allowed
00:13:10 <Cale> :)
00:13:11 <tieTYT> without tests in that situation, you're more likely to leave the bad code that you would like to change in a bad state
00:13:17 <vincenz> tieTYT: I know, but there's only one thing worse than writing tests and that's writing documentation, and I don't do that either
00:13:23 <dolio> qz: And contravariant return types and such. :)
00:13:29 <tieTYT> edwardk: i see
00:13:34 * vincenz tends to refactor mercilessly
00:13:39 <qz> dolio, yeh. i read that too :)
00:13:44 <vincenz> and I use the lazy haskell approach "test-on-demand"
00:13:45 <lispy> i've been using quickcheck lately at work and i've found about 5 bugs since i started using it
00:13:47 <tieTYT> does the haskell language claim that less/no tests are needed for your app?
00:14:07 <dolio> And it worked with arrays, which would have been nice.
00:14:10 <Cale> Adamant: an interesting paper to read would be the one on STM, which is a mechanism for concurrency
00:14:13 <vincenz> tieTYT: I think that typing removes a large set of necessary tests
00:14:15 <edwardk> tie: its not so much claimed by the language, but a lot of users find that passing typechecking and using quickcheck can get you most of your testing done.
00:14:15 <lispy> tieTYT: i don't think anyone is officially claiming that
00:14:30 <Adamant> final question - how easy is it to reverse engineer compiled Haskell?
00:14:33 <lispy> tieTYT: but people do recognize that type checking catches a lot of their mistakes
00:14:44 <vincenz> Adamant: good luck
00:14:44 <Cale> Adamant: I'll get a link. There, they use the type system to enforce that no unrevertable IO happens in thread communication transactions
00:15:05 <Cale> Adamant: I suspect it would be next to impossible to reverse engineer it back into Haskell code.
00:15:15 <int-e> Hmm.  map reverse . inits  would make a nicer primitive list operation than inits.
00:15:32 <Cale> Though it really depends on the runtime
00:15:38 <Adamant> how about something akin to a reasonable C program?
00:15:39 <lispy> tieTYT: and haskell being pure lets you go a step further than testing...you can relatively easily prove an algorithm is correctly implemented
00:15:54 <lisppaste2> int-e annotated #25030 with "another version" at http://paste.lisp.org/display/25030#1
00:16:06 <Cale> Adamant: well, everything looks a bit crazy, since you have the whole mechanism for laziness
00:16:07 <Adamant> since doesn't ghc compile to c, then use gcc?
00:16:13 <tieTYT> again, i suck with the terminology here.  As a specific example we're talking about the benefit of myFunction :: (MyDataType a) -> a will fail at compile time if you pass in a Num?
00:16:34 <vincenz> tieTYT: yes
00:16:49 <Cale> Adamant: values are represented as pointers to code which when run, updates the pointer to a piece of code which returns the value immediately before returning the value.
00:16:51 <Korollary> Adamant: Compiling a lazy language to stock hardware was a challenge in itself, thus the genereated code can look crazy sometimes. You ought to know the compiler inside out I guess.
00:16:55 <dons> Adamant: reverse engineering requires reversing the STG translation. super hard
00:16:59 <tieTYT> well i see that benefit of languages like php and ruby and javascript but doesn't Java have this same benefit?
00:17:10 <tieTYT> and i feel like i should be constantly writing test cases in java too
00:17:12 <vincenz> tieTYT: java has less strict typign
00:17:22 <vincenz> and less flexible typing
00:17:27 <Cale> Adamant: You can imagine what a full scale program would look like if written like that :)
00:17:31 <vincenz> so you can only make rougher assertions with the typesystem
00:17:43 <Adamant> Cale - yeah. I am getting the idea it would be nasty. :)
00:17:53 <tieTYT> vincenz: do you have an example?
00:18:00 <Cale> Adamant: in fact, you don't have to imagine, GHC is capable of emitting (completely unreadable) C code.
00:18:01 <therp> dons: may I ask the naive questions: what's harder about it than regular asm->C conversion? except that haskell may do any transformation to the code and C might done almost none
00:18:05 <tieTYT> hopefully i know enough about Haskell to understand it
00:18:10 <lispy> tieTYT: one of the problems in java is you often drop all the type information so you can do something useful (like stick an object in a collection) and then later you have to safely add it back
00:18:37 <tieTYT> add it back?
00:18:41 <tieTYT> you mean remove it?
00:18:43 <lispy> tieTYT: generics were added to java to plug this hole, but they only help with some of it
00:19:14 <lispy> tieTYT: i mean you take Integer, stick it in a List, and then later you go to get it and it's just an Object, so you have to make it an Integer again
00:19:16 <Adamant> ok. thanks, guys and (gals?) !
00:19:38 <Cale> therp: Not too much. It's just that if you only do the asm -> C conversion, you'll get something that at best, looks like the C output of ghc, which is already unreadable for even fairly trivial programs
00:19:39 <Korollary> map thanks [Either Guy Gal]
00:19:42 <tieTYT> lispy: ok that's what i thought you were saying
00:19:43 <tieTYT> yes i accept that generics were added to plug the this hole.  But what part don't the help with?
00:19:57 <lispy> tieTYT: look at the clone method
00:20:11 <tieTYT> that's just a busted method you shouldn't be using
00:20:14 <lispy> tieTYT: still requires a cast, meaning a chance for the programmer to screw up
00:20:20 <tieTYT> it's an example of a mistake, pure and simple
00:20:24 <lispy> why shouldn't you use it? it's really useful
00:20:58 <Cale> Do people actually use the generics in Java?
00:21:05 <tieTYT> Cale: yes
00:21:08 <Cale> Does the Java collections library use them?
00:21:12 <tieTYT> yes
00:21:12 <lispy> no
00:21:17 <lispy> :)
00:21:17 <tieTYT> yes it does
00:21:23 <edwardk> cale: yeah
00:21:37 <Korollary> I suppose when you introduce the feature, you'd better introduce a library that uses it heh
00:21:41 <edwardk> heh
00:21:43 <tieTYT> lispy: i'll have to grab my book to explain why you shouldn't use clone, do you care that much?
00:21:56 <lispy> tieTYT: actually i'm about to sleep...
00:22:01 <Adamant> btw, have you guys looked at Qi and it's typing system?
00:22:03 <Korollary> Hey, that may help then
00:22:11 <lispy> tieTYT: but if you shouldn't use clone then i have to write the for loop all the time?
00:22:22 <Cale> One of my biggest complaints about Java was that to remove objects from a list, you needed to cast them downwards from Object to whatever their real type was, and of course, that type information was gone by that point.
00:22:27 <Korollary> Adamant: I took a cursory glance at it.
00:22:30 <edwardk> Qi?
00:22:32 <tieTYT> lispy: what most people do is make a new interface called Copyable or something
00:22:36 <Adamant> thoughts?
00:22:39 <tieTYT> and put a copy method in there
00:22:53 <Korollary> @googile qi lisp
00:22:54 <tieTYT> clone has some REALLY complicated rules involved with it
00:22:57 <lambdabot> http://lambda-the-ultimate.org/node/657
00:22:57 <lambdabot> Title: Qi 6.1 released | Lambda the Ultimate
00:23:07 <Cale> Adamant: that's the one with the turing complete type system?
00:23:09 <tieTYT> and most people consider it "broken" and it shouldn't be used
00:23:12 <Adamant> yes.
00:23:37 <tieTYT> lispy: and since you can't add your own Copyable to ArrayList, i guess yes, your own for-loop unfortunately
00:23:50 <Cale> Adamant: That's a decent thing to have, though I think most compiler authors want to guarantee termination of compiling.
00:24:23 <Adamant> cool.
00:24:24 <lispy> tieTYT: yeah, too bad it's not a type class, because then you could add ArrayList as an instance in your own code
00:24:24 <Cale> (obviously, one can't when the type system is Turing complete, so programs with type bugs may never finish compiling)
00:24:35 <Adamant> alright, to bed!
00:24:50 <Korollary> that's for everybody
00:24:51 <Adamant> thank you again, denizen of #haskell !
00:25:02 <Adamant> denizens
00:25:06 <Korollary> @botsnack
00:25:06 <lambdabot> :)
00:25:09 <edwardk> ah neat i'm going to spend some time digging through qi.
00:25:22 <edwardk> thanks kor =)
00:25:31 <Korollary> hi 5
00:25:40 <lispy> low 5
00:25:50 <dolio> Ooo, found it.
00:25:55 <dolio> ?google variance based subtyping for parametric types filetype:pdf
00:25:58 <lambdabot> http://pag.csail.mit.edu/reading-group/variance-ECOOP02.pdf
00:26:14 <tieTYT> lispy: next time you're on, if you care, i'll paste you an excert from my book
00:26:21 <lispy> tieTYT: okay
00:26:39 <lispy> another thing Java could have used from it's inception is the 'Maybe a' type
00:26:46 <Korollary> @tell lispy Look up why you shouldn't use clone().
00:26:46 <lambdabot> Consider it noted.
00:27:08 * lispy is now afraid to speak infront of lambdabot
00:27:09 <lambdabot> lispy: You have 1 new message. '/msg lambdabot @messages' to read it.
00:27:13 <lispy> doh!
00:27:24 <dons> she got you good!
00:28:10 <bringert> hindley-milner type inference is exponential in the worst case, which for pratical purposes is the same as posibly non-terminating
00:28:17 <tieTYT> pft
00:28:20 <tieTYT> google first, duh
00:28:20 <tieTYT> http://www.javapractices.com/Topic71.cjp
00:28:23 <lambdabot> Title: Java Practices: Avoid clone
00:28:28 <tieTYT> now i don't have to grab my book
00:28:31 <bringert> if it takes to long to type check, just abort
00:28:33 <Cale> bringert: yeah, I suppose that's true :)
00:28:44 <dons> don't do it Cale ... ;)
00:28:48 <Cale> hehe
00:28:51 <bringert> like cayenne does for example
00:29:43 <Korollary> The type of the expression is 42.
00:29:44 <profmakx> tieTYT "avoid foo()" just means that the creativity of programmers to find excuses to use it anyway becomes exponential in loc
00:30:06 <tieTYT> what's loc stand for?
00:30:11 <Korollary> lines of crap
00:30:12 <Cale> lines of code?
00:30:12 <profmakx> lines of code
00:30:46 <Cale> http://paste.lisp.org/display/25030 -- anyone clever want to think of a better way to do this?
00:30:51 <tieTYT> that made me undersatnd that i don't know what you're saying
00:30:58 <profmakx> hehe
00:31:14 <int-e> Cale: I did annotate that paste
00:31:23 <profmakx> well forget it
00:31:23 <Cale> int-e: oh, you did :)
00:32:23 * profmakx is not really awake
00:32:39 <Korollary> profmakx: Actually, half decent programmers tend to obey the "Avoid X" after a while.
00:32:43 <lisppaste2> int-e annotated #25030 with "CPS-ify to get rid of list concatenation." at http://paste.lisp.org/display/25030#2
00:33:03 <profmakx> do they...
00:33:28 <profmakx> so, I should go and finde some at least half-decent programmers for some of my projects ^^
00:34:00 <tieTYT> Korollary: hopefully, half decent programmers ask, "Why shouldn't i use it?"
00:34:05 <tieTYT> because that's what i do
00:34:08 <tieTYT> except in the case of clone()
00:34:12 <tieTYT> where i just accepted it :)
00:34:17 <profmakx> :)
00:34:19 <tieTYT> but that's not what i usually do (I swear)
00:34:19 <int-e> funny. on the surface it's not CPS at all but when you think of lists in terms of unevaluated tails it is ...
00:34:42 <Korollary> int-e: Non-cosmetic use of $. Neat.
00:34:49 <musasabi> Anyone that has tried to use ghc fc-2 ?
00:35:04 * musasabi wants type-indexed families
00:35:06 <int-e> Korollary: hehe. I could use id, but I think ($) makes it clearer.
00:35:14 <tieTYT> i looked at the javadocs of how clone() is documented and it's really vague actually.  So i said, "screw this".  Later i read in a book that it should be avoided
00:35:20 <dons> Cale, some QC proeprties might be useful too
00:35:46 <Cale> dons: where should those go?
00:36:14 <dons> well, in the testsuite ideally. but at least writing them and then leaving them in as (non-haddock) comments could be useful
00:36:23 <dons> if there are some nice properties that these functions obey
00:36:58 <Cale> cool
00:38:35 <dons> prop_head_se..g prop_head_perms xs = head (perms xs) == xs -- ?
00:38:37 <edwardk> musasabi: url?
00:38:45 <tieTYT> nite guys
00:39:08 <Cale> hmm, it's unfortunate that it's still so much slower than the version of permutations for finite lists
00:40:08 <dons> (last . sort . perms) [1,2,3]== reverse [1,2,3] -- too
00:40:18 <Cale> interesting, my perms seems to run faster than int-e's in ghci
00:40:25 <Cale> perhaps I should compile them and see :)
00:40:27 <musasabi> edwardk: http://www.cse.unsw.edu.au/~chak/project/fc/
00:40:29 <lambdabot> Title: Manuel M T Chakravarty - Type Functions in GHC
00:44:22 <dons> why does freenode post gentoo release notices?
00:44:28 <int-e> Cale: I forgot which of the two approaches for finite permutations is faster, interleave-based (generate permutations, insert an additional element in all places) or selection-based (pick first element, then second, then third ...)
00:44:47 <Cale> int-e: seems like interleave
00:46:03 <int-e> Cale: selection happens to be a bit more concise.
00:46:17 <Cale> yeah
00:46:48 <profmakx> dons there was another notice shortly after that in which they apologize for that
00:46:49 <Cale> int-e: actually, I'm writing this for inclusion in ghc :)
00:47:04 <int-e> okay, then it should rather be fast.
00:47:06 <dons> profmakx, ah yes.
00:47:13 <Cale> There ought to be a permutations and combinations function in Data.List
00:47:20 <dons> we should get them to post new ghc releases :)
00:47:30 <Korollary> I was going to say lambdabot releases.
00:47:39 <dons> heh
00:47:41 <edwardk> cale: are you handling the infinite cases?
00:47:43 <dons> ?seen lambdabot
00:47:43 <lambdabot> Yes, I'm here. I'm in #ScannedInAvian, #perl6, #oasis, #darcs, #gentoo-haskell, #haskell_ru, #haskell.es, #haskell.se, #haskell.it, #haskell-overflow, #haskell-blah and #haskell
00:47:47 <Cale> edwardk: yes
00:47:51 <dons> since lambdabot practically runs freenode these days
00:47:56 <edwardk> cale: nifty =)
00:47:58 <vincenz> anyone read the second to latest blog entry on planet.haskell?
00:47:59 <vincenz> http://lukeplant.me.uk/blog.php?id=1107301645
00:48:02 <lambdabot> Title: Why learning Haskell/Python makes you a worse programmer
00:48:17 <dons> maybe lambdabot should start running an irc-server-over-irc server
00:48:17 <edwardk> vincenz: yeah, kinda agree =)
00:48:28 <dons> and we could ignore freenode altogether, just connect to lambdabot
00:49:03 <vincenz> edwardk: the title is somewhat shocking tho :), reading now
00:49:32 <edwardk> dons: then you can bake in a tcp/ip stack, and we can just connect to ambdabot not the internet, and you can build highspeed network cards for lambda-net, and ...
00:49:44 <Korollary> Hah. That is funny.
00:49:45 <edwardk> skynet is born ;)
00:50:37 <Korollary> Applying functional tecniques in languages with dismal support indeed leads to ugly code.
00:50:42 <profmakx> vincenz, but he is right to some extent.
00:50:52 <Korollary> I cringe every time I write a functor class in C++
00:51:25 <edwardk> kor: heh
00:51:52 <int-e> Cale: you should get rid of the init though - just let interleave x []     =  []
00:51:59 <edwardk> i have a whole library for manipulating points and hyperplane on the plucker quadric in c++, i can't bring myself to go back to it now ;)
00:52:06 <Cale> int-e: ah, yes,  I should
00:52:37 <edwardk> too many things that would be soo much cleaner in haskell
00:52:39 <vincenz> profmakx: oh he is
00:52:47 <vincenz> profmakx: just finished reading now
00:53:45 <edwardk> haskell seems like a language you teach people, and then they they go out bright eyed into the real world, see the shit they are forced to actually use and they wind up suicidal depressives ;)
00:53:57 <profmakx> hehe
00:54:35 <Korollary> Hmm, F# got haskell-style indentation rules.
00:55:07 <profmakx> wasnt F# ocaml on drugs?
00:55:11 <Korollary> let THE in PARTY in BEGIN
00:55:21 <Cale> edwardk: just reimplement it in Haskell :)
00:55:31 <sieni> profmakx: how's that different from ocaml proper? :-)
00:55:32 <edwardk> cale: probably going to
00:55:41 <profmakx> dont know
00:56:02 <profmakx> i never actually dealt with F#
00:56:06 <edwardk> cale: just have to break it to a friend of mine who is actually using it in his 3d engine that he needs to learn a new language ;)
00:56:46 <Cale> edwardk: haha
00:57:12 <Korollary> edwardk: If he complains, feed him some Tim Sweeney articles.
00:57:17 <edwardk> or ffi the crap out of it
00:57:39 <edwardk> kor: nah, tim sweeney doesn't like haskell, he just likes some of its features
00:58:32 <vincenz> F# was a MS version of o'caml
00:58:38 <vincenz> though I think they left out the 'o' bit
00:58:48 <Cale> okay, it's now only twice as slow as the finite-only version
00:59:09 <edwardk> if he could graft a monad or two, some dependent typing and STM into k&r C he would probably be happy ;)
00:59:12 <Cale> hmm, perhaps not quite that much
00:59:16 <vincenz> dons: there are some interesting things that just got brushed back up in my mind w.r.t o'caml -> haskell... like some patterns that completely change
00:59:43 <Korollary> edwardk: K&R C? That's like Star Wars with its ragged clothes and light sabers in the same scene.
00:59:45 * edwardk really doesn't like going back to look at ml code now that i've been writing in haskell for the last couple months.
01:00:03 <edwardk> kor: =)
01:00:11 <vincenz> edwardk: likewise :)
01:00:17 <edwardk> kor: i mostly meant it as a dig at his old-school imperative leanings ;)
01:00:44 <edwardk> ml always seems like its so close to being haskell, but then you find all these crufty keywords floating around.
01:00:47 <vincenz> tim sweeney, who is that?
01:00:59 <edwardk> vincenz: guy who runs epic megagames, wrote unreal, zzt, etc.
01:01:01 <vincenz> edwardk: not to mention the lack of TCs! and non first class data-cons!
01:01:16 <vincenz> oh yeah, that guy, I read his presentation on functional programming in gamems
01:01:18 <edwardk> a poor man's john carmack ;)
01:01:28 <Korollary> vincenz, edwardk : do you miss the module systems?
01:01:31 <vincenz> it was on LtU
01:01:41 <edwardk> kor: not much really.
01:01:55 <vincenz> Korollary: not really... for simple modules, haskell has modules, for functors, TCs are a lot less spammy
01:02:04 <edwardk> kor: i mean yes, but clas associated types will clean up the only niggling use i have for them now i think
01:02:52 <vincenz> I have teo say that another big win in haskell are automated derivations for Read/Show
01:03:00 <vincenz> that saves up a lot of code at times
01:03:19 <vincenz> (imagine testing a lexer and wanting to output the tokens..)
01:03:40 * edwardk nods.
01:03:44 <Cale> okay, 29.34 secs for the infinite version and 25.19 secs for the finite, on length (permutations [1..11])
01:03:49 <Cale> so I think that's decent enough
01:03:54 <edwardk> cale: respectable
01:04:01 <vincenz> > perms [1..11]
01:04:02 <lambdabot>  Not in scope: `perms'
01:04:08 <int-e> Cale: what if you force all elements?
01:04:12 <edwardk> cale: how does it compare for lots of iterations on small sets?
01:04:25 <vincenz> Cale: I propose the following rule:
01:04:41 <vincenz> forall n . length (permutation [1..n]) == fac n
01:04:49 <vincenz> use that as a GHC rule and you should get a lot more gains :)
01:04:53 <int-e> vincenz: don't start.
01:05:03 <vincenz> int-e: start what?
01:05:04 <Cale> vincenz: hehe :)
01:05:16 <int-e> vincenz: it's a can of worms. next you'll want sum (enumFromToBy a b c) = ...
01:05:28 <vincenz> oh rightio :)
01:05:30 <edwardk> int-e: heh i'll happily contribute them =)
01:05:41 <vincenz> a LOT of ghc rules for usecases that nearly never happen
01:05:43 * vincenz snickers
01:05:46 <edwardk> at least for pathological cases
01:06:01 <Cale> int-e: do you suppose that length . map length would do that?
01:06:07 <int-e> and then lots of people will write code that has abysmal performance on any other compiler, for silly reasons like this
01:06:12 * edwardk did a course on classical analysis, i have a pretty long laundry list of them worked out somewhere
01:06:13 <vincenz> Cale: I doubt it
01:06:23 <vincenz> Cale: you could first force map length by summing
01:06:23 <Cale> vincenz: yeah, I'm doubting it too :)
01:06:27 <int-e> Cale: sum (map sum)
01:06:30 <Cale> okay
01:06:31 <int-e> Cale: as an idea
01:06:46 <Cale> yeah, that'll be more certain :)
01:06:53 <vincenz> well you don't need to force the actual elements
01:06:55 <vincenz> just list positions
01:06:58 <vincenz> sum (map length)
01:07:28 <int-e> yes, okay. that'll do in this case
01:08:27 <vincenz> forall l . length (concat l ) = sum (map length l)
01:08:41 <int-e> Cale: I'd be curious how that compares to the selection version, because interleave is an O(k^2) operation.
01:08:52 <vincenz> oh wait
01:08:56 <vincenz> I have another perms version
01:08:59 <Cale> that's a stack overflow for anything respectably large though
01:09:13 <vincenz> hm
01:09:22 <vincenz> nm, my only gives one random permutation
01:09:28 <Cale> perhaps I should just do a seqList
01:09:30 <kosmikus> ?hoogle delay
01:09:30 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
01:09:31 <lambdabot> Network.Socket.NoDelay :: SocketOption
01:09:31 <lambdabot> System.Win32.File.mOVEFILE_DELAY_UNTIL_REBOOT :: MoveFileFlag
01:09:31 <vincenz> @where paste
01:09:32 <lambdabot> http://paste.lisp.org/new/haskell
01:09:45 <int-e> oh, stupid sum
01:09:50 <int-e> foldl' (+) 0 ?
01:10:07 <vincenz> why '?
01:10:14 <int-e> strictness
01:10:17 <Cale> yeah
01:10:18 <lisppaste2> vincenz pasted "Random Permutation" at http://paste.lisp.org/display/25032
01:10:33 <Cale> the default sum builds up large expressions in memory
01:11:07 <int-e> and can not be changed because that could change the behaviour for some funny Num instances.
01:11:23 <edwardk> joy
01:11:47 <edwardk> non-commutative ones or something?
01:12:06 <vincenz> > let removeAt 0 (x:xs)  = (x,xs); removeAt n (x:xs) = let (e, ys) = removeAt (n-1) xs in (e, x:ys) in removeAt 5 [1..]
01:12:08 <lambdabot>  (6,[1,2,3,4,5,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
01:12:34 <int-e> edwardk: hmm, imagine adding +Infinity
01:12:49 <int-e> edwardk: there's no contract that says a Num instance must be a ring. :/
01:12:52 <edwardk> int-e: k
01:13:13 <edwardk> int-e: damn broken numerical tower ;)
01:13:43 <vincenz> cale looked at the perm thingy?
01:16:19 <int-e> > foldl1 (flip const) [undefined, undefined, 1]
01:16:20 <lambdabot>  1
01:20:36 <vincenz> edwardk: lol, checked the pulse of #oasis?
01:20:42 * vincenz wasn't here hence the silence :P
01:21:09 <edwardk> vincenz: not in a while =)
01:21:16 * vincenz was gone on vacation for 2 weeks
01:21:49 <edwardk> i had just noticed it dropped off to where the only traffic was me for a whie
01:21:55 <edwardk> so i stopped showing up =)
01:53:36 <therp> I wonder if a haskell frontend could be implemented that makes haskell look like full-parenthesised lisp syntax. as far I understand GHC has a good modularisation between frontend and backends and all the stuff in between :), so implementing another frontend.. hmm is this feasible?
01:55:40 * apfelmus shudders when even thinking about full parenthesis-mania
01:55:44 <ibid> therp: of course it is. it's just a lot of hard work
01:58:29 <therp> unfortunately, I don't have much clue about ghc's internals.. :/
02:01:04 <dons> re.
02:01:48 <dons> maybe not even that much hard work..
02:02:10 <dons> a couple of weeks? less?
02:02:19 <edwardk> therp: it already has it, its called template haskell. =)
02:02:41 <therp> uh sounds spooky, let me ask google about it
02:02:50 * edwardk runs away
02:14:06 <profmakx> okay
02:14:18 * profmakx is going to write a paper about semantics of smileys
02:14:25 <profmakx> smilies
02:15:45 <nilsi> @quote
02:15:45 <lambdabot> S.Behrens says: Computer science is the womanizer, and math is the pure-hearted girl he won't call the next day.
02:16:00 <vincenz> dons: what's the @command for the guy that was so annoying? I forgot his nick
02:16:13 <dons> which guy? there's so many?
02:16:16 <dons> ?protontorpedo
02:16:17 <lambdabot> wat is lazy evaluation?
02:16:20 <profmakx> lol
02:16:22 <vincenz> yay!
02:16:25 <vincenz> @proton
02:16:25 <lambdabot> what echniques can be used to scael application in haskell?
02:16:43 <vincenz> @proton
02:16:44 <lambdabot> how do we automate ftp file transfers with haskell?
02:17:08 <dons> to think that he kept that up for 10 months...
02:17:54 <dons> cool. /me watches news article about bionic eye implants
02:19:34 <dons> using a 100 pixel binding to the retina.
02:20:47 <norpan> dons: wow
02:21:24 <profmakx> dons, i think they are working on such things here in aachen too
02:22:11 <dons> so then we just hook up ultraviolet, infra red and xray cameras and see through walls
02:22:22 <profmakx> and clothes!
02:22:23 <profmakx> hooray
02:22:25 <vincenz> dons: they had something similar to stick to your forehead so you could 'feel' images
02:22:59 * vincenz wonders what would happen if you took a UV, IR, or Xray picture of a monitor
02:23:16 <vincenz> a CRT one
02:23:32 <profmakx> xray should worjk
02:23:34 <profmakx> sort of
02:23:44 <vincenz> depends on how much the monitor emits
02:23:54 <vincenz> maybe you could reaad monitors through walls :)
02:24:19 <profmakx> which is what some people do all the time
02:24:22 <profmakx> damn my vocabulary
02:24:24 <profmakx> damnit
02:24:38 <dons> you wouldn't need a monitor.. you could just read the bytes directly in the cpu and off the magnetic disk ;)
02:25:12 <vincenz> dons: that's like trying to decipher what a program does by looking through a peephole of several assembly instructions...
02:25:19 * vincenz shudders
02:25:29 <dons> :) a 3Ghz too!
02:25:33 <dons> s/at/
02:25:52 <vincenz> there's a reason computers have peripherals like monitors!
02:26:22 <nilsi> hardware firms that want to sell them
02:26:25 <dons> humans are a gunky heavyweight ffi to call into
02:27:04 <profmakx> and slow also
02:27:14 <nilsi> let's write humans in haskell
02:27:31 <dons> a good idea!
02:27:36 <dons> think of the efficiency gains
02:27:45 <profmakx> prove properties of women
02:27:47 <profmakx> right
02:27:49 <profmakx> i am in!
02:27:58 <vincenz> erm, I don't think haskell is lazy enough to code humans
02:28:04 <dons> no heavy ffi overhead to transfer data. no slow marshalling of data to um... paper...
02:28:09 <nilsi> and the space leaks ... (he is not dead, he calculates ..)
02:28:14 <dons> heh
02:28:42 <vincenz> damn
02:28:48 <vincenz> they can really read a lot of data from a fly's brain
02:28:51 <vincenz> http://www.newscientisttech.com/article.ns?id=dn9879&feedId=online-news_rss20
02:28:54 <lambdabot> Title: 'Fly-vision' sheds light on murky videos - tech - 30 August 2006 - New Scientist ...
02:29:03 <vincenz> "Brinkworth was conducting experiments that involved recording the activity of fly brain cells as they were shown different images. "We were amazed at the extra detail they were able to extract from the dark parts of a scene,""
02:29:15 <vincenz> they can detect the amount of detail a fly detects in images o.O
02:32:28 <JaffaCake> audreyt: there?
03:05:49 <xerox> ?yow!
03:05:50 <lambdabot> YOW!!!  I am having fun!!!
03:16:06 <audreyt> JaffaCake: yo
03:16:14 <JaffaCake> hi there
03:16:34 <audreyt> long time no see... sadly I'll be in OOPSLA not ICFP
03:16:36 <JaffaCake> regarding your FreeBSD build of 6.6, you were experiencing random crashes right?
03:16:43 <audreyt> no, not so
03:16:54 <audreyt> I was experiencing consistent segfault upon ghci exit
03:17:00 <audreyt> I mean ghc exit
03:17:09 <JaffaCake> ah, interesting, I haven't seen that
03:17:10 <audreyt> but removing -threaded from Makefile.ghcbin fixed that.
03:17:21 <JaffaCake> however, I have committed a patch that might help
03:17:25 <audreyt> I tried all four thr libs
03:17:35 <JaffaCake> any chance you could pull and see if it helps?
03:17:35 <audreyt> and built from darcs trunk this morning -- that's 15 hours ago
03:17:40 <audreyt> sure
03:17:56 <audreyt> oh, and the changelog mentions the 15-tuple-instance thing twice
03:17:58 <JaffaCake> shame you won't be able to make it to ICFP :(
03:18:05 <JaffaCake> ok, ta
03:18:28 <audreyt> and there's some random typos I can't remember... hm, is it possible to ask for a commit bit so I can fix trivial things like this? :)
03:18:39 <audreyt> oh, and for some reason ghc_ge_605 check isn't on
03:18:46 <audreyt> so I had to add regex-compat manually
03:18:58 <JaffaCake> commit bit - sure
03:18:59 <audreyt> when compiling -HEADwith three day ago's -HEAD
03:19:33 <JaffaCake> send me an SSH key
03:20:48 <audreyt> http://perlcabal.org/~audreyt/id_dsa.pub
03:21:08 <audreyt> only one outstanding new patch in ghc:
03:21:09 <audreyt>   * don't closeMutex() the Capability lock
03:21:12 <audreyt> you mean this one, right?
03:21:25 <JaffaCake> yep
03:21:44 <audreyt> ok, uncommenting
03:21:44 <audreyt> SRC_HC_OPTS += -threaded
03:21:53 <JaffaCake> just fixed the ghc_ge_605 thing - guess I forgot to add or commit it before
03:22:27 <audreyt> nope.
03:22:34 <audreyt> [not|root]~/work/ghc/compiler/stage2# gdb ./ghc-6.5
03:22:38 <audreyt> run
03:22:42 <audreyt> Program received signal SIGSEGV, Segmentation fault.
03:22:42 <audreyt> [Switching to Thread 0x89ff000 (LWP 100135)]
03:22:42 <audreyt> 0x289c816b in pthread_cond_destroy () from /usr/lib/libthr.so.2
03:22:48 <audreyt> #1  0x088afd8b in stopTaskManager ()
03:22:50 <JaffaCake> you compiled the RTS and then re-linked stage 2?
03:22:52 <audreyt> #7  0x088ac4ba in exitScheduler ()
03:23:01 <audreyt> I simply relinked.
03:23:16 <audreyt> recompiling rts
03:23:34 <audreyt> relinked
03:23:44 <audreyt> same error
03:23:51 <JaffaCake> right, I'll go poke around some more
03:24:01 <audreyt> (recipe was "gmake rts" on ghc root, then rm stage2/ghc-6.5, then gmake stage2
03:24:02 <audreyt> )
03:24:02 <JaffaCake> strange it doesn't happen for me - what vsn of FreeBSD is this?
03:24:10 <audreyt> FreeBSD 6.1-STABLE #24: Thu Aug 31 01:49:26 CST 2006     root@my.audreyt.org:/usr/src/sys/i386/compile/NOT
03:24:35 <audreyt> might not be your problem, really :)
03:24:53 <JaffaCake> maybe not, but I'd like to be sure
03:25:06 <JaffaCake> if it's not our problem we can disable the threaded RTS on FreeBSD
03:25:33 <audreyt> forghc only
03:25:39 <audreyt> or for all programs?
03:25:45 * mux hearts opera
03:25:53 <mux> what's the problem with FreeBSD?
03:25:59 <audreyt> I guess for all progs
03:26:06 <JaffaCake> well, if it's hosed, then there's no point supplying it at all
03:26:07 <mux> I can probably help
03:26:08 <audreyt> as a simple "hello world" when linked with -threaded exhibits same error
03:26:12 * mux puts on his FreeBSD hat
03:26:35 <audreyt> mux: I'm seeing strange segfaults (see above) when running with GHC -head RTS with -threaded.
03:26:38 <audreyt> upon program exit
03:26:50 <JaffaCake> mux: not sure yet, but the threaded RTS in GHC 6.6 crashes for audreyt
03:26:51 <audreyt> consistently with libthr, libpthr, liblthr, and c_r.
03:27:18 <JaffaCake> audreyt: I do have a fresh build on FreeBSD 6.1 here, doesn't do it for me
03:27:21 <mux> do you have any debugging info besides what's in my log?
03:27:26 <JaffaCake> but I have seen occasional crashes
03:27:41 <audreyt> JaffaCake: yeah, so prolly not your bug. otoh, this is RELENG_6, not 6.1-RELEASE
03:27:50 <JaffaCake> right
03:28:03 <audreyt> can the ghc build process maybe probe for this
03:28:06 <mux> there haven't been any changes in the threading libs in RELENG_6 that I'm aware of
03:28:08 <audreyt> and disable -threaded? Pugs does that
03:28:15 <mux> and I pretty damn should be aware of it if there had been
03:28:35 <mux> if you can pinpoint specific problems with our threading implementation I'd like to know about it ASAP
03:28:43 <mux> so that I can possibly fix those for 6.2-RELEASE
03:28:44 <JaffaCake> mux: thanks
03:28:44 <audreyt> mux: I'll make a fresh world and see if it goes away.
03:28:52 <mux> (we're going to start the code freeze pretty soon now)
03:29:06 <JaffaCake> mux: libpthread has problems, we reported on threads@freebsd.org recently
03:29:15 <mux> what kind of problems?
03:29:27 <mux> I'll look into the archives because I'm not on threads@, but if you can summarize it here
03:29:28 <JaffaCake> causes occasional hangs in GHC
03:29:52 <mux> are you positively sure that those problems are due to the FreeBSD side of things?
03:29:59 <JaffaCake> we didn't find the root cause, but saw some kernel APIs being called with invalid args using ktrace
03:30:07 <JaffaCake> brb
03:30:25 <mux> that kind of corruptions could come from pretty much anywhere
03:30:56 <mux> blah, $REAL_WORK kicks in
03:31:26 <mux> JaffaCake, audreyt: don't hesitate to mail me (mux@freebsd.org) if you find anything specific and clearly related to FreeBSD, or if you have some more info about those problems
03:31:53 <mux> TIA!
03:35:52 <JaffaCake> audreyt: ack!  I think I found it
03:36:11 <JaffaCake> do you have any custom malloc settings on your box?
03:37:08 <audreyt> possibly. problem is I havn't been using this box in months
03:37:09 <mux> JaffaCake: changing malloc.conf helps?
03:37:19 <audreyt> (I dropped my macbook and it's now broken :/)
03:37:24 <JaffaCake> audreyt: line 79 of rts/Task.c
03:37:27 * mux tries to deal with boss on one side and IRC on the other side
03:37:47 <JaffaCake> somebody is calling pthread_cond_destroy() after freeing the enclosing struct, duh
03:37:48 <audreyt> surely you mean 81
03:37:49 <mux> stgFree(task) ?
03:37:53 <mux> ah, yes
03:37:57 <beelsebob> audreyt: :o
03:38:06 <audreyt> beelsebob: greetings
03:38:18 <beelsebob> one drop and it broke?
03:38:23 <beelsebob> remind me to be careful of mine
03:38:57 <mux> for the record, our pthread mutexes are PTHREAD_MUTEX_ERRORCHECK by default
03:39:23 <audreyt> beelsebob: it dropped from nearly 2m
03:39:30 <JaffaCake> mux: that's handy to know
03:39:39 * mux nods
03:39:43 <beelsebob> audreyt: how'd you do that?
03:39:46 <audreyt> and I think only the HD scratched, though they are still trying to determine if the motherboard broke as well
03:39:52 <audreyt> beelsebob: by IRC'ing during shower.
03:39:53 <mux> are the pthread_mutex_lock() calls checked?
03:40:00 <mux> many people don't error check those
03:40:07 <JaffaCake> mux: when DEBUG is on, yes
03:40:07 <beelsebob> rofl
03:40:12 <xerox> JaffaCake: hello! Question: are patches to cabal still in time to make it to 6.6?
03:40:12 <mux> ok
03:40:28 <JaffaCake> xerox: probably not, but if its simple and gets to me today, maybe
03:40:41 <audreyt> JaffaCake: oh. Typeable Key is now shared right?
03:40:46 <audreyt> and the comments in Typeable.hs is outdated?
03:40:46 <JaffaCake> yep
03:40:53 * JaffaCake looks
03:40:55 <xerox> JaffaCake: mainly the patches I mailed to the list, I still have no access to push them, and I'Ã¬ll have another today.
03:41:02 <xerox> JaffaCake: all cabal-install related.
03:41:12 <JaffaCake> xerox: on cabal-devel?
03:41:16 <audreyt> and does that mean we can somehow get an Int from a TypeRep? as a GHC.Exts maybe? pretty  please? :)
03:41:17 <xerox> JaffaCake: right.
03:41:25 <JaffaCake> I'll take a look later
03:41:27 <mux> JaffaCake: ok I need to go again, please keep me posted on that one
03:41:30 <xerox> Thank you, JaffaCake.
03:41:32 <audreyt> <- in both Pugs and $job uses (Show TypeRep) for Map String a
03:41:43 <xerox> JaffaCake: I'll mail to the list the one I've not sent yet ASAP.
03:41:52 <JaffaCake> audreyt: I'll try
03:41:52 <audreyt> if it can be made IntMap, I imagine things will be much, much faster.
03:42:00 <audreyt> JaffaCake: thanks so much :)
03:42:38 <SamB> why do you say $job? env vars are supposed to look like $JOB
03:43:13 <audreyt> in perl that would mean it's a module-scoped mutable variable...
03:43:19 <audreyt> whereas $job would be lexical
03:43:35 <SamB> but, I think $JOB is like $HOME, an environment variable!
03:43:47 <audreyt> export JOB=Asia/India
03:45:32 <JaffaCake> audreyt: could you try moving that stgFree() and see if it helps?
03:46:27 <audreyt> remaking
03:46:29 <audreyt> relinking
03:47:16 <audreyt> It worked! If you see this, JaffaCake's suggested bugfix has worked correctly.
03:47:20 <audreyt> :))
03:47:26 * JaffaCake does a little dance
03:47:32 <xerox> @karma+ JaffaCake
03:47:32 <lambdabot> JaffaCake's karma raised to 5.
03:47:33 <xerox> :D
03:47:44 <JaffaCake> it wasn't my bug either :)
03:47:58 <audreyt> so stgFree is not supposed to happen there?
03:48:11 <audreyt> or is it supposed to happen after closeCondition/closeMutex?
03:48:18 <JaffaCake> yes, the latter
03:48:32 <audreyt> for somereason that makes perfect sense
03:48:48 <mux> ah, so that was a GHC bug?
03:48:55 <audreyt> moving it to latter also worked.
03:49:03 <audreyt> #if defined(THREADED_RTS) closeCondition(&task->cond); closeMutex(&task->lock);
03:49:03 <audreyt> #endif stgFree(task);
03:49:08 <JaffaCake> mux: yes
03:49:12 <audreyt> like that. (modulo the linebreak)
03:49:14 <mux> doing development under FreeBSD is a very good way to find bugs :-)
03:49:23 <JaffaCake> mux: but the earlier problems still stand
03:49:24 <audreyt> as it's very much intolerating and cruel?
03:49:24 <mux> many of our APIs are more strict than those found on other unices
03:49:26 <mux> ah
03:49:49 <mux> we've had a long history of application crashes that were due to bad malloc() usage for instance, that didn't show up on Linux or elsewhere
03:50:01 <JaffaCake> mux: we're using libthr at the moment, it's been more reliable for us than libpthread
03:50:55 <JaffaCake> I heard there was murmerings about switching to libthr by default, and maybe even ditching libpthread altogether
03:51:04 <mux> maybe that will happen yes
03:51:10 <mux> there are hot internal debates about this
03:51:22 <mux> KSE has basically been a total failure
03:51:37 <JaffaCake> heh, on the list people are more diplomatic than that :)
03:51:38 <mux> of course that's not an official POV of the project ;-)
03:51:41 <mux> yes
03:51:47 <mux> for obvious reasons
03:52:05 <JaffaCake> KSE doesn't help GHC at all, since we have our own threading layer in the RTS
03:52:06 <mux> I'm also exagerating slightly
03:52:37 <mux> libthr gained mutex priority propagation in HEAD recently
03:52:44 <mux> or maybe not even in HEAD, but david xu implemented it in p4
03:52:54 <mux> that was a big missing point
03:53:27 <mux> it turns out that we might end up drawing the same conclusions than Sun on 1:1 threading vs M:N threading
03:54:19 <mux> M:N threading and SAs are hot on the paper, but there are practical problems with it
03:54:22 <mux> I don't know the specifics
03:56:37 <JaffaCake> right, I think it's one of those cases where the extra complexity doesn't justify the gains
03:57:03 <mux> yeah, and upcalls are more expensive than expected too
03:57:24 <JaffaCake> in GHC, our Haskell threads are an order of magnitude or two cheaper than even KSE threads, I think we've found a better place to add a layer of user-level scheduling
03:57:36 <mux> I think there's a way to make all of this work nicely, but it'll require someone to bang his head hard on this stuff, and this may never happen
03:57:49 <mux> you should compare with libc_r for that kind of things
03:57:56 <mux> libc_r has 0 syscalls context-switching
03:58:13 <audreyt> JaffaCake: #880
03:58:14 <musasabi> optimizing simple code is usually easier.
03:58:18 <JaffaCake> hmm, that's the old pre-KSE threading implementation?
03:58:22 <mux> yes
03:58:28 <JaffaCake> does it scale to SMP?
03:58:30 <mux> entirely userland implementation
03:58:31 <audreyt> # http://hackage.haskell.org/trac/ghc/ticket/880
03:58:32 <mux> no :-)
03:58:33 <lambdabot> Title: #880 (someFunction :: TypeRep -&gt; Int) - GHC - Trac
03:58:43 <mux> it's 1:M
03:59:09 <mux> the kernel has no knowledge of the threads since it's all userland, so it's seeing things as one process, and thus it's not SMP scalable
03:59:17 <JaffaCake> audreyt: thanks!
03:59:38 <audreyt> np, and thank _you_ :) afk, bbiab
04:00:32 <mux> ok, this time I'm really gone for eating
04:00:43 <mux> as I said, please keep me posted on that stuff if possible!
04:00:52 <JaffaCake> mux: libc_r wouldn't really help us, I think, but it might be a good comparison speed-wise
04:01:04 <mux> yeah, I was only saying that for speed-comparison purposes
04:01:15 <JaffaCake> ok thanks, catch you later
04:01:23 * JaffaCake is off for lunch too
04:01:24 <mux> since it's all userland, it's a fairer comparison
04:01:27 <mux> see you!
04:01:28 * mux &
04:07:29 * xerox wanders off to lunch
04:28:12 <vincenz> audreyt: irc-ing in the shower???
04:28:15 * vincenz just read the backlog
04:40:10 <dmwit> So these two cows were in a field.
04:40:20 <dmwit> Then one of them looks around a little bit and wanders off.
04:43:30 <ProfTeggy> ...and?
04:43:52 <vincenz> The other cow mooed"
05:06:21 <kpreid> @localtime dons
05:06:23 <lambdabot> Local time for dons is Thu Aug 31 22:03:06 2006
05:07:24 <kpreid> @tell dons No, not around. Our schedules overlap only in my evening, apparently.
05:07:25 <lambdabot> Consider it noted.
05:07:40 <kpreid> @type fmap
05:07:42 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
05:08:27 <kpreid> @free foo :: forall (a :: *). a -> a
05:08:27 <lambdabot> Expected variable or '.'
05:08:48 <kpreid> @run (\x -> x) :: forall (a :: *). a -> a
05:08:48 <lambdabot>  Parse error
05:08:56 <kpreid> @run (\x -> x) :: forall a. a -> a
05:08:57 <lambdabot>  Parse error
05:09:13 <kpreid> @free foo :: forall a. a -> a
05:09:13 <lambdabot> f . foo = foo . f
05:09:54 <kpreid> @tell dons the problem is not precisely in my patch: @free's parser doesn't like kind annotations
05:09:55 <lambdabot> Consider it noted.
05:10:25 <kpreid> @tell dons (so it does the same if you supply fmap's type explicitly)
05:10:26 <lambdabot> Consider it noted.
05:10:30 <Cale> @free foo :: a -> b
05:10:31 <lambdabot> g . foo = foo . f
05:11:11 * kpreid is done
05:11:52 <Cale> @free x :: (a -> b) -> (a,a) -> (b,b)
05:11:53 <lambdabot> g . h = k . f => ( f ($proj_2_1 x) = $proj_2_1 y   &&   f ($proj_2_2 x) = $proj_2_2 y ) => ( g ($proj_2_1 (x h x)) = $proj_2_1 (x k y)   &&   g ($proj_2_2 (x h x)) = $proj_2_2 (x k y) )
05:15:24 <xerox> @slap paolino
05:15:24 * lambdabot smacks paolino about with a large trout
05:17:20 <ell-hask> @slab ell-hask
05:17:20 * lambdabot beats up ell-hask
05:17:25 <ell-hask> @slap ell-hask
05:17:25 * lambdabot smacks ell-hask about with a large trout
05:17:34 <ell-hask> That will wake you up in the morning!
05:17:57 <sieni> @slap lambdabot
05:17:57 <lambdabot> why on earth would I slap lambdabot
05:18:48 <SamB> @slap lambdabot
05:18:49 <lambdabot> why on earth would I slap lambdabot
05:18:50 <SamB> @slap lambdabot
05:18:51 <lambdabot> why on earth would I slap lambdabot
05:18:53 <SamB> @slap lambdabot
05:18:53 <lambdabot> why on earth would I slap lambdabot
05:18:57 <SamB> hmm...
05:19:15 <xerox> WHY!
05:19:21 <xerox> Give her a reasonable reason.
05:19:29 <vincenz> @slap lambdabot for being inane
05:19:30 * lambdabot smacks lambdabot for being inane about with a large trout
05:19:42 * xerox giggles
05:20:46 <Stinger_> error : does not parse :P
05:23:26 <sieni> @slap lambdabot foo bar baz
05:23:27 <lambdabot> why on earth would I slap lambdabot foo bar baz
05:23:39 <sieni> @slap lambdabot for bar baz
05:23:40 * lambdabot slaps lambdabot for bar baz
05:24:05 <sieni> <3
05:24:29 <vincenz> <3 = ?
05:24:48 <sieni> heart emoticon
05:25:03 <vincenz> looks more like an ass with a heart, otherwise said, a dunce
05:25:34 <sieni> well, of course if you say like <3=3, then it probably doesn't refer to a heart ^_^
05:37:33 * boegel sees boobs in <3=3, am I the only one?
05:38:13 <Stinger_> yes :P
05:38:35 <sieni> boegel: yes
05:38:41 * boegel runs off crying
05:39:47 <sieni> It's an ascii adaptation of the Love Records logo: http://www.lovemusic.fi/
05:39:49 <lambdabot> Title: Love Kustannus
06:02:33 <xerox> http://lukeplant.me.uk/blog.php?id=1107301645
06:02:35 <lambdabot> Title: Why learning Haskell/Python makes you a worse programmer
06:04:50 <dons> haskell/python eh? heh "    I find I think in Python, and even in Haskell to some extent, even though I have used Haskell
06:04:51 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
06:04:54 <dons>     very little. I constantly find myself wanting to use idioms from these languages"
06:05:07 <beelsebob> xerox: I don't think that's really a valid argument
06:05:15 <Igloo> dons: Somehow I'd never noticed that your middle name is "Bruce" before
06:05:30 <beelsebob> he is essentially saying "I know I can write better code in Haskell and Python and this makes the code I write in C# worse"
06:05:38 <dons> Igloo: well it is!
06:05:38 <xerox> beelsebob: it's half sad half sarcasm
06:05:47 <beelsebob> yes... it's worse than the Haskell code, but it's just as good as the original C#
06:05:51 <xerox> beelsebob: I think
06:06:00 <beelsebob> makes sense
06:06:02 <Igloo> dons: That's made my day  :-)
06:06:20 <xerox> dons: good point about the title
06:06:27 * dons gives Igloo a strange look
06:08:36 <dons> isn't the moral of that blog that he should just write in haskell?
06:17:26 <dons> Igloo: i think that mail is quite reasonable. I'll add some thoughts in the morning
06:18:09 <Igloo> Cool, ta
06:24:18 * Igloo gets confused by trac
06:24:42 <Igloo> accepting and assigning seem to actually be orthogonal, but you can only do one at a time AFAICS
06:27:24 <Igloo> and if I understand the SQL correctly then a status of "assigned" seems to mean "accepted"
06:35:55 <vincenz> seq forces evaluation, correct?
06:36:23 <vincenz> is it me or is scanl not stack-safe?
06:36:51 <vincenz> @type scanr
06:36:53 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> [b]
06:37:01 <vincenz> @type scanl
06:37:02 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
06:37:28 <norpan> i'd say it's about as stack-safe as foldl
06:37:52 <norpan> whatever you mean by stack-safe
06:38:16 * vincenz tries scanr
06:39:06 <vincenz> nope
06:39:08 <vincenz> scanl is what I need :/
06:39:38 <dons> stick a seq in the accumulator
06:39:41 * vincenz is getting stack explosion for some reason
06:39:49 <vincenz> dons I did :
06:39:59 <dons> i.e. following foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
06:40:33 <vincenz> should I just define a scanl'?
06:40:45 <vincenz> I placed seq's inside the f
06:40:47 <vincenz> but that doesn't seem to help
06:41:04 * SamB wants a wordly diff algorithm that places less importance on words like "of" and "the" then on rarer words...
06:41:25 <vincenz> @paste
06:41:25 <lambdabot> http://paste.lisp.org/new/haskell
06:41:33 <lisppaste2> vincenz pasted "stackblow" at http://paste.lisp.org/display/25039
06:41:39 <SamB> maybe one that considers paragraphs and sentances, too...
06:42:10 <wolverian> sentences ..
06:42:17 <SamB> whatever
06:42:17 <vincenz> I had seq's in the blocks and footprints assignments
06:42:19 <vincenz> to no avails
06:43:54 <vincenz> dons: suggestions?
06:44:06 <vincenz> analyz ... = s `seq` ...
06:44:08 <vincenz> doesn't do it either
06:45:36 <vincenz> oh
06:45:40 <vincenz> wait foldr 0 max is doing it
06:45:54 <vincenz> erm foldr max 0
06:45:59 <vincenz> > maximum [1..10]
06:46:00 <lambdabot>  10
06:46:02 <dons> http://www.cs.mu.oz.au/~bjpop/timeline/timeline.4.png
06:46:08 <kpreid> dons: oh, what I said about schedules? never mind, apparently
06:46:24 <dons> :)
06:47:11 <ndm> its lacking hoogle :)
06:47:12 <lambdabot> ndm: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:49:09 <ndm> @tell kowey I can gurantee that until Windows users can use wxHaskell, your support time will be reduced along with your users :) - Releases can happen whenever, but compiler support should always be there
06:49:10 <lambdabot> Consider it noted.
06:49:25 <dons> what's this?? "Sascha Boehme, a student of mine, has done a project to implement the
06:49:28 <ValarQ> it's also lacking #Haskell
06:49:28 <dons> Reynolds/Wadler algorithm generating theorems from polymorphic types,
06:49:31 <dons> plus simplifications and postprocessings for such free theorems. "
06:49:39 <dons> didn't lambdabot beat this work by 7 days?
06:49:49 <ndm> dons: where is that comment?
06:50:10 <dons> haskell@, "Janis Voigtlaender   [Haskell] Announce: FreeTheorems library and tools"
06:50:16 <dons> ?where free
06:50:17 <lambdabot> http://andrew.bromage.org/darcs/freetheorems
06:50:25 <ndm> thats disturbing, 7 days later is suspicious
06:50:42 <xerox> dons: wow!
06:50:43 <dons> heh no. I doubt it :)
06:50:57 <ndm> dons: although seriously, I would have thought #haskell should probably be on that timeline
06:51:27 <dons> yeah maybe. you could reply to spj's mail asking for feedback?
06:52:26 <vincenz> @type foldr'
06:52:27 <lambdabot> Not in scope: `foldr''
06:52:30 <vincenz> hmm
06:52:32 <Philippa> djinn was a separate project that got integrated fast, no?
06:52:50 <vincenz> @type foldl'
06:52:51 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
06:52:58 <vincenz> @hoogle foldl'
06:52:59 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
06:53:10 <ndm> dons: their theorems for free thing is better than yours
06:53:45 <vincenz> > foldr max 0 [1..1000]
06:53:46 <lambdabot>  1000
06:53:53 <vincenz> > foldr max 0 [1..1000000]
06:53:55 <lambdabot>  Exception: stack overflow
06:53:57 <vincenz> aha
06:53:59 <ndm> dons: or so it appears at first glance
06:54:03 <vincenz> > foldl' max 0 [1..1000000]
06:54:05 <lambdabot>  1000000
06:54:18 <vincenz> dons: stack overflow was due to foldr max
06:55:00 <dons> ndm, i wouldn't be surprised. Janis has published several papers on free theorems. Pseudonym wrote @free in 1 day :)
06:55:28 <ndm> although yours does seem to have some better features
06:56:06 <xerox> o_O
06:56:51 <Igloo> Is there an obvious way to write a test for foldr/build fusion not happening that I'm missing?
06:57:38 <ndm> Igloo: can you get notification on garbage collection?
06:58:10 <Igloo> ndm: Ideally it would be independent of knowledge of the compiler
06:58:22 <dons> Igloo: testing for rules firing is hard
06:58:29 <ndm> Igloo: from what i know, the only thing you'd see is it going faster
06:58:29 <dons> you need to check the output of -ddump-simpl
06:58:47 <ndm> making it -ddump-simpl is very compiler version specific
06:58:47 <dons> (that's how we check all the ndp/bytestring stuff fuses)
06:59:48 <dons> Igloo: Roman L might have some ideas, he wrote some tools for checking for fusion firing for the ndp branch
06:59:59 <dons> rl @ cse.unsw.edu.au
07:00:41 <dons> having a nice robust way to check for rules firing would be useful :)
07:00:49 <Igloo> I thought about linking with a different list library with a trace in the constructors, but (a) that would affect strings being printed etc and (b) can't easily do that as they're constructors rather than functions
07:01:15 <dons> well, the -ddump-simpl output just prints the string you name each RULE
07:01:20 <Igloo> ta dons
07:01:22 <dons> so it wouldn't be too hard to check that
07:01:53 <Igloo> I really want to check the result as I'd like to be able to try different fusion rule sets
07:02:16 <dons> $ ghc -ddump-simpl-stats -O fuse.hs
07:02:24 <dons> 78 RuleFired
07:02:24 <dons>     9 FPS filter -> fused
07:02:24 <dons>     3 FPS filterS/filterS
07:02:24 <dons>     1 FPS foldl -> fused
07:02:24 <dons>     6 FPS length -> fused
07:03:05 * CosmicRay looks in
07:03:30 <CosmicRay> Igloo: congrats on your new ghc position, btw.  I didn't realize you were doing that the other day when I was asking ghc questions ;-)
07:03:36 <Igloo> heh, ta
07:03:54 <Igloo> How did the alpha testing go, BTW?
07:04:27 <CosmicRay> not all that great.   I duplicated the problem, and either that generated file is indeed correct, or the line/column number that the error references is way off.
07:04:37 <CosmicRay> I attached the file, and a few others, to the bug report.
07:04:49 <CosmicRay> but figuring out why it can't parse that file is probably beyond my abilities.
07:06:18 <CosmicRay> the file is one big huge line, though, so diffing it against other similar files in the source tree is not useful
07:06:39 <Igloo> I think I found it could be parsed by ghc-pkg on another arch
07:06:42 <CosmicRay> if there is some subtle problem -- a missing bracket somewhere or whatnot -- I don't have the patience to do a byte-by-byte comparison manually ;-)
07:06:47 <CosmicRay> ah
07:07:08 <Igloo> Recreatingt he appropriate parser with happy -d and recompiling might be helpful
07:07:25 <ValarQ> @where Free
07:07:25 <lambdabot> http://andrew.bromage.org/darcs/freetheorems
07:07:36 <ValarQ> @what Free
07:07:36 <lambdabot> http://andrew.bromage.org/darcs/freetheorems
07:07:49 <ValarQ> @whatis Free
07:07:49 <lambdabot> http://andrew.bromage.org/darcs/freetheorems
07:08:12 <ValarQ> hmm
07:08:36 <CosmicRay> Igloo: is that easy to do?  I'm not sure I even know where to look in the ghc tree for that.
07:08:56 <CosmicRay> Igloo: btw, I would be willing to give you or whomever a temporary account on my alpha if that would be the most expedient way to track this down.
07:09:03 <CosmicRay> bearing in mind that my alpha is no screamer ;-)
07:09:24 <CosmicRay> Igloo: I would also be willing to try compiling it in stable if you think the environment is the problem.
07:09:26 <ValarQ> what is Free?
07:09:53 <CosmicRay> ValarQ: philosophers have been wondering about that for centuries
07:09:58 <CosmicRay> ValarQ: seriously, I don't know ;-)
07:10:11 <ndm> ValarQ: Theorems for Free, an implementation of that paper
07:10:30 <ValarQ> ok...
07:10:37 <ValarQ> @where theorems for free
07:10:37 <lambdabot> I know nothing about theorems.
07:10:46 <ValarQ> :/
07:10:56 <ndm> @google theorems for free
07:10:59 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/papers/free/free.ps
07:11:22 <ndm> ValarQ: http://haskell.as9x.info/cgi-bin/ftonline.help.pl
07:11:24 <lambdabot> Title: Help on automatic generation of free theorems
07:11:53 <Igloo> CosmicRay: Doing a compile in stable is probably worthwhile as it requires very little person time
07:12:08 <Igloo> CosmicRay: Do you know if alpha has any known gcc issues?
07:12:08 <CosmicRay> Igloo: OK.  I will kick that off soonish then.
07:12:12 <Igloo> cool
07:12:34 <CosmicRay> Igloo: I was trying to remember on that, and I don't *think* so, but I haven't followed alpha-specific unstable issues very closely.
07:12:37 <ValarQ> is that something like djinn?
07:12:44 <CosmicRay> gcc has historically been well-behaved on alpha
07:13:51 <boegel> Alpha? why what when where
07:14:03 <boegel> I'm quite (sort of) familiar with Alpha machines...
07:14:17 <ValarQ> boegel: lucky you...
07:14:51 <CosmicRay> boegel: http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=384514
07:14:54 <lambdabot> Title: #384514 - ghc6: FTBFS on alpha - Debian Bug report logs
07:14:55 <boegel> ValarQ: well, not quite, they're bloody slow compared to new machines... but the architecture is nice and simple, which makes it interesting for research
07:15:15 <CosmicRay> hrmm, and I notice that the file I meant to send to the BTS never showed up.
07:15:42 <CosmicRay> boegel: believe it or not, when I was a college student in 1996, I bought one for my personal workstation.
07:15:54 <CosmicRay> boegel: it is now my personal Asterisk server, among other things ;-)
07:15:54 <boegel> CosmicRay: wow, that was quite expensive then?
07:16:43 <CosmicRay> yes, it was.  $4k or so, if I recall.  but I had been on a string of buying low-end machines that I'd have to replace because they'd die or be hopelessly outdated, and I want something that I'd use for *years*.  plus I had some surplus scholarship and student loan money ;-)
07:16:55 <boegel> CosmicRay: I'm not familiar with installing stuff on it though... they can be a pain because they're not longer maintained in several cases
07:16:59 <CosmicRay> and so here it is, the only machine I've ever used for 10 years
07:17:28 <CosmicRay> Igloo: well, it's building now.  I'll get back to you with the results in a few hours, once we know what they are ;-)
07:17:34 <boegel> CosmicRay: we have two Alpha's at work here, and they're burning cycles as fast as they can for me :)
07:18:12 <CosmicRay> boegel: I concur with your comments.  very nice system, the SRM BIOS is slick, but of course even the best alphas are late-90s tech.
07:18:37 <CosmicRay> boegel: I still chuckle, though, when I think about my 8MB L2 cache on that thing ;-)
07:19:15 <CosmicRay> Igloo: have you ever seen this when compiling ghc 6.5?
07:19:31 <CosmicRay> /usr/bin/ld: cannot find -lHSunix-1.0
07:19:31 <CosmicRay> collect2: ld returned 1 exit status
07:19:31 <CosmicRay> <<ghc: 16294964 bytes, 3 GCs, 185868/185868 avg/max bytes residency (1 samples), 15M in use, 0.00 INIT (0.00 elapsed), 0.04 MUT (0.22 elapsed), 0.01 GC (0.03 elapsed) :ghc>>
07:19:31 <CosmicRay> make[1]: *** [stage1/ghc-6.5] Error 1
07:19:31 <CosmicRay> make: *** [stage1] Error 1
07:19:56 <Igloo> CosmicRay: No
07:20:07 <CosmicRay> boegel: also, IDE sucks on alpha, and so does video (due to lack of AGP slots).  alphas love SCSI though.
07:20:52 <CosmicRay> Igloo: rats.  I'm a little confused about the build process... when I run make, it doesn't appear to try to build HSunix, but yet it obviously wants it for stage1...
07:21:17 <CosmicRay> I'm trying to test out the code I sent in yesterday, and it wasn't working out too well to do that under my existing ghc 6.4 installation
07:21:27 <Igloo> CosmicRay: That tree isn't up-to-date - the unix package is at 1.1 now
07:21:42 <CosmicRay> oh, where's the canonical source for it then?
07:21:52 <Igloo> Oh, sorry, that's the stage1 build
07:21:53 <CosmicRay> I got it from darcs.h.o/packages/unix
07:22:14 <Igloo> What GHC are you compiling with?
07:22:38 <CosmicRay> Igloo: Debian 6.4.2-2 from unstable on i386
07:23:40 <musasabi> CosmicRay: when playing with libraries (even from d.h.o) using darcs can help.
07:23:53 <CosmicRay> musasabi: I am using darcs ;-)
07:23:59 <musasabi> That is how I get things like template-haskell to compile locally.
07:24:03 <musasabi> s/darcs/cabal/
07:24:06 <CosmicRay> ah.
07:24:43 <musasabi> the Makefiles are too scary
07:24:46 <CosmicRay> I tried that, and it wouldn't work out right for a number of reasons.  One is that HsUnixConfig isn't regenerated by the cabal stuff, and another I haven't been able to track down (ghci complains of no such symbol lstat when I try to load the package)
07:24:54 <CosmicRay> so I figured the path of least resistance would be to just build me a new ghc
07:25:59 <Igloo> Does   echo 'main = putStrLn "Foo"' > q.hs; ghc -package unix q.hs -o q    work for you, CosmicRay?
07:26:20 <Igloo> Also, what's the commandline it's running?
07:26:23 <CosmicRay> hold a sec, let me try.
07:27:36 <CosmicRay> ah, weird, that works.
07:27:48 <CosmicRay> why ghci doesn't, I don't know.
07:28:08 <CosmicRay> well, this may be enough for me to test with anyway.
07:28:28 <CosmicRay> I can hack around the HsUnixConfig.h stuff by adding #defines in unix/include/HsUnix.h
07:28:40 <Igloo> CosmicRay: I was trying to work out the ghc-6.5 problem, not the ghci one
07:29:03 <CosmicRay> oh, well congratulations on hacking around the ghci one ;-)
07:29:36 <CosmicRay> I just saw this scroll by on my stable build on alpha:
07:29:42 <CosmicRay> /usr/bin/ghc6 -H16m -O -cpp -Wall -fno-warn-name-shadowing -fno-warn-unused-matches -i../../lib/compat -Rghc-timing    -c Version.hs -o Version.o  -ohi Version.hi
07:29:42 <CosmicRay> Version.hs:2:
07:29:42 <CosmicRay>     Warning: Definition but no type signature for `version'
07:29:42 <CosmicRay> Version.hs:3:
07:29:42 <CosmicRay>     Warning: Definition but no type signature for `targetOS'
07:29:44 <CosmicRay> Version.hs:4:
07:29:46 <CosmicRay>     Warning: Definition but no type signature for `targetARCH'
07:29:53 <CosmicRay> dunno if that's normal, and it probably is harmless...
07:30:04 <Igloo> Sadly normal
07:30:08 <CosmicRay> ok.
07:31:21 <CosmicRay> Igloo: I think that it would be nice to provide Show instances for UserEntry and GroupEntry that would format them as lines in /etc/passwd and /etc/group.  You think a patch for that would be accepted?  I'd probably also like to see those types derive at least Eq.
07:32:33 * Igloo is generally of the opinion that Show and Read should be derived, and pretty-printer and parser instances should cope with pretty stuff
07:33:50 <CosmicRay> Igloo: so if I wrote a patch that does that, and adds a function that prints it in canonical form, that would be better?
07:34:06 <CosmicRay> I'm fine with doing that, though I would say that the colon-separated way really is the canonical way for this stuff.
07:34:29 <ndm> Igloo: what i want is deriving Debuggable - a basic read/show, that you can guarantee isn't broken, when you are trying to debug something
07:35:19 <Igloo> CosmicRay: But then you can't paste the result of show into ghci
07:35:35 <Igloo> ndm: You mean essentially read/show that can't be given as instances?
07:35:50 <ndm> Igloo: yeah, i guess
07:36:03 <ndm> and then save Read/Show for pretty printing/pretty parsing
07:36:22 <musasabi> Read is evil for most things.
07:37:00 <CosmicRay> Igloo: true, but then you can paste it into /etc/passwd ;-)
07:37:34 <Igloo> :-)
07:44:10 <CosmicRay> Igloo: oh, and I swear I am not trying to turn Haskell into Perl.  I leave that to the Pugs team ;-)
07:48:49 <br1> How does locate next error work in emacs' haskell mode?
07:50:53 <bortzmeyer> I use FGL (Data.Graph.Inductive) to find out the components of a graph. But scc or components give me node numbers (type Node) while my nodes are labeled. How can I retrieve the labels? Should I maintain a Data.Map myself?
07:56:05 <CosmicRay> Igloo: BTW, I really like how easy it is to contribute code to ghc now, with darcs.
07:56:13 <CosmicRay> Igloo: if I had known it would be this easy, I would have done this long ago.
07:57:47 <Igloo> cool
07:59:00 <br1> what editor is most used for haskell?
07:59:24 <CosmicRay> br1: That answer is probably the same as "what editor is most used".
07:59:43 <CosmicRay> br1: and the answer to that question is the subject of debate.  But I'd say Unix people use Emacs
07:59:45 <xerox> That express the polyvariadic nature of Haskell people? :D
08:00:03 <CosmicRay> br1: though vim has a haskell mode too, and there are some editors written in haskell floating around as well
08:00:29 <br1> CosmicRay: I'm giving emacs a try, now.  But I can't get it to show me the next error.
08:00:58 <CosmicRay> oh, I don't use emacs to compile, so I'm afraid I'm not going to be much help.
08:01:23 <CosmicRay> Igloo: do you think people would find it at all helpful if I submit patches for some functions I have in MissingH.List that could be of general interest in Data.List?
08:01:37 <br1> CosmicRay: OK.  And what about auto complete?  Does emacs have something like this?
08:01:56 <CosmicRay> br1: I don't believe so, but I'm not that advanced of an emacs user.
08:02:09 <CosmicRay> br1: the person that wrote the Haskell mode for Emacs hangs out on the haskell mailing lists
08:02:13 <CosmicRay> br1: you may want to post there.
08:02:22 <ndm> CosmicRay: whcih ones?
08:03:23 <br1> CosmicRay: Thank you very much!
08:03:25 <musasabi> emacs can autocomplete based on the open source files and/or tags. The same with vim.
08:03:29 <Igloo> CosmicRay: We're probably too close to the 6.6 RC to be a good time for that
08:03:44 <CosmicRay> ndm: from a quick look, hasAny, contains, to start with
08:04:10 <CosmicRay> Igloo: OK, fair enough.
08:04:51 <CosmicRay> hi simon
08:05:17 <ndm> CosmicRay: contains should probably be renamed isSubstrOf
08:05:24 <simonpj> gosh you guys are attentive!  Just getting Gaim organised....
08:05:38 <musasabi> It seems that 6.6's cabal will lack the optional dependency stuff which will be nasty (with fps, FiniteMap etc)
08:05:44 <CosmicRay> ndm: yup
08:05:56 <ndm> CosmicRay: and can't find the haddock for hasAny?
08:05:59 <CosmicRay> ndm: when I started writing MissingH, I used pythonic names.
08:06:00 <ndm> is that in List?
08:06:11 <CosmicRay> {- | Returns true if the given list contains any of the elements in the search
08:06:11 <CosmicRay> list. -}
08:06:11 <CosmicRay> hasAny :: Eq a => [a]           -- ^ List of elements to look for
08:06:11 <CosmicRay>        -> [a]                   -- ^ List to search
08:06:11 <CosmicRay>        -> Bool                  -- ^ Result
08:06:19 <CosmicRay> ndm: yeah
08:06:35 <ndm> not entirely convinced about hasAny
08:06:48 <ndm> since its any (`elem` search) find
08:07:04 <ndm> and hasAny just seems to be a bit general as a name
08:07:07 <ndm> but definately isSubstr!
08:07:28 <ndm> I am tempted to do Data.MultiList
08:07:39 <Igloo> CosmicRay: I'd say the args are the wrong way round for hasAny, as xs `hasAny` ys wouldn't read right
08:07:59 <Igloo> MultiList?
08:08:00 <CosmicRay> OK, well that's easy enough to do.  some of the more complex stuff I'll certainly wait for ghc 6.6 before considering.
08:08:02 <ndm> with things like span. break, elem, but all using lists as the test
08:08:15 <Igloo> Ah
08:08:26 <ndm> i.e. break "like" "Neil likes Haskell" = ("Neil ","likes Haskell")
08:09:08 <CosmicRay> the other things that I find very useful are the strip functions: http://gopher.quux.org:70/devel/missingh/html/MissingH-Str.html#v%3Astrip
08:09:22 <ndm> there are quite a few list operations that i'd like to see generalised to strings, rather than the current List where they are basically Set's
08:09:24 <CosmicRay> I don't know where that would fit in the standard library though
08:09:37 <ndm> I considered Data.String
08:09:45 <ndm> to contain these MultiList things
08:09:52 <ndm> since almost certainly the main users would be strings
08:10:07 <ndm> I have trim, trimLeft, trimRight already in my libraries
08:10:43 <ndm> replace definately wants to go in somewhere
08:11:02 <ndm> and join, which i call intercat :)
08:11:28 <CosmicRay> ndm: I'm not sure isSubstr is the right name, since contains would apply to more than just strings.
08:11:44 <CosmicRay> maybe isSubset?  isSubList?
08:11:45 <ndm> isInfixOf?
08:12:03 <ndm> Prefix, Suffix, whats the bit in the middle
08:12:32 <CosmicRay> I suppose that makes sense, but it's not the most intuitive.
08:12:38 <ndm> however, its a natural generalisation of elem
08:12:56 <CosmicRay> well whoever commits stuff can either reject the patch or rename it if they don't like it.
08:13:30 <ndm> thats definately not the right thing to do - should reach a concensus first, rather than it being one single person getting to pick their personal taste to force an API forevermore
08:13:46 <ndm> although try reaching a concensus on semantics or names on the mailing list, hehe :)
08:14:37 <CosmicRay> heh
08:15:21 <ndm> what about elemList ?
08:15:34 <ndm> since that follows your takeWhileList etc ones
08:16:12 <ndm> hmm, takign a look at these functions, i should definately be using MissingH...
08:16:34 <ndm> and as soon as i start using a module, that means it gets indexed by Hoogle pretty soon after
08:16:34 <CosmicRay> heh
08:20:59 <CosmicRay> ndm: if you don't mind, who are you in real life?  /whois isn't being helpful
08:21:05 * CosmicRay tries to match nicks with names
08:21:07 <ndm> @where ndm
08:21:07 <lambdabot> I know nothing about ndm.
08:21:20 <ndm> @where+ ndm http://www.cs.york.ac.uk/~ndm/
08:21:20 <lambdabot> Done.
08:21:37 <ndm> Neil Mitchell, York (UK) Phd Student
08:21:40 <CosmicRay> ah, got it.
08:21:47 <ndm> pretty much sums me up in a single line (sadly)
08:22:43 <CosmicRay> heh
08:22:48 <ndm> I'm at my parents house, hence my IRC client isn't configured with any details :)
08:25:17 <ndm> anyone know anything about GRIN?
08:31:06 <vincenz> ndm: what about it?
08:31:08 <edwinb> I read about it once, but that probably doesn't count...
08:31:21 <vincenz> ditto
08:31:31 <ndm> vincenz: i am trying to figure out the trasformational architecture
08:31:42 <ndm> since i have a similar transformation system, but its not taht terminating
08:31:44 <edwinb> s/probably/definitely/ then...
08:32:02 <vincenz> huh, terminating?
08:32:13 <vincenz> afaik GRIN = something like ANF
08:32:15 <ndm> my optimisations don't fixed point
08:32:16 <vincenz> or STG
08:32:27 <Dino_> Luke is my hero today: "C# is a grubby mud hut compared to the breathtaking, elegant tower that is Haskell."
08:32:45 <ndm> yeah, but the GRIN methodology is about piling on optimisations and then fixedpointing
08:33:06 <ndm> i was wondering if any expression can cause a new function to be created
08:33:16 <ndm> and how he stops an infinite number of functino sbeing creating
08:33:28 <vincenz> hmm
08:33:38 <ndm> checking isomorphism of functions seems the obvious answer, but it doesn't work because other transformations then mutate the functions
08:33:51 <ndm> and if you pick an arbitrary order, i can often get f1 > f2 > f3
08:33:53 <vincenz> no idea, sorry :/
08:33:57 <ndm> at levels of reduction
08:34:10 <ndm> i may just have to rethink my transformation strategy
08:34:34 <vincenz> what is your aim?
08:35:15 <ndm> to simplify the crap out of a program
08:35:28 <ndm> for analysis rather than optimisation
08:35:44 <ndm> so all higher order functions should go
08:35:52 <ndm> that includes dictionary passing
08:37:30 <ndm> @where paste
08:37:30 <lambdabot> http://paste.lisp.org/new/haskell
08:39:40 <lisppaste2> ndm pasted "Defunctionalisation" at http://paste.lisp.org/display/25049
08:40:03 <ndm> vincenz: see that paste for my ultimate goal - take a higher order program with . and map, and remove all higher orderness from it
08:40:29 <ndm> the Unknown's come from my defintino of odd and >
08:40:34 <ndm> not introduced by my transformations
08:42:02 <kowey> frederik: was it you that was looking for help with custom controls yesterday?
08:42:03 <lambdabot> kowey: You have 1 new message. '/msg lambdabot @messages' to read it.
08:42:08 <vincenz> ndm: funky
08:42:48 <ndm> vincenz: it can totally eliminate haskell dictionaries that way
08:42:58 <CosmicRay> JaffaCake: I mentioned this to Igloo earlier, but I'm very pleased with what you all have done with the libraries.  It is so easy to contribute now with darcs.
08:43:21 <vincenz> ndm: yeah, that's what I thought as well as an option, I suggested it a while back but people mentioned the code-footprint would explode
08:43:41 <ndm> vincenz: in that case people have never read Mark Jones's paper :)
08:43:48 <ndm> i'll just get you a reference...
08:44:15 <ndm> vincenz: M. P. Jones. Dictionary-free Overloading by Partial Evaluation. In ACM SIGPLAN
08:44:17 <ndm> Workshop on Partial Evaluation and Semantics-Based Program Manipulation. ACM
08:44:18 <ndm> Press, June 1994.
08:44:38 <ndm> in that paper he proposes that, and then shows that the volume of code actually decreases
08:44:43 <vincenz> o.O
08:44:53 <vincenz> how is that possible?
08:44:56 <ndm> although now more people use more type classes its possible that result no longer holds, but it certainly used to be the case
08:44:56 <vincenz> dead-code elimination?
08:45:01 <edwardk> defunctionalization shouldn't be too hard. i've had to do it for some compiling stuff in the past, what are you missing so far, ndm?
08:45:02 <ndm> yep, dead code
08:45:12 <vincenz> dead code is orthogonal to it tho
08:45:22 <ndm> edwardk: i have it basically, i also want other transforms, and they have a habit of not fixed pointing
08:45:33 * edwardk nods.
08:45:54 <edwardk> I'm used to a CPS or ANF transform then defunctionalizing that to get rid of the continuations.
08:45:57 <ndm> edwardk: you did general defunc, in a type safe manner?
08:46:07 <ndm> automatically by a tool?
08:46:10 <ndm> or just by hand?
08:46:11 <edwardk> ndm: type safety? not so much an issue for me =)
08:46:17 <edwardk> ndm: at least back then
08:46:29 <edwardk> ndm: i was generating c at the time
08:46:39 <ndm> edwardk: it seems to be quite hard to do in a type safe manner automatically
08:46:41 <edwardk> ndm: so i didn't have closures and had to defunctionalize
08:46:51 <ndm> in a non-typesafe way, its relatively easy
08:46:53 <edwardk> ndm: sounds like a reasonable statement.
08:47:14 <ndm> and i want the standard defunc to be a last resort, since it makes it harder for analysis
08:47:31 <ndm> i want proper higher order elimination, then backed up with reynolds defunc if thats still required
08:47:50 <edwardk> ndm: yah, i had to use it as the last stage of one of my random imperative language compilers.
08:48:28 <ndm> edwardk: for me its the input to my analysis tool, so if the defunc mangles the code too badly, it hurts later on
08:48:36 <edwardk> *nods*
08:48:56 <edwardk> defunctionalization to me is always a last step kinda thing
08:49:31 <edwardk> right before i start trying to move to a three-instruction code or something more basic
09:01:45 <scriptdevil> lamdabot monad
09:01:54 <scriptdevil> isnt lamdabot a vot?
09:01:58 <scriptdevil> *bot
09:02:10 <xerox> Yes, she is.
09:02:15 <beelsebob> yes, what did you expect to happen?
09:02:27 <scriptdevil> i expected it to explain
09:02:29 <beelsebob> @vixen does scriptdevil know what you do?
09:02:29 <lambdabot> let's don't talk about that
09:02:34 <beelsebob> fail
09:02:34 <xerox> lol
09:02:35 <scriptdevil> like the emacs bot//
09:02:43 <beelsebob> @vixen what are monads about?
09:02:44 <lambdabot> i dunno, what about?
09:02:46 <xerox> scriptdevil: do you want such definitions there?
09:02:52 <beelsebob> bah, vixen is being poo
09:02:52 <scriptdevil> ok...
09:02:52 <xerox> That's an interesting idea....
09:02:57 <scriptdevil> xerox: just trying
09:03:00 <scriptdevil> for fun
09:03:08 <beelsebob> @google monad
09:03:10 <lambdabot> http://www.microsoft.com/technet/scriptcenter/hubs/msh.mspx
09:03:11 <lambdabot> Title: Scripting with Windows PowerShell
09:03:11 <scriptdevil> sorry if i disturbed u folks
09:03:18 <beelsebob> there you go... she's explained
09:03:28 <scriptdevil> beelsebob: ok..
09:03:31 <beelsebob> oh no
09:03:33 <beelsebob> that's the monad shell
09:03:35 <beelsebob> fail
09:03:39 <beelsebob> @google monad haskell
09:03:41 <lambdabot> http://www.nomaware.com/monads/
09:03:42 <lambdabot> Title: Nomaware | Monads
09:04:15 <scriptdevil> @vixen smile :P
09:04:16 <lambdabot> you know what? if we'd known it was going to be like this we'd have picked our own goddamn cotton!
09:04:16 <xerox> http://video.google.com/videoplay?docid=-3506870759603396896&q=bombing
09:04:17 <lambdabot> Title: Paint Bombing A Building - Google Video
09:05:09 <beelsebob> @vixen how're you doing today?
09:05:10 <lambdabot> i'm good, you?
09:05:18 <scriptdevil> :)
09:05:31 <scriptdevil> beelsebob: u r truly jobless.. :P
09:05:33 <beelsebob> @vixen mostly good - Haskell is telling me I'll be rich!
09:05:34 <lambdabot> Ooh, functional programmers are so hot!
09:05:38 <beelsebob> hehe :D
09:06:06 <scriptdevil> @vixen whats ur name?
09:06:07 <lambdabot> My name is Emily
09:06:10 <scriptdevil> :))
09:07:01 <beelsebob> @asl
09:07:01 <lambdabot> tell module failed: IRCRaised Prelude.head: empty list
09:07:03 <edwardk> @vixen asl?
09:07:04 <lambdabot> 19/f/California
09:07:05 <beelsebob> @vixen asl
09:07:05 <lambdabot> 19/f/California
09:07:07 <beelsebob> damn it
09:07:10 <beelsebob> interesting though
09:07:10 <edwardk> heh
09:07:12 <nilsi> @vixen emily is a fine name
09:07:13 <lambdabot> Any way you want it, baby!
09:07:24 <beelsebob> @vixen do you think edwardk is sexy?
09:07:24 <lambdabot> me, sexy? i do my best :)
09:07:28 <edwardk> @. vixen keal
09:07:29 <lambdabot> I don't think you are the one you say you are!
09:07:34 <edwardk> @state
09:07:34 <lambdabot> Unknown command, try @list
09:07:47 <beelsebob> @. elite vixen asl?
09:07:47 <lambdabot> 19/f/(4LiphoRnIA
09:07:52 <beelsebob> *g*
09:08:03 <edwardk> @. elite palomer
09:08:03 <lambdabot> yOu'R3 4|1 nuTz
09:11:31 <vincenz> @. elite proton
09:11:32 <lambdabot> compose module failed: IRCRaised Parse error: "proton"
09:11:39 <vincenz> @. elite protontorpedo
09:11:40 <lambdabot> hOw DOEz0rz j2ee c0MPArE 70 HaSkEl|?
09:11:51 <xerox> lol stop it
09:12:26 <vincenz> the funny part is that @protontorpedo delivers content with the same semantical value as the syntactical value of elite
09:12:35 <edwardk> heh
09:12:44 <Stinger_> hehe yeah I was thinking that was appropriate for the comment :)
09:13:11 <ihope> data IO a = IO (forall b. (a -> IO b) -> IO b)
09:13:14 <ihope> :-)
09:13:32 <xerox> Hmmmm?
09:14:33 <ihope> IO a = (a -> IO b) -> IO b, aye?
09:15:39 <xerox> Really?
09:15:45 <vincenz> that's a recursive definition
09:16:00 <xerox> How would that work?
09:16:11 <vincenz> makes no sense
09:16:30 <ihope> @type ($ return) :: ((a -> IO b) -> IO b) -> IO a
09:16:35 <lambdabot>   Couldn't match the rigid variable `b' against the rigid variable `a'
09:16:36 <lambdabot>    `b' is bound by the polymorphic type `forall a b. ((a -> IO b) -> IO b) -> IO a'
09:16:56 <ihope> vincenz: recursive data declarations are allowed, you know.
09:17:02 <xerox> ?type ($ return)
09:17:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => ((a -> m a) -> b) -> b
09:17:11 <xerox> Eh.
09:17:27 <vincenz> ihope: I know but yours makes no sense
09:17:29 <xerox> a -> IO b is difficult.
09:17:39 <vincenz> xerox: that's return
09:17:46 <xerox> ?type return
09:17:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
09:17:48 <vincenz> erm
09:17:49 <vincenz> nm
09:17:50 <ihope> Those types look like they unify to me.
09:18:02 <xerox> Doesn't seems the case to me.
09:18:07 <ihope> @type ($ return) :: (forall b. (a -> IO b) -> IO b) -> IO a
09:18:08 <lambdabot> (forall b. (a -> IO b) -> IO b) -> IO a :: forall a. (forall b. (a -> IO b) -> IO b) -> IO a
09:18:12 <ihope> Bing.
09:18:15 <vincenz> @type ($ return) is meaningless
09:18:16 <lambdabot> Not in scope: `is'
09:18:17 <lambdabot>  
09:18:17 <lambdabot> <interactive>:1:14: Not in scope: `meaningless'
09:18:20 <vincenz> that's like saying
09:18:26 <vincenz> @type ($ ap)
09:18:27 <lambdabot> forall (m :: * -> *) a b b1. (Monad m) => ((m (a -> b) -> m a -> m b) -> b1) -> b1
09:18:36 <vincenz> you're calling a function with return as parameter... it could just ignore it
09:18:40 <vincenz> @type (const $ return)
09:18:42 <lambdabot> forall b (m :: * -> *) a. (Monad m) => b -> a -> m a
09:19:04 <vincenz> @type (flip const $ return)
09:19:06 <lambdabot>   Ambiguous type variable `m' in the constraint:
09:19:06 <lambdabot>    `Monad m' arising from use of `return' at <interactive>:1:14-19
09:19:28 <ihope> @type (>>=) . ($ return)
09:19:29 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *) a1. (Monad m, Monad m1) => ((a1 -> m1 a1) -> m a) -> (a -> m b) -> m b
09:19:35 <xerox> ?type id $ return
09:19:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
09:19:46 <ihope> @type ($ return) . (>>=)
09:19:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
09:19:53 <ihope> Hmm.
09:21:16 <xerox> ?type (>>= return)
09:21:16 <vincenz> blegh
09:21:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
09:21:18 <xerox> That's it.
09:21:22 <vincenz> my personalized homepage is too small
09:21:34 <vincenz> xerox that's just id
09:21:45 <xerox> That's why I used id up there.
09:22:14 <ihope> @type (>>=) . (($ return) :: (forall b. (a -> IO b) -> IO b) -> IO a)
09:22:15 <lambdabot>   Inferred type is less polymorphic than expected
09:22:16 <lambdabot>    Quantified type variable `b' escapes
09:22:21 <ihope> Whee.
09:22:49 <ihope> So why don't we just let the quantified type variables escape, eh?
09:23:13 <xerox> :P
09:23:57 <ihope> Would we have to add "Inferred type is more polymorphic than expected" errors, then?
09:24:13 <ihope> And use a bit of hackery to get foralls?
09:25:01 <vincenz> blegh
09:25:04 <vincenz> why is there no admin link on blogspot?
09:25:12 * vincenz doesn't even know the link
09:25:36 <ndm> vincenz: www.blogger.com
09:26:13 <vincenz> ndm: i have a blog, so I surf to it
09:26:17 <vincenz> there's no admin - link
09:26:22 <vincenz> oh!
09:26:28 * vincenz grumbles
09:27:01 <ndm> vincenz: add one as your special link, but i know its annoying
09:27:10 <ndm> google are redoing blogger, so expect it to be prefect after that
09:28:01 <xerox> http://users.livejournal.com/_patrick_/3185471.html
09:28:04 <lambdabot> Title: _patrick_: Rob Gonsalves Ð¿Ð¾Ð´Ð¶Ð¸Ð³Ð°ÐµÑ ÑÐ¼Ñ
09:35:04 <vincenz> blegh
09:35:08 <vincenz> I move aroudn tooo much with my blogging neesd
09:36:19 <vincenz> Anyone use blogspot?
09:36:35 <vincenz> Is anonymous commenting severely advised against?
09:37:12 <ptolomy> Is findSubstring not supported in ByteString.Lazy because it is impractical, or just because it hasn't been implemented yet?
09:38:31 <ptolomy> wait.. or neither..
09:38:50 <ihope> Because it's too easy to implement?
09:39:17 <ptolomy> "it is actually implemented, but I missed it because I'm slow" is also a rather probable option.
09:41:30 <ndm> vincenz: nope, anon is not too bad at all
09:42:56 <vincenz> okies
09:49:48 <vincenz> I'm moving back to blogspot instead of using blosxom, at least I'll be able to get comments :)
09:50:51 <ricky_clarkson> I used blogcity a little bit, then it deleted my blog when I didn't blog for a month or something.
09:51:03 <ricky_clarkson> blogspot doesn't do that, seems ok so far.
09:51:03 <vincenz> damn
09:51:05 <vincenz> bastards
09:56:12 <goltrpoat> is there a fast log_2 :: (Num a) => a -> a of some sort hiding somewhere?
09:57:35 <ndm> @hoogle log
09:57:36 <lambdabot> Prelude.log :: Floating a => a -> a
09:57:36 <lambdabot> Prelude.logBase :: Floating a => a -> a -> a
09:57:36 <lambdabot> GHC.ConsoleHandler.Logoff :: ConsoleEvent
09:57:54 <goltrpoat> right, those are on Floating a
09:58:14 <goltrpoat> looking for an integer base 2 log
09:59:43 <goltrpoat> i can write one obviously, but it won't be as fast as, eg, a bsr eax, eax for Int32
10:01:32 <ndm> goltrpoat: you can use the ffi, ifyou wanted
10:01:39 <ricky_clarkson> Convert it to a binary string, find the length of that string.
10:01:43 * ricky_clarkson is a Java programmer. ;)
10:02:06 <goltrpoat> ndm:  was hoping to avoid that
10:02:26 <goltrpoat> ricky:  heh cute
10:04:08 <ricky_clarkson> I actually do something like that to work out whether a netmask is 'valid', because I couldn't think of a better way.
10:04:26 <ricky_clarkson> E.g., 255.255.0.0 is valid, 255.255.12.0 isn't.
10:24:09 <edwardk> ricky: heh, what always gets me is cisco wildcards reverse the bits and then allow invalid masks, so you can say all odd ip addresses on this network and weird stuff like that
10:24:49 <ricky_clarkson> Most things allow invalid masks.
10:24:55 <edwardk> yeah
10:25:11 <edwardk> though, i tend to prefer the /32 /24 notation
10:25:32 <ricky_clarkson> ifconfig doesn't support that, afaik.
10:25:43 <ricky_clarkson> ifconfig eth0 up 146.87.1.1 netmask 255.255.255.0
10:25:48 <edwardk> unfortunate but true
10:54:05 <maddddd> hello guys
10:54:47 <maddddd> can anybody help me with my homework?
10:54:55 <ricky_clarkson> Yes.
10:54:58 <ricky_clarkson> Your lecturer.
10:55:42 <vincenz> maddddd: what is your question?
10:55:54 <maddddd> well i have some questions
10:55:56 <vincenz> maddddd: specific questions are allowed, jsut don't expect us to write it for you
10:56:13 <maddddd> i was kind of expecting that
10:56:28 <vincenz> ok :) last time there was someone who copy pasted his homework to the #haskell ML and then said it was urgen
10:56:58 <tieTYT> dude
10:56:59 <tieTYT> i say
10:57:09 <tieTYT> we just ask maddddd what he wants 20 more times
10:57:11 <tieTYT> and then we give up
10:57:28 <vincenz> ricky_clarkson: tho to be fair, he did claim it was for homeworkk, instead of sneakily trying to get us to solve it
10:57:33 <ricky_clarkson> vincenz: Heh, true.
10:57:53 <vincenz> if it's language-related issues, and the student shows clear thinking I think questions should be allowed
10:58:19 <maddddd> it's more related to the logic of it...
10:58:35 <tieTYT> i wish i was an op right now
10:58:41 <ricky_clarkson> Usually the explicit mention of 'homework', rather than a specific question, indicates a request for a whole solution.  A trend that I observed.
10:58:47 <vincenz> tieTYT: why?
10:58:52 <vincenz> tieTYT: why do you need an op?
10:58:55 <ricky_clarkson> But yes, I agree, vincenz.
10:59:00 <tieTYT> ./kick maddddd just ask it!
10:59:11 <vincenz> tieTYT: erm, no.  #haskell is an open channel
10:59:21 <vincenz> except for extremist trolls
10:59:28 <ricky_clarkson> tieTYT: Calm down.  I can kick you from ##java if you like.
10:59:32 --- mode: ChanServ set +o vincenz
10:59:34 <maddddd> ok guys i'll be leaving if i'm bothering you with my silly questions
10:59:40 <vincenz> maddddd: you're not
10:59:50 <vincenz> maddddd: feel free to ask your question :)
10:59:50 <xerox> maddddd: go straight to the point now to please everybody's needs
10:59:51 <ricky_clarkson> maddddd: Go ahead and ask it.
10:59:54 <tieTYT> ricky_clarkson: can you make the bot kick me?
10:59:57 <Philippa> vincenz: there're traditionally a couple of other things that can get you kicked, but only after repeated warnings
11:00:05 <ricky_clarkson> tieTYT: javabot is not an op.
11:00:11 <tieTYT> :(
11:00:20 <Philippa> besides, not all the trolls're extremists. Some're just wankers
11:00:36 <vincenz> I meant extreme trolls, not troll extremists!
11:00:47 <vincenz> like proton
11:00:48 <vincenz> @proton
11:00:49 <lambdabot> syntax ur runing my high
11:00:55 <xerox> wtf
11:01:06 <maddddd> look i have to find out the smallest number that has the same number of digits as twice the number, three times the number and so on up to six times the number
11:01:22 <ricky_clarkson> maddddd: 1
11:01:28 <ricky_clarkson> No, 0.
11:01:29 <Philippa> if you think that's extreme trolling...
11:01:30 <maddddd> but in different order
11:01:35 <vincenz> maddddd: right...well first of all, what possible strategies do you consider?
11:01:42 <vincenz> Philippa: he asked the same inane questions for over 10 months
11:01:44 <_Codex> I have some homework too. (how does function call work in relation to function composition and it's associativity? :-)
11:01:58 <vincenz> Philippa: he's the shemale guy
11:02:38 <tieTYT> vincenz: who?
11:02:43 <xerox> _Codex: it makes Haskell diverge in points-free madness.
11:03:06 <maddddd> i was thinking of backtracking really but...
11:03:10 <vincenz> tieTYT: there was this guy named shemale_magic in here a while ago
11:03:37 <ricky_clarkson> My homework is: "what does lazy evaluation gain you?".
11:03:51 <ricky_clarkson> It's due in 3 years ago, so it's really urgent.
11:03:57 <tieTYT> haha
11:04:04 <vincenz> ricky_clarkson: I suggest using a lazy strategy
11:04:11 <maddddd> ricky_clarkson: are you asking me?
11:04:12 <xerox> ricky_clarkson - Spectacle and (a cure for) headache.
11:04:22 <ricky_clarkson> maddddd: No, everyone.
11:04:34 <vincenz> maddddd: your homework is supposed to be made in haskell?
11:04:38 <maddddd> yeah
11:04:47 <vincenz> erm
11:04:54 <vincenz> I think you should try to write down some pseudocodde first
11:04:57 <vincenz> on how you'd tackle it
11:05:02 <kosmikus> maddddd: what's the type of the function? what subtasks do you have to perform?
11:05:05 <vincenz> and then possibly ask with help in translating it
11:05:29 <vincenz> as kosmikus suggested, try to split the task in different parts, defiine what it is you're trying to do
11:06:30 <kosmikus> to some of the others here I can only say: this used to be a channel where we help people asking questions and wanting to learn Haskell rather than to scare them away. I hope this hasn't changed too much.
11:06:57 <vincenz> kosmikus: nope, still that way:)
11:07:24 <maddddd> really i'm not trying to offend anyone, but the only thing haskell has done to me up to now is to give me a big headache
11:07:34 <ricky_clarkson> kosmikus: tieTYT is just used to channels that get a lot of idiots.
11:08:27 <tieTYT> my bad
11:08:31 <kosmikus> maddddd: for how long are you learning Haskell?
11:09:49 <maddddd> since I got the homework, for like 2 weeks
11:09:56 <vegai> @shapr
11:09:56 <lambdabot> why on earth would I slap
11:10:01 <maddddd> up to now i have read the tutorial for c programmers
11:10:04 <vegai> :-(
11:10:30 <maddddd> and i succeeded in doing something in it.
11:10:58 <maddddd> actually what i told you is only a subpoint of the whole homework
11:11:16 <tieTYT> why did you read a c tutorial for haskell?
11:11:25 <ricky_clarkson> tieTYT: A tutorial for C programmers.
11:11:51 <tieTYT> maddddd: i "recommend" the yet another haskell tutorial
11:12:07 <vincenz> yep
11:12:09 <vincenz> yaht is great
11:12:14 <vincenz> @where yaht
11:12:14 <lambdabot> http://www.cs.utah.edu/~hal/htut/
11:12:20 <tieTYT> it's good in combination with this channel
11:12:33 <astrolabe> maddddd: I don't really understand your problem.  Hasn't 0 got the same no. of digits as 1*0,2*0 etc.  And if 0 is no good, hasn't 1?
11:12:34 <ricky_clarkson> Is hal a #haskell person?
11:12:38 <tieTYT> i notice there are a few exercises that you literally aren't ready to solve when he gives them to you
11:12:54 <vincenz> ricky_clarkson: never heard of him?
11:12:55 <vincenz> @seen hal
11:12:56 <lambdabot> I haven't seen hal.
11:13:02 <maddddd> i get error 403
11:13:03 <tieTYT> hehe the guy that wrote yaht
11:13:07 <ricky_clarkson> vincenz: As in the writer of that tutorial.
11:13:10 <maddddd> do you know of any mirror?
11:13:10 <ricky_clarkson> Hal Daumé
11:13:11 <vincenz> oh!
11:13:23 <vincenz> holy cow
11:13:27 <vincenz> @google yaht haskell
11:13:31 <lambdabot> http://www.hyuki.com/haskell/?cat=yaht
11:13:31 <lambdabot> Title: yaht - Haskell
11:13:34 <tieTYT> see ricky_clarkson is on a first name basis with the guy
11:13:44 <vincenz> grr
11:13:45 <ricky_clarkson> Hal's easier to type.
11:13:47 <tieTYT> they're like this son X
11:13:50 <vincenz> @google "yet another haskell tutorial"
11:13:53 <lambdabot> http://www.cs.utah.edu/~hal/htut/tutorial.pdf
11:14:04 <vincenz> damn it, he made it private access
11:14:05 <maddddd> Forbidden
11:14:05 <maddddd> You don't have permission to access /~hal/htut/tutorial.pdf on this server.
11:14:05 <maddddd> Additionally, a 403 Forbidden error was encountered while trying to use an ErrorDocument to handle the request.
11:14:05 <tieTYT> the one is forbidden
11:14:09 <tieTYT> i'll find one for you guys
11:14:16 <vincenz> it used to be fine
11:14:31 <tieTYT> i know
11:14:34 <tieTYT> it happened 2 days ago
11:14:42 <vincenz> odd
11:14:48 <ricky_clarkson> Yeah, I found another URL for it.
11:15:13 <maddddd> astrolabe: the digits can be in different places
11:15:16 <ricky_clarkson> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
11:15:21 <tieTYT> yes that's it
11:15:52 <vincenz> @where+ yaht http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
11:15:53 <lambdabot> Done.
11:15:59 <vincenz> @where yaht
11:15:59 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
11:16:04 <vincenz> \o/
11:19:56 <astrolabe> maddddd: I still don't get it.
11:20:03 <astrolabe> Does anyone else?
11:20:31 <maddddd> thanks guys
11:20:38 <maddddd> i'm reading that thing now
11:20:56 <maddddd> I hope that by 12 o'clock i will finish my homework so i can enter my exam :)
11:24:24 <CosmicRay> Igloo: the ghc build just crashed on stable
11:38:57 <tieTYT> why won't this compile? http://paste-bin.com/227
11:39:30 <tieTYT> http://paste-bin.com/228
11:39:36 <tieTYT> the second one has the error message in it
11:40:41 <arjanb> what's the type of you elements function? and then look at the type of ':'
11:41:03 <tieTYT> oh i see
11:41:15 <tieTYT> yes one is turning an a, the other one is returning a [a]
11:41:22 <tieTYT> now that error message makes sense
11:41:23 <tieTYT> thanks
11:43:39 <Igloo> CosmicRay: In the same way?
12:05:01 <dolio> ?free zip
12:05:02 <lambdabot> Expected OpColonColon
12:06:00 <apfelmus> ?free zip :: [a] -> [a] -> [(a,a)]
12:06:00 <lambdabot> ( ( f ($proj_2_1 z) = $proj_2_1 u     &&     f ($proj_2_2 z) = $proj_2_2 u   )  =>   g z = u ) => $map g (zip x y) = zip ($map f x) ($map f y)
12:06:32 <apfelmus> ?free zip :: [a]Â -> [b] -> [(a,b)]
12:06:33 <lambdabot> Extra stuff at end of line
12:06:41 <apfelmus> ?free zip :: [a]Â -> [b] -> [(a,b)]
12:06:42 <lambdabot> Extra stuff at end of line
12:07:03 <apfelmus> ?free zip :: [a]->[b]->[(a,b)]
12:07:03 <lambdabot> ( ( f ($proj_2_1 z) = $proj_2_1 u     &&     g ($proj_2_2 z) = $proj_2_2 u   )  =>   h z = u ) => $map h (zip x y) = zip ($map f x) ($map g y)
12:07:33 <vincenz> > let b = drop 1 b in head b
12:07:33 <lambdabot>  Add a type signature
12:07:43 <vincenz> > let b = drop 1 b in head b :: Int
12:07:44 <lambdabot>  Exception: <<loop>>
12:08:14 <maddddd> hello guys
12:08:19 <maddddd> it's me again :)
12:08:29 <maddddd> i have a question how do you do type casting?
12:08:36 <yip> you don't
12:08:44 <yip> haskell is type safe
12:08:49 <maddddd> but i can't reverse a number
12:08:57 <vincenz> define "reverse"
12:09:12 <yip> > reverse (show 123)
12:09:13 <lambdabot>  "321"
12:09:19 <maddddd> thanx :))
12:09:27 <vincenz> maddddd: that's a bad way of doing it
12:09:39 <vincenz> and since this is homework, you should probably learn the proper way
12:09:51 <vincenz> think aobut it, there's no generic "reverse" cause a number is not a list
12:09:57 <vincenz> you might want to first define how you get a list from a number
12:09:59 <vincenz> probably something like
12:10:09 <vincenz> toDigits :: Int -> [Int]
12:10:24 <maddddd> well i have a list of numbers and i want to check if they're palindromes
12:10:27 <vincenz> and obviously this is not standardly defined cause it depends on the base
12:10:58 <vincenz> maddddd: right and I think the clue of that problem is writing a proper algorithm that turns an integer into a list, the rest is rather trivial
12:11:00 <yip> > let n = 5335 in reverse (show n) == show n
12:11:01 <lambdabot>  True
12:11:06 <vincenz> yip: please stop
12:11:07 <yip> > let n = 5330 in reverse (show n) == show n
12:11:08 <lambdabot>  False
12:11:16 <yip> oops sorry :|
12:12:12 <yip> i think that show is actually a pretty good way for turning an integer into a list. but yeah it might be a good excersize to see if you can write your own function that converts an integer into a list
12:12:50 <vincenz> yip: well it's homework, using show kinda defeats the purpose
12:12:59 <vincenz> as that's the only hard part of the problem
12:13:32 <vincenz> yip: how is the gameboy emulator going?
12:13:35 <yip> yeah, it would be good to write a function that converts 5335 into the list [5, 3, 3, 5]
12:13:44 <yip> vincenz: stalled for quite a while now
12:14:03 <yip> vincenz: work is taking up much of my time :\
12:16:00 <vincenz> yip: army work?/
12:16:12 <yip> eh?
12:19:52 <apfelmus> > unfoldr (\x -> if x == 0 then Nothing else let (q,r) = quotRem x 10 in Just (r,q)) 1533
12:19:53 <lambdabot>  [3,3,5,1]
12:20:42 <jrmole> @pl \(a, b) -> (b, a)
12:20:42 <lambdabot> uncurry (flip (,))
12:20:47 <monochrom> hmm, need reverse or equivalent
12:21:01 <vincenz> apfelmus: please don't solve homework...
12:21:08 <xerox> > (snd &&& fst) (1,2)
12:21:09 <lambdabot>  (2,1)
12:21:20 <jrmole> @type (&&&)
12:21:21 <lambdabot> forall (a :: * -> * -> *) c' c b. (Arrow a) => a b c -> a b c' -> a b (c, c')
12:21:26 --- mode: vincenz set -o vincenz
12:22:51 <monochrom> @type ((&&&) :: (b->c) -> (b->c') -> (b -> (c,c')))
12:22:52 <lambdabot> forall b c c'. (b -> c) -> (b -> c') -> b -> (c, c')
12:23:00 <apfelmus> vincenz: sorry, i couldn't withstand because it's an anamorphism.
12:23:41 <xerox> @type ((&&&) :: (Arrow (~>)) => (a ~> b) -> (a ~> c) -> (a ~> (b,c)))
12:23:42 <lambdabot> forall (~> :: * -> * -> *) a b c. (Arrow ~>) => ~> a b -> ~> a c -> ~> a (b, c)
12:24:13 <monochrom> I don't oppose solving homework problems.  Our solutions are not homework solutions anyway.  unfoldr?  You think the student knows unfoldr?  You think the grader trusts a student who uses unfoldr?
12:24:36 <Cale> map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10)
12:24:36 <xerox> :(
12:24:41 <jrmole> i know students who would use unfoldr in a first haskell course
12:24:54 * xerox is a student!
12:25:16 <monochrom> The grader will not trust the student.  The grader will challenge the student to find out.
12:25:27 <vincenz> monochrom: :D
12:25:54 <vegai> perhaps you overestimate graders..
12:25:56 <monochrom> xerox will pass the challenge.  xerox is ok :)
12:26:12 * xerox kneels to the grader :P
12:26:47 <vincenz> xerox: that's hwo you get your points???
12:26:54 <monochrom> OK, if I overestimate graders, there is another way out.  You think the grader knows unfoldr too? XD
12:27:03 <jrmole> is this "challenge" like the duel in _the matrix_, except the construct is a ghci prompt?
12:27:12 <xerox> hah hah ~ caught :)
12:28:28 <vegai> monochrom: Like: Student: "Here I used unfoldr to..." Grader: "'unfoldr'? You can't just make things up"
12:28:52 <Cale> hehe
12:29:07 <eivuokko> JaffaCake, Ping.
12:29:16 <ricky_clarkson> edwardk: typedef can be emulated, kinda, in Java, by making a subtype.
12:29:23 <vincenz> vegai: or even worse "Where is unfoldr in your code?"
12:29:35 <ricky_clarkson> edwardk: interface StringList extends List<String>.  Obviously this has problems.
12:31:00 <monochrom> Most likely the student hands in homework containing unfoldr and grader just marks it as wrong out of ignorance.  Student will not appeal because it is copied, don't know how to argue.
12:31:17 <maddddd> guys how do i use sort?
12:31:27 <ndm> @google haskell sort
12:31:31 <lambdabot> http://www.haskell.org/haskellwiki/Introduction
12:31:31 <lambdabot> Title: Introduction - HaskellWiki
12:31:33 <monochrom> Give it a list of numbers.  Enjoy.
12:31:54 <maddddd> doesn't work
12:31:58 <Cale> > sort [5,2,67,2,15,4,7,3,5]
12:31:58 <tennin> I still have to reread the definition in the prelude every time I run across unfoldr
12:31:59 <lambdabot>  [2,2,3,4,5,5,7,15,67]
12:32:00 <araujo> hi hi!
12:32:02 <xerox> Enjoy a *sorted* list of numbers back!
12:32:04 <maddddd> ERROR file:{Hugs}\packages\hugsbase\Hugs.hs:10 - Undefined variable "sort"
12:32:16 <Cale> maddddd: It's in Data.List
12:32:20 <Dino_> @type sort
12:32:22 <lambdabot> forall a. (Ord a) => [a] -> [a]
12:32:22 <xerox> tennin: I believe you can work it out with the type
12:32:26 <monochrom> Yeah need to import
12:32:52 <Cale> I believe in hugs the command was something like  :also Data.List ?
12:32:58 <xerox> Possibly.
12:33:01 <monochrom> For your future convenience, "doesn't work" is very informative and specific.  Don't say anything more about your problem.
12:33:17 <Cale> monochrom: haha
12:33:43 * xerox rubs the crystal sphere... the problem..is....
12:33:57 <vincenz> monads
12:34:04 <dolio> @pl \(a,b) (c,d) -> compare b d
12:34:04 <lambdabot> (`ap` snd) . (. fst) . const . compare . snd
12:34:19 <xerox> dolio: you could go for a comparing first
12:34:34 <Cale> comparing snd
12:34:43 <xerox> comparing f x y = compare (f x) (f y)
12:35:00 <Cale> That'll be in Data.Ord in 6.6 :)
12:35:01 <tennin> actually, I think the problem now is that when I first read about unfoldr it seemed really complicated
12:35:33 <dolio> :) That'd certainly be simpler.
12:35:35 <tennin> now, it doesn't seem that complicated but because of that first experience I keep thinking I'm missing some detail that makes it so
12:35:37 <xerox> Cale: haha, not first :: Arrow (~>) => (a ~> b) -> ((a,c) ~> (b,c)). `First define ..' I meant.
12:35:52 <Cale> ah :)
12:36:20 <tennin> and so I feel compelled to check and recheck the definition in the prelude only to find that there is, in fact, no such detail
12:36:53 <xerox> ?index unfoldr
12:36:53 <lambdabot> Data.List
12:36:56 <xerox> ?fptools Data.List
12:36:57 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
12:37:10 <xerox> unfoldr      :: (b -> Maybe (a, b)) -> b -> [a]
12:37:10 <xerox> unfoldr f b  =
12:37:11 <xerox>   case f b of
12:37:11 <xerox>    Just (a,new_b) -> a : unfoldr f new_b
12:37:11 <xerox>    Nothing        -> []
12:37:17 <tennin> oh right, it's not even in the prelude is it?
12:37:18 <tennin> haha
12:37:39 <xerox> lambdabot makes certain works a breeze
12:39:00 <dolio> ?type ap
12:39:02 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
12:44:26 <yip> anyone ever done serial port programming in haskell?
12:45:17 <ricky_clarkson> @where yaht
12:45:18 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
12:47:24 <Cale> hmm, did dons ever make that graph comparing fps 0.1 to the latest version?
12:48:17 <xerox> http://hope.cs.rice.edu/twiki/pub/WG211/M3Schedule/foozles.pdf
12:48:26 <xerox> It's just me or this thing is *very* funny?
12:51:03 <Oejet> Cale: I saw something like it on planet.haskell.org
12:51:16 <dolio> Reminds me of the Apple product cycle.
12:51:41 <dolio> ?google apple product cycle
12:51:45 <lambdabot> http://www.misterbg.org/AppleProductCycle/
12:51:45 <lambdabot> Title: The Apple Product Cycle
12:53:11 <bringert> cool, I've met all real people mentioned by name in those slides
12:53:14 <bringert> including the author
12:53:36 <bringert> where do I get my t-shirt?
12:53:46 <xerox> Third door on the left up there
12:54:50 <wolverian> funny, now it's apple with the evil drm.
12:55:09 <wolverian> (re apple product cycle, second to last point in the list)
13:02:24 <Cale> http://www.scannedinavian.com/hope/image/70  -- ahaha
13:03:11 <jrmole> i don't get it
13:07:50 <monochrom> This is very sad. :)
13:13:07 <ndm> has everyone seen the shirley/surely thing on the mailing list?
13:14:06 <monochrom> which one?  haskell?  haskell-cafe?
13:14:30 <ndm> monochrom: [Haskell-cafe] data structures question
13:32:12 <bringert> ndm: read it now
13:32:45 <bringert> good thing he replied instead of going around thinking that chris is an asshole
13:33:22 <bringert> and he replied in a curteous way too
13:33:46 <bringert> has there ever been an out of control flame war on any of the haskell lists?
13:33:56 <ndm> not that i remember
13:34:12 <ndm> there was an iranian/nuclear bomb joke once which seemed slightly insensitive
13:34:13 <bringert> rarely even in here
13:34:24 * bringert googles
13:34:25 <ndm> but those are about the only things
13:35:05 <ndm> bringert: [Haskell-cafe] Compiling ghc for using STM
13:36:02 <bringert> ah, bulat
13:36:27 <bringert> that was a bit random
13:37:00 <bringert> does he hang out here?
13:37:03 <lispy> heh, bulat is funny that way
13:37:17 <lispy> sometimes he's very lucid and sometimes i have no idea what he's smoking :)
13:44:15 <tieTYT> if i'm working with pairs i have fst and snd.  What if i'm working with a tuple of 3?  I have to make my own functions?
13:44:27 <dolio> ?type fst3
13:44:28 <lambdabot> Not in scope: `fst3'
13:45:00 <Cale> There used to be fst3, snd3, thd3
13:45:12 <Cale> in the prelude
13:45:24 <Cale> those have been gone since Haskell98 though
13:45:29 <tieTYT> oh
13:45:33 <tieTYT> oh well, not a big deal
13:45:33 <Cale> You just use case
13:45:38 <Cale> or write your own :)
13:45:46 <tieTYT> yep
13:45:49 <tieTYT> thanks
13:47:49 <yip> data MyTuple a b = MyTuple a b
13:48:05 <yip> is this just as good as a double-tuple?
13:48:50 <jrmole> it will involve more boxing
13:49:20 <ndm> yip: yes, just as good
13:49:23 <jrmole> and MyTuple _|_ _|_ is distinct from _|_, whereas (_|_, _|_) and _|_ are indistinguishable
13:49:24 <jrmole> iirc
13:49:24 <ndm> jrmole: really?
13:49:40 <ndm> i thought data (,) a b= (,) a b
13:49:52 <ndm> thats certainly the definition Yhc and nhc both use
13:49:52 <Cale> > fst (5, undefined)
13:49:53 <lambdabot>  5
13:50:07 <tieTYT> how do i see the definition of a data I created?
13:50:12 <Cale> Tuples aren't strict
13:50:24 <jrmole> ah, nm, tuples are lifted
13:50:34 <jrmole> they weren't in miranda though
13:50:59 <jrmole> but newtype was introduced partially so you can make your own unlifted types
13:51:04 <ndm> jrmole: yep, thats one of the differences between haskell and miranda
13:51:09 <Cale> Well, and strict fields
13:51:25 <ndm> jrmole: Turner mentions it in one of his papers
13:51:41 <Cale> data MyTuple a b = MyTuple !a !b
13:51:44 <jrmole> it's in the history of haskell paper for one
13:51:59 <tieTYT> ie: how do I see that Maybe is Maybe a = Just a | Nothing
13:52:00 <tieTYT> or whatever it is
13:52:29 <ndm> tieTYT: are you using Hugs?
13:52:32 <ndm> :f Maybe
13:52:36 <tieTYT> no i'm using ghci
13:52:36 <Cale>  :i Maybe
13:52:41 <ndm> hops you to the definition
13:53:00 <tieTYT> thanks
13:54:48 <jrmole> wow, that's cool
13:55:29 <vincenz> re
13:55:36 <vincenz> @seen edwardk
13:55:37 <lambdabot> I saw edwardk leaving #haskell 25 minutes and 13 seconds ago, and .
14:02:35 <astrolabe> Does anyone know of a haskell library for manipulating sets (intersection, union etc) representing them internally as ordered lists?
14:03:32 <monochrom> No. But there's one using balanced binary search trees.
14:04:21 <vincenz> can you take out batteries from a laptop while they're on?
14:04:37 <vincenz> erm and t's plugged into AC
14:04:45 <astrolabe> monochrom: thanks
14:07:09 <monochrom> I use an IBM Thinkpad R31 and I do that all the time.
14:07:50 <vincenz> monochrom: taking the laptop out while it's on?
14:07:57 <vincenz> erm
14:07:58 <vincenz> battery
14:08:12 <monochrom> Yes.  Have AC.  Take out battery.  Or put battery in.
14:08:18 <vincenz> ah neat
14:08:22 <vincenz> gotta check if my battery aws recalled
14:09:06 <lispy> dons: here is a url that the url module doesn't accept...maybe we should relax the regexp: http://maps.google.com/maps?f=l&hl=en&q=star+bucks&near=5th+ave+%26+cherry,+seattle,+wa&ie=UTF8&z=15&ll=47.604427,-122.329845&spn=0.014265,0.02193&om=1
14:09:07 <lambdabot> Title: Google Maps
14:09:12 <lispy> oh damn
14:09:16 <lispy> it works this time...
14:09:17 <lispy> weird
14:12:33 <vincenz> damn
14:12:36 <vincenz> my battery is not reclaimed
14:12:36 <vincenz> :/
14:14:59 <vincenz> \o/
14:15:01 <vincenz> my paper is nearly finished
14:15:06 <vincenz> well pre-supervisor comments
14:15:22 <vincenz> only gotta rewrite a small part of my methodology section and do some last experiments
14:15:57 <vincenz> @localtime dons
14:15:59 <lambdabot> Local time for dons is Fri Sep  1 07:12:27 2006
14:27:25 <sris> who/what have/uses the logo looking something like this: (:/=)
14:27:30 <sris> (no assignments)
14:27:47 <vincenz> droolinig smily?
14:28:31 <sris> no, it's a assignment operator, pascal-style := within a circle with a line across itself ;)
14:28:52 <sris> it's not supposed to be ascii
14:29:57 <ihope> :/= is to := as /= is to ==, probably. x :/= y must mean "assign x to not be y".
14:30:03 <ndm> http://www.cs.york.ac.uk/fp/elements/no_assignment.png
14:30:45 <ndm> its usually a logo for pure functional things, which lack destructive updates
14:31:23 <ihope> There's a language called :â .
14:31:40 <sris> ah ok. because i just started a fp course, and our lector told us it was a common symbol/logo for fp, but i could find it anywhere on the net ;)
14:31:55 <ihope> :/= would be a nice ASCII representation for it.
14:32:35 <ihope> Now, I forgot what I was going to say. I wanted to say something, but I accidentally joined #haskel instead, so I redirected it here, then I joined #tapthru to ask if that was okay...
14:32:56 <ndm> sris: its not really that common, ocasionally only
14:33:14 <ndm> http://www.cs.york.ac.uk/fp/past.php
14:33:16 <lambdabot> Title: York Functional Programming Past Members, Projects and Theses
14:33:16 <sris> ah ok
14:33:18 <ndm> thats where i got it from
14:33:22 <monochrom> I guess a symbol for imperative programming would be "no lambda"
14:33:44 <ndm> monochrom: but all imperative languages are busy adding lambda! (apart from python which is busy removing it)
14:37:08 <norpan> lambda is overrated
14:37:26 <norpan> i prefer kappa
14:37:57 <ihope> Python is busy removing lambda?
14:38:58 <ndm> ihope: its a proposal for Python 3000
14:39:00 <tenni1> hmm, I thought Guido'd relented on that stuff, last I heard
14:39:12 <ndm> oh, maybe Guido has changed his mind again
14:39:44 <CosmicRay> Igloo: ping
14:40:33 <Igloo> hi
14:40:55 <CosmicRay> Igloo: did you see my note about ghc6 on alpha stable?
14:41:30 <Igloo> I saw the one I replied with "CosmicRay: In the same way?" to
14:41:45 <CosmicRay> ahh, yes, in the same way
14:41:59 <ihope> Why remove lambda? Why not add case instead?
14:42:09 <Igloo> Hmm, that's interesting
14:42:31 <Igloo> CosmicRay: This is ghc 6.4.2-something, right?
14:42:51 <CosmicRay> yes
14:43:32 <monochrom> Haha!  Now I know the symbol for OOP.  "no case". :)
14:44:43 <Igloo> CosmicRay: Can you grab the source for 6.4.1-2.1 from http://snapshot.debian.net/archive/2006/03/27/debian/pool/main/g/ghc6/ and try building that please?
14:44:45 <lambdabot> Title: Index of /archive/2006/03/27/debian/pool/main/g/ghc6
14:45:01 <Igloo> CosmicRay: If that succeeds then I'll diff them and see if anything obvious sticks out
14:45:35 <CosmicRay> Igloo: that one is known to build on alpha according to the buildd logs
14:45:41 <CosmicRay> http://buildd.debian.org/build.php?arch=alpha&pkg=ghc6
14:45:45 <lambdabot> Title: Package: ghc6 (alpha)
14:46:00 <Igloo> CosmicRay: It's known to have built on one alpha at one point  :-)
14:46:29 <CosmicRay> ok, fair enough.
14:46:54 <CosmicRay> that version is still in testing, thus still in the main archive
14:47:04 <CosmicRay> do you want me to build it on stable or testing?
14:47:41 <Igloo> Actually, let me just look at the diff quickly first
14:48:25 <tennin> wouldn't FORTH and relatives be the only purely imperative languages, besides ASM?
14:48:59 <vincenz> purely imperative
14:49:03 <vincenz> talk about a contradiction
14:50:28 <ihope> No functions. :-)
14:53:04 <Igloo> CosmicRay: What is maxBound :: Int?
14:53:18 <CosmicRay> in which version?
14:53:42 <Igloo> Any that fail to build 6.4.2
14:53:45 <Cale> tennin: also, anything so close to assembly that it didn't have subroutine abstractions at all :)
14:54:07 <CosmicRay> 9223372036854775807
14:54:17 <CosmicRay> 2 ^ 63, IOW
14:54:21 <CosmicRay> err, 2 ^ 63 - 1
14:54:28 <Cale> So, perhaps early versions of Basic would qualify?
14:54:44 <CosmicRay> that with ghc6 6.2.2
14:55:59 <CosmicRay> same in ghc6 6.4.1-2.1
14:56:23 <Cale> ihope: I think they should remove lambda from python, and then add back in a sane lambda :)
14:56:40 <CosmicRay> Igloo: this is interesting because sizeof(int) is 4 on alpha
14:57:02 <mauke> python is fundamentally C-like in its distinction between statements and expressions
14:57:07 <CosmicRay> I guess a Haskell int is mapping to a long.
14:57:41 <CosmicRay> btw I have to leave in 5m
14:57:42 <lucca> sizeof(int) != sizeof(int*) happens but is a revolting state of affairs
14:57:57 <norpan> a haskell int is implementation defined
14:57:58 <CosmicRay> lucca: that is indeed the case on alpha and I don't know why it's a problem
14:58:05 <Cale> lucca: should that matter?
14:58:06 <norpan> so it can map to int, long long long
14:58:09 <norpan> whatever you like
14:58:15 <CosmicRay> lucca: anybody that assumes that sizeof(int) == sizeof(void *) is writing braindead code
14:58:15 <norpan> it's up to the compiler
14:59:00 <Cale> The Haskell98 spec only guarantees the range [-2^29, 2^29 - 1]
14:59:06 <Cale> for Int
14:59:26 <CosmicRay> why 2^29 instead of 2^31 or even 2^30?
14:59:28 <mauke> which means a portable C implementation must use long :-)
14:59:41 <Cale> I'm not sure. Probably some strange architecture was considered :)
14:59:45 <norpan> saving two bits for a clever trick
14:59:51 <Igloo> CosmicRay: OK, I'm not convinced about
14:59:53 <Igloo> +nopOp ChrOp         = True  -- Int# and Char# are rep'd the same
14:59:53 <Igloo> +nopOp OrdOp         = True
14:59:53 <ndm> CosmicRay: tagged integers
14:59:59 <Igloo> in codeGen/CgPrimOp.hs
15:00:15 <CosmicRay> Igloo: ahh, interesting.
15:00:28 <ndm> CosmicRay: you might want to tag something as primitive vs a pointer to a thunk
15:00:35 <CosmicRay> so they're implying that, essentially, maxBound::Char == maxBound::Int?
15:00:38 <Cale> You can use minBound and maxBound to get the full extents on any given machine
15:00:53 <norpan> CosmicRay: no
15:00:59 <lucca> CosmicRay: I won't contradict that...  My point was more along the lines that for many architectures where that is the case, there are actually multiple pointer sizes, which is very awkward.
15:01:18 <Cale> > fromEnum (maxBound :: Char)
15:01:20 <lambdabot>  1114111
15:01:21 <Igloo> HsChar = StgChar = StgWord32 always AFAICS
15:01:25 <Cale> > fromEnum (maxBound :: Int)
15:01:26 <lambdabot>  2147483647
15:01:34 <CosmicRay> lucca: ahh, Alpha has only one pointer size, and it's always 64 bits
15:01:55 <Cale> > fromEnum (minBound :: Int)
15:01:57 <lambdabot>  -2147483648
15:02:00 <Cale> > fromEnum (minBound :: Char)
15:02:01 <lambdabot>  0
15:02:28 <Igloo> That's certainly one thing that coudl be wrong, anyway. I'll look for its commit message in a sec, and talk to Simon tomorrow
15:02:35 <CosmicRay> Igloo: if you want to mail me a diff, I could start a build later this evening or first thing tomorrow
15:03:00 <CosmicRay> Igloo: sounds plausible, though I wonder why amd64 hasn't tripped over that
15:03:12 <CosmicRay> Int is 64 bits there too (just checked)
15:03:17 <Cale> The definition of approxRational is interesting.
15:03:46 <Cale> approxRational takes two real fractional arguments x and e and returns the simplest rational number within e of x, where a rational p/q in reduced form is simpler than another p' / q' if |p| <=|p'| and q <=q' . Every real interval contains a unique simplest rational; in particular, note that 0/1 is the simplest rational of all.
15:03:50 <Igloo> CosmicRay: It'll be somewhat random, dependent on what happens to be next to things that get casted incorrectly
15:03:58 <Igloo> casted? Sheesh
15:04:04 <CosmicRay> oic
15:04:12 <CosmicRay> you brits
15:04:14 <tennin> the m4 manual referred to "functional languages such as C"
15:04:17 <CosmicRay> always with the grammar innovations
15:04:21 <CosmicRay> tennin: hah
15:04:35 <Cale> tennin: haha
15:04:54 <CosmicRay> tennin: as opposed to m4, which is a dysfunctional language? ;-)
15:05:26 <ricky_clarkson> Brits?
15:05:33 * ricky_clarkson is in Manchester.
15:05:50 <CosmicRay> Igloo is in the UK somewhere, I thought
15:06:34 * ndm is in Bristol now, but usually in York
15:06:47 <CosmicRay> ricky_clarkson: there are quite a few people from the UK in the haskell community
15:07:06 <ricky_clarkson> Good.
15:07:23 <Igloo> I'm in Oxford, yes
15:07:50 <ricky_clarkson> What role?
15:07:55 <ndm> nhc, Yhc, GHC and Hugs are all UK Haskell maintained
15:07:56 <tennin> @google "dysfunctional programming"
15:07:59 <ricky_clarkson> Student, lecturer, bicycle thief, etc.
15:07:59 <lambdabot> http://fishbowl.pastiche.org/2003/09/24/introducing_dysfunctional_programming
15:08:00 <lambdabot> Title: The Fishbowl: Introducing: Dysfunctional Programming
15:08:20 <tennin> don't think that's the one I wanted
15:09:02 * CosmicRay must run
15:11:29 <astrolabe> Cale: Sounds like continued fraction stuff.
15:11:51 <bringert> Igloo: I keep getting this when building ghc HEAD:
15:11:53 <bringert> _regexzmcompatzm0zi71_TextziRegex_a1_closure
15:11:54 <bringert> ...
15:12:26 <bringert> it seems to come from the linking of stage1/ghc-6.5
15:13:26 <bringert> huh? why did it only paste one line?
15:13:29 <Igloo> bringert: Is that a new problem? I'll try updating my tree in a sec
15:13:41 <bringert> got it first time yesterday
15:14:12 <bringert> it's an undfined symbol error, but you figured that out I guess
15:15:53 <vincenz> bringert: did yoou ever get around to reading my email?
15:15:54 <bringert> OS X/Intel, compiling with HEAD from a few days ago
15:16:06 <bringert> vincenz: what e-mail?
15:16:15 <bringert> date?
15:16:21 <vincenz> erm
15:16:23 <vincenz> cant' remember
15:16:28 <vincenz> the one concerning the GADT stuff
15:16:32 * vincenz loks
15:16:37 <bringert> I didn't answer that?
15:17:06 <vincenz> bringert: what's your email?
15:17:19 <bringert> bringert@cs.chalmers.se
15:17:19 <vincenz> my sent box is too large
15:17:31 <bringert> or bjorn@bringert.net
15:17:40 <bringert> is it
15:17:41 <bringert> Compos and demonstration with ANF
15:17:55 <vincenz> yes!
15:18:06 <ndm> ah, bringert, have you met Matt Naylor?
15:18:10 <tieTYT> this function comes from YAHT: http://paste-bin.com/230
15:18:20 <bringert> vincenz: there's no question in it
15:18:24 * vincenz has two sentboxes
15:18:28 <tieTYT> it's extremely difficult for me to figure out what's going on.  Is that because everything is poorly named or do i just suck?
15:18:44 <vincenz> bringert: well no... I was hoping on feedbak, there'd been talk about possibly investigating if this was worthy of submissio.
15:18:46 <bringert> did you ask somthing in here about it? or did you just want my comments?
15:18:51 <bringert> ah, right
15:19:12 <bringert> ndm: I don't think I have. who's he?
15:19:18 <norpan> tieTYT: is the code not commented in yaht?
15:19:27 <ndm> bringert: he's at chalmers this summer, a UK student, who sits next to me
15:19:35 <tieTYT> the code itself, no
15:19:37 <tieTYT> it talks about it
15:19:45 <norpan> and you still don't understand?
15:19:48 <bringert> ndm: so you are at chalmers too then :-P
15:19:58 <tieTYT> i understand the end result of what it does
15:20:00 <bringert> ndm: is he still here?
15:20:01 <tieTYT> but not how it does it
15:20:07 <ricky_clarkson> tieTYT: How far into yaht is that?
15:20:07 <ndm> bringert: hehe, no, i haev just stolen his desk
15:20:08 <bringert> who is he working with?
15:20:17 <ndm> bringert: yes, i think he's still there for another couple of weeks
15:20:19 <tieTYT> 4.6
15:20:32 <ndm> Koen, Mary
15:20:36 <bringert> I've only been at chalmers a few days the last 4 months
15:20:39 <norpan> surely there is simpler code leading up to that?
15:20:47 <ndm> and one of their students, Axel maybe?
15:20:54 <bringert> right, I should have gone to the fp research meeting today
15:20:58 <tieTYT> no actually, there's more complicated abstract examples before that
15:21:04 <tieTYT> but it doesn't show their implementations
15:21:10 <bringert> I always forget stuff like that
15:21:25 <bringert> what's he working on?
15:21:43 <ndm> circuits and combinator libraries in haskell - wired and ash
15:21:57 <norpan> tieTYT: but you do understand all the syntax?
15:22:08 <tieTYT> yes i understand all the syntax
15:22:14 <tieTYT> it's just difficult for me to understand what's going on
15:22:16 <bringert> I'll hopefully meet him before I go to icfp, which is starting to be pretty soon
15:22:35 <tieTYT> because these variables are defined in order x y z and used in this order: z y x
15:22:43 <tieTYT> and x y z aren't very descriptive in the first place
15:22:54 <tieTYT> do people usually define their arguments as a single letter?
15:22:54 <bringert> ndm: you could tell him to come to #haskell, quite a few chalmers people hang out here
15:23:09 <bringert> vincenz: looking at the code...
15:23:10 <norpan> tieTYT: well, this is an example of what is called continuation passing style
15:23:26 <norpan> which is hard to grasp
15:23:31 <bringert> vincenz: didn't we discuss this on IRC?
15:23:33 <ndm> bringert: he leaves before everyone goes off to fp, he's not much for online chat - he never even signs into instant messenger
15:23:39 <Igloo> bringert: What are you up to these days, OOI?
15:23:41 <vincenz> bringert: prior to the email
15:23:53 <ricky_clarkson> I've so far found that everything that is 'hard to grasp', conceptually, in Haskell, isn't.
15:23:56 <bringert> Igloo: compiling ghc HEAD
15:23:59 <ricky_clarkson> Only the syntax is hard.
15:24:00 <bringert> :-;
15:24:13 <bringert> eh, that's a weird smiley
15:24:16 <Igloo> bringert: If that really takes days then I pity you  :-)
15:24:25 <tieTYT> norpan: i'm trying to figure out where the y comes from in (\y -> cfold f y xs)
15:24:27 <norpan> ricky_clarkson: well, cps style IS hard to grasp
15:24:38 <norpan> tieTYT: the y is bound in the lambda expression
15:24:50 <bringert> Igloo: I'm just starting up my work here again after 3 months in the US
15:25:01 <norpan> so \y -> ... means a function taking a value (which is bound to y)
15:25:06 <bringert> I did mostly haskell web programming stuff over the summer
15:25:06 <tieTYT> yeah but how does it get used
15:25:23 <norpan> it's passed as an argument to the recursive call of cfold'
15:25:27 <tieTYT> i'm assuming the cfold (no tick) somehow assigns something to y
15:25:27 <Igloo> bringert: But what are you now, PhD at Chalmers?
15:25:35 <araujo> hi hi!
15:25:42 <bringert> ah, right
15:25:44 <norpan> tieTYT: no
15:25:52 <norpan> y is only local to the lambda expression
15:25:53 <bringert> yes, PhD student at chalmers since 1 year
15:26:14 <norpan> (\y -> ...) is a function value
15:26:18 <bringert> Igloo: you've finished your phd?
15:26:45 <mauke> > (\y -> y * y) 4
15:26:47 <lambdabot>  16
15:26:50 <tieTYT> yes i understand that
15:26:51 <Igloo> Submitted, but not been viva'd
15:26:56 <tieTYT> but in this: map (\x -> x + 5) [1,2,3]
15:27:14 <tieTYT> somewhere on the inside of map, it assigns 1 to x, then 2 to x, then 3 to x, right?
15:27:18 <mauke> no
15:27:25 <mauke> it calls the function
15:27:34 <tieTYT> ok well
15:27:40 <tieTYT> this is semantics
15:27:47 <tieTYT> where does it call the function in cfold?
15:27:52 <tieTYT> the lambda function
15:28:00 <tieTYT> err, cfold`
15:28:07 <araujo> map (\ x -> x + 5) [1 , 2 , 3] == let f = \ x -> x + 5 in [ f 1 , f 2 , f3 ]
15:28:16 <norpan> tieTYT: it doesn't
15:28:18 <araujo> tieTYT, ^^
15:28:33 <araujo> that's what a map translate at
15:28:37 <norpan> it passes the function as an argument to f
15:28:56 <tieTYT> norpan: and then what?
15:28:58 <norpan> and the function f uses that function value
15:29:08 <norpan> depending on what function f you pass in
15:29:28 <norpan> in this case, the function f is (\x t g -> f x (g t))
15:29:41 <norpan> it's quite confusing that both cfold and cfold' use the name f
15:29:53 <tieTYT> heh that was my original question
15:30:00 <tieTYT> the names of these things doesn't make it any easier
15:30:27 <araujo> > (==) (map (\ x -> x + 5) [1 , 2 , 3]) (let f = \ x -> x + 5 in [ f 1 , f 2 , f 3 ])
15:30:29 <lambdabot>  True
15:30:29 <norpan> so replace f by f' everywhere in the def of cfold'
15:30:33 <araujo> yay!
15:30:50 <tieTYT> cfold f` z (x:xs) = f` x z (\y -> cfold f` y xs)
15:31:06 <norpan> well, ` is not allowed
15:31:38 <mauke> U+2019 (0xe2 0x80 0x99): RIGHT SINGLE QUOTATION MARK [â]; U+0060 (0x60): GRAVE ACCENT [`]
15:31:44 <mauke> you're supposed to use [']
15:31:54 <mauke> U+0027 (0x27): APOSTROPHE [']
15:32:22 <tieTYT> it's complaining about that too
15:32:52 <tieTYT> oh
15:33:01 <tieTYT> that's cause the code i copied from the pdf used a bad tick
15:38:06 <tieTYT> ricky_clarkson: care to explain what's going on then?
15:39:08 <tieTYT> pft
15:39:11 <tieTYT> now i get this
15:39:15 <tieTYT> i hate the way it was written
15:39:20 <ricky_clarkson> tieTYT: nfi, wait until I get there. ;)
15:40:21 <tieTYT> the t in cfold becomes the y in cfold'
15:43:13 <tieTYT> what's nfi?
15:43:29 <mauke> no fucking idea
15:50:37 <bringert> Igloo: good timing with the ghc gig then I guess?
15:50:50 <bringert> the linking error seems to have fixed itself btw
15:51:31 <bringert> the power of ./darcs-all pull -a && make clean && ./configure && make
15:52:37 <vincenz> bringert: hmm, so any remaining thoughts or should I close the issue?
15:52:44 <vincenz> feedback? :D
15:52:49 <bringert> right
15:53:10 <bringert> I was on the phone, lost track of the three simultaneous irc conversations
15:53:14 <vincenz> noo prob :)
15:53:31 <bringert> I think I started playing with your code
15:53:36 <bringert> let's see if I find it
15:54:07 <vincenz> okies
15:54:54 <Igloo> bringert: Yup  :-)
15:55:34 <Igloo> And good to hear; my build is still going
15:57:18 <bringert> vincenz: I don't seem to have it, but I think it went along these lines: instead of replacing t a with t a b everywhere, you could maybe make it so that t is (t b), and use the old composOp
15:57:30 <bringert> but maybe I missed somthing in what you want to do
15:58:09 <bringert> I think I would more examples of functions using the stuff you sent me
15:58:28 <bringert> anyway, it's an interesting problem
15:59:02 <bringert> I'm not sure how widely applicable the results would be. can you think of any applications besides
15:59:09 <bringert> *phone*
15:59:26 <vincenz> the issue was with the Tag type which required an extra parameter
16:07:43 <bringert> phone again
16:08:30 <ricky_clarkson> "Do you mind, I'm trying to IRC"
16:32:22 <bringert> ok
16:33:17 <bringert> vincenz: I don
16:33:28 <bringert> 't see a Tag type in the code you sent me
16:33:57 <bringert> did you mean the ANFTag constructor?
16:35:23 <bringert> if so, ANF could still be * -> * -> *, but the tag parameter would the first one, so that ANF could be partially applied, to become a unary type constructor
16:35:33 <bringert> and you could then use the normal composOp
16:35:53 <bringert> but maybe there's some usage example where that doesn't work
16:36:14 <ell-hask> Is there a command such as 'type' that will perform type enforcement and still inheret all of the type classes?
16:36:48 <bringert> vincenz: I'm off for a few days, you are welcome to send me e-mail
16:36:56 <SamB> ell-hask: you could use the "newtype deriving" extension
16:37:10 <ell-hask> SamB: but you can't derive 'Num'
16:37:18 <SamB> ell-hask: sure you can!
16:37:34 <ell-hask> SamB: Please explain, it balks at me when I try.
16:37:41 <SamB> that is what the newtype deriving extension *does* -- derives arbitrary typeclasses!
16:37:44 <bringert> why isn't the logs url in the subject anymore?
16:38:16 <twanvl> you need the -fglasgow-exts flag for newtype deriving
16:38:29 <bringert> ell-hask: newtyp MyInt = MyInt Int deriving Num
16:38:35 <bringert> eh newtype
16:39:35 <ell-hask> twanvl: Thanks. So I would be corrent in saying this is not Haskell 98.  Perhaps Haskell' is considering this?
16:40:35 <SamB> *Main> :!cat newtype.hs
16:40:35 <SamB> {-# OPTIONS_GHC -fglasgow-exts #-}
16:40:35 <SamB> newtype Int2 = Int2 Int
16:40:35 <SamB>     deriving (Eq, Ord, Show, Bounded, Enum, Num, Real, Integral)
16:40:35 <SamB> *Main> :l newtype.hs
16:40:37 <SamB> Compiling Main             ( newtype.hs, interpreted )
16:40:39 <SamB> Ok, modules loaded: Main.
16:41:00 <bringert> yeah, that's good question
16:41:14 <bringert> this is a typical good Haskell' candidate
16:41:30 <bringert> are there any conceptual problems with newtype deriving?
16:41:34 <SamB> bringert: very well defined in the non-MPTC case ;-)
16:42:10 <bringert> hmm, yeah, MPTCs could be messy
16:42:12 <SamB> the only problem is that Show doesn't get derived the same way as other things, with newtype deriving...
16:42:20 <bringert> ah, right
16:42:28 <bringert> that is strange
16:42:32 <bringert> hmm
16:42:42 <SamB> anyway, MPTCs seem like they aren't to be standardized in Haskell'
16:42:44 <ell-hask> SamB: How did you come by indepth knowledge of how the classes are derived/
16:42:46 <ell-hask> ?
16:43:02 <SamB> ell-hask: oh, they are derived in a very simple way ;-)
16:43:53 <SamB> I'm not sure exactly how it is mathematically specified, but in actuallity it just uses the same instance dictionary...
16:44:13 <SamB> GHC does, I mean
16:44:23 <SamB> not sure how JHC would do it
16:46:24 <ricky_clarkson> @what JHC
16:46:24 <lambdabot> http://repetae.net/john/computer/jhc/
16:46:26 <SamB> anyways, I'm pretty sure there are some fairly simple rules for deriving things from the method signatures...
16:46:46 <SamB> @help what
16:46:46 <lambdabot> what <key>. Return element associated with key
16:46:51 <SamB> @help where
16:46:52 <lambdabot> where <key>. Return element associated with key
16:47:37 <SamB> probably isn't too hard to do it in TH
16:59:29 <vincenz> bringert: sorry about that
16:59:44 <vincenz> bringert: I replied by email, basically you can't change the tag-type with a composop
16:59:55 <vincenz> with what you propose
17:00:29 <bringert> hmm, right
17:00:39 <bringert> maybe you could write another function for that
17:01:32 <bringert> hmm, that's what you did, isn't it
17:01:48 <vincenz> yeah but it was defined in terms of composop
17:02:09 <vincenz> heh
17:02:13 <vincenz> one interesting pattern
17:02:18 <vincenz> assume some annotate function
17:02:23 <vincenz> that annotates with tag type X
17:02:26 <vincenz> so
17:02:33 <vincenz> annotate :: ANF X b -> ANF X b
17:02:37 <vincenz> then to go from an ANF X a
17:02:43 <vincenz> (annotate . untag )
17:02:49 <vincenz> untag is polymorphic in it's output :)
17:03:08 <bringert> and puts undefined everywhere?
17:03:12 <vincenz> no
17:03:15 <vincenz> removes tags
17:03:35 <vincenz> tho another option would be
17:03:41 <bringert> hold on, is the tag type the first or second type argument?
17:03:42 <vincenz> untag :: ANF a b -> ANF (Either a c) b
17:03:47 <vincenz> first
17:04:11 <vincenz> ack
17:04:13 <vincenz> never mind
17:04:13 <vincenz> second
17:04:15 <bringert> so what's the type of your first untag?
17:04:28 <vincenz> untag :: ANF a b -> ANF a c
17:04:42 <vincenz> annotate :: ANF a x -> ANF a x
17:04:48 <vincenz> though another useful pattern might be
17:04:58 <vincenz> pretag :: ANF a b -> ANF a (Either b c)
17:05:02 <vincenz> and leave c polymorphic
17:05:03 <bringert> ah, right, the tag argument is only ever used by ANFTag, and untag removes those
17:05:21 <vincenz> yeah
17:05:24 <vincenz> it's phantom for the rest
17:05:44 <bringert> or untag :: (b -> c) -> ANF a b -> ANF a c
17:05:49 <vincenz> possibly yeah
17:05:53 <vincenz> good pattern
17:05:55 <bringert> well, that should be called retag or something
17:06:04 <vincenz> well untag could be written in terms of retag
17:06:11 <vincenz> except ... not cause untag removes Tag stuff
17:06:16 <bringert> right
17:06:37 <vincenz> hmm
17:06:42 <vincenz> the version I sent you is not polymorphic
17:06:45 <vincenz> it untags to ANF a ()
17:07:53 <bringert> as I said before, this is an interesting problem, but in order for it to be publishable at a conference or workshop, it might need to have more applications. can you think of any besides tagged syntax trees?
17:08:02 <vincenz> I'll think about it
17:08:51 <bringert> I'm off to bed, flying to germany tomorrow. this is fun stuff to think about, bug me again whenever
17:08:56 <bringert> good night #haskell
17:10:25 <vincenz> hasta leugo
17:10:27 <vincenz> have a good flight
17:10:30 <vincenz> luego even
17:13:22 <bringert> vincenz: thought about it while brushing my teeth, what about:
17:13:26 <bringert> tag :: (ANF t1 a -> t2) -> ANF t2 a
17:13:47 <monochrom> ANF = ?
17:14:02 <bringert> that just adds ANFTag with the result of the first argument to all nodes
17:14:22 <vincenz> hmm
17:14:33 <bringert> monochrom: a GADT abstract syntax typ, with parameters for tag and syntactic category
17:14:46 <vincenz> and generic traversal thanks to bringert
17:15:17 <wolverian> having to write pseudocode for this data structures course in an imperative style is really wrecking my brain after months of haskell.
17:16:00 <vincenz> bringert: though I should prolly put the tag as first part, but I can't remember the reason why I didnt'
17:16:16 <monochrom> There is a standard chore procedure for translating most functional pseudocode to imperative peusdocode.
17:16:36 <wolverian> I suppose there would be.
17:17:11 <monochrom> Oh, yuck, I forgot translating sane data structures like trees to insane pointer manipulations. :)
17:18:53 <wolverian> right.. rotating red-black trees is rather annoying, if simple
17:18:55 <monochrom> data MyTree = Leaf | Branch Int MyTree MyTree   -- this is what wrecks your brain when translating
17:20:30 <monochrom> I always like to point out this observation.  In an imperative curriculum you're like chapter 2 for-loops and chapter 10 binary search trees.  In a functional curriculum you're like chapter 2 binary search trees and chapter 10 XML processing using arrows.  The difference in productivity is incredible.
17:22:24 <ricky_clarkson> monochrom: To be fair, I teach imperatively, and I don't spend a huge amount of time on things like for loops.
17:23:37 <tennin> clearly there is a market need for a Haskell -> imperative-pseudocode compiler
17:27:32 <ricky_clarkson> Is there a list of which educational establishments teach Haskell (or anything similar, including lisp), preferably those in the UK?
17:28:55 <monochrom> Not purely, but haskell.org -> "haskell in education" has stuff.
17:29:47 <ricky_clarkson> Cheers.
17:31:40 <monochrom> w00t, Igloo is the GHC tech support!  (Yes I have a serious backlog of the mailing lists)
17:31:53 <dons> ?remember monochrom In an imperative curriculum you're like chapter 2 for-loops and chapter 10 binary search trees.  In a functional curriculum you're like chapter 2 binary search trees and chapter 10 XML processing using arrows.  The difference in productivity is incredible
17:32:17 <dons> ?users
17:32:26 <lambdabot> Maximum users seen in #haskell: 235, currently: 197 (83.8%), active: 25 (10.6%)
17:33:38 <monochrom> I used to say "chapter 10 theorem proving" there.  Of course theorem proving is not exactly profitable. :)  For several years I couldn't think of a good application to put there, but I'm glad now we have one.
17:34:05 <vincenz> nono
17:34:07 <vincenz> it's not like that
17:34:39 <vincenz> imperative programming: chapter 2 for-loops, chapter 1: binary triess, functional programming: chapter 2: binary trees, chapter 10: for-loops
17:35:01 <monochrom> haha
17:35:05 <ndm> ricky_clarkson: i think the survey that someone did was more complete, can't remember who it was
17:35:20 <ndm> was one of the authors of the original haskell report
17:35:24 <ndm> about a year ago
17:35:53 <ndm> ricky_clarkson: http://www.cs.chalmers.se/~rjmh/Wash/Survey/teaching.htm
17:37:14 <vincenz> monochrom: yeah... side-effects require monad knowledge, then IO, then IORefs...
17:38:12 <monochrom> I personally put side effects and monads in chapter 5-8
17:39:02 <ndm> when i got taugth Haskell, side effects and monads weren't on the sylabus
17:39:23 <Cale> I think I'd probably teach types and values first, and include typeclasses in that discussion
17:39:33 <ndm> it makes you a much better functional programmer if you don't give someone side effects until way after they need them
17:39:57 <ndm> Cale: really? type classes are way confusing!
17:40:02 <ndm> Types are hard enough
17:40:07 <Cale> I think they're sort of critical though.
17:40:16 <ndm> not to functional programming
17:40:19 <ndm> to haskell, yes
17:40:21 <Cale> To Haskell programming
17:40:32 <ndm> but you want to introduce functional programming first, then haskell after that
17:40:34 <vincenz> ndm: type classes are easy
17:40:38 <tennin> "How to Design Programs" doesn't introduce mutating functions like set! until near the end
17:40:44 <Cale> They're not that bad
17:40:50 <ndm> vincenz: i dare you to tell that to a begining
17:40:56 <ndm> programmer
17:41:18 <Cale> ndm: I explained them to my friend right off the bat, and he had no problems :)
17:41:22 <ndm> they are easy now, but they are a cmoplication over types, hence you need a lot of type knowledge
17:41:57 <ndm> Cale: i demonstrate for 3rd year comp scis, they need things explaining slowly and in small steps
17:41:58 <monochrom> Beginning programmers can grok C++ operator overloading.  Hence they can grok Haskell type classes too.
17:42:00 <Cale> (then again, he has a degree in pure mathematics)
17:42:13 <ndm> Cale: yeah, like most haskell beginners :)
17:42:27 <monochrom> Ok, oops, pure mathematicians can grok operator overloading, therefore ... :)
17:42:37 <Cale> Yeah, typeclasses are cleaner and easier to understand than polymorphism in basically any other language
17:43:08 <Cale> We teach OO programming and subtyping and all that, and that seems way more complicated to me than typeclasses.
17:44:16 <ndm> we teach Ada first
17:44:22 <ricky_clarkson> Cale: I don't teach subclassing (in Java) to new programmers.
17:44:31 <ndm> which has one of the most confusing type systems ever
17:44:43 <ndm> made infinitely worse by the fact that aliasing isn't obvious
17:44:54 <ndm> for example in haskell:
17:44:59 <ndm> [a]
17:45:04 <ndm> [Maybe a]
17:45:11 <ndm> however in Ada, you'd have to come up with
17:45:17 <ndm> type Maybe_a = Maybe a
17:45:21 <ndm> [Maybe_a]
17:45:33 <ndm> so introduce an alias for every type expression!
17:45:39 <ndm> it makes the types unreadable
17:47:47 <Cale> yeah
17:48:15 <Cale> My friend actually wrote a full optimising Ada compiler for the compilers course
17:48:31 <Cale> and he had no shortage of complaints regarding Ada's lack of sanity
17:49:14 <ndm> with all the threading features?
17:49:31 <ndm> those are the only things that makes ada any good, and i guess STM blew that out of the water
17:49:56 <Cale> Yeah, I think so, and I seem to recall hearing things about the type system
17:50:12 <Cale> This was a couple years back now, so I don't recall things too clearly.
17:51:05 <Cale> Teaching Ada as a first language seems like a good way to crush the spirits of young programmers though :)
17:51:08 <ndm> an impressive acheivement
17:51:12 <ndm> yeah, it does indeed
17:51:28 <ndm> i demonstrated for a data structures and algorithms course in Ada
17:51:33 <ndm> first langauge for undergrads
17:51:42 <ndm> i got one data structure question in the whole 10 weeks
17:51:51 <ndm> the rest were "what is wrong with this stupid language"
17:52:06 <Cale> hehe
17:52:33 <lispy> at my school we teach them C for a term then force java on them for 3 years :)
17:52:35 <lispy> it's fun
17:53:00 <ricky_clarkson> lispy: How does the C work out?
17:53:01 <lispy> and a wonder anyone can write software that graduates
17:53:08 <SamB> how is that *fun*?
17:53:10 <lispy> ricky_clarkson: everyone hates it
17:53:14 <SamB> you are *evil*!!!
17:53:21 <ricky_clarkson> lispy: Why?
17:53:25 * lispy isn't an instructor
17:53:36 <lispy> SamB: so, *they* are *evil*
17:53:37 <SamB> lispy: maybe they can't do anything in it
17:53:56 <lispy> ricky_clarkson: because it's hard to learn C as your first language
17:53:58 <ricky_clarkson> I've seen C taught using C++, just so that they could avoid pointers.
17:54:05 <ricky_clarkson> I.e., use cin and cout.
17:54:06 <SamB> huh
17:54:09 <ricky_clarkson> Completely pointless.
17:54:11 <SamB> ho!
17:54:16 <SamB> that is pointless indeed
17:54:18 <ricky_clarkson> [no pun intended]
17:54:23 <Cale> At waterloo, there was one course on OO programming in Java for me, and then a baby compilers course, which was in Java, but also involved learning scheme and the basics of unix (which was just to make sure everyone knew unix). Now I think they've changed things so that students get a choice between Java and Scheme.
17:54:29 <Cale> (all the way through)
17:54:39 <SamB> you could just teach people to use FILE*s and tell them the stars mean that they are special
17:54:44 <SamB> like char*s
17:54:55 <ricky_clarkson> Cale: I bet hardly anyone chooses Scheme.
17:55:17 <Cale> ricky_clarkson: They apparently get full classes out of it.
17:55:28 <Cale> ricky_clarkson: It's the advanced section.
17:55:31 <ricky_clarkson> Must be an affluent area.
17:55:36 <ricky_clarkson> ..not worried about jobs.
17:55:40 <Cale> hehe
17:55:44 <SamB> um
17:55:54 <SamB> you don't get a degree in Java or Scheme anyway
17:55:55 <Cale> Or they figure they already know Java well enough :)
17:55:57 <ndm> Currently york does Scheme then Ada
17:56:03 <Cale> SamB: Of course :)
17:56:04 <ndm> no options at all
17:56:19 <SamB> Ada?
17:56:22 <SamB> is that any good?
17:56:23 <ndm> everyone cries that Scheme is crap
17:56:25 <Cale> The whole Java thing is sort of a concession to the co-op placement program.
17:56:27 <ndm> then they see Ada, hehe :)
17:56:32 <ndm> SamB: NO!
17:56:34 <SamB> hah
17:56:41 <SamB> why don't they teach Ada first?
17:56:48 <ndm> humour value?
17:56:58 <SamB> so then noone would complain later when they teach scheme ;-)
17:56:58 <ndm> i have repeatedly asked, why not haskell then java
17:57:07 <Cale> ndm: hehe
17:57:08 <ndm> and i think everyone agrees that would be better
17:57:11 <SamB> ... because Java isn't funny enough?
17:57:27 <ndm> the idea of scheme is no one knows it, very little syntax, and totally different
17:57:31 <Cale> Haskell, and then MMIX
17:57:35 <SamB> HAH!
17:57:39 <ricky_clarkson> Haskell would scare off some students.
17:57:40 <ndm> so you can get those who know programming, and those who don't, at roughly the same level
17:57:50 <SamB> first... someone spec me a whole MMIX computer!
17:57:57 <ndm> i.e. don't teach two groups at totally opposite different standards
17:57:59 <SamB> knuth neglected to spec peripherals
17:58:08 <ndm> we also teach a stack machine processor
17:58:17 <ndm> and the 2nd year has Z80 assembly code
17:58:18 <SamB> or a bus architecture
17:58:19 <Cale> Who needs peripherals anyway
17:58:39 <SamB> Cale: it is tricky to write NNIX without peripherals
17:59:16 <ricky_clarkson> It's hard to justify anything where I teach that doesn't directly correlate to a job.
17:59:16 <SamB> a proper emulator for said architecture would be nice, too...
17:59:29 <tennin> ndm: probably also means less to unlearn
17:59:36 <ricky_clarkson> Modules like "Data Structures" are struggling to stay alive, for example.
17:59:51 <ndm> tennin: true
17:59:55 <SamB> I think he should have just picked a real architecture and subsetted it...
18:00:13 <Cale> In the second CS course I took there, we compiled from SL (simple language, essentially a baseline imperative programming language) into DLX assembly (which is sort of like a cut down variant of MIPS)
18:00:18 <ndm> ricky_clarkson: thats funny, in york it would be impossible to teach anything that had any practical relevance
18:00:38 <Cale> ricky_clarkson: Is this at a university?
18:00:41 <SamB> ricky_clarkson: huh
18:00:47 <ricky_clarkson> salford.ac.uk
18:00:50 <SamB> most jobs need data structures!
18:00:55 <Cale> Is the program called "Computer Science", or "Programming"?
18:01:00 <ricky_clarkson> SamB: Not often.
18:01:10 <ricky_clarkson> Cale: There are many, but none of them are called Programming.
18:01:18 <ricky_clarkson> Computer Science is our biggest.
18:01:46 <Cale> It seems to me that a computer science program shouldn't care at all about what employers want.
18:01:57 <SamB> well, I suppose ideally you just look through your catalog of datastructures and mail-order the ones you need...
18:02:02 <ricky_clarkson> Cale: Then it might get no students.
18:02:19 <Cale> Sure it would :) Pure mathematics gets students :)
18:02:21 <ricky_clarkson> SamB: Sure, but gone are the days when the average programmer (see that, average?  sniff) has to produce a hashtable implementation.
18:02:26 <ricky_clarkson> Cale: Not here.
18:02:29 <Cale> Huh
18:02:31 <ricky_clarkson> The maths department closed in 99.
18:02:35 <dons> Cale , that's interesting -- in my second course we compiled C0 (a baseline imperative lang) to mips
18:02:35 <SamB> ricky_clarkson: fortunate!
18:02:39 <Cale> Here we have a mathematics faculty
18:02:39 <SamB> hashes are the bitch!
18:02:59 <Cale> and CS is a school of that faculty (a bit larger than a department)
18:03:26 <SamB> wow!
18:03:28 <SamB> where is that?
18:03:29 <Cale> So naturally, it's very mathematics-heavy.
18:03:32 <Cale> Waterloo
18:03:37 <ricky_clarkson> Where's Waterloo?
18:03:38 <tennin> CS needs more popularization
18:03:45 <Cale> ricky_clarkson: Ontario, Canada
18:03:47 * SamB wonders if they accept transfers from his community college
18:04:46 <ricky_clarkson> A lot of our students are trying to push themselves up in the world, they're more bothered about jobs after uni.
18:05:00 <Cale> The Mathematics faculty includes departments of pure mathematics, applied mathematics, combinatorics and optimisation, actuarial science, and statistics.
18:05:12 <ricky_clarkson> The uni advertises that 94% of graduates get jobs or continue studies within 6 months of graduating.
18:05:14 <Cale> (and as I mentioned, the school of CS)
18:05:46 <SamB> Cale: do they have any trouble finding work?
18:05:54 <tennin> I don't think most of the public has any real idea that CS can be an academic discipline
18:06:19 <dolio> tennin: I'd agree with that.
18:06:22 <Cale> SamB: not that I'm aware of. I'm being a little slow about it, since I was burnt out, and have little experience actually searching for jobs.
18:06:23 <ndm> ricky_clarkson: what are the A level requirements?
18:06:23 <ricky_clarkson> tennin: I don't think most of the public are too enamoured with academia.
18:06:30 <tennin> they associate programming with nerds, boy geniuses, cubicle slaves, and Silicon Valley tycoons but not academics
18:06:42 <ricky_clarkson> ndm: Dunno.  Fairly low I think.
18:06:44 <dolio> I'd tell people my major was computer science, and they'd say something like, "oh, so you hook up networks and stuff?"
18:06:46 <Cale> SamB: But I think the statistics for employment/continuation are pretty good.
18:06:56 <ricky_clarkson> It was a bit below Manchester Uni a few years back.
18:06:58 <tennin> somebody like Dijkstra doesn't fit in at all
18:07:12 <Cale> ricky_clarkson: here, many of the CS students drop out though
18:07:23 <monochrom> Microsoft likes to hire from Waterloo.
18:07:27 <ricky_clarkson> Cale: Many of ours do in the first 4 weeks of the first year.
18:07:30 <Cale> ricky_clarkson: since they discover that they don't really want to be computer scientists :)
18:07:33 <ricky_clarkson> We're trying to solve that for this year.
18:07:40 <Cale> I think it's fine
18:07:41 <ricky_clarkson> Cale: They want to do web sites, right?
18:07:47 <tennin> hell, I didn't have any real idea of CS as an academic discipline even when I was a second-year CS student.
18:07:57 <Cale> If someone wants community college, let them drop out and take that instead.
18:08:14 <SamB> Cale: drop out or switch majors?
18:08:18 <Cale> SamB: yeah
18:08:23 <SamB> which!
18:08:29 <ricky_clarkson> Cale: I think the framework of a degree is more conducive to disciplined learning than a community college.
18:08:37 <ricky_clarkson> People drop out of the latter even easier.
18:08:46 <Cale> SamB: drop out and join one of the perfectly respectable community colleges which teach things like how to program in C++
18:09:03 <Cale> If that's what you're really into
18:09:13 <ricky_clarkson> ..so if you encouraged them to drop out in general you'd end up with less clueful people in general.
18:09:27 <Cale> If you're in a CS degree, then you should want to study the aspects of computing which won't be different in 1000 years.
18:09:39 <ricky_clarkson> If I'd not studied a degree I'd probably still know nothing about networking or security, but be a better programmer than I am now. ;)
18:09:42 <dmwit> But I won't be alive in 1000 years...
18:09:57 <Cale> dmwit: that's beside the point :)
18:10:00 <ricky_clarkson> Cale: Depends what a degree means really.
18:10:00 <dmwit> =)
18:10:18 <tennin> dunno about 1000
18:10:20 <lispy> dmwit: with current rate of advancement in technology you don't know that
18:10:20 <dmwit> It's hard to imagine what things will be the same in such a long future.
18:10:21 <ricky_clarkson> If degrees can be obtained in Leisure and Tourism, then it's an open field.
18:10:23 <tennin> I'd settle for 30
18:10:34 <lispy> dmwit: you might be around till then :)
18:10:47 <dmwit> Nah, negligible senescence won't be around until 2050, and it'll be too late by then. =P
18:11:00 <SamB> Cale: how about the aspects of computing that won't be different in ten years?
18:11:06 <SamB> I could live with ten years!
18:11:11 <Cale> SamB: sure
18:11:19 <dmwit> I could live ten years!
18:11:28 <ricky_clarkson> dmwit: Don't count on it.
18:11:36 <dmwit> Yikes.
18:11:37 <perry> ten years of what?
18:11:44 <dmwit> As long as you don't know where I sleep...
18:11:55 <ricky_clarkson> dmwit: Easy.  In bed.
18:12:10 <dmwit> =)
18:12:10 <SamB> actually, the class I'm in now is about C++ but most of the students haven't got to arrays yet...
18:12:15 <Cale> SamB: but that'll still include lots of stupid unimportant details
18:12:34 <SamB> Cale: useful to know for now, though!
18:12:41 <Cale> Programming languages seem to be lasting around 30 years these days.
18:12:45 <SamB> yeah
18:12:50 <ricky_clarkson> SamB: I normally used pointers instead of arrays in C/C++ because the syntax seemed more consistent.
18:12:58 <Cale> So maybe 50 years is a good cutoff. :)
18:13:00 <perry> Cale: how about fortran
18:13:03 <SamB> ricky_clarkson: I'm not sure what you mean ;-)
18:13:08 <ricky_clarkson> Cale: 15/20 years I think.
18:13:16 <Cale> perry: I'm happy to consider fortran dead :)
18:13:18 <SamB> Cale: but, the Java fad isn't lasting that long
18:13:19 <tennin> I think students should stop demanding that all classes directly lead to a job and start demanding that they all directly lead to romance and sex instead.
18:13:30 <perry> Cale: its not dead
18:13:34 <ricky_clarkson> SamB: Hehe, you wish.
18:13:37 <Cale> Close enough
18:13:47 <ricky_clarkson> SamB: If Java adds closures, as is planned, it might retain a few.
18:13:56 <SamB> ricky_clarkson: well, applets are dead
18:13:59 <SamB> flash has won
18:14:02 <ricky_clarkson> SamB: Of course.
18:14:11 <Cale> I suppose it still has a little bit of a following, but it's not exactly popular.
18:14:22 <ricky_clarkson> I don't think Sun really cared much about applets.
18:14:35 <ricky_clarkson> From /topic ##java - "No applets, use JWS instead"
18:14:35 <dmwit> tennin: I agree.
18:14:48 <SamB> Cale: some scientists still use fortran... it seems that it can perform better than C for some reason?
18:15:04 <perry> SamB: way easier to analyze
18:15:13 <jcreigh> SamB: The trick to understanding C++ is to think about how hard it is to implement a compiler. Then everything (well, most things) makes sense.
18:15:21 <perry> ... for optimization
18:15:27 <ricky_clarkson> There are proof mechanisms for C too, but they work most reliably on C code without malloc.
18:15:42 <SamB> jcreigh: why do they make it so hard to implement a compiler?
18:15:47 <tennin> yeah, Fortran is still common in computational chemistry
18:15:59 <tennin> because there's a huge legacy codebase
18:16:04 <Cale> Though most of the physicists I know use things like maple and mathematica, which are probably an order of magnitude slower at numerical computation, but symbolic computation is far more important.
18:16:20 <Cale> and hey, computers these days are fast
18:16:27 <SamB> tennin: I actually heard that C just *cannot* go so fast, because of certain assumptions that C compilers aren't allowed to make?
18:16:49 <SamB> maybe they aren't even assumptions for fortran compilers
18:17:00 <dmwit> I think Fortran passes everything by pointer.
18:17:09 <ricky_clarkson> I got offered a job writing Fortran compilers.
18:17:19 <lispy> Cale: i met a math prof, that said one version of mathematica was so slow they would have never figured out a theorem otherwise.  (Guess it took so long to do some manipulations that they found a way to simplify things) :)
18:17:20 <dmwit> A naÃ¯ve implementation of struct passing in C would do wonders for parameter passing...
18:17:37 <Cale> lispy: hehe
18:17:47 <Cale> lispy: Actually Mathematica's getting pretty fast these days
18:18:00 <lispy> Cale: this was years ago he said
18:18:03 <Cale> yeah
18:18:12 <Cale> Earlier versions were extremely slow.
18:18:30 <ricky_clarkson> One of my colleagues wrote some of the original FORTRAN 77 books.
18:18:36 <Cale> and they only fairly recently started caring about optimisation of numerics.
18:18:48 <SamB> Cale: maybe the theorem got into mathematica
18:18:51 <Cale> hehe
18:18:59 <jcreigh> SamB: I mean, the design choices made in the language. Why does defining a function in the class definition (ie, giving the function body in a header) automatically flag it for inlining? Because in order to inline functions, the compiler needs the source, and the .cpp might not be around. What is the point of "virtual" functions? Oh, because C++ wants to do function dispatch at compile-time. It seems like most of the weird design ...
18:19:05 <jcreigh> ... choices in C++ can be traced to trying to make it fast.
18:19:14 <jcreigh> Which is okay.
18:19:15 <dons> and failing?
18:19:18 <jcreigh> dons: heh
18:19:22 <Cale> Yeah, that's one nice thing about having a CAS -- you can interleave all this algebraic simplification with numerical computation.
18:19:23 <SamB> hah, yeah!
18:19:23 <lennart> Fortran doesn't (did use to at least) specify how arguments are passed.  So a Fortran compiler can make the best possible assumptions. :)
18:19:35 <SamB> because everyone knows that virtual functions are essential
18:19:39 <SamB> and slow
18:19:41 <Cale> Which, interestingly enough, is what people are starting to do in Haskell :)
18:20:05 <ricky_clarkson> @what CAS
18:20:05 <lambdabot> I know nothing about cas.
18:20:12 <Cale> Computer Algebra System
18:20:20 <Cale> (Like Mathematica and Maple)
18:20:26 <lennart> Modern C++ seems to be all about templates these days.  Which is a pure functional language.
18:20:34 <dmwit> Does Cale accept botsnacks, too?
18:20:38 <dmwit> =P
18:20:38 <Cale> hehe
18:20:50 <SamB> Cale: @bot
18:20:54 <Cale> :)
18:21:00 <SamB> dmwit: I'd say yes ;-)
18:21:06 <dmwit> Brilliant!
18:21:20 <perry> bot cookie == #!bot
18:21:31 <Cale> lambdabot: @ot
18:21:32 <lambdabot> Maybe you meant: . id pl v vote wn yow
18:21:34 <Cale> lambdabot: @bot
18:21:35 <lambdabot> :)
18:21:42 <Cale> lambdabot: @bit
18:21:43 <lambdabot> Maybe you meant: dict id list quit
18:21:44 <tennin> the univ. I attended doesn't offer classes in compiler design anymore
18:21:53 <Cale> lambdabot: @baht
18:21:54 <lambdabot> Maybe you meant: fact part
18:21:59 <Cale> hmm :)
18:22:02 <perry> @what triple rot13
18:22:03 <lambdabot> I know nothing about triple.
18:22:08 <dmwit> Doesn't seem too smart, huh, Cale?
18:22:10 <tennin> which apparently means none of its graduates will be able to understand C++.  =)
18:22:12 <lispy> lennart: but does anyone in industry do modern C++?  I kept hearing how our code wis in C++ but other than the occasinoal clas sit's all C
18:22:21 <ricky_clarkson> @rot13 bushpx
18:22:22 <lambdabot> Unknown command, try @list
18:22:50 <lennart> it's true that most people use c++ as a slightly souped up c__
18:22:53 <lennart> c++
18:22:54 <ricky_clarkson> lispy: Symbian programming uses a 'special' version of C++.
18:23:15 <lennart> but check out modern c++ books.  they even mention haskell
18:23:28 <dmwit> bushpx -- not nice...
18:23:31 <ricky_clarkson> C++ is in the process of acquiring closures apparently.
18:23:33 <tennin> modern C++ seems to be another minority language, just like Lisp or Haskell
18:23:36 <ell-hask> I've never seen 'C' or 'C++' in the work force - only Haskell.... really.
18:23:41 <ricky_clarkson> dmwit: rot13 bushpx is ohfuck
18:23:47 <dmwit> Yes, I know.
18:23:50 <ricky_clarkson> Ah.
18:24:24 <Cale> One can create powerful abstractions in C++ in much the same way that a woman can produce a child. It's possible, and people do it, but it takes hours of labour and is extremely painful.
18:24:38 <lennart> haha
18:24:53 <ricky_clarkson> A Perl programmer gave an excuse that can equally be applied to C++.
18:25:00 <ndm> @quote Cale One can create powerful abstractions in C++ in much the same way that a woman can produce a child. It's possible, and people do it, but it takes hours of labour and is extremely painful.
18:25:05 <lispy> Cale: and you have to get screwed before you can produce it?
18:25:08 <ricky_clarkson> Given a pen, one can make scratches in the dirt, or write prose.
18:25:10 <dons> ndm, @remember
18:25:16 <ndm> @remember Cale One can create powerful abstractions in C++ in much the same way that a woman can produce a child. It's possible, and people do it, but it takes hours of labour and is extremely painful.
18:25:36 <ndm> dons, i was about to try @quote+, would that have worked?
18:25:36 <ricky_clarkson> @quote ricky_clarkson
18:25:41 <ricky_clarkson> phew
18:25:43 <ndm> @bot
18:25:45 <lambdabot> Cale One can create powerful abstractions in C++ in much the same way that a woman can produce a child. It's possible, and people do it, but it takes hours of labour and is extremely painful. hasn't
18:25:48 <lambdabot> said anything memorable
18:25:56 <lambdabot> ricky_clarkson hasn't said anything memorable
18:25:58 <lambdabot> :)
18:26:05 <lispy> oh, actually, @quote+ should work then it would match a lot of other plugins
18:26:07 <ricky_clarkson> Weirdo.
18:26:17 <ndm> dons: so did i remember that then?
18:26:19 <Cale> @quote Cale
18:26:20 <lambdabot>  ... if sections were allowed at the type level ...
18:26:21 <Cale> @quote Cale
18:26:22 <lambdabot>  [more monad clarity] monads as food gathering in post-industrial America
18:26:23 <Cale> @quote Cale
18:26:23 <lambdabot>  One can create powerful abstractions in C++ in much the same way that a woman can produce a child. It's possible, and people do it, but it takes hours of labour and is extremely painful.
18:26:27 <Cale> okay :)
18:26:35 <ndm> yep, but it didn't say it remembered
18:26:42 <dons> no, it statys silent now
18:26:44 <Cale> yeah, it used to say that
18:26:47 <lispy> @quote dons
18:26:48 <lambdabot>  The "I'm swallowing TaPL smiley" :[]
18:26:56 <lispy> lol
18:26:59 <Cale> haha
18:27:06 <Cale> @quote lispy
18:27:07 <lambdabot>  I just remembered this dream i had the other morning.  I was trying to tell my alarm clock how to snooze by using a list comprehension
18:27:39 <dmwit> I think this is the only channel I've been in where the resident bot actually got used.
18:27:41 <ndm> dons: do you have any idea how many people have done @hoogle queries?
18:27:55 <dons> ndm, I can check if you'd like
18:28:04 <dons> dmwit: huh!
18:28:09 * lispy uses it almost daily
18:28:18 <ndm> dons: if you could - i was looking at the web stats, trying to see how many people use hoogle
18:28:24 <dons> ndm, i just have to backup my haskell logs, then i'll do a little search for you.
18:28:29 <ricky_clarkson> I've used it almost once.
18:28:31 <ndm> dons: cheers
18:28:47 <dons> (I managed to munge the logs by typing: grep <simonpj> * ....
18:28:59 <ndm> hehe :)
18:29:13 <lispy> ah
18:29:17 <ndm> he said something today
18:29:18 <lispy> guess you need qhotes
18:29:22 <dons> lesson: don't hack txt files before coffee
18:29:22 <ndm> wasn't that interesting though :)
18:29:36 <dons> lispy: yep
18:29:36 <ndm> @quote simonpj
18:29:37 <lambdabot> simonpj hasn't said anything memorable
18:29:43 <dons> ?quote spj
18:29:44 <lambdabot>  it looks like hopscotch! (referring to a funny notation for lists)
18:29:44 <dons> maybe?
18:29:47 <dons> ah
18:29:57 <TomMD> @quote dons
18:29:58 <lambdabot>  -fglasgow-exts ~= -fhaskell-prime
18:30:25 <TomMD> dons - is that true, I was just asking earlier.  About glasgow-exts being included in haskell'
18:30:43 <lispy> @quote SamB
18:30:43 <lambdabot>  Because sliced bread gives horribly uninformative error messages?
18:30:58 <dons> probably many features of glasgow-exts will make it in
18:31:01 <ricky_clarkson> I like that one.
18:31:19 <lispy> one of my favorites is cjs
18:31:26 <lispy> @quote cjs
18:31:26 <lambdabot>  I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of these
18:31:26 <lambdabot> nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
18:31:47 <Cale> @quote
18:31:47 <lambdabot> Miod says: [On the vax] How many processors come with a built-in instruction which computes polynomials of degrees up to 31?
18:31:58 <Cale> @quote
18:31:59 <lambdabot> vincenz says: Yeah, haskell's like touching a 25 year old female model compared to the 50 year old, fat hairy male that is c++
18:32:15 <ndm> is there somewhere you can browse all the quotes online
18:32:28 <ndm> would be nice :)
18:32:33 <lispy> ndm: should be available in the lambdabot darcs repo
18:32:37 <ricky_clarkson> "Haskell is an interface between academics and programming languages"
18:32:46 <dmwit> =)
18:32:49 <dons> ndm, the quote archive file, herehttp://www.cse.unsw.edu.au/~dons/lambdabot/State/quote
18:32:55 <dmwit> And mathematicians are a tool for turning coffee into theorems...
18:33:21 <vincenz> oy
18:33:24 <vincenz> get rid of that quote of mine!
18:33:36 <lispy> @where+ quotes http://www.cse.unsw.edu.au/~dons/lambdabot/State/quote
18:33:36 <lambdabot> Done.
18:33:50 <dons> the slighly lacivious quote, vincenz?
18:34:04 <dons> @where+ where http://www.cse.unsw.edu.au/~dons/lambdabot/State/where
18:34:04 <lambdabot> Done.
18:34:59 <ricky_clarkson> @quote VirginiaCurry
18:35:00 <lambdabot>  "You know, Haskell actually never liked the name Haskell." -- Virgina Curry (Haskell B. Curry's widow)
18:35:39 <ricky_clarkson> @quote xerox
18:35:39 <lambdabot>  you know, befunge is probably the only language I've seen where you can run code pasted from IRC with the <nick> tags still in place ;-)
18:35:55 <ricky_clarkson> xerox said "I am really interested specifically in bottoms in this very moment."
18:36:04 <Cale> @quote
18:36:05 <lambdabot> samc says: monads are hard, let's go shopping
18:36:07 <Cale> @quote
18:36:08 <lambdabot> HavocPennington says: Haskell is the least-broken programming language available today.
18:36:11 <Cale> @quote
18:36:12 <lambdabot> pesco says: "Scientists Reveal: Human Consciousness Stems From Two Files in Different Directories!"
18:36:23 <ndm> woohoo, i just totally removed all higher order functions from the program Ant!!!!
18:36:24 <dmwit> =)
18:36:42 <ndm> (3 days worth of work for me)
18:36:56 <dons> why'd you remove them?
18:37:07 <ndm> i removed them automatically
18:37:09 <lispy> do you mean Ant the build script thyngi?
18:37:14 <ndm> and because my checker is first order
18:37:18 <dons> ah
18:37:23 <dons> cool1
18:37:35 <ndm> lispy: http://www.cs.york.ac.uk/fp/darcs/catch/src/Example/Ant.hs
18:37:55 <ndm> that ant, not a build script, a program to calculate ant paths and genetic algorithms, or something...
18:38:28 <dmwit> @quote Failure02
18:38:29 <lambdabot>  in haskell you can have korean smilies as variables! like (^-^)
18:38:40 <lennart> ndm: what does your checker check?
18:38:45 <dons> ?where+ freetheorems http://haskell.as9x.info/
18:38:45 <lambdabot> Done.
18:38:52 <ndm> lennart: absence of pattern match errors
18:39:02 <ndm> lennart: lack of head [], and other such nasties
18:39:13 <lennart> ah
18:39:37 <lennart> yes, higher order is a pain for such things
18:39:41 <dons> ndm, we should look again at trying to run this over Data.ByteString.Lazy at some point
18:40:09 <ndm> it can cope with higher order, butonly with defunctionalisation, whcih destroys some of teh flow
18:40:18 <ndm> i can now remove the higher order funcs nicely, which is agood result
18:40:29 <ndm> dons: indeed, i have rewritten both the front and back ends
18:40:49 <ndm> dons: once thats complete, and I get it as good as it was before, Data.ByteString.Lazy is the target
18:45:15 * araujo back from dinner
18:46:00 <dmwit> Welcome back.
18:46:11 <araujo> thanks dmwit !
18:46:14 <araujo> :-)
18:46:17 <araujo> @yarr!
18:46:17 <lambdabot> I heard andersca is a pirate
18:47:13 <lispy> oh, theer is a pirate festival in late Sept. in Porland
18:47:15 * lispy wants to go
18:47:22 <SamB> oooh!
18:47:33 <SamB> what sorta programs will they have?
18:47:55 <lispy> http://www.portlandpiratefestival.com/
18:47:56 <SamB> computer games? apps? console games?
18:48:08 <lispy> heh
18:48:19 <lispy> seafairing pirates
18:48:28 <jcreigh> The nice thing about have two monitors is that you can have Yet Another Haskell Tutorial open in xpdf on one, and #haskell open in irssi on the other.
18:48:31 <SamB> but... seafaring pirates are awful people!
18:48:37 <SamB> they, like, kill people and stuff!
18:48:56 <ndm> SamB: but they kept global warming down
18:48:57 <SamB> and support terrorism!
18:49:02 <lispy> jcreigh: or chat in #haskell while you baby sit ftp :)
18:49:28 <SamB> so why do seafaring pirates get to have a festival?
18:49:35 <SamB> shouldn't they just get jailtime?
18:49:39 <araujo> lispy, don't be bad, and invite lambdabot :-)
18:50:24 <lispy> ?vixen would you like to come to the pirate festival?
18:50:24 <lambdabot> the question isn't would i, but should i
18:50:33 <araujo> haha
18:50:34 <lispy> ?vixen yes you should
18:50:35 <lambdabot> i thought so
18:50:49 <araujo> ?vixen do you go then?
18:50:50 <lambdabot> yes i do
18:50:52 <ndm> @asl
18:50:52 <lambdabot> tell module failed: IRCRaised Prelude.head: empty list
18:50:59 <ndm> dons: a bug for you :)
18:51:12 <int-e> @vixen asl
18:51:13 <SamB> @vixen asl
18:51:13 <lambdabot> 19/f/California
18:51:13 <lambdabot> 19/f/California
18:51:20 <ndm> someone did that earlier when they were chatting up vixen
18:51:26 <int-e> great timing.
18:51:53 <int-e> @tell
18:51:53 <lambdabot> tell module failed: IRCRaised Prelude.head: empty list
18:51:56 <lennart> ?users
18:51:58 <lambdabot> Maximum users seen in #haskell: 235, currently: 191 (81.3%), active: 23 (9.8%)
18:51:59 <lispy> my guess is that asl is getting spell corrcted to something that needs an argument
18:52:01 <int-e> weird typo correction
18:52:40 * lispy grumbles as the ftp screws up again
18:52:46 <kpreid> lispy: @ask?
18:52:54 <ndm> @ask
18:52:55 <lambdabot> tell module failed: IRCRaised Prelude.head: empty list
18:52:57 <lispy> kpreid: that seems reasonable
18:53:33 <ndm> i guess is should run my checker over lambdabot
18:54:28 <lispy> ndm: can you explain to me again what your checker does?
18:54:33 <lispy> ndm: i don't think i'm getting it
18:54:48 <lispy> pleas and all that :)
18:54:58 * lispy pretends to have manners
18:55:29 <ndm> lispy: get ready for the sales pitch :)
18:55:36 * lispy braces
18:55:42 <ndm> haskell has case statements, underneath all patern matches are case statements
18:55:47 <ndm> for example, head is defined as
18:55:49 * lispy nods
18:56:02 <ndm> head x = case x of {[] -> error ; (a:b) -> a}
18:56:20 <ndm> my checker ensures that there will be no case statements which raise an error
18:56:37 <ndm> i.e. it checks that all the callers of head have a : as their argument, not a []
18:56:57 <lispy> oh, wow, wouldn't that be undecidable in some cases?
18:57:01 <ndm> and, for example, if you call map head xs
18:57:10 <ndm> it checks that all the elemetns of xs are :
18:57:18 <ndm> yes, very undecidable
18:57:23 <SamB> oh okay
18:57:29 <SamB> so you have an undecidable decider?
18:57:39 <SamB> what does it do if it is undecided?:
18:57:42 <ndm> SamB: I have a conservative checker
18:57:45 <int-e> does it give up and say 'I don't know' after a while?
18:57:51 <ndm> it outputs a precondition
18:57:56 <SamB> oh
18:57:59 <SamB> thats nice
18:58:00 <ndm> \forall main, True = its safe
18:58:09 <SamB> what if it does IO?
18:58:10 <ndm> \forall main, False = its usnafe, or the checker went crazy
18:58:12 <lispy> okay, now you lost me
18:58:25 <ndm> for all calls to the main function, the precondtion is False
18:58:30 <lispy> oh, so when it says yes it always right, but when it says no you're not sure
18:58:35 <ndm> i.e. regardless, you are not going to meet your checker
18:58:39 <ndm> yes, True is True
18:58:46 <ndm> False is i don't know
18:58:50 <ndm> SamB: handles it :)
18:59:06 <ndm> I assume readFile x  returns unknown
18:59:15 <ndm> and I assume that the IO actions do not raise exceptions
18:59:26 <SamB> the former is a fairly safe assumption
18:59:36 <SamB> the latter is totally unfounded...
18:59:46 <ndm> if you didn't assume readFile was safe, then every program with readFile in it would be unsafe
19:00:17 <SamB> but they are rather the exception than the rule...
19:00:18 <ndm> if you really want safe readFile programming, introducting readFileMay :: FilePath -> IO (Maybe String) would be the way to go
19:00:19 <lispy> basically, you can't check unchecked exceptions?
19:00:47 <ndm> lispy: you can, it can detect calls to error for example
19:01:01 <ndm> but if you were to assume readFile x = error "couldn't open file"
19:01:10 <ndm> then any program with readFile in fails
19:01:10 <lispy> ndm: what do you use for parsing haskell?
19:01:16 <ndm> lispy: Yhc
19:01:22 <int-e> what about lazy (irrefutable) patterns?
19:01:27 <ndm> lispy: run Yhc -core, and I take theinput from that
19:01:34 <lispy> ndm: does that mean you only check H98?
19:01:42 <ndm> int-e: there are none by the time you get to Yhc core, i don't know where they go, but they go :)
19:01:46 <SamB> int-e: what difference does that make if the action itself is error "foo"
19:02:10 <ndm> lispy: currently, yes, but you could hook up GHC core to the front end, its only a question of hacking, not thought
19:02:33 <int-e> ndm: okay. I just imagine that they'll lead to hard-to-check programs.
19:02:34 <ndm> if the action itself is error "foo", then that fails
19:02:35 <lispy> ndm: cool.  so does it find bugs? can you run it on itself?
19:02:52 <ndm> int-e: i haven't checked, i have no idea what Yhc does to them
19:03:12 <ndm> lispy: it does find bugs, it can't run on itself - its still a work in progress
19:03:34 <lispy> ndm: can you give me an example of a bug it would find?
19:04:05 <ndm> lispy: yes, http://www.cs.york.ac.uk/fp/darcs/catch/src/Example/Adjoxo.hs
19:04:21 <ndm> take a look at that code, it has 1 bug in it
19:04:30 <ndm> and did years before i ever got to it
19:04:34 <ndm> and Catch found it
19:05:06 <ndm> there are a few pattern match incompletness places
19:05:09 <ndm> opp 'O' = 'X'
19:05:11 <ndm> opp 'X' = 'O'
19:05:20 <ndm> for one, but in this program opp happens to be safe
19:05:31 <ndm> foldr1 bestOf (map moveval (([1..9] `dif` ap) `dif` pp))
19:05:45 <ndm> the foldr1 on that line is unsafe, and given the right inptu, you can crash the program at that line
19:06:03 <int-e> ndm: They're desugared to let bindings with closures I guess. ~(a,b) <- t becomes t' <- t; let a = (\(x,y) -> x) t'; b = (\(x,y) -> y) t'.
19:06:26 <lispy> ndm: cool
19:06:42 <ndm> int-e: all lambdas are floated to the top
19:06:50 <lispy> ndm: too bad darcs uses so many extensions to H98
19:07:01 <lispy> ndm: would be cool to run this on darcs
19:07:08 <int-e> oh.
19:07:28 <ndm> lispy: its untyped, so as long as you can trasnlate it to a core haskell language, which you pretty much certainly can, you could run anything through it
19:07:51 <ndm> lispy: its not that tied to Yhc at all, it totally mutilates teh code before it starts
19:08:43 <lispy> nice
19:08:53 <lispy> get hacking then and mke it read ghc core :)
19:09:10 <ndm> hehe, darcs is still way too big for it
19:09:17 <ndm> hoogle is the medium term target
19:11:50 <dmwit> @quote audreyt
19:11:50 <lambdabot>  assembly would require metaolegs (or megaolegs)
19:12:00 <dmwit> @quote audreyt
19:12:00 <lambdabot>  I think wiki in the original Hawaiian means "I can't find any damned thing"
19:12:16 <int-e> ndm: does the checker derive preconditions for strictness? (i.e. "f evaluates its first argument to whnf if <precondition> is satisfied" or maybe a negated version thereof)?
19:12:43 <ndm> int-e: no, but it could - its just a question of what you flag
19:23:25 * dons moves haskell logs into darcs
19:24:37 <ndm> #haskell logs?
19:24:42 <dons> yep
19:25:07 <dons> (the ones I use to generate the stats page from)
19:25:08 <dons> ?where stats
19:25:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
19:25:42 <Adamant> @quote dons
19:25:43 <lambdabot>  -fglasgow-exts ~= -fhaskell-prime
19:26:41 <Korollary> @quote Adamant
19:26:42 <lambdabot> Adamant hasn't said anything memorable
19:27:33 <dons> ?where+ darcs-logs http://www.cse.unsw.edu.au/~dons/code/%23haskell/
19:27:33 <lambdabot> Done.
19:27:45 <ndm> those logs show prtty impressive steady growth
19:28:19 <dons> $ grep '@hoogle\|?hoogle' * | wc -l
19:28:19 <dons> 3849
19:28:30 <monochrom> I want to start a browser flame war against Jared Updike :)
19:28:34 <dons> $ grep '@google\|?google' * | wc -l
19:28:35 <dons> 1777
19:28:36 <dons> ;)
19:29:03 <dons> ndm, I agree. we're going somewhere with this whole Haskell thing :)
19:29:05 <Korollary> A hoogle zeitgeist could be interesting.
19:29:06 <ndm> I got 65000 on the web page
19:29:10 <vincenz> dons: why not grep google?
19:29:26 <Korollary> your last sentence is a cause
19:29:28 <dons> I'm looking for lambdabot commands
19:29:34 <vincenz> google the google!
19:29:52 <Korollary> Y google
19:29:58 <dons> ndm, $ darcs get http://www.cse.unsw.edu.au/~dons/code/%23haskell orks for me
19:29:59 <lambdabot> Title: Index of /~dons/code/#haskell
19:30:18 <dons> (note that its around 100M ....)
19:30:36 <dons> so you probably don't want to darcs pull unless you really want it
19:30:49 <ndm> dons: thanks, but i'll stick with occasional greps from you :)
19:31:06 <ndm> can we file patches to the haskell IRC logs?
19:31:13 <dons> I suppose so yes :)
19:31:23 <dons> it's more so that i have a backup in case things go foul
19:31:24 <sjanssen> I'd like to fix all my spelling errors
19:31:28 <dons> hehe
19:31:37 <dons> sjanssen: and make some wittier remarks!
19:31:57 <Korollary> Make it look like Oleg hangs out here.
19:32:24 <dons> yeah, oleg talking to simon and wadler about hudak and hughes
19:33:18 <Korollary> or Paul Graham hanging out in #perl6
19:33:24 <sjanssen> we should just give up on actual IRC and communicate via darcs'ed IRC logs
19:33:27 <dons> $ grep oleg * | wc -l
19:33:27 <dons> 295
19:33:27 <dons> $ grep wadler * | wc -l
19:33:27 <dons> 142
19:33:27 <dons> $ grep simonpj * | wc -l
19:33:30 <dons> 371
19:33:32 <dons> $ grep hughes * | wc -l
19:33:35 <dons> 103
19:33:37 <dons> $ grep hudak * | wc -l
19:33:40 <dons> 92
19:33:58 <dons> sjanssen: maybe! want to write a server where irc commands are just darcs patches sent to a central repo? lambdabot could coordinate it all :)
19:34:18 <dons> oh, and why by centralised. just cherry pick
19:34:23 <dons> and distribute
19:34:42 <dons> then we'd be able to revert conversations we don't like
19:37:51 <ndm> i think it would be more reasonable to convert the mailing list first, then have IRC follow later
19:39:03 <dons> yeah, it would be good if the mailing list was in darcs (readonly) format at least
19:39:07 <dons> its a very useful resource
19:39:28 <dons> (i've put up a web interface to the (incomplete) archives, but more could be done)
19:40:20 <ndm> i use gmail to search them ,but only goes back as far as i've been subscribed
19:41:17 <dons> http://www.cse.unsw.edu.au/~dons/haskell-1990-2006/ (3M index)
19:41:18 <lambdabot> Title: Mail Index
19:41:53 <dons> however its incomplete. i've not been able to find complete logs from the early days
19:42:08 <dons> i think what we have is only by luck. someone saved some of the mail privately
19:43:45 <ndm> Colin Runciman?
19:43:51 <ndm> he had a pretty cmopletely archive somewhere
19:44:25 <ndm> which explains why he never respronds to my emails, he's already got plenty
19:44:29 <dons> heh
19:44:47 <dons> Colin's your supervisor, right?
19:44:51 <ndm> yep
19:45:01 <ndm> although haven't seen him in 4 or 5 months
19:45:12 <ndm> he's been at Galois
19:45:13 <dons> I haven't seen Manuel in 9 months :)
19:45:32 <dons> phd students running wild!
19:45:51 <sjanssen> like elementary school when the teacher leaves the room?
19:45:54 <ndm> yeah, colin should be back soon
19:46:11 <dons> sjanssen: exactly ;)
19:46:16 <ndm> not really, i turn up atabout 11:30am, just like when my supervisor is there
19:46:39 <dons> (hehe. me too. maybe i even get more work done, since there's not so many meetings to go to)
19:47:05 <ndm> true
19:47:13 <ndm> well i'm still working at 3:43am
19:47:23 <dons> sjanssen: got time on your hands? would you like to add maximum uptime tracking to the Uptime plugin?
19:47:57 <sjanssen> p'raps
19:48:37 <dons> the clocktime is already in the state, you'd need to extend it to a tuple of (current time, maximum time)
19:48:42 <dons> and then serialise the maximum time
19:48:56 <dons> checking if current > maximum on module unload
19:49:04 <dons> via the moduleExit hook
19:49:29 <dons> Seen.hs has similar code (though more complex)
19:52:52 <TomMD> ?where paste
19:52:52 <lambdabot> http://paste.lisp.org/new/haskell
19:58:38 <lisppaste2> TomMD pasted "data field name collision" at http://paste.lisp.org/display/25072
19:59:16 <TomMD> Does anyone know how to get around my issue without changing how I want to setup my data structures?
19:59:21 <dons> ndm, $ grep '> [@?][^ ]' * | sed 's/.*> .//;s/ .*$//' | sort | uniq -c | sort -r | head -20
19:59:25 <dons>   12127 type
19:59:27 <dons>    3053 eval
19:59:30 <dons>    2448 index
19:59:36 <dons>    2389 hoogle
19:59:37 <dons>    2366 seen
19:59:37 <dons>    1834 where
19:59:37 <dons>    1696 google
19:59:37 <dons>    1252 yow
19:59:39 <dons>    1198 plugs
19:59:41 <dons>    1038 quote
19:59:44 <dons>    1018 pl
19:59:46 <dons>     962 help
19:59:49 <dons>     944 wiki
19:59:51 <dons>     841 vixen
19:59:54 <dons>     814 karma+
19:59:54 <ndm> TomMD, type classes
19:59:56 <dons>     560 arr
19:59:59 <dons>     549 localtime
20:00:20 <ndm> how long has lambdabot been going?
20:00:52 <TomMD> my point is, I can't have a field in M2 and a field in M1 both with the name 'size'.  Rather frustrating.
20:01:40 <dons> ?remember lambdabot 02.09.16:00:25:19 <lambdabot> I live.
20:01:58 <dons> ?remember lambdabot Sorry, I'm not a very smart bot yet.
20:02:05 <dons> remember she used to say that all the time?
20:02:16 <TomMD> She is smarter now
20:02:37 <dons> if we look at just 2006, ndm, we see: $ grep '> [@?][^ ]' 06* | sed 's/.*> .//;s/ .*$//' | sort | uniq -c | sort -r | head -20
20:02:40 <dons>    5274 type
20:02:42 <dons>    1196 where
20:02:43 <dons>     921 seen
20:02:43 <dons>     862 google
20:02:45 <dons>    1943 hoogle
20:02:47 <dons>     847 index
20:02:50 <dons>     648 quote
20:02:50 <dons> (not counting > eval)
20:03:13 <ndm> cool, so hoogle is pretty much solidly 3rd propular
20:03:19 <sjanssen> @hoogle diffClockTimes
20:03:19 <lambdabot> Time.diffClockTimes :: ClockTime -> ClockTime -> TimeDiff
20:03:47 <dons> ndm, yeah. and will only increase in popularity I think
20:04:13 <ndm> dons: hopefully the hoogle website will take off once i have hoogle 4, and take hoogle out of beta :)
20:04:35 <dons> @eval 15076 times
20:04:38 <dons> in 2006,
20:05:21 <ndm> would it be possible to do a website interface to lambdabot?
20:05:33 <dons> and some 20,000 uses of the @eval/@plugs plugin all up
20:05:36 <ndm> so people on the web can fire lambdabot commands at a webpage, and get the asnwer via a web pages
20:05:39 <dons> ndm, I suppose so, yes.
20:05:52 <dons> since it already has a command line interface
20:05:54 <ndm> would be quite handy for the times i;m not on IRC
20:06:04 <ndm> and would open it up to a whole new audience
20:06:07 <dons> well, you could just install lambdabot locally and run it from ghci :)
20:06:11 <dons> but yes, a web interface. hmm
20:06:17 <dons> those hoogle stats are very impressive
20:06:18 <ndm> ghci? i don't use that!
20:06:21 <dons> 65k hits?
20:06:28 <ndm> not hits, searches
20:06:30 <dons> 65k searches. yes
20:06:34 <dons> very cool. way more than irc
20:06:46 <ndm> yep, way more than i expected
20:06:47 <dons> yeah, that would really spread the lambdabot love around
20:07:02 <ndm> although went to del.icio.us, and found over 100 people had hoogle in their bookmark list
20:07:10 <dons> huh cool
20:07:23 <dons> what's the ETA for hoogle 4?
20:07:31 <ndm> 2 weeks hacking
20:07:42 <ndm> but that isn't 2 weeks time by any means
20:07:43 <dons> ok nice. let me know when you want lambdabot syncing done
20:07:51 <dons> sure
20:08:07 <ndm> if its not out by Christmas, I'll be very annoyed
20:08:22 <sjanssen> dons: is state serialized before or after moduleExit is called?
20:08:27 <ndm> if my phd thing would just stop non-terminating, and just work, then it'll go happen sooner
20:09:41 <vincenz> ndm: yeah if my phd would just stop non-terminating, I'd be happy too
20:10:05 <ndm> i sometimes wonder if there is enough in hoogle to attempt to stretch it to a phd...
20:10:06 <dons> sjanssen:             withDebug "Running exit handlers"    runExitHandlers
20:10:07 <dons>             withDebug "Writing persistent state" flushModuleState
20:10:07 <dons>             io $ do hPutStrLn stderr "Exiting ... "
20:10:07 <dons>                     exitImmediately (ExitFailure 1))
20:10:44 <dons> so yeah, exit handlers first, module state second
20:11:02 <dons> ndm. hehe.
20:11:23 <dons> i'm trying to do that with hs-plugins
20:11:30 <ndm> i spotted :)
20:11:41 <ndm> although you are doing numerous things, rather than just one app
20:12:00 <dons> yeah, and its a pretty huge design space, with lots of intersecting technologies
20:12:01 <ndm> is that going to be your main phd topic?
20:12:10 <dons> typesafe linking is the topic
20:12:29 <ndm> Hoogle has now had 4 totally different type search algorithms, so thats a start...
20:12:33 <dons> so yeah, dynamic linking, meta programming, dynamic typing, object code types ...
20:13:02 <dons> ndm, these new indexed types will be interesting.. more info in the kind system
20:13:14 <dons> I wonder if there'd almost be enough to start doing useful searching
20:13:28 <ndm> dons: i think the poor users head would explode
20:13:53 <ndm> thats why i don't have forall supported - no one wants a function with forall, they want a specific function
20:14:04 <dons> well, with proper type-level functions, maybe i'll really want to find type level filter or map one day
20:14:36 <dons> ndm, true. hoogle helps out with newbies, and with more experience people searching stranges parts of the the libraries
20:14:50 <dons> so fancy typery is not going to be widely needed
20:15:19 <ndm> thats my hope, a quick grep shows 18 people who have specified forall a .
20:15:44 <ndm> and all of them were for normal functions, which didn't need forall
20:15:57 <ndm> except one person, who added a kidn signature to a monad definition
20:16:17 <ndm> however quite a few people search for "forall", since it confuses them when they see it
20:16:33 <dons> oh that's interesting
20:16:39 <dons> maybe keywords could be reported specially
20:17:00 <dons> "forall", keyword, glasgow-haskell extension <doc reference url>
20:17:01 <ndm> they already are :)
20:17:03 <ndm> @hoogle data
20:17:03 <lambdabot> Prelude.data :: keyword
20:17:04 <lambdabot> Data.Generics.Basics.Data :: class Typeable a => Data a
20:17:04 <lambdabot> Data.Generics.Basics.dataCast1 :: (Data a, Typeable1 t) => c (t a) -> Maybe (c a)
20:17:07 <dons> ah :)
20:17:11 <dons> ?hoogle forall
20:17:12 <lambdabot> Prelude.forall :: keyword
20:17:12 <lambdabot> Test.QuickCheck.forAll :: (Show a, Testable b) => Gen a -> (a -> b) -> Property
20:17:12 <lambdabot> Language.Haskell.TH.forallT :: [Name] -> CxtQ -> TypeQ -> TypeQ
20:17:26 <ndm> Prelude.forall is considered a bug
20:17:34 <ndm> it should show "keyword forall"
20:17:49 <ndm> and the web version even provides documentation for the keywords
20:18:07 <dons> makes me think that a @keyword plugin, that given a keyword returns the report section and url for the definition of that keyword (or type extensions sectoin in the case of ghc-exts)
20:18:09 <ndm> "This is a GHC/Hugs extension, and as such is not portable Haskell 98."
20:18:14 <dons> ah ok
20:18:18 <ndm> http://www.haskell.org/hawiki/Keywords#forall
20:18:20 <lambdabot> Title: Keywords - The Haskell Wiki
20:18:26 <ndm> i already have a wiki for keyword documentation
20:18:38 <ndm> i have that moved to the new wiki as well, but haven't updated hoogle
20:18:44 <dons> ah ha!
20:18:56 <dons> ?where+ forall http://www.haskell.org/hawiki/Keywords#forall
20:18:57 <lambdabot> Done.
20:19:19 <dons> ?where+ newtype http://www.haskell.org/hawiki/Keywords#newtype
20:19:20 <lambdabot> Done.
20:19:34 <dons> etc..
20:19:35 <ndm> one of the first thing i noticed when turning on hoogle logging is that loads of people searched for "where", hence the addition
20:19:46 <dons> wow. isn't that interesting.
20:20:30 <ndm> yep, entirely unexpected
20:20:51 <dons> its nice to see an insight into the minds of the average haskller out there dealing with their functional programming university courses
20:21:41 <petekaz> how do I make this piece of code better?  http://paste.kazmier.com/?action=Display&id=1157078113628154000000
20:22:06 <petekaz> something about those redundant case statements bothers me.
20:22:15 <dons> 404?
20:22:23 <petekaz> hmm ..
20:22:33 <ndm> i get can';t find server
20:22:40 <petekaz> my mod_rewrite skills must suck.
20:23:01 <petekaz> er maybe I didn't add the dns entry yet.
20:23:26 <petekaz> this will work: http://www.kazmier.com/~kaz/pastebin.cgi?action=Display&id=1157078113628154000000
20:25:24 <ndm> whats the exact warning?
20:25:29 <ndm> looks fine to me
20:26:27 <petekaz> it works ... I just thought there was a more haskell way of dealing with those nested case statements just checking maybe values.
20:27:07 <dons> something like:
20:27:08 <dons> doAction :: String -> CGI Html
20:27:09 <dons> doAction "Display" = do
20:27:09 <dons>   mid <- getSomeInput "id"
20:27:09 <dons>   possibly deflt mid   $ \id -> do
20:27:10 <ndm> not massively, without going monads, and thats not a good route
20:27:11 <dons>   mpaste <- liftIO $ loadPaste id
20:27:13 <dons>   possibly dflt mpaste $ \paste -> do
20:27:16 <dons>   result <- liftIO $ colorizePaste paste
20:27:18 <dons>   return result
20:27:21 <dons>   where
20:27:23 <dons>     deflt          = doAction "List"
20:27:26 <dons>     possibly b m f = maybe b f m
20:27:31 <ndm> result <- , return result is redunant
20:27:40 <dons> and that.
20:28:02 <dons> petekaz: see how i replaced the explict case with a higher order function to do the same thing?
20:28:12 <ndm> i think the way you have it now is reasonable, unless that pattern repeats a lot
20:28:35 <dons> so you can get it as small as:
20:28:36 <dons>   possibly mid    $ \id -> do
20:28:37 <dons>   mpaste <- liftIO $ loadPaste id
20:28:37 <dons>   possibly mpaste $ \paste -> do
20:28:37 <dons>   liftIO $ colorizePaste paste
20:28:39 <dons>   where deflt        = doAction "List";  possibly m f = maybe deflt f m
20:28:45 <dons> since the default case is always known
20:28:59 <petekaz> dons: still digesting ...
20:29:31 <dons> ?. pl undo do possibly mid $ \id -> do mpaste <- liftIO $ loadPaste id ; possibly mpaste $ \paste -> do liftIO $ colorizePaste paste
20:29:31 <lambdabot> possibly mid (liftIO . (flip possibly (liftIO . colorizePaste) =<<) . loadPaste)
20:29:35 <dons> :)
20:30:00 <petekaz> ah .. the latter makes perfect sense.
20:30:03 <dons> heh
20:30:11 <ndm> dons: does @pl ever make use of `possibly`
20:30:22 <dons> well I just made it up, so no?
20:30:30 <ndm> i mean, backticks
20:30:33 <dons> ah yes
20:30:40 <dons> sometimes, not sure when
20:31:42 <sjanssen> @pl \x -> (x `seq` y)
20:31:42 <lambdabot> (`seq` y)
20:32:19 <dons> @pl \x -> seq x y
20:32:20 <lambdabot> flip seq y
20:32:25 <dons> oh, it won't introduce them
20:32:27 <dons> it should!
20:32:51 <dons> @pl \x y -> mapM_ y x
20:32:52 <lambdabot> flip mapM_
20:33:00 <dons> @pl \x -> mapM_ y x
20:33:00 <lambdabot> mapM_ y
20:33:08 <dons> @pl \x -> mapM_ x y
20:33:08 <lambdabot> flip mapM_ y
20:33:18 <dons> (`mapM_` y)
20:34:15 <petekaz> dons: thanks! that was helpful, and now the code is 'nicer' in appearance.
20:34:23 <petekaz> (and it works too)
20:34:38 <dons> petekaz:   possibly (getSomeInput "id")     $ \id    -> do
20:34:38 <dons>   possibly (liftIO $ loadPaste id) $ \paste -> do
20:34:38 <dons>   liftIO $ colorizePaste paste
20:34:38 <dons>   where deflt = doAction "List"; possibly = (. maybe deflt) . (>>=)
20:34:55 <dons> since you don't really need to name the result of the IO action, we can merge that into possibly
20:34:56 * edwardk waves hello
20:35:28 <vincenz> hi
20:35:46 <petekaz> dons: everything but the def of 'possibly' I understand.
20:35:59 <dons>         possibly m f = m >>= \x -> maybe deflt f x
20:36:04 <dons> (just throwing @pl on it ;)
20:36:10 <petekaz> show off.
20:36:33 <ndm> possibly m f = m >>= maybe deflt f
20:36:36 <ndm> why not that?
20:36:45 <dons> even better
20:36:58 <ndm> @pl possibly m f = m >>= \x -> maybe deflt f x
20:36:59 <lambdabot> possibly = (. maybe deflt) . (>>=)
20:37:03 <edwardk> heh
20:37:24 <Frederick> hello folks :) does anyone knows any website wich shows how is haskell related with category theory formally?
20:38:12 <dons>   possibly (getSomeInput "id") $ \id    ->
20:38:13 <dons>   possibly (io $ loadPaste id) (io . colorizePaste)
20:38:13 <dons>   where possibly m f = m >>= maybe (doAction "List") f ;  io = lifTIO
20:38:15 <dons> perhaps?
20:38:31 <petekaz> dons, ndm: much nicer now!
20:38:48 <dons> Frederick: hmm, there's some notes on haskell.org
20:38:57 <dons> better would be to look into the type system papers on monads
20:38:59 <dons> Moggie et al
20:39:02 <dons> grr
20:39:03 <dons> Moggi
20:39:42 <edwardk> eugenio moggi's paper on the computational lambda calculus is a good start to understand where monads come into haskell
20:39:57 <dons> http://haskell.org/haskellwiki/Research_papers
20:39:59 <lambdabot> Title: Research papers - HaskellWiki
20:40:03 <LordBrain> Frederick: I think "Algebra of Programming" by Bird et al. is a bit enlightening as far as that goes...
20:40:07 <edwardk> the papers by phil wadler use a lot of monads, but don't justify it with much CT, they just use the terminology
20:40:08 <dons> but we could have an actual category theory section
20:40:17 <Frederick> dons, thanks a lot
20:40:28 <dons> there's some categories in the squiggol papers, aren't there?
20:40:33 <LordBrain> it's a book tho not a website..
20:40:43 <edwardk> most of the papers on CT and unctional programming tie to a lambda calculus, not haskell.
20:41:22 <edwardk> in that vein andrzej filinski's declarative continuations and categorical duality might help you understand how CT can apply to the values/continuation duality
20:41:48 <edwardk> that helps you understand the motivation behind haskell's call-by-need approach categorically.
20:42:23 <petekaz> dons: do you have any thoughts on an interface that one might use to get lambdabot to send a message to one of its channels?  I'd like to send some simple request to lambdabot about a new paste.
20:42:26 <edwardk> there are some papers by robin cockett and his students on charity, which is a language with explicit codata and data types, haskell types map closely onto their codata types.
20:42:31 <edwardk> if you need more, just ask
20:42:47 <edwardk> i probably have the papers all strewn about my desk at the moment ;)
20:45:35 <petekaz> I'm off to bed, thanks for the help again.
20:56:40 <sjanssen> dons: Seen doesn't save it's state between reboots, is this by design or accident?
20:57:58 <int-e> oh, I wanted to look into that some day. My theory is that it does save the state but forgets it all when joining the channels - because it assumes it knows nothing about the people who are there.
20:58:27 <sjanssen> int-e: it isn't saving the state
20:58:56 <int-e> strange. I thought it did, some time ago.
20:59:12 <sjanssen> the instance sticks with the default defn. of moduleSerialize, which doesn't save state
21:00:06 <sjanssen> the Module class probably changed at some point and the seen instance didn't change with it
21:01:05 <sjanssen> actually, I'm wrong.  seen writes the data out itself
21:07:16 <int-e> one thing is that the IRC server will send multiple 353 messages when joining a large channel like this one, causing joinChanCB being called multiple times.
21:08:54 <int-e> but I got lost somewhere in trying to figure out what exactly joinChanCB does.
21:10:56 <dons> sjanssen: ah. accident then! (i thought it manually saved it?)
21:11:43 <falconair> is there any haskell code available for a newbie who wants to study the implementation of simply typed lambda calculus, but wants to extend it as far as adding 'list comprehension'? (perhaps something like Ben Pierce's "Types and Programming Languages" ... but in haskell code)
21:11:44 <sjanssen> dons: I was confused, it does manually save it
21:11:54 <dons> right.
21:13:03 <edwardk> falconair, not directly, but if you want to explore the space, there is an intermediate language baked into the compiler jhc that implements a 'pure type system' which is an extended form of the simply typed lambda calculus to add polymorphism and dependent types, etc.
21:13:36 <edwardk> you can dig into the code there and extract the stuff for their 'E' intermediate language and pretty much turn it into a simply typed lambda calculus evaluator reasonably quickly.
21:13:58 <edwardk> falconair: i'm sure someone else has a more elegant solution, as is usually the case around here ;)
21:14:03 <falconair> edwardk: i'll check it out right now, thanks
21:14:09 <dons> there's a few lambda calculus interpreters around if you want to play with them
21:14:14 <dons> lambdaShell for one
21:15:16 <edwardk> lambdashell is untyped though isn't it?
21:16:10 <edwardk> http://www.cs.uu.nl/~johanj/MSc/jwroorda/ is a pure type system shell
21:16:11 <lambdabot> Title: Pure Type Systems for Functional Programming
21:16:25 <edwardk> and an explanation of how pure type systems extend the simply typed lambda calculus
21:16:30 <edwardk> thats the one i was looking for =)
21:16:58 <edwardk> should be a lot easier than starting from scratch or lifting E out of jhc.
21:17:24 <edwardk> nicely, you should be able to turn off the pts extensions and just get a simply typed lambda calculus
21:18:09 <falconair> edwardk: the pure type system thesis looks very good, the implementation code is right there in blue rectangles :)
21:18:21 <edwardk> heh
21:18:30 <falconair> apparently even parses user input using parsec
21:19:00 <edwardk> falconair: that was the paper i used to get my head around PTSs.
21:19:10 <edwardk> i think it does a wonderful job of explaining them.
21:19:35 <falconair> dons: lambda shell does indeed look untyped, a while ago i also checked out the lambdabot's plugins...unfortunately i don't know enough about its plumbing yet to make good use of it
21:27:09 <edwardk> how bad do you think it would be to have a runtime that required you to keep the compiler around so it could specialize types at runtime. kind of a higher order jit?
21:27:42 <dons> edwardk: could you add that paper to the PTS section of the research papers part of the wiki?
21:27:44 <edwardk> do you think there would be much resistance if it led to faster loops in the presence of dependent types?
21:27:59 <edwardk> dons: that would require me to actually log into the wiki at some point =)
21:28:12 <dons> please do :)
21:28:14 <edwardk> i never did set up an account or learn how to use one =)
21:28:19 <edwardk> ok, ok, i get the hint ;)
21:28:24 <dons> you create a name and password. super-easy
21:28:43 <dons> (if you click 'remember me' you can stay logged in whenever you connect to haskell.org)
21:28:50 <dons> (which makes quick edits easier0
21:29:12 <dons> ?karma+ lispy -- tiny url plugin
21:29:13 <lambdabot> lispy's karma raised to 6.
21:29:19 <dons> ?karma+ sjanssen  -- better @uptime
21:29:20 <lambdabot> sjanssen's karma raised to 15.
21:31:29 <dons> ?quit new stuff
21:32:58 <edwardk> summary is the summary of the changes right?
21:33:44 <dons> on the wiki?
21:33:45 <lispy> dons: i just fixed a bug with tiny-url
21:33:47 <edwardk> yeah
21:33:53 <dons> lispy: a new patch?
21:33:55 <dons> edwardk: yep
21:33:56 <lispy> yup
21:33:59 <edwardk> kk
21:34:01 <lispy> already sent
21:34:07 <dons> ok. tanks
21:34:41 <edwardk> added.
21:34:48 <dons> cheers edwardk
21:34:55 <edwardk> i could probably flesh out that type systemspage quite a bit, but not much would be haskell specific ;)
21:35:17 <dons> i think since type systems are shared over the FP langs, adding more stuff is good
21:35:23 * edwardk nods.
21:35:39 <dons> there's no CMU papers up there yet, or very few
21:35:43 <dons> even though many are relevant
21:35:55 <dons> same with OCaml and Clean
21:36:23 <edwardk> well, the only paper tangentially related to clean i would post would be Dana Harrington's thesis
21:36:26 <edwardk> on uniquenness types
21:36:44 <edwardk> thats not really on clean, coz its slightly different than their approach, but has sound categorical semantics.
21:37:26 <kfish> ?seen lambdabot
21:37:32 <edwardk> heh
21:37:42 <dons> there's some stuff in Clean we want to use though, like binary io
21:37:54 <dons> not type system stuff
21:37:58 <dons> heya kfish
21:38:33 * edwardk last saw lambdabot leaving #haskell. She last spoke 4 minutes ago. ;)
21:38:46 <kfish> hi dons :)
21:38:47 <dons> ?uptime
21:38:48 <lambdabot> uptime: 1 minute and 31 seconds, longest uptime: 1 minute and 31 seconds
21:38:49 <int-e> time warp :)
21:38:55 <RyanT5000> hey; could someone tell me the sources.list line for a haskell repository?
21:38:57 <dons> nice sjanssen .
21:39:10 <dons> lispy: how do we trigger the tiny url fix?
21:39:22 <lispy> the fix?
21:39:26 <lispy> or the feature?
21:39:33 <dons> 2nd
21:39:40 <lispy> http://www.halhigdon.com/marathon/advanced2/advancedII.htm
21:39:41 <dons> http://www.google.com
21:39:44 <edwardk> so haskell is not about to jump on the uniqueness type bandwagon, eh? =)
21:39:50 <lispy> uh...
21:39:51 <lispy> weird
21:39:55 <dons> ?url-on
21:39:56 <lambdabot> Url enabled
21:40:00 <lispy> http://www.halhigdon.com/marathon/advanced2/advancedII.htm
21:40:01 <dons> http://www.halhigdon.com/marathon/advanced2/advancedII.htm
21:40:12 <dons> let me check the proxy
21:40:12 <edwardk> she's shy
21:40:13 <lispy> it works on my instance of lambdabot :)
21:40:29 <lispy> /join #notGiR
21:40:31 <lispy> oops
21:40:31 <dons> proxy issue
21:41:07 <lispy> 21:37 <notGiR> Title: Marathon Training Schedule: Advanced - II, http://tinyurl.com/kppfm
21:41:13 <dons> cool
21:41:28 <dons> ?uptime
21:41:28 <lambdabot> uptime: 4 minutes and 11 seconds, longest uptime: 4 minutes and 11 seconds
21:41:31 <dons> ?quit testing
21:41:50 <lispy> heh, the quit message should just have the uptiem in it :)
21:41:53 <edwardk> i always find it funny that you tell lambdabot to quit testing when you want to start testing ;)
21:42:08 <edwardk> its like clicking start to shutdown the computer.
21:42:43 <dons> ?uptime
21:42:53 <lambdabot> uptime: 1 minute and 10 seconds, longest uptime: 4 minutes and 15 seconds
21:42:59 <dons> good
21:43:17 <int-e> @botsnack
21:43:18 <lambdabot> :)
21:43:23 <RyanT5000> debian repository anyone?
21:43:34 <dons> ?free filter
21:43:36 <lambdabot> g x = h (f x) => $map f . filter g = filter h . $map f
21:43:40 <dons> kpreid: works ^^
21:43:47 <lispy> dons: i think she's still having proxy issues tho
21:44:01 <dons> http://www.halhigdon.com/marathon/advanced2/advancedII.htm
21:44:05 <lambdabot> Title: Marathon Training Schedule: Advanced - II, http://tinyurl.com/kppfm
21:44:05 <dons> oh hmm.
21:44:07 <dons> nope
21:44:15 <dons> that's right, isn't it?
21:44:19 <lispy> yeah
21:44:34 <lispy> i tried it on /msg and didn't get it
21:44:45 <lispy> ?tiny-url http://www.google.com
21:44:46 <lambdabot> http://tinyurl.com/1c2
21:44:47 <lispy> that should work too
21:44:51 <dons> heh
21:44:58 <dons> cool
21:45:34 <lispy> long urls are a pain in my irc client so i'm very happy to have this feature :)
21:45:55 <lispy> i used to have emacs setup to do it for me, but i keep breaking it
21:45:57 <dons> yeah its good
21:46:01 <RyanT5000> dons: any idea if there's a debian repository that is relatively up-to-date for ghc and the like?
21:46:18 <RyanT5000> i just switched over to 100% linux
21:46:27 <lispy> RyanT5000: testing or unstable should be up to date on the main distro
21:46:33 <dons> RyanT5000: i don't use linux or debian, but I believe there's ghc-cvs packages in unstable?
21:46:45 <RyanT5000> hm, i'll check
21:46:46 <lispy> not ghc-cvs, he wants ghc6
21:46:51 <dons> ?version
21:46:52 <lambdabot> lambdabot 4p106, GHC 6.5 (OpenBSD i386 )
21:46:52 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:46:53 <lispy> ghc-cvs seems to be old
21:47:24 <lispy> RyanT5000: apt-cache search ghc6, should give you something recent.  If not you need the sources for unstable (maybe testing works too)
21:48:09 <RyanT5000> lispy: ghc6 is 6.4.1
21:48:46 <lispy> RyanT5000: 6.4.2 should be available too
21:48:54 <lispy> RyanT5000: that's how i got my copy of 6.4.2 on debian
21:49:19 <RyanT5000> huh, it's not in any of the ubuntu repositories
21:49:45 <lispy> RyanT5000: http://packages.debian.org/cgi-bin/search_packages.pl?keywords=ghc6&searchon=names&subword=1&version=unstable&release=all
21:49:48 <lambdabot> Title: Debian -- Debian Package Search Results, http://tinyurl.com/kjrtc
21:50:07 <lispy> RyanT5000: you'll want to grab the .deb and run "sudo dpkg -i <package>.deb"
21:51:51 <RyanT5000> what does the .deb really get me anyway?
21:52:14 <RyanT5000> maybe i should just get the tar of the latest snapshot
21:52:24 <Korollary> You should be able to add that location to your sources.
21:52:55 <RyanT5000> yeah but i kinda need 6.5 anyway
21:53:15 <RyanT5000> ah well, i shouldn't be doing this right now anyway
21:53:23 <RyanT5000> i have my first class at law school in 9 hours
21:53:26 <edwardk> Has anyone read http://portal.acm.org/citation.cfm?id=292556&coll=&dl=acm&CFID=15151515&CFTOKEN=6184618 who can tell me why this approach isn't used? my guess would be the algorithms non-determinacy would lead to long compile times, but hrmm
21:53:45 <Korollary> RyanT5000: Good luck.
21:53:54 <RyanT5000> Korollary: thanks
21:53:56 <RyanT5000> i'm off
21:54:12 <edwardk> even so any kind of decidable type inference for rank-n polymorphism is good, no?
21:54:35 <edwardk> or is it that it would lengthen compile times in the presence of common errors.
21:55:14 <Korollary> edwardk: You should post that paper to LtU
21:55:47 <Cale> edwardk: hmm, apparently there will be some support for type inference on higher-rank types in GHC soon
21:55:49 <edwardk> its a fairly old paper, and like with the wiki that would require me to create an account and stuff ;)
21:55:59 <Cale> edwardk: have you read the boxy types paper?
21:56:07 <edwardk> which one is that?
21:56:13 <Cale> http://research.microsoft.com/~simonpj/papers/boxy/
21:56:15 <edwardk> that sounds familiar but im not sure
21:56:16 <lambdabot> Title: Simon Peyton Jones: papers, http://tinyurl.com/ps2wk
21:56:39 <edwardk> ah neat, new paper *chew chew chew*
21:56:42 <Cale> lambdabot creates a tinyurl for every url pasted here? :)
21:56:45 <Korollary> edwardk: That's one account that you can really use, though.
21:57:00 <dons> edwardk: is that paper on the wiki?
21:57:37 <edwardk> dons: nope
21:57:50 <dons> hack away then :)
21:58:01 <edwardk> dons: its not exactly in haskell style, the type system makes other assumptions
21:58:19 <dons> i think all spj papers get to go up there, don't they?
21:58:25 <edwardk> dons: you realize this is a slipper slope. i'm currently surrounded by approximately 5,500 sheets of paper that i've printed out in the last 2 months ;)
21:58:35 <dons> yikes. you _print_ them?
21:58:39 <edwardk> dons: ah you mean the spj one
21:58:51 <edwardk> dons: yeah so i can read the good ones when i'm away from the keyboard
21:58:52 <dons> ah yes, not the acm one further up
21:58:55 <lispy> Cale: only if it's longer than 45 characters
21:59:12 <edwardk> i read the not-so-good ones or the really long ones on a sideways lcd.
21:59:15 <dons> fair enough. i should see if papers are legible in my mp3 player's text viewer. hmm...
21:59:35 <Cale> lispy: any idea how long tinyurls last?
21:59:44 <edwardk> but my workspace is a bit of a sight right now due to my current type theory paper obsession
21:59:48 <lispy> Cale: supposedly forever
21:59:50 <dons> forever I  think
21:59:51 <Cale> hmm
22:00:06 <dons> http://tinyurl.com/0
22:00:09 <lambdabot> Title: TinyURL.com - where tiny is better!
22:00:09 <edwardk> i have taped bits of papers all over the walls with scribbles etc. now looking at it makes me feel midly insane
22:00:11 <dons> http://tinyurl.com/1
22:00:15 <lambdabot> Title: Gilby's Website
22:00:18 <dons> weird
22:00:21 <dons> http://tinyurl.com/a
22:00:24 <lambdabot> Title: TinyURL.com - where tiny is better!
22:00:26 <dons> http://tinyurl.com/z
22:00:33 <Cale> I suppose that the number of digits won't increase so often, especially seeing as they're using base 36
22:00:36 <Korollary> edwardk: You need to switch to depth search soon then
22:00:50 <dons> base 36 eh?
22:01:06 <Korollary> does it include uppercase as well?
22:01:16 <dons> http://tinyurl.com/A
22:01:18 <lambdabot> Title: TinyURL.com - where tiny is better!
22:01:20 <dons> I'd guess not
22:01:26 <dons> 26 lower case+  10 digits
22:01:32 <Korollary> how ... human.
22:02:05 <edwardk> kor: well, i kinda like exploring as much as i can about a given problem space, before i stick my neck out and commit to writing something in it ;)
22:02:11 <dons> I suppose that gives them plenty of room before they tinyurl's themselves are too big
22:02:35 <dons> http://tinyurl.com/abcdefghikjlmnop
22:02:36 <lambdabot> Title: TinyURL.com - where tiny is better!
22:02:38 <Cale> actually, 36 is fairly divisible, so it's a decent number to use as a base.
22:02:41 <Korollary> dons: They're going to sell the company when the urls get long enough. Who cares after that ;)
22:02:44 <dons> http://tinyurl.com/abcdefgh
22:02:45 <lispy> > 36 ^ 10
22:02:46 <lambdabot>  3656158440062976
22:02:46 <lambdabot> Title: TinyURL.com - where tiny is better!
22:02:49 <dons> Korollary: heh
22:02:51 <edwardk> dons: if it makes you feel better for the trees i usually print 2-4 pages per sheet
22:02:56 <dons> http://tinyurl.com/abcde
22:03:00 <lambdabot> Title:
22:03:04 <dons> http://tinyurl.com/abcdef
22:03:04 <edwardk> depending on how tight the script and sequents are
22:03:05 <lambdabot> Title: TinyURL.com - where tiny is better!
22:03:18 <Korollary> Their motto is beyond lame.
22:03:55 <sieni> lame and beyond!
22:04:01 <dons> do we have a haskell one liner to generate the same urls?
22:04:14 <dons> or do they use some big ole hash?
22:04:18 <edwardk> so you are adding tinyurl support to lambdabot is the idea?
22:04:27 <edwardk> dons: i would guess a simple database lookup
22:04:28 <sieni> dons: ?
22:04:28 <dons> yeah, avoid the network
22:04:40 <edwardk> coz they seem to be added incrementally
22:04:45 <edwardk> 0, then longer digits, etc.
22:04:46 <dons> yeah fair enough
22:04:46 <sieni> dons: the urls increase with time
22:04:54 <dons> sieni: yup.
22:05:01 <dons> so nothing to be done about it
22:05:02 <edwardk> then just translate the record number back out to base 36
22:05:05 <lispy> they store the urls in a database and encode/decode the primary key id to the url
22:05:07 <edwardk> or store it that way, etc.
22:05:10 <lispy> yeah
22:05:46 <flux__> but, there's an alternative
22:05:51 <flux__> www.hugeurl.com!
22:05:56 <edwardk> ahahaha
22:06:05 <dons> heh
22:06:13 <sieni> unfortunately they are so huge that they can't be pasted on irc
22:06:21 <vincenz> "Do you feel that you can't satisfy your woman?  Do you have problems with size.  Not an issue, try www.hugeurl.com now!"
22:06:23 <dons> maybe we could start a company up with base 64 urls, nanourl.com
22:06:34 <dons> and take the tinyurl guys out with our _scalabilty_
22:06:48 <vincenz> dons: even better
22:06:49 <vincenz> zerourl
22:06:54 <vincenz> encode it all in the stuff before the /
22:06:58 <Korollary> we need a lazyurl. As many characters as the webserver requires.
22:07:02 <dons> heh
22:07:23 <Cale> How about a service which makes URLs longer?
22:07:41 <vincenz> "Bigger is Better, and we serve them Huge!"
22:07:50 <lispy> hugeurl could take and encode the url as xml, one tag percharacter then encode that xml as a url and give it back to you
22:07:51 <vincenz> should work for managers
22:08:10 <Korollary> IEbufferoverflowurl.com
22:08:11 <flux__> simply automatically register a new second-level-domain for all addresses
22:08:15 <flux__> it'll be expensive, though
22:08:15 <dons> unlambdaurl.com
22:08:30 <vincenz> binaryrul
22:08:33 <vincenz> 010010001
22:08:37 <dons> encode each url as an unlambda program that when executed redirects you to the page
22:09:01 <dons> vincenz: why stop there? unaryurl, 0 00 0000 000000000000000000
22:09:02 <lispy> oh, does lambdabot have a bf interpreter?
22:09:08 <dons> lispy: nope
22:09:11 <vincenz> dons: :D
22:09:23 <lispy> dons: any way to limit the run time if i created one?
22:09:28 <Cale> worlwideweb.huuuuuuuuuugeurl.com/scriptWhichDoesTheLinkingBit?754890fn8vgsd8cbb8337gv78xxxxt67c9s68r3478g8g32vgcdbhsg72389gdcgg3cg78chdg7d38f612fe&q=473189127&originalName=http://www.google.com/
22:09:30 <lambdabot> Title: Google
22:09:42 <Korollary> geez
22:09:44 <dons> lispy, yes, following the scripts/Unlambda.hs trick
22:10:04 <dons> you'd have to make it an external process
22:10:52 <lispy> oh
22:11:08 * lispy goes rooting for his bf interpreter
22:11:11 <dons> (that's ok, just stick it in scripts/)
22:11:55 * lispy just noticed that his old glasses were actually a closer prescription
22:13:21 <dons> ?uptime
22:13:22 <lambdabot> uptime: 31 minutes and 47 seconds, longest uptime: 31 minutes and 47 seconds
22:13:32 <Korollary> @users
22:13:33 <lambdabot> Maximum users seen in #haskell: 195, currently: 191 (97.9%), active: 10 (5.1%)
22:13:45 <Korollary> ooh. what happened to the 235 maximum?
22:14:08 <dons> oh hmm
22:14:14 <dons> :(
22:14:26 <dons> I might have sigkilled the state a bit prematurely
22:14:36 * dons hunts around
22:15:11 <lispy> dons: my bf.hs runs in the IO monad is that any problem?
22:15:12 <edwardk> cale: looks like simon pj does site that other paper on the second page of this boxy types thing
22:15:21 <edwardk> so i guess its the right direction to be searching =)
22:15:24 <edwardk> er cite
22:15:40 <dons> lispy: just make it a standalone program. that's fine.
22:16:19 <lispy> cool, i hacked it up as quick as possible, so it's really inefficient and i'd love pointers on it once you see it
22:21:16 <dons> looks like the @seen state wasn't under version control. so the 235 high score is lost unless we hack the binary file :)
22:21:48 <dons> ?uptime
22:21:58 <edwardk> or hack lambdabot once to set the value once it starts, then remove the hack next reboot
22:22:08 <edwardk> or on reloading that plugin
22:22:12 <lambdabot> uptime: 52 seconds, longest uptime: 33 minutes and 24 seconds
22:22:17 <dons> yeah that's doable too
22:22:45 <Korollary> We could change the topic to "free beer". That should bring at least 40 extras.
22:23:03 <dons> "we solve homework problems for free"
22:23:20 <Korollary> We do sometimes. heh.
22:23:24 <edwardk> hahahaha
22:23:56 <Korollary> I think Cale may have passed about 2-3 courses by now.
22:24:13 <Cale> hehe
22:24:13 <vincenz> Korollary: the one on the ML was the best
22:24:18 <vincenz> "Urgent, need answer now!"
22:24:23 <vincenz> ... homework desc ....
22:24:24 <dons> they should give him an honary CS degree :)
22:24:51 <vincenz> yeah, an honorary one too
22:25:30 <lispy> dons: okay, so i put it in scripts, where do i need to let the build system know about it?
22:26:40 <dons> edit the Cabal file to add the details
22:26:47 <dons> (i.e. follow that for hoogle or runpugs)
22:27:02 <Korollary> Man. Bulat's english is something.
22:27:21 <edwardk> ?
22:28:00 <dons> ?remember adaptec [in documentation for their raid chipsets] We have a disclaimer because there may be corner cases
22:28:42 <Korollary> SPJ: "This particular thing has been on my to-do list for
22:28:43 <Korollary> at least 10 years (see Andy Gill's thesis)."
22:28:57 <dons> the build/foldr stuff?
22:29:34 <Korollary> yes
22:29:41 <Korollary> that is some todo list.
22:29:48 <Korollary> Mine goes back... 3 days?
22:30:03 <edwardk> heh
22:31:09 <edwardk> i gave up keeping mine once it overflowed my notebook
22:31:55 <lispy> dons: i'm using getContents to read the bf program (which means you need to send EOF) is that a problem?
22:34:45 <edwardk> cale: http://citeseer.ist.psu.edu/cache/papers/cs/27283/http:zSzzSzpauillac.inria.frzSz~remyzSzworkzSzmlf.pdf/lebotlan03raising.pdf seems to one-up the simon pj paper in some ways. simon seems almost apologetic in the end of the boxy types paper giving the excuse that his approach is easier to learn and apply to existing compilers, etc. ;)
22:35:31 <Korollary> That link looks weird
22:35:49 <dons> lispy: you'll have to write the plugin too, so its up to you :) look at Plugin/Unlambda.hs for ideas
22:36:04 <edwardk> i could tinyurl it ;)
22:36:22 <Korollary> It's got two ".pdf"s in it.
22:36:28 <edwardk> http://tinyurl.com/zd47y
22:36:29 <edwardk> there
22:36:33 <edwardk> now it has none
22:36:40 <lispy> dons: ah yeah, i see now, cool
22:36:41 <Korollary> @karma tinyurl
22:36:41 <lambdabot> tinyurl has a karma of 0
22:36:43 <dons> ?tinyurl http://citeseer.ist.psu.edu/cache/papers/cs/27283/http:zSzzSzpauillac.inria.frzSz~remyzSzworkzSzmlf.pdf/lebotlan03raising.pdf
22:36:45 <lambdabot> http://tinyurl.com/zd47y
22:36:46 <Korollary> @karma+ tinyurl
22:36:46 <lambdabot> tinyurl's karma raised to 1.
22:40:55 <pandres> hello, where is the typo here?
22:40:57 <pandres> tal:attributes="style python:test (section['active'], 'background-image: url(\"images/active-link.gif\")', 'background-image: url(\"images/active-link.gif\")' );" >
22:41:06 <dons> wrong language?
22:41:13 <edwardk> haha
22:41:14 <pandres> sorry, wrong channel
22:41:19 <pandres> yep
22:41:23 <dons> :)
22:41:43 <edwardk> <interactive>:1:14: parse error on input `='
22:41:44 <edwardk> =)
22:41:55 <dons> ?topic-tail #haskell
22:41:56 --- topic: set to '["Haskell Communities & Activities Report, 10th edition","http://haskell.org/communities/","Haskell.org SoC projects","http://hackage.haskell.org/trac/summer-of-code/","Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","We put the Funk in Funktion","The ICFP has ended. Who won?"]' by lambdabot
22:41:56 <edwardk> so i would guess somewhere around there ;)
22:42:05 <dons> ?topic-cons Join us as we move forward toward the Age of the Lambda
22:42:06 <lambdabot> I do not know the channel Join
22:42:13 <dons> ?topic-cons #haskell Join us as we move forward toward the Age of the Lambda
22:42:13 --- topic: set to '["Join us as we move forward toward the Age of the Lambda","Haskell Communities & Activities Report, 10th edition","http://haskell.org/communities/","Haskell.org SoC projects","http://hackage.haskell.org/trac/summer-of-code/","Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","We put the Funk in Funktion","The ICFP has ended. Who won?"]' by lambdabot
22:42:40 <Korollary> Crowded topics are a marketing disaster.
22:42:51 <dons> ?topic-init #haskell
22:42:52 --- topic: set to '["Join us as we move forward toward the Age of the Lambda","Haskell Communities & Activities Report, 10th edition","http://haskell.org/communities/","Haskell.org SoC projects","http://hackage.haskell.org/trac/summer-of-code/","Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","We put the Funk in Funktion"]' by lambdabot
22:43:01 <edwardk> i just noticed the haskell topic was a list. how pathetic is that.
22:43:16 <dons> ?topic-tail #haskell
22:43:17 --- topic: set to '["Haskell Communities & Activities Report, 10th edition","http://haskell.org/communities/","Haskell.org SoC projects","http://hackage.haskell.org/trac/summer-of-code/","Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","We put the Funk in Funktion"]' by lambdabot
22:43:19 <Korollary> edwardk: that = you just noticing or the fact that it is a list/
22:43:21 <Korollary> ?
22:43:22 <dons> ?topic-tail #haskell
22:43:22 --- topic: set to '["http://haskell.org/communities/","Haskell.org SoC projects","http://hackage.haskell.org/trac/summer-of-code/","Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","We put the Funk in Funktion"]' by lambdabot
22:43:23 <edwardk> yes =)
22:43:40 <dons> ?topic-cons #haskell Join us as we move forward toward the Age of the Lambda
22:43:41 --- topic: set to '["Join us as we move forward toward the Age of the Lambda","http://haskell.org/communities/","Haskell.org SoC projects","http://hackage.haskell.org/trac/summer-of-code/","Haskell is still the language of choice for discriminating hackers","logs:","http://tunes.org/~nef/logs/haskell/","http://www.haskell.org/learning.html","We put the Funk in Funktion"]' by lambdabot
22:43:41 <Korollary> answer doesn't typecheck!
22:43:42 <dons> ok. done.
22:44:03 <edwardk> > or [True, True]
22:44:04 <lambdabot>  True
22:44:06 <edwardk> there =)
22:45:28 <edwardk> i realize the choice was in a with contexxt, so i could only choose one or the other but still =)
22:45:33 <Korollary> Expected Either, got Bool!
22:49:07 <pandres> since you're awakw guys
22:49:27 <pandres> somebody knows of digital images processing apps in haskell?
22:49:53 <pandres> i've read a paper , kind of old, the only thing I've found on the net
22:51:19 <Korollary> I know of none.
22:51:36 <Korollary> That should be quite a bit easier with Data.ByteString now.
22:51:37 * edwardk defers to older and wiser heads.
22:52:08 <int-e> Hmm, Imagemagick bindings would be an interesting idea.
22:52:12 <edwardk> yeah but you'd want a block image decomposition, and other stuff thats kinda waiting for DPH.
22:52:39 <pandres> DPH?
22:52:40 <edwardk> coz then it can be slick and implicitly parallel, etc. =)
22:52:47 <edwardk> data parallel haskell
22:52:48 <Korollary> It's all right. I don't have two cpus anyway.
22:53:35 <dons> edwardk: i don't think we need to wait for the optimal solution :)
22:53:42 <dons> since you can do an ok just right now
22:53:48 <dons> s/ok job/
22:54:08 <edwardk> well, block chunking could make multiple image transformations faster anyways even on one cpu. because you can then transform block-at-a-time in many cases. and if you chunk at cache-appropriately sized chunks, the filters can concatenate locally while things are still in cache.
22:54:32 <edwardk> i've been staring at automatic array dcomposition for the last 8-9 hours actually with something similar in mind
22:54:44 <edwardk> though admittedly in a non-haskell context.
22:55:19 <Korollary> Is it possible to use (Int, Int) as index for  Data.ByteString's Vector ?
22:55:19 <edwardk> the trick is figuring out what algorithms you'll use to know how to block the array, and how much you'll want in overlap exchange regions, etc.
22:55:50 <edwardk> its very much like laying out a MPI program now that i'm looking at it
22:56:45 <edwardk> just never really thought about using mpi style techniques to speed up single processor tasks.
22:56:46 <pandres> so array VS infite list is an easy choice for DI processing?
22:57:01 <edwardk> so its kind of novel to me
22:57:29 <edwardk> pandres: well, in the DP case, its more like lists of array chunks.
22:57:34 <Korollary> Well, I think "list" is not even a choice.
22:57:43 <dons> a list of arrays though...
22:57:43 <pandres> it is!
22:57:55 <edwardk> yeah
22:58:10 <edwardk> or in the image case a grid of arrays you can thread in list fashion
22:58:20 <dons> pandres: in practice you'd need to use either Data.Array.Unboxed or Data.ByteString I think
22:58:23 <edwardk> with vertical and horizontal traversals, like mpi channels
22:58:25 <pandres> teh infinite list approach and lazy IO menas that you dontneed the whole image in mem
22:58:32 <pandres> correct me if wrong
22:58:34 <dons> right
22:58:43 <dons> but you probably don't want an infinte list of Char
22:58:49 <edwardk> pandres: yes, but most image algorithms function better on blocks than scanlines.
22:59:17 <dons> ?quit add bf
22:59:47 <edwardk> so rather than chunk up an image into a 1024x1 scanline, you're better off using that space to chunk into say, 32x32 blocks
22:59:54 <lispy> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.@
22:59:59 <edwardk> it cuts the communication across scanlines and improves cache coherence of filters
23:00:19 <lambdabot> Done.
23:00:31 <lispy> hrm...that should have been hello world
23:00:35 <edwardk> usually the amount of communication in a filter is proportional to the surface area of your block. in the first case thats 1024, in the second thats 128
23:00:36 <dons> too slow?
23:00:39 <lispy> maybe
23:00:46 <dons> or maybe it didn't compile?
23:00:56 <lispy> i think it didn't compile
23:00:58 <dons> yes, no 'bf' binary
23:00:59 <lispy> Oh
23:00:59 <Korollary> "Done." sounds weird.
23:01:08 <lispy> dons: yeah, i forgot send cabal
23:01:10 <pandres> ok, thanks you for the hints
23:01:31 <edwardk> i used to do a lot of image processing stuff on a small mpi network =)
23:01:41 <lispy> dons: let me fix that real quick
23:01:51 <edwardk> switching gears to thinking about the same concepts in haskell, for things like array multiplication, etc.
23:01:53 <pandres> ok, maybe i'll be back with some questions then ;)
23:03:02 <lispy> dons: sent
23:05:55 <dons> lispy: should also be in lambdabot.cabal too
23:06:02 <lispy> doh
23:06:11 <dons> and you might want to add some ghc-option flags to get it optimised
23:06:19 <dons> ghc-options: -O
23:06:27 <lispy> hmm...yeah, i was going to profile it a bit here after we get it working :)
23:06:40 <dons> he
23:06:42 <lispy> i'll add it to the main cabal file real quick
23:07:51 <lispy> okay, sent that one too
23:09:34 <dons> ok.
23:09:37 <dons> try that
23:09:47 <lispy> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.@
23:09:48 <lambdabot> Done.
23:09:55 <lispy> interesting
23:09:58 <dons> tyr again
23:10:00 <lispy> heeh
23:10:04 <lispy> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.@
23:10:05 <lambdabot>  Hello World!
23:10:05 <lambdabot>  Machine Halted.
23:10:08 <lispy> yay!
23:10:22 <dons> bit noisy with the 2nd line.. ?
23:10:47 <lispy> perhaps, that line was helpful with the command line version so you know hen the program is done
23:10:53 <lispy> but mayb not as useful here
23:11:19 <dons> filter it out in the Plugin/* then/
23:11:20 <dons> ?
23:11:42 <lispy> or just have it not print it :)
23:12:06 <lispy> i'll try the former
23:12:41 <dons> either is good
23:14:07 <int-e> @bf
23:14:08 <lambdabot>  Machine Halted.
23:14:26 <int-e> @bf +[]
23:14:29 <lambdabot> Done.
23:14:55 <dons> ?uptime
23:14:55 <lambdabot> uptime: 15 minutes and 36 seconds, longest uptime: 38 minutes and 21 seconds
23:15:49 <int-e> @bf ++++[>[>>]+++++[>+++++<-]>[<+++++>-]<[<<]>-]>[[<<]>>--.++>[->.>]+>]<<.
23:15:53 <lambdabot> Done.
23:16:09 <int-e> @bf >++++[>[>>]+++++[>+++++<-]>[<+++++>-]<[<<]>-]>[[<<]>>--.++>[->.>]+>]<<.
23:16:13 <lambdabot> Done.
23:16:25 <dons> "Behind Harry Potter hides the signature of the king of the darkness, the devil," says Father
23:16:28 <dons> Gabriele Amorth, the Pope's "caster-out of demons"
23:17:08 <Korollary> Well
23:17:27 <Korollary> He's apparently 'the' authority on the subject
23:17:46 <edwardk> way to go catholic church, alienate the entire generation while yer at it? =)
23:18:00 <dons> heh
23:18:12 <sieni> that would be desirable, yes
23:18:28 <Korollary> Father Amorth says sieni is possessed, too.
23:18:47 <dons> sounds reasonable
23:18:53 <edwardk> i'd buy that
23:18:59 <sieni> god made me an atheist, what can i say
23:19:08 <edwardk> heh
23:19:16 <lispy> dons: hmm...so i modified cleanit to check for "Machine Halted" and replace it with "" but now it's scrubbing all my output...
23:19:16 <edwardk> there is a barbershop paradox in there somewhere ;)
23:19:38 <int-e> wth is that brainfuck interpreter doing?
23:19:39 <lispy> oh, i see
23:19:43 <int-e> @bf ++++++++++[>++++++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.@
23:19:46 <lambdabot>  bf: out of memory (requested 1048576 bytes)
23:19:48 <tennin> nah, God's probably sick of being believed in, is all
23:20:00 <int-e> or am I too stupid for cut&paste?
23:20:00 <dons> lispy: maybe use -O please :)
23:20:03 <lispy> int-e: it's pretty inefficient at the moment
23:20:21 <lispy> dons: hehe
23:20:29 <lispy> optim-what?
23:20:47 <edwardk> all that worship probably comes off as divine spam anyways
23:21:25 <dons> these catholic hackers: "I have no doubt that Hitler was possessed and so it does not surprise me that Pope Pius XII tried a long distance exorcism."
23:21:32 <edwardk> "oh my god, oh my god, oh my god"... would get a little tiring multiplied several million times over at once over a couple thousand years
23:21:33 <dons> i guess they had some remote exploit they could use to hack in
23:22:58 <int-e> lispy: inefficient isn't beginning to describe it
23:23:02 * int-e chuckles
23:24:28 <dons> :)
23:24:35 <int-e> > +[.]
23:24:36 <lambdabot>  Parse error
23:24:40 <int-e> @bf +[.]
23:24:43 <lambdabot>  ...
23:24:58 <int-e> oh good, that doesn't work on channels at least :)
23:25:04 <dons> :(
23:25:20 <int-e> in privmsg that sends ctcps.
23:25:26 <dons> lispy, filtering output to printable chars in the plugin might be a good idea...
23:25:34 <edwardk> heh
23:25:46 <int-e> @bf [-.]
23:25:47 <lambdabot>  Machine Halted.
23:25:50 <int-e> @bf -[-.]
23:25:50 <dons> i'm disabling it till we fix some things
23:25:50 <lambdabot>  þýüûúùø÷öõôóòñðïîíìëêéèçæåäãâáàßÞÝÜÛÚÙØ×ÖÕÔÓÒÑÐÏÎÍÌËÊÉÈÇÆÅÄÃÂÁÀ¿¾½¼»º¹¸·¶µ´³...
23:26:18 <lispy> dons: is there another plugin that does that filtering i can mimmic?  i'm not really sure which chars are printable
23:26:27 <dons> ?hoogle print
23:26:28 <lambdabot> Prelude.print :: Show a => a -> IO ()
23:26:28 <lambdabot> Text.Printf.Print :: class Print
23:26:28 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
23:26:31 <dons> ?hoogle+
23:26:32 <lambdabot> Text.Printf :: module
23:26:32 <lambdabot> Char.isPrint :: Char -> Bool
23:26:32 <lambdabot> IO.hPrint :: Show a => Handle -> a -> IO ()
23:26:57 <lispy> > isPrint 'a'
23:26:58 <lambdabot>  True
23:27:02 <dons> > filter isPrint ['\0'..]
23:27:03 <lambdabot>  " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefgh...
23:27:03 <int-e> as an approximation, don't print anything <32 or >126, except for 10 (end of line)
23:27:10 <lispy> sweet
23:27:22 <dons> ?hoogle isAscii
23:27:23 <lambdabot> Char.isAscii :: Char -> Bool
23:27:23 <lambdabot> GHC.Unicode.isAsciiLower :: Char -> Bool
23:27:23 <lambdabot> GHC.Unicode.isAsciiUpper :: Char -> Bool
23:27:32 <int-e> @bf ++++[>++++++++<-]>[.+]
23:27:32 <lambdabot> Done.
23:27:37 <dons> (disabled)
23:27:45 <int-e> still prints 'Done'.
23:27:49 <dons> sure
23:27:54 <dons> cause its done.
23:32:56 <glguy> hi everyone
23:33:28 <dons> hey glguy . how's the haskell coming along?
23:37:09 <glguy> still loving it. 80% on mathschallenge.net
23:37:21 <glguy> w/ haskell as my primary
23:37:40 <dons> yay
23:38:19 <glguy> i just install ubuntu + xgl/compiz
23:38:24 <glguy> omg
23:41:31 <lispy> so what is an efficient array type for holding Word8?  IOUArray?
23:42:28 <dolio> compiz is pretty.
23:44:32 <dons> ByteString?
23:44:35 <dons> does it have to be mutable?
23:44:55 <dons> otherwise, yeah, IOUArray Int Word8 would be good
23:46:08 <lispy> well, it's the "core" memory and gets updated every instruction
23:46:15 <dons> yep
23:46:19 <lispy> so i figured being mutable would help
23:47:28 <sieni> IOUArray == I Owe yoU Array?
23:47:33 <dons> sounds a bit like a Universal Machine
23:47:44 <dons> so probably some of the lessons of the UM would apply
23:47:48 <lispy> dons: yeah, i'm looking at the UM code right now
23:47:49 <dons> ?where um
23:47:49 <lambdabot> I know nothing about um.
23:47:52 <dons> cool
23:49:21 <dolio> :) I thought ByteString was good for everything.
23:49:39 <dolio> Someone should tell the guy on the GHC mailing list to write his multi-precision arithmetic replacement in ByteString.
23:50:02 <Cale> ByteString.Lazy :)
23:51:19 <lispy> i'm confused by the type of unsafeRead
23:51:25 <lispy> @type unsafeRead
23:51:26 <lambdabot> Not in scope: `unsafeRead'
23:51:31 <lispy> @hoogle unsafeRead
23:51:32 <lambdabot> No matches found
23:51:43 <lispy> unsafeRead :: (MArray a e m, Ix i) => a i e -> Int -> m e
23:51:44 <dons> ?type Data.Array.Base.unsafeRead
23:51:45 <lambdabot> forall e (a :: * -> * -> *) (m :: * -> *) i. (Data.Array.Base.MArray a e m, Ix i) => a i e -> Int -> m e
23:51:55 <lispy> what is m e?
23:51:59 <lispy> i just want e :)
23:52:00 <dons> Monad element
23:52:19 <lispy> so i need, do e <- unsafeRead arr 4 -- just to get e?
23:52:23 <Cale> m is usually ST or IO
23:52:27 <Cale> yeah
