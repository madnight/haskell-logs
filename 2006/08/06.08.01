00:00:03 <bortzmeyer> Nobody mentioned JSON (RFC 4627) yet? :-)
00:02:00 <audreyt> borism: representing haskell structures (or any other tagged records) in JSON is... not straightforward.
00:02:02 <tennin> I don't understand why the element/attribute distinction in XML
00:02:31 <sieni> tennin: to maximize agony
00:02:36 <tennin> I went looking for justifications of it, but all I found was perfunctory hand-waving
00:02:45 <tennin> I was at least hoping for some more energetic hand-waving
00:02:54 <bortzmeyer> tennin; it has old historical roots, back to the time of SGML
00:03:05 <sieni> xml is like s-expressions, expect that xml sucks
00:03:12 <audreyt> tennin: ok. the use case is
00:03:29 <audreyt> <a href="url"><b>text</b></a>
00:03:30 <bortzmeyer> SGML was only used for documents, not for data, so the difference between data (elements) and metadata (attributes) was more clear
00:03:44 <tennin> =\
00:03:48 <audreyt> tennin: not easy to do this with only elements or only atts.
00:04:19 <bortzmeyer> audreyt: <a><href>url</href><b>text</b></a>
00:04:30 <tennin> that doesn't really justify a fundamental distinction, it could just be allowed as a syntactic shorthand for the same thing
00:04:40 <bortzmeyer> Or <a><href>url</href>text</a> since mixed content is legal
00:04:55 <bortzmeyer> Some XML users never use attributes
00:05:33 <audreyt> I rest my case. :)
00:05:50 <audreyt> i.e. I think the att+elem encoding is more straightforward
00:05:56 <audreyt> but sure you can embed it using elems alone.
00:06:12 <bortzmeyer> audreyt: matter of taste, I don't think there is a profound difference
00:06:31 <audreyt> <a href="1">2<a name="3">4</a></a>
00:07:08 <audreyt> vs. <a><href>1</href>2<a><name>3</name>4</a></a>
00:07:24 <bortzmeyer> audreyt: <a><href>1</href>2<a><name>3</name>4</a></a> :-) Easy to transform from one form to another :-)
00:07:25 * johnnowak thinks attributes exist because xml is so needlessly verbose that xml would be (even more) painful without them
00:07:29 <audreyt> I agree it's matter of taste.
00:08:07 <Korollary> It's a social solution to a technical problem
00:08:50 <falconair_> earlier i was asking about doing math programming using functional languages, the following pdf file has the "Black-Scholes" option pricing formula (from finance) in 29 languages, including haskell...nice idea!
00:09:06 <falconair_> http://sciences.ows.ch/economie/BlackSholes.pdf
00:09:38 <falconair_> sorry, following is the html version: http://www.cse.ucsd.edu/~goguen/courses/130/SayBlackScholes.html
00:09:39 <lambdabot> Title: Say Black-Sholes!
00:10:10 <falconair_> haha, yeah, typo probably
00:14:07 <johnnowak> the economy of the HP48 example is impressive
00:17:57 <tennin> it seems like elements and attributes are two fairly arbitrarily chosen points of a larger design space
00:18:46 <tennin> i.e. (1) longhand vs shorthand syntax (2) allows further nesting vs flat string (3) allows duplicates vs unique (4) ordered vs unordered
00:19:00 <tennin> there may have been others I'm now forgetting
00:19:09 <tennin> I'm really too tired for this
00:19:13 <SamB_XP> we are still talking about how XML is just another kind of s-expression?
00:19:31 <SamB_XP> or again, I guess...
00:19:52 <tennin> or on the other hand, maybe if I weren't so tired I'd know better than to go on with this
00:20:12 <SamB_XP> yes, probably. it seemed boring before too.
00:20:29 * SamB_XP got bored trying to sleep, also
00:21:22 <tennin> well, I had a whole rant worked up in my head that came to me while trying to read through the XSLT spec
00:21:46 <bortzmeyer> Why isn't there a way to extract the items of a tuple? Something like t !! 0 ? I'm tired of writing functions just to extract an item.
00:21:56 <Korollary> > fst (1,2)
00:21:58 <lambdabot>  1
00:22:03 <Korollary> > snd (1,2)
00:22:04 <lambdabot>  2
00:22:13 <tennin> unfortunately much of it has faded from memory
00:22:26 <tennin> maybe it'll come back to me when I actually have to deal with XSLT again
00:22:32 <bortzmeyer> Korollary: thanks, I should have used Hoogle first :-)
00:22:33 <SamB_XP> @hoogle (a, b, c) -> a
00:22:34 <lambdabot> No matches, try a more general search
00:22:50 <Korollary> tennin: I bet there are a lot of rants about it on various blogs
00:22:52 * SamB_XP could have sworn he'd seen functions like that somewhere
00:23:10 <bortzmeyer> And if the tuple has more than two items?
00:23:27 <SamB_XP> well... don't do that ;-)
00:23:28 <tennin> there are tons of rants, I read many.
00:23:57 <tennin> My rant was slightly different through, at least I thought so at the time
00:24:25 <Korollary> For large tuples it makes more sense to declare a datatype
00:24:36 <tennin> through -> though
00:26:03 <SamB_XP> for some reason there is a certain tendancy not to pass around tuples other than pairs...
00:26:43 <Korollary> it's better documentation, too.
00:26:47 <int-e> lacking generalizations of fst and snd are a reason.
00:27:19 <SamB_XP> you'd be more likely to run into nested pairs...
00:27:41 <SamB_XP> ...than to encounter triples that weren't unpacked ASAP
00:27:57 <bortzmeyer> SamB_XP: nested pairs expressed in XML? :-)
00:28:09 <SamB_XP> huh?
00:28:29 <SamB_XP> XML hasn't tuples
00:28:57 <Korollary> > snd . fst ( (2,3), 4)
00:28:58 <lambdabot>  Couldn't match `a1 -> (a, b)' against `(a2, b1)'
00:29:01 <Korollary> bah
00:29:21 <Korollary> anyway
00:29:30 * Korollary passes out
00:29:38 <SamB_XP> > (snd . fst) ( (2,3), 4)
00:29:39 <tennin> you could use Template Haskell...
00:29:39 <lambdabot>  3
00:29:41 <bortzmeyer> SamB_XP: I was joking (hence the smiley). Tuples can be represented in XML (everything can be represented in XML)
00:29:42 <SamB_XP> Korollary: showoff
00:29:50 <SamB_XP> bortzmeyer: sure.
00:30:07 <SamB_XP> but it seems kind of silly to read them back in that way...
00:31:04 <Itkovian> vincenz: forwarded the mail ... most people are on vacation though, so I think we'd better not schedule the event next week
00:31:21 <bortzmeyer> OK, I can use datatypes instead of tuples. But, for easy extraction, I need to use datatypes with named field, no? Otherwise, I still have to write a function per field.
00:32:09 <SamB_XP> sure
00:32:17 <SamB_XP> records are nice for that ;-)
00:32:30 <bortzmeyer> And named records are not in Haskell 98, no ?
00:32:36 <SamB_XP> sure they are
00:33:13 <SamB_XP> data Record = Record { foo :: FooType, bar :: BarType } deriving (Eq, Ord, Show)
00:34:15 <bortzmeyer> OK, thanks
00:34:27 <SamB_XP> that gives you a constructor Record :: FooType -> BarType -> Record, extraction functions foo :: Record -> FooType and bar :: Record -> BarType, and some special syntax to boot ;-)
00:37:14 * lispy wishes they were named Record.foo instead of foo
00:37:22 <bortzmeyer> The main problem I have with named records is when you have identical fields (say "name") in two different types.
00:37:39 <lispy> if you define a lot of records in one module you easily get name clashes :(
00:37:53 <SamB_XP> oh, yeah, typically I will give the field names for a type a prefix
00:38:07 <lispy> yeah, like r_foo
00:38:18 <lispy> or rfoo
00:38:20 <lispy> or rFoo
00:38:22 <SamB_XP> so, like, data Item { itemName :: String, ... }
00:38:29 <bortzmeyer> Multiple declarations of `Main.name'
00:38:57 <bortzmeyer> SamB_XP:OK, like in C, no namespaces, use naming conventions :-(
00:39:09 <SamB_XP> bortzmeyer: well, not quite
00:39:16 <lispy> paecael
00:39:20 <lispy> oops
00:39:24 <SamB_XP> actually in C struct members have namespaces ;-)
00:39:29 <SamB_XP> so its kinda backwards
00:39:37 <lispy> you could put each record it's own module then import qualified :)
00:40:10 <SamB_XP> in C, modules don't have their own namespaces and structs do, in Haskell, modules do and record types don't ;-)
00:40:43 <lispy> i kinda like the way lisp does it
00:40:56 <SamB_XP> what? dynamic types?
00:41:08 <lispy> no the defstruct stuff
00:41:11 * SamB_XP doesn't like CL's namespaces
00:41:23 <lispy> those are confusing
00:41:28 <SamB_XP> too easy to mess up names
00:41:45 <SamB_XP> because you can *change* them
00:42:02 <SamB_XP> by *accident*
00:42:11 <lispy> in lisp it would be (record-foo fooinstance)
00:42:29 <lispy> very similar to the way haskell does it
00:42:44 <lispy> except they append "structname-" to the accesors
00:42:56 <SamB_XP> ah, yeah, nice
00:43:31 <lispy> i think given the haskell grammar, the most logical replacment for '-' would be '.'
00:43:36 <bortzmeyer> lispy: yes, it seems a very good idea. Does anyone know why Haskell does not do it?
00:43:40 <SamB_XP> ickickick
00:43:47 <SamB_XP> . does too much as it is
00:43:55 <int-e> what, and give . another meaning?
00:43:59 <int-e> exactly.
00:45:05 <lispy> i bet it wouldn't be too confusing because it would remind us of qualified module names
00:45:26 <SamB_XP> but how would you tell which it was?
00:45:37 <lispy> now that's a good question :)
00:45:44 <lispy> you'd have to check the imports
00:45:48 <SamB_XP> see, I told you . meant too much already
00:45:49 <int-e> import qualified Foo (blah); data Foo { blah :: Int }; Foo.blah.
00:46:35 <int-e> on the other hand, if you put data Foo in a module named Foo, you get what you want ...
00:46:35 <lispy> i think the reasonable thing in that case would be to have the compiler complain about name clashesh
00:47:04 <lispy> yeah, but that's not always deserable
00:47:19 <lispy> what if you have hundreds of similar records to define?
00:47:38 <lispy> take for example the way dtd2haskell generates code
00:48:03 <lispy> we could use ' in the names
00:48:09 <lispy> Record'foo
00:48:32 <lispy> actually i guess you'd have to use record'foo
00:48:52 <lispy> in fact, i think i'll start making that my convention
00:49:01 <lispy> > let record'foo = 4 in record'foo
00:49:02 <lambdabot>  4
00:49:07 <lispy> ah good it does parse :)
00:49:22 <SamB_XP> heh
00:49:24 <SamB_XP> ick
00:49:48 <lispy> > let record-foo = 4 in record-foo
00:49:48 <lambdabot>  Not in scope: `foo'
00:49:55 <lispy> the alternatives don't parse :(
00:50:01 <SamB_XP> well, maybe it is useful for french or italian words, or something...
00:50:15 <SamB_XP> probably french...
00:50:35 <bortzmeyer> It does not parse for me:tuple.hs:33:22: parse error on input `Person'name'
00:50:49 <bortzmeyer> in data Person = Person {Person'name::String, Person'age::Float} deriving (Eq, Show)
00:50:57 <lispy> > let {it = (+1); is = 3; it's = it is} in it's
00:50:58 <lambdabot>  4
00:51:16 <SamB_XP> bortzmeyer: you can't have capitalized variable names
00:51:20 <lispy> bortzmeyer: lower case the person on the rhs
00:52:00 <bortzmeyer> lispy; thanks, I just disovered it
00:52:44 <lispy> > let my:test = 2 in my:test
00:52:45 <lambdabot>  add an instance declaration for (Num [a])
00:52:45 <lambdabot>   In a pattern binding: my : te...
00:52:52 <lispy> oh duh
00:53:24 <lispy> data Person = Person { person'Name :: String, person'Age::Float}
00:53:38 <lispy> i think that's the capitalization i'd use
00:55:15 <bortzmeyer> lispy: yes, good idea, I believe I will stick on it, too
00:56:48 <lispy> cool, glad i could help :)
01:08:06 --- topic: '["Haskell Communities & Activities Report, 10th edition", "http://haskell.org/communities/", "Haskell.org SoC projects", "http://hackage.haskell.org/trac/summer-of-code/", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion", "The ICFP has ended. Who won?"]'
01:08:06 --- topic: set by int-e on [Mon Jul 24 14:25:57 2006]
01:16:34 <zeeeee> hi all, i'm just starting out in haskell. critique of any kind on my first app would be greatly appreciated. http://rafb.net/paste/results/7ZCvWt22.html
01:18:22 <zeeeee> (can i make it more concise/clear/clean/haskellic? everything from the var names to the whitespace)
01:20:04 <ski> instead of having 'argv <- getArgs' you could have 'arg1:arg2:_ <- getArgs'
01:20:36 <ski> (and of course s/(argv !! 0)/arg1/ s/(argv !! 1)/arg2/, then)
01:21:17 <ski> (or you could do '[arg1,arg2] <- getArgs' if you want to fix to 2 args)
01:22:45 <ski> hm, why have 'unlines' and 'lines' in two different places ?
01:23:17 <int-e> > let (bef, mid:aft) = splitAt 3 [1,2,3,4,5,6,7] in (bef, mid, aft)
01:23:19 <lambdabot>  ([1,2,3],4,[5,6,7])
01:30:20 --- topic: '["Haskell Communities & Activities Report, 10th edition", "http://haskell.org/communities/", "Haskell.org SoC projects", "http://hackage.haskell.org/trac/summer-of-code/", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion", "The ICFP has ended. Who won?"]'
01:30:20 --- topic: set by int-e on [Mon Jul 24 14:25:57 2006]
01:40:37 <shapr> Good morning #haskell!
01:40:58 <shapr> Hiya crem
01:41:31 <Lemmih> Hm, the threaded RTS is weird.
01:41:59 <lrrr> hi there
01:42:03 <Lemmih> My program fails about 0.2% of the time when I compile it with -threaded.
01:42:31 <lrrr> can anybody help me to understand difference between lazy evaluation in haskell and call-by-name in lambda calculus?
01:43:23 <lrrr> they're look so alike, but i'm sure they're not the same thing :)
01:44:00 <lrrr> or may be there's some good paper about this?
01:44:43 <shapr> I have a nice call-by-name call-by-value paper.
01:44:46 * shapr looks...
01:45:11 <lrrr> well i get the call-by-name vs call-by-value thing
01:45:30 <lrrr> normal order reduction, _|_ and so on..
01:45:47 <lrrr> but how exactly lazy evaluation relates to this?
01:46:05 <audreyt> lazy evaluation is call-by-name with memoization
01:46:15 <audreyt> so the next call-by-name will simply yield the previously calculated value
01:46:19 <audreyt> also known as call-by-need.
01:46:33 <audreyt> it is possible if the calculated value depends on the input alone
01:46:46 <audreyt> haskell is unique in guaranteeing this property.
01:47:00 <lrrr> is there expressions where lazy evaluation will fail to reach normal form but call-by-name won't ?
01:47:20 <lrrr> or they truly equivalent?
01:47:24 <audreyt> I do not think so. the order of evaluation is the same in both cases; it's just the result is cached.
01:48:23 <dcoutts> lrrr, they're not equivalent, call-by-name reaches normal form in more cases
01:48:24 <ValarQ> audreyt: is it actually unique?
01:48:38 <audreyt> among mainstream languages...
01:49:06 <lrrr> dcoutts, can you please give an example?
01:49:10 <audreyt> well, unique as far as I'm aware of :)
01:49:23 <dcoutts> lrrr, head [1,undefined]
01:49:41 <ValarQ> audreyt: i don't know about clean but miranda should be lazy as well
01:49:57 <audreyt> dcoutts: uhm, but lazy evaluation (call by need) gives 1 as well
01:50:09 <audreyt> dcoutts: lrrr was comparing call-by-need vs call-by-name
01:50:16 <dcoutts> audreyt, oh
01:50:21 <dcoutts> rigfht, sorry
01:50:30 <dcoutts> yeah, one is just an impleementation of the other
01:50:51 <lrrr> ah, ok :)
01:51:11 <audreyt> ValarQ: Miranda is still around?
01:51:28 <audreyt> (yes, it's lazy as well. I thought it's fallen into disuse :))
01:51:49 <shapr> I thought Haskell was designed to replace Miranad.
01:51:55 <dcoutts> they find the normal form in the same cases, but call by need can often do so with fewer steps
01:52:52 <audreyt> I ported call-by-need and call-by-name to perl5 as a CPAN module :) people reported that it leads to much cleaner code.
01:53:15 <audreyt> (with, in most cases, negligible performance penalty)
01:53:20 <shapr> Neato
01:53:26 <lrrr> and another one thing that i'm not understanding pretty well in haskell: order of evaluation, in call-by-name, as I understand, order of evaluation is fully detemined, "reduce the leftmost outermost expression" -- in haskell this works exactly the same way?
01:53:28 <audreyt> # http://search.cpan.org/dist/Scalar-Defer/
01:53:30 <lambdabot> Title: &#9787; &#21776;&#40179; &#9786; / Scalar-Defer - search.cpan.org
01:54:36 <audreyt> lrrr: yes.
01:55:05 <audreyt> (if you ignore the presence of "seq" and its friends.)
01:55:34 <ibid> lambdabot: haskell does not define evaluation order, just nonstrict semantics. lazy evaluation (call by need) is the most popular implementation method, though
01:55:40 <ibid> argh
01:55:51 <ibid> lrrr: ^
01:56:18 <lrrr> andreyt: it's because `seq` is somewhat not expressible in lambda?
01:58:33 <audreyt> yeah. `seq` is a primitive, not something that can be expressed using nonstrict lambdas.
01:58:49 <audreyt> for further details, the "Free Theorems in the Presence of seq" paper may be interesting.
01:59:37 <lrrr> ok, thanks :)
01:59:52 <audreyt> np :)
02:14:15 <edwardk> its a good paper. (just got back)
02:15:11 <edwardk> its been forcing me to contort my thinking on the whole substructural pure type system stuff to make sure i can track pointed types everywhere.
02:57:37 * shapr yodels
02:58:20 * boegel smacks shapr just for the fun of it
02:58:26 <shapr> ow!
03:00:42 <musasabi> morning
03:04:42 <ValarQ> g'day folks
03:04:46 <ndm> morning
03:11:57 <musasabi> What was the correct way to make tags for the GHC source?
03:14:36 <araujo> morning
03:22:08 <shapr> @yow !
03:22:09 <lambdabot> Okay ... I'm going home to write the "I HATE RUBIK's CUBE HANDBOOK FOR
03:22:09 <lambdabot> DEAD CAT LOVERS" ...
03:22:20 <ValarQ> what?
03:22:33 <shapr> musasabi: dons has a tags script - use hasktags instead of htags in the script - http://www.cse.unsw.edu.au/~dons/tmp/tag-fptools
03:22:45 * shapr blogs that
03:24:06 <musasabi> shapr: thanks
05:40:35 <dons> ?yow!
05:40:36 <lambdabot> LOOK!!  Sullen American teens wearing MADRAS shorts and "Flock of
05:40:36 <lambdabot> Seagulls" HAIRCUTS!
05:41:53 <ozone> irc
05:41:57 <ozone> oops
05:48:33 <ndm> dons, how come you always use ? to prod lambdabot, and most people use @
05:49:15 <dons> oh, i find ? more intuitive for asking questions, so i added it
05:49:22 <dons> everyone else is using legacy syntax ;)
05:49:27 <Stinger_> haha
05:49:38 <Stinger_> depricated ;)
05:50:04 <ValarQ> ¿yow?
05:50:08 <ndm> hmm, i was thinking of making @anything fire off lambdabout in guihaskell
05:50:12 <dons> ?uptime -- works for me
05:50:13 <lambdabot> uptime: 2 days, 9 hours, 1 minute and 33 seconds
05:50:20 <dons> since i'm asking for the uptime
05:50:26 <dons> oh, cool
05:50:29 <ndm> but don't want to use depreciated syntax :)
05:50:49 <dons> hehe. basically both @ and ? are allowed. that's it
05:50:49 <ozone> your mum's deprecated syntax
05:50:54 <roconnor> @vixen hey
05:50:55 <lambdabot> hello
05:50:55 <dons> hehe
05:51:00 <ndm> (obviously, this is dependant on lambdabot working with windows)
05:51:03 <ozone> hmm
05:51:05 <ozone> remind me not to irc after a few beers
05:51:15 <roconnor> @vixen what do you think about thread local storage?
05:51:15 <lambdabot> i dunno, what about?
05:51:16 <dons> ozone: REMIND ME!
05:51:19 <ozone> @tell ozone remind me not to irc after a few beers
05:51:20 <lambdabot> You can tell yourself!
05:51:24 <ndm> @tell ozone remind me not to irc after a few beers
05:51:25 <lambdabot> Consider it noted.
05:51:33 <ozone> what?  screw you hippie
05:51:34 <lambdabot> ozone: You have 1 new message. '/msg lambdabot @messages' to read it.
05:51:41 <mahogny> lol
05:51:44 <ozone> maybe you should rename it to "Turing" or something, dons
05:52:08 <ozone> @message this, beeyatch
05:52:09 <lambdabot> Maybe you meant: messages messages?
05:52:17 <dons> ozone goes totally wacky
05:52:17 <ndm> dons, what about @ndm does @quote ndm if ndm is not a command, but is exactly a user name?
05:52:29 <dons> it should be so, yes, ndm
05:52:30 <ndm> ditto for @epigram - does @where epigram
05:52:33 <dons> following keal and so on
05:52:39 <ndm> indeed
05:52:55 <ozone> dons: i have seen erlang the movie, i am changed forever
05:53:04 <dons> :)
05:53:24 <dons> http://video.google.com/videoplay?docid=-5830318882717959520 this one?
05:53:25 <lambdabot> Title: Erlang: The Movie - Google Video
05:53:32 <xerox> Then one populates the quote/where space with nicks and DoS!
05:53:53 <ozone> hello mike!  hello rob.  hello joe!  hello mike.
05:54:00 <xerox> Erlang the movie is a cult. Hello Rob. Hello Joe. Hello Mike.
05:54:14 <ndm> am just watching it now!
05:54:21 <ndm> where is Haskell: The Movie ?
05:54:32 <dons> hello simon. hello simon. hello simon
05:54:40 <xerox> hahaha
05:54:49 <ozone> ahaha
06:02:05 <ndm> that movie sounds like an advert for static checking of names, at the very least!
06:02:23 <dons> yep
06:02:29 <edwinb> It's why Haskell has such good support for overloading.
06:08:23 <ndm> but thats a very cool movie
06:10:16 <musasabi> JaffaCake: should I make the class alias changes in ghc head or ghc-fc branch? Seems like if I make the changes into head merging won't be fun due to the AT changes touching many of the same functions.
06:11:43 <JaffaCake> musasabi: merging will probably be difficult in either case - we're having difficulty keeping the ghc-fc branch synced with the head
06:12:13 <JaffaCake> I suggest keeping your changes local, so you can resolve conflicts by re-recording
06:13:44 <musasabi> but local to which branch - both changes change the majority of places which use ClassDecl
06:25:47 <Philippa> JaffaCake: Ping? I PMed you, don't want to nag but figured you might've missed it
06:31:27 <SamB> ack, my idiot solver is still going... and I have no way to check on its progress :-(
06:34:01 <SamB> I wish there was some way to easily toggle tracing at runtime...
06:34:03 <kpreid> SamB: add progress info only and run again, and use its results to guess at whether the first one is making good progress?
06:34:04 <lambdabot> kpreid: You have 1 new message. '/msg lambdabot @messages' to read it.
06:34:47 <SamB> kpreid: to do that I'd have to analyze the shape of the tree and stuff
06:45:21 <shapr> roconnor: Coming to AngloHaskell?
06:46:56 <SamB> and I'm not sure I can *do* that
06:47:34 <roconnor> shapr: nope.  as I recall I was busy whenever it is happening
06:47:34 <roconnor> I should start writing my article.
06:47:53 <shapr> roconnor: It's happening on Friday.
06:47:57 <shapr> In Cambridge
06:48:09 <roconnor> this friday?
06:48:17 <shapr> Yup
06:49:05 <roconnor> hmm, I'm actually free THIS weekend.
06:49:14 <roconnor> Maybe I can get a discount flight
06:50:36 <Lemmih> JaffaCake: Have I misunderstood something or did you add 'pkgString' to template-haskell and then used it in stage1?
07:16:36 <blackhawkblade> hello someone here from germany or who speaks german?`
07:16:40 <shapr> roconnor: Show up, it'll be fun!
07:16:55 <beelsebob> moin
07:17:14 <SamB> hmm, is there a genetic algorithm tutorial or something somewhere?
07:17:35 <blackhawkblade> beelsebob do u speak german=?
07:17:49 <mahogny> hm. I don't think our material is for public access
07:17:49 <psnl> SamB: um, haven't seem one
07:17:56 <beelsebob> blackhawkblade: a tiny bit
07:18:11 <mahogny> samb: but I can prolly answer your questions
07:18:16 <SamB> mahogny: who is "us"
07:18:16 <blackhawkblade> do u have a little bit time for me?
07:18:35 <mahogny> samb: a course at chalmers
07:18:36 <Stinger_> probably his uni
07:18:38 <ndm> beelsebob: you coming to AngloHaskell?
07:18:49 <beelsebob> angloHaskell?
07:18:54 * beelsebob confuseled
07:19:02 <ndm> @wiki AngloHaskell
07:19:03 <lambdabot> http://www.haskell.org/haskellwiki/AngloHaskell
07:19:34 <SamB> @google site:chalmers.se genetic algorithm
07:19:37 <lambdabot> http://www.me.chalmers.se/~mwahde/classification.html
07:19:37 <lambdabot> Title: Genetic Algorithm Based Classification of Gene Expression Data
07:19:44 <SamB> hmm
07:19:46 <beelsebob> ndm: doubt it
07:20:00 <shapr> beelsebob: Too far to Cambridge?
07:20:13 <ndm> @google distance cambridge kent
07:20:17 <lambdabot> http://www.kent.ac.uk/studying/faq.html
07:20:17 <lambdabot> Title: FAQs - Frequently asked questions - Studying at Kent - University of Kent
07:20:21 <Stinger_> microsoft handles ghc?
07:20:28 <beelsebob> no, stuff to do on the 4th of august
07:20:34 <beelsebob> Stinger_: no, SPJ and SM do
07:20:41 <SamB> Stinger_: a number of people at MS research do
07:20:46 <beelsebob> they just happen to be funded by MS research
07:20:50 <ndm> Stinger_: and ms handle SPJ and SM
07:20:51 <Stinger_> interesting
07:20:58 <ndm> so transitively....
07:21:03 <beelsebob> hehe
07:21:07 <blackhawkblade> somone here who speaks german?
07:21:11 <SamB> apparantly microsoft likes to hire GHC hackers for some reason
07:21:20 <shapr> Stinger_: GHC stays BSD3 licensed though.
07:21:25 <beelsebob> well... they are integrating it into VS
07:21:28 <Stinger_> look out for ghc.net coming soon!
07:21:44 <beelsebob> Haskell.net surely
07:21:45 <ndm> Stinger_: we already have YHC.net, it can produce native .NET bytecodes :)
07:21:47 <beelsebob> and btw... ick
07:21:53 <mahogny> ghc.net. that's when I switch over to another language :P
07:22:01 <Stinger_> yeah dunno why I chose ghc there
07:22:04 <SamB> beelsebob: you'd think they'd care more about all the problems GHC has on windows, wouldn't you?
07:22:14 <ndm> SamB, what problems?
07:22:22 <SamB> I heard it has a lot of problems ;-)
07:22:23 <ndm> as a GHC windows user, i'm perfectly happy
07:22:23 <beelsebob> SamB: I think they care that SPJ and SM aren't working for someone else
07:22:29 <SamB> hmm
07:22:35 <SamB> is that the only reason they hired them?
07:22:36 <beelsebob> if they employ the good researchers, then no one else can
07:22:38 <ndm> i'm not aware of many problems at all
07:22:54 <Stinger_> would this someone else start with ooh say a 'g'? :P
07:23:01 <dylan> must... stop listening to the Mandelbrot Set song...
07:23:09 <ndm> now Mac GHC, that has issues :)
07:23:22 <beelsebob> no, not really
07:23:28 <beelsebob> runs fine here
07:23:31 <ndm> doesn't 6.4.2 + threads = death ?
07:23:38 <beelsebob> nope
07:23:43 <ndm> beelsebob: still not become a Yhc buildbot?
07:23:45 <beelsebob> 6.4.2 + intel mac = death though
07:23:58 <ndm> ah, yeah, that was what i remember
07:24:02 <beelsebob> 6.5 + intel mac = happy shiny super fast builds though
07:24:17 <ndm> oh, a buildbot with 6.5 + intel mac would be nice :)
07:24:25 <beelsebob> heh
07:24:33 <beelsebob> prod me when I have less work
07:24:38 <beelsebob> (like after the IFL submission deadline)
07:24:46 <ndm> if you have everything installed, its about 10 minutes to set up
07:24:51 <ndm> and Andrew does everything from then on
07:24:54 <SamB> the only ways I can think of that having them at MS research would keep them from threatening MS are that (a) MS can keep an eye on them and be prepared for whatever they are working on and (b) they will not have to work on non-Haskell things as much, and the non-Haskell things they might have to work on would be under MS's control, or at least not under their competitors' control
07:25:04 <ndm> but prodding will commence after IFL deadline :)
07:25:30 <ndm> SamB, or just because they want to fund cool research, and gain the prestige and recognition of clever people doing clever things?
07:25:43 <SamB> for their on nefarious ends, no doubt
07:25:50 <mahogny> samb: heh. add to the list the fact that the haskell community isn't very MS hostile compared to other communities, and Ithink it is connected to this
07:25:51 <ndm> i doubt they have evil plans
07:26:03 <beelsebob> ndm: is yhc buildbots based on andrew's typed bags stuff?
07:26:12 <ndm> beelsebob: you what?
07:26:18 <ndm> oh, no, nothing to do with that
07:26:22 <beelsebob> apparently not
07:26:24 <beelsebob> :P
07:26:24 <ndm> real code, real people, not linda
07:26:30 <SamB> well, MS itself is headquartered in the US, where evil is required by law
07:26:30 <beelsebob> BWAHAHAHAHA
07:26:42 <beelsebob> SamB: Google - Don't be evil
07:26:49 <Stinger_>  /whois SamB
07:26:52 <Stinger_> heh
07:27:07 <ndm> SamB, MS have been nice to Haskell, very nice...
07:27:13 <SamB> well. Google must have found a loophole.
07:27:30 <ndm> I think MS is good, and google is evil, they're just waiting to pounce
07:27:35 <SamB> heh
07:27:36 <ndm> and acheive world domination
07:27:39 <Stinger_> they outsource their evil to china
07:27:48 <blackhawkblade> no one here who speaks german?
07:27:49 <SamB> if MS is good, they are very bad at showing it
07:28:04 <ndm> if you were good, you wouldn't need to spend time telling everyone
07:28:08 <Stinger_> they just dont want praise
07:28:11 <Stinger_> they are modest :)
07:28:13 <ndm> and if you are successful, everyone just assumes you are evil
07:28:18 <SamB> you'd think they'd want to *act* like it
07:28:22 <shapr> blackhawkblade: Some people who speak German are here, but they seem to be afk at the moment.
07:28:30 <blackhawkblade> damn
07:28:31 <shapr> ndm: I agree with that.
07:28:34 <SamB> instead of undercutting the competition and driving them out of bussiness at every opportunity
07:28:43 <blackhawkblade> ok is somewhere else here who has a few minutes for me?
07:28:55 <SamB> and strongarming the OEMs
07:29:04 <ndm> SamB, capitalism,the idea of selling more of your stuff, and making your competitors sell less stuff
07:29:16 <shapr> blackhawkblade: What's your question?
07:29:22 <SamB> yeah. but MS plays dirty.
07:29:27 <ndm> if you look at some of their competitors, i.e. Real Media, you realise they won by being better
07:29:34 <shapr> Sadly, monopoly is a pathological case of capitalism.
07:29:37 <ndm> and that the bar for competition was disturbingly low...
07:29:40 <SamB> I wasn't talking about Real Media
07:29:58 <ndm> if you were talking about netscape, same applies
07:29:59 <SamB> and MS's player is only a little better IMO
07:30:10 <SamB> too much wierd graphics that doesn't work reliably enough...
07:30:10 <ndm> no, its about 100 times better, because it doesn't take over my system
07:30:21 <SamB> hmm, yeah, true
07:30:22 <ndm> and i wouldn't class it as spyware
07:30:28 <SamB> point point...
07:30:35 <SamB> but I wouldn't want to *use* it, in any case
07:30:37 <beelsebob> ndm: It doesn't?  I haven't found a way to remove it from a Windows box
07:30:43 <beelsebob> I'd call that taking over the system
07:30:44 <shapr> In any case...
07:30:52 <SamB> beelsebob: that isn't what you call taking over
07:30:55 <ndm> beelsebob: you don't need to remove it, it just lies their inert
07:31:10 <shapr> If Microsoft is going to pay the Simons to write BSD3 licensed Haskellcode, I surely won't argue.
07:31:12 <Stinger_> like some dormant tumor :)
07:31:18 <beelsebob> ndm: in the same way that IE lies their inert when you tell windows to disable it?
07:31:28 <SamB> I'm more concerned that you probably can't downgrade it
07:31:28 <beelsebob> as in... it pops up at every possible oportunity
07:31:30 <ndm> beelsebob: not true, its actively used for lots of things
07:31:37 <shapr> From what I've heard, Microsoft Research is not the same as Microsoft Corporate.
07:31:39 <SamB> beelsebob: heh
07:31:53 <SamB> the reason IE is so annoying is that the help viewer is IE
07:32:01 <ndm> shapr: but it does mean that the Simon's are unable to look at GPL code, i beleive
07:32:08 <ndm> (at least thats what Tony Hoare said)
07:32:10 <SamB> so it pops up IE when you click on links
07:32:19 <SamB> actually IE would be nice if it weren't so bad
07:32:46 <beelsebob> SamB: that and MSN messenger opens IE, and randomly Explorer will use it instead of Firefox
07:32:47 <shapr> ndm: How so?
07:33:21 <beelsebob> shapr: for fear of MS being accused of it being in their software
07:33:23 <ndm> shapr: MS policy, and that if someone in the copmany has read GPL code, and someone else is involved in a copyright case regarding it, then its considered intentional
07:33:35 <ndm> which makes the damages much more
07:33:48 <shapr> Weird
07:34:05 <ndm> I asked Tony Hoare what kind of restrictions being at MS caused for his research, he said pretty much none, other than that one
07:34:07 <shapr> How do they handle stuff like HaXml? Isn't it already GPL?
07:34:20 <ndm> HaXml isn't distributed with GHC as a library
07:34:26 <shapr> It was.
07:34:31 <dmhouse> Isn't GHC GPL in the first place?
07:34:33 <ndm> it isn't now, i believe
07:34:38 <shapr> dmhouse: Nah, GHC is BSD3
07:34:45 <dmhouse> Ah.
07:34:52 <ndm> and thats one of the reasons they can't use cpphs, despite the fact that cpp breaks loads of things in haskell
07:34:55 <eivuokko> dmhouse, No.  BSD3 mostly.  Only GMP (used in rts) is LGPL.
07:36:03 * shapr reads about AMD's future 8-core products.
07:36:17 <SamB> that sounds kind of crazy to me ;-)
07:36:30 <ValarQ> sounds great to me :)
07:36:45 <SamB> what kind of software do you need for that?
07:36:48 <shapr> I like the idea behind AMD's 4x4 platform.
07:37:18 <shapr> SamB: Think about it, with STM and ghc-smp, all of your Haskell programs will be able to use bunches of cores without the insanity of thread locking you get with Java.
07:37:35 <shapr> Like this naive search you're running, yeah?
07:37:51 <SamB> I suppose maybe
07:38:09 <shapr> You could partition your search tree and give chunks to a bunch of different threads, right?
07:38:20 <SamB> yeah
07:38:39 <SamB> I'd have to change it so that it gave me *all* the results, though, I think...
07:38:58 <shapr> If you had two 8-core sockets on your mobo, you could go through a search tree pretty quickly.
07:39:08 <shapr> Even at 500MHz per core.
07:39:22 <emertens> I was under the impression that each additional processor's efficiency dropped off dramatically
07:39:23 <SamB> they are probably better MHz than the ones I have now, too
07:39:29 <SamB> and even one of those cores has more of them
07:39:37 <shapr> emertens: That's true with single threaded software.
07:39:38 <SamB> emertens: hmm?
07:39:59 <shapr> emertens: Most programs were never written with multiple CPUs in mind.
07:40:03 <emertens> because the time that the processor spends scheduling between processors reduced throughput
07:40:05 <SamB> oh, yeah, sure with single-threaded software when you are using for the most part just one CPU-intensive program at a time
07:40:32 <SamB> emertens: yeah, a bit lower bandwidth... maybe...
07:40:33 <shapr> Do you mean cache coherency with NUMA? or specifically interprocessor task scheduling?
07:40:40 <blackhawkblade> someone here who speaks german???
07:40:44 <emertens> the later
07:40:48 <shapr> blackhawkblade: Ich habe keine ahnung!
07:40:49 <SamB> I think he means scheduling bus access, or something?
07:41:15 <shapr> In Linux at least, task migration isn't done very often, just a few times a second.
07:41:20 <SamB> because interprocessor task scheduling is not very problemetic, from what I have heard...
07:41:25 <ihope> So does evaluate just evaluate the top constructor thing?
07:41:39 <mahogny> blackhawkblade: depends on the degree and who you ask i guess...
07:42:06 <shapr> On the downside, things like Python behave badly behave they have a global interpreter lock, and that lock gets migrated from CPU to CPU.
07:42:29 <shapr> But you can get around that by setting the cpu affinity for the Python intererpreter. "Don't leave this CPU!"
07:42:36 <SamB> heh
07:42:45 <shapr> Then all of your other tasks will be executed on your free CPU(s).
07:42:54 <mahogny> the sooner CPUs demand a better programming, the sooner we can trash our current shitty set of languages :)
07:42:59 <mahogny> +model
07:43:00 <SamB> everyone knows that SMP does nothing for Python apps
07:43:16 <shapr> emertens: I've been using a dual cpu Athlon MP 1.5GHz for several years, and it's the most responsive system I've ever used. It's way sexy!
07:43:33 <SamB> so how much do these 16-way systems cost?
07:43:39 <ihope> So just what is the Idioms wiki category for?
07:44:00 <ValarQ> SamB: oh, it does, but you need to use fork(2) :o)
07:44:01 <edwardk> idioms =)
07:44:03 <shapr> All the single cpu systems I've used have the occasional lag or dropout. I've never had that problem on my dual athlon system.
07:44:16 <ndm> ihope: think of it as a wiki index
07:44:34 <SamB> ValarQ: true, but that is a PITA
07:44:36 <shapr> Admittedly, the system requires five case fans to keep from overheating, but that's a flaw of the Athlon MP cpu, not SMP in general.
07:45:03 <ValarQ> SamB: depends on the problem... but yes
07:45:09 <SamB> or maybe it is a flaw in case design or fan engineering ;-)
07:45:18 <shapr> emertens: Also, with 8+ cores, Linux uses a tree to do the scheduling, making it easier to migrate with fewer steps.
07:46:07 <shapr> SamB: Nah, the case is a top-of-the-line ChiefTec Dragon with space for dual redundant PSUs, and the CPU fans are aftermarket Arctic Cooling fans with big chunks of copper on them. The Athlon MP just dumps out too much heat :-(
07:46:54 <shapr> SamB: The 4-way consumer systems claim less than $2k usd.
07:47:49 <shapr> I wish they'd just go ahead and release 8-way dies running at 500MHz.
07:47:54 * shapr shrugs
07:47:58 <SamB> what can I get for $2c?
07:48:05 <SamB> or do I mean $2C
07:48:09 <emertens> 200?
07:48:11 <SamB> yeah
07:48:36 <shapr> abacus? slide rule?
07:48:41 <ihope> Oh, sheesh...
07:48:42 <SamB> heh
07:48:52 <SamB> actually I think this computer was about that much
07:49:37 <ihope> I decided to put "defined:idiom" into Google, then I clicked the Wikipedia link, and I read through most of the article before getting to the part I really wanted.
07:51:24 <psi> can I change the description of already recorded darcs patches?
07:51:54 <SamB> psi: have you sent them or pushed them or pulled them or otherwise moved them?
07:52:03 <eivuokko> If they are only on your darcs repo, you can use amend-record or unrecord and rerecord
07:52:17 <psi> only in mine
07:52:20 <eivuokko> If you have distributed the patch, then it's pretty much impossible.
07:52:32 <psi> mkay
07:52:44 <SamB> if you have the patch in more than one place, of course be careful to get rid of all the other copies!
07:55:41 <dgoldsmith> eivuokko: Isn't GMP GPL, not LGPL?
07:56:56 <musasabi> "GMP is distributed under the GNU LGPL. This license makes the library free to use, share, and improve, and allows you to pass on the result. The license gives freedoms, but also sets firm restrictions on the use with non-free programs."
07:59:13 <shapr> 220 clients on #haskell today, that's a good number.
07:59:50 <shapr> dgoldsmith: How's Haskell going for you? Any questions?
08:00:36 <dgoldsmith> musasabi: Hmmm. I must have misread it. Thanks!
08:00:58 <dgoldsmith> shapr: having fun. :-)
08:01:12 <shapr> dgoldsmith: Spiffy, if you think of any questions...
08:01:21 <dgoldsmith> shapr: Thanks!
08:01:29 * dgoldsmith has phone meeting starting...
08:01:45 * shapr starts packing for AngloHaskell
08:03:16 <SamB> arg
08:03:20 <shapr> param?
08:03:31 * SamB didn't know that dyndns names expired
08:03:58 <SamB> oh wait, maybe that is one I don't use...
08:04:57 <mnislaih> I'm having a lot of issues in my code with exceptions + lazyness
08:05:01 <SamB> oh, apparantly my IP address hasn't changed...
08:05:15 <mnislaih> anyone can point a helpful tutorial, webiste or  paper covering this ?
08:05:42 <ihope> Hmm... well, if a person wants to {-# OPTIONS -fglasgow-exts #-} {-# OPTIONS -fallow-undecidable-instances #-} {-# OPTIONS -fallow-overlapping-instances #-} {-# OPTIONS -fallow-incoherent-instances #-}, there's nothing stopping him/her, eh?
08:06:04 <mnislaih> I remember having heard dcoutts speak of 'newbies and exceptions slipping through handlers'
08:06:07 <shapr> mnislaih: Have you looked at the "quicker" section of the GHC manual?
08:06:24 <mnislaih> yeah, many times! but probably not with a nose for exceptions
08:06:36 <ndm> ihope: OPTIONS_GHC, if you don't mind :)
08:06:52 * mnislaih digs the ghc manual
08:06:59 <ndm> since Yhc is getting OPTIONS_YHC support
08:07:34 <ndm> @hoogle evaluate
08:07:35 <lambdabot> Control.Exception.evaluate :: a -> IO a
08:07:36 <lambdabot> Test.QuickCheck.evaluate :: Testable a => a -> Gen Result
08:07:41 <dmhouse> I love Haskell advocacy.
08:07:51 <ndm> mnislaih: call evaluate on whatever it is, and that should fix it up
08:08:00 <ndm> call evaluate inside the exception handler
08:08:22 <mnislaih> I've used that trick in some places, but what if  the thing  is already in IO ?
08:08:26 <ihope> So there's no -fallow-everything?
08:08:56 <dmhouse> Someone said something innocent like 'I hate segfaults' in #kubuntu, so I responded with 'You should all used statically typed languages!'
08:09:29 <ihope> -fallow-untypable-expressions, -fallow-segfaults...
08:10:05 <ndm> -f-usec?
08:10:10 <greenrd> ihope: Also known as unsafeCoerce.
08:10:21 <edwinb> You can have enormous fun with unsafeCoerce...
08:10:28 <SamB> hey hey
08:10:43 <SamB> it is called unsafeCoerce# -- get it right!
08:10:49 <ihope> Oh, yeah.
08:12:10 <emertens> How is Haskell not getting segfaults related to static-typing?
08:12:38 <ndm> emertens: its one of the guarantees of static typing
08:12:56 <ndm> of course, it assumes a naieve implementation of prodding things
08:13:18 <emertens> so you can segfault in ruby?
08:13:28 <edwinb> A well implemented dynamically typed language won't segfault either
08:13:35 <edwinb> It might crash, but so might haskell programs...
08:13:43 <edwinb> so I'm not sure how relevant it is...
08:13:52 <ndm> its not entirely relevant, unless you compare to C
08:13:53 <psi> c has static typing and it can seg fault
08:14:00 <emertens> I was under the impression that it depended on if the language was a "managed" language or not
08:14:02 <ndm> which some might consider to be a bug in C, rather than a feature in Haskell
08:14:17 <dmhouse> C isn't very type-safe.
08:14:20 <ndm> you could write a version of C that didn't crash
08:14:27 <ndm> its a case of how mcuh you pay for it
08:14:31 <dmhouse> C is statically checked but not very well. :)
08:14:37 <ndm> in Haskell its a cheap property, because of the static typing
08:14:46 <Lemmih> emertens: "managed"?
08:14:55 <edwinb> dereference a null pointer isn't that much different from taking the head of an empty list, in terms of what you're program's going to do next... (crash)
08:15:04 <edwinb> your program, even (ouch)
08:15:53 <emertens> Lemmih: I was jus thinking how C arrays are just memory access, and teh segfault is the environments way of telling you that you tried to access memory that wasn't yours
08:16:10 <ndm> shapr: win32 uses have to do that, but in mingw
08:16:15 <emertens> Lemmih: while languages where the arrays are bounds checked and whatnot
08:16:29 <emertens> would give you a more specific error
08:17:01 <musasabi> emertens: one can use unsafe features in Haskell to get segfaults, or compiler bugs.
08:17:29 <ndm> or GC bugs, if you can find the right ones :)
08:17:36 <SamB> also, often a NULL pointer was returned from a library function that failed, and in Haskell it would give a nice exception...
08:17:37 <emertens> musasabi: I'm not arguing that Haskell is immune
08:17:51 <musasabi> like "poke nullPtr True"
08:18:04 <emertens> musasabi: I was initially questioning if static typing protected from the same class of errors
08:18:06 <SamB> but that isn't very common
08:18:30 <dmhouse> But you use pointers a lot less in Haskell than you do in C.
08:18:36 <edwinb> depends how strong your static type system is
08:18:49 <emertens> edwinb: you mean like epigram?
08:18:55 <SamB> and yeah, the less-frequent pointer usage makes finding pointer misuse easier
08:19:02 <musasabi> emertens: I think GC instead of using pointers + manual memory allocation is the crucial thing for fewer segfaults.
08:19:12 <dmhouse> Things like trying to dereference a null pointer, or accessing an array out of bounds are eventual aims of the static checker.
08:19:22 <edwinb> emertens: More that Haskell's type system gives you stronger guarantees than C's, but yes, you could go all the way to Epigram...
08:19:41 <Stinger_> and what is Epigram
08:19:41 <emertens> musasabi: agreed... but you can still walk off the end of a haskell array just as easily
08:19:50 <Stinger_> in a sentence or less :)
08:20:00 <musasabi> emertens: the normal array ops check for valid indexes.
08:20:20 * ihope attempts to make a ZFC theorem prover with Haskell
08:20:22 <emertens> musasabi: and computation stops, unless you catch the error
08:20:30 <emertens> musasabi: can you catch a segfault signal?
08:20:34 <edwinb> Stinger_: http://www.e-pig.org/
08:20:36 <lambdabot> Title: Epigram
08:21:34 <musasabi> emertens: one can catch signals in GHC Haskell.
08:22:03 <musasabi> http://okmij.org/ftp/Haskell/types.html#branding has an approach for statically validating array indexes on type level for many interesting problems.
08:22:04 <lambdabot> Title: Haskell Programming: Types
08:22:05 <emertens> musasabi: Oh, I just meant in general, could the signal be handled (in a UNIX environment)
08:22:16 <emertens> but if GHC can
08:22:24 <emertens> then obviously it can be handled
08:31:16 <shapr> vincenz: Think you'll be at AngloHaskell?
08:33:39 <ihope> Apparently "Bool :-P" is a valid type.
08:33:53 <shapr> @type True :: Bool :-P
08:33:58 <lambdabot> Not in scope: type constructor or class `:-'
08:33:59 <lambdabot>  
08:33:59 <lambdabot> <interactive>:1:15: Not in scope: type constructor or class `P'
08:34:06 <Lemmih> Heh.
08:34:42 <dmhouse> Well, I guess :-P is a valid type, so if Bool was a unary tycon... :)
08:35:01 <Lemmih> Looks like a type for (Succ?)SuccZeroth.
08:35:35 <Igloo> :- is an infix type constructor there, so Bool is fine as-is
08:37:00 <dmhouse> Igloo: it is?
08:37:05 <dmhouse> Oh, right, of course.
08:37:35 <ihope> type a :-p = a
08:37:38 <ihope> :-)
08:50:16 <emertens> Can one become *addicted* to sunflower seeds...?
08:51:01 <java-or-no> how is haskell different than java?
08:51:10 <mnislaih> Lemmih: under which conditions can revertCAFs be called ?
08:51:37 <mnislaih> It's not working for me
08:52:35 <emertens> java-or-no: java is a strict, imperative, object-oriented language
08:52:50 <emertens> java-or-no: haskell is a lazy, pure, functional language
08:55:15 <Lemmih> mnislaih: Why are you using revertCAFs?
08:56:17 <mnislaih> I am using exceptions to interrupt a debugging task
08:56:44 <mnislaih> I am playing with this idea of exceptions
08:57:07 <mnislaih> I think a CAF can end up with a wrong value because of this
08:57:52 <psi> > last (reverse [1..])
08:57:58 <lambdabot> Terminated
08:58:02 <blackhawkblade> someone here who speaks german
08:58:03 <psi> bah
08:58:19 <dmhouse> blackhawkblade: there are a few, what do you need done?
08:58:49 <Lemmih> {-# RULES "last/reverse" forall x. last (reverse (enumFrom x)) = x #-}
08:59:31 <blackhawkblade> i gonna write an exam tomorrow about haskell and i have a few questions.. some facts are not clear to me..
09:00:10 <shapr> java-or-no: Does that help any?
09:00:30 <mnislaih> Lemmih: what do you think of this exceptions idea?
09:00:38 <psi> Lemmih: would that make last (reverse (enumFrom 1)) return 1?
09:00:54 <blackhawkblade> dmhouse do u speak german?
09:00:56 <mahogny> blackhawkblade: if you use CS terminology, then by rule 50% will be english no matter which language you pretend to use :)
09:01:03 <Lemmih> psi: In theory, yes. Not sure if it works (:
09:01:15 <Lemmih> mnislaih: I don't quite understand.
09:01:23 <psi> what does the "last/reverse" bit mean?
09:01:29 <blackhawkblade> mahogny but its easier for me to ask in german ^^
09:01:40 <blackhawkblade> my english is not so good
09:01:55 <mahogny> blackhawkblade: baaah. if you do CS then you need to train your english
09:02:00 <dmhouse> blackhawkblade: try asking in German.
09:02:20 <ski> psi : naming of the rule
09:02:21 <Lemmih> psi: That's the name of the rule. GHC use it to give you stats about which rules has fired.
09:02:32 <psi> aha
09:02:57 <mnislaih> Lemmih: imagine there is a breakpoint inside a loop, and you want to break out
09:03:43 <mnislaih> in order to stop the debugging session, there is a new command ':stop' (it's not that immediate in fact) implemented with exceptions
09:04:11 <mnislaih> it throws a DynException, which surfaces to the external ghci, gets captured, and evaluation of the expression stops
09:04:11 <Lemmih> ah
09:04:37 <Lemmih> mnislaih: That sounds nice.
09:04:43 <psi> Lemmih: is it a ghc 6.5 thing?
09:04:51 <mnislaih> ok. the problem is that a CAF can be assigned a wrong value because of this. I am calling revertCAFs in the external exception handler, but it is not helping
09:05:47 <Lemmih> psi: No, it's also implemented in ghc-6.4.
09:06:39 <java-or-no> ?
09:06:42 <psi> it doesn't seem to work
09:06:54 <Lemmih> psi: You need -fglasgow-exts.
09:07:06 <psi> yes, i tried that
09:08:08 <blackhawkblade> dmhouse query..
09:08:51 <kowey> blackhawkblade: you know you have to register with NickServ to /query? (i ran into that once)
09:09:12 <blackhawkblade> ohmg
09:09:18 <blackhawkblade> no i know not ^^
09:09:24 <dmhouse> blackhawkblade: ask in the channel anyway.
09:09:36 <Lemmih> psi: You also need -O.
09:10:02 <psi> yay! it works
09:10:22 <Lemmih> (it's a bit evil, though :)
09:10:44 <blackhawkblade> also in nem haskell programm oder skript kann man ja typklassen definieren Datentypen und Typen
09:11:03 <blackhawkblade> ich versteh nur nich so richtig bzw genau den nutzen von typklassen.. das kam in den vorlesungen nie so raus..
09:11:46 <musasabi> Typeclasses are a way to implement polymorphism in Haskell.
09:12:09 <blackhawkblade> the only way?
09:12:44 <Philippa> depends what you mean by polymorphism
09:12:57 <dmhouse> ?type id -- no typeclasses here
09:12:59 <lambdabot> forall a. a -> a
09:12:59 <Philippa> they're the only "supported" way to do OO-style polymorphism
09:13:04 <dmhouse> ?type map -- or here
09:13:06 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
09:13:07 <Philippa> though there're other ways to encode it
09:13:21 <Philippa> (supported as in the language actively helps you out with it)
09:13:22 <musasabi> blackhawkblade: the only way to make a function behave in different fashion for different types.
09:13:42 <dmhouse> (I admit that id's something of a special case, but map is certainly polymorphic.)
09:14:00 <blackhawkblade> ok thx this helps me
09:14:30 <blackhawkblade> and about  Datentypen?
09:14:42 <Philippa> id and map have what's called parametric polymorphism - same kind of idea as C++ templates or Java generics
09:14:44 <java-or-no> managers piking java due o its popularity
09:15:01 <ski> (yay! haskell in deutch :)
09:15:21 <ski> (dmhouse : 'id' special case ?)
09:15:22 <dmhouse> ski: Deutsch ;)
09:15:30 <ski> arg
09:15:34 <shapr> java-or-no: Heard of the army of monkeys strategy?
09:15:44 <dmhouse> ski: id is the only non-bottom valued function universally quantified in its range.
09:16:12 <dmhouse> I.e. if you have f :: something -> a, where a isn't restricted by a typeclass, f either returns its argument or bottom.
09:16:29 <ski> dmhouse : by 'range' you mean 'codomain' ?
09:16:36 <dmhouse> Sure.
09:16:57 <ski> @type ($ 'a')
09:16:59 <lambdabot> forall b. (Char -> b) -> b
09:17:21 <ski> dmhouse : that doesn't apply ?
09:17:24 <dmhouse> Okay:
09:17:35 <java-or-no> hm
09:17:40 <java-or-no> whats that
09:17:42 <dmhouse> id is the only function :: a -> a that isn't const _|_.
09:17:53 <shapr> java-or-no: For a quick taste of Haskell, check out http://www.haskell.org/hawiki/HaskellDemo
09:17:53 <java-or-no> something about skaespere
09:17:54 <lambdabot> Title: HaskellDemo - The Haskell Wiki
09:18:14 <shapr> java-or-no: No, I mean that managers want to hire people who are easily replaced. That's the Java strategy.
09:18:23 <ski> dmhouse : ok  (but i don't see what's so special about that)
09:18:31 <blackhawkblade> dmhouse in our lessons we talked about "maybe"  but i never saw a program using maybe may someone have a simple eyam
09:18:38 <blackhawkblade> example for me using maybe?
09:19:06 <shapr> I use Maybe to represent failure of a computation.
09:19:08 <SamB> > M.fromList
09:19:08 <Philippa> safeHead [] = Nothing
09:19:08 <dmhouse> safeHead :: [a] -> Maybe a
09:19:09 <lambdabot>  Add a type signature
09:19:13 <dmhouse> safeHead [] = Nothing
09:19:15 <Philippa> safeHead (x:xs) = Just x
09:19:21 <emertens> > maybe [] id (Just [1])
09:19:22 <dmhouse> Yeah, that. :)
09:19:23 <lambdabot>  [1]
09:19:31 <emertens> > maybe [] id Nothing
09:19:33 <lambdabot>  Add a type signature
09:19:38 <shapr> > Data.List.elemIndex 'w' "blackhawkblade"
09:19:39 <emertens> > maybe [] id Nothing :: [Int]
09:19:39 <lambdabot>  Just 7
09:19:41 <lambdabot>  []
09:19:41 <Philippa> if you hand safeHead the empty list, you get Nothing back
09:19:44 <shapr> > Data.List.elemIndex 'X' "blackhawkblade"
09:19:44 <ski> @type lookup
09:19:46 <lambdabot>  Nothing
09:19:46 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
09:19:48 <dmhouse> safeHead is a function that is like head, but returns Nothing on an empty list instead of erroring.
09:20:13 <dmhouse> If you have a function that might fail, like safeHead (fails on an empty list), then it could have a Maybe a result type.
09:20:44 <dmhouse> elemIndex, find and lookup all have Maybe a result types because they can fail by not finding what they're looking for.
09:20:57 <SamB> > let mapping = M.fromList [(1,2),(3,4)] in map (maybe 0 id . M.lookup) [1..4]
09:20:58 <lambdabot>    Expecting a function type, but found `b'
09:20:58 <lambdabot>    Expected type: a1 -> Mayb...
09:21:03 <SamB> hmmhmm
09:21:13 <SamB> > let mapping = M.fromList [(1,2),(3,4)] in map (maybe 0 id . M.lookup mapping) [1..4]
09:21:16 <lambdabot>     add an instance declaration for (Num (Data.Map.Map (Data.Map.Map k a) ...
09:21:21 <SamB> hmm...
09:21:36 <SamB> @type M.lookup
09:21:37 <lambdabot> Couldn't find qualified module.
09:21:37 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.\\)?
09:21:38 <blackhawkblade> not so fast ^^ :-D
09:21:42 <SamB> @type DAta.Map.lookup
09:21:44 <lambdabot> Couldn't find qualified module.
09:21:44 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.\\)?
09:21:48 <SamB> @type Data.Map.lookup
09:21:49 <lambdabot> forall a (m :: * -> *) k. (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
09:22:04 <dmhouse> > let mapping = M.fromList [(1,2),(3,4)] in map (maybe 0 id . flip M.lookup mapping) [1..4]
09:22:05 <SamB> > let mapping = M.fromList [(1,2),(3,4)] in map (maybe 0 id . (`M.lookup` mapping) [1..4]
09:22:05 <lambdabot>  [2,0,4,0]
09:22:06 <lambdabot>  Parse error
09:22:14 <SamB> oh oops.
09:22:16 <SamB> forgot paren
09:25:29 <ihope> instance (Exists (a -> b), Exists a) => Exists b where example = example example
09:25:35 <ihope> Evil, aye?
09:26:00 <blackhawkblade> o.0o
09:26:04 <blackhawkblade> i am confused ^^
09:26:12 <dmhouse> Don't worry about ihope.
09:26:15 <bejs> ihope: Yeah, if you type it three times you get named demons
09:27:03 <shapr> Didn't I see that in a movie?
09:27:09 <shapr> Klaatu, berata, harrumph?
09:27:45 <ihope> No, it was naktu... or something.
09:28:20 <ihope> Klaatu barada nikto!
09:28:24 <dmhouse> What's everyone's favourite variable naming style? lots_of_underscored, camelCase, or lisp-tastic?
09:28:42 <shapr> I'm not picky.
09:28:51 <musasabi> most people use camelCase and some use lots_of_underscores
09:28:55 <bejs> The one that's already there
09:29:02 <dmhouse> I don't mean in Haskell, I mean in general.
09:29:10 <Philippa> I'd rather the lisp style than the underscores, but I tend towards camelCase
09:29:21 <dmhouse> bejs: yeah, I tend to take that attitude, but do you not have a preference?
09:29:24 <bejs> usually_with_underscores, but camelCase in Haskell 'cause everyone else does it.
09:29:25 <Philippa> the underscores is hardest to read IMO
09:29:49 <dmhouse> I think camelCase is pretty hard to read when you have a long name.
09:29:57 <bejs> iFindThisIsHardToReadQuicklyByScanning
09:30:04 <dmhouse> itsVeryHardForTheEyeToPickOutWhereTheBreaksAre
09:30:05 <shapr> Seen glasses-mode ?
09:30:13 <bejs> but_i_can_tell_the_words_apart_with_this
09:30:19 <dmhouse> this-on-the-other-hand-is-nice-and-easy, I think Lisp-style is my favourite.
09:30:30 <dmhouse> (Also it saves you shifting to hit the underscore key.)
09:30:36 <bejs> lisp-mode-when-it's-allowed
09:30:44 <blackhawkblade> maybe is part of prelude?
09:30:49 <emertens>  +His-i$_t|-|e_8EsT
09:30:58 <bejs> oh god
09:31:07 <emertens> @elite butICanTellTheseWordsApart
09:31:08 <lambdabot> butICaNt31lT|-|ESE\/\/oRd54PArT
09:31:13 <emertens> just do it like that
09:31:36 <psi> or'like'this
09:31:41 <shapr> I use hippie-expand to type variables after I've typed them the first time. That also helps me keep the same spelling.
09:31:53 <emertens> hippie-expand?
09:32:07 <bejs> autocomplete, basically.
09:32:15 <bejs> Unless there's a difference I'm not sure of.
09:32:35 <shapr> hippie-expand is a parameterizable autocomplete.
09:32:56 <blackhawkblade> dmhouse
09:33:06 <bejs> Take pity on us plain simple dabbrev-expand folks
09:33:22 <shapr> hippie-expand really is better than dabbrev-expand, especially since you can call dabbrev-expand from hippie-expand.
09:33:54 <bejs> oh, nice
09:34:22 * mnislaih is a sucker for hippie-expand
09:34:34 <SamB> me hopes the "uni" package will build with such a recent GHC
09:35:39 <SamB> er, s|me|/me|
09:37:14 <Philippa> I find long sentances hard to read in camelCase, but I tend to find that a hint that my names're getting too long
09:38:01 * edwardk waves ello.
09:38:04 <emertens> when you stick with single letter names, you don't have to worry about all of that stuff
09:38:14 <SamB> hahaha
09:38:22 <SamB> but then you might as well be programming in basic ;-)
09:38:30 * shapr boings
09:38:35 <edwardk> and what happens when you run out of variable names? =)
09:38:42 <bejs> Go into other character sets
09:38:46 <edwardk> woot
09:38:47 <bejs> µ, ŋ, ł etc.
09:38:48 <edwardk> unicode
09:38:54 <shapr> SamB: Sometimes single letter vars are perfect. There are times when it's the pattern of the code that's important.
09:38:54 <SamB> edwardk: you stuff things into arrays, duh!
09:38:58 <edwardk> heh
09:39:00 <SamB> shapr: sure
09:39:02 <emertens> edwardk: if you need more variables, use one of the as a list
09:39:06 <ihope> @djinn (a -> b) -> (a -> Not b) -> Not a
09:39:06 <Philippa> yeah, I have a lot of x and xs in my code
09:39:06 <lambdabot> f a b c = b c (a c)
09:39:08 <SamB> but he said "stick with single letter names"
09:39:12 <SamB> not "use single letter names"
09:39:14 <edwardk> now i am definitely reminded of commodore 64 basic =)
09:39:19 <shapr> Ok, I see your point.
09:39:34 * shapr has that unicycling urge
09:39:58 <emertens> @type Not
09:40:00 <lambdabot> Not in scope: data constructor `Not'
09:40:18 <SamB> I myself like one or two letter var names for a lot of my variable
09:40:18 <emertens> @kind Not
09:40:20 <lambdabot> Not in scope: type constructor or class `Not'
09:40:22 <SamB> er, variables
09:40:24 <edwardk> heh i use lots of single letter variables names... but then thats primarily because javascript variable access time is proportional to variable name length.
09:40:37 <edwardk> then again i also automated the process of generating the short names so its not so bad
09:40:39 <SamB> edwardk: what, no pre-hashing?
09:41:02 <SamB> no interning?
09:41:02 <edwardk> it can be a pretty big performance hit, and nope, none i can see.
09:41:17 <edwardk> interning happens in spidermonkey, but the length degradation is still noticable.
09:41:28 <SamB> really?
09:41:46 <shapr> Cool, we're nearly at the #haskell high water mark again.
09:41:58 * SamB wonders if Python used to have that problem. Suspects it did.
09:42:00 <dcoutts_> :-)
09:42:00 <edwardk> i wound up building an atomizer that went and atomized all of the identifiers you didn't explicitly tell it not to. the performance jump was impressive.
09:42:21 <SamB> edwardk: what is "atomize"?
09:42:30 <shapr> 224 clients on #haskell, one more for the high water mark!
09:42:31 <SamB> and if it is what it sounds like, why doesn't the JS compiler already do it?
09:42:31 <edwardk> by atomizing, i mean i just replaced them from a short variable set, a,b,c,d....z,a1,...az,...
09:42:41 <SamB> oh, nevermind then
09:42:53 <edwardk> nothing earth shaking. poor mans interning =)
09:43:45 <edwardk> anyways a 20% speed jump and good compression gains made it worth the 3 hour coding spree to write the atomizer
09:43:51 <edwardk> since it just recycled my parser anyways.
09:44:49 <dcoutts_> hia SyntaxNinja
09:44:55 <dcoutts_> @seen JaffaCake
09:44:56 <lambdabot> JaffaCake is in #haskell. I last heard JaffaCake speak 3 hours, 32 minutes and 43 seconds ago.
09:45:34 <edwardk> heh, well, for a split second i saw syntaxninja join before chessguy quit, so you had your 225 shapr =)
09:45:52 <blackhawkblade> in what way does maybe help in errors???
09:46:03 <shapr> edwardk: true :-)
09:46:23 <shapr> blackhawkblade: How do represent lookup failure in Java?
09:46:24 <edwardk> shapr: ever figure out that _stub bug?
09:46:34 <shapr> edwardk: Yeah, but I didn't finish fixing it.
09:47:00 <shapr> Anyway, I just taught myself a lot about GHC, JaffaCake found the bug.
09:47:10 <dcoutts_> blackhawkblade, it's an alternative to returning NULL or thowing an exception
09:47:18 * edwardk nods.
09:47:21 <dcoutts_> and it's more explicit than either of those techniques
09:47:28 <shapr> hiya SyntaxNinja!
09:47:35 <shapr> edwardk: GHC is much easier to hack on than I expected.
09:47:48 <blackhawkblade> in what way it is an alternative ? it just returns nothing instead of error or i am wrong?
09:48:02 <dcoutts_> in C people have to document if NULL is a permissable value, in Haskell you know from the type if there is a failure case.
09:48:08 <shapr> Once I started talking to other GHC hackers, it went from easy to very easy.
09:48:11 <dcoutts_> blackhawkblade, exactly
09:48:14 <shapr> I'd still like to see more docs though.
09:48:19 <SyntaxNinja> howdy
09:48:22 <edwardk> i poked around the internals trying to figure out how bad it would be to add back monad comprehensions, then i sneakily walked away, pretending i didn't see what i saw
09:48:38 <shapr> I keep meaning to write up a thousand foot view of GHC. I'll have time to do that on the trip I suspect.
09:49:14 <dcoutts_> shapr, here's a cunning representation optimisation trick that one might be able to do: optimise the representation of Maybe to remove one level of indirection
09:49:22 <shapr> ?
09:49:34 <dcoutts_> shapr, have the Nothing case be the 0 pointer
09:49:45 <blackhawkblade> hum... but in my opinion an error message is as good as nothing .. so y is maybe better? sry .. i know i am stupid ^^
09:49:53 <dcoutts_> shapr, and the Just case point directly to the x in Just x
09:50:01 <shapr> Is this is in the applications section of your fusion paper? :-)
09:50:07 <dcoutts_> so no extra Just indirection
09:50:18 <dcoutts_> shapr, no just a discussion with a colleague, F# does it apparently
09:50:24 <shapr> Makes sense.
09:50:26 <dcoutts_> it makes Maybe free
09:50:36 <shapr> Sort of like newtype
09:50:39 <dcoutts_> no additional allocation
09:50:48 <dcoutts_> (though still a comparision)
09:51:05 <dcoutts_> to distinguish the 0 case
09:51:15 <zarvok> have to watch out though - is the 0 pointer used to represent anything else that could be confused? A friend of mine had a problem recently where he made that optimization on a compiler he was using, but it turned out the empty list had the same representation
09:51:42 <dcoutts_> and it's not a Maybe only hack, any data type of the form: data T = A | B | ... | Z x
09:51:55 <Stinger_> strong typing would prevent that no?
09:52:06 <dcoutts_> zarvok, yeah, that's no problem because we know the types
09:52:34 <blackhawkblade> [18:49] blackhawkblade: hum... but in my opinion an error message is as good as nothing .. so y is maybe better? sry .. i know i am stupid ^^
09:52:36 <zarvok> hmm, fair enough, though the language he was using had strong types, so I wonder what the exact error was then
09:52:37 <kowey> blackhawkblade: the difference is that when you get Nothing, you can deal with it when writing your program
09:52:52 <ski> dcoutts_ : how's values of type 'Maybe (Maybe a)' represented ?
09:52:55 <kowey> blackhawkblade: whereas with an error message, your user ends up having to deal with it, which is bad
09:53:02 <Stinger_> ok was looking through some of those generic haskell papers, am I to assume the cast call will be optimized away in the general case?
09:53:32 <dcoutts_> ski, pointer (or 0) to a heap box containing a pointer (or 0) to a
09:53:51 <blackhawkblade> mhm ok...
09:54:00 <blackhawkblade> thx :-d
09:54:23 <ski> dcoutts_ : so it's not generally 'newtype'-like, then ..
09:54:29 <shapr> I've heard that exceptions should be for exceptional cases.
09:54:42 <blackhawkblade> is using trees in haskell popular? and effective?
09:54:52 <dcoutts_> ski, no it's still a pointer to a boxed object
09:55:04 <Philippa> I suspect the most popular sort's abstract syntax trees. Or possibly the behind-the-scenes implementation of Data.Map
09:55:14 <Philippa> it works, though slightly differently with immutable trees
09:55:17 <SamB> blackhawkblade: yes
09:55:31 <dcoutts_> ski, but we remove one indirection, instead of a pointer to a box containing a pointer to a value we have merely a pointer (or 0) to a value
09:55:47 <blackhawkblade> only to sort or in other ways too?
09:56:07 <SamB> not only to sort but also for mappings
09:56:21 <ski> dcoutts_ : oh, only the top-level indirection is removed, ok
09:56:26 <dcoutts_> ski, right
09:56:45 <dcoutts_> we change a double indirection to a single indirection
09:56:56 <ski> or a triple to a double, etc
09:56:58 <blackhawkblade> can u show me a little programm which is using a tree? :-d
09:57:09 <SamB> lets try an AST
09:57:12 <dcoutts_> ski, I don't think so. just 2 to 1
09:57:27 <SamB> @google site:haskell.org lambda calculus interpreter
09:57:29 <lambdabot> http://www.haskell.org/pipermail/haskell/2006-June/018077.html
09:57:30 <lambdabot> Title: [Haskell] Announce: Lambdabot 4.0
09:57:33 <SamB> hmm.
09:57:33 <ski> dcoutts_ : why not ?
09:57:40 <SamB> @google site:haskell.org/haskellwiki lambda calculus interpreter
09:57:40 <dcoutts_> ski, the Maybe (Maybe a) is 2->1 twice
09:57:43 <lambdabot> http://www.haskell.org/haskellwiki/User:EndreyMark
09:57:43 <lambdabot> Title: User:EndreyMark - HaskellWiki
09:57:49 <SamB> @google site:haskell.org/hawiki lambda calculus interpreter
09:57:52 <lambdabot> http://www.haskell.org/hawiki/DerekElkins
09:57:52 <lambdabot> Title: DerekElkins - The Haskell Wiki
09:57:57 <ski> dcoutts_ : twice ?
09:57:59 <dcoutts_> but I don't think it generalised beyond just using it multiple times
09:58:13 <SamB> @google site:haskell.org short examples
09:58:16 <lambdabot> http://www.haskell.org/hawiki/ShortExamples
09:58:16 <lambdabot> Title: ShortExamples - The Haskell Wiki
09:58:47 <dcoutts_> ski, ah, I see what you mean, you want me to flatten Maybe (Maybe a) to A | B | C a
09:58:53 <dcoutts_> ski, no, I'm not proposing that
09:59:02 <ski> no, i didn't mean that
09:59:04 <edwardk> hrmm
09:59:16 <musasabi> shapr: there seem to be lots of places to change allways. (with separate hssyn/core/iface data types etc)
09:59:25 <edwardk> we track the types no, so why can't it remove all of those levels of indirection? =)
09:59:35 <ski> (btw, with laziness, it becomes more complicated, i think)
09:59:52 <dcoutts_> ski, I don't think so, it can still be a pointer to a closure
09:59:54 <SamB> pretty much any interesting program has some kind of tree structure going on somewhere
10:00:05 <dcoutts_> we're not actually unboxing anything, so not adding strictness
10:00:17 <SamB> well, if it is big enough
10:00:25 <shapr> musasabi: Yes, GHC is quite active.
10:00:26 <dcoutts_> hmm, or maybe we are, hmm
10:00:38 <SamB> @google lambdabot lambda.hs
10:00:40 <ski> hm, so just '0' if it's already been forced to 'Nothig', then  ?
10:00:48 <lambdabot> http://paste.lisp.org/display/19180
10:00:48 <lambdabot> Title: Paste number 19180: Lambdabot Compilition output
10:00:53 <SamB> nope
10:00:55 <dcoutts_> ski, right, so yes that could be a problem
10:01:27 <dcoutts_> ski, because then what's the representation of a (Maybe a) that we've not forced yet...
10:01:41 <dcoutts_> so yes, you're right, it only works for !(Maybe a)
10:01:49 <ski> dcoutts_ : btw, the melbourne mercury compiler does represent the first few constant constructors with tag bits in the pointer
10:02:07 <SamB> blackhawkblade: could you be a little more specific about what you mean?
10:02:18 <SamB> do you have any particular sort of tree in mind?
10:02:22 <ski> dcoutts_ : i think it could work for 'Maybe a', too ..
10:02:37 <dcoutts_> ski, ok, I'm less sure now that I was initially :-)
10:02:44 <shapr> blackhawkblade: I like to make trees like this: data Tree a = Nil | Node (Tree a) a (Tree a) deriving Show
10:02:53 <dcoutts_> ski, could it, without losing sharing?
10:03:09 <blackhawkblade> shapr what can u do with this kind of tree`?
10:03:21 <emertens> anything that can be done with a binary tree
10:03:22 <shapr> Anything you want.
10:03:24 <blackhawkblade> i know this.. but we never used it in our lessons at university
10:03:31 <shapr> An empty tree is Nil
10:03:42 <ski> dcoutts_ : hm .. i was thinking the closure could be updated, and if it's known locally that the value is forced, it could be represented as '0' additionally
10:03:44 <SamB> my latest program contains about four lines dealing with trees directly
10:03:45 <shapr> A tree with Int is myTree = Node Nil 1 Nil
10:03:57 <SamB> data Tree a = Tree [(a, Tree a)]
10:03:57 <SamB> breadthFirst (Tree xs) = map fst xs ++ concatMap (breadthFirst . snd) xs
10:03:57 <SamB> depthFirst   (Tree xs) = concatMap (\(x,tree) -> x:depthFirst tree) xs
10:03:57 <SamB> stateTree state = Tree (map (id &&& stateTree) (statesAfter state))
10:04:15 * shapr goes unicycling
10:04:23 <SamB> now, that fourth line is application specific, but the other three aren't really
10:04:34 <SamB> they may be inefficient though ;-)
10:05:25 <blackhawkblade> ^^
10:05:33 <SamB> hmm, looking at depthFirst, I think I understand why my program seems to be running in pretty much constant space ;-)
10:05:51 <blackhawkblade> @shapr y did u add deriving show?
10:05:52 * lambdabot beats up y did u add deriving show?
10:06:02 <SamB> huh?
10:06:12 <SamB> @spell shapr
10:06:14 <lambdabot> Shapiro Sharp sharp shape shaper
10:08:32 <Cale> SamB: You have the opposite of a space leak? :)
10:08:34 <ski> blackhawkblade : that tells haskell that we want to be able to print trees (with a standard syntax)
10:09:09 <SamB> Cale: what is the opposite of a space leak?
10:09:12 <blackhawkblade> ah  thx u make several things much clearer to e..
10:09:14 <blackhawkblade> me
10:09:58 <Cale> SamB: unexpectedly having your program take less memory than you thought it would?
10:10:37 <SamB> well the main reason I was expecting worse was that I didn't remember what I had written for depthFirst...
10:13:40 * mux creates and combines stupid arrows that just do (+1), and wonders what to do next
10:13:42 <SamB> now really depthFirst doesn't use constant space, but it uses space proportional to the nesting level, I think...
10:13:50 <edwardk> gah. type level programming can be verbose
10:14:09 <blackhawkblade> how can i print a tree?
10:14:10 <edwardk> class XI a b | a -> b; instance ( TIsBool a b , TIsNormalForm a d , TOr b d T , TIf a T (I F) c , TIf b c (I a) e , TMSBs e a) => XI
10:14:10 <edwardk>  a e   seems to be the shortest way i can express something
10:14:42 <edwardk> er and the class XI a b | a -> b, b -> a should be the fundeps
10:14:48 <edwardk> its the symmetry that makes that long
10:15:37 <ski> blackhawkblade : try evaluating an expression that returns a tree
10:16:11 <emertens> Why are get and put fuctions of a MonadState rather than simply being functions that operate on State
10:16:39 <Cale> emertens: because there are other state monads you want to use them with?
10:16:53 <SamB> such as StateT
10:16:57 <Cale> In particular, you want them to work on monads which have had StateT applied
10:16:59 <emertens> @instances MonadState
10:17:00 <lambdabot> s (ContT r m), s (ErrorT e m), s (RWS r w s), s (RWST r w s m), s (ReaderT r m), s (State s), s (StateT s m), s (WriterT w m)
10:17:05 <emertens> That makes se
10:17:07 <emertens> nse
10:17:09 <edwardk> yeah i wound up slapping together a state monad instance myself because the monad i was working in had a ready place to throw the state
10:17:10 <emertens> nvm
10:17:44 <edwardk> in fact its all the functions that don't work off the dictionaries from the prelude, etc. that are headaches =)
10:18:05 <Cale> In general, when you have a monad transformer, there's a class which goes with it, specifying the special operations that the transformer lends to monads
10:18:25 * edwardk <<3 StateT
10:18:48 <Cale> Not just less than 3, but much less.
10:18:53 <edwardk> yep
10:18:58 <edwardk> i'm only one =)
10:21:32 <ski> blackhawkblade : e.g. if you put that definition by shapr in a module, and load it (e.g. into hugs or ghci), you can then enter 'Node Nil 2 (Node Nil 3 Nil)'
10:27:12 <ihope_> I can't give "data MyNot a = forall b. (a -> b) -> (a -> MyNot b) -> MyNot a", can I?
10:27:37 <ihope_> That is, I can't give that to Djinn...
10:33:34 <ski> don't think it understands the 'forall', no
10:35:30 <jtal> anyone know, when I'm trying to explicitly declare type of a function in ghci, do I need a special command first?
10:35:40 <jtal> (as I need 'let' in ghci)
10:36:07 <kpreid> jtal: let f x = g x :: type
10:36:13 <ski> let foo : X -> Y; foo x = ..x..
10:36:19 <ski> s/:/::/
10:36:26 <kpreid> er, that too
10:47:59 <jtal> ah! I have to do the definition at the same time. thanks
10:52:53 <ihope_> > let id :: Int -> Int in id "foo"
10:52:54 <lambdabot>  Not in scope: `id'
10:52:58 <ihope_> Uh?
10:53:23 <ihope_> > let id x = x in let id :: Int -> Int in id "foo"
10:53:23 <lambdabot>  Misplaced type signature: id :: Int -> Int
10:54:14 <Igloo> You have to give the definition with the type signature
10:54:23 <Igloo> > let id :: Int -> Int; id x = x in id "foo"
10:54:24 <lambdabot>  Couldn't match `Int' against `[Char]'
10:54:36 <Igloo> > let id :: Int -> Int; id x = x in id 5
10:54:38 <lambdabot>  5
10:56:00 <jtal> wow, same question within 5 minutes of eachother
11:02:34 * ihope_ sees if his driftless clock will accurately tick every picosecond
11:02:52 <ihope_> If it were to tick a thousand times every processor cycle...
11:04:29 <ihope_> Nope, not that accurate.
11:07:33 <ihope_> So given "newtype Not a = forall b. ConsNot ((a -> b) -> (a -> Not b) -> Not a)", is there a total Not (Not a) -> a?
11:11:15 <ihope_> > let (!) x = product [1..x] in (3!)
11:11:16 <lambdabot>  add an instance declaration for (Num (t -> t1), Enum (t -> t1))
11:11:16 <lambdabot>   In the ...
11:11:28 <ihope_> @type let (!) x = product [1..x] in (3!)
11:11:29 <lambdabot> forall t t1. (Num (t -> t1), Enum (t -> t1)) => t -> t1
11:11:43 <ihope_> @type let (!) x = product [1..x] in (!)
11:11:44 <lambdabot> forall a. (Num a, Enum a) => a -> a
11:11:51 <ihope_> ...What?
11:12:33 <ihope_> (x!) is not always the same as (!) x, then?
11:17:48 <bejs> Obviously people weren't too fond of that
11:21:17 <kpreid> @type let (!) = undefined in (!)
11:21:19 <lambdabot> forall a. a
11:21:36 <kpreid> @type let (!) = undefined in (undefined!)
11:21:37 <lambdabot> forall t t1. t -> t1
11:21:50 <kpreid> @type (x!)
11:21:51 <lambdabot> Not in scope: `x'
11:22:00 <kpreid> @type (undefined `undefined`)
11:22:01 <lambdabot> forall t t1. t -> t1
11:22:35 <kpreid> ihope_: apparently currying implies a 2-ary function
11:22:39 <emertens> the factorial of 0 is 1, right?
11:23:00 <SamB> yeah
11:23:10 <ihope_> kpreid: sections, you mean?
11:23:20 <emertens> which means that factorial x = product (1:[2..x]) at best, right?
11:23:24 <kpreid> Er. Right, currying wasn't the right word.
11:23:30 <SamB> that isn't really the best way to do it
11:23:33 * kpreid doesn't know 'sections'
11:23:44 <SamB> > product []
11:23:46 <lambdabot>  1
11:23:51 <emertens> ahh
11:23:52 <SamB> anyway, you don't need the 1: ;-)
11:23:59 <SamB> but that wasn't my point
11:24:03 <Philippa> kpreid: (+1) is a section
11:24:08 <SamB> multiplying by 1 an extra time is not a big deal
11:24:26 <SamB> I'm pretty sure there are more efficient orders to do the multiplication in
11:24:34 <emertens> I wasn't worried about the extra 1
11:24:42 <emertens> I thought that product [] would be undefined
11:24:54 <emertens> i guess I don't use product much
11:24:55 <SamB> I was unsure myself ;-)
11:24:58 <SamB> I don't either
11:25:19 <SamB> actually, product is not very good anyway
11:25:33 <SamB> > product [1..100000]
11:25:35 <lambdabot>  out of memory (requested 2097152 bytes)
11:25:39 <SamB> hmm
11:25:44 <SamB> that isn't the problem I meant
11:25:56 <emertens> 100000 is a big number :)
11:25:59 <SamB> > product [200..10000]
11:26:02 <emertens> err ^ factorial
11:26:03 <lambdabot>  7217983358049805967379337789051194555552531231727181455534124376214434626026...
11:26:30 <ihope_> For all x, product x = product (1:x).
11:26:36 <SamB> yeah but I think that means it was running multiplying so high it couldn't fit the number in memory...
11:26:42 <ihope_> Therefore, product [] = product [1].
11:26:43 <SamB> er, s/running/
11:27:08 <emertens> product = foldl' (*) 1 ?
11:27:37 <emertens> > foldl' (*) 1 [1..6]
11:27:37 <SamB> is it really?
11:27:38 <lambdabot>  720
11:27:58 <emertens> looks right
11:28:10 <emertens> > foldl' (*) 1 []
11:28:11 <SamB> I thought that "foldl!' (*) 1" was what I thought it *ought* to be
11:28:12 <lambdabot>  1
11:28:19 <SamB> er, except for the stray !
11:28:45 <emertens> from what I've read, you should always use foldl' or foldr when possible
11:28:48 <SamB> I think it is just foldr (*) 1
11:29:08 <SamB> which is not the right way to do it considering that the majority of numeric types have strict (*)
11:29:43 <SamB> (probably *all* of the ones in the base library of GHC)
11:30:50 <ihope_> So what are foldl and foldr' for? :-)
11:31:13 <emertens> @type foldr'
11:31:15 <lambdabot> Not in scope: `foldr''
11:31:18 <emertens> yeah, that doesn't exist
11:31:31 <ihope_> Oh.
11:33:19 <SamB> ihope_: I have no idea!
11:33:36 <SamB> well, there is your answer about foldr'
11:33:46 <SamB> it *would* be kind of stupid
11:33:58 <SamB> wouldn't work on non-finite lists
11:34:04 <SamB> (or well on huge lists)
11:34:31 <emertens> i believed that foldl' and foldr are tail-recursive
11:34:37 <emertens> believe
11:34:46 <SamB> foldr ain't, and that is for sure
11:34:56 <SamB> but it isn't *supposed* to be
11:35:44 <SamB> but don't worry, it does not have the undesirable attributes associated with non-tail-recursive functions in Scheme and such
11:35:51 <SamB> because it *is* lazy
11:36:15 <SamB> or, at least, thats how it is to be used
11:36:22 * shapr boings
11:36:58 <emertens> how is foldr not tail recursive?
11:37:08 <ihope_> Um...
11:37:12 <SamB> well, it doesn't call itself in tail position?
11:37:23 <ihope_> Give me a tail recursive implementation of foldr, eh?
11:37:26 <emertens> foldr f z []            =  z
11:37:27 <emertens> foldr f z (x:xs)        =  f x (foldr f z xs)
11:37:27 <SamB> @type foldr
11:37:28 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
11:37:34 <SamB> oh, there you go
11:37:48 <SamB> saved me the effort of writing the second case myself ;-)
11:38:04 <emertens> nevermind
11:38:08 <SamB> notice how the tail call is to f?
11:39:17 <SamB> typically f will not be strict in its second argument
11:39:43 <SamB> in fact, if it *is*, you probably should be using foldl'...
11:39:45 <emertens> http://www.haskell.org/hawiki/StackOverflow
11:39:47 <lambdabot> Title: StackOverflow - The Haskell Wiki
11:39:51 <emertens> is what I read regarding this subject
11:39:55 <SamB> yeah
11:40:03 <SamB> that is why you shouldn't use foldl ;-)
11:40:43 <emertens> "The one-line summary for folds: if the binary operation is strict use foldl' otherwise use foldr. "
11:41:12 <SamB> we should petition for the removal of foldl
11:41:20 * xerox <3 foldl
11:41:29 <SamB> xerox: what for?
11:41:40 <SamB> or at least maybe taking it out of Prelude
11:41:41 <xerox> I always fold with that...
11:41:51 <SamB> The one-line summary for folds: if the binary operation is strict use foldl' otherwise use foldr.
11:41:51 <xerox> Dinner!
11:42:38 <SamB> and by "common newbie stack overflowing code" we mean "Prelude functions"?
11:43:08 <SamB> or maybe they use foldl in the prelude...
11:43:15 <eivuokko> Not all binops are assosiative.
11:43:19 <SamB> which is less newbie...
11:43:26 <SamB> eivuokko: quite right
11:44:45 <SamB> but lots of code that folds could be rewritten to fold the other way
11:44:59 <eivuokko> Anyway, if you ask me, folds could go Data.List.  I don't use them that often.  But when I do, I think I use foldr and foldl pretty much as often.
11:45:10 <SamB> hmm.
11:45:10 <emertens> eivuokko: what is an example of a non-associative binop that breaks this?
11:45:30 <SamB> well. you don't usually fold with div or /...
11:45:40 <SamB> probably because they aren't associative
11:45:41 <mahogny> octonions if nothing else
11:45:50 <SamB> mahogny: octonions...
11:46:04 <SamB> they aren't associative?
11:46:05 <eivuokko> Parsec.<|>, some wierd combinations of >>= and <<= spring to mind.
11:46:07 <emertens> subtraction isn't associative, but it works the same with foldl' and foldl
11:46:15 <SamB> <|> isn't associative?
11:46:22 <mahogny> samB: no. and it is a rather trivial exercise to invent your own nonassoc binop
11:46:29 <SamB> mahogny: well yeah
11:46:31 <eivuokko> SamB, First choice is taken if it matches.  If both match...
11:46:56 <SamB> associative means:
11:47:18 <emertens> a `op` (b `op` c) === (a `op` b) `op` c
11:47:25 <SamB> (x >< y) >< z = x >< (y >< z)
11:47:30 <Philippa> : isn't associative
11:47:39 <SamB> true enough
11:47:43 <Philippa> yet it's one of the 'classical' things to fold over a list
11:47:48 <ihope_> (->) isn't associative, and it's not commutative either.
11:47:49 <SamB> so maybe we do need foldl...
11:47:50 <emertens> foldl' vs foldl doesn't change the associativity
11:47:52 <Philippa> I still like the reverse-as-fold definition
11:47:57 <ihope_> Not that (->) is... you know.
11:48:00 <SamB> (->) isn't a binop...
11:48:14 <ihope_> It's a binary operation on types.
11:48:23 <zeeeee> hi all, i'm just starting out in haskell. critique of any kind on my first app would be greatly appreciated. http://rafb.net/paste/results/7ZCvWt22.html
11:48:27 <SamB> and, you know, I'm fairly sure the typesystem is not lazy...
11:48:59 <SyntaxNinja> is there a command to list everyone's real name on the channel?
11:49:05 <SamB> haha
11:49:20 <Philippa> SyntaxNinja: not within the IRC protocol AFAIK, can't speak for your client
11:49:41 <kpreid> zeeeee: to start with, [a, b] <- getArgs; ... (read a) (read b) ...
11:49:51 <Philippa> but it'd be hard to implement and not get kicked for flooding, as it'd have to whois everyone
11:49:51 <eivuokko> SyntaxNinja, /who has that information as well (if they have given that info on logon)
11:50:25 <emertens> type /who #haskell
11:50:38 <eivuokko> Yeah, depends on your client whetever it defaults on asking per channel.
11:50:39 <mahogny> huh. flooding? has nothing to do with whois
11:50:39 <emertens> at least on my client, it does what you want
11:50:55 <madpickle> there's two ways
11:50:57 <madpickle> /who, and /names
11:51:05 <madpickle> /names is recommended if you only want nicknames
11:51:05 <Philippa> mahogny: it does if you send 220 whois commands in under a second
11:51:12 <SamB> but it only lists realnames
11:51:13 <mahogny> Philippa: the server does?
11:51:14 <SamB> not real names
11:51:27 <madpickle> it lists nicknames, yes
11:51:33 <Philippa> ah, didn't know /who
11:51:45 <madpickle> /who would list real name
11:51:47 <SamB> it can't figure out what peoples *real* real names are
11:51:57 <madpickle> [01 07:51:11 pm] (H) madpickle!i=jizzy@touch.my.lovecudgel.com (irc.freenode.net) [dough]
11:52:05 <madpickle> here's an example of my /who of #haskell
11:52:22 <SamB> exactly what I mean, you aren't really named "dough" are you?
11:52:25 <madpickle> 'dough', here, being my real name
11:52:27 <madpickle> um, dude
11:52:36 <SamB> as your whole name?
11:52:37 <madpickle> you cannot honestly expect to get someones real name
11:52:43 <madpickle> some put it there, others do not
11:52:44 <SamB> thats what I was saying ;-)
11:53:10 <mahogny> the rfc says it should be the real name! you can't imply that people are breaking the spec?
11:53:17 <SamB> hahahah
11:53:22 <SamB> the RFC has issues
11:53:25 <SamB> many issues
11:53:31 <mahogny> heh. many indeed
11:53:36 <mahogny> the whole rfc is an issue
11:53:38 <SamB> and that right there is a security issue
11:53:39 <edwardk> the rfc was written way back in what 91?
11:53:48 <madpickle> real name is an anachonism, left over from when UNICES simply entered it based on account profile
11:53:52 <zeeeee> kpreid: i've updated it, see http://rafb.net/paste/results/oKZbo098.html
11:53:56 <edwardk> the world was a lot more trusting back then
11:54:02 <madpickle> yes.. the days of rlogin
11:54:04 <Philippa> madpickle: still wasn't reliable...
11:54:06 <madpickle> and, uh, sendmail
11:54:10 <madpickle> why should it be reliable?
11:54:16 <kpreid> zeeeee: that won't work
11:54:19 <madpickle> who ever said i wanted people to know my real name? O.o
11:54:29 <mahogny> irc is just an extension to telnet. what should one expect?
11:54:37 <kpreid> zeeeee: you'd need to "mapM (liftM read) getArgs"
11:54:38 <madpickle> not telnet per se
11:54:45 <SamB> mahogny: hahaha
11:54:47 <mahogny> madpickle: very close
11:54:48 <musasabi> realname is good to quickly get irc <-> mailing list associations on #haskell.
11:54:52 <madpickle> it doesn't respond properly to the telnet command structure
11:55:00 <madpickle> a better, more apt way, would be "similar to talk"
11:55:02 <mahogny> madpickle: it used to be very close
11:55:04 <madpickle> which is what it was based off.
11:55:09 <SamB> and it is very hard to use with a telnet client, too ;-)
11:55:11 <madpickle> telnet has all kinds of escape characters added
11:55:16 * edwardk is sitting here trying to figure out where the heck this dedicated japanese contingent of users for his site keeps coming from
11:55:23 <zeeeee> kpreid: ok, i changed that, and am now reading more on what this *M functions are
11:55:27 <kpreid> @type mapM (liftM read) getArgs
11:55:29 <lambdabot> Not in scope: `getArgs'
11:55:30 <zeeeee> http://rafb.net/paste/results/UI3Xp814.html
11:55:39 <kpreid> @type mapM (liftM read) (undefined :: IO [String])
11:55:40 <lambdabot>   Couldn't match `[m String]' against `IO [String]'
11:55:40 <edwardk> maybe the japanese just really like javascript
11:55:41 <lambdabot>    Expected type: [m String]
11:55:45 <kpreid> apparently not
11:55:47 <SamB> edwardk: maybe they aren't really japanese?
11:55:50 <zeeeee> i'm interested in all feedback. can i make it more concise/clear/clean/haskellic? everything from the var names to the whitespace
11:55:52 <edwardk> also possible
11:56:02 <shapr> @yow !
11:56:03 <lambdabot> I have seen these EGG EXTENDERS in my Supermarket ...
11:56:10 <edwardk> but then google analytics gives language pref as jp being about the right level for them really to be
11:56:26 <SamB> or maybe they aren't really users?
11:56:26 <edwardk> actually yeah, almost all of them have it as their default
11:56:42 <edwardk> thats also possible, but they click around in patterns that aren't botly
11:56:48 <SamB> ah
11:57:21 <monochrom> Perhaps they understand your English.
11:57:37 <edwardk> i figured that much. just trying to figure out how they got referred.
11:57:43 * edwardk shrugs.
11:58:22 <kpreid> zeeeee: why ":_"?
11:59:01 <SyntaxNinja>  /who #haskell dosn't work. on gaim I can click on ppl and get their names, but can't seem to get entire chanenl
11:59:09 <zeeeee> kpreid: oh, i guess that's pointless
11:59:32 <zeeeee> http://rafb.net/paste/results/z9ZJMJ28.html
11:59:33 <kpreid> zeeeee: also, you might be able to use splitAt in normWords
11:59:37 <SamB> @map
11:59:38 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
11:59:47 <SamB> maybe that is of some use?
11:59:56 <SamB> it has real names and nicknames, iirc...
12:00:28 <kpreid> zeeeee: (before, unprocessedMiddle : after) = splitAt index ws
12:00:36 <kpreid> @type liftM (map read)
12:00:38 <lambdabot> forall a (m :: * -> *). (Monad m, Read a) => m [String] -> m [a]
12:01:02 <kpreid> zeeeee: okay, the args line I suggested actually needs to be [index, maxNumber] <- liftM (map read) getArgs
12:01:20 <kpreid> zeeeee: you can't do "map read getArgs" because getArgs isn't a [String], it's IO [String]
12:02:11 <kpreid> liftM turns (map read :: Read a => [String] -> [a]) into Read a => IO [String] -> IO [a]
12:07:57 <shapr> Oh, I need to update my location on HaskellUserLocations.
12:09:58 * shapr cannot remember his password for HaWiki
12:10:14 <shapr> That's especially depressing since I'm the person who maintains that wiki...
12:10:47 <SamB> is that wiki going to be around for a long time still?
12:10:49 <zeeeee> kpreid: i get a type error in this latest version, around the getArgs line: http://rafb.net/paste/results/Ae9WVB77.html
12:10:51 <shapr> I don't know.
12:11:13 <kpreid> zeeeee: I made a mistake and corrected myself; see above
12:13:33 <zeeeee> kpreid: oh i see it, but now they are both coerced as Floats whereas one should be an int and the other should be a float
12:13:46 <kpreid> zeeeee: ah, yes. you need to not use map
12:13:59 <kpreid> zeeeee: you have to have two occurrences of 'read' in your code
12:14:16 <kpreid> so, what I said originally
12:14:17 <kpreid> [a, b] <- getArgs; ... (read a) (read b) ...
12:14:42 <kpreid> Haskell lists always have elements of the same type, so 'map read' means that all the results are the same type
12:16:14 <zeeeee> kpreid: ok, now http://rafb.net/paste/results/38kYi363.html is the latest and greatest
12:16:45 <zeeeee> mm, disregard the second half (the exception :)
12:17:06 <kpreid> zeeeee: um, the source disagrees with the errors.
12:17:14 <kpreid> are you sure you ran the right version?
12:17:17 <zeeeee> kpreid: ya, the errors were leftover from before
12:17:21 <zeeeee> in the paste
12:17:22 <kpreid> oh, ok
12:18:20 <kpreid> looks ok to me, but I suggest a second opinion. (also you can remove the import of liftM now)
12:18:25 <zeeeee> kpreid: what about the whole structure of the app? is this how you would've approached the problem?
12:18:32 <xs> is there a fast way to get 300k uint8_t values from c, into, say, a gtk2hs pixbufdata? i'm currently using unsafeWrite into pixbufdata, using peek on a Ptr, and i can only get ~20Hz.
12:19:28 <kpreid> zeeeee: I might separate the parsing and printing from the numeric operation, but other than that, no
12:19:39 <kpreid> er, other than that I can't really think of something different
12:20:20 <zeeeee> thanks kpreid
12:20:35 <kpreid> oh, I see that's not trivial to design because it's not known which field is parseable as a number
12:21:10 <Lemmih> xs: You're writing it byte for byte?
12:21:30 <xs> Lemmih, yes.
12:21:50 <kpreid> zeeeee: you could write a function modifyField :: (Read a, Show a) => Int -> (a -> a) -> [[String]] -> [[String]]
12:21:52 <zeeeee> kpreid: hm, i'm actually confused what you mean by separating the parsing and printing from the numeric operation
12:22:28 <Lemmih> xs: You might be better off with Foreign.Marshal.Util.copyBytes
12:22:37 <kpreid> unlines . modifyField (/ maxNumber) . lines
12:23:05 <xs> Lemmih, hm. but pixbufdata isn't a Ptr?
12:23:12 <kpreid> (er, insert 'map unwords' and 'map words' in there
12:23:33 <Lemmih> xs: It isn't?
12:24:00 <xs> Lemmih, well, it isn't exposed anyhow?
12:24:01 <kpreid> zeeeee: I mean rearranging the program so (/ maxNumber) is separated from the code which splits lines and words and picks out the column being operated on
12:24:47 <xs> Lemmih, i'll give it a try, but it doesn't sound very portable.. thanks :)
12:25:34 <zeeeee> kpreid: ooh, i see, you're making a more general field-modifying function
12:25:45 <zeeeee> to modify the nth field
12:26:53 <emertens> @hoogle log
12:26:55 <lambdabot> Prelude.log :: Floating a => a -> a
12:26:55 <lambdabot> Prelude.logBase :: Floating a => a -> a -> a
12:26:55 <lambdabot> GHC.ConsoleHandler.Logoff :: ConsoleEvent
12:27:47 <emertens> logBase : flip powerOf :: (/) : `div` ?
12:30:35 <SamB> ??
12:31:03 <xs> Lemmih, heh, thanks ;-)
12:31:26 <Lemmih> xs: It worked?
12:32:01 <xs> Lemmih, yes, it's much quicker. the only problem remaining is how to actually process this data in haskell, as well as memcpy'ing it.
12:32:35 <emertens> Nevermind, I thought that powerOf was in the Prelude
12:33:12 <SamB> @hoogle powerOf
12:33:13 <lambdabot> No matches found
12:33:15 <SamB> @hoogle power
12:33:16 <lambdabot> No matches found
12:33:18 <emertens> powerOf n p = length $ takeWhile (\x -> x `mod` p == 0) (iterate (`div` p) n)
12:33:26 <SamB> @hoogle powa
12:33:27 <lambdabot> No matches found
12:33:31 <emertens> it's from Cale's hawiki page
12:34:44 <SamB> oh, is that like the analogies on the SAT or something?
12:34:51 <SamB> which sadly are not there anymore?
12:35:21 <SamB> it is kind of pathetic that they had to take those out...
12:35:28 <emertens> they did??
12:35:41 <SamB> so I've heard!
12:35:47 <emertens> apparently the sat has changed a lot since I took it
12:35:51 <emertens> they say it has 3 scores now
12:36:21 <SamB> I haven't taken it since, so I don't have an eyewitness account for you
12:36:51 <SamB> I think those analogies were my favorite kind of question
12:37:32 <psi> why did they have to take them out?
12:37:43 <Krolyk11> hello I need help with Haskell i need implement binary tree
12:37:52 <SamB> psi: I'm guessing "nobody" understands them anymore
12:38:09 <emertens> data Tree a = Leaf | Node (Tree a) a (Tree a)
12:38:17 <SamB> it really sucks for those of us who do...
12:38:30 <Krolyk11> and i need check is this tree is binary heap
12:38:42 <psi> SamB: do you have an example?
12:38:49 <SamB> psi: example?
12:38:50 <Krolyk11> thx emertens
12:38:55 <SamB> what do you mean?
12:38:59 <emertens> of an analogy?
12:39:10 <SamB> an example of a person who doesn't understand analogy questions?
12:39:21 <psi> no, what could one of those questions look like
12:39:30 <SamB> hmm.
12:39:37 <lispy> Krolyk11: is this homework?
12:39:39 <emertens> dollar : America :: Peso : ?
12:39:53 <SamB> that is the general idea
12:40:03 <emertens> (yes, i know that lots of counties use both of those currencies)
12:40:05 <SamB> but there would be five choice
12:40:07 <psi> heh
12:40:08 <SamB> er, choices
12:40:09 <lispy> Krolyk11: it's okay to ask homework questions, but you'll get better help if you tell us upfront that it's homework :)
12:40:21 <SamB> so only one of those would be a country that used pesos
12:40:27 <Krolyk11> yes it homework
12:41:19 * SamB forgot what a heap looks like
12:41:26 <SamB> which volume of Knuth is that in?
12:41:48 <emertens> in a max-heap, every node's label is >= it's children's labels
12:42:18 * Lemmih looks at the heap of junk on his desk.
12:42:23 <SamB> oh, okay
12:42:26 <emertens> that would be a trash heap
12:42:30 <emertens> not a min or max heap ;)
12:42:36 <SamB> so...
12:42:56 <SamB> oh man, I am so tempted to just write the function
12:43:22 <SamB> Krolyk11: what in particular did you need help with?
12:44:05 <Krolyk11> i need check if binary tree is heap
12:44:30 <emertens> Do you know what it means for a binary tree to be a heap?
12:44:44 <SamB> well, okay, I'm guessing either you've learned about what a heap is, or are supposed to read it in your textbook?
12:44:52 <lispy> Krolyk11: i'd recommend you create your binary tree data type and then look at making it an instance of Functor
12:45:03 <SamB> lispy: huh?
12:45:13 <lispy> SamB: then he can fmap it :)
12:45:15 <emertens> all (fmap isHeap myHeap)
12:45:22 <emertens> something like that?
12:45:24 <SamB> lispy: how will that help?
12:45:45 <lispy> well, he could create (for example) an inorder list of the nodes
12:46:11 <lispy> wouldn't that make writing isHeap easier?
12:46:14 * SamB thinks lispy has the wrong idea...
12:46:22 * lispy begins to doubt
12:46:25 <SamB> anyway, that sounds overcomplicated at this point
12:46:25 <emertens> lispy: given an inorder list of nodes, you coudl use map
12:46:29 * lispy starts drinking heavily
12:46:30 <SamB> I'd just write it the normal way
12:46:39 <SamB> the good, old fashioned way
12:46:45 <lispy> in c?
12:46:49 <SamB> no
12:47:03 <lispy> int isHeap(bintree* b) { ... }
12:47:04 <SamB> I'd pattern match on the tree datatype
12:47:26 <SamB> and use explicit recursion
12:47:53 <SamB> Krolyk11: so, what part of that do you need help with?
12:49:38 <lispy> emertens: yeah, actually i really like map so i was trying to find a way to transform the tree to a list
12:49:49 <lispy> emertens: fmap seems pretty easonable
12:50:23 <Krolyk11> i can transform tree to the list
12:50:24 <emertens> lispy: fmap on Tree a would be fmap :: (a -> b) -> Tree a -> Tree b
12:50:26 * lispy goes back to dreaming about report speficiation languages
12:50:50 <lispy> emertens: oh right, i was thinking it would accumulate the nodes
12:50:57 <psi> Krolyk11: just begin with the root. see if the property holds. repeat recursively.
12:56:28 * SamB wonders how to write a genetic algorithm
12:56:46 <monochrom> Don't transform the tree to a list.
12:57:11 <emertens> monochrom: don't worry, lispy has moved past that idea
12:57:17 <bejs> data Gene = G | A | T | C
12:57:31 <emertens> <rimshot>
12:57:44 <emertens> s/Gene/BasePair
12:57:51 <bejs> ah, whatever
12:57:53 <emertens> ;)
12:57:55 <SamB> not that kind of genetic algorithms
12:58:08 <monochrom> I volunteer to teach you how to get random numbers :)
12:58:10 <nealc_> :)
12:58:12 <emertens> generate a population of potential solutions
12:58:13 <SamB> and anyway you don't write that way
12:58:20 <emertens> evaluate them with a heuristic
12:58:34 <SamB> yeah.
12:58:39 <emertens> choose from the population based on the heuristic..
12:58:51 <emertens> mutate... cross-breed
12:58:57 <emertens> and lather rinse repeat
12:58:58 <SamB> how do you crossbreed though?
12:59:10 <emertens> there isn't a hard and fast rule i don't think
12:59:15 <vininim> oh, and GATC for dna and GAUC for rna. =p
12:59:19 <SamB> and does that make sense for ASM programs?
12:59:48 <emertens> you want to write a genetic algorithm to stumble into a working asm program?
12:59:57 <SamB> somethin like that
13:00:04 * SamB is playing with the ICFP problems
13:00:06 <xerox> ?type (take 10 . fix (\f g -> (\(x,g') -> x : f g') (next g))) `fmap` newStdGen
13:00:07 <lambdabot> IO [Int]
13:00:12 <xs> you want genetic programming not ga. gp has operators more specific to control flows.
13:00:18 <SamB> ah
13:00:22 <SamB> how does that work then?
13:00:34 <SamB> oh, but this ASM hasn't got control flow anyway...
13:00:47 <xs> well, you've got branching, which is the main concern, really
13:00:51 <SamB> I do?
13:00:53 <xs> branch points can be crossed over
13:01:04 <xs> for evolving interesting behaviour, sure?
13:01:10 <xs> how are you going to get loops? :)
13:01:24 <vininim> make it in haskell as a list of basic funcions and just whack the list around =P
13:01:46 <SamB> the IP wraps around to the beginning of the program again ;-)
13:02:18 <xs> mm junk code :)
13:02:35 <SamB> if you need some kind of flow, you need to use the SCIENCE opcode
13:02:53 <SamB> which conditionally changes the IS (instruction speed)
13:03:29 <xs> it's a float, thus allowing NaN (infinite)?
13:03:34 <SamB> no
13:03:54 <SamB> it is a signed 5-bit integer
13:04:01 <emertens> NaN /= Infinite... right?
13:04:02 <SamB> ranging from -16 to 15
13:04:34 <SamB> it is added to the IP after every instruction
13:05:19 <SamB> really, though, I suppose I wouldn't need to use GA for anything but permuting the registers
13:05:24 <SamB> or GP
13:05:27 <SamB> whatever
13:05:38 <SamB> that is done with the PHYSICS opcode, which is quite odd
13:11:16 <zeeeeee> hi all, i'm just starting out in haskell. critique of any kind on my first app would be greatly appreciated. http://rafb.net/paste/results/10H7pN89.html
13:11:39 <zeeeeee> (can i make it more concise/clear/clean/haskellic? everything from the var names to the whitespace to the overall design)
13:12:05 <zeeeeee> kpreid: (i think this might be the separation of parsing/processing that you meant)
13:13:23 <kpreid> zeeeeee: yep
13:13:55 <kpreid> zeeeeee: I'd move the show . f . read out of mapAt into processField though
13:14:06 <vininim> hah, the um specification is such a poetry
13:14:18 <kpreid> then mapAt has type Int -> (a -> a) -> [[a]] -> [[a]]
13:15:49 <emertens> @type interact
13:15:50 <lambdabot> (String -> String) -> IO ()
13:15:56 <musasabi> zeeeeee: lifting the lines/unlines closer to interact might make sense.
13:17:39 <musasabi> zeeeeee: maybe interactLines f = interact (unlines . map f . lines)
13:17:50 <musasabi> but that is just a matter of opinion
13:20:29 * SamB curses whoever decided that GTK file picker dialogs didn't need a text field
13:20:59 <xs> SamB, control+L?
13:21:07 <emertens> yeah.. it's just hidden
13:21:13 <SamB> xs: things like that should *NOT* be hidden
13:21:24 <xs> yeah :/
13:21:38 <SamB> users can't be expected to read documentation for the widgets
13:21:55 <SamB> especially since there isn't a convenient way to get to it
13:22:42 <emertens> all of the "studies" suggest that using a keyboard is almost always slower than using a mouse... I'm sure that the GTK people are just trying to force you to save time ;)
13:23:07 <shapr> Really? Which studies?
13:23:22 <emertens> search around on google for usability studies
13:23:34 <musasabi> emertens: keyboard with things like filename completion etc?
13:23:43 <emertens> one of the more interesting ones described one reason that most people *think* that the keyboard is fater
13:23:46 <emertens> faster
13:24:18 <musasabi> emertens: mouse is just pure pain if the directory hierarchy is deep and contains many files.
13:24:19 <emertens> the time spent thinking about the keystrokes supposedly used more brain time and the user actually forgot about how long it took
13:24:27 <SamB> emertens: stupid studies
13:24:28 <emertens> where the mouse was very easy that the user felt like it was taking forevef
13:24:32 <xs> on average
13:24:39 <SamB> if I know the path it is not going to be quick to click on all those things
13:24:50 <SamB> unless certain components of it are really long
13:24:51 <emertens> kind of like when you are having fun, time passes faster
13:25:02 <shapr> So people enjoy using the keyboard more?
13:25:12 <SamB> I don't care what is "faster"
13:25:13 <emertens> they feel like they are accomplishing more, or something
13:25:20 <emertens> I dont' know, I didn't write these things
13:25:50 <shapr> Anyone else near Cambridge, UK on the approaching Friday and wants to come to AngloHaskell?
13:25:53 <SamB> anyway, I'm not going to want to click on things rather than type /usr/bin/gv
13:25:54 <emertens> I think they are gear toward the general user
13:26:08 <emertens> than the poweruser who really is good at remembering the shortcuts
13:26:16 <shapr> emacs users are right out then?
13:26:19 <SamB> well MS has a text field there
13:26:25 <SamB> it might confuse windows users not to have one
13:26:31 <emertens> so?
13:26:45 <emertens> GTK isn't supposed to be a windows clone :)
13:26:48 <SamB> well, they *are* the majority of non-experts
13:27:10 <emertens> no one said that MS emphasises usability
13:27:14 <emertens> have you seen Vista?
13:27:23 <emertens> talk about cluttered and tough to use...
13:27:34 <SamB> and I really don't think that the text field slows anyone down...
13:27:41 <Philippa> if GTK doesn't behave at all like windows on windows, it's not particularly usable for writing windows apps for most users with
13:28:04 <SamB> oh, well, I'm not talking about the way it behaves on windows
13:28:07 <Philippa> sometimes it's a speedup, I *always* type drive letters for example because they're multiple clicks away
13:28:29 <emertens> two click?
13:28:38 <emertens> drop down open, select letter?
13:28:41 <SamB> like three at least
13:28:45 <bejs> yeah but you have to move the mouse to it first
13:28:49 <SamB> usually you need to scroll up
13:28:52 <Philippa> yeah, or my computer from the left and then a double click on the drive
13:29:06 <emertens> I prefer the keyboard too
13:29:19 <emertens> but I don't think that most people in #haskell are "typical" users
13:29:30 <SamB> I don't think we are that atypical
13:29:44 <bejs> I for one am completely weird.
13:29:45 <Philippa> we're not that atypical for power users
13:29:58 <SamB> and I really don't think a text field at the bottom will distract a user who wants to click on things
13:31:13 <zeeeeee> how do i fix this type error? http://rafb.net/paste/results/VLFqYX37.html
13:31:26 <bejs> The box always opens too small for me; I'd rather not have a text field take up even more space.
13:32:15 <SamB> bejs: heh
13:32:23 <SamB> the box is WAAAAAAAAY to small to be of any use to me
13:32:25 <emertens> SamB: What dialog window are you talking about specifically
13:32:30 <SamB> in fact, even if it filled the screen it would be
13:32:39 <SamB> emertens: the GTK 2 file picker dialog
13:32:40 <bejs> the new gtk file selector
13:33:06 <emertens> SamB: just start typing
13:33:16 <emertens> SamB: it looks like a little box pops up in the bottom corner
13:33:17 <SamB> emertens: that isn't very intuitive!
13:33:35 <emertens> SamB: if you type "/"
13:33:37 <SamB> there was no reason to believe that that would be of any use
13:33:39 <emertens> a location box comes up
13:33:43 <kpreid> zeeeeee: remove the type signatures in the where
13:34:05 <SamB> they ought to have a panic button somewhere that brings up something that explains all this
13:34:06 <kpreid> zeeeeee: the 'a' there is not the same as the 'a' above, so you're claiming that 'before' is a could be a list-of-anything
13:35:31 <emertens> ^ has made vininim look like a non-native speaker ;)
13:37:50 <zeeeeee> kpreid: there's no way for me to explicitly declare it to be a list of the same 'a'?
13:38:08 <zeeeeee> kpreid: i.e., there's no way for me to bind the a's together?
13:38:10 <kpreid> zeeeeee: IIRC, there is a ghc extension for that
13:38:19 <kpreid> but I suggest not bothering
13:38:23 <zeeeeee> kpreid: oh ok
13:48:50 <emertens> @index asTypeOf
13:48:50 <lambdabot> Prelude
13:50:08 <xerox> monochrom: do you think it counts if I do here @remember monochrom "imagining" is already a non-identity isomorphism. ?
13:58:35 <monochrom> That is nice.
14:15:54 <SamB> @hoogle ST
14:15:55 <lambdabot> Control.Monad.ST :: module
14:15:55 <lambdabot> Data.Array.ST :: module
14:15:55 <lambdabot> Control.Monad.ST.ST :: data ST s a
14:16:23 <SamB> @hoogle MonadST
14:16:24 <lambdabot> Control.Monad.State.MonadState :: class Monad m => MonadState s m
14:16:27 <SamB> hmm
14:16:32 <SamB> @hoogle liftST
14:16:33 <lambdabot> No matches found
14:16:55 <SamB> hmm, is there a reason why there isn't a MonadST like there is a monadIO?
14:17:13 <tessier_> hmm...
14:17:27 <tessier_> A distributed database implemented in haskell would be pretty sweet.
14:17:40 <tessier_> Something along the lines of googles map/reduce.
14:22:34 <ihope_> Is there a nice way to expeort everything except certain things?
14:23:23 <emertens> you mean module Main (main) where ...
14:23:24 <emertens> ?
14:23:32 <emertens> oh
14:23:33 <emertens> duh
14:23:38 <emertens> everything except :)
14:28:10 <roconnor> ihope_: can you reexport a module imported hiding stuff?
14:28:37 <roconnor> actually I guess hiding doesn't really hide stuff does it.
14:28:40 <ihope_> Oh, yeah, I could do that.
14:28:48 <ihope_> ...Couldn't I?
14:28:58 <roconnor> not sure
14:30:22 * roconnor wants class aliases
14:32:35 <SamB> @hoogle zipWithM
14:32:36 <lambdabot> Monad.zipWithM :: Monad a => (b -> c -> a d) -> [b] -> [c] -> a [d]
14:32:37 <lambdabot> Control.Monad.zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
14:32:37 <lambdabot> Monad.zipWithM_ :: Monad a => (b -> c -> a d) -> [b] -> [c] -> a ()
14:47:59 <SamB> @hoogle readArray
14:48:00 <lambdabot> Data.Array.MArray.readArray :: (MArray a e m, Ix i) => a i e -> i -> m e
14:48:07 <SamB> @hoogle unsafeRead
14:48:08 <lambdabot> No matches found
14:48:10 <SamB> hmm.
14:53:50 <SamB> @pl liftM2 (\x y -> liftIO $ unsafeRead x y)
14:53:51 <lambdabot> liftM2 ((liftIO .) . unsafeRead)
15:10:36 <xerox> roconnor - You have to provide a complete export list of what you want to export if you want to hide stuff you have imported.
15:15:43 <SamB> whats a nice way to sign-extend a five-bit number?
15:16:33 <xerox> Add a sign bit? :)
15:18:31 <SamB> xerox: it has a sign bit.
15:18:44 <SamB> I want to replicate this bit ;-)
15:18:53 <xerox> I don't know what do you mean by sign-extend then.
15:19:12 <SamB> it looks kind of like this...
15:19:22 <SamB> 000sxxxx
15:19:30 <SamB> I want to make it look like this:
15:19:36 <SamB> ssssxxxx
15:20:46 <SamB> (it is a word8)
15:20:50 <SamB> er, Word8)
15:24:56 * SamB supposes there isn't any really nice looking way to do it
15:25:52 <xerox> What's the meaning of a 4-bit sign ? :)
15:26:20 <eivuokko> I've been trying to figure that out, too :)
15:26:34 <SamB> it isn't a four-bit sign!
15:27:09 <SamB> notice how -1 comes out to be 11111111
15:28:49 <SamB> oh, maybe x .|. ((x .&. 4) * 0xF) will do the trick...
15:29:43 <SamB> wait
15:29:47 <SamB> s/4/bit 4/
15:31:21 * xerox scratches head
15:32:27 <psi> i think it will
15:33:11 <SamB> xerox: are you unfamiliar with twos complement? (insert apostrophe in appropriate location)
15:33:30 <psi> but in my mind << 4 is clearer than * 0xF
15:33:55 <SamB> since when do they do the same thing?
15:34:02 <xerox> SamB - I should re-read it, I can't remember it off-hand now.
15:34:34 <SamB> also, in Haskell it is written some other way
15:34:38 <psi> hm, right, but isn't << 4  what you want?
15:34:49 <psi> sorry
15:34:59 <psi> I thought wrongly :)
15:35:17 <xerox> shiftL
15:35:48 <psi> right...
15:36:10 <psi> :t (<<)
15:36:21 <psi> @t (<<)
15:36:22 <lambdabot> Maybe you meant: tell time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . v
15:36:31 <psi> @type (<<)
15:36:32 <lambdabot> Not in scope: `<<'
15:37:19 <xerox> ?hoogle (<<)
15:37:20 <lambdabot> Did you mean: (<<)
15:37:20 <lambdabot> Prelude.undefined :: a
15:37:20 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
15:37:26 <xerox> Yes, I did.
15:37:29 <psi> heh
15:37:58 <SamB> shiftL does not do what I want either ;-)
15:38:19 <xerox> ?tell ndm <xerox> ?hoogle (<<) <lambdabot> Did you mean: (<<)
15:38:20 <lambdabot> Consider it noted.
15:38:49 <psi> SamB: no :P
15:39:11 <SamB> and I was interpreting that << as meaning the same
15:39:37 <SamB> thanks to my ultra-contextual verbal processing support
15:39:56 <psi> hehe
15:44:51 <xerox> zeeeee: nice hostname %-)
15:45:09 <zeeeee> xerox: thanks :)
15:45:30 <kpreid> is there a better way to write (\n -> let all = complement 0 in all `xor` (all `shiftL` n))?
15:46:16 <paj> Hi
15:47:27 <psi> ello
15:49:00 <SamB> @type Control.Monad.liftM2 ((Control.Monad.State.liftIO .) . Data.Array.Base.unsafeRead)
15:49:02 <lambdabot> forall (m :: * -> *) e (a :: * -> * -> *) i (m1 :: * -> *). (Monad m1, MonadIO m, Data.Array.Base.MArray a e IO, Ix i) => m1 (a i e) -> m1 Int -> m1 (m e)
15:52:11 <SamB> oh ick
15:53:20 <monochrom> let all = complemet 0 in (all `xor`) . (all `shiftL`)
15:53:46 <monochrom> @pl \n -> 0 + 0*n
15:53:46 <lambdabot> (0 *)
15:53:53 <monochrom> @pl \n -> 5 + 0*n
15:53:54 <lambdabot> (5 +) . (0 *)
15:55:58 <xerox> It's just: xor (complent 0) . shiftL (complement 0)
15:56:31 <monochrom> Yeah
16:03:51 <LordBrain> Is there a single abstracted interface such as (get,put) for easily changing between a purely functional implementation of a stateful algorithm and a side-effecting one?
16:04:18 <SamB> no
16:04:34 <SamB> what did you mean though?
16:04:44 <kpreid> ST RealWorld is vaguely like that...
16:05:00 <LordBrain> i mean.. have the function/action definition, change the type signature, and walah, i am done
16:05:02 <musasabi> Changing from e.g. State to (ReaderT IO) is quite easy.
16:05:11 <SamB> hmm?
16:05:48 <musasabi> LordBrain: could you give more examples of what you want to do?
16:07:14 <monochrom> How does a purely functional implementation contain things like get,put?
16:07:26 <LordBrain> yeah, suppose i had that purely functional implementation of a bouncing ball.. and i want to keep the updateBall function the same, but change the type signature, so that it's now in the io monad.
16:07:51 <LordBrain> monochrom: using the State Monad
16:08:10 <LordBrain> i did it with updateBall:: State (Int,Int,Int,Int) ()
16:08:14 <musasabi> LordBrain: so you want to update the state in place instead of using State?
16:08:15 <monochrom> If you started with the ST monad instead, you could s/ST/IO
16:08:33 <kpreid> LordBrain: Control.Monad.State.modify?
16:09:03 <musasabi> LordBrain: to make changes like that easier it makes sense to newtype your monad if coding larger apps.
16:09:10 <LordBrain> musasabi: yes. I want it updated in place, i'd still call it stateful, but no it wouldnt be using the State Monad.
16:09:28 <LordBrain> yeah i thought about that musabi
16:09:40 <LordBrain> so just make my own monad?
16:09:47 <musasabi> LordBrain: the short solution is "updateBall:: ReaderT IO (IORef (Int,Int,Int,Int)) ()" or invidual IORefs for the components.
16:10:06 <monochrom> Have you used the IO monad?  It is quite unlike the State monad.  For example, newIORef ...
16:10:14 <LordBrain> yes i know
16:10:31 <LordBrain> its unlike it.. my question is there a way to abstract the difference away..
16:10:37 <musasabi> but as you can see it would be cleaner if you had a type/newtype somewhere and didn't have to change things all over.
16:11:27 <LordBrain> well making my own type, i could do the abstraction.. i guess i was wondering if there was something like that already done.
16:12:41 <musasabi> it is only a few lines usually.
16:14:46 <SamB> LordBrain: if you want to use your State code with IO, try StateT s IO on for size
16:15:41 <LordBrain> SamB: I was thinking that
16:15:43 <SamB> @type liftIO
16:15:44 <lambdabot> forall (m :: * -> *) a. (MonadIO m) => IO a -> m a
16:15:49 <SamB> @instances MonadIO
16:15:51 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
16:16:21 <xerox>  /win 25
16:16:22 <xerox> Ops.
16:16:32 <SamB> hmm, no instance constraints...
16:16:36 * SamB isn't sure he likes that
16:16:44 <LordBrain> my discovery of StateT is what made me think of it in the first place... but i'm not sure it works out.. because i still want to say (x,y,dx,dy) <- get
16:16:59 <SamB> guess what
16:17:05 <musasabi> you can say that with StateT
16:17:14 <LordBrain> ok, good
16:17:30 <musasabi> @type Control.Monad.State.get
16:17:31 <lambdabot> forall s (m :: * -> *). (MonadState s m) => m s
16:17:32 <SamB> @type do (x,y,dx,dy) <- get; liftIO $ print (x,y,dx,dy)
16:17:33 <lambdabot> forall a b c d (m :: * -> *). (MonadIO m, Show (a, b, c, d), MonadState (a, b, c, d) m) => m ()
16:18:21 <LordBrain> i thought i would have to say IORef (x,y,dx,dy) <- get
16:18:37 <musasabi> no.
16:18:39 <SamB> you aren't using IORefs ;-)
16:18:48 <SamB> you don't need them with StateT
16:18:56 <SamB> StateT is probably more efficient anyway
16:19:16 <musasabi> (and even with the ReaderT+IORef solution you would simply write get = readIORef . ask)
16:19:20 <monochrom> Well that's the disparity because we wish one code to work for both State/StateT and IO
16:19:21 <LordBrain> Well, i dont understand how i wouldnt need them... i am doing in place updating..
16:20:01 <LordBrain> is the StateT really in place updating?
16:20:10 <SamB> LordBrain: but it only comes out as in-place updating because of the compiler being smart ;-)
16:20:29 <LordBrain> hmm, i wish i was as smart as the compiler
16:20:34 <SamB> either that, or the compiler being a complete idiot
16:20:55 <musasabi> SamB: depends on the situation. When optimizing things it depends on the access pattend and the size of the structure. (whether ReaderT+IORef or StateT is beter)
16:21:17 <SamB> oh, and perhaps it isn't in-place update if you use a tuple
16:21:43 <edwardk> @paste
16:21:43 <lambdabot> http://paste.lisp.org/new/haskell
16:21:43 <LordBrain> what rules does the compiler use to figure that out?
16:22:01 <SamB> well... probably the rules for tail-call elimination...
16:22:07 <musasabi> the compiler could do linearity analysis and based on that update things in place. It doesn't.
16:22:19 <SamB> musasabi: hmm?
16:22:21 <LordBrain> ok i see
16:22:37 <LordBrain> it's a hypothetical optimization then..
16:23:10 <lisppaste2> edwardk pasted "type weirdness" at http://paste.lisp.org/display/23509
16:23:17 <edwardk> any ideas about the above?
16:23:19 <musasabi> SamB: afaik there is no updating values in place instead of new values after proving that there is no sharing.
16:23:30 <edwardk> i can drag in more of the surrounding code if needed
16:25:12 <LordBrain> musasabi: would the linearity analysis method still work if i didnt use the IO monad at all say?
16:25:16 <edwardk> the fundeps should match since TEq a b c | a b -> c, and Trichotomy n s | n -> s, so TIsPositive n b | n -> b takes n through Trichotomy, gets back a sign, then i would think i could use my TEq class to compare and get a boolean value
16:25:41 <musasabi> edwardk: the paste is missing sevaral definitions (class TEq for one)
16:25:47 <edwardk> yeah
16:26:00 <edwardk> spread across multiple source files, one sec.
16:26:20 <musasabi> LordBrain: yes. But it is non-trivial to implement in a compiler
16:26:50 <LordBrain> are there any compilers at all that do it?
16:27:24 <LordBrain> perhaps small prototype compilers for the sake of demonstration
16:27:38 <LordBrain> (not necessarily haskell compilers)
16:27:40 <lisppaste2> edwardk annotated #23509 with "dependencies" at http://paste.lisp.org/display/23509#1
16:28:04 <edwardk> i think that should be self contained now
16:28:17 <edwardk> oh wait
16:28:20 <edwardk> i forgot O and I
16:28:38 <musasabi> Clean has uniqueness annotations (essentially the same thing). I don't know of anyone inferring it - but there is probably a few compilers somewhere that implement it.
16:28:38 <LordBrain> i'm curious how linearity analysis would work
16:29:50 <lisppaste2> edwardk annotated #23509 with "miscellanea" at http://paste.lisp.org/display/23509#2
16:30:02 <musasabi> LordBrain: prove at the point of update that there are no more references to the data structure and turn the update function to work in-place instead of creating a new updated value.
16:30:43 <edwardk> i've been working up a formalism for pure type systems with substructural (i.e linear) constraints. basically to see how well it would work as an intermediate language
16:31:24 <edwardk> its awkward expressing pointedness, relevance, affinity, linearity, unrestrictedness, and poly/monotyping in one 'light weight' intermediate representation.
16:31:46 <shapr> @yow !
16:31:47 <lambdabot> Catsup and Mustard all over the place!  It's the Human Hamburger!
16:31:50 <musasabi> class TEq still missing
16:32:00 <shapr> It's sad that Yow will be leaving emacs :-(
16:32:10 <musasabi> and TBool
16:32:19 <edwardk> class TBool b => TEq x y b | x y -> b is the last line of the first paste
16:32:36 <edwardk> class (TCBool Closure x) => TBool x where fromTBool :: x -> Bool
16:32:36 <edwardk>  is 4 lines above that =)
16:32:53 <musasabi> ah, got only the second. My sloppyness.
16:33:46 <edwardk> (its got a bit of the kitchensink problem. should probably have just put up the original source file) =)
16:34:26 <edwardk> the reason for the XI XO nonsense is to ensure that i never leave 'normal form' for my 2s complement numbers.
16:34:51 <edwardk> i'm using T and F to express the infinite series of 0's or 1's in the msbs of the number.
16:34:56 <edwardk> O and I to express a single 0 or 1
16:36:01 <edwardk> theclosure hack can be dropped from TBool without losing expressiveness
16:37:37 <musasabi> edwardk: the problem looks like the "Trichotomy n s" is not evaluated first and thus it "s" is still polymorphic and thus there is no instance for (TEq s IsPositive b)
16:37:51 <edwardk> hrmm.
16:38:04 <LordBrain> So, to do what i was thinking of, it seems like I need to make my own monad, StateInPlace, an instance of MonadState
16:38:49 <edwardk> heh, any idea of a good hack to force resolution order? =)
16:40:12 <edwardk> coz i much prefer the stronger Trichotomy definition that separately recursing, coz it says more about the disjointness of the three conditions via that fundep.
16:41:12 <musasabi> solved it.
16:41:18 <edwardk> ooohoooh
16:41:20 <edwardk> =)
16:42:18 <musasabi> Change "tIsZero = undefined :: TIsZero n b => n -> b" to:
16:42:19 <musasabi> tIsZero :: TIsZero n b => n -> b
16:42:19 <musasabi> tIsZero = undefined
16:42:23 <edwardk> so what boneheaded stunt was i pulling this time?
16:42:28 <musasabi> and the same for the other predicates.
16:42:41 <edwardk> the predicates did me in?
16:42:47 <musasabi> yes
16:42:49 <edwardk> hah
16:42:52 <edwardk> thats funny
16:43:04 <edwardk> so much for trying to save a few keystrokes
16:43:49 <edwardk> is there a firm theoretical reason as to why? or did it just work out that way
16:44:29 <edwardk> in either event, you rock =)
16:46:07 <edwardk> hrmm. maybe something with the resolution order? tEq's signature was bound to the module level variable but tIsFoo weren't. does it resolve those first and work inward or something?
16:46:37 <musasabi> well I started out with "lets comment out the predicates as they look suspect", and then things worked. Next played a little bit with the class definitions and then noticed there was something funny with monomorphism restriction and tried giving them a proper signature. Noticed it just worked.
16:46:48 <edwardk> heh
16:47:04 <musasabi> 2:45 AM here, so no firm theoretical thinking.
16:47:10 <edwardk> heh sok
16:47:30 <edwardk> i'm going on about 28 hours without sleep myself =/
16:47:38 <edwardk> not over this mind you
16:48:13 <edwardk> now i just have to slog through getting the adder working right again, now that i've changed everything out to make things symmetrical
16:49:39 <edwardk> anyways does the type hackery there seem too baroque?
16:50:17 <edwardk> though i guess, not much of it shows up in the pasted example
16:50:50 * edwardk merrily goes back and closes up his sign class
16:51:28 <musasabi> edwardk: it looks quite nice.
16:52:03 <edwardk> http://slipwave.info/jugs/src/Type/ should have the code i'm working up right now
16:52:04 <lambdabot> Title: Index of /jugs/src/Type
16:52:10 <musasabi> edwardk: currently I am waiting for ghc-fc to stabilize before touching my own typehackery plays.
16:52:15 <edwardk> *nods*
16:52:29 <edwardk> i just needed type level booleans and wanted a nice 2s complement type level binary number implementation
16:52:35 <edwardk> so i could to fake dependent typing, etc.
16:52:51 <edwardk> and i figure its a good way to learn the dark corners of the language
16:53:34 <edwardk> right now the successor and negation relations work nicely
16:54:06 <edwardk> i haven't got the binary ops working any more because i started strongly normalizing all my numbers (hence the XO XI garbage) to get rid of anything before the long tail that could be consumed by it
16:54:32 <edwardk> and i haven't worked out a non-verbose way to specify the boolean operators over this boolean ring as a result.
16:56:23 <RyanT5000> how does -fallow-undecidable-instances work? does it just choose at random?
16:56:30 <edwardk> the closure hacks seem to be a reasonable way to keep people from extending the classes in ways the infrastructure can't support
16:57:06 <edwardk> its safe as long as you don't have any cycles
16:57:15 <zeeeee> hi all, i hear a lot about how great haskell is for parsing. without digging up these references again, is this most likely referring to happy? parsec? something else?
16:57:18 <edwardk> it'll still yell at you if you have two instances that unify
16:57:37 <edwardk> parsec usually
16:57:46 <zeeeee> edwardk: ok, that's what i thought too
16:57:48 <xerox> zeeeee: I'd say parsec. It is a very powerful tool.
16:57:57 <SamB> zeeeee: probably parsec, but happy isn't too shabby either
16:58:04 <RyanT5000> edwardk: well i just turned it on to get something to load (don't know if being in GHCi matters) and it worked even though i have two suitable instances
16:58:15 <RyanT5000> using trace i can see which one it's using
16:58:21 <RyanT5000> and if i take one out it'll use the other
16:58:25 <edwardk> interesting
16:58:30 <SamB> you wouldn't believe how much simpler ASTs are in Haskell unless you tried/thought about it ;-)
16:58:33 <RyanT5000> yeah, that seems like it should be illegal
16:59:02 <RyanT5000> but in order to get it to work in other circumstances (i.e.: when they don't ever actually coincide) i have to turn on that flag
16:59:04 <RyanT5000> it seems dangerous
16:59:56 <edwardk> well, its needed to do something like instance (TEQ a b c, TNot c c') => TNEQ a b c'
17:00:12 <edwardk> because everything on the left is a type, so things might not settle down, and you may never finish type checking
17:00:34 <RyanT5000> hm
17:00:40 <LordBrain> hmmmm
17:01:14 <RyanT5000> but can't it tell that it could've picked the other instance?
17:01:56 <RyanT5000> i mean whatever function is actually making the final decision should be able to determine what all the possible things that fit are, and should still give you an error if it finds two valid instances
17:02:00 <RyanT5000> (6.4.2, btw)
17:03:14 * edwardk is still learning his way around type classes
17:03:25 <edwardk> I'm mostly doing this as an exercise in controlled insanity
17:03:26 <RyanT5000> me too
17:03:52 <RyanT5000> i'm trying to produce a functional rdbms-type datastructure
17:04:03 <edwardk> fun
17:04:12 <edwardk> isn't there some work on using HList type things for that?
17:04:17 <LordBrain> what is the "state hack" referred to by -fno-state-hack. I read about it in the manual, but i still dont know. It says:
17:04:26 <LordBrain> Turn off the "state hack" whereby any lambda with a State# token as argument is considered to be single-entry, hence it is considered OK to inline things inside it. This can improve performance of IO and ST monad code, but it runs the risk of reducing sharing
17:04:38 <RyanT5000> edwardk: i've looked around, and i haven't found anything satisfactory
17:04:45 <edwardk> fair enough
17:05:02 <RyanT5000> the problem is that everything is potentially customized on a per-table basis
17:05:05 <LordBrain> i dont know what the # means on the State#
17:05:08 <RyanT5000> so i'm retaining the concept of a table
17:05:24 <RyanT5000> but a "Table" doesn't actually have any operations defined on it, much less a physical form
17:05:24 <edwardk> thats a core thing isn't it, something like 'unboxed' or implemented right in the core?
17:06:29 <RyanT5000> LordBrain: i've been told that # is just another character allowed in symbols
17:06:36 <RyanT5000> it's used as an uglifier by convention
17:06:44 <LordBrain> hmmmmm
17:06:50 <RyanT5000> i could be totally wrong though, i've never actually touched code that used it
17:07:00 <LordBrain> so there is a State# token...
17:08:12 <edwardk> used to keep the ST monad ordered, no?
17:08:19 <edwardk> since you can't make a new one without making a new ST monad.
17:08:21 <RyanT5000> edwardk: anyway the table library provides classes that can be used to define common features of tables
17:08:30 <edwardk> er run of one
17:08:47 <edwardk> sounds pretty sensible so far
17:09:01 <edwardk> woot
17:09:17 <edwardk> *Type.Binary> tNeg fourteen
17:09:17 <edwardk> O (O (I (O T)))
17:09:41 * edwardk kicks his adder
17:09:55 <RyanT5000> so far i have the classes Accessor, Index, Filter, Ordering, and Inserter
17:10:30 <RyanT5000> there's no update - that'll just be a filter operation that returns a table with the same kind of row as before
17:10:59 <RyanT5000> hopefully i can come up with some useful combinators
17:11:29 <ihope> Hmm, this one datatype is very impossible to add to Djinn.
17:11:53 <beelsebob> What was the original paper on Hood called again?
17:14:19 <lisppaste2> edwardk annotated #23509 with "more type weirdness," at http://paste.lisp.org/display/23509#3
17:15:07 <edwardk> now i seem to be slamming into more boundary cases.
17:15:34 <edwardk> kinda hard for me to track the resolution that leads to the LSB (O F) F F attempt
17:15:57 <LordBrain> hmmm ghc's verbose output is not going to standard out
17:16:27 <SamB> # is only allowed in names when -fglasgow-exts is on
17:16:52 <LordBrain> it goes to standard error
17:18:08 * edwardk winces at the prospect of adding a 'well formed' variable to the LSB calculation.
17:19:38 * monochrom looks at "Generics as a Library" on LtU
17:19:50 * monochrom parodes the abstract
17:26:29 <monochrom> "An important benefit of these approaches is that generic functions cannot be overriden by unknown ad-hoc behaviour, precluding a common source of software engineering nightmares.  In this paper, we undermine this work.  Using our new technique, overriding with arbitrary implementations to surprise your colleagues is possible."
17:26:45 <edwardk> heh
17:26:53 <edwardk> sounds like aop =)
17:35:32 <stepcut> monochrom: hehe
17:37:35 <monochrom> Quoting "theory of category": "I'm student thesis, and I'm interested in proofs of ..."
17:37:55 <monochrom> Wow, how much I'd love *my* thesis to come to life and write itself!
17:39:10 <ihope> Let's see... something's possible if you fail to prove that it's not true, and it's necessary if you cannot fail to prove it?
17:40:20 <monochrom> That sounds right.
17:41:22 <ihope> Okay.
17:41:25 <ihope> type Unknown a = (Possibly a, Possibly (Not a)) -- :-)
17:41:33 <vininim> That sounds like a good set of axioms to start with.
17:43:11 <ihope> Just defining Not and implication seems to be all that's needed for propositional logic.
17:43:19 <monochrom> Yes.
17:44:08 <ihope> Not was defined as reductio ad absurdum, and implication is either the double negative or a function.
17:45:56 <ihope> Failure is Djinn's Void, and Fails is Djinn's Not.
17:47:17 <ihope> Then we have "type Possibly a = Fails (Not a)", "type Necessarily a = Not (Fails a)", and "type Unknown a = (Possibly a, Possibly (Not a))".
17:56:59 <SamB> hmm, I just noticed, my solver finally found something
17:57:11 <SamB> (Though I changed it a bit and restarted it first)
17:59:15 <vininim> how is implication double negative?
17:59:36 <vininim> a negative takes one parameter, and implication takes two IIRC
17:59:45 <ihope> The double negative axiom is an implication.
18:00:05 <ihope> I wrote it as this: DoubleNegativeElimination :: Not (Not a) :- a
18:07:46 <ihope> I don't think there's a Fails a -> Not a... that'd be exists b. Fails a -> (a -> b, a -> Not b), which is Fails a -> a -> (b, Not b)... but I didn't include the rule that if we have a, but a fails, we can derive anything.
18:08:23 <ihope> I don't want the failure to find something to be proof that it doesn't exist.
18:12:06 <zeeeee> hi all, if i have a string like this: "||a|b||c", how do i split it on the "||" to get ["","a|b","c"]?
18:12:37 <SamB> @type runParser
18:12:39 <lambdabot> Not in scope: `runParser'
18:12:43 <SamB> aww
18:12:47 <ihope> @hoogle String -> String -> [String]
18:12:48 <lambdabot> No matches, try a more general search
18:12:51 <ihope> @hoogle glue
18:12:52 <lambdabot> No matches found
18:13:04 <SamB> @hoogle [a] -> [a] -> [[a]]
18:13:05 <lambdabot> No matches, try a more general search
18:13:28 <ihope> @hoogle Eq a => [a] -> [a] -> [[a]]
18:13:29 <lambdabot> No matches, try a more general search
18:13:55 <SamB> ihope: didn't they tell you that hoogle doesn't know how to search by class constraints?
18:14:23 <SamB> @hoogle m a -> (a -> m b) -> m b
18:14:25 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
18:14:25 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
18:14:25 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
18:14:29 <ihope> SamB: who are "they"?
18:14:47 <ihope> @hoogle Monad m => m a -> (a -> m b) -> m b
18:14:48 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
18:14:48 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
18:14:48 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
18:14:48 <SamB> ihope: well. you hadn't figured it out?
18:14:57 <ihope> SamB: not really.
18:15:17 <ihope> @hoogle (String -> Int) -> String -> Int
18:15:17 <lambdabot> No matches, try a more general search
18:15:39 <ihope> So even if there's Eq a => [a] -> [a] -> [[a]], Hoogle won't find it?
18:15:50 <SamB> @hoogle (b -> Bool) -> [a] -> [[a]]
18:15:51 <lambdabot> No matches, try a more general search
18:15:53 <SamB> ihope: not really
18:16:01 <SamB> it will just throw out the constraints
18:16:21 <SamB> @hoogle (a -> Bool) -> [a] -> [[a]]
18:16:22 <lambdabot> No matches, try a more general search
18:16:29 <SamB> hmm.
18:16:32 <zeeeee> so should i use Text.Regex or something? (i was hoping for something lighter-weight...surely there a 'split' function)
18:16:43 <SamB> does text.regex even do that?
18:16:56 <SamB> maybe you should look at that wikipage?
18:17:38 <SamB> @google site:haskell.org/hawiki "comparing f x y"
18:17:40 <lambdabot> No Result Found.
18:17:44 <SamB> @google site:haskell.org/hawiki "comparing f"
18:17:47 <lambdabot> http://www.haskell.org/hawiki/SchwartzianTransform
18:17:47 <lambdabot> Title: SchwartzianTransform - The Haskell Wiki
18:18:12 <SamB> @google site:haskell.org/hawiki useful functions
18:18:15 <lambdabot> http://www.haskell.org/hawiki/WorkerWrapper
18:18:15 <lambdabot> Title: WorkerWrapper - The Haskell Wiki
18:18:17 <SamB> hmm.
18:18:47 <ihope> So I don't want to be able to derive everything from Failure, because Failure simply means that something doesn't exist, not that it *can't* exist.
18:20:50 * SamB_XP wants a tool to search the wiki by the source of a function, modula variable names
18:20:57 <SamB_XP> er, modulo
18:22:57 <SamB_XP> @wiki LicensedPreludeExts
18:22:58 <lambdabot> http://www.haskell.org/haskellwiki/LicensedPreludeExts
18:24:18 <SamB_XP> zeeeee: look there?
18:24:54 <zeeeee> SamB: i'm reading it now
18:25:15 <zeeeee> SamB_XP: (There is currently no text in this page)
18:25:24 <SamB_XP> oh rats
18:25:26 <SamB_XP> @oldwiki LicensedPreludeExts
18:25:27 <lambdabot> http://www.haskell.org/hawiki/LicensedPreludeExts
18:25:32 <SamB_XP> that one works better ;-)
18:25:53 <SamB_XP> I don't think the function is there though
18:25:57 <SamB_XP> maybe MissingH has it
18:26:00 <zeeeee> oooh
18:26:05 <SamB_XP> @where MissingH
18:26:05 <lambdabot> http://quux.org/devel/missingh
18:26:13 <zeeeee> this is a nifty repository of tiny utility functions
18:26:51 <zeeeee> SamB_XP: sadly that latter site is down
18:26:57 <SamB_XP> hmm
18:27:03 <SamB_XP> quux.org? down?
18:27:33 <ihope> "There is no function that can prove a conclusion from something that doesn't exist, yet can also disprove the same conclusion from something that doesn't exist."
18:28:18 <Korollary> I think there are debian pkg's of MissingH
18:30:21 * ihope oogs
18:33:48 <ihope> Wait, that's "(Failure :- q) -> (Failure :- Not q) -> Failure".
18:35:07 <ihope> Aha...
18:37:19 <ihope> If we have a way to derive q from Failure, but we also have a way to derive Not q from Failure, then we can derive Not Failure. This means that we cannot also derive Failure.
18:37:34 <ihope> ...I just disproved what I was trying to prove, didn't I?
18:46:06 <dylan> @hoogle FilePath -> IO Bool
18:46:07 <lambdabot> Directory.doesDirectoryExist :: FilePath -> IO Bool
18:46:07 <lambdabot> Directory.doesFileExist :: FilePath -> IO Bool
18:53:49 <LordBrain> Monads have to be able to contain anything right? hmmm
18:54:00 <kpreid> yes
18:54:28 <kpreid> well, there's nothing stopping you from:
18:55:27 <kpreid> class Monad Foo where return x = fromJust $ Data.Typeable.cast x (typeOf (undefined :: Bar)) :: Bar
18:55:52 <kpreid> then you can only return Bars, but the type system doesn't know that
18:56:02 <ihope> Evil.
18:56:33 <musasabi> and will probably cause endless problems.
18:56:43 <LordBrain> lol
18:56:56 <LordBrain> thats clever.. but i'm not ready for that
18:57:27 <kpreid> why do you think you might want this?
18:57:36 <LordBrain> oh i dont
18:58:20 <musasabi> class Monad m where return :: MV m a => a -> m a; (>>=) :: (MV m a, MV m b) => m a -> (a -> m b) -> m b
18:58:32 <musasabi> class MV a b | a -> b
18:58:45 <LordBrain> Is it possible that something can be a member of MonadState, without being a Monad?
18:58:48 <musasabi> but GHC does not accept that yet (-fc branch)
18:59:09 <LordBrain> er instance
18:59:31 <ihope> musasabi: why would it accept that?
18:59:54 <musasabi> LordBrain: "class Monad m => MonadState s (m::* -> *) | m -> s where ..."
19:01:29 <musasabi> ihope: point - the MV class is wrong.
19:02:33 <LordBrain> hmm
19:02:44 <LordBrain> i didnt know ghc did anything with kinds
19:02:50 <musasabi> with "MV (m a) a" and instance like "instance Show a => MV (MyMonad a) a" it would work.
19:03:33 <musasabi> (that is when the System FC changes are in)
19:03:51 <vininim> Is opengl and openal support in ghc portable? ie: I can compile in any system that supports it, and it will work as expected.
19:04:12 <LordBrain> i wanted to do a sort of wrapped inplace state updating.. but i think its impossible
19:04:53 <LordBrain> well....
19:05:28 <LordBrain> I suppose there's nothing wrong with me making a non-monad get,put interface
19:05:39 <LordBrain> thats probably what i should have done
19:05:58 <LordBrain> i've been trying for too long to do something that is impossible...
19:06:06 <LordBrain> lol
19:06:46 <LordBrain> its impossible because the thing contained, a, would have to be in the IO monad
19:07:04 <musasabi> LordBrain: are you having actual performance problems?
19:07:11 <LordBrain> no, its all just an exercise
19:07:46 <SamB_XP> what? you need a performance problem before you can break out mutable stuff?
19:08:24 <LordBrain> oh actualy tehre was indeed a performance problem in hugs
19:08:36 <LordBrain> it used up my ram
19:08:41 <musasabi> SamB_XP: no. Mutable stuff just causes bugs and often "nicest" and "fastest" alternative look very different.
19:10:27 <Cale> Not just less than 3, but much less.
19:10:31 <Cale> oops
19:10:44 <LordBrain> musasabi: i guess i wanted a general way to switch out immutable state implementations with mutable ones.. that way maybe i can contain whatever bugs by keeping them within the implementation code for the abstract interface
19:13:00 <musasabi> What do you mean with mutable in this context? Just in-place updates instead of State but working the exact same way?
19:13:09 <LordBrain> yes
19:13:21 <LordBrain> ideally
19:14:50 <LordBrain> It's not so easy.. but it would be a cool thing, wouldnt it?
19:15:33 <LordBrain> i suppose suppose i should learn template haskell
19:15:50 <SamB> is it better to allocate the variable on the heap than on the stack?
19:16:11 <LordBrain> i dont think so SamB, of course thats archetecture dependent
19:16:20 <LordBrain> i think the Stack is better
19:16:39 <LordBrain> because of the caching... if i recall right
19:16:40 <SamB> well I think thats about what switching from State to an IORef would get you ;-)
19:16:51 <SamB> heap allocation, I meant
19:16:52 <LordBrain> yeah
19:17:08 <LordBrain> that's not all it would do tho..
19:17:40 <LordBrain> basicly... before the switch, i'm making more stuff to be cleaned up by the garbage collector
19:18:04 <musasabi> one can do such things
19:18:05 <LordBrain> an IORef i would assume would not do that
19:18:11 <SamB> heh
19:18:37 <musasabi> http://youzen.b2.fi/~musasabi/rios.hs
19:18:40 <SamB> the values referenced by the IORef would also need GCing
19:18:58 <LordBrain> let me think about that
19:19:08 <LordBrain> i'm not quite seeing it
19:19:20 <musasabi> In realistic situations you want to have IORefs inside the state record, and not outside it most of the time.
19:19:36 <LordBrain> musasabi: i already switched that actually
19:19:50 <LordBrain> but... why do you say that?
19:20:29 <LordBrain> i must have done a lot of nutty stuff the past few hours because i didnt stop to consider whether what i wanted to do was actually possible.
19:21:16 <musasabi> LordBrain: it depends entirely what you are doing. Most of the time it makes little sense to have the toplevel mutable when one really wants to have small pieces inside it mutable - thus avoiding having to copy the state when modifying it.
19:21:33 <LordBrain> yeah
19:21:34 <LordBrain> ok
19:21:53 <LordBrain> Anyway, why would the IORef approach make lots of garbage collection, i'm not getting that...
19:22:36 <LordBrain> i would an IORef Int, would only take one word-size of memory, more or less, ever.
19:22:51 <SamB> uh, no!
19:22:58 <LordBrain> why?
19:23:09 <int-e> musasabi: Hmm, do you think there's any chance of getting modify into the MonadState dictionary?
19:23:34 <LordBrain> once you modify the IORef, you garbage collect the old value, you never leave a trail
19:23:41 <LordBrain> and
19:23:55 <LordBrain> i naively would have assumed in fact that the IORefs would be updated in place.
19:24:07 <musasabi> int-e: modifyM would be much nicer. (and since modify can be implemented quite well with get+put)
19:24:09 <SamB> they are references -- they don't actually store the values
19:24:33 <musasabi> LordBrain: IORef (Int,Int,Int,Int) vs (IORef Int, IORef Int, IORef Int, IORef Int)
19:24:41 <LordBrain> yes i understand musasabi
19:25:04 <int-e> musasabi: I know it can be implemented in terms of get and put - but in some cases (MVar comes to mind, I guess there are others) modify is the actual fundamental operation.
19:25:04 <musasabi> everything inside the IORef is immutable. Just the IORef is mutable.
19:25:19 <LordBrain> hmmmmm
19:25:22 <LordBrain> ok
19:25:25 <vincenz> http://jaortega.wordpress.com/2006/03/17/programmers-go-bananas/#comment-125
19:25:26 <vincenz> heh
19:25:27 <LordBrain> that's not what i would have expected
19:25:46 <LordBrain> only because i was ignorant
19:25:48 <musasabi> int-e: I don't think MVars make sense for MonadState
19:25:49 <LordBrain> i suppose
19:26:26 <SamB> MVar has several atomic operations
19:26:53 <LordBrain> so are there such things as IOInts or something like that?
19:26:57 <musasabi> int-e: with MonadState I would expect "put x >> put x" to be identical to "put x"
19:26:58 <int-e> take and put ... sorry. but read is derived.
19:27:31 <int-e> musasabi: na, I wanted to make get = readMVar and put = writeMVar.
19:27:39 <musasabi> LordBrain: there are things like FastMutableInt and unboxed mutable arrays, but in general IORef Int is often fast enough.
19:28:07 <int-e> musasabi: pretty much what the IORef does, but with guaranteed thread-safety (which IORef, I believe, doesn't have?)
19:28:48 <musasabi> IORef is not thread safe.
19:28:59 <musasabi> (but there is atomicModifyIORef)
19:29:02 <LordBrain> but, if this is true, and i dont doubt you.. then there would be just as much garbage collection with the IORefs, and i would still run out of memory in hugs
19:29:24 <LordBrain> well... thats ok, i can just use TVars
19:29:30 <musasabi> int-e: writeMVar?
19:29:32 <SamB_XP> well, IORef might not leak the same way
19:30:11 <LordBrain> anyway, its good i get clarified about these little details
19:30:38 <LordBrain> hmmm is the leak just a bug in teh garbage collector?
19:30:40 <SamB_XP> takeMVar and putMVar, maybe you meant?
19:30:44 <int-e> musasabi: writeMVar m v = modifyMVar m (const (return v)) I guess. A counterpart to readMVar. Hmm.
19:30:45 <musasabi> int-e: with GHC IORefs are safe as long as you have only one writer in practice.
19:31:07 <SamB_XP> oh, no.
19:31:11 <SamB_XP> that makes no sense...
19:31:24 <int-e> maybe not.
19:31:24 <LordBrain> it seems like to me, IORefs and MVars are both sort of obsoleted by TVars and the STM monad... But maybe thats just me
19:31:31 <SamB_XP> but why would you want this anyway?
19:31:41 <SamB_XP> I don't think MonadState code is threadsafe
19:31:55 <LordBrain> it's not?
19:32:04 <emertens> monadstate has nothing to do with thread safety
19:32:04 <musasabi> SamB_XP: MonadState code is.
19:32:05 <SamB_XP> well none of mine is ;-)
19:32:27 <SamB_XP> I think it would be a pain to write MonadState code that was threadsafe
19:32:34 <musasabi> SamB_XP: what are you doing with it? (or we are using very different definitions)
19:32:35 <int-e> SamB_XP: I know I wanted it once. I'm not sure that's true anymore.
19:32:36 <LordBrain> really?
19:32:56 <LordBrain> it surprises me that MonadState would make my program not thread safe
19:32:58 <musasabi> The state is not shared between threads so it is a non-issue mostly.
19:33:04 <SamB_XP> oh.
19:33:05 <LordBrain> yeah
19:33:15 <SamB_XP> so what is the point of an MVar if the state isn't shared between threads?
19:33:18 <LordBrain> its not shared...
19:33:43 <LordBrain> MVars are shared.. but what do they have to do with Monad State?
19:33:45 <emertens> there is no reason to use an mvar in a single threaded situation
19:33:49 <musasabi> SamB_XP: an evil hack which won't work with MonadState in the current form.
19:33:53 <LordBrain> MonadState rather
19:33:57 <emertens> (that I know of at least)
19:37:15 <musasabi> STM is new and can replace parts of the old abstractions, but mixing STM and IO can be hard and there is not enough experience on best practices to make it an universal solution.
19:37:19 <int-e> SamB_XP: Because it's fine as long as you only take snapshots (using get = readMVar) but the rest of MonadState becomes dangerous. Hmm.
19:37:49 <LordBrain> conjure, the bittorrent client uses STM and IO
19:37:50 <emertens> you can't do IO at all inside STM
19:38:02 <LordBrain> well yes it doesnt do IO inside STM
19:38:25 <SamB_XP> well you CAN but you better just be doing it for debugging...
19:38:31 <LordBrain> i think that's part of the point, we dont want launch missles inside our STM action
19:38:35 <musasabi> emertens: there is unsafeIOToSTM
19:38:38 <SamB_XP> and definately don't try to do more STM from the IO
19:39:05 <emertens> fine, you *can* do IO, but it is intentionally difficult
19:39:16 * musasabi does lots of dirty IO inside STM, just have to be ready to handle replays etc
19:39:40 <LordBrain> you mean retrys?
19:39:43 <SamB_XP> rollbacks too
19:39:50 <musasabi> SamB_XP: yes.
19:40:58 <int-e> MVars are nice and simple ;)
19:42:15 <LordBrain> what's the M stand for?
19:42:20 <LordBrain> Mutable?
19:42:25 <LordBrain> Mutex?
19:42:26 <SamB_XP> Maybe?
19:42:29 <emertens> mutex?
19:42:37 <SamB_XP> Multithreaded?
19:42:39 <LordBrain> probably mutex, that makes sense
19:42:42 <emertens> magic?
19:42:52 <SamB_XP> MM MM good?
19:42:56 <LordBrain> lol
19:43:25 <LordBrain> mvars are lock based right?
19:43:35 <SamB_XP> huh?
19:43:50 <SamB_XP> I suppose they are pretty much mutexes...
19:43:51 <LordBrain> if i know my terminology, the word mutex implies locking
19:43:56 <SamB_XP> of a crazy type...
19:43:58 <emertens> attempting to read an empty mvar or write a full mvar is a blocking operation
19:44:37 <LordBrain> right
19:44:54 <SamB_XP> at least, takeMVar and putMVar block
19:45:03 <SamB_XP> as well as that modifyMVar or whatever it is called
19:45:29 <int-e> tryTakeMVar is the exception
19:45:39 <musasabi> There is a good introductory paper on them
19:45:40 <int-e> oh, and truPutMVar
19:45:44 <int-e> *try
19:46:04 * SamB_XP can't imagine the point of that last one
19:46:39 <LordBrain> are they obsolete tho?
19:46:42 <musasabi> tryPutMVar is useful
19:46:45 <LordBrain> now that we have TVars?
19:46:51 <int-e> no
19:46:51 <SamB_XP> nonono
19:46:53 <musasabi> LordBrain: no.
19:47:15 <int-e> they can be used in the plain IO monad, so they do something different.
19:47:16 <LordBrain> i thought you could implement an mvar as a tvar
19:47:23 <musasabi> Different purposes. For some purposes one can use TVars instead of MVars, for some purposes MVars are still the best.
19:47:33 <LordBrain> hmmm
19:47:53 <musasabi> LordBrain: one *could*. That does not make it the best route.
19:48:05 <LordBrain> why not?
19:48:13 <LordBrain> i do that so i dont forget how
19:48:14 <musasabi> things like performance.
19:48:15 <LordBrain> haha
19:48:19 <int-e> mvars don't need any rollbacks
19:48:25 <LordBrain> oh how practical of you :)
19:49:44 <musasabi> LordBrain: see http://www.haskell.org/ghc/dist/current/docs/libraries/stm/Control-Concurrent-STM-TMVar.html for the same interface as MVars except implemented with TVars.
19:50:30 <LordBrain> why am i looking at that?
19:50:53 <LordBrain> technically, the interface is slightly different because there are Ts
19:50:58 <LordBrain> hehe
19:51:18 <int-e> and work within STM
19:51:36 <LordBrain> yeah
19:51:38 <musasabi> and one could wrap each of those in "atomically" and it would be MVars. Except much slower.
19:51:57 <LordBrain> because of the logging?
19:52:09 <LordBrain> why are they slower?
19:52:24 <musasabi> Transactions add overhead.
19:53:20 <LordBrain> so, basicly i should use mvars unless i find i need more control?
19:54:21 <musasabi> Use the one which makes the code most readable and simple.
19:54:26 <emertens> they each provide different functionality
19:54:30 <emertens> so... use the one that fits best
19:54:41 <LordBrain> stm for composing...
19:55:59 <LordBrain> alright, here's a question for conjure coders, why did you decide to use STM for your app?
19:56:26 <LordBrain> as opposed to just mvars
19:56:49 <musasabi> (fancy concurrency with lots of data dependencies -> STM, non-trivial amounts of IO -> MVar)
19:56:53 <ihope> "Malformed constructor signature: Not (Not a) :- a"
19:57:02 <ihope> What's malformed about that?
19:57:35 <int-e> STM promises that there won't be any deadlocks. So yes, lots of data dependencies.
19:57:47 <int-e> <-- not a conjure developer.
19:58:00 <musasabi> (neither a conjure developer)
19:58:02 <LordBrain> ihope: maybe your computer is of the constructionist sentament and sheds reductio absurdum
19:58:22 <LordBrain> well SamB is
19:58:25 <LordBrain> :D
19:58:32 <ihope> LordBrain: that's elimination of double negation.
19:58:42 <LordBrain> oh
19:58:47 <LordBrain> true
19:59:30 <ihope> Reductio ad absurdum is the definition of Not, which hopefully is stronger than Djinn's Not.
20:00:19 <LordBrain> definition of Not?
20:00:28 <LordBrain> hmmm
20:00:28 <emertens> @hoogle Not
20:00:29 <lambdabot> Prelude.not :: Bool -> Bool
20:00:30 <lambdabot> Prelude.Nothing :: Maybe a
20:00:30 <lambdabot> Network.Socket.NotConnected :: SocketStatus
20:00:30 <LordBrain> yeah
20:00:59 <ihope> data Not a where ReductioAdAbsurdum :: (p :- q) -> (p :- Not q) -> Not p
20:01:24 <LordBrain> right
20:01:26 <ihope> Where :- is a weaker implication, which includes elimination of double negation as part of its definition.
20:02:05 <LordBrain> but the constructivists throw out eliminations of double negations, do they not?
20:02:11 <ihope> I'm still not convinced that double negation is required.
20:02:24 <ihope> Elimination of it, rather.
20:02:33 <emertens> I thought that was "intuitive" logic
20:02:33 <LordBrain> required for what?
20:02:59 <ihope> Required to be propositional calculus or whatever that's called.
20:03:30 <ihope> That is, I'm not sure whether or not there's a Not (Not a) -> a.
20:04:05 <LordBrain> so you yourself are in the constructivist camp?
20:04:16 <emertens> does anyone have the link to the pdf whose title is similar to: "Lecture notes for the curry-howard isomorphism"?
20:04:21 <LordBrain> or a sympathizer at least
20:05:17 * SamB_XP forgets who decided to use STM for conjure
20:05:24 <SamB_XP> it might have been jlouis
20:05:36 <SamB_XP> or however the name is spelled
20:05:55 <LordBrain> http://licomr.org/2002_8/workshop2002s/curryHoward.pdf
20:06:25 <LordBrain> that?
20:06:34 <ihope> I'm going to include double negation somehow no matter what the constructivists say.
20:06:42 <emertens> http://folli.loria.fr/cds/1999/library/pdf/curry-howard.pdf was what i was looking for
20:07:02 <emertens> LordBrain:  but have you read that paper that you linked to? do you recommend it?
20:07:21 <LordBrain> i havent read it, i just thought i'd try a search
20:08:15 <LordBrain> it has a higher google index or whatever you call it
20:09:57 <dons> ?yow
20:09:58 <lambdabot> We have DIFFERENT amounts of HAIR --
20:10:26 <vininim> o_O
20:13:03 <LordBrain> :)
20:13:17 <LordBrain> what is "yow" ?
20:14:51 <Cale> quotes from Zippy the Pinhead
20:15:18 <Cale> @yow
20:15:19 <lambdabot> I'm gliding over a NUCLEAR WASTE DUMP near ATLANTA, Georgia!!
20:15:22 <LordBrain> is Zippy famous?
20:15:27 <Cale> @yow
20:15:27 <lambdabot> Wow!  Look!!  A stray meatball!!  Let's interview it!
20:15:29 <Cale> yes
20:15:54 <LordBrain> @google "Zippy the Pinhead"
20:15:57 <lambdabot> http://www.zippythepinhead.com/
20:15:57 <lambdabot> Title: Zippy the Pinhead
20:17:29 <LordBrain> hmmm that cartoon setting looks like the library at UC Davis.
20:17:55 <LordBrain> with the big egg heads
20:18:35 <LordBrain> is that a famous work of art?
20:26:27 <tbon> hi
20:26:35 <tbon> wat is lazy evaluation?
20:26:41 <SamB_XP> well...
20:26:49 <SamB_XP> > head [1..]
20:26:51 <lambdabot>  1
20:27:02 <SamB_XP> you can't do that without it ;-)
20:27:22 <SamB_XP> well, maybe you can...
20:27:27 <SamB_XP> but not like this you can't
20:27:35 <SamB_XP> > head [1..] :: Integer
20:27:36 <lambdabot>  1
20:28:11 <SamB_XP> that takes the first element of an infinite list
20:28:31 <Korollary> @google wikipedia lazy evaluation
20:28:33 <lambdabot> http://en.wikipedia.org/wiki/Lazy_evaluation
20:28:37 <int-e> The Koan of Lazy Evaluation
20:28:37 <int-e> Michel Mauny was giving a guest lecture to new computer science students. After the students were seated, Michel pronounced: "Today's lecture will be about Lazy Evaluation".
20:28:37 <int-e> He paused for a moment, and then concluded with: "Are there any questions?"
20:28:38 <LordBrain> in math you deal with infinite sets, without having to specify each and every element, you just grab as many as you need in the context... lazy evaluation is the computer version of that.
20:28:41 <SamB_XP> > let greeting = "hello " ++ greeting in hello
20:28:42 <lambdabot>  Not in scope: `hello'
20:28:44 <dons> tbon: hmm. a huge topic. in one line: expressions aren't evaluated until their results are needed (if ever)
20:28:47 <Korollary> int-e: cute
20:28:49 <SamB_XP> oops
20:28:53 <SamB_XP> > let greeting = "hello " ++ greeting in greeting
20:28:55 <lambdabot>  "hello hello hello hello hello hello hello hello hello hello hello hello hel...
20:29:14 <SamB_XP> int-e: I like I like ;-)
20:29:36 <dons> > head [1..] :: Integer -- illustrates laziness. an infinite list is constructed, but never evaluated. instead, only the bit of it that is needed is taken
20:29:38 <lambdabot>  1
20:29:51 <dons> tbon: questions?
20:30:12 <dons> in a _strict_ language, you can't generally build infinite structures like this
20:30:44 <dons> since computing them would cause the program to diverge/not terminate. this isn't a problem in a lazy language-- hence, you can write a new class of programs
20:30:57 <SamB_XP> not to mention most strict languages don't even have syntax like [1..]
20:31:07 <LordBrain> Suppose humans couldnt do the cognitive equivalent of lazy evaluation, we wouldnt have things like square root of 2 as an exact number in our theories... as soon as it came up we would be stuck calculating it forever, because we cant make any more statements about it until we have reached the end.
20:31:24 <dons> yes. humans use lazy evaluation all the time
20:31:43 <dons> we stick in our heads place holders for facts, that may never be evaluated
20:31:51 <LordBrain> yeah
20:31:58 <SamB_XP> some of us are even just plain lazy ;-)
20:31:59 <dons> when they are needed (we call this an "exam") the brain goes crazy forcing all its values
20:32:08 <SamB_XP> hehe
20:32:10 <LordBrain> lol
20:32:17 <SamB_XP> this is why we have "homework"
20:32:23 <dons> that is, exam == deepSeq
20:32:32 <dons> and hence, we see why exams are evil
20:32:35 <SamB_XP> homework == shallowSeq ;-)
20:32:50 <dons> yep, perhaps just WHNF.
20:33:00 <SamB_XP> that one is just seq
20:33:07 <dons> enough to get by, until someone asks another question
20:33:11 <SamB_XP> but I have a very strong head
20:33:23 <SamB_XP> I was hit on the head with a brick once and I'm still smart ;-)
20:33:40 <SamB_XP> I'm not normal either
20:33:48 <dons> seems like ;)
20:33:59 <dons> tbon: questions? running away?
20:34:11 <dons> ?foldoc lazy evaluation
20:34:14 <lambdabot> No match for "lazy".
20:34:15 <lambdabot>  
20:34:15 <lambdabot> *** "evaluation" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
20:34:15 <lambdabot> evaluation
20:34:15 <lambdabot>  
20:34:17 <lambdabot> [9 @more lines]
20:34:20 <dons> no thanks.
20:34:25 <dons> ?foldoc laziness
20:34:27 <lambdabot> *** "laziness" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
20:34:28 <lambdabot> laziness
20:34:28 <lambdabot>  
20:34:28 <lambdabot>     {lazy evaluation}
20:34:28 <lambdabot>  
20:34:35 <SamB_XP> @vixen do you like lazy evaluation
20:34:36 <lambdabot> yah, i like
20:34:44 <SamB_XP> @foldoc "lazy evaluation"
20:34:45 <LordBrain> maybe if you quote it
20:34:46 <lambdabot> *** "lazy evaluation" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
20:34:46 <lambdabot> lazy evaluation
20:34:46 <lambdabot>  
20:34:46 <lambdabot>     <reduction> An {evaluation strategy} combining {normal order
20:34:46 <lambdabot>     evaluation} with updating.  Under normal order evaluation
20:34:48 <lambdabot> [33 @more lines]
20:34:49 <LordBrain> yeah
20:34:56 <dons> ?more
20:34:57 <lambdabot>     (outermost or call-by-name evaluation) an expression is
20:34:57 <lambdabot>     evaluated only when its value is needed in order for the
20:34:57 <lambdabot>     program to return (the next part of) its result.  Updating
20:34:57 <lambdabot>     means that if an expression's value is needed more than once
20:34:58 <lambdabot>     (i.e. it is shared), the result of the first evaluation is
20:35:00 <lambdabot> [28 @more lines]
20:35:29 <dons> that'll do. it raises sharing as well. which is a benefit you get. you need not recompute results
20:36:16 <SamB_XP> btw, WHNF stands for "weak head normal form"
20:36:17 <LordBrain> hmmm why does it raise sharing?
20:36:32 <SamB_XP> LordBrain: because of Full Laziness, maybe
20:37:52 <Korollary> call-by-need implies sharing. call-by-name doesnt
20:40:46 <dons> so, what's new in haskell today?
20:41:45 <LordBrain> let me see if i understand the terms, sharing and not recomputing results is redundant ?
20:42:37 <LordBrain> ie they're the same by definition?
20:42:51 <dons> they seem like synonyms to me. to really get a handle on this stuff, best to look at some of the early papers and tutorials on haskell
20:43:03 <dons> spj's online textbook, for example
20:43:19 <dons> and launchbury's natural semantics for lazy eval paper
20:43:57 <dons> we should have a course where we write a compiler for a lazy language in, say, 6 weeks
20:44:51 <dons> including rts, sharing and all
20:46:21 <jgrimes> that would be fun
20:46:27 <LordBrain> dons, i was thinking about the tutorial. I started writing it, and the way its going is toward a sort of general practical haskell tutorial.. The idea being, re-use the first chapter, and then branch off in different directions to learn different libraries.  Any opinions on that approach?
20:46:51 <dons> that seems reasonble
20:47:52 <LordBrain> like i put it up on the wiki, and it will have the format specified at the beginning so people could add chapters for say gtk2hs or a graphics library or what not.. where everything takes a plain haskell program from chapter 1 and polishes it up.
20:48:18 <dons> oh, that's nice. yes. i like that
20:48:20 <LordBrain> puts a new UI on it, or modifies it using a library binding in some way
20:48:32 <dons> yea. curses, console, gtk2hs...
20:48:37 <LordBrain> yeah
20:48:43 <dons> so a nice simple program. a game perhaps?
20:49:08 <LordBrain> well, i had like 3 ideas for sample programs
20:49:23 <dons> yeah?
20:50:30 <LordBrain> the bouncing ball, the contacts manager (except i'll work backwards to remove it's curses interface), and maybe a chatserver/client... just because thats what i've done lately, i already made a server.
20:50:55 <dons> yeah, i think at least start with a nice functional specification
20:50:58 <LordBrain> and i wanted to make a curses client in the first place.. thats what got me into hscurses programming
20:51:10 <dons> and then glue that to a ui
20:51:15 <dons> right
20:51:16 <LordBrain> yeah
20:51:50 <LordBrain> not just that.. but i can see how hs-plugins could be illustrated too
20:51:52 <tbon> so haskell is different from lisp?
20:52:08 <tbon> lazy makes macro not needed?
20:52:11 <LordBrain> its nicer on the eyes
20:52:19 <LordBrain> haskell is nicer on teh eyes than lisp imo
20:52:20 <dons> tbon: exactly
20:52:32 <tbon> how abut vs APL
20:52:34 <dons> its different from lisp, in that we have a type system to check errors when we compile the code
20:52:40 <LordBrain> yeah that too
20:52:46 <dons> and laziness (and higher order functions) means we don't need macros
20:52:50 <LordBrain> yeah
20:52:52 <tbon> !!
20:52:54 <tbon> really?
20:52:58 <dons> right
20:52:58 <tbon> no need fo macro?
20:53:00 <tbon> !
20:53:06 <tbon> woa
20:53:10 <LordBrain> well we do have template haskell so there must be some kind of need
20:53:32 <dons> but for, say, new control structures, you just define a new higher order function
20:53:34 <LordBrain> not that've use it...
20:53:42 <LordBrain> yeah
20:53:46 <tbon> thx
20:53:48 <dons> template haskell is more for large code generation problems
20:53:58 <dons> instead of using a preprocessor
20:54:09 <jcreigh> dons: Seriously? I'm a newbie to both Haskell and Lisp, but it seems like there must be something that macros express more cleanly than laziness...
20:54:26 <jcreigh> dons: "seriously?" re: "we don't need macros"
20:54:42 <dons> perhaps. i'm not sure. i'd imagine that a macro system would be strictly more powerful
20:54:51 <dons> but in practice we don't seem to need such features
20:55:09 <dons> and the benefit of defining new control structures _in_ the language,is huge
20:55:09 <LordBrain> in practice yeah... i've never used a macro
20:55:30 <dons> so no need for, say, special syntax (or macros) for imperative control structures
20:55:45 <dons> you just write a function: forever a = a >> forever a
20:56:12 <dons> or, foreach ls a = (flip mapM_ ) ls a
20:56:17 <SamB_XP> "power" is sometimes overrated
20:57:01 <dons> for real code generation games, we use a preprocessor or template haskell. but for everyday 'macro' stuff, a haskell hacker would just roll a new higher order function
20:57:03 <LordBrain> that forever idiom maybe is the preferred haskell way to do io actions which loop forever? and just have a thread that exits on a certain kind of input?
20:57:17 <dons> LordBrain: I think so
20:57:35 <LordBrain> ok
20:57:45 <LordBrain> i'm going to use it, so i hope you dont have a trademark
20:57:52 <LordBrain> :D
20:58:08 <monochrom> Yeah, I have "forever whatever".  Inside whatever some point may throw an EOF exception.
20:58:10 <dons> no, its free for use throughout the known universe
20:58:36 <monochrom> We don't trademark ideas. We patent them.
20:59:11 <LordBrain> ok
20:59:12 <monochrom> Did you know: someone patented the do notation, and every time you use it you'll ...
20:59:17 <SamB_XP> monochrom: you could trademark the function name ;-)
20:59:23 <LordBrain> yeah
20:59:33 <SamB_XP> maybe only with the type signature
21:00:08 <monochrom> I think "forever" per se is not trademarkable.  Has to be along the line of "perpetucia".
21:00:08 <dons> jcreigh: you really feel the benefit of the hof-approach to defining new control structures as you use haskell more and more. i particularly like the withFoo/finally/bracket style of safely accessing a resource
21:00:20 <SamB_XP> @type forever where forever x = w where w = x >> w
21:00:22 <lambdabot> parse error on input `where'
21:00:31 <SamB_XP> @type let forever x = w where w = x >> w in forever
21:00:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
21:01:22 <LordBrain> couldnt you just say
21:01:32 <LordBrain> @type forever where forever a = a >> forever a
21:01:33 <lambdabot> parse error on input `where'
21:01:35 <dons> ?type Control.Concurrent.withMVar -- for example, jcreigh
21:01:37 <lambdabot> forall b a. GHC.IOBase.MVar a -> (a -> IO b) -> IO b
21:01:46 <dons> ?type Control.Exception.finally -- too
21:01:47 <lambdabot> forall a b. IO a -> IO b -> IO a
21:02:36 <monochrom> So, laziness, higher-order function, the do notation, and the typeclass mechanism so you can also subject your own types to the do notation --- these seem to together cover 99% of the applications of macros.
21:03:00 <dons> that sounds about right
21:03:03 <SamB_XP> yes
21:03:05 <SamB_XP> somehow!
21:03:14 <dons> and the rest, the evil stuff, we'd use TH or a preprocessor
21:03:39 <musasabi> forever x = Control.Exception.try x >> forever x
21:03:43 <dons> so, for the nice 99%, you stay in the language, in the type system. hugely important
21:03:56 <dons> musasabi: nice variant
21:04:24 <dons> i have a, forever fn = catch (repeatM_ fn) handler
21:04:29 <jcreigh> dons: Oh! Are macros inconsistent/hard to do with strong typing?
21:05:01 <dons> well, its a meta programming system, isn't it? there hard in general to type. not inconsistent though -- see TH
21:05:11 <SamB_XP> generally macros aren't typechecked until you use them
21:05:12 <dons> just hard
21:05:23 <musasabi> TH can be used to do unsafe things
21:05:36 <SamB_XP> musasabi: so can a lot of things
21:05:47 <SamB_XP> TH just happens to make some of them a little safer
21:06:09 <dons> ?localtime musasabi
21:06:11 <lambdabot> Local time for musasabi is Wed Aug  2 07:05:48 2006
21:06:26 <musasabi> evening it is.
21:06:36 <dons> :)
21:06:50 <musasabi> SamB_XP: like avoiding pesky modules trying to export datatypes as opaque? ;)
21:07:00 <monochrom> There are replicateM and replicateM_ !  I be damned!  (But there is no repeatM)
21:07:07 <SamB_XP> musasabi: something along those lines
21:07:18 <dons> monochrom: its a mystery
21:07:45 <dons> ?type sequence_ . repeat
21:07:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
21:07:51 <SamB_XP> I mean, it is much safer to be able to retrieve the constructors with TH than to try and unsafeCoerce# to a copy/pasted type
21:08:13 <SamB_XP> because the module could be compiled with different optimizations
21:08:14 <monochrom> There are strictness concerns I can envision.
21:08:17 <SamB_XP> and that would be bad
21:09:04 <musasabi> ooh. I haven't used the unsafeCoerce# to different datatype and then using it for such evils before.
21:11:21 <LordBrain> i'd say learning haskell is generally more involved than other languages, but that's fine with me. (unless maybe you're coming from Clean or something)
21:11:55 <monochrom> It beats learning Turing machines.
21:12:42 <SamB_XP> musasabi: me either
21:12:59 <SamB_XP> musasabi: hs-plugins almost does ;-)
21:13:02 <dons> ?quote JohnMeacham
21:13:03 <lambdabot>  There will also be a karaoke competition to determine the fate of the monomorphism restriction.
21:13:08 <dons> ?quote John Meacham
21:13:08 <lambdabot> John Meacham hasn't said anything memorable
21:13:14 <dons> ?quote JohnMeacham
21:13:14 <lambdabot>  There will also be a karaoke competition to determine the fate of the monomorphism restriction.
21:13:23 <SamB_XP> I love that
21:13:31 <Korollary> Didnt you save the vending machine quote yesterday?
21:13:46 <SamB_XP> @quote JohnMeacham
21:13:46 <monochrom> I want to see the vending machine quote!
21:13:47 <lambdabot>  I liken learning haskell to tipping over a vending machine. you can't just push it, you gotta rock it back and forth a few times building up momentum until bam! suddenly the flash of insight hits
21:13:47 <lambdabot> and it all makes sense.
21:13:51 <dons> ah :)
21:14:02 <monochrom> Nice.
21:14:05 <SamB_XP> they are randomized, remember?
21:14:07 <dons> [and you get free candy]
21:14:22 <Korollary> They should be shuffled and then picked imho. That would prevent repeats.
21:14:35 <LordBrain> i suspect that some things which wouldnt normally be part of a language are in haskell, like monads as design patterns sorta... so you get a bit of an extra benefit from the learning and maybe its actually less compared in totality.
21:15:05 <SamB_XP> well, the only thing that makes monads a part of the language proper is the do notation
21:15:18 <Korollary> and main
21:15:26 <SamB_XP> well...
21:15:35 <dons> life's too short not to code in haskell. i'd hate to waste years solving bugs that have known solutions in more sophisticated languages
21:15:40 <SamB_XP> the fact that IO is a monad is not relied on by main
21:16:06 <Korollary> the only reason anything is computed is because somebody wants main's IO actions, tho
21:16:50 <SamB_XP> I stand by my distinction between IO and monads
21:17:36 <SamB_XP> for instance:
21:18:04 <SamB_XP> main = putStrLn "Hello, World!" does not use any Monad methods directly. nevermind how putStrLn is implemented ;-)
21:18:24 <monochrom> The latest http library is self-contained?!
21:18:37 <monochrom> Oh, yes, it's said so.
21:18:40 <Cale> SamB: well, main is of type IO a for some a, and IO is a monadic type.
21:18:50 <SamB_XP> Cale: that is incidental
21:18:54 <SamB_XP> that is part of the library ;-)
21:18:57 <LordBrain> what was the dependency before?
21:18:59 <Cale> But sure, you could use some other combinator structure.
21:19:09 <Korollary> Well, if you are not going to sequence actions, surely you don't need anything complicated.
21:19:30 <RyanT5000> SamB_XP: neither does [1]
21:19:34 <RyanT5000> but that's a monad
21:19:35 <monochrom> Needed the person to install Crypto and NewBinary separately.
21:19:57 <RyanT5000> (it doesn't directly use any monad functions, i mean)
21:20:04 <SamB_XP> RyanT5000: it is, sure
21:20:05 <Cale> SamB_XP: The thing is, the monadic interface is the only one that's provided for combining IO actions initially
21:20:10 <SamB_XP> but that is also part of the library
21:20:26 <SamB_XP> Cale: still, not part of the language but part of the library ;-)
21:20:34 <Cale> The Prelude is part of the language spec.
21:20:45 <SamB_XP> I still say it is a library
21:20:50 <RyanT5000> SamB_XP: are you saying main shouldn't be defined to be a monadic type?
21:20:59 <RyanT5000> but rather some amorphous "IOAction" type?
21:20:59 <SamB_XP> RyanT5000: no.
21:21:08 <SamB_XP> Just that the monadness comes from the library
21:21:17 <LordBrain> simple haskell programs can be read by people who dont understand monads, because they look imperative with do notation.. but when those people go to write programs, they run into that little bump because they didnt know actions were always a->M b
21:21:31 <Cale> SamB_XP: Okay, write a program that gets a line from the user and prints it back without using any monadic combinators anywhere in your program.
21:21:52 <Cale> (or do-notation, of course :)
21:22:01 <SamB_XP> hmmhmm
21:22:05 <LordBrain> he'll write it in C and then use the FFI
21:22:09 <LordBrain> lol
21:22:14 <Cale> heh
21:22:15 <SamB_XP> interact (take 1)?
21:22:20 <monochrom> main = interact id
21:22:23 <Korollary> use system "perl -e ..."
21:22:28 <LordBrain> lol
21:22:44 <dons> ?type interact
21:22:45 <lambdabot> (String -> String) -> IO ()
21:22:52 <SamB_XP> oh
21:22:55 <SamB_XP> right then
21:22:55 <Cale> fair enough :)
21:23:03 <LordBrain> aha got you
21:23:07 <LordBrain> hehe
21:23:08 <RyanT5000> well monads aren't necessarily the only way to sequence things
21:23:09 <SamB_XP> interact (unlines . take 1 . lines)?
21:23:25 <RyanT5000> i think you could make an arrowic IO
21:23:32 <dons> RyanT5000: right. you can sequence be writing nested lets or nested case
21:23:34 <RyanT5000> which would allow implicit multithreading, i think
21:23:47 <monochrom> If you prescribe "open 10 files and sort them and merge them and pick out duplicates and match some regex and do some STM", the interact trick will fail.
21:24:03 <RyanT5000> dons: i'm not sure that helps, becuase then you need side-effects
21:24:08 <monochrom> Oh, throw in "do some time drift" :)
21:24:18 <LordBrain> hmmm arrows might actually be easier for new haskellers although clumsier
21:24:18 <SamB_XP> monochrom: I'd like to see you do that in C without libc sometime ;-)
21:24:44 <Korollary> let's do that without an OS.
21:24:46 <SamB_XP> LordBrain: doubt it
21:24:54 <SamB_XP> Korollary: yeah! thats the spirit!
21:25:09 <Korollary> Pure BIOS calls
21:25:11 <monochrom> You people are crazy.
21:25:15 <musasabi> LordBrain: actually many parts of Haskell are only in the library. e.g. monads don't have any language support.
21:25:21 <RyanT5000> LordBrain: i also doubt it, but mostly because using text to write arrows is overly difficult
21:25:33 <RyanT5000> pure bios calls are not really all that hard
21:25:34 <SamB_XP> I say anything that has working code in the example Prelude is not part of the language
21:25:36 <jcreigh> Korollary: BIOS? Naw, just talk to the hard drive controller directly...
21:25:52 * Korollary inserts obligatory Granpa Simpson quote
21:25:59 <monochrom> arrowic IO is done
21:26:16 <monochrom> in fact arrowic <insert any monad here> is done
21:26:22 <SamB_XP> heh
21:26:24 <LordBrain> you cant do pure bios calls in a modern os tho can you?
21:26:24 <musasabi> arrows are not nice for text-based programming.
21:26:38 <SamB_XP> LordBrain: he already said to do it without the OS
21:26:41 <musasabi> (if monads are an alternative)
21:26:42 <int-e> LordBrain: if you are the kernel, you can.
21:26:43 <monochrom> Hmm what is text-based programming?
21:26:44 <LordBrain> oh
21:26:46 <LordBrain> sorry i missed
21:26:52 <RyanT5000> LordBrain: if by "modern" you mean "protected-mode", then correct, you can't use BIOS calls
21:27:01 <SamB_XP> RyanT5000: you can't?
21:27:01 <musasabi> monochrom: writing the source in a file by hand.
21:27:08 <RyanT5000> int-e: not usually true, at least not without jumping through lots of hoops
21:27:08 <jcreigh> LordBrain: I don't think so. AFAIK, you can't really do BIOS calls on the x86 while in protected mode.
21:27:12 <jcreigh> LordBrain: Err...what RyanT5000 said..
21:27:13 <LordBrain> yeah i meant protected mode..
21:27:16 <RyanT5000> SamB_XP: definitely not from user mode
21:27:17 <SamB_XP> but you can use BIOS calls in DJGPP...
21:27:20 <int-e> there's the vm86 mode, and bios have protected mode interfaces.
21:27:37 <LordBrain> jcreigh: you mean you can only do it in real mode right?
21:27:38 <monochrom> Sorry I still don't understand.  Could you give an example?
21:27:40 <Korollary> wow. djgpp! Is that thing still alive?
21:27:41 <RyanT5000> meh, vm86 isn't really using the BIOS
21:27:53 <SamB_XP> Korollary: it still builds ZSNES
21:27:54 <int-e> sure it is
21:27:56 <RyanT5000> and i don't know all that much about pmode bioses
21:27:57 <jcreigh> LordBrain: I think so.
21:28:09 <SamB_XP> and ZSNES still does some raw INTs
21:28:16 <RyanT5000> int-e: do pmode bioses provide their own vm86 environments?
21:28:18 <int-e> (I mean, you can do it, using vm86 mode. you don't have to map the BIOS if you don't want to ...)
21:28:21 <LordBrain> yah i concurr.. i just missed the beginning when he said do it in the kernel
21:28:24 <monochrom> Gosh this conversation is quickly degenerating to Apple ][ Integer BASIC at exponential rate...
21:28:42 <LordBrain> lol
21:28:53 <RyanT5000> that's what i meant - you're using a vm environment set up by the OS rather than the actual BIOS, even though the OS may have chosen to map it to the BIOS :P
21:28:56 <monochrom> "Can you write a Haskell interpreter in BASIC? ..."
21:29:02 <RyanT5000> </stupidity>
21:29:07 <SamB_XP> can I? no.
21:29:11 <SamB_XP> can it be done?
21:29:14 <SamB_XP> probably.
21:29:19 <int-e> RyanT5000: they ask to be passed in 0-based, full-access descriptors for data and code segments I believe.
21:29:19 <RyanT5000> should it be done? absolutely not
21:29:26 <SamB_XP> haha, yeah
21:29:46 <int-e> RyanT5000: this whole discussion is x86-specific, of course.
21:29:51 <RyanT5000> right
21:30:01 <SamB_XP> int-e: other systems have BIOS?
21:30:24 <SamB_XP> don't macs have firmware or something instead?
21:30:25 <int-e> SamB_XP: I don't know. Something has to serve as a boot loader or something.
21:30:29 <Korollary> They have equivalent stuff, but the name BIOS is an IBM PC'ism
21:30:31 <jcreigh> SamB_XP: I assume so, but it's probably called something different.
21:30:38 <int-e> names, names.
21:30:43 <RyanT5000> SamB_XP: BIOS = firmware
21:30:56 <SamB_XP> RyanT5000: true enough
21:31:06 * Korollary is having a guru meditation in a red, flashing window.
21:31:10 <musasabi> http://en.wikipedia.org/wiki/OpenFirmware
21:31:12 <dgoldsmith> SamB_XP: PPC Macs have Open Firmware. Intel Macs have EFI.
21:31:16 <SamB_XP> but that doesn't mean that using the word "BIOS" doesn't establish that we are talking about PC
21:31:50 <SamB_XP> Korollary: Amiga huh?
21:31:53 <dgoldsmith> http://en.wikipedia.org/wiki/Extensible_Firmware_Interface
21:31:59 <Korollary> Yeppers
21:32:09 <SamB_XP> that runs GHC?
21:32:13 <Korollary> no
21:32:21 <Korollary> It was decades ago
21:32:25 <SamB_XP> oh
21:32:41 <RyanT5000> so i'm writing a functional RDBMS-style datastructure library; is anyone willing to take a glance at my design?
21:32:42 <SamB_XP> I was confused by the use of the term "is"
21:32:56 <Korollary> SamB_XP: I was having it myself in my head. :)
21:33:01 <RyanT5000> i've got a bunch of classes that represent traditional RDBMS ideas
21:33:15 <RyanT5000> (i can't say, though, that i'm any kind of expert on RDBMS)
21:33:35 <Korollary> RyanT5000: Weren't you writing some kinda chess game?
21:33:47 <RyanT5000> Korollary: a turn-based space strat
21:33:53 <RyanT5000> much more complicated rules than chess
21:34:12 * Korollary destroys the Terrans and moves to a different galaxy
21:34:35 <SamB_XP> RyanT5000: anything like Stars!?
21:34:51 <RyanT5000> i don't think i've played Stars!, but it's very simmilar to MOO
21:35:02 <SamB_XP> MOO?
21:35:06 <RyanT5000> Master of Orion
21:35:10 <jcreigh> RyanT5000: The original, or one of the sad sequels?
21:35:12 <SamB_XP> I was going to say
21:35:20 <RyanT5000> i haven't played the originals
21:35:21 <RyanT5000> er
21:35:23 <RyanT5000> sequels
21:35:26 <RyanT5000> i've played the original
21:35:32 <RyanT5000> so that's the one i know it's simmilar to
21:35:33 <SamB_XP> I didn't think MUD Object-Oriented was much like a space strategy game
21:35:34 <LordBrain> I have a question
21:35:39 <RyanT5000> :P
21:36:00 <jcreigh> RyanT5000: Moo2 and Moo3 both suck, IMHO. So you're not missing much.
21:37:12 <LordBrain> the other day i showed off my lazy-list-functional bouncing ball program. I set out to create it as an exercise to practice the State Monad, and so i used updateBall::State (Int,Int,Int,Int) ().
21:37:38 <RyanT5000> heh
21:37:57 <RyanT5000> well in any case i have this gigantic datastructure, with about 6 different incarnations
21:38:11 <LordBrain> now, i could have just done updateBall:: (Int,Int,Int,Int) -> (Int,Int,Int,Int)
21:38:19 <RyanT5000> depending on whether it's the Server version, Client version, etc.
21:38:37 <monochrom> No other parameters for updateBall?
21:38:44 <LordBrain> nope
21:39:01 <monochrom> Are all four elements of the tuple changed usually?
21:39:08 <LordBrain> that was it, (x,y,dx,dy)  where dx is how much to increment x by
21:39:22 <RyanT5000> and so i need to use classes to make stuff like drawBoard work on most versions of it
21:39:50 <RyanT5000> basically the way i think about this thing is like a bunch of interconnected database tables
21:40:17 <LordBrain> now of course i used State, because thats why i wanted to make the program in the first place... for the practice of State, but my question is... is that a good design? or should just leave it in the tupple -> tupple form?
21:40:20 <RyanT5000> there are various things with which you can look up other things
21:40:45 <LordBrain> maybe using State offers some flexibility?
21:40:51 <RyanT5000> but let's say i write a draw program that doesn't understand planets (only ships), and then i add a set of planets to each cell in the board
21:41:16 <monochrom> Have two functions.  f :: (Int,Int,Int,Int) -> (Int,Int,Int,Int).  updateBall :: State (Int,Int,Int,Int) ().  updateBall = modify f
21:41:19 <RyanT5000> this shouldn't require me to make any changes to any of the various functions that use cells
21:41:28 <RyanT5000> which would be easy if there was only one version existing at a time
21:41:44 <RyanT5000> ntm, some things will need to update a datastructure they don't fully understand
21:42:05 <monochrom> updateBall is a nice name and do { ... ; updateBall; ...} makes sense.  Don't worry too much.
21:42:06 <RyanT5000> (e.g.: i hope to allow users to put notes on objects, but none of the game logic cares about them)
21:42:54 <RyanT5000> :'-(
21:42:56 <RyanT5000> it's difficult, lol
21:43:14 <LordBrain> i reworte it without the State Monad, and i think it is actually shorter
21:43:29 <LordBrain> Now i'm thinking i'll put both versions side by side in a tutorial
21:43:31 <SamB_XP> LordBrain: the State monad is probably pretty useless
21:43:35 <LordBrain> but
21:43:39 <SamB_XP> StateT is where it is at
21:43:40 <monochrom> Imperative programming is supposed to be longer :)  (Just kidding!)
21:43:54 <musasabi> RyanT5000: sounds like you need to abstract things more.
21:44:27 <LordBrain> i am anticipating readers might ask why bother with a State monad, and i cant answer.. except that now i could return a value but i dont make use of that
21:45:01 <RyanT5000> musasabi: yeah, that's where the rdbms idea comes in; i've noticed that practically everything in the datastructure is, logically speaking, a Map
21:45:26 <monochrom> Is the bouncing ball displayed when you run this program?
21:45:47 <RyanT5000> which strikes me as simmilar to tables
21:45:52 <RyanT5000> in a database
21:45:52 <LordBrain> SamB_XP: do you think i should be using StateT somehow in this bouncing ball program?
21:45:58 <LordBrain> monochrom: yes
21:46:14 <SamB_XP> LordBrain: not necessarily
21:46:25 <LordBrain> yeah i cant really justify it to myself
21:46:29 <SamB_XP> only that I think StateT is nice
21:46:45 <LordBrain> i cant hardly justify State, but i'm attached to that version because its my original
21:46:52 <LordBrain> hehe
21:46:56 <SamB_XP> try translating the C implementation of unlambda to Haskell some time ;-)
21:48:54 <monochrom> How do you display the ball?
21:49:28 <LordBrain> monochrom: let me repost it for you
21:49:46 <RyanT5000> @where paste
21:49:47 <lambdabot> http://paste.lisp.org/new/haskell
21:50:11 <lisppaste2> RyanT5000 pasted "Table.hs" at http://paste.lisp.org/display/23527
21:50:29 <RyanT5000> i'd really appreciate any commentary anyone could give me on that
21:51:04 <RyanT5000> the idea is to treat datastructures as tables, and define accessors, indexes, etc. on them
21:53:01 <lisppaste2> LordBrain pasted "Bouncing Ball" at http://paste.lisp.org/display/23528
21:53:31 <musasabi> RyanT5000: fundeps might make sense.
21:53:36 <RyanT5000> then, eventually, define some combinators: a datastructure that does lazy filtering/mapping (e.g.: extracts one part of the "row" when that index is requested, rather than filtering the entire thing at once)
21:54:14 <RyanT5000> musasabi: in which classes? all these classes use all their types in their function
21:54:30 <RyanT5000> i have to admit my understanding of the usefulness of fundeps is rather lacking
21:54:31 <lisppaste2> LordBrain annotated #23528 with "without State" at http://paste.lisp.org/display/23528#1
21:54:53 <RyanT5000> (i'm not at all saying they aren't useful - just that i don't understand them)
21:54:59 <musasabi> e.g. accessor. Don't a t and q determine r?
21:55:19 <RyanT5000> hm... yeah i suppose they should
21:55:27 <musasabi> I would make sure the interface matches your real needs.
21:55:36 <RyanT5000> right
21:55:42 <RyanT5000> i'm not sure about separating a and q
21:55:57 <LordBrain> i could include only one in the tutorial and make the other an exercise...
21:56:03 * musasabi tends to invent fancy interfaces which much type hackery and then note that they don't work for my original problem.
21:56:13 <RyanT5000> yeah, that's my problem too
21:56:17 <musasabi> *with
21:56:39 <monochrom> LordBrain: Ah, yes, simpler to use (Int,Int,Int,Int) -> (Int,Int,Int,Int)  if you intend to use iterate.
21:58:14 <LordBrain> hmmm or i could have updateBall return an (x,y) pair and do away with the xy function.... leave State in
21:58:43 <LordBrain> so many options :)
21:59:20 <LordBrain> so for the tutorial, i should keep it simple, dispense with the state monad?
21:59:27 <monochrom> However, in other applications, you may want to fuse the IO loop with the ball state loop, in which case you will wrap StateT around IO and loop over that.  Then what you learned about how to use State pays off.
22:00:07 <LordBrain> so, State is mostly  just training wheels for StateT ?
22:00:15 <LordBrain> haha
22:00:26 <monochrom> There are applications for State.
22:00:46 <LordBrain> well, besides that it lets me return a value, what else?
22:01:19 <LordBrain> maybe if my computations were more complex?
22:01:21 <musasabi> it is convenient.
22:01:42 <monochrom> Yes, if updateBall is very complicated, has its own loops, etc.
22:02:10 <RyanT5000> musasabi: what do you think about the idea of getting rid of separate a and q?
22:02:13 <musasabi> also when the code is monadic (and written with a few type-aliases) then changing monads will be easy if you want to refactor things.
22:02:48 <LordBrain> yes i thought about refactoring... but i didnt truely convince myself
22:02:58 <RyanT5000> i seem to just be using tag types for the first-term things
22:03:02 <musasabi> RyanT5000: too tired to answer in an intelligent manner.
22:03:07 <RyanT5000> alright :)
22:03:10 <RyanT5000> i'll try it
22:03:32 <RyanT5000> i factored out Accessor though anyway; i decided anything that acts like a real table can never have guaranteed lookups
22:04:31 <RyanT5000> that's also the reason for there being no update command - i don't guarantee that rows have any particular kind of uniqueness properties
22:04:40 <RyanT5000> update would be a filter
22:06:00 <musasabi> Making sure rows have identity can be good.
22:06:12 <musasabi> I had some typeclasses for tables with identitty
22:06:36 <RyanT5000> musasabi: i don't see how identity is useful in the typeclasses - we can always implement a table whose rows do have identity
22:06:52 <RyanT5000> e.g.: instead of having a row r, have a row (uniqueID, r)
22:06:56 <LordBrain> Ironically,  i originally concieved of the ball program because i figured 4 state values would make it worthy of a good State Monad Example.
22:06:57 <musasabi> http://www.cs.Helsinki.FI/u/ekarttun/hswebforms/hswebforms/src/WebForm/HaskellDB/IDTable.hs
22:07:15 <dons> ?where hope
22:07:15 <lambdabot> http://hope.bringert.net/
22:08:32 <RyanT5000> in fact, i should be able to make a combinator that turns a finite table without row identity into a finite table with row identity
22:08:37 <RyanT5000> and that would be pretty cool
22:09:52 <RyanT5000> also i've always been partial to datastructures that entirely lack discernable order
22:10:32 <zeeeee> hi all, can i get hugs/ghc to import from additional dirs without specifying -P.../-i... each time? ($HUGSDIR seems to only take one dir; no such thing for ghc)
22:10:45 <RyanT5000> (i'd be happier with Set, e.g., if it took a comparator function on construction rather than a global instance)
22:11:05 <RyanT5000> (and didn't have a toList function, except that took another ordering function)
22:12:42 <zeeeee> (if not...is there any way to have everything defined on startup from http://www.haskell.org/hawiki/LicensedPreludeExts?)
22:12:44 <lambdabot> Title: LicensedPreludeExts - The Haskell Wiki
22:12:46 <musasabi> RyanT5000: you could wrap Data.Set and get it.
22:13:24 <RyanT5000> musasabi: yeah, i would, except that my Table schema, ideally, should be a superset of the functionality of Set
22:14:49 <RyanT5000> i like things to be very explicit; i think having separate Index, Filter (aka update), Order, and Insert is pretty orthogonal
22:15:04 <monochrom> So, the new http package is incapable of https, I presume?
22:17:45 <Korollary> zeeeee: If you're trying to import your own stuff, you could Cabal'ize your sources and install them. Then, they will be in the import path.
22:18:26 <zeeeee> Korollary: the problem is i don't have root, and i'd like to not pollute this account's HOME dir with a lib dir
22:18:42 <Korollary> zeeeee: You can install them into your user's home as well.
22:18:47 <Korollary> err
22:18:51 <Korollary> well
22:19:05 <Korollary> The sources exist somewhere
22:19:28 <zeeeee> Korollary: why don't the prelude extensions exist as a cabal package already?
22:19:47 <zeeeee> erm, it was unfair to direct that to you
22:19:50 <zeeeee> haha
22:20:20 <Korollary> Heh
22:22:37 <zeeeee> i wish there existed a nice system for hosting/revision control of mini projects and code snippets that lets people quickly check out things. sf.net projects are too heavyweight, while sites like textsnippets.com are completely inadequate and garbage.
22:23:04 <zeeeee> (that should be: quickly check out things and commit suggested changes using standard tools like svn)
22:23:22 <RyanT5000> zeeeee: it should be a p2p cvs
22:23:31 <SamB_XP> darcs?
22:23:48 <RyanT5000> SamB_XP: more actively p2p
22:23:53 <RyanT5000> like you'd have to run a daemon
22:24:04 <Korollary> where did the p2p aspect come from?
22:24:08 <RyanT5000> me :P
22:24:09 <zeeeee> RyanT5000: why p2p
22:24:16 <SamB_XP> zeeeee: darcs?
22:24:27 <SamB_XP> okay, I need to go to bed...
22:24:48 <RyanT5000> i guess it could probably be just a webservice
22:24:56 <RyanT5000> i'm quite partial to p2p though
22:25:02 <zeeeee> SamB_XP: darcs lets users take ownership of their own section? categorize/hierarchically label their snippets? specify dependencies?
22:25:03 <RyanT5000> i think it'd allow for a lot more scalability
22:25:14 <Korollary> I think zeeeee asking for a public revision control system without the baggage of sf.net
22:25:21 <RyanT5000> (not just storage space scalability)
22:25:25 <zeeeee> Korollary: yes :)
22:25:50 <RyanT5000> it seems like the business models for sf.net would need to be very different from a 10-minute-project snippet management site
22:25:52 <zeeeee> add to that: approve/reject suggested revisions?
22:26:08 <Korollary> zeeeee: Does it need to be online? Darcs lets you create local repositories absurdly easily.
22:26:13 <zeeeee> (basically issue tracking)
22:26:18 <RyanT5000> so there's going to be some breaking point, which will require you to "refactor" your project onto a different site/system
22:26:32 <RyanT5000> with a p2p system you need no business model
22:26:48 <RyanT5000> but mostly i just like p2p
22:26:48 <RyanT5000> :P
22:26:54 <zeeeee> Korollary: well the point of such a system would be to share the site. i have no problem using darcs as the repository interface, since it decentralizes easily as you mentioned
22:26:59 <RyanT5000> it's my hammer
22:27:14 <RyanT5000> my hammer, with which i will attempt to smash the RIAA's toe while i'm in law school
22:27:22 * Korollary sees an agenda
22:27:56 <RyanT5000> hopefully thereby taking my brave stand, and getting sued into poverty, while my total assets are still extremely negative
22:28:08 <Korollary> zeeeee: I read somewhere that Google introduced an online repository like sf.net
22:28:20 <Korollary> I haven't checked it out, though.
22:28:21 <zeeeee> Korollary: yes they did
22:28:30 <jer> RyanT5000, you could always move to a country without a crazy copyright law ... like Canada =D
22:28:41 <zeeeee> Korollary: http://code.google.com/hosting/
22:28:42 <lambdabot> Title: Google Code - Project Hosting
22:28:45 <RyanT5000> jer: but the whole point is to get a bunch of smart law students vs. the RIAA in the supreme court :P
22:28:55 <RyanT5000> i don't want to run from the USA, i just want to fix it
22:29:08 <RyanT5000> :'-) it's kind of patriotic
22:29:09 <RyanT5000> lol
22:29:14 <jer> heh
22:29:35 * jer believes that you cannot understand how broke (or how good) your country is until you live outside of its borders for some time
22:29:40 <jer> but perhaps that's just me =]
22:29:53 <jer> but good luck to you anyway =]
22:30:03 <RyanT5000> yah, thanks :)
22:30:09 <RyanT5000> that is a good point though
22:30:16 <RyanT5000> i should definitely live somewhere else for a while
22:30:36 <RyanT5000> somewhere that hates the USA, but doesn't behead its citizens
22:30:39 <Korollary> zeeeee: I suppose you could mess around in your local darcs, and go through the pains of either google or sf.net when you're ready to share.
22:30:46 <jer> RyanT5000, france?
22:30:47 <jer> =D
22:30:59 <RyanT5000> you know, that's probably a really good choice
22:31:31 <RyanT5000> all the hate - but none of the balls - of the middle east :P
22:32:21 <jer> you could join the french foreign legion... help them get some balls =]
22:32:42 <RyanT5000> lol
22:32:55 <Korollary> move to mexico, then jump the border.
22:32:58 * jer hopes mux isn't around =]
22:33:00 <RyanT5000> hahaha
22:33:03 <jer> lol
22:33:24 <RyanT5000> he's french?
22:33:29 <jer> ya
22:36:41 <RyanT5000> man, importing Prelude stuff explicitly is a real pain
22:42:37 <zeeeee> Korollary: but that means you would need to create a SF project called "haskell joinList/split" for his two functions in the prelude-exts of those names. or he'd have to submit it to some global "snippets" project, which makes impossible (1) specifying dependencies, (2) tagging snippets as (eg) a combination of bash and python, (3) getting notified of issues pertaining to that snippet. plus he'd have to submit either (a) via some small
22:42:37 <zeeeee> group of admins, thus requiring submitting snippets as tracked issues, or (b) directly after getting dev access, which would lead to chaos if a dev decides to inject malicious code into your snippets.
22:43:37 <zeeeee> * he = you, his = yours
22:46:03 <Korollary> Yes
22:47:16 <Korollary> You thought I was going to argue with you, didn't you? Gotcha!
22:53:18 <LordBrain> well goodnight
22:53:27 <LordBrain> its almost 2 am here
22:53:53 <LordBrain> see you all tomorrow
23:03:41 <dons> ?uptime
23:03:42 <lambdabot> uptime: 3 days, 2 hours, 15 minutes and 2 seconds
23:06:26 <Lemmih> Morning, #haskell.
23:13:13 <dons> good morning Lemmih
23:19:26 * Lemmih boings.
23:19:38 <Lemmih> I'm gonna meet shapr today (:
23:21:16 <dons> cool!
23:23:31 <RyanT5000> internet -> real life relations are always interesting
23:29:53 <vincenz> Lemmih: woot
23:30:09 <vincenz> RyanT5000: to say the least
