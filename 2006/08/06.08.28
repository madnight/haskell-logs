00:01:34 <mnislaih> so I'm going to spend some time this morning mutilating my patches, hopefully I can unrecord all those that modify the conflicting file (luckily, that patch modifies a single file in the whole ghc repo) and merge them in a single big patch
00:02:00 <mnislaih> or is there a better way ?
00:02:16 <Lemmih> I don't know. My darcs knowledge is very limited.
00:03:05 <lispy> mnislaih: it may be easier to take the contents of Lemmih's patch and just manually hack them in and record that
00:03:32 * lispy finds unrecord to be painful at times
00:03:42 <mnislaih> Yes, but the problematic patch is already living in the main ghc repo. It cannot be unpulled
00:03:56 <lispy> dons: i didn't have any swap, so for now i've added 2GB of swap...hopefully this won't be an issue again :)
00:04:04 <lispy> mnislaih: ah
00:04:05 * mnislaih is merging his patches with the main ghc repo
00:05:25 <dons> lispy: heh
00:05:38 <Lemmih> My stomach just informed me that it's time to buy food. Be back in a bit.
00:07:16 <newsham> is haskell/esc available for use, or just papers for reading?
00:07:26 <lispy> esc?
00:07:49 <newsham> extended static checking for haskell
00:08:09 <newsham> theorem solver for pre- and post- conditions
00:09:14 <Lemmih> Dana said she only had a minimal Haskell parser for it, iirc.
00:09:34 <newsham> http://www.cl.cam.ac.uk/~nx200/research/escH-hw.ps
00:11:27 <urz> I want to make a function that iterates over every line of stdin and hands that line to a processing function.  I thought to make a lazy list of lines using getLine but that is trickier than i thought.  What's the typical way this is done?
00:12:25 <lispy> urz: why is that tricky?  (it's how i would think to do it)
00:12:41 <urz> lispy, well my crud isnt working heh
00:12:54 <urz>    let lines = catch (do s<-getLine; tail <- lines; return $ s:tail) (\_->return [])
00:12:57 <urz>    lines' <- lines
00:13:03 <dons> getContents >>= lines ?
00:13:14 <newsham> if you just applied "lines" (the prelude func) to all of stdin, that wouldnt be lazy?
00:13:26 <dons> lazy as all get up.
00:14:02 <urz> ok
00:14:16 <urz> heh
00:14:20 <lispy> urz: and if it's really big files you might look at fps
00:14:49 <newsham> i <- getContents;  map f (lines i)     ?
00:14:49 <urz> what's fps?  this is actually piped output
00:15:19 <lispy> urz: it's a very efficient way of processing string data, including reading from files
00:15:27 <lispy> @where fps
00:15:27 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
00:15:53 <newsham> dons: is fps going to be put into the ghc dist?
00:16:12 <eivuokko> It will be in 6.6, in base-package.
00:16:53 <newsham> neatoh
00:18:57 <dons> newsham: its already there :)
00:21:27 <lispy> dons: $ lambdabot --online
00:21:28 <lispy> Initialising plugins ............................................. done.
00:21:28 <lispy> [12:18 AM][dagit@olive~/local-data/lambdabot]
00:21:40 <lispy> dons: no error message!
00:21:48 <lispy> dons: any suggestions?
00:23:20 <Pseudonym> This is bizarre.
00:23:26 <Pseudonym> Building cabal out of darcs.
00:23:35 <dons> kpreid said earlier that the initial ip address of the chat.freenode.org server changed
00:23:42 <Pseudonym> Configuring cabal-setup-1.1.4...
00:23:44 <Pseudonym> setup: cannot satisfy dependency Cabal>=1.1.4
00:23:49 <Pseudonym> Hrm.
00:23:49 <dons> lispy, so perhaps try a different server?
00:24:23 <lispy> dons: chat.freenode.net is no good?
00:24:42 <Cale> Isn't it irc.freenode.net?
00:24:54 <lispy> trying that now...
00:25:04 <Cale> Or you could pick a specific server, like zelazny.freenode.net
00:25:44 <lispy> oh, interesting
00:25:59 <lispy> i ran it again to get the error message again, and it's actually doing something now
00:26:38 <Pseudonym> Gotta go.
00:28:03 <urz> what's wrong with this?     let lines' = getContents >>= lines
00:28:18 <newsham> lift lines?
00:28:25 <newsham> lines isnt  a -> ma
00:28:40 <Cale> return . lines
00:28:50 <Cale> though you should use fmap for that
00:29:00 <Cale> also, you probably want to run the action
00:29:04 <Cale> not just define it
00:29:10 <Cale> so it'd be
00:29:19 <Cale> lines' <- fmap lines getContents
00:29:35 <Cale> (no let)
00:29:42 <Cale> I'm assuming this is inside a do-block
00:29:52 <newsham> do c <- getContents; let ls = lines c       so horrible?
00:30:00 <urz> i got    lines' <- getContents >>= return . lines
00:30:01 <Cale> that's also correct
00:30:05 <urz> heh
00:30:10 <Cale> yeah, both of those :)
00:30:38 <Cale> though using   >>= return . lines   seems like a bit of an abuse for some reason.
00:31:08 <Cale> It'll (provably) work fine though. :)
00:31:35 <Cale> x >>= return . f = fmap f x
00:31:38 <dons> return . lines =<< getContents -- ?
00:31:46 <urz> i like the fmap one
00:31:54 <dons> ?pl return . lines =<< getContents
00:31:55 <lambdabot> lines `fmap` getContents
00:32:07 <newsham> thats perdy
00:34:10 <Cale> Interesting that it makes it infix.
00:42:11 <Karlik> Can anybody answer me on stupid question in room haskell_ru. I know only russian language
00:43:52 <dons> ADEpt: ping?
00:44:10 <ADEpt> dons: pong
00:44:18 <dons> ADEpt: you speak russian?
00:44:19 <ProfTeggy> "I know only Russian language" seems like an oxymoron. ;-)
00:44:19 <ADEpt> Karlik: got jabber?
00:44:41 <ADEpt> dons: only when not on IRC :)
00:44:45 <dons> heh
00:45:05 <ADEpt> Karlik: you could try alar/nealar and kep here as well.
00:45:27 <Karlik> My jabber don't work. I don't know why
00:45:42 <ADEpt> Karlik: privmsg me then
00:46:16 <Karlik> priv don't work, because i'm not register
00:46:52 <Karlik> can you add me akopyan@livejournal.com
00:47:04 <Karlik> I wrote you, adept.
00:47:21 <Karlik> but you don't answer. If you adept@livejournal.com
00:48:05 <ADEpt> Karlik: that's not my primary JID. Let's see if LJ server implements server-to-server finally ...
00:48:30 <Karlik> now. i wrote you to adept@jabber.ua
00:48:38 <Karlik> something like this
00:49:12 * ADEpt . o O ("something like this..." I like it :)
00:49:20 <ADEpt> sorry for flooding the channel, all
00:49:46 <Karlik> my English very bad
00:50:21 <basti_> as long as it's for helping someone with haskell, that kind of conversation is ok i guess ;)
00:51:02 <dons> :)
00:51:24 <urz> any multiline comments?
00:52:54 <dons> in haskell?
00:52:57 <dons> {- some long
00:52:59 <dons>    comment -}
00:56:32 <mnislaih> is there any trick to make darcs annotate work, in the ghc repo? Igloo Lemmih any idea?
00:57:10 <mnislaih> darcs annot compiler/main/GHC.hs ---> darcs failed:  There is no file or directory named 'compiler/main/GHC.hs'
01:24:15 <lispy> dons: after i create a Plugin/Foo.hs what do i do to get that module building?
01:24:34 <lispy> dons: it looks like i need to run BotPP.hs but i think that's part of the build process?
01:25:30 <dons> you add it to Modules.hs
01:25:39 <lispy> ah
01:25:40 <lispy> thanks
01:25:49 <lispy> i was worried that was autogenerated
01:26:17 <dons> that would be worrying :)
01:26:32 <lispy> :)
01:39:01 <tibbe> morning
01:43:50 <lispy> dons: when you use Lib.Url.getHtmlPage, how do you safely navigate the return list to get to the body of the message?  last?
01:48:01 <lispy> dons: n/m, i think i see what i have to d
01:55:09 <tibbe> sometimes peoples code just makes me wanna cry
01:55:54 * tibbe wishes he spoke better french so he could curse at the writer of this library
01:56:18 <tibbe> @quote
01:56:19 <lambdabot> lispy says: I just remembered this dream i had the other morning.  I was trying to tell my alarm clock how to snooze by using a list comprehension
02:00:25 <boegel> tibbe: conard!
02:00:51 <boegel> tibbe: merde alors, ce pas possible! mon dieu!
02:01:31 <foxy> dons, you mentioned earlier that we now have functions over types, is that with associated types?
02:01:32 <mux> connard takes two n's ;-à
02:01:34 <mux> :-) rather
02:01:39 <boegel> mux: oh, okay :)
02:01:53 <mux> quite a valuable thing to know heh
02:01:56 <boegel> mux: sorry 'bout that ;)
02:02:07 <boegel> mux: why's that? what does conard mean?
02:02:22 <mux> it's an insult
02:02:34 <osfameron> or a badly spelt duck
02:02:37 <mux> I couldn't really tell the proper meaning
02:03:19 <tibbe> boegel, :D
02:03:29 <mux> tibbe: btw, what's this library?
02:03:49 <tibbe> boegel, I doubt my pronounciation would help, perhaps I should try some french driving gesutres instead ;)
02:04:31 <tibbe> mux, it's work related, a parser for a protocol written in such a conveluted way that it's impossible to reuse
02:04:38 <tibbe> mux, in Java........
02:04:40 <mux> heh, sounds cool
02:05:22 <tibbe> boegel, s/gesutres/gestures
02:05:54 <tibbe> sometimes I can really understand the not invented here feeling
02:06:22 <lispy> yeah
02:06:29 <lispy> i hear you theer
02:07:12 <tibbe> I guess I shouldn't be too hard on the guy though, for all I know he might never have taken a class that's remotely linked to parsing
02:12:51 <_frederik_> shouldn't "fromIntegral" be called something shorter?
02:15:36 <audreyt> fi = fromIntegral
02:15:50 <audreyt> cast = unsafeCoerce#
02:16:03 <audreyt> run = unsafePerformIO
02:16:26 <audreyt> you can easily shorten things with this equal sign...
02:17:39 <_frederik_> oh really?
02:18:00 <lispy> rly
02:18:50 <Igloo> mnislaih: Looks like a --partial bug
02:19:17 <mnislaih> Does it mean that it will work with a non partial repo? that'd be cool.
02:19:33 <mnislaih> I've run into panic mode by now. Going the 'single big patch' route
02:19:34 <tibbe> o'rly http://www.orlyowl.com/
02:19:35 <lambdabot> Title: O RLY?
02:19:53 <Igloo> I suspect so. I'm not sure if it would be acceptably fast for GHC's, though
02:20:18 <_frederik_> i'm deciding to alias 'fromIntegral' to 'num'. but i think the standard name should be shorter. i was wondering what other people used
02:20:25 <eivuokko> What would be the correct way to throw Windows error codes in Win32 package?  Currently it throws user errors, which isn't that nice for some APIs.  Also, errno-like conversions are not so easy (like in unix/Foreign package), because Windows API has much wider amount of errors.
02:20:45 <eivuokko> Do I have to use Dynamic Exceptions and lose semi-nice user error messages?
02:21:24 <Heffalump> can't you catch the dynamic exceptions at the top-level and turn them back into nice messages, if unhandled elsewhere?
02:21:39 <eivuokko> Heffalump, Yes, but it is subtle diffrence for already existing programs.
02:22:05 <eivuokko> But yeah, that's my current plan.
02:23:08 <audreyt> _frederik_: length of a function should be roughly inversely proportional to its frequency in programs; if your code use fromIntegral a lot, then shortening it for your own use makes sense
02:23:48 <audreyt> _frederik_: but I've used it maybe only two or three times, so I wouldn't like the name "num" for it, as it'd dilute the meaning
02:25:08 <_frederik_> well i think it should be shorter. anyway, shouldn't the length be proportional to the log of the inverse frequency? stated that way, i think it's a decent rule
02:25:40 * mux enjoys foreach = flip mapM_
02:26:27 <_frederik_> that's a good one too
02:28:53 <audreyt> I use forM_ and forM here, but foreach is attractiveindeed
02:29:55 <mux> I thought about having a M or M_ suffix too, but decided foreach was more intuitive
02:30:05 <mux> it's handy when you're doing gtk2hs code
02:30:18 <mux> ie
02:30:22 <mux>     foreach (zip cols [0..]) $ \(col,i) -> do
02:30:22 <mux>         treeViewColumnSetSortColumnId col i
02:30:22 <mux>         treeViewColumnSetResizable col True
02:30:30 <boegel> is 'passivly' correct English?
02:30:37 <mux> I think it's passively
02:30:39 <integral> "passively"
02:30:50 <Heffalump> what's the context?
02:30:59 <Heffalump> (yes, "passively" is the right spelling)
02:33:13 <boegel> Heffalump: passively attending a meeting
02:33:23 <tibbe> sleeping?
02:33:40 <boegel> tibbe: no, just not joining the discussions :)
02:33:48 <boegel> but listening though
02:33:58 <tibbe> ah, that kind of passive
02:34:06 <mux> I think you should say "attending *to* a meeting"
02:34:26 <mux> not 100% sure though, I'm not a native english speaker
02:34:27 <mlh> depends
02:34:46 <mlh> usually not
02:34:54 <boegel> mux: I mentioned it like so: "<meeting>: attending (passively)"
02:35:02 <integral> imho that means something different.  "attending to" something would mean you were dealing with it, but "attending a meeting" would be that you were at a meeting
02:35:10 <mlh> yup
02:35:18 <mux> well in this case the "to" shouldn't be used indeed
02:42:59 <pflanze> how is list-append called in haskell?
02:43:27 <audreyt> ++
02:43:43 <pflanze> ah thanks. Now I remember :~)
02:44:32 <audreyt> np :)
02:44:36 <pflanze> (I always try +, then wonder if it was : or ::, of course not, append neither, but don't get to the point trying ++)
02:45:13 <mnislaih> Igloo: I'm trying from a non partial repo, but darcs seems to hang just the same
02:45:17 <mnislaih> Lemmih ping
02:46:42 <Igloo> What do you mean by hang?
02:47:13 <mnislaih> use 100% cpu for a long period of time
02:47:35 <mnislaih> maybe I should wait longer and it'll finish
02:47:54 <mnislaih> but I don't think so..
03:02:35 <xerox> pflanze: there is also concat :: [[a]] -> [a]
03:03:34 <pflanze> ah thanks for the note, xerox
03:29:48 <xerox> @tell ndm check out daikon on LtU!
03:29:49 <lambdabot> Consider it noted.
03:42:08 <profmakx> hmm
03:42:25 <profmakx> why is it the complete executable of lambdabot is 12MB in size?
03:42:49 <dons> it links a bunch of libraries, and maybe you don't have stripped objects?
03:43:16 <dons> $ du -hs lambdabot
03:43:17 <dons> 3.9M    lambdabot
03:43:23 <ndm> is stripped objects available on Windows?
03:43:23 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
03:43:25 <dons> on linux, with split object files
03:43:27 <profmakx> ah
03:43:31 <dons> s/stripped/split/
03:43:39 <dons> ndm, not sure.
03:43:59 <ndm> @seen xerox
03:44:00 <lambdabot> xerox is in #perl6, #haskell.it, #haskell-overflow, #haskell-blah and #haskell. I last heard xerox speak 14 minutes and 12 seconds ago.
03:44:11 <ndm> xerox, yeah I saw daikon
03:44:12 <dons> yeah, without split objects its around 12M statically linked
03:44:23 <profmakx> ah thx
03:44:36 <dons> but that's all 3/4 dead code the linker hasn't removed
03:45:13 <ndm> compile it with Yhc, and it will be teeny
03:45:21 <ndm> (thats assume you could, of course...)
03:45:28 <dons> when Yhc supports a few more things ... :)
03:45:32 <profmakx> well for a start i dont care if its 12 6 or 100 mb
03:45:38 <profmakx> i just wondered
03:45:50 <profmakx> whats yhc?
03:45:55 <ndm> @where yhc
03:45:56 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
03:45:56 <profmakx> yahoo haskell compiler ^^
03:46:02 <dons> heh yep
03:46:18 <ndm> profmakx: york haskell compiler - faster to compile than GHC, faster to run than Hugs
03:46:44 <ndm> profmakx: better for debugging than, well anything, since there aren't many alternatives
03:46:53 <profmakx> ah nice
03:47:13 <profmakx> yeah i know debugging haskell code can be a little painful
03:47:18 <profmakx> for large values of little
03:47:52 <ndm> well with Yhc, whena program crashes
03:48:00 <ndm> you just type "show me the stack", and it does
03:48:13 <dons> its painful? how so?
03:48:29 <ndm> dons: which debugger do you use for haskell?
03:48:42 <profmakx> i found it rather difficult to find mistakes
03:48:44 <profmakx> but
03:48:50 <ndm> in Haskell even printf debugging changes the evaluation order!
03:48:50 <profmakx> for one i am a beginner at this
03:48:51 <profmakx> so
03:48:55 <dons> QuickCheck
03:48:56 <dons> :)
03:49:22 <ndm> QuickCheck is useful for simple properties, but when writing program validators etc, QuickCheck is not strong enough
03:49:57 <dons> I've not needed a debugger beyond ghci. But I can imagine they'd be useful for some scenarios
03:50:21 <ndm> if the property you are checking is the turing problem, writing a quickcheck property for it becomes challenging
03:51:48 <audreyt> Igloo: FreeBSD with the nightly snapshot segfaults
03:51:57 <audreyt> on libthr of stage2
03:52:41 <audreyt> Starting program: /home/audreyt/i/ghc-6.5.20060827/compiler/stage2/ghc-6.5.20060827
03:52:49 <audreyt> Program received signal SIGSEGV, Segmentation fault.
03:52:52 <audreyt> 0x289de16b in pthread_cond_destroy () from /usr/lib/libthr.so.2
03:53:04 <audreyt> same error exhibits with libthr.so.1, libc_u, and libpthreads.
03:53:11 <audreyt> I'm compiling linuxthreads to see if it still fails.
03:53:13 <Igloo> OK, thanks
03:53:23 <audreyt> FreeBSD 6.1-STABLE, freshly cvsup-ed
03:53:40 <audreyt> stage1 is fine
03:53:44 <audreyt> (using stock 6.4.2 as boot)
03:53:57 <audreyt> difference apparnetly is that stage1 was not built with -threads
03:53:59 <audreyt> and stage2 was.
03:54:31 <audreyt> the segfault happens at program exit, after ghc (quite normally) did what it's supposed to do
03:54:32 * Igloo adds it to my big e-mail of things that don't work
03:54:45 <audreyt> Igloo++
03:55:12 <audreyt> I wonder if this coincides with win32 binary build being broken (missing ghc.exe) for a wekk or so
03:55:15 <audreyt> *week
03:57:04 <Igloo> Win32's been failing oddly: http://www.haskell.org/pipermail/cvs-ghc/2006-August/030964.html
03:57:06 <lambdabot> Title: [nightly] 27-Aug-2006 build of HEAD on i386-unknown-mingw32 (bling)
03:57:44 <Igloo> I'm not sure why it still decides to publish the result
03:57:50 <audreyt> nope, lthread doesn't work either
03:57:52 <audreyt> #0  0x28aeefe7 in sigsuspend () from /lib/libc.so.6
03:57:53 <audreyt> #1  0x289e2ed1 in __pthread_wait_for_restart_signal () from /usr/local/lib/liblthread.so.3
03:57:56 <audreyt> #2  0x289e32fb in __pthread_suspend_old () from /usr/local/lib/liblthread.so.3
03:57:58 <audreyt> #3  0x289e316d in pthread_create () from /usr/local/lib/liblthread.so.3
03:58:01 <audreyt> #4  0x088c4467 in createOSThread ()
03:58:02 <audreyt> so it appears fbsd is thoroughly hosed
03:58:12 <audreyt> how do I tell GHC to not build threaded?
03:58:34 <audreyt> I mean for ghc itself
03:59:13 <pflanze> How do I call ghc -e main mymain.hs from the shell and pass arguments so that they are available through getArgs ?
03:59:49 <audreyt> ghc -e main my.hs -- foo bar
03:59:53 <audreyt> like this? (not sure)
04:00:06 <Lemmih> pflanze: Can't you use runghc or runhaskell?
04:00:11 <pflanze> audreyt: no, ghc won't run this way
04:00:21 <pflanze> ah, runghc
04:00:28 <audreyt> aha. # Use threaded RTS with GHCi, so threads don't get blocked at the prompt.
04:00:28 <audreyt> SRC_HC_OPTS += -threaded
04:01:06 <Igloo> Yup, either in Makefile or Makefile.ghcbin
04:01:12 <audreyt> 'k.
04:01:51 <audreyt> remaking stage2...
04:04:29 <pflanze> Lemmih: I'd like not to start the interpreter through a shebang line, since I have to pass variable -i paths.
04:04:55 <audreyt> scary that pugs takes almost as long as stage2 to build...
04:05:23 <Igloo> :-)
04:06:34 <pflanze> (audreyt: from the faq ghc should compile fast without -O)
04:06:46 <audreyt> right, but I need this for production use :)
04:06:54 <audreyt> (pugs also compiles rather fast with "make fast")
04:07:36 <audreyt> I'm quite excited by the plan to drop gcc, as it appears that 50%+ of the time is actually spent on gcc+mangler
04:09:09 <pflanze> Schemes that compile through gcc have the same problem, but newer gcc's are improving upon feedback given by Scheme compiler authors.
04:10:55 <audreyt> you mean gcc optimizers are getting faster? :)
04:11:05 <audreyt> they've been optimizing their optimizers?
04:11:11 <The_Ball> gcc can compile scheme?
04:11:22 <audreyt> sure, the same was as it compiles haskell
04:11:30 <audreyt> it needs a huge preprocessor called GHC :)
04:11:37 <johnnowak> audreyt: :)
04:12:15 <johnnowak> audreyt: ghc isn't going to allow compiling to C in the future?
04:12:37 <dons> sure it is
04:12:39 <The_Ball> oh, is that how it works
04:13:39 <johnnowak> dons: whew :)
04:14:03 <audreyt> johnnowak: just decoupling -fvia-C with -O, I think
04:14:43 <profmakx> why would one want to compile haskell to C?
04:14:46 <johnnowak> audreyt: ah, that would be nice
04:16:22 <tibbe> profmakx, it's alot of work to write something that outputs really good assembler for many architectures, since C compilers already do that it saves alot of work to reuse them
04:17:34 <profmakx> yeek
04:18:10 <ndm> they don't produce C, they produce portable assembler - it just happens to be the same syntax and semantics as C
04:18:46 <audreyt> GHC's portable assembler is called C--
04:20:01 <ndm> it just so happens that C is more portable than C-- :)
04:20:08 <boegel> ndm: portable assembler? what are you talking about? :)
04:20:20 <profmakx> boegel, C i suppose
04:20:36 <boegel> profmakx: no, what produces portable assembler?
04:21:30 <profmakx> i meant C == portable assembler
04:29:28 <tibbe> audreyt, is C-- actually used in GHC?
04:30:11 <boegel> profmakx: oh :)
04:30:20 <audreyt> tibbe: yes.
04:30:29 <audreyt> see compiler/cmm/
04:31:10 <audreyt> and compiler/codegen/*
04:38:15 <tibbe> audreyt, last time I looked at C-- was 6 months ago or so and when reading the web site I figured that there's no good C-- -> assembler generator but there's now?
04:39:03 <audreyt> tibbe: compiler/nativeGen/
04:46:35 <tibbe> audreyt, so the generator is seperate from the C-- release? an all GHC thing?
04:47:44 <audreyt> I think so, yeah
04:47:58 <audreyt> as it's written in haskell, not C or C--
04:48:14 <ndm> most of the C-- toolson the website are in ML
04:48:54 <audreyt> ok. "C, C-- or ML" then
04:51:10 <musasabi> What is the most elegant way to poke a fps ByteString into a "Ptr a"?
04:52:01 <musasabi> unsafeUseAsCStringLen + memcpy works, but is there a nicer function that I am missing?
04:55:58 <dons> useAsCString  + memcpy seems ok
04:56:06 <dons> useAsCStringLen
04:56:59 <dons> you want to copy the ByteString to some C location, right?
04:57:42 <dons> maybe there should be a function copyToString : ByteString -> CString
04:57:50 <musasabi> yes. (or rather use it together with a buffer abstraction that uses pointers inside the implementation)
04:57:57 <musasabi> seems to work nicely
04:58:06 * musasabi gets rid of some UArrays
04:59:13 <pflanze> I still don't know how to pass arguments through to getArgs, with files interpreted by ghc, and pass variable -i options to ghc at the same time.
04:59:22 <pflanze> (thus runghc is out, right?)
05:00:18 <MarcWeber> How can I solve a Overlapping instances issue? http://rafb.net/paste/results/shWgnO12.html I want to lean more about heterogenous lists. So I wrote this code..
05:02:09 <sjanssen> MarcWeber: perhaps write a class ToStringList a where toStringList :: a -> [String]
05:02:44 <ndm> pflanze: all arguments before the file name are given to GHC, all after are given to your program
05:02:50 <sjanssen> it's tricky to match against Cons _ _ and Cons _ End
05:02:57 <mux> hmmm, if I want to convert a string representation of an integer to an integer, but want to handle errors myself, I should use reads instead of read?
05:03:01 <ndm> pflanze: runhaskell -iwhatever Filename myargs getargs
05:03:13 <ndm> mux: yes
05:03:27 * sjanssen goes to class
05:03:32 <mux> ndm: thanks
05:03:35 <ndm> mux: although i just usually do all isDigit first, and assume if that passes then read will succeed
05:04:34 <mux> okay
05:05:55 <ndm> case reads str of [(n,"")] -> success n ; _ -> failure
05:06:11 <mux> mmm, I wish I'd know why ghci can't properly handle my terminals on some boxes and why it works on some others
05:06:25 <mux> I can't use the backspace key with some configs for instance
05:06:42 <mux> whatever I set the backspace key to (^H, escape sequence, etc)
05:06:44 <ndm> yeah, the york uni machines have that issue with both hugs and ghci
05:07:06 <ndm> its kinda annoying trying to teach beginners to program, knowing that if they make a single char typo they have to restart
05:07:10 <mux> it works OK with at least one box of mine, and I can't see the difference
05:07:28 <mux> same termcap file, etc
05:08:11 <pflanze> Hm, with runghc -ixxx filename.hs, it complains about "Could not find interface file for `Main'". Previously, I used (with the mentioned problem of not being able to pass arguments): ghc -i"$1"/calc/ -ilib/ lib/mainblock.hs -e main
05:08:34 <pflanze> I do not have a Main module.
05:08:44 <ndm> pflanze: all modules without a name are implicitly main
05:08:47 <pflanze> mainblock.hs does not have a module declaration.
05:08:58 <ndm> in that case it is module main
05:09:02 <ndm> what is the type sig of main?
05:09:04 <pflanze> so why does it not find it?
05:09:07 <pflanze> aha
05:09:07 <dons> ?users #haskell
05:09:09 <lambdabot> Maximum users seen in #haskell: 235, currently: 197 (83.8%), active: 25 (10.6%)
05:09:16 <ndm> @users haskell
05:09:16 <lambdabot> Maximum users seen in haskell: 1, currently: 0 (0.0%), active: 0 (0.0%)
05:09:25 <dons> not yet ;)
05:09:34 <dons> ?users ndm
05:09:34 <lambdabot> Maximum users seen in ndm: 1, currently: 0 (0.0%), active: 0 (0.0%)
05:09:44 <pflanze> The type sig of my main is: IO [()]
05:09:51 <mux> running ghci in screen doesn't help either
05:09:54 * mux grumbles
05:10:01 <ndm> that explains it, return () at the end and you should be happy
05:10:06 <pflanze> ok
05:10:08 <ndm> or are you using a mapM ?
05:10:20 <ndm> as the main expression?
05:10:30 <ndm> or rather the last expression in the do block
05:10:48 <ndm> if so, you probably want mapM_
05:10:48 <mux> that is really annoying
05:11:02 <ndm> just use WinHugs, no terminal issues ever
05:11:12 <pflanze> ndm: (nested inside function calls) I think I  return (sequence lis)
05:11:14 <mux> WinHugs?
05:11:22 * mux smacks ndm with a dead fish :-)
05:11:25 <Igloo> What's teh ghci-in-screen issue?
05:11:27 <ndm> mux, or: http://www-users.cs.york.ac.uk/~ndm/temp/carrot.png
05:11:29 <mux> s/Win//
05:11:42 <ndm> pflanze: sequence_ instead of sequence
05:11:46 <ndm> if you don't want the result
05:11:51 <pflanze> ah
05:11:51 <mux> I'm using FreeBSD
05:12:00 <ndm> mux: guihaskell will fix all your issues, that program will run on freebsd :)
05:12:09 <ndm> http://www-users.cs.york.ac.uk/~ndm/temp/carrot2.png
05:12:14 <mux> ndm: I'd really like to avoid using a GUI for that
05:12:37 <ndm> you can pick one of: 1) backspace, 2) console - not both :)
05:12:42 <mux> meh!
05:12:53 * mux installs hugs
05:13:21 * Igloo can use backspace in ghci in screen
05:13:29 <mux> I can too, at home
05:13:38 <mux> on my work box that is nearly identical I can't
05:13:41 <ndm> just as a warning, on the machine it broke for me - hugs was as bad as ghci
05:13:51 <ndm> in the end turning on a console flag or something managed to change it
05:14:07 <ndm> some weird option to toggle broken vs non-broken behaviour
05:14:17 <mux> some stty setting?
05:14:24 <mux> it's probably ghci that is at fault here
05:14:39 <ndm> perhaps, i was using KDE, so it was a checkbox in a config dialog
05:14:45 <ndm> canc't remember the name though
05:15:11 <mux> I'm trying to find the difference between my home box where it works fine and my work box
05:15:30 <mux> but the config is violently similar
05:16:41 <mux> uh oh
05:17:53 <mux> dang
05:18:12 <mux> I found a different setting for the erase2 sequence in stty but changing it to the same as on my work box doesn't fix the issue
05:19:24 <mux> grrr
05:20:47 <mux> hugs works :)
05:20:55 * mux kicks ghci
05:21:38 * ndm hugs hugs
05:22:08 <MarcWeber> sjanssen: That will work
05:32:14 <ihope> data Foo a b = Foo [a] b -- is this defined as a monad anywhere?
05:32:46 <Heffalump> I doubt it
05:33:35 <xerox> MonadUndo?
05:34:25 <ihope> MonadOutput.
05:35:07 <xerox> That is, a Writer, using the list monoid?
05:39:51 <ihope> Yeah, that sounds right.
05:40:45 <ihope> @docs Control.Monad.Writer
05:40:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Writer.html
05:43:31 <ihope> type Processor s a = Processor {runProcessor :: ReaderT Event (StateT s (MaybeT (Writer [Output])) a}
05:43:58 <ihope> Think that's enough monads?
05:44:21 <pflanze> ndm: runghc does not work
05:44:31 <pflanze> strace shows: execve("/usr/bin/runghc", ["runghc", "-v", "-isim_060823_1600/calc/", "-ilib/", "lib/mainblock.hs", "sim_060823_1600/data/test.csv"], [/* 30 vars */])
05:44:41 <ndm> pflanze: it does on Windows :)
05:44:56 <pflanze> but then  tat64("/usr/lib/ghc-6.2.2/imports/Main.hi", 0xb751e808) = -1 ENOENT
05:45:12 <pflanze> and it does not try to open mainblock.hs
05:45:12 <ndm> no idea about that, Igloo might knwo more
05:46:03 <pflanze> All I want is a way to tell the "ghc" binary to accept arguments, "cannot be this is not there?"
05:46:12 * pflanze reads manual again
05:46:33 <Igloo> pflanze: I don't understand what you want to do
05:47:10 <pflanze> Igloo: I need to run a file, I've called it mainblock.hs, which has currently no module declaration but a main definition,
05:47:11 <xerox> ihope: the State `inside` the Reader?
05:47:15 <pflanze> and pass it -i options.
05:47:25 <pflanze> And commandline arguments.
05:47:35 <pflanze> so as to beable to fetch them through getArgs.
05:47:59 <pflanze> I've tried: ghc -i"$1"/calc/ -ilib/ lib/mainblock.hs -e main "$1"/data/test.csv >"$1"/output/out.csv
05:48:16 <pflanze> but it warns me that the .../test.csv argument is being ignored,
05:48:20 <pflanze> and in fact, getArgs is []
05:48:32 <Igloo> pflanze: Give the .hs file first
05:49:20 <norpan> do you mean --interactive or ghci?
05:49:24 * pflanze is creating a trimmed down file
05:49:50 <Igloo> runghc foo.hs foo bar --baz   works for me with 6.4.1, with getArgs returning ["foo","bar","--baz"]
05:50:20 <norpan> i wonder what runghc does
05:50:28 <orjan> I'm started to try the examples in the parsec doc. In the first one I get "Failed to load interface for `Parsec':". Using -v I can see thats there is a package  {name = "parsec",. This is on debian stable. What to check?
05:51:08 <Igloo> orjan: Use -package parsec or --make
05:51:19 <orjan> ok
05:51:22 <pflanze> norpan: it runs the ghc binary.. (strace clipped off the argument list, have yet to run strace with options not to clip)
05:51:24 <Igloo> norpan: Runs a source file without needing to compile it first
05:52:50 <norpan> yeah, but i wonder how it does it
05:54:11 <pflanze> what's the recommended paste service here?
05:54:30 <ndm> @where paste
05:54:30 <lambdabot> http://paste.lisp.org/new/haskell
05:54:42 <Igloo> Essentially the same as loading it in ghci and typing main
05:55:16 <lisppaste2> pflanze pasted "getArgs with ghc interpreter" at http://paste.lisp.org/display/24881
05:55:46 <pflanze> Igloo: put this into mymain.hs, then run ghc -e main mymain.hs, now add arguments.
05:55:52 <orjan> Igloo: hmm using ghc --make myfile.hs I get:  Can't find module `Parsec'
05:56:21 <pflanze> orjan: Text.ParserCombinators.Parsec
05:56:23 <eivuokko> Parsec is Text.ParserCombinators.Parsec now
05:56:37 <orjan> ahh, ok I see
05:56:48 <Igloo> pflanze: That doesn't work, but runghc does
05:57:07 <pflanze> Igloo: what's your runghc commandline?
05:57:09 <lennart> ?users
05:57:10 <lambdabot> Maximum users seen in #haskell: 235, currently: 205 (87.2%), active: 29 (12.3%)
05:57:43 <Igloo> $ runghc mymain.hs foo --bar baz
05:57:43 <Igloo> Usage: programname inputfile
05:57:43 <Igloo> got: ["foo","--bar","baz"]
05:58:20 <pflanze> Igloo: now add -i options.
05:58:39 <pflanze> like: runghc -i. -ilib mymain.hs foo --bar baz
05:59:11 <Igloo> $ runghc -i. -ilib mymain.hs foo --bar baz
05:59:11 <Igloo> Usage: programname inputfile
05:59:11 <Igloo> got: ["foo","--bar","baz"]
05:59:26 <pflanze> heh, I'm getting Could not find interface file for `Main'
05:59:41 <Igloo> You have 6.2.2, right? I'd recommend upgrading
05:59:46 <pflanze> yes
06:02:45 <mux> hmmm interact is sweet :)
06:11:21 <pflanze> runghc executes ghc with: ["/usr/bin/ghc", "-e", "System.Environment.withProgName \"-i.\" (System.Environment.withArgs [\"-ilib\",\"mymain.hs\",\"foo\",\"--bar\",\"baz\"] Main.main)", "-i."]
06:11:24 <pflanze> this explains it.
06:11:34 <pflanze> So I will now run ghc directly with the correct strings.
06:38:00 <kniv7s> hi, who can give me 3 reasons to learning haskell?
06:38:39 <ndm> kniv7s: fast, beautiful, elegant
06:38:40 <Stinger_> it's interesting :P
06:39:04 <kniv7s> mmmh usually answers :)
06:39:12 <kniv7s> haskell oriented answers?
06:39:56 <dons> visit haskell.org, and read 'why functional programming matters'
06:40:04 <vegai> because you should learn 1 additional language a year, and you don't have anything for 2006 yet
06:40:17 <dons> heh
06:40:45 <dons> ?users
06:40:45 <lambdabot> Maximum users seen in #haskell: 235, currently: 208 (88.5%), active: 28 (11.9%)
06:40:46 <SamB> monads are fun!
06:40:51 <dons> ?users #perl6
06:40:52 <lambdabot> Maximum users seen in #perl6: 148, currently: 134 (90.5%), active: 10 (6.8%)
06:40:56 <ndm> kniv7s: have you seen quicksort in haskell? thats a compelling reason
06:41:00 <dons> 235 people can't be wrong?
06:41:03 <ndm> qsort [] = []
06:41:36 <ndm> qsort (x:xs) = filter (<x) xs ++ [x] ++ filter (>= x) xs
06:41:38 <SamB> dons: what about all the folks who voted for George W. Bush here in the US?
06:41:41 <ndm> now thats just beautiful!
06:41:43 <kniv7s> thanks guys :)
06:41:44 <SamB> ... twice?
06:41:51 <boegel> SamB: touch? :)
06:42:02 <dons> i suppose 20 million people can be wrong
06:42:17 <SamB> "touche" is the usual term used, though I suppose "touch" means the same thing in the end...
06:42:41 <Heffalump> that "qsort" looks rather wrong to me
06:42:47 <SamB> oh, and maybe it has one of them funky unicode chars like xerox is so fond of...
06:42:56 <Heffalump> seeing as it's missing the recursive cases and all
06:43:08 <vegai> touché is passé composé, isn't it?
06:43:13 <dons> its a magic qsort
06:43:14 <Heffalump> it also breaks if you have multiple copies of x in the list
06:43:37 <Heffalump> vegai: it's the participle you'd use in that tense, yes
06:43:59 <xs> qsort [] = []; qsort (x:xs) = qsort lesser ++ [x] ++ qsort greater; where (lesser,greater) = partition (< x) xs?
06:44:37 <dons> xs, your nick is going to break my irc nick reference tracking scripts :)
06:44:54 <dons> the word 'xs' appears way too often in this channel ;)(
06:45:00 <Heffalump> no, that's even worse, it'll duplicate x
06:45:06 <dons> ?where stats
06:45:06 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
06:45:25 <SamB> Heffalump: but x isn't in xs...
06:45:27 <dons> qsort []     = []
06:45:28 <xs> dons, ha ha :p
06:45:28 <dons> qsort (x:xs) = qsort (filter (< x) xs) ++ [x] ++ qsort (filter (>= x) xs)
06:45:49 <dons> according to the haskell wiki anyway
06:46:12 <Heffalump> oh, sorry.
06:46:27 <Heffalump> those both look right, yes
06:46:33 <Heffalump> though xs' is more efficient
06:47:18 <ndm> ah yeah, i always forget the recusive case
06:47:28 <ndm> anyway a mainly sorted list is probably plenty :)
06:47:55 <SamB> heh
06:50:16 <jrmole> it looks more impressive to C programmers if you use a list comprehension
06:50:31 <jrmole> ;)
06:51:56 <profmakx> yeah
06:52:06 <profmakx> but dont tell them space and time requirements
06:52:28 <jrmole> hehe
06:53:06 <profmakx> this quicksort is the "hook-up" algorithm for the lecture on functional programming at our uni
06:57:46 <ndm> time is the same
06:58:02 <ndm> space is more, but as a trade off you can still use the original list
06:58:28 <ndm> and its also lazy, so minimum = head . sort is a reasonable definition
06:58:48 <SamB> ndm: the same as what?
06:59:10 <ndm> SamB: quick sort, implemented in C, if you only look at big O
06:59:28 <SamB> well...
06:59:38 <SamB> why would you only look at big O, anyway?
07:00:04 <ndm> because the big O stays the same, the other thinsg change
07:00:11 <ndm> i.e. given computer, compiler etc.
07:00:26 <SamB> true...
07:00:52 <profmakx> is it?
07:00:58 <ndm> and also, for a big enough data set, the alrogihtm with the biggest O losses always
07:01:00 <profmakx> perhaps its another one that was showed here
07:01:39 <ndm> thats the standard one, and its O(n^2) worst case,O(n log n) average
07:02:28 <pflanze> Is there a haskell mode for emacs which automatically opens the file and marks the region (or just line) where an error happened?
07:02:54 <xerox> It brings you to the point, if that counts as marking.
07:02:59 <SamB> pflanze: you mean the compilation mode?
07:03:07 * mux whispers: vim and :make
07:03:20 <SamB> that isn't Haskell-specific, you know!
07:03:36 <jrmole> oh, speaking of editors, does anyone here use Proxima?
07:03:47 <SamB> it does in fact bring you straight to the error if the path matches the working directory it starts with
07:04:01 <pflanze> SamB / xerox: hm, I'm currently using a "haskell-mode" but C-c C-l loads the file in the running ghci without bringing me to the point of compilation errors.
07:04:34 <xerox> Maybe there's some configuration to do.
07:04:37 <SamB> pflanze: oh, what happens if you middle click on the compilation errors?
07:04:48 * pflanze checks
07:05:41 <SamB> unfortunately xterm does not support doing something with compile errors... wonder if plan9's plumbing does...
07:06:28 <pflanze> SamB: I'm using X; middle-click splits the frame into two parts and shows the file in question, true.
07:06:36 <tibbe> pflanze, did middle click work? C-c C-n works in emacs haskell-mode
07:06:59 <tibbe> pflanze, C-c C-l loads a file
07:07:16 <SamB> pflanze: I believe that is what you call compilation-minor-mode
07:07:46 <pflanze> It does not however position the curser to the right line or anything like that, and I had the buffer already open in another frame (X window), would be better to signal me there.
07:08:11 <SamB> hmm, what did the error say?
07:08:27 <pflanze> /home/chris/Projekte/Ammoniak/repos1/check.hs:4:
07:08:27 <pflanze>     No instance for (Num [Char])
07:08:27 <pflanze>       arising from the literal `2' at /home/chris/Projekte/Ammoniak/repos1/check.hs:4
07:08:27 <pflanze> ..
07:08:52 <SamB> and where was point?
07:08:55 <pflanze> (this is a tiny example file; maybe I should try a bigger one)
07:09:08 <pflanze> cursor was at the top of the file
07:09:15 <SamB> huh
07:09:47 <SamB> that sure looks like the format that emacs likes...
07:10:15 <SamB> (where by emacs I mean compilation-[minor-]mode)
07:10:29 <pflanze> this is in Inf-Haskell
07:10:37 <pflanze> Inf-Haskell:run
07:10:53 <SamB> hmm
07:11:09 <SamB> maybe it doesn't use compilation-minor-mode as it should...
07:11:32 * pflanze does M-x compilation-minor-mode
07:11:58 <SamB> hmm, C-c C-l gives me some error about an unbound symbol...
07:12:44 <SamB> Symbol's function definition is void: inferior-haskell-load-file
07:13:18 <pflanze> this works for me
07:13:30 <SamB> yah
07:13:42 <pflanze> but middle-click now won't work at all anymore.
07:14:15 <pflanze> it just prints "No Error to go" in the status line
07:14:20 <SamB> oh
07:14:23 <pflanze> s/status line/minibuffer/
07:14:26 <SamB> did you click on the error?
07:14:29 <pflanze> yes
07:14:35 <SamB> huh huh huh
07:15:18 <pflanze> I've now killed the Inf-Haskell buffer and restarted, and no joy either anymore. Dunno how I could get it to work at all before.
07:16:36 <pflanze> Maybe ghci has to be started with a special option to output control chars?
07:17:20 <SamB> nah
07:17:41 <SamB> hmm, what is Inf-Haskell anyway?
07:18:04 <pflanze> what appears when I M-x run-haskell
07:18:30 <pflanze> inferior-haskell-mode, I'd say
07:18:35 <SamB> apparantly if I run "turn-on-haskell-ghci" and then type C-c C-l, it works...
07:19:27 <SamB> but the modeline says "(Haskell GHCi:run)" (or must have done so before I turned on compilation-minor-mode)
07:19:33 <pflanze> ah
07:20:03 <pflanze> I did change the command being started by run-haskell from my .emacs (was Hugs)
07:21:10 <SamB> and no, ghci doesn't need to be started wierdly for that...
07:28:36 <vincenz> fuck
07:28:43 <vincenz> @seen sieni
07:28:43 <lambdabot> sieni is in #haskell-blah and #haskell. I last heard sieni speak 4 hours, 43 minutes and 40 seconds ago.
07:28:52 * vincenz is stuck ini an airport with 5 hours delay
07:29:13 <vincenz> @arr
07:29:13 <lambdabot> Aye
07:29:48 <Heffalump> cast (in Typeable) can't be used on polymorphic things, can it?
07:30:35 <tibbe> SamB, I use C-c C-s to start ghci, together with a hook in my .emacs
07:31:49 <dons> Heffalump: nope
07:32:57 <vincenz> hiya dons
07:44:20 <vincenz> Anyone know a good source to use for "equational reasoning"?
07:44:48 <vincenz> source as in a paper to quote
07:47:33 <edwinb> Depends what you're using it for I suppose...
07:47:47 <edwinb> or how you're doing it
07:48:40 <vincenz> to use as reference
07:53:34 <edwinb> But what are you using it for? Manipulating equations isn't something that was 'invented' in a recent research paper any more than 'arithmetic' is...
07:55:39 <vincenz> well equational reasoning in the sense used by the haskell transformation rules system
07:56:29 <vincenz> dons: you prolly have one, no? given how your fusion paper uses the same system
07:57:45 <edwinb> so cite the haskell transformation rules system then ;)
07:58:45 <vincenz> erm... yeah but I need a reference
07:58:51 <vincenz> ...
07:58:53 <edwinb> Santos' thesis?
07:58:57 <vincenz> that's what I thought I was asking for
07:59:01 <vincenz> ah, I'll check it out, thanks ;:)
07:59:07 <vincenz> @seen sieni
07:59:07 <lambdabot> sieni is in #haskell-blah and #haskell. I last heard sieni speak 5 hours, 14 minutes and 5 seconds ago.
07:59:30 <edwinb> http://citeseer.ist.psu.edu/santos95compilation.html
07:59:41 <vincenz> cool, thanks :)
07:59:49 <vincenz> \o/
07:59:51 <vincenz> perfect
08:00:41 <sek> i have quite a nasty function im trying to build and i'm although quite stuck i'm hoping someone will know some magic Prelude function that will help me. Here is the problem, i want to efficiently generate all n sized vectors (with natural numbers as their elements) such that the sum of the elements of each vector is n, ie (n,0,0...,0),...,(0,...,0,n),(n-1,1,0,0...)...
08:04:01 <sek> i *could* do it using the perms function, but that is SERIOUSLY inneficient
08:05:37 <sek> heck, even with perms this is a nightmare
08:06:27 <mgoetze> sek: can't you just generalize it to n-dimensional vectors with norm m, then iterate over m?
08:07:19 <mgoetze> sek: e.g. n=3, then for m=0 you get (0,0,0), for m=1 you get (1,0,0), (0,1,0), (0,0,1) etc.?
08:08:10 <sek> what about m=2 ?
08:08:27 <twanvl> How about this:
08:08:27 <twanvl> vectors 0   0 = [[]]
08:08:27 <twanvl> vectors 1   n = [n]
08:08:27 <twanvl> vectors len n = [ x:xs | x <- [0..n], xs <- vectors (len-1) (n-x) ]
08:08:40 <mgoetze> sek: you take each of the results for m=1, add 1 at each position, and remove dups
08:09:27 <vincenz> twanvl: that won't type
08:09:28 <sek> hmm
08:09:41 <pflanze> "turn-on-haskell-ghci" works nicely, thanks for the tip SamB
08:10:26 <sjanssen> twanvl: you want [[n]]
08:10:46 <vincenz> probably :)
08:11:28 <sek> mgoetze: so this will work like breadth first search adding 1-increments to every possible location?
08:11:50 <sjanssen> and you could add an additional case: vectors 0 _ = []
08:12:16 <mgoetze> sek: yeah, that was my idea
08:15:00 <sjanssen> hmm, I wonder what the time complexity of twanvl's solution is.  You should be able to do this in O(n ^ 2)
08:15:32 <sek> mgoetze: yeah, this seems to be quite good. I'll try and figure which solutions complexity is better
08:15:56 * edwardk waves ello.
08:20:08 <sjanssen> @undo do x <- [0..n]; xs <- vectors (len - 1) (n - x); return (x:xs)
08:20:09 <lambdabot> [0 .. n] >>=
08:20:09 <lambdabot>  \ x -> vectors (len - 1) (n - x) >>= \ xs -> return (x : xs)
08:20:23 <sjanssen> @. pl undo do x <- [0..n]; xs <- vectors (len - 1) (n - x); return (x:xs)
08:20:24 <lambdabot> ap ((>>=) . vectors (len - 1) . (-) n) ((return .) . (:)) =<< [0..n]
08:20:36 <xerox> sjanssen: now @unmdo !
08:21:07 <sek> i tried the vectors on 15 and its taking ages
08:21:25 <sek> (quite a rough way of checking complexity:p)
08:22:13 <sjanssen> xerox: hmm, that might be doable
08:22:19 <xerox> msure.
08:22:32 <edwardk> heh
08:22:41 * xerox giggles uncontrollably
08:23:00 <sjanssen> except Language.Haskell doesn't parse mdo (as far as I know)
08:23:26 <xerox> So you didn't do @undo just with your own lil parser?
08:23:33 <sjanssen> maybe @redo would be fun
08:24:02 <xerox> Yeah...
08:24:03 <sjanssen> xerox: yeah, I leveraged existing facilities.  You should look at the code, it's very short
08:25:40 <dmhouse> Anyone happen to be an expert in subtyped systems?
08:25:51 <edwardk> subtyped?
08:26:01 <edwardk> substructurally typed, maybe =)
08:26:06 <dmhouse> Specifically someone that knows how to find the meet (greatest common subtype) and join (least common supertype) of two types?
08:26:35 <edwardk> what is the nature of your type system?
08:26:44 <dmhouse> I'm basically working in the pure simply typed lambda calculus with records and Top.
08:26:52 * edwardk nods.
08:27:19 <edwardk> records are easy, just look at the intersection or union of the field list
08:27:24 <dmhouse> Yep.
08:27:31 <dmhouse> Arrow types is where it gets interesting.
08:27:50 <edwardk> with corresponding glb or lub on the field's types if you have them attached to the record
08:27:55 <dmhouse> For the join of two arrow types, I think you take the meet of the domains and the join of the range.
08:28:26 <edwardk> hrmm. arrow types being Pi types in your PTS or real arrows?
08:28:40 <dmhouse> Arrow types as in functional types.
08:28:50 <edwardk> A -> B
08:29:17 <xerox> (Arrow (~>)) => (a ~> b) ?
08:29:25 <edwardk> How far into PTS land are you going with the type system here. do you have dependent types?
08:29:35 <dmhouse> Meaning a function which accepts arguments whose type are a subtype of A, and returns values whose type are a supertype of B.
08:29:40 <edwardk> they can complicate this a whole hell of a lot.
08:29:41 <dmhouse> No, I don't think so
08:29:52 <dmhouse> (As I don't really know what dependent types are :))
08:30:00 <edwardk> xerox: he just wants pi types, not real arrows =)
08:30:17 <edwardk> well, you said PTS so i assumed =)
08:31:02 <dmhouse> PTS?
08:31:12 <edwardk> if you look at a pure type system you can extend your pure type system in a number of directions. you can have terms that depend on terms, terms that depend on types, types that depend on types and types that depend on terms. the last one is dependent types.
08:31:23 <edwardk> pure type system
08:31:33 <edwardk> all pure typed simple lambda calculus
08:31:36 <edwardk> my mistake
08:31:49 <dmhouse> Argh, I've got to dash.
08:31:52 <edwardk> read the pure in that in a more refined context than it was intended =)
08:31:54 <dmhouse> Be back in a bit.
08:31:59 <edwardk> kk
09:16:14 <dmhouse> Wow, the topic changed?!
09:19:23 <edwardk> whoa it did
09:20:00 <edwardk> dm: you get my msgs clarifying the contravariant rule?
09:20:05 <gmak> knock knock
09:20:39 <sjanssen> apparently we don't put the funk in funktion anymore
09:20:49 <gmak> lol
09:21:33 <sjanssen> oh, I guess it's still there
09:24:55 <dmhouse> edwardk: I don't think so
09:28:42 <edwardk> any luck now?
09:28:46 * edwardk ponders.
09:30:19 <edwardk> In any event, subtyping a function allows you to weaken the constraints on its arguments and tighten the constraints on its result. think of it as allowing the subtype to do more and be more specific about its return type.
09:32:40 <dmhouse> edwardk: right.
09:34:13 <edwardk> So the contravariant rule follows. the lub of A -> B and C -> D is glb(A,C) -> lub(B,D) and you can invert to get the other case
09:35:43 <dmhouse> edwardk: that's a general rule?
09:35:51 <spiffy> Hmmm, Im still learning haskell, but I feel i need a bigger project than juust some toy examples. Anyone have any suggestions?
09:35:57 <edwardk> sure
09:36:09 <edwardk> look at it, do the math, it should hold
09:36:33 <dmhouse> Cool, thanks.
09:38:07 <edwardk> that presumes of course that you have sum types, etc.
09:41:03 <dmhouse> edwardk: why?
09:41:10 <sjanssen> lambdabot> redo m1 >>= \x -> m2 x >>= \y -> m3 >> return (f y)
09:41:11 <sjanssen> do { x <- m1; y <- m2 x; m3; return (f y)}
09:41:20 <xerox> sjanssen: yay!
09:42:12 <spiffy> anyone on a good project?
09:42:49 <ndm> spiffy: have you seen the lambdabot plugin @free ?
09:42:51 <Lemmih> spiffy: Cabal-install.
09:42:55 <ndm> @free sort :: [a] -> [a]
09:42:56 <lambdabot> $map f . sort = sort . $map f
09:43:06 <ndm> spiffy: read the paper its based on, and add more rules
09:43:26 <dmhouse> ndm: what does it do?
09:43:26 <ndm> reasonably easy, and working on an existing code base
09:43:38 <ndm> dmhouse: have you heard of Wadler's theorems for free?
09:43:53 <spiffy> ndm: Thanks, ill take a look
09:43:54 <dmhouse> No, I don't think so.
09:44:07 <ndm> dmhouse: you should - consider a function [a] -> [a]
09:44:21 <ndm> i can guarantee that:
09:45:01 <ndm> let res = f inp, means: \forall i, i `elem` res => i `elem` inp
09:45:23 <ndm> and thats without even seeing the function
09:45:27 <sjanssen> map f . sort = sort . map f isn't true for all definitions of f
09:45:43 <ndm> sjanssen: sort isn't [a] -> [a]
09:45:48 <Trix> hi
09:45:49 <ndm> that was a bad choice of name :)
09:45:51 <sjanssen> oh, okay
09:45:58 <dmhouse> ?type sort
09:46:00 <sjanssen> can we give class constraints?
09:46:03 <lambdabot> forall a. (Ord a) => [a] -> [a]
09:46:08 <dmhouse> Oh, the dictionary.
09:46:16 <sjanssen> @free sort :: (Ord a) => [a] -> [a]
09:46:17 <lambdabot> Extra stuff at end of line
09:46:18 <ndm> sjanssen: not yet, depends what spiffy manages :)
09:46:20 <edwardk> dmhouse: well, at least that lub is defined for all types i guess, but sum types give you a nice either abstraction
09:46:27 <rictic_> I'm having a bit of trouble expressing a rather simple thought in Haskell, and I think I'm just getting the syntax wrong.
09:46:47 <ndm> rictic_: show us your code
09:46:50 <rictic_> Say there are two classes, a and b.  How can I say that a type is an instance of class a if it is an instance of type b.
09:46:56 <Heffalump> has anyone here tried writing SYB-style code/
09:46:58 <dmhouse> edwardk: oh, yeah, meet isn't defined for all types, if that's what you're getting to.
09:47:00 <xerox> What is the idea?
09:47:01 <Heffalump> s#/#?#
09:47:21 <edwardk> at last check free doesn't take dictionaries
09:47:23 <ibid> rictic_: make a a subclass of b
09:47:25 <Lemmih> rictic_: You can't. Not in Haskell98 at least.
09:47:28 <xerox> ricebowl: declare the class b as follows: class A a => B a where ...
09:47:34 <dmhouse> rictic_: instance (B t) => A t where ...
09:47:47 <ibid> rictic_: assuming that you meant *class* b, of course
09:47:55 <rictic_> dmhouse: I tried that and got an error
09:47:58 <rictic_> ibid: yes
09:48:02 <xerox> dmhouse: Isn't it the other way around?
09:48:09 <ibid> rictic_: what error?
09:48:14 <rictic_> I'll look into subclasses
09:48:18 <rictic_> One moment
09:48:23 <xerox> dmhouse: so to enforce a to be \in A to be \in B.
09:48:38 <sjanssen> rictic_: you'd have to turn on some extensions, like -fglasgow-exts or maybe -fundecidable-instances
09:48:43 <dmhouse> xerox: oh, perhaps.
09:48:46 <ibid> ah, heh class B t => A t where ... not instance!
09:48:55 <ibid> sjanssen: why?
09:49:10 <xerox> ibid: isn't it the other way around?
09:49:26 <ibid> xerox: yes, i copied dmhouse :)
09:49:30 <xerox> Allright.
09:49:30 <Lemmih> ibid: That's only if he wants to do the instance trick.
09:49:40 <ibid> Lemmih: huh?
09:49:44 <rictic_> Ok, I want to say a type is an instance of Example if it is an instance of Enum
09:49:52 <rictic_> instance (Enum b) => Example b where
09:50:04 <rictic_> Gives me the error
09:50:04 <rictic_> Illegal instance declaration for `Example b'
09:50:04 <xerox> class Enum a => Example a where ...
09:50:04 <rictic_> 	(The instance type must be of form (T a b c)
09:50:05 <rictic_> 	 where T is not a synonym, and a,b,c are distinct type variables)
09:50:05 <rictic_>     In the instance declaration for `Example b'
09:50:10 <Lemmih> ibid: If he has to do ' instance (B t) => A t where'. Ie. if he can't modify the class.
09:50:17 <xerox> Now all Example instances will have to be Enums too.
09:50:30 <ibid> ah well, ok, that you can't do in h98 without changing the definition of Enum :)
09:50:38 <sjanssen> ibid: I'm not sure, try dumping that in GHC and see what it says
09:51:03 <sjanssen> ibid: GHC says "There must be at least one non-type-variable in the instance head"
09:51:07 <ibid> sjanssen: no need, what i suggested will work, but does not apply to rictic_'s problem
09:51:28 * ibid shuts up and goes play with torcs
09:51:48 <xerox> torcsâ½
09:52:13 <ibid> @google torcs
09:52:16 <lambdabot> http://torcs.sourceforge.net/
09:52:16 <lambdabot> Title: TORCS - The Open Racing Car Simulator
09:57:11 <kevinwatkins> quick noob haskell question if anyone is around
09:57:52 <ndm> @users
09:57:53 <lambdabot> Maximum users seen in #haskell: 235, currently: 206 (87.7%), active: 29 (12.3%)
09:58:03 <ndm> kevinwatkins: go forit - quite a few users around
09:58:36 <tieTYT> i'd like a yes or no response to this: if my function starts with the do keyword, am i making a monad?
09:59:00 <kevinwatkins> cool. let's say i map some function over a big tree, and most parts don't change. i want the new tree to mostly share structure with the original one. in ocaml i would do pointer compares as i reconstructed the tree--is there a canonical solution in haskell?
09:59:00 <ndm> tieTYT: you are using a Monad, making a monadic result (so probably yes)
09:59:00 <xerox> Using it.
09:59:10 <tieTYT> ndm: ok thanks
09:59:19 <ndm> kevinwatkins: not really, no
09:59:36 <xerox> kevinwatkins: one nice mean of using trees are zippers I think.
09:59:41 <kevinwatkins> i should say that the constructors in the tree are strict. otherwise i don't think my desire makes much sense
09:59:59 <xerox> kevinwatkins: you can navigate it, modify the subtrees, and go back to the root.
10:00:03 <xerox> All purely functional.
10:00:24 <kevinwatkins> yeah i like the zipper.
10:01:16 <kevinwatkins> the key point it seems is testing whether the result of the map left any particular subtree alone.  i want a quick optimistic test like the pointer compare if possible.
10:01:44 <ndm> no pointer compares, at least in normal haskell - in some sort of state monad you might get that
10:01:49 <ndm> but thats not the normal
10:02:08 <xerox> Is there a reason it is a map
10:02:50 <kevinwatkins> i've pretty much convinced myself that the "right" solution is to generalize the map. instead of returning a new tree it returns an "edit structure" describing how the new tree relates to the old. then a separate function can use the edit structure on the old tree to generate the new tree and share structure.
10:03:54 <kevinwatkins> i guess i can give more detail. the tree is a term in a theorem prover. the map is a substitution operation that instantiates some variables in the term with other terms.
10:04:28 <xerox> Yuck, you might get some higher-order help from the mathematicians here then, hehe.
10:05:35 <kevinwatkins> i'm following mostly john harrison's hol light code in ocaml, but it depends strongly on this pointer compare stuff
10:09:03 <tieTYT> does everybody else get access forbidden when they visit this page? http://www.cs.utah.edu/~hal/htut/
10:09:10 <tieTYT> i'm trying to get the yet another haskell tutorial
10:09:31 <ndm> tieTYT: yes
10:09:54 <tieTYT> does anyone know how else i can get that tutorial?
10:09:56 <ndm> tieTYT: and to the direct PDF link as well :)
10:10:05 <ndm> s/:)/:(/
10:10:36 <kevinwatkins> tieTYT: i copied it to http://watkins.dnsalias.org/tutorial.pdf if that helps
10:10:55 <kevinwatkins> grr.  http://watkins.dnsalias.org/~kw/tutorial.pdf
10:11:08 <tieTYT> great, thanks
10:11:21 <astrolabe> @where zipper
10:11:21 <lambdabot> I know nothing about zipper.
10:11:36 <tieTYT> kevinwatkins: that says forbidden too
10:11:45 <xerox> astrolabe: arrr, want a crash course? :)
10:12:09 <astrolabe> xerox: yes please, but I NEED a bath at the moment.
10:12:20 <tieTYT> this one works: http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
10:12:22 <xerox> astrolabe: allright.
10:12:32 <astrolabe> Are you about later?>
10:12:35 <xerox> Yup.
10:12:36 <tieTYT> you guys think it's the same one?
10:12:47 <astrolabe> Good.  Thanks
10:12:53 * xerox waves
10:12:53 <kevinwatkins> heh.  i copied the 404 page.  sorry.  i had read it just last night
10:13:23 <reppie> xerox sup NERD
10:13:37 <xerox> reppie: doing Erlang
10:13:43 <reppie> lol
10:13:46 <xerox> :P
10:15:13 <kevinwatkins> ah, i found the copy i read last night.  up at watkins.dnsalias.org now.
10:16:07 <tieTYT> kevinwatkins: i donno what that is, but it's not the tutorial
10:17:30 <kevinwatkins> huh.  the title "yet another haskell tutorial" could have fooled me
10:17:42 <tieTYT> that url goes to an image
10:20:32 <kevinwatkins> http://watkins.dnsalias.org/~kw/tutorial.pdf
10:20:50 <kevinwatkins> also huet's zipper paper is http://watkins.dnsalias.org/~kw/huet.pdf
10:22:28 <kevinwatkins> well thanks ndm, xerox. back to work then i guess.
10:23:00 <xerox> There's also the Web, which is a generalization of the zipper, if you are interested at this point.
10:23:55 <kevinwatkins> xerox: fascinating. url?
10:23:56 <bringert> @seen shapr
10:23:56 <lambdabot> I saw shapr leaving #haskell and #ScannedInAvian 10 days, 22 hours, 40 minutes and 15 seconds ago, and .
10:24:45 <bringert> that's odd
10:25:00 <xerox> http://citeseer.ist.psu.edu/hinze01web.html
10:25:02 <bringert> how's everyone doing?
10:25:05 <kevinwatkins> ah, perhaps you mean http://citeseer.ist.psu.edu/hinze01web.html.  will check it out.
10:25:09 <bringert> hi xerox
10:25:14 <xerox> Hello bringert!
10:26:16 <SyntaxNinja> y0
10:26:26 <xerox> Hey there!
10:26:54 <bringert> hi SyntaxNinja
10:27:10 <bringert> SyntaxNinja: is there a deb for hugs may 2006?
10:27:17 <bringert> I couldn't find one
10:30:09 <musasabi> ndm: do you have buildbot Cabal integration classes somewhere?
10:30:51 <tieTYT> ok thanks
10:31:16 <ndm> musasabi: nope, Yhc doesn't use Cabal
10:31:33 <ndm> but it should be as easy as system "runhaskell Setup configure" "runhaskell Setup build" "runhaskell Setup install"
10:31:53 <ndm> there is very little to the Yhc buildbot script - i think its maybe 10 lines long
10:32:00 <ndm> if you want i can get you a copy of it?
10:33:12 <SyntaxNinja> International talk like a pirate day is during ICFP
10:33:14 <SyntaxNinja> bringert: no, not yet.
10:33:32 <bringert> @arr
10:33:33 <lambdabot> I'll crush ye barnacles!
10:34:43 <bringert> SyntaxNinja: ok, thanks.
10:36:25 <ihope> xerox: what's wrong with putting State inside Reader?
10:37:46 <musasabi> seems simple enough to write the Python code.
10:38:27 <ndm> yep, was pretty trivial for us, although we do have a Python expert on teh Yhc team
10:38:59 <ndm> which is why we have a python runtime for Yhc :)
10:50:19 <tieTYT> what's wrong with what i did here? http://paste-bin.com/200
10:50:26 <tieTYT> the error is on readline
10:50:28 <tieTYT> err, read
10:51:27 <ihope> tieTYT: the last statement in that one block is "read readNum". That's not an action.
10:51:29 <ndm> tieTYT: read returns a value, a do block must return a monad
10:51:39 <ndm> return (read x) might get you further
10:51:44 <tieTYT> oh ok
10:52:00 <dmhouse> tieTYT: every line in a do block must be an action, or a 'x <- something' form or a 'let x = y' form.
10:52:15 <ihope> I think you want to replace those last two lines there with num <- readline, then something that does something with num.
10:52:25 <ndm> print $ read num
10:52:26 <ndm> maybe
10:52:52 <ihope> ndm: if tieTYT wants to print it, yes.
10:53:09 <tieTYT> ack this is all stuff i haven't learned yet in the yet another haskell tutorial
10:53:21 <ihope> But it looks like he's wanting asknum to return the number read, so make it just "readLine", not "num <- readLine".
10:53:56 <ihope> So this: http://paste-bin.com/201
10:54:20 <tieTYT> oh ok
10:54:44 <tieTYT> well i haven't been taught readLine yet, i think i'm just going about this wrong
10:56:21 <ihope> readLine = do x <- getLine; return (read x)
10:57:56 <tieTYT> yeah i figured
10:58:01 <tieTYT> thank you
10:58:36 <ihope> Oh, and you can drop the "num <- " in that version I gave you.
10:59:09 <Phillemann> I'm thinking of learning haskell (which would be my first functional language) and am wondering if there are libraries which allow you to send data over the net (a basic socket library would be enough).
10:59:12 <ihope> Actually, you have to... dunno where it came from.
10:59:32 <araujo> hello!
10:59:33 <ihope> Phillemann: yes, there's a Network module, and a Network.Socket one too, I think.
10:59:44 <Phillemann> ihope: Ah, that's great. Thanks. :)
10:59:50 <ihope> @docs Network
10:59:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network.html
11:19:23 <tieTYT> ihope: how do i use the result of an action that returns a list?  this is giving me an error: l <- asknum ; putStrLn "The product is " ++ (foldr (*) 1 l)
11:19:29 <tieTYT> and asknum returns a list
11:20:10 <lament> wow, ihope is here
11:20:13 <lament> ihope: hi!
11:21:50 <ihope> lament: hello.
11:22:07 <ihope> tieTYT: putStrLn ("The product is " ++ (foldr (*) 1 l))
11:22:19 <ihope> Otherwise it thinks you mean (putStrLn "The product is ") ++ (foldr (*) 1 l)
11:22:34 <lament> so many brackets make haskell look like Java :D
11:22:59 <ihope> Well, that same rule lets you remove the parentheses around the foldr thing.
11:23:00 <tieTYT> ihope: yeah really sorry.  I just remembered that
11:28:37 <dmhouse> ?hoogle local
11:28:38 <lambdabot> Control.Monad.Reader.local :: MonadReader r m => (r -> r) -> m a -> m a
11:28:38 <lambdabot> Distribution.Simple.Configure.localBuildInfoFile :: FilePath
11:28:38 <lambdabot> Distribution.Simple.GHCPackageConfig.localPackageConfig :: IO FilePath
11:32:47 * ihope reboots
11:40:14 <tieTYT> still more error: http://paste-bin.com/202
11:40:47 <tieTYT> i donno how to read these error messages very well, but i think it' strying to tell me i called foldr with the last 2 arguments as a number and a list of characters
11:40:54 <tieTYT> but i don't see where it'd get that idea
11:43:35 <basti_> tieTYT: "no instance for A B" means "a B can't be an A".
11:43:44 <basti_> in your case, a list of chars cant be a Number.
11:44:24 <pflanze> How can you trigger a garbage collection manually?
11:44:43 <mGem_> tieTYT I feel your pain, I was there earlier today,  I fixed it by using: putStrLn ("The product is " ++ (show ( foldr (*) 1 result_list)))
11:44:59 <tieTYT> so it thinks i'm trying to say 1 and l are the second argument
11:44:59 <basti_> mGem_: why is that right?
11:45:14 <tieTYT> instead of 1 is the second, and result_list is the third?
11:45:22 <basti_> tieTYT: wait.
11:46:24 <basti_> tieTYT: first, the font you're using appears not to make a big difference between l (L) and 1 (one).
11:46:28 <basti_> I'd fix that asap.
11:46:48 <mGem_> show takes a value and converts it to a string, then I added parens until it stopped complaining :)
11:47:00 <basti_> mGem_: ok ^^
11:47:53 <_JusSx_> who partecipated to icfp thie year?
11:48:00 <basti_> tieTYT: then: the error message gives several informations. For example, it digs up to top level from the error
11:48:17 <basti_> tieTYT: that's why you see several situations mentioned
11:48:45 <tieTYT> basti_: yes well atm i can't decode these error messages
11:49:00 <basti_> the type of foldr was inferred from its 2nd argument. and the neccissairy type of (++) from this.
11:49:13 <tieTYT> mGem: that worked, thanks.  I thought I only had to use show on converting integers to strings, now i get it
11:49:30 <basti_> you have to use show to convert integers to strings in this case.
11:50:00 <tieTYT> wait now i get it (sorta)
11:50:08 <tieTYT> my foldr returns an integer, and that's why i have to use show
11:50:19 <basti_> yea right
11:50:29 <basti_> did you think 1 (one) was an l (L)?
11:50:32 <tieTYT> so if my foldr returned a string i wouldn't have to use it
11:50:45 <tieTYT> basti_: no sorry, that was a typo, i meant to say result_list
11:51:29 <basti_> oh ok
11:53:09 <basti_> any other problematic error messages?
11:53:16 <basti_> we can bring up some from lambdabot.
11:54:07 <tieTYT> nope that solved everything
11:54:31 <tieTYT> another thing i learned from this
11:54:39 <tieTYT> is you can't directly print out a list of numbers
11:54:47 <tieTYT> you have to use show(list) around that too
11:54:50 <basti_> yea, you have to say show
11:54:54 <basti_> (show list)
11:54:58 <basti_> I'd put it like that
11:55:00 <SamB> > show list
11:55:00 <mauke> > print [1,2,3]
11:55:02 <lambdabot>  Not in scope: `list'
11:55:02 <lambdabot>  No IO allowed
11:55:09 <SamB> > show [1,2,3]
11:55:10 <lambdabot>  "[1,2,3]"
11:55:18 <basti_> but the ( ) are unneccissary in the most cases
11:55:22 <SamB> @. read run show [1,2,3]
11:55:24 <lambdabot>  [1,2,3]
11:55:24 <tieTYT> that was something, as far as i recall, that the "yet another haskell tutorial" didn't bring up at by chapter 3
11:55:26 <basti_> " " binds very tight
11:55:37 <basti_> it's rather obvious
11:55:47 <tieTYT> i mean chapter 4
11:56:18 <SamB> @. read run unlines (map show [1,2,3])
11:56:19 <lambdabot>  123
11:56:21 <SamB> hmm
11:56:22 <tieTYT> well from a java background, every object has a toString()
11:56:25 <SamB> @run unlines (map show [1,2,3])
11:56:26 <lambdabot>  "1\n2\n3\n"
11:56:33 <SamB> okay...
11:56:40 <SamB> @help read
11:56:41 <lambdabot> read "<foo>". Print <foo>
11:56:45 <tieTYT> so i can say println("hello" + 1 + myObject);
11:56:49 <tieTYT> that's why i was confused
11:56:53 <SamB> something is wrong with @read?
11:57:06 <tieTYT> i just gotta remember that if i'm gonna print a number, i gotta use show
11:57:10 <tieTYT> thanks a lot for the help
11:57:11 <basti_> tieTYT: see, and in haskell, every object that you can print is "instance" of the class "Show" and thus implements show.
11:57:26 <int-e> SamB: stripping newlines and adding spaces in front is a read feature.
11:57:32 <Pupeno_> > [1,2,3]
11:57:33 <lambdabot>  [1,2,3]
11:57:40 <int-e> SamB: meant to stop certain abuses.
11:57:42 <Pupeno_> why do you need show there ?
11:57:52 <tieTYT> i see
11:58:12 <SamB> int-e: I thought the spaces thing was a standard lambdabot thing
11:58:25 <SamB> only not in front of things not starting with @
11:58:28 <SamB> or ?
11:58:32 <basti_> Pupeno_: not there, but everywhere else ^^
11:58:37 <SamB> or >
11:59:08 <SamB> personally I was thinking the coolest thing about @read might be the ability to do that...
11:59:21 <SamB> anyway, the docs lie in that case
11:59:22 <Pupeno_> basti_: I believed that the value of an expression in the REPL would get printed using show on it (not making the call to show necessary).
11:59:43 <Pupeno_> basti_: when it doesn't work ?
11:59:52 <basti_> Pupeno_: yea, but tieTYT's problem was not directly in the REPL
12:00:03 <SamB> > id :: Int -> Int
12:00:04 <lambdabot>  <Int -> Int>
12:00:09 <Pupeno_> basti_: oh!
12:00:12 <SamB> > show (id :: Int -> Int)
12:00:13 <lambdabot>  "<Int -> Int>"
12:00:48 <SamB> > return () :: State () ()
12:00:49 <lambdabot>  add an instance declaration for (Show (State () ()))
12:01:34 <xerox> !
12:01:53 <xerox> "<() -> ((),())>"
12:02:00 <xerox> This would be cool :)
12:02:14 <int-e> but that isn't state.
12:02:43 <xerox> Hmmm?
12:02:46 <SamB> neither is return () :: State () ()
12:02:55 <SamB> thats just a monadic value!
12:02:55 <int-e> > runState { return () :: State () () }
12:02:56 <lambdabot>  Parse error
12:03:03 <int-e> > runState ( return () :: State () () )
12:03:04 <lambdabot>  <() -> ((),())>
12:03:11 <xerox> haha nice
12:03:18 <xerox> ?karma+ int-e
12:03:18 <lambdabot> int-e's karma raised to 18.
12:04:03 <xerox> Now let's make lambdabot do it
12:04:12 <xerox> It'd be fun with transformers
12:04:20 <int-e> add a 'deriving Show' in Control.Monad.State
12:04:32 <SamB> int-e: won't work!
12:04:37 <mauke> @type liftM liftM
12:04:38 <lambdabot> forall a1 r (m :: * -> *) (m1 :: * -> *). (Monad m1, Monad m) => m1 (a1 -> r) -> m1 (m a1 -> m r)
12:04:44 <int-e> SamB: are you sure?
12:05:00 <SamB> it only works if the Show instance for (a -> b) is seen
12:05:16 <int-e> it'd print <State { runState = (() -> ((),())) }> of course.
12:05:28 <SamB> eh...
12:05:30 <SamB> you mean...
12:05:48 <SamB> State { runState = <() -> ((),())> }
12:05:58 <int-e> uhm. right. yes.
12:06:09 <SamB> but only if the instance for (->) was in scope...
12:06:10 <int-e> > (id :: Int -> Int, 42)
12:06:11 <lambdabot>  (<Int -> Int>,42)
12:06:20 <int-e> which it would be in lambdabot
12:06:22 <int-e> it doesn
12:06:42 <kevinwatkins> > id
12:06:43 <lambdabot>  Add a type signature
12:06:44 <SamB> int-e: but not in Control.Monad.State
12:06:45 <int-e> it doesn't have to be in scope in Control.Monad.State.
12:06:50 <Pupeno_> Is ((==) 0 . length) an equivallent definition of null ?
12:06:54 <SamB> try it and see
12:06:56 <xerox> Pupeno_: nope.
12:07:05 <xerox> Pupeno_: it introduces an Eq constraint in the type.
12:07:08 <Heffalump> it does?
12:07:16 <Heffalump> it introduces an Eq Int constraint
12:07:18 <xerox> Hm.
12:07:20 <xerox> Right.
12:07:21 <Heffalump> which is trivially satisfiable
12:07:29 <xerox> But it doesn't work with infinite lists.
12:07:31 <Heffalump> ?type length
12:07:33 <lambdabot> forall a. [a] -> Int
12:07:34 <SamB> yah!
12:07:37 <xerox> So it's still not the same.
12:07:39 <SamB> and it forces the list too!
12:07:41 <Heffalump> it also doesn't work with lists of length 2^32 ;-)
12:07:47 <int-e> SamB: by the same argument, Show instances for lists for types other than those visible in Prelude would break down.
12:07:47 <Pupeno_> ?type ((==) 0 . length)
12:07:49 <lambdabot> forall a. [a] -> Bool
12:07:51 <xerox> null [] = True; null _ = False
12:07:54 <Pupeno_> ?type null
12:07:55 <lambdabot> forall a. [a] -> Bool
12:07:56 <xerox> This works with infinite lists.
12:07:56 <mauke> @type (liftM (*2) (+1))
12:07:58 <lambdabot> forall a. (Num a) => a -> a
12:07:58 <SamB> Heffalump: those are approximately infinite anyway
12:08:14 <Heffalump> tell that to Turing
12:08:18 <xerox> > null [1..]
12:08:18 <SamB> int-e: no, because those are parametric...
12:08:19 <lambdabot>  False
12:08:20 <xerox> > null []
12:08:21 <lambdabot>  True
12:08:28 <int-e> so is state
12:08:32 <xerox> > ((0==) . length) [1..]
12:08:36 <kevinwatkins> if you made a length returning a lazy natural number it would work.
12:08:36 <lambdabot> Terminated
12:08:56 <xerox> kevinwatkins: a lazy natural number? :)
12:09:00 <Heffalump> ok, so use genericLength and define a Nat type ;-)
12:09:06 <kevinwatkins> data Nat = Zero | Succ Nat
12:09:14 <SamB> stuff like "(Show (a -> (s, a))) => State s a" isn't allowed...
12:09:23 <mauke> @type liftM liftM liftM
12:09:24 <SamB> afaik
12:09:25 <lambdabot> forall (m :: * -> *) a1 r (m1 :: * -> *). (Monad m, Monad m1) => (a1 -> r) -> m (m1 a1) -> m (m1 r)
12:09:39 <kpreid> > let x = 10^12 :: Integer in (x, length (genericReplicate x ()))
12:09:42 <int-e> SamB: the derived instance is: instance Show (s -> (a, s)) => Show (State s a)
12:09:43 <lambdabot> Terminated
12:09:50 <sjanssen> genericLength + Nats probably won't work.  I imagine genericLength is tail recursive
12:09:53 <xerox> mauke: find the fixed point :D
12:10:04 <SamB> > undefined :: (Show (a -> (s, a))) => State s a -> String
12:10:05 <lambdabot>    Non-type variables in constraint: Show (a -> (s, a))
12:10:05 <lambdabot>   (Use -fglasgow-...
12:10:22 <SamB> oh
12:10:31 <mauke> > liftM liftM liftM (++) tail "foo" "bar"
12:10:32 <lambdabot>  Couldn't match `t -> [a]' against `[a1]'
12:10:35 <SamB> dunno how well that would work then...
12:10:35 <mauke> hmm
12:11:03 <SamB> that wasn't the message I would have expected
12:11:06 <SamB> as far as it went
12:11:09 <SamB> which was not very far
12:11:14 <xerox> ?type let fix f = f `liftM` (fix f) in fix
12:11:15 <lambdabot> forall r (m :: * -> *). (Monad m) => (r -> r) -> m r
12:11:19 <xerox> ^_^
12:11:48 <mauke> > liftM liftM liftM tail (++) "foo" "bar"
12:11:49 <lambdabot>  "oobar"
12:12:47 <int-e> SamB: *ShowQ Control.Monad.State2> return () :: State () ()  --->  State {runState = <() -> ((),())>}
12:13:53 <xerox> ?type liftM liftM liftM null (++) "" ""
12:13:55 <lambdabot> Bool
12:13:55 <xerox> lol
12:15:05 <xerox> What the...? :)
12:15:32 <Heffalump> gaaaah
12:15:32 <mauke> liftM == (.)
12:15:50 <xerox> ?type (.) (.) (.)
12:15:51 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
12:16:04 <xerox> > (.) (.) (.) null (++) "" ""
12:16:05 <lambdabot>  True
12:16:11 <Heffalump> the instance members of IArray are all hidden, so I can't wrap arrays in a newtype to make new ones and declare them in IArray.
12:16:11 <xerox> ?type liftM liftM liftM null (++) "" ""
12:16:13 <lambdabot> Bool
12:16:22 * xerox giggles uncontrollably
12:16:35 <mauke> remember to use `liftM` instead of . in your programs!
12:17:28 <xerox> > ((*2) `liftM` (+1) `liftM` (/5)) 10
12:17:29 <lambdabot>  6.0
12:17:38 <xerox> > ((*2) . (+1) . (/5)) 10
12:17:40 <lambdabot>  6.0
12:18:18 <mauke> > ((*2) `fmap` (+1) `fmap (/5)) 10
12:18:18 <lambdabot>  Parse error
12:18:25 <mauke> > ((*2) `fmap` (+1) `fmap` (/5)) 10
12:18:26 <lambdabot>  6.0
12:24:23 <nuffer> can anyone suggest an ide for osx?
12:25:22 <twanvl> eclipse?
12:25:53 <nuffer> is that really the best there is?
12:26:16 <nuffer> (I'm looking for something a little more lightweight)
12:26:22 <kevinwatkins> vi
12:26:26 <integral> teco
12:27:14 <nuffer> teco?
12:27:23 <SamB> Heffalump: tried Data.Array.Base?
12:27:36 <nuffer> oh, like emacs
12:27:54 <Heffalump> SamB: that doesn't export unsafe*
12:28:05 <phas> hi, i'm trying to compile hs-plugin from darcs and i get
12:28:06 <SamB> huh
12:28:09 <int-e> Data.Array.Base exports everything?
12:28:12 <phas> /usr/bin/ar: creazione di dist/build/libHSplugins-1.0.a
12:28:13 <phas> /usr/bin/ar: dist/build/src/Language/Hi/hschooks.o: Nessun file o directory
12:28:21 <Heffalump> oh, so it does
12:28:22 <Heffalump> sorry
12:28:24 * Heffalump is a fule
12:28:27 <Heffalump> thank you :-)
12:29:32 <SamB> Heffalump: heh
12:29:39 <SamB> I was just about to paste this:
12:29:43 <SamB> module Data.Array.Base where
12:29:49 <Heffalump> yes, I was reading the source
12:29:53 <Heffalump> I was just confused.
12:31:37 <SamB> with a name like Data.Array.Base, you'd kind of expect it to export at least the whole classes involved...
12:32:29 <SamB> hopefully no overzealous cabalizer decided to hide that module...
12:33:03 <SamB> good, there aren't any hidden modules in base ;-)
12:33:21 <xerox> phas: maybe you need haskell-exts
12:33:21 <int-e> arguable IArray should export the unsafe stuff, too.
12:33:24 <xerox> I am not sure
12:33:26 <int-e> *arguably.
12:34:14 <Heffalump> no, I don't think it should
12:34:19 <SamB> int-e: arguably
12:34:23 <Heffalump> Base is what extenders should use, IArray is what users should use
12:34:33 <SamB> but yeah ;-)
12:34:59 <SamB> arguably Base might be better split into what voodoo implementors and regular implementors would use...
12:35:38 <SamB> (or what implementors would use and what people writing RULES would use)
12:36:25 <int-e> IArray should at least export unsafeAt, too, in my opinion.
12:37:03 <xerox> @where haskell-exts
12:37:03 <lambdabot> I know nothing about haskell-exts.
12:38:20 <ivant> @pl [fst,snd] `ap` return (3,2)
12:38:20 <lambdabot> [fst, snd] `ap` return (3, 2)
12:38:31 <ivant> hmm
12:38:31 <lambdabot> ivant: You have 1 new message. '/msg lambdabot @messages' to read it.
12:39:05 <xerox> ivant: make parameters parameters, free vars aren't pl-ed out
12:39:55 <ivant> oh, sure
12:40:10 <ivant> @pl [a, b] `ap` return (c, d)
12:40:11 <lambdabot> [a, b] `ap` return (c, d)
12:40:20 <ivant> :-)
12:40:31 <int-e> @pl \a b -> [fst,snd] `ap` return (a,b)
12:40:31 <lambdabot> ((([fst, snd] `ap`) . return) .) . (,)
12:40:43 <ivant> oh, stupid me
12:40:44 <int-e> @pl \fst snd -> [fst,snd] `ap` return (a,b)
12:40:45 <lambdabot> flip flip (return (a, b)) . (ap .) . (. return) . (:)
12:42:02 <ivant> \(a,b) -> [fst a, snd b]
12:42:08 <ivant> @pl \(a,b) -> [fst a, snd b]
12:42:09 <lambdabot> uncurry ((. (return . snd)) . (:) . fst)
12:42:36 <xerox> @pl \f g x y -> [f,g] `ap` return (x,y)
12:42:37 <lambdabot> flip flip ((return .) . (,)) . (((.) . (.) . ap) .) . (. return) . (:)
12:42:41 <xerox> ?type \f g x y -> [f,g] `ap` return (x,y)
12:42:42 <lambdabot> forall b a b1. ((a, b1) -> b) -> ((a, b1) -> b) -> a -> b1 -> [b]
12:42:55 <ivant> something evil is going on here
12:43:17 <kevinwatkins> i wonder how to convince my client not to turn the list constructor into a smiley
12:44:05 <Cale> kevinwatkins: which client?
12:44:34 <xerox> GAIM?
12:45:00 <xerox> Yep. Check options, somewhere...
12:45:09 <xerox> You change the smiley theme to nothing
12:45:11 <Cale> Smiley Themes -> None
12:45:39 <kevinwatkins> yeah... although it does lend a certain levity to the code... i wonder if apl had a smiley operator
12:45:57 <kevinwatkins> thanks... just found it
12:46:38 <kevinwatkins> obviously i should be using a haskell client.  or writing one if it doesn't yet exist
12:48:17 <ivant> kevinwatkins: there is Hircules listed here: <http://haskell.org/haskellwiki/Libraries_and_tools/Network>
12:48:26 <ivant> kevinwatkins
12:48:36 <ivant> not sure if it works though
12:51:24 <Heffalump> anyone know how to write a Typeable instance for a datatype with kind (* -> * -> *) -> * -> * ?
12:52:41 <Igloo> Can't you derive Typeable these days?
12:53:05 <xerox> What's that, an arrow transformer? :D
12:53:20 <edwardk> heh icfp articles in traditional press http://www.post-gazette.com/pg/06228/713708-115.stm
12:53:21 <lambdabot> Title: Fiction-filled computer code mystery peppered with 'ancient' puzzles
12:53:46 <dmhouse> xerox: that would surely be (* -> * -> *) -> (* -> * -> *)
12:53:52 <Heffalump> it's refusing to do it for my type, and in fact what I need is a Typeable2 instance.
12:54:02 <Heffalump> [20:46] <ivant> not sure if it works though
12:54:04 <Heffalump> oops, sorry
12:54:08 <Heffalump> newtype OpaqueArray a i e = OpaqueArray (a i e)
12:54:11 <Heffalump> as it happens
12:54:16 <xerox> dmhouse: hmmmm why?
12:54:20 <edwardk> heff i'll have to switch gears and figure it out, i had to do a similar case a few days ago
12:54:26 <edwardk> one sec.
12:54:32 <Heffalump> oh, ta
12:55:02 <dmhouse> ?kind ListT
12:55:04 <lambdabot> Not in scope: type constructor or class `ListT'
12:55:08 <dmhouse> ?hoogle ListT
12:55:09 <lambdabot> Control.Monad.List.ListT :: m [a] -> ListT m a
12:55:09 <lambdabot> Control.Monad.List.ListT :: newtype ListT m a
12:55:09 <lambdabot> Language.Haskell.TH.ListT :: Type
12:55:15 <edwardk> the typeable stuff is a PITA ;)
12:55:19 <dmhouse> ?kind Control.Monad.List.ListT
12:55:20 <lambdabot> (* -> *) -> * -> *
12:55:26 <dmhouse> xerox: oh, never mind.
12:55:37 <dmhouse> xerox: no, wait. I am right, I think.
12:55:45 <xerox> dmhouse: I mean, it returns a type, not an Arrow
12:55:47 <araujo> > "hello" ++ (take 9 $ repeat '!')
12:55:48 <lambdabot>  "hello!!!!!!!!!"
12:56:23 <dmhouse> xerox: a X transformer is something that takes an X and returns another (normally different) one.
12:56:43 <edwardk> gah can't find the code.
12:56:43 <xerox> ?kind Monad.Identity.IdT
12:56:45 <lambdabot> Couldn't find qualified module.
12:56:51 <xerox> ?kind Control.Monad.Identity.IdT
12:56:53 <lambdabot>   Not in scope: type constructor or class `Control.Monad.Identity.IdT'
12:56:54 <xerox> ?kind Control.Monad.Identity.IdentityT
12:56:55 <lambdabot>   Not in scope: type constructor or class `Control.Monad.Identity.IdentityT'
12:57:01 <dmhouse> It would surely be the same as ListT.
12:57:23 <Heffalump> I can't find Typeable instances for any of the monad transformers in the standard library, sadly.
12:57:32 <xerox> No IdentityT hehe
12:57:49 <edwardk> yeah. i needed to put one together for StateT, i remember running into various problems with it
12:57:55 <Heffalump> I think I might just give up on parametrising my OpaqueArray type by the underlying array
12:58:11 <xerox> Phantom Types?
12:58:23 <Heffalump> I'm not sure how those are relevant.
12:58:31 <edwardk> oh thats right, i couldn't pull it off. i wound up falling back on using hsplugins unsafe stuff
12:58:48 <Heffalump> grmph
12:58:50 <Heffalump> ok, thanks :-)
12:58:52 <xerox> If you need to parametrize by a type I think that's their purpose, I might be wrong.
12:58:57 <Heffalump> at least I know to give up quickly now
12:58:58 <edwardk> it was when i was slapping together the haskell jit
12:59:04 <edwardk> for the icfp stuff
12:59:56 <edwardk> i needed to make a typable StateT, so i could pass in a particular StateT monad instance to an hs-plugin
13:00:08 <Igloo> Heffalump: Is   newtype OpaqueArray (a :: * -> * -> *) i e = OpaqueArray (a i e) deriving Typeable2   not what you want?
13:00:25 <Heffalump> does that work?
13:00:29 <Igloo> Yes
13:00:39 <edwardk> hah
13:00:41 <Heffalump> and the explicit kind is what makes it work?
13:01:13 <Heffalump> thanks :-)
13:01:21 <kevinwatkins> thanks edwardk... cool article.  amusingly tom7 and bob harper are almost indistinguishable in the photo
13:01:27 <edwardk> it works?
13:01:30 <edwardk> neat =)
13:01:34 <Heffalump> oh, no, it works without the explicit kind
13:01:36 * Heffalump is confused now
13:02:01 <edwardk> heff: oh yeah, i coudn't use that coz i couldn't afford the newtype thats why
13:02:12 <edwardk> didn't want to have to derive a half dozen instances
13:02:23 <Igloo> Oh, I didn't read it right and thought I'd need to tell it the kind. But yes, works either way
13:02:36 <Heffalump> ah. No, it doesn't.
13:02:40 <Heffalump> It's just using newtype deriving.
13:02:43 <Heffalump> Which is not what I want.
13:03:01 <Heffalump> at least I don't think it is
13:03:01 <Igloo> Ah, yes
13:03:22 <edwardk> you need this for a monad transformer?
13:03:36 <Heffalump> no, I need it for my OpaqueArray type above
13:03:41 <edwardk> ah
13:03:46 <Heffalump> basically, I don't like the Data instance of Array supplied with the standard library
13:03:52 <Heffalump> so I need to make my own Array type
13:04:04 <edwardk> fair enough
13:04:59 <edwardk> so, question, how often do you folks find yourself using the numerical operators in haskell? just curious. i notice i use them less and less as i use more and more higher order functions.
13:05:31 <edwardk> i mean, yeah one here and there to say how i'm folding, or whatnot
13:06:44 <Heffalump> well, it depends what I'm doing..
13:07:01 <Heffalump> I would say I don't use them as much as in C, but not that far off
13:07:12 <edwardk> maybe its just a function of the fact that i havent been writing numerical code lately
13:11:14 <Heffalump> hangon, I think this is actually easy
13:11:35 <Heffalump> you just make typeOf3 _ =                                                       typeOf (g a)]
13:11:38 <Heffalump>         where f :: Array i e -> i
13:11:41 <Heffalump>               f = undefined
13:11:43 <Heffalump>        
13:11:45 <Heffalump> typeOf3 _ = mkTyConApp (mkTyCon "Data.Array.OpaqueArray") []
13:11:47 <Heffalump>        g :: Array i e -> e
13:11:50 <Heffalump>               g = undefined
13:11:52 <Heffalump> aargh, sorry
13:12:54 <Heffalump> oh, no
13:13:13 <Heffalump> but nearly
13:17:02 <edwardk> unfortunately typeof3 assumes that all of the types are of the simple kind
13:17:34 <bringert> I'm trying the ghc testsuite for the first time, but I'm getting a python error: "AttributeError: 'module' object has no attribute 'local'"
13:17:54 <bringert> when running make in testsuite/tests/ghc-regress
13:19:49 <Igloo> bringert: You need python 2.4
13:20:16 <Heffalump> edwardk: yeah, the answer seems to be that I can only declare Typeable2 for it
13:20:23 <bringert> ah, the README says "NOTE: you need Python (any version >= 1.5 will probably do) in order
13:20:24 <bringert> to use the testsuite."
13:20:50 <eivuokko> Oops
13:20:59 <eivuokko> Gotta patch that as well
13:21:09 <eivuokko> I changed testsuite recently so it requires 2.4
13:21:33 <edwardk> it should be possible to construct a typeable3 instance, its just beyond my ken at this point.
13:21:54 <Heffalump> I don't think it is, it's badly kinded
13:21:59 <bringert> also, the http://cvs.haskell.org/trac/ghc/wiki/GhcDarcs page says taht you can run "make fast" from the testsuite dir, but it seems like you have to be in tests/ghc-regress
13:22:00 <Igloo> Pah, that's only days out of date. nofib's README claims "This version of nofib only supports ghc-2.05"
13:22:01 <lambdabot> Title: GhcDarcs - GHC - Trac
13:22:15 <bringert> haha
13:22:25 <bringert> funniest thing today
13:22:35 <bringert> I'm serious
13:23:13 <bringert> eivuokko: would it be possible to check the python version and give some simple error message if it's too old?
13:24:19 <eivuokko> Probably, but I'd need to check out how.
13:24:31 <eivuokko> I'm not exactly a python programmer.
13:24:35 <edwardk> ah perhaps you're right.
13:26:03 <eivuokko> bringert, It is a good idea, I'll try to come up with a patch to that effect.
13:26:03 <tieTYT> what the heck is wrong with this line: putStrLn ("The factorial of " ++ (show x) ++ " is " ++ (fact x))
13:26:08 <eivuokko> Thankss
13:26:11 <tieTYT> fact is a function i made
13:26:18 <mauke> tieTYT: show (fact x)
13:26:23 <bringert> eivuokko: python -V seems to print out the version number
13:26:29 <tieTYT> ah god damn it
13:26:33 <tieTYT> same mistake i made previously
13:26:34 <tieTYT> thanks
13:26:48 * bringert upgrades python
13:32:46 <edwardk> heff: that makes me feel better about the 4 hours i spent on my statet problem ;)
13:50:20 <Heffalump> is the MIME base64 encoding standard?
13:50:46 <Heffalump> (as in is the way MIME does it the standard way to use Base64)
13:51:19 <ivant> Heffalump: I always thought it was a standard
13:54:53 <lucca> Heffalump: in general, yes, though some things use a different base64 alphabet
13:55:07 <lucca> generally changing punctuation characters
13:55:27 <Heffalump> ta
14:14:13 <edwardk> base64 normally matches up with mime, normally its A-Za-z0-9+/ but the last 2 chars see lots of variations. !-, *-, _-, .-, _:
14:14:20 <edwardk> afk
14:20:45 <tieTYT> could anyone help me with this?
14:20:46 <tieTYT> http://paste-bin.com/203
14:22:56 <jrmole> printFact is IO code
14:23:00 <eivuokko> map isn't a monadic action, you can only have monadic actions, and lets, in do-block.
14:23:06 <psi`> tieTYT: main has type IO (), so the last line of your do expression must have that type.
14:23:33 <jrmole> @type map
14:23:35 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
14:23:39 <tieTYT> god
14:23:40 <eivuokko> Erm, actually map is monadic action, just not right type as others explained.
14:23:56 <tieTYT> the yet another haskell tutorial seems to have introduced do's waaay to early
14:24:11 <tieTYT> i don't know what i'm doing yet, but there seems to be all these rules for me to accomplish this exercise it gave me
14:24:45 <svref> I have a big record datatype called "vehicle", with 6 or so items in it.  Is there anything analogous to Pascal's "with" or Common-Lisp's "with-slots" construct, that don't require me to type (velocity vehicle) (max_accel vehicle)... ad naseum?
14:24:54 <jrmole> what you get by map printFact result_list is, for each integer, a description of how one would print that integer and its factorial
14:25:13 <jrmole> svref, with lists you can map ($ vehicle)
14:25:38 <svref> jrmole: huh?  I don't understand
14:25:53 <Cale> jrmole: that isn't likely to be typeable
14:25:59 <mauke> svref: hmm, wouldn't that require macros?
14:26:06 <Cale> unless all the field extractors are the same type
14:26:14 <Cale> you could use the ((->) e) monad :)
14:26:46 <jrmole> yeah, you're right
14:26:48 <Cale> (do vel <- velocity; ma <- max_accel; ...) vehicle
14:27:14 <Cale> But what is it that you're really after?
14:27:19 <Cale> Are you updating records?
14:27:25 <Cale> You can use the record update syntax
14:27:33 <jrmole> tieTYT, try mapM_ instead of map
14:27:45 <Cale> vehicle { max_accel = max_accel vehicle + 1 }
14:28:16 <Cale> tieTYT: yeah, it does possibly introduce them a little too early
14:28:34 <Cale> tieTYT: If you're doing IO, read my quick introduction to IO on the Haskell wiki, let me get you a link
14:28:37 <svref> Cale: yes I plan to create an updated record sometimes, but othertimes I want to type: x + v*t + 1/2*a*t^2, where x,v,a are taken from the vehicle record...
14:28:51 <jrmole> basically with a plain map, you're just making a list of IO actions for each integer... with mapM_ you tie those actions together into a single action, which is what the do notation wants
14:28:56 <Cale> svref: use let
14:29:25 <Cale> tieTYT: http://www.haskell.org/haskellwiki/Introduction_to_IO
14:29:27 <lambdabot> Title: Introduction to IO - HaskellWiki
14:30:00 <tieTYT> ok here's the solution from that tutorial
14:30:04 <svref> the problem with let, is the number of slots is not really settled on, so let (x v a _ _ _ _ _) will work today, but tomorrow when I add a "lane" field, I have to change all callers to have the right number of _s, right?
14:30:12 <Cale> no
14:30:16 <Cale> use record syntax
14:30:21 <nuffer> if I wanted fast 2d graphics in osx, what library would I look at?
14:30:30 <tieTYT> http://paste-bin.com/204
14:30:50 <tieTYT> this is the line i needed to get my previous attempt to work: listFactorials [] = return ()
14:30:50 <Cale> let Object { position = x; velocity = v; accel = a } = my_object
14:31:06 <jrmole> tieTYT, your listFactorials is basically a specialized mapM_
14:31:09 <tieTYT> as far as i can tell, there's know way i could have known that
14:31:25 <jrmole> @type mapM_
14:31:26 <svref> Cale: cool, okay, that's what I need!
14:31:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
14:31:38 <tieTYT> i don't understand how to read this stuff yet
14:31:44 <tieTYT> i'm just starting
14:31:44 <jrmole> the type signatures?
14:31:48 <tieTYT> yes
14:31:56 <Cale> tieTYT: return () is the action which does nothing and returns the empty tuple
14:32:09 <Cale> It's sort of a no-op
14:32:17 <tieTYT> Cale: i thought tuples != lists
14:32:23 <tieTYT> why is it returning () instead of returning []?
14:32:29 <Cale> listFactorials doesn't return a list
14:32:46 <Cale> It returns an IO ()
14:32:55 <tieTYT> true but i still have the same question
14:32:58 <jrmole> () is a type, basically equivalent to C's void type.  it contains one value, also called ()
14:33:01 <yip> nuffer: opengl is pretty popular
14:33:09 <nuffer> okay
14:33:14 <Cale> Actually, if you want to be picky, () has two values
14:33:17 <nuffer> any particular set of bindings?
14:33:22 <tieTYT> first
14:33:25 <nuffer> HOpenGL?
14:33:29 <mauke> > undefined :: ()
14:33:31 <lambdabot>  Undefined
14:33:36 <tieTYT> do you guys recommend a better tutorial than "yet another haskell tutorial"?
14:33:45 <yip> nuffer: ghc comes with it's own bindings
14:33:48 <jrmole> specialize mapM_ to (a -> IO ()) -> [a] -> IO () ... it takes two arguments.  the first is a function of type a -> IO (); that is, a way to take a value of type a, and do some IO, returning nothing (that is, the useless value ())
14:33:59 <Cale> tieTYT: not really, though for monadic stuff (IO and do notation), you should look at separate tutorials
14:34:01 <jrmole> the second argument to mapM_ is a list of such values of type a
14:34:11 <nuffer> oh, okay
14:34:20 <nuffer> and for windowing?
14:34:27 <jrmole> then mapM_ serves to do that IO for each element of said list, and the overall result of the mapM_ is some IO, thus the return type IO ()
14:34:36 <Cale> tieTYT: YAHT is a good (possibly the best right now) general tutorial, but there are better ones for specific topics
14:34:58 <tieTYT> should i just ignore its initial introduction to do?
14:35:03 <tieTYT> since it left me totally confused
14:35:05 <Cale> tieTYT: read mine :)
14:35:13 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
14:35:15 <lambdabot> Title: Introduction to IO - HaskellWiki
14:35:18 <yip> nuffer: gtk+ and sdl are good. or you can try glut
14:35:35 <tieTYT> am i ready for it?  I just know chapter 3 of the yaht
14:35:37 <tieTYT> ok i'll try that
14:35:49 <nuffer> any of those built into ghc?
14:35:53 <xerox> @ghc
14:35:53 <lambdabot>  Implicit-parameter bindings illegal in a parallel list comprehension
14:36:24 <Cale> tieTYT: It's just a quick intro to how IO is handled which should give some idea of how you should be thinking about IO-things.
14:37:20 <jrmole> i learned from http://www.cs.caltech.edu/courses/cs11/material/haskell/lectures/haskell_lecture_3.pdf
14:37:35 <jrmole> pg. 16 and on
14:37:40 <yip> nuffer: i think glut might be. actually i think that the haskell sdl bindings might have problems on osx. and i've also heard that gtk+ might have problems on osx
14:38:32 <nuffer> heh
14:38:36 <nuffer> I'll check out glut first then
14:38:53 <tieTYT> i don't know this notation: main :: IO ()
14:39:00 <tieTYT> is that the same as import IO
14:39:05 <araujo> no
14:39:06 <jrmole> it's a type signature
14:39:07 <nuffer> no
14:39:14 <jrmole> it's saying that the value named main has type IO ()
14:39:15 <nuffer> it says main is a function of type IO ()
14:39:18 <Cale> It says that main has type IO ()
14:39:24 <Cale> heh
14:39:36 <jrmole> where () is this useless type with only value (), and IO takes a "pure" type and makes it into a type which can do IO if used in a do block, etc.
14:39:56 <Cale> Well, not entirely useless ;)
14:40:30 <jrmole> if you say so ;)
14:40:39 <Cale> I mean, we're using it here
14:40:42 <Cale> I suppose the point is that a value of type () doesn't really carry much information with it.
14:40:45 <lament> *cough*
14:40:48 <araujo> tieTYT: that could be something like, io_t main (); ... in a common imperative dialect
14:40:57 <lament> IO () main() {
14:40:59 <lament>   return ();
14:41:00 <lament> }
14:41:03 <araujo> tieTYT: we just like things a .. bit different ;-)
14:41:18 <jrmole> the analogy is broken though, because in C it's assumed that any function can do some IO if it wants
14:41:27 <Cale> araujo: no, it'd be  void main (void);
14:41:29 <xerox> @arrr
14:41:30 <lambdabot> Aye Aye Cap'n
14:41:40 <jrmole> tieTYT, do you understand what is meant by referential transparency?
14:41:49 <tieTYT> this wiki page is way over my head at this point
14:41:52 <Cale> C functions can perform side effects by default, so it woun't return anything :)
14:41:54 <araujo> jrmole: who said i am talking about C?
14:41:57 <Cale> wouldn't*
14:42:18 <jrmole> araujo, find me a side-effect-free imperative language ;)
14:42:20 <araujo> That's just a pseudo line i am showing to him , explaining that we do type signature differently
14:42:21 <tieTYT> i think that means if f and g have the same result for the same arguments you could have used g when you used f and vice versa
14:42:35 <jrmole> tieTYT, it means more than that
14:42:44 <Cale> Or it would be  io_t main;
14:42:46 <jrmole> it also means that f always has the same value for a given argument
14:42:52 <Cale> i.e. not a function type
14:42:53 <araujo> jrmole: ?
14:43:05 <tieTYT> ok
14:43:19 <jrmole> haskell functions act like functions from math; in math you can't have f(3) = 7 one day and f(3) = 9 the next
14:43:24 <jrmole> but in C this kind of nonsense is common ;)
14:43:24 <araujo> tieTYT: that's just the way we do type signature
14:43:52 <Cale> It's similar to  name :: String;  name = "tieTYT"
14:44:13 <tieTYT> so it's just explicitly saying the type of name before you assign it?
14:44:17 <Cale> yes
14:44:20 <araujo> yes
14:44:23 <tieTYT> why was that necessary in your example?
14:44:24 <araujo> you get it
14:44:24 <Cale> main :: IO ()
14:44:37 <jrmole> it's almost never necessary in haskell, but it can help you think about your code
14:44:48 <Cale> It gives you a better sense of what you're actually defining
14:44:49 <jrmole> i like to think of type signatures as comments that are automatically validated by the compiler ;)
14:45:01 <araujo> tieTYT: it isn't mandatory , since haskell got type inference.
14:45:09 <araujo> tieTYT: but it is good practice.
14:45:18 <jrmole> occasionally it needs a few of them to figure out what the types of everything are, but only in specialized cases
14:45:35 <araujo> It helps you to think about the function in terms of their interfaces , instead of implementations.
14:45:53 <araujo> Now, who needs OO? ;_)
14:45:57 <jrmole> tieTYT, are you using an interactive environment like GHC or Hugs?
14:46:05 <tieTYT> i'm using ghc(i)
14:46:10 <jrmole> err, 's what i meant, sorry
14:46:18 <jrmole> yeah, you can use the :t command to ask it the type of an expression
14:46:40 <tieTYT> i think i just need the do command explained better to me
14:47:10 <jrmole> do you understand the monadic operations return and (>>=) ?
14:47:11 <tieTYT> or for someone to say, "yeah the do command isn't explained for crap at first in the YAHT.  Read on and you'll get it next time it brings it up (ie: chapter 5)"
14:47:13 <araujo> tieTYT: 'do' is just a syntatic sugar to the monadic operators. To give you a feel of imperative programming.
14:47:28 <araujo> Now, who is talking about imperative programming free of side-effects? ;-)
14:47:35 <tieTYT> jrmole: no, the YAHT says it'll talk about monads more in chapter 5
14:47:38 <jrmole> araujo: me, to be difficult
14:47:54 <tieTYT> it hasn't used >>= yet
14:48:05 <araujo> eh .. that's what the do helps you doing.
14:48:06 <jrmole> tieTYT, working out type errors in do notation is almost impossible unless you understand the underlying plumbing
14:48:11 <lament> yeah, starting teaching haskell with 'do' is a weird choice
14:48:22 <araujo> :-)
14:48:26 <tieTYT> jrmole: that explains my confusion
14:49:02 <araujo> jrmole: 'do' is a way of helping you to do imperative programming in a purely functional language.
14:49:06 <Cale> tieTYT: Yeah, I think my intro should give you a good sense of what's going on.
14:49:11 <jrmole> yeah, i know that
14:49:22 <araujo> Good :-)
14:49:23 <Cale> You're really building these values which represent actions.
14:49:35 <Cale> The only action which ever really runs in a compiled program is main
14:49:45 <ivant> how do I compile my program with -prof turned on when it uses some module (System.FilePath in my case) which I compiled from sources?
14:49:48 <Cale> but it's built up out of others :)
14:49:55 <tieTYT> Cale: i don't understand anything on this line though (>>) :: IO a -> IO b -> IO b
14:50:05 <tieTYT> except that :: is defining a type
14:50:13 <jrmole> >> is a binary operator
14:50:17 <nuffer> the () make it an infix operator
14:50:32 <jrmole> it takes two arguments, one is an IO action returning a value of type a, the other of type b
14:50:59 <tieTYT> what do the -> mean?
14:51:06 <Cale> oh
14:51:08 <nuffer> read it as "yields"
14:51:10 <nuffer> or at least I do
14:51:18 <jrmole> fact :: Int -> Int
14:51:24 <jrmole> fact takes an integer, and returns another integer
14:51:26 <Cale> A function of type a -> b takes a value of type a and returns a value of type b.
14:51:37 <tieTYT> so does it return the right or the left?
14:51:43 <tieTYT> ok
14:51:45 <jrmole> the right
14:51:48 <nuffer> it takes stuff on the left, and gives back the rest
14:51:56 <araujo> tieTYT: i would recommend you to read first about non-monadic types.
14:51:57 <tieTYT> so this is saying it takes IO a and IO b and returns IO b?
14:52:02 <jrmole> x >> y = do { x; y; }
14:52:02 <Cale> yes
14:52:05 <nuffer> you can give it one or more arguments
14:52:10 <ivant> @seen ndm
14:52:10 <lambdabot> I saw ndm leaving #haskell 3 hours, 55 minutes and 29 seconds ago, and .
14:52:16 <ivant> @seen dons
14:52:16 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 7 hours, 20 minutes and 38 seconds ago.
14:52:26 <jrmole> tieTYT, it actually returns a compound action, which does the IO from the first action, throws away the result, then does the IO from the second action and returns the result
14:52:27 <tieTYT> araujo: ok well that is chapter 4, the one i just got to
14:52:34 <Cale> jrmole: You could also write that  x >> y = do x; y
14:52:53 <araujo> tieTYT: And .... you don't know about type signature yet?
14:52:54 <tieTYT> maybe i should just ignore the fact that i had no idea what i was doing with the do command and start reading chapter 4 anyway
14:52:55 <jrmole> Cale: okay, i always code with layout so i don't know the other syntax
14:53:11 <araujo> what are you reading tieTYT ?
14:53:18 <tieTYT> araujo: no.  Chapter 3 explained map, filter, foldr/l
14:53:19 <jrmole> IMHO it's much better to learn the "pure" subset of haskell before attempting any IO
14:53:21 <tieTYT> YAHT
14:53:22 <Cale> jrmole: the braces and semicolons are separately optional :)
14:53:46 <Cale> tieTYT: You might just skip that chapter and read about types
14:53:56 <tieTYT> i know putStrLn, how to define functions in "pieces" ie: f 1 = 2, f _ = 3
14:53:57 <araujo> tieTYT: ok ...
14:54:05 <araujo> yes,
14:54:13 <tieTYT> i barely know anything
14:54:20 <tieTYT> ok i'll just give chapter 4 a shot
14:54:31 <araujo> i don't know if it is good to jump at monads at once
14:54:57 <araujo> they aren't _that_ complex really .... but it is better to understand a few things before
14:55:39 <jrmole> tieTYT, can you do all of these: http://www.cs.caltech.edu/courses/cs11/material/haskell/lab1/lab1.html
14:55:43 <lambdabot> Title: CS 11: Haskell track: assignment 1
14:55:52 <tieTYT> araujo: heh wasn't my choice.  right after they teach recursion they teach "interactivity".  And those examples are full of do's
14:56:06 <araujo> get it
14:56:16 <araujo> i know, most of the docs do that
14:56:59 <jrmole> i think maybe tutorial writers are too eager to show that haskell can actually do IO, and the cool but confusing ways in which it's done
14:56:59 <araujo> Really, Haskell is the only language where a Hello World printing to stdout isn't the best way to start teaching it :-)
14:57:14 <jrmole> araujo, i think factorial is the canonical functional hello world ;)
14:57:21 <jrmole> maybe qsort if you want something really impressive
14:57:28 <araujo> Yes, for functional programming pretty much.
14:57:34 <jrmole> i had a lot of fun playing with pure functions in ghci before i ever wanted to do IO
14:57:40 <jrmole> and imho that's a better way to learn the language
14:57:43 <qwr> jrmole: most functional languages are not pure
14:57:45 <Cale> main = putStrLn "Hello World" -- it's simple enough, but actually explaining how IO is done is not a decent way to start
14:57:52 <araujo> Even in non-pure functional languages. Factorial is kind of a 'de facto'
14:58:01 <tieTYT> jrmole: no i can't do first_n
14:58:12 <tieTYT> jrmole: well maybe i could...
14:58:13 <araujo> Cale: that's it :-)
14:58:30 <jrmole> ghci already gives you a working REPL with Read and Show for most builtin types, so you can do a lot of exercises that way
14:58:35 <araujo> I have met people coming to me with that kind of Hello World for explainig it.
14:58:38 <tieTYT> i don't know the difference between an Int and Integer yet
14:58:55 <araujo> they might think it is as straightforward as in other languages.
14:59:05 <Cale> tieTYT: Int is a machine integer like you get in most languages
14:59:24 <Cale> Integer is an unbounded integer which
14:59:30 <tieTYT> jrmole: i can do most of these i think but they're probably take me a while
14:59:40 <Cale> which can be basically anything that fits in memory
14:59:52 <Cale> > 2^5000
14:59:53 <lambdabot>  1412467032139426036835209667016147333668896175184541116813688085857118169842...
14:59:58 <qwr> tieTYT: i actually would suggest learning how monads work about as next thing after getting working factorial in haskell ;)
14:59:58 <Cale> > 2^5000 :: Int
14:59:59 <lambdabot>  0
15:00:21 <Cale> qwr: really?
15:00:24 <tieTYT> qwr: well apparently the author of YAHT agrees with you cause that's what he's doing
15:00:33 <Cale> tieTYT: well, he's explaining IO
15:00:43 <ivant> @hoogle [(a,b)->c] -> (a,b) -> c
15:00:44 <Cale> You don't really have to understand monads to understand IO
15:00:45 <lambdabot> No matches, try a more general search
15:00:50 <Cale> (but it helps, since IO is a monad)
15:00:58 <tieTYT> except he's saying, "These are monads, we won't go into them in depth here.  Now, do an exercise where you have to use monads"
15:01:02 <jrmole> it sounds like he's not explaining it, just giving you some canned solutions
15:01:09 <Cale> tieTYT: no, just IO
15:01:49 <Cale> But yeah, I agree he could include more preparation there
15:01:51 <tieTYT> well regardless, i have no understanding of why i can't use map (myFunction) list in my main = do
15:02:00 <tieTYT> but anyway
15:02:03 <tieTYT> i'll just continue reading
15:02:06 <tieTYT> so i can understand types
15:02:07 <Cale> tieTYT: What's myFunction's type?
15:02:21 <qwr> Cale: almost really. i did so ;)
15:02:32 <jrmole> tieTYT, do you understand what is meant by an "IO action"?
15:02:41 <tieTYT> i didn't explictly define it.  its a putStrLn
15:02:43 <Cale> tieTYT: : regardless, the reason why you can't use that as a line is that it's going to return a list, and not an action
15:02:51 <tieTYT> jrmole: generically i understand that.  Not in a haskell contect
15:02:54 <tieTYT> context
15:03:05 <Cale> tieTYT: However, if it returns a list of actions, there's sequence
15:03:07 <jrmole> in a haskell context it means a value of type IO a for some a
15:03:08 <tieTYT> Cale: myFunction will return a list?
15:03:09 <Cale> @type sequence
15:03:11 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
15:03:21 <Cale> (map myFunction list) will return a list
15:03:30 <Cale> possibly a list of actions
15:03:33 <tieTYT> ok i understand that
15:03:43 <tieTYT> oh i gotcha
15:03:44 <tieTYT> shoot
15:03:53 <tieTYT> what i wanted to do was take an "action" on each element of the list
15:04:02 <tieTYT> i see what i did wrong
15:04:04 <Cale> sequence will connect the actions together one after the other
15:04:29 <jrmole> tieTYT, your map gives you a list of the actions, but doesn't actually sequence them together into a single action
15:04:31 <Cale> or you can use  mapM  which is defined as  mapM f xs = sequence (map f xs)
15:05:05 <tieTYT> hrm ok
15:05:08 <Cale> mapM is an important part of how to do loops in Haskell, but it's just an ordinary function :)
15:05:10 <jrmole> or better, mapM_ which throws away the results
15:05:14 <jrmole> because they're all () anyway
15:05:24 <jrmole> this way you don't construct a big list [(), (), (), ... ] ;)
15:05:27 <Cale> Yeah, mapM_ will save you a little memory and CPU time
15:05:45 <jrmole> if by a little memory you mean O(1) instead of O(n) space, then yes ;)
15:05:57 <tieTYT> ok thanks for the help guys
15:06:04 <tieTYT> i'll come back if i get stuck on chapter 4 (types)
15:06:12 <jrmole> no problem
15:06:17 <Cale> jrmole: well, there's still the matter of whether the list is actually built
15:07:20 <jrmole> true
15:07:39 <jrmole> mm, reasoning about laziness is difficult
15:08:05 <Cale> and the original list you're mapping over consumes O(n) space anyhow
15:08:15 <jrmole> true
15:08:23 <svref> I can't find the syntax error in this:
15:08:23 <svref> data Foo = Foo { x::Int, y::Int }
15:08:23 <svref> fun foo = let {xx=x} foo in xx+5
15:08:28 <Cale> hmm, it looks like it does save a bit of memory
15:08:30 <jrmole> well i remember some example where mapM_ over map caused this improvement
15:08:33 <Cale> or at least allocations
15:08:47 <Cale> Probably the gc is collecting them all immediately though
15:09:07 <tennin> I liked the way the "Gentle Introduction" introduced IO (before introducing monads generally)
15:09:10 <Cale> fun foo = let {xx=x} = foo in xx+5
15:09:13 <Cale> er
15:09:15 <Cale> fun foo = let {xx=x} = foo in x+5
15:09:35 <Cale> tennin: yeah, YAHT does too
15:09:49 <Cale> svref: er, oops
15:09:53 <Cale> data Foo = Foo { x::Int, y::Int }
15:10:02 <Cale> fun foo = let {x=xx} = foo in xx+5
15:10:12 <araujo> brb
15:10:15 <Cale> the field name is always on the left
15:10:41 <Pupeno> is it possible with some haskell mode to run ghci embedded in Emacs and with a keystroke load the current file ?
15:11:03 <svref> Cale: I'm typing that in verbatim and still getting the error.  Could it be my version of HUGS is too old?
15:11:49 <svref> Cale: Hugs version "November 2003".
15:12:42 <svref> ghc 6.2.2
15:13:24 <sjanssen> "let {x=xx} = foo" looks wrong to me
15:13:47 <jrmole> it's a record pattern
15:14:12 <sjanssen> ah, svref you need to pattern match against the constructor
15:14:19 <Pupeno> xerox: ping?
15:14:22 <xerox> Pong.
15:14:26 <psi`> Pupeno: like C-c C-l?
15:14:46 <sjanssen> fun foo = let Foo {x = xx} = foo in xx + 5
15:14:56 <Pupeno> psi`: it say it is undefined... maybe I am missing to properly load haskell-mode
15:15:08 <svref> aha!
15:15:27 <Pupeno> it is installed, it should load.
15:15:40 <svref> Thanks Sj, Cale.  :D
15:15:55 <psi`> I have the following in my .emacs: (add-hook 'haskell-mode-hook 'turn-on-haskell-hugs)
15:16:01 <psi`> perhaps change hugs to ghci?
15:16:18 <psi`> or try M-x turn-on-haskell-ghci
15:17:01 <Pupeno> psi`: now it worked. Thanks. Any more magic that I might be missing ?
15:18:17 <psi`> not sure :)
15:18:40 <Pupeno> well, thank you!
15:19:06 <psi`> I've been meaning to see if it parses errors, and then allows you to jump to them
15:19:22 <Cale> svref: er, yeah, sorry about that :)
15:19:26 <Cale> svref: hehe
15:20:56 <psi`> apparently not
15:21:52 <Pupeno> xerox: well, nevermind. Thanks for responding.
15:22:04 <xerox> Allright.
16:10:29 <jeroenp> Hey there
16:15:37 <ndm> hi jeroenp
16:18:06 <jeroenp> I'm trying to get some haskell-skills, it's not as easy as I thought it would be
16:19:43 <ndm> jeroenp: having difficulty with anything in particular?
16:20:54 <jeroenp> I'm trying to do some easy numerical work, like plotting a mandelbrot. It's fairly slow, I think it can be faster, but I don't really know how
16:22:22 <ndm> are you using hugs or ghc?
16:23:29 <jeroenp> ghc
16:23:38 <jeroenp> With the wxHaskell package
16:25:54 <ndm> is it slow outputtnig to the console?
16:29:47 <jeroenp> Yes, but I don't know whether that's because of the scrolling it has to do or because of the computations.
16:29:59 <ndm> try outputting it to a file
16:30:09 <ndm> use writeFile or something
16:30:38 <jeroenp> The graphical thing is just putting a list of Color's to the screen, I suppose that's pretty fast.
16:31:21 <ndm> still, its best to test the speed of the computation - gui stuff can be slow
16:31:37 <ndm> and have you compiled with ghc -O ?
16:31:42 <jeroenp> Yes
16:32:26 <jeroenp> I think the problem lies in the lazyness of until, which I use.
16:32:27 <ndm> you can try profilign
16:33:09 <jrmole> jeroenp, you can redirect the console output to /dev/null and time it
16:33:09 <jeroenp> How do I do that? My apologies, I'm new to all of this.
16:33:14 <jrmole> are you using unix?
16:33:27 <jeroenp> Yes
16:33:57 <jeroenp> By hand I count two seconds for 400x400 pixels of mandelbrot-fun
16:34:01 <jrmole> ./whatever > /dev/null
16:34:17 <jeroenp> Is there a way to time that?
16:34:48 <ndm> time ./whatever > /dev/null
16:34:54 <jrmole> or /usr/bin/time for more info
16:36:15 <jeroenp> Thanks
16:36:41 <jeroenp> Do you think it will be faster when I exchange Complex Float for (Float, Float) ?
16:39:15 <zarvok> so if I built the latest ghc without mtl, is there some way to add it later?  I can only find the source that is included within the older ghc versions
16:39:38 <dons> the latest ghc still comes with mtl doesn't it?
16:39:55 <dons> libraries/{monads,mtl}
16:40:02 <zarvok> not the one in the repository
16:40:03 <Igloo> Not in core
16:40:09 <dons> ah
16:40:11 <jrmole> jeroenp, not likely at high -O
16:40:13 * dons updates
16:40:14 <Igloo> You need the extralibs tarball for that
16:40:45 <jrmole> i think it depends on whether Complex is defined with type or newtype
16:40:49 <zarvok> Igloo: where do I get it?
16:41:13 <dons> data (RealFloat a) => Complex a
16:41:14 <dons>   = !a :+ !a
16:41:15 <zarvok> I found it
16:41:17 <zarvok> thanks
16:41:37 <Igloo> zarvok: Hmm, where did you find it?
16:41:55 <dons> so there might be a benefit, possibly, to defining data SpecComplex = !Float :++ !Float
16:42:01 <dons> (or Double...)
16:42:08 <zarvok> hmm, actually, I lied, the google results made it look like I would find it on some page, but it was out of date
16:42:50 <jeroenp> But it probably wont change much?
16:43:14 <zarvok> any thoughts?  Even if I want to rebuild ghc, I don't know where to get the appropriate versions
16:44:05 <Igloo> zarvok: You could grab it with darcs get http://darcs.haskell.org/packages/mtl/
16:44:07 <lambdabot> Title: Index of /packages/mtl
16:44:31 <zarvok> I did that, so if I throw that into my ghc source it should work happily?
16:44:40 <zarvok> when I rebuild ghc, I mean
16:45:02 <Igloo> If you still have the GHC tree you can probably just go into libraries/mtl and do make
16:45:21 <Igloo> Otherwise, it should probably also be possible to build it as a cabal package
16:45:34 <zarvok> ah, yeah, you're right
16:45:36 <zarvok> I guess I was being silly
16:46:11 <zarvok> gar, that fails too, might be a faulty makefile though, let me see
16:47:19 <Igloo> Oh, you'll need to autoreconf and ./configure
16:47:32 <Igloo> Probably simpler to treat it as a cabal package, assuming that works
16:48:09 <jeroenp> jrmole: Do you think that one can make a (simple) raytracer running at almost decent (java-like) speed, in Haskell?
16:48:22 <jrmole> not sure
16:48:30 <jrmole> generally, the more speed you need in Haskell, the less simple things become
16:48:36 <dons> jeroenp: I'd expect much better than Java
16:48:43 <dons> ?shootout
16:48:44 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
16:49:06 <dons> note that there's a dozen or so example ray tracers on the haskell.org libraries page
16:49:50 <dons> here, http://haskell.org/haskellwiki/Libraries_and_tools/Graphics#Ray_Tracing
16:49:52 <lambdabot> Title: Libraries and tools/Graphics - HaskellWiki
16:51:00 <jeroenp> That list reminds me of a rather silly question; can you link to d-functions with the haskell (ghc) ffi?
16:51:43 <dons> are they functions in C?
16:52:04 <dons> the language you want to bind to is the important issue
16:52:22 <ndm> wow! thats a lot of ray tracers!
16:52:54 <dons> jeroenp: oh, you mean D, the language?
16:52:59 <dons> i don't know of any ffi binding to D.
16:53:26 <jeroenp> Ah well
16:53:27 <dons> probably on the easier scale of things, if they already have their own C ffi
16:55:19 <jrmole> if D functions follow the c calling convention, it should be almost trivial
16:55:51 <jrmole> you might need to deal with name manglers somehow, most easily with a C stub
16:56:19 <jrmole> iirc D is pretty low-level
16:57:18 <jrmole> debugging haskell-ffi-jni-java code was fun... when i ran my binary i got a ghc runtime crash or a hotspot vm crash with equal probability
16:57:47 <dons> heh
16:58:44 <jeroenp> How did you keep your sanity?
16:59:33 <dmwit> With a bucket, no doubt.
17:01:35 <LordBrain> the shootout page isnt very clear... why does http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=ghc   show "no program" for haskell but then when i click the "fasta" link to the left of the "no program" i get a haskell program?
17:01:37 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ...
17:01:53 <jeroenp> dons, do you think that D will become popular within the near future?
17:02:21 <LordBrain> i havent looked at D.. but i dont really see much reason for it.
17:02:34 <dmwit> jeroenp: Do you think that Haskell will become popular within the near future? =P
17:02:42 <ndm> D looks better than C
17:02:53 <ndm> but thats not a major endorsement
17:02:56 <jeroenp> dmwit, I do hope so
17:03:08 <ndm> they have thrown away CPP, and replaced it with an alternative, more restricted
17:03:19 <ndm> which might possibly be of use to Haskell - looking at what they have done
17:03:24 <LordBrain> how different from c is d?
17:03:27 <jrmole> D's features are a hodgepodge of C / C++ / C# / Java... there's a couple nice things but nothing to compel learning a new language
17:03:31 <jcreigh> Isn't D garbage collected?
17:03:34 * jcreigh checks
17:03:44 <jeroenp> I think it is
17:03:57 <jcreigh> yup, website says it is.
17:04:04 <ndm> it is
17:04:26 <jeroenp> I especially like the way they do templates, compared to c++ and java
17:04:50 <LordBrain> hmm yeah c++ templates are pretty hairy
17:04:53 <jrmole> i think haskell has a better chance of catching on than D does, because haskell is mind-blowingly better whereas D is just another incremental improvement
17:05:00 <jrmole> but that could work against haskell too
17:05:20 <jrmole> bbl
17:05:38 <dmwit> According to one of SPJ's presentations, Haskell's motto is "avoid success at all costs"...
17:05:41 <LordBrain> if microsoft started pushing D it would catch on
17:06:17 <SamB> dmwit: I think we are giving up on that one soon
17:06:24 <dmwit> Excellent! =)
17:06:42 <dons> yeah, its now something like 'trying to avoid sucess at all costs and failing"..
17:06:52 <LordBrain> lol
17:07:01 <SamB> it is hard to be successful at avoiding success...
17:07:20 <dons> ?users
17:07:23 <lambdabot> Maximum users seen in #haskell: 235, currently: 198 (84.3%), active: 26 (11.1%)
17:08:17 <LordBrain> I think, if C# were a protect of Digital Mars, it would be about where D is.
17:09:21 <jcreigh> Oh, interesting: http://www.digitalmars.com/d/lazy-evaluation.html
17:09:25 <lambdabot> Title: D Programming Language - LazyEvaluationOfFunctionArguments
17:09:33 <petekaz> how do I get an Integer from an Int?
17:09:46 <SamB> @type toInteger
17:09:48 <lambdabot> forall a. (Integral a) => a -> Integer
17:09:53 <petekaz> htanks
17:10:50 <SamB> now I think it is more like "avoid being overly successfull at all costs"
17:12:18 <petekaz> is there anything wrong with this?  let maxpage = ceiling $ length pastes / pagelen  (pagelen is an Int).
17:12:37 <dons> you won't be able to / the two Ints
17:12:42 <Cale> `div`
17:12:48 <petekaz> I don't quite get numbers yet.
17:12:57 <SamB> > 1 / 2
17:12:58 <lambdabot>  0.5
17:13:10 <jeroenp> @type 1
17:13:11 <lambdabot> forall t. (Num t) => t
17:13:16 <Cale> SamB's example works because Double is inferred.
17:13:17 <dons> > length [1..10] / (7::Int)
17:13:18 <lambdabot>  add an instance declaration for (Fractional Int)
17:13:18 <lambdabot>   In the definition of `...
17:13:19 <petekaz> I just want to round up a division.
17:13:31 <dons> > generiLength [1..10] / fromIntegral (7::Int)
17:13:32 <lambdabot>  Not in scope: `generiLength'
17:13:36 <petekaz> round up no matter what, not just at .5
17:13:40 <dons> > genericLength [1..10] / fromIntegral (7::Int)
17:13:41 <lambdabot>  1.4285714285714286
17:13:44 <petekaz> how do I do that?
17:13:55 <dons> > ceiling $ genericLength [1..10] / fromIntegral (7::Int)
17:13:56 <lambdabot>  2
17:14:04 <petekaz> thanks!
17:14:48 <LordBrain> Why should haskell "avoid success" at all?
17:15:06 <SamB> LordBrain: well... do *you* want to be Java?
17:15:09 <musasabi> Has anyone got example code using Cabal test-hooks with a library?
17:15:19 <SamB> or C?
17:15:19 <dmwit> So it can remain elite, and we don't have to worry about Perl syndrome... ?
17:15:37 <jcreigh> dmwit: What, exactly, is the Perl syndrome?
17:15:41 <musasabi> Mainly - how does one link examples when the library is not yet installed.
17:15:43 <Cale> Popular languages stop changing
17:16:03 <LordBrain> thanks Cale, that answer makes sense
17:16:12 <dmwit> I don't know, but it seems to get a lot of flak for attracting inexperienced programmers who make sub-par code...
17:16:13 <dons> musasabi: no, I found it too tedious to bother with test hooks in fps
17:16:17 <Cale> Because everyone yells and screams when you try to make some small compatibility breaking change
17:16:19 <dons> though i'd be interested if you hack it up
17:16:23 <jeroenp> Is there a standard function to go from a to b in n steps, or should I just do [a+(b-a) * i `div` n | i <- [1..n]] ?
17:16:40 <LordBrain> yeah
17:16:55 <Cale> [a, a + (b-a) `div` n .. b]
17:18:09 <jcreigh> Cale: That's a good point. Once languages hit a certain level of popularity, there's really no hope for any real change. Imagine trying to add closures to Java at this point...
17:18:20 <jeroenp> Cale: enumfromTo a $ a + (b-a) `div` n $ b ?
17:18:34 <dons> sames as the .. syntax
17:18:38 <jeroenp> fromToThen*
17:18:48 <jeroenp> Okey
17:19:02 <LordBrain> but say haskell98.. that's not changing much anyway.. maybe addendums get added... and the same will presumeably be true of haskell06 or whatever the next standard will be called.
17:19:25 <dons> yeah. yay for unstable branches
17:21:49 <LordBrain> hmm perl6 seems like its going to change a lot from perl5 inspite of it's popularity heh.
17:22:20 <jrmole> yeah, because the perl people finally got sick of having twelve million special cases in everything to keep some weird compatibility or make some obscure task take one fewer line of code
17:22:31 <ndm> yes, and VB.NET is a completely new language, not a change to VB
17:22:48 <jrmole> for that matter haskell as we know it is significantly different from haskell98
17:22:59 <ndm> jrmole: not the haskell i use
17:23:10 <jrmole> but the haskell that many important libraries use
17:23:39 <ndm> not the libraries i use :)
17:23:39 <jeroenp> Probably a silly question, but why do all those raytracers in Haskell use type vector and add, mul, etc functions instead of making newtype Vector and instance Vector an instance of Num??
17:23:56 <dons> jeroenp: laziness?
17:24:01 <dons> (in the bad sense ;)
17:24:12 <LordBrain> lol
17:24:15 <jeroenp> That's just sad, they're missing out on a lot of fun
17:24:18 <jrmole> hierarchical module names are probably the most-used extension, but that's somewhat trivial
17:24:39 <jrmole> MPTC/FD are used in a bunch of libraries, including, say, Control.Monad.State
17:24:54 <LordBrain> what's the name for the extension that allows me to embed type signatures?
17:25:03 <jrmole> embed how?
17:25:26 <ndm> forall 's you mean?
17:25:38 <dons> ?where haskellexts
17:25:39 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/HaskellExtensions
17:25:46 <jrmole> rank-2 types?
17:26:13 <dmwit> Oy, I just discovered this little gem:
17:26:14 <dons> or do you just mean pattern signatures?
17:26:21 <dmwit> @pl isAdjacent (r1, c1) (r2, c2) = latticeLength (r1, c1) (r2, c2) == 1
17:26:24 <lambdabot> isAdjacent = uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip 1 . ((flip . ((flip . ((==) .)) .)) .) . flip flip (,) . (((.) . (.) . latticeLength) .) . (,))
17:26:36 <ndm> i was more guessing at: f :: forall a . a -> a where b :: a -> a, being the same  type a
17:26:38 <dons> good lambdabot
17:26:42 <jrmole> oh yeah, FFI is an extension... that's more or less critical for use of haskell in industry, etc.
17:27:08 <ndm> FFI and heirarchcial modules are haskell 98 adendums - you can treat them as haskell 98
17:27:25 <dons> since all systems support them
17:27:38 <jrmole> ndm, that's just the embedding of the old interpretation of polymorphic types into the new higher-rank system with explicit forall, yes?
17:28:47 <ndm> jrmole: there are some things you can't write type sigs for in haskell 98, but do type check
17:29:01 <jrmole> wow, do you have an example?
17:29:05 <ndm> functions inside where's, taht unify to outside
17:29:13 <ndm> i can make one up, one sec...
17:31:03 <LordBrain> yes i think what i meant was embedding the type signature in a pattern
17:31:42 <ndm> @where paste
17:31:43 <lambdabot> http://paste.lisp.org/new/haskell
17:32:04 <lisppaste2> ndm pasted "No explict types allowed" at http://paste.lisp.org/display/24912
17:32:24 <ndm> jrmole: that program type checks, but if you uncomment the sig for g, it doesnt
17:32:26 <LordBrain> like
17:32:33 <LordBrain> (n::Int) <- getInt
17:34:20 <jrmole> hmm, tricky
17:34:33 <ndm> jrmole: not tricky, impossible without forall
17:34:42 <ndm> unless you restructure the code
17:34:51 <jrmole> i mean, it's tricky that the language allows such things
17:35:02 <ndm> yeah, forall solves this
17:35:43 <ndm> even if you stick to rank1
17:37:54 <jrmole> is there a difference between a -> a and forall a. a -> a
17:38:25 <dons> nice example ndm
17:38:43 <dons> jrmole: at the top level, no
17:38:46 <ndm> jrmole: yes, in one the binding applies for children as well
17:39:39 <ndm> oh, i'm wrong
17:39:52 <ndm> is it possible to type that example, even when adding forall's ?
17:41:31 <jrmole> so we try to unify the type of y (g's 'a' typevar) with the type of x (f's 'a' typevar), which is free in g, and this is the source of the error?
17:42:15 <ndm> yes
17:42:26 <ndm> if you were to pass the x to g as well, you don't get an error
17:42:38 <jrmole> when you add an explicit forall to the type signature for f, the error goes away
17:43:17 <dons> note that it compiles with -fglasgow-exts too
17:43:27 <dons> oh, hang on... my mistake
17:43:46 <dons> f :: forall a. a -> a
17:43:51 <dons> works
17:44:10 <jrmole> yeah
17:44:11 <ndm> forall at the top level, and not at the inner level?
17:44:17 <dons> as does
17:44:18 <dons> f :: a -> a
17:44:18 <dons> f (x :: a) = g x
17:44:22 <dons> (top level)
17:44:29 <dons> icky!
17:44:52 <jrmole> so we have a case where a -> a and forall a. a -> a differ, and the quantifier isn't even in the signature that we previously couldn't write!
17:45:19 <ndm> in hugs, it still doesn't work with an explicit forall
17:45:23 <ndm> only in ghc
17:45:31 <jrmole> so what does that forall tell the typechecker?
17:46:06 <ndm> in hugs, nothing
17:46:15 <jrmole> it also doesn't work when you remove the sig on f entirely, which i guess is because haskell doesn't have higher-rank inference
17:46:33 <ndm> in ghc "i am introducing a new free variable, in this scope this is the a to refer to"
17:46:56 <ndm> jrmole: no type sigs at all works fine, its first order typing, just beyond haskell 98
17:47:12 <ndm> rank-1 i should say, rather than first order
17:47:24 <jrmole> it doesn't work when you write the sig for g and not f, though
17:47:46 <ndm> yeah
17:47:46 <jrmole> ndm: so it's basically a typevar scope declarator?
17:47:52 <dons> yep
17:47:56 <ndm> yep
17:48:15 <dons> and similar with : f (x :: a) = g x, the lexically scoped tyvar
17:48:15 <ndm> in GHC, not in hugs though, it seems
17:48:33 <jrmole> and the problem comes back when we write g :: b -> b, so it really is a variable scope thing
17:48:36 * jrmole thinks out loud
17:48:59 <dons> definitely, you need to tell the compiler that the 'a's are all the same
17:49:31 <jrmole> i see
17:49:55 <dons> you should stick that code on a wiki page, ndm
17:50:00 <jrmole> so in theory you could have some intermediate extension which supports this scoping use of forall, but not higher-rank types
17:50:11 <ndm> dons, underwhat?
17:50:19 <ndm> jrmole: yes
17:50:21 <dons> or lexically-scoped tyvars
17:50:34 <dons> with pattern signatures
17:50:37 <dons> :)
17:50:49 <dons> ndm, oh hmm. something instructive?
17:51:03 <ndm> @wiki Untypeable Haskell 98
17:51:03 <lambdabot> http://www.haskell.org/haskellwiki/Untypeable Haskell 98
17:51:15 <ndm> your @wiki is broken, should be underscores
17:51:24 <dons> its your @wiki too!
17:51:27 <ndm> if i could compile lambdabot i'd send you a patch :)
17:51:32 <dons> bah
17:52:09 <ndm> i can send you a patch, but it would be 100% untested...
17:52:45 <dons> it might be possible to test just the plugin (and its deps) in ghci, without compiling everything
17:52:52 <dmwit> The best kind of patch is untested and has an eye underneath.
17:52:53 <dons> not sure if that'd pul in sometihng that breaks though
17:53:49 <jrmole> what happens when the forall is not at top level, i.e. foo :: (forall a. a -> b) -> a -> b
17:54:10 <jrmole> here the second 'a' is distinct from the quantified one, and both are distinct from any occurance of 'a' in a where signature, right?
17:54:59 <ndm> you can just rename that to (a -> b) -> c -> b
17:55:25 <jrmole> right
17:56:19 <jrmole> but not all quantifiers can be moved to top level
17:58:22 <ndm> true
17:58:36 <ndm> but i don;t understand rank-2 types :)
17:59:20 <jrmole> but in first-order logic we can write any formula in prenex normal form
18:00:45 <Cale> ndm: they're basically types in which certain parameters are forced to be polymorphic
18:01:37 <Pseudonym> Woohoo, I didn't know this was online: http://www.emis.ams.org/journals/TAC/reprints/articles/3/tr3.pdf
18:07:50 <nothingmuch> @seen shapr?
18:07:51 <lambdabot> I haven't seen shapr?.
18:07:53 <nothingmuch> @seen shapr
18:07:53 <lambdabot> I saw shapr leaving #haskell and #ScannedInAvian 11 days, 6 hours, 24 minutes and 22 seconds ago, and .
18:07:58 <nothingmuch> *sniff*
18:08:45 <Pseudonym> He's not dead.  Blog entry dated today.
18:12:22 <LordBrain> hmm anyone know of an ncurses pdf viewer?
18:12:44 <LordBrain> i really prefer reading in the terminal.. however strange that may be
18:13:02 <dons> hmm. no.
18:13:07 <LordBrain> i always prefer white on black... when everyone else seems to be the opposite
18:13:11 <dons> convert to text?
18:13:24 <LordBrain> yeah i could do that
18:13:40 <dons> i like ncurses, but black on white seems nicer ;)
18:13:42 <LordBrain> eventually i'll runinto mathematical symbols tho
18:13:56 <LordBrain> why is that?
18:14:10 <dons> looks more like paper?
18:14:10 <LordBrain> why are white-on-blackers rarer than black-on-whiters?
18:14:22 <LordBrain> paper is the nicest
18:14:25 <dons> we grow up reading black on white
18:14:29 <LordBrain> but, it doesnt seem like paper to me
18:14:30 <johnnowak> LordBrain: there are pdf->html converters you might use
18:14:55 <Pseudonym> I find white on black to be less eye-straining.
18:14:56 <LordBrain> because it lights up... and i just feel like its too much light
18:15:12 * johnnowak prefers light grey on dark grey for LordBrain's reasons
18:15:14 <LordBrain> yeah i'm with Pseudonym ... i'm not sure if its true, but thats how i feel.
18:15:17 <Pseudonym> white on black : light transmission :: black on white : light reflection
18:15:29 <Pseudonym> Since most computer displays are transmissive...
18:15:37 <Pseudonym> And most pieces of paper are reflective...
18:15:59 <LordBrain> yeah
18:17:28 <svref> in HUGS, is it possible to get the value of the last top-level expression somehow?
18:18:00 <dons> don't think so. in ghci you have 'it' though
18:18:11 <dons> Prelude> print 1
18:18:12 <dons> 1
18:18:12 <dons> Prelude> it
18:18:12 <dons> ()
18:20:24 <svref> well, it does work really in ghci.  :)
18:27:03 <ndm> svref: $$
18:27:39 <ndm> unless you are on WinHugs, I broke that :(
18:27:57 <dons> ?karma+ ndm hugs-foo
18:27:57 <lambdabot> ndm's karma raised to 8.
18:28:29 <ndm> ?karma- ndm breaking the feature i knew about in hugs!
18:28:30 <lambdabot> You can't change your own karma, silly.
18:29:16 <svref> > $$
18:29:17 <lambdabot>  Parse error
18:29:40 <dons> irc ain't no hugs :)
18:29:42 <ndm> lambdabot is running GHCi
18:29:47 <dons> nope :)
18:29:51 <dons> its running runplugs
18:30:03 <ndm> which is ultimately GHCi at some level?
18:30:08 <ndm> or similar to?
18:30:20 <dons> well, its not interpreted
18:30:27 <dons> its a wrapper to the dynamic linker and compiler
18:30:29 <dons> more like hmake
18:30:31 <ndm> in Hugs you can actually configure the $$ thing, to be whatever you choose
18:30:34 <dons> s/hmake/hi/
18:30:50 <ndm> (not that thats a good idea, of course)
18:33:22 <ndm> does runplugs take into account compile time in its time budget?
18:34:02 <ndm> @help plug
18:34:02 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:34:11 <ndm> @runplugs 1
18:34:12 <lambdabot> Unknown command, try @list
18:34:19 <ndm> @help
18:34:20 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:34:29 <dons> hmm, no, unless the cputime of the child ghc process affects the parent.
18:34:35 <dons> ?help run
18:34:36 <lambdabot> run <expr>
18:34:36 <lambdabot> You have Haskell, 3 seconds and no IO. Go nuts!
18:34:40 <svref> Is there a function which extracts the 3rd element of a triplet, analogous to fst?
18:34:58 <dons> svref, yes, : thd3 (_,_,c) = c
18:35:04 <ndm> svref: i have fst3, snd3 and thd3 defined in my project
18:35:08 <Cale> svens: which used to be in the Prelude
18:35:11 <Cale> er
18:35:15 <Cale> svref rather :)
18:35:18 <ndm> dons: how big a buffer can i give into lambdabot?
18:35:35 <dons> feed to it?
18:35:43 <ndm> for plugs
18:35:58 <dibblego> ?function
18:35:59 <lambdabot> Unknown command, try @list
18:36:01 <dons> what do tyou mean? what's the maximum input src size?
18:36:05 <ndm> yep
18:36:23 <dons> as big as ghc can handle?
18:36:40 <ndm> hmm, can probably cpu spin lambdabot then :)
18:36:50 <dons> though you'll likely run into irc-spec issues first ;)
18:36:56 <ndm> > let a = return () in a>>a>>a>>a>>a>>a>>a>>a>>a
18:36:57 <lambdabot>  add an instance declaration for (Show (m ()))
18:37:20 <dons> right, this do-bug
18:37:24 <ndm> yep
18:37:32 <dons> see if you can get it to work (maybe ghc's cpu time is counted, not sure)
18:37:33 <ndm> just wondering if lambdabot is remotely exploitable
18:37:46 <ndm> > let a = return () in a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a
18:37:47 <lambdabot>  add an instance declaration for (Show (m ()))
18:37:51 <ndm> > let a = return () in a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>
18:37:52 <lambdabot>  Parse error
18:37:53 <ndm> >a>>a>>a>>a>>a
18:38:14 <dons> list monad perhaps?
18:38:14 <dons> > let a = return [] in a >> a
18:38:15 <lambdabot>  add an instance declaration for (Show (m [a]))
18:38:22 <dons> > let a = return 'x' in a >> a
18:38:23 <lambdabot>  add an instance declaration for (Show (m Char))
18:38:29 <dons> > let a = return 'x' in a >> a :: [Char]
18:38:30 <lambdabot>  "x"
18:38:34 <ndm> i'm not 100 sure of the bug
18:38:45 <ndm> > fromJust $ let a = return () in a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a
18:38:46 <lambdabot>  ()
18:38:50 <dibblego> ?foldoc function
18:38:51 <ndm> > fromJust $ let a = return () in a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a
18:38:52 <lambdabot> *** "function" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
18:38:53 <lambdabot> function
18:38:53 <lambdabot>  
18:38:53 <lambdabot>     1. <mathematics> (Or "map", "mapping") If D and C are sets
18:38:53 <lambdabot>     (the domain and codomain) then a function f from D to C,
18:38:54 <lambdabot> [25 @more lines]
18:38:56 <lambdabot>  ()
18:39:05 <ndm> > fromJust $ let a = return () in a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a
18:39:06 <lambdabot>  ()
18:39:06 <dons> dibblego: didn't we talk about this yesterday?
18:39:12 <ndm> > fromJust $ let a = return () in a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a>>a
18:39:14 <lambdabot>  ()
18:39:26 <dons> you'll run into the irc line length before it gets too serious, i suspect
18:39:28 <dibblego> dons, yes, I'm trying to find where that definition comes from
18:39:29 <ndm> hard to tell if its cpu spinning with the irc delay
18:39:40 <dons> ?google foldoc
18:39:46 <Cale> @type let f x = (x,x); f1 x = f (f x); f2 x = f1 (f1 x); f3 x = f2 (f2 x) in f3
18:39:46 <lambdabot> http://foldoc.org/
18:39:47 <lambdabot> Title: FOLDOC - Computing Dictionary
18:39:47 <lambdabot> forall a. -> ((((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a,
18:39:48 <lambdabot>  a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))))), ((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a,
18:39:48 <lambdabot> a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a,
18:39:48 <ndm> its quadratic, so doesn't take much to push it over the edge
18:39:50 <lambdabot> a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))))), (((((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a,
18:39:51 <dibblego> dons, yeah but where in the foldoc
18:40:09 <lambdabot>  a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))))), ((((((a, a), (a, a)), (
18:40:09 <lambdabot> (a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))), (((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a,
18:40:09 <dons> yeah there's that
18:40:09 <lambdabot>  a), (a, a)))), ((((a, a), (a, a)), ((a, a), (a, a))), (((a, a), (a, a)), ((a, a), (a, a))))))))
18:40:10 <Cale> hehe, perhaps that should use @more
18:40:12 <ndm> although probably would run out of memory first
18:40:12 <Pseudonym> Nwo find the free theorem of that.
18:40:14 <dons> should use @more
18:40:25 * dons fixes
18:40:35 <Cale> also, look, it's a bit messed up
18:40:38 <Cale> forall a. ->
18:41:21 <dons> yeah, that's fixed in later ghc's, iirc
18:43:51 <dibblego> dons, do you where in the foldoc that definition actually exists?
18:45:39 <tieTYT2> why does this: :t (head . tail) say this: (head . tail) :: [a] -> a.  Shouldn't it say (head . tail) :: [a,b,c] -> b?
18:45:55 <tieTYT2> i kinda know why but i think this will be very educational
18:46:37 <dons> tieTYT2: nope :)
18:46:44 <dons> ?type tail
18:46:45 <lambdabot> forall a. [a] -> [a]
18:46:49 <dons> takes a list, returns a list
18:46:52 <dons> ?type head
18:46:54 <lambdabot> forall a. [a] -> a
18:47:15 <dons> [a] is not a tuple
18:47:18 <dons> ?type fst
18:47:20 <lambdabot> forall a b. (a, b) -> a
18:47:27 <dons> quite a different structure
18:47:33 <araujo> tieTYT, [a] is the list data type
18:48:20 <dons> ?type let f (_:b:_) = b in f
18:48:22 <lambdabot> forall a. [a] -> a
18:48:47 <dons> ?type let f [_,b,_] = b in f  -- lists of length 3 only
18:48:48 <lambdabot> forall a. [a] -> a
18:48:59 <tieTYT2> it's a lil misleading that the type of fst and snd explain exactly what will happen but the type of head and tail just tell me the types that will result
18:49:27 <dons> you're confusing the pattern matching for lists with the type, I think
18:49:54 <dons> all you know about the a list is that it contains elements of a single type, 'a'
18:50:13 <tieTYT2> ah
18:50:38 <dons> unlike tuples, which have a type for each component
18:50:42 <Cale> tieTYT2: Well, yeah, head *could* return any element of the list, given just the type, but it doesn't, it gives the first.
18:50:58 <dons> ?djinn [a] -> a
18:50:58 <lambdabot> -- f cannot be realized.
18:51:10 <Cale> djinn can't work with recursive types
18:51:12 <dons> ?djinn List a -> a
18:51:12 <lambdabot> -- f cannot be realized.
18:51:22 <dons> it does, but I think its missing a defn
18:51:28 <Cale> really?
18:51:32 <Cale> That'd be new then?
18:51:43 <dons> yep
18:51:49 <dons> ?djin-add data ListN a as = Nil | Cons a as
18:52:04 <dons> ?djinn-add type List a = Fix (ListN a)
18:52:14 <dons> ?djinn-add out :: List a -> ListN a (List a)
18:52:22 <dons> ?djinn-add in :: ListN a (List a) -> List a
18:52:31 <dons> ?djinn List a -> a
18:52:31 <lambdabot> -- f cannot be realized.
18:52:34 <dons> bah
18:52:39 <dons> ?djinn-env
18:52:39 <lambdabot> data () = ()
18:52:40 <lambdabot> data Either a b = Left a | Right b
18:52:40 <lambdabot> data Maybe a = Nothing | Just a
18:52:40 <lambdabot> data Bool = False | True
18:52:40 <lambdabot> data Void
18:52:41 <lambdabot> type Not x = x -> Void
18:52:43 <lambdabot> type List a = Fix (ListN a)
18:52:45 <lambdabot> data ListN a as = Nil | Cons a as
18:52:47 <lambdabot> in :: ListN a (List a) -> List a
18:52:49 <lambdabot> out :: List a -> ListN a (List a)
18:52:51 <araujo> tieTYT, Think of [a] , as a box containing values of 'a' type.
18:52:56 <dons> ?djinn List a -> Bool
18:52:57 <lambdabot> f _ = False
18:53:01 <dons> ah, there we go
18:53:09 <dons> ?djinn List a -> List a
18:53:10 <lambdabot> f a = a
18:53:16 <Pseudonym> ?free ff :: List a -> Bool
18:53:16 <lambdabot> ff x = ff ($map_List f x)
18:53:27 <araujo> tieTYT, If you got [Int] ,that's a box containing Ints , [Float] , one floats , and so on ....
18:53:29 <tieTYT2> ok
18:53:50 <araujo> tieTYT, it wouldn't make sense to have an Int box with also floats right? ...
18:54:15 <tieTYT2> right, unfortunately i say right based on my java knowledge
18:54:34 <tieTYT2> but sure :)
18:54:43 <tieTYT2> but i get it
18:54:48 <araujo> no problem , it's easy to get it.
18:54:54 <dons> you can still have lists of different types, but you need to tag the different types somehow
18:54:57 <dons> i.e. with a constructor
18:55:14 <dons> or an existential providing a uniform interface to the underlying value
18:55:18 <tieTYT2> dons: hm i see.  A constructor for the list?
18:55:25 <dons> for the elements
18:55:42 <jrmole> for any two types a and b, there's another type named Either a b
18:55:47 <dons> data E = A Int | B Char | C Bool ; x = [A 1, B 'x' , C True ]
18:55:58 <jrmole> whose elements are one of: Left x, where x has type a, or Right y, where y has type b
18:56:07 <araujo> mmm...
18:56:16 <araujo> that is still a list of type E
18:56:24 <dons> > [toDyn 'x', toDyn (), toDyn True, toDyn "foo", toDyn (Just ('x','y'))]
18:56:26 <lambdabot>  [<<Char>>,<<()>>,<<Bool>>,<<[Char]>>,<<Maybe (Char,Char)>>]
18:56:56 <dons> sure. you just have to inspect at runtime the different elements, by looking at the constructors
18:57:14 <jrmole> @type [Left True, Right "blah"]
18:57:15 <lambdabot> [Either Bool [Char]]
18:57:18 <dons> you'd need an HList to do that statically
18:58:11 <dons> yeah, the HList form generalises the Either form
18:58:36 <dons> data Universal a b c d e f ..... = A a | B b | C c | D d ....  :)
19:01:53 <araujo> tieTYT, Don't think that's limiting. It is actually another feature that helps keep the purity of the language.
19:02:03 <araujo> keeping
19:03:20 <jrmole> static typing means you know what type every expression has at compile time.  for tuples, you know this because the tuple's type specifies how many elements it has, and their types individually
19:03:27 <jrmole> for lists, you know this simply because all elements have the same type
19:04:04 <zarvok> @where cabal-get
19:04:04 <lambdabot> http://hackage.haskell.org/darcs/cabal-get-bootstrap/
19:04:29 <zarvok> anyone know why that link doesn't work?
19:08:25 <foxy> dons, you mentioned a while ago that we 'now have functions over types', is that in reference to associated types?
19:08:45 <dons> ah yes
19:08:55 <dons> let me find you a link
19:09:25 <tieTYT2> alright
19:09:30 <dons> http://hackage.haskell.org/trac/ghc/wiki/TypeFunctions
19:09:32 <lambdabot> Title: TypeFunctions - GHC - Trac
19:10:41 <dons> e.g. http://hackage.haskell.org/trac/ghc/wiki/TypeFunctionsExamples
19:10:43 <lambdabot> Title: TypeFunctionsExamples - GHC - Trac
19:13:59 <ndm> that scares me
19:14:38 <ndm> although slightly less than the MPTC stuff, which is good
19:15:15 <dons> heh
19:16:57 <dons> this is nice:
19:16:57 <dons> data instance Map ()     v = MapUnit (Maybe v)
19:16:58 <dons> data instance Map (a, b) v = MapPair (Map a (Map b v))
19:18:04 <ndm> unconvinced...
19:18:29 <ndm> so that is a different representation of Map's given their type?
19:18:39 <dons> i'd prefer a type function over an FD any day
19:18:44 <ndm> so more optimised forthe different types?
19:18:50 <dons> yeah, I think so
19:19:09 <ndm> thats kinda neat
19:19:20 <ndm> i guess IntMap suddenly gets used automatically then
19:19:26 <dons> so a library can (type-safely) specify alternate represetations
19:19:53 <sjanssen> wow . . . are there patches for this yet?
19:20:43 <ndm> they've been flowing into the fc and fc-2 branches
19:22:44 <svref> Does type Float have the concept of +Infinity ?
19:23:24 <sjanssen> > (-1 / 0, 1 / 0)
19:23:25 <lambdabot>  (-Infinity,Infinity)
19:23:58 <svref> @type (-1 / 0, 1 / 0)
19:24:00 <lambdabot> forall a a1. (Fractional a, Fractional a1) => (a, a1)
19:24:08 <Cale> > 0/0
19:24:09 <lambdabot>  NaN
19:24:21 <svref> @type (-1.0 / 0, 1.0 / 0)
19:24:22 <lambdabot> forall a a1. (Fractional a, Fractional a1) => (a, a1)
19:24:50 <sjanssen> svref: numeric defaulting turns 1 / 0 into a Double
19:25:08 <svref> I can say (1/0)::Float right?
19:25:29 <svref> > (1/0)::Float
19:25:29 <dons> hmm, imagine data instance [] Word8 = ByteString
19:25:30 <lambdabot>  Infinity
19:25:54 <SamB> > 1/0
19:25:55 <lambdabot>  Infinity
19:25:59 <SamB> > 1/0 :: Rational
19:26:00 <lambdabot>  Exception: Ratio.%: zero denominator
19:27:19 <sjanssen> is this work part of a secret plan to get ATs into Haskell' ?
19:27:29 <dons> possibly
19:28:15 <dibblego> I read of definitions of "function" that use the distinctive adjectives "pure" and "impure" - yet from what I understand a function is by definition "pure" so this distinction makes no sense - or is this a different and more loose definition?
19:28:31 <dons> we talked about this yesterday, didn't we?
19:28:41 <dibblego> not this particular thing
19:28:56 <dons> functions have a different meaning in computer science
19:29:06 <dons> they can be side effecting , i.e. taking the RealWorld as a state
19:29:07 <foxy> dons, did you reply to my question?  I keep disconnecting...
19:29:19 <dons> foxy, http://hackage.haskell.org/trac/ghc/wiki/TypeFunctions
19:29:22 <lambdabot> Title: TypeFunctions - GHC - Trac
19:29:28 <foxy> dons, thanks
19:29:42 <dibblego> then all routines are functions
19:29:55 <dons> in computer science, they're roughly synonyms
19:30:03 <dons> as we talked about yesterday :)
19:30:35 <dibblego> then what is functional programming?
19:31:02 <SamB> computer math!
19:31:03 <dibblego> C# is a functional language
19:31:03 <dons> that's functions in the mathematical sense, as we said yesterday
19:31:16 <jrmole> programming in a language where functions are first-class
19:31:25 <dibblego> so we use the term "functional programming" in a mathematical sense, but not a computer science sense - that makes no sense
19:31:32 <Korollary> Functions in CS have not been traditionally like functions in maths.
19:31:46 <jrmole> nor are functions in functional languages always referentially transparent
19:31:59 <dons> yeah, like jrmole says. its the first classedness of functions in FP that matters
19:32:01 <jrmole> scheme and ML are just as much "functional programming" as haskell
19:32:09 <dons> hence pure functional languages
19:32:19 <dibblego> ok then, I'll live with that
19:32:46 <dons> it just happens that functions in haskell are often functions
19:33:20 <SamB> dons: actually, they are functions unless you are playing tricks on your compiler
19:33:22 <jrmole> barring unsafe operations, they always are
19:33:40 <dibblego> functions in Java are often functions
19:33:50 <jrmole> but you can't assume they are
19:33:51 <SamB> java doesn't even support functions
19:33:57 <jrmole> thus you cannot do equational reasoning
19:33:59 <dibblego> sure it does
19:34:03 <SamB> nope!
19:34:05 <SamB> only methods!
19:34:05 <dons> but I often play tricks on the compiler, SamB :)
19:34:06 <dibblego> yep!
19:34:06 <Korollary> methods are not functions
19:34:11 <SamB> dons: yes I know ;-)
19:34:12 <dibblego> methods are functions
19:34:16 <araujo> no
19:34:16 <dibblego> let me show you
19:34:20 <dibblego> yes
19:34:32 <Korollary> methods are like functions but they have access to the object's state
19:34:39 <Korollary> and other globals
19:34:43 <dibblego> Simple Type-Theoretic Foundations for Object-Oriented Programming
19:34:58 <dibblego> a method is directly analogous to a function
19:35:01 <jrmole> really i'd say "functional programming" is defined by style and idioms more than language
19:35:05 <dibblego> a "function in disguise" if you will
19:35:16 <dibblego> there is nothing "special" about a method that makes it not a function
19:35:25 <jrmole> you can do FP-like stuff in many languages, and you can write imperative code in scheme or even haskell
19:35:50 <dibblego> nothing is global until we have proof of a finite universe
19:36:01 <Korollary> eh?
19:36:02 <SamB> hah
19:36:13 <dibblego> nothing is global - I will demonstrate if you like
19:36:15 <araujo> dibblego, a method is a piece of code associated to a specific object.
19:36:15 <dons> imperative programming is just a special case of functional programming anyway ;)
19:36:16 * SamB thinks dibblego is an expert in missing the point
19:36:25 <dons> SamB: I suspect so too :)
19:36:50 <dibblego> no, I think you are missing the point - this is a common misunderstanding
19:36:53 <SamB> "nothing is global"? WTF does it matter if these things don't effect the entire universe?
19:36:56 <dibblego> but I'm open to what I don't know
19:36:58 <araujo> And which is usually invoked through a well defined interface for _that_ specific object or set of objects, like message passing.
19:37:05 <SamB> they do effect the machine they run on
19:37:11 <dibblego> SamB, that's a separate argument - and a very lengthy one - if you like
19:37:28 <SamB> we weren't talking about the whole universe
19:37:33 <dibblego> SamB, "the machine" is not "global"
19:37:41 <Korollary> I don't see what global scope has anything to do with universes.
19:37:41 <dibblego> 'this' in Java is not global
19:37:45 <SamB> dibblego: there you go missing the point again
19:37:49 <dons> dibblego: I mean, you've been asking this question about functions since the 2nd of this month...
19:37:53 <dons> what's the deal?
19:37:55 <dibblego> Korollary, either everything is global or nothing is - you can't have one or the other
19:37:59 <SamB> "the machine" is not what most people even mean when they say global
19:38:05 <SamB> most people mean "the process"
19:38:07 <dibblego> SamB, actually it's not
19:38:23 <dibblego> no, they oten mean something else - look at what Korollary said for example
19:38:34 <araujo> dibblego, A function is more like a blackbox where you can put values in, to get other values out. f (x) = y for all x
19:38:34 <jrmole> haskell is the only programming language i know of that regularly provokes discussion of metaphysics ;)
19:38:36 <SamB> well, global scope is typically per-process...
19:38:41 <Korollary> dibblego: "Global" here refers to scope of a variable in a program.
19:38:43 <dibblego> SamB, what is the "singleton design pattern"?
19:38:51 <SamB> dibblego: you are crazy!
19:38:57 <SamB> do you know what "process" means?
19:39:03 <dibblego> SamB, they say that, but I have no option to think the opposite is true
19:39:06 <dibblego> SamB, yes
19:39:12 * johnnowak reaches for his gun
19:39:22 <dons> 08.02.2006: 18:34:33 <dibblego> what's the opposite of "referentially transparent"? ; [big discussion about functions and functions] 18:54:00 <LordBrain> the reason being that the word function is suggestive of "functional" which impli
19:39:26 <dons> es referential transparency...
19:39:31 <dibblego> Korollary, you used the term "global" to refer to what is represented by "this" in Java
19:39:31 * edwardk hides behind johnnowak, somewhere outside of his field of vision.
19:39:40 <Korollary> dibblego: No, I didn't.
19:39:40 <araujo> jrmole, that's because haskell use term from metaphysics!
19:39:54 <dibblego> Korollary, you used it to distinguish a method and a function
19:40:14 <Korollary> dibblego: Yes, I did.
19:40:17 <edwardk> well, kor is a weirdo ;)
19:40:32 <dibblego> Korollary, by referring to what Java calls 'this'
19:40:33 <Korollary> edwardk: Shhh. My therapist strongly disallows you from using that term.
19:40:44 <edwardk> =)
19:41:01 <dibblego> I am used to tomatoes being thrown at me for non-conformance - I'll leave when it becomes uninformative
19:41:11 * edwardk doesn't listen to therapists. How do you think I wound up the well balanced individual I am today? =)
19:41:18 <dons> 06.02.15:14:44:00 <dibblego> is a 'functional language' one where all functions are 'pure'?
19:41:33 <dibblego> dons, clearly not
19:41:38 <johnnowak> dons: maybe there are two dibblegos?
19:41:45 <dibblego> there aren't - I asked that
19:41:58 * SamB throws uninformative tomatoes at dibblego 
19:42:06 <dons> nope, just one dibblego
19:42:12 <jrmole> and what's this about singleton design patterns?
19:42:17 <johnnowak> dons: maybe he has a split personality?
19:42:30 <edwardk> i think it might be referring to the one per program in some sort of universal existential way, not sure ;)
19:42:41 <johnnowak> edwardk: :)
19:42:47 <dibblego> jrmole, I dare you to define it - after you do, I will hold something before you that meets that definition and you will call it absurd - this is recursive - eventually, you will start talking about the universe to try to define scope
19:43:12 <araujo> dibblego, what is your point? .. if you got any ...
19:43:23 <jrmole> to define what?
19:43:24 <dibblego> araujo, none in this case - it is a tangent like I said earlier
19:43:25 <edwardk> dibblego: singletons are a design pattern, design ptterns are inherently fuzzy around the edges
19:43:33 <dibblego> and a very lengthy discussion I should warn
19:43:35 <SamB> dibblego: the singleton pattern is the pattern where you try to pretend that you can have a class with only one instance ;-P
19:43:40 <dibblego> edwardk, I disagree, but that's ok
19:43:42 <araujo> a discussion .. with no point .. right
19:43:56 * johnnowak thinks dibblego is bluffing
19:43:56 <jrmole> design patterns are a general system for using many, many words to describe simple things
19:43:57 <dibblego> araujo, I refuted a point was the point since it is wrong (and common)
19:44:18 <dibblego> the term "design patterns" is a euphemism
19:44:21 <SamB> dibblego: if it isn't fuzzy around the edges... it must be a mathematical construction.
19:44:34 <araujo> i don't know why, that sentence got a kaleish feeling ....
19:44:35 <SamB> dibblego: it means "fuzzy things"!
19:44:40 <dibblego> SamB, it is not only fuzzy around the edges - it just cannot exist
19:44:47 <Korollary> dibblego: I didn't mean that "this" is global. You can claim that MyObject.method(arg1, arg2) is syntactic sugar for method(MyObject, arg1, arg2). That's just an implementation tactic. The word 'method' implies a certain object, which is why we usually tend to use the term not interchangeably with function.
19:44:48 <SamB> araujo: you mean keal?
19:44:48 <jcreigh> jrmole: So you're saying design patterns are a template for the general concept of excessive verbosity? :)
19:44:55 <araujo> SamB, that is it
19:44:56 <jrmole> if a design pattern weren't fuzzy around the edges, you could code it
19:44:59 <SamB> @. elite keal
19:44:59 <lambdabot> (aL3 3Tc 41r3ady poiN+Ed 0u+ h4zx3l| iz0rz pUny TO NO7HIng TO 3/\/\u|AtE u$ing /\/\Y baRraG3 Of M4tHemATIC +HEORIES
19:45:02 <edwardk> one can always hold up an assinine example of a design pattern, it doesn't invalidate the fact that the patterns can be useful (to Java programmers *cough*) =)
19:45:07 <jrmole> then it would cease to be a design parameter and become a parametrized module or something
19:45:08 * johnnowak hands dibblego a 'Relativism and You' pamphlet
19:45:18 <jrmole> right, because Java programmers are used to using lots of code to describe simple things
19:45:19 <SamB> johnnowak: good man!
19:45:21 <dibblego> jrmole, I disagree strongly, but it is a side issue
19:45:26 <jrmole> so when they talk about what they do, it's natural to use lots of words ;)
19:45:35 * SamB holds up a "no relativists allowed" sign
19:45:43 <dons> ?remember jcreigh So you're saying design patterns are a template for the general concept of excessive verbosity?
19:46:15 <dibblego> I wish those books had never been written on design patterns - we'd have made a lot of progress otherwise
19:46:19 <Korollary> A design pattern is a reoccurring pattern in programs that cannot be captured by the language itself. Singleton is such a pattern, which people use.
19:46:26 <edwardk> Well, design patterns are one of those things that typically provoke a heted response. Personally, I like them if only because they tend to give a more accessible common terminology to discuss common problems.
19:46:29 <dibblego> believe what you will - thanks for the tips
19:46:41 * jcreigh admits that he hasn't read the book.
19:46:48 <jrmole> well, i'm sure there are certain design patterns that describe things which are... actually things
19:46:50 <dons> ramkrsna: you mean this is keal-ish "I refuted a point was the point since it is wrong (and common)" ?
19:46:57 <dons> grr. araujo ^^
19:47:03 <dibblego> jcreigh, "the book" is GoF - a pile of biblical nonsense worshipped by many (obviously)
19:47:11 <SamB> so, like, monads before type classes would be a design pattern? (perhaps a mythical one, perhaps not...)
19:47:16 <Korollary> Design patterns are not really bad things.
19:47:17 <edwardk> dib: heh
19:47:19 <lispy> no, the book is good
19:47:26 <dibblego> burn it I say
19:47:30 <lispy> it helped a lot of people to understand things
19:47:30 <araujo> dons, yeah
19:47:36 <jrmole> but the way people talk about design patterns annoys me to no end
19:47:43 <SamB> Korollary: what say you?
19:47:50 <jrmole> they come up with more and more terms to muddy the view of what's going on
19:47:59 <dibblego> it misled a lot of people into fantasical understandings of software development - if you call that helping
19:47:59 <Korollary> SamB: about monads?
19:48:05 <dons> araujo: I agree.
19:48:09 <jrmole> instead of trying to implement their halfassed abstractions, and occasionally getting something concrete and useful like monads
19:48:19 <SamB> Korollary: yes. if we used monads with no typeclasses, that would be a design pattern, right?
19:48:27 <dibblego> anyway, I don't like mixing religion and IRC
19:48:32 <jcreigh> dibblego: I've heard of it, I just haven't read it.
19:48:33 <dibblego> thanks again for the tips - sorry for stirring
19:48:49 <lispy> DSLs are a design pattern and we use them all the time in haskell, does that make DSLs bad now?
19:48:57 <edwardk> In the end it gives a lot of names, and some useful novel OOP usage patterns, and people move on with their life and most people just remember to name certain objects Factories from then on ;)
19:49:12 <dibblego> edwardk++; // :)
19:49:13 <SamB> edwardk: heh
19:49:14 <Korollary> SamB: I am not sure. When you use monads, you capture some abstraction with the language itself. It's got to be something that you syntactically *have* to repeat.
19:49:16 <jrmole> maybe we should periodically try to implement every design pattern as a typeclass, and if it doesn't work, we should erase a randomly-chosen half of the nodes on c2 describing it ;)
19:49:25 <johnnowak> awww.
19:49:30 <araujo> hah
19:49:46 * johnnowak was hoping to learn why globals don't exist
19:50:03 <SamB> Korollary: but, I mean, you'd need to come up with new names for return, >>=, and >>...
19:50:07 <jcreigh> johnnowak: "globals"?
19:50:08 <Korollary> jrmole: There's an article by Norvig (?) that shows that 16 out of 23 patterns don't exist in Lisp.
19:50:19 <edwardk> heh
19:50:23 <jcreigh> Maybe I should read the scrollback. :)
19:50:24 <SamB> Korollary: of course
19:50:30 <johnnowak> jcreigh: :)
19:50:47 <lispy> Korollary: oh, do you have a link, that sounds fun to read
19:50:48 <SamB> whenever they got a nice pattern, they wrote a macro for it after they used it a few times...
19:51:07 <Korollary> @google 16 out of 23 patterns don't exist in Lisp
19:51:12 <lambdabot> http://use.perl.org/~petdance/journal/
19:51:12 <lambdabot> Title: Journal of petdance (2468)
19:51:15 <Korollary> blah
19:51:21 <SamB> @google "16 out of 23 patterns don't exist in Lisp"
19:51:23 <lambdabot> No Result Found.
19:51:27 <SamB> hmm
19:51:29 <jrmole> DSLs may be a design pattern, but i'd rather call them by this new term i just invented
19:51:31 <jrmole> "good idea"
19:51:36 <lispy> @google norvig design patterns lisp
19:51:39 <SamB> @google "patterns don't exist in Lisp"
19:51:39 <lambdabot> http://www.norvig.com/design-patterns/
19:51:39 <lambdabot> Title: Design Patterns in Dynamic Programming
19:51:42 <lambdabot> http://www.mail-archive.com/kplug-lpsg@kernel-panic.org/msg00375.html
19:51:42 <lambdabot> Title: Re: Code Completion (Was: KPLUG-LPSG: Lambda the Ultimate)
19:51:48 <Korollary> http://norvig.com/design-patterns/
19:51:50 <lambdabot> Title: Design Patterns in Dynamic Programming
19:52:55 <Pseudonym> Incidentally, the assertion was completely wrong.
19:52:59 <Korollary> This is also very good by Norvig
19:53:01 <Korollary> http://www.norvig.com/21-days.html
19:53:02 <lambdabot> Title: Teach Yourself Programming in Ten Years
19:53:06 <jcreigh> jrmole: I'd love to see a programming book entitled "good ideas". :)
19:53:13 <jcreigh> Pseudonym: Norvig's?
19:53:13 <jrmole> i'd love to write one
19:53:19 <dons> ndm, ping
19:53:19 <jrmole> ;)
19:53:20 <Pseudonym> 16 out of 23 patterns described in a book subtitled "reusable object-oriented software" don't exist in Lisp.
19:53:29 <Pseudonym> Well duh.
19:53:33 <lispy> dons: i wrote a lambdabot plugin last night (needs a ton of polishing still) but i wondered if you'd have any interest in it.  It works sort of like url-title, but instead it grabs the tiny-url for long urls...
19:53:34 <Pseudonym> Lisp isn't object oriented.
19:53:42 <edwardk> pseudonym: heh
19:53:48 <dons> lispy: nice idea!
19:53:54 <Korollary> Pseudonym: He meant CLOS iirc
19:53:55 <Pseudonym> OTOH there are whole papers devoted to implementing configuration and global state in Haskell.
19:54:09 <Pseudonym> Patterns which don't exist in C++.
19:54:17 <SamB> a monad a monad!
19:54:23 <dons> ?remember TimSweeney In a concurrent world, imperative is the wrong default!
19:54:24 <SamB> a penny for your monad!
19:54:26 <lispy> dons: okay, i'll send patches once i'm done refactoring and testing
19:54:36 <jcreigh> Pseudonym: Hmm...good point.
19:54:41 <dons> lispy: should it just be an extension to Url.hs ?
19:54:45 <SamB> (shipping and handling not included)
19:54:48 <edwardk> dons: heh
19:54:54 <lispy> dons: yeah, i think so, that's part of the refactoring :)
19:55:04 <Pseudonym> Any good engineer knows that any programming job requires more than the language gives you.
19:55:08 <lispy> dons: Title: Foo, http://tinyurl.com/blah
19:55:17 <Pseudonym> You at the very least need to supply the "business logic".
19:55:32 <lispy> dons: and then if there is no title but still a long url it could just print the tinyurl
19:55:33 <SamB> what is this ... "business logic"... you speak of?
19:55:34 <dons> ?remember MatthiasFelleisen we have come to the conclusion that programs in less expressive languages exhibit repeated occurrences of programming patterns, and that this pattern-oriented style is detrimental to the programming process [1991, On the Expressive Power of Programming Languages]
19:56:00 <Pseudonym> SamB: Indeed.
19:56:08 <nuffer> what's the function of type Ptr a -> IO a?
19:56:16 <Korollary> More relevant to #scheme, but I don't feel like pasting it there, heh: http://calculist.blogspot.com/2006/08/even-can-be-odd.html
19:56:18 <lambdabot> Title: The Little Calculist: Even can be odd
19:56:24 <SamB> @hoogle Ptr a -> IO a?
19:56:25 <lambdabot> Did you mean: Ptr a -> IO A?
19:56:31 <SamB> no!
19:56:35 <SamB> @hoogle Foreign.Ptr a -> IO a?
19:56:36 <lambdabot> Did you mean: Foreign.Ptr a -> IO A?
19:56:37 <nuffer> google didn't help me at all
19:56:43 <Pseudonym> Basically, Norvig made the same newbie mistake that a lot of Java script kiddies did: Design Patterns the idea == Design Patterns the book.
19:56:51 <SamB> @hoogle Foreign.Ptr.Ptr a -> IO a?
19:56:51 <nuffer> there has to be a function like that though, right?
19:56:52 <lambdabot> Did you mean: Foreign.Ptr.Ptr a -> IO A?
19:56:57 <SamB> ACK!
19:57:04 <SamB> @docs Foreign.Ptr
19:57:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Ptr.html
19:57:05 <nuffer> I mean, how else am I going to access my Ptrs' data?
19:57:07 <Pseudonym> For "Design Patterns" the idea, read "engineering experience".
19:57:11 <nuffer> also seen that, no information
19:57:12 <Korollary> Pseudonym: But he was deliberately addressing those patterns.
19:57:17 <Pseudonym> Sure he was.
19:57:19 <Pseudonym> But so what?
19:57:30 <Pseudonym> He tried to spin it that Lisp was superior to Smalltalk.
19:57:31 <Korollary> Well, the GoF guys got an ACM awards for that.
19:57:38 <SamB> @docs Foreign.Storable
19:57:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Storable.html
19:57:38 <jrmole> nuffer, peek?
19:57:44 <Pseudonym> Because look at all the design patterns you don't need!
19:58:00 <Pseudonym> Completely missing that there are patterns which turn up in Lisp that Smalltalk doesn't need.
19:58:27 <Pseudonym> All right, I'll stop now.
19:58:30 <SamB> Pseudonym: you mean like macros?
19:58:30 <edwardk> or scheme, call/cc based patterns.
19:58:31 <nuffer> ahhh
19:58:35 <nuffer> there we go, thank you
19:59:56 <Korollary> Pseudonym: I suppose he was trying to change the attitude from "Wow, cool patterns" to "Damn, we need patterns."
20:00:07 <Pseudonym> Perhaps.
20:00:42 <edwardk> dons: whats the default array size underlying the data.bytestring stuff?
20:00:52 <Korollary> I have a book on UML + patterns. I can't read it before bedtime coz I just snooze.
20:01:02 <edwardk> kor: heh
20:01:20 <edwardk> the only pattern books i've liked have been the GoF book and the antipatterns book.
20:01:26 <Pseudonym> Korollary: I'm defending patterns, not UML.  UML is almost indefensible.
20:01:37 <edwardk> oh and i thin vlissides had a little addendum to the gof book that didn't suck too bad
20:01:48 <Pseudonym> In particular, I believe it to be fundamentally incompatible with agile development.
20:01:59 <Pseudonym> It's no use for designing code.
20:02:04 * edwardk agrees wholeheartedly.
20:02:05 <Korollary> Pseudonym: One day we will have executable UML. Just you wait :: Maybe Pseudonym
20:02:11 <Pseudonym> Its only use is for documenting it.
20:02:25 <Pseudonym> But agile development implies that the structure might be changing.
20:02:28 <johnnowak> Korollary: thanks for that even-can-be-odd link
20:02:42 <Pseudonym> UML can't capture that change, IM(L)E.
20:02:48 <Cale> Korollary: then you'll document the executable UML with more UML
20:02:55 <Cale> hehe
20:03:08 <edwardk> UML is like a death certificate for innovation. Once you write it you might as well start mourning the code and move on. ;)
20:03:10 <Korollary> Cale: Sadly, I saw that in a job ad while I was looking a year ago. "Executable UML".
20:03:22 * Pseudonym is trying to think of Lisp-specific design patterns, BTW
20:03:34 <Pseudonym> Not being a Lisp-head, it's hard. :-)
20:03:36 <Korollary> Pseudonym: Parentheses!
20:03:56 <edwardk> pseudonym: scheme define-syntax automata?
20:04:18 <Korollary> edwardk: But you define syntax differently if you wish.
20:04:19 <jrmole> there are haskell design patterns at http://haskell.org/hawiki/CommonHaskellIdioms
20:04:19 <tieTYT2> will the haskell code I write and compile on windows xp always compile on *nix?
20:04:21 <lambdabot> Title: CommonHaskellIdioms - The Haskell Wiki
20:04:55 <Pseudonym> Yeah, I'm thinking more like CommonHaskellIdioms.
20:05:20 <jcreigh> tieTYT2: "always"? So long as you stay away from platform-specific libraries and features, I imagine so.
20:05:26 <Pseudonym> My first thought was tail recursion, which is mostly unnecessary in a language with loops.
20:05:34 <Pseudonym> But that doesn't really capture what I'm thinking of.
20:05:44 <jrmole> in fact most such languages don't implement tail recursion efficiently
20:05:49 <edwardk> pseudonym: the scheme define-syntax habit of creating domain specific languages is probably the grossest example of a habit a schemer has that most other programming language programmers don't.
20:05:54 <dons> ?karma+ sjanssen -- @redo
20:05:54 <lambdabot> sjanssen's karma raised to 13.
20:05:55 <jrmole> unless by "with loops" you mean "with loops defined in terms of tail recursion" ;)
20:06:00 <tieTYT2> ok, thanks
20:06:08 <Pseudonym> edwardk: You've never seen C++ template libraries, then?
20:06:10 <edwardk> @redo x >>= y
20:06:10 <lambdabot> Maybe you meant: read todo undo
20:06:16 <edwardk> aww shucks =)
20:06:58 <dons> sjanssen: did you fix the issue of the monadic fail case in the translation?
20:07:04 <edwardk> pseudonym: sure. i do lots in template libraries, but they aren't as invasive about changing the syntax of the language. well, with the possible exception of spirit. ;)
20:07:10 <Pseudonym> :-)
20:07:15 <Pseudonym> OK, fair point.
20:07:33 <sjanssen> dons: which issue is this?
20:07:48 <lscd> What's the difference between let (a', b') = a b and let a' = a; b' = b?
20:08:18 <dons> the first doesn't type ?
20:08:21 <Korollary> lscd: you mean (a', b') = (a, b) ?
20:08:29 <edwardk> the first applies the function a to value b, then takes the result as a pair and splits it apart, the second, just makes aliases for the variable names.
20:08:37 <lscd> Korollary: nope
20:09:12 <dons> > (do Just x <- return Nothing; return x) :: [ Int ]
20:09:13 <Pseudonym> If you meant let (a', b') = (a,b), then there are a number of subtle differences which you don't want to know about.  Trust me on this.
20:09:13 <lambdabot>  []
20:09:16 <Korollary> lscd: Then they are quite different. a b is application of b to a, which produces a pair (a', b'). In the other case, a' = a.
20:09:18 <dons> ?undo > (do Just x <- return Nothing; return x) :: [ Int ]
20:09:19 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 1}) "Parse error"
20:09:22 <lscd> dons: hm. actually, the second doesn't in the example i'm playing with (http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html)
20:09:24 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
20:09:27 <dons> ?undo > do Just x <- return Nothing; return x
20:09:28 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 1}) "Parse error"
20:09:35 <dons> ?undo > do (Just x) <- return Nothing; return x
20:09:36 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 1}) "Parse error"
20:09:42 <dons> ?undo do (Just x) <- return Nothing; return x
20:09:43 <lambdabot> return Nothing >>= \ (Just x) -> return x
20:09:50 <dons> > return Nothing >>= \ (Just x) -> return x :: [Int]
20:09:51 <lambdabot>  Non-exhaustive patterns in lambda
20:09:52 <sjanssen> oh, I see
20:10:01 <lscd> ahhh, right, of course; i didn't realize a function application was happening. d'oh. thanks
20:10:10 <dons> its supposed to call 'fail', iirc
20:10:11 <Korollary> That's a good tutorial
20:10:22 <edwardk> so it needs the case mapping otherwise onto fail in the monad, right?
20:10:33 <sjanssen> edwardk: yep
20:10:49 <dons> or a big catch :)
20:10:55 <nuffer> given a list and an index how do I get an element?
20:10:56 <edwardk> mucks up short lambdas pretty bad though.
20:10:58 <lscd> Korollary: yeah, it's great - it's the only explanation of monads i've seen that ends up making any sense
20:11:04 <dons> > [1..10] !! 3
20:11:06 <lambdabot>  4
20:11:09 <nuffer> thanks
20:11:20 <dons> ?hoogle [a] -> Int -> a
20:11:21 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
20:11:26 <dons> is a better way to ask for what you wanted :)
20:11:34 <Pseudonym> nuffer: You're strongly advised not to do that, though.
20:11:45 <nuffer> O (n) access time?
20:11:50 <Pseudonym> Roughly 99% of newbie uses of (!!) are better replaced by a different algorithm.
20:11:52 <Korollary> lscd: Actually, when you go back and re-read the other tutorials, you may wonder what was wrong with them. It is a somewhat laborious subject.
20:12:04 <Pseudonym> xs !! i is O(i) access time.
20:12:12 <sjanssen> I can't recall the last time I used (!!)
20:12:13 <nuffer> I figured
20:12:24 <nuffer> but I have a list of 16 elements
20:12:26 <Korollary> I use !! when I can't be bothered in a small script.
20:12:30 <lscd> Korollary: hmm, do you mean i'll wonder what i found confusing, or what's poorly done about them?
20:12:30 <nuffer> and I need to pull three of them out]
20:12:31 <jrmole> it may be that monads are one of those things which one needs to see from a whole bunch of perspectives before understanding
20:12:39 <nuffer> I can't be bothered to get all three in one loop over the list
20:12:46 <nuffer> and this happens once on program loading
20:12:47 <jrmole> it may also be that we're just bad at explaining them, and each have our own pet metaphor ;)
20:12:48 <Korollary> lscd: Both
20:12:49 <nuffer> performance is a non-issue
20:13:16 <lscd> jrmole: hm. i think both are probably factors
20:13:23 <jrmole> as do i
20:13:27 <Korollary> jrmole: Isn't it especially curious that there is so little to explain in the first place ;)
20:13:33 <jrmole> also teaching IO doesn't help
20:13:37 <edwardk> nuffer which 3?
20:13:40 <lscd> jrmole: agreed entirely
20:13:44 <jrmole> because the IO monad is a rather strange monad to learn
20:13:58 <nuffer> sorry, four
20:14:03 <edwardk> ok, which four? =)
20:14:05 <nuffer> 4, 5, 6 and 7
20:14:24 <edwardk> > drop 3 $ take 4 $ [0..10]
20:14:26 <lambdabot>  [3]
20:14:27 <lscd> Korollary: well, yeah; but that doesn't prevent people from writing long tracts using strange metaphors that don't lead to monad-enlightenment :)
20:14:30 <edwardk> er..
20:14:38 <nuffer> heh
20:14:42 <edwardk> > take 4 $ drop 3 $ [0..10]
20:14:43 <lambdabot>  [3,4,5,6]
20:14:44 <Pseudonym> nuffer: That's cool, but I thought I'd give the standard disclaimer anyway.
20:14:58 <jrmole> people approach monads as "variations on IO" or "ways to represent side effects", which is okay for some of them, but not general
20:15:07 <jrmole> the Maybe monad is a good first example, imho
20:15:08 <nuffer> Pseudonym: no worries
20:15:19 <nuffer> edwardk: thanks
20:15:35 <edwardk> i've had to use !! maybe twice. dig through Data.List you'll find lots of neat toys there
20:15:55 <lscd> edwardk: hm, how do you handle command line arguments usually then?
20:15:59 <edwardk> that will dramatically speed up your code and make it more legible
20:16:09 <edwardk> lscd: command line arguments? =)
20:16:47 <Korollary> System.Console.GetOpt maybe?
20:16:50 <edwardk> yeah
20:16:54 <edwardk> thats what i was looking for =)
20:17:10 <lscd> edwardk: yeah, the things you get with getArgs?
20:17:13 <edwardk> positional arguments are so 1985 ;)
20:17:16 <lscd> Korollary: hm, ok
20:17:30 <lscd> edwardk: sure, but for sufficiently small scripts .. ;)
20:17:38 <edwardk> i use gnu style args for everything really
20:17:45 <edwardk> coz small scripts tend not to stay small
20:17:47 <lscd> fair enough
20:17:58 <Korollary> my small scripts stay small. Poor nutrition.
20:17:59 * jer tends to use bsd style args for everything unless not given a choice
20:18:04 <jrmole> edwardk, unix is so 1970 ;)
20:18:07 <edwardk> habit i got into in perl where its so easy to use getopt
20:18:16 <jer> but i tend to be a fan of brevity on the unix shell
20:19:04 <Korollary> edwardk: real man use turing complete DSL's for their options/config parsing ;)
20:19:18 <edwardk> kor: i do, its called hsplugins, thanks dons! =)
20:19:36 <Korollary> This is how you do it:
20:19:38 <Korollary> @karma+ dons
20:19:39 <lambdabot> dons's karma raised to 53.
20:20:56 <dons> hehe :)
20:21:07 <dons> yay for haskell config files
20:41:16 <nuffer> any easy way to make a Data.Array from a pointer?
20:41:21 <nuffer> a Foreign.Ptr that is
20:44:50 <dons> well not super easy, but doable. let me see....
20:45:57 <dons> (you'd be using a IOUArray or UArray though)
20:46:27 <dons> maybe it'd be just easier to stick with Foreign.Marshal.Array's?
20:46:43 <Korollary> Hmm. Ask.com tv ads.
20:48:50 <dons> nuffer: check out
20:48:51 <dons> ?wiki Modern_array_libraries
20:48:51 <lambdabot> http://www.haskell.org/haskellwiki/Modern_array_libraries
20:49:20 <dons> oh, unsafeForeignPtrToStorableArray perhaps?
20:49:59 <nuffer> ummm
20:50:03 <nuffer> ; ramdata <- sequence (map ((peekByteOff :: Ptr Word8 -> Int -> IO Word8) pram) [0..size])
20:50:04 <nuffer> 	; return (array (0, size) (zip [0..size] ramdata))
20:50:12 <nuffer> it's ugly, but I think it gets the result I want
20:50:24 <nuffer> (albeit kind of slowly)
20:50:37 <dons> would be faster to write a strict loop to do this though
20:50:46 <dons> go 0 = return ()
20:51:02 <dons> go n = .... ; go $! n-1
20:51:05 <dons> or some such
20:51:28 <dons> check here for some hints on fast peek/poke: http://www.cse.unsw.edu.au/~dons/code/fps/Data/ByteString.hs
20:52:08 <nuffer> huh
20:52:11 <nuffer> that looks interesting
20:52:32 <nuffer> I shall examine it at a later date -- perhaps when I feel like making this part of the program space/time efficient
20:52:56 <nuffer> it's a one-time cost though, so I'm not terribly concerned about efficiency at this early of a stage
20:53:17 <nuffer> anyway, I'm going to get some sleep
20:53:19 <nuffer> thanks for the help
21:11:14 <newsham> is there a function that does:    map (uncurry f) (zip a b)  ?
21:11:22 <newsham> (seems like that would be a common idiom)
21:11:53 <newsham> is that zipWith?
21:12:31 <newsham> heh, nevermind. :)
21:13:30 <lispy> @pl \f a b -> map (uncurry f) (zip a b)
21:13:30 <lambdabot> (. zip) . (.) . map . uncurry
21:13:34 <lispy> hmm..
21:13:47 <lispy> i wanted it to find zipWith
21:13:50 <newsham> > zipWith xor [1,2,3] [4,5,6]
21:13:50 <lambdabot>  Add a type signature
21:14:00 <newsham> > zipWith xor [1,2,3] [4,5,6]   :: [Int]
21:14:02 <lambdabot>  [5,7,5]
21:14:06 <lispy> shiny
21:14:15 * lispy moves toward the shiny
21:14:24 <newsham> > map (uncurry xor) (zip [1,2,3] [4,5,6])   :: [Int]
21:14:25 <lambdabot>  [5,7,5]
21:15:00 <newsham> what does "pl" in "@pl" stand for?
21:15:07 <lispy> maybe pl just doesn't have a rule for that
21:15:21 <lispy> pointless which is a pun, because it finds 'point free' forms
21:15:34 <Pseudonym> ?type zipWith
21:15:35 <newsham> *nod* danke.
21:15:36 <lambdabot> forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
21:15:43 <Pseudonym> ?free zipWith :: forall c b a. (a -> b -> c) -> [a] -> [b] -> [c]
21:15:45 <lambdabot> f . k x = p (h x) . g => $map f . zipWith k y = zipWith p ($map h y) . $map g
21:17:11 <newsham> > map (\(a,b) -> xor a b) (zip [1,2,3] [4,5,6])   :: [Int]
21:17:12 <lambdabot>  [5,7,5]
21:17:23 <newsham> @pl \(a,b) -> xor a b
21:17:24 <lambdabot> uncurry xor
21:18:15 <newsham> @pl \a,b -> map (uncurry xor) (zip a b)
21:18:15 <lambdabot> uncurry (zipWith xor)
21:18:45 <newsham> @pl \a b -> map (uncurry xor) (zip a b)
21:18:45 <lambdabot> zipWith xor
21:19:13 <newsham> @pl \f a b -> map (uncurry f) (zip a b)
21:19:14 <lambdabot> (. zip) . (.) . map . uncurry
21:19:27 <newsham> ahh, because with f it wouldnt be pointsfree.
21:23:23 <tieTYT2> how do i read this: map :: (a -> b) -> [a] -> [b]
21:23:32 <tieTYT2> does this mean map takes one argument that's a function that turns a into b
21:23:38 <tieTYT2> i mean takes an a and returns a b
21:23:54 <tieTYT2> and another argument that's a list of [a] and returns a list of [b]?
21:24:02 <edwardk> tie: yeah
21:24:02 <foxy> tyeTYT2: yes
21:24:06 <newsham> map takes a function (a -> b) and a list [a] and returns a list [b]
21:24:21 <foxy> > map (+ 1) [1..5]
21:24:22 <lambdabot>  [2,3,4,5,6]
21:24:26 <edwardk> > map show [1..5]
21:24:27 <lambdabot>  ["1","2","3","4","5"]
21:24:28 <newsham> the function maps from an a to a b.  and the input is a list of as and the output is a list of bs
21:24:41 <tieTYT2> ok so.... does that mean when i do a :t on something and part of its type definition has parenthesis around it, that means that part represents a function?
21:24:53 <edwardk> yeah.
21:24:53 <newsham> if there's an arrow in the parens.
21:24:56 <newsham> like (a -> b)
21:25:01 <tieTYT2> coo
21:25:18 <foxy> a -> (b -> c) is the same as a -> b -> c
21:25:36 <edwardk> though you can also view it because of associativity, as a function that takes a function from (a -> b) and returns a function that maps ([a] -> [b])
21:25:36 <foxy> but (a -> b) -> c is not
21:26:11 <edwardk> a -> b -> c -> d is equivalent to a -> (b -> (c -> d))
21:26:33 <tieTYT2> now.... if i saw ... :: (a -> b) -> (c -> d)  does that mean there's a function that takes a function and returns a different function (also, is that possible in haskell)?
21:27:02 <edwardk> tie: sure, but that function would usually be written (a -> b) -> c -> d, and would mean the exact same thing
21:27:19 <edwardk> @type map show
21:27:21 <lambdabot> forall a. (Show a) => [a] -> [String]
21:27:34 <edwardk> @type map (+1)
21:27:35 <lambdabot> forall a. (Num a) => [a] -> [a]
21:27:42 <tieTYT2> edwardk: if it's written your way, how do i know it's not a function that takes a function and a single value and returns a single value?
21:27:50 <foxy> @djinn (a -> b) -> c -> d
21:27:50 <lambdabot> -- f cannot be realized.
21:27:51 <edwardk> its both =)
21:28:04 <edwardk> haskell uses currying, you can partially apply a function to its arguments and get another function
21:28:15 <tieTYT2> whoa, over my head right now
21:28:18 <edwardk> @type (1+)
21:28:19 <lambdabot> forall a. (Num a) => a -> a
21:28:23 <edwardk> (1+) 2
21:28:25 <tieTYT2> i'll get to that evenually
21:28:26 <edwardk> > (1+) 2
21:28:27 <lambdabot>  3
21:28:33 <edwardk> note the funny parens
21:28:47 <newsham> anyone know of an rc4 implementation in haskell?
21:29:13 <edwardk> tie: i only mention it because its kind of critical to understanding the haskell syntax.
21:29:42 <edwardk> tie: the idea of currying is that you can always take a function that expects (a,b) -> c and obtain a function of type a -> b -> c and vice versa
21:29:57 <tieTYT2> this tutorial hasn't mentioned the word yet, but i've heard of it
21:30:00 <edwardk> @type curry
21:30:01 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
21:30:05 <edwardk> @type uncurry
21:30:06 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
21:30:30 <edwardk> @type (+)
21:30:31 <lambdabot> forall a. (Num a) => a -> a -> a
21:30:36 <edwardk> @type uncurry (+)
21:30:37 <lambdabot> forall b. (Num b) => (b, b) -> b
21:30:44 <tieTYT2> how come @type show says <lambdabot> forall a. (Show a) => [a] -> [String] but when i type it into ghci i get: show :: (Show a) => a -> String
21:31:00 <dons> different ghci version
21:31:03 <dons> ?version
21:31:04 <lambdabot> lambdabot 4p93, GHC 6.5 (OpenBSD i386 )
21:31:04 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:31:08 <dons> --> GHC 6.5
21:31:20 <tieTYT2> i have 6.4.2 i think...
21:31:24 <tieTYT2> but i thought i grabbed the latest
21:31:29 <edwardk> wit
21:31:32 <tieTYT2> is there a later version for OpenBSD than windows?
21:31:34 <edwardk> @type show
21:31:36 <lambdabot> forall a. (Show a) => a -> String
21:31:41 <edwardk> thats what it says
21:31:55 <edwardk> i said @type 'map show' above
21:32:04 <edwardk> trying to demonstrate partial application
21:32:23 <tieTYT2> @type show
21:32:24 <lambdabot> forall a. (Show a) => a -> String
21:32:31 <foxy> > (show . read) 1
21:32:32 <lambdabot>  add an instance declaration for (Num String)
21:32:33 <tieTYT2> oh my mistake
21:32:36 <tieTYT2> but you see it's different
21:32:55 <tieTYT2> do i need to be on *nix to get version 6.5?
21:33:05 <edwardk> tie: the forall is implied
21:33:20 <Korollary> 6.5 is not officially out yet.
21:33:32 <tieTYT2> oh
21:33:43 <edwardk> tie: its a nicety of haskell that you can avoid having to specify that a,b,c, etc are variables over types as long as you use lowercase names
21:33:59 <tieTYT2> ah i remember reading about that
21:34:06 <edwardk> [a] is shorthand for forall a. [a]
21:34:51 <tieTYT2> alright
21:34:55 <edwardk> there are very few cases in which you really want to move the foralls around, so haskell just sticks them on the outside.
21:34:57 <tieTYT2> i'm gonna go back to this tutorial
21:35:00 <edwardk> kk
21:35:34 <lispy> could you have? [forall a. a]
21:36:11 <Pseudonym> No, but you could do this:
21:36:17 <Pseudonym> data Id = forall a. Id a
21:36:18 <Pseudonym> [Id]
21:36:41 <lispy> oh
21:36:43 <edwardk> then you can have your heterogeneous list
21:37:14 <Pseudonym> It's a restriction because of the way you implement it.
21:39:47 <jrmole> what's the precise restriction? foralls cannot appear inside constructors other than (->) ?
21:44:00 <edwardk> http://www.macs.hw.ac.uk/~dsg/gph/docs/4.06/users_guide/universal-quantification.html says a bit about it
21:44:13 <edwardk> not sure it gives you what you want, jr
21:52:13 <jrmole> bbl
21:58:43 <tieTYT2> ok what's up with this: x 'a' :: (Char -> t) -> t
21:58:53 <tieTYT2> why isn't it (Char -> t) -> a?
21:59:07 <tieTYT2> oh sorry, i get it
21:59:50 <newsham> I wrote an RC4 function (and found another one online) and cant help thinking that rc4 looks a lot longer and more complicated in haskell than in other languages
22:03:14 <newsham> anyone have ideas for smaller and more elegant code?
22:03:34 <newsham> (I think implementing the state as a function might make for smaller code, but probably really inefficient)
22:10:35 <edwardk> haven't ported any of my crypto stuff to haskell yet, so dunno
22:10:55 <newsham> wanna look over the code (short)?
22:43:53 <tieTYT2> is this how you define a datatype that takes as arguments, 2 of one type and 2 of another type? data Quadruple a a1 b b1 = Quadruple a a1 b b1
22:44:32 <dons> hmm, how about data Quadruple a b = Q a a b b -- ?
22:44:43 <dons> since otherwise you have no check that a == a1 and b == b1
22:45:19 <tieTYT2> pft, this sounds like something stupid with the tutorial again
22:45:32 <tieTYT2> i'm gonna check the answer to this exercise and see if it didn't teach me something
22:46:25 <tieTYT2> yep
22:46:27 <tieTYT2> and yes, you're right
22:46:42 <tieTYT2> but i don't think there's any way i could have known that by reading this tutorial sequentially -__-
22:46:54 <dons> hmm. interesting.
22:47:46 <tieTYT2> well i guess i could have but i would have really had to read into things
22:47:52 <edwardk> yeah
22:49:34 <tieTYT2> ok so this part: data Quadruple a b =
22:49:52 <tieTYT2> that just defines the types in the constructors you're going to use?
22:50:47 <tieTYT2> also, when i do it dons way, i can :t Q but i can't :t Quadruple.  What is the point of the word after data (ie: Quadruple)
22:51:19 <edwardk> yeah it does
22:51:35 <monochrom> So that you can have two cases.  data TwoCases a b c = Perhaps a a b b | Perchance c c c
22:51:45 <edwardk> the word after data names the data type, the word on the right hand side of the = names the constructor
22:52:00 <edwardk> data Maybe a = Just a | Nothing
22:52:13 <edwardk> now you can refer to the type Maybe, or the constructors Just or Nothing
22:52:14 <tieTYT2> oh i get it
22:52:24 <tieTYT2> :t on Quadruple is like doing :t on Int
22:52:26 <tieTYT2> which doesn't make sense
22:52:42 <edwardk> the fact that it CAN be the same is an accident of the syntax, since they can never be used in the same place.
22:53:39 <tieTYT2> ah this is becoming clear
22:53:52 <tieTYT2> ok thanks guys
22:54:36 <dons> you can in fact use :k on the _type_ though, to see how many type arguments it takes
22:54:39 <dons> ?kind Int
22:54:41 <lambdabot> *
22:54:43 <dons> ?kind Maybe
22:54:44 <lambdabot> * -> *
22:55:01 <dons> so, ?kind Quadruple ==>   * -> * -> *
22:55:13 <tieTYT2> oh
22:55:15 <tieTYT2> i see
22:55:36 <dons> ?type 'x'
22:55:38 <lambdabot> Char
22:55:41 <dons> ?kind Char
22:55:43 <lambdabot> *
22:56:04 <Pseudonym> ?kind Control.Monad.RWS
22:56:06 <lambdabot> Not in scope: type constructor or class `Control.Monad.RWS'
22:56:11 <Pseudonym> ?kind Control.Monad.State.RWS
22:56:13 <lambdabot>   Not in scope: type constructor or class `Control.Monad.State.RWS'
22:56:20 <Pseudonym> ?kind RWST
22:56:22 <lambdabot> Not in scope: type constructor or class `RWST'
22:56:42 <Pseudonym> ?hoogle runRWST
22:56:43 <lambdabot> Control.Monad.RWS.runRWST :: RWST r w s m a -> (r -> s -> m (a, s, w))
22:56:53 <tieTYT2> hm, does the fact that :t 'x' returned Char mean that '' is a function?
22:56:53 <Pseudonym> ?kind Control.Monad.RWS.RWST
22:56:55 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
22:56:59 <Pseudonym> That's it.
22:57:19 <dons> tieTYT2: no, not quite. '' is special syntax for a character literal
22:57:34 <dons> I suppose it could be viewed as a constructor, but it isn't really
22:57:41 <dons> unlike []
22:57:44 <tieTYT2> hm i see
22:57:49 <dons> ?type []
22:57:50 <lambdabot> forall a. [a]
22:58:00 <dons> ?type (:)
22:58:01 <lambdabot> forall a. a -> [a] -> [a]
22:58:04 <dons> ?type (:) 'x'
22:58:06 <lambdabot> [Char] -> [Char]
22:58:12 <dons> ?type (:) 'x' "more"
22:58:13 <lambdabot> [Char]
22:58:28 <dons> ?kind [] -- list type constructor
22:58:29 <lambdabot> * -> *
22:58:39 <dons> ?kind [] Char
22:58:40 <lambdabot> *
22:58:56 <dons> (remember that [] on the type level is the list type, and [] on the value level is the empty list)
22:59:08 <dons> ?type [] -- the empty list value
22:59:10 <lambdabot> forall a. [a]
22:59:19 <dons> ?kind [] -- the list _type_ constructor
22:59:20 <lambdabot> * -> *
22:59:46 <dons> (this is like having data Q a = Q a a, where Q is both a value and type constructor
23:00:30 <tieTYT2> oh
23:00:42 <dons> did I confuse you, or is that ok?
23:00:52 <tieTYT2> little bit of both
23:01:04 <tieTYT2> it sounds like something where tomorrow i'll say, "I get what he was saying"
23:01:07 <dons> so values have types. types classify values
23:01:08 <tieTYT2> but i haven't been introduced :k yet
23:01:09 <edwardk>  kinds are a little tricky to get your head around at first. think of them at types of types.
23:01:15 <dons> and types have kinds, kinds classify types
23:01:44 <dons> then, in haskell, the same syntax can be used on the type and value level, which is somewhat confusing (as you found with Quadruple)
23:02:28 <dons> so you could write a list as: data [] a = [] | a : [a]
23:02:45 <dons> where the first [] is a type constructor of kind * -> * (it takes a single type 'a')
23:02:54 <dons> and the second is a constructor for empty lists, []
23:03:14 <dons> like, data Q a = Q | R a (Q a)
23:03:42 <dons> where the first Q is a type with kind * -> *, and the second is a value, Q
23:04:03 <dons> i'll stop now
23:04:10 <ValarQ> hello dons
23:04:32 <dons> hey ValarQ
23:05:27 <tieTYT2> hehe ok
23:05:41 <tieTYT2> i think when i read 4 more sections of the tutorial i'll be able to understand everything you're saying
23:05:59 <dons> ok. but feel free to ask questions :)
23:06:14 <tieTYT2> thanks :)
23:06:20 <tieTYT2> i haven't been holding back
23:06:23 <tieTYT2> but you guys are really helpful
23:06:26 <dons> our mission statement is to have every programmer understand the distinction between types and kinds :)
23:07:05 <ValarQ> welcome mr Welcome
23:26:40 <dons> ?users
23:26:42 <lambdabot> Maximum users seen in #haskell: 235, currently: 199 (84.7%), active: 17 (7.2%)
23:32:56 <lokadin> say can i make a multi lined string into a 2 dimensional array
23:33:24 <lokadin> er well actually i just need to seek line and column
23:33:36 <lokadin> what would be the easiest way of doing that?
23:34:19 <dons> break it into lines, create an array with each line, then create an array with the result?
23:34:32 <dons> or, just create an array of bytestrings from each line?
23:34:56 <tieTYT2> is there a web framework for haskell?
23:35:10 <lokadin> sounds soo complex, maybe i could write it to a file and use some kind of seek command?
23:35:53 <dons> B.getContents >>= \n -> let ls = lines n ; m = length ls in listArray (0,m-1) ls :: Array Int ByteString
23:36:08 <dons> tieTYT2: a few, check out haskell.org under 'libraries and tools'
23:37:11 <lokadin> and B would be the initial lines?
23:37:12 <tieTYT2> ok thanks
23:37:38 <dons> B.getContents is the Data.ByteString.getContents function
23:37:48 <dons> maybe you only want normal getContents though
23:38:21 <lokadin> i just want it to be simple and easy to use thats all :)
23:43:27 <lokadin> er how do i make it accept input from a pipe?
23:43:35 <lokadin> it's not getArgs?
23:44:23 <dons> getContents
23:44:30 <dons> you want to read from stdin?
23:44:55 <lokadin> oh is that where a '|' throws the input?
23:45:18 <lokadin> kk
23:45:20 <lokadin> i'll try that
23:46:34 <lokadin> yay!!!
23:46:34 <lokadin> :)
23:46:39 <lokadin> it worked
23:46:47 <lokadin> learn something new everyday
23:46:57 <lokadin> er more like every hour
23:49:34 <lokadin> so what's the type if it's just a normal getContents? or should i just use ByteString
23:52:59 <dons> ?type getContents
23:53:00 <lambdabot> IO String
23:53:06 <dons> ?type Data.ByteString.getContents
23:53:07 <lambdabot> IO Data.ByteString.Base.ByteString
23:53:20 <dons> don't use ByteString unless you have some special reason though
23:53:34 <dons> (i.e. speed is an issue)
23:54:07 <lokadin> oh okay, well it isn't atm, and if i need to optimize it in a year, i'm sure i wont mind
23:54:16 <lokadin> thanks though for replying :)
23:54:50 <lokadin> i got it to work as a ByteString (as in compiling)
23:55:52 <lokadin> but i guess i'll turn it back to normal but the Type
23:55:55 <lokadin> don't worry about it
23:55:58 <lokadin> i'll figure it out
23:56:12 <lokadin> not that your worried
23:58:59 <dons> :)
