00:00:04 <edwardk> is anyone here planning on attending the ICFP?
00:02:01 <Tela> bdash: I don't see binaries, but it looks like some people are getting successful builds off the CVS. I'll try.
00:08:21 <sslow_> Hi, I have a question about ByteString lazy. Using readFile and then in a
00:08:22 <sslow_> do, processing the text two times for example using elemIndices seems to 'break' the laziness.
00:08:22 <sslow_> The memory usage in my case gets close to 1G. Is this expected?
00:12:05 <basti_> how long is the file?
00:12:13 <dons> its possible you're retaining the bytestring somehow, meaning the garbage collector can't throw away the processed part of the stream
00:12:27 <basti_> I'd agree with dons there yes
00:12:28 <dons> or possibly its an inefficient version of elemIndices
00:12:40 <dons> which fps are you using?
00:13:38 <dons> (recently we found a couple of laziness bugs in 0.7, so its possible that's the problem)
00:13:44 <dons> though not in elemIndices
00:14:09 <dons> let me merge those patches into the darcs repo
00:14:20 <sslow_> hi, sorry for the delay, i am using fps-0.8
00:14:30 <sslow_> the file is 1G
00:14:40 <basti_> ok
00:14:45 <basti_> fits huh
00:14:45 <basti_> ^^
00:15:07 <dons> let me just push a patch, and you can try that.
00:15:26 <sslow_> retaining the bytestring shouldn't be the problem, because if i use a second readFile the memory usage is normal
00:15:31 <sslow_> sure
00:22:03 <dons> ok. just pushed a patch to the fps repo
00:22:25 <dons> it fixes not-lazy-enough issues in a few functions (though not elemIndices)
00:22:34 <dons> if that doesn't fix your problem, you might have to post the code, or at least profile to work out where the cost is
00:22:46 <dons> and then we can work out if its elemIndices being bad, or something else
00:23:00 <sslow_> sure, let me try it
00:25:44 <Tela> Hm. I got a macintel native GHC 6.5 and now lambdabot complains about a poorly versioned fps (FastPackedStrings?) should this happen? (I didn't use CVS but instead grabbed a specific build)
00:26:01 <dons> you need a newer fps
00:26:07 <dons> try 0.7 from the website
00:26:09 <dons> oh, hmm. ghc 6.5
00:26:19 <dons> grr
00:26:19 <dons> yes, that's an old version of fps
00:26:23 <Tela> ok
00:26:25 <dons> you need a newer ghc 6.5 snapshot :(
00:26:42 <dons> or else 6.4.1 with a newer cabal
00:27:08 <Tela> haha.. Alright, I'll try to just use the CVS GHC and apply the couple hackeries myself
00:27:29 <Tela> er, CVS probably being Darcs :S
00:28:06 <dons> yeah, or grabbing a src snapshot (perhaps 2006-07-24 (its a good one))
00:28:23 <dons> and then applying whatever x86 tweaks you need for the mac
00:28:53 <dons> how do I do superscripts in latex, again?
00:28:58 <basti_> ^
00:29:01 <basti_> ^{abc}
00:29:03 <dons> ^{x}
00:29:03 <dons> yeah
00:29:07 <dons> cheers
00:29:11 <basti_> for one letter you can spare the {}
00:29:39 <dons> and negative space?
00:29:49 <basti_> \hspace{-2mm} eg
00:29:53 <basti_> there's a few shorthands
00:29:56 <dons> something like \; ?
00:30:08 <basti_> I never bothered to learn those by heart ^^
00:30:18 <basti_> are you trying to set something "on top" of something else?
00:30:28 <dons> no, trying to write ~1 nicely
00:30:45 <dons> ^\backsim\hspace{-1mm}1
00:31:14 <basti_> hmm you mean 1 with ~ overlaid?
00:31:17 <dons> yep. that works (well, -0.5mm)
00:31:21 <dons> nope
00:31:56 <dons> in front of
00:31:56 <dons> i.e. ~1 literally
00:31:59 <dons> problem fixed now.
00:32:05 <dons> ?karma+ basti -- latex help
00:32:06 <basti_> okay ^^
00:32:09 <basti_> :D
00:32:22 <dons> ?bot where are you in canada?
00:32:32 <tibbe> latex help?
00:32:50 <basti_> latex help starts when commands contain @
00:32:50 <dons> yep
00:33:14 <dons> heh
00:34:19 <edwardk> you know you've been starting at CT stuff too long when commands reads as comonads on first glance. =/
00:34:43 <basti_> lol
00:35:30 <edwardk> and then you try to think of comonads as commands, dual to the view of monads as actions,  to justify the problem.
00:36:50 <joelr1> good morning
00:37:02 <joelr1> is it valid to import two different packages under the same prefix?
00:37:14 <basti_> try? ^^
00:37:21 <dons> same prefix?
00:37:30 <joelr1> that is import a.b.c.d as A and then import foo.bar.baz as A
00:37:40 <dons> yes, I suspect so
00:37:43 <joelr1> aha
00:37:46 <dons> I'd be surprised if it didn't work
00:37:47 <joelr1> then another question
00:38:12 <joelr1> i'm rebuilding ghc from scratch, right
00:38:28 <joelr1> but compiler/ depends on libraries/template-haskell
00:38:44 <joelr1> meaning that ./libraries/template-haskell/Language/Haskell/TH/Syntax.hs has pkgString
00:39:04 <joelr1> but I don't think this gets rebuilt before building compiler/hsSyn/Convert.lhs
00:39:08 <joelr1> how do i work around this?
00:40:16 <Tela> ugh. Ok. Now I'm running into problems with Happy. This thing just does not want to build. Anyone know if Happy is workable on macintel?
00:40:29 <joelr1> Tela: i think so
00:41:03 <joelr1> Darwin junior.local 8.7.1 Darwin Kernel Version 8.7.1: Wed Jun  7 16:19:56 PDT 2006; root:xnu-792.9.72.obj~2/RELEASE_I386 i386 i386
00:41:12 <joelr1> happy -v
00:41:12 <joelr1> Happy Version 1.15 Copyright (c) 1993-1996 Andy Gill, Simon Marlow (c) 1997-2005 Simon Marlow
00:41:18 <Tela> configure complains about the architecture immediately.
00:41:27 <Tela> Hmm..
00:41:34 <Tela> good to know : )
00:41:35 <joelr1> Tela: beats me. don't remember how i built it
00:42:00 <Tela> hehe - the hope of a success is good enough. Thanks :)
00:43:44 <joelr1> dons: any clues?
00:46:04 <Tela> ("Unrecognised platform: i686-apple-darwin8.7.1")
00:46:23 <Lemmih> joelr1: I'd be interested in any workaround you find.
00:46:34 <joelr1> Lemmih: i don't see any
00:46:48 <joelr1> short of someone supplying me with a freshly built mac intel ghc
00:46:57 <joelr1> Lemmih: but since you said yesterday this applies to you...
00:47:43 <joelr1> Lemmih: hmm... I really don't know, seems like everyone but Simon would be in the same bind
00:48:23 <joelr1> Lemmih: maybe soft-linking ghc-inplace and rebuilding the libraries first?
00:49:44 <joelr1> Control/Applicative.hs:1:0:
00:49:44 <joelr1>     conflict: module `Control.Applicative'
00:49:44 <joelr1>     belongs to the current program/library and also to package base-1.0
00:50:44 <joelr1> how do i disable --package base-1.0?
00:51:36 <joelr1> i soft-linked `which ghc` to compiler/ghc-inplace temporarily
00:52:07 <joelr1> i guess i need to make it a shell script that gives ghc proper arguments to prevent it from looking in the packages when rebuilding libraries
00:52:19 <joelr1> don't know the proper set of switches, though
00:54:11 <Lemmih> How about undoing whatever Simon did?
00:54:21 <joelr1> undoing?
00:54:27 <joelr1> i wouldn't even know where to start
00:54:36 <joelr1> Lemmih: you mean unrolling patches to Convert.lhs?
00:54:57 <joelr1> i wish there was a way to unroll patches to a given file
00:55:16 <joelr1> let me try by checking the patches to the file and unrolling one by one
00:56:19 <Lemmih> joelr1: You could inline TH.pkgString.
00:56:32 <joelr1> Lemmih: what do you mean?
00:57:12 <Lemmih> joelr1: TH.pkgString = unpackPS
00:57:29 <joelr1> Lemmih: let me unroll the patches first
00:57:48 <joelr1> Lemmih: or is the above all i need?
00:58:28 <lispy> joelr1: how goes the code?
00:58:35 <Lemmih> I don't know.
00:58:51 <joelr1> Lemmih: can i just say  where TH.pkgString = unpackPS at the point where it's used?
00:58:56 <joelr1> lispy: high
00:59:01 <joelr1> lispy: err, hi!
00:59:04 <lispy> heh
00:59:07 <Lemmih> joelr1: I haven't tried it.
00:59:08 <lispy> jorhi
00:59:13 <lispy> er joelr1: hi
01:02:49 <joelr1> Lemmih: inlining helps
01:02:57 <joelr1> Lemmih: although it leads to another error
01:03:08 <joelr1> hsSyn/Convert.lhs:574:23:
01:03:08 <joelr1>     Constructor `NameG' should have 2 arguments, but has been given 3
01:08:05 <joelr1> Lemmih: inlining sort of solves it
01:18:57 <dons> ?pl \x -> p x && q x
01:19:19 <dons> liftM2 (&&) p q
01:26:35 <ski> ?pl \f -> let x = f x in x
01:26:58 <ski> bah, mbot gone, too
01:27:58 <dons> i'll bring back lambdabot
01:28:24 <ski> power back ?
01:28:27 <dons> yep
01:28:30 <dons> and ip quota
01:28:35 <ski> ok
01:30:15 <joelr1> what's the difference between mbot and lambdabot?
01:30:51 <dons> mbot is a backup lambdabot, it also has a mathematica plugin
01:31:05 <dons> it is maintained by Cale, and runs in #math and #engineering amongst other places
01:31:30 <dons> whereas lambdabot runs in #haskell* and #perl6
01:32:13 <joelr1> how do I map smEf_ret back to a Haskell symbol?
01:32:13 <mnislaih> Lemmih: How did it go ? Did you build the debugger ?
01:32:40 <dons> ?version
01:32:41 <mbot> lambdabot 4p70, GHC 6.4.1 (Linux i686 2.40GHz)
01:32:41 <mbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
01:32:52 <ValarQ> lambdabot: welcome back
01:33:01 <ski> @hello
01:33:01 <mbot> Maybe you meant: help tell
01:33:08 <lambdabot> lambdabot 4p72, GHC 6.5.20060724 (Linux i686 2.66GHz)
01:33:10 <lambdabot> darcs get /tmp_amd/eno/import/1/chakcvs/darcs/lambdabot
01:33:12 <lambdabot> Title: Index of /~dons/lambdabot
01:33:12 <dons> mbot: @part #haskell
01:33:20 <lambdabot> Maybe you meant: help hylo tell
01:34:11 <Cale> > foldr (+) 0 [1..100]
01:34:12 <lambdabot>  fd:8: hClose: resource vanished (Broken pipe)
01:34:20 <Cale> hmm
01:34:26 <Cale> @yow
01:34:26 <lambdabot> Couldn't find fortune file
01:34:29 * dons thinks
01:34:36 <dons> (yes, my normal machine is still down :)
01:34:42 <dons> i'll have to go in to uni to turn it back on
01:34:50 <dons> but these things i can fix
01:35:24 <eivuokko> joelr1, re: ghc build issues.  Fwiw, your issue stems from using ghc 6.5 to compile ghc 6.5.  It appears that compiler sort of skips the stage1, and hence you get ghci and template-haskell enabled on stage1.  Unfortunately this requires that template-haskell package must have the same interface vs what compiler expects...well, for some reason that changed.
01:35:56 <joelr1> eivuokko: hi esa! you didn't get too much sleep today apparently :D
01:36:09 <eivuokko> joelr1, Sleeping's overrated! ;)
01:36:16 <joelr1> eivuokko: as per Lemmih i inlined pkgString but check my latest error
01:36:23 <joelr1> mailed to ghc-users
01:36:28 <joelr1> this one i positively cannot figure out
01:36:34 <joelr1> not even where to start
01:36:57 <eivuokko> lol
01:37:02 <eivuokko> omg, like nightmare
01:37:50 <joelr1> eivuokko: what do you think?
01:38:06 <eivuokko> Codegen is broken?  Really, no idea.
01:40:04 <dons> > 1+2
01:40:05 <lambdabot>  user error (loadShared: couldn't load `librt.so' because /usr/lib/librt.so: ...
01:40:09 <dons> bah
01:41:29 <eivuokko> joelr1, You should probably run the failed command (manually) with  -keep-tmp-files and check those errors out.
01:41:58 <eivuokko> Maybe it's a foreign call with bad signature.
01:42:51 <Lemmih> mnislaih: Still building.
01:43:44 <joelr1> eivuokko: reset_terminal is not used properly
01:44:48 <lightstep> are nice's abstract interfaces the same as haskell's type classes?
01:45:03 <dons> hmm, I'd be surprised
01:45:07 <dons> they might be similar though
01:45:59 <mnislaih> talking about ghc: how does one tell make to force the update of the driver/package.conf.inplace file ?
01:46:54 <dons> touch package.conf.inplace.in ?
01:47:17 <dons> or package.conf.in -- whatever its called
01:47:20 <eivuokko> Yeah, it's not generated, is it?
01:47:26 <mnislaih> yes, it is generated
01:47:33 <dons> it is, from the .in file, iirc
01:48:12 <mnislaih> but touchin the .in file does not trigger the update
01:48:29 <mnislaih> wait, I tried make in the driver dir. I'll try at the top level
01:48:38 <dons> make clean in the driver?
01:49:13 <eivuokko> Well
01:49:26 <eivuokko> package.conf.inplace : echo "[]" > $@
01:49:42 <dons> yeah
01:49:52 <dons> > 1+2
01:49:54 <mnislaih> make is doing its thing, it worked
01:50:01 <lambdabot>  3
01:50:07 <dons> ?type map
01:50:08 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
01:50:15 <dons> ?hoogle map
01:50:15 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
01:50:16 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
01:50:16 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
01:50:19 <Cale> @yow
01:50:20 <lambdabot> Couldn't find fortune file
01:50:26 <dons> i'll need to find one
01:50:29 <dons> ?google lambdabot
01:50:31 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
01:50:31 <lambdabot> Title: lambdabot
01:50:43 <dons> ?version
01:50:44 <lambdabot> lambdabot 4p72, GHC 6.4.2 (Linux i686 2.80GHz)
01:50:44 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
01:50:55 <dons> hmm. did the GHz go up??
01:51:09 <dons> bizarre: lambdabot 4p72, GHC 6.5.20060724 (Linux i686 2.66GHz)
01:51:53 <dons> ah, I know
01:52:00 <dons> I built on a different machine
01:54:11 <dons> where do fortunes live on linux?
01:54:35 <Cale> /usr/share/games/fortune{,s}
01:55:04 <dons> found it
01:55:24 <dons> ?yow
01:55:24 <lambdabot> The SAME WAVE keeps coming in and COLLAPSING like a rayon MUU-MUU ...
01:55:29 <dons> that looks right
01:55:33 <dons> ?fortune
01:55:33 <lambdabot> It is ridiculous to call this an industry.  This is not.  This is rat eat
01:55:33 <lambdabot> rat, dog eat dog.  I'll kill 'em, and I'm going to kill 'em before they
01:55:33 <lambdabot> kill me.  You're talking about the American way of survival of the fittest.
01:55:33 <lambdabot> 		-- Ray Kroc, founder of McDonald's
01:56:06 <dons> ?uptime
01:56:06 <lambdabot> uptime: 6 minutes and 54 seconds
01:56:12 <dons> ?users
01:56:13 <lambdabot> Maximum users seen in #haskell: 192, currently: 192 (1.0%)
01:56:18 <joelr1> foreign import ccall unsafe "rl_reset_terminal"
01:56:18 <joelr1>   rl_reset_terminal :: Ptr CChar -> IO ()
01:56:18 <dons> heh
01:56:30 <joelr1> does this describe void rl_reset_terminal?
01:57:12 <dons> IO () == void, yes.
01:57:26 <joelr1> cause i still get "return value not ignored" errors
01:58:22 <joelr1> @paste
01:58:22 <lambdabot> http://paste.lisp.org/new/haskell
01:59:02 <dons> ?quit fixo
01:59:51 <dons> ?users
01:59:52 <lambdabot> Maximum users seen in #haskell: 193, currently: 193 (100.0%)
02:01:46 <joelr1> folks, any clues?
02:01:46 <joelr1> http://wagerlabs.com/foo.txt
02:01:56 <joelr1> lisppaste is broken for some reason
02:06:01 <dons> ?version
02:06:02 <lambdabot> lambdabot 4p72, GHC 6.4.2 (Linux i686 2.80GHz)
02:06:02 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
02:06:29 <eivuokko> joelr1, What does your system's manpages say about the function?  Then conditionally change the ffi import of cl_reset_terminal by using preprocessor.  Say it returns Int, change it to return IO CInt, instead of IO ().  Use #if defined(foo_HOSTOS) etc (I dunno what the foo is for you)
02:06:48 <joelr1> eivuokko: i just changed the return value to ()
02:06:58 <eivuokko> Ah, right.
02:07:01 <joelr1> eivuokko: the issue is that i don't know how to rebuild the hsc file automatically
02:07:13 <joelr1> eivuokko: so i did make clean in compiler and i'm now waiting to see what happens
02:07:19 <eivuokko> Ergh
02:07:29 <eivuokko> Just remove the generated files when you need.
02:07:31 <joelr1> eivuokko: there must be an easier way
02:07:51 <joelr1> eivuokko: i don't know where the result of Readline.hsc is
02:08:01 <joelr1> because it's not rebuilt automatically when i change the hsc file
02:08:07 <eivuokko> Hmh
02:08:17 <eivuokko> I so hate ghc' buildsystem
02:08:40 <dons> :)
02:08:47 <eivuokko> I dunno the answer, maybe it's under compiler/stage1
02:15:20 <eivuokko> What I don't get, is how you can disable that stage1 ghci and template-haskell except changing config.mk and lying about the already-installed compiler's version.
02:16:44 <eivuokko> Ok, enough of that...no point in spending whole day trying to understand makefiles and design in their use.
02:17:06 <dons> yeah, just struggle on with them for a couple more years :)
02:17:13 <dons> that's what we all do
02:18:22 <wilx> Heh, sounds like it could use rewrite of the build infrastructure :)
02:18:38 <eivuokko> Well, there's a lot worse.  Like gcc.
02:18:49 <wilx> :)
02:26:14 <joelr1_> .
02:26:32 <xerox> Dot.
02:26:37 <joelr1_> who am i?
02:26:47 <joelr1_> ok, joelr1_
02:26:50 <joelr1_> got it
02:27:16 <dons> ?pl f . g
02:27:16 <lambdabot> f . g
02:27:26 <dons> ?pl \f g -> f . g
02:27:26 <lambdabot> (.)
02:27:29 <dons> ah well
02:27:43 <edwardk> heya
02:27:45 <edwardk> shapr around?
02:27:57 <xerox> Is it a verb?
02:28:19 <eivuokko> @seen shapr
02:28:19 <lambdabot> I haven't seen shapr.
02:28:33 <edwardk> we have a lambdabot back!
02:28:38 <xerox> "I am shapring around."
02:28:44 <xerox> @arr!
02:28:44 <lambdabot> Arrr!
02:28:45 * edwardk hugs lamdabot
02:28:51 * xerox joins the hug
02:28:56 * edwardk missed lambdabot.
02:29:03 <edwardk> it wasn't the same with that nasty old mbot =)
02:29:14 <dons> hehe
02:29:32 <xerox> Cale nicely fixed some things tough :)
02:29:44 <dons> ?remember * edwardk hugs lamdabot * xerox joins the hug * edwardk missed lambdabot. it wasn't the same with that nasty old mbot =)
02:29:44 <lambdabot> Done.
02:32:10 <edwardk> heh, i have lambdabot on my trillian buddy list, so i can just double click from my desktop. i don't have mbot there ;)
02:40:26 <foxy> dons, I was worried for a while there... :)
02:40:42 <dons> boo :(
02:40:48 <dons> :)
02:40:51 <foxy> yay :D
02:41:32 <foxy> the problem with delayed coverage is that yelling has no effect
02:41:48 <dons> ah, but you can still try!
02:43:28 * edwardk wonders if anyone has heard anything about 'codependent type systems' other than shapr's jokes a year or 3 back? =)
02:44:03 * xerox shakes head
02:44:17 <edwardk> shucks
02:51:36 <xerox> ?ghc
02:51:36 <lambdabot>  A lazy (~) pattern connot bind existential type variables
02:51:50 <xerox> Who did know that!
02:59:58 <Stinger_> whats an existential type, sounds very philosophical
03:00:20 <sieni> xerox looks like an existential type, at le
03:00:28 <sieni> at least in the pictures
03:00:32 * xerox laughs
03:00:47 <sieni> that
03:00:54 * xerox is
03:01:24 <xerox> http://www.haskell.org/haskellwiki/Existential_type
03:01:26 <lambdabot> Title: Existential type - HaskellWiki
03:01:43 <tibbe> lambdabot!
03:01:48 <tibbe> @sing
03:01:50 <xerox> ?remember sieni xerox looks like an existential type, at least in the pictures
03:01:51 <lambdabot> parse error (possibly incorrect indentation)
03:01:51 <lambdabot> Done.
03:02:00 <xerox> haha, what do you want her to sing?
03:02:10 <tibbe> uhm
03:02:24 <tibbe> eh
03:02:26 <tibbe> dunno
03:02:32 <tibbe> something
03:02:45 <xerox> @arr
03:02:46 <lambdabot> Yo ho ho, and a bottle of rum!
03:02:50 <xerox> There you go.
03:02:54 <tibbe> perhaps she could freestyle some
03:02:57 <tibbe> :D
03:03:04 <xerox> @vixed Could you freestyle some?
03:03:04 <lambdabot> i'll hafta plead the fifth on that one.
03:05:21 <dons> rhymes!
03:05:48 <tennin> what is "universalist philosophy"?  Descartes, Leibniz and Kant?
03:06:07 <tennin> and is it dual to existentialism?
03:06:18 <dons> heh
03:06:19 <xerox> coexistentialism.
03:06:39 <sieni> I don't get any karma but lots of quotes ^_^
03:07:09 <xerox> @quote sieni
03:07:09 <lambdabot>  xerox looks like an existential type, at least in the pictures
03:07:11 <xerox> @quote sieni
03:07:12 <lambdabot>  xerox looks like an existential type, at least in the pictures
03:07:14 <xerox> Yuck :P
03:07:37 <sieni> I thought that lambadabot had a larger collection of my utterings'
03:07:43 <sieni> -'
03:07:47 <sieni> stupid pinky
03:07:54 <xerox> Cut it.
03:08:02 <dons> sieni: hmm. probably sitting on the turned-off machine
03:08:17 <dons> i'll resync the state on monday, when I go in and turn the machine back on
03:08:21 <sieni> dons: ^_^
03:08:33 <dons> ?brain
03:08:33 <lambdabot> I think so, Doctor. But are these really the legs of a show girl?
03:08:38 <sieni> dons: not that I miss them too much ^_^
03:08:42 <dons> :)
03:09:34 <xerox> Did you see, they are selling a site on eBay <http://cgi.ebay.com/ws/eBayISAPI.dll?ViewItem&item=120021374185>
03:10:14 <dons> hmm, US $49,999.99?
03:10:32 <xerox> They even got a bid, yep... weird.
03:12:25 <dons> hmm, so they're selling the software?
03:12:33 <dons> and the domain
03:12:49 <dons> maybe I should register lambdabot.com...
03:12:57 <xerox> haha
03:13:10 <xerox> You should!
03:13:19 <dons> yeah, now i think about it. hmm.
03:20:00 <tibbe> @users
03:20:01 <lambdabot> Maximum users seen in #haskell: 194, currently: 194 (100.0%)
03:21:05 <szymzet> I'm trying to one of the exercises from "yet another Haskell tutorial" and I have to create a datatype Tuple that can have 1 to 4 elements. I want to create a function tuple1 .. tuple4 which returns Maybe a, my definition of the function looks like this: tuple1 :: Tuple a b c d -> Maybe e
03:21:32 <szymzet> And I get an error
03:21:44 <tibbe> @paste
03:21:44 <lambdabot> http://paste.lisp.org/new/haskell
03:22:25 <xerox> szymzet: where does the e come from?
03:24:19 <szymzet> Aaa now I know... sorry for this mess. And BTW what's this "@paste" ?
03:24:28 <xerox> Check the url.
03:24:47 <xerox> Are you familiar with lambdabot's @commands ?
03:25:44 <dons> szymzet: meet lambdabot:
03:25:51 <dons> > map (+1) [1..10]
03:25:53 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
03:25:54 <dons> ?type map
03:25:56 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
03:25:59 <dons> ?kind Int
03:26:00 <lambdabot> *
03:26:01 <dons> ?hoogle map
03:26:02 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
03:26:02 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
03:26:02 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
03:26:06 <dons> ?docs Data.IntMap
03:26:07 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-IntMap.html
03:26:12 <dons> ?fptools Data.IntMap
03:26:13 <lambdabot> http://darcs.haskell.org/packages/base/Data/IntMap.hs
03:26:19 <dons> ?yow!
03:26:19 <lambdabot> Hello?  Enema Bondage?  I'm calling because I want to be happy, I guess ...
03:26:25 <xerox> That's a heavy load of informations =)
03:26:50 <dons> *cough*
03:27:29 <Stinger_> you cant have a return type thats dependent on the source types can you?
03:27:34 <xerox> dons - lambdabot.com could contain the so-wanted web interface....
03:27:40 <dons> yeah
03:28:07 <xerox> Stinger_: functions make type functionally dependent.
03:28:18 <dons> Stinger_: hmm. parametic-polymorphically?
03:28:27 <dons> ?djinn a -> b
03:28:28 <lambdabot> -- f cannot be realized.
03:28:35 <dons> ?hoogle a -> b
03:28:36 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
03:28:36 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
03:28:36 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
03:28:48 <xerox> Notice the class constraints there.
03:28:53 <dons> you can do it with bounded polymorphism, via a dictionary
03:29:02 <xerox> Ah, that's how it's called!
03:29:29 <Stinger_> in that case you would have it specified in the type signature?
03:29:46 <Stinger_> i.e. the dictionary mentioned in the sig somehow
03:29:50 <dons> essentially, C a => a -> b   --->   (C a b) -> a -> b
03:29:51 <xerox> Indeed.  By the class constraint.
03:30:11 <szymzet> l@listcommands
03:30:11 <szymzet> @listcommands
03:30:11 <lambdabot> Unknown command, try @list
03:30:12 <xerox> (C a b => a -> b)
03:30:41 <dons> oh, I was illustrating how the class constraint turns into an actual argument
03:30:48 <Stinger_> anyway essentially thats what szymzet was having problems with
03:30:52 <szymzet> @list
03:30:52 <lambdabot> list [module|command]. Where modules is one of:
03:30:52 <lambdabot> babel base compose dice dict djinn drhylo dummy elite eval fact fresh haddock help hoogle instances karma lambda localtime log more pl poll pretty quote search seen slap spell state system tell todo
03:30:52 <lambdabot> topic type unlambda url version vixen where
03:31:23 <xerox> Yes but you can have C a => ... -> a, and C a b => a -> ... -> b, but not C a => a -> ... -> b.  (Where ... are actual types.)
03:31:36 <xerox> (That's my understanding at least.)
03:39:10 <araujo> http://pleac.sourceforge.net/pleac_haskell/strings.html
03:39:49 <araujo> i am misunderstanding something ... or most of the code is bad?
03:41:26 <xerox> That certainly looks nasty
03:42:04 <xerox> ``In this document, you'll find an implementation of the Solutions of the Perl Cookbook in the Haskell language.''
03:43:24 <Stinger_> haskell can be a bit like perl in the sense that people type in this string of crazy crap and it does some massively complicated function
03:43:55 <florenz> hi
03:44:00 <Stinger_> at least from my perspective :)
03:44:31 <florenz> does someone know if ghci cannot handle static libraries (.a files) with the -l flag?
03:45:09 <araujo> Stinger_, that's almost true of any language
03:45:28 <Stinger_> perhaps I see more examples of it in perl and haskell
03:46:03 <araujo> i think Haskell avoids more abuse because of its clean string representation
03:46:25 <xerox> FSVO clean.  It is not the best for all the purposes.
03:46:57 <Pupeno> xerox: FSVO ?
03:47:03 <xerox> For Some Values Of.
03:50:51 * araujo finds Haskell strings easier to handle than practically any language he has tried
03:51:31 <Pupeno> araujo: no longer in #haskell-es ?
03:51:37 <dons> the recursive type makes correct, inductively-defind code easier
03:51:49 <dons> Pupeno: so #haskell-es is active?
03:52:04 <araujo> Even those languages claiming "everything is a string" make it more clumsy than Haskell
03:52:05 <dons> or is it #haskell.es?
03:52:07 <Pupeno> dons: not really, but I keep joining.
03:52:08 <araujo> Pupeno, hi!
03:52:15 <araujo> hah, it is #haskell.es
03:52:19 <dons> Pupeno: I think lambdabot's in #haskell.es
03:52:24 <Pupeno> oh! thanks.
03:52:24 <dons> ?seen lambdabot
03:52:25 <lambdabot> Yes, I'm here. I'm in #scannedinavian, #haskell.es, #haskell.se, #haskell.it, #oasis, #perl6, #darcs, #haskell_ru, #gentoo-haskell, #haskell-overflow, #flippi, #haskell-blah and #haskell
03:52:51 <xerox> #haskell.it had a peak of 6 users at some point! :D
03:53:02 <dons> cool :)
03:53:09 <araujo> we got 7 atm!
03:53:30 <Pupeno> counting lambdabot.
03:53:35 <araujo> haha
03:53:47 <joelr1> haskell.es > haskell.it
03:54:16 <Pupeno> araujo: make Chanserv join the channel and it'll be 8. Althour no real users, I believe it has a psicological weight and will make users stay a bit more.
03:54:31 <dons> that's a good idea
03:54:37 <araujo> haha .. nah ... lambdabot will be jealous then
03:54:37 <xerox> Do you know who's the author of whitespace, the programming language?
03:55:11 <dottedmag> xerox: e.c.brady@dur.ac.uk ?
03:55:16 <xerox> Our edwinb!!!
03:55:24 <Pupeno> On a userfriendly forum, there was a guy claming that after the "computer programming" teacher gave them a homework to do in any language, he've done it on whitespace.
03:55:26 * xerox laughs
03:55:46 <xerox> I talked with him a lot at AngloHaskell and I didn't know!
03:56:31 <ski> sure
03:56:52 <ski> ECHAN
04:03:02 <ski> m, have read a little about projective geometry
04:03:41 <mnislaih> Lemmih: the ordering of the payload elements of a Constr closure should always correspond to the associated Datacon arguments, or is it reversed in any architecture ?
04:45:51 <gaal> has anyone got 6.5 working on debian? it seems that the package 'ghc-cvs' is broken.
05:00:50 <xerox> gaal - That's right. You'd better use a snapshot I think.
05:01:26 <gaal> xerox: thanks.
05:01:57 <xerox> You're welcome.
05:08:17 <kpreid> dons?
05:11:02 <dons> yep
05:13:42 <kpreid> [23:37] <dons> are there anonymous functions in lojban?
05:13:59 <kpreid> depends on what you want to call a function, I think
05:14:41 <kpreid> but the obvious thing, ka/ce'u/ckaji, suffers from the fact that application allows precisely 1 item in the relation. I recently thought of just generalizing that, so, with the caveat that it's not official: yes.
05:16:07 <dons> oh, cool :)
05:16:36 <kpreid> "lo ckaji be lo ka ce'u sumji ce'u lipa bei lire" ~= "($) (\x -> x + 1) 2"
05:16:58 <dons> wow!
05:17:25 <kpreid> except, of course, that ka are relations, not functions, so it's more like Prolog than Haskell, but the sumti syntax lets you pull out the first place as 'result'
05:17:38 <dons> yeah
05:18:41 * xerox stares blankly
05:18:43 <kpreid> feel free to visit #lojban if you want more information than is vaguely on-topic here :)
05:31:30 <xerox> G'day int-e
05:32:24 <int-e> hello. I feel it
05:32:41 <int-e> 's morning but the sun outside calls me a liar.
05:59:46 <araujo> http://www.jelovic.com/articles/why_people_arent_using_haskell.htm
05:59:48 <lambdabot> Title: Why People Aren't Using Haskell
06:03:52 <vegai> some fair points there
06:04:22 <xerox> All that text could be enough to build one of those libraries he's asking for, in Haskell.
06:05:11 <vegai> but perhaps not quite as easy to write ;)
06:05:51 <araujo> The interesting thing is that i still fail to see the reason why people aren't using haskell ....
06:06:01 <vegai> my personal goal would to become skilled enough so I cuold "sell Haskell as a solution to your problems"
06:06:22 <dons> though hugs98? come on.
06:06:23 <vegai> well, math isn't sexy
06:06:29 <araujo> though whenever i read these kind of articles, i remember what uncle Dennis said ....
06:06:34 <dons> "And there is an air
06:06:34 <dons> of staleness: where new versions of these other languages appear frequently, the Haskell community is
06:06:37 <dons> offering you Hugs98.
06:06:37 <dons> doesn't seem valid
06:06:40 <vegai> and Haskell feels like math
06:06:40 <dons> "
06:06:42 <xerox> That's not true indeed.
06:06:54 <vegai> how old is that?
06:06:56 <araujo> 99% of the text doesn't seem valid at all....
06:07:18 <ValarQ> im not that happy with those everything-in-a-large-package ideas
06:07:29 <araujo> vegai, don't know ...
06:07:30 <dons> yeah, maybe this is quite old?
06:07:30 <ValarQ> the ghc package is pretty big as it is
06:07:31 * xerox looks at cabal-install
06:07:56 * xerox should finish hacking cabal-install instead of IRC =P
06:08:00 <dons> seems like we're actively chasing: a) libraries b) real world programs c) standardisation
06:08:13 <vegai> <meta name="GENERATOR" content="Microsoft FrontPage 5.0">
06:08:30 <vegai> (ok, that was below the belt)
06:08:35 <dons> heh
06:08:50 <dons> hugs98 doesn't mean it was written in 1998 either  :(
06:09:00 <dons> I mean, hugs comes with Data.ByteString...
06:09:01 <vegai> bad idea to criticize without telling the date. Things get old.
06:09:33 <xerox> Deface^H^H^H^H^H^HMail the guy.
06:09:38 <ValarQ> dons: 98 has to mean that the latest bugfix was applied 1998 :o)
06:09:47 <araujo> The sort of annoying thing is that it is one of the first results after a "haskell language" google search
06:09:48 <dons> heh
06:10:15 <dons> *shrug* there's a million bloggers out there. some say sensible things, some don't know what they're talking about
06:10:46 <dons> the response to this article seems fairly negative, looking at the google results.
06:11:01 * araujo was expecting more accurate bloggers as first results
06:11:01 <dons> I think its a 2001 article
06:11:11 <dons> judging by the dates of some of the responses
06:11:48 <dons> maybe its newer. there's some LtU hits from 2001 for the title
06:12:06 <dons> yeah, 2001
06:12:12 <dons> so who cares!? :)
06:12:20 <dons> there's been a lot happen in the last 5 years
06:12:50 * xerox nods
06:14:29 <ValarQ> some minor things...
06:15:53 <araujo> Even if it was written a decade ago, it still doesn't show any valid point imho.
06:16:43 <midfield> newbie question: can modules be spread out over multiple files?
06:16:54 <dons> midfield: nope
06:17:15 <dons> but modules can be mutually recursive (so you can partition the code any way you like)
06:17:49 <midfield> dons: thanks.  (that restriction is kind of weird, imho.)
06:18:04 <dons> that each file is its own module?
06:18:10 <xerox> Be sure to use GHC 6.5 or your head will explode like gaal's ;)
06:18:23 <dons> Better than each file has to be a class ;)
06:18:33 <midfield> dons: agreed, but similar.
06:18:34 <ValarQ> dons: sure is :)
06:18:37 <dons> how I love the land of verbs
06:18:48 * dcoutts likes to verb words
06:18:55 <dons> argh!
06:19:33 <dcoutts> ahem, actually, that's not true
06:19:50 <dcoutts> I just like the verb to verb
06:20:18 <dons> midfield: sometimes I suppose its annoying, you end up with Foo and FooUtils or Foo , Foo.Utils , Foo.MoreStuff
06:20:48 <dons> though you can always tie Foo.* together into a single Foo module via module exports..
06:20:53 <dcoutts> we need editors that can help us nativage large modules that are divided into subsections
06:21:12 <dcoutts> like a table of contents for chapters in a document
06:21:29 <dons> hmm. interesting.
06:21:37 <dcoutts> so you can easily jump to the right section
06:21:43 <madpickle> you guys seem to use <<= quite a lot; could somebody point me to a website that explains what it does?
06:21:49 <dons> >>= ?
06:21:54 <dcoutts> =<< ?
06:21:55 <dons> ?where YAHT
06:21:55 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
06:22:03 <dons> oh, wrong one.
06:22:09 <madpickle> 404
06:22:12 <xerox> Segfaults... yarr.
06:22:14 <xerox> The comonadic combinator? :)
06:22:26 <dons> ?where+ yaht http://www.cs.utah.edu/~hal/htut/
06:22:27 <lambdabot> Done.
06:22:39 * dcoutts prefers (=<<) it's more like (.) in it's order
06:22:45 <midfield> dons: mostly it's not annoying because haskell is so terse.  in say, java, having a whole package per file would be ludicrous
06:22:55 <madpickle> dons: thanks.
06:23:00 <Speck> morning all
06:23:33 <dons> yeah, I think its not too annoying, since you can create a module that exports a bunch of others, giving the appearence of a single module split over several files
06:23:41 <xerox> madpickle: if you think of a value of type (m a), where m is a monad, as a container of values of type a, then you can read the type of bind "(>>=) :: m a -> (a -> m b) -> m b" as: ``If I have a box of apples (m a), and for every apple you give me a box of blueberries (a -> m b), then I can put all of them in one box (m b)''.
06:23:54 <xerox> From: Monads As Containers, by Cale Gibbard.
06:24:05 <madpickle> hrm. interesting.
06:24:20 <basti_> the really interesting part is why we're doing that
06:24:30 <basti_> it keeps I/O in order, for example
06:24:55 <dons> rigorous taint checking :)
06:25:35 <xerox> madpickle - Now combine that with the (arbitrary) definition of monad, which is a container type m, along with two methods: return and bind.  Let's reason about them with other three equivalent menthods from which we can define bind later, that are easy to think about, for now.  They are map, join, and return.
06:26:16 <xerox> madpickle - map comes from the definition of functor. A functor is a container (f a) along with a method that enables us to apply a single function (a -> b) to every member of the container obtaining a container of new values (f b).
06:26:44 <madpickle> hrm.
06:26:44 <xerox> madpickle - join has the type m (m a) -> m a, it is the way you make a container of values out of a container of containers of values.
06:26:51 <madpickle> could i have a link to that paper?
06:27:05 <xerox> ?wiki MonadsAsContainers
06:27:05 <lambdabot> http://www.haskell.org/haskellwiki/MonadsAsContainers
06:27:09 <madpickle> thanks
06:27:20 <xerox> Hrrrrmmmpf.
06:27:24 <madpickle> doesn't appear to work
06:27:37 <dons> ?google monads as containers
06:27:40 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
06:27:40 <lambdabot> Title: MonadsAsContainers - The Haskell Wiki
06:27:42 <xerox> http://www.haskell.org/haskellwiki/Monads_as_Containers
06:27:43 <lambdabot> Title: Monads as Containers - HaskellWiki
06:27:47 <xerox> That's it.
06:27:50 <madpickle> thanks
06:27:54 <dons> ?oldwiki MonadsAsContainers
06:27:54 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
06:27:55 <xerox> Well, it does the explanation exacly as I was trying to do here.
06:28:10 <dons> xerox: some things are hard to teach over irc though
06:28:12 <madpickle> yeah, i just need examples to understand stuff like that
06:28:20 <madpickle> thanks for the effort, though, xerox.
06:28:21 <basti_> madpickle: the jump from boxes of apples to I/O is a little abstract.
06:28:31 <xerox> I was just going too fast, sorry.
06:28:35 <madpickle> nah, it's ok.
06:28:43 <madpickle> i'm just a hands-on person
06:28:43 <dons> better than monads as unicycles though
06:28:48 <madpickle> lol
06:29:20 <dons> why aren't unicycles called monad-a-cycles?
06:29:23 <dons> they could have been
06:29:41 <dons> "I'm just off to uni on my monadacycle", you'd say
06:31:40 <florenz> can anyone answer me a simple question concerning HUnit?
06:32:13 <dons> not sure. ask and we'll see :)
06:32:47 <florenz> if i issue runTestTT (5 ~|= 6) in ghci i get `Cases: 1  Tried: 1  Errors: 1  Failures: 0' but it should be 1 failure instead of 1 error, shouldn't it?
06:33:09 <dons> possibly it threw an exception?
06:33:15 <dons> isn't that what 'Error' is?
06:33:29 <dons> ?hoogle ~|=
06:33:33 <lambdabot> No matches found
06:33:51 <florenz> yes, ?= calls assertFailure sometime which throws an exception
06:34:11 <florenz> or do i just mix up the meaning of failure and error?
06:34:25 <florenz> ?hoogle ~?=
06:34:26 <lambdabot> Test.HUnit.Base.(~?=) :: (Eq a, Show a) => a -> a -> Test
06:34:44 <dons> oh, possibly
06:34:53 <dons> ?source Test.HUnit.Base
06:34:54 <lambdabot> lambdabot 4p72, GHC 6.4.2 (Linux i686 2.80GHz)
06:34:54 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
06:34:57 <dons> ?fptools Test.HUnit.Base
06:34:58 <lambdabot> http://darcs.haskell.org/packages/HUnit/Test/HUnit/Base.hs
06:38:37 <dons> possibly if you're doing pure code testing, you might want to try QuickCheck instead
06:38:50 <dons> its better for pure code. HUnit's good for IO stuff though
06:39:19 <dons> (QuickCheck is like HUnit, but it generates the test data for you)
06:41:23 <florenz> yes, i know QuickCheck, but I actually have to test lots of I/O, so i took HUnit
06:41:26 <szymzet> Do you know any tutorials on 2D graphics  libraries for haskell (for example hsSDL) ?
06:41:45 <florenz> and the above runTestTT example was just to look how it works
07:41:22 <esap> In category theory, what justifies the use of the notation f(x) for f . x?
07:44:01 <basti_> uhm
07:44:05 <esap> It's clear it works when x : 1 -> A, but in other cases I don't see any connection.
07:44:51 <astrolabe> I'm not familiar with those notations.  What do they mean here?
07:45:09 <esap> f . x is just the composition of f and x.
07:45:18 <esap> and f(x) is the application of f to argument x
07:45:40 <esap> Many category theory papers just assume those are the same.
07:45:41 <astrolabe> Well, strictly, they are different things then.
07:45:45 <basti_> i think, any x is isomorphous to a morphism 1->A ?
07:46:00 <basti_> thus you don't need to care?
07:47:31 <astrolabe> Maybe they are just using f( ) as the name of the function x |-> f.x
07:48:13 <basti_> yes I'd assume that's the semantics.
07:48:21 <esap> could be. Or it's some kind of generalization from the case where x : 1 -> A [e.g. using generalized elements]. But to me it seems strange.
07:48:37 <basti_> do you see any problems?
07:48:52 <esap> Yes, there are problems.
07:48:59 <basti_> like...? o.0
07:49:37 <esap> For example, from f(x), it's clear that f is a function (~arrow) and x is a value. But for f . x, both f and x are arrows.
07:50:13 <esap> So with the notation f(x), you think of f and x as different kinds of entities.
07:50:25 <esap> with the composition, they are clearly considered as alike.
07:50:38 <basti_> hmm
07:50:44 <astrolabe> That is quite common though.
07:50:45 <basti_> so is that a problem, when x could be a function from 1?
07:51:25 <astrolabe> To forget irrelevent structure while considering a particular problem
07:51:36 <basti_> yea ok maybe
07:51:50 <esap> basti: no, not just that. Then you also have to consider that with exponentials, there is  apply . <f,x>
07:52:06 <basti_> so?
07:52:15 <esap> which you could also denote with f(x).
07:52:22 <esap> because that's clearly function application.
07:52:30 <basti_> hmm.
07:52:41 * basti_ fears he isnt all that good in CT
07:52:49 <esap> so the different concepts seem to be very confused there.
07:53:31 <basti_> ok.
07:53:32 <basti_> ^^
07:53:47 <basti_> say ppl... when monads are (something like) the CT representation of monoids... what kind of programming structure would correspond to, say, a group?!
07:55:40 <basti_> "programs that can be reordered and undone"?
07:56:31 <esap> class Group g where { mult :: g -> g -> g ; identity :: g }
07:57:07 <basti_> hmm no i mean: there is a CT representation for groups
07:57:17 <basti_> stating the axioms of groups
08:00:20 <esap> I'm not sure
08:00:30 <basti_> not?
08:00:40 <basti_> ^^
08:00:45 <basti_> i thought so...
08:00:47 <esap> I mean, you do need to represent all the axioms
08:00:52 <basti_> yes
08:01:01 <basti_> it'd be a pretty harsh thing to do
08:01:02 <esap> in some way as transformation rules
08:01:03 <basti_> generally
08:01:15 <basti_> hmmm?
08:01:40 <esap> for example, associativity corresponds to commutativity of some diagrams in CT
08:01:50 <basti_> yea
08:01:51 <esap> but representing commutativity diagrams is hard
08:02:03 <basti_> hmm ok i see that point yes
08:02:20 * esap got to go to sauna. bbl.
08:02:23 <basti_> hF
08:03:20 <int-e> Monads aren't monoids though. A monoid in the CT sense is a category with a single object.
08:03:57 <basti_> yes that is true
08:04:16 <basti_> but, there is a relation
08:04:29 <basti_> same axioms, namely
08:04:42 <xerox> From `Sets for Mathematics': Definition 1.3: An *element* of a set A is any maping whose codomain is A and whose domain is 1.
08:04:59 <basti_> xerox: well-found ^^
08:06:16 <basti_> uhm, not all groups are abelian btw. so, a group would correspond to undoable programs
08:07:05 <basti_> (inverse)
08:07:38 <xerox> ``The first consequence of our definition is that: */element/ is a special case of mapping*. A second expression of the role of 1 is that */evaluation/ is a special case of composition.* In other words, if we consider any mapping f from A to B and then consider any element a of A, the codomain of a and the domain of f are the same; thus, we can form the composite f a, [skipping diagram of f a] which will be the mapping 1 -> B. But since the doma
08:08:16 <xerox> ``Which element is it? It can only be, and clearly is, the /value/ of f at a.  That is, if a is an element, f a = f(a).''
08:08:33 <xerox> There is also a third expression of the role of 1, want to see that too? Or am I spamming too much?
08:12:43 <xerox> (I thought esap had that book.)
08:34:42 <esap> xerox: I do have "Sets for mathematics"
08:34:58 <xerox> That explanation fails somehow?
08:35:35 <esap> xerox: it does work for the special case where x : 1 -> A.
08:35:48 <xerox> It is defined to be so.
08:36:16 <esap> xerox: but with general elements, e.g. where the domain of x is something else than 1.
08:36:34 <esap> xerox: I can't see any reason why that equality would work
08:36:50 <theHat> hi, i started with haskell today, while reading a text from http://www.cs.utah.edu/~hal/ and using hugs i found that Char.toUpper or Char.isLower dont work :S
08:36:53 <xerox> It didn't introduce generalized elements yet I believe... I can't say.
08:37:24 <theHat> i restarted hugs with -98 parameter to load all the modules as i read, but still dont work
08:37:51 <esap> xerox: Another trouble occurs when you consider functions 'f' that are not referentially transparent.
08:38:18 <xerox> esap - Do you have non referentially transparent functions in Set ?
08:38:32 <esap> xerox: No. I'm thinking more general notion of categories
08:38:39 <esap> xerox: not only Set.
08:38:44 <xerox> I don't know yet, then. Sorry!
08:39:23 <Speck> theHat: they should work, care to elaborate on what you've done?
08:40:09 <theHat> Speck i am copy the examples from the book
08:40:41 <theHat> ex: map Char.toUp "great"
08:40:54 <theHat> ex: map Char.toUpper "great"
08:40:55 <theHat> sorry
08:40:57 <Speck> do you get an error?
08:41:15 <theHat> yes
08:41:53 <theHat> ERROR - Undefined qualified variable "Char.toUpper"
08:42:45 <Speck> perhaps the Char module isn't imported/visible to Hugs
08:43:00 <theHat> maybe
08:46:36 <astrolabe> theHat: What does the hugs promt look like?
08:46:57 <astrolabe> prompt
08:47:25 <pejo> theHat, my hugs has it directly in the prelude, just "toUpper 'u'" works.
08:47:39 <Stinger_> was looking for this the other day is there a power operator that takes a fractional exponent?
08:48:17 <kpreid> Stinger_: **
08:48:45 <Speck> astrolabe: remember me? you helped me with symbolic logic homework a while ago -- I got an A+!
08:48:56 <Stinger_> bah I shoulda guessed that :(
08:49:07 <Stinger_> only found ^ and ^^
08:49:39 <astrolabe> Oh yeah.  Hi speck!  That's wonderful!
08:49:55 <astrolabe> I didn't know I knew symbolic logic :)
08:50:41 <astrolabe> my Hugs can't see toUpper in the prelude
08:50:44 <Speck> I guess it was pretty generic stuff I needed help with though, my first class in logic was 400 level
08:51:04 <astrolabe> Have you finished the course now?
08:51:25 <Speck> yeah a while ago but I've been off the radar until today
08:52:04 <astrolabe> How did you do it in overall?
08:52:33 <pejo> astrolabe, (mine is old)
08:52:43 <Speck> A+! :-D
08:53:19 <astrolabe> Ah.  I thought you had a good attitude.
08:53:26 <Pupeno> is there a function that runs all functions in a list (no parameters, or all the same parameters)
08:53:53 <kpreid> Pupeno: map ($ x) fs
08:54:55 <xerox> swing map ?
08:54:58 <astrolabe> @djinn a -> [a ->b] -> [b]
08:55:02 <lambdabot> -- f cannot be realized.
08:55:06 <astrolabe> boo
08:55:19 <xerox> ?type let swing f c a = f ($ c) a in swing map
08:55:24 <lambdabot> forall a b. a -> [a -> b] -> [b]
08:55:26 <xerox> astrolabe: [a -> b] ?!?!
08:55:37 <xerox> Ah, ooops, nevermind.
08:55:43 <astrolabe> heh
08:55:49 <xerox> I thought you were talking about compose.
08:55:57 <xerox> (OK, that's it, anyway.)
08:56:19 <astrolabe> swing makes my head hurt
08:56:27 <kpreid> I've never seen djinn given an answer for lists
08:56:44 <xerox> kpreid: indeed, it can't handle recursive types.
08:57:04 <astrolabe> xerox: if you do too much of that stuff (including arrows) you will go blind!
08:57:26 <xerox> @arrr
08:57:26 <lambdabot> Yeh scurvy dog...
08:57:38 <astrolabe> fair
08:58:40 <kpreid> @djinn-add data L a = L0 | L1 a | L2 a a | L3 a a a
08:58:46 <xerox> > let swing f c a = f ($ c) a in swing all [even,(>0)] [2,4,8]
08:58:51 <lambdabot>  add an instance declaration for (Num ([a -> Bool] -> Bool))
08:58:51 <lambdabot>   In the list...
08:59:01 <kpreid> @djinn a -> L (a -> b) -> L b
08:59:01 <lambdabot> f a b =
08:59:02 <lambdabot>   case b of
08:59:02 <lambdabot>   L0 -> L0
08:59:02 <lambdabot>   L1 _ -> L0
08:59:02 <lambdabot>   L2 _ _ -> L0
08:59:05 <lambdabot>   L3 c d e -> L3 (e a) (d a) (c a)
08:59:12 <kpreid> ...
08:59:43 <xerox> Disappointment.
08:59:51 <kpreid> it may be right, but it's not sensible
09:00:22 <xerox> That's a draw back of the heuristics, I think.
09:03:07 <astrolabe> @where idioms
09:03:07 <lambdabot> I know nothing about idioms.
09:03:56 <astrolabe> @where+ idioms http://haskell.org/hawiki/CommonHaskellIdioms
09:03:57 <lambdabot> Done.
09:04:20 <xerox> There also is CategoryIdioms
09:04:45 <xerox> http://haskell.org/haskellwiki/Category:Idioms
09:04:46 <lambdabot> Title: Category:Idioms - HaskellWiki
09:06:09 <astrolabe> hmmm.  I guess you can't squeeze more than one link in.
09:06:47 <xerox> Let's try!
09:07:09 <xerox> @where+ idioms http://haskell.org/hawiki/CommonHaskellIdioms http://haskell.org/haskellwiki/Category:Idioms
09:07:10 <lambdabot> Done.
09:07:13 <xerox> @where idioms
09:07:14 <lambdabot> http://haskell.org/hawiki/CommonHaskellIdioms http://haskell.org/haskellwiki/Category:Idioms
09:07:21 <astrolabe> :D
09:07:31 <xerox> Maybe... define @where++ :)
09:07:58 <xerox> (Just to increase the lambdabot darcs-graph, if not else.)
09:08:45 <xerox> Poll: what packages do you most want to appear in the cabal-install repository of Haskell packages?
09:10:07 * mnislaih votes for Hood 
09:10:23 <xerox> What is Hood?
09:10:27 <mnislaih> oh, Hood will need to be cabalised first
09:10:36 <mnislaih> @where Hood
09:10:36 <lambdabot> I know nothing about hood.
09:10:44 <mnislaih> www.haskell.org/hood
09:10:45 <xerox> I am mostly interested in little-and-simple-but-tedious-to-install-by-hand packages.
09:10:50 <xerox> At least in this very moment.
09:11:42 <mnislaih> fps, MissingH, Edison
09:12:10 <xerox> I am not sure about MissingH, is there any software that depends on it? What is Edison?
09:12:30 <mnislaih> Edison is a collections library
09:12:35 <mnislaih> @Edison
09:12:36 <lambdabot> Unknown command, try @list
09:12:39 <mnislaih> @where Edison
09:12:40 <lambdabot> I know nothing about edison.
09:12:49 <Igloo> xerox: I most want the uploading tool to exist so I can upload my packages
09:13:11 <xerox> Igloo: given the current policy, you have to have access to monk to upload them.
09:13:18 <xerox> Igloo: and it is just matter of scp-ing them!
09:13:34 <Igloo> xerox: There's no index any more?
09:13:50 <xerox> The index is just a tar file of all the cabal files :)
09:14:27 <Igloo> How does that get updated then? Just a cron job every n minutes?
09:15:15 <xerox> There is no public repository yet, but we ought to think about it soon.  Now I made this call because I want to make one to give people the possibility to try cabal-install.
09:16:31 <xerox> I'll also mail in the dependencies-cleansing patch today.
09:31:13 <Speck> la la la
09:31:52 <basti_> L
09:31:53 <basti_> A
09:33:31 <Speck> read any interesting papers recently?
09:34:26 <basti_> hmm one from LtU about how attribute grammars relate to monads, arrows and comonads
09:36:35 <ookk> is there any straightforward tutorial of monads?
09:36:35 <Speck> yea I tried to wrap my head around some of those comonad papers without a lot of success
09:36:55 <ookk> with realworld examples
09:37:02 <basti_> hmm
09:37:12 <Speck> the nomaware tutorial is good I think
09:37:29 <basti_> as for applications: try the "rotating cube in opengl" stuff
09:37:33 <xerox> ?wiki Monads_As_Containers
09:37:33 <lambdabot> http://www.haskell.org/haskellwiki/Monads_As_Containers
09:37:37 <xerox> Check it out, ookk!
09:37:50 <ookk> ill do that, thx
09:37:59 <ookk> hmm empty
09:38:08 <xerox> Uffff.
09:38:16 <xerox> ?google Monads as Containers site:haskell.org
09:38:18 <lambdabot> http://www.haskell.org/hawiki/MonadsAsContainers
09:38:18 <lambdabot> Title: MonadsAsContainers - The Haskell Wiki
09:38:25 <xerox> ?google Monads as Containers site:haskell.org/haskellwiki/
09:38:28 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_Containers
09:38:28 <lambdabot> Title: Monads as Containers - HaskellWiki
09:38:31 <ookk> ahh that was better :)
09:38:33 <xerox> That's it.
09:38:37 <xerox> (New wiki url.)
09:38:51 <xerox> Let's see if that other command works...
09:38:55 <xerox> ?gwiki monads as containers
09:38:56 <lambdabot> No Result Found.
09:39:01 <xerox> Wah.
09:39:31 <Speck> has there been any recent hIDE activity?
09:40:28 <xerox> If you count `asking if there has been any recent hIDE activity' hIDE activity, there's been quite a lot!  <chuckles>
09:42:16 <Speck> haha
09:43:12 <mnislaih> ?google you could have invented monads
09:43:15 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
09:43:15 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
09:44:48 <midfield> anyone here used NewBinary?  anyone have docs?  haddock keeps failing...
09:48:24 <Pupeno> how would you call a function that gets a list of functions and returns a function that runs each function in the list ?
09:49:14 <kpreid> @pl \l x -> map ($ x) l
09:49:14 <lambdabot> flip (map . flip id)
09:49:52 <xerox> ?oldwiki LicensedPreludeExt
09:49:52 <lambdabot> http://www.haskell.org/hawiki/LicensedPreludeExt
09:50:00 <xerox> Append a 's'
09:50:14 <xerox> I saw swing defined there, and seems working, if you are willing to do that...
09:50:14 <araujo> 9 on #haskell.es!
09:50:24 <araujo> :-)
09:50:25 <kpreid> Pupeno: "run a function" doesn't make a whole lot of sense
09:50:44 <kpreid> Pupeno: you have to have some argument, or it isn't a function
09:50:47 <Speck> Pupeno: in parallel or serially
09:50:51 <Pupeno> kpreid: evaluate a function ?
09:51:15 <Pupeno> Speck: serially, but that's not important.
09:51:20 <kpreid> Pupeno: functions can only be /applied/, and they have to be applied to something. what are you applying them to?
09:52:55 <xerox> Pupeno: swing!
09:53:14 <Pupeno> kpreid: oic, nevermind.
10:03:44 <midfield> nevermind, Data.ByteStream and Data.Word.Word8 will save my day.
10:10:42 <cm> hi
10:11:02 <Korollary> boom
10:35:28 <kowey> theory: one reason people find Haskell hard to read is because some Haskellers use very short variable names
10:35:36 <kowey> uh... hypothesis
10:36:17 <lispy> there is also the blanket theory that code is much harder to read when you didn't write it (recently)
10:36:29 <kowey> hypothesis b: Haskellers use very short variable names, because pattern matching + layout discourage lengthy variables
10:36:34 <kowey> (because that would make lines very long)
10:36:36 <kowey> comments?
10:37:08 <ibid> kowey: haskellers use very short variable names because that's a good idea
10:37:40 <ibid> kowey: there is a rule of thumb that the length of a variable name is proportional to the length of its visibility scope
10:38:13 <ibid> kowey: which applies in imperative code too; it's just that imperative programmers tend to use longer scopes
10:38:35 <kowey> ibid: ahah! thanks for pointing that out... i sorta do that instinctively, but first time anybody's explicitly said it
10:39:07 <kowey> so the rule of thumb for people *reading* haskell code is that if the name is very short, you shouldn't be looking for far
10:39:36 <ibid> kowey: the reason haskell is often hard to read is that it is a very dense language (ie. you can say a lot with very small amounts of code)
10:40:17 <kowey> i'm trying to figure out what would be good advice for people who complain of haskell-induced brain hurtage
10:41:03 <kowey> i guess we can't do much about density, except advise people not to look in too many places, but to look at it for a long time (density)
10:41:03 <ibid> kowey: my standard answer is, "it makes you a better programmer even if you never touch haskell again"
10:41:34 <kowey> ibid: well... i was hoping primarily to alleviate the pain :-)
10:41:36 <int-e> kowey: learning is hard. *shrugs*
10:41:48 <ibid> i have a hypothesis that program comprehension speed is constant when normalized over code density
10:42:18 <araujo> I think Haskell tend to be easier to read than most of the languages out there.
10:42:29 <xerox> ibid: take boredom in account!
10:42:40 <kowey> araujo: well, yeah, but that's because we're used to it
10:42:43 <lispy> kowey: if you want to make code easier to read for others, using the idiomn of the language are one of the biggest ways to do that (there even exists research that suggest this)
10:42:46 <ibid> xerox: yes, and the law of seven :)
10:43:03 <lispy> idiomn == idioms
10:43:25 <ibid> xerox: ok, it's constant ignoring fatique
10:43:25 <lispy> expert programmers begin to look for patterns in the code
10:43:33 <araujo> kowey, i learned other languages first , after so many years, i still find them more ugly and hard to read.
10:43:48 <lispy> i forget the terminology that researchers gave this...it was like signalposts or something
10:43:50 <ibid> xerox: remember that dense code can cause fatique too
10:44:00 <xerox> ibid: it depends in my opinion
10:44:09 <ibid> xerox: which?
10:44:24 <xerox> ibid: if the dense code is full of recognizable patterns, it's still comprehensible code
10:44:28 <dylan> I can't say I know haskell yet, but other than having to remember so many symbolic operators, it is very easy to read and comprehnsion speed seems to be non-linear...
10:44:47 <dylan> (e.g. gradually becomes faster)
10:44:58 <xerox> (ibid: I am thinking of points free code.)
10:45:04 <kowey> i have also heard complaints about the operators
10:45:15 <ibid> xerox: yes, and even sparse code containing patterns help :)
10:45:22 <ibid> xerox: hence design patterns ;)
10:45:40 <xerox> I don't know about them, I can't read very laaarge projects.
10:45:41 <dylan> '.' isn't so bad, but '$' was hard to get used to.
10:45:48 <xerox> I had problems with Cabal too, hrrrmpf.
10:45:50 <ibid> $ is great :)
10:45:58 <ibid> once i figured it out, that is
10:46:11 <xerox> f . g . h . ... . z $ x  is even better!
10:46:11 <dylan> I'd prefer if '$' was something else.
10:46:20 <dylan> though I don't know what.
10:46:30 <ibid> xerox: no it's not
10:46:47 <ibid> xerox: it seems to be a matter of personal preference
10:46:48 <xerox> Argh.
10:47:11 <xerox> Cale had formalized the reasons, it has to do with whipuptitude :)
10:47:33 <kowey> whipuptitude?
10:47:40 <lispy> one of more confusing things about haskell code to me, is a very long 'where' or 'let' clause where the variables seem to appear in random order or deep in a pattern
10:48:21 <xerox> I dislike lets. They introduce the details, and then the actual code comes after.
10:48:28 <dylan> I find it hard to figure out proper indentation for 'where' for a function.
10:48:29 <xerox> Wheres on the other hand leave the details for later.
10:49:09 <dylan> by 'proper' I mean "looks nice", not "compiles"
10:49:09 <lispy> xerox: i prefere where also, but i've had this readablility problem with both at various times
10:49:12 <ibid> when i don't know exactly how i can implement a functionn, i write it f params = undefined where ...
10:49:21 <ibid> and start adding definitions in the where
10:49:25 <xerox> lispy: a big monitor helps much!
10:49:31 <kowey> i tend to use let for "things you probably absolutely need to know to get the code" and where for "details"
10:49:37 <ibid> xerox: i often use let when the meat is in the defs
10:49:38 <xerox> ibid: yes! yes! yes!
10:49:47 <xerox> ibid: I only use lets in do blocks.
10:50:03 <ibid> xerox: also it's basically the only choice in do
10:50:16 <lispy> i wish there was a where that spanned multiple patterns
10:50:33 <lispy> but...whenever i need that i stop using a where and make auxillary functions
10:50:35 <xerox> lispy: lambda-lift those definitions :)
10:50:40 <ibid> then the pattern variables wouldn't be in scope
10:50:43 <xerox> That :)
10:51:00 <ibid> ... or put the pattern matching in a case :)
10:51:09 <ibid> i use case a lot
10:51:25 <ibid> i almost never use if
10:51:26 <lispy> i still don't use case much, but that's a good point
10:51:43 * lispy avoids if because of the syntax, in lispy....
10:51:50 <lispy> er lisp
10:51:58 <lispy> heh, not in myself...
10:52:43 * dylan tatoos '(if (null? me) (explode)) on lispy 
10:53:27 <xerox> ibid: if feels strange, yeah
10:53:40 <xerox> ibid: I am learning using case, strangely enough I never did before these last days
10:54:17 <ibid> i often write:
10:54:20 <ibid> case whatever of
10:54:29 <ibid>   True -> whatever'
10:54:36 <ibid>   False -> whatever''
10:55:22 <xerox> Yuck.
10:55:30 <ibid> huh?
10:55:32 <xerox> You want a place in thedailywtf?
10:55:36 * xerox is kidding
10:56:00 <ibid> you like if whatever then whatever' else whatever'' so much?
10:56:06 <xerox> No :(
10:56:15 <ibid> okay, what then?
10:56:17 <xerox> 'bool' would be good, like 'maybe' and 'either'.
10:56:32 <ibid> pfui
10:57:09 <ibid> well, i tend to write core-ish haskell unless applications make the stuff very much easier to read
11:16:48 <ookk> why doesnt this work? f = do r <- randomIO; (putStrLn.show) r
11:17:41 <Lemmih> Works for me.
11:18:49 <ookk> hmm bah i forgot to include the module :P
11:19:58 <ookk> this thoug doesnt work: let f = do r <- randomIO; r
11:20:09 <dcoutts> indeed
11:20:15 <ookk> how come?
11:20:32 <dcoutts> because r is not of type IO ()
11:20:35 <ookk> what if i want an action that returns a random number?
11:20:44 <dcoutts> use return
11:21:08 <dcoutts> note that do r <- randomIO; return r  =  randomIO
11:21:10 <Lemmih> 'randomIO' does that.
11:21:23 <dcoutts> (do r <- randomIO; return r)  =  randomIO
11:21:49 <ookk> okay
11:22:00 <dcoutts> ookk, so I bet the problem is that you're trying to get a 'pure' random number out of nowhere
11:22:14 <dcoutts> ie trying to use 'f' as if it were a random number
11:22:28 <dcoutts> rather than an IO action that returns a random number?
11:22:38 <ookk> i want to make a list of random numbers
11:22:47 <ookk> and i want to make an action for it
11:23:03 <ookk> but i first thought about an action to produce one random number
11:23:33 <Korollary> It's easier to see when you desugar the do-notation
11:23:38 <dcoutts> so you want to use getStdGen and randoms
11:24:15 <dcoutts> @type return . randoms =<< getStdGen
11:24:18 <lambdabot> forall a. (Random a) => IO [a]
11:24:41 <dcoutts> @type fmap randoms getStdGen
11:24:42 <lambdabot> forall a. (Random a) => IO [a]
11:25:25 <int-e> @index getStdGen
11:25:26 <lambdabot> System.Random
11:25:39 <ookk> okay that seems to work fine
11:25:39 <ookk> thx
11:26:28 <ookk> im not that into monads yet
11:26:33 <int-e> one problem though, if you do that several times, you get the same sequence.
11:26:34 <ookk> wat does =<< do?
11:26:38 <ookk> what*
11:26:49 <ookk> its like flip >>= ?
11:27:04 <int-e> yes
11:28:14 <ookk> how do i use that list then?
11:28:23 <int-e> so to use it properly, you want something like do g <- getStdGen; let (g1, g2) = split g; setStdGen g1; return $ randoms g2
11:28:27 <ookk> it genereates an infinite list?
11:28:35 <int-e> yes
11:28:43 <ookk> but how do i only take n elements?
11:28:52 <int-e> take n ...
11:28:55 <int-e> it's a list
11:28:58 <dylan> take 10? :)
11:29:00 <ookk> doesnt work for me
11:29:03 <ookk> i tried that
11:29:18 <int-e> it does work, but you may be doing it in the wrong place.
11:29:30 <ookk> i have to list <- ...
11:29:30 <int-e> take isn't monadic, take is pure.
11:29:36 <ookk> then take n list?
11:29:49 <int-e> @type return . take 100 . randoms =<< getStdGen
11:29:52 <lambdabot> forall a. (Random a) => IO [a]
11:30:23 <int-e> or let list' = take 100 list
11:30:30 <int-e> but not  list' <- take 100 list
11:31:11 <int-e> list' <- return (take 100 list)  works again.
11:32:26 <ookk> so any function that within it uses something with type IO cannot has to return something with type IO?
11:33:29 <Korollary> it works out that way
11:35:33 <ookk> but how come return . take 100 . randoms =<< getStdGen works?
11:35:44 <ookk> doesnt randoms return IO Int?
11:35:48 <ookk> and take is functional?
11:36:09 <int-e> return takes a value and wraps it into an IO action.
11:36:14 <int-e> @type return :: a -> IO a
11:36:16 <lambdabot> a -> IO a :: forall a. a -> IO a
11:36:44 <ookk> take 100 . randoms should not be valid?
11:36:56 <ookk> you pass the values of randoms that is IO Int to take 100
11:37:05 <int-e> no
11:37:33 <int-e> randoms is of type StdGen -> [Int]
11:37:38 <int-e> it's a pure function.
11:38:07 <int-e> do g <- getStdGen; return (take 100 (randoms g))  is equivalent to that line.
11:38:58 <int-e> g is a random number generator (StdGen), randoms turns it into a list, take 100 chops that list, return turns it back into something IO-ish.
11:39:03 <ookk> but how can it be a pure function?
11:39:17 <ookk> it doesnt have the same value for the same parameters?
11:39:17 <int-e> why not?
11:39:30 <int-e> given the same StdGen argument it'll always produce the same list.
11:39:44 <int-e> that list contains many different values.
11:40:20 <ookk> but then why cant i use it directly?
11:40:31 <ookk> randoms =<< getStdGen ?
11:40:42 <ookk> if randoms :: Int
11:40:56 <int-e> because you must get back to IO for =<< to work.
11:41:47 <int-e> getStdGen >>= some_function_that_needs_a_list_of_random_numbers . randoms   will work nicely.
11:42:44 <int-e> if some_function_etc returns an IO action.
11:43:09 <ookk> >>= returns a monad?
11:43:15 <ookk> (>>=) :: (Monad m) => m a -> (a -> m b) -> m b
11:43:16 <int-e> yes
11:43:34 <ookk> so a monad is an IO action?
11:43:52 <int-e> You cannot get out of IO. You can enjoy the freedom of purity for a while but at the end of the day you must get back into the pesky IO monad.
11:44:01 <int-e> No, but IO is a monad.
11:44:40 <int-e> so (>>=) has type IO a -> (a -> IO b) -> IO b  among others.
11:44:57 <ookk> okay
11:45:42 <ookk> this monad stuff is far from self-explanatory :P
11:45:52 <ookk> but its getting clearer
11:48:12 <Korollary> in this context it's just the typesystem.
11:49:34 <_frederi1_> can anyone help me with a memory leak problem?
11:52:20 <_frederik_> http://ofb.net/~frederik/irc_paste/count-given-multiword.hs
11:52:56 <_frederik_> it's reading a list which is several gigabytes using getContents, parsing words from the front of it, and keeping statistics
11:53:19 <_frederik_> most work is done in 'countWords' which is tail-recursive
11:53:38 <_frederik_> the memory usage grows as it reads the list
11:54:31 <Korollary> Why are you not using Data.ByteString if the list is in gigabytes?
11:55:03 <_frederik_> i don't know, but what i'm doing now should work, should it not?
11:55:44 <_frederik_> i don't care about speed, i just want it to work and not run out of memory
11:57:20 <Korollary> Did you try a profile run with a smaller list?
11:57:56 <int-e> try to seq your counts.
11:57:57 <_frederik_> no, wouldn't that require recompiling all the libraries i use with profiling as well?
11:58:26 <int-e> HT.update ht suf (Just $ c+1) --> let c' = c+1 in c' `seq` HT.update ht suf (Just $ c')
11:58:41 <int-e> but it's very hard to guess memory leaks from the source code. profile.
11:58:48 <_frederik_> ah
11:59:13 <_frederik_> is there a way to profile without recompiling all the packages i depend on?
12:00:12 <int-e> probably not. (although that'd be very nice)
12:01:13 <_frederik_> thanks int-e, it works now
12:01:15 <_frederik_> you're my hero
12:02:12 <int-e> lucky
12:04:07 <dylan> Long live the fighters of Muad_Dib!
12:04:15 <dylan> (sorry)
12:04:48 <Korollary> too much spice
12:05:08 <int-e> too little water, too hot sun.
12:25:36 <wilx> Heh.
12:53:13 <tibbe> @sad
12:53:14 <lambdabot> Maybe you meant: faq id map read slap
12:53:47 <basti_> certainly
12:54:32 <Korollary> @map slap #haskell
12:54:32 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
12:54:44 <basti_> o.0
12:55:11 <vegai> the *other* map
12:55:23 <basti_> ah ok
13:06:14 <Jaak> @hoogle [a] -> a -> [[a]]
13:06:15 <lambdabot> No matches, try a more general search
13:06:31 <Jaak> @hoogle [a] -> [a] -> [[a]]
13:06:32 <lambdabot> No matches, try a more general search
13:07:19 <Jaak> @hoogle [a] -> (a -> Bool) -> [[a]]
13:07:20 <lambdabot> No matches, try a more general search
13:07:28 <Jaak> :\
13:07:56 <tibbe> what do you need?
13:08:41 <Jaak> split/tokenize, already implemented it tho'
13:46:49 <sh10151> is Parsec the 100% solution to haskell tokenizing?
13:47:08 <stepcut> sh10151: no
13:47:17 <norpan> hardly
13:47:33 <sh10151> is there a 100% solution?
13:47:46 <norpan> there is no 100% solution for anything
13:47:57 <stepcut> sh10151: depends on your problem
13:48:04 <sh10151> intro to http://www-static.cc.gatech.edu/~shivers/papers/sre.txt
13:48:45 <sh10151> "I am not saying that these three designs of mine represent the last word on
13:48:46 <sh10151> the issues -- "100%" is really a bit of a misnomer, since no design is ever
13:48:46 <sh10151> truly 100%. I would prefer to think of them as sufficiently good that they at
13:48:46 <sh10151> least present low-water marks -- future systems, I'd hope, can at least build
13:48:46 <sh10151> upon these designs, hopefully *in terms of* these designs."
13:49:08 <sh10151> prolegomenae
13:49:50 <stepcut> sh10151: Parsec is a very reasonable, full-featured implementation of a monadic, backtracking parser
13:50:19 <stepcut> sh10151: It could be improved by adding a ParsecT monad transformer
13:51:34 <stepcut> sh10151: There are also some limitations of monadic parsers in general
13:52:53 <stepcut> sh10151: but Daan wrote Parsec with the intention that it should be an 'industrial-strength' parser
13:53:01 <sh10151> thanks
13:53:06 <stepcut> http://www.cs.uu.nl/~daan/parsec.html
14:02:22 <xerox> How do you desugar parallel list comprehensions?
14:06:38 <int-e> into zips
14:07:52 <int-e> a <- x | b <- y ==> (a,b) <- zip x y
14:26:31 * edwardk yawns and waves.
14:26:35 <xerox> Yow.
14:26:50 <edwardk> how goes cabal-get?
14:27:18 <xerox> I am lost on some perl code I *want* to translate to Haskell.
14:27:25 <edwardk> ?
14:27:27 <xerox> Blame #perl6.
14:43:07 <Cale> xerox: what does the code do?
14:43:14 <xerox> Primes.
14:44:32 <xerox> perl -wle '("1" x $_) !~ /^(11+)\1+$/ && print while ++ $_'
14:46:50 <Cale> um, 1 isn't prime
14:47:04 <xerox> I know.
14:47:42 <Cale> ++ is pre-increment here?
14:47:47 <xerox> Yes
14:49:56 <int-e>  perl -le '1while(1x++$_)=~/^(11+)\1+$|^1$/||print'
14:50:00 <int-e> that doesn't print 1 :)
14:50:38 <xerox> hehe
14:50:50 <xerox> perl is strange.
14:51:05 <xerox> But I am envious of that powerful regexp oracle!
14:51:16 <edwardk> heh
14:51:17 <int-e> granted, it's 2 characters longer, compressed.
14:51:19 <kpreid> @pl (\x -> (x - 1) `mod` 2 == 0)
14:51:19 <lambdabot> (0 ==) . (`mod` 2) . subtract 1
14:51:24 <Korollary> right. it's the way to write software.
14:51:24 <Cale> ah, I see how that works.
14:52:01 <Cale> They're cleverly abusing the fact that perl regular expressions describe non-regular languages.
14:52:02 <xerox> My first attempt was stylish but... wrong.
14:52:08 <int-e> the fact that you can rewrite ("1" x $_) as 1x$_ is nasty.
14:52:15 <xerox> ....non-regular? uuuuh!
14:52:19 <int-e> err, keep the brackets.
14:52:36 <Cale> xerox: Primes isn't a regular language
14:52:38 <wolverian> what's nasty about implicit coercion? :)
14:52:43 <Cale> Even in unary :)
14:52:51 <xerox> Cale, what does it mean?
14:53:26 <Cale> http://en.wikipedia.org/wiki/Regular_language says it better than I can
14:53:55 <int-e> So Perl regexps can describe non-regular languages.
14:53:55 <Cale>     * the empty language Ø is a regular language.
14:53:55 <Cale>     * the empty string language { ε } is a regular language.
14:53:55 <Cale>     * For each a ∈ Σ, the singleton language { a } is a regular language.
14:53:55 <Cale>     * If A and B are regular languages, then A U B (union), A • B (concatenation), and A* (Kleene star) are regular languages.
14:53:57 <Cale>     * If A is a regular language, then (A) denotes the same regular language
14:53:59 <Cale>     * No other languages over Σ are regular.
14:54:25 <Cale> right
14:54:35 <Cale> Because they're not really regular expressions anymore
14:54:48 <Cale> They have things like \1
14:54:49 <xerox> That's interesting
14:55:00 <int-e> the fact that primes isn't a regular language is a nice application of the pumping lemma for regular languages.
14:55:02 <xerox> Well, I can implement that.
14:55:12 <int-e> (encoded as unary)
14:55:13 <xerox> I can implement that whole regexp.... except for the last +.
14:55:16 <wolverian> the perl6 development synopses mention that explicitly: we think the popular term "regex" is in the process of becoming a technical term with a precise meaning of: "something you do pattern matching with, kinda like a regular expression".
14:55:33 <edwardk> as i seem to recall, they are turing complete because you can inject code fragments
14:55:42 <Cale> yeah
14:55:43 <wolverian> ...which is why they're still called regexes in perl6.
14:55:47 <Cale> ugh
14:55:52 <xerox> The last + is a disaster.
14:56:06 <Cale> They really should stop
14:56:13 <Cale> just call the things grammars
14:56:24 <xerox> Don't they call it roles now? I could be wrong.
14:56:26 <wolverian> perl6 has grammars, which are not regexes.
14:56:35 <Korollary> roles are macros iirc
14:56:45 <wolverian> xerox, no. roles are feature composition things (compile-time mixins)
14:56:56 <basti_> how can a regular language be described by "second order monadic logic"?
14:57:03 <Cale> why would they have grammars and regexes (which aren't regular expressions)
14:57:06 <Cale> ?
14:57:08 <wolverian> ..or interfaces that can define implementation and state
14:57:28 <wolverian> Cale, grammars are to rules what classes are to methods, roughly.
14:57:46 <Cale> wolverian: hm?
14:57:53 <int-e> Ah, I remmeber what I did. The |^1$ took care of the 'prime' 1.
14:57:53 <xerox> So we are off-track to have ^(11+)\1+$ in Haskell?
14:57:54 <edwardk> cale: probably because perl has the problem that there are like 4-5 people out there who know all of the ins and outs of its regexp engine. so a little reinventing of the wheel is to be expected.
14:57:59 <wolverian> Cale, http://dev.perl.org/perl6/doc/design/syn/S05.html see "Grammar"
14:58:01 <lambdabot> Title: Synopsis 5: Regexes and Rules -
14:58:07 <wolverian> er, "Grammars"
14:58:28 <int-e> Perl oneliners are mostly read-only in a scary way, I don't even immediately understand the ones I wrote myself after a while.
14:58:29 <Cale> edwardk: But if they serve the same purpose, why not drop the messy regex engine?
14:58:46 <edwardk> coz its the fastest one out there
14:58:49 <xerox> int-e - I'm fine with that, but the method is clever, isn't it?
14:58:58 <wolverian> the messy regex engine that perl5 uses is extremely useful. what would you want to replace it with?
14:59:17 <int-e> xerox: yes. I saw that method elsewhere.
14:59:20 <xerox> I initially suspected it was a very interesting way to generate primes, but when Cale said non-regular I though I was expecting too much.
14:59:20 <Cale> wolverian: A proper way to construct parsers?
14:59:32 <Cale> :)
14:59:50 <edwardk> shapr around
14:59:51 <edwardk> ?
14:59:56 <edwardk> @seen shapr
14:59:56 <lambdabot> I haven't seen shapr.
15:00:02 <wolverian> Cale, perl6 has builtin support for tokens, rules and grammars (collections of the aforementioned). it really looks pretty much like parsec, except rules are their own sublanguage.
15:00:05 <int-e> @yarr
15:00:05 <lambdabot> Splice the Mainbrace!
15:00:25 <Cale> wolverian: right, I'm saying once you have that, what do you need regexps for?
15:00:36 <xerox> one = char '1'; composite = many (one >> many one) -- ?
15:00:58 <Cale> xerox: Note the use of \1
15:01:03 <wolverian> Cale, well, syntactically, rules _are_ regexes.
15:01:06 <int-e> xerox: then you assert that repetitions of that particular string follow.
15:01:08 <wolverian> (named regexes)
15:01:11 <Cale> ^(11+)\1+$
15:01:24 <edwardk> terseness and speed
15:01:27 <Cale> \1 matches the same thing as the first bracketed group matched
15:01:31 <xerox> Cale: that's what my first many is for, I think
15:01:46 <wolverian> right. mind you, the regexp language of perl5 is no more in perl6 - the syntax is completely different.
15:01:53 <xerox> I knew that
15:01:57 <Cale> Oh
15:01:57 <xerox> But now I see what I was missing
15:02:02 <Cale> many2 :)
15:02:14 <xerox> Not even that, I think
15:02:14 <int-e> 11111111 matches as (11)[11][11][11] or (1111)[1111], but not as (111)[111]11
15:02:15 <edwardk> xerox: you need to remember the match and match it exactly on subsequent matches
15:02:17 <Cale> many2 p = p >> many p
15:02:36 <xerox> Right
15:02:38 <tibbe> is Types and Programming Languages a recommended read?
15:02:42 <xerox> it ought to be the exact same parser
15:02:49 <edwardk> tibbe: YES =)
15:02:58 <xerox> Cale, but I think that doesn't work either
15:03:03 <Cale> wolverian: okay, then call them rules :)
15:03:10 <xerox> Cale, a p could match 2 '1' and another 4 '1', no?
15:03:32 <wolverian> Cale, rules are named regexes. :)
15:03:33 <edwardk> cale: is your parser nondeterministic? coz if its greedy it won't work.
15:03:39 <edwardk> s/cale/xerox/
15:03:40 <int-e> x <- (one >> many1 one); many1 (string x)
15:03:42 <wolverian> Cale, (as are tokens, but with slightly different behaviour)
15:03:44 <tibbe> edwark, what's it like?
15:03:46 <int-e> now add backtracking to that
15:03:47 <Cale> xerox: yeah, you need to remember the result
15:03:53 <xerox> int-e's one is nice
15:04:01 <edwardk> tibbe: a really good way to get your head around operational semantics
15:04:04 <xerox> But does it backtrack nicely ?
15:04:12 <int-e> hmm, not quite correct :)
15:04:23 <xerox> Or does it match the whole string at first?
15:04:24 <int-e> string ('1':x) is more like it
15:04:40 <int-e> and no, parsec doesn't backtrack by default and I have no idea where the 'try' should go.
15:04:49 <Cale> wolverian: how about the name 'pattern'? Is that taken?
15:04:53 <edwardk> maybe  readP/parsek?
15:04:58 <xerox> I think it would match the whole string no matter how many 1's are in there.
15:05:03 <Cale> patterns would be a better term than regexes
15:05:15 <edwardk> yeah parsec will just gobble up with whole group of 1s in the first many.
15:05:31 <xerox> :(
15:05:34 <Cale> use try
15:05:46 <wolverian> Cale, pattern is a piece of regex (or the whole regex); i.e. a string that parses as a regex
15:05:54 <int-e> you probably need your own many1 implementation for the first part
15:05:59 <int-e> one that tries all alternatives.
15:06:01 <wolverian> Cale, (that is, this is how the synopses use these words right now.)
15:06:05 <xerox> on the<Interrupted by int-e>
15:06:08 <Cale> wolverian: Isn't a piece of a regex also a regex?
15:06:19 <xerox> Cale, on the first many1 ?
15:06:35 <basti_> *b is not a regex, but piece of a*b
15:06:36 * basti_ ducks
15:06:38 <wolverian> Cale, a regex is generally a complete unit.
15:06:47 <wolverian> a phrase, if you will, where pattern is a set of words.
15:07:14 <wolverian> basti_, right. :)
15:07:56 <wolverian> Cale, I don't necessarily disagree with you on the naming issue, but I don't feel very strongly in either direction.
15:08:27 <basti_> not counting parenthenses, and when you don't break the "quantifiers", and don't formally destroy constructions like alternatives, cale's statement holds though.
15:08:47 <basti_> boils down to: regexes are recursively defined.
15:12:55 <Cale> xerox: hmm, seems that doesn't work
15:13:04 <xerox> To me too
15:13:05 <int-e> Homework. Find a regular expression for L([ab]*) - L([ab]*aabb[ab]*).
15:14:51 <xerox> Cale, it seems to me that the latter + is a complete disaster, how the heck does it know where to stop...
15:15:02 <Cale> huh?
15:15:08 <Cale> It backtracks completely
15:15:26 <xerox> Until the exhaustion of the whole string?
15:15:33 <Cale> yes
15:15:35 <xerox> AH.
15:16:11 <Cale> Parsec tries to be LL(1) as much as possible, and certain kinds of backtracking aren't allowed, for performance reasons.
15:16:15 <Cale> ReadP'd work though
15:16:19 <edwardk> maybe it should be something like:
15:16:25 <edwardk> > filter ((=="").snd) $ (flip readP_to_S) "1111" $ do x <- (char '1' >> many1 (char '1')); many1 $ string x
15:16:27 <lambdabot>  Not in scope: `string'
15:16:35 <edwardk> ah no readP in scope
15:16:42 <xerox> readP ?
15:16:44 <edwardk> though thats not quite right
15:16:52 <edwardk> Text.ParserCombinators.ReadP
15:16:57 <xerox> Uh.
15:16:58 <edwardk> is nondeterministic =)
15:17:16 <edwardk> the code above is wrong, but has the right idea i think
15:17:20 <edwardk> it'll also be slooow.
15:17:23 <edwardk> =)
15:18:23 * xerox wants it
15:18:25 <xerox> @yarrrr
15:18:26 <lambdabot> I want me grog!
15:18:40 <edwardk> its built in. you should just :m the module in ghci
15:18:51 <edwardk> and you can play with it
15:18:53 <xerox> No I mean, the whole thing, I'm eager.
15:18:56 <edwardk> ah
15:19:10 <edwardk> then you should go to #ocaml, we're lazy ;)
15:19:17 <xerox> Roar.
15:19:50 <Cale> composite = do x <- liftM2 (:) (char '1') (many1 (char '1')); y <- many1 (string x); z <- look; guard (null z); return (x,y)
15:20:04 <xerox> look..
15:20:15 <Cale> look :: ReadP String
15:20:15 <Cale> Look-ahead: returns the part of the input that is left, without consuming it.
15:20:41 <edwardk> thats what i was looking for =)
15:22:20 <xerox> WOW
15:22:25 <xerox> @karma+ Cale
15:22:25 <lambdabot> Cale's karma raised to 12.
15:22:39 <xerox> readP_to_S composite "111"  ===>  []
15:22:50 <xerox> readP_to_S composite "111111"  ===>  [(("11",["11","11"]),""),(("111",["111"]),"")]
15:23:16 <xerox> Thank you.
15:23:40 <int-e> xerox: can you paste the code?
15:23:46 <int-e> please?
15:23:59 <xerox> Cale's some lines above
15:24:31 <int-e> ah
15:24:39 <xerox> No, I wasn't clever enough :|
15:27:05 <xerox> int-e: yours was pretty right, it just needed a magical look function, and a guard.
15:27:18 <int-e> xerox: and a different monad
15:27:29 <xerox> Cale: I tried n times to realize what was into the guard, but it beated me.
15:27:59 <xerox> int-e: polymorphism :P
15:28:24 <edwardk>  tail $ map fst $ filter ((==[]).snd) $ zip [1..] $ map (readP_to_S composite) $ inits $ repeat '1'
15:28:30 <edwardk> woops
15:28:31 <edwardk> no
15:28:34 <edwardk> that seems to blow up
15:29:10 <edwardk> [2,3,4,6,8,12,14,18,20,24,30,32,38,42,44,48,54,60,62,68,72,74,8 is a little cracked =)
15:30:37 <xerox> something $ filter (null . readP_to_S composite) (flip replicate '1' `map` [1..])
15:31:35 <xerox> something = map length
15:31:45 <edwardk> > take 20 $ map fst $ filter ((==[]).snd) $ zip [1..] $ map (readP_to_S composite) $ tail. inits $ repeat '1'
15:31:46 <edwardk> [1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67]
15:31:47 <lambdabot>  Not in scope: `composite'
15:31:53 <edwardk> er
15:32:01 <xerox> Yuck.
15:32:05 <edwardk> map fst $ filter ((==[]).snd) $ zip [1..] $ map (readP_to_S composite) $ tail. inits $ repeat '1'
15:32:07 <edwardk> works =)
15:32:33 <xerox> Maybe it'd look nicer with arrows
15:32:53 <edwardk> possibly. just wanted to glue the numbers in quickly
15:34:50 <edwardk> so, fully unrolled into a one-liner
15:34:52 <edwardk> map fst $ filter ((==[]).snd) $ zip [1..] $ map (readP_to_S $ do x <- liftM2 (:) (char '1') (many1 (char '1')); y <- many1 (string x); z <- look; guard (null z); return (x,y)) $ tail. inits $ repeat '1'
15:36:01 <int-e> the perl version is shorter ;)
15:36:16 <edwardk> yeah
15:36:17 <edwardk> quite
15:36:18 * xerox runs chasing int-e with a long knife
15:36:26 <edwardk> but then it has a nice regexp syntax in the language
15:36:38 <xerox> nice! ... nice! ...
15:36:43 <edwardk> heh
15:36:48 <wolverian> I think he means terse
15:36:53 <edwardk> well, its appropriate to certain problem domains
15:36:57 * xerox icks
15:37:04 <int-e> Knives. What did I do?
15:37:07 <xerox> O(n^n) algorithms?
15:37:08 <edwardk> and yes, terse is closely connected to 'nice' in my mind.
15:37:23 <wolverian> it's nice, yes, but it also sucks (ref. perl6 revamp of regexes)
15:37:26 <xerox> Nevermind, int-e, my brain is fried up.
15:37:31 <int-e> just O(n^2) I suppose.
15:37:48 <xerox> Supponent.
15:37:50 <int-e> xerox: please keep knives out of your hands then :)
15:37:57 <xerox> @yarrrr
15:37:58 <lambdabot> Splice the Mainbrace!
15:38:05 <int-e> @botsnack
15:38:05 <lambdabot> :)
15:38:19 <edwardk> this is probably the least efficient number sieve ever written though =)
15:38:43 <xerox> ...and I initially thought the method was clever...
15:38:51 <xerox> In some sense it *is*, but...
15:38:58 <int-e> it is, if you want a short perl program :)
15:39:23 * int-e wrote a O(2^n/n) average case sort algorithm once, to get a short assembler program.
15:39:23 <edwardk> well, all its doing is looking for a number that evenly divides your candidate prime.
15:39:47 <edwardk> a number >1 that is
15:40:08 <xerox> You are right
15:40:10 <edwardk> and perl's regexp engine is spanking us performance wise, coz readP is not fast
15:40:11 <int-e> (I'm not 100% sure the average case analysis is correct. But the best case was O(n^2) and the worst case O(2^n).)
15:40:19 <xerox> Why the hell are we encoding it in strings?!
15:40:27 <edwardk> coz you wanted to =)
15:40:31 <xerox> I did not!
15:40:46 <int-e> we could use type level natural numbers instead
15:40:50 <xerox> I did want to express it in Haskell.
15:40:54 <xerox> int-e: at some point I tried.
15:41:01 <edwardk> heh
15:41:02 <int-e> oh no. xerox is there, I didn't say anything.
15:41:05 <xerox> Now I think I understand better ...
15:41:18 <edwardk> i have a type level nat lib, but i don't have any primality testing in there
15:41:32 <xerox> ........
15:41:34 <xerox> Time to add one!!! yarrr.
15:41:34 <int-e> hmm, did I confuse edwardk with xerox? maybe.
15:41:38 <edwardk> heh
15:41:40 <edwardk> yeah =)
15:42:00 <edwardk> xerox: feel free to pull the code from my site and add it ;)
15:42:05 <xerox> Well, it's easy enough
15:42:35 <edwardk> yeah just all the recursion is a pain to write in the type level
15:42:43 <xerox> I don't find it painful
15:42:46 <xerox> But it's just me
15:43:11 <edwardk> then feel free, there is a multiplier in there, the type level binary or type level hex should both work =)
15:43:37 <xerox> I wonder if you could do it indipendently of the ""underlying"" meta-representation
15:43:39 <edwardk> i never did get around to writing a divmod type for it
15:43:42 <int-e> how do you terminate a division?
15:43:42 <int-e> hmm
15:43:56 <urz> what is rank-2 polymorphism?
15:44:03 <urz> or rank-1 or rank-n
15:44:38 <edwardk> urz: think about creating a function that can take other polymorphic functons as arguments.
15:44:52 * edwardk is afk a sec.
15:57:38 <wolverian> hrm. this ghci.vim really does not work in my vim.
15:57:42 <wolverian> or I don't know how to use it.
16:08:14 <SyntaxNinja> >  50.3 + 2.48 + 2.65
16:08:20 <lambdabot>  55.42999999999999
16:09:39 <SyntaxNinja> that's annoying
16:10:20 <stepcut> darcs get http://www.n-heptane.com/nhlab/repos/Decimal/
16:10:22 <lambdabot> Title: Index of /nhlab/repos/Decimal
16:10:22 <stepcut> ;)
16:10:27 <edwardk> heh
16:10:53 <int-e> >  50.3 + 2.48 + 2.65 :: Rational
16:10:56 <lambdabot>  5543%100
16:11:42 <stepcut>  > 50.3 + 2.48 + 2.65 :: Decimal
16:11:42 <stepcut> 55.43
16:34:03 <Cale> > showFFloat (Just 2) (50.3 + 2.48 + 2.65)  ""
16:34:05 <lambdabot>  "55.43"
16:34:31 <Cale> oh, he's quit
16:35:21 <urz> do you ever use the ST monad?
16:36:48 <SamB> I've tried once or twice
16:36:52 <SamB> but it is so annoying!
16:36:58 <urz> oh
16:37:02 <urz> im reading about it
16:37:16 <urz> why is it annoying?
16:39:00 <SamB> the types don't compose as well as I'd like
16:39:15 <SamB> in particular, that forall is pesky
17:46:02 <LordBrain> @where OOHaskell
17:46:03 <lambdabot> http://homepages.cwi.nl/~ralf/OOHaskell/
18:44:19 <jluquette> hi, does anyone have some pointers to good resources on using FFI in a pretty complex C system?
18:44:51 <jluquette> i've looked around for a bit, but most of what i can find is very, very primitive (and just sticks to the actual addendum to the haskell 98 report)
18:45:07 <jluquette> i'd highly appreciate any help.  thanks.
18:48:32 <dons> jluquette: hmm, there's a bit of a tutorial here:
18:48:34 <dons> ?wiki Wc
18:48:34 <lambdabot> http://www.haskell.org/haskellwiki/Wc
18:48:55 <dons> for complex systems, you might need c2hs to generate the bindings
18:49:03 <dons> as used in, for example, gtk2hs
18:49:15 <dons> possibly you would use hsc2hs instead, if its a simpler problem
18:49:54 <jluquette> dons: ahh, so that's what you'd use to generate bindings to large structs?
18:50:02 <dons> yep
18:50:07 <dons> one of the tools, c2hs or hsc2hs
18:50:12 <dons> ?where c2hs
18:50:12 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/c2hs/
18:50:52 <jluquette> aha
18:51:09 <jluquette> is it generally easy to deal with c->haskell interfaces?
18:51:35 <jluquette> or is it going to be somewhat nightmarish when trying to mitigate one way monads at the C level?
18:52:38 <lispy> one way monads at the C level?
18:53:15 <lispy> if you import a pure function from C you can make it pure and it doesn't have to return IO a
18:53:29 <jluquette> lispy: right, having a program in C calling into a haskell library, and having to encapsulate data into, say, the IO monad for the call
18:53:31 <lispy> you can do this with the sine function for instance
18:53:49 <jluquette> but i'm not dealing with pure functions, unfortunately.
18:54:06 <lispy> the C code knows nothing of monads
18:54:12 <jluquette> right.
18:54:25 <lispy> okay, i just don't get what you're worried about...
18:54:46 <jluquette> well, the haskell code i'm calling into is a parser
18:55:00 <jluquette> it's going to depend on the state of alot of things (all of which will be pulled from a database)
18:55:10 <jluquette> so the best way i imagined to do that was to make a monad on the haskell end
18:55:19 <jluquette> and i'm just not sure how i'm going to lift the data in the C call into the monad on the haskell end
18:55:50 <jluquette> i.e.: if the call requires 5 records from a db (which will be passed as structs in the C level), how easily will i be able to lift all of those into a monad for parsing?
18:56:23 <lispy> well, if it's in the IO monad no problem right?
18:56:29 <jluquette> (i have to admit i haven't invested a _TON_ of thought into this yet, because i'm just trying to see if it's feasible at the moment, so i apologize for being somewhat braindead.)
18:56:51 <lispy> maybe you just need to transformer, yourmonad -> IO
18:57:02 <jluquette> hmm.
18:57:50 <jluquette> well, there won't be any IO side effects, but there will be database side effects
18:58:49 <jluquette> sorry, i think i'm just wasting your time right now :)
18:58:49 <jluquette> i need to look into c2hs and mess around a bit before i can actually see if there will be problems
19:12:11 <lispy> jluquette: no waste of time
19:12:19 <lispy> jluquette: i was just distracted by other things
19:12:37 <lispy> bottom line, FFI is quite simple with C and haskell
19:14:07 <jluquette> i'm hoping so :)
19:15:31 <wolverian> http://www.informatik.uni-bonn.de/~ralf/publications/Quote.pdf this is the coolest hack I've seen this week
19:18:31 <edwardk> hrmm how are they supporting the guillemet delimitation?
19:19:26 <wolverian> I assumed haskell supports unicode identifiers.
19:20:11 <edwardk> the ony way i culd think of is the kind of trick that heffalump was using to try to do a lighter monad syntax, abusing [| |] in template haskell
19:20:24 <stepcut> I suspect the real code uses something else
19:20:57 <edwardk> $(parse [| fork fork leaf leaf leaf lead |])
19:21:02 <edwardk> or something
19:21:03 <stepcut> yeah
19:21:27 <edwardk> though its tricky to get the stuff inside [| |]'s to type check =)
19:22:57 <edwardk> ahh
19:23:22 <edwardk> nm, they do it with quote tick tick tick endquote
19:23:29 <dons> wolverian: it does support unicode identifiers. ghc supports them in version 6.5
19:23:29 <edwardk> so not quite as clean
19:23:50 <dons> you can use real lambdas :)
19:24:09 <edwardk> yeah, but a guillemet is not a unicode letter  symbol, so it would be an operator and hence binary
19:24:47 <edwardk> dons: add good unicode support to yi and i might use it ;)
19:28:02 <sh10151> so many editors, so little time
19:29:50 <edwardk> wolverian: that paper is somewhat amusing =)
19:30:04 <wolverian> yup :)
19:30:26 <edwardk> so now you need to write an LALR parser generator that generates the instances ;)
19:32:25 <edwardk> heh http://channel9.msdn.com/Showpost.aspx?postid=223865 has Eric Meijer rambling on about a fair chunk of topics that cover STM, concurrency, etc.
19:32:27 <lambdabot> Title: Erik Meijer: Democratizing the Cloud
19:32:52 <edwardk> he's sort of an ex-haskell guy so it seemed appropriate to the channel
19:57:48 <sh10151> democratizing the cloud?
19:58:14 <edwardk> well i think the intent was to talk about vb in a distributed parallel processing environment
19:58:20 <edwardk> but he mostly talks about other topics
19:58:50 <sh10151> http://hinchcliffe.org/img/web2architecture.jpg
19:59:06 <sh10151> I heard that "People in the Machine Nurture the Cloud"
19:59:31 <edwardk> heh that sounds very much like something from soylent green for some reason
19:59:51 <edwardk> not quite sure why
19:59:54 <sh10151> http://www-scf.usc.edu/~tlrobins/crazycoolchart.jpg
20:00:21 <edwardk> heh
20:00:52 <edwardk> wtf? =)
20:03:11 <Korollary> nice shirt
20:05:25 <Korollary> "unprotected sex!"
20:08:00 <Korollary> The interviewer sounds boring.
20:08:24 <edwardk> the interviewer sucks ass
20:08:33 <edwardk> the singularity interviews demonstrate his ignorance =)
20:08:53 <edwardk> those also mention STM, btw.
20:09:02 <Korollary> This is the first channel9 video I've ever seen.
20:09:10 <Korollary> C# has STM
20:09:28 <edwardk> yeah. they have an OS kernel written in C# and are playing with STM in that context.
20:10:07 <Korollary> go javascript!
20:10:10 <edwardk> they do domain separation optionally within a given hardware protection domain, so can get a nice 30% speed boost. thats actually pretty low.
20:10:11 <Korollary> hah
20:10:13 <edwardk> kor: heh
20:10:14 <edwardk> yeah
20:10:15 <Korollary> he said 'ajax hype'
20:10:45 <edwardk> overall i largely agree with him. though the 'what happened to jscript.NET answer largely appears to be that microsoft buried it
20:11:14 <edwardk> they fed it enough support that people couldn't slam them, but they just wrote the most assinine help pages for it i've ever seen
20:11:25 <Korollary> 'javascript is kind of a weird language.'
20:11:45 <edwardk> ecmascript 4 takes javascript to exactly the same place he is talking about vb being at.
20:11:54 <edwardk> the mixed static/dynamic typing, etc.
20:12:21 <edwardk> he's kind of a strange duck for a former haskell guy though =)
20:12:25 <Korollary> I am not sure whether Eric has ever said anything pro-dyna+static typing before joining MS.
20:12:29 <edwardk> http://lambda-the-ultimate.org/node/967
20:12:30 <lambdabot> Title: Visual Basic and LINQ | Lambda the Ultimate
20:12:42 <edwardk> dunno when he joined
20:13:13 <Korollary> Audrey!
20:13:23 <Korollary> go pugs
20:13:47 <edwardk> heh the video really made me want to work on an STG or GRIN -> javascript compiler
20:13:55 <Korollary> I am watching his laptop screen
20:13:57 <edwardk> just the former has soooo much library support it needs.
20:14:16 <Korollary> I am not sure if all this crosscompiling means anything
20:14:54 <edwardk> anyways the singularity videos are amusing especially if you are familiar with any SASOS research, since they seem to basically roll up all of the last 10 years of research, and claim it as their own
20:14:56 <Korollary> Intellisense uber alles.
20:15:19 <Korollary> He doesn't believe in up-front design. I am taking this to my boss.
20:15:24 <edwardk> heh
20:15:37 <edwardk> i don't really believe in up-front design either.
20:15:39 <Korollary> I think that's a line of BS
20:15:51 <edwardk> it just ties your hands and limits refactoring
20:16:19 <Korollary> I dont know what you mean with up-front design, then.
20:16:49 <edwardk> up front design lets you employ more people of lesser talent to work on the project, but a waterfall development model only works when you fully understand the problem domain a priori
20:17:18 <Korollary> I dont consider up-front design synonymous to waterfall.
20:17:27 <edwardk> think classic 5 stage design vs. something more flexible, like the unfortunately named extreme programming.
20:17:31 * edwardk nods.
20:17:31 <hitodama> does anyone have reccommendations for a windows text editor for editing haskell code?
20:17:44 <edwardk> some design up front, but i think he's using the term in the waterfall model sense.
20:17:56 <edwardk> er some up front design is useful, but...
20:18:12 <Korollary> hitodama: I believe there's an eclipse plugin called eclipsefp. Also visual haskell.
20:18:54 <Korollary> His laptop is going crazy behind him heh.
20:19:45 <edwardk> heh i just noticed that it was running something, then shut down, etc =)
20:19:50 <Korollary> I think somebody is using it via remote desltop
20:20:42 <Korollary> Ok, the way he described up-front design indeed does suck.
20:20:56 <Korollary> pages of UML docs before a single line is written. Yeah.
20:21:20 <edwardk> i presently have an employer that works that way. i'm slowly changing them from their 1980s style design model, but its taking a lot of work.
20:22:02 <Korollary> It depends on the project. Space shuttle software will be written with more upfront design and redtape than e-commerce software.
20:22:11 <edwardk> sure
20:22:19 <edwardk> but they do random websites for linguists =)
20:22:29 <edwardk> its totally inappropriate
20:22:34 <Korollary> I see
20:22:58 <edwardk> keeps the customer out of the loop to the end, so when the customer finally sees the project they come back with all sorts of major changes, etc.
20:23:03 <edwardk> and tons of effort is wasted
20:23:07 <Korollary> What a waste of 45 minutes of Eric Meijer
20:23:35 <edwardk> today was the first day i saw this site.
20:23:58 <Korollary> I knew about this, but I wasn't interested in it.
20:24:22 <Korollary> the interviewer is a dufus.
20:24:32 <edwardk> i was sent the link by a buddy of mine who is trying to get his head around STM stuff
20:24:40 <dylan> My boss is stuck in the 1980s model of design, but, he has not enough time to actually require me to do suck things. XD
20:24:52 <dylan> *such things
20:24:58 <edwardk> heh
20:25:09 <edwardk> i'll go so far as GANTT charts, etc.
20:25:22 <dylan> my 'design requirements document' is a series of scribbles he writes on scrap paper.
20:25:24 <edwardk> those serve a purpose, but mostly i use them to keep projects on track and track critical tasks.
20:25:28 <Korollary> I believe I can jump in my car and in 20 minutes smack this interviewer silly.
20:25:42 <edwardk> kor: go for it, smack him one for me while yer at it =)
20:26:04 <edwardk> the singularity interviews are plagued with similar dumb questions, esp #3.
20:26:38 <dons> dylan: how's the haskell coding coming along? had time to write anything fun?
20:26:53 <Korollary> I like his desk. Our desks suck at work.
20:27:10 <dylan> dons: Oh, the thing using getDirectoryContentsRec is fun
20:27:18 <Korollary> go Agile
20:27:20 <dons> oh good :)
20:27:30 <dylan> dons: trying to make it handle my variant-files.
20:27:34 <dylan> I really should explain...
20:27:39 <edwardk> not sure i like it actually, the 90 degree edge on desks like that bite into my wrists.
20:27:45 <dylan> I keep all . files in ~/wc/home/conf
20:28:00 <edwardk> well, forearms really
20:28:02 <dylan> and I'm writing a haskell script to replace a perl script, which symlinks them into ~/
20:28:12 <dons> ok, nice
20:28:29 <dylan> for different machines, I have, say, ~/wc/home/conf/screenrc@frey
20:28:30 <dons> (I use darcs to keep all my . files in ~/src/dotfiles
20:28:45 <dylan> which gets linked to ~/.screenrc if the hostname == frey
20:28:54 <dons> nice system
20:29:10 <dylan> (~/wc/home/conf is a checkout of the SVK path: //home/local/)
20:29:40 <dylan> it takes only a few minutes to bring my config into a new system. :)
20:29:44 <Korollary> You can set up a darcs repo on a regular website, right? You dont need darcs-server unless you want to be able to push?
20:30:13 <dons> Korollary: you don't need darcs-server unless you want to push via http
20:30:20 <dylan> the perl script is really hacky, so I figured this is a good use for haskell. There's seemingly a lot of logic that doesn't need to be in the IO monad. :)
20:30:45 <dons> yeah
20:31:05 <Korollary> He's going to be talking to SPJ
20:31:32 <edwardk> kor: ?
20:31:37 <dylan> I used to keep ~/ under version control, but that's a bit hard.
20:31:47 <Korollary> The interviewer said he'd be talking to MSR Cambridge in August sometime
20:31:53 <dons> $ ls /home/dons
20:31:55 <dons> _darcs          ....
20:31:57 <edwardk> ah
20:32:06 <edwardk> there is a posted tour of the cambridge lab there as well i think
20:32:26 <dylan> Anyway, I have a question
20:32:42 <dylan> Anyone heard of a FUSE (filesystem in userspace) library for haskell?
20:32:51 <dons> sure
20:32:55 <dons> Syntaxninja wrote it.
20:33:01 <dylan> whee!
20:33:01 <dons> oh, sorry.
20:33:12 <dons> for fuse, there's David Roundy's binding
20:33:15 <edwardk> dylan: yeah
20:33:24 <dylan> linky?
20:33:26 <dons> oh, and SyntaxNinja's too, I think
20:33:32 * dons linkifies...
20:33:58 <dons> ?wiki Libraries_and_tools/Operating_system#Filesystems
20:33:58 <lambdabot> http://www.haskell.org/haskellwiki/Libraries_and_tools/Operating_system#Filesystems
20:34:07 <dylan> Thanks!
20:34:30 <dons> Halfs, Fuse, hfuse, ZipperFS :)
20:35:23 <dylan> I have no real purpose for this, other than wanting to play with fuse. :-)
20:36:20 <Korollary> The interviewer thinks that EM looks like a researcher.
20:37:35 <midfield> i want a priority queue.  should i use Edison?
20:38:25 <hitodama> Hmm, is there anyway to get a ghci window inside of Visual Haskell?
20:39:29 <hitodama> or, does anyone know of a nicer version of emacs under windows than vanilla xemacs?
20:40:03 <stepcut> hitodama: you can install cygwin+X, but that is probably a bit overkill
20:40:30 <dons> midfield: well, unless Data.Queue works for you
20:40:57 <dons> using the new edison is not a bad idea, though
20:42:27 <midfield> dons: isn't that just a FIFO queue?  i want a priority queue (a heap?)
20:43:13 <dons> right, so I think you need edison's queues
20:43:22 <dons> ?where edison
20:43:23 <lambdabot> I know nothing about edison.
20:43:29 <midfield> dons: ok.  thanks.
20:44:00 <dons> ?where+ edison http://www.eecs.tufts.edu/~rdocki01/edison.html
20:44:01 <lambdabot> Done.
21:03:04 <_frederik_> FUSE still doesn't have the concept of opening and closing file handles, right?
21:07:42 <lispy> the think that really sucked for me with fuse was broken connections
21:07:59 <lispy> i don't know abotu opening and closing...that seems pretty weird not support
21:15:52 <dons> ?uptime
21:15:52 <lambdabot> uptime: 19 hours, 10 minutes and 51 seconds
21:24:55 <_frederik_> i thought FUSE was all done with named paths, so read and write commands would include a path name. i was working on AVFS, another project of Miklos Szeredi, back when he first started work on FUSE
21:25:07 <_frederik_> and i told him that it was a really bad design
21:27:00 <_frederik_> for instance, the unix 'install' command works by unlinking anything in the destination, and creating a new file. this way, anything which still has the old file open will still see the old data. but with FUSE's design, i think that's impossible
21:37:22 <petekaz> newbie question. I'm trying to write a library for myself that basically simplifies the use of Net.NewCGI, but I am unsure of the correct way to do this.  Ideally, when using this library, I just want the user to define a function called 'processAction'.  So I thought I should make a 'class WebApp where' with that one function.  Then in the file where I use it, I just did an 'instance WebApp of' but it seems that a class has to be
21:37:22 <petekaz> parameterized according to my compile errors?
21:38:16 <petekaz> Is this not the right approach?
21:38:36 <dons> class WebApp MyType where ...
21:38:49 <dons> ah, sorry. instance WebApp MyType where;
21:38:54 <dons> and class WebApp a where
21:39:02 <dons> the type parameter might be a 'phantom' though
21:39:19 <dons> i.e. only used to pick the right instance to use
21:39:24 <petekaz> I see.
21:40:03 <dons> ?pl \c -> h * 33 + ord c
21:40:03 <lambdabot> (h * 33 +) . ord
21:40:13 <dons> ?pl \h -> h * 33 + ord c
21:40:13 <lambdabot> (ord c +) . (33 *)
21:46:31 * edwardk waves ello.
21:47:40 <Tela> The existence of both >>= and =<< is a serious syntax annoyance... Ugh.
21:47:51 <dons> hmm?
21:47:59 <dons> =<< is generally less used
21:48:00 * edwardk just wasted an hour writing a 'shim' for his second monitor's resolution so the desktop wouldn't try to display outside of the region the physical display suppports.
21:48:11 <dons> most often seen only in: return . f . g . h =<< someIO
21:48:13 <dons> style code
21:48:16 <edwardk> tela: why is it annoying?
21:48:25 <johnnowak> Tela: just rename them to alligator-coming and alligator-going
21:48:26 * edwardk finds =<<<< useful some times.
21:48:33 <Tela> I was reading some code and ran across =<<... I'm a little dislexic and it took me a while to figure out why that section made absolutely no sense
21:48:40 <edwardk> ahh
21:48:49 <dons> ah well. now you know :)
21:49:08 <Tela> hehe, hopefully
21:52:07 <midfield> i'm having trouble getting haddock to deal with NewBinary.  any hints?
21:54:20 <edwardk> NewBinary?
21:54:30 <dons> ?where NewBinary
21:54:30 <lambdabot> darcs get http://www.n-heptane.com/nhlab/repos/NewBinary
21:54:47 <midfield> lambdabot uses it, right dons?
21:55:00 <edwardk> hahaha. hoogling for it mentions 'Lambdabot says: darcs get ... ' =)
21:55:22 <edwardk> new feature?
21:57:14 <midfield> edwardk: it's a library for binary IO, serializing, etc.
21:58:33 <edwardk> ah
22:00:22 <midfield> i feel like NewBinary should point to Binary which is at http://www.haskell.org/nhc98/libs/Binary.html
22:00:24 <lambdabot> Title: Using the NHC.Binary library
22:00:34 <midfield> lol
22:00:41 <dons> midfield: yep
22:01:46 <midfield> dons: can you answer questions about NewBinary / Binary?
22:02:16 <dons> yep?
22:02:48 <edwardk> @seen shapr
22:02:49 <lambdabot> I haven't seen shapr.
22:02:59 <midfield> dons: great.  i will ask some soon i'm sure!
22:03:32 <edwardk> hrmm. is anyone here familiar ith the symmetric lambda calculus?
22:05:18 * edwardk has been playing with what would constitute a symmetric pure type system. it seems to require the idea of codependent types which are just weird =)
22:08:25 <tessier> Why do functional programmers seem to sit around and talk about theory and never generate any killer apps while imperative programmers talk about how to actually do stuff and write operating systems, web browsers, and things that change the world?
22:08:39 <edwardk> tessier: heh
22:08:46 <Patterner> what about darcs?
22:08:50 <tessier> Just an observation as I read through my haskell book and lurke on this channel. :)
22:08:55 <tessier> I've been here and in #lisp for many months now.
22:09:00 <tessier> Patterner: WTF is darcs?
22:09:16 <tessier> Patterner: If you think darcs is a killer app...
22:09:17 <edwardk> tessier: its version control system
22:09:27 <Patterner> it is for me :)
22:09:30 <edwardk> heh
22:09:40 <tessier> Most people have no use for a version control system. The vast majority of those who do have never heard of darcs.
22:09:44 <dons> tessier: check out haskell.org for operating systems, web servers, revision control....
22:09:45 * johnnowak likes darcs.
22:09:51 <edwardk> it _is_ the first cvs type piece of software i've really liked
22:09:59 <tessier> I think functional programming has a lot of potential. I just wonder why the functional world keeps marginalizing itself.
22:10:13 <dons> tessier: I mean, clearly trolling, right? Since we are writing new apps all the time...
22:10:18 <dons> ?version
22:10:18 <lambdabot> lambdabot 4p72, GHC 6.4.2 (Linux i686 2.80GHz)
22:10:19 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:10:20 <johnnowak> tessier: that's a bunch of nonsense... most imperative programmers sit around on irc and do the same thing :)
22:10:23 <tessier> dons: I have seen it. And I know about HOUSE etc.
22:10:23 <dons> for example :P
22:10:40 * Patterner waits for KDE5 in Haskell
22:10:42 <dons> so, quit trolling then.
22:10:44 <tessier> dons: Actually, not trolling.
22:11:11 <tessier> dons: Is there a single piece of software written in a functional language included in any Linux distro?
22:11:24 <Patterner> does OCaml count?
22:11:25 <dons> Linspire uess Haskell for its distro tools...
22:11:28 <edwardk> tessier: the linspire folks write all their stuff in haskell
22:11:33 <dons> what about pugs, eh?
22:11:34 <tessier> dons: Right. And that is the only one I can cite also.
22:11:39 <dons> perl6 written in haskell
22:11:50 <Patterner> There is no Perl6 atm...
22:11:53 <dons> or the new debian-iso stuff written in haskell
22:11:56 <tessier> Patterner: I'm not aware of anything written in OCaml being part of a distro.
22:12:13 <wolverian> Patterner, but pugs is a significant amount of a perl6 :-)
22:12:18 <dons> then there's things like darcs, available with most distros now. mldonkey, comes with most things
22:12:19 <thetallguy> The Linspire hardware detector is written in O'Caml.
22:12:26 <tessier> I know perl6 is written in haskell but it doesn't come with any distro and it isn't clear that it will be the canonical perl6.
22:12:42 <tessier> thetallguy: It seems like they are leaning towards rewriting it all in haskell.
22:12:49 <tessier> thetallguy: I had lunch with the Linspire guys a few weeks ago.
22:12:51 <thetallguy> In time.
22:12:52 <Patterner> define "part of a distro"... available for install? included in the base system and installed by force?
22:13:00 <wolverian> it's available in debian and ubuntu.
22:13:06 <tessier> thetallguy: Ah. You work for Linspire?
22:13:14 <thetallguy> tessier: That was a least  a month agol.
22:13:19 <tessier> right
22:13:29 <dons> so, anyway, for a small community, i'd say the fp world, or at least ocaml and haskell, have been pretty productive, and growing rapidly.
22:13:37 <edwardk> tessier: technically 'perl6' unlike perl5 is supposed to refer to a language not an implementation. in perl5, Perl 5 referred to the language and perl5 to the particular implementation that was he only implementation, but im being pedantic ;)
22:13:40 <tessier> I am impressed with haskell so far.
22:13:51 <Patterner> tessier: i know a lot about perl6 :)  guess why i'm here...
22:13:54 <thetallguy> We are working on a new autobuilder and associated tools to manipulate Debian packages and archives.
22:14:04 <thetallguy> We will move on from there.
22:14:07 <tessier> cool
22:14:07 <wolverian> I consider it great progress for such a non-industry-sexy language.
22:14:16 <dons> tessier: so dive in and write some killer apps :)
22:14:16 <tessier> So I'm just wondering why functional programming is such a hard sell.
22:14:18 * johnnowak is optimistic about Perl 6... nice to see some very interesting features being brought to a larger audience
22:14:24 <Patterner> Let's write the Parrot in Haskell too
22:14:25 <midfield> ok noob question: how do i pattern match on the pieces of a record type?
22:14:27 <wolverian> (at least to those who want to hire _lots_ of coders instead of _good_ coders)
22:14:28 <johnnowak> tessier: It's hard.
22:14:30 <edwardk> anyways i will admit that most of what functional programmer seem to do is write functional programming languages =)
22:14:36 <Patterner> CODE MONKEYS FOR HIRE
22:14:48 <tessier> edwardk: Exactly. :) I see lots of papers on functional languages.
22:14:50 <wolverian> edwardk, or turn imperative languages into functional ones..
22:15:06 <midfield> tessier: well i'm in the middle of porting lucene to haskell. does that make you happy?
22:15:16 <tessier> midfield: What is lucene? :)
22:15:18 <Patterner> Functional C = FuC..?
22:15:44 <johnnowak> Patterner: FunC sounds better. in multiple ways. :)
22:16:00 <tessier> "We put the FunC in Funktion"
22:16:04 <johnnowak> first four letters of function, fun + c, sounds like Funk...
22:16:06 <tessier> Someone change the topic. :)
22:16:08 <edwardk> tessier: its an unfortunate consequence of the selection process that obtains functional programmers for you. you get people who really really like abstraction, and are used to playing with small languages, well, once they have their language they might as well parse and compile it...
22:16:09 <johnnowak> yes, someone write FunC please. :)
22:16:55 * edwardk still wants to write a language named sex, simply because no one will claim that their language is better than sex.
22:16:58 <thetallguy> I think FP is also a hard sell because it's like flying by wire
22:16:59 <Patterner> I think the intersection between Haskell and C is the empty set.
22:17:00 <midfield> tessier: the full-text search engine behind, oh wikipedia, sourceforge, etc...
22:17:17 <edwardk> It also comes premade with nice book titles, 'the joy of sex', etc. =)
22:17:23 <Patterner> well, chocolate is better than sex.
22:17:24 <dons> Patterner: that can't be true. you've got alloca and malloc in Haskell too :)
22:17:41 <tessier> edwardk: The most common complaint I hear from experienced programmers about functional languages is that due to the desire of functional programmers to write compilers you always get a dozen implementations of any one functional programming language and no decent libraries since writing common libraries isn't sexy.
22:17:49 <thetallguy> Many people feel removed from the nitty gritty
22:17:52 <Patterner> dons: those are Abominations Upon Nuggan and are discarded
22:17:57 <thetallguy> And they like the nitty gritty
22:17:58 <edwardk> patterner: well, then  you could release that as the arguably improved version, the cayenne or clean to its haskell
22:18:10 <edwardk> tessier: yeah.
22:18:14 <tessier> So there is no one compiler that people feel they can get behind and there is no standard library for doing basic things like talking to the outside world.
22:18:19 <wolverian> tessier, that's a good point. CHAN, anyone?
22:18:22 <tessier> Perl and Python have huge and great libraries. Java too for the most part.
22:18:33 <Patterner> Cabal is standard right?
22:18:35 <wolverian> (but of course it's happening.. Cabal)
22:18:37 <tessier> Hopefully Haskell can be the functional language that solves that problem.
22:18:39 <dons> Cale: right
22:18:43 <dons> Patterner: right
22:19:12 <edwardk> yeah haskell seems to be more of an exception to that rule than normal
22:19:13 <dons> ghc is the standard compiler, and the FFI standard, is the standard way to talk to the outside world,in Haskell, btw ;)
22:19:17 <thetallguy> tessier: You using FP at work?
22:19:32 <thetallguy> I remember you saying you were heading that direction.
22:20:15 <tessier> thetallguy: Not yet. Still not good enough at it. Doing python for the moment. But once I make some decent progress on it at home I will consider introducing it at work.
22:20:17 <Patterner> offer me a job where i can do Haskell the whole day and I'll accept in a heartbeat
22:20:29 <edwardk> patterner: i hear you there =)
22:20:36 <tessier> Have way too much basic sysadmin stuff on my plate for at least the next month before I can really get into any programming projects.
22:21:01 <tessier> Lately I have been wondering how to apply functional principles to system configuration management a la cfengine
22:21:07 <Patterner> i'm stuck with Python and Java (and Perl for my 'private' stuff :)
22:21:18 * edwardk wonders if he should try to set up an interview at galois when he is over there for the icfp.
22:21:30 <midfield> dons: how do i write a null byte in NewBinary?
22:21:52 <johnnowak> tessier: a lack of libraries is only a problem if it lacks the ones you need
22:21:56 <tessier> Also been pondering a zope-like system in haskell.
22:22:02 <johnnowak> tessier: several functional or quasi-functional languages have all I desire :)
22:22:21 <johnnowak> well, except a couple things.. but Java doesn't have them either.
22:22:32 <tessier> johnnowak: True. But try explaining that to the programmers out there used to CPAN or Java's standard class lib.
22:22:32 <thetallguy> Nuts. it seems that Language.Haskell.Syntax  doesn't support comments.
22:22:34 <Adamant> Haskell is "functional-only", right?
22:22:41 <tessier> Adamant: purely functional, yes
22:22:53 <tessier> Adamant: You can't do imperative programming as well like you can with something like lisp
22:22:55 <thetallguy> tessier: a sane move.
22:23:08 * Patterner writes Perl2Haskell.php
22:23:09 <Adamant> closures don't work?
22:23:14 <edwardk> tessier: unless you could the do notation.
22:23:19 <wolverian> Patterner, auuughhh.
22:23:40 <tessier> thetallguy: Yeah. I gotta be careful not to get in over my head with the cool new technologies. I hate it when a project stalls because we just don't know enough about what we are doing to pull it off.
22:23:51 <Adamant> PHP Must Die!
22:23:58 <johnnowak> Adamant: god. yes.
22:24:03 <Patterner> that's why managers love Java... lots of code monkeys from the universities...
22:24:09 <thetallguy> tessier: The very reason we took so long to standardize on Haskell.
22:24:20 <Adamant> heh, now they are teaching us PHP at my Java School
22:24:23 <thetallguy> It's a fair amount of work.
22:24:23 <tessier> Patterner: Yeah. And lots of crap code. :(
22:24:27 * johnnowak actually saw a job posting on craigslist seeing Lisp programmers last week
22:24:32 <edwardk> and you can get lines of code out of them so they appear to be productive even when they spin their wheels
22:25:01 <Patterner> tessier: but many lines of code for the buck!!1
22:25:14 <tessier> Patterner: That must be a good value. Right? :)
22:25:27 <johnnowak> any program written in less than 100,000 lines isn't worth using.
22:25:31 <Patterner> LoC is easy in Java... One line of Perl is ~30 lines of Java...
22:25:42 <edwardk> john: spoken like a true java programmer =)
22:25:45 <Patterner> tessier: tiny manager brains think so
22:25:48 <johnnowak> edwardk: :)
22:25:54 <thetallguy> johnnowak: grep, ls, more, find
22:26:00 <johnnowak> thetallguy: i'm teasing :)
22:26:06 <thetallguy> sorry
22:26:08 <thetallguy> reflex
22:26:12 <Patterner> thetallguy: kgrep kls ktrue :)
22:26:16 <johnnowak> thetallguy: can't say i blame you. :)
22:26:30 * johnnowak awaits the arrivial of KKDE
22:26:42 * edwardk collected all of the sun certificates on a lark. I hope to never use the language for anything more substantial than plugging a missing feature in cocooon now and again ever again.
22:26:48 <thetallguy> johnowak
22:26:59 <thetallguy> oddly, I talked about that with Aaron Seigo.
22:27:07 <thetallguy> KDE developer...
22:27:15 <johnnowak> mmm..
22:27:36 <thetallguy> He didn't really take us seriously.
22:27:40 <johnnowak> hehe
22:27:44 <tessier> midfield: So it seems lucene is currently written in Java. How's the
22:27:48 <tennin> never having to learn Java is one of my major career goals
22:27:48 <tessier> er..
22:27:58 <tessier> midfield: How do you find mapping imperative to functional?
22:27:59 <edwardk> tennin: good luck with that
22:28:00 <johnnowak> tennin: it only takes a weekend
22:28:00 <thetallguy> I'll have to send him the definition of ``blindsided''
22:28:05 * tessier has never had to learn java
22:28:16 * johnnowak has had to learn Java...
22:28:17 <tessier> I played with it for a few weeks back in 97 or dumped it
22:28:24 <tessier> s/or/and/
22:28:26 <Patterner> java is easy
22:28:34 <thetallguy> But seriously, wh doesn't Language.Haskell.Syntax support comments?
22:28:34 <Patterner> learning the libraries is not...
22:28:37 <thetallguy> Most annoying.
22:28:44 <tessier> Patterner: Right. And it seems to have a lot of boiler plate.
22:28:48 <edwardk> java doen't suck as bad as it could, but it doesn't really favor good oo design practice so much as pay it lip service.
22:28:50 <thetallguy> Learning libraries is never easy.
22:29:01 <Patterner> J2EE is terrible
22:29:20 <Patterner> everthing with Enterprise is bloated (unless it's a tv series)
22:29:24 * johnnowak doesn't even really know what J2EE is
22:29:42 <edwardk> patterner: yeah. there is a lot to be said for bundling up services as POJOs =)
22:29:55 <johnnowak> ugh. Enterprise was worse than Voyager.
22:30:03 <tennin> yeah, I more or less have the gist of the language from seeing so many code snippets in various places
22:30:12 <midfield> tessier: i think the big thing for java is mapping OO to functional.  it's great, IMHO.  i think it has been a good exercise for me so far.  a literal mapping is impossible and stupid.  when you're done usually the code is a tenth the size, easier to read and safer.
22:30:23 <edwardk> johnnowak: think of it as a set of standardizes services provided by the java environment.
22:30:27 <Patterner> johnnowak: true, but it wasn't bloated
22:30:31 <johnnowak> edwardk: ah
22:30:34 <johnnowak> Patterner: fair enough. :)
22:30:53 <Patterner> (Shatner is bloated :)
22:31:20 <edwardk> johnnowak: when writing java code you basically get to pick a target platform J2ME, J2EE, etc. and that lets you know what you can expect to have access to, XML services, etc.
22:31:45 <johnnowak> edwardk: ah, makes sense then. thanks.
22:31:54 <edwardk> the idea being that if the container provides the whole ball of wax its a lot easier for developers.
22:32:03 <edwardk> just the bundles are pretty bloated.
22:32:12 <johnnowak> edwardk: doesn't that ruin all the fun though of hunting down SRFIs and picking the least bad module system for the task?
22:32:15 <Patterner> J2ME is easy because it's Java for Mobile Systems and a lot smaller than the other J2-thingies
22:32:44 <edwardk> john: in theory =), but take for example cocoon, which needs so many things beyond j2ee, so you wind up installing 50 jars of stuff anyways =)
22:32:44 <midfield> tessier: often i don't read the java code.  haskell lets you code in a style where you specify the description of the code via very expressive types, and then the code just comes out...
22:33:22 <midfield> tessier: so i just use the spec of the file formats and algorithms and go from there.
22:33:43 <ThreeQ> hey, what exactly is unsafe about unsafeInterleaveIO?
22:33:49 <Patterner> edwardk: 114 jars
22:34:13 <edwardk> patterner: yeah thats about right, i haven't counted in a while =)
22:34:42 <edwardk> mmine is probably a bit worse coz i have all sorts of other blocks installed for xsl:fo, and charting beyond the base install
22:34:49 <tessier> midfield: Yeah, that is one of the things I like about haskell. How you specify what you want instead of so much emphasis on how to do it.
22:34:54 <dons> ThreeQ: its possible to accidentally interleave reads from a file, if you're not careful about locking
22:35:34 <dons> (Handles lock themselves, to  prevent this)
22:35:39 <ThreeQ> ah
22:35:49 <midfield> ok i give up, how do i make fromIntegral give me a Word8?
22:36:00 <ThreeQ> that makes sense
22:36:04 <dons> > fromIntegral (1 :: Int) :: Word8
22:36:07 <lambdabot>  1
22:36:18 <dons> ?type fromIntegral (1 :: Int) :: Word8
22:36:19 <ThreeQ> I guess I was thinking of "unsafe" in the sense of "can use this to implement coerce :: a -> b"
22:36:19 <lambdabot> Word8 :: Word8
22:36:20 <midfield> dons: thanks
22:36:28 <dons> ThreeQ: no, not like that :)
22:36:56 <dons> unsafe only rarely means "breaks the type system", thankfully :)
22:37:08 <midfield> dons: so i can write a null byte with "put_ bh (fromIntegral(0::)::Word8)" ?
22:37:09 <dons> i.e. unsafeCoerce# and unsafePerformIO
22:37:10 <ThreeQ> hehe
22:37:18 <dons> midfield: works for me.
22:37:32 <dons> but, midfield (0 :: Word8) works just as well
22:37:47 <dons> i.e. put_ bh (0 :: Word8)
22:37:59 <dons> will dispatch to the Binary instance for Word8
22:38:49 <dons> examples: http://www.cse.unsw.edu.au/~dons/code/lambdabot/Lib/Binary.hs
22:39:15 <midfield> dons: thanks
22:40:03 <dons> I ought to just package up NewBinary with lots of instances, and haddockise it.
22:40:03 <dons> hmm
22:41:03 <petekaz> Can I not do this:
22:41:13 <petekaz> test :: Maybe String -> Maybe Int
22:41:14 <petekaz> test marg = do
22:41:15 <petekaz>   Just arg <- marg
22:41:16 <petekaz>   return $ read arg
22:41:28 <midfield> dons: please?
22:41:45 <dons> petekaz: marg is pure, right?
22:42:05 <dons> test (Just arg) = read arg ; test _ = error "Nothing" -- ?
22:42:08 <midfield> dons: where's your paypal button? :)
22:42:15 <dons> hehe.
22:42:20 <dons> maybe I should try that... hmm!
22:42:38 <dons> though i should finish my dissertation first
22:42:57 <petekaz> test is passed 'Just "10"' as an arg when I call it.
22:43:23 <lisppaste2> petekaz pasted "ghc error message" at http://paste.lisp.org/display/24423
22:43:31 <petekaz> that is my error.
22:44:05 <petekaz> I though one could unpackage the Maybe in a do expression.
22:44:05 <dons> > let test (Just x) = read x :: Int ; test _ = undefined in test (Just "10")
22:44:11 <lambdabot>  10
22:44:13 <midfield> dons: me too!
22:44:21 <dons> > let test (Just x) = read x :: Int ; test _ = undefined in test (Just "x")
22:44:22 <lambdabot>  Exception: Prelude.read: no parse
22:44:23 <midfield> dons: stupid dissertation.
22:44:26 <dons> > let test (Just x) = read x :: Int ; test _ = undefined in test Nothing
22:44:28 <lambdabot>  Undefined
22:44:31 <dons> midfield: hehe. right!
22:45:00 <midfield> dons: at least you're in CS.....i REALLY shouldn't be doing this.
22:45:09 <dons> oh. heh
22:45:25 <dons> yeah, I can usually swing the side projects as related somehow
22:51:40 <Adamant> give in to the dark side
22:52:04 <Adamant> join the CS group, and you will be more powerful than ever before!
22:52:14 <dolio> petekaz: The problem in your code is "Just arg <- marg". The "<-" takes it out of the monad, so matching it with "Just arg" makes the compiler think it's Maybe (Maybe String)
22:52:27 <dolio> petekaz: You want: "arg <- marg"
22:53:16 <dons> I think that dropping into the Maybe monad is overkill here, though
22:53:20 <dons> just pattern match
22:53:40 <dolio> Probably.
22:53:52 <dolio> It's two lines either way.
22:54:31 <midfield> dons: any tips on how to implement "get" for null-terminated strings?
22:55:59 <dons> read them char-by-char? or use an ffi binding to a C function that reads back a CString?
22:56:12 <dons> then pack the CString into a ByteString?
22:56:43 <dons> (i.e. have a look at the ByteString instance in the Binary.hs i mentioned above)
22:57:09 <dons> heh,    Compatible compilers must supports the following recent c++ techniques:
22:57:09 <dons>    * Partial template (function) specialization.
22:57:09 <dons>    * Explicit template (member) function instantiation.
22:57:10 <dons>    * Treat void return as normal return.
22:57:20 <dons> and they say Haskell needs standardisation
22:57:41 <midfield> dons: hmm.  i'm beginnning to reconsider the current binary format.
22:57:56 <dons> midfield: better to store as a ByteString, if you're reading and writing
22:58:07 <dons> then you store the size and the bytes directly, so its a simple read
22:58:18 <dons> depends on what you're doing though
22:59:13 <midfield> dons: here's the issue.  i have a datatype which is two strings, a number and a bunch of data.  i need to sort an enormous collection of them by the two strings lexographically then the number.  the data is ignored for sorting purposes.
22:59:33 <dons> ok
22:59:46 <midfield> dons: there are so many of them i need to do an offine (external) sort: i sort chunks of them, spool to disk, then at the end mergesort.
23:00:00 <dons> ok
23:00:57 <midfield> dons: hence the need to go to a binary serialization.  the usual way of serializing strings though is (length, data), which isn't amenable to direct ByteString comparison to get the right order.
23:01:11 <midfield> hence the desire to go to null-terminated strings.
23:01:17 <dons> hmm?
23:01:35 <dons> you wan tthe length though, to make the reads efficient, no?
23:01:37 <midfield> (this is not my design, by the way.)
23:01:49 <dons> since you just read a block of size 'n'
23:01:54 <dons> rather than scanning for \0
23:01:59 <dons> ah, well, if you can't work around it
23:02:22 <midfield> the workaround would be to write a comparison function on ByteStrings which plucks out the sub-ByteStrings.
23:02:40 <midfield> dons: is there an efficient way of doing that?
23:02:44 <dons> you can't store a list of bytestrings directly?
23:03:21 <dons> there's a few substring functions already, though. maybe you could use them?
23:03:27 <dons> or use memmem?
23:03:32 <midfield> i mean, i'm going to have a list of bytestrings, but they are composed of (length, string, length, string, number, data)
23:03:45 <midfield> and i want to sort them on the concatenation of the two strings plus number
23:03:46 <dons> ah
23:07:13 <midfield> by the way i'm going to need your revised NewBinary, for FPS support (and i was serious about paypal, though i'm poor!)
23:07:29 <dons> well, just grab the Binary.hs from lambdabot or hmp3
23:07:37 <dons> (or just take the FPS instance for Binary)
23:07:48 <dons> Its free to a good home!
23:08:08 <dons> http://www.cse.unsw.edu.au/~dons/code/hmp3/Binary.hs
23:08:38 <monochrom> Does "good home" mean someone has to cabalize it or darcize it or something?
23:09:39 <dons> NewBinary is cabalised and darcsified
23:09:40 <midfield> i hope not!
23:09:50 <dons> my Binary.hs is free to anyone, as a standalone module
23:27:47 <midfield> i hate unicode almost as much as i hate java
23:28:04 <johnnowak> what did unicode ever do to you?
23:28:06 <edwardk> mid: ?
23:28:35 <midfield> it's bitten me in the ass more than anything other standard.
23:29:10 <midfield> in a former life i wrote an object database for common lisp.  going back and forth between c and lisp and unicode is a nightmare.
23:29:34 <midfield> sorting is always hard.
23:29:45 <midfield> i dunno i'm just grumpy right now.  sorry for the rant.
23:30:45 <edwardk> sorting unicode sucks, coz a proper sort is locale dependent =/
23:31:14 <midfield> and encoding is locale dependent too
23:31:47 <monochrom> woah?  sorting depends on locales yes, but unicode encoding?
23:32:15 <edwardk> er sorting =)
23:32:20 <edwardk> sorry was distracted =)
23:37:02 <dons> life's too short to code in C++
23:37:36 <monochrom> life's too short to critique C++  XD
23:38:14 * dons goes back to writing Haskell 
23:39:02 <monochrom> don't work too hard
23:39:04 <midfield> http://www.cl.cam.ac.uk/~mgk25/unicode.html#c
23:39:06 <lambdabot> Title: UTF-8 and Unicode FAQ
23:40:16 <monochrom> ok, you mean choosing an encoding other than UTF-8 is locale dependent.
23:40:32 <monochrom> So, always insist on UTF-8.
23:41:46 <midfield> monochrom: the problem is unicode != UTF-8.  sometimes you don't have control.
23:43:45 <monochrom> How do you mean?
23:45:25 <edwardk> sorting is the hard part wth unicode, the encoding is pretty painless. the only issue is that strings cease to be nicely random-access.
23:45:37 <edwardk> at least in a utf-8 representation.
23:45:48 <edwardk> though, even a utf-16 rep loses random access in the face of higher planes.
23:46:42 * edwardk is really annoyed at javascript. it insists on a broken utf-16 implementation, and not letting you encode higher plane values in a single character. =/
23:48:29 <monochrom> UTF-8 is just for communication between programs.  Programs should store and work on 32-bit characters, and those are pretty random-access, right?
23:49:29 <edwardk> working and storing in utf-32 is a question of how much data you work on and how much non-sequential access you need.
23:53:03 <dons> ?aspell deferred
23:53:26 <dons> ?spell test
23:53:39 <dons> ah, no aspell installed, I think
23:54:25 <tessier> So what is the most common web application framework to use if you want to code a webapp in haskell?
23:54:40 <tessier> And are there any databases being implemented in haskell to use with it?
23:55:30 <dons> HAppS? WASH? haskelldb? hsql? Hope?
23:55:40 <dons> check the details on haskell.org under 'libraries and tools'
23:55:43 <dons> ?where happs
23:55:43 <lambdabot> I know nothing about happs.
23:55:57 <tessier> Any one of those in particular in the lead as far as functionality, maturity, and mindshare go?
23:55:57 <dons> ?google happs haskell
23:56:00 <lambdabot> http://happs.org/HAppS/README.html
23:56:00 <lambdabot> Title: HAppS -- Haskell Application Server (version 0.8 )
23:56:08 <lispy> ?where lispy's pants
23:56:08 <lambdabot> I know nothing about lispy's.
23:56:09 <dons> probably wash or happs these days
23:56:17 <lispy> ?where lispy's_pants
23:56:18 <lambdabot> I know nothing about lispy's_pants.
23:56:26 <dons> ?where+ happs http://happs.org/
23:56:26 <lambdabot> Done.
23:56:29 <dons> ?where WASH
23:56:29 <lambdabot> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
