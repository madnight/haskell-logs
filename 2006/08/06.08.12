00:00:42 <SamB_XP> so you can write (isAscii `op` negationFunction isDigit) or something like that...
00:00:48 <Heffalump> tibbe: I think it's a bad idea to try to combine parsers with negation
00:00:57 <tibbe> then for each group of tokens I want to parse I need one parser, say: tok and one list, toks
00:01:06 <SamB_XP> I guess (isAscii `op` not . isDigit) would work fine
00:01:12 <Heffalump> it'll damage their efficiency, because they have to consider the more general case where they are parsing a longer string than one token/character
00:01:17 <tibbe> that ascii digit case is fine
00:01:22 <SamB_XP> but you'd have to pick a nice op
00:01:30 <tibbe> any OCTET excluding ALPHA, DIGIT, reserved, extra, safe, and unsafe
00:01:46 <SamB_XP> well, if you used list of chars instead of parsers...
00:01:49 <tibbe> where the tokens to be excluded are defined in a similar manner
00:01:53 <SamB_XP> er, lists
00:02:14 <tibbe> SamB_XP, I do but sometimes I need the parser and sometimes I need the list so there's some duplication
00:02:21 <SamB_XP> oneOf
00:02:33 <tibbe> yes
00:02:49 <tibbe> but it still doubles the amount of definitions
00:02:58 <tibbe> since there's one per parser and one per list
00:03:04 <tibbe> (or almost)
00:03:08 <SamB_XP> eh, you don't need to write defs for the parsers
00:03:28 <tibbe> but they're reused sometimes and then that's nice to have
00:03:40 <SamB_XP> alternatively, you could invest in a lexer
00:03:42 <tibbe> but I guess I should go with alot of isXXX instead of parsers
00:03:55 <tibbe> SamB_XP, hmm yes
00:04:10 <tibbe> but I think that the groups are overlapping
00:04:26 <SamB_XP> hmm, probably.
00:04:46 <u221e> Anyone happen to know of a good i386 CPU emulator?
00:04:58 <tibbe> and alot of satisfy isXxxGroup lots alot uglier in the parsers
00:05:15 <tibbe> @pastebin
00:05:16 <lambdabot> Unknown command, try @list
00:05:35 <u221e> I just want one that emulates the CPU, not a full system emulator like bochs or qemu
00:06:29 <SamB_XP> I suppose you'd need <?>'s too
00:06:39 <xerox> Cale: can one implement prolog's CUR operator in the list monad?
00:06:49 <Cale> xerox: CUR?
00:06:54 <xerox> Oops, I mean CUT.
00:07:12 <xerox> (And I am lagged.)
00:07:14 <tibbe> SamB_XP, what does it do?
00:07:28 <SamB_XP> tibbe: it improves error messages
00:07:40 <tibbe> ah yes, I remember now
00:07:52 <tibbe> it's on the todo list
00:08:07 <SamB_XP> which is pretty vital when using satisfy, because satisfy does not have any information to go on
00:08:09 <falconair> is it possible to create operators in haskell which 'surround' their operands rather than being in prefix or infix? ... for example, if i wanted to define my own list comprehension [ blah | blahblah  ]
00:08:16 <SamB_XP> outfix?
00:08:28 <SamB_XP> no, you can't make outfix operators
00:08:39 <falconair> is that actually called outfix?
00:08:46 <SamB_XP> sometimes
00:08:55 <xerox> Cale - i.e. for having this code halt nicely: factors 1 = mzero; factors n = do { p <- primes; if n `mod` p == 0 then return p `mplus` factors (n `div` p) else mzero }
00:09:00 <Cale> xerox: not exactly
00:09:06 <Cale> xerox: you can takeWhile
00:09:09 <falconair> heh, good to know, thanks SamB_XP
00:09:22 <xerox> Cale, allright.
00:09:26 <Cale> xerox: You'd have to add an extra dataconstructor to lists to really get it.
00:09:34 <SamB_XP> especially in the type [a]
00:09:52 <xerox> Cale - How would it look like?
00:10:59 <Cale> xerox: When joining, you'd takeWhile (notCut), I think
00:11:11 * edwardk kinda wondered why we don't have any 'outfix' operators in haskell. The syntax (. foo .) is unambiguous right? it can't be legal now can it?
00:11:16 <xerox> Cale - Ah, makes sense! Thank you.
00:11:35 <edwardk> or (^ bar ^)
00:11:41 <SamB_XP> @type (\x -> (. x .))
00:11:42 <lambdabot> parse error on input `)'
00:12:16 <edwardk> or a [. b .]   for some sort of array like accessor mixing up the pool of notations a bit
00:12:57 <Heffalump> edwardk: trying to avoid kitchen sink mentality?
00:13:02 <edwardk> heff: sure
00:13:13 <edwardk> heff: but you have to admit haskell's array accessors look like ass =)
00:13:17 <Heffalump> the more people add, the more the burden on implementors
00:13:19 <Heffalump> I don't mind them
00:13:30 <Heffalump> and my day job is C(++) programming
00:13:34 * edwardk shrugs
00:13:46 <profmakx> morning
00:13:47 <edwardk> its all sugar anyways
00:14:17 <profmakx> not only on the implementors i suppose. the more features a language has, the more features a programmer would have to learn
00:14:31 <profmakx> (understand and use...)
00:15:00 <edwardk> prof: yeah. just adds another set of useful notations. lord knows mathematicians like to throw new brackets at us. =)
00:15:08 <edwardk> bananas and lenses anyone? =)
00:15:25 <SamB_XP> and think of the future generations and what would happen if we would waste syntax on things like user-defined outfix operators!
00:15:40 <edwardk> heh
00:15:58 <profmakx> and will anyone think abou the children!
00:15:59 <edwardk> well, a boy can dream can't he? =)
00:16:05 * edwardk twitches.
00:16:06 <SamB_XP> also, try to keep Haskell from looking like Perl ;-)
00:16:20 <edwardk> too late. you guys use way too many operators for that
00:16:21 <falconair> is it technically difficult to add outfix to a language? wouldn't you basically have a macro system then?
00:16:38 <edwardk> =)
00:17:01 <SamB_XP> well, if we added outfix like *you* mean, yeah sure
00:17:10 <edwardk> ehehehe
00:17:20 <falconair> is there another kind of outfix?
00:17:21 <SamB_XP> but if we added outfix that basically defined functions with a bracket-like notation, that wouldn't
00:17:29 <edwardk> just noticed a gap in the syntax where another feature could be shoehorned
00:17:38 <Heffalump> if then else is kind of outfix
00:17:40 <SamB_XP> it would juts be ... really wierd ...
00:17:56 <profmakx> well
00:19:37 * edwardk goes back to playing with type level monads. :>>= anyone? =)
00:20:34 <Heffalump> anyone got any hints on handling variables when writing a GADT-based type-safe interpreter?
00:20:58 <edwardk> heff: haven't gotten there yet in mine
00:21:15 <SamB_XP> Heffalump: run for your life!
00:21:23 <Heffalump> I was just writing a C interpreter for other reasons (well, for a subset of C) and realised I should be using GADTs
00:21:28 <SamB_XP> uhm, Data.Dynamic?
00:21:45 <Heffalump> that doesn't sound very type safe :-)
00:21:51 <SamB_XP> it is!
00:22:09 <Olathe> I'm trying to follow a tutorial along in WinHugs. How do I do all three of these on one line: head :: [a] -> a, head (x:xs) = x, head([1, 2])
00:22:15 <SamB_XP> well, as long as you do it right anyway...
00:22:28 <Heffalump> only runtime type safe, surely
00:22:31 <Heffalump> I can get that without GADTs
00:22:47 <SamB_XP> I mean, you have to typecheck the code first if you want to avoid runtime type errors...
00:22:49 * edwardk started building the javascript stuff as gadts then decided it would be better compiled and moved it all into template haskell
00:23:04 <SamB_XP> and I don't think you can stuff variables of different types into a single Map...
00:23:08 * Heffalump is relatively experienced with GADTs, having used them for some darcs prototyping
00:23:15 <Heffalump> SamB_XP: well, you can if you quantify out the different types
00:23:20 <SamB_XP> hmm
00:23:40 * Heffalump decides to get this working without GADTs and then see if he can add them
00:23:48 <SamB_XP> I really need sleep
00:23:55 <SamB_XP> I should have gone hours ago...
00:24:05 <SamB_XP> curse you, GPF and Zortic...
00:24:28 <xerox> Olathe: function definition deserves a line on its own: head (x:xs) = x :: [a] -> a; but as you see you can embed the type. Please note you must write this in a .hs file and load it in the interpreter, you can't add new bindings in Hugs directly as far as I know. After loading the module, you can evaluate `head [1,2]' by typing it in the interpreter.
00:27:51 <falconair> so, can i get close to the following DSEL syntax: "sum abs(x) for x in list and y in list2 if x<10 and x=y" (should be the same as "sum [abs x | x <-list; y <-list2; x < 10; x == y]" (if i got the haskell syntax right)
00:28:56 <Olathe> I get "ERROR file:.\test.hs:1 - Inferred type is not general enough
00:29:29 <Olathe> Let me examine a working Haskell file.
00:31:30 <xerox> @paste
00:31:30 <lambdabot> http://paste.lisp.org/new/haskell
00:32:08 <lisppaste2> Olathe pasted "test.hs" at http://paste.lisp.org/display/24018
00:38:48 <nostromo> I discovered fairly quickly this idiom to test "definitions": let head (x:xs) = x in head [1,2,3]
00:42:23 <SamB_XP> > let head (x:xs) = x in head [1,2,3]
00:42:24 <lambdabot>  1
00:42:31 <SamB_XP> we use that here too ;-)
00:43:05 * merus dicks around with PA
00:43:16 <xerox> nostromo: right, but you can't do that in Hugs AFAIK.
00:43:22 <nostromo> it is similar to the let in scheme
00:43:25 <Muad_Dib> hia dcoutts...fix your tabcompletion indeed...cause I read logs if it tells me my name was said :P
00:43:26 <nostromo> I'm using hugs
00:43:40 <SamB_XP> xerox: of course you can!
00:43:45 <Cale> xerox: of course you can, that's an expression
00:43:47 <xerox> Yaaak
00:43:49 <SamB_XP> its just a normal let!
00:43:50 <xerox> The in, right.
00:44:08 <SamB_XP> I mean look, I just did it with lambdabot!
00:44:22 <SamB_XP> and ack I feel horrible
00:44:27 <xerox> Indeed!
00:45:21 <SamB_XP> stupid ADD with its hyperfocus and near-compulsive inability to stop things in the middle...
00:45:36 <nostromo> I was amazed that I could not express lot of things as "expressions" in a functional language till I found "let" :)
00:45:53 <nostromo> I'm beginning to grok haskell
00:48:31 <Cale> 09 - King Kong (live on a flat-bed diesel in the middle of a race track at a Miami Pop Festival ... the Underwood ramifications).ogg
00:49:14 <Cale> apparently, that's too long a filename for Windows' Joliet long file name extensions on a CD :)
00:56:20 <xerox> Cale, data List a = a :< List a | Nil | Cut doesn't seem to be the right one...
00:56:37 <xerox> Cale, I think you need to put a Cut inside the cons, somehow, right?
00:57:06 <Cale> oh, hmm
00:57:32 <Cale> It doesn't pan out?
00:57:49 <Cale> join Nil = Nil
00:57:53 <Cale> join Cut = Cut
00:58:26 <Cale> join (Nil :< xs) = join xs
00:58:29 <xerox> Wait, it maybe works
00:58:34 <Cale> join (Cut :< xs) = Cut
00:58:55 <xerox> *Prolog> toList $ fromList [1,2,3] >>= \x -> if x /= 2 then fromList [x,x*2] else Cut
00:58:56 <Cale> join (x :< xs) = x :< join xs
00:58:58 <xerox> [1,2]
00:59:00 <Cale> er
00:59:01 <xerox> *Prolog> [1,2,3] >>= \x -> if x /= 2 then [x,x*2] else []
00:59:03 <xerox> [1,2,3,6]
00:59:23 <Cale> join ((x :< ys) :< xs) = x :< join (ys :< xs)
00:59:24 <Cale> rather
01:00:15 <xerox> I did: join Nil = Nil; join (Nil :< ys) = join ys; join (Cut :< ys) = Nil; join ((x :< xs) :< ys) = x :< join (xs :< ys)
01:00:49 <Cale> join Cut = Cut
01:00:54 <Cale> and you'll have the same as me :)
01:01:01 <Cale> er, not quite the same
01:01:02 <Cale> hmm
01:01:16 <Cale> Yeah, it's a good question how deeply we want to cut there
01:01:23 <xerox> join (Cut :< ys) = Nil -- was the key point for me
01:01:30 <xerox> Right...
01:01:30 <Cale> We could presumably even parametrise it with a Nat
01:02:02 <Cale> My cut will stop everything there.
01:02:06 <xerox> There are just two levels, aren't they?
01:02:21 <Cale> not when you bind over and over
01:02:29 <xerox> Ah-uhm.
01:02:42 <Cale> I can't recall the exact semantics of cut from prolog
01:03:31 <dons> someone want to write a tiny prolog binding for lambdabot?
01:04:52 <dons> nostromo: it's cool that haskell's starting to make sense for you :)
01:05:08 <dons> let us know if there's anything else you think you should be able to do, but can't see how.
01:05:43 <dons> > head [1..3] where head (x:xs) = x ; head _ = undefined
01:05:44 <lambdabot>  Parse error
01:05:50 <dons> silly parser :P
01:06:02 <xerox> We used to be able to do wheres!
01:06:08 <dons> > x where x = 1
01:06:09 <lambdabot>  Parse error
01:06:18 <dons> nope. has to be an expression
01:06:23 <xerox> After the-v-threat, it stopped working, I think.
01:06:29 <dons> > let x = y in x where y = 3
01:06:30 <lambdabot>  Parse error
01:06:31 <nostromo> well, I have studied the SICP book a few times, and I have a background in lisp (I like scheme) and a few other languages
01:06:41 <dons> > let x = y where y = 3 in x
01:06:43 <lambdabot>  3
01:06:55 <nostromo> dons: the fact that there is a distinction between statements and expressions resulted puzzling to me
01:07:11 <dons> statements? like in the do-notation?
01:08:37 <nostromo> I mean, definitions need to go in files
01:08:57 <nostromo> so I needed to start using let to test things interactively
01:09:51 <nostromo> in scheme (or python, or... you name it) you can "define" interactively
01:10:08 <dons> right. because a binding may depend on anything declared somewhere else in the file, before or after. which doesn't translate well to step-by-step interactive environments
01:10:19 <xerox> In GHCi you can do `let .. = ..' do introduce new bindings. And use it afterwards.
01:10:21 <dons> if you use ghci, you can declare new bindings: let x = 1
01:10:51 <xerox> In GHC 6.5 you don't even need to do `print' on Show a => IO a values, it automagically prints it for you.
01:10:54 <dons> since ghci interprets statements in a do-block, where the : let <ident> = <expr> form is valid
01:10:57 <nostromo> ok, I'll probably install it later, I'm using hugs for the moment
01:10:57 <xerox> GHCi is a strange beast.
01:11:31 <dons> also, mutually recursive bindings are valid anywhere, which makes interactive definitions also hard..
01:30:00 <newsham> http://www.thenewsh.com/~newsham/x/machine/sud.py
01:30:03 <newsham> i know, its a sickness.
01:32:13 <Cale> newsham: Now translate it back into Haskell
01:32:34 <Cale> hehe
01:32:54 <newsham> it would be largely identical to the original except using a list comprehension instead of a list remove function
01:33:09 <newsham> the rest was translated almost verbatim
01:33:30 <newsham> oh, and left folds instead of right folds
01:47:11 <shemale_magic> hi
01:47:21 <protonorpedo> hi
01:48:30 <protonorpedo> helllo
01:48:32 <protonorpedo> ?
02:10:48 <mnislaih> @tell Lemmih I'm halfway done with moving everything to the desugarer
02:10:48 <lambdabot> Consider it noted.
02:32:17 <joelr1> good morning
02:32:21 <vincenz> moin
02:32:39 <joelr1> does anyone know if ghc uses floating-point exceptions on mac osx intel?
02:33:02 <joelr1> where would i look in the ghc sources?
02:33:18 <dons> either the native code gen, or inspect the C code generator
02:33:38 <vincenz> xerox: what is tht prolog stuff?
02:33:42 <joelr1> dons: let me see what directories these live under
02:34:19 <dons> under codeGen cmm and nativeGen, iirc
02:34:29 <joelr1> dons: thanks! looking...
02:38:20 <joelr1> dons: i'll just ask simon on monday. can't find it. there's code for handling SIGFPE but i can't see anything re: enabling FPE
03:40:01 <foxy> dcoutts: ping
03:40:19 <foxy> @seen dcoutts
03:40:20 <lambdabot> dcoutts is in #haskell-overflow, #haskell-blah, #haskell and #gentoo-haskell. I last heard dcoutts speak 9 hours, 40 minutes and 11 seconds ago.
04:22:23 <foxy> @yarr!
04:22:23 <lambdabot> Is that a hornpipe in yer pocket, or arr ya just happy ta see me?
04:27:22 <tibbe> @hoogle a -> [a -> b] -> [b]
04:27:23 <lambdabot> No matches, try a more general search
04:27:31 <xerox> ?wiki Compose
04:27:31 <lambdabot> http://www.haskell.org/haskellwiki/Compose
04:27:45 <wolverian> hey, I was just reading that!
04:27:47 <xerox> tibbe: check that url.
04:27:53 * wolverian takes it back from xerox 
04:28:17 <xerox> Oh, wait.
04:28:24 <xerox> You want something different.
04:28:44 <xerox> ?type map . (flip ($))
04:28:45 <tibbe> xerox, I want to apply a value to a list of predicates, and then OR that
04:28:45 <lambdabot> forall a b. a -> [a -> b] -> [b]
04:28:52 <xerox> You want this one.
04:29:01 <tibbe> yep, thanks
04:29:05 <xerox> ?type (or .) . map . (flip ($))
04:29:06 <lambdabot> forall a. a -> [a -> Bool] -> Bool
04:29:09 <tibbe> does it have a name?
04:29:11 <xerox> Ops.
04:29:17 <xerox> That's it ;)
04:29:29 <xerox> I don't think so.
04:29:51 <tibbe> hmm
04:30:05 <tibbe> applyPred
04:30:07 <tibbe> nah
04:30:25 <xerox> ?type all
04:30:26 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
04:30:29 <xerox> But it's different.
04:30:39 <xerox> Oh, wait, maybe...
04:31:04 <xerox> > let swing f c a = (f ($ a)) c in swing all
04:31:05 <lambdabot>  Add a type signature
04:31:08 <xerox> ?type let swing f c a = (f ($ a)) c in swing all
04:31:09 <lambdabot> forall a. [a -> Bool] -> a -> Bool
04:31:13 <xerox> Ah-ha.
04:31:30 <xerox> ?oldwiki LicensedPreludeExts
04:31:30 <lambdabot> http://www.haskell.org/hawiki/LicensedPreludeExts
04:32:07 <tibbe> is it there somewhere?
04:32:20 <xerox> Well, swing is there, and you needed swing all.
04:32:54 <tibbe> ok, thanks
04:33:01 <xerox> You're welcome.
04:33:16 <tibbe> @t all
04:33:17 <lambdabot> Maybe you meant: tell time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . v
04:33:36 <xerox> `swing any', since you want to `or' the results.
04:33:40 <xerox> Sorry.
05:01:14 <tibbe> a good name for a function that checks if its first arg pred is true and the second arg, a list of preds, is false, yesAndNO? ;)
05:04:22 <vegai> yesAndOhNoes
05:06:03 <vegai> perhaps f if it's local
05:06:28 <tibbe> it's local to the package but quite heavily used inside
05:06:40 <tibbe> (i.e. to construct parsers)
05:10:13 <tibbe> I was thinking except, like so: isOctet `except` [isReserved, isDigit, isUnsafe]
05:44:28 <MarcWeber> How can  I get the selected item of a list in gtk2hs? There is treeViewGetSelection  -> IO TreeSelection  and newtype TreeSelection=TreeSelection (ForeignPtr (TreeSelection))
05:48:10 <Pupeno_> lambdabot: yow!
05:50:20 <int-e> @type Control.Monad.foldM
05:50:22 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
05:51:30 <dons> tibbe: how about `butIsNot` ?
05:51:44 <dons> isOctet `butIsNot` [isReserved, isDigit, isUnsafe]
05:56:03 <int-e> hmm. unfoldM :: (a -> m (Maybe (b,a))) -> a -> m [b] would be nice.
05:56:27 <dons> hmm!
05:56:35 <dons> ?type unfoldr
05:56:36 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
05:57:06 <dons> ?type liftM2 unfoldr
05:57:07 <lambdabot> forall a a2 (m :: * -> *). (Monad m) => m (a2 -> Maybe (a, a2)) -> m a2 -> m [a]
05:57:13 <dons> not quite
05:57:42 <int-e> which has been suggested before and is in PreludeExts
05:58:09 <dons> yeah, considering we have replicate and repeatM, unfoldM is only natural too
05:59:51 <int-e> woops
06:02:50 <dcoutts> MarcWeber, the TreeSelection object gives you access to the selection
06:03:04 <dcoutts> see the documentation for that type
06:03:37 <int-e> @pl unfoldM f a = f a >>= maybe (return []) (\p -> unfoldM f (snd p) >>= return . (fst p:))
06:03:39 <lambdabot> unfoldM = fix (liftM2 flip ((>>=) .) . (maybe (return []) .) . flip flip ((return .) . (:) . fst) . (liftM2 (>>=) .) . flip flip snd . ((.) .))
06:03:39 <dcoutts> foxy, I got your email
06:03:57 <dcoutts> Muad_Dib, sorry! :-)
06:04:33 <beelsebob> hehe
06:04:43 * beelsebob feels evil for snarking on the haskell mailing list now
06:05:15 <dons> ?karma+ beelsebob
06:05:16 <lambdabot> beelsebob's karma raised to 3.
06:05:21 <dons> great reply.
06:05:27 <beelsebob> :D
06:05:31 <dons> i was considering just a reminder on the homework policy
06:07:14 <int-e> Well, he didn't even bother to explain the problems in his own words. sigh.
06:07:49 <norpan> hopefully his tutor will read this and give him a harsh reminder
06:07:51 <int-e> but, I must admit, the 'VERY URGENT' and calling homework a project made me laugh :)
06:08:17 <dons> :)
06:08:44 * beelsebob adds a bit more evilness to the reply
06:09:20 <int-e> the unfoldM turned up in thinking about a one-line solution for the first problem btw.
06:09:27 <norpan> more replies?
06:09:41 <beelsebob> yeh, added a note that I would avoid my tutor if I were him
06:09:48 <dons> ;)
06:09:51 <beelsebob> because they were probably on the mailing list too
06:10:07 <dons> its happend in here, even. students asking, only to find their tutor sitting in the channel
06:10:51 <beelsebob> lol
06:14:20 <dcoutts> heh
06:15:36 * musasabi delurks for a while
06:16:13 * beelsebob prods musasabi with sticks
06:18:10 * musasabi was just beating people with rattan stick
06:21:02 <beelsebob> the poor guy didn't seem to get the idea of that reply
06:21:43 <musasabi> (or more like their shields)
06:22:58 <int-e> beelsebob: oh, did he answer?
06:23:18 <beelsebob> yep, basically saying, "Yes, you appear to be in a bad mood, can you answer the question anyway"
06:23:26 <int-e> haha
06:23:54 <beelsebob> I'm not quite sure how to reply
06:23:58 <beelsebob> I think I'll leave it
06:24:05 <int-e> ask for money
06:24:07 <int-e> :-P
06:24:16 <beelsebob> rofl
06:36:15 <kuribas> Hi, is there a good explanation of comonads somewhere?
06:36:24 <beelsebob> yes... here
06:36:26 <beelsebob> BRAINFUCK!
06:36:28 <beelsebob> :P
06:37:18 <SamB_XP> uh...
06:37:19 <SamB_XP> what?
06:38:53 <kuribas> erm, what has brainf**k to do with comonads?
06:39:15 <beelsebob> comonads are one
06:39:28 <beelsebob> and possibly edwin does both of them
06:40:25 <kuribas> beelsebob: are you saying they are difficult to understand?
06:41:20 <beelsebob> :)
06:43:38 <dons> beelsebob is being particularly evil today ;)
06:45:27 <beelsebob> :DD
06:47:32 <dcoutts> dons, so today I want to look at the speed of the lazy fusion combinators
06:47:42 <dcoutts> and write more for the paper
06:48:57 <dons> ok. didn't get anywhere much today, my sister was visiting. however i'll be going throught the paper tomorrow, see if i can fill out a section or two
06:49:16 <dons> any thoughts on why the lazy combinators are slow?
06:50:18 <dcoutts> probably same reasons we were having with the strict ones
06:50:26 <dcoutts> I'll try and find out exactly
06:52:15 <SamB_XP> comanads are a brainfuck variant?
06:53:02 <dons> little known isomorphism
07:01:11 <tibbe> if I have a parsec parser like so: do { nonterm1; nonterm2 } where both nontermX returns a string can I combine these two strings and return them without doing: do { a <- nonterm1; b <- nonterm2; return $ a ++ b} ?
07:04:54 <dcoutts> tibbe, ask liyang about applicative
07:05:45 <tibbe> liyang, what's applicative? ;)
07:05:49 <dcoutts> @type ap
07:05:51 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
07:06:02 <tibbe> that looks a bit scary
07:06:14 <dcoutts> tibbe, I think you can do: return (++) `ap` nonterm1 `ap` nonterm2
07:06:16 <Igloo> You can liftM2 (++) nonterm1 nonterm2
07:06:23 <dcoutts> or that
07:06:26 <dcoutts> :-)
07:06:39 <tibbe> hmm, that I understand at least
07:06:40 <dcoutts> @type liftM
07:06:41 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
07:06:43 <dcoutts> @type liftM2
07:06:44 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
07:07:22 <kuribas> That's nice, but isn't that essentially the same solution?
07:08:10 <Igloo> In what sense?
07:08:33 <Igloo> It does the same thing, but you haven't really got a choice about what it does
07:08:36 <dcoutts> kuribas, yeah, it's the same as doing do { a <- nonterm1; b <- nonterm2; return $ a ++ b}
07:08:48 <dcoutts> but it's neater (at least some people think so)
07:09:02 <tibbe> basically I want to say, hey, give back all the input you just consumed as a string
07:09:21 <dcoutts> tibbe, however you rally do care about the order
07:09:25 <dcoutts> rally/really
07:09:35 <tibbe> yeah, I want it in the order it was parser ;)
07:09:40 <tibbe> @paste
07:09:40 <lambdabot> http://paste.lisp.org/new/haskell
07:10:36 <tibbe> params = param >> many (char ';' >> param)param = many (pchar <|> char '/')
07:10:41 <tibbe> bah
07:10:48 <tibbe> params = param >> many (char ';' >> param)
07:10:53 <tibbe> param = many (pchar <|> char '/')
07:11:16 <tibbe> everything might as well be one big rule, it's seperated for readability/reusability
07:12:38 <tibbe> I need something a bit more general than liftM2
07:12:49 <tibbe> @t mapM
07:12:49 <lambdabot> Maybe you meant: tell time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . v
07:13:04 <tibbe> @type mapM
07:13:05 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
07:13:15 <tibbe> @foldrM
07:13:19 <tibbe> @type foldrM
07:13:21 <dcoutts> dons, to make this really a shared ghci session we need :i :t etc
07:13:21 <lambdabot> Not in scope: `foldrM'
07:13:32 <dcoutts> :t foldr
07:13:40 <dcoutts> :q
07:13:41 <dcoutts> ;-)
07:14:14 <tibbe> I'm sure others must have had the same problem
07:15:46 <LordBrain> i didnt see what you said before needing something more general than liftM2.... and liftM2 can be generalized in different ways..
07:16:15 <LordBrain> so in which way do you want it generalized?
07:16:32 <tibbe> basically I need to gather the output from several actions
07:16:49 <tibbe> dcoutts suggested liftM2 for my particular example
07:17:00 <norpan> well, liftM3 etc?
07:17:07 <norpan> and mapM
07:17:10 <tibbe> to lift ++ to concat strings returned from two actions
07:17:19 <LordBrain> sequence
07:17:21 <kpreid> tibbe_: concatMapM = (liftM concat . mapM) should do it
07:17:29 <kpreid> er, right, sequence
07:17:31 <kpreid> not mapM
07:17:51 <LordBrain> @type sequence
07:17:52 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
07:18:00 <kpreid> @type (liftM concat . sequence)
07:18:02 <lambdabot> forall a (m :: * -> *). (Monad m) => [m [a]] -> m [a]
07:22:50 <tibbe> alright, that's almost it except that some parsers return Chars and some Strings
07:23:17 <tibbe> intuitivly that should be doable
07:24:02 <LordBrain> among my utilities, i have a sequenceWhileM :: (Monad m) => (a -> m Bool) -> [m a] -> m [a]
13:05:09 --- topic: '["Haskell Communities & Activities Report, 10th edition", "http://haskell.org/communities/", "Haskell.org SoC projects", "http://hackage.haskell.org/trac/summer-of-code/", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion", "The ICFP has ended. Who won?"]'
13:05:09 --- topic: set by dons on [Thu Aug 10 22:11:10 2006]
13:05:11 <wolverian> that's a 404
13:05:15 <wolverian> is the project still alive?
13:05:49 <mauke> argh, I need the current position in my string
13:06:06 <emertens> mauke: what's the function do?
13:06:13 <newsham> zip str [1..] ?
13:06:36 <emertens> [0..] ?
13:06:41 <xerox> ?
13:06:42 <newsham> yah, 0.. what a mi thinking?
13:07:04 <mauke> emertens: I think it runs a DFA on a string
13:07:31 <sehute> lambdabot: wish you could check your links from time to time ;) [does this text end up with the creator of lambdabot?]
13:07:45 <sjanssen> @type \f -> foldr (\x xs s -> xs (f s x)) (\_ _ s -> s)
13:07:47 <lambdabot> forall a t t1 t2. (t -> a -> t) -> [a] -> t -> t1 -> t2 -> t2
13:07:48 <sjanssen> @type foldl
13:07:49 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:08:22 <mauke> emertens: anyway, it has to emit the positions of the matches
13:09:37 <sjanssen> @type \f s0 xs -> foldr (\x xs s -> xs (f s x)) id xs s0 -- here is foldl
13:09:38 <lambdabot> forall a a1. (a1 -> a -> a1) -> a1 -> [a] -> a1
13:56:28 --- topic: '["Haskell Communities & Activities Report, 10th edition", "http://haskell.org/communities/", "Haskell.org SoC projects", "http://hackage.haskell.org/trac/summer-of-code/", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion", "The ICFP has ended. Who won?"]'
13:56:28 --- topic: set by dons on [Thu Aug 10 22:11:10 2006]
13:56:31 <Jonex> I wan't it to contain the data of an image.
13:56:42 <sjanssen> > (\l -> foldr (\x xs s -> xs x) id l undefined) [1, 2, 3]
13:56:43 <lambdabot>  3
13:56:47 <int-e> @type Data.Array.array
13:56:48 <lambdabot> forall e i. (Ix i) => (i, i) -> [(i, e)] -> Array i e
13:56:52 <Jonex> So I'd guess an array'd be faster than a list of lists.
13:57:13 <sjanssen> @pl \x xs s -> xs x
13:57:13 <lambdabot> (const .) . flip id
13:57:24 <int-e> Array i e is an immutable array with indices of type i and elements of type e. i can be (Int, Int), for example.
13:57:32 <emertens> the type is Array i e with e is your elements type and i is an instance of Ix
13:57:40 <emertens> @instances Ix
13:57:41 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
13:57:45 <int-e> mutable arrays in haskell are awkward to use (in my experience so far)
13:57:47 <emertens> @instances Data.Array.Ix
13:57:47 <emertens> ?
13:57:48 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
13:58:07 <emertens> @instances-importing Ix
13:58:07 <int-e> @instances-importing Data.Ix Ix
13:58:07 <emertens> ?
13:58:07 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
13:58:08 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
13:58:12 <emertens> What am I missing
13:58:34 <heatsink> @instances Int
13:58:36 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
13:58:45 <int-e> emertens: the right syntax for instances-importing :)
13:58:45 <heatsink> I dunno
13:58:48 <sjanssen> emertens: Ix lives in Data.Ix
13:58:57 <Jonex> Hmm, maybe I should see first what kinds of arrays I can get from any image lib for haskell.
13:59:33 <int-e> (it would probably be useful to translate @instances A.B.C to @instances-importing A.B C)
14:00:21 <Jonex> Hmm, is there any image loading library for haskell?
14:01:22 <SamB> image?
14:01:29 * SamB feigns ignorance
14:01:48 <Jonex> You don't know what an image is?
14:02:19 <SamB> I'm feigning ignorance. That means I am *pretending* not to know what an image.
14:02:26 <SamB> er, what an image is.
14:02:33 <heatsink> "Image"? Is that some kind of function? :p
14:02:38 <newsham> plugins-1.0 ?
14:02:57 <johnnowak> SamB: :)
14:03:01 <Jonex> hmm, can't find one on google. Where else can I look?
14:03:19 <Lemmih> Jonex: There's SDL.
14:03:26 <SamB> ewwwwww
14:03:33 <newsham> http://www.cse.unsw.edu.au/~dons/hs-plugins/
14:03:33 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules
14:03:46 <johnnowak> SamB: what's wrong with SDL?
14:03:47 <emertens> 16:02  SamB> er, what an image is.
14:03:55 <emertens> err
14:03:56 <SamB> johnnowak: it isn't what it claims to be, for starters
14:04:03 <Jonex> Isn't SDL for showing images?
14:04:09 <johnnowak> SamB: how so?
14:04:23 <SamB> well, it isn't very direct, at least!
14:04:25 <newsham> you want pictures?  or binary images?
14:04:33 <newsham> i confused
14:04:34 <johnnowak> SamB: it's a matter of perspective :)
14:04:54 <newsham> that happens a lot.
14:05:00 <Jonex> I wan't to be able to load png files to an array of pixels.
14:05:05 <Jonex> *want
14:05:11 <SamB> I'm not sure I'm prepared to argue that it isn't simple, but I could argue that such library should not be too simple...
14:05:35 <Jonex> Quite basic thing to do, would be weird if there wasn't any lib for it?
14:05:50 <johnnowak> there's room for many levels of abstraction when it comes to multimedia libraries
14:05:52 <SamB> sure!
14:06:03 <SamB> there is this library called "png2pnm" you can use
14:06:18 <newsham> png is so simple you could easily whip up your own
14:07:23 <johnnowak> chicken scheme has an imlib extension...
14:07:25 <SamB> the main problems with DirectX are API churn and the fact that it is pretty much windows-only, as far as I'm aware...
14:07:29 <Jonex> SamB: Can't find it on google, sure about the name?
14:07:42 <SamB> Jonex: it is actually a program ;-)
14:07:55 <Jonex> I want to load them in my program.
14:08:12 <Weirdan> hi people, newbie here. Can anyone lend a helping hand?
14:08:18 <SamB> it will convert png to an easier-to-parse format
14:08:18 <Jonex> newsham: Sounds like a lot of work if you are new to haskell.
14:08:22 <SamB> oh, and I spelled it wrong
14:08:33 <SamB> pngtopnm is the real name
14:08:39 <Jonex> SamB: But there has to be png-readers for haskell?
14:08:48 <SamB> Jonex: there might be one
14:09:13 <Jonex> Weird, must be the first language I see that lacks something so basic.
14:09:19 <emertens> Weirdan: your best bet will be to ask questions and wait for answers :)
14:09:28 <johnnowak> Jonex: perhaps you can write it? :)
14:09:32 <Jonex> Is there readers for any other format?
14:09:41 <Jonex> johnnowak: Nope, that's why I need a lib.
14:09:46 <SamB> well, see, the trouble isn't to write it, the trouble is to give it a decent API ;-)
14:09:56 <newsham> jonex: *shrug* it is really really simple.. probably not too much work.. even if you are new
14:10:19 <SamB> Jonex: you really could just convert to pnm first...
14:10:52 <Jonex> newsham: I don't know monads and IO yet, and have yet to find a doc that explains clearly how they work rather than how hard they are to learn.
14:11:07 <Jonex> SamB: Is there a pnm reader for haskell?
14:11:16 <newsham> err.. maybe not really really simple.. i think i'm thinkingof pnm.
14:11:20 <johnnowak> Jonex: why are you trying to do image manipulation (I assume you're manipulating them) in haskell?
14:11:22 <newsham> this looks slightly non-simple :)
14:11:30 <newsham> but pnm is simple!  and its easy to convert :)
14:11:44 <SamB> Jonex: who cares?
14:11:54 <SamB> you can write those easily enough!
14:12:20 <norpan> pnm reader for haskell should be easy
14:12:25 <Jonex> johnnowak: Because I have a function that requres recursion, ra pout of recursion depth in Python, and while I could rewrite it to use it's own stack, it'd be more elegant if it could use language recursion.
14:12:29 <emertens> you guys get mean when dons and Cale and so on aren't around :)
14:12:32 <SamB> pnm readers should be easy in most reasonable things
14:12:41 <Jonex> I'm not really manipulating it, only extracting data.
14:12:48 <johnnowak> Jonex: chicken scheme has image libraries and can certainly handle recursion
14:13:25 <newsham> jonex: where's the python code?
14:13:31 * int-e would probably think twice before doing low-level image processing in Haskell.
14:13:31 <johnnowak> Jonex: although i'll say no more lest #haskell hang me
14:13:35 <Jonex> Chicken scheme? Never heard of it, does it have an irc channel where people are active. OCaml was to dead for me.
14:13:50 <SamB> emertens: what do you mean?
14:14:21 <norpan> it never hurts to try to do anything in haskell
14:14:22 <johnnowak> Jonex: You can just join #scheme here on freenode. the site is at http://www.call-with-current-continuation.org
14:14:23 <emertens> If you are going to work with large ammounts of binary data, I'd guess that it would be best to consider mutable arrays, and to use those you'll need to understand a little about monads
14:14:25 <lambdabot> Title: call-with-current-continuation.org
14:14:35 <SamB> the thing about "is that some kind of function" was probably a reference to Pan...
14:14:47 <Weirdan> emertens: sure, here it is: I trying to work through the 'Yet another tutorial on Haskell' and I'm unable to write an (IO action?) to get a list of numbers from user
14:14:47 <Weirdan> here's what I got so far:
14:14:47 <Weirdan> getNums = do
14:14:47 <Weirdan>   putStrLn "Give me a number (or 0 to stop):"
14:14:47 <Weirdan>   num <- getLine
14:14:48 <Weirdan>   if read num == 0
14:14:50 <Weirdan>      then return []
14:14:52 <Weirdan>      else do
14:14:53 <SamB> emertens: only if he needs to change it
14:14:54 <Weirdan>              rest <- getNums
14:14:56 <Weirdan>              return ((read num :: Int):rest)
14:14:58 <Weirdan> when called from main as
14:15:00 <Weirdan>    getNums
14:15:01 <johnnowak> Jonex: and of course, don't forget C :)
14:15:02 <Weirdan> it
14:15:09 <SamB> emertens: if not, immutable ones are fine
14:15:27 <Weirdan> 's working ok, but when I try it so:
14:15:27 <Weirdan> nums <- getNums
14:15:27 <Weirdan> all I get is ERROR file:.\SumProductFac.hs:9 - Last generator in do {...} must be an expression
14:15:38 <Jonex> Weirdan: Use a pastebin (google it)
14:15:44 <int-e> @where paste
14:15:44 <lambdabot> http://paste.lisp.org/new/haskell
14:16:00 <Jonex> newsham: http://www.deadbeefbabe.org/paste/1482
14:16:23 <SamB> Weirdan: you have to have an expression as the last statement in main
14:16:32 <Jonex> Also I got more for the image loading, but that's not really part of the algoritm.
14:16:33 <SamB> (or any do block)
14:17:07 <newsham> jonex: i dont see recursion.
14:17:14 <Jonex> johnnowak: Does C have infinite recursion depth?
14:17:18 <newsham> oh, there's a big gap in the code.. i didnt see the whole thing :)
14:17:19 <johnnowak> newsham: findfield calls itself
14:17:27 <SamB> Jonex: GCC supports TRE
14:17:29 <Weirdan> SamB: even if main is defined as main = do ....
14:17:34 <SamB> or TCE or whatever it is called
14:17:36 <Weirdan> SamB: ?
14:17:36 <johnnowak> Jonex: no, but i'm sure you can write it without it...
14:17:54 <Jonex> Of course I can, if I use a list as stack.
14:17:55 <SamB> Weirdan: the last thing in any do block must be an expression
14:18:05 <Jonex> That's more ugly though.
14:18:10 <lisppaste2> Weirdan pasted "problem with getting list from an IO action" at http://paste.lisp.org/display/24041
14:18:34 <SamB> Weirdan: try adding "print nums" after "nums <- getNums"
14:18:45 <int-e> Jonex: not really, in a sense, a do block must have a 'return value' and x <- ... doesn't have one.
14:18:47 <johnnowak> Jonex: i'd rather fast image processing in C than image processing in haskell :) ugliness is a matter of perception...
14:19:13 <int-e> johnnowak: you can always use FFI for combining the basic low level building blocks.
14:19:17 <SamB> and really, who needs to bind a variable and then leave the scope before using it?
14:19:18 <Weirdan> SamB: thanks, it works :)
14:19:36 <SamB> not that *that* is illegal
14:19:40 <Jonex> johnnowak: Do you know any good image loding libs for c?
14:19:41 <johnnowak> int-e: of course. depends what else he's doing ... may not be worth the effort.
14:19:50 <int-e> johnnowak: which is an area where Haskell should do better than C (processing commands and building an image processing pipeline to execute)
14:19:53 <int-e> johnnowak: right
14:19:54 <johnnowak> Jonex: there are plenty, google will help.
14:20:16 <Jonex> I found some that really wasn't abstracted at all.
14:20:17 <edwardk> jonex: imagemagick doesn't suck
14:20:20 <newsham> you can do that without recursion fairly easily.    queue = [coord]; for work in queue : if not visited : work.apppend(vec_add()... for directions) ...
14:20:31 <SamB> pnglib is generally used for PNG at some point, right?
14:20:33 <newsham> the code will probably even be smaller
14:20:37 <newsham> (in python at least)
14:20:42 <edwardk> samb: yeah
14:20:47 <Jonex> SamB: Yeah, but it had terrible syntax.
14:20:58 <johnnowak> Jonex: you may want to try imlib. i'm not sure how solid it is.
14:21:02 <SamB> yeah, I seem to remember it not being friendly ;-)
14:21:17 <SamB> or maybe that was zlib, but they are like brothers...
14:21:53 <Jonex> My requirement for syntax is that it should be something like Image myimage = LoadImage(PATH); Array imarr = Image.toArray();
14:22:16 <edwardk> jonex: then check imagemagick
14:22:18 <johnnowak> Image image = myImage image image image ...
14:23:05 <edwardk> gotta love a tool where you can use stl iterators to string together images into an animated gif when you use the c++ bindings =)
14:24:06 <norpan> gotta hate the overloading of unrelated concepts in c++ :)
14:24:07 <newsham> jonex: how about this?  http://www.thenewsh.com/~newsham/x/visited.py
14:24:11 <newsham> no stack blowing
14:24:14 <edwardk> norpan: yeah
14:24:36 <norpan> just like monads in haskell
14:24:47 <norpan> except that is good of course
14:24:52 <norpan> because it is haskell
14:25:01 <edwardk> norpan: heh.
14:25:10 <Jonex> newsham: Oh.
14:25:13 <newsham> you could also move the visited check into the work.append loop, that might keep the list small
14:25:27 <SamB> except monads *are* related
14:26:08 <newsham> jonex: in your case recursion isnt really needed, as you dont care about the order of visitation..
14:26:11 <edwardk> as, arguably is the usage of iterators in c++ for the purpose above. it just lets you store images in an arbitrary container before generating the animated gif
14:26:26 <newsham> you just need some way to manage a work queue, and recursion gives you that for free.. but doing it "by hand" isnt hard in your case
14:27:02 <Jonex> newsham: Will that for pt in work loop find the appended stuff too?
14:27:13 <Jonex> If so that really simplifies things.
14:27:19 <newsham> yup, you can iterate while appending
14:27:41 <Jonex> Then, I just have to understaqnd it so I can rewrite it myself without copying your code. :)
14:27:50 <newsham> always a good idea :)
14:28:07 <Jonex> It's for a school project. :)
14:28:15 <newsham> work is a work-queue holding all the points you want to check out in the future
14:29:15 <Jonex> Yeah, I have another version that uses a whila loop and a stack-object, it puses and pops things from the stack until it's empty. But that looked quite ugly.
14:29:17 <int-e> newsham: I'd definitely do the visited check before adding to the queue. keeps the queue at least 2 times smaller.
14:29:25 <newsham> i guess your class lets you pick any language?
14:29:35 <newsham> int-e: yah, thought of that after I posted it.
14:29:49 <int-e> newsham: what's more, you can add the things to the visited map immediately
14:30:25 <newsham> *nod*
14:30:41 <Jonex> newsham: I't s a project of 100 points(roughly equivalent to hours) where you are almost free to do whatever you want. As long as it's within the goals of the program.
14:31:17 <newsham> int-e: you can entirely eliminate the visited map and use the work queue as your results queue (assuming you test the first point before throwing it into the queue)
14:31:28 <newsham> of course inclusion test is slower for the queue than for the map
14:31:47 <newsham> jonex: sounds like fun!
14:32:24 <Jonex> newsham: If you find soething ineteresting to do.
14:32:55 <Jonex> It's hard to come up with such large projects imo.
14:32:55 <newsham> there are no shortage of interesting programming tasks..  if you cant find something fun, you're probably not cut out to be a programmer.
14:32:55 <edwardk> hrmm does anyone here have a decent usage case for comonads other than the dataflow stuff and pairs?
14:33:20 <newsham> most programmers i know have a laundry list of things they want to write if only they had time
14:33:22 <Jonex> newsham: I'm not, really. It's just that I'm better at programming than I am at anything else.
14:33:45 <newsham> jonex: *shrug* well i hope you find it somewhat enjoyable at least
14:33:50 <newsham> if you plan to do it for a long time
14:33:58 <Jonex> I like solving problems.
14:34:03 <sehute> Jonex: are you looking for an idea for a programming-project in Haskell?
14:34:32 <newsham> sehute: language choice not constrained.  he was thinking of doing this graphics problem in haskell because his recursive solution blows the stack in python..
14:34:42 <newsham> but was wondering if there rae good png file readers for haskell to start with
14:34:49 <edwardk> heh, dons has a laundry list of todo items, if he is allowed to hack on existing projects  =)
14:35:00 <sehute> newsham: ah, I see
14:35:34 <sehute> Jonex: you could simulate recursion in Python with a loop and a stack, though :P
14:35:36 <newsham> of course as the good #haskell citizen i showed him how to use a work queue in python instead of recursion
14:35:47 <Jonex> I'm kinda depressive, so I usually don't have much spirit to do stuff. I kinda need to get into them before I kcan keep going without effort.
14:35:49 <sehute> newsham: exactly :)
14:36:16 <Jonex> sehute: Knoithat, but the code went hard to read. And Python really isn't a very fast language.
14:36:25 <newsham> original code: http://www.deadbeefbabe.org/paste/1482?__session_just_started__=1 ,  work queue code: http://www.thenewsh.com/~newsham/x/visited.py
14:36:36 <sehute> Jonex: import psyco; psyco.full()
14:36:40 <edwardk> jonex: what are you trying to do with the images, anyways?
14:36:50 <Jonex> newsham: Though, visited, work = {}, [coord], is that really nice?
14:36:52 <sehute> Jonex: The Psyco package really makes Python a lot faster
14:37:24 <sehute> Jonex: besides, it doesn't sound like it's really the speed of Python that's your problem, if I'm not mistaken? :)
14:37:28 <Jonex> sehute: Hmm, not a lot for my purposes, at least not when I tried it, went from 25 to 19 iirc.
14:37:38 <newsham> jonex: i find a multiple assignment nicer than a long list of single assignments, but thats a stylistic point and many people disagree
14:37:56 <Jonex> sehute: Well, I was kinda interested in how hard it would be to do in haskell to.
14:38:03 <sehute> Jonex: but I agree, Python is not particularly suited for quick graphics-alogos, imo
14:38:11 <newsham> jonex: write it twice in two languages, compare and contrast.
14:38:17 <newsham> twice the fun, and probably extra credit too
14:38:41 <Jonex> newsham: Hmm, ok. I usually only use multiple assignment if the variables are closely related. Like x,y = (2,4)
14:39:05 <newsham> jonex: yah, many people hold to that style point.  pick your style and go with it...
14:39:41 <newsham> in my mind they're related in that they both set the initial state for the computation..
14:40:02 <newsham> but if they were complex expressions or really long on the line, i might split them up some
14:40:05 <Jonex> Damn, the for loop is so clever, it's like a stack, just that it don't delete old data, just don't reed it. Why didn't I think of that mself. :)
14:40:24 <sehute> Jonex: in my experience, programs take longer to write in Haskell, but you get code that you can depend on and trust. And code that you can trust is a concept that's very closely related to reusable code. I find Python-code hard to reuse and to full of potential run-time bugs and sideffects. You can write a gazillion tests, but then you might as well write it in Haskell :)
14:40:35 <newsham> its not quite like a stack.. the order will be slightly different.
14:40:59 <Jonex> Yeah, true. But as you said, not a problem for me. :)
14:41:01 <johnnowak> i find it so odd that all these new advanced haskell programs that talk about monads and such all day are amazed by a for loop :)
14:41:08 <newsham> instead of depth-first you'll be going breadth-first
14:41:53 <edwardk> john: heh
14:46:31 <newsham> if it was a stack your function would race off in one direction till it hit an edge, then explore that edge before backtracking
14:46:48 <newsham> if its a queue it will explore around the starting point and then outwards from there
14:46:55 <newsham> i twould be cool to make animations of that :)
14:47:39 <edwardk> hrmm, no convincing use cases for comonads other than the dataflow/pair ones?
14:48:25 <SamB> brain exploding?
14:48:30 <edwardk> samb: heh
14:48:46 <newsham> keeping grad students employed?
14:49:23 <edwardk> so far it seems to only be maintaining the existence of a pair of estonian grad students, not a very wide impact on the employment market =)
14:50:02 <newsham> 2 is at least 5 times larger than zero.
14:50:10 <SamB> heh
14:50:35 <edwardk> so no loving for comonads here, eh? =)
14:50:51 <newsham> sorry, the attempt at witty banter is to cover up my ignorance.
14:51:03 <edwardk> i would figure at least john nowak would speak up. doesn't he want to do something with dataflow?
14:53:47 <edwardk> oh wait, i guess a costate monad as well, so it give you a conext that you can modify to rerun a function with slightly different arguments for experiments.
14:53:53 <edwardk> s/conext/context/g
14:54:01 <heatsink> heh
14:54:15 <edwardk> er costate comonad =)
14:55:06 <int-e> > let next 0 = [2,1]; next 1 = [0,1]; next 2 = []; bfs a = let x = a:bfs' [a] x in x; bfs' [] [] = []; bfs' v (a:as) = let v' = filter (not . flip elem v) (next a) in v' ++ bfs' (v ++ v') as in take 3 $ bfs 0
14:55:07 <lambdabot>  [0,2,1]
14:55:09 <edwardk> might be useful if i could get my heard around it before my internal ghc pops up the notorious 'my brain exploded' error.
14:55:32 <int-e> this is a breadth first search with one minor problem - it doesn't terminate :(
14:56:44 <int-e> otherwise, defining the work queue with   let x = a:bfs' [a] x in x   is pretty.
14:57:14 <heatsink> int-e: it needs an extra state variable, a set saying what's been visited, right?
14:57:22 <Jonex> newsham: Hmm, will dict be faster than list for x in list/dict?
14:57:23 <SamB> okay....
14:57:25 <SamB> thats wierd
14:57:27 <int-e> heatsink: it has that, that's the first argument to bfs'
14:57:33 <SamB> apparantly there isn't anything wrong with my program!
14:57:43 <int-e> heatsink: but it can't find out when the work queue is exhausted.
14:57:50 <SamB> the one that I just wrote a program to check, that is
14:57:57 * heatsink reformats the code for reading
14:58:41 <SamB> so why did the uploader complain that my program has the wrong number of branches in a case?
14:58:49 <SamB> wait...
14:58:56 <SamB> I haven't finished yet...
14:59:00 <SamB> something must be missing
14:59:16 <int-e> (you get an Exception: <<loop>> if you take out the 'take 3')
15:00:05 <SamB> I wrote a program once where I tried to use a lazy list to represent an actual queue
15:00:07 <edwardk> hrmm
15:00:09 <SamB> that is, kids standing in a line
15:00:19 <edwardk> whats  a good way to filter a list so you only get one of each element in it
15:00:19 <SamB> but it looped without a <<loop>>
15:00:58 <edwardk> but when it may be infinite =)
15:00:59 <heatsink> edwardk, nub?
15:01:15 <SamB> oh, heh, I need to check the code in each branch of a case ;-)
15:01:24 <int-e> heatsink: it just doesn't work. you can implement a three-parameter bfs' that just accumulates a new chunk while working on the previous chunk though, which will look very similar, code-wise.
15:04:39 <SamB> and I need to add bindings for the pattern matched...
15:10:58 <sehute> I wish I could install haskell, python, ruby and mono, then import OtherLanguages and do stuff like Python.string.join ["a", "b", "c"] ":"
15:10:59 <heatsink> int-e: I think i understand. clever design, though.
15:11:46 <edwardk> int-e: that version can only search a tree right?
15:13:28 <SamB> ah, now I'm getting something useful ;-)
15:14:27 <newsham> sehute: how about CLR-based python, ruby, haskell?
15:14:29 <heatsink> int-e: bfs' 0 _ _ = []; bfs' n v (a:as) = let v' = filter (not . (`elem` visited)) (next a) in v' ++ bfs' (n-1+length v') (visited ++ v') as
15:14:48 <heatsink> int-e: bfs a = let x = a:bfs' 1 [a] x in x
15:14:50 <sehute> newsham: that would be nice too :)
15:15:10 <newsham> there is clr based python at least.  is the visual haskell impl clr based?
15:15:21 <sehute> newsham: do you know the current status?
15:15:26 <heatsink> int-e: That calculates when the list becomes empty; then it doesn't look at the list --> no loop.
15:15:37 <newsham> sehute: not really..
15:15:51 <sehute> newsham: yhc, pypy, ironpython, ruby.net and h# (?) might cut it in the future, methinks
15:16:08 <newsham> yah, back to a MS world.
15:16:12 <newsham> s/yah/yay/
15:16:32 <sehute> newsham: well, clr+mono+that ecma-standard, isn't really MS in that MS way I think you mean
15:16:47 <sehute> newsham: it originated from MS, then cut all connections
15:16:51 <newsham> if you say so :)
15:17:10 <sehute> newsham: :)
15:18:27 <edwardk> clr is still pretty much microsoft's bitch. miguel de icaza's efforts to the contrary notwithstanding ;)
15:18:35 <sehute> at the moment, I think Mono/CLR has a better chance of becoming close to a standard open VM than Java, as Sun's implemenation takes away a lot of initative for working on the open versions of Java
15:19:09 <sehute> edwardk: if I use clr with Mono on Debian, it's noones bitch
15:19:13 <sehute> edwardk: free as in free
15:20:09 * edwardk gave up on mono a year or two back when I tried to install it for a project and got all sorts of inane semaphore problems
15:20:18 <edwardk> so maybe i'm biased
15:20:36 <SamB> maybe now I can read the blueprint ;-)
15:20:59 <edwardk> free as in free is one thing, but so is sucks as in sucks =)
15:21:08 * sehute has had very good experiences with c#+mono, tried out Boo, Nemerle, IKVM (and BF.NET :D), and has mostly very good experiences, but did encounter one strange bug in Mono, that he reported
15:21:13 <SamB> or maybe my code contains *semantic* errors, in addition to the syntactical ambiguity just resolved
15:21:41 <edwardk> well, my major worldview is somewhat colored from the perspective of javascript, and the mono jscript implementation is horribly broken.
15:22:02 <edwardk> the one guy that is working on it hasn't made much headway and it barely runs hello world
15:22:13 <edwardk> (well it does more than that, but not much)
15:22:22 <sehute> edwardk: ah, I remember trying out some horribly broken clr javascript-thing too
15:22:29 <sehute> edwardk: and IronPython never worked for me
15:22:37 <sehute> edwardk: neither that Ruby-implementation
15:22:45 <edwardk> i actually had a production use for the code, and had to reimplement everything from scratch over spidermonkey
15:22:55 <edwardk> it as actually quite traumatic to the project.
15:23:41 <sehute> edwardk: try installing "monodevelop-boo" if you're on a Debian-based system, read a Boo-tutorial and I think you'll like the clr and Mono better :)
15:23:44 <SamB> I tried the thing that was supposed use native Python, but it didn't like the fact that my Python uses a 32-bit representation of Unicode
15:24:00 <edwardk> sehute: so while i give them props for trying to make it work, it just doesn't seem ready for prime time. the major use for mono is as a marketing vehicle for microsoft to say hey, look clr is open source. its not its intent, but thats the effect
15:24:08 <SamB> (It was geared towards windows builds, which use a 16-bit representation)
15:24:14 <sehute> edwardk: mono+c# is ready for primetime, imo
15:24:30 <sehute> edwardk: just look at all the apps that are made with it
15:24:32 <edwardk> sehute: sure, but c# is a pretty hideous lang =)
15:24:43 <sehute> edwardk: well, you could xml-rpc to haskell ;)
15:24:47 <edwardk> heh
15:24:58 * edwardk isn't a big fan of xml-rpc either ;)
15:25:09 <sehute> SamB: which implementation of Python was that?
15:25:19 <SamB> well, just take a look at C, C++, and Java and remind yourself that these apps could have been written in one of them...
15:25:20 <profmakx> one cannot be a fan of anything xml -.-
15:25:25 <SamB> sehute: the normal implementation
15:25:34 <SamB> it was some stuff to do FFI to it
15:25:39 <sehute> edwardk: I tried xml-rpc once, in Python, for remote-controlling Xmms. It worked and I was happy.
15:26:09 <edwardk> profmakx: to be fair xpath and xml namespaces don't entirely suck. xml isn't about the crufty reinvented s-expressions, its about the stuff layered on top
15:26:25 <sehute> profmakx: if all the xml is nicely hidden and just works, then it's quite nice. And the schema-transforms can be serious black magic
15:26:37 <SamB> sehute: you mean trang?
15:26:44 <SamB> oh, you said "transforms"
15:26:46 <edwardk> i actually rather like working in cocoon, and thats all xml
15:26:49 <SamB> not "transformers"
15:26:52 <sehute> profmakx: oh, and svg works (although not nearly as a flash-replacement)
15:26:54 <SamB> nevermind
15:27:08 <profmakx> "it works" ;)
15:27:08 <edwardk> svgstill needs more uniform implementation
15:27:11 <SamB> Relax NG makes no alterations to your trees ;-)
15:27:28 <sehute> SamB: but C# is nice :)
15:27:43 <SamB> sehute: I'm not arguing otherwise
15:27:54 <profmakx> yeah i am not a big fan of xml because it has no real use for me
15:27:55 <edwardk> i'm kinda sick of breaking it in one way to get it to run in adobe, another to get it to run in firefox, and then transforming it into directanimation to get it to load in internet explorer, while having to transform it to flash ot images to render elsewhere =)
15:27:59 <SamB> I'm saying that it must be better than C, C++, and JAva
15:28:06 <SamB> er, Java
15:28:29 <edwardk> ot/or/
15:28:34 <sehute> profmakx: my guess is that you're using xml in some way or another. Openoffice? Inkscape? Svg? Xhtml?
15:28:51 <SamB> edwardk: yeah
15:28:53 <SamB> that is bad
15:29:01 <profmakx> sehute, yes but thats not what i meant
15:29:11 <profmakx> but surely what you meant by "nicely hidden" ;)
15:29:15 <edwardk> samb: the only reason why i can use svg these days is because i can use cocoon to autogenerate jpgs from it =)
15:29:16 <sehute> edwardk: yeah, that removes one of the main supposed advantages with svg
15:29:19 <SamB> I think web 1.5 supports SVG
15:29:21 <SamB> er, 2.4
15:29:26 <SamB> X_X
15:29:28 <sehute> profmakx: ;)
15:29:30 <SamB> 2.*5*
15:29:37 <profmakx> so for the if its nicely hidden part i concur
15:29:52 <SamB> so, wait for Web 2.5 to come out ;-)
15:29:58 <sehute> profmakx: well, I concur back, so there!
15:30:05 * edwardk thinks a cocoon clone in haskell would be pretty cool =)
15:30:10 <edwardk> big project though
15:30:18 <norpan> i think this web x.y business is so silly
15:30:30 <profmakx> about the c# language
15:30:33 <jer> SamB, great... another buzzword employeres will be expecting to see on ye 'ole résumé
15:30:38 <profmakx> i think its just another c-like language
15:30:38 <edwardk> heh, when did they start using minor version numbers on web 2.0? =)
15:30:39 <sehute> edwardk: how old is cocoon? Is it similar to Tomcat?
15:30:40 <SamB> Web 2.0 is the "JavaScript works/asynchronous XML" release
15:30:44 <profmakx> nothing special
15:30:58 <edwardk> sehute: cocoon runs inside of a servlet container
15:30:58 <profmakx> but all the .net libs (copying the java complexity) does the trick
15:31:05 <edwardk> sehute: its several years old now though
15:31:24 <edwardk> sehute: so its relation to tomcat would be that it can be run inside it
15:31:27 <sehute> edwardk: so... it's a wrapper for servlets, between the app and for instance tomcat? *reading more on the web*
15:31:30 <edwardk> er it can be run inside tomcat
15:31:31 <SamB> profmakx: I think the garbage collection goes a long way towards making it usable as compared with C/C++
15:31:38 <SamB> maybe managed C++ is better though
15:31:41 <edwardk> sehute: not quite. its an alternative framework
15:31:45 <profmakx> and that seems to be the point where mono is quite incomplete
15:31:46 <edwardk> you don't work with servlets
15:31:49 <edwardk> you can
15:31:53 <edwardk> but they aren't the heard of cocoon
15:32:02 <profmakx> sweet garbage collection ;)
15:32:15 <edwardk> you deal with 3 things. xml generators, transformers and serializers.
15:32:18 <profmakx> with c-like i thought more of syntax-look-alikes
15:32:19 <sehute> edwardk: like spring?
15:32:21 <edwardk> the generator could be a file
15:32:43 <edwardk> the transformer could be an xslt or something that can do sql queries described in the input xml document, or take a chart description and render svg
15:33:04 <sehute> Anyways, I would choose C and C# over C++ and Java.
15:33:06 <edwardk> the serializer could render your xsl:fo to pdf, your svg to jpeg, could just pretty print your xhtml, or generate html, etc.
15:33:29 <SamB> is it just me or does this sound like a simplified version of that mulitmedia framework, with XML instead of multimedia?
15:33:32 <SamB> gstreamer
15:33:32 <edwardk> and its glued together by a sitemap that understands how to cache all of these intermediate stages and glue together different components.
15:33:46 <SamB> ooh, caching
15:33:56 <sehute> Wish we could have haskell-opengl-applets embedded in webpages :P
15:34:10 <edwardk> samb: it somewhat predates gstreamer
15:34:32 <SamB> I suppose it does
15:34:34 <profmakx> "this webpage is best viewed in functional-firefox 1.0"
15:34:44 <edwardk> i do like the fact that i can share the bulk of my document pipeline and fork it near the end to generate xhtml and pdf representations of a document
15:34:47 <profmakx> haskellfox ...
15:34:49 <SamB> I was playing with it a long while ago...
15:34:55 <edwardk> and i can abuse xsl:foto generate tables of contents, etc for the pdf.
15:35:11 <sehute> profmakx: yeah, exactly :D
15:35:23 <sehute> profmakx: sure could beat flash
15:35:47 <edwardk> anyways, i like cocoon if only coz there are a wide array of transformers already assembled for it
15:36:02 <edwardk> that and it has a 'flowscript' system that lets you do continuation based web programming
15:36:03 <sehute> profmakx: on the other hand, there might be haskell-implementations in Java?
15:36:22 <sehute> profmakx: a haskell2applet might do the trick?
15:36:56 <edwardk> well, trying to get stg or grin to compile down to javascript now =)
15:37:23 <edwardk> would give me ghc or jhc respectively
15:37:50 <edwardk> just wish it was easier to get at stg in ghc
15:40:15 <sjanssen> sehute: one could write a YHC bytecode interpreter in Java (if there isn't one already)
15:40:50 <sehute> sjanssen: that would be really nice to have, especially if it targeted an open implementation
15:40:55 <edwardk> sjansse: how fares the summer of code?
15:41:05 <sehute> sjanssen: yeah, how is unicode going? :)
15:41:19 <edwardk> not to jump all over you the moment you show up =)
15:41:30 <sjanssen> edwardk, sehute: you will see some unicode code soon
15:41:35 <edwardk> woot
15:41:37 <sehute> whoppi :)
15:41:48 <sjanssen> I've only got a week or so left, so it better be soon
15:42:15 <edwardk> yeah
15:42:28 <sehute> coding = planning really well :P
15:42:29 <edwardk> do you have to do both that and the data.rope stuff to get paid?
15:42:36 * dcoutts is eager to see unicode packed string code too
15:42:56 <dcoutts> sjanssen, was parsec ever part of your plan?
15:43:12 <sjanssen> dcoutts: It was . . . but I've just run out of time
15:43:24 <sjanssen> it's something I still want to do though
15:43:35 <dcoutts> the basic unicode stuff turned out to be harder than it looked ?
15:43:41 <dcoutts> it'd be nice
15:43:54 <dcoutts> and I want a binary serialisation system too :-)
15:44:01 <sjanssen> things have just taken too long
15:44:12 <dcoutts> and gzip/gunzip, and ... etc etc
15:44:29 <sehute> oh, and a library for rendering the entire unicode-set in ascii-graphics! With soundeffects! And a spinning cube on the top!
15:44:34 <sjanssen> I still think that generic Parsec will be easy with my Stringable class, so I'm confident that I'll get around to it someday
15:44:42 <sehute> ;)
15:44:42 <dcoutts> sehute, pftt, that's easy
15:46:12 <sehute> I once read a book by a Norwegian author named Erlend Loe that meant that exclamation points should be allowed to be used perhaps once a year per person
15:46:22 <dcoutts> hah!
15:46:37 <foxy> dcoutts: Did you find the problem with that cut-down file?
15:46:49 <dcoutts> foxy, sorry, not looked at it yet
15:46:54 <foxy> :)
15:47:09 <dcoutts> I've been chasing performance issues in ByteString.Lazy
15:48:20 <sehute> good night people :)
15:48:28 <sehute> good luck with the unicode sjanssen
15:50:29 <dcoutts> foxy, btw labelSetJustify doesn't mean what you think it means
15:50:41 <dcoutts> it doesn't set the alignment
15:50:54 <dcoutts> and it makes no difference unless you've got more than one line of text
15:51:06 <dcoutts> it's about how multiple lines align with each other
15:51:45 <dcoutts> foxy, you want miscSetAlignment
15:52:09 <dcoutts> or set cmd [ miscXalign := 0 ]
15:52:34 <dcoutts> there's alignment and padding
15:52:45 <dcoutts> alignment is a real value 0..1
15:52:50 <dcoutts> padding is in pixels
15:53:42 <dcoutts> foxy, so the default alignment is in the middle, ie 0.5, so just set it to 0, and possibly using some non-0 X padding if you want a slight left margin
15:58:56 <foxy> dcoutts, OK, I'll fix that -- that code was already there btw ;)
15:58:58 <dcoutts> foxy, as for the notebookSetCurrentPage, it doesn't do anything if the notebook widget is not visible.
15:59:14 <dcoutts> one could probably argue that's a bug in Gtk+
15:59:44 <foxy> dcoutts: But I'm pretty sure the notebook widget is visible when that function is called
16:00:04 <dcoutts> foxy, really? is the window it's in visible too?
16:00:16 <foxy> yup
16:00:21 <dcoutts> when I swap the order of widgetShowAll box and notebookSetCurrentPage box 1 then it works
16:00:30 <foxy> oh
16:00:40 <dcoutts> in the code you sent me
16:00:51 <foxy> ah, but it's window 2 that doesn't come to the front
16:00:55 <dcoutts> in the yi code it's more complicated
16:01:01 <dcoutts> yes, they're ordered from 0
16:01:12 <dcoutts> so the second tab comes to the front
16:01:31 <foxy> so I just need to swap those two calls?
16:01:50 <dcoutts> well in the test case you sent me, yes
16:02:00 <dcoutts> not sure about in yi, it's a bigger prog :-)
16:02:25 <dcoutts> I'm going to file a bug about it not working before it's shown
16:06:00 <kpreid> is there any documentation of the initial discovery/discussion of using a monad for IO?
16:06:51 <foxy> dcoutts: OK, thanks for your help
16:09:22 <Jonex> newsham: Awake still?
16:10:00 <stepcut> kpreid: did you read 'History of Haskell' already?
16:10:15 <kpreid> never heard of it.
16:10:16 * kpreid looks
16:10:34 <Jonex> newsham: Just wanted to tell you that the set type in python will be just as good as dict if you don't care about the value.
16:10:43 <thetallguy> kpreid: http://research.microsoft.com/~simonpj/tmp/history-v2.pdf
16:10:45 <foxy> dcoutts: Can you explain why the second window has scroll bars and the first doesn't?
16:12:50 <kpreid> stepcut: I note that the obvious "History" link goes to a page named that but not mentioning that paper
16:13:16 <dcoutts> foxy, because you're not calling scrolledWindowSetPolicy on it
16:13:38 <foxy> ah
16:13:40 <dcoutts> foxy, can you see the typo?
16:13:53 <dcoutts> you're missing a '2'
16:14:09 <dcoutts> fix that and it works
16:14:25 <foxy> found it!
16:17:29 <thetallguy> kpreid
16:17:33 <thetallguy> Look above
16:17:52 <kpreid> yes, I meant to address you
16:17:58 <kpreid> I am reading it now
16:18:04 <kpreid> I also now see that it is very new
16:18:17 <thetallguy> Not published yet.
16:18:20 <thetallguy> Out for review
16:39:21 <dcoutts> foxy, see http://bugzilla.gnome.org/show_bug.cgi?id=351112
16:39:24 <lambdabot> Title: Bug 351112 - gtk_notebook_set_current_page fails when the notebook has not yet b ...
16:40:48 <foxy> dcoutts, great, I'll keep an eye on it.  Thanks again :D
16:40:53 <dcoutts> np
16:46:55 <dcoutts> Igloo, did you have any thoughts on the Cabal configurations stuff?
17:04:41 <foxy> Iis there a way to configure Cabal to use unix file hierarchies on windows?  i.e. When I say ./Setup configure --prefix=/usr/local on windows package 'foo' will have a directory  /usr/local/foo but I would prefer .exe to go to /usr/local/bin etc.
17:07:29 <dcoutts> foxy, look at setup configure --help
17:07:36 <dcoutts> it mentions --bindir --libdir and others
17:07:58 <foxy> what a pain though, couldn't there be a switch
17:08:03 * foxy is lazy
17:08:14 <dcoutts> most windows users want it the windows way
17:09:01 <johnnowak> i maintain that they don't know what they want.
17:09:31 <dcoutts> hah
17:09:47 <foxy> I would be using linux if I could, I have MSYS and X-mouse to make my computer as *nxy as possible
17:10:00 <johnnowak> why can't you?
17:10:26 <foxy> because I need to be able to use Matlab and I only have a Windows version
17:10:38 <johnnowak> ah.
17:10:56 <dcoutts> get a free copy of vmware and use that to run matlab
17:11:04 <johnnowak> i think matlab even runs well under WINE
17:11:06 <dcoutts> or use vmware on windows to run linux!
17:11:15 <foxy> @where vmware
17:11:16 <lambdabot> I know nothing about vmware.
17:11:29 <foxy> @google vmware
17:11:31 <lambdabot> http://www.vmware.com/
17:11:31 <lambdabot> Title: VMware - Virtualization Software
17:11:42 <foxy> @help where
17:11:42 <lambdabot> where <key>. Return element associated with key
17:11:44 <dcoutts> I used linux at my past employment for quite a while that way, 'til I found an old spare box to do a proper install
17:11:56 <foxy> @help where+
17:11:57 <lambdabot> where+ <key> <elem>. Define an association
17:12:13 <foxy> @where+ vmware http://www.vmware.com/
17:12:14 <lambdabot> Done.
17:12:42 <foxy> Does vmware use much memory?  I'm already crashing Matlab regularly
17:13:24 <johnnowak> you may want to use wine then. it's just a reimplementation of the win32 apis so there should be much of a hit, if any
17:13:31 <johnnowak> i don't think vmware eats much though
17:14:41 <beelsebob> Xen is supposed to be a bit better in terms of RAM than VMWare
17:14:44 <beelsebob> at least at the low end
17:16:30 <johnnowak> you'd think there'd be a free or cheap linux crossgrade...
17:21:53 <SamB_XP> johnnowak: a what?
17:22:50 <johnnowak> Oftentimes, one can pay a small fee if one already owns a given software for a certain platform in order to obtain a license of another platform.
17:23:27 <johnnowak> You usually send back your X copy and get a Y copy.
17:23:47 <SamB_XP> what versions of Y are available?
17:24:41 <johnnowak> er.. just S and K at the moment
17:25:12 <SamB_XP> and how do those compare with X11R7?
17:26:09 <johnnowak> 20% faster TTL on my AMD64 w/ 2.6.13
17:39:42 <Cale> mean?
17:41:00 <Cale> heh, perhaps I shouldn't refer to threads that are hours old :)
17:56:54 <vincenz> Cale: what was that prolog system you and xerox were talking about
17:59:49 <Cale> vincenz: just implementing a nondeterminism monad with something like prolog's cut
18:00:16 <LordBrain> where can i read about seq?
18:06:32 <Cale> LordBrain: mostly all there is to know is that evaluating  (a `seq` b)  will evaluate the top-level constructor in a before returning b.
18:09:52 <LordBrain> hmmm
18:10:55 <vincenz> Cale: that's a better description than I had heard about seq :)
18:13:07 <petekaz> OT: any mac users out there? what do you use for an IRC client?
18:13:37 <dgoldsmith> Colloquy. http://colloquy.info/
18:13:39 <lambdabot> Title: Colloquy: IRC &amp; SILC Client
18:13:46 <johnnowak> I second Colloquy.
18:14:12 <johnnowak> some interesting non-gui clients at www.wmii.de as well
18:14:12 * vincenz thinks that irc clients should be terminal based
18:14:26 <petekaz> ok .. I was looking at Xirc and Colloquy, just wasn't sure which one to pick.
18:14:30 <johnnowak> http://www.wmii.de/wmii/index.php?page=ii -- very cool
18:14:31 <lambdabot> Title: window manager improved 2
18:14:52 <LordBrain> you can probably get irssi on mac os x
18:14:59 <petekaz> vincenz: I tend to agree, I've used ERC in my emacs session for years which runs in a screen session that I take everywhere with me.
18:15:17 <johnnowak> no reason to switch then
18:16:02 <johnnowak> colloquy is just a nice gui on irssi
18:16:21 <LordBrain> hmmmm i think they should have a client daemon, so you can do more than switch terminals, you could actually switch clients... if there was a protocol for such a thing.
18:16:24 <petekaz> Yeah, but the mac stuff is so nice looking.  I've finally taken a peek at Aquamacs, and I am trying to set myself up locally instead of just using the mac as a ssh client.
18:16:36 <LordBrain> but the irc client makers all want you to use only one client.
18:16:40 <LordBrain> hehe
18:17:04 <petekaz> I wish I could use Aquamacs to connect to my emacs session running on my linux box.
18:17:08 <johnnowak> ii gives irc a filesystem interface, so you could write any number of clients for it
18:19:03 <petekaz> well, another mac question (intel), I want to build my own ghc.  But I need happy it seems.
18:19:38 <petekaz> nevermind, I forgot I have a copy of ghc on here that I can use to build it.
18:19:55 * johnnowak wishes ghc wasn't so ghc dependent 
18:21:51 <SamB> ack ack ack...
18:32:38 <benja_> just in case anybody was wondering what template haskell is for: http://www.xoltar.org/2003/aug/13/templateHaskellTupleSample.html
18:32:40 <lambdabot> Title: Template Haskell Example
18:33:06 <edwardk> benja: i have some type level hex arithmetic code that abuses it too
18:33:11 <petekaz2> excellent, I've been meaning to learn about this.
18:33:20 <benja_> reveals that it's so that we can abbreviate 'let [foo, bar, baz] = list_of_stuff' to 'let (foo, bar, baz) = $(tuple 3) list_of_stuff'
18:33:37 <benja_> petekaz2: sorry, I wasn't speaking seriously =)
18:33:49 <edwardk> heh
18:34:56 <johnnowak> thank benja_
18:35:19 <petekaz2> Could I use TH to enable better support for string pattern matching?  For example, in Erlang, I can basically do something like: test("abc":Rest) which really means: test('a':'b':'c':Rest)?
18:36:03 <benja_> petekaz2: well, you can't add syntax ... so it would probably become more verbose
18:36:16 <edwardk> petekaz: would have to be careful the input to a th macro has to typecheck as well in some ways. the result would probably be something like
18:36:27 <SamB> yeah, it would most likely only be worth it for fairly long strings...
18:36:59 <edwardk> heh
18:37:03 <edwardk> nevermind it would be horrid =)
18:37:11 <edwardk> pattern matching is hard in th =)
18:37:20 <SamB> is it now?
18:37:20 <benja_> ''Unfortunately the original paper does not reflect the currently implemented syntax, which undoubtedly causes all sorts of confusion amongst the unsuspecting masses. The new syntax and API are documented in âNotes on Template Haskell Version 2â, by Tim Sheard and Simon Peyton Jones http://research.microsoft.com/~simonpj/tmp/notes2.ps. The placement of this paper in the tmp directory is apparently a little known way to indicate that someth
18:37:35 <benja_> oops, that quote was longer than I though :)
18:37:36 <SamB> @hoogle charP
18:37:37 <lambdabot> Text.ParserCombinators.Parsec.Char.CharParser :: type CharParser st a
18:37:37 <lambdabot> Language.Haskell.Syntax.HsCharPrim :: Char -> HsLiteral
18:37:43 <edwardk> well, it wouldnt be succinct enough to justify using for that case
18:37:51 <SamB> @hoogle CharP
18:37:52 <lambdabot> Text.ParserCombinators.Parsec.Char.CharParser :: type CharParser st a
18:37:52 <lambdabot> Language.Haskell.Syntax.HsCharPrim :: Char -> HsLiteral
18:37:53 <benja_> "...The placement of this paper in the tmp directory is apparently a little known way to indicate that something is indispensable."
18:38:17 <SamB> @type Language.Haskell.TH.charP
18:38:18 <lambdabot> Not in scope: `Language.Haskell.TH.charP'
18:38:23 <SamB> @type Language.Haskell.TH.Library.charP
18:38:24 <lambdabot> Couldn't find qualified module.
18:38:25 <lambdabot> Maybe you're using the wrong syntax: Data.List.(\\) instead of (Data.List.\\)?
18:38:31 <SamB> @type Language.Haskell.TH.Lib.charP
18:38:32 <lambdabot> Not in scope: `Language.Haskell.TH.Lib.charP'
18:38:47 <edwardk> samB: unless you want to pattern match against a sentence or two it hardly seems worth it =)
18:38:52 <SamB> hehe
18:39:05 <SamB> you can't splice them properly, then?
18:39:15 <edwardk> you can, its just verbose.
18:39:59 <edwardk> plus i don't know their status: http://www.haskell.org/pipermail/glasgow-haskell-bugs/2003-July/003392.html
18:40:00 <lambdabot> Title: Template Haskell, [p|...|]
18:40:14 <SamB> I said splice
18:40:28 <edwardk> splice = $(...) right?
18:40:54 <edwardk> you can, but the idea above was to shorten writing 'a':'b':'c' to "abc" any splice there will wind up being rather verbose
18:41:13 <SamB> oh, yes, of course
18:41:24 <SamB> $(f "abc") at best
18:41:29 <edwardk> yep
18:41:38 <edwardk> then getting a rest marker on there
18:41:52 <SamB> oh, yeah...
18:42:10 <SamB> that *would* be tricky
18:42:11 <edwardk> hence why when i went to write the throwaway example, i just stopped =)
18:45:16 <benja_> how about (splice foo [d|    f ("Foo"&rest) = bar;   f ("Bar"&rest) = baz    |])?
18:45:17 <edwardk> strP s v = return $ ListP $ map (LitP . CharL) s  ++ (VarP $ mkName v)
18:45:30 <edwardk> $(strP "foo" "rest")
18:45:44 <benja_> (writing 'foo' being left as an exercise to the reader)
18:46:02 <edwardk> strP above should work
18:46:05 <SamB> edwardk: I have difficulty believing that the name would then be in scope for Haskell code...
18:46:29 <edwardk> edwardk: strP would have to be in a where binding on the clause or in another module =)
18:46:59 <SamB> edwardk: talking to yourself, are you?
18:47:32 <edwardk> yep =)
18:47:33 <benja_> benja_: hm, perhaps I should occasionally do that, too
18:47:42 <SamB> why?
18:47:50 <SamB> are you trying to attract your attention?
18:48:03 <benja_> oh, did I say that out loud?
18:48:05 <edwardk> yah, usually I ignore me
18:48:13 <benja_> /msg benja_ don't do that
18:48:56 <SamB> SamB: what, you don't think talking to yourself is a good thing to do?
18:49:07 <edwardk> I actually have no idea where the edwardk on that line came from =) maybe i hit tab
18:49:43 <edwardk> in any event, the strP thing should work =)
18:49:46 <SamB> hmm hmm hmm
18:49:55 <SamB> this int_to_condition will be very slow, most likely...
18:50:25 <edwardk> int_to_condition?
18:50:52 <SamB> I'm still trying to read the blueprint
18:51:02 <SamB> I bet my approach is stupid
18:51:11 <edwardk> ah from adventure?
18:51:15 <SamB> yeah
18:53:42 <SamB> the code I have in front of me is supposed to search the trash heap for something broken to steal a kindlist from...
18:54:02 <SamB> ... and it does this very many times...
18:54:14 <SamB> well, not yet it doesn't, but it will
18:55:35 * edwardk never did get around to programmatically tackling adventure
18:56:06 <SamB> I had to do a lot of stuff by hand...
18:56:10 <SamB> or did, anyways
18:56:22 <SamB> but did write a solver that helped a lot
18:56:38 * edwardk nods.
18:56:49 <SamB> I did not learn prolog, though
18:57:21 * edwardk has done his best to forget prolog ;)
18:57:32 <SamB> that bad, is it?
18:57:42 <edwardk> depends on what you like
18:57:52 <edwardk> its definitely not what i like =)
18:57:57 <SamB> my solver is totally aimless
18:58:13 <SamB> though it has a bias towards incinerating things at this point
18:58:24 <edwardk> kind of hard to solve something without a goal
18:58:43 <edwardk> and isn't incinerating capable of leving you in a state with no path to win?
18:58:48 <edwardk> er leaving
18:59:00 <SamB> oh, well, it looks through the tree for a state (with attached path) meeting a simple condition, but it doesn't do anything to work towards that in particular
18:59:52 <SamB> it does not connect to the UM or anything, just runs off a dumped item list
19:00:18 <edwardk> ah
19:00:32 <edwardk> how can you test if anything worked without feedback from the um?
19:00:55 <SamB> well, it is only for the puzzles where you put things together
19:01:02 <SamB> the rules for that are pretty simple
19:01:25 <SamB> so you just sort of build in a simulator
19:03:41 <SamB> I don't suppose you figured out the premise of the story yet?
19:04:35 <edwardk> that would require me to have played with it for more than 2 minutes =)
19:04:44 <SamB> heh, yeah ;-)
19:05:08 <SamB> I cannot really talk about what I'm doing without revealing it...
19:05:10 <edwardk> i basically putzed with it, got an item or two to combine, then said fuck it =)
19:05:14 * edwardk nods.
19:05:40 <SamB> I can't even remark at how much this tool I wrote in Haskell is helping ;-)
19:05:46 <SamB> (it isn't the solver)
19:05:48 <edwardk> heh
19:05:59 <SamB> well, not properly anyway
19:08:18 <petekaz2> any mac intel users have a 'happy' that can give me.  i am having a problem trying to build it.
19:09:45 <petekaz2> or alternatively, what did you do to compile it?
19:09:49 <SamB> its actually a pretty good IF for being so puzzle-heavy and suing so much RAM...
19:10:05 <SamB> petekaz: sorry, not a mac user...
19:10:31 <SamB> does qemu support running Linux programs on Darwin yet?
19:11:53 * SamB wrote a "lint" tool for RML
19:19:40 <dgoldsmith> petekaz2: I was able to build happy by editing the configure file. I copied the entry for powerpc-apple-darwin and made one for i686-apple-darwin, changing all the target stuff to i386-apple-darwin. It built.
19:20:04 <dgoldsmith> I have no idea if it works. :)
19:20:38 <SamB> dgoldsmith: why didn't you try using it?
19:20:45 <petekaz2> dgoldsmith: thx.
19:20:47 <dgoldsmith> No idea how to test it...
19:20:58 <dgoldsmith> "make" succeeded though.
19:21:03 <dgoldsmith> @where paste
19:21:04 <lambdabot> http://paste.lisp.org/new/haskell
19:21:34 <lisppaste2> dgoldsmith pasted "patch to happy configure" at http://paste.lisp.org/display/24046
19:22:32 <dgoldsmith> Just look for powerpc-apple-darwin and paste this in right after.
19:23:07 <petekaz2> thx.
19:35:00 <dons> moin
19:36:30 <sjanssen> hello dons
19:39:08 <dons> hey sjanssen. how's the code going?
19:40:30 <sjanssen> good!  I'm at the point where I can actually run some quickchecks against StorableVector
19:40:30 * dons extracts some caffeine
19:40:35 <dons> cool!
19:40:43 <dons> good news
19:40:44 * foxy takes a ticket in the dons queue
19:42:21 <dons> foxy: you sent me a patch, yes?
19:42:36 <dons> in this damn winmail.dat format, but anyway ;)
19:42:49 * dons coffee. back soon
19:43:20 <dcoutts> morning dons!
19:43:24 <foxy> dons, yes.  I fixed a previous error but now either the new window doesn't get focused and can be edited or it gets focused and everything hangs
19:43:46 <dcoutts> foxy, more gui troubles?
19:44:00 <dcoutts> foxy, it's a good thing you're persistent :-)
19:44:16 <foxy> dcoutts, yep, this time I think it's yi code at fault
19:44:33 <foxy> dcoutts, heh, I consider Haskell fun cf. work
19:45:23 <dcoutts> :-)
19:45:27 <lisppaste2> petekaz pasted "Building GHC question" at http://paste.lisp.org/display/24048
19:48:37 <dcoutts> petekaz, is that the latest darcs version?
19:48:54 <petekaz2> yes.
19:49:29 <petekaz2> I'm using 6.5 to build it, is that ok?
19:50:12 <petekaz2> (never built GHC before)
19:50:55 <dcoutts> petekaz2, try building ghc-6.5 using ghc-6.4.2, that's supported.
19:51:30 <petekaz2> ok, I'll go search for a 6.4 mac intel version.
19:51:40 <dcoutts> each version of 6.5 should probably build with itself and with 6.4.2
19:51:53 <dcoutts> ah, I see, that may be a problem
19:51:58 <sjanssen> petekaz: I don't think there is a 6.4 intel mac version
19:52:03 <petekaz2> oh.
19:52:38 <dgoldsmith> There isn't.
19:52:43 <petekaz2> well, I can be happy using the prebuild 6.5 version I have then ... building source code is so gentoo.
19:52:50 <dcoutts> petekaz2, either wait or hack the ambiguities yourself
19:53:11 * dcoutts hugs gentoo
19:53:27 <dgoldsmith> petekaz2: were you able to get happy to build?
19:53:40 <petekaz2> dgoldsmith: yup. I did the same for 'alex' as well.
19:53:44 <petekaz2> but both built.
19:53:53 <dcoutts> pftt just imagine relying on other people to build source code for you, what a silly idea
19:55:20 <dcoutts> dons, so results on the lazy bytestring stuff, readLStrUp is blindingly quick
19:55:32 <dcoutts> writeLStrUp is fantastically slow
19:56:48 <dcoutts> F.lengthS . F.readLStrUp  is faster than for strict ByteString on a 50Mb file, probably since it can stay within L2 cache the whole time, including GC etc.
19:59:59 <dcoutts> it's 0.24s for strict and 0.19s for lazy
20:00:05 <dcoutts> which is nice
20:00:21 <dcoutts> so the Q is, why's the writeLStrUp soooo slooow
20:00:39 <sjanssen> @hoogle Ptr
20:00:39 <lambdabot> Foreign.Ptr :: module
20:00:40 <lambdabot> Foreign.Ptr.Ptr :: data Ptr a
20:00:40 <lambdabot> GHC.Exts.Ptr :: Addr# -> Ptr a
20:00:47 <dcoutts> a simple id = F.writeLStrUp . F.readLStrUp  takes over 3sec
20:02:28 <dcoutts> compared to 0.3 sec for strict
20:04:14 <sjanssen> it'd be nice if Cabal+Hugs would check if your source parses/typechecks in the build stage
20:07:49 <dcoutts> sjanssen, aye
20:07:51 <dcoutts> file a bug
20:09:32 <dons> dcoutts: hmm. so is ghc generating some bad core?
20:09:53 <dcoutts> dons, not sure yet, I might be giving it bad code
20:10:10 <dcoutts> I'm comparing it with our nice reallocing strict version
20:11:19 <dons> oh, we should add that 4k-and-don't-trim/realloc to the createAndTrim functions too
20:11:58 <dcoutts> aye
20:12:13 * dons looks at the code
20:15:03 <dcoutts> for the moment I'm just going to expand that inline in writeLStrDn
20:15:13 <dcoutts> er Up
20:15:17 <dcoutts> like I did for writeStrUp
20:15:33 <dcoutts> there's no point trying to abstract in that bit of code
20:15:46 <dcoutts> it's too performance critical to fiddle with
20:15:58 <dcoutts> all the inlining there is rather subtle I fear
20:16:22 <dons> yep
20:16:31 <dcoutts> well, it's very subtle, note all the {-# NOINLINE #-} bits to make the loop go faster :-)
20:16:50 <dons> yeah. ah well.
20:17:17 <dcoutts> it's more handy to have those things in the hand written 1 shot versions
20:17:23 <dcoutts> since there's lots of them
20:17:46 <dcoutts> so the clarity and not making copy&pastos is more important
20:18:36 <dcoutts> dons, so any suggestion on the benchmark we should use in our intro?
20:19:01 <dcoutts> I hacked on the log file one a bit this afternoon and got some surprising results on space usage
20:19:19 <dons> yeah, I saw.
20:19:22 <dcoutts> it's a neat program and it gives some nice improvements essentially for free
20:19:43 <dons> i don't have a really compelling example yet. maybe i'll have a peek at the existing fusion papers
20:20:08 <dcoutts> good idea
20:20:35 <dcoutts> I noticed from the heap profiling that when doing lines, we do end up with a lot of space overhead
20:20:52 <dcoutts> since we've got 20 bytes for the PS
20:21:03 <dons> hmm
20:21:05 <dcoutts> 12 for the (:) cons cell
20:21:16 <dcoutts> and 8 for the ForeignPtrContents
20:21:28 <dcoutts> oh, no the ForeignPtrContents is shared between substrings
20:21:44 <dcoutts> so 32 bytes
20:22:19 <dcoutts> 32 for lazy 20 for strict
20:22:46 <dcoutts> but that's actually as significant fraction of the length of an average line of text
20:22:55 <dons> ah right. I thought we shared the underlying FP
20:23:09 <dcoutts> no, it's unboxed into the PS
20:23:29 <dcoutts> the FP consists of a Addr# and a ForeignPtrContents
20:23:30 <dons> right
20:24:46 <dcoutts> so it's not suprising that the PS & (:) appeared as a significant fraction of the actual string data
20:25:31 <dcoutts> it might be worth, as you mentioned before, to unbox the PS into the list
20:25:45 <dcoutts> ie have a special element-strict LPS list
20:25:49 <dons> hmm. right
20:26:07 <dcoutts> it'd save an indirection and 8 bytes I think
20:28:52 <dcoutts> heh, remember that Bulat was comlaining about the space overhead of a ForeignPtr
20:29:07 <dcoutts> his suggestion was just to use ByteArray#
20:29:20 <dcoutts> well I think that'd only save 4 bytes overall
20:29:43 <dcoutts> since we wouldn't need the ForeignPtrContents in the PS constructor
20:30:34 <dons> ah yes! heh
20:30:38 <dcoutts> well, in the case that the ForeignPtrContents can't be shared then it saves the ForeignPtrContents too which is 12 bytes
20:31:04 <dcoutts> but very often it can
20:32:03 * dcoutts sends dons a rule bug fix
20:32:30 <dons> good good
20:42:33 <dons> ?uptime
20:42:33 <lambdabot> uptime: 1 day, 17 hours and 36 minutes
20:42:37 <dons> ?quit yarr!
20:42:48 <vincenz> @bot
20:43:00 <vincenz> dons: next time use this
20:43:06 <vincenz> @. @quit @yarr
20:43:11 <vincenz> @. quit yarr
20:43:12 <vincenz> l
20:43:34 <dcoutts> @arr
20:43:55 <dcoutts> lambdabot?
20:43:58 <dcoutts> @botstack
20:44:02 <lambdabot> Smartly me lass
20:44:08 <lambdabot> :)
20:44:17 <dcoutts> @yarr!
20:44:17 <lambdabot> Splice the Mainbrace!
20:44:23 <dcoutts> yay :-)
20:44:24 <vincenz> @yarr!
20:44:24 <lambdabot> Arr! Me ship be the biggest brig in the port!
20:44:31 <vincenz> :)
20:44:44 * dcoutts added some more pirate quotes
20:45:01 <dcoutts> thanks for accepting my first lambdabot patch dons :-)
20:45:36 <dcoutts> note how @arr and @yarr are subtly different
20:45:39 <dons> :)
20:45:49 <dcoutts> well, it's an important mater when you're a pirate
20:45:52 <dcoutts> @arr
20:45:53 <lambdabot> Drink up, me 'earties
20:46:09 <dons> aah!
20:47:28 <vincenz> what's the diff?
20:47:52 <dcoutts> @yarr!
20:47:53 <lambdabot> Avast!
20:47:55 <dcoutts> @yarr!
20:47:55 <lambdabot> I heard andersca is a pirate
20:47:58 <dcoutts> @yarr!
20:47:59 <lambdabot> Yo ho ho, and a bottle of rum!
20:48:02 <dcoutts> @yarr!
20:48:03 <lambdabot> Arr! Me ship be the biggest brig in the port!
20:48:18 <dcoutts> vincenz, yarr! is more of a greeting
20:48:29 <dcoutts> arr is more of an afermative
20:48:39 <vincenz> how'd you fix that?
20:48:42 <vincenz> partition the line-set?
20:48:47 <dcoutts> yes
20:48:59 <dcoutts> one is a subset of the other
20:49:15 <dcoutts> and I added a few more just for good measure
20:49:33 <vincenz> @arr
20:49:34 <lambdabot> Drink up, me 'earties
20:49:36 <vincenz> @arr
20:49:36 <lambdabot> I want me grog!
20:49:40 <vincenz> @yarr!
20:49:41 <lambdabot> Yarrr!
20:50:21 <dcoutts> see? :-)
20:50:31 <dcoutts> @yarr
20:50:31 <lambdabot> Swab the deck!
20:53:03 <lucca> Arr, drop yer pants and prepare to be boarded.
20:53:17 <vincenz> LOL
20:54:56 <lucca> hm, I may have scared him away.
20:55:08 <vincenz> who wouldn't be scared
20:55:11 <vincenz> you're a manly man
20:55:31 <lucca> heh
20:56:05 <vincenz> and that's how the song goes "We're men...we're men in tights..."
21:04:19 <satan> how do i count the # of times a function is called? like a static int in C or whatever
21:05:18 <dons> you'd need to use some kind of accumulator state
21:05:25 <dons> either in IO or the ST monads.
21:05:40 <dons> _or_
21:05:45 <dons> just profile your code with -prof -auto-all
21:05:58 <dons> and then look at the profiling output, which includes these counts
21:06:02 <satan> ah
21:06:10 <satan> ok thanks dons i'll check it out
21:06:13 <dons> i.e. ghc -O -prof -auto-all Foo.hs ; ./a.out +RTS -p
21:06:23 <dons> then the file 'a.out.prof' contains the call graph, and other ifo
21:06:25 <dons> info
21:06:29 <satan> wow ok
21:06:35 <Pupeno> Hello.
21:06:48 <Pupeno> Is anybody using Haskell to build web applications ?
21:07:06 <stepcut> Pupeno: yes
21:07:08 <dons> sure. lots of people
21:07:13 <dons> ?where happs
21:07:13 <lambdabot> I know nothing about happs.
21:07:17 <dons> ?where HAppS
21:07:18 <lambdabot> I know nothing about happs.
21:07:21 <dons> ?google happs
21:07:22 <lambdabot> http://www.happs.com.au/
21:07:23 <lambdabot> Title: Welcome to Happs &amp; Three Hills
21:07:25 <dons> bah
21:07:35 <Pupeno> ?google haskell happs
21:07:36 <sm> http://happs.org
21:07:38 <lambdabot> http://www.cs.helsinki.fi/u/ekarttun/haskell/HAppS-httpd/
21:07:38 <lambdabot> Title: Index of /u/ekarttun/haskell/HAppS-httpd
21:07:38 <lambdabot> Title: HAppS -- Haskell Application Server (version 0.8 )
21:07:50 <dons> ?google haskell hope bringert
21:07:53 <lambdabot> http://www.scannedinavian.com/hope/
21:07:54 <stepcut> ?where hope
21:07:54 <lambdabot> http://hope.bringert.net/
21:07:58 <dons> ?where wash
21:07:58 <Pupeno> but any concrete example ?
21:07:58 <lambdabot> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
21:08:05 <dons> Pupeno: look above at happs.org
21:08:11 <dons> or http://www.scannedinavian.com/hope/
21:08:26 <dons> or go to haskell.org and look at the libraries/web* stuff
21:08:35 <stepcut> Pupeno: I believe the hope site, and shaprs weblog are both using hope
21:08:41 <dons> ?where+ happs http://happs.org
21:08:42 <lambdabot> Done.
21:09:03 <Pupeno> dons: I know there are tons of frameworks, nice, very nice... there are even more on common lisp, all mostly useless. There's a huge amount of Python ones... only to get one or two that doesn't suck.
21:09:37 <sm> hi Pupeno
21:09:50 <sm> they all have some great strengths, but none of them are heavily used yet
21:09:50 <dons> dive in and try them out then. we've suggest those that are most widely used. wash, happs, hope. there's others too
21:11:07 <stepcut> IMO Haskell + web apps is still a bit immature, but there seems to be a lot of interest in that area right now -- so hopefully it will mature quickly
21:11:57 <SamB> Pupeno: they have web frameworks that don't suck?
21:12:05 <SamB> I thought it was part of the spec or something
21:12:10 <dons> heh
21:12:22 <Pupeno> hehe.
21:12:22 <SamB> "all web frameworks MUST suck"
21:12:54 <Cale> same goes for XML
21:13:44 <Pupeno> damn, I can't read Haskell anymore :(
21:14:19 <dons> I always wonder if the creaters of Standard ML get pissed off about all the *ML things these days, that aren't MLs ;)
21:15:59 <Pupeno> does HAppS provide its own DB system ?
21:16:11 <Pupeno> or wrapper that's it.
21:16:47 <stepcut> Pupeno: yes and no
21:16:58 <Pupeno> stepcut: can you elaborate ?
21:17:15 <stepcut> Pupeno: You have a data type that holds you content (what would typically go in a database)
21:17:50 <Pupeno> yes.
21:18:44 <Pupeno> so ?
21:18:54 <stepcut> I believe the data type is automatically serialized to disk
21:19:05 <SamB> automatically???
21:19:17 <Pupeno> mh ?
21:19:22 <stepcut> and there is a write-ahead logging mechanim -- so even if the system crashes, things are consistent
21:19:35 <stepcut> sorry, it has been a while since I looked at it
21:19:47 <SamB> there must be a class involved ;-)
21:19:50 * SamB goes to bed now
21:20:10 <Pupeno> stepcut: if it is that way, it sucks.
21:20:34 <stepcut> If I recall correctly, it was both cool and sucky at the same time
21:21:05 <dons> ?girl19
21:21:05 <lambdabot> I have stolen about 50 msn and yahoo accounts
21:21:24 <Pupeno> mixing different goals (like saving data and writting web applications) in the same package sucks... it's evil.
21:21:47 <dons> submit a patch :)
21:22:00 <vincenz> @girl19
21:22:00 <lambdabot> well.. I never hacked Russians
21:22:15 <vincenz> dons: we need a @protonorpedo
21:22:16 <stepcut> Pupeno: marshaling data between nice data structures and SQL tables is evil ;)
21:22:23 <dons> vincenz: quite so!
21:22:30 * dons greps the logs
21:22:31 <vincenz> dons: besides... I never got his nick, shouldn't it be @protontorpedo?
21:22:32 <stepcut> Pupeno: storing trees in databases is horrid
21:22:40 <Pupeno> dons: generally does mistakes can't be solved by a patch.
21:22:43 <vincenz> dons: grep for shemale as well
21:23:00 <Pupeno> stepcut: so ? even if all that is true, there's no reason to mix them.
21:23:40 <stepcut> Pupeno: perhaps. I think that is the experiment
21:23:59 <Pupeno> I see.
21:24:03 <Pupeno> Thanks.
21:24:27 <dons> vincenz: oh, there's some real gold here
21:24:30 <stepcut> Pupeno: I think HAppS could be very superior for quick prototypes
21:24:50 <Pupeno> stepcut: superior to what ?
21:24:52 <stepcut> Pupeno: but probably not so great for 'enterprise' level applications
21:25:02 <stepcut> superior to everything else
21:25:05 <stepcut> ;)
21:25:18 <vincenz> dons: :)
21:25:28 <Pupeno> stepcut: I see. Thanks.
21:28:59 <stepcut> Pupeno: in some respects it is like object relation mapping, only way simpiler. But, then again, many people consider ORM evil :)
21:29:24 <stepcut> @spell simpiler
21:29:25 <lambdabot> simpler simple sampler dimplier simile
21:30:23 <Pupeno> stepcut: let me clarify... I do not mind any particular way to handle data. I've worked with object databases, relational databases, for me, it's ok. I would even like to try new ways. What I really dislike is mixing a web framework with a data storage library. That is what sucks.
21:31:09 <stepcut> why is that ?
21:31:29 <tessier> Pupeno: Which object databases have you used?
21:31:57 <Pupeno> because they are separate tasks. A web framework should let you use whatever you want to store data and a data storage should be usable from anywhere.
21:32:15 <Pupeno> tessier: ZODB and a bit of elephant (in those days in which it didn't really worked).
21:32:34 <dons> its very disturbing reading protontorpedo's entire irc works. we should have kicked
21:32:53 <dons> identical questions repeated weeks apart
21:33:00 <dons> ie.. "is haskell a lisp"
21:33:03 <vincenz> lol
21:33:14 <dons> and weird questions about ftp and mysql
21:33:14 <vincenz> you filtered on shemale?
21:33:17 <dons> yep
21:33:21 * vincenz nods
21:33:29 <vincenz> We should some of them in lambdabot
21:33:32 <vincenz> like "is haskell a lisp"
21:33:33 <vincenz> :)
21:33:45 <dons> yeah, i'm putting them in
21:35:06 <dcoutts> dons, there's something odd going on with the writeLStrUp and I can't see what
21:35:25 <dcoutts> I've got it quite close to the strict code
21:35:34 * dcoutts -> #haskell-overflow
21:35:58 <dons> hmm
21:36:33 <vincenz> -> #oasis
21:38:09 <dons> hmm. I think protontorpedo may actually be trolling us. or possibly brain damaged. hmm
21:38:25 <vincenz> or both
21:38:29 <vincenz> I think the first implies the second
21:38:40 <vincenz> got any spectacular examples?
21:38:42 <vincenz> link?
21:38:44 <tessier> Pupeno: I need to learn more about zodb. Read a lot but haven't programmed it not
21:41:13 <stepcut> dons: perhaps protontorpedo is an advanced fork of vixen ?
21:41:53 <dons> quite possibly.
21:41:54 <vincenz> :)
21:42:01 <dons> we seem to have wasted a lot of time on him though
21:42:03 <vincenz> maybe a turing experiment?
21:42:08 <dons> with no progress at all on his part
21:42:10 <vincenz> dons: show me some examples in links?
21:42:19 <vincenz> next time I'm booting him straight away
21:42:24 <dons> vincenz: hang on. building a little protontorpedo db
21:42:30 <vincenz> :
21:42:31 <vincenz> :D
21:42:33 <dcoutts> who's protontorpedo ?
21:42:40 <stepcut> that would add a whole new level to the comment "I wonder how long it will take him (prototorpedo) to figure out Cale is a bot"
21:42:42 <vincenz> dons: I wanted to see it in context, that's why I asked
21:42:47 <vincenz> dcoutts: shemale_magic
21:42:59 <dons> vincenz: yes. i know. give me a sec or 5
21:43:02 <vincenz> sure
21:43:03 <dcoutts> that's probably not good
21:43:05 <vincenz> take your time
21:43:19 <vincenz> dcoutts: Philippa objected to his use of the name for reason I don't quite remember
21:43:28 <vincenz> something about not taking it seriously or something
21:44:26 <stepcut> vincenz: I believe the objection was that shemale is a derogatory term
21:44:49 <vincenz> no
21:44:53 <dons> definitely. that's one thing.
21:45:09 <vincenz> I thinik Philippa sees it as a valid term, but he was using it for other reasons
21:45:09 <dons> but in general, he seems to be low level trolling, or stupid and noisy
21:45:20 <vincenz> dons: I guess he hasn't leveled yet
21:45:28 <vincenz> He should ask xah lee for advise
21:45:35 <tessier> xah lee is very wise
21:45:42 * vincenz peers at tessier 
21:45:43 * tessier snickers
21:46:16 <dons> hehe
21:46:21 <vincenz> yeah
21:46:23 <vincenz> he must be level 20
21:46:27 <vincenz> I think proton is only level 2
21:46:42 <stepcut> hrm, my list of imports is getting so long, I am starting to wish for 'import *' to work :)
21:48:09 <vincenz> stepcut: do like me
21:48:11 <dons> that would be nice
21:48:14 <vincenz> stepcut: I segment my code
21:48:17 <vincenz> and then have a toplevel
21:48:22 <vincenz> for instance I ahve different parts of my AST
21:48:24 <vincenz> in AST/*.hs
21:48:28 <vincenz> such as typing, identifiers, whatnot
21:48:29 <vincenz> then I have
21:48:35 <vincenz> AST.hs
21:48:43 <vincenz> in root where I import the others and re-export em
21:48:53 <stepcut> vincenz: right now I just have a ton of imports from the standard library
21:48:57 <vincenz> ah
21:49:01 <vincenz> well make one for stdlib then
21:49:07 <vincenz> StuffIUse.hs
21:49:26 <stepcut> hrm, that could be useful
21:50:23 <vincenz> or
21:50:26 <vincenz> StdLibCrap.hs
21:54:14 <dons> ?quit add @protontorpedo
21:55:13 <sjanssen> @protontorpedo
21:55:24 <vincenz> @bot
21:55:26 <dons> we await freenode's blessing
21:55:30 <vincenz> ah yes
21:55:32 <vincenz> that's always so slow
21:55:36 <lambdabot> no I cant read online for long my eyes get fuzzy
21:55:38 <lambdabot> :)
21:55:48 <vincenz> @protontorpedo
21:55:48 <lambdabot> are objects kina just subroutines
21:55:52 <vincenz> :D
21:55:53 <vincenz> @protontorpedo
21:55:53 <lambdabot> as u scale and complexity grows?
21:56:01 <vincenz> @protontorpedo
21:56:01 <lambdabot> windows is validating itelf a lot during ownloads altely
21:56:08 <vincenz> lol
21:56:14 <vincenz> @protontorpedo
21:56:14 <lambdabot> how would haskell solve the following gnarley problem: many client distributed accross the usa, transfers must take palce in the form of file transfer, and data must be read from files, and recorded,
21:56:14 <lambdabot>  then other partners who apply taxes to this data and then give abck new files with taxes aded, then last transers to 4th parties who get us paid for the phone calls that are the product
21:56:36 <dons> this guy has a job??
21:56:43 <stepcut> dons: manager
21:56:46 <stepcut> ;)
21:56:48 <dons> ah
21:56:52 <dons> yes, makes sense
21:56:57 * stepcut is just guessing
21:57:06 <dons> ?karma+ engineers
21:57:07 <lambdabot> engineers's karma raised to 1.
21:57:13 <dons> ?karma- engineers
21:57:13 <lambdabot> engineers's karma lowered to 0.
21:57:19 <dons> ?karma- managers
21:57:19 <lambdabot> managers's karma lowered to -1.
21:57:24 <dons> ?karma+ engineers
21:57:24 <lambdabot> engineers's karma raised to 1.
21:57:41 <dons> ?protontorpedo
21:57:41 <lambdabot> is haskell better than APL or perl or clisp?
21:57:58 <vincenz> dons: what were you referring to earlier in logs when you said he really was a pain
21:58:02 <vincenz> @protontorpedo
21:58:02 <lambdabot> Im not a loser
21:58:09 <dcoutts> hah hah
21:58:13 <vincenz> classic
21:58:19 <johnnowak> i wonder why #haskell gets so many trolls
21:58:29 <dcoutts> I don't think we get that many
21:58:31 <vincenz> johnnowak: we're too friendly a community
21:58:33 <dons> yeah, not many.
21:58:43 <dons> but maybe we put up with them for longer than we need to
21:58:44 <vincenz> dons: oh bullocks, you and dcoutts are two of the greatest trolls ever
21:58:52 <johnnowak> vincenz: perhaps it would be best to recruit a few trolls to keep the rest out?
21:58:58 <dcoutts> @yarr!
21:58:59 <lambdabot> Avast!
21:59:03 <vincenz> johnnowak: like live in trolls?
21:59:08 <johnnowak> something like that.
21:59:11 <dons> yeah, good idea!
21:59:20 <dcoutts> @troll
21:59:20 <lambdabot> tell module failed: IRCRaised Prelude.head: empty list
21:59:25 <dons> a troll army, if you will
21:59:25 <dcoutts> hah
21:59:40 <dcoutts> @troll?
21:59:40 <lambdabot> Unknown command, try @list
21:59:45 <dcoutts> @troll
21:59:45 <lambdabot> tell module failed: IRCRaised Prelude.head: empty list
21:59:54 <dons> maybe @troll should pick a random quote from our trolls?
22:00:02 <dcoutts> yes
22:00:02 <dons> vincenz: http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Quote/Text.hs
22:00:14 <dons> check the bottom of the file. its strange watching his brain tick
22:00:40 <dcoutts> what ever happened to the "are you fully nerd!??" guy?
22:00:51 <dons> silence.
22:00:57 <dons> that was such a great email though
22:01:01 <johnnowak> dons: this is amazing
22:01:01 <dcoutts> his quote kepts dissapearing iirc
22:01:22 <johnnowak> "is haskell doomed to be a mysql driver"
22:01:31 <dons> i've filtered only maybe 5% of what he's said
22:01:39 <dons> so almost everything he's said is in that list
22:01:45 <dons> talk about high quality contributions
22:02:04 <johnnowak> hehe
22:02:12 <johnnowak> very good noise to noise ratio.
22:02:13 <dons> so many questions
22:02:16 <dons> heh
22:02:24 <vincenz> ecause MIT guy philip green says haskell adn lisp are only langs where u spend more tie thinking than coding
22:02:28 <vincenz> one owuld think that a good thing
22:03:07 <vincenz> his grammar is great too :)
22:03:20 <vincenz> "can haskell do same stuff as J2EE but nicer"
22:03:25 <dons> ?remember DennisHeuer Are you fully nerd????
22:03:26 <lambdabot> Done.
22:03:39 <vincenz> @remember vincenz Geek is Chique.
22:03:39 <lambdabot> Done.
22:03:47 <dons> ?remember DennisHeuer What is that???? Your strategy shows that you just don't care.
22:03:48 <lambdabot> Done.
22:03:55 <vincenz> ooh
22:04:00 <vincenz> lisq :)
22:04:07 <vincenz> (lots of incessant silly questionmarks)
22:04:29 <dons> the world is so wondrous and new for protontorpedo.
22:04:31 <dcoutts> yeah, quite a good troll
22:04:34 <Jormunder> @list
22:04:35 <lambdabot> list [module|command]. Where modules is one of:
22:04:35 <lambdabot> babel base compose dice dict djinn drhylo dummy elite eval fact fresh haddock help hoogle instances karma lambda localtime log more pl poll pretty quote search seen slap spell state system tell todo
22:04:35 <lambdabot> topic type unlambda url version vixen where
22:04:45 <vincenz> dons: "oleg?"
22:04:53 * vincenz BAHAHAS
22:05:03 <dons> :)
22:05:07 <Jormunder> @list hoogle
22:05:07 <lambdabot> hoogle provides: hoogle hoogle+
22:05:09 <sjanssen> when was this guy around?
22:05:14 <dcoutts> a good mixture of half plausible questions and 'bs'
22:05:25 <vincenz> sjanssen: few days ago
22:05:31 <vincenz> but he's a repeat-troll
22:05:41 <vincenz> @protontorpedo
22:05:41 <lambdabot> help please
22:05:50 <dcoutts> but the shere number and shotgun approach of the Qs gives him away
22:05:51 <vincenz> I especially love how
22:06:00 <vincenz> "troll?" "cmon Im asking cool questions" are so close together
22:06:11 <dcoutts> heh heh
22:06:23 <johnnowak> i want to hug him.
22:06:23 <vincenz> followed right after by "Im not a loser"
22:06:26 <dons> yeah. that starts to give it away
22:06:30 <dons> sjanssen: right
22:06:32 <dcoutts> I like "are you wealthy concultants?"
22:06:38 <vincenz> sounds like concubines
22:06:48 <dcoutts> heh
22:07:24 <sjanssen> @shemale_magic
22:07:24 <lambdabot> Unknown command, try @list
22:07:28 <sjanssen> blast
22:07:42 * johnnowak knows someone personally who is very much like protontorpedo...
22:08:50 <dcoutts> I find that hard to believe
22:08:56 <dons> I think he knows what he's doing: "here is the big one: is it mroe prctical than say python?"
22:08:58 <dcoutts> are they a self-aware troll?
22:09:02 <satan> i'm trying to print all whole factors of a number with factors n = filter (noRem n) [1..n], where noRem returns true if the remiander is 0
22:09:12 <dcoutts> or just like that and not realising they're rambling?
22:09:18 <satan> but it complains about Num [a] ?
22:09:25 <dons> its the self aware ones that are good. who just occasionally slip
22:09:27 <dcoutts> this troll looks like they know what they're doing
22:09:50 <satan> does anyone know why?
22:09:55 <dcoutts> run for the hills, the troll is self-aware!
22:09:57 <vincenz> I thought troll implied self-awareness
22:10:08 <dcoutts> me too
22:10:48 <sjanssen> satan: that bit of code looks okay, maybe the trouble is in noRem?
22:10:57 <dcoutts> otherwise you just feel sorry for them and try not to encourage them too much
22:11:05 <johnnowak> @quote girl19
22:11:06 <lambdabot> girl19 hasn't said anything memorable
22:11:10 <vincenz> @girl19
22:11:11 <lambdabot> am I supposed to be frantic with terror and anxiety?
22:11:20 <satan> sjanssen: hmm my noRem is: noRem n x = mod n x == 0
22:11:26 <vincenz> "some dude called topmind says that oo is bs"
22:11:27 <vincenz> BWAHAHA
22:12:02 <sjanssen> > let factors n = filter (noRem n) [1..]; noRem n = mod n x == 0 in factors 12
22:12:03 <lambdabot>  Not in scope: `x'
22:12:26 <sjanssen> > let factors n = filter (noRem n) [1..]; noRem n x = mod n x == 0 in factors 10
22:12:30 <lambdabot> Terminated
22:12:40 <satan> oh dear
22:12:46 <mauke> > let factors n = filter (noRem n) [1..n]; noRem n x = mod n x == 0 in factors 10
22:12:47 <lambdabot>  [1,2,5,10]
22:12:56 <dcoutts> dons, wow!
22:13:01 <dcoutts> dons, got it
22:13:18 <sjanssen> satan: your problem is elsewhere in your program
22:13:20 <satan> so what was the problem?
22:13:21 <dcoutts> I think, let me double checks...
22:13:32 <mauke> satan: what problem?
22:13:52 <satan> sjanssen: ok lemme look
22:13:58 <satan> mauke: it complained about Num [a]
22:14:01 <satan> ok i think i found it
22:14:05 <sjanssen> satan: it likely means you're writing a list when your program wants a number, or vice versa
22:14:15 <mauke> satan: what's the exact error?
22:14:24 <mauke> "complained about Num [a]" doesn't really help
22:14:25 <satan> sjanssen: yes thats exactly what it was, i've fixed it now, thanks
22:14:25 <dons>     "how does haskell compare to j2ee?",
22:14:25 <dons>     "how does j2ee compare to haskell?",
22:14:28 <dcoutts> dons, satan: well the problem was quite inocuous. I removed one line...
22:14:37 <dons> oh!
22:14:50 <satan> thanks guys :)
22:15:04 <dcoutts> one line in readLStrUp, not in writeLStrUp
22:15:14 <vincenz> @brain
22:15:14 <dcoutts> yeah and it was readLStrUp that was fast
22:15:15 <lambdabot> I think so, Brain! How much deeper would the ocean be if there weren't sponges down there?
22:15:18 <satan> eh?
22:15:22 <johnnowak> dons: he's not trolling. he just has a poor knowledge of the commutative property.
22:15:24 <dcoutts> mm, quite
22:15:37 <dcoutts> the explanation was that it was preventing proper inlining
22:15:50 <vincenz> dons: asshat?
22:15:59 <dons>     "is haskell better than APL or perl or clisp?",
22:15:59 <dons>     "ok is haskell a type of lisp?",
22:15:59 <dons>     "hakell is not lisp or ml right?",
22:16:00 <dons>     "how deos haskell differ from ml or lisp?",
22:16:00 <dcoutts> so the loops for readLStrUp and writeLStrUp were not being compined into a single loop
22:16:07 <dons> vincenz: oh, someone used that to describe keal
22:16:12 <vincenz> ah :)
22:16:15 <dcoutts> and that meant that all sorts of optimisations were not happening
22:16:21 <dons> hmm!
22:16:32 <dcoutts> and the line was ....
22:16:38 <dcoutts> readLStrUp [] = emptyS
22:16:49 <dcoutts> so, don't do that :-)
22:16:55 <dcoutts> I'll have to do it another way
22:16:58 <dons> huh
22:17:05 <dons> very interesting
22:17:09 <dons> bad ghc.
22:17:16 <dcoutts> well...
22:17:36 <dcoutts> otherwise ghc has to notice that we've got two loops here
22:18:01 <dcoutts> and it'd have to duplicate the writeStrUp loop into both branches
22:18:17 <dcoutts> whereas without that branching readLStrUp is a single loop
22:18:27 <dcoutts> so the two merge nicely
22:18:43 <dons> hmm. ok.
22:18:51 <dcoutts> it's a bit subtle but I did think when I wrote that originally it might be a problem
22:18:54 <dons> isn't this weird haskell we're doing.
22:19:03 * dcoutts grins
22:19:09 <dons> or, we're just paying very close attention to what ghc does to the code
22:19:14 <dcoutts> high performance haskell
22:19:38 <dons> yeah
22:19:49 <dcoutts> yes, you've got to think a bit like a C programmer
22:19:59 <dcoutts> what code is this going to transform into
22:20:05 <dcoutts> and will that be any good
22:20:08 <dons> yeah
22:20:16 <dcoutts> allocations, inlinings etc etc
22:20:21 <dons> and then start to worry about branches and so on
22:20:56 <dons> i sorted the protontorpedo list into 3 kinds of remarks he makes, http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Quote/Text.hs
22:21:09 <dons> it has to be trolling, surely.
22:21:14 * stepcut just cut the CPU usage of his program by 60% by switching from Data.List to Data.Queue :)
22:21:18 <dons> heh
22:22:05 <dcoutts> dons, one thing I wish for occasionally is to see in the source where we are introducing lazy deffers
22:22:05 <stepcut> the output of the profiler does not make much sense to me however
22:22:12 <dcoutts> adnd were we are doing allocations
22:22:29 <dons> hmm.
22:22:30 <dcoutts> eg return (PS fp 0 n : writeChunks s') is doing a lazy defer
22:22:38 <dons> have the compile warn?
22:22:43 <dcoutts> which in this case is exactly what we want
22:23:05 <dons> i..e "thunk creation: 32:14:Foo.hs" ?
22:23:36 <vincenz> dons: what is "hu me/" ?
22:23:41 <dons> who me?
22:23:46 <dcoutts> perhaps we just need it to be easier to see and read the core
22:23:49 <dcoutts> at various stages
22:23:57 <dcoutts> since the core shows allocations
22:24:00 <dons> yes.
22:24:09 <dons> so maybe with some notes back to the src that produced each fragment
22:24:12 <dons> or editor support....
22:24:16 <dcoutts> yeah
22:24:20 <dons> a vim collapse/expand mode
22:24:28 <vincenz> dons: vim is great :)
22:25:32 <dcoutts> dons, ok now it's only half the speed of the strict version and that's without any other branch twidling
22:25:47 <dcoutts> compared to 10x slower before
22:25:58 <dcoutts> I'll come back to it
22:26:03 * dcoutts -> sleep
22:26:11 <dons> ok. great work
22:26:37 <LordBrain> @brain
22:26:37 <lambdabot> Well, I think so, but Kevin Costner with an English accent?
22:28:44 <vincenz> @brain
22:28:44 <lambdabot> I think so, Brain, but pants with horizontal stripes make me look chubby.
22:28:54 <vincenz> they're so much funnier in context
22:29:00 <vincenz> gotta love pinky and the brain :)
22:29:07 <vincenz> the funny part is that he usually predicts how the plot will fail
22:29:16 <LordBrain> how'd you end up bringing up the mighty vim?
22:29:28 <LordBrain> i think we should rename yi to yim
22:29:32 <LordBrain> hehehe
22:29:49 <LordBrain> a tribute to vim which was a tribute to vi
22:30:22 <vincenz> nah
22:30:27 <vincenz> the haskell' version of yi will be yim
22:30:34 <vincenz> yahoo instant messenger
22:30:41 <LordBrain> lol
22:32:10 <vincenz> dons: been thinking of writing those rewrite rules for ADVISE in scheme macro :)
22:34:05 <LordBrain> well... i fixed highlight bugs in yi.. and the >> shift bugs, so that's all the bugs i know about caused by my upgrade to support visual mode..
22:34:42 <LordBrain> however, i'm thinking of redoing the whole approach to text selection
22:35:14 <dons> hmm. ok.
22:35:23 <dons> or do you want to try to add syntax highlighting?
22:35:45 <dons> i can give you a stub that almost works..
22:35:52 <LordBrain> hmmm
22:36:02 <LordBrain> like a plugin?
22:36:12 <dons> no, just built in haskell syntax highlighting
22:36:16 <dons> we could factor it out later
22:36:32 * dons tries to find the code
22:37:27 <LordBrain> i want to refactor text selection, put more in the core api, and make it more flexible for different kinds of editors and different kinds of selections...
22:37:39 <dons> ok.
22:37:58 <LordBrain> and add visual-line mode, and even visual-block mode, tho i think block mode is less essential
22:38:02 * johnnowak can't find an editor he likes
22:38:12 <LordBrain> have you tried vim?
22:38:39 <vincenz> vim: it even cleans your windows
22:38:44 <LordBrain> you have to give it a chance if you're not used to moded editing it is strange at first
22:38:59 <vincenz> and the new version has tabbed editing \o/
22:39:14 <LordBrain> what is tabbed editing?
22:39:17 * vincenz binded CTRL+TAb and CTRL+SHIFT+TAB to switch tabs, even when in insert mode
22:39:21 <vincenz> LordBrain: get 7.0
22:39:25 <vincenz> :tabe
22:39:28 <LordBrain> oh i will eventually
22:39:30 <LordBrain> hehe
22:39:42 <mauke> vim7: now with embedded scheme
22:39:56 <LordBrain> i tried to already actually, but my apt-pinning prioirities are blocking it
22:40:11 <LordBrain> it uses scheme as the default?
22:40:57 <johnnowak> LordBrain: I use vim, but I don't much care for it.
22:41:06 <LordBrain> oh really
22:41:23 <LordBrain> how long have you used it?
22:41:28 <johnnowak> LordBrain: I find certain things to be too slow or complicated enough that I have to stop thinking about what I'm working on.
22:41:32 <johnnowak> About two years, on and off.
22:42:14 <LordBrain> i dont ... if anything i find it frustrating i cant do vim stuff in other contexts..
22:42:55 <LordBrain> well not frustrating.. more a little annoying, because they flow out of my fingers mindlessly
22:43:11 <johnnowak> I've just used a mac for 15 years. To delete a line, "command-left, command-shift-right delete" is hard-coded. "escape dd i" is less good for me. :)
22:43:23 <vincenz> rafb.net is down
22:43:25 <vincenz> @where paste
22:43:26 <lambdabot> http://paste.lisp.org/new/haskell
22:43:31 <mauke> johnnowak: escape cc
22:43:50 <johnnowak> mauke: that's the other thing... it's so arbitrary :)
22:44:01 <mauke> no, c is for change. it makes sense!!
22:44:08 <lisppaste2> vincenz pasted "tabswitching in vim" at http://paste.lisp.org/display/24052
22:44:15 <vincenz> one thing that bugs me in vim
22:44:16 <LordBrain> yeah its not arbitrary, there is a logic to it all
22:44:24 <vincenz> is how it works with the clipboard
22:44:26 <vincenz> I kept doing "+y
22:44:28 <vincenz> and killing vim
22:44:31 <vincenz> and then it wouldn't paste
22:44:35 <vincenz> apparently I had to keep it open
22:44:48 <johnnowak> that's all things, not just vim
22:46:12 <johnnowak> mauke: what if i want to just change half a line?
22:46:13 <LordBrain> cw is an exception to their rule.... normally c for change, and then a movement command such as w tells how much to delete before swithcing you to insert mode... but they make cw act like ce (it doesnt delete the space after the word which is what a w movement would suggest)
22:46:21 <mauke> johnnowak: which half?
22:46:33 <johnnowak> mauke: *that* half :)
22:46:39 <johnnowak> er... i donno. a bit in the middle.
22:46:44 <LordBrain> right now, yi is more consistent in that respect...
22:47:02 <LordBrain> but i think we will go for compatability over consistency eventually
22:47:48 <johnnowak> mauke: er.. ? :)
22:48:08 <mauke> johnnowak: move to start of half, v, move to other end, c
22:48:43 <johnnowak> mauke: i have to leave insert mode to do that too.
22:48:54 <johnnowak> i'd rather just highlight it and start typing
22:49:07 <mauke> no, you have to not be in insert mode in the first place
22:49:22 <LordBrain> oooooooooooooooooh
22:49:30 <johnnowak> well most of the time i'm in insert mode, so i'd have to leave it to use visual mode
22:49:39 <LordBrain> if you do a lot of insert mode stuff, that is why you dont like vim
22:49:41 <LordBrain> that is
22:49:53 <johnnowak> well of course i do... i'm typing 80% of the time. :)
22:50:07 <LordBrain> you're not taking advantage of its moded editing really... most of your time should really be in normal mode
22:50:34 <johnnowak> so you don't enter text most of the time when you're in a text editor?
22:51:16 <LordBrain> no not really, your especially in programming, you have this big file and you usually are only changing small sections
22:51:45 <LordBrain> type it all in in insert mode.. then you switch to normal mode and clean it up
22:52:42 <johnnowak> eh, it just doesn't work for me. i like a modeless editor. i find i've gotten very fast with it and I don't see how a modal editor can be much faster. even if it were a bit faster, i'd find it more distracting.
22:52:48 <johnnowak> i'm just hopeless, don't mind me. :)
22:53:54 <johnnowak> i'll just eventually write my own editor and be happy.
22:55:35 <dons> you could write a yi mode to do whatever you wanted...
22:56:41 <LordBrain> i like cntrl-n and cntrl-p in insert mode tho
22:56:51 <LordBrain> for word completion
22:57:01 <johnnowak> i have one problem with vim... i use visual mode to select text a lot, delete it, and paste it
22:57:27 <johnnowak> but if i delete anything else, usually using dd to clean up blank lines around my cut.. i lose the text i copied and get a blank line
22:57:28 <LordBrain> you mean when you just want to yank it?
22:57:30 <johnnowak> i assume i'm not using it wrong.
22:57:36 <johnnowak> nah, i know how to do that :)
22:57:37 <dons> its not lost :)
22:57:43 <johnnowak> where'd it go? :)
22:57:48 <dons> there's multiple copy buffers
22:57:54 <dons> (a stack of them)
22:57:59 <dons> :ls
22:58:01 <dons> lists them, iirc
22:58:03 <mauke> is there really a stack?
22:58:08 <mauke> I thought :ls was for buffers
22:58:15 <dons> :regs maybe
22:58:27 <dons> its hard coded into my spine, let me type it to see what the real command is
22:58:38 <mauke> :reg
22:58:42 <johnnowak> is there a way to delete lines without putting a bunch of junk into the stack?
22:59:05 <johnnowak> it doesn't show in the stack either after i use 'dd'...
22:59:12 <dons> ah yes, :reg
22:59:26 <mauke> johnnowak: :h registers
22:59:55 <LordBrain> i didnt know about this
23:00:01 <LordBrain> coolness :)
23:00:19 <johnnowak> mauke: yes, i know this
23:00:26 <johnnowak> my text editor should not have 9 types of registers! :)
23:00:36 <mauke> what 9 types?
23:00:44 <johnnowak> "There are nine types of registers"
23:00:49 <jargonjustin> johnnowak: Are you using emacs?
23:00:49 <johnnowak> :h registers
23:00:53 <johnnowak> jargonjustin: vim!
23:01:20 <LordBrain> if you dont want to do moded editing then i'd think you would like emacs
23:01:41 <dons> its a bit arbitrary. but oh well.
23:01:42 <mauke> sounds like an arbitrary numbering
23:01:44 <johnnowak> i don't like emacs
23:01:52 <LordBrain> hmmm
23:01:57 <LordBrain> i never learned emacs
23:02:14 <LordBrain> except for a few things
23:02:41 <LordBrain> emacs is heavier it seems resource wise
23:03:03 <dons> s/seems/is :)
23:03:05 <Stinger_> whats vi's scripting language like?
23:03:06 <johnnowak> i just want a simple modeless editor, find/replace, goto line, cut/copy/paste, and "pass this text to this command and insert the result".
23:03:11 <dons> Stinger_: nasty
23:03:15 <johnnowak> Stinger_: crap
23:03:22 <LordBrain> vim's script langauge.. as i dont think vi has one
23:03:23 <dons> Stinger_: bad
23:03:28 <Stinger_> I see :D
23:03:51 <dons> there's , of course, perl, python ... bindings too
23:03:52 <lucca> Stinger_: elisp is pretty nasty too; it just beats the alternatives...
23:03:52 <LordBrain> yeah.. you can script it in perl or something else tho if you compile it to do that
23:03:55 <dons> for those who use such things
23:03:55 <Stinger_> well ok how would you fair it against elisp? (seeing as some people think that is pretty poor too)
23:04:20 <dons> you wouldn't compare them
23:04:35 <johnnowak> i'd take elisp over vim's.. thing.
23:04:46 <LordBrain> i'd probably like elisp better...
23:04:53 <mauke> vimscript is just a bunch of adhockery
23:05:05 <dons> its the php of editor scripting
23:05:11 <LordBrain> yeah.. ad hoc al lthe way
23:05:16 <mauke> vim7 got aggregate values
23:05:17 <lucca> adhockery or oddhackery?
23:05:18 * johnnowak wonders why a text editor needs a scripting language
23:05:23 <dons> lets add a haskell binding!
23:05:39 <mauke> johnnowak: to write scripts in, duh :-)
23:05:39 <Stinger_> so you can customize it
23:05:40 <dons> johnnowak: for programming syntax highlighting and indenting/
23:05:42 <dons> ?
23:05:54 <johnnowak> dons: you don't need a scripting language for that
23:05:55 <Stinger_> if I wanted a text editor I'd use pico :P
23:06:03 <dons> it helps to use a language
23:06:16 <dons> esp. to write things like parsers
23:06:22 <dons> i.e. if you want haskell indenting to not suck
23:06:27 <lucca> johnnowak: as you get more complex language support, you need a more complex customization system
23:06:28 <LordBrain> the thing is... say you make a new ftplugin to syntax color a langauge and handle its indenting etc etc... if you dont make it in vimscript, its not really going to work in every vim, because they have to be compiled to use the bindings for the language
23:06:47 <johnnowak> i'd rather just pass the text off to another process and feed it back in, and just write the indenting code in haskell or whatever i like
23:06:52 <dons> yeah
23:06:56 <dons> that's what I do.
23:07:02 <dons> just call things via !!
23:07:08 <lucca> grant you, elisp lets one do a great deal more than one should
23:07:17 <lucca> (as I'm using emacs for irc...)
23:07:43 <lucca> So... are there any libcurses bindings or clones in haskell?
23:07:49 <LordBrain> i fantasized about an irc plugin for yi the other day
23:07:57 <dons> lucca: 3
23:08:04 <dons> ?where hscurses
23:08:04 <lambdabot> http://www.informatik.uni-freiburg.de/~wehr/haskell/
23:08:05 <johnnowak> LordBrain: Do you *really* need smart indenting? a simple copying of the previous indent is almost always adequate.. just hit tab or delete on occasion. haskell and scheme being exceptions...
23:08:09 <dons> ?where hmp3
23:08:10 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
23:08:14 <mauke> johnnowak: let's say you're writing C and you want to have <F2> add any missing #includes for the identifier under the cursor
23:08:15 <dons> (uses a curses binding too)
23:08:23 <dons> ?where yi
23:08:23 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
23:08:29 <dons> (uses another variant, similar to hmp3)
23:08:33 <johnnowak> mauke: ok.
23:08:37 <lucca> ok, reading
23:08:43 <mauke> how do you do it without a scripting language?
23:08:59 <johnnowak> mauke: like i said, my editor would have a "pass selected text to external program and insert the result"
23:09:04 <johnnowak> you don't need built-in scripting
23:09:12 <mauke> but there is no "selected text"
23:09:14 <Stinger_> how would you make it insert it at the right place
23:09:21 <LordBrain> um... vim can do that
23:09:22 <dons> insert at the current point
23:09:23 <dons> easy
23:09:25 <mauke> there's a cursor position and all the #include lines in the current buffer
23:09:27 <dons> even yi does this ;)
23:09:28 <vincenz> dons: I see a pattern, all where's point at ~dons
23:09:29 <johnnowak> LordBrain: I'm not saying it can't
23:09:37 <dons> vincenz: hmm.
23:09:37 <Stinger_> so an include statement in the middle of an identifier? :P
23:09:40 <dons> not all
23:09:43 <LordBrain> in fact, you can set the formatting program
23:09:47 <vincenz> dons: want to hear something REALLY funny?
23:09:53 <LordBrain> the one it runs when you use the = command
23:09:58 <johnnowak> highlight, position cursor, execute command
23:10:00 <dons> vincenz: it better be funny...
23:10:13 <LordBrain> i have usually found the defaults fine tho
23:10:20 <mauke> johnnowak: you'd have to pass the whole buffer + cursor position for every <F2> :/
23:10:39 <mauke> sucks, slow, etc
23:10:46 <johnnowak> mauke: why? i just have to pass the selection to the external command
23:11:02 <vincenz> dons: well I showed my (your) site to my friend, when it was like the original thing.  One of the first things he suggested was to change the background.  And the nwe looked at your site when I had changed mine, and he went liek "That background is exactly what I had told you to get!"
23:11:06 <mauke> again, there is no selection in my case
23:11:20 <johnnowak> mauke: it takes a second to select the word under the cursor.. no big deal.
23:11:21 <mauke> and just having the word under the cursor is not sufficient
23:11:27 <dons> vincenz: oh, you mean my new background?
23:11:29 <vincenz> yeah
23:11:31 <dons> heh
23:11:38 <dons> that's funny
23:11:39 <vincenz> anyways
23:11:46 <vincenz> I might switch to pure divs
23:11:50 * edwardk tends to find all small repetitive tasks in an editor to be a 'big deal'
23:12:04 <mauke> you need to get the current #includes, look up includes for selection, add missing includes at the right point in the buffer
23:12:09 <dons> vincenz: ok. hmm. let me know how it goes.
23:12:14 <johnnowak> mauke: i'm just a minimalist i suppose. i don't see why a text editor should have to be more than 3000 lines or so of C.
23:12:15 <dons> and what the benefits are
23:12:22 <dons> of C???
23:12:23 <mauke> all without moving the cursor, of course
23:12:38 <johnnowak> dons: or what have you :)
23:12:41 * edwardk watches dons fall over in shock.
23:12:44 <LordBrain> lol
23:12:45 <dons> seriously, its the 21st century. at least put some static typing in there.
23:12:57 <Stinger_> c++ :)
23:12:58 <johnnowak> C isn't statically typed?
23:13:01 <dons> yi was written in 2 weeks in 1000 lines of haskell ;) so get cracking!
23:13:16 <johnnowak> dons: how many lines is it up to now?
23:13:19 <dons> weak typing doesn't count for naught
23:13:20 <LordBrain> c is statically typed, but not strongly
23:13:21 <lucca> ooo portishead
23:13:26 <johnnowak> LordBrain: right
23:13:58 <dons> johnnowak: hmm. let me see. 3508   3212 (code/comments)
23:14:13 <johnnowak> no too bad :)
23:14:33 <LordBrain> i'd use haskell to write an editor
23:14:40 <johnnowak> 3000 lines of C though will contain, er... less functionality.
23:14:58 <dons> yeah, vi is almost identical to yi, but its 15k lines of C
23:14:59 <LordBrain> or...
23:15:02 <LordBrain> at least c++
23:15:24 <johnnowak> i wonder what the smallest sane editor with unicode support would come out to in C...
23:15:37 <johnnowak> none of this "syntax coloring" fanciness
23:15:51 <LordBrain> if i were to program vim from scratch and without haskell, i'd use c++
23:16:02 * dons is tempted to make a vim-only fork of yi. minimal, fast. no extra fake emacsing
23:16:27 * johnnowak would like that
23:16:35 <vincenz> what's the advantage of yi?
23:16:47 <johnnowak> it's written in haskell!
23:16:49 <dons> currently? its easy to hack on. doesn't seem to have bugs.
23:16:59 <LordBrain> depends on what you mean by bugs
23:17:01 <dons> its also fast
23:17:05 <LordBrain> hehe
23:17:07 <LordBrain> it is fast
23:17:11 <LordBrain> we need to handle tabs
23:17:20 <johnnowak> depends on what you mean by easy to hack on. :) most people don't know haskell. everyone knows C.
23:17:21 <dons> that's missing features. there are missing features
23:17:27 <LordBrain> it just ignores them pretty much... allows you to enter them, but they mess up the movements
23:17:44 <dons> johnnowak: oh, its easy to hack on in that you can add code and probably won't break random things
23:17:51 <johnnowak> dons: good point
23:17:54 <dons> unlike, say, adding some random C into vi/vim
23:17:59 * johnnowak still uses true tabs for everything
23:18:01 <dons> which could do who knows what evil
23:18:05 <LordBrain> also, it needs line wrap (or horizontal scrolling)
23:19:29 <LordBrain> my version of yi actually lights up the tabs when you cursor over them
23:19:54 <johnnowak> has anyone tried using Sam?
23:19:58 <LordBrain> a somewhat useful side-effect to the highlighting code...
23:20:40 <LordBrain> tho i think that we are going to have to convert tabs to spaces before displaying them.. when we finally support them properly
23:20:54 <johnnowak> i assume that's what vim does
23:22:06 <LordBrain> yi currently just writes everything quickly as it actually is in the buffer...
23:22:39 <LordBrain> which means tabs are always the same width..
23:22:46 <mauke> wow, so you can embed escape sequences there?
23:22:55 <mauke> and display arbitrary stuff?
23:23:03 <LordBrain> probably
23:23:38 <LordBrain> i havent tried that
23:24:00 <johnnowak> sounds.. good!
23:24:25 <LordBrain> its using ncurses to blit line by line, assuming the characters in a line are each having a single unit of width
23:26:39 <LordBrain> well if it can do ansi escape codes to color things, it will probably loose that ability eventually when we update it's display code.
23:27:04 <LordBrain> unless we actively seek to preserve it
23:28:00 <dons> it doesn't do ansi escapes though. it does curses escapes
23:29:35 <scc> there's wily http://www.cse.yorku.ca/~oz/wily/intro.html I downloaded it but never tried it (the mention of sam reminded me of it).
23:29:36 <lambdabot> Title: Introduction to Wily
23:34:03 <LordBrain> dons did you pull from my repo, if not you should, its in a usable state now, and i want to use your repo as an archive sort of, before i start hacking it up again :P
23:35:34 <dons> I think I pulled.
23:35:35 <dons> let me check
23:36:41 <LordBrain> i kinda like the way tabs light up... maybe we should preserve that
23:40:06 <satan> how do i merge 2 lists together, without duplicates? so say merge [1,2,3] [3,4,5] should give me [1,2,3,4,5]
23:40:20 <satan> i'm not sure how to eliminate the duplicates
23:40:28 <dons> LordBrain: interesting. i have such a patch in my vim hightlighting code
23:40:40 <dons> syn match tabNasty display "\t"
23:40:40 <dons> hi link tabNasty Todo
23:41:17 <dons> LordBrain: ok, pulled .
23:41:26 <LordBrain> cool
23:41:27 <mauke> > nub $ [1,2,3] ++ [3,4,5]
23:41:28 <lambdabot>  [1,2,3,4,5]
23:41:54 <satan> mauke: thanks
23:42:08 <LordBrain> if you are on a line with tabs, and you press 'w' you get a wmove error...
23:43:03 <satan> mauke: what does nub do?
23:43:19 <LordBrain> removes duplicates
23:43:26 <satan> ah ok
23:43:29 <satan> thanks
23:43:33 <dons> LordBrain: right.
23:43:44 <dons> since tabs bang us past the end of the screen
23:43:49 <LordBrain> i think nub might require them to be grouped first
23:44:13 <dons> > nub [1,2,1,2,1,2]
23:44:14 <lambdabot>  [1,2]
23:44:15 <mauke> > nub [1,2,3,1,2,1,1,3,4,2,]
23:44:16 <lambdabot>  Parse error
23:44:18 <mauke> > nub [1,2,3,1,2,1,1,3,4,2]
23:44:20 <lambdabot>  [1,2,3,4]
23:44:33 <vincenz> HOLY CRAP
23:44:40 <vincenz> Anyone see that URGENT message on h-c ml?
23:44:53 <LordBrain> yeah dons, if we fix this, it might actually bring us a step closer to supporting something like utf-8, since we will have characters of varied length
23:44:57 <vincenz> I mean the way he even formulates it
23:45:10 <vincenz> There are 2 questions for my project and I need to aswer them as soon as possible. The answers need to be written in Haskell using recursive methods.
23:45:14 <vincenz> o.O
23:45:15 <vincenz> that's just mindboggling
23:46:13 <vincenz> I mean the nerve
23:46:57 <dons> vincenz: yeah, its great. beelsebob's response is just lovely, though
23:47:16 <vincenz> ah, that's beelsebob?
23:47:35 <vincenz> Yeah it is:)  Though I would've probably rubbed it in a bit more :D
23:48:17 <vincenz> It'd be even cooler if the professor knew about this, and then sent a reply to him
23:48:24 <vincenz> And then when he's presenting it "Ah, I see you brought my solution"
23:48:31 <LordBrain> dons, would it kill the efficiency if i just made a list of char-lengths?
23:49:36 <LordBrain> that is [1,1,8,1,1,1] where the 8 is a tab
23:49:44 <LordBrain> and then used sum to give the length
23:50:08 <dons> hmm
23:53:02 * edwardk posts an offtopic link http://www.kuro5hin.org/story/2006/8/6/155745/7278
23:53:03 <lambdabot> Title: Faith Based Programming || kuro5hin.org
23:55:36 <dons> heh
23:55:38 <dons> "    Side effects, too, should be impossible.  God does not change what
23:55:38 <dons>     he says, so why should the Divine Code be any different?   This
23:55:38 <dons>     means, of course, above all else, "functional programming" languages
23:55:38 <dons>     should be used when writing the Will of God"
23:55:51 <edwardk> =)
23:58:06 <LordBrain> i like my programming to be god free
23:58:33 <LordBrain> it's a god free zone, you know?
23:58:55 <edwardk> heh
23:58:57 <therp> I'd rather base my argument about the superiority of FP on something like FP code doesn't know time, they are eternal truths, <some cool argument about eternity
23:59:21 <therp> s/they/its statements/
23:59:45 <LordBrain> it said the compiler was hethen and to blame for all your errors too
