00:15:34 <dcoutts> dons, ping
00:19:26 <dcoutts> boliver, I didn't realise you were here :-)
00:24:01 <dons> dcoutts: pong
00:24:24 <dcoutts> dons, so, I want to talk about the deadline :-)
00:24:27 <dons> ok
00:24:45 <dcoutts> Ideally I should be dissapearing on the 19th
00:24:48 <dons> --> overflow
00:24:54 <dcoutts> @arr
00:24:54 <lambdabot> I'll crush ye barnacles!
00:24:57 <dcoutts> ahem
00:39:19 <profmakx> @arr
00:39:19 <lambdabot> Drink up, me 'earties
00:42:01 <tibbe> @hoogle compose
00:42:02 <lambdabot> No matches found
00:42:16 <tibbe> @type [a -> a] -> a -> a
00:42:17 <lambdabot> parse error on input `->'
00:42:28 <tibbe> @hoogle [a -> a] -> a -> a
00:42:29 <lambdabot> No matches, try a more general search
00:42:47 <tibbe> isn't there a compose functions somewhere?
00:44:31 <dons> ?type (.)
00:44:32 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
00:45:55 <profmakx> that should be about the third operation one learns in haskell ^^ (Not having thought about the first and second though)
00:49:15 <tibbe> @type foldr1 (.) [\x -> x, \y -> y]
00:49:16 <lambdabot> forall c. c -> c
00:49:56 <tibbe> > let compose = foldr1 (.) [\x -> x, \y -> y] in compose [\x - > x + 1, \y -> y * 3] 3
00:49:56 <lambdabot>  Parse error
00:50:11 <tibbe> um
00:50:23 <tibbe> > let compose = foldr1 (.) in compose [\x - > x + 1, \y -> y * 3] 3
00:50:23 <lambdabot>  Parse error
00:50:33 <tibbe> > let compose = foldr1 (.) in compose [\x -> x + 1, \y -> y * 3] 3
00:50:34 <lambdabot>  10
00:51:19 <tibbe> > let compose = foldr1 (.) . reverse in compose [\x -> x + 1, \y -> y * 3] 3
00:51:20 <lambdabot>  12
00:51:37 <tibbe> or would that be foldl1?
00:51:49 <tibbe> > let compose = foldl1 (.) in compose [\x -> x + 1, \y -> y * 3] 3
00:51:50 <xerox> > (foldl' (.) id) [(+1),(*3)] 3
00:51:50 <lambdabot>  10
00:51:51 <lambdabot>  10
00:52:08 <tibbe> @type foldl'
00:52:09 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
00:52:22 <tibbe> too many folds!
00:52:33 <xerox> ?fptools Data.List
00:52:34 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
00:53:51 <tibbe> > let compose = foldl1 (.) in compose (map showString ["hi", "bye"]) ""
00:53:52 <lambdabot>  "hibye"
00:53:58 <tibbe> yeah!
00:54:26 <xerox> uhu.
00:54:46 <tibbe> or perhaps that's showList
00:55:02 <tibbe> I want to do unlines but using shows
00:55:09 <xerox> ?type let swing f c a = (f ($ a) c) in swing showString
00:55:10 <lambdabot>   Expecting a function type, but found `[Char]'
00:55:10 <lambdabot>    Expected type: ((a -> b) -> b) -> t -> t1
00:55:13 <xerox> Nevermind.
00:55:31 <tibbe> @type foldl1
00:55:32 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
00:55:33 <tibbe> @type foldl'
00:55:34 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
00:56:04 <tibbe> is foldl' really foldl1 with id?
00:56:09 <bruno_> @type foldl (.) id
00:56:10 <lambdabot> forall b. [b -> b] -> b -> b
00:57:03 <xerox> '-versions of folds are their strict counterparts.
00:57:09 <tibbe> > let compose = foldl (.) id in compose [] ""
00:57:10 <lambdabot>  ""
00:57:19 <xerox> 1-versions of folds are missing the [] case.
01:00:24 <tibbe> ok, thanks
01:37:04 <nostromo> any clue of this error while trying to make gtk2hs? /usr/include/bits/libio-ldbl.h:24: (column 30) [FATAL]  >>> Syntax error!  The symbol `_IO_vfscanf' does not fit here.
01:37:25 <nostromo> gentoo, linux-ppc
01:37:28 <dcoutts> hmm, c2hs failing to parse something perhops
01:37:50 <dcoutts> nostromo, file a gentoo bug with all the details, we'll look into it
01:37:57 <nostromo> it is gtk+-2.10
01:37:59 <nostromo> ok
01:38:01 <dcoutts> ah ok
01:38:08 <dcoutts> I've never tested with 2.10
01:38:29 <dcoutts> nostromo, you can build with gtk+2.8 and run with 2,10
01:38:34 <dcoutts> if that helps at all
01:38:47 <dcoutts> as a temporary workaround
01:38:50 <nostromo> I could try to downgrade gtk, compile it and upgrade again :)
01:38:59 <dcoutts> quickpkg gtk+
01:39:05 <nostromo> I know
01:39:08 <dcoutts> :-)
01:39:35 <dcoutts> ok, but do file the bug or we'll forget :-)
01:39:49 <nostromo> I'll do it later
01:39:56 <dcoutts> thanks v. much
01:39:56 <nostromo> if I don't forget
01:40:39 <nostromo> I'm looking at what package the offending file is coming from, it is actually glibc-2.4
01:41:08 <nostromo> so it could be something deeper than gtk-2.8, rather some change in glibc headers
01:47:37 <dcoutts> nostromo, that's quite possible
01:48:04 <dcoutts> nostromo, mention all that in your bug report
01:48:21 <nostromo> ok , I'll do, I'm curious to see some graphic haskell :)
01:48:52 <dcoutts> glibc is usually does more tricky things with GNU C extensions that Gtk
01:49:13 <dcoutts> and those are the things that c2hs sometimes has trouble parsing
01:50:08 <nostromo> the file says something like: "__LDBL_REDIR_DECL (_IO_vfprintf)"
01:50:36 <nostromo> after the same for vfscanf
01:51:28 <dcoutts> nostromo, do you know what the __LDBL_REDIR_DECL macro expands to?
01:52:04 <nostromo> grepping for it
01:52:26 <nostromo> (fortunately grep is free software, or "grepping" would be forbidden, like "googling") :-)
01:53:14 <dcoutts> hah
01:54:45 <nostromo> defined in sys/cdefs.h
01:56:20 <nostromo> either "#define __LDBL_REDIR_DECL(name) extern __typeof (name) name __asm (__ASMNAME ("__nldbl_" #name));" or nothing
01:57:10 <nostromo> it is something related with __LONG_DOUBLE_MATH_OPTIONAL
01:57:41 <nostromo> I mean, with LONG DOUBLES in general
02:00:57 <tibbe> I'm having some difficulties with parsec's try combinator, try (choice (map (try . string) someStrings)) <|> token, doesn't backtrack and use token when the first parser fails
03:08:26 <gds> > foldr (flip (>>=) (++)) "" [return "Hello ", return "World"]
03:08:28 <lambdabot>  "Hello World"
03:08:42 <gds> Anyone have any ideas why that doesn't work in ghci?
03:11:07 <eivuokko> When asking question about "working", it is a good idea to specify what indicators you get it doesn't work.  I tried, and based on error message, you need instance for Monad ((->) a), which can be found in Control.Monad.Reader iirc.  Use :m +Control.Monad.Reader on ghci prompt.
03:13:04 <gds> eivuokko: Sorry - yes - I should have been more specific, but you seem to have exactly solved my problem :)
03:13:09 <gds> Thanks :)
03:25:21 <dcoutts> stepcut, ping
03:26:36 <dcoutts> audreyt, ping
03:27:14 * dcoutts and dons are most interested in hearing any feedback you might have on Data.ByteString
03:27:25 <dcoutts> we're writing up our paper on it at the moment
03:28:25 <dcoutts> advantages/disadvantages of using it in practice etc
03:50:24 <kzm_> Hmm...I have one problem regarding FPS, but I guess it's really a Cabal one: even if fps-0.7 is hidden, building my application refuses to import ByteString as it is found in multiple packages (fps-0.7 and fps-0.8).
03:50:44 <kzm_> (Installing fps-0.8 hid fps-0.7)
03:51:27 <kzm_> My application is built by ghc --make -- must I use Cabal to build it for hiding to work?
03:51:44 <xerox> Use -package fps-0.8 ?
03:51:58 <eivuokko> You can use hide-all-packages and explicit packge-flags to get the packages you need, I think.
03:52:09 <dmhouse> kzm_: no, ghc-pkg is independant from Cabal, I think.
03:52:34 <kzm_> -package fps-0.8 didn't help - it still sees fps-0.7.
03:52:39 * kzm_ scratches his head.
03:53:11 <kzm_> Oh wait - perhaps I haven't rebuild another library depending on fps.
03:56:34 <kzm_> Since the library depending on fps got hidden along with fps-0.7, and I specify it as a package dependency, fps-0.7 got unhidden, and thus conflicted with fps-0.8.  Sounds plausible?
03:58:57 <kzm_> "Could not find module `Data.ByteString.Char8':" - WTF?!
04:09:33 <kzm_> Any way to find out why ghc insists on fps-0.7?  I've rebuild everything, and even unregistered fps-0.7
04:10:25 <dons> ghc-pkg list
04:10:38 <dons> re you using something that asks specifically for fps 0.7?
04:11:29 <audreyt> dcoutts: hi
04:11:35 <dcoutts> hia
04:12:22 <audreyt> pugs makes pretty extensive use of ByteString, yes
04:12:32 <dcoutts> :-)
04:12:35 <audreyt> what do you like to hear about? API change pains? :)
04:12:37 <kzm_> dons: yes, apparently.  But I can't imagine what or how.  I just do 'ghc -c Foo.hs' and get fps-0.7 not available.
04:12:46 <dcoutts> audreyt, strict or lazy or both?
04:13:06 <audreyt> mm? I'm referring to useAsCStringLen back and forth
04:13:14 <audreyt> and the initial checkin to GHC-trunk breraking compat with fps-0.6
04:13:15 <dcoutts> kzm, you've got a .hi file you need to recompile, it's got a reference to fps-0.7 still
04:13:18 <audreyt> and things like that
04:13:37 <kzm_> (useAsCStringLen was what promted my upgrade attempt)
04:13:39 <audreyt> but now GHC-trunk has multiversioning (aka package prefix to modules), it's all fine now
04:13:44 * kzm_ wants to try out Judy.
04:13:57 <dcoutts> audreyt, so you use the Data.ByteString and not Data.ByteString.Lazy
04:14:02 <audreyt> yup
04:14:12 <audreyt> I'd like a "reverse" happy D.B.L
04:14:16 <dcoutts> audreyt, so you value the ablity to move back and forth between foreign C code without copying then
04:14:19 <audreyt> i.e. one based on D.Sequence
04:14:38 <kzm_> dcoutts, where might that reside?  (I've cleaned my app directory)
04:14:41 <audreyt> I do, but I also miss the native UTF8 support in das's fps
04:14:47 <audreyt> *darcs
04:14:56 <dcoutts> audreyt, oh? why would that be helpful? the D.Sequence based one?
04:15:06 <audreyt> either native UTF8 or Char16 support will make things much easier
04:15:11 <dcoutts> yes, unicode is in the pipeline
04:15:32 <dcoutts> one based on D.sequence could not be lazy sadly
04:15:47 <dcoutts> so I don't know if it'd have much advantage over just ByteString
04:15:56 <audreyt> mostly fast concat
04:16:00 <dcoutts> mm
04:16:09 <audreyt> my application is somewhat specialized
04:16:17 <audreyt> it's perl, it concats string all the time
04:16:19 <dcoutts> the lazy bytestring concat is liner in the number of chunks
04:16:44 <audreyt> right. what I really want I guess is a StringBuilder-ish API
04:17:02 <dcoutts> to make building strings from the back cheaper
04:17:04 <audreyt> the CLR String is immutable, but it also have a prealloc-buffer, concat-friendly
04:17:10 <audreyt> type called StringBuilder
04:17:10 <audreyt> yes.
04:17:14 <dcoutts> right
04:17:30 <dcoutts> where as our one would be O(n^2) for StringBuilder
04:17:37 <audreyt> which is like, unusable
04:17:43 <dcoutts> albeit for a smallish n as it's chunks
04:17:50 <dcoutts> yes :-)
04:18:02 <audreyt> so that's the #2 wish after unicode
04:18:12 <dcoutts> interesting, I'd never considered that
04:18:18 <audreyt> the C land interop is very valued
04:18:24 <audreyt> we interact with pcre, syck etc all the time
04:18:27 <audreyt> and judy
04:18:35 <audreyt> which all expect some sort of CStringLen
04:18:48 <dcoutts> do you ever use the feature where you can use your own foreign finaliser?
04:18:59 <dcoutts> do any of the C apis you use need that?
04:19:12 <audreyt> packCStringFinalizer ?
04:19:25 <dcoutts> where they give you a string and say "please call foo_free when it's no longer needed"
04:19:33 <dcoutts> right, with the Finalizer
04:20:07 <audreyt> no, all three extern C libs manages their own free
04:20:16 <dcoutts> right
04:20:18 <audreyt> but I can see it being useful if they don't
04:20:38 <audreyt> so, the concrete API; lots of convenience functions got tropped
04:20:39 <dcoutts> yeah, many C libs ask you to free it yourself
04:20:40 <audreyt> dropped
04:20:48 <audreyt> most I don't miss
04:20:53 <dcoutts> which ones do you miss?
04:21:23 <audreyt> let me look at chglog. a sec
04:21:31 <dcoutts> are you happy with the way the api mirrors the list api?
04:21:51 <audreyt> not exactly "happy"
04:21:54 <audreyt> "tolerable"
04:21:58 <dcoutts> heh :-)
04:22:06 <audreyt> changing case to splitAt is painful
04:22:07 <dcoutts> any problems with that approach do you think?
04:22:24 <audreyt> f (x:y:'*':zs) = ...
04:22:31 <audreyt> is very hard to express
04:22:35 <dcoutts> case to splitAt? I don't quite follow
04:22:40 <dons> right. no pattern matching
04:22:44 <dcoutts> ah yes
04:22:47 <audreyt> have to do a C.length and then a C.index and then a C.splitAt
04:22:57 <dcoutts> mm
04:22:59 <kzm_> Okay, I worked it out: while my library appeared to compile and install correctly, it had (a bit less apparently) incorporated some old files from a previous build that still referred to (the non-existent) fps-0.7.
04:23:00 <audreyt> I wonder if we can relax the "length" part
04:23:17 <audreyt> indexAt 2 (== *)
04:23:19 <audreyt> or something.
04:23:26 <audreyt> but you get the idea
04:23:30 <dcoutts> we were thinking of adding an uncons operation
04:23:52 <dcoutts> to mirror case thing of (x:xs) -> ..; [] -> ...
04:24:26 <dcoutts> yes, loosing pattern matching is a shame
04:24:37 <dcoutts> we'd need views right dons?
04:25:30 <dons> I think so, yes.
04:25:49 <audreyt> oh. the Read instance is very subtly broken for ByteString
04:25:56 <audreyt> so I actually need to newtype it
04:26:00 <dcoutts> oh dear
04:26:00 <dons> hmm?
04:26:02 <audreyt> (trips high bits)
04:26:07 <audreyt> >0xFF
04:26:14 <dons> hmm
04:26:17 <audreyt> read "\20000"
04:26:34 <dons> oh, that's the read instance you wrote, audreyt ;)
04:26:50 <dcoutts> audreyt, that's because you want unicode right?
04:27:00 <audreyt> I wrote that? :)
04:27:06 <dcoutts> where as currently ByteString is bytes/ascii
04:27:15 <audreyt> then I'm the only one to blame :)
04:27:43 <int-e> why, that's correct behaviour for a plain bytestring. except that it could treat that as an error, maybe
04:28:51 <audreyt> uhm, to me ByteString carries only notion of Word8
04:29:03 <audreyt> and is agnostic over Char8, UTF8, etc interpretations
04:29:13 <audreyt> but newtype is fine
04:29:37 <dcoutts> right, since it's agnostic and 8-bit it ignores the high bits in a Char
04:29:42 <dcoutts> when converting from String
04:29:55 <norpan> it would be nice to have some kind of inherit mechanism for functions when doing newtype
04:29:57 <dcoutts> for UTF8/UTF16 obviously that'll work ok
04:30:13 <dcoutts> norpan, you can "inherit" instances
04:30:24 <norpan> yes, but not functions
04:30:28 <dcoutts> true
04:30:48 <norpan> and ByteString has a lot of functions to inherit if you newtype it :)
04:30:59 <dcoutts> yes :-)
04:31:17 <dcoutts> the problem here is the lack of unicode of course
04:31:24 <dcoutts> and sjanssen is working on that
04:31:25 <norpan> yes unicode is a pita
04:31:43 <dcoutts> he's working on UTF32
04:31:48 <norpan> where p is either pain or pleasure
04:31:51 <dcoutts> hah
04:32:15 <dcoutts> audreyt, anything else? semantics or performance?
04:32:23 <audreyt> so, convenience APIs
04:32:28 <dcoutts> oh yes
04:32:29 <audreyt> we used to use dropWhitePS
04:32:42 <audreyt> but that's not in bottleneck code
04:32:49 <audreyt> so we can easily take it being slower
04:32:56 <dcoutts> == dropWhile isSpace right?
04:33:00 <dons> and user's can always inline their own defns?
04:33:03 <audreyt> yeah but impl in cbits
04:33:08 <dons> ah
04:33:28 <dcoutts> we can put that optimisation in without affecting the API
04:33:28 <audreyt> maybe I missed it
04:33:31 <dcoutts> via RULES
04:33:37 <audreyt> yes. that'd rock
04:33:54 <audreyt> but I didn't see a "break" with BS separators
04:34:02 <audreyt> which is very common when translating pattern matching
04:34:17 <audreyt> (x:'-':'-':xs) -> ...
04:34:20 <dcoutts> hmm, we did have something called break didn't we dons?
04:34:41 <audreyt> yeah but that takes Char->Bool
04:34:43 <dons> split?
04:34:56 <audreyt> I can't give it (== '-') because xs may start with '-'
04:34:59 <audreyt> split again only takes Char
04:35:02 <dons> yep
04:35:06 <audreyt> i.e. all the things that currently takes Char
04:35:14 <audreyt> is more usefully taking BS for my use
04:35:20 <dons> similar story to the List library, I suppose
04:35:21 <audreyt> s/Char/Char->Bool/
04:35:34 <audreyt> yes but List has wellknown breakAtGlue etc
04:35:46 <audreyt> while for FPS there's less copy-and-pastable code around
04:37:15 <dons> yep
04:37:59 <audreyt> i.e. Char8.join has no dual
04:38:39 <audreyt> what else... "partition" is missing
04:38:43 <audreyt> not sure why
04:39:23 <audreyt> oh it's just "span" now?
04:39:34 <dcoutts> oh, we've got span and break
04:39:34 <dcoutts> not sure if that does what you want
04:39:45 <dcoutts> > break (=='-') "foo--bar"
04:39:46 <lambdabot>  ("foo","--bar")
04:39:51 <audreyt> hm no.
04:40:40 <audreyt> I really want the dual to join :)
04:40:46 <dons> right
04:40:49 <audreyt> in both "break" and "split" mode
04:40:52 <dons> that's reasonable
04:41:30 <dons> there's probably one in the linspire parser code
04:43:49 <audreyt> (sorry, was caught in #perl6 wrt GHC 6.5)
04:43:50 <audreyt> back
04:44:45 <audreyt> not sure when to use map and when to map'
04:44:49 <audreyt> so I just blindly use map now
04:46:24 <audreyt> oh. literals.
04:46:37 <audreyt> I currently use this technique to force sharing
04:46:48 <audreyt> {-# NOINLINE _foo #-}
04:46:51 <dcoutts> we're removing map'
04:46:54 <audreyt> _foo :: ByteString
04:46:59 <audreyt> _foo = pack "foo"
04:47:08 <audreyt> is that just cargo culting?
04:47:18 <dcoutts> is it what? :-)
04:47:24 <audreyt> if I switch to say (pack "foo") everywhere
04:47:34 <dons> hmm. why wouldn't you get sharing?
04:47:35 <audreyt> will that slow things down and/or malloc unneccessarily if it's in a loop?
04:47:44 <audreyt> there are many _foo occurances
04:47:44 <dcoutts> shoudn't do
04:48:06 <dcoutts> pack "foo" should get optimised to packAddr "foo"#
04:48:13 <dons> yeah, it usually does
04:48:18 <dcoutts> so all will share the constant C string "foo"
04:48:24 <audreyt> and GHC does constant interning
04:48:25 <audreyt> ok
04:48:34 <dcoutts> they may not share the same BS constructor however
04:48:45 <audreyt> so if I have ten uses
04:48:49 <audreyt> I still get ten constants
04:48:56 <dcoutts> right
04:49:05 <audreyt> but that's bad
04:49:09 <dcoutts> well, possibly :-)
04:49:17 <audreyt> since that will trigger compareBytes
04:49:25 <audreyt> while I really want p==p'
04:49:29 <dcoutts> ah, no
04:49:38 <dcoutts> no they share the same memory for the string data
04:49:45 <dcoutts> but possibly different BS constrcors
04:49:53 <audreyt> oh ok
04:49:58 <audreyt> p is the same, jsut not the head
04:49:58 <audreyt> ok
04:50:06 <audreyt> much yummier
04:50:12 <norpan> very yummy
04:51:09 <dcoutts> wether or not the BS constructors are shared depends on GHC's CSE stuff
04:51:25 <audreyt> that I worry less
04:51:30 <dcoutts> but the string literals get shared by the compiler and linker
04:51:33 <audreyt> what's the magick that makes it share "p"?
04:51:49 <dcoutts> the linker uses common string tables
04:51:54 <dons> yeah, with the same underlying pointer, you'll get     | p == p' && s == s' = True
04:52:04 <dons> before it hits compareBytes
04:52:05 <dcoutts> so it even shares across independently compiled modules
04:52:17 <dcoutts> if you've got identical strings in two .o files
04:52:19 <dcoutts> (I think)
04:52:55 <dons> it might be interesting to build a proper fast/shared string api over Data.Bytestring, though. like GHC's FastString
04:53:03 <audreyt> oh. readInt in BS takes "+123"
04:53:24 <dcoutts> yes
04:53:29 <dcoutts> +/-
04:53:33 <audreyt> dons: Pugs uses Judy to build its ID table
04:53:48 <audreyt> but you can easily do the same with HashTable...
04:53:49 <dons> ah ok
04:53:53 <dons> yep
04:53:54 <audreyt> ...except you can't as Char8.hash is not there :)
04:54:08 <dons> but its easy to find/write
04:54:29 <audreyt> though I think if it's core then .hash is arguably core as well
04:54:46 <audreyt> i.e. if you want to replace the common hashString for Data.HashTable
04:55:01 <audreyt> (darcs had a hashPS.)
04:55:22 <dons> yep
04:56:06 <audreyt> Numerics.read* currently I go via unpack
04:56:28 <audreyt> I do appreciate a platform neutral readInt
04:56:42 <audreyt> instead of strtol
04:57:19 <audreyt> maybe group the additional reaers in Data.ByteString.Numerics or something, not sure
04:58:13 <audreyt> the steady improvement in memory use and performance gains are amazing, but you know that already :)
04:59:09 <audreyt> almost thanks to fps alone, we were able to get pugs from "too slow to puts in production" to "certainly fast enough for many tasks"
04:59:20 <dcoutts> hash = foldl' (\hash c -> (hash `shiftL` 5 + hash) `xor` c) 5381
04:59:32 <dcoutts> @type Data.List.foldl' (\hash c -> (hash `shiftL` 5 + hash) `xor` c) 5381
04:59:33 <lambdabot> forall b. (Bits b) => [b] -> b
04:59:39 <audreyt> before fps, our runtime dominates profiling
04:59:44 <dcoutts> @type Data.List.foldl' (\hash c -> (hash `shiftL` 5 + hash) `xor` c) (5381 ::Int )
04:59:45 <audreyt> especially in string lookup and comparison
04:59:45 <lambdabot> [Int] -> Int
04:59:53 <audreyt> after fps, our parser dominates easily 80%+
05:00:00 <audreyt> because we are stills tuck with String Parsec
05:00:02 <audreyt> (hint hint)
05:00:16 <dcoutts> @type Data.List.foldl' (\hash c -> (hash `shiftL` 5 + hash) `xor` (fromIntegral c)) 5381 :: [Data.Word.Word8] -> Int
05:00:17 <lambdabot> [Data.Word.Word8] -> Int :: [Word8] -> Int
05:00:44 <dcoutts> audreyt, ask stepcut for their parsec for BS
05:00:46 <audreyt> a bytestring-friendly parsec will likely make pugs entirely usable as a scripting language
05:00:54 <audreyt> stepcut: url to your parsec for BS?
05:01:13 <dcoutts> I don't know if it's open source, but it's worth asking :-)
05:01:24 <dons> yeah, freespire are using a bytestring parsec.
05:01:26 <audreyt> I remember a SoC project for that...
05:02:45 <audreyt> so, currently wishlist: unicode; dual to join; stringbuilder; parsec support
05:02:58 * dcoutts adds that to our TODO
05:03:06 <audreyt> stringbuilder to fps would be something like ResizableMutableCharArray to String
05:03:42 <dcoutts> audreyt, or chunks that you add at the end
05:03:43 <audreyt> most imperative high-level language has those
05:03:55 <dcoutts> or just reallocing & copying
05:03:59 <audreyt> yes.
05:04:07 <audreyt> the outside API should be very much similar
05:04:12 <dcoutts> it's difficult to do that purely
05:04:44 <dcoutts> the chunks style is easier to do purely
05:04:51 <audreyt> aka Boehm's ropes
05:05:00 <audreyt> (immutable string in C++ that does crazy sharing magick)
05:05:01 <dcoutts> what is the stringbuilder api exactly?
05:05:20 <dcoutts> how much does it need to see the string it's building
05:05:27 <dcoutts> while it's still building it, that is
05:05:36 <dcoutts> and is it always append or prepend too?
05:06:12 <dcoutts> audreyt, btw that hash above is apparently quite good
05:06:16 <dcoutts> http://www.cse.yorku.ca/~oz/hash.html
05:06:36 <dcoutts> BS.foldl' (\hash c -> (hash `shiftL` 5 + hash) `xor` (fromIntegral c)) 5381
05:07:00 * dcoutts thinks his network connection is being intermittant
05:07:03 <dons> that's a nice little hash function
05:07:18 <dcoutts> dons, yeah
05:07:19 <audreyt> dcoutts: http://www.hpl.hp.com/personal/Hans_Boehm/gc/gc_source/cordh.txt
05:07:38 <audreyt> http://java.sun.com/j2se/1.5.0/docs/api/java/lang/StringBuilder.html
05:07:39 <lambdabot> Title: StringBuilder (Java 2 Platform SE 5.0)
05:07:52 <audreyt> either one will solve the concat problem
05:08:02 <audreyt> the first is perhaps easier to do purely
05:08:51 <dcoutts> audreyt, yeah, you probably do want Sequence ByteString
05:09:09 <audreyt> and I do have a preimitive implementation...
05:09:36 <audreyt> # http://svn.openfoundry.org/pugs/src/Data/ByteString/Seq.hs
05:10:53 <audreyt> I wonder if typeclassing all fps functions will make alternative views
05:11:09 <audreyt> Char16, UTF8, newtype'd ones, etc
05:11:19 <audreyt> a bit easier. but that's not pressing
05:12:19 <dcoutts> the more primitive method of course is using modules
05:12:20 <audreyt> most of Judy work's application in pugsland is changing
05:12:37 <audreyt> IORef (Map String a)
05:12:39 <audreyt> to
05:12:47 <audreyt> Judy.StrMap a
05:12:52 <audreyt> which uses fps underneath
05:12:56 <dcoutts> right
05:13:04 <dcoutts> and that's much faster I expect
05:13:09 <audreyt> sure
05:13:15 <audreyt> by the same token I wonder if (IORef ByteString)
05:13:21 <audreyt> can be replaced by something else.
05:13:26 <audreyt> but that again is not pressing
05:13:27 <dcoutts> so you've got a general judy map module?
05:13:32 <audreyt> yup
05:13:34 <dcoutts> cool
05:13:36 <audreyt> works very vey well
05:13:39 <dcoutts> :-)
05:13:44 <audreyt> IntMap, StrMap, Hash, Set
05:14:06 <audreyt> to dircetly replace their pure counterparts in IORef context
05:14:23 <audreyt> (well, except for Hash, which is replacing Data.HashTable)
05:14:44 <dcoutts> right
05:14:56 <audreyt> cmarcelo did all the work :) I'm just the mentor who harass him once in a while
05:15:02 <dcoutts> :-)
05:15:13 <audreyt> so... I think that's all
05:15:21 <audreyt> I _think_ a TH-based transformer
05:15:28 <audreyt> that maps a string case to a fps case
05:15:49 <audreyt> will probably be useful, though I worry about sanity
05:19:05 <nomeata> Hi. someone posted a few weeks ago something about a higher level gtk for haskell implementation. does anyone can give me a pointer√ü
05:19:55 <dcoutts> nomeata, ndm was working on something he called PropLang, see the Haskell wiki
05:20:08 <nomeata> dcoutts: thx
05:20:10 <dcoutts> audreyt, thanks very much for the comments! :-)
05:20:37 <audreyt> dcoutts: thanks so much for saving thousands of hours of #perl6 pepople's time :)
05:20:45 <audreyt> (dons too)
05:20:46 * dcoutts grins
05:21:06 <audreyt> the entire smoke test now runs in <10mins. it used to take 4 hours.
05:21:15 <audreyt> with parsec bytestring I expect that number to be cut in half
05:22:26 <audreyt> dons: is sjanssen still going to do that and/or integrate stepcut's work
05:22:33 <audreyt> or is that dropped from scope?
05:23:39 <dons> hopefully we can take on stepcut's code. though reproducing it wouldn't be too hard, I think
05:37:06 <nomeata> ndm: ping
05:37:14 <ndm> nomeata: pong
05:38:04 <nomeata> ndm: I'm trying our your PropLang code, but it's not compiling. My bad?
05:38:14 <ndm> nomeata: the sample application?
05:38:22 <ndm> most likely my bad :)
05:38:54 <ndm> i tweaked it so it works better with guihaskell, which unfortunately broke the sample app
05:39:02 <ndm> didn't get round to fixing it up - will try that now
05:39:15 <nomeata> ndm: so are you still actively working on it? the concept sounds very tempting to me...
05:39:35 <ndm> nomeata: i am developing it in parallel with guihaskell, which is the main user
05:39:36 * nomeata just got it to run, but a lot of warnings, and the word count does not work
05:39:57 <ndm> unfrotunately thats stalled on a couple of GHC/Gtk bugs and issues
05:40:04 <ndm> but yes, i'm sitll very interested in it
05:40:22 <nomeata> what's guihaskell?
05:40:53 <ndm> @where winhaskell
05:40:53 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/winhaskell.php
05:41:00 <ndm> that, but written in Haskell, using Gtk2hs
05:41:10 <ndm> http://www-users.cs.york.ac.uk/~ndm/temp/carrot.png
05:41:51 <nomeata> I see, an interactive haskell shell programm of sorts
05:42:44 <ndm> yes, a wrapper for Hugs + GHCi + more stuff
05:42:54 <norpan> that's nice
05:43:03 <norpan> i've yet to see a big gui application in haskell
05:43:11 <ndm> its way too slow at the mo
05:43:22 <ndm> but thats Gtk+GHC's fault, nothing to do with me
05:43:25 <norpan> hey, gangsta rap, slow at the mo
05:44:19 <ndm> nomeata: fixed the proplang sample, give it a pull
05:44:39 <nomeata> ok, thanks
05:45:56 <nomeata> working fine
05:47:17 <audreyt> dons: what should the API be called?
05:47:24 <audreyt> "breaks" "splits"?
05:47:33 <audreyt> "breakWith", "splitWith"?
05:47:49 <audreyt> "breakBS", "splitBS"?
05:47:54 <audreyt> hopefully not "break'"
05:48:38 <nomeata> what's the difference between "x <- return $ some_function a b" and "x = some_function a b" in a do statement?
05:48:46 <eivuokko> unintersperse? ;)
05:49:06 <ndm> nomeata: none
05:49:16 <ndm> or not much in practical terms
05:49:27 <bringert> except that you are missing a "let" :-)
05:49:40 <ndm> as to why i did that, its because the code looked like that before :)
05:49:46 <ndm> i'm fixing it up properly now
05:49:58 <ndm> before getTextView was monadic, now its not
05:50:07 <ndm> the shortest fix is to bung a return on it
05:50:07 <audreyt> unintersperse is inspired
05:50:13 <ndm> the proper fix is coming :)
05:50:20 <nomeata> i would have just offered to fix that for you, but looks like youre faster :-)
05:50:32 <audreyt> then break is maybe unjoin
05:51:36 <norpan> ./` unjoin my heaaaart ./'
05:51:44 <norpan> sorry
05:51:46 <eivuokko> Heh
05:52:32 <ndm> nomeata: that tweak has been pushed
05:53:05 <ndm> nomeata: and btw, the sample app is wowfully incomplete - it needs proper save/load code writing, and stuff to do saveas if you save without specifying a filename etc.
05:53:56 <nomeata> ndm: do you want patches? :-)
05:54:03 <ndm> nomeata: definately!
05:54:09 <nomeata> (not promising anything, but when I have nothing else to do I might fiddle around a bit)
05:54:20 <ndm> cool, whatever you can come up with would be appreciated
05:54:20 <norpan> the sample app is an editor?
05:54:26 <ndm> yes
05:54:27 <dcoutts> audreyt, is split what you want?
05:54:50 <audreyt> no
05:55:03 <audreyt> unjoin :: ByteString -> ByteString -> Maybe (ByteString, ByteString)
05:55:05 <audreyt> unjoin glue str = do
05:55:07 <audreyt>     idx <- findSubstring glue str
05:55:09 <audreyt>     return (take idx str, drop (idx + length glue str))
05:55:11 <audreyt> is what I want
05:55:55 <dcoutts> ah ok
05:56:04 <audreyt> the last line has a misplaced )
05:56:06 <audreyt> but you get the idea :)
05:56:41 <dcoutts> well what you've got there is pretty effecient
05:57:04 <audreyt> sure :)
05:57:18 <dcoutts> so no need to extend the API :-)
05:57:25 <audreyt> (none of the "wishlist" above means "I'm blocking on fps", just "things would be eiaser if I had that alraedy" :))
05:57:34 <norpan> have youy done any thinking on memory use/garbage collection with bytestrings? i mean, since the foreignptr is shared there may be huge chunks of memory left unused in the heap as long as part of the bytestring is in use
05:57:34 <audreyt> *nod*
05:57:45 <dcoutts> aye, we need an extra missing-style list lib
05:57:50 <dcoutts> for the more common ones
05:58:08 <dcoutts> the List is quite a good common/minimal set
05:58:19 <dcoutts> the List API I mean
05:58:21 <audreyt> yup
05:58:41 <dcoutts> Data.List.ExtraStuff :-)
05:58:52 * gds discovers liftM2
05:58:53 <gds> Yay!
05:59:07 <norpan> gds: it was just laying there waiting for you!
05:59:27 * gds hugs the lambdabot 
06:05:22 <dons> norpan: regarding leaving chunks in the heap, that's what 'copy' is for
06:05:48 <dons> to copy out a substring (i.e. when parsing) so the GC can deallocate the rest
06:06:04 <nomeata> ndm: should I push to your e-mail adress?
06:06:16 <norpan> dons: aha
06:06:18 <ndm> nomeata: send to a file
06:06:23 * nomeata is relatively new to darcs, so bear with me if that's a stupid question :-)
06:06:36 <ndm> nomeata: gzip the file, then email it to me: ndmitchell   #AT#   gmail.com
06:06:39 <norpan> dons: that's good then
06:06:51 <ndm> nomeata: darcs record first
06:07:21 <nomeata> ndm: I recorded. how do I send to a file?
06:07:44 <nomeata> and what's the benefit to just darcs push ndm....com?
06:07:49 <ndm> do "darcs send -o name.patch", then "gzip name.patch", then email it to me
06:08:09 <ndm> nomeata: you can't push to me, you can send to me, but becuase of windows/darcs issues it doesn't usually work
06:08:25 <ndm> typically in darcs you'd just go "darcs send", and darcs would do the rest
06:10:00 <nomeata> would darcs gzip it?
06:10:22 <eivuokko> Nope.
06:10:51 <nomeata> ndm: ok, it's out. just a few cosmetics, making sure that the patch submission actually works -- I hope you don't mind
06:12:59 <ndm> nomeata: no probs, looks good to me, just applying
06:13:41 <ndm> nomeata: it causes a few build failures in Variable.hs ?
06:14:19 <ndm> liftM not in scope (easy enough to fix), but also a name not defined: ./PropLang/Variable.hs:31:11: Not in scope: `e'
06:14:37 <nomeata> oh, sorry, I was too eager with submitting, I actually forgot the test
06:14:42 * nomeata hides in a corner :-)
06:14:53 <nomeata> I'll fix it and re-submit
06:15:22 <nomeata> how do I do that, change a already recorded patch?
06:16:57 <ndm> nomeata: darcs unrecord
06:17:05 <ndm> then darcs record again
06:17:11 <nomeata> thx
06:17:47 <audreyt> dcoutts: oh.
06:17:49 <audreyt> findSubstringFrmomEnd
06:17:56 <audreyt> or something in that variation
06:18:18 <nomeata> new patch sent
06:18:27 <dcoutts> audreyt, sorry, I don't follow
06:18:42 <audreyt> span as spanEnd
06:18:46 <audreyt> so findSubStringEnd ?
06:19:32 <audreyt> s/as/has/
06:19:39 <xerox> findSubStringEnd xs ys = xs `elem` tails ys -- ?
06:19:53 <nomeata> ndm: would it be ok if I had used amend-patch instead of unrecord, even though I already sent away that patch once?
06:19:58 <audreyt> xerox: it needs to return index
06:20:01 <audreyt> and also, it's fps :)
06:20:22 <ndm> nomeata: no idea...
06:20:30 <ndm> i can darcs unrecord, or whatever helps
06:21:03 * nomeata is off for lunch
06:21:56 <ndm> nomeata: i got it working, and have pushed your patch, thanks!
06:23:01 <ookk> doesnt haskell have infinetely large floating point numbers?
06:23:08 <ookk> i dont want do see NaN
06:23:24 <Igloo> It has Rational
06:23:25 <ookk> at least i want the 10 digits and an exponent
06:24:06 <ookk> how do i get it to use rational?
06:24:16 <int-e> > 1 :: Rational
06:24:17 <lambdabot>  1%1
06:24:18 <ookk> with sqrt for instance?
06:24:23 <xerox> ?type sqrt
06:24:25 <lambdabot> forall a. (Floating a) => a -> a
06:24:25 <int-e> not at all
06:24:29 <xerox> ?instances Floating
06:24:30 <lambdabot> Double, Float
06:24:34 <xerox> :-/
06:25:00 <ookk> that is not very nice
06:26:01 <SamB> ookk: sqrts are usually irrational...
06:26:24 <ookk> yes but there is no irrational number in a computer
06:26:47 <SamB> nevermind that Float and Dobule don't actually represent irrationals...
06:26:49 <norpan> ookk: there is if you want to
06:27:17 <norpan> and sqrts are never irrational
06:27:25 <ookk> i want exp and sqrt that doesnt give me NaN when the numbers get to large
06:27:27 <int-e> sqrt(2) is irrational.
06:27:31 <SamB> but with Ratio, where would you stop?
06:27:34 <norpan> err, yes
06:27:48 <int-e> they are not transcendental.
06:28:09 <int-e> if you have a non-transcendental argument
06:28:10 <norpan> forget what i said, i'm working :)
06:29:13 <norpan> i had a datatype for algebraic numbers somewhere :)
06:30:55 <SamB> ookk: so you would like floating-point numbers with bignums for the exponents?
06:31:33 <ookk> i would be enough with int for the exponent
06:32:12 <ookk> i have a problem with it saying NaN after the exponent goes over 300
06:32:22 <ookk> i dont think it should do that
06:32:42 <SamB> are you using Double?
06:33:02 <bourbaki> moin
06:33:43 <ookk> im just using ** and sqrt
06:34:08 <bourbaki> quick question if you have something like (x,y) and x and y theres an obvious difference
06:34:10 <SamB> hmm
06:34:17 <bourbaki> is there something like this for output values in haskell?
06:34:30 <bourbaki> that is ie R^2 and two seperate values?
06:34:40 <norpan> for output values?
06:34:43 <dons> hmm?
06:34:44 <norpan> return values from functions?
06:35:02 <bourbaki> yes i have the following idea
06:35:08 <bourbaki> imagine a petri net
06:35:12 <SamB> R^2?
06:35:22 <bourbaki> there you can have two end nodes that represent the result of a function
06:35:26 <SamB> Why would you want only real numbers?
06:35:32 <bourbaki> but they dont necessarily form a product
06:35:35 <binary42> Use a list.
06:35:42 <bourbaki> SamB: that was an example
06:35:49 <bourbaki> binary42: a list is a product
06:36:01 <norpan> (x,y) is not necessarily a product
06:36:07 <norpan> it's just a pair with x and y in it
06:36:20 <norpan> well, it depends on what you mean by product of course
06:36:22 <SamB> norpan: can you explain what is meant by "product"?
06:36:22 <bourbaki> i think there is a difference in (x,y) and x and y
06:36:38 <dons> this is so confusing.
06:36:41 <SamB> (x,y) is just a way to hold x and y...
06:36:44 <bourbaki> well let me explain
06:36:46 <dons> what are you trying to do, bourbaki ?
06:36:50 <dons> code please
06:36:57 <SamB> unless you are talking about a type
06:36:59 <bourbaki> there is no code yet
06:36:59 <norpan> dons: spoilsport
06:37:09 <bourbaki> if you use (x,y) you have to provide x and y at the same time
06:37:17 <bourbaki> if its x and y you can do it seperately
06:37:24 <SamB> in which case it is also able to contain _|_
06:37:42 <SamB> bourbaki: you do not need to provide x and y at the same time
06:37:57 <SamB> > fst (1, error "oops!")
06:37:58 <lambdabot>  1
06:37:59 <norpan> what do you mean by "at the same time" anyway
06:38:09 <norpan> the whole code is present at the same time
06:38:55 <norpan> i think bourbaki has a case of the imperatives
06:38:57 <bourbaki> what i mean is that if you use () its a product
06:39:11 <bourbaki> so its another type then two seperate types like x and y
06:39:18 <bourbaki> you can of course use curry
06:39:23 <bourbaki> thats like converting the type
06:39:33 <norpan> i think you are confused
06:39:33 <bourbaki> but there is nothing like this for the output of a function
06:39:46 <norpan> if a function should output two values, use the type (x,y)
06:39:57 <norpan> what's the problem with that
06:40:27 <ookk> so anyone got an idea of how to get the 10 first digits of e**1000 for example?
06:40:30 <norpan> saying that (x,y) is a product is just a matter of interpretation
06:40:38 <ookk> i just get NaN for an aswer
06:40:46 <norpan> it could just as well be two totally unrelated values
06:40:55 <SamB> ookk: you could take the first 10 digits of e...
06:41:16 <SamB> > e**1000
06:41:17 <lambdabot>  Not in scope: `e'
06:41:18 <bourbaki> SamB: because its not the same
06:41:33 <bourbaki> compareing this to the perti net its as if i would have a product of the two nodes
06:41:35 <ookk> by first i mean the most significant digits
06:41:36 <SamB> oh, wait.
06:41:39 <SamB> the e is confusing
06:42:00 <SamB> I think I was getting confused with exponential notation...
06:42:04 <bourbaki> and not two seperate ... well ... wait if its one output you can have the sum ... like either of the two nodes
06:42:30 <ookk> i dont care if the exponent is 3000
06:42:33 <ookk> it shouldnt matter
06:42:34 <SamB> now, lets see...
06:42:40 <SamB> how do you calculate e?
06:42:59 <SamB> I could open my calculus book...
06:43:01 <ookk> i guess i have to write something myself that sets the exponent to 0 in every step of **
06:43:06 <sieni> from the sum for example
06:43:16 <ookk> but i think its stupid that you get NaN for an answer
06:43:19 <dons> > (exp 1) ** 1000
06:43:20 <lambdabot>  Infinity
06:43:25 <dons> > (exp 1)
06:43:26 <lambdabot>  2.718281828459045
06:43:27 <norpan> bourbaki: if function f returns (x,y) you can just do something like let (x,y) = f ... in e and then use x and y separately in e
06:43:29 <ookk> how much space would it require to store an exponent above 300?
06:43:41 <ookk> not much
06:43:46 <SamB> > (exp 1) ** 1000 :: Double
06:43:47 <lambdabot>  Infinity
06:43:53 <dons> we don't have arbitrary precision reals
06:43:54 <ookk> when there is infinite integers why not infinite floating point numbers
06:44:02 <dons> yeah, why not?
06:44:07 <sieni> > sum (takeWhile (/= 0) (map (\n -> 1 / product [1..n]) [0..]))
06:44:08 <lambdabot>  2.7182818284590455
06:44:25 <SamB> ookk: if you write your own type you can get it to work
06:44:25 <dons> :)
06:44:32 <norpan> ookk: because there really are "infinite" floating point numbers, which would take much room :)
06:44:40 <SamB> blame IEEE 754, iirc
06:44:56 <norpan> how would you decide how many decimal places to keep from e for instance
06:45:05 <ookk> i guess i will just calculate it in steps and remove the exponent so that i get some values
06:45:14 <eivuokko> Don't blame that spec.  It's atleast a spec for something, instead of a mess of dozen and more diffrent implementations.
06:45:15 <sieni> norpan: you can estimate the remainder term in the sum
06:45:20 <SamB> eivuokko: well
06:45:41 <bourbaki> norpan: yep but thats the product i think the other thingy that is haveing two seperate nodes is
06:45:42 <ookk> you can estimate the error from truncating e
06:45:45 <SamB> what I mean is that it is not like we have invented our own floating-point types that are lamer than everyone elses
06:45:50 <bourbaki> either node1 | node2
06:46:00 <sieni> norpan: 1/n! goes to zero much faster than 1/a^n, so you can use geometric sum to estimate the error
06:46:04 <norpan> bourbaki: i can't possibly know what you mean until i see some example of what you are trying to do
06:46:10 <bourbaki> like in a finite state automata where you can have two seperate outcomes
06:46:24 <bourbaki> norpan: do you know fsm ?
06:46:31 <norpan> sieni: but how would the compiler do it
06:46:32 <norpan> bourbaki: sure
06:47:17 <norpan> bourbaki: are you talking about non-deterministic automata now?
06:47:27 <bourbaki> norpan: yes
06:47:38 <norpan> then you should probably use a list as output
06:47:43 <bourbaki> norpan: that is an automaton that can have two seperate sinks
06:47:43 <binary42> :-)
06:47:51 <norpan> bourbaki: exactly two?
06:47:56 <bourbaki> norpan: no n
06:47:57 <SamB> seperate sinks?
06:47:59 <norpan> or zero, one or two?
06:48:08 <bourbaki> well a sink is an end of an automaton
06:48:10 <SamB> couldn't it just have one of those two-part sinks like my grandma has?
06:48:15 <bourbaki> norpan: no n+
06:48:23 <SamB> ;-P
06:48:23 <norpan> SamB: yeah, with garbage grinder
06:48:24 <bourbaki> and if there is exacly one end
06:48:31 <SamB> norpan: how did you know?
06:48:32 <bourbaki> that is just one node that marks the end
06:48:35 <bourbaki> no ...
06:48:53 <bourbaki> there are more then one end node but if the program terminates is just one node the token is in in the end
06:48:54 <norpan> SamB: you don't want to know :)
06:49:02 <bourbaki> then its the sum of all nodes that is the output
06:49:20 <SamB> norpan: so... you are my grandmother?
06:49:29 <norpan> SamB: i am your father
06:49:42 <norpan> so you better behave
06:49:47 <SamB> haha, my father is in the other room!
06:50:03 <norpan> yeah?
06:50:33 <norpan> bourbaki: i'm not sure exactly what you are trying to do, but i suppose it's time for you to write some code
06:50:55 <bourbaki> norpan: i will have to write the program in another language than haskell
06:51:10 <bourbaki> i want to use c# because i have more runtime information of objects and such
06:51:25 <bourbaki> thats why i asked for a c# haskell the other day
06:51:31 <bourbaki> er .NET that is
06:51:39 <norpan> bourbaki: oh? then why wonder about haskell types
06:52:05 <bourbaki> because the ppl in here are familiar with all these concepts and see a difference in all these things :)
06:52:15 <dons> hehe
06:52:15 <bourbaki> so i thought this is the right place to discuss something liek that
06:52:37 <bourbaki> the thing is that i have to make a difference in all this because i want programs to be concaternatable in different places
06:52:42 <dons> we do provide abstract problem solving capabilities, that's true
06:52:48 <bourbaki> its like an extension of arrows to programs
06:52:54 <bourbaki> and concurrency
06:53:00 <norpan> we solve all problems as long as they're well-formulated and sufficiently easy
06:53:28 <scc> or your bandwidth back
06:54:14 <dons> and posed as haskell problems. that helps
06:54:48 <bourbaki> :)
06:55:00 <bourbaki> i tried to do all this in haskell and already had quite some nice stuff done
06:55:14 <bourbaki> but i didnt manage to use the HLists for my functions
06:55:32 <bourbaki> that is i had networks for different typed nodes and such that was a pain
06:55:55 <norpan> well, perhaps you need a product type for all your node types
06:55:58 <dons> why do you need different typed nodes and runtime inspection ?
06:56:06 <dons> yeah, one type to rule them all
06:56:11 <norpan> one type to bind them
06:56:16 <norpan> err
06:56:20 <norpan> one type to (>>=) them
06:56:54 <bourbaki> well that would have been possible but
06:57:10 <dons> ?pl \one type to them -> one type to >>= them
06:57:10 <lambdabot> (((>>=) .) .)
06:57:10 <bourbaki> that also would have ... required you to rewirte all the functions
06:57:23 <bourbaki> the idea was that the nodes have a type and that the arrows of the diagram are functions
06:57:38 <bourbaki> and for the functions you have all the usual arrow operators
06:57:47 <dons> yeah, sounds very arrowish
06:57:50 <norpan> are we talking haskell arrows?
06:58:00 <bourbaki> and for these program networks some more operators that do nearly the same as arrows but on programs
06:58:04 <bourbaki> norpan:  yes
06:58:07 <bourbaki> ie
06:58:14 <bourbaki> you just have a sequential program
06:58:23 <norpan> well, that sounds entirely possible
06:58:32 <bourbaki> then you can use the arrow operators to compile the program to a single arrow
06:58:50 <norpan> one arrow to rule them all
06:58:50 <bourbaki> but for programs that include circles like recursions and such you cant do that
06:58:57 <norpan> sure you can
06:59:04 <norpan> depends on the type of your arrow
06:59:10 <bourbaki> ok sure but then you would have to craft the functions for that uber type
06:59:16 <norpan> you can't use functions, but you can use other arrows
06:59:17 <bourbaki> and i didnt like that idea
06:59:21 <bourbaki> because
06:59:23 <bourbaki> ah right
06:59:27 <bourbaki> that was the problem
06:59:34 <bourbaki> you can do a product of nodes
06:59:46 <bourbaki> then you have a new type wich you can ... dont mind :)
06:59:54 <bourbaki> you can do that you are right
07:00:01 <bourbaki> but i think i didnt really like the idea
07:00:05 <norpan> well
07:00:10 <bourbaki> because you cant introduce new types
07:01:11 <SamB> hmm...
07:01:20 <bourbaki> would either of you be interested in helping me to do this in haskell?
07:01:22 <SamB> can I make libc use a bigger input buffer?
07:02:20 * SamB wonders why he came here with that question...
07:02:24 <SamB> glibc, in particular...
07:02:53 <bourbaki> SamB: who you or me?:)
07:02:59 <SamB> me!
07:03:13 <SamB> the program in question isn't even written in Haskell
07:03:19 <SamB> though I did prototype it in Haskell
07:03:22 <SamB> it is my UM
07:03:47 <SamB> I want to be able to fit all of my RML program into the buffer at once ;-)
07:04:06 <SamB> so that I can suspend the reading/parsing by pressing ^Z
07:04:41 <bourbaki> oh btw is there a way to get the ellegance of monadic parsers to c++ with templates?
07:04:48 <SamB> well, not quite
07:04:56 <SamB> but there is something
07:05:10 <SamB> boost:: something-or-other
07:05:25 <cm> boost::spirit
07:05:26 <bourbaki> i guess the problem is to catch the second variable for the return right?
07:06:20 * SamB wonders what bourbaki is talking about
07:06:45 <bourbaki> well if i remember correctly you can concaternate the parsers
07:07:03 <bourbaki> and can have a variable in the middle where you can get the output of the parse and the rest
07:07:13 <scc> (a,b) -> c  ~=  a -> (b -> c)  and  a -> (b,c)  ~=  (a->b) -> c
07:07:13 <SamB> oh, you mean with >>?
07:07:22 <bourbaki> yes
07:07:28 <scc> oops I didn't mean to post that
07:07:47 <SamB> I don't remember what spirit does...
07:08:07 <SamB> but the main problem with it is most likely that you have to declare the types of your variables ;-)
07:09:26 <bourbaki> no not if you use templates
07:09:38 <bourbaki> i have managed to do something quite similar to arrows with templates
07:09:57 <bourbaki> but its just compile time then so i didnt investigate any further into that
07:11:42 <nomeata> ndm: you just got another patch, introducing a handy -<- operator, and it will treat text as modified only when it's different to the last saved version, to demonstrate these features.
07:12:14 <ndm> nomeata: so -<- is -< with an Eq context?
07:13:02 <nomeata> ndm, no, it is var1 -<- var2, getting the content from one Var container to the other
07:13:17 <ndm> oh, so var1 -< get var2 ?
07:13:29 <nomeata> just saves a line, but it's nice to read than do bla <- getVal var1; var2 <- bla;
07:13:51 <ndm> ah, thats cool
07:14:03 <nomeata> might be totally useless, if it only saves one world, dunno
07:14:35 <nomeata> it's used in the other patch (two patches in one mail, I hope that's ok)
07:15:44 <ndm> nomeata: yep, thats fine, all applied
07:16:13 <ndm> two patches in one mail bundle is perfectly fine with darcs, if anything its less work :)
07:16:23 <nomeata> ndm: great!
07:16:29 <ndm> since i can pick and choose which i want, and they remain two separate patches if you record them separately
07:17:25 <nomeata> is there a way for me to list the patches in your repository? darcs pull says "nothing to do", so I would not know if the patch was pushed or not
07:19:22 <ndm> nomeata: i'll get a darcsweb on the repo, then you can see it in a summary
07:19:34 <ndm> darcs send -o nul will also give you a list of patches pending in  your repo vs mine
07:19:40 <ndm> so if thats nothing, they are all there
07:21:05 <nomeata> so if I forgot what patches I have already sent, it might happen that I send them twice, and darcs will not stop me, right?
07:21:20 <dcoutts> right
07:21:23 <dcoutts> but that's ok
07:21:28 <ndm> nomeata: right, but send them as many times as you want
07:21:40 <ndm> always send all patches in every bundle, its less work for me
07:21:44 <dcoutts> because it'll notice they're the same when applied and not re-apply them
07:21:51 <nomeata> sounds good
07:21:52 <ndm> means i don't need to get the order right, and can just grab the last one
07:22:26 <nomeata> what happens if you like a patch but for a small tiny thing
07:22:41 <nomeata> would you change the patch, or apply it and add another one
07:22:43 <ndm> how do you mean? small patches are easy enough to deal with
07:22:46 <dcoutts> instead of "darcs send -o nul" use "darcs send --dry-run"
07:22:50 <ndm> usually just add another patch
07:23:40 <ndm> anyone used HASP/Haskell source extensions, that XML in a haskell document thingy?
07:24:16 <ndm> I ran the hsx preprocessor, and it generates lots of genTag, toAttribute function calls etc
07:24:19 <ndm> but no import for them
07:30:52 <ookk> if i want to iterate a function n times without the previous values beeing stored how do i do?
07:31:10 <ookk> beacuse i get a stack overflow when i apply it to over 300k values
07:31:16 <dcoutts> use tail recursion
07:31:24 <ookk> but if i first apply it to 100k values and then to 300k values it runs fine
07:32:17 <ookk> i have used tail recursion
07:32:36 <ndm> ookk: paste an example
07:32:54 <ookk> fib 0 (a,b) = (a,b)
07:32:54 <ookk>     fib n (a,b) = fib (n-1) ((a,b),a)
07:33:02 <ookk> fib n (a,b) = fib (n-1) ((a,b),a)
07:33:21 <ookk> fib n (a,b) = fib (n-1) ((a+b),a)
07:33:22 <ookk> bah
07:33:29 <ookk> the last one and first i correct
07:34:36 <int-e> fib n a b = let s = a+b in s `seq` fib (n-1) s a
07:34:47 <int-e> (why are you using a pair there?)
07:35:30 <ookk> because i felt like it :)
07:36:05 <ookk> i dont understand why my function gets stack overflow though
07:36:13 <int-e> it's not your function
07:36:22 <int-e> it's the unevaluated (+) thunks that it creates
07:37:32 <ookk> i got to use a pair to
07:37:43 <ookk> fib 0 a b should return (a,b)
07:37:50 <ookk> i cant return a b
07:38:48 <Lemmih> ndm: using HSP or HASP?
07:39:13 <ndm> Lemmih: i don't want to use either really, i just want to squirt out the XML as text
07:39:22 <ndm> but am happy to prod one or the other if required
07:39:22 <int-e> ookk: well, f 0 a b = (a,b)  would still work. depends on the context, a bit.
07:39:57 <ookk> int-e, what does seq do?
07:40:39 <Lemmih> ndm: Then you want HSP. Importing HSP or HSP.Data should do.
07:40:39 <ndm> I am only embedding XML, i don't want to process/pattern match it etc, just generate it simply
07:40:47 <int-e> a `seq` b evaluates a to head normal form before evaluating b. in case a is a numeric expression it just evaluates it to its value
07:41:26 <ookk> okay
07:41:32 <ndm> Lemmih: cheers :)
07:41:45 <SamB> what is head normal form?
07:41:45 <SamB> I
07:42:05 <SamB> I've heard of Weak Head Normal Form
07:42:29 <norpan> head normal form is whnf without any reducible parts
07:42:43 <SamB> reducible parts?
07:43:15 * gds wonders if this sort of thing is likely to be useful to anyone out there: http://totherme.livejournal.com/1477.html
07:43:16 <lambdabot> Title: totherme: Haskell for reformed perlmongers
07:43:40 <gds> (it's only one function - not a tute or anything...)
07:43:48 <norpan> SamB: yeah, (\x -> \y -> y) is whnf, but not hnf
07:43:55 <norpan> err no
07:44:03 <norpan> SamB: yeah, (\x -> (\y -> y) z) is whnf, but not hnf
07:44:18 <norpan> hnf would require reducing (\y -> y) z to z
07:44:58 <nomeata> ? paste
07:45:04 <norpan> that's at least what i think the difference is
07:45:04 <norpan> :)
07:45:10 <nomeata> how do I make the bot tell me where to paste :-)
07:45:14 <norpan> whnf is the "normal form" for graph reduction
07:45:18 <nomeata> paste?
07:45:50 <SamB> lisppaste2: help nomeata out
07:47:10 <gds> ?paste
07:47:11 <lambdabot> http://paste.lisp.org/new/haskell
07:47:59 <lisppaste2> nomeata pasted "lableless gtk dialog?" at http://paste.lisp.org/display/24170
07:48:16 <nomeata> can someone tell me why this dialog does not show the label?
07:49:06 <ndm> nomeata: no idea, but for reference, i was going to create some MsgBox functions to put in PropLang, since that aspect of Gtk2Hs seems incredibly painful!
07:49:18 <emertens> I don't actually want to know the answer, but does an efficient (non-exponential in time and space) algorithm exist for finding the most efficient method of exponentiation
07:49:35 <int-e> > let (a,b) <*> (c,d) = (a*c+b*d, a*d+b*(c+d)); fib 0 = (1,0); fib n | odd n = (0,1) <*> fib (n-1); fib n = let x = fib (n`div`2) in x <*> x in length . show $ fib 10000
07:49:37 <lambdabot>  4183
07:49:46 <dcoutts> ndm, if you come up with anything feel free to submit them for inclusion in Gtk2Hs too
07:49:56 <dcoutts> unless they depend on PropLang of course
07:50:17 <ndm> dcoutts, those would be entirely proplang free, but handy still :)
07:50:40 <nomeata> dcoutts: is there a good reason to not have a "askUser :: String -> [ Responses ] -> Respons" function?
07:51:06 <nomeata> with data Respons = ResponseYes | ResponseNo | Response Cancel?
07:51:24 <nomeata> that'd cover most cases of dialog boxes in one line
07:51:36 <nomeata> askUser :: String -> [ Response ] -> IO Response, actually
07:52:02 <ndm> nomeata: definately add that to PropLang! (and then once it hits gtk2hs it can be removed)
07:52:17 <ndm> although you may need a Window parameter, to know the dialog boxes parent
07:52:19 <dcoutts> nomeata, See the GNOME HIG, I think we'd want something better than that.
07:52:32 <ndm> dcoutts, better = more complex?
07:52:36 <dcoutts> yes
07:53:06 <ndm> more complex = harder for users :(
07:53:09 <nomeata> dcoutts: does Gtk2HS have gtk's MessageDialog Class? it's close to that function
07:53:18 <dcoutts> ndm, not at all, the toher way around
07:53:18 <dcoutts> the HIG suggests meaningful names on the buttons, not just yes/no
07:53:35 <ndm> yeah, but lazy users always just use yes/no
07:53:42 <dcoutts> exactly
07:53:43 <SamB> arg
07:53:59 <SamB> can't get buffering to work as I want for my C UM...
07:54:02 <ndm> then have data Response = Response ResponseCode String
07:54:14 <dcoutts> and first line, second line text and one of a number of icons
07:54:17 <ndm> and have responseOk = Response ResponseOk ""
07:54:28 <ndm> then responseOk{msg="This is OK"}
07:54:35 <ndm> lazy people win, people who care win
07:54:49 <dcoutts> it's not jsut made up to be more complex, it really is about making a more usable UI
07:55:20 <ndm> its nice to be able to hack something together quickly, then refine it later
07:55:26 <dcoutts> http://developer.gnome.org/projects/gup/hig/2.0/windows-alert.html
07:55:26 <ndm> rather than paying the price straight away
07:55:27 <lambdabot> Title: Alerts
07:55:30 <nomeata> but it would be nice to construct a dialog box and run it in one (maybe long) function call
07:55:52 <dcoutts> nomeata, getting the result asynchronusly is no problem
07:56:05 <dcoutts> messageBox blah blah $ \response -> do ...
07:57:09 <nomeata> anyway, what's wrong with my code? :-)
07:57:14 <dcoutts> ndm, it needn't be hard actually, lets see...
07:57:43 <ndm> dcoutts, yeah, i have faith you'll find something easy in the end :)
07:57:46 <dcoutts> you want a list of strings and responses
07:57:57 <dcoutts> where the response is your own data type
07:58:06 <dcoutts> [(String, a)] -> a
07:59:07 <nomeata> well, I'd sugest to use a predefined response type, to enable the use of stock icons
07:59:25 <nomeata> and maybe one RESPONSE_CUSTOM a, that gets no icon
07:59:32 <ndm> typing "Yes","No","Cancel", just guarantees the order of the buttons will be wrong
07:59:38 <dcoutts> indeed
07:59:50 <nomeata> data Response = ResponseYes | ResponseNo | ResponseCancel | ResponseCustom a
07:59:59 <dcoutts> and Gtk+ does have support for putting the buttons in the right order according to the platform
08:00:17 <dcoutts> ie it's one way on Gnome and OSX and the opposite way on windows
08:01:54 <nomeata> I still would like to know what's wrong with my pasted code, so I can try to hack up some programmer-friendly dialog function
08:02:52 <ihope> Well, if you mean that line you just pasted, you'd probably want data Response a = ResponseYes | ResponseNo | ResponseCancel | ResponseCustom a
08:03:15 <nomeata> no, I mean  http://paste.lisp.org/display/24170
08:03:17 <dcoutts> nomeata, ok, well you want a string for each button and a way of indicating the kind of the button so you can use stock icons as you suggest
08:03:44 <nomeata> dcoutts: icons and ordering, yes.
08:03:53 <MarcWeber> Is there a shorter way for btn <- buttonNew "foo" >>= (\btn -> btn `onClicked event >> return btn) Especially for passing btn by `onClicked`.
08:04:23 <dcoutts> and then minimally a line of text, but preferably a main line and optional secondary text like in the HIG
08:05:31 <dcoutts> MarcWeber, 3 or 4 lines is about as short as you can expect and keep it readable I think
08:05:41 <dcoutts> btn <- buttonNew
08:05:54 <dcoutts> onClicked btn $ do ...
08:05:57 <dcoutts> return btn
08:08:18 <nomeata> ok, found my problem
08:10:44 <ndm> nomeata: i'd personally like something in the same lines as askUser, but with a Window param (which is required for the modality), so feel free to add it to proplang
08:10:56 <ndm> since proplang is highly experimental, it can always be changed/removed later
08:11:58 <MarcWeber> dcoutts: Yeah. its readable... but beocmes kind of polluting when using many buttons .. I'll  use a function containnig these steps (http://rafb.net/paste/results/wmG3Fw42.html)
08:12:55 <dcoutts> MarcWeber, next time we break aoi, eg with Haskell' we can make that eaier, eg:
08:13:21 <ndm> aoi?
08:13:24 <dcoutts> Button.new [ handler clicked := do ... ]
08:13:32 <dcoutts> aoi/api
08:14:03 <dcoutts> ie we'll allow setting properties on construction
08:14:12 <dcoutts> and that'll inlcude event handlers
08:14:45 <MarcWeber> dcoutts: Can I use some kind of writer monnad to add many controls to a container?
08:14:58 <nomeata> ndm: I'm currently doing the save/load stuff, but afterwards maybe
08:15:13 <dcoutts> MarcWeber, if you code it yourself certainly :-)
08:16:06 <dcoutts> set mycontainer [ containerChild := child | child <- ... ]
08:16:14 <dcoutts> is also an easy way to do it
08:16:40 <norpan> hey, what is :=
08:19:12 <MarcWeber> dcoutts: I'm thinking of something like addToContainer ( do { buttonNewWithLabel "blah"; buttNewWithLabel "foo"; buttonNewWithClickE "hello" (msgBox "hello")})  container which would be much clearer because you don't need those x y z in [ ... | child <- [x,y,z] ] anymore, right?
08:19:38 <dcoutts> sure, try it
08:22:23 <ndm> nomeata: cool, thanks for all this work you are doing on it!
08:22:29 <ndm> @wiki PropLang
08:22:29 <lambdabot> http://www.haskell.org/haskellwiki/PropLang
08:22:34 <MarcWeber> what abouut mapM $ (a `conntainerAdd`) $ [ buttonNew, buttonNew,..]  ? Then I don't have to write anything new ;)
08:23:51 <ndm> the first $ is irrelevant, i think
08:24:52 <MarcWeber> right :)
08:33:02 <xerox> The second one is too.
08:45:23 <emertens> screw mathschallenge.net for putting an NP-Hard problem in the problem set and making me brute force it
08:45:37 <emertens> arg!
08:47:57 <MarcWeber> Is there something shorter for (\c -> Just $ snd c) ? (Just.snd) (would mean module Just), ((Just).snd) doesn't work.
08:48:09 <emertens> Just . snd
08:49:36 <MarcWeber> emertens: Oh it does.  (Using one space or ()) Thx
08:49:41 <nomeata> ndm: got another patch, file management complete now
08:49:49 <nomeata> but that's it for today :-)
08:50:05 <ndm> nomeata: thanks a lot! i've added you to the proplang wiki page, as a patcher :)
08:50:41 <ndm> nomeata: one question, why no need to write to modified anymore?
08:51:29 <nomeata> ndm: because modified = txt != oldtext
08:51:47 <nomeata> so it's always reflecting that state
08:52:00 <nomeata> one has to update oldtext, though
08:52:06 <nomeata> pasttxt it's called, i think
08:52:09 <ndm> ah, cool :)
08:52:11 <ndm> lasttxt
08:52:18 <nomeata> whatever :-)
08:52:25 <ndm> and you can now implement revert trivially
08:52:39 <ndm> and modified actually reflects differences, not changes
08:52:48 <ndm> i.e. type a c, delete it, and modiefied = false again :)
08:52:53 <nomeata> right, I thought about that too. (txt!text) -<- lasttxt
08:52:59 <nomeata> that't the point
08:53:02 <ndm> woot, that looks cool
08:53:21 * nomeata is off
08:53:21 <ndm> thanks a lot, very nice
08:53:28 <ndm> @karma+ nomeata
08:53:29 <lambdabot> nomeata's karma raised to 1.
08:53:29 <nomeata> :-)
08:54:16 <ndm> all pushed, and all happy :)
08:54:58 <tibbe> I'm trying to build haskellnet which needs NewBinary but NewBinary 0.1 refuses to build, it there a newer version?
08:55:18 <ndm> NewNewBinary ;)
08:55:33 <tibbe> :p
08:55:34 <int-e> NewTernary?
08:56:01 <tibbe> go ahead, make fun of my misery ;)
08:56:42 * Patterner makes fun of tibbe's misery
09:08:28 <tibbe> shapr, ping
09:08:33 <tibbe> @seen shapr
09:08:34 <lambdabot> I saw shapr leaving #haskell, #ScannedInAvian and #haskell-blah 22 hours, 23 minutes and 41 seconds ago, and .
09:25:22 <eivuokko> Would Windows resource compiler usage belong to Cabal, or the software that uses Cabal (ie Setup.hs)?
09:29:44 <ndm> eivuokko: not sure what you are meaning?
09:29:50 <ndm> "resource useage"
09:30:02 <eivuokko> resource compiler
09:30:02 <ndm> i guess Cabal will do it automatically in some way, i guess....
09:30:12 <eivuokko> Cabal doesn't know or handle resource scripts
09:30:18 <ndm> well it should do!
09:30:36 <eivuokko> I am not actually sure if I can get it accept binary resource either.
09:30:40 <ndm> what are you trying to add with resource scripts?
09:30:49 <svref> What's the preferred code editor for Haskell?
09:30:58 <eivuokko> Version info, embedding files, like manifests, icons, etc.
09:31:01 <ndm> svref: emacs, vi, textpad
09:31:03 <eivuokko> svref, The one you like.
09:31:28 <ndm> hmm, you don't really want a binary resource file, a text one is better
09:31:39 <svref> Debian stable emacs isn't grokking .hs files out of the box, puts me in "Fundamental"mode.  :P
09:31:43 <eivuokko> You want binary resource files if you embed dialoginfo
09:32:03 <ndm> no, you can put them in textual resource files - visual studio does the conversion automatically
09:32:24 <eivuokko> Yes, but you want to use editor to handle them and traditionally that's binary.
09:33:20 <eivuokko> Anyway, that should be simple, they are just object files, assuming of course the object file in right format.
09:36:33 <ndm> doesn't the visual studio editor work with textual resource files?
09:36:42 <ndm> thats the only editor i've used...
09:37:00 <svref> is there some easy way to ask for the first element of a tuple?
09:37:30 <svref> or is it case (x,_) of tuple...
09:37:42 <eivuokko> ndm, Hmmm.  Not sure, and I am mainly interested in scripts anyway...
09:37:58 <ndm> svref: try hoogle :)
09:38:03 <ndm> @hoogle (a,b) -> a
09:38:06 <lambdabot> Prelude.fst :: (a, b) -> a
09:38:06 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
09:38:06 <lambdabot> Prelude.snd :: (a, b) -> b
09:38:06 <svref> ndm: thanks
09:38:15 <ndm> answer, yes, its called fst
09:39:07 <svref> > fst (3,6)
09:39:13 <lambdabot>  3
09:39:23 <svref> > fst (3,6,9)
09:39:24 <lambdabot>  Couldn't match `(a, b)' against `(a1, b1, c)'
09:40:01 <svref> close enough :)
09:50:51 <tibbe> @hoogle emptyLine
09:50:52 <lambdabot> No matches found
10:11:18 <_JusSx_> wow
10:11:24 <_JusSx_> why so many ppl?
10:11:44 <_JusSx_> who partecipated to icfp this year?
10:12:00 <swiert> the idling is deafening.
10:12:17 <int-e> @users
10:12:20 <lambdabot> Maximum users seen in #haskell: 235, currently: 209
10:12:44 <int-e> See, we're still far away from that maximum, no wonder it's so quiet.
10:12:50 <_JusSx_> last time i was here, there was more or less 20 guys here
10:13:07 <_JusSx_> what happened?
10:14:04 <lucca> darcs and various other tools
10:17:30 <ndm> _JusSx_: how long ago was that?
10:21:52 <svref> Hat + Ghc6 work fine on the program in Hat's tutorial, but on my real program, the compiler screams about "the monomorphism restriction" and various other things.  What should I do?
10:22:26 <svref> (the real program compiles fine without Hat)
10:47:36 <svref> "Ord a => [a] -> a -> [(a,a)]" What's the syntax to say that a implements both Ord and Num?
10:49:05 <psi> (Ord a, Num a) iirc.
10:49:09 <kombinator> (Ord a, Num a) => ...
10:49:37 * kpreid has acquired the habit of writing (Ord a) => ... due to that
10:49:39 <svref> That works, thank you.
11:23:39 <nostromo> I reported the gentoo problem with gtk2hs we spoke about this (European) morning: http://bugs.gentoo.org/show_bug.cgi?id=144028
11:23:41 <lambdabot> Title: Bug 144028 - dev-haskell/gtk2hs does not build with glibc-2.4-r3
11:23:57 <dcoutts> nostromo, thanks very much
11:24:08 <nostromo> I would appreciate a quick patch/clues to fix it
11:25:41 <emertens> Is there a highspeed mutable version of Data.Set.Set?
11:25:49 <nostromo> there are plenty of such functions declared as returning __typeof (whatever)
11:25:51 <emertens> @index STSet
11:25:51 <lambdabot> bzzt
11:26:13 <Lemmih> emertens: No, not really.
11:26:20 <nostromo> mutable should be a forbidden word in a functional language channel :P
11:26:53 <bass> Hi guys, can anybody explain why Data.Map.lookup returns a Monad and not just a value that is in the map?  http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html#v%3Alookup
11:27:20 <xerox> bass: because the computation can fail (if it doesn't find any)
11:27:34 <xerox> bass: then, for the monad you pick, the behaviour you get is different.
11:27:54 <Lemmih> > M.lookup "key" (M.fromList []) :: Maybe String
11:27:55 <lambdabot>  Nothing
11:28:01 <Lemmih> > M.lookup "key" (M.fromList []) :: [String]
11:28:02 <lambdabot>  []
11:28:03 <bass> ok, so I need to have a Monad to be able to lookup values in Maps
11:28:10 <int-e> bass: if it helps, just think of the function as returning a Maybe. It can do that, Maybe is a MonadPlus instance.
11:28:32 <xerox> > M.lookup "key" (M.fromList []) :: Either String String
11:28:33 <lambdabot>  add an instance declaration for (Monad (Either String))
11:28:34 <lambdabot>   In the expressi...
11:28:34 <bass> Oh right of course!
11:28:38 <xerox> Yuck.
11:28:58 <xerox> ?instance MonadError
11:28:59 <lambdabot> Maybe you meant: instances instances-importing
11:29:25 <bass> thanks
11:32:37 <shapr> dude, as if!
11:33:12 <shapr> @users
11:33:12 <lambdabot> Maximum users seen in #haskell: 235, currently: 212
11:33:25 <shapr> tibbe: Hey, thanks for trying HaskellNet
11:33:31 <shapr> tibbe: Did you get my reply?
11:33:39 <shapr> bringert: Hope still kicks butt :-)
11:35:57 * Lemmih wonders if someone's willing to share a bunk at ICFP.
11:40:55 * shapr boings
11:41:03 <shapr> Sure is quiet today.
11:41:40 <kpreid> > cycle "noise"
11:41:41 <lambdabot>  "noisenoisenoisenoisenoisenoisenoisenoisenoisenoisenoisenoisenoisenoisenoise...
11:42:02 <shapr> Try Jun Mukai's Summer of Code project, HaskellNet! do darcs get http://darcs.haskell.org/SoC/haskellnet and try the code! Then tell and Jun what you think. I'm the mentor, not that I've had to do anything...
11:42:04 <lambdabot> Title: Index of /SoC/haskellnet
11:46:54 <eivuokko> Chain of deps strikes again :-)
11:55:21 <ndm> i believe xerox is solving the deps problem for his SoC project
11:55:45 <svref> "hat-detect" looks cool, but debain didn't install it along with hat-observe, -stack, -trail, -trans, -view, and -check.  Waaah.
11:56:13 <ndm> svref: i believe hat-detect is newer than the others
11:56:53 <svref> are you daring to insinuate that debian might not be up-to-date?  Are you a troll?  :)
11:57:23 <ndm> nah, i'm a hat person (for some definition of hat person)
11:59:56 <Lemmih> xerox: How's Cabal-get coming along?
12:02:29 <lispy> i love debian, but debian is often not up to date on packages that really matter to me
12:02:43 <lispy> for everything else, the's apt
12:03:07 <svref> lispy: debian for servers, ubuntu for computers you actually touch.
12:05:22 <SamB> my excuse is that I hadn't heard of ubuntu when I set this box up. oh, and I don't have enough computers to have a seperate server...
12:07:05 <svref> My excuse is that the server is always on, and it takes so long to fire up a laptop...
12:08:24 <svref> I've had amazing results with Ubuntu.  Its probably the best OS I've ever used (though I haven't used MSWindows or MacOS in 3++ years)
12:08:54 <SamB> trust me, Windows is not a very nice OS
12:08:59 <emertens> LOL
12:09:27 <dylan> trust me, Windows is not an OS.
12:09:35 <SamB> not as distributed by MS, anyway
12:09:43 <nostromo> some Dell laptops seem to be easy to "fire off" :)
12:09:43 <emertens> am I in #comedy ?
12:09:54 <emertens> just have wandered away from #haskell
12:10:04 <SamB> it has potential, I Think
12:10:09 <SamB> er.
12:10:14 <SamB> why did I capitalize think?
12:10:28 <ndm> windows is great!
12:10:31 <emertens> you were thinking of a Mac product, iThink ;)
12:11:53 <emertens> who can guess what these two lines of code do
12:11:54 <emertens> solve n = let next ys@(h:_) = [b:ys | a <- ys, let b=a+h, b <= n] in fromJust . find ((==n) . head) . concat . iterate (>>= next)
12:12:12 <SamB> @type let solve n = let next ys@(h:_) = [b:ys | a <- ys, let b=a+h, b <= n] in fromJust . find ((==n) . head) . concat . iterate (>>= next) in solve
12:12:14 <lambdabot> forall a. (Num a, Ord a) => a -> [[a]] -> [a]
12:15:04 <emertens> > let solve n = let next ys@(h:_) = [b:ys | a <- ys, let b=a+h, b <= n] in fromJust . find ((==n) . head) . concat . iterate (>>= next) in solve 15 [[1]]
12:15:06 <lambdabot>  [15,10,5,4,2,1]
12:19:24 <SamB> I still can't guess what it does ;-)
12:19:40 <bringert> shapr: sweet (re: hope kicking butt)
12:20:33 <vegai> What is Hope suited for? Every kind of web app imaginable?
12:23:31 <emertens> it's the shortest addition chain to n
12:24:07 <ndm> is hope suitable for hoogle?
12:24:08 <SamB> oh
12:24:16 <emertens> the solving such a chain is NP-Hard, which was making my solutions take a long time :)
12:24:39 <ndm> since it appears hsx requires GHC, which makes it a no-no for hoogle :(
12:25:27 <SamB> what is wrong with GHC?
12:25:43 <emertens> > let solve n = let next ys@(h:_) = [b:ys | a <- ys, let b=a+h, b <= n] in fromJust . find ((==n) . head) . concat . iterate (>>= next) in solve 191 [[1]]
12:25:47 <lambdabot> Terminated
12:25:55 <emertens> 191 is the longest chain below 200
12:25:59 <emertens> > let solve n = let next ys@(h:_) = [b:ys | a <- ys, let b=a+h, b <= n] in fromJust . find ((==n) . head) . concat . iterate (>>= next) in solve 192 [[1]]
12:26:00 <lambdabot>  [192,128,64,32,16,8,4,2,1]
12:26:23 <bringert> vegai: I don't know, that needs to be explored
12:26:42 <bringert> vegai: but I think that I have made it pretty general
12:27:32 <bringert> ndm: you could make a hoogle module for Hope, if you want to integrate Hoogle with some larger  web site
12:28:03 <ndm> SamB: Hoogle is developed with Hugs, and will be released with Yhc - GHC is only used for the web server
12:28:16 <ndm> bringert: no, i more meant writing hoogle
12:28:35 <ndm> GHC is too slow to develop Hoogle, its slowness annoys me
12:28:48 <ndm> (at compile time, which is obviously what as a developer i do all day!)
12:28:59 <SamB> hugs supports compiling?
12:30:00 <ndm> yes/no
12:30:09 <ndm> it supports loading the code in the interpretter
12:30:15 <bringert> ndm: ah, no. Hope doesn't currently support dynamic compilation or anything like that
12:30:17 <emertens> like ghci?
12:30:19 <ndm> which includes parsing, type checking and generating a bytecode
12:30:40 <ndm> i would call that compiling, but its an ambiguous area
12:31:01 <ndm> emertens: like ghci, but instant, rather than slow
12:31:56 <SamB> hmm, so what makes ghci so slow?
12:32:00 <emertens> I like the breaks I get at work when compiling with visual studio.net
12:32:09 <emertens> I'd hate to have to work constantly
12:32:28 <ndm> i used to use borland C++, imagine 24 minute compiles, and it always recmopiled everything!
12:32:36 <SamB> ouch!
12:32:42 <ndm> SamB: its written in Haskell ;)
12:33:02 <ndm> yeah, i had a P200, which the bosses wife, who occasionally did a few spreadsheets, had a 3Ghz machine
12:33:15 <jgrimes_> ouch
12:33:26 <ndm> and borland C++ adds back the #include's that i removed to speed up the build!
12:33:56 <SamB> so where is the hit?
12:34:00 <SamB> parsing?
12:34:01 <SamB> typechecking?
12:34:03 <SamB> desugaring?
12:34:09 <SamB> converting to bytecode?
12:34:17 <ndm> every one of the above
12:34:20 <ndm> GHC is just not that fast
12:34:23 <ndm> Yhc is massively faster
12:34:27 <ndm> Hugs even more so
12:34:35 <ndm> someone really should profile GHC at some point
12:34:46 <SamB> hmm
12:35:02 <ndm> i have reported O(n^2) bugs in GHC for certain syntactic constructs
12:35:08 <ndm> who knows what else is lurking in there
12:35:21 <ndm> op >> op >> op >> op >> ... 700 times
12:35:28 <ndm> the compile, and what GHC cry
12:36:05 <SamB> @fixity >>
12:36:05 <lambdabot> Unknown command, try @list
12:36:31 <ndm> it applies to any monadic block
12:36:35 <ndm> not sure why though
12:37:02 <SamB> do you mean Œ©(n^2)?
12:37:12 <ndm> I just mean really really really really slow :)
12:37:30 <ndm> at a much more than linear factor
12:37:37 <ndm> i assume n^2, but it might be worse
12:37:40 <emertens> ndm: if you are reported the same bug a quadratic number of times
12:37:56 <emertens> you're probably being caught in the spam filter
12:38:02 <emertens> err
12:38:07 <SamB> emertens: heh
12:38:12 <emertens> not same
12:38:16 <ndm> anyway, GHC is way too slow
12:38:23 <ndm> no idea why, but it is
12:38:27 <emertens> how slow is it?
12:38:27 <ndm> linking is slow too
12:38:33 <ndm> which Yhc avoids entirely until runtime
12:38:35 <SamB> linking
12:38:37 <ndm> to compile Yhc
12:38:41 <SamB> is not GHC's fault...
12:38:41 <ndm> on my home machine
12:38:49 <emertens> linking is the fault of gcc
12:38:50 <ndm> Hugs = 5 secs, GHC = 7 mins
12:39:02 <ndm> if ghc invokes gcc, then that becomes ghc's fault
12:39:04 <SamB> emertens: you mean ld
12:39:12 <emertens> it's all in the same toolkit, whatever :)
12:39:15 <ndm> it adds to the GHC compile time
12:39:22 <SamB> I mean, the abysmal linking speed is not GHC's fault...
12:39:28 <ndm> yeah, i realise that
12:39:28 <emertens> because it's actually compiling :)
12:39:41 <ndm> but its more than actually linking, although that is a big hit
12:39:43 <SamB> I bet it would work better if ld used data structures
12:39:53 <ndm> since linking is not linear, one change = relink
12:40:03 <ndm> while you can just recompile some files
12:40:05 <SamB> oh, you mean GCC and the mangler?
12:40:06 <eivuokko> Well, there are incremental linkers..
12:40:16 <eivuokko> Just that gnu ld isn't one, is it?
12:40:40 <SamB> eivuokko: I bet GHC doesn't know how to invoke any of them properly, either...
12:41:35 <ndm> anyway, i suspect GHC could be improved a lot
12:41:49 <ndm> once Yhc works, we want to move to ByteString, which should give us another big performance boost
12:42:02 <ndm> something GHC can't do, because it has to be GHC 5.0 compatible
12:42:16 <eivuokko> Huh?
12:42:20 <jgrimes_> someone could always fork ghc, right?
12:42:30 <ndm> GHC officially wants to compile all the way back to GHC 5.9
12:42:33 <ndm> * 5.0
12:42:39 <ndm> 5.0 does not have bytestring
12:42:43 <ndm> and works quite differently
12:42:47 <ndm> so its unlikely to get it
12:42:58 <ndm> whereas Yhc has no such qualms, and can demand GHC 6.6 :)
12:42:59 <eivuokko> I thought GHC is barely compatible one released version backwards.
12:43:00 <SamB> ndm: they can include modules that they need alongside the compiler...
12:43:17 <SamB> they use packed strings already, anyway
12:43:20 <ndm> SamB: ByteString prods the internals quite deeply, would be quick hard...
12:43:24 <eivuokko> (compatible as in being able to bootstrap from)
12:43:39 <ndm> eivuokko: alegedly, in the manual, 5.0 is the compatible target
12:43:45 <Igloo> GHC just puts new libraries into lib/compat when it needs them to compile with older GHCs
12:43:56 <ndm> that might just be an incompatible manual though ;)
12:44:52 <SamB> are you telling me that Data.ByteString won't be able to build with 5.0?
12:45:06 <ndm> i have no idea, but it would be more work
12:45:16 <eivuokko> ndm, I might be wrong.  I just had really diffrent impression.
12:45:20 <SamB> who cares?
12:45:30 <ndm> eivuokko: i only read the manual, it may be outdated now
12:45:36 <SamB> people who go back and grab 5.0 binaries just to compile 6.6 with are crazy ;-)
12:45:51 <eivuokko> SamB, Why...I was about to try it.
12:45:52 <ndm> a lot of people are crazy :)
12:46:05 <ndm> if they could compile GHC with Yhc, then they could solve all their build issues
12:46:19 <ndm> certainly not possible at the mo,  but perhaps one day...
12:46:29 <eivuokko> Well, yhc needs a lot of fronend work, doesn't it?  It has almost no extensions.
12:46:43 <ndm> yes, a lot is a bit of an understatement :)
12:47:22 <eivuokko> If I understand correctly, not even forall-stuff :-S  MPTC and stuff I can live without, but forall...ouchie.
12:47:33 <ndm> yep
12:47:42 <ndm> although there is a SoC project to fix that up
12:47:46 <Igloo> What do you need the forall stuff for?
12:48:02 <SamB> which extensions does GHC actually use for bootstrapping?
12:49:51 <eivuokko> Igloo, storing class context in variables, safety tricks with types.
12:49:52 * emertens imagines a catastrophe were the GHC binaries that are able to compile the current ghc source get wiped out, and all that's left is code for a compiler that needs to be compiled to compile itself
12:50:10 <emertens> existential types stuff?
12:51:23 <eivuokko> Yes.  data Foo = forall a. (Show a) => Foo a
12:52:46 <eivuokko> And stuff like runST is also quite useful.
12:54:41 <Igloo> Hmm, mathschallenge.net has banned me for 10 mins because I was solving the problems too quickly
12:55:42 <emertens> correctly?
12:55:53 <emertens> (you didn't heed the slow down warning?)
12:56:05 <emertens> Igloo: what is your mathschallenge nick?
12:56:10 <SamB> emertens: haha
12:56:26 <emertens> SamB: what? there is a warning telling you to slow down on the submitting :)
12:56:48 <SamB> like all the GHC 6 binaries could be wiped out...
12:56:57 <emertens> ohhh
12:56:59 <emertens> :)
12:57:33 <Igloo> All correct but one
12:57:54 * Igloo misread the warning, I think, but I can't check what it says now
12:58:29 <emertens> Igloo: are you igfoo?
12:58:33 <Igloo> Yup
12:58:47 <emertens> I'm glguy
12:59:11 <emertens> Failure02 aka Eighty frequents the channel
13:01:13 <emertens> I was not aware that England's flag was a red cross
13:02:06 <BCoppens> emertens: ever watched the english football fans? They don't hop around in a blue flag usually, afaik
13:02:14 <Igloo> You'll normally see the Union Flag, three crosses of various directions and colours dumped on top of each other
13:02:31 <emertens> no, i typically don't want english people watch soccer
13:02:33 <Igloo> (http://en.wikipedia.org/wiki/Union_Flag)
13:02:49 <BCoppens> emertens: neither do I, but unfortunately you can't always avoid it if you watch the news :P
13:03:19 <emertens> I don't like the way the the Union Flag's diagonal stripes seem to not intersect the middle of the flag
13:03:24 <emertens> that's always bothered me
13:06:43 <greenrd> Igloo: That's the *British* flag, not the *English* flag ;)
13:07:39 <emertens> greenrd: those are different?
13:07:42 <emertens> :-p
13:13:44 <wolverian> I have a data type LS { fields }, and various foo = LS { ... } definitions. can I specialise functions to work on the specific 'foo's, or am I misusing the system? :)
13:14:18 <sieni> http://en.wikipedia.org/wiki/List_of_British_flags
13:14:26 <wolverian> (they are l-systems)
13:15:33 <wolverian> I see that I could also define data LS = Koch | ...; and make functions for those. however, I don't have enough experience to know what the right thing (tm) here is.
13:16:09 <wolverian> or I could put the draw methods (which need to be specialised) inside the datatype
13:16:22 <greenrd> That would be the right approach, I think
13:17:09 <wolverian> I was hesitant about that because it looks so ugly
13:17:54 * edwardk waves hello.
13:18:45 <greenrd> Why is it ugly?
13:19:08 <greenrd> If you want to have an identifying field whichOneAmI, and case on that, go ahead
13:19:10 <wolverian> well I'd like to do: koch = LS { ...; draw '+' = ...; draw '-' = ...; } but I gather that won't do
13:19:12 <greenrd> but I think the latter is ugly
13:19:43 <wolverian> I suppose it's just syntax.
13:19:46 <wolverian> thanks.
13:20:23 <wolverian> greenrd, that feels unclean. :)
13:20:30 <wolverian> I'll just go the map route
13:34:10 <Igloo> Anyone with ghci on an amd64 around?
13:34:47 <Patterner> yes
13:35:09 <Igloo> What does   reverse $ take 10 $ reverse $ show $ sum [ x ^ x | x <- [1..1000] ]   say for you? And what OS are you using?
13:35:33 <greenrd> "0612504812"
13:35:34 <greenrd> Linux
13:35:41 <Igloo> What distribution?
13:35:53 <wilx> "9110846700"
13:35:53 <greenrd> sorry, this is nocona, not amd64
13:35:58 <greenrd> rpath linux 1
13:36:08 <edwardk> >  reverse $ take 10 $ reverse $ show $ sum [ x ^ x | x <- [1..1000] ]
13:36:09 <lambdabot>  "9110846700"
13:36:11 <edwardk> @version
13:36:11 <lambdabot> lambdabot 4p63, GHC 6.5 (OpenBSD i386 )
13:36:11 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
13:36:13 <Igloo> nocona?
13:36:14 <edwardk> =)
13:36:14 <wilx> Heh, interesting. GHCi 6.4.2 on FreeBSD 6.1 .
13:36:28 <greenrd> Igloo: a pentium 4 that can handle x86_64 instructions
13:36:33 <sethk> is the \\ operator an operator on two lists that returns the values in one but not in the other?
13:36:35 <Patterner> "0612504812" gentoo linux
13:36:42 <Igloo> wilx: And an amd64 CPU?
13:36:49 <wilx> Nope, 32bit P4.
13:36:54 <Igloo> OK. Thanks all
13:37:10 * Igloo will file a bug in a tick
13:37:47 <Patterner> 6.4.2 (if it matters...)
13:38:08 <Igloo> (see, I wasn't wasting time on mathschallenge.net. I was hunting for ghc bugs!)
13:38:38 <edwardk> igloo: heh
13:38:59 <Klauso> Is it possible to write a non-terminating function in Haskell that is not recursive (and does not call other recursive functions)? In Lambda-Calculus this would of course be possible (e.g. using Y Combinator) but what about Haskell?
13:39:58 <greenrd> I wouldn't think so, because there's no primitive iteration nor primitive code generation
13:40:00 <edwardk> klauso: i think not without some loop involved everything should resolve
13:40:28 <sethk> how do I get around the problem where Distribution.Compat.FilePath is hidden in Cabal-1.1.4?
13:40:52 <edwardk> klauso: after all, haskell gets desugared down to a variant of the lambda cube
13:41:28 <Klauso> how is the desugaring relevant to this question?
13:41:47 <edwardk> klauso: unless you could stuff like functions in the prelude that can diverge.
13:42:22 <edwardk> klauso: hrmm, well, can you type a combinator?
13:42:31 <Klauso> sure
13:42:45 <Klauso> (\x -> (x x)) (\x -> (x x))
13:43:00 <Klauso> if this would type-check it would be a non-terminating expression
13:43:08 <edwardk> @type (\x -> (x x)) (\x -> (x x))
13:43:09 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
13:43:09 <lambdabot>    Expected type: t
13:43:17 <edwardk> i meant type check =)
13:43:24 <edwardk> that being my point =)
13:43:34 <int-e> "9110846700" with gentoo linux (ghc 6.4.2 and ghc 6.5, gmp 4.2.1 (next likely culprit))
13:43:55 <Klauso> well, this particular fixed point combinator does not type-check, but maybe another one would?
13:44:37 <Klauso> I also know that simply-typed lambda calculus is strongly normalizing but Haskell's type system is obviously much more powerful
13:46:28 <Patterner> int-e: 6.5 on gentoo?
13:46:30 <edwardk> klauso: well, the haskell type system gets cast onto the lambda cube more or less in core. all calculi in the lambda cube is all strongly normalizing. the only real extensions at that level are case statements for pattern matching, so i would presume, yes, but when you sprinkle in some of the advanced type weirdness from ghc its possible not.
13:46:49 <edwardk> er all caculi in the lambda cube are strongly...
13:47:27 <int-e> Patterner: compiled myself. (although there appears to be a ghc-darcs package)
13:47:51 <Patterner> not on my system...
13:48:07 <Klauso> edwardk: But if everything gets compiled to lambda cube how are recursive (non-terminating) functions compiled?
13:48:25 <edwardk> klauso: erf, forgot there is also a letrec primitive added too
13:48:42 <Klauso> Is it really the case that the whole lambda cube is strongly normalizing? I thought this would only hold for simply-typed LC
13:48:48 <edwardk> and every type is presumed pointed. there are some subtle distinctions
13:49:01 * edwardk goes to dig up the paper he first read it in.
13:49:17 <shapr> Isn't the ackermann function neither recursive nor terminating? I thought it was pretty much the opposite of recursive.
13:50:23 <Klauso> of course ackermann is recursive
13:50:24 <zarvok> it's not _primitive_ recursive
13:50:27 <int-e> Patterner: Ok, there is not. Sorry. I must have mixed something up there.
13:50:30 <Klauso> the point is that it is not primitive recurision
13:50:32 <shapr> ah ok
13:50:45 <Klauso> sorry, zarvok, I was too late :-)
13:50:59 <zarvok> heh
13:51:00 * shapr likes this channel
13:51:03 <edwardk> still looking for the one, but G. Barthe, J. Hatcliff, M.H. S¯rensen, Weak normalization implies strong normalization in generalized non-dependent pure type systems, Theoret. Comput. Sci. (200x.), in press. might be a start
13:51:47 <int-e> Patterner: the gcc version could also be interesting (I'm still using 3.4.6 for most things here)
13:52:17 <Patterner> int-e: 4.1.1 (gmp is 4.2.1 too)
13:54:20 <Klauso> I guess one could make an expression non-terminating if we had call/cc in Haskell
13:54:23 <edwardk> Found it.
13:54:49 <edwardk> its in modularity of strong noralization in the algebraic lambda-cube by Barbanera Fernandez and Geuvers
13:55:11 <sethk> I'm having a problem because Distribution.Compat.FilePath is hidden in cabal.  There was a workaround for this, but I can't remember it.  Anyone?
13:55:14 <edwardk> Journal of Functional Programming 7 1997 pp613-660
13:55:29 <edwardk> its a cornerstone for my current research topic =)
13:55:45 <edwardk> i just couldn't remember who did the proof.
13:55:48 <sethk> dons, are you about?
13:55:49 <Klauso> so what does the paper say?
13:56:23 <Klauso> @type \f -> (\x -> f (\y -> x x y)) (\x -> f (\y -> x x y))
13:56:24 <edwardk> that a larger class of systems that includes the lambda cube are all strongly normallizing
13:56:24 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t2 -> t1
13:56:24 <lambdabot>    Expected type: t
13:56:37 <Klauso> I see, that's interesting
13:56:49 <Klauso> but this can't hold anymore once you introduce recursive types
13:57:21 <edwardk> thats possible too. iirc simon pj noted problems with that in Henk.
13:57:59 <edwardk> http://research.microsoft.com/~simonpj/Papers/henk.ps.gz
13:58:00 <Klauso> e, g., \x -> (x x)  could have type Mu t. a -> t
13:58:35 <Klauso> ...where Mu is a recursion operator on types
13:59:29 <edwardk> once you throw recursive types into the mix a lot of properties stop holding. i'm not sure what research has been done there.
13:59:31 <Klauso> it should be (Mu t. t -> a) of course
14:00:00 <Klauso> I am not proposing to do it :-)
14:00:04 <edwardk> heh
14:00:27 <edwardk> hrmm. does anyone know of any research on partially typed systems? i.e. where you can mix typed and truly untyped terms?
14:00:33 <Klauso> I just wanted to know whether it's possible to write non-terminating expressions in Haskell
14:00:58 <SamB> > let x = x in x
14:00:59 <lambdabot>  Add a type signature
14:01:02 <SamB> > let x = x in x :: ()
14:01:03 <lambdabot>  Exception: <<loop>>
14:01:05 <edwardk> klauso: define haskell in this. you mean in the surface syntax, using the functions baked into the prelude, etc.
14:01:17 <SamB> does that count?
14:01:28 <Klauso> I meant without using recursion
14:01:39 <SamB> hahahah
14:01:50 <SamB> without using recursion
14:01:56 <SamB> you can do next to nothing without using recursion
14:02:05 <Klauso> that's not true
14:02:08 <monochrom> sum (repeat 0) will probably do.
14:02:21 <Klauso> in lambda calculus you can do *everything* without recursion
14:02:25 <edwardk> mono: thats why i was trying to ask whether or note the prelude functions counted =)
14:02:35 <SamB> Klauso: what?
14:02:35 <edwardk> er or not
14:02:53 <edwardk> samb: fix point combinators
14:03:07 <SamB> oh
14:03:14 <SamB> > fix id ()
14:03:15 <lambdabot>  Add a type signature
14:03:15 <Klauso> in lambda calculus you can write things like (\x -> (x x)) (\x -> (x x))
14:03:23 <SamB> > fix id () :: ()
14:03:24 <lambdabot>  Exception: <<loop>>
14:04:01 <Klauso> with non-terminating expression I mean one which 1) is not in a recursive functions, 2) does not call any function that is recursive or calls another recursive function
14:04:01 <emertens> > fix (\f x -> if x == 1 then 1 else f (x-1)) 5
14:04:03 <lambdabot>  1
14:04:09 <emertens> > fix (\f x -> if x == 1 then 1 else x * f (x-1)) 5
14:04:10 <lambdabot>  120
14:04:13 <Klauso> so using "fix" does not count :-)
14:04:29 <SamB> ho
14:04:30 <SamB> oh
14:05:21 <SamB> wait
14:05:26 <edwardk> well, my answer is without fix and without an internaly recusive prelude function, no, unless you know some dark corner of the type system i am overlooking
14:05:30 <SamB> does fix even use recursion?
14:05:48 <Klauso> I think fix f = f (fix f)
14:05:55 <Klauso> so it is recursive
14:06:10 <emertens> the Y combinator is not recursive
14:06:17 <Klauso> yes, but it does not type-check
14:06:17 <SamB> > fix id :: ()
14:06:18 <lambdabot>  Exception: <<loop>>
14:06:43 <Klauso> @type \x -> (x x)
14:06:44 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
14:06:44 <lambdabot>    Expected type: t
14:06:54 <emertens> > fix (flip const) 4
14:06:56 <lambdabot>  4
14:06:59 <SamB> fix f = x where x = f x
14:07:06 <int-e> @pl \x -> x x
14:07:06 <lambdabot> join id
14:08:12 <edwardk> @type let y f = f (y f) in y
14:08:13 <lambdabot> forall t. (t -> t) -> t
14:14:54 <LordBrain> @index chr
14:14:55 <lambdabot> Data.Char
14:18:59 <emertens> @hoogle maximum'
14:18:59 <lambdabot> No matches found
14:49:32 <araujo> hello!
14:58:27 <emertens> hi
14:58:53 <emertens> note to self, it's faster to test 15k numbers for primality than it is to test 10^6 numbers for primality
15:01:43 <Kahdloc> emertens, wouldn't that be obvious?
15:03:01 <emertens> in hind-sight, yes it would :)
15:10:25 <int-e> not at all, it depends on the size of the numbers.
15:23:39 <emertens> Igloo: looks like you have been making progress today :)
15:26:36 <Igloo> emertens: Just been picking off the easy ones inbetween doing other things  :-)
15:32:12 <dcoutts> Igloo, does that mean musasabi and I can pester you for your opinion on Cabal configurations?
15:32:48 * dcoutts grins
15:33:18 <Igloo> dcoutts: I haven't managed to make a significant dent in the threads so far, I'm afraid. I got caught up in writing database libraries this weekend instead  :-(
15:38:11 <dcoutts> Igloo, ok :-)
15:39:38 <emertens> what is xor in Data.Bits?
15:39:46 <emertens> I want to xor two Ints...
15:39:49 <emertens> never done it before
15:40:08 <emertens> (do you xor Word8 s)
15:40:10 <emertens> ?
15:40:30 <SamB> > 1 `xor` 2 :: Int
15:40:31 <lambdabot>  3
15:40:38 <emertens> pimpin'
15:40:39 <SamB> that is how ;-)
15:40:53 <SamB> only usually you don't need to put the type in like that, exactly
15:42:28 <emertens> > (ord 'a',ord 'z', ord 'Z', ord 'A', ord ' ')
15:42:30 <lambdabot>  (97,122,90,65,32)
15:58:16 <giksos> hi, does anyone know if there are bindings for the history library?
15:59:35 * dcoutts does not know what the "history library" is
15:59:59 <monochrom> is there also the Dickens library? :)
16:00:15 <dcoutts> giksos, you don't mean command line history, like readline?
16:00:29 <monochrom> "module TheGreatExpectation where import OliverTwist ... "
16:00:37 <dcoutts> :-)
16:04:37 <giksos> i do mean command line history. The readline bindings that come with ghc only provide access to the addHistory function, but I need more.
16:25:25 <stepcut> How do I tell the type checker the 'a' in the type signature of a where clause is the same 'a' as the parent function ?
16:25:56 <stepcut> I get the error "Inferred type is less polymorphic than expected, Quantified type variable `p' is mentioned in the environment:"
16:27:03 <musasabi> stepcut: use forall in the outer signature.
16:27:20 <stepcut> thanks, that did it
16:27:30 * stepcut has no idea why though
16:28:37 <Cale> stepcut: that turns on scoping for type variables
16:29:02 <stepcut> ah, I think that is an explanation I can understand
16:29:13 <Cale> stepcut: otherwise, they're not bound outside the signature they occur in at all
16:29:40 <Cale> dons: are you up yet?
16:31:30 <Cale> I'm getting Regex.hsc:66:9: Not in scope: `P.unsafeUseAsCString' while trying to build lambdabot
16:32:01 <stepcut> Cale: do you have the darcs version of fps ?
16:32:07 <Cale> stepcut: yes
16:32:30 <Cale> oh, hmm... perhaps I should update lambdabot too :)
16:33:03 <stepcut> hrm ... I had a similar error, but updating from fps-0.7 to fps-darcs was the fix...
16:34:20 <Cale> 179 patches :)
16:34:32 <Cale> that'll keep my CPU busy for a while
16:35:14 <stepcut> heh
16:38:31 <Cale> I wonder what it is that darcs is doing there.
16:47:33 * Cale considers just downloading a fresh repo.
16:50:13 <Cale> Is darcs solving some sort of NP-hard problem when applying patches? :)
16:52:51 <stepcut> Cale: i believe it is
16:55:20 <Cale> perhaps it could at least do some kind of hash to see if the file had been edited first
17:24:10 <lispy> dons: in ghc 6.6 fps was added and called Data.ByteString correct?
17:24:24 <lispy> dons: i'm asking so that i can make a note of it for darcs
17:26:13 <lispy> Cale: some of us suspect so, and droundy and others have some proposals, but i guess it's a problem to solve
17:28:41 <fishkandy> lispy: according to the communities report for June, yes it was added (http://haskell.org/communities/06-2006/html/report.html)
17:28:42 <lambdabot> Title: Haskell Communities and Activities Report
17:29:03 <eivuokko> Oh, it would be cool if darcs required ghc 6.6...I could use new Win32 bits, too. :-)
17:29:21 <fishkandy> and unicode source files :))
17:29:45 <eivuokko> I don't think that is a big deal for darcs sources.
17:30:20 <fishkandy> eivuokko, sure, but i'll be happy if i can write functions in japanese :)
17:30:25 <eivuokko> :)
17:41:09 <lispy> fishkandy: hehe
17:41:20 <lispy> eivuokko: there are always #ifdef's ;)
17:41:41 <lispy> eivuokko: personally, i'd like to say, make ghc 6.6 a requirement, but i guess supporting 6.2 allows darcs on more platforms
17:42:36 <lispy> eivuokko: are you interested in darcs development?  i've been strongly considering maintaining my own branch of darcs to further my darcs interests when they diverge from that of the current maintainership
17:42:58 <lispy> and requiring 6.6 is something i wouldn't have problems with
17:50:47 <Cale> hahaha
17:50:53 <Cale> darcs is still patching
17:51:10 <lispy> who maintains the debian ghc package?
17:51:20 <lispy> i want a recent ghc but the best i can get is 6.4.2
17:51:31 <lispy> well, i should rephrase that
17:51:45 <lispy> if i wanted a recent development version of ghc the best i can get is from 2005
17:51:51 <Cale> My father and I went out to the store to get some drain cleaner and a snake, and then over to the coffee shop, and it's still going. I think I'll just download a new repo :)
17:51:54 <lispy> unless i'm willing to build it myself
17:52:12 <Cale> They should at least add a progress meter to it.
17:52:15 <lispy> Cale: any unusualy circumstances?
17:52:27 <lispy> Cale: yeah, and verbose isn't really
17:52:28 <Cale> lispy: 179 patches to pull, other than that no
17:52:54 <lispy> probably darcs could use a custom monad on top of the IO monad for things like progress
17:53:14 <SamB> yeah, that could work
17:53:15 <fishkandy> lispy, and cabal (libghc6-cabal-dev) is stuck at 1.1.3 :-(
17:53:23 <SamB> but it might be non-linear
17:53:24 <lispy> fishkandy: yikes!
17:53:32 <lispy> SamB: how so?
17:54:00 <lispy> SamB: darcs miht be non-linear in it's workflow or the way the monad reports status it would appear non-linear?
17:54:02 <SamB> I mean, well, if it was a progress bar it might not move at a steady rate
17:54:29 <lispy> yeah, it's hard to predict how long a step will take, but we colud at least say, "Applying patch x of y"
17:54:33 <lispy> actually, doesn't ti do that?
17:54:36 <lispy> or is that only for a get
17:54:42 <lispy> Cale: what version do you have?
17:55:05 <lispy> i don't get to use darcs as often as i would like so even though i have looked at the source a lot i forget sometimes howi t does things :)
17:55:07 <Cale> lispy: darcs 1.0.5 (release)
17:55:12 <edwardk>  @tell shapr http://thunderbird.scannedinavian.com/~shae/cgi-bin/Flippi?view=TestMargin is linked in the june haskell community report, but your server wants authentication to view the page.
17:55:21 <edwardk> gah space
17:55:27 <edwardk> @tell shapr http://thunderbird.scannedinavian.com/~shae/cgi-bin/Flippi?view=TestMargin is linked in the june haskell community report, but your server wants authentication to view the page.
17:55:27 <lambdabot> Consider it noted.
17:55:35 <lispy> Cale: you should probably upgrade, i don't remember which version but something around 1.0.5 had a bad bug in patch reordering
17:55:57 <Cale> lispy: this is just the one which is current in Ubuntu
17:55:58 <lispy> Cale: not the easiest thing to trigger, but not fun if you get it
17:56:02 <Cale> hmm
17:56:19 <lispy> Cale: wouldn't cause the behavior your seeing tho
17:56:58 <Cale> I've had problems applying patches to things when I leave them for too long
17:57:49 <lispy> you mean, when you go a long time without updating?
17:57:54 <Cale> yeah
17:58:01 <Cale> and lots of patches build up
17:58:02 <lispy> i've noticed that before too
17:58:22 <lispy> like when i don't work on yi for 6 months then pull patches
17:58:33 <lispy> i think it happens when there have been conflicts since you pulled last
17:58:43 <lispy> just a theory, i never tested it
17:59:01 <Cale> perhaps I'll apply them 5 at a time or something
17:59:07 <Cale> and see where it has problems
17:59:27 <Frederick> hi cale are you around?
17:59:27 <lispy> perhaps, but i'd say just grab a fresh copy ;)
17:59:38 <Cale> Frederick: yeah
17:59:55 <Frederick> I got my first category theory class :(
18:00:56 <edwardk> frederick: thats usually not cause for a frown =/
18:01:16 <edwardk> or did they race ahead of you
18:01:34 <Frederick> the teacher sucks he created a "new branch" of the human knowledge
18:01:42 <edwardk> ?
18:01:48 <Cale> Who is your teacher?
18:02:12 <Frederick> his name?
18:02:12 <Cale> Usually having a prof that knows what they're talking about is a good thing :)
18:02:15 <Cale> yeah
18:02:24 <Cale> and what branch? :)
18:02:38 <Cale> Is it MacLane? :)
18:02:53 <edwardk> maclane died last year
18:02:56 <Frederick> Cale, not so lucky
18:03:00 <edwardk> he'd be a little hard to learn from now =)
18:03:06 <Cale> yeah
18:03:29 <Cale> Oh, right, he died just last year.
18:03:33 <eivuokko> lispy, Dunno about #ifdeffing ByteString..seems a lot of work. :-)  And no, I am just interested darcs just so far I can get it working in Windows.
18:03:39 <Cale> that's too bad
18:04:07 <Frederick> I'm afraid of failing the class :/
18:04:17 <Cale> and you said that :)
18:04:22 <Cale> Frederick: hmm
18:04:34 <Cale> Frederick: It's moving really quickly?
18:07:12 <Cale> Frederick: Is there anything I can help with?
18:08:26 <Frederick> Cale, dunno I'm just putting it out
18:08:37 <Frederick> first class no way to fail so soon
18:08:53 <Frederick> I bough 2 notebooks one for copy in class than I make a clean version at home
18:10:10 <Cale> I never had the patience for that, but it would work well :)
18:11:13 <Cale> I got into the habit of using white paper for mathematics notes, because it looks nicer with all the diagrams and 2d notation. (and I don't have any problems writing in a straight line :)
18:11:49 <lispy> eivuokko: yeah, #ifdef'ing bytestring might be a lot of work, otoh, fps that darcs uses was the basis for fps aka bytestring so maybe just need a small compatibily wrapper...then when compiled with ghc 6.6 you'd get a performance boost
18:12:33 <eivuokko> lispy, Yeah.  But I think the interface has changed quite a bit
18:12:38 <lispy> i write my notes, throw them away and then try to reconstruct the knowledge when i studied/homeworked
18:12:49 <lispy> worked okay for me
18:13:16 <lispy> eivuokko: yeah, but it's bad for darcs to have it's own, antiquated, half-optimized version of fps
18:13:42 <lispy> eivuokko: at the least, darcs's copy of fps should get updated to current bytestring
18:13:48 <eivuokko> Heh
18:14:17 <lispy> half-optimized is of course another way of saying, half-fasted...
18:14:20 <lispy> which sounds like...
18:14:54 <eivuokko> half-sped? ;)
18:15:04 <lispy> BTW, i never litterally through, them away, just didn't look at them until i was done
18:15:24 <lispy> threw not through...geez, hooked on phonics here
18:18:04 <lispy> openfile        :: String -> String
18:18:06 <lispy> openfile f       = primFopen f (error ("can't open file "++f)) id
18:18:17 <lispy> interesting that openfile didn't used to return an IO value
18:18:40 <lispy> and yet, that version of the prelude did have monads
18:19:18 <Cale> But IO wasn't a monad yet
18:20:23 <lispy> what was it?
18:20:30 <lispy> how did you keep things sequenced?
18:20:47 <Cale> I think they just used continuation passing style.
18:21:15 <Cale> Though in that case, that looks odd
18:21:36 <lispy> http://www.cse.unsw.edu.au/~dons/data/cc.prelude
18:21:47 <lispy> (in case you want to have a look for yourself)
18:22:30 <lispy> primitive primFopen "primFopen" :: String -> a -> (String -> a) -> a
18:22:36 <lispy> that looks very similar to foreign
18:22:59 <Cale> oh, looks like that openfile is cheating somewhat
18:23:19 <Cale> Is it exported?
18:23:39 <Cale> hmm
18:23:59 <Cale> readFile is a better example of how things were done
18:32:55 <edwardk> cale: talking about pre-IO io in haskell?
18:33:01 <Cale> yes
18:33:13 <Cale> gofer actually
18:33:14 <edwardk> wasn't that throguh [Request] -> [Response] streams
18:33:15 <edwardk> ?
18:33:28 <tennin> [Response] -> [Request]
18:33:33 <edwardk> yeah
18:33:48 <Cale> yeah
18:33:52 <edwardk> kk
18:34:19 <edwardk> heh. we should use the OI comonad for io, really stop the newbies cold =)
18:34:25 <Cale> hehe
18:34:39 <Cale> Actually, that's been shown dangerous
18:34:45 <edwardk> no more 'how can i get rid of the IO around this object'
18:34:48 <edwardk> yeah, no linear types
18:34:52 <tennin> is there still a use for that sort of thing?
18:34:58 <Cale> Comonads?
18:35:13 <Cale> There must be uses :)
18:35:30 <Cale> I think it just hasn't been thoroughly explored yet.
18:35:37 <edwardk> tennin: i now three or four useful comonads, but thats about it
18:35:39 <edwardk> er know
18:35:42 <stepcut> http://cs.ioc.ee/~tarmo/papers/essence.pdf
18:35:45 <tennin> no, for the pre-monadic IO style
18:36:32 <edwardk> just as views of equivalent systems
18:36:34 <stepcut> those people are arguing in that paper and another one that many uses of Arrows might be better done with comonads
18:36:41 <edwardk> so we don't start thinking of monads as critical for IO
18:36:52 <tennin> I was thinking  IO restricted to a specific request ADT might be appropriate in some situations
18:36:53 <edwardk> stepcut: yeah, its a decent paper
18:37:03 <Cale> edwardk: however, monads sure do make IO elegant :)
18:37:15 <edwardk> stepcut: dataflow is one of those four i mentioned =)
18:37:57 <stepcut> edwardk: I would like to understand it better, and then try implementing one of those functional reactive programming GUI things using comonads
18:38:01 <edwardk> cale: yeah, but, IO is pretty much just used as the generic closet in which we dump all our dirty laundry.
18:38:34 <edwardk> step: hrmm, that should be doable for most cases
18:38:48 <SamB> okay, my RML program seems to break all the objects in the Games and Amusements Exhibit room, as desired...
18:38:57 <edwardk> but watch out for OI-style unsafety problem
18:39:04 <Cale> Well, that's because it's stupidly general, but which dirty laundry? :)
18:39:10 <edwardk> problem/problems
18:39:37 <stepcut> edwardk: ok
18:39:40 <SamB> but somehow it still does not *work*
18:39:53 <edwardk> well right now IO is basically a grab bag of imperative junk =)
18:40:10 <Cale> What do you think should be separated from it?
18:40:10 <monochrom> imperative treasure
18:40:22 <Cale> hehe
18:40:37 <edwardk> you have references, mutable arrays, etc. file io, etc. that really in many cases are largely unrelated
18:41:02 <edwardk> not sure. but perhaps more of it should be tied into dictionaries that io instances, so you can delegate a subset of those options to a function
18:41:02 <monochrom> Yes that's true
18:41:04 <SamB> well... the trouble is the *safe* way is *far too safe*
18:41:10 <dons> well, the infinite tower of monads you'd need to write a real program (i.e. lambdabot) can get a bit hairy. i'd hate to put that on beginners
18:41:14 <SamB> i.e. it is too hard to extract the treasure from ST
18:41:53 <dons> i can imagine many uses for a more precisely typed IO system, IOW, IOS, IOR etc.. you just wouldn't want it as the defautl
18:42:19 <Cale> We possibly need more automatic ways to combine monads.
18:42:27 <edwardk> dons: i agree, i would just like to be able to say here i will allow this function to create references, etc. without giving it a full fledged IO
18:42:33 <dons> that's one of the biggest unsolved problems, I think, Cale.
18:42:43 <SamB> Cale: oh no, not like CLOS!
18:42:48 <edwardk> coz once you have broken IO apart you might find more reordering options, etc.
18:42:57 <Cale> The problem with combining monads is that in general, monads are too general of a structure.
18:43:31 <Cale> So if you take two monads and ask "how do I combine these into one", there might be several answers, or nothing obvious.
18:44:26 <Cale> Perhaps there are some axioms/operations which most monads we'd like to use would satisfy, but which would make it easier to combine things.
18:44:46 <edwardk> cale: didn't wadler write a paper covering 3 or so of those?
18:45:03 <edwardk> and group some distinct groups of monads that way?
18:45:08 <edwardk> er and form some..
18:45:25 <Cale> hmm
18:45:44 <Cale> which paper?
18:45:51 <edwardk> lemme dig for it
18:46:18 <edwardk> i think it was 'combining monads'
18:46:42 <edwardk> look at section 7, "from the Boom hierarchy to a monad hierarchy"
18:47:15 <dons> it would be interesting to code up a little partitioned IO library for people to try
18:47:39 <dons> something that, I guess at first, just partitioned readers from writers, and then moved on to other things
18:47:58 <edwardk> yeah
18:48:03 <dons> since I can think of times i'd like a static guarantee that some code writes nothing
18:48:11 <dons> or never touches files (only stdin,stdout)
18:48:30 <edwardk> splitting apart reading would be nice, because a lot of that can be reordered, etc, not that monads are easy to do that in
18:48:37 <dons> wouldn't be too hard to start newtyping things, and wrapping existing IO into more structured types
18:50:18 <Cale> edwardk: he gives some general constructions there, but not of the sort which you'd want for partitioning IO
18:50:35 <edwardk> cale: yeah, i was remembering the paper only vaguely
18:50:53 <Cale> He only does 3 specific compositions
18:51:18 <edwardk> cale: as  recall this was the first thing written on monad combination really, so thats probably to be expected.
18:51:23 <Cale> at least one of which can't be made an instance of monad
18:51:30 <Cale> of Monad, sorry :)
18:51:37 <edwardk> which one?
18:51:44 <Cale> Sets
18:52:03 <Cale> because Ord or at least Eq is required
18:52:13 <edwardk> ah
18:52:31 <Cale> I think you'd have the same problem with bags
18:53:39 <edwardk> times like that when i wish you could re-use the monad sugar in more limited contexts, like i want with arrows at times.
18:54:08 <Cale> Well, the problem is really with the class system
18:54:14 <edwardk> yeah
18:54:23 <Cale> and it's not an easy one to solve either
18:54:46 <dons> ?users
18:54:48 <edwardk> no good way to covariantly subtype Monad to obtain a restricted form of it
18:54:48 <lambdabot> Maximum users seen in #haskell: 235, currently: 192
18:56:31 <Kahdloc> hmm, quite a drop in population
18:56:46 <Cale> Well, the problem is that you could, for instance, have a function with type (Monad m) => m Integer -> m Integer, but which in the course of its operation, uses things of type m (Integer -> Integer)
18:56:59 <Cale> It wouldn't work with m = Set
18:57:12 <Cale> but from its outward type, it looks like it should
18:57:16 <edwardk> cale: yeah i understand,same probem came up with using arrows to represent pipes.
18:57:34 <SamB>       fun read(acc : string, rest : itemlist) : string =
18:57:34 <SamB>         case rest of
18:57:34 <SamB>           SomeItems { item', rest' } => [
18:57:34 <SamB>             let x = condition_to_int(item_condition(item')).
18:57:34 <SamB> 	    case x = 0 of
18:57:35 <SamB>               True { } => return acc
18:57:35 <edwardk> i needed everything i could pure/arr into an arrow to be an instance of Show and Read
18:57:39 <SamB>             | False { } => return read(acc ^ string_fromchar(x), rest')
18:57:41 <SamB> 	  ]
18:57:43 <SamB> 	| NoItems { } => return acc.
18:57:45 <SamB> oh, ack
18:57:47 <SamB> tabs.
18:57:47 <edwardk> samb: whoa
18:57:49 <SamB> hate them!
18:58:16 <Kahdloc> SamB....pastebot or something
18:58:24 <SamB> yeah.
18:58:26 <SamB> okay...
18:58:56 <SamB> @paste
18:58:56 <lambdabot> http://paste.lisp.org/new/haskell
18:59:03 <dons> Kahdloc: oh, re. the population, it flucutates over 24 and 7 day cycles
18:59:14 <dons> currently, its day time in australia, evening US, we usually have around 195 or so
18:59:34 <dons> midday europe, on a monday or tuesday, we can get quite high, up to the 220+
18:59:52 <edwardk> er rather every arrow head pointed to an instance of Show and every arrow tail pointed to an instance of Read. the category is well defined, the properties of objects in it are well defined. it could even be desugared if the sugaring was defined differenty, its just not implementable with ghc's arrow sugar.
19:00:51 <lisppaste2> SamB pasted "unsuccessful attempt to bypass Censory Engine" at http://paste.lisp.org/display/24205
19:02:30 <SamB> does anyone have any clue why this returns an empty string, even though it messes with the objects in the "Games and Amusements Exhibit"?
19:02:57 <dons> oh, you're hacking away on the adventure game?
19:03:22 <dons> hehe
19:04:38 <monochrom> Haha Censory Engine
19:05:05 <monochrom> Godawful, what is this, OCaml?
19:05:28 <SamB> monochrom: worse!
19:05:29 <SamB> RML!
19:05:39 <SamB> dons: yes!
19:05:50 <monochrom> At least it has pattern matching.
19:06:03 <SamB> before, it didn't even mess with the objects, and it was a stupid error
19:06:06 <monochrom> and nested functions
19:06:14 <SamB> I forgot to call read' at the bottem of read
19:06:28 <SamB> er, s/read/write/
19:06:47 <SamB> forgot to call *write'* at the bottom of write
19:07:22 <monochrom> Do you know how godawful it is the 21st Century already and 2 out of 3 mainstream languages don't have nested functions, and the remaining 1 has it but only by way of an even more godawful construct?
19:08:23 <SamB> it should be evident that I am trying to encode a pieces of a string by encoding the characters as naturals and setting the conditions of items to those naturals...
19:08:37 <SamB> the problem is that it doesn't decode them correctly...
19:10:37 <SamB> >: break manual
19:10:46 <SamB> You speak the words "" aloud, but there is no one around to hear
19:10:46 <SamB> them.
19:11:27 <SamB> I don't suppose that actually works if you switch the goggles first?
19:12:17 <SamB> would you believe I wrote a lint program just because one of my cases needed [] around it?
19:13:09 <monochrom> I believe you.
19:21:53 <SamB> and apparantly not all the "do" statements have expressions returning no value!
19:22:04 <SamB> my lint was originally a bit overzealous
19:23:01 <dons> ?remember monochrom Do you know how godawful it is the 21st Century already and 2 out of 3 mainstream languages don't have nested functions, and the remaining 1 has it but only by way of an even more godawful construct?
19:23:02 <lambdabot> Done.
19:23:12 <dons> monochrom: what 3 mainstream languages are you thinking of?
19:23:16 <dons> C, C++, Java?
19:23:20 <monochrom> Yes
19:23:35 <dons> its a nice quote. expect to see something in the HWN ;)
19:23:46 <monochrom> Whee!  I'll be famous!
19:23:52 <dons> in case anyone hasn't noticed, @remember strings are used to populate the HWN quotes archive
19:23:58 <SamB> dons: did I do anything really stupid?
19:24:00 <dons> so if you see something good, @remember it.
19:24:13 <dons> SamB? maybe, you tell me.
19:24:13 <monochrom> The recent issue has very funny quotes :)
19:24:25 <SamB> don't we already do that just for our own enjoyment?
19:24:29 <SamB> @remember
19:24:29 <dons> monochrom: hah. I thought so too. in fact, I get email from SPJ saying "very good quotes" :)
19:24:29 <lambdabot> Incorrect arguments to quote
19:24:36 <SamB> @quote
19:24:36 <lambdabot> lambdabot says: tERmIN473d
19:24:38 * SamB is tired
19:24:48 <dons> we use @remember for our own fun yes.
19:24:56 <SamB> maybe 'cause I just started on 40mg of adderall today
19:24:56 <dons> but I also use it to generate the HWN
19:25:15 <SamB> @quote
19:25:15 <lambdabot> malcolm says: Most software doesn't need to be fast.  But all software needs a fighting chance of correctness
19:25:24 <SamB> @quote
19:25:24 <lambdabot> darius says: Well profiling does add a bit of reflection, but it should have the good sense not too go near the barbed wire fences and armed guards.
19:25:36 <SamB> heh
19:26:00 <dons> so, I guess my point is: be sure to @remember stuff thats good, that is spoken while i'm asleep ;)
19:26:06 <SamB> hehe
19:27:01 <lispy> @quote
19:27:02 <lambdabot> Cale says: They're using continental drift as a means of communication.
19:27:28 * SamB wonders about the context of that one
19:27:44 <SamB> it would be cool if there was a tool to find the context of a @quote in the logs ;-)
19:28:05 <dons> sounds like a job for ... SamB-Man!
19:28:10 <SamB> oh man
19:28:23 <SamB> every time I say "it would be cool" you want me to do it myself!
19:28:26 <dons> faster than a typing monkey, more powerful than a linux cluster!
19:28:40 <dons> funny that ;)
19:28:50 <lispy> jumps over a typo in a single bound
19:29:04 <dons> why is it every time someone thinks up something cool, they want _me_ to write it..
19:29:19 <lispy> you're good at implementing stuff
19:29:31 <dons> :P
19:29:47 <SamB> dons: maybe you already know of a tool
19:29:52 <lispy> the problem with me is that my todo list is unidirectional
19:29:55 <SamB> who told you of that other tool?
19:30:04 <dons> hmm?
19:30:10 <SamB> the one for the log stats
19:30:20 <dons> I mean... lambdabot does have both the full logs and the full quotes... so it _could_ be done
19:30:23 <dons> SamB: oh, dylan
19:30:42 <SamB> does dylan know of a tool for finding things people said?
19:30:45 <dons> one thing someone should hack up is annotated @karma
19:30:59 <dons> i..e. @karma+ SamB -- good ideas
19:31:00 <SamB> such as @remember so-and-so such-and-such
19:31:22 <SamB> (nevermind *who* said it, or in what channel)
19:31:28 <dons> oh. google?
19:31:37 <SamB> hmm
19:31:50 <lispy> dons: i'm thinking i should port lambdabot to windows tonight. think it's a big job?
19:31:51 <SamB> well it would be a channel that lambdabot was in
19:32:12 <dons> lispy: no, I think its highly doable. Cale had it working a year or two ago
19:32:16 <dons> and ndm is interested too
19:32:20 <SamB> @google "They're using continental drift as a means of communication."
19:32:23 <lambdabot> http://tunes.org/~nef/logs/haskell/06.07.31
19:32:26 <dylan> what about me?
19:32:27 <dons> SamB: ok. so we take the State/Logs/freenode/ subdir then
19:32:36 <dons> SamB: heh, google wins
19:32:54 <SamB> so I suppose that works well for the original ones
19:33:01 <SamB> and unoriginal ones who cares anyway?
19:33:12 <lispy> dons: what version of ghc should i use?
19:33:15 <lispy> will it matter...
19:33:32 <dons> lispy: >= 6.4.1
19:33:38 <SamB> oooh, I like.
19:33:41 <dons> manzano$ grep "They're using continental drift as a means of communication." */*
19:33:44 <dons> #haskell/2006-08-01.txt:06:30:04 <Cale> They're using continental drift as a means of communication.
19:33:47 <dons> manzano$ pwd
19:33:50 <dons> /home/dons/lambdabot/State/Log/chat.freenode.net
19:33:53 <SamB> apparantly that is how we are going to find out who won the ICFP ;-)
19:34:12 <dons> hmm..? by looking for people announcing their points?
19:34:22 <SamB> no
19:34:26 <SamB> continental drift
19:34:28 <dons> ah
19:34:31 <SamB> as a communication mechanism
19:34:32 * dylan has log files seperated by day, and a tool to insert them into postgres. :)
19:34:39 <dons> oh, that's a nice idea.
19:34:44 <dons> what then do you do with the db?
19:35:00 <SamB> @quote
19:35:00 <lambdabot> ChristopherHendrie says: Sometimes I wonder if Java will be indirectly responsible for hastening the adoption of functional programming languages
19:35:08 <dylan> refresh my memory on conversations with friends
19:35:19 <Cale> dons: think about it, you've implemented hs-plugins and yi, both of which are things which everyone seemed to want, but nobody but you was willing to actually implement :)
19:35:31 <SamB> @quote
19:35:31 <lambdabot> sethk says: it's certainly true that you can clobber the stack in C without even getting out of bed in the morning
19:35:32 <edwardk> cale: hehe
19:35:40 <SamB> heh
19:35:42 <dons> ah. oh, I wrote a script to convert daily logs to graphs, via pisg, you might be interested, dylan? (these graphs: http://www.cse.unsw.edu.au/~dons/irc/)
19:35:43 <lambdabot> Title: Haskell IRC Activity
19:35:55 <SamB> @quote
19:35:55 <lambdabot> Failure02 says: in haskell you can have korean smilies as variables! like (^-^)
19:36:06 <dons> Cale: ok. what else do we need then?
19:36:19 <edwardk> woohoo: i keep climbing the rankings about one slot per day =)
19:36:27 <dons> cabal-get... ?
19:36:29 <edwardk> er every other day i guess
19:36:31 <dons> hackage.
19:36:38 <dons> a haskell window manager..
19:36:39 <lispy> dons: test case coverage tools...i had an idea how to implement it
19:36:41 <edwardk> soon i will out-chat ndm...
19:36:45 <edwardk> not sure this is a good thing
19:36:51 <dons> lispy: oh, you're too late. have you looked at hpc?
19:36:53 <dons> ?where hpc
19:36:54 <lambdabot> http://www.galois.com/~andy/hpc-intro.html
19:36:56 <Cale> dons: hehe, yeah, a Haskell WM which is extensible with hs-plugins :)
19:37:09 <dons> well, i think i'd go for ghc-api these days
19:37:09 <SamB> eh, I like:
19:37:11 <SamB> Tim Toady : "Learning Haskell itself is easy -- I've done it several times already"
19:37:13 <lispy> dons: i'd be happy to use a pre-built :) (checking it out)
19:37:21 <dylan> dons: that's pretty neat
19:37:28 <SamB> but I thought his name was Larry Wall
19:37:32 <SamB> or Walls
19:37:50 <lispy> sweet
19:37:51 <dons> dylan: it grabs the nick and line totals out of pisg stat files, and gnuplots them
19:37:58 <lispy> dons: this is excatly what i wanted
19:37:59 <SamB> dons: isn't his name Larry?
19:38:07 <LordBrain> what is the return and bind for (->) ?
19:38:20 <LordBrain> where do i find that?
19:38:23 <SamB> isn't it S and K?
19:38:25 <dons>     return = const
19:38:25 <dons>     f >>= k = \ r -> k (f r) r
19:38:47 <lispy> dons: i want to run that tool against darcs with its massive test suite...to prove that the test suite is horribly inadequate for its size
19:38:57 <dons> lispy: that would be really really cool
19:39:19 <dons> it is inadequate. darcs is way bigger than fps, and fps has 3k QC properties (and still doesn't cover everything..)
19:39:32 <edwardk> yowsa
19:39:49 <edwardk> thats a lot of invariants =)
19:39:51 <lispy> dons: that's awesome tho, with something like fps we really need to be able to trust it
19:40:00 <SamB> dons: you don't actually make any attempt to figure out people's real names, do you?
19:40:00 <dons> yeah
19:40:09 <dons> SamB: in the logs?
19:40:16 <SamB> in the HWN quotes
19:40:18 <dons> edwardk: yeah, the list api has many many properties that hold
19:40:25 <dons> SamB: sometimes, if I know them already
19:40:28 <lispy> dons: here is another tool we want, a way to specify tests for 'quality' constraints...like "property x should take less than 3 seconds while using 100mb of ram max"
19:40:41 <dons> lispy: that would be a cool extension to HUnit, perhaps?
19:40:43 <SamB> dons: didn't you know that Tim Toady is not a real name?
19:40:46 <edwardk> dons: it makes sense, just 'whoa' =)
19:40:54 <dylan> dons: I must confess, I also use logs to make megahals of various people/groups. XD
19:40:56 <dons> SamB: actually, I suspected that after I published
19:41:12 <lispy> dylan: do you have a haskell version of megahal?
19:41:14 <dons> dylan: oh! good. we used to have a megahal called MegaMonad
19:41:15 <SamB> it sounds like TIMTOWTDI
19:41:19 <dylan> lispy: sadly, no
19:41:21 <lispy> dylan: if so i'd like to lambdabot it
19:41:25 <SamB> it is, iirc, an alias of perl's creator
19:41:40 <dons> SamB: ah.
19:41:44 <SamB> who's name is Larry Wall
19:41:49 <dons> very interesting.
19:41:52 <edwardk> heh i wrote one of those. hadn't heard the name before. used to call my megahal irc bot 'doppelganger' =)
19:42:15 <lispy> i have a wrapper in lisp around the megahal binary, but it crashes a lot
19:42:17 <dons> SamB: yes, rings a bell now. I remember audreyt telling us that quote, I think
19:42:23 <lispy> so a reimplementation in haskell would rock
19:42:45 <dylan> I sometimes let a megahal filled with everything I've ever said on IRC/AIM/Jabber impersonate me on AIM.
19:42:52 <lispy> but i lack the patiences to convert the C source to haskell and i lack the understanding to write a HMM library
19:42:53 <dons> hehe
19:42:56 <Cale> dylan: haha
19:42:58 <dons> that's cool dylan
19:43:03 <dylan> The C source for megahal is insane
19:43:03 <dons> ?google MegaMonad
19:43:06 <lambdabot> http://haskell.org/hawiki/MegaMonad
19:43:06 <lambdabot> Title: MegaMonad - The Haskell Wiki
19:43:20 <lispy> dylan: yeah, all those statics and globals makes my mind hurt
19:43:22 <dylan> I seem to remember it has two huge functions.
19:43:25 <dons> its really an ideal problem for Haskell, though. all that parsing and symbolic hacking
19:43:47 <dylan> it's just a double-ended markov chain, isn't it?
19:43:57 <lispy> dons: yes, words would do half of what the C version does :)
19:43:58 <dons> yeah, how hard can it be?
19:44:16 <lispy> dylan: yes, but i don't understand markov chains and lack a good reference that i understand :)
19:44:37 <lispy> oh there is also a response ranking algorithm
19:44:37 <dylan> funniest thing a megahal ever said to me was "I am not the lord of the spirits of the unix system"
19:44:40 <lispy> well, heuristic
19:44:46 <dons> i've got the 'sausage dog' textbook by pike, with 4 or 5 10 line markov chain impls. in them. so surely not too hard.
19:44:48 <lispy> nice
19:45:38 <lispy> i guess i'm just a weenie
19:45:39 <syntaxfree> "Philosophical" question: I'm finding myself tempted to model mathematical domains of knowledge in Haskell directly.
19:45:53 <dons> syntaxfree: sounds reasonable
19:45:57 <lispy> i had spec'd about 60% of the C source out into pseudo code at one point
19:45:58 <monochrom> Please don't.
19:46:01 <syntaxfree> How appropriate/inappropriate is that?
19:46:40 <syntaxfree> Well, specifics. Usually game-theoretical software is implemented using trees.
19:46:41 <dons> syntaxfree: we have other math libs, so seems reasonable to me. its a bit vague though, the question. what kind of math?
19:46:52 <monochrom> You can encode some of the types, e.g., "Ring" as a type class.  But you can't encode the theorems.
19:47:17 <syntaxfree> I find  myself tempted to write axiomatic definitions of "game", "strategy", etc. as types.
19:47:17 <lispy> in fact, ring is mostly there
19:47:20 <lispy> see Num
19:47:38 <dons> monochrom: well, you could encode the theorems. just might end up with more type hackery than you hoped.
19:48:05 <SamB> @quote
19:48:05 <lambdabot> darius says: Well profiling does add a bit of reflection, but it should have the good sense not too go near the barbed wire fences and armed guards.
19:48:08 <syntaxfree> recursive types are already some kind of "behaviour" on types.
19:48:19 <monochrom> God help you.
19:48:43 <syntaxfree> I wonder why it is verboten to add more behaviour.
19:48:56 <dons> syntaxfree: hmm?
19:49:17 <dons> type hackery is the #1 area of research in haskell ;)
19:49:21 <syntaxfree> (for instance, Data PositiveInt =  PI (Int x (where x>0)
19:49:24 <syntaxfree> )
19:49:43 <dons> you can do that, if you want
19:49:47 <syntaxfree> so an error can then be raised if someone tries to PI -3
19:49:53 <lispy> oh to do that currently you need a module, only export what you have to and use a "smart constructor"
19:49:54 <syntaxfree> oh. I can?
19:50:00 <dons> not directly as a dependent type, but its one of the easier type tricks to encode
19:50:08 * dons finds a ref
19:50:28 <SamB> dons: what?
19:50:34 <SamB> you must be confused
19:50:35 <dons> ?wiki Smart_constructors
19:50:36 <lambdabot> http://www.haskell.org/haskellwiki/Smart_constructors
19:50:46 <dons> ?wiki Type_arithmetic
19:50:46 <lambdabot> http://www.haskell.org/haskellwiki/Type_arithmetic
19:50:51 <SamB> oh, thats not a type trick anymore if you use a smart constructor
19:51:03 <dons> the above article includes a type version as well
19:51:12 <dons> using an Olegism
19:51:14 <SamB> oh, smart constructors -- they come free with views?
19:51:19 <monochrom> on this side of the river, runtime checks are not considered types, no matter what the Java side says :)
19:51:51 <dons> certainly not.
19:51:54 <syntaxfree> um, wait, wait. Will that work in Haskell 98, and will that work in plain GHC (or GHC with some extra modules)?
19:51:59 <dons> sure
19:52:16 <syntaxfree> OH. Smart constructors are functions. Smart!
19:52:18 <dons> some tricks need overlapping instances, but they've been around for about hmm, 11 years?
19:52:35 <dons> since Oct 1998, actualy
19:52:36 <SamB> certainly not?
19:52:50 <SamB> I mean can't you get smart constructors with *uppercase* names, in the presence of views?
19:53:02 <dons> SamB: ??
19:53:27 <dons> oh, that was in ref to monochrom's remark
19:54:05 <lispy> i was reading the paper on views, but i didn't really get it
19:54:11 <dons> ?quote lennart
19:54:12 <lambdabot> lennart hasn't said anything memorable
19:54:13 <dons> ?quote lennart
19:54:13 <lambdabot> lennart hasn't said anything memorable
19:54:15 <dons> grr
19:54:16 <syntaxfree> dons: that's clever. I wish I had thought of that.
19:54:50 <dons> ah,
19:54:51 <dons> ?quote augustss
19:54:52 <lambdabot>  hbc still has some unique features, like views.  that i've never used..
19:55:46 <newsham> I need to read in an XML document, iterate over it, make some changes, and write it out.   The document is very large.  will any of the haskell xml libs let me process the file lazily so that only a small part of it is in memory at any given time?
19:56:06 <newsham> without writing the code as some sorta silly stream-processing parser?
19:56:17 <lispy> newsham: HaXml is lazy, i verified this the other day with at least one of their parsers
19:56:30 <newsham> perfect.  i'll start digging there.  thanks.
19:56:36 <monochrom> I have doubt.
19:56:49 <lispy> newsham: i used dtd2haskell and then used the parser for the dtd2haskell generated code...may behave differently than their standard xml parser
19:56:57 <newsham> in general, how does laziness interact with IO monads?
19:57:08 <monochrom> they interact ok.
19:57:14 <SamB> dons: maybe you should WHOIS quoted people who are connected when you try to figure out people's real names/
19:57:17 <lispy> newsham: IO monad is basically strict, but some IO primitives are lazy
19:57:19 <SamB> s|/|?|
19:57:24 <monochrom> The real problem is if you use Parsec you're strict.
19:57:28 <newsham> lispy: how do I know which are which? :)
19:57:40 <monochrom> If you call readFile it's lazy.
19:57:40 <SamB> ooh, we talked about this recently
19:57:41 <lispy> newsham: good question, i usually ask an expert ;)
19:57:46 <syntaxfree> Haskell hackers often  make me feel like a complete idiot who shouldn't be allowed to vote or drive.
19:58:01 <monochrom> Then if you give the returned string to Parsec you stricten it
19:58:03 <newsham> lispy: got an url where I can download the expert from?
19:58:12 <monochrom> So really the IO monad is neutral.
19:58:20 <lispy> newsham: http://www.cse.unsw.edu.au/~dons/
19:58:20 <lambdabot> Title: Don Stewart
19:58:26 * lispy ;)
19:58:27 <syntaxfree> http://www.haskell.org/haskellwiki/Type_arithmetic
19:58:29 <lambdabot> Title: Type arithmetic - HaskellWiki
19:58:32 <syntaxfree> that's just brilliant.
19:58:35 <newsham> :)
19:58:49 <monochrom> And nobody listens to me because I don't prepend every sentence with newsham: lispy: everybody:
19:58:50 <SamB> lispy: heh
19:59:03 <SamB> the page *does* claim to be Don Stewart!
19:59:24 <lispy> monochrom: huh, did you say something? ;)
19:59:29 <monochrom> No.
19:59:38 <SamB> monochrom: hmm
19:59:47 <SamB> could you maybe talk about the solution?
19:59:50 <SamB> the problem is boring
19:59:56 <SamB> well, this part is anyway
20:00:00 <newsham> dons last updated: 2006-08-14
20:00:17 <SamB> I want to know how you are supposed to know if the parse is successful or not
20:00:35 <SamB> ohno! dons: you are stale!
20:00:40 <dons> yikes!
20:01:10 <monochrom> I don't actually know for sure how to do lazy parsing.
20:01:20 <SamB> monochrom: that is the part that hurts my head
20:01:52 <SamB> I keep thinking that some kind of exception mechanism would be nice, but I have no clue how it could be done without introducing undue strictness!
20:02:01 <newsham> I couldnt get dons to install, so I installed monochrome instead, but I couldnt figure out how to invoke it without an argument.
20:02:28 <SamB> hahahaha
20:02:43 <SamB> dons: you need to be cabalized!
20:04:24 <syntaxfree> the revolution will not be cabalized.
20:05:06 <lispy> my test the other day: read xml, write it back out.  Took max of ~25megs ram.  Second test, read the file in, did something strict (can't remember exactl what now) and saw max memory usage was ~150megs
20:05:30 <dons> lispy: hmm :( you want Parsec-ByteString?
20:05:42 <monochrom> I seem to have seen a lazy parser, but I am not sure.
20:05:42 <SamB> hmmhmmhmm!
20:05:50 <dons> [Char] is the root of all evil in the world
20:05:59 <lispy> dons: this is my evidence that haxml is lazy
20:06:18 <lispy> 25megs of ram is totally reasonable for my application
20:06:21 <lispy> it was a large spreadsheet
20:06:25 <dons> oh, ok. still though....
20:06:32 <SamB> lispy: so what happens with MAME's game list?
20:06:35 <lispy> yeah, you have a good point
20:06:40 <SamB> that was the real killer app!
20:06:46 <lispy> SamB: you're speaking greek!
20:07:10 <SamB> well, one of our number was trying to process MAME's game list with HXT
20:07:25 <SamB> maybe he already tried HaXml, not sure
20:07:26 <lispy> oh, so is HXT lazy?
20:07:30 <SamB> no!
20:07:33 <SamB> it is bad!
20:07:38 <SamB> it uses Parsec!
20:07:49 <lispy> well, it really should be strict for some reasons
20:07:49 <SamB> it also exports WAAAAAAAAY to much information
20:08:14 <monochrom> On the "Libraries and Tools" page, "Utrecht Parser Combinator Library" seems to be lazy.  It says, "parsing results become available on the fly without hanging on to the input"
20:08:15 <SamB> can you tell I'm only taking 40mg of adderal instead of 60?
20:08:19 <lispy> what if i'm trying to compute something, i get towards the end of the computation and the xml was malformed all along?
20:08:38 <lispy> heh
20:08:50 <SamB> lispy: you've saved yourself from swapping yourself to death?
20:09:19 <monochrom> If Haxml is lazy, I'd be damned.  A few months ago I checked it out and it used Parsec.
20:09:49 <newsham> damnations
20:09:49 <SamB> I thought it was HXT that used Parsec
20:10:17 <monochrom> HXT certainly does.  But I examined both Haxml and HXT several months ago.
20:11:13 <syntaxfree> "A few months ago I checked it out and it used Parsec."  .... "But I examined both Haxml and HXT several months ago."
20:11:25 <syntaxfree> Was it *a few* months ago or *several* months ago?
20:12:13 <monochrom> Both.
20:12:39 <lispy> monochrom: did you use the parser for dtd instances? that might explain the difference
20:12:55 <lispy> syntaxfree: haxml doesn't change very fast
20:13:18 <lispy> monochrom: also, maybe i need to re-run my test
20:13:18 <monochrom> No, I didn't.  That may explain the difference.
20:17:52 <lispy> now that i think about it, maybe in my test i generated the spreadsheet from a database and wrote it out
20:17:58 <lispy> maybe i wasn't read in xml after all
20:18:00 <lispy> now i'm curious
20:18:06 <lispy> i know my database library is lazy
20:18:11 <lispy> that's why i picked it
20:18:12 <monochrom> I am terribly sorry I made a mistake.  Haxml comes with its own parser combinator library and it doesn't have to behave like Parsec.
20:18:55 <lispy> i'm disappointed to hear Parsec is strict...
20:18:58 <SamB> I was pretty sure I had once thought it was nice that HXT used Parsec
20:19:01 <lispy> all this time i assumed it was lazy
20:19:21 <SamB> lispy: I dunno how it could be with such nice errors!
20:23:54 <newsham> hmm.. haxml uses configure/make not cabal?
20:24:09 <syntaxfree> Prolog is cool.
20:24:31 <syntaxfree> I wonder why there isn't code to read from corporate databases into Prolog.
20:24:45 <lispy> newsham: i use 1.13 at work and i use cabal with it
20:25:04 <lispy> @version
20:25:05 <lambdabot> lambdabot 4p63, GHC 6.5 (OpenBSD i386 )
20:25:05 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
20:26:26 <lisppaste2> magyar pasted "bind error" at http://paste.lisp.org/display/24206
20:26:49 <newsham> ahh, my bad, Setup.hs worked fine..  web page says to use configure/make though
20:29:31 <lispy> getting the lambdabot source now
20:30:16 <dons> lispy: what you'll be looking to do is remove the 'unix' dep from the .cabal file
20:30:23 <dons> and then see where things break, and fix them
20:30:48 <dons> currently, i use 'exitImmediately'. you'll need to find the win32 equivalent of that (or some workaround) and #if WINDOWS it in
20:37:39 <monochrom> I love arrows.  I would feel bad if HXT lost to HaXml.
20:39:53 <lispy> dons: hm...
20:42:33 <lispy> bleh, it's windows...i have no usable editors
20:44:03 <Korollary> emacs and vim run on windows
20:44:15 <lispy> yeah, but i don't have them for whatever reason
20:44:35 <lispy> dons: for the readline requirement, i need the haskell readline library?
20:45:00 <dons> yeah. I suppose we could work around that.
20:45:08 <dons> replace 'readline' with 'getLine' in the src, perhaps?
20:45:22 <lispy> i might as well use the real thing
20:45:24 <dons> (then there's no command line history and only basic editing, though)
20:46:05 <lispy> question is...where is the library at
20:46:07 <lispy> @where readline
20:46:08 <lambdabot> I know nothing about readline.
20:46:41 <sethk> dons, did you answer me earlier?  I have a blue tab which means someone used my name (but it could be just tab completion)
20:47:34 <lispy> why is my google-fu weak?
20:47:40 <lispy> @google haskell readline download
20:47:42 <lambdabot> http://www.haskell.org/ghc/download_ghc_641.html
20:47:42 <lambdabot> Title: GHC: Download version 6.4.1
20:48:36 <lispy> @doc Prelude
20:48:36 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
20:49:11 <lispy> oh hmm...readline is supposed to be packaged with ghc?
20:49:38 <sethk> in the same places as the earlier libc is packaged, I believe
20:51:43 <lispy> oh it is, but i'm accidentally using the ghc with visual haskell
20:53:46 <lispy> heh, now my cabal is too old
20:54:06 <lispy> dons: you should note, cabal with ghc-6.4.1 is too old to read lambdabot.cabal
20:58:41 <lisppaste2> magyar pasted "route" at http://paste.lisp.org/display/24212
20:59:50 <dons> magyar is posting to the wrong irc channel :/
21:08:45 <lispy> dons: http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
21:08:47 <lispy> er...
21:09:01 <dons> er?
21:09:15 <lispy> dons: Setup.hs: cannot satisfy dependency fps>=0.7
21:09:32 <lispy> dons: how should we deal with this...data.bytestring or fps?
21:09:54 <dons> hmmm? which compiler are you using?
21:10:02 <lispy> 6.4.1
21:10:15 <dons> so you install Data.ByteString/fps 0.7
21:10:52 <lispy> so just grab the latest version from here: ftp://ftp.cse.unsw.edu.au/pub/users/dons/fps/fps-0.7.tar.gz
21:10:56 <dons> yep
21:11:11 <lispy> easy enough :)
21:16:36 <lispy> oh weird
21:17:10 <lispy> dons: configure: creating ./config.status
21:17:11 <lispy> config.status: creating config.h
21:17:14 <lispy> rm: cannot remove directory `./confstatdY1924': Directory not empty
21:17:32 <lispy> this error is new to me
21:18:34 <lispy> ls -A shows no files in that dir
21:18:45 <dons> not seen that before.
21:18:51 <dons> possibly harmless
21:18:53 <BlurredWe> can somebody help a newbie out with a type error?  (is there a paste bin?)
21:18:57 <dons> ?paste
21:18:58 <lambdabot> http://paste.lisp.org/new/haskell
21:19:02 <dons> we live to serve
21:19:33 <lispy> dons: cygwin couldn't remove it, but windows explorer removed it just fine :(
21:19:55 <lisppaste2> BlurredWeasel pasted "type error" at http://paste.lisp.org/display/24213
21:20:34 <dons> fib2 (x - 1) + fib2 (x - 2) doesn't produce a list
21:20:37 <dons> maybe oyu mean ++ ?
21:20:50 <lispy> dons: it's on a linux server shared over samba...so maybe i need to move it to the ntfs partition...but this is very weird
21:21:28 <dons> BlurredWe: the code is a bit broken.
21:21:32 <BlurredWe> I know
21:21:39 <dons> your 'generator' in the list comprehension isn't a generator
21:21:44 <BlurredWe> I'm a very newbie
21:21:54 <BlurredWe> heh, that would explain why it breaks I guess
21:22:06 <logicfree> ummmm. are Prolog functors like cat theory functors?
21:22:06 <dons> here's one to ponder:
21:22:16 <dons> >  let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
21:22:18 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
21:22:47 <BlurredWe> what does 'in fibs' do?
21:22:51 <logicfree> there should be a HOF for co-recursion like that.
21:22:55 <dons> BlurredWe: also, using !! is an O(n) operation on a list. (not an array), so its not going to be good for complexity)
21:23:08 <dons> BlurredWe: oh, its just 'let' syntax: let x = e1 in e2
21:23:23 <logicfree> I actually wrote some HOFs for co-recursion some time ago, and put them in a very unpretentious Haskell tutorial some time ago.
21:23:23 <lispy> dons: heh, and now i moved it to the ntfs partition and i'm getting an error that it can't find the module 'Distribution.Simple'...windows is so weird
21:23:23 <dons> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
21:23:25 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
21:23:51 <logicfree> http://www.navarro.mus.br/diego/blog/2005/10/20/uma-introducao-ao-haskell-usando-cobras-autofagicas/
21:23:54 <lambdabot> Title: delta-bar-delta ¬ª uma introdu√ß√£o ao Haskell usando cobras autof√°gicas
21:24:42 <dons> > let fibs = 1 : 1 : [ x + y | (x,y) <- zip fibs (tail fibs) ] in fibs
21:24:43 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
21:24:55 <dons> BlurredWe: ^^^ perhaps?
21:25:08 <BlurredWe> dons, that is basically what I was looking for
21:25:20 <dons> notice that the thing on the RHS of the <- is a list
21:25:22 <BlurredWe> makes sense, since fibs + tail fibs are both lists
21:25:38 <BlurredWe> and zip combines the two with an offset of 1
21:25:49 <dons> > let fibs = 1 : 1 : [ x | x <- zipWith (+) fibs (tail fibs) ] -- another option
21:25:50 <lambdabot>  Parse error
21:25:56 <dons> > let fibs = 1 : 1 : [ x | x <- zipWith (+) fibs (tail fibs) ] in fibs -- another option
21:25:58 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
21:26:31 <wolverian> wait, isn't the list comprehension pretty useless there?
21:26:37 <co-recursive> @quote co-recursive
21:26:38 <dons> uh hu
21:26:38 <lambdabot> co-recursive hasn't said anything memorable
21:26:45 <dons> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
21:26:46 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
21:26:47 * co-recursive just registered the new nickname.
21:26:50 <dons> I think is to be preferred
21:26:55 <co-recursive> Lambdabot doesn't recognize me :(
21:26:59 <dons> syntaxfree, what's with all the nicks?
21:27:17 <co-recursive> I'm looking for a new nickname.
21:27:22 <Lemmih> You could also use parallel list comprehension.
21:27:23 <co-recursive> I think I like this one a lot.
21:27:35 <Lemmih> (if lambdabot wasn't so anal)
21:27:41 <dons> heh
21:27:46 <lispy> why would the file system make cabal give an error about unfound modules?
21:27:47 <dons> Lemmih: you know how to patch ;)
21:27:50 <lispy> this is so bizzare
21:28:01 <wolverian> oh, now I see you said the comprehensioneless version a screenful ago. so sorry. :)
21:28:18 <BlurredWe> dons, what does the 'fix $' part of that do?
21:28:27 <lispy> @hoogle fix
21:28:27 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
21:28:27 <lambdabot> Control.Monad.Fix :: module
21:28:27 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
21:28:31 <lispy> @hoogle ($)
21:28:33 <lambdabot> Did you mean: ($)
21:28:33 <lambdabot> Prelude.undefined :: a
21:28:33 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
21:28:39 <dons> fix is a recursion combinator. it takes a function and lets it call itself recursively
21:28:43 <dons> ?type fix
21:28:44 <lambdabot> forall a. (a -> a) -> a
21:28:44 <lispy> @type ($)
21:28:46 <lambdabot> forall b a. (a -> b) -> a -> b
21:28:59 <dons> and $ is just nice parenthesis-less application
21:29:07 * monochrom loves fix
21:29:18 <Lemmih> Those two types made absolutely no sense first time I saw them.
21:29:19 <dons> > fix (\fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)) -- same thing
21:29:20 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
21:29:26 <co-recursive> um. fix allows lambda functions to call themselves?
21:29:59 <dons> well, i was trying to explain it operationally. perhaps that was bad wording
21:30:06 <lispy> > fix id
21:30:06 <lambdabot>  Add a type signature
21:30:14 <dons> if in doubt, read the src:
21:30:14 <dons> fix :: (a -> a) -> a
21:30:15 <dons> fix f = let x = f x in x
21:30:18 <monochrom> "fix (\s -> True:s)" is another way of writing "let s = True:s in s"
21:30:56 <monochrom> QED
21:31:09 <BlurredWe> so monochrom, that'd be a list of 'True's?
21:31:13 <dons> > fix (1:)
21:31:14 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
21:31:14 <monochrom> Yes!
21:31:18 <dons> > fix (True:)
21:31:19 <lambdabot>  [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True,...
21:31:31 <BlurredWe> thanks for all your help guys, I'm sure I'll be back :)
21:31:42 <co-recursive> > or (fix (True:))
21:31:44 <lambdabot>  True
21:31:47 <co-recursive> !
21:31:49 <lispy> this is so weird
21:31:51 <monochrom> Anytime you use recursion, you could replace by fix, albeit less familiarly.
21:32:03 <co-recursive> > not (and (fix (True:)))
21:32:05 <lispy> any one else seen weird behavior with cabal on windows with different partitions?
21:32:07 <lambdabot> Terminated
21:32:14 <BlurredWe> thanks guys
21:32:23 <monochrom> "or" is a lazy bump, obviously :)
21:32:25 <co-recursive> "or" won't evaluate everything. smart!
21:32:43 <lispy> @type or
21:32:44 <lambdabot> [Bool] -> Bool
21:32:48 * monochrom is in a good mood
21:32:58 * monochrom looks for some music
21:33:27 * monochrom is a lazy bump. re-plays whatever is already on the playlist of his mp3 player.
21:33:39 <monochrom> lazy bump = smart!
21:33:41 <co-recursive> or a = if (not a) then False else or (cdr a)
21:33:56 <co-recursive> there has to be a better way to write that.
21:34:00 <lispy> co-recursive: it takes a list
21:34:05 <co-recursive> true.
21:34:08 <lispy> yeah, use pattern matching
21:34:21 <co-recursive> or a = if (not (car a)) then False else (or (cdr a))
21:34:21 <lispy> > or []
21:34:22 <lambdabot>  False
21:34:29 <lispy> or [] = False
21:34:40 <monochrom> or = fix (\f a -> if (not a) then False else f (tail a))
21:34:42 <co-recursive> or x:xs = or (not x : or xs)
21:34:43 <lispy> or (True:xs) = True
21:34:52 <lispy> or (_:xs) = or xs
21:35:10 <monochrom> to mock a mocking fix
21:36:04 <co-recursive> as homage, Haskell should define car = head and cdr =  tail
21:36:46 <SamB> how about car = truck and cdr = train?
21:37:02 <lispy> you're such a cdr
21:37:13 <johnnowak> co-recursive: just as long as it defines cadr, caadr, cadaadar, etc..
21:37:35 <co-recursive> hmm.
21:37:36 <SamB> how do you pronounce all those differently?
21:37:47 <SamB> especially the ones with multiple As?
21:37:53 <co-recursive> lemme think.
21:37:54 <johnnowak> "C A A D R"
21:38:14 <johnnowak> how do you pronounce x:xs?
21:38:22 <SamB> x
21:38:27 <SamB> xs
21:38:27 <lispy> x cons'd with exes
21:38:39 <dons> "ex cons exes" ?
21:38:48 <dons> or yeah
21:39:15 <co-recursive> parse ('C':xs) = parse xs
21:39:32 <co-recursive> parse ('A':xs) = tail . parse(xs)
21:39:47 <co-recursive> parse('D ':xs) = tail . (parse xs)
21:40:03 <co-recursive> parse('R':_) = id
21:40:09 <SamB> uh...
21:40:18 <SamB> you don't actually think that will work do you?
21:40:27 * johnnowak runs
21:40:36 <co-recursive> um. won't?
21:40:43 <lispy> does it type check?
21:40:50 <SamB> "cannot construct infinite type blah blah blah"
21:40:54 <co-recursive> well, the idea is to take a String and produce a function.
21:40:57 <lispy> that should be your first question with anything you do in haskell :)
21:41:19 <co-recursive> there's no "function" type.
21:41:23 <co-recursive> Blah!
21:41:24 <SamB> > let parse ('A':xs) = tail . parse(xs); parse('D ':xs) = tail . (parse xs)
21:41:25 <lambdabot>  Improperly terminated character constant
21:41:36 <SamB> > let parse ('A':xs) = tail . parse(xs); parse('D':xs) = tail . (parse xs)
21:41:37 <lambdabot>  Parse error
21:41:41 <SamB> hmm
21:41:47 <SamB> plus it don't parse ;-)
21:41:58 <co-recursive> parse :: String->([a]-> a)
21:42:22 <co-recursive> ahh. the problem is that strings that end in DR return lists, and strings that end in AR return values.
21:42:34 <dons> > case "head" of "head" -> head ; "last" -> last ; "index 2" -> (!! 2) $ [1..10]
21:42:35 <lambdabot>  add an instance declaration for (Num ([a] -> a))
21:42:35 <lambdabot>   In an arithmetic seque...
21:42:38 <co-recursive> that could be fixed stating that parse car l = [head l]
21:43:03 <dons> > (case "head" of "head" -> head ; "last" -> last) [1..10]
21:43:04 <lambdabot>  1
21:43:23 <SamB> I thought the problem was that depending how many As are in the string, you'd need a different number of []s in the type
21:43:35 <SamB> so you'd end up with it trying to construct an infinite type
21:43:36 <dons> yeah, better make sure the types all match..
21:43:47 <dons> or else you've got to encode an interpreter (or use dynamics)
21:43:50 <SamB> > let x = [x] in x
21:43:51 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
21:43:51 <lambdabot>    Expected...
21:44:32 <johnnowak> i-swear-this-is-kosher-just-do-it
21:44:45 <co-recursive> umm.
21:44:48 <co-recursive> CAAR.
21:44:52 <co-recursive> = CAR (CAR)
21:44:56 <co-recursive> yeah, you're right.
21:45:01 <SamB> yah!
21:45:07 <SamB> I know that!
21:45:07 <co-recursive> shit.
21:45:15 <co-recursive> ok. sorry for the curse word.
21:45:22 <SamB> heh
21:45:42 <SamB> I better go to bed...
21:45:46 <co-recursive> I don't usually use'em. When it blurts out it's a sign of Xtreme Frustration.
21:45:48 <SamB> my head hurts
21:45:54 <monochrom> "parse doesn't parse" is a very funny thing to say :)
21:46:05 * lispy has been listening to wesley willis had now has a very high tolerance for swear words ;)
21:46:15 <Korollary> I curse like a sailor
21:46:23 <emertens> anyone have some suggestions for making this function work better? URLs, papers, something?
21:46:25 <monochrom> I curse like a gentleman.
21:46:26 <emertens> 79: 79
21:46:28 <lispy> i sail like a cursor
21:46:29 <emertens> $ primes 1000000 | wc -l
21:46:31 <emertens> solve n = length $ filter (\x -> (x - n) `divides` (x * n)) [n+1..2*n]
21:46:33 <co-recursive> There was a song that said something like that.
21:46:33 <emertens> ^C
21:46:36 <emertens> $ factor 1000008
21:46:38 <emertens> err
21:46:39 <co-recursive> "Curse like a sailor drink like a mick"
21:46:41 <emertens> it finds the number of solutions for 1/x + 1/y = 1/n given n
21:47:11 <SamB> just solve it and count the solutions ;-)
21:47:37 <Korollary> well, I suppose you can avoid building a list by passing state around.
21:47:47 <monochrom> I swear like a gentleman and computer science theorist.
21:47:48 <SamB> or you could just use fusion!
21:47:59 <Korollary> Gillete Fusion!
21:48:07 <monochrom> Haha
21:48:09 <emertens> I thinkI really need ideas on a different way to approach the problem
21:48:16 <emertens> this brute force method isn't cutting it :)
21:48:26 <emertens> I'm just looking for suggestions on shit to read :)
21:48:30 <SamB> is that ocam's new razor?
21:49:11 <SamB> the Gillete Fusion?
21:49:43 * SamB wonders why nobody is throwing rotten tomatoes yet
21:49:48 <lispy> hm...does windows have a replacement for isRegularFile?  does it even need relpaced...i'm wondering if i could do #if WINDOWS isRegularFile = const True
21:50:20 <SamB> ... does it return true for directories?
21:51:02 <lispy> dunno, the documentation says only the type signature
21:51:47 <lispy> i'm starting to think i should do this tomorrow
21:51:49 <lispy> i'm pretty tired
21:52:09 <lispy> i wonder if the darcs source would have the solution to this
21:52:15 <lispy> they have to deal with win32 vs. posix
21:54:26 <dons> we should have very few posixisms though
21:54:35 <dons> lambdabot's been built and run on win32 before, after all
21:55:08 <lispy> i'm seeing it in Fortune.hs at the moment
21:55:30 <lispy> that module imports isRegularFile and getFileStatus
21:55:50 <lispy> -- | 'isFile' is a predicate wheter or not a given FilePath is a file.
21:55:51 <lispy> isFile :: FilePath -> IO Bool
21:55:52 <lispy> isFile = (isRegularFile `fmap`) . getFileStatus
21:56:01 <lispy> i guess really i just need a win32 version of isFile
21:56:21 <dons> its ok if not all plugins work out of the box
21:57:04 <lispy> not sure how i would disable one on just win32...so i'll dig a bit more...i'm not ready to give up, just think maybe i should sleep
21:57:10 <lispy> there is getFileType
21:57:20 <lispy> but no idea what a FileType represents...it's just a DWORD
21:58:15 <lispy> fILE_ATTRIBUTE_NORMAL :: FileAttributeOrFlag
21:59:34 <lispy> so i think i should use getFileAttributes and then check for fILE_ATTRIBUTE_NORMAL
21:59:38 <Korollary> I dont know enough about win32. But, could it be for symlinks, pipes vs regular files?
22:00:17 <lispy> Korollary: yeah, i think that's a file type and then file attribute tells you if it's a normal file
22:00:23 <lispy> and i think in this case we want normal file
22:02:14 <lispy> @hoogle Word32 -> Word32 -> Word32
22:02:15 <lambdabot> No matches, try a more general search
22:02:27 <lispy> @hoogle land
22:02:28 <lambdabot> Data.Graph.Inductive.Graphviz.Landscape :: Orient
22:02:28 <lambdabot> System.Win32.NLS.sUBLANG_SWEDISH_FINLAND :: SubLANGID
22:02:28 <lambdabot> System.Win32.NLS.lANG_ICELANDIC :: PrimaryLANGID
22:03:14 <lispy> i want the haskell equivalent of C's &
22:03:31 <lispy> @hoogle (&)
22:03:32 <lambdabot> Did you mean: (&)
22:03:32 <lambdabot> Prelude.undefined :: a
22:03:32 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
22:03:37 <lispy> @hoogle &
22:03:37 <Korollary> @index testBit
22:03:37 <lambdabot> Data.Graph.Inductive.Graph.(&) :: DynGraph gr => Context a b -> gr a b -> gr a b
22:03:38 <lambdabot> Prelude.(&&) :: Bool -> Bool -> Bool
22:03:38 <lambdabot> Control.Arrow.(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
22:03:38 <lambdabot> Data.Bits, Foreign
22:03:46 <Korollary> you need Data.Bits
22:03:54 <lispy> cool, thanks
22:03:58 <lispy> @doc Data.Bits
22:03:58 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
22:04:35 <lispy> > Data.Bits.(.&.) 15 7
22:04:36 <lambdabot>  Not in scope: data constructor `Data.Bits'
22:04:46 <lispy> > (.&.) 15 7
22:04:47 <lambdabot>  Add a type signature
22:04:52 <lispy> > (.&.) 15 7 :: Word32
22:04:53 <lambdabot>  7
22:05:02 <lispy> > (.&.) 0 7 :: Word32
22:05:03 <lambdabot>  0
22:05:57 <Korollary> "System.Win32.NLS.lANG_ICELANDIC". weird. Why is the l in lowercase?
22:06:38 <lispy> it's a constant
22:06:44 <lispy> imported by hsc2hs
22:09:40 <Cale> What I don't understand is why they made everything else uppercase still.
22:11:19 <dons> its like those mac vs pc advertisements. the win32 stuff just has to be a bit boring and stupid ;)
22:12:40 <Korollary> It's like a case reversal
22:12:56 <Korollary> > map toLower "lANG_ICELANDIC"
22:12:57 <lambdabot>  "lang_icelandic"
22:13:03 <Korollary> err
22:13:07 <Korollary> I am a genius
22:13:12 <Korollary> but you get the drift
22:13:16 <co-recursive> http://science.slashdot.org/article.pl?sid=06/08/16/0144202
22:13:17 <lambdabot> Title: Slashdot | Poincare Conjecture Proof Completed
22:13:23 <sieni> wanha!
22:13:35 <Korollary> And Perelman is AWOL.
22:13:54 <Korollary> 1000 pages.
22:14:01 <co-recursive> " Perelman now seems to be the favorite to receive a Fields Medal at the International Mathematics Union meeting next week, but it's not clear that he'll even show up!"
22:14:12 <lispy> whoa
22:14:19 <Korollary> He turned down a prize before
22:14:30 <sieni> probably not fields medal
22:14:59 <co-recursive> Now, *there's* a square peg in a round hole.
22:15:10 <Korollary> Feynman was against prizes. Maybe Perelman is, too.
22:15:31 <Korollary> I can have it if he doesnt want it. Chicks dig Fields Medals.
22:15:48 <lispy> Korollary: keep telling yourself that
22:15:55 <co-recursive> chicks dig Knuth t-shirts, it seems :)
22:16:01 <Korollary> lispy: My therapist tells me to stop, though.
22:16:13 <sieni> feynman didn't turn down nobel prize
22:16:14 * lispy grumbles about not being able to guess the right compiler define for detecting win32
22:16:27 <dons> ?remember Korollary [On Perelman going AWOL before the Fields Medal award] I can have it if he doesnt want it. Chicks dig Fields Medals
22:16:28 <lambdabot> Done.
22:16:47 <Korollary> sieni: He didn't. But, he was going to (iirc). I watched an interview of him where he was talking about it.
22:17:03 <lispy> darcs uses #ifdef WIN32 but that must be passed on the ghc commandline or something
22:17:12 <Korollary> http://video.google.com/videoplay?docid=6586235597476141009&q=feynman
22:17:13 <lambdabot> Title: The pleasure of finding things out - RP Feynman - Google Video
22:17:17 <sabren> #if !defined(mingw32_HOST_OS) && !defined(__MINGW32__)
22:17:18 <sabren> maybe?
22:17:27 <lispy> hmm...i'm using cygwin
22:17:44 <lispy> i'll still try it :)
22:18:00 <sabren> oh.. that's from System:Process:Internals for GHC
22:18:10 <sabren> er s/:/./
22:18:37 <Cale> Does darcs have a switch for letting you interactively resolve conflicts?
22:18:39 <Korollary> Perl'ism? That would have been ::, tho.
22:18:53 <lispy> Cale: the best you'll get is to use an external conflict tool
22:19:04 <sabren> korollary: nah, just an uplateism :)
22:19:11 <lispy> Cale: you tell darcs on the command line what tool youw ant to use, check the manual because i don't know the details :(
22:19:24 <co-recursive> ""7) Hemp produces more pulp per acre than timber on a sustainable basis, and can be used for every quality of paper. Hemp paper manufacturing can reduce wastewater contamination. Hemp's low lignin content reduces the need for acids used in pulping, and its creamy color lends itself to environmentally-friendly bleaching instead of harsh chlorine compounds. Less bleaching results in less dioxin and fewer chemical by-products."
22:19:27 <co-recursive> !
22:19:29 <lispy> sabren: that works
22:19:56 <lispy> but now it can't find System.Win32.File
22:20:00 <lispy> hmm...
22:20:11 <lispy> probably need to compile with -package Win32-1.0
22:20:21 <lispy> how do you get cabal to choose packages based on host os?
22:20:46 <sabren> :D
22:21:23 * sabren has exhausted his knowledge of compiling haskell
22:21:29 * lispy too
22:21:38 <Korollary> You can pray
22:22:14 <Korollary> Hmm
22:22:25 <Korollary> I think Bulat was asking a similar question on haskell-cafe
22:22:36 <Korollary> conditional cabal'izing
22:22:36 <lispy> oh yeah
22:22:43 * lispy checks gmail
22:23:18 * Korollary plugs his choice of free web based email provider, too.
22:23:24 <Korollary> wait. I use gmail, too.
22:23:45 <co-recursive> gmail is getting slow lately.
22:23:56 <Korollary> How did you measure it?
22:23:58 <co-recursive> The good thing about gmail is that it's easy to use it for storage and use something else for checking.
22:24:41 <lispy> hmm..looks like he never got an answer to part of his question
22:25:00 <lispy> Second question is how to test whether program compiles under Unix or
22:25:02 <lispy> Windows environment. Posix/Win32 packages availability would be the
22:25:03 <lispy> best criterion but it can't be tested :(
22:25:04 <co-recursive> I forward from an account on my own domain name to gmail. I check from my own server, I just leave gmail archiving stuff.
22:25:30 <co-recursive> there should be a minimal posix system you could ship with your program for Windows.
22:25:32 <lispy> yeah, i give out my own domain address and just read it in gmail and send from there with a custome reply-to
22:25:44 <co-recursive> Cygwin is just silly.
22:26:02 <co-recursive> lispy: well, I read from my own domain address pop3 server. Way faster.
22:26:02 <lispy> i think bulat is right about being able to test for package existence at compile time
22:26:11 <co-recursive> lispy: otoh, I often use gmail to find old messages.
22:26:45 <co-recursive> (before switching to a Mac I was reformatting the computer's HD very often, switching distributions and the like)
22:27:18 <co-recursive> it's nice that pretty much anything I'd ever want to show anyone is already on my gmail, since I probably emailed it to some place I can print.
22:27:39 <Korollary> gmail. The omnipresent trashcan.
22:27:41 <co-recursive> All my academic production, including the silly term papers from junior undergrad.
22:29:37 <co-recursive> gmail is an omnipresent archive for me.
22:30:16 <Korollary> You worded more kindly. I spoke more like a sailor.
22:30:37 <co-recursive> maybe I should write a script that emailed myself a darcs dist snapshot periodically.
22:30:48 <co-recursive> I've often needed Haskell code at work that was at home.
22:31:00 <Korollary> ssh tunneling?
22:31:12 <Korollary> oh, your computer is off while at work.
22:31:34 <co-recursive> yes. It's also behind this NAT thing that won't let any outside thing connect to a server at my computer.
22:32:02 <sabren> that's what web hosting is for :D
22:32:12 <Korollary> Yes. But gmail is free.
22:32:26 <co-recursive> My parents have web hosting, and I use it.
22:32:34 <Cale> co-recursive: you can usually configure such NAT things to forward ports
22:32:37 <co-recursive> Gmail is pretty much infinite, though.
22:32:42 <sabren> yeah
22:33:02 <co-recursive> Cale: I don't have any kind of access to the NAT thing and the support people are drones.
22:33:02 <Korollary> your haskell code can't reach gigabytes in size anyway. Otherwise, haskell is broken.
22:33:28 <sabren> is there a market for commercial darcs hosting?
22:33:48 <co-recursive> Basically there's this company that rents some kind of line, and runs a network in my building.
22:33:52 <lispy> hm...actually i added win32 as a build dep and it still fails
22:34:00 <co-recursive> It's dirt cheap.
22:34:41 <co-recursive> I wish Sourceforge had  GHC.
22:35:45 <co-recursive> anyway, even if you hate gmail, setting up a forward to a gmail account can prove very useful.
22:36:40 <monochrom> I think I have proof that HaXml parser and pretty-printer are very strict.
22:37:11 <lispy> and i think i have a counter proof
22:37:17 <lispy> at least for the pretty-printer
22:37:45 <co-recursive> monochrom: proof or evidence?
22:37:49 <lisppaste2> monochrom pasted "HaXml strictness/laziness" at http://paste.lisp.org/display/24216
22:38:59 <monochrom> I would say strong proof, but please do judge it carefully
22:39:15 <lispy> i'm too tired to figure out why it's not finding System.Win32.*
22:40:03 <lispy> monochrom: have you checked to see if fn_a or fn_b are considered strict by ghc just to make sure you're not accidentally forcing strictness?
22:41:34 <lispy> monochrom: so fn_b just writes an infinite xml doc?
22:41:57 <monochrom> Could you, instead, inform me: if fn_a is considered strict, can it still print out "helloworld"?
22:42:03 <lispy> monochrom: and i can't tell what fn_a does
22:42:56 <lispy> i'm having a hard time just figuring out what fn_a should do
22:43:00 <monochrom> fn_a constructs the data structure for <hello><world/>....  then two tests.
22:43:34 <monochrom> the first test pattern-matches the data structure to get just one bit of it.  it terminates.  it prints out the result promptly.
22:43:50 <monochrom> the second test calls the pretty printer "content".  It fails.
22:44:20 <lispy> chokes on undefined or it fails to terminate?
22:44:50 <monochrom> If it chokes on undefined, will we get to the pattern matching stage?
22:45:50 <lispy> i was thinking maybe it chokes on undefined while computing c
22:46:02 <lispy> but i don't kno what mkElem takes as params
22:46:11 <lispy> i don't actualy know what it does
22:46:23 <monochrom> mkElem never looks at the undefined part
22:46:41 <monochrom> if it chokes on undefined, it can't compute c, h, w.
22:46:50 <monochrom> As of now, it does compute h, w.
22:48:14 <lispy> so you're saying that the line "putStrLn (show (content c))" has to be the source of the strictness?
22:48:33 <monochrom> Yes.  putStrLn (h++w) is executed successfully.
22:49:31 <lispy> and we know that putStrLn is lazy right?
22:49:40 <lispy> so that leaves, show and content
22:49:49 <monochrom> Yes.  putStrLn (repeat 'c') works.
22:50:09 <lispy> i was using hPutXml or something like taht
22:50:14 <lispy> can we use that here?
22:51:15 <lispy> @hoogle content
22:51:16 <lambdabot> Text.Html.content :: String -> HtmlAttr
22:51:16 <lambdabot> Text.Html.markupContent :: HtmlElement -> Html
22:51:16 <lambdabot> Directory.getDirectoryContents :: FilePath -> IO [FilePath]
22:51:42 <lispy> http://www.cs.york.ac.uk/fp/HaXml/HaXml/Text-XML-HaXml-Xml2Haskell.html#v%3AhPutXml
22:53:13 <lispy> we'd need to convert that Content to an XmlContent
22:54:44 * lispy sleeps
22:58:26 <monochrom> show and content calls the same code as hPutXml does, from the HaXml source.
23:01:11 <lispy> hmm...i wondered
23:01:29 <lispy> yeah, so the difference i saw the other day must have just been due to laziness in the db
23:01:43 <lispy> too bad show is strict...i wonder why that happens
23:04:02 <Korollary> ?
23:04:58 <monochrom> "show" as in "show" for the type "Doc", which is in Text.PrettyPrint.HughesPJ, Korollary.
23:06:29 <monochrom> I am too lazy to separate "content" and "show for Doc".  "content" outputs Doc; show maps Doc to string.  Doc is an abstract data type.  It is tricky to find out which of the two functions is strict.
23:33:44 <dons> ?uptime
23:33:45 <lambdabot> uptime: 2 days, 4 hours, 25 minutes and 31 seconds
23:37:09 <Cale> dons: hmm, perhaps you can help with something
23:37:21 <Cale> Let me just recompile lambdabot
23:37:39 <Cale> I'm getting empty output from things which call popen
23:37:57 <Cale> (resulting in it printing Terminated)
23:38:12 <Cale> % hello
23:38:13 <mbot> Cale: Terminated
23:38:18 <Cale> > 1 + 2
23:38:18 <mbot> Terminated
23:38:19 <lambdabot>  3
23:38:23 <Cale> like that?
23:38:44 <Cale> The programs it's running seem to work fine when I run them from the shell
23:41:20 <Cale> dons: you around?
23:43:57 <Cale> hmm, perhaps I won't forkIO the evaluates
23:44:52 <Cale> % 1 + 1
23:44:52 <mbot> Cale: Terminated
23:44:54 <Cale> > 1 + 1
23:44:55 <mbot> Terminated
23:44:55 <lambdabot>  2
23:44:57 <Cale> nope
23:47:12 <Cale> oh
23:47:14 <Cale> hmm
23:47:48 <dons> yeah?
23:48:15 <dons> that's weird.
23:48:51 <dons> does runplugs work from the shell?
23:48:54 <dons> is it in the right place?
23:49:58 <Cale> I'm thinking it has to do with the fact that the bot is running as another user. I'll try giving it an absolute path.
23:50:35 <dons> yeah, could be permissions, I suppose
