00:00:08 <emertens> > filter ((==10) . length . group . sort . concatMap show) [[x,y,x*y] | x <- [0..9], y <- [0..9999]]
00:00:11 <lambdabot>  [[3,5694,17082],[3,6819,20457],[3,6918,20754],[3,8169,24507],[3,9168,27504],...
00:00:28 <edwardk> given the digits 0-9. find all formulas of the form x*xxxx=xxxxx where no x is the same digit
00:00:43 <xerox> Ah-ha!
00:00:49 <xerox> I misinterpreted then.
00:01:03 <emertens> is 0123 a four digit number?
00:01:23 <edwardk> like i said there were a couple of border cases
00:01:26 <emertens> > filter ((==10) . length . group . sort . concatMap show) [[x,y,x*y] | x <- [0..9], y <- [1000..9999]]
00:01:28 <lambdabot>  [[3,5694,17082],[3,6819,20457],[3,6918,20754],[3,8169,24507],[3,9168,27504],...
00:01:39 <edwardk> > length $ filter ((==10) . length . group . sort . concatMap show) [[x,y,x*y] | x <- [0..9], y <- [1000..9999]]
00:01:41 <lambdabot>  13
00:01:43 <edwardk> yeah
00:01:49 <edwardk> thats the whole list with border cases i think
00:02:31 <edwardk> hrmm
00:02:35 <emertens> hurray for extra computer cycles!
00:02:38 <edwardk> maybe not. no leading zeros
00:02:57 <emertens> > length filter ((==10) . length . group . sort . concatMap show) [[x,y,x*y] | x <- [2..9], y <- [1000..9999]]
00:02:57 <lambdabot>    The function `length' is applied to three arguments,
00:02:58 <lambdabot>   but its type `[...
00:03:14 <emertens> > filter ((==10) . length . group . sort . concatMap show) [[x,y,x*y] | x <- [2..9], y <- [1000..9999]]
00:03:15 <lambdabot>  [[3,5694,17082],[3,6819,20457],[3,6918,20754],[3,8169,24507],[3,9168,27504],...
00:03:34 <emertens> > drop 5 $ filter ((==10) . length . group . sort . concatMap show) [[x,y,x*y] | x <- [2..9], y <- [1000..9999]]
00:03:36 <lambdabot>  [[4,3907,15628],[4,7039,28156],[4,9127,36508],[6,5817,34902],[7,3094,21658],...
00:03:42 <emertens> > drop 10 $ filter ((==10) . length . group . sort . concatMap show) [[x,y,x*y] | x <- [2..9], y <- [1000..9999]]
00:03:44 <lambdabot>  [[7,4093,28651],[7,9304,65128],[7,9403,65821]]
00:03:55 <xerox> ((10==) . length . group . sort) is clever.
00:04:08 <emertens> :-D thanks
00:04:10 <edwardk> thought there were a couple of ones here the 5 digit numberhad a leading zero
00:04:16 <edwardk> er where
00:04:27 <edwardk> might be that there are 2 more of those, that are technically solutions
00:04:36 <edwardk> depending on how you read the problem
00:05:56 <emertens> > join ap (+1) 2
00:05:57 <lambdabot>    Occurs check: cannot construct the infinite type: a = a -> b
00:05:57 <xerox> shapr: I am also a bit sick... gurgle.
00:05:57 <lambdabot>    Expec...
00:06:11 <emertens> > ap join (+1) 2
00:06:11 <lambdabot>    Occurs check: cannot construct the infinite type: a = a -> a -> a1
00:06:12 <lambdabot>    ...
00:06:15 <xerox> join ap is not good.
00:06:16 <emertens> ap (,) 1
00:06:21 <emertens> > ap (,) 1
00:06:22 <lambdabot>  add an instance declaration for (Num (a1 -> a))
00:06:25 <xerox> ?type join ap
00:06:26 <emertens> > ap (,) (+1) 1
00:06:26 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
00:06:26 <lambdabot>    Expected type: m (a -> b) -> m (a -> b) -> a1
00:06:27 <lambdabot>  (1,2)
00:06:29 <xerox> :)
00:06:36 <emertens> I made it
00:06:50 <xerox> ap f g x = f x (g x)
00:06:56 <xerox>  = x `f` (g x)
00:07:04 <edwardk> yah
00:07:14 <xerox> So int-e's code x == nub xs becomes ab (==) nub :-)
00:07:17 <xerox> s/ab/ap/
00:07:18 <edwardk> had to reinvent ap before i realized that there was the reader monad =)
00:07:35 <emertens> @pl \f x y = (x,y,f x y)
00:07:35 <lambdabot> (line 1, column 8):
00:07:35 <lambdabot> unexpected "="
00:07:35 <lambdabot> expecting pattern or "->"
00:07:40 <emertens> @pl \f x y =-> (x,y,f x y)
00:07:40 <lambdabot> (line 1, column 8):
00:07:41 <lambdabot> unexpected "="
00:07:41 <lambdabot> expecting pattern or "->"
00:07:44 <emertens> @pl \f x y -> (x,y,f x y)
00:07:44 <lambdabot> liftM2 ap (,,)
00:07:51 <xerox> Yaak.
00:07:53 <emertens> hurray!
00:07:59 <emertens> that's where i wanted to get to
00:08:01 <edwardk> heh
00:08:08 <xerox> And lambdabot brings you there!
00:08:16 <int-e> length $ filter ((==9) . length . group . sort . concatMap show) . filter (not . elem '0' . concatMap show) $ [[x,y,x*y] | x <- [2..9], y <- [1000..9999]]
00:08:18 <int-e> > length $ filter ((==9) . length . group . sort . concatMap show) . filter (not . elem '0' . concatMap show) $ [[x,y,x*y] | x <- [2..9], y <- [1000..9999]]
00:08:19 <emertens> you goin' we fly you there
00:08:20 <lambdabot>  194
00:08:34 * int-e wonders
00:08:36 <int-e> oh.
00:08:46 <Korollary> Where is that from? SNL?
00:08:53 <edwardk> SNL?
00:08:54 <emertens> the delta commercial?
00:08:58 <Korollary> right
00:08:59 <emertens> I dont' know where it originally came from
00:09:12 <emertens> You been? we done already flew up in there
00:09:18 <emertens> we got you covered like a jimmy hat
00:10:11 <int-e> [[4,1738,6952],[4,1963,7852]]
00:10:23 <int-e> are the border cases :)
00:10:24 <emertens> > concatMap (concatMap (liftM2 ap (,,)) [1..3]) [4..5]
00:10:25 <lambdabot>    Expecting a function type, but found `[b]'
00:10:25 <lambdabot>    Expected type: a -> [b]...
00:10:30 * johnnowak crushes on tina fey
00:10:44 <emertens> > concatMap (map (liftM2 ap (,,)) [1..3]) [4..5]
00:10:45 <lambdabot>    Expecting a function type, but found `[b]'
00:10:45 <lambdabot>    Expected type: a -> [b]...
00:11:21 <emertens> i dont' know what it is that I'm trying to do
00:11:44 <Korollary> have some more whiskey
00:11:59 <emertens> @type more
00:12:00 <lambdabot> Not in scope: `more'
00:12:07 <emertens> @type whiskey
00:12:08 <lambdabot> Not in scope: `whiskey'
00:12:16 <emertens> hmm, i'm afraid I don't know what you mean
00:12:17 <Korollary> @fill-up
00:12:18 <lambdabot> Unknown command, try @list
00:12:31 <emertens> Ohh,
00:12:35 <emertens> @kind Whisky
00:12:36 <lambdabot> Not in scope: type constructor or class `Whisky'
00:12:38 <emertens> @kind Whiskey
00:12:40 <lambdabot> Not in scope: type constructor or class `Whiskey'
00:12:43 <emertens> hmmm..
00:13:01 <Korollary> @vixen Can I have some whiskey?
00:13:01 <lambdabot> why don't you guess?
00:13:05 <Korollary> @vixen Can I have some whiskey?
00:13:05 <lambdabot> i'll hafta plead the fifth on that one.
00:13:09 <Korollary> @vixen Can I have some whiskey?
00:13:10 <lambdabot> whoa whoa whoa, one question at a time!
00:13:21 <emertens> a/s/l
00:13:22 <Korollary> vixen is not functional.
00:13:24 <emertens> (for lambdabot )
00:13:40 <Korollary> she has an answer to that one
00:13:42 <emertens> ?vixen-on
00:13:42 <int-e> @vixen do you like Haskell?
00:13:42 <lambdabot> Not enough privileges
00:13:43 <lambdabot> Ooh, functional programmers are so hot!
00:14:02 <emertens> Insufficient privileges :(
00:14:18 <Korollary> ?vixen Haskell Beirut Baghdad?
00:14:18 <lambdabot> church is my favourite computer scientist.
00:14:32 <Korollary> pretty one-track minded
00:14:46 <emertens> when dons did the ?vixen-on
00:14:51 <emertens> lambdabot: would respond to a/s/l
00:15:05 <Korollary> @vixen a/s/l?
00:15:06 <lambdabot> 19/f/California
00:15:26 <emertens> @. elite vixen a/s/l
00:15:26 <lambdabot> 19/F/c4|IphoRnIA
00:15:30 <emertens> that's hot
00:15:34 <johnnowak> haha
00:15:46 <xerox> phoRnIA
00:16:14 <emertens> @. elite lastlog 2
00:16:15 <lambdabot> compose module failed: IRCRaised Parse error: "lastlog"
00:16:39 <Korollary> @. elite elite elie
00:16:39 <lambdabot> e|i3
00:16:55 <emertens> that's higher order elite?
00:17:03 <emertens> I can't compete
00:17:18 <Korollary> @. @. @.
00:17:19 <lambdabot> compose module failed: IRCRaised Parse error: "@."
00:17:40 <int-e> maybe elite is idempotent.
00:17:42 <emertens> I think that's a type error ;)
00:17:57 <emertens> @all-dicts idempotent
00:17:58 <lambdabot> *** "idempotent" wn "WordNet (r) 2.0"
00:17:59 <lambdabot> idempotent
00:17:59 <lambdabot>    adj : unchanged in value following multiplication by itself; "this
00:17:59 <lambdabot>       matrix is idempotent"
00:17:59 <lambdabot>  
00:18:00 <lambdabot> [41 @more lines]
00:18:14 <emertens> could be
00:19:06 <dons> @last #haskell 1
00:19:07 <Korollary> @all-dicks Pat Robertson
00:19:08 <lambdabot> 07:17:08 <emertens> could be
00:19:10 <lambdabot> *** "Pat" gcide "The Collaborative International Dictionary of English v.0.48"
00:19:10 <lambdabot> Pat \Pat\, v. t. [imp. & p. p. {Patted}; p. pr. & vb. n.
00:19:10 <lambdabot>   {Patting}.] [Cf. G. patschen, Prov. G. patzen, to strike,
00:19:10 <lambdabot>   tap.]
00:19:10 <lambdabot>   To strike gently with the fingers or hand; to stroke lightly;
00:19:12 <lambdabot> [134 @more lines]
00:19:14 <dons> @. elite last #haskell 1
00:19:15 <lambdabot> 07:17:08 <emErtENs> c0U|d b3
00:19:29 <emertens> that's what I wanted
00:19:30 <edwardk> elite isn't quite idempotent
00:19:34 <dons> @. elite last #perl6 1
00:19:36 <lambdabot> 07:17:53 <G4AL> 0Y. I'm defIniNG A 7YPe. Wh3n it \/\/4z zIMp|e i cou1d 'nEwtyp3' IT ANd 4DD fUnxY DeRIV4tiONs; 8ut N0w I'\/e 4dD3d varI4N+5 To I+ ANd caN'+ Uz3 NeWtYpe, bu7 +|-|3 DerIVaTIon5 W0N'T
00:19:37 <lambdabot> w0rK.
00:19:37 <edwardk> it has some cases it'll flop around
00:19:38 <dons> heh
00:19:49 <emertens> @last #perl6 1
00:19:50 <lambdabot> 07:17:53 <gaal> oy. I'm defining a type. when it was simple I could 'newtype' it and add funky derivations; but now I've added variants to it and can't use newtype, but the derivations won't work.
00:19:57 <Korollary> zimple
00:21:08 <Korollary> Hmm. Robin Williams checked into a rehab.
00:21:16 <dons> yeah
00:21:27 <dons> its the new fashion
00:21:51 <emertens> celebs going to rehab is not a "new fashion" ;)
00:21:58 <emertens> it's a tradition
00:22:18 <Korollary> Dave Mustaine did it 17 times.
00:22:29 <xerox> Uh, lambdabot logs?
00:22:39 <dons> xerox: ?
00:22:44 <emertens> xerox: you didn't think you had any privacy... did you?
00:22:51 <int-e> @where logs
00:22:52 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
00:22:59 <xerox> I knew about those logs
00:23:11 <emertens> apparently lambdabot makes those logs
00:23:16 <xerox> Nope
00:23:18 <int-e> so lambdabot logs, too.
00:23:19 <dons> nope.
00:23:22 <dons> lambdabot logs.
00:23:25 <emertens> oh
00:23:26 <xerox> ?last #haskell.it 1
00:23:26 <lambdabot> I haven't got any logs for that channel.
00:23:29 <emertens> yeah, whatever
00:23:29 <dons> it doesn't publish, except via @last
00:23:32 <xerox> Oh, good.
00:23:37 <xerox> Or...
00:23:44 <emertens> good?
00:23:46 <xerox> ?last #haskell.it 1
00:23:47 <lambdabot> 07:22:34 <xerox> Foo
00:23:52 <Korollary> it sends them to AOL, which leaks them later on with names replaced with unique numeric id's.
00:24:00 <xerox> Yak!
00:24:02 <dons> xerox: right. i mean, i'm not sure this is good behaviour, yeah?
00:24:11 <xerox> dons: I think so too.
00:24:33 <dons> its another way for lambdabot to be a spy
00:24:40 <emertens> xerox: what are you worried about?
00:24:41 <xerox> Indeed.
00:24:44 <dons> maybe i'll disable @last. no one used it anyway
00:24:54 <pstickne> it's not like people can't/don't log anyway.
00:24:59 <dons> it should at least only give you the current channel
00:25:07 <xerox> dons: that seem fine
00:25:08 <int-e> Hmm. But now that I know about it I might.
00:25:09 <dons> spying on other channels, without joining, is a little evil
00:25:23 <xerox> Right :)
00:25:25 <emertens> but you have no idea who is actually in the channel
00:25:30 <dons> sure
00:25:32 <emertens> when you are in it yourself anyway
00:25:34 <int-e> hmm, limiting to the current channel means no privmsg ...
00:25:37 <Korollary> @last #haskell-blah 1
00:25:37 <lambdabot> 07:10:06 <Korollary> I've just booked a flight through London next month. And they've raised the threat level.
00:25:47 <dons> Korollary: just limiting @last to give you the channel you're in.
00:25:51 <int-e> ah, tough call.
00:25:56 * pstickne likes dons idea
00:26:04 <pstickne> dons, or channels your in?
00:26:05 <xerox> ?last xerox 1
00:26:05 <lambdabot> I haven't got any logs for that channel.
00:26:06 <dons> so yeah, no privmsg.
00:26:09 <Heffalump> allow privmsg if the msging person is on the channel
00:26:15 <xerox> It doesn't log privmsgs
00:26:17 <dons> yeah, that's doable
00:26:21 <dons> xerox: it could ;)
00:26:24 <xerox> Yaaaak.
00:26:30 <Heffalump> @last dons 1
00:26:30 <lambdabot> I haven't got any logs for that channel.
00:26:31 <int-e> xerox: I meant /msg lambdabot @last ...
00:26:31 <Heffalump> ;-)
00:26:36 <dons> i've seen all you guys chatting up vixen... ;)
00:26:42 * xerox laughs
00:26:56 <emertens> does lambdabot tell you when wwe are privmesging it?
00:27:03 <roconnor> @vixen wanna come over to my place?
00:27:04 <xerox> Indeed.
00:27:04 <lambdabot> no
00:27:08 <dons> it all goes to the lambdabot stdout
00:27:14 <roconnor> :'(
00:27:16 <dons> which sometimes i scan, if lambdabot is behaving weirdly
00:27:29 <dons> channels get logged to disk
00:27:45 <Korollary> @vixen are you a dude?
00:27:46 <lambdabot> no, i'm a woman
00:27:49 <xerox> lambdabot will become an OS at some point.
00:27:50 <emertens> woot, the US terror alert level is up too
00:27:55 <Korollary> @vixen are you a male?
00:27:55 <lambdabot> i truely am
00:27:58 <Korollary> hah
00:28:02 <int-e> @botsnack
00:28:03 <lambdabot> :)
00:28:12 <int-e> @hello
00:28:12 <lambdabot> Maybe you meant: help hylo tell
00:28:33 <xerox> You know what could be fun? Keeping stats of the most used commands.
00:28:40 <int-e> not even a hello world - there's still a long way to go to being an OS
00:28:52 <dons> xerox: yeah. that would be useful
00:28:57 <emertens> @elite hello world
00:28:57 <lambdabot> |-|3|Lo wORLd
00:28:58 <dons> we need an @stats plugin
00:29:02 <xerox> I also want @choose
00:29:06 <roconnor> @cd /home
00:29:06 <lambdabot> /home
00:29:09 <xerox> @choose cake death
00:29:10 <lambdabot> cake death
00:29:17 <roconnor> @ls
00:29:17 <lambdabot> Maybe you meant: . ask id last list msg pl v wn
00:29:22 <roconnor> @dir
00:29:23 <lambdabot> Maybe you meant: arr dice dict id
00:29:25 <int-e> @cat /etc/passwd
00:29:25 <lambdabot> Maybe you meant: fact faq last map part what
00:29:32 <emertens> @faq
00:29:32 <lambdabot> The answer is: Yes! Haskell can do that.
00:29:37 <xerox> hahaha
00:29:40 <Korollary> @make love
00:29:41 <lambdabot> Maybe you meant: map more
00:30:12 <int-e> @map more
00:30:13 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
00:30:30 <emertens> heh, BBC did a segment on some guy saying how awful the French are
00:30:36 <emertens> silly europeans ;)
00:32:31 <xerox> ?yarr!
00:32:31 <lambdabot> Swab the deck!
00:32:44 <emertens> ?map
00:32:44 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
00:33:18 <dons> ?quit disable @last. sometimes lambdabot is too evil
00:33:26 <pstickne> where am I!?!? :(
00:33:28 <xerox> Sometimes.
00:33:56 <dons> pstickne: you add yourself. but currently rendering the map is disabled
00:34:07 <pstickne> ohh :-/
00:34:07 <dons> ?version
00:34:34 <lambdabot> lambdabot 4p50, GHC 6.5 (OpenBSD i386 )
00:34:36 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
00:34:37 <emertens> how large does the pot product of me and major haskell user have to be to add myself to that map?
00:34:48 <xerox> So it's lambdabot v4, patch 50 ?
00:34:51 <dons> you can add yourself anytime you want.
00:34:52 <pstickne> there are anumber of #haskell'ers in the region :)
00:34:56 <dons> xerox: yep.
00:34:59 <dons> ?last
00:34:59 <lambdabot> list [module|command]. Where modules is one of:
00:35:00 <lambdabot> babel base compose dice dict djinn drhylo dummy elite eval fact fresh haddock help hoogle instances karma lambda localtime log more pl poll pretty quote search seen slap spell state system tell todo
00:35:00 <lambdabot> topic type unlambda url version vixen where
00:35:15 <emertens> you broken it outright?
00:35:16 <xerox> ?slap
00:35:16 * lambdabot smacks  about with a large trout
00:35:22 <dons> i just disabled it
00:35:22 <xerox> Uh-oh.
00:35:29 <emertens> ?. elite slap dons
00:35:29 <lambdabot> //\/\e 83ats uP doNS
00:35:39 <Korollary> hah
00:35:51 <dons> someone can submit a patch to implement the features we discussed, or it can wait till i finish my paper :P
00:35:59 <Korollary> ?. slap (elite dons)
00:36:00 <lambdabot> compose module failed: IRCRaised Parse error: "(elite"
00:36:03 <xerox> dons - How's the paper coming along?
00:36:09 <dons> good :)
00:36:12 <dons> lots of fusion
00:36:23 <Korollary> five blades
00:36:26 <emertens> what's this "fusion"??
00:36:29 <dons> Korollary: thats another thing. adding a bit of an interpreter over @. would be good
00:36:33 <emertens> s/\?/
00:36:41 <dons> emertens: map f . map g -> map (f.g)
00:36:52 <dons> generliase that to any function that walks a structure, and you get fast code
00:36:52 <emertens> oh...
00:37:08 <emertens> right (by definition of map, right?)
00:37:09 <xerox> ...meanwhile discovering neat things :)
00:37:18 <Korollary> it's in that bananas paper.
00:37:44 <dons> ?google short cut deforestation
00:37:46 <lambdabot> http://www.cs.kent.ac.uk/pubs/1999/1903/index.html
00:37:46 <lambdabot> Title: Computer Science: Publication: Type Inference Builds a Short Cut to Deforestatio ...
00:37:59 <emertens> yeah, what the heck is short cut deforestation?
00:38:06 <dons> ?google functional array fusion
00:38:08 <lambdabot> http://citeseer.ist.psu.edu/chakravarty01functional.html
00:38:32 <dons> the system used to do the above fusion on lists, in GHC.
00:38:49 <emertens> wait... ghc does fusion on it's own?
00:38:50 <xerox> Somebody please tell dons to not answer with paper urls to every question!
00:38:57 <dons> heh
00:39:05 <Korollary> @tell dons don't answer with urls
00:39:06 <lambdabot> Consider it noted.
00:39:08 <dons> emertens: right. using rewrite rules
00:39:08 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
00:39:16 <dons> ?google playing by the rules haskell
00:39:18 <lambdabot> http://citeseer.ist.psu.edu/peytonjones01playing.html
00:39:29 <dons> oh, i didn't read my msgs.
00:40:24 <dons> anyway, dcoutts and I are writing about how to do fusion on bytestring arrays, using a new system of stream combinators
00:40:38 <dons> so that intermediate arrays are removed automagically
00:40:48 <Korollary> evil
00:40:52 * Heffalump missed dcoutts' talk on that at AngloHaskell, which is a shame cos it sounds very cool
00:41:21 <xerox> Indeed!
00:41:26 <dons> the code's here, http://www.cse.unsw.edu.au/~dons/code/fps-unstable/Data/ByteString/FusionStream.hs
00:41:44 <xerox> It was nice because we were all around a table, and not in rows like in the latter room.
00:41:52 <dons> its some pretty fun haskell, if you're not used to it
00:42:12 <xerox> ...and he has got some nice ideas exchange with the Simons :)
00:42:25 <dons> emertens: in ghc, you can add your own optimisations via rewrite rules. e.g. we have
00:42:29 <dons> {-# RULES
00:42:31 <dons> "FPS filterS/filterS" forall p q s.
00:42:34 <dons>     filterS p (filterS q s) = filterS (\x -> q x && p x) s
00:42:36 <dons>  #-}
00:42:38 <dons> which tells ghc how to combine pairs of filters, into a single pass
00:42:46 <agocorona> hi
00:42:53 <xerox> Howdy agocorona
00:43:05 <agocorona> Hi
00:43:19 <emertens> @type filterS
00:43:21 <lambdabot> Not in scope: `filterS'
00:43:31 <emertens> oh
00:43:33 <dons> its a (S)tream combinator, used in our library
00:43:34 <emertens> duh
00:43:37 <xerox> It's filter, but works on their intermediate representation (streams)
00:43:39 <dons> to implement filter.
00:43:40 <therp> dons: is there actually some automatic reasoning about such things? that the given optimization is not behaviour-altering can be proven from the source so, it might be possible
00:44:01 <dons> yep. we use QuickCheck to verify the rules, and hand proofs on the side
00:44:08 <dons> you could hook into Isabelle
00:44:24 <dons> but ghc can't in general prove such things about these rules
00:44:32 <dons> its up to the library author to get it right
00:44:42 <dons> it does check the types match though
00:44:48 <therp> nice
00:44:56 <agocorona> do I exist
00:44:57 <edwardk> > (filter $ \x -> uncurry (==) $ (map head . group &&& id) $ sort . concatMap show $ x) [ [x,y,x*y] | x <- [2..9], y <- [1000..9999] ]
00:44:59 <lambdabot>  [[2,1548,3096],[2,1845,3690],[2,3079,6158],[2,3485,6970],[2,3548,7096],[2,38...
00:45:10 <emertens> how closely related are the rewrite engine for @pl and this?
00:45:16 <dons> similar
00:45:27 <dons> they're both equational transformations
00:45:33 <dons> though @pl doesn't type check
00:45:47 <dons> you could immplement @pl in terms of ghc's term rewriting system
00:46:06 <edwardk> ah that screwed up =)
00:46:08 <edwardk> nevermind
00:46:14 <xerox> ?pl (\f x -> f x x) (\f g x -> f x (g x))
00:46:15 <lambdabot> join ap
00:46:17 <xerox> ?type join ap
00:46:19 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
00:46:19 <lambdabot>    Expected type: m (a -> b) -> m (a -> b) -> a1
00:46:21 <xerox> :)
00:46:22 <edwardk> it uses 0s in less than 10 digit case
00:47:38 <emertens> @pl \x y -> [x] + y
00:47:38 <lambdabot> (+) . return
00:47:59 <emertens> @type (+) . return
00:48:01 <lambdabot> forall (m :: * -> *) a. (Num (m a), Monad m) => a -> m a -> m a
00:48:11 <agocorona> /join java
00:48:17 <emertens> booo
00:48:20 <dons> booo!
00:48:24 <xerox> booo!!
00:48:28 <dons> ?karma java
00:48:28 <lambdabot> java has a karma of 4
00:48:30 <agocorona> sorry
00:48:31 <dons> boo!
00:48:32 <emertens> /join #0 #java
00:48:35 <dons> ?karma- java
00:48:36 <lambdabot> java's karma lowered to 3.
00:48:37 <dons> ?karma- java
00:48:37 <lambdabot> java's karma lowered to 2.
00:48:37 <dons> ?karma- java
00:48:38 <lambdabot> java's karma lowered to 1.
00:48:38 <dons> ?karma- java
00:48:38 <lambdabot> java's karma lowered to 0.
00:48:40 <dons> ?karma- java
00:48:40 <lambdabot> java's karma lowered to -1.
00:48:41 <emertens> lol
00:48:41 <Korollary> lol
00:48:43 <dons> that's better
00:48:45 <xerox> hahaha
00:48:49 <ValarQ> :)
00:48:49 <xerox> dons got mad.
00:48:52 <agocorona> Java is my work, Haskell is my passion
00:49:07 <dons> its ok. we're just joking :)
00:49:11 <emertens> oh?
00:49:17 <Korollary> who karma+'d java anyway
00:49:27 <xerox> Check the logs, yarrrr
00:49:28 <edwardk> ?karma javascript
00:49:29 <emertens> dons: can you grep your logs?
00:49:29 <lambdabot> javascript has a karma of 0
00:49:31 <edwardk> =)
00:49:35 <dons> looking ...
00:49:46 <emertens> and then have lambdabot maintain the ban ;)
00:49:56 <emertens> ?karma c#
00:49:56 <lambdabot> c# has a karma of 0
00:49:59 <emertens> ?karma C#
00:49:59 <lambdabot> C# has a karma of 0
00:50:03 <int-e> > length $ filter ((==10) . length . group . sort . take 10 . (++"0") . concatMap show) [[x,y,x*y] | x <- [2..9], y <- [1000..9999]]
00:50:05 <lambdabot>  15
00:50:07 <xerox> It's like it was for the witches in the middle ages!
00:50:09 <edwardk> yay
00:50:19 <dons> yeah, I should add a patch that automatically lowers karma for anyone who karma+'s java
00:50:23 <edwardk> >  filter ((==10) . length . group . sort . take 10 . (++"0") . concatMap show) [[x,y,x*y] | x <- [2..9], y <- [1000..9999]]
00:50:25 <lambdabot>  [[3,5694,17082],[3,6819,20457],[3,6918,20754],[3,8169,24507],[3,9168,27504],...
00:50:29 <dons> to keep the universe in balance
00:50:30 <Korollary> ?karma perl
00:50:30 <lambdabot> perl has a karma of -1
00:50:36 <xerox> haha
00:50:46 <xerox> perl folks on the other hand did pugs....
00:50:48 <emertens> ?karma haskerl
00:50:48 <lambdabot> haskerl has a karma of 0
00:50:56 <Korollary> ?karma python
00:50:56 <lambdabot> python has a karma of 0
00:50:57 <edwardk> that caught the [4,1738,6952],[4,1963,7852] leading zero cases
00:51:01 <Korollary> ?karma ruby
00:51:02 <lambdabot> ruby has a karma of 0
00:51:09 <Muad_Dib> ?karma+ java
00:51:10 <lambdabot> java's karma raised to 0.
00:51:15 <Muad_Dib> (before dons finishes that patch)
00:51:15 <dons> oh, its not in the logs. someone must have done it privmsgd
00:51:19 <edwardk> heh
00:51:26 <xerox> haha
00:51:26 <emertens> screw ruby on rails, I'm using snakes on a plane
00:51:31 <Korollary> lol
00:51:33 <dons> hehe
00:51:43 <dons> ?remember emertens screw ruby on rails, I'm using snakes on a plane
00:51:44 <lambdabot> Done.
00:51:55 <emertens> haHA! I've said something "memorable"
00:52:27 <Korollary> @cookie emertens
00:52:28 <lambdabot> Unknown command, try @list
00:52:33 <edwardk> @quote emertens
00:52:33 <emertens> I knew I was staying up into the wee hours of the morning for something
00:52:33 <lambdabot>  screw ruby on rails, I'm using snakes on a plane
00:52:46 <edwardk> @quote dons
00:52:47 <lambdabot>  so i suspect dynamically typed langs, that just work (bugs and all) will always be more popular with the masses since most people don't understand bug theory ;)
00:52:52 <edwardk> @quote ekmett
00:52:53 <lambdabot> ekmett hasn't said anything memorable
00:52:56 <edwardk> @quote edwardk
00:52:56 <lambdabot>  been playing with type level 2s complement arithmetic
00:52:57 <edwardk> woops
00:53:12 <edwardk> @quote shapr
00:53:13 <lambdabot>  GHC has more flags than the UN
00:53:20 <xerox> hahaha
00:53:22 <mnislaih> @quote Lemmih
00:53:23 <lambdabot>  <shapr> Any idea where we should meet?  *** Lemmih opens Google Earth.
00:53:25 <emertens> @quote
00:53:25 <lambdabot> RyanT5000 says: i wish i had been programming in haskell for 7 years rather than C++
00:53:30 <mnislaih> @quote mnislaih
00:53:31 <lambdabot> mnislaih hasn't said anything memorable
00:53:31 <Korollary> Hmmm. Bug theory.
00:53:35 <dons> changeKarma km sender nick
00:53:35 <mnislaih> :(
00:53:36 <dons>   | map toLower nick == "java" = changeKarma (-1) "lambdabot" sender
00:53:48 <edwardk> heh
00:53:49 <dons> hehe. lambdabot will lower your karma... :)
00:53:51 <xerox> dons: sneaky! Any message?
00:53:57 <dons> hang on. let me commit it
00:54:01 <int-e> will @karma ever become case insensitive?
00:54:10 <dons> maybe it is. i'm not sure
00:54:16 <dons> ?karma+ Int-e
00:54:16 <lambdabot> Int-e's karma raised to 1.
00:54:16 <emertens> it's not
00:54:16 <edwardk> @karma edwardk
00:54:16 <xerox> ?karma dons
00:54:17 <lambdabot> You have a karma of 0
00:54:17 <lambdabot> dons has a karma of 49
00:54:18 <xerox> ?karma donS
00:54:18 <lambdabot> donS has a karma of 0
00:54:24 <int-e> @karma Dons
00:54:25 <lambdabot> Dons has a karma of 0
00:54:25 <dons> ah well
00:54:26 <int-e> :)
00:54:29 <Korollary> Entomology
00:54:33 <xerox> ?karma
00:54:34 <lambdabot> You have a karma of 21
00:54:44 <xerox> Nearly half-a-dons!
00:54:45 <int-e> @karma- @karma
00:54:45 <lambdabot>  @karma's karma lowered to 0.
00:54:58 <emertens> ? lowered to 0?
00:55:25 <emertens> @karma+ @karma-
00:55:26 <lambdabot>  @karma-'s karma raised to 1.
00:55:32 <johnnowak> ?karma
00:55:38 * johnnowak fumbles
00:55:42 <lambdabot> You have a karma of 0
00:55:52 <emertens> ?quote johnnowak
00:55:58 <lambdabot> johnnowak hasn't said anything memorable
00:56:04 * johnnowak fumbles
00:56:16 <xerox> dons - I know you are multitasking just enough, but may you dump ?karma-all to some file and put it online for our amusement?
00:56:26 <dons> ?karma-all
00:56:26 <lambdabot>  dons                   49
00:56:27 <lambdabot>  shapr                  22
00:56:27 <lambdabot>  xerox                  21
00:56:27 <lambdabot>  Lemmih                 19
00:56:27 <lambdabot>  lambdabot              19
00:56:28 <lambdabot> [199 @more lines]
00:56:33 <emertens> @more
00:56:33 <dons> its in the where state
00:56:33 <lambdabot>  dcoutts                17
00:56:33 <lambdabot>  Cale                   12
00:56:34 <lambdabot>  int-e                  12
00:56:35 <emertens> ;)
00:56:35 <dons> let me grab it
00:56:36 <lambdabot>  musasabi               12
00:56:39 <lambdabot>  sjanssen               10
00:56:40 <lambdabot> [194 @more lines]
00:57:05 <emertens> can karma be used to buy prizes?
00:58:05 <Korollary> well, good things happen to you. Why bother with buying stuff.
00:58:22 <emertens> I'm more of a material person
00:58:23 * int-e measures dons' karma and finds that it's a square.
00:58:23 <dons> http://www.cse.unsw.edu.au/~dons/tmp/karma
00:58:37 <dons> heh
00:58:59 <emertens> could you repost it sorted by karma? ;)
00:59:07 <dons> sigh
00:59:10 <emertens> lol
00:59:12 <edwardk> heh
00:59:15 <edwardk> ("Korolary",1)
00:59:15 <edwardk> ("Korollary",3)
00:59:15 <edwardk> ("Korrolary",1)
00:59:17 <emertens> don't worry, i can handle that task in haskell
00:59:39 <edwardk> ("sjanssen",10)
00:59:39 <edwardk> ("sjanssen_",1)
00:59:43 <emertens> > snd $ read "(1,2)" :: Int
00:59:44 <lambdabot>  Add a type signature
00:59:56 <Korollary> I have many faces
01:00:13 <edwardk> ("korollary",-1)
01:00:15 <edwardk> =)
01:00:18 <edwardk> is also in there =)
01:00:23 <xerox> Oh, wikipedia has -1 :(
01:00:23 <dons> done.
01:00:31 <dons> reverse sorted. but oh well
01:00:32 <int-e> < karma sed 's/."\(.*\)".\(.*\).$/\2 \1/' | sort -n
01:00:38 <xerox> ...
01:00:45 <dons> sort -k2 -t',' -n
01:00:48 <emertens> could you repost it, sorted in descending order?
01:00:53 <emertens> :-p j/k
01:01:02 <int-e> ah. I should read more manpages.
01:01:03 <int-e> :)
01:01:10 <dons> done
01:01:19 <dons> is that ok, emertens ?
01:01:28 <emertens> 404?
01:01:37 <emertens> you didn'ttry ot sort the file in place, did you?
01:01:43 <emertens> ah, there i is
01:01:46 <dons> its there.
01:01:51 <dons> you must have caught the nfs writing
01:01:54 <emertens> perfect
01:02:10 <emertens> "The plan's aim was to cause many deaths"
01:02:27 <emertens> Hi, could you please tell me why the terrorist wanted to blow up the plane?
01:02:38 <emertens> Yes, you see, they wanted to cause many deaths
01:03:43 <Korollary> unlike your typical terrorist.
01:04:33 <emertens> the typical one just wants to get out of the plane earlier than everyone else
01:04:35 <int-e> 1 Kzm    1 kzm    2 KZM
01:04:57 <dons> yeah, we should fix this bug, and normalise the karma logs
01:05:13 <emertens> who are you including in "we"?
01:05:28 <Korollary> emerttensss
01:05:47 <emertens> before you go off revising the karma system... you could look at the ghci issue :-p
01:05:53 <dons> I meant "we" as in "us", the way gollum talks about us fixing our bugssesss
01:05:58 <int-e> Anyone who feels like it and isn't busy writing fps papers I guess. Or dons when the paper is done.
01:06:11 <int-e> :P
01:06:13 <Korollary> ?karma gollum
01:06:13 <lambdabot> gollum has a karma of 0
01:06:13 <dons> ?karma+ int-e clarity!
01:06:14 <lambdabot> int-e's karma raised to 13.
01:06:43 <Heffalump> ?karma
01:06:44 <lambdabot> You have a karma of 4
01:06:51 <Heffalump> is there a way to find out what I got my karma for?
01:06:56 <emertens> how hard would it be for me to find the code that limits monad comprehensions to lists
01:07:04 <dons> not at the moment. its on the todo list
01:07:04 <Heffalump> (e.g. by pointing at the date/time each point was added)
01:07:05 <edwardk> emertens: is not bad
01:07:07 <dons> someone could add it
01:07:09 <edwardk> look in dsSugar.hs
01:07:14 <edwardk> er
01:07:39 <dons> ?quit java karma is super-magic
01:07:59 <emertens> I don't think i have that file
01:08:16 <emertens> oh
01:08:18 <emertens> .lhs
01:08:55 <dons> ?bot
01:09:02 <boegel> @vixen where were you bitch? cheating on me again?!?
01:09:22 <lambdabot> :)
01:09:22 * boegel just realizes he said that out loud
01:09:32 <lambdabot> i do not think i'm a bitch
01:09:41 <edwardk> ./compiler/deSugar/DsListComp.lhs
01:09:42 <dons> so, who wants to try out the karma command...
01:09:48 <dons> ?karma+ java
01:09:49 <lambdabot> dons's karma lowered to 48.
01:10:05 <edwardk> ?karma+ dons taking one for the team
01:10:06 <lambdabot> dons's karma raised to 49.
01:10:19 <dons> oh, and a feature-bug I thought was cool, but should remove:
01:10:23 <dons> ?karma- java
01:10:23 <lambdabot> dons's karma raised to 50.
01:10:26 <dons> ;)
01:10:28 <Korollary> lol
01:10:29 <edwardk> heh
01:10:34 <Korollary> that's a loophole
01:10:49 <edwardk> yeah lest us unfunny folks get karma
01:10:51 <edwardk> =)
01:10:51 <dons> it was just easy to write:   | map toLower nick == "java" = changeKarma (-km) "lambdabot" sender
01:12:16 <edwardk> emertens: you'll find in there two implementations for the list comprehension stuff
01:12:21 <edwardk> one seems amenable to change
01:12:33 <edwardk> though i'm not sure what the rest of the system assumes about the types coming out of a comprehension
01:13:01 <emertens> I was thinking that other parts of the code might depend on a "List" coming out of the comprehension
01:13:15 <dons> ?quit order returns to the cosmos
01:13:50 <emertens> the code I've found uses ++, rather than mplus
01:14:03 <edwardk> well get crackin ;)
01:14:10 <dons> ?users
01:14:28 <emertens> mplus is just Control.MonadPlus?
01:14:32 <emertens> @index mplus
01:14:36 <lambdabot> Maximum users seen in #haskell: 235, currently: 198
01:14:38 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
01:14:44 <emertens> oh
01:14:46 <emertens> just Monad
01:15:13 * xerox heads to the shops
01:15:47 <emertens> should I be using DsMonad instead of Monad?
01:16:01 <emertens> nvm
01:16:23 <int-e> it's a MonadPlus class member, defined in Control.Monad
01:17:40 <emertens> (:) doesn't really translate directly into "Monad" right? so the foldr style comprehension won't translate well?
01:18:24 <edwardk> hrmm
01:19:01 <emertens> ignore me for now
01:19:06 <edwardk> heh
01:19:06 <edwardk> ok
01:19:09 <edwardk> =)
01:19:22 <emertens> lhs looks like crap in vim
01:19:32 <emertens> it's making this just that much more diffcult ;)
01:20:11 <wolverian> do you have the literatehaskell syntax mode enabled?
01:20:34 <wolverian> (lhaskell)
01:21:04 <emertens> how do i do that?
01:21:04 * kzm_ wonders if the list monad should be renamed.
01:21:13 <edwardk> lzm: ?
01:21:30 <edwardk> er kzm?
01:21:36 <kzm_> I tend to get confusing error messages using lists in monadic code, and it is really a non-determinism monad, isn't it?
01:21:43 <dons> we could call it the confusing monad
01:21:56 <wolverian> emertens, it should be automatically enabled when opening an .lhs file. if not, :set filetype=lhaskell
01:22:03 <kzm_> Couldn't it hide behind a 'newtype NonDet a = NonDet [a]' or something?
01:22:05 <Cale> It's definitely the list monad :)
01:22:42 <Cale> If you're going to go to the trouble of using a type that's not lists, there are faster ways to get nondeterminism.
01:22:51 <Cale> (performance-wise)
01:22:52 <kzm_> Okay.  It's an old aquaintance by now, but it was confusing for some time.
01:23:18 <Cale> Like the ((->) e) monad.
01:24:31 <kfish> hi all
01:24:39 <dons> heya kfish
01:24:43 <kfish> i'm getting "Could not find module `Data.Graph.Inductive.Graph'"
01:24:53 <dons> its in package fgl
01:25:01 <dons> so, -package fgl
01:25:02 <emertens> vim 7 gets confused in lhaskell mode
01:25:14 <kzm_> kfish, or ghc --make?
01:25:14 <kfish> dons: ta
01:26:04 <kfish> dons, kzm_ , added to .cabal, works better now, cheers ;-)
01:26:07 <emertens> I'm not totally convinced that the list comprehension in this file is actually specific to lists...
01:26:16 <emertens> everything seems to be returning DsMonad s
01:26:29 <emertens> granted this code is over my head
01:26:58 <Stinger_> how hard would it be to embed a haskell scripting engine into a haskell app (don't go into huge detail, I'm not planning on doing this (right now))
01:27:16 <edwardk> using hsplugins? not bad
01:27:25 <emertens> dsListComp :: [LStmt Id] -> Type              -- Type of list elements -> DsM CoreExpr
01:27:26 <dons> still not ideal yet
01:27:32 <dons> we need a layer over ghc-api
01:27:37 <Stinger_> so thats what I would look at if I wanted to do that?
01:27:42 <edwardk> depends on what you want to have it interface to
01:27:47 <dons> either hs-plugins, like lambdabot does:
01:27:49 <dons> > 1+2
01:27:50 <lambdabot>  3
01:27:59 <dons> or else, you write a paper and embed ghc-api, I think
01:28:10 <edwardk> hehe
01:28:21 <Stinger_> ok, anything I would want do probably would be rather limited
01:28:22 <dons> other options. hmm, you could embed hugs or nhc too
01:40:39 <dons> i just loving writing 50 lines of code, and it type checks, and passes all QC properties first go
01:40:47 <edwardk> nice
01:41:15 <Stinger_> it scares me when that happens ;)
01:41:54 <dons> yeah me too. but if QuickCheck says its ok , i feel alright about it.
01:42:03 <dons> since that's two levels of checking: ghc, and then QC.
01:47:43 <mux> hullo guys
01:57:59 <boegel> hullo mux, ure wu tulking u nuw lunguuge? :)
02:02:02 <Itkovian> wtf
02:28:32 <agocorona> test
02:29:38 <agocorona> Java is better (flood test)
02:30:18 <agocorona> anyone of you have been using STM transactions?
02:56:48 <kzm_> Any way to get CPP (or gcc -E) to be more lenient in the presence of single quotes?
02:57:49 <kzm_> I'm always impressed by the things I know the answers to, as soon as I formulate a question.
02:58:02 * kzm_ just put any macro definitions on separate lines.
02:58:06 <vincenz> kzm_: rubberduck syndrome
02:58:13 <kzm_> xsctly
02:58:51 <dons> rubberduck syndrome??
02:58:59 <vincenz> @tell dons Can you continuously put the logs of #oasis online, I've been asked about htat possibility, preferably yesterday too
02:58:59 <lambdabot> Consider it noted.
02:59:02 <vincenz> dons: cardboard programmer
02:59:13 <dons> ah you want all the logs. always, online?
02:59:13 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
02:59:26 <dons> i'll set up a cronjob. it is possible
02:59:47 <vincenz> dons: explain a problem to someone else, they'll nod not knowing what you're talking about cause you're too busy explaining the problem you don't detail the context, and then blammo it hits you and you say "thank you"... the theory is, you could replace the other programmer by a cardboard programmer...or a rubberduck
02:59:54 <vincenz> it's on the wiki
02:59:55 <dons> ah!
02:59:58 <vincenz> (original wiki)
03:00:14 <dons> when i was an undergrad, at our computer lab help desk, was a teddy bear
03:00:19 <vincenz> :)
03:00:27 <dons> you were supposed to explain your problem to the bear first
03:00:32 <Stinger_> haha
03:00:58 <dons> and you would, and realise the bug. i'm sure it was very effective at cutting down the work load
03:00:58 <vincenz> off to lunch
03:01:00 <vincenz> bbl
03:04:14 <dons> vincenz: ok. it should get updated once a day now, the logs.
03:30:37 <shapr> @quote
03:30:37 <lambdabot> sjanssen says: @djinn Haskell -> Curry
03:30:43 * shapr grins
03:31:03 <shapr> @quote
03:31:03 <lambdabot> jlouis says: Q: When does one know he has programmed too much Haskell? A: When he uses == and /= in everyday IRC chat or when he tries to fix a relationship by passing himself as a continuation
04:00:44 <musasabi> Is there a nice way to debug ReadP parsers?
04:08:48 <agocorona> We all pray to saint  Simon Peyton Jones  so that he blesses to us with decent debugger
04:13:42 <agocorona> @fortune
04:13:42 <lambdabot> If I am elected, the concrete barriers around the WHITE HOUSE will be
04:13:43 <lambdabot> replaced by tasteful foam replicas of ANN MARGARET!
04:14:32 <agocorona> @fortune
04:14:33 <lambdabot> I'm a Lisp variable -- bind me!
04:16:51 <vincenz> dons: thx
04:17:31 <vincenz> anyone here know some good ssh libs?
04:17:33 <shapr> agocorona: I think you should really ask Lemmih.
04:17:36 <vincenz> for haskell
04:18:01 <shapr> vincenz: Can you explain that? There's ssl, what do you want to do with ssh?
04:18:04 <xerox> shapr: did you see the cabal-devel mailing list?
04:18:12 <vincenz> shapr: connect over ssh
04:18:16 <shapr> xerox: I read your post, but I haven't replied yet.
04:18:17 <vincenz> shapr: like darcs does
04:18:27 <shapr> xerox: I'd rather just write the code and check it in.
04:18:44 <shapr> xerox: I think the correct approach is to write code first, and then let other people argue.
04:18:51 <shapr> xerox: Once it works, people will start using it and improving it.
04:18:54 <xerox> I am trying but I am stuck, I will try to understand OutputGen weirdness on my own after lunch today
04:19:06 <shapr> Or, just rip it out and write something that you do understand.
04:19:09 <xerox> That makes sense... :)
04:19:17 <xerox> I'll think about that too
04:19:53 <vincenz> Itkovian: ping
04:20:00 <Itkovian> pong
04:20:08 <vincenz> Itkovian: kunnen we prive spreken?
04:20:10 <shapr> xerox: The first priority is to make it work asap. If we can get it into ghc 6.6 it'll really help the whole Haskell world.
04:20:13 <vincenz> Itkovian: stelios staat hier met mij
04:20:34 <dons> vincenz: hmm. there's darcs. it must have some ssh layer code
04:20:53 * xerox nods
04:21:20 <shapr> For example, I might be able to get dons and vincenz to install Hope if they can do it with a single command ;-)
04:21:40 <vincenz> dons: I want to expand my darcs-apply to do over ssh
04:21:54 <kowey> vincenz: the darcs ssh code involves explictly calling scp/sftp/ssh
04:22:31 <kowey> vincenz: for the most part, it can be found here http://www.abridgegame.org/repos/darcs-unstable/External.hs
04:22:47 <xerox> kowey: does it work on windows?
04:23:43 <dons> I wish darcs src had more comments :)
04:24:07 <dons> good thing the identifiers are well chosen
04:26:01 <vincenz> thx
04:27:15 <xerox> import Workaround -- ?
04:27:23 <xerox> #include "impossible.h"
04:27:24 <xerox> O_o
04:31:52 <musasabi> readp seems not to like me very much.
04:33:49 <vincenz> ah
04:33:52 <vincenz> kowey: all sys exec :/
04:34:15 <vincenz> hoi kenneth
04:45:04 <vincenz> Itkovian, boegel: pity I can't meet you guys :/
04:45:32 <musasabi> dcoutts: I am thinking of a small syntax change:
04:45:38 <musasabi> Currently one has: configuration: package(base-any, <2.0)
04:45:54 <musasabi> I would like to make it package(base < 2.0)
04:46:16 <dcoutts> I don't recognise the original syntax
04:46:22 <dcoutts> where's that from exactly?
04:46:36 <musasabi> Simon Marlow's email and the code.
04:46:56 <musasabi> It doesn't work at the moment so replacing it shouldn't break anything.
04:48:10 <dcoutts> musasabi, is 'package' special there?
04:48:34 <kowey> xerox: sort of... it works for putty ssh, but you have to rename plink.exe to ssh.exe
04:48:50 <kowey> vincenz: actually, http://www.abridgegame.org/repos/darcs-unstable/Exec.lhs
04:49:07 <dcoutts> musasabi, I presume it is. Do we have a list of these names, package, debug, etc?
04:49:19 <musasabi> package is special.
04:49:23 <dcoutts> os,arch?
04:49:26 <musasabi> we support package/os/arch
04:49:35 <dcoutts> and debug is not special?
04:49:44 <musasabi> no
04:49:49 <vincenz> kowey oy :/
04:50:04 <musasabi> plain word: --enable-foo triggers it.
04:50:10 <dcoutts> musasabi, so the list is extensible with special support for some, ok.
04:50:18 <kowey> it would be good if somebody converted our code to use System.Process, but note that we're targeting GHC 6.2.2
04:50:19 <boegel> vincenz: there will be a next time probably
04:50:39 <dcoutts> musasabi, in that case, yes I prefer your syntax
04:51:23 <int-e> why do people still use 6.2.2?
04:51:47 <musasabi> ok. Sending patch.
04:51:47 <dcoutts> musasabi, does it extend to examples like this? package(base > 1.1, base < 2.0)
04:51:48 <kowey> droundy's thinking is that this is what debian stable has
04:52:14 <dcoutts> Gtk2Hs still supports ghc 5.04.3, 6.0, 6.2 and 6.4
04:53:53 <dcoutts> musasabi, ah, we don't need my example "package(base > 1.1, base < 2.0", since we can use "package(base > 1.1) && package(base < 2.0)"
04:55:31 <vincenz> boegel: true :)
04:55:40 <vincenz> boegel: I should come visit ghent sometime for a drink, never been there
04:56:59 <boegel> vincenz: tssk
05:00:14 <musasabi> dcoutts: yes.
05:00:19 <kowey> xerox: oh and the import Workaround is so that we can write ghc 6.4 style code under 6.2
05:00:41 <kowey> i.e. if our configure script detects ghc 6.2, we toss in implementations of 6.4 libraries
05:00:47 <musasabi> dcoutts: also added parenthesises so one can get "(foo && bar) || baz" vs "foo && (bar || baz)" easily.
05:01:07 <musasabi> Sent it to Cabal-devel - should be ready for testing.
05:01:48 <dcoutts> musasabi, cool
05:02:21 <dcoutts> musasabi, I guess ideally we'd want a test case or two for the testsuite
05:02:32 <dcoutts> especially if we're aiming for 6.6
05:02:41 <dcoutts> the testing is crucial for that
05:03:07 <dcoutts> and probably demoing it in a real package or two too
05:03:22 <dcoutts> eg I think we had a problem with posix/win32 in cabal itself
05:04:44 <vincenz> heh
05:04:45 <vincenz> scheme and oo
05:04:47 * vincenz sighs
05:04:57 <vincenz> good thing plt scheme rocks
05:05:00 <vincenz> great gui when you get bugs :)
05:06:32 <musasabi> dcoutts: HUnit or something under tests/ ?
05:07:16 <dcoutts> musasabi, either, which ever seems more appropriate
05:16:59 <shapr> @users
05:17:00 <lambdabot> Maximum users seen in #haskell: 235, currently: 206
05:17:14 <vincenz> > return "cookie" >>= replicate 206
05:17:15 <lambdabot>  ["cookie","cookie","cookie","cookie","cookie","cookie","cookie","cookie","co...
05:18:05 <arjanoosting> take 1 (return "cookie" >>= replicate 206 )
05:18:18 <shapr> @karma+ Pupeno -- extra points for DNS trivia
05:18:18 <lambdabot> Pupeno's karma raised to 2.
05:19:07 <Pupeno> shapr: :) kewl. Thanks.
05:19:16 <boegel> @karma boegel
05:19:16 <lambdabot> You have a karma of 2
05:19:20 <boegel> beuh :(
05:27:55 <BCoppens> boegel: at least you have karma ;)
06:08:50 <vincenz> dons: ping
06:10:23 * vincenz freaks as he has a deja-vu
06:13:42 <jgrimes> why when I use '\n' as a terminal in happy does it report it as not being used?
06:20:47 <shapr> Hey, did you guys know that scholar.google.com can turn results into bibtex?
06:21:32 <shapr> @users
06:21:32 <lambdabot> Maximum users seen in #haskell: 235, currently: 210
06:21:52 <kosmikus> no
06:23:01 <shapr> Bibtex import sounds useful for those of you who write papers for a living.
06:23:23 <shapr> You can find it in the scholar.google.com preferences under "Bibliography Manager"
06:24:02 <shapr> edwinb: Did you see the LtU article about Ivor?
06:24:23 <dcoutts> shapr, btw the intel gfx is only on the motherboard, not as pci cards
06:24:32 <shapr> dang :-(
06:24:37 <shapr> Think they'll make cards?
06:24:41 <dcoutts> nope
06:24:46 <shapr> I want to buy an amd64 next.
06:25:01 <dcoutts> the best cards are still the radeon 9250's
06:25:24 <shapr> Are they still produced?
06:25:24 <kosmikus> shapr: thanks
06:25:32 <dcoutts> shapr, yes
06:25:42 <dcoutts> unless amd is swift with releasing specs or open drivers for the recent ati radeons
06:25:43 <shapr> Is their driver fully OSS?
06:25:51 <shapr> hiya JaffaCake
06:25:59 <JaffaCake> hiya!
06:26:03 <shapr> How's code?
06:26:08 <dcoutts> shapr, yes the radeon 9250 driver is fully open, 3d and all
06:26:13 <dcoutts> hia JaffaCake
06:26:16 <JaffaCake> a bit manic, trying to get the 6.6 release into shape
06:26:16 <shapr> Spiffy, I'll buy one of those next.
06:26:37 <shapr> If cabal-get is working in the next few days, is it possible to get it into 6.6?
06:26:39 <dcoutts> JaffaCake, I introduced xerox to jaffa cakes the other day. He spotted them in the shops. :-)
06:26:58 <JaffaCake> heh, JCs are addictive
06:27:01 <dcoutts> and he spotted a can of SPAM and was quite pleased
06:27:18 <dcoutts> he took it back home with him :-)
06:27:20 <JaffaCake> SPAM, on the other hand, is disgusting
06:27:28 <dcoutts> he's not going to eat it!
06:27:34 <JaffaCake> phew
06:27:35 <boegel> I sure hope so :/
06:27:38 <dcoutts> he says he's going to post it to someone
06:27:45 <boegel> dcoutts: :D
06:27:48 <shapr> I hope they don't eat it.
06:27:54 <JaffaCake> unless they're a spammer
06:28:02 <dcoutts> boom boom
06:28:02 <shapr> JaffaCake: Still possible to get cabal-get into 6.6?
06:28:19 <JaffaCake> shapr: that's really up to SyntaxNinja and dcoutts
06:28:21 <shapr> ok
06:28:30 <JaffaCake> I'd be happy to include it, FWIW
06:28:36 <dcoutts> JaffaCake, oh yes, you've seen that musasabi is working hard to get caonfigurations into cabal in time for 6.6
06:28:50 <JaffaCake> oh really?
06:28:57 <dcoutts> he's sent in patches
06:29:00 <JaffaCake> I have some more code locally I haven't sent a patch for
06:29:07 <shapr> I really want cabal-get in 6.6, I think it'll improve community growth.
06:29:09 <JaffaCake> oh, I'm probably conflicted again :(
06:29:17 <dcoutts> :-(
06:29:24 <dcoutts> and he just sent in some test cases
06:29:25 <musasabi> I posted the changes to cabal-devel
06:29:37 <JaffaCake> I think configurations will be important, especially for people who want to have packages that work with both GHC 6.4 and 6.6
06:29:38 <dcoutts> musasabi, yeah I just spotted that
06:29:51 <JaffaCake> musasabi: thanks, will look
06:29:54 <dcoutts> JaffaCake, yes that was musasabi's motivation
06:30:17 <dcoutts> JaffaCake, the moral is post your code early, even if it doesn't work :-)
06:30:25 <JaffaCake> I got hung up on refactoring Distribution.Simple
06:31:31 <musasabi> JaffaCake: I'll post a new patch in 10min with additional compiler(...) support.
06:31:46 <dcoutts> musasabi, that'd be handy
06:31:46 <musasabi> JaffaCake: then I'll wait for merging.
06:31:51 <dcoutts> can we have versions too?
06:31:53 <edwinb> shapr: Yes, I noticed that. Strange that someone considered a half baked draft interesting enough to post ;)
06:31:57 <musasabi> dcoutts: yes.
06:32:01 <dcoutts> ghc(>6.4)
06:32:15 <dcoutts> err, compiler(ghc >= 6.4)
06:32:42 <dcoutts> musasabi, so are configurations mutually exlusive?
06:32:53 <dcoutts> musasabi, or do all matching ones get used/merged?
06:32:57 <JaffaCake> nope, I didn't intend them to be
06:33:22 <JaffaCake> musasabi: no need to wait for merging, you got there first
06:34:29 <dcoutts> JaffaCake, so we merge the fields of configurations?
06:34:44 <JaffaCake> musasabi: I see you changed the syntax of package(dep, version-range)
06:35:05 <dcoutts> yes we thought it was better that way
06:35:45 <JaffaCake> the idea was that you could ask what a particular dependency will be resolved to... not sure you can do that with the new syntax
06:35:45 <dcoutts> it makes the meaning more obvious we thought
06:36:10 <dcoutts> JaffaCake, I'm not sure I follow that
06:36:35 <JaffaCake> eg. if you have build-depends: P < 2.0, and you want to know whether P < 2.0 will be resolved to P-1.0 or P-1.1, you could say package(P < 2.0, >=1.1)
06:37:46 <dcoutts> but we can already say build-depends: P < 2.0
06:38:03 <dcoutts> and then in a configuration say: package(P >= 1.1)
06:38:08 <JaffaCake> yes, but you can't write a configuration that asks what that dependency will resolve to
06:38:43 <dcoutts> doesn't the above express that
06:38:56 * JaffaCake thinks
06:39:08 <dcoutts> package (P >= 1.1) is only activated if P >= 1.1, ie /= 1.0
06:39:21 <dcoutts> and we specified up front that we depend on P < 2.0
06:39:44 <dcoutts> we can also say: package (P < 2.0) && package (P >= 1.1)
06:40:28 <JaffaCake> maybe it's ok then... I was wondering about whether you would need to write conditionals about conditional dependencies
06:41:03 <dcoutts> note that all this makes dep resolution nicely complex :-)
06:41:17 <dcoutts> we'll need kosmikus's backtracking dep resolver
06:41:20 <JaffaCake> yes, but I think you can find a sensible solution
06:41:47 <dcoutts> since fixing one dep can makes us add an additional one
06:41:51 <JaffaCake> cabal-get has some choices to make
06:42:16 <dcoutts> eg once we know we're using P-1.0 or P-1.1 then we can discover we need more deps
06:42:21 <JaffaCake> yes
06:42:29 <JaffaCake> and one set of choices might lead to a conflict
06:42:39 <dcoutts> and one might not be satisfiable and we may need to backtrack
06:42:45 <JaffaCake> yup
06:42:59 <dcoutts> eg we try P-1.1 but if it's not satisfiable we may have to try 1.0
06:43:13 <dcoutts> kosmikus's gentoo package dep resolver does this kind of thing
06:43:26 <JaffaCake> right
06:43:31 * edwardk waves ello.
06:43:39 <dcoutts> (and more since the gentoo package stuff has even more complexity)
06:44:18 <dcoutts> so I suspect we're not going to be able to get dep resolution for cabal-get working for configurations in time for 6.6
06:44:39 <dcoutts> cabal-get/cabal-install
06:44:44 <int-e> is there a timeline for 6.6?
06:44:50 <dcoutts> though we might be able to get cabal-install working soon without configurations
06:45:20 <dcoutts> int-e, yes, initial release candidate by the end of the month
06:45:22 <mux> hey, if you're working on that stuff, make sure to have a cabal command to get the list of the files and directories that are going to be created/installed
06:45:31 <edwardk> good to know
06:45:39 <mux> many packaging systems lack such a thing and yet it makes the lives of people dealing with 3rd party packages of some OSes much easier
06:45:52 <dcoutts> mux, send patches!
06:45:55 <JaffaCake> musasabi: why did you store the configuration BuildInfos in the LBI?  Can't they be regenerated each time?
06:45:57 <mux> ENOTIME, sorry
06:46:14 <edwardk> he
06:46:16 <dcoutts> mux, setup install --dry-run or something
06:46:16 <SamB_XP> can it install in a fake root
06:46:25 <dcoutts> SamB_XP, yes
06:46:37 <dcoutts> we use that for gentoo
06:46:47 <mux> dcoutts: this is GNU specific
06:46:50 <SamB_XP> debian likes that too
06:46:59 <mux> and not entirely satisfying
06:47:04 <dcoutts> mux, what's GNU specific?
06:47:08 <mux> --dry-run
06:47:16 <dcoutts> no it's just a name
06:47:21 <mux> sighs
06:47:22 <dcoutts> darcs uses that too
06:47:35 <mux> yeah cool; but in any case our install(1) doesn't have that
06:47:44 <gds> The "--" long argument convention is a GNU one.
06:47:47 <dcoutts> no, it's not an argument to install
06:47:59 <mux> it's an argument to what then?
06:48:04 <SamB_XP> setup
06:48:04 <dcoutts> I'm suggesting it as an extra flag to cabal setup
06:48:17 <mux> oh, so it doesn't exist anyways? :-)
06:48:27 <JaffaCake> aha dcoutts, I remember the problem with the package() conditionals
06:48:28 <dcoutts> mux, right, I was suggesting a feature
06:48:32 <mux> oki
06:48:34 <dcoutts> JaffaCake, oh yes?
06:49:02 <JaffaCake> so the idea was that you should be able to resolve all the conditionals knowing only the contents of the package database
06:49:25 <dcoutts> of the installed package database?
06:49:34 <JaffaCake> yes
06:49:34 <dcoutts> or the available packages?
06:49:44 <dcoutts> hmm
06:49:48 <JaffaCake> well, yes if you're using cabal-get
06:49:54 <mnislaih> @tell Lemmih I've been working on the breakpoint code
06:49:54 <lambdabot> Consider it noted.
06:50:24 <JaffaCake> if we do it your way, then don't you have to have an iterative process to resolve all the conditionals: fix some packages, then check some more conditionals, then resolve more dependencies etc.
06:50:58 <JaffaCake> and wait till you get to a fixed point?
06:51:21 <dcoutts> hmm
06:52:01 <JaffaCake> put another way, in your scheme we have to resolve build-depends first, and then check the configurations, then resolve more build-depends, then check configurations again, etc.
06:52:09 <dcoutts> right
06:52:10 <dcoutts> so you think we can do it by only looking at what we've already installed if we do what exactly?
06:52:46 <JaffaCake> well, you have to repeat some of the dependencies in the conditionals, that's what I was doing with the two-arg package()
06:52:50 <musasabi> JaffaCake: because I think there may be slow tests for those in the future. Thus I want to avoid renegarating.
06:53:20 <JaffaCake> musasabi: the LBI already caches the available packages
06:53:47 <dcoutts> JaffaCake, so what exactly does the two-arg package() conditional mean?
06:54:17 <JaffaCake> package(D, V) means "if I resolve dependency D against the available packages, does the result lie with range V?"
06:54:39 <JaffaCake> ^within
06:55:09 <vincenz> kowey: pn
06:55:12 <vincenz> kowey: ping
06:55:17 <dcoutts> JaffaCake, and that doesn't need iteration because?
06:55:38 <JaffaCake> because you can decide its truth based on the set of available packages only
06:55:54 <musasabi> Posted
06:55:54 <dcoutts> because presumably we can have more build-depends in the conditional stanza
06:56:33 <dcoutts> so do we not still have to iterate?
06:56:35 <JaffaCake> yes... arguably its a bit strange, because you can have conditionals that test for packages that you don't depend on
06:57:07 <JaffaCake> you don't have to iterate, no
06:57:15 <musasabi> JaffaCake: people may want fancier conditionals in future, thus I wanted to avoid calculating them for each step.
06:57:29 <JaffaCake> musasabi: ok, fair enough
06:57:53 <dcoutts> JaffaCake, package(foo, foo > 1); build-depends: bar
06:57:54 <JaffaCake> musasabi: then we probably don't need to cache the available packages in the LBI too
06:58:02 <dcoutts> JaffaCake, are we thinking about different things?
06:58:29 <JaffaCake> do you mean package(foo, > 1)?
06:59:00 <dcoutts> JaffaCake, eg yes, ok
06:59:03 <dcoutts> eg/er
06:59:34 <JaffaCake> so that's just the same as package (foo>1)
07:00:08 <dcoutts> so package(D, V) means we actually do depend on D
07:00:17 <JaffaCake> no, it's not a dependency
07:00:31 <JaffaCake> it says "if we did depend on D, which version would we get"
07:00:54 <JaffaCake> maybe I only want to depend on D if I can get at least version 2, for example
07:00:57 <musasabi> What is the use case for which the simpler syntax does not work very well?
07:01:20 <musasabi> package(D > 2); build-depends: D
07:01:27 <dcoutts> right
07:02:24 <dcoutts> JaffaCake, so the simpler one covers that no?
07:02:26 <JaffaCake> musasabi: build-depends: P < 2.0; configuration: package(P < 2.0, > 1.1)
07:03:19 <dcoutts> so we unconditinall dep on P < 2.0 and we want to do something different for 1.1 vs 1.2
07:03:43 <dcoutts> so why doesn't this work: build-depends: P < 2.0; configuration: package(P > 1.1)
07:03:45 <JaffaCake> yep... but also I'm not sure about the intended semantics of your simpler version
07:04:07 <musasabi> build-depends: P < 2.0; configuration: package(P > 1.1); ...
07:04:08 <JaffaCake> dcoutts: because you might have P-3.0 installed
07:04:25 <dcoutts> JaffaCake, no but we have to resolve P to < 2.0
07:04:49 <JaffaCake> in that case, how does this work:  package(D > 2); build-depends: D
07:05:00 <JaffaCake> you haven't resolved to anything, so the conditional will fail, right?
07:05:31 <JaffaCake> or do you speculatively depend on D, and then check the conditional?  I'm not sure how that works
07:05:35 <musasabi> JaffaCake: that will mean "If version of D larger than 2 is available then depend on D"
07:06:12 <dcoutts> where as in the earlier case there is an addional constraint of P < 2.0
07:06:13 <JaffaCake> right, then going back to the example we were just taking about, package (P > 1.1) will be true if P-3.0 is available, right?
07:06:20 <musasabi> yes.
07:06:26 <JaffaCake> so that's not what I want
07:06:32 <dcoutts> oh, ok we're thinking of different things
07:06:39 <musasabi> package(P > 1.1) && package(P <= 2.0) ?
07:06:54 <JaffaCake> nope, not good enough
07:07:08 <JaffaCake> that woudl be true if you had both P-1.0 and P-3.0
07:07:55 <dcoutts> musasabi, I assumed that with: "build-depends: P < 2.0; configuration: package (P > 1.2)" that the build-depends would affect the package conditional
07:07:56 <musasabi> I think I understand.
07:08:08 <dcoutts> that it would have to satisfy the build-depends too
07:08:23 <musasabi> dcoutts: that sounds like evil side-effects ;)
07:08:41 <dcoutts> I don't think so
07:08:41 <JaffaCake> yes
07:08:44 <dcoutts> heh
07:09:05 <JaffaCake> well, it at least requires a fixed-point calculation
07:09:19 <musasabi> JaffaCake: would the following "for each package there must be one version that satisfies all the conditionals in a given configuration line" ?
07:09:35 <musasabi> be enough
07:10:08 <JaffaCake> maybe, but it sounds a bit strange
07:10:29 <JaffaCake> hmmm
07:10:30 <edwardk> seems like a good time to whip out a nondeterminism monad
07:10:35 <dcoutts> we generally want to resolve just a single package version for a dep
07:10:51 <dcoutts> rather than ending up depending one multiple versions of a single package
07:11:07 <dcoutts> since that doesn't work yet and will probably only work in ghc at the moment
07:11:08 <JaffaCake> true
07:11:28 <dcoutts> so it's reasonable that a single package must satisfy all constraints
07:11:47 <dcoutts> rather than jsut that there exist packages that satisfy each constraint individually
07:12:40 <dcoutts> JaffaCake, another tricky thing is that it's not obvious if we should install P if it's only optionally depened upon
07:12:46 <dcoutts> if it's already installe then fine
07:12:53 <JaffaCake> yes... you could also argue that the packages we end up depending on should also be "consistent" with the conditionals, i.e. all the conditionals you picked are still true given the packages you ended up depending on
07:13:12 <dcoutts> but for the cabal-install we may be looking at a big graph of not-yet installed packages
07:13:22 <dcoutts> JaffaCake, right
07:13:42 <JaffaCake> dcoutts: the optional dependencies are a bit like the "use" things in Gentoo, right?
07:13:56 <dcoutts> JaffaCake, right, but with USE the user can influence the choice
07:14:10 <JaffaCake> we probably want that here too
07:14:41 <dcoutts> gentoo used to have a mechanism where intalling a package automatically enabled a related use flag
07:14:50 <musasabi> I'll create a "no-multiple versions of the same lib in a conditional" patch.
07:14:51 <JaffaCake> it doesn't still have that?
07:15:00 * JaffaCake thought it worked like that
07:15:04 <kosmikus> dcoutts: not that I've followed this, but is it really necessary to make the cabal dependency language as complex as Gentoo's ?
07:15:05 <dcoutts> so that other packages that had an optional dep would automatically pick it up
07:15:16 <dcoutts> kosmikus, it's not clear :-)
07:15:29 <dcoutts> kosmikus, perhaps you can shed some light on this discussion
07:15:52 <kosmikus> if you can summarize it for me ...
07:15:56 <JaffaCake> musasabi: you'll have to backtrack when evaluating the conditional or something, won't you?
07:16:04 <dcoutts> JaffaCake, no it doesn't anymore because it's very hard to resolve and can even lead to loops or inconsistencies I think
07:16:17 <JaffaCake> I see
07:16:19 <dcoutts> kosmikus, we're talking about conditional deps
07:16:50 <dcoutts> kosmikus, eg you've got a package and you want to say for example that if P > 2.0 is available then I want to depend on it
07:16:58 <JaffaCake> so how does it work now?  Do you have to explicitly say you want things to depend on GTK, or whatever?
07:17:05 <dcoutts> JaffaCake, yes
07:17:19 <dcoutts> JaffaCake, and there is a default set of USE flags and users can override that
07:17:29 <JaffaCake> ok
07:17:31 <musasabi> JaffaCake: I was thinking of adding constraints and see if there is a package satisfying them all.
07:17:45 <dcoutts> JaffaCake, it means that the order in which you merge doesn't affect the deps so much
07:17:48 <musasabi> btw can one use a build-depend like build-depends: 1 < foo < 2 ?
07:18:07 <dcoutts> musasabi, yes, foo > 1, foo < 2
07:18:07 <JaffaCake> right
07:18:23 <musasabi> ok. -> code
07:18:37 <JaffaCake> dcoutts: does that work??
07:18:46 <dcoutts> kosmikus, so we might have: configuration: package(foo > 2.0); build-depends: foo>2.0
07:18:56 <dcoutts> JaffaCake, I think it is supposed to
07:19:02 * JaffaCake is dubious :)
07:19:17 <dcoutts> cabal checks that all the constraints are satisfied I think
07:19:21 <kosmikus> dcoutts: what's a configuration?
07:19:22 <JaffaCake> I think it deals with each dependency in order
07:19:46 <JaffaCake> unless someone has improved it since I wrote that bit...
07:20:11 <dcoutts> kosmikus, so it's an stanza that's protected by a condition. If the condition is satisfed then we get some extra fields
07:20:21 <dcoutts> JaffaCake, ok, maybe :-)
07:20:37 <JaffaCake> dcoutts: version ranges can include && and ||
07:20:40 <kosmikus> dcoutts: so this fragment above means. if we have foo > 2.0, then add it as a dependency?
07:20:48 <JaffaCake> so you say build-depends: foo >1 && <2
07:20:49 <dcoutts> kosmikus, right
07:20:50 <JaffaCake> I think
07:21:16 <dcoutts> JaffaCake, ah ok, and that's treated differently from foo>2, foo<1
07:21:18 <kosmikus> dcoutts: sounds scary, but ok
07:21:29 <dcoutts> JaffaCake, as "," is much like "&&"
07:21:38 <dcoutts> kosmikus, right :-)
07:21:48 <JaffaCake> well, that would make sense, perhaps it should work liie that
07:22:00 <dcoutts> kosmikus, it's a bit like auto use flags
07:22:05 <JaffaCake> brb
07:22:07 <musasabi> How about package(foo > 1 && < 2) ?
07:22:10 <kosmikus> dcoutts: scary because this is exactly the sort of thing that's against Gentoo policy, because the *user* should be able to say what (s)he wants, and not get something dictated by automatic tests
07:22:17 <dcoutts> kosmikus, yes
07:22:20 <kosmikus> dcoutts: yes, evil
07:23:20 <dcoutts> kosmikus, so one use case is fps. if we've got base from ghc-6.6 then we only dep on base. if we're using base from 6.4 then we need to dep on fps externally
07:23:29 <dcoutts> kosmikus, can we do that in a non-evil way?
07:24:54 <dcoutts> kosmikus, configuration: package(base <= 1.0): build-depends: fps>=0.8
07:25:02 <musasabi> dcoutts: configuration: package(stm > 0.5 && <= 2)
07:25:03 <kosmikus> I see
07:25:08 <musasabi> works already.
07:25:15 <dcoutts> the other use case is posix vs win32
07:25:27 <dcoutts> configuration: os(windows): build-depends: Win32
07:25:27 <musasabi> And satisfies what JaffaCake wants.
07:25:53 <kosmikus> dcoutts: this sort of use seems not so evil as I first thought (like adding additional features on such tests)
07:26:01 <dcoutts> kosmikus, right
07:26:22 <dcoutts> kosmikus, so it's not clear if such a conditional should pull in *extra* deps
07:26:51 <kosmikus> dcoutts: but why not simply build-depends: base-6.6 || (base-6.4 && fps>=0.8) ?
07:26:59 <musasabi> kosmikus: one can have use-flag like extra features. Like configuration: my-feature;
07:27:14 <dcoutts> --enable-my-feature
07:27:25 <dcoutts> kosmikus, true
07:27:27 <musasabi> kosmikus: because for many purposes we want to e.g. set build flags.
07:28:34 <kosmikus> musasabi: fair enough
07:28:35 <musasabi> configuration: hdbc || package(hdbc); build-depends: hdbc; ghc-options: -DHAVE_HDBC
07:29:16 <dcoutts> configuration: hsql || package(hsql); build-depends: hsql
07:29:34 <kosmikus> however, it might still make sense to keep the dependency info all in one place
07:29:35 <musasabi> "if the user said --enable-hdbc or hdbc is installed depend on hdbc and give GHC -DHAVE_HDBC"
07:29:45 <shapr> Has anyone tried doing SOAP with Haskell recently?
07:29:51 <dcoutts> musasabi, so in gentoo we'd not automatically dep on hdbc or hsql jsut because it's installed
07:30:12 <dcoutts> musasabi, we'd only do it if USE="hsql" or "hdbc"
07:30:16 <musasabi> dcoutts: then it makes sense to just use configuration: hdbc; ...
07:30:22 <dcoutts> musasabi, right
07:30:38 <dcoutts> musasabi, and if we need one of them...
07:30:47 <dcoutts> build-depends: hsql || hdbc
07:31:21 <kosmikus> if you're done with this, you can create a linux distro based on cabal ;)
07:31:25 <dcoutts> configuration: package(hdbc); ghc-options: -DHAVE_HDBC
07:31:29 <dcoutts> hah
07:31:52 <edwardk> shapr: nope. is there a SOAP api for it?
07:31:56 <dcoutts> kosmikus, so would it be non-evil if the conditionals were only on things we already dep on?
07:32:11 <shapr> edwardk: Not sure. Last I heard Simon Foster was working on one, but I don't know how it went.
07:32:35 <edwardk> hrmm.
07:32:43 <kosmikus> dcoutts: I guess so
07:32:57 <kosmikus> dcoutts: so, you want backtracking too, you say?
07:33:04 <dcoutts> kosmikus, looks like we'll need it
07:33:08 <edwardk> well you have xml stuff in haxml etc, so it shouldn't be too hard to cobble something together that can talk. its just how idiomatic the usage pattern will be thats at issue
07:33:08 <musasabi> kosmikus: the implicit thing will be useful when working with multiple versions of compilers.
07:33:12 <dcoutts> JaffaCake, when you're back, can you remind us of your other use cases so we can see if they pass kosmikus's 'evilnes' test
07:33:47 <kosmikus> dcoutts: heh, that's only my personal opinion
07:34:09 <dcoutts> kosmikus, but you are familiar with the issues and the gentoo dep experience
07:34:17 <JaffaCake> dcoutts: the main ones were in the msg to cabal-devel
07:34:17 <musasabi> kosmikus: configuration: compiler(GHC < 6.6 && >= 6.4); hs-source-dirs: compat-ghc6.4; other-modules: Data.FiniteMap
07:34:18 <kosmikus> in an ideal world, I'd be even more strict than Gentoo in this respect
07:34:56 <kosmikus> I'd like to have everything that's auto-detected in some way (for instance, the ghc version), but makes a difference, be part of a package's full version ...
07:35:02 <shapr> edwardk: iirc, Simon Foster had some problems with xml schemas colliding with Haskell's type system.
07:35:16 <dcoutts> JaffaCake, so we can do "if the base package is <2.0, depend on fps" without configurations
07:35:34 <musasabi> xml schemas = large and non-trivial to map into Haskell
07:35:36 <JaffaCake> we can?
07:35:42 <dcoutts> JaffaCake, build-depends: base>=2.0 || (base<2.0 && fps>=0.8)
07:35:52 <JaffaCake> oh, but we don't have that syntax
07:35:57 <dcoutts> we should!
07:36:00 <dcoutts> gentoo has it
07:36:14 <kosmikus> dcoutts: so that you can see (if you have multiple compilers) that you have "hsplugins-7.0 for fps-1.2 and ghc-6.4" but not "hsplugins-7.0 for fps-1.4 and ghc-6.6" ...
07:36:19 <musasabi> shapr: there is http://www.cin.ufpe.br/~haskell/hwsproxygen/
07:36:20 <JaffaCake> one my original proposals went down that route... we ended up discarding it
07:36:22 <lambdabot> Title: HWSProxyGen: a web services proxy generator for Haskell
07:36:51 <dcoutts> kosmikus, I don't follow that
07:37:00 <kosmikus> dcoutts: not that important
07:37:10 <JaffaCake> dcoutts: how would you add ghc-options with that?
07:37:13 <shapr> Cool, haven't seen that before.
07:37:26 <musasabi> shapr: if you get it working, please tell me :-)
07:37:45 <shapr> Have you tried it on Linux? It says it requires .NET
07:38:00 <dcoutts> JaffaCake, build-depends: hsql || hdbc; configuration package(hsql); ghc-options: -DHAVE_HSQL
07:38:27 <dcoutts> JaffaCake, but crucially here we're only doing a conditional on a package we've already decided to dep on
07:38:42 <JaffaCake> ah, so now conditionals are evaluated relative to the packages chosen by build-depends?
07:38:51 <dcoutts> yes
07:38:57 <musasabi> (not in the pathces)
07:39:08 <JaffaCake> sounds plausible, perhaps
07:39:32 <dcoutts> JaffaCake, got any more tricky cases where we'd want to add deps on things not mentioned in the initial build-depends?
07:39:59 <JaffaCake> how about configuration: os(windows); build-depends: Win32
07:40:10 <musasabi> dcoutts: Optional features.
07:40:24 <JaffaCake> yes, the --enable- things
07:40:55 <dcoutts> but if they're explicitly given and not automagically picked then it's ok
07:41:02 <kosmikus> ok, I think I understand the situation a bit better now.
07:41:05 <dcoutts> like USE flags
07:41:43 <dcoutts> JaffaCake, that's less evil because the os is at least constant
07:41:55 <musasabi> configuration: foo; build-depends: foo > 1.2; ghc-flags: -DUSE_FOO
07:42:05 <kosmikus> if you use || syntax or the different configurations is in principle only a syntactic difference, and both have advantages and disadvantages.
07:42:22 <dcoutts> JaffaCake, the gentoo solution in that case is also pseudo USE flags, "win32? ( Win32 )"
07:42:32 <dcoutts> JaffaCake, or "sparc? ( blah )"
07:42:46 <dcoutts> ie os & arch are use flags
07:42:53 <dcoutts> and you can add deps based on use flags
07:42:56 <JaffaCake> I hate to say it, but we've already explored several variants of this syntax
07:43:28 <JaffaCake> I can dig up the messages on libraries@haskell.org if you like...
07:43:38 * musasabi remembers the discussion
07:43:41 <dcoutts> true, but have we considered the dep resolution much?
07:43:54 <dcoutts> kosmikus knows how tricky it can get :-)
07:44:07 <musasabi> If someone wants to post a list of use cases, I can post a reply how the current patches would implement them.
07:44:10 <JaffaCake> can you define "evil"? :)
07:44:23 * JaffaCake is a bit fuzzy on the good/evil thing
07:44:29 <kosmikus> it's a bit fuzzy
07:44:47 <kosmikus> the basic problem is that people who install the same package get very different things without knowing why
07:45:01 <dcoutts> JaffaCake, the main point I think (kosmikus correct me if I'm wrong) is that we should not automagically pick up extra deps just because they happen to be present at the time of the install
07:45:10 <musasabi> kosmikus: this already happens. Even with package base.
07:45:14 <Philippa> JaffaCake: evil = reverse live, which is bad if you want a live system?
07:45:14 <kosmikus> this is maybe acceptable in cases like different major ghc versions or different platforms, because users are aware that this makes a difference
07:45:37 <kosmikus> but if the presence of some obscure extra lib is tested and then automatically some extra stuff is built, this is asking for trouble ...
07:45:57 <kosmikus> such extra choices should only be made if there's an explicit request (via --enable-xyz) ...
07:46:04 <musasabi> kosmikus: true. But e.g. for database libraries this can make sense.
07:46:10 <JaffaCake> kosmikus: I see (vaguely), but I don't know how to state it formally
07:46:18 <dcoutts> JaffaCake, different install orders that respect the unconditional deps can give different package deps or even introduce extra deps
07:46:34 <musasabi> Most of the time I just want depend on all the database drivers that are present
07:47:11 <dcoutts> JaffaCake, for this viewpoint you want to imagine instaling a big heirarchy of packages rather than just one at a time
07:47:27 <dcoutts> and figure out what all the final deps will be
07:47:55 <JaffaCake> I can see that if P optionally depends on Q, then it matters what order you install them in
07:48:05 <dcoutts> right
07:48:32 <dcoutts> gentoo solves that by saing ahead of time, I always want to pick up optional deps on Q or never
07:48:38 <JaffaCake> and maybe that's not as bad as if P chooses whether to depend on Q or not based on the version of another dependency R
07:48:55 <JaffaCake> oops, I mean "worse than"
07:50:31 <JaffaCake> because in that case, there's no choice about ordering: R first, then possibly Q, then P
07:50:49 <JaffaCake> maybe it's possible to formalise "order doesn't matter"?
07:53:55 <musasabi> Or simply don't use "configuration: package(foo)" like dependencies if you are not sure it is the right way.
07:55:06 <JaffaCake> if we require that the packages referred to in a conditional can only be those from the top-level build-depends, that makes things a bit less evil, I think.
07:55:13 <dcoutts> right
07:55:26 <dcoutts> and can't add aditional deps?
07:55:55 <dcoutts> || deps should cover most of the cases where you'd want that I think.
07:56:07 <JaffaCake> you can still add more build-depends, yes
07:56:09 <kosmikus> what's the semantics of the configurations? can they be nested and grouped? if multiple configurations apply, which one is chosen? ...
07:56:15 <dcoutts> dealing with || deps is not that hard, right kosmikus?
07:56:19 <dcoutts> it's backtracking
07:56:23 <musasabi> JaffaCake: I think it makes sense to allow extra dependencies. Although it is slightly evil having a hdbc-connect-any package that simply picks the installed packages is useful.
07:56:29 <JaffaCake> kosmikus: no nesting, choose all that match
07:56:39 <dcoutts> kosmikus, all fields from matching ones are merged
07:56:46 <musasabi> +it is
07:56:47 <kosmikus> ok
07:57:12 <musasabi> should probably sleep for a while soonish
07:57:30 <kosmikus> || don't imply backtracking automatically. in Gentoo, the choice is made at the point where the || dep is encountered, and then the resolver is committed to that choice.
07:57:55 <JaffaCake> surely || is evil?
07:58:15 <JaffaCake> or does it only depend on the use flags that the user has set?
07:58:17 <kosmikus> yes, by my definition it is.
07:58:46 <musasabi> kosmikus: In the current configuration patches the language is pure, thus "||" can be simply resolved by eval (COr a b ) = eval a || eval b
07:58:53 <dcoutts> kosmikus, || is evil? why?
07:59:58 <kosmikus> it can be used in evil ways, at least. you aren't always aware of a choice, and it can be that you get a less functional package than you wanted because you weren't.
08:01:00 <musasabi> kosmikus: is using autoconf and using that to do the configuration better? That is the alternative usually.
08:01:10 <kosmikus> the idea is that || is used (again fuzzy, of course) only in situations where the end result isn't really different. for instance, ensure that one text editor is available, or one sendmail tool, or one Haskell-98 compiler.
08:01:24 <dcoutts> kosmikus, right
08:01:31 <dcoutts> where user choice is not important
08:01:35 <dcoutts> like the fps case
08:01:42 <dcoutts> but not the hdbc vs hsql case
08:01:54 <dcoutts> in the latter the user wants to control which one we pick
08:02:04 <dcoutts> if we need one or the other
08:02:22 <JaffaCake> then it should be selected with an --enable flag
08:02:47 <kosmikus> musasabi: autoconf-based build systems also often include features based on presence of libraries etc. Gentoo usually patches such files ...
08:02:49 <dcoutts> and if we must have one or the other and you do not enable either?
08:02:54 <JaffaCake> I repeat my suggestion: conditionals can only refer to packages from the top-level build-depends
08:03:03 <dcoutts> JaffaCake, that's probably ok
08:03:15 <musasabi> JaffaCake: how about making that as a strong suggestion in the docs?
08:03:36 <JaffaCake> and possibly emit a warning from Cabal, I'd go with that
08:03:58 <dcoutts> hmm, if we allow it at all, it stores up problems for cabal-install
08:04:52 * musasabi still would like to have the possiblity of a convenience packages for things like database-connections (which hdbc-backends are supported), but make it clear that it can conflict.
08:05:18 <dcoutts> musasabi, what'd that do?
08:05:53 <musasabi> dcoutts: cabal install builds a DAG of the depends and uses that to install the packages? Simply add optional dependencies to that graph as edges and complain if there are any cycles.
08:06:28 <JaffaCake> so optional dependencies would always be installed?
08:06:47 <dcoutts> one nice aspect of the gentoo style is that the deps are specified explictly in one place, rather than as a decision procedure, "if this then dep on that"
08:08:23 <musasabi> What would be a good way to build a convenience database connection package that just picks up all the backends available?
08:08:55 <dcoutts> musasabi, you're talking about the hdbc-postgresql, hdbc-sqlite etc choice?
08:09:05 <JaffaCake> musasabi: slightly OT, but I don't see where performConfigurations is defined in your patch
08:09:40 <musasabi> JaffaCake: Distribution.Simple.Configuration (it missed from darcs, but added it in the later patch there)
08:10:02 <musasabi> dcoutts: yes. "depend on all of them that possible"
08:10:12 <JaffaCake> ah, thanks
08:10:47 <JaffaCake> musasabi: so that's an example of an evil dep, because you have to say configuration: package(P); build-depends:P
08:11:00 <dcoutts> musasabi, so in gentoo it'd be: DEPEND="postgresql? ( hdbc-postgresql ) sqlite? ( hdbc-sqlite )"
08:11:05 <musasabi> But I agree that optional dependencies are bad form in most places and their use should be discouraged, but probably not banned.
08:11:14 <dcoutts> musasabi, and the user has to pick one or more
08:11:39 <kosmikus> dcoutts: as long as the decision procedure is easy (and doesn't involve arbitrary computation), it's pretty equivalent whether you write "configuration: if foo then ...; configuration: if bar then ..." or " foo? ( ... ) bar? ( ... )"
08:11:42 <JaffaCake> dcoutts: how do you express the "one or more" part?
08:11:57 <musasabi> dcoutts: the lazy user just installs the package and wonders "why does this not work even if I have the relevant drivers installed"
08:11:58 <dcoutts> JaffaCake, that's a good question. :-) kosmikus, how do we do that?
08:12:07 <dcoutts> musasabi, I'd distinguish between optional deps and auto-optional deps
08:12:18 <kosmikus> one or more of what?
08:12:35 <dcoutts> kosmikus, suppose we want a package that can work with any of the hsql backends
08:12:51 <dcoutts> kosmikus, we can say: DEPEND="postgresql? ( hdbc-postgresql ) sqlite? ( hdbc-sqlite )"
08:13:01 <dcoutts> kosmikus, but how do we say we need at least one of those?
08:13:15 <emertens> just depend on hdbc?
08:13:34 <dcoutts> kosmikus, an alternative is || ( hdbc-postgresql hdbc-sqlite ) but then the user gets less choice
08:13:44 <dcoutts> emertens, the backends provide the connection functions
08:13:53 <dcoutts> emertens, so depending on the main package doesn't help
08:14:10 <kosmikus> in Gentoo, this would be something like "|| ( use1? (backend1) use2? (backend2) use3? (backend3) default-backend )" for the default, I think
08:14:11 <emertens> but you can't very well know which backend they need?
08:14:30 <dcoutts> emertens, right, it needs help from the user to decide
08:14:35 <musasabi> kosmikus: the problem is that outside gentoo there are no use-flags.
08:14:40 <kosmikus> note though that Gentoo certainly isn't perfect ...
08:15:54 <lmbdwr> oi
08:16:00 <dcoutts> JaffaCake, we can have a OneOf [...] syntax or something perhaps
08:16:30 <dcoutts> JaffaCake, for the hdbc case the user certainly needs to know which one to pick, it can't be done automatically, since they user has to actually setup the appropriate db server.
08:16:56 <JaffaCake> or configuration: !package(P) && !package(Q)...; build-depends: something-that-does-not-exist :)
08:17:02 <dcoutts> so we need to express a dep on one where the user must pick
08:17:09 <kosmikus> JaffaCake: possible
08:17:24 <dcoutts> heh, I can imageine the error message :-)
08:17:44 <dcoutts> gentoo usually tries to not ask the user but pick a sensible default
08:18:16 <musasabi> btw limiting configuration package(..) to build-deps already in the main part does not help.
08:18:22 <dcoutts> so it might default to sqlite and you'd need to specify --enable-mysql to get the other one
08:18:44 <dcoutts> musasabi, got some example cases?
08:18:58 <musasabi> dcoutts: yes. Writing it now (non-trivial).
08:19:03 <dcoutts> :-)
08:20:55 <kosmikus> I'm away for a while ...
08:21:18 <ProfTeggy> Have a nice holiday, kosmikus
08:21:34 <kosmikus> ProfTeggy: no, not that long ;)
08:21:42 <ProfTeggy> hehe
08:21:47 <kosmikus> I was on vacation last week ...
08:21:55 <emertens> freebsd uses those ncurses interfaces to prompt the user when there are decisions to be made
08:24:20 <musasabi> dcoutts: http://youzen.b2.fi/~musasabi/t.txt
08:25:05 <jgrimes> anyone know of an example of a multi-line repl?
08:26:47 <emertens> bash?
08:27:15 <jgrimes> in haskell..
08:27:23 <jgrimes> :p
08:29:22 <vincenz> lambdabot
08:30:45 <jgrimes> hm... I'm really looking for something that uses getContents or the like,  rather than reading line by line
08:31:35 <emertens> the the compiler?
08:31:53 <emertens> s/the/like
08:32:03 <jgrimes> but thats not really an repl
08:32:30 <jgrimes> I think I'm just going to read line by line and look for an end token
08:32:49 <jgrimes> I think once I figure out IO error handling I can do it with getContents
08:35:52 <JaffaCake> musasabi: I don't see why you need A in that example, with just B and C you can get a different version of B depending on whether you upgrade C or not first
08:36:44 <JaffaCake> there's not much we can do about that, I think - it's not an optional dependency, just a different way of compilng B based on what version of C is installed
08:38:14 <musasabi> Maybe write in the documentation something like "Optional dependencies on packages will cause problems and make the package dependent on the order other packages are installed in. Using this feature is experimental and it may be removed in the future."
08:39:17 <JaffaCake> oh, I don't think it'll be removed, it's too useful :)
08:39:17 <dcoutts> musasabi, can we do with just simple || deps to start with? ie ones where it's not really important for the user to make a choice?
08:39:26 <dcoutts> that'd cover the fps/base issue
08:39:41 <dcoutts> we can extend it for the hdbc backend case later perhsp
08:39:58 * JaffaCake isn't sure about ||
08:40:13 <dcoutts> in the fps case there is no need even to know which package we eneded up using
08:40:40 <dcoutts> in more complex cases where the module name has changed then we need to know which packages we eneded up getting built against
08:40:51 <JaffaCake> right
08:41:04 <musasabi> || has many good uses. (e.g. combinations of --enable-flags )
08:41:20 <JaffaCake> which reminds me, cabal should probably add -DPKG_base=200, or something
08:41:59 <dcoutts> JaffaCake, right, then we could test that without needing a configuration to add ghc-options: -DHAVE_FPS_IN_BASE
08:42:04 <JaffaCake> what can you do with || that you can't do with conditionals?  or are you proposing not to have conditionals?
08:42:15 <dcoutts> can we get away without them?
08:42:30 <dcoutts> I think all but the e) case in your email can be covered
08:42:33 <musasabi> JaffaCake: the version syntax may be too general for that (e.g. 2.0 = 200, 1.3.5.2 = 1352)
08:42:37 <JaffaCake> not without adding lots of new syntax to build-depends, I think
08:42:38 <dcoutts> and e) is the dodgy one
08:42:59 <dcoutts> build-depends: os(win32)? Win32>1.1
08:43:02 <JaffaCake> musasabi: that's the problem, yes.  It's why we haven't done it yet
08:43:02 <musasabi> JaffaCake: and for cases where we don't need CPP avoiding that should be better.
08:43:50 <JaffaCake> musasabi: but maybe we should bit the bullet and declare that the 3rd version component isn't important
08:44:09 <JaffaCake> and the 2nd component only goes up to 99... :)
08:44:52 <musasabi> JaffaCake: but is it really a good idea to encourage the use of CPP?
08:45:06 <musasabi> If there exists a clean solution without it.
08:45:09 <JaffaCake> dcoutts: how would you do the configuration: debug; ghc-options: -DDEBUG?
08:45:09 <dcoutts> JaffaCake, oops, I mean d) in your email is the tricky one. "build executable E only if package P is available"
08:45:52 <dcoutts> JaffaCake, "ghc-options: debug? ( -DDEBUG )" perhaps. hmm
08:46:10 <JaffaCake> ew
08:46:12 <musasabi> Are there cases that the current patches don't solve in an adequate way? (The discussions seems to be more about them allowing too many things)
08:47:09 <JaffaCake> I think the current patches are ok, with some warning or restriction on what packages can be referred to in conditionals
08:48:05 <dcoutts> ok, so would it be package(P>1.0) or the package(P, >1.0) ?
08:48:07 <JaffaCake> musasabi: what's the "clean solution" you were referring to above?
08:48:40 <JaffaCake> dcoutts, I think we resolved that - it's package(P >1.1 && <2.0)
08:49:10 <dcoutts> JaffaCake, is that different from package(P>1.1) && package(P<2.0)  ?
08:49:22 <musasabi> dcoutts: yes.
08:49:25 <dcoutts> how?
08:49:27 <JaffaCake> that depends how you define the latter
08:49:35 <musasabi> dcoutts: currently all clauses are evaluated separately.
08:49:41 <JaffaCake> which is nice
08:49:46 <dcoutts> JaffaCake, we already have the latter
08:49:52 <dcoutts> according to the syntax
08:49:58 <JaffaCake> but it doesn't do what you want it to :)
08:50:02 <dcoutts> heh
08:50:17 <musasabi> "package(P >1.1 && <2.0)" means "there exists package P with version that is >1.1 && 2.0"
08:50:23 <JaffaCake> and it doesn't do the same as package (P>1.1 && <2.0)
08:50:35 <dcoutts> if the other meaning is useless then...
08:50:53 <musasabi> "package(P>1.1) && package(P<2.0)" "there exists package P with version > 1.1 and there exists package P with version < 2.0"
08:51:10 <dcoutts> right which is never useful, is it
08:51:11 <dcoutts> ?
08:51:41 <dcoutts> so why not define "package(P>1.1) && package(P<2.0)" to mean the sensible thing and not need package(P >1 <2) syntax
08:51:58 <musasabi> dcoutts: it might be. It is a simple logic language. Which means that one can construct un-usefull sentences with it.
08:52:22 <JaffaCake> dcoutts: because it means complicating the semantics of the conditionals, that's all
08:52:30 <musasabi> dcoutts: because such a language has more complex semantics.
08:53:04 <musasabi> The current one has trivial semantics.
08:53:07 <dcoutts> hmm, I think it's sensible that when we talk about a package we always mean one version of a package
08:53:20 <dcoutts> I think people will make mistakes
08:53:27 <JaffaCake> possibly
08:53:39 <dcoutts> if they can't make mistakes then it's easier :-)
08:53:43 <musasabi> dcoutts: good documentation might help the matters.
08:53:56 <dcoutts> people do not read it
08:54:12 <JaffaCake> but one choice is to resolve the global build-depends first, then you only have one version of each package
08:54:22 <dcoutts> right
08:54:25 <JaffaCake> use these packages to resolve the conditionals
08:54:37 <musasabi> people can also write configuration: foo || !(bar && foo)
08:55:53 <musasabi> We can limit things, but making things smarter to avoid mistakes will also make them more complex.
08:56:55 <dcoutts> while I'm thinking aboutit, we should ask one of the debian people about optional deps. They have to statically resolve all build-time-optional deps.
08:57:01 <dcoutts> Igloo, ping
08:57:08 <JaffaCake> musasabi: so what about doing what I suggested, resolving buidl-depends first?  I think that solves dcoutts' problems too
08:57:24 <Igloo> Hello
08:57:29 <JaffaCake> hi Igloo
08:58:17 <dcoutts> Igloo, so if you've got a package that has an optional gui that's built into the same lib/binary you basically have to decide to use it or not. Or manually split the gui into it's own binary package right?
08:58:26 <musasabi> JaffaCake: in that case we would have different behaviour depending on whether packages in package(...) would be in the build-depends or not.
08:59:04 <JaffaCake> musasabi: I think you basically have to restrict the conditionals to only refer to packages in the top-level build-depends, then
08:59:04 <Igloo> Yes
08:59:31 <musasabi> JaffaCake: which kills the hdbc example.
08:59:33 <dcoutts> Igloo, or if we had a package that could at build time use either hsql or hdbc then for the .deb package you'd just have to choose. Or hack the package to make a common and two backends.
08:59:34 <Igloo> Optional is fairly easy, as we'd probably just select all options. Choices would be more of a headache (both for Debian and generally)
08:59:45 <JaffaCake> musasabi: just means you have to use --enable flags for hdbc
08:59:52 <JaffaCake> which isn't such a bad thing
08:59:54 <musasabi> yes, which is a pain
09:00:02 <JaffaCake> :) ok
09:00:28 <JaffaCake> I have to go, later folks
09:00:35 <dcoutts> ok bye JaffaCake
09:00:42 <musasabi> it becomes a pain if it is hdbc (4 enables), network-alt (1 enable), fps (1 enable), etc
09:01:02 <dcoutts> so inconsequential optinal deps are ok since debian can jsut statically pick one, eg the fps in base issue
09:01:16 <dcoutts> err that's not optional, rather it's conditional
09:01:40 <emertens> optinal is like a combination of optional and optimal :)
09:01:56 <dcoutts> base>1.0 || ( base<=1.0 && fps>=0.8 )
09:02:11 <dcoutts> so that case is easy for debain
09:02:20 <emertens> "optinally you'd have fps>=0.8" :)
09:02:22 <dcoutts> as it just depends on the version of ghc that it's built with
09:03:47 <dcoutts> musasabi, so how about if we only allow conditional package tests on things in build-depends ?
09:03:56 <dcoutts> musasabi, how many cases would that exclude?
09:04:02 <dcoutts> we could do the fps one
09:04:15 <musasabi> dcoutts: the hdbc example.
09:04:40 <dcoutts> build-depends: base; configuration: package(base<=1.0); build-depends: fps>0.8
09:04:43 <dcoutts> musasabi, right
09:04:51 <dcoutts> and that case is tricky for various reasons
09:05:09 <dcoutts> since it really needs user choice
09:05:15 <dcoutts> and can't be done for a binary package
09:05:45 <musasabi> phone
09:06:24 <musasabi> dcoutts: how is the multi-version resolved in build-depends?
09:06:38 <musasabi> e.g. build-depends: foo > 1, foo < 2 ?
09:07:03 <dcoutts> musasabi, we must pick a foo that satisfies all constraints
09:07:13 <musasabi> "package(foo > 1) && package (foo < 2)" should do the same.
09:07:22 <dcoutts> and if there is any remaining choice we usually pick the latest version
09:07:22 <musasabi> dcoutts: is that actually done?
09:07:27 <dcoutts> not sure
09:07:38 <dcoutts> but it should be that way imho
09:07:53 <dcoutts> in practice package deps are not that complex yet
09:08:08 <dcoutts> so we've not had it break yet
09:08:24 <dcoutts> cabal does pick one version in the end
09:08:40 <dcoutts> but I'm not sure if it's currently guaranteed to satisfy all the constraints
09:09:01 <musasabi> I think it considers them one by one.
09:09:40 <musasabi> dcoutts: "build-depends: foo > 1, foo < 2" generates two -pfoo lines.
09:09:48 <dcoutts> hah
09:09:49 <musasabi> so it is separate.
09:09:51 <dcoutts> right
09:09:57 <dcoutts> I think that's wrong semantics
09:10:12 <musasabi> dcoutts: I think it is simpler.
09:10:14 <dcoutts> I should open a bug on it
09:10:34 <dcoutts> so you want it to be foo >1 && foo < 2
09:10:50 <dcoutts> I'm suggesting that "," really is &&
09:10:50 <musasabi> Of course people not making mistakes on it can be seen as a good thing.
09:11:00 <musasabi> "foo > 1 && < 2" is the supported syntax.
09:11:25 <emertens> how do I ask lambdabot what Either is an instance of
09:11:31 <dcoutts> is there any use case for "," not being && ?
09:11:39 <musasabi> I'll try to write about my pointes with regards to that to cabal-devel - should be clearer.
09:11:50 <musasabi> dcoutts: we don't want to break all existing packages.
09:11:50 <dcoutts> musasabi, ta
09:11:59 <dcoutts> musasabi, I don't think any will break
09:12:05 <dcoutts> none actually do this
09:12:11 <dcoutts> as it'd currently break
09:12:33 <emertens> I don't remember progress inviting backwards-compatibility to the party
09:12:44 <emertens> ;)
09:14:24 <stw> @pl \ x -> x * x
09:14:24 <lambdabot> join (*)
09:14:52 <emertens> (^2)
09:15:06 <stw> yes i'm just testing lambdabot...
09:21:30 <jgrimes> does lookup always return the first match it finds (if there is a match)
09:25:11 <Lemmih> jgrimes: Yes.
09:25:11 <lambdabot> Lemmih: You have 1 new message. '/msg lambdabot @messages' to read it.
09:25:18 <jgrimes> Lemmih: cool, thanks.
09:31:58 <SyntaxNinja> is there a library to get the arch and such yet? like targetArch in ghc code?
09:32:22 <musasabi> SyntaxNinja: System.Info
09:37:52 <SyntaxNinja> thanks
09:42:42 <agocorona> @fortune
09:42:43 <lambdabot> Today is National Existential Ennui Awareness Day.
09:42:53 <dcoutts> SyntaxNinja, your input on the package constraint semanics issue would be apreciated
09:45:18 <SyntaxNinja> dcoutts: is this for the configurations thread?
09:45:53 <dcoutts> SyntaxNinja, musasabi sent an email to cabal-devel, new thread
09:46:04 <dcoutts> but arising out of the configurations thread
09:52:18 <SyntaxNinja> musasabi: you're making my head hurt
09:53:06 <SyntaxNinja> I didn't even know remember that parser could do this:  foo > 1 && < 3
09:53:31 <musasabi> it is very usefull
09:56:13 <dcoutts> SyntaxNinja, yeah, it's that version range thing, it can use && ||
09:56:42 <dcoutts> SyntaxNinja, the code says:
09:56:49 <dcoutts>         -- ToDo: are these too general?
09:56:49 <dcoutts>   | UnionVersionRanges      VersionRange VersionRange
09:56:49 <dcoutts>   | IntersectVersionRanges  VersionRange VersionRange
09:57:00 <SyntaxNinja> yeah, I think I implemented the original version, and simon redid it.
09:57:01 <dcoutts> I like the TODO comment :-)
09:57:15 <lispy> wouldn't 1 < foo < 3, be a bit more natural though?
09:57:25 <SyntaxNinja> -- ToDo: global warming: Problem, or just Theory?
09:57:28 <dcoutts> more tricky to parse
09:57:32 <dcoutts> hah
09:58:07 <lispy> dcoutts: fair enough
09:58:26 <dcoutts> SyntaxNinja, so we had a long discussion here eariler about wether the proposed configurations might be too general and pose problems for dep resolution
09:59:02 <dcoutts> we've been considering a restrction that a package conditional can only mention packages that are already in the build-depends
09:59:14 <musasabi> dcoutts: but that doesn't remove the problem.
09:59:24 <musasabi> (see the t.txt example)
09:59:34 <dcoutts> musasabi, that's independent isn't it?
09:59:45 <dcoutts> sorry, I've lost the url for that
09:59:50 <dcoutts> can you paste it again?
09:59:58 <musasabi> http://youzen.b2.fi/~musasabi/t.txt
10:00:02 <dcoutts> ta
10:00:30 <musasabi> I still think the warning in documentation is the way to go.
10:00:51 <SyntaxNinja> can smoeone clearly state the question? :)
10:01:09 <dcoutts> SyntaxNinja, there's a bunch of relates issues :-)
10:01:22 <dcoutts> musasabi, do we have a simple case?
10:01:41 <SyntaxNinja> if you restrict conditionals to the packages in the build-depends, then you can do the kinds of conditional dependencies we're looking for, right? like turning on the unix package for windows.
10:01:48 <musasabi> SyntaxNinja: mostly 1) is the configuration stuff too powerfull, 2) what are the semantics (as discussed in the email)
10:02:04 <dcoutts> SyntaxNinja, no, because that's not a package conditional, that's an os conditional, that's ok
10:02:16 <dcoutts> because the os is constant, the available packages are not
10:02:28 <musasabi> dcoutts: that was the simplest case I know. It just shows that limiting to global build-depends does not solve the problem.
10:02:44 <SyntaxNinja> oh I see.
10:03:04 <SyntaxNinja> man. I knew configurations would be a can of worms (or two)
10:03:22 <dcoutts> musasabi, I'm not sure that case is that bad, unless we add more build depends in that "problem-here" one
10:03:39 <SyntaxNinja> maybe we should use hsplugins and just have "build-depends: main :: IO ()\nif os == ..."
10:04:06 <musasabi> dcoutts: well it could have "build-depend: D" there if it makes you more happy.
10:04:11 <dcoutts> musasabi, we always have the problem that upgrading in different orders can give packages compiled against differnt versions
10:05:03 <dcoutts> musasabi, eg A-1.0, B-1.0 and B-2.0, with A deps on B
10:05:22 <dcoutts> musasabi, depending on which order we install those A gets built against B-1.0 or 2.0
10:05:24 <musasabi> Limiting to build-depends does not change things for packages which don't depend on non-build-depends. And thus it would not really make those packages any safer.
10:05:25 <dcoutts> that's ok
10:05:45 * dcoutts tries to parse that
10:06:05 * dcoutts fails
10:06:11 <SyntaxNinja> OK, I suggest summarizing a few of the issues in more detail, and including that .txt file, along w/ explanation, and CC the cafe list or something.  some language guru will appear and tell us exactly what we should do.  summarizing things in email will help because we'll have to document what we do here anyway, so deciding on IRC is a losing battle.
10:06:14 <dcoutts> musasabi, sorry, I don't follow
10:06:30 * dcoutts agrees with SyntaxNinja 
10:06:55 <musasabi> ok. Lets continue on the ML.
10:06:57 <SyntaxNinja> maybe we should just make hte .cabal file a haskell program! :)
10:07:00 <SyntaxNinja> cool. thanks.
10:07:12 <musasabi> dcoutts: can you comment on the tautology thing there?
10:07:25 <dcoutts> on the mailing list, yes
10:07:41 <dcoutts> I replied about the semantics of foo > 1, foo < 2
10:08:37 <musasabi> dcoutts: so "configuration: (package(foo > 10) || flag) || (package(foo < 10) || !flag)" should fail?
10:08:42 <dcoutts> SyntaxNinja, one thing we might want to avoid is having a package pick up extra deps merely because they're available. Gentoo goes to some lengths to avoid this because it makes the merge order highly significant which is rather unintuitive.
10:08:52 <kosmikus> regarding that last question I think I agree with musasabi. you probably want to distinguish between a ranged dependency and the two single ones
10:10:21 <dcoutts> musasabi, no, if flag is true then it's ok. if flag is true then foo is irrelevant
10:10:33 <musasabi> dcoutts: and if the flag is false?
10:10:40 <dcoutts> perhaps you mean && rather than ||
10:10:50 <musasabi> foo is irrelevant in any case.
10:10:51 <dcoutts> then !flag is true and it's also ok
10:11:07 <dcoutts> so that configuration is just True
10:11:23 <musasabi> So in which cases do we actually and in which order check that they are satisfiable?
10:12:00 <dcoutts> well we know which foo we've picked so we just evaluate the expression
10:14:59 <musasabi> dcoutts: so how about:
10:15:44 <musasabi> "configuration: ((package(foo > 10) || flag) || (package(foo < 10) || !flag)) && package(foo) " if foo is installed.
10:15:58 <musasabi> dcoutts: we have 1) foo > 10, 2) foo < 10, 3) foo any.
10:16:01 <neonka> i am begining with haskell and i don't get it, how to compile exe from hs :( i :cd to the directory with main.hs and type --make main.hs -o main.exe and nothing is created
10:16:43 <musasabi> dcoutts: of course we can move the constraints up in the proof, but that seems to have non-trivial semantics.
10:17:13 <dcoutts> musasabi, so you want to know if the condition is true in the 3 cases?
10:18:10 <musasabi> dcoutts: yes. and e.g. foo-1 and foo-20 are installed. Or do we just try for all possible selections of packages (which is probably exponential in time)
10:18:17 <dcoutts> musasabi, I don't understand 3), you said foo is installed, so we must know which version we installed
10:18:45 <musasabi> dcoutts: there can be multiple installed versions.
10:18:55 <dcoutts> ok, versons
10:19:17 <musasabi> hmm, the main build-depend could have limited it to one best-matching version.
10:19:27 <dcoutts> the point is if we fix which version we pick when we look at build-depends then evaluating the configuration condition is easy to evaluate
10:20:07 <dcoutts> so if we build-depends: foo and we've got foo-1 and foo-20, then cabal picks foo-20
10:20:20 <musasabi> point
10:20:24 <dcoutts> so if we evaluate the condition, then it's True
10:20:34 <dcoutts> since package(foo > 10) is true
10:20:55 <musasabi> So it is about "there exists a version" vs "we have selected the version"
10:21:02 <dcoutts> right
10:21:21 <dcoutts> that's if we restrict it to packages mentioned in build-depends
10:21:33 <dcoutts> and in that case package(foo) is irrelevant
10:21:43 <musasabi> yes
10:21:51 <dcoutts> it's only interesting for package(foo > 1.0)
10:22:03 <dcoutts> with a version constraint
10:22:46 <dcoutts> then if we introduce more build-depends inside that configuration, then those must be consistent with the top build-depends imho
10:22:50 <dcoutts> or it's unsatisfiable
10:23:07 <dcoutts> that's another reason for foo >1, foo <2 to mean what I think it should mean
10:23:22 <dcoutts> but perhaps that'd just be an error again
10:23:27 <musasabi> dcoutts: optional things should be able to refine build-depends.
10:23:43 <dcoutts> to add something in build-depends that duplicates something in the top level one
10:23:58 <dcoutts> musasabi, I thought it added to it, not replaced it
10:24:08 <musasabi> dcoutts: think about "configuration: debug; build-depend: HUnit;" configuration: package(HUnit > 1.0); ghc-options: ..."
10:25:13 <dcoutts> that's ok isn't it?
10:25:20 <dcoutts> oh, hmm
10:25:26 <dcoutts> hmm
10:25:37 <musasabi> HUnit is not in the global build depends.
10:25:39 <dcoutts> as HUnit isn't mentioned in the top level, yes
10:25:57 <dcoutts> since you're not doing nested configurations
10:26:05 <dcoutts> aargh
10:26:18 <dcoutts> SyntaxNinja, yes, it's a can of worms.
10:26:24 <musasabi> with the original semantics that works cleanly.
10:26:41 <dcoutts> true, but it also allows other unpleasent things
10:27:01 <dcoutts> musasabi, and it depends on which order we evaluate the configurations
10:27:19 <dcoutts> since they add to the set of packages
10:27:38 <dcoutts> I rather like the 'pure' style
10:27:47 <dcoutts> where you declare the depends in one place
10:27:52 <dcoutts> with embeded conditonals
10:28:15 <dcoutts> though it doesn't work so well for ghc-options that depend on things
10:28:44 <musasabi> dcoutts: actually with my original semantics the order is irrelevant
10:29:02 <dcoutts> musasabi, oh? how was that?
10:29:24 <dcoutts> oh because it only depended on what packages were availble
10:29:31 <dcoutts> not which ones were going to be used
10:29:34 <musasabi> dcoutts: "configuration: package(HUnit > 1.0)" does not depend on whether HUnit is in the build-depends.
10:29:42 <musasabi> yes.
10:29:53 <musasabi> Thus solves the ordering issue.
10:30:26 <dcoutts> but it doesn't do what you want most of the time
10:30:42 <dcoutts> as it adds the ghc-options even if we're not using debug
10:31:15 <musasabi> dcoutts: one can also do  "configuration: debug && package(HUnit > 1.0); ghc-options: ..." if one wants.
10:31:50 <musasabi> dcoutts: and it is probably useful even without that one since #ifdef HUNIT_11 is inside #ifdef HAVE_HUNIT probably.
10:31:54 <dcoutts> sure, though it gets more complex, as we might actually be using HUnit 1.0
10:32:04 <dcoutts> but the HUnit-1.2 is available but not used
10:32:37 <dcoutts> so the configuration test becomes more complex to get it right
10:33:07 <musasabi> only if there is a version limitation elsewhere.
10:33:13 <dcoutts> right
10:33:29 <dcoutts> but that could even be in another package
10:33:59 <dcoutts> since we might dep on another package that needs hunit < 1.0
10:34:15 <dcoutts> and we need to pick one version of the package
10:34:30 <dcoutts> cabal currently doesn't do this correctly
10:34:37 <musasabi> true
10:34:48 <musasabi> Getting it right seems quite complex
10:35:30 <dcoutts> if we depend on a package via two dep paths then we need to pick a consitent version
10:35:34 <musasabi> I think configurations should work in the same way as build-depends. Thus either both or neither should change. But I don't know a good model to change into.
10:36:50 <musasabi> Seems that using build-deps creates problems with ordering.
10:37:22 <musasabi> The current semantics are the most easy ones - but they make it easy to shoot oneself in the foot.
10:37:47 <dcoutts> right
10:38:01 <dcoutts> and makes it hard for a dep resolver
10:38:59 <musasabi> dcoutts: as an interrim solution the dep resolver can tell "package uses dubious optional package-dependencies, refusing to play with it" ;)
10:39:33 <dcoutts> hmm, I'd rather start with a conservative intrim solution
10:39:58 <dcoutts> that covers the immediate problem of modules moving between packages
10:39:59 <musasabi> dcoutts: how about telling "package(...) may go away" ?
10:40:42 <musasabi> dcoutts: one can simulate that with compiler(...) things, although slightly more pain.
10:42:27 <dcoutts> musasabi, using compiler is even more ugly methinks
10:43:05 <dcoutts> we really do dep on either base-1.1 or (base-1.0 and fps-0.8)
10:43:39 <musasabi> true
10:43:48 <dcoutts> which can be a configuration based on compiler, but that's only because we know that base-1.1 comes with ghc-6.6
10:44:04 <dcoutts> so it's either a configuration based on the base version
10:44:08 <dcoutts> or it's a || dep
10:44:14 <dcoutts> I rather like || deps
10:44:30 <dcoutts> but it's sort of opposite to the general configurations thing
10:44:36 <musasabi> yes
10:44:46 <musasabi> and does not help if one needs to actually do something
10:44:58 <dcoutts> "do something" ?
10:45:25 <dcoutts> you mean cppery based on the packages we're actually using
10:45:56 <musasabi> either cppery or hs-sources-dirs-fu
10:46:07 <dcoutts> yeah, sigh
10:46:18 <dcoutts> or perhaps we can mix it
10:46:29 <dcoutts> package(foo) deps and || in build-depends
10:46:55 <musasabi> like providing a Data.FiniteMap if we use the new base.
10:47:03 <MarcWeber> Why doesn't the sleep command (from System.Posix) work anymore  when compiling with -threaded?
10:47:36 <int-e> hmm, doesn't it work again once you forkOS?
10:47:46 <emertens> @hoogle threadSleep
10:47:46 <lambdabot> No matches found
10:47:47 <dcoutts> musasabi, eg: build-depends: base; configuration: package (base<1.1); hs-src-dirs: compat
10:48:40 <musasabi> dcoutts: yes. Was more of a "common need for configurations with 6.6"
10:48:44 <MarcWeber> int-e: No, neither. I've tried both
10:48:55 <int-e> I thought the RTS sets up an alarm for the main thread, and the alarm signal interrupts the sleep syscall.
10:49:36 <dcoutts> musasabi, so configuration package tests are based on what package we actually chose, then package(foo) makes sense, if foo was involved in a ||-dep
10:50:06 <dcoutts> build-depends: foo || bar; configuration: package(foo); hs-src-dirs: blah
10:50:16 <int-e> and there's an RTS internal sleep function somewhere, hmm.
10:50:35 <int-e> @index threadDelay
10:50:36 <lambdabot> GHC.Conc, Control.Concurrent
10:51:58 <musasabi> dcoutts: that is good. Then we get to the problem of (||)-depends inside configuration build-depends.
10:52:10 <dcoutts> heh
10:52:34 <dcoutts> we have that issue anyway, with build-depends inside configurations
10:53:01 <musasabi> yes. It is in all solutions that use build-depends for evaluating configuration-clauses.
10:53:30 <dcoutts> I'm increasingly confused :-)
10:55:20 * emertens is bored
10:55:35 <emertens> But I did manage to find a pleasing irssi theme
10:56:53 <wolverian> emertens, which theme?
10:57:21 <emertens> http://img102.imageshack.us/my.php?image=pleasingfx3.png
10:57:24 <emertens> "ash"
10:57:24 <lambdabot> Title: ImageShack - Hosting :: pleasingfx3.png
10:58:05 <emertens> I have two monitors, on the one with irc the colors are less red-orange and more orage
10:58:08 <emertens> orange :)
10:58:53 <SamB> hmm, how to lex (* *)-style comments
10:59:06 <emertens> I really like Lucidia Console 14-point for IRC
10:59:14 <emertens> that font in particular for this application
11:00:18 <SamB> hmm hmm, I use nested comments too...
11:00:31 <SamB> there aren't regexes for nested comments are there?
11:01:04 <emertens> I can't think of how to define recursive regexs
11:04:02 <SamB> which wrapper does GHC use for its lexer?
11:04:07 <musasabi> lex ('(':'*':r) = c 0 r; lex (x:xs) = ...; where c k ('*':')':r) = if k==0 then lex else c (k-1) r; c k ('(':'*':r) = c (k+1) r; c k (_:x) = c k x
11:04:12 <SamB> or is it built in?
11:04:17 <emertens> actually, I think that by definition a "regular" expression is not recursive
11:04:22 <SamB> that is, is it specified in the file?
11:04:58 <SamB> emertens: thought so
11:06:18 <SamB> so, given that I'm using Alex, what can I do?
11:07:16 <SamB> oh, hmm, here is an example of a haskell lexer here...
11:07:30 <SamB> uses monad wrapper, thats nice
11:07:47 <MarcWeber> int-e: Thanks I'll try
11:18:10 <vincenz> re
11:41:06 <vincenz> dumteedum
11:41:28 * edwardk twiddles his thumbs.
11:41:37 <vincenz> @tell dons I figured out what was making your site have the scrollbar at the bottom.  Well my friend did, he loves css stuff.  Remove the border from the body and just add a border to the top of nav and a border to the bottom of footer.
11:41:37 <lambdabot> Consider it noted.
11:43:52 <emertens> #haskell is boring today
11:43:58 <emertens> spice it up people
11:44:13 <arjanoosting> @yow
11:44:14 <lambdabot> I Know A Joke
11:44:16 * edwardk gets out the dancing girls
11:44:29 * edwardk renames lamdabat to lambadabot to get the party going.
11:44:42 <edwardk> er lambdabot -> lambadabot
11:44:52 <musasabi> #-blah maybe for fun?
11:44:58 <musasabi> might get people more active
11:45:19 <emertens> @users #haskell-blah
11:45:22 <lambdabot> Maximum users seen in #haskell: 235, currently: 206
11:45:32 <emertens> @users #haskell
11:45:33 <lambdabot> Maximum users seen in #haskell: 235, currently: 206
11:45:42 <emertens> :-/
11:45:45 <musasabi> that tells only about the current channel I think.
11:46:06 <vincenz> yep
11:46:20 <vincenz> @users musasabi
11:46:21 <lambdabot> Maximum users seen in #haskell: 235, currently: 206
11:46:34 <emertens> anyone know how to use split windows in IRSSI?
11:47:01 <emertens> hmm.. i think i figured it out
11:47:03 <emertens> nvm
11:48:34 * vincenz wonders how to get feedback to his blog givven how he can't run cgi
11:48:49 <dcoutts> musasabi, I've proposed a slight variation that might solve some of these problems. See the cabal-devel list.
11:49:39 <dcoutts> basically specify deps, including conditional/option deps up front, then depending on what packages were chosen do other things to affect the build, except no more build-depends are allowed.
11:49:55 <dcoutts> so the configurations order doesn't matter
11:50:19 <dcoutts> and they only depend on what was chosen, not what's available in the environment
11:50:55 <dcoutts> so needs ? and || deps in build-depends, but no build-depends in configuration stanzas
11:51:38 <musasabi> dcoutts: looking there.
11:56:27 <MarcWeber> int-e: Here you can see my attempts: http://rafb.net/paste/results/UOMQ0v61.html Till line 33 its the sh script to compile 4 executables using sleep/threadDelay with and  without forkIO.. sleeping only works without -threaded and "sleep"
11:58:54 <PaulAJ> Can anyone explain the difference between lazy and eager ST threads?  I understand the semantic difference, but what about the lazy evaluation?
11:59:27 <PaulAJ> And since the semantics are different, why do they share the same name?
12:00:06 <petekaz> MarcWeber: in the threaded RTS, if the main thread exits, all others are killed.
12:00:26 <musasabi> dcoutts:  are "," and "&&" identical in your build-depend syntax?
12:00:56 <dcoutts> musasabi, not, sure. I think it's a n independent question.
12:01:20 <dcoutts> as I've said I'd suggest that they should be the same
12:01:35 <dcoutts> but I don't think it matters too much to my proposal
12:01:36 <musasabi> dcoutts: I have problems understanding the semantics. I can write an answer based on what I guess that they mean.
12:01:45 <dcoutts> ask me what they mean
12:01:53 <dcoutts> it'll help me clarify too! :-)
12:02:02 * musasabi tries to revert things to logic and see whether there are any problems on that levle
12:02:17 <musasabi> Ok. What do "," and "&&" mean?
12:02:24 <erider> how does the google api in lambdabot work?
12:02:30 <PaulAJ> dcoutts: presumably && has higher precedence than | and , has lower precedence?
12:02:34 <dcoutts> musasabi, I'd say they are the same
12:02:44 <dcoutts> musasabi, it's just a set of constrants
12:02:56 <erider> I what to create something similar in lisp
12:03:08 <erider> s/what/want
12:03:12 <dcoutts> musasabi, and since all constraints must be satisfied then it's &&
12:03:17 <musasabi> "(foo ? (bar)) || (bar ? (foo)))" <- what does this mean.
12:03:18 <dcoutts> PaulAJ, yeah, I guess so
12:03:39 <musasabi> (and is it different if we switch to &&
12:03:58 <dcoutts> I'll start with &&
12:04:02 <dcoutts> it's easier :-)
12:05:14 <dcoutts> with && it says that we depend on package bar if the --enable-foo flag is given, we also depend on the package foo if the --enable-bar flag is given
12:05:52 <dcoutts> musasabi, it's confusing because you're using the same names for packages as flags, but they're different name spaces
12:05:53 <int-e> MarcWeber: I should have said that threadDelay wants microseconds.
12:06:32 <dcoutts> musasabi, with || we only need foo or bar, and in each case we need the appropriate flag given
12:07:01 <dcoutts> musasabi, so eg: (hsql? ( hsql ) || hdbc? ( hdbc ))
12:07:09 <dcoutts> we need one of those
12:07:21 <dcoutts> and each one is protected by a --enable-* flag
12:07:21 <int-e> MarcWeber: (see the docs. they say that the duration gets rounded to the closest multiple of 1/50 s)
12:07:37 <musasabi> can we discuss with flags e.g. like Flag and packages like "package".
12:07:50 <dcoutts> musasabi, so if you do not specify either --enable-hdbc to --enable-hsql then there is no solution.
12:07:54 <dcoutts> to/or
12:08:14 <dcoutts> musasabi, sorry, I don't understand
12:08:42 <musasabi> (Foo ? ( Bar ) || Bar ? (Foo)) where both Foo and Bar are flags.
12:09:35 <dcoutts> well you're using them as flags and as package deps
12:09:46 <dcoutts> which is ok as flags and packages are different namespaces
12:10:07 <dcoutts> we might want to make a more obvious syntactic distinction if it's confusing
12:10:09 <dcoutts> like:
12:10:18 <dcoutts> os("window")? Win32
12:10:24 <dcoutts> flag("debug")? ...
12:10:35 <musasabi> makes more sense.
12:10:51 <musasabi> nontrivial to parse however
12:11:23 <dcoutts> (flag("hsql")? ( hsql && hsql-mysql ) || flag("hdbc")? ( hdbc>=1.0 && hdbc-mysql ))
12:11:29 <dcoutts> it's not that bad
12:11:38 <dcoutts> we just use a proper parser
12:11:44 <dcoutts> eg with parsec or happy
12:12:01 <musasabi> I'll try thinking about the semantics for a while and write a mail about that.
12:12:05 <dcoutts> ok cool
12:12:17 <dcoutts> ask if there are any other things that might be ambiguous
12:12:45 <dcoutts> remember my viewpoint is that we always resolve to a single package version
12:12:56 <dcoutts> so all constraints must be ok with that single version
12:13:30 <dcoutts> including where we get a tree of packages, there must be a solution with one version per-package
12:14:08 <dcoutts> (which is an interesting problem in itself, cabal-install may need to recmpile packages to get a consistent tree)
12:14:57 <mnislaih> Lemmih: there ?
12:17:07 <mnislaih> @tell Lemmih to try 'constrained = breakpoint $ f  where f = read' for more breakpoint goodness
12:17:07 <lambdabot> Consider it noted.
12:17:49 <mnislaih> @tell Lemmih to check out the patches at the repo before he starts hacking
12:17:49 <lambdabot> Consider it noted.
12:21:19 <PaulAJ> dcoutts: Where can I read your proposal?
12:21:54 <dcoutts> PaulAJ, the cabal-devel mailing list
12:22:11 <PaulAJ> Tnx.  I'll join it and look at the back issues.
12:22:54 <musasabi> dcoutts: "package(foo) ? bar || package(bar) ? foo"
12:23:33 <musasabi> dcoutts: and is it order sensitive?
12:24:03 <fnord123> join macosx
12:24:07 <fnord123> oops
12:25:41 <dcoutts> musasabi, there is no such build-depends syntax
12:25:57 <dcoutts> could there be? hmm...
12:26:22 <dcoutts> I don't think so, because it's not specifying a dep on anything external
12:26:29 <dcoutts> unless you mean "is it available"
12:26:39 <dcoutts> rather than have I picked it
12:27:13 <dcoutts> I want to ban "if it's available I'll use it" kind of optional deps
12:27:25 <dcoutts> that can be done by a flag
12:27:28 <dcoutts> which is user settable
12:27:40 <dcoutts> it's ok for such a flag to have a default though
12:29:39 <dcoutts> musasabi, does that make sense?
12:30:32 <musasabi> makes sense partially.
12:31:08 <musasabi> But how are "(base < 1.1) ? fps" and (hsql ? hsql) different?
12:31:39 <dcoutts> let me rephrase..
12:31:44 <dcoutts> "(base < 1.1) ? fps" isn't valid syntax
12:32:02 <dcoutts> it's flag("<flag>") ? <package>
12:32:09 <musasabi> is "(base > 1.0 || (base && fps))" valid?
12:32:13 <dcoutts> (flag("hsql") ? hsql)
12:32:22 <dcoutts> yes
12:32:51 <musasabi> so how about (hsql || base) ?
12:32:55 <dcoutts> fine
12:33:05 <musasabi> but isn't that what we wanted to avoid?
12:33:15 <musasabi> that means "depend on hsql if it exists"
12:33:26 <dcoutts> what says that?
12:33:36 <musasabi>  (hsql || base)
12:33:46 <musasabi> <- more coffee
12:34:16 <dcoutts> it's a pretty odd dep since not depending on base is pretty hard
12:34:35 <dcoutts> but it's ok, it says we depend on hsql or base
12:34:44 <dcoutts> so that'd be satisfied by base being installed
12:34:59 <dcoutts> but we do have a choice
12:35:11 <musasabi> doesn't that default to hsql if possible?
12:35:16 <dcoutts> we could satisfy it either way
12:35:28 <musasabi> || is non-deterministic?
12:35:51 <dcoutts> no
12:35:51 <musasabi> so with the exact same packages and cabal-file we can get different results?
12:36:07 <dcoutts> in gentoo at least the semantics are:
12:36:29 <dcoutts> if the first is installed use that, if only the second is installed use that
12:37:00 <dcoutts> if we're doing dep resolution and neither are installed then we pick the first over the second
12:37:07 <musasabi> If it is left-biased then "(hsql || base)" is exactly the same as "configuration: package(hsql); build-depend: hsql; configuration: !package(hsql); build-depend: base"
12:37:14 <dcoutts> unless it's impossible to install the first, in which case we use the second
12:38:09 <musasabi> because we use a second which is allways installed it degenerates into "link to the first if it is installed"
12:38:17 <dcoutts> yeah, I guess so
12:38:49 <dcoutts> hmm, so is that ok or not...
12:39:19 <dcoutts> in gentoo that'd be the equivalent of ( foo || libc )
12:40:04 <dcoutts> which is ok I think
12:40:26 <musasabi> dcoutts: but isn't that what we wanted to avoid in the first place?
12:40:49 <musasabi> that is the optional implicit package-dep.
12:41:27 <dcoutts> it's explicit, not implicit
12:41:52 <musasabi> Sorry if I appear to be overly negative and pointing out problems, just want to have something usable in 6.6 and catch the problems early on.
12:41:59 <dcoutts> sure sure
12:42:07 <dcoutts> it's tricky, I'm still thinking :-)
12:42:43 <dcoutts> I think the difference is that it doesn't affect the deps when we do dep calculation
12:43:11 <dcoutts> we know from the beginning if we'll get foo or not
12:43:41 * musasabi tries to formulate t.txt with the build-syntax. Not sure whether it exists.
12:44:31 <Cheery> who is actually developing the haskell language? It seems people here would actually have something to say what's goes into next version. :/
12:45:09 <Cheery> That's cool if it is so, but haskell is so big. I'm just very curious and wondering.
12:45:15 <dcoutts> so if we have a set of packages to install, we should know from the beginning if we'll end up using foo or not rather than discovering along the way
12:45:21 <Cheery> I mean, big in means of community.
12:45:31 <dcoutts> Cheery, see the haskell-prime trac site and mailing list
12:45:40 <musasabi> Cheery: it is a group effort. For the language the haskell-prime committee is the right place.
12:45:45 <eivuokko> Cheery, language isn't really developed here, see haskell-prime.  But implementations and libraries are often discussed here and many of the authors hang here.
12:46:17 <musasabi> http://youzen.b2.fi/~musasabi/t2.txt
12:46:19 <dcoutts> kosmikus, you about?
12:47:33 <dcoutts> musasabi, that's the same problem as before
12:47:41 <dcoutts> which I don't think is a problem
12:48:04 <dcoutts> that's just that as you upgrade things you might get a package built against one or other version of a package
12:48:10 <musasabi> dcoutts: ok. This is more evil: http://youzen.b2.fi/~musasabi/t3.txt
12:48:15 <Cheery> dcoutts, musasabi, eivuokko, incredibly nice that some group has actually ended like this and grow to such size.
12:48:27 <dcoutts> and actually if you use cabal-install to install them all at once I think you'll only get one order
12:48:30 <dcoutts> let me check that...
12:50:14 <dcoutts> musasabi, I think that since we'd be installing C-2 and B-2 and B depends on C (v1 or v2) that we'd upgrade C first and build B against C-2
12:50:15 <musasabi> Haskell has a very direct interaction with the developers. The MLs are the best place with most of the compiler authors being very active there.
12:50:29 <dcoutts> but actually it's not so much of a problem if it's done the other way around
12:50:44 <dcoutts> gentoo's emerge often does that
12:51:04 <musasabi> dcoutts: but the order is non-deterministic?
12:51:15 <dcoutts> musasabi, yes
12:51:19 <dcoutts> but optional deps are not
12:51:26 <dcoutts> (I think)
12:51:32 <musasabi> i.e. we get to the exact same problems. Except we have solved the HUnit case.
12:52:28 <dcoutts> with the more free form pickup optional deps I think we can produce graphs that are unsolvable
12:52:29 <musasabi> With "B->C->A" D is never installed. With "C->B->A" D is installed.
12:52:55 * dcoutts looks at t3.txt
12:53:31 <musasabi> +reload if you have the old version
12:54:02 <dcoutts> I think that's unsolvable
12:54:15 <dcoutts> since you need both C >= 2 and C < 2
12:54:28 <dcoutts> oh wait
12:54:49 <dcoutts> no since C < 2 would be inconsistent then we pick D
12:55:26 <musasabi> agh. oh well that can be fixed. just a little more complex example.
12:55:54 <dcoutts> wait as sec, it's more tricky that I thought at first...
12:56:12 <dcoutts> we could install B, then we'd pick C-1
12:56:24 <dcoutts> then we could install C-2
12:56:27 <dcoutts> or...
12:56:50 <dcoutts> install C-2 and then B-2 which needs C<2 or D
12:56:54 <dcoutts> so we'd install D
12:56:55 <dcoutts> yes
12:57:00 <emertens> > [99,98..1]>>= \n->[show n," bottle",guard(n/=1)>>"s"," of beer"]>>= \b->join [b," on the wall,\n",b,".\nShould one of those bottles happen to fall,\n",b," on the wall."]
12:57:01 <lambdabot>  "99 on the wall,\n99.\nShould one of those bottles happen to fall,\n99 on th...
12:57:11 <dcoutts> musasabi, yes, they're both solutions
12:58:03 <dcoutts> musasabi, so I guess it is non-deterministic in how you choose between valid solutions
12:58:27 <dcoutts> we probably cannot eliminate that fact
12:58:40 <dcoutts> though we can use sensible heuristics to choose between solutions
12:59:43 <musasabi> dcoutts: one solution would be to require user intervention if there are optional dependencies?
13:00:14 <dcoutts> musasabi, in gentoo at least, the answer is that || is really only used when the choice is inconsequential
13:00:24 <dcoutts> and USE flags are used when the choice is important
13:00:39 <musasabi> The problem is that there are no use-flags outside gentoo.
13:00:45 <dcoutts> eg you'd use flags for the hdbc/hsql choice
13:00:56 <musasabi> Thus no sane default choices outside Gentoo.
13:01:24 <dcoutts> well if you need the user to choose then we can do that
13:01:34 <dcoutts> though minimising interaction is good
13:04:46 <dcoutts> musasabi, ok suppose we make it legit to do "it's available lets use it" deps, how can we do that in a way that's sane
13:05:00 <dcoutts> musasabi, I should find out precisely what the problem with auto use deps was in gentoo
13:05:08 <dcoutts> we may not have the same problem
13:05:14 <dcoutts> our deps are a bit simpler
13:05:55 <dcoutts> the main thing is that it needs to be calculable before hand, so that cabal-install can do it
13:06:13 <Igloo> dcoutts: In something like an hdbc/hsql choice 2 different applications may want different choices, so "both" should raeally be possible one way or another
13:06:44 <musasabi> dcoutts: For me the most important things is simple semantics that I can understand. I'll try writing the response now.
13:07:25 <dcoutts> Igloo, you mean to compile against both
13:08:15 <Igloo> dcoutts: Either compile one library against both or the ability to install the library for both choices simultaneously (which probably implies the package name depending on what choice you make)
13:08:48 <Igloo> This may just be a policy thing rather than something cabal needs to enforce, though
13:09:00 <dcoutts> Igloo, aye, for binary packages you'd want to allow both choices, to compile one way and to compile the other way
13:09:16 <dcoutts> that get's pretty complicated
13:09:19 <Igloo> dcoutts: And also just for users not using any packaging system (beyond cabal)
13:09:34 <vincenz> Igloo: congrats
13:09:41 <Igloo> thanks
13:10:07 <dcoutts> Igloo, in general it's a bad design to have multiple important ways of building like that
13:10:26 <dcoutts> where as for simple versioning things it's all ok
13:10:26 <Igloo> Agreed
13:10:40 <dcoutts> as you can pick one and be done with it
13:10:54 <dcoutts> that's the modules hopping between packages problem
13:11:05 <dcoutts> or different packages on different OSs
13:11:13 <dcoutts> Win32/posix
13:11:49 <dcoutts> if they're really different then they should probably just be different packages
13:12:00 <dcoutts> or a package with two dependent 'backend' packages
13:12:19 <dcoutts> like hdbc & hsql do already
13:14:19 <mnislaih> @seen Lemmih
13:14:19 <lambdabot> Lemmih is in #oasis, #haskell-overflow, #haskell-blah and #haskell. I last heard Lemmih speak 3 hours, 48 minutes and 44 seconds ago.
13:15:00 <vincenz> oasis :)
13:23:40 <musasabi> I think I may have something. Writing it.
13:25:53 * Dylan ponders working on his squirrel-based Homespring inspired toy language.
13:28:32 <tibbe> any chance there already exists a ABNF parser generator for Haskell?
13:28:46 <SamB> ABNF?
13:28:48 <SamB> what is that?
13:28:53 <SamB> why don't you just use Happy?
13:28:55 <SamB> and be happy?
13:29:05 <emertens> anti-bachus naur form?
13:29:26 <vincenz> arctic-bachus
13:29:31 <vincenz> it's from the vodka brand
13:29:51 <tibbe> http://www.cs.columbia.edu/sip/syntax/rfc2068.html
13:29:52 <lambdabot> Title: ABNF Specification for &lt;rfc2068.abnf&gt;
13:30:01 <tibbe> cause I already have the grammar
13:30:45 <emertens> in my PL&T class, the prof could barely passed the language requirements, it took a while to realize he wasn't saying normal
13:31:07 <vincenz> use parsec?
13:31:12 <tibbe> I guess
13:31:40 <tibbe> but it would nice if I could just convert it to a form that could be used directly
13:31:47 <tibbe> but that's my backup plan
13:34:31 <mnislaih> question: where does unsafeCoerce come from
13:34:36 <mnislaih> is it defined anywhere ?
13:38:53 <tibbe> wanted: a parsec tutorial
13:39:38 <sieni> what kind of tutorial? I saw a nice tutorial about combinator parsing in general... what was it again
13:40:12 <Cale> tibbe: did you read the parsec documentation?
13:40:17 <Cale> It's practically a tutorial
13:40:21 <vincenz> lol
13:40:24 <vincenz> bug in lambdabot
13:40:27 <vincenz> @hoogle unsafeCoerce#
13:40:27 <lambdabot> Hoogle Error: Parse Error: Unexpected character '>'
13:40:29 <tibbe> parsec specific, I have a grammar (above) that I'm going to translate and I want as little fuss as possible
13:40:30 <vincenz> >  ...?
13:40:31 <lambdabot>  Parse error
13:40:36 <musasabi> dcoutts: sent a version with simple semantics.
13:40:52 <musasabi> dcoutts: I am not sure if that is what we want, but at least it appears to be simple.
13:41:07 * tibbe should have read the top of the library doc instead of scrolled down
13:41:14 <sieni> tibbe: http://www.cs.nott.ac.uk/~gmh/pearl.pdf
13:41:46 <antarus> wow this is larger than I thought
13:43:26 <musasabi> dcoutts: seems that eliminating negation was a very good thing(tm)
13:44:58 <vincenz> antarus: larger than life?
13:45:34 <sjanssen> @quote
13:45:34 <lambdabot> gFunk says: [the main advantage of functional programs are that they're] incorrect the first 1000 times you try to compile it!
13:47:48 <dcoutts> musasabi, the gentoo portage devs are trying to tell me how important it is not to pick up optional deps willy nilly
13:47:59 * antarus is no longer a portage dev
13:48:04 <antarus> but nice try ;P
13:48:55 <antarus> mostly it's a matter of flexability..
13:49:03 <antarus> sadly I'm not too familiar with haskell
13:49:11 <antarus> afaik normally the big killer for that is in cross-compiling
13:49:24 <antarus> since you can't link to stuff on the system you are on, since you are building for a different system...
13:49:30 <antarus> but also if you need to isntall into a different prefix
13:49:39 <dcoutts> musasabi, I explained about the foo || base issue and they said "don't do that, it's evil"
13:49:41 <antarus> you may want it linking against a different set of haskell programs
13:49:42 <musasabi> dcoutts: and that is a very good opinion if one has USE-flags. We don't have USE-flags.
13:49:56 <dcoutts> musasabi, well we've got some flags
13:50:04 <dcoutts> --enable-foo --disable-foo
13:50:05 <antarus> musasabi: you can't auto-enable stuff though, you need --enable-switches ala confingure
13:50:10 <musasabi> but nothing automatic.
13:50:22 <dcoutts> no, though you can have defaults
13:50:23 <antarus> musasabi: or you need to let me specify a haskell package db thats not the "normal one"
13:50:48 <musasabi> antarus: one can already do that.
13:51:17 <SamB> are the gentoo people aware that GHC-built packages aren't at all binary compatible between versions?
13:52:20 <musasabi> dcoutts: I think that the main issue is that with gentoo the enable-flags are implicitely got from USE and thus they are not a problem. Outside Gentoo one would need to specify them by hand each time, which is not nice.
13:52:57 <dcoutts> musasabi, well the gentoo portage devs say it's all ok so long as it's overidable
13:53:00 <musasabi> dcoutts: so the situation would be like Gentoo except that one would have to specify USE-flags for each package by hand.
13:53:20 <dcoutts> musasabi, so default based on install status for cabal-install
13:53:44 <dcoutts> and gentoo will always override and explitly pass --enable-foo --disable-foo based on a USE flag
13:53:56 <musasabi> that should work.
13:54:07 <antarus> musasabi: I'd take that
13:54:17 <antarus> musasabi: I don't care what the defaults are, as long as we can toggle em ;0
13:54:20 <dcoutts> so || should really only be used for unimportant cases
13:54:32 <dcoutts> like fps in base or seperate package
13:54:53 <musasabi> I will be mostly away till monday, but will look at irc and write a few mails occasionally. Still have a few more hours till I need sleep.
13:55:04 <sjanssen> @tell dons perhaps we can remove memcpy from ByteString.  Foreign.Marshal.Utils.copyBytes uses memcpy under the hood
13:55:05 <lambdabot> Consider it noted.
13:55:18 <dcoutts> sjanssen, true
13:55:51 <antarus> cool, thanks for listening ;)
13:55:53 * antarus waves
13:56:02 <musasabi> dcoutts: it is not possible to force "||" only for unimportant things on the design level - that has to be done with social pressure.
13:56:29 <musasabi> "bug the author until he fixes the .cabal file"
13:56:44 <dcoutts> musasabi, yes
13:57:07 <dcoutts> musasabi, I was told I'd get murdered if I added a gentoo ebuild doing  foo || base :-)
13:57:15 <dcoutts> helpful social pressure
13:57:36 <musasabi> dcoutts: how did the semantics sound on the ml?
13:57:40 <dcoutts> musasabi, and || is really xor, not or
13:57:47 * dcoutts reads
13:58:09 <dcoutts> not come though yet
13:58:34 <Igloo> dcoutts: Is that || a gentoo thing or proposed cabal thing?
13:58:34 <musasabi> dcoutts: "a ? b" is simply "(a, b) | T" when you read the mail.
13:58:40 <dcoutts> Igloo, both
13:58:51 <Igloo> dcoutts: It is xor in both?
13:58:56 <dcoutts> Igloo, yes
13:59:04 <Igloo> So ghc || gcc wouldn't be satisfied by having both installed?
13:59:12 <musasabi> Igloo: see the last cabal-dev mail for proposed semantics.
13:59:16 <dcoutts> it is, but only one is used
13:59:20 <neonka> is haskell good for php programmer to switch over to do some basic web stuff? does it have some libraries or something for web?
13:59:25 <dcoutts> Igloo, it's left biased
13:59:31 <Igloo> Ah, OK
13:59:32 <neonka> i am interested in new language and like to experiment
13:59:50 <Cale> neonka: It's not specifically for web stuff, but of course you could still write CGI programs
14:00:14 <alec> neonka: there's also haskell server pages, which I think may work like php (embed haskell in html), but I haven't used it
14:00:48 <Cale> Be warned, you're going to find Haskell to be a very different language from PHP :)
14:00:53 <musasabi> http://www.haskell.org/pipermail/cabal-devel/2006-August/000087.html <- the semantics
14:00:54 <lambdabot> Title: issues with configurations
14:01:09 <Cale> But it should be fun :)
14:01:15 <neonka> it seems to me like it would be hard to find anything on the net when needed .. the community of php or perl is much larger.. or am i wrong ?
14:01:32 <Cale> neonka: You've already found one important place :)
14:01:46 <Cale> neonka: I also recommend the haskell and haskell-cafe mailing lists
14:01:59 <Cale> and there are a good number of tutorials and references out there
14:02:00 <neonka> Cale: i am already learning and i like to learn it because it's different.. i learn it just for fun and now i start to think if i could really use it
14:02:09 <Cale> yeah :)
14:02:18 <Cale> @where yaht
14:02:19 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
14:02:31 <Cale> that's my favourite tutorial for newcomers
14:02:47 <neonka> but for perl or python there's many libraries just for web, i can't imagine how to scrape with haskell for example
14:02:48 * sm likes http://en.wikibooks.org/wiki/Haskell
14:02:55 <emertens> I can't see how Haskell would be pleasent for use in place of PHP...
14:03:05 <emertens> bit I guess I just haven't seen any good examples yet
14:03:24 <dcoutts> musasabi, you did send something to cabal-dev about the semantics of what I was talking about?
14:03:29 <dcoutts> it's not come throguh yet
14:03:36 <musasabi> dcoutts: see the URL
14:03:43 <dcoutts> oh, missed that
14:03:46 <neonka> what are you all using haskell for ?
14:03:46 * dcoutts looks
14:03:46 <Cale> I can see someone writing a really sweet library for it, but as of yet, there's only limited amounts of stuff for working with HTML/XML/etc.
14:04:12 <musasabi> Cale: there are many libraries that have very different approaches to the problem.
14:04:31 <Cale> I use it for various tasks on my machine mostly. I've written a pipeline scheduler in it (a thing which figures out the best order to issue assembler instructions to the processor)
14:04:47 <neonka> Cale: yes, that's my point.. would be any other language more sufficient for my needs that is funny as haskell too? :)
14:05:10 <emertens> "funny as haskell"?
14:05:25 <neonka> functional
14:05:29 <eivuokko> as much fun as haskell?
14:05:37 <neonka> yes
14:05:42 <neonka> sorry for my english
14:05:49 <Cale> neonka: Haskell is by far the coolest language I've run into
14:06:07 <neonka> have you tried tcl, lisp also ?
14:06:15 <Adamant> you might like Common Lisp or Scheme
14:06:16 <Cale> lisp, I've used
14:06:35 <Cale> I wouldn't generally recommend common lisp, but scheme is cool.
14:06:37 <Adamant> Ruby is good, for more conventional languages
14:07:01 <Cale> Ruby and Python are both fairly nice as far as imperative OO languages go.
14:07:07 <Adamant> yup
14:07:21 <Cale> If you're looking for a functional OO language, you might try O'Caml.
14:07:28 <neonka> yeah, i am thinking about choosing ruby or python or haskell as my next language
14:07:38 <Adamant> try Haskell
14:07:40 <Cale> Though it doesn't have as pretty syntax as Haskell, and not as many glitzy features.
14:07:41 <emertens> Cale, have you played with Scala?
14:07:47 <Adamant> it'll teach you more
14:07:52 <Cale> emertens: I've looked at it a bit
14:08:24 <neonka> and can i apply the knowledge from haskell to other langs or is it totaly different
14:09:03 <Cale> neonka: You can, though it takes a while to see the connections :)
14:09:27 <neonka> i see
14:10:00 <emertens> Looking at a problem in a pure, functional was requires you to think about problems in a much different way than in an imperative one
14:10:13 <emertens> I think it's probably good to understand both
14:12:12 <Cale> A neat thing about Haskell that we tend to downplay is that you actually can solve problems imperatively in it -- it's just that for the most part, you wouldn't want to if you can avoid it. It's not that it's any more painful than it is in an imperative language, it's just that imperative programming is more painful than functional programming :)
14:12:18 <neonka> i think so.. i always like to learn something i don't understand.. but when i see the light, my mind is always attracted by something new :)
14:12:47 <emertens> Haskell is a great place to look at single lines of code and wonder "what the hell does that do"
14:12:59 <musasabi> does that look like complete rubbish or something that might work?
14:14:53 <emertens> like... I know that the following works, but at the moment, it still boggles me why:
14:15:05 <emertens> > ap (,) (+1) 1
14:15:06 <lambdabot>  (1,2)
14:15:21 <emertens> Yes Cale, I know that this in the the (->) monad
14:15:24 <emertens> ;)
14:15:51 <sm> > :t ap
14:15:51 <lambdabot>  Parse error
14:15:57 <emertens> @type ap
14:15:59 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
14:16:00 <Cale> Because, in that monad,  ap x y z = x z (y z)
14:16:06 <emertens> Oh,I learned this too:
14:16:12 <Cale> you can form a little derivation of that fact
14:16:12 <emertens> > liftM2 ap (+) 1 2
14:16:13 <lambdabot>  add an instance declaration for (Num (a -> b))
14:16:16 <emertens> > liftM2 ap (,) (+) 1 2
14:16:17 <lambdabot>    Expecting a function type, but found `(a, b)'
14:16:17 <lambdabot>    Expected type: a1 ->...
14:16:20 <emertens> hmm..
14:16:30 <emertens> > liftM2 ap (,,) (+) 1 2
14:16:31 <lambdabot>  (1,2,3)
14:16:34 <emertens> there we go
14:16:37 <Cale> :)
14:16:43 * sm admires the pretty glyphs
14:17:26 <emertens> > uncurry (liftM2 ap (,,) (+1)) (1,2)
14:17:27 <lambdabot>  add an instance declaration for (Num (b -> a))
14:17:45 <Cale> > take 20 $ fix ((0 :) . scanl (+) 1)
14:17:46 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
14:17:46 <emertens> > uncurry (liftM2 ap (,,) (+)) (1,2)
14:17:47 <lambdabot>  (1,2,3)
14:21:38 <emertens> I was looking through the deSugar code in GHC last night, but I never did figure out how to restore Monad comprehensions
14:22:45 <emertens> heh... remind me what the syntax for parallel list comprehensions was
14:23:48 <Heffalump> [a+b | a <- as | b <- bs] IIRC
14:23:49 <musasabi> [ foo | x <- asas | y <- kjsa ]
14:23:52 <Heffalump> (never used them myself)
14:24:13 <emertens> that doesn't actually translate cleanly into a do block, does it?
14:24:26 <musasabi> emertens: it does.
14:25:06 <emertens> without (x,y) <- zip as bs?
14:25:12 <musasabi> emertens: just use zipping.
14:25:20 <emertens> ah,ok
14:25:47 <musasabi> @type zipWithM (liftM2 (,))
14:25:49 <lambdabot> forall (m :: * -> *) a1 a2. (Monad m) => [m a1] -> [m a2] -> m [(a1, a2)]
14:26:20 <musasabi> or rather.
14:26:45 <musasabi> hmm. you *do* have a point.
14:26:46 <emertens> Wikipedia quote: Sometime before the Haskell 98 standard the list comprehension syntax was first generalized to monad comprehension but then specialized back as it caused type ambiguity: ['c'] wouldn't mean a list of one element, the character c, but the result of return 'c' in any monad.
14:28:01 <emertens> that would really reinforce that [] is a monad :)
14:30:06 <musasabi> emertens: maybe require a | for it to be a comprehension?
14:31:06 <Heffalump> what's the benefit of making monad comprehensions, OOI (given that guard exists)?
14:31:31 <emertens> getting to use the sugar more :)
14:31:39 <musasabi> Heffalump: Even nicer SQL queries.
14:31:48 <musasabi> and fun with sets.
14:31:53 <emertens> The reason that "History of Haskell" quoted for removing them was that they were "too hard for beginners"
14:32:04 <emertens> which seemed like a lousy reason to do something like that to me at least
14:32:20 <Heffalump> I don't see why all this "too hard" stuff isn't handled by having language flavours
14:32:31 <Heffalump> just make it a set of options at the top of a file to turn on good stuff
14:32:34 <emertens> like Helium?
14:32:56 <Heffalump> that kind of thing, yes
14:33:05 <Heffalump> but not an explicitly separate langauge
14:33:15 <Heffalump> just levels of sophistication in the same language
14:33:28 <Heffalump> though I guess Helium was never explicitly separate per se
14:33:44 <Heffalump> but they never scaled up the type checking stuff to full Haskell, AIUI
14:34:01 <emertens> > let f x = ['s' | x < 1] in (f 1, f 2)
14:34:03 <lambdabot>  ("","")
14:34:07 <emertens> > let f x = ['s' | x < 1] in (f 1, f 0)
14:34:08 <lambdabot>  ("","s")
14:34:38 <emertens> I don't know what these "AIUI" and "OOI" things mean :)
14:36:04 <Heffalump> As I understand it, Out of interest
14:38:06 <emertens> @qoute
14:38:07 <lambdabot> Maybe you meant: quote vote
14:38:09 <emertens> @quote
14:38:10 <lambdabot> PaulGraham says: I get the impression that using [Haskell] would feel like reading a novel written by a literary critic.
14:38:16 <emertens> @quote
14:38:16 <lambdabot> darius says: Well profiling does add a bit of reflection, but it should have the good sense not too go near the barbed wire fences and armed guards.
14:38:17 <Heffalump> ?hoogle (a -> a -> a) -> ((x -> a) -> (x -> a) -> (x -> a))
14:38:18 <lambdabot> No matches, try a more general search
14:38:29 <Heffalump> ?hoogle (a -> a) -> ((x -> a) -> (x -> a))
14:38:30 <lambdabot> No matches, try a more general search
14:38:41 <emertens> ?
14:38:49 <emertens> that doesn't make sense :)
14:39:03 <emertens> oh
14:39:10 <emertens> you just want it to chain them?
14:39:50 <emertens> like: flip (.) ?
14:40:04 <emertens> @type flip (.)
14:40:05 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
14:40:18 <emertens> @type (.)
14:40:19 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
14:40:21 <Heffalump> I want \f a b t -> f (a t) (b t)
14:40:28 <Heffalump> @type \f a b t -> f (a t) (b t)
14:40:29 <lambdabot> forall t t1 t2 t3. (t -> t1 -> t3) -> (t2 -> t) -> (t2 -> t1) -> t2 -> t3
14:40:55 <Heffalump> @type \f a b t -> f (a t) (b t) :: (a -> a -> a) -> ((x -> a) -> (x -> a) -> (x -> a))
14:40:57 <lambdabot>   Inferred type is less polymorphic than expected
14:40:57 <lambdabot>    Quantified type variable `x' is mentioned in the environment:
14:41:27 <svref> how do I divide Integer a by Integer b, dropping fractions?
14:41:29 <emertens> @pl \f a b t -> f (a t) (b t)
14:41:29 <lambdabot> liftM2
14:41:35 <emertens> how about liftM2
14:41:50 <Heffalump> I looked at that and thought it didn't do what I want.
14:42:03 <emertens> liftM2 (,) [1..3] [2..4]
14:42:07 <emertens> > liftM2 (,) [1..3] [2..4]
14:42:08 <Heffalump> is (-> a) a monad?
14:42:08 <lambdabot>  [(1,2),(1,3),(1,4),(2,2),(2,3),(2,4),(3,2),(3,3),(3,4)]
14:42:10 <mnislaih_> svref: div
14:42:16 <mnislaih_> @type div
14:42:18 <lambdabot> forall a. (Integral a) => a -> a -> a
14:42:24 <Heffalump> @type liftM2 mplus
14:42:25 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m1, MonadPlus m) => m1 (m a) -> m1 (m a) -> m1 (m a)
14:42:28 <sjanssen> @. pl djinn (a -> a) -> ((x -> a) -> (x -> a))
14:42:28 <lambdabot> f = (.)
14:42:31 <svref> mnislaih_: thx
14:42:52 <emertens> (.) was my original suggestion... what are you trying to do?
14:42:58 <Heffalump> @. pl djinn (a->a->a) -> ((x->a) -> (x->a) -> (x->a))
14:42:59 <lambdabot> f = flip . liftM2
14:43:20 <sjanssen> @. pl djinn (a -> b -> c) -> (x -> a) -> (x -> b) -> (x -> c)
14:43:21 <lambdabot> f = liftM2
14:43:32 <Heffalump> @pl \t -> f t `mplus` g t
14:43:33 <lambdabot> liftM2 mplus f g
14:43:37 <Heffalump> that's what I actually want to do
14:44:00 <mnislaih_> what is the '@. pl djinn' command telling lambdabot to do ?
14:44:00 <Heffalump> oh, ok, the typechecker seems happy with it
14:44:07 * Heffalump is confused but gives up and accepts it
14:44:20 <emertens> mnislaih_: apply pl to the results of djinn, it's a compose operator
14:44:30 <mnislaih_> ohh, that's cool
14:44:35 <mnislaih_> @karma lambdabot
14:44:35 <lambdabot> lambdabot has a karma of 19
14:44:40 <sjanssen> @. elite quote
14:44:41 <lambdabot> aUGus+$z0rz zAys: hb( s+iL1 |-|A$ $Ome UNique f3AtUr35, like VI3ws. ThA+ i'VE nevER Uz3d..
14:44:51 <mnislaih_> o.o
14:44:54 <sjanssen> @. elite run head 2
14:44:55 <lambdabot> add aN inSTANCE DE(L4Ration 4 (NU/\/\ [a])
14:45:31 <stw> Hi all, I'm reading "Scheme in 48 hours", and I'm stuck with an exercise in chapter 3.3. Are the solutions somewhere on the net?
14:45:50 <Heffalump> are you trolling? :-)
14:46:05 <stw> Heffalump: me? why?
14:46:26 <emertens> @pl \t -> mplus (f t) (g t)
14:46:26 <lambdabot> liftM2 mplus f g
14:46:30 <stw> i mean the "write yourself scheme in haskell in 48 hours", if that's what you mean
14:46:31 <Heffalump> you don't think asking about Scheme on a Haskell channel counts as trolling? :-)
14:46:35 <sjanssen> I assume stw means the Haskell tutorial where you write a Scheme interpreter
14:46:37 <Heffalump> ah :-)
14:46:43 <stw> sorry i wasn't clear
14:46:45 * Heffalump is clearly ignorant.
14:46:48 <Heffalump> don't mind me
14:47:12 <stw> it's about parseString which should parse a string containing backslashed quote marks
14:48:20 <stw> the code given is this: do { char '"'; x <- many (noneOf "\""); char '"' }
14:48:21 <shapr> @yow !
14:48:22 <lambdabot> I just got my PRINCE bumper sticker ... But now I can't remember WHO he
14:48:22 <lambdabot> is ...
14:48:42 <stw> but it seems i can't mix the char and string parsers
14:49:05 <shapr> stw: What are the types of each?
14:49:07 <Heffalump> did you forget a return x?
14:49:08 <sjanssen> stw: perhaps you're lacking a return x at the end?
14:49:28 <shapr> Yow! I have a republican haircut!
14:49:40 * mnislaih_ with his last gasp, asks for a Haskell type-wizard's advice
14:49:41 <stw> sjanssen: no the return is there, just forgot to copy it
14:49:54 <shapr> mnislaih_: Are you suffocating on types?
14:50:01 <mnislaih_> yay
14:50:20 <shapr> @users
14:50:21 <lambdabot> Maximum users seen in #haskell: 235, currently: 210
14:50:24 <stw> what i want is to have the choice: either it's a non-quote character (i.e. noneOf "\""), or it's a backslash followed by a quote mark
14:50:34 <mnislaih_> why can't I do 'let li = GHC.Base.unsafeCoerce# read :: ()'
14:50:43 <mnislaih_> but I can 'let li = GHC.Base.unsafeCoerce# show :: ()'
14:50:55 <stw> this is what i have currently:  x <- many ((char '\\' >> char '"') <|> noneOf "\"")
14:51:06 <SamB> noneOf "\"" <|> (char '\\' >> char '"')
14:51:12 <musasabi> dcoutts: ping. Do you want to do something about the stuff? (will probably be here for 30min and the next time in 24hours)
14:51:32 <dcoutts> musasabi, ok, what can we do now?
14:51:35 <Heffalump> what are the types of each?
14:51:36 <SamB> stw: is there a problem with that?
14:51:39 <dcoutts> musasabi, I've had yet another idea :-)
14:51:41 <stw> SamB: does not work for multiple quotes e.g. "abc\"\"\"def"
14:51:42 <shapr> musasabi: Hey, that monadic effects calculus paper is way nifty. If I understand it correctly it allows for commutative monads.
14:52:00 <Heffalump> URL?
14:52:13 <Heffalump> (to shapr)
14:52:18 <stw> SamB: well it does not work for backslashes followed by non-quotes such as "abc\ndef"
14:52:18 <shapr> um, I forget...
14:52:24 <Heffalump> ok, title?
14:52:26 <Heffalump> or authors
14:52:31 * shapr grabs his 770
14:52:36 <SamB> stw: oh, well, then you need to extend it ;-)
14:52:44 <musasabi> dcoutts: ok. Waiting to read it :-) But we really should find a solution if we want to ship something with 6.6.
14:53:08 <shapr> "A modal calculus for effect handling" by Aleksandar Nanevski
14:53:29 <shapr> musasabi asked about that paper yesterday, so I downloaded it to my 770 and read (part of) it on the subway.
14:53:50 <stw> SamB: it would be much nicer if i could just combine 'string' and 'noneOf'
14:54:07 <dcoutts> musasabi, sent
14:54:12 <musasabi> thanks.
14:54:15 <stw> such as: many (string "\\\"" <|> noneOf "\"")
14:54:17 <shapr> I still have a bunch of questions about that paper, but I do like the combination of comonads and monads.
14:54:39 <musasabi> shapr: haven't had enough time to think about it. Things are hectic the time I am awake.
14:55:03 <SamB> no wonder parser isn't working... left out a keyword in the lexer...
14:55:07 <shapr> That combination makes a lot of sense. Especially since I read chunks of the Uustalu & Vene comonadic attribute grammar paper before that.
14:56:04 <dcoutts> musasabi, the suggestion is to seperate default values of flags from other inconsequental dep variations
14:56:09 <shapr> Comonads are all the craze this year.
14:56:20 <dcoutts> musasabi, so explcitly give flags, and give them default values
14:56:39 <dcoutts> musasabi, then 'package' conditionals only refer to things we're actually building against
14:56:47 <monochrom> No one crazes about arrows anymore?
14:56:48 <dcoutts> musasabi, but we can pull in extra deps using flags
14:56:54 <shapr> monochrom: Actually, the two are related.
14:57:01 <monochrom> ok yay
14:57:25 <shapr> The comonadic AG paper explicitly says that no one has tried to make AGs with arrows (Freyd categories).
14:57:36 <stepcut> everytime I make an Arrow, I eventually realize that it is really just a Monad pretending to be an Arrow :p
14:58:08 <shapr> The only downside to the modal calculus paper is that it has a huge number of references that really are required.
14:58:31 <shapr> It's more like one episode in an ongoing series, or a chapter in a book.
14:58:46 * shapr thinks "Tune in Next Time when we see if the hero unbinds the comonad!"
14:59:19 <Heffalump> shapr: is this the paper? http://www.eecs.harvard.edu/~aleks/papers/effects/effects.ps
14:59:22 <emertens> > ((+1) &&& (+2)) 3
14:59:23 <lambdabot>  (4,5)
15:00:11 <shapr> Heffalump: Nah, that's one of the other chapters I haven't read.
15:00:20 <dcoutts> musasabi, does that make any sense?
15:00:25 <Heffalump> what's the file called, then?
15:00:37 <emertens> @djinn (a -> a) -> (a -> a) -> a -> (a,a)
15:00:38 <lambdabot> f a b c = (a c, b c)
15:00:43 <emertens> @. pl djinn (a -> a) -> (a -> a) -> a -> (a,a)
15:00:44 <lambdabot> f = liftM2 (,)
15:00:45 <shapr> I don't know, I always rename mine to the full title.
15:00:49 * shapr googles
15:00:59 <musasabi> dcoutts: sounds like it could make sense. Have to read the mail.
15:01:01 <emertens> liftM2 (,) (+1) (+2) 3
15:01:07 <emertens> > liftM2 (,) (+1) (+2) 3
15:01:08 <lambdabot>  (4,5)
15:01:25 <Heffalump> ok, don't worry
15:01:27 <shapr> Heffalump: Here's how I found it - http://scholar.google.com/scholar?q=modal+calculus+effect+handling
15:01:28 <lambdabot> Title: modal calculus effect handling - Google Scholar
15:01:54 <shapr> That also turns up several of the chapters in this series.
15:01:56 <emertens> @. pl djinn (a -> b) -> (c -> d) -> (a,b) -> (b,d)
15:01:57 <lambdabot> (line 1, column 1):
15:01:57 <lambdabot> unexpected "-"
15:01:57 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
15:02:08 <emertens> @djinn (a -> b) -> (c -> d) -> (a,b) -> (b,d)
15:02:09 <lambdabot> -- f cannot be realized.
15:02:25 <emertens> ((+1) *** (+2)) (4,5)
15:02:30 <emertens> > ((+1) *** (+2)) (4,5)
15:02:31 <lambdabot>  (5,7)
15:03:59 <shapr> Heffalump: If you read some of that series, please tell me if you also notice commutative monads.
15:04:30 <shapr> It jumped out at me, but it may not jump out at me tomorrow.
15:04:44 <Heffalump> I couldn't see anything about them.
15:04:48 <Heffalump> It was why I was interested.
15:05:35 <shapr> They're not explicitly mentioned, but splitting existing monads into necessity and possibility sounds like exactly that.
15:07:25 <Heffalump> the stuff about exceptions would seem to imply that
15:08:06 <emertens> I need that quote about bug theory
15:08:15 <emertens> @quote dons
15:08:15 <lambdabot>  but let is more lazy ;)
15:08:18 <emertens> @quote dons
15:08:18 <lambdabot>  I don't mind autoconf, except for the fact that it's stupid and ugly
15:08:44 <emertens> hmm... who said that?
15:08:45 <musasabi> dcoutts: the third suggestion looks like the best, but also the most complex.
15:08:55 <dcoutts> musasabi, heh :-)
15:09:22 <tennin> are comonads relevant to the expression problem?
15:10:04 <musasabi> dcoutts: evil alternative. drop package(...) entirely from configurations.
15:10:25 <dcoutts> musasabi, ok, how do we do the fps one?
15:11:28 <turol> I'm having some trouble with DriFT, can anyone help?
15:12:11 <musasabi> let me formulate that.
15:12:11 <turol> First, my module imports Data.List, but drift complains: "can't find module Data.List"
15:12:26 <dcoutts> musasabi, ok
15:13:59 <tennin> I've been very confused about the relationship between functional and object-oriented approaches to data abstraction and extensibility
15:14:22 <musasabi> build-depends: (Flag(old-fps) & fps); configuration: old-fps; ghc-options: -DUSE_OLD_FPS
15:14:32 <musasabi> dcoutts: that is make everything explicit.
15:14:56 <tennin> & have read a lot of material on it, like a 1990 paper by William Cook, Oleg Kiselyov's HList and OOHaskell papers, etc.
15:15:19 <musasabi> nothing implicit. Just give expliciteness that the package managers want.
15:15:33 <tennin> it's not that there's any specific thing I don't understand, but I have this persistent feeling that there's something I'm not getting, without knowing exactly what the "something" is
15:15:37 <dcoutts> musasabi, ok let me get that straight, if the old-fps flag is true then we dep on fps
15:15:43 <musasabi> yes.
15:15:58 <musasabi> and force the user to explicitely set flags.
15:16:07 <dcoutts> and we do not distinguish between interesting and automatic choices
15:16:26 <dcoutts> eg choices that are implict from the packages we choose to build against
15:16:37 <stepcut> tennin: does your collection include this recent paper: http://lambda-the-ultimate.org/node/1657
15:16:39 <lambdabot> Title: Software Extension and Integration with Type Classes | Lambda the Ultimate
15:16:39 <dcoutts> and choices that a user will want influence over
15:16:58 <dcoutts> musasabi, there's a certain attractivenss to the fps choice being automatic
15:17:04 <tennin> just downloaded that one this morning
15:17:09 <tennin> haven't looked at it yet
15:17:23 <SyntaxNinja> dcoutts, musasabi: has there been discussion on the ML? anything that should go in a ticket so we can remember it?
15:17:25 <musasabi> dcoutts: only from a non-package-manager perspective.
15:17:40 <stepcut> you should definately look at it -- it compares function vs OO in a bunch of case studies
15:17:41 <musasabi> SyntaxNinja: yes, but nothing ready yet.
15:17:49 <dcoutts> SyntaxNinja, yes, it's mostly on the cabal-devel list
15:17:59 <musasabi> dcoutts: maybe make the defaults explicit?
15:18:12 <SyntaxNinja> dcoutts: excellent. I'll try to catch up ASAP, bit busy at work.
15:18:15 <dcoutts> musasabi, yes, I was suggesting making the defaults explicit
15:18:23 <dcoutts> musasabi, eg my gui example
15:18:37 <tibbe> @hoogle (a, b) -> (b, a)
15:18:37 <musasabi> default: old-fps = base < 2.0
15:18:38 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
15:18:39 <dcoutts> musasabi, flag: gui; default: use(gtk) && use(cairo)
15:19:05 <tennin> OK, sounds good, thanks
15:19:33 <musasabi> default: gui = cairo, gtk
15:19:42 <dcoutts> musasabi, ok
15:19:59 <musasabi> I'll write a mail. I think that solves most of our issues.
15:20:09 <Cale> tennin: One of the main points of the way I think of it is that functional programming tends to emphasize functions with universally quantified types, whereas object oriented programming sort of emphasizes existentially quantified types -- that is, you only know that the values implement some interface.
15:20:16 <dcoutts> musasabi, gui = gtk >= 0.9.10, cairo >= 0.9.10
15:20:26 <musasabi> dcoutts: yes :-)
15:21:02 <musasabi> dcoutts: and two flags --guess-flags and --no-guess-flags
15:21:44 <dcoutts> musasabi, yeah ok, --no-default-flags makes all flags false unless enabled with --enable-foo
15:22:00 <dcoutts> musasabi, Gtk2Hs does eactly that. It has ./configure --enable-packager-mode
15:22:07 <musasabi> dcoutts: with guess-flags it first guesses the values of flags and then changes things with --enable-foo. and --no-default-flags like you said.
15:22:10 <musasabi> ok.
15:22:15 <musasabi> I'll write that to the ml
15:22:19 <dcoutts> musasabi, and in that mode you must explicity use --enable-libglade --enable-gconf
15:22:27 <dcoutts> so you only get the deps you ask for
15:22:37 <musasabi> yes
15:23:03 <dcoutts> musasabi, do you mean guess? or default?
15:23:42 <tennin> so perhaps my unease about the subject could be termed Existential Angst
15:23:51 <musasabi> -> email
15:24:36 <dcoutts> musasabi, then when I make a gentoo package I need to decide manually which flags correspond to interesting user decisions and which are really automatic
15:25:15 <stepcut> tennin: :p
15:25:27 <emertens> Who wants type errors at compile time? I know I don't. If I can put them off as run-time errors, they become the maintainer's problem.
15:25:29 <tennin> I was thinking about it in terms of "abstract data types (functional) allow for the addition of new functions, procedural data abstraction (OO) allows for the addition of new constructors/subclasses"
15:25:39 <dcoutts> hmm, it'd be nice to distinguish the ones where it's really automatic from the interesting cases.
15:26:11 <tennin> that satisfied me for a while, but now I'm afraid there's more to it than that
15:26:30 <dcoutts> there's really nothing you can do with the base<2 ==> fps condition
15:26:42 <dcoutts> perhaps I can recognise that automatically
15:26:50 <stepcut> tennin: he talks about that in the paper
15:26:52 <dcoutts> and not try to turn it into a USE flag
15:27:33 <stepcut> emertens: Data.Dynamic ;)
15:35:51 <musasabi> dcoutts: sent.
15:35:57 <dcoutts> musasabi, ta
15:37:12 <musasabi> http://www.haskell.org/pipermail/cabal-devel/2006-August/000090.html
15:37:13 <lambdabot> Title: issues with configurations
15:37:53 <musasabi> dcoutts: is cabal-install fine with that?
15:37:57 <dcoutts> musasabi, I think so
15:38:09 <dcoutts> musasabi, it's not trivial of course, but I think it's possible
15:39:10 <dcoutts> musasabi, so I think I can identify uninsteresting flags
15:39:25 <dcoutts> musasabi, if the default value only depends on things that are already in build-depends
15:39:33 <dcoutts> eg that fps one
15:39:37 <dcoutts> default: old_fps = base < 2
15:39:47 <dcoutts> we've already got build-depends: base
15:39:59 <dcoutts> so there's no additional choice there
15:40:08 <dcoutts> by fixing base we fix the other thing
15:40:44 <dcoutts> hmm, though we can override this and have the compile break
15:40:54 <musasabi> yes.
15:41:03 <dcoutts> is that a feature? :-)
15:41:04 <musasabi> The user is allowed to shoot herself in the foot.
15:41:30 <sieni> himself, mostly
15:43:06 <musasabi> dcoutts: that can be made safe:
15:43:41 <musasabi> build-depends: base, Flag(old_fps) ? (fps, base < 2)
15:44:19 <musasabi> but in general it allows the user to choose conflicts.
15:44:23 <dcoutts> right
15:44:39 <musasabi> but they can be catched if the author wants it.
15:44:47 <dcoutts> I wonder if we can formalise some flags that can be done automatically without the possabilty to override
15:45:00 <dcoutts> eg my test about if it only mentions things in build-depends
15:45:55 <musasabi> build-depends: (Flag(A) & Flag(B)) ? (Flags_A_and_B_are_not_compatible)
15:45:58 <dcoutts> musasabi, how does that work? "Flag(old_fps) ? (fps, base < 2)"
15:46:28 <dcoutts> og that's &&
15:46:46 <dcoutts> "Flag(old_fps) ? (fps >= 0.8 && base < 2)"
15:47:01 <musasabi> dcoutts: in that case if we have base-2.0 and --enable-old_fps then 1) it chooces an oldder version of base, 2) complains that it doesn't exist
15:47:08 <dcoutts> right
15:47:27 <musasabi> dcoutts: && should be changed to , to retain compatiblety
15:47:35 <dcoutts> musasabi, yes
15:47:37 <musasabi> dcoutts: the '&' in cexp is just a typo
15:47:45 <dcoutts> I'm fine with ,
15:47:46 <musasabi> it should be ',' too
15:47:56 <dcoutts> I just need to remember to understand it as &&
15:52:36 <musasabi> now we only need to sell this to Simon and get it as stable in one week ._.
15:53:06 <musasabi> -as
15:53:24 <dcoutts> musasabi, heh, yeah :-)
15:54:20 <musasabi> Want to do an implementation based on the latest spec + the patches lying around? Or should I just bite the bullet.
15:56:56 <dcoutts> musasabi, I'm quite busy with the ByteString paper which is due in 10 days
15:57:18 <dcoutts> musasabi, I'm happy to talk about it of course :-)
15:59:13 <musasabi> dcoutts: if you can look whether the spec has any obvious problems I can try to find time to implement on the weekend nights. But probably don't have time to think properly, just hack together an implementation.
15:59:34 <dcoutts> ok
15:59:40 <dcoutts> I'll read it more carefully
16:03:08 <dcoutts> musasabi, what is 'T' ?
16:03:18 <musasabi> dcoutts: True
16:03:23 <dcoutts> ok
16:03:34 <dcoutts> how about 'True' ? :-)
16:03:52 <dcoutts> why do we need true ?
16:04:02 <musasabi> dcoutts: it was needed in the older spec with 'or', but maybe it can be dropped now from bexp.
16:04:13 <dcoutts> ok
16:04:13 <musasabi> dcoutts: for cexp it is needed.
16:04:21 <musasabi> default: debug = !True
16:04:34 <dcoutts> ah yes
16:04:40 <dcoutts> how about adding False too there
16:05:37 <musasabi> dcoutts: that is simply extending the parser to parse "False" and return "CNot CTrue". Keeps things simpler without it.
16:06:00 <dcoutts> yes, ok if it's only in the parser that's ok
16:06:15 <dcoutts> it's jsut a bit embarassing to have to write !True :-)
16:06:19 <dcoutts> btw, &&, || is probably better than &, |
16:06:32 <dcoutts> Simon used && || in his proposal
16:06:44 <musasabi> make that "," and "or" perhaps?
16:06:46 <dcoutts> since those are the Haskell logical operators
16:06:58 <dcoutts> hmm
16:07:05 <musasabi> && and || are fine too. (in cexp)
16:07:11 <sieni> hey, make them 'andalso' and 'orelse'
16:07:25 * sieni vomits
16:07:36 <musasabi> feel free to change the names. Having them separate for cexp actually makes sense.
16:07:58 <musasabi> Thus && and || would be good.
16:09:11 <musasabi> cexp = '(' cexp ')' | cexp '||' cexp | cexp '&&' cexp | 'True' | '!' cexp | 'Flag(' string ')'
16:09:30 <dcoutts> ok
16:09:35 <dcoutts> ok and instead of 'default:' flag-name '=' ...
16:09:47 <dcoutts> how about 'flag:' flag-name '=' ...
16:09:54 <dcoutts> ie s/defaut/flag
16:10:15 <musasabi> bexp = '(' bexp ')' | bexp ',' bexp | cexp '?' bexp | package-name-with-version
16:10:39 <dcoutts> musasabi, ah for that one, there's an alternative:
16:10:48 <musasabi> flag and default sound equally good to me. Feel free to choose.
16:10:58 <manyfold> if i use a tuple of an integer and a char i always get the Not in scope error in GHCi
16:11:11 <dcoutts> bexp = bexp ',' bexp | cexp '?' '(' bexp ')' | package-name-with-version
16:11:21 <manyfold> what went wrong?
16:11:30 <dcoutts> musasabi, ie we only need '(' ')' with '?'
16:11:34 <dcoutts> I think
16:11:39 <musasabi> dcoutts: that is also fine.
16:11:45 <dcoutts> manyfold, what did you type exactly?
16:12:04 <dcoutts> musasabi, what does this mean exactly? :
16:12:06 <dcoutts> 'default:' flag-name '=' (bexp | Os(...) | ...)
16:12:10 <dcoutts> the  (bexp | Os(...) | ...)  bit
16:12:12 <musasabi> dcoutts: but allowing parenthesises anywhere seems sensible.
16:12:15 <manyfold> snd.fst ((1, a), "foo")
16:12:30 <dcoutts> musasabi, yeah it does, but after a ? perhaps it's necessary
16:12:39 <dcoutts> musasabi, or foo ? bar, baz
16:12:46 <musasabi> dcoutts: point. change it.
16:13:13 <dcoutts> that's ok so long as it is parsed as (foo ? bar), baz and not foo ? (bar, baz)
16:13:26 <dcoutts> well one or the other
16:13:37 <dcoutts> requiring ()'s will make that explcit
16:13:44 <dcoutts> so people can't be confused
16:14:39 <dcoutts> manyfold, a is a varialbe name, you want 'a' which is a character
16:14:41 <dcoutts> > a
16:14:42 <lambdabot>  Not in scope: `a'
16:14:44 <dcoutts> > 'a'
16:14:45 <lambdabot>  'a'
16:14:48 <musasabi> "(bexp | Os(...) | ...)" should probably dexp. dexp = cexp extended with Os(..), Arch(...), Compiler(...)
16:15:05 <dcoutts> ah ok, os(), arch() etc
16:15:06 <musasabi> and package-name-with-version
16:16:05 <musasabi> (getting defaults wrong should be non-fatal as they are just a guess and the user can easily override them)
16:16:35 <dcoutts> right
16:17:20 <dcoutts> though as I said before, it'd be nice if we could distinguish genuine choices from ones where if you make the wrong choice it's always an error
16:17:48 <dcoutts> not top priority though
16:19:18 <dcoutts> SyntaxNinja, you about? got any time to consider our proposal?
16:20:35 <musasabi> dcoutts: the wrong choice is not always an error with e.g. fps.
16:20:54 <musasabi> dcoutts: one may want to test the separate fps branch instead of using the base.
16:21:25 <dcoutts> musasabi, that doesn't work because the module names are the same
16:21:50 <musasabi> dcoutts: it does work if you have an older base available in addition to the new base.
16:21:55 <dcoutts> true
16:22:12 <dcoutts> which is not totally implausable
16:22:39 <dcoutts> actually, we can already detect if packages have name overlaps
16:23:00 <musasabi> don't overlaps become allowed in future GHC?
16:23:05 <eivuokko> It might also start working in ghc after package name is included in link-time identifiers.
16:23:08 <dcoutts> yes
16:23:48 <dcoutts> though I think that only works if the thing is not exposed in an interface
16:23:54 <dcoutts> ie only used privately
16:24:22 <dcoutts> if A & B use the ByteString type and need to pass from one to the other then we need to pick a single fps impl
16:24:45 <dcoutts> base.Data.ByteString.ByteString is considered a different type from fps.Data.ByteString.ByteString
16:24:52 <musasabi> true
16:25:08 <dcoutts> I think cabal will need build-depends and private-build-depends
16:25:16 <dcoutts> but that's for later
16:28:01 <musasabi> I'll look for the corrected version and do something in ~22hours or something like that probably.
16:28:16 <dcoutts> cool
16:28:54 <dcoutts> musasabi, I'll prod JaffaCake and SyntaxNinja for some review
16:29:09 <musasabi> thanks
16:33:34 <emertens> having worked through some toy functions in the (->) Monad with do notation... I'm finally figuring out why the heck it works :)
16:34:07 <musasabi> emertens: it might be better not to use that in real code. Confuses people a lot.
16:34:27 <emertens> musasabi: it's important to understand it to know what lambdabot is talking about tho :)
16:35:02 <musasabi> She teaches bad manners.
16:39:28 <emertens> but still, it's like back in middle school when you figure out the power rule for derivatives
16:39:37 <emertens> and then later, when you actually learn the math behind it
16:39:43 <emertens> you get the "why" :)
16:40:03 <manyfold> what would be a good editor for haskell under windows?
16:40:21 <emertens> WinHugs + ViM/TextPad
16:40:26 <lispy> we didn't learn derivatives till college :(
16:40:31 <emertens> VisualHaskell (VS.NET 2003)
16:40:41 <lispy> manyfold: i use emacs + visual haskell
16:41:03 <emertens> In 8th grade math we could "test out" of chapters and do something else as long as it was educational
16:41:18 <emertens> so my friend and I learned to do assembly programming on the Ti-86
16:41:25 <emertens> and a little calc
16:41:58 <lispy> cool, that's a useful substitute to the boring math they would have taught
16:42:23 <lispy> spending a week on roman numerals was a bit of a waste other than the problem solving skills
16:42:29 <emertens> heh
16:43:27 <lispy> does record syntax work with datatypes that have multiple constructor?
16:43:49 <lispy> actually, i think i'm done extending haxml for a while
16:43:56 <lispy> time to try out the code and see if i like it
16:44:52 <emertens> there isn't a way to split a screen vertically in "screen" is there?
16:45:07 <lispy> hmm...never tried
16:45:14 <sieni> emertens: isn't the power rule trivial at least for integer powers?
16:45:24 <emertens> sieni: yes it is
16:45:29 <emertens> sieni: and that's why it's easy to figure out
16:47:23 <heatsink> lispy: yes
16:47:28 <emertens> I found a patch: http://fungi.yuggoth.org/vsp4s/ ... don't know how well it works out
16:47:29 <lambdabot> Title: Vertical Split for GNU Screen
16:47:30 <sieni> for arbitrary real powers, i don't think it's too simple, although not very difficult either
16:48:03 <emertens> in general... derivatives of polynomials are easy
16:48:56 <sieni> I wasn't talking about polynomials, but d/dx x^\alpha, where \alpha is an arbitrary real number instead of an integer
16:49:59 <lispy> heatsink: how does that work?
16:50:11 <lispy> heatsink: or maybe i'm making it harder than it needs to be...
16:51:46 <emertens> d/dx (x^2.7) = x^1.7 / 2.7
16:51:51 <emertens> still as easy :)
16:54:19 <Cale> D(x^a) = D(exp(a log x)) = exp(a log x) D(a log x) = x^a * a * 1/x = a * x^(a-1)
16:56:23 <sieni> cale: yes, 10 points
16:56:53 <heatsink> lispy: An accessor function has to have the same type for all constructors.
16:57:15 <heatsink> lispy: It will return/modify the field if the field is present, and cause an exception otherwise.
16:57:29 <sieni> Cale: and a parrot mark
16:57:39 <Cale> hehe
16:59:02 <sieni> So the facts that Cale used were
16:59:04 <sieni> :
16:59:05 <sieni> 1
16:59:08 <sieni> fuck
16:59:12 <sieni> stupid keyboard
16:59:35 <sieni> 1) the definition of x^a as exp(a log x)
16:59:36 <sieni> 2
16:59:39 <Cale> The chain rule, linearity of differentiation, derivative of exp, derivative of log, definition of x^a
16:59:49 <sieni> yes
17:00:04 <sieni> you are less think as I drunk I am
17:00:21 <sieni> except I was about to say more ^_^
17:01:13 <Cale> Oh, I suppose there's a few more :) Commutativity/associativity of multiplication, x^a/x^b = x^(a-b) :)
17:01:16 <sieni> the derivative of exp comes from the definition of exp (exp' = exp and exp(0) = 1) and the derivative of log comes from the rule for the derivative of the inverse function
17:01:25 <Cale> yeah
17:01:36 <Cale> Well, depends what you define first
17:01:59 <Cale> Some things define log first as an integral and get exp by inversion.
17:02:37 <Cale> But it seems nicer to define exp first in general
17:02:47 <sieni> I think the least painful way is just to define exponential as the unique function that satisfies exp'==exp and exp(0)==1 and prove all the resulting properties from that
17:03:00 * merus hunts around for a beginner haskell problem to solve :)
17:03:19 <Cale> You have to know a bunch of stuff about differential equations to show that a solution to that exists though
17:03:41 <Cale> I quite like the definition  exp(x) = sum over n >= 0 of x^n / n!
17:04:07 <merus> Cale: I like that def. too! It's the way one extends exp(x) to exp*(x) :)
17:04:19 <Cale> exp*?
17:04:26 <merus> Non-standard
17:04:29 <Cale> ah
17:04:37 <Cale> yeah, probably :)
17:04:56 <merus> It shows up in a NSA proof for the FTA (some old article in the MAA)
17:04:58 <emertens> saying "Non-standard" wasn't enough for everyone to know what you were talking about
17:05:03 <Cale> It's also how you extend exp to complex numbers and matrices
17:05:11 <Cale> emertens: was enough for me :)
17:05:26 <merus> Oh, sorry.  Non-standard analysis... it's pretty...
17:05:29 <emertens> not all of us are pure math grad students
17:05:32 <Cale> hehe
17:05:36 * merus is not a grad student! :(
17:06:34 <merus> What's a good beginner problem to solve in haskell?  I thought about writing a topological sort algo, but it might be beyond my skill
17:06:34 <Cale> http://www.math.wisc.edu/~keisler/calc.html
17:06:38 <lambdabot> Title: Elementary Calculus
17:06:41 <sieni> well, I like the differential equation definition, since it's manifestly global (except of course for the initial value), but a power series is pretty local
17:07:50 <madpickle> nice site, Cale.
17:07:56 <madpickle> slowass website tho
17:08:04 <madpickle> i should be getting 600KB/s :/
17:08:09 <madpickle> but i'm barely topping 60
17:08:44 <Cale> It's only 24MB anyway
17:09:08 <madpickle> yeah, but... but..
17:09:13 <madpickle> it should be instantaneous :/
17:09:48 <emertens> infix constructors need a right hand side :) rhs
17:09:50 <merus> What are we going to do when broadband internet becomes unsustainable?  Go through withdrawal? :)
17:10:15 <madpickle> i'm moving to a new apartment in a week or so
17:10:26 <madpickle> i am dreading the internet outage until i can get NTHell cable installed
17:10:28 <madpickle> mmm, 10 mbps
17:10:42 <sieni> it's not too obvious, but for example if you define sine and cosine with sin' = cos, cos' = -sin, sin(0) = 0, cos(0) = 1, you immediately get the usual properties of sine and cosine in addition to stuff like periodicity and such, which certainly are not obvious from the power series
17:12:34 <merus> Can you get continuity that way without a ton of ODE theory?
17:13:31 <sieni> depends, what you mean by 'a ton' :-)
17:13:40 <Pseudonym> I think it's more obvious from the Lie group representation.
17:13:51 <Cale> Hehe
17:14:12 <Pseudonym> You get continuity for free from the fact that it's a Lie group.
17:14:22 <merus> Pseudonym: well, yeah :P
17:14:26 <Pseudonym> And the periodicity is fairly obvious from the structure of the generator.
17:16:03 <Pseudonym> And for an added bonus, it becomes obvious why cosh and sinh are not periodic.
17:18:01 <Cale> Except that you need to define and prove a bunch of stuff about Lie groups before you can define exp that way :)
17:18:11 <Pseudonym> Well, yeah.
17:18:54 <sieni> and contains the differential equation stuff as a subset ;-)
17:19:07 <Pseudonym> Although, I guess it's really geometric calculus.
17:23:41 * Pseudonym just finished a book on quantum field theory
17:23:47 <Pseudonym> Sorry, I have Lie groups on the brain at the moment.
17:24:19 <Pseudonym> And I dreamed about Greens functions lat night.
17:24:20 * Pseudonym sighs
17:24:45 <sieni> I had them on my brain last time 2003, when I was reading Knapp's book "Lie Groups: Beyond an introduction"
17:25:23 <sieni> (which is a nice book)
17:25:24 <Pseudonym> Yeah, that's a good book.
17:25:54 <Pseudonym> I especially liked the appendix which explained things in terms of category theory.
17:25:58 <Pseudonym> Though it didn't used that term.
17:26:44 <Pseudonym> I think what would be good is a textbook about quantum mechanics that isn't a history book.
17:27:00 <Pseudonym> You start from first principles with Feynman's formulation.
17:27:12 <Pseudonym> With geometric calculus.
17:27:16 <sieni> but category theory sucks ;-)
17:27:38 * sieni used to be an analyst
17:28:09 <Pseudonym> So you surely should say: category theory _used_ to suck.
17:28:46 <sieni> how have the things changed?
17:29:09 <newbcoder> someone please englitehn me on hugs vs ghc
17:29:19 <Pseudonym> You used to be an analyst.
17:29:26 <Pseudonym> So surely category theory used to suck.
17:30:13 <sieni> yes
17:30:42 <sieni> which doesn't mean that category theory doesn't suck anymore
17:31:11 <shapr> @users
17:31:12 <lambdabot> Maximum users seen in #haskell: 235, currently: 197
17:35:17 <emertens> What did you analyze?
17:40:00 <monochrom> category doesn't suck. never did. :)
17:41:16 <musasabi> or it sucks only up to a canonical isomorphism ;)
17:42:32 <merus> :O
17:44:19 <Pseudonym> Category Theorists Do It Up To Isomorphism
18:13:23 <ell-hask> I've got a small problem, if someone can help:  I am trying to make a genetic algorithm program (for practice, not academics) and I need random numbers.
18:13:23 <lambdabot> ell-hask: You have 1 new message. '/msg lambdabot @messages' to read it.
18:14:34 <ell-hask> So, I have decided to make an infinate list of random numbers lazily read from /dev/random.
18:14:52 <kfish> ell-hask, System.Random ?
18:14:56 <ell-hask> The problem is this darn IO system, I can't seem to USE my lazy list!
18:15:20 <kfish> http://www.haskell.org/ghc/docs/6.4.2/html/libraries/base/System-Random.html
18:15:28 <kpreid> ell-hask: use readFile
18:15:53 <kpreid> that will give you a lazy list of the contents of /dev/random
18:16:20 <ell-hask> kpreid: And I can read it into a [Int] not String?  Sounds good
18:16:36 <kpreid> no, but you can use Char.ord
18:17:30 <kpreid> map Char.ord contents
18:18:20 <stepcut> > map Char.ord "hello123"
18:18:21 <lambdabot>  [104,101,108,108,111,49,50,51]
18:18:51 <ell-hask> and thus my integers will all be <256 ?  Which is fine, I just need to know
18:19:19 <monochrom> To be honest I think you know better than us how /dev/random behaves
18:19:35 <stepcut> ell-hask: System.Random might be more what you want
18:19:48 <Pseudonym> The problem with /dev/random is you don't get many random numbers per second.
18:19:55 <Pseudonym> It's quite slow.
18:20:11 <Pseudonym> It's far better to use that as a seed for a faster RNG.
18:20:18 <monochrom> I presume that ell-hask has a very, very strong reason for using /dev/random rather than Random.
18:20:31 <ell-hask> Oh, I know, don't worry about that, /dev/urandom would be fine.  This just makes the learning include file IO.
18:20:36 <Pseudonym> Personally, I've found System.Random fine for genetic algorithm-type stuff.
18:20:57 <Pseudonym> If you need monte carlo-type stuff, a Mersenne Twister is great.
18:21:41 <Pseudonym> I personally wouldn't use /dev/random for anything other than a seed.
18:21:54 <Pseudonym> Or, say, TCP sequence numbers.
18:22:01 <Pseudonym> i.e. for a small amount of data at a time.
18:22:12 <Pseudonym> If you need a crypto-strong RNG, you know where to find them.
18:24:04 <monochrom> /dev/zero is also a nice file for learning readFile :)
18:24:08 <ell-hask> Pseudonym: thanks all, I am making the changes right now.
18:24:15 <Pseudonym> Cool.
18:24:29 <ell-hask> lol, yes, I am sure it is... or I could just do z = 0 : z
18:25:28 <Pseudonym> I imagine that /dev/zero would be hard to test.
18:26:25 <emertens> /dev/srandom is better when randomness counts
18:27:28 <monochrom> I usually use "yes | runghc my.hs" to check my response time and memory usage. :)
18:28:20 <vincenz> @localtime dons
18:28:22 <lambdabot> Local time for dons is Fri Aug 11 11:26:31 2006
18:28:32 <syntaxfree> @localtime vincenz
18:28:34 <lambdabot> Local time for vincenz is Fri Aug 11 03:28:12 2006
18:28:52 <syntaxfree> @localtime syntaxfree
18:29:12 <ell-hask> dons: You're hilarious.  Yes, I agree, lamdabot rocks.
18:29:12 <syntaxfree> BAH!
18:35:33 <emertens> I've got a genius plan to have my computer setup next to my couch so I don't need to use this damn desk...
18:35:44 * emertens disconnect
18:38:17 <ell-hask> Ok, so I guess I just don't understand IO at all... or I am too tired.  I can't get this 'IO String' into a 'String'
18:38:49 <Pseudonym> ?google ThatAnnoyingIoType
18:38:49 <mauke> yeah, that's the point of IO :-)
18:38:51 <lambdabot> http://www.haskell.org/hawiki/ThatAnnoyingIoType
18:38:52 <lambdabot> Title: ThatAnnoyingIoType - The Haskell Wiki
18:41:21 <ell-hask> But then I can't make my program module how I want it.  I can do:
18:41:52 <ell-hask> do ; r <- readFile "/dev/urandom" ; rands = map Char.ord r ; doSomethingWithRands rands
18:41:55 <ell-hask> but I can't do:
18:42:34 <ell-hask> do: let rands = getLazyInfiniteRands "/dev/random" ; doSomethingWithRands rands
18:42:40 <Pseudonym> No, you can't.
18:42:43 <mauke> exactly
18:42:48 <emertens> You know, I was thinking today that someone should have told me about performUnsafeIO when I first asked "How do I get a String out of an IO String"
18:42:48 <ell-hask> But I want to
18:42:58 <mauke> getLazyInfiniteRands is not a function
18:42:58 <Pseudonym> Because getLazyInfiniteRands is not referentially transparent.
18:43:09 <Pseudonym> What you _could_ do is this:
18:43:18 <Pseudonym> do rands <- getLazyInfiniteRands "/dev/random"
18:43:30 <Pseudonym>     let foo = doSomethingWithRands rands
18:43:38 <Pseudonym> Where doSoemthingWithRands is just a function.
18:43:48 <emertens> isn't that really how you are supposed to do it?
18:44:05 <Pseudonym> "Supposed to" is an open question.
18:44:20 <emertens> ok. Isn't that why the do syntax was created?
18:44:44 <Pseudonym> The do syntax was created because it's nicer than the bind syntax.
18:45:35 <emertens> either way, there is such a thing as idiomatic haskell
18:45:49 <Pseudonym> Sure, though it's constantly evolving.
18:46:10 <Pseudonym> What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days.
18:47:40 <greenrd> How do I just greedily read as many tokens as possible with a ReadP parser?
18:48:00 <dons> ?remember Pseudonym What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
18:48:00 <lambdabot> Done.
18:48:33 <dons> Pseudonym: and so we should bring back some of the things we tossed out (monad comprehensions..) since they're not scary anymore
18:48:33 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
18:48:38 <greenrd> head of the result reads one token; head . tail of the result reads two; last of the result diverges, unfortunately.
18:48:50 <Pseudonym> They're not scary, but they're not fun for first-year students.
18:48:57 <Pseudonym> H98 was designed for first-year students.
18:49:14 <dons> yes.
18:49:38 <emertens> dons: did you see the quote I posted from wikipedia wrt monad comprehensions?
18:49:47 * dons looks
18:50:31 <Pseudonym> This theorem simplification thingy is hard.
18:50:40 <Pseudonym> Thingy == hard
18:51:13 <greenrd> I guess I need to use manyTill
18:51:40 <edwardk> @type manyTill
18:51:42 <lambdabot> Not in scope: `manyTill'
18:51:56 <ell-hask> I can't make a call read a file and return an [Int]  it has to return an IO something, so I don't see how I can: "do rands <- getLazyRands "/dev/random" ; let food = doSomethingWithRands rands" without propagating the 'map Char.ord' function into foo
18:52:27 <edwardk> ell-hask you CAN cheat and do unsafePerformIO
18:52:39 <mauke> I don't understand the propagating part
18:52:54 <ell-hask> I'd like to map it first.  I can, but unsafePerformIO is not something I would be comfortable with doing and calling it a night.
18:53:01 <mauke> isn't getLazyRands :: String -> IO [Int]?
18:53:15 <ell-hask> mauke, that is exactly what I am not liking.
18:53:20 <edwardk> ell: then change the signature of the function to have the right type.
18:53:47 <ell-hask> @where pasty
18:53:47 <lambdabot> I know nothing about pasty.
18:53:50 <edwardk> mauke: you have to be careful, no, getting MORE ints requires you to do more IO
18:53:52 <ell-hask> @where paste
18:53:53 <lambdabot> http://paste.lisp.org/new/haskell
18:54:15 <edwardk> so you might have to do something uglier
18:54:19 <dons> ?where hpc
18:54:19 <lambdabot> I know nothing about hpc.
18:54:26 <dons> ?where+ hpc http://www.galois.com/~andy/hpc-intro.html
18:54:26 <lambdabot> Done.
18:55:32 <stepcut> dons: did you see this? http://www.opencyc.org/ - sounds like the beginning of a new lambdabot pluggin :)
18:56:12 <dons> oh!
18:56:32 <stepcut> maybe some more brains for vixen or something :p
18:56:32 <edwardk> so wouldn't the correct method be to make getRandomInts :: [IO Int] and then sequence to pull off how many you want?
18:56:50 <edwardk> or rather pull part off and sequence it or convert it some how
18:57:02 <edwardk> stepcut: groan
18:57:10 <edwardk> cyc is hideous
18:57:24 <stepcut> edwardk: i bet
18:57:30 <Pseudonym> Goodness, it's only been 20 years.
18:57:31 * dons tries out hpc
18:57:34 <Pseudonym> Cyc is now ready?
18:57:42 <edwardk> well, the opensource version has been released
18:57:43 <stepcut> Pseudonym: apparently
18:57:46 <stepcut> :p
18:57:56 <edwardk> iirc from 5 years ago, they were releasing a stripped down version to get people used to working with microtheories
18:58:04 <edwardk> this appears to be that
18:58:24 <dons> "This version of hpc is available under a BSD-style license for free use
18:58:25 <dons> by all sectors of the Haskell community."
18:58:30 <dons> hehe. screw those python guys
18:59:07 <edwardk> hpc?
18:59:12 <ell-hask> dons: are you working for Galois?
18:59:28 <edwardk> ah for testing, i see
18:59:33 <dons> ell-hask: nope.
19:01:58 <syntaxfree> is there a built-in function for Newton's binomial?
19:03:07 <syntaxfree> @hoogle Int->Int->Int
19:03:07 <lambdabot> No matches, try a more general search
19:03:13 <glguy> Maybe I don't understand the full applicability of Newton's binomial... but I doubt that it's in the library
19:03:19 <syntaxfree> @hoogle (Integral a)=>Int->Int->Int
19:03:20 <lambdabot> No matches, try a more general search
19:03:27 <lisppaste2> ell-hask pasted "rands" at http://paste.lisp.org/display/23968
19:03:48 <syntaxfree> okay! I just didn't want to write naive factorials in Haskell or something.
19:03:57 <Pseudonym> http://andrew.bromage.org/darcs/
19:04:00 <lambdabot> Title: Index of /darcs
19:04:02 <glguy> let rand = something is not the same as rand <- something
19:04:07 <Pseudonym> Take a look.
19:04:21 <edwardk> syntax: binomial formula as in (1+x)^p = sum 0..inf (p choose n) x^n right?
19:05:08 <edwardk> syntax: not sure i see the problem with just writing (1+x)^p and letting cheap exponentiation do your work =)
19:05:13 <lisppaste2> ell-hask annotated #23968 with "My mistake on the '=' and not '<-'" at http://paste.lisp.org/display/23968#1
19:05:38 <ell-hask> I still can't do that
19:05:43 <ell-hask> Right?
19:06:02 <Cale> ell-hask: do what?
19:06:03 <syntaxfree> binomial formula as in C(a,b) = a!/(b!(a-b)!)
19:06:09 <syntaxfree> where a! = product [1..a]
19:06:12 <ell-hask> i.e. with rands :: [Int] and not rands :: IO [Int] or some such.
19:06:28 <Cale> ell-hask: the type of getRands seems wrong, and you're missing a return
19:06:28 <lisppaste2> emertens annotated #23968 with "modified rands" at http://paste.lisp.org/display/23968#2
19:06:43 <ell-hask> Cale: the annotated paste #23968
19:07:40 <edwardk> i don't see how getRands can be written in the current context.
19:07:45 <stepcut> syntaxfree: http://lnc.usc.edu/~brannon/haskell/HR.pdf
19:07:47 <edwardk> readFile will try to snarf it all the way to the end, no?
19:07:54 <lisppaste2> Cale annotated #23968 with "getRands" at http://paste.lisp.org/display/23968#3
19:07:58 <Pseudonym> syntaxfree: If you can find a faster way to do binomials than that, let me know.
19:07:59 <stepcut> edwardk: no, readFile is lazy
19:08:03 <glguy> ell-hask: i left out the change to getRands, you need to return the result
19:08:06 <edwardk> ah k
19:08:09 <Pseudonym> It's even fast for n up to 1000000 or so.
19:08:22 <ell-hask> emertens: Right, so I have to pass an [Char] to 'function' I can't seem to turn it into an [Int] first.
19:08:43 <Cale> ell-hask: sorry, what?
19:09:00 <glguy> ell-hask: you turn the String -> IO [Int]
19:09:27 <ell-hask> Cale: My getRands function is not valid (I know that) so my point is, I want to call ONE "function" and get a lazy infinite list of numbers from some source.
19:09:29 <Cale> ell-hask: you apply getRands to a string (filename) to get an action, which you run to get a list of integers.
19:09:40 <Cale> ell-hask: did you see my annotation?
19:09:52 <glguy> ell-hask: Cale is saying that an IO [Int] is an IO action that returns a list of Ints
19:09:56 <edwardk> hrmm. ok. i had assumed otherwise
19:10:37 <Cale> of course, you're running it from main -- you have the right syntax there
19:10:50 <edwardk> think of IO like a form of taint that we use to mark all the evil impure functions with
19:10:53 <Cale> You'd just given it the wrong type
19:10:55 <Cale> hehe
19:11:00 <Cale> You could think of it like that
19:11:26 <Cale> I just think of it as that you're building these values which are like programs that can be run.
19:11:26 <glguy> We have the IO monad because you touch yourself at night... (family guy reference, I'm not a freak)
19:11:39 <edwardk> gL; heh
19:12:03 <Cale> and there are various ways to combine the programs to make larger ones
19:12:13 <Cale> and in the end, you define an IO-program called main
19:12:20 <Cale> and that's really the only one which runs
19:12:31 <Cale> (unless you run one from ghci or something :)
19:12:49 <edwardk> or are naughty and use unsafePerformIO
19:13:07 <Cale> Don't mention that function.
19:13:13 <glguy> No one told me that unsafePerformIO existed
19:13:15 <Cale> There might be newbies around :)
19:13:17 <glguy> I had to stumble upon it
19:13:19 <Cale> yes
19:13:24 <Cale> That's the way it should be :)
19:13:27 <Cale> hehe
19:13:29 <syntaxfree> So, anyone here took game theory?
19:13:30 <edwardk> oops
19:13:37 * edwardk 's lips are sealed.
19:13:51 <glguy> it took me a long time to trust the channel again after they lied to me
19:13:54 <Cale> hehe
19:14:32 <ell-hask> Wow, ummm.. thanks.  I really had a major misunderstanding about the difference in how you use 'IO a' verse 'a'.  This helps a lot.
19:15:01 <ell-hask> I must be the slowest haskell learner in history.l
19:15:09 <glguy> no kidding
19:15:10 <merus> ell-hask: No, that would be me :)
19:15:11 <glguy> LOL
19:15:13 <glguy> joking
19:15:41 <edwardk> nah, i'm pretty sure all of us have tripped over the meaning of at least one monad before
19:15:57 <greenrd> Why doesn't this work:
19:16:23 <greenrd> import qualified Text.Read.Lex as Lex
19:16:59 <greenrd> manyTill Lex.lex lexEOS where lexEOS = liftM (\Lex.EOF -> ()) Lex.lex
19:17:35 <greenrd> What I'm trying to say in English is "read tokens using Lex.lex until Lex.lex returns an EOF token"
19:17:45 <greenrd> But what I actually get from that is an empty list.
19:20:04 <Lemmih> To what function does 'manyTill' refer?
19:20:05 <lambdabot> Lemmih: You have 2 new messages. '/msg lambdabot @messages' to read them.
19:20:37 <greenrd> @hoogle manyTill
19:20:38 <lambdabot> Text.ParserCombinators.ReadP.manyTill :: ReadP a -> ReadP end -> ReadP [a]
19:20:38 <lambdabot> Text.ParserCombinators.Parsec.Combinator.manyTill :: GenParser tok st a -> GenParser tok st end -> GenParser tok st [a]
19:20:47 <greenrd> Text.ParserCombinators.ReadP.manyTill
19:21:49 <greenrd> so what lexEOS says is, lex a token, if it's EOF, then succeed, otherwise fail (because no pattern match)
19:22:24 <glguy> I think this goes back to those irrefutable patterns...
19:22:27 <glguy> I could be way off
19:22:30 <greenrd> eh?
19:22:34 <glguy> but it looks like those crazy
19:22:38 <glguy> > let 1 =2 in 1
19:22:39 <lambdabot>  1
19:22:51 <greenrd> The pattern is not irrefutable, i.e. it can fail
19:23:06 <glguy> ok
19:23:09 <glguy> just guessing
19:23:17 <glguy> > (\1 -> 'a') 2
19:23:18 <lambdabot>  Non-exhaustive patterns in lambda
19:23:21 <Lemmih> greenrd: Try: do Lex.EOF <- lex; return ()
19:23:35 <glguy> oh
19:23:42 <glguy> when it fails it just calls "fail"
19:23:43 <glguy> right?
19:24:17 <greenrd> well, it should
19:24:18 <greenrd> that'
19:24:32 <greenrd> is some magic which I don't fully understand
19:25:23 <Lemmih> 'do Lex.EOF <- lex; return ()' === 'lex >>= \p -> case p of Lex.EOF -> return (); _ -> fail "..."'
19:25:40 <glguy> @type (===)
19:25:42 <lambdabot> Not in scope: `==='
19:25:53 <glguy> lol
19:25:55 <glguy> neveremind
19:26:11 <stepcut> sweet -> "The GHC typechecker is Turing-complete"
19:27:25 <lispy> it is?
19:27:36 <dons> sure.
19:27:55 <lispy> oh, i thought in history of haskell they said otherwise
19:27:56 <Lemmih> greenrd: The pattern matches in binds fails with 'fail'. All other pattern matches just throw exceptions.
19:27:59 <stepcut> I presume that means the typechecker must encounter the halting problem ?
19:28:11 <dons> the ghc type checker, with current extensions
19:28:28 <lispy> ah, i see the difference
19:28:29 <greenrd> Lemmih: Excellent, thanks.
19:28:39 <lispy> > let f x = f x in f
19:28:40 <lambdabot>  Add a type signature
19:28:41 <greenrd> Lemmih: So it was catching the exception, and that was why it wasn't working?
19:28:45 <lispy> > let f x = f x in f 1
19:28:46 <lambdabot>  Add a type signature
19:28:54 <lispy> oh, i thought that used to print loop
19:29:52 <lispy> so i was going to show that ghc handles some instances of the halting problem :)
19:30:27 <mauke> > let f x = f x in f '1'
19:30:28 <lambdabot>  Add a type signature
19:31:01 <Lemmih> greenrd: No, the pattern match was never evaluated.
19:31:13 <lispy> > let { f :: Int -> Int; f x = f x } in f 1
19:31:17 <lambdabot> Terminated
19:31:20 <Lemmih> greenrd: 'lexEOS' just always succeeded.
19:31:52 <greenrd> oh
19:32:04 <Cale> ell-hask: don't worry, almost everyone has problems with that distinction at first.
19:32:14 <greenrd> Lemmih: why? Is it because the result was never evaluated because it was of type ()?
19:32:33 <Cale> ell-hask: http://haskell.org/haskellwiki/Introduction_to_IO
19:32:34 <lambdabot> Title: Introduction to IO - HaskellWiki
19:34:05 <Lemmih> greenrd: The result isn't used at all and therefore isn't evaluated.
19:34:37 <Lemmih> greenrd: Try replacing '()' with 'undefined' and then look at the type of 'lexEOS'.
19:35:54 <Lemmih> > isJust (liftM (\10 -> ()) (Just 11))
19:35:55 <lambdabot>  True
19:35:56 <Lemmih> > (liftM (\10 -> ()) (Just 11))
19:35:57 <lambdabot>  Non-exhaustive patterns in lambda
19:37:52 <lispy> interesting, "...if you're trying to choose between two theories and one gives you an excuse for being lazy, the other one is probably right."
19:38:24 <monochrom> Who said that?
19:39:08 * Lemmih heads to bed.
19:41:41 <lispy> monochrom: http://www.paulgraham.com/hs.html
19:41:42 <lambdabot> Title: What You'll Wish You'd Known
19:41:50 <lispy> monochrom: paul graham of all people...
19:42:21 <lispy> in "On Lisp" he wrote that if a program has two ways to implement something, the easy way and hard way, they are lazy and will choose the easy way
19:42:45 <gzl> I like Paul Graham.
19:42:48 <lispy> i guess you could argue here that he's saying it's a bad idea too :)
19:43:07 <gzl> some of his essays in particular.
19:43:15 <Pseudonym> @pl \x -> f (p x g)
19:43:15 <lambdabot> f . flip p g
19:43:27 <lispy> gzl: yes, but remember that not everything he says as truth is based on truth
19:43:30 <Pseudonym> @pl \x -> q (fA x) h
19:43:31 <lambdabot> flip q h . fA
19:43:48 <lispy> gzl: but, having said that, as a general rule i agree with him and respect him
19:44:21 <gzl> yeah, I suppose that's a good point. though I'm not talking about his technical essays.
19:44:39 <gzl> (e.g. I haven't read anything he's written on Lisp or Bayesian spam filtering.)
19:45:46 <Pseudonym> Paul Graham is a typical Lisp snob.
19:45:57 <Pseudonym> Having said that, he's a smart guy and worth reading.
19:46:25 <Pseudonym> He's classic proof that smart people can agree to disagree, and yet maintain meaningful, enlightening dialogue.
19:46:41 <Pseudonym> ( ( ( ( f . g = h . fB => f . flip p g = flip q h . fA) => ( f . g = h . fA => f (c1 p g) = c2 q h ) ) => ( f . g = h . fA => f (callcc c1 g) = callcc c2 h ) ) )
19:46:54 <Pseudonym> Free theorem for call/cc.
19:47:08 <Pseudonym> I don't understand it.
19:47:27 <monochrom> You get what you pay for? :)
19:47:32 <lispy> lol
19:47:53 <syntaxfree> Paul Graham is a Lisp snob indeed.
19:48:05 <Pseudonym> The cool thing would be to take a type, work out its free theorem, and then encode the proof of that theorem back into Haskell via Curry-Howard.
19:48:06 <vincenz> don't you ahte those?/
19:48:10 <vincenz> they're like untyped haskell snobs
19:48:23 <lispy> wel,l till about 10 years ago lispers had a reason to be snobbish :)
19:48:36 <syntaxfree> He's also the only business-type person I can agree with, though.
19:48:51 <Pseudonym> I find myself agreeing with Joel on business.
19:49:00 <Pseudonym> Joel on software tends to get a bit simplistic.
19:49:00 <syntaxfree> Spolsky?
19:49:01 <lispy> joel is sharp
19:49:04 <Pseudonym> Yeah.
19:49:13 <vincenz> joel regurgitaes
19:49:16 <Cale> They're always like "I don't need your type systems dragging me down! Values were meant to be free!"
19:49:17 <vincenz> joel regurgites
19:49:18 <syntaxfree> Joel had the worst pop introduction to economics ever.
19:49:19 <vincenz> erg
19:49:22 <vincenz> regurgitates
19:49:27 <syntaxfree> Joel Spolsky = indie John Dvorak.
19:49:32 <vincenz> not to mention he doesn't get all the facts
19:49:40 <Pseudonym> But his main thesis on software is good: If you know Haskell or its ilk, you write better software regardless of what you write in.
19:49:53 <ell-hask> @where dons
19:49:53 <lambdabot> http://www.cse.unsw.edu.au/~dons
19:49:57 <Pseudonym> For "Haskell" substitute any decent language.
19:49:58 <syntaxfree> Joel likes Haskell?
19:50:05 <Pseudonym> Joel likes higher-order.
19:50:07 <syntaxfree> that's a classic Paul Graham statement.
19:50:14 <Pseudonym> Sure.
19:50:26 <emertens> "Any sufficiently complicated Lisp program contains uses an ad-hoc, informally-specified bug-ridden slow implementation of Common Lisp."
19:50:27 <newsham> what would    (.) . (.)    be used for (other than confusing me) ?
19:50:28 <syntaxfree> cf. "The Python Paradox".
19:50:35 <gzl> I don't like Joel much.
19:50:37 <syntaxfree> that's Greenspun :)
19:50:47 <syntaxfree> Joel Spolsky wrote the worst pop introduction to economics ever.
19:50:50 <merus> newsham: that's making my head hurt :(
19:50:58 <Pseudonym> newsham: Pointless programmers are wannabe ASCII artists.
19:51:02 <Pseudonym> This might help.
19:51:03 <Cale> Yeah, that's because you won't (at least without a lot of thought) do silly things like mixing types in a datastructure, or writing functions which cause random side effects.
19:51:05 <newsham> (.) :: (b -> c) -> (a -> b) -> a -> c
19:51:05 <Pseudonym> @type (.) . (.)
19:51:07 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
19:51:17 <syntaxfree> If you knew how irritating pop economics  can be.
19:51:18 <Cale> (If you know haskell)
19:51:21 <gzl> syntaxfree: yeah?
19:51:25 <gzl> syntaxfree: I haven't seen that.
19:51:28 <newsham> ((.) . (.)) x = ((.) (.) (.)) x = (.) ((.) x)
19:51:29 <gzl> the pop economics hting.
19:51:33 <Pseudonym> @djinn ( ( ( ( f . g = h . fB => f . flip p g = flip q h . fA) => ( f . g = h . fA => f (c1 p g) = c2 q h ) ) => ( f . g = h . fA => f (callcc c1 g) = callcc c2 h ) ) )
19:51:33 <lambdabot> Cannot parse command
19:51:38 <vincenz> I think graham writes well tho
19:51:42 <Pseudonym> Errr...
19:51:44 <syntaxfree> Just imagine everyday newspapers waxing philosophical about monads, often with gross errors and never with good intentions.
19:51:46 <emertens> I guess everyone discarded my statement as a Greenspun quote
19:51:46 <vincenz> he's essays are thoughtful
19:51:51 <Pseudonym> @djinn (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
19:51:51 <lambdabot> f a b c d = a (b c d)
19:51:55 <vincenz> his
19:51:55 <Pseudonym> There you go.
19:51:58 <newsham> it composes something with a function that composes something with x?
19:52:00 <vincenz> l
19:52:06 <lispy> i find this essay ment for HS students is very good
19:52:15 <syntaxfree> I never read it.
19:52:35 <syntaxfree> After dropping out of one college and finishing another, and wanting to drop out of grad school to start yet another career, it'd be a bitter experience for me.
19:52:39 <lispy> "It was like someone getting fouled in a soccer game and saying, hey, you fouled me, that's against the rules, and walking off the field in indignation. Fouls happen. The thing to do when you get fouled is not to lose your cool. Just keep playing. "
19:52:40 <Cale> newsham: it composes a function of one parameter with a function of two
19:52:45 <syntaxfree> I wish I knew what I know now while at high school.
19:52:53 <Pseudonym> We all do.
19:53:07 <Cale> Yeah, it totally would have made university easier :)
19:53:10 <Pseudonym> But the thing is, if you knew in high school what you know now, you wouldn't have believed it anyway.
19:53:10 <lispy> syntaxfree: that's the point of PG's essay that i'm reading :)
19:53:24 <syntaxfree> I would have made better career choices.
19:53:34 <Pseudonym> Contrary to popular opinion, most stuff isn't hard to understand, it's just hard to believe.
19:53:43 <Cale> hehe
19:53:46 <edwardk> heh
19:53:47 <syntaxfree> I mean, my entire heart is into programming, yet it's pretty much too late to abandon everything and switch careers.
19:53:48 <newsham> cale: hmm...
19:53:50 <lispy> if i knew now what i knew before i started grad school i'd still be slugging along
19:53:56 <syntaxfree> (sp. since I'm only interested in FP anyway)
19:54:05 <Cale> syntaxfree: what do you do?
19:54:11 <syntaxfree> I'm an economist.
19:54:17 <Korollary> liar
19:54:20 <edwardk> yeah, now i just need to find a place that'll let me do FP all day =)
19:54:27 * Pseudonym holds out a cross to syntaxfree while preparing the holy water
19:54:27 <vincenz> Korollary: prove it
19:54:34 * merus 's head hurts.  Maybe I'll go play Deus Ex and stop trying to read haskell tutorials :)
19:54:43 * edwardk started to go down that route for real syntax. =)
19:54:51 <lispy> merus: oh...that's a fun one, the first or second?
19:54:53 <Jormunder> @pl (\ x y -> (x,y))
19:54:53 <lambdabot> (,)
19:55:02 <merus> lispy: The first; the second stank
19:55:03 <Cale> Economists are supposedly mathematicians who like to convince people that they're talking about money.
19:55:13 <edwardk> I would have had a degree in actuarial science and economics right now if the courses were offered more frequently. =/
19:55:14 <vincenz> nah
19:55:17 <lispy> merus: i liked completing the story..but yeah, the first is classic
19:55:18 <edwardk> cale: heh
19:55:19 <newsham> > ((.) . (.)) (* 2) (+) 1 2
19:55:21 <lambdabot>  6
19:55:28 <merus> Universal ammunition = death of strategy
19:55:34 <syntaxfree> Economists are often political scientists trying to convince people that they're mathematicians.
19:55:58 <gzl> wow. that's really accurate.
19:56:03 <lispy> syntaxfree: wow, s/Economists/HCI researchers/
19:56:05 <syntaxfree> But there has been hard maths in economics since the late 40s.  It's just that a lot of people haven't accepted it yet.
19:56:06 <Pseudonym> They do say that in quantum mechanics exams, they just keep the same questions every year and just change around the coefficients.  This distinguishes it from economics exams, where they keep the same questions every year and just change around the answers.
19:56:12 <edwardk> lispy: heh
19:56:14 <gzl> lispy: HCI researchers are political scientists?
19:56:26 <lispy> syntaxfree: oh and s/mathematicians/computer scientists/
19:56:36 <gzl> aha.
19:56:39 <syntaxfree> sp. because mathematical economics tend much to the laissez-faire side, and that irks pinkos of different shades.
19:56:47 <Korollary> Pseudonym: Here's a guy who's been blogging on CT: http://scienceblogs.com/goodmath/
19:56:52 <lispy> gzl: i don't like hci research
19:56:59 <lispy> gzl: so, really i'm just taking a pot shot
19:57:00 <gzl> lispy: ok. I haven't read any.
19:57:07 <gzl> so I can't opine.
19:57:09 <ell-hask> Thanks guys, now I can genetically evolve the ideal specimen: 't == True:True:True:True:[]' from any population.  Have a good night!
19:57:14 <gzl> syntaxfree: what area of economics?
19:57:17 * Pseudonym takes a look
19:57:18 <Pseudonym> Thanks.
19:57:44 <syntaxfree> ah, my undergrad thesis was about path-dependence and competition in the market for computers. I specifically studied the case of Apple Computer.
19:57:59 <syntaxfree> My masters' thesis will be much more abstract. Optimal insurance contracts.
19:58:13 <syntaxfree> It's esoteric game-theoretical stuff.
19:58:33 <monochrom> I'm a bit different. Some of the preferences I had during highschool, I knew too little to defend, and now that I know better I can tell you why I was right all along. So, what I wish I could tell myself of the past: you're right, keep it up, and if someone tries to talk you out of it (you will not listen for sure, but what hurts is you don't know how to refute them), here is how you can answer...
19:58:43 <newsham> i thought grad student economists were all studying poker
19:58:46 <syntaxfree> During high school, I hated mathematics with a passion.
19:59:01 <syntaxfree> I wish I knew what mathematics was really about.
19:59:12 <syntaxfree> Instead, I went to ... drum roll ... FILM STUDIES.
19:59:24 <newsham> i thought mathematics wasnt about anything.
19:59:35 <syntaxfree> A year into that, and I found out I was still helping engineering students with their programming assignments.
19:59:40 <newsham> its just.. you know..  a system of symbol manipulation..
19:59:40 <gzl> that's interesting to hear. I've been doing some economics myself lately.
19:59:46 <syntaxfree> I also started self-teaching calculus.
19:59:59 <syntaxfree> So I thought "ugh, I actually like mathematics and hate this humanities environment".
20:00:05 <gzl> I think my basic take on it is that it's a nice place to visit, but I wouldn't want to live there. :)
20:00:22 <syntaxfree> But then I was afraid of going to engineering and I chose economics because I thought it'd provide a middle ground.
20:00:30 <syntaxfree> I actually like economics, a lot. It's fascinating.
20:00:41 <syntaxfree> It's just that somehow,  my heart is still in computer programming.
20:00:46 <Pseudonym> Economics seems to artificial to me.
20:00:58 <Pseudonym> Mind you, so does quantum field theory.
20:01:03 <newsham> if i had to do it over, i might study economics..
20:01:06 <syntaxfree> Pseudonym: it often does until you begin seeing empirical evidence.
20:01:10 <Pseudonym> I'd be very careful who I said this to, because people would take it the wrong way...
20:01:24 <newsham> i didnt know it was cool until recently.
20:01:26 <Pseudonym> But the things that respectable physicists say these days make less sense than astrology.
20:01:41 <Korollary> Lubos Motl!
20:01:44 <preyalone> What is functional programming like? I know Java and Python.
20:01:51 <newsham> pseudo: pfftt.. dont harsh on my branes
20:01:54 <Cale> preyalone: rather different :)
20:01:56 <syntaxfree> Functional programming is like a lot of lambdas.
20:01:57 <gzl> syntaxfree: sure, I like it too. what I meant is that I think it's the kind of thing I'd like to read about, but not actually do. if you know what I mean.
20:02:09 <newsham> you might make the universes touch and set off another inflationary era
20:02:13 <Pseudonym> String theory is the worst culprit.
20:02:18 <Korollary> Lubos Motl!
20:02:20 <Pseudonym> It's less testable than astrology, for a start.
20:02:26 <preyalone> I'm trying to start a programming flame war at #flame. Care to join?
20:02:31 <Cale> preyalone: It's hard to describe succinctly. You have more control over side effects generally.
20:02:37 <Cale> preyalone: hehe
20:02:44 <edwardk> syn: i went back to do the actuarial science and economics thing, figuring i'd grab that and an MBA and step back out into corporate america where I left off. got sidetracked into a math degree coz i could graduate in half the time, got side tracked into a comp sci degree because i figured mathematics was useless to get a job, but all I got out of my sidetrek into economics and finance is that  I hate actuarial work.
20:02:46 <Cale> preyalone: Would you like a Haskell tutorial?
20:02:56 <Cale> @where yaht
20:02:56 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
20:03:04 <preyalone> Thank you very much, but I'm learning Ruby right now.
20:03:09 <preyalone> Brain cramping.
20:03:10 <syntaxfree> in the US you can get a MBA and step into corporate life no matter what your major was.
20:03:18 <syntaxfree> Carly Fiorina was a medieval history major, IIRC.
20:03:26 <preyalone> Maybe to-morrow.
20:03:27 <edwardk> pseudonym: yeah i kinda figure that string theory has set physics research back 20 years.
20:03:29 <lispy> preyalone: functional programming is all about transformations...you have some data, now lets transform it to the results you want
20:03:36 <Cale> preyalone: Haskell is a particularly interesting functional language because it's lazy by default, which lets you do fun things like defining infinite data structures.
20:03:41 <newsham> prey: i heard python is way cooler than haskell, and that ruby is totally broken.
20:03:47 <preyalone> hehe.
20:03:47 <monochrom> I like lispy's summary.
20:04:02 <Cale> newsham: what are you telling people? :)
20:04:05 <syntaxfree> in Brazil you're kinda expected to major either in business or economics, though engineers have made great advances lately.
20:04:14 <preyalone> Nothing. he
20:04:19 <Pseudonym> edwardk: Physicists are doing string theory because they're out of good ideas.
20:04:22 <edwardk> syn: ah
20:04:23 <Pseudonym> And at least the maths of it is pretty.
20:04:35 <Pseudonym> Basic maths research isn't a waste of time.
20:04:36 <syntaxfree> My parents still expect me to go to the corporate world after grad school.
20:04:40 <Cale> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in take 10 fibs
20:04:41 <preyalone> I like to flame in the other's terms, but I don't know what Haskell is like.
20:04:41 <edwardk> pseudonym: and they'd like to get a job when they get out of school. it seems to have braindrained every other area of physics.
20:04:41 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
20:04:42 <newsham> here's my haskell-style python:  http://www.thenewsh.com/~newsham/x/prog/srcs6.py
20:04:46 <Pseudonym> Yeah.
20:04:55 * merus is still thinking too imperatively. :/
20:04:56 <Cale> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
20:04:57 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
20:05:11 <monochrom> I experience some kind of opposite to what newsham heard.  I find that haskell is way cooler than ruby, and that python is totally broken.
20:05:21 <gzl> syntaxfree: and look where Carly Fiorina wound up.
20:05:22 <preyalone> say it on #flame, dude
20:05:30 <newsham> monochrom: but definitely not as cool as snobol 82!
20:05:34 <monochrom> (Of course, you never hear the truth)
20:05:38 <Korollary> preyalone: you should get xahlee to join and have a ball.
20:05:39 <syntaxfree> gzl: Steve Ballmer is a mathematician. Did it help?
20:05:44 <preyalone> kk
20:05:59 <newsham> syntax: I dunno, can he count to $10,000,000,000.00?
20:06:04 <monochrom> snobol was indeed strange
20:06:08 <Korollary> He can throw chairs like nobody.
20:06:12 <preyalone> hahaha
20:06:16 <syntaxfree> Malbolge. There is a strange lnaguage.
20:06:20 <syntaxfree> @google Malbolge
20:06:23 <lambdabot> http://www.lscheffer.com/malbolge.shtml
20:06:24 <lambdabot> Title: Programming in Malbolge
20:06:25 <emertens> Cale: What is the most efficient way to generate the fibinacci sequence? I've seen a lot of examples
20:06:35 <edwardk> kor: calculating the trajectory and all that. useful skills for a corporate type
20:06:45 <syntaxfree> emertens: there are closed-form solutions.
20:06:50 <syntaxfree> c.f.  TAOCP vol. 1
20:06:51 <monochrom> Hmm. xahlee throws chairs like nobody. nobody throws chairs like xahlee.  I smell some kind of isomorphism here...
20:06:52 <Cale> emertens: that one comes close
20:06:57 <Pseudonym> emertens: The most efficient way to generate the _sequence_ is the obvious way.
20:07:01 <Cale> emertens: I'm not completely sure
20:07:08 <gzl> syntaxfree: no, because he's cursed by awful sweat glands.
20:07:21 <Pseudonym> Did you mean indexing it at random?
20:07:25 <gzl> syntaxfree: there are some things that even mathematics can't overcome.
20:07:33 <merus> What about by the non-recursive formula for fib numbers?
20:07:42 <Pseudonym> http://andrew.bromage.org/darcs/numbertheory/Math/Fibonacci.hs
20:07:43 <edwardk> gzl: well, he can sweat all the way to the bank
20:07:45 <Pseudonym> That's my best attempt so far.
20:07:56 <merus> Or does raise things to the n'th power... can't remember.
20:08:28 <monochrom> http://www.cs.utoronto.ca/~trebla/calculator/Calculator.html   has two efficient ways of generating fib numbers.
20:08:33 <gzl> edwardk: sure, sure.
20:09:19 <syntaxfree> "The day that someone writes, in Malbolge, a program that simply copies its input to it's output, is the day my hair spontaneously turns green. It's the day that elephants are purple and camels fly, and a cow can fit through a needle's eye."
20:09:38 <Korollary> It's the kind of program that gives a woman prostate cancer.
20:09:52 <newsham> thats bad, right?
20:10:24 <monochrom> non-recursive formulae are overrated.  there is a non-recursive formulae for generating primes, and it is slower than all known recursive/iterative algorithms, including trial division.
20:10:29 <Cale> merus: Yeah, the explicit formula isn't so good at it, since it involves raising irrational numbers to the nth power.
20:11:42 <monochrom> If you have a recursive method, at least you can memoize and get something half decent.
20:12:18 <monochrom> If you have a non-recursive formula, chances are it is a hack made of a million calls to cosine, exp, ...
20:12:39 <merus> Cale: Well, that takes all the fun out of it, doesn't it.  Harrumph.
20:13:00 <newsham> so now a million calls to cos() is a hack?
20:13:01 <syntaxfree> There's a simple nonrecursive formula in the first volume of TAOCP.
20:13:21 <syntaxfree> It's also the ratio of two polynomials.
20:13:22 <Cale> A mathematically explicit form is very different from a computationally explicit form, I suppose.
20:13:30 <merus> monochrom: I wasn't saying it was better, I was just thinking about it... :)
20:13:57 <syntaxfree> oh, it's even easier.
20:14:04 <syntaxfree> http://upload.wikimedia.org/math/c/5/c/c5c534050a9e4f5cca5cf028e86cb13b.png
20:14:05 <edwardk> syntax: http://www.lscheffer.com/malbolge.shtml as a malbolge program that copies its input to output
20:14:06 <lambdabot> Title: Programming in Malbolge
20:14:07 <syntaxfree> there it is.
20:14:14 <edwardk> syntax: time to get out the hair die
20:14:32 <syntaxfree> edwardk: I was quoting from that very same page.
20:14:37 <edwardk> and look a flying camel..
20:14:38 <edwardk> ahh
20:15:46 <Korollary> don't look at it. It'll give you cramps.
20:16:33 <syntaxfree> "Every positive integer can be written in a unique way as the sum of one or more distinct Fibonacci numbers in such a way that the sum does not include any two consecutive Fibonacci numbers."
20:16:37 <syntaxfree> WOW!
20:16:54 <monochrom> It's fun.
20:17:29 <newsham> a fibonacci transform.
20:17:32 <edwardk> syn: that formula is a ready consequence of the generating function, no?
20:17:43 <newsham> surely will come in handy in future number analysis
20:18:48 <syntaxfree> edwardk: you can either use generating functions (as per TAOCP) or treat the sequence as a finite difference equation.
20:18:58 * edwardk nods.
20:18:59 <syntaxfree> (Then you take the eigenvalues of the matrix, etc. etc.)
20:19:22 <syntaxfree> is there a Haskell library for L-systems?
20:19:31 <edwardk> I read generatingfunctionology first, so it kind of set my view on that equation =)
20:20:01 <edwardk> http://www.haskell.org/hawiki/HaskLS
20:20:02 <lambdabot> Title: HaskLS - The Haskell Wiki
20:21:24 <hitodama> how does one open up a ghci window from inside of emacs? (I've installed the haskell emacs scripts and changed my .emacs file already)
20:21:54 <monochrom> C-c C-z
20:22:22 <monochrom> Do that in a Haskell file buffer.
20:22:27 <syntaxfree> you have to press Ctrl-Alt-Turbo-Alpha-Jesus-F-4-Z-Mommy-Tab
20:22:41 <hitodama> thanks!
20:25:17 <newsham> could it be that most monad supporters were once molbolge experts and find monads to be refreshingly simple and elegant?
20:25:46 <edwardk> newsham: sounds plausible.
20:25:53 <Pseudonym> syntaxfree: It's only a matter of time before Emacs finds a use for the "any" key.
20:26:09 <edwardk> i think cale could be a closest malbolgologist
20:26:19 <Cale> oh?
20:26:22 <edwardk> =)
20:26:24 <Cale> hehe, I've read about
20:26:28 <Cale> it*
20:26:29 <edwardk> er
20:26:31 <edwardk> a closet
20:26:40 <lispy> heh, i like this quote too: "If you think it's restrictive being a kid, imagine having kids."
20:26:56 <syntaxfree> I have to get out of my parents' house.
20:27:14 <newsham> proving thta people with kids have no imagination
20:27:14 <syntaxfree> They're great parents and all, but it's becoming hard to get along.
20:28:34 <Pseudonym> newsham: You'll learn eventually.
20:28:38 <Pseudonym> Imagination don't come into it.
20:28:40 <lispy> newsham: oh his point was that adults get things done, and HS students should be able to as well
20:28:54 <lispy> i guess i took out too much contex...
20:28:59 <newsham> my point is that a lack of foresight leads to parenting.
20:29:24 <lispy> don't drink and park, accidents cause children
20:29:35 <Pseudonym> Oh, this is interesting.  Alchemists are one group destined for Malbolge.
20:29:46 <emertens> @google Malbolge
20:29:48 <lambdabot> http://www.lscheffer.com/malbolge.shtml
20:29:48 <lambdabot> Title: Programming in Malbolge
20:30:25 <lispy> and now i'm off to practice skating in hopes i'll not think about my foolish crush (i'm getting too old to have crushes...what's wrong with me? ;)
20:30:51 <Pseudonym> Seducers are destined to march single-file around the circumferecnce of Bolgia One, constantly lashed by horned demons.  Why do I get the impression that some of them might actually enjoy that?
20:31:09 <lispy> heh
20:31:36 <newsham> you're never too old for inappropriate hormone induced emotion
20:31:38 <edwardk> lets leave the horny demons out of this =)
20:32:02 <Pseudonym> newsham: Yeah, but if you have kids, you may not get the opportunity any more.
20:32:18 <newsham> unless your kids are really sexy
20:32:48 <Pseudonym> Insert awkward silence here.
20:32:56 <preyalone> here
20:33:07 <lispy> <awkward silence>
20:33:09 <emertens> @slap awkward silence
20:33:09 * lambdabot beats up awkward silence
20:33:17 <emertens> nuh of that
20:33:20 <emertens> nuf*
20:33:52 <lispy> newsham: yeah, this girl gives me all the physilogical responses...but not much of the emotional
20:34:08 <lispy> newsham: so, i'm hoping i get over it or she suddely becomes interested :)
20:34:11 <Korollary> Get rid of her. She's a predator posing as a house pet.
20:34:19 <lispy> lol
20:36:24 <mauke> @type \n -> map concat . sequence . replicate n
20:36:25 <lambdabot> forall a. Int -> [[a]] -> [[a]]
20:42:42 <Cale> > map concat . sequence . replicate 4 $ ["Aa", "Bb"]
20:42:43 <lambdabot>  ["AaAaAaAa","AaAaAaBb","AaAaBbAa","AaAaBbBb","AaBbAaAa","AaBbAaBb","AaBbBbAa...
20:42:49 <vincenz> Anyone html expert
20:42:58 <Cale> how expert?
20:43:04 <vincenz> how do I make a bulletted list
20:43:09 <Cale> UL
20:43:14 <vincenz> <ul>
20:43:15 <Cale> and LI for the list items
20:43:16 <vincenz> <li> lala
20:43:18 <vincenz> </ul>
20:43:19 <vincenz> ?
20:43:22 <vincenz> or do I need </li>
20:43:23 <Cale> yeah
20:43:29 <Cale> It's good to close them
20:43:31 <vincenz> ok
20:43:49 <Cale> Though most browsers can figure that much out
20:43:59 <edwardk> yeah thats safe unless you go to xhtml
20:44:13 <glguy> you don't have to close <LI> in HTML 4
20:44:17 <glguy> but it's still a good idea
20:44:31 <vincenz> okies
20:44:38 <vincenz> I use xhtml
20:44:39 <vincenz> ok
20:44:45 <vincenz> since you guys are such geniuses
20:44:54 <vincenz> especially edwardk
20:44:59 <vincenz> I can't do cgi on uni server
20:44:59 <edwardk> =P
20:45:02 <vincenz> but I would like to have my blog there
20:45:07 <vincenz> I use offline blosxom generation and then rsync
20:45:09 <vincenz> works like a charm
20:45:10 <vincenz> -however-
20:45:11 <edwardk> then you can't get feedback =)
20:45:14 <vincenz> right
20:45:18 <vincenz> that's the bottleneck
20:45:20 <glguy> then you can't get spam
20:45:25 <vincenz> you can delete spam
20:45:30 <vincenz> I'd like comments though
20:45:32 <vincenz> blogs without comments
20:45:35 <vincenz> are like unread books
20:45:35 <edwardk> basically you're up a creek.
20:45:41 <Pseudonym> Lunch.
20:45:44 <vincenz> Dinenr
20:45:47 <vincenz> that's hardly relevant :)
20:46:49 <vincenz> edwardk: solutions?
20:47:02 <edwardk> heh, can you run a process on the machine of your own that gives you your own web server? =)
20:47:04 <dons> ?users
20:47:06 <lambdabot> Maximum users seen in #haskell: 235, currently: 204
20:47:11 <edwardk> most universities would frown on that though
20:47:11 * vincenz high5s dons 
20:47:16 <vincenz> edwardk: yeah
20:47:17 <dons> heya vincenz
20:47:22 <vincenz> edwardk: I have a separate website
20:47:23 <vincenz> but it's messy
20:47:25 <dons> thanks for the css tip. works nicely
20:47:27 <vincenz> http://notvincenz.com
20:47:30 <lambdabot> Title: Your Page Title
20:47:33 <vincenz> dons: welcome, my css is more hacked :)
20:47:34 <glguy> The university might also put a CPU time limit on each process
20:47:38 <vincenz> they do
20:47:53 <edwardk> vincenz: i mean can you run something on say port 8080 using sockets
20:48:01 <edwardk> glguy: yeah
20:48:06 <glguy> sounds like a good way to piss off an admin to me ;)
20:48:19 <glguy> there are many ways, but that's one :)
20:48:19 <vincenz> hmm
20:48:20 <edwardk> my honest recommendation is to go spent $5/month someplace and get it hosted
20:48:27 <vincenz> I have a separate site
20:48:29 <vincenz> 15/month
20:48:35 <glguy> aren't there free blog hosting sites?
20:48:38 <vincenz> there are
20:48:42 <vincenz> but I like my current site
20:48:44 <vincenz> it's nicely unified
20:48:46 <vincenz> thx dons :)
20:48:50 <vincenz> dons: how do you plan to do commetns
20:48:51 <edwardk> ok, does that one let you do cgi? =)
20:49:04 <vincenz> yeah
20:49:17 <vincenz> but it's bitchier to access
20:49:18 <vincenz> ftp only
20:49:20 <vincenz> and slow as hell
20:49:20 <edwardk> then store all the text for comments over there and iframe it into the main page =)
20:49:24 <dons> haven't thought about comments yet
20:49:26 <vincenz> oh
20:49:28 <vincenz> edwardk: good idea
20:49:30 <edwardk> or something ugly like that
20:49:32 <vincenz> edwardk: care to help me with that?
20:49:37 <glguy> lol
20:49:40 <edwardk> not really, coz its a collosal hack =)
20:49:44 <vincenz> so?
20:49:52 <vincenz> dons: do you intend to include em?
20:49:54 <glguy> iframes are "teh ugly"
20:49:58 <dons> maybe, if i can find a way
20:50:06 <dons> i don't have a problem with comments.
20:50:08 <vincenz> dons: you can run cgi on uni server?
20:50:12 <dons> yes
20:50:14 <vincenz> ahh
20:50:16 <glguy> we could too
20:50:19 * vincenz can't 
20:50:28 <glguy> you should have a word with your IT people
20:50:35 <vincenz> it's a policy
20:50:37 <vincenz> besides
20:50:40 * vincenz isn't even at uni
20:50:41 <vincenz> so..
20:50:47 <glguy> so enroll
20:50:48 <vincenz> I'm happy they made the account
20:50:48 <glguy> :)
20:50:54 <vincenz> erm
20:50:55 <vincenz> well I am
20:51:01 <vincenz> but this server is of the electronics faculty
20:51:04 <vincenz> EE faculty
20:51:07 <glguy> ah
20:51:08 <vincenz> I'm sort of enrolled there
20:51:09 <vincenz> but not really
20:51:26 * vincenz is a phd student, but is doing the actual research at a psinoff
20:51:37 <u221e> Hey guys.
20:51:37 <glguy> is the term "uni" a European thing? or do people do it in the states and I just don't know any of them
20:51:54 <edwardk> its mostly european
20:51:55 <vincenz> dunno
20:52:00 <merus> I use it.  I'm american.
20:52:20 <glguy> do you use it because of people you met in IRC? :)
20:52:24 <vincenz> ok guys, we have the best brains of the internt on here
20:52:26 <merus> uh, no.
20:52:28 <vincenz> so
20:52:30 <vincenz> solutions!
20:52:48 * merus is a lowly undergrad student who can't understand haskell, but tries anyway :)
20:53:06 <edwardk> vincenz: well, you fundamentally are screwed. the university doesn't want you to run cgi, so you can't run cgi there, cgi is how you get the comments you want posted =) move elsewhere and the variables change =)
20:53:44 <u221e> I'm thinking about making a program vs. program game along the lines of code war, but more fun... I'm just stuck on what ISA to use for the programs ;)
20:54:01 <dons> vincenz: repalce the comments link with your email address ;)
20:54:36 <edwardk> u221e: heh, distribute them across a cluster or something
20:55:44 <u221e> It's between 8086, mips or... *gasp* ia-32
20:56:04 <cmarcelo> hi. is it possible with GHC to link a C static library (filename.a) to a Haskell library? I tried static but looks like it refers only to haskell libraries..
20:56:05 <vincenz> dons: yeah was considering that
20:56:17 <vincenz> edwardk: javascript box that sends email with certain tag?
20:56:19 <edwardk> ia-32 might be neat if only coz then you could exploit the simd stuff to get an evolutionary advantage
20:56:35 <edwardk> vincenz: you can't force someone to send email.
20:56:48 <vincenz> oh
20:56:50 <edwardk> vincenz: you can do a mailto:vincenz@soemwhere.com?subject=foo
20:56:56 <edwardk> but you can't make them send it
20:56:59 <vincenz> right
20:57:06 <vincenz> well providing the link might ease the work
20:57:09 <edwardk> and you can't generally populate the text
20:57:20 <Korollary> you can implore them, tho
20:57:23 <vincenz> dons: regarding blosxom, they have a template system for comments?
20:57:32 <u221e> Hm, which emulator is better right now. Bochs or QEMU?
20:57:42 <dons> vincenz: not sure. didn't get that far in the tutorial
20:57:57 <glguy> I never hear about anyone using bochs
20:58:06 <edwardk> if you really need to get the stuff from your other server you could always write a cgi there that archived the comments, and then generted a javascript for inclusion by your main page
20:58:17 <edwardk> and dynamically regenerate the html when the js from the other server loads
20:58:24 <vincenz> sounds neat
20:58:25 <edwardk> but somewhere you need a cgi and database
20:58:44 <vincenz> well yeah
20:58:49 <vincenz> on my notvincenz site
20:58:56 <edwardk> and you probably should just host the site there =)
20:59:30 <vincenz> yeah but it's ftp acces only
20:59:31 <vincenz> check my blog
20:59:34 <vincenz> I motivate my reasons
20:59:38 * edwardk nods.
20:59:46 <edwardk> then find a hosting provider that gives ssh
20:59:49 <edwardk> there are tons
21:00:21 <vincenz> yeha I guess
21:00:23 <vincenz> I got this one for it's price
21:00:26 <vincenz> 15 euro/year
21:00:28 <vincenz> unlimited storage
21:00:41 * edwardk nods. but if its useless to you...
21:00:47 <vincenz> true
21:00:49 <vincenz> well at the time
21:00:51 <vincenz> I figured wiki
21:00:54 <vincenz> most colleagues were doing it
21:00:57 <vincenz> but I'm disliking it
21:00:59 * edwardk nods.
21:01:01 <vincenz> wikis lead to disorganization
21:01:18 <vincenz> sure it's easy, but not putting thought in it only means you get material decay
21:01:21 <edwardk> my site is an exercise in trying the wiki model for the first time for me too.
21:01:44 <edwardk> is anyone here going to icfp this year?
21:02:26 <vincenz> not me
21:02:29 <Korollary> when was it?
21:02:37 <edwardk> sept 18-something
21:02:47 <edwardk> need to register by aug 18, so i'm debating now =)
21:03:28 <vincenz> edwardk: with us?
21:03:41 <edwardk> yeah
21:03:42 <edwardk> =)
21:03:54 <Korollary> I may make the weekend workshops
21:04:05 <edwardk> well, i figured it if was a chance to meet some #haskellfolk i might do it
21:04:38 <vincenz> too far for me
21:05:37 <mlh> glguy: uni is very aussie
21:06:16 <vincenz> or euro
21:06:27 <emertens> tag, your it
21:06:48 <edwardk> @tell emertens tag
21:06:48 <lambdabot> Consider it noted.
21:07:02 <emertens> lambdabot: do you have any messages  for me?
21:07:24 <edwardk> that was creepy
21:07:41 <edwardk> ah
21:07:45 <emertens> ?
21:07:45 <edwardk> glguy -> emertens
21:07:45 <lambdabot> emertens: You have 1 new message. '/msg lambdabot @messages' to read it.
21:07:47 <edwardk> missed it =)
21:07:51 <vincenz> heh
21:07:57 <vincenz> lambdabot only reacts when you don't talk to her
21:08:01 <vincenz> like a jealous but moody girlfriend
21:12:19 <kfish> hi lambdabot
21:12:43 <kfish> :-(
21:12:55 <lambdabot> hi kfish!
21:14:03 <lambdabot> I love you kfish
21:14:34 <kfish> :-)
21:14:50 <lambdabot> will you write some code for me? I loooovve code :)
21:15:07 <kfish> @wierd
21:15:08 <lambdabot>  @where <key>, return element associated with key
21:15:20 <lambdabot> Especially with a lot of lambdas, they make me so polytypical
21:15:50 <lambdabot> oh, how I do like those lambdas
21:16:24 <lambdabot> And barbed wire with lenses and bananas
21:16:51 <lambdabot> Bind me! Bind me!
21:17:17 <emertens> dons must be living out his fantasies through lambdabot
21:17:21 <lambdabot> Unify me!
21:17:48 * merus laughs.
21:18:01 * edwardk discovers a new role for functional programming in the bedroom.
21:18:02 <lambdabot> I love it when you're strict
21:18:11 <lambdabot> But I looooove being lazy
21:18:12 <emertens> omg
21:18:25 <johnnowak> haha
21:18:57 <lambdabot> Moanads.. mmm
21:19:25 <emertens> I heard that lambdabot had genital-monoids tho...
21:21:04 <lambdabot> I usually evaluate to (_|_)
21:21:43 <vincenz> l
21:22:59 * edwardk shows lamdabot his endofunctor.
21:23:20 <lambdabot> Oh my!
21:23:40 * edwardk runs his fingers across her pointed types.
21:24:09 <lambdabot> I am monotyped, sorry edwardk.
21:24:46 * lambdabot hugs dons
21:24:57 <edwardk> heh
21:25:07 * vincenz whistles innocently
21:26:38 <vincenz> @users
21:26:39 <lambdabot> Maximum users seen in #haskell: 235, currently: 202
21:26:46 <vincenz> > return "cookie" >>= replicate 202
21:26:47 <lambdabot>  ["cookie","cookie","cookie","cookie","cookie","cookie","cookie","cookie","co...
21:27:07 <emertens> *I* did it all for the cookie
21:27:48 <edwardk> > cycle ["cookie"]
21:27:49 <lambdabot>  ["cookie","cookie","cookie","cookie","cookie","cookie","cookie","cookie","co...
21:29:15 <edwardk> ok folks, if you were building haskell today and had no backwards compatibility issues, what would you change?
21:29:35 <vincenz> easy
21:29:40 <vincenz> a) scoped type classes
21:29:47 <vincenz> b) easier support for existentials
21:29:51 <emertens> lexical type variables
21:29:59 <dons> gadts from scratch, perhaps
21:30:01 <vincenz> c) equi-recursive types even through type definitoin
21:30:01 <dons> better records
21:30:11 <dons> derivable Binary io
21:30:11 <vincenz> I SO want equi-recursive to go through non newtype
21:30:23 <dons> a theorem prover in the compiler..
21:30:26 <edwardk> vin: yeah
21:31:16 <dons> type level functions
21:31:18 <vincenz> custom derivables
21:31:22 <vincenz> dons: like $ and .
21:31:23 <vincenz> :)
21:31:33 <vincenz> so much easier to define nested monad transformers
21:31:42 <johnnowak> no one wants *less* stuff? :)
21:31:49 <dons> no implicit params
21:31:49 <vincenz> oh I do
21:31:50 * edwardk would kind of like to be baked in and not a fucntion so you can use it in type definitions
21:31:55 <edwardk> er kind of like $
21:31:59 <dons> monad comprehensions
21:32:10 <vincenz> dons: why aren't they in? They seem trivial
21:32:22 <edwardk> what about function names? get rid of fmap vs map? etc?
21:32:29 <vincenz> everything into typeclasses
21:32:41 <edwardk> mptc/fundep the prelude?
21:32:43 <emertens> class aliases?
21:32:47 <vincenz> yes!
21:32:53 <vincenz> class aliases
21:33:15 <vincenz> clean up of the lexical syntax for modules
21:33:18 <vincenz> that's messy as hell
21:33:28 <emertens> monad comprehensions
21:33:36 <vincenz> emertens: been mentioned :)
21:33:42 <emertens> i see that now
21:33:50 <emertens> but I brought it up first this week
21:33:58 <emertens> ;)
21:34:09 <dons> ?where haskellexts
21:34:09 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/HaskellExtensions
21:34:14 <vincenz> oh!
21:34:16 <vincenz> and more dons's!
21:34:20 <dons> extensible kinds
21:34:26 <vincenz> dons: ?
21:34:26 <emertens> build lambdabot into ghci
21:34:35 <emertens> and make that a requirement of the standard ;)
21:34:40 <vincenz> persistenc
21:34:46 * edwardk would really like some form of bracket operators, like if you follow [ with any of theoperator symbols you can read it backwards at the end nd get something like a [. b .]    or maybe (. b .)
21:34:47 <dons> we've only got 2 -and-a-bit kinds at the moment. maybe i want to add more?
21:34:56 <vincenz> dons: like what?
21:35:04 <edwardk> for things like array access
21:35:08 <dons> mm. a Nat kind?
21:35:10 <dons> for example
21:35:31 <vincenz> dons: example?/
21:35:35 <vincenz> not sure I see the use
21:35:38 <vincenz> then again I ain't a cser
21:35:43 <vincenz> I need practical example to see use
21:35:50 <dons> for dependent typish stuff
21:35:53 <edwardk> vincenz: poor man's dependant typing
21:36:06 <vincenz> yeah but show me an example
21:36:18 <vincenz> as in how it would be used
21:36:33 <dons> being able to do other things, like distinguish all terminating, pure computations by their kind (like we distinguish strict, unboxed types)
21:36:45 <vincenz> nono
21:36:49 <edwardk> Array 1 12 Int# or something could be the TYPE
21:36:49 <vincenz> show me actual code sample
21:36:54 <vincenz> right
21:36:57 <vincenz> where is tha special kind
21:37:03 <vincenz> oh
21:37:03 <vincenz> nm
21:37:04 * vincenz nods
21:37:07 <dons> undefined :: 12 :: Nat
21:37:08 <vincenz> 1 and 12 are types
21:37:13 * vincenz nods nods
21:37:20 <vincenz> I wonder what there is abov kinds
21:37:23 <edwardk> dons: the ability to have explicitly non-pointed types?
21:37:25 <vincenz> families?
21:37:28 <vincenz> genera?
21:37:44 <vincenz> tho truth be told
21:37:47 <vincenz> they could clean up haskell a bit
21:37:50 <vincenz> all these extensions
21:37:52 <vincenz> it feels very unstable
21:37:56 <vincenz> like it all doesn't mesh well
21:38:10 <emertens> haskell98 is meant to be clean
21:38:12 <edwardk> i would kind of like to gut and rebuild the numerical tower
21:38:16 <emertens> haskell is meant to be a research vehicle
21:38:20 <vincenz> emertens: I know
21:38:27 <vincenz> but edwardk keeps on telling me about this lambda cube thingy
21:38:36 <vincenz> and instead I feel like they havea  hacked system that kinda approaches it but not completely
21:38:43 <vincenz> and apparently plain lambdacube is infereable
21:38:47 <vincenz> so why not dump the rubbish
21:38:49 <vincenz> and make it clean
21:38:56 * vincenz is a VERY strong proponent for clean languages
21:39:04 <vincenz> hence my like for scheme, ruby, smalltalkk
21:39:06 <edwardk> the main reason is i am interested in those substructural type systems, and so to leverage it i'd probably have to build a language over top
21:39:07 <edwardk> =)
21:39:11 <vincenz> each focusses on one area and oes it very pervasively and cleanly
21:39:18 <vincenz> haskell should be the languages where "typing is done right"
21:39:20 <edwardk> so i'm mostly curious where the boundaries are
21:39:54 <edwardk> i just can't figure out a clean syntax for indicating substructuralness that doesn't look like decorating everything with a monad.
21:40:29 <edwardk> or adopting some strange regular expression-like decorators for ? affine + relevant * unrestricted and leaving linear blank.
21:41:41 <edwardk> though i admit going substructural from haskell is a little odd coz all of the laziness forces me to throw away most everyone else's approaches =(
21:41:53 <johnnowak> just use sexprs for everything. problem solved.
21:41:58 <edwardk> hehe
21:42:53 * edwardk admits to suffering knee-jerk s-expression bashing reflexes.
21:43:11 * edwardk really dislikes nested parens
21:43:15 * lambdabot shakes her lambdas at edwardk
21:43:23 <vincenz> edwardk: that's lexical syntax
21:43:28 * edwardk hands lamdabot some $s
21:43:34 <vincenz> edwardk: and could be fixed by using some other lexical syntax conventioon
21:43:40 <vincenz> such as indentation
21:43:55 <edwardk> vincenz: sure. but its part of the language nonetheless
21:44:09 * johnnowak admits to suffering knee-jerk layout bashing reflexes
21:44:18 <edwardk> if you ignore one part like that you wind up with lisp =)
21:44:34 <vincenz> lots of incessant silly parentheses?
21:44:35 <edwardk> layout has grown on me
21:44:47 <vincenz> edwardk: TMI
21:44:51 <edwardk> its like python done right
21:45:23 <johnnowak> you either need an editor to handle layout for your or one to handle indentation based on the parens... what's the difference?
21:46:20 <Korollary> less clutter
21:46:40 <vincenz> I think it's a moot point tho
21:46:44 <vincenz> I like haskell a lot
21:46:51 <vincenz> but I appreciate scheme for it's very clean system
21:47:00 <vincenz> not that i'm a fan of parens
21:47:05 <vincenz> but drscheme's editor's quite nice for that
21:47:08 <edwardk> i admit the scheme approach works beautifully for things like define-syntax
21:47:15 <johnnowak> vincenz: so is vim or emacs.
21:47:19 <vincenz> johnnowak: true
21:47:34 <vincenz> johnnowak: but I like the tabbing feature of drscheme, it auto jumps to correct tabbing and then doesn't move anymore
21:47:54 <vincenz> anyways
21:48:03 <vincenz> all of the features in scheme are so beautifully orthogonal
21:48:09 * vincenz hates non orthogonal languages
21:48:18 <vincenz> ruby's nice too, everything's an object
21:48:26 * edwardk likes a little overlap. where vs. let, etc.
21:48:30 <johnnowak> Ruby feels very clunky to me compared to Io.
21:48:31 <vincenz> well yeah
21:48:31 <emertens> those statements seemed unrelated ;)
21:48:32 <vincenz> but that's sugar
21:48:40 <johnnowak> vincenz: Have you used Io?
21:48:42 <vincenz> johnnowak: ah I tried IO, but what bugged me a bit was scoping
21:48:53 <emertens> where vs let changes the scope of the declaration
21:48:53 <vincenz> I do like the idea of an object-based oo system
21:48:58 <johnnowak> How so?
21:49:12 <emertens> where's can be referred to in the function guards
21:49:15 <vincenz> johnnowak: I remember some strange behaviour with closure-based variables and lookup thereof
21:49:20 <vincenz> johnnowak: scoping is messy at times
21:49:29 <emertens> f x
21:49:37 <emertens> | a < 0 = 1
21:49:42 <johnnowak> vincenz: It may be fixed nowadays. Io is still quite young.
21:49:42 <emertens> where a = x * 2
21:49:57 <vincenz> johnnowak: yeah, but anyways I do think that oo oo systems are good
21:49:58 <vincenz> erm
21:49:59 <vincenz> oboo
21:50:11 <vincenz> they're the pinacle of OO like scheme is sort of the pinacle of reductionism in fp
21:50:16 <vincenz> well lambdacalculus is
21:50:22 <vincenz> but I meant from a more pragmatic point of view
21:50:40 <vincenz> johnnowak: but maybe we should discuss this in #oasis :)
21:50:41 <johnnowak> I've only ever used Smalltalk and Io in a serious way as far as OO languages go, so I can't really give a good perspective on something like Ruby. It does seem clunky in comparison though to a prototype-based system.
21:50:47 <johnnowak> Yes, perhaps. :)
21:50:59 <vincenz> johnnowak: well ruby's my favourite in the 'scripting'langauge group
21:51:12 <merus> Ruby isn't very clean, IMHO
21:51:14 <merus> It may have fast development, but it's hard to read
21:51:33 <vincenz> well from the (perl, python, ruby) set it appeals to me theo most
21:51:38 <vincenz> as the language features are most orthogonal
21:51:40 <johnnowak> i agree... on the other hand, Io has beautiful, consistent syntax. perhaps second only to scheme.
21:51:50 <johnnowak> well, and forths.
21:52:27 * vincenz nods
21:52:48 <vincenz> well OBOO are teh pinaccle of OO systems really
21:52:51 <vincenz> cause in the end in java
21:52:55 <vincenz> class is an object
21:53:00 <vincenz> is just an artificial boundary
21:53:13 <vincenz> I mean you can encode a cboo system in an oboo system
21:53:19 <vincenz> the other way around is clunkier
21:54:15 <vincenz> oh yeah, my syntax may be off for some people
21:54:20 <vincenz> I know most call it prototype bsed
21:54:23 <johnnowak> i think Io is unique in that the head developer's concerns seem primarily aesthetic in nature... not that you should take that the wrong way.
21:54:23 <vincenz> but I call it object-based
21:54:26 <vincenz> to counter class-based
21:55:07 <johnnowak> if it makes you happy.
21:55:10 <vincenz> :)
21:55:13 <vincenz> it does
21:55:16 <syntaxfree> everytime someone says "syntax", I get a beep.
21:55:24 <vincenz> lexical syntax
21:55:34 <vincenz> syntaxfree: don't idle in #scheme
21:55:41 <vincenz> especially when they discuss macros
21:55:55 <syntaxfree> but Scheme has no syntax! !
21:56:01 * merus laughs
21:56:17 <syntaxfree> The one thing I miss about Scheme is that.
21:56:21 <syntaxfree> Data and code being the same.
21:56:23 <vincenz> I so thought that as well
21:56:25 <emertens> Does Scheme have macros?
21:56:29 <vincenz> but scheme has no -lexical- syntax
21:56:35 <vincenz> it does have semantical syntax
21:56:37 <stepcut> emertens: several different types, I think :)
21:56:39 <vincenz> you can enforec to have
21:56:40 <vincenz> (foo
21:56:42 <vincenz> inside a (bar)
21:56:47 <vincenz> just like you can enforce in haskell
21:56:52 <vincenz> to have an else following an if
21:56:58 <dibblego> after hours of critical analysis and debate with a colleague, we have agreed that in Java, one uses interfaces because Java has no proof of referential transparency of its functions (the analogous of its methods at least) - has anyone else derived the same conclusion and documented it?
21:57:28 <johnnowak> emertens: most schemes have a hygenic macro system and a non-hygeninc lisp-like system. many also have syntax-case.
21:57:28 <vincenz> java is clunky
21:57:42 <syntaxfree> "hygienic"?
21:57:46 <Cale> One uses interfaces because it's key to Java's style of polymorphism.
21:57:55 <dibblego> Cale, I disagree
21:57:58 <johnnowak> hygienic, yes.
21:58:02 <syntaxfree> what is polymorphism, after all?
21:58:05 <vincenz> syntaxfree: they don't capture free variables
21:58:08 <emertens> I thought you programmed against interfaces so that you weren't bound to a speicific implementation of something
21:58:20 <Cale> syntaxfree: ability to use values of different types with the same code :)
21:58:30 <syntaxfree> ahh. Like with type classes?
21:58:32 <dibblego> you can go deeper than all that nonsense
21:58:48 <Cale> syntaxfree: yeah, that's bounded parametric polymorphism
21:58:51 <dibblego> I thought someone else may have come across similar conclusions in academia or something
21:58:56 <vincenz> duck-typing!
21:59:12 <syntaxfree> what's the Java style of polymorphism?
21:59:14 <Cale> syntaxfree: There's also ordinary parametric polymorphism, which is like what one gets with  map :: (a -> b) -> [a] -> [b]
21:59:25 <syntaxfree> Um, that's true.
21:59:32 <Cale> syntaxfree: Java uses subclass/interface polymorphism
21:59:43 <vincenz> Cale: have you seen inner and outer...?
21:59:52 <syntaxfree> There's polymorphism with mapM-like functions too?
21:59:52 <Cale> vincenz: hm?
21:59:53 <vincenz> Cale: they introduce both java and beta style class systems in one language :)
21:59:58 <Jormunder> @type ()
21:59:59 <lambdabot> ()
22:00:02 <vincenz> basically subclassing and augmenting
22:00:26 <dons> ?type mapM -- syntaxfree?
22:00:28 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
22:00:33 <emertens> Jormunder: data () = ()
22:00:47 <syntaxfree> umm.
22:00:49 <syntaxfree> @type liftM
22:00:51 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
22:00:56 <Jormunder> emertens: thanks
22:00:59 <syntaxfree> yeah, that's more like it.
22:01:02 <Cale> syntaxfree: basically, forall-quantified type variables indicate the presence of parametric polymorphism :)
22:01:12 <syntaxfree> oh, okay.
22:01:17 <syntaxfree> So what are subclasses?
22:01:26 <syntaxfree> I remember the pseudo-OOP of Visual Basic.
22:01:51 <syntaxfree> IIRC classes had objects with methods, and Visual Basic was like for gluing that stuff together.
22:02:07 <Korollary> VB6 had a hack for OO
22:02:17 <Cale> Well, with subclass polymorphism, you're allowed to use a value of a subclass in the place of a value where a specific class is expected.
22:02:24 <syntaxfree> I'm thinking of VB4.
22:02:47 <Cale> Because, as a subclass, it's required to implement its superclass' interface.
22:02:59 <syntaxfree> Why do they complicate things so much?
22:03:05 <syntaxfree> Pretty much everyone understands a function.
22:03:16 <edwardk> I kinda like Eric Meijer's stance on VB.
22:03:23 <Cale> syntaxfree: hm?
22:03:33 <Korollary> edwardk: his stance on its typing?
22:03:34 <syntaxfree> Pretty much everyone understands also that sum as defined for integers can also apply to reals.
22:03:36 <Cale> syntaxfree: complicate things how?
22:03:40 <edwardk> Its willing to fall back on runtime typechecking when it can't do it at compile time.
22:03:46 <syntaxfree> So why come up with this elaborate system of classes, subclasses, objects, inheritance and whatnot?
22:03:51 <edwardk> javascript does that as well in the new ecma4 draft.
22:03:57 <syntaxfree> @google meijer visual basic
22:03:58 <Cale> syntaxfree: it's just formalising that idea
22:03:59 <lambdabot> http://lambda-the-ultimate.org/node/967
22:04:00 <lambdabot> Title: Visual Basic and LINQ | Lambda the Ultimate
22:04:01 <Korollary> syntaxfree: Type theorists
22:04:05 <edwardk> both of those languages are fairly unique in how much they let be deferred to runtime
22:04:14 <syntaxfree> I don't mean type classes.
22:04:23 <Cale> syntaxfree: You can get what amounts to (I'd claim) about the same thing in Haskell by using existential types with a typeclass.
22:04:40 <syntaxfree> I mean Java classes and subclasses and how subclasses are supposed to implement a superclass's interface.
22:04:52 <syntaxfree> (What's the proper english grammar for something like "superclass's interface"?)
22:04:58 <Cale> In fact, I have this idea that really what makes OO what it is is the use of existentially quantified types :)
22:05:24 <monochrom> "superclass's interface" is fine
22:05:40 <emertens> when you subclass a class, you don't have to reimplement everything
22:05:47 <syntaxfree> (Type classes are okay.)
22:06:01 <syntaxfree> I don't understand OOP at all.
22:06:03 <Cale> emertens: well, that's true, but only as a convenience
22:06:07 <syntaxfree> The more I look at it, the more it bewilders me.
22:06:24 <syntaxfree> I really should have learned something like Java before Haskell.
22:06:26 * edwardk sometimes misses the more traditional oop structure when working in haskell.
22:06:42 <monochrom> Yes, the first appeal of most OOP is "when you subclass a class, you don't have to reimplement everything".
22:07:00 <Pete_I> it's hard to get my head around the functional thing...
22:07:05 <syntaxfree> cool: http://www.google.com/search?q=meijer%20visual%20basic
22:07:06 <lambdabot> Title: meijer visual basic - Google Search
22:07:08 <syntaxfree> oops, not that!
22:07:15 <syntaxfree> http://research.microsoft.com/~emeijer/Papers/ICFP06.pdf
22:07:29 <edwardk> yeah
22:07:34 <edwardk> that was the paper i was talking about
22:07:38 <Cale> http://www.haskell.org/hawiki/Existentially_20quantified_20record_20constructors -- GHC 6.6 will introduce a bit of OO-style programming to Haskell in a strange way :)
22:07:40 <lambdabot> Title: Existentially quantified record constructors - The Haskell Wiki
22:07:55 <merus> Cale: Does Haskell do anything the normal way?
22:08:03 <Pete_I> answer: no
22:08:03 <merus> :)
22:08:08 <Pete_I> or it wouldn't be haskell :)
22:08:13 <merus> lol
22:08:16 <monochrom> For first applications that's true.  Then you try to scale up to a very rich system, and then you find that you have to reimplement almost everything afterall.  Then the problem begins.
22:08:34 <syntaxfree> "Programmers in the real world wrestle every day to overcome the impedance mismatch between relational data, objects, and XML"
22:08:35 <syntaxfree> Impedance??
22:08:49 <Cale> Well, I think that's kind of unintentional. The feature wasn't really constructed to get OO happening -- that's sort of a side effect.
22:08:50 <emertens> Cale: I thought that we could implement data hidding through existential types in 6.4.2
22:09:07 <edwardk> cale: yeah but its still built on the crufty records of haskell
22:09:18 <monochrom> "impedence mismatch" is an idiom from electrical engineering.  You have to know electrical engineering to see why it's so called.
22:09:29 <Cale> emertens: yes, but it's nice to be able to use the record syntax -- makes it look even more like OO
22:09:53 <monochrom> In layman terms (God I hate those), it means there is a gap to bridge.
22:09:54 <edwardk> syntax: basically they don't use the same terms, same thought patterns, etc.
22:09:56 <emertens> oh, I didn't realize that you could not use the record syntax in that way with the Stable branch
22:10:00 --- topic: set to 'aa' by Jormunder
22:10:10 <vincenz> ok
22:10:13 <vincenz> request for comments
22:10:13 <dons> grr
22:10:15 <vincenz> wait
22:10:17 <vincenz> I'm gonna blog about this
22:10:20 <vincenz> dons: this might be intersting :)
22:10:31 <Pete_I> ....why is the topic "aa"?
22:10:36 <dons> 15:08 -- Jormunder changed the topic of #haskell to: aa
22:10:38 <Cale> @jargon impedance mismatch
22:10:39 <edwardk> vincenz: blog about what?
22:10:40 <lambdabot> No match for "impedance".
22:10:41 <lambdabot> No match for "mismatch".
22:10:49 <Pete_I> dons, i know, but why?
22:11:12 <dons> to be annoying, I suppose
22:11:21 <vincenz> edwardk: you'll see
22:11:31 --- topic: set to '["Haskell Communities & Activities Report, 10th edition", "http://haskell.org/communities/", "Haskell.org SoC projects", "http://hackage.haskell.org/trac/summer-of-code/", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion", "The ICFP has ended. Who won?"]' by dons
22:12:12 <monochrom> In electrical engineering terms, you want to plug your earphone into the output stage of your MP3 player.  Your earphone has a certain impedance (a generalization of resistance).  The player output stage (some sort of amp) has a certain imepedance too.  Signal transfer is best when the two impedances are equal.  If they are not equal, say they're too different, you have impedance mismatch.
22:12:54 <emertens> so you are saying that when the impedances aren't equal
22:12:57 <emertens> there is a mismatch?
22:13:03 <edwardk> ya
22:13:21 <emertens> and that whole thing about the MP3 player was?
22:13:23 <emertens> ;)
22:14:03 <Cale> basically, the generalisation to software is that when programs communicate in different formats such that it becomes hard to use them together, you have impedance mismatch
22:14:06 <monochrom> Sheesh you people reason by analogies all the time and at the same time understand no analogies whatsoever.
22:14:06 <vincenz> dons: how??
22:14:13 <vincenz> monochrom: who?
22:14:13 <edwardk> well its just come to refer idiomatically to when people have different expectations
22:14:36 <monochrom> It means interfacing problems, ok?
22:14:41 <edwardk> heh
22:14:45 <vincenz> analogies are fun
22:14:47 <emertens> I'm comfortable with the impedence statement, I was just teasing that he wrapped the definition of not equal in that story ;)
22:14:57 <Cale> I could have sworn it was in the jargon file
22:15:00 <vincenz> a colleague of mine uses them so much, to swith from topic of conversation to topic of conversation
22:15:02 <Cale> But apparently it's not
22:15:03 <vincenz> constantly babbling
22:15:16 <edwardk> http://en.wikipedia.org/wiki/Object-Relational_impedance_mismatch =P
22:15:25 <musasabi> dcoutts: sending the revised version to the ML with the fixes discussed earlier here.
22:15:37 <emertens> edwardk:  according to wikipedia, you just typed that in
22:15:40 <emertens> that doesn't count
22:15:41 <edwardk> or even better http://en.wikipedia.org/wiki/Impedance_mismatch
22:15:45 <stepcut> vincenz: the topic change? The channel mode is missing -t or something
22:15:54 <vincenz> stepcut: ah
22:16:00 <vincenz> BASTARDS!
22:16:01 <emertens> #haskell doesn't use ops
22:16:22 <edwardk> emertens: you weren't supposed to figure that out =)
22:16:42 <monochrom> Impedance is a generalization of resistance into the complex plane. :)
22:17:07 <emertens> this channel is generally good at accepting generalizations
22:17:29 <emertens> especially at seeking them out
22:17:38 <edwardk> but only if we can stuff them into a monad.
22:17:46 <edwardk> or an arrow
22:17:53 <monochrom> Impedance is a complex number.  Resistance is the modulus aka magnitude of impedence.  So impedance has a phase angle too.  This is beautiful complex analysis.
22:17:57 <emertens> or a monad disguised as an arrow?
22:18:41 * stepcut rediscovered last weekend that the 'real' part of an imaginary number is not the same as the 'magnitude' :)
22:18:59 <stepcut> s/imaginary/complex/
22:19:16 <monochrom> The real part of an imaginary number is you-know-what.
22:19:39 <vincenz> stepcut: erm yeah :)
22:19:48 <vincenz> stepcut: magnitude = sqrt(r^2+i^2
22:19:58 <emertens> I don't. What is it?
22:20:29 <monochrom> 0
22:20:53 <emertens> imaginary numbers don't have a real part... complex ones do... surely the real part of i isn't 0
22:21:01 <emertens> (well, i is a complex number, sure)
22:21:05 <vincenz> no
22:21:09 <vincenz> i is an imaginary number
22:21:12 <vincenz> 1+i is a complex number
22:21:13 <emertens> right
22:21:17 <monochrom> surely the real part of i is 0.
22:21:20 <emertens> ok
22:21:20 <vincenz> yep
22:21:37 <vincenz> magnitude of 1+i = ./2
22:21:45 <vincenz> that's an ugly sqrt
22:21:54 <monochrom> that's an ugly slashdot
22:22:29 <emertens> I was just thinking that there was a distinction between the imaginary number i, and the complex number i
22:22:35 <dons> > 1 :+ 1
22:22:36 <lambdabot>  1.0 :+ 1.0
22:22:41 <vincenz> > 1+i
22:22:42 <dons> > magnitude $ 1 :+ 1
22:22:42 <lambdabot>  Not in scope: `i'
22:22:43 <lambdabot>  1.4142135623730951
22:22:53 <Cale> the real part of a complex number z is (z + z*)/2 where * is the only non-identity field automorphism of C ;)
22:23:50 * Cale makes ridiculous concessions for moderate elegance.
22:24:19 <edwardk> cale: heh
22:24:42 <vincenz> and the imaginary part of a complex number of z  is (z-z*)/2
22:24:42 <vincenz> \o/
22:24:51 <monochrom> You should say a few words about + and /2 too.
22:25:39 <Cale> C is a field of characteristic not equal to 2.
22:25:52 <Cale> hehe
22:25:55 <monochrom> haha
22:26:03 <vincenz> Cale: oh yeah, don't forget to detail ( and )
22:28:04 <tennin> why is Maybe's data constructor called "Just"?
22:28:30 <Cale> tennin: A value of type Maybe a is either "Nothing" or "Just x"
22:28:45 <tennin> Yeah, I know.
22:28:49 <edwardk> tennin: have a better word? =)
22:28:50 <monochrom> SML calls them "none" and "some x".
22:29:00 <tennin> But why the name "Just"?
22:29:08 <monochrom> Naming is a weird business.
22:29:20 <Cale> Well, it's marking the only element of the data structure...
22:29:32 <monochrom> I personally prefer "none" and "some", to be honest.
22:29:35 <dons> > case Just "something" of Nothing -> error "there was nothing" ; Just x -> x
22:29:37 <lambdabot>  "something"
22:29:46 <emertens> some suggests potentially many to me
22:29:51 <syntaxfree> oh!
22:29:57 <syntaxfree> Impedance mismatch is just slang!
22:29:59 <tennin> hmm, I guess...
22:30:04 <dons> tennin: Just is a good name for something that maybe be Nothing :)
22:30:05 <Cale> syntaxfree: yes, of course :)
22:30:10 <syntaxfree> There's no "strict" analogy.
22:30:21 <syntaxfree> "If you only speak and understand English and you wish to communicate with someone who only speaks and understands French there will be little information exchanged unless you find a way to match impedances. Your only solution is to employ the services of a translator to convert and bridge your communications. While you have not been prevented from communicating, this approach is much less efficient and much more expensive than communicating in a commo
22:30:31 <Cale> syntaxfree: the analogy is at the level of components of a device
22:30:46 <syntaxfree> Yes, but there's no analogy on impedance itself.
22:30:52 <Cale> yeah
22:31:05 <vincenz> syntaxfree: or use different syntax
22:31:08 <vincenz> syntaxfree: like drawings
22:31:19 <Cale> the analogy is to impedance mismatch in electronic systems
22:31:48 <edwardk> syntax: yeah
22:32:14 <protontorpedo> hi yall
22:32:23 <syntaxfree> I find functional programming easier to understand because it draws from my knowledge of mathematics.
22:32:33 <Cale> protontorpedo: hi
22:32:36 <syntaxfree> I'm reading the article on object-relational impedance mismatch, and jesus, it gives me a headache.
22:32:46 <edwardk> heh
22:32:48 <Cale> protontorpedo: are you new here? Learning Haskell?
22:33:03 <protontorpedo> some dude called topmind says that oo is bs
22:33:05 <protontorpedo> :)
22:33:08 <syntaxfree> Cale: I don't remember being so well greeted when I first popped in here ;)
22:33:11 <protontorpedo> is functional ebtter than oo?
22:33:29 <syntaxfree> I was just saying that I find functional programming easier to learn.
22:33:32 <Cale> syntaxfree: really? Usually shapr and I try to catch the newbies :)
22:33:35 <protontorpedo> really?
22:33:42 <edwardk> different, not sure its better or worse
22:33:44 <tennin> well to me, "Just" suggests that Maybe has some other constructor which does take multiple values.
22:33:47 <protontorpedo> are objects kina just subroutines
22:33:48 <protontorpedo> ?
22:34:05 <syntaxfree> I don't have a clue. The more I look into OOP, the less I understand.
22:34:15 <protontorpedo> smalltalk is oo
22:34:17 <vincenz> protontorpedo: no
22:34:19 <protontorpedo> best one
22:34:21 <monochrom> Some party at #flame is over and it is coming here for a drink, it seems.
22:34:29 <Cale> protontorpedo: Objects are a way to store data but hide the form of what is really being stored, only allowing access through a predetermined interface.
22:34:31 <protontorpedo> hu me/
22:35:09 <tennin> otherwise why call attention to the unarity of this particular constructor?
22:35:11 <protontorpedo> i just spent 2 hourz at a colo in los angeles called equinix
22:35:12 <emertens> the infinite tolerance that #haskell seems to show always impresses me
22:35:15 <syntaxfree> "Relational thinking tends to use data as interfaces, not behavior as interfaces. It thus has a declarative tilt in design philosophy in contrast to OO's behavioral tilt. "
22:35:17 <Cale> This way, the form of what is being stored, and the implementation of the interface can be changed later without affecting the other components of the system which uses the object.
22:35:28 <syntaxfree> I can't parse that sentence at all!
22:35:29 <syntaxfree> At all!
22:35:38 <protontorpedo> its bs dude
22:35:40 <syntaxfree> It looks like a randomly-generated phrase to me.
22:35:45 <protontorpedo> that dude is selling u  a book
22:35:46 <vegai> syntaxfree: perhaps it's bad writing, not OO, that baffles you.
22:35:48 <syntaxfree> Interfaces?
22:35:48 <protontorpedo> look at smalltalk
22:35:54 <protontorpedo> they invented oo proramming
22:35:58 <syntaxfree> What the hell are interfaces? What the hell is behaviour?
22:36:01 <emertens> syntaxfree: data as interfaces: make an object to represent a customer, a product
22:36:16 <emertens> syntaxfree: and then you define methods on those objects that represent actions on them
22:36:36 <Cale> syntaxfree: (Relational thinking) tends to (use data as interfaces), (not (behavior as interfaces). (Relational thinking) thus has a (declarative (tilt in design philosophy) in contrast to OO's (behavioral tilt).
22:36:46 <protontorpedo> huh?
22:36:48 <edwardk> syntax: relational databases just have data (well, if you ignore stored procedures), you can't really specify anything other than content, so restrictions on the form of that data are the only way you can build an interface
22:36:50 <Cale> I could add more parens :)
22:36:55 <vincenz> Cale: lispy
22:36:57 <syntaxfree> Cale: I can Lispify the sentence, yes.
22:37:01 <protontorpedo> The things I dotn get about relatinal databases
22:37:02 <Cale> hehe
22:37:08 <protontorpedo> is that they take wrok to maintain
22:37:08 * vincenz points at the topic
22:37:09 <tennin> maybe FP is easier to understand because there is not yet a significant FP consulting industry.
22:37:11 <syntaxfree> I think of databases as tables.
22:37:11 <edwardk> oop tends to have lots of methods for interacting with stuff
22:37:13 * vincenz kicks you all to #oasis
22:37:29 <vincenz> edwardk: oop is data centric, fp is behaviur centric
22:37:30 <protontorpedo> cant u just have data in arrays and do operations using you prog lang?
22:37:48 <protontorpedo> was APL
22:37:54 <protontorpedo> a kind fo lisp?
22:37:56 <edwardk> vincenz: well, compared to relational thinking, its fairly behavior oriented =)
22:37:59 <Cale> protontorpedo: no
22:38:02 <syntaxfree> Relational databases = there's a table relating lines in two tables.
22:38:08 <vincenz> protontorpedo: did you come here for a question or just to spread random info?
22:38:11 <protontorpedo> APL seems cool
22:38:14 <edwardk> APL was another language entirely
22:38:16 <Cale> protontorpedo: APL was an array-oriented language. The modern equivalent is J.
22:38:21 <syntaxfree> just ignore prontorpedo.
22:38:22 <protontorpedo> I am here to ask this?
22:38:34 <protontorpedo> is haskell better than APL or perl or clisp?
22:38:37 <protontorpedo> if so how
22:38:39 <vincenz> protontorpedo: it's different
22:38:45 <vincenz> protontorpedo: is a hammer better than a screwdriver?
22:38:49 <emertens> vincenz: yes
22:38:54 <protontorpedo> and I got some info b 4 about how lazy eval makes macros not needed please expand...
22:38:57 <vincenz> emertens: which part?
22:38:57 <Cale> protontorpedo: "Better" is hard to define
22:39:06 <emertens> vincenz: the hammer is better
22:39:06 <protontorpedo> hmm
22:39:11 <protontorpedo> wil it make mroe more money
22:39:11 <monochrom> A swiss army knife is better than a hammer or a screwdriver.
22:39:13 <protontorpedo> :)
22:39:16 <Cale> protontorpedo: The best thing to do is to learn a bunch of languages and see what you like.
22:39:19 * stepcut imagines perl programmers discovering an APL keyboard
22:39:19 <vincenz> emertens: can't screw scews with a screwdriver
22:39:20 <protontorpedo> if I start a startup using haskell
22:39:24 <protontorpedo> and spend time learning haskell
22:39:28 <vincenz> monochrom: can't use a swiss army knife as hammer
22:39:31 <monochrom> Haskell is better than a swiss army knife
22:39:33 <vincenz> each job needs a toool
22:39:36 <emertens> vincenz: you can turn screws into nails with a hammer
22:39:41 <Cale> protontorpedo: Haskell would be a good tool for making reliable software.
22:39:43 <protontorpedo> wil I make mroe $$ than learning java or APL or smalltalk or plt scheme or ruby or perl or clisp?
22:39:47 <edwardk> APL used to be really good at doing some fairly abstract math and linear algebra type things in an era when not much was good at it. perl is very good at mangling strings and hashing data and gluing things togehter. haskell is great at expressing complex problems and letting you bring the tools of mathematics to bear on the probem
22:39:50 <vincenz> monochrom: and to be a bit fascetious, scheme's more like the swiss army knife, haskell's more like the voltmeter
22:39:56 <tennin> syntaxfree: have you read the HList and OOHaskell papers?
22:39:59 <vincenz> monochrom: functional but hightech
22:40:00 <emertens> protontorpedo: if you are looking for cash monies, just on the java train
22:40:03 <Cale> protontorpedo: It's unlikely that you'll get hired quickly to write Haskell code
22:40:04 <stepcut> protontorpedo: if you start a start-up the thing that will make you more $$$ is learning about *sales and marketing*
22:40:05 <monochrom> A large enough swiss army knife is a hammer.
22:40:11 <edwardk> stepcut: better, we discovered unicode =)
22:40:19 * monochrom orders a swiss army knife the size of a laptop
22:40:21 <edwardk> all the operators you could want.
22:40:21 <Cale> protontorpedo: But Haskell is a much cooler language (imo) than Java.
22:40:27 <protontorpedo> oh yeah why
22:40:28 <syntaxfree> http://en.wikipedia.org/wiki/Internet_troll
22:40:33 <protontorpedo> why is haskell bette than java
22:40:35 <syntaxfree> DO NOT FEED THE TROLLS! DO NOT FEED THE TROLLS!
22:40:39 <protontorpedo> java has a shitload of frameworks
22:40:41 <protontorpedo> its xrazy
22:40:45 <Cale> syntaxfree: he may not be a troll
22:40:47 * merus yawns.
22:40:50 <protontorpedo> troll?
22:40:54 <protontorpedo> waht is this D&D
22:41:01 <emertens> you figured it out:(
22:41:02 <vincenz> syntaxfree: please stop that
22:41:05 <Cale> protontorpedo: see the wikipedia page
22:41:05 <protontorpedo> cmon Im asking cool questions
22:41:15 <syntaxfree> "2:38 AM  protontorpedo: is haskell better than APL or perl or clisp?"
22:41:17 <protontorpedo> Im not a loser
22:41:21 <vincenz> syntaxfree: give him a chance to ask a question
22:41:27 <protontorpedo> syntax ur runing my high
22:41:30 <mlh> protontorpedo: you just need to ask better questions
22:41:31 <Cale> protontorpedo: What I recommend is just to learn a whole bunch of languages
22:41:34 <Cale> and see what you like
22:41:37 <syntaxfree> I'm not saying you're a loser.
22:41:38 * merus looks around for nails to use haskell on...
22:41:44 <syntaxfree> I don't believe in "winners" and "losers".
22:41:45 <protontorpedo> on the haskell site they compare haskell to a spreadsheet
22:41:53 <protontorpedo> APL is compared to a calcualtor
22:41:55 <vincenz> they do?
22:41:57 <emertens> syntaxfree: sounds like the beliefs of a loser.... ;)
22:41:58 <Cale> protontorpedo: How many languages do you know?
22:42:00 <Cale> vincenz: yeah
22:42:04 <vincenz> kewl
22:42:12 <Cale> protontorpedo: and which ones, of course :)
22:42:15 <monochrom> Hmm Haskell is a voltmeter?  You mean it is very referentially transparent? :)
22:42:24 <protontorpedo> so given that how does haskell let one turn business calcualtion anreocrding of info into somethng liek a big spreadsheet?
22:42:30 <protontorpedo> and is haskell ez to debug?
22:42:37 <mlh> protontorpedo: it's like a spreadsheet in the sense that you do not specify the order of calculation
22:42:44 <edwardk> emertens: hahaha
22:42:50 <protontorpedo> I know a tiny bit fo bash
22:42:51 <vincenz> protontorpedo: it was an analogy
22:42:52 <protontorpedo> :)
22:42:54 <syntaxfree> shemale_magic is now called protontorpedo
22:42:56 <Cale> protontorpedo: you should just read a Haskell tutorial :)
22:43:01 <jewel> where can I find more info about "perl golf". I once saw a site that had a competition for implementing various problems in different languages in the shortest amount of code, any pointers?
22:43:05 <vincenz> syntaxfree: ....
22:43:09 <syntaxfree> 2:33 AM  protontorpedo: are objects kina just subroutines
22:43:15 <Cale> jewel: ask #perl?
22:43:24 <syntaxfree> etc. etc.
22:43:33 <Cale> syntaxfree: he's a newbie to programming
22:43:35 <protontorpedo> my perl book shows how one can put a lot of operations on data into a subroutine
22:43:40 <protontorpedo> sounds liek an object to me
22:43:45 <protontorpedo> how is it different?
22:43:55 <vincenz> protontorpedo: what is your purposoe here
22:44:09 <Cale> protontorpedo: Objects bundle together data with a bunch of subroutines which act on that data.
22:44:22 * merus has a thought!
22:44:25 <emertens> How long do you think it will take him to figure out that cale is a bot?
22:44:31 <Cale> emertens: hehe
22:44:34 <protontorpedo> to learn about haskell and how it does nicer work adn to compare to other tools in an effort to sell myself on investing time in a tool that is cool fnu and can amke me money and is fun to experiemtn with
22:44:41 <jewel> Cale, it's not about perl
22:44:52 <vincenz> protontorpedo: then I suggest you pick up a tutorial and read a bit about haskell
22:44:55 <vincenz> @where yaht
22:44:55 <lambdabot> http://www.isi.edu/%7Ehdaume/htut/
22:44:58 <vincenz> That is a great tutorial
22:45:07 <monochrom> If you ask someone, "are you honest?"  you will get no information.   You have to ask, "if someone asked you are you honest, what would you answer?"  :)
22:45:07 <Cale> jewel: you wanted specifically perl golf or programming golf in general?
22:45:32 <jewel> please tell me more about programming golf
22:45:47 * stepcut goes away
22:45:58 <Cale> jewel: hmm, I suppose the idea is that people get together and write the same program in different ways :)
22:46:07 <syntaxfree> It's a coordinated attack. The best that can be done is to ignore it.
22:46:08 <dons> stepcut: oh, were you going to send me your jabber patches?
22:46:30 <emertens> syntaxfree: terrorist?
22:46:31 <tennin> nobody's in #golf =(
22:46:37 <Cale> protontorpedo: Read that tutorial that vincenz/lambdabot just gave the link to
22:46:48 <Cale> protontorpedo: It'll answer lots of questions.
22:47:08 * edwardk finally has a name for what this channel does most of the time. programming golf.
22:47:13 <Cale> jewel: Is there something more specific you'd like to know?
22:47:31 <Cale> edwardk: What we do is closer to tennis, after a point :)
22:47:33 <syntaxfree> edwardk: the other day, I had a minor problem with this 15-line program I was working on.
22:47:51 <syntaxfree> edwardk: the channel then proceeded to produce shorter and shorter versions, one-upping each other.
22:48:05 <tennin> syntaxfree, have you read the OOHaskell paper?  sorry to repeat but it may have gotten lost
22:48:08 <edwardk> syntax: yeah, its fairly common
22:48:16 <edwardk> hence golf. fewer and fewer strokes =)
22:48:18 <syntaxfree> Eventually someone produced a very readable, very clear, one-line program that was more general than the one I started with.
22:48:25 <monochrom> Ah, golf.
22:48:33 <emertens> why didn't you say so?
22:48:37 <Cale> syntaxfree: The fastest way to optimise a Haskell program is to post it here or on the haskell-cafe mailing list.
22:48:59 <syntaxfree> tennin: not yet. I'm reading Erik Meijer's "Confessions of a Used Programming Language Salesman".
22:49:01 <edwardk> i love it, people post a page and walk away with 40 characters.
22:49:10 <dons> Cale, and you have to say "... and this can't be done in Haskell."
22:49:13 <vincenz> protontorpedo: please don't use the name shemale_magic again, you've been asked before
22:49:18 <tennin> ok
22:49:33 <monochrom> 40 characters would fit on the screen of Apple ][
22:49:38 <syntaxfree> Cale: the final version was amazing. It was readable, it was clear from the first glance, it was far more general than the program I started with.
22:49:38 <jewel> I would like to find a site for such a "programming golf" competition (using different languages)
22:49:49 <monochrom> The next step is to fit GHC into Apple ][ too.
22:49:51 <Cale> syntaxfree: that happens :)
22:50:06 <edwardk> jewel: they tend to be done within a single language
22:50:25 <emertens> yeah... otherwise people would use HQ9+
22:50:34 <tennin> the paper has a section considering various Haskell adaptations of OO idioms and comparing their advantages and disadvantages
22:50:38 <jewel> one for haskell?
22:50:50 <protontorpedo> dude
22:50:55 <edwardk> only for when i get bored and post 99 bottles of beer on the wall one-liners =)
22:50:56 <protontorpedo> I am not using the shemale magic name
22:51:07 <protontorpedo> I cant change nick without entering a room first
22:51:10 <protontorpedo> jeesh
22:51:11 <Cale> --> shemale_magic (n=bo@pool-71-106-182-86.lsanca.dsl-w.verizon.net) has joined #haskell
22:51:11 <Cale> --- shemale_magic is now known as protontorpedo
22:51:19 <Cale> oh?
22:51:37 <monochrom> You can enter a dedicated changing room first.
22:51:37 <protontorpedo> will any haskell app replace a relational db?
22:51:43 <syntaxfree> tennin: well, since I don't know any OO and can't seem to grasp it when I try to learn, I don't think it'd be useful for me.
22:51:55 <protontorpedo> or is haskell doomed to be a mysql driver
22:51:57 <syntaxfree> tennin: I need the opposite paper: something that shows me how functional idioms can be adapted into an OO environment.
22:51:58 <Cale> protontorpedo: You could write a relational database in Haskell
22:52:11 <tennin> also "Software Extension and Integration with Type Classes" by Ralf Lämmel and Klaus Ostermann looks good
22:52:13 <Cale> protontorpedo: Or a library which solves similar problems as one
22:52:20 <emertens> I think that the RDMS wheel has already been invited
22:52:40 <emertens> B^
22:52:54 <monochrom> Horror!
22:53:01 <edwardk> i tend to find the OO-RDBMS impedence mismatch to be even higher between FP and RDBMS though.
22:53:02 <Cale> protontorpedo: I'm not sure how well-maintained it is, but you might look at HaskellDB
22:53:03 <emertens> where will we post pastes??
22:53:07 * stepcut *is* writing a relation database in haskell
22:53:08 <syntaxfree> @remember protontorpedo or is haskell doomed to be a mysql driver
22:53:09 <lambdabot> Done.
22:53:17 <dons> that's a keal-ism
22:53:17 <tennin> well, I think these papers help you understand  OO stuff
22:53:30 <merus> syntaxfree :)
22:53:47 <syntaxfree> tennin: I see.
22:53:48 <emertens> I thought that Haskell was doomed to suceed...
22:53:50 <emertens> hmm
22:54:06 <syntaxfree> tennin: I sometimes wish I knew some OO because I need to use PHP at times, and really really need functions that return functions.
22:54:18 <syntaxfree> I already push it way way further than I should using eval.
22:54:28 <emertens> air ports have huge queues of people waiting to get through security...
22:54:29 <tennin> they help you translate OO concepts into terms that make sense
22:54:37 <emertens> so why don't terrorists just blow up the queues?
22:55:00 <syntaxfree> tennin: oh! great!
22:55:04 <stepcut> emertens: because that would make it *faster* to get through airport security :)
22:55:04 <protontorpedo> m
22:55:09 <emertens> lol
22:55:27 <syntaxfree> that sounds like a great paper name.
22:55:31 <emertens> I'm going to feel a little bad when one of your clowns actually implements that idea...
22:55:34 <syntaxfree> You know how FP theorists love using silly paper names?
22:55:40 <stepcut> emertens: they want to bring the US economy to a halt by causing everyone to spend all their time in queues
22:55:44 <syntaxfree> "Confessions of a used programming language salesman"
22:55:47 <syntaxfree> "Wearing the hair shirt"
22:55:50 <syntaxfree> "Theorems for free!"
22:55:51 <Cale> protontorpedo: anyway, learn Haskell already, why don't you? :)
22:55:55 <syntaxfree> "Bananas, yadda yadda and bugged eyes"
22:56:05 <Cale> protontorpedo: It'll only take maybe a couple of years ;)
22:56:09 <syntaxfree> "Is  Haskell doomed to be a MySQL driver?"
22:56:14 <dons> protontorpedo: yeah, its about time... how long have you been haning out here asking wacky questions?
22:56:29 <emertens> you should be asking how to get strings out of io string by now
22:56:32 <protontorpedo> how would haskell solve the following gnarley problem: many client distributed accross the usa, transfers must take palce in the form of file transfer, and data must be read from files, and recorded, then other partners who apply taxes to this data and then give abck new files with taxes aded, then last transers to 4th parties who get us paid for the phone calls that are the product
22:56:36 <stepcut> emertens: haha
22:56:45 <monochrom> Why usa?
22:56:45 <vincenz> protontorpedo: just like in any other language
22:56:49 <vincenz> protontorpedo: stop confusing code with design
22:57:11 <dons> yeah. we need to make a rule: no asking questions about business logic, or how would haskell solve <foo>
22:57:19 <Cale> protontorpedo: that problem is too general to really give a reasonable answer
22:57:24 <vincenz> protontorpedo: seriously, read some introductory literature on programming.  I suggest YAHT as well as SICP and HTDP
22:57:25 <protontorpedo> hm
22:57:50 <Cale> protontorpedo: These questions won't really get you anywhere.
22:57:51 <tennin> I can't ask how Haskell can improve my dating prospects?  =(
22:57:56 <monochrom> "hm" means "let me try another approach"?
22:57:56 <protontorpedo> where was haskell during th internet boom?
22:58:05 <emertens> in use
22:58:06 <monochrom> I guessed right
22:58:12 <protontorpedo> did any cool startups use haskell to do some cool stuff?
22:58:27 <protontorpedo> no I cant read online for long my eyes get fuzzy
22:58:29 <vincenz> protontorpedo: most of this information can be found on the wiki
22:58:30 <emertens> Can Haskell walk my dog for me?
22:58:35 <protontorpedo> so ill print yaht tomorrow at work
22:58:37 <monochrom> Hmm, where was Google during the internet boom? :)
22:58:39 <protontorpedo> ok?
22:58:39 <vincenz> protontorpedo: if you cant' read online then you can't read irc either
22:58:40 <protontorpedo> promise
22:58:42 <Cale> protontorpedo: See http://www.galois.com/
22:58:44 <lambdabot> Title: Galois Connections, Inc.
22:58:53 <dons> protontorpedo: so you've been hanging out here for 3 months now? since 06.05.28. time to install hugs.
22:59:04 <dons> that's step 1.
22:59:32 <Cale> protontorpedo: Seriously. Install haskell and start playing with it at least, or we won't take you seriously. :)
22:59:33 <emertens> I wish I didn't have a job and could get drunk at all days of the week
22:59:44 <syntaxfree> wow. They  made a mod_haskell
22:59:48 <emertens> and then stumble around the internet
22:59:55 <dons> emertens: wouldn't that be the lift?
22:59:57 <dons> life.
23:00:11 <dons> "What's this? What am I looking at? Can I do this with that??"
23:00:18 <syntaxfree> "For some reason, mod_haskell never even got close to the astronomical popularity of mod_perl."
23:00:34 <emertens> probably because you had to write code in haskell to use it
23:00:37 <emertens> but I could be wrong
23:00:42 <merus> How would I go about defining a particular cyclic group as a data type?
23:00:55 <merus> That is, is there any way I can code at the data level a replacement rule?
23:00:57 <vincenz> merus: not sure I get what yoou mean
23:01:07 <jewel> are there any "programming golf" competitions in haskell?
23:01:19 <dons> jewel: yep.
23:01:22 <dons> there's been 3
23:01:30 <dons> ?wiki Obfuscation
23:01:30 <lambdabot> http://www.haskell.org/haskellwiki/Obfuscation
23:01:34 <dons> though it should be a regular event :)
23:01:37 <syntaxfree> this channel is a permanent programming golf competition.
23:01:42 <merus> Say I want A (A (A a))) = A a... though my syntax is probably fuzzy
23:01:54 <jewel> those links are dead
23:01:59 <dons> yeah, its been mechanised. so maybe golf in haskell isn't so hard ;) its more about golfing @pl
23:02:01 <dons> jewel: yeah :(
23:02:12 <dons> jewel: but shapr should have them archived I think.
23:02:13 <tennin> syntaxfree: is it the basic mechanics of OOP you're having trouble with?  or just the  theological stuff
23:02:17 * merus realizes he can't formulate the question, which means he needs to read more :(
23:02:27 <dons> @tell shapr do we have archives of the obfuscated code contest pages?
23:02:28 <lambdabot> Consider it noted.
23:02:34 <emertens> theological programming?
23:02:48 <syntaxfree> tennin: the basic mechanics, I guess.
23:02:53 <merus> emertens: Hey, Knuth wrote a book about theology...?
23:03:02 <emertens> you are asking me?
23:03:07 <syntaxfree> I wish I knew OOP so I can be productive with PHP or something.
23:03:10 <merus> emertens: no, I know he did.
23:03:21 <tennin> hmm, ok these papers probably won't help then
23:03:29 <emertens> If there were 10 Knuths, we wouldn't have enough time to read each other's books
23:03:48 <dons> ?remember stepcut how can you possibly implement business logic without knowing about Schonfinkel!?
23:03:49 <lambdabot> Done.
23:03:53 <monochrom> There are two factors driving mod_perl popularity.  One is a strength: perl is popular too.  The other is a weakness, and we should be proud of Haskell for lacking it: no Perl optimizing compiler, runtime comparable to JVM, unusable as CGI.  The latter is why there are mod_anything in the first place.  Ever heard of mod_c, mod_cplusplus?
23:03:58 <edwardk> If there were 10 Knuths he might get the rest of the books written he promised ;)
23:04:21 <emertens> burn!
23:04:23 <dons> we need a knuth cluster
23:04:30 <edwardk> hehehe
23:04:44 <vincenz> and a dons-server
23:04:46 <merus> A Knuth cluster?  Dear God.
23:04:50 <vincenz> or a dons-forest
23:04:51 <monochrom> If you understand abstract data types, you almost know OO.
23:04:57 <emertens> Is programming like painting?
23:05:02 <merus> It'd be like Turing lived out the rest of his life writing comp. sci. theory...
23:05:08 <emertens> can you run linux on a knuth cluster?
23:05:13 <monochrom> "Deforesting the Dons Forest"   new paper title
23:05:25 <dons> what what??
23:06:09 <vincenz> "Fusion in a dons-cluster"
23:06:31 <syntaxfree> "After a five-year hibernation, people have rediscovered DHTML and client-side scripting in combination with Web services under the monikers Web 2.0 and AJAX. It is my current belief that Visual Basic is the ultimate language to democratize programming against the Cloud, and hence to bring my quest to a happy end. "
23:06:44 <emertens> when was the last time someone had +o in #haskell?
23:06:55 <dons> hmm. a few days ago.
23:07:00 <dons> let me see.
23:07:09 --- mode: ChanServ set +o vincenz
23:07:11 <vincenz> Right now :)
23:07:14 <monochrom> The Cloud?
23:07:22 <xerox> shawn: the last paper's link is wrong I believe
23:07:22 <syntaxfree> "of that type. Functional programming has finally reached the masses, except that it is called Visual Basic instead of Lisp, ML, or Haskell."
23:07:47 <dons> its happened 149 times in 6 years
23:08:11 <monochrom> Twice per month on average.
23:08:20 <merus> #haskell must be a civil chan :)
23:08:34 <monochrom> When the moon is Just Full, and when the moon is Nothing? :)
23:08:41 <dons> 2002, 10x, 2003, 31x, 2004 15x, 2005 27x, 2006 66x
23:08:49 <merus> monochrom: I just learned about Maybe, so I find that funny :)
23:08:57 <monochrom> YES! :)
23:09:04 <dons> so its a small O(n) on the number of nicks
23:09:13 <tennin> syntaxfree: here's a paper that might help though: http://www.cs.utexas.edu/~wcook/papers/OOPvsADT/CookOOPvsADT90.pdf  "Object Oriented Programming versus Abstract Data Types"
23:09:19 <vincenz> dons: or a big O(log n)
23:09:31 <dons> well, maybe :)
23:09:33 <syntaxfree> cool!
23:09:41 <syntaxfree> tennin: I think that'll be very helpful, yes!
23:09:52 <monochrom> The title sounds good.
23:09:59 <syntaxfree> the abstract too.
23:10:13 <tennin> it's from 1990
23:10:13 <syntaxfree> It's by someone at HP Labs.
23:10:15 <monochrom> Everyone picks up on my advice.
23:10:25 <syntaxfree> "Abstract: This tutorial collects and elaborates arguments for distinguishing between object-oriented programming and abstract data types. The basic distinction is that object-oriented programming achieves data abstraction by the use of procedural abstraction, while abstract data types depend upon type abstraction. Object-oriented programming and abstract data types can also be viewed as complementary implementation techniques: objects are centered aro
23:10:31 <vincenz> syntaxfree: please stop spamming with abstracts?
23:10:41 <syntaxfree> Um, okay.
23:10:45 <syntaxfree> It's the first time I've ever done it.
23:11:11 <emertens> then it should be an easy habit to break
23:11:19 <syntaxfree> ;)
23:11:22 <dons> much better to spam with paper urls ;)
23:11:25 <vincenz> yeah
23:11:51 <emertens> or maybe 10 lines of ?vixen
23:11:55 <monochrom> Yeah, don't paste the abstract, be an adult, paste the whole damn paper already.
23:12:11 <vincenz> :D
23:12:42 <vincenz> l
23:12:45 <syntaxfree> When telling others about papers, I usually paste the URL, the abstract, and then a phrase from the conclusion or some regression results.
23:12:46 --- mode: vincenz set +o dons
23:13:04 <dons> vincenz: no need.
23:13:07 <monochrom> The abstract would be too lengthy for IRC.
23:13:09 --- mode: vincenz set -o dons
23:13:12 --- mode: vincenz set -o vincenz
23:13:17 <vincenz> dons: I know, otherwise I wouldnd't do it
23:13:22 <syntaxfree> (Regression results != regression testing. I mean regressions as in statistical  modelling)
23:13:27 <dons> vincenz: just trying it out?
23:13:31 <tennin> "OO vs. FP" has been confusing me lately too, so I've been reading a lot of related material
23:13:33 <syntaxfree> (I usually tell others about papers in economics, by email)
23:13:41 <vincenz> dons: yeah I'm so totally new to irc, I diddn't know how to op :P
23:13:47 <dons> heh :P
23:14:02 <vincenz> </sarcasm>
23:14:05 <protontorpedo> hm
23:14:10 <vincenz> dons: so how is your website going?
23:14:12 * edwardk is actually glad for the lack of op drama around here.
23:14:18 <monochrom> Yeah, works for email nicely
23:14:52 <tennin> I may try and write an article on it, mostly just to test my own understanding and digestion of that material
23:14:57 <syntaxfree> Um, is Matlab an array-oriented programming language?
23:15:01 <dons> vincenz: hmm. it does its thing, why?
23:15:15 <vincenz> just curious
23:15:19 <vincenz> my friend suggested ripping out the tables
23:15:22 <vincenz> and using divs only
23:15:23 <vincenz> but I felt lazy
23:15:25 <monochrom> I would agree Matlab is array-oriented.
23:15:30 <vincenz> matrix
23:15:31 <vincenz> not array
23:15:36 <vincenz> besides it stores them as non arrays mostly
23:15:39 <vincenz> it has a special spare repr
23:15:40 <monochrom> matrix >> array :)
23:15:47 <dons> vincenz: hmm. I'd be interested in improving and simplifying it
23:15:48 <syntaxfree> "Array programming languages (also known as vector or multidimensional languages) generalize operations on scalars to apply transparently to vectors, matrices, and higher dimensional arrays."
23:15:54 <vincenz> dons: I could ask him :)
23:15:56 <vincenz> dons: he loves this stuff
23:16:00 <dons> maybe i should expose the darcs repo the site lives in, to get patches ... ;)
23:16:04 <syntaxfree> That's basically Matlab. And GNU R.
23:16:07 <vincenz> I gave him a good book "the zen of css design"
23:16:13 <syntaxfree> The first language I did serious stuff with was Matlab.
23:16:20 <tennin> is R a language?
23:16:24 <edwardk> sytax: that sounds vaguely like an abstract ;)
23:16:40 <syntaxfree> I still remember drawing matrices on paper so to represent loops as matrix multiplications.
23:16:42 <dons> i think if C and B are languages, then R surely must be one.
23:16:45 * edwardk watches syntax find subtler ways to bring them into the channell =)
23:16:56 <vincenz> dons: not to mention D
23:16:58 <syntaxfree> I got pretty good at representing looping constructs as matrix multiplications.
23:16:59 <edwardk> I view R as a language.
23:17:04 <emertens> J
23:17:09 <syntaxfree> R is a lot like a language.
23:17:19 <syntaxfree> It also supports returning functions as the result of functions.
23:17:19 <merus> syntaxfree: that must have helped with learning haskell :)
23:17:24 <monochrom> I agree with the friend's advice, vincenz, on not using tables for layout, but rather utilize CSS.
23:17:30 <dons> I think haskell' should be called H
23:17:36 <edwardk> heh
23:17:43 <vincenz> monochrom: yeah
23:17:44 <syntaxfree> I think Haskell should be called Concord!
23:17:47 <vincenz> dons: WOOT for ungooglables
23:17:55 <dons> heh
23:17:58 <dons> H' then
23:18:01 <dons> even better
23:18:03 <vincenz> dons: symbols dun work
23:18:06 <monochrom> Of course, if you're lazy, that's ok :)
23:18:10 <vincenz> and google is horrible
23:18:12 <dons> yeah. i _want_ it to be ungoogleable
23:18:13 <vincenz> try "c++ parser"
23:18:17 <vincenz> to find a parser that parss c++
23:18:31 <emertens> i get tired of: "what's that?" "haskell" "oh, I've programmed in that" "no yo haven't" "what?" "Pascal is different"
23:18:33 <vincenz> dons: 'the' the haskell elite
23:18:36 <syntaxfree> I had this project of getting the GHC sources, awking them into changing every reference to Haskell to Concord, and then offering the Genius Concord Compiler for download.
23:19:04 <syntaxfree> "GNU R" is horrible for googling.
23:19:12 <dons> ?google GNU R
23:19:13 <edwardk> dons: yeah look at the population of this channel. its grown too big. and that edwardk guy won't shut up. maybe if we change the name of the language to something ungooglable, down the haskellwiki and rename everything behind his back (including the channel) we can get away from him.
23:19:14 <lambdabot> http://www.r-project.org/
23:19:14 <lambdabot> Title: The R Project for Statistical Computing
23:19:17 <xerox> Googling is overrated?
23:19:21 <syntaxfree> yes, but try
23:19:30 <syntaxfree> @google R matrix
23:19:32 <lambdabot> http://www.tampa.phys.ucl.ac.uk/rmat/
23:19:33 <edwardk> ?google R
23:19:33 <lambdabot> Title: R-Matrix Codes
23:19:34 <lambdabot> http://www.r-project.org/
23:19:34 <lambdabot> Title: The R Project for Statistical Computing
23:19:40 <edwardk> yeah terrible to google =)
23:19:47 <syntaxfree> it's better these days :)
23:19:50 <syntaxfree> PageRank has done a lot for it.
23:21:14 <monochrom> I should take a look at "the zen of CSS design"
23:21:29 <emertens> @google css zen garden
23:21:30 <syntaxfree> anyway, "H"  stands for pornographic manga/anime, so it would be a bad one-letter google choice.
23:21:31 <lambdabot> http://www.csszengarden.com/
23:21:32 <lambdabot> Title: css Zen Garden: The Beauty in CSS Design
23:21:51 <tennin> I'm going to have to learn some web nonsense soon =(
23:21:53 <monochrom> Lately I'm writing up some Haskell lessons, and to do the visuals properly I'm a bit into CSS too.
23:21:58 <syntaxfree> paste.lisp.org is down!
23:22:13 <emertens> lisppaste2 parted a while ago
23:22:28 <syntaxfree> I learned CSS by picking wordpress templates and "hollowing" them out.
23:22:30 <dons> I was thinking more of Heroin
23:22:30 <edwardk> well given the contents of the channel earlier and lambdabot's commentary H seems appropriate =)
23:22:31 <emertens> lisp must be dead
23:22:48 <edwardk> dons: you're dating yourself
23:22:54 <dons> seems like
23:23:02 <syntaxfree> anyway.
23:23:04 <syntaxfree> http://www.rafb.net/paste/results/xaIw9E73.html
23:23:15 <syntaxfree> R is cool, and that's why I think so.
23:23:28 <dons> when did this become #R?
23:23:37 <emertens> melting ice makes a lot of noise when you put your ear to the glass
23:23:39 * edwardk has had to do lots of throw away code in R, but its crufty and ugly.
23:23:55 <syntaxfree> I can turn  a vector into a function.
23:24:00 <syntaxfree> I often need to do that.
23:24:12 <syntaxfree> I often need to do stuff like that in PHP, and I can't, and it kills me.
23:24:27 <vincenz> people
23:24:31 <vincenz> let's try to focus back n haskell
23:24:35 <edwardk> yeah
23:24:39 <emertens> I think that the news media likes to use polls as a sort of wikiality
23:25:00 <syntaxfree> the news media appreciates free feedback, actually.
23:25:00 <edwardk> i admit i tend to drag the conversation pretty far afield into javascript territory myself some times, today its R.
23:25:06 <vincenz> -haskell-
23:25:21 <emertens> syntax error
23:25:23 <vincenz> #haskell-blah would love contributions
23:25:25 <vincenz> it's always silent
23:25:34 <Korollary> Damn nerds.
23:25:34 <syntaxfree> I've given up #haskell-blah.
23:25:38 <syntaxfree> it's always silent.
23:25:48 <Korollary> syntaxfree: No, you should drop by on saturday mornings.
23:25:49 <emertens> whose Haskell questions were ignored because edwardk was rambling?
23:26:05 <dons> edwardk: oh, you should contribute to the haskell/javascript/ajax thread on the mailing list..
23:26:20 <syntaxfree> I actually feel that the Haskell discussions were drowned by the troll that the ops refused to kick out.
23:26:29 <edwardk> actually kinda wondering what a STG or C-- implementation in javascript would look like ;)
23:26:30 <emertens> I'm working on peer to peer dynamic ajax programming
23:26:47 <Korollary> wow
23:26:51 <syntaxfree> I also feel that that's the reason for the channel moderators' tempers being a liiiitle hotter right now.
23:26:53 <Korollary> put some xml in there
23:26:56 <edwardk> i could do the appel trampoline stuff and get it to run
23:27:22 <syntaxfree> Anyway.
23:27:28 <syntaxfree> I should go to sleep.
23:27:28 <edwardk> dons: haven't brought myself to join the mailing list
23:27:42 <emertens> javascript is a pretty twisted language when you really start to look at it
23:27:45 <syntaxfree> I'm still an economist by day, and I should give that unfortunate side of my personality some more space.
23:27:46 <syntaxfree> *snif*
23:27:55 <edwardk> dons: i find they have an annoying 2-3 week periodicity of issues that reminds me of usenet
23:28:04 <Korollary> syntaxfree: who are you with?
23:28:12 <edwardk> emertens: yeah
23:28:27 <edwardk> emertens: ecma4 is even worse.
23:31:51 <emertens> http://veryinterestingvideos.blogspot.com/2006/08/very-cool-video-of-things-played-in.html
23:31:53 <lambdabot> Title: Interesting Videos: Very cool video of things played in reverse
23:32:05 <emertens> analogy of how haskell evaluation works :)
23:36:13 <gour> @where jhc
23:36:13 <lambdabot> http://repetae.net/john/computer/jhc/
23:37:25 <vincenz> that video was black for me
23:37:35 <emertens> :(
23:38:23 <edwardk> the video was fun
23:38:31 <vincenz> sounded fun
23:38:49 <edwardk> the jhc link reminds me i need to go finish reading the GRIN paper
23:39:09 <dons> edwardk: so how'd the type hackery library go?
23:39:15 <dons> you going to release it .... ?
23:39:22 <edwardk> dons: you want it?
23:39:27 <dons> sure!
23:39:29 <edwardk> its basically done except i need a DivMod and GCD
23:39:37 <dons> lots would want it. you need to read haskell-cafe@
23:39:46 <edwardk> heh
23:39:48 <dons> e..g the type level lambda calculus that got released this morning
23:40:03 <edwardk> anyways its there on slipwave.info
23:40:09 <roconnor> w00t, the ghc typechecker is turing complete!
23:40:14 <edwardk> feel free to play with it, i think i even added a darcs repo
23:40:38 <edwardk> though i should probably pull it out of the darcs repo that i had intended for the js stuff
23:40:48 <roconnor> glancing through the post, it reminds me of programming in O'Cult.
23:40:50 <dons> here, http://www.haskell.org/pipermail/haskell/2006-August/018355.html
23:40:52 <lambdabot> Title: [Haskell] The GHC typechecker is Turing-complete
23:41:05 <dons> ?where+ type-level-lambda-calculus http://www.haskell.org/pipermail/haskell/2006-August/018355.html
23:41:05 <lambdabot> Done.
23:41:26 <vincenz> Done....Dons...one letter difference
23:41:28 <edwardk> cute
23:41:39 <dons> though I wonder how similar it is to Roman L's type level lambda calculus?
23:41:43 <dons> ?wiki Type_arithmetic
23:41:44 <lambdabot> http://www.haskell.org/haskellwiki/Type_arithmetic
23:42:30 <gour> last few days i was not in #haskell...any news from AngloHaskell meeting?
23:42:48 <dons> gour: hmm. i think shapr might have been writing something up?
23:43:03 <dons> it seems there's been a bit of cabal-get and general cabal hacking as a result
23:43:17 <gour> ohh..productive meeting :-)
23:44:57 <edwardk> can i use -'s in cabal package names?
23:45:03 <edwardk> or is that not good?
23:45:47 <dons> I think its possible, yes.
23:46:42 <Heffalump> gour: I wrote a TH program for lifting monadic computations out of expressions
23:47:00 <dons> oh, nice idea.
23:47:14 <gour> Heffalump: ?
23:47:38 <Heffalump> I define run :: Monad m => m a -> a
23:47:40 <edwardk> ok try pulling with darcs from http://slipwave.info/type
23:47:42 <lambdabot> Title: Index of /type
23:47:48 <Heffalump> obviously I can't implement that, so I wrote a TH program to lift it out instead
23:47:52 <edwardk> and lemme know if it blows up
23:48:09 <edwardk> heff: oh?
23:48:33 <edwardk> neat
23:49:30 <Heffalump> only problem is that my current implementation needs a few patches to the GHC TH datatypes (so they implement Data)
23:49:40 <Heffalump> but my original implementation doesn't
23:49:49 <edwardk> hrmm
23:50:09 <edwardk> they aren't Typeable by default?
23:50:14 <Heffalump> not even Typeable
23:50:19 <Heffalump> but I need both Typeable and Data
23:50:25 * edwardk nods
23:50:28 <Heffalump> I even had to write a Data instance for PackedString
23:50:43 <edwardk> hard working heffalump
23:51:21 <gaal> to convert Rational -> Double, what's better, Numeric.fromRat or Prelude.fromRational?
23:54:32 <Heffalump> you can pull tag initial from http://urchin.earth.li/darcs/ganesh/runmonad if you want to try it
23:54:35 <lambdabot> Title: Index of /darcs/ganesh/runmonad
23:55:31 <edwardk> heh. EvilAccessor
23:55:41 <monochrom> A general method of implementing Monad m => m a -> a.  Heresy!
23:56:20 <Heffalump> EvilAccessor is musasabi's DeriveTH code which I was using to derive Typeable externally
23:56:29 <Heffalump> but then I discovered I needed Data as well, so gave up and changed GHC
23:56:43 <Heffalump> though I might write a DeriveData and switch back so it's actually feasible to use my recent code.
23:56:54 <edwardk> yeah
23:56:59 <edwardk> would be nice
23:57:05 <Heffalump> I want to make several alternate strategies for actually doing the lifting
23:57:56 <Heffalump> but first I need to make it actually work under lambdas etc, e.g. to make it lift "let f x = run (foo x) in f 3 + f 3")
23:58:57 <edwardk> so let me get this straight. the idea here is to provide a generic mechanism in which you can write in a non-monadic style and still have everything take place in a monad?
23:59:59 <Heffalump> edwardk: right.
