00:04:54 <newbcoder> what is a good algernative to make?
00:05:29 <Korollary> java people use ant iirc
00:09:41 <dons> haskell people use Cabal, if you're writing haskell
00:16:20 <bortzmeyer> newbcoder: what do you dislike in make? It would help to know that in order to select an alternative
00:16:33 <bortzmeyer> Python people sometimes uses scons
00:17:01 <lokadin> bah, i can't get it to work, i put it as :: Array Int String ,  am i not supposed to have it in main? (it's not the last line) it keeps complaining that it expected IO b.
00:18:15 <dons> main has IO () type
00:18:45 <lokadin> ..., i know that
00:19:04 <lokadin> does it relate?
00:19:05 <Lemmih> bortzmeyer: Supporting multiple compilers, profiling and executables is almost impossible with make.
00:19:29 <lokadin> i thought it might, i just couldn't figure out how to get that function out of main
00:19:35 <Pseudonym> Anyone tried to compile Cabal from darcs lately?
00:19:41 <lokadin> i guess i could if i declare it outside
00:19:42 <lokadin> hmmm
00:19:45 <lokadin> brb
00:20:00 <Pseudonym> For some reason it doesn't work for me.
00:20:14 <Cale> lokadin: can you paste what you have?
00:20:15 <bortzmeyer> Lemmih: you exxagerate a bit. I have Makefiles for C programs which accept several C compilers.
00:20:17 <Lemmih> bortzmeyer: Make also has portability problems and is generally just pure evil.
00:20:22 <eivuokko> If you're using ghc, try adding -cpp on commandline for ghc
00:20:30 <Cale> Using an Array as a line of a do-block won't work
00:20:33 <sieni> Lemmih
00:20:46 <sieni> Lemmih: what's your option then?
00:20:59 <dons> I'd like to use \cdot for .
00:21:23 <Cale> ·
00:21:36 <Lemmih> sieni: I believe Cabal's the answer.
00:21:48 <bortzmeyer> Lemmih: I rely on GNU make (like SQL, it is almost impossible to be portable with make). GNU make runs on every platform and offer everything you need
00:22:10 <Pseudonym> GNU make, however, is not available on every platform.
00:22:14 <Pseudonym> And it doesn't offer everything you need.
00:22:14 <lokadin> @paste
00:22:15 <lambdabot> http://paste.lisp.org/new/haskell
00:22:30 <Lemmih> bortzmeyer: Have you tried installing a Haskell library with make?
00:22:32 <Pseudonym> It doesn't offer subdirectories in any helpful way, for example.
00:22:36 <lokadin> Cale: so how should i do it?
00:22:37 <bortzmeyer> Pseudonym: cite one Unix platform where it does not run
00:22:45 <lokadin> er
00:22:46 <lokadin> i'll paste
00:22:56 <bortzmeyer> Lemmih: no, I'm a beginner in Haskell, I'll have to try
00:23:02 <Pseudonym> I didn't say it doesn't run on every platform (though you did shift to "Unix").
00:23:12 <Pseudonym> I said it's not available on every platform.  As in, it doesn't come for free.
00:23:24 <sieni> Lemmih: ok, I just hoped that you don't say "autotools" ^_^
00:23:36 * Pseudonym is a fairly recent convert to scons
00:23:39 <Pseudonym> Though not for Haskell.
00:23:46 <Pseudonym> Well, not for Haskell-only.
00:24:25 <Oejet> Pseudonym: You know any make like program, which supports subdirectories?
00:24:49 <Pseudonym> Of course not.  if it supports subdirectories, it's not make-like.
00:25:03 <Oejet> Pseudonym: Aka "recursive make considered harmful"
00:25:18 <Oejet> Hm.
00:25:46 <Pseudonym> scons is pretty good for that.
00:26:00 <lisppaste2> Lokadin pasted "arrays" at http://paste.lisp.org/display/24923
00:26:13 <Pseudonym> Generally speaking, you can make recursive make work, if you don't care about things like -j
00:26:42 <bortzmeyer> Pseudonym: I do not understand. Recursive make transmits options like -j
00:27:06 <bortzmeyer> Pseudonym: just be sure to use "${MAKE}" and not "make"
00:27:07 <Pseudonym> Have you ever tried it?
00:27:10 <Pseudonym> How much parallelism did you get?
00:27:30 <bortzmeyer> Pseudonym: no, I did not try with -j but it works with other options
00:28:04 <Pseudonym> It doesn't do what you might naively expect it to do.
00:28:28 <lokadin> so little does
00:28:30 <bortzmeyer> Back to the subject of "make-like" programs, (I have for the first time) a real-world Haskell program to ship. Should I use Cabal (it currently uses make and it is simple, it has no subdirectories :-)
00:28:41 <Pseudonym> Yes.
00:28:59 <bortzmeyer> Pseudonym: my Haskell program do not always do what I expect
00:29:11 <Pseudonym> For obvious reasons, you don't want to have to learn Cabal on a complex program.
00:29:26 <bortzmeyer> But not all Haskell installations have Cabal (difference between "runs on" and "is available")
00:29:43 <Pseudonym> Sure, but it's the de facto standard.
00:30:00 <bortzmeyer> I was even planning to use autoconf, at least to detect ghc (and its version)
00:30:02 <dons> which haskell installations don't come with cabal?
00:30:15 <dons> its certainly a lot easier to find that autoconf + gnu make :)
00:30:19 <bortzmeyer> dons: so, you say that every Haskell instalation in the world has Cabal?
00:30:38 <dons> current versions of haskell compilers and interpreters all come with cabal, yes.
00:30:43 <Pseudonym> HBC probably doesn't.
00:30:47 <bortzmeyer> I just tried on my workstation and there is no Cabal, while ghc and hugs are installed and work
00:30:54 <Pseudonym> I didn't check though.
00:30:59 <bortzmeyer> (My workstation is a Debian stable)
00:31:01 <dons> they're not current then, your ghc must be more than 1 year old
00:31:10 <dons> ghc --version ?
00:31:14 <bortzmeyer> I do not upgrade compilers every month
00:31:26 <Heffalump> 6.2 if Debian stable
00:31:31 <bortzmeyer> ghc 6.4, (a backport from Debian unstable)
00:31:37 <Heffalump> IM 6.2.2
00:31:38 <Heffalump> ah, ok
00:31:51 <dons> 6.4.2 and later ghc's ship with cabal.
00:31:54 <bortzmeyer> On Debian, you apparently need the package libghc6-cabal-dev
00:31:56 <dons> hugs 2005 ships with cabal
00:32:07 <dons> nhc98 1.18 ships with cabal
00:32:15 <dons> not sure about yhc
00:32:16 <bortzmeyer> dons: not everybody compile from source, they use packjages where "development" things like Cabal are packaged separately
00:32:56 <dons> that doesn't change the fact that all current stable versions of the 3 main haskell compilers ship with cabal as standard
00:33:17 <dons> so i'd see it as a lighter dep than gnu make and autoconf (esp. for windows people)
00:33:21 * Korollary is lost
00:33:29 <tibbe> @hoogle a -> [a] -> a
00:33:30 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
00:33:30 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
00:33:30 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
00:33:34 <bortzmeyer> OK, I'll try to learn it. And for detecting is Haskell is there? autoconf? (My program is not for Haskellers, it is for people who need the program, period)
00:33:52 <tibbe> I want a concatWith = unWords with "glue" element
00:34:01 <bortzmeyer> And non-Unix platforms are not really important
00:34:05 <dons> cabal is pretty trivial for most haskell programs, 2 files only.
00:34:08 <dons> ?where hnop
00:34:08 <lambdabot> http://semantic.org/hnop/
00:34:17 <dons> is a useful stub to get started
00:34:45 <dons> you need 2 things: a Setup.hs and a project.cabal file
00:34:52 <dons> the latter corresponds to a Makefile
00:35:23 <tibbe> ?type unwords
00:35:24 <lambdabot> [String] -> String
00:35:32 <dons> as you can see from hnop, a basic haskell executable's build system is around 5 or so lines of cabal
00:35:35 <bortzmeyer> Again, how do you test if some Haskell (I try to make a program which works with hugs and ghc) is present?
00:35:46 <tibbe> @hoogle [String] -> String -> String
00:35:47 <lambdabot> No matches, try a more general search
00:35:58 <tibbe> @hoogle String -> [String] -> String
00:35:59 <lambdabot> No matches, try a more general search
00:36:13 <dons> if you want to add those kinds of additional tests, you'd state that in an external script
00:36:13 <tibbe> @hoogle [a] -> [[a]] -> [a]
00:36:14 <lambdabot> No matches, try a more general search
00:36:22 <dons> i.e. a sh script/autoconf/....
00:36:29 <tibbe> @hoogle [[a]] -> [a] -> [a]
00:36:30 <lambdabot> No matches, try a more general search
00:36:30 <dons> depending on how portable you want things to be
00:36:34 <tibbe> argh!
00:36:46 <lokadin> could i use vim script on the command line?
00:37:27 <bortzmeyer> dons: OK, I know and use autoconf and I am aware of its limits. You just confirmed that there is no ideal solution
00:37:44 <dons> you can avoid the gmake dependency
00:37:51 <Oejet> > let concatWith = unwords . Data.List.intersperse in concatWith "foo" ["abe", "kat", "ko", "kylling"]
00:37:52 <lambdabot>    Expecting a function type, but found `b'
00:37:53 <lambdabot>    Expected type: a -> [Stri...
00:38:11 <dons> cabal will handle any library requirements. additional stuff you write yourself, of course
00:38:14 <lokadin> bortzmeyer: you don't need to use autoconf if you're using cabal, it detects haskell and packages for you
00:38:31 <lokadin> bortzmeyer: automagically
00:38:35 <lokadin> :)
00:38:41 <dons> ah yes, you don't need to say "hugs 2005" as a dep
00:38:52 <dons> you just specify which libraries you need, i.e. base 2.0
00:38:58 <dons> --> ghc 6.6, for example
00:39:17 <dons> so that stays in cabal
00:39:39 <dons> Cale: what would be some good latex for the =<< operator?
00:40:28 <Oejet> > let concatWith x = unwords . Data.List.intersperse x in concatWith "foo" ["abe", "kat", "ko", "kylling"]
00:40:29 <lambdabot>  "abe foo kat foo ko foo kylling"
00:40:40 <Oejet> tibbe: ^
00:41:13 <Cale> dons: I'd use \! to shift the characters together a bit
00:41:25 <dons> ah yes that might do it
00:42:11 <Cale> iirc, it was either 2 or 3 \!'s which looked right
00:42:57 <dons> is there half-a \! ?
00:43:34 <dons> \newcommand{\rbind}{\code{=<\!<}} looks ok, but the = could be closer (\! is too close)
00:44:41 <dons> \hspace will do, I suppose
00:45:03 <Cale> yeah
00:45:18 <dons> ah, this is nice: \newcommand{\rbind}{\code{=\hspace{-0.3mm}<\!<}}
01:26:29 <petekaz> dons: how does this version of my pastebin look in your ascii browser?  http://www.kazmier.com/~kaz/pastebin.cgi
01:28:28 <Jaak>  links dont work
01:28:51 <Jaak> gives me "You don't have permission to access /~kaz/ on this server." in lynx, works okay in ffox
01:29:50 <johnnowak> petekaz: looks good here. just kill the redundant links.
01:30:14 <johnnowak> petekaz: i have to press down three times to get to the next one :)
01:30:34 <petekaz> true.
01:31:15 <johnnowak> if anything, clicking the name should give the last N posts by that user, not just that particular one.
01:31:24 <Jaak> looks are okay, but it just plain doesnt work
01:31:35 <johnnowak> Jaak: 'tis beta. :)
01:31:58 <Jaak> well, but it does in firefox, it that meant to be so?
01:32:01 <petekaz> I'm a newbie, I'm having a hard time as it is.
01:32:07 <Jaak> is*
01:32:20 <petekaz> Jaak: what do you mean it doesn't work?  It should.
01:32:55 <Jaak> well, in lynx http://www.kazmier.com/~kaz/pastebin.cgi loads okay, but i cant follow any links
01:33:04 <johnnowak> i can in elinks
01:33:12 <Jaak> its okay in links
01:33:19 <johnnowak> erm
01:33:36 <Jaak> ye, weird
01:33:41 <petekaz> johnnowak: yeah, its beta, I need to add a few things to it.
01:34:50 <johnnowak> petekaz: you also might want to stick to one <html> tag in the beginning :)
01:34:55 <johnnowak> maybe that's what is throwing lynx
01:35:07 <johnnowak> although.. i have no idea why it would.
01:35:17 <petekaz> johnnowak: one tag?
01:35:27 <johnnowak> <html
01:35:28 <johnnowak> ><html ><head
01:35:43 <johnnowak> that's rather odd angle bracing. :)
01:35:49 <petekaz> by design.
01:36:07 <petekaz> I'm using NewCGI module.
01:36:18 <johnnowak> maybe lynx doesn't like it
01:36:39 <johnnowak> not seen html before that puts the > on a new line
01:37:01 <petekaz> its perfectly valid.
01:37:14 <johnnowak> that doesn't mean lynx likes it
01:37:17 <petekaz> and it eliminates whitespace.
01:37:22 <petekaz> between tags.
01:37:31 <johnnowak> er
01:38:31 <johnnowak> well i think it is utterly insane. :) but you're free to do it. not sure what it will break though.
01:38:48 <petekaz> you don't do much web dev do you?
01:39:11 <johnnowak> no, i don't
01:39:33 <petekaz> "<tag1> <tag2>" is very different from "<tag1><tag2>"
01:40:05 <petekaz> and the way NewCGI renders output is like the latter as spaces inside the brackets is ignored.
01:40:14 <johnnowak> yes i know that much.
01:40:26 <petekaz> CSS is a bitch.
01:40:43 <johnnowak> you don't have to use it :)
01:40:57 <Jaak> ugh
01:41:22 <Jaak> css is biatch but its still useful
01:42:00 <petekaz> well, I must say that I like the clean use of HTML.  The plain HTML of that page is concise and simple, yet it looks halfway decent in firefox etc ...
01:42:02 <Jaak> much better than load of nested tables
01:42:07 <petekaz> right ...
01:42:28 <petekaz> My nav bar is <ul> element.
01:42:35 <johnnowak> very few sites need the complex layouts they employ
01:43:15 <johnnowak> they could ditch the tables and CSS complexity if they used something simpler and designed around the crap we have to work with rather than try and make things work in spite of it
01:43:17 <Jaak> whats with the <html><html> ...?
01:43:41 <petekaz> johnnowak: look at the html now ... I turned on debug mode in NewCGI which is less efficient than regular mode but does pretty printing.
01:45:17 <johnnowak> hm. lynx gives a 403 forbidden error
01:45:22 <johnnowak> elinks is fine
01:46:01 <Jaak> as i said :P
01:46:02 <petekaz> maybe it has to do with my links, I'm using a relative link that starts with '?action=...'
01:48:52 <petekaz> well, for now, it's good enough :-)  after all it is 4:45am here
01:49:26 <petekaz> thanks for the feedback.
02:35:57 <lokadin> is parsec a part of ghc?
02:36:19 <dons> its distributed with ghc
02:38:25 <lokadin> so would i have to find the definition of letter in the ghc sources then?
02:39:01 <lokadin> kk i'll figure it out probably
02:41:11 <dons> ?docs Text.Parsec
02:41:11 <lambdabot> Text.Parsec not available
02:41:22 <dons> ?index Parsec
02:41:23 <lambdabot> bzzt
02:41:27 <dons> ?hoogle Parsec
02:41:28 <lambdabot> Text.ParserCombinators.Parsec :: module
02:41:28 <lambdabot> Distribution.Setup.parseCleanArgs :: [String] -> [OptDescr a] -> IO (Int, [a], [String])
02:41:28 <lambdabot> Distribution.Setup.parseConfigureArgs :: ConfigFlags -> [String] -> [OptDescr a] -> IO (ConfigFlags, [a], [String])
02:41:33 <dons> ?docs Text.ParserCombinators.Parsec
02:41:34 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec.html
02:41:45 <dons> don't guess, read the docs :)
02:44:51 <lokadin> well that's really the problem, maybe i'm reading them wrong but i don't believe it's in the docs
02:45:15 <lokadin> how to make an alphabet such as letter
02:45:54 <bortzmeyer> I try to transform a list [a] into a String. I use "foldr (++) "" a" but I want to add a string between the items of the list (not at the end, only between)
02:46:05 <bortzmeyer> I do not find how to writ such a "join" function
02:46:16 <ProfTeggy> intersperse
02:46:25 <ProfTeggy> bortzmeyer, that's what can help you
02:46:29 <norpan> and concat
02:47:04 <dons> > concat . intersperse ", ["my", "little", "pony"]
02:47:04 <lambdabot>  Improperly terminated string
02:47:10 <dons> > concat . intersperse "," ["my", "little", "pony"]
02:47:11 <lambdabot>    Expecting a function type, but found `[a]'
02:47:11 <lambdabot>    Expected type: a1 -> [[...
02:47:16 <dons> > concat . intersperse "," $ ["my", "little", "pony"]
02:47:17 <lambdabot>  "my,little,pony"
02:47:49 <dons> > concat . intersperse "," . map show $ [True,False,False,True]
02:47:51 <lambdabot>  "True,False,False,True"
02:47:52 <lokadin> alright well i'm going to bed cause i can't deal with any more head and brick wall action, cya, have a good day all :) fe'o(translates as over and out)
02:48:05 <dons> ?pl \xs -> concat . intersperse "," . map show $ xs
02:48:05 <lambdabot> join . intersperse "," . map show
02:48:25 <norpan> concat == join
02:48:32 <norpan> lambdabot is fancy schmancy
02:49:30 <bortzmeyer> Thanks, intersperse was indeed what I was looking foir
03:12:31 <beelsebob> @hoogle (a->b->c) -> [(a,b)] -> [c]
03:12:32 <lambdabot> No matches, try a more general search
03:12:37 <beelsebob> bah
03:12:42 <beelsebob> no reZipWith then?
03:13:15 <dons> @hoogle (a -> b -> c) -> [(a , C[Cb)] -> [c]
03:13:16 <lambdabot> No matches, try a more general search
03:13:27 <dons> @hoogle (a -> b -> c) -> [(a , b)] -> [c]
03:13:28 <lambdabot> No matches, try a more general search
03:13:29 <dons> bah
03:13:33 <Igloo> @type map . uncurry
03:13:35 <lambdabot> forall a b c. (a -> b -> c) -> [(a, b)] -> [c]
03:13:44 <dons> @hoogle (a -> b -> c) -> [(a, b)] -> [c]
03:13:45 <lambdabot> No matches, try a more general search
03:13:49 <dons> silly hoogle
03:14:00 <dons> @hoogle (a -> b -> a) -> a -> b
03:14:02 <lambdabot> Prelude.curry :: ((a, b) -> c) -> a -> b -> c
03:14:12 <dons> @hoogle (a -> b -> a) -> [a] -> b
03:14:13 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
03:14:13 <lambdabot> List.minimumBy :: (a -> a -> a) -> [a] -> a
03:14:13 <lambdabot> Prelude.foldl1 :: (a -> a -> a) -> [a] -> a
03:14:18 <dons> oh well
03:14:33 <dons> @hoogle (a -> b -> a) -> [(,) a b] -> b
03:14:34 <lambdabot> hoogle: scripts/hoogle/src/Hoogle/MatchType.hs:74:8-45: Non-exhaustive patterns in function asBound
03:14:34 <lambdabot>  
03:14:38 <dons> heh
03:16:10 <dons> ?users
03:16:11 <lambdabot> Maximum users seen in #haskell: 235, currently: 197 (83.8%), active: 23 (9.8%)
03:43:05 <foxy_> > 197/235
03:43:06 <lambdabot>  0.8382978723404255
03:54:51 <dons> ?yow
03:54:51 <lambdabot> NANCY!!  Why is everything RED?!
03:56:16 <Cale> @yow
03:56:16 <lambdabot> While my BRAINPAN is being refused service in BURGER KING, Jesuit
03:56:17 <lambdabot> priests are DATING CAREER DIPLOMATS!!
03:59:06 <kzm> Are there jesuit priests?  I thought jesuits were monks.
04:03:26 <ibid> those two are not mutually incompatible
04:04:07 <ibid> http://en.wikipedia.org/wiki/Jesuit :)
04:05:50 <sieni> aren't monks quite often priests?
04:07:09 <ibid> yes
04:07:29 * tibbe sees the cool new tab-completion in GHCi 6.6 and immediatly launches GHCi to try it out. it doesn't work. oh yes, I forgot to install 6.6 first... %)
04:08:32 <dons> yeah, its rather nice
04:08:34 <ibid> i think kzm's confusion might come from the misunderstanding that all monks live in monasteries :)
04:15:47 <sieni> @pl (\f x -> zipWith f (map fst x) (map snd x))
04:15:48 <lambdabot> (`ap` map snd) . (. map fst) . zipWith
04:16:13 <sieni> @type ap
04:16:14 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
04:16:22 <sieni> "ok"
04:20:53 * kuribas has written syntax coloring support for lisppaste
04:23:06 <kuribas> I hope the lisppaste people are not all on vacation or something.
04:23:23 <petekaz> kuribas: nice, I just wrote a haskell pastebin too: http://www.kazmier.com/~kaz/pastebin.cgi
04:23:55 <petekaz> kuribas: re: lisppaste, I recently wrote the erlang syntax for it as well.
04:24:26 <kuribas> Oh, I see :)
04:24:39 <kuribas> Is that going to replace lisppaste?
04:25:19 <petekaz> I doubt it, but its going to be available if anyone wants to use it.  I use the hs-colour module for the syntax highlighting.
04:25:52 <kuribas> Well, it looks nice.
04:25:54 <musasabi> It seems that GHC runs on ReactOS. Now to create a build-slave there...
04:26:08 <petekaz> I wrote a haskell syntax for lisppaste as well a while back, but I had a hard time getting it to work in the edge cases.
04:26:41 <kuribas> petekaz: hmm, could you give me some examples of edge cases?
04:26:43 <petekaz> And since I am brand new to haskell I thought I'd try to write a simple web app to wet my appetite.
04:26:59 <kuribas> I am not sure I have those right...
04:28:02 <petekaz> I can't remember, it was a very long time ago (about a year), this was when I wrote the erlang one (oddly enough, it took them a year to add it to lisppaste)
04:28:42 <kuribas> ouch.  I hope they don't take a year for the haskell one.
04:28:50 <musasabi> Haskell98 is quite nontrivial to parse
04:29:11 <kuribas> musasabi: I don't do much more than lexing actually.
04:29:16 <petekaz> musasabi: I discovered that.
04:29:25 <musasabi> the lexeme and whitespace rules are not the clearest ones around.
04:29:26 <petekaz> kuribas: I recall a good test case for you!
04:30:08 <kuribas> petekaz: go ahead!
04:30:20 <petekaz> kuribas: one of the simon's wrote a lexer for haskell.  put that into your lisppaste syntax and watch it fail.  I just can't find the link right now.
04:30:49 <petekaz> I need to run and get ready for work ... bbl
04:31:43 <petekaz> kuribas: maybe try this: http://cgi.cse.unsw.edu.au/~cs3161/06s1/tutorials/04/Lexer.html
04:31:43 <kuribas> It would be hard to watch it fail without the code ...
04:31:43 <lambdabot> Title: Lexer.hs
04:31:54 <kuribas> ah, ok :)
04:31:55 <dmwit> Is there any editor that does auto-indentation for Haskell?
04:32:04 <kuribas> emacs
04:32:46 <dmwit> Ah, then it's even worse that vim doesn't... =P
04:37:55 <kuribas> petekaz: It looks fine.
04:39:17 <kuribas> My syntax coloring will not work for nested comments, and probably not for unicode characters that are not in the ascii set.
04:45:51 <vincenz> @seen boegel
04:45:51 <lambdabot> boegel is in #haskell and #haskell-blah. I don't know when boegel last spoke.
04:45:53 <vincenz> @seen itkovian
04:45:53 <lambdabot> I saw itkovian leaving #haskell-overflow, #haskell-blah and #haskell 1 day, 14 hours, 30 minutes and 20 seconds ago, and .
04:52:01 <boegel> vincenz: y0w
04:52:19 <boegel> vincenz: Itkovian is on holdiay I think
04:52:50 <vincenz> ah thanks
04:55:00 <vincenz> I heard the meeting went well :)
04:56:13 <boegel> vincenz: yeah, sure... Andy didn't get much new information, but it was interesting to get an overview of the whole thing
04:56:19 <boegel> it's quite fast too :)
04:56:21 <bortzmeyer> A Parsec issue: I try to write a grammar which recognizes between N and M occurrences of a string. Parsec has "count n p" but no "count n m p".
04:56:34 <vincenz> boegel: thx :)
04:56:48 <bortzmeyer> I tried to write one such combinator and it is not obvious: "optional" or "option" do not have the signature I want.
04:56:53 <vincenz> boegel: and it uses plain maps inside as well as oo, so it could be faster :P
04:57:51 <bortzmeyer> Does anyone has such combinator already written?
04:58:13 <mauke> yeah, but not in parsec
04:58:57 <mauke> manyNtoM c m n p = liftM2 (++) (manyN m p) (manyToN c n p)
04:59:31 <mauke> manyToN c n p | n <= 0 = return [];  | otherwise = prepend p (manyToN c (n - 1) p) `c` return []
05:00:10 <mauke> prepend = liftM (:)
05:01:51 <bortzmeyer> mauke: thanks, but I prefer to continue to use Parsec (I do no want to rewrite everything)
05:02:00 <vincenz> Anyone know why that stuff on map and fmap isn't tagged by [Haskell-cafe]   It is rather annoying and spammy
05:02:15 <vincenz> ah, haskell-prime
05:02:35 <mauke> bortzmeyer: the above code should be relatively easy to translate to parsec. I think.
05:32:34 <frederik> hello
05:33:00 <frederik> is there anybody in here who could help me with a ... very basic wxhaskell problem?
05:33:16 <Lemmih> Sure.
05:33:26 <frederik> a, nice
05:33:42 <frederik> wait a minute ;)
05:34:33 <frederik> I don't seem to understand the way the inheritance is realized in wxhaskell
05:34:44 <frederik> I'm trying to do a custom control
05:35:16 <frederik> I looked at the custom control demo but it didn't help much
05:36:04 <frederik> I need to store some information with my control and the CustomControl sample says something like "For more complicated things, one should define a ColorBox data type instead of a simple type synonym"
05:36:27 <frederik> Lemmih: how would something like this look like?
05:39:09 <Lemmih> frederik: I'm sorry, I don't know much about wxhaskell.
05:39:31 <frederik> ok
05:40:53 <frederik> it could really need a better documentation/introduction
05:56:45 * ProfTeggy smells a volunteer in this channel...
05:56:55 <ProfTeggy> Could it be.... frederik? ;-)
05:59:33 <ricky_clarkson> No.
05:59:42 <ricky_clarkson> A volunteer does not complain, he patches.
06:00:02 <frederik> ProfTeggy: a volunterr for what :)
06:00:03 <frederik> a
06:00:06 <frederik> hehe
06:00:08 <ricky_clarkson> To fix the docs.
06:00:09 <ProfTeggy> Hehe
06:00:10 <frederik> I didn't really complain
06:00:20 <ProfTeggy> No, you identified a shortcoming.
06:00:24 <frederik> no, no *g as you've seen above I don't understand
06:00:25 <frederik> it
06:00:26 <ProfTeggy> Did right in.
06:00:34 <ProfTeggy> s/Did/Dig/
06:01:03 <frederik> You don't want documentation by someone who doesn't understand what he's talking about hehe
06:01:49 <frederik> All the basic stuff is documentated rather well, but the custom control demo doesn't help me much
06:02:03 <frederik> ricky_clarkson: ProfTeggy: you don't happen to know more about wxhaskell :)
06:02:56 <ricky_clarkson> Nope.
06:03:00 <ProfTeggy> I hardly know about its existence.
06:14:38 <dons> ?seen shapr
06:14:39 <lambdabot> I saw shapr leaving #haskell and #ScannedInAvian 11 days, 18 hours, 31 minutes and 25 seconds ago, and .
06:18:34 <boegel> dons: hmm, I wonder where he's at...
06:18:53 <dons> working I suppose
06:19:01 <dons> (blog's still active, very much)
06:20:46 <ricky_clarkson> Does he blog while on a unicycle?
06:26:06 <bringert> he did mention using his Nokia 770 for blogging, I guess that could be done on a unicycle
06:27:09 <dons> I seem to recall him talking about juggling nokias while unicycling. maybe that's involved in some way?
06:28:52 <bringert> I trust that everyone has seen this picture of John Hughes on shapräs unicycle: http://www.scannedinavian.com/hope/image/63
06:29:12 <bringert> eh, stupid swedish keyboard, that should be shapr's
06:29:29 <ricky_clarkson> Nice domain name.
06:29:51 <bringert> gotta go, phd cake at work!
06:30:13 <ricky_clarkson> phd cake?
06:30:43 <lokadin> maybe he's getting a cake for getting his phd?
06:30:52 <JKnecht> sure; ought be after the defense though.
06:31:10 <dons> I wish I had a phd cake
06:31:21 <ricky_clarkson> I don't have a phd, or a cake.
06:31:32 * JKnecht don't want either.
06:31:45 <ricky_clarkson> I ate pancakes earlier, does that count?
06:31:57 <ricky_clarkson> Microwavable ones, so probably not.
06:31:59 <lokadin> were they phd pancakes?
06:32:07 <JKnecht> no, masters.
06:32:14 <lokadin> oo, well close enough
06:32:24 <dons> a phd cake is a funny cake that takes 4 years to cook, no one understands what you put in it or why it takes so long to cook. and when its done only you really want to eat it
06:32:32 * boegel will push hios gf into baking a cake tonight, all this talk is making him hungry
06:32:36 * ricky_clarkson is a better programmer than any phd he's met.
06:32:39 <ProfTeggy> dons, let me take this down...
06:32:45 <boegel> dons: heh :)
06:32:45 <lokadin> if you had some kinda syrup or jam i'm sure the pancakes could have been considered a cake
06:33:05 <lokadin> if it was stacked
06:33:06 <dons> ProfTeggy: hehe
06:33:15 <ProfTeggy> ricky, the 'P' in PhD is not for 'Programming'
06:33:40 <lokadin> really?
06:33:43 <lokadin> lol j/k
06:33:53 <ricky_clarkson> ProfTeggy: That's why I don't want one.
06:33:55 <boegel> dons: you are the new topic in #haskell-blah, congrats :)
06:34:21 <boegel> ricky_clarkson: a Phd isn't about programming, it's about research...
06:34:30 <lokadin> fun fun :)
06:34:46 * boegel brings out his Phd knives
06:35:22 <ProfTeggy> Well, research can certainly be about programming
06:35:34 <dons> boegel: hehe :)
06:35:53 <boegel> ProfTeggy: ok, it can, but it's not always like that
06:36:01 <ricky_clarkson> boegel: I program and research simultaneously, but my goal is better programs, not a PhD. ;)
06:36:22 <boegel> anyway, I've learned a hell of a lot more about programming in the first year of my Phd, than I have in my 4 years Master
06:36:33 <ricky_clarkson> What's it on?
06:36:43 <dons> boegel: cool :)
06:36:46 <BCoppens> boegel: doesn't surprise me that much ;)
06:36:52 <boegel> ricky_clarkson: estimating performance based on program similarity
06:36:59 <boegel> BCoppens: :D
06:37:30 <boegel> ricky_clarkson: but I'm far away of being an expert... I'd like to get into Haskell some more, but I don't have the time
06:38:05 <boliver> ricky_clarkson is, via Curry-Howard, a better mathematician than any PhD student:)
06:38:36 <ricky_clarkson> ..that I've met.
06:39:08 <ricky_clarkson> I don't use Greek symbols though, that's my handicap. ;)
06:39:26 * ProfTeggy grins.  Yous ound frustrated.
06:40:05 <ProfTeggy> A \lambda here and there doesn't hurt as the good people of this channel know.
06:40:53 * boegel uses alpha quite a lot, the architecture that is
06:41:11 <lokadin> say i wonder do any of your students ever get a hold of you here? frequently/
06:41:45 <ProfTeggy> Not that I know of.  kosmikus has been a student of mine.  But that's quite some time ago.
06:42:31 <ricky_clarkson> I will start using sounds instead of symbols.
06:43:01 <lokadin> oh okay, just wondering, always seemed like the most logical place to go when learning haskell, #haskell that is
06:43:10 <tennin> ProfTeggy, aren't you a database expert?
06:43:10 <ProfTeggy> Yes, but use them consistently.  Don't fart where you barked yesterday.
06:43:12 <lokadin> ricky_clarkson: you can use lojban variables :)
06:43:55 <ProfTeggy> tennin, my research is on database query compilation.  Calling me an expert is flattering, thanks.
06:44:22 <ricky_clarkson> boegel: Why estimate performance rather than measure it?
06:44:40 <dons> heh
06:45:08 <tennin> do you know of any applications of category theory in the database field?
06:45:34 <ricky_clarkson> ProfTeggy: Is allowing null a mistake in databases?
06:45:56 <ProfTeggy> tennin, monads have been used as a useful abstraction of the diverse collection types you encounter when you compile rich query languages, like OQL.
06:46:43 <boegel> ricky_clarkson: various reasons... machine not available, simulation too slow, too much applications to measure, ...
06:46:43 <ProfTeggy> tennin, monad comprehensions are a quite versatile representation for queries.  I have written some pieces on this view of database querying.
06:46:56 <ProfTeggy> tenning, so, yes
06:47:53 <tennin> ok
06:48:25 <ProfTeggy> tennin, do you know about LINQ?
06:48:41 <tennin> that's the basis for C# v3 LINQ?
06:48:53 <ProfTeggy> That's what I mean, yes.
06:49:02 <tennin> yeah
06:49:13 <ProfTeggy> LINQ re-establishes this connection between database querying and monads.
06:49:34 <ProfTeggy> This time in a much more digestible setting (C#) than category theory.
06:49:51 <ProfTeggy> Maybe it will succeed this time.  Erik Meijer pushes it, so there's some hope.
06:54:08 <tennin> I was reading the "Alice book", and presentations in terms of set theory always make me wonder about categorical generalizations
06:54:19 <tennin> it's my own personal version of mindless buzzword-compliance seeking
06:55:20 <JKnecht> Alice book?
06:55:53 <tennin> "Foundations of Databases"?
06:56:49 <JKnecht> well if it's couched in sets oughta have a categorical generalization.
06:57:04 <tennin> it has an Alice in Wonderland illustration on the cover
06:58:06 <JKnecht> i'm way ole school, still use Ullman
07:37:19 <beelsebob> interesting...
07:37:32 <beelsebob> does unsafePerformIO happen atomically?
07:37:55 <beelsebob> or can it end up with the operations in the unsafe bit interleaved with other operations?
07:57:19 <bringert> is there a way to install ghc built from darcs sources without overwriting the /usr/local/bin/ghc etc., i.e. just install as /usr/local/bin/ghc-6.5?
07:58:27 <therp> I presume only be choosing another prefix..
07:58:45 <therp> ./configure --prefix=/usr/local/ghc-6.5 will create /usr/local/ghc-6.5/bin/ghc
07:58:48 <Igloo> I don't think so, but you could move bin out of the way, install, move it back and then move across those binaries you want
07:58:52 <musasabi> ./configure --prefix=/opt/ghc-6.5-20060829 ?
07:59:09 <Igloo> But yeah, --prefix is probably easier
08:19:01 <alec> Igloo: thank you for updating ghc-cvs!
08:19:48 <Igloo> np  :-)
08:21:06 <bringert> after running  ./configure --prefix=/opt/ghc-6.5-20060829, what do I have to rebuild, if anything? Are the paths hard-coded into executables or anything like that?
08:23:55 <Igloo> They're in shell scripts nd package.conf files
08:24:49 <Igloo> I'm fairly sure make install will suffice, but you could run make first if you want to make sure
08:27:57 <bringert> Igloo: btw, I'm adding a dummy deprecated Network.NewCGI module which reexports Network.CGI so that old programs compile with the cgi package that comes with GHC 6.6. That's not a problem, right (for API stability reasons or anything like that)?
08:29:09 <Igloo> Changing the API for 6.6 should be fine as long as you get it in before the RC is announced
08:30:29 <bringert> Igloo: thanks. oh, and another thing, I keep changing the version number of my packages quite often, but that seems to produce errors like "Bad interface file: Text/XHtml/BlockTable.hi
08:30:29 <bringert>         Something is amiss; requested module  xhtml-2006.8.29:Text.XHtml.BlockTable differs from name found in the interface file xhtml-2006.8.14:Text.XHtml.BlockTable" when I run make in ghc
08:31:25 <xerox> > hello = "hello " ++ hello in hello
08:31:25 <lambdabot>  Parse error
08:31:28 <xerox> Arrr.
08:31:43 <xerox> Hi.
08:31:44 <bringert> shouldn't the build system or something figure that out? Or did I do something wrong in my Makefiles? I basically just copied them from other packages
08:31:48 <bringert> hi xerox
08:33:15 <benja_> has anybody experimented with making (->) an arrow and defining (f x) to be arrow application?
08:33:21 <Igloo> I suspect the modules aren't depending on the package.conf files; I'll try to look into it
08:33:50 <xerox> benja_: There actually is an Arrow (->) instance defined in the library.
08:34:28 <benja_> right ... but I mean redefining the syntax so that (f x) is general arrow application and specializes to function application for functions
08:34:45 <benja_> I'm sure it gets tricky and annoying and all, but somebody must have had the thought ;)
08:35:39 <CosmicRay> Igloo: do you have any hunch on that alpha build failure?
08:36:43 <xerox> > arr (+2) 1
08:36:44 <lambdabot>  3
08:36:56 <xerox> Does it get complicated?
08:37:57 <Igloo> CosmicRay: My hunch is that gcc is broken
08:38:09 <CosmicRay> ugh.
08:38:51 <benja_> I suppose I could try the idea myself by building a preprocessor which transforms every Haskell function application (f x) to (arr f x)...
08:38:51 <CosmicRay> I was wondering about some autoconf stuff, since it seems to be the package.conf.inplace file that's having an iissue
08:39:02 <benja_> ...and see whether type inference etc still works as expected...
08:39:06 * Igloo wishes I could log in to goedel to see what it's doing
08:39:18 <Igloo> The package.conf.inplace file looked fine to me
08:39:33 <CosmicRay> oh, where did you find it?
08:39:48 <Igloo> I retried the build on escher before it got locked down
08:40:02 <CosmicRay> ah.
08:40:16 <CosmicRay> I'm building a testing environment on my own alpha box, but it's a 600MHz one so this will take awhile.
08:40:43 <Igloo> That's 67 million more than escher  :-)
08:40:45 <benja_> ibid: IIRC you were considering (f x) to be arrow application for some language of yours, didn't you? did that go anywhere?
08:41:06 <ibid> benja_: yes and no
08:41:16 <CosmicRay> Igloo: heh, escher is a slower alpha than mine?
08:41:18 <ibid> benja_: it's on the back burner :)
08:41:20 <CosmicRay> mine is literally 10 years old
08:41:22 <benja_> =-)
08:41:36 <Igloo> It's a EB164 SX164 533MHz according to http://db.debian.org/machines.cgi?host=escher
08:41:38 <lambdabot> Title: Debian Project -- debian.org Developer Machines
08:41:52 <CosmicRay> Igloo: ahh.  so similar to mine but a bit slower.
08:42:03 <CosmicRay> mine is a LX164 600MHz
08:42:09 <benja_> ibid: know any references about stuff like this?
08:42:17 <Igloo> It only took goedel a bit over an hour to break, though, and that's a DS20E EV68 833MHz
08:42:22 <ibid> benja_: not really
08:42:27 <benja_> ok
08:42:31 <ibid> benja_: why do you ask?
08:42:42 <CosmicRay> Igloo: last time I tried to build ghc6 on debian boxen, they didn't have several of the build-deps
08:42:45 <CosmicRay> Igloo: is that better now?
08:43:13 <benja_> ibid: idly podering it for fencore, for similar reasons as you were, probably :-)
08:43:36 <Igloo> CosmicRay: debian-admin@lists.debian.org normally install things within a day IME
08:44:24 <Igloo> Currently lots of the d.o machines should have all the build-deps as I've been testing ghc-cvs on them
08:54:52 <musasabi> Does cabal support having a required preprocessor in the same package as the source?
09:01:18 <ndm> musasabi: kinda, lambdabot does that
09:01:33 <ndm> but not that much using cabal, more hand hacked
09:04:05 <musasabi> @version
09:04:05 <lambdabot> lambdabot 4p93, GHC 6.5 (OpenBSD i386 )
09:04:05 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
09:07:05 <profmakx> hooray for lambdabot
09:12:19 <musasabi> does not work for libraries unfortunately :-(
09:21:40 <tibbe> ?users
09:21:42 <lambdabot> Maximum users seen in #haskell: 235, currently: 204 (86.8%), active: 28 (11.9%)
09:22:21 <ndm> ?users haskell
09:22:22 <lambdabot> Maximum users seen in haskell: 1, currently: 0 (0.0%), active: 0 (0.0%)
09:22:33 <CosmicRay> Igloo: it's a bad sign when it takes several minutes to compile one file.
09:24:09 <Igloo> Which file?
09:24:19 <CosmicRay> Main.hs
09:24:34 <CosmicRay> so there may be a reason ;-)
09:24:51 <CosmicRay> but it's on a slow machine, and an unregisterized platform...
09:25:02 <CosmicRay> used to be terribly slow on amd64 too, until they did a real port
09:35:15 <Oejet> Hi, boegel.
09:37:15 <ricky_clarkson> Is even arithmetic lazy in Haskell?
09:37:31 <SamB> ricky_clarkson: ... not usually...
09:37:36 <SamB> why?
09:37:45 <SamB> do you have some code that is bugging you?
09:37:50 <ricky_clarkson> Nope.
09:37:59 <ricky_clarkson> Curiosity.
09:38:20 <SamB> the product and sum functions seem to be designed for use with lazy arithmatic, though...
09:38:37 <apfelmus> huh? + : Int -> Int -> Int is strict in its arguments
09:38:57 <xerox> Strict?
09:39:48 <SamB> apfelmus: the functions whose names are "product" and "sum"
09:39:51 <xerox> > fst (1,(+) 1 undefined)
09:39:52 <lambdabot>  1
09:40:12 <apfelmus> > 1+ undefined
09:40:13 <lambdabot>  Undefined
09:40:20 <ricky_clarkson> In a lazy library in Java, lazy arithmetic would be prohibitively annoying, due to no operator overloading.
09:40:58 <apfelmus> SamB: they operate on lists
09:42:01 <apfelmus> xerox: fst is the lazy function in your case. fst (1,1+undefined) == fst (1,undefined) == 1
09:46:03 <tieTYT> i see that snd is also
09:47:12 <frederik> I asked earlier today, but maybe now there's someone in here who could help me with a basic wxhaskell problem?
09:47:38 <lispy> how basic?
09:47:42 <lispy> i got it to compile once
09:47:53 <frederik> lispy: hehe, not that basic ;)
09:48:01 <frederik> lispy: something about custom controls ...
09:51:12 <frederik> hm, someone has to be using that library ...
09:52:28 <ndm> frederik: gtk2hs has tons of support, thats why i switched from wx -> gtk
09:53:17 <ndm> despite prefering wx in general...
09:53:53 <frederik> ndm: hm, wxhaskell looked at bit nicer at a first glance
09:54:23 <ndm> frederik: yes, but they don't even have compiled windows versions which work with GHC 6.4.2, which is a bad sign
09:55:04 <frederik> maybe I should have a look at gtk2hs, too. Using glade might be nice as well if I had to do something larger
09:55:28 <Oejet> ndm: Neither does gtk2hs. ;-)
09:55:43 <ndm> Oejet: it does, if you need a link, i have one
09:55:54 <ndm> Oejet: i complained to dcoutts, he made one within the hour
09:56:24 <Oejet> I installed gtk2hs on Windows yesterday, did I miss it? X-)
09:57:31 <frederik> wxhaskell doesn't seem to be maintained currently, too
09:57:43 <frederik> on the other hand there's a thread on haskell cafe about reviving it
09:59:06 <SyntaxNinja> frederik: I've heard stuff about a team looking to maintain it.
09:59:12 <ndm> Oejet: so do you already have it installed andbuilt? you probably did miss it - it only ended up on the mailing list
09:59:34 <ndm> there is a team, but its only a team maintaniing it once something actually happens
09:59:43 <bringert> Igloo: ./configure --prefix=/opt ; make; make install didn't cut it: $ /opt/bin/ghci
09:59:43 <bringert> /opt/bin/ghci: line 5: /usr/local/lib/ghc-6.5/ghc-6.5: No such file or directory
09:59:45 <ndm> whereas dcoutts is actively maintaining and developing gtk2hs
10:01:13 <Igloo> Hmm, that's a little worrying
10:02:09 <bringert> I could of course have done something wrong
10:02:54 <Oejet> ndm: I did a binary install.
10:03:09 <Igloo> You can't do foldl'/build fusion, right?
10:03:32 <frederik> ok, compiling gtk2hs ...
10:03:32 <Igloo> bringert: Added to my list of things to look at, ta
10:04:40 <audreyt> is there any way to make ghci loada .a file
10:04:46 <audreyt> save using ar to extract them all out?
10:07:40 <bringert> audreyt: I think there some way to turn the .a file into a single .o file that ghci loads, but not to load an .a file directly. but I'm no authority on the matter
10:07:51 <bringert> eh, thers *is*
10:08:29 <bringert> like what ghc-pkg --auto-ghci-libs  does
10:09:15 <audreyt> hm. not sure how to programattically do it
10:09:19 <audreyt> but thanks for the Ptr
10:12:03 <bringert> audreyt: I think it's a pretty simple ar operation, I think I've done it in a Makefile in the past
10:16:15 <petekaz> bringert: I used your NewCGI to make a haskell pastebin.
10:16:30 <petekaz> bringert: http://www.kazmier.com/~kaz/pastebin.cgi
10:17:04 <bringert> petekaz: nice
10:18:19 <bringert> petekaz: first bug report: maybe the view should be a bit wider, http://www.kazmier.com/~kaz/pastebin.cgi?action=Display&id=1156853110780394000000 needs horizontal scrolling
10:18:36 <petekaz> yeah.
10:18:51 <bringert> do you store the pastes in plain files?
10:18:54 <petekaz> mine has scrolling.
10:18:59 <petekaz> yours does not?
10:19:22 <petekaz> oh, you don't want scrolling.
10:19:29 <bringert> ah, I meant that it has scrolling, but that the view should be wider so that it doesn't need it
10:19:49 <bringert> petekaz: how do you store the pastes?
10:20:32 <petekaz> bringert: fixed (800 now), just refresh.
10:20:54 <petekaz> bringert: pastes are just stored by writeFile $ show paste
10:21:01 <petekaz> each paste in its own file.
10:21:09 <petekaz> no locking required.
10:21:26 <bringert> sweet. to bad there is no way to use characters widths as length units in CSS
10:21:35 <petekaz> you can.
10:21:42 <petekaz> right?
10:21:47 <bringert> I thought there was only heights
10:21:51 <bringert> em and ex
10:21:55 <petekaz> I don't think so.
10:22:09 <petekaz> I'll try ... hold on
10:22:11 <bringert> in that case, maybe you could make it 80 characters wide
10:22:38 <petekaz> I just set it to 90em.
10:22:40 <petekaz> too big now.
10:23:00 <bringert> em is the font-size, i.e. height
10:24:09 <bringert> petekax: nice app. have you made a lambdabot plugin to display new pastes in the channel?
10:24:20 <petekaz> I went back to 800px.  Using ems and exs screws up my display as different fonts are used in different places.
10:24:26 <petekaz> bringert: that is my next step.
10:24:56 <petekaz> bringert: I'm really happy about the clean HTML generated.
10:25:21 <bringert> yeah, it looks very nice.
10:25:25 <petekaz> I defer everything to CSS.  Even my navbar is a UL list.
10:26:06 <bringert> I do the same in hope, it is very nice to be able to change the look of the site without touching the program
10:26:39 <bringert> http://hope.bringert.net/ if you haven't seen it
10:26:42 <petekaz> Yes.  Although your default color scheme in hope is terrible!  (or is that just shapr's)
10:26:54 <petekaz> (not claiming mine is any better ...)
10:27:19 <bringert> it's not the default, but I did make it, and I use it for my hope setup
10:27:25 <bringert> I'm not much of a designer
10:27:32 <bringert> you don't like baby blue?
10:27:36 <petekaz> the left side looks washed out or faded.
10:27:41 <petekaz> yeah, the blue.
10:27:48 <petekaz> well .. no
10:28:08 <petekaz> the blue is okay.  It's the color of the section titles.
10:28:57 <bringert> I need to do something about that then. any suggestions?
10:29:00 <petekaz> it needs more contrast or it needs to be more complementary.  Instead it looks as if the blue (which isn't bad) is a transparency that was laid on top of the rest.
10:29:28 <petekaz> I bought this nifty color book.  It just has color schemes in it.
10:29:41 <petekaz> let me look at it for your blue and see what options there are.
10:30:52 <petekaz> fyi: http://www.amazon.com/Color-Index-Over-1100/dp/1581802366/sr=8-1/qid=1156872474/ref=pd_bbs_1/102-2419787-0508128?ie=UTF8
10:31:42 <petekaz> bringert: how about this: rgb(254,134,71)
10:33:56 <petekaz> in addition to the above these other two seem to go nicely with it (assuming your blue is (110,176,220)): (147,131,86), (67,30,47)
10:34:18 <boegel> Hi Oejet
10:34:30 <boegel> I'm off again, the dishes are calling... :)
10:37:20 <bringert> petekaz: that orange became a bit unreadable on the gray, and it very intense
10:37:30 <bringert> see http://hope.bringert.net/
10:37:47 <petekaz> I would make the orange the background, not the foreground.
10:37:52 <bringert> ah
10:38:05 <petekaz> Or the purplish color I pasted.
10:38:51 <petekaz> this one would look nice i bet (67,30,47)
10:38:55 <bringert> ah, right, if I change the background I have to make new rounded corners
10:39:14 <petekaz> not the background ... sorry, the background of the section titles.
10:39:23 <petekaz> the grey items now.
10:39:29 <bringert> hehe, ok
10:39:42 <petekaz> the blue is nice, no need to ditch that.
10:40:38 <petekaz> and that orange looks a bit brighter than what I meant to type (254,134,71)
10:41:19 <bringert> trying the purple now
10:41:36 <petekaz> thats not too shabby.
10:41:45 <bringert> yeah
10:41:53 <bringert> I need to make new corners
10:41:56 <petekaz> maybe orange text now.
10:42:10 <bringert> on just the titles, or everything?
10:42:26 <petekaz> or the khaki color (just the titles)
10:43:50 <petekaz> you know you can use rgb values right?
10:44:06 <petekaz> color: rgb(254,134,71)
10:44:10 <petekaz> is permissible
10:44:22 <petekaz> (not sure if you are converting those nums to hex)
10:44:24 <bringert> yee
10:44:41 <bringert> I normally use hex, but I copied your values now
10:44:52 <bringert> can't be bothered to convert
10:45:49 <lispy> i wish Doc was a type class, but i guess even then i'd still need some parameter to tell it which style I want
10:47:01 <CosmicRay> Igloo: still building stage1.  hasn't hit the problem yet.
10:48:55 <bringert> grr, CSS is a pain sometimes:
10:48:58 <bringert> .navigation .tree .label .navigation a:link,
10:48:58 <bringert> .navigation .tree .label .navigation a:visited,
10:48:58 <bringert> .navigation .tree .label .navigation a:active,
10:48:58 <bringert> .navigation .tree .label .navigation a:hover {
10:50:07 <petekaz> I notice you suffer a bit from classitis.
10:50:13 <bringert> eh, typo
10:50:22 <SamB> heh
10:50:24 <bringert> one .navigation too many
10:50:25 <petekaz> I used to do the same until I read Zeldman's book.
10:50:50 <bringert> which book is that?
10:51:09 * bringert has never read any web design books, though he should
10:51:20 <petekaz> http://www.zeldman.com/dwws/
10:51:21 <lambdabot> Title: Zeldman: Designing With Web Standards, 2nd Edition
10:51:39 <petekaz> Great book.  It teaches you the 'right' way of using the various standards effectively.
10:51:49 * Heffalump is currently suffering with CSS
10:51:51 <vincenz> re
10:51:55 <Heffalump> I need to make something work in IE, sadly.
10:51:57 <petekaz> How to avoid classitis and divitis.
10:52:17 <petekaz> Heffalump: took me forever to get my pastebin code looking right in all browsers I have available to me.
10:52:21 <petekaz> and IE was the worst.
10:52:38 <petekaz> The Zeldman book speaks of the broken box model that IE suffers from.
10:53:15 <SamB> hmm, I wonder if any browsers use a bag model...
10:55:23 <Oejet> Anyone knows the technical reasoning behind IE being seemingly so horrible with CSS?
10:55:59 <petekaz> Oejet: I believe it has to do with its box model implementation.  That basically screws everything up in a non-compatible manner.
10:56:02 <tieTYT> what makes you think there's a technical reason?
10:56:13 <tieTYT> it's probably just easier to implement less
10:56:43 <SamB> Oejet: they need to rewrite it
10:57:20 <bringert> if you are the dominant player, it's better to force people to develop solutions that work in your browser but not in other's
10:58:21 <bringert> few user will switch from IE because of its broken CSS implementation, since no web developer can afford to make pages that look crap in IE
10:58:25 <Oejet> Yeah, yeah, but do they actually instruct their programmers to do that?
10:58:26 <bringert> users
10:58:49 <bringert> I wouldn't think so, they just don't tell them to fix their bugs I guess
10:59:00 <Heffalump> IE7 is going to be better, AIUI
10:59:30 <bringert> or rather, give them lots of other assignments with higher priority because of their better payoff for the company's bottom line
11:00:33 <SamB> Oejet: they said something about not being able to fix it without rewriting the whole thing, iirc...
11:01:17 <SamB> the whole thing being the layout/rendering engine, of course...
11:01:44 <SamB> (Or was that about XHTML? I think it really sorta goes together somehow, though...)
11:06:37 <integral> @pl \a b -> compare (snd a) (snd b)
11:06:37 <lambdabot> (. snd) . compare . snd
11:07:04 <integral> ugly
11:09:31 <tieTYT> what's up with that \ format for defining functions
11:09:41 <tieTYT> \x -> x + 5
11:09:51 <tieTYT> why would i do that?
11:09:54 <lament> tieTYT: \ is the greek letter lambda
11:10:09 <Eidolos> Rather, a very crude approximation thereof. :)
11:10:25 <tieTYT> yes but why would i use it?
11:10:45 <tieTYT> is it an anonymous function?
11:10:47 <integral> You'd use an eta for a lambda-abstraction?  Or maybe a zeta?  Or a rho?
11:10:51 <lament> tieTYT: clearly.
11:11:03 <tieTYT> ok then i'm sure that's pretty powerful
11:11:03 <lament> tieTYT: it's a function, and it doesn't have a name, so it must be...
11:11:59 <tieTYT> i'm new here :P
11:19:06 <kolmodin> I tried to write a c2hs' .chi files dependency resolver as a Setup.hs script to cabal, but it's hard (well, requires duplication of code) since cabal is very restrictive with which functions it exposes to the user
11:19:57 <kolmodin> so, the best would be if it was included into cabal, naturally
11:32:49 <integral> @pl \m -> [m]
11:32:49 <lambdabot> return
11:36:07 <CosmicRay> so, I guess I can't just check out the http://darcs.haskell.org/packages/unix/ and hack on it... is there a document somewhere that describes the minimum I need to be able to hack on that stuff?
11:36:09 <lambdabot> Title: Index of /packages/unix
11:39:10 <araujo> hello!
11:39:22 <CosmicRay> yo araujo
11:39:32 <araujo> hi hi CosmicRay
11:39:40 <Igloo> CosmicRay: What do you want to do?
11:39:45 <araujo> how your hacking goes bud?
11:39:54 <Igloo> CosmicRay: It should be buildable as a cabal package
11:40:18 <CosmicRay> Igloo: I want to fix getpwnam/getpwent/etc to actually support the entire API and return everything that the C functions return.
11:41:59 <CosmicRay> Igloo: interesting.  I tried running "make", which gave an error trying to includ some random thing
11:42:09 <CosmicRay> Igloo: I then tried the cabal file, which gave:
11:42:14 <CosmicRay> ./setup configure
11:42:15 <CosmicRay> setup: unix.cabal:42: Unknown field 'install-includes'
11:42:48 <Igloo> Ross changed it to that earlier today, I think. I suspect you need a newer cabal.
11:43:00 <Igloo> Or unpull his patch for testing
11:44:35 <CosmicRay> oh, sure enough.
11:45:31 <Igloo> If you want to get this into 6.6 you'll probably need to move fairly quickly, BTW
11:46:06 <CosmicRay> Igloo: understood.  I originally went to python to write my program because of this, much as it pained me (python's equivolent of getpwent() reads the entire passwd db into ram up-front, ugh)
11:46:18 <CosmicRay> Igloo: then I realized Debian already had /usr/bin/getent that did what I want
11:46:29 <CosmicRay> but I'm still ticked that the Haskell API is incomplete ;-)
11:46:35 <Igloo> :-)
11:46:52 <CosmicRay> Igloo: do you know if anybody has ever added IPv6 to network?
11:47:31 <Igloo> I have a vague feeling I've seen some IPv6 stuff somewhere, but I couldn't tell you where
11:49:23 <Igloo> What is trac going to do if I "accept ticket"?
11:49:59 * musasabi has both IPv6 stuff (network-alt) and some extra unix code for daemons (System-Daemon) ;)
11:50:28 <CosmicRay> musasabi: yes, I know you do.  Have you gotten it integrated into ghc?  I'd use it in a heartbeat if it was on every ghc machine
11:51:00 <musasabi> CosmicRay: that is why there are package managers and cabal-get.
11:51:02 <Igloo> CosmicRay: network is no longer in GHC core, so network-alt is just as good
11:51:56 <musasabi> CosmicRay: as for pushing network-alt instead of Network I want to see what happens to Handles first (and what haskell-prime api looks like)
11:52:33 <CosmicRay> Igloo: so GHC will ship without network support out of the box?
11:53:14 <musasabi> CosmicRay: ghc-core won't include network support, but the tarballs will have network.
11:53:14 <Igloo> CosmicRay: GHC will ship with as little as possible, yes
11:53:32 <CosmicRay> Igloo: ugh, this is going to be a pain for users.
11:53:36 <CosmicRay> err,
11:53:45 <CosmicRay> if what musasabi says is true, then never mind
11:53:45 <Igloo> CosmicRay: Not if you send in those cabal patches  :-)
11:53:50 <CosmicRay> ghc-core is a darcs repo?
11:53:55 <CosmicRay> but not the source tarball?
11:54:07 <Igloo> There are now 2 source tarballs, core and extralibs
11:54:11 <CosmicRay> Igloo: cabal is beyond me at the moment, but I've almost got a System.Posix patch worked up
11:54:15 <CosmicRay> Igloo: ahh.
11:54:20 <CosmicRay> ok, well then I guess it's not all that bad.
11:54:24 <musasabi> on debian there could be ghc6: depends: ghc6.6-core, network, ...
11:55:32 <Igloo> Hmm, I guess I need to decide exactly what packages there should be soon
11:55:42 <vincenz> @seen jyp
11:55:43 <lambdabot> I haven't seen jyp.
12:04:08 <CosmicRay> Igloo: would it be kosher to implement getAllGroupEntries in terms of unsafeInterleaveIO in the libraries?
12:04:16 <CosmicRay> this would have to call getgrent() repeatedly under the hood.
12:05:42 <Igloo> That doesn't look very safe, as a subsequent call would reset the pointer
12:05:57 <ventonegro> hi
12:06:00 <CosmicRay> Igloo: yes, getpwent() is non-reentrant
12:06:15 <ventonegro> i know this is dumb, but i've just started learning haskell
12:06:15 <CosmicRay> I'm not sure what the best workaround that is.
12:06:20 <Igloo> With getgrent_r it would probably be OK
12:06:46 <ventonegro> the tutorials I've read say I can write "data Point = Point a a", but GHC gives me an error
12:07:02 <CosmicRay> Igloo: that is a GNU extension though
12:07:12 <CosmicRay> also:
12:07:14 <ventonegro> is there any GHC option I should use?
12:07:39 <CosmicRay> NOTES
12:07:40 <CosmicRay>        The function getgrent_r() is not really reentrant since it  shares  the
12:07:40 <CosmicRay>        reading position in the stream with all other threads.
12:07:42 <Igloo> ventonegro: data Point a = Point a a
12:08:03 <ventonegro> Igloo: yep, that's it
12:08:03 <Igloo> CosmicRay: That isn't a problem here is it? In fact, it's even necessary with the threaded RTS?
12:08:06 <CosmicRay> Igloo: but I'd still have to use unsafeInterleaveIO, right?
12:08:08 <ventonegro> Igloo: and I get an error
12:08:37 <CosmicRay> Igloo: I don't know.  The interface between Haskell threads and the OS has always been opaque to me.
12:08:52 <Igloo> CosmicRay: Yes, but using it would be safe (or as safe as other bits of lazy IO in teh standard libraries)
12:08:57 <musasabi> CosmicRay: how about: 1) use unsafeInterleaveIO, 2) use a lock, 3) force the evaluation of the blocking lock-holding unsafeInterleaveIO if there is contention
12:09:01 <Igloo> ventonegro: What error?
12:09:22 <musasabi> (that is all of those together)
12:09:24 <ventonegro> <interactive>:1:0: parse error on input `data'
12:09:44 <Igloo> ventonegro: You can't give data declarations interactively. You have ot load them from a file
12:10:00 <ventonegro> oh, I see
12:10:03 <ventonegro> thanks
12:10:39 <CosmicRay> musasabi: I'm not sure I understand your step 3.
12:10:48 <CosmicRay> specifically, the "force the evaluation of" part
12:11:12 <CosmicRay> are you saying that breaking the lock should force the rest of the file to be cached into RAM?
12:11:35 <Igloo> CosmicRay: Re it being a GNU extension, you could do it lazily if you have the extension and strictly otherwise
12:12:07 <lispy> heh, i just figured out a 1 line replacement for a 3 line function i wrote because i started using quickcheck :)
12:13:22 <CosmicRay> Igloo: where are the configure checks for the unix package?  Grep doesn't show any instance of, say, HAVE_GETPWNAM_R except in hsc sources....
12:13:48 <musasabi> make "MVar ()" the lock. 1) when grabbing the lock we fill it with something that seqs the unsafeInterleaveIO that is going to occur. If it is already held then readMVar it and seq then contents and after that try to grab the lock in a blocking manner.
12:13:50 <Cale> "If we would remove every construct in Haskell for which some compiler gives bad error messages, our language would be empty." -- Erik Meijer
12:14:08 <Cale> :)
12:14:13 <vincenz> Cale: Hi!
12:14:15 <Cale> hi!
12:14:22 <vincenz> que pasa
12:14:35 <CosmicRay> Igloo: the trick is that the function exists everywhere but with a different prototype on different systems.
12:14:42 <musasabi> CosmicRay: if the lock would not force evaluation things could easily lead to deadlocks.
12:15:05 <CosmicRay> musasabi: yes, indeed, my concern too.
12:15:28 <musasabi> I can show some code in 5min if you are interested how the lock would work
12:15:37 <CosmicRay> musasabi: yes, that would be nice.
12:16:01 <ndm> Igloo: for the GHC length bug, couldn't you add a transformation rule such that build (length x) => bulid (length_with_foldr x)
12:16:07 <CosmicRay> musasabi: what if someone had read part of the list when a second request came in from a different thread?
12:16:24 <ndm> then length is by default a non-builder, but if the consumer comes along it gets converted
12:17:33 <Igloo> CosmicRay: It comes from configure.ac:AC_CHECK_FUNCS([getgrgid_r getgrnam_r getpwnam_r getpwuid_r getpwnam getpwuid]) I assume
12:18:21 <CosmicRay> Igloo: ahh, so it magically uppercases it, adds the HAVE_ bits, etc?
12:18:48 <Igloo> ndm: I'm not sure I see what you mean
12:19:09 <ndm> build . foldr gets shortcutted
12:19:25 <ndm> length is currently not in terms of foldr, so doesn't get build fused
12:19:45 <Igloo> ndm: length is in terms of foldr, and does get fused
12:19:55 <ndm> but if you make it in terms of foldr, then you overflow sometimes
12:19:56 <Igloo> ndm: But it therefore produces 1+(1+(1+...
12:20:01 <ndm> i mean, currently 6.4.2 :)
12:20:04 <Igloo> OK
12:20:18 <ndm> so you have two options: a foldr length, or a standard one
12:20:20 <ndm> why not have both
12:20:23 <Igloo> CosmicRay: I think so. I'm certainly sure that lots of magic is involved  :-)
12:20:25 <ndm> default to the standard one
12:20:40 <ndm> then build (length x) => build (length_with_foldr x)
12:20:42 <ndm> as a transformation rule
12:20:49 <Igloo> ndm: What is length_with_foldr?
12:20:51 <Cale> hmm
12:20:55 <CosmicRay> Igloo: *black* magic, certainl.
12:21:14 <Cale> unless you're using something like a lazy Nat type for the result, I'd think you'd want to write length with foldl'
12:21:15 <ndm> Igloo: length = length in 6.4.2, length_with_foldr is length in HEAD, defined with foldr
12:21:35 <Igloo> ndm: Then won't build (length_with_foldr x) also produce 1+(1+(1+...?
12:21:52 <ndm> doesn't the build drop the 1+(1+(1+ problem?
12:22:06 <Igloo> Cale: The question is how to write length and some rules such that fusion (deforestation) happens
12:22:08 <ndm> as it consumes the elements one by one
12:22:49 <ndm> i thought the problem in that example was that list isn't being fused
12:22:58 <Cale> Igloo: but surely you can't deforest with length composed on the left, can you?
12:22:59 <Igloo> No, the list does get fused
12:23:07 <Cale> I'd think you'd need to co-opt the ordinary evaluation mechanism with seq in order to be sure not to get overflows.
12:23:17 <musasabi> CosmicRay: it works, just a moment.
12:23:21 <Cale> basically regardless of how you write it
12:23:31 <ndm> ah, i think you may well be right
12:23:51 <Igloo> Cale: It's certainly possible to fuse the two by hand. I don't think you can do anything if you have a build on the right, no
12:24:12 <CosmicRay> musasabi: sweet, thanks.
12:24:18 <ndm> you can do fusion with Seq using hylomorphism's instead of foldr/build
12:24:23 <ndm> but thats not a trivial change at all!
12:24:41 <Igloo> Right, I think something might be possible, but not in 6.6's timescale
12:24:58 <ndm> indeed
12:24:58 <Igloo> The problem isn't so much deforesting length, it's deforesting length while not reforesting everything else
12:25:19 <Igloo> Which probably means changing everything
12:25:25 <ndm> could you write foldr' as a consumer, but not a builder?
12:25:37 <Cale> What's the forest in the case of length? I don't see the large intermediate datastructure.
12:25:47 <Igloo> Cale: The list
12:26:19 <Cale> ah, okay
12:26:52 <Igloo> http://hackage.haskell.org/trac/ghc/ticket/707 and http://hackage.haskell.org/trac/ghc/ticket/876 are the context, if you're interested
12:26:54 <lambdabot> Title: #707 (foldr/build seems to be broken) - GHC - Trac
12:26:54 <Cale> So it's not just length on it's own which you're optimising, it has to be length of something specially produced.
12:27:13 <Igloo> Yes, but lots of the prelude is designed to specially produce stuff using build
12:27:30 <Cale> right
12:27:34 <Cale> okay
12:30:41 <musasabi> CosmicRay: http://youzen.b2.fi/~musasabi/devious-lock.hs
12:31:46 <Cale> yeah, foldr just doesn't seem the right strategy for length, since while you might avoid the construction of the list, you'll end up constructing a call graph which is isomorphic to that list.
12:32:11 <Cale> I wonder if there's a reasonable way to completely do away with stack overflows.
12:33:55 <musasabi> Does anyone have TH based datatype versioning code? Mainly I want to have subtyping relations for suitable changes between versions.
12:36:26 <Cale> After all, the stack size can be changed at execution time -- why not something like a Fibonacci-expanding stack?
12:36:49 <ndm> Yhc has an auto-expanding stack
12:37:48 <musasabi> Cale: OS threads + changing stack sizes can cause problems.
12:38:08 <musasabi> (but that is not a large problem on 64bit archs)
12:38:09 <Cale> musasabi: ah, hmm
12:38:23 <Cale> What happens?
12:39:35 <musasabi> Cale: e.g. there is 2GB of virtual addresses for a problem. Stack must be continuous. mmap needs large continuous address ranges. Pick starting addresses for e.g. 100 thread stacks from that 2gb. Either they are near each other (limiting the size) or they are widely apart (making it impossible to mmap a large file).
12:39:47 <musasabi> s/problem/program
12:40:07 <CosmicRay> musasabi: hmm.  looking at this code, what if the function for the second arg -- that thing that evaluates the whole of a -- messes up with the lazy I/O operation?
12:41:29 <musasabi> CosmicRay: that is just a function like: readFile + length.
12:41:44 <musasabi> i.e. depends on the whole input being read.
12:41:56 <CosmicRay> musasabi: any attempt to run getpwent() -- or setpwent() -- within the same process will interfere with the other
12:42:08 <CosmicRay> musasabi: think of it as a single file position pointer for the whole process.
12:42:16 <musasabi> CosmicRay: thus they share the lock.
12:42:41 <musasabi> CosmicRay: there is a more simplistic approach to this in Network.
12:42:48 <CosmicRay> musasabi: right, but say you're the second thread that tries to get the list of all users.  So the code wants to just evaluate the list for you statically, right?
12:42:49 <Cale> musasabi: ah, hmm... and presumably most attempts to do away with continuity would result in slowing things down
12:42:59 <CosmicRay> musasabi: but to do that, you interfere with what's going on in the first thread.
12:44:06 <musasabi> The problem is code like this: do users <- getAllUsers; flip mapM_ users $ \user -> doSomeOpNeedingTheLock user
12:44:21 <emu> is there a function which extracts the nth member of a tuple
12:44:39 <musasabi> Thus the evaluation needs to be kicked in some places.
12:44:41 <CosmicRay> musasabi: yes, that would be an issue too.
12:44:44 <Cale> emu: What would its type be? :)
12:44:55 <emu> Cale: i realize; but SML has special ops to do this
12:45:00 <emu> just wondering
12:45:10 <vincenz> emu: you can to it with template haskell
12:45:12 <Cale> emu: Well, you can construct such a thing with template haskell
12:45:18 * vincenz beeps Cale 
12:45:21 <Cale> but it's not exactly pretty
12:45:27 <vincenz> DrIFT?
12:45:34 <emu> yea it would have to construct a function with \(...,x,...) -> x or something
12:45:42 <Cale> right
12:45:47 <vincenz> emu: but with extra _
12:45:48 <emu> no big deal just was wondering offhand
12:45:58 <CosmicRay> maybe I should just submit a strict version and let the knowledgable hackers fix it later
12:46:05 <CosmicRay> it wouldn't be any worse than python, at least
12:47:51 <Lemmih> CosmicRay: Hi!
12:48:03 <CosmicRay> hey lemmih
12:48:35 <Lemmih> CosmicRay: Do you have a darcs repo for hdbc?
12:49:07 <CosmicRay> Lemmih: yes, several.  See the list at http://darcs.complete.org/
12:49:09 <lambdabot> Title: Darcs repositories on complete.org
12:51:17 <CosmicRay> Lemmih: does that answer your question?
12:51:24 <Lemmih> Great. I've extended hdbc-postgresql with prepared queries and support for binary data.
12:51:30 <CosmicRay> Lemmih: all of them should be darcs send-capable btw.
12:51:33 <CosmicRay> sweet.
12:51:42 <CosmicRay> err, it should support prepared queries out of the box
12:51:53 <CosmicRay> ahh, or maybe not.
12:52:03 <CosmicRay> the infrastructure it there with the '?' placeholder anyway
12:52:10 <CosmicRay> but I may not have actually implemented it in the backend.
12:52:18 <CosmicRay> anyway, send away ;-)
12:52:38 <Lemmih> It was left as a FIXME in hdbc-postgresql-1.0.0.0.
12:52:44 <CosmicRay> ah.
12:52:54 <CosmicRay> that does sound right.  it's been a bit since I hacked on that.
12:52:59 <CosmicRay> THANKS for writing it!
12:58:03 <Lemmih> No problem. I'll send you the code tomorrow.
12:58:09 * Lemmih heads to bed.
13:02:14 <syntaxfree> I'm rereading the Gentle Introduction to  Haskell.
13:02:29 <syntaxfree> It's actually interesting how it's structured, it's just plagued with bad examples. And pseudocode!
13:02:55 <syntaxfree> It should be improved upon, by someone with the necessary clout.
13:03:43 <ventonegro> i'm trying to learn from it right now
13:04:15 <syntaxfree> I gave up Haskell when I first encountered the Gentle Introduction.
13:04:33 <syntaxfree> If you're having problems understanding it, I recomend Hal Daume's "Yet Another Haskell Tutorial".
13:04:41 <jeroenp> Where can one find this gentle introduction?
13:04:42 <syntaxfree> @google htut
13:04:47 <lambdabot> http://www.prospectburma.org/index.php?option=com_content&task=view&id=47&Itemid=40
13:04:47 <lambdabot> Title: Nay Htut: With A Bit of Help from His Friends - Prospect Burma
13:04:54 <syntaxfree> @google yaht
13:04:57 <lambdabot> http://www.tradekey.com/ks-yaht/
13:04:57 <lambdabot> Title: yaht - Offers for yaht - exporters, manufacturers, suppliers, wholesale, Traders ...
13:05:01 <syntaxfree> oh god.
13:05:22 <syntaxfree> well, you can find the Gentle Introduction and Yet Another Haskell Tutorial at www.haskell.org
13:05:29 <syntaxfree> @google yet another haskell tutorial
13:05:31 <lambdabot> http://www.cs.utah.edu/~hal/htut/tutorial.pdf
13:05:41 <syntaxfree> @google gentle introduction to haskell
13:05:44 <lambdabot> http://www.haskell.org/tutorial/
13:05:45 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
13:05:58 <ventonegro> is the lambdabot written in haskell? :-)
13:06:27 <ventonegro> actually, i think i'm understanding pretty much all i'm reading
13:06:32 <syntaxfree> that's more like it :)
13:06:50 <syntaxfree> yes, it is.
13:06:56 <syntaxfree> dons wrote it.
13:07:11 <syntaxfree> He's here all the time. The place is full of teh Haskell celebs :)
13:07:42 <jeroenp> Why not reading one of the million syllabi out there concerning functional programming in Haskell?
13:09:19 <SamB> dons had a lot of help, thanks to the plugin system ;-)
13:09:24 <SamB> which he also wrote...
13:09:33 <beelsebob> haha
13:09:58 <SamB> meaning that a lot of people have written plugins to do various things
13:10:35 <SamB> apparantly I've written two of them, though I had forgotten the second until dons showed me proof...
13:12:15 <syntaxfree> there is a pdf somewhere out there with most of the Haskell prelude defined in Haskell.
13:12:30 <syntaxfree> I wish there was more of it for other libraries.
13:12:42 <ventonegro> prelude == C++'s STL?
13:13:04 <syntaxfree> Prelude is what's available to GHCi/Hugs before you import other libraries.
13:13:14 <ventonegro> ok
13:13:15 <syntaxfree> I don't know C++, so.
13:13:28 <syntaxfree> like, "head", "tail", etc. are defined in the prelude.
13:13:40 <syntaxfree> are you using ghci or hugs?
13:13:46 <ventonegro> ghci
13:13:55 <SamB> it doesn't have as many data types as STL
13:13:58 <SamB> only the linked list
13:14:02 <SamB> and the tuples
13:14:07 <syntaxfree> in ghci, you can trype :browse Prelude and see what's there.
13:14:13 <jeroenp> But you don't need as many :-)
13:14:14 <ventonegro> cool
13:14:20 <syntaxfree> s/trype/type.
13:14:27 <jrmole> http://undergraduate.csse.uwa.edu.au/units/230.301/lectureNotes/tourofprelude.html
13:14:28 <lambdabot> Title: A Tour of the Haskell Prelude
13:14:38 <SamB> if you want, say, the binary tree, you need to import it from somewhere
13:14:47 <syntaxfree> The Prelude also defines the essential type classes as well.
13:15:01 <syntaxfree> rose trees are defined in Data.Tree. I forget where binary trees are.
13:15:24 <ventonegro> wow, lots of symbols
13:15:26 <SamB> syntaxfree: Data.Map ;-)
13:15:52 <syntaxfree> in your Haskell code, you say "import Data.Map".
13:16:01 <SamB> ... nevermind that the interface doesn't specify that they are binary trees...
13:16:24 <syntaxfree> in ghci, you say :module + Data.Map  to load it, or :browse Data.Map to see what's defined there.
13:17:14 <musasabi> What is the status of the cabal->debian package stuff?
13:17:25 <ventonegro> thanks, ppl
13:17:30 <ventonegro> good night
13:17:35 <SamB> musasabi: there is such stuff already?
13:17:43 <musasabi> SamB: at least some.
13:18:10 <SamB> ... I'm guessing it isn't a standard debhelper package ;-)
13:18:37 <musasabi> CosmicRay: ping
13:19:18 * musasabi just wants an automatic "take metainformation from *.cabal and create the deb"
13:19:18 <syntaxfree> @ping
13:19:20 <lambdabot> parse error (possibly incorrect indentation)
13:19:54 <SamB> cabal-alien?
13:20:11 <lispy> hmm...anyone have an example of how to get cabal to run your quickchecks?
13:20:13 * SamB is just throwing out a name
13:20:23 <syntaxfree> oh.
13:21:21 <syntaxfree> "In general, given that x has type t1 and exp has type t2, then \x->exp has type t1->t2". Well, obvious, of course, but does
13:21:33 <syntaxfree> \ :: t1->t2->(t1->t2)
13:21:35 <syntaxfree> make any sense?
13:22:59 <jeroenp> It doesn't to me, syntaxfree
13:23:06 <SamB> no!
13:23:10 <SamB> for it is bad syntax
13:23:23 <syntaxfree> I mean, does it make any sense to say lambda has a type?
13:23:23 <SamB> you have to put variables and an arrow after the \ at some point...
13:23:31 <SamB> no, lambda doesn't have a type!
13:23:41 <syntaxfree> heh. okay, okay.
13:24:36 <SamB> you can of course write some typing judgements about lambdas
13:24:52 <jeroenp> syntaxfree: for fun you should read about type-free lamba calculus and curry-type-inference
13:25:00 <SamB> (probably you'd want to normalize them first)
13:25:03 <jeroenp> And when you make sense out of it, notify me
13:25:35 <syntaxfree> Yes, I need some better theoretical CS at some point.
13:25:43 <syntaxfree> Recall I have no CS background whatsoever.
13:28:28 <lispy> man, cabal really needs a bigger manual
13:28:36 <jeroenp> What background do you have, syntaxfree?
13:28:55 <syntaxfree> I'm an economist.
13:28:59 <syntaxfree> In grad school right now.
13:29:02 <lispy> i see runTests :: (Args -> Bool -> PackageDescription -> LocalBuildInfo -> IO ExitCode) in the cabal manual, but i have no idea how i want to use it
13:29:31 <jeroenp> How did you get there?
13:30:09 <syntaxfree> I was afraid of mathematics in high school.
13:30:19 <syntaxfree> So I went to film studies, actually.
13:30:40 <syntaxfree> I'd programmed somev
13:30:55 <syntaxfree> er, some stuff as a ten-year-old in Basic or something.
13:31:08 <jeroenp> If you're afraid of mathematics, there's  no need to escape from cs though, not that much math there at most colleges
13:31:31 <syntaxfree> So I was in film school, and my engineering roommates kept on asking me questions about their programming assignments, and I knew how to do them.
13:31:48 <syntaxfree> But since I was afraid of maths, I took economics, something in the middle of the road.
13:32:10 <syntaxfree> Economics turned out to be a lot lot more mathematical than I'd ever dream of, and I found great joy in mathematics.
13:32:27 <syntaxfree> At some point, I was applying for graduate school in mathematics. Maybe shapr remembers that time.
13:32:50 <syntaxfree> Anyway, I'm near my Masters right now, and will prolly get a job for a few years before going for a PhD.
13:33:15 <syntaxfree> Maybe computer programming was my true call and all, but I enjoy economics enough to keep doing what I'm already doing.
13:34:03 <musasabi> Given a TyCon is it possible to obtain the corresponding TypeRep ?
13:34:28 <Oejet> syntaxfree: I suppose you are good at programming compared to your peers?
13:34:29 <SamB> are you going to make that Enron joke a reality?
13:34:37 <SamB> @google haskell enron
13:34:40 <lambdabot> http://www.haskell.org/haskellwiki/Humor/Enron
13:34:40 <lambdabot> Title: Humor/Enron - HaskellWiki
13:35:18 <syntaxfree> My peers are programming-averse enough to use the point-and-click statistics package as opposed to hacking up GNU R routines that'll save them hours of work.
13:35:39 <SamB> *POINT AND CLICK*!!?!??!?!?!?!?!??!
13:35:45 * SamB recoils in horror!!!!!
13:36:09 <syntaxfree> I am interested enough in functional programming to study  substantial theoretical material on it, though.
13:36:32 <jeroenp> syntaxfree: I know that feeling, did one course and want to know all
13:37:08 <syntaxfree> I've superficially read a few papers, and as I progress with Haskell I reread them and understand more.
13:37:56 <syntaxfree> I think computer programming is my true calling,  but it's too late to drop everything and enroll in some CS undergrad program by now. Not to mention it'd be boooring.
13:38:17 <jeroenp> How old are you then?
13:38:54 <SamB> yah. I think CS undergrad is probably boring too!
13:38:57 <syntaxfree> 24.
13:39:20 <vincenz> syntaxfree: what do you do
13:39:25 <syntaxfree> I'm an economist.
13:39:32 <syntaxfree> NOT AN ACCOUNTANT!
13:39:34 <syntaxfree> :-P
13:40:11 <jrmole> i actually know a couple undergrad students in economics who use haskell
13:40:11 <jeroenp> syntaxfree, you could probably cure that
13:40:23 <jrmole> CS undergrad isn't boring if you pick the right school
13:40:31 <jrmole> but most places it will be "introduction to programming hello world in java"
13:40:38 * syntaxfree should have mentioned he's in Brazil.
13:40:49 <vincenz> Coba cabana
13:40:59 <jrmole> mm, i have no idea how higher education works there
13:41:15 <syntaxfree> I have a friend in the CS department. Says most of his program is Prolog.
13:41:28 <jeroenp> Prolog?
13:41:35 <jrmole> prolog is a neat language
13:41:40 <jeroenp> It is?
13:41:45 <SamB> better than Java!
13:41:47 <syntaxfree> Economics is an interesting case here. Some schools are very very mathematical in orientation, and some will teach almost no mathematical economics at all.
13:42:00 <syntaxfree> anyway, he's doing lots of graph theory,  as well.
13:42:06 <jrmole> SamB: not for most things
13:42:15 <syntaxfree> Seems like a quite theoretical course, but somewhat apart from what interests me.
13:42:27 <SamB> jrmole: well, I think it would be more fun to do prology things than to do java-y things
13:42:35 <vincenz> SamB: everything besides perl and c are better than java
13:42:35 <syntaxfree> A lot of compiler stuff too.
13:42:36 <jrmole> i go to Caltech, where economics is basically applied mathematics only you call the function you're optimizing "money" or something
13:42:41 <vincenz> s/are/is
13:42:47 <jrmole> syntaxfree, what interests you in CS?
13:42:51 <jeroenp> SamB: it would me more fun to chop of your hand than do java, it's a bad comparison
13:42:54 <vincenz> jrmole: and the function pareto-optimal
13:42:55 <jrmole> vincenz, C++?
13:42:56 <SamB> vincenz: why make an exception for perl?
13:43:09 <vincenz> SamB: *SHUDDER*
13:43:20 <SamB> and chopping off my hand wouldn't be fun for long...
13:43:22 <jrmole> C++ and C suffer from the same terrifying flaw, namely lack of automatic memory management
13:43:24 <syntaxfree> I'm interested, uh, in functional programming, and type theory for what I've seen of it.
13:43:36 <jeroenp> jrmole: do D
13:43:36 <vincenz> jrmole: templates help a bit for c++
13:43:36 <jrmole> and people are smart enough not to write applications software in C anymore, but they haven't quite learned that for C++
13:43:56 <jrmole> i'm glad that C# and Java are taking over from C++... people are learning to shoot themselves in the foot on slightly higher levels
13:44:25 <syntaxfree> I think it was Philip Greenspun that claimed Java has managed to take C programmers halfway to Lisp.
13:44:29 <vincenz> jrmole: I disagree, either make a truly clean language, or leave it as it is, with a lot of crap to hack with, like template and operator meta-hell :D
13:44:47 <jrmole> hehe
13:44:58 <jrmole> well, this is why C and haskell are the two languages i use these days
13:45:07 <jrmole> syntaxfree, i'm sure people here (myself included) can recommend many books and papers in those areas
13:45:11 <vincenz> yeah but C doesn't have enough hell t it :/
13:45:13 <jrmole> many of which i'm sure you're aware of
13:45:14 <vincenz> just annoyingness
13:45:19 <jrmole> in C you get to write your own hell
13:45:28 <vincenz> not on the meta-level
13:45:34 <vincenz> it's just copy-paste
13:45:38 <jrmole> this is CS, the level is the meta-level ;)
13:45:47 <jrmole> okay, what about macros?
13:45:55 <vincenz> not powerful enough :/
13:46:01 <vincenz> except to do some lexical trickery
13:46:04 <jrmole> they're turing complete, no?
13:46:10 <jrmole> ;)
13:46:14 <vincenz> don't think so
13:46:22 <SamB> ... not in C!
13:46:29 <jeroenp> jrmole: a turing machine is turing complete, I don't see you programming in those
13:46:30 <SamB> templates are though
13:46:33 <jrmole> http://www0.us.ioccc.org/1995/vanschnitz.c
13:46:36 <vincenz> hmm
13:46:44 <vincenz> anyone ever implement a scheme-interpreter?
13:46:49 <jrmole> of course not, but if i wanted to construct my own hell as vincenz was suggesting, i'm sure this would be a component of it
13:47:05 <jrmole> in C preprocessor?
13:47:12 <vincenz> no
13:47:30 <vincenz> in scheme, preferably a compiler to some bytecode
13:47:52 <SamB> jrmole: hmm
13:47:55 <SamB> recursion...
13:48:02 <jrmole> vincenz, http://mitpress.mit.edu/sicp/full-text/book/book.html
13:48:03 <lambdabot> Title: Structure and Interpretation of Computer Programs
13:48:07 <SamB> but does it have lexical or dynamic scope?
13:48:27 <vincenz> jrmole: does it do macros?
13:48:27 <jrmole> looks like for CPP to be turing complete, you need to run the preprocessor an arbitrary number of times
13:48:35 <jrmole> vincenz, i don't think so
13:49:00 <vincenz> I'd prefer a full r5rs thingy
13:49:00 <jrmole> the interpreters / compilers in SICP are very simple and didactic in nature
13:49:06 <jrmole> there's plenty of r5rs implementations
13:49:22 <vincenz> the idea being that you write a scheme->bytecode in scheme...and then write a mini-bytecode engine that you compile for many platforms
13:49:29 <vincenz> small being key
13:49:39 <vincenz> and build in some networking stuff :)
13:50:12 <jrmole> fun
13:50:22 <jrmole> well it shouldn't be hard to write a scheme-to-bytecode compiler
13:50:27 <jrmole> in fact i'll be doing it for a class this year
13:50:34 <jrmole> though i think i'll write the compiler in haskell
13:50:45 <vincenz> including macros?
13:50:53 <vincenz> I think the macro bit is the complicated part
13:51:00 <vincenz> the rest is yeah, rather trivial
13:51:12 <syntaxfree> wow. as-patterns are still as uncompreehensible as they were when i first looked at them.
13:51:21 <vincenz> except maybe continuations, unless you don't write a compiler and just use a continuation monad in haskell
13:51:27 <jrmole> don't know about macros
13:51:28 <syntaxfree> The text even  claims they "improve readability". Hahaha.
13:51:36 <SamB> syntaxfree: as patterns?
13:51:43 <jrmole> it is a compiler, but i don't know if we have to implement call/cc
13:51:45 <vincenz> jrmole: though I'm not sure it's trivial to write an actual compiler that maps to some sort of stack machine or regster machine
13:51:47 <syntaxfree> like,
13:51:49 <jrmole> can't you refactor to CPS in all cases?
13:52:03 <jrmole> vincenz, we target the O'Caml VM
13:52:07 <syntaxfree> > let f s@(x:xs) = x:s  in f "Hey"
13:52:08 <lambdabot>  "HHey"
13:52:09 <vincenz> ah
13:52:13 <jrmole> as for an actual register machine, SICP has an example
13:52:23 <vincenz> jrmole: what kind of vm is ocaml's?
13:52:26 <jrmole> no idea
13:52:33 <jrmole> i think it's pretty functional
13:52:45 <syntaxfree> that's equivalent to f (x:xs) = x:x:xs
13:53:43 <vincenz> jrmole: I know some guy that did it for a subset of scheme (he doesn't support full numeric towre ... and some other small bits)...and it's really small, has statically linked network protocols and it's used for trying out different 0-day attacks by having many of these little machines in place, so it's easy to extend them (instead of writing some kind of virus once and uploading it)
13:53:46 <psi> it simply gives the whole pattern a name. I don't see the problem.
13:54:00 <vincenz> not that I plan on hacking, but the concept sounded neat, little machines everywhere that are easily reprogrammable
13:54:04 <jrmole> wow, nice
13:54:38 <jrmole> the pattern n@p is the same as the pattern p, except it additionally binds the name n to the entire value matched by p
13:54:53 <vincenz> n@pster for instance
13:54:55 <syntaxfree> I know. But to say that it improves readability..
13:55:03 <jrmole> it avoids duplicating terms
13:55:17 <jrmole> in this case x:xs, which is not a big deal
13:55:43 <jrmole> but say you're performing case analysis on some large record type, and then want the entire record so you can use record update syntax
13:55:57 <vincenz> syntaxfree: it doesn't, however it does ensure performance, especially if you're constantly matching tuples
13:56:06 <vincenz> otherwise the compiler must constantly build new ones and reclaim the old ones
13:57:11 <syntaxfree> if you're going as far as having patterns that bind names for the right side of an equation, maybe you should go as far as having first-class patterns with semantics that can be specified in Haskell!
13:57:30 <vincenz> I don't think that'd be typeabl
13:57:52 <jrmole> it would be horrible to compile
13:58:07 <jrmole> and the point of any pattern is to bind names to the RHS
13:58:14 <vincenz> yeah
13:58:16 <jrmole> it's no worse than > f x = x
13:58:17 <vincenz> meaning you'd get dynamic scopign
13:58:22 <jrmole> which binds x for the RHS ;)
13:58:24 <psi> it's convenient if you have a large data type, e.g., f foo@(Foo a b c d e) = ...
13:59:05 <jrmole> or i should say , the point of any pattern which contains variable names
13:59:45 <syntaxfree> there should be a contest for obfuscated haskell code.
14:00:03 <vincenz> hah
14:00:09 <vincenz> haskell can't be obfuscated
14:00:13 <vincenz> just ask the type of the funciton :)
14:00:19 <syntaxfree> ;)
14:00:31 <jrmole> syntaxfree, there is one
14:00:41 <jrmole> or has been a few times
14:00:59 <jrmole> http://haskell.org/haskellwiki/Obfuscation
14:01:00 <lambdabot> Title: Obfuscation - HaskellWiki
14:01:49 <lament> eh, i thought _all_ haskell was obfuscated?
14:02:06 <syntaxfree> well, I guess boolean guards are first-class paterns of some sort.
14:02:11 <vincenz> jrmole: http://www.ephemeralsecurity.com/mosquito-lisp
14:02:26 <jrmole> guards are not patterns
14:02:34 <jrmole> they desugar into the expression part of a case, not the pattern part
14:03:56 <vincenz> http://www.ephemeralsecurity.com/demos/
14:04:03 <jrmole> cool stuff
14:04:16 <jrmole> also ion3 ;)
14:04:16 <vincenz> great for SETI-style stuff
14:04:20 <vincenz> just distribute the client
14:06:26 <vincenz> what is ion3?
14:07:41 <syntaxfree> ion3 is this ubercool window manager.
14:07:58 <vincenz> ubercool is an uberuncool word
14:09:47 <vincenz> Anyways, jrmole join #oasis
14:09:55 <jrmole> it's a GUI for people who prefer CLI's ;)
14:10:06 <jrmole> or generally would rather do things with strange three-modifier-key commands or bits of lua code than click on a bunch of glossy icons
14:10:22 <syntaxfree> rlwrap is cool.
14:10:43 <syntaxfree> Lua was developed at my university.
14:12:33 <syntaxfree> > take 0 bot
14:12:34 <lambdabot>  Not in scope: `bot'
14:12:49 <vincenz> > take 0 undefined
14:12:50 <lambdabot>  Add a type signature
14:12:55 <vincenz> > take 0 undefined :: [Int]
14:12:56 <lambdabot>  []
14:13:16 <vincenz> @users
14:13:18 <lambdabot> Maximum users seen in #haskell: 235, currently: 198 (84.3%), active: 22 (9.4%)
14:13:25 <syntaxfree> > take undefined::Int []
14:13:26 <lambdabot>    Kind error: `Int' is applied to too many type arguments
14:13:26 <lambdabot>   In the type ...
14:13:28 <vincenz> > return "cookie" >>= replicate 198
14:13:29 <lambdabot>  ["cookie","cookie","cookie","cookie","cookie","cookie","cookie","cookie","co...
14:13:41 <vincenz> syntaxfree: wrap it
14:13:50 <vincenz> > take (undefined::Int) []
14:13:51 <lambdabot>  Add a type signature
14:13:56 <vincenz> though it shouldn't be necessary
14:13:59 <vincenz> > take undefined [] :: [Int]
14:14:01 <lambdabot>  Undefined
14:15:10 <syntaxfree> ok :)
14:16:19 <syntaxfree> the Gentle Introduction spends a lot of time on patterns. I never really thought of them as that important.
14:41:13 <SyntaxNinja> @seen bringert
14:41:14 <lambdabot> I saw bringert leaving #haskell.se and #haskell 2 hours and 44 seconds ago, and .
14:41:18 <SyntaxNinja> @seen shapr
14:41:19 <lambdabot> I saw shapr leaving #haskell and #ScannedInAvian 12 days, 2 hours and 58 minutes ago, and .
14:51:47 <syntaxfree> I don't understand the difference between type and newtype.
14:52:03 <syntaxfree> oh, forget about it, I do.
14:52:14 <Cale> hehe
14:52:27 <SyntaxNinja> 16 seconds, not bad.
14:53:04 <Cale> Yeah, newtype actually gives you a properly new type in the type system, along with a data constructor and proper type checking, whereas type just gives another name for an existing type.
14:55:04 <syntaxfree> well, what's the difference between type and data, then?
14:55:08 <syntaxfree> er, newtype and data.
14:59:39 <jrmole> newtype is restricted to one constructor
14:59:49 <jrmole> no | allowed
15:00:07 <jrmole> and is implemented the same way as type, after typechecking
15:00:13 <jrmole> i.e. has no boxing / unboxing instructions
15:00:22 <syntaxfree> what are boxing instructions?
15:04:13 <vincenz> []
15:04:29 <norpan> uppercut
15:05:07 <Cale> syntaxfree: Values in Haskell are boxed in the sense that they are represented by pointers to code which when executed will produce the desired value.
15:05:33 <Cale> When the code runs once, it updates the pointer to a piece of code which returns the result directly.
15:06:14 <syntaxfree> @type sequence
15:06:16 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
15:07:26 <Cale> Saying that a value is unboxed means that this level of indirection is missing. Of course, interacting with unboxed values has to be handled differently, so there are effects regarding polymorphism there, but in this case, you're likely just wrapping another boxed value -- values of the newtype will just be completely the same in memory as the values of the original type.
15:08:11 <syntaxfree> hmm.
15:08:31 <lispy> i need some help with some TH
15:09:20 <lispy> i wrote a function which takes a string and generates something like, putStr s >> quickCheck s
15:09:49 <lispy> well, putStr "s: " >> quickCheck s is more accurate
15:10:02 <lispy> called this mkCheck
15:10:06 <lispy> i put mkCheck in one module
15:10:12 <lispy> then i'm trying to use it somewhere else
15:10:41 <lispy> and I say, $(mkCheck "prop_lrotateId1") and I get an error that prop_lrotateId1 is not in scope (even though it should be)
15:24:25 <LordBrain> haskell.org down again?
15:30:23 <SamB> http://haskell.org
15:30:25 <lambdabot> Title: Haskell - HaskellWiki
15:30:34 <SamB> ... no!
15:36:17 <norpan> hey, this channel is on 24 hours a day
15:38:03 <vincenz> norpan: no, 25 hours
15:38:06 <vincenz> shapr makes up an extra hour
15:38:56 <norpan> does he indeed
15:39:14 <vincenz> true, you're right
15:39:15 <vincenz> 2 hours
15:39:17 <vincenz> so 26 it is
15:40:52 <ndm> @seen shapr
15:40:52 <lambdabot> I saw shapr leaving #haskell and #ScannedInAvian 12 days, 3 hours, 57 minutes and 32 seconds ago, and .
15:41:00 <ndm> we're down to 24 hours a day now :(
15:41:11 <vincenz> damn
15:41:24 <vincenz> fortunately it doesn't work in retrospect
15:41:24 <vincenz> or
15:41:28 <vincenz> or today would be 0 hours
15:41:34 <vincenz> negative shaprhours
15:41:39 <tieTYT> why isn't :t (+)'s type this: (+) :: Num a -> Num a -> Num a
15:42:05 <tieTYT> is this different from (Num a) => a -> a -> a?
15:42:29 <eivuokko> Yes, Num is a class, not type constructor.
15:43:05 <tieTYT> ok when i say data Tuple a b c d = ...
15:43:10 <tieTYT> is the lhs a class?
15:43:38 <vincenz> nope
15:43:46 <vincenz> it's a type constructor
15:43:58 <eivuokko> No.  data Foo a b = Bar a b;  Foo is a type constructor, Bar is data constructor, and Foo Int Int is a type (via applied type constructor).
15:43:59 <tieTYT> ok interesting
15:44:03 <dons> ?yow!
15:44:03 <lambdabot> What a COINCIDENCE!  I'm an authorized "SNOOTS OF THE STARS" dealer!!
15:44:08 <tieTYT> java background here, i figured all datatypes were classes
15:44:24 <eivuokko> class Baz a where baz :: a -> a;  Baz is a class, that has operation baz that is like identity
15:44:46 <vincenz> tieTYT: classes are more like interfaces in java
15:44:51 <vincenz> type classes that is
15:44:57 <vincenz> they specify a set of operations
15:45:08 <vincenz> and then you can 'instance' that class for a specific 'type'
15:45:10 <tieTYT> ok so the lhs is a type constructor.  what's the rhs?
15:45:17 <vincenz> data constructor
15:45:31 <vincenz> it applies to values (data)
15:45:32 <tieTYT> type constructor and data constructor.. hmm
15:45:35 <vincenz> type constructors apply to types
15:45:42 <vincenz> for instance
15:45:47 <vincenz> data Foo a b = Bar a b
15:45:52 <vincenz> Bar 1 2 :: Foo Int Int
15:46:02 <vincenz> erm well not quite
15:46:07 <vincenz> Bar "1" "2" :: Foo String String
15:46:18 <vincenz> you could also say
15:46:23 <vincenz> data Foo = Bar String String
15:46:27 <vincenz> but then you could only have Foo's of strings
15:46:49 <tieTYT> so data Foo a b = Bar a b makes Foo more generic
15:46:53 <tieTYT> you can have a Foo of any type that way
15:47:17 <vincenz> right
15:47:19 <tieTYT> my use of the word "type" doesn't seem right in haskell land
15:47:25 <vincenz> but!
15:47:29 <tieTYT> was that sentence correct?
15:47:36 <vincenz> you can't just use a (Foo Int Int) in a place that requires a (Foo String String)
15:47:56 <vincenz> well I was a bit abusive with terminology as well
15:48:01 <vincenz> in the Foo a b case, Foo is a type constructor
15:48:10 <vincenz> that when applied to two types, gives a specific type
15:48:18 <vincenz> in the second case, Foo is just a specific type
15:48:21 <tieTYT> wait
15:48:23 <vincenz> namely some record containing two strings
15:48:33 <tieTYT> ok nm i gotcha
15:49:11 <tieTYT> ok so i figure, i just don't know how to make class's yet
15:49:27 <vincenz> well most interesting classes exist already
15:49:35 <vincenz> I doubt you need classes if you're still learning haskell
15:49:40 <vincenz> classes specify interfaces
15:49:44 <vincenz> for instance class Eq
15:49:48 <vincenz> specifies the == and != operations
15:49:54 <vincenz> you can then for instance say
15:50:08 <vincenz> instance Eq Int where .... x == y = nativeCompareInteger x y
15:50:15 <vincenz> well it's not exactly that but it gives you the idea
15:50:26 <vincenz> or you could say
15:50:31 <vincenz> instance Eq a => Eq [a] where ...
15:50:31 <tieTYT> i haven't learned the instance keyword yet
15:50:49 <vincenz> if a type 'a' has an instance, we can define an instance for lists of of 'a' that is also an instance of the "class Eq"
15:51:06 <vincenz> tieTYT: well class in haskell are interfaces, instances define the specific imiplementation for a given type
15:51:32 <vincenz> if you just want something to hold data
15:51:36 <vincenz> you don't need classes
15:51:38 <vincenz> but data-types
15:51:50 <vincenz> aka 'data Foo a b = Bar a b'
15:51:53 <vincenz> or
15:51:59 <vincenz> data Either a b = Left a | Right b
15:53:36 <tieTYT> ok well if i have a function that returns an Either and a function a function that takes an Either as an argument how do i use that?
15:54:02 <tieTYT> am i supposed to use pattern matching: takeEither (Left a) = ...something...
15:54:11 <tieTYT> takeEither (Right b) = ...something...
15:54:17 <vincenz> yep
15:54:23 <tieTYT> ok
15:54:45 <tieTYT> i notice the interpreter seems to force me to use data constructors (as opposed to type constructors) as arguments
15:55:00 <vincenz> well yes
15:55:04 <vincenz> the function takeEither has
15:55:12 <vincenz> forall a b. Either a b -> Something
15:55:24 <vincenz> so on the type level, the type constructor is used
15:55:32 <vincenz> but in the code, you're dealing with values, data, hence data-constructors
15:55:46 <tieTYT> interesting
15:56:05 <vincenz> a more concrete case
15:56:07 <tieTYT> that makes sense (but i have to use a little handwaving.  I'll probably understand it completely by tonight
15:56:10 <vincenz> data FooBar = Foo Int | Bar String
15:56:14 <vincenz> Foo 1 :: FooBar
15:56:18 <vincenz> Bar "x" :: FooBar
15:56:55 <vincenz> with typeconsructors
15:56:59 <vincenz> data FooBar a = Foo a | Bar String
15:57:09 <vincenz> Foo "1" :: FooBar String
15:57:16 <vincenz> Bar "1" :: FooBar ...???
15:57:23 <vincenz> it won't know cause it can't infer the 'a'
15:57:31 <tieTYT> so that's an error?
15:57:41 <tieTYT> ok
15:57:43 <vincenz> ewll if you give it to a function that expects a FooBar String
15:57:46 <vincenz> it's not an error
15:57:49 <vincenz> it'll know
15:57:56 <vincenz> in general there's enough context to determne the proper type
15:58:01 <tieTYT> i have another question http://paste-bin.com/212
15:58:10 <tieTYT> is there a less verbose way to define tuple1?
15:58:27 <vincenz> nope
15:58:30 <vincenz> tho...
15:58:35 <vincenz> what is that datatype for?
16:00:30 <tieTYT> heh i donno
16:00:35 <tieTYT> it's just an exercise in YAHT
16:01:10 <dons> in practice you don't write such code. it's just an exercise :)
16:01:26 <vincenz> @karma+ dons
16:01:27 <lambdabot> dons's karma raised to 54.
16:01:40 * vincenz whistles
16:01:45 <dons> Igloo: I agree with the build/foldr issue. It's bitten me a couple of times in the head -- we should revert it and fix it some other way
16:01:50 <dons> vincenz: what's that karma for?
16:01:57 <dons> and how was Sardinnia?
16:02:05 <vincenz> it could be better
16:02:09 <dons> ?spell Sardinnia
16:02:09 <lambdabot> Sardinia Sardining Sardine Sidonia Sardinia's
16:02:10 <vincenz> weather wasn't great first week
16:02:12 <vincenz> Sardinia
16:02:23 <vincenz> and myp lane back was retarded and retarded by 6 hours
16:02:29 <dons> oh, that's a pity.
16:02:39 <dons> did you get out to the beach though?
16:03:22 <vincenz> yep :)
16:03:29 <vincenz> second week there was 120 kmh winds :)
16:03:32 <dons> heh
16:03:33 <vincenz> great for having some waves
16:04:08 <vincenz> tho ... yeah.... the beach where I went to bodyboard
16:04:11 <vincenz> -full- of jellyfish
16:04:15 <vincenz> the entire beach was covered
16:04:21 <vincenz> from the stream, waves, and wind
16:04:25 <dons> wow
16:04:40 <vincenz> yeah
16:04:43 <vincenz> still itches
16:05:07 <dons> :S
16:05:14 <ndm> did you pee on yourself?
16:05:18 <vincenz> fortunately only got stung twice
16:05:33 <dons> ndm, I thought you were supposed to use vinegar?
16:05:54 <dons> (at least, they have vinegar bottles on beaches in queensland for this purpose)
16:05:59 <ndm> dons: alegedly both work, but that may be urban myth
16:06:05 <dons> maybe
16:06:07 <vincenz> vinegar yeah
16:06:13 <ndm> the number of jellyfish in england is pretty low :)
16:06:44 <vincenz> oh yeah
16:06:46 <vincenz> on the plane back
16:06:51 <vincenz> we had a little screen showing info
16:06:53 <vincenz> 160km/h winds
16:07:09 <dons> hehe. I think I'd still try the vinegar if some irukandji jellyfish had a go a me.
16:07:13 <dons> cool ;)
16:07:13 <SamB> ... so increasing the acidity of the effected area is supposed to help with jellyfish stings?
16:07:38 <ndm> SamB: all strings are either acid or alkali - vinegar or bicarb of soda will fix all of them
16:07:49 <ndm> wasp = vinegar, bee = bicarb of soda
16:07:55 <dons> except for the poison ones...
16:08:03 <ndm> those aren't stings, those are poisons
16:08:11 <ndm> and in the UK, its not really an issue :)
16:08:16 <SamB> ... you wierd!
16:08:18 <dons> http://www.australianfauna.com/irukandji.php
16:08:19 <lambdabot> Title: Irukandji Jellyfish
16:08:56 <dons> ah, more useulf http://en.wikipedia.org/wiki/Irukandji_jellyfish
16:09:03 <dons> "Vinegar has been found to deactivate Irukandji jellyfish stingers" !
16:09:26 <dons> ah, deactivate the stingers. too bad if they already posion you
16:10:44 <dons> ?uptime
16:10:45 <lambdabot> uptime: 1 day, 20 hours, 59 minutes and 3 seconds
16:10:48 <dons> ?users
16:10:49 <lambdabot> Maximum users seen in #haskell: 235, currently: 197 (83.8%), active: 20 (8.5%)
16:12:35 <araujo> The pee is a placebo
16:12:42 <araujo> :-)
16:12:56 <vincenz> right
16:13:02 <vincenz> cause we -all- believe in the curative powers of pee
16:13:07 <vincenz> like those doctors that drink it in the morning
16:13:51 <araujo> yeah, doctors are weird
16:14:22 * araujo that's why he wants to continue being a broken student :-)
16:14:45 <vincenz> broken?
16:14:46 <vincenz> why?
16:14:51 <vincenz> most people will settle for broke, but broken?
16:15:04 <araujo> oh yeah broke :-)
16:15:32 <araujo> vincenz, Probably nn-engish speaker will say 'broken' from time to time :-P
16:15:47 <vincenz> :)
16:15:50 * vincenz is non-english but ok :)
16:15:54 <araujo> Which, for me, i don't see _that_ many difference either :-P
16:15:59 <vincenz> I'm just a bastard that takes people on their words
16:16:38 <tieTYT> alright here's another request for spoon-feeding: http://paste-bin.com/213
16:16:45 <tieTYT> i pasted the exercise question
16:16:46 <araujo> ?
16:17:06 <tieTYT> the answer to it follows (it comes out of YAHT)
16:17:08 <araujo> oh, ya, yu learning haskell!
16:17:11 <vincenz> tieTYT: nice
16:17:16 <araujo> oh, i mean, you ...
16:17:26 <tieTYT> that was totally unintuitive to me
16:17:26 * araujo gotta be careful with vincenz around :-)
16:17:57 <tieTYT> plus if i actually pass a tuple through valueOfTuple, it doesn't print what the exercise says it should, it prints (Left (Left 1))
16:18:13 <tieTYT> so wth.  Is this a bad exercise?
16:18:51 <tieTYT> yep i'm learning haskell
16:18:52 <vincenz> why should it print?
16:19:16 <tieTYT> well in the interpreter i think it applies show to it
16:19:19 <vincenz> oh
16:19:28 <tieTYT> if i say valueOfTuple(Single 1)
16:19:38 <vincenz> rightio
16:19:49 <vincenz> should work fine
16:19:54 <vincenz> and haskellers tend to use . and $
16:19:56 <vincenz> not ()
16:20:01 <vincenz> Left $ Left 1
16:20:05 <vincenz> Left . Left $ 1
16:20:07 <tieTYT> i've learned . but not $
16:20:24 <tieTYT> but anyway, how is this doing what is requested?
16:20:25 <vincenz> it's like .
16:20:28 <vincenz> but different association
16:20:32 <vincenz> and lower priority
16:20:41 <tieTYT> oh
16:21:12 <vincenz> @type (.)
16:21:13 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
16:21:14 <vincenz> @type ($)
16:21:15 <lambdabot> forall b a. (a -> b) -> a -> b
16:21:25 <vincenz> erm yeah...
16:21:28 <dons> > (toUpper . toLower $ 'x') == toUpper (toLower 'x') == (toUpper $ toLower 'x')
16:21:28 <lambdabot>    precedence parsing error
16:21:29 <lambdabot>     cannot mix `(==)' [infix 4] and `(==)' ...
16:21:32 <dons> heh ok
16:21:34 * vincenz thx dons
16:21:41 <dons> > (toUpper . toLower $ 'x') == (toUpper (toLower 'x')) == (toUpper $ toLower 'x')
16:21:42 <lambdabot>    precedence parsing error
16:21:42 <lambdabot>     cannot mix `(==)' [infix 4] and `(==)' ...
16:21:53 <dons> > (toUpper . toLower $ 'x') == (toUpper (toLower 'x') == (toUpper $ toLower 'x') )
16:21:54 <lambdabot>  Couldn't match `Char' against `Bool'
16:22:06 <dons> bah, you know what I mean
16:22:15 <vincenz> No I don't
16:22:20 <dons> > (toUpper . toLower $ 'x') == (toUpper (toLower 'x')
16:22:21 <lambdabot>  Parse error
16:22:27 <dons> > (toUpper . toLower $ 'x') == (toUpper (toLower 'x'))
16:22:28 <lambdabot>  True
16:22:41 * dons -> coffee
16:22:52 <tieTYT> ok... so it looks like you apply $ to the arguments
16:23:04 <tieTYT> what if toLower had 2 arguments?
16:23:14 <vincenz> heh
16:23:15 <dons> > map (+1) $ [1..10]
16:23:17 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
16:23:35 <dons> > map $ (+1) $ [1..10]
16:23:36 <lambdabot>  Couldn't match `a -> b' against `[a1]'
16:23:39 <dons> no good
16:23:57 <vincenz> dumteedum
16:24:07 <vincenz> dons: wrong association
16:24:15 <vincenz> ?
16:24:15 <dons> > (map $ (+1)) $ [1..10]
16:24:17 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
16:24:21 <dons> yeah
16:24:41 <dons> as Pseudonym always says
16:25:07 <vincenz> too much $ is bad?
16:25:23 <dons> some real world examples: modify $ \state -> state { ircStayConnected = False }
16:25:31 <dons> (`mapM` mods) $ \(ModuleRef m ref name) -> do ....
16:25:37 <ndm> I love $ :)
16:25:39 <dons> io $ hPutStrLn stderr " done." >> hFlush stderr
16:25:41 * vincenz quietly whispers to dons "we've scared away the newb"
16:25:54 <dons> ah well.
16:26:09 <dons> it bad form to use more than 1 $ in a line, I think :)
16:26:24 <vincenz> dons: except when sending SPAM
16:26:26 <dons> though, threadr    <- io $ forkIO $ rloop threadmain chanr chanw
16:26:33 <ndm> I often use many
16:26:37 <ndm> either i have one
16:26:40 <ndm> or i have a pipeline
16:26:43 <vincenz> ndm: I refactor extraneous $ to .
16:26:51 <dons> oh, that's a nice one: lbIO k = LB . ReaderT $ \r -> k (\(LB m) -> m `runReaderT` r)
16:26:57 <dons> ?pl lbIO k = LB . ReaderT $ \r -> k (\(LB m) -> m `runReaderT` r)
16:26:58 <lambdabot> (line 1, column 8):
16:26:58 <lambdabot> unexpected "="
16:26:58 <lambdabot> expecting variable, "(", operator or end of input
16:27:01 <dons> boo
16:27:18 <ndm> nub $ concatMap g $ allExpr $ body $ getFunc hite x
16:27:19 <dons> lift . lbIO $ \conv -> withMWriter mvar $ \x writer -> ... -- 2
16:27:26 <ndm> thats just one line in the file i'm currently hacking :)
16:27:27 <kpreid> dons: how do you feel about [foo $ bar x, foo $ baz y]?
16:27:32 <dons> ndm, that's supposedly bad style though, isn't it?
16:27:39 <ndm> dons: my code, my style
16:27:46 <dons> heh
16:28:06 <dons> nub . concatMap g . allExpr . body . getFunct hit $ x
16:28:18 <ndm> yeah, i don't like that as much
16:28:22 <vincenz> ndm: sayeth the c-programmer
16:28:26 <ndm> less symetry
16:28:34 <dons> more .'s though
16:28:37 <dons> ?karma+ .
16:28:38 <lambdabot> .'s karma raised to 1.
16:28:56 <ndm> its just not as pretty, i think
16:29:00 <vincenz> $karma+ $
16:29:02 <vincenz> doh
16:29:21 <dons> seems I tend to use more than 1 in an expr when lift'ing or forkIO'ing:
16:29:23 <dons> forkIO $ sequence_ . repeat $ do ...
16:29:45 <vincenz> heh
16:29:46 <dons> io $ forkIO $  ...
16:30:00 <vincenz> io . forkIO $
16:30:04 <dons> I suppose because forkIO takes a big expr as an argument
16:30:55 <vincenz> dons: how do you classify 'big'
16:31:02 <vincenz> by the number of stacked monad tranasformers?
16:31:06 <dons> 2 lines?
16:32:01 <dons> ?pl \m -> getName >>= writeGlobalState m
16:32:01 <lambdabot> (getName >>=) . writeGlobalState
16:33:57 <kpreid> dons: I'd guess it would be because of forkIO $ do habit
16:34:29 <vincenz> @pl dons
16:34:29 <lambdabot> dons
16:35:04 <dons> kpreid: or just the nice symmetry: x <- some io action --> x <- forkIO $ some io action
16:35:09 <dons> so easier to threadify it
16:36:11 <kpreid> huh. yes. f $ g h is closer to f g h than f . g $ h
16:36:21 <kpreid> er, closer to g h
16:36:27 * vincenz shuts up all the geeks as they scare away the newbs
16:37:37 <nuffer> IO arrays, are they general purpose arrays?
16:37:44 <vincenz> erm
16:38:00 <vincenz> I've never used arrays
16:38:04 <vincenz> but I think there's other options
16:40:20 <dons> nuffer: yep
16:40:30 <dons> ?gwiki Modern array libraries
16:40:32 <lambdabot> No Result Found.
16:40:47 <dons> ?google site:haskell.org Modern array libraries
16:40:51 <lambdabot> http://haskell.org/haskellwiki/Modern_array_libraries
16:40:51 <lambdabot> Title: Modern array libraries - HaskellWiki
16:41:08 <vincenz> dons: what about diffarray and co?
16:41:12 <vincenz> or ST?
16:41:30 <dons> never used diffarray. ST arrays are general purpose though. see the above story
16:41:35 <vincenz> nice pag  :)
16:42:48 <vincenz> probby with IO array is the monad requirements o.O
16:43:27 <dons> yep
16:45:48 <vincenz> hmm
16:45:54 <vincenz> I think the naming "unsafeAt" is poorly chosen
16:46:00 <vincenz> it hints at stepping out of the monad
16:46:02 <vincenz> which it does not do
16:46:09 <vincenz> uncheckedAt ?
16:47:50 <ndm> vincenz: you may be stepping out of the IO monad and into a random chunk of heap...
16:47:58 <ndm> its far worse than unsafePerformIO
16:49:32 <vincenz> hmm
16:49:39 <vincenz> I thought it'd only not do the index checking
16:49:44 <vincenz> so I was led to believe by that webpage
16:49:49 <vincenz> prolly needs better formulating then :
16:49:50 <vincenz> :/
16:50:44 <ndm> it doesn't do the index checking, but the index checking is all that stops you from overrunning the arry
16:50:55 <dons> :)
16:51:29 <dons> _usually_ you have checked the bounds yourself -- but if you get it wrong, then you won't get an exception. something evil will more ikely happen
16:51:45 <dons> i..e segfault versus helpful exception
16:52:15 <ndm> it blows apart the whole haskell is safe thing
16:52:34 <vincenz> well yeah
16:52:34 <dons> hence unsafeFoo :)
16:52:38 <vincenz> but I still think it's bad wording
16:52:40 <vincenz> call it unchecked
16:52:51 <vincenz> unsafe implies monad-houdinism
16:52:51 <ndm> i think evilFoo is a better name
16:52:53 <jrmole> the term "type-safe" is well-established to describe this property
16:52:59 <ndm> its not unsafe, providedyou treat it with care
16:53:10 <ndm> but it will kill you if you give it the chance
16:53:14 <jrmole> also it's important that these functions have long, unwieldy names
16:53:22 <vincenz> yes
16:53:26 <jrmole> and unsafePerformIO can also cause segfaults, which is probably the "real" reason for it being declared unsafe
16:53:34 <dons> yep
16:53:37 <jrmole> just improperly sequencing IO wouldn't be a type saftey violation
16:53:46 <dmwit> superBadTheWayRatMazesWithoutCheeseAreBadButNotUnsafeFoo?
16:54:27 <dons> yeah, hence unsafeInterleaveIO is a bit special: no type errors, just some io weirdness
16:54:29 <jrmole> if the IO monad had more granularity, we could make a version of unsafePerformIO that can never corrupt the heap
16:54:32 <vincenz> I think unsafe refers to the fact you don't know whether it's executed due to monadic blba
16:54:40 <dons> (but no worse than readFile "x" >>= writeFile "x")
16:54:53 <vincenz> dons: what does that do?
16:54:57 <vincenz> cat makes an empty file :/
16:55:02 <vincenz> which is so lame
16:55:04 <vincenz> cant do
16:55:06 <jrmole> yeah... the behavior of readFile w.r.t. laziness is nonintuitive
16:55:09 <vincenz> cat pre-A A > A
16:55:15 <jrmole> or rather, getContents
16:55:20 <dons> its unsafe in the unsafeInterleaveIO sense
16:55:27 <dons> yeah
16:55:40 <dons> though... we do lock the Handle to deal with this
16:55:46 <vincenz> ??
16:55:47 <dons> so you get an exceptoin (not just truncated input)
16:55:50 * vincenz is lacking context
16:55:57 <jrmole> ah, it's not what happened to me when i tried this
16:56:00 <jrmole> perhaps i had an old ghc version
16:56:39 <dons> the Handle should be put in a semi-closed state, which will throw an exception if you attempt to use it somewhere else
16:57:03 <jrmole> vincenz, do { c <- hGetContents hdl; close hdl; putStrLn c }
16:57:16 <vincenz> rightio
16:57:18 <vincenz> but i mean
16:57:22 <vincenz> "unsafeInterleaveIO"
16:57:31 <jrmole> why can't we have the contents be read strictly on close?
16:57:32 <jrmole> oh
16:59:48 <dons> there's a tricky issue with GC, I thin
16:59:55 <dons> k. Simon talked about this last week on the ml
17:01:31 <jrmole> "Once a semi-closed handle becomes closed, the contents of the associated list becomes fixed. The contents of this final list is only partially specified: it will contain at least all the items of the stream that were evaluated prior to the handle becoming closed." -- ghc 6.4
17:01:51 <dons> yeah.
17:02:07 <jrmole> so does / can it "evaluate" the next thunk to error "lazy read on closed file" or something?
17:02:54 <dons> guess not without hackery (you want a warning that you didn't read the whole file?)
17:03:04 <dons> and what happens on sockets?
17:03:40 <jrmole> hmm, i'm not even sure what sockets should do
17:05:06 <jrmole> it should probably be an IO error, i guess
17:06:09 <jrmole> it seems that, conceptually, hGetContents gives you the whole contents of the file, and if later it's not actually able to do so, this is an error on the system's part and should be reported to you as such
17:06:25 <jrmole> much like, say, building a computation but running out of heap before it can evaluate
17:06:55 <jrmole> i mean, if your unfold runs out of heap halfway through, it doesn't just truncate the list
17:07:14 <dons> yeah. I agree its not ideal currently
17:07:20 <dons> and it bites too many people
17:07:21 <jrmole> i make no claims about how easily this could be implemented; this is "wouldn't it be nice" mode
17:07:27 <dons> :)
17:08:21 <jrmole> i suppose there's no way to have a list of type IO [a] which works partway and then gives an IO error
17:08:28 <jrmole> it would have to be of type IO [IO a]
17:08:42 <jrmole> or am i confusing myself?
17:08:57 <SamB> well...
17:09:04 <lennart> then you might as well use getChar
17:09:09 <SamB> unsafeInterleaveIO complicates things
17:10:41 <SamB> oh, anyway, you can catch those IO errors if you make sure they happen inside your catch ;-)
17:10:53 <SamB> or try or whatever...
17:11:17 <SamB> anyway, if you make sure they happen while your exception handler is active...
17:12:29 <jrmole> seems like implementing these partial lists with type IO [a] would make it so any catch forces the immediate reading of the whole list
17:12:37 <jrmole> because it would need to resolve that each individual character is not an error
17:13:34 <SamB> *you* actually have to make sure of that, if you want to keep the error from escaping your handler...
17:14:01 <jrmole> files as lazy lists is a cool thing to have for simple scripting-style things, but i'm not sure the semantics can be made nice enough for heavy lifting
17:14:05 <vincenz> I wonder if flow based typing might solve some of the issues of IO
17:14:15 <jrmole> vincenz, what's flow based typing?
17:14:36 <vincenz> not sure but I remember there to be some typing that can handle the flow of an application
17:15:38 <vincenz> so you could require x to happen after y
17:15:44 <vincenz> by having it in the type
17:16:22 <jrmole> well, if this were just a simple Error monad, your catch would force a pattern match on the error/non-error constructors, which would force the match against all individual characters, which would require actually reading them
17:16:30 <jrmole> i don't know how IO exceptions are implemented though
17:17:05 <vincenz> I was thinking more the issues with Storable that requires stuff to happen inside an "withStorable" and if you use it outside of that block requires certain function calls
17:18:46 <jrmole> what module is withStorable in?
17:19:00 <vincenz> @hoogle withStorable
17:19:01 <lambdabot> Data.Array.Storable.withStorableArray :: StorableArray i e -> (Ptr e -> IO a) -> IO a
17:19:04 <vincenz> that one
17:19:07 <jrmole> ah
17:20:01 <vincenz> but I learned about it just now in the page that dons referred
17:23:20 <jrmole> so unsafeInterleaveIO inside withStorableArray is bad mojo, since your IO action "completes" immediately, the array might get freed, and then later when you get that value you have a stale pointer?
17:23:38 <vincenz> ???
17:24:40 <jrmole> just trying to understand what's going on
17:25:27 <vincenz> yeah but erm... not that far
17:25:55 <vincenz> I wasn't thikning at all about unsafeInterleaveIO
17:27:01 <jrmole> yeah, but it connected
17:28:25 <jrmole> maybe
17:33:27 <vincenz> hmm
17:33:32 <vincenz> what's a good VM implementation?
17:33:51 <Pseudonym> For what?
17:34:02 <vincenz> for having a small portable VM that's not too heavyweight
17:34:10 <vincenz> to compile code for
17:34:20 <dons> there are some weird phd topics out there http://www.theage.com.au/articles/2006/08/27/1156617211732.html?from=top5
17:34:21 <lambdabot> Title: Star Trek's a thesis - TV & Radio - Entertainment - theage.com.au
17:34:23 <vincenz> I take it registerbased?
17:34:44 <Pseudonym> JVM is a popular choice because it's everywhere, but it's very OO.
17:34:45 <vincenz> in that case... how many regs is a good number? What are typical instructions? Modelling a full RISC seems excessive
17:34:49 <Pseudonym> Have you looked at LLVM?
17:34:54 <vincenz> hmm, no
17:35:02 <Pseudonym> ?google llvm
17:35:05 <lambdabot> http://llvm.org/
17:35:05 <lambdabot> Title: The LLVM Compiler Infrastructure Project
17:35:10 <vincenz> oh wait
17:35:16 <vincenz> I heard about it in the sense of a c++ compiler
17:35:19 <jrmole> parrot?
17:35:24 <Pseudonym> The nice thing is you can compile to native code via LLVM.
17:35:29 <vincenz> basically I want to compile scheme to it
17:35:35 <Pseudonym> Oh, then use C--.
17:35:37 <vincenz> not sure if anyone is familiar with mosquito-lisp
17:35:39 <jrmole> parrot is built for dynamically typed languages
17:35:40 <vincenz> ?
17:35:55 <Pseudonym> Or implement your own SECD machine in about 20 lines of Haskell.
17:36:13 <jrmole> the choice is clear, compile to brainfuck or unlambda
17:36:26 <vincenz> no seriously
17:36:31 <vincenz> what is the most typical choice?
17:36:33 <vincenz> I take it register-based
17:36:34 <LordBrain> if i say do {x <- hGetLine h; hClose h; putStrLn x}   x is lazy,right? yet this program works, does that mean the handle isnt really closed until after x is requested?
17:36:36 <dons> you could even use lambdabot Unlambda.hs implementation..
17:36:37 <vincenz> 16 registers?
17:36:39 <vincenz> special purpose ones?
17:36:47 <Pseudonym> For scheme, the most typical choice is to roll your own, since scheme VMs are so simple.
17:36:54 <vincenz> build in malloc and free as native inistructions?
17:37:01 <vincenz> Pseudonym: how's that?
17:37:02 <ndm> vincenz: usually its stack based, not register
17:37:06 <jrmole> stack VMs are easier to write
17:37:07 <vincenz> ndm: why?
17:37:09 <jrmole> and easier to emit code for
17:37:15 <vincenz> stack vm's are harder to optimize I would presume
17:37:22 <ndm> as jrmole says
17:37:30 <ndm> they are a bit harder to optimize
17:37:31 <vincenz> right
17:37:38 <ndm> but can be easier to execute
17:37:42 <jrmole> LordBrain, did you see the above getContents discussion?
17:37:44 <vincenz> okies
17:37:51 <vincenz> ndm: what is a typical instruction set for it?
17:37:51 <ndm> and you get to ignore the whole regsiter spill issues
17:37:54 <LordBrain> no i wasnt here actually... i just left irssi on
17:38:02 <ndm> vincenz: have you seen the Yhc instruction set?
17:38:03 <jrmole> i think the answer is "it might not work", at least this is true for getContents
17:38:09 <vincenz> ndm: fraid not yet
17:38:13 <jrmole> maybe hGetLine is strict
17:38:25 <vincenz> the UM one seems too restrictive
17:38:26 <vincenz> on the other hand
17:38:29 <ndm> vincenz: http://www-users.cs.york.ac.uk/~ndm/yhc/bytecodes.html
17:38:30 <vincenz> a full RISC set is prohibitive
17:38:31 <lambdabot> Title: Yhc - Bytecode Documentation
17:38:55 <vincenz> ah i see
17:39:01 <ndm> if you are doing a lazy language you need to make some different choices
17:39:01 <vincenz> you make very erm... language-oriented instructions
17:39:04 <vincenz> they're not generic
17:39:07 <Pseudonym> vincenz: A good instruction set is to directly interpret a subset of Scheme.
17:39:11 <ndm> nope, depends what you want
17:39:20 <Pseudonym> Seriously.
17:39:26 <vincenz> Pseudonym: isn't that seriously inefficient?
17:39:45 <Pseudonym> ?google "write yourself a scheme in 48 hours"
17:39:48 <lambdabot> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
17:39:48 <lambdabot> Title: Write Yourself a Scheme in 48 hours
17:39:51 <LordBrain> jrmole: ok i see
17:40:00 <LordBrain> jrmole: yeah hGetLine must be strict
17:40:05 <vincenz> the thing is
17:40:10 * vincenz ponders
17:40:11 <vincenz> nm
17:40:14 <jrmole> since it's specially pointed out that getContents is lazy, i think this is the case
17:40:43 <jrmole> vincenz, i'm not sure they're necessarily language-oriented
17:40:51 <jrmole> but they are laziness-oriented, i.e. supporting graph reduction
17:41:12 <Pseudonym> http://www.iro.umontreal.ca/%7Eboucherd/mslug/meetings/20041020/minutes-en.html
17:41:15 <lambdabot> Title: '(Montreal Scheme/Lisp User Group) / Bienvenue
17:41:16 <Pseudonym> Try that one.
17:41:21 <jrmole> STG was developed for LML and used for Haskell, iirc
17:41:25 <vincenz> aha :)
17:41:32 <vincenz> well erm
17:41:42 <vincenz> the problem with -> C is that you need a C compiler
17:41:44 <vincenz> ideally
17:41:56 <Pseudonym> Sure, but the thing is, you don't need to compile to C.
17:42:00 <vincenz> you'd have a (syntax is Source-(Medium)->Target)
17:42:08 <vincenz> Scheme-(Scheme)->ByteCode
17:42:17 <vincenz> and a ByteCode-(C)->native
17:42:23 <vincenz> well the second would be the VM interpreter
17:42:50 <vincenz> that way you could decide whether to ship VMs with full repl or not
17:42:56 <ndm> vincenz: are you after doing something in particular?
17:43:02 <lispy> the top level splice restriction in TH gets old fast
17:43:07 <Pseudonym> The idea is it does enough source-to-source translations such that the final scheme is trivial to compile to C.
17:43:16 <Pseudonym> That final step doesn't have to be to C.
17:43:18 <vincenz> ndm: well have you looked at mosquito-lisp? It looks nifty, I was having an idea of rolling my own for the fun of it
17:43:31 <ndm> @google mosquito lisp
17:43:35 <lambdabot> http://www.ephemeralsecurity.com/mosquito-lisp
17:43:56 <ndm> cool
17:44:28 <vincenz> basically they have an ultra-mini VM
17:44:34 <vincenz> they erm...hack into a system *whistle*
17:44:45 <vincenz> and then they can send compiled scheme code to it to try 0-day bugs
17:45:00 <vincenz> not that I plan to use it for hacking, but the concept of small VMs that can communicate code to one another is nifty :)
17:45:22 <vincenz> and obviously having just a byte-code interpreter will make it smaller
17:45:26 <vincenz> so that then you can decide whether to compil
17:45:36 <vincenz> scheme-(Scheme)->bytecode to byte code and ship it or not
17:46:03 <vincenz> (yes, I realize this will forego EVAL bye default, but that's minor acceptable loss)
17:46:16 <Pseudonym> vincenz, if you take a look at the generated C for the 90 minute scheme compiler, it's actually a bunch of macros.
17:46:32 <Pseudonym> All of which are perfectly respectable VM instructions.
17:46:37 <vincenz> Pseudonym: I will :)
17:46:39 <vincenz> thx for the pointer
17:47:27 <vincenz> does it do macros?
17:47:44 <vincenz> that seems to be the hardest part that most scheme tutorials etc seem to skip on
17:48:06 <vincenz> woo :)
17:48:09 <vincenz> it's even written in scheme
17:48:13 <vincenz> all I have to do is change the output code :)
17:48:53 <vincenz> noice
17:49:06 <Pseudonym> Once you've bootstrapped it, it'll be cool.
17:49:21 * lispy triumphs over cabal for now
17:50:05 <vincenz> Pseudonym: the nice part of it is having the option of having the compiler or not just by compiler the compiler portside and then sshing it, or whatever protocol you use :)
17:50:23 <Pseudonym> Right.
17:50:44 <vincenz> interpreters don't give you that decoupling freedom
17:51:00 <vincenz> which granted, is only a footprint issue
17:51:33 <emu> just because you compile doesn't mean there isn't a runtime
17:56:58 <vincenz> whew
17:56:59 <vincenz> lag
17:58:17 <johnnowak> does ghc do any optimizations to deduce sigularly referenced objects allowing destrutive updates? if so, is it possible to make use of this to allow for referential transparency without monads? perhaps it is an obvious question, but I'm not much of a haskell programmer yet. :)
17:59:15 <jrmole> what do you mean by referential transparency without monads?
17:59:25 <jrmole> every expression in haskell is referentially transparent, monadic or not
17:59:39 <vincenz> the referential transparency is used for the compilation process
18:00:23 <johnnowak> say i pass a list to a function. is the list copied in all cases, or can it be mutated in some cases?
18:00:30 <ndm> johnnowak: what you are thinking of is uniqueness types, which clean uses, instead of monads
18:00:33 <dons> johnnowak: some fusion optimisations (such as byteString) are able to use destructive updates
18:00:51 <johnnowak> ndm: ah.
18:01:08 <dons> lists aren't ever mutated though
18:01:13 <ndm> dons: but you can't detect if a bytestring is only referenced by one user can you?
18:01:29 <ndm> which use destructive updates?
18:01:48 <vincenz> fusion works based on the idea that your intermediate result is not used elsewhere
18:01:51 <vincenz> so yes, one user
18:01:54 <dons> you can see: f . g . h . filter ....
18:02:04 <dons> where filter creates a new array only viewable by h
18:02:13 <johnnowak> ndm: I know of Clean's system, and I was wondering if Haskell makes similar optimizatiosn under the hood, even if it doesn't necessarily make use of that to otherwise not require monads for certain things.
18:02:19 <dons> which the compiler then turns into a single traversal, where (f.g.h) mutate the result of filter
18:02:41 <ndm> johnnowak: i don't think so
18:02:55 <johnnowak> Hm. So don't pass such large data then. :)
18:03:05 <dons> so from the outside: (f .g . h . filter) just returns a new bytestring (and does so using mutation under the hood)
18:03:17 <vincenz> erm
18:03:19 <vincenz> o.O
18:03:21 <vincenz> dons: how's that
18:03:31 <ndm> dons: ah, so it does one copy, 3 mutations
18:03:33 <vincenz> fusion still transforms code to use other functions
18:04:06 <dons> ndm, yep. filter creates a new array, via a copy, which f. g. h mutate
18:04:27 <vincenz> dons: where does the mutation occur?
18:04:30 <ndm> does yi use Bytestring yet?
18:04:31 <dons> so these functions ike filter, unfold, replicate that produce new arrays that are immediately consumed, can be safely mutated by their consumers
18:04:35 <dons> ndm, npoe
18:04:43 <johnnowak> thanks dons, that's helpful
18:05:20 <dons> vincenz: wait for the paper :) it'll be out next week with all the top secret details
18:05:43 <johnnowak> better than nothing i suppose :)
18:06:04 <dons> one nice thing is that we don't have to extend ghc to add these optimisations
18:06:07 <dons> rewrite rules are enough
18:06:28 <dons> so if you could find other cases where there's no sharing, the same thing could apply
18:07:08 <vincenz> how can rewrite rules introduce modification tho?
18:07:13 <dons> admittedly just about every other type is harder to mutate than Ptr a
18:07:15 <vincenz> unless you sneak in a hidden IO
18:07:22 <ndm> isn't it hidden C?
18:07:47 <dons> vincenz: writeIO (f.g.h) (filternewArray)
18:07:54 <dons> inlinePerformIO $
18:08:00 <vincenz> ah rightio
18:08:03 <vincenz> IO monads
18:08:11 <ndm> inlinePerformIO ?
18:08:15 <dons> (i.e. poor man's runtime system support via inlinePerformIO)
18:08:23 <dons> ndm, fast unsafePerformIO
18:08:27 <johnnowak> it would be fantastic if we could notate that we expect something to be mutated, and then have the compiler warn if we've analysed incorrectly (or if the compiler is not sufficiently smart to analyse completely)
18:08:44 <ndm> johnnowak: Clean does all of that
18:08:53 <johnnowak> hm.
18:08:58 * vincenz ponders
18:09:04 <vincenz> why aren't those ideas ported to ghc
18:09:19 <vincenz> soon we'll have three languages, heh
18:09:23 <vincenz> haskell, clean and ghc
18:09:45 <johnnowak> perhaps I'll give it a shot... it seems very simple. hell, i thought of it.
18:09:52 <ndm> Clean is already a language?
18:10:08 <ndm> as is GHC
18:10:14 <jrmole> ghc's haskell is already significantly advanced over haskell98
18:10:16 <ndm> so the only one thats in doubt is Haskell
18:10:28 <vincenz> GHC is not a language
18:10:29 <SamB> Haskell... isn't much of a language!
18:10:35 <vincenz> it's a name!
18:10:44 <Cale> It's a way of life!
18:10:45 <johnnowak> i thought it was a lifestyle?
18:10:45 <SamB> at least, not if you mean Haskell98!
18:10:49 <johnnowak> Cale: :)
18:11:11 <Cale> The white zone is for loading and unloading only!
18:11:23 <ndm> if you can compile all the standard libraries using only Haskell 98, i'll let you claim that GHC is Haskell
18:11:30 <johnnowak> were uniqueness types originally considered for haskell in place of or in addition to monads?
18:11:38 <ndm> (FFI and heirarhcical modules allowed)
18:11:45 <jrmole> GHC's Haskell98 libraries compile in Haskell98 mode, yes?
18:11:49 <ndm> don't think so, originally continutatinos were allowed
18:12:02 <ndm> jrmole: the Haskell 98 ones yes, but pretty much none of the others
18:12:05 <SamB> ndm: that ain't 98!
18:12:16 <jrmole> then GHC is a full implementation of Haskell98, and some other things besides
18:12:19 <Cale> johnnowak: For IO, monads seem so much nicer to me.
18:12:24 <ndm> but they are adendums to Haskell 98, so i let it off
18:12:25 <SamB> with FFI and heirarchical modules, it *is* a lot better
18:12:32 <johnnowak> Cale: it is entirely possible.
18:12:37 <SamB> also, the Prelude won't build under '98
18:12:49 <jrmole> i'd guess uniqueness types are nice in the same way seq is nice
18:12:55 <ndm> i originally thought uniqueness was better, but now, with experience, i think monads are
18:12:56 <jrmole> as a small hack that allows you to annotate for extra strictness
18:13:04 <Cale> johnnowak: Though it might be nice to be able to give checked hints about uniqueness for performance reasons.
18:13:17 <jrmole> but monads are a general way to organize code that goes way beyond destructive updates
18:13:26 <dons> i wonder if bang patterns in IO could be turned into uniqueness hints
18:13:41 <johnnowak> Cale: that's mainly my interest. i'd like to verify that I know what is going on, or perhaps give hints to the compiler so it can try and optimize certain things it might not otherwise do.
18:14:08 <jrmole> in many cases a theorem-proving task is still undecidable even if you specify explicitly what you want proven
18:14:26 <johnnowak> perhaps I can just make it so by fiat then :)
18:14:37 <dons> does anyone know of work discovering uniquness in monadic code? it seems we'd be able to recover the same kind of information that clean's uniqueness types describe, and get more on the side
18:14:38 <jrmole> sure,  but your compiler won't be able to tell you if you're wrong
18:14:49 <johnnowak> jrmole: in some cases, that is not a bad tradeoff
18:14:50 <jrmole> you can already do that with unsafePerformIO, sort of
18:14:52 <Cale> The things that people like dons are doing with RULES are pretty impressive. It would be nice to have a nice clean, standardised system for rules which wasn't just pragmas.
18:14:54 <jrmole> no, not at all
18:15:21 <jrmole> (re tradeoff)
18:15:24 <ndm> Cale: i did consider than
18:15:35 <ndm> i also wondered if you would get any bonus out of runtime rewrites
18:15:47 <SamB> what are "JUST pragmas"?
18:15:53 <Cale> SamB: heh
18:16:00 <ndm> map f (map g x) = map (f.g) x
18:16:09 <ndm> but as a standard pattern matching rewrite rule
18:16:14 <jrmole> problem is, seq and such are safe annotations... they may cause your program to diverge, but they can't corrupt anything
18:16:20 * SamB thinks pragmas are just a handy way to avoid adding keywords
18:16:24 <ndm> possibly with an annotation as to what is a concrete name
18:16:30 <ndm> ^map f (^map g x) = map (f.g) x
18:16:40 <ndm> then that rule can be fired at either runtime or compile time
18:16:43 <SamB> well... a bit more than that...
18:16:56 <jrmole> whereas your unchecked uniqueness types would be on the same level as the unsafe functions
18:17:01 <SamB> also a way for compilers not in the know to ignore them...
18:17:09 <Cale> ndm: Isn't it a little hard to apply it at runtime, under most means of compilation?
18:17:24 <ndm> Cale: not for Yhc :)
18:17:28 <Cale> I suppose you do have the graph in some form.
18:17:51 <ndm> with Yhc you can pull apart a value, and see what value created it
18:17:57 <ndm> * function created it
18:18:03 <ndm> so you can tell between x and id x
18:18:08 <Cale> interesting
18:18:22 <ndm> of course, this is using the evil break referential transparency
18:18:32 <Cale> Well, obviously :)
18:18:52 <ndm> you can also grab pieces of code, and fling them around a network, and put them back together at runtime
18:19:06 <Cale> Yeah, that's really very cool.
18:19:15 <ndm> hopefully Tom will write a paper on it
18:19:37 <Cale> So I take an unevaluated value and send it over the network without forcing evaluation?
18:19:39 <ndm> the intended use case is for grid computing -  a haskell program can open a socket, send portable bytecode over the wire, send some data
18:19:48 <ndm> and get back a result
18:19:59 <ndm> yep, send thunks over a network, without evaluation
18:20:12 <Cale> Very cool, I was thinking it would be very nice to do that earlier.
18:20:26 <Cale> Similarly, can one store them to a file?
18:20:30 <vincenz> ndm: you work on yhc
18:20:30 <ndm> its in teh Yhc repo, but entirely undocumented
18:20:31 <SamB> ... what does it do with unsafePerformIOs?
18:20:31 <vincenz> ?
18:20:34 <ndm> yep, you acn do anything
18:20:37 <ndm> vincenz: yep
18:20:41 <vincenz> neato
18:20:57 <ndm> store them in a file, even take the code and map it to upper case :)
18:21:04 <ndm> (which will probably blow up your computer)
18:21:22 <Cale> ndm: so it actually gives human readable expressions?
18:21:33 <Cale> I'd think it would be bytecode or some such :)
18:21:41 <SamB> ... bytecode has upper/lower case?
18:21:43 <ndm> Cale: not at all, it gives Yhc bytecode - but given there is a bytecode library you can decmopile it to some degree
18:21:48 <Cale> ah
18:22:05 <ndm> no, that was more a joke - it passes the bytecode around as a string currently, so you can corrupt it easily :)
18:22:23 <jrmole> hmm, such a bytecode system would be pretty great for a haskell OS
18:22:24 <ndm> there is only a low level and highly unsafe API at the mo, but in future it will have a higher level api
18:22:33 <Cale> jrmole: yes :)
18:22:43 <ndm> you'd need to add jit compilation to the bytecode
18:22:43 <Cale> It would be ridiculously cool.
18:22:47 <jrmole> i was thinking about some kind of STG-machine as a platform VM, but this sounds cooler and... more existing
18:22:50 <SamB> ndm: I repeat: what does it do with unsafePerformIO?
18:23:00 <Cale> jrmole: Looked at house?
18:23:02 <jrmole> i want to be able to swap in/out bits of the OS as it runs, like the LISP machines of yore
18:23:05 <jrmole> Cale, briefly
18:23:18 <jrmole> i'm not too interested in writing Yet Another Unix Clone
18:23:32 <ndm> SamB: no unsafePerformIO - all in the IO monad, with runtime support
18:23:38 <Cale> jrmole: I believe that's the idea there -- I think they started out by ripping out GHC's RTS, and turning that into a basic operating system.
18:23:39 <jrmole> i would want strong typing on all system calls
18:23:43 <jrmole> yes
18:23:47 <SamB> ndm: I meant...
18:23:53 <ndm> not sure what you mean, by what about unsafePerform?
18:24:01 <jrmole> but they didn't have anything close to a VM... you couldn't do grid computing or any of that
18:24:07 <SamB> if I had an unsafePerformIO... what would happen if I tried to send it over the wire?
18:24:08 <jrmole> and their system calls were basically unix, iirc
18:24:21 <ndm> SamB: don;t use unsafePerformIO :)
18:24:26 <Cale> jrmole: Of course, you need a good unix compatibility layer these days if you want access to a good selection of apps :)
18:24:37 <SamB> what if I tried to pass a ByteString over the wire?
18:24:42 <Cale> SamB: what would be the problem with that?
18:24:47 <SamB> and it didn't happen to have been evaluated yet?
18:24:47 <jrmole> sure, but that can be just another app that runs on top of your uber-awesome strongly-typed system of doom
18:24:47 <ndm> SamB: no idea on any of the deep details, that's Tom's department
18:25:05 <ndm> SamB: but it wouldprobably pass the Ptr over the wire, then send all data requests back to the original machine
18:25:23 <ndm> it can get heap contents are required from a remote machine
18:25:29 <jrmole> awesome haskell kernel -> translation to L4 semantics -> L4Linux
18:25:31 <SamB> ndm: ... what if there were no Ptr yet?
18:25:45 <ndm> SamB: then the Ptr would come into existance on the remote machine
18:25:52 <SamB> oh
18:25:53 <Cale> SamB: that'd be fine
18:25:56 <ndm> and you'd probably have two bytestrings on each machine
18:26:22 <SamB> so, unsafePerformIOs migrate fine?
18:26:41 <ndm> SamB: maybe, thats harder to know - the effects (readFile etc) might happen on either machine
18:26:43 <Cale> SamB: I don't see why they'd be any different from other calls.
18:26:58 <ndm> it will still work, but be even more unsafe
18:27:03 <ndm> i was thinking the other day
18:27:03 <Cale> yeah
18:27:18 <SamB> what happens if I do readFile and then pass the results to another machine?
18:27:19 <jrmole> ndm, you do work on yhc?
18:27:20 <ndm> if you had a JIT at runtime for a Haskell Byte Code, what runtime information could you use to make it faster than GHC
18:27:24 <ndm> jrmole: yes
18:27:34 <ndm> i.e. GHC uses static informatino to speed up its program
18:27:44 <jrmole> ndm, want to port the runtime system to the L4 microkernel?
18:27:47 <ndm> if you had access to runtime informatino, what would you use to make the code go faster
18:28:03 <ndm> jrmole: not really :) - but its reasonably well written C
18:28:20 <jrmole> i need an ambitious project
18:28:24 <ndm> jrmole: i don't have much to do with the runtime really, am more a compiler side person (if even that)
18:28:28 <jrmole> okay
18:28:29 <ndm> jrmole: go for it!
18:28:40 <SamB> ndm: probably couldn't do anything that JHC can't do...
18:28:55 <ndm> SamB: remember JHC also relies on static information
18:28:57 <SamB> except that you'd be able to wait until it seemed like it would help
18:29:04 <SamB> ndm: I know
18:29:17 <ndm> at runtime you can actually tell if a value in evaluated or not, so strictness information becomes perfect
18:29:33 <SamB> hmm
18:29:38 <ndm> i was just trying to think if runtime info gives anything where a static info can't
18:31:06 <SamB> well, it tells you what needs optimizing anyways
18:31:10 <ndm> unfortunatley i didn't get very far...
18:31:29 <ndm> did you hear of the HP processor, which runs as a VM for the processor itself?
18:31:39 <ndm> it emulates its own instruction set
18:31:56 <ndm> and in doing so, is able to do better recompilation at runtime, based on better info
18:31:59 <SamB> and if, say, you parsed a program into a function you could optimize that at runtime...
18:32:04 <SamB> but not at compile time...
18:32:19 <ndm> and get a 10% speed boost over running the processor natively
18:32:30 <SamB> ndm: sweet!
18:32:30 <ndm> yes, something like that
18:32:39 <SamB> perhaps all CPUs will do that in the future
18:32:49 <ndm> yeah, thats what got me thinking - sometimes dynamic information beats static info
18:32:57 <ndm> it was about 5 years ago, i believe
18:33:15 <ndm> but transmeta did something similar, in some respects
18:33:40 <SamB> ... but nobody tried to run programs on their arch...
18:33:55 <jrmole> intel learned this with the itanium, to some degree
18:34:14 <jrmole> it had parallelization information encoded at compile time
18:34:19 <SamB> jrmole: I think itanium is overcomplicated
18:34:26 <jrmole> but the really complicated runtime analyzers still beat it
18:34:27 <SamB> nobody wants to write a JIT for that...
18:34:31 <jrmole> of course it is
18:34:41 <SamB> too much work to generate
18:34:42 <jrmole> but the point is, compilers can't always tell when instructions don't depend on one another
18:35:05 <ndm> so, the question remains, how would you do the same things that have been shown for assembly language to a haskell vm?
18:35:25 <ndm> given that runtime analysis seems to win everything else
18:35:46 <jrmole> referential transparency seems like a big win for runtime analysis
18:36:06 <Pseudonym> Part of the problem is that it's hard to tell that instructions don't interfere on an architecture with no registers (to a first approximation).
18:36:16 <SamB> jrmole: but what about those tricks dons and others play on compilers?
18:36:25 <Pseudonym> The condition register is a severe bottleneck.
18:36:39 <jrmole> the fusion stuff?
18:36:40 <Pseudonym> Any arithmetic instruction may interfere with any other via the carry code.
18:36:54 <Pseudonym> carry bit
18:37:04 <SamB> jrmole: no, the unsafePerformIO stuff
18:37:44 <ndm> we can ignore the tricks for now
18:38:00 <ndm> i was more looking for flawed ideas than anything else :)
18:38:27 <SamB> compile to JVM bytecode!
18:38:37 * SamB tries to come up with sillier ideas
18:38:43 <jrmole> again, brainfuck and unlambda
18:38:51 <lscd> SamB: no, compile to unlambda!
18:39:02 <lscd> d'oh, jrmole beat me :)
18:39:15 <SamB> compile it to Glulx and write a GIT engine
18:39:50 <jrmole> compile it to a configuration of the rule 110 cellular automaton
18:39:58 <ndm> SamB: we already have compiled to .NET
18:40:01 <jrmole> or haskell typeclass declarations
18:40:14 <jrmole> or a series of tubes and valves
18:40:19 <ndm> and someone is working on JVM
18:40:19 <SamB> compile it to run on your cellular phone
18:40:28 <jrmole> SamB, most of them run java these days
18:40:30 <ndm> and someone is working on a cell phone
18:40:33 <jrmole> so what you said earlier ;)
18:40:40 <ndm> and someone on hardware, FPGA
18:40:49 <ndm> so we actually have most of those silly ideas already :)
18:40:53 <SamB> well, the point is that these are not very good ways to get runtime optimization for Haskell ;-)
18:41:27 <ndm> indeed, and runtime optimisation is the only way Yhc will ever compete with GHC on speed
18:41:32 <jrmole> the easiest runtime optimization is to wait 18 months ;)
18:41:50 <SamB> jrmole: it doesn't work though
18:41:59 <SamB> not unless someone buys you a new computer or something
18:42:02 <ndm> which GHC gets faster - its not about being fast, its about being fast relative to the competition :)
18:42:06 <jrmole> in the average case it does
18:42:15 <jrmole> but maybe the code gets 2x as complicated in that time
18:42:29 <jrmole> with many projects, that would be very slow progress ;)
18:43:18 <ell-hask> Are there any network daemon projects out there using Haskell?
18:43:49 <jrmole> can yhc compile ghc?
18:44:13 <ndm> jrmole: not by a long way - yhc is pretty much haskell 98
18:44:34 <ndm> if we could, it would be an easy way for GHC to do bootstrapping
18:45:10 <jrmole> does GHC use most of the extensions it implements?
18:45:30 <ndm> it uses quite a few, i think
18:45:40 <ndm> not the newest ones - its meant to compile back to GHC 5
18:45:47 <ndm> but thats still quite a lot of extensions
18:46:49 <jrmole> yeah, i get the impression a lot of the extensions were designed by the GHC team because they made writing GHC easier
18:47:47 <ndm> quite possibly, but they don't get to use a lot of their own extensions
18:48:32 <petekaz> ndm: I made my pastebin with hs-colour (I think you suggested this to me).  http://www.kazmier.com/~kaz/pastebin.cgi
18:49:06 <ndm> petekaz: neat!
18:49:16 <johnnowak> petekaz: looks lovely
18:49:29 <dgoldsmith> Things you can do at runtime you can't do statically include cross-module optimization and cross-module inlining.
18:49:46 <petekaz> thanks!
18:49:59 <ndm> dgoldsmith: JHC and GHC both do those already
18:50:17 <ndm> GHC limits the amount of cross-module stuff, but JHC doesn't
18:50:36 <ndm> but certainly, at runtime their are no module/package boundaries that have to be respected
18:50:45 <dgoldsmith> You can't do cross-module stuff at compile time if you have dynamic libraries.
18:51:15 <dgoldsmith> Obviously, if you compile and bind the whole thing in one big binary, you can do anything. :-)
18:52:00 <ndm> yeah, all Haskell compilers do the bigbinary blob at the mo
18:52:35 <dgoldsmith> ghc does support dynamic libraries on Darwin-PPC at the moment.
18:52:52 <jrmole> i got it to make a .so on linux/i386 with much hacking
18:53:23 <dgoldsmith> http://hackage.haskell.org/trac/ghc/wiki/Platforms
18:53:26 <lambdabot> Title: Platforms - GHC - Trac
18:53:38 <jrmole> had to have gcc do the linking though
18:54:06 <jrmole> and it supports .dll on Windows, or did at some point
18:56:53 <ndm> i think ghc and dynamic libraries is unadvised at the mo, for a while they've been prodding people towards a standalone .exe
18:57:08 <ndm> andthe .dll on windows is the entire program, just in .dll form - not using libarires through .dll's
18:58:59 <jrmole> yeah
18:59:19 <jrmole> well, on unix i imagine you can still use dlopen through ffi, if you're willing to work at that level
18:59:46 <jrmole> in fact, i assume ffi can link to functions in .so files directly
19:00:04 <jrmole> so it's the other direction that's the issue -- linking in haskell code dynamically
19:00:23 <jrmole> this kind of thing should be easy (or easier) with yhc's bytecode, yes?
19:01:41 <ndm> jrmole: oh, with Yhc's bytecode its trivially
19:01:58 <ndm> we do runtime linking anyway, and by default hoover up one .hbc file per module
19:02:43 <jrmole> so linking is something the VM implementation deals with?
19:03:50 <ndm> indeed
19:04:02 <ndm> at runtime, not compile time
19:04:16 <jrmole> well the target VM isn't even known at compile time
19:05:06 <ndm> how do you mean?
19:05:12 <ndm> we know we are producing for the Yhc VM
19:05:53 <jrmole> nm, said that wrong
19:06:13 <jrmole> i meant that you don't know what you're linking with at compile time
19:06:30 <jrmole> unless there's some intermediate step which links a bunch of bytecode together into one piece of bytecode
19:06:46 <ndm> we have that as an optional step
19:07:03 <ndm> aech bytecode archive externally links to things via names, and internally via positions
19:07:09 <ndm> you can combine many .hbc files into one
19:08:06 <jrmole> and this is done type-safely?
19:08:29 <jrmole> i.e., if two different chunks of bytecode define an algebraic type A, they can exchange values of type A iff their definitions are isomorphic?
19:09:05 <ndm> that is checked at compile time
19:09:19 <ndm> they have .hi files which link them up
19:09:24 <ndm> and they both specify which type A they use
19:09:28 <ndm> i.e. Data.Map.Map
19:09:36 <ndm> then the Data.Map module supplies the definitino
19:09:39 <ndm> and they both use that one
19:09:47 <ndm> so the type A has a strong name at runtime
19:11:44 <jrmole> if they both contain the line data A = ..., those are considered distinct even if they're both exported?
19:11:59 <jrmole> i guess that's obviously the correct thing to do
19:12:17 <jrmole> i'm just trying to work out how haskell namespaces would work in this hypothetical OS
19:12:34 <ndm> you can give everything a fully qualified name
19:12:52 <ndm> possibly even qualified with the package in there (for an OS thats probably needed)
19:14:51 <jrmole> i like the idea of one global module space, but i agree it's unwieldy
19:15:27 <jrmole> we can also choose packages on a per-process basis, as a way of implementing different process personalities
19:15:43 <coffeemug> hey guys
19:16:20 <Korollary> may lambda be with you.
19:16:27 <coffeemug> I'm trying to figure out how to properly use the error monad
19:16:36 <coffeemug> together with the state monad
19:16:45 <coffeemug> (or rather StateT)
19:17:27 <coffeemug> should I have StateT wrap Error
19:17:33 <coffeemug> or should I have ErrorT wrap State?
19:17:42 <jrmole> i did the former
19:18:10 <jrmole> http://www.nomaware.com/monads/html/standardxformers.html explains the difference well
19:18:12 <lambdabot> Title: Standard monad transformers
19:18:14 <coffeemug> if I go with the former every time I throw an error I'm going to have to lift that operation, correct?
19:18:46 <Pseudonym> Do you want throwing an error to restore state or not?
19:19:23 <jrmole> "Order is important when combining monads. StateT s (Error e) is different than ErrorT e (State s). The first produces a combined type of s -> Error e (a,s), in which the computation can either return a new state or generate an error. The second combination produces a combined type of s -> (Error e a,s), in which the computation always returns a new state, and the value can be an error or a normal value."
19:19:28 <coffeemug> I am reading that
19:19:43 <coffeemug> to restore state, what do you mean?
19:20:06 <Pseudonym> With ErrorT wrap State, State is at the bottom.
19:20:23 <Pseudonym> Which means that a computation which mutates state will always mutate state, even if it throws an error.
19:20:37 <coffeemug> aha, I see
19:20:38 <jrmole> and you won't even catch the error until you look at the value part
19:20:56 <jrmole> you could exec such a computation, look at only the final state, and never see any erros
19:21:03 <jrmole> which for most things is not what you want
19:21:25 <Pseudonym> If you StateT wrap Error, then throwing and catching an error will actually restore state.
19:21:40 <coffeemug> I see
19:21:40 <Pseudonym> This, incidentally, is why there is no IO transformer.
19:21:45 <coffeemug> right
19:21:47 <Pseudonym> You can't "undo" IO.
19:21:56 <coffeemug> heh
19:22:02 <Pseudonym> As Lee Naish used to say, you can't stick the paper back into the laser printer and pull the toner off.
19:22:05 <coffeemug> with haskell I get transactional support out of the box :-D
19:22:11 <Pseudonym> Yup.
19:22:18 <jrmole> coffeemug, you should do marketing
19:22:29 <Pseudonym> You wait till you see STM.
19:22:37 <coffeemug> yeah, STM is on my list
19:22:39 <Pseudonym> You get thread-safe transaction support out of the box.
19:22:40 <coffeemug> didn't get to it yet
19:22:54 <Pseudonym> Incidentally, Haskell's execution model is, basically, two-phase commit.
19:23:08 <coffeemug> I can use strings for errors, right?
19:23:14 <coffeemug> I can do throwError "hello"
19:23:18 <Pseudonym> You execute stuff, then as a final step, overwrite the redex with the result of the computation.
19:23:24 <Pseudonym> (That's called "update".)
19:23:29 <Pseudonym> Sure.
19:23:30 <jrmole> using Either for your concrete error type, you can choose any error type
19:23:38 <jrmole> concrete Error monad, i meant
19:23:52 <coffeemug> so at the following link
19:23:53 <coffeemug> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error.html
19:24:20 <coffeemug> there is a part where it says an instance of MonadError is defined for MonadState
19:24:40 <coffeemug> what's that about?
19:25:14 <jrmole> you mean MonadError e m => MonadError e (StateT s m) ?
19:25:29 <coffeemug> yes
19:25:30 <coffeemug> that bit
19:25:41 <coffeemug> and then there is (Error e, MonadState s m) => MonadState s (ErrorT e m)
19:26:09 <jrmole> the first one is just saying that you can StateT a monad with error handling, and your compound monad will also have error handling (that just passe sthrough to the inner monad)
19:26:16 <jrmole> means you do less lifting
19:26:37 <jrmole> because throwError works as well in your StateT Either as in the inner Either, or whatever you're using
19:26:49 <coffeemug> ahh, I see
19:26:58 <Pseudonym> Incidentally, it's worth it usually to spend a few lines and write meaningful operations for your monad.
19:27:06 <jrmole> that second line is almost exactly the converse of that
19:27:23 <coffeemug> Pseudo: what do you mean?
19:27:44 <Pseudonym> I mean rather than using the StateT primitives, for example, write some semantically meaningful operations instead.
19:27:48 <jrmole> this explains why i had only one lift in my entire stack machine interpreter
19:27:59 <jrmole> which used a StateT Either
19:28:22 <Pseudonym> Example:
19:28:41 <Pseudonym> type MyMon a = State (Foo,Bar) a
19:28:50 <Pseudonym> myGetFoo :: MyMon Foo
19:28:56 <Pseudonym> myGetFoo = reads fst
19:28:58 <Pseudonym> Or something.
19:29:02 <Pseudonym> gets, I think, not reads
19:29:05 <Pseudonym> ?type reads
19:29:06 <lambdabot> forall a. (Read a) => ReadS a
19:29:11 <Pseudonym> Errr...
19:29:13 <Pseudonym> ?type gets
19:29:14 <lambdabot> forall a (m :: * -> *) s. (MonadState s m) => (s -> a) -> m a
19:29:17 <Pseudonym> Right.
19:29:38 <Pseudonym> That's only a couple of lines, but if you decide to stack another transformer on, there's only one place you need to add a lift.
19:30:55 <coffeemug> ahh, I see
19:31:35 <Pseudonym> One of the nicest things about Haskell is that abstraction is cheap.
19:31:52 <Pseudonym> It costs very little to do something like that.
19:32:27 <coffeemug> yeah
19:32:37 <Pseudonym> But you get the same benefits that you'd get from building a proper ADT.
19:32:39 <dons> re
19:32:47 <coffeemug> ok
19:32:56 <coffeemug> I think I understand the difference in stacking monads
19:33:04 <coffeemug> thanks :)
19:33:19 <Pseudonym> No problem.
19:33:25 <coffeemug> ok, back to coding
19:33:26 <coffeemug> gn guys
19:33:29 <Pseudonym> Error and State aren't so difficult.
19:33:34 <coffeemug> thanks again
19:33:36 <Pseudonym> But there are others that are harder to work out.
19:33:37 <Pseudonym> No problem.
19:33:45 <coffeemug> I'll get there one day :)
19:41:33 <newsham> hi
19:53:23 <dons> http://www.tiobe.com/tiobe_index/index.htm interesting
19:53:23 <lambdabot> Title: TIOBE Programming Community Index
19:58:17 <lennart> i can't see haskell there
19:58:50 <lennart> oh, there it is!
19:59:03 <lennart> 0.077%
19:59:13 <dons> just below ocaml. not too shabby :)
19:59:24 <dons> and we beat ML
19:59:47 <lennart> and Bourne shell
20:00:44 <dons> and Clean and Erlang
20:01:05 <newsham> i'm gonna guess that there are more sh "programmers"
20:01:44 <dons> perl -4.57% trending down
20:02:20 <newsham> sounds dramatic but doesnt look huge on the chart
20:02:45 <newsham> also the c# trending down doesnt look dramatic on the chart
20:07:04 <lennart> flight tracking with google earth really is awesome :)
20:13:45 <JosephRivers> how does one use the "Infinity" value? When I type it at a prompt I get: Not in scope: `infinity'
20:14:29 <JosephRivers> sorry I mean the error is: Not in scope: data constructor `Infinity'
20:15:02 <lennart> where have you found this Infinity value?
20:15:26 <araujo> hello around here
20:15:38 <JosephRivers> Enter (1/0)  at the prompt; it returns Infinity, so there must be an Infinity value
20:15:47 <JosephRivers> I want to know the constructor for it
20:16:04 <lennart> there is no constructor for it
20:16:38 <JosephRivers> well, how do you enter it as a value. You must be able to since (1/0) results to it
20:16:38 <lennart> > 1/0
20:16:40 <lambdabot>  Infinity
20:16:51 <JosephRivers> that gives the error message above
20:16:52 <lennart> you can use 1/0
20:17:12 <lennart> > read "Infinity" :: Double
20:17:14 <lambdabot>  Infinity
20:17:18 <lennart> or that
20:17:30 <JosephRivers> that's kind of evasive though; i want to use the straight value
20:17:46 <lennart> there is no name for that value
20:17:55 <JosephRivers> why doesn't entering Infinity at the promt work?
20:18:04 <lscd> JosephRivers: that's exactly what a friend of mine ended up doing in ruby; it seems to be more or less standard to hack around it that way
20:18:39 <lennart> because Double is not a data type with any exposed constructors
20:18:58 <lennart> in fact, you can only get values of type Double by using expressions
20:19:24 <lennart> even when you type 1.2 it's not really a Doubkle
20:19:34 <JosephRivers> i guess I'll have to just use the expression 1/0--I wish there was a way to enter it directly though
20:20:11 <lennart> well, put the definition "infinity = 1/0" in a module and use that
20:22:13 <lennart> a reason that there is no such definition in the Haskell Prelude is that Haskell doesn't require the floating point types to have infinity
20:32:39 <dons> ?users
20:32:41 <lambdabot> Maximum users seen in #haskell: 235, currently: 192 (81.7%), active: 19 (8.1%)
20:35:10 <Korollary> active?
20:35:58 <Korollary> ?help users
20:35:59 <lambdabot> users [chan]. Report the maximum number of users seen in a channel
20:36:14 <Korollary> out of date docs. So typical. Haskell changes nothing!
20:36:45 <dons> active means "did speak in the last 4 hours"
20:37:06 <lscd> ah
20:37:10 <lscd> ?users
20:37:10 <lambdabot> Maximum users seen in #haskell: 235, currently: 192 (81.7%), active: 18 (7.7%)
20:37:34 <lscd> wow, it decreased since you ran it
20:38:05 <dons> someone hasn't spoken for 4 hours then
20:38:10 <dons> Korollary: Wed Aug 30 13:34:05 EST 2006  Don Stewart <dons@cse.unsw.edu.au>
20:38:10 <dons>   * improve docs. Stop Korollary whinging
20:51:01 <newsham> whinging or whining?
20:51:23 <dons> a little of a) and b)
20:51:36 <dons> ;)
21:10:58 * jcreigh Just finished "Gdel, Escher, Bach", but still can't pronounce "Gdel"...
21:18:59 <johnnowak> any pronounciation of his name is going to be incomplete anyway
21:20:12 <Pseudonym> It's impossible to prove that you've correctly pronounced his name from his name alone.
21:38:31 <dons> ?uptime
21:38:31 <lambdabot> uptime: 2 days, 2 hours, 26 minutes and 41 seconds
21:54:05 <araujo> @yarr!
21:54:05 <lambdabot> Splice the Mainbrace!
22:15:24 <foxy__> Pseudonym: couldn't an oracle provide the correct pronunciation?
22:57:20 <LordBrain> @pl if x then y else z
22:57:20 <lambdabot> if' x y z
22:57:26 <LordBrain> ah
22:59:25 <dons> if' x y z = if x then y else z
23:00:11 <LordBrain> @index if'
23:00:12 <lambdabot> bzzt
23:00:28 <LordBrain> @type if'
23:00:29 <lambdabot> Not in scope: `if''
23:00:38 <LordBrain> where is if' ?
23:01:01 <LordBrain> @index if'
23:01:02 <lambdabot> bzzt
23:01:46 <newsham> are there any compilers for iterative languages that use a functional representation internally for analysis?
23:02:10 <newsham> ie:  init; for(iter in list) update;   =>  foldl update init list
23:02:13 <Korollary> gcc's SSA is said to be a kind of functional language
23:02:53 <dons> yeah, SSA is isomorphic to ANF form, a pseudo-Core
23:02:54 <newsham> the SSA form gets rid of updates (makes new variables for each assignment) but doesnt transform looping into recursion
23:15:56 <lispy> dons: my lambdabot instance complains about "fd:9: hClose: resource vanished (Broken pipe)" when i try to use > to evaluate expressions.  What do i need to tweak?
23:24:04 <lispy> @where runplugs
23:24:04 <lambdabot> I know nothing about runplugs.
23:25:44 <dons> maybe you're hs-plugins isn't installed?  or borked in some way?
23:25:47 <dons> (on the mac??)
23:26:31 <lispy> dons: amd64 machine, i'll install hs-plugins or check if i already have it
23:26:53 <lispy> yeah, loks like i don't have it
23:26:54 <dons> then check the runplugs binary is built, and in the current directory
23:27:12 <lispy> thanks
23:27:16 <dons> (it won't have been built unless you a) installed hs-plugins b) used the lambdabot.cabal.plugins file
23:27:40 <dons> (we don't enable plugins by default, since that's easier on the home user who just wants to run a command line lambdabot, or GOA)
23:27:47 <lispy> oky, so i'm doing (a) now, and so i need to do (b) as well?
23:28:04 <dons> you'll need to: mv lambdabot.plugins.cabal lambdabot.cabal ; then configure;build;install
23:28:11 <lispy> gotcha
23:28:13 <lispy> thanks
23:28:33 <dons> maybe you'd like to add a little section to the README for users who want @run to work
23:28:52 <lispy> ah, good idea
23:29:02 <newsham> newsham@lenoxp$ echo "this is a test" | md5sum
23:29:02 <int-e> . o O ( 1. don't use a recent ghc 6.5 )
23:29:17 <lispy> dons: i was learning TH at work today
23:29:40 <dons> and don't use a ghc 6.5 newer than the 24th of last month
23:29:46 <lispy> i used the H98 parser to parse a file, look for "prop_" functions and thene generate cod to call them
23:29:48 <dons> (since hs-plugins isn't ported to the new .hi/package system)
23:29:54 <dons> lispy: cool!
23:29:55 <lispy> no worries
23:30:07 <dons> morning int-e
23:30:09 <dons> how's code?
23:31:12 <int-e> nothing new really. how'd the paper turn out?
23:31:38 <dons> still going. 4 days left. looking nice I think
23:32:03 <dons> this is turning into a 4-week-long-ICFP-contest-ish experience :}
23:33:04 <int-e> . o O ( dons must be coding all day and writing paper all night. )
23:33:18 <dons> something like that :S
23:40:12 <Korollary> ?users
23:40:13 <lambdabot> Maximum users seen in #haskell: 235, currently: 196 (83.4%), active: 11 (4.7%)
23:42:26 <monochrom> http://www.vex.net/~trebla/haskell/hxt-arrow/index.xhtml
23:59:31 <Korollary> Hmm, an arrows tutorial.
