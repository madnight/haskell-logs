00:02:32 <wolverian> ok, I'm feeling dumb. why doesn't concat . transpose do what I want?
00:03:24 <Cale> unsafeNoOp :: () -- ahahaha
00:04:04 <Cale> wolverian: what is it that you want?
00:04:32 <wolverian> I expected 'concat . transpose list' to do the same thing as 'concat (transpose list)'
00:05:13 <wolverian> ah. I see it is a precedence problem.
00:05:14 <norpan> you need (concat . transpose) list or concat . transpose $ list
00:05:20 <wolverian> thanks
00:05:40 <wolverian> ..is concat $ transpose list nicer?
00:05:41 <norpan> or, as you said, concat (transpose list) :)
00:05:58 <norpan> or concat $ transpose list
00:06:15 <norpan> what is nicer is really up to you
00:06:23 <wolverian> yeah. thanks :)
00:08:15 <Cale> But you should try to keep the number of $'s on a line to at most 1 if what you're really doing is composing functions and applying them to a value
00:08:36 <Cale> (of course, any of the suggestions here are fine)
00:08:53 <norpan> Cale: why? any technical reason for that?
00:08:57 <wolverian> mm. I tend to put $ before thinking about it.
00:09:01 <wolverian> (which is bad)
00:09:23 <Cale> It's just a style thing. I've found that it's easier to edit code when it uses . rather than $
00:09:39 <norpan> why is editing one easier?
00:09:46 <Cale> Because, for instance, you can quickly chop out the middle of a chain of compositions without editing it.
00:09:49 <edwardk> whats the cleanest way to turn c <- charEsc <|> charNum
00:09:49 <edwardk>         return $ Just c into a single statement?
00:09:53 <norpan> concat $ transpose $ lines $ ...
00:09:56 <Cale> but with $, the type is different
00:10:08 <Cale> transpose $ lines is nothing
00:10:15 <Cale> but transpose . lines is
00:10:18 <norpan> so?
00:11:21 <Cale> So it makes it just a little faster to factor that part out later if needed. It also makes it apparent when points-free forms are available
00:12:18 <wolverian> working with geometry is wonderful in haskell :)
00:12:35 <edwardk> wolverian: what are you doing?
00:12:50 <wolverian> learning opengl
00:12:55 <edwardk> ah fun stuff
00:12:56 <wolverian> (and haskell)
00:13:33 * edwardk is thinking about porting a bunch of weird pluckerspace math stuff to haskell. would probably be a lot shorter here
00:13:35 <Cale> It's sort of better in general to be thinking about functions rather than values, if at all possible, and composition emphasizes the manipulation of functions while application emphasizes values.
00:14:44 <mornfall> Cale: that's what you say ;-)
00:14:51 <edwardk> no ideas on how to clean up the do syntax above?
00:15:32 <edwardk> i kind of agree with cale on that. the biggest problem people have as they move to higher mathematics is thinking about functions in their own right without manipulating values.
00:15:48 <edwardk> haskell is pretty much just an exercise in higher mathematical thinking
00:16:02 <mornfall> what do you call higher mathematics
00:16:39 <edwardk> 'higher than rote memorization calculus work'
00:16:46 <mornfall> sure, there are places where composition is clearer than application, but i'd hardly generalize
00:17:25 <Cale> Well, in the cases we're talking about, the code is probably exactly as clear either way
00:17:45 <dons> ?users
00:17:46 <lambdabot> 191
00:17:59 <astrolabe> edwardk: the code looks quite short to me as it is.
00:18:11 <edwardk> astrolabe well, its a repeated idiom
00:18:14 <edwardk> i want to replace it
00:18:34 <astrolabe> where is the repeat?
00:18:46 <Cale> It's just that using a chain of compositions basically opens up a bunch of meaningful subexpressions that weren't there before, which is good when editing code.
00:19:59 <edwardk> astrolabe: its repeated in several places throughout the code, not within that snippet =)
00:20:00 <Cale> It's a minor point, really :)
00:20:27 <astrolabe> So set a variable to that value?
00:20:58 <edwardk> heh
00:21:00 <edwardk> nevermind
00:21:17 <edwardk> liftM Just $ charEsc <|> charNum
00:21:21 <edwardk> is what i was thinking of
00:21:26 <edwardk> i just couldn't remember the function for a sec
00:21:38 <astrolabe> Ah :)
00:21:55 <edwardk> that also lets me get rid of the do line above
00:21:59 <edwardk> which is what i was looking for
00:22:17 <astrolabe> It is nicer.  I didn't think of it.
00:23:45 <deathsstar> hi
00:23:53 <deathsstar> what is haskell?
00:23:58 <deathsstar> is it nicer than APL?
00:24:06 <norpan> yes
00:24:10 <dons> http://haskell.org <-- try that :)
00:24:14 <lambdabot> Title: Haskell - HaskellWiki
00:24:34 <edwardk> only problem is that <?> and $ cant be used in the same expression, so i get stuck with some crummy ()s
00:24:36 <edwardk> oh well
00:24:40 <edwardk> deathsstar: much
00:25:50 <deathsstar> is haskell nicer than clisp?
00:26:08 <dons> deathsstar: in #haskell, we definitely think so.
00:26:09 <norpan> deathsstar: we think so, that's why we hang here
00:26:12 <hellish> Depends on who you ask.
00:26:24 <hellish> What does <?> mean?
00:26:35 <hellish> Google won't search for punctuation...
00:26:39 <dons> its a lot newer language, and I think much more innovation is happening in Haskell
00:26:57 <edwardk> <?> is used in parsec to annotate the match with more information so it can give better error messages
00:27:07 <dons> ?users
00:27:07 <lambdabot> Maximum users seen in #haskell: 193, currently: 193
00:27:11 <dons> :)
00:27:19 <hellish> Ah.
00:27:39 <vincenz> dons: no we don't
00:27:45 <edwardk> stringLetter <|> stringEscape <?> "string character"  will fail with "expected string character" instead of expected "\\" or "...."
00:27:47 <dons> vincenz: ?
00:27:51 <vincenz> dons: we think that awk is the best programming language
00:27:58 <dons> oh, that's right. I forgot
00:28:10 <vincenz> dons: and that OSX is the ultimate os
00:28:16 <edwardk> yeah perl sucks, long live awk =)
00:28:18 <dons> oh , that too
00:29:13 <vincenz> Viva awk
00:47:53 <dons> ?users
00:48:19 <lambdabot> Maximum users seen in #haskell: 192, currently: 192
00:49:00 <dons> ?bot have a cookie
00:49:01 <lambdabot> :)
00:58:28 <norpan> 192 users and no-one to talk to
00:58:58 <dons> yow!
00:59:02 <dons> ?users
00:59:02 <lambdabot> Maximum users seen in #haskell: 193, currently: 193
01:11:44 <vincenz> @yow
01:11:44 <lambdabot> I just remembered something about a TOAD!
01:12:07 <vincenz> > replicate 193 "cookie"
01:12:08 <dons> ?users
01:12:09 <lambdabot>  ["cookie","cookie","cookie","cookie","cookie","cookie","cookie","cookie","co...
01:12:09 <lambdabot> Maximum users seen in #haskell: 194, currently: 193
01:16:05 <vincenz> I wish life was this easy
01:16:17 <vincenz> > "cookie" >>= replicate 193
01:16:18 <lambdabot>  "ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc...
01:16:20 <vincenz> ack
01:16:37 <vincenz> > return "cookie" >>= replicate 193
01:16:38 <lambdabot>  ["cookie","cookie","cookie","cookie","cookie","cookie","cookie","cookie","co...
01:20:31 <Cale> > replicate 193 () >> "cookie"
01:20:32 <lambdabot>  "cookiecookiecookiecookiecookiecookiecookiecookiecookiecookiecookiecookiecoo...
01:21:42 <Cale> so obviously,
01:21:44 <Cale> > replicate 193 () >> ["cookie"]
01:21:45 <lambdabot>  ["cookie","cookie","cookie","cookie","cookie","cookie","cookie","cookie","co...
01:22:06 <Cale> > replicate 193 () >> ["cookie","milk"]
01:22:07 <lambdabot>  ["cookie","milk","cookie","milk","cookie","milk","cookie","milk","cookie","m...
01:24:22 <vincenz> > ["cookie", "milk"] >>= replicate 193
01:24:24 <lambdabot>  ["cookie","cookie","cookie","cookie","cookie","cookie","cookie","cookie","co...
01:41:24 <dons> ?yow
01:41:24 <lambdabot> I have seen these EGG EXTENDERS in my Supermarket ...
01:47:56 <edwardk> you folks are really bored aren't you? =)
01:48:04 <leeghoofd> do you how I can write this without my own p function? p x = x*x   variantie lijst = sum (map p lijst)
01:48:27 <leeghoofd> if I use (^) it doesn't work
01:48:38 <leeghoofd> I think because ^ needs two args
01:49:01 <edwardk> @pointless \ x -> x *x
01:49:01 <lambdabot> join (*)
01:49:20 <edwardk> sum $ map (join (*)) list
01:49:54 <leeghoofd> aha, and join means double the args?
01:49:58 <edwardk> yeah
01:50:03 <leeghoofd> ok, thanks
01:50:03 <edwardk> @type join
01:50:05 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
01:50:37 <edwardk> well, you might have to heap and load Control.Monad.Reader
01:50:39 <edwardk> for that to work
01:50:45 <edwardk> because that the monad in question
01:51:03 <edwardk> its kind of a dirty trick =)
01:51:39 <leeghoofd> yeah, it says not in scope
01:51:44 <leeghoofd> so I have to load that
01:52:28 <edwardk> load Control.Monad.Reader and maybe Control.Monad and that will work =)
01:52:57 <beschmi> what about: sum $ map (^2) l
01:53:28 <edwardk> heh, thats cheating =)
01:53:31 <leeghoofd> I read about that I think
01:53:39 <leeghoofd> I will try
01:54:00 <leeghoofd> yeah, that works :)
01:54:34 <leeghoofd> stupid I didn't think of that because I had read something like that
01:54:41 <leeghoofd> thanks beschmi
01:57:47 <dons> ?users
01:57:48 <lambdabot> Maximum users seen in #haskell: 196, currently: 196
01:59:12 <edwardk> lambdabot's user count resets when you reboot her?
01:59:55 <edwardk> (we'd peaked out at like 225 the other day i why i ask)
02:12:43 <dons> nope. I only implemented this user tracking thing today
02:12:51 <dons> it should automagically persist across reboots
02:13:01 <edwardk> ah cool
02:13:23 <dons> (lambdabot plugin state are usually instances of Serial, which takes care of everything)
02:13:30 * edwardk nods.
02:13:48 <dons> I was just checking it worked :)
02:17:04 <dons> ?users
02:17:05 <lambdabot> Maximum users seen in #haskell: 198, currently: 197
02:19:09 <beschmi> just wondering how "join (*)" works. Is the Monad instance for "Monad ((->) a)" defined somewhere?
02:19:58 <dons> yes, there is!
02:20:03 <dons> ?instances Monad
02:20:05 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
02:20:11 <dons> oh, the very first one in our list
02:20:40 <dons> its in Control.Monad.Reader , for ghc < 6.5
02:20:52 <dons> ?source Control.Monad.Instances
02:20:53 <lambdabot> lambdabot 4p48, GHC 6.5 (OpenBSD i386 )
02:20:53 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
02:20:54 <beschmi> cool, thanks
02:21:01 <dons> ?fptools Control.Monad.Instances
02:21:02 <lambdabot> Control.Monad.Instances not available
02:21:09 <dons> ah, well, anyway, that's where it is now
02:21:21 <dons> instance Monad ((->) r) where
02:21:21 <dons>     return = const
02:21:21 <dons>     f >>= k = \ r -> k (f r) r
02:23:41 <beschmi> i see, then join (*) == (*) >>= id == \r -> id ((*) r) r
02:26:04 <foxy_> @djinn ((a -> b) -> a) -> a)
02:26:05 <lambdabot> Cannot parse command
02:31:05 <Stinger_> is it possible to write haskell without using the indentation rules?
02:32:43 <dons> yep
02:32:47 <dons> you can use explicit { ;;; }
02:33:02 <dons> > let { x = 2; y = 3; } in x + y;
02:33:03 <lambdabot>  Parse error
02:33:09 <dons> > let { x = 2; y = 3 } in x + y
02:33:11 <lambdabot>  5
02:33:20 <Stinger_> ah right knew you could use ;s a bit, but not {}s
02:33:40 <dons> they open up after  where, do, let, case
02:33:50 <dons> > case 1 + 2 of { z -> z+1; }
02:33:52 <lambdabot>  4
02:33:56 <Stinger_> yeah the specific instance I was thinking of was a case
02:34:16 <Stinger_> thanks
02:34:55 <dons> its commonly used in case to simulate a switch
02:35:16 <dons> > case () of { _ | 1 == 2 -> False ; | 2 == 2 -> True ; }
02:35:17 <lambdabot>  Parse error
02:35:21 <dons> > case () of { _ | 1 == 2 -> False | 2 == 2 -> True ; }
02:35:23 <lambdabot>  True
02:35:37 <dons> ?pretty f = case () of { _ | 1 == 2 -> False | 2 == 2 -> True ; }
02:35:37 <lambdabot>  f = case () of
02:35:38 <lambdabot>      _ | 1 == 2 -> False
02:35:38 <lambdabot>       | 2 == 2 -> True
02:35:46 <dons> not too bad, Ms. Bot.
02:36:51 <Stinger_> O_O
02:38:55 <Igloo> Is pretty using something from Language.Haskell?
02:40:57 <Stinger_> what are the |s for?
02:41:04 <dons> Igloo: yep
02:41:14 <dons> but then it gets munged by lambdabot's filters on the way out
02:41:20 <int-e> muhahaha. "Parse error" at column -17
02:41:20 <Igloo> Guards; that branch is bhosen only if the following expression evaluates to True
02:41:44 <Stinger_> oh, duh :/
02:41:58 <dons> > let f x | x < 3 = "Less than" | otherwise = "Otherwise" in f 4
02:41:59 <lambdabot>  "Otherwise"
02:42:06 <dons> same thingy
02:44:46 <int-e> @. pretty pl f = (\x. x x) (\x. x x)
02:44:47 <lambdabot> "Parse error" at column -17
02:45:20 <dons> ?pl f = (\x. x x) (\x. x x)
02:45:21 <lambdabot> (line 1, column 3):
02:45:21 <lambdabot> unexpected "="
02:45:21 <lambdabot> expecting variable, "(", operator or end of input
02:45:32 <dons> ?pl f x = x + x
02:45:32 <lambdabot> f = join (+)
02:45:38 <dons> ?@. pretty pl f x = x + x
02:45:44 <dons> @. pretty pl f x = x + x
02:45:44 <lambdabot>  f = join (+)
02:45:49 <int-e> ups. I actually meant -> instead of . but that works, too.
02:53:24 <dons> ?users
02:53:25 <lambdabot> Maximum users seen in #haskell: 201, currently: 201
02:54:28 <norpan> wow
02:54:32 <dons> ?quit test persistence
02:54:40 <dons> norpan: ?
02:54:56 <norpan> 200+ users
02:55:34 <dons> sure. we average 200+ these days
02:55:42 <dons> this is , what, a slow sunday? :)
02:55:54 <dons> ?users
02:55:54 <lambdabot> Maximum users seen in #haskell: 202, currently: 202
02:55:58 <dons> good bot!
02:56:07 <Igloo> Oh, that reminds me, do you have daily traffice graphs for #haskell, dons?
02:56:12 <dons> I do
02:56:14 <dons> ?where stats
02:56:15 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
02:56:25 <dons> it got very quiet around ICFP contest time, and this weekend...
02:56:32 <Igloo> Cool, ta
02:56:46 <Igloo> *nod*, I was just curious to see what AH did to the graph  :-)
02:56:55 <dons> it killed us ;)
02:57:26 <Igloo> Which way does this graph go?
02:57:39 <dons> hmm?
02:57:53 <Igloo> The top one on http://www.cse.unsw.edu.au/~dons/irc/haskell-06.html - which end is today/yesterday?
02:57:54 <lambdabot> Title: #haskell @ freenode.org stats by dons
02:58:21 <dons> ah, the right end , end 0 , is today
02:58:38 <dons> well, as of 3 hours ago
02:59:01 <Igloo> It doesn't look like it actually made a huge impact then
02:59:10 <Igloo> 2 weeks ago was worse
02:59:16 <Igloo> Oh, was that the contest?
02:59:16 <dons> yeah, icfp contest
02:59:18 <dons> right
02:59:19 <Igloo> OK
02:59:41 <Igloo> But 4 weeks ago was also quite low
03:00:16 <dons> I presume something about summer, and weekends, in the northern hemisphere?
03:00:24 <dons> (oh, also, no university down here as well)
03:00:27 <Igloo> Could be
03:00:36 <Igloo> How come?
03:01:04 <dons> winter break, finished 2 weeks ago
03:01:23 <Igloo> Ah, right. Does that PhD students?
03:01:36 <dons> nope
03:01:39 <dons> we''re stil here :)
03:01:43 <dons> in the cold, hacking away
03:01:56 <Igloo> :-)
03:02:07 <dons> notice we're starting to get more hugs questions on the list -- uni's back
03:02:14 <Igloo> heh
03:06:13 <dons> ?users
03:06:13 <lambdabot> Maximum users seen in #haskell: 202, currently: 202
03:09:15 <audreyt> how is sameTVar# implemented?
03:09:18 <audreyt> or sameMVar# etc
03:09:22 <audreyt> I can't seem to find it in the RTS
03:13:11 <dcoutts__> @yarr!
03:13:12 <lambdabot> Avast!
03:13:15 <dcoutts__> hia dons
03:13:15 <lambdabot> dcoutts__: You have 2 new messages. '/msg lambdabot @messages' to read them.
03:14:02 <dcoutts__> concatMapA via appendA hmm
03:16:17 <musasabi> audreyt: translateOp SameTVarOp             = Just mo_wordEq
03:16:44 <musasabi> audreyt: in ghc/compiler/codeGen/CgPrimOp.hs
03:19:27 <audreyt> danke
03:19:30 <audreyt> and mo_wordEq is cmm prim?
03:20:44 <audreyt> seems so
03:20:51 <audreyt> so it's just comparing
03:20:57 <audreyt> (unsafeCoerce# tvar :: Word)
03:21:26 <musasabi> mo_wordEq is the same thing as used to compare e.g. ints
03:21:30 <audreyt> that's good, that means pugs gets to use (unsafeCoerce# :: Word) to be the unique id of a container object
03:21:31 <int-e> mo_wordEq       = MO_Eq  wordRep
03:21:39 <int-e> cmm/MachOp.hs
03:21:50 <audreyt> as it already is stable, there's no need to StablePtr
03:21:57 <audreyt> (if I undersatnd this correctly)
03:32:30 <wolverian> ?where whyfp
03:32:31 <lambdabot> I know nothing about whyfp.
03:33:23 <dons> dcoutts__: yeah, we might have to do it another way
03:33:41 <dons> dcoutts__: anyway, lots of new fuseable things, inc. concatMap. but zipWith is a bit stubborn
03:34:06 <dons> also, most things are slower in one-shot mode, in their fuseable form, and will need rewriting back
03:36:40 <dons> dcoutts__: one of the decisions I made, which we might need to discuss, was I abandoned the possible resize in the inner loops. I think this means the 'hint' must actually be a maximum size.
03:36:50 <dons> so far it hasn't hurt -- and there's a big speed gain.
03:36:56 <dons> but probably we can't fuse unfoldr now
04:20:26 <audreyt> unboxed complex numbers. do they exist in some form?
04:20:54 <Heffalump> an unboxed tuple of unboxed ints?
04:21:07 <dons> data (RealFloat a) => Complex a
04:21:07 <dons>   = !a :+ !a
04:21:23 <dons> so well, no. no special support.
04:21:58 <dons> beyond having the components unboxed in the :+ constructor (at least for say, Int)
04:22:29 <dons> or Double.
04:25:43 <audreyt> but the :+ itself is boxed con
04:31:53 <foxy_> dcoutts__: If you recall I was having focussing troubles, I've got rid of the gtk-CRITICAL errors, but the new notebook page does not come to the front, even with notebookSetCurrentPage
04:56:43 <dons> ?users
04:56:44 <lambdabot> Maximum users seen in #haskell: 204, currently: 201
04:59:46 <vincenz> dons: that total is kept over lambdabot reboots?
05:06:12 <Heffalump> does TH see explicit type signatures the user gave?
05:06:32 <audreyt> dons: so the only unicode-aware fps is currently http://www.ii.uib.no/~ketil/src/fps/Data/ByteString/UTF8.hs ?
05:06:41 <audreyt> or is there some other code somewhere else?
05:08:08 <musasabi> wasn't there SoC work on that?
05:08:08 <Igloo> Heffalump: Yes
05:08:32 <Heffalump> if it chooses to ignore them and then messes up the types of the things referred to, does it break?
05:10:15 <Igloo> I don't follow
05:10:33 <Igloo> GHC doesn't remember what types things had when they are quasi-quoted and then spliced back in again
05:11:09 <Heffalump> but the abstract syntax that TH sees have type signatures?
05:11:20 <Igloo> Yes
05:11:41 <Heffalump> and what happens if it returns abstract syntax with invalid type signatures? Presumably GHC will refuse to accept it.
05:11:49 <Igloo> Right
05:11:56 <Igloo> Just as if you wrote code with invalid type sigs
05:12:06 <Heffalump> and given that there are situations where type sigs are needed, I can't just strip them out
05:12:16 <Heffalump> though that'll probably do for a first approximation
05:12:32 <Igloo> What are you trying to do?
05:17:46 <vincenz> hi
05:22:13 <Heffalump> Igloo: the run idea I mentioned at AG
05:22:15 <Heffalump> s/AG/AH/
05:22:45 * Igloo doesn't remember
05:24:01 <Heffalump> define run :: Monad m => m a -> a
05:24:18 <Heffalump> and then translate it away with TH
05:25:26 <foxy_> does 'darcs dist' grab a pristine copy or the latest (possibly unrecorded) version?
05:27:50 <Igloo> Ah, right
05:30:40 <kpreid> Heffalump: you mean like "print (run getArgs)" -> "print =<< getArgs"?
05:34:40 <Heffalump> I'm not sure my basic idea would easily handle that.
05:34:45 <Heffalump> But it probably could be done.
05:35:18 <Heffalump> I want to turn an expression of type a with embedded run calls into one of type m a where the run calls have been translated away
05:36:31 <kpreid> I'm just wondering what sort of embeddings you'll handle
05:41:48 <roconnor> @vixen I'm lonely.
05:41:48 <lambdabot> Crazy little wanker!
05:56:42 <Heffalump> is http://www.haskell.org/ghc/docs/latest/html/users_guide/template-haskell.html out of date?
05:56:44 <lambdabot> Title: 7.6. Template Haskell
05:57:02 <Heffalump> it claims that [| ... |] is of type Expr but that doesn't exist. It actually seems to be of type Q Exp.
05:57:12 <Heffalump> Which is a bit odd since why would the input need to be in Q?
05:57:51 <int-e> @type [| 1+1 |]
05:57:53 <lambdabot> parse error on input `|'
05:58:11 <musasabi> int-e: Q Exp
05:59:43 <Heffalump> but why the Q?
06:00:08 <int-e> dons: Why does runplugs have the -fth flag if the parser in run doesn't like template haskell anyway?
06:00:40 <int-e> Q is a monad that allows access to the symbols that are currently in scope, for all I know.
06:01:36 <int-e> @type Language.Haskell.TH.runQ
06:01:37 <lambdabot> forall a (m :: * -> *). (Language.Haskell.TH.Syntax.Quasi m) => Language.Haskell.TH.Syntax.Q a -> m a
06:01:56 <int-e> or something closely related.
06:02:07 <musasabi> and reification.
06:02:34 <Heffalump> I still don't see why the result of [| |] is in Q.
06:02:49 <Heffalump> I can see why you'd want to pass Q Exp to $( ... )
06:07:42 <int-e> can [| |] contain $() ?
06:10:19 <musasabi> yes
06:10:32 <musasabi> [d| encode z = getCacheOffset z encodeInt32 ($(expForConsCaseAndEachMember dname (\_ i -> [| encodeInt32 (toEnum i) |]) (varE fn)) z)  |]
06:10:37 <musasabi> for an example
06:14:23 <Igloo> Heffalump: Name generation
06:14:49 <Igloo> Also, [| ... $( ... ) ... |] needs to desugar to monadic code
06:15:12 * Heffalump is rather more convinced by the latter explanation
06:15:30 <Heffalump> [| ... |] shouldn't need name generation without embedded $( ... )
06:15:34 <Heffalump> should it?
06:16:19 <Igloo> It wouldn't technically need it, but [| \x -> \x -> x |] gives you two different names for x
06:16:30 <Heffalump> ah, ok
06:18:30 <Heffalump> errm, stupid question, but how do I get a fresh Name?
06:19:46 <int-e>   qNewName :: String -> m Name ?
06:19:46 <Heffalump> oh, newName. Must have looked right past it.
06:20:00 * int-e wonders
06:20:12 <Igloo> Unless you want it to be the same name that you get by writing "x" in the source, in which case you want mkName
06:20:16 <int-e> yeah, newName looks good.
06:20:23 <int-e> newName s = Q (qNewName s)
06:25:17 <Heffalump> why does LamE take a list of patterns? Syntactic sugar?
06:25:56 <Igloo> Because you can say \x y z -> e
06:26:25 <Igloo> The syntax tree is full Haskell
06:26:34 <Heffalump> ah, I see
06:26:40 <Heffalump> what's ListP?
06:26:52 <Igloo> The pattern [x, y, z]
06:26:58 <Igloo> (P == Pattern)
06:27:06 <Heffalump> why not use ConP?
06:27:15 <Heffalump> oh, syntactic sugar again
06:27:16 <Heffalump> ok.
06:30:42 <vincenz> it's odd to have sugar in coreforms
06:34:14 <Heffalump> wow, this actually works.
06:37:15 * Heffalump tries to understand Control.Monad.Writer
06:38:02 <Igloo> Surprised by code working and having trouble understanding monads? Anyone would think you were a C programmer  :-)
06:38:47 * Heffalump decides to just use a State monad instead
06:39:44 <Killer666> you can pass whole your program state through functions as argument
06:39:57 <Heffalump> Killer666: ?
06:40:12 <musasabi> State is much easier than Writer
06:42:40 * Heffalump tries to resist the temptation to use his translator to define itself
06:43:01 <Igloo> :-)
06:43:19 <Heffalump> it'd be cool, cos the evaluation order would be self-defining then
06:50:10 <postman> int-e: How exactly did you intend to keep track of the _unnumbered_ vertices? Since every time you have some vertex you only need to increase the weight of the unnumbered vertices. I did implement those constant time operations already.
06:50:51 <Heffalump> @hoogle (a -> m b) -> (f a -> m (f b))
06:50:52 <lambdabot> No matches, try a more general search
06:57:27 <audreyt> is there a reason why "Ord TypeRep" can't be trivially offered?
07:01:51 <musasabi> audreyt: making people frustrated?
07:02:28 <musasabi> "show . typeOf" works in practice, but it is dirty.
07:02:39 <audreyt> yeah.
07:02:51 <audreyt> but I imagine that they didn't simply expose the !Key
07:02:58 <audreyt> is because somehow it doesn't guarantee ordering
07:03:07 <audreyt> but I don't see why, as long as the types are loaded in the same order
07:03:39 <musasabi> maybe because the ordering may vary between different runs of the program (probably)
07:04:30 <musasabi> asking on the ML could help
07:04:37 <audreyt> k.
07:10:26 <void> is there a totorial on networking with haskell?
07:10:30 <void> *tutorial
07:11:27 <musasabi> void: it works mostly the same way as in C and other languages using sockets.
07:11:36 <int-e> postman: if you don't have them already numbered, you can add them to the array as you go (keeping track of all vertices with weight >= 1)... it'll be a bit more complicated, but doable.
07:12:33 <int-e> postman: you might want to turn around the array for that, so you can start filling and consuming the vertices from the start.
07:12:51 <void> musasabi: yeah, bur just some basic structure to get me going... how to send recieve data (all usring Ptr a?)
07:14:03 <int-e> postman: but usually I'd assume the vertices are available in an array or easily stored in one (say, if they're given as a linked list)
07:14:05 <musasabi> you can use 1) Ptr, 2) String
07:14:58 <void> musasabi: ah so I do hGetBuf handle mystring 256
07:19:07 <postman> int-e: Currently, I have the graph in a Data.Graph.Inductive.Tree structure. Thus alternatively, I could first copy this structure to an array equivalent, and move unnumberered elements to the end of this array and also keep an index (separating the numbered and unnumbered vertices)
07:20:42 <postman> int-e: I don't really see how keeping track of all vertices with weight>=1 would help. Because the very querying whether something is unnumbered already becomes inefficient.
07:20:51 <int-e> I still haven't looked at D.G.Inductive. So I don't know what the best way there would be.
07:21:30 <postman> int-e: I only use that non-constant lookup structure, because it has a nice interface.
07:21:43 <postman> int-e: I might implement an array backend later.
07:26:05 <postman> int-e: how do you make sure you don't visit a numbered node ever in your setup? Your description seems vague.
07:26:33 <int-e> postman: the visited vertex falls off the list, in a manner of speaking.
07:27:50 <int-e> postman: setting l to l-1 amounts to deleting the last element of the array - which is the vertex that's being picked.
07:27:57 <postman> int-e: I mean that somewhere the neighbor relations need to be stored.
07:28:57 <int-e> postman: an obvious data structure that works is: vertices are stored in a linked list and have a linked list of edges (which point to neigbouring vertices) associated with them.
07:30:15 <postman> int-e: you mean that vertices are stored in an array?
07:30:30 <int-e> i.e. data Edge = To Vertex; data Vertex = Vertex Label [Edge]; data Graph = [Vertex]
07:30:55 <int-e> postman: nah, I'm happy with traversing that list once (to store the vertices in an array) for the algorithm.
07:33:18 <int-e> hmm. pointer comparisons don't work in Haskell ... To Vertex is bad - should use some Vertex Id instead.
07:35:36 <postman> int-e: so you still get an array?
07:36:01 <postman> int-e: (where the Id needs to point to)
07:37:12 <int-e> Yes.
07:40:15 <postman> int-e: and making something "unnumbered" now amounts to?
07:42:46 <int-e> Nothing. You just put all nodes on the v[] array - that makes them 'unnumbered'.
07:43:15 <int-e> You might need another array to keep track of the mapping of Vertex Ids to the index in the v[] array.
07:45:21 <postman> int-e: I mean that somewhere in the algorithm you need to increase the weight by 1 of all unnumbered vertices connected to the chosen vertex. I really don't see where you do that.
08:01:25 <postman> int-e: I was wrong. It's not bad to visit a numbered vertex multiple times.
08:18:05 <dons> ?users
08:18:05 <lambdabot> Maximum users seen in #haskell: 209, currently: 209
08:18:26 <roconnor> ?users
08:18:26 <lambdabot> Maximum users seen in #haskell: 209, currently: 208
08:27:39 <audreyt> if I have a TypeRep, and a class with a method that does not care about the actual value
08:27:41 <psi> I have seen higher
08:28:00 <audreyt> x :: TypeRep; class C a where meth :: a -> Int
08:28:20 <audreyt> the meth body does not actually look into the value
08:28:25 <audreyt> is there an easy way to get the Int from x?
08:30:07 <audreyt> one that does not involve hs-plugins, preferably :)
08:31:41 <roconnor> meth undefined
08:31:45 <roconnor> ?
08:31:52 <musasabi> audreyt: like this: ?
08:31:57 <musasabi> data Proxy t = t
08:32:11 <musasabi> class Typeable f => Dep f t | f -> t
08:32:51 <musasabi> and then you can have code like: foo :: Dep a b -> Proxy a -> M b
08:33:09 <audreyt> mm...
08:33:10 <musasabi> (Typeable there if you need to do things with the types like storing them in a Map(
08:33:47 <musasabi> http://www.cs.helsinki.fi/u/ekarttun/haskell/TLS/TLSVar.hs has that approach. (dirty code)
08:34:13 <audreyt> well, I just wrote instance Data/Eq/Ord for existentials
08:34:21 <audreyt> so dirty code is welcome :)
08:34:30 <lisppaste2> int-e pasted "MCS (for postman)" at http://paste.lisp.org/display/23733
08:34:38 <postman> int-e: v[i] has no meaning here, right? swap v[idx[w+1]-1] and v[i]
08:35:47 <audreyt> musasabi: gotcha. thanks!
08:36:42 <postman> int-e: nm, thanks, although, I'd rather have done it myself. I hope I learn something of it.
08:37:03 <int-e> postman: then don't look at it. but all those little technical questions are no fun.
08:37:36 <postman> int-e: I can imagine that.
08:40:27 <int-e> hmm, somehow such imperative style haskell code ends up hardly readable very easily.
08:41:05 <int-e> well, array handling code really.
08:41:08 <postman> int-e: I think it's redundant explicitness.
08:42:55 <postman> int-e: asSTA is to avoid adding type signatures?
08:43:04 <int-e> yes
08:43:39 <int-e> @index newListArrayST
08:43:40 <lambdabot> bzzt
08:45:59 <int-e> postman: and the dummy argument of mcs' has the same purpose - it deals with the monomorphism restriction. (I would think twice before doing that in serious code)
08:47:59 <postman> int-e: You see it as a bad thing?
08:48:18 <int-e> postman: adding a type signature seems a bit cleaner.
08:49:32 <int-e> postman: the asSTA is good however (although I have a different name usually)
08:52:10 <postman> int-e: Ok, I understand both tricks, but this only shows how much experience I lack.
08:52:42 <Una^> hey guys, got a course of functional programming coming up and was wondering if you could recommend a good book.. my uni recommends Simon Thompson, Haskell: The Craft of Functional Programming. Is this worth getting or are there any better ones?
08:53:21 <postman> This is also a bit of a hack, right? loop (-1) acc = return (reverse acc)
08:53:35 <int-e> not a hack at all
08:53:43 <postman> It only gets called once at the end, right?
08:53:59 <int-e> yes. and it returns its accumulated result
08:54:36 <Krunch> Una^: http://mitpress.mit.edu/sicp/full-text/book/book.html
08:54:37 <lambdabot> Title: Structure and Interpretation of Computer Programs
08:56:05 <Stinger_> if they recommend a haskell book, they're probably using haskell :P
08:56:25 <Una^> Krunch, yeah had a look at that.. seems more for scheme/lisp though I guess the principles are pretty similar
08:56:38 <postman> int-e: hmm, I thought that adding a reverse to the end would be nicer, but then you would still need to have a way to escape out of the loop.
08:57:03 <postman> int-e: and in that case your solution is good.
08:57:10 <Krunch> Una^: depend if you need to learn functional programming or haskell :)
08:57:56 <int-e> postman: I consider the reversal to be part of what the loop does. I wouldn't add other processing there.
08:58:38 <Una^> Krunch, yeah indeed.. know any good haskell specific books?
08:59:48 <Stinger_> theres the haskell school of expression
09:00:29 <Stinger_> which I've been reading, not bad
09:00:49 <Stinger_> doesnt go into anything TOO tricky though
09:01:50 <Una^> k might check that out ty
09:02:31 <Stinger_> how many unis are teaching haskell these days?
09:02:45 <therp> una: I like "The Craft of Function Programming"
09:02:57 <Una^> in england - most of the top ones teach some sort of functional at one point
09:03:17 <Una^> haskell and ML I think are the main languages used
09:03:44 <Krunch> Stinger_: i know at least one in Belgium (i was surprised) but it looks like others are using scheme instead
09:03:46 <therp> una: I'm a long term programmer and have experience in common lisp, so it wasn't hard to bit throught the book in one week, basically without any haskell knowledge before
09:03:57 <therp> s/bit/bite/
09:04:17 <Stinger_> yeah we did scheme
09:04:20 <Una^> therp, ahh this will be the first functional language I have done..
09:04:35 <therp> una: any experience with lisp/ml before?
09:04:58 <Una^> none, only used procedural languages before
09:05:27 <LordBrain> c++?
09:05:45 <Una^> java/c++/little bit of 6800 asm :P
09:05:52 <Una^> 68k even
09:05:55 <LordBrain> procedural i usually think of pascal and c
09:05:58 <Krunch> Una^: you might want to learn some scheme before going to haskell, it's a really simple language, good to start learning functional programming
09:06:06 <Una^> and c ofc ;p
09:06:27 <therp> una: ah nevermind, the book is ok for you I guess. will take awhile to get use to the non-return statement based code flow and higher order functions are likely to be new.. however, setup an emacs and a haskell implementation, then you should be fine
09:06:48 <LordBrain> i dont know Krunch, if you want to get the functional idioms, haskell might be better, because in scheme you dont have to program in a functional style.. there's always the temptation to slip into an old habit.
09:07:50 <Una^> therp, ok thanks
09:08:07 <therp> lordbrain: yes true, but gradual conversion is possible :) while haskell might offer frustration to the spotless mind
09:08:10 <LordBrain> tho i started out in ocaml, and then scheme.. and then came to haskell
09:08:20 <LordBrain> yeah, i suppose you are rihgt
09:09:13 <therp> for me, basic (8yrs old), pascal (12yrs), C (15yrs), java (18yrs), common lisp (24yrs), haskell (25yrs old). that's no joke. it's like the programming languages are growing with me :)
09:09:28 <LordBrain> cool
09:09:32 <LordBrain> i started with basic around 12
09:09:43 <therp> I tried C++ when I was 13 but that didn't work out very well
09:10:01 <LordBrain> then came pascal, and then asm... and then c
09:10:04 <therp> I didn't get the idea of polymorphism and what it'd be good for. the book I had was bad though.
09:10:18 <kowey> well, I am relieved not to be the only brain-damaged raised-on-basic kid around here
09:10:32 <Stinger_> hehe yeah me too
09:10:45 <therp> I didn't mention x86 asm, ibm host assembler, PL/I and cobol in my list :) only the stuff I did programming for pleasure in
09:10:50 <Stinger_> basic -> c64 asm -> x86 asm :)
09:11:15 <daniel_larsson> basic -> 6502 asm -> pascal -> modula-3 -> C -> ML -> C++ -> Python -> Haskell. Fun to be back in functional programming again :)
09:11:41 <therp> when I was 14yr I coded up a brute force password cracker for novell networks in x86 asm. that was fun. it didn't work at all, but it was nice :) - oh I guess I'm off-topic
09:12:00 <LordBrain> i did asm for pleasure... it was really nice to see programs go fast... basic is really really slow, and even the compilers werent fast enough for me on that 1.3 mhz 8088 or whatever it was i had..
09:12:30 <LordBrain> besides, in dos, asm is hwere its at.. how else to make TSRs and things..
09:12:31 <therp> wow 8088. I started with 6.77mhz 8086
09:12:59 <LordBrain> well i cant remember the mhz
09:13:06 <LordBrain> it might have been more in that ball park
09:13:18 <LordBrain> the original 8086's were slower
09:13:39 <therp> hach *sigh* childhood memories
09:14:01 <LordBrain> hmmm i've now forgotten the difference between the 8088 and the 8086, they were extremely close, and its possible you had an 8088 without realizing.
09:14:13 <therp> 8086 = 8088 + 16 bit addressing
09:14:25 <daniel_larsson> 8088 was crippled somehow? ahh, that may be it )
09:14:52 <therp> 8086 was after 8088 iirc, despite one might conclude otherwise from the type numbers
09:15:17 <LordBrain> hmmm thats not what i heard
09:16:04 <therp> ah ok, but it's inferior to 8086 right?
09:16:21 <therp> http://en.wikipedia.org/wiki/8088
09:16:23 <LordBrain> hmm maybe wikipedia can tell us
09:16:35 <LordBrain> hah, we're in sync
09:16:35 <therp> encyclopedias kill conversations :)
09:17:25 <LordBrain> i think mine was at the 6.77mhz
09:17:30 <LordBrain> like your 8086
09:18:09 <LordBrain> it was not too bad for that class of computers.. i've programmed some which were slower and had like 1.5mhz or what not
09:18:40 <LordBrain> the nice thing about computers then, is we didnt need big fans
09:19:17 * Krunch still has a fanless Pentium
09:19:41 <LordBrain> really?
09:19:53 <LordBrain> it's still going?
09:19:57 <LordBrain> hehe
09:20:01 <Krunch> well actually it had a fan, but i noticed it didn't work several months after it stopped working
09:20:15 <LordBrain> hah
09:20:18 <Krunch> i removed it, no problem, the machine is still running
09:20:25 <LordBrain> cool
09:20:42 <LordBrain> that's probably as fast as you can get without a fan
09:21:08 <LordBrain> i had a fan die on a p2 once, and you know the cpu went with it.
09:21:19 <Krunch> no, i think some recent VIA cpu are fanless
09:21:27 <LordBrain> oh
09:21:59 <dottedmag> Krunch: And they are as fast as old Pentimus :)
09:22:23 <lde> p3 coppermine doesn't need a fan
09:23:34 <therp> krunch: I had a p4 1.8 without a fan. there a few fanless designs out there, no problem for fanless until about 65W thermal design power
09:23:35 <Krunch> i think some people build a giant radiator just to be able to say they could run a fanless P4
09:24:32 <Jormunder> hell :: IO a -> a ?
09:24:32 <Jormunder> :P
09:25:20 <LordBrain> unsafePerformIO
09:25:32 <LordBrain> @type unsafePerformIO
09:25:37 <lambdabot> Not in scope: `unsafePerformIO'
09:25:54 <LordBrain> oh well
09:26:00 <LordBrain> @hoogle unsafePerformIO
09:26:01 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
09:26:02 <lde> @type Foreign.unsafePerformIO
09:26:03 <lambdabot> forall a. IO a -> a
09:26:10 <Jormunder> wow
09:26:52 <Jormunder> unsafePreformIO = hellGates
09:26:53 <Jormunder> :P
09:27:18 <LordBrain> i suspect its useful for FFI programming
09:31:34 <SamB> LordBrain: quite so
09:32:51 <SamB> for instance, some things use pointers to pass values in/out
09:33:05 <SamB> but may be pure otherwise
09:33:10 <LordBrain> hmmm how would people feel about yi using PCRE instead of posix regexes?
09:33:29 <LordBrain> i see
09:34:26 <SamB> of course, you can use unsafePerformIO for many things that are externally pure but internally impure, not just FFI
09:34:42 <LordBrain> yeah
09:34:43 <SamB> but FFI made it pretty much essential that it be standardized
09:36:13 * SamB wonders if Debug.Trace qualifies as pure
09:36:58 <Heffalump> depends on your definition of pure :-)
09:36:58 <int-e> of course not
09:37:01 <sieni> LordBrain: that would be a good idea ;-)
09:37:12 <SamB> I'd have to agree with Heffalump on this one ;-)
09:37:34 <Heffalump> nothing is really pure, in the sense of "free of all observable side-effects"
09:37:35 <SamB> it depends on whether writing to stderr is considered impure or not ;-)
09:37:39 <Heffalump> they use memory and time
09:37:46 <kpreid> it's all a matter of what layer you're working at
09:38:11 <kpreid> all you have to do is make sure that you can draw a layer boundary above all your uses of unsafePerformIO :)
09:38:24 <SamB> it is of course referentially transparent
09:38:41 <int-e> trace ?
09:39:12 <SamB> int-e: yeah, I'm talking about trace
09:40:31 <SamB> The trace output doesn't change the values of expressions in any way
09:40:38 <int-e> referential transparancy is only concerned about values. so ... yes.
09:41:15 <SamB> sure, optimizations will possibly alter the trace output
09:41:17 <int-e> and with my 'IO is outside of the pure world' view I should probably agree that it's pure, too.
09:41:18 <SamB> but who cares?
09:41:23 <int-e> But I feel differently :)
09:41:25 <SamB> or rather, isn't that what you want anyway?
09:41:57 <SamB> of course... isn't pure if you were planning on doing some important output on stderr ;-)
09:42:04 <LordBrain> it would be good for programmers... vi/vim users might wonder why s/(stuff)/[stuff] doesnt work...
09:43:15 <LordBrain> power-users might appreciate it tho, if they're going to learn regexes all the way and make use of groups anyway... might be nice they dont have to put backslashes in.
09:43:22 <SamB> oh hmm
09:43:26 <int-e> Heh, I can't really prevent other programs writing there anyway (at least with Linux. /proc/*/fd/* exist)
09:43:28 <SamB> I just realized something...
09:44:13 <SamB> how do I delete only *one* item from a list, by value?
09:44:17 <int-e> hah. I'm being silly :)
09:44:43 <LordBrain> List.delete
09:44:43 <Igloo> SamB: delete
09:45:01 <SamB> > delete 1 [1,1,1]
09:45:04 <lambdabot>  [1,1]
09:45:06 <SamB> oh, okay.
09:45:09 <SamB> thats nice
09:45:12 <SamB> thats what I do already
09:45:28 <int-e> > delete 2 [1..]
09:45:29 <lambdabot>  [1,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
09:46:02 <SamB> int-e: it is important that only one be deleted
09:46:17 <SamB> even if multiple entries exist for that value
09:46:26 <int-e> SamB: yes, I got that. But it's useful for infinite lists, too :)
09:46:53 <SamB> int-e: oh, yeah, that does keep your lists from getting ever slower
09:46:54 <int-e> (at least in theory. I'm not sure if I can come up with a real use case)
09:47:04 * Heffalump finishes implementing the first attempt at "run"
09:47:21 <SamB> at least, if you are deleting items you've actually seen in the list
09:47:22 <Heffalump> http://urchin.earth.li/darcs/ganesh/runmonad/ (darcs gettable)
09:47:24 <lambdabot> Title: Index of /darcs/ganesh/runmonad
09:47:48 * SamB is glad he didn't stop his program yet
09:48:15 <lispy> ganesh?
09:48:22 <Paltas> > ['a'..]
09:48:23 <lambdabot>  "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137\...
09:48:58 <SamB> that idiot solver is having trouble with one of the puzzles
09:49:06 <SamB> ... again
09:49:12 <lispy> > take 100000 ['a'..]
09:49:14 <lambdabot>  "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137\...
09:49:27 <lispy> > ['a'..] !! 10000000
09:49:28 <lambdabot>  Exception: Prelude.(!!): index too large
09:49:33 <lispy> > ['a'..] !! 100000
09:49:34 <SamB> I think
09:49:34 <lambdabot>  '\100097'
09:49:46 <Heffalump> lispy?
09:49:48 <SamB> or I misspelled RS232 adapter, but I think I checked for that already
09:50:38 <lispy> Heffalump: hi! :)
09:50:55 <Heffalump> [17:47] <lispy> ganesh?
09:51:00 <Heffalump> what was that about? :-)
09:51:01 <int-e> oh, that solver.
09:51:01 <lispy> Heffalump: isthat your name?
09:51:04 <Heffalump> yes
09:51:07 <lispy> Ah
09:51:11 <Heffalump> doesn't /whois tell you that?
09:51:12 <SamB> perhaps it does not deal well with parts that are so broken being wanted
09:51:24 <lispy> Heffalump: i didn't even suspect it was part of your name
09:51:35 <Heffalump> ah
09:51:42 <lispy> Heffalump: i thought of hindu god...
09:52:35 <Heffalump> it's not that uncommon for people to be named after it
09:52:50 <lispy> Heffalump: so i assume you're indian?
09:52:57 <Heffalump> my parents are Sri Lankan
09:53:02 <lispy> ah
10:04:06 <Heffalump> hmph, Exp etc have no Typeable instances
10:08:38 <emertens> Are there penalties associated with -fno-monomorphosim-restriction
10:08:57 <emertens> -fno-monomorphism-restriction (of course)
10:12:12 <SamB> not really
10:12:22 <SamB> except that your code might not work without it
10:12:47 <emertens> should I try to write my code in a way that doesn't require it?
10:12:53 <SamB> well, if it results in the inference of overloaded types, that could
10:14:05 <SamB> the penalty being that most implementations are slower when dealing with overloaded types, at least sometimes...
10:14:08 <emertens> I just didn't know if it was a restriction left over from long ago, or if there was some penalty to removing it
10:14:37 <SamB> many people would like for it to be lifted
10:14:39 <emertens> @hoogle either
10:14:40 <lambdabot> Prelude.either :: (a -> c) -> (b -> c) -> Either a b -> c
10:14:40 <lambdabot> Prelude.Either :: data Either a b
10:14:46 <Heffalump> no, people are still discussing whether to keep it or not, it's not an obvious decision
10:14:53 <Heffalump> and not for legacy reasons, either
10:15:23 <emertens> I noticed a bit of the discussion in "History of Haskell" but I wasn't sure what was decided on
10:15:25 <SamB> maybe it should just be optional
10:15:46 <musasabi> The haskell-prime mailing list had a long discussion about it
10:16:21 <dons> ?users
10:16:22 <lambdabot> Maximum users seen in #haskell: 216, currently: 216
10:16:32 <dons> well, seems to work. good-o
10:16:33 <SamB> the motivation was something to do with overloaded constants not being memoized or something like that?
10:17:09 <Heffalump> I think there were some issues with making certain things typeable, too
10:17:18 <SamB> Heffalump: oh?
10:17:19 <Heffalump> dons: btw, how is haskell-prime coming along?
10:17:20 <emertens> is it related to type signatures being closed?
10:17:24 <Heffalump> SamB: I can't remember.
10:17:37 <emertens> instead of type variables having lexical scope?
10:17:47 <SamB> but... who is the 216th user?
10:17:59 <dons> Heffalump: I think we're about to make some steps forward
10:18:01 * SamB sees a figure of 215 in his client
10:18:21 <dons> i see 215 now
10:18:22 <dons> ?users
10:18:23 <lambdabot> Maximum users seen in #haskell: 216, currently: 215
10:18:26 <dons> and so does the bot
10:18:30 <SamB> oh, I see
10:18:32 <mwolak> plisk quit
10:18:33 <Heffalump> plisk left
10:19:02 * SamB doesn't see anything without colored name next to it anymore
10:19:16 <dons> considering this is a slow sunday, i think our high water mark must be way above the 225 we previously thought it was
10:20:15 <kosmikus> @seen swiert
10:20:16 <lambdabot> I haven't seen swiert.
10:20:17 <Heffalump> can I just declare an instance of Data.Typeable for a random type that doesn't already derive it?
10:20:41 <kosmikus> @seen bringert
10:20:42 <lambdabot> bringert is in #haskell.se and #haskell. I don't know when bringert last spoke.
10:20:47 <SamB> Heffalump: you *can*
10:20:53 <bringert> hi kosmikus
10:21:01 <SamB> but try to avoid doing it in one library for another
10:21:01 <kosmikus> bringert: are you still in the US?
10:21:05 <musasabi> dons: any reason for the haskell-prime list being so quiet.
10:21:17 <musasabi> Heffalump: I have some TH code for that if you want.
10:21:24 <musasabi> +?
10:21:25 <bringert> kosmikus: nope, came back to sweden this tuesday
10:21:30 <kosmikus> bringert: ah, ok
10:21:31 <roconnor> ?users
10:21:31 <lambdabot> Maximum users seen in #haskell: 216, currently: 216
10:21:40 <Heffalump> musasabi: yes please
10:21:46 <roconnor> ?uptime
10:21:46 <lambdabot> uptime: 7 hours, 17 minutes and 17 seconds
10:21:52 <Heffalump> SamB: well, I need to do it for a library that doesn't derive it itself
10:21:57 <dons> musasabi: hmm, some discussions about classes and concurrency have been happening off chan? and things have slowed as people go about their icfp and haskell-workshop work?
10:22:00 <Heffalump> (Language.Haskell.TH itself as it happens :-)
10:22:04 <bringert> kosmikus: going back for icfp of course
10:22:05 <SamB> Heffalump: are you writing a program or a library?
10:22:12 <Heffalump> a library
10:22:15 <SamB> eeee
10:22:18 <SamB> well.
10:22:23 <bringert> kosmikus: how come you're asking?
10:22:32 <bringert> did you want to grab a beer?
10:22:43 <SamB> just cross your fingers and hope nobody else does it too, I guess!
10:23:02 <Heffalump> apart from the risk of instances clashing, are there any other differences?
10:23:13 <kosmikus> bringert: I thought you might stay until ICFP. And I just booked my flight. I'm going to fly to Seattle on Sept. 6 ...
10:23:15 <Heffalump> (between the result of derive Typeable and doing it myself in the obvious way)
10:23:27 <SamB> well, you have to either do it manually or with TH or something, rather than the compiler doing it for you, so you could do it wrong
10:23:36 <SamB> like, accidentally using the same name as another instance
10:23:39 <kosmikus> staying in Redmond for a couple of days before going to Portland ...
10:23:51 <Heffalump> well, I would use the fully qualified name as the docs suggest
10:24:05 <SamB> should be fine
10:24:09 <musasabi> Heffalump: http://www.cs.helsinki.fi/u/ekarttun/haskell/DeriveTH/
10:24:10 <bringert> kosmikus: ah, no. I'll go back for the ghc hackathon, hw and icfp, but I didn't know that when I bought the tickets for the previous trip
10:24:11 <Heffalump> ok, ta
10:24:11 <lambdabot> Title: Index of /u/ekarttun/haskell/DeriveTH
10:24:19 <bringert> kosmikus: going to see daan?
10:24:26 <kosmikus> bringert: yes.
10:24:43 <bringert> swiert is there too, as you probably know
10:24:44 <kosmikus> bringert: I'll be at the hackathon, too.
10:24:52 <musasabi> Heffalump: Internal.hs and DeriveTypeable.hs
10:24:54 <Heffalump> musasabi: thanks.
10:25:06 <Heffalump> what are the redistribution conditions, if any?
10:25:24 <Heffalump> not that I've put any on what I want to use it for either yet :-)
10:25:25 <kosmikus> bringert: yes, I know. but he's not that much around on the channel since he's over there ...
10:25:30 <musasabi> BSD3. (haven't packaged and released it yet properly).
10:25:33 <bringert> kosmikus: I didn't see your name on the list, but then again, I'm not on the list either
10:25:37 <SamB> there isn't anything magic about the derive, except that it is so easy
10:25:41 <musasabi> if you want something else most licences are fine.
10:25:44 <kosmikus> bringert: oh, I haven't registered ...
10:25:45 <SamB> er, deriving...
10:25:46 <Heffalump> ta
10:25:50 * Heffalump disappears
10:25:54 <kosmikus> bringert: I really should.
10:27:41 <bringert> does the current darcs ghc have instance deriving for GADTs?
10:31:01 <bringert> kosmikus: I guess we'll be in portland about the same period then. if you want to share a hotel room, I'm trying to find someone who will be there the whole time
10:31:12 <kosmikus> yes
10:31:14 <kosmikus> :)
10:31:45 <bringert> for expense reasons it might be easier to share with someone else from chalmers, but I think I'm the only one going to all three events
10:32:00 <bringert> and I guess it's easy enough to pay the bill with two credit cards
10:32:51 <bringert> whoa, there's 25 people on the list for the hackathon
10:33:07 <bringert> and there seems to be about 27 chairs in the picture of the room
10:33:44 <bringert> maybe 28
10:35:25 <kosmikus> hehe
10:39:11 <void> does hReady or hWaitForInput allways wait if the handle is a socket?
10:42:14 <LordBrain> What does >||< mean in parsec?
10:43:31 <LordBrain> nevermind.. its not parsec
10:48:37 * edwardk returns.
10:49:47 <LordBrain> does yi predate parsec?
10:50:11 <LordBrain> or did they make a choice that they want to make their own combinators..
10:50:38 <SamB> Yi uses lexer combinators...
10:50:43 <dons> LordBrain: we're using lexer combinators, not parser combinators :)
10:51:06 <dons> originally the syntax is from 'Lazy Lexing is Fast' .. the paper, not the movie
10:51:08 <LordBrain> but parsec doesnt have those?
10:51:16 <LordBrain> there's a movie?
10:51:24 <SamB> movie?
10:51:26 <dons> no ;) jokes folks
10:51:26 <LordBrain> are you kidding?
10:51:28 <SamB> oh.
10:51:29 <LordBrain> lol
10:51:30 <dons> ?localtime
10:51:38 <dons> ?localtime dons
10:51:41 * SamB thought maybe there was an animation of lazy lexing in action
10:51:41 <lambdabot> Local time for dons is Mon Aug  7 03:50:27 2006
10:51:47 <dons> heh
10:52:20 <dons> LordBrain: check the end of the yi paper for the full story
10:53:29 <dons> interestingly, these combinators have since been used in the new Text.Regex.Lazy, to quite some success, I think
10:53:46 <LordBrain> ah
10:54:23 <SamB> does that beat C soundly?
10:54:28 <LordBrain> well i think visual mode requires its own lexer, if i understand
10:54:48 <LordBrain> hmmm
10:54:57 <LordBrain> should I add things to the TODO?
10:54:57 <dons> yep., beating C is easy though. the new PCRE/ByteString layer should beat most things soundly.
10:55:06 <dons> LordBrain: sure.
10:55:16 <LordBrain> ok
10:55:23 <SamB> does that beat perl too?
10:55:26 <musasabi> dons: now one needs only ship a version of GHC with those so we can get it into the shootout.
10:55:43 <dons> yes. we need to somehow get Text.Regex.Lazy shipped.
10:55:44 * edwardk settles in and reads the paper in question =)
10:55:54 <dons> perhaps we should have some discussion on the libraries@ list
10:56:33 <musasabi> having a package rexex-lazy shipped and deprecating Text.Regex migh make sense
10:56:36 * SamB makes a lame joke about there being some from time to time
10:57:03 <dons> musasabi:hmm? shipped and deprecating?
10:57:08 <SamB> someone uses Text.Regex for something?
10:57:53 <dons> yeah, deprecating Text.Regex. moving Text.Regex.Lazy into a libraries/regex-lazy spot
10:58:43 <musasabi> SamB: yes. It is not too bad if the code is short and one just needs a quick hack.
10:58:51 <edwardk> i like the paper it helps resolve my biggest problem with parsec based lexing
10:59:06 <SamB> oh?
10:59:15 <dons> edwardk: the lazy lexer paper?
10:59:18 <edwardk> yeah
10:59:48 <musasabi> SamB: e.g. matching user-agent strings from HTTP headers.
10:59:51 <edwardk> how much faster is it that parsec for lexing purposes?
11:00:00 <dons> somewhat faster.
11:00:03 <SamB> musasabi: oh
11:00:10 * dons waves hands around
11:00:15 * edwardk laughs
11:00:19 <SamB> whenever I want regexes for anything, I want some kind of group extraction...
11:00:33 <SamB> well, just about
11:00:42 <edwardk> basically debating about replacing my simple parsec lexer with something of this sort
11:00:52 <dons> should be pretty easy to whip up
11:01:06 * edwardk nods.
11:01:08 <musasabi> SamB: that is one place where just the info about "does this match" is usually enough, but I don't think that Text.Regex has any users that would protest with the move.
11:01:18 <dons> right.
11:01:28 <edwardk> right now i have a template haskell hack to generate the keyword trie to avoid backtracking, etc.
11:01:28 <dons>  JaffaCake has made noises to this effect, I think
11:01:30 <musasabi> Especially not if 6.6 shipped with a version of Cabal that supported conditional dependencies.
11:01:38 <dons> (hmm, or at least getting some replacement in)
11:01:50 <LordBrain> dons: undo doesnt seem to work the way it should, for example, if i say d2l that deletes 2 characters at once, then i have to say undo twice to undo it.
11:02:02 <edwardk> i could stick with parsec and add a similar one for operators and it might not be necessary to switch.
11:02:06 <dons> LordBrain: hmm?
11:02:17 <dons> the undo doesn't work exactly like vim, but its close
11:03:06 <LordBrain> well, i'm wondering if thats how you want it, d2l deletes two chars at once, but i have to press undo twice. Is that intentional?
11:03:39 <dons> oh, it doesn't coalesce at all
11:03:43 <Cale> vim 7.0 has crazy undo features now :)
11:03:45 <dons> though, hmm, this wouldn't be too hard
11:03:51 <LordBrain> i havent tried vim 7 yet
11:03:52 <dons> Cale, oh yes?
11:04:02 <dons> modal time travelling undo?
11:04:05 <dons> or whatever its called
11:04:11 <Cale> You can ask it for a version that's so manyy seconds, minutes or hours earlier or later.
11:04:15 <Cale> -y
11:04:16 <dons> ah right!
11:04:25 <dons> wacky
11:04:32 <LordBrain> hehe
11:04:45 <dons> why not just add a darcs binding to undo ;)
11:04:51 <Cale> and it keeps track of separate branches
11:05:15 <dons> huh. maybe it is an rcs
11:05:59 <LordBrain> what if i make a change, quit, and open the file, can i undo it?
11:06:07 <dons> nope
11:06:09 <Cale> I don't think so.
11:06:17 <SamB_XP> not much of an RCS then
11:06:45 <Cale> Well, it's an abstract RCS :)
11:08:06 <edwardk> only problem there is when you hop into vi to use regexps to clean up a 50 meg file, that could get pretty horrendous memory usage wise
11:08:08 <dons> heh
11:09:30 <dons> @localtime dons
11:09:31 <LordBrain> eventually there will be some kind of RCS built into the filesystem i think.
11:09:34 <lambdabot> Local time for dons is Mon Aug  7 04:08:20 2006
11:09:42 * dons -> sleep!
11:10:03 <SamB> LordBrain: plan9 has had that for years!
11:10:19 <SamB> no branches, but it does have daily snapshots
11:10:56 <daniel_larsson> VMS has some kind of RCS too )
11:11:05 <SamB> Its probably configurable
11:11:21 <daniel_larsson> very basic, but each save creates a new version
11:11:22 <SamB> well, I mean, maybe you'd need to edit source or something but is that a big deal?
11:14:20 <SamB> the trouble with a filesystem-as-RCS is that most people expect deleting things to give them more free space
11:14:57 <SamB> (that, and most people don't have some big WORM server sitting around somewhere)
11:23:30 <Krunch> versionned fs already exist outside plan9
11:23:58 <emertens> and lisp is designed to work with one :)
11:24:37 <Krunch> http://linuxfr.org/~g78/21409.html#701990 (page in french but the linked pages are in english)
11:24:38 <lambdabot> Title: Journal de g78: Une petite ide du soir
11:25:52 <dylan> perhaps a version controlled fs would have a 'forget' operation, which freed space?
11:26:18 <Krunch> rm --for-real
11:26:20 <Krunch> :)
11:26:38 <dylan> or rm --rev=all
11:26:51 <emertens> it could work like dos did
11:26:55 <emertens> the space is freed
11:26:59 <emertens> but can be undeleted
11:27:05 <emertens> if it hasnt been
11:27:09 <emertens> overwritten :)
11:27:09 <Krunch> vms had versionned fs but i don't know how it worked
11:30:23 <int-e> hmm. but I don't want to version-control all my .o files. a fs or even a directory seems too be too coarse for versioning.
11:31:39 <jer> http://en.wikipedia.org/wiki/Files-11 <-- good overview of VMS filesystems
11:59:13 <LordBrain> dons: is "Lazy Lexing is Fast" published online somewhere?
12:00:49 <emertens> Does anyone have a good example of the use of "guard"?
12:00:52 <emertens> @hoogle guard
12:00:53 <lambdabot> Monad.guard :: MonadPlus a => Bool -> a ()
12:00:53 <lambdabot> Control.Monad.guard :: MonadPlus m => Bool -> m ()
12:00:53 <lambdabot> Language.Haskell.TH.Guard :: data Guard
12:01:09 <LordBrain> aha i found it
12:01:34 <roconnor> @hoogle when
12:01:34 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
12:01:35 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
12:02:14 <roconnor> > guard true 5 :: [Int]
12:02:15 <lambdabot>  Not in scope: `true'
12:02:18 <roconnor> > guard True 5 :: [Int]
12:02:19 <lambdabot>  Couldn't match `[Int]' against `()'
12:02:51 <emertens> > guard True >> return 5 :: [Int]
12:02:52 <emertens> ?
12:02:52 <lambdabot>  [5]
12:02:58 <emertens> > guard False >> return 5 :: [Int]
12:03:00 <lambdabot>  []
12:03:10 <emertens> interesting...
12:03:29 <kpreid> hm
12:03:38 <kpreid> when would mzero differ from fail?
12:03:49 <emertens> when they were defined differently :)
12:04:01 <kpreid> well, yes...
12:04:07 <emertens> fail :: Bool
12:04:12 <emertens> fail :: Maybe Int
12:04:15 <emertens> > fail :: Maybe Int
12:04:16 <lambdabot>    Expecting a function type, but found `Maybe Int'
12:04:16 <lambdabot>    Expected type: Ma...
12:04:23 <emertens> @type fail
12:04:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
12:04:35 <emertens> > fail "experimenting" :: Maybe Int
12:04:36 <lambdabot>  Nothing
12:08:59 <emertens> kpreid: I don't know which MonadPlus instances fail and mzero are defined differently
12:10:19 <Cale> imo, fail should be considered harmful :)
12:10:28 <emertens> I've heard that you don't like fail :)
12:10:32 <emertens> you specifically
12:10:36 <Cale> Yes :)
12:10:42 <emertens> and not from you yourself :)
12:10:56 <Cale> It's not part of the definition of a monad, and so shouldn't be in the Monad class.
12:11:06 <Cale> I'm okay with there being a separate MonadFail class.
12:12:08 <emertens> fail isn't required to adhere to any laws, is it?
12:12:16 <kpreid> Cale: in that case, what would do { [x] <- []; return x } mean?
12:12:34 <emertens> that would be a pattern matching error...
12:12:41 <int-e> no
12:12:47 <LordBrain> which is what fail is for, right?
12:12:49 <int-e> it'd return []
12:12:58 <emertens> int-e: if fail didn't exist?
12:12:59 <int-e> but for a different reason :)
12:13:06 <Cale> yes
12:13:14 <kpreid> oh, wait, that was a broken example
12:13:18 <int-e> you want [x] <- return []  or [x]  <- [[]]
12:13:27 <kpreid> int-e: yes
12:13:45 <emertens> > do { [x] <- [] ; return x }
12:13:46 <lambdabot>  Add a type signature
12:13:51 <emertens> > do { [x] <- [] ; return x } :: [Int]
12:13:53 <lambdabot>  []
12:14:05 <Cale> > do { [x] <- [[]] ; return x } :: [Int]
12:14:06 <lambdabot>  []
12:14:12 <emertens> is that only because "fail" exists?
12:14:19 <int-e> maybe that should desugar to mzero ... and require MonadPlus to type.
12:14:28 <Cale> MonadZero ;)
12:14:36 <int-e> or that
12:14:37 <Cale> Currently, pattern matching there uses fail
12:14:41 <int-e> or a nicer MonadError
12:14:58 <int-e> but that wouldn't resolve the conflict :)
12:15:24 <emertens> is there a good reason that that statement shouldn't just call  :  error "failed to match pattern" ?
12:15:27 <Cale> I sort of think that using refutable patterns should create a MonadZero dependency
12:15:40 <Cale> It could
12:15:45 <kpreid> emertens: yes: the usefulness of the Maybe monad
12:15:48 <int-e> btw, are n patterns the only reason why Eq is a requirement for Num or are there performance considerations, too?
12:15:51 <Cale> It's sometimes convenient for filtering
12:15:56 <kpreid> er, actually, no
12:16:02 <Cale> int-e: yeah
12:16:26 * int-e is worried about pattern matches that the programmer knows can't fail.
12:16:38 <int-e> oh refutable, irrefutable. hmm.
12:16:50 <int-e> that'd be an idea, but nasty.
12:16:52 <emertens> > do { Just x <- Nothing; return x } :: Maybe Int
12:16:53 <lambdabot>  Nothing
12:17:03 <emertens> that's ugly...
12:17:07 <Cale> ugly?
12:17:13 <emertens> I don't like that it works :)
12:17:27 <int-e> > do { Just x <- Just Nothing; return x } :: Maybe Int
12:17:28 <lambdabot>  Nothing
12:17:59 <emertens> doesn't seem to me that those should return the same value
12:18:03 <Cale> > do { ~(Just x) <- Nothing; return x } :: Maybe Int
12:18:04 <lambdabot>  Nothing
12:18:18 <int-e> > do { ~(Just x) <- Just Nothing; return x } :: Maybe Int
12:18:19 <lambdabot>  Irrefutable pattern failed for pattern (Data.Maybe.Just x)
12:18:36 <Cale> ah, yes of course :)
12:19:07 <emertens> irrefutable pattern?
12:19:16 <int-e> ~pat
12:19:26 <Cale> Adding ~ before a pattern makes it match lazily
12:19:26 <emertens> I thought that meant "lazy" pattern...
12:19:56 <int-e> > do { ~(Just x) <- Just Nothing; return 0 } :: Maybe Int
12:19:58 <lambdabot>  Just 0
12:20:04 <Cale> that is, it automatically accepts, and only causes an error when the variable is used if the pattern fails to match
12:20:42 <Cale> > let Nothing = Just 5 in Nothing
12:20:43 <lambdabot>  Add a type signature
12:20:50 <Cale> > let Nothing = Just 5 in Nothing :: Maybe Integer
12:20:51 <lambdabot>  Nothing
12:21:16 <Cale> pattern bindings are irrefutable by default
12:21:36 <Cale> > let Just a = Nothing in a :: Integer
12:21:37 <lambdabot>  Irrefutable pattern failed for pattern Data.Maybe.Just a
12:21:42 <Cale> > let Just a = Nothing in 5
12:21:44 <lambdabot>  5
12:21:51 <int-e> let bindings, you mean
12:22:00 <Cale> no, pattern bindings in general
12:22:04 <emertens> let 5 = Nothing in Nothing
12:22:09 <emertens> > let 5 = Nothing in Nothing
12:22:10 <lambdabot>  add an instance declaration for (Num (Maybe a))
12:22:10 <lambdabot>   When checking the patte...
12:22:19 <emertens> > let Left 4 = Nothing in Nothing
12:22:19 <lambdabot>  Couldn't match `Either a b' against `Maybe a1'
12:22:21 <int-e> > (\Just x -> x) Nothing
12:22:22 <lambdabot>    Constructor `Just' should have 1 argument, but has been given 0
12:22:22 <lambdabot>   When...
12:22:29 <SamB> heh
12:22:30 <int-e> > (\(Just x) -> x) Nothing
12:22:31 <lambdabot>  Add a type signature
12:22:34 <SamB> > let 5 = 10 in 11
12:22:35 <lambdabot>  11
12:22:39 <int-e> > (\(Just x) -> x) Nothing :: Integer
12:22:40 <lambdabot>  Non-exhaustive patterns in lambda
12:22:48 <Cale> That's a lambda binding
12:22:58 <Cale> if it's anything
12:23:25 <emertens> > let 1 = 2 in 1
12:23:26 <Cale> The Report distinguishes between pattern bindings and function bindings.
12:23:26 <lambdabot>  1
12:23:35 <int-e> ah
12:23:44 <emertens> why is that legal?
12:23:53 <int-e> it's a pattern binding :)
12:24:01 <kpreid> emertens: because the pattern is never 'evaluated', to say it sloppily
12:24:02 <Cale> emertens: because it's a pattern binding, and thus irrefutable
12:24:24 <Cale> and since it binds no variables, it can't get you into trouble
12:24:58 <int-e> > let (1,x) = (2,3) in x -- hmm. that works though?
12:24:59 <lambdabot>  Irrefutable pattern failed for pattern (1, x)
12:25:00 <Korollary> a gentler compiler still should ask "what the heck are you doing?"
12:25:12 <emertens> > let 1 = error "insane" in 2
12:25:13 <lambdabot>  2
12:25:14 <int-e> oh, left-to-right matching.
12:25:52 <int-e> > let (x,1) = (2,3) in x
12:25:53 <lambdabot>  Irrefutable pattern failed for pattern (x, 1)
12:25:58 <int-e> good. nice.
12:26:26 <Cale> > let (~1,x) = (2,3) in x
12:26:27 <lambdabot>  3
12:27:10 * roconnor works on his MR article
12:28:21 <edwardk> heh, for a moment there with the let 1 = 2 stuff i was reminded of when i accidentally changed the value of 2 in fortran once
12:28:22 <int-e> > [p|p<-[2..],null[0|0<-map(mod p)[2..p-1]]]
12:28:22 <lambdabot>  parse error on input `<-'
12:28:26 <int-e> > [p |p<-[2..],null[0|0<-map(mod p)[2..p-1]]]
12:28:28 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:29:07 <roconnor> edwardk: My friend once wrote...
12:29:14 <roconnor> #define TRUE 0
12:29:19 <roconnor> and then, cut and paste
12:29:24 <roconnor> #define FALSE 0
12:29:30 <edwardk> heh
12:29:35 <emertens> Cale: were you using Haskell when monad comprehensions existed (rather than being restricted to the list monad)?
12:29:43 <roconnor> And went though most of his program before encountering a very strange bug.
12:29:52 <Cale> emertens: no, but I wish I had been :)
12:30:01 <int-e> Cale: how about that prime sieve? :)
12:30:11 * edwardk wants monad comprehensions. they strike me as one of the more elegant proposals of the time
12:30:25 <Cale> int-e: cute
12:30:27 <emertens> does anyone here know what those might have lookedl ike?
12:30:47 <Cale> Monad comprehensions?
12:30:48 <edwardk> emertens it was just the list comprehension synta
12:30:52 <edwardk> wasn't it?
12:30:54 <SamB_XP> emertens: most likely they looked like list comprehensions ;-)
12:30:56 <Cale> yeah
12:31:12 <edwardk> just wasn't restricted to the list monad
12:31:18 <Cale> > [() | x <- getLine; putStrLn x]
12:31:19 <lambdabot>  Parse error
12:31:25 <Cale> [() | x <- getLine, putStrLn x]
12:31:27 <Cale> rather
12:31:38 <Cale> hmm, would that even be allowed?
12:31:45 <musasabi> no
12:31:49 <Cale> right
12:31:57 <Cale> [() | x <- getLine, () <- putStrLn x]
12:32:00 <emertens> wouldn't putStrLn need to return bool?
12:32:01 <Cale> that would be though
12:32:09 <Cale> not Bool, ()
12:32:22 <int-e> > map (\x -> (x, [42|x])) [True, False]
12:32:23 <lambdabot>  [(True,[42]),(False,[])]
12:33:08 <Cale> things which weren't generators would be treated as guards
12:33:20 <Cale> using the guard function which is now in Control.Monad
12:34:31 <Cale> hmm, it's odd that python has both heterogeneous lists and tuples.
12:34:41 <edwardk> efficiency
12:34:53 <edwardk> not that python is very efficient =)
12:35:02 <Cale> Yeah, tuples are immutable
12:35:06 <Cale> that's the only difference
12:35:10 * edwardk nods.
12:47:42 <edwardk> hrmm. has anyone given though to trying to generate haddock lines from the .hi file when it encounters root level template haskell splices?
12:52:29 <LordBrain> dons: 'b' doesnt behave properly, i'm going to fix it. Should i implement its movement operation as a primative in CharMove.hs, or should I try to be minimalist with that API, and just implement as much as possible in Vim.hs?
12:52:59 <LordBrain> or some in between...
12:53:04 <LordBrain> heh
13:03:47 <ptolomy> If someone familiar with STM is willing to write a really simple STM example that sues STM and IO without unsafeness and put in on the wiki, i will name my desk in their honor. From that point forward, in all contexts it will be called "_____ Memorial Desk".
13:04:30 <Igloo> ptolomy: AIUI you can't safely do IO inside an STM transaction
13:05:02 <Igloo> As STM would need to be able to roll it back
13:05:08 <roconnor> do { y <- atomically do {x<-getMVar; putMVar (x+1); return x}; print y}
13:05:17 <ptolomy> Well, I suppose that would explain why I was unable to do it.
13:05:35 <Korollary> ptolomy: I have one
13:05:54 <ptolomy> Additional contraints would be that it works and tha tit uses multiple threads to do something, perhpas.
13:06:30 <ptolomy> I just have difficult seeing how to make it useful without IO.
13:06:50 <musasabi> ptolomy: I very simple example would be to use it to update non-transactional counters.
13:07:25 <musasabi> ptolomy: I use it for serializing transaction related things, but it is very non-trivial.
13:10:10 <ptolomy> So my daydreams of writing thread-per-client TCP servers with STM handling all the messy parts of concurrency without using unsafeIO are not to come to pass?
13:13:04 <mwolak> is there a normal way to fake being able to add constructors to a data type?
13:13:04 <roconnor> ptolomy: why is that?
13:13:20 <Cale> ptolomy: It isn't useful without IO
13:13:35 <roconnor> Thread communication doesn't usually need IO.
13:13:37 <Cale> ptolomy: The STM monad is for composing transactions
13:15:11 <angloxerox> @yow
13:15:12 <lambdabot> YOW!!  I'm in a very clever and adorable INSANE ASYLUM!!
13:15:34 <angloxerox> Cute.
13:15:38 <Cale> mwolak: sure, you could have an "Other" case like  data MyData a = Red | Blue | Other a
13:17:00 <mwolak> cale: I don't think that will do quite what I want
13:17:03 <Cale> Or you could use Either
13:19:18 <mwolak> I think I'm going to punt and use strings
13:19:19 <int-e> > let s = either (either (const "red") (const "blue")) show in map s [Left (Left ()), Right 42]
13:19:20 <lambdabot>  ["red","42"]
13:20:20 <stepcut> ?where goa
13:20:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
13:20:23 <int-e> ups. why did that work?
13:20:29 <int-e> @type [Left (Left ()), Right 42]
13:20:31 <lambdabot> forall b b1. (Num b1) => [Either (Either () b) b1]
13:20:52 <int-e> I understand that b1 defaults to num ... but what did it do with b?
13:21:02 <int-e> err to Integer
13:21:36 <int-e> > undefined
13:21:37 <lambdabot>  Add a type signature
13:26:51 <roconnor> ?type either (either (const "red") (const "blue"))
13:26:53 <lambdabot> forall a b b1. (b1 -> [Char]) -> Either (Either a b) b1 -> [Char]
13:27:10 <roconnor> ?type either (either (const "red") (const "blue")) show
13:27:11 <lambdabot> forall a b b1. (Show b1) => Either (Either a b) b1 -> [Char]
13:27:21 <roconnor> hmm
13:28:10 <roconnor> > const 5 undefined
13:28:12 <lambdabot>  5
13:28:17 <roconnor> simpler
13:28:50 <roconnor> ?type const 5 undefined
13:28:52 <lambdabot> forall a. (Num a) => a
13:29:14 <roconnor> I suppose it just doesn't care about polymorphic types that disappear.
13:29:55 <roconnor> must be that HM type inference
13:32:32 <angloxerox> @spell wisky
13:32:34 <lambdabot> whiskey whisk Wisc risky wispy
13:33:53 <angloxerox> @type let fib 0 = 1; fib 1 = 1; fib x = fib (x-1) + fib (x-2) in fib
13:33:55 <lambdabot> forall a a1. (Num a1, Num a) => a -> a1
13:34:25 <postman> Is liftM redundant (as fmap exists)?
13:34:42 <Heffalump> yes
13:34:51 <Heffalump> its existence annoys some theorists, IIRC
13:36:54 <roconnor> Heffalump: they have different types
13:37:25 <roconnor> in principle not all Monads need to implement Functor.
13:37:43 <edwinb> angloxerox: bah, it didn't include "whisky" (which is the correct spelling for Scotch)
13:37:51 <roconnor> although it is a mistake to make a Monad that doesn't implement Functor.
13:38:19 <roconnor> The fact that Monads are not all Functors is a language design flaw.
13:40:05 <Heffalump> roconnor: right.
13:50:01 <roconnor> @hoogle first
13:50:02 <lambdabot> Control.Arrow.first :: Arrow a => a b c -> a (b, d) (c, d)
13:50:02 <lambdabot> Data.List.deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
13:50:02 <lambdabot> System.Win32.File.c_FindFirstChangeNotification :: LPCTSTR -> Bool -> FileNotificationFlag -> IO HANDLE
13:56:42 <dcoutts__> dons: not having the realloc means we can't fuse utf8/16 encodings or concatMap or pack or anything else where we cannot predict the max length
13:57:27 <dcoutts__> it really ought to be possible to do the realloc without sacrificing performance because it should just be one more compare per iteration
13:57:29 <angloxerox> I can see dcoutts__ typing those things, it's funny, now he'll turn in my direction and laugh I suppose.
13:57:45 <angloxerox> He did.
13:57:53 * dcoutts__ grins
13:58:01 <stepcut> heh
13:58:14 <Heffalump> musasabi: you around? How do I specify the name of the type to be derived for? I've tried $(deriveTypeable (mkName "Language.Haskell.TH.Exp")) and also Language.Haskell.TH.Syntax.Exp and also Exp, but none of them seem to work.
14:00:42 <Igloo> Try $(deriveTypeable 'Exp)
14:01:28 <Igloo> Sorry, $(deriveTypeable ''Exp)
14:01:50 <Heffalump> ahah, ta
14:05:02 * musasabi looks at the channel.
14:05:13 * Heffalump doesn't really grok TH yet
14:05:30 <musasabi> 'Exp <- constructor named Exp. ''Exp <- type named Exp.
14:06:03 <angloxerox> Heffalump: are you trying to do that insane stuff you thought about at the pub last night?
14:06:27 <Heffalump> angloxerox: what insance stuff?
14:06:32 <Heffalump> s/insance/insane/
14:06:44 <angloxerox> Heffalump: freudian slip =P
14:06:51 <Heffalump> :-p
14:07:24 <angloxerox> Heffalump: that one you were talking about with edwinb and ndm... I can't remember the details, but it was like RULES+TH+code generation = BOOM.
14:07:36 <Heffalump> oh, no.
14:07:43 <musasabi> that sounds very nifty
14:07:48 <angloxerox> Aw! %-)
14:07:53 <Heffalump> it's the thing I was telling Liyang he should have done.
14:08:18 * Heffalump tries to get his head round Data.Generics
14:17:37 <Heffalump> @seen arjanoosting
14:17:38 <lambdabot> I haven't seen arjanoosting.
14:21:26 <postman> What does AlgRep stand for?
14:21:42 <roconnor> > let x = x in x
14:21:42 <lambdabot>  Add a type signature
14:21:46 <roconnor> > let x = x in x :: Int
14:21:47 <lambdabot>  Exception: <<loop>>
14:22:19 <roconnor> What is the shortest Haskell program where graph reduction fails, but GHC doesn't print <<loop>>?
14:24:11 <int-e> > fix(+1)
14:24:13 <lambdabot>  Exception: <<loop>>
14:24:46 <musasabi> > let x = y; y = x in x
14:24:47 <lambdabot>  Add a type signature
14:25:03 <musasabi> > let x = y; y = x in x :: ()
14:25:05 <lambdabot>  Exception: <<loop>>
14:25:07 <musasabi> bah
14:25:09 <Igloo> let f () = f () in f () is an upper-bound
14:25:30 <musasabi> Prelude> let x =y; y=x in x
14:25:35 <musasabi> works in my ghci
14:25:41 <int-e> @index fix
14:25:42 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
14:25:46 <roconnor> Igloo: thanks.
14:26:29 <roconnor> Igloo: no wait, that's no good
14:26:38 <roconnor> My CPU is still in use
14:26:57 <Igloo> What do you want to happen then?
14:27:02 <roconnor> Nothing
14:27:04 <roconnor> no CPU
14:27:08 <petekaz> @users
14:27:09 <lambdabot> Maximum users seen in #haskell: 216, currently: 209
14:27:11 <Igloo> Read from an MVar with nothing in
14:27:11 <roconnor> no ouput
14:27:13 <postman> musasabi: odd that let x =y; y=x in x uses no CPU.
14:27:14 <roconnor> no reduction
14:27:19 <roconnor> nothing
14:27:52 <roconnor> musasabi: yes, that is a good example.
14:28:06 <roconnor> ah, maybe I have an old GHC
14:29:31 <Igloo> Oh, duh, that won't work
14:30:35 <Igloo> I don't think there is one. If there is an unblocked thread then it will use CPU eventually (although you can use threadDelay with a huge number which is probably good enough, depending on what you are trying to do)
14:31:08 <roconnor> Igloo: let x =y; y=x in x uses no CPU in my GHC (6.4.2)
14:31:17 <roconnor> nor does it print <<loop>>
14:31:29 <Heffalump> !
14:31:58 <Igloo> Looks like a ghci bug to me
14:32:29 <Igloo> let x =y; y=x in x :: ()   will not use CPU in a 6.5, but when I hit ^C says *** Exception: <<loop>>
14:32:45 <roconnor> Seems they fixed it.
14:32:56 <Igloo> That's not fixed
14:33:04 <roconnor> oh
14:33:09 <roconnor> you need to hit ^C
14:33:18 <roconnor> > assemble = encodeAsm . link> let x =y; y=x in x :: ()
14:33:18 <lambdabot>  Parse error
14:33:19 <Igloo> Right; it should instantly raise the exception
14:33:27 <roconnor> let x =y; y=x in x :: ()
14:33:31 <roconnor> > let x =y; y=x in x :: ()
14:33:32 <lambdabot>  Exception: <<loop>>
14:33:38 <roconnor> hmm
14:33:44 <roconnor> very odd
14:34:47 <roconnor> why does lambdabot get the exception?
14:35:03 <int-e> > last [0..]
14:35:07 <lambdabot> Terminated
14:35:53 <int-e> > nub [0..]
14:35:55 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
14:36:41 <postman> Isn't nub implemented in O(n^2)?
14:37:14 <int-e> yes, but it keeps the first of each class of equal elements.
14:37:15 <Igloo> Yes
14:37:59 <Heffalump> oh, bugger, I need an instance of Data for all the TH types too :-(
14:38:00 <int-e> > cycle []
14:38:01 <lambdabot>  Add a type signature
14:38:08 <Heffalump> musasabi: don't suppose you have some more handy code lying around? ;-)
14:38:32 <int-e> > cycle [] :: [Int]
14:38:33 <lambdabot>  Exception: Prelude.cycle: empty list
14:38:50 <musasabi> Heffalump: no instance for Data. But you can look at the other files in the linked place or e.g. SerTH for examples how to derive stuff.
14:39:45 <int-e> > [0..] >> []
14:39:46 <lambdabot>  Add a type signature
14:40:03 <Cufisz> does anyone know if there is a way for all thrown exceptions to report file and line numbers (in ghc) ?
14:40:55 <musasabi> Cufisz: in GHC you could use CPP as a dirty way to do it.
14:42:06 <Cufisz> hmm, but i specifically need to know when i'm getting an "*** Exception: Prelude.(!!): index too large"
14:42:13 <Cufisz> i suppose i could write my own (!!)
14:42:28 <Cufisz> =)
14:42:52 * Heffalump gives some consideration to rebuilding GHC instead
14:43:39 <musasabi> Cufisz: the easy solution is like this:
14:44:05 <musasabi> #define an alternative. And use __LINE__ etc there.
14:44:13 <musasabi> see darcs for examples.
14:44:24 <Cufisz> darcs source?
14:45:04 <musasabi> yes.
14:45:11 <musasabi> The other alternative is to use -xc
14:45:13 <Cufisz> alright, will check it out. thanks.
14:45:17 <musasabi> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-options-debugging
14:45:18 <lambdabot> Title: 4.14. Running a compiled program
14:46:11 <Cufisz> that looks even nicer
15:02:51 <Cufisz> musasabi: hrm, for some reason my main.prof is coming up empty
15:03:11 <Cufisz> even though "./main.exe +RTS -f" lists -xc as an option
15:03:46 <Cufisz> i still get a "<GHC.List.CAF>main: Prelude.(!!): index too large" though =P
15:05:52 <Cale> Cufisz: how often do you use !! in the code?
15:05:55 <musasabi> Cufisz: are the modules recompiled with -prof -auto-all
15:06:09 <Cufisz> yup
15:06:13 <Cufisz> cale: not that much
15:06:15 <musasabi> rm *.{o,hi} + recompile might help
15:06:20 <int-e> @karma+ ghc
15:06:20 <lambdabot> ghc's karma raised to 1.
15:06:31 <Cufisz> and i've been using it instead of head
15:06:46 <Cufisz> so i'm going to go through and substitute head for (!! 0)
15:06:49 <Cale> head is just as dangerous
15:07:02 <Cale> but at least you'll be able to tell them apart
15:07:02 <Cufisz> why's that?
15:07:11 <Cale> > head []
15:07:12 <lambdabot>  Add a type signature
15:07:16 <Cale> > head [] :: Int
15:07:17 <lambdabot>  Exception: Prelude.head: empty list
15:07:25 <Cufisz> ahh, yes, obbviously the probablem i've been having =)
15:07:38 <Cale> It's better to use case
15:07:43 <Cufisz> it would be nice to figure out a way to identify exceptions though
15:07:57 <Cale> and make sure that your pattern matches cover all cases
15:08:12 <Heffalump> it would be better if errors came with a handy backtrace
15:08:14 <Cale> yeah, usually that profiling trick helps
15:08:16 <Heffalump> but that's tricky in a lazy language
15:08:26 <Cale> backtraces would be sort of meaningless
15:08:29 <Heffalump> or indeed if ESC/Haskell was usable.
15:08:30 <Cufisz> hmm, i'll keep the case thing in mind too
15:08:51 <Heffalump> well, you can imagine two backtraces. One of where it was constructed and one of where it was forced.
15:11:09 <Pegazus> Hi, given a Pushdown Automata (with possible infinite loops), how to turn it into an automata that always consumes all the input? [i've a book wich explains this, but i don't understand the book explanation :) so if anyone could help me...]?
15:11:36 <Heffalump> is this equivalent to left-factoring a grammar?
15:12:25 * Heffalump goes to bed
15:12:26 <Pegazus> what is left-factoring a grammar? making it non left recursive?
15:12:30 <Heffalump> yes
15:12:36 <Pegazus> ok, it isn't so...
15:55:04 <toki2_0> hi
15:55:49 <musasabi> hello
15:55:58 <edwardk> heya
15:56:05 <Lemmih> Greetings, Haskell.
15:56:06 <lambdabot> Lemmih: You have 1 new message. '/msg lambdabot @messages' to read it.
16:01:29 <toki2_0> i want to compute mandelbrot pictures. My inner loop is roughtly something like   let f c xs = xs ++[((last xs)*(last xs) + c)] in takeWhile(\x -> x*x < 4) (f c [0]
16:02:21 <toki2_0> color = length ( takeWhile ....)
16:03:09 <toki2_0> now this is very slow. I assume that haskell uses recursion and lazy evaluation
16:03:47 <toki2_0> We all know that the inner loop if the mandelbrot set can be computed with a for-loop
16:04:35 <toki2_0> I wonder if there is a compilation flag for GHC which optimizes this to a for loop
16:04:48 <toki2_0> Can anyone help me ?
16:05:50 <musasabi> toki2_0: your first try would be "ghc --make -O2 " and see if that is fast enough.
16:06:21 <musasabi> toki2_0: after that looking at the code and making it faster is the solution.
16:06:22 <edwardk> you also might look at http://shootout.alioth.debian.org/gp4/benchmark.php?test=mandelbrot&lang=ghc&id=2 and see if you can steal any ideas for
16:06:26 <lambdabot> Title: mandelbrot Haskell GHC #2 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Co ...
16:08:45 <toki2_0> there is something like specialization (a pragma or so) to tell ghc to implement this function for float values. I thought that after the function is specialized it can be optimized - maybe even from recursion to iteraion
16:09:13 <edwardk> there is a {-# SPECIALIZE #-} pragma
16:09:17 <edwardk> in ghc anyways
16:09:32 <Korollary> you can add type annotations to force operations on Floats instead of Num a
16:09:39 <edwardk> that too
16:10:19 <Korollary> I'd have a profile run to see if you have any space leaks. If not, and you want to achieve near-C speeds, you need to do some reading.
16:10:22 <Korollary> such as
16:10:28 <Korollary> @google haskell.org Performance
16:10:30 <lambdabot> http://www.haskell.org/haskellwiki/Introduction
16:10:31 <lambdabot> Title: Introduction - HaskellWiki
16:10:34 <Korollary> argh
16:10:36 <Korollary> not that one
16:10:56 <Korollary> @wiki Performance
16:10:57 <lambdabot> http://www.haskell.org/haskellwiki/Performance
16:11:07 <Korollary> that one
16:11:13 <int-e> argh. you're building the list from the wrong end
16:11:24 <toki2_0> i know
16:11:25 <angloxerox> hehe
16:11:46 <toki2_0> i did this to be able to use "takeWhile"
16:12:36 <int-e> > takeWhile (<2000) $ iterate (*2) 1
16:12:37 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024]
16:12:49 <toki2_0> but anyway the compiler should optimize this to a for loop and it should be not matter how the list is created
16:13:14 <toki2_0> yeah, "iterate" is the solution
16:13:45 <toki2_0> > 1 :+ 1
16:13:46 <lambdabot>  1.0 :+ 1.0
16:14:38 <int-e> you're overestimating the compiler I think.
16:14:42 <toki2_0> > let x0 = 1:+1 in x0*x0
16:14:43 <lambdabot>  0.0 :+ 2.0
16:14:52 <toki2_0> > let x0 = 1:+1 in realPart $ x0*x0
16:14:53 <lambdabot>  0.0
16:15:06 <toki2_0> > let x0 = 1:+1 in imagPart $ x0*x0
16:15:07 <lambdabot>  2.0
16:15:14 <angloxerox> @type \c -> ap (++) ((+c) . join (*) . last)
16:15:15 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
16:15:16 <lambdabot>    Expected type: [a] -> [a]
16:15:19 <angloxerox> Ooops
16:15:19 <int-e> > length $ iterate (++[1]) !! 10000
16:15:20 <lambdabot>    Expecting a function type, but found `[a]'
16:15:20 <lambdabot>    Expected type: [a]
16:15:20 <lambdabot>   ...
16:15:27 <int-e> > length $ iterate (++[1]) [] !! 10000
16:15:31 <lambdabot> Terminated
16:15:37 <int-e> > length $ iterate (1:) [] !! 10000
16:15:38 <lambdabot>  10000
16:17:22 <angloxerox> @type \c -> ap (++) (return . (+c) . join (*) . last) -- points-freed, yay =P
16:17:23 <lambdabot> forall a. (Num a) => a -> [a] -> [a]
16:17:44 <toki2_0> > takeWhile (\x -> imagPart (x*x) < 4) $ iterate (\x -> x*x + (0:+1)) (0:+1)
16:17:45 <lambdabot>  [0.0 :+ 1.0,(-1.0) :+ 1.0,0.0 :+ (-1.0),(-1.0) :+ 1.0,0.0 :+ (-1.0),(-1.0) :...
16:17:54 <emertens> angloxerox: except for the c ?
16:18:04 <angloxerox> emertens: right, it looks ugly otherwis
16:18:10 <angloxerox> +e
16:18:13 <emertens> angloxerox: no no, it's still ugly ;)
16:18:21 <int-e> > head $ dropWhile (\x -> imagPart (x*x) < 4) $ iterate (\x -> x*x + (0:+1)) (0:+1)
16:18:25 <lambdabot> Terminated
16:19:21 <int-e> oh it is running in a cycle
16:19:39 <int-e> > dropWhile (\x -> imagPart (x*x) < 4) $ take 1000 $ iterate (\x -> x*x + (0:+1)) (0:+1)
16:19:40 <lambdabot>  []
16:21:06 <angloxerox> Goodnight people
16:21:11 <edwardk> night xerox
16:22:02 <toki2_0> > length $ takeWhile (\x -> imagPart (x*x) < 4) $ iterate (\x -> x*x + (0:+1)) (0:+1)
16:22:06 <lambdabot> Terminated
16:22:30 <toki2_0> > length $ takeWhile (\x -> imagPart (x*x) < 4) $ take 1000 $ iterate (\x -> x*x + (0:+1)) (0:+1)
16:22:31 <lambdabot>  1000
16:22:52 <toki2_0> > length $ takeWhile (\x -> imagPart (x*x) < 4) $ take 1000 $ iterate (\x -> x*x + (0:+1)) (1:+1)
16:22:53 <lambdabot>  6
16:23:22 <toki2_0> 0:+1 is in the mandelbrot set, and 1:+1 is outside
16:23:51 <toki2_0> no, sorry, it's a julia set ;)
16:24:02 <toki2_0> > length $ takeWhile (\x -> imagPart (x*x) < 4) $ take 1000 $ iterate (\x -> x*x + (0:+1)) (0:+0)
16:24:03 <lambdabot>  1000
16:24:07 <toki2_0> > length $ takeWhile (\x -> imagPart (x*x) < 4) $ take 1000 $ iterate (\x -> x*x + (1:+1)) (0:+0)
16:24:08 <lambdabot>  2
16:24:36 <toki2_0> I like the lambdabot more and more ;)
16:28:11 <toki2_0> the length of that list is an index into the colortable
16:28:44 <toki2_0> > do ptin "bla"
16:28:45 <lambdabot>  Not in scope: `ptin'
16:28:50 <toki2_0> > do print "bla"
16:28:51 <lambdabot>  No IO allowed
16:28:57 <toki2_0> damn
16:31:57 <toki2_0> Why is x*x an imaginary number ? it should be real, shouldn't it ?
16:32:19 <int-e> no.
16:32:38 <emertens> 1+i * 1+i /= real
16:33:33 <int-e> > (1 :+ 1) * conjugate (1 :+ 1)
16:33:34 <lambdabot>  2.0 :+ 0.0
16:33:50 <int-e> > magnitude (1 :+ 1)
16:33:51 <lambdabot>  1.4142135623730951
16:33:52 <toki2_0> oh yeah thats it
16:34:30 <int-e> @pl \x -> realPart x ^2 + imagPar x^2
16:34:31 <lambdabot> ap ((+) . (^ 2) . realPart) ((^ 2) . imagPar)
16:35:12 <int-e> > (\(x :+ y) -> x^2 + y^2) (1 :+ 1)
16:35:13 <lambdabot>  2.0
16:35:18 <int-e> your choice.
16:35:52 <int-e> good night
16:36:02 <toki2_0> yeah, actually that's what i need
16:36:27 <ajay> Are there any online haskell educational resources that take you through creating a decently sized program that does something sort of cool?
16:37:47 <Cale> ajay: there's a tutorial in which you construct a scheme interpreter
16:38:24 <ajay> hmm, sounds cool, I'll google it, thanks
16:38:54 <Cale> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
16:38:56 <lambdabot> Title: Write Yourself a Scheme in 48 hours
16:39:12 <ajay> thanks
16:39:14 <hyrax42> scheme in 48 hours?
16:39:20 <Adamant> could you do the reverse?
16:39:30 <hyrax42> I didn't get all the way through it, but parsec is very nice
16:39:33 <Adamant> write a Haskell interpreter in Scheme fairly simply?
16:39:39 <Adamant> (basic, of course)
16:40:10 <hyrax42> the uniformity of lisp syntax makes a simple lisp almost trivial to implement
16:40:34 <whoopsbob> yeah, I imagine haskell would be a lot more difficult
16:41:19 <hyrax42> ok quick q
16:41:23 <Philippa> the fact there isn't an equivalent notion of "a simple haskell" doesn't help
16:41:40 <hyrax42> what are the derivable instances?
16:42:15 <Philippa> an interpreter for terms in a haskell-like language with variables, lambda, application, case statements and let statements isn't so hard to do, a lot of the work's in the typechecker
16:42:40 <Philippa> but then IIRC a call-by-name implementation of haskell98's entirely valid - just slow
16:42:57 <hyrax42> I was looking in wiki and saw stuff like deriving MonadRandom
16:43:33 <Cale> Eq, Ord, Enum, Bounded, Show, and Read
16:43:37 <Cale> oh
16:43:40 <Cale> for newtypes
16:43:44 <hyrax42> oh
16:43:46 <hyrax42> ok
16:43:50 <Cale> anything that the original type has
16:43:52 <hyrax42> it had me a little confused
16:44:21 <Cale> oh, also Typeable, I think, and possibly a few others in GHC
16:44:26 <hyrax42> an extensible "deriving" would be cool
16:44:31 <Cale> yeah
16:44:36 <hyrax42> but I know it's ongoing research
16:44:55 <hyrax42> I like the sum of products approach
16:45:48 <hyrax42> thanks for the newtype clarification, Cale
16:45:56 <hyrax42> I'll get to bed now
16:45:59 <hyrax42> night
17:11:44 <foxy_> @where primes
17:11:44 <lambdabot> I know nothing about primes.
17:12:40 <nealc> foxy_, what do you want?
17:13:08 <foxy_> nealc, I want to know whether 59 is prime without starting up a ghc session :)
17:13:48 <Pseudonym> > [ f | f <- [2..58], 59 `mod` f == 0 ]
17:13:49 <lambdabot>  []
17:13:50 <Lemmih> ?vixen Is 59 a prime number?
17:13:51 <lambdabot> isn't it obvious?
17:14:01 <Pseudonym> > [ f | f <- [2..59], 60 `mod` f == 0 ]
17:14:03 <lambdabot>  [2,3,4,5,6,10,12,15,20,30]
17:15:13 <nealc> > sieve (x:xs) = x : sieve [ y | y <- xs, ( y `mod` x) > 0]
17:15:14 <lambdabot>  Parse error
17:15:24 <nealc> :)
17:16:03 <nealc> lambdabot, how do I do a lambda recursive?
17:18:01 <Pseudonym> > let sieve (x:xs) = x : sieve [ y | y <- xs, ( y `mod` x) > 0] in sieve [2..]
17:18:02 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
17:18:50 <foxy_> ;D
17:22:04 <nealc> Pseudonym, good
17:36:50 <Pete_I> how do you measure the # of digits in a number?
17:37:17 <Pete_I> something with the length function, but i can't figure out how to turn the number into a string.
17:37:25 <Pete_I> is that necessary?
17:38:54 <nealc> no
17:39:01 <nealc> you can use logarithm
17:39:15 <kpreid> (if precision is not necessary)
17:39:38 <nealc> you can ceil it
17:39:43 <musasabi> > length (show 2^10)
17:39:43 <lambdabot>  add an instance declaration for (Num String)
17:39:44 <LordBrain> show will turn it into a string
17:39:53 <LordBrain> > show "34.3"
17:39:54 <lambdabot>  "\"34.3\""
17:40:00 <Pete_I> show, that's it. thanks.
17:40:03 <kpreid> nealc: that won't work for multiples of 10
17:40:05 <musasabi> > length (show (2^10))
17:40:07 <lambdabot>  4
17:40:12 <musasabi> etc
17:40:15 <kpreid> > (ceil . logBase 10) 1000
17:40:15 <lambdabot>  Not in scope: `ceil'
17:40:19 <kpreid> > (ceiling . logBase 10) 1000
17:40:21 <lambdabot>  3
17:40:29 <kpreid> > ((+1) . floor . logBase 10) 1000
17:40:30 <lambdabot>  3
17:40:38 <kpreid> uh
17:40:40 <LordBrain> i meant to say
17:40:44 <LordBrain> > show 34.3
17:40:45 <lambdabot>  "34.3"
17:40:57 <kpreid> well, see, it's imprecise :-)
17:41:29 <Pete_I> ah
17:41:42 <Pete_I> i'm using only whole numbers anyways :)
17:41:44 <kpreid> > compare (logBase 10 1000) 3
17:41:45 <lambdabot>  LT
17:42:55 * dmhouse_ wonders what he's doing up at this time
17:43:10 <dmhouse_> Huh, what's with the underscore?
17:43:32 <kpreid> > (logBase 10 1000) - 3
17:43:33 <lambdabot>  -4.440892098500626e-16
17:44:54 <madpickle> ho hum
17:45:16 <madpickle> http://www.treehugger.com/files/2006/02/loremo_ag_157_m.php
17:47:52 <Pseudonym> > let { discreteL10 0 = 0 ; discreteL10 n = 1 + discreteL10 (n `div` 10) } in discreteL10 99
17:47:53 <lambdabot>  2
17:47:56 <Pseudonym> > let { discreteL10 0 = 0 ; discreteL10 n = 1 + discreteL10 (n `div` 10) } in discreteL10 100
17:47:57 <lambdabot>  3
17:47:58 <Pseudonym> > let { discreteL10 0 = 0 ; discreteL10 n = 1 + discreteL10 (n `div` 10) } in discreteL10 101
17:47:59 <lambdabot>  3
17:48:03 <Pseudonym> The one catch is:
17:48:05 <Pseudonym> > let { discreteL10 0 = 0 ; discreteL10 n = 1 + discreteL10 (n `div` 10) } in discreteL10 0
17:48:06 <lambdabot>  0
18:05:53 <LordBrain> can lambdabot tell me the precedence of an operator?
18:11:44 <SamB> LordBrain: I don't think so
18:11:53 <SamB> certainly not last I heard
19:08:17 <LordBrain> @localtime dons
19:08:19 <lambdabot> Local time for dons is Mon Aug  7 12:07:07 2006
19:27:01 <nealc_> lambdabot, erider thinks you are the best bot.
19:27:11 <erider_> @localtime nealc_
19:27:13 <lambdabot> Local time for nealc_ is Sun Aug  6 23:22:08
19:27:53 <musasabi> where is that?
19:28:20 <nealc_> @google bot haskel list
19:28:22 <lambdabot> http://www.sil.si.edu/digitalcollections/usexex/learn/Overstreet-02.pdf
19:28:43 <erider_> brasil
19:28:55 <nealc_> @google bot haskell -lambdabot
19:28:57 <lambdabot> http://www.haskell.org/tutorial/functions.html
19:28:57 <lambdabot> Title: A Gentle Introduction to Haskell: Functions
19:29:25 <nealc_> @google "another bot" haskell -lambdabot
19:29:28 <lambdabot> http://www.centplus.com/mmorpg/poker-bot.htm
19:29:29 <lambdabot> Title: Information about poker bot
19:30:05 <nealc_> @google "another bot" haskell "not lambdabot"
19:30:07 <lambdabot> No Result Found.
19:31:01 <nealc_> @all-dict worst
19:31:03 <lambdabot> *** "Worst" gcide "The Collaborative International Dictionary of English v.0.48"
19:31:03 <lambdabot> Worst \Worst\, n.
19:31:03 <lambdabot>   That which is most bad or evil; the most severe, pernicious,
19:31:03 <lambdabot>   calamitous, or wicked state or degree.
19:31:03 <lambdabot>   [1913 Webster]
19:31:05 <lambdabot> [158 @more lines]
19:31:19 <lambdabot> That's it. I'm not replying to you any more.
19:31:35 <lambdabot> You get what you're given or write your own bot.
19:38:50 <nealc_> > let s x | to Rational (x*10) - toRational(truncate (x*10)) == 0 = 1 | otherwise = 1+s(toRational((x*10))) in (s 24.3) + (ceiling (logBase 10 24.3))
19:38:51 <lambdabot>  Not in scope: data constructor `Rational'
19:38:59 <nealc_> > let s x | toRational (x*10) - toRational(truncate (x*10)) == 0 = 1 | otherwise = 1+s(toRational((x*10))) in (s 24.3) + (ceiling (logBase 10 24.3))
19:39:00 <lambdabot>  3
19:42:13 <nealc_> Pete_I, you question was verry good. I like good questions. the fractionary part isnot measurable with logaritm. i never wonder that.
19:53:37 <dons> dcoutts__: ok, good point :) I'll look at what ghc is doing with that inner loop
19:53:44 <dons> and try to get realloc working
20:01:08 <musasabi> updated network-alt to the new FPS API.
20:03:09 <dons> good morning
20:03:15 <dons> musasabi: oh nice.
20:03:27 <dons> any problems/good things?
20:03:55 <dons> ?users
20:03:55 <lambdabot> Maximum users seen in #haskell: 216, currently: 194
20:05:03 <LordBrain> dons, I'm trying to make yi more vim compatable. Vim actually has various block-of-text concepts, like word, WORD, paragraph, and sentence.. i've got somethign worked up in side Vim.hs, but i'm wondering if we should build these concepts at a different level really
20:06:31 <musasabi> dons: was very easy.
20:07:16 <dons> LordBrain: well we have Char.hs or something, don't we?
20:07:25 <dons> which describe actions over such blocks
20:07:36 <dons> but i agree, make it more vim-ish, by all means
20:08:08 <musasabi> is there a good way to do [Bytestring] <-> ByteString.Lazy conversions (just didn't spot the right function, when looking at HAppS code)
20:08:37 <dons> hmm. we don't have an official mechanism. we should
20:08:52 <dons> Strict -> Lazy, just breaks on chunk sized bits
20:08:58 <dons> Lazy -> Strict, has to concat
20:09:23 <SamB> should be a Stringy class, but there aren't views so maybe not yet...
20:09:37 <dons> yeah. if we had views, I'd push for it, perhaps
20:09:46 <dons> maybe there's a paper there
20:09:59 * SamB really likes the name Stringy
20:10:10 <dons> class StringThing ?
20:10:13 <musasabi> dons: more interested in the list approach - don't want to the performance costs.
20:11:36 <musasabi> basically functions like: "ByteString -> IO ()" and "IO ByteString" that would be nice wrap for Lazy stuff (mapM_ and for the other unafeInterleaveIO)
20:12:41 <dons> hmm
20:13:15 <musasabi> lazyToBase :: Lazy.ByteString -> [Base.ByteString]
20:13:45 <dons> what's that do? just drop the LPS constructor?
20:13:48 <musasabi> yes
20:14:03 <musasabi> baseToLazy = LPS
20:14:19 <musasabi> interleaveBaseToLazy :: IO Base.ByteString -> IO Lazy.ByteString
20:14:25 <dons> hmm
20:14:33 <dons> not a bad idea at all!
20:15:49 <musasabi> interLeaveBaseToLazy c = fmap LPS =<< loop =<< c where loop s = if null s then return [] else do r <- unsafeInterleaveIO (loop =<< c); return s:r
20:15:57 <musasabi> or somesuch
20:18:39 <musasabi> -> sleep
20:19:07 <dons> night!
20:23:53 <dons> 18:05:53 <LordBrain> can lambdabot tell me the precedence of an operator?
20:24:00 <dons> LordBrain: that's a good idea for a plugin!
20:24:22 <dons> its a restricted binding to :info in ghci, in the Type.hs plugin
20:34:17 <LordBrain> ok.. well i havent opened up lambdabot yet
20:34:21 <LordBrain> hehe
20:37:44 <LordBrain> dons, i dont suppose you happen to know.. if i readE at the beginning of a line with no text, do i get
20:37:52 <LordBrain> '\n' ?
20:38:48 <LordBrain> i should run yi on ghci... it would be faster developing it
20:40:42 <dons> hmm, its been a while. either [] or \n, I suppose
20:40:54 <dons> use 'trace' or hPutStrLn file to check
20:42:51 <dons> LordBrain: also, if you find yourself adding generic functions, like 'grab a word' or 'read a paragraph' or such, feel free to add them into the core, not just in a mode file, since others might want to use the interface
20:43:23 <LordBrain> yeah i was thinking i'd develop in Vim.hs and eventually move things there...
20:43:57 <LordBrain> i have a function, detectMovement:: Action -> IO Bool
20:44:21 <LordBrain> which grabs the position, performs the action, and compares it with the position after, returning true if it changed.
20:44:42 <LordBrain> thats a canidate for CharMove
20:44:57 <LordBrain> i wasnt clear how minimalist i should be with the general apis
20:45:19 <LordBrain> should i just stick anything in there that might be useful generally and not worry about minimalism?
20:45:44 <dons> well, keeping it minimal is a good idea
20:45:56 <dons> if its a clean, simple function. that's good
20:46:21 <dons> if its does a bunch of things, and is a bit specialised for a particular editor , then probably just leave it in the Vim.hs
20:46:56 <LordBrain> also, i wanted to change prevWord to put you at the beginning of the word instead of the end... but i decided that would be rude
20:47:03 <LordBrain> hehe
20:47:13 <dons> heh
20:48:22 <LordBrain> anyway, vim is strange in its b and e keys i'm finding.. because its configurable... its behavior can depend on what file you have open and things.
20:49:05 <LordBrain> but i've been workign steadily toward the default behavior...
20:49:45 <dons> ok. good!
20:49:55 <dons> and you can send me patches any time :)
20:50:05 <LordBrain> good because i've already been sending..
20:50:20 <dons> oh, nothing's arrived yet...
20:50:24 <LordBrain> hmmm
20:50:29 <dons> maybe darcs send isn't getting mail off your machine?
20:50:34 <LordBrain> maybe somethign is configured wrong... or i dont know
20:50:47 <dons> you could try: darcs send -o /tmp/foo.patch ; then mail me /tmp/foo.patch manually
20:51:07 <LordBrain> yeah... check your email is right in there too
20:52:30 <LordBrain> it acted like it was sending patches.. i named them and things
20:52:44 <LordBrain> by the way, is it ok for patch names to have spaces?
20:53:54 <stepcut> sweet! my mp3 playing consumes 25% of the cpu when idle :)
20:54:50 <dons> heh
20:55:10 <dons> LordBrain: yes. patch names can have spaces
20:55:14 <LordBrain> is there a way to list out the names of the patches i recorded?
20:55:35 <dons> darcs changes | less
20:55:40 <dons> my mail seems right.
20:56:28 <LordBrain> i probably have exim wrong or something
20:57:30 <LordBrain> yeah i've got three patches supposedly sent to you
20:58:43 <dons> right. nothing has arrived
21:05:56 <LordBrain> if i have a patch that is named, and i want to rename it, is there a way i can do that?
21:09:08 <dons> hmm. you'd have to unrecord it, and then darcs record again
21:14:36 <LordBrain> dons, should i do the -o thing and send them one at a time? or send them all at once?
21:17:37 <dons> you could just send them all in one go, darcs should do that.
21:18:02 <dons> dcoutts__: ah! the fusionbench was missing -funbox-strict-fields -- seems to make a big difference in the realloc-in-inner-loop problem
21:18:29 <dons> dcoutts__: i'm getting the anticipated speed now, no unreasonable slow down
21:18:47 <dons> dcoutts__: the inner loop is up to 50% slower without -funbox-strict-fields
21:19:21 <dons> lesson: users of Data.ByteString should crank up that flag
21:33:34 <LordBrain> dons: check your email now
21:35:24 <dons> hmm, nothing yet..
21:36:47 <LordBrain> dons whats your email, maybe i'm sending it to the wrong place
21:37:36 <dons> dons <> cse.unsw.edu.au ?
21:37:37 <lispy> LordBrain: are you using 'darcs send' by any chance?
21:38:31 <LordBrain> yes
21:39:58 <lispy> LordBrain: ah, try darcs send -o mypatch.dpatch and then manually mailit
21:40:21 <dons> yeah.
21:40:23 <SamB_XP> is your "sendmail" command broken, perhaps?
21:40:25 <lispy> darcs send can successfully deliver the mail to your sendmail program and then your sendmail program might fail to deliver...
21:41:18 <LordBrain> yeah its broken, but i also manually sent them
21:41:36 <LordBrain> i already did it
21:41:58 <LordBrain> thats ok, i'll figure it out in the morning
21:42:16 <LordBrain> goodnight
21:42:25 <dons> here's a rule for us all:
21:42:31 <dons> {-# RULES
21:42:31 <dons> "map -> fused map"  [~1] forall f.
21:42:31 <dons>     map f = F.strTransformerBi (F.mapS f)
21:42:31 <dons> "unfused map -> map" [1] forall f.
21:42:31 <dons>     F.strTransformerBi (F.mapS f) = map f
21:42:33 <dons>   #-}
21:42:42 <SamB_XP> that is two rules!
21:42:42 <dons> SamB_XP: a cookie for you, if you can figure that out.
21:42:56 <dons> its really really super cool
21:43:06 <dons> (now that ghc actually works properly in its rule matching)
21:43:21 <SamB_XP> what did it do before?
21:43:39 <dons> it just wouldn't match many things
21:44:00 <dons> so, can you see what that does? with the phasing annotations?
21:44:01 <SamB_XP> like what?
21:44:17 <SamB_XP> sort of
21:44:19 <dons> oh, if some 'let's got in the way.
21:44:23 <dons> then the rule wouldn't fire
21:44:32 <SamB_XP> oh, so they fixed that?
21:44:35 <dons> yep
21:44:40 <SamB_XP> sweet
21:44:49 <dons> as of around the 24th  of last month. now things really seem to fuse nicely
21:54:49 <jgrimes> how does [~1] work? Does that do a replace during preprocessing?
21:55:36 <SamB_XP> something like "before stage 1", I think...
21:55:51 <jgrimes> right... I guess my question was... what is stage 1?
21:55:52 <jgrimes> :)
21:56:06 <SamB_XP> probably the last stage
21:56:11 <jgrimes> oh
21:56:11 <jgrimes> ok
21:56:22 <dons> its the last inlining phase we can do reasonable pattern matching on the Core.
21:56:29 <jgrimes> ah.
21:56:33 <dons> before the unconditional inlining kicks in
21:56:41 <SamB_XP> there is a stage 0?
21:56:52 <dons> so the idea is that in any phase, rewrite map to a fuseable form.
21:57:15 <dons> then if at the end, there's fuseable maps left over, rewrite them back to the original, fast-but-not-fuseable map
21:57:52 <jgrimes> ok
21:57:52 <SamB_XP> the plain old list fusion code does essentially the same thing
21:57:56 <dons> yep
21:58:12 <SamB_XP> because the fusable forms of the list-processing functions are a bit less efficient, too
21:58:30 <SamB_XP> or something like that
21:58:41 <SamB_XP> maybe just slower to optimize, I dunno...
21:59:37 <SamB_XP> hmm, need sleep
21:59:43 <jgrimes> yeah, same :)
22:00:03 <SamB_XP> will go now
22:00:15 * SamB_XP goes
22:00:43 * stepcut notes that using -O2 is probably good *first* step when trying to optimize code
22:00:55 <Cale> It's rather cool to be able to encode that sort of information into a library, but it would be better if it could be done in a less GHC-specific way.
22:01:29 <dons> you do encode them into a library. as rules :)
22:01:44 <Cale> but rules are definitely GHC specific
22:01:48 <dons> yeah.
22:02:02 <dons> though they needn't be. we could agree on a term rewriting for Core system
22:02:10 <jgrimes> I was just about to ask if any others had the rules pragma :)
22:02:16 <Cale> If we could agree on Core :)
22:03:13 <dons> its not even core you match on. the rules only contain haskell fragments
22:03:42 <dons> so , the language could have a term rewriting phase. it _could_ be done.
22:03:49 <Pseudonym> The real problem with rules is that there are no guarantees.
22:03:52 <Cale> Ah, right, so you wouldn't really even need that. You could standardise some fairly high-level mechanism for it.
22:04:02 <dons> Pseudonym: on what? termination?
22:04:08 <dons> or are you thinking of something else.
22:04:11 <Pseudonym> That they are applied at all.
22:04:16 <dons> right
22:04:22 <dons> its all down to how the compiler produces Core
22:04:25 <Pseudonym> Right.
22:04:26 <dons> and how good the pattern matching is
22:04:39 <Pseudonym> A TH-like system is better in that respect.
22:04:54 <Pseudonym> Sometimes, the optimisation is what makes the program tractable.
22:04:58 <dons> maybe. though the high level haskell language is too big, too many cases to consider
22:05:07 <Pseudonym> Not true in the case of foldr/build.
22:05:12 <Cale> Could you do what you do with rules if they were all applied in a separate pass before any further transformation? Probably not as well?
22:05:45 <dons> Pseudonym: yeah, these fusion combinator systems do the job nicely, since they're usually in terms of only a hand full of functions
22:05:56 <Cale> Well, you'd definitely miss things which would show up only after inlining
22:05:57 * Pseudonym nods
22:06:10 <dons> other kinds of optimisatoins (I'm thinking DSL-type algebraic ones) have problems on the TH level
22:06:19 <dons> that would be easier with all the sugar thrown out
22:07:50 <Pseudonym> The only way to get guarantees, I think, is to build a self-optimising system in TH.
22:08:00 <Pseudonym> And then your libraries become just as maintainable as C++ template code.
22:08:22 <dons> heh
22:08:40 <Cale> You could also take a fairly large hit in time complexity of compiling :)
22:08:51 <Pseudonym> Sure, but that's the price you pay.
22:08:57 <dons> indeed we do already with this rules stuff
22:09:07 <dons> you really feel it kicking in
22:09:18 <Pseudonym> The thing is, I've done a few programs which optimise themselves at run-time.
22:09:26 <Pseudonym> It'd be nicer if that could be done at compile-time.
22:14:25 <dons> hmm,15:10 [slashnet] -smkelly(smkelly@cloak-62C8A953.zombie.org)- Kyle did it.
22:14:56 <Pseudonym> Oh, great.  Now I know the ending of Twin Peaks.
22:15:03 <dons> heh!
22:22:10 <Cale> Oh, great.  Now I know who killed Kenny. That bastard!
22:22:32 <Pete_I> which episode?
22:22:42 <Cale> heh
22:22:43 <Pete_I> :)
22:23:00 <Pete_I> kenny must be immortal or something. he keeps coming back.
22:32:59 * Cale listens to John Scofield's 1998 album "A Go Go"
22:37:06 * Pseudonym listens to Rachmaninov's 2nd piano concerto
22:49:30 <dcoutts__> Lemmih: ping!
22:50:07 <dcoutts__> dons: woo!
22:51:06 <dcoutts__> dons: I had thought that -funbox-strict-fields was only needed to unbox things into constructors
22:51:30 <dcoutts__> and that if you put {-# UNBOX #-} everywhere that it'd not be needed
22:51:46 <dcoutts__> seems I was wrong
22:51:57 <dcoutts__> well, that's a good result
22:52:06 <Cale> http://www.boasas.com/?c=681 -- ahaha
22:52:07 <lambdabot> Title: [Boy on a Stick and Slither]
22:52:49 <dcoutts__> perhaps -funbox-strict-fields should be in -O or -O2
22:53:38 <Cale> hmm, is there any reason not to unbox strict fields?
22:55:24 <dcoutts__> it can sometimes be a pesimisation
22:55:37 <dcoutts__> if you need to rebox straight after
22:55:51 <dcoutts__> but generally it's a great optimisation
22:56:48 <dcoutts__> dons: so I'll have a few hours today (between family activities) to work on paper stuff
22:56:58 <dcoutts__> so tell me if there's anything you want me to do
22:57:13 <dcoutts__> I was looking at zipWith[S]
22:57:50 <dcoutts__> the Skip kind of gets in the way for zipWith, making it more complex
22:58:36 <dcoutts__> since one stream might yield and the other skip
22:59:07 <dcoutts__> in which case you can wither skip overall and forget the yield
22:59:15 <dcoutts__> or skip and remember the yield
22:59:30 <dcoutts__> or recurse locally 'til you get a non-skip
22:59:54 <dcoutts__> I think the remembering you had one is probably better
23:00:23 <dcoutts__> ie recurse on the left 'til you get a value, then on the right
23:00:55 <dcoutts__> so it needs a bool state value to say if we're waiting for a left or a right
23:02:08 <dcoutts__> dons: spj suggested a way we might be able to remove the bool state values that ruin the performance of appendS/consS/snocS
23:02:21 <dcoutts__> it involved using a higher order thing
23:02:29 <dcoutts__> which may not work at all
23:02:48 <dcoutts__> or may end up working really slowly due to the higher orderness not bein eliminated
23:02:53 <dcoutts__> or may be really good
23:03:05 <dcoutts__> so that's worth a quick investigation
23:03:28 <dcoutts__> dons: I might try that in the absence of any instructions from yourself :-)
23:04:27 <dcoutts__> musasabi: re [Bytestring] <-> ByteString.Lazy. No not yet, but I think there should be.
23:04:46 <dcoutts__> musasabi: and indeed that should be prefered as a primitive over Bytestring <-> ByteString.Lazy
23:05:36 <dcoutts__> musasabi: as you say, ByteString.Lazy -> [Bytestring] is free
23:06:15 <dcoutts__> musasabi: and [Bytestring] -> ByteString.Lazy is just a O(n) lazy check, so it's sort of O(1) amortised
23:06:53 <dcoutts__> musasabi: I don't want to expose the LPS constructor directly as we might end up changing the representation to use lists with unboxed elements
23:13:35 <Itkovian> meuning
23:14:05 <dcoutts__> good meuning to you sir
23:34:19 <dons> hey dcoutts__
23:35:36 <dons> dcoutts__: I was wondering if you'd like to investigate why the map->mapS/mapS->map rules don't match the mapS->map case
23:35:56 <dons> (and similarly for other plain->fuse [~1], fuse->plain[1] rule pairs)
23:36:05 <dons> or else, look at zipWith* and concatMAp
23:37:15 <falconair> hi, i'm making my way through "Composing Contracts" b SP Jones, it describes a combinator library for financial contracts...having never done function programming, i'm not sure how to actually code it: is there another example of a combinator library which might help me understand the paper I mentioned before?
23:38:31 <dons> hmm.
23:38:38 <dons> hard question, falconair
23:38:49 <dons> you want an introduction to combinator libraries?
23:39:52 <falconair> yeah, with code.  for example, this paper has combinators zero, one, when, anytime...i don't even know if these are 'functions' or constructors of a type (comblib = zero | one | when | anytime...)
23:40:54 <dons> they're just functions, most likely
23:41:07 <dons> (constructors are functions too..)
23:42:28 <falconair> that's what i originally thought, but the 'zero' combinator (?) simply returns a zero...but it is of a type called 'Contract' ... so i can't just return a zero, i have to return a 'contract' of value zero...and the contract is made up of these combinators...so perhaps these really aren't function...eh...i'm confused
23:42:50 <Itkovian> how do I get the fpstring.o to be included in the build of the profiled fps libs?
23:43:03 <dons> oh, you running into a Cabal bug, Itkovian ?
23:43:03 <dcoutts__> dons: right'o
23:43:29 <dons> Itkovian: most likely Cabal expects fpstring.o to be in a certain place . symlink to it from that localtion, and things should go ok
23:43:34 <Itkovian> dons: no idea, I just see that the fps_count etc remain undefined in the .a
23:43:35 <Itkovian> ok
23:43:39 * Itkovian checks
23:43:42 <dons> dcoutts__: ok, what?
23:44:17 <dons> dcoutts__: so you have a handle on the state of the stream code at the moment?
23:44:18 <dcoutts__> dons: I'll look at the rules fusable<->unfusable forms or concatMap/zipWith
23:44:24 <dcoutts__> I think so
23:44:37 <dcoutts__> unless you've been making major changes recently :-)
23:44:45 <dons> essentially, I just tuned it, and added more fuseable functions
23:44:58 * dcoutts__ darcs pulls
23:45:05 <dons> the lazy bytestring fuseable stuff is very slow though
23:45:10 <dcoutts__> aye
23:45:11 <dons> i'm not sure why yet
23:45:26 <dons> also, some of the writeLStr (iirc) breaks the lazy invariant
23:45:28 <dcoutts__> wow! lots of patches
23:45:43 <dons> the StreamProperties.hs QC catches the invariant breakers
23:45:49 <dcoutts__> ok
23:45:50 <dons> anyway, we can leave the lazy stuff on the side for nwo
23:46:07 <dons> ideally, I think we should get concatMap, zipWith and append fused
23:46:14 <dcoutts__> indeed, that'd be nice
23:46:23 <dcoutts__> it's what spj suggested would be interesting
23:46:34 <dcoutts__> to see how this fusion method compares to build/fold
23:46:37 <dons> and also the 2-phase issue, of turning map' -> mapS, and mapS -> map'
23:47:10 <dcoutts__> it's not going back you say
23:47:16 <dons> this last thing is crucial I think , since things like emptyS or consS have bad complexity
23:47:19 <dons> dcoutts__: right
23:47:27 <dcoutts__> yeah, for map it's ok but for length etc
23:47:29 <dons> i.e. map will turn into mapS
23:47:36 <dons> but lone mapS aren't being switched back
23:47:44 <dons> i've _never_ been able to get this trick to work, in fact
23:47:49 <dcoutts__> heh
23:48:01 <dcoutts__> so when do they get inlined?
23:48:04 <dcoutts__> what phase
23:48:05 <dons> dcoutts__: right, length/empty/head/last/... anything whose complexity is worse in streamed form
23:48:22 <dons> well, its a bit tricky reading those phasing numbers..
23:48:25 <dcoutts__> we need to make sure we write then back in a phase beforethey get inlined
23:48:31 <dons> it seems to be: phase gentle -> phase 2 -> phase 1 or something
23:48:35 <dcoutts__> yeah [~?]
23:48:54 <dons> right. currently we have [~1] and [1]
23:48:57 <dcoutts__> I copied the rules & phases from ghc base
23:49:01 <dons> yeah.
23:49:09 <dons> now I wonder if map/build-map even works..
23:49:18 <dcoutts__> but that also depends on the phase in which we inline readStr/mapS etc
23:49:25 <dons> yep
23:49:33 <dcoutts__> ok I'll look at that first
23:49:51 <dons> i suggest hackign tests/fuse.hs and watching -ddump-simpl-iterations
23:50:05 <dcoutts__> yes
23:50:06 <dons> and just check that I comitted the rules for map->mapS, and back
23:50:20 <dcoutts__> that's what I did before when diagnosing RULES issues
23:51:46 <dons> aside from this, the basic set of fuseable ops are running very nicely now.
23:51:52 <dcoutts__> :-)
23:52:02 <dons> definitely seems to be a win over wrap/map/filter, or fps 0.7, with the same compiler
23:52:15 <dcoutts__> yeah
23:52:32 <dons> there's a small, ~5% overhead, for adding the extra realloc inside the inner loop (the cost of the offset check)
23:52:39 <dons> but we can probably live with that
23:52:41 <dcoutts__> right, that's ok
23:52:50 <dcoutts__> I think it's worth it to fuse things like pack
23:52:53 <dcoutts__> and utf8
23:52:56 <dons> right.
23:53:03 <dcoutts__> and concatMap etc etc
23:53:15 <dcoutts__> dons: spj said I need to be specific about the property required for strFooBi
23:53:21 <dons> ah right.
23:53:26 <dcoutts__> I think the property is just associatvity
23:53:31 <dcoutts__> sound right?
23:53:38 <dons> has to produce the same result, running left to right, or right to left
23:53:39 <dcoutts__> not commutativity too
23:54:48 <dons> how do we apply these terms to loop directions?
23:54:58 <dcoutts__> hmm?
23:55:25 <dons> oh, you want associativity of: bi (dn f) or dn (bi f) ?
23:55:56 <audreyt> if I have
23:56:00 <audreyt> class C a b
23:56:02 <dons> i was thinking about the constraint on the function 'g', in (bi g). that it must produce the same value running in both directions
23:56:04 <audreyt> is it possible to say
23:56:28 <int-e> Oh, darcs pull <fps-unstable> is broken again. (probably a permission problem)
23:56:31 <audreyt> newtype Foo = MkFoo String deriving ((`C` Int))
23:56:35 <dcoutts__> dons: yes exactly, I'm talking about the property of g in bi g
23:56:47 <audreyt> if I had a "instance C String Int"?
23:56:59 <dons> int-e checking...
23:57:01 <dcoutts__> dons: I think g needs to be associative
23:57:57 <dons> ah
23:58:44 <dcoutts__> at least for strConsumerBi
23:58:51 <dcoutts__> for strTransformerBi ...
23:58:55 <dons> so we want to know if that is the same as saying it produces the same result when g is applied up or down?
23:59:05 <dcoutts__> right
23:59:12 <int-e> dons: thanks, works now
23:59:27 <dons> i.e. if  dn g == up g then OK (bi g)
