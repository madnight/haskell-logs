00:11:06 <Tela> ooh... I found the Monad as a Nuclear Waste Container
00:11:18 <Tela> It's like a scavenger hunt.
00:28:13 <ski> hm, microwave ovens usually have windows
00:29:48 <ski> (plural, since the lattice in effect subdivides the whole into many small windows)
00:45:09 <dons> Cale, oh more news. my department is having a power upgrade in 24 hours, and thus loses power for about 15 hours. So lambdabot will disappear this time tomorrow no matter what, and won't be back for 24 hours or longer, depending on the ip quota issue
00:45:27 <Cale> okay
00:46:20 <dons> I'm thinking it might be useful to have an @on/@off plugin
00:46:33 <dons> so that we could have backup lambdabots actually sitting in the channel
00:46:41 <dons> and they can be turned on and off, via a Base plugin command
00:48:56 <dons> ?pl fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
00:48:56 <lambdabot> fix ((1 :) . (1 :) . ap (zipWith (+)) tail)
00:49:02 <dons> not bad
00:58:42 <mnislaih> Morning
01:01:07 <lispy> http://blog.codersbase.com/2006/08/17/learn-math-10-tips/
01:01:14 <lambdabot> Title: dagit.o » Blog Archive » Learn Math (10 tips)
01:07:07 <dons> interesting lispy
01:08:44 <lispy> thanks
01:10:49 <dons> @tell ndm how about kind searching in hoogle? just to be complete
01:10:49 <lambdabot> Consider it noted.
01:13:23 <dons> @tell shapr the "Here come the Booleans" sketch is lovely
01:13:24 <lambdabot> Consider it noted.
01:18:59 <shapr> She's working on a monad right now.
01:18:59 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
01:24:07 <dons> nice :)
01:42:04 <ski> (shapr : row 0 is the (converse-)dual of implication, called "subtraction" or "difference" by some .. also, why is row 6 called 'consequence' ?)
01:50:29 <dmhouse> Morning everyone.
01:50:29 <lambdabot> dmhouse: You have 2 new messages. '/msg lambdabot @messages' to read them.
01:50:42 <ski> morning
01:51:08 * dmhouse gets his results in about 20 minutes
01:55:01 <ski> (results ?)
01:55:24 <dmhouse> Exams.
01:55:51 <dmhouse> They're minor-ish exams, they form part of my A-levels if you're familiar with the English education system.
01:57:24 <ski> mhm
02:00:37 <ivant> dons, what is "Here come the Booleans"? I can't find it using google
02:01:12 <dons> check out http://planet.haskell.org
02:01:13 <lambdabot> Title: Planet Haskell
02:03:06 <xerox> G'day!
02:04:36 <dmhouse> dons: hehe :)
02:04:39 <dmhouse> Morning xerox
02:05:10 * dmhouse is off
02:06:35 <xerox> http://chneukirchen.org/blog/archive/2006/08/side-effects-in-real-life.html
02:06:39 <lambdabot> Title: chris blogs: Side-effects in real life
02:06:58 <xerox> @where nymphaea
02:06:59 <lambdabot> http://haskell.galois.com/~paolo/nymphaea
02:07:01 <xerox> ^- wolverian :)
02:20:39 <dons> mmm. http://www.cse.unsw.edu.au/~chak/project/fc/
02:20:39 <lambdabot> Title: Manuel M T Chakravarty - Type Functions in GHC
02:21:56 <dons> edwardk: http://hackage.haskell.org/trac/ghc/wiki/TypeFunctions
02:21:58 <lambdabot> Title: TypeFunctions - GHC - Trac
02:24:21 <dons> heh, they're even considering: "We currently don't allow associated GADTs.'
02:24:57 <xerox> type index?
02:25:11 * xerox scratches head
02:25:35 <dons> might be some papers to read ;)
02:25:46 <dons> "Indexed type constructors: Type constructors that are defined via one or more type declarations that have non-variable parameters. We often call them sloppily just indexed types. We informally call constructors that are not indexed vanilla constructors."
02:26:18 <dons> ah, examples,
02:26:20 <ivant> guys, can somebody point out some good example of marshalling the C-structures to Haskell. "Tackling the Awkward Squad" doesn't tell anything about it :-(
02:26:23 <dons> data family Map k :: * -> *
02:26:23 <dons> data instance Map ()     v = MapUnit (Maybe v)
02:26:23 <dons> data instance Map (a, b) v = MapPair (Map a (Map b v))
02:26:33 <dons> ivant: hmm, there a little bit here;
02:26:51 <dons> ?wiki Wc
02:26:51 <dons> grr
02:26:51 <lambdabot> http://www.haskell.org/haskellwiki/Wc
02:27:06 <dons> otherwise, read the haskell ffi addendum
02:27:47 <xerox> Yeah the example is alien syntax :P
02:27:58 <dons> :)
02:28:24 <pmurias> hi,
02:28:36 <pmurias> is anybody familiar with yhc here?
02:28:53 <dons> ndm and beelsebob should be able to help you
02:28:59 <alar> How do I defeat "the instance type must be of form (T a b c) where T is not synonym" error? -fallow-overlapping-instances?
02:29:00 <dons> if they're around
02:29:12 <dons> hmm, possibly just -fglasgow-exts ?
02:29:24 <xerox> I think it is a syntax error?
02:29:25 <dons> or else don't but a type synonym in there?
02:29:40 <dons> yeah
02:29:42 <ivant> dons, I actually read both but my brain is overflowing
02:30:04 <alar> I'm trying to define instance (Num a,Show a)=> Num (Either a String)
02:30:05 <dons> oh, you should get a cup and try to catch anything that flows out. you'll need it later
02:30:17 <dons> String -> [Char] ?
02:30:25 <alar> in Hugs it seems to be OK, but Visual Haskell complains
02:30:31 <xerox> You need to newtype that I believe.
02:31:02 <dons> -fglasgow-exts works for me
02:31:03 <ski> doesn't 'Num' subclass 'Show' ?
02:31:10 <xerox> Yes it does.
02:31:12 <alar> ok, thanks
02:31:12 <dons> yeah, I think so.
02:31:38 <xerox> What do you do with such an instance, if I could ask?
02:32:55 <dons> its a pretty wacky instance :)
02:33:04 <alar> xerox: Num a is the case when number in a file is parsed correctly, String is parse error
02:33:06 <dons> I suppose: Right () + Left "xyz" ?
02:33:18 <ivant> @seen ndm
02:33:19 <lambdabot> I saw ndm leaving #haskell-overflow, #haskell-blah and #haskell 16 hours, 43 minutes and 32 seconds ago, and .
02:33:29 <ivant> @seen beelsebob
02:33:30 <lambdabot> I saw beelsebob leaving #haskell 4 hours, 55 minutes and 23 seconds ago, and .
02:33:39 <dons> so ndm should wake up soon
02:34:00 <xerox> alar: why do you want to treat the cases at `arithmetic' level? :)
02:34:01 <alar> and this instance allows me to handle both cases uniformly
02:34:43 <dons> seems a little odd. its rare to see non-obvious Num instances
02:35:01 <dons> but to each, their own :)
02:35:33 <alar> I do a lot of arithmetic, and if my code will reject seemingly incorrect parses , it will spit errors like camel
02:36:14 <alar> and I need to understand as many files as I can: so I swallow some seemingly incorrect cases
02:36:30 <alar> and forward them to my resulting file :))
02:36:47 <ski> fast and wrong ?
02:36:59 <alar> fast and tolerable
02:37:06 <ski> :)
02:37:27 <alar> e.g. "network frequency" field is not neede for propper display of graph
02:37:45 <alar> but it is needed for some sophisticated processing
02:39:14 <alar> I choose to accept nonsense in this field when parsing, but check before I output something: whether i accepted more nonsense than I should
02:41:27 <alar> also there are 3 fields and each is computable from 2 others
02:42:43 * xerox hugs everybody
02:43:00 <xerox> They've added a entry about Google SoC with my name on the History of Haskell paper...
02:43:06 <xerox> How nice!!
02:44:29 <ivant> hmm, lambdabot forgot to un-rot13 the fortune
02:46:01 <ivant> @fortune
02:46:03 <lambdabot> The rights and interests of the laboring man will be protected and cared
02:46:03 <lambdabot> for not by our labor agitators, but by the Christian men to whom God in his
02:46:03 <lambdabot> infinite wisdom has given control of property interests of the country, and
02:46:03 <lambdabot> upon the successful management of which so much remains.
02:46:03 <lambdabot> 		-- George F. Baer, railroad industrialist
02:46:15 <ivant> and now it is ok
02:46:51 <dons> some are in rot13 for fun, I think
02:47:10 <xerox> @yow
02:47:11 <lambdabot> I'm dressing up in an ill-fitting IVY-LEAGUE SUIT!!  Too late...
02:47:12 <ivant> we need the rot13 plugin for lambdabot then :-)
02:47:33 <dons> no no, just compose the @run plugins with @fortune
02:47:40 <Cale> http://cale.yi.org/index.php/Artwork :)
02:47:58 <Cale> Got a mediawiki working finally.
02:48:07 <xerox> Uh, mediawiki.
02:49:29 <Cale> yes :)
02:49:55 <dons> ?state (\x -> map toUpper x)
02:49:55 <lambdabot> (\x -> map toUpper x)
02:49:58 <merus> somebody should port the wiki engine to haskell :)
02:49:58 <Cale> It's somewhat overkill for a personal site :)
02:50:06 <dons> ?. run . ++
02:50:06 <lambdabot>  Parse error
02:50:11 <xerox> I'd say so :)
02:50:17 <dons> ?. run . ++ . id "text"
02:50:17 <lambdabot> compose module failed: IRCRaised Parse error: "\"text\""
02:50:23 <dons> ?. run . ++ . id text
02:50:23 <lambdabot> compose module failed: IRCRaised Parse error: "text"
02:50:27 <xerox> ?state
02:50:28 <lambdabot> (\x -> map toUpper x)
02:50:29 <dons> ?. show id text
02:50:29 <lambdabot> "text\n"
02:50:31 <merus> That'd be a cool trick.  It'd probably run faster, too.
02:50:44 <dons> ?. run . ++ . show id text
02:50:45 <lambdabot>  "TEXT\n"
02:50:59 <Cale> But all the features I'll end up wanting (go diagrams, mathematical notation, etc.) are already plugins for it, so I don't have to worry about implementing them myself.
02:51:00 <xerox> dons haha I just realized what you're trying to do
02:51:07 <dons> ?state (\x -> let rot13 = id in rot13 x)
02:51:08 <lambdabot> (\x -> let rot13 = id in rot13 x)
02:51:09 <dons> ?. run . ++ . show id text
02:51:10 <lambdabot>  "text\n"
02:51:16 <dons> so now, just find a rot13 one liner
02:51:31 <xerox> Cale, right. What was the last one, oddmuse?
02:51:35 <Cale> yeah
02:51:38 <Cale> On my previous wiki, I'd implemented go diagrams by hand, in ugh, perl.
02:51:52 <xerox> chr . (`mod` something) . (+13) . ord
02:51:55 <ivant> I found this: http://www.miranda.org/~jkominek/rot13/haskell/rot13.hs
02:51:55 <merus> Cale: oooh~
02:52:00 <ivant> but it is not a one-liner
02:52:14 <dons> ?state (\x -> map (chr . (`mod` something) . (+13) . ord) x)
02:52:14 <lambdabot> (\x -> map (chr . (`mod` something) . (+13) . ord) x)
02:52:26 <xerox> let me find the something
02:52:40 <xerox> > ord 'a' - ord 'z'
02:52:41 <lambdabot>  -25
02:52:44 <dons> yeah, what's with these really verbose rot13.hs ?
02:52:49 <xerox> > ord 'A' - ord 'Z'
02:52:51 <lambdabot>  -25
02:52:54 <dons> you'd think someone would have a pointfree oneliner
02:53:03 <Cale> One of the things which I didn't back up when reinstalling my machine was the contents of my webserver, since I wanted to redo it, and it was a mess anyway.
02:53:07 <xerox> > map ord "aAzZ"
02:53:07 <ivant> I guess so
02:53:08 <lambdabot>  [97,65,122,90]
02:53:28 <xerox> > 122-65
02:53:30 <lambdabot>  57
02:53:34 <xerox> Maybe that.
02:56:06 <Stinger_> what does pointfree mean? as a single expression (no lambdas,lets etc)?
02:56:29 <xerox> No formal parameters (points).
02:57:27 <ivant> > (((ord 'n') - 97)+13 +26) `mod` 26
02:57:29 <lambdabot>  0
02:58:49 <dons> Stinger_: yep, basically
02:58:55 <dons> ?pl \x y -> x f y
02:58:56 <lambdabot> ($ f)
03:01:07 <dons> Stinger_:
03:01:11 <dons> ?wiki Pointfree
03:01:11 <lambdabot> http://www.haskell.org/haskellwiki/Pointfree
03:01:25 <xerox> > let rot13 = map (chr . (+(ord 'a')) . (`mod` 26) . (+13) . (subtract (ord 'a')) . ord . toLower) in rot13 (rot13 "hello")
03:01:26 <lambdabot>  "hello"
03:01:43 <dons> good!
03:01:51 <ivant> does it work for the uppercase?
03:01:53 <xerox> More or less
03:02:03 <dons> ?state ( map (chr . (+(ord 'a')) . (`mod` 26) . (+13) . (subtract (ord 'a')) . ord . toLower)
03:02:03 <lambdabot> ( map (chr . (+(ord 'a')) . (`mod` 26) . (+13) . (subtract (ord 'a')) . ord . toLower)
03:02:08 <xerox> > let rot13 = map (chr . (+(ord 'a')) . (`mod` 26) . (+13) . (subtract (ord 'a')) . ord . toLower) in rot13 (rot13 "It will DOWN CAsE")
03:02:09 <lambdabot>  "itnwillndownncase"
03:02:14 <xerox> Yuck, spaces too.
03:02:15 <dons> ?. run . ++ . show id some text goes here
03:02:16 <lambdabot>  Parse error
03:02:17 <Stinger_> and remove spaces :D
03:02:25 <dons> ?. run . ++ . show id sometext
03:02:26 <lambdabot>  Parse error
03:02:34 <dons> ?state ( map (chr . (+(ord 'a')) . (`mod` 26) . (+13) . (subtract (ord 'a')) . ord . toLower) )
03:02:34 <lambdabot> ( map (chr . (+(ord 'a')) . (`mod` 26) . (+13) . (subtract (ord 'a')) . ord . toLower) )
03:02:37 <dons> ?. run . ++ . show id sometext
03:02:38 <lambdabot>  "fbzrgrkge"
03:02:50 <dons> ?. run . ++ . show fortune
03:02:51 <lambdabot>  "hjnejavfavafgvapgviroaaohgaguravafgvapgapnaaorasbhtugoaajrherauhznaeorvatfa...
03:02:53 <dons> hehe
03:02:54 <xerox> :P
03:03:03 <xerox> Is it swedish?
03:03:05 * xerox ducks
03:03:06 <ivant> we need mapWhen
03:03:20 <ivant> :-)
03:03:22 <norpan> not swedish
03:03:27 <xerox> What is its type?
03:03:29 <Stinger_> no "bork"s in there
03:03:49 <norpan> exactly
03:04:02 <norpan> but i have to inform you that bork is not a swedish word
03:04:36 <dons> no?? I've been severely misled on this matter, then
03:04:38 <Stinger_> just about my entire knowledge of sweedish culture comes from that chef on the muppets
03:07:34 <norpan> possible candidates are "borg", "kork", "ork", etc
03:07:36 <xerox> I think I have a better one!
03:08:20 <xerox> > let rot13 = map (chr . (`mod` 128) . (+64) . ord) in rot13 (rot13 "Evil, punctuation?!  And whitespace-casing:@StrinG!")
03:08:20 <dons> "ork" is good
03:08:21 <lambdabot>  "Evil, punctuation?!  And whitespace-casing:@StrinG!"
03:08:32 <dons> oh good
03:08:45 <xerox> (OK call it rot64 :P)
03:09:00 <dons> yeah, looks nice though
03:09:42 <xerox> > length (filter isAscii ([minBound..maxBound] :: String))
03:09:43 <lambdabot>  128
03:09:48 <xerox> (That's why.)
03:12:16 <alar> aha
03:12:30 <norpan> > length (filter (liftM2 (&&) isAscii isPrint) ([minBound..maxBound] :: String))
03:12:31 <lambdabot>  95
03:12:38 <Cale> alt.swedish.chef.bork.bork.bork
03:12:39 <alar> seems that IDE does not pass "-fglasgow-exts" to GHC
03:13:05 <Cale> alt.adjective.noun.verb.verb.verb
03:13:23 <norpan> .interj.interj.interj
03:14:01 <dons> alar: there must surely be a way to set that though
03:14:15 <dons> at least via {-# OPTIONS -fglasgow-exts #-} in the src file
03:14:17 <alar> yes
03:14:24 <Stinger_> thats what lambdabot needs, sweedish chef mode :)
03:14:53 <Cale> alt.adjective.noun.verb.verb.verb is an actual group though :)
03:15:02 <ivant> http://en.wikipedia.org/wiki/Swedish_Chef
03:15:10 <xerox> > catMaybes . map (\x -> do { guard (liftM2 (&&) isAscii isPrint x); return x} :: Maybe Char) $ ([minBound..maxBound] :: String)
03:15:10 <Cale> http://groups.google.com/group/alt.adjective.noun.verb.verb.verb?lnk=gschg
03:15:11 <lambdabot> Title: Google Groups: alt.adjective.noun.verb.verb.verb
03:15:12 <lambdabot>  " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefgh...
03:15:16 <xerox> :D
03:15:19 <dons> I think a swedish chef, combined with a megamonad
03:15:39 <ivant> bork = return ?
03:15:51 <dons> heh
03:15:59 <dons> i think bork must be (.) considering how often its used
03:16:06 <dons> f `bork` g `bork` h
03:16:14 <xerox> Or ap :)
03:16:19 <dons> >>= perhaps
03:16:32 <ivant> yeah, >>= is good
03:16:48 * alar thinks he knows russian analogue for bork
03:16:56 <dons> @pl \a (b,c) -> a c b
03:16:56 <lambdabot> (`ap` snd) . (. fst) . flip
03:16:57 <ivant> or even >> (and the result goes away)
03:17:00 <norpan> indeed
03:17:06 <ivant> alar: what is it?
03:17:09 <dons> is: (`ap` snd) `bork` (`bork` fst) `bork` flip
03:17:11 <norpan> but bork is clearly an interjection
03:17:21 <dons> ?pl \x y -> x . f . y
03:17:22 <lambdabot> (. (f .)) . (.)
03:17:28 <Cale> http://www.aanvvv.com/
03:17:29 <lambdabot> Title: alt.this.site.introduce.explain.describe | alt.adjective.noun.verb.verb.verb
03:17:35 <dons> bork (f `bork`) `bork` bork
03:17:40 <alar> ivant: english speakers sometimes mistake it for indefinite article
03:17:47 <alar> at least in anecdotes
03:17:49 <xerox> I'd the the first one differently...
03:17:57 <dons> bork `bork` bork would be fine
03:18:48 * ivant tries to recall some russian anecdote known to english language speakers
03:19:33 <ivant> bork = id, then?
03:19:34 <xerox> ?type let bork x = x (bork x) in bork
03:19:35 <lambdabot> forall t. (t -> t) -> t
03:19:45 <ivant> nah
03:19:48 <xerox> !!!
03:19:50 <Cale> haha, I like their poll
03:20:07 <dons> ?type (.) . (.)
03:20:07 <dons> ?bot
03:20:08 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
03:20:08 <lambdabot> :)
03:21:12 <alar> "russian lesson in CIA:
03:21:13 <alar> - professor, where indefinite article "blya" is placed in the phrase "kto posledniy za vodkoy?"?"
03:22:03 <ivant> oh, I didn't think about those "interjections"
03:22:21 <dons> well, if bork is an interj. then what's that, a `seq` ?
03:23:03 <Stinger_> oh sweet beaker videos, was looking for some of these a while back
03:25:48 <ivant> @djinn (a -> a) -> a
03:25:49 <lambdabot> -- f cannot be realized.
03:26:48 <alar> @type fix
03:26:50 <lambdabot> forall a. (a -> a) -> a
03:27:54 <ski> @djinn let x = a -> x in x
03:27:55 <lambdabot> Cannot parse command
03:28:12 <dons> ?djinn-help
03:28:13 <lambdabot> Cannot parse command
03:28:18 <dons> ?help djinn
03:28:19 <lambdabot> djinn <type>.
03:28:19 <lambdabot> Generates Haskell code from a type.
03:28:19 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
03:28:34 <dons> there's some djinn commands for adding new defns
03:28:58 <xerox> ((a -> a) -> a is a lie.)
03:29:32 <dons> ?djinn-add fix = (a -> a) -> a
03:29:33 <lambdabot> Cannot parse command
03:29:36 <dons> ?djinn-add fix :: (a -> a) -> a
03:29:36 <lambdabot> Cannot parse command
03:29:42 <boliver> a lie that evrybody believes :)
03:30:37 <ski> @djinn-add data Fix f = In (f (Fix f))
03:30:45 <ski> @djinn Fix ((->) a)
03:30:45 <lambdabot> Cannot parse command
03:30:46 <lambdabot> Cannot parse command
03:30:49 <norpan> ?djinn-add fix ? (a -> a) -> a;
03:30:50 <lambdabot> -- fix cannot be realized.
03:31:16 <ski> @djinn-env
03:31:16 <lambdabot> data () = ()
03:31:16 <lambdabot> data Either a b = Left a | Right b
03:31:16 <lambdabot> data Maybe a = Nothing | Just a
03:31:16 <lambdabot> data Bool = False | True
03:31:16 <lambdabot> data Void
03:31:18 <lambdabot> type Not x = x -> Void
03:31:20 <lambdabot> Error: Recursive types are not allowed: Fix
03:31:28 <ski> hrm
03:31:49 <dons> :)
03:32:01 <dons> ?djinn-clr
03:32:01 <dons> ?djinn-env
03:32:02 <lambdabot> data () = ()
03:32:02 <lambdabot> data Either a b = Left a | Right b
03:32:02 <lambdabot> data Maybe a = Nothing | Just a
03:32:02 <lambdabot> data Bool = False | True
03:32:04 <lambdabot> data Void
03:32:06 <lambdabot> type Not x = x -> Void
03:32:13 <ski> i guess 'U' won't work then, either .. :/
03:33:08 <norpan> @djinn List a -> Bool
03:33:09 <lambdabot> f _ = False
03:33:22 <norpan> cheating
03:34:28 <norpan> @djinn-add fix :: (a -> a) -> a
03:34:37 <norpan> @djinn (a -> a) -> a
03:34:37 <lambdabot> f = fix
03:34:41 <norpan> good djinn
03:34:47 <dons> good djinn
03:35:22 <xerox> O_O
03:35:30 <xerox> ...
03:35:31 <ski> @djinn bad
03:35:32 <lambdabot> -- f cannot be realized.
03:36:47 <norpan> @djinn (b -> b) -> b
03:36:48 <lambdabot> -- f cannot be realized.
03:37:01 <norpan> it's not so good after all
03:38:28 <dons> right
03:40:48 <dons> prop_reverseBP      = L.reverse     `eq1`  P.reverse seems to be failing
03:41:38 <dons> oh, wrong channel
03:42:15 <xerox> Data.Unique
03:42:19 <xerox> ?docs Data.Unique
03:42:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Unique.html
03:48:32 <ivant> bb everybody, need to go to work (finally :-) )
04:34:24 <shapr> arjanb: Are you the arjan on lwn.net?
04:37:32 <arjanb> no
05:16:40 <xerox> @yarr!
05:16:41 <lambdabot> Har de har har!
05:20:17 <xerox> Howdy astrolabe!
05:23:42 <dcoutts> @arr!
05:23:42 <lambdabot> Keelhaul the swabs!
05:23:55 <dcoutts> how's the hacking going today xerox?
05:24:40 <xerox> Waiting for a start
05:25:35 <xerox> I just noticed they did add a little paragraph on the SoC in the History of Haskell paper, so nice!
05:36:42 <ski> Ha! Ha! Ha!
05:36:47 <ski> (http://data.magicsquare.be/ouvrages/2203/305/2203305037_1g.jpg)
05:44:22 <dons> Ha!
05:46:37 <ski> (that is a pic from an Adele album, if you happen to know about it)
07:05:07 <wolverian> xerox, nice
07:05:16 <xerox> @Yarr!
07:05:17 <lambdabot> Maybe you meant: arr yarr
07:05:19 <xerox> ...
07:06:41 <wolverian> my evaluator hit a problem. the idea is that it just outputs a list of points. but that means that at the end of the branches, cairo draws a line between the end of the branch and the trunk (which is the next point). argh. why didn't I see this yesterday :)
07:07:11 <dcoutts> you'll need to stroke and start a new line
07:07:27 <dcoutts> rather than extending the current line
07:07:43 <xerox> wolverian: did you see ABoP?
07:08:17 <xerox> Lindenmayer's book, that is. It suggests to do a turtle interpretation of the produced string, which works really well.
07:08:18 <wolverian> dcoutts, right.. but how do I signal that to the drawer, when all I'm outputting is a list of points? :)
07:08:30 <wolverian> xerox, ah, no.. I'll look into that.
07:08:49 <dcoutts> moveTo x0 y0 >> lineTo x1 y1 >> stroke
07:10:13 <wolverian> er, yes, but my flow looks like this: string -> type tree -> list of (x,y) tuples -> cairo drawer
07:10:21 <wolverian> the last phase is where I lose information
07:10:46 <dcoutts> wolverian, then pass [(Point, Point)] instead
07:11:06 <wolverian> oh, line segments? hm.
07:11:19 <dcoutts> well in your case they're whole lines
07:11:26 * xerox thinks the turtle interpretation is pretty nice again
07:11:27 <dcoutts> not just segments
07:11:27 <wolverian> moveTo fst, relLineTo snd?
07:11:59 <dcoutts> well if they're absolute coords then its moveTo fst >> lineTo snd
07:12:16 <wolverian> xerox, right.. I'm just trying to avoid mixing the evaluation with the drawing. I have a working turtle implementation
07:12:31 <wolverian> dcoutts, yeah, that sounds good. thanks!
07:14:51 <wolverian> it's a bit cleaner code, too.. no more StateT.. then again, I now have a function with five different cases and four arguments. that's a monster :-)
07:18:25 <edwardk_> StateT is your friend =)
07:18:38 * merus <3 StateT
07:20:31 <wolverian> yeah. the point was to not tie the evaluation with the drawing, so now I can make more drawing backends trivially.. I'll add state to the evaluator when I get completely disgusted by it
07:22:30 <edwardk_> figured out the rest of the trick to using comonads for substructural logic, er rather reintroducing traditional structural logic in a substructural type system. =) i kinda had to use a couple type classes in my intermediate language though. =/
07:23:04 <wolverian> scary adult talk..
07:23:28 <edwardk_> wolverian: ah i see that you have regressed to your logo years =)
07:23:46 <wolverian> hey, I never had those! I'm living my first logo childhood..
07:24:31 * edwardk_ hands wolverian a marker and a spirograph and watches him run the marker around the floor, obsessive-compulsively lifting the marker at regular intervals.
07:26:22 <edwardk_> but basically if my underlying type system is linear (or even ordered) i can use a comonad to reintroduce weakening or contraction.
07:26:37 <edwardk_> so if i make 2 type classes, one for weakening and one for contraction
07:27:00 <edwardk_> then i have 3 comonads, for the instances of either or both respectively.
07:27:29 <ski> hrm, how will just contraction yield a comonad ?
07:27:38 <edwardk_> and its easier to add behavior when i have the comonad as a marker than it would be to remove behavior when i have a monad marker.
07:28:57 <edwardk_> ski: well, like any useful monad you have an additional operation on the comonad for it.
07:29:25 <ski> but comonads 'w' should have an 'forall a. w a -> a' operation
07:29:58 <edwardk_> sure.
07:30:00 * merus finds Monads as Demon Exorcism a good monad-tutorial title.
07:30:05 <ski> (dual to 'return :: Monad m => a -> m a')
07:30:06 <edwardk_> think !a in linear logic
07:30:22 <edwardk_> with a !a i can extract a a whenever i want
07:30:25 <ski> so what would that operation be, with just contraction, and no weakening ?
07:30:28 <ski> yes
07:30:30 <ski> weakening
07:30:49 <edwardk_> yeah weakening works well. contraction i am still working on a little =)
07:31:02 <edwardk_> heh
07:31:10 <edwardk_> maybe i need to go back to the drawing board on that one
07:31:13 <ski> i'd be very surprised if you could make only contraction into a comonad
07:31:20 <edwardk_> probably right
07:31:31 <edwardk_> i had hope =)
07:31:48 <edwardk_> maybe a monad =)
07:32:10 <ski> (i doubt)
07:32:53 <greenrd> @seen shapr
07:32:54 <lambdabot> shapr is in #haskell and #ScannedInAvian. I last heard shapr speak 2 hours, 58 minutes and 30 seconds ago.
07:32:59 <edwardk_> hrmm
07:33:13 * ski catches-up with yesterday talk on comonads
07:33:24 * edwardk_ has been obsessing about trying to find a use for them
07:34:26 <Stinger_> jeez I just sorta figure out what monads are and you all have to start introducing more archaic mathematical structures :)
07:34:53 <ski> ;)
07:35:27 <edwardk_> ski can you see my /msgs? i am not running ident or whatever so some people were having trouble seeing them
07:35:55 <beschmi> @seen mnislaih
07:35:56 <lambdabot> mnislaih is in #haskell. I last heard mnislaih speak 19 minutes and 8 seconds ago.
07:36:05 <mnislaih> hi beschmi
07:36:25 <ski> edwardk_ : no .. mayhaps you are not identified to nickserv ?
07:36:25 <beschmi> hi, wich version do you use to bootstrap ghc.debugger
07:36:34 <edwardk_> will return in a sec.
07:36:43 <mnislaih> I anticipate you are having problems with the libraries.
07:36:47 <nomeata> for those who are interested: http://www.joachim-breitner.de/blog/archives/161-Brainfuck-interpreter-in-Haskell.html
07:37:14 <mnislaih> I am working in syncing the ghc.debugger repo with the main ghc repo. That will fix all the issues
07:37:20 <beschmi> mnislaih, 6.4.2 fails with "unknown package template-haskell"
07:37:54 <mnislaih> at stage2 right ?
07:38:02 <beschmi> mnislaih, newer ghcs fail with something like "No indices in Data.Array.ST"
07:38:23 <mnislaih> that's because of some changes in the base package at ghc-6.5
07:38:57 <mnislaih> I'm finding that I should have frozen all the repos for the libraries in my repo too, not only the main one
07:39:09 <beschmi> mnislaih: im not sure which stage it is. ghc-inplace compiling something in the compiler directory
07:39:49 <mnislaih> I will get back to you when I have synced the repo to the latest ghc-6.5 patches beschmi
07:39:59 <mnislaih> which will be later this evening
07:40:47 <beschmi> mnislaih: ok, just wanted to see if i'm doing something wrong
07:46:55 <Pupeno> [OT] what's the difference between a binary semaphore and a mutex ?
07:48:57 <roconnor> Isn't a mutex part of control flow, while a binary semaphore is a data structure?
07:50:43 <Pupeno> roconnor: in what way a mutex is not a data structure like a binary semaphore ?
07:52:49 <dcoutts> Pupeno, my impresiion was that they were pretty similar, not sure if there is a subtle difference however
07:53:33 <roconnor> Pupeno: anyone can raise or lower a semaphore, but you must enter and exit a mutex control block.
07:54:02 <roconnor> but I'm not a concurency expert.
07:54:15 <dcoutts> that's just when using a mutex to control a critical section
07:54:55 <roconnor> don't mutexs control critical sections?
07:55:07 <int-e> they can be used to lock resources, too
07:55:10 <Stinger_> its all the same thing :P
07:55:36 <roconnor> @wikipedia mutex
07:55:40 <lambdabot> No Result Found.
07:55:50 <norpan> mutex == semaphore
07:55:52 <roconnor> @wikipedia semaphore
07:55:55 <lambdabot> No Result Found.
07:55:59 <int-e> semaphores are counters that can be decreased and increased but never go below zero. mutexes are a sort of binary semaphore - it's always 0 or 1.
07:55:59 <Pupeno> According to someone on #lisp, the thread that acquired a mutex should be the same as the one to release it. That constraint is not needed in semaphores.
07:56:00 <Stinger_> that doesnt sound right
07:56:17 <roconnor> @wikipedia wikipedia
07:56:19 <lambdabot> No Result Found.
07:56:23 <int-e> err, that's not a defining constraint for a mutex either
07:56:38 <int-e> it might be a constraint of a mutex implementation
07:57:04 <mnislaih> beschmi: I have synced the repo to the main ghc trunk. Now it will build, if only with one or two minor issues
07:57:34 <mnislaih> these are due to current ghc-6.5 state. I can guide you, it's not very involved
07:57:50 <mnislaih> let me know if you want to try
07:57:56 <Pupeno> I need, for a program I am making, a semaphore in which I can change the number of resources arbitraly, so I thought about recording the original value and then a counting and allow acquires as long as the counting is below the original value. Am I missing some detail here that will ensure chaos and pain in the near future ?
07:58:48 <Pupeno> (maybe I should not allow releases below zero, but that's another issue).
07:58:54 <roconnor> I belive that using locks will  ensure chaos and pain in the near future.
07:59:20 <roconnor> I belive that programming with locks will  ensure chaos and pain in the near future.
08:00:01 <ulfdoz> .oO( That feature is guaranteed beyond present development )
08:04:35 <Pupeno> roconnor: I mean, any pain that is not caused with a standard semaphore.
08:04:52 <Pupeno> I will do a serious recomendation to switch to Erlang, but untill then we are stuck.
08:05:25 <roconnor> You don't need Erlang to implment message passing.
08:09:38 <Pupeno> roconnor: I know, but that's what I'd do because or problem is very Erlangish (that is, many of the things we need are provided by Erlang, OTP and maybe, Mnesia).
08:09:56 <roconnor> :)
08:10:03 * int-e thinks MVars are nice.
08:16:19 <int-e> @index forkIO
08:16:19 <lambdabot> Control.Concurrent
08:19:26 <lisppaste2> int-e pasted "semaphore from MVar" at http://paste.lisp.org/display/24294
08:28:17 <int-e> @index QSem
08:28:17 <lambdabot> Control.Concurrent.QSem, Control.Concurrent
09:02:57 <mnvl> i have a built haskell library at /usr/local/lib/lgal-1.0/libgal-1.0.a
09:03:58 <mnvl> i don't understand why ghc -lgal-1.0 main.hs isn't working
09:03:58 <mnvl> or what the correct linker option should be
09:04:47 <mnvl> sorry the filename is
09:05:02 <mnvl> /usr/local/lib/lgal-1.0/libHSgal-1.0
09:05:25 <Lemmih> mnvl: Tried 'ghc -package gal'?
09:06:45 <mnvl> yes thanks Lemmih tthat has compiled!
09:07:07 <mnvl> but can you explain why the C-style linker option doesn't work?
09:07:13 <mnvl> thnk you so much anyway
09:07:28 <mnvl> i have been trying to do this since yerterday
09:07:35 <dcoutts> mnvl, because /usr/local/lib/lgal-1.0/ is not on your linker path
09:07:59 <dcoutts> you linker path is probably only /usr/local/lib/ and /usr/lib/ and /lib/
09:08:07 <dcoutts> (and some secret gcc dirs too)
09:08:09 <mnvl> mnvl@sonja2:~/m$ cat /etc/ld.so.conf
09:08:15 <mnvl> /usr/X11R6/lib
09:08:15 <mnvl> /usr/local/lib
09:08:15 <mnvl> /usr/local/lib/gal-1.0/
09:08:17 <mnvl> i added it though
09:08:28 <mnvl> ?
09:09:00 <dcoutts> ok, then to make it work specify the correct library name, which is -lHSgal-1.0
09:09:21 <dcoutts> as you said, it's called /usr/local/lib/lgal-1.0/libHSgal-1.0.a
09:09:38 <dcoutts> and with -l you can leave off the lib prefix and .a suffix
09:09:51 <dcoutts> the remaining name beng HSgal-1.0
09:10:27 <dcoutts> but of course the right thing to do is not to modify your linker path but just use -package gal
09:10:36 <mnvl> still doesn't work
09:10:36 <mnvl> but i have successfully compiled so not to worry
09:10:38 <mnvl> thx for help everyoen
09:10:49 <mnvl> ok, i'll stick to that in future
09:10:49 <dcoutts> or if you compile with --make then you don't even need to specify the packages
09:11:01 <mnvl> it seems better that way anyway
09:11:05 <dcoutts> indeed
09:11:18 <dcoutts> especially when you've got dozens and dozens of libs
10:06:58 <george_> hi can anyone help me im very new to haskell and getting in a tangle with variable types, if someone could show me some example code to convert say a char to a single letter string this would really help me
10:07:34 <dmhouse> george_: do you know how Strings are represented in Haskell?
10:07:41 <Lemmih> > ['x']
10:07:46 <lambdabot>  "x"
10:07:51 <dmhouse> They're a list of Chars. I.e. String = [Char].
10:08:30 <dmhouse> And, as Lemmih shows, you can use the normal [] syntax to build any size lists, including lists with a single element.
10:09:44 <george_> wait
10:09:52 <george_> i will get the error message i repeatedly get
10:12:07 <george_> is there any recommended way of pasting? error is 4 lines long, i dont want to get a kick
10:12:18 <dmhouse> ?where paste
10:12:18 <lambdabot> http://paste.lisp.org/new/haskell
10:12:37 <mauke> or rafb.net/paste
10:14:37 <lisppaste2> george pasted "beginner haskell error" at http://paste.lisp.org/display/24300
10:15:01 <mauke> capStr [] = [] is wrong
10:15:20 <dmhouse> Wait, is it?
10:15:22 <mauke> or maybe your function type is wrong
10:15:28 <dmhouse> Surely this is a function to capitalise a String?
10:15:35 <dmhouse> In which case it takes Strings and returns Strings.
10:15:37 <edwardk> i think your type annotation is wrong
10:15:42 <dmhouse> So capStr :: String -> String
10:15:44 <edwardk> don't you want capStr :: String  -> String?
10:15:45 <edwardk> yeah
10:15:54 <mauke> @index toUpper
10:15:54 <lambdabot> Data.Char
10:16:05 <mauke> capStr = map Data.Char.toUpper
10:16:18 <george_> i think it was string -> string originally
10:16:34 <george_> and got an error there so i changed trying to follow some example in a book
10:16:40 <edwardk> > map toUpper "this is a test"
10:16:41 <lambdabot>  "THIS IS A TEST"
10:17:37 <edwardk> the nice thing about #haskell is you can post a snippet of code and invariably someone around here will turn it into a 1 liner ;)
10:17:49 <george_> yes, im not trying to do it in an efficient way, im just playing with the language to get used to it
10:17:53 <edwardk> yeah
10:17:57 <edwardk> understand completely
10:18:37 <int-e> many 1-liners teach useful things.
10:19:28 <edwardk> yeah, map is probably more central to the heart of the language than guards and multiple definition =/ kinda funny that way
10:20:17 <lisppaste2> george annotated #24300 with "same" at http://paste.lisp.org/display/24300#1
10:20:42 <edwardk> use : not ++
10:20:53 <edwardk> you are prepending a character onto a string
10:20:56 <dmhouse> > 'a' : "abcde"
10:20:57 <lambdabot>  "aabcde"
10:21:09 <dmhouse> > "abc" ++ "abcde"
10:21:10 <lambdabot>  "abcabcde"
10:21:23 <dmhouse> ++ joins Strings. : adds a Char to the front of a String.
10:21:28 <edwardk> @type (:)
10:21:29 <lambdabot> forall a. a -> [a] -> [a]
10:21:30 <george_> perfect =)
10:21:33 <edwardk> @type (++)
10:21:34 <george_> thanks guys
10:21:34 <lambdabot> forall a. [a] -> [a] -> [a]
10:21:42 <edwardk> np
10:22:12 <shapr> greenrd: Are you getting my private messages?
10:22:44 <mnislaih> dmhouse: the compile error you were finding yesterday with ghc.debugger: It is weird
10:23:25 <mnislaih> I have synced the repo with the main ghc-6.5 trunk earlier this afternoon, but it won't help with your issue
10:23:51 <mnislaih> what system are you using? Can it compile plain vanilla ghc-6.5?
10:24:35 <astrolabe> Was there a lookup function ::  a -> [(a,b)] -> b       ?
10:24:43 <dmhouse> ?hoogle lookup
10:24:44 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
10:24:44 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
10:24:44 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
10:25:07 <dmhouse> mnislaih: Linux, ix86. I certainly have compiled ghc-6.5 in the past.
10:25:11 <astrolabe> Ah thanks.  I can't believe it was called 'lookup'!  :)
10:26:30 <dmhouse> mnislaih: I'll have another go at compiling 6.5, see what happens.
10:26:46 <mnislaih> dmhouse: make a clean start with 'make distclean'
10:26:51 <xerox> Simon Peyton-Jones on shapr's unicycle: http://paolo.is-a-geek.com/mu/
10:26:58 <xerox> %-)
10:26:58 <mnislaih> also, make sure that you pull the latest patches from the ghc.debugger soc repo
10:27:34 <mnislaih> xerox: can't open the page :S
10:27:52 <mnislaih> does the dyn dns  point to 'goedel.local'  ?
10:27:57 <xerox> Argh.
10:28:09 <dmhouse> xerox: awesome :)
10:28:13 <edwardk> xerox: heh
10:28:13 <dmhouse> mnislaih: wfm.
10:28:15 <mnislaih> that's a Mac Os o.o
10:28:17 <xerox> Why dmhouse can?
10:28:29 <xerox> Hey edwardk :D
10:29:14 * xerox adds some more description
10:29:21 <mnislaih> xerox: wait a minute. Safari went to goedel.local but Firefox loads it ok
10:30:02 <shapr> xerox: Is it okay if I copy those pix to my hope instance?
10:30:30 <edwardk> so who are the other folks in the pic?
10:30:35 <edwardk> i kinda guess shapr
10:30:39 <shapr> Simon Marlow is holding the go board
10:30:51 <xerox> a sec
10:30:53 <shapr> Duncan Coutts aka dcoutts is on SPJ's left side.
10:31:03 <dcoutts> @yarr!
10:31:03 <lambdabot> Get out o' me way, yeh landlubber
10:31:09 <edwardk> thats who i was trying to figure out =)
10:31:14 <dcoutts> where?
10:31:24 <dcoutts> ah
10:31:42 <shapr> In the first picture, Dana N. Xu is wearing a backpack and standing to the left of Paul A Johnson, aka PaulAJ on #haskell
10:31:56 <xerox> Yea I am adding those names too :)
10:32:32 <shapr> In the background at the entrance of MSR There's Alexander Jacobson wearing a blue shirt and facing someone else...
10:32:40 <shapr> Behind dcoutts you can almost see Lemmih
10:32:46 <xerox> shapr: feel free to do it, it's fine. I *hope* you like them
10:33:04 <shapr> Oh, that's Igloo that's facing alexj
10:33:37 <xerox> I added names and links
10:33:48 <edwardk> heh
10:34:17 <shapr> In the second picture you can see Heffalump to the right of igloo & alexj, and genneth to the right of Heffalump.
10:36:33 <xerox> I added names and linksffalump
10:36:34 <dmhouse> xerox: make a second image with everyone captioned :)
10:36:36 <xerox> Ops
10:36:39 <xerox> Yes a second
10:37:36 <dmhouse> shapr: who's that on SPJ's right, our left?
10:38:01 <shapr> That's me
10:38:29 <dmhouse> Ah, right. You have a lambda T-shirt! :)
10:38:40 <shapr> from EuroHaskell 2004 even
10:38:45 <shapr> bringert's design
10:38:46 <xerox> OK, reload!
10:38:52 <shapr> @oldwiki EuroHaskell
10:38:52 <lambdabot> http://www.haskell.org/hawiki/EuroHaskell
10:39:10 <xerox> I don't know what to link for Paul Johnson and Gen Zhang.
10:39:45 <shapr> genneth: Do you have an url or blog?
10:39:50 <shapr> @seen PaulAJ
10:39:50 <lambdabot> I saw PaulAJ leaving #haskell 19 hours, 34 minutes and 17 seconds ago, and .
10:39:56 <shapr> He's here in the evenings.
10:40:01 <xerox> Okay!
10:40:53 <xerox> Added links for Go too :D
10:41:58 <shapr> xerox: Are you on planet haskell?
10:42:03 <xerox> Nope.
10:42:27 <xerox> I recently heard of it, what is its url?
10:42:32 <shapr> planet.haskell.org
10:42:46 <xerox> That was easy. Nice!
10:48:51 <xerox> shapr: and how does one get on there?
10:50:26 * xerox thinks
10:50:35 <xerox> I think I even have the video of SPJ unicycling....
10:50:55 <shapr> xerox: talk to ibid
10:50:59 <xerox> ....somewhere :)
10:51:16 <dmhouse> ?hoogle [a] -> [a] -> Bool
10:51:17 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
10:51:17 <lambdabot> List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
10:53:25 <shapr> mwc: Are you getting my privmsgs?
10:53:55 * shapr thinks not
10:54:01 * shapr sighs
10:54:33 <shapr> mwc: I see your messages
10:54:36 <xerox> (shapr: by the way, cabal-install ought to be able to suit your needs now.)
10:54:39 <shapr> yay!
10:55:21 <shapr> mwc: Nah, it's freenode
10:55:23 <xerox> SoC ends in very few days, and I'd like to outline what it is needed to be done for the purpose of the program, but I will _surely_ continue hacking afterwards.
10:55:30 <shapr> For some reason it's convinced I'm not a registered user.
10:55:38 <xerox> identify!
10:55:40 <mwc> yeah, as I said, be careful about being on it out of an environment like high school
10:55:41 <shapr> I did!
10:55:46 <xerox> So if you have any ideas, please shout to me!
10:55:52 <xerox> You and everybody else.
10:56:05 <shapr> ah, finally
10:56:07 <shapr> I think erc is broken.
10:56:23 <xerox> That's quite possible
10:57:14 <xerox> ibid: ping
10:59:01 * xerox wonders...
11:00:23 <astrolabe> xerox: What have you done?
11:01:18 <xerox> astrolabe: I've removed some complexity, now you can make a repository with the simple unix commands I list in the cabal-devel email, and use cabal-install with that.
11:01:34 <xerox> I.e. no code is needed to handle a repository, just a web server.
11:04:23 <shapr> yay
11:04:26 <shapr> xerox: sounds awesome!
11:04:31 <xerox> I am happy!
11:15:30 * edwardk notes that summer of code often seems like "the last week of summer of code" =)
11:16:10 <edwardk> half the people i know who are doing a SoC project are scrambling around at the end of it after goofing off all summer =)
11:16:22 <edwardk> no offense xerox =)
11:16:28 <dbremner> shapr - hello
11:21:03 <neologism> edwardk: :)
11:21:57 <mnislaih> edwardk: that's definitely not my case (:
11:27:42 <mld> hey,, is there no comp.lang.haskell or similar?
11:31:01 <eivuokko> I think there's no active newsgroup for haskell.  haskell-cafe mailing list is the nearest thing you get.  It's availabe in gmane.
11:31:05 <int-e> I guess the smartass answer is 'try news.gmane.org'
11:33:28 <mld> ok thanks
11:33:45 <int-e> (gmane is a mail-to-news gateway)
11:35:01 <ookk> can you use guards with lambda functions?
11:35:15 <basti_> you can't match against functions no
11:35:19 <basti_> if that is what you wanted to know
11:35:20 <int-e> no (why would you?)
11:35:26 <ookk> no
11:35:33 <ookk> i mean a lambda function with guards in it
11:35:36 <int-e> \x | x== 2 -> 4  doesn't make sense to me?
11:35:36 <basti_> ah
11:35:40 <ookk> i want to make a one liner
11:36:12 <Igloo> You can't, no
11:36:29 <int-e> > (\2 -> 3) 3 -- hmm.
11:36:30 <lambdabot>  Non-exhaustive patterns in lambda
11:36:33 <ookk> \x | Nothing -> Infinity | x -> Finite x
11:36:38 <ookk> something like that
11:36:50 <int-e> oh, you want a builtin case. no, that doesn't exist
11:36:56 <ookk> so i have to define another function in a where statement?
11:37:08 <ookk> that has the guards i want
11:37:14 <Igloo> Or \x -> case x of ...
11:37:25 <int-e> > (\x -> case x of Nothing -> 0; Just x -> x) (Just 42)
11:37:27 <lambdabot>  42
11:37:34 <jgrimes_> Anyone checked out HaskellNet?
11:37:41 <int-e> @type maybe
11:37:42 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
11:37:52 <int-e> > maybe 0 id (Just 42)
11:37:53 <lambdabot>  42
11:37:57 <ookk> ill try that
11:38:00 <int-e> > fromMaybe 0 (Just 42)
11:38:00 <lambdabot>  42
11:38:09 <ookk> thx
11:38:44 <int-e> Hmm. maybe is Maybe's version of fold. Sort of. :)
11:41:26 <ookk> what does the => mean when you declare a function type?
11:41:59 <edwardk> @tell ski the co-applicative stuff can't work if we follow your derivation from coexponentials. in order to have both exponents and coexponents we need a bi-[cartesian closed] category. all bi-[cartesian closed] categories are degenerate. http://citeseer.ist.psu.edu/crolard99subtractive.html
11:41:59 <lambdabot> Consider it noted.
11:43:00 <int-e> they are class constraints. (Num a, Ord b) => a -> b -> Bool  means a is a type that implements the Num class (you can add it, and so on), b implements the Ord class (you can compare it)
11:43:22 <int-e> @type (+)
11:43:24 <lambdabot> forall a. (Num a) => a -> a -> a
11:43:24 <edwardk> heh, that also might explain the general shortage of comonads.
11:43:59 * edwardk is afk
12:00:02 <george_> does haskell have an intrinsic square root function?
12:00:16 <xerox> intrinsic?
12:00:20 <SamB> sqrt?
12:00:27 <SamB> xerox: I think he means "in the Prelude"
12:00:34 <edwardk> @type sqrt
12:00:36 <lambdabot> forall a. (Floating a) => a -> a
12:00:50 <SamB> @doc Text.PrettyPrint.HughesPJ
12:00:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-PrettyPrint-HughesPJ.html
12:01:07 <edwardk> @index sqrt
12:01:08 <lambdabot> Prelude
12:24:20 <george_> does haskell have a printf equivalent?
12:24:47 <Itkovian> george_: Text.Printf iirc
12:25:22 <george_> is this the best way to output some variable?
12:27:16 <SamB> george_: depends
12:27:48 <george_> ok, say im doing some basic program that calculates factors of a values
12:27:48 <SamB> putStrLn and show often help
12:27:53 <SamB> (also print)
12:28:27 <SamB> probably print would be enough, if you really need to do IO
12:29:03 <SamB> printf is for when the Show instances don't do what you want, pretty much
12:29:20 <george_> so as it iterates through the different possibilities and checks if they are factors i want it to print them as an: if (x * y ==  someVal) then (print x y) else do something
12:29:21 <george_> ?
12:29:27 <SamB> and it annoyingly only works on a few types, so no using it on Word8s or anything like that
12:29:56 <SamB> george_: you should probably just write your program to return a list
12:30:08 <SamB> lists are printed lazilly, like so:
12:30:20 <SamB> > [1,2,3,10,error "Hand grenade!"]
12:30:22 <lambdabot>  Exception: Hand grenade!
12:30:27 <SamB> hmm...
12:30:35 <SamB> something is wrong
12:30:40 * SamB suspects dons
12:30:59 <SamB> maybe...
12:31:13 <SamB> > [1...1000]++error "hand grenade!"
12:31:14 <lambdabot>  Not in scope: `...'
12:31:18 <SamB> > [1..1000]++error "hand grenade!"
12:31:19 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
12:31:42 <george_> sorry, why are you putting in errors?
12:31:45 <SamB> still not very useful...
12:32:00 <SamB> well...
12:32:53 <SamB> I was trying to show that "show" on lists is lazy, that is, it formats as it goes along
12:35:01 <SamB> so you could just write your code to compute a list of factors
13:15:09 <dmhouse> > Nothing `mplus` Just 4
13:15:10 <lambdabot>  Just 4
13:17:21 <newsham> nothing comes of nothing
14:09:36 <eivuokko> Hmmm.  I've sent a patch to cabal-devel a while back, but it's not applied and nobody argumented against it. :-(
14:11:20 <Igloo> dcoutts might a good person to prod there
14:19:39 <ivant> @hoogle castPtr
14:20:13 <lambdabot> Foreign.Ptr.castPtr :: Ptr a -> Ptr b
14:20:15 <lambdabot> Foreign.Ptr.castPtrToFunPtr :: Ptr a -> FunPtr b
14:20:17 <lambdabot> Foreign.StablePtr.castPtrToStablePtr :: Ptr () -> StablePtr a
14:25:27 <dcoutts> eivuokko, which one was that?
14:30:59 <eivuokko> dcoutts, I tried to send you (and SyntaxNinja) a mail, but apparently your address won't accept mail from ei-vuokko-info because I am using pretty protected smtp-server that (arguably incorrectly) doesn't accept some bounces.
14:31:27 <dcoutts> eivuokko, try sending to the cabal-devel list
14:31:53 <eivuokko> http://www.haskell.org/pipermail/cabal-devel/2006-May/000006.html <- thatäs the old mail with the patch
14:31:55 <lambdabot> Title: [patch] Workaround for ar and ld for Windows cmdline length restriction
14:33:21 <dcoutts> eivuokko, ah yes ok
14:34:22 <eivuokko> dcoutts, I'd like feedback if there is something wrong, be it in patch, my mail, language etc..
14:34:41 <dcoutts> eivuokko, no, it just dropped off our attention list :-)
14:35:14 <dcoutts> eivuokko, any chance of doing it based on how many fit in 32k rather than using chunks of 100
14:35:26 <dcoutts> eivuokko, actually that does make a differnce
14:35:35 <dcoutts> ar is O(n^2) in number of invocations
14:35:40 <dcoutts> when doing it in chunks
14:35:46 <dcoutts> so fewer larger chunks is better
14:35:54 <eivuokko> In my tests, not really.
14:36:06 <dcoutts> have you tried base? :-:
14:36:11 <dcoutts> ar take >500Mb
14:36:26 <eivuokko> No, I tried with my dx bindings
14:36:34 <dcoutts> and needs more than 5 invocations of several hundred .o files each
14:36:38 <xerox> 47 97 95 98 96 94 99 ...
14:36:52 <dcoutts> and takes quite a while
14:37:25 <dcoutts> I submitted a patch to binutils to make it take 'only' 100Mb memory to link HSbase.a
14:37:31 <dcoutts> rather than >500Mb
14:37:43 <xerox> http://hackage.haskell.org/trac/summer-of-code/query?status=new&status=assigned&status=reopened&group=topic&type=proposed-project&order=priority
14:37:43 <SamB> cool
14:37:46 <lambdabot> Title: Custom Query - Haskell.org Google Summer of Code - Trac
14:37:46 <xerox> ^- this is crazy
14:37:52 <xerox> They didn't only spam
14:38:01 <xerox> They have even added proper categories for their spam?
14:38:19 <xerox> So we have Online Casino SoC project proposals, and Online Gambling SoC project proposals.
14:39:16 <eivuokko> dcoutts, Meh, I'll get to it somepoint again, then.  It's just very annoying to do it by 32k as it's hard to guess correct number without being sure how the underlying commands are invoked.  I can't know how long the filenames are because of unicode issues, so it'd still need to use heuristics to cut it in somewhere under 32k.
14:39:42 <dcoutts> ah, hmm yes, unicode
14:39:46 <eivuokko> (And using 8.3 names isn't possible because it's not an requirement for OS to work.)
14:39:59 <eivuokko> (I have machines where 8.3 names are disabled)
14:40:27 <SamB> so how about 8k?
14:40:36 <eivuokko> dcoutts, Also, the algorithm to find optimal number of ar calls is also quite complicated.
14:41:13 <SamB> hey, isn't there a way to stick all that stuff in a file instead of passing it on the commandline?
14:41:20 <dcoutts> nope
14:41:24 <eivuokko> Not in binutils that come with 6.4
14:41:27 <SamB> patch it!
14:41:31 <eivuokko> dcoutts, Yes, but only in new binutils
14:41:38 <eivuokko> SamB, I can't patch all the existing installations
14:41:48 <SamB> yeah
14:42:36 <dcoutts> eivuokko, is this only in the windows code path? or unix too?
14:42:43 <eivuokko> dcoutts, Windows only.
14:42:45 <dcoutts> I think it should be in both
14:42:51 <SamB> the file thing?
14:42:58 <dcoutts> many unix shells have the same restriction
14:43:06 <dcoutts> 32k is about right
14:43:25 <eivuokko> Really?  I can't say how many times I've heard this 32k argument used against Windows as devel machine...
14:43:34 <dcoutts> heh
14:43:56 <dcoutts> well I'm not sure what the limit is, but there is one
14:43:59 <eivuokko> I should know better than to listen OS advocats.
14:43:59 <sieni> windows is a bad devel machine, since windows sucks
14:44:13 <eivuokko> Is there /silence in freenode?
14:44:33 <dcoutts> and I know linking libHSbase.a on linux uses xargs and takes at least 5 invocations of ar
14:44:35 <sieni> i speak from experience
14:44:39 <SamB> what does 32k have to do with devel?
14:44:47 <SamB> it seems to me it has to do with BUILDING
14:44:47 <dcoutts> large builds
14:44:59 <SamB> which is not the same as devel
14:45:01 <dcoutts> the two are related :-)
14:45:06 <eivuokko> SamB, most people don't run into that limitation without doing big builds.
14:45:06 <SamB> yes
14:45:14 <eivuokko> Infact, I know none.
14:45:18 <dcoutts> I do devel and builds on the same machine, as do most people
14:45:20 <SamB> but you could be building on windows and doing the actual hacking on Linux
14:45:41 <SamB> you'd probably be building on Linux mostly, but still might test on windows once in a while
14:46:33 <ivant> eivuokko: they usually run into it when they do "grep ... `find ...`"
14:47:02 <dcoutts> eivuokko, does ghc not help at all these days with -split-objs ?
14:47:08 <dcoutts> I thought it did
14:47:32 <dcoutts> or do we still need to find them all manually and ar them all?
14:48:04 <eivuokko> dcoutts, Ok, so patch is bad.  But it's unclear what needs to be done.
14:48:21 <eivuokko> dcoutts, Huh?
14:48:28 <dcoutts> eivuokko, no, patch is a good step, but I think it should go further :-)
14:48:32 <eivuokko> dcoutts, split-objs is why I wrote the patch.
14:48:37 <dcoutts> yes yes
14:48:54 <eivuokko> Because my dx+self built Win32 30-line demo was almost 3 megs!
14:48:56 <dcoutts> but I recall that ghc gave us a bit more help with using -split-objs than it used to
14:49:05 <eivuokko> I have no idea
14:49:08 <dcoutts> ok
14:49:16 <eivuokko> I never used it before I saw there was a patch in ghc/cabal that enabled it somewhat
14:49:55 <eivuokko> And I still haven't used split-objs outside cabal.
14:50:05 <dcoutts> yeah, it's generally a pain
14:50:15 <dcoutts> I added support for it in gtk2hs
14:50:29 <eivuokko> Yeah, I've seen you talk about that.
14:50:52 <SamB> ar ought to use data structures
14:51:11 <eivuokko> gnu binutils ought to be rewritten with sanity in mind.
14:51:15 <SamB> yes!
14:51:18 <SamB> exactly
14:51:19 <SamB> and GHC
14:51:20 <SamB> too
14:51:39 <SamB> preferably at the same time
14:51:42 <eivuokko> They are almost insane to hack, I've tried few times to find out exactly how they work, because there's so bad specs about fileformats.
14:52:14 <dmhouse> Yay! I've built a working typechecker for the simply typed lambda calculus with records and subtyping :)
14:52:21 <eivuokko> :)
14:52:37 <dmhouse> Now to add conditionals and a minimal type.
14:53:26 <eivuokko> dcoutts, Let me recap: The patch needs to run in unixy platforms as well?   The current algorithm isn't sufficient?  (Care to outline some other algo?)
14:55:40 <dcoutts> eivuokko, well if you're desperate then we can apply it anyway, but I think it'd be nice to make it better.
14:55:56 <dcoutts> ghc currently uses xargs
14:56:08 <dcoutts> when linking HSbase and others
14:56:45 <dcoutts> maybe the best way to do this is to write an xargs-style function
14:56:55 <dcoutts> and use it for all 4 cases
14:56:59 <dmhouse> ?hoogle intersect
14:57:00 <lambdabot> List.intersect :: Eq a => [a] -> [a] -> [a]
14:57:00 <lambdabot> Data.Set.intersect :: Ord a => Set a -> Set a -> Set a
14:57:00 <lambdabot> List.intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
14:57:01 <eivuokko> dcoutts, I am not desperate, I just don't feel like hacking on it anymore.  I was just shocked when my stuff wasn't in when I read the Cabal source today.
14:57:04 <dcoutts> ld & ar on wndows and posix
14:57:12 <dcoutts> eivuokko, right, ok
14:57:17 <eivuokko> Eh
14:57:28 <dcoutts> eivuokko, we just forgot, that's all.
14:57:46 <eivuokko> Yeah, sire.
14:57:48 <eivuokko> *sure
14:58:22 <xerox> Yessir!
14:58:25 <eivuokko> I was fairly happy that someone (ndm) showed interest in Cabal-hacking in Windows... :-)
14:58:41 <eivuokko> So I started looking over the source for the stuff I've needed.
14:59:01 <dcoutts> great
15:00:45 <eivuokko> The problem with xargs-style is that (iirc) the complexit how you call the tools is diffrent
15:01:14 <eivuokko> So the function would force one way to do it, only.
15:01:54 * SamB yawns after hour-and-a-half wesnoth game
15:02:08 <eivuokko> What's that?
15:02:26 <SamB> its when you play Battle for Wesnoth for an hour and a half?
15:02:30 <SamB> in this case, online
15:02:58 <eivuokko> Ok.  No idea what it is.  I'll google for it later.
15:03:09 <dmhouse> Is intersect O(n*m)?
15:03:34 <SamB> Its a cool strategy game
15:03:46 <xerox> Andrew Bromage : "What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure th ese days"
15:03:53 <xerox> Yarrr, I have this feeling too :)
15:04:10 <SamB> mill-olegs?
15:04:13 <SamB> milli-grams!
15:04:25 <SamB> er
15:04:29 <SamB> s/mill/milli/
15:04:32 <eivuokko> dmhouse, The worst case, yes, I think so.
15:04:42 * dmhouse thinks SamB missed the joke with that one ;)
15:04:50 <SamB> no I didn't
15:04:52 <dmhouse> eivuokko: thanks.
15:05:05 <SamB> I'm just saying that if milligrams are small why wouldn't milli-olegs?
15:05:26 <SamB> er, um, *be*.
15:05:41 <semi_> with unsorted data O(n*m)
15:06:07 <semi_> sorted data would give O(n+m) I think?
15:06:11 <ivant> and something like O(n+m) for sorted
15:06:39 <eivuokko> @type Data.List.intersect
15:06:40 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
15:07:01 <ivant> yep, it is O(n+m)
15:07:32 <eivuokko> It can't be with Eq
15:08:12 <ivant> if it is sorted, then we have (Ord a) already :-)
15:08:12 <dmhouse> Okay, here's basically what I need to achieve:
15:08:56 <norpan> if sorted is O(n+m) then you can get O(nlog n + mlog m) by sorting
15:09:06 <norpan> which is clearly better than O(n*m)
15:09:26 <eivuokko> norpan, Except that it's then strict.
15:09:33 <ivant> sure, but that has space overhead
15:09:46 <norpan> not if you use a lazy sort like merge sort
15:11:00 <semi_> if a hashtable could be used, it would be O(n+m) even for unsorted, but I don't know squat about haskell
15:11:01 <dcoutts> eivuokko, ah, on most unixs it's 2^17 bytes rather than 2^32
15:11:04 <dcoutts> but it's still a problem
15:11:11 <dcoutts> err
15:11:16 <dcoutts> > 2^15
15:11:16 <lambdabot>  32768
15:12:54 <eivuokko> Ok, sort doesn't need to be totally strict in all cases, but surely it might need to be strict in all cases, just because the last element in source might need to be first?
15:13:03 <eivuokko> *in some cases
15:13:07 <eivuokko> Yawn
15:13:11 <norpan> but how is intersect without sort less strict
15:13:22 <eivuokko> norpan, it is strict on only one argument.
15:13:54 <norpan> so, sort one of the arguments, that should be sufficient to get O(n+mlog m)
15:14:04 <eivuokko> Hmh.
15:14:25 <norpan> with binary search of course
15:14:32 <norpan> but not given the current impl
15:14:44 <eivuokko> Yes, that seems correct to me.
15:14:48 <norpan> but anyway
15:15:01 <norpan> it's time to sleep
15:19:58 <Pupeno__> well, yes... locking was painful... I didn't know how much paniful it was untill now.
15:32:06 <newsham> is it possible to do somethint statefully with haxml?  like, say, use a random number generator?
15:32:30 <newsham> seems like all the filters want to be stateless
15:33:31 <ivant> newsham: you can prepare your random numbers before doing anything in haxml
15:34:13 <newsham> right, but how do I pass them in to the filters?
15:34:16 <ivant> the only thing which involves side effects is getting the random seed
15:34:48 <ivant> you can pass the random seed as a parameter
15:34:54 <ivant> or do I miss some point here?
15:34:55 <newsham> for the sake of argument, lets say you want a filter that looks for tag "dice" and generates <tr>number</tr>  for number from 1 to 6, for example
15:35:14 <newsham> and I dont know how many <dice> tags there are.
15:35:36 <dmhouse> Hrm. Anyone happen to know whether an algorithm for finding the join of two functional types? Is it take the meet of their domain as the domain and the join of their range as the range?
15:35:37 <newsham> so I want something like     makeNum `o` deep (tag "dice")  right?
15:35:59 <newsham> but makeNum will need access to the sequence of randoms in addition to the tag
15:36:15 <newsham> the makeNum sig has to be   Content -> [Content]
15:36:29 <ivant> Oh, I think I understand now
15:36:32 <ivant> hmm
15:36:37 <xerox> Anybody with an acm subscription?  <http://portal.acm.org/citation.cfm?doid=505168.505175>
15:36:48 <dmhouse> (Join = least common supertype, meet = greatest common subtype)
15:37:25 <newsham> although maybe a LabelFilter can be used somehow
15:37:48 <ivant> xerox: I can try to get it but it may take a couple of days (and the success is not guaranteed)
15:37:54 <newsham> but even with a LabelFilter..  it would have to be a function that gives different results each time even though the args are the same
15:37:56 <newsham> (ie. stateful)
15:38:09 <xerox> ivant: i see, thanks
15:38:21 <ivant> xerox: should I do it?
15:38:36 <xerox> ivant: if you have time :)
15:39:25 <ivant> xerox: I have a whole life :-)
15:39:35 <ivant> .. of time
15:42:51 <newsham> ivant: so no ideas for haxml?
15:44:21 <ivant> newsham: wait a minute, I'll switch my brain to another mode
15:45:41 <ivant> xerox: requested the article, hopefully I'll get it soon
15:46:31 <newsham> *sits on hands patiently*
15:47:06 * ivant browsing through haxml api
15:47:32 <newsham> hagb: telnet to this irc server and irc manually without a client.. good way to get used to the interface
15:47:41 <newsham> [misfire]
15:48:52 <ivant> ? oo
15:52:17 <int-e> ∞?
15:52:40 <ivant> newsham: I don't have a good understanding of how haxml actually works (though I tried to use it once), but how about this solution:
15:52:41 <SamB> to ∞ and beyond!
15:53:48 <SamB> hmm, remind me never to convert pango into a typesetter
15:54:07 <newsham> icfp99 paper on http://www.cs.york.ac.uk/fp/HaXml/ looks like the best documentation
15:54:08 <lambdabot> Title: HaXml: Haskell and XML
15:54:40 * ivant generating haskell code
15:54:53 <ivant> @hoogle: zipWith
15:54:54 <lambdabot> Maybe you meant: hoogle hoogle+
15:55:00 <ivant> @hoogle zipWith
15:55:00 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
15:55:01 <lambdabot> List.zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
15:55:01 <lambdabot> List.zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]
15:55:23 <int-e> interesting order :)
15:55:25 <ivant> @hoogle zipWith ($)
15:55:26 <lambdabot> Hoogle Error: Parse Error: Unexpected character '$)'
15:55:27 <int-e> @index zipWith3
15:55:27 <lambdabot> Data.List, Prelude
15:55:33 <newsham> *sigh*  read what I said, read rfc, read sample code I gave url to, etc...
15:55:38 <newsham> oops, wrong channel.. *sigh*
15:56:03 * int-e comforts newsham 
15:56:03 <SamB> @hoogle+ SamB :: Food -> Stupid
15:56:05 <ivant> @type zipWith ($)
15:56:07 <lambdabot> forall b b1. [b1 -> b] -> [b1] -> [b]
15:56:18 <xerox> SamB: hahaha it's not for adding things :P
15:56:39 <xerox> @hoogle a -> b -> c
15:56:41 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
15:56:41 <lambdabot> Prelude.curry :: ((a, b) -> c) -> a -> b -> c
15:56:41 <lambdabot> Data.Graph.Inductive.Monad.ufoldM :: GraphM m gr => (Context a b -> c -> c) -> c -> m (gr a b) -> m c
15:56:43 <xerox> @hoogle+
15:56:44 <lambdabot> Data.FiniteMap.lookupWithDefaultFM :: Ord key => FiniteMap key elt -> elt -> key -> elt
15:56:44 <lambdabot> Data.Map.findWithDefault :: Ord k => a -> k -> Map k a -> a
15:56:44 <lambdabot> Prelude.const :: a -> b -> a
15:56:47 <xerox> & co.
15:56:49 <SamB> ah
15:56:50 <lambdabot> SamB: You have 1 new message. '/msg lambdabot @messages' to read it.
15:57:44 <ivant> newsham: zipWith ($) (labelFilters) (deep (tag "dice"))
15:58:46 <ivant> where labelFilters :: [Random a] -> [LabelFilter a]
15:59:09 <ivant> not sure about labelFilters but you get the idea
15:59:38 <ivant> oh, small fix: concat $ zipWith ($) ......
16:00:18 <newsham> hmmm
16:00:38 <zarvok> So I'm trying to install the latest version of Cabal out of the repository
16:00:44 <zarvok> And it chugs along fine for a while
16:00:46 <zarvok> and then I get:
16:00:51 <zarvok> Linking ...
16:00:51 <zarvok> Configuring cabal-setup-1.1.4...
16:00:51 <zarvok> setup: cannot satisfy dependency Cabal>=1.1.4
16:00:51 <zarvok> make: *** [build-stamp] Error 1
16:01:11 <zarvok> Now, I know pretty much nothing about cabal
16:01:26 <zarvok> but it seems strange to me that it's a dependency in its own installer
16:01:29 <ivant> labelFilters :: Random a => [a] -> [LabelFilter a], of course
16:01:30 <dcoutts> eivuokko, I've written an xargs function
16:01:44 <zarvok> anyone have any advice?
16:02:29 <eivuokko> dcoutts, Sure.
16:02:47 <eivuokko> dcoutts, So have I - my ar calling in the old patch is basically xargs.
16:03:03 <eivuokko> But the way I call ld really isn't.
16:03:09 <dcoutts> ah, so we're duplicating ;-)
16:03:11 <ivant> newsham, does this seem to work for you or is it a mess?
16:03:12 <dcoutts> well it could be...
16:03:19 <eivuokko> dcoutts, If you want to fix it, by all means!
16:03:33 <dcoutts> feel free to paste your code somewhere
16:03:36 <dcoutts> I'll merge them
16:03:40 <eivuokko> dcoutts, I can hack other things...like fixing this annoying MAPI bug, and maybe look into few GHC lib probs..
16:03:51 <dcoutts> ok
16:04:00 <eivuokko> dcoutts, My patch is on that old mail...I don't have the patch elsewhere
16:04:16 <dcoutts> oh ok, sorry I thought you meant you had something new
16:04:25 <dcoutts> I've got your previous patch
16:04:46 <newsham> ivant: i'm still digesting.. thanks for your suggestion.
16:04:50 <newsham> i suspect it would work.
16:04:51 <eivuokko> Well, anyway, big deal, it's like 10 lines or something.
16:04:59 <ivant> newsham, oh I messed with random
16:05:37 <eivuokko> dcoutts, I can say I am not hacking that thing before I get some feedback on the list, or few days pass.
16:05:50 <dcoutts> right'o
16:05:59 <ivant> newsham: labelFilters should simply map random numbers list to a list of LabelFilters which attach these labels to the nodes
16:06:20 <eivuokko> Unfortunately Jaffacake is on holiday (I think), he might have ideas.
16:06:20 <dcoutts> eivuokko, I'll give it a go based on your patch, if you can test what I do on win32 that'd be great.
16:06:53 <eivuokko> dcoutts, If I can do testing with my own projects, sure.
16:06:58 <dcoutts> ta
16:07:26 <dcoutts> I'm doing the xargs by counting chars and making a chunk of chars less than a configurable limit
16:07:27 <dcoutts> eg 32k
16:07:41 <eivuokko> dcoutts, In general, if I can help with Windows-issues, I'd be glad to as long as they don't take half a day.
16:07:48 <dcoutts> right
16:07:52 <dcoutts> thanks
16:09:54 <newsham> ivant: *nod*
16:11:53 <ivant> xerox: http://www.comp.mq.edu.au/~mike/papers/47.ps.gz
16:19:23 <ivant> @tell xerox "On category theory as a (meta) ontology for information systems research" <http://www.comp.mq.edu.au/~mike/papers/47.ps.gz>
16:19:24 <lambdabot> Consider it noted.
16:23:16 * ivant is admired by lambdabot
16:24:08 * ivant screwed up with English language, lambdabot is admired by me
16:28:50 <wolverian> does @pl not support record field update syntax?
16:32:52 <ivant> @where throwErrnoIf
16:32:52 <lambdabot> I know nothing about throwerrnoif.
16:32:53 <wolverian> also, if there's gets, why no modifys? :)
16:33:29 <ivant> @kind throwErrnoIf
16:33:30 <lambdabot> Not in scope: type variable `throwErrnoIf'
16:33:34 <ivant> @type throwErrnoIf
16:33:36 <lambdabot> Not in scope: `throwErrnoIf'
16:34:51 <newsham> hmm.. the haxml example from the paper donut work
16:41:27 <ivant> @type peek
16:41:29 <lambdabot> Not in scope: `peek'
16:41:33 <ivant> shoot
16:42:53 * heatsink likes how ffi uses BASIC syntax for pointer reads and writes :)
16:43:04 <heatsink> err... basic names.
16:43:19 <newsham> would you prefer "derefForReading" and "derefForWriting"?
16:43:35 <heatsink> no, I prefer peek and poke.
16:45:07 <heatsink> It's accurate.  It also sounds more like an obsolete feature than "pointer" names would.
16:45:08 <newsham> nufekop
16:45:17 <heatsink> what?
16:45:38 <newsham> old game company, "pokefun" backwards
16:45:56 <heatsink> hm.
16:46:00 <ivant> yeah, when I was ~12 years old I had a lot of fun trying to understand what "peek" and "poke" are needed for
16:46:50 <newsham> poke 53281,0
16:48:38 <Pseudonym> I like the Lisp names better.
16:48:39 <ivant> ah, ok, I had a 80286, not a C64
16:48:47 <Pseudonym> CAR and CDR are even more obsolete than peek and poke.
16:48:58 <heatsink> Pseudonym, and backwards too :)
16:49:31 <Pseudonym> Sorry, how are they backwards?
16:50:07 <heatsink> If you have a list of numbers, the data is in car and the address of the next cons-cell is in cdr
16:50:08 <newsham> any ideas on this compiler error?  http://www.thenewsh.com/%7Enewsham/x/hax/
16:50:12 <lambdabot> Title: Directory /~newsham/x/hax/
16:50:24 <newsham> i'm probably not linking something in..
16:50:26 <Pseudonym> Err... oh, I see.
16:50:43 <Pseudonym> @foldoc cdr
16:50:43 <lambdabot> Error: connect: does not exist (Connection refused)
16:50:50 <Pseudonym> Ooh.
16:51:16 <heatsink> newsham: Usually ghc --make figures out the correct packages to link with.
16:51:41 <newsham> ahh, thats it.. my apologies.. i've been away from ghc for a few months
16:52:11 <Pseudonym> Time to get your fix.
16:52:40 <newsham> indeed.
16:53:02 <heatsink> oh, "decrement".
16:53:05 <newsham> time to remember all the reasons why i hate the separation of state and functional code :)
17:01:37 <ivant> @hoogle CInt -> CUInt
17:01:38 <lambdabot> No matches, try a more general search
17:01:55 <ivant> @hoogle Integral a => a -> CUInt
17:01:56 <lambdabot> No matches, try a more general search
17:02:05 <ivant> bummer
17:02:49 <ivant> how do I cast from CInt to CUInt?
17:03:14 <heatsink> I think fromIntegral would do it
17:03:39 <ivant> @type fromIntegral
17:03:40 <lambdabot> forall b a. (Num b, Integral a) => a -> b
17:03:58 <ivant> @kind CUInt
17:04:00 <lambdabot> Not in scope: type constructor or class `CUInt'
17:05:21 <ivant> thanks, it works
17:14:55 <ivant> how can I say Cabal that it should link my sources with a specific library?
17:15:03 <ivant> s/say/instruct/
17:17:04 <eivuokko> With field extra-libraries, I think.
17:17:08 <int-e> I think yes, using the extra-libraries: and extra-lib-dirs: (if needed) fields.
17:17:09 <int-e> :)
17:17:10 <ivant> eivuokko, thanks
17:17:17 <ivant> I just found it :-)
17:18:17 <eivuokko> If you need extra-lib-dirs, you might want to write out a buildinfo-file in Setup.hs, during the configure-step.
17:18:42 * ivant have just built successfully the Samba client library bindings! Yay!
17:18:51 <eivuokko> :)
17:19:16 <ivant> now I need to make it work :-)
17:20:39 <ivant> Foreign Function Interface is fun. It is like learning a foreign language looking at the sources :-)
17:22:27 <eivuokko> Heh.  I love Haskell's ffi.  FFI and Foreign got, imo, very good balance for most stuff.
17:23:45 <ivant> I'm still not sure if the marshalling code from directory entry structure would work
17:24:14 <ivant> I read lots of ghc library sources to understand how to do it :-)
17:30:37 <dcoutts> @hoogle ExitStatus
17:30:37 <lambdabot> No matches found
17:30:42 <dcoutts> @hoogle ExitSucess
17:30:42 <lambdabot> No matches found
17:31:00 <dcoutts> @hoogle ExitSuccess
17:31:00 <lambdabot> System.Exit.ExitSuccess :: ExitCode
17:34:31 <ivant> @index bracket
17:34:31 <lambdabot> Control.Exception, Distribution.Compat.Exception, Graphics.HGL.Draw.Monad, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL
17:36:08 <ivant> @type bracket
17:36:09 <lambdabot> Not in scope: `bracket'
17:36:24 <ivant> @hoogle bracket
17:36:25 <lambdabot> IO.bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
17:36:25 <lambdabot> IO.bracket_ :: IO a -> (a -> IO b) -> IO c -> IO c
17:36:25 <lambdabot> Control.Exception.bracket_ :: IO a -> IO b -> IO c -> IO c
17:40:02 <dons> ?where cpphs
17:40:02 <lambdabot> http://www.cs.york.ac.uk/fp/cpphs/
17:41:40 <dons> ?where haskell-exts
17:41:40 <lambdabot> I know nothing about haskell-exts.
17:41:44 <dons> ?where haskellexts
17:41:44 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/HaskellExtensions
17:43:23 <dons> ?users
17:43:28 <lambdabot> Maximum users seen in #haskell: 235, currently: 191
17:43:32 <dons> ?uptime
17:43:32 <lambdabot> uptime: 3 days, 22 hours, 35 minutes and 20 seconds
17:47:12 <dons> ?remember lennart Even though I'm largely responsible for making CPP available in a Haskell compiler I think it's an abomination.  It should be avoided
17:47:12 <lambdabot> Done.
17:49:31 <eivuokko> Heh.
17:51:47 <dcoutts> nice
17:52:00 <dcoutts> and yes, it is an abomination
17:52:54 <Pseudonym> The world needs a syntax-based macro system that actually works in a system with a syntax that's more complex than Lisp.
17:53:03 <Pseudonym> Some research required.
17:53:20 <xerox> Hiya Pseudonym
17:53:20 <lambdabot> xerox: You have 1 new message. '/msg lambdabot @messages' to read it.
17:53:30 <Pseudonym> G'day xerox.
17:53:35 <xerox> Thanks ivant :D
17:53:36 <dcoutts> as ndm often points out, it gets used for static platform difference where it'd be perfectly easy to do that dynamically using System.Info.os
17:53:37 <Pseudonym> Nobody ever leaves me messages.
17:53:56 <Pseudonym> dcoutts: I have to wonder about that "perfectly easy".
17:53:59 <Pseudonym> Maybe in this case it would.
17:54:00 <lambdabot> Pseudonym: You have 1 new message. '/msg lambdabot @messages' to read it.
17:54:10 <Pseudonym> Woohoo!  Thanks!
17:54:13 <dcoutts> Pseudonym, the cases it doesn't cover is FFI decls
17:54:14 <ivant> xerox: welcome
17:54:15 <xerox> %-)
17:54:23 <dcoutts> and changing locations/names of imports
17:54:43 <Pseudonym> There are situations where you have things where implementation detail leaks to the application level.
17:54:55 <Pseudonym> Like, say, file permissions, which are VERY different in Posix than in Win32.
17:55:24 <heatsink> dcoutts: I've had reasons to use SIZEOF_VOID_P.
17:55:39 <dcoutts> sadly so have I
17:55:49 * dons raises hand too
17:56:06 <dcoutts> we've got some highly GHC-specific code in fps of course
17:56:22 <dcoutts> that uses cpp quite a bit to provide non-GHC versions
17:56:22 <dons> also, these days we have the  (semi-experimental) WordPtr and so on
17:56:34 <dcoutts> WordPtr?
17:58:32 <Pseudonym> I'm pleased to say that I've never even used FFI.
17:58:45 <Pseudonym> I'm sorry to say that's because I've never written any code that's practical enough for it.
17:58:58 <xerox> The FFI is nice!
17:59:05 <Pseudonym> Oh, it looks nice, that's for sure.
17:59:35 <ivant> hey, I just told the same thing about FFI, couple of pages above! :-)
17:59:49 <xerox> I never had to use such defines as the one you mentioned before, tought.
18:00:46 <Pseudonym> It's nice if you can deal with the platform-specificness in the foreign code.
18:01:07 <xerox> Allright.
18:01:29 <eivuokko> I much rather deal with them in haskell rather than write, say C.
18:01:41 <eivuokko> But I do use hsc2hs quite a lot.
18:02:05 <dons> Pseudonym: did you notice lambdabot got mentioned in the history of haskell paper? :)
18:02:23 <Pseudonym> Yeah. :-)
18:02:25 <Pseudonym> Nice touch.
18:03:02 <xerox> @karma+ lambdabot
18:03:02 <heatsink> neato.
18:03:03 <lambdabot> lambdabot's karma raised to 20.
18:05:00 <xerox> 3am ~ yawn
18:05:14 <xerox> I just finished explaning monads to a group of people, good fun.
18:06:15 <heatsink> were they listening voluntarily?
18:06:25 <dons> xerox: what analogy or metaphor did you use?
18:06:27 <xerox> They were asking for it!
18:06:31 <dons> monad-as-garbage-bin?
18:06:34 <ivant> @type liftM
18:06:35 <heatsink> heh
18:06:36 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
18:06:37 <xerox> dons - Containers, Cale docet.
18:06:38 <dons> monad-as-refrigerator?
18:06:43 <xerox> hahaha
18:06:51 <dons> monad-as-unicycle?
18:07:17 <Cale> :)
18:07:20 <ivant> monad-as-lovely-pillow
18:07:32 <xerox> ?remember dons xerox: what analogy or metaphor did you use? monad-as-garbage-bin? monad-as-refrigerator? monads-as-unicycle?
18:07:32 <lambdabot> Done.
18:07:41 <ivant> it's 5am and my program does not compile yet :-)
18:07:49 <Cale> monads as food gathering in post-industrial America
18:07:49 <xerox> ivant: it's really a good time for that analogy in fact...
18:08:10 <dons> ivant: just see it as taking time out of future debugging :)
18:08:34 <xerox> That sounds comonadic
18:08:35 <dons> ?rememeber Cale [more monad clarity] monads as food gathering in post-industrial America
18:08:36 <lambdabot> Done.
18:08:42 <xerox> hahaha
18:09:24 <xerox> Good idea the [] thing.
18:09:54 <heatsink> @recall Cale
18:09:54 <lambdabot> Unknown command, try @list
18:10:01 <heatsink> @Cale
18:10:02 <lambdabot> Unknown command, try @list
18:10:05 <Cale> @quote Cale
18:10:05 <lambdabot>  ... if sections were allowed at the type level ...
18:10:06 <xerox> @quote Cale
18:10:06 <lambdabot>  Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
18:10:10 <Cale> @quote Cale
18:10:10 <lambdabot>  Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
18:10:11 <Cale> @quote Cale
18:10:12 <lambdabot>  [more monad clarity] monads as food gathering in post-industrial America
18:10:13 <Cale> @quote Cale
18:10:13 <lambdabot>  [more monad clarity] monads as food gathering in post-industrial America
18:10:15 <xerox>  ... you could write (a ->)
18:10:15 <ivant> btw, list monad looks like pillow []
18:10:18 <ibid> xerox: pong
18:10:40 <xerox> ibid: hi! Shapr told me to talk to you to get entries on planet.haskell
18:11:13 <xerox> Did you people see SPJ on unicycle?=
18:11:15 <ivant> @djinn [a] -> a
18:11:16 <lambdabot> f _ = fix (\ a -> a)
18:11:32 <dons> xerox: no?
18:11:40 <xerox> peytonjones06unicycling @ http://paolo.is-a-geek.com/mu/
18:11:50 <Pseudonym> *FreeTheorems> freeTheorem "head" tHead
18:11:50 <Pseudonym> (forall f_1 :: (A_2 -> A_3). forall v1_4 :: [A_2]. forall v2_5 :: [A_3]. (forall
18:11:50 <Pseudonym>  f_6 :: (A_2 -> A_3). (forall x_7 :: A_2. forall y_8 :: A_3. f_6 x_7 = f_1 x_7)
18:11:50 <Pseudonym> => $map f_6 v1_4 = v2_5) => f_1 (head (| A_2 |) v1_4) = head (| A_3 |) v2_5)
18:12:11 <ibid> xerox: yeah. i need your feed uri :)
18:12:13 <ivant> @where liftM
18:12:13 <lambdabot> I know nothing about liftm.
18:12:17 <dons> Pseudonym: needs a pretty printer ;)
18:12:18 <xerox> ibid: okay! let me see...
18:12:21 <ivant> @index liftM
18:12:21 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
18:12:31 <xerox> ibid: feed://paolo.is-a-geek.com/mu/entry?type=rss
18:12:59 <xerox> ibid: do entries need to be tagged somehow to show up there, or everything goes?
18:13:08 <ibid> uh, feed is not a uri scheme that i know of. i assume it's accesible by http?
18:13:24 <xerox> Yes it is, I just copy and pasted, you can change 'feed' with 'http'
18:14:08 <ibid> xerox: everything in the feed. you can, if you want, provide a more specific one, though the only thing i ask is that the feed contain only english posts
18:14:28 <Pseudonym> (forall f :: (A_2 -> A_3).  f . head = head . $map f)
18:14:33 <Pseudonym> That's after serious simplification.
18:14:43 <dons> nice!
18:14:50 <xerox> ibid: mumble.
18:14:55 <syntaxfree> There's this mathematical structure, I'm not sure it can be expressed as a Haskell type.
18:15:01 <xerox> ibid: no I think it is okay, I never do too-off-topic entries
18:15:11 <syntaxfree> an Event can be Omega or it can be a subset of another event.
18:15:41 <Pseudonym> I had to use $map, because otherwise the free theorem for map is hard to read.
18:15:46 <dons> ok. hmm. data Event = Omega | Subset Event -- ?
18:15:55 <xerox> Pseudonym: yuck, what is that?
18:15:55 <ibid> xerox: yyeah, the plan is for planet to contain posts by haskell people, not just haskell posts by people :)
18:16:00 <syntaxfree> yeah, that's what I meant, I think.
18:16:02 <ivant> @index bracket
18:16:02 <lambdabot> Control.Exception, Distribution.Compat.Exception, Graphics.HGL.Draw.Monad, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL
18:16:03 <Pseudonym> xerox: Sorry?
18:16:10 <syntaxfree> dons: I wish I could attach to every event a Probability.
18:16:17 <syntaxfree> I have a Z1 data type for probabilities.
18:16:17 <xerox> Pseudonym: what is FreeTheorem?
18:16:45 <xerox> ibid: I'll try my best :)
18:16:49 <Pseudonym> xerox: Any function g of type forall a. [a] -> a must satisfy the theorem:
18:16:53 <syntaxfree> can I somehow specify that an Event has  Z1 p attached?
18:16:57 <Pseudonym> forall f. f . g = g . map f
18:17:02 <dons> ok. hmm. data Event = Omega | Subset Event ; data GenEvent a = GenEvent a ; type Event = GenEvent Probability -- ?
18:17:11 <Pseudonym> (Note: In fact, seq breaks this guarantee.)
18:17:16 <dons> syntaxfree: see above. paramaterise the Event on a type, then supply the type
18:17:24 <Pseudonym> (But for seq-free programs, the theorem is true.)
18:17:28 <dons> seq is super evil for free theorems
18:17:38 <dons> breaks build/foldr for the same reasons
18:17:42 <Pseudonym> Right.
18:17:56 <ibid> xerox: added
18:17:56 <Pseudonym> build/foldr is true because of the free theorems for build and foldr.
18:17:58 <syntaxfree> umm.
18:18:04 <xerox> Pseudonym: oh I see.
18:18:11 <xerox> ibid: thank you very much :)
18:18:13 <syntaxfree> with data Even = Omega | Subset Event, can an Event have more than one subset?
18:18:49 <dons> it could. you just need to flatten the type, if you want to prevent that
18:19:07 <syntaxfree> flatten?
18:19:18 <dons> data Event = Omega | Subset [AtomicEvent] ; newtype AtomicEvent = AtomicEvent Probability
18:19:21 <dons> perhaps?
18:19:41 <syntaxfree> hmm. interesting.
18:19:42 <dons> anyway, just get in there and hack around. as far as type hackery goes, this doesn't seem too hard
18:20:16 <xerox> ibid: I read some non-haskell post from other people, so it is a relaxed policy the all-haskell one, right?
18:20:17 <syntaxfree> is there a concise documentation on data constructor syntax?  Htut is way too prolix for my current needs.
18:20:22 <dons> its just a matter of finding the type that accurately models the invariants you want
18:20:56 <dons> well, the haskell98 report?
18:21:08 <dons> ?where online-report
18:21:08 <lambdabot> I know nothing about online-report.
18:21:14 <xerox> Yarrr
18:21:20 <xerox> @google haskell report
18:21:22 <lambdabot> http://www.haskell.org/onlinereport/
18:21:23 <lambdabot> Title: The Haskell 98 Language Report
18:21:27 <dons> ?where haskell98
18:21:28 <lambdabot> http://haskell.org/onlinereport/
18:21:33 <syntaxfree> I hope it's not _too_ technical in turn.
18:21:50 <dons> well, if you want to program in the language, best to read the definition at some point :)
18:22:07 <dons> or get one of the textbooks, perhaps?
18:22:14 <xerox> Which is not `complete' in the sml sense, but very good :D
18:22:18 <ibid> xerox: as i said, posts by haskell people, not just haskell posts :) don't worry about on-topicness as long as you still are a haskeller (of course, haskell posts every once in a while are appreciated)
18:22:34 <xerox> ibid: ok cool!
18:23:16 <emertens> @hoogle round
18:23:17 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
18:23:17 <lambdabot> Text.Html.background :: String -> HtmlAttr
18:23:17 <lambdabot> System.Win32.Info.cOLOR_BACKGROUND :: SystemColor
18:23:24 <ibid> xerox: one of the points of a planet is seeing what the relevant people are doing and thinking :)
18:23:26 <syntaxfree> what does  Subset [AtomicEvent] mean?
18:24:02 <dons> that an event might be a subset of a list of events?
18:24:06 <xerox> ibid: that makes sense.
18:24:11 <ibid> xerox: ... sort of the soapbox of the community :)
18:24:15 <dons> i'm not 100% sure what you're tryign to do, so just guessing
18:24:26 <xerox> ibid: I like it! I didn't know it existed until today I believe
18:24:44 <ibid> xerox: feel free to advertise. we did discuss it on -cafe when we started it
18:24:58 <xerox> OK.
18:25:20 * ibid should remember to write something of planet to the communities report
18:25:42 * ibid had a doh! moment when reading the latest one :)
18:26:03 <xerox> Yeah you should :D
18:29:44 <syntaxfree> dons: Oh, I see.
18:39:46 * ivant does unsafePerformIO (apply pillow (head me)) where apply = (.)
18:40:25 <dons> heh
18:40:30 <dons> you shouldn't use unsafePerformIO ;)
18:40:32 * xerox in answer return xerox `ap` pillow -- and stays pure
18:40:54 <dons> pillow `fmap` return . (head me) -- perhaps?
18:41:24 <xerox> There's an id there
18:41:24 <dons> ?type ap
18:41:24 <dons> ?type fmap
18:41:25 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
18:41:27 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
18:41:54 <xerox> ?pl \pillow -> pillow `fmap` return . head
18:41:55 <lambdabot> (line 1, column 33):
18:41:55 <lambdabot> unexpected "."
18:41:55 <lambdabot> expecting variable, "(", "!!", space, operator or end of input
18:41:55 <lambdabot> ambiguous use of a right associative operator
18:41:59 <xerox> Boom.
18:42:05 <xerox> ?pl \pillow -> (pillow `fmap` return) . head
18:42:05 <lambdabot> (. head) . (`fmap` return)
18:42:27 <xerox> ?pl (`fmap` . return)
18:42:28 <lambdabot> (line 1, column 2):
18:42:28 <lambdabot> unexpected "`"
18:42:28 <lambdabot> expecting lambda abstraction or expression
18:42:31 <xerox> Grrrr.
18:42:43 <xerox> ?pl \x -> (x `fmap`) . return
18:42:44 <lambdabot> (return .)
18:42:47 <xerox> Dang.
18:45:36 <syntaxfree> @hoogle Parsec
18:45:37 <lambdabot> Text.ParserCombinators.Parsec :: module
18:45:37 <lambdabot> Distribution.Setup.parseCleanArgs :: [String] -> [OptDescr a] -> IO (Int, [a], [String])
18:45:37 <lambdabot> Distribution.Setup.parseConfigureArgs :: ConfigFlags -> [String] -> [OptDescr a] -> IO (ConfigFlags, [a], [String])
19:06:45 * edwardk wave ello..
19:07:24 <Lemmih> Morning.
19:17:10 <edwardk> awfully chatty at this hour, isn't it? =)
19:19:46 <dons> anyone got an amd64 and a spare 5 minutes?
19:20:06 * edwardk does, but not in a 64 bit os at the moment =)
19:20:14 <dons> no 64 bit longs?
19:20:23 <edwardk> i'm just running in win32 atm
19:20:33 <edwardk> so would guess not
19:20:41 <edwardk> nope, none
19:20:41 <Patterner> dons: what do you want me to do?
19:20:56 <Patterner> x86_64/linux
19:21:20 <dons> do you have a recent Cabal installed, and ghc6.4.2 or later?
19:22:07 <Patterner> 6.4.2, 1.1.4
19:22:56 <dons> actually, maybe I can just get a code review. edwardk can you comment on the 'reverse' and 'intersperse' functions: http://www.cse.unsw.edu.au/~dons/code/fps-unstable/cbits/fpstring.c
19:23:16 <dons> edwardk: anything suspicious there?
19:24:22 <dons> Patterner: ok, perhaps we can just see. can you darcs pull http://www.cse.unsw.edu.au/~dons/code/fps-unstable/
19:24:22 <lambdabot> Title: Index of /~dons/code/fps-unstable
19:24:54 <Patterner> fpstring.c:37:13: Test expression for while not boolean
19:24:56 <Patterner> fpstring.c:78:20: Test expression for for not boolean
19:25:03 <dons> ah good idea
19:25:25 <Patterner> (that was splint :)
19:25:44 <dons> cheers
19:25:46 <Patterner> no. but i'm 'get'ting it
19:26:04 <dons> yeah, pull. then configure ; build ; install
19:26:13 <dons> and run the testsuite: cd tests && make
19:26:58 <dons> or, faster: cd tests && runhaskell Properties.hs
19:27:53 <Patterner> is the "install" part really necessary?
19:28:09 <lispy> @pl zipWith (*)
19:28:09 <lambdabot> zipWith (*)
19:28:12 <lispy> hm...
19:28:16 <lispy> no product2?
19:28:29 <dons> Patterner: hmm. to have ghc use the package when running the tests, yes
19:28:41 <dons> however, its only a single library, so you can uninstall easily
19:29:03 <dons> ghc-pkg unregister fps-0.8 ; rm -rf /some/path/lib/fps-0.8
19:30:12 <Patterner> still getting it...
19:30:17 <Patterner> tick tock... tick tock...
19:30:28 <dons> we've been busy :)
19:30:49 <dons> ?karma+ Patterner -- testing
19:30:50 <lambdabot> Patterner's karma raised to 1.
19:32:01 <Patterner> no greencard, no pfesetup
19:32:11 <dons> that's fine
19:32:15 <dons> just Cabal being noisy
19:32:39 <dons> i don't know of any haskell program that needs pfesetup, actuallly.... aways wondered why Cabal tests for that
19:33:21 <Patterner> i wonder why gentoo has no greenard
19:33:45 <dons> greencard is rarely used these days
19:34:32 <edwardk> er, what is greencard? =)
19:34:32 <dons> c2hs is more common. hand written ffi bindings even more so
19:34:41 <dons> its an ffi binding generator
19:35:10 <Patterner> i have c2hs :)
19:35:11 <dons> the original
19:35:12 <dons> circa. 1997
19:35:25 <dons> Patterner: doesn't matter, though. you don't need any of these tools to build fps
19:35:36 <Patterner> testing Properties
19:35:37 <dons> Cabal just tests for a bunch of things whether we like it or not :)
19:35:51 <Patterner> so far lots of "OK, 100 tests" lines
19:35:52 <dons> cool
19:36:03 <dons> that's good.
19:36:19 <Patterner> thought so :)
19:36:29 <Patterner> bad lines are "No OK", right?
19:37:05 <dons> well, "Failed .... "
19:37:37 <dons> we're just checking that neither intersperse nor reverse start failing on 64 bits
19:38:18 <Patterner> i need a faster computer, it is still testing...
19:38:42 <dons> there's lots of tests :)
19:39:17 <Patterner> getting a better computer is always a good idea :)
19:40:17 <Patterner> concatMap is very slow
19:40:58 <dons> it is
19:41:10 <Patterner> "All done"
19:41:19 <dons> no failures ?
19:41:27 <Patterner> nope
19:41:30 <dons> great!
19:41:43 <Patterner> running "make" now
19:41:44 <dons> ?karma+ Patterner -- computing resources
19:41:45 <lambdabot> Patterner's karma raised to 2.
19:41:58 <dons> now, expect this to take longer. it runs the tests in a bunch of different ways
19:42:35 <dons> with different flags and so on
19:43:47 <lispy> @pl \(x,y) -> (x+1,y)
19:43:47 <lambdabot> first (1 +)
19:43:58 <lispy> @type first
19:43:59 <lambdabot> forall (a :: * -> * -> *) d c b. (Arrow a) => a b c -> a (b, d) (c, d)
19:44:02 <lispy> @type fst
19:44:03 <lambdabot> forall a b. (a, b) -> a
19:44:29 <lispy> @type first (1 +)
19:44:30 <lambdabot> forall b d. (Num b) => (b, d) -> (b, d)
19:44:40 <lispy> interesting
19:45:27 <dons> http://www.theregister.co.uk/2006/08/17/firefox_crop_circle/
19:47:41 <lispy> oh yeah, that happened near where i live
19:47:59 <dons> heh
19:49:41 * lispy goes to oregon state
20:03:20 <Patterner> "All done"
20:03:32 <Patterner> no errors or failures.
20:03:50 <dons> great!
20:04:41 <dons> thanks for running that Patterner
20:05:21 <Patterner> np.
20:05:52 <Patterner> just send a /msg when you need more testing
20:06:44 <dons> cheers
20:16:11 * emertens wonders if a "J translator" exists
20:33:17 <lisppaste2> randy pasted "ldd svnserve" at http://paste.lisp.org/display/24330
21:07:31 <newsham> anyone here handy with haxml?
21:07:42 * stepcut is a bit handy
21:07:50 <stepcut> though I always feel like I am using it wrong :-/
21:08:01 <newsham> so in their paper the "attributed" lifter would label the node with a list of all attr name/val pairs.
21:08:16 <newsham> but in the ucrrent version it only labels it with the value from one attribute (given its name)
21:08:27 <sieni> isn't there xsxml also?
21:08:30 <newsham> i want to walk over all attributes.. is there an ways way in the current impl?
21:08:55 <newsham> one solution is to just dig into the data structure and grab the attributes.. but i want to do it "the HaXml way"
21:09:37 * stepcut checks
21:09:49 <newsham> maybe I should back up and say what I'm doing...
21:10:39 <newsham> http://www.thenewsh.com/~newsham/x/tweaker.hs <- here's what i'm goofing with.
21:10:49 <newsham> my use of "attributed" is wrong as noted above
21:10:55 <newsham>  but you shoul get the gist of it
21:13:42 <stepcut> newsham: so, for any given element you are either going to replace all the attributes, or none of the attributes ?
21:13:55 <newsham> no, either replace no attributes, or some fraction of them.
21:14:25 <stepcut> ah yes, i see that now
21:15:21 <newsham> is it in poor taste to access the Content members?
21:15:52 <Pseudonym> Surely that depends what you do to them when you "access" them.
21:15:56 <stepcut> access in what way?
21:16:39 <newsham> i suppose i could write 'newAttrs' in a way that grabs the attributes from the current node
21:16:54 <stepcut> extracted :: (Content -> a) -> CFilter -> LabelFilter a
21:16:55 <stepcut>   Label each content with some information extracted from itself.
21:17:33 <stepcut> I don't see a combinator that gets all the attrs, but 'extracted' looks like it might be a good way to build one that does...
21:17:37 <newsham> newAttrs (CElem n as cs) = [CElem (Elem n as' cs)] where as' = tweakAttrs as
21:17:39 <newsham> something like that?
21:17:51 <newsham> yah, I saw extracted... but no accessor to go with it
21:18:18 <newsham> seems like illegally crossing an abstraction boundary to reach into CElem like that, though.
21:18:25 <newsham> the name's even different than the interface published in the paper :)
21:19:31 <newsham> perhaps what i want to do wasnt intended by haxml authors
21:20:40 <stepcut> newsham: i think you just need to build a new combinator -- if you look in Combinators.hs, you can see how he uses 'extracted' to build tagged, attributed, etc
21:21:26 <newsham> *nod*
21:21:36 <newsham> but to do that I have to access the consituents of CElem, yes?
21:21:47 <stepcut> newsham: yeah
21:22:42 <stepcut> I always feel like I am using HaXml the 'wrong' way too -- so it's not just you :)
21:22:58 <stepcut> I am still not clear on how I am supposed to *construct* xml documents
21:26:50 <stepcut> I don't think I have ever written a program that used HaXml and did not manipulate the data types (CElem, etc) directly in some place -- maybe it is supposed to be that way...
21:28:01 <newsham> HaXml-1.13.1/examples/Example.hs looks like its creating a doc
21:28:13 <newsham> though its using a DTD I guess
21:30:05 <newsham> updated the code on my page.. it compiles now.. i made a weird tweak function that tears into a CElem.  but I get a runtime error:
21:30:09 <newsham> a.out: xx.hs:19:4-92: Non-exhaustive patterns in function tweakAttrs
21:30:22 <newsham> oh, i was looking at the wrong place :)
21:30:39 <newsham> (two functions with nearly the same name)
21:32:17 <newsham> ok, now it runs, but it looks like all the random choices are identical.
21:32:23 <newsham> i'm using split and randomR correctly, right?
21:34:01 <newsham> also, is my "main" sane?  should it be "withRands gen keep"?  and using foldXml is the best approach?
21:36:21 <foxy> @seen dons
21:36:22 <lambdabot> dons is in #haskell-overflow and #haskell. I last heard dons speak 1 hour, 29 minutes and 39 seconds ago.
21:36:44 <foxy> dons, have you had a chance to look at find-file in yi+gtk?
23:39:24 --- topic: '["Haskell Communities & Activities Report, 10th edition", "http://haskell.org/communities/", "Haskell.org SoC projects", "http://hackage.haskell.org/trac/summer-of-code/", "Haskell is still the language of choice for discriminating hackers", "logs:", "http://tunes.org/~nef/logs/haskell/", "http://www.haskell.org/learning.html", "We put the Funk in Funktion", "The ICFP has ended. Who won?"]'
23:39:24 --- topic: set by dons on [Thu Aug 10 22:11:10 2006]
23:39:53 <dons> ?version
23:39:53 <mbot> lambdabot 4p70, GHC 6.4.1 (Linux i686 2.40GHz)
23:39:53 <mbot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
23:40:45 <Cale> It's only a couple of days old, so if that's not current, you've been busy :)
23:40:56 <dons> its current :)
23:41:10 <dons> ?uptime
23:41:10 <mbot> uptime: 3 minutes and 39 seconds
23:41:16 <Korollary> I am appalled that Cale is not running ghc-head.
23:41:21 <dons> heh
23:41:37 <Korollary> 6.4.1 ? Are you a newbie or something?
23:41:40 <Cale> heh
23:41:53 <dons> well, its not hugs... that's something ;)
23:41:56 <Cale> Compiling things is for suckers
23:42:23 <Korollary> I am with ya there.
23:51:56 <araujo> hello
23:53:28 <lispy> hi
23:55:36 <gaal> Hi, I think I found a bug in the GHC docs. In http://haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#implicit-parameters
23:55:56 <gaal> in the section "Implicit-parameter type constraints", the function least xs = fst (sort xs)
23:56:03 <gaal> shouldn't that be "head"?
23:56:29 <gaal> (The Hugs docs have the same text)
23:56:45 <dons> yep. looks like a bug
23:56:55 <dons> submit a patch/bug report
23:56:58 <gaal> where's the right place to report it?
23:57:06 <dons> the ghc trac system?
23:57:13 <dons> i.e. go to haskell.org/ghc
23:57:20 <gaal> okay, thanks.
23:57:21 <dons> and find the bug reporting page
