00:00:31 <lispy> dons: okay i made a small note in the readme, let me know if you don't get the patch (I haven't tried darcs send from this machine yet, but postfix should be sendmail mail)
00:02:21 <sieni> Nice arrow tutorial. The first two sentences read: "Many Haskellers begin by asking "what are arrows?"  I won't answer
00:02:24 <sieni> this question."
00:02:56 <lispy> heh
00:04:47 <dons> heh
00:04:59 <dons> lispy: recvd
00:08:01 <lispy> sweet
00:08:28 <lispy> hopefully i'll find time for refactoring tomorrow...meant to do that tonight but ended up fighting with my ex...
00:08:31 <lispy> bleh
00:08:40 <Korollary> again?
00:08:52 <lispy> yeah, seems to be about once a week i think
00:09:03 <Korollary> Shall I send a peacekeeping force?
00:09:12 <lispy> heh
00:09:21 <lispy> no, she said i'm being mean and doesn't want to talk to me anymore
00:09:30 <lispy> so...probably won't be a problem anymore
00:10:02 <Korollary> That's cool. I've always wanted to be mean.
01:21:38 * edwardk waves hello.
01:31:46 <edwardk> busy place at this hour ;)
01:32:54 <profmakx> its 10:30 in Germany
01:33:06 <profmakx> so all students are asleep ^^
01:33:09 <edwardk> 4:30am here in detroit ;)
01:33:23 <profmakx> hmm
01:33:36 <profmakx> are you already awake or still?
01:33:53 <edwardk> just woke up, figured i'd get some code written before going in to work
01:34:09 <profmakx> oh
01:34:15 <profmakx> well
01:34:26 <profmakx> i figure i should write some latex-stuff now
01:34:29 <edwardk> trying to get as much done as i can before semester starts and i get bogged down teaching
01:34:49 <profmakx> or else my prof will be a little disappointed ;)
01:35:02 <edwardk> fair enough
01:35:09 <profmakx> what are you working on?
01:36:16 <edwardk> i started cobbling together a mix of traditional linear and other substructural types, uniqueness types and regions to build a fast intermediate language for functional programming languages that allows in-place updates and linear/affine-style destroy on first-use semantics where appropriate.
01:36:22 <xerox> ?yow!
01:36:23 <lambdabot> YOW!!  Now I understand advanced MICROBIOLOGY and th' new TAX REFORM
01:36:23 <lambdabot> laws!!
01:37:10 <edwardk> went down a long and circuitous path involving non-commutative linear-logic before scrapping it and showing that the region based version was more powerful and more useful in practice.
01:37:44 <edwardk> i guess its kinda dry unless you are into that sort of thing =)
01:37:49 <johnnowak> edwardk: pfft.. i could've told you that.
01:37:53 <profmakx> well
01:37:57 <edwardk> heh
01:38:00 <profmakx> i deal with logic in my studies
01:38:12 <profmakx> but i haven´t yet done much on functional programming
01:38:19 <profmakx> anyway it sounds interesting ;)
01:38:37 <edwardk> my math background is mostly in non-euclidean geometry, so this takes me into utterly strange territory for me ;)
01:38:59 <profmakx> whee, you know triangle groups/hyperbolic groups?
01:40:05 <edwardk> have heard the terms, but they don't stick out in my mind. my major usage was for computational visibility, so lots of work in the real version of the Plucker quadric and properties of isotropic quadratic spaces.
01:41:27 <profmakx> ah
01:41:42 <edwardk> so mostly i just lifted 3d lines into a 5d projective space and played with them there to show the existence or absence of certain lines.
01:41:43 <profmakx> that rings a bell
01:42:08 <profmakx> yeah this sort of thing proves very useful in visibility calculations
01:42:17 <edwardk> useful if you want to build a 3d game or something and only want to show the polygons that are visible.
01:43:10 <profmakx> i do write 3dgames in my "free time"
01:43:17 <profmakx> as long as i have free time
01:43:28 <profmakx> which isnt the case that often
01:43:33 <edwardk> i used to do 3d game programming stuff about 10 years ago, so the plucker stuff always interested me. when i got a chance, i went back, did a masters in math and worked out another coordinatization for the plucker quadric that had nice properties, then showed it was equivalent to promoting a 130-year old coordinate system by Eduard Study into modern oriented projective geometry.
01:43:59 <edwardk> so, thats my first thesis in a nut-shell ;)
01:44:11 <profmakx> nice ;)
01:44:31 <profmakx> is it available online?
01:44:56 <edwardk> basically showing that te Study coordinates can be viewed as the diagonalization of the plucker quadric, so they have nice properties, and their traditional disadvantages don't exist any more now that we have oriented projective geometry and can tell lines from its duals in study coordinate terms.
01:44:59 <edwardk> sure, one sec.
01:45:17 <edwardk> http://slipwave.com/~harmless/thesis.pdf is an older draft of it.
01:45:34 <profmakx> a bit like quaternion rotations concerning rotations isnt it?
01:45:38 <profmakx> or am i way off here?
01:45:49 <edwardk> its fine aside from a few points of chapter 11
01:46:25 <profmakx> has it been used in "practise" yet?
01:46:32 <edwardk> well, actually you can view study coordinates as a pair of points at infinity describing each line, so you can treat them as 2 unit quaternions describing each line
01:47:23 <edwardk> yeah. i have a library of code for it that works just fine and the plucker version i used for visibility like 10 years ago. all i did was shift to a better basis for my vector space and show some nice properties for mapping back out into 'real' 3d projective space.
01:48:42 <edwardk> in the end it embeds a 3d projective space in a 5d projective space, where all lines in the 3d space map to points or hyperplanes on a quadric surface (depending on the map)  and points and planes both map onto certain equivalence classes of planes.
01:48:59 <edwardk> it sounds strange, but it works =)
01:49:33 <profmakx> well i think i will take my time and read the thesis ;)
01:49:44 <profmakx> and then come back and bore you with questions
01:49:46 <edwardk> theorem A.4.4 in the paper should connect the quaternion case to study coordinates
01:50:50 <edwardk> the nice part about showing an equivalence with such an old coordinate system is that there were so many 'free theorems' i could rip out of old literature from 80 years ago and update into the modern context.
01:50:55 <_frederik_> you guys are crazy
01:51:01 <edwardk> fred:?
01:51:27 <_frederik_> yes?
01:51:40 <edwardk> prof: anyways, if you make it to chapter 11 let me know and i'll try to drum up a more current version of it. the main results there drop from O(N^4 alpha(n)) to O(n^2)
01:51:53 <edwardk> by applying more conve polytope theory
01:52:01 <edwardk> er convex polytope
01:52:27 <profmakx> yes, i will let you know ;)
01:52:42 <edwardk> though that version of the proof takes the paper from being quite as accessible as this version, which just presumes an understanding of linear algebra and decent mathematical maturity.
01:52:56 <profmakx> for now i will go to my triangle groups and prove theorems about their automatic structure
01:53:22 <edwardk> ay particular usage in mind or just exploring for sake of exploring?
01:54:00 <profmakx> for your thesis?
01:54:10 <edwardk> i meant for your triangle groups actually =)
01:54:29 <profmakx> well its an idea from a prof. that did research on automatic groups
01:54:47 <profmakx> and i found automatic structures and groups very interesting so i started researching
01:54:56 <profmakx> for the sake of exploring for one
01:55:06 * edwardk nods.
01:55:06 <profmakx> and for the sake of getting my diploma finally ^^
01:55:12 <edwardk> Heh
01:55:40 <ToTimkopf> hehe
01:55:50 * ToTimkopf shares his fudge cookies with profmaksx
01:55:51 <_frederik_> what is automatic structure?
01:55:58 <edwardk> I went on a 6 month detour myself into visibility problem in systems of piecewise quadratic surfaces before i decided the existence of a solution didn't matter because the complexity was too high for hardware for the forseeable future. =/
01:56:06 <_frederik_> what are substructural types?
01:56:22 <edwardk> frederik: do you know what contraction and weakening are in logic?
01:56:28 <_frederik_> no
01:56:45 <edwardk> frederik: ok, well, lets think about haskell and the lambda calculus for a sec.
01:57:14 <edwardk> frederik: \x -> x + x    contracts x because it uses it twice. whereas \_ -> 12 weakens its argument because it doesn't use it at all.
01:57:28 <_frederik_> ok
01:57:39 <_frederik_> i can't really generalize from those examples
01:58:01 <edwardk> well, if you show that you don't contract or weaken you know that you will use every variable once exactly, so you can allocate it, compute it eagerly and discard it immediately after first usage.
01:58:45 <_frederik_> ok. something to do with linear logic?
01:59:17 <edwardk> proving the absence of contraction or weakening alone also yield possible optimizations. if you never contract, then you never duplicate the reference to your variable, so its used at most once, and if you never weaken, you know that you will have to use the value, so its relevant and can be eagerly computed.
01:59:19 <edwardk> yeah.
01:59:47 <edwardk> substructural basically pertains to any limitation on the exchange, contraction or weakening rules of logic.
01:59:48 <profmakx> _frederik_, an automatic structure for an algebraic structure is essentially a set of finite state automata that recognize every relation in the structure plus a sujective map from some regular language to the universe of the structure
02:01:30 <_frederik_> edwardk: so "substructural" in that contraction and weakening are statements about the use of variables, and not expressible with compositional syntactic rules?
02:03:07 <edwardk> frederick: yeah, you usually take the sequent calculus for the language and contort it to eliminate those rules, and then explicitly reintroduce them in a more limited context using some form of forgetful functor (really a comonad) called an exponential.
02:03:45 <_frederik_> profmakx: what do you mean to "recognize a relation"? what is the universe of a structure?
02:04:20 <profmakx> well take the set of all words over a finite alphabet
02:04:27 <edwardk> fred: basically you have your fsa, you feed it your word one letter at a time, then if the fsa is in an accept state at the end, your word has the desired property.
02:04:34 <profmakx> and the shortlex-order
02:04:40 <edwardk> is that a reasonable approximation? =)
02:05:12 <profmakx> then there exists an automaton in 2 input words that accepts the "fold" of two words iff v < w in the shortlex order
02:05:19 <profmakx> the universe is here the set of words
02:05:28 <profmakx> and the relation is the shortlex ordering
02:05:31 <_frederik_> edwardk: no, i don't understand. for me a relation is a set of pairs
02:05:39 <_frederik_> shortlex-order?
02:06:10 <profmakx> yes. first "length" and if lengths are equal look at lexical ordering
02:06:20 <_frederik_> ok
02:06:39 <profmakx> in my terms relations can be n-ary, but that does not matter
02:07:00 <profmakx> the automaton for < exactly recognizes pairs of words that are in the relation
02:07:19 <_frederik_> what is the "fold" of two words?
02:08:03 <profmakx> well take pairs of letters
02:08:07 <edwardk> fred: well, i kind of oversimplified, coz as i recall you use a number of automata for it, one that checks if two are equal, one that checks if you are in reduced form, and some product or multiplier
02:08:35 <profmakx> so if you have v = abc and w = def
02:08:47 <profmakx> v "fold" w is (a,d)(b,e)(c,f)
02:09:01 <edwardk> > zip "abc" "def"
02:09:02 <lambdabot>  [('a','d'),('b','e'),('c','f')]
02:09:03 <profmakx> so you have one "letter" to feed into your finite state automaton
02:09:10 <edwardk> each pair is a letter
02:09:15 <profmakx> yeah zip was the haskell op ^^
02:09:15 <_frederik_> ok
02:09:22 <profmakx> <- not yet too fluent in haskell
02:09:45 <profmakx> i call it fold for the sake of notation in earlier works on the topic
02:10:00 <_frederik_> what are the relations in an algebraic structure?
02:10:05 <_frederik_> how does a forgetful functor introduce structure?
02:10:22 <edwardk> well you forget the ability to weaken or contract.
02:10:25 <profmakx> i dont get your question ^^
02:10:51 <edwardk> hence why its easier to think about it as a comonad that allows those operations
02:11:08 <edwardk> and can then be dropped.
02:11:17 <profmakx> an algebraic structure is just a set (called universe) together with some relations and some functions
02:11:41 <edwardk> it gets weirder coz i have two comonads, one that disallows it initially for uniqueness, then another than you shed to lose the ability again to go linear.
02:12:26 <profmakx> btw... any good papers/books on how category theory fits into functional programming?
02:12:38 <edwardk> prof: tons of them. hardly know where to start.
02:12:52 <edwardk> robin cockett has written a bunch of papers, but not sure how accessible they are
02:12:53 <profmakx> because, i learned Category Theory only in context of Cohomology of Groups
02:13:48 <edwardk> eugenio moggi wrote a book on the computational lambda calculus that introduced the concept of monads to what later became the haskell community, thats a good historical starting point
02:14:18 <edwardk> dana harrington's thesis on uniqueness typing makes use of a lot of CT for its categorical semantics,but is a bit like jumping into the deep end of the pool.
02:14:45 <_frederik_> profmakx: i'm just having trouble visualizing. is a group an algebraic structure? what are the functions and relations?
02:14:51 <edwardk> if you are comfortable with linear logic there are a number of papers that reference CT principles in its usage.
02:15:07 <profmakx> yes groups are algebraic structures
02:15:33 <profmakx> and you can view right-multiplication by a generator as a relation
02:15:35 <profmakx> for example
02:15:49 <profmakx> (well, at least this is what i do in my work right now ;))
02:16:09 <_frederik_> profmakx: ok. what about functions?
02:16:17 <profmakx> well
02:16:27 <profmakx> functions are only a special case of a relation
02:16:33 <profmakx> (in a certain sense)
02:16:55 <_frederik_> profmakx: so the relations are enough to define the structure? so an automatic structure is a way to define an algebraic structure?
02:17:04 <profmakx> yes
02:17:17 <profmakx> even more, you can represent infinite structures by finite means
02:17:35 <_frederik_> what does that mean?
02:17:40 <profmakx> well
02:17:46 <_frederik_> infinite in the sense that the number of relations is infinite?
02:17:46 <profmakx> take an infinite group
02:17:52 <_frederik_> ok
02:17:55 <profmakx> it is infinite
02:18:09 <profmakx> but you can "represent" all elements by an automaton
02:18:16 <profmakx> or a regular language
02:18:21 <profmakx> (which is equivalent)
02:18:31 <profmakx> or some MSO-Formula ;)
02:18:31 <_frederik_> ok
02:18:36 <_frederik_> MSO?
02:18:41 <profmakx> uhoh
02:18:51 <profmakx> note to self: dont throw in too many things at once ;)
02:18:57 <profmakx> Monadic Second Order Logic
02:19:07 <profmakx> essentially you can quantify over sets of elements
02:19:19 <profmakx> as in "There exists a set X of elements, such that"
02:19:27 <_frederik_> oh
02:19:34 <_frederik_> where does the monad come in?
02:19:51 <profmakx> well
02:20:29 <profmakx> the "monadic" does not have anything to do with "monads" from CT i suppose
02:21:24 <profmakx> it reflects that you can quantify over unary relations
02:21:29 <profmakx> only
02:21:40 <_frederik_> ok
02:21:45 <profmakx> so this logic is much more restricted than Second Order logic is
02:23:19 <edwardk> http://www.brics.dk/RS/95/21/BRICS-RS-95-21.pdf should give a decent overview of generating automata from m2l.
02:24:14 <_frederik_> if i read the chapter on monads in mac lane, then i'll understand this stuff about exponential forgetful functor comonads reintroducing weakening and contraction in a language?
02:25:05 <edwardk> probably not in isolation
02:25:13 <_frederik_> what else should i read?
02:25:36 <edwardk> you'd probably want to read jean-yves girard's papers on linear logic, that will motivate the use of the exponentials ! and ?
02:26:02 <edwardk> then you can look at a paper by phil wadler and others on linear logic as a programming language, that will make the comonad connection for !.
02:26:52 <profmakx> ups. MacLane died last year -.-
02:26:58 <edwardk> yeah =(
02:28:16 <edwardk> you may want to read around on a bunch of other stuff to make linear logic's categorical semantics sink in. there are a bunch of papers by robin cockett and others from u. calgary, but they aren't very accessible.
02:28:38 <edwardk> they tend towards a lot of deep CT terminology.
02:28:51 <_frederik_> i thought all CT terminology was deep :)
02:28:57 <edwardk> though the difficulty varies a bit
02:29:16 <_frederik_> well thanks for the discussion, for trying to explain this stuff
02:29:19 <profmakx> well i thought i got CT until i heard a talk by some CT-Wizard
02:30:11 <_frederik_> which universities do CT? it always seems to come out of ones i've never heard of
02:30:14 <edwardk> heh, well, there are categories, functors and monads, then there are people going on about symmetric affine categories with monoidal lax comonads , etc. ;)
02:30:31 <edwardk> prof: heh i agree =)
02:31:08 <profmakx> well, one thing to keep in mind
02:31:13 <profmakx> is that CT is just a tool
02:31:17 <profmakx> IMHO
02:31:26 <edwardk> fred: good question, depends on what parts of it interest you. u.calgary in alberta seems to put out a decent batch of CT based programming language papers
02:31:42 <_frederik_> how's cambridge?
02:31:45 <edwardk> prof: yeah. in the end its all about chasing objects around cute little diagrams to make sure everything commutes ;)
02:31:45 <profmakx> so we use it, but seldomly there is a lecture "Category Theory..."
02:31:52 <profmakx> jep
02:31:59 <_frederik_> i see
02:32:35 <profmakx> which also can be a problem
02:32:38 <edwardk> i tend to chase down authors not universities when it comes to CT stuff, so i'm not sure where would be a good place to go for it.
02:33:03 <profmakx> as in the "hauptstudium" some profs tend to just "use" CT and no one ever heard of it
02:33:09 <profmakx> which can be quite frustrating
02:33:18 <edwardk> you can probably get a good overview from a course on homological algebra in a math department somewhere, but it won't have many comp sci connections made in the course
02:33:39 <_frederik_> by the way, maybe you guys can answer a copyright question i had. i started entering a bunch of definitions and theorems from Roy Crole's "Categories from Types" into a flashcard system which would eventually be public. not the main text, but just the statements. and then i thought, maybe i should ask his permission first. but i never heard back. but i was kinda thinking that the actual statement of the results shouldn't be copyrighted, only 
02:33:55 <_frederik_> edwardk: i was wondering since i'll be at cambridge next year
02:34:20 * edwardk needs to figure out where he wants to do his phd.
02:34:36 * johnnowak wonders where edwardk is considering
02:34:38 <profmakx> same here ;)
02:34:42 <_frederik_> edwardk: cambridge have good functional programming people, and good machine learning people (my area)
02:35:03 <_frederik_> sorry "Categories for Types"*
02:35:46 <edwardk> pretty much open at this point. looking for places with strong functional programming background, not afraid of CT, staying in the states would be nice, but isn't required
02:36:17 <edwardk> some doors are closed to me because i've done masters in math and comp sci, so some programs here in the states won't want to take me coz i've already done a comp sci masters =/
02:37:04 <profmakx> hmm
02:37:23 <edwardk> but i've maintained top marks, etc, so my academics shouldn't be an issue.
02:37:59 <edwardk> though i'm a bit of a non-traditional student having come back to college after spending the previous 10 years in the real world doing dot-com stuff.
02:39:06 <edwardk> john: suggestions? i probably need to get off my ass and apply soon ;)
02:40:04 <edwardk> though i guess in defense of my pursuit of too many degrees, i only spend 3 years doing them all.
02:40:15 <edwardk> so its more like a more rigorous undergrad ;)
02:40:32 <profmakx> hehe
02:40:33 <johnnowak> edwardk: hell, don't ask me, i'm an art student :)
02:40:48 <edwardk> john: heh
02:40:54 <profmakx> i have been doing all this in parallel (maths, cs and my "own" company)
02:41:08 <profmakx> but for my phd i will be settling on one topic i suppose ^^
02:41:10 <johnnowak> i'd love to go for something CS-related but .. not exactly easy given my current position. maybe i can sneak into the media lab :)
02:41:16 <edwardk> i made and lost my millions THEN went to school ;)
02:42:28 <profmakx> i neither made nor lost millions but got along just "fine"... except for the stress
02:42:42 <edwardk> i figured i'd better settle on comp sci, coz i understand comp sci. i love mathematics, but comp sci is comparatively easy to me.
02:43:26 <profmakx> well i will have to see what i do for my phd
02:43:26 <edwardk> though, finding out about the progress the functional programming community has made has made me feel like there is something worth learning in comp sci again.
02:43:40 <profmakx> i´d love to go to australia
02:43:48 <profmakx> or Great Britain perhaps
02:44:03 <edwardk> I almost went to australia to work for a game company like 8 years ago.
02:44:14 <edwardk> glad i didn't though, they wound up closing up shop a year later ;)
02:44:17 <profmakx> but i dont know if i will do compsci or maths
02:44:28 <_frederik_> australia has some decent universities right?
02:44:45 <profmakx> _frederik_, i dont care ^^ i want to go to the beach there *laughs*
02:44:46 <dons> you could come to unsw and do some haskell hacking...
02:45:00 <_frederik_> unsw?
02:45:01 <edwardk> dons: how much longer have you got in your phd?
02:45:09 <dons> 10 months or so
02:45:13 <profmakx> well if i do learn haskell in time
02:45:21 <dons> ?google unsw
02:45:23 <lambdabot> http://www.unsw.edu.au/
02:45:23 <lambdabot> Title: UNSW: The University of New South Wales - Sydney Australia - Home page
02:45:38 <profmakx> but theres always room for research
02:45:54 <dons> 10 minutes from Bondi beach... ;)
02:45:56 <profmakx> and i frankly have to say: haskell is the least broken language i know and i totally love it
02:46:11 <profmakx> yeah! been there like 6 years ago
02:46:13 <edwardk> the other thing is i'll have to figure out how attending a foreign university will affect my financial aid status here in the states, etc.
02:46:50 <pejo> dons, oh, we use the same kind of argument. "You won't see the sun until spring". :p
02:47:01 <edwardk> and i'd need to figure out if whatever fellowship i could obtain could sustain both me and my fiancee until she could find a linguistics job in the area.
02:47:10 <dons> pejo: heh
02:47:22 <_frederik_> dons: what's your thesis?
02:47:22 <edwardk> thats my major constraint at this time
02:47:34 <dons> ?where lambdabot
02:47:34 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
02:47:37 <dons> joking ;)
02:47:45 <_frederik_> good
02:47:51 <xerox> ?where yi
02:47:51 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
02:47:55 <xerox> That's more like it ;)
02:47:57 <dons> heh
02:48:08 <_frederik_> how do i tell if a package has been compiled with profiling enabled?
02:48:28 <edwardk> oh and figuring out what to do with my cats =/
02:48:34 <dons> it works if you compile with -prof -auto-all, _frederik_
02:48:40 <dons> that's how you tell
02:49:05 <_frederik_> oh boy
02:49:21 <_frederik_> lame
02:49:37 <_frederik_> dons: you still have to read your thesis to us
02:49:41 <dons> its an easy test. otherwise you look in the lib dir
02:50:03 <profmakx> is yi like vim done right?
02:50:16 <dons> i reckon so :)
02:50:31 <profmakx> will try it tonight
02:54:58 <_frederik_> dons: is yi your thesis? or is it secret?
02:55:33 <dons> my thesis is on the research page (I think): typesafe linking
02:56:01 <dons> yi, lambdabot etc. are related projects exploring dynamic linking in a strongly statically typed setting.
02:56:07 <_frederik_> ok
02:56:09 <dons> ?where hs-plugins
02:56:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
02:56:57 <dons> > map (+1) [1..10] -- powerered by phd ;)
02:56:58 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
02:57:15 <xerox> Isn't it crazy? We survive on his toy projects.
02:57:31 <dons> :P
02:57:47 <xerox> Don't stop playing!
02:57:49 <xerox> :D
02:58:47 * edwardk thinks dons is really doing some sort of study of the effects of these technologies on people on IRC, and we are all just fish staring at him out of the fishbowl.
02:59:02 <dons> heh!
02:59:05 <profmakx> damn!
02:59:12 <profmakx> ^^
02:59:19 <xerox> Just dig it and live with it...
02:59:36 * edwardk straps himself in for another round of electro-shock therapy ;)
02:59:48 * edwardk presses the button
02:59:50 <edwardk> @yow!
02:59:50 <lambdabot> Yow!  I'm imagining a surfer van filled with soy sauce!
02:59:57 * edwardk is zapped.
03:00:05 <xerox> haha
03:00:10 <xerox> @arrr
03:00:11 <lambdabot> Avast!
03:00:13 <xerox> More morphine!
03:00:28 <xerox> Like mice in a cage.
03:01:10 <_frederik_> mice in a fishbowl
03:01:30 * boegel bites dons for not giving him enough food
03:01:57 <_frederik_> when will template haskell allow splices using functions defined in the same module?
03:02:33 * dons notes down in black book: Aug 30, 8pm. "As I suspected, boegel is a bad fish that doesn't play well with the others"
03:02:42 <edwardk> frederik: they don't seem to be in a hurry, as far i can tell, never ;)
03:02:53 <xerox> As your attorney, I advise you to take a hit out of the little brown flask in my shaving kit.
03:02:58 <dons> "remind to inject more caffeine into the water tomorrow"
03:04:04 <boegel> it would be really funny if dons is just playing along but, but he actaully _is_ doing all kinds of psycho-tests on us...
03:04:07 * boegel ponders
03:04:59 <Pupeno> Ahg, Emacs automatic indentantion drives me crazy.
03:05:03 <dons> "test how subject interacts with artificial fembot"
03:05:05 <dons> ?vixen-on
03:05:06 <lambdabot> What's this channel about?
03:05:10 <xerox> asl?
03:05:11 <lambdabot> 19/f/California
03:05:18 <profmakx> ;)
03:05:18 <lambdabot> what's worth more a flush or a full house?
03:05:23 <xerox> 7QUERY lambdabot
03:05:23 <lambdabot> Would you dress in women's clothes for me?  That really turns me on ;)
03:05:24 <xerox> ops
03:05:24 <lambdabot> why me? :)
03:05:43 <edwardk> think about it, its all about trying to breed a smarter more functional fish; by letting them play with lambdabot, the channel weeds out those imperative fish pretty fast
03:05:43 <lambdabot> I define fun
03:05:48 <profmakx> -.-
03:05:49 <lambdabot> i could really use a backrub
03:05:50 <profmakx> I hate fun
03:05:51 <lambdabot> fun fun fun!
03:05:53 <xerox> lol
03:05:54 <Pupeno> Is it me or haskell-mode doesn't know about let in a do ?
03:05:54 <lambdabot> do i amuse you?
03:05:54 <lambdabot> Ooh, functional programmers are so hot!
03:06:01 <dons> ?vixen-off
03:06:02 <lambdabot> Bye!
03:06:09 * xerox waves to \bot
03:06:25 <psi> Pupeno: it's not you
03:06:45 * Pupeno goes back to Kate and indenting by hand.
03:08:03 <xerox> I think it does...
03:08:08 <xerox> What is your problem with let-in-a-do?
03:09:00 <araujo> morning
03:09:06 <psi> indentation on the next line, iirc
03:10:15 <xerox> It seems to me that if you press TAB enough times it brings you to all the sensible positions.
03:11:42 <psi> my haskell-mode is fubared so I can't check, but as I recall there was something wrong with it.
03:12:00 <Pupeno> xerox: here it doesn't, it nevers indent the next line of a let in a do at the same level of the let, always inside the let or outside the do.
03:12:08 <Pupeno> How do you turn a number into a string ?
03:12:15 <xerox> > show 31337
03:12:15 <mux> show
03:12:16 <lambdabot>  "31337"
03:12:20 <Pupeno> thanks.
03:12:33 <dons> ?hoogle a -> String
03:12:34 <lambdabot> Prelude.show :: Show a => a -> String
03:12:34 <lambdabot> Text.Html.prettyHtml :: HTML html => html -> String
03:12:34 <lambdabot> Text.Html.renderHtml :: HTML html => html -> String
03:12:37 <xerox> What if you do:
03:12:45 <mux> ?djinn a -> String
03:12:46 <lambdabot> -- f cannot be realized.
03:12:53 <mux> ?djinn Num a => a -> String
03:12:53 <lambdabot> Cannot parse command
03:12:58 <foxy__> @karma- djinn
03:12:58 <lambdabot> djinn's karma lowered to -2.
03:12:59 <dons> no class
03:13:03 <xerox> f xs = do x <- xs
03:13:03 <xerox>           let y = x*x*x
03:13:03 <xerox> TAB-TAB-TAB...
03:13:04 * mux nods at foxy__ 
03:13:08 <xerox> Pupeno?
03:13:10 <dons> -2!
03:13:12 <psi> ?djinn Show a => a -> String
03:13:13 <lambdabot> Cannot parse command
03:13:22 <xerox> Poor djinn :(
03:13:28 <psi> oh
03:13:31 <dons> ?djinn (a -> b) -> (c -> b) -> Either a c -> b
03:13:31 <lambdabot> f a b c =
03:13:32 <lambdabot>   case c of
03:13:32 <lambdabot>   Left d -> a d
03:13:32 <lambdabot>   Right e -> b e
03:13:37 <dons> good djinn
03:13:40 <mux> heh
03:13:42 <_frederik_> @karma+ _frederik_
03:13:43 <lambdabot> You can't change your own karma, silly.
03:13:47 <_frederik_> man
03:13:53 <_frederik_> someone should write a wiki that accepts haskell code. but when modules are stored in the database, all the identifiers are replaced with placeholders, so they can be easily renamed by changing the placeholder->identifier mapping. and it will run itself using hs-plugins
03:14:01 <mux> @karma+ frederik
03:14:01 <lambdabot> frederik's karma raised to 1.
03:14:08 <_frederik_> @karma+ mux
03:14:09 <lambdabot> mux's karma raised to 3.
03:14:12 <mux> heh
03:14:15 <dons> ?djinn-add type C a = (a -> Ans) -> Ans
03:14:18 <mux> collaborative karma hacking
03:14:26 <dons> ?djinn C a -> (a -> C b) -> C b
03:14:27 <lambdabot> f a b =
03:14:27 <lambdabot>   case out (in Nil) of
03:14:27 <lambdabot>   Nil -> \ c -> a (\ d -> b d c)
03:14:27 <lambdabot>   Cons e _ -> b e
03:14:58 <dons> huh. didn't think it would throw a list in there. weird
03:15:08 <dons> ?djinn-clr
03:15:13 <dons> ?djinn-add type C a = (a -> Ans) -> Ans
03:15:17 <dons> ?djinn C a -> (a -> C b) -> C
03:15:31 <xerox> _frederik_: why do you need a wiki for that?
03:16:12 <xerox> List?
03:16:59 <_frederik_> xerox: the idea is to have a wikipedia for operating systems
03:17:18 <dons> ?djinn C a -> (a -> C b) -> C b
03:17:18 <lambdabot> f a b c = a (\ d -> b d c)
03:17:36 <xerox> _frederik_: I don't follow
03:17:36 <Pupeno> xerox: tab-tab-tab takes me well inside the let, another tab and I am outside. Never at the sime level of the let.
03:18:00 <_frederik_> xerox: the identifier thing is incidental, only to make it tractable to rename things.
03:18:41 <xerox> Pupeno: here it brings me to the same eight of "x*..", "y =..", "let..", "xs.." (adding "f "), base.
03:18:54 <xerox> Pupeno: which are pretty much all the sensible places, aren't they?
03:19:25 <xerox> _frederik_: I don't understand the hs-plugins part then.
03:20:37 <_frederik_> xerox: so it can run itself
03:21:00 <Pupeno> xerox: here it never brings me to the place of the "let", maybe we have different versions and yours works better.
03:21:01 <xerox> _frederik_: that makes it quite complex! I think.
03:21:21 <_frederik_> xerox: there would have to be a way to prevent commits that break test cases
03:21:39 <xerox> _frederik_: I think just a wiki with such capabilities is some not-obvious design.
03:21:49 <xerox> Allright :)
03:22:11 * Cale just found out that unmerciless means the same thing as merciless
03:22:27 <dons> well that's kooky
03:22:27 <xerox> Oh?
03:22:59 <Cale> and it goes back as far as the 1500's.
03:23:13 <xerox> \Un*mer"ci*less\, a. [Pref. un- (intensive) + merciless.] Utterly merciless. [Obs.] --Joye.
03:24:58 <_frederik_> what are the others? inflammable? misunderestimate?
03:25:05 <_frederik_> priceless
03:25:24 <dons> ?web1913 unmerciless
03:25:27 <lambdabot> *** "Unmerciless" web1913 "Webster's Revised Unabridged Dictionary (1913)"
03:25:27 <lambdabot> Unmerciless \Un*mer"ci*less\, a. [Pref. un- (intensive) +
03:25:27 <lambdabot>   merciless.]
03:25:27 <lambdabot>   Utterly merciless. [Obs.] --Joye.
03:25:30 <Cale>  5. Some peculiarities in the use of un-, arising in the ME. period but surviving beyond it, require special notice.    a. It is sometimes redundantly prefixed to adjs. ending in -less. Early instances are unrecheleas reckless, unroless restless, unwitles insensible (see 3 above), and ungiltles guiltless (Sir Tristr. 2144). The type, however, chiefly belongs to the later 16th and the 17th cent.; among the instances from that period are unboundless, uncomfortl
03:25:30 <Cale> ess, undauntless, uneffectless, unfathomless, unhelpless, unmatchless, unmerciless, unnumberless, unrecomptless, unremorseless, unrespectless, unshameless, unshapeless, untimeless; as late as 1786 unquestionless is found, and unrestless exists in modern dialect.
03:25:40 <dons> "Utterly merciless"
03:26:20 <dons> this english language is broke
03:26:53 <SamB> so I guess you don't stick un- on words ending in -less...
03:27:54 <xerox> Haskell is a unsideffectfull language.
03:28:15 <xerox> unsideffectless?
03:28:23 <Cale> unsideffectless, heh
03:28:40 <xerox> Weird.
03:28:46 <Cale> uneffectless is one of the listed words, in fact
03:28:54 <denq> unsideffectless :)
03:29:06 <xerox> Yeah that's where I got the idea from :)
03:30:14 <xerox> unlazinessless
03:30:40 <xerox> ...and its dual unstrictnessless.
03:31:03 <Cale> the OED page for un-, prefix 1 is almost 1MB
03:31:16 <dons> "insensible" is still in use
03:31:45 <dons> but the 'in' isn't redundant, is it?
03:32:14 <Cale> oh, the italics/bold are lost
03:32:20 <dons> ah
03:32:24 <Cale> it was giving a meaning for unwitles
03:32:29 <dons> ah!
03:51:54 <edwardk> i seem to recall seth teller having a list of a bunch of words which were their own antonyms or something like that =)
03:52:26 <edwardk> http://people.csail.mit.edu/seth/misc/selfantonyms.html
03:52:30 <lambdabot> Title: Seth Teller's Self-Antonym / Janus Word / Contronym Page
03:56:04 <edwardk> cale: a number of those example lacked a '-less' morpheme, they were adopted to follow the '-less' suffix after the fact. a similar example is the word righteous, which used to be riht-wis, or 'right and wise' but was adapted to follow the -eous suffix like beauteous, etc. the morphology of engish is terrible ;)
03:57:09 <SamB> edwardk: boy, we couldn't spell in the old days!
03:57:30 <edwardk> samb: hehehe
03:57:57 <edwardk> the lyf so short, the crafte so longe to lerne ;)
03:59:06 <SamB> the dicteshionairy not yet rit...
03:59:10 <edwardk> hehehe
03:59:45 <xerox> Have you ever tried checking how small can you write if you try hard?
04:00:07 <SamB> well, I think it depends on the point of the writing tool
04:00:22 <SamB> for instance I can't write very small with a dull pencil
04:00:33 <xerox> You think?
04:00:37 <edwardk> xerox: heh. thats pretty much the definition of my handwriting, then i realized it was because i was getting nearsighted ;)
04:00:55 <SamB> okay, it does depend on that
04:01:13 <SamB> and I think my ability to think depends on my dose of adderall...
04:01:54 <SamB> hmm. so UMIX really does use a bunch of \n's to "clear the screen" at startup...
04:02:02 * edwardk nods.
04:02:15 <SamB> 0x32 of them, it looks like...
04:02:47 <edwardk> too bad they couldn't be bothered to define the terminal with more interesting screen clearing and cursor control and timing primitives... ;)
04:02:48 <xerox> haha
04:03:20 <SamB> you know, its awfully nice of them to make the account/password names remind you what is in the account...
04:03:30 <edwardk> heh
04:03:31 <SamB> "plinko", hehe
04:04:11 <edwardk> you know, the icfp contest this year was the final selling point on me going to the conference rather than waiting to read the papers after the fact ;)
04:04:30 <SamB> heh
04:04:50 <SamB> for some reason I want to do the blackknots puzzle...
04:07:00 <xerox> > 111111111 * 111111111
04:07:01 <lambdabot>  12345678987654321
04:07:12 <SamB> nice!
04:10:43 * SamB wonders what the best way is to keep from coming up with too many similar patterns...
04:10:49 <SamB> oh, well, I don't have time to do this now...
04:22:43 <SamB> hmm
04:22:55 <SamB> how come if I run getContents from ghci it returns right away?
04:23:11 <dons> something else has hold of stdin already?
04:23:16 <mux> I think it's because it reads lazily
04:23:25 <SamB> oh right
04:23:26 <SamB> ack.
04:23:31 <SamB> this can't be good!
04:23:38 <dons> oh, is it in 'it' ?
04:23:40 <int-e> it isn't :)
04:23:52 <dons> Prelude> getContents
04:23:52 <dons> "
04:23:52 <SamB> oh wait, if I run "length" on the result maybe I can do something...
04:23:54 <dons> blocks
04:24:11 <int-e> Prelude> getContents >>= print
04:24:12 <int-e> "ss;;kkjjffssaall;;kkjjssffaa
04:24:22 <int-e> note the double letters, that's unbuffered input for you :)
04:24:28 <SamB> oh ack
04:24:32 <SamB> ^D doesn't work
04:24:40 <int-e> ^C does, sort of
04:25:00 <int-e> after that, stdin is closed.
04:25:20 <mauke> POOL'S CLOSED
04:25:47 <SamB> hmm
04:26:08 <SamB> but that leaves me with an "Interrupted" in the middle of my String :-(
04:26:16 <SamB> ... and no end!
04:26:33 <dons> isn't readline going to be messing with stdin?
04:26:56 <SamB> dons: well, not while a computation is being waited on...
04:27:09 <SamB> readline is only used for the R in REPL
04:27:29 <SamB> of course, in Haskell the E and P are mixed together
04:47:15 <SamB> hmm, I wonder what I did with my glasses...
04:47:34 * SamB hopes he doesn't have too much trouble seeing the blackboard in class today...
04:48:22 <mux> SamB: eyes problems?
04:49:00 <SamB> I'm nearsighted
04:49:13 <mux> same here, badly
04:49:31 <mux> I can't even read the two huge letters at the top of the board without my glasses
04:49:35 <mux> Z and U, IIRC
04:49:46 <mux> you know, that board that opticians have
04:49:51 <SamB> oh, that one
04:50:08 <SamB> I'm not that bad, thankfully... at least, I don't think I am...
04:50:15 * SamB doesn't remember the board too well...
04:50:18 <mux> it's not tht much of a problem these days anyway
04:50:23 <mux> they make great lenses
04:50:26 <mux> slim and all
04:50:28 <SamB> anyway, I gotta run
04:50:31 <mux> cya
04:53:24 <vincenz> do all opticians have the same one?
04:53:26 <vincenz> or is it randomized
04:53:44 <mux> at least in france, all the ones I have seen have the exact same one
04:54:02 <mux> (all the opticians I have seen...)
05:14:41 <musasabi> Did edwardk package the type level number library?
05:17:01 <ell-hask> ?where paste
05:17:01 <lambdabot> http://paste.lisp.org/new/haskell
05:19:35 <lisppaste2> ell-hask pasted "instance of Num" at http://paste.lisp.org/display/24981
05:19:51 <ell-hask> Does anyone have an answer to a stupid instance problem?
05:20:51 <Lemmih> ell-hask: 'fromInteger a = DF (fromInteger a)'?
05:22:39 <ell-hask> Thanks, silly me
06:26:39 <apfelmus> how far is the Haskell' commitee?
06:27:06 <profmakx> exactly... 320 miles
06:27:07 <profmakx> an hour
06:31:45 <apfelmus> mh. a distance is measured between 2 points but i was more interested in the completion state of Haskell'
06:32:05 <musasabi> @seen edwardk
06:32:05 <lambdabot> I saw edwardk leaving #haskell 2 hours, 13 minutes and 50 seconds ago, and .
06:32:24 <profmakx> hmm
06:32:37 <profmakx> anyone with experience in writing papers in english?
06:37:25 <CosmicRay> If I add a new test to packages/unix/configure.ac, what controls how it gets into the global HsUnixConfig.h?
06:37:29 <CosmicRay> will it automatically happen?
07:14:16 <liyang> @index unsafeCoerce
07:14:16 <lambdabot> bzzt
07:18:42 <dons> ?index unsafeCoerce#
07:18:42 <lambdabot> bzzt
07:18:49 <dons> ?hoogle unsafeCoerce#
07:18:50 <lambdabot> Hoogle Error: Parse Error: Unexpected character '>'
07:18:55 <dons> *cough*
07:19:06 <dons> ?type GHC.Prim.unsafeCoerce#
07:19:07 <lambdabot> forall b a. a -> b
07:19:27 <dons> ?type GHC.Base.unsafeCoerce# -- maybe?
07:19:28 <lambdabot> forall b a. a -> b
07:19:30 <dons> ah yes
07:20:05 <mux> so many things I don't know yet in haskell :-(
07:20:35 <dons> unsafeCoerce# is the most evil of evils. enjoy!
07:21:15 * mux goes to look it up
07:21:21 <liyang> I'm not guilty. Honest guv.
07:21:24 <dons> the type says it all
07:21:30 <dons> ?djinn a -> b
07:21:31 <lambdabot> -- f cannot be realized.
07:21:35 <dons> ?free evil :: a -> b
07:21:36 <lambdabot> g . evil = evil . f
07:21:45 * mux wonders if someone already wrote a brainfuck interpreter in haskell
07:21:47 <dons> whihc tells you something.. :)
07:22:36 <mux> mmm, hoogle doesn't know about unsafeCoerce#?
07:22:40 <ricky_clarkson> How would you do an inline rot13?
07:22:46 <mux> sorry, it does
07:23:09 <mux> err, it doesn't o_O
07:23:19 <ricky_clarkson> I thought something like map do chr(ord)+13 "bushpx"
07:23:20 <paolino> hi has anyone access to acm or doi articles ?
07:23:30 <ricky_clarkson> Obviously plus bounding stuff.
07:23:31 <dons> ricky_clarkson: we've had it here a few times. check the logs?
07:23:35 <ricky_clarkson> s/bound/wrapp/
07:24:24 <mux> > map (\x -> chr(ord(x)+13)) "hello"
07:24:26 <lambdabot>  "uryy|"
07:25:33 <mux> mmm actually this isn't good
07:26:01 * mux <- lame
07:26:18 <ricky_clarkson> > map (\x -> chr((ord(x)-ord('a')+13)%26+ord('a'))) "bushpx"
07:26:19 <lambdabot>  Couldn't match `Ratio Int' against `Int'
07:26:37 <mux> > map (\x -> chr(ord(x)+13%26)) "hello"
07:26:37 <lambdabot>  Couldn't match `Int' against `Ratio a'
07:26:41 <mux> heh
07:26:50 <mux> > map (\x -> chr(ord(x)+13 `mod` 26)) "hello"
07:26:51 <lambdabot>  "uryy|"
07:27:02 <mux> > map (\x -> chr((ord(x)+13) `mod` 26)) "hello"
07:27:03 <lambdabot>  "\r\n\DC1\DC1\DC4"
07:27:05 <CosmicRay> Igloo: congrats on your ghc job
07:27:07 <mux> hmpf.
07:27:12 <profmakx> um mux
07:27:16 <ricky_clarkson> > map (\x -> chr((ord(x)-ord('a')+13) `mod` 26+ord('a'))) "bushpx"
07:27:16 <CosmicRay> Igloo: now I realize why you were answering my ghc release questions ;-)
07:27:17 <lambdabot>  "ohfuck"
07:27:17 <profmakx> a is not zero
07:27:17 <mux> this can't work
07:27:21 <ricky_clarkson> Got it. ;)
07:27:22 <mux> yeah I know.
07:27:37 <mux> nice
07:28:22 <dons> CosmicRay: heh!
07:28:34 * mux likes to do rot13 with g? in vim
07:29:06 <CosmicRay> BTW, I *really* like being able to use darcs to submit patches to ghc!
07:29:27 <dons> that's just weird, mux. what an odd feature
07:29:32 <mux> yeah
07:29:33 <dons> CosmicRay: me too!
07:29:40 <mux> and definitely useless
07:30:00 <dons> it makes fptools easier to play around with, don't you think?
07:30:06 <CosmicRay> yes.
07:30:15 <CosmicRay> I actually submitted some patches to the unix package yesterday
07:30:21 <CosmicRay> was pretty easy
07:30:22 <ndm> if only darcs on windows supported darcs send ...
07:30:27 <wolverian> mux, I think it is for newsgroups where rot13 has been used as a spoiler-hiding method, or something along those lines
07:30:29 <CosmicRay> ndm: I thought it did?
07:30:40 <ndm> and if only all the base libraries were in Cabal format, not crappy makefiles :(
07:30:42 <CosmicRay> dons: though compiling that package outside of ghc6.6 was not so easy ;-)
07:30:50 <CosmicRay> ndm: I thought most are now?
07:30:54 <ndm> CosmicRay: not really, it traditionally breaks
07:31:14 <ndm> CosmicRay: pretty much none, they might have a Cabal file but it certainly won't compile the code
07:31:29 * paolino wants to read "http://www.citeulike.org/user/ChaTo/article/349892" 
07:31:30 <lambdabot> Title: CiteULike: Trust Framework for P2P Networks Using Peer-Profile Based Anomaly Tec ...
07:31:42 <ndm> CosmicRay: Esa has patches that fix darcs send on Windows, but they haven't been taken for the main darcs tree :(
07:35:27 <mux> wolverian: among other things
07:35:38 <wolverian> mux, so it is not useless. :)
07:35:58 <mux> it's not because it is used (rarely) in newsgroups that it's cool to have in vim :-)
07:36:10 <mux> but anyways, I should have said "nearly useless"
07:37:06 <wolverian> I suppose ^L is the canonical method nowadays
07:37:40 <dons> I have a theory that acm et al should stop charing for papers, and instead distribute them for free. instead, they can make their $google bucks with targetted advertising
07:37:54 <dons> s/charging for papers/
07:38:09 <dons> shapr might like that
07:38:12 <ndm> dons: but do you have any idea what they charge universities?
07:38:20 <ndm> no way they will recoup that in google bucks
07:38:26 <dons> yeah, like $20k a subscription...
07:38:52 <johnnowak> ndm: they might if the ads are to get people to buy university subscriptions.
07:39:00 <dons> if the content is good, people will come. and the demographic would be pretty nice. imagine all the pocket protector companies queueing up to target readers ...
07:39:19 <ndm> of course, but still, thats a large amount ofmoney...
07:39:45 <ndm> although i guess they have to do something, to stop people just going to authors homepages
07:40:01 <dons> the whole system is a scam. authors who write, proof read and _type set_ their work, then hand copyright over to $publisher, who starts charging for it.
07:40:07 <dons> how'd we end up in this situation?
07:40:16 <ndm> its a broken system, but its the system we have :)
07:40:44 <ndm> but universities get money from funding bodies based on number of publications
07:40:47 <dons> i hope the haskell research papers wiki becomes a good resource
07:40:51 <johnnowak> dons: i can't see it holding out for too much longer
07:40:52 <dons> (and scholar.google.com helps too)
07:40:59 <ndm> so in effect, the university gets paid for that work
07:41:04 <ricky_clarkson> I find research papers hard to read.
07:41:12 <ndm> it just so happens that there is a publisher in the middle who makes a killing :)
07:41:16 <johnnowak> dons: If you think there is money to be made with such a service -- Why don't you do it?
07:41:33 <ndm> johnnowak: what you need is prestige - otherwise a publication means nothing
07:41:44 <ndm> although maths papers are now usually published on e-print first
07:41:47 <johnnowak> dons has prestige. ;)
07:41:50 <ndm> which is basically this kind of thing
07:41:52 <dons> well, i'd prefer to just put all the papers up and give them away (see haskell.org/haskellwiki/Research)
07:42:12 <ndm> whats the criteria for putting a paper on that page?
07:42:24 <dons> it uses the word haskell in it somewhere?
07:42:35 <ndm> i should put my paper on there then
07:42:46 <dons> yes!
07:43:21 <johnnowak> 'lleksah, and other words spelled backwards: a retrospective'
07:43:24 <dons> johnnowak: I think even without forcing the issue the edifice will come down. who goes to the publisher first anymore when there's citeseer/google?
07:43:34 <dons> johnnowak: heh
07:43:35 <johnnowak> dons: very true
07:44:21 <profmakx> well being at papers... is it usual to write "we" even if one writes a paper/thesis alone?
07:44:28 <dons> the publisher plays little part in the disemination of the work now -- the author sends out the mails, hosts the websites etc. so we should stop giving them copyright and free money
07:44:29 <profmakx> well, in english at least
07:44:43 <dons> profmakx: hmm. often yes.
07:44:51 <kzm_> profmakx, it is getting more common to use the singular, I think.
07:45:06 <ndm> ok, my paper is now added
07:45:07 <profmakx> because i am whipping up my dimploma-thesis
07:45:14 <profmakx> in english
07:45:23 <profmakx> and was wondering what is th "right thing to do"
07:45:35 <ndm> diploma-thesis should be I, not we
07:45:36 <kzm_> You can use 'we' as in you (the reader) and I.
07:45:38 <dons> i wish someone would send me all their clever content, along with the copyright, and i'll host it and charge for it. scam! </end rant>
07:46:00 <johnnowak> dons: google makes money off clever content without even hosting it :)
07:46:05 <dons> yeah
07:46:09 <profmakx> well i will just ask the prof what he thinks i should write
07:46:10 <ndm> dons: if as a result of this scam, you can persuade my uni to pay for a free holiday, i'll do that
07:46:15 <profmakx> or use
07:46:18 <profmakx> or whatever
07:46:44 <kzm_> profmakx, that's what professors are for, you know :-)  Good luck!
07:46:54 <kzm_> (with the thesis, that is)
07:47:01 <paolino> anyone got that article in the meanwhile ? :)
07:47:14 <dons> ndm, maybe they should just send authors to the beach, instead of a conference
07:47:24 <ndm> dons: suits me!
07:47:46 <ndm> although i do like hearing other people present their work
07:47:58 <profmakx> i´m in for the beach thing
07:48:40 <kzm_> ndm - I can tell you about my work on the beach if you like?  You bring the beer, and I'll bring the slides.
07:48:44 <dons> ndm, you could talk about your work at the beach. but don't mind if i go for a swim first
07:48:56 <dons> kzm, heh
07:49:06 <xerox> paolino!
07:49:40 <kzm_> (I finally got my neural network to calcuate boolean 'and'.  Probably not sufficient for a conference anyway :-)
07:49:46 <ndm> yeah, beer makes conferences more fun
07:49:56 <paolino> ola xerox
07:49:57 <ndm> (although vodka is a bad idea, i learnt that in estonia)
07:50:33 <edwinb> it's best to save the beer until after your own talk however ;)
07:50:53 <ndm> my talk was day 2 or 9 in estonia, so that was easy enough
07:51:00 <ndm> * 2 of 9
07:51:04 <edwinb> good planning
07:51:14 <kzm_> depends on the confidence/competence ratio, I think.  If it is very low, a few beers might help.
07:51:18 <paolino> xerox still on cabal-get ?
07:51:18 <ndm> talk at the preconference workshop, thats the solution
07:51:23 <xerox> paolino: yah
07:52:32 * dons `fmap` sleep
07:53:01 <ndm> not repeatM_ sleep ?
07:53:35 <mux> replicateM_ 3600 sleep
07:54:17 * paolino thinks copyrighted paper are a sad way to make money
07:55:36 <edwinb> There's nothing to stop authors putting their ACM published papers on their own web site...
07:55:40 <edwinb> it's a shame more don't...
07:55:56 <ndm> the only paper i've ever failed to find online was one by my own supervisor
07:56:16 <ndm> who had some paper copies in a filing cabinet, so that was ok
07:56:23 <jeroenp> \leave
07:57:12 <kowey> (extra-considerate users even put up their .tex/.bib to be blind-friendly)
07:59:25 <ndm> i have a .bib file for all my papers online
07:59:35 <CosmicRay> Anyone seen ghc6 fail to build with:
07:59:45 <CosmicRay> /usr/bin/ld: cannot find -lHSunix-1.0
07:59:45 <CosmicRay> collect2: ld returned 1 exit status
07:59:45 <CosmicRay> <<ghc: 16294964 bytes, 3 GCs, 185868/185868 avg/max bytes residency (1 samples), 15M in use, 0.00 INIT (0.00 elapsed), 0.02 MUT (0.20 elapsed), 0.02 GC (0.03 elapsed) :ghc>>
07:59:45 <CosmicRay> make[1]: *** [stage1/ghc-6.5] Error 1
07:59:45 <CosmicRay> make: *** [stage1] Error 1
08:11:42 * jeroenp pokes dblhelix
08:12:47 * dblhelix awakes form a daydream involving alpha-equivalence and shadowing
08:13:24 <dblhelix> jeroenp?
08:14:14 <jeroenp> Googled for `cartetische' lately :-)
08:14:54 * dblhelix googles
08:15:20 * dblhelix grins
08:15:37 <jeroenp> Maybe you could fix that :-)
08:16:04 <dblhelix> I should, I guess
08:16:22 <dblhelix> jeroenp: written any haskell code lately?
08:16:35 <jeroenp> Tried to do a mandelbrot-viewer
08:16:47 <dblhelix> wxHaskell based?
08:16:52 <jeroenp> Of course
08:17:01 <dblhelix> well...
08:17:36 <dblhelix> I'm going to try and find out whether I like Gtk2Hs better for teaching purposes
08:18:06 <jeroenp> Gtk2Hs? Interesting
08:20:35 <dblhelix> @where Gtk2Hs
08:20:35 <lambdabot> http://haskell.org/gtk2hs/
08:20:57 <jeroenp> The website looks fancier
08:21:16 <dblhelix> moreover, the projects seems to have more momentum
08:22:09 <jeroenp> ThereI haven't been wxHaskell updates since 2005 or so?
08:22:39 <dblhelix> jeroenp: no official ones, anyway
08:23:06 <frederik> jeroenp: dblhelix: hey ... I was looking for somebody to help me with a wxhaskell problem in here yesterday. Maybe you could help me?
08:23:07 <kowey> wxhaskell is coming back to life one day (there's about 5 of us actively working to make it happen)
08:23:18 <jeroenp> I could try
08:23:43 <frederik> jeroenp: do you know the CustomControl demo that's distributed with wxhaskell?
08:23:49 <dblhelix> kowey: I saw it on the mailing lists
08:23:55 <ndm> kowey: can i make a suggestion - your first task should be a windows binary for GHC 6.4.2 - thats the reason I've moved from wxHaskell to Gtk2hs
08:24:15 <dblhelix> kowey: any official releases to be expected before, say, January?
08:24:45 <jeroenp> dblhelix: don't you have one of those?
08:24:50 <kowey> ndm: thanks... though i suspect we'd release for three at the same time
08:25:18 <ndm> kowey: even if its an old version - or an interim release
08:25:32 <kowey> dblhelix: january sounds reasonable... (don't quote me on this) we've got a temporary darcs repo, need some testing for the unicode stuff
08:25:34 <ndm> kowey: but i'd do it soon, as at the moment windows users have little choice but to use gtk2hs
08:25:36 <dblhelix> ndm: besides from the availability of binaries, how would you value Gtk2Hs compared to wxHaskell?
08:26:02 <kowey> ndm: i'll point this out to the group, thanks
08:26:09 <ndm> dblhelix: i don't know enough to do wxHaskell vs Gtk2Hs, but I tend to prefer wxWidgets to GTK+
08:26:21 <dblhelix> jeroenp: no, for the course, I supplied 6.4.1 binaries
08:26:41 <jeroenp> Ah, my bad
08:26:51 <ndm> wxWidgets is a better fit with the OS than Gtk, hence my choice
08:27:08 <ndm> and I've seen loads of good wx apps, but never seen a good Gtk+ one :)
08:27:31 <frederik> ndm: dblhelix I looked through the papers about both and at the demos supplied and at least the way the layout is done seemed much nicer in wxhaskell ;)
08:28:02 <ndm> frederik: having used Glade, after a while it seems perfectly intuative, and then the layout issue is totally gone
08:28:22 <frederik> on the other hand, doing the layout manually (without using glade) seems to be discouraged by the gtk2hs authors anyway
08:28:28 * johnnowak finds gtk apps to be nicer than wxwindows apps
08:28:31 <frederik> hehe, right
08:28:56 <dblhelix> frederik, ndm: okay, thanks... I guess our preference goes to wxHaskell too... not in the last place since it orginated in utrecht... but still, for our course, we do not want to rely on a badly supported project
08:29:17 <ndm> johnnowak: as a windows user, its pretty much TortoiseCVS vs GIMP - and thats easy to call
08:29:33 <johnnowak> ndm: what about firefox?
08:29:49 <ndm> johnnowak: I'm a windows user, that doesn't use GTK on Windows
08:30:08 <dblhelix> using glade is not really an option for our course
08:30:10 <dylan> it doesn't look like GTK on linux, either
08:30:14 <johnnowak> well it does on linux and it works quite nicely :) -- it seems i missed the 'windows' bit of the conversation
08:30:42 <ndm> johnnowak: whenever talking to me, assume there is a little windows flag flying in front of my user name
08:30:51 <dblhelix> I guess I should at least get my hands dirty on Gtk2Hs sometime soon
08:31:01 <dblhelix> can't think of a suitable project to do so yet
08:31:06 <johnnowak> wxwindows apps on OS X are a bit of a pain. they look almost like mac apps, but behave nothing like them. i'd prefer something that looks totally different.
08:31:09 <johnnowak> ndm: noted :)
08:31:26 <dblhelix> there's not to much guis in type checkers :S
08:31:52 <ndm> dblhelix: on the contrary! I'd love a gui that let you explore type errors, by annotating each term with the type inferred
08:31:52 <johnnowak> dblhelix: doesn't ghc have a curses library? :)
08:32:39 <dblhelix> ndm: well, but that would be a bit too much for a small test project
08:33:07 <ndm> dblhelix: its on my list of things that i want, but would be totally incapable of doing (beacuse of the type side of things)
08:33:34 <dblhelix> ndm: however, I have thought of an editor that would show all kinds of feedback from program analyses attached to individual expressions
08:34:19 <dblhelix> ndm: I guess I'm not capable enough at the gui side... seems like we should join forces :)
08:34:51 <ndm> dblhelix: i'm probably not capable on the gui side either, sadly - but its definately a project that someone needs to do
08:35:28 <dblhelix> ndm: seems to me that hoogle is taking almost all of your time anyway, right?
08:35:40 <ndm> dblhelix: not at all, i'm spending much more time on my phd!
08:35:47 <ndm> (which is nothing to do with hoogle)
08:35:50 <ndm> @where catch
08:35:50 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
08:35:59 <ndm> thats sucking my time in at the mo
08:36:25 <ndm> hoogle is the little side project i try and squeeze a days hacking in on every few weeks
08:36:31 <frederik> ndm: oh, you've written hoogle? Is there any way I can search for an exact type?
08:36:32 * edwardk waves hello.
08:36:33 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
08:36:45 <dblhelix> ndm: reminds me that I was planning to ask you stuff about your phd track too...
08:36:59 <ndm> frederik: not yet, but i'm going to add it for hoogle 4
08:37:04 <dblhelix> ndm: but it's perhaps better to take that off line...
08:37:11 <edwardk> musasabi still around?
08:37:15 <edwardk> @seen musasabi
08:37:16 <lambdabot> musasabi is in #haskell-overflow, #haskell-blah and #haskell. I last heard musasabi speak 1 hour, 49 minutes and 23 seconds ago.
08:37:19 <frederik> ndm: ok, I was just expecting it to behave like that
08:37:27 <ndm> dblhelix: either email it, or hop into a private talk on irc, or haskell-overflow
08:37:31 <ndm> dblhelix: whatever suits you
08:37:33 <frederik> ndm: to search for the exact type
08:37:56 <ndm> frederik: Hoogle 1 did, it turns out that almost no one wanted that, and in practice its not that useful
08:38:11 <ndm> Hoogle 2 did unification, and that turns out not to be that useful either
08:38:27 <ndm> Hoogle 3 did edit distance, which is respectable, but sometimes surprising
08:38:40 <frederik> hehe
08:38:45 <ndm> Hoogle 4 does wrap/unwrap model, which is hopefully going to be the final one
08:38:47 <dblhelix> ndm: is it right that you've focused more on the pattern matching thing than on the terminating checking up till now?
08:38:59 <ndm> dblhelix: almost entirely
08:39:07 <ndm> have hardly touched termination
08:39:27 <ndm> but the method i have developed occasionally solves termination problems "for free"
08:39:34 <ndm> for example, map head (reverse x)
08:39:35 <dblhelix> well, it's mostly the termination part that I'm interested in for the next year or so...
08:39:51 <ndm> will infer that either x.tl*.hd{:}, or x.tl*{:}
08:40:00 <ndm> i.e., either its safe or non-terminating
08:40:21 <ndm> and i am working on how to exploit this
08:40:41 <ndm> i think by changing a \forall to an \exists in the semantics, it might just solve termination
08:41:05 <ndm> but there are a couple of issues that are minor for pattern matching, but then become critical for termination
08:41:14 <musasabi> edwardk: pong
08:41:15 <lambdabot> musasabi: You have 1 new message. '/msg lambdabot @messages' to read it.
08:41:22 <ndm> so am trying to solve them in the pattern match sense, before trying to filp the switch to terminatino
08:41:29 <dblhelix> ndm: I see...
08:42:54 <ndm> dblhelix: whats your particular interest in termination?
08:43:18 <ndm> my terminatino focus is on termination in a lazy language - so determining terminatino in the presence of functions like repeat#
08:43:35 <dblhelix> ndm: I'll send you an e-mail later this week or so, right? I'll explain a bit what we've been up to and planning to do with respect to termination analysis and perhaps we could benefit from each other's work in some way...
08:43:57 <ndm> dblhelix: cool, will look forward to it
08:44:16 <dblhelix> ndm: basically, I want to ensure termination of a partial evaluator... joining the results of binding-time analysis and termination analysis...
08:44:48 <dblhelix> nbm: but perhaps termination analysis per se is interesting for us too
08:45:03 <dblhelix> jeroenp: planning to take the grammars and parsing course this year?
08:45:05 <musasabi> edwardk: src/Type/Binary/Internals.hs does not compile either.
08:45:16 <edwardk> ok, now something is strange =)
08:45:30 <edwardk> that works fine here on 6.5
08:45:36 <edwardk> whats the error?
08:45:47 <musasabi> edwardk: is the public repository and your repository in sync?
08:45:58 <edwardk> the public repository is my working dir
08:45:59 <edwardk> =)
08:46:09 <musasabi> src/Type/Binary/Internals.hs:314:10: Not in scope: type constructor or class `IsNegative'
08:46:17 <musasabi> might be just a typo
08:46:22 <edwardk> checking
08:46:38 <musasabi> changing that to TIsNegative just results in further errors.
08:46:51 <edwardk> no, it should find IsNegative in Type.Sign
08:46:57 <edwardk> did i not include Type.Sign in the package?
08:47:07 <edwardk> thats possible
08:47:25 <musasabi> Namely should TReverse' have two or three arguments.
08:47:47 <musasabi> e.g. instance (TIsNegative a b, TReverse' a b c, TNF c c') => TReverse' a c'
08:47:54 <edwardk> lemme go look and see whats up. its been a while since i thought about this thing, but i thought i left it in a working state
08:48:20 <jeroenp> dblhelix: naturally :)
08:48:31 <dblhelix> jeroenp: good :
08:48:37 <jeroenp> I've been looking forward to it since completing the FP-course
08:49:05 <dblhelix> jeroenp: who's teaching the course? bastiaan?
08:49:18 <jeroenp> I think so, they changed it from Fokker to Bastiaan
08:49:23 <edwardk> ok, i must have fuxxored things a patch or two back, checking what i did
08:49:39 <jeroenp> A pity, now I'll probably never be able to take a Fokker-course
08:50:14 <dblhelix> jeroenp: haven't you followed Imperative Programming when he was teaching it?
08:50:45 <jeroenp> No, didn't think about subscribing to it untill it was too late
08:50:58 <dblhelix> jeroenp: ah, too bad...
08:51:04 <dblhelix> well...
08:51:15 * dblhelix is off to his theorems and lemmas again...
08:51:25 <edwardk> ok, the TReverse stuff is screwed up. commenting it out works
08:51:35 <edwardk> it was part of my starting to write TDivMod
08:51:44 <jeroenp> dblhelix: How is your research going?
08:51:54 <edwardk> then i got distracted. i committed a change someone else asked for and it got dragged in coz i was sloppy
08:52:35 <edwardk> try pulling the current version from the repository
08:52:40 <dblhelix> jeroenp: it slowed down a bit, because of a broken finger and students willing to finish their master's thesis projects before sept 1st
08:52:42 <edwardk> should have a couple of trivial patches to stop the errors
08:53:20 <dblhelix> jeroenp: and it will probably slow down again because of teaching duties in the first period...
08:53:26 <jeroenp> And I heared you're supervising imperative programming?
08:54:03 <dblhelix> jeroenp: yeah, but more passively than I did for Functional Programming...
08:54:32 <jeroenp> Why did they assign a ST-phd to imp?
08:54:37 <dblhelix> jeroenp: just help out at the lab sessions and the exercises... no organizational duties or anything
08:54:56 <dblhelix> jeroenp: well, IMP is organized by the ST group...
08:55:06 <jeroenp> That explains a lot
08:55:45 <dblhelix> jeroenp: just because most of us are fp guys, doesn't mean that imperative programming isn't a software technology thing...
08:56:03 <jeroenp> Almost forgot :-)
08:56:22 <jeroenp> dblhelix: is there someone working on the new FP-syllabus? I'd like to see it, if possible
08:56:38 <dsacode> Hello! I wrote function that removes duplicates items from list, but some guy said me that I can write "rd" function with 2 sentences, not 3 as I do.. Can someone give me advice or something.. Here's the code: http://paste.lisp.org/display/24992
08:56:40 <dblhelix> jeroenp: but I will probably also supervise a FOSA project... so I'll be rather busy...
08:56:58 <vincenz> dsacode: what does dsa stand for?
08:57:06 <dblhelix> jeroenp: I'm working on it... as a side project... it'll probably not be ready for this year's course...
08:57:13 <dsacode> vincenz, do you care? :)
08:57:21 <vincenz> dsacode: yes
08:57:23 <edwardk> > nub [1,2,1,1,1,23,4,5]
08:57:28 <lambdabot>  [1,2,23,4,5]
08:57:36 <vincenz> dsacode: dynamic single assignment?
08:57:49 <dsacode> edwardk, it removes duplicate items that sits near..
08:57:50 <dblhelix> jeroenp: but I'm happy to send you a draft chapter every now and then... perhaps you're willing to proofread some of those?
08:57:54 <dsacode> vincenz, actually i don't know )
08:58:00 <jeroenp> I'd like to, dblhelix
08:58:03 <vincenz> dsacode: ah was just curious if it was that acronym :)
08:58:29 <jeroenp> I'm curious, and eager to know what things will change in the new version
08:59:05 <jeroenp> Personally I hope you're going to handle classes sooner than you did this year, they were handy in the first assignment but we didn't know about them until the last
08:59:20 <ndm> dsacode: why not: rd x (l:ls) | x == l = l:ls   ; rd x ls = x:ls
08:59:21 <vincenz> jeroenp: type classes?
08:59:26 <dblhelix> jeroenp: well, the notes we use now have been with us for almost almost ten years now... so some of the stuff that's in it, is really outdated... that's my main concern...
08:59:30 <ndm> dsacode: shorter by 2 lines :)
08:59:57 <dsacode> ndm, nice :)
09:00:21 <musasabi> edwardk: what email address do you prefer? (fixed some things)
09:00:30 <edwardk> musasabi: ekmett@gmail.com
09:00:42 <edwardk> what was busted?
09:00:45 <ndm> dsacode: i'm also not sure about laziness - is your function lazy?
09:00:50 <sjanssen> > foldr (\x xs -> x : filter (==x) xs) [] [1, 1, 3, 1, 3]
09:00:52 <lambdabot>  [1,1]
09:00:54 <musasabi> edwardk: cabal file + some import typos
09:01:00 <edwardk> ah
09:01:10 <edwardk> first crack at doing a cabal file =)
09:01:11 <ndm> i.e. will head (remdups (repeat 1)) == 1 ?
09:01:20 <musasabi> the second patch is entirely optional, the first one good.
09:01:24 * edwardk nods.
09:01:27 <ndm> i'd have done it with explicit recursion, but foldr is usually a better style
09:01:32 <edwardk> i'll throw em both in i'm sure.
09:01:46 <sjanssen> > foldr (\x xs -> x : filter (==x) xs) [] $ repeat 1
09:01:47 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
09:02:09 <dsacode> sjanssen, for [1,1,3,1,3] output must look like [1,3,1,3]
09:02:10 <sjanssen> > foldr (\x xs -> x : filter (/=x) xs) [] $ repeat 1
09:02:12 <lambdabot>  Exception: stack overflow
09:02:22 <sjanssen> dsacode: yeah, I had a typo
09:02:38 <sjanssen> oh, I see
09:02:53 <ndm> f (x:xs) = x : f (dropWhile (== x) xs)
09:02:56 <ndm> f [] = []
09:03:02 <ndm> that looks nice enough to me, and very simple
09:03:04 <ndm> and lazy
09:03:05 * dblhelix really has to go now...
09:03:30 <dblhelix> see you, guys... (and Philippa, of course)
09:03:43 <ndm> dblhelix: bye, look forward to that email :)
09:03:53 <sjanssen> @pl foldr (\x xs -> x : dropWhile (==x) xs)
09:03:54 <lambdabot> foldr (liftM2 (.) (:) (dropWhile . (==)))
09:06:18 <jeroenp> foldr (\x -> (:) x . filter (not . (x ==))) []
09:06:18 <Marudubshinki> question, folks: So I'm reading Lambda the Ultimate, and I come across the acronym GADT, which obviously stands for "Generalized Algebraic Data Type". No definition is given there (no surprise), so I go to Wikipedia, and I find [[Algebraic data type]] (http://en.wikipedia.org/wiki/Algebraic_data_type), which *seems* to be what I'm looking for, but I'm not certain since it never mentions GADTs. Are algebraic data types = GADTs?
09:06:45 <jrmole> http://hackage.haskell.org/trac/haskell-prime/wiki/GADTs
09:06:47 <lambdabot> Title: GADTs - Haskell Prime - Trac
09:08:18 <jeroenp> Is there a standard haskell-function for S := \f g x. (f x) (g x)
09:08:21 <jrmole> and http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html
09:08:23 <lambdabot> Title: 7.5. Generalised Algebraic Data Types
09:08:39 <jrmole> @pl \f g x -> (f x) (g x)
09:08:40 <lambdabot> ap
09:08:40 <Marudubshinki> jrmole: if I'm understanding that correctly, no? GADTs take varying arguments whereas ADTs might not?
09:08:42 <sjanssen> @pl s f g x = (f x) (g x)
09:08:42 <lambdabot> s = ap
09:09:14 <Marudubshinki> jrmole: thanks for that second link. answers me question
09:09:18 <ndm> Marudubshinki: GADT's is like ADT's (the wikipedia definition) on type steroids
09:09:41 <sjanssen> Marudubshinki: GADT's can have existentially quantified type variables
09:09:45 <Marudubshinki> ndm: sounds like the article needs some revising... :( oy vey
09:09:51 <jrmole> that's not the only distinction though
09:10:02 <Marudubshinki> jrmole: ? not just varying arguments?
09:10:10 <jrmole> not just existential quantification
09:10:15 <ndm> Marudubshinki: no, ADT's are what haskell 98 supports, the wikipeida article is correct - GADT /= ADT
09:10:24 <ndm> GHC added GADT's
09:10:31 <sjanssen> Marudubshinki: standard ADTs can have varying arguments
09:10:51 <jeroenp> jrmole: what does lambdabot mean by ap?
09:10:59 <jrmole> it's a builtin function
09:11:02 <sjanssen> @type ap
09:11:04 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
09:11:28 <jrmole> is that the ((->) r) monad?
09:11:44 <jeroenp> Can I use that in the GHC-prelude?
09:11:58 <jrmole> import Control.Monad
09:12:10 <jrmole> but beware, not many people will recognize it as the S combinator
09:12:14 * Marudubshinki is confused now. so GADTs are a GHC extension, and ADTs are part of Haskell, and they are similar except that GADTs are "existentially quantified"
09:12:15 <sjanssen> you might have to import Control.Monad.Reader as well
09:12:23 <jrmole> you may be better off just putting s x y z = (x z) (y z) somewhere
09:12:49 <jrmole> Marudubshinki, the distinction is not existential quantification only
09:13:07 <Marudubshinki> jrmole: what else is there?
09:13:29 <ndm> Marudubshinki: Haskell 98 = ADT, GHC = both ADT and GADT, GADT is a generalisation of ADT
09:14:07 <Marudubshinki> ndm: yes, I got that: I was asking jrmole how GADT extends ADT besides the existential bit
09:14:12 <jrmole> the type signatures of the constructors are more general
09:14:39 <jrmole> with regular ADTs, say you define data Foo a b c = ConstA a b | ConstB b c
09:15:02 <jrmole> so the constructors are of type ConstA :: a -> b -> Foo a b c and ConstB :: b -> c -> Foo a b c
09:15:23 <Marudubshinki> right...
09:15:23 <jrmole> with GADTs you can get more general constructors, including ones that take Foos and return them too
09:15:30 <jrmole> i can't explain this very well though
09:15:35 <jrmole> plus i have to go now... someone else?
09:18:44 <swiert> Marudubshinki: you might want to google "indexed families" - that's how GADTs are known in the type theory community.
09:19:54 <swiert> The big difference is that where in an ADT all constructors of a data type take recursive arguments of the same type.
09:21:15 <Marudubshinki> GADTs don't take recursive arguments?
09:21:31 <Marudubshinki> or rather allow different types, I guess you meant
09:22:36 <swiert> Exactly - they allow you to instantiate recursive arguments or return a more specific type.
09:22:50 <swiert> http://www.haskell.org/haskellwiki/GADT
09:22:51 <lambdabot> Title: Generalised algebraic datatype - HaskellWiki
09:23:04 <swiert> has some pretty good examples.
09:23:12 <Marudubshinki> swiert: I think I understand now. better go read the various links you guys've given me.
09:29:38 <musasabi> polymorphism + serialization = evil++ :-(
09:33:10 <musasabi> "data F a where F :: C1 a => Proxy a -> F Int" equal to "data G a where G :: C2 => Proxy b -> G Int"
09:48:04 <scriptdevil> hmmm... i was reading the hitchhikers guide.. it says main = do input <- getContents putStrLn ("DEBUG: got input " ++ input)
09:48:24 <scriptdevil> but the same code run says do must end in an expression
09:49:24 <ndm> scriptdevil: do you haev a newline in there anywhere?
09:49:55 <ndm> scriptdevil: Haskell uses newlines and indentation for structure, if you put it all on one line then that does soemthing different
09:50:13 <scriptdevil> ndm: i applied the indentation
09:50:38 <ndm> scriptdevil: do you have it entirely done with spaces - no tabs?
09:50:52 <ndm> scriptdevil: if so, can you paste your code into the paste bin
09:50:54 <ndm> @where paste
09:50:54 <lambdabot> http://paste.lisp.org/new/haskell
09:51:04 <scriptdevil> ndm i use vim i set tabs to 4 spaces
09:51:20 <ndm> scriptdevil: haskell uses 8 spaces = tab
09:51:29 <ndm> use all spaces for your indentation
09:51:45 <ndm> or get vim to convert tabs to spaces
09:52:03 <ndm> or:
09:52:20 <scriptdevil> set tabstp=8
09:52:27 <ndm> main = do
09:52:29 <ndm>    input <- getContents
09:52:31 <ndm>    putStrLn ("DEBUG: got input " ++ input)
09:52:51 <ndm> changing the style of indentation, so as long as inptu and putStrLn align, it works, regardless of yoru tab stops
09:54:04 <scriptdevil> ndm that was refreshing thanks
09:54:16 <scriptdevil> it worked when i brought input down
09:54:40 <ndm> scriptdevil: no probs, i personally use tabs=4 spaces, and get my editor to replace tab with 4 spaces, and that usually gets everything working fine
09:54:59 <scriptdevil> i have decided to move to haskell to see how pure functional lang
09:55:07 <scriptdevil> ndm: btw which editor?
09:55:22 <ndm> scriptdevil: TextPad on Windows
09:56:03 <scriptdevil> oh... windows... i have it installed.. but only for prince of persia.. never mind.. it is the programmer not the OS that is worthy. thanks for ur help
09:56:06 <dylan> I make tabs look like 4 spaces, but remain tabs, and spaces are a really ugly shade of red when at the beginning of a line.
09:56:32 * scriptdevil is listening to "PetShop Boys -Its a Sin.mp3"
09:56:46 <dylan> Now if only I could teach vim to auto-indent haskell properly...
09:56:54 <scriptdevil> dylan: i want that too..
09:57:31 <scriptdevil> emacs is absolutely stubborn.. i hate that too.. for me vim = emacs + modes. emacs = vim + OS :P
09:58:00 <scriptdevil> stubborn means i cant use more than one tab even if i want to..
09:58:16 <dylan> heh
10:00:02 <scriptdevil> isnt indent/haskell.vim worth modiying? i will try once i learn haskell at least to a  modest level. as one programmer said.. if i master a programming language i'll give up programming
10:01:39 <scriptdevil> gn.. tc .. it is 11 pm in india.///
10:05:27 <profmakx> @yow!
10:05:28 <lambdabot> I put aside my copy of "BOWLING WORLD" and think about GUN CONTROL
10:05:28 <lambdabot> legislation..
10:09:18 <xerox> > let emacs = vim ++ "OS"; vim = emacs ++ "modes" in compare emacs vim
10:09:20 <lambdabot>  Exception: <<loop>>
10:09:23 <xerox> Your definitions are incomparable.
10:09:35 <xerox> Oh he has gone.
10:12:05 <ventonegro> i've just written a factorial and a fibonacci functions
10:12:24 <xerox> ?karma+ ventonegro
10:12:25 <lambdabot> ventonegro's karma raised to 1.
10:12:30 <ventonegro> the factorial is almost instantaneous (!), but fibonacci isn't
10:12:42 <xerox> It really depends on how are you computing it.
10:12:44 <ventonegro> is it because of the tail call?
10:14:19 <ventonegro> the output of ((fact . fib) 6) is impressive :-)
10:14:28 <ventonegro> ops, ((fact . fib) 20)
10:16:18 <ndm> ventonegro: paste your definitino of fib
10:16:21 <ndm> @where paste
10:16:22 <lambdabot> http://paste.lisp.org/new/haskell
10:17:31 <lisppaste2> ventonegro pasted "fibonacci" at http://paste.lisp.org/display/24998
10:18:13 <ndm> ventonegro: your fib is O(n^2)
10:18:52 <ndm> if you compute fib 12, it will compute both fib 11 (which computes fib 10 as well) and fib 10
10:18:58 <ndm> hence fib 10 is done twice
10:18:59 <ventonegro> maybe i should memoize the results?
10:19:05 <ndm> and fib 3 will be done 100's of times
10:19:30 <ndm> ventonegro: thats one option, but its much easier just to fix your definition of fib
10:19:44 <ventonegro> how so? :-)
10:19:53 <ventonegro> (my second day of haskell)
10:20:06 <vegai> not easier if you don't know the better algorithm
10:20:15 <Eidolos> ndm: Doesn't Haskell memoize this kind of thing?
10:20:28 <ndm> Eidolos: it only memorises CAF's, things with no arguments
10:20:42 <Eidolos> Oh.. hell even Perl does that. :(
10:21:15 <ndm> Eidolos: really?
10:21:24 <ndm> ventonegro: i'm just googling for it
10:21:40 <Eidolos> Yeah, it's a part of the constant folding. If it looks like your function will always return the same value, it'll just replace all calls to that function with its value.
10:22:09 <lament> go Perl!!!
10:22:11 <vincenz> > let fact 0 = 1; fact n = n * fact (n-1); fib n = let fibs = 1:1:zipWith (+) fibs (tail fibs) in head . drop n $ fibs in fact . fib $ 20
10:22:15 <lambdabot>  2096090140811497052267340710650854818831710724225628569550628618284275427803...
10:22:17 <Eidolos> (that's probably the most popular way to get genuine constants in Perl: sub PI {3.14159265358979})
10:22:20 <ndm> Eidolos: with fib?
10:22:27 <Eidolos> Oh, no, not fib.
10:22:30 <ventonegro> Eidolos: but the function can not use a global, then
10:22:35 <ndm> Haskell does that, but at a much much more powerful form
10:22:41 <ndm> it does arbitrary inlinnig
10:22:42 <lament> Eidolos: ouch, ugly.
10:22:44 <ndm> thanks to lazy evaluation
10:22:52 <Eidolos> lament: Perl6 gets constants. *shrug*
10:23:00 <lament> Eidolos: that's the problem with Perl, all the cool stuff it has gets used in very ugly ways
10:23:13 <ventonegro> vincenz: damn, i cannot understand that line yet
10:23:19 <Eidolos> There are also a few modules (perhaps one even in the core distro) that lets you define a variable as constant. But that's neither here nor there: back to Haskell. x_x
10:23:31 <vincenz> ventonegro: first two parts are just your fact
10:23:47 <ventonegro> vincenz: this i understood
10:24:12 <ventonegro> what does '$' do?
10:24:26 <vincenz> > let double x = x * x in double $ 2
10:24:27 <lambdabot>  4
10:24:45 <vincenz> f (g x) = f $ g x  = f . g $ x
10:24:51 <vincenz> = f $ g $ x
10:25:19 <lament> let double x = x * x in double 2
10:25:28 <lament> > let double x = x * x in double 2
10:25:29 <lambdabot>  4
10:25:35 <xerox> > join (*) 2
10:25:36 <lambdabot>  4
10:25:45 <ventonegro> sorry, it's not clear yet
10:25:50 <ventonegro> function application?
10:26:21 <vegai> $ is the anti-lisp operator
10:26:22 <xerox> '$' is function application yes
10:26:37 <xerox> You can think of '$' as a '(', and add a ')' at the end of the line, mentally.
10:26:46 <ventonegro> ah, ok
10:26:50 <ventonegro> thanks
10:26:54 <xerox> You're welcome.
10:28:00 <ventonegro> show $ fact . fib $ 20
10:28:02 <ventonegro> cool
10:30:47 <xerox> :D
10:30:58 <vincenz> anti-lisp
10:30:59 <vincenz> lol
10:31:49 <vincenz> ventonegro: then this part
10:32:00 <vincenz> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs
10:32:01 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
10:32:25 <ventonegro> ok, let me see
10:32:35 <ventonegro> a list that begins with 2 1's
10:32:38 <vincenz> yes
10:33:11 <ventonegro> what does zipWith do?
10:33:23 <xerox> zip = zipWith (,)
10:33:30 <vincenz> zipWith takes two lists
10:33:32 <vincenz> and gives one list back
10:33:42 <vincenz> taking elements in apirs and applying the function
10:33:42 <xerox> > let evens = map (+1) odds; odds = 1 : map (+1) evens in zip odds evens
10:33:43 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21,...
10:33:59 <vincenz> > let ones = 1:ones in zipWith (+) ones ones
10:34:00 <lambdabot>  [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2...
10:34:02 <ventonegro> i see, you "displace" the second list by one position with tail
10:34:07 <vincenz> yep
10:34:12 <ventonegro> and the  sum both
10:34:16 <ventonegro> interesting
10:34:16 <xerox> :D
10:34:33 <vincenz> it's an infinitely long list
10:35:07 <ventonegro> but since haskell is lazy it only counts until it has the answer
10:35:19 <vincenz> well only until you actually demand the data
10:35:42 <ventonegro> i see
10:36:06 <vincenz> anyways
10:36:12 <vincenz> the last part is (though not mathematically correct
10:36:23 <vincenz> head . drop n $ fibs
10:36:29 <vincenz> drop the first n elements
10:36:32 <vincenz> and then take the head
10:36:36 <lament> mm
10:36:46 <lament> what's wrong with this?
10:36:52 <vincenz> that's not the nth element
10:36:56 <vincenz> but the n+1th element
10:37:03 <lament> > let blah = 1 : zipWith (+) blah (tail blah) in blah
10:37:04 <lambdabot>  Exception: <<loop>>
10:37:18 <vincenz> lament: not possible
10:37:18 <lament> oh
10:37:22 <lament> need two elements, bah
10:37:23 <vincenz> the second element depends on itself
10:37:30 <lament> > let blah = 1 : 2 : zipWith (+) blah (tail blah) in blah
10:37:31 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
10:37:38 <lament> boring
10:37:55 <vincenz> yeah
10:37:59 <vincenz> haskell is extremely boring
10:38:25 <lament> :(
10:38:41 * vincenz was being sarcastic
10:38:45 <norpan> endless fibonacci masturbation is boring
10:38:55 <vincenz> yeah, it's a good way to show a newb some code tho
10:39:05 <ventonegro> yep!
10:39:07 <norpan> sure
10:39:24 <vincenz> it's probably the most oft-quoted piece of haskell code :D
10:39:49 <lament> of course
10:39:53 <lament> it's all haskell is good for :)
10:40:07 <ventonegro> it's because factorial is so easy that nobody can screw it
10:40:43 <vincenz> heh
10:41:28 <ventonegro> what do you guys use haskell most for? math?
10:41:38 <norpan> > fix((1:).(1:).ap(zipWith(+))tail)
10:41:39 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
10:41:41 <vincenz> I use it for tool development
10:41:48 <norpan> there you go, newbies
10:42:05 <xerox> norpan is bullying!
10:42:06 <vincenz> norpan: no ap!
10:42:15 <norpan> ap is considered harmful?
10:42:20 <xerox> No!
10:42:23 <vincenz> it is until monads are comfortable
10:42:29 <vincenz> @type ap
10:42:31 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
10:48:20 <vincenz> @type scanl
10:48:22 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
10:48:33 <vincenz> > scanl (*) 1 [1..]
10:48:36 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
10:49:03 <vincenz> > let fac n = head . drop n $ scanl (*) 1 [1..] in fac 5
10:49:04 <lambdabot>  120
10:49:08 <norpan> just say ap :: (a -> b -> c) -> (a -> b) -> a -> c
10:49:30 <norpan> no monads needed
10:50:25 <vincenz> > scanl (*) 1 $ scanl (*) 1 [1..]
10:50:26 <lambdabot>  [1,1,1,2,12,288,34560,24883200,125411328000,5056584744960000,183493347225108...
10:51:07 <vincenz> > drop 1 . scanl (*) 1 . drop 1 . scanl (*) 1 . drop 1 . scanl (*) 1 $[1..]
10:51:08 <lambdabot>  [1,2,24,6912,238878720,5944066965504000,745453331864786829312000000,37694479...
10:51:18 <norpan> @djinn (a -> b -> c) -> (a -> b) -> a -> c
10:51:18 <lambdabot> f a b c = a c (b c)
10:51:23 <norpan> hey, good djinn
10:51:38 <xerox> ap
10:51:44 <vincenz> petito
10:51:47 <xerox> lol
10:51:53 <xerox> G'day Maddas.
10:52:03 <Maddas> yow!
10:52:17 <xerox> ?. pl djinn (a -> b -> c) -> (a -> b) -> a -> c
10:52:17 <lambdabot> f = ap
10:52:20 <xerox> See.
10:52:40 <norpan> yeah, what i said: ap
10:52:40 * xerox sees (dead?) patterns
10:52:47 <norpan> or S combinator if you're in that mood
10:53:04 <xerox> Oh I missed that.
10:54:12 <vatic42> I have a question, if someone wouldn't mind helping.  What is the most stable 6.5 build to play around with?
10:55:19 <musasabi> take the most recent one.
10:55:45 <musasabi> so you will have new and exciting bugs instead of old boring bugs.
10:55:58 <vatic42> Haha.  Is it very buggy?
10:56:27 <ndm> vatic42: if you don't want to trouble shoot bugs then 6.4.2 is the way to go
10:56:29 <musasabi> works for most of my code.
10:57:03 <musasabi> but panics on somethings depending on the version.
10:57:45 <vatic42> I don't really want to trouble shoot bugs, because I'm still learning.  I did want to play around with the SMP capabilities, though, which aren't in 6.4.2.
10:58:26 <jrmole> is haskell-cafe@ appropriate for asking a show of interest in a potential project?
10:59:01 <musasabi> vatic42: usually the bugs are in the form of the compiler dying, so you can try it for your source and see how it works.
10:59:17 <musasabi> vatic42: the most experimental things are on branches and not in HEAD>
10:59:42 <vatic42> Heh, ok.  Thanks.
10:59:50 <ndm> jrmole: yep
10:59:54 <ndm> jrmole: what project?
11:00:06 <jrmole> the yhc/L4 thing i was talking about yesterday
11:00:27 <ndm> jrmole: you might want to ask on the Yhc mailing list first, seem if its tecehnically feasible
11:00:50 <ndm> jrmole: see if anyone can point you at anything, then armed with a bit more knowledge of what it entails, then ask on haskell-cafe
11:01:00 <jrmole> okay
11:01:34 <jrmole> i've been reading yhi code, and it looks doable
11:01:39 <jrmole> code and docs i should say
11:01:47 <ndm> jrmole: you might want to cc Guillaume FORTAINE
11:01:57 <ndm> he was asking OS/Yhc questions a few days ago
11:02:08 <ndm> guillaume_dot_fortaine_at_wanadoo_dot_fr
11:02:39 <jrmole> yeah, i've talked to him already, though not in the context of yhc
11:02:57 <ndm> neat, looks like you could do good things with that :)
11:03:44 <vincenz> jrmole: what's the plan?
11:04:11 <jrmole> hmm, it's very half-baked currently :)
11:04:24 <jrmole> this is why i want feedback from people more experienced than i
11:04:46 <jrmole> but the basic plan is to port yhi to run on top of L4 directly
11:05:04 <jrmole> replace the IO monad builtins with a L4 monad, giving access to L4 IPC in haskell
11:06:05 <ndm> that sounds cool
11:06:19 <ndm> the big thing is whether you need to replace the IO Monad at compile time, or only at runtime
11:06:28 <ndm> i.e. would you need a specialised prelude
11:06:34 <ndm> i suspect not, but not entirely sure
11:06:53 <jrmole> then eventually we can implement the IO monad (or much better, a TypedIO monad) on top of that, by talking to L4 filesystem servers and such
11:07:55 <jrmole> do you know if yhc can be modified so processes don't share the same heap?
11:08:13 <jrmole> it would be nice (maybe vital) for each haskell thread to be a different L4 process
11:08:48 <benmos> Hi all. I have a quick question about basic use of Reader / ReaderT...
11:08:49 <jrmole> we can probably emulate shared heap by doing IPC on page faults, anyway
11:09:19 <ndm> not sure about heap things - yhi has a unique heap for each process, since its invoked separately for each program
11:09:33 <ndm> if you share yhi instances, then you should be able to separate the heaps quite easily
11:10:48 <kolmodin> will Koen Claessen and John Huges newest QuickCheck (that one with shrink :: a -> [a]) make it to GHC 6.6?
11:11:18 <jrmole> "This is rather than using one OS thread per Haskell process because all processes can access the global heap, so if using OS threads it would be necessary to either lock every heap access (incredibly slow) or use some of the truely nasty tricks that concurrent GHC uses."
11:12:31 <vincenz> what's L4?
11:12:36 <jrmole> a microkernel architecture
11:13:01 <jrmole> basically allows you to request memory pages from other processes, and send messages
11:13:02 <jrmole> and that's it
11:13:10 <vincenz> ah
11:13:45 <jrmole> as i understand, the only code running at ring 0 is the task switcher (not even the scheduler) and the code that updates the pagetable
11:13:49 <ndm> jrmole: thats only for threads, which need to share a global heap - if each process doesn't need a global heap you don't need locks
11:14:05 <jrmole> right... i'm not sure i want this thread/process distinction though
11:14:07 <jrmole> but L4 has it, even
11:14:15 <jrmole> so i guess it's reasonable
11:14:19 <ndm> typically threads access the same heap, processes don't
11:14:31 <ndm> with Yhc it would be a pain to remove, because of teh way its designed
11:14:37 <jrmole> *nod*
11:14:45 <ndm> since a thread isn't all that concurrent, unless you fire off FFI
11:15:10 <jrmole> i will think about it
11:15:39 <jrmole> anyway, thanks, bbl
11:15:48 <ndm> cool, good luck
11:26:44 <emu> do people have trouble when using indent-region on haskell code, or is there some trick to it
11:30:19 <musasabi> What is the nicest way of getting PGP support into a BSD licensed library? OpenPGP SDK, BPG, or something entirely else?
11:30:28 <musasabi> and wrong channel.
11:30:52 <lament> at least you weren't asking about gay sex advice.
11:31:37 <musasabi> yes, that should go to #-blah ;)
11:32:24 <emu> well i guess things work out better if you use rectangle kill/yank when moving haskell code around
11:45:25 <sethk> is there a way to send the .hi files (on a compile) to a different directory than the current directory?  I'm trying to set up my build so everything in my source directory is to be checked in to VC and all build products are stored in a subdirectory
11:46:49 <ndm> sethk: yes, its a command line flag
11:47:03 <sethk> ndm, but will it work with --make?
11:47:14 <sethk> if I put the .hi files in a different directory?
11:47:14 <ndm> sethk: ghc --make Main -o catch%flag% -odir Temp\%mode% -hidir Temp\%mode%
11:47:29 <ndm> thats how i invoke it, hidir puts the .hi files in a seprate dir
11:47:36 <ndm> -odir does the same for.o
11:47:47 <sethk> yes, but I'm worried about that impacting imports
11:48:42 <ndm> imports?
11:48:52 <ndm> are you ghc --make'ing a library, or an app?
11:48:58 <sethk> an app
11:49:05 <ndm> I use that command line above to make an app, and it all just works
11:49:07 <sethk> well, depends what you mean by that
11:49:15 <sethk> in the sense you mean, probably not.
11:49:23 <sethk> I use separately compiled files to build apps
11:50:23 <ndm> thats the way to do it, and ti works for me, thats all i know
11:50:56 <sethk> I'll try that hidir flag, see if it does what I need.  thanks
11:51:41 <sethk> I'm already using -odir, I'll see if adding hidir breaks my build
11:52:18 <eivuokko> sethk, There's another flag to add more directories where ghc looks for imports (.hi files).  -i I think.
11:52:46 <sethk> eivuokko, ok, thanks, I'll throw that in if it complains.
11:53:45 <eivuokko> Note that foreign exports might generate stubs next to your modules, still.
11:54:11 <sethk> eivuokko, yes, that may be an issue.
11:54:53 <eivuokko> I just usually globally make my vc ignore all _stub.[cho].  That has been (partially?) fixed in ghc 6.5/6
11:55:10 <sethk> unfortunately this company is using a brain dead cm tool
11:57:13 <eivuokko> They are fortunately fairly small files, so putting them in might not be impossible to handle.
12:07:19 <sethk> eivuokko, it isn't a matter of size, the cm people bitch if there are any build products checked into cm
12:07:44 <SamB> ... any what?
12:08:09 <sethk> SamB, build products.  the .hi file is a build product of compiling a .hs file
12:08:19 <SamB> oh, that
12:08:22 <sethk> is -ohi the same as -hidir ?
12:08:49 <sethk> probably not, since it didn't seem to do anything.  :)  maybe I didn't put it in the right place.   I'll play with it.
12:08:53 <SamB> sure, you shouldn't have .hi files under cm... they are very non-portable...
12:09:03 <sethk> SamB, true
12:09:04 <mauke> -ohi -Iupgradedyour -ram
12:09:13 <sethk> "_
12:09:16 <sethk> :)
12:09:48 <SamB> but sometimes it might make sense to put potential build products under CM... if they are built with a fairly unusual tool, that shouldn't be needed unless you change a specific file...
12:10:37 <sethk> SamB, yes, I know, but these people are hard to deal with, and I don't want to try to explain haskell files to them - they might notice I'm using it  :)
12:10:46 <SamB> hah
12:11:11 <sethk> -hidir seems to be working fine
12:11:32 <ndm> SamB, indeed - i often put happy generated files, and certainly bison generated files in
12:12:26 <SamB> yeah, it can be a PITA to get the right large bovine-like creature for a specific file...
12:13:41 <ndm> and Hugs with yacc from 1990 just silently breaks
12:13:57 <SamB> ouuuuuuch!
12:14:29 <SamB> happy is fairly straightforward
12:14:57 <heatsink> hi SyntaxNinja
12:17:13 <musasabi> Is the mapping from data-types to Enum by deriving clauses fixed?
12:17:40 <ndm> musasabi: i believe its based on the order, by spec
12:18:06 <ndm> and yes, it is fixed, provided you do not reorder teh items
12:18:12 <musasabi> ok, will look at the spec.
12:18:34 <musasabi> ha. section 10.2 is exactly what I was looking for.
12:47:42 <tibbe> ?users
12:47:47 <lambdabot> Maximum users seen in #haskell: 235, currently: 211 (89.8%), active: 30 (12.8%)
12:48:00 <tibbe> the number of users on #haskell is very constant
12:48:21 <tibbe> and activity is always between 80-90% whatever that means
12:49:01 <SamB> wait, I thought activity was usually a little over 10%
12:49:24 <heatsink> we're programmers, of course we're not that active.
12:50:32 <SamB> but on IRC, activity means talking ;-)
12:50:40 <SamB> what in other places passes for idlenes!
12:51:05 <tibbe> oh, wrong number
12:53:16 <tieTYT> do most of you use haskell as a hobby language?
12:54:23 * SamB isn't sure how to answer that...
12:56:36 <tieTYT> do you get paid to program in haskell?
12:57:11 <jrmole> kind of... i'm using haskell to code programs for a research project
12:57:15 * SamB doesn't get paid to do much of anything!
12:57:16 <ndm> i get paid to do a phd, and my phd is in haskell
12:57:25 <jrmole> but the programs aren't the end product, so they don't care what language i use
12:57:39 <xerox> <http://en.wikipedia.org/wiki/Martha%27s_Vineyard_Sign_Language> ``Frequently, the punchlines to dirty jokes were told only in sign language.''
12:58:43 <tieTYT> are any of you using haskell because you believe the maintanence of your applications will be easier than if you used a language such as Java or C#?
12:58:52 <tieTYT> have you found this to be true?
12:59:49 <heatsink> This sounds like a survey.
13:00:24 * bringert also gets paid for phd, and uses haskell for it
13:00:33 <tieTYT> it is
13:00:56 <bringert> tieTYT: yes, though there are many reasons
13:01:30 <heatsink> The primary project is in C. I use haskell for writing supplemental tools because they're faster to develop and easier to maintain.
13:02:00 <tieTYT> does your project written in C use the tools?
13:02:29 <jrmole> tieTYT, absolutely
13:02:37 <jrmole> re: maintenance
13:02:48 <SamB> so build tools?
13:03:30 <tieTYT> if i find myself using a lot of do's, does that mean i'm approaching haskell the wrong way?
13:03:34 <heatsink> It uses one of them.  The rest are for interpreting program output or debugging  output.
13:03:56 <tieTYT> maybe this isn't easy to answer but i can say in java if you use a lot of static methods and singletons, you're not being very object oriented
13:04:16 <ndm> tieTYT: probably, yes
13:04:21 <apfelmus> tieTYT: depends on what you are doing. i even prefer haskell as the best imperativ language around
13:04:34 <gour> hi, anyone finds leo (outlining editor) useful for writing haskell programs?
13:04:53 <SamB> tieTYT: dos are good when you are wanting to write imperative programs
13:05:14 <SamB> but if you would rather just calculate things, no.
13:05:49 <tieTYT> ok
13:06:26 <heatsink> tieTYT, if you're thinking about your code in the sense of gradually modifying some collection of data until you're done (which is probably happening with do statements) that's not very functional.
13:07:07 <ndm> tieTYT: are your do's usually in the IO monad? thats a bit sign of doing it the C way
13:07:19 <tieTYT> i don't write a lot of do's
13:07:34 <tieTYT> i don't write a lot of anything, i've only looked into haskell for 2 days
13:07:39 * SamB is puzzled as to why tieTYT asked the question ;-)
13:07:56 <tieTYT> because i felt it was good to avoid a bad habit before i got into it
13:08:17 <ndm> tieTYT: I learnt haskell for about a year before using more than one do per program
13:08:18 <tieTYT> i'd rather ask that before i used them whenever i could than after
13:08:22 <SamB> anyway, you should try to write your program with no IO in sight
13:09:10 <SamB> except that if you want to make an executable, main needs to do IO
13:09:42 <tieTYT> alrighty
13:10:03 <SamB> I mean, unless your program is like a webserver or something
13:10:27 <heatsink> actually, a web server that doesn't do IO would be more secure ;)
13:10:28 <SamB> but why would you write one of those anyway?
13:10:42 <apfelmus> IO is fine if you do IO. readFile is ok. but for or while loops are forbidden (use map, filter, fold instead)
13:11:03 <SamB> well, obviously if it does anything significant besides the serving, it would be nice to avoid IO for as much of that as possible
13:11:19 <SamB> apfelmus: we don't even *have* those
13:11:30 <bringert> well, we kind of do
13:11:47 <falconair_> a recent paper on STM says that the type 'STM a' may be changed to 'Atomically a' and the function 'atomically' may be changed to 'perform' ... first of all, is my understanding correct?  Are more changes expected before the STM library is released?
13:11:56 <bringert> mapM etc
13:12:08 <SamB> falconair_: ... released?
13:12:17 <SamB> the library is available now!
13:12:31 <falconair_> SamB...I thought STM was going to be part of GHC 6.6
13:12:46 <SamB> @type Control.Monad.STM.atomically
13:12:47 <lambdabot> Couldn't find qualified module.
13:12:49 <SamB> hmm
13:12:55 <SamB> @hoogle atomically
13:12:56 <lambdabot> GHC.Conc.atomically :: STM a -> IO a
13:13:02 <SamB> oh, is that where it is?
13:13:10 <SamB> maybe hoogle doesn't index the stm package...
13:13:21 <ndm> SamB: entirely possible...
13:13:24 <SamB> @doc Control.Monad.STM
13:13:24 <lambdabot> Control.Monad.STM not available
13:13:38 <SamB> @doc Control.Concurrent.STM
13:13:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/stm/Control-Concurrent-STM.html
13:13:58 <jrmole> apfelmus, for is (flip mapM_) ;)
13:14:16 <SamB> falconair_: well, I would be surprised if it was not part of GHC 6.6, considering it was part of GHC 6.4...
13:14:20 <apfelmus> bringert: when building the docs for Text.Xhtml i keep getting "haddock: parse error in doc string: [TokSpecial '/',TokString "www.haskell.org",TokSpecial '/']". any idea?
13:15:01 <bringert> apfelmus, that's odd
13:15:01 <falconair_> SamB...I didn't realize it was part of  6.4 :), since my mac intel machine can't run it yet, I've main reading about this stuff rather than coding
13:15:17 <bringert> apfelmus: which versions of xhtml and haddock?
13:15:44 <ndm> apfelmus: remeber haddock often chokes on teh comments in haskell source files
13:16:01 <apfelmus> bringert: xhtml 2006.8.29 and haddock 00.7
13:16:02 <bringert> oh, I got the same error
13:16:05 <bringert> weird
13:16:20 <bringert> that used to work
13:16:21 <ndm> its entirely common for haddock to blow up on source files
13:16:34 <bringert> yeah, but I'm pretty sure I tested it the other day
13:16:38 <apfelmus> bringert: i'm puzzled that grep -r TokSpecial * doesn't even match anything inside XHtml
13:16:39 <ndm> hehe
13:16:43 <ndm> haddock from head?
13:16:55 <ndm> apfelmus: TokSPecial is what the haddock lexer has created
13:17:20 <ndm> apfelmus: take a look at the line number it references, and you'll see /www.haskell.org/
13:17:23 <musasabi> is there a reason this is not valid:
13:17:39 <apfelmus> ndm: ah.
13:17:45 <musasabi> [d| instance Foo $(toN name) where foobar = $(somefun) |] ?
13:18:03 <ndm> apfelmus: paste the whole comment that its borking on, and i might be able to help
13:18:13 <SamB> @type [d| instance Foo $(toN name) where foobar = $(somefun) |]
13:18:14 <lambdabot> parse error on input `instance'
13:18:22 <SamB> hmm
13:18:36 <bringert> the thing is, it doesn't give a line number, and there is no www.haskell.org in the source files
13:18:42 <musasabi> The problem is the name of the type as a variable.
13:18:54 <SamB> Prelude> :t [d| instance Foo $(toN name) where foobar = $(somefun) |] ?
13:18:54 <SamB> <interactive>:1:17: parse error on input `$('
13:18:56 <bringert> I think it comes from the cabal file
13:19:22 <bringert> yep, that was
13:19:23 <bringert> it
13:19:25 <SamB> musasabi: the usual lack of splicing-places?
13:19:49 <bringert> it used to work
13:20:05 <bringert> ndm: you're right, I have got haddock from HEAD
13:20:13 <musasabi> SamB: yes :-(
13:20:21 <bringert> and cabal from head
13:20:42 <ndm> hmm, thats weird, it shouldn't die like that...
13:20:44 <apfelmus> ndm: haddock mumbles
13:20:45 <apfelmus>   Preprocessing library xhtml-2006.8.29...
13:20:45 <apfelmus>   Running Haddock for xhtml-2006.8.29...
13:20:45 <apfelmus>   haddock: parse error in doc string: [TokSpecial '/',TokString "www.haskell.org",TokSpecial '/']
13:20:48 <apfelmus> and stirs.
13:21:03 <SamB> musasabi: well, probably nobody is eager to hack up the parser/AST type to let you splice everywhere you ought to be able to?
13:21:21 <bringert> phone
13:21:36 <ndm> apfelmus: try editing the cabal file, so it doesn't have www.haskell.org in it
13:23:00 <vincenz> quit
13:24:36 <apfelmus> ndm: removing the whole link works. so haddock looks inside the cabal file? insane
13:24:47 <ndm> apfelmus: seems so, yes...
13:24:59 <ndm> apfelmus: bug Simon Marlow about it
13:25:20 <ndm> my haddock hacking experience is the --hoogle flag only :)
13:27:45 <bringert> hold on, I don't have haddock from HEAD
13:27:49 <bringert> I have 0.7
13:27:58 <bringert> so the change is probably in cabal
13:28:09 <ndm> ah, thats probably it
13:28:12 <bringert> apfelmus: what ghc and cabal versions do you have
13:28:29 <ndm> cabal lifts the info from the .cabal file and sends some of it through to haddock on the command line
13:30:21 <bringert> Igloo: similar problem as yesterday, did ./darcs-all pull -a; make, now I get: ./HsVersions.h:93:0:
13:30:21 <bringert>     Bad interface file: stage1/utils/FastString.hi
13:30:21 <bringert>         mismatched interface file versions: expected 6050, found 390518464
13:31:22 <SyntaxNinja> w00t
13:31:38 <ndm> SyntaxNinja: why w00t?
13:31:40 <apfelmus> bringert: ghc 6.4.2. where do i find out the cabal version
13:31:42 <apfelmus> ?
13:31:50 <ndm> SyntaxNinja: and btw, do you know when Colin heads home?
13:32:03 <SyntaxNinja> ndm: he's gone from galois, not sure where he is currently.
13:32:06 <SyntaxNinja> I think on his way home.
13:32:22 <SyntaxNinja> apfelmus: ghc-pkg-6.4.2 -l |grep Cabal
13:32:22 <ndm> ok, well i decided to take a holiday, so if he shows up, i won't be there
13:32:38 <SyntaxNinja> ndm: OK. well tell him that if he's looking for you to ask me and I'll tell him I don't know, but you're on holiday.
13:32:47 <Lemmih> apfelmus: or 'ghc-pkg-6.4.2 field Cabal version'.
13:32:53 <apfelmus> bringert: ok cabal 1.1.4
13:33:15 <SyntaxNinja> has anyone else had trouble w/ ghc 6.5 and main:Distribution.Simple verses Cabal:Distribution:Simple ?
13:33:17 <apfelmus> thx
13:33:18 <bringert> strange, then I must have messed something up, since I can swear it worked the other day
13:34:03 <apfelmus> bringert: what do you want to do with the [ ]Â in your cabal description anyway?
13:34:11 <sethk> hmm, found a --make bug.  I'm stil on 6.4.2, I'll try it with a newer one before I report it.
13:34:32 <bringert> apfelmus: it's a hack, it's used by hask-home when generating the homepage for the package
13:35:00 <ndm> sethk: 6.4.2 is the stable one, whats your bug?
13:35:36 <sethk> ndm, I just checked and 6.4.1 is on this box.  I'm doing a quick install on 6.4.2.  If it is still there, I'll tell you.  give me about 10 minutes to install and rebuild.
13:35:38 <bringert> Igloo: ah, it seems to be a different error. I guess ghc's interface file format changed?
13:35:58 <ndm> sethk: windows or linux?
13:36:08 <sethk> ndm, linux
13:36:35 <bringert> it feels like ghc should just rebuild everything in dependency order when that happens though
13:36:42 <sethk> ndm, it's odd, because this is something I've been building for months, the only thing I changed is that I added -hidir (was already using -odir)
13:36:49 <sethk> ndm, anyway, ready to build with 6.4.2...
13:37:07 <ndm> sethk: yeah, i had a few bugs with some make stuff and optinos, esp on windows
13:37:19 <ndm> think they all dispapeared eventually, may have been things i was doing wrong
13:37:25 <apfelmus> bringert: ah. mh well, haddock does not care about [], only on /.
13:37:51 <bringert> slashdot?
13:41:19 <sethk> ndm, this is really odd.  If I put the .hi files back (in the same directory with the .hs files) it doesn't happen.
13:41:30 <sethk> ndm, so I should report a 6.4.2 bug?
13:41:34 <apfelmus> bringert: i only mean / (no dot here even if the sentence is over) reading the f.. manual, it seems that haddock takes / in pairs for italic text. if you embrace the url in <  >, everything is fine.
13:41:48 <sethk> ndm, or should I wait for the RC that's due and test with it first?
13:42:42 <ndm> sethk: whats your exact command line?
13:42:52 <ndm> sethk: since i do this, and it works perfectly
13:43:10 <ndm> and can you make a minimally reproduceable test case?
13:43:45 <sethk> ndm, It's a makefile building a bunch of apps, so the compile/link lines are the same for all the apps.
13:44:09 <ndm> sethk: just give an example of what ghc is invoked with
13:44:12 <sethk> ndm, what's happening is that it is saying "Skipping Main", but it shouldn't be skipped, then I get a bunch of unresolved externals
13:44:38 <sethk> ndm, I can paste the line, but it's the same line that works for all the other apps I'm building in this directory:
13:44:41 <ndm> sethk: i doubt its the obvious bug,there must be something a bit deeper about your set up or soemthing
13:44:45 <bringert> I guess I should use haddock markup in hask-home then, or move the description used by hask-home to a separate file.
13:44:49 <ndm> sethk: go on then
13:44:53 <sethk> ications requires at runtime the shared libraries from the glibc version used for linking
13:44:53 <sethk> ghc --make -static -optl -static -threaded -fffi -fglasgow-exts -fno-monomorphism-restriction -Werror -W -i.. -odir . -hidir . -o imageDownload ../imageDownload.hs
13:45:08 <sethk> first line was a mistake, just read from ghc --make
13:45:17 <sethk> here is one that works:
13:45:31 <sethk> ghc --make -static -optl -static -threaded -fffi -fglasgow-exts -fno-monomorphism-restriction -Werror -W -i.. -odir . -hidir . -o writeStateValues ../writeStateValues.hs wgid.o
13:45:45 <ndm> ah, i know!
13:45:53 <ndm> i am guessing you have multiple apps
13:45:55 <sethk> now, that one (the one I just pasted) uses ffi, as you can see, and the undefined externals are ffi functions
13:46:01 <ndm> in different directories
13:46:15 <sethk> ndm, all correct, except the different directories part
13:46:22 <ndm> is the Main module for each file named Main.hs, or AppSpecific.hs?
13:46:43 <ndm> i am guessing AppSpecific
13:46:54 <sethk> ndm, correct.
13:47:00 <apfelmus> bringert: yeah.
13:47:01 <ndm> then AppSpecific.hs has the module Main, so it goes to hidirectory/Main.o and Main.hi
13:47:09 <sethk> two apps, neither file is named Main, both begin with module Main
13:47:12 <ndm> based on the module name
13:47:22 <sethk> but so are all the others that build correctly.
13:47:30 <ndm> yeah, obviously -hidir uses the module name, not the filename to do ti
13:47:36 <sethk> but you nailed one part, the ffi one links, and the one right after that fails.
13:47:48 <musasabi> Is there a nice way to combine literate haskell and haddock?
13:47:51 <SamB> so -hidir is messed up!
13:47:51 <ndm> ah, so perhaps the ffi forces Main.o
13:47:59 <ndm> musasabi: Google SoC
13:48:02 <SamB> oh, wait, ffi?
13:48:08 <sethk> something like that, but the one with ffi links perfectly
13:48:12 <ndm> musasabi: or cpphs -unlit file
13:48:15 <sethk> it's the following one, without ffi, that has a problem
13:48:29 <ndm> musasabi: i was tempted to fork haddock, and add automatic -cpp and -unlit support with cpphs
13:48:51 <musasabi> ndm: I know how to unlit it - just want to have haddock comments *as the literate part*.
13:49:09 <ndm> musasabi: ah, good point!
13:49:22 <ndm> musasabi: i think that should be a 10 minute patch to cpphs
13:49:28 <ndm> musasabi: and would be nice to have in it
13:49:43 <sethk> ndm, I'll just hack in a rm main.hi for the moment, see if that works
13:50:16 <sethk> ndm, didn't have to remove main.hi, only main.o
13:50:18 <sethk> weird
13:50:47 <ndm> yep, weird indeed - perhaps ffi puts special restrictions
13:50:51 <ndm> at least you can work round it
13:50:58 <ndm> but perhaps report it as a bug anyway
13:51:25 <sethk> ndm, ok
13:51:26 <ndm> I patched Yhc so it doesn't do that - AppSpecific.hs always generates AppSpecific.hi in Yhc
13:51:36 <ndm> even if Module name is Main
13:51:48 <SamB> I'm pretty sure GHC is supposed to do that too
13:52:02 <SamB> at least when the module name is Main
13:52:30 <nilsi> @seen ndm
13:52:31 <lambdabot> ndm is in #haskell-blah, #haskell-overflow and #haskell. I last heard ndm speak 54 seconds ago.
13:52:45 <ndm> @seen nilsi
13:52:45 <lambdabot> nilsi is in #haskell. I last heard nilsi speak 15 seconds ago.
13:53:05 <nilsi> i have a binary wxhaskell for ghc 6.4.2
13:53:29 <nilsi> but i am currently unable to find the download link
13:53:39 <nilsi> for windows that is
13:53:40 <ndm> nilsi: post it to haskell@ and shove it on the wxHaskell home page!
13:53:52 <nilsi> not compiled myself
13:54:15 <ndm> as long as you have permission to redistribute it, get it on a public server!
13:55:10 <ndm> nilsi: why is the wxHaskell website showing me popups?
13:55:20 <nilsi> i downloaded it from sourceforge or something, i am desparetely looking for the link atm
13:55:27 <ndm> http://wxhaskell.sourceforge.net/
13:55:27 <nilsi> a few days ago
13:55:40 <lambdabot> Title: wxHaskell
13:55:52 <nilsi> i doubt they have a 6.4.2 version
13:56:20 <ndm> http://sourceforge.net/project/showfiles.php?group_id=73133&package_id=73173
13:56:25 <ndm> thats 6.4.0
13:56:40 <ndm> the latest publically available release
13:57:12 <nilsi> some guy patched it
13:59:15 <nuffer> how can I do um... basically a typedef from C in haskell?
13:59:25 <profmakx> -.-
13:59:27 <profmakx> Type
13:59:35 * apfelmus takeWhile dark sleep
13:59:36 <nuffer> capitol or lowercase?
13:59:54 <ndm> nuffer: lower
13:59:58 <ndm> type String = [Char]
14:00:00 <nuffer> so "type a = b"
14:00:02 <mauke> try it, your editor should color the right version
14:00:13 <nuffer> yeah, it did, but I get an error I don't really understand
14:00:22 <mauke> paste the error
14:00:35 <nuffer> one sec
14:00:40 <profmakx> waeeh
14:00:47 <profmakx> why dont i remember such things?
14:00:47 <nuffer> Malformed LHS to type of class declaration
14:01:09 <nuffer> oh, must the name be uppercase?
14:01:10 <profmakx> it would be easier if you showed us your defintion i suppose
14:01:17 <profmakx> yes
14:01:21 <nuffer> okay, that was the problem
14:01:24 <mauke> yes, typenames must start with a capital letter
14:01:28 <nuffer> thankee
14:15:45 <nuffer> http://pastebin.com/780107 -- can anyone explain to me what this error is trying to tell me?
14:17:41 <ndm> @where paste
14:17:41 <lambdabot> http://paste.lisp.org/new/haskell
14:17:49 <ndm> is easier to use in future :)
14:17:49 <jrmole> it's saying that nn is a three-tuple rather than an IO type
14:18:08 <jrmole> what's the type of cpumGet?
14:18:10 <nuffer> okay, in the future I will paste there...
14:18:19 <nuffer> cpumGet :: CPU -> Word16 -> IO Word8
14:18:39 <nuffer> er, sorry, CPUMemory -> Word16 -> IO Word8
14:18:56 <jrmole> actually i'd guess it's complaining about the next line, even though that's not what it says
14:19:10 <jrmole> did you try return (3, 2, cpumGetZP m nn)
14:19:21 <nuffer> no, let me put that in
14:19:38 <jrmole> does cpumGetZP have an IO monad return type?
14:19:54 <nuffer> um
14:20:02 <nuffer> CPU -> CPUMemory -> (Int, Word16, IO Word8)
14:20:36 <nilsi> is there a way to search sourceforge for a particular filename?
14:21:02 <musasabi> Someone had a tool to preprocess files with TH content to produce the resulting Haskell files?
14:21:04 <jrmole> nuffer, for cpumGetZP?
14:21:20 <nuffer> uh, CPUMemory -> Word8 -> IO Word8
14:21:53 <jrmole> and you want the end result to have type (Int, Word16, IO Word8)?
14:22:00 <nuffer> yeah
14:22:08 <Philippa> musasabi: as in "run all stages but the final one, show resulting source with all splices performed"?
14:22:11 <jrmole> okay, then that looks right... put a return before it
14:22:46 <jrmole> also, in general, defining your own algebraic data type is almost always better than using a tuple, except for very localized uses
14:22:49 <musasabi> Philippa: yes. (want to generate haddock docs for those)
14:23:00 <jrmole> it will make your type errors much more informative, and catch some things you otherwise wouldn't
14:23:04 <nuffer> okay
14:23:27 <musasabi> haddock is no fun when all data declarations come from TH without such a tool.
14:25:42 <musasabi> Philippa: I think someone here had such a tool (~about a year ago).
14:26:14 <Philippa> seems to me like an obvious flag for GHC if there's no tool to do it
14:26:23 <Philippa> well, flag and patch
14:27:12 <nilsi> ping ndm
14:27:21 <ndm> pong nilsi
14:27:24 <nilsi> i found my link
14:27:27 <nilsi> http://sourceforge.net/project/showfiles.php?group_id=168626
14:27:48 <nilsi> has a binary for 6.4.2, this is where i found it
14:28:04 <ndm> neat, are you one of the wxHaskell new team of maintainers?
14:28:31 <nilsi> no, i am just an ordinary windows user
14:28:53 <Philippa> we need more of those
14:29:13 <Philippa> well, I say we - for certain values of ordinary I'm just an ordinary windows user too
14:29:54 <nilsi> i am unable to compile something like that myself let alone patching makefiles
14:30:06 <ndm> nilsi: you should email the new wxHaskell team, so they can put a link on teh web
14:31:29 <nilsi> feel free to do that :D
14:31:51 <ndm> @tell kowey have you seen this http://sourceforge.net/project/showfiles.php?group_id=168626 - could that be put on teh wxHaskell home page?
14:31:52 <lambdabot> Consider it noted.
14:31:56 <ndm> nilsi: just done :)
14:32:21 <nilsi> :)
14:50:03 <profmakx> nice global announcements this evening ^^
14:51:49 <nilsi> @seen JohnMeacham
14:51:49 <lambdabot> I saw JohnMeacham leaving #haskell-blah and #haskell 4 days, 12 hours, 38 minutes and 14 seconds ago, and .
15:00:18 <bringert> grr, HaXml uses Data.FiniteMap, so it doesn't build with ghc HEAD
15:00:41 <ndm> bringert: send off a patch!
15:00:50 <ndm> or find Data.FiniteMap somewhere, in terms of Data.Map
15:00:57 <ndm> I'm sure there must be one out there..
15:01:03 <bringert> it might be intentional, to support ghc 6.2.2 etc.
15:01:14 <nilsi> interesting: http://www-i2.informatik.rwth-aachen.de/i2/99/
15:01:35 <nilsi> title:  Automated Termination Analysis for Haskell
15:02:03 <ndm> yeah, have seen that before - am still trying to get round to reading it
15:02:13 <bringert> it seems malcolm wallace sent one to ghc-cvs recently
15:02:36 <ndm> bringert: him being the HaXml person, that kind of makes sense :)
15:04:08 <nilsi> http://aprove.informatik.rwth-aachen.de/index.asp?subform=termination_proofs.html
15:04:09 <lambdabot> Title: AProVE
15:04:55 <ndm> nilsi: what is your interest in termination proofs for haskell?
15:05:04 <ndm> thats really cool, its my phd so will have to study that in detail
15:05:20 <nilsi> i wonder if better compiler optimizations are possible, if you know about termination behaviour
15:05:53 <ndm> maybe a few
15:06:03 <ndm> you can do insane partial evaluation
15:06:16 <ndm> I think that is Neil Jones's route
15:06:28 <Philippa> partial evaluation good
15:06:29 <nilsi> in my experience space leaks are the thing that prevents people from using haskell
15:06:46 <nilsi> they say: haskell is cool, but much too slow
15:07:20 <ndm> that system looks incredible
15:07:30 <nilsi> so i wait for jhc with optimistic evaluation
15:07:32 <ndm> actually, possibly sufficiently powerful for me just to ditch that part ofmy phd
15:08:32 <nilsi> i like everything with  "automated" in it :)   being lazy :)
15:14:28 <bringert> hm, when builing ghc HEAD I get:
15:14:40 <bringert> _regexzmcompatzm0zi71_TextziRegex_a1_closure
15:14:42 <bringert> ...
15:15:00 <bringert> eh, missing "/usr/bin/ld: Undefined symbols:" there
15:15:08 <musasabi> seems like it should depend on the regex-compat package but does not.
15:16:37 <bringert> ah, well, they'll notice during the nightly build I guess, noone awake to fix it now anyway
15:17:25 <bringert> good night #haskell
15:19:07 <profmakx> n8 bringert
15:20:01 <musasabi> Anyone have Base64 for fps?
15:22:23 <dmwit> Yargh, I can't keep up with this channel.  Too much traffic.
15:23:25 <emu> it's extremely easy to write "slow" code in haskell, probably doesn't help general impression much
15:23:53 <Cale> I think it's pretty easy to write slow code in any language.
15:23:56 <SamB> emu: huh
15:24:06 <nilsi> well in C it is harder
15:24:09 <SamB> Cale: not if you have to use loops!
15:24:18 <Cale> Even if you have to use loops :)
15:24:19 <SamB> loops are HARD!
15:24:25 <dmwit> nilsi: in C, everything is harder.
15:24:32 <SamB> well, some might think so ;-)
15:25:18 <nilsi> in C the results are wrong, but the code executes fast
15:25:26 <dmwit> =D
15:25:41 <SamB> I think that the ease of writing slow programs in Haskell just means that it is easy to write programs more complicated than a paperclip
15:25:49 <emu> yes, of course
15:26:01 <ndm> i disagree - in C you can write a loop that goes round 10000 times and does nothing
15:26:09 <emu> a little code goes a long way
15:26:10 <ndm> try writing that in Haskell - it will delete the loop!
15:26:26 <SamB> > length (replicate 10000 ())
15:26:27 <lambdabot>  10000
15:26:31 <emu> in C, 1/3 = 0, mmm
15:26:33 <dmwit> Any good C-compiler will delete such a loop, too...
15:26:38 * SamB wonders if the compiler can delete that
15:26:52 <ndm> SamB: add a rewrite rule :)
15:26:56 <SamB> > sum (replicate 10000 0)
15:26:57 <lambdabot>  0
15:27:01 <ndm> with list fusion, its nearly possible
15:27:02 <dmwit> SamB: If the value is never used, why would it be evaluated?
15:27:18 <SamB> dmwit: well, if it isn't used, who cares about it anyway?
15:27:33 <dmwit> I think that's ndm's point...
15:29:58 <Cale> Hehe, there should be rewrite rules for summing arithmetic sequences generated by enumFromThenTo
15:30:09 <Cale> (and friends)
15:30:18 <ndm> Cale: add them :)
15:30:51 <SamB> doesn't that assume some things?
15:31:11 <SamB> they'd have to be only used for Integral types, methinks...
15:31:18 <emu> SamB: i was refering to algorithmic choices which can result in poor performance, for example in the extreme, using foldl instead of foldr in: take 5 (foldr (++) [] (map (:[]) [1..]))
15:31:38 <SamB> then again, maybe GF types wouldn't be in Enum...
15:31:43 <emu> (in a totally contrived example)
15:33:51 <emu> > take 5 $ foldr (++) [] $ map (:[]) [1..]
15:33:52 <lambdabot>  [1,2,3,4,5]
15:34:42 <Cale> emu: But you can make similar mistakes in C, it's just that you have to write more code to do it :)
15:34:49 <emu> of course, Cale
15:35:21 <emu> representing infinite sequences in C, however, doesn't sound like my idea of a good time
15:35:24 <SamB> except that C doesn't support lists which, if not infinite, do not fit in memory in any case
15:35:30 <Cale> well, yes
15:35:44 <SamB> > length [1..]
15:35:48 <lambdabot> Terminated
15:35:49 <emu> hehe
15:36:02 <emu> nice error message
15:36:11 <emu> > take 5 $ foldl (++) [] $ map (:[]) [1..]
15:36:15 <lambdabot> Terminated
15:36:17 <Cale> Yeah, that's what it prints if you run out of time
15:37:02 <emu> i was writing some code to enumerate the theorems of the MIU system actually when I used foldr like this, so i wondered what would happen if i used foldl, with unsurprsing results.  not so contrived after all.
15:37:22 <SamB> emu: huh
15:37:28 <SamB> you can do that?
15:37:40 <SamB> I suppose in order of number of steps, you could...
15:37:46 <Cale> SamB: yep :)
15:37:57 <SamB> but you'd get duplicates
15:38:07 <Cale> You could nub the list :)
15:38:12 <emu> theorems = axioms ++ $ foldr (++) [] [ expand s | s < theorems ])
15:38:15 <SamB> not really...
15:38:24 <emu> lol nubing the list would... eh
15:38:28 <SamB> well. maybe.
15:38:36 <SamB> > nub [3,2,3]
15:38:37 <lambdabot>  [3,2]
15:38:41 <SamB> oh, okay, so you could
15:39:00 <emu> you could compare vs the generated "so-far" list
15:39:01 <SamB> but it would be O(n^2)
15:39:05 <Cale> yeah
15:39:10 <emu> that would require using a pair of lists in the sequence
15:39:25 <Cale> emu: that's effectively the same as nub
15:39:27 <SamB> > nub [3,2,3..]
15:39:27 <lambdabot>  Parse error
15:39:36 <Cale> > nub [1..]
15:39:38 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:39:42 <emu> Cale: well, you can't nub an infinite seq...
15:39:42 <emu> er
15:39:49 <Cale> yes you can :)
15:39:49 <SamB> > nub ([3] ++ [2..])
15:39:51 <lambdabot>  [3,2,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
15:39:55 <emu> um btw
15:40:07 <emu> is there some setting i can use to prevent GHC from trying to print out infinite sequences
15:40:12 <SamB> > nub ([3] ++ [2..]) :: [Integer] -- to make sure is infinite!
15:40:13 <lambdabot>  [3,2,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
15:40:13 <emu> if i accidentally make it Show one
15:40:25 <Cale> I just hit Ctrl-C
15:41:10 <SamB> ... you expect GHC to know which are infinite?
15:41:32 <emu> i mean cut-off
15:41:36 <emu> like lambdabot is doing
15:41:51 <ndm> > take 25 $ show $ nub ([3] ++ [2..]) :: [Integer] -- to make sure is infinite!
15:41:52 <lambdabot>  Couldn't match `Integer' against `Char'
15:42:00 <ndm> > take 25 $ show $ (nub ([3] ++ [2..]) :: [Integer] ) -- to make sure is infinite!
15:42:01 <lambdabot>  "[3,2,4,5,6,7,8,9,10,11,12"
15:42:12 <ndm> how about that, for doinga  cut off?
15:42:27 <Cale> > nub . concat . sequence $ [[1..],[1..10]]
15:42:28 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
15:42:34 <emu> ah cool, so i did theorems = nub $ ... and it worked
15:43:01 <emu> i thought nub would try to examine the entire list for duplicates..
15:43:07 <Cale> it does
15:43:10 <Cale> lazily :)
15:43:33 <emu> so long as it searches "backwards" it's ok i guess
15:43:42 <araujo> hi all
15:43:44 <Cale> nub [] = []; nub (x:xs) = x : nub (filter (/= x) xs)
15:43:47 <araujo> hola br1
15:43:57 <emu> i see
15:44:05 <profmakx> @seen edwardk
15:44:06 <lambdabot> I saw edwardk leaving #haskell 3 hours, 18 minutes and 20 seconds ago, and .
15:44:36 <Cale> So it'll always produce the first element, and filter is lazy, so as long as you don't end up eliminating the entire rest of the list, you'll always get another element from the filter.
15:45:29 <Cale> You do end up building up a huge chain of tests as you work your way down the list though.
15:45:34 <emu> yea
15:45:54 <emu> it's running rather quickly though, take 100 takes no time at all, yay ghc
15:46:12 <emu> i've avoided any large branching factors i think
15:46:34 <emu> even with O(n^2) of nub..
15:47:02 <Cale> Have you either solved the MU problem or read far enough to know the answer?
15:47:16 <emu> both
15:47:24 <Cale> cool
15:47:35 <emu> i mean it became kinda clear how the III and UU were working together
15:48:20 <emu> theorems = nub $ (axioms++) $ (foldr (++) [] [ expand s | s <- theorems ])
15:48:29 <emu> so i decided to use this as an exercise for haskell
15:49:21 <Cale> theorems >>= expand
15:49:28 <Cale> =  (foldr (++) [] [ expand s | s <- theorems ])
15:49:39 * SamB wonders which n is the n in this O(n^2)
15:49:52 <emu> SamB: infinity!
15:49:57 <Cale> SamB: number of elements generated so far
15:50:00 <emu> or whatever I use to extract elements of the list
15:50:01 <SamB> I suppose it is the number of elements in the source that are read...
15:50:07 <Cale> yeah
15:50:27 <Cale> It would be more correct to say that the nth element takes O(n) time, perhaps
15:50:30 <SamB> in the case of MIU this upper bound will not be reached, of course
15:50:31 <dmwit> concat (map expand theorems) ?
15:50:40 <emu> Cale: the >>= operator defined for a monad?
15:50:43 <Cale> emu: yep
15:50:49 <SamB> Cale: not really
15:50:59 <Cale> emu: this is exactly the sort of thing which the list monad is for
15:51:29 <dmwit> Oh, >>= is even better
15:51:29 <jeroenp> Cale: don't you mean nub [] = []; nub (x:xs) = x : filter (/=x) (nub xs)
15:52:01 <emu> fun
15:52:33 <SamB> jeroenp: does that make things significantly different?
15:52:40 <Cale> jeroenp: nope
15:52:48 <Cale> but it doesn't change much
15:53:40 <jeroenp> Perhaps you can even prove that they are the same, effectively
15:54:16 <jeroenp> Cale: Misread your version, now I see :)
15:55:59 <emu> nubBy eq (x:xs)         =  x : nubBy eq (filter (\y -> not (eq x y)) xs)
15:56:24 <emu> where does the name 'nub' come from anyhow? I was looking for a function like this the other day and nearly missed it.
15:59:32 <jeroenp> emu: nubBy eq = let { nubb [] = []; nubb (x:xs) = x : nubb (filter (not . eq x) xs)} in nubb
15:59:55 <emu> hm? I copied that defn out of the Report
16:00:05 <jeroenp> I just made something up
16:00:10 <emu> which i'm reading for more info on >>= and the list monad
16:00:16 <jeroenp> I suppose the report-thing is better then
16:02:07 <emu> i see:  m >>= k          = concat (map k m)
16:02:35 <emu> concat = foldr (++) []
16:02:38 <SamB> also (>>=) = flip concatMap ;-)
16:03:06 <dmwit> @type concatMap
16:03:08 <lambdabot> forall b a. (a -> [b]) -> [a] -> [b]
16:03:31 <emu> concatMap f = concat . map f
16:03:31 <SamB> dmwit: it is just (concat . map)
16:03:39 <SamB> emu: eh?
16:03:40 * emu just found it in the report
16:03:40 <dmwit> Seems sensible.
16:03:47 <SamB> oh.
16:03:52 <emu> same thing, the report seems to prefer explicit arguments though
16:03:53 <SamB> okay, I'm confused then!
16:04:05 <SamB> @type \f -> concat . map f
16:04:06 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
16:04:14 <SamB> @type concat . map
16:04:15 <lambdabot>   Expecting a function type, but found `b'
16:04:16 <lambdabot>    Expected type: (a1 -> b) -> [[a]]
16:04:18 <SamB> okay good
16:04:26 <SamB> I'm just ordinarily confused
16:04:43 <SamB> not confused about the precedence of . and application...
16:04:44 <emu> and flip just re-orders argument order?
16:04:53 <SamB> @type flip
16:04:54 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
16:05:13 <SamB> @free flip :: (a -> b -> c) -> b -> a -> c
16:05:14 <lambdabot> h . k x = p (f x) . g => h . flip k y = flip p (g y) . f
16:05:34 <SamB> oooookay...
16:05:37 <dmwit> Frightening.
16:05:48 <SamB> I have NO IDEA if that is AT ALL USEFUL or not
16:06:15 <emu> what's @free?
16:06:32 <SamB> it gives you "Theorems for Free"
16:06:42 <SamB> @help free
16:06:43 <lambdabot> free <id :: a -> a>. Generate theorems for free
16:06:55 <SamB> @free id :: a -> a
16:07:00 <lambdabot> f . id = id . f
16:07:34 <emu> lol
16:08:30 <dmwit> Hmmm... just found this one:
16:08:33 <dmwit> @yhjulwwiefzojcbxybbruweejw
16:08:34 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
16:08:36 <dmwit> Any ideas?
16:09:06 <wolverian> @y
16:09:07 <lambdabot> Maybe you meant: yarr yhjulwwiefzojcbxybbruweejw yow . v
16:09:35 <wolverian> no. I have no idea.
16:09:53 <dmwit> @yarr
16:09:54 <lambdabot> Shiver me timbers!
16:09:58 <dmwit> =)
16:10:16 <wolverian> @. vixen yarr
16:10:16 <lambdabot> Are we just wasting time?
16:10:25 <wolverian> yes.
16:10:59 <dmwit> @protontorpedo
16:11:00 <lambdabot> I personally emailed paul graham the lisp guy today after reading about python in E raymonds essay he metions ruby n python is u cant use lisp
16:11:18 <wolverian> okay who the hell writes these things
16:11:25 <wolverian> I want to buy him a beer.
16:11:46 <SamB> protontorpedo?
16:11:48 <nilsi> is beer better than lisp?
16:11:50 <SamB> @proton
16:11:51 <lambdabot> scheme, lisp, php, python, perl, tcl, al banned
16:11:55 <SamB> @pr
16:11:55 <lambdabot> Maybe you meant: pretty print-notices protontorpedo pl
16:12:04 <SamB> @help protontorpedo
16:12:04 <lambdabot> protontorpedo is silly
16:12:09 <SamB> @help keal
16:12:10 <lambdabot> keal. Talk like Keal
16:12:13 <SamB> @keal
16:12:14 <lambdabot> Keal angry @ dons
16:12:18 <SamB> @keal
16:12:18 <lambdabot> i try make program called Glyph to do it but my script lang called T too slow. i invent T
16:12:22 <SamB> @silly
16:12:22 <lambdabot> Unknown command, try @list
16:12:25 <SamB> @funny
16:12:25 <lambdabot> Unknown command, try @list
16:12:32 <wolverian> @dons
16:12:33 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
16:12:35 <SamB> @keal
16:12:36 <lambdabot> #haskell needs to take its meds
16:12:45 <nilsi> @quote dons
16:12:45 <lambdabot>  the type system is *great* for coding while sleepy.. you just hack any garbage together, and let the type checker deal with it
16:12:51 <SamB> @quote
16:12:52 <lambdabot> int-e says: C++ does make a reasonably usable high-level assembler
16:12:56 <SamB> @quote
16:12:57 <lambdabot> malig says: quantum mechanics actually strikes me as less wierd than lazy evaluation sometimes. at least it disallows time travel
16:13:04 <SamB> haha
16:13:07 <SamB> @quote
16:13:07 <lambdabot> ChilliX says: You need to seek a balance between category theory and VLSI
16:13:14 <SamB> mmmmmm
16:13:17 <dmwit> =) at malig
16:13:23 <SamB> balance between catagory theory and VLSI...
16:13:37 * SamB doesn't imagine many circuits run on category theory...
16:13:55 <nilsi> it is about low level vs. high level languages
16:13:57 <dmwit> @botsnack
16:13:58 <lambdabot> :)
16:13:59 <wolverian> pfft. everything is a category when you look at it long enough.
16:14:05 <nilsi> methinks
16:14:08 <musasabi> Lemmih: would you happen to have a local branch of haskell-src-exts ?
16:14:32 <Lemmih> musasabi: I don't think so.
16:14:35 <nilsi> @quote
16:14:35 <lambdabot> xahlee says: The Haskell Logo is the perfection of logos
16:14:40 <nilsi> @quote
16:14:40 <lambdabot> S.Behrens says: or maybe she is the Queen of Sciences and he is the Mack Daddy.
16:14:44 <nilsi> @quote
16:14:45 <lambdabot> mwc says: I actually got away with running Haskell through a TeX pretty printer and handing it in as pseudocode
16:14:55 <nilsi> @quote
16:14:56 <lambdabot> ndm says: outside of haskell i know roughly as many satan worshipers as christians.
16:15:01 <nilsi> @quote
16:15:01 <lambdabot> tennin says: [very #haskell] anyone know of any good books/papers on the application of category theory to databases?
16:15:04 <musasabi> Lemmih: zerothHead uses HsSpliceDecl which does not appear anywhere when grepping the haskell-src-exts darcs repo.
16:15:49 <musasabi> (or google)
16:17:05 <dmwit> So, why is List.map in scope but not List.nub?
16:17:20 <dmwit> I know it's easy to import List, but...
16:17:55 <araujo> @hoogle map
16:17:56 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
16:17:56 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
16:17:56 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
16:18:03 <araujo> @hoogle nub
16:18:04 <lambdabot> List.nub :: Eq a => [a] -> [a]
16:18:04 <lambdabot> List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
16:18:11 * dmwit says duh
16:18:23 <dmwit> (Also, thanks.)
16:18:30 <araujo> welcome
16:43:37 <dolio> ?free zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
16:43:37 <lambdabot> h . k x = p (f x) . g => $map h . zipWith k y = zipWith p ($map f y) . $map g
16:44:18 <dolio> ?free zip :: [a] -> [b] -> [(a, b)]
16:44:19 <lambdabot> ( ( f ($proj_2_1 z) = $proj_2_1 u     &&     g ($proj_2_2 z) = $proj_2_2 u   )  =>   h z = u ) => $map h (zip x y) = zip ($map f x) ($map g y)
16:45:06 <dmwit> @more
16:47:25 <Cale> ?free map :: (a -> b) -> [a] -> [b]
16:47:26 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
16:59:46 <falconair_> is there an IDE for haskell which shows the type of an expression without having to run the code through  an compiler or an interpreter? (Visual Studio for F# allows one to hover the cursor over an expression and pops up the type of the expression...very useful for newbies such as myself)
17:00:37 <dolio> The Visual Haskell (I think that's the name) project is working on that kind of thing.
17:00:48 <dolio> And eclipse-fp might be able to do it.
17:01:00 <falconair_> I tried visual haskell, but that is apparently only for VS 2003, not the latest
17:01:06 <falconair_> hm...i'll try eclipse-fp
17:01:19 <dolio> Ah. Those are the only two haskell ide type projects I know of.
17:01:33 <falconair_> are there any other in development?
17:01:37 <emu> emacs
17:02:18 <falconair_> emacs and haskell, now i have two things to learn :)
17:02:38 <emu> emacs is easy and will make your coding life so much better
17:02:45 <falconair_> emacs allows one to quickly check the type of an expression?
17:02:54 <emu> yep
17:03:06 <dolio> It will indent your haskell properly, too.
17:03:09 <dolio> So luxurious. :)
17:03:23 <falconair_> i'll have to learn it eventually...kicking and screaming, I'm sure
17:03:27 <emu> emacs runs a haskell shell as an inferior sub-process
17:03:52 <emu> you can load your buffer with a keyclick, and cursor over names will display info and type in the minibuffer
17:04:05 <emu> you can interact with the haskell prompt inside emacs
17:04:10 <falconair_> that's what i wanted
17:04:32 <dmwit> Nobody writes these things for vim! =(
17:04:41 <emu> indentation, alignment of =, and probably other things i haven't used
17:04:49 <dmwit> I guess I'll have to get on it...
17:05:14 <dolio> :) Yeah. I've been using vim lately, and I miss haskell-mode.
17:05:18 <emu> plus the useful rectangle mark/kill/yank commands
17:05:35 <emu> which is nice with the layout syntax
17:05:49 <dmwit> emu: Is that something you miss, or just another feature you're telling falcon about?
17:06:08 <emu> feature
17:06:11 <emu> brb
17:06:51 <lennart> ?users
17:06:53 <lambdabot> Maximum users seen in #haskell: 235, currently: 191 (81.3%), active: 21 (8.9%)
17:07:46 <musasabi> Lemmih: created a patch to haskell-src-exts and will send it to upstream to support the splices.
17:14:57 <dons> there's a reasonable perl binding for vim, we could use that to add a haskell-mode
17:15:14 <dons> ?todo-add Write haskell-mode for vim
17:15:15 <lambdabot> Entry added to the todo list
17:21:58 * edwardk waves hello.
17:28:37 <dmwit> @hoogle FiniteMap
17:28:38 <lambdabot> Data.FiniteMap :: module
17:28:38 <lambdabot> Data.Graph.Inductive.Internal.FiniteMap :: module
17:28:38 <lambdabot> Data.FiniteMap.FiniteMap :: data FiniteMap key elt
17:31:47 <SyntaxNinja> new galois job description! http://www.haskell.org/pipermail/haskell-cafe/2006-August/017716.html
17:31:49 <lambdabot> Title: [Haskell-cafe] Galois Connections seeking a developer
17:32:48 <edwardk> hrmm. maybe should apply, will be at ICFP anyways
17:37:37 <SyntaxNinja> edwardk: yeah, we'd be glad to set up interviews during ICFP (we're in Portland)
17:38:02 <edwardk> i'll dust off a resume then.
17:38:15 <SyntaxNinja> the unwritten feature of the job is that you'd work with me ;)
17:38:17 <edwardk> though, i wouldn't be available until december, since i'm teaching this fall.
17:38:23 <edwardk> not sure if that would be an issue.
17:38:39 <dons> hehe
17:39:30 <SyntaxNinja> edwardk: worth applying; may or may not be an issue.
17:39:43 <edwardk> syntax: *nods*
17:40:23 <edwardk> if nothing else it'll get me away from standardizing linguistic ontologies ;)
17:41:36 <SyntaxNinja> now _that_ might disqualify you ;)
17:41:44 <edwardk> hahahaha
17:41:52 <SyntaxNinja> "Anyone whose previous job includes 'ontologies' need not apply" ;)
17:42:02 <edwardk> eep! =)
17:42:07 <kpreid> dons: aww, running lambdabot doesn't have my patch?
17:42:33 <SyntaxNinja> edwardk: just kidding :)
17:42:48 <edwardk> hey the linguists pay the bills and let me keep the lights on at the moment. kinda fell into it by accident since they were the only game in town willing to let me up and leave to go teach classes in the middle of the day ;)
17:42:57 * SyntaxNinja gots ta run. email me if you have questinos baout the job!
17:43:01 <edwardk> will do
17:43:06 <edwardk> thanks for the info.
17:43:09 <SyntaxNinja> np
17:43:19 <dons> kpreid: not yet.i'll push it later today
17:43:26 <kpreid> ah, sure
17:43:28 <edwardk> ooh ooh, what patch? =)
17:43:45 <kpreid> it just bugs me to see people supplying type signatures for standard functions :)
17:50:03 <dons> I think we should have a plugin that behaves like a really broken floating point unit, just for laughs
17:50:17 <dons> since people think 0.1 + 0.2 is so bad ;)
17:51:20 <dons> ?remember Jan-WillemMaessen I was trying to understand the bignum-heavy Read instance for Double in the report, and ended up with a nasty headache
17:53:01 <edwardk> heh
17:53:10 <edwardk> @early-intel ?
17:53:10 <lambdabot> Unknown command, try @list
17:53:14 <dons> ?karma+ sjanssen more patches
17:53:14 <lambdabot> sjanssen's karma raised to 14.
17:53:30 <dons> yeah, something liek that, edwardk :)
17:54:57 <edwardk> gah closures seem to make store typing a pain in the neck =/
17:55:21 <edwardk> coz the size of the element is based on the number of free variables, not the number of arguments for the function, etc. =(
17:58:30 <dons> interesting! http://marc.theaimsgroup.com/?l=netbsd-users&m=115698047302492&w=2
17:58:34 <lambdabot> Title: 'The future of NetBSD' - MARC
17:58:49 <dons> some ideas that apply to furthering haskell there I think
17:59:40 <dons> particularly we want to ensure the meritocracy, where people continue compete to produce new code/features/...
18:04:05 <lispy> how do i list the constructors of a data type using TH?
18:04:13 <lispy> i literally want to put the constructors in a list
18:05:13 <edwardk> don't you jus stick them in the dataD?
18:05:24 <lispy> what do you mean?
18:05:32 <lispy> [d| .. |] ?
18:05:47 <edwardk> nah using the $(dataD ...) stuff
18:05:57 <lispy> hmm...okay i'll look for that
18:06:22 <edwardk> dataD :: CtxQ - Name -> [Name] -> [ConQ] -> [Name] -> DecQ
18:06:33 <edwardk> the ConQ list is where your constructors go
18:07:03 <lispy> i want to extract the list of constructors
18:07:17 <edwardk> oh, not build a list =)
18:07:20 <lispy> so i have Data Foo = F1 | F2 | F3 | ... | Fn
18:07:20 <edwardk> sorry
18:07:41 <lispy> and i want to create [F1, F2, F3, ..., Fn] automatically
18:08:16 <edwardk> you wat Data.Typeable no?
18:08:19 <edwardk> er want
18:08:29 <lispy> so then i want Name -> [ConQ] ?
18:08:45 * lispy hasn't looked at Data.Typeable yet
18:08:50 <edwardk> unfortunately you can't really get there right from TH.
18:08:55 <lispy> @hoogle Name -> [ConQ]
18:08:56 <lambdabot> No matches, try a more general search
18:08:59 <edwardk> TH doesn't give much insight into other code.
18:08:59 <emu> enumerable?
18:09:13 <Igloo> reify the type and then just pattern match on it
18:09:14 <lispy> emu: i'm trying to generate Enum instances a certain way
18:09:14 <SamB> edwardk: um
18:09:14 <edwardk> TH lets you write your own code automatically. it doesn't provide reflection services.
18:09:18 <SamB> you can!
18:09:24 <musasabi> lispy: how about using Enum?
18:09:28 <SamB> edwardk: it does!
18:09:32 <edwardk> samb: where?
18:09:33 <SamB> unless they took 'em out!
18:09:34 <emu> can't you derive Enum and be able to do [F1..]
18:09:59 <edwardk> ahh the Info stuff?
18:10:01 <lispy> i derived Enum but the default derivation didn't make me happy
18:10:01 <emu> and the default enumeration is lexicographic
18:10:01 * edwardk digs in
18:10:07 <musasabi> > [False ..]
18:10:09 <lambdabot>  [False,True]
18:10:11 <edwardk> i never noticed that before =)
18:10:19 <SamB> of course, its probably fairly inconvenient to do exactly what lispy wants...
18:10:31 * lispy nods at SamB
18:10:51 <lispy> Igloo: so, reifyDecl is no more and i should use reify?
18:11:18 <lispy> Igloo: because i'm not sure i understand what you're telling me to do :)
18:11:34 <Igloo> lispy: Yes
18:12:08 <edwardk> ok, so you just reify the name and get back the Info, but how do you get to a data constructor list from there?
18:12:27 <musasabi> edwardk: just walk the datastructure.
18:12:31 <Igloo> The info contains the DataD, which contains the Cons as above
18:12:38 <lispy> ah!
18:12:39 <lispy> thanks
18:12:45 <musasabi> hmm. weird scoping issue:
18:12:52 <musasabi> import qualified A
18:12:53 <musasabi> foo = "This is weird"
18:12:53 <musasabi> instance A.Foo () where foo = ()
18:12:58 <Igloo> dons: Interesting, ta
18:13:03 <musasabi> and this is legal.
18:13:44 <edwardk> Name, Type, Name, Fixity, where are the constructors?
18:13:45 <dons> Igloo: makes me think. things like fgl and wxHaskell have become 'locked', and don't progress. I wonder what we do about that
18:14:04 <lispy> dons: 'locked' ?
18:14:05 <dons> darcs , for one, helps unlock fptools at least
18:14:09 <Igloo> dons: The flipside is that if you don't have a maintainer for a given library, then no-one will apply patches sent for it, though
18:14:14 <musasabi> edwardk: have you tried to look at Streams or SerTH code which does exactly that.
18:14:19 <dons> lispy, just pondering http://marc.theaimsgroup.com/?l=netbsd-users&m=115698047302492&w=2
18:14:21 <lambdabot> Title: 'The future of NetBSD' - MARC
18:14:30 <dons> Igloo: right. you need active maintainers
18:14:32 <edwardk> musasabi: nope. just learned it was possible 2 minutes ago ;)
18:14:41 <edwardk> i'd been appealing to typeable before now
18:14:52 <dons> e.g. fps and lambdabot work quite well, and I mostly just review the incoming patches
18:15:09 <dons> maybe we need to actively assign maintainers
18:15:18 <edwardk> ah i see it now
18:15:19 <edwardk> thanks
18:15:24 <lispy> edwardk: where is it?
18:15:39 <edwardk> TyConI contains a Dec
18:16:08 <lispy> ah, thanks
18:16:25 <emu> hm, I had to type [(F1)..] for it to work
18:16:31 <dons> another thing is code reviews. It would be nice to implement the openbsd policy that nothing goes in without at least one other person's ok, for non-core contributors. we have vaguely this policy, but it could be well defined
18:16:51 <Igloo> dons: I think I'm missing something. When you take up waterskiing and stop applying patches etc, don't fps and lambdabot become locked too?
18:16:55 <emu> or [F1 ..]
18:16:59 <edwardk> though i think emu's idea of just deriving enum is clean =)
18:17:22 <dons> Igloo: well, at least they're ope. anyone else could grab it from darcs and start maintaining
18:17:26 <dons> open
18:17:41 <Igloo> dons: How is wxHaskell not open?
18:18:03 <dons> no, fgl and wxHaskell are open. they're just lagging for some reason
18:18:05 <dons> trying to work out why
18:18:35 <Igloo> I've lost track of whether you're arguing for or against maintainers of libraries
18:19:42 <dons> ok, let's see. take the case of fgl. Martin maintains it. but its sorely in need of updating.
18:20:15 <dons> so it would appear to be a case of a 'locked' project: you have to send stuff to martin, which may take a long while to propagate back
18:20:18 <lispy> edwardk: yeah and after my refactoring i think i may have fixed the problem with the default Enum derivation...guess i'll run with this for now and worry about my custom enum later
18:20:19 * musasabi thinks it is more of a case "make libraries simple and easy to dig in"
18:20:26 <dons> musasabi: yes, that may be it
18:20:54 <emu> what's this literate haskell stuff i see mentioned
18:20:55 <dons> darcs has certainly helped out base/ I think (and fps and lambdabot, from my experience)
18:21:12 <musasabi> with lambdabot and fps it is very easy to make changes, with things like fgl and wxhaskell one must first spend time (and get sidetracked) before getting anything done.
18:21:28 <lispy> from what i've seen, unless you're hitting the wall with darcs, it's a huge help
18:21:28 <musasabi> darcs is good.
18:21:30 <dons> why's that do you think?
18:21:43 <dons> is it due to the complexity of fgl, say. or other reasons?
18:21:53 <lispy> wxhaskell is very hard to get compiling
18:22:02 <lispy> that makes it a pain to contribute to
18:22:31 <dons> maybe some guidelines for libraries might be useful. a) cabal b) darcs c) haddock ...
18:22:39 <dons> i.e. some kind of style/best practice document
18:23:24 <lispy> as a library user one of the things that concerns me is how 'alive' the project is and how mature
18:23:32 <dons> I think in general we are doing things right. we have leadership,fairly decoupled components now, breaking things is frowned upon, competition works
18:23:34 <Igloo> Hmm, couldn't half of teh boiler plate at the top of modules come from the .cabl file? That would make it easier to change maintainers
18:23:38 <lispy> (but maybe i'm going on a tangent)
18:24:21 <dons> Igloo: yeah, maybe if it was easier to reassign maintainers.
18:24:33 <LordBrain> Hey
18:24:35 <dons> or just to have well established maintainers for the libraries
18:24:52 <lispy> what about an orphan system?
18:24:53 <dons> ie.. not just libraries@haskell.org
18:24:58 <LordBrain> i'm using sockets... and i'm having a little problem where i think i'm running out of input from a socket and its closing the handle as a result
18:25:11 <dons> lispy: they should be listed as orphans, and we seek people to take maintainership?
18:25:13 <musasabi> Old stale documentation is worse than no documentation at all sometimes.
18:25:18 <lispy> dons: yes
18:25:36 * Igloo would like to say maintainer changing to   Don Stewart <libraries@haskell.org>   so everyone still gets teh patches, but we know it's Don's job to apply them
18:26:15 <dons> i bet if we look at the projects whose maintainer:     libraries@haskell.org, they'd be the ones more likely to bit rot
18:26:23 <lispy> dons: when the maintainer is inactive for a while, the project becomes 'orphaned' and listed somewhere...people are encouraged to apply for stewardship of orphaned projects?
18:26:23 <dons> Igloo: yeah
18:26:23 <Igloo> The problem comes when the maintainer gets too busy to maintain well, but doesn't want to let the library go
18:26:39 <dons> true
18:29:20 <Igloo> and I think your URL above is arguing against assigning maintainers for that reason
18:29:20 <Igloo> But if we don't do that then it ends up being Simon M (or possibly me, now) who is defacto maintainer of everything
18:29:20 <lispy> darcs receives patches faster than can be reviewed and applied by the current maintainers.  What do you do in that case?
18:29:20 <dons> right. you don't want fixed maintainers who become a bottleneck
18:29:20 <edwardk> > $(do x <- reify(mkName "Just") ; return $ LitE $ StringL $ case x of {TyConI (DataD _ _ _ _ _) -> "TyConI"; PrimTyConI _ _ _ -> "PrimTyCon"; VarI _ _ _ _ -> "Var"; ClassI _ -> "ClassI"; DataConI _ _ _ _ -> "DataCon"; otherwise -> "Gah!"  })
18:29:20 <lambdabot>  Parse error
18:29:20 <lispy> so the community is the maintainer?
18:29:20 <lispy> is that possible?
18:29:20 <dons> but we also don't want to have 2 guys at Haskell HQ responsible for all packages
18:29:20 <edwardk> er.. well that says 'DataCon' with TH on and working right
18:29:20 <edwardk> but I can't seem to reify $ mkName "Maybe"
18:29:20 <dons> lispy: that's kind of the idea with libraries@haskell.org, but its the same as being orphaned for packages other than base
18:29:20 <Igloo> lispy: We currently have "the community is the maintainer" officially, which in practice means "Simon Marlow is the maintainer of absolutely everything"
18:29:20 <LordBrain> hmmmm if you have multiple maintainers i suspect you will have the problem that both people slack thinking the other one will pick it up
18:29:20 <lispy> edwardk: maybe you need the "a" ?  try it with a less polymorphic type?
18:29:20 <edwardk> a where?
18:29:33 <LordBrain> how can i keep a handle open even tho it hits the end of file?
18:29:35 <dons> if we look at libraries with no actual maintainer, they are: unix, template-haskell, stm, readline, network, mtl, html, haskell98, base, X11, QuickCheck
18:29:36 <lispy> edwardk: well, you're trying to get the constructors of Maybe, but it's really "Maybe Foo" that you should be using?
18:29:43 <dons> most of which are kept up to date by SimonM et al
18:29:56 <edwardk> well, the problem is reify takes a name
18:29:56 <dons> then there are others with actual maintainers, like fgl, that become bottlenecks
18:30:08 <edwardk> so if you can't feed it a name you're screwed for using the reify interface ;)
18:30:13 <lispy> edwardk: and you used mkName "Maybe", so you're good right?
18:30:22 <lispy> ah
18:30:24 <edwardk> mkName "Foo" works fine for all foo
18:30:34 <LordBrain> i guess i need to do lower level IO
18:30:38 <dons> in openbsd you have a range of 'comitters' to whom patches can be submitted for feedback and committing.
18:30:42 <Igloo> dons: So what we've concluded is that neither way works?  :-)
18:30:43 <dons> no one really owns any part of the tree.
18:30:58 <dons> but you can always find someone who can review and commit your code
18:30:58 <musasabi> Lemmih: zerothHead now works for me in a very good fashion :-)
18:31:12 <dons> Igloo: so maybe we don't want 1:1 bindings of people to packages
18:31:38 <dons> but rather a listed set of people who can review and commit to anywhere, (or redirect to someone who can review that code)
18:31:39 <Igloo> dons: That sounds like the current libraries@ again, though
18:31:51 <LordBrain> yeah have multiple people with commit access is good
18:32:01 <dons> but if I send a patch to libraries@, we just hope simonM picks it up
18:32:13 <dons> i will get feedback though
18:32:18 <lispy> @type simonM
18:32:19 <lambdabot> Not in scope: `simonM'
18:32:23 <LordBrain> lol
18:33:05 <dons> maybe if the people who are willing to review and commit were listed somewhere, patches send to libraries@ could be picked up and dealt with explicitly
18:33:21 <dons> i.e. 'I'll look at this' messages
18:33:53 <dons> so, say someone sends in a patch, we actually get someone other than Simon to look at the code, review, feedback, and then commit when its good
18:34:58 <dons> with discussion on libraries@ too, when appropriate
18:34:58 <lispy> what about having the patches come in and then in a round robin fashion they are forwarded to capable maintainers so as to distribute the load?
18:34:58 <dons> roughly that yes.
18:34:58 <dons> patches come in, people on libraries@ with commit access need to say "I'll take this", and then it is assigned to them. they review, etc and commit
18:34:58 * Igloo wonders if patches should go to a BTS instead
18:35:15 <lispy> BTS?
18:35:16 <dons> rather than now, where anyone comments but basically simonM says ok == too much load on simon
18:35:42 <lispy> dons: i think getting people to step up when you have a lot of maintainers might become an issue
18:35:57 <Igloo> Bug Tracking System
18:37:02 <musasabi> darcs send -> Trac could work, but would that be better?
18:37:02 <emu> @hoogle listM1
18:37:02 <lambdabot> No matches found
18:37:02 <emu> @hoogle liftM1
18:37:02 <lambdabot> No matches found
18:37:34 <lispy> i would advocate this.  The BTS would then have a special place just for submitted patches where people can find them and review them
18:37:34 <musasabi> @type liftM
18:37:34 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
18:37:34 <edwardk> ok. so in the end i can't seem to work back from a datacon to the data type to get to the constructor list. i've pretty much walked the entire tree, so reify seems like a dead end.
18:37:55 <edwardk> i can extract the  name of the data type, but not any particulars about it
18:37:59 <emu> thanks
18:38:02 <lispy> edwardk: you couldn't get the constructor names?
18:38:34 <edwardk> no, coz i can't get my hands on an appropriate Info instance.
18:38:56 <musasabi> edwardk: go via TyConI
18:38:58 <edwardk> reify seems to stick to the namespace of variables and constructors, not types.
18:39:13 <edwardk> $(do x <- reify $ mkName "Just" ; return $ LitE $ StringL $ case x of {TyConI (DataD _ _ _ _ _) -> "TyConI"; PrimTyConI _ _ _ -> "PrimTyCon"; VarI _ _ _ _ -> "Var"; ClassI _ -> "ClassI"; DataConI n1 t n2 f -> "DataCon " ++ nameBase n1 ++ " " ++ nameBase n2 ++ " " ++ case t of {ConT _ -> "ConT"; VarT _ -> "VarT"; AppT _ _ -> "AppT"; ForallT _ _ _ -> "ForallT"; otherwise -> "oh bugger"}; otherwise -> "Gah!"  })
18:39:20 <dons> So I'm thinking that to improve response times, we would have a well defined system for review and acceptance of patches. it could go via the BTS or the mailing list. But we just need to have a set of people who can be _expected_ to look at things. I.e.the present system but with more emphasis on getting non-simon committers to look at, review and commit things ?
18:39:21 <musasabi> 'Foo = constructor, ''Foo = type
18:39:27 <edwardk> if i change "Just" to "Maybe" i would expect back a TyConI but i don't get one.
18:39:55 <edwardk> prefix it in the string for the name?
18:40:08 <musasabi> "reify ''Maybe" should work.
18:40:22 <edwardk> reify $ mkName "Maybe" blows up
18:40:23 <lispy> dons: hehe, you could give simon a quota.  Once he looks at, say, 5 patches a week he's not allow to sign off on any more :)
18:40:44 <edwardk> heh
18:40:45 <edwardk> ok
18:40:48 <edwardk> now i'm seeing things
18:41:04 <lispy> TH isn't the best documented feature of Haskell
18:41:25 <lispy> it's mostly documented in the research papers and they seem to be out of date on the syntax and notation
18:41:47 <edwardk>  
18:41:47 <edwardk>  
18:41:47 <edwardk> <interactive>:1:2:
18:41:47 <edwardk>     `Maybe' is not in scope at a reify
18:41:47 <edwardk>     In the definition of `it':
18:41:47 <edwardk>         it = $[splice](do
18:41:49 <edwardk>                          x <- reify $ (mkName "Maybe")
18:41:51 <edwardk>                          return $ (LitE $ (StringL $ (case x of TyConI (DataD _ _ _ _ _) -> ...))))
18:42:07 <lispy> edwardk: did you try, x <- reify ''Maybe
18:42:15 <musasabi> reify only quoted names, mkName can cause problems.
18:42:16 <edwardk> i can call reify $ mkName "Maybe" and its ok until i wrap it in an actual Q monad
18:42:47 <musasabi> it is possible to hack around that, but not in nice ways.
18:42:49 <lispy> edwardk: i should warn you that i've since given up and used deriving (Enum)
18:43:05 <dons> Igloo: i.e. I think I just want you (well its your job now), me, Ross and other non-Simons to take on this review/commit work. so that when someone sends in something, we can be sure someone will look at it, do the quality review, and get it committed or rejected
18:43:07 <edwardk> lipy: i know, i just want to figure it out
18:43:21 <edwardk> musasabi: um, reify expects a name, how do i get there from your quoted string?
18:43:23 <lispy> edwardk: okay :)
18:43:24 <dons> before we get a bus error
18:43:28 <edwardk> other than via mkName?
18:43:36 <musasabi> @type ''Maybe
18:43:37 <lambdabot> lexical error in string/character literal
18:43:50 <musasabi> ''Maybe has the type Name.
18:43:58 <edwardk> k
18:44:17 <edwardk> AHHHHH
18:44:18 * heatsink never knew about that TH syntax
18:44:19 <edwardk> ok
18:44:25 <edwardk> i'd never seen that before =)
18:44:37 <edwardk> sorry for being so thick
18:45:03 <lispy> heatsink: yeah, that's what i was trying to say about the TH documentation...I didn't see it documented either
18:45:09 <musasabi> np. (was just fighting a few hours with TH myself)
18:45:14 <lispy> > [| ''Maybe |]
18:45:15 <lambdabot>  Parse error
18:45:32 <lispy> hmm...i though lambdabot could do TH now
18:45:38 <lispy> > [| 1 |}
18:45:38 <lambdabot>  Parse error
18:45:40 <lispy> > [| 1 |}
18:45:40 <lambdabot>  Parse error
18:45:41 <heatsink> What does mkName do vs. double apostrophe vs. [| |]
18:45:42 <lispy> gad
18:45:45 <lispy> > [| 1 |]
18:45:45 <lambdabot>  Parse error
18:46:28 <heatsink> well... [| |] is a Q Exp, right.
18:47:20 <musasabi> heatsink: they create different sorts of Names.
18:47:35 <lispy> > $( 1 )
18:47:35 <lambdabot>  Parse error
18:48:27 <heatsink> So... (VarE $ mkName "Foo") vs. (VarE 'Foo) vs. [| Foo |]
18:48:33 <dons> no TH in the Language.Haskell parser
18:48:46 <dons> > $(id 1) -- wsa that the trick?
18:48:46 <lambdabot>  Parse error
18:48:54 <edwardk> > $(do x <- reify ''Maybe ; return $ LitE $ StringL $ case x of {TyConI (DataD _ _ a b c) -> "TyConI: " ++ (concat $ intersperse "," $ map (\d -> nameBase $ case d of NormalC n _ -> n) b)})
18:48:54 <edwardk> "TyConI: Nothing,Just"
18:48:55 <lambdabot>  Parse error
18:48:57 <dons> > $id 1
18:48:57 <lambdabot>  Parse error
18:48:58 <edwardk> woot
18:48:59 <edwardk> ok
18:49:03 <edwardk> thanks a ton musa =)
18:49:09 <heatsink> bleh, that's obviously wrong, hold on.
18:49:34 <edwardk> never mind the horrible hack job getting there ;)
18:49:41 <edwardk> since i was just writing it all on the ghci command line
18:49:45 <heatsink> (ConE $ mkName Foo) vs. (ConE 'Foo) vs. [| Foo |]
18:50:36 <lispy> so there is single and double quote?
18:50:57 <edwardk> heatsink: well, i would say that the difference is how long you've been using TH and whether you know about the shorter versions ;)
18:51:01 <lispy> > [| 1 |] -- this should print 1
18:51:01 <lambdabot>  Parse error
18:52:14 <edwardk> you know you've been using haskell too long when you bake a $ operator into your lambda calculus.
18:52:17 <heatsink> one of the black magic things to me is how TH resolves names to the correct module.  Does it resolve the same way in all cases?
18:52:37 <heatsink> edwardk, I've gotten errors from using $ at the type level before :)
18:52:54 <edwardk> heatsink: yeah thats why i want it as a language primitive ;)
18:53:20 <edwardk> data OxF a = I$I$I$I a
18:53:30 <edwardk> er type
18:54:41 <LordBrain> @index io
18:54:41 <lambdabot> bzzt
18:54:46 <LordBrain> @type io
18:54:47 <lambdabot> Not in scope: `io'
18:55:08 <lispy> one thing that disappointed me about TH was that you can't walk over a module just given the name
18:55:13 <edwardk> @index IO
18:55:13 <lambdabot> System.IO, Prelude
18:55:14 <lispy> (at least i didn't see a way to do that)
18:55:34 <LordBrain> yeah, the lowercase io must be defined somewhere in lambdabot
18:55:38 <musasabi> How did one tell GHC that foo.abc is a haskell source file?
18:55:41 <lispy> oh, i wonder if it's possible to combine scrap your boiler plate with the TH types
18:56:42 <edwardk> lispy: well, i would say you can't, then someone will come along and show me up with weird ' prefixes and the game will be afoot once more ;)
18:57:54 <lispy> heh
18:58:05 <lispy> well, if i could walk a module then i wouldn't need a parser
18:58:12 * edwardk nods.
18:59:01 <dons> Igloo: so I think i'll just start reviewing patches that come in more actively :)
18:59:29 <dons> and maybe CCing people who know the code and might be able to comment
18:59:44 <lispy> i keep thinking i'll do that with darcs, but then i get distracted or annoyed and don't do it
19:00:14 <dons> so e.g. if a patch comes in to fgl, i'll take a look , comment, cc. Martin, and try to resolve it as a reject or a commit
19:00:38 <dons> Igloo: in openbsd there's a convention that if there is a "Maintainer timeout" then anyone can commit to a package
19:00:56 <dons> which is roughly what we want, I think, so things can always move forward.
19:09:03 <dons> Igloo: I might write up some commit and library guidelines describing what is expected to be done to get a patch in to the libraries
19:21:07 <araujo> hello here
19:25:52 <lispy> dons: that is good
19:34:54 <araujo> @yarr!
19:34:54 <lambdabot> Well Ahoy! thar.
20:04:18 <dmwit> @photontorpedo
20:04:18 <lambdabot> as u scale and complexity grows?
20:04:27 <dmwit> @photontorpedo
20:04:28 <lambdabot> and haskell is general purpose?
20:05:38 <dons> ?photonto
20:05:39 <lambdabot> Unknown command, try @list
20:05:42 <dons> ?photontorpe
20:05:43 <lambdabot> Unknown command, try @list
20:05:45 <dons> ?photontorpedo
20:05:46 <lambdabot> scheme, lisp, php, python, perl, tcl, al banned
20:06:02 <dons> ?photontorpedo
20:06:03 <lambdabot> how does haskell compare to c++?
20:06:13 <dons> what a bizarre troll that guy was
20:06:32 <edwardk> dons: heh
20:09:20 <dmwit> Wait, those are actual quotes?
20:09:26 <dons> uh huh.
20:09:35 <Cale> ?photontorpedo
20:09:36 <lambdabot> why haskell over lisp?
20:09:37 <dmwit> O.o
20:09:41 <Cale> ?photontorpedo
20:09:41 <lambdabot> windows is validating itelf a lot during ownloads altely
20:09:44 <johnnowak> dmwit: :)
20:09:49 <Cale> ?photontorpedo
20:09:50 <lambdabot> or does it become a mishmash of code?
20:10:00 <Cale> ?keal
20:10:00 <lambdabot> primary elemental assumption of integer coefficients to roots in counting sytem is wrong
20:10:01 <dons> bottom of : http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Quote/Text.hs
20:10:01 <dmwit> lambdabot: I have perl bok but saw haskell and am woner hey this is new and improved and seems powerful because MIT guy philip green says haskell adn lisp are only langs where u spend more tie thinking than
20:10:09 <Cale> keal was more fun :)
20:10:11 <Cale> ?keal
20:10:11 <lambdabot> can you make a macro that builds the expression accoridng to a genetic algorithm where you decide what is good and what is bad?
20:10:15 <Cale> ?keal
20:10:15 <lambdabot> its because the timeline diverges and past events themselves unhappen
20:10:23 <dons> keal was more fun.
20:10:26 <Cale> ?keal
20:10:26 <lambdabot> i think it because mathematics damage you cpu
20:10:41 <dons> protontorped was just depressing, that someone would do that for 10 months
20:10:54 <dons> it doesn't uplift the human spirit
20:11:22 <Cale> In the time he'd taken asking questions about whether Haskell was worth learning, he could have learned Haskell :)
20:11:31 <Cale> ?keal
20:11:32 <lambdabot> i changed my user od
20:11:35 <Cale> ?keal
20:11:35 <lambdabot> primary elemental assumption of integer coefficients to roots in counting sytem is wrong
20:11:38 <Cale> ?keal
20:11:38 <lambdabot> with KealDigit quantum crackproof encryption possible
20:11:45 <dons> that's a great quote
20:11:48 <dons> i'd love that on a tshirt
20:11:53 <Cale> hehe
20:11:57 <Cale> ?keal
20:11:57 <lambdabot>  what have you been smoking? you narrow minded Haskell user?
20:12:03 <Cale> haha
20:12:04 <Cale> ?keal
20:12:05 <lambdabot> what are epsilons?
20:12:33 <Cale> ?keal
20:12:33 <lambdabot> tomorrow i share next mathematical secrety
20:12:46 <dmwit> Taken from the margin, no doubt.
20:13:08 <Cale> heh, it's not really a mathematical secret, but it's secrety
20:13:24 <dmwit> It has the secret nature.
20:13:29 <dmwit> =)
20:13:35 <Cale> ?keal
20:13:36 <lambdabot> you need a Zh function in Haskell
20:14:19 <Cale> ?keal
20:14:20 <lambdabot> Cale etc already pointed out Haskell is puny to nothing to emulate using my barrage of mathematic theories
20:14:29 <Cale> haha
20:14:50 <Cale> I love how he claims that I pointed that out
20:15:06 <dmwit> I like "doctor just give meds not fix prollem".
20:16:11 * johnnowak attempts to build lambdabot
20:17:27 <edwardk> so who was this keal person anywyas?
20:17:41 * edwardk lives in terror of the day there is an edwardk ;)
20:17:47 <edwardk> er ?edwardk
20:18:20 <dmwit> =P
20:23:28 <dmwit> @b52
20:23:29 <lambdabot> She drove a Plymouth Satellite faster than the speed of light!
20:24:47 <emu> this is probably a dumb question, but how do you write (\n -> n - 1) in short hand notation? writing (-1) just gives (negate 1) instead of partial application
20:25:08 <Cale> (+ (-1)) ?
20:25:11 <emu> i guess
20:25:13 <dmwit> (1 -)
20:25:20 <Cale> (1 -) is different :)
20:25:25 <emu> that's 1 - _
20:25:33 <dmwit> ...
20:25:34 <dmwit> =(
20:25:38 <edwardk> > (subtract 1) 2
20:25:39 <lambdabot>  1
20:25:59 <Cale> yeah, they put subtract in the prelude as an apology for that bit of syntax
20:26:07 <edwardk> yeah
20:26:07 <emu> ah, =)
20:26:14 <edwardk> down with negative numbers! =)
20:26:19 <edwardk> heh
20:27:09 <edwardk> of course, i also would want + and * to be freed up to express sum and product types, and & and | for other linear operators, etc. =)
20:27:20 <edwardk> so i guess i'm on a slippery slope
20:29:12 <johnnowak> i'm getting a 'could not find module "maybe"' error when compiling lambdabot on ubuntu. anyone have a hint?
20:30:06 <edwardk> i got nothing ;)
20:30:39 <johnnowak> lovely :)
20:31:38 <johnnowak>  it is a member of package haskell98-1.0, which is hidden
20:32:00 <edwardk> change the import to Data.Maybe?
20:32:01 <edwardk> =)
20:33:22 <johnnowak> edwardk: thanks :)
20:33:35 <johnnowak> er
20:33:50 <johnnowak> ghc-6.4.1: panic! (the `impossible' happened, GHC version 6.4.1): This compiler was built without a native code generator
20:34:58 <johnnowak> well. that sucks.
20:35:20 <edwardk> upgrade ghc and go to bed? =)
20:36:00 <johnnowak> i'm using the debian packages
20:36:08 <johnnowak> why am I not surprised that I should've built it myself :)
20:36:26 <johnnowak> useless package managers!
20:38:19 <edwardk> heh
20:39:25 <dmwit> Oh!
20:39:36 <dmwit> It's (-) 1.
20:39:42 <dmwit> No.
20:39:56 <dmwit> Blast, I'm tired.
20:39:58 <dylan> johnnowak: what debian? etch, sid?
20:40:12 <johnnowak> dylan: 'tis ubuntu
20:40:23 <dolio> flip (-) 1
20:40:28 <johnnowak> the info on the package just indicates they stole it from debian... no idea which
20:41:18 <dolio> ?pl \x -> x - 1
20:41:18 <lambdabot> subtract 1
20:42:33 <dylan> 'cause my ghc does native code just fine..
20:43:10 <dylan> @pl \x -> x + 1
20:43:11 <lambdabot> (1 +)
20:45:46 <dylan> subtract is flip (-), yeah?
20:46:03 <dolio> I think so.
20:46:24 <dylan> seems to be the case.
20:46:29 <dylan> > flip (-) 4 5
20:46:31 <lambdabot>  1
20:46:35 <dylan> > subtract 4 5
20:46:36 <lambdabot>  1
20:47:04 <dylan> ?pl \x -> x / 2
20:47:05 <lambdabot> (/ 2)
20:47:06 <johnnowak> dylan: i should probably just put etch on here now that there's an up to date kernel
20:47:24 <dylan> johnnowak: I always build my own kernels with make-kpkg. :)
20:47:39 <johnnowak> dylan: i just want to get some work done for a change :)
20:47:49 <johnnowak> last week was linux fun week :)
20:48:03 <dylan> heh
20:48:34 <dylan> I just copy debian's .config, get a new kernel source and run make-kpkg.
20:54:22 <Korollary> ?users
20:54:24 <lambdabot> Maximum users seen in #haskell: 235, currently: 185 (78.7%), active: 20 (8.5%)
20:55:50 <Korollary> My whin(g)ing continues: we wants max active!
21:00:15 <edwardk> heh
21:09:52 <johnnowak> can anyone tell me why dons's ByteString installs to /f/g/.. ?
21:10:11 <johnnowak> i wasn't aware the root of my hierarchy needed an /f directory
21:11:24 <Korollary> what did you specify as prefix for Setup.hs?
21:12:13 <johnnowak> i, er, didn't
21:12:39 <johnnowak> was my first time using such a thing :)
21:12:55 <johnnowak> regardless, /f/g is an interesting default.
21:12:59 <Korollary> I don't know what the default is. It shouldnt be something silly like that, tho
21:14:04 <Korollary> it looks like /usr/local if omitted
21:14:13 <Korollary> see .setup-config
21:14:17 <johnnowak> hm. thanks
21:14:50 <Korollary> @where fps
21:14:51 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
21:15:25 <johnnowak> why is it called fps?
21:15:44 <edwardk> fast packed string
21:16:04 <johnnowak> hm.
21:16:21 <edwardk> later renamed to data.bytestring as i recall
21:16:28 <edwardk> but the old name stuck
21:16:36 <johnnowak> edwardk: yes, i was wondering why the inconsistency
21:16:45 <johnnowak> i went looking for bytestring and suddenly i was downloading fps :)
21:16:53 <edwardk> i think there was a data.bytestring when it started
21:17:28 <Korollary> No
21:17:39 <edwardk> or was it just decided that was a better name?
21:17:45 <johnnowak> hm. well ubuntu's ghc barfs when i try to compile lambdabot and it looks like fun to get it installed from source on ppc linux...
21:18:52 <Korollary> There was something called PackedString (written during darcs development iirc). FPS was meant to replace it and get into ghc. A flurry of emails, yadda yadda, Data.ByteString.
21:19:09 <edwardk> ah thats what it was
21:19:18 <edwardk> i knew there was a name conflict somewhere =)
21:21:24 * johnnowak looks confused
21:25:04 <Korollary> Setup.hs configure is fine, but it fails to build?
21:28:08 <johnnowak> Nah, we're all good now. :)
21:28:51 <dons> it was just decided that Data.ByteString was better than FastPackedString
21:29:00 <dons> (i.e. it was a _fast_ PackedString type)
21:29:15 <dons> but yadda yadda people complain Char /= Word8, so String /= ByteString
21:29:58 <Korollary> How is the unicode support?
21:30:10 <Korollary> Is sjanssen done with it?
21:30:27 <dons> just waiting on the final status report.
21:30:31 <dons> much has been done though
21:30:49 <dons> we have a Storable a => Vector a now :)
21:30:55 <dons> so you can pack anything you want in
21:31:15 <Korollary> Where's Vector?
21:34:34 <dons> haskell.org/darcs/something/fps-soc
21:34:36 * edwardk wonders how many chunks a FPS style structure should be in before it becomes worth it to spawn of processes to do things like that in parallel. (I realize this is more of a question for DPH)
21:34:47 <dons> http://darcs.haskell.org/SoC/fps-soc
21:34:50 <lambdabot> Title: Index of /SoC/fps-soc
21:35:05 <dons> edwardk: not sure. but i've been pondering the same thing...
21:35:12 <edwardk> just curious about comparing the cost of processing a run of 32 or 64k ompare with the cost of spawning the thread
21:35:17 <dons> in fact we have a student running dph stuff on a GPU now
21:35:23 <dons> which I wouldn't mind binding to
21:35:29 <edwardk> haha
21:35:30 <dons> to do say, bzip2
21:35:34 <edwardk> how is that working for you?
21:35:36 <dons> over streams, in a coprocessor
21:36:06 * edwardk nods.
21:36:32 * dons -> meeting
21:36:42 <edwardk> i did a simple haar/daubechies wavelet decompressor in the gpu way back when
21:36:59 <edwardk> but havent kept up with current shader languages, etc.
21:38:24 <Korollary> @foldoc dph
21:38:25 <lambdabot> No match for "dph".
21:38:41 <Korollary> What is dph?
21:39:21 <edwardk> data.parallel haskel
21:39:27 <Korollary> ah
21:41:18 <edwardk> @tell dcoutts btw- i like data.bytestring.lazy, very clean =)
21:41:19 <lambdabot> Consider it noted.
21:47:07 <dibblego> guten tag
21:47:25 <kfish> guten morgen mate
21:47:44 <edwardk> project guten berg? =)
21:48:19 * edwardk <<- dumb american, pretends other languages doesn't exist ;)
21:48:29 <edwardk> we don't
21:48:32 <edwardk> er don't
21:49:00 <edwardk> mainly coz I have enough trouble with english
22:12:28 <dibblego> given a function f(x) -> y, for all values of x, there is exactly one y; for some, but not all, values of y, there exists exactly one x, but for some other values of y, there exists more than one x - what is this property called? "surjective" and "injective" are not fully descriptive
22:13:04 <monochrom> Not injective.
22:13:30 <dibblego> yeah that
22:13:30 <monochrom> Almost all functions fit this description.
22:13:57 <dibblego> ok, so the fact that some values of y can infer x means nothing?
22:14:13 <monochrom> means nothing.
22:14:21 <dibblego> ok then, thanks
22:16:24 <dibblego> a one way hash cannot be described in this way
22:16:45 <dibblego> for any given y, there are infinite values of x
22:16:54 <lament> um.
22:16:58 <lament> Depends on the hash.
22:17:07 <dibblego> MD5, SHA
22:17:14 <lament> for example, 0 hashes to 0, everything else hashes to 1
22:17:20 <dibblego> right
22:17:59 <monochrom> a one-way hash of good quality probably spread things out quite evenly.
22:18:55 <monochrom> A certain man is happy sometimes and unhappy some other times.  What is this property called?
22:19:04 <monochrom> "John Doe"
22:19:30 <Cale> mood inconstancy?
22:19:40 <dibblego> ok, I think I see your point
22:19:48 <monochrom> injectiveness inconstancy :)
22:20:00 <lament> monochrom: called "needs to get laid more"
22:20:46 <lament> and the function needs a smaller domain :)
22:21:02 <monochrom> Very good ideas.
22:21:32 <Cale> permutations and combinations really ought to be in Data.List
22:22:12 <Cale> Perhaps someone could add some reasonable implementations before GHC 6.6 is released?
22:23:06 * araujo thinking to write a small tutorial about object-oriented programming on Haskell
22:23:26 <Cale> selections would be good to have around as well.
22:23:41 <dons> ?uptime
22:23:42 <lambdabot> uptime: 3 days, 3 hours, 11 minutes and 13 seconds
22:23:45 <araujo> eh, article ....
22:24:12 <edwardk> araujo: have you read oohaskell and the hlist stuff?
22:24:20 <Cale> dons: Who do we bug about things like that?
22:24:28 <dons> what's this? /me reads up
22:24:45 <Cale> dons: add permutations, combinations, selections to Data.List
22:24:49 <araujo> edwardk, in a brief glance
22:24:50 <dons> Cale, what you do is write the code, and send it to ghc-cvs as a darcs patch
22:25:05 <dons> (that's what i've been doing for forM / repeatM)
22:25:08 <araujo> edwardk, my intentions is to show the native flexibility of the language
22:25:14 <araujo> are*
22:25:15 <dons> if its done and simple, it can probably go straight in
22:25:20 <Cale> ah, okay
22:25:27 <Cale> I'll have to pull the repo
22:25:27 <edwardk> araujo: *nods*, though its a little tricky coz records suck so bad in haskell ;)
22:25:29 <dons> Cale, as long as its not too controversial, like the split* saga
22:25:50 <Cale> split*?
22:25:57 <edwardk> araujo: so anything beyond simple cases quickly falls away from the natural OO style of other languages.
22:26:05 <araujo> edwardk, well, i was thinking about a combination of, Class Type +Data Type + Records
22:26:05 <dons> split/splitWith.tokens/blah blah/yadda yadda/no agreement/no code
22:26:28 <araujo> edwardk, and who wants to be like other languages? :-)
22:26:43 <edwardk> araujo: the record problem comes in coz you have no way to extend a record other than doing a tail pointer or head pointers into your superclasses.
22:26:44 <dons> Cale, other nice things would be fst3,snd3,thd3 from the cc.prelude, SimonM already gave that an ok, if someone writes the patch
22:26:51 <araujo> egh, Type Class i meant ...
22:27:09 <edwardk> so you can't get all of your method accesses with one clean syntax without falling into the hlist approach, which doesn't perform well
22:27:09 <Cale> dons: as prelude functions?
22:27:20 <kowey> araujo: are you also planning a word on the phantom type stuff used in wxhaskell?
22:27:20 <lambdabot> kowey: You have 1 new message. '/msg lambdabot @messages' to read it.
22:27:46 <dons> Cale, Data.Tuple
22:27:48 <Cale> aha
22:28:01 <edwardk> dons: is it stopping with 3 or going higher? =)
22:28:04 <Cale> Is there a Data.Ord yet?
22:28:22 <dons> you could steal the code from http://www.cse.unsw.edu.au/~dons/data/cc.prelude and add haddocks
22:28:25 <Cale> (and in particular, is my 'comparing' function in there?)
22:28:32 <dons> edwardk: i'm inclined to stop at 3. though 7 is sometimes a good number
22:28:34 <araujo> edwardk, i was thinking to use 'records' just like instance accessors
22:28:53 <dons> module Data.Ord (
22:28:53 <dons>    Ord(..),
22:28:53 <dons>    Ordering(..),
22:28:53 <dons>    comparing,
22:28:53 <dons>  ) where
22:28:55 <araujo> For single objects , that is it.
22:28:59 <Cale> dons: cool :)
22:29:04 <dons> comparing :: (Ord a) => (b -> a) -> b -> b -> Ordering
22:29:04 <edwardk> fth and fth for fourth and fifth are ambiguous, so good reason to stick with  3
22:29:04 <dons> comparing p x y = compare (p x) (p y)
22:29:06 <edwardk> ;)
22:29:11 <Cale> dons: Which darcs repo do I pull?
22:29:15 <araujo> kowey, i don't know wxhaskell
22:29:21 <dons> let me see...
22:30:01 <edwardk> and using the full word would conflict with any future similar extension of arrows, so i guess it would have to stop with 3 =/
22:30:16 <dons> Cale, http://hackage.haskell.org/trac/ghc/wiki/GhcDarcs
22:30:17 <lambdabot> Title: GhcDarcs - GHC - Trac
22:34:20 <kowey> araujo : if interested, http://www.citeulike.org/user/kowey/article/455115 (shows how they cram wxWidget's oo hierarchy into Haskell doing funky things with phantom types)
22:34:23 <lambdabot> Title: CiteULike: wxHaskell: a portable and concise GUI library for haskell
22:34:53 <kowey> or err... something... /me doesn't know what he's talking about
22:34:54 <araujo> ok, i check
22:36:47 <eivuokko> kowey, Hiya.  Any news on wxhaskell darcs repo? :)
22:43:18 <Cale> http://www.haskell.org/pipermail/haskell-cafe/2002-June/003123.html -- hehe
22:43:20 <lambdabot> Title: Generating the n! permutations in Haskell
22:43:54 <dons> heh
22:44:20 <kowey> eivuokko: JaffaCake has responded to us... and now we're waiting for Daan to send him an ssh key
22:44:41 <hitodama> does anyone have any reccomendations for a small first project for someone who's been somewhat introduced to Haskell?
22:44:52 <dons> a sudoku solver perhaps?
22:44:56 <dons> ?wiki Sudoku
22:44:56 <lambdabot> http://www.haskell.org/haskellwiki/Sudoku
22:45:07 <kowey> eivuokko: in the meantime, we're using http://www.schroedinger1.demon.co.uk/wxhaskell/
22:45:09 <lambdabot> Title: Index of /wxhaskell/
22:45:19 <dons> Cale, oh I see you use forM in your sudoku solver :)
22:45:34 * dons is glad its in Control.Monad now
22:45:41 <Cale> dons: yeah
22:48:32 <eivuokko> kowey, Great!  I'll try building it soonish?  Does it contain your/shelarcy's patches (that weren't in cvs iirc)?
22:49:36 <kowey> eivuokko: yeah, it contains our patches
22:49:58 <kowey> eivuokko : i couldn't get it to build on OS X 10.3 :-(, but seems to build happily on Linux
22:50:44 <eivuokko> kowey, I'm Windows-based.  I just would like one gui lib that behaves nicely in Windows.  And atleast wxwidgets do, so it leaves me to extend wxhaskell if it's not enough for me.
22:51:17 <int-e> dons: oh, it's in Data.Traversable, too. :)
22:51:55 <kowey> eivuokko: (one piece of good news is that 2/6 of us, Jeremy and shelarchy, are Windows-based too... so hopefully this means Windows people will be well taken care of)
22:52:27 <kowey> another 2/6 are mac based, 1/6 linux, and 1/6 unknown
22:53:04 <eivuokko> Heh
22:53:29 <dons> int-e, yes :)
22:53:33 <dons> ?karma+ ross
22:53:33 <lambdabot> ross's karma raised to 1.
22:53:58 <dons> kowey: you guys should make a Haskell-on-Windows wiki page, to collect useful information
22:54:06 <eivuokko> Does he (ross) come here?
22:54:46 <dons> I don't think so
22:54:56 <eivuokko> Thought so :-(
22:55:12 * kowey searches the wiki
22:59:38 <kowey> dons: how's this for a stub? http://www.haskell.org/haskellwiki/Windows
22:59:40 <lambdabot> Title: Windows - HaskellWiki
23:03:51 <dons> ok good!
23:04:04 <dons> you might want to look at the Apple and BSD pages too
23:05:37 <kolmodin> oh, there's a forM now. great! :)
23:06:36 <kolmodin> so no more flip mapM list $ \x -> do ...
23:06:40 <Cale> Hmm, does anyone have implementations of permutations and combinations which work well with infinite lists?
23:06:55 <Cale> I suppose I could write them, but I'm feeling lazy at the moment
23:07:03 <dons> yeah, or (`mapM` [1..10]) $ \_ -> do ...
23:07:15 <Cale> The versions included in Haskell 1.3 only worked on finite lists.
23:08:32 <dons> nope, sorry :}
23:08:54 <dons> we need ?hoogle-src which searches all *.hs files in the known universe for funcitons of a certain type or name
23:09:08 <dons> is there a google hack we could use to do that?
23:09:22 <dons> (restrict searches to files with a particular prefix?)
23:11:41 <dons> kpreid: around? seems to be some weirdness with your @free patch
23:11:53 <dons> (is it possible that ghc 6.5 returns forall a. * that messes things up?
23:12:13 <dons> kpreid: lambdabot> free fmap
23:12:19 <dons> Expected variable or '.'
23:12:51 <edwardk> is there any good set of GADT examples other than the little haskell wiki page, the original paper and david roundy's blurb on darcs?
23:13:15 <dons> there's henrik's paper on space invaders with gadts
23:13:25 <dons> either ICFP or HW 2005
23:13:30 <edwardk> heh going looking
23:13:35 <kowey> dons: perhaps something useful for 'I am a FooOS user, and need help' questions : http://www.haskell.org/haskellwiki/Category:OS
23:13:37 <lambdabot> Title: Category:OS - HaskellWiki
23:13:59 <dons> yeah good idea!
23:14:02 * dons adds openbsd
23:14:09 <edwardk> the yampa arcade
23:14:26 <dons> was that 2005?
23:15:05 <kosmikus> 2003, I think
23:15:24 <edwardk> 2003, but i didn't see any real use of GADTs on first glance
23:15:33 <dons> edwardk: there was a 2005 paper adding GADTs
23:15:41 <dons> at ICFP, iirc
23:15:47 <kosmikus> oh
23:15:48 <edwardk> kk looking for it
23:16:28 <kosmikus> ?google dynamic optimization for functional reactive programming
23:16:34 <lambdabot> http://portal.acm.org/citation.cfm?id=1086374&dl=ACM&coll=&CFID=15151515&CFTOKEN=6184618
23:16:37 <dons> when you find it, stick it up on haskell.org's http://haskell.org/haskellwiki/Research_papers/Functional_reactive_programming page?
23:16:38 <lambdabot> Title: Research papers/Functional reactive programming - HaskellWiki
23:16:40 <dons> ah
23:16:50 <musasabi> Is there a function to get the size of an Integer in bits?
23:16:55 <edwardk> heh if i can =)
23:16:56 <dons> that's the one.
23:17:15 <edwardk> heh its not on his personal site's publication page yet
23:17:17 <dons> musasabi: oh hmm. i think there is such a function. but you'll have to implement it
23:18:18 <kosmikus> edwardk: I think it is ...
23:18:42 <kosmikus> ?google henrik nilsson publications dynamic optimization
23:18:45 <musasabi> the plain division method looks slow, just looking inside the Integer would be the easiest way and then get the exact number of bits by iterating division.
23:18:46 <lambdabot> http://www.cs.nott.ac.uk/~nhn/papers.html
23:18:46 <lambdabot> Title: Henrik Nilsson's Publications
23:18:51 <dons> kosmikus++ google-fu
23:19:06 <edwardk> http://www.cs.yale.edu/homes/nilsson/papers.html didnt have it
23:19:08 <lambdabot> Title: Henrik Nilsson's Publications
23:19:21 <kosmikus> edwardk: he's in Nottingham for quite some time now ...
23:19:24 <edwardk> ah
23:19:28 <edwardk> that would explain it =)
23:19:34 <dons> with no redirect?
23:19:37 <edwardk> i just followed the first thing that had his name on it =)
23:19:48 <dons> ?google Henrik Nilsson
23:19:50 <lambdabot> http://www.cs.nott.ac.uk/~nhn/
23:19:51 <lambdabot> Title: Henrik Nilsson's Home Page
23:19:55 <edwardk> its got a blurb saying that his new page can be found there
23:19:59 <edwardk> i just didn't see it
23:20:06 <edwardk> he didn't go out of his way to make it stand out ;)
23:20:54 <musasabi> @type bitSize
23:20:55 <lambdabot> forall a. (Bits a) => a -> Int
23:20:59 * musasabi feels stupid
23:21:06 <edwardk> ahh gadt arrow examples even
23:21:37 <dons> musasabi, oh _that_ :)
23:21:56 <dons> > bitSize (2^10000 :: Integer)
23:21:57 <lambdabot>  Exception: Data.Bits.bitSize(Integer)
23:22:05 <dons> > bitSize (2 :: Integer)
23:22:06 <lambdabot>  Exception: Data.Bits.bitSize(Integer)
23:22:10 <dons> > bitSize (2 :: Int)
23:22:11 <lambdabot>  32
23:22:27 <dons> ?instances Bits
23:22:28 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
23:22:30 <musasabi> hmm. not exactly what I was looking for.
23:22:42 <dons> ah yes
23:23:35 <dons> oh hmm. some TH/word size games could be played.
23:23:42 <dons> > bitSize (undefined :: Word)
23:23:43 <musasabi> hmm. I could implement it as a binary search and avoid divisions totally.
23:23:44 <lambdabot>  32
23:24:15 <dons> > 1 `shiftR` 3 :: Integer
23:24:16 <lambdabot>  0
23:25:09 <int-e> > let swapi 0 (a:b:cs) = b:a:cs; swapi n (a:bs) = a:swapi (n-1) bs; perm' l = unfoldr (\(l, f:fs) -> Just (l, (f l, fs))) (l, permf 0); permf n = let it = replicate (n+1) (swapi n) in it ++ concatMap ((++it) . (:[])) (permf (n+1)) in take 10 $ map (take 4) $ perm' [1..]
23:25:10 <lambdabot>  [[1,2,3,4],[2,1,3,4],[2,3,1,4],[3,2,1,4],[3,1,2,4],[1,3,2,4],[1,3,4,2],[3,1,...
23:25:38 <kosmikus> ?google type-safe self-inspecting code
23:25:40 <lambdabot> http://www.cs.uu.nl/people/doaitse/Talks/2004/TypeSafeSelfInspectingPrograms.pdf
23:26:00 <tieTYT> is there a way to put curly brackets around this to define it on one line? data BinaryTree a = Leaf a | Branch (BinaryTree a) a (BinaryTree a)
23:26:07 <kosmikus> edwardk: another application of GADTs ^^^
23:26:28 <kosmikus> tieTYT: no need to put any brackets around this, just put it on one line ...
23:26:40 <tieTYT> oh...
23:26:47 <tieTYT> that's easy enough
23:26:47 <tieTYT> thanks
23:27:24 <edwardk> kos: thanks =)
23:28:01 <edwardk> prototyping some stuff for the substructural things in haskell. wanted to (ab)use GADTs as much as possible.
23:28:13 <tieTYT> ok now i asked this before but i forgot.  The lhs is called a type constructor and the rhs is called a data constructor?
23:28:34 <dons> yep
23:28:58 <tieTYT> sweet, thanks
23:29:16 <dons> edwardk: maybe we should have a GADT section in the type system papers?
23:29:21 <dons> (if there isn't one already
23:29:46 <dons> structure in two pieces: theory/practice, with applications going into the latter
23:29:50 <edwardk> there is a little frilly introduction, but everyone seems to just want to reprint the original adt term evaluator example ;)
23:29:58 <Korollary> yah
23:30:10 <dons> its a great example for compiler writers ;)
23:30:14 <edwardk> heh
23:30:23 <Korollary> self serving %*&^%'s
23:30:26 <edwardk> yeah but it doesn't go far enough if you really ant to draw them in
23:30:33 <dons> heh
23:30:41 <edwardk> needs variable selection, a nice monad to chew on, etc =)
23:30:51 <edwardk> recursion...
23:31:25 <lispy> who uses recursion?
23:31:58 <dons> reminds me of the perl blogger who was complaining that haskell would never make it because it doesn't have loops
23:32:10 <edwardk> hahahaha
23:32:14 <profmakx> well
23:32:18 <dons> heh, we've even got forM now, so that should keep some people happy
23:32:18 <profmakx> good morning ;)
23:32:31 <edwardk> morning =)
23:32:41 <lispy> @hoogle forM
23:32:42 <lambdabot> Text.Html.form :: Html -> Html
23:32:42 <lambdabot> Time.formatCalendarTime :: TimeLocale -> String -> CalendarTime -> String
23:32:42 <lambdabot> System.Time.formatTimeDiff :: TimeLocale -> String -> TimeDiff -> String
23:32:49 <lispy> hmm..
23:32:50 <Cale> dons: that wasn't a perl blogger, that was Guido van Rossum, the guy responsible for Python.
23:32:52 <dons> lispy: only in ghc 6.5 branch atm
23:32:52 <lispy> @type forM
23:32:53 <lambdabot> Not in scope: `forM'
23:32:58 <dons> Cale, ah yes!
23:32:59 <lispy> ah, what is the type?
23:33:07 <edwardk> can't find forM
23:33:15 <dons> Guido/Perl blogger . easy to confuse ;)
23:33:19 <edwardk> heh
23:33:28 <lispy> @type blogger . easy
23:33:29 <lambdabot> Not in scope: `blogger'
23:33:29 <lambdabot>  
23:33:29 <lambdabot> <interactive>:1:10: Not in scope: `easy'
23:33:34 <lispy> ;)
23:33:39 <Korollary> "The guy responsible for Python" has a negative connotation lol.
23:33:41 * lispy can't parse tonight
23:33:42 <profmakx> um... that somehow lowers my respect for van Rossum..
23:33:42 <edwardk> only from the distance from the perl/python debate that the average functional programmer has, dons ;)
23:33:42 <dons> hehe
23:33:44 <tieTYT> haskell seems like it takes more brain power to use than the other languages
23:34:09 <tieTYT> or maybe that's just cause i'm used to imperative languages
23:34:17 <edwardk> tie: yeah, it does
23:34:29 <Cale> tieTYT: Well, sort of
23:34:32 <dons> tieTYT: i'm not sure. we teach it to undergrads who have little or no brain power. and they hack it fine. its more the cutting edge stuff plays mental games with you
23:34:33 <edwardk> tie: this is a good thing though. in the end you get to be a much better programmer and your code is a lot cleaner
23:34:49 <profmakx> the first reaction of a guy i spoke to about haskell was "it does not have variables?" which comes close to "it does not have loops?" i think
23:35:01 <Cale> Haskell makes it more possible for those with brain power to create powerful things
23:35:05 <dons> we don't need no stinkin' variables
23:35:06 <tieTYT> edwardk: agreed.  But just like any community, 90% of programmers are lazy idiots that don't want to think
23:35:09 <edwardk> prof: heh
23:35:21 <Cale> Powerful abstractions, I should be precise here :)
23:35:23 <Korollary> I am a lazy idiot myself at times.
23:35:31 <profmakx> haskell itself is lazy -.-
23:35:33 <int-e> @quote cjs
23:35:34 <lambdabot>  I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of these
23:35:34 <lambdabot> nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
23:35:48 <kowey> tieTYT: i use Haskell precisely because of my limited brain power (type safety got my back, yo)
23:35:52 <profmakx> yeah
23:35:58 <profmakx> @karma+ lambdabot
23:35:59 <lambdabot> lambdabot's karma raised to 20.
23:36:03 <edwardk> kowey: lol
23:36:09 <lispy> heh
23:36:12 <dons> ?remember kowey i use Haskell precisely because of my limited brain power (type safety got my, yo)
23:36:15 <Cale> kowey: yeah, that's actually quite a nice thing :)
23:36:24 <tieTYT> i've been using haskell for 3 days and i didn't even realize there aren't variables
23:36:28 <Cale> dons: how'd you lose the "back"?
23:36:31 <profmakx> or you use haskell _because_ you want to spend your brain power on important things
23:36:31 <lispy> refactoring is a lot easier in haskell
23:36:31 <tieTYT> isn't a let sorta like a variable?
23:36:32 <edwardk> you missed a 'back'
23:36:34 <dons> grr.
23:36:46 <dons> ?remember kowey i use Haskell precisely because of my limited brain power (type safety back, yo)
23:36:49 <dons> oh man
23:36:54 <edwardk> tie: it is exactly like one, you just can't reassign it
23:36:56 <Cale> tieTYT: But it only defines local constants :)
23:36:57 <lispy> lol
23:37:03 <dons> kowey: I sincerely apologise for misquoting you twice
23:37:10 <dons> i'll hack the state file and fix it
23:37:13 <edwardk> tie: well, you can but you can't do it in the i = i + 1 and loop kinda way
23:37:13 <int-e> (in case anyone looked at it. the code I posted above is not a permutation generator. but it works for small n ;) )
23:37:26 <tieTYT> anyway 2+ convos at once
23:37:30 <kowey> dons: :-D... i just hope i didn't accidentally imply that people that talk like that have limited brain power
23:37:43 <tieTYT> kowey: what you said is similar to the idea that it's good that programmers should be lazy
23:38:09 <tieTYT> that's why we reuse code instead of reinventing the wheel.  Why we define a function if we do one action more than once...
23:38:54 <kowey> it's a different kind of laziness... good programmers are willing to spend mental effort to learn things so that they save effort on boring things
23:38:58 <profmakx> my mathematician-side likes haskell as well as it is far lazier than my compsci side ;)
23:38:59 <tieTYT> anyway that stuff actually takes discipline.  Programmers call it laziness but I think it's more of a skill
23:39:30 <kowey> and the reason why i say "good programmers" is that the boring things is where you can make pointless mistakes
23:39:42 <lispy> well, i want the compiler to do as much work for me as it possibly can...
23:39:42 <tieTYT> yes
23:39:45 <kowey> i mean, if you're going to make mistakes, you might as well make interesting ones
23:39:52 <Korollary> We define abstractions because we are lousy at reading code. Better at remembering.
23:39:54 <tieTYT> haha
23:40:17 <lispy> i like type checking because the compiler just did a bunch of work for me
23:40:31 <edwardk> kosmikus: i can't find a gadt in that set of slides, either =)
23:40:33 <tieTYT> i think that's why everybody that likes it likes it
23:40:42 <lispy> when i write code in php i have to test every line and every branch to make sure the types make sense
23:40:48 <Korollary> Nah. People like type checking for the compile errors.
23:41:02 <tieTYT> Korollary: isn't that what he just said?
23:41:15 <Korollary> He worded it more gently
23:41:30 <lispy> @karma- php
23:41:31 <lambdabot> php's karma lowered to -1.
23:41:53 <profmakx> still too high
23:41:58 <tieTYT> heh
23:42:02 <profmakx> by far too high
23:42:12 * lispy just remembered spending 2 hours trying to figure out why his sql query had a syntax error in 'Array'
23:42:39 <lispy> in php, if you pass an Array where a string is expected it just converts it to the string literal 'Array'
23:42:48 <lispy> no warning, no errors...just converts it
23:43:16 <tieTYT> yep that can suck
23:43:19 <kosmikus> edwardk: sorry, which set of slides?
23:43:21 <Korollary> dwim please
23:43:23 <int-e> I'm sure some people will claim that that's an advantage
23:43:24 <profmakx> the blessings of dynamic typing -.-
23:43:24 <tieTYT> well it'll always suck
23:43:45 <tieTYT> int-e: what would those people say in its defense?
23:43:55 <lispy> well, in some dynamically type languages you'd at least get an error about type mismatch
23:44:08 <edwardk> lispy: you should try writing coldfusion some time. whenever the rest of the world does it one way, they go their own. add kludgy syntax, random <cf ... > tags around everything and season to taste.
23:44:30 <Adamant> can you do macros with static typing?
23:44:40 <int-e> tieTYT: they'll quote an obscure example where you need that exact behaviour.
23:44:42 * lispy doesn't really like web programming because it's all so dynamicy and broken
23:44:43 <edwardk> kos: i thought you posted the link about  http://www.cs.uu.nl/people/doaitse/Talks/2004/TypeSafeSelfInspectingPrograms.pdf
23:45:04 <tieTYT> lispy: i'm sure that depends on the language
23:45:11 <int-e> tieTYT: granted it would be easier if they'd not convert to "Array" but to a concatenated string of its contents.
23:45:11 <lispy> Adamant: you can do template haskell and that's more or less staticly typed and quite powerful
23:45:14 <profmakx> as a side note: my english vocabulary sucks
23:45:29 <kosmikus> Adamant: http://www.cs.uu.nl/~arthurb/macros.html
23:45:31 <lambdabot> Title: Syntax Macros
23:45:44 <kosmikus> edwardk: yes. it doesn't exist?
23:45:49 <tieTYT> lispy: or i'm not sure what you mean by dynamicy
23:45:55 <tieTYT> you can do web stuff in C# and java
23:46:06 <edwardk> it exists, just didn't see the gadt part
23:46:12 <lispy> tieTYT: yeah :(
23:46:33 <lispy> tieTYT: java, C#, perl, php and so on all have a lot of the same frustrating problems
23:46:53 <profmakx> curly braces?
23:46:57 <tieTYT> well java is strictly typed like haskell too
23:46:59 <kosmikus> edwardk: oh right. that's because they didn't exist (in GHC) yet.
23:47:01 <therp> hm this talk-macros.pdf mentions a "core haskell". is that specified somewhere more precisely?
23:47:01 <tieTYT> and C#
23:47:16 <lispy> tieTYT: not really, but yeah they try to
23:47:23 <therp> slide #3 in http://www.cs.uu.nl/~arthurb/data/Macros/Talk-Macros.pdf
23:47:24 <kosmikus> edwardk: look on page 20, there's the declaration of the Parser type using the "Equal" type to express an equality constraint between two types manually.
23:47:31 <edwardk> kos: heh no problem. got confused as to the intent
23:47:35 <edwardk> kos: *nods*
23:47:39 <kosmikus> edwardk: that's nothing more than an encoded GADT. you'd write this using a GADT now.
23:47:41 <tieTYT> lispy: in what way not really?
23:47:41 <Adamant> in my limited experience, what matters less than static/dynamic typing, is strong vs. weak typing.
23:48:14 <lispy> tieTYT: http://www.ciscavate.org/blog/?p=12
23:48:17 <lambdabot> Title: Bitwise Evolution Â» foreach(What?)
23:48:33 <Adamant> C is statically typed, but I don't think anyone thinks it's type system is particularly strong.
23:48:40 <edwardk> Symbol (Equal Char t) Char    got it
23:48:40 <tieTYT> Adamant: i'm not so good at this vocab (these concepts are very badly named imo).  What i mean is that in java if you're variable is a String, you can't use it like an int
23:49:16 <Cale> lisppaste2: url
23:49:17 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
23:49:27 <lispy> tieTYT: my point is that java and C# have a lot of holes in their type saftey
23:49:27 <Korollary> therp: It could be the STG language
23:49:39 <lispy> tieTYT: that link i gave you gives one instance from C#
23:49:47 <lisppaste2> Cale pasted "golf time?" at http://paste.lisp.org/display/25030
23:49:53 <Adamant> tieTYT, static typing is checked at compile time, dynamic typing is at least in part checked at run-time
23:50:02 <edwardk> tie: yeah they have a decent strict type system, but its a weaker "Nominal" type system, in which the only real types come from associating a type with a class. as a result everything winds up being a class and requires way too much code to insert a simple type.
23:50:02 <kosmikus> edwardk: there's also a paper about this. but I can't find it online.
23:50:13 <Adamant> what you are talking about is "strong vs. weak" typing, IIRC.
23:50:19 <Cale> Note that 'perms' here works on infinite lists, and I'd like to preserve that. It's not particularly efficient though.
23:50:59 <kowey> tieTYT: another thing to consider is what i call 'fancy' vs 'simple' typing (is there an official term for this?)
23:51:24 <kowey> tieTYT: by 'fancy' typing, i mean all sorts of cool things, like type variables and parametric polymorhism (which java 1.5 now has?)
23:51:43 <Korollary> powerful/modern type systems?
23:51:46 <Cale> typeclasses :)
23:51:47 <lispy> generics in java are flawed
23:52:00 <edwardk> kowey: 'sexy types' as simon pj calls them
23:52:09 <tieTYT> kowey: i can answer that for you if you explain what they are
23:52:10 <kowey> oooh, i _like_ that
23:52:13 <lispy> for instance, clone is not generic and requires a cast whenever you use it
23:52:15 <edwardk> higher order polymorphism, extistentials, etc.
23:52:24 <tieTYT> i'v enever heard the term type variables/parametric polymorphism
23:52:35 <kosmikus> ?google sexy types in action
23:52:39 <lambdabot> http://www.eecs.harvard.edu/~ccshan/cs252/usage.pdf
23:52:43 <Adamant> what do you guys consider to be the main advantages of Haskell's type system, besides the fact it can be verified at compile time?
23:52:45 <edwardk> tieTYT: you might have heard of them as templates.
23:53:04 <tieTYT> i've heard of templates in C++.  I think they're similar to java's Generics
23:53:07 <kosmikus> kowey: ^^^ nice survey paper
23:53:11 <lispy> Adamant: type classes, parametric polymorphism and algebraic data types
23:53:14 <tieTYT> i know what java's generics are, but i'm not sure if they're the same as C++ templates
23:53:15 <dolio> Heh.
23:53:25 <dolio> Templates are turing complete.
23:53:40 <edwardk> tieTYT: java's generics are c++ templates without the performance boost or syntactic benefits of typedef ;)
23:53:45 <kowey> kosmikus: yay, bedtime reading :-)
23:53:47 <lispy> tieTYT: well, java generics don't exist at run-time, if that helps you see differences :)
23:53:52 <tieTYT> but regardless, the syntax for Java generics are really ugly and take a lot of effort to use correctly wherever possible
23:54:02 <Cale> Adamant: Well, not just that it happens at compile time, but that it actually manages to catch about 95% of the things which would be bugs in a language with a less fancy type system.
23:54:19 <edwardk> tieTYT: yeah largely because they forgot typedef
23:54:30 <edwardk> tieTYT: its the only thig that makes c++ templates even remotely usable
23:54:50 <Korollary> Adamant: I think Haskell's type system captures and documents the intent of the programmer effectively. There is no dearth of abstraction mechanisms.
23:55:19 <Cale> Debugging time for Haskell programs seems much lower than for programs in other languages, and I'd say it's almost entirely due to the type system.
23:55:27 <Adamant> Cale - I'm not familiar with "fancy type" systems, just the usual suspects of C/C++/Java... what kind of bugs does Haskell's type system catch over Java?
23:55:50 <dons> any kind of property you want to encode in the type system..
23:55:53 <Cale> Adamant: Well, let's look at a simple example...
23:56:00 <Adamant> most of my "functional" language experience is CL/Scheme/Mosquito Lisp
23:56:06 <dons> i.e. "this function always returns a sorted list" is a property you could encode, with sufficient effort
23:56:22 <tieTYT> edwardk: i'm not fluent enough in C++ to know about the effect a typedef would have on java
23:56:22 <Korollary> Java vs Haskell is a difficult comparison since the languages are so different.
23:56:25 <Cale> map :: (a -> b) -> [a] -> [b] -- this says that map takes a function from values of type a to values of type b, and a list of values of type a, and returns a list of values of type b
23:56:30 <Cale> map [] = []
23:56:39 <Cale> map f x = x : map f xs
23:56:43 <Cale> this has a bug
23:56:45 <edwardk> my biggest problem with haskell's type system is it really DOES have a hard time encoding traditional c++ style oop. oohaskell doesn't count ;)
23:56:51 <Cale> it will be caught at compile time
23:57:18 <Cale> In particular, it's not applying the function f to the list
23:57:25 <dons> edwardk, *shrug* this is not the land of nouns
23:57:29 <lispy> Cale: um...that would be caught in most languages because xs is undefined :)
23:57:38 <Cale> er, sorry
23:57:44 <Cale> map f (x:xs) = x : map f xs
23:57:56 <Cale> that's the buggy line I wanted :)
23:58:09 <astrolabe> a buggy bug
23:58:14 <edwardk> tieTYT: typedef lets you create short aliases for templates, that can then be associated with other templates. so you can refer to say, type_traits<int>::reference in a truly generic fashion. in java you lack that ability to make types depend on types as cleanly. it removes  whole class of ready abstractions.
23:58:41 <edwardk> or once you have defined your 256 character template you can give it a 4 character typedef name ;)
23:58:48 <edwardk> and only have to change it in one place
23:58:58 <dolio> Cale: You could do that in C++ too, couldn't you? :)
23:59:00 <edwardk> not that c++ templates are good, but they are hella better than java generics.
23:59:04 <Korollary> Adamant: This is something that Java cannot catch: http://lambda-the-ultimate.org/node/1527
23:59:06 <lambdabot> Title: Type checking and logical errors | Lambda the Ultimate
23:59:24 <tieTYT> edwardk: ah that's kinda cool
23:59:27 <Cale> dolio: Yes, possibly, using templates.
23:59:36 <tieTYT> yeah i could see where i'd want that in java when i use generics
23:59:44 <gour> python irc friend who wants to see me in python camp, send me this one http://www.mindview.net/WebLog/log-0025
23:59:44 <qz> edwardk, generics and templates are different
23:59:46 <lambdabot> Title: Bruce Eckel's MindView, Inc: 5-2-03 Strong Typing vs. Strong Testing
23:59:58 <qz> and they coexist in say c++/cli
