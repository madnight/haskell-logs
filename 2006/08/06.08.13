00:00:06 <LordBrain> a plug for fp in that paper might not be all that desirable
00:00:10 <edwardk> what happens if you wrote the compiler? =)
00:00:49 <therp> edwardk: big bang "in a pocket"? :)
00:00:58 <LordBrain> its not supposed to be free of contraditions... you just have to accept it and stop thinking
00:02:25 * edwardk has never understood faith-based anythging, so *shrug*
00:03:47 * edwardk is pretty firmly in the atheist/secular humanist camp.
00:04:10 <edwardk> but thats about ll the religion i think i want to drag into a programming channel =)
00:04:14 <satan> hmm how do i get adjacent pairs from a list as tuples, as in, fn [1,2,3] should give [(1,2),(2,3)]?
00:04:39 <LordBrain> hmmm
00:05:03 <Olathe> zip [1, 2, 3] (tail [1, 2, 3])
00:05:04 <sjanssen> > let l = [1, 2, 3] in zip l (tail l)
00:05:05 <lambdabot>  [(1,2),(2,3)]
00:05:20 <satan> wow how did you do that? heh
00:05:51 <edwardk> sjanssen beat me to the punch =)
00:06:05 <sjanssen> and Olathe beat us all
00:06:08 <sjanssen> showoff.
00:06:14 <Olathe> I cheated :)
00:06:17 <LordBrain> Olathe?
00:06:24 <Olathe> I copied the Fibonacci example.
00:06:25 <satan> thanks :)
00:06:32 <edwardk> let l = [1,2,3] in ap zip tail l
00:06:41 <edwardk> > ap zip tail [1,2,3]
00:06:42 <lambdabot>  [(1,2),(2,3)]
00:07:07 <Olathe> What is ap ?
00:07:13 <edwardk> @type ap
00:07:15 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
00:07:24 <edwardk> the above is a dirty trick using Control.Monad.Reader
00:07:30 <Olathe> Hmmm...WinHugs doesn't have it :(
00:07:38 <Olathe> Oh, OK.
00:08:59 <satan> so the 2 is repeated because its an odd number of elements, what if it was [1,2,3,4] and you wanted [(1,2),(3,4)]?
00:09:10 <vincenz> LordBrain: I don't like my code to be god free, after all god wrote it
00:09:16 * vincenz looks down at -his- own code
00:09:54 <satan> sorry, i'm new to all this, learning haskell
00:10:13 <LordBrain> why be sorry?
00:10:30 <sjanssen> satan: use pattern matching and recursion, (x:y:xs) is your first pattern to match
00:10:31 <vincenz> be happy you're learning the Righteous Ways (TM) of haskell, satan
00:10:35 <LordBrain> no, satan, zip is a function  which creates pairs out of two lists
00:11:09 <LordBrain> > zip [1,2,3] ['a','b','c']
00:11:10 <lambdabot>  [(1,'a'),(2,'b'),(3,'c')]
00:11:15 <satan> ok
00:11:21 <vincenz> > zip "LordBrain" "lambdabot"
00:11:21 <satan> right, zips em together
00:11:22 <lambdabot>  [('L','l'),('o','a'),('r','m'),('d','b'),('B','d'),('r','a'),('a','b'),('i',...
00:12:05 <edwardk> > let m (x:y:xs) = (x,y):m xs; m (x:[]) = []; m ([]) =  [] in m [1,2,3,4]
00:12:06 <lambdabot>  [(1,2),(3,4)]
00:12:26 <edwardk> or something like that
00:12:33 <edwardk> not as pretty =)
00:13:17 <satan> ok lemme absorb it :)
00:13:20 <Stinger_> isnt there a function that takes every nth element of a list or similar?
00:13:27 <vincenz> no
00:13:29 <edwardk> stinger: none in the prelude or data.list
00:13:36 <Stinger_> hmm surprising
00:13:42 <edwardk> stinger: otherwise that would have been easy =)
00:13:49 <vincenz> easy :)
00:13:54 <Stinger_> yeah well I kinda expected it to be :)
00:14:28 <vincenz> > let every n l = take 1 l ++ every n (drop n l) in every 2 [1..10]
00:14:32 <lambdabot> Terminated
00:14:43 <vincenz> o.O
00:15:06 <vincenz> > let every n l = take 1 l ++ every n (drop n l); every n [] = [] in every 2 [1..10]
00:15:07 <lambdabot>    Warning: Pattern match(es) are overlapped
00:15:08 <lambdabot>        In the definition...
00:15:18 <vincenz> > let every n [] = []; every n l = take 1 l ++ every n (drop n l) in every 2 [1..10]
00:15:19 <lambdabot>  [1,3,5,7,9]
00:15:21 <vincenz> :)
00:15:46 <Stinger_> I take it lambda bot doesnt remember bindings :)
00:15:50 <vincenz> nope
00:15:56 <vincenz> I had asked dons for that, thou
00:16:02 <vincenz> that'd be a nifty feature
00:16:16 <Stinger_> indeed
00:16:22 <edwardk> hrmm, per person memory would be cooler =)
00:16:29 <vincenz> edwardk: that was my original suggestion to dons
00:16:41 <edwardk> ha
00:16:43 <edwardk> er ah
00:16:45 <Stinger_> or even switchable per person, set a mode :)
00:16:54 <Stinger_> global/personal :)
00:17:21 <Stinger_> of course. I can imagine some chaos going on with global bindings heh
00:17:31 <vincenz> yeah
00:17:34 <vincenz> best to have perperson
00:17:35 <edwardk> global could get bad
00:17:39 <vincenz> and only for ident'd nicks
00:17:44 <edwardk> per person with a reset binding would be good
00:17:44 <vincenz> dons: ping
00:17:55 <Stinger_> hahah
00:17:56 <vincenz> dons: how hard is it to allow features only for ident'd nicks?
00:17:59 <edwardk> vincenz: bah, then i can't use it =)
00:18:02 <Stinger_> hey dons: code this please :)
00:18:17 <vincenz> I could prolly do it myself
00:18:21 <sjanssen> it's probably simpler to just import qualified more modules
00:18:43 <vincenz> sjanssen: true but you have the whole don't do IO restriction
00:18:50 <vincenz> sjanssen: that becomes harder to maintain with other modules
00:18:58 <vincenz> besides
00:19:02 <vincenz> how would the syntax work?
00:19:04 <vincenz> @define
00:19:05 <vincenz> ?
00:19:05 <lambdabot> (line 1, column 1):
00:19:05 <lambdabot> unexpected end of input
00:19:05 <lambdabot> expecting white space or simple term
00:19:08 <sjanssen> vincenz: right, you just don't import those modules
00:19:32 <vincenz> another issue would be code layout
00:19:37 <vincenz> I mean we use the ; now
00:19:40 <vincenz> for multi bindings on a line
00:19:50 <vincenz> but that would get more difficult with different bindings done at differnt times
00:19:51 <sjanssen> we already have a bunch of static imports, right?  Why not just expand them to any module you could possibly want
00:20:12 <vincenz> an import per definition?
00:20:20 <sjanssen> vincenz: I'm talking strictly expanding the modules imported, no new code
00:20:24 <vincenz> oh
00:20:32 <vincenz> I think the original idea is to have custom bindings
00:20:35 <vincenz> aka I do
00:20:38 <vincenz> @let every ...
00:20:38 <lambdabot> No module "every ..." loaded
00:20:41 <vincenz> and from then on I can use every
00:20:52 <sjanssen> ah, I see
00:21:08 <sjanssen> but then nobody will understand you when you use 'every'
00:21:50 <vincenz> sjanssen: noone understands now when people write one liner code :P
00:21:53 <vincenz> no I'm kidding
00:21:57 <vincenz> but possible we could do
00:22:03 <vincenz> @whatis vincenz every
00:22:03 <lambdabot> http://www.esat.kuleuven.ac.be/~cpoucet/
00:22:08 <vincenz> erm, right
00:22:22 <vincenz> an even better idea:
00:22:36 <vincenz> have lambdabot have a website with an @paste syntax per user
00:22:41 <vincenz> so you can define your ibndings there
00:23:08 <sjanssen> hmm, integrating lambdabot with a pastebin could be cool
00:23:11 <vincenz> with some security features such as: not allowed to choose your imports, maximum cap on filesize
00:23:42 <vincenz> sjanssen: yeah, plus it wouldn't be difficult, just as difficult as @eval now
00:24:15 <vincenz> lambdabot: vincenz has pasted "http://xxxx" it results in "yyy"
00:24:50 <vincenz> or even prettyprinting the result in the output html page
00:24:52 <vincenz> so it's referrable
00:27:26 <vincenz> Anyways
00:27:29 <vincenz> bbye people
00:27:31 <vincenz> cya in  2 weeks
00:28:05 <edwardk> later vincenz
00:28:21 <vincenz> @where+ vincenz Sardinia
00:28:21 <lambdabot> Done.
00:30:06 <dons> what do we want? an extensible set of top level bindings?
00:30:31 <edwardk> oh for lambdabot?
00:30:41 <edwardk> i think the discussion was letting let bindings stick around statement to statement
00:30:46 <edwardk> with a way to clear em
00:31:02 <edwardk> though i dunno how that would fit into your current compilation scheme
00:31:16 <dons> right. hmm.
00:32:04 <dons> yeah, could be done
00:32:20 <dons> we just accumulate an environment, which gets dumped into each @eval
00:32:26 <dons> i.e. @let f x = x
00:32:35 <dons> then "f x = x" becomes a top level binding in future @evals
00:33:00 <dons> stick them in a Map, and have @let f x = x ; @undefine f
00:33:01 <xerox> let x = x ++ (in terms of lambdabot commands), and runstate.
00:33:02 <dons> say
00:33:09 <dons> :)
00:33:16 <dons> xerox: right
00:33:19 <dons> ?state
00:33:20 <lambdabot> (\xs -> case last (init xs) of '1' -> "rock"; '2' -> "paper"; '3' -> "scissors")
00:34:32 <xerox> ?. run . ++ . show dice 1d3
00:34:33 <lambdabot>  "paper"
00:34:39 <xerox> Your turn!
00:35:10 <edwardk> hrmm
00:35:27 <edwardk> > liftM2 ap (zip.) (.tail) (map snd . filter (odd.fst) . zip [1..]) [1..10]
00:35:28 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10)]
00:35:34 <edwardk> sad
00:35:36 <xerox> ?state (\xs -> case last (init xs) of '1' -> "rock"; '2' -> "paper"; '3' -> "scissors")
00:35:36 <lambdabot> (\xs -> case last (init xs) of '1' -> "rock"; '2' -> "paper"; '3' -> "scissors")
00:35:53 <xerox> Who wants to play?  "?. run . ++ . show dice 1d3"
00:36:22 <dons> ?. read . run . ++ . show dice 1d3
00:36:23 <lambdabot>  scissors
00:36:30 * xerox lost
00:36:37 <xerox> @yarr!
00:36:38 <lambdabot> Get out o' me way, yeh landlubber
00:37:13 * edwardk thinks satan doesn't want his answer any more
00:37:26 <satan> haha no i'm here
00:37:35 <xerox> edwardk: what about this:
00:37:40 <edwardk> the version above should work, but its a bit painful =)
00:38:04 <xerox> > let odds = 1 : map (+1) evens; evens = map (+1) odds in zip odds evens
00:38:05 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21,...
00:38:25 <edwardk> xerox: well, it was to group neighboring elements of a list, [1..10] was just convenient
00:38:42 <edwardk> > liftM2 ap (zip.) (.tail) (map snd . filter (odd.fst) . zip [1..]) [1,2,38,24,12,2]
00:38:43 <lambdabot>  [(1,2),(38,24),(12,2)]
00:38:43 <xerox> Oh I see.
00:38:47 <xerox> I think we did that in the past.
00:39:26 <edwardk> i just couldn't come up with a better way (pointlessly) than zipping up a list i could filter on then removing it
00:39:27 <xerox> Maybe some combination of unzip transpose iterate (take 2)... I gotta dash.
00:39:38 <satan> wow that's awesome, thanks edwardk
00:40:58 <xerox> A fold would also do it.
00:41:05 <edwardk> xerox: hrmm
00:41:52 <edwardk> xerox: i was just happy to get the liftM2 ap (zip.) (.tail) part right =)
00:42:31 <xerox> :)
00:42:51 <Stinger_> hmmm precidence rules only apply within an expression right?
00:42:54 * xerox goes hiking or something &
00:43:29 <Stinger_> precedence* sorry typing one handed (eating toast)
00:56:50 <LordBrain> can i do a let binding to something i just pulled out of a monad using the <- notation?
00:56:53 <LordBrain> like
00:57:45 <LordBrain> this <- Action; let suchandsuch = this + 1 in somefunc suchandsuch
00:57:51 <musasabi> yes
00:58:18 <musasabi> > do x <- Just 2; let y = x + 1; return y
00:58:19 <lambdabot>  Parse error
00:58:28 <musasabi> > (do x <- Just 2; let y = x + 1; return y)
00:58:29 <lambdabot>  Parse error
00:58:46 <musasabi> lambdabot does not like me :-(
01:00:55 <LordBrain> your sure i can do it tho right?
01:01:49 <LordBrain> > do { x <- Just 2; let y = x + 1; return y }
01:01:49 <lambdabot>  Parse error
01:01:52 <Stinger_> do x <- Just 2; let y = x + 1 in return y
01:01:56 <Stinger_> > do x <- Just 2; let y = x + 1 in return y
01:01:57 <lambdabot>  Just 3
01:02:14 <LordBrain> i thought we dont need "in" because its in a do block
01:02:20 <Stinger_> probably not :P
01:02:49 <Stinger_> thats what I thought toop actually
01:02:53 <edwardk> > map (head &&& head.tail) $ takeWhile ((>1).length) $ unfoldr (return . splitAt 2) [1..14]
01:02:55 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14)]
01:03:52 <edwardk> there is probably something simple that could be done to simplify the stuff wrapped around the unfoldr though
01:05:09 <musasabi> "in" is not needed
01:05:16 <int-e> head . tail = last in that case
01:05:21 <musasabi> for some reason the lambdabot parser is more picky
01:05:49 <edwardk> ah
01:06:10 <edwardk> > map (head &&& head.tail) $ takeWhile ((>1).length) $ unfoldr (return . splitAt 2) [1..14]
01:06:11 <Stinger_> > do x <- Just 2; (let y = x + 1) ;return y
01:06:11 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14)]
01:06:11 <lambdabot>  Parse error
01:06:12 <edwardk> er
01:06:13 <edwardk> crap
01:06:22 <edwardk> > map (head&&&last) $ takeWhile ((>1).length) $ unfoldr(return.splitAt 2) [1..14]
01:06:23 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14)]
01:06:28 <musasabi> Stinger_: try it in ghci
01:06:44 <Stinger_> yeah I know its right, checked my book :)
01:06:45 <int-e> musasabi: lambdabot has its own parser since too many people tried to escape the lambdabot and hs-plugins wrappers by adding spurious } to the expressions (and also other stuff)
01:07:04 <edwardk> int-e: ahh is that why =)
01:07:21 <int-e> musasabi: it should parse haskell expressions though - don't know why it doesn't accept valid do syntax.
01:08:06 <musasabi> int-e: that might also have something to do with layout+let+do-blocks
01:09:54 <int-e> > unfoldr (\x@ ~(a:b:cs) -> if length x > 1 then Just ((a,b), cs) else Nothing) [1..13]
01:09:55 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12)]
01:10:25 <int-e> > do  x <- Just 2; let { y = x + 1 }; return y -- is this how it worked?
01:10:26 <lambdabot>  Just 3
01:10:44 <edwardk> heh, i was just writing up a better unfoldr that was doing more or less that, but i hadn't gotten the lazy pattern
01:10:50 <vincenz> re
01:10:55 <vincenz> Anyone know some good books to print out?
01:10:59 <edwardk> unfoldr(return . (first (head&&&last)) . splitAt 2) [1..14] blows up after 14
01:11:06 <vincenz> for instance "Patterns of Software" by R.P. Gabriel  ... is it interestinig?
01:11:12 <edwardk> i was writing in the other case
01:11:52 <int-e> if pointfree code was readable, haskell wouldn't have lambdas ;)
01:12:22 <edwardk> hehehe
01:19:34 <Igloo> @seen SyntaxNinja
01:19:35 <lambdabot> I saw SyntaxNinja leaving #haskell, #darcs and #haskell-blah 1 day, 8 hours, 9 minutes and 13 seconds ago, and .
01:27:33 <syntaxfree> @hoogle String->[String]
01:27:35 <lambdabot> Prelude.lines :: String -> [String]
01:27:35 <lambdabot> Prelude.words :: String -> [String]
01:27:35 <lambdabot> Text.Regex.splitRegex :: Regex -> String -> [String]
01:28:07 <syntaxfree> > splitRegex ";"  "a;b;c"
01:28:08 <lambdabot>  Not in scope: `splitRegex'
01:28:21 <syntaxfree> > Text.Regex.splitRegex ";" "a;b;c"
01:28:22 <lambdabot>  Not in scope: `Text.Regex.splitRegex'
01:28:53 <syntaxfree> > break "a;b;c" (\x->x==d)
01:28:54 <lambdabot>  Not in scope: `d'
01:29:06 <syntaxfree> > break "a;b;c" (\x->x==";")
01:29:07 <lambdabot>  Couldn't match `a -> Bool' against `[Char]'
01:29:20 <syntaxfree> @pl \x->x==";"
01:29:21 <lambdabot> (";" ==)
01:29:23 <int-e> > break (';'==) "a;b;c"
01:29:24 <lambdabot>  ("a",";b;c")
01:29:45 <syntaxfree> int-e so, is there a function equivalent to splitDelim s d = w : splitDelim ss d where (w, ss) = break (\x->x==d)
01:29:52 <syntaxfree> short of splitRegex, which is way too general?
01:30:07 <syntaxfree> I just want to parse CSV.
01:30:29 <int-e> > takeWhile (not.null) unfoldr (Just . break (';'==)) . (';':) $ "a;b;c"
01:30:30 <lambdabot>    The function `takeWhile' is applied to three arguments,
01:30:30 <lambdabot>   but its type...
01:30:36 <int-e> > takeWhile (not.null) . unfoldr (Just . break (';'==)) . (';':) $ "a;b;c"
01:30:38 <lambdabot>  []
01:30:59 <int-e> oh.
01:31:25 <int-e> > unfoldr (\x -> if null x then Nothing else Just . break (';'==) . tail $ x) . (';':) $ "a;b;c"
01:31:26 <lambdabot>  ["a","b","c"]
01:32:10 <syntaxfree> I don't want Nothing, I want [] in case of null x
01:32:29 <int-e> not that I know of. Although words and lines make you wish there was.
01:32:37 <int-e> > unfoldr (\x -> if null x then Nothing else Just . break (';'==) . tail $ x) . (';':) $ ""
01:32:38 <lambdabot>  [""]
01:32:54 <int-e> > unfoldr (\(_:x) -> if null x then Nothing else Just . break (';'==) $ x) . (';':) $ ""
01:32:56 <lambdabot>  []
01:33:24 <syntaxfree> > unfoldr (\x -> if null x then Nothing else Just . break (';'==) . tail $ x) . (';' :) $ "a;b;c;;d"
01:33:25 <lambdabot>  ["a","b","c","","d"]
01:33:27 <int-e> the Nothing is the end-of-list marker for unfoldr
01:33:36 <syntaxfree> I see.
01:33:59 <syntaxfree> I'm reluctant to use that because I don't understand unfoldr, but it looks more robust than my recursive version.
01:34:09 <syntaxfree> (In that it handles empty columsn, which my version doesn't)
01:35:42 <syntaxfree> > let splitDelim s d = unfoldr (\x -> if null x then Nothing else Just . break (';'==) . tail $ x) . (d :) $ s in splitDelim "a;b;c;;d" ';'
01:35:43 <lambdabot>  ["a","b","c","","d"]
01:36:22 <syntaxfree> as a matter of aesthetics, would you put the delimiter as the first or second argument?
01:36:41 <Cale> splitDelim d = map (takeWhile (/= d)) . takeWhile (not . null) . iterate (drop 1 . dropWhile (/= d))
01:37:45 <int-e> ah!
01:38:09 <Cale> I'd put it first. The delimiter's less likely to change than the string.
01:38:15 <syntaxfree> true.
01:39:28 <int-e> > let splitDelim d = map (takeWhile (d /=) . tail) . filter (([d] ==) . take 1) . tails . (d:) in splitDelim ';' "a;;b"
01:39:29 <lambdabot>  ["a","","b"]
01:39:51 <syntaxfree> >let unDelim d s = foldl (\x y->x:d++y) s in unDelim  ';'  [a,b,c,,d]
01:40:00 <Cale> > let splitDelim d = map (takeWhile (d /=) . tail) . filter (([d] ==) . take 1) . tails . (d:) in splitDelim ';' "aa;;bbb"
01:40:02 <lambdabot>  ["aa","","bbb"]
01:40:14 <syntaxfree> > let unDelim d s = foldl (\x y->x:d++y) s in unDelim  ';'  [a,b,c,,d]
01:40:14 <lambdabot>  Parse error
01:40:31 <Cale> ah, cool
01:40:32 <int-e> or maybe use  filter ((d ==) . head) . init . tails
01:40:51 <edwardk> > uncurry zip $ join (***) (map snd) $ partition (odd.fst) $ zip [1..] [1..10]
01:40:52 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10)]
01:41:08 <edwardk> fun with arrows
01:41:23 <syntaxfree> > let unDelim d s = foldl (\x y->x++[d]++y) s in unDelim  ';'  [a,b,c,,d]
01:41:23 <lambdabot>  Parse error
01:41:27 <syntaxfree> :(
01:41:38 <edwardk> but it takes me back to merging a superfluous list
01:41:40 <int-e> ... partition id $ zip (cycle [True, False]) ...
01:41:55 <edwardk> ah
01:42:27 <syntaxfree> > (\x y->x++['k']++y]) "ab" "cd"
01:42:27 <lambdabot>  Parse error
01:42:30 <syntaxfree> ?
01:42:39 <Cale> int-e: hm?
01:42:48 <syntaxfree> > (\x y->x++['k']++y) "ab" "cd"
01:42:49 <lambdabot>  "abkcd"
01:42:57 <int-e> Cale: hmm what?
01:42:58 <dons> http://haskell.org
01:43:08 <vincenz> anyone?
01:43:08 <dons> hmm... is haskell.org working for anyone?
01:43:10 <syntaxfree>  > let unDelim d s = foldl1 (\x y->x++[d]++y) s in unDelim  ';'  [a,b,c,,d]
01:43:10 <int-e> Cale: I didn't like the  take 1
01:43:15 <vincenz> interesting pdf book to print out to take on airplane and train?
01:43:16 <Cale> int-e: that last line looks likely to be a type error
01:43:26 <vincenz> dons: seems down
01:43:30 <dons> :/
01:43:39 <int-e> oh! not id, fst
01:43:41 <syntaxfree> > let unDelim d s = foldl1 (\x y->x++[d]++y) s in unDelim  ';'  [a,b,c,,d]
01:43:41 <lambdabot>  Parse error
01:43:43 <int-e> sorry.
01:43:45 <syntaxfree> :'(
01:43:50 <edwardk> > uncurry zip $ join (***) (map snd) $ partition fst $ zip (cycle [True,False]) [1..10]
01:43:51 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10)]
01:44:26 <syntaxfree> > let unDelim d s = foldl1 (\x y->x++[d]++y) s in unDelim  ';'  ["a","bc","c","","d"]
01:44:28 <lambdabot>  "a;bc;c;;d"
01:44:34 <syntaxfree> :-P
01:45:18 <edwardk> neat trick, but the other version was shorter =)
01:45:34 <syntaxfree> @hoogle semicolon
01:45:34 <lambdabot> No matches found
01:45:37 <Cale> > uncurry zip . join (***) (map snd) . partition fst $ zip (cycle [True,False]) "Hello there"
01:45:38 <lambdabot>  [('H','e'),('l','l'),('o',' '),('t','h'),('e','r')]
01:46:01 <syntaxfree> um, ";" is a semicolon, right?
01:46:05 <syntaxfree> or is it a colon?
01:46:10 <Cale> semi
01:46:11 <vincenz> it's an appendix
01:47:03 <syntaxfree> @hoogle unfoldr
01:47:04 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
01:47:04 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
01:47:16 <syntaxfree> question.
01:47:23 <syntaxfree> I have a module Csv where import list.
01:47:29 <syntaxfree> I mean, import List
01:47:36 <syntaxfree> then I import that module elsewhere.
01:47:51 <syntaxfree> if I'm going to use more List functions, must I import List again?
01:48:05 <Cale> yes, unless you explicitly export it
01:48:19 <syntaxfree> how so?
01:49:02 <Cale> By including List in your export list.
01:50:21 <syntaxfree> Hmm.
01:50:29 <syntaxfree> Another doubt.
01:50:33 <int-e> oh. splitDelim d "" should actually be [""], to be consistent.
01:50:55 <LordBrain> dons: i found a c ruetine in YiUtil.c to give me the lengths of tabs between two points in the buffer. So i exposed it in FastBuffer.hs(which already had access) and Buffer.hs, and via that interface i used it in UI.hs to adjust the value of "len"
01:50:58 <syntaxfree> I'm trying to compile main.hs which imports Csv
01:51:17 <int-e> > let splitDelim d s = sd' d (d:s); sd' _ [] = []; sd' d (_:xs) = let (x,xs') = break (d==) xs in x:sd' d xs' in splitDelim ';' "abc;"
01:51:18 <lambdabot>  ["abc",""]
01:51:18 <syntaxfree> and then I have, in the same folder, csv.hs which starts with module Csv where
01:51:23 <syntaxfree> yet GHC can't  seem to find it.
01:51:54 <Cale> Try naming it Csv.hs
01:51:59 <LordBrain> dons: strangely, tho, i'm still getting the wmove error when i use w on a line with a tab
01:52:01 <syntaxfree> oh.
01:52:17 <syntaxfree> not yet.
01:52:58 <syntaxfree> oh, stupid me, I had to ghc --make
01:53:04 <syntaxfree> because Csv.hs is not yet compiled.
01:53:53 <syntaxfree> I'm so lame, I should be banned from computer programming :)
01:54:26 <syntaxfree> :t readArgs
01:54:31 <syntaxfree> @type readArgs
01:54:32 <lambdabot> Not in scope: `readArgs'
01:54:38 <syntaxfree> @type System.readArgs
01:54:38 <LordBrain> its getArgs
01:54:39 <lambdabot> Not in scope: `System.readArgs'
01:54:50 <syntaxfree> @type System.getArgs
01:54:51 <lambdabot> IO [String]
01:54:57 <int-e> @type System.Environment.getArgs
01:54:58 <lambdabot> IO [String]
01:55:19 <syntaxfree> I'm doing [file, column]<-getArgs
01:55:45 <syntaxfree> "column" is a number, though. Is there anything I can do to get it to parse a number inside a do block?
01:55:59 <int-e> let column' = read column
01:56:04 <syntaxfree> read.
01:56:06 <syntaxfree> Thanks!
01:56:08 <syntaxfree> @type read
01:56:09 <lambdabot> forall a. (Read a) => String -> a
01:56:12 <int-e> it's a string
01:56:21 <syntaxfree> yes, inside the do block it's a string.
01:56:27 <int-e> (you may need a type signature)
01:58:16 <syntaxfree> @hoogle Unique
01:58:16 <lambdabot> Data.Unique :: module
01:58:17 <lambdabot> Data.Unique.Unique :: data Unique
01:58:17 <lambdabot> Data.Unique.hashUnique :: Unique -> Int
01:58:20 <syntaxfree> int-e: I will.
01:58:25 <syntaxfree> @hoogle unique
01:58:26 <lambdabot> Data.Unique :: module
01:58:26 <lambdabot> Data.Unique.Unique :: data Unique
01:58:26 <lambdabot> Data.Unique.hashUnique :: Unique -> Int
01:59:10 <int-e> > read "123" :: Int
01:59:11 <lambdabot>  123
01:59:42 <syntaxfree> unique x:xs = if (x  elem` xs) then xs else x
01:59:46 <syntaxfree> um.
01:59:59 <syntaxfree> unique xs = if (x  elem` xs) then xs else x:(unique xs)
02:00:06 <int-e> `elem`
02:00:08 <syntaxfree> is that defined somewhere?
02:00:21 <syntaxfree> Yes. Is that defined somewhere already, though?
02:00:21 <int-e> > nub "abbbcdefbba"
02:00:23 <lambdabot>  "abcdef"
02:00:28 <syntaxfree> "nub". Why?
02:00:30 <int-e> Data.List
02:00:35 <int-e> no clue.
02:00:44 <LordBrain> heh.. yi can do f<TAB> to find the next tab
02:01:20 <int-e> -- (The name 'nub' means \`essence\'.)
02:01:35 <syntaxfree> !
02:01:39 <syntaxfree> column d m = map (!!d) m
02:01:44 <syntaxfree> is that defined anywhere? :~
02:02:05 <int-e> no.
02:02:09 <int-e> transpose is though
02:02:10 <syntaxfree> ok!
02:02:27 <syntaxfree> um, transpose sounds good enough.
02:03:04 <syntaxfree> @pl column d m = (transpose m)!!d
02:03:04 <lambdabot> column = flip ((!!) . transpose)
02:03:12 <syntaxfree> @pl column d m = map (!!d) m
02:03:12 <lambdabot> column = map . flip (!!)
02:03:18 <syntaxfree> which one sounds smarter?
02:03:23 <int-e> yours
02:03:31 <int-e> unless you need the other columns, too
02:03:37 <syntaxfree> it doesn't handle the entire matrix, I reckon.
02:03:56 <int-e> in which case I'd transpose first, then use !!. (or think about arrays)
02:04:03 <syntaxfree> I'm taking this semicolon-delimited CSV and I want to group entries by one column.
02:04:20 <syntaxfree> Microsoft Excel does something like that, but I'm trying to automate something for my parents.
02:04:58 <int-e> aha. no, I'd not transpose then.
02:05:23 <lucca> hm, yi --as=emacs seems less functional than the vi mode
02:05:25 <int-e> because the main object of interest are still rows.
02:05:31 <syntaxfree> yeah.
02:05:48 <syntaxfree> I'd like to have maximum-number-of-columns though.
02:05:54 <syntaxfree> as in maxcol = length . transpose
02:06:06 <syntaxfree> any transpose-less way of doing that?
02:06:23 <LordBrain> lucca: well i am not working on emacs... i dont use emacs... we need emacs people to work on it
02:06:30 <int-e> maxcol = length . maximumBy length
02:06:54 <lucca> LordBrain: getting there :p
02:07:07 <int-e> if your rows have varying lengths, transpose is a bad idea anyway.
02:07:09 <syntaxfree> > let square x= x*x in maximumBy square [-1, 0, 0.5]
02:07:10 <lambdabot>    Occurs check: cannot construct the infinite type: t = t -> t1
02:07:10 <LordBrain> :)
02:07:10 <lambdabot>    Expe...
02:07:15 <int-e> > transpose [[1], [2,3]]
02:07:17 <lambdabot>  [[1,2],[3]]
02:07:36 <syntaxfree> how does maximumBy work?
02:07:56 <int-e> hmpf
02:08:28 <int-e> > let comparing f a b = compare (f a) (f b) in maximumBy (comparing length) [[1], [2,3]]
02:08:29 <lambdabot>  [2,3]
02:10:00 <int-e> or, ihopes' favourite (IIRC): let attach g f a b = g (f a) (f b); comparing = attach compare; ...
02:10:01 <syntaxfree> oh.
02:10:49 <syntaxfree> I hope I'm not boring the channel with trivial problems, but one more question.
02:10:55 <syntaxfree> How do I define "negative !!"?
02:11:07 <syntaxfree> ohhh.
02:11:09 <syntaxfree> forget about it.
02:11:24 <syntaxfree> (What I need is negative "column" anyway)
02:33:02 <edwardk> heh @pl butchers attach =)
02:33:28 * edwardk returns to sleeping
02:41:37 <nostromo> I'm looking for some enlightment: I have imported List
02:42:03 <basti_> how can we enlight that?
02:42:23 <nostromo> ((++) . sort) [2,1,4,3,5] [2,1,4,3,5]
02:42:24 <nostromo> [1,2,3,4,5,2,1,4,3,5]
02:42:34 * int-e lights a candle with a match.
02:42:47 <int-e> what are you trying to achieve?
02:42:51 <nostromo> (sort . (++)) [2,1,4,3,5] [2,1,4,3,5] ERROR - Type error in application
02:43:06 <nostromo> what is going wrong in the second example?
02:43:09 <int-e> @pl \x y -> sort (x ++ y)
02:43:10 <lambdabot> (sort .) . (++)
02:43:28 <basti_> > (sort .) . (++) [2,1,4,3,5] [2,1,4,3,5]
02:43:29 <lambdabot>    Expecting a function type, but found `[a]'
02:43:29 <lambdabot>    Expected type: a2 -> a1...
02:43:34 <basti_> uh
02:43:43 <basti_> > ((sort .) . (++)) [2,1,4,3,5] [2,1,4,3,5]
02:43:44 <lambdabot>  [1,1,2,2,3,3,4,4,5,5]
02:43:47 <basti_> there
02:43:49 <nostromo> cool, why the (sort.) makes a difference?
02:44:03 <int-e> (sort . (++)) [2,1,4,3,5] = sort ([...]++)
02:44:08 <norpan> why are you not just writing sort (... ++ ...)?
02:44:10 <nostromo> this would be true enlightment, and why my naive try failed
02:44:10 <int-e> so you're trying to sort a function
02:44:23 <basti_> look at the type of .
02:44:28 <basti_> @type (.)
02:44:29 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
02:44:37 <int-e> which fails. (.) only 'forwards' one argument, not two.
02:44:41 <nostromo> norpan: I'm trying to understand composition
02:45:01 <norpan> well, understand that . composes functions each taking one argument
02:45:12 <nostromo> ok, I see
02:45:35 <nostromo> I don't feel it natural, but I see
02:46:20 <int-e> sort (x ++ y) = sort ((++) x y) = (sort . ((++) x)) y = ((.) sort ((++) x)) y = (((.) sort) . (++)) x y = ((sort .) . (++)) x y
02:46:37 <int-e> all the gory details.
02:46:44 <nostromo> thanks
02:49:33 <edwardk> @type (<<^)
02:49:35 <lambdabot> forall d b (a :: * -> * -> *) c. (Arrow a) => a c d -> (b -> c) -> a b d
02:49:35 <syntaxfree> How do I extract elements 3 to 5 from a list in Haskell again?
02:49:45 <syntaxfree> (I have  [1,2,3,4,5,6,7], I want [3,4,5])
02:49:48 <int-e> take 3 . drop 2
02:49:54 <syntaxfree> take and drop.
02:49:57 <nostromo> take 3 drop 2
02:49:59 <syntaxfree> My brain is dying.
02:50:02 <syntaxfree> Sorry.
02:50:05 <basti_> syntaxfree: why that? ;)
02:50:05 <syntaxfree> I forgot.
02:50:17 <syntaxfree> Not enough sleep.
02:50:21 <basti_> :|
02:50:34 <syntaxfree> > take 3 [1..10]
02:50:35 <lambdabot>  [1,2,3]
02:50:55 <nostromo> take 3  (drop 2 [1,2,3,4,5])
02:51:20 <syntaxfree> > let decol d s = take (d-1) s ++ drop d s in decol 4 [1..10]
02:51:22 <lambdabot>  [1,2,3,5,6,7,8,9,10]
02:51:27 <syntaxfree> :)
02:51:32 <|Steve|> > take 3 . drop 2 [1..10]
02:51:33 <lambdabot>    Expecting a function type, but found `[a]'
02:51:33 <lambdabot>    Expected type: a1 -> [a...
02:51:42 <nostromo> >((take 3) . (drop 2)) [1..10]
02:51:47 <nostromo> > ((take 3) . (drop 2)) [1..10]
02:51:48 <lambdabot>  [3,4,5]
02:51:51 <|Steve|> Ah.
02:52:15 <nostromo> > take 3  (drop 2 [1,2,3,4,5]) --works too
02:52:17 <lambdabot>  [3,4,5]
02:52:56 * syntaxfree is an economist and he's okay, he hacks by night and he works by day.
02:53:21 <nostromo> except for Sundays, where he hacks day and night :P
02:53:26 <int-e> when do you sleep? at work or while hacking?
02:53:44 <dons> I fight crime in my spare time
02:54:12 <nostromo> my revenge for my students not wanting to learn python for AI classes will be to teach them haskell coming term >:)
02:54:35 <dons> ?karma+ nostromo
02:54:35 <lambdabot> nostromo's karma raised to 1.
02:55:13 <syntaxfree> int-e: not at all.
02:55:17 <int-e> can I somehow forward patches in darcs (i.e. force darcs to swap otherwise uncommutable patches in its repository, with me resolving conflicts)?
02:55:20 <nostromo> I tried to be nice and use the AIMA examples
02:55:36 <int-e> I guess I need to send, revert, apply, is that right?
02:56:03 <dons> hmm. I wonder what --reorder-patches does? (or whatever it is)
02:56:55 <kowey> int-e: that might work... you could also maybe do something with darcs diff
02:58:30 <kowey> i think --reorder-patches would only be for patches that do commute
02:58:48 <dons> ah yes
03:00:23 <LordBrain> dons, does yi store the positions of the SoL's somewhere?
03:00:44 <LordBrain> so i can for example, given an Start of Line, figure out the line number
03:00:56 <LordBrain> or look up the line number rather
03:01:09 <LordBrain> wihtout having to go thru the buffer and count \n's
03:02:01 <LordBrain> or rather
03:02:06 <LordBrain> given a line number... get the position
03:02:46 <dons> there's a way I think
03:02:48 <dons> let me see
03:03:21 <dons>     indexOfLine :: a -> Int -> IO Int
03:03:21 <dons>     indexOfLine b i = do
03:03:21 <dons>         p <- pointB b
03:03:21 <dons>         gotoLn b i
03:03:21 <dons>         q <-  pointB b
03:03:23 <dons>         moveTo b p
03:03:25 <dons>         return q
03:03:28 <dons> ?
03:03:53 <dons> I also have, getLineAtPoint, pointAtLineOffset, lineCount
03:03:59 <dons> but they're not in the main repo. maybe they should be
03:04:13 <dons> let me know if you need them
03:04:59 <LordBrain> the first two i think would be useful... getLineAtPoint will be needed for visual line mode i think
03:05:19 <LordBrain> pointAtLineOffset is very close to what i need now
03:05:43 <dons> here, at the end of the file, http://www.cse.unsw.edu.au/~dons/tmp/Buffer.hs
03:05:44 <LordBrain> except i'm working with actual screen coordinates i think
03:05:56 <dons> ah in the Window?
03:06:08 <LordBrain> i am trying to fix the tab problem
03:06:21 <dons> very good :)
03:06:40 <LordBrain> i fixed it in the selection code, but it is also in the cursor-positioning code
03:06:56 <LordBrain> the cursor-positioning code being the culprit of our wmove errors
03:07:48 <dons> yes
03:21:39 <int-e> darcs send, unpull, pull, apply -i (to omit one patch that I didn't want after all) worked.
03:23:49 <kowey> it generates a conflict that you clean up by hand?
03:26:01 <int-e> Here's the question as I should've asked it: I have a darcs repository with my own local changes. darcs pull generates conflicts. instead of resolving them now, I want a clean pull with my own patches on top, and then resolve the conflicts.
03:27:23 * int-e still has to work on asking questions properly, despite having been on the other side and knowing the frustration of being presented an intermediate problem that might just be the result of a bad approach. Sorry.
03:29:04 <kowey> oh! you want to "put aside" your local changes, pull things in nicely, apply your local changes and deal with the conflicts there
03:29:14 <LordBrain> dons: in the function, pointAtLineOffset <-- is offset mean the first line displayed on the page?
03:29:21 <LordBrain> or is that the column?
03:29:41 <dons> if its in Buffer.hs, it'll be offset from the top of the file, surely?
03:29:51 <dons> and the Window caches the line at the top of the screen, yes?
03:29:57 <syntaxfree> Given a string, remove all occurences of a char.
03:30:07 <dons> been a while since i looked at that code, though
03:30:07 <int-e> and despite having read http://www.catb.org/~esr/faqs/smart-questions.html yesterday. it's a good read, I enjoyed it a lot.
03:30:09 <lambdabot> Title: How To Ask Questions The Smart Way
03:30:18 <LordBrain> it might be offset from the beginning of the line, in other words column..
03:30:25 <dons> could be
03:30:27 <syntaxfree> removeChar c x:xs = if (x==c) then xs else x:removeChar xs
03:30:29 <int-e> kowey: right.
03:30:36 <syntaxfree> is there a built-in function for that?
03:30:38 <dons> but LineOffset suggest to me its a line fofset
03:30:50 <LordBrain> moveXorEol b off
03:30:55 <dons> ?hoogle delete
03:30:56 <lambdabot> List.delete :: Eq a => a -> [a] -> [a]
03:30:56 <lambdabot> Data.HashTable.delete :: HashTable key val -> key -> IO ()
03:30:56 <lambdabot> Data.IntMap.delete :: Key -> IntMap a -> IntMap a
03:31:05 <dons> > delete 'c' "haskecckellcc"
03:31:06 <lambdabot>  "haskeckellcc"
03:31:26 <dons> syntaxfree: filter ...
03:31:34 <syntaxfree> oh. true.
03:31:34 <LordBrain> yeah filter
03:31:42 <dons> > filter (/='c') "haskecckellcc"
03:31:43 <lambdabot>  "haskekell"
03:31:48 <syntaxfree> > filter (/='c') "haskeccllcc"
03:31:49 <lambdabot>  "haskell"
03:32:26 <syntaxfree> I want to remove all "  from a string.
03:32:28 <dons> ?hoogle a -> [a] -> [a]
03:32:29 <lambdabot> List.intersperse :: a -> [a] -> [a]
03:32:29 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
03:32:29 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
03:32:33 <syntaxfree> Do I escape like \"  ?
03:32:34 <dons> ?hoogle+
03:32:35 <lambdabot> List.insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
03:32:35 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
03:32:35 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
03:32:41 <kowey> int-e: yeah, i sometimes use the send, obl, apply approach... not so much for pulling, but more for setting things really aside
03:32:44 <dons> syntaxfree: filter (/= '"')
03:33:02 <tibbe> I have a small documentation patch I would like to send to the GHC repo but my ISP blocks port 25 so I can't darcs send it. However I could use my webmail. How do I create a darcs patch using darcs send that I can then send manually?
03:33:03 <LordBrain> i'm thinking moveXorEol moves rightward by the ammount offset... so this basicly means column
03:33:04 <tibbe> -o ?
03:33:17 <dons> LordBrain: yes.
03:33:30 <dons> it moves right, x columns, or to the end of the line
03:33:35 <syntaxfree> my editor's syntax highlighting goes bork bork bork with that, dons.
03:33:43 <dons> bad editor
03:34:03 <dons> > filter (/= '"') "hake\"ll\" is \"fun\""
03:34:03 <syntaxfree> @hoogle sort
03:34:04 <lambdabot> List.sort :: Ord a => [a] -> [a]
03:34:04 <lambdabot> List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
03:34:04 <lambdabot> System.Win32.NLS.sORTIDFROMLCID :: LCID -> SortID
03:34:04 <lambdabot>  "hakell is fun"
03:34:17 <syntaxfree> what is sortBy like?
03:34:22 <dons> its like sort.
03:34:36 <syntaxfree> are strings sortable?
03:34:39 <dons> sure
03:34:49 <dons> > sort "foo"
03:34:50 <lambdabot>  "foo"
03:34:52 <syntaxfree> I need to sort a [[String]] by a certain column.
03:34:54 <dons> > sort "badc3frad"
03:34:56 <lambdabot>  "3aabcddfr"
03:35:00 <syntaxfree> no, no, I mean
03:35:10 <syntaxfree> > sort ["abc", "def", "aaa"]
03:35:11 <lambdabot>  ["aaa","abc","def"]
03:35:13 <dons> yes, lists are sortable, since they're in Ord
03:35:16 <syntaxfree> yes, that's almost it.
03:35:21 <dons> ?instances Ord
03:35:22 <lambdabot> (), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
03:36:08 <syntaxfree> well, I have [["zzz", "zzz", "aaa"], ["aaa", "aaa", "zzz"]]
03:36:16 <syntaxfree> I want to sort by the third "column".
03:36:22 <syntaxfree> See?
03:36:47 <basti_> @type Data.List.sortBy
03:36:49 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
03:37:14 <syntaxfree> What is an Ordering?
03:37:21 <basti_> @info Ordering
03:37:21 <lambdabot> Unknown command, try @list
03:37:21 <dons> > sortBy (\[_,a,_] [_,b,_] -> a `compare` b) [["zzz", "zzz", "aaa"], ["aaa", "aaa", "zzz"]]
03:37:22 <lambdabot>  [["aaa","aaa","zzz"],["zzz","zzz","aaa"]]
03:37:26 <basti_> hmm
03:37:33 <basti_> Lt, Gt or Eq IIRC
03:37:55 <dons> > [minBound .. maxBound :: Ordering]
03:37:56 <lambdabot>  [LT,EQ,GT]
03:38:14 <int-e> The order is very useful.
03:38:38 <syntaxfree> dons: I'm almost there. I'd like to specify a column number as an argument.
03:38:41 <dons> Order is better than Chaos, for sorting things
03:38:46 <syntaxfree> Jesus, I'm sorry I'm actually asking you to write my function.
03:38:53 <syntaxfree> I don't understand Ordering :(
03:39:02 <basti_> Ordering is just an ordinary datatype
03:39:14 <basti_> data Ordering = LT | GT | EQ
03:39:22 <syntaxfree> @type compare
03:39:24 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
03:39:47 <syntaxfree> > compare 3 5
03:39:48 <lambdabot>  LT
03:40:04 <syntaxfree> hmm. I seem to be getting there.
03:40:18 <int-e> > let (a,b) <=> (c,d) = compare (compare d b, compare a b) (EQ, EQ) in sortBy (<=>) [(a,b) | a<-[0..2], b<-[0..2]]
03:40:19 <lambdabot>  [(0,2),(1,2),(2,2),(0,1),(1,1),(2,1),(0,0),(2,0),(1,0)]
03:40:22 <basti_> o.0
03:40:57 <dons> > let sortN n = sortBy (\a b -> a !! n `compare` b !! n) in sortN  1 [["zzz", "zzz", "aaa"], ["aaa", "aaa", "zzz"]]
03:40:58 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
03:40:58 <lambdabot>    Expected...
03:41:03 <syntaxfree> > sortBy (\l1 l2-> (l1!!2 `compare` l2!!2)  [["aaa","aaa","zzz"],["zzz","zzz","aaa"]]
03:41:04 <lambdabot>  Parse error
03:41:22 <dons> missing parens
03:41:23 <syntaxfree> > sortBy (\l1 l2-> (l1!!2 `compare` l2!!2))  [["aaa","aaa","zzz"],["zzz","zzz","aaa"]]
03:41:23 <lambdabot>  <Plugins.Eval>:1:10: parse error on input `='
03:41:29 * dons -> dinner
03:41:33 <syntaxfree> yes. thanks!
03:41:58 <syntaxfree> > sortBy (\l1 l2-> ((l1!!2) `compare` (l2!!2)))  [["aaa","aaa","zzz"],["zzz","zzz","aaa"]]
03:41:59 <lambdabot>  [["zzz","zzz","aaa"],["aaa","aaa","zzz"]]
03:43:18 <syntaxfree> foldl1 f [1,2,3] is f(1, f(2, f(3))) ?
03:43:53 <syntaxfree> or is that foldr1?
03:43:54 <Heffalump> no
03:43:57 <Heffalump> that's foldr
03:44:04 <syntaxfree> what's foldl1 like?
03:44:14 <int-e> f (f 1 2) 3
03:44:15 <Heffalump> in fact what you said isn't anything, because it's badly typed
03:44:22 <Stinger_> and it doesnt have the f(3)
03:44:27 <Heffalump> foldr1 would be f 1 (f 2 3)
03:44:30 <|Steve|> @type foldr1
03:44:31 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
03:44:42 <syntaxfree> yes. I actually used mathematical  notation for the result.
03:45:17 <syntaxfree> Um. Lemme think out aloud.
03:45:17 <Heffalump> you had one too many call to f,
03:45:30 <syntaxfree> I have sortByCol that sorts a [[String]] by "column" d.
03:45:52 <syntaxfree> I want to input a list of numbers, so it first sorts by number 1, then by number 2, then by number 3. Hmm.
03:46:14 <syntaxfree> I actually want, in mathematical notation, f(1, f(2, f(3)))
03:46:44 <dottedmag> syntaxfree: here you have two functions: f(x) and f(x,y)
03:46:45 <Stinger_> erm what does f do one one operand compared to two?
03:47:05 <syntaxfree> Jesus.
03:47:07 <syntaxfree> My brain is melting.
03:47:16 <int-e> syntaxfree: foldr does f(1, f(2, f(3, x)))
03:47:17 <syntaxfree> I'd better get some sleep.
03:47:25 <basti_> i don't think jesus has anything to do with that.
03:47:33 <int-e> syntaxfree: that's the closest you'll get.
03:47:40 <syntaxfree> Yes. But Jesus is generally good to complain to.
03:47:47 <basti_> yea ok
03:49:11 <syntaxfree> sortByCols [] x = x
03:49:11 <syntaxfree> sortByCols d:ds x = sortByCol d (sortByCols ds x)
03:49:24 <syntaxfree> anyway, that was what I needed. Why "foldr" ever crossed my mind, I'll never know.
03:50:31 <Igloo> You need parens around d:ds
03:50:53 <syntaxfree> Yes. I'm not writing code anymore.
03:51:03 <syntaxfree> Thank you though :)
03:51:16 * syntaxfree owes the channel so much.
03:51:18 <int-e> extractCols d l = map (l!!) d ... then sortBy (comparing (extractCols d))
03:51:30 <kowey> so... does anyone here know how to get something hosted on darcs.haskell.org (namely, wxhaskell) ?
03:51:40 <int-e> that should be a bit more efficient.
03:52:08 <syntaxfree> int-e: except I don't understand what that does.
03:52:32 <syntaxfree> > [10..1]
03:52:33 <lambdabot>  []
03:52:39 <int-e> it extracts the columns you want as a list and then uses the comparison for lists.
03:52:42 <syntaxfree> @type reverse
03:52:42 <int-e> > [10,9..1]
03:52:43 <lambdabot> forall a. [a] -> [a]
03:52:44 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
03:52:58 <syntaxfree> > reverse [10..1]
03:52:59 <lambdabot>  []
03:53:04 <syntaxfree> > reverse [1..10]
03:53:05 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
03:53:32 <syntaxfree> @type max
03:53:34 <lambdabot> forall a. (Ord a) => a -> a -> a
03:53:37 <int-e> (I gave a definition for 'comparing' earlier.
03:53:38 <int-e> )
03:53:39 <syntaxfree> @type maximum
03:53:40 <lambdabot> forall a. (Ord a) => [a] -> a
03:54:38 <syntaxfree> > let f x = [1..x] in f 5
03:54:40 <lambdabot>  [1,2,3,4,5]
03:55:01 <int-e> > enumFromTo 1 5
03:55:02 <lambdabot>  [1,2,3,4,5]
03:55:08 <syntaxfree> better.
04:24:02 <shapr> Igloo: did you say you'd built ghc on an m68k box with about the same stats as a 770?
04:25:17 <Igloo> I've built it on a 50MHz m68k with 128M of RAM
04:25:43 <shapr> Hm, the 770 is 225MHz with 64mb of ram. How long did the m68k build take?
04:25:54 <shapr> iirc, days?
04:26:01 <Igloo> Just shy of a week, yes
04:26:03 <shapr> yow
04:26:08 <shapr> I think I'll skip it.
04:26:27 <Igloo> Although you could cut it down by not building opengl
04:28:11 <basti_> o.0
04:37:16 <dons> yeah, it was about a week on a 33Mhz 68040 too
04:37:36 <shapr> I wonder if half the ram and nine times the MHz will be faster?
04:37:56 <Stinger_> why are you people compiling ghc on 68ks -_-
04:38:01 <psi> can't it be cross compiled?
04:38:25 <shapr> psi: Probably, but that's no fun.
04:38:36 <int-e> @index Id
04:38:37 <lambdabot> bzzt
04:38:59 <psi> I don't consider compiling very much fun :-)
04:39:13 <Stinger_> yeah especially ghc :)
04:39:17 <psi> (yet I run gentoo!)
04:39:34 <giksos> hi, I have a problem when trying to catch sigint. The handler seems to get called much later than the signal arrives. Is anyone familiar with this?
04:42:04 <Igloo> shapr: I wouldn't be surprised if it was slower
04:42:51 <shapr> ah well
04:43:19 <Igloo> Ug, deriving Lift is a pain. I end up needing to lift names, which means lifting PackedStrings and suchlike
04:50:28 <musasabi> shapr: how about running an emulator on a fast machine?
05:00:44 <shapr> musasabi: Yeah, probably the most sensible approach.
05:00:53 <shapr> musasabi: Speaking of compiling, should jhc build from the repo?
05:01:50 <shapr> I've updated jhc and all four subrepos, and I get Could not find module `Util.Perhaps': \n  (imported from ./Grin/Grin.hs)
05:04:56 <mnislaih> shapr: I've run hugs on a pocketpc and its' great
05:05:41 <mnislaih> maybe you want to try hugs instead of ghc
05:06:20 <musasabi> shapr: there was major refactoring ~8 hours ago by John. Still haven't pulled. The version before those at least was buildable. Should test.
05:06:56 <musasabi> shapr: my guess is that Util.Perhaps was simply forgotten from a darcs add.
05:07:29 <mnislaih> less than a week ago I tried building jhc and it killed my ghc-6.5
05:08:08 <musasabi> mnislaih: a week ago at least ghc 6.4.2 worked
05:08:26 <mnislaih> it was probably fault of ghc-6.5. It panicked away
05:08:31 <musasabi> Various versions of ghc-6.5 are buggy and crash in various different ways
05:08:49 <musasabi> which is perfectly normal for a HEAD branch
05:08:49 <mnislaih> I used latest, by that time
05:10:08 <mnislaih> Lemmih: I've uploaded a patch to my repo at http://ender4.dsic.upv.es:81 (ghcfull)
05:10:09 <lambdabot> Title: Index of /
05:10:42 <mnislaih> take a look when you can, right now generated core doesn't lint yet
05:11:17 <musasabi> mnislaih: have to test it once the 6.6 prerelease comes out
05:11:33 <mnislaih> it can make for a good stress test
05:11:54 <mnislaih> funny that ghc-6.5 can compile itself yet not jhc
05:12:08 <musasabi> normal
05:12:22 <musasabi> ghc-6.5 is tested against building itself
05:12:28 <musasabi> it is not tested against building jhc
05:12:37 <mnislaih> hmm, makes sense
05:12:38 <dcoutts> @yarr!
05:12:39 <lambdabot> What be a priate's favourite cheese?
05:12:39 <lambdabot> Yarrlsburg!
05:12:40 <dcoutts> morning folks
05:12:51 <shapr> New pirate quotes?
05:12:55 <mnislaih> gm dcoutts
05:12:58 <shapr> That one's misspelled!
05:13:01 <shapr> g'mornin dcoutts
05:13:02 <musasabi> hello dcoutts
05:13:08 * dcoutts grins
05:13:13 <dcoutts> yes, new pirate quotes
05:13:34 * mnislaih goes to eat some pirate food
05:13:37 <shapr> Dang, I forgot to try some Wensleydale.
05:13:41 <dcoutts> that was a pun from a play I was in
05:13:47 <dcoutts> shapr, oh yeah :-(
05:13:59 <shapr> I'll have to import some.
05:14:04 <dcoutts> heh
05:14:10 <shapr> dcoutts: I had lots of fun staying at your house, thanks!
05:14:14 <dcoutts> well I'll be there in a few weeks
05:14:18 <dcoutts> I can import some :-)
05:14:25 <shapr> Good idea!
05:14:54 * dcoutts needs to book a hostle in Stockholm for the 25th
05:15:14 <dcoutts> hostle/hostel
05:18:56 <vincenz> hmm
05:20:21 <dons> giksos: there's some signal handling code here that might be useful http://www.cse.unsw.edu.au/~dons/code/yi/Yi.hs
05:20:39 <dons> or here  http://www.cse.unsw.edu.au/~dons/code/hmp3/Main.hs
05:20:51 <dons> (the latter is probably simpler to follow)
05:21:09 <dcoutts> shapr, did I see you're a subscriber on lwn? I assume all shaprs are you.
05:21:23 <giksos> dons: thanks, I'll take a look now.
05:23:50 <shapr> dcoutts: I haven't seen other shaprs.
05:23:56 <shapr> Yes, I've been an LWN subscriber for years.
05:24:03 <dcoutts> me too
05:24:44 <Stinger_> LWN?
05:24:53 <dcoutts> @google LWN
05:24:56 <lambdabot> http://lwn.net/
05:24:56 <lambdabot> Title: LWN: Welcome to LWN.net
05:24:56 <shapr> I'd guess you saw me comment on the freespire article?
05:25:23 <dcoutts> shapr, I saw one where you were talking about your pseudonym
05:25:36 <shapr> Oh yeah.
05:26:35 <shapr> andrew cooke made that point in LtU.
05:26:42 <dcoutts> shapr, hmm, so they're actually using our ByteString sutff? dons and I should definately mention that in our paper.
05:27:56 <giksos> dons: this code is just what I am doing. Did you also have the problem that signals arrive later?
05:29:31 <dons> i've not noticed it, no
05:29:56 <dons> perhaps you want to print something when they arrive? maybe the first signal is being dropped? does -threaded make a difference?
05:30:25 <dons> dcoutts: yeah, they're using bytestrings
05:30:57 <dcoutts> woo!, our code has been released to thousands of people :-)
05:31:07 <dons> hehe
05:31:19 <dcoutts> dons, we should ask them for some feedback
05:31:37 <giksos> dons: I'm installing a handler that prints something out, but this usually happens much later than I press Ctrl-c (after some further input). Maybe it's because I'm using readline.
05:31:44 <dons> now who was it? stepcut, he's the freespire hacker?
05:31:59 <dcoutts> @seen stepcut
05:32:00 <lambdabot> stepcut is in #haskell-blah and #haskell. I last heard stepcut speak 7 hours, 9 minutes and 55 seconds ago.
05:32:11 <dons> I seem to recall talking to stepcut about improving the speed of some package parser.
05:32:22 <dons> giksos: hmm. could be.
05:32:29 <dons> could be escape handling in readline?
05:32:58 <giksos> escape handling?
05:33:06 <dons> giksos: what happens if you deliver signals via kill -TERM or whatever/
05:33:10 <dcoutts> dons, yes, Jeremy Shaw posts to the haskell-cafe from a linspireinc.com address
05:33:40 <shapr> stepcut == Jeremy Shaw
05:34:39 <shapr> dcoutts: Here's the reference for my lwn comment - http://lambda-the-ultimate.org/node/1499#comment-17328 I think I got called haskellpimpolicious there...
05:34:40 <lambdabot> Title: Editing posts | Lambda the Ultimate
05:34:53 <dcoutts> heh
05:35:18 <giksos> dons: kill has the same effect
05:35:29 <tibbe> would the modified (3 clause) BSD license be could for a small haskell application server?
05:35:41 <giksos> I wrote the kind of input loop in C, it works as it should
05:36:22 <dcoutts> shapr, that's a nice quote :-)
05:36:28 * shapr grins
05:36:43 <dcoutts> ' It really doesn't matter if you're called "haskellpimpolicious", "shapr" or "shae erisson" '
05:36:57 <shapr> I wonder if andrew cooke was gently chiding me for my rabid proselytization.
05:37:11 <dcoutts> ;-)
05:38:18 <dons> giksos: hmm. i wonder if readline does something weird?
05:38:30 <shapr> lwn is the best online-only publication I've seen.
05:38:51 <shapr> Science News (sciencenews.org) is equally rated by me, but it's primarily hardcopy.
05:39:10 <dons> oh, interesting comment from the linspire guys re. OCaml "the libraries are not as complete as those in Haskell"
05:39:25 <shapr> Where's that from?
05:39:34 <dons> http://homepages.inf.ed.ac.uk/wadler/realworld/linspire.htm
05:39:42 <dons> l
05:40:14 <dons> "a vibrant community that is producing new advances weekly" :)
05:40:35 * shapr grins
05:40:46 <ndm> dons: 404 on that link?
05:40:57 <dons> http://homepages.inf.ed.ac.uk/wadler/realworld/linspire.html
05:40:58 <shapr> add the l on the end
05:40:59 <lambdabot> Title: Linspire/Freespire
05:41:14 <vincenz> cya people!
05:41:16 <vincenz> be back in 2 weeks
05:41:27 <shapr> bye vincenz!
05:41:41 * vincenz goes to catch a train to germany to pick a flight to italy
05:41:44 <dons> ciao vincenz
05:41:45 <vincenz> @where vincenz
05:41:46 <lambdabot> Sardinia
05:41:48 <vincenz> :)
05:42:00 <vincenz> @where+ vincenz http://www.esat.kuleuven.ac.be/~cpoucet/
05:42:00 <lambdabot> Done.
05:42:07 <vincenz> and oh yeah
05:42:14 <vincenz> I think the only reason ocaml is beating us on shootout
05:42:18 <vincenz> is a native regexp lib
05:42:40 <vincenz> that's the only two it really outperforms us severely
05:42:42 <vincenz> like 12x
05:42:45 <shapr> Isn't that fixed in 6.6?
05:42:49 * vincenz shrugs
05:42:52 <vincenz> no idea
05:42:52 <giksos> dons: readline in itself works normally, it's just the signal handling that plays tricks. I'll try the same without readline now...
05:42:56 <dons> Kevin Carmony, President & CEO, Linspire, Inc.,"Many of our OS team rave about Haskell. Just because Linspire is a consumer, easy-to-use version of Linux, doesn?t mean we don?t want the best, most sophisticated programming tools to help us deliver that. We get more done in less time with Haskell.."
05:43:06 <vincenz> :)
05:43:11 <shapr> Nice quote!
05:43:13 * vincenz leaves before he gets hooked
05:43:16 <vincenz> shapr: check it out
05:43:19 <vincenz> @protontorpedo
05:43:19 <lambdabot> so haskell is free
05:43:24 <vincenz> @protonorpedo
05:43:24 <lambdabot> is there an oo db in haskell?
05:43:29 <vincenz> @proton
05:43:29 <lambdabot> I dont know any programming yet at 33 dream of learning ti and gettign rich
05:43:31 <shapr> What's that?
05:43:35 <shapr> Sounds like keal
05:43:37 <vincenz> some annoying user
05:43:40 <vincenz> shemale_magic
05:43:44 <dons> ?proton
05:43:44 <lambdabot> smalltalk is oo
05:43:46 <shapr> oh that pers
05:43:47 <dons> ?proton
05:43:47 <shapr> on
05:43:47 <lambdabot> is haskell better than APL or perl or clisp?
05:43:50 <vincenz> @proton
05:43:50 <lambdabot> why haskell over smalltalk? I thought smalltalked rocked
05:43:57 <vincenz> heh
05:44:03 <vincenz> and at some other point he says oo sucks
05:44:03 <shapr> Maybe we should have @parody ?
05:44:07 <vincenz> @proton
05:44:07 <lambdabot> so haskell is new and improved c
05:44:14 <vincenz> lol, nice one
05:44:15 <Stinger_> haha
05:44:32 <Stinger_> could be taken as a compliment :)
05:44:34 <vincenz> I loved the other one as well
05:44:36 <vincenz> "Im not a loser"
05:44:44 <Stinger_> c was the defacto standard in many areas for a long time
05:44:44 <dons> 95% of what he's said has ended up in the text file. its all trollish gold
05:44:48 <vincenz> @proton
05:44:49 <lambdabot> help please
05:44:49 <dons> ?proton
05:44:49 <lambdabot> can I build a sales database with it?
05:44:49 <shapr> It's funny that part of our signal on #haskell is the noise...
05:44:55 <vincenz> :)
05:44:58 <dons> heh
05:45:02 <vincenz> @proton
05:45:02 <lambdabot> how fast is the haskell web serve for dynamic content? siriam from scheme says the scheme one si FAT AS HEK
05:45:19 <vincenz> anywho
05:45:23 <vincenz> dons and I nearly kicked hm
05:45:29 <shapr> me too
05:45:34 <shapr> But I nearly kicked him for his nick
05:45:35 <vincenz> but I remembered shapr
05:45:42 <dons> if you look at all his statements together, its clearly trolling, I think
05:45:46 <vincenz> shapr: Oh I have once in the past, cause Philippa told me he had been asked to change it
05:45:52 <shapr> vincenz: Er, what did you remember about me?
05:45:58 <vincenz> shapr: that you like an open channel
05:46:00 <shapr> oh
05:46:05 <dons> shapr, at the bottom of http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Quote/Text.hs
05:46:11 <Stinger_> shapr is a #haskell bigwig then? :)
05:46:12 <vincenz> so I fought the temptation to kick him
05:46:14 <shapr> I thought you remembered how much I enjoy reading this sort of humor.
05:46:19 <vincenz> that too
05:46:22 * shapr grins
05:46:27 <vincenz> we wanted to fill the logs for a lambdabot upgrade
05:46:35 <dons> Stinger_: its a do-ocracy :) if you do, you are.
05:46:42 <shapr> Stinger_: I guess so, I'm the "benevolent dictator" as dcoutts told his parents last weekend.
05:46:50 <dcoutts> :-)
05:46:54 <vincenz> shapr: I hope that was not in an intimate context
05:46:59 <shapr> ?
05:47:03 <dcoutts> !
05:47:08 * vincenz looks at dcoutts and shapr
05:47:08 <Stinger_> o_O
05:47:17 * dcoutts slaps vincenz 
05:47:20 <vincenz> :D
05:47:29 <shapr> dcoutts' parents had just asked what I did in the Haskell community, and the subject turned to the #haskell channel.
05:47:40 <vincenz> I don't know, maybe he was introducing you to his parentts
05:47:42 <vegai> dons: meritocracy?
05:47:47 <Stinger_> dcoutts parents know what haskell is? wow :D
05:47:57 <vincenz> Stinger_: well he -is- dcoutts
05:48:12 <dons> vegai: almost. not quite merit based though. you can' rest on your laurels.
05:48:13 <dcoutts> yeah, my parents use linux
05:48:18 <shapr> At some point during AngloHaskell the Simons asked roughly why #haskell was so calm and conflict free.
05:48:21 <vincenz> dcoutts: that's impressive
05:48:33 <vincenz> dcoutts: been trying to get my mother to switch but she's a computer newb
05:48:44 <dcoutts> so is my mother
05:48:47 <vincenz> then again, she's constantly complaining about trojans etc
05:48:51 <vincenz> I might just make her get a mac
05:49:00 <dcoutts> try ubuntu
05:49:15 <vincenz> I use ubuntu, but still...
05:49:24 * dcoutts as a gentoo developer shouldn't say that really
05:49:26 <shapr> I told 'em #haskell isn't conflict free, I'm just willing to kickban people whenever I judge them to detract from the community.
05:49:36 <shapr> dcoutts: I recommend ubuntu also, but I use debian.
05:49:38 <vincenz> shapr: so how come I'm still here?
05:49:49 <shapr> vincenz: Because you don't detract from the community.
05:49:52 <vincenz> tsk
05:49:56 <vincenz> I should try harder
05:50:06 <dcoutts> shapr, obviously developers should be using gentoo, but desktop end users are allowed to use ubuntu :-)
05:50:19 <shapr> vincenz: Everybody steps outside the borders sometimes (especially me), but the people who come back inside the borders of 'contributing to the community' get to stay.
05:50:30 <vincenz> dcoutts: gentoo??? That takes -ages- to build
05:50:43 <musasabi> Gentoo is frustrating when as a developer I usually want things installed quickly.
05:50:44 <vincenz> shapr: I was kidding, but thanks for the vote of confidence :)
05:50:45 <dcoutts> you only install once
05:50:53 <vincenz> dcoutts: erm, this isn't windows!
05:51:28 <giksos> dons: yes, it's the readline. It installs some handlers of its own and something goes wrong. Strange though that C and haskell behaviour is different in this case.
05:51:29 <shapr> vincenz: Speaking of confidence, should I kick you off the channel so you won't be late? ;-)
05:51:29 * dcoutts doesn't grok that comment
05:51:42 <vincenz> shapr: nah I still have time.... my plane leaves at 7am in germany
05:51:45 <shapr> ok
05:51:48 <giksos> dons: without the readline, signals arrive at once
05:51:51 <vincenz> shapr: I just have to make sure I cathc a train to germany before the evening
05:51:51 <musasabi> dcoutts: actually it is quite frequently I notice "I need to test foo, bar, baz and foobar" and after testing them for 5min I can uninstall them.
05:52:08 <vincenz> still not sure what to do there....hopefully a cheap hotel, cause the airport is way out in the middle of nowhere
05:52:15 <shapr> musasabi: I do a lot of that too. But I always thought that was a sysadmin role, not dev.
05:52:26 <basti_> vincenz: where are you going?
05:52:31 <vincenz> sardegna
05:52:36 <shapr> Hm, integration dev would require that too..
05:52:39 <basti_> o.0
05:52:40 <shapr> vincenz: sardinia?
05:52:43 <dcoutts> musasabi, many things are suprisingly quick to build/install, just not mysql & php. :-)
05:52:45 <shapr> @google sardegna
05:52:48 <lambdabot> http://www.sardegna.com/
05:52:49 <musasabi> shapr: as a sysadmin I care mostly about things being stable, not experimenting with stuff.
05:52:50 <basti_> and from where in germany?
05:52:50 <vincenz> -CHOOCHOO-> coln -WHOOSH-> sardegna
05:52:59 <eivuokko> Is some other project than ghc using darcs.haskell.org/testsuite?
05:53:03 <vincenz> erm, koln
05:53:04 <basti_> kln?
05:53:06 <basti_> ic
05:53:07 <vincenz> right
05:53:09 <vincenz> koln-bonn
05:53:10 <vincenz> CGN
05:53:13 <shapr> qlnn!
05:53:20 <vincenz> is that like quorn?
05:53:23 <musasabi> dcoutts: maybe I should get faster machines, but usually the gentoo way took 15min which was too slow
05:53:27 <dcoutts> musasabi, for many random utils it can be done quicker than fedora's apt-get.
05:53:28 <shapr> musasabi: Good point, I shall reformulate my mental roles.
05:53:29 <vincenz> basti_: german?
05:53:34 <basti_> vincenz: yes.
05:53:41 <vincenz> basti_: know cologne-bonn at all?
05:53:42 <dons> eivuokko: hmm. i think nhc was looking to use it
05:53:44 <basti_> vincenz: will you stay in kln?
05:53:50 <dons> eivuokko: i've certainly hacked it to test nhc98
05:53:55 <vincenz> basti_: it's too far from the airport I've heard, my flight leaves at 6:55am
05:53:56 <basti_> i visited someone in kln once
05:54:04 <basti_> oh yea that sucks
05:54:06 <eivuokko> dons, I'm modifying the driver, and I wonder what I might break :-)
05:54:06 <vincenz> yeah
05:54:14 <vincenz> also the reason I have to leave today and find some place to crash there
05:54:15 <basti_> never been at the airport
05:54:15 <dons> eivuokko: probably not much
05:54:15 <ndm> dons, eivuokko: Yhc would love to use it
05:54:18 <shapr> heippa hei eivuokko
05:54:21 <vincenz> not to mention I've been up sine 22:00
05:54:27 * shapr waves finnish words at Esa
05:54:27 <basti_> :D
05:54:35 <ndm> nhc is pretty much frozen now, Yhc will definately want good test suites
05:54:35 <dons> ndm, wouldn't be too hard to add. i was able to get nhc98 working on the testsuite without much fuss
05:54:37 <vincenz> so yeah.... I seriously hope I can find somewhere to crash there
05:54:43 <dcoutts> musasabi, yeah, having a fast machine helps, and of course compilation parallelises well so you can take advantage of mutliple cpus if you've got them.
05:54:58 <basti_> vincenz: yea i'd hope that too.
05:55:02 * wolverian sees iso-8859-1 and runs in fear 
05:55:05 <eivuokko> shapr, lol :-)  Hiya
05:55:11 <vincenz> I should prolly leave soon, last train is at 20:00 but I didn't book a train ticket so I'd prefer going early nd hopefully find a hotel
05:55:19 <dcoutts> musasabi, where did we get with the configurations buisness btw? are we waiting for more replies from Simon/Isaac/Igloo ?
05:55:30 <eivuokko> dons, Cool.  I'll just run the full ghc-regress then.
05:55:35 <vincenz> basti_: oh Q: can I bring handluggage?
05:55:42 <vincenz> basti_: I don't feel like checking in my lappy
05:56:11 <shapr> Dang, Haskell is not mentioned on the freespire.org site.
05:56:39 <shapr> vincenz: 770 roxx on planes.
05:57:02 <vincenz> shapr: that's not the point, they stole my cellphone from my hardcover luggage in madrid end of last yaer.... and besides you know how hard they throw luggage around
05:57:10 <vincenz> and I need to bring my lappy cause I gotta seriously work on a paper
05:57:12 <shapr> Makes a good music player, research paper reader, email reader, web browser, note taker, etc.
05:57:27 <dcoutts> shapr, and runs yhc right?
05:57:27 <shapr> Sadly, I haven't found a good way to do programming on it.
05:57:31 <musasabi> dcoutts: if we can agree on something that goes into 6.6 I can create a patch.
05:57:32 <shapr> dcoutts: Still haven't tried that...
05:57:39 <vincenz> shapr: use binary, like realcoderS :)
05:57:51 <shapr> I don't even write C if I don't have to...
05:57:54 <musasabi> dcoutts: currently I am waiting for an agreement on a spec that should go in.
05:58:06 <dcoutts> musasabi, you and I can probably agree, not so easy to get buy in from everyone else :-)
05:58:15 <musasabi> dcoutts: as there is no sense in writing an another patch for syntax which is dismissed the next day.
05:58:22 <dons> huh. typing in 'haskell' into google brought up a job add saying "Haskell hackers welcome"...
05:58:23 <dcoutts> yeah
05:58:28 <shapr> dons: really?
05:58:35 <shapr> wow
05:58:43 <shapr> Oh hey, isn't that where JohnMeacham works?
05:59:06 * shapr sends a resume
05:59:08 <dons> http://www.janestcapital.com/ocaml.html ?
05:59:10 <lambdabot> Title: Jane Street Capital, LLC
05:59:30 <JohnMeacham> no. I work at a place called first quadrant. they don't use haskell. yet.
05:59:42 <shapr> hah
05:59:46 <dons> "Functional Prog. Jobs. Haskell hackers welcome! Program in OCaml at Jane Street"
06:00:01 <shapr> Ok, I know I've heard of some heavy duty Haskell hackers who work at Janestcapital
06:00:08 <dons> I feel so warm and fuzzy. Some HR department is welcoming to haskell hackers!
06:00:08 <shapr> JohnMeacham: Hey, can you fix the jhc missing code?
06:00:21 <shapr> JohnMeacham: I've updated jhc and all four subrepos, and I get Could not find module `Util.Perhaps': \n  (imported from ./Grin/Grin.hs)
06:00:31 <dons> they should just send an email to haskell@, its got to be cheaper than waiting for us to find out on google
06:00:44 <shapr> I'll blog it, then it'll be on planet haskell.
06:01:22 <JohnMeacham> shapr: added
06:01:23 <shapr> Sometimes I think I blog too much, or others don't blog enough.
06:01:30 <dons> heh
06:01:54 <shapr> JohnMeacham: Is it in the online repo too?
06:02:41 <vincenz> Perhaps ==
06:02:41 <vincenz> ?
06:02:49 <vincenz> Yes | No | Perhaps a?
06:03:15 <dcoutts> shapr, we need you to blog so the rest of us know what's going on
06:03:29 <vincenz> shapr is the sharp voice of the community
06:03:39 <profmakx> pickupWoman :: Woman -> Perhaps?
06:03:47 <vincenz> profmakx: no
06:03:59 <vincenz> pickupWoman :: Woman -> Maybe Not
06:04:05 <vincenz> data Not;
06:04:27 <profmakx> worth a try
06:04:37 <dons> ?djinn a -> Maybe (Not a)
06:04:37 <lambdabot> f _ = Nothing
06:04:44 <profmakx> i know about 2 women who would  actually understand that
06:04:48 <shapr> vincenz: hah
06:04:58 <shapr> profmakx: my gf would ...
06:05:13 <profmakx> my ex-gf would
06:05:15 <shapr> But I think she really wants Epigram instead of Haskell.
06:05:18 <profmakx> thats the first one ;)
06:05:47 <giksos> dons: I found a mail about exactly my problem: http://www.haskell.org/pipermail/libraries/2005-March/003466.html
06:05:49 <lambdabot> Title: [darcs-devel] [darcs #279] [wish] Use readline for line-editing
06:05:54 <ndm> shapr: you've twisted her mind!
06:06:02 <shapr> Actually, she thinks mutability is twisted.
06:06:07 <dons> giksos: so its a readline issue?
06:06:22 <vincenz> @type Not a
06:06:23 <lambdabot> Not in scope: data constructor `Not'
06:06:23 <lambdabot>  
06:06:23 <lambdabot> <interactive>:1:4: Not in scope: `a'
06:06:23 <dons> oh, just -threaded
06:06:25 <vincenz> @type Not
06:06:27 <lambdabot> Not in scope: data constructor `Not'
06:06:29 <dcoutts> dons, there must be a memory accounting bug here...
06:06:36 <dons> hmm?
06:06:47 <JohnMeacham> oops. okay, now it is added.
06:06:49 * profmakx will now go to programming hell ... :/ l8er
06:06:54 <vincenz> @karma+ basti_ for help with german trains
06:06:54 <dcoutts> dons, ./fuse +RTS -M600k -RTS < bigdata  works for strict bytestring, even though bigdata is 50Mb
06:06:54 <lambdabot> basti_'s karma raised to 1.
06:06:57 <basti_> :D
06:06:59 <shapr> ndm: When I showed her python's ability to redefine a name, she thought it was insane. Should couldn't see how people would be able to trust that their code hadn't changed something behind their back.
06:07:19 <dcoutts> dons, and yet for lazy ./fuse +RTS -M200m -RTS < bigdata  fails!
06:07:24 <dons> dcoutts: hmm. fails?
06:07:38 <dcoutts> it needs more like 250M
06:07:42 <dcoutts> but the file is only 50M
06:07:52 <dcoutts> and we should be streaming block by block
06:08:10 <dons> :/
06:08:23 <dcoutts> I don't understand
06:08:26 <dons> what happens under fps 0.7?
06:08:36 * dcoutts tries
06:09:30 <shapr> JohnMeacham: Seems to be building now, thanks!
06:09:45 <_frederik_> anyone going to ICFP?
06:09:50 <_frederik_> i also want to find someone to share a room with
06:09:52 <dcoutts> dons, I'll try 0.7 and 0.8 with 6.4.2
06:09:54 <shapr> JohnMeacham: One more question, should the prebuilt libs on the website work for the latest repo code?
06:10:14 <vincenz> btw
06:10:16 <vincenz> tomorrow
06:10:18 * vincenz >>= beach
06:10:25 <vincenz> \o/
06:10:52 <JohnMeacham> shapr: not sure. I think so, but am not positive.
06:11:03 <shapr> ok
06:14:17 <greenrd> shapr: Your gf is sensible. But I suspect you're leading her on to these conclusions a bit ;)
06:14:42 <greenrd> shapr: Have you been in #haskell-blah yet? You said you would
06:14:47 <dcoutts> dons, yes, a simple print . B.length =<< B.getContents takes 100m in 0.7 and 0.8 with ghc-6.4.2
06:15:07 <dons> which is right or wrong?
06:15:09 <dcoutts> and nearly no heap for strict bytestring
06:15:13 <dcoutts> wrong!
06:15:16 <dcoutts> that's for lazy
06:15:20 <dons> hmm
06:15:28 <dcoutts> it should never need more than about 2 * 32k
06:15:31 <dons> badness
06:15:45 <dcoutts> leak in hGetContents ?
06:15:52 <dons> maybe the gc needs to be tweaked?
06:16:19 <dons> could we be holding on to the head some how?
06:16:28 <dcoutts> would we have not noticed if it had been actually reataing the whole lot
06:16:38 <dcoutts> you did a test with multi-gb files
06:16:42 <dons> (i've written other programs that didn't do this. filter (/='e') worked fine on terabytes, remember.
06:16:50 <dcoutts> yes
06:17:00 <dons> it ran in something like 1.8M constant heap
06:17:25 <dons> what do the filtering/maps do? as opposed to the folds, like B.length?
06:17:49 <dcoutts> dons, ah!
06:17:56 <dcoutts> length is retaining the whole lot
06:18:03 <dcoutts> Lazy.length
06:18:28 <dcoutts> B.putStr =<< B.getContents  is fine in nearly 0 heap
06:19:21 <dcoutts> length (LPS ss) = L.sum (L.map (fromIntegral.P.length) ss)
06:19:29 <dcoutts> leaks apparently
06:19:29 <dons> we should audit the folds at some point, like length / maximum and so on, to check how they're holding on to things
06:19:36 <dcoutts> I'll rewrite it
06:19:38 <dons> hmm.
06:19:49 <dcoutts> yes, we should
06:19:49 <dons> lazyness is a grand thing ;)
06:19:56 <dcoutts> :-)
06:20:32 * dons `ap` sleep
06:20:43 <_frederik_> you guys are so geeky
06:20:45 <dcoutts> @type sleep
06:20:47 <lambdabot> Not in scope: `sleep'
06:20:52 <dcoutts> @type dons
06:20:53 <lambdabot> Not in scope: `dons'
06:20:55 <dcoutts> hmm
06:21:19 <dcoutts> @pl dons `ap` sleep
06:21:20 <lambdabot> dons `ap` sleep
06:21:24 <dcoutts> bah
06:21:34 <dcoutts> oh yeah, g'night dons ;-)
06:21:57 <vincenz> > 506/ 157
06:21:58 <lambdabot>  3.2229299363057327
06:25:32 <dcoutts> dons, yah, that works now
06:25:41 <dcoutts> length (LPS ss) = L.foldl' (\n ps -> n + fromIntegral (P.length ps)) 0 ss
06:26:18 <dcoutts> it runs in minimal heap, and the lazy version is now faster than the strict version
06:26:41 <mnislaih> @msg Lemmih looks like we are linting!
06:26:41 <lambdabot> Not enough privileges
06:26:43 <vincenz> @karma+ basti_ for calling youth hostel in koln
06:26:43 <lambdabot> basti_'s karma raised to 2.
06:26:58 <vincenz> mnislaih: @tell
06:27:06 <mnislaih> oh, right
06:27:11 <mnislaih> @tell Lemmih looks like we are linting!
06:27:12 <lambdabot> Consider it noted.
06:30:56 <vincenz> ok
06:30:59 <vincenz> bbye peopl
06:31:03 <basti_> good luck vincenz
06:31:21 <vincenz> @karma+ basti_ for making me find out koln is close to airport or I might have had to crash on a bench
06:31:21 <lambdabot> basti_'s karma raised to 3.
06:31:51 * basti_ laughs
06:32:06 <basti_> hope everything will be right there
06:32:45 <basti_> bbl
06:48:29 <mnislaih> GHC hackers: is it possible to get the type of an arbitrary LHSExpr annotated with type information (i.e. after the typechecking phase) ?
06:49:52 <mnislaih> I mean, probably it should be possible to do it manually, but is there any utility function for this around?
06:50:42 <mnislaih> somefunction :: LHsExpr Id -> Type
06:52:13 <Lemmih> What does GHCi use?
06:52:13 <lambdabot> Lemmih: You have 1 new message. '/msg lambdabot @messages' to read it.
06:52:47 <mnislaih> oh but ghci prolly deals simply with HsVar cases
06:53:02 <mnislaih> ok, :type does it for anything
06:53:16 <mnislaih> we are linting Lemmih :)
06:53:21 <Lemmih> mnislaih: How did you solve the linting problem?
06:53:46 <mnislaih> I saw some comment about a blunt instrument around, and applied it to heart :D
06:54:10 <mnislaih> let's say that unsafeCoerce and me are intimate now
06:54:19 <Lemmih> (:
06:57:09 <mnislaih> Lemmih, is it a good idea to invoke the whole typechecking machinery from the desugarer?
06:58:14 <Lemmih> I don't think so. Why do you need the typechecker?
06:58:17 <mnislaih> since the ids are already typed, it should not be necessary
06:58:40 <mnislaih> ghci does it that way
06:59:23 <Lemmih> What are you typechecking?
06:59:26 <mnislaih> I need to extract the type of an arbitrary (LHsExpr Id) to make the auto-inserted breakpoints lint
06:59:59 <mnislaih> since those are inserted at the desugarer now, I need to put them the corresponding TyApp manually
07:02:48 * shapr throws Arbitrary instances
07:03:23 <Lemmih> mnislaih: Hm, how do you typecheck the expressions now? Convert 'LHsExpr Id' to 'LHsExpr Name' and throw it through the typechecker?
07:03:58 <Lemmih> Hiya shapr.
07:04:04 <mnislaih> now? I'm not doing it yet,
07:04:19 <mnislaih> I didn't need to do this for the 'normal' breakpoints
07:05:10 <mnislaih> for normal breakpoints I had to wrap applications of unsafecoerce in TyApps too, but since those were all HsVars, I extracted the type from the Id
07:05:39 <mnislaih> now for 'auto' breakpoint I need to get the type of arbitrary expressions
07:05:58 <mnislaih> 'auto' breakpoints are those we insert via instrumentation
07:06:41 <Igloo> And you don't know where they're going to go when the typechecker runs?
07:07:17 <mnislaih> in 'normal' breakpoints I used TyApp to make the applications of unsafeCoerce to teh scope variables lint. In the 'auto' breakpoints I need to use them to make the aplication of 'breakpoint::a->a' lint, to instantiate that a
07:07:25 <mnislaih> Igloo: this happens in the desugarer
07:07:42 <mnislaih> all I need is some function with type 'LHsExpr Id -> Type'
07:08:49 <ndm> so what you need is hoogle for the GHC source code :)
07:09:22 <mnislaih> oh ndm, that would be simply insane
07:09:34 <ndm> mnislaih: it is on the roadmap, not too far away
07:09:42 <mnislaih> tags are helpful but only for names
07:10:25 <Lemmih> mnislaih: There's no such function. The closest thing is TcExpr.tcExpr.
07:11:19 <shapr> hiya Lemmih
07:11:26 <mnislaih> that would invoke the typechecker, wouldn't that be too much overhead ?
07:12:53 <Lemmih> mnislaih: You really need the typechecker if the expression is arbitrary.
07:13:55 * mnislaih starts looking for a workaround
07:15:08 <mnislaih> how about a f :: LPat id -> Type  ?
07:15:32 <mnislaih> that should be easy even to do manually
07:16:09 * mnislaih realizes that there are 20 different variants in the Pat datatype
07:16:28 <mnislaih> :S
07:19:55 <Lemmih> mnislaih: Shouldn't you be working on LHsBind instead of LHsExpr?
07:22:43 <mnislaih> I'm working on LHsBind too. But
07:23:08 <mnislaih> I am dealing with instrumenting 'do' statements now
07:26:35 <mnislaih> ok, getting the type of an arbitrary CoreExpr has to be easier
07:26:46 <mnislaih> and I can use that
07:26:50 <mnislaih> (I think)
07:26:55 <SamB> hmm, how do you implement integer division?
07:27:26 <ndm> SamB: div
07:27:34 <SamB> I said implement
07:27:48 <ndm> integerDivision = div :)
07:27:59 <astrolabe> It's a bit like long division I believe
07:28:03 <SamB> hmm
07:28:33 <astrolabe> It'll be in knuth :)
07:28:33 <musasabi> SamB: complex, buggy ways described in thick books.
07:29:04 <musasabi> SamB: look for books describing how CPUs do thing or look at various bignum libraries.
07:29:23 <mnislaih> aha! CoreUtils.exprType :: CoreExpr -> Type
07:32:09 <SamB> would that be in Volume 2, then?
07:32:28 <SamB> is there maybe a special trick for dividing by 2?
07:32:44 <astrolabe> long division base 2 is easy
07:33:50 <astrolabe> I can't remember which volume, I''ve got half a memory it's vol 1, but I'm not sure.
07:34:46 <musasabi> SamB: dividing by 2^K = shift K bits.
07:39:06 <SamB> musasabi: well, yes
07:40:43 <SamB> @hoogle pretty
07:40:44 <lambdabot> Text.Html.prettyHtml :: HTML html => html -> String
07:40:44 <lambdabot> Text.Html.prettyHtml' :: HtmlElement -> [String]
07:40:48 <SamB> @hoogle Pretty
07:40:49 <lambdabot> Text.Html.prettyHtml :: HTML html => html -> String
07:40:49 <lambdabot> Text.Html.prettyHtml' :: HtmlElement -> [String]
07:40:54 <SamB> ack
07:41:06 <SamB> @hoogle Doc
07:41:06 <lambdabot> Text.PrettyPrint.HughesPJ.Doc :: data Doc
07:41:07 <lambdabot> Language.Haskell.TH.PprLib.Doc :: type Doc
07:41:07 <lambdabot> Language.Haskell.TH.PprLib.to_HPJ_Doc :: Doc -> Doc
07:49:39 <Igloo> Is it just me or is http://www.mail-archive.com/cabal-devel@haskell.org/msg00049.html not solved in the HEAD?
07:49:40 <lambdabot> Title: Cabal package name patch
08:12:46 <fasta> How's the type of a mathematical function called? I know the two parts of it have names like domain and range (there are other names).
08:15:05 <Stinger_> define type
08:15:54 <fasta> @type map
08:15:55 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
08:17:38 <fasta> Stinger_: if you would write down map using mathematical notation, how would it's domain + codomain be called?
08:18:44 <fasta> Stinger_: Do you understand what I mean?
08:23:06 <Stinger_> I suppose it would be similar to what you get from the @type output
08:25:58 <Stinger_> dunno whether you would call the domain as the product of all unary functions with all lists and the codomain the set of all lists
08:26:52 <fasta> Stinger_: You are misunderstanding me.
08:27:01 <Stinger_> most probably :)
08:27:57 <Stinger_> you mean what are the comp sci notational equivalents of codomain and domain?
08:27:59 <gzl> what Stinger_ said is what I would have guessed too
08:28:37 <fasta> Stinger_: No, I mean how you can refer to domain + codomain in one word.
08:28:51 <gzl> what?
08:29:28 <Stinger_> is that possible? what if the domain and codomain are relatively unrelated?
08:29:34 <gzl> refer to it in one word? I think you're going to need to give an example of what you're talking about
08:29:42 <fasta> gzl: In programming languages the type of a function is codomain + word.
08:29:49 <fasta> er + domain
08:30:14 <gzl> ...ok
08:30:26 <fasta> gzl: You can refer to it with one word. #math said that object would qualify.
08:30:42 <gzl> refer to what?
08:30:44 <gzl> the type?
08:31:23 <fasta> gzl: it=type
08:31:36 <gzl> why are you looking for this? I think you're trying to name something in a way that doesn't seem to have a real purpose
08:31:59 <gzl> even in your example, I'm not sure how useful it is to say that the type of a function is 'object'...
08:32:11 <gzl> it's too generic
08:32:33 <Stinger_> yeah its kinda like saying the domain and codomain of a function fall in the set of all mathematical entities
08:32:38 <gzl> yeah, exactly
08:32:49 <fasta> Stinger_: agreed
08:33:02 <gzl> if you agree then why are we talking about this ;p
08:33:14 <fasta> gzl: I don't agree with you.
08:33:35 <gzl> but what I was saying is like what Stinger_ said, and you agree with him.
08:33:58 <fasta> gzl: I want to specify only the domain + codomain of a function and leave out the specification for that function.
08:34:19 <gzl> by specification you mean implementation?
08:34:21 <Stinger_> function signature?
08:34:39 <gzl> and if so, what does this have to do with grouping domain and codomain under 'object'
08:35:07 <Stinger_> fasta isnt that just the type of the function?
08:35:09 <gzl> I think it would help a lot if you gave an example of exactly what you're trying to do
08:35:40 <fasta> gzl: I basically want to say:"Now function f gets the type f::N -> R." (using mathematical notation)
08:35:56 <Stinger_> you want to specify the type of the function? map :: (a -> b) -> [a] -> [b]
08:36:04 <gzl> yeah, that's already done in the type signature
08:36:44 <fasta> gzl: so you suggest?
08:36:47 <Stinger_> fasta do you want to know how to write something in haskell? or in mathematical notation?
08:36:52 <gzl> what?
08:36:54 <fasta> Stinger_: math
08:38:09 <fasta> I have this discussion in which a function first had domain + codomain X, and now that same function gets a different domain.
08:38:13 <Stinger_> ok so you want to write a haskell type in mathematical notation?
08:38:35 <fasta> Stinger_: no, I don't want to write a Haskell type in mathematical notation.
08:38:40 <gzl> haha
08:38:40 <fasta> Stinger_: although it could be
08:38:48 <Stinger_> O_O
08:38:59 <gzl> ditto
08:40:16 <fasta> Ok, if you are Haskell inclined: F first had signature f::X->Y, now (because of changes in ways P, Q, and  R) it has signature f::L->X
08:40:31 <fasta> s/F/f
08:40:47 <gzl> so why can't you write it exactly like that in your document?
08:41:01 <fasta> gzl: because it's _not_ about Haskell.
08:41:11 <gzl> but f : X -> Y is not haskell notation, it's mathematical notation
08:41:36 <fasta> gzl: yes, but the wording used is not mathematical wording.
08:41:48 <fasta> gzl: there's no such thing as "signature", IIRC, in math.
08:41:56 <gzl> OH!
08:42:05 <gzl> I get it.
08:42:20 <fasta> Oh, now, you get it already :)
08:42:30 <gzl> you really could have explained that a lot better :)
08:42:48 <Stinger_> I may get it, but I'm not putting anything down conclusively :P
08:42:59 <fasta> I think it was unambiguous.
08:43:01 <gzl> I'm not sure you need to use a word at all. you could simply use type if you want, but people tend not to use a word for that
08:43:22 <gzl> it wasn't ambiguous. ambiguous would be many possible meanings. we couldn't find one possible meaning. ;)
08:43:30 <gzl> anyway
08:43:43 <gzl> I think you can just say "a function with domain A and codomain B"
08:44:10 <fasta> gzl: Can I also say f becomes f:A->B?
08:44:16 <Stinger_> generally in mathematics you dont change things, its a bit like haskell, you only make new things
08:44:17 <gzl> or "the domain of f becomes X and the codomain becomes Y after doing blah blah"
08:44:27 <gzl> yeah, you don't change the type of an existing function
08:44:29 <gzl> that's why this is confusing
08:44:44 <Stinger_> of course, you may reuse the name when you dont care about the previous function anymore
08:45:00 <fasta> In this case one mathematical structure is represented in a more efficient way by a tuple of elements.
08:45:45 <gzl> why can't you just write this out in English? just say "the domain of f becomes X and the codomain becomes Y" or whatever
08:46:09 <gzl> that's probably much clearer than trying to use jargon and symbols where they're not needed
08:46:13 <Stinger_> what you'd probably do is say X is the set of all tuples and the function is f:X->Y
08:46:53 <Stinger_> we define a new function F' that does blah (where blah is somehow related to f)
08:47:04 <gzl> right, that's the usual way of doing it
08:47:14 <Stinger_> er s/F/f/ generally
08:47:33 <gzl> modulo typos. :)
08:47:43 <Stinger_> haha
08:47:52 <Stinger_> I like that
08:48:04 <fasta> Every paper could use that one.
08:48:49 <Stinger_> modulo errors would be nice, but thats a very 'hard' problem
08:50:02 <gzl> yeah
09:18:41 <br1> Is "eol" in the prelude of hugs? ghci can't find it.
09:19:05 <wilx> @index eol
09:19:06 <lambdabot> bzzt
09:20:07 <Lemmih> There's no 'eol' in Hugs' prelude (tested with 20050308).
09:20:28 <norpan> @hoogle eol
09:20:45 <Lemmih> br1: Where is it used?
09:21:27 <lambdabot> No matches found
09:21:39 <br1> My teacher gave me some code with it.  I'm just going to change it.  Thanks.
09:22:05 <nostromo> > let facs n = scanl (*) 1 [1..n] in let fact n = facs n !! n in fact 12
09:22:07 <lambdabot>  479001600
09:22:12 <nostromo> > let facs n = scanl (*) 1 [1..n] in let fact n = facs n !! n in fact 30
09:22:13 <lambdabot>  1409286144
09:22:27 <nostromo> it does integer overflow, why?
09:22:31 <nostromo> is that a bug?
09:22:54 <int-e> nostromo: the !! forces your n to int
09:22:55 <nostromo> > let facs n = (foldl1 (*) [1..n]) in facs 30
09:22:56 <lambdabot>  265252859812191058636308480000000
09:23:12 <int-e> @type (!!)
09:23:13 <lambdabot> forall a. [a] -> Int -> a
09:23:15 <nostromo> n should be int, 30, it is the factorial that is not
09:23:28 <kpreid> @type (*)
09:23:29 <lambdabot> forall a. (Num a) => a -> a -> a
09:23:39 <int-e> nostromo: and overflows aren't errors. you're working in a ring mod 2^32 instead.
09:23:52 <kpreid> *'s outputs are of the same type, so the result is the same type as n
09:24:09 <kpreid> if you want to loosen that, you need fromIntegral at the point where you wish the type to change
09:24:10 <nostromo> now I see
09:24:21 <Lemmih> > let facs n = scanl (*) 1 [1..n] in let fact n = facs n `genericIndex` n in fact 30
09:24:23 <lambdabot>  265252859812191058636308480000000
09:24:27 <int-e> > let fact = product . enumFromTo 1 in fact 30
09:24:28 <lambdabot>  265252859812191058636308480000000
09:24:29 <nostromo> ok
09:24:30 <kpreid> let facs n = scanl (*) 1 [1..fromIntegral n] in let fact n = facs n !! n in fact 30
09:24:37 <kpreid> > let facs n = scanl (*) 1 [1..fromIntegral n] in let fact n = facs n !! n in fact 30
09:24:38 <lambdabot>  265252859812191058636308480000000
09:24:55 <nostromo> tricky
09:25:09 <norpan> yeah
09:25:43 <nostromo> so it is my first "type inferencing" bug :)
09:25:46 <norpan> lots of functions take Int when they probably should take any member of the Integral class
09:26:11 <nostromo> the "n" in !! drags the whole type to int
09:26:50 <norpan> yeah
09:26:51 <int-e> > let n :: Integer ; n = 23 in [1..] !! n
09:26:52 <lambdabot>  Couldn't match `Int' against `Integer'
09:27:12 <int-e> that happens for the same reason.
09:28:21 <kpreid> nostromo: if you'd given facs a type signature (Integer -> Integer, say), you would have gotten an error showing the problem
09:29:44 <nostromo> > let facs n = scanl (*) 1 [1..n] ; fact n ::Integer = facs n !! n in fact 12 -- shows it
09:29:44 <lambdabot>  Parse error
09:30:38 <int-e> > let facs n = scanl (*) 1 [1..n] ; fact n = (facs n !! n) :: Integer in fact 12
09:30:39 <lambdabot>  Couldn't match `Integer' against `Int'
09:30:59 <int-e> type signatures in patterns aren't Haskell 98 so lambdabot's internal parser rejects that.
09:31:35 <int-e> while type signatures in expressions are fine.
09:42:18 <nostromo> is there any "postmodern" web development/wiki framework written in haskell?
09:43:40 <SamB> yeah, lambdabot runs everything by an internal parser in order to verify that it is an expression...
09:43:53 <SamB> and not any of that tomfoolery with the )( in the middle
09:51:30 <luqui> doesn't Monad m imply Functor m
09:51:33 <luqui> ?
09:51:46 <norpan> no, but all standard monads are functors
09:51:56 <norpan> and you can do functor for any monad
09:52:25 <luqui> is there an fmap I can use if my context is (Monad m)
09:52:36 <luqui> or is it safe to make it (Monad m, Functor m)?
09:54:30 <Igloo> You can liftM
09:54:43 <luqui> ah, right
09:55:31 <norpan> liftM is == fmap
09:55:46 <luqui> yes, I remember
09:55:54 <luqui> I had forgotton about lifts
09:56:00 <luqui> thanks
10:02:45 <dcoutts> hey ndm, you're looking for buildbots?
10:02:54 <ndm> dcoutts, oh yes!
10:04:23 <ndm> dcoutts, email the Yhc mailing list, and someone will be able to hook you up with password/username
10:04:36 <ndm> certainly if you've got a different combo from what we already have, would be most appreciated
10:08:34 <dcoutts> ndm, I've got a sparc linux box
10:08:34 <mnislaih> ocaml doesn't have list comprehensions nor the Enum class, I am having a hard time trying to find out how to generate a list of numbers
10:09:02 <ndm> dcoutts, that would be nice :)
10:09:25 <beelsebob> ndm: you want an x386-darwin build-bot?
10:09:34 <beelsebob> i386 even
10:09:41 <ndm> beelsebob: yes!
10:09:50 <beelsebob> I have a ppc-darwin too if you want
10:09:52 <ndm> (didn't i ask for that one ages ago ;))
10:09:55 <ndm> more the merrier
10:09:59 <beelsebob> yeh, but I was busy paper writing
10:10:01 <ndm> darwin = os x ?
10:10:03 <beelsebob> yep
10:10:05 <ndm> i remember
10:10:10 <beelsebob> send me stoofs to set it up then :)
10:10:17 <ndm> @wiki Yhc/Buildbot
10:10:17 <lambdabot> http://www.haskell.org/haskellwiki/Yhc/Buildbot
10:10:26 <beelsebob> cool :)
10:10:30 <beelsebob> I'll get dealing with it
10:10:45 <ndm> basically email off for a password username, and follow those instructions
10:10:55 <beelsebob> kk :)
10:13:15 <ndm> beelsebob: how was the paper?
10:13:24 <ndm> hat-delta stuff again, chance of a pre-copy anywhere?
10:13:29 <beelsebob> okay, not wonderful
10:13:32 <beelsebob> not really hat-delta
10:13:41 <beelsebob> representation of functional values in a debug session
10:13:55 <ndm> that sounds cool, did you come up with a good rep?
10:14:21 <beelsebob> yes and no
10:14:27 <beelsebob> we have 3 different represetations
10:14:39 <beelsebob> two of which apply to lambda expressions
10:14:46 <beelsebob> and each of which covers a different possibility
10:14:54 <ndm> Yhc can now dynamically pull apart a function
10:14:59 <beelsebob> there's still one posibility we have no good represetation for
10:15:12 <beelsebob> which is a very complex long running function that is called a lot of times
10:15:26 <beelsebob> pull appart?
10:15:46 <ndm> you can tell the difference between f 1 and g 1 at runtime
10:15:58 <ndm> even if both return the same value
10:16:04 <ndm> i.e. trashes referential transparency
10:16:08 <beelsebob> hehe
10:16:10 <beelsebob> fun
10:26:52 <beelsebob> ndm: I can get you a centos-x86 bot
10:27:34 <ndm> beelsebob: good too, just say how many username/passwords you want, and the boxes
10:28:26 <beelsebob> ndm: I want tatd2/password with a ppc-OS X and i386-OS X, and twig/password for centos-i386
10:28:43 <ndm> beelsebob: email the list, only Andrew can do it
10:29:03 <beelsebob> k
10:34:00 <beelsebob> ndm: looks like a lot of dependancies for this
10:34:20 <beelsebob> I'm not sure it really does check for platform independance, because so few platforms will be able to build all the deps
10:34:33 <ndm> beelsebob: svn, darcs, c compiler - what else?
10:34:47 <ndm> oh, python, scons
10:35:06 <beelsebob> twisted, cvstoys, all yhcs deps
10:35:17 <ndm> cvstoys?
10:35:20 <beelsebob> (which I seem to remember not yet existing for i386-darwin)
10:35:28 <beelsebob> cvstoys is needed for buildbot
10:35:29 <ndm> twisted is only for buildbot, not for Yhc
10:35:32 <ndm> oh, ok
10:35:40 <ndm> we have an i386 buildbot, was easy
10:35:45 <beelsebob> yeh... but a yhc buildbot seems to need a *lot* of deps
10:35:51 <ndm> darwinports get buildbot, and it did all automatically
10:36:02 <SamB> twisted doesn't need building...
10:36:14 <ndm> yeah, dependancies are a concern
10:36:24 <ndm> we're intending to define 3 levels of dependancy
10:36:30 <beelsebob> oh?
10:36:34 <ndm> 1) can do buildbot, requires buildbot + rest
10:36:36 <beelsebob> I tried fink and it didn't like it
10:36:48 <ndm> 2) can do scons, ghc, gcc etc
10:36:54 <ndm> darwinports did it first time of asking
10:36:59 <ndm> on ppc and x86
10:37:05 <beelsebob> cool :)
10:37:08 <beelsebob> using it now
10:37:09 <ndm> 3) C compiler, and thats it
10:37:14 <SamB> well, I mean, maybe it will build pyc files or something if you install it...
10:37:22 <beelsebob> where do I get scons?
10:37:29 <ndm> darwinports get scons
10:37:32 <beelsebob> okay
10:37:47 <ndm> i was quite impressed with darwin ports when greg had it going!
10:38:31 <beelsebob> ndm: how do I tell buildbot what to build?
10:38:41 <beelsebob> you don't mention that in the yhc/buildbot page at all
10:38:44 <ndm> beelsebob: you don't, Andrew does
10:38:48 <beelsebob> ah, I see
10:38:56 <ndm> buildbot entirely automates it, its quite neat
10:38:57 <beelsebob> makes sense
10:39:04 <beelsebob> will I get the build product?
10:39:16 <SamB> I suppose that is why it is called "buildbot"
10:39:20 <beelsebob> i.e. is this a short cut to me getting a working, up to date yhc on my machine
10:40:09 <ndm> yes, in one of the directories, you'll have inst which you can copy and install
10:40:26 <ndm> so yes, a shortcut - once you have it set up, and broken, someone else will prod it til its fixed
10:40:50 <beelsebob> cool :)
10:40:56 <ndm> we've got an open bug to post the win32 buildbot builds online, so we'll have hourly windows builds available
10:43:54 <beelsebob> ndm: how often will this much my CPU?
10:44:21 <ndm> beelsebob: every time there is a change to the Yhc source code, not that often
10:44:30 <ndm> just nice it if you're worried
10:44:40 <beelsebob> true tha
10:44:55 <beelsebob> it's not gonna be a problem really
10:45:11 <ndm> nah, i run it on my main work machine, without nice or anything
10:45:11 <beelsebob> I have dual 1.83Ghz processors, I'm not going to notice a major dent
10:45:46 <SamB> what if it used *both* of them?
10:46:37 * int-e hands beelsebob a hammer
10:46:43 <int-e> (for making dents)
10:46:48 <beelsebob> dents?
10:47:00 <beelsebob> oh, I see
10:47:10 <int-e> for denting things.
10:47:16 <scc> a bit dents aren't we
10:47:17 <beelsebob> right... I have buildbot set up now
10:47:20 <beelsebob> just need andrew now
10:47:22 <scc> forgive me
10:48:00 <ndm> andrew should get to it tomorrow morning
10:48:29 <greenrd> Is there a tool to automatically generate .hs-boot files?
10:49:46 <ndm> greenrd: no
10:50:24 <scc> hello monochrom I (was samc) never did get the second half of your paper can I download it somewhere?
10:50:34 <greenrd> I don't understand why .hs-boot files are needed anyway
10:50:46 <greenrd> Either there is enough information or there isn't.
10:50:53 <greenrd> If there is not enough information, you need to add it.
10:50:57 <monochrom> What second half of what paper?  I fail to recall...
10:53:16 <ndm> greenrd: bad implementations, nothing more, nothing less
10:53:28 <ndm> its entirely possible to get rid of them, and i consider it a bug that you can't
10:53:32 <beelsebob> ndm: why do you still get 510 patches when you do a --partial on yhc?
10:53:49 <ndm> beelsebob: i have no idea, i did a -tag but it didn'#t have any effect
10:53:55 <beelsebob> :(
10:54:22 <scc> I don't recall the name but it contained the proof of the converse of a loop law in Back's formalism (I think)
10:54:56 <scc> it's on another computer
10:57:12 <monochrom> Wow. I fail to recall giving it out even. :)
10:57:27 <monochrom> I didn't have time to write the second half.
10:57:34 <scc> :(
10:59:10 <int-e> ndm,  darcs optimize --checkpoint -t <tag>  seems to be needed.
10:59:24 <ndm> int-e: cheers, will try that now,...
10:59:33 <scc> I remember you said it was of only theoretical interest, but I wasn't so sure. Are you familiar with Martin Ward's work?
10:59:43 <monochrom> No.
11:01:24 <ndm> int-e: worked perfectly, thanks
11:01:31 <int-e> nice :)
11:01:32 <scc> he does some cool going backwards stuff http://www.dur.ac.uk/martin.ward/
11:01:34 <lambdabot> Title: Martin Ward's Home Page
11:03:31 <shapr> scc: hiya! long time no see!
11:03:41 <scc> his "pigs from sausages" paper and such seem very impressive to me
11:03:46 <scc> hey shapr
11:04:00 <scc> as a feat
11:04:01 <monochrom> ok, "pigs from sausages" does it! :)
11:05:02 <shapr> scc: Do you have a website/blog/etc ?
11:05:59 <scc> shapr, still no, I always intend to but never get round to it
11:06:04 <TwigEther> win 2
11:06:07 <TwigEther> fail! :)
11:06:18 <shapr> aww
11:06:56 <beelsebob> gyah!
11:07:05 <beelsebob> how do I set the header search paths again?
11:07:46 <shapr> -i
11:07:52 <beelsebob> no, globaly
11:07:53 <shapr> Wait, what header?
11:07:55 <beelsebob> what env variable
11:08:06 <shapr> Probably something with caps INCLUDE ?
11:08:09 <beelsebob> gmp.h
11:08:23 * shapr should remember that...
11:08:39 <scc> shapr have you fixed your news feed suckiness yet?
11:08:51 <shapr> scc: yup
11:08:57 <shapr> @where shapr
11:08:57 <lambdabot> http://www.ScannedInAvian.com/hope
11:09:18 <shapr> And I have three months worth of good articles in my new blog.
11:09:20 <shapr> @users
11:09:24 <lambdabot> Maximum users seen in #haskell: 235, currently: 221
11:09:30 <shapr> spiffy
11:09:34 <dcoutts> indeed
11:09:48 <scc> cool
11:10:51 <greenrd> Hmm.
11:11:26 <greenrd> Should I write a .hs-boot file generator, or should I cut and paste the minimal amount of code from one module to another to break module circularity?
11:11:29 <TwigEther> I take it to fix this I need a shiny new version of ghc rather than than ghc 6.4.1 th I have now? < http://www.uploadthis.co.uk/uploads/Twigathy/doom.txt >
11:12:44 <ndm> greenrd: usually just easier to move the code around
11:13:03 <greenrd> yeah, that's what I thought
11:16:02 <beelsebob> yay! scons picked up this time
11:16:13 <beelsebob> and we're grabbing libffi :)
11:16:23 <beelsebob> eek! messyness
11:17:58 <beelsebob> http://www.cs.kent.ac.uk/people/rpg/tatd2/error.txt <-- BOOM!
11:18:52 <beelsebob> ndm: poik
11:19:06 <beelsebob> why the hell is it trying to compile System V stuff?
11:22:54 <ndm> beelsebob: hmm, must have misread your arch
11:23:13 <ndm> blame Andrew
11:23:58 <ndm> or just wait til you have uildbot, he can fix it from there easily enough
11:33:08 <mnislaih> @tell Lemmih I have uploaded two more patches to my repo, and although it is not yet done, this thing starts to be usable in real world code. Feel free to play with it!
11:33:08 <lambdabot> Consider it noted.
11:34:08 <ookk> if i have written a .hs file with a module in it how do i include it in compilations with GHC?
11:34:12 <Lemmih> @tell mnislaih Will do.
11:34:13 <lambdabot> Consider it noted.
11:34:30 <mnislaih> heh :)
11:34:30 <lambdabot> mnislaih: You have 1 new message. '/msg lambdabot @messages' to read it.
11:35:05 <Lemmih> @tell mnislaih You've got a message. (:
11:35:05 <lambdabot> Consider it noted.
11:35:08 <mnislaih> Lemmih, I tested the overhead with a dumb qsort function and with the mergesort code from Data.List
11:35:09 <lambdabot> mnislaih: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:35:34 <mnislaih> 25x in the 1st case, 9x in the second
11:35:58 <mnislaih> good news is that if debugging mode is on and there are no breakpoints active, the overhead can be made zero
11:36:12 <mnislaih> so in a way it can be always on. Overhead in compiling is not noticeable
11:36:21 <Lemmih> Neat.
11:36:21 <lambdabot> Lemmih: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:36:37 <abcde`> Is this a sort of "I'm not going to talk to you ever again!" way of communicating?
11:36:49 <abcde`> via a third party
11:36:57 <mnislaih> lol abcde`
11:37:10 <mnislaih> it's just I didn't expect Lemmih would be on the keyboard
11:37:16 <int-e> > unwords $ repeat "silly"
11:37:17 <lambdabot>  "silly silly silly silly silly silly silly silly silly silly silly silly sil...
11:37:18 <mnislaih> and I was about to part
11:37:34 * mnislaih parts
11:39:15 <svref> Is anyone here reasonably conversant in both Haskell and Common Lisp?
11:39:52 * basti_ only knows a little lisp
11:40:02 <scc> shapr, it seems to me that logic alphabet thing you mention can be improved
11:41:39 <svref> In Common Lisp, all the list functions take optional arguments "key" and "test".  Specifying a test is equivalent to the Haskell *By functions.  But I don't see anything equivalent to the "key" argument.
11:42:29 <svref> Say I have a list of fruit objects, and I want to sort them according to color.  How would I do that?
11:42:50 <shapr> scc: How so?
11:43:08 <Lemmih> svref: sortBy?
11:43:27 <SamB> sortBy (comparing fruitColor)
11:43:40 <svref> okay, closer
11:43:55 <SamB> but note that comparing is not yet in Prelude
11:44:18 <int-e> comparing f a b = f a `compare` f b
11:44:19 <SamB> is it going to be, I wonder...
11:44:34 <int-e> it should be somewhere. :)
11:44:49 <SamB> where would you put it?
11:44:54 <SamB> Data.List?
11:45:04 <int-e> Data.Ord (which doesn't exist)? Prelude?
11:45:27 <SamB> hmm, Data.Ord doesn't yet exist?
11:45:37 <SamB> I suppose there isn't a whole lot of demand
11:45:37 <int-e> Data.Ordering of course, but no, that doesn't exist.
11:46:04 <int-e> it's certainly Prelude-ish.
11:47:55 <scc> Here's one example: consider a square with central dot the top of which is visible if both arguments are true, the left if only the left, the right if only the right, and the bottom if neither. In this way the underlying Boolean table is tilted 45 degrees and so symmetrical with respect to both arguments and so commutative operations are symmetrical along the vertical axis.
11:47:57 <scc> also equality looks like equality :)
11:49:23 <scc> because only the top and bottom of the square are visible. I must have explained myself poorly
11:49:58 <scc> ...is visible if the result is true when...
11:50:06 <SamB> oh, you mean the (==) gate
11:51:22 <scc> or are we out of sync
11:54:02 <svref> how do I get the unary - function?  (-) gives me the binary one.
11:54:25 <abcde`> (*(-1))?
11:55:07 <psi> > negate 1
11:55:08 <lambdabot>  -1
11:55:27 <sieni> @pl \x -> -x
11:55:27 <lambdabot> (line 1, column 7):
11:55:27 <lambdabot> unexpected "-"
11:55:27 <lambdabot> expecting lambda abstraction or expression
11:55:35 <sieni> @pl (\x -> -x)
11:55:35 <lambdabot> (line 1, column 8):
11:55:36 <lambdabot> unexpected "-"
11:55:36 <lambdabot> expecting lambda abstraction or expression
11:56:11 <abcde`> @pl (\x -> (-x))
11:56:12 <lambdabot> subtract
11:56:18 <abcde`> hm?
11:56:40 <Igloo> It's parsing it (incorrectly) as a section
11:56:45 <scc> you could also make the sides convex or concave for true or false in which case all the operations could be written cursively in a stylised form. The infinity sign for equality for example. the negating the result would be like turning inside out
11:57:02 <svref> thank you.
12:04:51 <shapr> scc: Draw it? I have to go...
12:05:05 <kolmodin> dons: is hs-plugins 1.0 released? in that case, could you please make a tarball?
12:05:34 <dcoutts> dons, yes, you don't get any gentoo ebuild 'til you make a tarball :-)
12:05:51 <kolmodin> :)
12:06:59 <br1> I'm getting "Illegal instance declaration for X Y Z...".  Any ideas?  I don't see anything wrong.  It's code generated by polyp.
12:13:25 <svref> can you look at the function at http://www.osaurus.us/~dm/tmp/merge.hs and tell me why it doesn't compile, and how to actually write the Probably fix suggested by ghci?
12:16:54 <br1> svref: Write a type for merge.
12:17:15 <svref> br1: I don't know how to do that.
12:19:26 <br1> merge :: (a -> a -> Bool) -> [a] -> [a]
12:19:26 <br1> merge = mergeBy compare
12:23:17 <svref> I think merge :: [a] -> [a] -> [a] and mergeBy :: (a -> a -> Ordering) -> [a] -> [a] -> [a], but that doesn't seem to make the compiler any happier
12:24:26 <br1> merge :: Ord a => [a] -> [a] -> [a]
12:24:26 <br1> merge = mergeBy compare
12:25:05 <svref> ah!
12:25:09 <br1> :)
12:25:52 <svref> So its not smart enough to trace through and figure out that arguments to compare are instances of Ord...
12:25:55 <stepcut> you might also want to add the type signature: mergeBy :: (Ord a) => (a -> a -> Ordering) -> [a] -> [a] -> [a]
12:26:44 <svref> I guess because it doesn't know that mergeBy is ever going to be called with non-empty lists...
12:26:58 <stepcut> if you use the flag, -fno-monomorphism-restriction, then it can figure it out
12:27:37 <stepcut> but giving it a type signature is probably a better solution
12:29:48 <stepcut> (regarding my earlier statement 'mergeBy :: (a -> a -> Ordering) -> [a] -> [a] -> [a]' is probably sufficient -- the '(Ord a) =>' is not needed there)
12:29:50 <araujo> hi
12:29:56 <araujo> anybody uses hsshellscript here?
12:40:46 <eivuokko> ndm, Does Hugs' System.Process work after Ross Patterson's patch? o.O
12:41:13 <br1> fwiw, my Illegal instance declaration problem was solved by -fglasgow-exts
12:46:44 <ookk> i have seen ppl use the \\ operator for removing an item from a list but i get "not in scope" when i try to use it, is it not in the standard language?
12:46:58 <dcoutts> @hoogle (\\)
12:47:00 <lambdabot> Did you mean: (\\)
12:47:00 <lambdabot> Prelude.undefined :: a
12:47:00 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
12:47:09 <dcoutts> heh
12:47:12 <dcoutts> @hoogle \\
12:47:13 <lambdabot> Hoogle Error: Parse Error: Unexpected character '\\'
12:47:17 <dcoutts> bah
12:47:34 <ookk> [1,2,3]\\2 = [1,3]
12:47:39 <ookk> is there no such operator?
12:47:52 <dcoutts> @type (Data.List.\\)
12:47:53 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
12:48:07 <dcoutts> > [1,2,3]\\2 = [1,3]
12:48:08 <lambdabot>  Parse error
12:48:12 <dcoutts> > [1,2,3]\\2
12:48:13 <lambdabot>  add an instance declaration for (Num [a])
12:48:17 <dcoutts> ugg
12:48:23 <dcoutts> > [1,2,3]\\ (2 :: Int)
12:48:24 <lambdabot>  Couldn't match `[a]' against `Int'
12:48:35 <dcoutts> oh
12:48:41 <dcoutts> > [1,2,3]\\ [2 :: Int]
12:48:42 <lambdabot>  [1,3]
12:48:59 <dcoutts> ookk, you just need to import Data.List
12:49:06 <Lemmih> > delete 2 [1,2,3]
12:49:07 <lambdabot>  [1,3]
12:49:08 <ookk> ahh ok thx
12:49:21 <dcoutts> yeah, or use delete
12:50:28 <ookk> delete is also not in scope?
12:50:36 <Lemmih> @index delete
12:50:37 <lambdabot> Data.HashTable, Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
12:50:38 <ookk> should i import Data.List for that function also?
12:50:46 <ookk> oki thx
13:43:40 <hitodama> does anyone have reccommendations for a text editor/IDE for a haskell newbie on windows?
13:43:55 * Heffalump uses xemacs on Windows
13:45:55 <wilx> Heffalump, what version of XEmacs do you use? If I may ask?
13:46:10 <Heffalump> 21.4.19
13:46:13 <wilx> haskell-mode kinda refuses to work for me with the latest stable release....
13:46:38 <Heffalump> seems ok to me, apart from its usual niggles (block commenting for example, not matching brackets correctly after a lambda)
13:50:18 <hitodama> where is the .xemacs file on windows?
13:52:01 <SamB> I can only assume that opening up ~/.xemacs in XEmacs would get you to it
13:52:04 <wilx> I have $HOME set so it is there.
14:40:28 <hitodama> hmm, I tried to compile a hello world program (the first code listing in the Scheme in 48 hours tutorial)
14:40:35 <hitodama> I got this as an error message
14:40:37 <hitodama>  Attilla:~ ajay$ ghc -o hello_you test.hs
14:40:38 <hitodama> compilation IS NOT required
14:40:38 <hitodama> /usr/bin/ld: can't locate file for: -lgmp
14:40:38 <hitodama> collect2: ld returned 1 exit status
14:40:57 <hitodama> this is on a mac, I installed ghc via fink
14:42:12 <dcoutts> hitodama, you need the gmp library installed
14:42:24 <dcoutts> ideally your packaging system should have done that for you
14:43:43 <dcoutts> hitodama, in the mean time you can use ghci to try your code interactively
14:44:06 <dcoutts> rather than producing a stand alone program
14:44:20 <dcoutts> perhaps you can use fink to install libgmp
14:44:54 <hitodama> yeah, found it in fink
14:44:58 <hitodama> I will try installing it
14:44:59 <dcoutts> fi you find that fixes things then perhaps file a bug with the fink people to tell them they're missing the libgmp dependency
14:45:31 <hitodama> hmm
14:45:50 <kpreid> @tell svref I'm "reasonably conversant in both Haskell and Common Lisp", and would be happy to answer questions
14:45:50 <lambdabot> Consider it noted.
14:47:10 <hitodama> hmm, now it compiles, but gives me an error when I run it
14:47:20 <hitodama> Attilla:~ ajay$ ./hello_you
14:47:21 <hitodama> hello_you: Prelude.(!!): index too large
14:48:08 <kpreid> hitodama: use genericIndex instead of (!!)
14:50:24 <hitodama> do I just replace !! with genericIndex in the code, or does it use different syntax
14:50:58 <kpreid> !! works like `genericIndex`
14:51:07 <kpreid> (!!) works like genericIndex
14:51:27 <kpreid> if it's punctuation, it's infix by default; if it's letters, it's prefix by default, but `` and () change that
14:51:46 <kpreid> > "aardvarks" !! 5
14:51:47 <lambdabot>  'a'
14:51:51 <kpreid> > "aardvarks" `genericIndex` 5
14:51:52 <lambdabot>  'a'
14:52:08 <kpreid> (!!) '
14:52:17 <kpreid> > (!!) "aardvarks" 5
14:52:18 <lambdabot>  'a'
14:52:31 <hitodama> hmm, thanks, it makes a bit of sense now
15:00:13 <Pupeno> What is " Shorter lead times." ?
15:03:13 <eivuokko> dcoutts, Hiya.  Didn't we talk about make -j2 with ghc?  I think it doesn't work in Windows, primops.txt should depend on stage1/ghc_boot_platform.h
15:03:42 <dcoutts> eivuokko, I've never tried it on windows
15:04:01 <dcoutts> but we do build with -jN by default on gentoo and havn't had any bug reports
15:04:13 <dcoutts> doens't mean it's not borken on windows of course
15:04:24 <eivuokko> Right.
15:04:30 <dcoutts> I that's doubt it's been tested there before
15:04:39 <Pupeno> Mentioned on http://haskell.org/haskellwiki/Introduction
15:04:40 <lambdabot> Title: Introduction - HaskellWiki
15:05:19 <eivuokko> Thanks, any idea how to add dependency correctly?  Just put it into makefile?  Seems a bit dubious as it always depends on stage1 header.
15:07:29 <dcoutts> hmm
15:09:21 <dcoutts> eivuokko, well if it's a simple dep then yeah, just add it to the makefile
15:10:10 <dcoutts> I'm not sure I understand the stage subtulty
15:11:03 <eivuokko> I don't know if there's anythign special there.  But it's hard to say.
15:11:49 <astrolabe> I've got a copy of winhugs at work, but its response lines are invisible.  Can anyone say why?
15:21:42 <astrolabe> If you don't know, it's fine to talk amongst yourselves  :)
15:21:56 <eivuokko> :)
15:32:50 <eivuokko> dcoutts, First tries...simple dep seems to work...doing full build now.  Thanks for the help.
15:32:58 <dcoutts> np
15:33:07 <dcoutts> I didn't do anything :-)
15:43:35 <Pupeno> is it possible to run ghci inside emacs ?
15:47:53 <musasabi> Pupeno: yes.
15:52:20 <Patterner> I have a problem with Cabal (from svn, 1.1.5). "make install" fails with "setup: cannot satisfy dependency Cabal>=1.1.4".
15:53:06 <Pupeno_> is it possible to run ghci inside emacs ?
15:54:43 <abcde`> Pupeno: M-x comint-run?
15:55:02 <abcde`> well, M-x comint-run ghci
15:55:34 <Pupeno_> nothing better than that ? (like automatic loading the open file or something like that ?)
15:56:05 <eivuokko> dcoutts, Don't know if you're interested, but fwiw -j2 couldn't work all the way.  Non-repeating error...yay :-S  Guess I'm back to clean and no -j2.
15:56:08 <abcde`> don't think so...
15:56:27 <dcoutts> eivuokko, :-( is that ghc-6.4.2 or 6.5 ?
15:57:03 <int-e> @where gtk2hs
15:57:03 <lambdabot> http://haskell.org/gtk2hs/
15:57:13 <eivuokko> dcoutts, 6.5
15:57:36 <dcoutts> eivuokko, ah ok, I've note tried that with -j2 for a while
16:00:46 <emertens> do I have to have glade installed before I compile gtk2hs to use it?
16:01:05 <dcoutts> emertens, yes, since it needs the libglade header files
16:01:33 <dcoutts> btw glade is the gui builder, libglade the thing gtk2hs uses to load the files at runtime
16:01:57 <emertens> right
16:02:06 <emertens> In doing this on OS X
16:02:15 <emertens> just figuring out what ports  I need to install
16:02:22 <dcoutts> right
16:02:29 <dcoutts> I think there is a gtk2hs port already
16:02:50 * emertens notices that gtk2hs 0.9.10 is in darwinports
16:02:56 <dcoutts> yes :-)
16:03:12 <dcoutts> I'm looking forward to someone trying the new Gtk+ 2.10 on OSX with Gtk2Hs
16:03:27 <emertens> What would that entail?
16:03:30 <dcoutts> the new Gtk+ 2.10 can be built to not use X11
16:04:10 <dcoutts> well practically speaking it'd have to be in the ports collection or whatever other package collections it is people use
16:04:26 <dcoutts> the OSX native backend is still a bit experimental
16:04:31 <emertens> looks like darwinports has 2.8.19
16:04:35 <dcoutts> right
16:04:43 <dcoutts> same on gentoo
16:05:15 <dcoutts> it seems to take a while for major Gtk+ releases to get distributed generaly
16:06:02 <dcoutts> it often seems to take the following gnome release to get it distributed widely
16:06:15 <dcoutts> it's the same on win32 last I checked, only 2.8.x available
16:06:28 <jer> dcoutts, that's because larger applications like gnome (and any other programs that depend on gtk) need to be thoroughly tested against the new major gtk+ version
16:06:43 <jer> before operating systems tend to bump it, they make sure its safe first
16:06:44 <dcoutts> yeah I guess so
16:06:51 <dcoutts> to knock out the new bugs in gtk+
16:07:31 <Patterner> "[ebuild   R   ] x11-libs/gtk+-2.10.1" :)
16:10:18 <dcoutts> Patterner, ah ok, I hadn't noticed it get into portage, that and I usually run stable
16:10:31 <Patterner> it's bleedin' edge...
16:10:44 <dcoutts> I'm probably one of the few gentoo devs who only runs a stable profile :-)
16:10:56 <Patterner> wuss :)
16:11:22 <dcoutts> well of course all the haskell stuff I use is ~arch
16:11:48 <Patterner> too bad i have cabal problems under os x...
16:12:05 <dcoutts> do you use gentoo on osx ?
16:12:59 <dcoutts> I'm looking for help with the haskell packages on gentoo/ppc/osx
16:13:30 <Patterner> no. i use gentoo on my x86_64 desktop and os x on my powerbook
16:13:54 <dcoutts> some crazy gentoo devs are working on gentoo for freebsd and darwin
16:14:46 <Patterner> excentric, not crazy :)
16:15:05 <dcoutts> :-)
16:15:35 <Patterner> you don't know, by chance, how to install Cabal from svn..?
16:15:36 <emertens> Is "Gentoo for FreeBSD" just freebsd + portage?
16:16:01 <dcoutts> emertens, basically yes, but uses all the fbsd base libs
16:16:12 <dcoutts> Patterner, you mean from darcs surely?
16:16:22 <Patterner> s/svn/darcs/
16:16:42 <dcoutts> Patterner, darcs get http://darcs.haskell.org/packages/Cabal
16:16:44 <lambdabot> Title: Index of /packages/Cabal
16:17:00 <Patterner> But "sudo make install" fails with "setup: cannot satisfy dependency Cabal>=1.1.4".
16:17:13 * Patterner pats lambdabot
16:17:24 <eivuokko> dcoutts, re: ghc and make -j2.  I don't understand how -j2 could work.  HsVersions.h depends on ghc_boot_platform.h, but nothing is marked to depend on HsVersions.h or ghc_boot_platform.h.  Oh, well.
16:17:52 <dcoutts> sounds bad
16:17:56 <dcoutts> file a bug
16:18:06 <dcoutts> now is the time to fix that sort of thing
16:18:11 <eivuokko> I'm writing a mail.
16:18:12 <dcoutts> just before the release
16:18:27 <Patterner> i hoped you have a simple solution...
16:18:43 <eivuokko> Yeah, I'm trying to help a bit on release...want to have good Windows build.
16:19:02 <dcoutts> Patterner, hmm, make should just work
16:19:14 <Patterner> make works. make install doesn't.
16:19:22 <dcoutts> ah right
16:20:15 <dcoutts> Patterner, try sudo ./setup install
16:20:21 <Pupeno_> how do I print the type of an object ?
16:20:36 <dcoutts> Pupeno_, in ghci use :type blah
16:20:44 <dcoutts> or here say:
16:20:45 <Pupeno_> thanks.
16:20:49 <dcoutts> @type (+)
16:20:50 <lambdabot> forall a. (Num a) => a -> a -> a
16:20:52 <madpickle> what's the fastest way to get the i'th digit from a number (like getting '4' from 123456)
16:21:16 <dcoutts> (!!i) . show
16:21:31 <Patterner> setup install installed
16:21:47 <madpickle> doesn't appear to work
16:21:52 <madpickle> (in Hugs)
16:22:20 <dcoutts> > ((!!4) . show) 123456
16:22:21 <lambdabot>  '5'
16:22:31 <Patterner> and "make install" works too
16:22:45 <madpickle> so:
16:22:45 <dcoutts> Patterner, any idea what was going wrong then?
16:22:50 <madpickle> > (!!2) . show $ 123
16:22:51 <lambdabot>  '3'
16:23:01 <madpickle> thanks for your help, dcoutts.
16:23:06 <kpreid> > (\x i -> (x `div` (10 ^ i)) `mod` 10) 12345 2
16:23:07 <lambdabot>  3
16:23:12 <kpreid> -- if you don't mind counting from the right
16:23:14 <madpickle> yeah, that's what i used before
16:23:19 <Patterner> well, "setup install"ed a Cabal 1.1.5 which was used by the "make install"
16:23:22 <madpickle> but it wasn't particularly efficient with all the divs and mods
16:23:24 <kpreid> (or if you want a numerically sensible answer rather than a textually sensible one)
16:23:40 <Patterner> no idea why "setup install" wasn't called during "make install"
16:24:01 <madpickle> > read $ [(!!2) . show $ 123] :: Integer
16:24:02 <lambdabot>  3
16:24:07 <dcoutts> Patterner, it is, see the makefile, it also does some other stuff
16:24:09 <madpickle> so that's what i'll be using. not sure if it actually *is* faster
16:24:11 <madpickle> we'll see =D
16:25:21 <Patterner> "make -n install" shows no "./setup install" (only in cabal-install and cabal-setup)
16:25:32 <emertens> > @type logBase
16:25:32 <lambdabot>  Parse error
16:25:33 <dcoutts> madpickle, it's probably more sensible to use arithmatic than strings
16:25:38 <emertens> @type logBase
16:25:40 <lambdabot> forall a. (Floating a) => a -> a -> a
16:25:49 <emertens> > logBase 2 8
16:25:50 <lambdabot>  3.0
16:26:01 <emertens> > logBase 100 12345
16:26:03 <madpickle> dcoutts: i suppose so. it's only that for a lot of repeat computations i find that it takes quite a while.
16:26:03 <lambdabot>  2.0457455471339756
16:26:22 <madpickle> the `div` method is what i used before.
16:26:28 <Patterner> you know what they say about "premature optimization", right?
16:26:34 <dcoutts> madpickle, repeat computations? I don't see any
16:26:37 <madpickle> this isn't premature optimization
16:26:39 <madpickle> not in that
16:27:06 <Patterner> "faster".  I rest my case.
16:27:08 <madpickle> if i have to wait 20 mins to get an answer to something that is the direct result of a really efficient way of doing it, then i'd rather optimize it.
16:27:21 <madpickle> i'm doing these programmatic maths challenges
16:27:33 <emertens> link?
16:27:39 <dcoutts> going via strings will be slower
16:27:40 <madpickle> http://www.mathschallenge.net/index.php?section=project
16:27:42 <lambdabot> Title: mathschallenge.net
16:28:31 <madpickle> i know full well about premature optimizations; i'm not new to programming, only to haskell. my only concern is making something that will actually compute in a reasonable time.
16:28:39 <madpickle> esp. since a fair bit of trial and error is involved.
16:32:34 <madpickle> nice site, eh?
16:32:38 <madpickle> see what i mean about computation?
16:35:02 <emertens> I'm going to do a bunch of those mathschallenge problems to give haskell a numbers boost
16:35:16 <madpickle> ok =)
16:44:39 <Pupeno_> On page 17 of http://www.haskell.org/tutorial/haskell-98-tutorial.pdf, take1 0 bot fails because 0 matches _ and to try to match bot to [] it evaluates bot, which fails ?
16:46:02 <LordBrain> is that the gentle introduction?
16:46:08 <int-e> right
16:46:25 <int-e> (both of you)
16:46:56 <Pupeno_> thanks.
16:50:10 <Korollary> "Consequently each problem is based on the performance of Visual Basic using a reasonably efficient algorithm"
16:52:18 <emertens> is there an obviously more efficient way to do this: let primes = sieve [2..] where sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in primes !! 10000
16:52:45 <madpickle> lol
16:52:49 <madpickle> well well =)
16:52:56 <int-e> yes.
16:53:09 <madpickle> which question?
16:53:09 <emertens> I just ripped that sieve off
16:53:14 <emertens> cale's page
16:53:29 <int-e> > let primeP n = all ((0/=) . (n`mod`)) (takeWhile (
16:53:30 <lambdabot>  Parse error
16:54:22 <int-e> > let primeP n = all ((0/=) . (n`mod`)) (takeWhile (\p -> p*p <= n) primes); primes = 2:filter primeP [3,5..] in take 10 $ drop 1000 primes
16:54:23 <lambdabot>  [7927,7933,7937,7949,7951,7963,7993,8009,8011,8017]
16:54:49 <int-e> that's the first obvious idea, only test primes up to sqrt(n).
16:55:04 <madpickle> people have done that questioin in x86 assembler
16:55:17 <madpickle> and the solution is shorter and more concise than most of the C++ ones
16:56:32 <emertens> actually, when I ran my solution
16:56:34 <emertens> with -O
16:56:35 <emertens> in compiled for
16:56:39 <emertens> instead of interpreted
16:56:42 <emertens> it ran rather quickly
16:57:31 <emertens> 16 people said that they solved that problem with pen / paper
16:57:42 <madpickle> hello looking it up on the internet
16:58:10 <int-e> for speed, http://cr.yp.to/primegen.html is quite neat.
16:58:24 <int-e> what's the problem?
16:58:36 <emertens> I think that the sieve i used is pretty efficient... like a sieve is supposed to, it only checks `mod` x == 0 on primes, not all numbers < ./n
16:58:48 <int-e> oh, you gave the link above.
16:59:16 <emertens> sieve of atkin?
17:02:56 <madpickle> that website is an excellentw ay to learn any language
17:03:02 <Pupeno_> ok, time to sleep... learning Haskell is so fun.
17:12:04 <joelr1> good evening
17:12:27 <joelr1> anyone willing to run a short program for me?
17:12:29 <joelr1> http://wagerlabs.com/fpu.c
17:12:50 <joelr1> you would need to be on intel, on a recent processor
17:14:36 <Patterner> result = 8.27652E+06  status = 0  control = 37f  ip = 80456a32  cs = 10  op = 0
17:15:06 <Patterner> I'm not an expert but I don't think that's haskell code, right?
17:15:48 <joelr1> Patterner: not at all :) thanks, though. what processor did  you run that on? OS?
17:15:59 <Patterner> guess :)
17:16:25 <joelr1> Patterner: ugh... linux/p4?
17:16:29 <joelr1> Patterner: mac osx?
17:16:37 <Patterner> linux amd64
17:16:41 <madpickle> not sure if it would work properly on windows. not sure windows would let you touch the FPU directly
17:16:53 <joelr1> Patterner: ah, AMD does not work
17:17:03 <joelr1> i need a core duo or p4 or something like that
17:17:08 <Patterner> *sniff*
17:17:13 <joelr1> oh, wel
17:17:15 <joelr1> well
17:17:19 <joelr1> thank you guys!
17:17:30 <int-e> weird.
17:17:43 <Pseudonym> Do we have a new keal?
17:18:01 <dons> hmm?
17:18:08 <Korollary> if only
17:18:18 <Pseudonym> I realise nobody could replace keal.
17:18:53 <Korollary> at best a sidekick
17:18:55 <int-e> I really wonder what that program is supposed to do if it 'works'.
17:19:07 <madpickle> well
17:19:49 <int-e> it does a multiplication, then more stuff with the fpu while printing, then stores the fpu status somewhere and prints a few of its values.
17:20:10 <madpickle> seems to get the fpu status right then and there. whatever might be in it.
17:20:41 <madpickle> instruction pointer, segment, and opcode (?)
17:20:44 <madpickle> opcode addr it seems.
17:20:55 <int-e> operand address, more likely
17:21:11 <int-e> hmm. na
17:21:29 <madpickle> he's just querying the FPU for details on storage
17:21:39 <madpickle> i doubt intel would ever change anything between the architectures
17:21:45 <madpickle> that significant anyway
17:23:08 <int-e> Patterner: oh, is that a 2.4.x kernel?
17:23:23 <int-e> the addresses are in kernel space, apparently
17:23:52 <Patterner> 2.6
17:25:53 <int-e> funny. I get addresses in the 0xC0...... area.
17:25:59 <lisppaste2> LordBrain pasted "Yi MVar trouble" at http://paste.lisp.org/display/24084
17:26:13 <emertens> finding the sums of the prime numbers below 10^6 seems to take a little more time than the previous problems :)
17:33:04 <Lemmih> LordBrain: Trouble?
17:34:00 <emertens> if I used the BSD primes(6) tool... and then parsed the results with Haskell...
17:34:07 <dcoutts> sum . takeWhile (<10^6) $ primes where primes = ...
17:34:11 <emertens> did I use haskell...
17:34:15 <emertens> primes
17:34:16 <emertens> or cheat
17:34:17 <emertens> :)
17:34:30 <dons> LordBrain: yes, so you definitely can't call getBufferWith down inside a withEditor block
17:34:43 <emertens> $ primes 1 999999  > primes.txt   runs lightning fast
17:35:33 <dons> LordBrain: however, you do have the editor itself, 'e',
17:35:50 <dons> so you should be able to look up the buffer directly, without needing to take the editor state MVar
17:36:09 <emertens> dcoutts: that takeWhile code was what I did first, but it was taking forever
17:36:11 <dons> (if there's no editor state accessor to allow this, you could add it)
17:36:22 <LordBrain> ok
17:36:25 <LordBrain> hmm
17:37:00 <dons> you just can't call: readEditor inside a withEditor block
17:37:10 <dons> you could call: findBufferWith (e :: Editor) u
17:37:12 <dons> though, I think
17:37:59 <dons> (i.e. you need to find the unthreadsafe functions that take an editor as an argument, not the ones that lock yi, and access the editor state)
17:39:39 <kpreid> is it anything of note to cause ghc to say "My brain just exploded."?
17:39:51 <dcoutts> emertens, I can do 10^5 in less than a minute with a simple algorighm
17:39:56 <dons> yes, you have reached level 5, kpreid
17:40:21 <dcoutts> emertens:
17:40:22 <dcoutts> main = print . sum . takeWhile (<10^5) $ primes
17:40:22 <dcoutts> primes = sieve [2..]
17:40:22 <dcoutts>   where sieve (p:x) = p : sieve [ n | n <- x, n `mod` p > 0 ]
17:40:34 <dcoutts> and for more sophisticated primes code see:
17:40:36 <dcoutts> http://www.haskell.org/hawiki/SieveOfEratosthenes
17:40:37 <lambdabot> Title: SieveOfEratosthenes - The Haskell Wiki
17:40:39 <kpreid> dons: does it count if I don't really know what I'm doing? :)
17:40:54 <dons> you're trying to pattern match on an existential, I think
17:40:59 <kpreid> yup
17:41:03 <dcoutts> with a let
17:41:08 <dcoutts> rather than a case
17:41:13 <dcoutts> iirc
17:41:14 <kpreid> hm.
17:41:54 <kpreid> well, I'm pretty sure existentials aren't what I want anyway
17:45:06 <Dylan> woah
17:45:17 <Dylan> I'm getting linker errors with something that works fine with ghci
17:46:09 <lisppaste2> Dylan pasted "shadow.hs" at http://paste.lisp.org/display/24085
17:46:21 <greenrd> Is it just me, or is this error message arse-backwards: Expecting a function type, but found `blah blah`
17:46:32 <greenrd> Then it prints a NON-function type as the "expected" type
17:46:39 <greenrd> and a FUNCTION type as the "inferred" type
17:46:45 <greenrd> That always confuses me
17:46:57 <Lemmih> Dylan: Forgot a --make?
17:47:05 <Dylan> it's one file?
17:47:52 <greenrd> So what confuses me is, should I trust that it has the inferred... expected ... bit the right way round, and the error message is the wrong way round?
17:47:55 <greenrd> Or is it vice-versa?
17:49:01 <dons> Dylan: --make will find any packages you need to link with, rather than having to add them on the command line with -package foo
17:49:03 <Dylan> Lemmih: Okay, why does --make cause it work, if it's only using modules that come with ghc?
17:49:13 <Dylan> Oh, okay.
17:49:14 <dons> for example, if you use the monad transformer package, or the network package
17:49:33 <Dylan> I'm using System.Posix
17:49:41 <dons> right, so you need -package unix, I think
17:49:52 <dcoutts> Dylan, use "ghc-pkg list"  to see what packages you've got
17:50:15 <dons> ?docs System.Posix
17:50:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix.html
17:50:24 <dons> yep, in the unix package
17:50:27 <Dylan> it's somewhat confusing that runhaskell implies --make.
17:50:47 <gbolt> gentlemen egntlemen
17:51:07 <gbolt> how simpel is it to get rida mysql and use haskell alone without java or mysql
17:51:24 <int-e> Hmm, and a -package haskell98 for the Monad module? (Control.Monad is the hierarchical libraries counterpart)
17:51:42 <ndm> eivuokko: no idea
17:52:19 <greenrd> gbolt: I don't think there is any point in using Java with Haskell anyway
17:52:31 <gbolt> no no java mysql is curent setup
17:52:35 <gbolt> Id rather dump both
17:52:40 <greenrd> oh I see
17:52:42 <gbolt> use haskell for database and lang
17:52:46 <gbolt> anyone try this?
17:52:53 <greenrd> There was a talk on that at AngloHaskell
17:52:53 <gbolt> I still need decent speed
17:53:04 <greenrd> about using the Prevayler approach with Haskell
17:53:24 <dons> gbolt: try haskelldb or one of the other haskell db bindings.
17:53:43 <greenrd> @google happs
17:53:45 <lambdabot> http://www.happs.com.au/
17:53:45 <lambdabot> Title: Welcome to Happs &amp; Three Hills
17:53:49 <greenrd> oops
17:53:52 <dons> ?where happs
17:53:52 <lambdabot> http://happs.org
17:54:20 <greenrd> gbolt: Take a look at happs
17:54:30 <dons> gbolt: ah, I recognize your ip address
17:54:32 <dons> ?proton
17:54:32 <lambdabot> can I build something that lets laptop users sync contacts and client dta over the net?
17:54:54 <dons> and am kind of sick of this trolling.
17:54:56 <greenrd> gbolt: Alex Jacobson gave a talk on happs
17:55:12 <dons> greenrd: gbolt is probably just stringing you along.
17:55:19 <dons> see for example previous statements:
17:55:20 <dons> ?proton
17:55:21 <lambdabot> waht is this D&D
17:55:23 <dons> ?proton
17:55:23 <lambdabot> is there an oo db in haskell?
17:55:25 <dons> ?proton
17:55:25 <lambdabot> is there an oo db in haskell?
17:55:27 <dons> ?proton
17:55:27 <lambdabot> ok is haskell a type of lisp?
17:55:29 <mauke> ?proton
17:55:29 <lambdabot> treid comon lisp. ansi common lisp bok by graham. it sucked
17:55:34 <greenrd> Seems like reasonable questions to me
17:55:43 <greenrd> Don't me too quick to assume trolling
17:55:47 <greenrd> oops
17:55:50 <greenrd> *be
17:55:54 <mauke> ?proton
17:55:55 <lambdabot> how does j2ee compare to haskell?
17:56:02 <greenrd> That's a very reasonable question.
17:56:05 <dons> greenrd: perhaps see the entire canon: http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Quote/Text.hs
17:56:16 <dons> at the bottom of that page, pretty much everything he's said in 3 months
17:56:20 <edwardk> greenrd: the its not just a few occurences
17:56:37 <edwardk> and the questions never move up in level =)
17:56:48 <edwardk> or change much =)
17:56:49 <dons> its low level, but once you see it all together, there's a clear pattern of wasting our time
17:57:05 <greenrd> I see
17:58:02 <mauke> "is haskell doomed to be a mysql driver?" wow.
17:58:07 <greenrd> hehe
17:58:10 <edwardk> in general the question is one line designed to provoke an hour long discussion
17:58:19 <dons> yeah, considering he asked today: 10:50  gbolt:: use haskell for database and lang?
17:58:37 <dons> now, you'd think since that was already answere, hmm, 5x over the last 3 months
18:00:23 * edwardk nods that he succeeded anyways. we've spent how long on this topic? =)
18:00:33 <dons> :/
18:00:43 <johnnowak> ?proton
18:00:44 <lambdabot> hu me/
18:01:11 <greenrd> dons: So lambdabot stores a database of quotes... as Haskell source code?
18:01:17 <greenrd> That's one approach to persistence...
18:01:29 <dons> not really, quite like that.
18:01:41 <dons> most quotes are just in a text file, read as a bytestring
18:01:43 <int-e> @quote dons
18:01:43 <lambdabot>   its like you can really see the guy's brain melting
18:01:56 <dons> some i dump into their own command, and yes, put in a src file
18:02:24 <dons> but that's not a persistence thing. the text State/* logs are for persistence
18:02:43 <dons> actually, there's also a bunch of binary files in there too, for things like the @seen state
18:02:46 <gbolt> happs seem strong
18:03:41 <edwardk> the keal quotes make my head hurt.
18:03:58 <dons> heh
18:05:37 <dons> btw, gbolt is also known as shemale_magic, HeyObjects, parnassus, gavino, hypothesys, octon, java-its-pssa, mel-gibson, java-or-no, proton-gun,  deathsstar and protontorpedo
18:05:48 <gbolt> how do I take all this junk in mysql and jaava
18:06:07 <gbolt> and get this incedible chunk of crud traNSFORmed into something that willscale adn run fast in haskell?
18:06:12 <int-e> @protontorpedo
18:06:13 <lambdabot> ok so say I ftp files from some 50 remote servers now, and then read them inot mysql, then ftp back to an ohter 50 servers some info they read into thier informix db
18:06:15 <gbolt> I hate sugarcrm by the way
18:06:27 <dons> gbolt, stop trolling or you will be kicked
18:06:34 <gbolt> ok
18:06:38 <gbolt> sorry god
18:06:48 <edwardk> well, this is what you get in order to maintain "Nice opers here, no one got kicked!" =)
18:07:14 <int-e> . o O ( instead, we just ban people and wait for them to leave )
18:07:41 <edwardk> heh
18:09:24 * dcoutts has to go feed the trolls
18:12:40 <dons> heh, 06.07.23:23:48:54 <parnassus> I am banned from like 6 rooms
18:13:56 <dons> <parnassus> scheme, lisp, php, python, perl, tcl, al banned
18:14:01 <dons> somehow I'm not surprised
18:14:21 <edwardk> heh
18:14:59 <edwardk> as much as we'd hate to follow in the footprints of tcl... =)
18:15:36 <dons> sometimes this person also uses join: gavino99 (n=root@masqrd.la.teampcs.com) joined #haskell
18:15:52 <dons> asking such questions as : 06.06.30:14:14:01 <gavino99> how does haskell compare to say java?
18:15:55 <Korollary> why spend all this energy
18:16:17 <dons> I only realised today that he's been using multiple nicks, and multiple ip addresses, to troll us for months
18:16:50 <Korollary> What is that australian word that means 'bothered' ?
18:17:36 <dons> maybe a bit annoyed, yes
18:18:08 <Korollary> I meant as in I can't be bothered. There was an aussie word for it.
18:18:23 <dons> oh, a good one, 06.06.30:14:15:12 <gavino99> is ghc or hugs98 or nhc98 best haskell jvm?
18:18:33 <dons> "can't be stuffed?" perhaps?
18:18:36 <Korollary> right
18:19:30 <Korollary> Perhaps the questions are sincere. I can't imagine anybody being stuffed to the extent where he changes nicks and ips to ask absurd questions.
18:19:54 <jer> Korollary, i can, and have seen it happen many dozens of times =/
18:19:58 <greenrd> dons: How do people figure out when 2 troll personas are the same person?
18:20:09 <dons> read the logs and check the ip address
18:20:35 <dons> however, its always the same personality. just different names, and 2 ip addresses
18:20:36 <greenrd> Same IP address, different DNS??
18:20:44 <dons> hmm?
18:20:50 <greenrd> oh I see
18:21:07 <greenrd> well, personality is circumstantial evidence
18:21:16 <lisppaste2> kpreid pasted "What's wrong with this seemingly trivial Monad instance?" at http://paste.lisp.org/display/24089
18:21:38 <jer> you can also tell by how they carry themselves, the questions they ask, etc
18:21:40 <dons> I don't understand the question, greenrd. the same nick is appearing on two different ip addresses. and on on of the ip addreses, he uses about 10 different nicks
18:22:04 <dons> jer, right, esp. since in this case, he asks the same questions from his script
18:22:12 <jer> dons, they usually do =]
18:22:23 <kpreid> mind if I ask an on-topic question? :)
18:22:32 <jer> or atl east very similar questions
18:22:41 <jer> we used to (at least when i was still there) have real bad issues with trolls in #freebsd.. you get to picking them out quick
18:22:46 <kpreid> I finally got around to simplifying the problem that's had me stuck for months
18:25:25 <int-e> kpreid: it doesn't like you changing the first argument of ContT
18:25:44 <kpreid> but what is it that changes it?
18:25:53 <int-e> your definition
18:26:26 <kpreid> before I tried to introduce ContT I had been using that definition as a generic wrapper
18:26:30 <LordBrain> dons: with hscurses i find i still need the -package switch even with make
18:26:33 <LordBrain> --make
18:26:51 <int-e> let f be of type Int -> Foo (). then consider (g >>= f) with g of type Foo Int
18:27:03 <LordBrain> makybe its just not installed correctly...
18:27:25 <dons> LordBrain: its not exposed by default?
18:27:28 <int-e> to be a Monad instance, that must be defined, but that means you're combining ContT Int ... with ContT () ...
18:27:50 <kpreid> ah, I see
18:28:04 <kpreid> thanks.
18:28:16 <kpreid> I now need to figure out how to Not Do That Then
18:28:55 <emertens> @hoogle while
18:28:56 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
18:28:56 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
18:28:56 <lambdabot> Data.PackedString.dropWhilePS :: (Char -> Bool) -> PackedString -> PackedString
18:29:37 <kpreid> int-e: wait, but why does Bar not fail?
18:29:43 <kpreid> oh, of course
18:30:01 <kpreid> the other types involved aren't required to be Bars themselves
18:32:11 <int-e> kpreid: trying to give Bar a monad instance would fail (if haskell allowed that for type aliases)
18:32:28 <emertens> @hoogle maximum
18:32:29 <lambdabot> Prelude.maximum :: Ord a => [a] -> a
18:32:29 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
18:32:29 <lambdabot> Data.List.maximumBy :: (a -> a -> Ordering) -> [a] -> a
18:32:51 <Dylan> 'Side effects, too, should be impossible.  God does not change what he says, so why should the Divine Code be any different?   This means, of course, above all else, "functional programming" languages should be used when writing the Will of God.'
18:33:19 <Dylan> http://www.kuro5hin.org/story/2006/8/6/155745/7278
18:33:21 <lambdabot> Title: Faith Based Programming || kuro5hin.org
18:34:59 <emertens> @hoogle findIndex
18:35:00 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
18:35:01 <lambdabot> Data.Map.findIndex :: Ord k => k -> Map k a -> Int
18:35:39 <dons> oh, our troll is also gschuett@masqrd.la.teampcs.com
18:35:49 <dons> so persistent.
18:41:23 <dons> heh, on #tcl, <wtkncceglv> who is is this gschuett troll that frequents here with the bizarre names?
18:42:18 <dcoutts> Dylan, that's a great article :-)
18:42:54 <Dylan> dcoutts: indeed. it seems to be supportive of haskell. ;)
18:43:01 <dons> oh, and on #lisp, 15:54:26 --- mode: Xach set +b *!*=gschuett@208.201.11.*
18:43:01 <dons> 15:54:37 --- kick: star-trekio was kicked by Xach (New nick, same old shit.)
18:43:43 <dcoutts> Dylan, I like the bit at the end about being "willing to accept Jesus as your personal Lord and Debugger."
18:44:06 <dcoutts> d'Lord and d'Bugger
18:49:06 <dons> that's 10 months now :/
18:50:30 --- mode: ChanServ set +o dons
18:50:39 --- mode: dons set +b *!*n=bo@*.lsanca.dsl-w.verizon.net
18:50:39 --- kick: gbolt was kicked by dons (dons)
18:50:44 <madpickle> is there a variation of maximum that doesn't result in C stack overflow with very large lists?
18:50:49 --- mode: ChanServ set -o dons
18:50:59 <emertens> problem 14?
18:51:02 <dons> madpickle: hmm. a foldl' ?
18:51:07 <madpickle> dons: i can try that
18:51:30 <dons> > foldl' (\a b -> if a > b then b else a) [1..10000]
18:51:31 <lambdabot>  Add a type signature
18:51:34 <dons> > foldl' (\a b -> if a > b then b else a) [1..10000] :: Int
18:51:35 <lambdabot>    Expecting a function type, but found `Int'
18:51:35 <lambdabot>    Expected type: Int
18:51:35 <lambdabot>   ...
18:51:41 <dons> > foldl' (\a b -> if a > b then b else a) 0 [1..10000] :: Int
18:51:42 <lambdabot>  0
18:51:46 <int-e> @type max
18:51:47 <lambdabot> forall a. (Ord a) => a -> a -> a
18:51:56 <dons> > foldl' max 0 [1..10000] :: Int
18:51:57 <lambdabot>  10000
18:52:03 <dons> > foldl' max 0 [1..1000000] :: Int
18:52:04 <lambdabot>  1000000
18:52:08 <int-e> @type foldl1' max
18:52:08 <dons> > foldl' max 0 [1..1000000000] :: Int
18:52:10 <lambdabot> forall a. (Ord a) => [a] -> a
18:52:13 <lambdabot> Terminated
18:52:19 <emertens> > foldl max 0 [1..10^7]
18:52:23 <lambdabot> Terminated
18:52:27 <dons> no stack overflow. but i'm surprised that maximum would do that anyway?
18:52:32 <int-e> I think for maximum, foldl1' is good :)
18:52:42 <emertens> > foldl1'  max [1..10^7]
18:52:45 <lambdabot>  10000000
18:53:01 <madpickle> and what is that called in hugs?
18:53:11 <int-e> @index foldl1'
18:53:11 <lambdabot> Data.List
18:53:15 <madpickle> oh
18:53:16 <madpickle> thanks
18:53:27 <dons> oh. hugs. :) you might want to use ghc if performance is becoming any issue?
18:53:59 <lispy> or if you're confused by error messages
18:54:13 <emertens> madpickle: what problem are you playing with?
18:54:25 <madpickle> well, i prefer the Winhugs interface to the console version.
18:54:32 <madpickle> (of GHCi)
18:54:58 <emertens> Stack space overflow: current size 8388608 bytes.
18:54:59 <emertens> Use `+RTS -Ksize' to increase it.
18:55:06 <emertens> what should i do to try to get around this?
18:55:08 <emertens> or
18:55:09 <emertens> @paste
18:55:09 <lambdabot> http://paste.lisp.org/new/haskell
18:55:33 <lisppaste2> emertens pasted "Why is this using so much stack??" at http://paste.lisp.org/display/24090
18:56:58 <emertens> @pl \f a -> (a,f a)
18:56:59 <lambdabot> ap (,)
18:57:40 * lispy is never really comfortable with that monad instance
18:57:44 <emertens> @pl \f a -> (f a, a)
18:57:45 <lambdabot> ((,) =<<)
18:59:03 <dons> emertens: have you profiled?
18:59:09 <emertens> profiled?
18:59:24 <dcoutts> profile! profile! profile!
18:59:37 <dcoutts> profile for fun and profit
18:59:38 <emertens> hooray, it worked
18:59:41 <emertens> but lets profile anyway
18:59:43 <dons> oh, in this case its just a little stub.
18:59:46 <dons> how'd you fix it?
19:00:04 <emertens> instead of ziping
19:00:07 <emertens> zipping*
19:00:17 <emertens> I just stored the value using (,) =<<
19:00:53 <emertens> I needed to find the value x in [1..10^6-1] such that f x was maximized
19:01:18 <lisppaste2> emertens annotated #24090 with "now it works" at http://paste.lisp.org/display/24090#1
19:04:47 <dons> for those interested in that little saga today, here's a final transcript of gschuett's trolling over the last 10 months, under 24 nicks, and 4 ip addresses, http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Quote/Text.hs
19:05:38 * lispy checks it out
19:05:43 <dons> its kind of depressing. we should have noticed sooner.
19:05:55 <dons> just about everyone here wasted time on this guy.
19:05:56 <dons> oh well
19:05:59 * dons gets coffee
19:06:30 <lispy> @protontorpedo
19:06:30 <lambdabot> on the haskell site they compare haskell to a spreadsheet
19:08:13 <dons> ?quit sync
19:10:19 * dcoutts darcs sends dons a pile of patches
19:10:24 <dons> cheers
19:11:14 <kpreid> question: how practical might it be to build an inverse of @pl? and could it be made to behave sensibly?
19:11:35 <dcoutts> kpreid, not too hard to add points back in
19:11:51 <lispy> and it would be cool
19:11:56 <dcoutts> just eta expand and inline (.) etc
19:12:48 <Pseudonym> There are some corner cases.
19:12:52 <Pseudonym> @pl \x -> x x
19:12:52 <lambdabot> join id
19:13:05 <Pseudonym> Now un-pl (join id) (join id)
19:20:28 <Pseudonym> @type join
19:20:30 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
19:20:51 <Pseudonym> @type join id
19:20:52 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a1
19:20:52 <lambdabot>    Expected type: a -> a -> a1
19:23:31 <Lemmih> @users
19:23:31 <lambdabot> Maximum users seen in #haskell: 235, currently: 194
19:27:47 <Jormunder> @t \x -> x x
19:27:48 <lambdabot> Maybe you meant: tell time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . v
19:28:16 <Jormunder> @type \x -> x x
19:28:18 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
19:28:18 <lambdabot>    Expected type: t
19:43:45 <stepcut> hrm, I profiled my program and 42% of the time is spent in foldr2 :p
19:46:04 <Pseudonym> And that, ladies and gentlemen, is why profiling higher-order code is hard.
19:46:15 <Pseudonym> Add some cost centres.
19:46:23 <stepcut> SCC ?
19:46:39 <Pseudonym> Yup.
19:47:22 <Patterner> what is scc?
19:47:22 <stepcut> I think it this case, it really is spending all the time in foldr2
19:47:57 <Cale> foldr2?
19:48:16 <stepcut> its like foldr but takes two lists instead of one
19:48:25 <stepcut> it is not exported
19:48:32 <stepcut> but I copied into my code
19:48:42 <Cale> what does it do with the two lists?
19:49:09 <Pseudonym> Pattener: SCC lets you declare a profiling cost centre.
19:49:48 <Pseudonym> The problem with profiling higher-order code is: Suppose you have a program that takes data, puts it through multiple passes of munging, and then spits out data.
19:49:55 <Pseudonym> What if every pass calls, say, foldr?
19:50:09 <Pseudonym> The call graph looks weird.
19:50:17 <Pseudonym> Every module calls foldr, which then calls every module.
19:50:20 <Pseudonym> It's a bottleneck.
19:50:31 <stepcut> Cale: at the moment, nothing:       'foldr2 convolve' 0 list1 list2 where convolve' ex i acc = acc'
19:50:42 <stepcut> ack, too many ' in there
19:50:48 <Pseudonym> The idea is that you put cost centres at high levels, so the different calls to foldr get separated.
19:50:58 <stepcut> foldr2 convolve 0 list1 list2 where convolve ex i acc = acc
19:51:41 * Patterner reads chapter 5
19:54:23 <stepcut> This particular foldr2 instance needs to be called around 50,000 times per second on an input list of 32 elements
19:55:31 <stepcut> it (currently) seems that the overhead of foldr2 is significantly higher than the operation that the non-gutted convolve is supposed to do :)
19:57:22 <stepcut> But, I think I can rewrite the algorithm to use a simple numeric comparison instead of deconstructing two lists and checking if they are null -- which should help a fair bit.
19:58:40 <stepcut> it has to do that check 1.5million times per second -- so it pays to optimize it a bit, it seems to account for 42% of my execution time :)
20:05:21 <dons> heh
20:07:17 <stepcut> dons: I'm sure you have had similar experiences recently :)
20:08:11 <dons> yeah. we've been doing a bit of this 'small changes == big gains' stuff
20:09:07 <Pseudonym> And decent type systems makes small changes possible.
20:09:22 <dcoutts> dons, where does -funbox-strict-fields help exactly?
20:09:47 <dons> oh, was it in some of the tests we were running? (you referring to the note to add -funbox-strict-fields?)
20:09:49 <dcoutts> -funbox-strict-fields is equivalent to using {-# UNPACK #-} on all strict fields, so which strict fields are we missing?
20:10:13 <dcoutts> we shouldn't need to ask user to use -funbox-strict-fields I think
20:10:50 <dons> we shouldn't need to. I suspect though ghc takes our strictness and propogates it into the user's program, finding new values that as a result can be strict and unpacked
20:11:16 <dcoutts> hmm
20:11:23 <dons> though i've actually removed that comment. the patch was only transient
20:11:26 <dcoutts> that wasn't what I thought -funbox-strict-fields does
20:11:51 <dons> hmm. you think its purely on strict fields of data types?
20:11:57 <dcoutts> I thought it really was equivalent to adding an {-# UNPACK #-} on all strict fields of data constructors
20:12:02 <dcoutts> yes
20:12:03 <LordBrain> is there a way to output the caller.. like put a watch on a function which tells where its being called from?
20:12:07 <dons> why would we see any changes then on programs that use fps?
20:12:11 <dcoutts> check the user guide
20:12:14 <dons> which we do seem to see.
20:12:15 <dcoutts> perhaps :*:
20:12:28 <dcoutts> I have not generally seen any difference
20:12:42 <dons> ah ok. i'm happy to defer to you on this
20:12:43 <dcoutts> what I noticed was that -O2 was slower than -O
20:12:55 <dcoutts> and that -funbox-strict-fields made -O2 faster
20:13:01 <dcoutts> and had no effect with -O
20:13:09 <dons> LordBrain: hmm. the only thing I can think of is to look at the profiling call graph
20:13:30 <LordBrain> hmm
20:13:37 <LordBrain> i want to actually step thru the program
20:13:49 <dons> through what, yi?
20:13:55 <LordBrain> :)
20:13:57 <LordBrain> yeah
20:13:58 <dons> or something simpler?
20:14:01 <LordBrain> well
20:14:11 <LordBrain> it would be cool if i could put a breakpoint in, and step
20:14:16 <dons> the existing stepping-debuggers, freja, hood, hat and so on, won't run yi
20:14:32 <dcoutts> dons, there may well be an effect from :*:
20:14:39 <dons> hmm. i suppose it might just work with Lemmih's breakpoint code
20:14:45 <dons> dcoutts: maybe that's it
20:14:46 <Lemmih> Hood isn't really a stepping debugger.
20:15:02 * dons hasn't looked at hood in 4 years
20:15:16 <LordBrain> i suppose i could output to c and use gdb hahaha
20:15:18 <dons> (last time I had a bug :P)
20:15:20 <dcoutts> dons, as for hGetSomeContentsN, that should be the default behaviour of hGetContentsN
20:15:26 <dcoutts> that's what I always intended
20:15:31 * Lemmih grins.
20:15:35 <dons> dcoutts: ah ok. that's what i suspected.
20:15:35 <dcoutts> so it could be used with sockets etc
20:15:39 <dons> we can make it the default then.
20:15:49 <dcoutts> I didn't realise it wasn't working
20:15:55 <LordBrain> i dont understand the connection between the c that ghc outputs and the haskell i typed in.
20:16:09 <dons> LordBrain: the connection is a relation, known in the literature as "GHC"
20:16:45 <dons> once you understand the semantics of the GHC function, its easy to see the link between Haskell and the C generated ;)
20:16:46 <lucca> having read, Plugin/Quote/Text.hs, I fear for our planet
20:16:48 <LordBrain> maybe ghc should have a switch to output c code that is more annotated and things
20:16:52 <dons> lucca: heh
20:17:04 <dons> LordBrain: hmm. that's not a bad idea. the asm backend does that
20:17:25 <dcoutts> dons, heh it's in our TODO
20:17:31 <dcoutts> * consider if lazy hGetContents should use non-blocking reads.
20:17:31 <dons> dcoutts: oh!
20:17:35 <stepcut> LordBrain: there was a bit of discussion about that on the list a few months ago. JHC aims to output 'readable' C code
20:17:48 <dons> dcoutts: well, if you'd like to make it the default. that's a good idea.
20:17:56 <stepcut> But, JHC might take all week to think about the C code it is going to output ;)
20:18:01 <dons> dcoutts: i want to push an api-stable fps 0.7 into base/ this week
20:18:03 <dcoutts> dons, I'd rather go to bed :-)
20:18:07 <dcoutts> dons, yes
20:18:12 <dons> so we should plan to check everything is sorted.
20:18:16 <dcoutts> dons, there are a few more API things I think
20:18:23 <dcoutts> so map' is gone
20:18:27 <dcoutts> which is good
20:18:28 <dons> right. that's done
20:18:45 <dcoutts> I vote to get rid of hGetLines
20:18:54 <dons> heh. well, I'm not too attached
20:19:08 <dons> esp. in the light of the fusion games we now play
20:19:09 <dcoutts> there's a note about unsafeHead/Tail for Char8
20:19:15 <dcoutts> and scanr,scanr1
20:19:40 <dcoutts> we should add a ByteString.Lazy -> [ByteString] operation
20:19:44 <dons> ah yes
20:19:50 * dons updates the todo list
20:19:51 <dcoutts> and a [ByteString] -> ByteString.Lazy
20:20:07 <dcoutts> toChunks fromChunks ?
20:20:10 <dcoutts> something like that
20:20:21 <dcoutts> one of them has to check the invariant
20:21:18 * dcoutts really really heads to bed
20:21:29 <dons> ok. get some sleep
20:22:23 <dons> Pseudonym: I'll stick the homework page on the new wiki now
20:23:26 <glguy> @hoogle (Num a) => a -> Int
20:23:27 <lambdabot> Data.Map.findIndex :: Ord k => k -> Map k a -> Int
20:23:27 <lambdabot> Prelude.exponent :: RealFloat a => a -> Int
20:23:27 <lambdabot> Prelude.floatDigits :: RealFloat a => a -> Int
20:23:55 <glguy> How do I floor a sqrt into an integral
20:24:33 <glguy> I found truncate and floor
20:24:39 <dons> ?type sqrt
20:24:41 <lambdabot> forall a. (Floating a) => a -> a
20:24:46 <glguy> (I was missing a fromIntegral before ssqrt)
20:24:51 <dons> > floor $ sqrt pi
20:24:53 <lambdabot>  1
20:24:55 <glguy> truncate $ sqrt $ fromIntegral n
20:25:14 <glguy> the numbers are all positive, so floor should behave the same as truncate
20:25:45 <dons> problem solved?
20:26:07 <LordBrain> so you asked a question you already knew the answer to?
20:26:18 <LordBrain> heh
20:26:26 <LordBrain> testing us?
20:26:49 <LordBrain> @brain
20:26:49 <lambdabot> But where are we going to find a duck and a hose at this hour?
20:27:09 <LordBrain> @pinky
20:27:09 <lambdabot> Unknown command, try @list
20:30:16 <glguy> When I ask questions, I'm also still thinking of how to solve them :-p
20:30:27 <LordBrain> :)
20:30:27 <glguy> and since I already understand my question, I have a bit of an advantage
20:32:29 <LordBrain> dons: the reason i was thinking about stepping, is i put the correction in for tabs on teh cursor position code and yet i still get the wmove error...
20:32:50 <dons> ?karma+ int-e -- big lambdabot refactor
20:32:50 <lambdabot> int-e's karma raised to 14.
20:33:10 <dons> LordBrain: hmm. I used to just use 'trace' to check the coordinates of things in yi
20:33:21 <dons> i.e. ./yi 2> logfile
20:33:23 <LordBrain> interestingly, one way to fix this is just to make the cursor invisible as the point is always considered selected
20:33:32 <kpreid> is there another name for this ".:"?
20:33:32 <kpreid> > let (g .: f) x y = g (f x y) in (concat .: map) show [1,2,3]
20:33:34 <lambdabot>  "123"
20:33:50 <LordBrain> so the selected style shows up on the point, and it looks like a cursor
20:33:56 <dons> ?pl \g f x y -> g (f x y)
20:33:57 <lambdabot> (.) . (.)
20:34:01 <dons> kpreid: ^^
20:34:18 <Soliah> dons, what course in CSE use haskell?
20:34:20 <Soliah> *courses
20:34:26 <kpreid> dons: "yeah but"
20:34:30 <dons> Soliah: well, comp1A used to, till what, last year?
20:34:35 <Soliah> yes :<
20:34:37 <dons> but we also use it in principles of programming
20:34:42 <Soliah> i mean out of the pro electives
20:34:42 <kpreid> > let (g .: f) x y = g (f x y) in (length . concat .: map) show [1,2,3]
20:34:43 <lambdabot>    precedence parsing error
20:34:43 <lambdabot>     cannot mix `(.)' [infixr 9] and `(.:)' ...
20:34:45 <dons> and adv. functional programming.
20:34:52 <LordBrain> what does commp1A use now?
20:34:53 <dons> so , comp3161, and comp4132
20:35:04 <dons> hmm. C? not sure.
20:35:11 <Soliah> 1a doesn't exist anymore
20:35:14 <Soliah> its like "Computing 1"
20:35:18 <Soliah> and "computing 2"
20:35:23 <Soliah> they do a mix of perl and C i think
20:35:23 <LordBrain> is it just up to the teacher?
20:35:25 <dons> Soliah: if you want to do Haskell, try to get into comp3161. then I'll be your tutor :)
20:35:30 <Soliah> haha
20:35:35 <dons> we write a haskell interpreter from scratch
20:35:41 <dons> mini-haskell, anyway
20:36:23 <dons> it might be creeping into some of the other courses, possibly in KaiE's concurrency course
20:36:59 <dons> and Jingling is usually happy for haskell to be used in the compiler construction courses he runs
20:37:08 <dons> though you often have to ask specifically
20:37:18 <Soliah> i can't even find those courses in the handbook
20:37:23 <Soliah> :<
20:37:32 <dons> let me see... well, you missed comp3161 for this year, it was last session
20:37:50 <dons> http://www.handbook.unsw.edu.au/undergraduate/courses/2006/COMP3161.html
20:38:29 <dons> quite possibly in http://www.handbook.unsw.edu.au/undergraduate/courses/2006/COMP4151.html
20:39:31 <dons> in http://www.handbook.unsw.edu.au/undergraduate/courses/2006/COMP3131.html Jingling may let you use Haskell
20:39:40 <dons> and in http://www.handbook.unsw.edu.au/undergraduate/courses/2006/COMP3151.html
20:39:57 <Soliah> hm i'll have to do compilers next sem
20:40:21 <dons> well, compilers is this session. so I'd do 3161 next session, and then compilers the session after.
20:40:38 <dons> and do 3151 and 4151 too, possibly
20:40:47 <dons> but 3161 is the main Haskell course
20:40:53 <Soliah> hah i wanna do ecommerce and adv dbs too :<
20:41:01 <Soliah> damn this amount of choice!
20:41:03 <dons> ecommerce? sounds like a phoney subject ;)
20:41:08 <Soliah> hahah
20:41:16 <Soliah> from what my coop friends tell me
20:41:20 <Soliah> dbs are important :<
20:41:29 <dons> depends.
20:41:35 <Soliah> i feel jipped
20:41:41 <Soliah> richard buckland is doing data org this session
20:41:49 <dons> I didn't do the db course. I did all the compilers courses though.
20:41:59 <dons> you've not had Richard?
20:42:02 <Soliah> nope :<
20:42:06 <Soliah> i went to his optional lectures
20:42:08 <dons> oh, that's a pity.
20:42:11 <Soliah> but never had him as a lecturer
20:42:21 <dons> go and sit in on a couple of data org classes then. its pretty inspiring
20:42:36 <dons> i had comp1A in haskell with him :)
20:42:49 <dons> we wrote cgi haskell maze games and bots that fought each other for assignment points
20:43:20 <Soliah> i might lol
20:43:35 <Soliah> still dbs is pretty good atm
20:43:39 <Soliah> jas is a good lecturer
20:43:52 <dons> yep
20:44:27 <Soliah> i'm so doing 3161
20:44:33 <Soliah> need to do at least one more course with haskell
20:44:53 <dons> yeah. its just good to understand programming languages properly, since you're going to be using them for a while...
20:45:09 <dons> its one of the few courses all about writing better code
21:02:47 <svref> If I have predicate p, is (p/=) the "official" way of creating the opposite function?
21:02:48 <lambdabot> svref: You have 1 new message. '/msg lambdabot @messages' to read it.
21:03:41 <dons> not.p ?
21:04:05 <dons> since presumably ( p /= ) wouldn't actually type, if p was a predicate
21:04:06 <svref> dons: thanks, that's much prettier.
21:04:38 <stepcut> svref: is p a function like, p :: a -> Bool, ?
21:04:42 <Cale> You should try to leave spaces around infix operators
21:04:46 <Cale> especially .
21:04:52 <svref> stepcut: True
21:05:01 <dons> except in arguments to filter ;)
21:05:28 <svref> > (True /=) False
21:05:29 <lambdabot>  True
21:05:30 <dons> filter (not.good) seems reasonable to me. Why, Cale, other than to work around broken syntax highlighting?
21:05:59 <kpreid> hm, since lambdabot delivers messages in private, you can't tell whether a message you sent message has been received
21:06:11 <dons> hmm?
21:06:19 <svref> kpreid: I got your message just now :)
21:06:30 <stepcut> kpreid: you want delivery confirmation?
21:06:53 <kpreid> well, most of the IRC message bots I've seen deliver in the channel, so I'm used to it
21:06:54 <Cale> dons: Well, one reason is that the syntax can be somewhat ambiguous for (.)
21:07:22 <dons> considering qualified names?
21:07:24 * stepcut goes to bed
21:07:32 <dons> night stepcut
21:07:34 <Cale> yeah
21:07:43 <stepcut> it's getting pretty late here
21:07:48 <stepcut> @localtime stepcut
21:07:49 <stepcut> ;)
21:07:50 <lambdabot> Local time for stepcut is Sun Aug 13 21:07:29 2006
21:09:46 <svref> By the way, are there infix funky-punctuation operators for bitwise operators, ala C's '|' '&', etc?
21:09:47 <dons> lambdabot's such a monad addict
21:09:48 <dons> newtype ModuleT s m a = ModuleT { moduleT :: ReaderT (MVar s, String) m a }
21:09:49 <dons>     deriving (Functor, Monad, MonadTrans, MonadIO, MonadError IRCError, MonadState t)
21:09:57 <dons> svref: yep
21:10:06 <dons> > 0 .|. 8
21:10:07 <lambdabot>  Add a type signature
21:10:12 <dons> > 0 .|. 8 :: Int
21:10:13 <lambdabot>  8
21:10:25 <dons> ?docs Data.Bits
21:10:26 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
21:11:30 <dons> stepcut: how about that lambdabot/jabber patch, btw?
21:13:42 <stepcut> dons: I will publish it tomorrow -- you probably do not want to apply to the official source because it adds dependencies on loudmouth and glib
21:14:06 <dons> ah ok.
21:14:19 <stepcut> dons: I am pondering writing a real haskell jabber binding using the HaXml 'sax' parser
21:14:26 <dons> yeah
21:14:33 <dons> it would be good to just bundle this in lambdabot
21:14:37 <dons> i.e. lambdabot --online --jabber
21:16:07 <stepcut> The jabber server I need to connect to requires SSL, but hopefully for the native haskell jabber libraryr, I can just use the openssl wrapper around lambdabot to start with
21:24:55 <rob-d> i'm trying to get the RotatingCube.hs example program to compile, but i'm having the same problem that gour was having in this log: http://tunes.org/~nef/logs/haskell/05.11.10
21:25:24 <rob-d> he has the problem one minute, then declares victory a short time later without a description of how he solved it :-(
21:26:07 <dons> what's the error?
21:26:09 <stepcut> rob-d: this is the gkt2hs version ?
21:26:44 <rob-d> should be.  there are two versions of it?
21:27:11 <rob-d> the error is identical to the one from the log:  Could not find module `Graphics.UI.Gtk.OpenGL':
21:27:18 <stepcut> rob-d: i think rotating cube is a classic opengl program -- so there is a probably a Glut version, an SDL version, and a bunch of others
21:27:32 <rob-d> i definitely want the gtk2hs version :-)
21:27:39 <LordBrain> hmmm
21:27:50 <LordBrain> i would try using -package
21:28:26 <Cale> rob-d: --make
21:29:24 <rob-d> am using --make
21:30:11 <LordBrain> try -package... for some reason i have to use -package sometimes and it works even tho --make doesnt.. must be something to do with the configuration
21:30:47 <LordBrain> like -package gtk2hs
21:31:22 <Cale> yeah, I suppose that HGL might not be automatically on
21:31:37 <rob-d> it claims that gtk2hs is an unknown package
21:31:52 <Cale> well, you might not have gtk2hs installed
21:32:32 <LordBrain> i'm off
21:32:34 <Cale> though I think the package might just be called gtk
21:32:41 <Cale> ghc-pkg list
21:32:48 <Cale> should tell you what packages you have
21:33:33 <stepcut> rob-d: it is possible you need a *really* new version of gtk2hs
21:33:38 <rob-d> it's installed.  i've been able to fiddle with tabnotebooks with gtk2hs
21:33:52 <Urden> I know this isn't the place to ask a java question, so does anyone know if there is any appropriate channel on freenode for java questions?
21:34:16 <johnnowak> I donno... #java?
21:34:32 <rob-d> newer than gtk-0.9.10?  and gour was having the same troubles this past november
21:34:57 <rob-d> and then he got it working, using some sort of magic :-)
21:35:18 <stepcut> I have 0.9.10, but I don't see any OpenGL stuff in it, but I saw haddock docs for 0.9.10.2 that do
21:35:22 <Urden> #java dosent exist :(
21:35:37 <johnnowak> try ##java
21:35:54 <stepcut> http://haskell.org/gtk2hs/?s=opengl
21:35:56 <lambdabot> Title: Gtk2Hs
21:36:04 <stepcut> it looks like opengl was started the day before the 0.9.10 release
21:36:18 <stepcut> so, you probably need the devel version
21:36:19 <dons> Cale, hehe http://www.boasas.com/?c=666
21:36:21 <lambdabot> Title: [Boy on a Stick and Slither]
21:36:44 <Cale> hehe, yeah
21:37:31 <Urden> johnnowak: i did...no dice
21:37:32 <Urden> ah well
21:37:45 <johnnowak> Urden: works here... not sure what the problem might be.
21:38:25 <Urden> hmmm
21:40:30 <rob-d> ok, going to try devel version.  thanks for the help
21:41:00 <stepcut> rob-d: darcs get http://cvs.haskell.org/darcs/gtk2hs/
21:41:02 <lambdabot> Title: Index of /darcs/gtk2hs
21:41:21 <stepcut> it includes a new directory, http://cvs.haskell.org/darcs/gtk2hs/gtkglext/
21:41:22 <lambdabot> Title: Index of /darcs/gtk2hs/gtkglext
21:41:25 <stepcut> that is probably not in the code you have
21:42:33 <stepcut> you may also have to use, -package gtkglext
21:42:51 <rob-d> hrm.  the link in the story was 404, but i found http://darcs.haskell.org/gtk2hs/.  is that going to be different from cvs.hask... ?
21:42:52 <lambdabot> Title: Index of /gtk2hs
21:43:32 <stepcut> rob-d: no, they are the same machine
21:44:03 <stepcut> rob-d: if you get the devel version, the Rotating cube is included in demo/opengl
22:00:26 <Taral> @pl \a b -> a >>= (\a' -> b >>= (return . a'))
22:00:27 <lambdabot> (. ((. (return .)) . (>>=))) . (>>=)
22:00:31 <Taral> ew
22:00:54 <Taral> @pl \a b -> a >>= (\a' -> b >>= (\b' -> return (a' b')))
22:00:55 <lambdabot> (. ((. (return .)) . (>>=))) . (>>=)
22:01:03 <Taral> @type ap
22:01:04 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
22:01:08 <Taral> @type \a b -> a >>= (\a' -> b >>= (\b' -> return (a' b')))
22:01:10 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => m (a -> a1) -> m a -> m a1
22:18:36 <glguy> is there a builtin function to search an infinite sorted list?
22:18:46 <glguy> before I write a simple one on my own?
22:22:38 <dons> search for?
22:22:57 <dons> ?hoogle a -> [a] -> a
22:22:58 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
22:22:58 <dons> perhaps?
22:22:58 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
22:22:58 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
22:23:06 <dons> ?hoogle (a -> Bool) -> [a] -> a
22:23:07 <lambdabot> No matches, try a more general search
22:23:17 <dons> ?hoogle find
22:23:18 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
22:23:18 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
22:23:18 <lambdabot> List.findIndices :: (a -> Bool) -> [a] -> [Int]
22:23:21 <glguy> elem' x (y:ys) | x < y = elem' x ys | x == y = True | otherwise = False
22:23:57 <dons> > isJust . find (==7) $ [1..7]
22:23:58 <lambdabot>  True
22:24:03 <dons> > isJust . find (==7) $ [1..3]
22:24:04 <lambdabot>  False
22:24:35 <dons> > isJust . find (==7) . takeWhile (\c -> c < 7) $ [1..3]
22:24:36 <lambdabot>  False
22:24:39 <dons> > isJust . find (==7) . takeWhile (\c -> c < 7) $ [1..]
22:24:40 <lambdabot>  False
22:24:55 <dons> > isJust . find (==7) . takeWhile (\c -> c <= 7) $ [1..]
22:24:56 <lambdabot>  True
22:25:22 <dons> > (\l -> last l == 7) . takeWhile (\c -> c <= 7) $ [1..]
22:25:23 <lambdabot>  True
22:25:33 <lispy> @type isJust
22:25:34 <lambdabot> forall a. Maybe a -> Bool
22:25:36 <dons> ?pl (\l -> last l == 7) . takeWhile (\c -> c <= 7)
22:25:37 <lambdabot> (7 ==) . last . takeWhile (<= 7)
22:26:15 <dons> > findN n xs = (n ==) . last . takeWhile (<= n)a in findN 7 [1..]
22:26:16 <lambdabot>  Parse error
22:26:21 <dons> >  let findN n xs = (n ==) . last . takeWhile (<= n)a in findN 7 [1..]
22:26:22 <lambdabot>  Not in scope: `a'
22:26:26 <dons> >  let findN n xs = (n ==) . last . takeWhile (<= n) in findN 7 [1..]
22:26:27 <lambdabot>  Add a type signature
22:26:31 <dons> boo on that
22:27:04 <glguy> Lisp's format function makes this one easy :) http://mathschallenge.net/index.php?section=project&ref=problems&id=17
22:27:28 <dons> seems pretty easy, if the list is sorted
22:28:26 <dons> > (== 7) . head . dropWhile (< 7) $ [1..]
22:28:27 <lambdabot>  True
22:32:27 <glguy> anyone know how to find the length of a string in lisp?
22:36:49 <Pseudonym> http://www.cs.cmu.edu/Groups/AI/html/cltl/cltl2.html
22:36:49 <lambdabot> Title: Common Lisp the Language, 2nd Edition
22:36:53 <Pseudonym> You might want to bookmark that.
22:37:04 <glguy> I went to the hyperspec and figured it out
22:38:13 <Pseudonym> The trouble is, Common Lisp takes TMTOWTDI to the extreme.
22:38:28 <Pseudonym> Because it's actually the union of about 2.5 Lisp implementations.
22:38:51 <glguy> TMTOWTDI?
22:39:09 <sieni> wikipedia might help with that
22:39:12 <Pseudonym> @foldoc TMTOWTDI
22:39:13 <lambdabot> No match for "TMTOWTDI".
22:39:20 <Pseudonym> There's More Than One Way To Do It
22:39:25 * johnnowak hides behind a Scheme implementation
22:39:34 <Pseudonym> Scheme is much prettier than Common Lisp.
22:40:22 <johnnowak> Scheme is much prettier than most things. :)
22:40:23 <dons> ?proton
22:40:23 <lambdabot>  and is haskell ez to debug?
22:40:33 <johnnowak> heh, dons :)
22:40:36 <dons> doh. i was hoping for a is hakesell a clips question.
22:40:43 <johnnowak> ?proton
22:40:44 <dons> heya johnnowak
22:40:45 <lambdabot> so if I learn haskell i can make cool interactive websites and get rich right?
22:41:20 <johnnowak> hm. none of the good ones coming up.
22:41:36 <dons> ?proton
22:41:36 <sieni> Pseudonym: yes, since scheme adheres to the TIMTOBFTTWTDI principle instead of TIMTOWTDI.
22:41:36 <lambdabot> scheme, lisp, php, python, perl, tcl, al banned
22:41:53 * Pseudonym tries to work that one out
22:41:59 <dons> ?remember sieni scheme adheres to the TIMTOBFTTWTDI principle instead of TIMTOWTDI
22:41:59 <lambdabot> Done.
22:42:09 <satan> how exactly does fmap differ from map? what's this functor business?
22:42:29 <dons> hehe
22:42:32 <dons> ?type fmap
22:42:33 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
22:42:34 <dons> ?type map
22:42:35 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
22:42:38 <satan> i'm new to all this :(
22:42:39 <dons> there you go
22:42:40 <Pseudonym> > fmap (+1) (Just 1)
22:42:41 <lambdabot>  Just 2
22:42:44 <Pseudonym> Does that help?
22:42:45 <dons> fmap is more general
22:43:04 <dons> since it works over any type in Functor. not just ([] a)
22:43:05 <satan> so map is only for lists, while fmap is more general?
22:43:12 <dons> yep, see the type.
22:43:14 <Pseudonym> Right.
22:43:18 <satan> right
22:43:20 <Pseudonym> Every Monad is a Functor.
22:43:23 <dons> (a -> b) -> [a] -> [b]  versus (Functor f) => (a -> b) -> f a -> f b
22:43:24 <Pseudonym> Which is nice.
22:43:29 <satan> right
22:43:44 <dons> map should probably be fmap
22:43:47 <dons> oh well
22:43:52 <Pseudonym> It was once.
22:43:59 <dons> quite so.
22:44:09 <satan> hmmm
22:44:11 <dons> we need a @good-old-days plugin
22:44:27 <Pseudonym> The reason why we have map at all is because first year students get confused with error messages involving typeclasses.
22:44:37 <Pseudonym> That's a bit of an exaggeration, BTW.
22:44:50 <satan> haha
22:44:50 <dons> oh, second year students too??
22:45:06 <Pseudonym> But H98 was designed to be less confusing to teach to undergrads, while still allowing the advanced stuff.
22:45:20 <satan> hmm ok so can i ask for help with a haskell question i found online?
22:45:24 <Pseudonym> map -> fmap isn't such a big price to pay, all things considered.
22:45:31 <satan> relating to functors and fmap, of course
22:45:42 <Pseudonym> By all means.
22:46:18 <Pseudonym> But using the keyboard is the usual means.
22:46:35 <satan> heh ok
22:46:51 <satan> Write an fmap function suitable for making the type "data Tree a = Leaf a Node (Tree a) a (Tree a)" an instance of class Functor
22:47:07 <satan> i guess my problem is, i don't even understand what its asking :S
22:48:25 <Pseudonym> First off, write map for lists./
22:48:49 <Pseudonym> BTW, making binary trees an instance of Functor is almost always the wrong thing to do.
22:49:00 <Pseudonym> Because binary trees almost always have extra constraints.
22:49:03 <satan> ok
22:49:28 <Pseudonym> For example, fmap on binary _search_ trees won't in general maintain the orderedness condition.
22:49:39 <Pseudonym> And fmap on binary heaps won't maintain the ordering condition either.
22:49:45 <satan> ok
22:49:59 <Pseudonym> But as an exercise, it's cool.
22:50:07 <satan> ok, so how do we get started
22:50:15 <Pseudonym> First, write map for lists.
22:50:28 <Pseudonym> Secondly, think about what fmap for this data structure will do, conceptually.
22:51:00 <satan> you mean, the map function? isnt that already defined?
22:51:06 <Pseudonym> Yes.
22:51:12 <Pseudonym> But you should try writing it.
22:51:21 <satan> ok so lemme try here
22:51:28 <Pseudonym> If you understand how that works, understanding how fmap for trees works will be a bit easier.
22:51:36 <satan> map f (x:xs) = f x : (map f xs) ?
22:51:46 <Pseudonym> OK so far.
22:51:52 <satan> alright cool
22:51:58 <Pseudonym> But you're missing a case.
22:52:04 <satan> the base case?
22:52:10 <Pseudonym> Yes.
22:52:18 <satan> map f [] = []
22:52:21 <Pseudonym> data [a] = [] | a:[a]
22:52:24 <Pseudonym> Right.
22:52:37 <satan> ok cool
22:52:55 <satan> so trees have a node and 2 children, so i should apply the fmap to that, somehow
22:53:33 <Pseudonym> That's the idea.
22:53:46 <satan> hmm ok
22:54:03 <glguy> 101 is written, one hundred one, not one hundred and one
22:54:03 <glguy> right?
22:54:50 <satan> fmap f a = f a ++ (fmap f left a) ++ (fmap f right a)
22:54:59 <satan> i'm not sure about the syntax :(
22:55:16 <satan> but i should apply it to the parent, then call fmap on each of the children
22:55:37 <Pseudonym> glguy: It depends where you're from.
22:55:42 <Pseudonym> I say one hundred and one.
22:55:50 <Pseudonym> satan: What's the type of fmap?
22:55:52 <satan> me too :) canada here
22:56:44 <satan> takes a function and applies f to each part of the function?
22:56:53 <Pseudonym> What's the type?
22:56:54 <Pseudonym> @type fmap
22:56:55 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
22:56:59 <glguy> Pseudonym: I just remember having that drilled in in elementary school
22:57:06 <satan> not sure what this is: (a -> b) -> f a -> f b
22:57:13 <Pseudonym> (a -> b) -> Tree a -> Tree b
22:57:19 <glguy> Pseudonym: and Lisp doesn't believe that the and should be there, so it makes it harder to do this problem :)
22:57:20 <Pseudonym> Much like (a -> b) -> [a] -> [b]
22:57:38 <satan> ok
22:58:57 <satan> not getting it, i'm afraid
22:59:26 <Pseudonym> Well, the left hand sides are going to be:
22:59:37 <Pseudonym> fmap f Leaf = ...
22:59:42 <Pseudonym> fmap f (Tree l x r) = ...
22:59:43 <Pseudonym> Right?
22:59:45 <satan> i know it takes a tree and returns a tree, with f applied to it, thats all, right
23:00:00 <Pseudonym> Let's do the base case first.
23:00:03 <satan> ah ok
23:00:04 <Pseudonym> Often easiest to do that first.
23:00:12 <Pseudonym> What will it return?
23:00:21 <satan> the leaf itself
23:00:24 <glguy> Aparently the "Common British" way to say numbers has the "and" while the "Common American" way doesn't
23:00:46 <satan> fmap f Leaf = f leaf
23:01:44 <Pseudonym> satan: Look at the base case of map for lsits.
23:01:46 <Pseudonym> lists
23:01:51 <satan> ok
23:02:29 <satan> which was map f [] = f
23:02:45 <glguy> err
23:02:48 <glguy> map f [] = [] -- ?
23:02:57 <satan> sorry yeah
23:03:04 <satan> map f [] = []
23:03:13 <satan> so for the tree, if the leaf is nil, i guess
23:03:19 <Pseudonym> Right.
23:03:33 <satan> fmap f nil = nil ?
23:03:38 <Pseudonym> Yup.
23:03:43 <satan> ok
23:03:44 <Pseudonym> fmap f Leaf = Leaf -- in your case
23:03:51 <satan> right
23:03:55 <Pseudonym> OK.
23:03:57 <Pseudonym> Now do the other case.
23:03:58 <satan> and then the step case
23:04:53 <satan> i know i should call f on the leaf and fmap on the 2 children, but how do i connect them in the function
23:05:02 <satan> for lists, you just ++ the pieces together
23:05:09 <Pseudonym> Oh, hang on.  What's the type of Tree again?
23:05:21 <satan> data Tree a = Leaf a Node (Tree a) a (Tree a)
23:05:28 <Pseudonym> You left out a pipe somewhere.
23:05:35 <satan> right
23:05:44 <satan> data Tree a = Leaf a | Node (Tree a) a (Tree a)
23:05:51 <Cale> haha: <pengrate> Well shit. Apparently I just drank 59,500 kilograms of dissolved solids in a bottle of water. "Ingredients: Pure Spring Water, Ozone. Total dissolved solids: 119 Mg/L"
23:05:52 <Pseudonym> Ugh.  That's ugly.
23:06:16 <Pseudonym> You can't have an empty Tree, apparently.
23:06:26 <Cale> That's fine
23:06:27 <Pseudonym> So actually, it's:
23:06:32 <Pseudonym> fmap f (Leaf x) = ...
23:06:42 <Cale> It's okay to exclude the empty case if you don't want it :)
23:06:53 <satan> ok so
23:06:55 * Pseudonym doesn't like arbitrary restrictions.
23:07:09 <satan> fmap f (Leaf x) = x ?
23:07:24 <satan> or should it be Leaf x after the =
23:07:32 <Pseudonym> Here's an idea.
23:07:41 <Pseudonym> Why don't you type that up and see what happens.
23:07:49 <Pseudonym> instance Functor Tree where
23:07:56 <Pseudonym>     fmap f (Leaf x) = ...
23:08:03 <Pseudonym> You don't need to put the other case in yet.
23:08:10 <Pseudonym> You only want to type check.
23:08:19 <satan> in a .hs file, or in the interpreter
23:08:28 <Pseudonym> In a .hs file.
23:09:51 <satan> ok it complains
23:10:00 <satan> whether i put Leaf x or x
23:10:15 <satan>    Couldn't match the rigid variable `a' against `Tree b'
23:10:15 <satan>       `a' is bound by the type signature for `fmap'
23:10:50 <Pseudonym> Which version is that for?
23:11:03 <satan> instance Functor Tree where
23:11:04 <satan>  fmap f (Leaf x) = x
23:11:18 <Pseudonym> OK, now look at the type of fmap for Tree.
23:11:35 <Pseudonym> (a -> b) -> Tree a -> Tree b
23:11:50 <Pseudonym> What type does fmap return?
23:11:59 <satan> ah so it should return a Tree too
23:12:07 <Pseudonym> Right.
23:12:21 <satan> so it cant accept a Leaf either then?
23:12:36 <Pseudonym> Sorry?
23:12:47 <satan> sorry, i meant, as an argument
23:13:10 <Pseudonym> Why not?
23:13:17 <satan> fmap f (leaf x) - shouldn't it complain about that too? or is it fine since a Leaf is a Tree
23:13:28 <Pseudonym> Yes, Leaf is a Tree.
23:13:34 <Pseudonym> Well Leaf x is a Tree a where x :: a
23:13:41 <satan> ok
23:14:05 <satan> so then if we return (Leaf x), it should work, right?
23:14:28 <satan> hmm it doesnt
23:14:55 <Pseudonym> What error message do you get now?
23:15:13 <satan> lemme pastebin, 1 sec
23:16:23 <satan> http://paste.uni.cc/9319
23:16:52 <Pseudonym> OK, now what does that mean?
23:17:16 <Pseudonym> Line 6 is pointing you to the "x" argument of "Leaf".
23:17:28 <Pseudonym> And it says Expected type: b, Inferred type: a
23:17:41 <Pseudonym> That means it found something of type a where it expected something of type b.
23:19:06 <satan> right
23:19:30 <Cale> and after all, what is fmap supposed to do?
23:20:08 <satan> take a tree, apply f to it and return the tree
23:20:19 <Cale> apply f to all the elements in it, right?
23:20:27 <satan> right
23:20:45 <Cale> and here, x is an element of the tree, and you didn't apply f
23:20:54 <Cale> and so the compiler called you on it
23:20:58 <satan> ohhh
23:21:40 <satan> so do i just make it f (Leaf x) or f x
23:21:49 <Cale> Leaf (f x)
23:21:56 <satan> right i was gonna say that
23:22:12 <satan> ok it works, nice
23:22:19 <satan> now for the other case
23:22:45 <Cale> This is something cool about having a somewhat expressive static type system -- you can catch bugs like that :)
23:23:23 <satan> fmap f (Tree l x r) = Node fmap f (Tree x) fmap f (Tree r)
23:23:33 <satan> not sure what the Node bit does
23:23:51 <satan> right, so haskell' statically typed
23:23:52 <Cale> you're missing lots of parens, and a detail
23:23:55 <satan> haskell's
23:24:18 <Pseudonym> You should type that and see what happens, BTW.
23:24:21 <satan> the a in the middle?
23:24:22 <satan> ok
23:24:22 <Cale> Is the constructor called Node or Tree
23:24:24 <Cale> ?
23:24:25 <Pseudonym> See what Haskell tells you.
23:24:34 <Cale> It's Node
23:25:30 <satan> heh, parse error on input `where'
23:26:59 <satan> ok i get: Not in scope: data constructor `Tree'
23:27:26 <Cale> right
23:27:28 <satan> which means there is no such ctor
23:27:40 <Cale> Tree is a type constructor
23:27:49 <satan> ok
23:28:27 <Cale> The other data constructor for trees was Node
23:28:35 <satan> right
23:29:46 <satan> hmm its saying Not in scope: data constructor `Tree' for fmap f (Tree l x r) too
23:30:07 <Cale> well, right
23:30:07 <satan> should i replace that with Node
23:30:12 <Cale> yes
23:30:33 <satan> following the format prescribed in the data declaration, i presume
23:31:43 <satan> fmap f (Node (Tree a) a (Tree a)) = Node (Tree (f a)) (f a) (Tree (f a ))
23:31:52 <Cale> no
23:32:00 <satan> ok
23:32:04 <Cale> you had it right apart from Tree/Node
23:32:33 <Cale> The syntax of data declarations is a little confusing for beginners
23:32:40 <satan> you mean, this: fmap f (Tree l x r) = Node fmap f (Tree x) fmap f (Tree r)
23:33:02 <satan> yep, it sure is :)
23:33:16 <Cale> the LHS of that is correct apart from "Tree" which should be "Node"
23:33:22 <Cale> the RHS has more problems :)
23:33:26 <satan> heh ok
23:33:54 <Cale> the first of which is that you're trying to apply the Node constructor to 6 things
23:34:17 <satan> fmap f (Node l x r) = Node (Tree (f l)) (f x) (Tree (f r))
23:34:20 <satan> is that better?
23:34:47 <Cale> You never use Tree at the value level
23:34:48 <satan> so with the brackets now, i'm applying it to 3 things
23:34:57 <Cale> it's only a part of the type-language
23:34:58 <satan> oh ok
23:35:04 <satan> i see
23:35:08 <Cale> what you have is closer now though
23:35:40 <Cale> the key is to recursively apply fmap
23:35:43 <satan> replace the Tree on RHS with....what? Leaf? more Nodes?
23:35:54 <satan> there are 2 nodes and 1 leaf, i guess
23:36:40 <satan> right
23:36:52 <Cale> 2 subtrees and a value
23:37:00 <Cale> and you're applying f to the value
23:37:10 <Cale> and recursively mapping over the 2 subtrees
23:37:32 <satan> fmap f (Node l x r) = Node (fmap Tree (f l)) (f x) (fmap Tree (f r))
23:37:46 <satan> like that, i guess, except to not use Tree on the rhs
23:38:06 <satan> oh wait, no f's on the trees
23:38:07 <Cale> Right, you can't use Tree at all with values
23:38:19 <Cale> you pass f to the fmap
23:38:57 <satan> ok
23:39:16 <satan> maybe: fmap f (Node l x r) = Node (fmap f (l)) (f x) (fmap f ((r)))
23:39:32 <Cale> sure, that's a lot of parens, but it should work :)
23:39:46 <Cale> fmap f (Node l x r) = Node (fmap f l) (f x) (fmap f r)
23:39:47 <satan> wow it does too
23:40:05 <satan> right so it gets that l and r are trees from the data declaration
23:40:16 <Cale> yes
23:40:19 <satan> thats why i don't need to specify Tree again in the RHS
23:40:21 <satan> ahhh ok
23:40:36 <satan> thanks for the help, Pseudonym and Cale , maybe one day i won't suck at this heh
23:40:52 <satan> how come you guys know it so well? use it for work everyday?
23:40:52 <Cale> A possibly better syntax for the data declaration (which is actually supported in newer GHCs) is the following:
23:41:02 <satan> or just been coding it for ages?
23:41:08 <Cale> I have
23:41:16 <Cale> I've been using haskell for about 2 years
23:41:24 <satan> for work?
23:41:31 <Cale> and I had a summer job at one point
23:41:32 <Korollary> Subconscious messaging
23:41:41 <satan> wow no wonder eh
23:41:43 <Korollary> Cale has it on his cereal box
23:41:46 <satan> good stuff
23:41:46 <satan> lol
23:42:06 <kosmikus> Cale: only two years? I thought that you've been around much longer ...
23:42:21 <Pseudonym> Yeah, I thought so too.
23:42:26 <Pseudonym> Maybe it just seems like forever.
23:42:55 <Cale> kosmikus: hmm
23:43:07 <Cale> Could it be closer to 3 now? I'm not sure
23:43:12 <Cale> Not much longer than that
23:43:17 <Cale> data Tree a where
23:43:19 <Cale>     Leaf :: a -> Tree a
23:43:19 <Cale>     Node :: Tree a -> a -> Tree a -> Tree a
23:43:28 <Pseudonym> See, I don't like that.
23:43:31 <Cale> that'd be another way to declare your type satan.
23:43:35 <satan> ok so i guess the lesson here is that fr any custom data type, define a functor that can match all possible cases, then go from there
23:43:36 <Pseudonym> I think the pseudo-BNF is much more elegant.
23:43:53 <satan> cool, i'll jot that down
23:44:04 <Pseudonym> I'd even prefer something like this for GADTs:
23:44:07 <Cale> Yeah, Functor instances are generally pretty good things to have
23:44:32 <satan> cool
23:44:41 <kosmikus> I like the GADT syntax, but I prefer "data Tree :: * -> * where"
23:44:49 <Cale> you can also put a kind-declaration in place of the 'a' there
23:45:01 <satan> so you were saying something about haskell being statically typed, right? so that means it does type checking before runtime, at compile time?
23:45:03 <Cale> data Tree :: * -> * where
23:45:05 <Cale>     Leaf :: a -> Tree a
23:45:05 <Cale>     Node :: Tree a -> a -> Tree a -> Tree a
23:45:05 <Cale> like that
23:45:07 <satan> or am i totally wrong?
23:45:11 <Cale> satan: yeah
23:45:18 <Pseudonym> data StateMonad a
23:45:23 <Pseudonym>    = Return a
23:45:34 <satan> ok cool, and haskell has garbage collection too, right?
23:45:34 <Pseudonym> Hang on.
23:45:36 <Pseudonym> data StateMonad s a
23:45:38 <Pseudonym>    = Return a
23:45:41 <Cale> and its type system is powerful enough to catch a lot of things which would be runtime errors in other languages
23:45:46 <Cale> yep
23:45:47 <Pseudonym>    | Fetch :: StateMonad s s
23:45:56 <Pseudonym>     | Store s :: StateMonad s ()
23:45:58 <Pseudonym> Or something.
23:46:07 <satan> Cale: thats cool, i wish i'd heard of it earlier
23:46:09 <Cale> hmm
23:46:27 <satan> so when does haskell allocate memory to a variable? when its compiling or at runtime or..?
23:46:31 <kosmikus> Pseudonym: you can go for the old-style " | Fetch with a = s " syntax
23:46:33 <Pseudonym>     | Bind (StateMonad s b) (b -> StateMonad s a)
23:46:43 <Pseudonym> Maybe.
23:46:52 <kosmikus> Pseudonym: that's been proposed by Ralf Hinze, I think, and still supported by Omega
23:46:57 <Pseudonym> Yes.
23:46:59 <Cale> satan: Well, it's a little complicated...
23:47:06 <satan> oh?
23:47:17 <Pseudonym> Although I must admit, the version with the kind is more elegant than the version without.
23:47:18 <satan> is there a link i can read maybe? if you're busy
23:47:38 <Cale> satan: Initially, it'll allocate some when the variable comes into scope, but that's just a thunk -- a pointer to code which when run will build the value
23:47:52 <Cale> You could read the STG machine paper
23:47:59 <satan> STG?
23:48:15 <Cale> Spineless Tagless G-machine
23:48:31 <Cale> I believe the G is for graph, but I'm not sure.
23:48:32 <satan> so is that the secret behind how haskell handles infinite lists? it doesnt actually build them until needed, and that too only how much is needed
23:48:41 <satan> ok i'll google it
23:49:03 <Cale> I'll get you a citeseer link, but my connection is slow right now, as I'm uploading
23:49:19 <satan> ok thanks :)
23:50:17 <Cale> http://citeseer.ist.psu.edu/peytonjones92implementing.html
23:50:58 <Cale> If you're unfamiliar with CiteSeer, the download links are all in the top right corner :)
23:51:27 <satan> i am, thanks for the tip :)
23:51:34 <Cale> That's a fairly involved paper though
23:51:56 <Cale> but the initial discussion helps a lot in understanding what's really going on when Haskell code is running
23:54:03 <satan> yeah i can see that heh
23:54:07 <satan> not for neophytes
23:55:07 <satan> ok so there's a lot of talk of curried functions
23:55:16 <Cale> yep
23:55:18 <satan> those are functions that take one argument and return a function, right?
23:55:26 <Cale> right
23:55:34 <satan> ok cool
23:55:40 <Cale> In fact, all functions of multiple parameters in Haskell are curried
23:55:55 <satan> so f a b c actually is left associative, like so: (((f a) b) c)
23:55:56 <Cale> Which is why it's important to implement things so that will be efficient.
23:56:02 <Cale> right
23:56:14 <satan> ok
23:56:25 <satan> how can you do that? always use foldl instead of foldr?
23:56:30 <satan> or am i being naive here?
23:56:37 <Cale> uhh
23:56:44 <Cale> foldl/foldr are a separate issue
23:56:49 <satan> ok
23:57:12 <Cale> Though foldr is more natural in Haskell, since it's capable of working with infinite lists.
23:57:39 <satan> whereas foldl isnt
23:57:47 <Cale> right
23:57:56 <satan> ok
23:58:24 <Cale> In fact, in *most* cases where you want a foldl, you really want to use the strict (non-lazy) version, called foldl'
23:58:31 <Cale> which is in Data.List
23:59:08 <satan> whats the difference between strict and lazy exactly?
23:59:52 <Cale> Well, lazy evaluation is done by always evaluating the outermost function first
23:59:58 <ibid> you're almost comparing apples and oranges
