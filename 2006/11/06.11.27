00:01:21 <int-e> Botty: the initial patch isn't counted, I think.
00:04:05 <Botty> Setup.hs: cannot satisfy dependency fps>=0.7
00:05:08 <int-e> edit cabal file, replace fps>=0.7 by regex-compat
00:07:30 <Botty> apparently I don't have that either
00:09:18 <int-e> oooooooh
00:09:32 <int-e> are you using ghc 6.4.2?
00:09:44 <Botty> 6.4.1
00:09:46 <int-e> then you should get fps and install it first.
00:09:54 <int-e> @where fps
00:09:54 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
00:10:14 <int-e> and undo the .cabal file changes. they're necessary for 6.6
00:10:22 <int-e> I should've asked first :)
00:10:45 <w-ber> Hi, this may be an "RTFM" question (if it is, I'm satisfied with pointers or links to the documentation)... I'd like to create a data structure that has lists of pointers to cells. The lists would work as sort of indices, and two lists may share a cell (in the form of a pointer). Should I use IORef(?), normal lists, or what, when I would want to be able to update the contents of the cells so that the change is visible to every index list (as they only ...
00:10:50 <Botty> alright
00:10:51 <w-ber> ... contain pointers)?
00:13:30 <int-e> w-ber: that's a little too vague. IORefs or STRefs can do this. Mutable arrays and indices might be right, or maybe a completely different data structure.
00:13:33 <Botty> sounds like a very C-like data structure
00:14:15 <int-e> w-ber: it really depends on what you're trying to do, but usually pointers are something to avoid.
00:14:17 <w-ber> Well, I could use Data.Array and create lists of Ix's. :)
00:14:43 <w-ber> The point is, I'll be updating the cells heavily.
00:15:06 <int-e> and you'll share them a lot, too?
00:15:57 <int-e> and all this is performance critical code so you wouldn't want to just put the cells into a Data.Map, indexed by ... uhm .. index?
00:17:04 <w-ber> Well, I want the index lists because the cells have several groupings. I could use an ordinary array and (C-like) calculate the index every time, or I could (C-like) have lists of pointers to the cells, so that I could quickly access any group of cells I want.
00:17:43 <w-ber> Come to think of it, I sound so vague I'm ashamed. :)
00:18:29 <Botty> well, have you tried the performance of the plainly written haskell?
00:18:48 <int-e> hard to say. ST- or IORefs are certainly something to be considered, if this needs to be fast.
00:19:09 <int-e> But Data.Map could be a reasonable compromise, too.
00:19:54 <w-ber> Botty: No, not yet. This is my second day with Haskell, and I'm still reading.
00:19:55 <int-e> And if Haskell doesn't cut it, FFI is also an option. Or writing in assembly language. ;)
00:20:45 <w-ber> No-one will die if it isn't fast, but I would not like it to be slow either.
00:21:11 <Botty> oh, heh, ok
00:21:52 <w-ber> I'm not a stranger with functional programming, but it's hard to unlearn several years of imperativeness. :)
00:24:22 <Botty> yep, I know the feeling. I'm 3 months into functional, after 8 years imperative :)
00:24:38 <lispy> Botty: ah, is it hard to get used to?
00:24:58 <Botty> pretty hard, but once you really get it, going back is harder
00:25:06 <lispy> :)
00:25:27 <dobblego> is there a function that will take a -> b where error might be called and return Maybe b instead?
00:26:01 <lispy> dobblego: not exactly sure what you want...
00:26:04 <araujo> @hoogle (a -> b) -> Maybe b
00:26:04 <lispy> ?type throwError
00:26:05 <lambdabot> No matches, try a more general search
00:26:06 <lambdabot> Not in scope: `throwError'
00:26:24 <dobblego> I want to call Map.(!) and handle the case of error
00:26:26 <lispy> ?hoogle throwError
00:26:27 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
00:26:34 <Botty> lispy - basically he wants it to return maybe instead of erroring out
00:26:38 <araujo> @hoogle catch
00:26:39 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
00:26:39 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
00:26:39 <lambdabot> GHC.ConsoleHandler.Catch :: (ConsoleEvent -> IO ()) -> Handler
00:26:52 <araujo> @hoogle (!)
00:26:54 <lambdabot> Did you mean: (!)
00:26:54 <lambdabot> Prelude.undefined :: a
00:26:54 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
00:26:55 <lispy> throwError works with any instance of MonadError including Maybe and Either
00:27:28 <w-ber> int-e: Data.Array would really be the simplest option, as I could collect a subset of the indices to a list easily, but it feels pointless to create a copy of 256 or 65536 cells every time I update one.
00:28:18 <int-e> w-ber: hmm. STArray or IOArray, maybe? Of course once you do that you're stuck in a pesky monad ;)
00:29:26 <w-ber> int-e: Hmm, those are possibilities.
00:29:29 <dobblego> that's all a bit annoying
00:29:41 <dons> w-ber: how many elements, how often are you indexing?
00:29:50 <dons> ?docs Data.IntMap
00:29:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-IntMap.html
00:29:52 <dobblego> thanks
00:29:55 <dons> ^^ cheap, no copying
00:30:11 <dons> otherwise, you can go nuts with destructive arrays
00:30:24 <dons> but find out how the idiomatic pure solutions works before worrying about the speed
00:30:28 <dons> probably with ghc -O you won't care
00:30:38 <int-e> destructive ... and here I thought they were called 'mutable'.
00:30:43 <w-ber> IntMap looks nice.
00:31:55 <dons> > M.fromList $ zip [1..] "some chars"
00:31:56 <lambdabot>  {1:='s',2:='o',3:='m',4:='e',5:=' ',6:='c',7:='h',8:='a',9:='r',10:='s'}
00:32:02 <Botty> yeah, ghc is good at optimizing things.  usually the best way to go is avoid extravagant optimization, and only do it if the nice implementation is slow
00:32:15 <dons> ?let m = M.fromList $ zip [1..] "some chars"
00:32:17 <lambdabot> Defined.
00:32:23 <w-ber> That's the hardest part to unlearn after you've used C or C++. :)
00:32:43 <dons> > M.lookup 3 L.m
00:32:44 <lambdabot>  add an instance declaration for (Show (m Char))
00:32:48 <Botty> yes, thankfully my stint with those two was relatively short
00:32:50 <dons> > M.lookup 3 L.m :: Maybe Char
00:32:51 <lambdabot>  Just 'm'
00:32:58 <dons> > M.lookup 113 L.m :: Maybe Char
00:32:59 <lambdabot>  Nothing
00:33:18 <dons> > M.insert 0 'X' L.m
00:33:19 <lambdabot>  {0:='X',1:='s',2:='o',3:='m',4:='e',5:=' ',6:='c',7:='h',8:='a',9:='r',10:='s'}
00:33:49 <dons> easy peasy, purely functional data structures
00:33:50 <Botty> note, you won't need the M. and L. prefixes - those are just for the bot
00:34:04 <Botty> or, interactive interpreter rather
00:34:16 <lispy> int-e: i prefer 'destructive' but i come from a lisp background
00:34:29 <dons> yep. though if you import qualified Data.IntMap as M, to avoid name clashes, you'll use the M. prefix
00:34:49 <dons> lispy: me too: and it tells you you're destroying data -- good to remind people of that ;)
00:34:49 <lispy> under the hood it might be mutable even if i can't mutate it...so destructive is nice to say when i can destroy a value by over writing it
00:34:54 <int-e> lispy: destructive sounds more negative. which is a good reason to call them that.
00:34:57 <w-ber> Thanks for the help. I guess I'll try the trivial solution first...
00:35:20 <int-e> lispy: because whatever they are whenever I use them my code tends to become ugly and unmaintainable.
00:35:42 <lispy> int-e: :)
00:35:43 <dons> w-ber: feel free to ask for speed/perf advice here, via :
00:35:44 <dons> ?paste
00:35:44 <lambdabot> http://paste.lisp.org/new/haskell
00:35:51 <dons> good luck with your lambda adventures!
00:36:13 <dons> > fix ((1:) . scanl (+) 1) -- have a fixpoint, w-ber 
00:36:14 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
00:36:48 <lispy> my experience with haskell is that the speed/performance you need is possibel, but leave it to last because it's harder than getting your program to be right in the first place.  And do you really care how long you wait for the _wrong_ answer :)
00:37:00 <w-ber> dons: That made me laugh even though I'm not sure I got the joke.
00:37:21 <dons> :)
00:37:26 <lispy> that's a nice fib
00:37:32 <dons> its a teaser advertisement ;)
00:37:50 <lispy> ?type ((1:) . scanl (+) 1)
00:37:51 <lambdabot> forall b. (Num b) => [b] -> [b]
00:38:10 <lispy> > ((1:) . scanl (+) 1) [1,2,3,4]
00:38:11 <lambdabot>  [1,1,2,4,7,11]
00:38:29 <lispy> > take 20$ ((1:) . scanl (+) 1) [1..]
00:38:31 <lambdabot>  [1,1,2,4,7,11,16,22,29,37,46,56,67,79,92,106,121,137,154,172]
00:38:47 <w-ber> How does lambdabot deal with infinite data?
00:39:00 <dons> lazily :)
00:39:02 <lispy> w-ber: as long as you don't need an infinite amount it's fine
00:39:06 <dons> > [1..]
00:39:07 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
00:39:23 <lispy> w-ber: oh and lambdabot will stop after something like 3 seconds of computation
00:39:29 <lispy> > length [1..]
00:39:33 <w-ber> lispy: I was just about to ask that.
00:39:33 <lambdabot> Terminated
00:39:47 <lispy> w-ber: there is a similar restriction on memory consumed
00:40:07 <dons> and no IO either
00:40:09 <lispy> w-ber: we also have a web version of lambdabot if you prefer
00:40:12 <dons> the type checker rules that out
00:40:12 <lispy> ?where lambdaweb
00:40:13 <lambdabot> http://lambdabot.codersbase.com
00:40:14 <Botty> it also won't execute expressions with type IO - only return the type of the IO
00:40:18 <Botty> yeah...
00:40:21 <dons> > readFile "/etc/passwd"
00:40:23 <lambdabot>  <IO [Char]>
00:40:30 <dons> thank you mr. typesystem
00:40:35 <Botty> :)
00:40:39 <lispy> dons: don't be sexist :)
00:40:58 <lispy> Dr. Typesystem would hide the gender :)
00:40:59 <Botty> yes, the way it punishes me I'd say the typesystem is female
00:41:18 <w-ber> You are funnier than #perl. :)
00:41:43 <lispy> pugs!
00:41:56 <lispy> it's the _first_ perl6 implementation and it's in Haskell
00:42:03 <w-ber> I know.
00:42:17 <dons> thank you Non-gender-specific Overlord Typesystem: Finder and Enforcer of the types!
00:42:19 <lispy> is that how you learned about haskell?
00:42:31 <lispy> dons: heh :)
00:42:54 <w-ber> lispy: No, I first heard about Haskell from a friend-turned-Haskell-zealot.
00:42:56 <Botty> yeah, pugs will probably net quite a few inductees ;)
00:43:07 <w-ber> Perl 6 seems uninteresting after I read about Haskell.
00:43:10 <lispy> w-ber: we're friends? ;)
00:43:40 <dons> hehe
00:43:41 * lispy often tries to sell haskell to any friend that will hold still for the pitch
00:43:42 <w-ber> :)
00:45:12 <w-ber> I think he first mentioned Haskell in 2004, but I didn't actually begin reading tutorials until last Saturday.
00:45:37 <Botty> yeah, I first heard of haskell from none other than smerdy....
00:45:51 <lispy> w-ber: i recommend "Tackling the awkward squad..." if you're from a more imperative background and you find the IO monad to be mysterious
00:45:54 <Botty> needless to say that probably delayed my haskellism a few years
00:45:58 <w-ber> lispy: Already read it.
00:46:10 <lispy> w-ber: awesome, what did you think?
00:46:30 <lispy> w-ber: is it appropriate for beginners to haskell?
00:46:39 <lispy> i keep recommending it so feedback is good :)
00:46:51 <dons> ?where yaht
00:46:52 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
00:46:59 <w-ber> lispy: Although it does a good job in explaining how monads and IO work in Haskell, I don't think it will convince the sceptics.
00:47:05 <dons> also good (lots of other fun stuff on haskell.org of course)
00:47:15 <dons> w-ber: yeah, good point 
00:47:33 <dons> its really a research paper, not a tutorial or advocacy document 
00:47:39 <lispy> w-ber: probably not, but my reason for recommending is because it takes the mystery out of the IO monad which i think is important for haskell newbies
00:47:47 <w-ber> lispy: Hmm, beginners... There were a couple of things that need background in functional programming.
00:48:03 <lispy> w-ber: do you remember which things?
00:48:13 <w-ber> lispy: Not at the moment, but I can look them up.
00:48:36 <lispy> w-ber: if you have criticism that is probably the most handy so that the community can improve
00:49:01 <dons> lispy: let w-ber write some code in peace! ;)
00:49:03 <lispy> oh that's another great point about haskell, the community is very alive and very interested in improving
00:49:08 <lispy> dons: :)
00:49:27 <w-ber> Thanks, dons. :)
00:49:35 <Botty> yeah, I'm going to start writing crits on the docs.  One thing that's bad is that its fairly spread, and usually the first google results are zvon, some kinda offshoot docs by some prof or something
00:50:10 <dons> the docs are here:
00:50:11 <lispy> Botty: have you tried the haskell specific google search?
00:50:12 <w-ber> bbl, going to deflower my Haskell virginity.
00:50:13 <dons> ?docs Data.List
00:50:13 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
00:50:24 <lispy> i forgot the URL but it's not bad usually
00:50:26 <dons> Botty: did you see the link to the new doc submission page I put up?
00:50:27 <Botty> also, http://www.haskell.org/hawiki/Keywords#class
00:50:28 <lambdabot> Title: Keywords - The Haskell Wiki
00:50:39 <dons> ?wiki Improving_library_documentation
00:50:40 <lambdabot> http://www.haskell.org/haskellwiki/Improving_library_documentation
00:50:51 <dons> Botty: if you notice things in the haddock docs that need fixing, log them to the wiki
00:50:54 <dons> and i'll commit as they appear
00:50:58 <Botty> mainly its hoogle's links, those are the ones I use
00:52:04 <Botty> alright, will do.  It's kinda hard too, when you don't even agree with the documentation paradigm ;P
00:52:30 <lispy> dons: my biggest complaint with haddock is that it doesn't provide enough navigation links in the pages it creates...guess i should add that to the wiki page
00:52:45 <dons> or patch haddock. its pretty simple i think
00:53:03 <Botty> yeah, sometimes it creates extraneous links too. like if you say the name of the function in its description, it links to itself
00:53:21 <lispy> dons: interestingly, the wxhaskell docs don't have this problem, but they use an old version of haddock so i have wondered if that's a causal relationship
00:54:14 <dons> yeah, haddock 0.8 is out now, and its certainly better than back in the pre 0.6 days
00:54:33 <Botty> also, what'd be great with the docs, is if you could link into the code, pretty printed
00:54:39 <lispy> but does it add these relative links?  I mostly want a link that takes me to the parent module
00:56:59 <lispy> dons: is 0.8 the new one that uses ghc-api?
00:57:09 <lispy> dons: or is that still to be released?
00:59:19 <dons> not the ghc-api one, no
00:59:49 <lispy> i'm looking forward to that version
01:00:01 <lispy> my understanding is it will work on anything ghc handels
01:00:13 <lispy> so no more #ifdef __HADDOC__
01:00:54 <dons> yep
01:01:56 <dblhelix> say I execute a program with System.Cmd.system, how can I then capture the output that's written to stdout and/or stderr??
01:02:09 <lispy> dblhelix: use popen from lambdabot 
01:02:11 <lispy> ?where lambdabot 
01:02:12 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
01:02:36 <Korollary> MissingH also has popen iirc
01:02:45 <lispy> Korollary: ah nice
01:03:09 <dblhelix> lispy: which src-file? how is it implemented? (tnx, btw)
01:03:10 <lispy> popen should definitely find its way into a more standard haskell library
01:03:19 * dblhelix agrees
01:03:21 <lispy> dblhelix: dons would know those details betteer than me :)
01:03:25 <Korollary> ?index popen
01:03:26 <lambdabot> bzzt
01:03:27 <lispy> dblhelix: but i can look
01:03:47 <Korollary> actually runProcess gives you handles, too.
01:04:02 <Korollary> ?type System.Process.runProcess
01:04:03 <lambdabot> FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> Maybe GHC.IOBase.Handle -> Maybe GHC.IOBase.Handle -> Maybe GHC.IOBase.Handle -> IO System.Process.Internals.ProcessHandle
01:04:05 <lispy> iirc, runProcess is the primitive that lambdabot's popen uses
01:04:47 <lispy> dblhelix: http://www.cse.unsw.edu.au/~dons/lambdabot/Lib/Process.hs
01:04:48 <lambdabot> http://tinyurl.com/sta5w
01:04:55 <lispy> dblhelix: it's near the top of the file
01:05:13 <dblhelix> lispy: tnx!
01:05:14 <lispy> actually it's the only function
01:05:25 <lispy> dblhelix: you're welcome!
01:07:37 <lispy> dblhelix: but really you should think shapr and dons for writing lambdabot  ;)
01:07:44 <lispy> s/think/thank/
01:08:05 <lispy> ?version
01:08:06 <lambdabot> lambdabot 4p282, GHC 6.5 (OpenBSD i386)
01:08:06 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
01:08:24 <lispy> dons: i've been meaning to ask, how do you generate that version number? which script file?
01:08:37 <dons> yeah, we probably should get popen into System.Process 
01:09:07 <dons> PATCH_COUNT=`darcs changes --xml-output 2> /dev/null | sed -n '/TAG/q;/^<\/patch/p' | wc -l | sed 's/ *//g'`
01:09:17 <lispy> aye!
01:09:25 <lispy> where is that?
01:09:32 <lispy> i need to upgrade my lambdabot  again
01:09:39 <lispy> <SiR> lambdabot 4p242, GHC 6.4.2 (Linux x86_64 3.20GHz)
01:09:58 <lispy> 40 patches is a lot!
01:26:30 <Syzygy-> @tell aFlag matrixExcursion changed name after the panitz tutorial was written. It's now called preservingMatrix
01:26:30 <lambdabot> Consider it noted.
01:27:18 <lispy> hmm....what library is that?
01:27:34 <lispy> matrixExcursion makes it sound like an elisper wrote it
01:28:01 <lispy> but wouldn't "withMatrix" be a more haskell-esqe name?
01:28:21 <int-e> naa, you can use the matrix outside of that, too
01:28:32 <int-e> it'll just also affect everyone else after you
01:28:56 <Syzygy-> The point is that within a preservingMatrix, you can juggle matrix operations as you like it, and when you're done, everything you did will be ignored for the thing afterwards.
01:28:58 <int-e> so preservingMatrix is really what it does.
01:29:20 <lispy> alright
01:29:32 <Syzygy-> It corresponds a bit, in think, to something like pushCurrentMatrix >> doMyStuff >> popCurrentMatrix (in very ugly pseudocodish)
01:29:48 <lispy> Syzygy-: is this opengl?
01:30:37 <int-e> HOpenGL I thought
01:30:39 <int-e> so yes
01:31:19 <Syzygy-> HOpenGL, yes.
01:31:33 <Syzygy-> I got a question in the middle of the night from dons and aFlag about matrixExcursion.
01:31:33 <lispy> scala has this problem, a great toturial was written  and later the language was tweaked but the two were not synrchorized
01:31:57 <lispy> it's very frustrating for the beginner
01:32:00 <Syzygy-> I started writing my tutorial sequence (need to continue sometime) while reading panitz' tutorial, and discovering that it was out of synch.
01:32:34 <lispy> Syzygy-: nice, may i have a link?  also have you seen my ne-he conversion?
01:33:07 <lispy> ?where nehe-tuts
01:33:07 <lambdabot> darcs get http://projects.codersbase.com/repos/nehe-tuts/
01:35:04 <Syzygy-> lispy: I have seen your conversions. I will start helpuing you write on them at some point in the future (also, one of them crashes my X when I resize it....)
01:35:19 <Syzygy-> And mine are buried in blog.mikael.johanssons.org
01:35:29 <Syzygy-> Hmmm... I should get an opengl-tag for my blog.
01:38:01 <dons> Syzygy-: I put up your math blogs here: http://haskell.org/haskellwiki/Haskell_and_mathematics perhaps you know some other math/haskell references/material?
01:38:03 <lambdabot> Title: Haskell and mathematics - HaskellWiki, http://tinyurl.com/yerb92
01:38:32 <therp> I think that's a good question to ask here, I need a preferable short and convincing list of arguments why Haskell (that's strong typing, pureness, functional programming and lazyness) is a language you want to look at as a programmer
01:38:57 <therp> can anyone provide me with a answer that's != simply because it's so beautiful :) (which would be my answer)
01:39:37 <dons> perhaps, http://haskell.org/haskellwiki/Why_Haskell_Matters and http://haskell.org/haskellwiki/Introduction
01:39:39 <therp> I'm planning to give a talk about an impertive impure used-to-side-effects audience
01:39:39 <lambdabot> Title: Why Haskell matters - HaskellWiki, http://tinyurl.com/t3ccg
01:39:45 <therp> that's why I'm asking
01:39:55 <dons> and finally: http://www.cs.chalmers.se/~rjmh/Papers/whyfp.html
01:39:58 <lambdabot> Title: Why Functional Programming Matters, http://tinyurl.com/writ
01:40:21 <therp> s/about/to/
01:40:29 <therp> dons: oh that looks great thank you
01:40:33 <dons> summary: controlling ide effects leads to better code, since its easier to understand, test, plug together, ...
01:40:39 <lispy> Syzygy-: interesting, i have tested them on OSX only
01:40:47 <dons> s/side/  (freudian slip ;)
01:40:58 <lispy> Syzygy-: maybe i should setup a bug database
01:41:40 <lispy> Syzygy-: do you remember if it was toward the beginning or end of the tutorials?
01:41:45 <dons> lispy++ http://codersbase.com/index.php/Nehe-tuts
01:41:57 <dons> lispy, is it reddit worthy ?
01:42:18 <dons> 'evening greentea 
01:42:43 <greentea> Hey dons.
01:43:41 <lispy> dons: sure
01:43:50 <lispy> dons: i just sent the announce to haskell-cafe :)
01:43:52 <Syzygy-> lispy: Toward the end... Textures had come into play.
01:44:01 <lispy> Syzygy-: hmm...okay
01:44:10 <lispy> Syzygy-:  i should test on my ibook to see if i can find it
01:44:18 <lispy> Syzygy-: thanks
01:44:49 <Syzygy-> lispy: Basically, what I did was start the program, and resize it very early. Result, X stops responding, and I need to log on to the computer remotely to kill it and get back to using the computer.
01:45:20 <Syzygy-> dons: Do you have the stuff that Henning Thielemann does there?
01:45:48 <lispy> Syzygy-: gotcha, it may be an x only bug so i'm curious to play around
01:45:54 <dons> Syzygy-: nope?
01:46:58 <Syzygy-> Ok. Thielemann is active on Haskell-cafe, and custodian of a bunch of stuff, including, I think, Haskore. He also develops a Prelude-replacement to do computational algebra in Haskell, with "True reals" and a mathematical construction of the core types and other niftiness.
01:47:10 <dons> yes. ah didn't know about his math work
01:47:25 <dons> so are those libraries linked to from the math libs page?
01:47:26 <Syzygy-> That's how I first met him. :P
01:47:31 <Syzygy-> I dunno...
01:47:33 <dons> cool
01:48:17 <Syzygy-> Yeah, seems they are... The Numeric Prelude seems to be it.
01:49:48 <lispy> dons: did you announce to reddit or were you hinting for me to do it?
01:51:04 <dons> lispy: i'll do it if you like
01:51:51 <lispy> dons: sure, after 2/3 a bottle of wine it's easy to make a typo :)
01:52:08 <dons> lispy: hehe
01:52:08 <lispy> dons: so if you don't mind i'll owe you a favor later :)
01:52:15 <dons> sure
01:52:28 <lispy> maybe i'll end up porting hs-plugins to ghc6.6 ;)
01:53:13 <dons> heh
01:53:58 <Syzygy-> Oooooh, yes pleasE?
01:54:59 <int-e> lispy++ (thinks about porting hs-plugins to ghc 6.6) ;-)
01:55:43 <dons> sigh, so much to do, so little time.
01:56:50 <lispy> dons: now that i know you're writing your thesis i'm more inclinded to help with hs-plugins :)
01:57:05 <dons> lispy: any chance for screenshots/html text for the tuts? 
01:57:23 <lispy> that's some good feedback you got there :)
01:57:32 <dons> a bit of fancy packaging and the tuts could be quite popular..
01:57:49 <lispy> okay, i'll add this to my google calendar
01:57:53 <dons> (i'll hold off posting to reddit, maybe we can make it a bit more web friendly)
01:58:00 <lispy> i really shouldn't work on it tell the 7th
01:58:06 <lispy> good idea
02:01:42 <lispy> dons: do you use google calendar?
02:01:53 <dons> nope, should I?
02:01:56 <dons> useful?
02:02:03 <lispy> well it's like ical, have you used that?
02:02:20 <dons> nope :) i have devtodo though 
02:02:25 <lispy> and it's only useful if you agree with the time management skills i stress in my learn math blog entry
02:02:30 <lispy> ah devtodo
02:02:37 <lispy> i used that for a year or two
02:02:47 <lispy> it has an elegant simplicity
02:02:56 <dons> stacks are nice
02:03:19 <Syzygy-> What kind of stacks are we talking right now? Algebraic? Data structures? 
02:03:24 <lispy> ical is nice if you agree that scheduling some time on your calendar for your todo items is the best way to get them done
02:03:35 <dons> ?where+ devtodo http://swapoff.org/wiki/DevTodo
02:03:35 <lambdabot> Done.
02:03:52 <lispy> i haven't used devtodo since 2002 or 2001
02:03:58 <lispy> it would be interesting to see it now :)
02:04:19 <dons> much the same I suspect :)
02:04:35 <lispy> dons: but really the reason i ask is because i would share my calendar entries for haskell stuff with you if you used it
02:05:00 <lispy> i remember putting all my homework tasks into devtodo
02:05:23 <lispy> the screenshot is very familiar
02:05:29 <dons> lispy: url? i'll have a look 
02:07:46 <lispy> does this work? http://www.google.com/calendar/event?action=TEMPLATE&amp;tmeid=MzhoczEwdnF1aGZ2czdyN25nc2owc2UxMnMgdW9zN2FlNnRpY2lydTJtZWdhOTIwbWllYmtAZw&amp;tmsrc=dW9zN2FlNnRpY2lydTJtZWdhOTIwbWllYmtAZ3JvdXAuY2FsZW5kYXIuZ29vZ2xlLmNvbQ
02:07:48 <lambdabot> http://tinyurl.com/vzwe9
02:08:13 <lispy> tinyurl++
02:09:39 <dons> seems so, lispy 
02:09:53 <markha> dons: you nehe-tutorials build fine on windows.  
02:10:06 <dons> lispy's tuts.
02:10:16 <markha> oops, sorry lispy
02:10:19 <lispy> markha: that's really good to know since i've never tested that
02:10:21 <dons> markha: thanks for doing that. give lispy any feedback 
02:10:33 <dons> markha++
02:10:39 <lispy> markha++
02:10:48 <markha> the first 3 tuts run fine too. thanks alot lispy.  a little graphics-wizbang can't hurt Haskell:)
02:10:58 <lispy> markha: definitely
02:11:20 <lispy> markha: so darcs on win32 is also working for you?
02:11:34 <lispy> markha: because darcs needs win32 testers and people to give feedback also
02:11:37 <markha> yep, it was darcs get and then "make" and that was it
02:11:57 <lispy> markha: do you use cygwin, or mingw or both?
02:12:01 <markha> mingw
02:13:04 <lispy> markha: thanks
02:13:11 <markha> np
02:13:19 <int-e> > '''
02:13:19 <lambdabot>  lexical error in string/character literal
02:13:29 <lispy> > '\''
02:13:30 <lambdabot>  '\''
02:14:01 <int-e> I know :)
02:14:15 <markha> lispy: and I was just thinking about nehe-tutorials in Haskell the other day, and there you go with your tutorials:).  And it's so nice that everything just works "out of the box"
02:14:50 <lispy> markha: you're welcome :)
02:15:04 <lispy> markha: but it only goes up to 12 or so, so we need more :)
02:15:26 <markha> I'm a Haskell newb, but this is something I'm interested in
02:20:14 <markha> given haskell's reputation, as something that you need a PhD in Math in,  I'm looking at Utils.hs in the nehe-tutorial and finding the source remarkably clean, aesthetic, and easy to understand.  I'm finding that I really like piecewise function decompositation along with pattern-matching.  it seems easier to reason about 
02:21:12 <lispy> yes, it is!
02:21:22 <lispy> equational reasoning in haskell is pretty easy
02:21:33 <lispy> referential transparency is quite a nice thing!
02:25:35 <dons> markha: the math PhDs are rater rare. I'm not sure we have any in here...
02:26:13 <dons> s/rather/
02:27:15 <w-ber> List comprehensions rule.
02:27:39 <markha> all the tutorials run fine for me 1-12
02:27:56 <lispy> otoh, a BS in math helps a fair bit (I say that as someone who has one and picked up haskell relatively easily)
02:28:07 <lispy> markha: ah, excelent
02:28:12 <gds> We benefit from a few (phds - maths or otherwise) helping build our tools though. It's good to have really smart tools :)
02:28:24 <markha> gds: yeah
02:28:42 <lispy> yes, haskell currently benefits from having very little mediocrity in the communicty
02:28:46 <lispy> er community
02:29:47 <metaperl> the very nature of the haskell language prevents mediocrity :)
02:31:06 <markha> I'm mediocre, so that's why I probably need Haskell.  I don't think my brain can handle some gobbly-gook of class-based OO hierarchies
02:31:09 <markha> :)
02:32:58 <lispy> one of my professors said publicly (recently), "I'm not smart enough to program in perl."  I feel that way abotu most OO and imperative langugase
02:32:59 <w-ber> Haskell is a nice excuse to not think in OO.
02:33:34 <markha> http://lambda-the-ultimate.org/classic/message4857.html#4886.  I was reading Oleg's paper on subtyping/sublassing today
02:33:36 <lambdabot> Title: LtU Classic Archives, http://tinyurl.com/sdfc4
02:34:03 <vincenz> OO languages is for those that are good at history, you need to remember a lot of minute details.  FP is good for those that have less of this paraphernalia memory and are more able to reason on algorithms.
02:35:40 <lispy> Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it. 
02:35:40 <lispy> Brian W. Kernighan 
02:35:48 <markha> So the smart people are smart enough to know that they're dumb enough to need Haskell:)
02:35:56 <lispy> i absolutely love that quate :)
02:36:06 <lispy> markha: exactly
02:36:34 <lispy> and the K of K&R C seems to agree :)
02:38:28 <markha> Or I'll let Haskell be clever for me. heh
02:40:18 <w-ber> Talking about math, does Haskell have a formally defined semantics? The Haskell 98 Report is informal and somewhat operational in describing the semantics, and I was able to find only a couple of related academic papers from early 1990s.
02:40:41 <lispy> one of my favorite things about debugging haskell is that you can do it with pen and paper and use alegbraic substitutions...it's more like doing math than debugging
02:40:55 <lispy> w-ber: no, it does not
02:41:04 <lispy> w-ber: the history of haskell paper talks about this
02:41:12 <w-ber> Right, will read.
02:41:27 <lispy> w-ber: ML, otoh, does have a formally defined semantics using denomational semantics
02:42:27 <lispy> w-ber: iirc, in the history of haskell paper the authors talk about it being a bit surprising that not having formally defined haskell's semantics has actually helped the language to flourish and evolve because researchers didn't have to re-prove that it was sound in every paper they publish
02:42:29 <vincenz> lispy: denotational or operational?
02:43:04 <lispy> vincenz: i thougbt ML had denotational semantics, but i've never checked for myself so i could be wrong
02:44:15 <psykotic> ml's is operational, at least standard ml
02:44:22 <psykotic> i don't think ocaml has much of anything :)
02:44:36 <w-ber> lispy: Could be, but isn't everything now on a shaky ground (if we want everything to be formally proven, that is)?
02:44:43 <lispy> ocaml has a traslation to sML right? ;)
02:45:05 <vincenz> I would think it to be operational
02:45:09 <vincenz> cause ith as references and such
02:45:13 <lispy> w-ber: maybe, i don't know much about semantics to be honest
02:45:15 <vincenz> they tend to be kinda nasty at denotational level
02:45:43 <vincenz> lispy: sure there's an overlap between the core of sml and ocaml
02:45:50 <vincenz> lispy: except that ocaml adds classes n top
02:45:52 <vincenz> s/n/on
02:45:56 <vincenz> hence the 'o'
02:45:56 <vincenz> :)
02:45:57 <lispy> w-ber: i haven't completed my masters studies yet and i work industry, who needs semantics ;)
02:46:03 <w-ber> lispy: Haha.
02:46:29 <psykotic> references aren't a problem in DS
02:46:33 <psykotic> look at scheme's DS for instance
02:46:39 <vincenz> hmm
02:47:09 <psykotic> a scheme denotation is something of type Environment -> Store -> Continuation -> Answer
02:47:22 <psykotic> the store is a map from Locations to Values. the Environment is a map from Names to Locations. etc.
02:47:35 <vincenz> yep yep, but this isn't specified in the language def
02:47:50 <psykotic> it is in r5rs
02:47:55 <vincenz> o.O
02:48:23 <vincenz> ah whoops, yep
02:48:41 <w-ber> A newbie question: I have a list of strings, and I want to add a new string (say "---") between every ith and (i+1)th string. What's the FP way?
02:49:09 <vincenz> lunchtime
02:49:11 <lispy> ith and (i+1)th?
02:49:26 <w-ber> Uh, right.
02:49:28 <lispy> w-ber: can you give an example where the list has length 5 or so?
02:49:58 <lispy> but i would bet intersperse or the new intecalate would be helpful
02:49:59 <w-ber> ["a", "b", "c", "d", "e"] should become ["a", "b", "---", "c", "d", "---", "e"]
02:50:09 <w-ber> Every 3rd in that example.
02:51:18 <w-ber> Hm, or "take two, add junk, take two, ..."
02:52:07 <dons> > splitAt 3 "haskell"
02:52:08 <lambdabot>  ("has","kell")
02:52:19 <dons> > let (x,y) = splitAt 3 "haskell" in x ++ "---" ++ y
02:52:20 <lambdabot>  "has---kell"
02:52:52 <boulez> what's your blog, lispy?
02:53:27 <dons> > let (x,y) = splitAt 3 (map show [1..10]) in x ++ ["---"] ++ y
02:53:29 <lambdabot>  ["1","2","3","---","4","5","6","7","8","9","10"]
02:54:34 <araujo> morning
02:54:43 <lispy> boulez: http://blog.codersbase.com/ you can also find it on planethaskell.org
02:54:45 <lambdabot> Title: dagit.o
02:54:53 <boulez> thanks
02:54:56 <lispy> or is it planet.haskell.org
02:55:08 <lispy> boulez: yw
02:55:23 <psykotic> @hoogle Int -> [a] -> -> [[a]]
02:55:24 <lambdabot> No matches, try a more general search
02:55:30 <psykotic> @hoogle Int -> [a] -> [[a]]
02:55:31 <lambdabot> No matches, try a more general search
02:55:45 <lispy> it's always nice when strangers are interested in your website :)
02:55:52 <psykotic> dons: there's no splitEvery? :)
02:56:27 <dons> > map return "haskell" :: [String] -- perhaps?
02:56:27 <psykotic> if you had a splitEvery with the kind of signature i wrote then you could easily do what w-ber wants by a regular intersperse + a concat
02:56:28 <lambdabot>  ["h","a","s","k","e","l","l"]
02:56:32 <lispy> i wonder if you could write splitEvery in terms of unfoldr
02:57:04 <dons> yeah, a splitN is pretty easy, and very useful
02:58:03 <psykotic> intersperseEvery n x xs = concat $ intersperse [x] $ splitEvery n xs
02:58:29 <lispy> can we have an intercalateEvery too? ;)
02:58:32 <psykotic> hehe
02:59:10 <dons> ?let split n = map (take n) . takeWhile (not . null) . iterate (drop n)
02:59:11 <lambdabot> Defined.
02:59:26 <dons> > L.split 3 "haskell is fun some times"
02:59:28 <lambdabot>  ["has","kel","l i","s f","un ","som","e t","ime","s"]
02:59:55 <lispy> nice
03:00:03 <psykotic> > let intersperseEvery n x xs = concat $ intersperse [x] $ L.split n xs in intersperseEvery 3 "-" "haskell is fun some times"
03:00:04 <lambdabot>  Couldn't match `[Char]' against `Char'
03:00:18 * greentea begins to wonder if people title their tutorials with "A gentle introduction to . . ." in jest.
03:00:25 <psykotic> doh
03:00:41 <lispy> greentea: in the case of "gentle incroduction to haskell" i think so :)
03:01:00 <lispy> greentea: actually, to be fair, it's gentle if you're coming from ML or lisp
03:01:00 <dons> greentea: :) historically the 'gentle intro' was gentle compared to the only other tutorial at the time: the haskell language report...
03:01:01 <psykotic> > let intersperseEvery n x xs = concat $ intersperse x $ L.split n xs in intersperseEvery 3 "---" "haskell is fun some times"
03:01:03 <lambdabot>  "has---kel---l i---s f---un ---som---e t---ime---s"
03:01:19 <dons> but given time, it proved to be less than gentle.
03:01:20 <greentea> lispy: Not only that one, but "A gentle introduction to the Haskell XML Toolbox".
03:01:23 <dons> psykotic++
03:01:29 <greentea> dons: Ah, i see.
03:01:44 <greentea> i found YAHT to be much more my speed.
03:01:49 <markha> so who's going to do Practical Haskell?
03:01:52 <lispy> greentea: and green tea would be quite a gentel introduction to tea :)
03:02:05 <dons> ?pl intersperseEvery n x xs = concat $ intersperse x $ L.split n xs
03:02:06 <lambdabot> intersperseEvery = ((join .) .) . flip ((.) . intersperse) . ((L .) .) . split
03:02:09 <lispy> markha: dons claimed that one earlier today :)
03:02:13 <greentea> But yes, i'm finding this HXT intro to be not so gentle.
03:02:15 <dons> ?pl intersperseEvery n x xs = concat $ intersperse x $ split n xs
03:02:17 <lambdabot> intersperseEvery = ((join .) .) . flip ((.) . intersperse) . split
03:02:18 <greentea> lispy: :-)
03:02:23 <dons> not too bad
03:02:57 <lispy> anything that begins with: ((join .) .) -- earns a hesitation from me :)
03:03:04 <dons> heh
03:03:08 <lispy> it's already using the reader monad!
03:03:09 <dons> and rightly so
03:03:21 <psykotic> the reader monad is your friend. trust the reader monad. be happy!
03:03:39 <dons> ?remember psykotic the reader monad is your friend. trust the reader monad. be happy!
03:03:46 <lispy> awesome
03:03:50 <dons> but do not try to understand the  reader monad: that way lies madness
03:04:03 <dons> (i kid ;)
03:04:06 * lispy imagines a smeagol quote about Reader understanding
03:04:15 <psykotic> the reader monad is an avatar of the flying spaghetti monster and not for us to comprehend
03:04:16 <psnl> dons: so its like ghc?
03:04:22 <dons> instance MonadReader r ((->) r) where
03:04:22 <dons>     ask       = id
03:04:23 <dons>     local f m = m . f
03:04:28 <w-ber> psykotic++
03:04:40 <dons> psnl: heh
03:04:52 <w-ber> psykotic: I was already hacking away with my own intersperseEvery, but your version seems more useful.
03:05:30 <dons> w-ber: so you just have to post a question here, that could be soluble in a 1 or 2 liner, and let the channel take care of the rest ... ;)
03:05:36 <lispy> haskell is the only language i know where someone has made an effort to make the "base" libraries portable between implemenations instead of just trying to define them in terms of the spec
03:05:51 <psykotic> #haskell is a distributed microrefactoring system :)
03:05:55 <w-ber> dons: I prefer solving problems on my own, though. :)
03:06:00 <dons> that's good :)
03:06:04 <lispy> #haskell is amazing at turning a 10 liner into a 20 char solution
03:06:14 <dons> distribute your cognition, as lispy says
03:06:27 <dons> we should write up the spec for the peer-to-peer refactoring protocol
03:06:32 <lispy> http://files.codersbase.com/me-southpark.png
03:06:39 <lispy> dons: neat idea
03:07:09 <lispy> fwiw, i got the "distrubute your congnition" from another intern while at IBM research :)
03:07:13 <dons> lispy: hehe :)
03:08:06 <lispy> dons: also, fwiw, that south park image has gotten me the closest to a real date that internet personals have come for me :)
03:08:25 <dons> lispy, heh!
03:08:46 <psykotic> lispy, weak :)
03:09:17 <lispy> i need to have it posted with the rest of the #haskell-blah portraits
03:09:20 <psykotic> isn't there a craigslist category for people who appreciate the finer points of point-free style?
03:09:58 <dons> hehe
03:10:05 <lispy> heh
03:10:15 <psnl> psykotic: I'm imagining it to be called "pointless people"
03:10:20 <lispy> it was on CL that i found my latest attempt at an internet gf :)
03:10:30 <lispy> psnl: perfect
03:11:16 <psnl> lispy: not my joke http://www.willamette.edu/~fruehr/haskell/evolution.html
03:11:19 <lambdabot> Title: The Evolution of a Haskell Programmer, http://tinyurl.com/3swhu
03:11:26 <lispy> dons: we should try to get an RFC number, after all, the carrier pigeon over TCP people got one
03:11:26 <araujo> hola CoreIIian 
03:11:42 <dons> oh hehe. yeah.
03:11:50 <ms_> ok, optimisations. If a type has a # after it then it's a raw type right?
03:12:09 <ms_> and how do I tell if workers have been used? (-ddump-simpl)
03:12:20 * lispy delegates to dons
03:12:21 <dons> ms_: unboxed (so 'raw' yeah)
03:12:24 <dons> not stored on the heap
03:12:40 <ms_> cool
03:12:42 <dons> workers, -ddump-simpl, yeah. the function will be called $foo_worker or some such
03:12:49 <ms_> ahh, ta.
03:12:53 <dons> the more # the better (usually)
03:12:57 <ms_> heh
03:12:58 <dons> (in the -ddump-simpl output)
03:13:13 <int-e> psykotic: the true realisation is that (.) = ap (const ap) const  so you can write point-free code without dots ;)
03:13:14 <lispy> ?google UM haskell dons
03:13:16 <lambdabot> http://www.cse.unsw.edu.au/~dons/um.html
03:13:16 <lambdabot> Title: Haskell UM
03:13:26 <dons> :}
03:13:31 <lispy> ms_: check that url for haskell programs that exploint this
03:13:35 <lispy> exploit*
03:13:52 <dons> ok, but that's more an exercise in writing Core manually ;)
03:14:15 <dons> very interesting benchmark. the new SSA backedn should help
03:14:21 <lispy> s/exploit/exploit this manually/ ;)
03:14:28 <lispy> SSA?
03:14:48 <dons> new optimisation layer between C-- and the native code gen, in ghc
03:14:50 <psnl> one day I'll find out the point to point-free
03:14:51 <int-e> static single assignment
03:15:00 <psnl> dons: same idea as the gcc one?
03:15:18 <dons> going via SSA form (so lots of imperative , traditional optimisations for free)
03:15:27 <dons> psnl: I suppose so, yes. 
03:15:28 <lispy> psnl: well, by not explitly stating the parameters it's a hair easier to combine with other functions
03:15:45 <ms_> dons, is it faster to use tuples or separate elems in an ADT?
03:15:51 <lispy> psnl: plus, you don't waste symbol names by naminng something which you only use once
03:15:56 <psykotic> dons: unfortunately higher order functions throw a wrench in a lot of traditional imperative optimizations facilitated by SSA.
03:16:04 <psnl> lispy: ah, right
03:16:05 <psykotic> that was largely the reason that shivers invented k-CFA.
03:16:16 <dons> ms_: seperate, strict elems usually data T = T !Int !Bool ...
03:16:22 <ms_> dons, thanks
03:16:25 <psykotic> (i'm thinking of the equivalent of loop-invariant hoisting for instance)
03:16:25 <dons> (unless you're looking for *more* laziness)
03:16:28 <psnl> lispy: I imagined it as a really cool bit of theory
03:16:42 <dons> psnl: that's why we do the SSA after code generation to C-- :)
03:16:45 <lispy> psnl: maybe it is, i just made up those reasons :)
03:17:01 <dons> basically we want to improve the stuff we feed to the final native gen pass, and then improve the register allocator
03:17:11 <dons> can't rely on gcc to get us past C-speed these days
03:17:36 <ms_> and are there any general rules of thumb as to what not to use {-# UNPACK #-} on?
03:17:53 <dons> you hardly ever need explicit unpacks
03:17:57 <lisppaste2> w-ber pasted "intersperseEvery, newbie style" at http://paste.lisp.org/display/30784
03:17:59 <dons> use ! fields, with -funbox-strict-fields
03:18:01 <dons> ?wiki Performance
03:18:02 <lambdabot> http://www.haskell.org/haskellwiki/Performance
03:18:16 <ms_> ahh, tnx
03:18:19 * araujo saluda a CoreIIia1 CoreIIian corellian 
03:18:23 <dons> (my opinion: as soon as you use an explicit strict field, ghc should turn on -funbox-strict-fields)
03:18:23 <lispy> ?where haskellsearch
03:18:24 <lambdabot> I know nothing about haskellsearch.
03:18:40 <lispy> dons: do we still care about the haskell specific search engine? if so, what is the ?where key?
03:18:42 <psnl> lispy: hoogle?
03:18:56 <int-e> w-ber: use splitAt?
03:20:17 <lispy> ?where+ haskellsearch http://www.google.com/coop/cse?cx=015832023690232952875%3Acunmubfghzq
03:20:18 <lambdabot> Done.
03:20:44 <dons> ah, you beat me to it
03:20:52 <lispy> gmail++
03:21:07 <w-ber> int-e: Where and how?
03:21:43 <lispy> dons: but i swear it's buggy, they still don't list me as a contributor
03:22:10 <lispy> dons: and yet i can kinda contribute (I can add sites) but at the same time, I can't fully contribute
03:23:21 <lispy> although it is nice to see that performance lists that wiki page first: http://www.google.com/custom?cx=015832023690232952875%3Acunmubfghzq&q=performance&cof=LH%3A57%3BCX%3AHaskell%2520Search%2520Engine%3BFORID%3A0%3BS%3Ahttp%3A%2F%2Fhaskell%2Eorg%3BL%3Ahttp%3A%2F%2Fhaskell%2Eorg%2Fhaskellwiki_logo_small%2Epng%3BLP%3A1&client=google-coop-np
03:23:23 <lambdabot> Title: performance - Google Search, http://tinyurl.com/y7nmf4
03:23:43 <lispy> which is something i don't think happens in a normal google search
03:23:49 <lispy> i rarely see the new wikipages
03:24:38 <int-e> w-ber: intersperseEvery n a l = let (ini, l') = splitAt n l in if null l' then ini else ini ++ a : intersperseEvery n a l'
03:25:49 <lispy> dons: either way, i'm way past my bedtime :)
03:25:52 * lispy *
03:25:57 * lispy &
03:26:51 <w-ber> int-e: Right, that makes sense.
03:27:38 <ms_> in -ddump-simpl output, does (# some...types... #) mean the tuple is unboxed? (looking at return tuple types)
03:27:50 <dons> yep, unboxed tuples
03:29:29 <Lemmih> dons: Do you know why 'base_GHCziBase_unpackCStringzh_closure' would be an unknown symbol when loading a file containing Strings with hs-plugins on ghc-6.6?
03:31:41 <Lemmih> Weird, it works in ghci.
03:31:52 <dons> Lemmih: ghc 6.6 and hs-plugins don't yet mix
03:32:09 <dons> (hs-plugins can't parse 6.6 .hi files yet, no add version numbers to symbol names)
03:32:15 <ms_> is using -funbox-strict-fields going to confuse the profiler?
03:32:26 <dons> ms_: don't think so (?)
03:32:55 <dons> morning swiert 
03:33:13 <Lemmih> dons: It does. I fixed it.
03:33:20 <dons> ah :)
03:33:27 <ms_> Lemmih: in current ghc6.6 release?
03:33:37 <swiert> hiya dons.
03:33:39 <dons> does it look up symbol names with the version number (I think that's required now?)
03:33:42 <ms_> Lemmih: oh, ignore that, sorry
03:34:00 <dons> (ah , maybe not)
03:34:14 <dons> so its looking for: base_DataziByteString_useAsCStringLen_closure
03:34:27 <dons> Lemmih: did you fix the package.conf handling (now there's base-2.0 and so on ?)
03:34:34 <dons> and ditch the AltData.Typeable stuff?
03:35:08 <dons> (there the 3 things that needed doing afaik)  
03:35:57 <Lemmih> ?paste
03:35:58 <lambdabot> http://paste.lisp.org/new/haskell
03:37:33 <lisppaste2> Lemmih pasted "hs-plugins with ghc-6.6" at http://paste.lisp.org/display/30785
03:40:39 <ms_> mmm, if I have -funbox-strict-fields but then switch from the data to a newtype, the strictness annotations aren't valid
03:40:48 <ms_> does that mean they will never be unboxed?
03:41:20 <dons> Lemmih, compile with DEBUG=1, and see what packages its trying to load
03:41:43 <dons> ms_: right, use a data unless you have an existing string type to unbox
03:42:16 <int-e> > take 2 $ (read "[1,2,3," :: [Int]) -- *sniff*
03:42:18 <lambdabot>  Exception: Prelude.read: no parse
03:42:26 <dons> heh
03:42:39 <Syzygy-> > take 2 $ (read "[1,2,3]" :: [Int])
03:42:41 <lambdabot>  [1,2]
03:42:47 <Syzygy-> Ah, so it should work. :P
03:42:55 <Syzygy-> > take 2 $ (read "[1..]" :: [Int])
03:42:56 <lambdabot>  Exception: Prelude.read: no parse
03:42:56 <dons> > take 2 $ (read "[1..]" :: [Int]) -- should work too ;)
03:42:58 <lambdabot>  Exception: Prelude.read: no parse
03:43:04 <dons> jinx!
03:43:04 <int-e> > take 2 $ (read ("[1,2,3," ++ cycle "42,") :: [Int])
03:43:08 <lambdabot> Terminated
03:43:36 <ms_> dons: ok, that sorta contradicts http://haskell.org/haskellwiki/Performance/Data_Types
03:43:38 <lambdabot> Title: Performance/Data types - HaskellWiki, http://tinyurl.com/yj9gl6
03:43:53 <ms_> no, it doesn't, not if I remember to read
03:44:40 <dons> a module of  strict variants of tuples, eithers and maybes would be useful
03:44:45 <dons> we use them in the ndp/bytestring stuff a lot
03:44:57 <dons> things like data MaybeS a = NothingS | JustS !a
03:52:41 <w-ber> > [1,3..(3^2)]
03:52:43 <lambdabot>  [1,3,5,7,9]
03:53:32 <opqdonut> > [1,3,9..(3^4)]
03:53:33 <lambdabot>  Parse error
03:53:38 <opqdonut> a shame :(
03:54:13 <opqdonut> zipwith (^) (repeat 3) [1,2..]
03:54:18 <opqdonut> > zipwith (^) (repeat 3) [1,2..]
03:54:19 <lambdabot>  Not in scope: `zipwith'
03:54:26 <opqdonut> > zipWith (^) (repeat 3) [1,2..]
03:54:28 <lambdabot>  [3,9,27,81,243,729,2187,6561,19683,59049,177147,531441,1594323,4782969,14348...
03:54:32 <opqdonut> \o/
03:55:55 <dons> opqdonut reaches haskell hacker level 3
03:56:10 <dons> (maybe igher ;)
03:56:30 <astrolabe> [1,2,..] = [1..]
03:56:37 <astrolabe> does that make me level 4?
03:56:53 <opqdonut> > [1..]
03:56:54 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
03:56:55 <dons> only if you can provide a proof ..
03:56:58 <opqdonut> nice
03:57:11 <Syzygy-> > take 5 [3,3..]
03:57:13 <lambdabot>  [3,3,3,3,3]
03:57:14 * dons passes astrolabe @check ...and whispers "exhaustion"
03:57:15 * astrolabe retires in a dignified manner
03:57:31 <opqdonut> ?check [1,2..] == [1..]
03:57:37 <astrolabe> Thanks dons that's really helful
03:57:37 <lambdabot> Terminated
03:59:07 <dons> hehe
03:59:16 <dons> ok, "induction" then :)
04:00:11 <dons> [1..] ==> [1,2..] { reduce } ==> [1,2..] == [1,2..] :)
04:02:00 <dons> ?check [1,2] == [1..2]
04:02:01 <lambdabot>  OK, passed 500 tests.
04:02:17 <int-e> ?scheck [1,2] == [1..2]
04:02:19 <lambdabot>   Completed 1 test(s) without failure.
04:02:29 <w-ber> > [0,3..(3^2)]
04:02:31 <lambdabot>  [0,3,6,9]
04:02:58 <dons> ?scheck \n -> [1,2..n] == [1..n]
04:02:59 <lambdabot>  Add a type signature
04:03:05 <dmn> hi
04:03:11 <dons> ?scheck \n -> [1,2..n] == [1..n] :: Int -> Bool
04:03:13 <lambdabot>    Expecting a function type, but found `Bool'
04:03:15 <lambdabot>    Expected type: Int -> ...
04:03:24 <dons> ?scheck ( \n -> [1,2..n] == [1..n]) :: Int -> Bool
04:03:25 <lambdabot>   Completed 13 test(s) without failure.
04:03:43 <dmn> is it possible to define a function, so that it could be used like a `foo` b without the `` ?
04:03:45 <w-ber> > tail [0,3..(3^2)]
04:03:46 <lambdabot>  [3,6,9]
04:03:57 <dons> dmn, yes, if you use symbols
04:04:13 <int-e> > fix ((>>= \x -> [x, 2*x]) . map (^2) . (1:) . tail)
04:04:15 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
04:04:24 <dons> > let a .+. b = a ++ " -- " ++ b in "one" .+. "two"
04:04:26 <lambdabot>  "one -- two"
04:04:45 <dmn> ahm
04:05:21 <dmn> and one more thing
04:05:24 <dons> dmn, make sense?
04:05:32 <dmn> sure
04:06:05 <dmn> how can i evaluate haskell code given in a string ? 
04:06:05 <dons> yep, your other question?
04:06:13 <dons> bit harder :)
04:06:25 <dmn> yeah, i thought it would be ;]
04:06:26 <dons> two ways: using hs-plugins System.Eval.Haskell module
04:06:30 <dons> (as lambdabot does)
04:06:35 <dmn> mhm
04:06:38 <opqdonut> > fix ((>>= \x -> [x, 2*x]))
04:06:38 <dons> or perhaps call ghci with the string
04:06:39 <lambdabot>  Exception: <<loop>>
04:06:47 <dons> and display the result as a string 
04:07:01 <dons> (or lambdabot's runplugs program, which is like a safe version of ghci)
04:07:22 <dmn> i'd go with the library functions - definitely more elegant
04:07:35 <dmn> i'll check the docs 
04:07:37 <opqdonut> > fix ((>>= \x -> [x, x^2])) 
04:07:38 <lambdabot>  Exception: <<loop>>
04:07:39 <dons> ok, you'll need hs-plugins then, and ghc 6.4.2
04:07:41 <dons> ?where hs-plugins
04:07:41 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
04:07:48 <dons> $ echo "map (^2) [1..10]" | ghci
04:07:49 <dons> [1,4,9,16,25,36,49,64,81,100]
04:07:54 <opqdonut> > iterate (^2) 1
04:07:56 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:08:00 <dons> the popen/System.Process onto ghci solution is nice and cheap though
04:08:01 <opqdonut> > iterate (2) 1
04:08:02 <lambdabot>  add an instance declaration for (Num (a -> a))
04:08:04 <opqdonut> > iterate (*2) 1
04:08:05 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
04:08:08 <opqdonut> there
04:08:18 <w-ber> > iterate (^2) (-1)
04:08:19 <lambdabot>  [-1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
04:08:28 <opqdonut> w-ber: :)
04:08:41 <opqdonut> > iterate (sqrt) (-1)
04:08:43 <lambdabot>  [-1.0,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,NaN,Na...
04:08:52 <opqdonut> > iterate (sqrt) (-1 :+ 0)
04:08:53 <lambdabot>    precedence parsing error
04:08:53 <lambdabot>     cannot mix prefix `-' [infixl 6] and `(...
04:08:59 <mux> > iterate (sqrt) ((-1) :+ 0)
04:08:59 <opqdonut> > iterate (sqrt) ((-1) :+ 0)
04:09:00 <lambdabot>  [(-1.0) :+ 0.0,0.0 :+ 1.0,0.7071067811865476 :+ 0.7071067811865475,0.9238795...
04:09:01 <lambdabot>  [(-1.0) :+ 0.0,0.0 :+ 1.0,0.7071067811865476 :+ 0.7071067811865475,0.9238795...
04:09:03 <mux> heh
04:09:05 <opqdonut> mux: :)
04:09:07 <w-ber> Haha.
04:09:41 <mux> > L.zeta (2 :+ 0)
04:09:42 <lambdabot>  Not in scope: `L.zeta'
04:09:46 <mux> hmpf
04:09:48 <opqdonut> :)
04:09:49 <mux> let's redefine it
04:10:15 <mux> ?let zeta s =  = [ (n :+ 0) ** (-s) | n <- [1..] ]
04:10:16 <lambdabot>  Parse error
04:10:19 <mux> oops
04:10:27 <mux> ?let zeta s = [ (n :+ 0) ** (-s) | n <- [1..] ]
04:10:29 <lambdabot> Defined.
04:10:36 <opqdonut> haha
04:10:36 <mux> > L.zeta (2 :+ 0)
04:10:38 <lambdabot>  [1.0 :+ -0.0,0.25 :+ -0.0,0.11111111111111109 :+ -0.0,6.25e-2 :+ -0.0,4.0000...
04:10:54 <mux> > sum $ take 1000 $ L.zeta (2 :+ 0)
04:10:56 <lambdabot>  1.6439345666815615 :+ 0.0
04:11:03 <mux> > sum $ take 10000 $ L.zeta (2 :+ 0)
04:11:05 <lambdabot>  1.6448340718480652 :+ 0.0
04:11:27 <opqdonut> > fix L.zeta
04:11:28 <lambdabot>  Couldn't match `Complex a' against `[Complex a]'
04:11:41 <w-ber> > [ (-1)^n | n <- [1..] ]
04:11:42 <opqdonut> > fix (head 10 . L.zeta)
04:11:42 <lambdabot>  [-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,...
04:11:43 <lambdabot>  add an instance declaration for (Num [[Complex a] -> Complex a])
04:11:48 <opqdonut> > fix (take 10 . L.zeta)
04:11:49 <lambdabot>  Couldn't match `Complex a' against `[Complex a]'
04:11:58 <opqdonut> > fix (head . L.zeta)
04:12:00 <lambdabot>  Exception: <<loop>>
04:12:11 <w-ber> > [1,-1]
04:12:12 <lambdabot>  [1,-1]
04:12:18 <w-ber> > [1,-5]
04:12:20 <lambdabot>  [1,-5]
04:12:22 <dons> its been a busy blogging day for haskell. this thread turned out well, i think, http://programming.reddit.com/info/sijx/comments
04:12:24 <lambdabot> Title: Why Haskell? (reddit.com), http://tinyurl.com/ynauv9
04:12:27 <w-ber> Ahem.
04:12:30 <w-ber> > [1..-1]
04:12:31 <lambdabot>  Not in scope: `..-'
04:12:35 <w-ber> > [1..(-1)]
04:12:37 <lambdabot>  []
04:12:44 <w-ber> Okay, so that doesn't work.
04:12:49 <dons> but there's been a lot of random haskell articles appearing today on programming.reddit.com/ fun.
04:12:53 * mux is looking for a quick and interesting thing to play with in haskell, to pass the day
04:13:10 <mux> there's nothing more boring than the last days of work when you're changing job
04:13:25 <opqdonut> > iterate negate 1
04:13:26 <w-ber> You can try solving the halting problem.
04:13:26 <lambdabot>  [1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,1,-1,...
04:13:27 <dons> mux, play with the new smp multicore support in ghc 6.6?
04:13:44 <dons> i.e. `par` things that run implicitly on all your cpus?
04:13:54 * dons finds that kind of thing fun . maybe i'm weird
04:13:57 <mux> dons: I suppose that would be interesting - but I'd have to update the FreeBSD port of GHC to 6.6 first
04:14:10 <dons> ok. that's one thing you could do :)
04:14:12 <mux> and I'll have to test this on my only SMP box, a bi p3 500 :-P
04:14:20 <dons> hehe
04:14:25 <mux> not particularly fast :-)
04:14:27 * w-ber is running on dual P3 933 MHz
04:14:33 <opqdonut> mux: my only smp box is a dual pI 133MHz
04:14:37 <opqdonut> :)
04:14:40 <w-ber> Classic.
04:14:42 <mux> opqdonut: haha! I beat you ;-)
04:14:46 <dons> so you're all writing multicore/smp haskell programs then?
04:15:02 <dons> forkIO and par yourself silly
04:15:09 <opqdonut> forkIO is nice
04:15:10 * mux ponders what program to write that would take advantage of SMP capabilities
04:15:14 <mux> forkIO rocks
04:15:25 <dons> mux, well I wrote the parallel QC driver this week. that was pretty easy
04:15:33 <dons> so some batch processing task that currently walks a list?
04:15:34 <mux> how did you slice the work?
04:15:39 <mux> oh
04:15:41 <mux> I'm stupid
04:15:42 <w-ber> dons: I have done no concurrency in my programs because threading in C feels dirty. Maybe Haskell is different. :)
04:15:45 <mux> quite easy to slice QC :-)
04:15:54 <pejo> mux, hack away on GHC, that is a good program to write! 
04:15:55 <dons> I fork N threads, and have them pop jobs off the property list as they are ready
04:16:03 <dons> the jobs list is just a shared MVar
04:16:03 <opqdonut> nice
04:16:08 <mux> pejo: I believe it's too hard for me
04:16:10 <dons> about 4 loc
04:16:12 <opqdonut> MVars are poweful
04:16:14 <mux> dons: what about STM?
04:16:24 <mux> isn't that suppose to supercede MVars and stuff?
04:16:35 <opqdonut> there was this good artivle about writing a web server in haskell
04:16:38 <dons> didn't bother with STM. might have been fun to do that though
04:16:39 <opqdonut> can't remember the url tho
04:16:48 <dons> mux, you could modify the pqc to use STM ...
04:16:54 <mux> pqc?
04:16:59 <opqdonut> parallel qc?
04:17:00 <pejo> opqd, Simon Marlow probably has it on his homepage, it's from JFP iirc.
04:17:01 <dons> i.e. this code: http://www.cse.unsw.edu.au/~dons/code/pqc/Test/QuickCheck/Parallel.hs
04:17:03 <lambdabot> http://tinyurl.com/y7cyqp
04:17:04 <mux> ooh.
04:17:06 <dons> ?where pqc
04:17:06 <lambdabot> http://www.cse.unsw.edu.au/~dons/pqc.html
04:17:15 <mux> I could also rewrite my zeta program to take advantage of SMP
04:17:25 <dons> yeah!
04:17:32 <mux> splitting the list into chunks and summing those on each CPU
04:17:45 * mux hearts dons
04:17:46 <psnl> channels are the way to write threaded code in haskell
04:17:56 <dons> mux, yep that sounds cool.
04:18:00 <dons> psnl: yeah, Chans rock
04:18:13 <dons> (see above Chans for messages, MVar for worklists)
04:18:25 <dons> do we have STM chans?
04:18:27 <mux> I'll base this on pqc then
04:18:54 <dons> mux, once it works, be sure to blog or cabalise it :) it'd make both a fun library, and a fun blog/tutorial
04:19:15 <psnl> dons: I kind of end up with a thread passing jobs though a channel to the workers. 
04:19:33 <mux> dons: sure
04:19:35 * psnl has a little web crawler that does that
04:19:44 <mux> I just hope I'll find someone else than me to update the FreeBSD port to 6.6 :-P
04:19:48 <dons> psnl: yeah, that's equiv to an MVar [a], maybe I should just use two chans, instead of an MVar [Job] and a Chan
04:20:00 <dons> psnl: in haskell?
04:20:04 <dons> you should post it somewhere...
04:20:07 <psnl> dons: aye
04:20:33 <psnl> dons: it needs some TLC, but when I get around to it I'll blog about it
04:21:11 <opqdonut> http://research.microsoft.com/Users/simonpj/papers/marktoberdorf/mark.pdf
04:21:13 <lambdabot> http://tinyurl.com/yc5nfg
04:21:22 <opqdonut> that was the article
04:23:16 <mux> dons: hmm, it looks like we're missing the bootstrap files for FreeBSD/6.6
04:23:35 <dons> you have ghc 6.4.2 on your box?
04:23:39 <mux> yeah
04:23:44 <dons> just build from src for now, then worry about the port later?
04:23:46 <mux> I should be able to build it by hand so
04:23:49 <mux> yep
04:23:50 <dons> yep
04:23:51 <mux> I'll do this
04:24:56 <psnl> dons: at some point I'll even end up on planet haskell ;-)
04:27:36 <mux> dons: does the build framework of GHC allows me ot generate the bootstrap files myself?
04:31:51 <araujo> hola ventonegro 
04:32:04 <ventonegro> araujo, ol :-)
04:33:34 <dons> mux yep, read the porting guide
04:36:33 <ms_> in the profiler output, is there any documentation as to what the columns actually mean?
04:36:49 <ms_> like is "entries" really the number of times that function gets invoked?
04:37:30 <ms_> and if so, are the common reasons as to why some functions would mysteriously be called twice as much as I'd expect given the calls to the containing function?
04:38:16 <dons> hmm. can't think of anything obvious
04:38:28 <mux> dons: ok t hanks
04:38:53 <dons> if the profiling doesn't make sense, ask on haskell-cafe@haskell.org including the profiler out put, and a team of busy monkeys will (in distributed fashion) analyse it
04:39:53 <nornagon> 0,0SINEP
04:39:54 <nornagon> 0,1SINEP
04:39:54 <nornagon> 0,2SINEP
04:39:54 <nornagon> 0,3SINEP
04:39:54 <nornagon> 0,4SINEP
04:39:56 <nornagon> 0,5SINEP
04:39:58 <nornagon> 0,6SINEP
04:40:00 <nornagon> 0,7SINEP
04:40:03 <nornagon> 0,8SINEP
04:40:06 <nornagon> 0,9SINEP
04:40:08 <nornagon> 0,10SINEP
04:40:11 <nornagon> 0,11SINEP
04:40:13 <nornagon> 0,12SINEP
04:40:16 <nornagon> 0,13SINEP
04:40:18 <nornagon> 0,14SINEP
04:40:21 <nornagon> 0,15SINEP
04:40:24 <nornagon> 1,0SINEP
04:40:26 <nornagon> 1,1SINEP
04:40:28 <nornagon> 1,2SINEP
04:40:31 <nornagon> 1,3SINEP
04:40:33 <nornagon> 1,4SINEP
04:40:36 <nornagon> 1,5SINEP
04:40:38 <nornagon> 1,6SINEP
04:40:41 <nornagon> 1,7SINEP
04:40:43 <nornagon> 1,8SINEP
04:40:46 <nornagon> 1,9SINEP
04:40:48 <nornagon> 1,10SINEP
04:40:51 <nornagon> 1,11SINEP
04:40:53 <nornagon> 1,12SINEP
04:40:54 <ibid> aaRG!
04:40:56 <nornagon> 1,13SINEP
04:40:58 <wolverian> well, that's interesting.
04:40:58 <nornagon> 1,14SINEP
04:41:01 <nornagon> 1,15SINEP
04:41:03 <nornagon> 2,0SINEP
04:41:05 <ibid> ops around?
04:41:06 <nornagon> 2,1SINEP
04:41:08 <nornagon> 2,2SINEP
04:41:11 <nornagon> 2,3SINEP
04:41:13 <dblhelix> could someone pleaz.........
04:41:13 <nornagon> 2,4SINEP
04:41:16 <nornagon> 2,5SINEP
04:41:19 <nornagon> 2,6SINEP
04:41:21 <nornagon> 2,7SINEP
04:41:23 <nornagon> 2,8SINEP
04:41:26 <nornagon> 2,9SINEP
04:41:28 --- mode: ChanServ set +o dons
04:41:28 <nornagon> 2,10SINEP
04:41:31 <nornagon> 2,11SINEP
04:41:33 <nornagon> 2,12SINEP
04:41:34 --- kick: nornagon was kicked by dons (sorry)
04:41:46 <nornagon> eeeep
04:41:49 <dons> scary
04:41:51 <nornagon> so sorry!
04:41:52 --- mode: ChanServ set -o dons
04:41:56 <nornagon> wrong channel >.>
04:41:58 <ibid> nornagon: what was that about?
04:42:05 <nornagon> ibid: my irssi changed recently
04:42:06 <guerra> :P
04:42:13 <dons> wrong channel??!
04:42:14 <nornagon> i was trying to spam #ed
04:42:18 <ibid> nornagon: and?
04:42:20 <nornagon> on bantown
04:42:26 <nornagon> and that used to be window 23
04:42:32 <nornagon> but now haskell is 23 >.>
04:42:34 --- mode: ChanServ set +o Igloo
04:42:36 <dons> you probably shouldn't do that ...
04:42:41 --- mode: Igloo set +c
04:42:44 <nornagon> yes.
04:42:49 <nornagon> I will move haskell far far away.
04:42:51 <ibid> yeah, spamming would be a bad idea in general
04:42:52 <nornagon> I am v.v. sorry.
04:42:59 <guerra> lol
04:43:04 <nornagon> #ed is spam and only spam :P
04:43:04 <dons> Igloo: what's +c do?
04:43:10 <Igloo> Filters colour codes
04:43:13 <int-e> hmm. -s+t ?
04:43:14 <dons> cool
04:43:16 <ibid> let's talk fast so that horrible thing scrolls off the screen!
04:43:26 <dons> oh, we should keep the topic lock
04:43:27 <nornagon> everyone just /clear >.>
04:43:33 <int-e> I don't think we want to be secret, but topic protection is good
04:43:34 <dons> phew, gone
04:43:41 <Igloo> Why are we +s?
04:43:52 <dons> no idea.
04:43:58 <psnl> we don't want random trolls?
04:44:01 <int-e> probably has to do with the server crash yesterday
04:44:07 <dons> ah probably
04:44:08 <araujo> So nobody can't spy on us.
04:44:10 <dons> a few things went weird then
04:44:12 <ibid> on other networks it is necessary to avoid netwide trolls
04:44:18 <psnl> two lines to go!
04:44:21 --- mode: ChanServ set +o vincenz
04:44:27 <ibid> dunno if that's a big problem in freenode
04:44:27 <psnl> yey
04:44:46 --- mode: ChanServ set +c
04:44:50 <araujo> -t -s is good
04:45:03 <int-e> -t caused trouble.
04:45:18 <araujo> where?
04:45:18 <vincenz> lol
04:45:20 <vincenz> "wrong channel"
04:45:22 --- mode: Igloo set -s
04:45:29 <vincenz> as if spamming a different channel is acceptable
04:45:37 <dons> Igloo: can you set +t too?
04:45:37 <int-e> anyway as long as the topic is protected by chanserv we want +t, too.
04:45:42 --- mode: Igloo set +t
04:45:45 <dons> vincenz: why the ops?
04:45:52 --- mode: ChanServ set +t
04:46:03 --- mode: ChanServ set +ntc
04:46:10 <ibid> do we have an interface for editing the topic, now that we are +t?
04:46:19 --- mode: Igloo set -o Igloo
04:46:25 <psnl> lambdabot!
04:46:40 <ibid> does lambdabot have the topic changing premissions?
04:46:40 --- mode: vincenz set -o vincenz
04:47:00 <araujo> i set up topiclock on, and -t on most channels. And that isn't a problem.
04:47:19 <psnl> ibid: we might have to op lambdabot, but we oculd all audit the code first
04:47:37 <ibid> i mean, is there evidence of topic mangling with -t?
04:47:42 <ibid> if not, why +t?
04:47:50 <araujo> ibid, none i know of
04:47:55 <ibid> on freenode and specifically on this channel?
04:48:18 <dons> ibid: not with +t it doesn't
04:48:19 <int-e> we had some trouble a while ago, and topic lock made it worse. (dons might have a log)
04:48:31 <vincenz> dons: no reason :)
04:48:37 <Igloo> psnl: Good luck auditing the RTS  :-)
04:48:51 <dons> so we've got chanserv and +t locking the topic, iirc
04:48:54 <dons> which makes sense.
04:49:18 <dons> after a bout of heavy topic spamming/abuse a couple of months ago
04:49:27 <ibid> dons: in other words, topic is unwritable by mere users?
04:49:28 <vincenz> :/
04:50:00 <int-e> ibid: it hasn't been for some time now.
04:50:04 <dons> ibid: right
04:50:12 <araujo> i remember someone messing with the topic, but that was long ago
04:50:25 <dons> since 06.09.06:22:34:03 --- mode: Cale set +t
04:50:52 <dons> 06.09.22:15:21:03 <shapr> +t happened when spambots started puttings urls in the topic.
04:51:23 <dons> did everyone see the crazy number of haskell articles appearing on reddit? http://programming.reddit.com/ (and not from people in this channel! *gasp*)
04:51:25 <lambdabot> Title: reddit.com: programming - what&#39;s new online
04:52:44 <vincenz> dons: not to mention he makes mistakes
04:52:52 <Igloo> Wow; that could almost be the haskell.org news page
04:53:42 <dons> Igloo: yeah. my theory is that haskell articles rate well (we have all the new technology?) and so now the reddit regulars are searching out haskell articles to improve their karma...
04:53:45 <vincenz> ah nevermind, misread something
04:53:54 <Igloo> lol
04:54:07 <vincenz> lambdakarma-pimps
04:55:03 <dons> also, a fairly well known blogger is starting an epic haskell series, http://scienceblogs.com/goodmath/2006/11/why_haskell.php
04:55:05 <lambdabot> http://tinyurl.com/y8dzbl
04:55:10 <dons> so that helps make it 'ok' to post about haskell :)
04:55:26 <vincenz> heh
04:55:27 <vincenz> "The answer is simple: glue."
04:55:32 <vincenz> feels very much like a rip of whyfp
04:55:50 <dons> yeah, that was pointed out.
04:55:58 <vincenz> where?
04:56:03 <dons> in the comments, iirc
04:56:13 <vincenz> ah :)
04:56:14 <dons> "Nice article, definitely glue is what makes functional programming languages, well, functional. I'd give some props to John Hughes's paper "Why Functional Programming Matters", a popular paper which makes basically the same point about glue (even calls it glue), but in more detail."
04:56:34 <dons> 'Rehashing a *good* statement isn't necessarily a bad thing. I haven't seen Hughes' paper (if I had, I would have linked it),
04:56:37 <dons> but the glue property of functional languages is really fundamental - if I'd missed that in my understanding of Haskell, it would just mean that I didn't get Haskell."
04:56:40 <dons> (good response)
04:58:15 <vincenz> Yeps :)
04:58:20 <araujo> oh, the qsort example ... that's all it takes me to convince my teachers about Haskell
04:58:28 <vincenz> Still, props should be given where they are due
04:58:46 <araujo> I think i want a t-shirt with that example on the back
04:58:58 <dons> hehe
04:59:23 <dons> you'll have people pointing out that it would be more efficient inplace though...
04:59:33 <dons> and then you'll have to explain merge sort
04:59:39 <dons> and recursion
04:59:43 <dons> and then where will you be? :)
04:59:47 <vincenz> yeah, recursion, damn, that's so tough
05:00:11 <vincenz> even C has recursion
05:00:28 <dons> what was that comment recenly about not teaching recusion to python, ruby, java and C/C++ programmers because their stacks (and heads) explode
05:00:29 <nornagon> Heh.
05:00:41 <vincenz> dons: most c compilers tail recurse
05:01:18 <araujo> dons, i just hope they all are hot chicks :-)
05:01:22 <nornagon> but not ruby/python/java
05:01:30 * mux has been taught to avoid recursion like the plague in the past
05:01:31 <dons> vincenz, doesn't mean the programmer's head does though ;)
05:01:32 <nornagon> araujo: haha, good luck :)
05:01:40 <norpan> i hate that qsort example
05:01:40 <mux> and how to de-recursify stuff for optimization :-)
05:01:48 * araujo points hot = higher order typed
05:01:48 <vincenz> dons: :D
05:02:03 <vincenz> dons: point taken, I started really using recursion in my c program after I had relearned scheme
05:02:33 * mux has often used little stack APIs in C code to de-recursify tree walking
05:03:12 <Philippa> vincenz: tail recursion is, uh, not reliable in C. The analysis is a bitch
05:03:30 <Philippa> though not as bad as for general TCO
05:04:14 <vincenz> Philippa: as long as you don't have exceptions it's not that bad..
05:04:27 <vincenz> (and of course assuming no ugly stack hacking
05:09:58 <kpreid> just thought up this morning:
05:10:00 <kpreid> > ap (++) show "ap (++) show "
05:10:02 <lambdabot>  "ap (++) show \"ap (++) show \""
05:10:41 <kpreid> @. run . read run ap (++) show "ap (++) show "
05:10:44 <lambdabot>  "ap (++) show \"ap (++) show \""
05:11:39 <int-e> @quote state
05:11:39 <lambdabot>   ?. ++ . read . show . state ?. ++ . read . show . state
05:12:00 <kpreid> @help ++
05:12:01 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:12:16 <int-e> state is still disabled I hink.
05:12:26 <int-e> ++ could be used to append strings to the state
05:12:28 <kpreid> ah
05:12:44 <vincenz> what happens if you call set! in a sub-environment
05:12:45 <kpreid> anyway, it just occurred to my that my last haskell quine could be pointfreed
05:12:52 <vincenz> (let () (set! x 1))
05:12:58 <vincenz> and x exists in the parent-environment
05:13:09 <kpreid> > ap(++)show"ap(++)show" -- condensed version
05:13:11 <lambdabot>  "ap(++)show\"ap(++)show\""
05:13:15 <int-e> kpreid: I'm sure I've seen this beforem, but congrats anyway :)
05:18:23 <augustss> vincenz: then x gets set
05:18:31 <vincenz> whoops
05:18:33 <vincenz> wrong channel :)
05:18:42 <augustss> no problem
05:18:55 <augustss> scheme is no mystery :)
05:19:53 <augustss> environment does not effect where you can set a variable, just what's in scope
05:24:53 <vincenz> augustss: it could define a new one in the tighter env :)
05:31:22 <swiert> dcoutts: is there a home page for the functional programming course in Oxford?
05:31:48 <dcoutts> swiert, yep,though much of the material is not assessable outside oxford
05:31:53 <augustss> vincenz: it could, but it doesn't :)
05:32:09 <Igloo> swiert: http://web.comlab.ox.ac.uk/oucl/courses/topics06-07/fp/
05:32:12 <lambdabot> Title: Functional Programming, http://tinyurl.com/y7gasa
05:32:35 <swiert> dcoutts: Ok - that's a shame. We want to introduce our undergraduates to GUI programming with Haskell this year and I was hoping to steal some ideas.
05:32:36 <dcoutts> swiert, oh, Igloo found the url before me :-)
05:32:39 <swiert> Igloo: thanks.
05:32:52 <dcoutts> swiert, I can send you my proactical
05:33:11 <swiert> dcoutts: That'd be great!
05:34:11 <vincenz> augustss: so you answered my Q :)
05:34:53 <augustss> this is #haskell, we answer any questions :)
05:35:39 <Philippa> not true, #haskell-blah got set up to handle some of the ones I was being asked...
05:37:13 * vincenz snickers
05:37:15 <augustss> heh
05:37:28 <dylan> it's really interesting the mental images IRC nicks give me before I've had coffee.
05:38:28 <opqdonut> :D
05:38:46 * dylan pictures vincenz as sort of like the phantom from the phantom of the opera... and Philippa is a platypus...
05:39:03 <augustss> huh?
05:39:12 <augustss> your imagination is running wild
05:39:21 * mux is not sure he wants to know how is dylan picturing him
05:39:30 <dylan> mux: robot. :)
05:39:48 <augustss> surely with several inputs but only one output
05:39:48 <Philippa> I guess the platypus makes a change from that damn dolphin
05:41:07 <mux> dylan: am I 3-laws-compliant?
05:41:14 <opqdonut> :D
05:41:20 <dylan> mux: I . hope so.
05:41:33 <mux> must. destroy. humanity... *bzzzz*
05:41:44 <dylan> mux also reminds me of mutex
05:42:56 <dylan> hmm. I wonder if it's sane to rewrite my entire wmiirc in haskell.
05:43:10 <opqdonut> dylan: wmii? vade retro, satanus!
05:43:32 <dylan> huh?
05:43:55 <dylan> ion3 is what I'm using currently, but it sucks on my wide-screen display. :P
05:45:16 <dons> dylan: you got my wmiirc?
05:45:26 <opqdonut> dylan: how does it suck on widescreen?
05:45:28 <dylan> dons: yep, still writing my own for practice.
05:45:34 <opqdonut> dylan: works fine here, wuxga
05:45:38 <dons> good
05:45:50 <dylan> opqdonut: it doesn't allow me four 89x27 terminals that won't randomly change size
05:46:02 <dylan> dons: yours makes a good reference.
05:46:07 <opqdonut> dylan: not ion's fault but the terminal's
05:46:22 <dylan> well, I'll run just the terminal over using a window manager.
05:46:49 <dylan> rxvt is like a brother to me.
05:47:29 <opqdonut> ion's nudge usually fixes terminalsize related issues
05:47:53 <dylan> also I don't want to wait 'til fullsize status bar doesn't cause shrinking windows.
05:48:37 <opqdonut> yeah that is a problem
05:48:38 <dylan> And I find it easier experimenting with a 9p filesystem than lua.
05:48:50 <opqdonut> but i still like ion's model more
05:49:28 <dylan> not having tabs is a bonus for me
05:49:37 <dylan> as it has too much overlap with screen.
05:50:08 <dylan> and tagging is nice.
05:50:24 <opqdonut> dwm is nice, wmii is just ugly
05:51:00 <dylan> dwm doesn't allow me a grid of four rxvts
05:51:32 <opqdonut> precise layout is irrelevant, power is important
05:51:35 <dylan> it's either wmii, ratpoison, or ion3.
05:52:06 <dylan> I need to be able to see four things at once. :)
05:52:16 <opqdonut> ratpoison lacks power for anything more complicated than one or two frames
05:52:36 <vincenz> augustss: another Q
05:52:53 <vincenz> augustss: mind joining #oasis briefly?
05:53:06 <opqdonut> dylan: are you sure you really need to?
05:53:22 <dylan> opqdonut: yes, otherwise the space is wasted.
05:53:48 <opqdonut> a longer backlog is not wasted space
05:53:50 <dylan> I really don't need 60 or 80 lines of IRC.
05:53:56 <opqdonut> too wide terminals are, yes
05:54:06 <dylan> or 60 or 80 lines of mutt is also a waste
05:54:16 <dylan> as I often only have 10 messages per folder. :P
05:54:18 <opqdonut> 80 lines is screen height for me
05:54:35 <opqdonut> and it's nice for ircs
05:54:40 <opqdonut> *ircing
05:56:59 <dylan> also, I was able to make left/right movement between columns work in the way I expect it wmii, haven't figured out how to do that in ion3 yet
05:57:58 <dylan> and having a config file written in haskell is fun. :-D
06:00:00 <dylan> though, dwm with a grid view and multihead support would work nicely.
06:00:30 <dylan> especially dwm rewritten in haskell... I think someone wagered it could be done in about 200 lines of haskell. :)
06:01:21 <Botje> is wmii no longer developed? :(
06:02:24 <Botje> oh, the mailing list is still active
06:02:37 <Botje> looks like the maintainer got held up by Real Life(tm)
06:02:39 <Botje> nm :)
06:02:42 <yaarg> i think the original  developer isnt working on it anymore
06:04:14 <dylan> yeah, he's working on dwm.
06:04:51 * yaarg nods
06:07:13 <yaarg> i did a google recently for a haskell window manager and found some australian university has the idea listed as a thesis topic
06:08:11 <yaarg> but apart from that i didn't find anything :)
06:10:27 <mux> yay, GHC 6.6 compilation done
06:13:10 <pejo> yaarg, http://twb.ath.cx/~twb/hack/SCRATCHPAD/c/tinywm/tinywm-haskell.hs
06:13:11 <lambdabot> http://tinyurl.com/yg32zx
06:13:24 <pejo> Think it was dons who gave the link the other day, but I'm not sure.
06:14:02 <yaarg> yeah i've seen that before actually
06:14:39 <dr_strangelove> why is clean faster than haskell?
06:15:47 <dr_strangelove> I heard some arguments that haskells (sometimes) slowness is due to lazy evaluation, but clean has also lazy evaluation?
06:18:14 <yaarg> it's not significantely faster to make such a statement
06:18:24 <yaarg> and iirc there were problems with the programs used to benchmark
06:19:12 <pejo> dr_strangelove, (performance drawbacks of lazy eval is dcoumented here and there, Boquist's thesis, Ennals thesis, an article by Nethercoete, and probably a bunch more that I'm missing out).
06:19:43 <ms_> how efficient in terms of memory are adts in general?
06:20:28 <yaarg> problems being the clean programs used strict evaluation everywhere for example!
06:20:34 <yaarg> so like..yeah
06:20:35 <ms_> I've added a couple of fields to an ADT and found performance crippled. I'm just wondering if it's a cache problem that there's now too much data to fit in the cache
06:21:01 <ValarQ> isn't the main difference that clean has simpler ways of controlling strictness?
06:21:27 <ValarQ> yaarg: you mean it doesn't support lazy evaluation?
06:22:18 <dr_strangelove> I consider writing a network simulator in haskell, but the algorithm involves state, and arrays that are modified in each iteration. Is haskell a good candidate for such an algorithm?
06:22:52 <ValarQ> dr_strangelove: yes, but you need to know what datastructures to use
06:23:25 <dr_strangelove> ValarQ, arrays with fixed size
06:23:31 <yaarg> ValarQ: no it does
06:23:44 <ValarQ> DiffArrays for example
06:24:56 <ValarQ> yaarg: the webpage says "The programming language Clean is a general purpose, state-of-the-art, pure and lazy functional programming language designed for making real-world applications."
06:25:20 <dr_strangelove> hm, looks complicated, but thanks, I give it a try
06:26:01 <yaarg> ValarQ: yeah it said it does :)
06:26:30 <ValarQ> dr_strangelove: maybe Data.Array.ST is what you're looking for (havent tested it myself thought)
06:27:15 <ValarQ> yaarg: but it doesn't?
06:28:09 <yaarg> ValarQ: i'm saying it does support lazy evaluation
06:28:26 <yaarg> right?
06:29:48 <ValarQ> oh, i misinterpreted your answer, sorry
06:30:56 <ValarQ> but whats the problem with clean programs using strictness?
06:33:12 <dons> dr_strangelove: just use mutable arrays if your algorithm demands it (or use Data.IntMap)
06:33:25 <yaarg> strict annotations
06:33:35 <metaperl> which is older? Clean or haskell?
06:33:38 <dons> clean
06:33:40 <dylan> Clean.
06:33:58 <metaperl> why did haskell develop even though Clean was around?
06:34:46 <araujo> Haskell is more open :-)
06:35:11 <ValarQ> yaarg: is that a problem?
06:35:53 <metaperl> araujo - more open to what?
06:37:14 <dylan> haskell is more free. :-)
06:38:16 <ValarQ> dr_strangelove: http://copilotconsulting.com/mail-archives/haskell.2006/msg00997.html
06:38:18 <araujo> metaperl, than clean
06:38:19 <dylan> hey, cool. my work machine is upgrading to ghc 6.6
06:38:22 <lambdabot> Title: [Haskell] modern arrays library, http://tinyurl.com/y8l9bm
06:40:18 <yaarg> ValarQ: i was saying, in the clean versus haskell benchmarks that people commonly refer to the clean programs were found to use strictness annotations iirc
06:42:28 <dons> and note the builtin strict strings in Clean missing in Haskell's shootout entries prior to ByteString..
06:43:39 <dons> some might be interested, i just added a simple state monad interpreter to this reddit thread :) http://programming.reddit.com/info/sijx/comments
06:43:42 <lambdabot> Title: Why Haskell? (reddit.com), http://tinyurl.com/ynauv9
06:44:23 <dons> the subsection is http://programming.reddit.com/info/sijx/comments/cslsz (the question was begging for a state monad)
06:44:25 <lambdabot> Title: Why Haskell? (reddit.com), http://tinyurl.com/ymgzfw
06:49:27 <ValarQ> dons: what version of ghc is the shootout using now?
06:50:23 <wolverian> heh, bootsandtea makes a good point about why's tutorial (http://programming.reddit.com/info/sijx/comments/cslj6)
06:50:26 <lambdabot> Title: Why Haskell? (reddit.com), http://tinyurl.com/sucu4
06:51:36 <dons> ValarQ: one is using 6.6, the other 6.4.2 (the one everyone is looking at uses 6.4.2 still)
06:52:57 <pejo> wolverian, "about why's tutorial"?
06:52:58 <ValarQ> so the applications used has to be 6.4.2 compatible then?
06:53:26 <dons> no, they can fail with 6.4.2, assuming 6.6 is to be added soon
06:53:34 <dons> we've already submitted 3 bytestring solns, i think
06:53:56 <ValarQ> great, how are they doing?
06:54:52 <dons> well, they've not been run yet
06:55:06 <dons> we now they do very well from local testing (between C and C++ in speeD)
06:55:09 <dons> (I think)
06:55:55 <ValarQ> beating C++ shouldn't be so hard :)
06:58:04 <pejo> ValarQ, both Intel and the GCC people are working quite hard on performance improvements.
06:59:49 <ValarQ> pejo: i'm sure they do...
07:03:19 <Syzygy-> sigfpe_: You poked me last night?
07:08:06 <opqdonut> what's the standard idiom for shuffling a list?
07:08:16 <psnl> there is no longer any speedup from using forkOS on SMP systems, right?
07:08:49 <mux> ?TYPE SORT
07:08:50 <lambdabot> Unknown command, try @list
07:08:52 <mux> oops, caps
07:08:54 <mux> ?type sort
07:09:00 <lambdabot> forall a. (Ord a) => [a] -> [a]
07:09:05 <mux> ?type sortBy
07:09:07 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
07:09:14 <Igloo> psnl: You need to use +RTS -N 2 to use 2 Haskell threads without it
07:10:59 <psnl> Igloo: okish
07:22:06 <vincenz> what is the dual of "a dependent"
07:22:19 <vincenz> x -> y: y is a dependent of x, x is a .... of y
07:25:47 <gds> http://pozorvlak.livejournal.com/34731.html -- Indentation gotcha for docs writers.
07:25:50 <lambdabot> Title: pozorvlak: An open letter to the authors of Haskell documentation
07:26:14 <gds> Looks like someone wrote a function in emacs, which when you copy it into vim, probably won't compile :)
07:26:44 <vincenz> LOL "Scientific papers are not an acceptable form of documentation. They're barely an acceptable way of doing science."
07:26:48 <vincenz> that guy is trolling
07:27:11 <gds> I'm afraid he's not - he's a good friend of mine - he's just annoyed.
07:27:27 <sjanssen> there's a problem with the docs for Control.Monad.State
07:27:31 <gds> Feel free to ignore that bit - look at the indentation issue.
07:27:57 <sjanssen> erm, there was supposed to be a question mark there
07:28:04 <gds> sjanssen: Almost...
07:28:07 * psnl wonders about a haskell drinking game featuring "monadic" or "combinator"
07:28:29 <gds> sjanssen: There's an example in there, which works, so long as you type it in /precisely/
07:28:38 <gds> But if you use vim, and the tab key, it won't do what you expect.
07:28:58 <sjanssen> gds: do you know which example?
07:29:06 <gds> Yes - it's the one we talk about in that thred.
07:29:10 <gds> *thread
07:29:11 <vincenz> a) tabs shouldn't be used, and any sane vimmer will turn tabs into spaces, b) well I personally always put do on an empty line but that's just me :)
07:29:12 <psnl> @help quote
07:29:13 <lambdabot> quote <nick>
07:29:13 <lambdabot> remember <nick> <quote>
07:29:13 <lambdabot> Quote somebody, a random person, or save a memorable quote
07:29:13 <gds> the ticker example.
07:29:17 <vincenz> @quote psnl
07:29:17 <lambdabot>  ndm: you should have stayed around for the part where Conor denied he was Conor.
07:29:19 * sjanssen continues reading
07:29:31 <gds> vincenz: Both of us do turn them into spaces - that's not the problem.
07:29:36 <vincenz> hmm
07:30:00 <psnl> @quote Conor We could all sit in a long line with laptops, and talk to each other on #haskell
07:30:01 <lambdabot> Conor We could all sit in a long line with laptops, and talk to each other on #haskell hasn't said anything memorable
07:30:07 <gds> Certainly, putting do on an empty line seems like the easiest way to avoid trouble.
07:30:12 <psnl> dang
07:30:16 <sjanssen> ah, I see
07:30:22 <psnl> @remember Conor We could all sit in a long line with laptops, and talk to each other on #haskell
07:30:27 <gds> I just thought it was worth mentioning to folks that write docs and examples.
07:31:14 <gds> especially since if you're using emacs (which I often do), you'll probably not ever be made aware of the gotcha otherwise...
07:31:52 <LoganCapaldo> dons: To play with Yi, should I get the release or the development?
07:32:02 <gds> Of course, another way would be to write a vim indentation mode or something - but my vim-fu isn't that good :)
07:32:37 <sjanssen> gds: is pozorvlak new to Haskell?
07:32:47 <opqdonut> ?pl \a -> do { x<-randomIO; return (a,x) }
07:32:48 <lambdabot> (line 1, column 10):
07:32:49 <lambdabot> unexpected "{"
07:32:49 <lambdabot> expecting variable, "(", operator or end of input
07:33:13 <opqdonut> ?pl \a -> randomIO >>= \x -> return (a,x)
07:33:13 <lambdabot> (`fmap` randomIO) . (,)
07:33:15 <gds> sjanssen: Kinda - he played with it half a decade or so ago, had fun, did other stuff, and is now re-learning.
07:33:42 <gds> He's a mathematician, but with a bit of hacker in him.
07:34:09 <gds> He does both category theory and perl pretty well :)
07:34:51 <opqdonut> ?pl \xs -> mapM (\a -> randomIO >>= \x -> return (a,x)) xs
07:34:51 <lambdabot> mapM ((`fmap` randomIO) . (,))
07:34:56 <opqdonut> ugh
07:35:12 <vincenz> @pl \f x y z -> f x y z
07:35:13 <lambdabot> id
07:35:18 <vincenz> @pl \x y z -> f x y z
07:35:19 <lambdabot> f
07:35:32 <vincenz> @pl \f g x y z -> f (g x y z)
07:35:33 <lambdabot> (.) . (.) . (.)
07:35:36 <gds> sjanssen: If you're replying, and LJ complains about maintenance at you - just retry. It's being a bit awkward this morning.
07:36:19 * eviltwin_b has been getting failures and odd style timeouts all (long) weekend
07:36:30 <vincenz> seems to be since 7nov
07:36:32 <gds> (oh, and I'm "totherme", in case anyone that cares didn't know ^_^ )
07:36:34 <kpreid> @unpl mapM ((`fmap` randomIO) . (,))
07:36:35 <lambdabot> mapM (\ d -> fmap (((,)) d) randomIO)
07:36:55 <kpreid> ook (can't unpl fmap)
07:38:36 <sjanssen> the indentation in Control.Monad.State is really funky
07:39:30 <sjanssen> @hoogle a -> [a] -> Int
07:39:31 <lambdabot> No matches, try a more general search
07:39:42 <sjanssen> @hoogle (a -> Bool) -> [a] -> Int
07:39:43 <lambdabot> No matches, try a more general search
07:40:37 <kpreid> @type length . filter
07:40:38 <lambdabot>   Expecting a function type, but found `b'
07:40:38 <lambdabot>    Expected type: (a1 -> Bool) -> [a]
07:40:56 <kpreid> @type \f -> length . filter f
07:40:57 <lambdabot> forall a. (a -> Bool) -> [a] -> Int
07:41:13 <sjanssen> @hoogle elemIndex
07:41:14 <lambdabot> List.elemIndex :: Eq => a -> [a] -> Maybe Int
07:41:14 <lambdabot> Data.List.elemIndex :: Eq a => a -> [a] -> Maybe Int
07:41:16 <sjanssen> there we go
07:41:33 <mux> @hoogle find
07:41:35 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
07:41:36 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
07:41:36 <lambdabot> List.findIndices :: (a -> Bool) -> [a] -> [Int]
07:44:04 <opqdonut> what's the standard idiom for shuffling a list?
07:44:25 <sjanssen> anyone have a copy of /The Craft of Functional Programming/?
07:44:28 <mux> I don't think there's a standard idiom for this
07:45:01 <kpreid> > map fst . List.sortBy snd . zip (randoms (mkStdGen 0)) $ "abcdef"
07:45:03 <lambdabot>    Occurs check: cannot construct the infinite type: t = (a, t -> t1)
07:45:04 <lambdabot>    ...
07:45:18 <kpreid> > map snd . List.sortBy fst . zip (randoms (mkStdGen 0)) $ "abcdef"
07:45:19 <lambdabot>    Occurs check: cannot construct the infinite type: t = (t -> t1, b)
07:45:20 <lambdabot>    ...
07:45:34 <kpreid> @type sortBy
07:45:36 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
07:46:05 <kpreid> @hoogle (a -> b) -> a -> a -> Ordering
07:46:06 <lambdabot> No matches, try a more general search
07:46:29 <kpreid> > map snd . List.sortBy (\a b -> fst a `compare` fst b) . zip (randoms (mkStdGen 0)) $ "abcdef"
07:46:30 <lambdabot>  Add a type signature
07:46:41 <kpreid> > map snd . List.sortBy (\a b -> fst a `compare` fst b) . zip (randoms (mkStdGen 0) :: [Integer]) $ "abcdef"
07:46:45 <lambdabot>  "bdefca"
07:48:06 <opqdonut> nice, i was thinking about something like that
07:48:18 <mux> except it's not really random :-)
07:48:23 <kpreid> ghc 6.6 has a combinator to make the sorting function nicer, iirc
07:48:29 <mux> > map snd . List.sortBy (\a b -> fst a `compare` fst b) . zip (randoms (mkStdGen 0) :: [Integer]) $ "abcdef"
07:48:32 <lambdabot>  "bdefca"
07:48:41 <kpreid> and you need to supply a StdGen by some means other than mkStdGen 0, of course
07:48:47 <opqdonut> yeah, oC
07:48:47 <mux> the seed should be something at least a bit random
07:48:53 <kpreid> that was just to be able to run it in lambdabot
07:48:56 <mux> k
07:49:18 <opqdonut> map snd . List.sortBy (first compare) . zip (randoms (mkStdGen 0) :: [Integer])
07:49:28 <opqdonut> > map snd . List.sortBy (first compare) . zip (randoms (mkStdGen 0) :: [Integer])
07:49:29 <lambdabot>    Expecting a function type, but found `t_a1Uj'
07:49:29 <lambdabot>    Expected type: (b, d...
07:49:36 <opqdonut> hrmm
07:49:45 <kpreid> @type first compare
07:49:47 <lambdabot> forall b d. (Ord b) => (b, d) -> (b -> Ordering, d)
07:51:21 <opqdonut> if there was a randomsIO this would be easy
07:51:33 <opqdonut> (of course defining one isn't hard)
07:51:46 <kpreid> @type liftM randoms newStdGen
07:51:48 <lambdabot> forall a. (Random a) => IO [a]
07:52:12 <kpreid> myself I'd write a function taking the StdGen instead of mingling the IO code
07:52:30 <opqdonut> i use random so extensively that i have to resort to randomIO
07:52:48 <kpreid> *doubt*
07:53:01 <sjanssen> opqdonut: have you seen the random monad?
07:53:04 <kpreid> reader monad? splitting generators? implicit variables?
07:53:19 <opqdonut> sjanssen: no?
07:53:35 <opqdonut> > liftM randoms newStdGen >>= (return . take 10) >>= print
07:53:36 <lambdabot>  Add a type signature
07:53:46 <sjanssen> opqdonut: http://www.haskell.org/haskellwiki/New_monads/MonadRandom
07:53:49 <lambdabot> Title: New monads/MonadRandom - HaskellWiki, http://tinyurl.com/y5xzau
07:53:49 <opqdonut> > liftM randoms newStdGen :: [Integer] >>= (return . take 10) >>= print
07:53:50 <lambdabot>  Parse error
07:54:07 <opqdonut> > ((liftM randoms newStdGen) :: [Integer]) >>= (return . take 10) >>= print
07:54:08 <lambdabot>  Couldn't match `Integer' against `[a]'
07:54:09 <Saizan> the type sign goeas at the end
07:55:02 <kpreid> opqdonut: the type of the sub-bit would be IO [Integer]
07:55:18 <opqdonut> > ((liftM randoms newStdGen) :: IO [Integer]) >>= (return . take 10) >>= print
07:55:20 <lambdabot>  <IO ()>
07:55:23 <opqdonut> nice...
07:56:57 * boegel boings off
07:57:22 <opqdonut> i tried something like "sequence [randomIO,randomIO] >>= print" but it crashes with a stack overflow :((
07:57:42 <kpreid> that's ...oddd
07:58:03 <opqdonut> yeah
07:58:22 <psnl> opqdonut: what does print $ randomIO do?
07:58:33 <opqdonut> > (sequence [randomIO,randomIO] :: [IO Integer]) >>= print
07:58:35 <lambdabot>  Couldn't match `IO Integer' against `[a]'
07:59:05 <opqdonut> psnl: No instance for (Show (IO ()))
07:59:12 <opqdonut> i guess you mean randomIO >>= print?
07:59:21 <Cale> "sequence [randomIO,randomIO] >>= print" works for me
07:59:23 <opqdonut> > ((sequence [randomIO,randomIO]) :: IO [Integer]) >>= print
07:59:25 <lambdabot>  <IO ()>
07:59:32 <psnl> opqdonut: yeah
07:59:45 <psnl> > randomIO >>= print
07:59:47 <lambdabot>  Add a type signature
08:00:00 <Cale> (It defaults to Integer)
08:00:00 <psnl> > randomIO :: IO(Int) >>= print
08:00:02 <lambdabot>  Parse error
08:00:03 <kpreid> common mistake, at least for me: using liftM where =<< is appropriate
08:00:05 <opqdonut> "*** Exception: stack overflow" even with "randomIO >>= print"
08:00:26 <Cale> opqdonut: there's something wrong with your GHCi installation
08:00:31 <opqdonut> i restarted ghci, now it works
08:01:34 <opqdonut> if i use randomIO more that once i get stack overflow
08:01:55 <w-ber> How would one define the Church numerals in Haskell?
08:02:02 <w-ber> > churchNumeral 0 = (\x -> x)
08:02:03 <lambdabot>  Parse error
08:02:09 <psnl> opqdonut: what is your OS? what happens if you compile with ghc?
08:02:21 <opqdonut> psnl: linux
08:02:59 <resiak> w-ber: the 0th church numeral is (\f z -> z), for starters
08:03:04 <resiak> (unless my mind has completely failed me
08:04:17 <w-ber> Right.
08:04:31 <opqdonut> psnl: it works when i compile it
08:04:59 <w-ber> resiak: However, that creates an infinite type, not matter how you write it. (At least that's why ghc is telling me.)
08:05:37 <kpreid> churchNumeral n = \f z -> iterate f z !! n
08:06:07 <kpreid> > (\f z -> z) succ 0
08:06:08 <lambdabot>  Add a type signature
08:06:16 <kpreid> > (\f z -> z) succ (0::Int)
08:06:18 <lambdabot>  Add a type signature
08:06:29 <kpreid> > (\f z -> z) (succ::Int -> Int) 0
08:06:30 <lambdabot>  0
08:06:43 <w-ber> Fun.
08:06:51 <opqdonut> > \f z -> iterate f z !! 2
08:06:53 <lambdabot>  Add a type signature
08:07:11 <kpreid> opqdonut: it needs to know the type of f to make it executable
08:07:56 <opqdonut> yeah
08:12:38 <dr_strangelove> how do you decide between "where" and "let ... in"?
08:13:49 <kpreid> (a) whichever part is bigger, the definitions or the body, goes last
08:13:51 <Saizan> let .. in for bounding values, and where for aux functions generally
08:14:07 <kpreid> (b) whichever fits better in the narrower beginning lines goes first
08:14:37 <dr_strangelove> what does (b) mean?
08:14:58 <norpan> you need to use where if you're defining multi-definition functions, otherwise use let :)
08:15:15 <Ugarte> He means the body or the bindings, I think.
08:15:32 <kpreid> dr_strangelove: the first part will generally end up indented more, so use the resulting line length to judge
08:15:32 <dr_strangelove> can you nest where functions?
08:15:58 <kpreid> also, one way to write a simple recursive definition is:
08:16:15 <kpreid> foo x = result where result =
08:16:15 <kpreid>   <big definition>
08:16:46 <norpan> what would that buy you, exactly
08:16:51 <resiak> why not foo x = \n   <big definition>?
08:17:08 <kpreid> you use it when the definition is recursive
08:17:11 <kpreid> contains the result
08:17:21 <norpan> ah, when you have parameters to result
08:17:30 <norpan> but you didn't write any parameters :)
08:17:36 <kpreid> no, not parameters
08:17:47 <kpreid> where the big definition contains 'result' itself
08:18:04 <resiak> 'result' is longer than 'foo x' ;)
08:18:13 <kpreid> hmm
08:18:21 <Ugarte> De gustibus non disputandum.
08:18:27 <Ugarte> Ultimately you're just talkin gabout issues of taste.
08:18:53 <kpreid> I guess I'm imperative-thinking
08:19:05 <norpan> i don't remember, are parameterless functions memoized or is it just top-level functions
08:19:16 <kpreid> where you want to build a real cycle and not just refer to a separate invocation of the maker
09:26:52 <Saizan> is there something like fromNum :: (Num a, Num b) => a -> b ?
09:27:14 <twanvl> ?type fromIntegral
09:27:16 <lambdabot> forall b a. (Num b, Integral a) => a -> b
09:27:44 <vincenz> @hoogle (Num a, Num b) => a -> b
09:27:46 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
09:27:46 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
09:27:46 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
09:27:53 * vincenz coughs
09:28:25 <mauke> @type toEnum . fromEnum
09:28:26 <lambdabot> forall a a1. (Enum a, Enum a1) => a1 -> a
09:31:21 <Saizan> :O
09:35:03 <kpreid> @type fromEnum
09:35:04 <lambdabot> forall a. (Enum a) => a -> Int
09:35:15 <Saizan> wait, so Fractional are an enumeration?
09:35:21 <kpreid> > (toEnum . fromEnum) 1000000000000000000 :: Integer
09:35:22 <lambdabot>  -1486618624
09:36:14 <Saizan> > (toEnum . fromEnum) 2.34534 :: Float
09:36:16 <lambdabot>  2.0
09:36:27 <sjanssen> > fromEnum (1%2)
09:36:29 <lambdabot>  0
09:36:59 <Saizan> it's not very good
09:37:41 <sjanssen> Saizon: as you can see, the fractional types aren't very well behaved Enums
09:38:07 <Saizan> maybe because they are not countable?:D
09:39:34 <sjanssen> > [1.0, 1.1 .. 2.0] -- I imagine they're only instances of Enum for this notation
09:39:35 <lambdabot>  [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004,1.50000000...
09:39:39 <sjanssen> hahaha
09:39:55 <sjanssen> and /this/ is why floating point sucks
09:40:20 <sjanssen> > map fromRational $ [1.0, 1.1 .. 2.0]
09:40:22 <lambdabot>  [1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.0]
09:41:57 <Saizan> the problem is that we still have a silicon chip under us
09:43:05 <sjanssen> I think Double is the wrong default
09:43:47 <Saizan> so? 128 bit?
09:44:11 <sjanssen> I'd rather see Rational be the default
09:45:38 <Saizan> ah, in haskell, yes me too
09:46:08 <mauke> > 1%2 + 0.5
09:46:09 <lambdabot>  1%1
09:49:07 <profmakx> hm
09:49:18 <profmakx> did anyone do continued fractions with haskell?
10:30:16 <astrolabe> profmakx: I've got a feeling their almost built in
10:30:39 <profmakx> heh
10:30:43 <astrolabe> there is some library which will find good rational approximations to Doubles for instance.
10:30:44 <profmakx> well weve got lists
10:32:28 <astrolabe> Ah no, I was thinking of
10:32:34 <astrolabe> @type approxRational
10:32:35 <lambdabot> forall a. (RealFrac a) => a -> a -> Rational
10:32:52 <astrolabe> which doesn't seem to use continued fractions
10:33:02 <astrolabe> I don't think.
10:33:04 <vraj> @doc HDBC
10:33:04 <lambdabot> HDBC not available
10:33:07 * astrolabe looks harder
10:33:08 <profmakx> hmm
10:33:46 <profmakx> Num -> [Int] would be nice
10:34:31 <astrolabe> how would that work for 2.5 :: Double
10:34:43 <astrolabe> Ah, I see what you mean
10:34:56 <astrolabe> not hard to write
10:43:23 <lisppaste2> metaperl pasted "Is there a better way to implement my own unzip?" at http://paste.lisp.org/display/30801
10:43:58 <Cale> you don't need the first case
10:44:02 <SyntaxNinja> w00t
10:44:21 <metaperl> Cale - but isnt my implementation horribly inefficient?
10:44:55 <Cale> doesn't seem all that bad to me -- is it slow?
10:45:16 <metaperl> Cale - well shouldn't there be a way to do this in one pass as opposed to two?
10:45:41 <Lemmih> Greetings SyntaxNinja.
10:45:45 <metaperl> in an imperative language, you would not recurse over the list twice
10:46:20 <Cale> meh, constant factor :)
10:46:24 <Cale> hehe
10:46:45 <metaperl> Cale but what if the input list were 1 million items long?
10:46:49 <Cale> I suppose you could do it in one pass
10:46:55 <metaperl> Cale - how?
10:47:55 <arjanoosting> SyntaxNinja: you were looking for me?
10:48:41 <lisppaste2> Cale annotated #30801 with "unzip" at http://paste.lisp.org/display/30801#1
10:49:04 <Cale> I wouldn't prefer that though.
10:49:32 <Binkley> you could also use a fold
10:49:34 <Saizan> i was going to paste that :O
10:49:47 <Cale> sure
10:49:53 <Binkley> which is more or less equivalent to Cale's version, it just avoids explicit recursion, which is always godo :-)
10:49:55 <Binkley> good, even.
10:50:00 <metaperl> Cale - your solution is mind-boggling. I will be staring at it the rest of the day
10:50:08 <Cale> mind-boggling?
10:50:11 <metaperl> Binkley - I dont think a fold will work will it?
10:50:13 <Binkley> metaperl: if you think that's mind-boggling, wait till you see the Y combinator
10:50:20 <Cale> of course it will :)
10:50:28 * metaperl shudders
10:50:59 <metaperl> oh, now that you mention it, I think a fold left could work
10:51:00 <Cale> unzip' = foldr (\(x,y) (xs,ys) -> (x:xs, y:ys)) ([],[])
10:51:12 <lisppaste2> Binkley annotated #30801 with "not tested!" at http://paste.lisp.org/display/30801#2
10:51:24 <metaperl> oh yes, consing on from the right
10:51:28 <Binkley> mine might reverse it or something
10:51:32 <Binkley> but, it's all the same, really
10:52:05 <Cale> yeah, that'll reverse the lists
10:52:11 <Binkley> I'm a bit dyslexic that way
10:52:25 <Binkley> you could use foldr or you could use foldl with snoc. same difference
10:52:26 <kpreid> @pl foldr (\(x,y) (xs,ys) -> (x:xs,y:ys)) ([],[])
10:52:27 <lambdabot> foldr (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (:)) . flip . (((.) . (,)) .) . (:))) ([], [])
10:52:32 <Binkley> :-(((((
10:52:40 <Saizan> d'oh
10:52:43 <Cale> Have you seen my fold diagrams?
10:52:47 <Binkley> yeah
10:53:12 <metaperl> Cale - no I havent, but I wold like to
10:53:23 <SyntaxNinja> heya arjanoosting
10:53:25 <metaperl> @type snoc
10:53:26 <lambdabot> Not in scope: `snoc'
10:53:53 <Saizan> fold diagrams?
10:54:10 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
10:54:43 <arjanoosting> heya SyntaxNinja
10:57:14 <Cale> The important thing to remember is that foldr is almost always the one you want.
10:57:29 <Binkley> metaperl: snoc x xs = (xs ++ [x])
10:57:33 <Binkley> it's not a prelude function, though
10:57:43 <Binkley> since it's inefficient ;-)
10:58:18 <Cale> xs ++ ys takes O(length xs) time to finish, in the worst case.
10:58:21 <Saizan> <Cale> http://cale.yi.org/index.php/Fold_Diagrams <-- i only get connection timeout..
10:58:27 <Cale> Saizan: hmm
10:58:38 <metaperl> Saizan that is a Zen diagram of folding
10:58:44 <metaperl> stare at the blank space
10:58:47 <Cale> oh, I know why
10:58:48 <metaperl> and you shall know all
10:58:56 <metaperl> :)
10:58:58 <Saizan> :O
10:59:04 <metaperl> lol
10:59:04 <Cale> something has gone screwy with my router config
10:59:26 <Binkley> I don't suppose anyone here is unfortunate enough to use darcs with mingw?
10:59:34 <cjeris> Cale: "foldr is almost always the one you want", why?
10:59:55 <Cale> cjeris: because foldr f z directly replaces (:) with f and [] with z
11:00:03 <Cale> So it's extremely natural.
11:00:18 <Cale> It also works well with lazy evaluation
11:01:17 <cjeris> I still don't have a handle on what works well in lazy context... I'm used to thinking in ML, "foldl can be written as a tail-recursive loop but foldr can't".
11:01:41 <Cale> Tail recursion is evil in the presence of laziness.
11:01:43 <mauke> short version: tail recursion = bad :-)
11:01:47 <cjeris> although you can always reverse first, then ((foldl .) .) . flip
11:01:57 <sjanssen> another good rule of thumb: foldl' when you know that the whole list must be consumed before you can produce output
11:02:06 <Cale> In fact, if you're going to use foldl, you probably want foldl'
11:02:13 <Cale> right
11:02:13 <cjeris> tail recursion is evil in the presence of laziness ?!?!
11:02:15 <Cale> yes
11:02:32 <Cale> let me give you an example, and you'll see why
11:02:35 <mauke> it eats your call stack
11:02:51 <Cale> foldl f z [] = z
11:03:03 <Cale> foldl f z (x:xs) = foldl f (f z x) xs
11:03:12 <Cale> foldl (+) 0 [1,2,3]
11:03:21 <Cale> = foldl (+) (0 + 1) [2,3]
11:03:29 <Cale> = foldl (+) ((0 + 1) + 2) [3]
11:03:38 <Cale> = foldl (+) (((0 + 1) + 2) + 3) []
11:03:40 <cjeris> oh... instead of paying 0 times, you pay 2 times!
11:03:44 <Cale> = (((0 + 1) + 2) + 3)
11:03:50 <Cale> = ((1 + 2) + 3)
11:03:53 <Cale> = (3 + 3)
11:03:55 <Cale> = 6
11:04:07 <Cale> yep
11:04:17 <Cale> So that's why foldl' exists
11:04:29 <cjeris> so, it confuses you, and buys you nothing.  whereas in strict languages, it confuses you, but buys you a lot. :)
11:04:31 <Cale> it's strict, and so the evaluation is forced as you consume the list
11:05:33 <metaperl> by strict you mean immediate evaluation?
11:05:51 <Saizan> but, how is it strict? built-in magic?
11:05:58 <metaperl> and tail-recursion is not useful for haskell programs?
11:06:00 <mauke> seq, mostly
11:06:07 <Cale> By strict, I mean that it forces the evaluation of its parameters before continuing with the recursive call
11:06:12 <mauke> strict is the opposite of lazy
11:06:14 <cjeris> thanks Cale!
11:06:30 <Cale> foldl' f z [] = z
11:06:30 * cjeris disappears for meeting &
11:06:34 <metaperl> i came from SCheme --- i think tail recursion is optimizable.. but again that is a strict language
11:06:48 <Cale> foldl' f z (x:xs) = let y = f z x in y `seq` foldl' f y xs
11:07:11 <Cale> Tail recursion is optimised into a loop in either case
11:07:36 <Cale> but if the function is lazy, you don't really get much out of it, and you risk stack overflows
11:08:11 <Cale> The reason why is that you end up with a tight loop that does nothing but build up a big expression which still needs to be evaluated.
11:08:23 <Cale> (and that expression is just as large as the original list, in the case of foldl)
11:08:24 <metaperl> Ok, one other question... One of the things I remember Autrijus telling me about Haskell is that you can abstract anything... but can you abstract whether all aspects of a program run lazily or eagerly?
11:08:38 <Binkley> metaperl: what do you mean?
11:08:53 <Cale> You can do various things to force the evaluation of values whenever you want that evaluation to occur.
11:09:22 <Cale> Let me just fix my connection -- somehow I got assigned the wrong IP address on the LAN.
11:09:30 <Cale> (which is why my webserver is down)
11:09:38 <Cpudan80> Hello everyone
11:09:42 <metaperl> Binkley - a program has to use foldl or foldl' --- it has to buy into a strategy of computation... Monads are supposed to be pluggable strategies of computation
11:09:45 <metaperl> Cpudan80 hi
11:09:52 <Cpudan80> I am doing a haskell programming project -- any good tutorials?
11:10:03 <Cpudan80> I would hate to bombard you with newb questions :)
11:10:04 <kpreid> > let strictOrLazy x y c = ((,) `c` x) `c` y in (strictOrLazy 1 2 ($), strictOrLazy 3 4 ($!))
11:10:05 <lambdabot>    Expecting a function type, but found `t_a1Up'
11:10:05 <lambdabot>    Expected type: (a ->...
11:10:37 <kpreid> ok, why didn't that work?
11:10:41 <xerox> ?yow
11:11:00 <lambdabot> Is this the line for the latest whimsical YUGOSLAVIAN drama which also
11:11:02 <lambdabot> makes you want to CRY and reconsider the VIETNAM WAR?
11:11:14 <Cale> okay, hopefully http://cale.yi.org/index.php/Fold_Diagrams should work now
11:11:34 <Saizan> yes, it works, thanks
11:11:40 <xerox> Ciao Saizan (:
11:11:46 <lambdabot> Title: Fold Diagrams - CaleWiki
11:11:47 <metaperl> Cale - is that long-haired person you?
11:11:52 <Binkley> metaperl: well, you don't *have* to use either foldl or foldl'
11:11:53 <Cale> (somehow my router managed to ignore the explicit MAC-IP mapping for my machine)
11:11:53 <metaperl> in the upper left corner?
11:11:54 <mauke> @where tutorial
11:11:59 <Cale> metaperl: yes :)
11:12:23 <Cpudan80> > tutorial
11:12:28 <Cpudan80> nope...
11:12:32 <lambdabot> http://www.haskell.org/tutorial/
11:12:33 <metaperl> Cale - you look like a well-rounded person. I never thought anyone could be on IRC as much as you and look that good
11:12:37 <Cpudan80> !tutorial
11:12:47 <Cale> hehe
11:12:47 <Saizan> ?where yahc
11:12:49 <xerox> huh
11:12:54 <lambdabot>  Not in scope: `tutorial'
11:13:00 <mauke> haha, wow
11:13:11 <xerox> lies!
11:13:15 <mauke> why is haskell.org/tutorial/ the Gentle Introduction?
11:13:20 <lambdabot> I know nothing about yahc.
11:13:26 <Cale> mauke: good question :)
11:13:35 <Cale> It's only gentle if you're coming from ML :)
11:13:41 <Binkley> ?remember metaperl I never thought anyone could be on IRC as much as you and look that good
11:15:48 <complaisant> hi. anyone can give me a light about how to use the Language.Haskell.Syntax HsDecl type built with HsFunBind ?
11:16:09 <Cpudan80> Hmm sorry about that
11:16:11 <Cpudan80> My client quit
11:16:25 <Cpudan80> But - I got the tutorial link - thanks to whoever sent it to me
11:16:43 <wy> Oh, I hate indentation so much! Copied from the tutorial, but the code doesn't work.
11:16:55 <Cale> wy: which indentation?
11:17:00 <Cale> lisppaste2: url
11:17:01 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:17:06 <wy> Cale: grouping by indentation is evil...
11:17:06 <mauke> Cpudan80: http://www.haskell.org/haskellwiki/Learning_Haskell
11:17:09 <lambdabot> Title: Learning Haskell - HaskellWiki, http://tinyurl.com/gg7z2
11:17:19 <Cale> wy: the basic idea is to line up things which are at the same level
11:17:33 <Cale> and if something is part of something else, then it gets indented more
11:17:43 <Cale> do x <- y
11:17:43 <mauke> except for "if then else" in monads :/
11:17:50 <Cale> huh?
11:18:01 <wy> yes. I'm doing do <- ...
11:18:07 <Cale> you want to line the following line of the do up with the x
11:18:09 <mauke> you can't have "else" at the same level as "if" in a do-block
11:18:14 <Cale> mauke: of course not
11:18:18 <LPhas> anyone knows how to set emacs to load haskell mode for .hsc files?
11:18:22 <Cale> it's inside the if, you indent it more
11:18:27 <Cale> if foo
11:18:30 <Cale>   then bar
11:18:33 <Cale>   else quux
11:18:37 <mauke> Cale: to me it's part of the if
11:18:39 <wy> http://paste.lisp.org/display/30804
11:18:47 <Cale> mauke: right, so you indent it more
11:18:56 <mauke> if foo then do
11:18:58 <mauke>   bar
11:18:59 <mauke> else do
11:19:01 <mauke>   quux
11:19:44 <mauke> wy: rule of thumb: start a new line after each do/where
11:20:04 <metaperl> Cale - the foldl f z diagram ... shouldnt the arrow from the data structure to the call tree point at f z 1  since that is where evaluation starts?
11:20:06 <wy> I'm wondering how can the meta language of haskell do the job with all the indentations
11:20:20 <Cale> http://paste.lisp.org/display/30804#1
11:20:47 <complaisant> ?: anyone can give me a light about how to use the Language.Haskell.Syntax HsDecl type built with HsFunBind?
11:20:47 <lambdabot> Maybe you meant: . v
11:20:56 <Cale> metaperl: It's showing the result of the call.
11:21:16 <Cale> metaperl: that is, the result after foldl has done all its work
11:21:33 <metaperl> hmmm
11:22:06 <Cale> metaperl: after the foldl, you still have to evaluate all the f's and that's the order in which it will happen
11:22:13 <Cpudan80> Would this be a valid statement in haskell?
11:22:19 <Cpudan80> simplify x+0 = 0+x = x
11:22:24 <Cpudan80> y/n?
11:22:26 <mauke> wy: http://paste.lisp.org/display/30804#2
11:22:35 <mauke> Cpudan80: no, too many ='s
11:22:41 <Cale> wy, mauke: have a look at my paste
11:23:02 <Cale> ah, mauke has already seen it at least
11:23:04 <Cpudan80> mauke: So if I split that into two cases -- simplify x+0 = x and simplify 0+x = x?
11:23:15 <Cale> but I really don't like that indentation style
11:23:23 <wy> Cale: Thank you. It works. I'm figuring out the difference
11:23:32 <wy> mauke: Thanks :)
11:23:36 <mauke> Cpudan80: still fails because of precedence. and it doesn't make sense ...
11:23:38 <Cale> at least indent the l <- getLine and return (c:l) a little more in mauke's version
11:23:54 <Cale> because they're part of the do on the previous line, not the surrounding do
11:24:07 <Cpudan80> mauke: Ok - I guess I will have to do some more reading :)
11:24:07 <mauke> Cale: this style is very useful in the code I'm currently writing
11:24:18 <Cale> mauke: does that actually parse?
11:24:28 <mauke> sec
11:24:31 <Cale> I'd be surprised actually.
11:24:41 <wy> Cale: I think indentations cost more space. Isn't it?
11:24:48 <Cale> wy: huh?
11:24:55 <Cale> wy: more space?
11:25:14 <wy> because each blank space is a byte
11:25:19 <Cale> who cares?
11:25:33 <mauke> Cale: http://rafb.net/paste/results/Y4yPv271.html -- parses and compiles
11:25:46 <Cale> Does anyone use 300k floppies anymore?
11:26:00 <Ugarte> Presumably because you want your source code to be smaller by a few bytes? :P
11:26:08 <Cale> The amount of space taken by source code files is trivial.
11:26:29 <mauke> wy: surprise, { ; } also are a byte each
11:26:36 <Cale> mauke: I find that really hard to read
11:27:02 <mauke> Cale: why, it's almost like C :-)
11:27:11 <wy> Cale: But I find indentation grouping not hard to read, it's impossible to read...
11:27:11 <Saizan> that's why :D
11:27:12 <Cale> lining things up which aren't on the same level is confusing
11:27:15 <complaisant> hi. anyone can give me a light about how to use the Language.Haskell.Syntax HsDecl type built with HsFunBind ?
11:27:46 <Cale> complaisant: no idea :) I could look at the documentation...
11:27:47 <mauke> Cale: that sounds like "using infix notation with different levels of precedence is confusing"
11:28:03 <Cale> mauke: no, it's rather like "no indentation is a bad idea"
11:28:10 <Cale> only a little more specific
11:28:16 <mauke> no, this is specifically about tail nesting
11:28:29 <mauke> and one of the reasons why I don't like lisp: )))))
11:29:04 <kpreid> Cpudan80: this makes sense: "simplify (x :+ 0) = x"
11:29:18 <kpreid> Cpudan80: provided you have a declaration for the constructor :+
11:29:39 <mauke> the non-increased indentation from line 10 to 11 tells me that the 'then return (r, p)' branch is a logical end of the function
11:29:44 <Cale> It's just that in order to parse what you've written, I need to notice that there's an if-then-else construct there with a do in the else about half-way through the block, or else I'll mistakenly think that it's all going to run unconditionally.
11:29:46 <Igloo> complaisant: Use it to do what?
11:30:42 <mauke> Cale: similar to 'return' in the middle of a block in C
11:30:42 <Cpudan80> kpreid: ehh ok
11:30:46 <Cale> Indenting the 'then' and 'else' parts makes it obvious that there's a branch going on, and that different code will run based on some condition
11:30:55 <mauke> which is exactly what I'm trying to emulate here
11:30:58 <complaisant> to read a haskell program & convert it to point-free or point-wise ..
11:31:05 <Cale> mauke: right, which I also consider to be a bad idea :)
11:31:23 <complaisant> so i need to use that type do read & show
11:31:26 <Cale> (well, C affords you few choices, so it's a little unfair)
11:31:38 <Excedrin> is there a Haskell style guide somewhere? (preferably not "Just use Emacs")
11:31:48 <mauke> Cale: indenting 'then' and 'else' introduces two more levels of indentation if you also indent the do block
11:31:49 <complaisant> -.- sounsd a little bit complicated
11:31:53 <pejo> Cale, goto. :-)
11:31:59 <Cale> pejo: right
11:32:13 <Cale> mauke: so?
11:32:17 <Cpudan80> infixl 5 :+
11:32:24 <mauke> Cale: it's ugly
11:32:25 <kpreid> complaisant: http://www.cse.unsw.edu.au/~dons/code/lambdabot/Lib/Pointful.hs
11:32:27 <lambdabot> http://tinyurl.com/ykpjqd
11:32:29 <Cpudan80> that basically defines the :+ correct?
11:32:37 <Cale> mauke: if indentation becomes a problem, perhaps you should be writing smaller functions?
11:32:43 <kpreid> Cpudan80: it defines how to parse it, but not what it means
11:32:55 <mauke> heh, I think 10 lines is small enough
11:33:10 <kpreid> complaisant: Pointful.hs (which I wrote) uses those data structures, and possibly also does the latter part of what you want
11:33:13 <Cpudan80> kpreid: hmm ok
11:33:21 <Cale> Yeah, and in 10 lines, you're not going to get more than a few levels of indentation, if you're doing things in a sane way
11:33:35 <Cale> lisppaste2: url
11:33:35 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:33:43 <mauke> so I could just omit them as they don't add any readability
11:34:05 <complaisant> kpreid : tnks i'll take a look at it
11:34:40 <wolverian> is there a generic method to make ghc tell me which expression in a function exactly causes a typeclass restriction to be found on a parameter?
11:36:28 <Cale> mauke: hm?
11:36:35 <Cale> mauke: but they do
11:36:43 <mauke> not for me
11:37:47 <wy> Cale: So you broke the line before "then". And it seems "if c == '\n'" must be at the same level as c <- getChar'
11:38:08 <Cale> wy: yes
11:38:23 <Cale> wy: the 'then' and 'else' are parts of the 'if', so they're indented more
11:38:24 <mauke> yes, the next non-white character after do/where sets the "current" indentation level
11:38:43 <SyntaxNinja> xerox: dcoutts: any progress merging the cabal-with-install branch?
11:38:58 <dcoutts> SyntaxNinja, I've not looked at it yet
11:39:04 <dcoutts> xerox, how about you ?
11:39:32 <wy> Cale: It seems the second line of do must be at the same level as c<- .... No more, no less.
11:39:46 <Cale> you can imagine a little grey line descending just to the left of c <- ... So long as code falls to the right of that line, it's inside the do-block.
11:40:16 <dcoutts> SyntaxNinja, I see you've been documenting more stuff, that's great. I know people have had some difficulty in getting to grips with the cabal code, module descriptions should help there.
11:40:31 <dcoutts> just to see how bits fit together etc
11:40:42 <lisppaste2> Cale pasted "indented" at http://paste.lisp.org/display/30806
11:40:46 <wy> Cale: But why doesn't it work if I indent a bit more after c <- ?
11:41:03 <SyntaxNinja> dcoutts: yeah, hope that'll help
11:41:10 <Cale> wy: because then it becomes part of the getChar'
11:41:29 <SyntaxNinja> dcoutts: although I honestly have trouble believing that there is any trouble with the code.  I still just think that reading other peoples' code is simply hard and people give up easily :)
11:41:39 <Cale> wy: If you indent a line more than the previous one, then it's as if the previous line continues there.
11:41:47 <dcoutts> SyntaxNinja, that's also true of course
11:41:55 <SyntaxNinja> dcoutts: plus LOTS of people have hacked on cabal, more than most libraries, and haven't heard any complaints from those who have written a lot.
11:42:09 <dcoutts> SyntaxNinja, indeed, it's self-selecting that way
11:42:30 <wy> Cale: That's so weird. Like a way to prevent people copying code around.
11:42:39 <Cale> wy: hm?
11:42:59 <dylan> it's easy copying do-notation code in vim, at least
11:43:05 <Cale> It's usually quite nice af far as keeping things readable.
11:43:11 <dylan> I imagine it's the same in any editor with block-copying
11:43:50 <Cale> anyway, if you're copying large sections, you really should make a function :)
11:43:50 <w-ber> If I already didn't have a girlfriend, Haskell would be my new loved one. I've been constantly thinking "but it can't be this easy!" while programming, but it really is.
11:44:03 <Cale> w-ber: awesome :)
11:44:09 <wy> Cale: Say if you have a big piece of code and you want to extract a little part out into another function. You have to re-indent it correctly. I think that's hard without a editor that can do column | square based cut&paste.
11:44:22 <Cale> wy: but most editors can
11:44:23 <w-ber> Cale: Sorry, out-of-the-blue comment. :)
11:44:36 <mauke> wy: I just copy lines, then reindent them all
11:44:44 <lispy> w-ber: heh
11:44:44 <Philippa> w-ber: heh, I just settled for meeting someone thanks to haskell
11:44:50 <Cale> w-ber: of course comments like that are welcome here -- that might even end up in the Haskell Weekly News
11:44:53 <wy> mauke: But the editor can't do it automatically for you
11:45:10 <Cale> (at least, if dons sees it :)
11:45:27 <mauke> wy: it's semiautomatic, I tell it how many levels to in-/dedent
11:45:42 <wy> I see this style prevents the editors from doing the clever thing, unless the editors knows the semantics
11:46:02 <wy> No. Only if the editors can read our mind.
11:46:08 <Philippa> yeah, but it doesn't need to be that clever
11:46:22 <Philippa> in practice the extra second getting enough key repeats in isn't that big a deal
11:46:33 <Cale> wy: Editors have a hard time with Haskell code anyway, what with operator precedence being definable inline :)
11:47:12 <Cale> but yeah, I just set vim to indent things the same amount as the previous line, and I have no problems
11:47:34 <Cale> Emacs has a "smart" indent mode, but I hate it.
11:47:56 <wy> Cale: Oh. I see... in this case no editor can be smart
11:47:57 <Cale> When I'm using Emacs, I set it to the simple Haskell indenter, and that's a lot more comfortable.
11:48:21 <lispy> Cale: ah, i'm reminded of Brian's suggested modifications :)
11:48:28 <Cale> lispy: haha
11:48:31 <wy> Is it haskell-indent-mode ?
11:48:36 <mauke> you could probably use { ; } everywhere and use a variant of C mode
11:48:48 <Philippa> yuck
11:49:02 <Philippa> layout's good partly because of the reduction in visual noise when you're parsing complex expressions
11:49:14 <Cale> wy: I think that's the 'smart' one
11:49:18 <Philippa> when there's so much info in a handful of lines, stuff like that's important
11:49:25 <mauke> Cale: btw, the non-indenting in my code is pretty much the same as in "module Foo where ..."
11:50:00 <Cale> mauke: Yeah, but there's only one module Foo where... per file (at least, the way things are currently set up). If there was more than one, I'd be indenting.
11:50:30 <Philippa> hrmm. If it were legit, I'd want explicit braces but layout-based semicolons
11:50:41 <wy> Cale: (add-hook 'haskell-mode-hook 'turn-on-haskell-simple-indent)
11:50:46 <Philippa> though I might still indent anyway
11:50:51 <Cale> wy: that sounds about right
11:51:15 <wy> Cale: Haha. It's strange I have also (add-hook 'haskell-mode-hook 'turn-on-haskell-indent) in my .emacs
11:51:21 <mauke> Cale: there's only one do per if :-)
11:51:32 <Cale> mauke: not really
11:51:40 <Cale> You have two branches there
11:51:53 <Cale> even if one is simple, there's logically two paths that the code could take
11:52:05 <Cale> and it's a courtesy to your readers to point that out
11:52:15 <mauke> exactly
11:52:27 <mauke> I'm telling them "one of the paths ends right here, don't bother looking for more"
11:52:44 <Cale> http://paste.lisp.org/display/30806 -- note how when I reindented your code, it became obvious at a glance what the termination condition was.
11:53:19 <Cale> (well, at least, as far as that can be locally determined :)
11:53:45 <Cpudan80> Ok question
11:53:48 <Cale> and also obvious that the thing doesn't just loop forever
11:53:53 <Cpudan80> How would one define this correctly?
11:53:59 <Cpudan80> x*1 = x
11:54:02 <Cpudan80> would it be...
11:54:03 <Cale> (which it initially looks like to me with your old indenting)
11:54:14 <wy> I guess putting a ; at the end of each line of "do" is a good idea.
11:54:16 <mauke> Cpudan80: huh? you don't define +, it's in the language
11:54:30 <Cale> Cpudan80: are you writing an instance of Num?
11:54:43 <Cpudan80> Ehh no - I am writing a simplification function
11:54:45 <Cpudan80> So like
11:54:49 <Cpudan80> x+0 = x
11:54:59 <mauke> step 1: make a datatype for expressions
11:55:04 <Cpudan80> Ok yeah got that
11:55:06 <mauke> a tree or something
11:55:10 <Cpudan80> yes yes ok
11:55:16 <wy> Cale: I added a ; to the end of the first line. So I only need to remember indent a little more after c<-
11:55:22 <Cale> simplify (Plus x 0) = x
11:55:40 <Cpudan80> Is Plus predefined?
11:55:46 <Cale> Cpudan80: no
11:55:53 <Cpudan80> err ok...
11:55:59 <Cale> wy: you can do that of course -- you can always use semicolons and braces if you're having trouble getting the indentation right
11:56:36 <Cale> Cpudan80: I'm assuming there's something similar in your datatype for expressions
11:56:48 <Cpudan80> Yes Add
11:56:50 <Cpudan80> and Sub
11:56:53 <Cpudan80> and Mul - etc
11:56:56 <Cpudan80> So - If I did
11:57:03 <lispy> wy: when i was new to haskell i fought with layout a lot...and used { ; } a fair bit...but eventually it becomes quite natural
11:57:05 <Cpudan80> simplify (Add x 0) = x
11:57:06 <ptolomy> Should I be surprised that gcc doesn't compile '*p -= 5; while( *p ) { *p -= 5; }' into the same code as 'do { *p -= 5; } while (*p);' ?
11:57:12 <Cpudan80> That should pass the tests
11:57:17 <Cpudan80> Cale: thanks for the pointers
11:57:48 <Cale> Cpudan80: depending on the design of your program, you might also want to do  simplify (Add x 0) = simplify x
11:57:56 <tibbe> Cale: you're a mathematician right?
11:58:04 <Cale> tibbe: sort of, yeah
11:58:16 <Cpudan80> Cale: hmm I'll have to see how it goes
11:58:17 <Cale> tibbe: I have a Bachelor's degree in pure mathematics
11:58:41 <lispy> it's like asking if someone is a hacker...real hackers are modest and know better hackers so they answer, "Well, I guess you could say that..."
11:59:11 <tibbe> Cale, do you have a couple of minutes to give some pointers on a proof sketch for a property on an NFA?
11:59:22 <Cale> tibbe: I'm already looking at it ;)
11:59:27 <tibbe> oh!
11:59:42 <wy> lispy: I guess you've experienced with Lisp
11:59:42 <tibbe> I know #math and #haskell where aliases ;)
11:59:46 <tibbe> knew*
12:00:02 <Cale> I'm going to have to refamiliarise myself with the formal definition of an NFA
12:00:32 <Syzygy-> tibbe: Not quite. They contain the same people (modulo college freshmen) but occasionally people care about who talks about what where.
12:00:45 <tibbe> Syzygy-: yes :)
12:01:03 <shapr> Syzygy-: btw, your nickname is awesome
12:01:23 <Cale> I tend to invite discussion of Haskell in #math, which is why there is so much migration :)
12:01:38 <Syzygy-> lispy: Speaking of layout, http://pozorvlak.livejournal.com has an amusing rant about starting Haskell, and gds+some others are turning it into neat discussion.
12:01:38 <Cale> (well, one reason :)
12:01:39 <tibbe> Cale: you want me to give more detail on anything please let me know, I'm not 100% sure it's a good model but it felt sound to me
12:01:45 <wy> lispy: I was used to Lisp. I'm taking a course which is using sml this semester so I started using it. It's appeared to me more natural than Haskell because it doesn't allow sequencing without ";"
12:01:46 <lispy> wy: yeah, i used to do a lot of lisp
12:01:55 <Syzygy-> Cale: You weren't responsible for me  though. :)
12:01:56 <tibbe> btw, what's pure mathematics?
12:01:56 * gds glances up ....
12:02:16 <Cale> tibbe: as opposed to applied mathematics
12:02:21 * dcoutts adds Hans & int-e to Gtk2Hs contributers list
12:02:25 <dcoutts> thanks chaps
12:02:27 <Syzygy-> shapr: It's a combination of 1) algebraic geometry, 2) the #math op crowd on EFNet and 3) nick collision with a guy on EFNet who uses Syzygy since YEARS back and actually asked nicely.
12:02:34 <SyntaxNinja> shapr: !
12:02:46 <shapr> SyntaxNinja: !
12:03:07 <shapr> Syzygy-: I mean more that syzygy is a great word to choose for a nickname.
12:03:23 <Syzygy-> Oh, and also, a handwriting style that makes the word syzygy be a looooong sequence of extending loops. Calligraphy on the word is gorgeous.
12:03:37 <lispy> Syzygy-: hehe, "Scientific papers are not an acceptable form of documentation. They're barely an acceptable way of doing science.
12:03:38 <lispy> "
12:03:41 <shapr> dcoutts: I had something I needed to ask you, I wonder what it was...
12:03:52 * dcoutts grins
12:04:01 <Syzygy-> lispy: I like the debate. I'm michiexile there btw.
12:04:03 <lispy> shapr: good morning
12:04:04 <Cpudan80> Cale: Should that be this ---> simplify (x (Num 0)) = x?
12:04:10 <Cpudan80> It said I needed Num
12:04:12 <tibbe> Syzygy-: what debate?
12:04:25 <Syzygy-> tibbe: Check the latest post on http://pozorvlak.livejournal.com
12:04:28 <wy> lispy: One thing I feel good about Lisp is the syntax, which means there is almost no syntax.
12:04:34 <Cale> Cpudan80: simplify (Add x (Num 0)) = x
12:04:36 <mauke> Cpudan80: missing type constructor, I think
12:04:44 <shapr> lispy: good morning!
12:04:45 <Cale> data constructor
12:04:46 <Cpudan80> Cale: Thought so - thank you
12:04:55 <Cpudan80> Sorry for the newb ?s
12:05:06 <Cale> tibbe: hmm
12:05:07 <mauke> er, yeah
12:05:11 <lispy> wy: i would agree.  But I mostly stopped using lisp when i found haskell.  It's just better in most ways.
12:05:12 <Syzygy-> Cpudan80: Your not being noisy, and people here are helpful as a default mode. :)
12:05:25 <Cpudan80> Hey I'm trying to learn
12:05:28 * Syzygy- thinks about some of the people DEMANDING help in loud voices on #maths...
12:05:28 <shapr> good!
12:05:30 <Cale> tibbe: that might be a reasonable way to structure things
12:05:33 <Cpudan80> I've seen some people come into channels and paste teh assignment
12:05:38 <Cpudan80> And say "Will someone do it?"
12:05:39 <mauke> @keal
12:05:40 <lambdabot> 99% of my book has been erased by faulty hdd's
12:05:43 <Cpudan80> lol
12:05:43 <lispy> wy: pattern matching + strong typing/type inference + laziness is really nice
12:05:45 <shapr> Syzygy-: Those people drop by on #haskell just after that and demand to be unbanned
12:06:12 <Syzygy-> Cpudan80: Yup. Those are kinda the people I bait for a while and then kickban for being idiots once they blow up completely. Either that or tell of for being idiots.
12:06:21 <Cale> shapr: actually, those aren't even the ones which we ban
12:06:21 <Syzygy-> Though ... I don't have op on #math@freenode.
12:06:24 <Cpudan80> lol
12:06:24 <Syzygy-> Maybe just as well.
12:06:27 <shapr> Cale: oh
12:06:40 <wy> lispy: Yes. The most serious problem with Lisp is types. It's usually late to find errors.
12:06:42 <Syzygy-> shapr: Do you get EFNet exiles in here??? *boggle*
12:06:43 <lispy> those sort of people get solutions involving gratuitus uses of "fix" ;)
12:06:46 <Cale> shapr: It's the ones which are much worse that get banned (crapflooders, trolls)
12:07:05 <shapr> Cale: yow!
12:07:28 <Cale> and they still have the gall to come and ask to be unbanned after that
12:07:29 <shapr> Syzygy-: Not really. I could claim that I'm an EFNet exile from way back. I got kickbanned from #perl
12:07:34 <lispy> wy: and as it has a problem python has.  If you work in the interactive mode for a while developing your source, you may have functions which exist in memory but didn't make it into your file.  So the next time you load up your source it's broken...
12:07:47 <Heffalump> shapr: what did you do?
12:07:53 <tibbe> Cale: so for the proof I was thinking of something along the lines of: for all strings s: delta*(s) = (q, EmptySet) for some q among the final states
12:07:53 <Syzygy-> shapr: I can only speak for EFNet, but there, if you're banned, there's a very high chance that you - or someone with the same ident and similar enough ip - was either trolling heavily or spambotting of flooding.
12:08:00 <shapr> Heffalump: I asked for an editor with syntax highlighting.
12:08:05 <lispy> wy: ghci and hugs do not have this problem because they start fresh whenever you reload the file
12:08:14 <tibbe> Cale: i.e. that's what I would like to be able to prove for a given NFA (or disprove)
12:08:27 <Syzygy-> Most other idiots end up getting timed bans, or at least not botlisted => their bans lift after a while.
12:08:44 <Cale> tibbe: that seems reasonable -- of course, you'll have to use the actual structure of the individual NFA in order to do it
12:09:05 <Syzygy-> shapr: You get _banned_ for asking about syntax highlighting editors?!?!
12:09:13 <wy> lispy: That seems not a problem to me. I always write the code into a file first and evaluate with C-x C-e
12:09:16 * Syzygy- gets the itch to get banned from #perl now. :P
12:09:36 <mauke> current topic says: Not a helpdesk; no CGI/Web/FAQ/MySQL/PCRE/Net::IRC/dumbassery/WINE LIP - #perldoc/google/#perlhelp
12:09:41 <wy> lispy: I need to adjust the file at the end though
12:09:48 <lispy> wy: yes, but if you rename something and forget to change it in all places you can still get the problem
12:10:01 <mauke> I guess editor falls under FAQ
12:10:18 <Cale> shapr: how many editors fell under that category when you asked the question?
12:10:19 <tibbe> Cale: but that would be the requirement for the proof? the only one needed right?
12:10:37 <syntaxfree> a simple Haskell doubt.
12:10:37 <Cale> It would seem to me that almost any editor would have basic syntax highlighting for perl
12:10:41 <syntaxfree> er, Parsec doubt.
12:10:51 <syntaxfree> What is the "not" combinator for parsers?
12:11:06 <syntaxfree> or "zero" combinator, whatever.
12:11:08 <Cpudan80> Hmm ok - maybe I am missing something
12:11:10 <Cpudan80> simplify (Add x (Num 0)) = x
12:11:22 <Cale> syntaxfree: notFollowedBy?
12:11:23 <Cpudan80> It says "Instance of Num required for defn of simplify"
12:11:28 <eviltwin_b> you'd be surprised; it's rather hard to get even simple syntax highlighting right for perl if here documents or //x are in use
12:11:37 <Cpudan80> Did I miss something in there?
12:11:40 <kpreid> Cpudan80: it's talking about the builtin typeclass Num.
12:11:43 <lispy> Cpudan80: "Num" is not a constructor it's a type class
12:11:45 <syntaxfree> Num is a type-class.
12:11:59 <Syzygy-> eviltwin_b: Couldn't be that hard. Just make your editor have a complete perl parser built in. ;)
12:12:09 * eviltwin_b rolls his eyes
12:12:14 <syntaxfree> Cale: uh. let's say I have a parser "hash = char '#'"
12:12:15 <Cale> Cpudan80: I don't know what your file looks like, so I don't know
12:12:20 <mauke> Syzygy-: a complete perl parser must be a complete perl interpreter
12:12:27 <syntaxfree> Now I want a parser that recognizes any character but "#".
12:12:30 <Cpudan80> Cale: Hang on and I'll pastebin it
12:12:31 <eviltwin_b> although it would be kinda need to use the B modules to output the AST and use that to do highlighting :>
12:12:31 <tibbe> Cale: how would one write a delta for one transition of an NFA: delta(q, a, T) = (q', T \ {somesymbol}) for some values of q, a and T?
12:12:31 <Syzygy-> mauke: Sure. I'm game for that. :)
12:12:35 <syntaxfree> I know there's a parser combinator for that, but still.
12:12:59 <Syzygy-> syntaxfree: Doesn't that parser immediately recognize # as well, by yielding '#' as the only thing raising some sort of parse failure? ;)
12:13:01 <tibbe> Cale: I'm not 100% sure how to express the add and removes state, union and set minues?
12:13:13 <mauke> Syzygy-: yeah, I want my editor to run parts of my code while I type it
12:13:21 <Syzygy-> Yeah?
12:13:28 <syntaxfree> Syzygy: yes, if I'm willing to use the output of "parse". I wish I could do it inside the parser monad though.
12:13:30 <Syzygy-> I'm sure you wouldn't do anything hazardous, right?
12:13:53 <Philippa> syntaxfree: do you want it for chars or multi-char things?
12:13:58 <Cpudan80> Cale: Ok - here goes - don't laugh http://pastebin.ca/259833
12:14:00 <syntaxfree> multi-char things.
12:14:00 <Cale> tibbe: sure. In general, your transition functions change T completely, which might be a little tricky to work with.
12:14:10 <Philippa> okay. You realise it can't consume, right?
12:14:17 <shapr> Syzygy-: Yes, I got kickbanned for asking for an editor with syntax highlighting.
12:14:23 <tibbe> Cale: can you see a better way of expressing it?
12:14:39 <shapr> Cale: emacs must have been in that category, but #perl's response was "Real mean don't need colored text."
12:14:44 <syntaxfree> therefore, I need "try".
12:14:55 <Syzygy-> shapr: *boggle*
12:15:03 <tibbe> Cale: I'm also thinking of what would happen in a loop that starts more and more timers, sets only allow one of each element. But I'm not sure how to do it with a sequence.
12:15:05 <Philippa> heh. Shame it hadn't been me asking then
12:15:14 <lisppaste2> syntaxfree pasted "I want a parser that recognizes non-comment things from these two parsers:" at http://paste.lisp.org/display/30812
12:15:29 <shapr> Syzygy-: So I learned Python instead of Perl
12:15:30 <Cale> Cpudan80: it's that last line
12:15:43 <Cale> Cpudan80: you need to return an Expr, but you have 0 there
12:15:48 <mauke> Syzygy-: like loading modules?
12:15:58 <tibbe> Cale: I was thinking that I might do what's done with a push-down automaton a have a stack of running timers, although the pushing and popping isn't exactly what I want
12:16:03 <Cpudan80> Cale: Oh I see
12:16:07 <Cpudan80> Hmm
12:16:09 <wy> What does the "a" in "ioError :: IOError -> IO a" mean?
12:16:14 <Cale> Cpudan80: also, put the type signature for simplify closer to the implementation :)
12:16:22 <lispy> ?type ioError
12:16:23 <lambdabot> forall a. IOError -> IO a
12:16:29 <Cale> wy: It means any type whatsoever
12:16:35 <Cpudan80> Cale: So how can I make 0 into an expression I wonder?
12:16:37 <syntaxfree> wy: IO is a polymorphic type.
12:16:42 <Cpudan80> Expr 0 lol?
12:16:46 <lispy> Cpudan80: sure, (Num 0) ?
12:16:48 <syntaxfree> @google haskell parametric polymorphism
12:16:48 <wy> Cale: But it's not bound. Isn't it?
12:16:53 <Cpudan80> ohh
12:16:54 <lambdabot> http://en.wikipedia.org/wiki/Polymorphism_(computer_science)
12:16:56 <Cpudan80> ok
12:16:58 <Cpudan80> thanks
12:16:58 <Cale> Cpudan80: well, look through the data constructors of Expr -- you have Num
12:17:02 <Cpudan80> let me see how that goes
12:17:12 <Cpudan80> yeah I see that
12:17:14 <Syzygy-> Time to pop afk again. *wavers*
12:17:16 <Cpudan80> That would work
12:17:21 <Cpudan80> my brain is not in the right place today
12:17:29 <Cpudan80> Too much turkey last week
12:17:31 <Cale> wy: It never returns, so it doesn't matter what type it is.
12:18:05 <Cale> @type undefined
12:18:07 <lambdabot> forall a. a
12:18:13 <Cpudan80> So I guess I need to put in the opposite cases too right?
12:18:15 <Cpudan80> like ehh
12:18:17 <lispy> ?type undefined :: Int
12:18:19 <lambdabot> Int :: Int
12:18:19 <wy> Cale: I get the hint.. that "a" will be unified with other types!
12:18:20 <Cpudan80> 0+x && x + 0
12:18:21 <Cale> > head [1,2,undefined]
12:18:23 <lambdabot>  1
12:18:30 <Cale> > head ["Hello","World",undefined]
12:18:30 <Cpudan80> in order for it to work correctly...
12:18:31 <Cpudan80> yeah
12:18:31 <lambdabot>  "Hello"
12:18:35 <lispy> > length [undefined]
12:18:36 <lambdabot>  1
12:19:09 <lispy> > length (replicate 10 undefined)
12:19:10 <lambdabot>  10
12:19:51 <Cale> wy: yeah, at least usually -- and the fact that it's so polymorphic is a hint that it's undefined
12:20:34 <Cale> the only values of type  (forall a. a)  are errors and infinite loops.
12:20:54 <lispy> ?type let x = x in x
12:20:55 <lambdabot> forall t. t
12:21:02 <lispy> > let x = x in x
12:21:03 <lambdabot>  Add a type signature
12:21:07 <lispy> > let x = x in x :: Int
12:21:09 <lambdabot>  Exception: <<loop>>
12:21:22 <lispy> and ghc can even find infinite loops in some cases
12:21:22 <tibbe> Cale: is there a math mailing list where I could post my problem to get some ideas of different possible representations?
12:21:46 <Cale> tibbe: one representation would be to have two sets on every transition
12:21:48 <wy> Why can lambdabot find the loops?
12:21:55 <Cale> tibbe: a set of adds and a set of removals
12:21:58 <Cpudan80> Is show a predefined function?
12:22:00 <Cpudan80> like ehh
12:22:04 <lispy> wy: because of how the evaluator works
12:22:06 <Cpudan80> show n (n is Num)
12:22:22 <lispy> wy: there is a paper which describes the mechanics if you are really interested
12:22:26 <Cale> which would be simpler than an arbitrary set function which might behave differently depending on what's already there
12:22:28 <wy> lispy: but my ghc goes into infinite loop
12:22:31 <lispy> ?google spinless tagless g-machine
12:22:33 <lambdabot> http://tunes.org/~nef/logs/haskell/06.06.23
12:22:38 <Cale> I think that would be a bit easier to work with, proof-wise
12:22:41 <lispy> heh, that's not right link
12:22:45 <tibbe> Cale: that was my original idea, then do set minus to end up with empty set
12:22:53 <Cale> ?google spineless tagless g-machine
12:22:55 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
12:22:59 <lispy> wy: what version of ghc are you using/
12:23:10 <Cale> spinless sounds like something from physics :)
12:23:18 <lispy> ah, heh
12:23:25 <tibbe> Cale: but I didn't know if I'd write that as (Q, T, T) or (Q, T x T) so i moved to one set ;)
12:23:31 <wy> lispy: 6.4.1
12:23:37 <tibbe> Cale: reminds me of politicians more ;)
12:23:48 <mauke> Cpudan80: yes, but only for instances of Show
12:23:57 <Cpudan80> ?
12:24:02 <Cpudan80> so capital S?
12:24:05 <lispy> wy: basically when ghc evaluates something it marks the state as it enters the thunk...and if it comes back to the same state it knows it has an infinite loop
12:24:13 <mauke> Cpudan80: add "    deriving Show" as the last line of your data Expr definition
12:24:33 <tibbe> Cale: but I want (Q, T, T) right becuase T x T is a set of tuples?
12:24:53 <Cpudan80> mauke: hmm ok -- that code was supposed to work (it was given to me)......
12:25:05 <Cale> tibbe: okay, so you have A: (Q, Sigma) -> 2^T, and R: (Q,Sigma) -> 2^T
12:25:25 <wy> lispy: That's really clever. The spineless tagless G-machine?
12:25:28 <mauke> Cpudan80: and it used show without mentioning Show in the type definition?!
12:25:32 <tibbe> Cale: 2^T ?
12:25:34 <Cale> with the requirement that A(q,s) intersect R(q,s) is empty for all q, s
12:25:37 <Cpudan80> mauke: Yes
12:25:39 <Cale> tibbe: powerset
12:25:42 <mauke> that's weird
12:25:46 <Cpudan80> Here's teh whole code (4 lines)
12:25:55 <wy> lispy: Maybe my ghc is a bit old. It comes with Ubuntu
12:26:02 <Cpudan80> formatExpr (Num n) = show n
12:26:02 <lispy> wy: most haskell implementations view your program as a graph, a sort of function call graph, and the way that graph is reduced gives you lazy evaluation (hence the name g-machine)
12:26:03 <Cpudan80> formatExpr (Var x) = x
12:26:05 <Cpudan80> formatExpr (Add a b) =
12:26:07 <Cpudan80>     "(" ++ formatExpr a ++ " + " ++ formatExpr b ++ ")"
12:26:15 <Cpudan80> it had some more lines for multiply and subtract
12:26:20 <mauke> Cpudan80: oh, that's ok
12:26:20 <Cpudan80> but I took those out
12:26:23 <lispy> wy: it seems like that loop detection was turned off for a while, but i could be wrong
12:26:29 <Cpudan80> mauke: It is?
12:26:34 <mauke> Cpudan80: that calls Int's show, not Expr's
12:26:44 <tibbe> Cale: I'm not sure that I follow.
12:27:21 <glguy> ?version
12:27:22 <lambdabot> lambdabot 4p282, GHC 6.5 (OpenBSD i386)
12:27:22 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:27:32 <lispy> wy: i forget what spineless refers to and tagless in related to boxing values, iirc
12:27:49 <glguy> ugh, I have to connect through Tor again =/ my remote server I usually use is down
12:27:55 <Cpudan80> mauke: Yeah - my thing says "cannot find show function for <expression thing>
12:28:16 <wy> lispy: should I use an option argument on ghc?
12:28:18 <Cale> tibbe: Well, the idea is that A(q,s) is the set of timers added by the transition from state q upon reading s
12:28:23 <mauke> Cpudan80: are you running it in ghci?
12:28:24 <Saizan> 2^T should be the set of all the subsets of T, isn't it?
12:28:30 <Cale> Saizan: exactly
12:28:30 <Cpudan80> mauke: ghci?
12:28:33 <Cpudan80> no - hugs
12:28:37 <lispy> wy: not sure i follow
12:28:48 <Cpudan80> so if I add | deriving show to the list?
12:28:48 <tibbe> Cale: ok
12:28:55 <Cpudan80> capital S
12:28:56 <Saizan> never seen written like this, tough..
12:29:15 <Cale> tibbe: respectively, R(q,s) is the set of things to remove
12:29:24 <mauke> Cpudan80: what expression triggers that error?
12:29:26 <tibbe> Cale: and they might not overlap, get it
12:29:50 <Cpudan80> mauke: The error is: ERROR - Cannot find "show" function for:
12:29:51 <Cpudan80> *** Expression : simplify (Add (Add (Var "y") (Num 3)) (Num 0))
12:29:53 <Cpudan80> *** Of type    : Expr
12:30:00 <wy> lispy: maybe my ghc is too old.
12:30:08 <wy> I'm compiling a new one
12:30:09 <Cpudan80> so its trying to do y+3 + 0
12:30:16 <Cpudan80> it cant show it I guess
12:30:30 <mauke> Cpudan80: ah, that's because you're trying to print the result of an expression of type Expr
12:30:47 <Cpudan80> right...
12:30:48 <glguy> Does anyone know off hand how to make mIRC color people's nicks?
12:30:53 <mauke> yeah, hugs uses "show" internally to stringify/print values
12:31:03 <wy> lispy: Do you have some source for introduction to these abstract machines ? I'm interested in that
12:31:08 <Cale> Cpudan80: just add "deriving Show" to your data declaration
12:31:11 <Cpudan80> mauke: So I need that line
12:31:13 <Cpudan80> ok
12:31:14 <lisppaste2> syntaxfree pasted "still doesn't work" at http://paste.lisp.org/display/30813
12:31:15 <Cpudan80> thanks
12:31:26 <Saizan> glguy: you need a script/addon for that
12:31:32 <lispy> wy: just that link cale posted
12:31:46 <lispy> wy: http://citeseer.ist.psu.edu/peytonjones92implementing.html
12:31:48 <lambdabot> http://tinyurl.com/geuhe
12:32:04 <tibbe> Cale, and delta : (Q, Sigma) -> (Q, T, T) ? condition for proof, the difference between those Ts (how do I write that? how can I refer to them) is the empty set?
12:32:05 <lispy> wy: but i don't think that discusses the graph reduction at all
12:32:21 <lispy> Cale: do you know a paper that discusses the evaluation strategies that are commonly implemented?
12:32:21 <mauke> :t fromJust
12:32:21 <Cale> tibbe: delta will be the same as usual
12:32:29 <vincenz> http://notvincenz.blogspot.com/2006/11/continuations.html
12:32:31 <lambdabot> http://tinyurl.com/ydk6wx
12:32:33 <vincenz> for your reading pleasure :)
12:32:56 <Excedrin> wy: http://research.microsoft.com/Users/simonpj/Papers/pj-lester-book/
12:32:58 <lambdabot> Title: Simon Peyton Jones: book, http://tinyurl.com/y6d7fu
12:32:59 <lispy> we really need to get ":t" to be an alias for "@type"
12:33:38 <Cpudan80> Cale: mauke -- it works like a champ now! Thanks!
12:33:45 <tibbe> Cale: right so A and R adds as "new deltas" and I express my proof in terms of them
12:33:50 * Cpudan80 makes some notes about deriving Show :)
12:33:59 <Cale> tibbe: yeah
12:34:00 <mauke> lispy: that was a term-o, actually
12:34:15 <mauke> I had ghci running in another screen window
12:34:21 <Cale> tibbe: also note that if you wanted to add those to delta directly
12:34:24 <wy> Excedrin: that's really great!
12:34:39 <Cale> it wouldn't be Q x Sigma -> (Q, T, T)
12:34:41 <Cale> but
12:34:44 <wy> lispy: I got the paper. Thank you!
12:34:47 <Cale> Q x Sigma -> (Q, 2^T, 2^T)
12:35:01 <Cale> because you're talking about adding and removing sets of timers
12:35:02 <lispy> mauke: yeah, but everyone who uses ghci has done that on accident at some point in here :)
12:35:07 <lispy> wy: you're welcome
12:35:20 <Cale> (formally, 2^T is the set of functions from T to 2 = {0,1}
12:35:21 <Cale> )
12:35:59 <wy> lispy: what type of work do you do with Haskell?
12:36:21 <tibbe> Cale: I'm a bit unsure of when to use x and () respectively in the function domain and codomain
12:36:42 <lispy> wy: mostly hobby/school when i use haskell.  I was using it at work for a bit, but it wasn't popular with my managers
12:37:00 <Cale> tibbe: Oh, I really shouldn't be using (,,)
12:37:18 <Cale> that's just the Haskell part of my brain interfering
12:37:24 <tibbe> Cale: so proof condition: A(q_0, s) \setminus R(q_0, s) = EmptySet for all string s
12:37:28 <Cale> Q x Sigma -> Q x 2^T x 2^T
12:37:29 <lispy> wy: i like to contribute to darcs when i have time, but lately i've done nothing on that front
12:37:40 <tibbe> Cale: that's my problem too ;)
12:37:44 <lispy> wy: and i should be at work now :)
12:38:25 <Cale> tibbe: well, you have to be a little more careful
12:38:45 <tibbe> Cale: about same timer started twice?
12:38:59 <Cale> tibbe: A(q,s) is just the set of things added when you read the single symbol s, and are in state q
12:39:12 <Cale> oh, that's another concern, can they do that?
12:39:26 <tibbe> I was thinking of having A* defined like delta*
12:39:29 <tibbe> ie on strings
12:39:34 <wy> lispy: I want to make a language that looks perfect to me and then write intelligent programs with it
12:39:50 <tibbe> Cale: they shouldn't do that, lets assume they dont for now
12:40:02 <tibbe> Cale: because then we would need multisets
12:40:05 <Cpudan80> Cale: ok - so I got this mostly working
12:40:08 <Cpudan80> except it fails at
12:40:11 <Cpudan80> simplify (Add (Mul (Var "x") (Num 0)) (Add (Var "y") (Num 3))))
12:40:21 <Cpudan80> there is an extra ) in there - but anyway
12:40:28 <vincenz> Cpudan80: what's this for?
12:40:28 <Cpudan80> I wonder why...
12:40:39 <Cpudan80> An algebraic simplifier thingy
12:40:42 <kpreid> Cpudan80: what kind of "fails"? doesn't simplify?
12:40:45 <lispy> wy: that's ambitious :)
12:40:48 <Cpudan80> It says
12:40:56 <lispy> wy: so are you a language or ai student mostly?
12:41:01 <Cpudan80> simplify (Expr_Add (Expr_Mul (Expr_Var "x") (Expr_Num (Num_fromInt instNum_v28 0))) (Expr_Add (Expr_Var "y") (Expr_Num (Num_fromInt instNum_v28 3))))}
12:41:12 <Cpudan80> It works for all the other cases
12:41:16 <Cpudan80> back to the code :)
12:41:34 <kpreid> you left out some important part of the error
12:42:44 <Cale> tibbe: okay, so you have that A*(q, epsilon) = empty, A*(q, Ss) = (A*(q,S) \ R(delta*(q,S),s)) union A(delta*(q,S),s)
12:42:54 <Cpudan80> kpreid: Thats all it says
12:42:59 <Cpudan80> Program error is in front of that
12:43:03 <Cpudan80> I think I can fix it though
12:43:13 <Cale> Where s is a symbol, S is a string, and Ss is their concatenation
12:43:26 <mauke> Cpudan80: maybe you should get ghc
12:43:46 <Cpudan80> mauke: ok - I'll look at that
12:43:54 <Cale> tibbe: does that make sense with your way of thinking about it?
12:43:57 <Cpudan80> mauke: I think I need to add "simplify x" to my returns
12:43:59 <Cale> and you can define
12:44:09 <kpreid> Cpudan80: Oh. It probably means that you have no case in your function for that set of arguments.
12:44:09 <Cpudan80> so that way it simplifies each piece all the way down
12:44:11 <tibbe> Cale: why remove timers there? why not run A and R from the start to the end and the subtract?
12:44:14 <wy> lispy: I haven't decided yet. This semester I'm only taking language course
12:44:20 <kpreid> Perhaps you need a fallback, 'simplify x = x'
12:44:35 <Cpudan80> kpreid: Right
12:44:53 <Cale> tibbe: I suppose that works -- it's just that A* and R* are less useful for determining the intermediate state changes then.
12:44:55 <tibbe> then subtract*
12:44:59 <syntaxfree> what's the syntax for multi-line comments again?
12:45:01 <syntaxfree> :~
12:45:03 <tibbe> Cale: right
12:45:06 <mauke> {- -}
12:45:08 <dylan> {- -}
12:45:10 <syntaxfree> thanks!
12:45:19 <Cale> Well, hang on...
12:45:28 <syntaxfree> I'm cutting-and-pasting code during debugging, and I'm hell afraid I lose some code :~
12:45:32 <Cale> What if a timer is started, then stopped and then started again
12:45:40 <Cpudan80> kpreid: BINGO
12:45:42 <Cpudan80> Thanks
12:45:45 <tibbe> Cale: it just that I'm not sure of the end condition if we remove stuff along the way :)
12:45:46 <wy> actually I think add -- to all the lines you want to comment is a better idea
12:45:50 <Cale> then it will be in both the A set and the R set if you're not careful
12:45:53 <Cpudan80> I was thinking about that before you said it though :-P
12:46:03 <Cale> So you really do need to watch out for that
12:46:11 <Cpudan80> Haskell is kinda cool
12:46:23 <syntaxfree> Haskell is teh super.
12:46:28 <Cpudan80> This is fun - in a sick programming CS Student kinda way...
12:46:36 <Cale> tibbe: do you see that?
12:46:36 <tibbe> Cale: yes
12:46:39 <Cale> okay
12:47:01 <Cale> So it would be best if we remove what's removed at every stage :)
12:47:13 <Cale> and similarly, R* is going to make use of the definition of A
12:47:30 <tibbe> Cale: about that final condition, is it enough to look at A*(q_o, s) and see if it is Empty? for a string s
12:47:43 <tibbe> Cale: mutualy recursive huh?
12:47:56 <Cale> not quite mutually recursive
12:48:08 <syntaxfree> mutually co-recursive?
12:48:20 <Cale> because it's A* depending on R and R* depending on A
12:48:22 <syntaxfree> I love the word "co-recursive". Better than any of the other co-stuff.
12:48:22 <tibbe> perhaps that's the word :)
12:48:50 <syntaxfree> co-recursion is "forward" recursion in infinite lists.
12:48:54 <Cale> but if you wanted to unify A with A*, it would be
12:49:02 <int-e> @users
12:49:02 <lambdabot> Maximum users seen in #haskell: 276, currently: 260 (94.2%), active: 40 (15.4%)
12:49:21 <wy> how can I cause an EOFError to test the code about exceptions?
12:49:21 <glguy> > "test"
12:49:23 <lambdabot>  "test"
12:49:33 <tibbe> Cale: about that final condition...
12:49:43 <Cale> I think so, yes, you just have to check that A* is empty for any given word for which q* is an accepting state
12:49:45 <syntaxfree> fibs = 1:[ x+y | (x,y)<-zip fibs (tail fibs) ]
12:49:50 <syntaxfree> that's co-recursion
12:50:29 <Cale> brb
12:50:40 <wy> fib@(1:tfib)    = 1 : 1 : [ a+b | (a,b) <- zip fib tfib ] ?
12:51:07 <syntaxfree> cool.
12:51:15 <tibbe> Cale: I think I can do it on my own from here, going to go through it tomorrow morning and write some stuff down
12:51:21 <syntaxfree> > let  fib@(1:tfib)    = 1 : 1 : [ a+b | (a,b) <- zip fib tfib ] in fib
12:51:22 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
12:51:32 * glguy finds out that you don't need a special script to color people's nicks in mIRC
12:51:49 <syntaxfree> cool, cool, really cool. I didn't think you could define tfib in an as-pattern like that.
12:51:52 <wy> Hey. I want to trigger a EOFError. How can I?
12:51:59 <syntaxfree> @j
12:51:59 <lambdabot> Maybe you meant: jargon join . v
12:52:05 <syntaxfree> @hoogle EOFError
12:52:06 <lambdabot> System.IO.Error.eofErrorType :: IOErrorType
12:52:06 <lambdabot> IO.isEOFError :: IOError -> Bool
12:52:06 <lambdabot> System.IO.Error.isEOFErrorType :: IOErrorType -> Bool
12:52:19 <wy> syntaxfree: That's in the tutorial ;-)
12:52:25 <wy> I'm a novice
12:52:37 <mauke> wy: read from an empty file?
12:52:38 <syntaxfree> you do understand the as-pattern, right?
12:52:53 <Excedrin> I don't
12:52:55 <Cpudan80> Hmm
12:52:59 <Cpudan80> So this call formatExpr (simplify (Add (Add (Var "y") (Num 3)) (Mul (Var "x") (Num 0))))
12:53:04 <Cpudan80> No longer fails
12:53:17 <Cpudan80> but it returns y+3 + x*0
12:53:24 <Cpudan80> it should return y+3
12:53:27 <Cpudan80> hmm
12:53:49 <wy> It seems you are writing a symbolic math program?
12:53:49 <Cpudan80> Wonder why it stopped a little early..
12:54:00 <mauke> yay debugging
12:54:01 <lispy> > let foo :: Either Int Int; foo (Right x) = (Right x) in foo (Right 1)
12:54:01 <lambdabot>    The function `foo' is applied to one arguments,
12:54:02 <lambdabot>   but its type `Either...
12:54:03 <Cpudan80> a simple one
12:54:18 <glguy> > let f m@(n+1) = m + n in f 3
12:54:19 <lambdabot>  Parse error in pattern
12:54:21 <tibbe> Cale: thanks
12:54:25 <wy> mauke: can you give me an example? I haven't done with the part with files yet
12:54:30 <syntaxfree> wy = clippy?
12:54:31 <lispy> > let foo :: Either a b -> Either b c; foo (Right x) = (Right x) in foo (Right 1)
12:54:32 <lambdabot>    Quantified type variable `c' is unified with another quantified type var...
12:54:40 <vincenz> > let foo (Right x :: Either Int Int) = (Right x) n foo (Right 1)
12:54:41 <lambdabot>  Parse error in pattern
12:54:41 <syntaxfree> "It seems you are writing a symbolic math program. Would you like:
12:54:43 <lispy> okay, n/m that example doesn't work :)
12:54:51 <vincenz> > let foo ((Right x) :: (Either Int Int)) = (Right x) n foo (Right 1)
12:54:51 <lambdabot>  Parse error in pattern
12:54:53 <syntaxfree> * to download Mathematica by Stephen Wolfram
12:55:02 <syntaxfree> * to learn about doing symbolic mathematics in your head
12:55:05 <lispy> i was going to show the difference between @ patters and not using @patters
12:55:08 <syntaxfree> * to do this numerically
12:55:16 <syntaxfree> * type in your question below "
12:55:20 <mauke> wy: what tutorial is this?
12:55:25 <eviltwin_b> "* a boot to the head"?
12:55:38 <wy> mauke: A gentle introduction to Haskell
12:55:39 <vincenz> * an alphaparticle
12:55:42 <glguy> ?yow
12:55:43 <lambdabot> You were s'posed to laugh!
12:56:39 <wy> mauke: OK. The file operations are near. I'll do it myself
12:57:24 <lispy> ah, heer is the example
12:57:32 <lispy> this helps show how @ patterns work
12:57:36 <lispy> > let foo :: Either String b -> Either Int b; foo (Right x) = (Right x) in foo (Right 1)
12:57:38 <lambdabot>  Right 1
12:57:49 <lispy> > let foo :: Either String b -> Either Int b; foo r@(Right x) = r in foo (Right 1)
12:57:50 <lambdabot>  Couldn't match `Int' against `String'
12:58:01 <wy> Is there a way to query if a type is an instance of a class?
12:58:30 <glguy> > let f xxs@(x:xs) = x : xxs in f [1,2,3,4]
12:58:32 <lambdabot>  [1,1,2,3,4]
12:59:05 <glguy> > let f xxs@(x:xs) = (x, xs, xxs) in f [1,2,3,4]
12:59:06 <lambdabot>  (1,[2,3,4],[1,2,3,4])
12:59:29 <tibbe> wy: how do you mean?
12:59:37 <syntaxfree> enough, Alphaputee!
12:59:44 <lispy> the point of my example above is that it shows that when you use the at-pattern you really get the same value, even including the type
13:00:13 <lispy> ?type Right (1::Int)
13:00:14 <lambdabot> forall a. Either a Int
13:00:24 <wy> tibbe: I mean something like :type
13:00:38 <lispy> there is :inspect
13:01:06 <agocorona> hi people, could you help me. I have a problem: http://paste.lisp.org/display/30816
13:01:34 <agocorona> hi
13:01:51 <tibbe> wy, i'm still not sure what you want
13:02:05 <agocorona> could you help me? : http://paste.lisp.org/display/30816
13:02:43 <wy> tibbe: Is there something like a function that takes a type and a class and returns a bool?
13:03:01 <lispy> agocorona: the type error is exactly right!
13:03:23 <tibbe> wy: dunno, i guess there is some dynamic type info, what do you need it for? types are available at compile time
13:04:01 <lispy> wy: there is no reflection built into the language, the closest you will come is the typeable stuff in Data.Dynamic (iirc)
13:04:27 <agocorona> lispy: lispy: yes, sure., but how can have the same functionality without errors?
13:04:53 <lispy> agocorona: well, the problem is that it cannot figure out a type for "y"
13:05:02 <agocorona> sorry for the repeating name
13:06:04 <agocorona> getfromURI:: String -> IO a does`nt mean that  a is Indexable?
13:06:11 <lispy> agocorona: so one fix would be get f to have the type of 'y' in its signature
13:06:32 <lispy> then it's up to the caller of f to fix the type
13:06:41 <Cpudan80> Can someone look at this?
13:06:42 <Cpudan80> http://pastebin.ca/259887
13:06:48 <Cpudan80> The error is described up top
13:06:54 <Cpudan80> a semantic error I suppose
13:07:30 <lispy> Cale: do you know a nice solution to agocorona's problem?
13:07:43 <Cpudan80> It doesn't finish simplification...
13:08:00 <Binkley> Cpudan80: why would you expect it to output anything else?
13:08:03 <lispy> Cpudan80: because it's not recursive
13:08:05 <agocorona> I thoug that  String-> IO a   inside the definition of the class Indexable tell to the compiler that the object returnred is indexanle
13:08:11 <Binkley> in your simplify function, which of your patterns matches that expression?
13:08:27 <Cpudan80> lispy: But even adding "simplify x" instead of = x didn't fix it?
13:08:42 <dcoutts> Igloo, I've read through your revised configs proposal and I think it looks good to go.
13:08:53 <glguy> Cpudan80: you don't have a simplify (Add x y) = Add (simplify x) (simplify y)
13:09:06 <Cpudan80> ohhh
13:09:09 <Cpudan80> Hmm
13:09:14 <glguy> so... (Add x y) becomes (Add x y)
13:09:17 <Cpudan80> that might fix it
13:09:37 <Cpudan80> I need a mult one too
13:09:40 <glguy> that will get you one step closer
13:09:41 <Cpudan80> and a subtract one
13:09:43 <glguy> it won't fix it though
13:09:55 <Cpudan80> ok let me see how that works out
13:09:58 <glguy> you'll be left with: (0 + (y + 3))
13:10:19 <Cpudan80> ok
13:10:28 <lispy> simplify (Add x y) = simplify (Add (simplify x) (simplify y))
13:10:29 <glguy> you'd have to simplify again (but you still have to make sure that you don't go spinning into an infitite recursion
13:10:33 <lispy> that will get you a bit closer
13:10:45 <mauke> lispy: that looks like infinite recursion
13:10:45 <lispy> (i think...)
13:10:48 <glguy> and will cause the error that I just warned about :)
13:10:56 <syntaxfree> > "a" ++ "b" ++ ['c']
13:10:57 <lambdabot>  "abc"
13:11:20 <lispy> mauke: not if one operand is 0 ;)
13:11:52 <glguy> There needs to be one step that simplifies the children
13:12:02 <glguy> and then a second step that simplifies one level up
13:12:43 <agocorona> lispy: agocorona: so one fix would be get f to have the type of 'y' in its signature <--- I cant since f:: String->String
13:13:12 <agocorona> http://paste.lisp.org/display/30816
13:14:31 <glguy> Cpudan80: foldExpr f (Add x y) = f (Add (foldExpr f x) (foldExpr f y)) -- a couiple of these I think...
13:14:48 <Cpudan80> foldExpr?
13:15:03 <alexj__> shapr: you here?
13:15:12 <glguy> it's not exactly a fold, but the idea is there
13:15:14 <Cpudan80> glguy: Yeah - that left me with 0+y+3 like you said it would
13:15:26 * edwardk waves hello.
13:15:29 <edwardk> @users
13:15:30 <lambdabot> Maximum users seen in #haskell: 276, currently: 262 (94.9%), active: 45 (17.2%)
13:15:36 <Cpudan80> glguy: You mean format?
13:15:39 <Cpudan80> formatExpr?
13:15:45 <Cpudan80> no... that cant be it
13:15:52 <edwardk> amazing how fast the channel seems to be growing of late
13:16:21 <lispy> edwardk: i think this time of year (because of schools) it grows fastest
13:16:23 <glguy> Cpudan80: nope, you just need to treat the whole thing as a binary tree, recurse on the child nodes and then afterwards simplify
13:16:25 <edwardk> *nods*
13:16:39 <agocorona> @users mean quadratic distribution
13:16:39 <lambdabot> Maximum users seen in mean quadratic distribution: 1, currently: 0 (0.0%), active: 0 (NaN%)
13:16:46 <tibbe> edwardk: you have a nice plot of users/time?
13:16:56 <agocorona> naaa
13:16:59 <SamB_XP> doesn't dons?
13:17:01 <edwardk> just what i saw on dons' site
13:17:06 <lispy> ?where stats
13:17:06 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
13:17:38 <LPhas> mumble
13:17:51 <agocorona> fine
13:17:51 <edwardk> heh i've been losing ground on the stats. i need to rant more about substructural types and stuff =)
13:17:57 <tibbe> oh! you can see when I joined in the text output graph!
13:18:32 <glguy> I need to talk more if I'm going to make it to the top, i'm only in 31st place =(
13:18:59 <lispy> agocorona: if getFromURI had type a -> String -> IO a, then you could add a parameter to f and make it f :: a -> String -> String
13:19:19 <lispy> agocorona: and the caller would do something like f (undefined::Foo) "myuri"
13:19:25 <tibbe> 52nd place :( :(
13:19:41 <SamB_XP> hmm, I bet my placement is muddled by the fact that I don't know how to use a text-based client under screen...
13:19:42 <lispy> agocorona: it's annoying because then you have this 'undefined' you need to not evaluate, but it gets the types to work out
13:19:47 <glguy> tibbe: I guess at least we made it to an honorable mention ;)
13:20:03 <tibbe> glguy: yeah :D and I think I gained a rank or two today
13:20:23 <tibbe> next time I'll ask someone to explain arrows in relation to CT to me
13:20:26 <edwardk> if i was only 25% more chatty i'd be in the top 25 of all time... disturbing given that i've been here for 4-5 months now =/
13:20:40 <metaperl> nder certain simple restrictions, problems that can be solved in linear time in a language with assignments must take longer (by a logarithmic factor) in an eagerly evaluated purely functional language.  --- http://web.comlab.ox.ac.uk/oucl/work/geraint.jones/morehaste.html
13:20:41 <lisppaste2> syntaxfree pasted "this is rather simple" at http://paste.lisp.org/display/30818
13:20:42 <lambdabot> Title: Research Highlights - More Haste Less Speed, http://tinyurl.com/y8gr3h
13:20:46 <Cpudan80> How does one make a comment in haskell?
13:20:48 <Cpudan80> $?
13:20:51 <Cpudan80> err #
13:20:55 <syntaxfree> metaper: i saw that.
13:21:02 <syntaxfree> cpudan80: nope. "--" or "{-"
13:21:12 <Cpudan80> thanks
13:21:12 <syntaxfree> "-}"
13:21:16 <glguy> (and {- is closed like -}
13:21:23 <agocorona> lispy: I will check it. Thanks
13:21:38 <SamB_XP> > 1 {- like this! -} + 1 -- or this!
13:21:40 <lambdabot>  2
13:21:48 * glguy envisions well-typed comments
13:21:56 <edwardk> i wonder if i changed my nick to edwardk++, what would happen to my karma?
13:21:56 <glguy> ... subject verb agreement
13:22:14 <glguy> is that a legit nick on freenode?
13:22:30 <\this{is}> cool, eh?
13:22:31 <edwardk> ah guess not
13:22:40 * glguy guesses that + is a reserved character for "voice"
13:22:47 <SamB_XP> @karma edwardk
13:22:48 <edwardk> saw Marvin-- in the logs, hoped =)
13:22:48 <lambdabot> edwardk has a karma of 3
13:22:57 <syntaxfree> @karma syntaxfree
13:22:57 <lambdabot> You have a karma of 1
13:23:02 <SamB_XP> edwardk++: hello!
13:23:03 <SamB_XP> @karma edwardk
13:23:04 <lambdabot> edwardk has a karma of 3
13:23:10 <lispy> edwardk: i think the nick is sent in a different part of the irc message so lambdabot doesn't look it when checking what was tyed?
13:23:11 <edwardk> heh oh well
13:23:15 <lispy> ah
13:23:19 <lispy> yeah, that would cause it....
13:23:20 <SamB_XP> edwardk: it wouldn't do anything for your karma
13:23:27 <GuidoVanRossum--> I wonder if this works.
13:23:31 <SamB_XP> certainly the nick is not processed by the filter
13:23:33 <tibbe> @karma tibbe
13:23:34 <lambdabot> You have a karma of 0
13:23:38 <tibbe> :(
13:23:42 <meddle> hi guys; could someone point me to a good concurrent haskell intro?
13:23:42 <tibbe> i've been a bad boy
13:23:48 <edwardk> samb: unless said something in passing and mentioned the name edwardk ++
13:23:49 <SamB_XP> GuidoVanRossum--: no, silly dictatorial personage
13:23:51 <GuidoVanRossum--> I wish I knew where I got my karma from.
13:24:06 <edwardk> but as they don't appear to let + through the protocol tis a moot point
13:24:22 <GuidoVanRossum--> @karma GuidoVanRossum
13:24:22 <lambdabot> GuidoVanRossum has a karma of 0
13:24:25 <tibbe> meddle: hmm, there's a web server paper
13:24:29 <lispy> meddle: a good one?  well...there is the stm paper and "tackling the awkward squad..." but ymmv
13:24:31 <SamB_XP> edwardk: well, in passing is not at the beginning of the message
13:24:37 <tibbe> @google concurrent haskell
13:24:39 <lambdabot> http://research.microsoft.com/~simonpj/Papers/papers.html
13:24:39 <lambdabot> Title: Simon Peyton Jones: papers
13:24:42 <SamB_XP> lambdabot only honours those things at the beginning of the message
13:24:50 <edwardk> lispy: i was mostly thinking of when people replied and autocompleted
13:25:03 <edwardk> alas tis not to be
13:25:05 <glguy> but the colon after the ++ kills it
13:25:09 <edwardk> *nods*
13:25:14 <SamB_XP> well, I suppose if I said
13:25:19 <SamB_XP> edwardk++ is working on foo
13:25:24 <SamB_XP> that would alter your karma
13:25:29 <lispy> meddle: "tackling the awkward squad..." is quite good, but i don't know about it in the context you asked.  It does touch the topic, but i don't recall them getting heavy into concurrent haskell
13:25:42 <edwardk> or if i said hey SamB_XP++ how is that project going?
13:25:44 <lispy> ?karma
13:25:45 <lambdabot> You have a karma of 20
13:25:47 <meddle> lispy: i haven't read that yet.. i'll start there
13:25:50 <lispy> oh, the big 20!
13:25:50 <meddle> thanks :D
13:25:51 <Lajexander> I need a continuation tutorial... I really don't understand that much of the one at wikibooks...
13:26:06 <SamB_XP> edwardk: the "hey" would mess it up
13:26:17 <edwardk> ah it doesn't take it mid-line?
13:26:17 <lispy> meddle: yw
13:26:52 <SamB_XP> I'm fairly sure it didn't last I knew
13:27:36 * edwardk shrugs.
13:27:51 <glguy> is mIRC lying to me, or is the bans list empty?
13:28:08 <mauke> no bans here either
13:28:35 <SamB_XP> perhaps you can't access the bans list in the usual way here?
13:28:38 <glguy> I feel so exposed...
13:29:04 <glguy> I usually don't use mIRC, but today my irssi box is down
13:29:05 <glguy> so...
13:29:08 <glguy> i just wondered
13:29:17 <glguy> irssi usually shows ~49 of them
13:29:19 <lispy> could also be that the bans list was reset when freenode went down this weekend?
13:29:30 <glguy> that would make sense... did it go down?
13:29:32 <SamB_XP> could be!
13:29:42 <glguy> ?uptime
13:29:43 <wy> I've got a problem in http://paste.lisp.org/display/30819
13:29:44 <lambdabot> uptime: 14h 59m 5s, longest uptime: 9d 2h 23m 6s
13:29:47 <mauke> heh, ghc warns about unused functions that are actually used, but only by other unused functions
13:29:49 <lispy> glguy: yeah for like the 10 longest minutes of my life!
13:30:08 <lispy> mauke: if you list them in exports it will shut up
13:30:24 <glguy> wy: either use putStrLn
13:30:27 <mauke> but they're private
13:30:29 <glguy> wy: or read about buffering
13:31:04 <lispy> mauke: well, it shouldn't complain if they do eventually get called by something which is exported
13:31:05 <glguy> ?hoogle flush
13:31:06 <lambdabot> GHC.ConsoleHandler.flushConsole :: Handle -> IO ()
13:31:07 <lambdabot> System.Win32.File.flushFileBuffers :: HANDLE -> IO ()
13:31:07 <lambdabot> IO.hFlush :: Handle -> IO ()
13:31:25 <SamB_XP> mauke: of course! it follows the directed graph to determine what is used...
13:31:25 <lispy> mauke: otherwise you might have a ghc bug report to make :)
13:31:50 <mauke> SamB_XP: yeah, but it should only complain about immediately unused functions
13:32:02 <glguy> wy: http://www.mail-archive.com/haskell@haskell.org/msg19164.html
13:32:04 <lambdabot> Title: Re: [Haskell] putStr is not evaluated in the correct order, http://tinyurl.com/y22b9f
13:32:09 <SamB_XP> mauke: then it wouldn't complain about mutually recursive functions!
13:32:11 <mauke> lispy: I know, that part is just not written yet :-)
13:32:20 <mauke> ah, the refcounting problem
13:35:14 <wy> glguy: Thanks. hFlush stdout works
13:36:38 <dobblego> how do I have a data constructor argument be of two type-classes? data Ord a, Show a => X a= X a
13:37:17 <lisppaste2> metaperl pasted "I want to optimize my implementation of reverse" at http://paste.lisp.org/display/30820
13:37:41 <Cpudan80> glguy: Ok - so - I got it to do y+3+0
13:37:51 <Cpudan80> But I need a tiny little step...
13:38:02 <Cpudan80> I guess I need to think some more ;)
13:38:18 <dobblego> metaperl, have you looked at the GHC source? (that implementation performs poorly)
13:38:19 <Cpudan80> my gut reaction threw it into infinite recursion
13:38:28 <mauke> metaperl: reverse = Data.List.reverse :-)
13:38:42 <tibbe> ?source
13:38:42 <lambdabot>  not available
13:38:46 <tibbe> @source
13:38:46 <lambdabot>  not available
13:38:47 <metaperl> I'm doing an SJT exercise mauke :)
13:39:01 <shapr> alexj__: jabber?
13:39:02 <mauke> @source reverse
13:39:02 <lambdabot> reverse not available
13:39:07 <lisppaste2> glguy annotated #30820 with "reverse with tail recursion" at http://paste.lisp.org/display/30820#1
13:39:16 <metaperl> dobblego - no i have not looked at the source
13:39:26 <mauke> @source Data.List
13:39:26 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
13:39:30 <metaperl> glguy - we had a discussion of tail recurision here this morning.. it is not so great for Haskell
13:39:40 <tibbe> fold snoc?
13:40:02 <glguy> metaperl: reverse doesn't work on infinite lists
13:40:07 <tibbe> > foldl snoc [] [1,2,3]
13:40:07 <lambdabot>  Not in scope: `snoc'
13:40:14 <wy> How can I get the contents from monads to a variable that can be used in the other parts?
13:40:26 <mauke> glguy: so?
13:40:31 <dobblego> wy, <-
13:40:31 <tibbe> > let snoc = flip (:) in foldl snoc [] [1,2,3]
13:40:33 <lambdabot>  [3,2,1]
13:40:35 <chessguy> > reverse [1..]
13:40:36 <mauke> wy: depends on the monad
13:40:37 <metaperl> glguy - thanks I like that implementation
13:40:39 <lambdabot> Terminated
13:40:46 <chessguy> > reverse [1..]
13:40:50 <lambdabot> Terminated
13:41:03 <tibbe> metaperl, let snoc = flip (:) in foldl snoc [] [1,2,3]
13:41:04 <glguy> mauke: so no sense in worrying about reverse always having to traverse the whole list
13:41:09 <chessguy> hmmm. "doesn't work" or "takes an infinite amount of time?
13:41:20 <metaperl> tibbe - you are brain damaging me
13:41:24 <Binkley> chessguy: takes an infinite amount of time
13:41:37 <dobblego> how do I write a to be of two type-classes? data Ord a, Show a => X a= X a ?
13:41:37 <tibbe> metaperl: :)
13:41:44 <mauke> glguy: no, tail recursion eats your stack
13:41:55 <Binkley> though from GHC's perspective, there's often no distinction...
13:41:56 <chessguy> hmm, seems like not working would be preferable
13:42:16 <Binkley> chessguy: how do you check that a list is infinite?
13:42:20 <dobblego> chessguy, just define a universe where "takes an infinite amount of time" and "working" are in contradiction :)
13:42:24 <tibbe> dobblego: (Class1 a, Class2 a) => a -> Int IIRC
13:42:35 <glguy> foldl (flip (:)) [] is the equivalent to what I wrote
13:42:54 <dobblego> tibbe, nope, GHC gives parse error on input `,'
13:43:01 <dobblego> oh wait, take it back
13:43:30 <dobblego> damn parentheses, thanks
13:43:44 <tibbe> dobblego: you're welcome
13:44:34 <tibbe> > let rev = foldl (flip (:)) [] in rev [1,2,3]
13:44:35 <lambdabot>  [3,2,1]
13:45:02 <lisppaste2> tibbe annotated #30820 with "With foldl" at http://paste.lisp.org/display/30820#2
13:45:30 <metaperl> wow, that is some tight code
13:46:26 <tibbe> metaperl: look at it like this: a list is -> 1 : 2 : 3 : [] and then you reverse the :
13:46:48 <tibbe> where's that foldl image?
13:46:58 <metaperl> what?
13:47:06 <metaperl> "then you reverse the :"
13:47:09 <metaperl> that makes no sense to me
13:47:31 <tibbe> flip (:) takes and reverses :
13:47:37 <wy> How can I concatenate a list of strings into one string?
13:47:45 <dobblego> ?type concat
13:47:46 <lambdabot> forall a. [[a]] -> [a]
13:47:47 <glguy> concat
13:47:48 <tibbe> I'm sorry about being so terse, I'm lying down in my sofa so it's hard to type
13:48:00 <metaperl> wy mapConcat
13:48:03 <metaperl> @type mapConcat
13:48:04 <lambdabot> Not in scope: `mapConcat'
13:48:13 <tibbe> there's an image that explains it but I can't find it
13:48:19 <tibbe> ?type reduce
13:48:19 <glguy> metaperl; you might be thinking of concatMap
13:48:20 <lambdabot> Not in scope: `reduce'
13:48:21 <metaperl> @type unwords
13:48:22 <lambdabot> [String] -> String
13:48:22 <dobblego> > concat ["abc", "def", "ghi"]
13:48:24 <lambdabot>  "abcdefghi"
13:48:30 <metaperl> oh
13:48:31 <tibbe> http://foldl.com/ ;)
13:48:32 <metaperl> i'm wrong
13:48:34 <metaperl> sorry wy
13:48:34 <lambdabot> Title: foldl.com
13:48:53 <metaperl> > unwords "hi there"
13:48:54 <lambdabot>  Couldn't match `String' against `Char'
13:48:54 <dibblego> tibbe, nice :)
13:49:07 <metaperl> > unwords [ "hi" , "bob" ]
13:49:08 <lambdabot>  "hi bob"
13:49:09 <glguy> instead of one "reduce", we have foldl foldr foldl1 foldr1 foldrl'
13:49:09 <tibbe> although that wasn't the image I was looking for
13:49:30 <glguy> errr foldl'
13:49:31 <wy> metaperl: this is cool!
13:49:33 <metaperl> glguy and scnanl too
13:49:35 <metaperl> scanl
13:49:40 <metaperl> wy - what is cool?
13:49:50 <wy> unwords
13:49:54 <metaperl> :)
13:49:55 <tibbe> dobblego: if you read about reduce in "why functional programming matters" you might figure out how to use that to do what I did
13:50:08 <dobblego> tibbe, I've read it and I know what you did mate :)
13:50:16 <opqdonut> > fix ( (1:) . (1:) . (zipWith (+) `ap` tail))
13:50:17 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
13:50:20 <tibbe> dobblego: oh, sorry, thought you didn't :)
13:50:36 <tibbe> opqdonut: now that was uncalled for!
13:50:37 <metaperl> @type intersperse
13:50:38 <lambdabot> forall a. a -> [a] -> [a]
13:50:40 <dobblego> tibbe, I just like the brevity of the website; I've sent it to my colleagues for an introduction to foldl :)
13:51:06 <tibbe> dobblego: I belive there's and foldr.com as well
13:51:25 <dibblego> indeed there is
13:53:33 <opqdonut> tibbe: oh, sorry :)
13:54:28 <mauke> wow, I think I understand that
13:59:39 <nomeata> Interesting. According to the logs, in June 05, long before I started hanging around here, Lunar^ posted this song by me (http://mitschriebwiki.nomeata.de/WroteItInHaskell.html) and shapr found it cute. cute!
13:59:42 <lambdabot> Title: Das VorlesungsMitschiebWiki - WroteItInHaskell, http://tinyurl.com/y3osxg
14:00:35 <dobblego> ?type (>>=)
14:00:37 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
14:26:08 <glguy> ?users
14:26:08 <lambdabot> Maximum users seen in #haskell: 276, currently: 258 (93.5%), active: 45 (17.4%)
14:29:35 <Cpudan80> glguy: you still here?
14:30:21 <glguy> yeah
14:30:51 <Cpudan80> Ok - so - The simplification thing - it simplfies to (y+3)+0
14:31:07 <glguy> k
14:31:10 <RemiTurk> good evening
14:31:14 <Cpudan80> does the order of the definitions matter in haskell?
14:31:22 <RemiTurk> no
14:31:23 <Cpudan80> or does it blast through them all?
14:31:25 <Cpudan80> ok
14:31:27 <glguy> Cpudan80: the first definition to match
14:31:35 <glguy> Cpudan80: is the one that is used
14:31:39 <RemiTurk> except for the order of matches, that is..
14:31:45 <Cpudan80> glguy: ok - thought so
14:32:00 <Cpudan80> glguy: You said I needed to simplify the child of that simplification correct?
14:32:22 <glguy> you need to separate traversal from simplification
14:33:08 <Cpudan80> oh....
14:33:23 <Cpudan80> any suggestions as to how to proceed?
14:34:34 <glguy> do you have that pastebin link still?
14:36:40 <Cpudan80> yeah - let me update it
14:36:58 <glguy> don't worry about it
14:37:07 <glguy> I'm just goign to throw together a really simple
14:37:12 <glguy> example that illustrates my point
14:37:37 <Cpudan80> http://pastebin.ca/259984
14:38:02 <kpreid> @pl \f -> fix (f >>)
14:38:02 <lambdabot> fix . (>>)
14:38:08 <kpreid> is there another name for that?
14:38:19 <vincenz> spam
14:38:30 <vincenz> spam $ print "HAHA!"
14:39:08 <glguy> kpreid: it is often: forever x = x >> forever x
14:39:28 <vincenz> or
14:39:33 <vincenz> sequence_ . repeat
14:39:34 <kpreid> actually, I just realized I need a termination condition, anyway
14:39:43 <glguy> sequence_ . repeqt
14:39:45 <glguy> yeah, that
14:40:13 <vincenz> @type repeat
14:40:14 <lambdabot> forall a. a -> [a]
14:40:19 <vincenz> @type cycle
14:40:20 <lambdabot> forall a. [a] -> [a]
14:42:25 <glguy> Cpudan80: still there?
14:42:35 <Cpudan80> yep
14:43:19 <glguy> Cpudan80: I think that I added to your paste...
14:44:15 <glguy> ?paste
14:44:16 <lambdabot> http://paste.lisp.org/new/haskell
14:44:27 <Cpudan80> glguy: Yeah I see that
14:44:33 <Cpudan80> why did you remove all the other cases
14:44:37 <Cpudan80> subtract and stuff
14:44:44 <glguy> Because I just wrote that from memory
14:44:47 <glguy> I didn't modify yours
14:45:20 <Cpudan80> oh ok
14:46:29 <Cpudan80> hmm I guess that will work
14:46:38 <Cpudan80> I think there should be some more direct way though
14:47:46 <glguy> You are doing two different things
14:48:41 * shapr considers registering http://install.sh
14:48:55 <shapr> Or something really evil like autoconf.sh
14:49:00 <RemiTurk> haha
14:49:24 <kpreid> Fallow, incoherent instances!
14:49:47 <RemiTurk> shapr: could there be a http://setup.hs?
14:50:00 <kpreid> (luckily the problem was just an insufficiently specified [])
14:50:10 <Cpudan80> glguy: Yeah... but why cant you just add a case for y+x+0 ---> y+x
14:50:18 <shapr> RemiTurk: Sadly, .hs doesn't exist
14:50:29 <RemiTurk> shapr: time to start a haskell micronation? ;)
14:50:47 <glguy> Cpudan80: Because If you try to enumerate all possible reductions, you'll never be able to stop
14:50:57 <Cpudan80> hmm
14:51:00 <Cpudan80> true
14:51:07 <shapr> I'd still like to colonize .aq and start a nation that specifically disallows patent and copyright.
14:51:09 <glguy> Cpudan80: if you generalize the reductions, you can handle all of the cases without an infinite filesize
14:51:17 <Cpudan80> right right
14:52:23 <Cpudan80> glguy: in your code traverseExpr f -- f is the return value right?
14:52:42 <glguy> Cpudan80: f is a function that you specify
14:53:02 <glguy> Cpudan80; like in the case of: simplifyExpr = traverseExpr simplify
14:53:25 <glguy> Cpudan80: the idea is that the traversal has nothing to do with simplication
14:53:35 <glguy> and that simplification is just one thing you might want to do
14:53:44 <Cpudan80> ook
14:53:48 <Cpudan80> I see I see
14:54:06 <glguy> I probably could have called that: foldExpr
14:54:23 <Cpudan80> So you basically break it down into to tiny pieces
14:54:26 <Cpudan80> simplify as you go along
14:54:27 <greentea> Hey all.
14:54:30 <Cpudan80> and build it back up?
14:54:34 <glguy> Cpudan80: yeah, that
14:54:38 <glguy> greentea: hi
14:54:54 <Cpudan80> glguy: what's the $ in there for?
14:55:16 <cjeris> shapr: good way to get added to the axis of evil
14:55:19 <Cpudan80> Im scrolling through the manual
14:55:24 <Cpudan80> let me see if I can find info
14:55:57 <Excedrin> $ is function application
14:56:06 <Excedrin> f (g x) =  f $ g x
14:56:15 <Cpudan80> oh
14:56:20 <Cpudan80> ok sounds good
14:56:39 <glguy> Cpudan80: I use them to avoid having to count as many closing parenthesis
14:56:57 <Cpudan80> so you could do
14:57:03 <Cpudan80> f(......)?
14:57:22 <glguy> yeah
14:58:45 <mux> ?seen dons
14:58:46 <lambdabot> dons is in #ghc, #haskell-overflow, #haskell and #Haskell. I last heard dons speak 8h 3m 20s ago.
14:59:33 <glguy> Cpudan80: there is other magic that you can use $ for
14:59:45 <Cpudan80> lol
14:59:46 <glguy> > map ($ 5) [ (+1), (+2) ]
14:59:48 <lambdabot>  [6,7]
15:00:25 <shapr> cjeris: true that
15:02:36 <dons> morning
15:02:37 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:02:45 <greentea> Hi dons.
15:03:10 <vincenz> eveninig
15:03:18 <glguy> http://programming.reddit.com/goto?id=so4y -- WOW, talk about criticising a PL you "obviously" don't understand
15:03:21 <lambdabot> Title: The Little Calculist: Does type inference have to suck?
15:03:44 <mux> dons: morning!
15:03:53 <mux> dons: I finished my parallel zeta thing
15:03:57 <dons> cool!
15:03:58 <mux> want to take a look?
15:04:00 <vincenz> ack!
15:04:02 <vincenz> I can't right click
15:04:07 <mux> I think there's still a bug somewhere though
15:04:09 <dons> glguy: yeah, that was a pretty boring article
15:04:16 <dons> mux, ok good. post it up somewhere
15:04:35 <mux> http://mu.org/~mux/Main.hs
15:04:45 <shapr> Still, Dave Herman seems to be a pretty smart guy, I'd like to know more about why he thinks type inference in Haskell is broken.
15:04:59 <dons> complaints about the error messages
15:05:06 <dons> (of SML/NJ, I think)
15:05:15 <dons> examples would be good...
15:05:25 <glguy> I think that this might actually be an appropriate example of when to use the term "sour grapes"
15:06:03 <greentea> /me, as a n00b, /does/ prefer Helium's error messages.
15:06:51 <mux> I wonder if that cut function I coded already existed somewhere, or if I could have written it in a simpler way
15:07:13 <emu> the guy sounds like a java monkey
15:07:16 <mux> *Main> cut (1,1000) 3
15:07:16 <mux> [(1,334),(335,667),(668,1000)]
15:07:17 <Cale> greentea: that's odd, your IRC client didn't generate an action from /me
15:07:38 <glguy> some IRC clients let you write // to mean a literal /
15:07:44 <glguy> maybe he wrote //me?
15:07:50 <greentea> Cale: Yes, 'twas rather odd. i'm using GAIM, and it's been crashing of late.
15:07:54 <Excedrin> is there a simpler way to do: map snd (filter fst (zip [True, False] [1, 2])) ?
15:07:57 <cjeris> If you can't tell which case is missing from your pattern match, your ADT has too many constructors ;)
15:07:57 * glguy tests
15:07:59 <greentea> glguy: 'She', and i didn't. :-)
15:08:07 <mux> dons: does it look correct to you?
15:09:07 <Cale> greentea: yeah, GAIM isn't such a great IRC client. (I do use it for MSN though.)  I usually recommend X-Chat for IRC.
15:09:23 <emu> a graphical representation of type-inference might be interesting, but probably will be a muddled mess that can't clearly show everythign
15:09:24 * greentea tries again, carefully avoiding typing '//'.
15:09:30 <vincenz> Cale: or a screen session and ssh login somewhere :)
15:09:33 <greentea> Yep, worked that time.
15:09:36 <vincenz> Cale: why do you think it says spain?
15:09:42 <emu> i use irssi-text for irc, run it under screen
15:09:59 <mux> dons: of course the code could use comments :-)
15:10:30 <greentea> Cale: Yes, i used to use X-Chat, but i also regularly need to use Jabber, and occasionally Yahoo! (MSN is EVIL :-) ), so i prefer to just run one client.
15:11:04 <mentomorph> Hola! Do you know of a delay fnk. in Haskell ?
15:11:22 <mentomorph> what is it ?
15:11:45 <Cale> greentea: yeah, I often wonder why I even bother to run it, but there are one or two people I know who seem to prefer it over IRC.
15:11:59 <Cale> mentomorph: what would it do?
15:12:30 <Philippa> I make quite a lot of use of MSN, the status notifications're good if you're after individual convos
15:12:48 <mentomorph> I go trough a list of IO actions, I'd like to have a delay inbetween outputs.
15:12:58 <Cale> okay
15:13:32 <kpreid> @type threadDelay
15:13:33 <lambdabot> Not in scope: `threadDelay'
15:13:35 <glguy> Excedrin: about the only other way I can see makign it cleaner is: [a | (a,b) <- zip values bools, b]
15:13:40 <Cale> yeah, threadDelay
15:13:42 <kpreid> @type System.IO.threadDelay
15:13:43 <lambdabot> Not in scope: `System.IO.threadDelay'
15:13:47 <Cale> In Control.Concurrent
15:14:01 <kpreid> mentomorph: to do that, 'intersperse (threadDelay n)' on your list :)
15:14:08 <mentomorph> thx Cale, kpreid
15:14:15 <mentomorph> allrightt :)
15:17:34 * kpreid wonders if there are any other uses for (sequence_ . intersperse)
15:17:35 <mentomorph> working fine, thank you guys.
15:17:42 <kpreid> er, not .
15:17:56 <glguy> (sequence_ .) . intersperse?
15:18:24 <Cale> I suppose you could insert updates to a progress meter.
15:18:31 <LPhas> ?seen dcoutts
15:18:31 <lambdabot> I saw dcoutts leaving #ghc, #gentoo-haskell, #haskell-overflow and #haskell 1h 48m 37s ago, and .
15:19:35 <SyntaxNinja> dons: ancient and justified developers of the cabal?
15:20:07 <mentomorph> nope it doesn't work as I wanted.
15:20:58 <mentomorph> it still throws it all out after the delay, even though delay is interspearsed
15:21:20 <kpreid> "it"?
15:21:26 <mentomorph> ghc
15:21:27 <kpreid> maybe you want hFlush too?
15:21:34 <kpreid> I meant the second "it"
15:21:46 <mentomorph> the IO actions
15:21:57 <kpreid> what are the actions doing?
15:22:05 <kpreid> if they're printing, then you need hFlush
15:22:21 <mentomorph> it's a kt2hs drawLine function
15:22:47 <kpreid> well, check that for some flush operation
15:22:51 <dons> SyntaxNinja: :)
15:23:01 <mentomorph> oki. thx.
15:23:28 <dons> SyntaxNinja: i've had 3 user reports for mkcabal already. People are using it to write cabal files. Yay!
15:23:56 <SyntaxNinja> sweet :)
15:24:34 <SyntaxNinja> dons: I'm replying to your email.
15:25:01 <dons> if i can polish it up, and people continue to use it, having it included with cabal seems a good idea, imo.
15:27:16 <thailand-fan> can haskell be used to develop databases?
15:27:34 <thailand-fan> lazy evaluation seems ideal for banks who want to know global balances
15:27:37 <thailand-fan> etc.
15:27:44 <thailand-fan> and templating
15:28:12 <thailand-fan> where you only want part of a page to be computed
15:28:40 <mux> dons: so, had a look at the code yet?
15:28:51 --- mode: ChanServ set +o dons
15:28:57 --- mode: dons set +b *!*n=bill@4.38.41.*
15:28:57 --- kick: thailand-fan was kicked by dons (nice try gschuett)
15:29:07 --- mode: ChanServ set -o dons
15:29:16 <dons> mux, sorry. went out for breakfast. url?
15:29:29 <mux> dons: http://mu.org/~mux/Main.hs
15:29:43 <kpreid> heh, I recognized him too
15:29:47 <dons> that guy was the famouse protontorpedo troll (maybe he is a bot?)
15:29:49 <dobblego> ?paste
15:29:50 <lambdabot> http://paste.lisp.org/new/haskell
15:29:57 <dons> 2 seconds in the logs reveals:
15:29:58 <dons> 06.09.07:17:04:41 <dons> you can tell by the spelling/questions. but also the name: gschuett@4.38.41.141
15:30:01 <dons> 06.09.07:18:02:44 --- mode: dons set +b *!*@4.38.41.141
15:30:18 <lisppaste2> dobblego pasted "how do do I go from the former to the latter?" at http://paste.lisp.org/display/30835
15:30:22 <dons> our ban list expired during the recent weird netsplit/reboot :/
15:30:36 <dons> so keep an eye out for the old trolls
15:30:47 <glguy> ?protontorpedo
15:30:48 <lambdabot> is it nicer than APL?
15:31:03 <underzsof> THE SITE HAS EVERYTHING ABOUT WAREZ RAPIDSHARE DOWNLOADZ --> WWW.UNDERZSOFT.COM  THANX!!!
15:31:10 <dons> sigh
15:31:14 <dobblego> like that one?
15:31:15 <kpreid> is there a monad transformer for backtraces?
15:31:17 <SyntaxNinja> dons: what was that about?
15:31:47 <dobblego> lambdabot should commit the ban list to a darcs repos
15:32:01 <glguy> *cough* eggdrop *cough*
15:32:10 <dons> ok. firstly we had a well known troll, see the 'protontorpedo' section of this page http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Quote/Text.hs
15:32:12 <lambdabot> http://tinyurl.com/mkqad
15:32:14 <profmakx> is eggdrop written in haskell, glguy
15:32:18 <dons> the second guy, coincidence I guess
15:32:19 <glguy> Oh man... I had some eggdrop stuck in my throat
15:32:23 <dons> maybe we should be +s
15:32:29 <SyntaxNinja> dons: I just replied about mkcabal
15:32:36 <dons> cheers
15:32:46 <SyntaxNinja> dons: I personally think we should keep it separate.  not because it's not AWESOME, but because it is awesome :)
15:32:57 <SyntaxNinja> I want more awesome layered tools that aren't  just a part of the cabal codebase
15:32:57 <dons> ok.
15:33:01 <dobblego> how do I write a type with a data constructor that has a varable bound by two type-classes? http://paste.lisp.org/display/30835
15:33:08 <dons> currently it doesn't search the src for libs or execs.
15:33:11 <SyntaxNinja> the executables that come w/ cabal are already getting confusing, fwiw.
15:33:25 <dons> yeah fair enough
15:33:39 <dons> but i'll move it to depend on Cabal for the cabal data types, I think
15:33:48 <kpreid> dobblego: I think you have to put all the constraints on all the instances
15:33:56 <SyntaxNinja> dons: that's OK, right?
15:34:11 <dons> yep
15:34:16 <dobblego> kpreid, as in "(Ord a, Show a)" ?
15:34:26 <kpreid> dobblego: yes. that's my experience.
15:34:32 <dobblego> ok I'll give it a burl
15:34:33 <glguy> ?keal
15:34:34 <lambdabot> perhaps i just genius and never tested
15:35:19 <dobblego> kpreid, that did it, thanks
15:35:42 <dons> mux, nice and simple. does it work?
15:36:00 <greentea> dons: lol @ "Category theory is the Paris Hilton of mathematics" :-)
15:36:05 <SyntaxNinja> dons: my net connection is flaky, can't see that URL.
15:36:14 <dons> for the troll?
15:36:24 <SyntaxNinja> yeah, no worries. we trust ya
15:36:37 <dons> 10:26  dons> ok. firstly we had a well known troll, see the 'protontorpedo' section of this page
15:36:41 <dons>              http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Quote/Text.hs
15:36:42 <lambdabot> http://tinyurl.com/mkqad
15:36:44 <mux> dons: looks like it does, though I thought there might be a bug because when I change the number of threads the result varies slightly; maybe this is just a rounding issue and not really a bug in my code, I'm not sure
15:36:48 <vincenz> @protontorpedo
15:36:49 <lambdabot> Im really only a bash person and even then Im tin
15:36:50 <dons> (2 sec grep in the logs for his ip address )
15:36:52 <vincenz> @protontorpedo
15:36:52 <lambdabot> i have a win xp box
15:36:53 <glguy> ?girl19
15:36:53 <lambdabot> LOL
15:36:59 <vincenz> @protontorpedo
15:37:00 <lambdabot> is functional ebtter than oo?
15:37:20 <glguy> ?stewie
15:37:21 <lambdabot> Unknown command, try @list
15:37:24 <dobblego> ?dibblego
15:37:25 <lambdabot> Unknown command, try @list
15:37:38 <vincenz> @protontorpedo
15:37:38 <lambdabot> wil haskell make mroe more money?
15:37:47 <sjanssen> @keal
15:37:48 <lambdabot> i need math friendly compiler to compile for jvm or flash
15:37:48 <dobblego> is there any difference between a ++ b ++ c and concat [a,b,c] ?
15:37:50 <SyntaxNinja> my flight is bording, see you guys later.
15:37:54 <vincenz> @quote dons
15:37:55 <lambdabot>  screw 'em. we have the technology.
15:38:03 <vincenz> bbye SyntaxNinja
15:38:13 <Pseudonym> Cya.
15:38:15 <Pseudonym> Have fun.
15:38:37 <dons> dobblego: concat = foldr (++) []
15:38:41 <glguy> I didn't realize palomer earned a lambdabot command
15:38:48 <dobblego> ah that's right
15:38:49 <vincenz> @palomer
15:38:50 <lambdabot> Brump!
15:38:56 <vincenz> #quote glguy
15:38:59 <vincenz> ?quote glguy
15:38:59 <lambdabot>  that's odd, mine is this big : |-----------------------------|
15:39:05 <dons> do	and:
15:39:05 <dons> foldr k z xs = go xs
15:39:05 <dons>          where
15:39:05 <dons>            go []     = z
15:39:06 <vincenz> oh yeah, I remember that one :D
15:39:06 <dons>            go (y:ys) = y `k` go ys
15:39:12 <Pseudonym> That protontorpedo quote reminds me of the story of Euclid.
15:39:15 <vincenz> dons: paste!
15:39:16 <glguy> ?quote emertens
15:39:17 <lambdabot>  screw ruby on rails, I'm using snakes on a plane
15:39:44 <Pseudonym> A student asked Euclid: "What profit can I gain from geometry?"
15:40:07 <Pseudonym> Euclid called a slave and said to him: "Give that man a coin.  He has to profit from everything he learns."
15:40:09 <mux> dons: can you think of a simpler way to write the cut function?
15:40:11 <Pseudonym> The student was then dismissed.
15:40:38 <vincenz> Pseudonym: that's not funny :/
15:40:47 <Pseudonym> It's not meant to be.
15:40:47 <glguy> Pseudonym: so was protontorpedo the slave? or the student?
15:40:55 <Pseudonym> glguy: The student, I think.
15:41:05 <vincenz> @protontorpedo
15:41:06 <lambdabot> so why would one prefer haskell to say clisp or smalltalk?
15:41:10 <Pseudonym> "Here's a nickel, kid.  Go buy yourself a real programming language."
15:41:23 <Pseudonym> OK, now THAT question is actually fairly reasonable, taken out of context.
15:41:38 <vincenz> Pseudonym: yeah, except that that's all he asked
15:41:41 <vincenz> for like x months straight
15:41:44 <Pseudonym> Yeah.
15:41:56 <vincenz> @localtime Pseudonym
15:41:57 <lambdabot> Local time for Pseudonym is Tue Nov  28 10:36:27 2006
15:42:09 <vincenz> o.O, where is that
15:42:14 <vincenz> aussie?
15:42:14 <Pseudonym> Here.
15:42:17 <Pseudonym> Yup.
15:42:28 <vincenz> @localtime dons
15:42:29 <lambdabot> Local time for dons is Tue Nov 28 10:36:59 2006
15:42:35 <Pseudonym> Same time zone.
15:42:37 <vincenz> yeps
15:42:41 <vincenz> different time :)
15:44:56 <dobblego> @localtime dobblego
15:44:58 <lambdabot> Local time for dobblego is Tue Nov 28 09:39:30
15:45:19 <dobblego> and yet I am not east nor west than dons :)
15:45:36 <glguy> ?. vixen protontorpedo
15:45:37 <lambdabot> Ooh, functional programmers are so hot!
15:45:47 <glguy> ?. vixen protontorpedo
15:45:47 <lambdabot> Ooh, functional programmers are so hot!
15:45:52 <glguy> =\
15:45:59 <dons> clearly dobblego is stuck in some kind of time vortex
15:46:18 <sjanssen> @where dobblego
15:46:19 <lambdabot> I know nothing about dobblego.
15:46:27 <vincenz> @quote sjanssen
15:46:27 <lambdabot>  @djinn Haskell -> Curry
15:46:28 <dobblego> I woke up one morning and they'd all changed the clocks one me!! I swear it
15:46:31 <vincenz> @quote vincenz
15:46:32 <lambdabot>  Binkley: the sex is all in the operational semantics, denotational semantics only deals with love
15:46:53 <dobblego> funny, for APLAS I booked the wrong flight at first, because APLAS was held *after* fiddling with the clock and I booked my flight before it
15:53:11 <glguy> that's enough for me, night all
15:53:13 <dons> this 'Why Haskell?' article is getting repicated all over. its come up on at least 4 other non-haskell sites now
15:53:29 <dons> ?users
15:53:30 <lambdabot> Maximum users seen in #haskell: 276, currently: 241 (87.3%), active: 41 (17.0%)
15:54:16 <sjanssen> > replicate 4 "Why Haskell?"
15:54:17 <lambdabot>  ["Why Haskell?","Why Haskell?","Why Haskell?","Why Haskell?"]
15:54:28 <dons> made it to 'OS news' and from there all over
15:54:43 <sjanssen> > repeat "Why Haskell?" -- hopefully
15:54:44 <lambdabot>  ["Why Haskell?","Why Haskell?","Why Haskell?","Why Haskell?","Why Haskell?",...
15:54:51 <greg_lundien> is there a library function in haskell to convert from decimal to binary??
15:54:57 * shapr haskelldots the whole world
15:55:17 <vincenz> dons: yeah, I removed google blog search "haskell" from my google personalized homepage due to spam
15:55:19 <sjanssen> @hoogle showIntAtBase
15:55:20 <lambdabot> Numeric.showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
15:55:35 <vincenz> Anyone have any comments on my entry on continuations?
15:55:39 * vincenz vies for comments on his blog
15:55:39 <greg_lundien> sjanssen: thanks
15:55:52 <dons> vincenz: I use 'haskell programming' and 'haskell language' with additional blocks on spam sites
15:56:10 <sjanssen> > showIntAtBase 100 (head . show) 2 ""
15:56:11 <lambdabot>  "2"
15:56:30 <sjanssen> > showIntAtBase 2 (head . show) 100 ""
15:56:31 <lambdabot>  "1100100"
15:57:04 <dons> greg_lundien: why do you need to convert to binary?
15:57:23 <kpreid> > showIntAtBase 2 Char.intToDigit 100 ""
15:57:24 <lambdabot>  "1100100"
15:57:42 <greg_lundien> dons: uh... long story? do you know how to do it?
15:58:29 <vincenz> all ints are binary
15:58:37 <greg_lundien> the showIntAtBase thing doesn't work with guys
15:58:45 <vincenz> only with girls?
15:58:47 <greg_lundien> *with hugs, not guys
15:58:50 <greg_lundien> lolz
15:58:54 <dons> :m + Numeric
15:58:56 <Cale> import Numeric
15:58:59 <greg_lundien> oic
15:59:01 <dons> ?hoogle showIntAtBase
15:59:02 <lambdabot> Numeric.showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
15:59:15 <dons> hey ms_
15:59:17 <dons> how's code?
15:59:36 <greg_lundien> cant import numeric
15:59:50 <dons> ah well
15:59:57 <sjanssen> probably using an ancient Hugs
15:59:58 <dons> perhaps that was for the best
16:00:07 <dons> but Numeric should be h98 ?
16:00:08 <vincenz> @localtime vincenz
16:00:09 <Cale> > reverse . map (`mod` 2) . takeWhile (/= 0) . iterate (`div` 2) $ product [1..10]
16:00:11 <lambdabot>  [1,1,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,0,0,0]
16:00:14 <vincenz> @where vincenz => office
16:00:14 <lambdabot> http://www.esat.kuleuven.ac.be/~cpoucet/
16:00:41 <dons> ?let toBinary = reverse . map (`mod` 2) . takeWhile (/= 0) . iterate (`div` 2)
16:00:42 <lambdabot> Defined.
16:00:51 <Cale> er, he left?
16:00:57 <sjanssen> dons: I don't think it is H '98
16:01:51 <Cale> > reverse . L.unfoldr' (/= 0) (`mod` 2) (`div` 2) $ 10
16:01:52 <lambdabot>  Not in scope: `L.unfoldr''
16:02:00 <Cale> > reverse . L.unfoldr (/= 0) (`mod` 2) (`div` 2) $ 10
16:02:01 <lambdabot>  Not in scope: `L.unfoldr'
16:02:03 <sjanssen> at least the Hugs November 2003 installed on my uni's server doesn't have Numeric
16:02:04 <Cale> hmm, gone
16:02:10 <sjanssen> I should bug them about installing GHC
16:02:16 <vincenz> @type unfoldr
16:02:17 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
16:02:22 <dons> sjanssen: huh.
16:02:23 <SamB_XP> > showIntAtBase 1 (-1)
16:02:24 <lambdabot>  add an instance declaration for (Num (Int -> Char))
16:02:35 <Cale> vincenz: I had a local unfoldr with a different type
16:02:39 <dons> > showIntAtBase 1 (-1) []
16:02:40 <lambdabot>  add an instance declaration for (Num (Int -> Char))
16:03:02 <vincenz> > unfoldr (\x -> if x == 0 then Nothing else Just divMod x 2) 10
16:03:03 <lambdabot>    The function `Just' is applied to three arguments,
16:03:03 <lambdabot>   but its type `a -...
16:03:11 <vincenz> > unfoldr (\x -> if x == 0 then Nothing else Just $ divMod x 2) 10
16:03:12 <lambdabot>  [5]
16:03:18 * sjanssen spoke too soon, Numeric is there
16:03:20 <SamB_XP> > showIntAtBase 2 ("01"!!) (-1)
16:03:22 <lambdabot>  <[Char] -> [Char]>
16:03:33 <SamB_XP> > showIntAtBase 2 ("01"!!) (-1) ""
16:03:35 <lambdabot>  Exception: Numeric.showIntAtBase: applied to negative number -1
16:03:36 <vincenz> > divMod 2 5
16:03:37 <lambdabot>  (0,2)
16:03:44 <vincenz> > divMod 5 2
16:03:45 <lambdabot>  (2,1)
16:04:00 <vincenz> > unfoldr (\x -> if x == 0 then Nothing else Just $ curry (flip (,)) $ divMod x 2) 10
16:04:01 <lambdabot>  Couldn't match `(a, b)' against `b1 -> a1 -> (a1, ((b, b), b1))'
16:04:09 <vincenz> @type flip(,)
16:04:10 <lambdabot> forall a b. b -> a -> (a, b)
16:04:19 <vincenz> > unfoldr (\x -> if x == 0 then Nothing else Just $ uncurry (flip (,)) $ divMod x 2) 10
16:04:21 <lambdabot>  [0,1,0,1]
16:04:41 <vincenz> @pl \x -> if x == 0 then Nothing else Just $ uncurry (flip (,)) $ divMod x 2
16:04:41 <lambdabot> ap (flip if' Nothing . (0 ==)) (Just . uncurry (flip (,)) . flip divMod 2)
16:05:20 <vincenz> @type (\x -> guard (x==0) >> return $ uncurry (flip(,)) $ divMod x 2)
16:05:22 <lambdabot> forall a (m :: * -> *). (MonadPlus ((->) (a, a)), Monad m, Integral a) => a -> m (a, a)
16:05:30 <vincenz> @pl (\x -> guard (x==0) >> return $ uncurry (flip(,)) $ divMod x 2)
16:05:31 <lambdabot> ap ((>> return) . guard . (0 ==)) (uncurry (flip (,)) . flip divMod 2)
16:05:34 <vincenz> :/
16:06:00 <vincenz> > unfoldr (\x -> guard (x==0) >> return $ uncurry (flip(,)) $ divMod x 2) 100
16:06:01 <lambdabot>  add an instance declaration for (MonadPlus ((->) (b, b)))
16:09:40 * vincenz wishes for a modDiv function
16:10:20 <vincenz> > reverse . unfoldr (\x -> guard (x/=0) >> (Just . uncurry (flip(,)) $ divMod x 2)) $ 100
16:10:21 <lambdabot>  [1,1,0,0,1,0,0]
16:17:47 <Cale> unfoldr is awkward
16:18:26 <Cale> Which is a shame. It would be nice if we had a language where things like folds/unfolds/etc. were automatic.
16:18:51 <Cale> (and not awkward to use, like explicit fixed points usually make thingss)
16:22:57 <shapr> Cale: How could they be automatic?
16:23:28 <Cale> Well, there's an "obvious" fold implementation for most algebraic data types
16:24:04 <shapr> expliquez?
16:24:07 <Cale> It takes replacement functions for each of the constructors, and simply walks through the structure replacing them
16:24:24 <Cale> for example
16:24:37 <sjanssen> you want automatic derivation of folds and unfolds?
16:24:39 <shapr> Is this sort of like Traversable?
16:24:40 <SamB_XP> what about a polymorhic-recursive ADT?
16:24:47 <SamB_XP> er. add a p somewhere.
16:25:09 <Cale> data Nature a = Rock a | Stream a (Nature a) | Tree (Nature a) (Nature a)
16:25:35 <Cale> foldNature rock stream tree (Rock a) = rock a
16:26:01 <Cale> foldNature rock stream tree (Stream a n) = stream a (foldNature rock stream tree n)
16:26:22 <Cale> foldNature rock stream tree (Tree n1 n2) = tree (foldNature rock stream tree n1) (foldNature rock stream tree n2)
16:27:12 <Cale> (that's easier to write with case and let, I just think it gets the point about mechanicalness across better that way)
16:28:01 <Cale> and of course, if you use another functor in the process, you're going to map the fold over that functor
16:28:11 <Cale> for instance...
16:28:27 <Cale> data Rose a = Nil | Branch a [Rose a]
16:28:39 <Cale> foldRose n b Nil = n
16:29:09 <Cale> foldRose n b (Branch x rs) = b x (map (foldRose n b) rs)
16:29:20 <SamB_XP> Cale: that doesn't look polymorphic recursive...
16:30:28 <dons> hmm. did people spot this: http://thread.gmane.org/gmane.comp.lang.haskell.glasgow.user/11297/focus=11297
16:30:31 <lambdabot> Title: Gmane Loom, http://tinyurl.com/yyw6s4
16:30:35 <Cale> SamB_XP: could you explain what you mean?
16:30:40 <dons> successfully created create dynamic loadable libraries (.so) with GHC 6.6 under Linux X86
16:30:48 <Cale> shapr: does that make sense?
16:31:08 <SamB_XP> dat Foo a = Bar a | Baz (Foo [a])
16:31:15 <SamB_XP> er. s/dat/data/
16:31:18 <SamB_XP> how do you fold that?
16:31:30 <Cale> You can build this sort of thing generically if you represent the type-level fixed point explicitly
16:32:11 <shapr> Cale: Yeah, I get it. It's an fmap instance for each constructor, right?
16:32:23 * shapr saw a picture of Cale on livejournal! wow!
16:32:25 <dobblego> what is a good article explaining the difference between the "thing" and the "abstract concept of the thing"?
16:32:43 <dobblego> as in "2 is a representation of twoness"
16:32:59 <dobblego> what's that idea called?
16:33:21 <Pseudonym> shapr: He's THAT good looking, eh?
16:34:05 <shapr> Pseudonym: It's more that I've been unable to find a pic of Cale for years.
16:34:15 <Pseudonym> Ah.
16:34:19 <Cale> shapr: it's been on my website for a while now
16:34:24 <Cale> (the same picture)
16:34:33 <twanvl> dobblego: You should look under Plato
16:34:37 <Cale> http://cale.yi.org/index.php/Main_Page
16:34:39 <Philippa> shapr: whose LJ?
16:34:46 <dobblego> twanvl, ok thanks
16:35:51 <Philippa> I figure most of the stalkers've found mine by now - that, or don't know how to STFW :-)
16:36:49 <dobblego> twanvl, any more keywords?
16:38:21 <Cale> dobblego: There's not much to it really. You have a formal system specifying axioms for these symbolic "statements" about the natural numbers. The '2' in that system is not the same as two apples, simply because it's not two apples, it's a formal symbol, if you want, it's a mark on a page.
16:39:09 <Cale> The way in which that '2' corresponds to the "two" in "two apples" is a matter of science.
16:39:16 <twanvl> dobblego: http://en.wikipedia.org/wiki/Platonic_idealism is what I was thinking of
16:39:18 <lambdabot> http://tinyurl.com/k4ame
16:39:56 <dobblego> ok thanks
16:40:21 <Cale> Counting things and placing objects next to each other empirically behaves a lot like the addition operation of natural numbers. Well enough that we can make predictions about how many objects there will be when we count them using our formal system.
16:43:45 <Cale> SamB_XP: Good question -- perhaps you need higher rank types.
16:45:03 <SamB_XP> Cale: of course you do
16:45:36 <SamB_XP> Cale: but if, say, the dog comes along and eats one?
16:45:48 <Cale> huh?
16:45:53 * shapr chews on a type
16:45:55 <SamB_XP> heh
16:45:57 <SamB_XP> sorry
16:46:04 <SamB_XP> um, those were on different topics
16:46:12 <thetallguy> data Gum?
16:46:16 <SamB_XP> first one was re: higher-rank types
16:46:51 <SamB_XP> the second about natural numbers and their relationship to counting collections of real objects...
16:46:52 <Cale> Oh, the objects being eaten
16:47:04 <Cale> well, you can talk about predecessors and so on
16:47:30 <SamB_XP> oh, I thought that might count as something that isn't covered in the model ;-)
16:47:51 <Cale> That's why we use natural numbers to count things, they support the operations which we usually want in order to describe what happens with objects under counting.
16:47:57 <boulez> Cale: if you have a set of mutually-recursive datatypes, you get a set of mutually-recursive fold functions?
16:48:03 <SamB_XP> I'd like to see proof that 2+2 isn't 4 sometime ;-)
16:48:12 <Cale> boulez: I suppose you do :)
16:48:36 <boulez> is that the correct nomenclature? 'the' fold is a set of folding functions?
16:48:37 <greentea> SamB_XP: Hm, i may be able to help you with that, moment.
16:49:07 <Cale> boulez: well, we're really talking about catamorphisms
16:49:17 <eviltwin_b> if you pick the right mathematical axioms...
16:49:36 <SamB_XP> I meant in real life ;-)
16:49:37 <Cale> I could just define 2 + 2 to be 3 and define 3 not to be equal to 4
16:50:05 <Cale> They're just symbols, and can be put to other good uses :)
16:50:10 <SamB_XP> or any other difference between the real world and naturals
16:50:22 <SamB_XP> (naturals being the usual naturals)
16:50:39 <Cale> SamB_XP: Well, there are certainly real-world situations where it's inappropriate to use natural numbers.
16:50:55 <Cale> For example, consider angles.
16:51:06 <SamB_XP> well it isn't the best way to model electromagnetic fields, I'm sure ;-)
16:51:22 <greentea> Cale: You don't even need to redefine '2' - you can use talk about 2 + 2 in base 3 instead. :-)
16:51:29 <Cale> yeah, try assigning a natural number to every electromagnetic field :)
16:51:45 <SamB_XP> greentea: I was using decimal notation...
16:52:00 <SamB_XP> Cale: I thought they used quaternians or something like that
16:52:29 <greentea> SamB_XP: Oh, /now/ you tell us. ;-)
16:52:48 <Cale> greentea: well, 4 wouldn't even make sense at all then
16:53:02 <greentea> Cale: True.
16:53:50 <greentea> But then there's the question of the structure that 2 + 2 is taking place in, of course.
16:54:22 <SamB_XP> I said the naturals!
16:54:30 <Cale> Quaternions are used as a convenient way to represent orientations together with scaling factors in 3-D space, though they have the problem that every orientation has two quaternions which represent it.
16:54:57 <eviltwin_b> 2 + 2 != 4 if you can't pass 3.  consider the speed of light as an example of that in the real world
16:55:02 <SamB_XP> Cale: polar coordinates are worse!
16:55:02 <Cale> But they have the really nice advantage that multiplication corresponds rather nicely with composition of rotations.
16:55:09 <Cale> indeed
16:55:11 <greentea> Hm, so what's the 'natural' stucture for the naturals?
16:55:34 <SamB_XP> isn't it Peano arithmatic?
16:55:42 <Cale> yeah, Peano's axioms
16:55:49 <greentea> Ah, okay.
16:55:58 <Cale> 1. Zero is a number
16:56:13 <Cale> 2. If n is a number then so is Sn, the successor of n.
16:56:24 <Cale> 3. Zero is not the successor of another number.
16:56:33 <Cale> er, of any number
16:56:57 <psnl> Cale: er, you don't need the third rule, surely?
16:57:02 <Cale> 4. Sn = Sm if and only if n = m
16:57:17 <SamB_XP> yeah, surely not!
16:57:31 <Cale> 5. If a set S of numbers contains 0, and also the successor of every number in S, then every number is in S.
16:57:34 <eviltwin_b> psnl: strictly, you do; rule 1 doesn't rule out there being a predecessor to zero, and rule 2 can be run backwards
16:57:39 <greentea> So addition is defined in terms of iterations of successors then?
16:57:42 <SamB_XP> sure it does
16:57:58 <Cale> There's no way to rule out 0 being equal to the successor of 2
16:58:02 <SamB_XP> you can't match the Zero constructor against an S pattern ;-)
16:58:36 <Cale> and of course, there exist systems which satisfy all the rest of the axioms except that one
16:58:45 <Cale> namely, modular arithmetic
16:58:52 <eviltwin_b> there's your problem; it's not a pattern (unles syou use the G-E-B implementation of it :> )
16:59:06 <SamB_XP> ah ;-)
16:59:10 <Cale> Even in GEB, that was an axiom
16:59:13 <Excedrin> Zeron
16:59:26 <Cale> That's the axiom that lets you treat it like a pattern
16:59:27 <SamB_XP> it was listed, but how did it fit into the system?
16:59:27 <eviltwin_b> sure, because G-E-B wasn't implemented as a haskell pattern match
16:59:50 <eviltwin_b> (well, it was a patern match, but not a haskell pattern match)
16:59:53 <Cale> In Haskell, datatypes just automatically satisfy a bunch of axioms similar to that
17:00:01 <SamB_XP> I still can't figure out how to implement PC in Haskell
17:00:15 <Cale> In fact, that wasn't always the case -- for a while, there were non-free types in Haskell and Miranda.
17:00:36 <SamB_XP> well of course there are non-free types in Miranda
17:00:54 <SamB_XP> but in Haskell of course everything is available under the MIT license, so it is all free ;-)
17:01:07 <Cale> *groan*
17:01:08 <Cale> hehe
17:01:15 <eviltwin_b> anyway, in the absence of #3 you cannot *prove* that there is no number whose successor is zero inside the system; therefore it must be stated as an axiom.  (or as the negation of the axiom, leading to a different system)
17:02:08 <Cale> Interestingly, there's no axiom which says that every number is either zero or the successor of a number.
17:02:09 <eviltwin_b> s/\*prove\* (.) inside the system/\*prove\* inside the system \1/
17:02:11 <SamB_XP> see, we wouldn't have this problem if we called the Fooble and Zlorp instead of Zero and Succ
17:02:25 <eviltwin_b> there doesn't need to be; #1 and #2 are the definition of number
17:02:29 <eviltwin_b> in effect
17:02:34 <Cale> No, there could be others.
17:02:53 <eviltwin_b> not within the system described by those rules, in the system of mathematical reasoning
17:02:55 <Cale> There are nonstandard models of Peano arithmetic :)
17:03:36 <Cale> There's no way to prove from those axioms that forall n. (n = 0) or (exists m. n = Sm)
17:04:45 <eviltwin_b> no, the system assumes a specific framework of mathematical reasoning.  if you modify that framework you again get a different system
17:04:54 <Cale> I'm not modifying anything
17:05:03 <eviltwin_b> the framework it assumes considers #1 and #2 to be a definition of number
17:05:13 <SamB_XP> no
17:05:29 <Cale> Let me write them more formally.
17:05:47 <SamB_XP> it lets you go and write your own axioms
17:06:38 <Cale> exists x. Zero(x)
17:07:07 <Cale> forall x. exists y. y = Sx
17:08:02 <Cale> Zero(z) => not (exists x. z = Sx)
17:08:37 <Cale> Sx = Sy => x = y
17:08:49 <eviltwin_b> cale: I'd argue that the only reasoning supported by that system is that described by the axioms; as such, #1 and #2 *are* what, in a more general framework, would be translated as forall n. (n = 0) or (exists m. n = Sm)
17:09:06 <eviltwin_b> but the framework does not support making that statement, t's far too simple
17:09:24 <Cale> eviltwin_b: No, most of the time that's not considered an axiom of Peano arithmetic
17:09:40 <Excedrin> what's Reader?
17:09:40 <Cale> However, it doesn't really matter all that much, because you have induction.
17:10:21 <Cale> Excedrin: a monad which lets you distribute a global environment into blocks of code
17:11:03 <Cale> Actually, I should probably be translating them somewhat differently.
17:11:23 <Cale> 1. exists 0. Number(0)
17:11:46 <Cale> 2. forall n. Number(n) => Number(Sn)
17:12:10 <Excedrin> oh, so it's different from State because it's global?
17:12:12 <Cale> 3. forall n. not (Sn = 0)
17:12:31 <Cale> Excedrin: no, it's different in that you can't write the state
17:12:42 <Cale> it's exactly like the state monad except you can't change the state
17:13:23 <Cale> or hmm
17:13:26 <Excedrin> ok, then Writer is like Reader, but write-only?
17:13:32 <Cale> 3. forall n. (Number n) => not (Sn = 0)
17:14:04 <Cale> Excedrin: sort of
17:15:05 <Excedrin> ok, I'm reading All About Monads again, maybe now it will stick
17:15:31 <Cale> Excedrin: With writer, there's a specified combining operation and zero value for the type (See Data.Monoid), and you make updates to the state by using 'tell', which combines the value you give with the current state
17:15:43 <Cale> (and you can't observe the state from inside, right)
17:16:48 <Cale> However, there is listen :: (MonadWriter w m) => m a -> m (a,w)
17:17:39 <greentea> So why would one use Writer without also using Reader?
17:17:49 <Cale> For logging
17:17:58 <Cale> or for maintaining probabilities :)
17:17:59 <Cale> hehe
17:18:07 <SamB_XP> Cale: that isn't a state, that is more of a report...
17:18:09 <Cale> (that's a bit obscure)
17:18:23 <Cale> SamB_XP: right
17:18:48 <SamB_XP> I'm using it to output "moves"
17:18:59 * greentea ponders.
17:19:00 <Cale> You can writer-transform the list monad using the multiplicative monoid on the rationals
17:19:25 <dons> yeah, there's got to be some good cases for disallowing reads statically
17:19:34 <dons> not as many as disallowing writes , of course
17:19:40 <Cale> and what you get is a list monad which is suitable for maintaining the probability of making a given choice (provided that you enforce the rule that the probabilities in the lists you use sum to 1)
17:20:17 <Cale> (note that elements of the lists will be (value, Rational) pairs)
17:21:34 <Cale> hmm...
17:21:36 <Cale> @version
17:21:36 <lambdabot> lambdabot 4p282, GHC 6.5 (OpenBSD i386)
17:21:36 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:21:48 <dons> ?
17:21:54 <Cale> > mappend [1,2,3] [3,4,5]
17:21:56 <lambdabot>  [1,2,3,3,4,5]
17:22:10 <Cale> > mappend (Product (1/2)) (Product (3/4))
17:22:11 <lambdabot>  Not in scope: data constructor `Product'
17:22:15 <Cale> nope
17:22:51 <dcoutts> Igloo, cheers.
17:22:55 <Cale> any chance of moving to 6.6? :)
17:23:25 <dons> Haskell Weekly News it out! http://programming.reddit.com/info/sp2l/details
17:23:28 <lambdabot> Title: Haskell Weekly News: automated testing fever strikes! (reddit.com), http://tinyurl.com/ymy2ex
17:23:29 <dons> Cale: yes. very soon!
17:25:07 <tp76> This lambdabot sure is chatty.
17:25:34 <vincenz> @arr
17:25:35 <lambdabot> Swab the deck!
17:25:59 * vincenz feels ignored in the quotes :/
17:26:24 <dons> vincenz: oh, did I miss one?
17:26:34 <dons> there were so many i'm starting to edit for conciseness
17:26:43 <vincenz> no, nothing particular
17:26:52 <vincenz> I doubt you want the one regarding semantics :P
17:26:54 <vincenz> @quote vincenz
17:26:55 <lambdabot>  sure, give us your homework and we'll email it straight to your teacher :)
17:27:01 <dons> hehe
17:27:03 <vincenz> hmm
17:27:34 <kpreid> Earlier I asked "is there a monad transformer for backtraces?" -- a slightly modified (via newtype) ReaderT does the job
17:27:36 <vincenz> sadly, I haven't touched haskell code as of late, except helping some #haskellers
17:28:01 <vincenz> kpreid: ListT?
17:28:08 <kpreid> no
17:28:14 <vincenz> erm yes
17:28:16 <vincenz> ListT State
17:28:16 <kpreid> ListT is nondeterminism
17:28:22 <kpreid> I wanted a stack trace
17:28:23 <vincenz> what do you think backtracing is?
17:28:26 <vincenz> oh
17:28:27 <kpreid> so ReaderT's local is
17:28:28 <Cale> ListT is kind of broken
17:28:50 <kpreid> sorry, I used 'backtrace' from other contexts
17:28:53 <sorear> If we have a backtrace monad, won't it break the laws?
17:29:12 <kpreid> it only includes a 'stack' entry explicitly
17:29:13 <sorear> baz = do foo ; bar
17:29:23 <vincenz> how do you call a word that reads the same in both directions
17:29:25 <sorear> bar = do jar ; error "x"
17:29:31 <sorear> vs.
17:29:35 <Cale> vincenz: a palindrome
17:29:36 <dons> palindrome
17:29:37 <vincenz> thx
17:29:50 <sorear> baz = do foo ; jar ; error "x"
17:29:52 * vincenz is tired, 2:30 am, been up since early, paper writing (or trying to)
17:29:56 <sorear> monad law allowed change
17:30:04 <sorear> changes backtrace
17:30:05 <kpreid> sorear: because it's actually bar = trace "baz" $ do jar; error "x"
17:30:20 <Cale> I refer to pairs (x,y) of words such that x = reverse y, 'copalindromes'
17:30:27 <vincenz> :)
17:30:38 <kpreid> sorear: trace x (TraceT m) = TraceT $ local (x:) m
17:30:43 <vincenz> Cale: colin dromes
17:31:22 <Cale> Or how about Michael Palin dromes?
17:31:35 <ihope> Why copalindromes?
17:31:44 <sorear> this (TraceT) seems eerily similar to a problem I faced
17:31:58 <sorear> generate a random infinite tree (maze)
17:32:18 <sorear> my solution was a random monad with auto-forking
17:32:28 <ihope> Whee.
17:32:29 <sorear> or manual forking if the laws are sacred
17:32:32 <kpreid> the other key element of TraceT is defining 'fail' to incorporate the trace
17:32:33 <Cale> ihope: Well, for one, they're useful in building up longer palindromes from parts.
17:32:45 <vincenz> so they should be prepalindromes
17:32:53 <Cale> perhaps :)
17:32:59 <Cale> also, 'co' not in the sense of dual
17:33:13 <mbishop> anyone here have bellsouth internet?
17:33:20 <ihope> Yeah. If a palindrome is x such that x = reverse x, it would seem a copalindrome would be reverse x = x. :-)
17:33:24 <Cale> but in a similar sense to co- in 'cooperative'
17:33:31 <sorear> like coprime
17:33:36 <vincenz> Cale: like codependent
17:33:43 <vincenz> very cooperative :)
17:36:47 <emu> ghc just told me to panic
17:36:54 <sorear> how so?
17:37:05 <emu> apparently, the impossible happened
17:37:06 <SamB_XP> emu: no, I think GHC was panicing at you ;-)
17:37:28 <kilimanjaro> Yes. The portal has been opened....
17:38:06 <emu> linkBCO: >= 64k insns in BCO
17:38:39 <SamB_XP> that sounds a lot more possible than most impossibles
17:38:46 <dons> emu: nice
17:38:52 <SamB_XP> dons: is that a new one?
17:39:04 <dons> I've seen it before. Might even be fixed in newer ghcis
17:39:25 <SamB_XP> why should it be fixed in GHCis?
17:39:28 <emu> yea ghc itself seems to be ok with the file
17:39:32 <emu> ghci on the other hand
17:39:33 <SamB_XP> shouldn't it be fixed in the compiler?
17:42:02 <dons> SamB_XP: are you trolling ?
17:42:12 <SamB_XP> er, no.
17:42:29 <SamB_XP> I suppose that would be part of "GHCi" anyway...
17:42:40 <emu> i can get a darcs version of ghc and see if it still happens, i guess
17:42:53 <emu> ooh boy 6.7!!
17:43:08 <dons> SamB_XP: what did you think I meant by: "Might even be fixed in newer ghcis" ?
17:43:17 <dons> if not "fixed in the compiler?"
17:43:23 <vincenz> ghc != ghci
17:43:27 <SamB_XP> anyway, I was just thinking that maybe the bytecode gererator shouldn't make such big BCOs
17:43:32 <dons> same thing. different backend, vincenz
17:43:58 <vincenz> ...       ^^^^^^^^^
17:44:18 <dons> anyway, i've seen this bug reported before. it might even be fixed.
17:44:22 <SamB_XP> shapr was trolling in ##c the other day
17:44:25 <dons> hehe
17:44:28 <dons> shapr++
17:44:28 <Cale> oh?
17:44:32 <Cale> shapr++
17:44:37 <Cale> how was he trolling?
17:44:42 <vincenz> Cale++
17:44:50 <SamB_XP> he was asking if C supported ADTs and closures ;-)
17:44:50 <mbishop> ##C is made for trolling
17:45:00 <vincenz> SamB_XP: ask em about GADTS
17:45:06 <Cale> SamB_XP: hahaha
17:45:10 <Cale> Do we have logs?
17:45:29 <SamB_XP> know, I answer questions by saying "don't use C for that, use Haskell instead" -- I don't ask silly questions like that ;-)
17:45:32 <vincenz> either way, ##c and ##c++ are trolling grounds
17:46:35 <emu> was the error something along the lines of "this file is too big"?
17:46:48 <emu> because it has a lot of TH-expanded forms
17:50:38 <SamB_XP> I can only imagine it had a supercombinator that was too big
17:50:42 <SamB_XP> whatever one of those may be
17:51:06 <sorear> a supercombinator is a kind of function
17:51:19 <sorear> i don't recall the details
17:51:44 <vincenz> supercombinator is just a function
17:51:46 <jdev> A combinator that's fallen into a vat of radioactive goo and gotten superpowers?
17:51:47 <sorear> they are described in _The_Implementation_Of_Functional_Programming_Languages_, by SPJ
17:52:18 * vincenz wants a minicombinator
17:53:27 <boulez> (sjanssen): you want automatic derivation of folds and unfolds?
17:53:29 <boulez> yes
17:54:32 <sjanssen> boulez: show us the code! ;)
17:55:01 <boulez> I'm asking if there's something out there that generates folds automatically
17:55:23 <sorear> Wasn't that the subject of the 'Scrap your boilerplate ...
17:55:30 <sorear> ' series of articles?
17:55:39 <vincenz> or bringert's 2006 icfp paper
17:55:42 * sorear curses easy-to-hit enter key
17:55:47 <vincenz> boulez: check that paper, bringert 2006 icfp
17:55:51 <boulez> OK, thanks
17:55:55 <shapr> Is there some way to transfer data between two entangled photons?
17:55:56 <vincenz> forgot the name
17:56:05 <vincenz> shapr: seems not
17:56:39 <shapr> They're using photon entanglement for encryption, how does that work?
17:56:44 <vincenz> dunno
17:56:56 <vincenz> with lots of light most likely
17:57:00 <sorear> it's not so much encryption
17:57:10 <sorear> it is tamper evidence
17:57:27 <sorear> like those seals on food cans
17:57:41 <shapr> So, you can transfer information about whether a photon has been read or not?
17:57:49 <sorear> supposedly you can only read a photon once
17:57:53 <sorear> reading is impure
17:57:55 <vincenz> if a photon is read it loses its info
17:57:57 <eviltwin_b> if you do something to one member of a quantum-entangled photon pair, the other one does something similar
17:58:03 <vincenz> sorear: you mean non referentially transparent
17:58:09 <sorear> yes
17:58:14 <vincenz> or photonically in this case
17:58:31 <shapr> I was just thinking about a sci-fi story, and I wondered if quantum entanglement might be the next radio.
17:58:34 <eviltwin_b> so you keep one, send the other, and you know if the other was tamppered with.
17:58:48 <eviltwin_b> "reading" it requires tampering with it
17:59:26 <vincenz> I always wonder if the scientist that formulated those theories came to those conclusions because they assume we use other photons to "read"
17:59:34 <sorear> observation, in QM, invariably consists of observing the interaction of a particle with its environment
17:59:40 <eviltwin_b> ==sorear
17:59:44 <sorear> at least thats what i've hear
17:59:50 <sorear> d , (grrr)
17:59:58 <vincenz> yeah, but to me that seems a technical problem, not a theoretical one
18:00:08 <vincenz> what if you had a way to read a particle without interacting it against another particle
18:00:10 <Cale> http://www.experts-exchange.com/Web/Q_22031739.html -- haha, someone wants Rnd() to be referentially transparent :)
18:00:12 <eviltwin_b> the Heisenberg principle is about this.  it is in fact a theoretical issue
18:00:12 <lambdabot> http://tinyurl.com/ybeubd
18:00:24 <vincenz> eviltwin_b: not everyone agrees with its conclusions :)
18:00:38 <shapr> Wikipedia has http://en.wikipedia.org/wiki/Quantum_communication_channel
18:00:40 <lambdabot> http://tinyurl.com/y99vf7
18:01:18 <shapr> Back on topic, two previous clients of mine asked me about upgrading customized Zope installations. My response is to suggest HAppS.
18:01:33 <eviltwin_b> vincenz: if you have such a thing,  it's operating outside of current physics
18:02:03 <eviltwin_b> granted, there's a lot of theoretical physicists who think we're due to run into something like that...
18:02:05 <vincenz> eviltwin_b: maybe with string theory?
18:02:13 <eviltwin_b> ha.
18:02:20 <eviltwin_b> string "theory" isn't, really.
18:02:23 <vincenz> I think the whole heisenberg principle derives from the limitation involved with using photons
18:02:54 <dons> ?temp
18:02:55 <lambdabot> Maybe you meant: help tell time
18:02:56 <shapr> I shouldn't have asked, it's too off topic!
18:02:56 <eviltwin_b> it doesn't matter if you use photons or something else.  observation is a form of interaction
18:02:58 <dons> wrong chan :/
18:03:10 <vincenz> eviltwin_b: until we can find a way of observing without interacting :)
18:03:33 <eviltwin_b> good luck...
18:03:47 <shapr> Oh hey, does HaXml or HXT have a way to autoderive XML values for Haskell values?
18:04:07 * shapr wonders about the XmlContent typeclass...
18:05:11 <shapr> dons: Silly question, can you tell me what this is for? http://www.cs.helsinki.fi/u/ekarttun/haskell/EncodeBSL.hs I think it's about serializing lazy bytestrings, is that right?
18:05:13 <lambdabot> http://tinyurl.com/yjeyb2
18:05:45 <shapr> I also think that magic rule at the bottom is what musasabi was investigating when he disappeared...
18:06:00 * shapr wonders when Cthulhu got involved in rule based rewriting...
18:07:57 <vincenz> dons: suggestion: have lambdabot's @version give back "darcs get --partial ..."
18:08:15 <shapr> vincenz: fix it!
18:09:06 <vincenz> I can't even do a get partial
18:09:35 <dons> why?
18:09:59 <Excedrin> shapr: http://www.cs.york.ac.uk/fp/HaXml/Haskell2Xml.html
18:09:59 <dons> shapr: looks like it
18:10:02 <lambdabot> Title: HaXml: Haskell and XML, http://tinyurl.com/y4xq9x
18:10:15 * dons -> uni
18:11:11 <shapr> Excedrin: thanks
18:12:18 <sorear> [RIO] I've got a syntactically correct .cabal and a 7KiB .tar.gz, now what?
18:14:13 <shapr> Hm, I don't want to use DrIFT, and my app already requires TH, didn't danielsson or somebody write up a Template Haskell equivalent of DrIFT?
18:16:28 <sjanssen> @keal
18:16:28 <lambdabot> 99% of my book has been erased by faulty hdd's
18:17:36 <vincenz> @proton
18:17:36 <lambdabot> why haskell over lisp?
18:18:14 <newsham> question: is there a cleaner way to do this?  http://www.thenewsh.com/~newsham/x/quest.txt
18:18:37 <lispy> shapr: i've heard rumors of such a thing but never seen it
18:19:09 <newsham> i'm gonna end up having a lot of these things (translate string args to proper types and dispatch to real function) and i want it to be as simple as possible
18:19:19 <vincenz> newsham: yes, very easily
18:20:19 <newsham> awesome..  ok, so next question: what is that easier way ;-)
18:20:47 <sjanssen> newsham: which monad is getEvent in?
18:20:54 <sorear> ?type getEvent
18:20:56 <lambdabot> Not in scope: `getEvent'
18:20:56 <vincenz> newsham: this is all in maybe?
18:20:57 <newsham> Ev MyState Request Result
18:21:07 <newsham> (this is from HApps, btw)
18:21:22 <vincenz> that makes no sense
18:21:24 <vincenz> you don't return in that monad
18:21:31 <newsham> doLogin does.
18:21:37 <newsham> as does r200
18:21:38 <sjanssen> @type maybe
18:21:40 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
18:21:43 <vincenz> newsham: in the maybe event
18:21:55 <vincenz> oh, nm, it's an action :)
18:22:34 <newsham> yes.  doLogin is action  String -> String -> Ev MyState Request Result  (mystate and request are baked in state, result is the type to eventually be returned)
18:22:43 <sjanssen> newsham: I'd suggest using: maybe (r200 "invalid args") id $ do blah; blah; blah;
18:23:14 <lispy> r200?
18:23:20 <lispy> that's a lot of registers
18:23:26 <newsham> r200 = sresult 200
18:24:01 <vincenz> http://rafb.net/paste/results/lMeFM472.html
18:25:38 <shapr> lispy: http://permalink.gmane.org/gmane.comp.lang.haskell.template/341
18:25:41 <lambdabot> Title: gmane.comp.lang.haskell.template, http://tinyurl.com/yczkto
18:25:43 <newsham> maybe d f m   takes m and if it isJust returns f (fromJust m) else returns f d?
18:25:57 <vincenz> no
18:25:59 <vincenz> else just d
18:26:01 <vincenz> @type maybe
18:26:03 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
18:26:04 <vincenz> check the type ;)
18:26:10 <newsham> yah the type not tell me so much
18:26:15 <vincenz> yes it does
18:26:17 <vincenz> it takes a 'b'
18:26:19 <vincenz> and returns a 'b'
18:26:22 <vincenz> so it does not do (f d)
18:26:26 <newsham> yah, how is "b" a "Just d" ?
18:26:34 <vincenz> ...
18:26:40 <newsham> ahh, yah, f is from a to b.
18:26:43 <newsham> so cant take in d
18:27:13 <lispy> shapr: the attachments are a bit illegible though :(
18:28:18 <shapr> lispy: gnus is fine with them.
18:28:21 <shapr> lispy: http://www.scannedinavian.com/~shae/thderive/
18:28:23 <lambdabot> Title: Index of /~shae/thderive
18:28:27 <vincenz> @join #scheme
18:28:37 <newsham> ok, so the next question..   I'm gonna have another one that looks JUST LIKE this one, except it wont be "login" / doLogin, and the types and number of args will differ.
18:28:56 <newsham> aside from using TH, is there any way I can keep from having a lot of hand written code here?
18:29:07 <newsham> seems like they will be different enough that I cant factor out code
18:29:40 <newsham> all will be   arg1 <- lookMbRead rq "arg1"; arg2 <- ...;  doFunc arg1 arg2 ...
18:29:44 <sjanssen> newsham: have you seen liftM2?
18:29:54 <newsham> sjanssen: yup
18:29:54 <lispy> shapr: nice
18:30:29 <newsham> sjanssen: what about it?
18:30:48 <satan> simple lambda calculus question: does (\a -> \b -> b) c evaluate to \b -> b
18:31:06 <satan> since it takes in c as a, discards it and returns \b -> b?
18:31:17 <sjanssen> newsham: your code could be shortened to "maybe (r200 "invalid) id $ liftM2 doLogin (lookMbRead rq "user") (lookMbRead rq "pass")
18:31:19 <vincenz> sjanssen: yes
18:32:19 <lispy> maybe is often exactly the abstraction i need, but i'm not a huge fan ofit
18:32:34 <lispy> it's kinda hard to read a line with a big maybe and figure it all out
18:32:35 <sjanssen> lispy: huh?  how does that work?
18:32:48 <sjanssen> I see
18:33:16 <lispy> i do use it
18:33:23 <lispy> but, sometimes i feel like i'm making my code less clear ;)
18:34:56 <newsham> sjansen: ah.. yes, but that is just one case (two args).  consider (updated):  http://www.thenewsh.com/~newsham/x/quest.txt
18:34:58 <dobblego> ?hoogle Monad a b -> a -> b
18:35:00 <lambdabot> No matches, try a more general search
18:35:07 <newsham> I will have many of these with different number of args and different arg types
18:35:47 <sjanssen> newsham: liftM4? ;)
18:36:18 <newsham> hmm.. true.. but is that really cleaner?  basically the same thing.  hrm.. *ponders*
18:36:45 <vincenz> `apa`
18:36:47 <vincenz> `ap`
18:36:50 <vincenz> :)
18:37:17 <sjanssen> liftMK eliminates those superflous "arg1" variables
18:37:27 <newsham> yes.
18:38:22 <vincenz> @paste
18:38:22 <lambdabot> http://paste.lisp.org/new/haskell
18:38:32 <newsham> i wish i could code these in a generic way with a list of argument names and a dispatch function, but that seems impossible in the type system.
18:38:34 <sjanssen> new rule for Haskell: never give something a name unless it really, really deserves it
18:38:38 <vincenz> http://rafb.net/paste/results/5CsFkW75.html
18:38:48 <kpreid> > return (+) `ap` return 1 `ap` return 2 :: [Int]
18:38:50 <lambdabot>  [3]
18:39:18 <Excedrin> it's funny that computers are good at counting, but humans are required to count the number of arguments to liftMn
18:39:23 <newsham> ideally I'd like to say:   dispatchWithArgs doFunc1 ["arg1", "arg2"]
18:39:56 <newsham> excedrin: or zipN.
18:40:00 <sjanssen> Excedrin: variadic functions are tough in the presence of currying
18:40:01 <lisppaste2> vincenz pasted "remove the rq stuff" at http://paste.lisp.org/display/30842
18:40:22 <lispy> Excedrin: this is easy in lisp
18:40:28 <lisppaste2> vincenz annotated #30842 with "bugremoval" at http://paste.lisp.org/display/30842#1
18:41:31 <lisppaste2> vincenz annotated #30842 with "better" at http://paste.lisp.org/display/30842#2
18:42:16 <kpreid> the other possibility is for doFunc1 and doFunc2 to take lists of arguments
18:42:28 <lispy> ?type and
18:42:30 <lambdabot> [Bool] -> Bool
18:42:36 <lispy> and is a good example of that
18:42:53 <lispy> > and
18:42:54 <lambdabot>  <[Bool] -> Bool>
18:42:56 <lispy> > and []
18:42:57 <lambdabot>  True
18:43:04 <vincenz> newsham: like?
18:43:45 <lisppaste2> vincenz annotated #30842 with "compacter" at http://paste.lisp.org/display/30842#3
18:43:49 <newsham> vinc: can you be more verbose?
18:43:55 <vincenz> "you like"?
18:44:30 * vincenz points at the lisppaste2 url
18:44:45 <vincenz> btw
18:44:48 <newsham> hrm.. almost!  if I can define something to do   `ap` mbread rq name  in one go i'm happy!
18:44:49 <vincenz> your code can never work
18:44:54 <vincenz> how can mbread return different stuff?
18:45:17 <kpreid> vincenz: you lost lookMbRead being an action
18:45:18 <newsham> what code can never work?
18:45:23 <vincenz> kpreid: so?
18:45:27 <vincenz> kpreid: how can it return different types
18:45:32 <newsham> lookMbRead :: Read a => Request -> String -> Maybe a
18:45:36 <vincenz> ah
18:45:38 * vincenz nods
18:45:49 <newsham> <- doing the impossible.
18:46:12 <Cale> liftM's exist up to liftM4
18:46:13 <Cale> er
18:46:17 <Cale> liftM5 even
18:46:24 * vincenz prefers `ap`
18:47:04 <newsham> so if I make   foo name = (`ap` mbread rq name)   then I can do   func `foo` "arg1" `foo` "arg2"  ?
18:47:37 <sjanssen> newsham: almost
18:47:46 <sjanssen> foo x name = x `ap` mbread rq name
18:48:09 <lispy> mbread?
18:48:11 <lispy> make break?
18:48:14 <lispy> er bread
18:48:26 <shapr> Man, this TH deriving code is making my eyes cross...
18:48:31 <sjanssen> instance Monad Bake
18:49:18 <newsham> lispy: maybe read.  http://happs.org/auto/apidoc-0.8.4/HAppS-Protocols-MessageWrap.html
18:49:21 <lambdabot> http://tinyurl.com/yn9ssf
18:50:32 <lispy> am, mbRead
18:50:55 <newsham> err.. lookMbRead is what I'm using.
18:53:34 <newsham> now, what's a good name or symbol for this :)
18:55:30 <newsham> updated quest.txt with new operator (called "a" for now)
18:59:36 <greentea> Does anyone know if anyone is working on a Jabber/XMPP lib for Haskell?
19:00:10 <newsham> ?hoogle ap
19:00:11 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
19:00:12 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
19:00:12 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
19:05:08 <vincenz> sjanssen: won't work, monomorphism restriction
19:11:21 <emu> i'm on a roll today.  i caused a pattern match exhaustion failure in Data.Set.rotateL, an internal function
19:11:31 <sjanssen> vincenz: okay, add a type signature
19:11:42 <sjanssen> emu++
19:12:01 <newsham> sjanssen: so this is still a little confusing to me (not having played with ap much).  I get the gist of what's going on ("return doLogin" threw me for a loop at first).  but I cont figure out how to apply another function I want.
19:12:18 <newsham> I used to be able to do    "return ifLoggedIn $ doLogin user pass"
19:12:40 <newsham> now I want to somehow incorporate "ifLoggedIn" into the (return doLogin) `a` "user" `a` "pass"
19:12:41 <sjanssen> what are the types of doLogin and ifLoggedIn?
19:13:07 <newsham> doLogin :: String -> String -> fancy-monad-thingy
19:13:27 <sjanssen> @hoogle when
19:13:28 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
19:13:28 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
19:13:45 <sjanssen> newsham: is ifLoggedIn in the same fancy monad?
19:13:50 <newsham> ifLoggedIn :: Ev MyState Request Result -> Ev MyState Request Result
19:14:21 <newsham> ifLoggedIn fetches internal state, checks if logged in, if not, returns a redirect action, else returns the arg (action)
19:14:50 <newsham> doLogin :: [Char] -> [Char] -> Ev MyState Request Result
19:14:59 <sjanssen> newsham: you want ifLoggedIn $ return doLogin etc.
19:15:30 <newsham> but "return doLogin ..." is gonna be Maybe (Ev MyState Request Result)    right?
19:15:42 <sjanssen> oh, right
19:15:57 <sjanssen> fmap ifLoggedIn $ return doLogin ...
19:16:15 <newsham> hrm.. starting to feel awkward now.
19:16:37 <newsham> compiles though.
19:17:01 <sjanssen> return (\x y -> ifLoggedIn (doLogin x y)) ... -- is an alternative
19:18:14 <newsham> if i push the "fmap" into the "ifLoggedIn" its not as ugly.
19:18:30 <newsham> is there an easy way to get rid of the "return" in "return doLogin"?
19:18:55 <newsham> I would like this code to be somewhat obvious when read, but "ap" and "fmap" still arent very obvious to me.
19:19:25 <LoganCapaldo> you could put the return inside doLogin no?
19:19:49 <newsham> yup.. except thats one place I want to keep even simpler.
19:19:56 <newsham> since I'll be writing lots of doFuncs
19:20:00 <sjanssen> newsham: there aren't really any great alternatives
19:20:06 <newsham> *nod*
19:20:20 <sjanssen> newsham: does the Ev monad provide any error catching facilities?
19:20:21 <LoganCapaldo> doLogin1 = ...; doLogin = return doLogin perhaps?
19:20:32 <LoganCapaldo> err
19:20:36 <LoganCapaldo> you get the idea
19:20:38 <newsham> sjanssen: havent seen any yet.. the docs are rather light..
19:20:54 <sjanssen> this is HAppS, yeah?
19:21:25 <lambdabot> Local time for vincenz is Tue Nov 28 04:15:46 2006
19:21:33 <newsham> yes
19:21:57 * vincenz might have found a way to crash lambdabot 
19:21:59 <sjanssen> perhaps we should ask shapr what he knows about the Ev monad?
19:22:51 <vincenz> dons: ping
19:23:12 <augustss> haskell think would right which should monad could something function
19:23:32 <augustss> haskell think would right which should monad could something function
19:24:08 <dons> hehe
19:24:09 <augustss> ?users
19:24:09 <lambdabot> Maximum users seen in #haskell: 276, currently: 235 (85.1%), active: 34 (14.5%)
19:24:09 <dons> vincenz: ?
19:24:26 <vincenz> dons: check @tell in private
19:24:31 <vincenz> just finished typing :)
19:24:49 <augustss> dons: i like the weird channel statistics :)
19:25:13 <dons> augustss: weird?
19:25:20 <dons> vincenz: ok. very interesting. i'll have to think about this.
19:25:30 <vincenz> dons: possibly a timeout mechanism
19:25:40 <dons> vincenz: yep. there's none currently. nice idea.
19:25:42 <dons> vincenz
19:25:44 <augustss> well, with random quotes, sad people, happy people
19:25:44 <dons> vincenz++
19:25:58 <dons> oh, the irc stats
19:26:00 <dons> yeah :)
19:26:03 <dons> ?where stats
19:26:04 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
19:26:13 <vincenz> I'd try it myself, but I always have issues getting lambdabot built, and I'm currently 4:20am working on a paper
19:26:15 <dons> (I thought you meant ?users)
19:26:20 <augustss> and, of course, the list of popular words!
19:26:21 <dons> vincenz: ok. that's fine.
19:26:26 <dons> augustss: yeah, very nice eh?
19:26:39 <augustss> very
19:29:05 <vincenz> dons: there's one simple way to fix it
19:29:36 <dons> vincenz: oh?
19:29:39 <vincenz> dons: KEep a reverse map (Map requestor [requestee]) as well and only each person to only keep X requests
19:29:43 <vincenz> the only way to beat that is to cycle nicks
19:29:48 <dons> vincenz: good idea
19:29:49 <vincenz> which swould either have to happen in a channel
19:29:54 <vincenz> or they'd need a shitload of nickserv regs
19:30:00 <vincenz> cause you can't pm on freenode unregged
19:30:01 <newsham> can I make a prefix operator (punctuation) in haskell?
19:30:31 <vincenz> newsham: no
19:30:35 <dons> newsham: maybe... there's prefix sections in ghc now...
19:30:40 <vincenz> oh
19:30:42 <dons> and there's okasakis _postfix_ paper
19:30:44 <vincenz> neat :)
19:30:56 <dons> but i've not seen prefix done for arbitrary functions. it may not be feasible
19:30:58 <newsham> so its not a standard haskell thing but might exist
19:31:22 <dons> right. it might require a patch to the parser :)
19:31:39 <vincenz> newsham: why does it have to be an operator?
19:31:44 <vincenz> newsham: just pick a singleletter function name
19:35:16 <vincenz> @type maybe
19:35:17 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:35:22 <vincenz> @type M.lookup
19:35:23 <lambdabot> Couldn't find qualified module.
19:35:35 <vincenz> @type Data.Map.lookup
19:35:37 <lambdabot> forall a (m :: * -> *) k. (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
19:40:17 <Excedrin> is there an efficiency difference between List.partition and (\f l -> (filter f l, filter (not . f) l)) ?
19:41:00 <dons> partition p xs = foldr (select p) ([],[]) xs
19:41:01 <dons> select p x ~(ts,fs) | p x       = (x:ts,fs)
19:41:01 <dons>                     | otherwise = (ts, x:fs)
19:41:07 <Excedrin> oh... List.partition is defined as that
19:41:07 <Excedrin> nevermind
19:41:49 <dons> your filter walks the list twice, doesn't it?
19:43:23 <sjanssen> Excedrin: both O(n), but the filter will do about twice as much work
19:47:38 <Excedrin> oh, jhc's libraries are different from GHC's
19:49:08 <Excedrin> what's the ~ ?
19:49:21 <dons> lazy pattern
19:49:48 <greentea> Could anyone direct me to a good GHCi tutorial?
19:50:27 <dons> > let f (x,y) = 1 in f undefined
19:50:29 <lambdabot>  Undefined
19:50:32 <dons> > let f ~(x,y) = 1 in f undefined
19:50:34 <lambdabot>  1
19:50:44 <dons> greentea: GHCi tutorial? i.e. how to use the repl?
19:50:49 <greentea> *nod*
19:51:06 <dons> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci.html
19:51:07 <greentea> i could only find a bare bones page on the HaskellWiki.
19:51:08 <lambdabot> Title: Chapter 3. Using GHCi, http://tinyurl.com/y6xlby
19:51:24 <greentea> Oh foo. *slaps forehead*
19:51:29 <greentea> Thanks. *blush*
19:51:36 <dons> :)
19:57:37 <shapr> @where diki
19:57:37 <lambdabot> I know nothing about diki.
19:58:49 <dons> araujo: i notice this page is missing a few of the translated articles? http://haskell.org/haskellwiki/HWN/es
19:58:51 <lambdabot> Title: HWN/es - HaskellWiki
19:59:17 <dons> is it too much work?
20:01:38 <dons> can someone with ghc 6.7 reproduce this: http://www.haskell.org/pipermail/cvs-ghc/2006-November/032875.html
20:01:40 <lambdabot> Title: ghc (HEAD) cannot parse multi-line comment, http://tinyurl.com/y4vwu6
20:03:27 <LoganCapaldo> dons: If I wanted to try and use Yi as an editor, (and not as an example of Haskell source code) would I want the release or the development branch, if you don't mind my asking?
20:05:16 <dons> LoganCapaldo: i'd take the darcs repo
20:05:30 <dons> and yeah, you can use it as a decent vi (a few do, i've heard)
20:05:40 <LoganCapaldo> dons: thanks
20:06:16 <Korollary> Does yi use ByteString?
20:07:17 <dons> i belive so, though only for a few things
20:07:28 <dons> (its buffer type was written before the advent of fps)
20:07:35 <Korollary> ah
20:08:39 <Korollary> there are easily 1000 text editors out there.
20:08:59 <newsham> hmm.. lookMbRead is not working as I had expected it to.
20:09:04 <newsham> anyone here familiar with HAppS?
20:09:26 <Lemmih> shapr is, I think.
20:09:31 <undone> would it be inappropriate to suddenly join this channel and expect to quickly learn haskell?
20:09:34 <newsham> ?seen shapr
20:09:35 <lambdabot> shapr is in #scannedinavian, #haskell and #ScannedInAvian. I last heard shapr speak 11m 58s ago.
20:09:56 <Korollary> undone: quickly depends on you. You can expect good answers, though.
20:10:09 <undone> hmmm, probably asking a bit much
20:10:17 <undone> exam tomorrow :(
20:10:28 <emu> i joined here and suddenly I have a PhD
20:10:31 <sieni> undone: I don't think anyone finds it inappropriate if you quickly learn haskell
20:10:35 <dons> undone: hmm, you can try!
20:10:41 <sjanssen> dons: would you use ByteString for the buffer if you were writing Yi today?
20:10:43 <dons> > map (+1) [1..10] -- let's get started!
20:10:44 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
20:10:48 <dons> sjanssen: i think so, yes
20:10:54 <dons> a buffer would be a [ByteString]
20:10:57 <dons> one per line
20:11:02 <shapr> undone: Yeah, if you have lots of enthusiasm, I'm sure it'll work for you.
20:11:04 <dons> rather than one big mutable byte arr
20:11:07 <monochrom> I can read a crash course and quickly learn. No interaction with other people necessary. YMMV.
20:11:12 <shapr> newsham: you screamt?
20:11:28 <dons> undone: visit http://haskell.org for tuts and so on
20:11:29 <lambdabot> Title: Haskell - HaskellWiki
20:11:38 <dons> undone: and install hugs or ghc
20:11:42 <shapr> newsham: What questions do you have?
20:11:44 <undone> have hugs
20:11:51 <undone> i've been "learning" haskell for the last 10 weeks or so
20:11:56 <sjanssen> dons: that's how Yi works now?  inserting a single char at the beginning is O(n) wrt the size of the file?
20:11:56 <undone> then the exam hits and i realise i know nothing
20:12:21 <monochrom> "When you find out that you know nothing, you can get a MSc."
20:12:22 <newsham> shapr: I'm trying to fetch an argument.  so I do "rq <- getEvent".  now if I do "lookS 100 rq "var"" I'm gettin gthe value I place in the url
20:12:39 <newsham> but if I do (lookMbRead rq "var") :: (Maybe String)    I'm always getting Nothing
20:12:47 <shapr> undone: Well, this is a good place to learn. I dunno about passing your exam after one night of studying, but you can learn lots here on #haskell
20:12:55 <newsham> isnt lookMbRead rq "var"   supposed to return the value?
20:13:10 <undone> well the questions don't seem overly difficult
20:13:13 <undone> we have a sample paper
20:13:25 <newsham> oh!  blah!  I just ralized that to read String, it need quotes.
20:13:26 <newsham> blah.
20:13:29 <sieni> sjanssen: Perhaps it uses a gap at the insertion point, like I guess emacs does
20:13:36 <shapr> undone: You've already learned an important principle, non-strict evaluation!
20:13:45 <undone> heh
20:14:03 <newsham> hrmm.. so Read is not quite what I want right now.
20:14:05 <shapr> newsham: Hey, I was able to help you find the answer!
20:14:05 * shapr cheers
20:14:06 <monochrom> hahahahaha
20:14:08 <dobblego> given a function f of type A -> B -> C, how does a function of type A -> (A -> B -> C) look defined in terms of f?
20:14:12 <newsham> shapr: thanks anyway :)
20:14:16 * shapr grins
20:14:58 <undone> well sample paper is http://www.computing.dcu.ie/~mhearne/FP/lab_exam_sample.txt
20:15:01 <lambdabot> http://tinyurl.com/y4bxrt
20:15:13 <undone> gotta love tinyurl
20:15:26 <sieni> dons: I guess you are familiar with the buffer gap approach, but have you seen this: http://vmlinux.org/jocke/editor/txt/buffer-gap.txt ?
20:15:28 <lambdabot> http://tinyurl.com/wu4eo
20:15:32 <monochrom> g a a' b c = f (head [a,a']) b c
20:15:42 <undone> i remember all these little bits of code from what i've done in labs, but can't write functions :(
20:16:18 <shapr> undone: time to start bit fiddlin
20:16:21 <dobblego> monochrom, why head [a, a']? isn't that just a?
20:16:31 <undone> shapr: yay.
20:16:39 <monochrom> need to make sure a and a' have the same time, as you have overspecified.
20:17:25 <Excedrin> re, gap buffers: http://p-cos.net/lisp-ecoop/submissions/StrandhVilleneuveMoore.pdf
20:17:27 <dobblego> I'm just trying to define a function in terms of another where I wish to write only the B -> C part
20:17:28 <lambdabot> http://tinyurl.com/yhqwp3
20:18:03 <shapr> Would a 2-3 Finger Tree be good for a buffer datatype?
20:18:25 <undone> anyway, for example first question asks me to swap every second element in an array, i have only the vaguest idea of how to go about that
20:18:43 <sjanssen> shapr: I'm pondering that right now
20:19:01 <vincenz> 2-3 finger-trees are good for sequences
20:19:23 <monochrom> So the correct question is "given f::A->B->C, write g::B->C using f"?  Or is it "given f::B->C, write g::A->B->C using f"?  Or ...?
20:19:56 <shapr> I wonder how Lazy ByteStrings, SGI's ropes, and 2-3 Finger Trees would compare...
20:20:03 <undone> as do i
20:20:28 <shapr> undone: Do you know how to make an array in Haskell?
20:20:58 <sjanssen> I think I'd use something like "data Buffer = B {aboveLines, belowLines :: Sequence ByteString, currentLine :: FastMutableByteArrayOfSomeSort}"
20:21:48 <undone> shapr: well, not exactly. i know if i'm taking one in then the program will start with something like swap :: [Int] -> [Int]
20:21:57 <shapr> What's the user mode that allows reception of privmsgs from unidentified nicks?
20:22:02 <undone> althought it's not just for Ints
20:22:04 <monochrom> [Int] is an array?!
20:22:14 <undone> maybe?
20:22:19 <shapr> undone: I suspect you need to start by figuring out how to build an array then.
20:23:01 <shapr> undone: Did you save any source from the labs?
20:23:03 <Korollary> This looks interesting: http://programming.reddit.com/info/so4y/comments/cspiy
20:23:06 <lambdabot> Title: Does type inference have to suck? (reddit.com), http://tinyurl.com/yyk6wc
20:23:08 <monochrom> I want to pick on the wording of question 1 "swap every second element".
20:23:16 <undone> shapr: source?
20:23:25 <shapr> Korollary: short answer is that he wants type slicing
20:23:39 <shapr> undone: Yeah, you said you'd done Haskell labs, so I assume you had some source code at some point, right?
20:24:44 <undone> well there were a few examples of functions and things, if that's what you mean
20:24:56 <shapr> Cool, do you have them?
20:25:19 <sorear> q
20:25:31 <Korollary> shapr: I don't care about that. The link I posted points to a slime-like thing for haskell
20:25:55 <undone> shapr: well most of it's online, but notes and things were poor, they really left us all to figure it out by ourselves
20:25:56 <Korollary> it needs comments badly, though
20:26:32 <shapr> undone: Awright, it's online, wouldn't your next step be to read through it and see if you can recall anything that was done in the labs?
20:26:54 <undone> shapr: well if you want to be logical about it...
20:27:02 <undone> :)
20:27:29 <monochrom> A prerequisite of programming anything...
20:27:29 <shapr> Well, I have code of my own to write...
20:27:33 <monochrom> is to be logical about it.
20:27:59 <Korollary> except when it's about business logic
20:28:02 <shapr> There's also random hacking.
20:28:32 <monochrom> For crying out loud, random hacking does not require human intervention.
20:28:40 <undone> shapr: notes aren't overly good. no worries though. there's a repeat exam next week anyway i think. might try to actually learn something for that...
20:28:44 <Korollary> monkeys and typewriters?
20:28:45 * shapr grins
20:28:56 <shapr> undone: Isn't now a good time to start?
20:29:48 <undone> now is 4.23 am in the morning, class tomorrow starts at 9, so i guess not
20:30:06 <kilimanjaro> that's 4 hours of solid work
20:30:10 <undone> heh
20:30:11 <kilimanjaro> get cracking
20:30:13 <undone> i've done that before
20:30:15 * shapr grins
20:30:16 <monochrom> repeat exam?!
20:30:17 <vincenz> @localtime vincenz
20:30:20 <lambdabot> Local time for vincenz is Tue Nov 28 05:24:38 2006
20:30:32 <undone> monochrom: well if you fail, you get a second chance with less marks on offer
20:30:40 <monochrom> Oh ah.
20:30:45 <vincenz> sounds like a coding-bid-site
20:30:58 <kilimanjaro> vincenz: that has no correlation with phallic size
20:31:13 * vincenz peers at kilimanjaro 
20:31:21 <kilimanjaro> (how early in the morning it is has no correlation)
20:31:25 <kilimanjaro> nevermind
20:31:30 <undone> anyway there was a link posted when i joined, will have a look when i get some time
20:31:31 * vincenz is working on a paper
20:31:47 <undone> actually, out of curiosity
20:31:53 <undone> what do you guys actually use haskell for?
20:32:01 <undone> like, what kind of programs?
20:32:10 <greentea> Okay, so i've read the chapter on GHCi, and it didn't tell me what i needed to know: how can i specify the type signature of a function i'm about to define?
20:32:10 <kilimanjaro> undone: umm, haskell is used to perpetuate haskell
20:32:11 <vincenz> haskell compilers
20:32:19 <shapr> I get paid to write Haskell.
20:32:24 <undone> nice
20:32:27 <greentea> undone: i'm trying to put together a Jabber client.
20:32:45 <vincenz> I've written a couple of interpreters
20:32:52 <shapr> I have a bunch of unfinished projects, but I've contributed code to lambdabot among other things.
20:33:05 <shapr> I'm working on a research paper annotation tool right now.
20:33:06 <greentea> Although i'm very much a noob, i need to build an app to help me really get to know a language.
20:33:06 <undone> jabber client seems useful
20:33:14 <vincenz> shapr: oh?
20:33:22 <shapr> greentea: smart
20:33:35 <shapr> vincenz: Yeah, Fermat's Last Margin. We've discussed it before, remember?
20:33:38 <vincenz> shapr: seen my latest entry?
20:33:46 <vincenz> shapr: ah yeah, we have, I thought FLM was blog-based, however :)
20:33:47 <undone> hmmm, well i find it somewhat interesting, if awkward
20:33:53 <shapr> vincenz: Igloo recently wrote a darcs backed wiki, so now I'm stealing it...
20:34:00 <vincenz> nifty
20:34:18 <kilimanjaro> I'd like to write a video game in haskell
20:34:29 <shapr> vincenz: Nah, FLM is all about having a wiki in a darcs repo, and then pulling changes from other people who have their own wiki repo.
20:34:33 <monochrom> I am currently using Haskell for call-with-current-continuations, in short code in which control is jumping around like crazy.
20:34:36 <undone> kilimanjaro: can that really be done with it?
20:34:45 <vincenz> monochrom: seen my call/cc blog-entry?
20:34:48 <kilimanjaro> undone: sure
20:34:51 <monochrom> No.
20:34:59 <shapr> undone: Someone wrote Quake clone in Haskell already.
20:35:07 <undone> got a link?
20:35:09 <vincenz> one is on pure cont's, the other on DCs
20:35:12 <kilimanjaro> undone: there are opengl bindings for ghc
20:35:12 <vincenz> http://notvincenz.blogspot.com/
20:35:13 <greentea> undone: There are gpackages available to access OpenGL, for example.
20:35:35 <greentea> And X11.
20:35:45 <undone> interesting
20:35:49 <shapr> undone: http://www.haskell.org/haskellwiki/Frag
20:35:51 <lambdabot> Title: Frag - HaskellWiki
20:36:02 <undone> it was presented to us as being mostly useful for teaching good programming style
20:36:06 <shapr> And SDL
20:36:18 <shapr> undone: Silly teachers
20:36:27 <shapr> It kicks butt for writing real applications.
20:36:30 <greentea> shapr: Ah, didn't know there were SDL bindings.
20:36:41 <sjanssen> shapr: to be fair Haskell /is/ good at demonstrating good style
20:36:45 <greentea> Or i haven't been observant enough. :-)
20:36:58 <shapr> I've done VB, Java, Python and more... I am SO happy to get paid to write Haskell now! I can write better code in a smaller amount of time.
20:37:02 <sjanssen> but it's excellent at just about everything else, too
20:37:24 <dobblego> monochrom, given f::A -> B -> C, write g :: (B -> C) -> A -> (A -> B -> C)
20:37:28 <vincenz> monochrom: comments welcome :)
20:37:32 <undone> well i'm coming from java
20:37:36 <monochrom> Well Haskell is good for both learning and doing.  Nothing wrong with that.
20:37:48 <undone> it's very different
20:37:54 <undone> scary, even
20:37:54 <vincenz> @type (flip . flip)
20:37:55 <shapr> Truly
20:37:56 <lambdabot> forall a b c. (b -> a -> c) -> b -> a -> c
20:38:11 <shapr> undone: Ever tried to do unit testing with J2EE?
20:38:24 <undone> nope :)
20:38:26 <vincenz> dobblego: const (const f)
20:38:38 <shapr> undone: (In Java) Ever had a value change when you weren't expecting it?
20:38:53 <undone> not when it wasn't my fault
20:39:05 <undone> i'm not overly advanced in java
20:39:12 <vincenz> dobblego: or simply: g = flip
20:39:13 <undone> college student, you know
20:39:30 <kilimanjaro> i think i'm lucky, the only language I have used in the past 1 1/2 years is Scheme (with some bits of C and prescheme mixed in). learning haskell hasn't been that rough :)
20:39:42 <dobblego> vincenz, actually g is of type A -> (A -> B -> C) where g provides the implementation of B -> C
20:39:47 <shapr> I got started with Java when it was in beta, I still get the value changing surprise.
20:40:02 <shapr> Solution? Don't let values change!
20:40:03 <undone> what causes it?
20:40:04 <kilimanjaro> the biggest hurdle was just learning the syntax
20:40:05 <monochrom> One thing I don't understand is the two parameters of type A.
20:40:09 <dobblego> I have written a compiler plugin to disallow x=y in Java
20:40:12 <vincenz> monochrom: seen the entry
20:40:18 <vincenz> ?
20:40:23 <dobblego> my code will only run on IBM JVM (with tail call elim)
20:40:27 <vincenz> dobblego: write a compiler to disallow java
20:40:32 <monochrom> Well it will take an hour!
20:40:38 <vincenz> monochrom: what will?
20:40:40 <Korollary> ?karma java
20:40:41 <lambdabot> java has a karma of -13
20:40:43 <monochrom> your entry
20:40:45 <vincenz> java--
20:40:47 <vincenz> monochrom: WHAT?!?
20:40:50 <shapr> Have you ever mistyped a loop, or started at one when you should have started at zero, or vice versa? Solution? Don't do that! Make a combinator!
20:40:58 <dobblego> monochrom, I want to return a function of type A -> B -> C given an A
20:41:19 <vincenz> dobblego: const id
20:41:34 <dobblego> ?type const
20:41:35 <lambdabot> forall a b. a -> b -> a
20:41:42 <greentea> Hm.
20:41:45 <vincenz> @type const id
20:41:46 <greentea> ?karma perl
20:41:46 <lambdabot> forall a b. b -> a -> a
20:41:47 <lambdabot> perl has a karma of -1
20:41:58 <kilimanjaro> ?karma scheme
20:41:59 <greentea> How is this karma determined?
20:41:59 <lambdabot> scheme has a karma of 0
20:42:03 <vincenz> A = 'b', B = 'a', C = 'a'
20:42:07 <shapr> undone: The biggest cause of surprising value change is threading. It's really hard to get threading right. Solution? Use Software Transactional Memory!
20:42:08 <dobblego> greentea, by the programming gods
20:42:21 <sjanssen> dobblego: does Sun have a bug tracker?  File "No tail call elimination" as a JVM bug and see what happens :)
20:42:28 <dobblego> sjanssen, it's been there since 2002
20:42:37 <Excedrin> ?karma greentea
20:42:38 <lambdabot> greentea has a karma of 0
20:42:41 <undone> shapr: quite the solution, that
20:42:44 <Excedrin> greentea++
20:42:46 <Excedrin> ?karma greentea
20:42:47 <lambdabot> greentea has a karma of 1
20:42:49 <dobblego> sjanssen, http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4726340
20:42:52 <greentea> Excedrin: Ah. :-)
20:42:52 <lambdabot> Title: Bug ID: 4726340 RFE: Tail Call Optimization, http://tinyurl.com/ybx6ht
20:43:00 <eviltwin_b> not only do they have one, but other people can vote for bugs to theoretically increase their priority
20:43:05 <shapr> undone: Anyway, I could go on at great length about parts of Java, VB, Python, etc that have irritated me. Haskell isn't perfect, but it bugs me much less than anything else. I would like to use Epigram, but it's not yet production ready...
20:43:06 <vincenz> LOL: State   In progress, request for enhancement
20:43:08 <monochrom> Because it's full of Scheme.  When I read Scheme code I fill in my own type inference.  Now type inference is like 2^2^N so I figure it'll take my brain an hour.
20:43:27 <undone> shapr: epigram is?
20:43:40 <undone> a new functional language of some sort i assume
20:44:04 <Excedrin> http://www.e-pig.org/
20:44:07 <lambdabot> Title: Epigram
20:44:12 <shapr> undone: It's a crazy language that takes the same size step as from Java to Haskell, but again..
20:44:23 <kilimanjaro> Haskell has alot of muscle behind it, at least compared to most other "modern" programming languages
20:44:50 <shapr> undone: And the next step past that is pull programs directly from mathematical proofs. Have you heard of the Curry-Howard correspondance?
20:45:04 <undone> nope, maths is not my strong point
20:45:19 <shapr> undone: Not mine either, I never had any CS classes at all...
20:45:23 <dobblego> computer programming is a specialisation of maths
20:45:27 <vincenz> monochrom: your constants are too big
20:45:37 <shapr> undone: But there is some powerful beauty to be found in the world around Haskell.
20:45:46 <kilimanjaro> dobblego: math is a specialisation of logic
20:45:48 <Excedrin> shapr: isn't that already possible with Coq (and maybe a few others, Hol)?
20:45:53 <undone> dobblego: true.
20:46:03 <monochrom> logic is a specialisation of computing.
20:46:08 <undone> heh
20:46:25 <kilimanjaro> computing is a specialisation of living
20:46:38 <shapr> Excedrin: Yeah, if you don't mind your resulting programs representing all math with Church numerals.
20:46:47 <monochrom> Thus, ability to write Haskell programs is passing the Turing test.
20:47:03 <monochrom> And no, not all humans pass the Turing test.
20:47:11 <shapr> Excedrin: Even church numerals are an optimization for most proof extraction tools.
20:47:27 <undone> i think i'll go to bed
20:47:36 <shapr> undone: Anyway, you should drop by when you've had sleep
20:47:41 <undone> will idle here for a bit, maybe make an effort to actually learn it
20:47:44 <shapr> undone: There's some amazingly cool stuff here
20:47:54 <kilimanjaro> undone: it will make you hate your CS program
20:47:58 <Excedrin> shapr: is it possible to mechanically replace all of the math parts with native math?
20:48:16 <shapr> undone: But it'll make you love programming
20:48:19 <undone> i'm slighly more capable than i may have the impression i am, i may pass.
20:48:25 <undone> *have given
20:48:28 <shapr> Excedrin: Yeah, you just have to teach the system (Coq, Hol, etc) how to do it :-)
20:48:42 <undone> shapr: well that would be nice, i'm starting to hate java
20:48:57 <shapr> Excedrin: In the paper I read, one of the axioms that dramatically sped up the resulting program was that 0 < 1
20:48:58 <monochrom> If you hate java or c++ or ...  you have hope.
20:49:02 <dobblego> feel free to contribute to its karma
20:49:10 <dobblego> and monochrom's for that comment
20:49:14 <kilimanjaro> shapr: That's always a good one to have :)
20:49:44 <undone> java--
20:49:52 <shapr> undone: In my experience, Java is manager oriented programming. It's designed to let programmers be interchangeable cogs. It doesn't work though, because that's not reality.
20:49:58 <Excedrin> ?karma python
20:49:59 <lambdabot> python has a karma of 0
20:50:25 <monochrom> Hahahahaha Dibert's substitutability principle...
20:50:27 <shapr> undone: When you get a chance, read my favorite research paper of all time - http://alistair.cockburn.us/index.php/Characterizing_people_as_non-linear,_first-order_components_in_software_development
20:50:28 <lambdabot> http://tinyurl.com/y4qmjx
20:50:42 <Korollary> lol
20:50:43 <undone> if ever a link needed a tinyurl that was it
20:51:03 <shapr> monochrom: I hadn't heard of that, is that really what it's called?
20:51:11 <undone> will do if i find time
20:51:11 <monochrom> No I'm making it up.
20:51:52 <undone> i haven't really written any real programs yet, still fairly basic so i'm hardly qualified to judge languages
20:52:04 <monochrom> Liskov's substitutability principle.  A subclass should work as a drop-in replacement of its superclass.
20:52:11 <monochrom> (Liskov's is real.)
20:53:12 <monochrom> Dilbert's substitutability principle.  A subclass's programmer should work as a drop-in replacement of his/her predecessor.   (This one I'm making it up.  The "Dilbert" part refers to management principles.)
20:53:46 <shapr> monochrom: I think you've made up a lasting principle.
20:53:52 <shapr> I shall immediately document it on my blog.
20:54:03 <monochrom> Recall that I am full of wisdom.
20:54:14 * shapr recalls
20:54:24 <monochrom> @remember monochrom Dilbert's substitutability principle.  A subclass's programmer should work as a drop-in replacement of his/her predecessor.
20:54:28 <kilimanjaro> shapr: How is java "designed" to let programmers be interchangeable cogs? How is this different from haskell?
20:55:14 <undone> i smell a debate
20:55:22 <undone> goodnight!
20:55:24 * shapr structures his thoughts...
20:55:29 <lisppaste2> dobblego pasted "Better" at http://paste.lisp.org/display/30854
20:55:30 <undone> *idles*
20:55:30 <shapr> g'night undone
20:55:34 <shapr> come back soon!
20:55:39 <dobblego> monochrom, I have tried to express my problem more accurately
20:55:46 <undone> i'll stay here, screen is a wonderful thing
20:55:57 <undone> bye
20:55:58 <monochrom> As an example, Perl prevents programmers from being interchangeable. XD
20:56:11 <vincenz> dobblego: easy
20:56:22 <dobblego> I really would see it on any other day
20:56:25 <shapr> kilimanjaro: Two things immediately come to mind (I'm sure I can come up with more).
20:56:26 <vincenz> h _ _ = g
20:56:47 <kilimanjaro> Java certainly was designed to be mainstream, even to steal away C++ programmers. But the interchangeable part... do you think writing Java code is easier than writing Haskell code?
20:57:33 <shapr> Yes, Haskell lets you dramatically change the behaviour of your code. Java does not.
20:57:49 <kilimanjaro> Java just stumbled upon this cog thing. It was a byproduct of the being the right thing at the right time (no, I don't think Java is the right thing, but management and CS programs around the world have that self-sustaining opinion).
20:58:05 <shapr> Furnished libraries are all final, you don't get to change the broken Date class in Java, but you can always rely on it being broken just that same way at every company.
20:58:43 <sjanssen> dobblego: one answer is "h _ = const g"
20:59:04 <kilimanjaro> shapr: What's the difference? If a company wants to use a different date class, they can use a different date class.
20:59:11 <vincenz> sjanssen: already said that :)
20:59:22 * sjanssen is too slow
20:59:32 <kilimanjaro> shapr: Ok, I see your point about this, since it would break compatabilit with the rest of the APIs
20:59:44 <shapr> I'd like to argue that Java's public/private/protected is similar, but Haskell has the same thing. One difference is that I've never seen Haskell protecting something via exports unless the hidden code does bad things to the program. So maybe that's a community thing. Hm.
21:00:04 <sjanssen> dobblego: your example is a bit strange ... there doesn't seem to be any way for h to use that Int parameter, because g doesn't use Int
21:00:11 <dobblego> I think I have made a mistake - in the problem description - which clarifies my confusion
21:00:29 <shapr> On the other hand, Haskellers are encourage to use unsafeCoerce and unsafePerformIO when they're sure it's a good thing.
21:00:35 <kilimanjaro> shapr: Do you mean just not exporting a function?
21:00:51 <kilimanjaro> (re: your statement about the module system)
21:01:16 <shapr> Well, like "module Foo ( MyType, typeConstructor )" mean that you can't access the type constructors, you can only use the given function to do it.
21:01:41 <shapr> I ran across a case recently where that was necessary (URL comparison needs to be case insensitive).
21:01:43 <kilimanjaro> Ahh. Sorry, I'm inexperienced when it comes to Haskell
21:01:58 <kilimanjaro> And with Java :)
21:02:21 <shapr> I have several years experience with Java, but not so much with Haskell.
21:02:40 <dobblego> same
21:02:51 <shapr> As in, I got paid to write Java for years, but I've only been doing commercial Haskell for a few months.
21:03:01 <dobblego> I habe unfortunate entry on my resume as writing the implementation along with the certifications
21:03:04 <kilimanjaro> Who do you work for?
21:03:17 <dobblego> IBM
21:03:19 <dobblego> used to
21:03:20 <shapr> There's a big difference between code done for fun and for work.
21:03:32 <shapr> I work for HAppS
21:03:58 <dobblego> HAppS is a company?
21:04:07 <shapr> dobblego: Did you work on the JVM?
21:04:13 <shapr> dobblego: Yeah, HAppS LLC
21:04:15 <dobblego> shapr, the JCE implementation
21:04:43 <shapr> What does that stand for?
21:04:48 <dobblego> cryptography
21:04:54 <dobblego> Java Cryptography Extension
21:05:00 <dobblego> java.security.*
21:05:06 <shapr> I can think of at least two possibilities..
21:05:06 <shapr> oh!
21:05:14 <newsham> can I make a multi-line string literal in haskell?
21:05:20 <shapr> I used cryptix for an RFC3161 implementation that failed miserably.
21:05:29 <shapr> newsham: not really
21:05:30 <dobblego> where is the HAppS LLC website?
21:06:00 <kilimanjaro> http://happs.org/HAppS/README.html ?
21:06:01 <lambdabot> Title: HAppS -- Haskell Application Server (version 0.8.4 )
21:06:17 <dons> sjanssen, yeah O(n) (but its a memmove, so still beats vi/emacs up to around 20M buffers or so, from memory)
21:06:20 <dobblego> that looks like a README for an application server to me, but what would I know?
21:06:28 <dons> but yeah, i'd just use a linked list of (immutable) bytestrings now
21:06:55 <kilimanjaro> dobblego: well, that's what happs.org redirects to
21:07:11 <dobblego> yes I know
21:07:26 <dobblego> HAppS to me, has always been the Haskell Application Server
21:07:39 <dobblego> yet HAppS LLC doesn't turn up much
21:07:40 <kilimanjaro> maybe they plan to do consulting work or something
21:08:23 <dobblego> maybe they don't have a website
21:08:50 <kilimanjaro> outrageous
21:08:56 <dobblego> wtf is LLC anyway?
21:09:02 <emu> limited liability corp
21:09:07 <kilimanjaro> yea
21:09:32 <kilimanjaro> it's somewhere between proprietorship and s-corp on the spectrum
21:09:48 <dobblego> well, I can't turn anything up
21:10:43 <kilimanjaro> Maybe they are part of the Haskell Underground
21:10:53 <kilimanjaro> black market functional programming
21:10:55 <dobblego> which further arouses my curiosity :)
21:11:22 <dons> kilimanjaro: you mean the Haskell Cabal (n.b. there is no Haskell Cabal... I never said anything)
21:12:04 <kilimanjaro> dons: Well, at least I know what to call it if it did exist
21:12:17 <kilimanjaro> dobblego: Maybe shapr is making a website right now
21:12:27 <dobblego> that's what I was thinking :)
21:12:43 <dobblego> he will come back in 30 minutes with this nice website
21:13:41 <dobblego> ?type flip
21:13:42 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
21:13:42 <kilimanjaro> but he needs an alibi for those 30 minutes
21:13:58 <dobblego> he will just say that HAppS LLC employees take regular breaks
21:14:04 <kilimanjaro> "Sorry guys, I had to go gather some lumber or the troops will get cold"
21:14:04 <dobblego> he will even write that on the website
21:14:20 <dobblego> "At HAppS LLC, we take regular 30 minute breaks"
21:14:44 <kilimanjaro> What's a break from haskell hacking?
21:15:48 <kilimanjaro> I guess basketball would be pretty fun
21:16:18 <dobblego> I am playing squash in 80 minutes
21:16:25 <kilimanjaro> I'm fly fishing right now
21:16:46 <dobblego> well duh, all Haskell programmers do that
21:17:02 <Pseudonym> I fish without bait while coding Haskell.
21:17:05 <dons> dobblego: funny. i'm playing in 45 mins
21:17:06 <dobblego> gotta keep those Java guys feeling useful
21:17:12 <Pseudonym> That way I won't be distracted by catching anything.
21:17:26 <dobblego> dons, where boots? I went to one at Surry Hills (sp?)
21:17:30 <emu> bug-squash?
21:17:47 <dons> dobblego: at unsw gym
21:17:56 <dobblego> nice
21:17:59 <dobblego> I wish I was at uni
21:18:04 <dons> makes it easy, just wander down the hill
21:18:05 <dobblego> I think I'm gunna
21:18:21 <dobblego> a couple of unis play in my competition
21:18:34 <kilimanjaro> I'd like to go to grad school, if I ever get out of this BS alive
21:18:36 <dobblego> "away" games get me thinking
21:19:24 <kilimanjaro> dobblego: do you have a degree?
21:19:36 <dobblego> yes, just the basic Bachelor
21:20:13 <dobblego> I signed up for post-grad last year and was ready to go, but my sister got sick an things changed
21:20:23 <dons> shapr: does HAppS use implicit params?
21:20:32 <dons> I see alexj talking about them in passnet
21:20:41 <dobblego> don't disturb shapr while he is writing the HAppS LLC website!
21:20:42 <dons> i'd be interested in knowing why they're being used
21:20:50 <dons> ah oops
21:20:54 <eviltwin_b> heh
21:21:01 <dobblego> and fly fishing
21:21:52 <kilimanjaro> most phd programs pay students a stipend for research or something, right?
21:22:20 <dobblego> I just want to do fun stuff and have a squash court "just around the corner"
21:22:27 <dobblego> but dunno otherwise
21:22:48 <kilimanjaro> being a grad student couldn't be that bad of a job
21:23:38 <dons> its great!
21:23:54 <lambdabot> I LOVE GRAD STUDENTS!
21:24:03 <dons> cute, lambdabot
21:24:16 <kilimanjaro> dons: do you get a stipend of some sort?
21:24:20 <dons> yup
21:24:31 <kilimanjaro> is that pretty much standard for phd students?
21:24:44 <dons> sjanssen: oh, we've ordered the 8 socket, 16 core box now. hopefully it'll be here before the xmas break...
21:24:51 <dons> kilimanjaro: at least here, yeah
21:24:59 <dons> though helps to have a supervisor with project funding...
21:26:01 * monochrom shivers
21:26:46 <kilimanjaro> does lambdabot have a feature that lets me message somebody who is not currently in channel?
21:27:04 <int-e> @help tell
21:27:05 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
21:30:25 <monochrom> @tell vincenz (define k (call/cc call/cc)) is crazy!  But I've figured it out by rewriting as (define k (call/cc (\m -> call/cc (\n -> m n)))).
21:30:25 <lambdabot> Consider it noted.
21:30:31 <monochrom> That's an example.
21:45:52 <dons> does anyone know whether case is ever signficant in field labels in cabal files?
21:46:07 <newsham> yay, this happs stuff isnt half bad :)
21:46:36 <dons> newsham: blog about it!
21:46:37 <dons> :)
21:46:40 <monochrom> I have solved the type equation t = a -> ContT r IO t !  :)
21:46:57 <dons> monochrom: example?
21:47:24 <monochrom> newtype Whee r a = Whee (a -> ContT r IO (Whee r a))
21:47:31 <dons> mmm :)
21:47:53 <monochrom> I use it in a convoluted implementation of "yield".
21:48:14 <newsham> sorry, no  blog here.
21:48:29 <newsham> perhaps I'll have some code to share in a week or two
21:48:49 <dons> Lemmih: is the PackageDescription data type the type of .cabal file data?
21:48:55 <dobblego> dons, I vaguely recall it was once - was it hs-source-dirs?
21:48:58 <dons> ah yes. it is.
21:49:05 <dons> dobblego: hmm.
21:49:22 <dobblego> actually I'll be able to figure it out, one sec
21:49:35 * dons tries to digest cabal in one sitting
21:49:50 <newsham> i was thinking of using XSLT for presentation.. but after struggling to get XSLT to let me have decomposable components (figured it out but not worth the pain), I decided to go with Text.Html for the time being.
21:50:09 <emu> hs-Source-Dirs worked for me
21:50:11 <newsham> which means I have a super powerful template language (haskell), but the html is kinda non-standard lookng (haskell :)
21:50:31 <dobblego> dons, I take it back (I think)
21:50:58 <dobblego> actualy I am using Hs-Source-Dirs quite happily
21:51:20 <dons> can you try all upper case...
21:51:56 <dobblego> works fine
21:52:04 <dons> hehe . ok. good
21:52:28 <dobblego> I think maybe once I thought it was the problem, but it wasn't or something
21:53:32 <dmead> ?ghc
21:53:33 <lambdabot>  even with cunning newtype deriving the newtype is recursive
21:53:44 <dmead> xDD
21:54:29 <Excedrin> newsham: what's a decomposable component?
21:54:51 <dmead> anyone know if you can tell ghci to save a stand alone binary?
21:55:43 <Cale> dmead: no
21:55:49 <dmead> =(
21:55:55 <Cale> dmead: you run ghc for that
21:55:58 <dmead> cause that would be totally hot =p
21:56:01 <Cale> why?
21:56:09 <Cale> what could you even do with that?
21:56:11 * johnnowak burns himself
21:56:16 <dons> dmead: nope. can't do it
21:56:39 <dmead> it would save some time
21:56:59 <Cale> really?
21:57:12 <dmead> i think ;o
21:57:14 <Cale> what would it save in the binary?
21:57:31 <Cale> a copy of the running ghci?
21:58:26 <dmead> hmm
21:58:39 <eviltwin_b> a shell script which invoked ghci on a here-document containing a dump of ghci's current "memory"?
21:58:43 <dmead> it would automatically compile a binary with the module and options you've got loaded in memory
21:58:44 <eviltwin_b> (yug)
21:59:35 <dmead> can someone point me to an example of a simple ghc app?
21:59:43 <dmead> i'm trying to port some of my code from hugs
21:59:50 <dmead> and i've never used it
21:59:58 <Excedrin> main = PutStrLn "Hello"
22:00:05 <Cale> with lowercase p
22:00:12 <Excedrin> yes, that
22:00:22 <dmead> k =p
22:00:44 <monochrom> In the old days a lisp interpreter is built thusly.  First somehow you have a minimal executable.  Then you run it and define some more functions (by hand or by redirection), and call a dump command to dump the current code and heap as a new executable.  Then you do the same to the new executable to add more functions.
22:00:52 <Excedrin> ghc --make hello.hs # does everything needed, most of the time
22:01:41 <monochrom> In fact maxima is exactly like that.  When you run maxima, the first message it says is something along the line of "successfully resumed the last session".
22:02:09 <monochrom> Very old versions of HOL were like that too.
22:02:24 <sorear> emacs too
22:02:54 <sorear> Gforth as well (it only saves heap tho)
22:04:28 <Pseudonym> In the middle-days, some people did this by core dumping.
22:04:45 <sorear> see the perl docs
22:04:48 <Pseudonym> Turn a core dump into an executable.
22:04:56 <sorear> there is a function for dumping core
22:04:59 <Pseudonym> Right.
22:05:07 <Excedrin> see any CL
22:05:10 <Cale> dmead: if you're looking for something more extensive...
22:05:10 <dmead> hmm
22:05:25 <dmead> is there directions on how to grab command line args?
22:05:32 <dmead> i  saw something like that way back...
22:05:41 <monochrom> System.getArgs?
22:05:48 <dmead> yes?
22:05:58 <monochrom> I have no direction.
22:06:11 <Cale> http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
22:06:14 <lambdabot> Title: How to write a Haskell program - HaskellWiki, http://tinyurl.com/yxe296
22:08:03 <pzpz> other than infinite structures and lazy evaluation does haskell/fpl offer over most imperative languages?
22:08:12 <pzpz> s/over/apart
22:08:19 <Cale> Extremely expressive types
22:08:25 <Cale> (well, comparatively)
22:08:28 <dobblego> imperative languages have infinite structures and lazy evaluation
22:08:30 <sorear> stubborn advocates :)
22:08:46 <dmead> pzpz: the oppertunity to talk to me, who is so awesome
22:08:48 <Cale> dobblego: not many of them
22:09:03 <dobblego> interface List<A>{List<A> succ(); T t();} // infinite list in Java
22:09:12 <dobblego> er s/T/A
22:09:13 <dmead> oh right..
22:09:18 <Excedrin> pzpz: type classes and monads
22:09:33 <pzpz> dobblego: hence the "over most" :)
22:09:45 <dobblego> a proper type system (for example, you cannot write a generalisation of a monad in Java with generics)
22:09:56 <sorear> papers with cool names
22:10:27 <monochrom> newtype
22:10:38 <Cale> Even most imperative languages don't have parametric polymorphism
22:10:39 <dobblego> from an earlier discussion, a proper compiler i.e. one that doesn't shit itself with a few recursive calls
22:10:47 <Cale> actually, more than newtype, data
22:11:14 <Cale> You can define a binary tree with  data Tree a = Leaf | Branch a (Tree a) (Tree a)
22:11:22 <Excedrin> dobblego: which compiler shits itself?
22:11:34 <Cale> and you get all the operations necessary to construct and deconstruct trees for free
22:11:48 <dobblego> I watched someone write \filename -> lines $ readFile filename for a Java assignment a couple of hours ago - they are still going
22:11:55 <dobblego> Excedrin, from earlier, it was Sun's Hotspot
22:11:59 <monochrom> continuations
22:12:14 <Excedrin> dobblego: ok
22:12:51 <sorear> how many hours did it last take you to write a symbolic differentiation prog in C++?
22:12:54 <dobblego> if I write \filename -> lines $ readFile filename 100 times, have I done 100 Java university assignments?
22:12:59 <eviltwin_b> that seems excessive even for Java
22:13:03 <eviltwin_b> now if you'd said COBOL...
22:13:33 <dobblego> they even had to eagerly evaluate (because they were using arrays)
22:13:46 <Excedrin> but COBOL has mature compilers
22:13:51 <dobblego> and they call it "teaching",  sheesh
22:14:11 <Cale> pzpz: of course, you get the usual functional language stuff, like higher-order functions
22:14:22 <eviltwin_b> nothotspot, the Java assignment thing
22:14:23 <Cale> > map (*2) [1,2,3,4,5]
22:14:25 <lambdabot>  [2,4,6,8,10]
22:14:56 <sorear> HOF's exist in languages like C; assuming you keep the Intel ISA manual under your pillow
22:14:58 <dobblego> wanna see the source for map in Java?
22:15:08 <Cale> heh, no :)
22:15:14 <dobblego> return isEmpty(list) ? empty : cons(f.f(((Just<A>)head(list)).just()), map(f, ((Just<List<A>>)tail(list)).just()));
22:15:22 <eviltwin_b> no, I'm about to go to bed, don't need nightmares :>
22:15:44 <Excedrin> wow, that's a lot of parenthesis
22:16:14 <sorear> Hasn't sun heard of infix{,l,r}?
22:16:16 <dobblego> because head and tail return Maybe a in that implementation
22:16:23 <monochrom> type-level programming
22:16:36 <pzpz> Cale: higher order how ? via currying?
22:16:51 <Cale> pzpz: higher order in that they turn functions into other functions
22:16:57 <sorear> like map
22:16:57 <dobblego> pzpz, Cale passed a function that was (*2)
22:17:00 <Cale> (take functions as parameters)
22:17:06 <sorear> like qsort in C
22:17:12 <sorear> except less ad hoc
22:17:40 <pzpz> dobblego: which is just a lambda function, correct?
22:17:49 <pzpz> err, no
22:17:50 <dobblego> if you like
22:17:54 <pzpz> could be
22:17:56 <dobblego> \x -> x * 2
22:18:00 <pzpz> ya
22:18:06 <dobblego> you can do that in Java
22:18:17 <dobblego> note that my map implementation called f.f
22:18:25 <dobblego> interface F<A, B>{B f(A a);}
22:18:31 <dobblego> the whole point is show how screwed up it is
22:18:41 <dmead> mmm
22:19:01 <dmead> whats the simplest way to grab the string of the arguments?
22:19:13 <emu> is there an idiom for functions which, like record syntax, return a new copy of some structure in which some subfield has changed?
22:19:19 <dobblego> you can replace return with "if" and ? with "then" and : with "else" and you're getting closer to haskell
22:19:20 <monochrom> oneCPS :: (Int -> r) -> r; oneCPS k = k 1
22:19:23 <Excedrin> dmead: getArgs
22:19:31 <dmead> k
22:19:38 <Cale> emu: record { field = newValue }
22:19:50 <emu> Cale: yes yes, i meant subfield
22:19:57 <emu> like a record of records
22:20:03 <Cale> oh
22:20:15 <emu> or a record of a set of records
22:20:34 <Excedrin> pzpz: are you familiar with another language?
22:20:45 <monochrom> main = { s <- getArgs; mapM_ putStrLn s }
22:20:54 <pzpz> Excedrin: of course, many
22:20:56 <Excedrin> pzpz: there's a Haskell for C programmers tutorial somewhere
22:21:10 <Cale> I recommend YAHT
22:21:11 <Excedrin> http://www.haskell.org/~pairwise/intro/intro.html
22:21:12 <dobblego> http://www.haskell.org/~pairwise/intro/intro.html
22:21:13 <lambdabot> Title: Haskell for C Programmers, http://tinyurl.com/gcyso
22:21:14 <lambdabot> Title: Haskell for C Programmers, http://tinyurl.com/gcyso
22:21:18 <monochrom> I am familiar with Chinese.
22:21:21 <Cale> are you familiar with ML?
22:21:29 <Cale> (or an ML-ish language?)
22:21:40 <pzpz> Excedrin: I'm just writing a silly little paper on testing haskell. however, I'm still pretty amateur with haskell :)
22:22:03 <Cale> @where yaht
22:22:04 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
22:22:09 <sorear> all haskell amateurs get over it
22:22:11 <Cale> that's the tutorial I  recommend
22:22:14 <pzpz> Cale: well, I can write about anything non-monadically now, but i'm learning.
22:22:21 <Cale> pzpz: that's cool
22:22:48 <dobblego> do most people start out writing everything to be IO () ?
22:22:54 <Cale> pzpz: are you learning to rely on the library functions for lists rather than write explicit recursion all the time?
22:22:58 <Cale> dobblego: no
22:22:58 <pzpz> dobblego: I did
22:23:10 <monochrom> I don't.
22:23:47 <pzpz> Cale: I try as much as I can
22:23:52 <Cale> yeah
22:24:01 <Cale> It's just something that you get better at over time
22:24:36 <Cale> That's actually a significant part of making programming in Haskell easy, is knowing the list and monad libraries.
22:24:41 <pzpz> Cale: however, i ended up writing a little helper function to do Int -> [Int] (512 -> [5,1,2]
22:24:45 <pzpz> which is easy enough
22:25:05 <Pseudonym> dobblego: Most people start out writing everything for the command line.
22:25:06 <pzpz> at first, i thought a fold would be a good method
22:25:18 <Cale> you can do it with unfoldr, but the unfoldr in the library is slightly irritating
22:25:19 <dobblego> I suppose
22:25:20 <pzpz> but i wasn't sure how to carry the current power
22:25:34 <pzpz> hwo would you do such a thing?
22:25:55 <monochrom> unfoldr to give [2,1,5], then reverse
22:25:56 <sorear> shadow parameter
22:25:56 <pzpz> i ended up just writing simple recursion, but i'd prefer utilizing the prelude more
22:26:16 <Cale> > unfoldr (\x -> if x == 0 then Nothing else Just (x `div` 10) (x `mod` 10)) 512
22:26:17 <sorear> > iterate (`div` 10) 512
22:26:17 <lambdabot>    The function `Just' is applied to two arguments,
22:26:18 <lambdabot>   but its type `a -> ...
22:26:18 <lambdabot>  [512,51,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
22:26:26 <Cale> er
22:26:31 <pzpz> :)
22:26:33 <Cale> > unfoldr (\x -> if x == 0 then Nothing else Just (x `div` 10, x `mod` 10)) 512
22:26:35 <lambdabot>  [51,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
22:26:49 <Cale> > unfoldr (\x -> if x == 0 then Nothing else Just (x `mod` 10, x `div` 10)) 512
22:26:51 <lambdabot>  [2,1,5]
22:26:51 <eviltwin_b> @hoogle charToInt
22:26:52 <lambdabot> No matches found
22:26:55 <Cale> there we are
22:26:56 <eviltwin_b> hm
22:27:04 <Cale> > reverse . unfoldr (\x -> if x == 0 then Nothing else Just (x `mod` 10, x `div` 10)) $ 512
22:27:06 <lambdabot>  [5,1,2]
22:27:25 <sorear> (\x -> map (Char.digitToInt) $ show x)
22:27:29 <pzpz> eviltwin_b: I looked, maybe not hard enough
22:27:29 <sorear> > (\x -> map (Char.digitToInt) $ show x)
22:27:30 <lambdabot>  Add a type signature
22:27:38 <eviltwin_b> that's what I was looking for
22:27:39 <sorear> > (\x -> map (Char.digitToInt) $ show x) :: Int -> [Char]
22:27:39 <monochrom> yeah actually I would use show and then map digitToInt
22:27:40 <lambdabot>  Couldn't match `Char' against `Int'
22:28:18 <monochrom> People, you should use /msg lambdabot to test your snippets, get it working, and post in the channel no more than one single working version.
22:28:31 <sorear> > (\x -> map (Char.digitToInt) $ show x) :: Int -> [Int]
22:28:33 <lambdabot>  <Int -> [Int]>
22:29:27 <eviltwin_b> > map Char.digitToInt $ show 512
22:29:29 <lambdabot>  [5,1,2]
22:29:33 <monochrom> Note that you have map (Char.digitToInt) . show there.
22:29:34 <Cale> > let unfoldr f p g = map f . takeWhile p . iterate g in reverse . unfoldr (`mod` 10) (/= 0) (`div` 10) $ 512
22:29:36 <lambdabot>  [5,1,2]
22:29:45 <Cale> so much nicer
22:29:52 <Cale> too bad that version isn't in the library
22:30:15 <monochrom> Ah, unfold until condition?
22:30:16 <pzpz> heh
22:30:43 <Cale> of course, you can write it inplace explicitly
22:30:46 <pzpz> monochrom: sometimes it's fun to see their failings :)
22:30:53 <Cale> It's totally equivalent in power to ordinary unfoldr
22:31:01 <Cale> (you can write one in terms of the other)
22:31:32 <Cale> Just without the annoying artificial use of Maybe type
22:33:29 <Cale> Of course, you can also use this tactic in-place
22:33:58 <Cale> > reverse . map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ 512
22:34:00 <lambdabot>  [5,1,2]
22:34:30 <pzpz> i like how all the library methods are much more challenging than simple recursion :)
22:35:20 <Cale> actually, that way is probably how I'd do it right away
22:35:29 <dmead> yay!
22:35:35 <int-e> > map ((-48+) . ord) . show $ 512
22:35:36 <lambdabot>  [5,1,2]
22:35:44 <dmead> dan@localhost ~/code/Classes/CSC499 $ ./proverApp "((P->Q)&(Q->R))->(P->R)"
22:35:44 <dmead> "((P->Q)&(Q->R))->(P->R) is a theorem"
22:35:44 <dmead> dan@localhost ~/code/Classes/CSC499 $
22:35:45 <Cale> (though I wanted to show how unfoldr worked)
22:35:47 <dmead> weee
22:36:23 <dobblego> dmead, nice, what language is that?
22:36:30 <pzpz> int-e: pro method :)
22:36:34 <dmead> laanguage?
22:36:42 <dmead> it's my theorem prover, written in haskell
22:36:45 <dobblego> oh right
22:37:06 <dmead> now to get it to print proofs...
22:38:10 <dobblego> that is one of the rules of inference right?
22:38:16 <dobblego> hypothetical syllogism?
22:38:19 <dmead> yep
22:38:26 <pzpz> you just googled it.
22:38:33 <dmead> lol
22:38:38 <dmead> yea its a basic inference rule
22:38:51 <dobblego> actually I refreshed on it on the weekend
22:39:22 <dobblego> I don't know how you'd google it
22:39:45 <dobblego> one result :)
22:40:01 <dobblego> that won't load
22:40:17 <Cale> It loads for me
22:40:22 <Cale> http://www-lsr.imag.fr/users/Michel.Levy/classical_prop/index.php?formula=(p+%3D%3E+q)+%26+(q+%3D%3E+r)+%3D%3E+(p+%3D%3E+r)&action=Prove+Formula
22:40:38 <dobblego> maybe everyone in #haskell is trying to load it
22:41:07 <Cale> It's not terribly bandwidth intensive or anything
22:41:16 <Cale> It appears to be a javascript theorem prover
22:41:18 <dobblego> I get "cannot find server" so I give up
22:42:09 <Cale> Or maybe it's serverside.
22:42:15 <dobblego> I suppose I should go play squash as promised, bye
22:42:35 <dobblego> I cannot resolve the host name
22:42:54 <dobblego> it's something my end
22:42:54 <Cale> that's odd
22:43:02 <dobblego> or maybe the whole internet just exploded
22:43:11 <Korollary> there's a netsplit at least
22:43:35 <dobblego> must go, seeya
22:44:04 <Cale> heh, this song is called tjhelmerich@earthlink.net
22:47:16 <pzpz> honestly, I can't seem to figure out why languages like Haskell are so unpopular compared to imperative counterparts
22:47:23 <pzpz> i blame education :(
22:48:44 <zarvok> I don't know.  At CMU, for example, we have a bunch of courses in SML and about functional programming and type theory, but most of my fellow students still seem to have a strong preference for imperative languages
22:48:53 <zarvok> I'm not sure it's a result of the education they are getting
22:49:16 <Korollary> there are a lot of apps written in such languages.
22:49:25 <pzpz> zarvok: at my undergraduate level we have only one course that exposes students to FP.
22:49:45 <pzpz> zarvok: nearly all assignments are limited to C*/Java
22:50:23 <zarvok> pzpz: we only have one required course that uses a functional language, but it is early on and students can then pick from a bunch of optional courses in the area if they like it
22:50:25 <dmead> pzpz: same here, but we use C++ and java
22:51:17 <monochrom> cale_unfoldr f p g = unfoldr (liftM2 (>>) (guard . p) (return . f &&& g))
22:51:29 <monochrom> Cale you can use that from now on :)
22:51:46 <Cale> monochrom: that's a cute way to write it
22:51:49 <pzpz> I mean, who here's first language wasn't imperative?
22:51:57 * monochrom is cute and wise.
22:52:37 <pzpz> i honestly don't remember logo. was logo a logical language?
22:52:38 <int-e> pzpz: do natural languages count :)
22:52:55 <pzpz> i just remember making sweet shapes.
22:54:14 <zarvok> wikipedia says logo is functiona
22:54:18 <zarvok> *functional
22:54:23 <zarvok> a variant of scheme
22:54:43 <zarvok> err, lisp, whatever
22:54:46 <pzpz> oh, how sweet. my first language was functional!
22:55:10 <zarvok> it would be a good name for a logic programming language though
22:55:13 <zarvok> what were they thinking
22:55:17 <monochrom> My first language was Casio FX-3600P
22:55:27 <pzpz> monochrom: asm?
22:55:45 <zarvok> mine was QBASIC, a basic dialect used on some robot controllers
22:55:46 <zarvok> it was awful
22:55:50 <zarvok> err
22:55:52 <zarvok> not QBASIC
22:55:54 <zarvok> PBASIC
22:56:07 <pzpz> heh
22:57:24 <monochrom> You could say that.  The available instructions were: load, store, (there were 6 registers), exit, if >0 goto top, if <=M goto top.
22:57:57 <monochrom> 39 instructions could be stored.
22:58:03 <zarvok> we'll call that rrisc
22:58:08 <zarvok> really reduced instruction set
22:58:35 <monochrom> Now, here is the punchline.
22:58:55 <monochrom> FOR SEVERAL YEARS I DID NOT EVEN OWN THIS CALCULATOR.
22:59:42 <monochrom> I would write a program on paper at home.  The next morning I would borrow the calculator from a friend and tested my program.  It would work.  It would also be the shortest possible program for the same task.
22:59:57 <pzpz> i hope so. you only have a few shots :)
23:00:32 <pzpz> if your compiler complained about working too hard, you'd probably stop using it to find bugs :)
23:00:51 <monochrom> You know how people think proving programs correct is intractible.  I find it very tractible.  I think my teenage experience made the difference.
23:01:14 <pzpz> perhaps elementary cs courses should be done in pen and paper.
23:01:46 <sieni> tractible? as in being able to become a tract?
23:02:21 <Korollary> sieni: You used to be more interesting. What happened?
23:02:24 <monochrom> So, in a strong sense, my early programming experience was comparable to that of Knuth, Dijkstra, Hoare, etc., i.e., the hardware was so scarce and expensive, a tight edit-test cycle was not available.
23:02:34 <sieni> Korollary: I stopped drinking
23:02:46 <Korollary> I knew it!
23:04:03 <newsham> ?seen shapr
23:04:03 <lambdabot> shapr is in #scannedinavian, #haskell and #ScannedInAvian. I last heard shapr speak 1h 58m 30s ago.
23:04:12 <monochrom> The Casio FX-3600P calculator is also very energy-efficient.  A new battery (merely CR2025) can last more than ten years.
23:04:32 <pzpz> it might take 10 years to calcluate something, thought ^_^
23:04:37 <pzpz> though
23:05:48 * shapr snores quietly
23:06:16 <newsham> hey shapr -- how does one typically manage session state in happs?
23:07:08 <pzpz> could anyone point out a site runinng on happs ? :)
23:07:10 <shapr> I have some minor clue...
23:07:49 <shapr> newsham: The SessionKeeper code can be used to create a session that lasts a certain amount of time. You get a SessionKey as a result, and you manage that however you like.
23:07:59 <Lemmih> pzpz: pass.net
23:08:23 <shapr> Sadly, I'm just parroting that. I asked the author of that code (musasabi) the same question and that was the answer I got. I haven't gotten around to doing that myself.
23:08:34 <monochrom> I wrote the programs neatly on grid paper, i.e., one square per instruction.  My mother looked over my shoulder and asked, "are these knitting instructions?"  (She's into knitting and apparently the notations were similar.)
23:08:46 <Lemmih> shapr: How's musasabi, btw?
23:08:48 <newsham> so shove the session key into a cookie?
23:09:01 <shapr> Lemmih: No clue, I haven't heard from him in ... two weeks?
23:09:04 <shapr> @seen musasabi
23:09:05 <lambdabot> I saw musasabi leaving #ghc, #haskell-overflow, #haskell-blah, #haskell and #Haskell 16h 20m 13s ago, and .
23:09:29 <shapr> I know he was very sick awhile back, I hope it hasn't returned.
23:09:43 <pzpz> Lemmih: any others?
23:09:58 <Lemmih> pzpz: Not to my knowledge.
23:10:36 <shapr> pzpz: http://pass.net/ and http://www.searchpath.org/
23:11:04 <shapr> pzpz: I can show you a simple wiki I wrote with HAppS if you like.
23:11:33 <shapr> newsham: Anyway, if you end up with code that does session stuff, I'd like to get a copy to integrate into the tutorial.
23:11:57 <shapr> Anytime someone has a HAppS question I can't answer I know it's time to write more tutorial code.
23:12:13 <newsham> shapr: sure thing.
23:13:06 <pzpz> shapr: that would be great
23:13:38 <shapr> darcs get http://www.scannedinavian.com/~shae/happswiki/
23:13:40 <lambdabot> Title: Index of /~shae/happswiki, http://tinyurl.com/y422jc
23:14:32 <shapr> It's really simple and could be cleaner, but it demonstrates the explicit state and state transformer idea of HAppS.
23:15:47 <shapr> dons: HAppS doesn't really use implicit params. Alex was trying them in one place, but I think he's switching to the state monad.
23:15:49 <pzpz> shapr: i've only briefly looked at happs. this would be fun to lookat when I get some time. thanks :)
23:15:59 <shapr> pzpz: Sure, feel free to ask me any questions.
23:16:39 <Cale> nice, ~150 lines :)
23:17:11 <Cale> oh wait
23:17:18 <Cale> they don't import each other
23:17:30 <Cale> so that's < 100 lines even
23:18:02 <shapr> Cale: The page templates could be much shorter.
23:18:43 * shapr considers cleaning it right now...
23:19:40 <metaperl> Why does Davie's book get so little recognition in the Haskell community - http://www.alibris.com/search/search.cfm?qwork=3312383&wtit=Introduction%20to%20Functional%20Programming&matches=16&qsort=r&cm_re=works*listing*title
23:19:43 <lambdabot> Title: An introduction to functional programming systems using Haskell by Antony J. T.  ..., http://tinyurl.com/y8p2t7
23:20:10 <shapr> metaperl: I've only heard about it once or twice.
23:20:33 <metaperl> hmm, I found Bird "Intro to FP" for 50 bux... do you like that one?
23:21:21 <metaperl> wait a minute. how could this book cover Haskell98 if it was written in 1988?
23:21:27 <metaperl> I'm not buying this...
23:22:15 <Cale> It's probably Haskell 1.3 or 1.4
23:22:33 <Cale> Haskell's probably changed more since '98 than between 1.4 and 98.
23:23:10 <dons> hmm, is http://sequence.complete.org/ down?
23:23:27 <Cale> seems like it
23:23:34 <dons> huh
23:23:40 <dons> first time that's happened, that i know of
23:23:52 <pzpz> when's Haskell' due?
23:24:05 <dons> in 9 months
23:24:25 <pzpz> you're joking, aren't you?
23:24:26 * shapr wonders if that's a joke
23:24:46 <dons> well, kinda. but its almost 9 months till the next HW
23:24:50 <pzpz> :)
23:24:53 <dons> so it sort of works :)
23:25:38 <dons> ?uptime
23:25:52 <lambdabot> uptime: 1d 54m 40s, longest uptime: 9d 2h 23m 6s
23:26:45 <dons> first time i've ever seen the blog tag "Haskellware"
23:27:22 <dons> oh, sequence seems to be back now
23:27:31 <shapr> ralf laemmel?
23:27:50 <dons> yup
23:27:59 <dons> good guess :)
23:28:31 <shapr> I just asked google :-)
23:28:36 <dons> heh
23:31:10 * greentea is having type problems when using GHCi.
23:31:28 <dons> do tell
23:31:28 <greentea> i keep on getting "Ambiguous type variable 'a'" messages.
23:31:37 <dons> ok, can you paste the code?
23:31:38 <dons> ?paste
23:31:39 <lambdabot> http://paste.lisp.org/new/haskell
23:32:47 <lisppaste2> greentea pasted "Type ambiguity" at http://paste.lisp.org/display/30858
23:33:09 <dons> need more code than that.
23:33:15 <dons> where's mkelem?
23:33:17 <greentea> No, that's all i'm trying to do.
23:33:20 <dons> and sattr
23:33:38 <greentea> i've brought the Arrow.XML.HXT.Arrow module into scope via m:.
23:33:50 <greentea> Which is where those functions live.
23:33:51 <dons> can you include what modules you've got in scope then?
23:33:58 <dons> just Arrow.XML.HXT.Arrow?
23:34:03 <greentea> *nod*
23:34:08 <dons> what package is that in, -package HXT?
23:34:13 <greentea> Yep.
23:34:50 <dons> which i don't have.
23:34:54 <dmead> dons: my prover is finished, except for predicate logic
23:34:54 <greentea> Well, hxt-6.1
23:34:58 <greentea> Ah.
23:35:20 <dons> can you paste the type error too, that's the most important part :)
23:35:23 <dons> dmead: cool!
23:35:41 <dmead> dons: care to take a look?
23:35:53 <dmead> dons: i'd like some opinions
23:36:13 <dons> you can post it , but i'm on my way home from work now. i'll have a look later. or ask for advice on haskell-cafe@haskell.org
23:36:21 <lisppaste2> greentea annotated #30858 with "Type ambiguity error" at http://paste.lisp.org/display/30858#1
23:36:33 <greentea> Ah, okay, thanks.
23:36:33 <dmead> kk
23:36:36 <dmead> post it where?
23:37:18 <dons> i was thinking , mail haskell-cafe@haskell.org and ask for advice. otherwise, post it somewhere visible and put the url here
23:37:37 <dons> greentea: Probable fix: add a type signature that fixes these type variable
23:37:44 <greentea> Yes, well, i did that.
23:37:47 <dons> try giving type annotations to the types you think the result should be and so on
23:37:51 <dons> does that change the error message?
23:37:53 <greentea> At least i believe i did.
23:37:54 <greentea> No.
23:38:18 <greentea> i added ":: ArrowXml a => a XmlTree XmlTree" to the end of that code.
23:38:35 <greentea> Then added it to the end of each call to sattr.
23:39:00 <dons> perhaps ask on haskell-cafe then, including as much src as you have, and the types of  mkelem  and sattr  for reference
23:39:08 <dons> someone who knows HXT should be able to help
23:39:19 <greentea> Okay, thanks. :-)
23:40:05 <dons> http://www.haskell.org/visualhaskell is out
23:40:07 <lambdabot> Title: Visual Haskell
23:40:11 <dons> Visual Haskell prerelease 0.2
23:40:44 <dons> with screenshots.
23:40:48 <dons> that should make the windows guys happy
23:41:18 <dons> i like the cabal file thingy, http://www.haskell.org/visualhaskell/screenshots.html
23:41:19 <lambdabot> Title: Visual Haskell Screenshots, http://tinyurl.com/vt3nz
23:42:06 <pzpz> pretty neat
23:46:01 <shapr> In my wiki dispatch, every function has the same first line: "WikiState pages <- get" is there some nice way to factor that out?
23:46:40 <shapr> @pl get >>= \(WikiState pages) -> foo pages
23:46:41 <lambdabot> (line 1, column 21):
23:46:41 <lambdabot> unexpected "p"
23:46:41 <lambdabot> expecting operator or ")"
23:48:38 <pzpz> any emacs users know a method for setting an automatic margin wrap, kind of like what M-q  does for you?
23:49:02 <shapr> (fill-column 79)
23:49:10 <shapr> um, (setq fill-column 79)
23:49:24 <pzpz> is there an inverse to M-q ?
23:49:34 <shapr> If you want M-q to be called whenever you go over the limit, there's autofill-mode
23:49:46 <shapr> Maybe C-/ ?
23:50:10 <dmead> the haskell-mode on ubuntu has nice automatic formatting
23:50:11 <shapr> I don't understand the question. What should the inverse of M-q do?
23:50:26 <pzpz> Puts everything on one line.
23:50:37 <pzpz> well, a block of text
23:50:39 <shapr> hm, @pl doesn't handle constructor unpacking.
23:51:16 <pzpz> auto-fill-mode is nice, thanks.
23:53:51 <dmead> bonk!
23:53:53 <dmead>  dan@localhost ~/code/Classes/CSC499 $ ./proverApp "((P->Q)&(Q->R))->(P->R)"
23:53:54 <dmead> "((P->Q)&(Q->R))->(P->R) is a theorem"
23:53:54 <dmead> dan@localhost ~/code/Classes/CSC499 $
23:55:26 <pzpz> it looks to me that you're just printing the argument along with is a theorem :)
23:55:35 <pzpz> not very impressive!
23:55:36 <pzpz> b
23:56:10 <pzpz> and... irssi obviously doens't support emacs hotkeys.
23:56:22 <dmead> haha
23:56:25 <dmead> no =/
23:57:49 <shapr> I use ERC
23:58:19 <astrolabe> I use windows, and I've got visual studio.net at work, but I'm not that tempted by Visual Haskell for some reason.  Maybe my projects are too simple at the moment.
23:58:24 <pzpz> shapr: like it?
23:58:32 <dmead> ERC?
23:58:42 <pzpz> emacs irc
23:58:47 <dmead> ah
