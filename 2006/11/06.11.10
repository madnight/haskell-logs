00:00:34 <dons> http://programming.reddit.com/info/qaxl/comments
00:00:38 <lambdabot> Title: "Without QuickCheck I don&#39;t think it would have been possible to write the l ..., http://tinyurl.com/tyn6l
00:01:16 <dons> ndm, I didn't know you used QuickCheck for FilePAth. but your experiences mirror dcoutts and mine with Data.ByteString
00:01:27 <dons> it just wouldn't have been possible to get it done and into ghc 6.6 without QuickCheck
00:01:43 * lispy oscillates
00:01:51 <dons> a 2 man 2 month job would have been a 2 man 6 month (or more)
00:02:03 <dons> we would have to have duplicated QuickCheck anyway. its the only solution
00:03:55 <lispy> oh yeah, automated testing is a blessing
00:04:08 <lispy> esp. when it's good like quickcheck
00:04:13 <lispy> and you adopt a policy to fix bugs first
00:04:36 <dons> yep
00:04:40 <lispy> the biggest reason most developers i know don't fix a bug is because they don't know it exists yet
00:04:45 <dons> yeah
00:05:05 <dons> ?remember lispy the biggest reason most developers i know don't fix a bug is because they don't know it exists yet
00:05:46 <lispy> :)
00:12:16 <dons> ?seen trevion
00:12:18 <lambdabot> I saw trevion leaving #haskell 1m 13d 14h 35m 49s ago, and .
00:12:26 <dons> 1m. huh
00:13:16 <pkhuong> `and .'?
00:14:23 <dons> strings aren't a very rich type ;)
00:14:29 <pkhuong> :| I just wrote a state monad for CL.
00:14:33 <dons> cool!
00:14:51 <roconnor> @what CL
00:14:52 <lambdabot> I know nothing about cl.
00:15:02 <pkhuong> no, bad! I can already see the hordes of lispers flogging me to death.
00:15:15 <Botty> roconnor - Common Lisp I presume
00:15:20 <pkhuong> yes.
00:17:50 <dons> but it makes perfect sense
00:20:29 <pkhuong> dons: a state monad in a side-effect-ful language? (: I want to be able to copy and split the state, that's all. I think I could have used a special variable, but it may be useful to easily snapshot the whole state later.
00:22:42 <dblhelix> @pl \(x, y) -> x : ana y
00:22:43 <lambdabot> uncurry ((. ana) . (:))
00:24:53 <Excedrin> does Neil Mitchell IRC?
00:25:28 <Excedrin> oh, I see ndm..
00:28:49 <dblhelix> @hoogle (a -> c) -> (b -> d) -> (a, b) -> (c, d)
00:28:51 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
00:29:17 <dblhelix> doesn't that one deserve a place in Data.Function?
00:29:57 * roconnor hopes we don't make Data.Function
00:30:00 <dolio> Is that the same as ***?
00:30:15 <dolio> ?type (***)
00:30:16 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
00:33:11 <dons> roconnor: got a better name?
00:33:56 <roconnor> Function
00:34:31 <roconnor> or in this case perhaps Function.Combinator
00:34:47 <dolio> Just throw it all in the prelude.
00:34:50 <dolio> Works for PHP. :)
00:35:13 <dons> well, suggest it roconnor
00:35:29 <roconnor> nah, I honestly don't care that much
00:35:44 <roconnor> Data.Function may be a bad name, but we will all survive with it
00:36:45 <roconnor> In this case being decisive is prehaps more important than getting it right
00:37:27 <dblhelix> @hoogle (a -> b) -> (a -> c) -> a -> (b, c)
00:37:28 <lambdabot> No matches, try a more general search
00:37:39 <dblhelix> another candidate, imho
00:38:00 <dolio> ?type (&&&)
00:38:01 <lambdabot> forall (a :: * -> * -> *) c' c b. (Arrow a) => a b c -> a b c' -> a b (c, c')
00:38:12 <roconnor> @type liftM2 (,)
00:38:14 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
00:38:38 <dblhelix> indeed, but don't you think there should be specialized versions somewhere?
00:39:18 <dolio> I'm more of a fan of the generality, but some people might say so.
00:40:00 <dblhelix> besides, Control.Arrow is not portable, but I'm sure if that still counts as an argument nowadays
00:40:43 <dblhelix> /s/sure/*not* sure
00:40:47 <roconnor> I guess if you stick with portable Haskell, you are stuck in the previous millenium
00:41:05 <dolio> What's it use that's specific to GHC?
00:41:14 <dolio> Multi-parameter classes?
00:41:40 <dolio> Wait, no, that's not it.
00:41:57 <dons> Control.Arrow isn't portable?
00:42:03 <dolio> Declaring (->) an instance?
00:42:13 <dons> -- Portability :  portable
00:42:30 <dons> nothing magic about (->) being an instance
00:42:34 <dblhelix> well, in Helium, for educational purposes, we only support (a subset of) Haskell 98
00:42:45 <dblhelix> dons: buy, hey, what about mptc's
00:42:52 <dons> what about them? :)
00:43:08 <dblhelix> don't they render the module non-portable?
00:43:22 <dolio> Control.Arrow doesn't actually use them. I was mistaken.
00:43:47 <dblhelix> dolio: ah, of course
00:43:57 <dblhelix> so, no issue then...
00:44:07 <dons> MPTCs would render it non-portable, I think, yes.
00:45:06 <dblhelix> but still, somehow, I think I would rather expose freshmen to Data.Function (or whatever it'll be called) than Control.Arrow
00:47:31 <dolio> Yeah, if it's about teaching, >< is probably the way to go.
01:00:33 <Botty> 3
01:00:46 <Botty> wrong window...
01:17:52 <lispy> 4
01:17:57 <lispy> right window ;)
01:18:21 <dons> zsh: command not found: 4
01:18:24 <dons> oh, wrong window
01:18:29 <lispy> heh
01:18:40 * dons tries again
01:18:48 <dons> gmake: *** No rule to make target `4'.  Stop.
01:18:52 <dons> doh!
01:19:02 <Botty> >_<
01:19:07 <dons> this time for sure!
01:19:09 <dons> $ runhaskell 4
01:19:10 <dons> Could not find module `4':
01:19:10 <dons>   use -v to see a list of the files searched for
01:19:10 <dons>   (one of the roots of the dependency analysis)
01:19:13 <dons> argh!
01:19:43 <lispy> dons: I found it!
01:19:44 <lispy> $ ghc -e '4'
01:19:44 <lispy> 4
01:19:46 <Botty> no really, its quite easy to type something in the wrong window when you've got 2 screens :)
01:19:58 <dons> lispy++
01:20:15 <dons> cute, $ ghc -e 4
01:20:16 <dons> 4
01:21:20 * profmakx waves g`day to everyone
01:22:33 <dons> heya profmakx
01:23:22 <Syzygy-> $ ghc -e 'let fibs = [1] ++ [1] ++ zipWith (+) fibs (drop 1 fibs) in take 10 fibs'
01:23:25 <Syzygy-> [1,1,2,3,5,8,13,21,34,55]
01:23:28 <Syzygy-> lispy++
01:23:31 <Syzygy-> Me likes too.
01:24:49 <lispy> heh, glad i could help :)
01:31:20 <Itkovian> hey, that's quite cool
01:38:05 <vegai> http://www.walken2008.com/politics.html
01:38:08 <lambdabot> Title: Walken 2008 - Campaign Website
01:55:39 <kfish> heh dons: your web page for data.bytestring doesn't yet mention inclusion in ghc6.6 :-)
01:57:12 <kzm> I can't help but notice that three of the benchmarks involve biosequences - i.e. FASTA files.
01:59:26 <kzm> I have some code for that - rather rudimentary, only scratching my own itches as they arise.  I'd love to leverage some of the shootout effort to improve my library.  (And feel free to rip whatever from my repo, of course)
02:00:38 <kzm> (one thing that might come in handy, would be to read just the sequence data into a buffer (bytestring) - ignoring headers and whitespace, and possibly upcasing as we go along.
02:00:43 <kzm> )
02:01:14 <kzm> Shouldn't be too hard to adapt some of the BS functions for this, but perhaps this would be generally useful as well?
02:03:28 <kzm> something like:  \f p -> return . filter p =<< readFile f  ?
02:05:04 <kzm> Perhaps doing it in "user space" is equally efficient - esp. with BS.Lazy...
02:05:47 <dons> kfish: cheers. i'll update it.
02:05:57 <dons> just writing a talk on bytestring right at the moment.
02:06:09 <kfish> heh
02:06:13 <kfish> how's the conference?
02:07:22 <dons> yeah good. lots of interesting stuff going on.
02:18:27 <dcoutts> kzm, that looks much like the example from the intro to our ByteString paper
02:18:58 <dcoutts> kzm, we were reading in a file, upcasing, filtering and hashing
02:19:03 <kzm> dcoutts, okay.
02:19:19 <kzm> Rewriting Hs Str?
02:20:24 <kzm> I printed it out now, and will take a look.  Holler if it's the wrong one :-)
02:20:44 <vegai> dons: is hs-plugin for ghc-6.6 still on the drawing board?
02:22:05 <kzm> Anyway, I'll need a contigous buffer to pass to FFI.  So I guess I need a non-lazy FPS containing just the data.
02:22:16 * kzm is off to fetch the dead trees.
02:25:27 <wilx> Heh.
02:25:34 <wilx> Dead trees is so bad name. :)
02:27:27 <vegai> dons: No causing of stress implied, of course.
02:37:33 <syntaxfree> @pl pair a b = (>>) (char a) (char b)
02:37:34 <lambdabot> pair = (. char) . (>>) . char
02:52:47 <Lemmih> xerox: ping.
02:53:40 <dons> vegai: yes. this weekend all going to plan
02:55:55 <dons> hey guys, i'm giving a talk tomorrow on bytestrings and stream fusion. draft slides here: www.cse.unsw.edu.au/~dons/tmp/streams-talk.ps
02:56:02 <dons> if anyone wants to have a quick look and comment
02:56:18 * dons back in an hour or so
02:57:13 <syntaxfree> I can't turn some recursive do-notation functions into bind notation.
02:57:26 <syntaxfree> @paste
02:57:27 <lambdabot> http://paste.lisp.org/new/haskell
02:58:01 <lisppaste2> syntaxfree pasted "what's bind notation for this?" at http://paste.lisp.org/display/29613
03:00:11 <xerox> Lemmih: pong
03:00:51 <syntaxfree> dang monomorphism restriction!!
03:02:01 <Lemmih> xerox: You're using hope, right? Can you see what I'm doing wrong: http://blog.catenova.org/ ?
03:02:59 <xerox> Lemmih: have you created the first user, that is the admin?
03:05:33 <Lemmih> xerox: I've tried to create a user but the users table in the database is still empty.
03:06:29 <xerox> When I did it, I think I had to write the url by hand to add it, but then the error messages like that one disappeared.  I'm not sure what is going on there.
03:08:20 <Lemmih> Hm, okay, I'll poke bringert when he gets around.
03:09:43 <xerox> I suspect the code has changed heavily since I updated it last time.
03:31:21 <sylvan> I'm not sure I understand the reasoning behind the new policy of counting gzipped bytes rather than lines of code in the shootout. Do they really want to reward languages with redundant and verbose syntax?
03:32:16 <ms_> um, does anyone know what the story is with the hopengl package for ghc6.6?
03:32:29 <sylvan> Lines such as "MyVeryLongAndClumsyClassName longAndClumsyObjectName = new MyVeryLongAndClumsyClassName" may compress as well as a light weight syntax, but it sure as hell doesn't look as nice...
03:32:30 <xerox> sylvan: uhm, some editors can edit gzipped textfiles directly. But that's twisted.
03:32:50 <sylvan> heh, yeah
03:36:19 <blue> hello there can anyone help me out with 2 exersises I have in haskell?
03:36:41 <dons> sylvan: yeah, its a bit silly.
03:36:41 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
03:36:46 <dons> its not that meaningful
03:37:44 <dons> kzm++ thanks!
03:39:41 <SamB> Hmm, some of my calculus classmates have been complaining of a C++ teacher who makes them use names about that long...
03:39:41 <blue> hello anyone?
03:39:45 <beelsebob> blue: yes, but are these exercises for class?
03:39:53 <blue> no
03:40:06 <beelsebob> what are they for? Just out of a book?
03:40:29 <flux__> (x)emacs dynamic completion is a bliss
03:40:39 <flux__> I use long names all the time :)
03:40:57 <gds> likewise - in both emacs and vim...
03:41:04 <beelsebob> ditto with XCode
03:41:09 <blue> no I'm just trying to program in haskell Im a beginner
03:41:18 <xerox> Hello blue.
03:41:19 <beelsebob> kk, what's the problems?
03:42:42 <blue> in my program I want a list of integers ,it will return a list like this: if original list is [1,2,3,4] the new list will be [2,4,6,8]
03:42:51 <beelsebob> okay
03:42:56 <xerox> you want to apply the same function to each element of the list?
03:43:06 <beelsebob> you want to use map
03:43:09 <blue> yep recursively
03:43:17 <xerox> he wants to *define* map :)
03:43:20 <beelsebob> okay
03:43:22 <beelsebob> well
03:43:31 <xerox> do you know pattern matching?
03:43:37 <beelsebob> suppose you want to apply f to all the elements in the empty list...
03:43:45 <beelsebob> what would the resulting list look like?
03:44:18 * xerox gets sucked in a vortex of -fdisallow-overlapping-explanations
03:44:28 <blue> f  [] = []
03:44:33 <beelsebob> not quite
03:44:42 <beelsebob> this function needs to have two arguments
03:44:47 <beelsebob> one of them is the function you need to apply
03:44:48 <xerox> the idea is right, he misses the function name :)
03:44:55 <beelsebob> and the other is the list to apply to
03:45:01 <beelsebob> so you would want: f g [] = []
03:45:16 <sylvan> f = map
03:45:18 <sylvan> :-)
03:45:27 <beelsebob> sylvan: he has to do it *recursively*
03:45:49 <beelsebob> now... supposing you want to apply the function to a list with at least one element... how would you apply it to the first element?
03:47:01 <beelsebob> (ignore the rest of the list, how would you go about applying g to just the first element)
03:47:40 <blue> wait...
03:47:47 <beelsebob> k
03:48:03 <xerox> "...ignore this terrible drug, pretend it's not happening..."
03:48:11 <beelsebob> indeed
03:49:55 <sylvan> I think he actually just wanted to define "map (*2)" himself... I.e. f :: Num a => [a] -> [a]... Not the full blown higher order map...
03:50:14 <beelsebob> mebby
03:50:42 <xerox> sylvan: and what would be the exercise? using hoogle?
03:51:19 <sylvan> I'm guessing "define a function to double each element in a list", and then "generalise it to apply a supplied function to each element" in the next exercise?
03:51:22 <beelsebob> it would be an early beginner exercise for using recursive functions
03:51:31 <blue> f (h:t) = h : g  t
03:51:43 <beelsebob> okay
03:51:44 <beelsebob> well...
03:51:45 <xerox> right, except g is a free variable there.
03:51:55 <beelsebob> the head in your answer there... hasn't had anything done to it
03:52:06 <beelsebob> so you know you're not going to change the elemnts in the list
03:52:14 <beelsebob> and again, you're down to only one argument
03:52:29 <beelsebob> you know that the function is going to accept g and a list as input...
03:52:34 <beelsebob> f g (h:t)
03:52:37 <beelsebob> = ???
03:52:52 <beelsebob> so how would you go about appying g to h?
03:52:56 <blue> i want to add to every number of the list : length (h:t) - length t and return the new list
03:53:15 <blue> but I dont wont length (h:t) to cj`hange
03:53:33 <blue> I want it to be the initial size of the list
03:54:28 <sylvan> something like f xs = fHelper (length xs) xs ; where fHelper n (x:xs) = ...
03:54:54 <SamB_XP> sylvan: fHelper doesn't need that to be an argument
03:55:02 <sylvan> true
03:55:06 <SamB_XP> it could just as easily be defined in the "where"
03:55:08 <blue> I tried sth with "where"
03:55:20 <blue> but it only added 1 to every number
03:55:29 <blue> can I declare sth as a constant?
03:55:30 <sylvan> f xs = fHelper xs ; where n = length xs ; fHelper (x:xs) = ...
03:57:04 <dcoutts_> dons, talk looks good so far. The "writing to an array is straight forward" is a slight exaggeration :-) the same exaggeration we had in the padl paper. :-)
03:57:29 <ski> (sylvan the initial ';' is wrong, no ?)
03:57:58 <dcoutts_> dons, yesterday I wrote stream,unstream for [a] and Array a, using ST(U)Arrays. It's not totally trivial.
03:58:13 <kzm> dcoutts_, I've read the paper briefly, but I'm still not entirely sure how to build a buffer to pass to FFI.
03:58:47 <dcoutts_> kzm, you can get the raw Ptr out of the ByteString so you can pass it to C land
03:58:49 <kzm> In particular I need to specify the size in advance (to avoid a costly length calculation)
03:59:12 <dcoutts_> kzm, are you getting a string from C or passing it to C ?
03:59:26 <SamB_XP> it sounds like he wants to malloc a Ptr...
03:59:28 <kzm> Yes, the passing is okay.  I'll build a (non-lazy) BS, and pass that.
03:59:51 <dcoutts_> kzm, is all you're doing passing a Haskell String to C as a CString ?
03:59:52 <kzm> I was thinking I'll build the string on the Haskell side, and pass it over for processing.
03:59:57 <dcoutts_> kzm, then use withCString
04:00:00 <SamB_XP> dcoutts: he said "buffer"
04:00:09 <kzm> Yes *I know*
04:00:10 <SamB_XP> not "string"
04:00:10 <kzm> :-)
04:00:17 * dcoutts_ isn't quite sure what kzm is doing
04:00:28 <SamB_XP> if he meant a string... he should have said "string"
04:00:35 <kzm> Well - if you'd let me explain... :-)
04:01:02 <blue> f (h:t) = new h :f t  \n where new :: Int -> [Int] \n  new k = h + length(h:t) - length t : new (k-1)
04:01:12 <kzm> I have a relatively large file, and I want to extract/modify parts of it before withCString'ing it.
04:01:39 <dcoutts_> dons, btw, read . write  isn't the identity on arrays, it's the identity on streams (and then only the subset that can be represented by arrays, ie finite streams)
04:01:40 <blue> can you tell me what this is doing?
04:01:54 <kzm> I currently use lazy BS readFile for that, which means I need to concatenate the blocks into a contigous buffer.
04:02:13 <kzm> And I worry that it will mean calculating the length first, keeping everything in memory twice.
04:02:56 <kzm> So I'd rather just specify the final string (buffer) length in advance, and have the readFile lazy BS being GC'ed as we go.
04:03:03 <kzm> Clearer now? :-)
04:04:40 <kzm> blue: did you try it out in an interpreter?  (Or on paper)
04:04:55 <dcoutts_> kzm, yep
04:04:59 <blue> yep
04:05:11 <kzm> blue: and?
04:05:14 <kzm> dcoutts_, and?
04:05:17 <kzm> :-)
04:05:27 <blue> it adds 1 to all numbers
04:05:28 <dcoutts_> kzm, lemme think
04:05:37 <dcoutts_> (and check the code)
04:06:04 <blue> is there any way to keep length(h:t) the same during the recursion?
04:06:16 <kzm> dcoutts_, (it should be easy to write something similar to many FPS functions, withForeignPtr ... go 0 ...where go x y z = ...
04:07:06 <dcoutts_> kzm, yeah, you could use create to make your new strict BS and then Lazy.fromChunks to get the chunks and then write them in one by one.
04:07:15 * kzm got a meeting.  Back later.
04:07:33 <kzm> 'create', huh.  Will check.  Thanks.  Must run.  Now.
04:07:54 <dcoutts_> kzm, Data.ByteString.Base.create
04:09:08 <dcoutts_> dons, page 18, spelling of traversal
04:10:42 <dcoutts_> dons, otherwise looks good
04:10:54 <dcoutts_> some of the graphs are a tad big
04:21:42 <malebria> Hello there.
04:23:35 <malebria> I have a doubt about Control.Exception.catch... I thought that if I had an do expression and try to catch one function in it and the whole do expression it would both catch an exception in this function.
04:23:51 <malebria> @paste
04:23:52 <lambdabot> http://paste.lisp.org/new/haskell
04:25:03 <lisppaste2> malebria pasted "Catch problem" at http://paste.lisp.org/display/29616
04:25:35 <malebria> In the second function, it works fine. In the first, I got uncaught exception.
04:28:29 <dcoutts_> malebria, I don't understand. In the second version you're not catching anything.
04:32:28 <malebria> dcoutts_:         treat $ street_expansion
04:32:48 <dcoutts_> ah yes, I missed that
04:33:13 <malebria> dcoutts_: So exceptions cannot be catched a in a upper level?
04:33:44 <dcoutts_> should be able to
04:34:29 <malebria> dcoutts_: any ideas of why these two give different results?
04:34:46 <dcoutts_> no, sorry
04:35:04 <dcoutts_> are you sure the problem is there?
04:35:15 <dcoutts_> where exactly is the exception being raised ?
04:35:20 <malebria> dcoutts_: I'm not sure if the problem is only here.
04:35:47 <dcoutts_> try using a very simple exception handler that just prints and discards the error
04:35:48 <malebria> dcoutts_: I'm raising an Sql exception from HDBC, by calling postgresql with a wrong function.
04:36:22 <dons> dcoutts_: great. thanks. i've updated a bit here: www.cse.unsw.edu.au/~dons/tmp/streams-talk.ps
04:37:09 <dcoutts_> dons, yay, the graphs fit :-)
04:37:19 <syntaxfree> wow.
04:37:33 <syntaxfree> Philip Wadler illustrated an early printed edition of the Jargon File.
04:37:53 <syntaxfree> http://en.wikipedia.org/wiki/Jargon_File
04:38:11 <dylan> The Wadler?
04:38:48 <dcoutts_> dons, looks good to me
04:38:52 <dons> dylan, there is only one.
04:38:53 <malebria> dcoutts_: hum... now things are a little bit different.
04:39:07 <malebria> I changed treat just to print the exception and continue normally.
04:39:07 <dons> dylan: author of 6/10 of the most cited haskell papers of all time! (amazing)
04:39:16 <dons> aka lambda man
04:39:42 <syntaxfree> yes, The Wadlerman.
04:39:47 <malebria> dcoutts_: With the second option, which was working with the other treat, it was the same.
04:39:55 <syntaxfree> the Prince of Funktions.
04:40:15 <malebria> dcoutts_: but with the first, it first print the exception, and it happened with the second, and then give the uncaught exception problem.
04:40:46 <dcoutts_> dons, I'm less convinced that we should use exists rather than forall in the Stream data decl. The forall refers to the type of the constructor Stream. If it were exists, it should be on the inside of the constructor.
04:40:46 <magr> dons: on slide 6-A, you write "bad for gcc", where (I think) "bad for gc" is meant
04:41:02 <dcoutts_> magr, I think he does mean gcc
04:41:11 <dons> yes :)
04:41:17 <dons> gcc doesn't like haskell code
04:41:29 <magr> who is gcc? :-)
04:41:40 <magr> anyway, "bad for GC" also
04:41:51 <dons> that is also true, yeah
04:42:02 <dons> well, the GC likes lists more than arrays, but still ...
04:42:11 <malebria> dcoutts_: can it be because I'm returning undefined in a IO () function?
04:42:19 <dcoutts_> malebria, certainly
04:42:34 <dcoutts_> data Stream = forall s. Stream (s -> Step s) s, vs something like: data Stream = Stream (exists s. ((s -> Step s), s))
04:42:35 <magr> dons: btw, I like the paper!
04:43:40 * dons `ap` sleep. i'll read any comments in the morning.
04:43:49 <dcoutts_> g'night dons
04:47:12 <lisppaste2> malebria annotated #29616 with "Treat code" at http://paste.lisp.org/display/29616#1
04:47:40 <malebria> dcoutts_: When I try to pass () as a parameter, to make the function doesn't return undefined, it gives me:
04:47:54 <malebria>     Couldn't match the rigid variable `a' against `()'
04:48:26 <dcoutts_> is that in the definition of treat or where you're using it ?
04:48:53 <malebria> in the definition of treat, in the last paste.
04:49:25 <dcoutts_> unless I see the code I've no idea what the mistake might be
04:49:57 <malebria> dcoutts_: but the problem is in this last paste, the way it's it doesn't compile.
04:50:09 <malebria> dcoutts_: I didn't get this error:
04:50:17 <malebria>     Couldn't match the rigid variable `a' against `()'
04:50:17 <malebria>       `a' is bound by the type signature for `treat'
04:50:17 <malebria>       Expected type: a
04:50:28 <malebria>       Inferred type: ()
04:50:29 <malebria>     In the first argument of `treat_', namely `()'
04:50:29 <malebria>     In the definition of `treat': treat fun = treat_ () (const fun) undefined
04:51:06 <malebria> Why can't I pass () as a parameter?
04:51:39 <dcoutts_> malebria, because you've stated that treat has return type IO a, not IO ()
04:52:28 <malebria> dcoutts_: I thought IO b would match for IO ().
04:52:44 <malebria> I mean, I use treat :: IO a -> IO a with IO () functions.
04:53:01 <dcoutts_> malebria, no, you're stating that the caller of the function get's to choose the 'b'.
04:53:24 <dcoutts_> malebria, so if the caller gets to choose the 'b' then you can't constrain it to be ().
04:53:27 <malebria> dcoutts_: ok, I think I get it.
04:53:51 <dcoutts_> that's sort of what 'rigid' means, it's a type you've specified and it must be 'b' for any type b
04:53:51 <malebria> I just changed the treat to IO () -> IO ()
04:53:57 <dcoutts_> yep
04:54:41 <dcoutts_> malebria, as an experiment, try commenting out the type signature for treat, and let the compiler infer the type, then chekc what the compiler inferred.
04:54:49 <dcoutts_> you might find it interesting.
04:55:05 <dcoutts_> and it's a useful trick sometimes if you can't figure out the type yourself
04:55:20 <malebria> dcoutts_: good tip.
04:55:21 <malebria> Thanks.
04:55:44 <dcoutts_> though of course the compiler infers the most general type, you may want to constrain it further
04:56:21 <malebria> IO () -> IO ()
04:56:23 <malebria> =D
04:56:32 <malebria> That's because of my () especified.
04:56:37 <dcoutts_> ok, I was half expecting it to be IO a -> IO ()
04:57:10 <dcoutts_> ah, that's because of the treat_ type is forcing that
04:57:14 <malebria> dcoutts_: yes.
04:57:18 <malebria> in (a -> IO b)
04:57:23 <malebria> the parameter function.
04:57:44 <dcoutts_> yep
04:57:50 <malebria> Thanks!
04:57:54 <dcoutts_> np
04:58:09 <malebria> But now I'll go back to the real problem.
04:58:14 <malebria> About the SpinButton.
04:59:11 <malebria> dcoutts_: Problem solved.
04:59:58 <dcoutts_> dons, the graph you've got was from runs on a faster machine than the one you're using for the other examples. Ie the graph doesn't match the timings you give. Perhaps that's not important.
05:00:19 <dcoutts_> of course, it isn't important, it's just proportional, but it might be confusing to an audience
05:00:52 <dcoutts_> if you want to use the timings from the graph/paper, the precise timings are in the .tex file I think.
05:21:20 <ski> dcoutts_ : agree, wrt 'forall' vs. 'exists'
05:21:59 <dcoutts_> ski, you mean you think it should be forall for the existential data type decls ?
05:22:42 <ski> it should be 'forall' if it is before the data constructor
05:22:51 <dcoutts_> aye
05:23:15 <ski> data Showable = forall x. Show x => S x
05:23:25 <dcoutts_> it'd also be nice to be able to say: [exists a. Foo a => a]
05:23:32 <ski> forall x. Show x => S :: x -> Showable
05:23:40 <ski> forall x. S :: Show x => x -> Showable
05:23:46 <ski> S :: forall x. Show x => x -> Showable
05:23:51 <dcoutts_> eek
05:23:52 <ski> dcoutts_ : aye
05:24:07 <ski> dcoutts_ : just a stepwise derivation ..
05:24:18 * dcoutts_ tries to grok
05:24:28 <ski> forall x. (Show x => (S :: x -> Showable))
05:24:39 <ski> forall x. (S :: Show x => (x -> Showable))
05:24:45 <ski> S :: forall x. (Show x => (x -> Showable))
05:25:24 <ski> "for all types 'x', if 'x' is in 'Show', then 'S' has type 'x -> Showable'"
05:25:31 <dcoutts_> yes
05:25:55 <ski> "for all types 'x', 'S' has type : provided 'x' is in 'Show', 'x -> Showable'"
05:26:07 <ski> "'S' has type : for all types 'x', provided 'x' is in 'Show', 'x -> Showable'"
05:26:46 <ski> hm
05:26:49 <ski> if one has
05:26:51 * dcoutts_ has to go
05:27:02 <ski> foo :: (exists x. ..x..) -> ...
05:27:09 <ski> this can be transformed into
05:27:19 <ski> foo :: forall x. (..x.. -> ...)
05:27:44 <ski> but i recently came into an example where i wanted to do this, but couldn't ..
05:29:59 <syntaxfree> pick a number between 1 and 100, and tell me in a private message.
05:30:49 <ski> syntaxfree : whole number ?
05:30:58 <syntaxfree> ah, yes.
05:31:03 <syntaxfree> pick an integer between 1 and 100.
05:31:09 <syntaxfree> thanks.
05:31:44 * syntaxfree will plot a histogram with the answers received in the next 60 minutes.
05:34:07 * ski seems to recall JohnMeacham had some 'exists' to 'forall' expansion ..
05:39:31 <syntaxfree> no more random n umber contributions?
05:40:57 <ski> @type divides
05:40:59 <lambdabot> Not in scope: `divides'
05:41:18 <ski> @let d `divides` n = n `mod` d == 0
05:41:20 <lambdabot> Defined.
05:43:23 <ski> @let sigma n = sum [d | d <- n : [1 .. cieling (sqrt n)] , d `divides` n]
05:43:25 <lambdabot> <local>:10:34: Not in scope: `cieling'
05:43:30 <ski> @let sigma n = sum [d | d <- n : [1 .. ceiling (sqrt n)] , d `divides` n]
05:43:32 <lambdabot> Defined.
05:43:43 <syntaxfree> why is that sigma?
05:44:03 <syntaxfree> sigma will always mean "standard deviation"!
05:44:28 <syntaxfree> 1/sqrt(2*pi*sigma) * exp (-0.5(y-mu)^2/sigma^2) !!!
05:44:48 <ski> e.g. http://www-gap.mcs.st-and.ac.uk/Manuals/doc/htm/ref/CHAP015.htm
05:44:53 <lambdabot> Title: [ref] 15 Number Theory, http://tinyurl.com/yfp55t
05:44:56 <ski> sigma is a number-theoretic function
05:45:04 <ski> @let decay n = sigma n - n
05:45:06 <lambdabot> Defined.
05:45:18 <syntaxfree> oh.
05:45:58 <syntaxfree> http://c2.com/cgi/wiki?HaskellLanguage <-- this should be fixed.
05:46:01 <lambdabot> Title: Haskell Language
05:46:32 <ski> @let primes = sieve [2..] where sieve (p:ns) = p : sieve (filter (not . (p `divides`)) ns)
05:46:34 <lambdabot> Defined.
05:46:45 <ski> > take 25 primes
05:46:47 <lambdabot>  Not in scope: `primes'
05:46:50 <ski> > take 25 L.primes
05:46:52 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
05:48:06 <ski> @let decayInvs 0 = [1]; decayInvs 1 = primes; decayInv n | n > 1 = [i | i <- [1..(n-1)^2] , decay i == n]
05:48:08 <lambdabot> Defined.
05:48:24 <ski> > map L.decayInv [2..10]
05:48:25 <lambdabot>  Add a type signature
05:48:27 <syntaxfree> that's starting to look like a RNG.
05:48:34 <ski> > map L.decayInv [2..10] :: [Int]
05:48:35 <lambdabot>  Couldn't match `Int' against `[a]'
05:48:39 <ski> > map L.decayInv [2..10] :: [[Int]]
05:48:41 <lambdabot>  add an instance declaration for (RealFrac Int, Floating Int)
05:48:45 <ski> mrf !
05:49:01 <ski> @let decayInvs 0 = [1]; decayInvs 1 = primes; decayInvs n | n > 1 = [i | i <- [1..(n-1)^2] , decay i == n]
05:49:03 <lambdabot> <local>:14:0:     Multiple declarations of `L.decayInvs'     Declared at: <lo...
05:49:25 <syntaxfree> lamdabot should allow per-nickname namespaces.
05:49:40 <syntaxfree> then everyone could access, say, syntaxfree.montecarlo.poisson and so on.
05:49:59 <ski> @undefine decayInvs
05:50:00 <lambdabot> Undefined.
05:50:03 <ski> @let decayInvs 0 = [1]; decayInvs 1 = primes; decayInvs n | n > 1 = [i | i <- [1..(n-1)^2] , decay i == n]
05:50:04 <lambdabot> <local>:1:33: Not in scope: `primes'  <local>:1:88: Not in scope: `decay'
05:50:11 <ski> sigh
05:51:19 <ski> @let decayInvs 0 = [1]; decayInvs 1 = primes; decayInvs n | n > 1 = [i | i <- [1..(n-1)^2] , decay i == n]
05:51:20 <lambdabot> Ambiguous type variable `a' in the constraints
05:51:38 <ski> @let decayInvs :: Integer -> [Integer]; decayInvs 0 = [1]; decayInvs 1 = primes; decayInvs n | n > 1 = [i | i <- [1..(n-1)^2] , decay i == n]
05:51:39 <lambdabot> <local>:5:123:     No instances for (RealFrac Integer, Floating Integer)     ...
05:54:09 <ski> > map L.decayInvs [2..10]
05:54:11 <lambdabot>  [[],[2,4],[9],[],[6,18,25],[16,28,32],[49],[45],[12,24]]
05:54:14 <ski> yes ! :)
05:55:07 <ski> > filter (null . L.decayInvs) [2..100]
05:55:09 <lambdabot>  [2,5]
05:55:35 <Syzygy-> @type null
05:55:36 <lambdabot> forall a. [a] -> Bool
05:55:39 <dcoutts_> syntaxfree, did you get my random num?
05:55:41 <ski> hm
05:55:47 <Syzygy-> > null []
05:55:48 <syntaxfree> dcoutts: actually, I didn't.
05:55:49 <lambdabot>  True
05:55:51 <xerox> ski - what are you coding?
05:55:51 <Syzygy-> > null [2]
05:55:53 <lambdabot>  False
05:55:55 <Syzygy-> Ah.
05:56:00 <ski> (i think i have a bug ..)
05:56:02 <dcoutts_> syntaxfree, I can't pm you as this nick isn't registered
05:56:06 <syntaxfree> it should be called "empty", not "null".
05:56:08 <xerox> Syzygy-: that's better than ([]==) because the type does not contain an Eq constraint.
05:56:16 <Syzygy-> @type (null . L.decayInvs)
05:56:18 <lambdabot> Couldn't find qualified module.
05:56:21 <syntaxfree> ah, just say it aloud. I just didn't want to flood the channel.
05:56:27 <dcoutts_> 23
05:56:28 <syntaxfree> I didn't expect I'd get 3 answers only.
05:57:07 <Syzygy-> dcoutts_: Is that really random?
05:57:19 <dcoutts_> Syzygy-, what makes you doubt it ?
05:57:19 <Syzygy-> Why do we want to give him random numbers anyway?
05:57:37 <syntaxfree> so I can check if they have an uniform distribution.
05:57:41 <dcoutts_> syntaxfree, presumably you're trying to show that we're not very good at picking random numbers? :-)
05:57:43 <Syzygy-> dcoutts_: I've read the Illuminatus! trilogy... :P
05:57:46 <ski> > unfoldr (\n -> if n == 0 then Nothing else let n' = L.decay n in Just (n',n')) 12
05:57:48 <lambdabot>  [10,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
05:57:54 <syntaxfree> I can't say more than that without biasing the results.
05:58:00 <ski> > L.decay 1
05:58:01 <dcoutts_> sure ok :-)
05:58:02 <lambdabot>  1
05:58:05 <ski> bug
05:58:19 <syntaxfree> j #wordpress
05:58:30 <Syzygy-> Forgot a / there...
05:59:02 <syntaxfree> oh.
05:59:07 <syntaxfree> It's this keyboard.
05:59:12 <syntaxfree> the / fails sometimes.
06:04:04 <ski> > unfoldr (\n -> if n == 0 then Nothing else let n' = L.decay n in Just (n',n')) 12
06:04:07 <lambdabot>  [16,15,9,4,3,1,0]
06:04:29 <ski> @ley decaySequence n = n : unfoldr (\n -> if n == 0 then Nothing else let n' = L.decay n in Just (n',n')) n
06:04:30 <lambdabot> Defined.
06:04:57 <ski> > filter (null . L.decayInvs) [2..100]
06:05:00 <lambdabot>  [2,5,52,88,96]
06:05:04 <ski> yes !
06:05:39 <ski> xerox : some small number-theoretic functions i had fun with, when i was in lower school
06:05:59 <xerox> what were those?
06:06:08 <ski> > take 8 (decaySequence 220)
06:06:09 <lambdabot>  Not in scope: `decaySequence'
06:06:13 <ski> > take 8 (L.decaySequence 220)
06:06:15 <lambdabot>  [220,284,220,284,220,284,220,284]
06:06:35 <ski> 220 and 284 are the first "amicable number pair"
06:06:50 <ski> they've been known since ancient times
06:07:17 <ski> > map (take 4 . L.decaySequence) [6,28,496,8128]
06:07:18 <lambdabot>  [[6,6,6,6],[28,28,28,28],[496,496,496,496],[8128,8128,8128,8128]]
06:07:31 <ski> those are the first four "perfect" number
06:07:44 <ski> the old greeks had much fun with these
06:08:15 <ski> > take 10 (L.decaySequence 12496)
06:08:17 <lambdabot>  [12496,14288,15472,14536,14264,12496,14288,15472,14536,14264]
06:08:33 <ski> that's the first "amicable quintuple"
06:08:55 <ski> > take 4 (L.decaySequence 945)
06:08:57 <lambdabot>  [945,975,761,1]
06:09:18 <ski> '945' is the first odd number that "decays" to a larger number ('12' is the first even such)
06:09:44 <ski> > take 10 (L.decaySequence 125)
06:09:46 <lambdabot>  [125,31,1,0]
06:09:52 <ski> > take 10 (L.decaySequence 105)
06:09:54 <lambdabot>  [105,87,33,15,9,4,3,1,0]
06:10:02 <syntaxfree> lambdabot surely has some juice. Those computations sound taxing.
06:10:11 <ski> > take 10 (L.decaySequence 276)
06:10:12 <lambdabot>  [276,396,696,1104,1872,3770,3790,3050,2716,2772]
06:11:08 <ski> '276' is the first number for which it's currently unknown (unless there's been some advance) whether it's sequence terminates (i.e. ends in '0') or enters a loop, or just diverges towards infinity
06:11:36 <ski> > L.decaySequence 220
06:11:38 <lambdabot>  [220,284,220,284,220,284,220,284,220,284,220,284,220,284,220,284,220,284,220...
06:11:42 <ski> > L.decaySequence 120
06:11:44 <lambdabot>  [120,240,504,1056,1968,3240,7650,14112,32571,27333,12161,1,0]
06:12:19 <ski> ('120' is often called the first "tri-perfect" number .. it's 'sigma' is thrice itself)
06:12:40 <ski> > L.decaySequence 1220
06:12:41 <lambdabot>  [1220,1384,1226,616,824,736,776,694,350,394,200,265,59,1,0]
06:12:45 <ski> hm
06:13:11 <ski> anyway, there's lots of fun to be had with these :)
06:13:16 <sieni> hey guys, click some `+' on that: http://bash.org/?705948
06:13:18 <lambdabot> Title: QDB: Quote #705948
06:14:57 <wilx> Awww.
06:15:01 <wilx> I can feel his pain.
06:19:22 <earthy> poor sod
06:35:51 <xerox> ski: you have a taste for number theory?
06:54:16 <Igloo> dcoutts: Configurations mean I can't topologically sort packages without backtracking, right?
07:03:12 <xerox> Igloo: what does that mean? :)
07:05:36 <Igloo> xerox: Which bit?
07:05:50 <therp> is there any canonical example where it is really useful to have functions that are instances of some classes? I'm just figuring out where I would like to use such things, because I haven't seen haskell code using that
07:06:37 <Igloo> therp: I don't understand the question
07:07:33 <therp> igloo: the instance syntax allows function to be an instance of a class. I wonder why I would use that
07:07:48 <Binkley> therp: monads
07:07:53 <Binkley> (among other things)
07:08:07 <therp> ah right, the state transformer is a function
07:09:16 <Igloo> functions are often given a show instance, even if only returning "<function>" or something, too, so that you can derive Show on datatypes containing them
07:09:24 <therp> so, then I have seen some use cases.. usually the state transformer is given a new type and I think that's the reason I've never seen a "->" appearing in an instance definition..
07:09:31 <dcoutts_> Igloo, that may well be true. That's an important issue to keep in mind when designing the configurations.
07:10:35 <Igloo> dcoutts_: I think it's inevitable or we can't handle things like fps
07:10:44 <dcoutts_> Igloo, aye
07:11:13 <dcoutts_> Igloo, what would be nice is if the order didn't really matter
07:11:25 <Igloo> It probably means I'm going to need to be able to lie to cabal about what is installed, somehow
07:11:57 <Syzygy-> @type bind
07:12:01 <dcoutts_> Igloo, for building debian package?
07:12:03 <lambdabot> Not in scope: `bind'
07:12:10 <Syzygy-> @type (>>)
07:12:12 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
07:12:25 <dcoutts_> Igloo, can you think of an example?
07:12:28 <xerox> (Syzygy-: (>>=) is usually called `bind'.)
07:12:30 <Igloo> dcoutts_: For building lots of Debian packages, and also to avoid having to order things manually in GHC's libraries/Makefile
07:12:37 <Igloo> dcoutts_: An example of what?
07:12:38 <Syzygy-> @type (>>=)
07:12:40 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
07:12:46 <dcoutts_> Igloo, where you would need to lie.
07:15:00 <Igloo> dcoutts_: Oh, wait, if all flags are given then I'm going to be fine, aren't I?
07:15:41 <dcoutts_> Igloo, I think so, and you could try setting the flags based on what will be installed at the end.
07:15:47 <Igloo> Except I'm not sure I want to do that for libraries/Makefile
07:16:02 * Igloo decides to do it the simple way for now
07:29:58 <pitecus> is there some way to decide which module to load at runtime?
07:30:47 <glguy> hs-plugins
07:31:03 <pitecus> is that included in ghc, glguy ?
07:31:30 <glguy> I don't believe so
07:31:39 <pitecus> ok
07:33:34 <bringert> pitecus: can also use the GCH API
07:33:42 <bringert> eh GHC
07:34:18 <pitecus> thanks
07:39:34 <shapr> Lemmih: No, HaskellDB, HSQL and PostgreSQL
07:39:50 <shapr> Lemmih: Also, I can't lookup blog.catenova.org
07:42:11 <shapr> dons: I found part or all of the IOHCC code on my drive, I'll put it back online in the next few days.
07:42:16 * shapr puts that on his google calendar.
07:42:59 <shapr> I like the jwz method of doing backups, copy your entire previous homedir onto the new installation/drive.
07:44:57 <araujo> hello
07:45:50 <shapr> yow!
07:46:40 <araujo> @yarr!
07:46:41 <lambdabot> Avast!
07:47:20 <shapr> @quote
07:47:21 <lambdabot> wadler says: Curried food and curried functions are both aquired tastes
07:47:27 <shapr> @quote
07:47:28 <lambdabot> musasabi says: combining Cabal and autoconf is an evil and complex art.
07:47:46 * araujo flips and throws sugar lambdas at everyone
07:47:51 <int-e> @spell acquire
07:47:52 <lambdabot> acquire
07:50:01 <shapr> I think we should distribute Igloo's fabled lambda boomerangs at the next ICFP held in .au
07:51:10 * int-e thinks araujo should be more careful with throwing around sharp and pointy stuff.
07:53:34 <araujo> :-)
07:54:35 <vincenz> ndm: ping
07:54:51 <ndm> vincenz: pong
07:55:55 <vincenz> ndm: concerning your test setup.  What about copying all those quickcheck tests that fail into standard unit tests ;)
07:56:06 <vincenz> that way you have the corner cases well-documented in your testbody
07:56:30 <ndm> vincenz: often the corner cases are quite obscure, hard to pin down, and not useful
07:56:39 <vincenz> I mean the cases that you had it wrong
07:56:42 <ndm> vincenz: i.e. what happens to splitPath with "//c" and joinPath
07:57:02 <ndm> it matters to keep the properties consistent, but for an individual test case its rather useless - since its a silly thing to do
07:57:05 <ndm> but i have moved a few over
07:58:04 <vincenz> ok :)
07:58:18 <vincenz> seems like a good std practice
07:58:21 <vincenz> have some basic unit tests
07:58:29 <vincenz> whenever quickcheck fails, move it over to the std unit tests
07:58:36 <ndm> yes, in general i'd agree
07:58:47 <vincenz> unless, of course, you have pathological cases
07:58:54 <ndm> its just that the filepaths have lots of tests that are silly, but useful to have properties being sensible
07:59:19 <vincenz> couldn't you do something lik
07:59:19 <ndm> i tried to keep the specific cases as documenting behaviour, rather than actual tests
07:59:26 <vincenz> isValidPath path ==> property
07:59:31 <vincenz> and define a proper isValidPath
07:59:55 <ndm> i do for a few properties
07:59:59 <vincenz> :)
08:00:09 <ndm> but i tried to avoid it where possible
08:01:18 <vincenz> why?
08:01:27 <malebria> dcoutts_: are you there?
08:01:28 <vincenz> properties shouldn't hold for invalid paths, should they?
08:01:30 <ndm> because properties are nicer if they are always true
08:01:35 <dcoutts_> @arr!
08:01:36 <lambdabot> Drink up, me 'earties
08:01:40 <dcoutts_> malebria, aye
08:02:01 <ndm> some people might want to play with invalid file paths, i'd rather not spoil their fun
08:02:08 <vincenz> :)
08:02:23 <ndm> i.e. if you have an invalid drive and want to change the extension, namely: 1:\file\file.ext
08:02:25 <malebria> dcoutts_: do you know if there's a way to get when a comboBoxEntry was already edited?
08:02:35 <ndm> why shouldn't replaceExtension work on that
08:02:53 <vincenz> ndm: yeah but pathological cases
08:02:55 <vincenz> like //x
08:03:13 <ndm>  //x/file.ext - replaceExtension should still work
08:03:18 <dcoutts_> malebria, the combo box has a data model, you can get the selction object for that and listen for changes.
08:03:22 <malebria> dcoutts_: without getting when the user is editing..
08:03:30 <ndm> and //c is actually valid, just silly :)
08:03:44 <vincenz> ndm: it is?
08:03:59 <vincenz> ndm: do you compile differently on different plats?
08:04:10 <vincenz> (or is the proper short term "plafs")
08:04:27 <ndm> vincenz: i have System.FilePath which does runtime OS detection
08:04:33 <malebria> dcoutts_: is what you're suggesting different from afterChanged?
08:04:38 <vincenz> ndm: why not go for #ifdef?
08:04:51 <ndm> vincenz: but i have System.FilePath.Posix and System.FilePath.Windows for specific file types regardless of platform
08:04:58 <dcoutts_> malebria, perhaps not. What do you need exactly that onChanged doesn't give you ?
08:05:06 <ndm> vincenz: because what if there is a portable bytecode format?
08:05:46 <malebria> dcoutts_: Something like submit, if the user edit the comboBoxEntry I don't want nothing to happen, just if he press enter.
08:06:12 <vincenz> ndm: so every operation switches?
08:06:28 <ndm> vincenz: yes
08:06:38 <vincenz> ndm: using a monad?
08:06:43 <ndm> vincenz: eek, no!
08:06:47 <ndm> vincenz: using a boolean
08:06:57 <vincenz> why not, have different datatypes for different platfs
08:07:13 <ndm> different data types?
08:07:17 <vincenz> maybe the compiler can do something smart and remove a few checks
08:07:18 <ndm> type FilePath = String
08:07:24 <ndm> Yhc -O can
08:07:28 <vincenz> data FilePathWindows = FPW String
08:07:32 <ndm> yuk
08:07:38 <vincenz> ndm: how?
08:07:40 <ndm> now readFile FilePathWindows fails
08:07:43 <ndm> vincenz: partial evaluation
08:08:20 <ndm> vincenz: whats wrong with using a boolean and doing runtime testing? if anyone can show me a profile of a real program where that really makes a difference, i'll switch to ifdef's
08:08:29 <vincenz> I dunno
08:08:40 <ndm> (and i'll probably switch to ifdef's for submission into base, as thats the normal way of doing it)
08:09:02 <dcoutts_> malebria, it seems that the changed signal does not distinguish selecting an item from the list, vs editing in the entry field, though you can check if there is an item currently selected.
08:09:40 <malebria> dcoutts_: why would it be different from onChanged?
08:10:27 <dcoutts_> malebria, I assume that when one edits something in the entry field then there is no item selected. So you could use onChanged and then check if there's a current selection.
08:10:34 <Pupeno> How do I change how haskell-mode runs ghci to run ghci -fglasgow-exts ?
08:10:44 <malebria> dcoutts_: hum.. let me try.
08:11:34 <psnl> right, booked going to fun in the afternoon
08:11:46 <dcoutts_> psnl, yay
08:12:00 <ndm> psnl: cool, see you there :)
08:12:08 <psnl> dcoutts_: there will be boozing, right?
08:12:15 <dcoutts_> @Yarr!
08:12:16 <lambdabot> Maybe you meant: arr yarr
08:12:21 <dcoutts_> grr
08:12:24 <dcoutts_> @yarr
08:12:25 <lambdabot> Smartly me lass
08:13:00 <vincenz> @yarr
08:13:01 <lambdabot> Arrr!
08:13:07 <dcoutts_> psnl, what time do you expect to turn up? morning or afternoon?
08:15:06 * araujo reading the every-3-months emails about "Writing a new kernel for the Hurd"
08:15:21 <psnl> dcoutts_: afteroon, get into oxford at 1113
08:15:28 <roconnor> ha Data.Unsafe
08:15:41 <roconnor> prety all modules will be moved to being under Data.
08:15:44 <ndm> I think Type.Unsafe is a better name
08:15:49 <roconnor> because ``everything is Data''
08:16:00 <dcoutts_> psnl, ok, great
08:16:09 <araujo> Interestingly enough, they keep proposing House as an alternative ....
08:16:12 <dcoutts_> psnl, I was wondering as I'm organising things for the morning.
08:16:19 <araujo> Among other ones ...
08:16:24 <ndm> then we can have Type.Nat, Type.Code.RSA
08:17:28 <psnl> dcoutts_: I would show up eariler, but it would mean two nights down there
08:17:34 <dcoutts_> aye
08:19:02 * psnl promises to be there for all of lambdahack
08:19:33 <vincenz> psnl: what is this
08:19:48 <shapr> araujo: Someone is suggesting replacing GNU/Hurd with GNU/House?!
08:19:55 <ndm> lambdahack will include hat hacking, hopefully
08:20:10 <shapr> Hm, that would probably work...
08:20:21 <psnl> vincenz: is what?
08:20:28 <vincenz> psnl: what you are attending
08:20:29 <shapr> araujo: Do you have urls to the list archives?
08:20:41 <psnl> ndm: so it will be like any other day for me ;-)
08:21:02 <ndm> psnl: i rarely hack on hat, so a nice change for me
08:21:05 <psnl> vincenz: http://sneezy.cs.nott.ac.uk/fun/
08:21:07 <lambdabot> Title: Fun in the Afternoon
08:21:41 <araujo> shapr, yes
08:21:47 <araujo> shapr, Among other kernel alternatives
08:22:23 <araujo> shapr, Every 3 months or so, these kind of threads start to happen, then they cease after a few weeks of discussions
08:22:26 <shapr> araujo: That reminds me of a post I made to LtU some years ago - http://lambda-the-ultimate.org/node/299
08:22:28 <lambdabot> Title: House , hOp - the Haskell Operating System | Lambda the Ultimate
08:22:43 <araujo> shapr, let me get the threads archives
08:22:52 <shapr> Bored by those lemmings who use wildly popular operating systems such as the HURD? Wondering how Arrows might improve operating system design now that monads are ho-hum? Looking for an opportunity to write a purely functional network driver? If this sounds familiar, hOp, and now House is the project for you!
08:23:11 <shapr> Sometimes I write very silly things.
08:23:44 * psnl goes back to packing
08:24:03 <edwardk> @seen Igloo
08:24:04 <lambdabot> Igloo is in #darcs, #ghc and #haskell. I last heard Igloo speak 1h 8m 1s ago.
08:24:08 <Igloo> edwardk: ?
08:25:08 <edwardk> heya, is there any thought of moving -fno-unit-at-a-time out of ghc and into some config file or checking the version of gcc before usint it? the binary install of ghc-6.6 assumes that my version of gcc supports it, despite being 3.3. I had to hex edit ghc to get stuff to compile =/
08:26:15 <Igloo> edwardk: There is a bug report about that; we plan to do it better at some point
08:26:18 <edwardk> ah k
08:30:57 <araujo> :-P
08:31:00 <araujo> shapr, http://lists.gnu.org/archive/html/l4-hurd/2006-08/msg00031.html
08:32:11 <int-e> @users
08:33:27 <araujo> mm...
08:33:30 <araujo> shapr, ?
08:36:38 <araujo> shapr, http://lists.gnu.org/archive/html/l4-hurd/2006-08/threads.html
08:36:58 <araujo> shapr, several threads refer to House
08:40:27 <shapr> araujo: thanks!
08:44:35 <explicitjelly> i just wrote a fractran interpreter
08:45:24 <explicitjelly> the actual interpreter's got 3 lines
08:50:53 <lambdabot> Title: My Vision, http://tinyurl.com/y4tsms
08:54:08 <shapr> araujo: There's a lot of good stuff in these threads.
08:54:25 <araujo> shapr, yeah , many ideas are proposed
08:55:04 <araujo> shapr, the community is trying to find a new road
08:56:13 <shapr> You and shapiro write pleasing replies. Guillame seems to have good ideas and then act like a troll when he is told to write some code :-)
08:56:29 <araujo> hah
08:57:17 <shapr> Some of your posts imply that OS dev could be faster with a different implementation language. I agree with you.
08:59:20 <lambdabot> Maximum users seen in #haskell: 265, currently: 240 (90.6%), active: 2 (0.8%)
08:59:36 <lambdabot> Title: l4-hurd (thread), http://tinyurl.com/ycp5hk
08:59:44 <shapr> The bot, he is lagged.
08:59:51 <shapr> Boten lambda
09:00:00 <vincenz> @join #oasis
09:00:09 <shapr> lambda heter boten!
09:00:14 <araujo> shapr, yes, pretty much
09:00:36 <vincenz> dons: ping!
09:00:52 <int-e> cool. 28 minutes response time.
09:01:08 <shapr> araujo: Seems to me that a good solution would be to write a domain specific language that extends the ideas of the Hardware monad papers.
09:01:16 <araujo> shapr, i do believe that a programming language could have important influences over an OS design. I also think that the OS community got many things to learn from PL communities.
09:02:26 <edwardk> @seen dons
09:02:27 <lambdabot> dons is in #haskell-overflow, #haskell and #ghc. I don't know when dons last spoke.
09:04:09 <araujo> shapr, that could be a good proposal.
09:04:56 <shapr> One person in that list said that checking all the constraints took much thought. You could instead write a monad or arrow that enforces the constraints by itself.
09:05:57 <shapr> Then you could stack the constraints you want to be in the finished product.
09:21:24 <Syzygy-> I have a datatype Permutation, with constructor PL, which is -really- [Int], but with a bunch of overloading and stuff going on. I want to zip two such permutations, and retrieve the resulting list and juggle that.
09:21:32 <Syzygy-> How do I get out of my datatype again?
09:21:45 <glguy> pattern matching is one way
09:22:21 <glguy> or if you are using record labels, that is the other way
09:22:32 <Syzygy-> Record labels?
09:22:44 <glguy> PL { something :: [Int] }
09:22:55 <mauke> something :: PL -> [Int]
09:22:58 <Syzygy-> Can I still declare it as PL [1,2,3,4] afterwards?
09:23:30 <mauke> yes
09:25:09 <newsham> > let c n = n : c (if n `mod` 2 == 0 then n `div` 2 else 3*n+1) in map (length . takeWhile (/= 1) . c) [1..20]
09:25:17 <lambdabot>  [0,1,7,2,5,8,16,3,19,6,14,9,9,17,17,4,12,20,20,7]
09:26:13 <mauke> @pl let c n = n : c (if n `mod` 2 == 0 then n `div` 2 else 3*n+1) in map (length . takeWhile (/= 1) . c) [1..20]
09:26:15 <lambdabot> map (length . takeWhile (1 /=) . fix (ap (:) . (. ap (ap (if' . (0 ==) . (`mod` 2)) (`div` 2)) ((1 +) . (3 *))))) [1..20]
09:26:21 <mauke> whoa
09:26:43 <glguy> newsham: even
09:26:48 <glguy> if even n
09:27:25 <glguy> and are you intentinoally not using iterate?
09:27:35 <newsham> no, iterate will be nice too
09:28:40 <newsham> > let c n = if (even n) then n `div` 2 else 3*n+1 in map (length . takeWhile (/= 1) . (iterate c)) [1..10]
09:28:41 <lambdabot>  [0,1,7,2,5,8,16,3,19,6]
09:28:45 <glguy> ?hoogle findIndex
09:28:46 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
09:28:47 <lambdabot> Data.Map.findIndex :: Ord k => k -> Map k a -> Int
09:29:07 <glguy> ?hoogle elemIndex
09:29:08 <lambdabot> List.elemIndex :: Eq => a -> [a] -> Maybe Int
09:29:08 <lambdabot> Data.List.elemIndex :: Eq a => a -> [a] -> Maybe Int
09:29:20 <glguy> > findIndex (/=1) [4,6,2,1]
09:29:22 <lambdabot>  Just 0
09:29:37 <glguy> > findElem 1 [4,6,2,1]
09:29:38 <lambdabot>  Not in scope: `findElem'
09:29:45 <glguy> > elemIndex 1 [4,6,2,1]
09:29:46 <lambdabot>  Just 3
09:29:59 <glguy> newsham: that might be closer to what you are using length.takeWhile for
09:31:07 <glguy> > let c n | even n = n `div` 2 | otherwise = 3 * n + 1 in map (elemIndex 1 . iterate c) [1..10]
09:31:09 <lambdabot>  [Just 0,Just 1,Just 7,Just 2,Just 5,Just 8,Just 16,Just 3,Just 19,Just 6]
09:31:15 <newsham> > let c n = if (even n) then n `div` 2 else 3*n+1 in map (fromJust . elemIndex 1 . (iterate c)) [1..10]
09:31:17 <lambdabot>  [0,1,7,2,5,8,16,3,19,6]
09:31:58 <glguy> > let c n | even n = n `div` 2 | otherwise = 3 * n + 1 in [elemIndex 1 $ iterate c x | x <- [1..10]]
09:31:59 <lambdabot>  [Just 0,Just 1,Just 7,Just 2,Just 5,Just 8,Just 16,Just 3,Just 19,Just 6]
09:32:13 <glguy> > let c n | even n = n `div` 2 | otherwise = 3 * n + 1 in [fromJust $ elemIndex 1 $ iterate c x | x <- [1..10]]
09:32:15 <lambdabot>  [0,1,7,2,5,8,16,3,19,6]
09:32:27 * glguy actively avoids using if
09:32:50 <newsham> i'm uncomfrtable using multipe |'s on the same line
09:45:51 <ski> xerox : somewhat :)
09:49:20 <newsham> >>> def c(n) :
09:49:20 <newsham> ...     if n % 2 == 0 : return n/2
09:49:20 <newsham> ...     return 3*n+1  7:48
09:49:20 <newsham> >>> [len(list(takewhile(lambda n : n != 1, iter(c, n)))) for n in xrange(1,10)]
09:49:20 <newsham> [0, 1, 7, 2, 5, 8, 16, 3, 19]
09:49:27 <newsham> doenst quite have the same charm.
09:49:44 <newsham> (also had to make my own iter())
09:53:27 <shapr> Ya know, this is the only programming language irc channel where I've found people who know more than I do about Kolmogorov Complexity.
09:57:33 <shapr> For some reason my relatives consider me to be some sort of world class genius. As a proof of the fact that all the stuff I know and use is just a matter of learning it, I explained shannon's information theory to one of my relatives in five minutes.
09:58:41 <thetallguy> That's okay shapr
09:58:50 <thetallguy> We'll keep you grounded. ;-)
09:58:55 * shapr grins
09:59:41 <shapr> I think the only thing I do differently is that I pursue my interest in these subjects on my own time.
10:00:07 <shapr> My relatives don't read about computer science in their spare time, that's the only difference I see.
10:00:14 <thetallguy> Some people find that strange.
10:00:32 <petter_> hello
10:00:33 <thetallguy> I mean, who doesn't have a book on combinatorics in the bathroom?
10:00:36 <dylan> people use me a database...
10:00:47 <shapr> dylan: Me too
10:01:03 <therp> thetallguy: my bathroom is not about 2 square meters.. :) no space for that
10:01:12 <therp> -not
10:01:21 <thetallguy> So is mine.  I made space
10:01:36 <ski> things out there are interesting .. how could one not try to learn them ?
10:01:41 <shapr> I read my 770 in the bathroom, and it does have combinatorics papers on the mmc card :-)
10:01:43 <jgrimes> I share my bathroom with 7 other people... so... :p
10:01:59 <shapr> ski: I don't know. But I think a lot people spend their spare time doing nothing.
10:02:06 <shapr> jgrimes: Wow, must be a big room.
10:02:24 <dylan> at this point, my mother knows more about operating system design, compiler design, and programming in general than a non-IT person would ever need to know
10:02:24 <jgrimes> generally not at the same time!
10:02:30 <Ugarte> Generally?
10:02:30 <shapr> Other than airports, I've never been in a bathroom with seven other people.
10:02:37 <jgrimes> dylan, haha, same.
10:02:37 <therp> ski: yes, I think the only more beautiful thing then learning is watching a sundown over the ocean (but probably I only think that because I'm not living near the ocean) :)
10:02:50 <chessguy> dylan, you have a very strange mother
10:03:01 <dylan> I feel compelled to explain things to my parents/girlfriend/neighbors...
10:03:15 <boegel> shapr: or small people (Snowwhite and the 7 Dwarfs?)
10:03:17 <dylan> chessguy: it's just from me explaining things to her.
10:03:24 <shapr> dylan: Yes, same for my mother. Though my mother also teaches me stuff in return. My mother has a master's is library science.
10:03:28 <shapr> s/is/in
10:03:30 <therp> dylan: and I felt proud because my girlfriend uses Ubuntu
10:03:41 <shapr> Oh, I feel that same compulsion! I must explain fascinating ideas that I've found recently.
10:03:50 <ski> yes !
10:03:57 * boegel feels stupid in here
10:03:59 <dylan> therp: My girlfriend was using debian before I met her. And freebsd before that. XD
10:04:05 * gour feels proud his wife uses gentoo (she has to :-)
10:04:12 <shapr> hm, my mother does that too... she told me about some gardening research she'd recently stumbled upon, where an orphanage grew their own food on top of their building.
10:04:12 <chessguy> heh. you should here me trying to explain math/comp sci problems to my girlfriend's who's a music therapy major
10:04:59 <shapr> I explain math/cs ideas to my girlfriend who's majoring in jazz saxophone. She does just fine :-)
10:05:04 * ski is lucky to have his brother to explain cool things with monads, continuations, types, categories, logic to
10:05:25 <shapr> Ok, I admit she's sick of hearing about lambda calculus and all its cool features :-/
10:05:33 <dylan> neither of my parents are exactly normal. My life-lessons as a child usually involved some quotation of old poetry or classical greek platitude
10:05:51 <gour> shapr: jazz is in ;)
10:05:54 <petter_> shapr: does your girlfriend explain to you about reharmonisations or something like that in return?
10:05:56 <chessguy> i still don't quite get the whole power of lambda calculus
10:06:25 <therp> shapr: haha :) same here. I usually talk to my girlfriend about Lisp or Genetic Programming
10:06:31 <shapr> petter_: Actually, yes. I've been trying to figure out the math behind the circle of fifths in the last week, but I'm guessing I'd need to understand the pythagorean tuning system to do that correctly.
10:06:45 <chessguy> ooh, a haskeller interested in GP!
10:06:47 <therp> shapr: maybe I should say "I'm talking at her" :)
10:07:08 <chessguy> therp, i'm trying to build a GP framework in haskell
10:07:09 <therp> chessguy: yes, we already talked about that I think
10:07:20 <jgrimes> I still need to pick up a book on GP from the library
10:07:35 <chessguy> oh, i don't remember
10:07:37 <jgrimes> find out a little more about
10:07:42 <jgrimes> it
10:07:47 <therp> chessguy: I'm trying to build a Liskell, so I can build my new great super AI GP framework in it :)
10:07:49 <chessguy> jgrimes, look for one called "genetic programming", by koza
10:07:54 <jgrimes> chessguy, yeah, you told me :)
10:07:59 <chessguy> Liskell?
10:08:10 <petter_> shapr: maybe make a hascore program to generate coltrane solos? :-)
10:08:14 <chessguy> geez, am i that boring, that i just repeat myself all the time?
10:08:25 <therp> chessguy: aehm yes :) the Lisp syntax for Haskell. wait a week and I should have finished my paper on it
10:08:25 <petter_> s/hascore/haskore
10:08:27 <jgrimes> haha
10:09:26 <shapr> petter_: Hey that would rock
10:09:43 <jgrimes> it would also be very impressive
10:09:51 <petter_> or it would swing!
10:10:19 <jgrimes> chessguy, "Genetic programming : on the programming of computers by means of natural selection " ?
10:11:39 <chessguy> yes
10:12:20 <jgrimes> cool deal, it's available via the e-library as well as hard copy. no excuse not to at least look at it. :)
10:12:55 <therp> jgrimes: I would only recommend it if you really want to get into the topic. It's quite huge, although I found it worth reading
10:13:23 <jgrimes> therp, well, I am interested in its methods, at least
10:13:40 <therp> jgrimes: the code in the book won't run on any recent lisp dialect. but after a bit of patching it works..
10:13:48 <therp> ah yes, and that's the book that got me interested in Lisp :)
10:14:22 <jgrimes> :)
10:14:23 <kpreid> hey, neat. #haskell is talking about Lisp (sort of) and #lisp is talking about Haskell (sort of)
10:14:42 <jgrimes> therp, thanks for the info
10:14:45 * jgrimes heads to class
10:14:52 <therp> enjoy
10:15:16 <petter_> in the Functional Programming course i took one of the assignments was a program to generate chord voicings and basslines from chord changes, maybe that excercise could be extended to generating solos
10:16:05 <chessguy> therp, do you have a working copy of the lisp code?
10:16:13 <therp> chessguy: yes
10:16:23 <chessguy> any chance i could get a copy of that?
10:16:35 <therp> sure just a sec
10:17:09 <newsham> petter: sounds interesting.
10:18:06 <newsham> how was it achieved?  generate a large number of possibles and filter over some fitness function (min distance in inner voices, no parallel 5ths and octaves, no awkward jumps, etc..) ?
10:18:15 <therp> chessguy: should work in cmucl and sbcl
10:18:25 <chessguy> oh, i can't get dcc's
10:18:33 <chessguy> can i msg you my email address?
10:18:53 <therp> hm? who then I just sent that to? [19:17] --- DCC SEND gp-koza.tar.bz2 to chessguy complete [10116 cps].
10:19:01 <therp> chessguy: sure
10:19:57 <petter_> newsham: i did something like: generate all notes belonging to a chord(in all octaves), then select a "close" voicing, minimizing the movement from the previous chord
10:20:43 <newsham> so just from one chord to the next?  no more "global" optimization?
10:21:37 <petter_> it was 3 years ago, but i don't think i did a global optimization
10:22:35 <EvilRanter> is it possible to use the prelude functions that take (a -> Bool) with monads?
10:22:42 <EvilRanter> (takeWhile etc)
10:22:42 <petter_> just start on a triad, 1:st inversion and continue
10:25:24 <petter_> i thought about doing a "guitar" version, that generates voicings more like the ones a guitarist would play, or at least chords that are possible to play on a guitar
10:26:38 <petter_> some kind of constraints determining what is possible
10:27:38 <newsham> you a guitarist?
10:27:45 <petter_> yes :-)
10:28:22 <ptolomy> petter_: Ooh. I wrote the same program a few months ago.
10:28:31 <newsham> http://www.thenewsh.com/%7Enewsham/progs/fretboard.c + http://www.thenewsh.com/%7Enewsham/progs/chords.txt
10:28:34 <lambdabot> http://tinyurl.com/ycuyaq
10:29:42 <atsampson> petter_: I did that in Python: http://offog.org/darcs/misccode/chords.py
10:29:50 <petter_> ptolomy: ah, what strategy did you use for generating the chords?
10:30:04 <ptolomy> though mine didn't do transitions between chords, although it did work for an aribitrary number of strings, frets, and in any tuning.
10:30:09 <petter_> ptolomy: voicings, sorry
10:30:38 <ptolomy> I had a few heuristics based on experience that it filtered through.
10:30:40 <EvilRanter> @type fmap until
10:30:42 <lambdabot> forall (f :: * -> *) a. (Functor f) => f (a -> Bool) -> f ((a -> a) -> a -> a)
10:30:54 <EvilRanter> hm.
10:31:00 <EvilRanter> @type fmap takeWhile
10:31:02 <lambdabot> forall (f :: * -> *) a. (Functor f) => f (a -> Bool) -> f ([a] -> [a])
10:32:18 <EvilRanter> is it possible to transform, say, takeWhile to be :: (Functor f) => (f a -> f Bool) -> f a -> f a ?
10:32:38 <EvilRanter> er, -> f [a] -> f [a], rather
10:33:04 <petter_> ok, I mean first it seems easy, you can only play six notes at once, those notes have to be in certain intervals... but then you only have 4 fingers and a thumb, what combinations are possible, couldn't the program easily generate "impossible" stretches for the fingers?
10:33:45 <newsham> heh..  yah, guitar..  easy to write for! ;-)
10:34:12 <ptolomy> and what is possible varies from person to person.
10:34:19 <ski> @type takeWhile
10:34:21 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
10:34:26 <ptolomy> I choose to err on the side of generating questionably playable things and letting the user choose.
10:34:30 <newsham> you can have some general expectation about what a well trained guitarist can play
10:35:15 <atsampson> I think the opposite problem is more interesting: what's the optimal guitar tuning that makes all chords as easy as possible to play?
10:35:24 <ski> EvilRanter : do you really need the argument type being '(f a -> f Bool)' ?
10:35:49 <EvilRanter> ski, I've got an IO [String
10:35:51 <EvilRanter> ]
10:36:10 <EvilRanter> so, i think so... do say if you can think of a better approach
10:36:12 <ski> (since that is probably more general argument than possible to implement)
10:36:17 <newsham> atsampson: "all chords" == ?  at least one of each?  including those built above the triad?   using all strings for all chords or is it ok to skip some strings?
10:36:27 <ski> EvilRanter : 'f' is 'IO' in your case ?
10:36:37 <EvilRanter> yes
10:36:37 <newsham> i think for generality the "normal" tuning is going to win because it gives you access to all notes
10:36:58 <newsham> where as more specialized tunings can make notes inaccessible
10:37:09 <ski> EvilRanter : if you could provide some context (e.g. by pasting), i could see if i could come up with something ..
10:38:46 <petter_> Frank Gambale has started to use some kind of new tuning which enables him to play chords more like a pianist
10:38:54 <petter_> closer intervals
10:39:39 <EvilRanter> manyStrings <- f_takeWhile (not . null) $ repeat getLine; otherString <- getLine  -- define f_takeWhile
10:39:40 <petter_> pltolomy: you could give the length of the musicians fingers as an argument to the function :-)
10:39:43 <newsham> does he use more strings?
10:40:06 <petter_> no, but a two-neck guitar, one neck with normal tuning, one with the new tuning
10:40:32 <EvilRanter> I have something that fills manyStrings correctly, but it uses getContents, and leaves nothing for otherString
10:43:12 <chessguy> @djinn (a -> Not b) -> (b -> Not a)
10:43:13 <lambdabot> f a b c = a c b
10:43:35 <newsham> You can still play a D chord and it comes out as the major triad, but the pitches are different.
10:43:43 <newsham> weird..  his tuning is compatible with old fingerings?
10:44:20 <petter_> yes, I never understood that bit
10:44:34 <petter_> he doesn't explain how it is tuned right?
10:44:55 <newsham> there's some hints that he's patenting it.  if so i imagine you can just go look it up on the patent database
10:46:08 <petter_> hmm, can you patent such a thing?
10:48:08 <newsham> probably not, but he's a musician, what does he know :)
10:48:19 <ski> EvilRanter : @type f_takeWhile
10:48:37 <EvilRanter> f_takeWhile :: (Functor f) => (a -> Bool) -> f [a] -> f [a]
10:50:22 <newsham> nothing for frank and gambale on the patent db
10:50:29 <ski> EvilRanter : hm, and what do you want to do there, instead ?
10:50:49 <EvilRanter> ski, sorry, what?
10:50:57 <ski> (or did you wonder how to define 'f_takeWhile' ?)
10:51:01 <EvilRanter> yes.
10:51:04 <ski> oh
10:51:41 <EvilRanter> @type fmap (takeWhile (/=0))
10:51:42 <lambdabot> forall (f :: * -> *) a. (Functor f, Num a) => f [a] -> f [a]
10:51:45 <EvilRanter> gotcha
10:52:00 <kpreid> @type \f x -> fmap (f x)
10:52:01 <lambdabot> forall (f :: * -> *) a b t. (Functor f) => (t -> a -> b) -> t -> f a -> f b
10:52:04 <EvilRanter> just had a brainwave looking at the type def you just tesed out of me
10:52:09 <kpreid> @type (\f x -> fmap (f x)) takeWhile
10:52:10 <lambdabot> forall (f :: * -> *) a. (Functor f) => (a -> Bool) -> f [a] -> f [a]
10:52:13 <ski> i don't think you can do it with just 'Functor' .. 'Monad' will do (as will 'Applicative'), i think
10:52:25 <kpreid> @pl (\f x -> fmap (f x))
10:52:26 <lambdabot> (fmap .)
10:52:30 <ski> @type \f -> liftM (takeWhile f)
10:52:32 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> Bool) -> m [a] -> m [a]
10:52:41 <kpreid> type (fmap . takeWhile)
10:52:44 <ski> @type liftM
10:52:45 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
10:52:52 <kpreid> @type (fmap . takeWhile)
10:52:53 <lambdabot> forall (f :: * -> *) a. (Functor f) => (a -> Bool) -> f [a] -> f [a]
10:52:53 <ski> or maybe i'm just stupid :)
10:53:03 <JohnMeacham> ski: yes, jhc has existentials, so you can do 'type Any = exists a . a' and stuff like that.
10:53:11 <kpreid> @type (fmap `fmap` takeWhile)
10:53:12 <lambdabot> forall (f :: * -> *) a. (Functor f) => (a -> Bool) -> f [a] -> f [a]
10:53:15 <ski> JohnMeacham : and you can do :
10:53:22 <ski> foo :: (exists a. ..a..) -> ...
10:53:25 <ski> and it means
10:53:33 <ski> foo :: forall a. (..a.. -> ...)
10:53:37 <ski> JohnMeacham : ?
10:53:41 <JohnMeacham> yes.
10:53:47 <ski> how about
10:54:01 <ski> foo :: (forall a. exists b. ..a..b..) -> ...
10:54:02 <ski> ?
10:54:14 <ski> (i ran into this some days ago)
10:54:45 <newsham> http://mb.frankgambale.com/NonCGI/Forum1/HTML/003745.html
10:54:48 <lambdabot> Title: Raison D'etre Tabs Up - NEW GAMBALE TUNING REVEALED - Frank Gambale's Message Bo ..., http://tinyurl.com/vksan
10:55:31 <ski> (the problem is that 'b' can logically depend on 'a', so it's hard to move out .. without converting the 'forall a. ' into 'exists a. ' .. one could eliminate that with some Church CPS, i think, but i'd like to avoid that)
10:55:50 <ski> (also, i'd prefer not to skolemize 'b' over 'a')
10:56:09 <pitecus> can i "include" a file for another one in GHC?
10:56:22 <JohnMeacham> right now, it trys to convert everything to foralls. there is experimental support for first class existentials.
10:56:39 <EvilRanter> pitecus, :also /path/to/other/file at the prompt
10:56:45 <JohnMeacham> which would allow them in arbitrary contexted.
10:56:57 * EvilRanter is away: eats
10:57:00 <ski> (EvilRanter : but, i still think you can't do it if you want to add 'f' in the argument function, too)
10:57:45 <ski> JohnMeacham : ok  (i know Mercury has support for first class existentials .. they do their 'ST'-thing like that :)
10:58:04 <pitecus> At what prompt?
10:58:20 <JohnMeacham> yeah, they would be translated to an unboxed tuple of a value and its type.
10:58:41 <ski> why keep the type at run-time ?
10:58:52 <newsham> so this tuning is in the same intervals, except the first two strings are in different octaves.
10:59:12 <ski> i'm thinking of cases where the caller should be polymorphic in what the type-variable is, so it should work parametrically, no ?
11:01:16 <ski> data StackOps s = S {empty :: s,push :: Int -> s -> s,pull :: s -> Maybe (Int,s)}
11:01:24 <ski> stackOps :: exists s. StackOps s
11:01:56 <ski> (so a caller of 'stackOps' here must be polymorphic in 's')
11:02:42 <JohnMeacham> because you might use it. if you don't then dead code elemination will get rid of it. In any case, it is needed for the intermediate translation anyway.
11:02:52 <ski> mhm
11:03:20 <ski> i guess you possibly could use such for 'Dynamic' things .. but it seems an orthogonal thing, imo
11:07:36 <Botty> pitecus: at the ghci prompt.  Looks like "Prelude>"
11:07:40 <pitecus> How can import a module A into module B and reexport from module B all functions experted by A?
11:07:57 <skew> list "module A" in the export list
11:08:02 <pitecus> Botty, I was actully asking about including a file in another file
11:08:08 <Botty> ohh
11:08:21 <pitecus> skew thanks
11:08:39 <skew> if you truly want to include one file in another, you have to use a preprocessor
11:08:50 <skew> isn't import enough?
11:09:26 <pitecus> Might be enough
11:15:16 <pitecus> So in module B I have "import qualified Data.Map as Map" and I have "module Map" in its export list. When I import module B and try to use Map.fromList I get a not in scope error.
11:15:38 <skew> It will show up as B.fromList
11:17:00 <pitecus> All of Map.fromList, B.fromList and fromList give the same not in scope error...
11:23:49 <edwardk> Any ideas about: lambdabot> > 1 + 1
11:23:49 <edwardk>  fd:6: hClose: resource vanished (Broken pipe)
11:25:19 <shapr> hey wli, ltns.. how's code?
11:25:37 <shapr> edwardk: Maybe the host box is running out of resources? Doesn't it call plugs in a wrapper?
11:27:08 <edwardk> shapr: the host box is pretty much empty
11:27:09 <ptolomy> Anyone have a favorite way to left-pad a string with spaces? (added extra spaces to make the string length N if (length stirng) < N, if (length string) >= N, return string)
11:27:15 <ptolomy> the way I'm doing it seems less idiomatic.
11:27:33 <edwardk> shapr: i am trying to make all of this work under 6.6 which has required jumping through some hoops, but i wouldn't think it would affect this part
11:29:08 <shapr> I've heard that hs-plugins doesn't yet work with ghc 6.6, and I know that @eval / @plugs require hs-plugins. Could that be the problem?
11:29:15 <edwardk> ah
11:29:19 <edwardk> that could be it =)
11:29:23 <xinming> anyone here would give me a url for distinguishing data and newtype difference?
11:29:29 <Botty> ?hoogle Int -> String -> String
11:29:30 <lambdabot> No matches, try a more general search
11:29:32 <edwardk> i got djinn working, but i guess thats a script not a plugin, eh?
11:29:35 <shapr> On the other hand, I heard that dons was going to fix hs-plugins for ghc 6.6 last weekend,so maybe the latest darcs repo version will help?
11:29:43 <shapr> I don't know.
11:29:50 <shapr> Does hs-plugins have a test suite?
11:29:57 <shapr> runghc Setup.hs test ?
11:30:16 <edwardk> not sure. going to pull the current copy and see if it works. it built fine in 6.6, but i don't know if its usable =)
11:32:13 <Botty> > let pad n s | (n >= length s) = replicate (n - length s) ++ s in pad "hello" 10
11:32:15 <lambdabot>    Expecting a function type, but found `[a]'
11:32:15 <lambdabot>    Expected type: [a]
11:32:15 <lambdabot>   ...
11:32:22 <edwardk> hrmm the test cases for it give lots of fun messages like:
11:32:22 <edwardk> a.out: Ix{Int}.index: Index (196608) out of range ((0,12)), so its probably fubared =)
11:32:51 <Botty> > let pad n s | (n >= length s) = replicate ((n - length s) ++ s) ' ' in pad "hello" 10
11:32:53 <lambdabot>  Couldn't match `[a]' against `Int'
11:33:31 <Botty> > let pad n s | (n >= length s) = (replicate (n - length s) ' ') ++ s in pad "hello" 10
11:33:33 <lambdabot>  Couldn't match `Int' against `[Char]'
11:33:43 <edwardk> trying via darcs
11:34:02 <Botty> > let pad n s | (n >= length s) = (replicate (n - length s) ' ') ++ s in pad 10 "hello"
11:34:03 <lambdabot>  "     hello"
11:34:16 <Botty> ptolomy ^
11:35:05 <ventonegro> > let pad n s | (n >= length s) = (replicate (n - length s) ' ') ++ s in pad 2 "hello"
11:35:06 <lambdabot>  Non-exhaustive patterns in function pad
11:35:46 <Botty> > let pad n s = (replicate (n - length s) ' ') ++ s in pad 2 "hello"
11:35:48 <lambdabot>  "hello"
11:35:59 <Botty> oh, cool, better not to have the guard
11:36:22 <ventonegro> hmm
11:36:29 <ventonegro> > replicate -3 'a'
11:36:30 <lambdabot>  add an instance declaration for (Num (Char -> Int -> a -> [a]))
11:36:58 <Botty> > replicate (-3) 'a'
11:37:00 <ventonegro> > replicate (-3) 'a'
11:37:00 <lambdabot>  ""
11:37:01 <lambdabot>  ""
11:37:07 <Botty> hehe
11:37:14 <edwardk> and the darcs version is just as hosed
11:37:24 <edwardk> time to recompile it all over with 6.5 =/
11:37:28 * edwardk cries.
11:37:40 * edwardk bucks up and gets back to work
11:47:58 <Pupeno> In something like: data Color a = Color a a a, can I limit a to belong to a type that is instance of the class Num ?
11:58:03 <sylvan> data Num a => Color a = Color a a a
11:58:03 <edwardk> shapr: alright, new dilemma, under ghc 6.4.2 i get the same problem =(
11:59:07 <edwardk> but at least there, it runs the test suite for hsplugins
12:16:27 <Pupeno> sylvan: thanks.
12:18:47 * ski would like 'Reader' to be named otherwise ..
12:25:19 <Excedrin> ski: what should it be named? (I'm not familiar with what it does..)
12:25:44 <ski> well, one possibility is 'Environment'
12:26:08 <ski> it keeps track of a dynamic environment, that can be read, but not updated
12:26:45 <ski> however, you can locally change it, when you run a sub-computation
12:26:46 <ski> (but it will automatically change back, when that sub-computation is done)
12:27:14 <ski> Excedrin : would you happen to know about "dynamical scoping" (or "implicit parameters") ?
12:28:15 <Excedrin> I know dynamic scope, but I don't know if that's the same thing
12:28:50 <ski> (one use of environment is for a config, that you want to set once, when you call something on top-level, but that you seldom of never want to change locally, so you don't want to bother with explicitely passing the config around in argument(s))
12:29:18 <ski> (e.g. the indent level of a pretty-printer could be an environment)
12:29:59 <ski> dynamical scope is roughly the same thing, yes
12:30:40 <ski> (and i'm referring to the 'dynamic extent' part of that term)
12:32:12 <ski> arg .. sorry, i managed to confuse the terms, anyway
12:34:35 <ski> roughly s/dynamic extent/indefinite scope/ in the sense of http://www.supelec.fr/docs/cltl/clm/node43.html
12:34:38 <lambdabot> Title: 3. Scope and Extent, http://tinyurl.com/ymjh3z
12:56:49 <dons> heh, http://programming.reddit.com/info/qcmo/comments
12:56:49 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
12:56:52 <lambdabot> Title: Colorized lambdabot for Windows (reddit.com), http://tinyurl.com/y9lyhv
12:59:55 <shapr> Today's crazy idea is to implement 3G services in Haskell with the GNU USRP.
13:00:34 * shapr smacks himself back into focus...
13:01:33 <ski> focus !
13:01:58 * ski has some ideas about focus in logic
13:02:14 <ValarQ> ?
13:02:37 <ski> map f [a ...] = [f a ...]  -- imagine this being valid syntax :)
13:03:17 <ValarQ> hmm :/
13:03:43 <ski> or
13:04:00 <ski> foo (\x -> y) = let x = 4 in y*2
13:06:12 <Botty> Yeah, I think it'd be cool if $ traversed the right side until its broken down to the arguments that the left side function takes.  This would probably screw with inference, but hey
13:06:25 <Botty> so map f [a ...] = f $ [a...]
13:07:05 <ValarQ> ok, now im scared...
13:07:28 * dcoutts is too
13:08:04 <Botty> (note, my equality, and I presume ski's equalitys are equivalence, not definition)
13:08:08 <SamB_XP> what about the substitution syntax?
13:08:28 <int-e> length $ [[1],[2,3]] ... is that 2 or [1,2]?
13:08:38 <int-e> scary.
13:08:54 <roconnor> int-e: depends if the result type is a list or not
13:08:56 <Botty> 2 because it's already broken down enough...
13:09:06 <Botty> problem is how do you get [1,2], heh
13:09:24 <ski> Botty : you should talk to edwardk about that
13:09:53 * ski 's equality is indeed definition !
13:10:09 <Botty> oh jeez
13:10:49 <ski> i have a sketch of a type system for it :)
13:11:17 <ski> (and it appears to make sense, logically)
13:14:57 * EvilRanter is back (gone 02:18:00)
13:16:07 <ValarQ> welcome back mr Ranter
13:17:37 <EvilRanter> re
13:27:20 * SamB thinks it is funny how they make it sound like they were planning all along to use Stream Fusion to make fps fast...
13:27:43 <dcoutts> SamB, ?
13:27:54 <SamB> "We have implemented ..."
13:28:06 * dcoutts doesn't understand
13:28:09 <SamB> well, I suppose you did totally change it...
13:28:40 <dcoutts> we started with functional array fusion, we flirted with build/foldr and then came up with streams
13:28:54 <shapr> Where are you going next?
13:28:59 <shapr> Where can you not go?
13:29:00 <dcoutts> more streams
13:29:16 <dcoutts> streams for lists and other sequences
13:29:20 <SamB> The "We have implemented ...", if read alone, sounds like you did it from the ground up with Stream Fusion in mind...
13:29:21 <dcoutts> more proofs
13:29:40 <lennart> I want stream fusion versions of the list functions
13:29:44 <dcoutts> SamB, well the thing is you have to document the result, not the path you took to get there
13:29:57 <dcoutts> lennart, we're working on just that
13:30:04 <lennart> excellent
13:30:08 <skew> have you looked at how stream fusion gets along with zip?
13:30:16 <lennart> because what ghc has now just doesn't cut it
13:30:16 <dcoutts> a little
13:30:20 <monochrom> "I have become a Christian" does not sound like I had planned to become a Christian all along.
13:30:24 <dcoutts> zip should be fine
13:30:35 <SamB> well, "we have retrofitted [fps] with Stream Fusion" would sound more accurate to me
13:30:40 <monochrom> In fact it's most obviously unplanned and spontaneous.
13:30:55 <monochrom> "I have become pregnant" neither :)
13:31:16 <lennart> "We have implemented ..." sounds good to me.  It's what they did, planned or not.
13:31:27 <skew> dcoutts: for example, the GHC strategy only lets zip fuse with one argument
13:31:54 <dcoutts> lennart, the stream stuff is generic in the sequence so it mostly just carries over from the stream stuff we did for fps, though now we want a firmer theoretical basis since while people might not mind us taking liberties with semantics for their big chunks of bytes, they'll complain betterly if we mess with lists.
13:32:05 <dcoutts> skew, this works in both
13:32:05 <monochrom> SamB-wife: You won't believe it!  I've become pregnant!   SamB: So you have been planning this all along since the first day we met...
13:32:34 <SamB> um
13:32:40 <monochrom> hee hee hee!
13:32:44 <lennart> dcoutts: true :)
13:32:50 <SamB> I'm afraid reductio-ad-absurdium doesn't work with connotations!
13:33:28 <dcoutts> lennart, so I've been reading up of proving properties of co-recursive programs :-)
13:33:32 <dcoutts> of/on
13:33:38 <skew> dcoutts: have you written up what zip would look like?
13:34:09 <skew> it seems like Skip might be a bit of trouble
13:34:15 <dcoutts> skew, zip xs ys = unstream (zipS (stream xs) (stream ys))
13:34:26 <dcoutts> skew, yeah, that is trouble
13:34:31 <skew> I meant what zipS looks like
13:34:39 <dcoutts> yeah :-) that's the tricky bit
13:34:43 <SamB> hah
13:34:51 <dcoutts> well it's doable of course, but it needs a recursion
13:34:59 <dcoutts> a nested recursion
13:34:59 <monochrom> David Parnas has a great article on why a report should sound like you have been planning it all along.
13:35:04 <monochrom> (and how)
13:35:34 <xerox> monochrom: got an url?
13:35:46 <monochrom> No.
13:35:46 <skew> dcoutts: it looks like a stream producer is basically an unfold
13:35:53 <dcoutts> skew, yes.
13:37:12 <moconnor> How do you write "foo x y = guard $ (x /= y)" in a point free form?  (Or rather, how do you use the bots pointfree refactoring thingy)?
13:37:21 <SamB> Well, it is more impressive if the authors were planning on having it sound like that.
13:37:25 <moconnor> I expect "foo = guard . (/=)" to work, but it doesn't.
13:37:30 <xerox> (guard .) . (/=)
13:37:36 <EvilRanter> @pl foo x y = guard $ (x /= y)
13:37:36 <lambdabot> foo = (guard .) . (/=)
13:37:37 <dcoutts> @pl \x y -> guard $ (x /= y)
13:37:37 <lambdabot> (guard .) . (/=)
13:37:41 * xerox wins!
13:37:42 <SamB> and agree with those who know otherwise that it sounds funny ;-)
13:37:48 <xerox> let (.:) = (.) . (.) in guard .: (/=)
13:37:52 <xerox> too.
13:37:55 <EvilRanter> I suspected that, i just wanted to check
13:38:00 <skew> does oleg's deep composition operator work there?
13:39:14 <moconnor> What is (guard .) doing?  is . there still function compoisition?
13:39:15 <xerox> prolly
13:39:18 <xerox> yes it is.
13:39:53 <monochrom> "A Rational Design Process: How and Why to Fake It"
13:40:06 <xerox> (guard .) . (/=) = \x -> guard . (x /=) = \x y -> guard (x /= y)
13:40:17 <monochrom> I'm sorry if all the good articles are not on the web.
13:40:29 <xerox> http://web.cs.wpi.edu/~gpollice/cs3733-b05/Readings/FAKE-IT.pdf
13:40:34 <lambdabot> http://tinyurl.com/yxhcc6
13:41:11 <skew> the internet overflows with copies
13:41:47 <monochrom> Every I ever needed to know I learned from books.
13:42:15 <monochrom> And everything crackpot I ever ran into I found from the web.
13:42:37 <monochrom> GHC is the exception.
13:42:59 <moconnor> xerox: I see now.  Thank you.
13:43:32 <xerox> You're welcome moconnor!
13:44:59 <skew> http://okmij.org/ftp/Haskell/polyvar-comp.lhs
13:45:12 <EvilRanter> is there a nicer way of saying \_->(...)?
13:45:21 <skew> const ...?
13:45:22 <xerox> const
13:45:39 <xerox> skew: polyvariadic functions are lovely
13:45:46 <monochrom> Sadly, const x is longer than \_->x
13:46:04 <xerox> k = const -- ?
13:46:13 <EvilRanter> monochrom, but less perly, and I guess that's a good thing
13:46:22 <int-e> monochrom: not really, because the latter should have two more spaces
13:47:17 <skew> and they take parens in the same contexts, I think
13:47:32 <ski> '(.:)' strikes again !
13:48:05 <xerox> ski yeah...
13:48:11 <xerox> sections are neater :P
13:48:18 <ski> bah :)
13:48:42 <SamB> const may be longer, but looks nicer, and requires less thinking about parens...
13:49:20 <SamB> not to mention being easier to pronounce
13:49:24 <skew> actually, \_ looks nicer in some places
13:49:42 <SamB> well, it depends...
13:49:52 <skew> like when you are setting up callbacks or something, for symmetry with other cases
13:50:20 <sjanssen> @keal
13:50:20 <lambdabot> better be atleast 16x16 color with extended ascii set
13:51:42 <skew> Oh, "(->) a" isn't an instance of MonadPlus
13:52:20 <ski> how would it be ?
13:52:23 <skew> so guard `mcomp` (/=) might work
13:53:13 <skew> the problem with all these functional dependency things is that they kind of break inference
13:54:00 <skew> the arguments can't be found just from knowing the results
13:56:01 <xerox> skew: the arguments to what?
13:56:14 <skew> the types on the argument and result sides of the dependencies
13:56:16 <xerox> typevars in classes?
13:56:27 * EvilRanter condenses his previous code singificantly, by figuring that what he wrote as "return $ (x:) =<< xs" (amoung many others) should've been just "fmap (x:) xs"
13:56:30 <xerox> right, those
13:56:33 <skew> and I think even if you do promise GHC that something is a bijection, it won't use it in inference
13:57:00 <xerox> class C a b | a -> b, b -> a ?
13:57:18 <skew> yeah
13:57:35 <dcoutts> did you notice that Simon PJ has made class constraints on data types mean the right thing ?
13:57:47 <skew> I saw that
13:57:57 <dcoutts> so if you have: data Foo = Bar a => Foo ...
13:58:01 <skew> I wonder if Omega examples translate now
13:58:03 <xerox> what did happen?
13:58:23 <skew> dcoutts: not quite - if you write data Foo where Foo :: (Bar a) => ...
13:58:29 <dcoutts> then you can use the Bar class when you do case analysis on the Foo construcor
13:58:42 <dcoutts> skew, yeah, GADT syntax only.
13:58:48 <skew> oh
13:58:53 <skew> ok, rather.
13:58:55 <dcoutts> who else thinks we should fix the meaning for Haskell' ?
13:59:01 <skew> yeah, that sounds good
13:59:06 <Igloo> dcoutts: Do you happen to know where hooks can find the ghc-options field from the cabal file?
13:59:11 <skew> hmm
13:59:31 <skew> well, the current meaning seems to have some purpose as well
13:59:37 <dcoutts> Igloo, not off the top of my head, I presume it's in the build options somewhere
13:59:51 <dcoutts> skew, it's almost totally useless.
13:59:52 <skew> but I'd rather provide that by letting type synonyms include class constraints, and floating them out
14:00:39 <dcoutts> skew, where is the current H98 meaning of class constraints on data constructor helpful ?
14:00:47 <Igloo> dcoutts: Ah, i think it gets mangled into "options"
14:01:21 <skew> oh, it doesn't do what I was thinking. It is actually totally useless
14:01:22 * Igloo disappears
14:01:38 <skew> I thought that mentioning the type in a type sigature automatically added some constraints
14:01:45 <skew> but you still have to list them explicitly
14:01:45 <dcoutts> all it does is change the type of the constructor, in a totally useless way
14:02:43 <skew> and as I said, I'd prefer to let type signatures add constraints on their arguments, if we want e.g. mentioning Map k v to automatically imply an Ord k constraint
14:03:29 <dcoutts> note that it'll allow Set as an instance of Monad
14:03:39 <skew> Ah, finally
14:03:43 <dcoutts> since you'll be able to rely on the Ord constraint
14:03:51 <skew> It's a great time to be a Haskell programmer.
14:04:26 <dcoutts> so for Haskell2 I presume we'll adopt GADT syntax for all data decls
14:04:48 <skew> I don't know about that, the current syntax is nicer for simple cases
14:05:00 <skew> much less repeating the name of the type being defined
14:05:02 <dcoutts> hia andygill
14:05:27 <SamB_XP> what version number does todays Haskell report have?
14:05:32 <xerox> I never use GADTs :(
14:05:48 <skew> xerox: it sounds like in a few more weeks SPJ will have made them very interesting
14:05:50 <dcoutts> SamB_XP, 98 :-) (2003 revised edition)
14:06:05 <SamB_XP> no, I meant the *real* version number
14:06:11 <skew> 1.5?
14:06:15 <SamB_XP> like, win2k is 5.0
14:06:22 <skew> it is the Haskell 98 report
14:06:30 <ski> @yarr
14:06:30 <xerox> skew - huh, any idea what the cool part is about?
14:06:31 <lambdabot> I'll crush ye barnacles!
14:06:36 <skew> the versions before were 1.2, 1.3, 1.4
14:07:04 <skew> xerox: type classes will work with them
14:07:22 <skew> and between functional dependencies and GADTs you can do a whole lot of nifty type-level stuff
14:07:28 <xerox> skew, ack! what does it imply? more type-level-computation stuff available?
14:07:32 <skew> read about Tim Sheard's Omega
14:07:44 <SamB_XP> surely it has an internal, hidden version number somewhere!
14:08:17 <xerox> skew ah! from his home-page: "I have recently been experimenting with a new idea that has been coined "Generalized Algebraic Data Structures". They support the construction, maintenance, and propagation of semantic properties of programs using powerful old ideas about types (the Curry-Howard Isomorphism) in surprisingly easy to understand new ways"
14:08:18 <Botty> gah, ubuntu repository is so bad.  GHC is at 6.4...  Not the only thing that's old, practically everything is a few increments behind latest stable
14:09:35 <xerox> skew, is the extensible kinds programming language?
14:09:36 <SamB_XP> XP is 5.1...
14:09:42 <skew> that's the one
14:09:48 <xerox> cool, i've seen that
14:10:03 <xerox> and we will be able to do _that_ stuff then?
14:10:07 <skew> basically, with GADTs without this type class stuff, you can define structures whose correctness conditions rely on things being the same
14:10:15 <skew> like a simply-typed lambda calculus
14:10:42 <skew> this stuff Simon is working on should let you use any conditions you can compute with type classes
14:10:55 <xerox> (in which there is only one type?)
14:11:07 <skew> no, without polymorphism
14:11:13 <xerox> ah.
14:11:20 <skew> if you've seen any of the GADT papers you've seen the AST
14:11:28 <xerox> nope :(
14:12:03 <skew> I'm talking about things like append :: (AddNat n m n_plus_m) => Vec n a -> Vec m a -> Vec n_plus_m a
14:12:19 <xerox> cool
14:12:51 <skew> if you've got Vec n a where VNil :: Vec Z a; VCon :: a -> Vec n a -> Vec (S n) a
14:13:12 <ski> hm, i recall there was a paper about type class functions, instead of predicates, that could be used when there's functional dependencies anyway
14:13:32 <ski> append :: Vec n a -> Vec m a -> Vec (AddNat n m) a
14:13:40 <xerox> skew: right
14:13:52 <xerox> ski: that looks nice
14:13:52 <skew> and class AddNat n m s | n m -> s, with instance AddNat Z n n, instance AddNat m n n_plus_m => AddNat (S m) n (S n_plus_m)
14:13:54 <ski> class AddNat n m = n_plus_m where ...
14:13:59 <SamB_XP> ski: doesn't that only work forwards, though?
14:14:16 <skew> you can write it out today, but it won't type
14:14:21 <ski> SamB_XP : i'm not sure .. possibly it could work both ways
14:14:34 <SamB_XP> huh
14:14:37 <xerox> skew, oh.
14:14:49 <skew> once this is done you should be able to write the case append VNil vs = vs
14:15:03 <skew> and have it realize n = Z in that case so n_plus_m = n works
14:15:19 <skew> now it won't figure that out for you
14:15:42 <skew> and fixing that doesn't actually have anything to do with carrying dictionaries around in datatypes
14:17:41 <ski> http://www.informatik.uni-bonn.de/~ralf/hw2001/5.html
14:17:44 <lambdabot> Title: A Functional Notation for Functional Dependencies, http://tinyurl.com/y3ggqz
14:17:58 <ski> that's the one
14:18:03 <dmead> hey all
14:18:10 <dmead> i have a question =o
14:18:19 <dmead> i've got a data declaration
14:18:20 <skew> SamB_XP: I think you could write out (a = TyFun b c) if you wanted to constrain all of them
14:18:29 <dmead> and i want to be able to give it a num instance
14:18:38 <dmead> so i can do simple math with the constructors
14:18:47 <xerox> skew: "Illegal instance declaration for `AddNat (S m) n (S n_plus_m)'  (the Coverage Condition fails for one of the functional dependencies)"
14:19:13 <skew> and I think that falls under the stuff about tightening up functional dependencies a bit
14:19:39 <xerox> too much power?
14:19:39 <skew> that instance should be justfied by the functional dependencies on the precondition of the instance, but the typechecker doesn't notice
14:21:13 <skew> see http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#undecidable-instances
14:21:16 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
14:21:39 <skew> rather, http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#instance-rules
14:21:42 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
14:21:46 <ski> dmead : ok ?
14:22:14 <dmead> ah sorry got distracted
14:22:34 <dmead> ok, this is just some rough code i did
14:22:47 <dmead> http://taz.cs.wcupa.edu/~dmead/code/Bowling.hs
14:22:50 <lambdabot> http://tinyurl.com/yazfw4
14:22:55 <dmead> in instance Num  Frame where
14:22:55 <dmead>        = framescore x
14:22:55 <dmead>     
14:23:22 <dmead> what goes in the blank space so i can map a roll to a call to framescore
14:23:24 <ski> (xerox,(SamB_XP) : does the paper sound interesting ?)
14:23:29 <dmead> so you could do Spare + Strike
14:23:30 <dmead> etc
14:23:46 <skew> it seems like rule 2. could be "every type variable in S(tvs_right) is reachable from S(tvs_left)", where reachability includes follows fundeps from the context
14:24:02 <SamB> ski: the Stream Fusion one?
14:24:27 <ski> SamB : A Functional Notation for Functional Dependencies, link above
14:24:43 <SamB> oh, I didn't look
14:24:47 <SamB> I should be writing a lab report
14:24:52 <ski> dmead : yes .. you'd need to declare instances for 'Show' and 'Eq' first, though
14:25:12 * ski looks ar dmead's link
14:25:20 <dmead> skiL i've got it derrived
14:25:28 <dmead> ski: i've got it derrived
14:25:29 <ski> ok
14:26:03 <dmead> ski: seem that i should be able to do  x = framescore x
14:26:08 <dmead> in the Num instance
14:26:11 <ski> what should 'Spare + Strike' return, do you think ?
14:26:17 <dmead> 20
14:26:22 <ski> oh
14:26:41 <ski> you don't want to declare 'instance Num Frame' i think
14:26:45 <dmead> hmm
14:26:56 <dmead> overload the + operator maybe?
14:27:09 <ski> you want to have an inclusion from 'Frame' to some kind of number (e.g. 'Int')
14:27:30 <dmead> yes
14:27:47 <ski> '(+)' is already overloaded .. you can't do it again (without hiding the old binding)
14:27:53 <dmead> hmm..
14:28:27 <ski> probably it'd best to not try to do this kind of inclusion
14:28:46 <dmead> hmm ok
14:28:55 <dmead> i'll find a simpler way...
14:28:58 <ski> if you however insist, you could add an extra constructor to 'Frame' for holding an arbitrary 'Int' result
14:29:08 <dmead> yea Score Int does that
14:29:18 <dmead> but i'm in a debate with somone about the value of recursion
14:29:29 <dmead> and i wanted to make the code extremely clear
14:29:37 <ski> and then you could define '(+)','(-)', etc in the 'Num' instance to always yield a value of this constructor
14:29:49 <ski> (and you could make a custom 'Show' instance too, if you wanted)
14:30:13 <ski> well, you have 'Score Int Int' not 'Score Int'
14:30:19 <dmead> oh right
14:30:19 <dmead> yea
14:30:38 <ski> i'd suggest not doing an instance here, though
14:31:20 <dmead> yeaa i gues i'll make it messier and just use framescore(x) in the math
14:31:23 <ski> hm, you don't really need parens around the test condition of an 'if'-'then'-'else'
14:31:46 <dmead> lisp/c++ habit =)
14:31:59 <skew> dmead: I think laziness and take n is appropriate here
14:32:18 <ski> in 'scoreaux', probably you could use 'map' to avoid writing so many calls to 'framescore' ..
14:32:32 <dmead> hmm
14:34:23 <dmead> tmoertel: hey
14:35:17 <ski> (dmead : hrm .. or maybe using it in 'score' would be better)
14:35:45 <dmead> ski: i'm trying to avoid using counters
14:36:36 <dmead> ski: but yea, tmortel did a really nice version that did have a frame counter
14:36:37 * ski wonders what would require counters ..
14:37:05 <ski> btw, you can use "guards" instead if the 'if'-'then'-'else'es there ..
14:37:45 <ski> (dmead : do you know guards ?)
14:38:00 <glguy> ?hoogle inBounds
14:38:01 <lambdabot> No matches found
14:38:01 <dmead> ski: yes i just learned a few days ago, going to convert to them
14:38:12 <glguy> ?hoogle bounds
14:38:13 <lambdabot> Array.bounds :: Ix a => Array a b -> (a, a)
14:38:13 <lambdabot> Data.Array.bounds :: Ix i => Array i e -> (i, i)
14:38:13 <lambdabot> Data.Array.IArray.bounds :: (HasBounds a, Ix i) => a i e -> (i, i)
14:38:15 <ski> (it's a bit like 'cond' if that helps)
14:38:23 <dmead> aye
14:38:45 <dmead> yea i saw how to do cond in the haskell tutorial =)
14:38:49 <glguy> Is there a function that takes two Ix instances as a range, and determines if a third instance is within those bounds?
14:39:07 <glguy> other than: x `elem` (range . bounds) array
14:39:08 <glguy> ?
14:39:53 <ski> @type \x array -> x `elem` (range . bounds) array
14:39:55 <lambdabot> forall i e. (Ix i) => i -> Array i e -> Bool
14:40:02 <ski> @hoogle i -> Array i e -> Bool
14:40:03 <lambdabot> No matches, try a more general search
14:41:00 <Botty> glguy - wouldn't Ord be enough to do that?
14:41:54 <glguy> Botty: no, I don't believe so
14:42:19 <tmoertel> dmead: hi!
14:42:39 <dmead> tmoertel: hi =p
14:43:00 <dmead> tmoertel: i saw your code on ron jeffries site
14:43:43 <tmoertel> dmead: yeah, that was the tip of a long back-and-forth email iceberg.
14:44:11 <dmead> tmoertel: word, i've been debating the value of recursion with him for about 2 weeks now
14:44:27 <dmead> tmoertel: trying to get a really clear version done that he won't have cause to complain about =p
14:45:20 <tmoertel> I sent him the following code to demonstrate that the frame counter wasn't needed:
14:45:24 <tmoertel> score2 rs = fst . s.s.s.s.s.s.s.s.s.s $ (0, rs) where s = uncurry scoreFrame
14:45:41 <tmoertel> (scoreFrame scores a single frame and returns (score, remainingRolls))
14:46:10 <dmead> ha word
14:46:28 <tmoertel> dmead: he said, in response, that that version was clearer than the recursive one  ;-)
14:46:47 <dmead> tmoertel: lol
14:47:14 <dmead> tmoertel: i doubt his abilities personally... i showed his article to my advisor the first thing he asked me was if he's even a programmer
14:47:54 <tmoertel> dmead: remember that he teaches a lot of learning programmers.  as a result, I suspect he is more sensitive to things that beginners are likely to have trouble with.
14:48:09 <tmoertel> dmead: in other words, he simply has a different cost model than we do.
14:48:29 <tmoertel> dmead: I think recursion is a powerful, simple, elegant technique, but he thinks its easy to stumble over.
14:48:35 <tmoertel> s/its/it's/
14:48:43 <dmead> tmoertel: hmm, thats certainly being nice about it =)
14:48:57 <tmoertel> dmead: Maybe he's right, if he's talking to his average student.
14:50:46 <ski> it depends ..
14:51:19 <dmead> tmoertel: i even went as far to point out he likes to think iteratavely wheres this requires recursive thinking
14:51:19 <dmead> tmoertel: yea that is true
14:51:19 <tmoertel> dmead: But I argued that recursion was like a chef's knife: awkward and perhaps even dangerous for those who don't know how to use it, but one of the most valuable tools for those who know how to use it.
14:51:19 <dmead> tmoertel: indeed
14:51:19 <dmead> tmoertel: i'm going to finish up a version i'm doing with type constructors after diner
14:51:19 <dmead> so you can do score [spare,strike, score int int] etc
14:51:23 <ski> what do you prefer : a) a 'map' call b) an explicit recursion, that amounts to the same ?
14:51:33 <dmead> explicit recursion
14:51:41 <dmead> map is not always sufficient
14:51:46 <ski> of course not
14:51:54 <tmoertel> ski: map, when I want a map.
14:51:58 <ski> but in the case that a 'map' would've sufficed ?
14:52:19 <ski> (and similarly for 'foldr' and other higher-order functions that encapsulate particular patterns of recursion)
14:52:24 <ski> right
14:52:27 <dmead> hmm
14:52:29 <tmoertel> ski: In general, I prefer map, foldr, foldl', etc. when that's what I want.
14:52:30 <dmead> i need to learn folds...
14:53:09 <ski> a relevant url .. http://lambda-the-ultimate.org/node/1014
14:53:11 <lambdabot> Title: "The Anatomy of a Loop" | Lambda the Ultimate
14:53:56 <dmead> i'll take a look at that later
14:54:01 <dmead> time for foodin'
14:54:13 <ski> imo, recursion is wanted for generalness, but when the looping fits a standard pattern, it's usually better to not do explicit recursion
14:55:01 <tmoertel> ski: indeed.  map, foldr, etc.  *mean* something and communicate intent; they not only factor out recursion, accumulation, etc., but say something important about what you're trying to do.
14:55:27 <ski> right
14:55:57 <ski> (shivers also have some other interesting points in the paper linked at from that LtU post)
14:58:52 <glguy> > (range . bounds) (listArray ((0,0),(2,2)) [1..]))
14:58:53 <lambdabot>  Parse error
14:58:56 <glguy> > (range . bounds) (listArray ((0,0),(2,2)) [1..])
14:58:58 <lambdabot>  [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)]
14:59:44 * tmoertel must go walk his dog
14:59:48 <EvilRanter> wow. some of #perl are really vicious.
15:14:23 <glguy> ?docs Data.Array
15:14:24 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
15:40:22 <dons> ?users
15:40:22 <lambdabot> Maximum users seen in #haskell: 265, currently: 242 (91.3%), active: 33 (13.6%)
15:46:32 <joelr1> greetings!
15:46:45 <joelr1> is manuel t. around?
15:49:34 <dons> manuel t?
15:49:46 <joelr1> dons: well, yes
15:50:02 <joelr1> dons: unless i can ask you about automatic vectorization with dph :D
15:50:33 <dons> oh, you mean Manuel C :)
15:50:51 <dons> I suggest emailing Manuel and Roman. chak,rl <at> cse.unsw.edu.au
15:51:39 <dons> roman's actually standing in front of me right now, giving a talk about DPH
15:53:40 <joelr1> dons: oh, how cool
15:53:47 <joelr1> dons: where is that happening?
15:54:07 <joelr1> dons: yep, manuel t. c. :D
15:54:40 <dons> here at unsw, the http://www.comp.mq.edu.au/~asloane/iWeb/SAPLING-1.html
15:54:42 <lambdabot> Title: SAPLING-1, http://tinyurl.com/tkzb2
15:54:49 <dons> i'll see if i can get roman to put up his slides
15:54:58 <joelr1> dons: i think you posted a link to dph on LtU. i read through and it appeared they don't have automatic vectorization yet
15:55:13 <joelr1> dons: that would be groovy
15:55:40 <dons> if you use parallel arrays, you get transparently parallel operations
15:55:45 <dons> its experimental, though
15:56:22 <joelr1> dons: well, i'm used to having arrows in my back
15:57:02 <dons> :)
15:57:55 <joelr1> dons: round 2!
15:58:12 <dons> glad you're back for more punishment ;)
15:58:46 <joelr1> dons: i'm thinking about dph in the context of trading which is all about processing time series, aka arrays/vectors
15:58:55 <dcoutts> dons, will rl's slides be available ?
15:59:13 <joelr1> i like the elegance of array comprehensions
15:59:42 <joelr1> and with laziness i think it would be easy to model infinite time series
15:59:47 <joelr1> just a theory
16:00:11 <ski> infinite arrays ?
16:00:55 <dcoutts> dons, I've spent much of the day investigating how to prove stream . unstream = (id :: Stream a -> Stream a), it's harder than it looks. unstream . stream = (id :: [a] -> [a]) is easy by comparison.
16:01:33 <joelr1> ski: i'm probably speaking nonsense :D
16:01:42 <joelr1> talking that is
16:02:19 <joelr1> ski: but you basically have a time series that can be modeled either as a list or an array. i'm thinking of parallel arrays.
16:02:28 <ski> mhm
16:02:33 <ski> linear array ?
16:02:54 <skew> dcoutts: isn't that false, because it squeezes out the Skip steps?
16:02:55 <joelr1> ski: mhm? linear array? what do you mean?
16:03:11 <dons> dcoutts: yeah, i'll try to get him to put them up
16:03:18 <skew> dcoutts: how about unstream . stream . unstream == unstream?
16:03:31 <ski> "linear" meaning "single-dimensional", here
16:03:37 <dcoutts> skew, that's easy, but not as helpful
16:03:38 <dons> joelr1: you might like to get ghc 6.6 and just start playing around with the smp runtime
16:03:46 <dons> get a sense of where and how you can take the paralleism
16:03:49 <skew> dcoutts: that has the advantage of being true
16:03:50 <joelr1> dons: yep, i have that
16:04:08 <dcoutts> skew, well in a sense Skip doesn't matter
16:04:11 <joelr1> dons: plus, i'm on a core duo macbook pro
16:04:28 <SamB> dcoutts: ... why would it be equal in any way but intentionality?
16:04:31 <skew> dcoutts: have you defined what sense that is, because you'll need to to get an equality
16:04:43 <SamB> anyway.
16:04:45 <skew> or perhaps add a side condition that the stream doesn't have any skips to begin with
16:05:07 <SamB> just define (==) = (==) `on` unstream ;-)
16:05:18 <dcoutts> skew, the equivalence condition is probably just unfold
16:06:41 <dcoutts> SamB, do we have a proof from the semantics of (exists s. ...s...) about what observations are possible and so what is necessary to prove equality?
16:07:21 <dcoutts> what does it mean for a value to have an existential type, what are the proof rules for working with those things
16:08:16 * SamB has no idea...
16:08:31 <dcoutts> aye, the intuition is ok, but formally...
16:09:29 <SamB> yeah, well, I like (==) = (==) `on` unstream...
16:09:48 <SamB> as a formal statement of "I don't care!"
16:10:20 <emu> i've found that my lexer from parsec's makeTokenParser is taking up a very significant amount of time and space.  have people experimented with other options, maybe based on data.bytestring?
16:10:37 <SamB> emu: you should maybe try alex...
16:10:46 <SamB> which goes well with happy.
16:10:54 <emu> i already wrote a parser using parsec
16:10:58 <SamB> there is some library for packed strings...
16:11:03 <SamB> but it isn't too close to parsec
16:11:22 <emu> i really like parsec, don't really want to get into yacc-clones again
16:11:33 <SamB> well. its a lot less messy than in C!
16:11:43 <dcoutts> emu, you can use parsec with alex
16:11:50 <SamB> also true
16:11:59 <dcoutts> emu, alex is like lex, not yacc
16:12:00 <SamB> but you have to give up all those nice Char-only combinators...
16:12:25 <SamB> but Parsec doesn't seem to *like* doing that
16:12:25 <emu> i'm already using ParsecToken
16:12:31 <SamB> emu: too bad
16:12:38 <emu> surely I can just drop in another lexer?
16:12:45 <dcoutts> yeah, sure
16:12:54 <dcoutts> alex is fast, especially when lexing from bytestrings
16:13:15 <dcoutts> which reminds me, I should send in the patches to make alex to that easily
16:13:20 <emu> it doesnt come with ghc right?
16:13:32 <dcoutts> yep, it's separate
16:13:52 <emu> what's this Text.Read.Lex package?
16:15:24 <emu> hm i guess that's a haskell specific lexer
16:20:14 <dons> dcoutts: Chilli had an idea to write a usenix paper on implementing unix tools with fusible bytestrings
16:20:22 <dons> sound easy, and fun.
16:20:30 <dcoutts> heh, yeah fun
16:20:44 <dcoutts> I want a fusible sort
16:21:03 <emu> ah this seems like it'll work out..
16:22:47 <dcoutts> dons, for that it'd really help if we could fuse with hGetContents to guarantee a single reader so we can do one fewer buffer copy.
16:22:57 <dmead_away> bonk
16:26:09 <dons> dcoutts: yeah. we need to look at that
16:27:00 <dcoutts> dons, it'd be particularly funky if we could do it without importing Data.ByteString, but just by automagic stuff with putStr & hGetContents
16:27:38 <dcoutts> putStr = putStrS . stream
16:34:28 <Igloo> Grr, I wish Cabal had just picked Setup.lhs
16:35:38 <dcoutts> Igloo, rather than ?
16:35:46 <Igloo> Setup.hs or Setup.lhs
16:36:05 <dcoutts> it's not that hard :-)
16:36:45 <Igloo> OK, how do I add a dependency on whichever of those exists in this make rule then?
16:36:52 <Igloo> $(foreach SUBDIR,$(SUBDIRS),$(SUBDIR)/setup/Setup): %/setup/Setup: $(BOOTSTRAPPING_CABAL).stamp
16:37:38 <Igloo> make doesn't seem to glob if I just use %/Setup.*hs, and $(wildcard) doesn't expand the %
16:38:16 <dcoutts> mm, fair enough, it's tricky with make
16:38:45 <Igloo> Having both really does gain us nothing
16:39:06 <dcoutts> soon enough you won't need either
16:39:24 <dcoutts> which will make it harder again for make I suppose
16:39:42 * Igloo doesn't believe I won't need either soon
16:39:55 <dcoutts> "soon" :-)
16:40:09 <dcoutts> heh, yeah ok maybe soon is the wrong word
16:40:15 <dcoutts> we need more Cabal hackers
16:40:34 <dcoutts> I'd like to point out I'm a patch reviewer and release manager, not a Cabal hacker
16:41:07 * Igloo hides dcoutts's RM hat and gives him a shiny hacker hat
16:41:15 <dcoutts> SyntaxNinja has been rather busy lately
16:41:30 <dcoutts> Igloo, I've got too many hats
16:41:51 <Igloo> That operation preserved the number of hats
16:42:02 <dcoutts> heh, but one entails more work
16:54:19 <emu> @hoogle a -> [b] -> [b]
16:54:20 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
16:54:21 <lambdabot> List.insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
16:54:21 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
16:54:29 <emu> @hoogle [b] -> a -> [b]
16:54:30 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
16:54:30 <lambdabot> List.insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
16:54:30 <lambdabot> Prelude.scanl :: (a -> b -> a) -> a -> [b] -> [a]
16:54:34 <Excedrin> @paste
16:54:34 <lambdabot> http://paste.lisp.org/new/haskell
16:54:52 <Excedrin> http://paste.lisp.org/display/29655
16:55:25 <Excedrin> DrIFT reports, DrIFT can't find type [(["Haskell2Xml"],TypeName "Int")]
17:04:23 <Excedrin> does DrIFT need the .hs files? Also, it doesn't seem to use the DERIVEPATH
17:07:31 <arjanoosting> Igloo: I have a patch for haskell98-report which fixes it's FTFBS and some other bugs. Should I do a NMU or do you plan to do an upload?
17:08:41 <Igloo> arjanoosting: I'll be looking at it this weekend
17:09:01 <arjanoosting> Igloo: alright, I have just sent my work to the BTS
17:09:19 <Igloo> OK, thanks
17:12:36 <Botty> hmm, is ruby some odd cross between functional and procedural?  I learned ruby before but at the time I didn't know haskell
17:12:52 <EvilRanter> botty, it's basically procedural, AFAIK
17:13:00 <Botty> ok
17:13:06 <scodil> whats a fast way to round a float to an int? truncate and round are killing me. I don't know why its so slow
17:13:21 <EvilRanter> in that it's got global scope, dynamic scoping, etc
17:13:32 <EvilRanter> scodil, is floor any better? (I doubt it)
17:13:46 <Botty> sure. but it mixes in some functional idioms
17:14:12 <Igloo> dcoutts: Do you know if there's a UserHooks equivalent to defaultMain?
17:14:22 <scodil> EvilRanter: no floor is just as bad
17:14:53 <EvilRanter> scodil, then i think you're kinda stuck. those things should be optimised for efficiency
17:15:18 <EvilRanter> can you use rationals / a fixed-point thinger / unboxed types?
17:15:37 <scodil> sure they should. there's cpu instructions specifically for that
17:15:58 <scodil> I'm using mapArray over StorableArrays
17:16:23 <scodil> mapping from an array of floats to another array of floats is fast, but from an array of floats to one of ints is damn slow
17:17:10 <scodil> i can understand (maybe) floor, ceil and round, because there's math involved. but truncate?
17:18:28 <scodil> it must be going through the RealFloat methods
17:18:37 <scodil> floatRadix, decodeFloat and all that
17:20:57 <Botty> Well, RealFrac defines the floating stuff, and unless they're redefined in the base stuff, they should all have about the same speed
17:22:16 <Botty> *floating stuff -> rounding stuff
17:24:19 <EvilRanter> @help
17:24:20 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:25:05 <EvilRanter> @remember #perl <tech> who needs saneness
17:27:19 <dcoutts> Igloo, there isn't as far as I know.
17:31:05 <Igloo> OK, ta
17:38:29 <emu> ok, ParsecToken did twice as well as Alex :/ lesson learned
17:40:56 <SamB> eeek!
17:41:05 <SamB> Alex needs work!
17:41:16 <SamB> @where alex
17:41:17 <lambdabot> http://www.haskell.org/alex/
17:42:51 <araujo> hello!
17:42:58 <dcoutts> emu, I'm surprised. Is the code available ?
17:43:39 <emu> which part? the lexer?
17:46:16 <dcoutts> yes
17:46:40 <SamB> oh, btw, which options did you pass to alex?
17:46:44 <emu> none
17:47:16 <dcoutts> try alex -g
17:52:26 <emu> -g helps a bit, but still worse than Token
17:53:00 <SamB> can we get an Alex template for use with ByteString?
17:53:04 <SamB> how would it look?
17:53:25 <dcoutts> SamB, yeah, one's been written, it just need claning up and submitting
17:53:31 <SamB> does it fuse?
17:53:36 <dcoutts> no
17:53:46 <SamB> why not?
17:54:04 <dcoutts> it's not expressed as a stream consumer
17:54:23 <dcoutts> anyway, mostly you're lexing directly from a file so it doesn't buy you much
17:54:37 <SamB> point
17:55:29 <dcoutts> also, you're getting tokens from the ByteString, so it's helpful for it to really exist
17:55:46 <SamB> ?
17:56:07 <dcoutts> well your tokens are likely to contain substrings from the input
17:56:15 <dcoutts> eg identifiers in a prog lang
17:56:27 <SamB> oh, you can extract those directly?
17:56:31 <dcoutts> sure
17:56:40 <dcoutts> it's just a substring
17:56:57 <dcoutts> so there's no copying by default
17:57:09 <SamB> well, yes, but, I didn't know Alex was set up for that
17:57:22 <SamB> oh, huh, I see
17:57:29 <dcoutts> alex just gives you the input position and length
17:57:40 <SamB> yeah
17:57:55 <SamB> so I see, now that you mentioned it
17:57:57 <SamB> that is nice
17:58:05 <dcoutts> yeah, it worked out quite nicely
17:58:16 <SamB> I guess they must have done this by hand sometimes in the past?
17:58:21 <dcoutts> indeed
17:58:28 <dcoutts> ghc lexes from a buffer
17:58:48 <SamB> ah
17:58:53 <dcoutts> so if you use the basic-bytestring wrapper then you get a tokens function with type Lazy.ByteString -> [Token]
17:59:23 <dcoutts> we have wrappers for the equivelent of the basic, posn and monad
17:59:32 <SamB> nice ;-)
18:00:01 <dcoutts> so yeah, I should find some time to tidy it up, benchmark it and send it in
18:00:15 <SamB> but, you definately want to tidy them up in case people need to steal them ;-)
18:01:28 <dibblego> how do you teach a Java person (read: senior super spanker) the basics of computer programming without offending them?
18:01:58 <SamB> hmm. I don't know. Buy them a book where KISS stands for "Keep It Short and Simple"?
18:02:04 <dibblego> good idea
18:02:10 <dibblego> but that can be seen as an offence too
18:02:11 <araujo> dibblego, Teaching them Haskell?
18:02:14 * araujo giggles 
18:02:15 <SamB> (such as my C++ book)
18:02:17 <dibblego> better than my current approach anyway
18:02:18 <SamB> dibblego: I know!
18:02:28 <SamB> It offends *me*
18:02:37 <dibblego> what does?
18:02:41 <dibblego> that they are offended?
18:02:47 <SamB> the "Keep it Short and Simple"
18:02:55 <SamB> I like the uncensored version
18:03:06 <SamB> "Keep It Simple, Stupid!"
18:03:34 <SamB> because all programmers are idiots
18:03:40 <SamB> especially those who think otherwise
18:03:52 <dibblego> Keep Idiots Safely Secure
18:04:04 <dibblego> Securely Safe
18:04:19 <SamB> Sleeping Soundly
18:04:21 <dibblego> my sentiments exactly
18:04:28 <dibblego> we are all idiots!
18:06:11 <SamB> actually, don't you *want* him to be offended?
18:07:48 <SamB> Haskell is a good way to learn the basics.
18:08:08 <SamB> all the way to the state of the art in optimization.
18:08:25 <SamB> not that the *compilers* are necessarily that good...
18:09:44 <SamB> we like getting rid of intermediate data structures
18:09:54 <Cale> One of the nice things about lazy evaluation is that it forces you to realise that evaluation order is a choice :)
18:10:43 <SamB> but without making your source code a twisted mess
18:10:54 <SamB> (only your object code)
18:12:01 <Excedrin> DrIFT is odd; I'm not sure why it works for types from the Prelude, but not for stuff that I'm importing from the hierarchial libraries
18:12:44 <SamB> probably because it doesn't have the source for those?
18:13:11 <SamB> it cannot read the interface files
18:13:24 <SamB> nor can it go online and read the documentation
18:13:36 <emu> curiosity: Parsec doesn't seem to be "lazy", since if I ask for the first part of a parsed structure, it still seems to parse the whole file.. or am i using it wrong?
18:13:48 <SamB> no, you are absolutely correct
18:13:49 <SamB> see...
18:14:06 <Excedrin> I'm using it with Hugs
18:14:07 <SamB> @type Text.ParserCombinators.Parsec.parse
18:14:09 <lambdabot> forall a tok. Text.ParserCombinators.Parsec.Prim.GenParser tok () a -> Text.ParserCombinators.Parsec.Pos.SourceName -> [tok] -> Either Text.ParserCombinators.Parsec.Error.ParseError a
18:14:20 <SamB> Excedrin: in that case, maybe you could just tell it where to look
18:14:20 <Excedrin> strace shows it opening the correct files, but it still can't find the type
18:14:26 <SamB> oh!
18:14:28 <SamB> eek.
18:14:40 <SamB> emu: notice the "Either" there?
18:14:44 <emu> yes
18:15:04 <emu> i see. it has to know whether it'll return an error or not.
18:15:05 <Cale> It can't possibly know whether an error occurs right at the end of the file.
18:15:12 <SamB> quite
18:15:18 <Excedrin> SamB: how? is there a command line option for that?
18:15:50 <emu> conceivably a parser could go as far as it could and then find a way to signal failure, maybe even have options for continuing?
18:16:02 <dcoutts> it is possible to have lazy parsers
18:16:07 <dcoutts> that are 'optimistic'
18:16:23 <dcoutts> they embed errors in the structure if they are encountered later
18:16:23 <emu> just speculating anyhow, it makes sense now
18:16:29 <SamB> that is true
18:16:38 <SamB> I think HXT does that
18:18:44 <SamB> emu: for a while I was trying to see how that was possible
18:18:49 <SamB> eventually I decided it wasn't
18:19:13 <SamB> but then I decided maybe it was, if you would embed further processing in a Monad or Arrow or something...
18:19:19 <emu> yea
18:20:24 <ski> @hoogle many0
18:20:26 <lambdabot> No matches found
18:20:47 <ski> @hoogle many
18:20:47 <lambdabot> Text.ParserCombinators.ReadP.many :: ReadP a -> ReadP [a]
18:20:48 <lambdabot> Text.ParserCombinators.Parsec.Prim.many :: GenParser tok st a -> GenParser tok st [a]
18:20:48 <lambdabot> Text.ParserCombinators.ReadP.many1 :: ReadP a -> ReadP [a]
18:21:00 <emu> Parsec/Token seems pretty simple
18:21:02 <ski> @hoogle+
18:21:02 <lambdabot> Text.ParserCombinators.ReadP.manyTill :: ReadP a -> ReadP end -> ReadP [a]
18:21:03 <lambdabot> Text.ParserCombinators.Parsec.Combinator.many1 :: GenParser tok st a -> GenParser tok st [a]
18:21:03 <lambdabot> Text.ParserCombinators.Parsec.Combinator.manyTill :: GenParser tok st a -> GenParser tok st end -> GenParser tok st [a]
18:21:36 <ski> @hoogle+
18:21:36 <lambdabot> Foreign.Marshal.Utils.withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
18:21:37 <lambdabot> Text.ParserCombinators.ReadP.skipMany :: ReadP a -> ReadP ()
18:21:37 <lambdabot> Text.ParserCombinators.Parsec.Prim.skipMany :: GenParser tok st a -> GenParser tok st ()
18:22:07 <ski> hm, 'skipMany' always succeeds, yes ?
18:22:55 <emu> yea
18:23:26 <dcoutts> emu, very interesting. Yeah the alex one is half the speed.
18:24:50 <SamB> dcoutts: what sort of tokens are they?
18:25:08 <dcoutts> SamB, what do you mean exactly ?
18:25:24 <SamB> well, I mean, is there anything odd about the regular expressions?
18:25:41 <emu> i may have sucked at creating them, but, its not too extensive
18:27:01 <emu> mostly copied from the examples: whitespace, ; comments, \( and \), \-? $digit+ for ints, \-? $digit+ \. $digit+ for floats, $alpha [$alpha $digit \_ \-]* for identifiers, and quoted strings done simply with \" [^\"]* \"
18:28:16 <SamB> maybe your regexes don't overlap as much as alex is used to ;-)
18:28:50 <scodil> is there a function f such that f [1,2,3] [10,20,30] = [1,10,2,20,3,30] ?
18:29:27 <emu> @hoogle [a] -> [a] -> [a]
18:29:28 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
18:29:29 <lambdabot> List.intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
18:29:29 <lambdabot> List.unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
18:29:48 <emu> @hoogle+
18:29:48 <lambdabot> Data.List.deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
18:29:49 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
18:29:49 <lambdabot> List.(\\) :: Eq a => [a] -> [a] -> [a]
18:32:44 <emu> > concat [ [a,b] | (a,b) <- zip [1,2,3] [10,20,30] ]
18:32:45 <lambdabot>  [1,10,2,20,3,30]
18:33:33 <emu> ah well
18:33:34 <emu> brb
18:34:04 <jdev> > (foldr1 (.) $ zipWith (.) (map (:) [1,2,3]) (map (:) [10,20,30])) []
18:34:06 <lambdabot>  [1,10,2,20,3,30]
18:38:54 <SamB> eek
18:39:23 <SamB> how do I get advi to display my \[ \left| ... \right| \] correctly?
18:39:31 <SamB> it is showing gaps in the big bars :-(
18:53:21 <kelan> anyone using debian? i just upgraded from ghc 6.4 to 6.6 and now i'm missing libraries. such as Control.Monad.State
18:53:24 <kelan> any ideas?
18:53:58 <SamB> apt-cache search ghc6.6
18:53:59 <sjanssen> kelan: GHC 6.6 doesn't ship with as many libraries
18:54:07 <SamB> maybe that well will tell you something?
18:54:12 <SamB> er.
18:54:14 <SamB> s/well //
18:54:22 <sjanssen> there is probably a package called "extralibs"
18:54:49 <sjanssen> or the libraries are packaged separately, "mtl" is the package that has Control.Monad.State
18:57:24 <kelan> ah, ok, i saw the mtl package, but it specifically describes it as the monad transformer library. i guess i thought it would only provide the transformer versions of the monads
18:57:28 <kelan> thanks for the help
18:57:47 <SamB> kelan: it *should* say "monad template library"
18:58:19 <kelan> maybe i should send a note to the maintainer to fix the description
18:58:41 <SamB> Igloo: You messed up the description for libghc6-mtl-dev!
18:58:56 <kelan> heh
18:59:03 <kelan> ok, thanks again for the help:)
18:59:35 <Igloo> SamB: Your "Fix lhs delimiters" patch doesn't apply (missing "Unlifted args are only interesting when we know what they are"); do you want to resend, or would you rather I recreated it myself?
19:00:33 <SamB> oh, okay, I'll try resending...
19:00:49 <Igloo> SamB: I took the description straight from the .cabal file
19:01:07 <SamB> oh really?
19:01:20 <Igloo> Yes, really.
19:01:49 <SamB> I thought the T was for Template!
19:02:44 <SamB> Transformer really only covers half the monads in that library, you know...
19:03:52 <Igloo> SamB: Is "Implement builtin "RULES" for bit-shifts" one of the patches-for-comments, or do you think it is committable?
19:04:26 <SamB> It shouldn't damage anything, but that doesn't mean it won't.
19:04:45 <SamB> (I mean, performance-wise)
19:04:55 <SamB> I think it can be committed
19:05:28 <lispy> hey
19:05:33 <lispy> it's #haskell time!
19:06:46 <SamB> Igloo: did it get through?
19:07:38 * SamB wonders why TeX doesn't use rules for the vertical bar "characters"?
19:08:04 <lispy> SamB: what do you mean?
19:08:10 <merus> SamB: Don't they have a control sequence for that?  \vert
19:08:25 <lispy> \verb|blah| ?
19:08:39 <SamB> well, it seems to be using four vertical bar glyphs :-(
19:08:49 <merus> \left\vert blah blah blah \right\vert
19:08:59 <SamB> \verb|blah| is a way to write "verbatim" text...
19:09:06 <SamB> not a way to get a vertical bar.
19:09:09 <Igloo> SamB: Yup, pushed; thanks!
19:09:17 <SamB> Igloo: you are welcome!
19:09:24 <SamB> sorry I messed it up the first time
19:09:43 <Igloo> np
19:10:31 <lispy> SamB: yeah, i didn't know hat you meant
19:15:14 <lispy> i really hope the fixity discussions don't go anywheer
19:15:23 <lispy> i think the current system is aready pretty complex
19:15:34 <lispy> and i use lots of explicit parens just so i don't have to think about it
19:17:57 * Botty as well.  back when I was more noober I would get lots of precedence errors, now I just pepper parens
19:18:19 <lispy> i half want to comment on it, but the thread is so long now and i don't even know how many threads there are becase they keep changing the topic...
19:18:58 <sjanssen> lispy: it isn't going in
19:19:05 * lispy cheers!
19:19:21 <sjanssen> not that I have any authority
19:19:32 <sjanssen> but it's pretty clear that it isn't appropriate for haskell-prime
19:19:59 <sjanssen> and the people that have shown real interest aren't on the committee, as far as I can tell
19:20:43 <Igloo> "lispy" advocates parentheses; film at 11!
19:20:56 <lispy> heh
19:21:01 <Igloo> (not that I don't agree)
19:21:23 <lispy> (used, (appropriately), they (can be) nice)
19:21:43 <sjanssen> it's kinda crazy to advocate that the compiler needs to resolve a precedence graph just to parse things
19:22:10 <lispy> i wonder what fixity we could give to vertical tab
19:22:30 <sjanssen> and that imports could change your program from one that properly parses to a precedence error
19:22:52 <lispy> oh wow, i hadn't realized that
19:23:24 <lispy> although, this does remind me, i wish you could reinstance things
19:23:32 <sjanssen> lispy: yeah, if precedences export like instances do (silently and transitively)
19:24:06 <lispy> i mean, you can if you use newtype deriving, but i wish you could do it without the newtyping
19:24:10 <sjanssen> if module Foo declares a precedence relation, and you remove an "import Foo ()" from your program, stuff will break
19:24:49 <lispy> that's crazy because "import Foo ()" doesn't actually import anything
19:24:56 <lispy> "anything"
19:28:31 <dolio> Would it be too difficult to only be able to declare precedences of operators defined within a given module?
19:30:09 <dolio> I mean, if you have Bar.=== and Foo.===, with different precedences, and import them both, you probably want each to have the precedence given in its respective module.
19:30:16 <dolio> Although I suppose that's already nasty.
19:31:34 <sjanssen> dolio: that's already how it works
19:32:00 <sjanssen> if Bar.=== and Foo.=== are distinct, not just re-exported from some other module
21:35:49 * monochrom <3 existential types
21:37:35 <monochrom> err everyone drunk?
21:57:11 * monochrom ROTFL on the "don't" thread in haskell-cafe
22:01:33 <emu> nope, not drunk
22:01:52 <emu> i need to stay awake long enough to make it onto the plane in 5 hours
22:02:25 <monochrom> ouch that's bad
22:03:01 <psykotic> long trip?
22:03:13 <emu> na, short one
22:03:27 <emu> just gotta hop on plane, hop off
22:03:36 <psykotic> worst plane trip ever: 14 hour trip from seoul to paris, while nursing an insane hangover... on no sleep.
22:03:45 <emu> yea i'd hate to do that
22:03:52 <emu> one time i got in a plane while i had a cold though, that was baad
22:06:06 <emu> so, tell me, any haskell vim'ers?
22:08:20 <Smokey``> I think I'm gonna go nuts, I can't figure out how to force the evaluation of a statement, before it's actually used -_-
22:08:40 <dolio> Example?
22:09:35 <Smokey``> http://rafb.net/paste/results/QG0Fxq76.html <-- part of a do statement... but pixels isn't being evaluated untill it's actually needed... (later on in the do statement)
22:10:31 <dolio> Pixels is like a [[a]] or something?
22:10:40 <Smokey``> [a]
22:11:01 <dolio> And you want all the content forced, too, I assume?
22:11:06 <dolio> You'll need a deepSeq for that.
22:11:20 <Smokey``> deepSeq... okey dokey i'll look that up :) ty dolio
22:11:41 <Willy0nWheels> The US government is run by a demon/alien hybrid called the Aggemoth.
22:12:17 <sjanssen> oh yeah, I think I read that in Time Magazine
22:12:38 <Willy0nWheels> TIME MAGEZINE WANTS TO INSTALL PARASITIC NANOCHIPS IN EVERYONES BRAINS!!1!!
22:12:43 <psykotic> Willy0nWheels, is he Cthulhu's brother?
22:12:52 <psykotic> oh wait, no, that's Hastur.
22:12:56 <emu> that's RFID
22:13:10 <dolio> Does Time have that kind of power?
22:13:20 <emu> they are "MAGE"s
22:13:38 <sjanssen> dolio: "wants to"
22:13:44 <sjanssen> or should I say, "WANTS TO"
22:13:50 <dolio> :)
22:13:52 <Willy0nWheels> Ph'nglui mglw'nafh Cthulhu R'lyeh wgah'nagl fhta
22:14:27 <Willy0nWheels> whoze mages?
22:14:36 <Willy0nWheels> I WANT TO KNOW WHOZE MAGES!!!!
22:15:22 <sjanssen> so, Willy0nWheels, what brings you to #haskell?
22:15:28 <Willy0nWheels> YOUR MOM
22:16:00 <EvilRanter> see, now, what that makes me think, is an esoteric language based on the language of the Old Ones...
22:16:12 <sjanssen> my mom knows nothing about Haskell.  In fact, she'd probably wash my mouth out with soap if I said "monads" to her
22:16:30 <Willy0nWheels> MONADS EAT YUOR SOUL!!!! WASH YOUR MOUTH OUT
22:16:31 <emu> I believe he tried to comprehend ST
22:16:49 <Willy0nWheels> ST SUCKS!!!! BURN IT
22:17:59 <psykotic> EvilRanter, of course, "ia! shub-niggurath" should be call/cc
22:18:36 <EvilRanter> umlauts and apostrophes would change the behaviour of keywords...
22:18:46 <dolio> Sounds like a good addition for R7RS.
22:18:59 <Willy0nWheels> look! air
22:19:57 <monochrom> Am I in the wrong channel?
22:20:08 <emu> it's late..
22:20:42 <Willy0nWheels> OH NO YUOR IN THE RIGHT PLACE
22:20:43 <EvilRanter> no, it's early
22:20:54 <EvilRanter> 06:20, here
22:21:08 <EvilRanter> (yes, I've been connected / semi-active all night. who needs sleep?
22:21:09 <emu> are you in Britain/France
22:21:46 <EvilRanter> /who says... yes.
22:22:00 <Willy0nWheels> YOU NEED MOAR VESPENE GAS!!!!
22:23:45 <EvilRanter> KIROV REPORTING!!!111onehundredandeleven
22:33:55 <dmead> bong bong bong bonggggg
22:34:06 <dmead> how about, i give you the finger
22:34:13 <dmead> you can't scare me with this gestapo crap!
22:45:02 <dons> oh, JavaUser.
22:45:08 <dons> we better re-ban him :/
22:45:13 --- mode: ChanServ set +o dons
22:47:35 <Smokey``> Yup, I think I'll go nuts right about now...
22:47:55 --- mode: dons set +b *!i=JavaUser@*.qwest.net
22:48:06 <dons> n.b. 06.07.01:12:56:59 --- mode: Igloo set +b *!i=JavaUser@*.dclient.hispeed.ch
22:48:14 <Smokey``> let buffer = rnf () `seq` (renderScene resolution (RRT 8 8) camera scene) -- should evaluate renderScene immediately, yes?
22:48:14 --- mode: ChanServ set -o dons
22:48:25 <dons> hmm. not nec.
22:48:36 <dons> let buffer = ... in buffer `seq` ...
22:48:42 <dons> you want to force buffer
22:48:45 <Smokey``> okay...
22:49:07 <dons> whereas you have something that will force (rnf ()) when buffer is demanded
22:49:25 <Smokey``> oh, right...
22:50:07 <dons> hey tmorris
22:50:13 <tmorris> hey mate
22:50:15 <EvilRanter> maybeIf b x = if b then Just x else Nothing :: Bool -> a -> Maybe a
22:50:21 <dons> back home?
22:50:22 <EvilRanter> is there such a builtin?
22:50:30 <dibblego> yeah just got back from squash training
22:50:35 <dons> ?type isJust
22:50:37 <lambdabot> forall a. Maybe a -> Bool
22:50:43 <EvilRanter> other way
22:50:44 <dons> EvilRanter: not builtin
22:50:57 <dons> ?pl \b x -> if b then Just x else Nothing
22:50:58 <lambdabot> flip flip Nothing . (. Just) . if'
22:51:16 <EvilRanter> (when i say "builtin", i mean "standard library or whatever")
22:51:20 <EvilRanter> @type if'
22:51:21 <lambdabot> Not in scope: `if''
22:51:35 <ski> @type \b x -> guard b >> Just x
22:51:37 <lambdabot> forall a. Bool -> a -> Maybe a
22:51:52 <dolio> Maybe something like... "let buffer = ... ; evaluate (rnf buffer) ; ..." ?
22:52:23 <dons> ski++
22:52:25 <Smokey``> I think, I'm just too inexperienced with Haskell, to even attempt anything this simple -_-
22:52:39 <EvilRanter> > mzero :: Maybe Int
22:52:40 <lambdabot>  Nothing
22:52:42 <dons> ?pl \b x -> guard b >> Just x
22:52:43 <lambdabot> (. Just) . (>>) . guard
22:54:02 <dolio> Don't feel too bad. Forcing evaluation order is tricky business.
22:54:39 <dons> for those interested, http://www.cse.unsw.edu.au/~dons/tmp/irc-ban-history
22:54:41 <lambdabot> http://tinyurl.com/ylyv7j
22:54:55 <ski> dons : huh ?
22:55:15 <emu> dons: you use vim, right?
22:55:19 <dons> the complete list of every time we've banned someone, in this channel :)
22:55:24 <dons> emu, yeah
22:55:27 <Smokey``> dolio: heh, it shouldn't be... I'm soo lost right now -_-
22:55:34 <Korollary> palomer was banned?
22:55:50 <EvilRanter> he started swearing at people, IIRC
22:55:54 <dons> Korollary: yeah :(
22:56:01 <Korollary> crap
22:56:15 <Korollary> 11/7. I should read the logs
22:56:26 <dons> and actively sending us OT -- it was his stated goal. oh well.
22:56:55 <dons> we really really tried to reform him
22:57:07 <dons> starting months ago with the @palomer plugin
22:57:18 <dons> *sigh*
22:58:12 <Korollary> ok it wasnt on 11/7
22:58:28 <Korollary> oh well
22:59:10 <Korollary> why cant you nerds just get drunk and punch each other like normal people?
22:59:43 <EvilRanter> people? I'm a neural network...
23:00:44 <Korollary> why would a neural network 'rant' ?
23:01:03 <dolio> Because it's trained to?
23:01:18 <Korollary> they must have used blogs as data
23:02:08 <EvilRanter> Korollary, are you an obvious deduction from a theorem, and do you run on KDE?
23:02:36 <dibblego> there is a compiler that compiles to .NET isn't there?
23:02:45 <EvilRanter> Also, this is an anagram of "Irrelevant", which is my normal online psyudnonym, but was taken.
23:02:53 * Korollary is powered by Gatorade
23:03:03 <dibblego> ever drunk a purple gatorade?
23:03:15 <dibblego> I'm glad I googled it before going to see the doctor
23:03:17 <Korollary> against my principles
23:03:29 <dibblego> lol first hit
23:03:39 <EvilRanter> I rely on a mixture of espesso, coca-cola, and the occasional tea
23:03:44 <dibblego> "Green stool"
23:04:18 <EvilRanter> is that like red hat?
23:04:18 <dons> ?remember dibblego I'm glad I googled it before going to see the doctor
23:04:54 <dibblego> it's funny that the title of the first hit of googling for purple gatorade is "green stool
23:04:59 <EvilRanter> damnit, I haven't got any tea ATM. i'm craving it now.
23:05:39 <EvilRanter> anyone /dcc?
23:06:35 <sjanssen> I wonder how hard it'd be to implement overloaded string literals in GHC
23:07:08 <dons> sounds fun/obfuscating
23:07:25 <dons> and you thought No instance of Num (a -> a) was a confusing error...
23:07:27 <dons> > 1 2
23:07:29 <lambdabot>  add an instance declaration for (Num (t -> a))
23:07:29 <lambdabot>   In the definition of `ao...
23:07:38 <dons> now strings will do this too..
23:07:50 <sjanssen> ah, that is true
23:07:53 <dons> why don't we have numeric literals of function type?!
23:08:05 <dons> we should! think of the obfuscatory power
23:08:08 <EvilRanter> wouldn't creating a function called "S" that does the processing be "good enough" in most cases?
23:08:15 <dolio> It's been suggested at least twice by my count.
23:08:18 <EvilRanter> (well, "s")
23:08:24 <sjanssen> dons: do you think overloaded strings is a bad idea then?
23:08:49 <dons> hmm. not sure yet. i can see good things both ways
23:08:54 <EvilRanter> would these numeric literals be the church integers or sth?
23:08:58 <dons> but i don't think its a killer feature. maybe it is?
23:09:16 <dons> it'd make bytestrings easier
23:11:19 <emu> dons: is there any kind of vim interaction with ghci mode?
23:12:03 <dons> there was a post recently, i think
23:12:06 <dons> but i've not used it
23:12:18 <dons> see on haskell.org, under the 'program development/vim' page
23:12:24 <dolio> EvilRanter: The proposals I remember seeing wanted to do something like "1 + sin^2"
23:12:26 <emu> yea i downloaded your vimrc
23:12:46 <dolio> Which is shorthand for "\x -> 1 + sin (sin x)"
23:12:55 <EvilRanter> I see
23:13:14 <EvilRanter> wouldn't that make type deduction very difficult?
23:13:47 <sjanssen> maybe we should just have "instance (Monad m, Num a) => Num (m a) where ..."
23:13:54 <dolio> I think they said that it's not hard to set things up so that you get the intuitively "correct" result from such things.
23:14:00 <sjanssen> where all the operators are just liftM'ed
23:14:55 <dons> i.e. 1 1 could actually be sensible.. hmmm ... iohcc-07?
23:16:36 <sjanssen> readLn + readLn >>= print
23:16:53 <dons> mm. nice.
23:17:21 * monochrom <3 existential types and closures
23:18:09 <sjanssen> and the (->) a monad would provide the function instance
23:18:57 <monochrom> I ask an OOP question but it's for Haskell's sake, trust me.  If an OO program is written properly, does it ever need downcast?
23:18:59 <emu> is anyone using ghc on OS X 10.3?
23:19:33 <emu> downcasting is more related to the lack of proper parametric polymorphism than OO
23:20:00 <dolio> Java used to require extensive downcasting.
23:20:16 <dolio> Because vectors stored only objects.
23:20:32 <sjanssen> I'm far from a Java expert, but I find downcasting necessary on occasion
23:20:43 <dons> yeah, so lack of parametric polymorphism, perhaps?
23:20:49 <dons> i'm sure there's papers on it.
23:21:03 <dolio> Avoiding that would require making a separate list class for every value you want to hold.
23:21:09 <emu> wadler probably has a papero n it
23:21:29 <dolio> Or, every type, that is.
23:22:05 * monochrom secretly admires Wadler
23:23:25 <Korollary> monochrom: Casting presupposes static types, no? Then it's not strictly an OO question.
23:23:52 <monochrom> Darn.  Yes, I presuppose static types.
23:24:45 <emu> heh, and, i'd barely consider static type systems to be OO :/
23:26:00 <monochrom> With static but existential types, it may be legit OO again.
23:27:35 <monochrom> Haha he has a talk "the unreasonable effectiveness of logic"
23:32:35 <Botty> Is there a fast way to sortBy the order of constructors for a type?
23:32:55 <Botty> Well, more like an elegant way...
23:33:12 <Korollary> you mean deriving Ord?
23:33:52 <monochrom> deriving (Eq,Ord)
23:34:04 <monochrom> Then just use "sort" :)
23:34:20 <Botty> doh!!!
23:34:40 <Botty> I figured deriving Ord would actually look at the data, or something
23:35:11 <monochrom> Yes, it looks at the data.  It also looks at the constructors.
23:35:27 <monochrom> data X = B Int | A Char
23:35:33 <monochrom> deriving (Eq,Ord)
23:35:47 <Botty> 0hh
23:35:57 <monochrom> Now, B 10 < A '5'   this just looks at the constructors.
23:36:10 <monochrom> B 10 < B 20   this has to look at the data of course.
23:37:19 <Botty> alright, cool.  Toobad I want to sort the numeric bit in reverse order, but I can manage that nicely with my own function as a parameter for sortBy, and defaulting my function to compare :)
23:41:25 <dolio> Hmm, we need to get rid of (Eq n, Show n) => Num n before making Num (m n).
