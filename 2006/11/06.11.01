00:00:00 <glguy_> nvm
00:00:02 <glguy_> figured it out :)
00:00:07 <desrt> concatMap :)
00:00:35 * Smokey` hugs desrt
00:00:41 * desrt smiles
00:00:45 <glguy_> > [ (1,2,3) , (3,4,5) , (4,5,5) ] >>= (\(a,b,c) -> [a,b,c])
00:00:46 <lambdabot>  [1,2,3,3,4,5,4,5,5]
00:00:47 <Smokey`> concatMap is my new hero ;)
00:00:55 <Ulfalizer> f=sequence::[[a]]->[[a]]  works as well, but it's 2 characters longer :/
00:01:55 <dolio> How about f = sequence, and then compile with -fno-monomorphism-restriction. :)
00:02:10 <Ulfalizer> i think that's cheating :P
00:02:30 <glguy_> that's a loser's attitude!
00:02:40 <dolio> Maybe, but the monomorphism restriction is lame in the first place. :)
00:02:50 <desrt> uh oh.  here we go.
00:02:58 <Ulfalizer> i've already won. his lisp implementation is like 6 lines :P
00:03:04 <dolio> Heh.
00:03:49 <glguy_> ?type runIdentity
00:03:50 <lambdabot> Not in scope: `runIdentity'
00:03:59 <glguy_> )-:
00:04:01 <desrt> > id
00:04:01 <lambdabot>  Add a type signature
00:04:07 <desrt> why is lambdabot so useless?
00:04:18 <desrt> it should strive to be like ML
00:04:20 <glguy_> because you touch yourself at night
00:04:40 <glguy_> speaking of begging the question...
00:05:08 <glguy_> I'm tired of people calling into NPR and saying that something "begs the question..." when it clearly does not
00:05:24 <desrt> "STRAW MAN ARGUMENT!!"
00:05:38 <desrt> (to name another oft-misused fallacy name)
00:05:48 <glguy_> red herring is a favorite
00:05:53 <desrt> oh yes.
00:06:03 <dolio> Yeah, when did people start saying "begs the question"?
00:06:08 <hellish> glguy_: Call in and complain!
00:06:16 <desrt> about a week ago i actually heard someone say "false diechtomy"
00:06:30 <glguy_> desrt: correctly?
00:06:36 <desrt> no
00:06:41 <desrt> they said die-echt-omy
00:06:45 <glguy_> dolio: correctly say it? or commonly misuse it?
00:06:51 <dolio> Is that where you remove the dead from someone?
00:06:57 * desrt shrugs
00:07:01 <dolio> glguy_: Misusing it.
00:07:13 <desrt> i think it's someone trying to pronounce "dichotomy" without knowing what they mean
00:07:24 <glguy_> Probably since people have wanted to appear to be smarter than they are...
00:07:27 <glguy_> so... forever
00:07:32 <desrt> actually
00:07:35 <desrt> he used it in a legit way
00:08:05 <desrt> i guess it's better to misprounce but have the right idea than it is to be able to speak but not to think :)
00:08:16 <glguy_> I think that it's funny that the incorrect usage of "begging the question" is becoming acceptable
00:08:23 <glguy_> because so many people don't know what it means anymore
00:08:30 <desrt> oh oh!  sour grapes!
00:08:50 <desrt> how people think it means people being annoyed by the success of others
00:09:15 <desrt> when really it means taking your own failures in stride
00:09:15 <glguy_> I tend to avoid using that expression, as I don't fully understand it's correct usage myself
00:09:26 <desrt> it's from the following story:
00:09:32 * glguy_ attempts to file that one away for use later
00:09:37 <hellish> I've only ever heard it used correctly on LtU...
00:09:46 <desrt> a fox is walking along one day and he sees some grapes on the edge of a cliff
00:09:55 <desrt> he tries to jump up to grab the grapes
00:09:58 <desrt> and tries and tries and tries
00:10:00 <desrt> but they are too high
00:10:14 <desrt> so he says "well.. now that i've gotten a closer look, i see that those grapes are very sour looking anyway"
00:10:20 <desrt> and walks away without having lost pride
00:10:23 <glguy_> When someone gives you sour grapes... make sour grape drink...
00:10:58 <glguy_> desrt: I'll definitely remember that story
00:11:06 <desrt> it's a good one :)
00:12:20 <dolio> I'd always thought that the idea of the story was that the fox thought they were sour because he couldn't reach them , although I can't recall where I got that interpretation.
00:12:55 <Smokey`> my first file IO function written in Haskell :D I'm soo proud *tear* ;)  (nothing pretty, but ... it should do the job...)
00:13:02 <dolio> So when people say "sour grapes", it's because someone's denigrating the achievments of others because they know they couldn't achieve similar things.
00:13:17 <desrt> dolio; it really has very little to do with others
00:13:32 <desrt> it's how you handle your own failure to acheive
00:13:41 <desrt> regardless of the acheivement of those around you
00:13:47 <dolio> Yeah, I know. I don't know how I came up with that now. :)
00:13:52 <desrt> it's specifically *not* bitterness/resentment towards the successes of others
00:14:07 <desrt> (which is a very common misuse)
00:14:12 <dolio> Maybe I just read that into the story becaus that's how people always use it.
00:17:24 <dolio> Wikipedia seems to disagree with you, by the way.
00:17:30 <dolio> "The phrase sour grapes refers to the false denial of one's desire for something that one fails to acquire."
00:17:45 <desrt> uhm.. that's exactly what i said
00:18:01 <desrt> the fox doesn't _honestly_ believe the grapes to be sour
00:18:09 <desrt> he's just telling himself that to make him feel better
00:18:17 <glguy_> another one that I hate is when someone calls something a "Catch-22"
00:18:19 <Bobstopper> I had a "type Foo a = StateT FooState IO a" declaration. But I wanted it to work within another state transformer like "StateT s Foo a". I got errors to do with not applying Foo to enough arguments. So I've tried turning my Foo into a newtype but now I don't know how to get it to act like a state monad (preferably instancing MonadState). Can anyone help?
00:18:45 <glguy_> Catch-22 is a specific /catch/
00:19:20 <desrt> isn't a catch 22 when you could have A if only you could have B and you could have B if only you could have A but you have no way to get either?
00:19:23 <lispy> glguy_: touche!
00:19:31 <dolio> Couldn't that lead to the situation where someone belittles the achievments of others merely because they couldn't achieve it themselves?
00:19:32 <lispy> that's another missused one :)
00:19:35 <desrt> damn!
00:19:50 <desrt> dolio; sure.  but that's something different, then
00:20:14 <glguy_> lispy: there is a Mac commercial about that
00:20:18 <desrt> oh.  i was right.
00:20:26 <desrt> Catch-22 is a term, coined by Joseph Heller's novel Catch-22, describing a general situation in which an individual has to accomplish two actions which are mutually dependent on the other action being completed first.
00:20:43 <glguy_> no, Catch-22 is a title of a book
00:20:45 <glguy_> about a specific catch
00:20:59 <glguy_> relating a regulation #22
00:21:19 <desrt> i mean, though, the expression "catch 22"
00:21:28 <dolio> Isn't a catch more general though?
00:21:33 <desrt> (which has its own separate page on wikipedia) :)
00:21:39 <dolio> As in, something undesirable you have to do to get something desirable?
00:21:52 <glguy_> I see your wikipedia reference and raise you http://www.wsu.edu/~brians/errors/catch22.html
00:21:55 <lambdabot> Title: catch 22, http://tinyurl.com/t4aen
00:22:30 <glguy_> I'll side with this site over wikipedia any day
00:22:34 <desrt> glguy_; in agreement with my definition :)
00:22:49 <Smokey`> if anyone can be bothered, just looking for feedback/criticism on my code... it's nothing exciting nor pretty, but it does the job...   http://rafb.net/paste/results/rKY3No92.html
00:22:50 <desrt> the example they give is exactly "A gives you B and B gives you A but you can't get either"
00:22:50 <dolio> Oh, I see. You're saying peopel use catch-22 when what they're describing is just a catch.
00:23:12 <glguy_> desrt: right, you are describing a catch
00:23:23 <desrt> no.  this is a catch22.
00:23:31 <desrt> read the site that you pasted a link to more carefully
00:23:34 <glguy_> no, catch22 is not a generic
00:23:50 <glguy_> I see that
00:23:52 <desrt> your site says "you can’t get published until you have an agent, and you can’t get an agent until you’ve been published" is a catch-22
00:23:58 <Ulfalizer> A requires B and B requires A and you don't have either would be a catch22
00:24:05 <desrt> Ulfalizer; exactly.
00:24:09 <glguy_> yeah yeah
00:24:17 <glguy_> I misread the page way back when
00:24:21 <desrt> :p
00:24:25 <glguy_> sour grapes!
00:24:28 <desrt> hahahah
00:24:29 <Ulfalizer> :P
00:25:32 <glguy_> there was a "sour grapes" entry as well http://www.wsu.edu/~brians/errors/sour.html
00:25:34 <lambdabot> Title: sour grapes
00:25:43 <araujo> dons, on it :-)
00:25:45 <desrt> hmm
00:25:50 <desrt> dining philosophers is sort of like a catch-22
00:25:59 <desrt> but a 5-way one
00:26:29 <desrt> you could eat your meal if only the damn guy beside you would finish his
00:26:35 <desrt> and he could eat his if only you'd finish yours
00:26:52 <dibblego> > let reverse [] = []; reverse (x:xs) = reverse (xs) ++ [x] -- why is this inefficient?
00:26:53 <lambdabot>  Parse error
00:27:06 <dibblego> > let reverse [] = []; reverse (x:xs) = (reverse xs) ++ [x] -- why is this inefficient?
00:27:06 <lambdabot>  Parse error
00:27:11 <desrt> dibblego; ++ is evil
00:27:14 <glguy_> dibblego: serious?
00:27:19 <desrt> avoid its use if at all possible
00:27:25 <dibblego> serious
00:27:34 <desrt> let me tell you a story about a guy
00:27:39 <desrt> i can't spell his name so i'll just call him joe
00:27:43 <dibblego> > let reverse [] = []; reverse (x:xs) = (reverse xs) ++ [x] in reverse [1..10] -- why is this inefficient?
00:27:44 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
00:27:45 <glguy_> dibblego: the first list has to be copied is why
00:27:49 <desrt> dibblego; listen up
00:28:01 <lispy> dibblego: i think the answer to your question in #darcs is that darcs doesn't diff binary data and for text data it does it line by line, ala 'diff'
00:28:02 <glguy_> dibblego: so in the case of reverse, you are copying a list once for each element in the list
00:28:04 <desrt> joe is looking for a job.. he looks around and finds this crew making a road
00:28:14 <dibblego> lispy, thanks
00:28:20 <desrt> the foreman on the job says "ok joe... let's see how you do today... paint me a line down this road"
00:28:41 <desrt> after a day of work, joe goes back to the boss who says "awesome work joe!  300 metres in one day.  come back tomorrow!"
00:28:42 <dibblego> gah I see why
00:28:48 <dibblego> I hate forgetting stuff
00:28:50 <desrt> joe comes back the next day... paints some more line
00:29:02 <dibblego> I'm on medication lately :) is my excuse
00:29:04 <desrt> at the end of the day the boss is like "only 150 metres today joe.. but still not bad... come back tomorrow"
00:29:07 <glguy_> I don't like Joe...
00:29:18 <desrt> on the 3rd day joe goes back to work...
00:29:25 * glguy_ fires joe
00:29:46 <desrt> but after the 3rd day his boss is angry... he says "joe... on your first day... 300 metres.. great... but on your second day, only 150... and today, only 50!"
00:29:50 <desrt> "why are you working so slowly?"
00:30:01 <dibblego> nice metaphor :)
00:30:05 <desrt> joe says "i'm not working slowly.  it's just that the bucket is so far away now!"
00:30:20 <desrt> (the end)
00:30:26 <dibblego> you should blog it
00:30:33 <Akheron> *appalause*
00:30:39 <desrt> moral: do NOT grow linked lists by appending to them :)
00:30:52 <glguy_> desrt: and title it "Appending is slow?"
00:31:02 <desrt> i didn't make this story up
00:31:08 <desrt> i'm sure it's already out there somewhere :p
00:31:21 <dibblego> you really should write it up
00:31:30 <desrt> i really should go to bed!
00:31:32 <desrt> holy crap
00:31:43 <dibblego> I'll write it up then
00:31:55 <dibblego> oh wait, I don't have a blog
00:32:47 <desrt> the guy's name is "Schlemiel"
00:33:28 <dibblego> you mean in the real life story?
00:33:29 <desrt> found it
00:33:32 <desrt> http://discuss.fogcreek.com/techInterview/default.asp?cmd=show&ixPost=153
00:33:35 <lambdabot> Title: The Old techInterview Forum - Shlemiel the Painter, http://tinyurl.com/ybog9j
00:34:02 <dibblego> nice
00:34:21 <kfish> it's an old joke, but then so are linked lists and people still use them :-)
00:34:38 <glguy_> linked lists are an old-joke?
00:34:57 <desrt> linked lists are the best data structure for an awful lot of things
00:35:02 <dolio> Heh, glguy, how about: "I'm jumping ship, what other good social network sites are around that actually have INTERESTING technical articles?"
00:35:22 <desrt> ok.  nite everyone.
00:35:32 <glguy_> dolio: where was that?
00:35:36 <glguy_> OHH
00:35:37 <glguy_> found it
00:37:12 <lispy> dolio: yeah, i modded that one down juston the title
00:37:13 <dibblego> seeya
00:43:50 <araujo> hah, bunch of funny quotes in this hwn
00:45:21 <dolio> I was dismayed. My golden ratio one-liner didn't get in. :(
00:46:13 <dolio> I guess it's not different enough from a fibonacci generator.
00:47:31 <Syzygy-> desrt: You should prepend? Or insert sorted? Or?
00:48:07 <Ulfalizer> prepending is good
00:50:37 <Ulfalizer> a common strategy is to keep a separate "result list" that you pass along and prepend to, building the result step by step instead
00:52:37 <dolio> Note elemsTree here: http://tinyurl.com/y3l23z
00:52:39 <lambdabot> Title: Introductory Haskell: Solving the Sorting-It-Out Kata
00:55:35 <araujo> dons, i find this document about how to start a haskell project very useful
00:55:44 <araujo> dons, i will definitely translate it too
00:56:00 <Ulfalizer> what article?
00:56:04 <araujo> That's the kind of stuff newcomers need
00:56:15 <araujo> Ulfalizer, check HWN
00:56:20 <Ulfalizer> HWN?
00:56:57 <Ulfalizer> void: moo :|
00:57:20 <void> Ulfalizer: hoo :/
00:57:32 <araujo> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/16164/focus=16164
00:57:35 <lambdabot> Title: Gmane Loom, http://tinyurl.com/vtvg5
00:58:17 <araujo> http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
00:58:19 <lambdabot> Title: How to write a Haskell program - HaskellWiki, http://tinyurl.com/yxe296
01:00:07 <Syzygy-> @type (==>)
01:00:08 <lambdabot> Not in scope: `==>'
01:00:20 <dons> ?hoogle ==>
01:00:20 <lambdabot> Test.QuickCheck.(==>) :: Testable a => Bool -> a -> Property
01:03:34 <lispy> dons: i didn't find time to work on the t-shirt!
01:03:49 <lispy> why does mediawiki search suck, and can we fix it or replace it?
01:09:04 <dblhelix> @pl (\(a, b) (c, d) -> f a c)
01:09:05 <lambdabot> (`ap` snd) . (. fst) . (const .) . f . fst
01:09:23 <lispy> easy to read!
01:09:59 <lispy> ?pl \(a, b) (c, d) -> (b c, a d)
01:10:00 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip (flip . (((.) . (,)) .)))
01:10:54 <lispy> ?pl \(a, b) (c, d) -> (b c) (a d)
01:10:55 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip (flip . ((.) .)))
01:13:08 <dblhelix> what i was looking for is
01:13:19 <dblhelix> (. fst) . f . fst
01:14:32 <lispy> i found thigs like: (foo .) . bar
01:14:34 <lispy> hard to read
01:15:06 <lispy> ?type ((+) .) . (+1)
01:15:07 <lambdabot> forall b a. (Num b, Num (a -> b)) => (a -> b) -> a -> b -> b
01:15:23 <lispy> ?type ((+) .) . (+)
01:15:24 <lambdabot> forall a. (Num a) => a -> a -> a -> a
01:15:47 <lispy> > ((+) .) . (+) 1 2 3
01:15:48 <lambdabot>  add an instance declaration for (Num (t -> a1 -> a -> b))
01:15:58 <lispy> > ((+) .) . (+) $ 1 2 3
01:15:58 <lambdabot>  add an instance declaration for (Num (t -> t1 -> a))
01:16:04 <lispy> hmmm
01:16:11 <lispy> > (((+) .) . (+)) 1 2 3
01:16:12 <lambdabot>  6
01:18:33 <lispy> > (((+) .) . id) 1 2
01:18:33 <lambdabot>  add an instance declaration for (Num (a -> b))
01:19:29 <Bobstopper> @pl f x -> fmap fst  $ Just x
01:19:30 <lambdabot> (line 1, column 5):
01:19:30 <lambdabot> unexpected ">" or "-"
01:19:30 <lambdabot> expecting variable, "(", operator or end of input
01:19:39 <Bobstopper> @pl \f x -> fmap fst  $ Just x
01:19:39 <lambdabot> const (fmap fst . Just)
01:24:05 <lispy> dons: i re-volunteered to the haskell search engine
01:24:15 <lispy> dons: i don't think it worked correctly before
01:30:13 <lispy> dons: i see that it's now ranking things better
01:30:20 <lispy> openFile goes write to the library
01:31:08 <Syzygy-> ?hoogle IO a -> a
01:31:09 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
01:31:09 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
01:31:09 <lambdabot> Language.Haskell.TH.Syntax.qRunIO :: Quasi m => IO a -> m a
01:33:27 <dblhelix> @pl (\(x, y) z -> (x, y, z))
01:33:28 <lambdabot> uncurry (,,)
01:33:36 <Syzygy-> Ooooookay. There's something weird going on with my emailer and the Haskell Cafe..
01:34:00 <Syzygy-> I get occasional emails, but when I end up checking out the mail archive, there are MANY more emails than I've seen...
01:35:54 <dblhelix> @pl (\z (x, y) -> (x, y, z))
01:35:54 <lambdabot> (`ap` snd) . (. fst) . flip (flip . (,,))
01:37:19 <lispy> Syzygy-: i've noticed something like that, but not with haskell-cafe
01:37:39 <lispy> Syzygy-: maybe it's your spam filter
01:37:47 <dblhelix> @pl \(x, y) z -> (x, (y, z))
01:37:47 <lambdabot> uncurry ((. (,)) . (.) . (,))
01:38:13 <Syzygy-> lispy: Nope. My filter tags, but doesn't throw away...
01:38:15 <dblhelix> @pl (\z (x, y) -> (x, (y, z))
01:38:15 <lambdabot> (line 1, column 26):
01:38:15 <lambdabot> unexpected end of input
01:38:15 <lambdabot> expecting variable, "(", operator or ")"
01:38:33 <dblhelix> @pl \z (x, y) -> (x, (y, z))
01:38:34 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,)) . flip (,)
01:38:39 <dblhelix> aha
01:38:43 <lispy> Syzygy-: on some of the mail lists (but not haskell-cafe) i get things out of order
01:39:07 <Syzygy-> lispy: But I've missed things that passed by weeks ago and still haven't appeared...
01:43:18 <Syzygy-> Hmmmmm.... I just stumbled across a "discrepancy" of sorts in the monad concept. The space-man tutorial (and to a certain extent the type signature) describes the action of bind/>>= as "take out the thingie from the monad, and feed it through the function that sends it into the monad again"
01:43:36 <therp> is there any addon to haskell emacs mode that eases looking up documentation? for instance, built-in hoogle query on given terms?
01:43:53 <Syzygy-> However, every category theoretical axiom set I've seen for monads/triples has a natural transformation mm -> m, which is the object most reminiscent of bind in the axiom lists.
01:44:14 <Syzygy-> Which would be like "clothing the suited astronaut in another suit, and then removing one of the suits.
01:44:34 <dolio> ?type join
01:44:35 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
01:45:01 <Syzygy-> Ah. So join is the category theoretical entity, and not bind?
01:45:22 <dolio> I think join is the easier basis when you're doing category theory.
01:45:25 <Syzygy-> Can you express all the syntactic sugar with join and return?
01:45:32 <dolio> ?pl (join .) . fmap
01:45:32 <lambdabot> (=<<)
01:45:49 <Syzygy-> For one thing, join has the signature I expected.
01:45:55 <Syzygy-> ?type (=<<)
01:45:56 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
01:46:05 <Syzygy-> ?type fmap
01:46:06 <dolio> >>= is flip (join . fmap) (need the extra . for haskell's type system.
01:46:07 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
01:46:26 <dolio> Since all monads functors, you can always build it.
01:46:35 <dolio> And let's see...
01:47:06 <dolio> ?pl \f m -> join (f m)
01:47:06 <lambdabot> (join .)
01:47:20 <dolio> Hmm...
01:49:55 <dolio> ?pl (>>= id)
01:49:55 <lambdabot> join
01:50:04 <dolio> So you can build one out of the other.
01:50:14 <dolio> And vice versa.
01:50:18 <Syzygy-> Right.
01:50:32 <Syzygy-> So one is syntactic sugar for the other. Then I'm more comfortable with the concept. :)
01:50:52 <dolio> Most haskell monads do >>= directly, and join indirectly, though.
01:51:07 <dolio> I don't think join is even part of the monad class.
01:51:59 <dolio> But in theory, you can take your pick.
01:52:53 <Syzygy-> Nooo, join doesn't seem to be part of the monad class. Not according to my ghci
01:53:12 <dolio> Yeah, it's just implemented in terms of (>>=).
01:54:42 * araujo `offTo` univ
01:55:09 <Syzygy-> Reminds me.... I've seen occassional mentions of comonads. Are they useful, and how do they work?
01:55:56 * Syzygy- 'd expect them to be an endofunctor m, with something m a -> a and something m a -> m m a
01:55:58 <dolio> I've read a couple papers on them, but I'm not as familiar with them as I am with monads.
01:56:08 <Syzygy-> And diagrams for the "obvious" relations of them
01:56:25 <dolio> But, yeah, there's counit c a -> a.
01:56:38 <dolio> And I think the papers I've seen use cobind.
01:56:53 <musasabi> comonads are nifty but some of their uses would like things that the Haskell typesystem currently lacks.
01:56:59 <Syzygy-> ?type bind
01:57:00 <lambdabot> Not in scope: `bind'
01:57:08 <musasabi> bind = >>=
01:57:09 <dolio> Bind is (=<<)
01:57:19 <Syzygy-> ?type (=<<)
01:57:20 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
01:57:29 <dolio> At least in the context of those papers.
01:58:10 <Syzygy-> So cobind would be (c a -> b) -> c a -> c b ?
01:58:22 <alar> @quote adept
01:58:22 <lambdabot>  Tried to co-read and co-understand comonads, but got co-re dump
01:58:30 <Syzygy-> Hehe
01:58:45 <Syzygy-> co-reading and co-understanding seems counterproductive though... :P
01:59:02 <alar> coproductive
02:02:17 <dolio> The way I've seen them described is that (c a) is a value of type a in some context c.
02:02:54 <dolio> So c a -> b is a function from a value a to a value b that can make use of the implicit context.
02:04:02 <Ulfalizer> does experience with monads in category theory help when learning about monad concepts in haskell?
02:04:39 <roconnor> @seen dons
02:04:40 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 1h 4m 20s ago.
02:07:09 <Syzygy-> Ulfalizer: It does, a bit, yeah.
02:07:25 * Syzygy- revisited "Toposes, triples, and theories" and suddenly got more of a grip on monads...
02:07:36 <Syzygy-> For me, it's very much a case of both areas helping the other along.
02:08:38 <Syzygy-> But I also have as a primary mental model some remarks heard on an operad theory conference, not anything in any of the haskell documentation....
02:09:49 <Ulfalizer> Syzygy-: is that a book on category theory?
02:10:05 <Ulfalizer> t, t, & t  that is :)
02:10:34 <Syzygy-> More or less..
02:10:59 <Syzygy-> It's on Topos theory and on logic, but that all moves very closely interweaved with category theory as such.
02:11:16 <Syzygy-> Very handwavy, my current impression is that a topos is a sheaf of categories.
02:12:11 <Ulfalizer> i've no exposure to category theory or even abstract algebra yet :/
02:12:32 <Syzygy-> Oh dear. Then I would recommend you to wait a while with tt&t.
02:12:33 <Ulfalizer> +had
02:12:41 <Ulfalizer> ok
02:20:01 <musasabi> @hoogle ByteString -> (Char,ByteString)
02:20:02 <lambdabot> No matches, try a more general search
02:28:47 <Bobstopper> is gtk2hs' mogul layer deprecated?
03:05:42 <dcoutts> Bobstopper, yes, the mogul package is deprecated.
03:05:53 <Bobstopper> thanks
03:07:32 <enolan> Huzzah! Real name - irc nick coherence with services!
03:37:21 <dons> is cl-darcs an attempt to do a darcs rewrite?
03:38:38 <mrchebas> hi there, does any of you know what is the repository (darcs or cvs) for hmake?
03:39:07 <dons> ?where hmake
03:39:07 <lambdabot> http://haskell.org/hmake
03:39:20 <dons> it's available in darcs, iirc
03:39:26 <dons> (or maybe as part of nhc98)
03:39:36 <mrchebas> yep, it's the last one
03:39:57 <mrchebas> i want to make it work with ghc-6.6
03:40:07 <mrchebas> maybe installing nhc with all the utils is better
03:40:29 <dons> hmm. hmake should work standalone. malcolm mightn't have looked to port it yet. how does the build fail?
03:41:43 <mrchebas> ?googleit complains about readline
03:41:46 <lambdabot> http://www.evl.uic.edu/cavern/sage/faqs.php
03:41:46 <lambdabot> Title: SAGE :: DOCUMENTATION
03:41:50 <mrchebas> oops
03:41:52 <mrchebas> sorry for that
03:42:10 <dons> ok. do you have readline installed?
03:42:12 <mrchebas> i saw on a thread that Malcolm pushed a fix
03:42:18 <dons> ah ok.
03:42:21 <mrchebas> yeah, i do
03:42:28 <kzm> Hah - the last line from apt-get: "Get:404 http://no.archive.ubuntu.com edgy/main nmap 4.10-1 [719kB]".  I thought it was an error :-)
03:42:30 <mrchebas> but i think that the package nameing changed
03:42:30 <lambdabot> Title: Index of /
03:42:49 <mrchebas> so i want Malcolm's fix :)
03:43:19 <dons> ok so grab the darcs repo.
03:43:35 <mrchebas> do you have the url?
03:43:39 <mrchebas> i grabbed the nhc one
03:45:46 <therp> is it actually ok to define an instance X Y outside the module that is defining the class/data Y?
03:46:11 <mrchebas> dons: do you know if there is a separate hmake repo?
03:46:15 <swiert> mrchebas: Hi!
03:46:25 <mrchebas> hey wouter
03:46:39 <swiert> how's cambridge?
03:46:41 <mrchebas> trying to build hat over here :)
03:46:48 <mrchebas> pretty cool
03:46:53 <swiert> what are you working on?
03:46:56 <mrchebas> i was busy these days preparing a presentation
03:47:14 <mrchebas> i am going to implement the semi-tagging optimization
03:47:23 <mrchebas> probably you can find it on the trac wiki
03:47:38 <swiert> ok - I'll do a google.
03:47:45 <swiert> No generics for ghc yet?
03:47:56 <mrchebas> so i was hoping to build ghc with hat, to help me understanding the source
03:48:18 <mrchebas> might be, might be, but not for the moment
03:48:29 <roconnor> dons, what is the recommend way of updateing my darcs patch/my trac?
03:48:32 <mrchebas> i want to get more involved with the common generics library effort
03:48:52 <swiert> The effort seems like a really good idea.
03:48:57 <mrchebas> and maybe then i will know of an economic way to improve the support for generics in ghc
03:49:11 <dons> roconnor: so the best way i think would be to attach an updated patch to the existing ticket
03:49:34 <swiert> Yeah, makes sense. So are you up to your elbows in ghc-internals atm?
03:49:40 <mrchebas> yes
03:49:48 <mrchebas> reading lots of code
03:49:51 <swiert> Any fun?
03:49:58 <mrchebas> i was doing benchmarks these last weeks
03:50:00 <mrchebas> yeah
03:50:03 <mrchebas> terribly fun
03:50:08 <roconnor> dons: okay, but should a make a new patch, or bundle my two patches together?  I probably should make a new patch.
03:50:13 <mrchebas> it was long time ago since i did low-level stuff
03:50:55 <dons> roconnor: a new patch, yes. darcs amend-record or some such
03:50:58 <mrchebas> swiert: so you're going to go the Fun in the Afternoon. It seems like a nice event
03:51:10 <mrchebas> are you giving a talk there?
03:51:19 <swiert> I'm not too fond of that kind of hacking, but to each their own.
03:51:22 <roconnor> dons: wouldn't amend-record be unsafe, since I've distributed my patch to the mailing list?
03:51:38 <Binkley> *waves hi to mrchebas*
03:51:47 <dons> yes . good point. so you coudl amend-record, and note that the old patch is now to be unpulled
03:51:53 <swiert> mrchebas: yes. I'll talk about the version control stuff I've been doing with Daan and Andres.
03:51:54 <dons> i doubt it has been widely applied yet
03:52:22 * mrchebas waves back to Binkley
03:52:35 <mrchebas> nice
03:52:36 <dons> Fun in the Afternoon people: any chance we can get a video or at least notes of the event?
03:52:39 <mrchebas> some darcs stuff?
03:52:42 <roconnor> True.  But I feel better going with a new patch, unless there is a reason not to.
03:52:56 <dons> if someone could take notes for the HWN, as we did for CUFP, that would be really great!
03:53:09 <dons> (i'll be taking notes for APLAS next week ... :)
03:53:28 <swiert> dons: I'll check with Conor and Graham.
03:53:42 <pharm> I'll probably be going to the FitA, since I'm in the office down the hall from Jeremy, so I could take some notes if no-one else is going to...
03:53:56 <swiert> the least we can do is collect slides.
03:54:25 <dons> so slides are good, notes+slides are better, notes+video is even better still.
03:55:09 <pharm> Can't supply a video camera though...unless anyone knows where we can borrow one in Ox.#
03:55:09 <dons> here's the notes from CUFP, to give you an idea, http://sequence.complete.org/hwn/20060927
03:56:14 <dons> how was the ghc hackathon filmed? was that malcolm wallace's camera?
03:57:18 <mrchebas> i heard he filmed it but no idea about the camera
03:58:04 <dons> its at oxford, right? maybe we could get dcoutts on the case.
03:58:12 <dcoutts> @yarr!
03:58:13 <lambdabot> Eat maggoty hardtack, ye unkempt, jenny frequentin', son of a gun.
03:58:16 <dcoutts> what ?
03:58:27 <dons> speak of the devil himself!
03:58:35 <dcoutts> you want me to record it ?
03:58:39 <dons> you goint to Fun in the Afternoon?
03:58:41 <dcoutts> yep
03:58:43 <dons> could we get video?
03:58:46 <dcoutts> hrm
03:58:58 <dcoutts> if someone can get me the equipment, possibly.
03:59:04 <dons> (i.e. do you know where to rustle up a camera somehow? in the dept?)
03:59:23 <dcoutts> not sure if we have anything like that
03:59:54 <dons> perhaps you guys should check with Jeremy and the other organisers. I'd say one of them must have access to a camera somehow.
04:00:14 <dcoutts> yeah, Jeremy is more likely to
04:00:15 <pharm> hold on, I'll just go prod Jeremy...
04:00:41 <pharm> he's not in his office...
04:00:56 * dcoutts has the impression that Soft Eng are rolling in it
04:01:06 <pharm> shhh. Don't tell anyone...
04:01:14 <pharm> or they'll all want some...
04:01:19 <dons> heh
04:01:35 <dcoutts> yeah! like us poor cold hungry prog lang folk ;-)
04:01:40 <pharm> nb. I'm Phil Armstrong btw: Ganesh knows me from a few years ago...
04:08:45 <Bobstopper> Hmm... the FRP community seems to be a bit stagnant if the yampa-users mailing list is anything to go by :(
04:10:38 <Philippa> yeah, it was always just a little hard for interested potential users to start hacking unfortunately
04:10:56 <dons> haskell-cafe@ might bring up more results?
04:11:00 <Philippa> still, Yampa's a big chunk of research lore for the next time someone wants to have a go
04:11:02 <roconnor> @pl \x -> (f x, g x)
04:11:02 <lambdabot> liftM2 (,) f g
04:11:19 <Philippa> point, I doubt I would've subscribed even if I'd started doing something serious with it
04:11:34 <dons> @pl \x -> (f x, f x)
04:11:34 <lambdabot> liftM2 (,) f f
04:11:40 <dons> should be an arrow for that
04:12:05 <xerox> join (&&&)
04:12:14 <dons> for those who didn't see it earlier, http://www.haskell.org/pipermail/haskell-cafe/2006-November/019190.html
04:12:16 <lambdabot> Title: [Haskell-cafe] there's a monster in my Haskell!, http://tinyurl.com/y49m75
04:12:19 <dons> ?type join (&&&)
04:12:20 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
04:12:31 <dons> that's so crazy, it just might work!
04:12:34 <xerox> ^_^
04:12:57 <dons> i need to get xerox into improving @pl with more rules..
04:13:14 <Bobstopper> anyone know what the current focus in FRP is then? My main concern at the moment is efficiency, but I'm not sure if yampa is inefficient because optimising it is a hard problem or developers ore just working on other stuff.
04:13:26 <dons> Bobstopper: seems to run find in Frag
04:13:35 <xerox> We were talking about that with Duncan yesterday, wandering around in Oxford, dons!
04:13:48 <dons> ah nice, xerox
04:13:48 <Philippa> ask? I suspect it's tricky to optimise well without linear or uniqueness types though
04:13:51 * dcoutts grins
04:13:55 <dcoutts> hia xerox
04:13:56 <xerox> Hiya =)
04:14:00 <twb> Does Haskell have a built-in function similar to the UNFOLD procedure in SRFI-1 <http://srfi.schemers.org/srfi-1/srfi-1.html> ?
04:14:00 <dcoutts> flight ok ?
04:14:03 <dons> you were planning to hack on @pl?
04:14:08 <Philippa> 'lo xerox - how long're you over here for?
04:14:10 <dons> ?type unfoldr --?
04:14:11 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
04:14:18 <Philippa> not any more, then :-)
04:14:18 <twb> Cool.
04:14:19 <dons> twb ^^ ?
04:14:21 <Bobstopper> well, I think it's efficient with continuous time stuff, but if I understand correctly it busy waits if it has nothing to do.
04:14:30 <xerox> dcoutts: it has been a bit different from my previous flights, it was the first time I flew at night, and the shakes were a bit scary :)
04:14:34 <dons> twb: i.e. the dual of fold?
04:14:36 <Philippa> busy waiting under lazy evaluation isn't what you think it is
04:14:40 <dcoutts> xerox, heh :-)
04:14:42 <twb> For some reason I don't see unfold as often as fold and map.
04:15:07 <dons> yeah, generating list from seeds is not that common, and usually you'd use replicate, or repeat, or ..
04:15:09 <Philippa> but for many uses you'd be feeding it "oi, gimme a render!" requests regularly anyway
04:15:17 <xerox> Philippa: I've been to London to visit Google, with a bunch of SoC students, and then visited a friend in Richmond, after that I've been to Oxford with Duncan for two days.
04:15:17 <dcoutts> twb, yeah, I think unfold is underappreciated
04:15:25 <Philippa> I've had cause to unfoldM a couple of times
04:15:26 <dons> ?karma unfoldr
04:15:26 <lambdabot> unfoldr has a karma of 3
04:15:32 <Philippa> which is annoying, because it's not in the libs
04:15:34 <dons> it does have a small fan club here though :)
04:15:45 <dons> Philippa: darcs patch to libraries@ ..
04:15:56 <dcoutts> dons, yeah, we appreciate unfolding stepper functions :-)
04:16:01 <dons> right!
04:16:03 <twb> I wonder if it can do anything DO can.
04:16:08 <Philippa> xerox: 'k. Was just wondering if you were likely to be around for Fun in the Afternoon, but that's a while off yet
04:16:09 <Bobstopper> Philippa: have you run any of the fruit examples and watched the CPU time when the game isn't playing? It uses about as much as when it is playing...
04:16:09 <twb> I guess that's a question for #scheme :-)
04:16:26 <xerox> Philippa: next time :)
04:16:27 * emk was happy to discover everywhereM the other day.
04:16:38 <Philippa> dons: willpower patch to flippa@... :-) I'm rather busy by my standards atm too, and not just the number of dates and metadates I seem to have at the mo
04:16:39 <xerox> emk: what's that!
04:16:55 <Philippa> (metadate = agree to agree on a date later)
04:16:57 <dons> xerox: the Data.Generics traversals
04:17:03 <xerox> huh.
04:17:19 <emk> xerox: Well, "everywhere" rebuilds a tree by applying a transformation to each node. "everywhereM" is the monadic version.
04:17:21 <Philippa> Bobstopper: I hadn't, that could be a bad implementation on Fruit's part though
04:17:55 <emk> I'm not even using the Data.Generics version yet; just a hand-coded implementation of the idea.
04:17:58 <Philippa> also, even if it's not you probably only need to rewrite the one high-level func to feed stuff in the right way
04:18:06 <Bobstopper> Oh well, I guess there's only one way to find out. I'll have a shot at making a gtkfruit
04:18:48 <dcoutts> Bobstopper, go for it, that'd be great.
04:18:53 <emk> xerox: Something like "everywhereM simpleOptimize ast"...
04:18:55 <xerox> emk: what tree are you talking about exactly?
04:19:08 <emk> xerox: That's the nice part. The standard everywhereM doesn't care.
04:19:29 <Philippa> ...thought, it's probably quite tricky to do right on concurrency grounds. It's nice and easy if you just have an SDL+OGL event loop kind of thing...
04:19:37 <emk> xerox: If you define a version by hand, it works on whatever kind of tree you define it on. But Data.Generics is very clever...
04:19:53 <Philippa> ...but that's because you're intending to grab all the CPU you can and chuck frames out like crazy
04:20:12 <Philippa> games're traditionally really unpleasant programs to share a CPU with :-)
04:20:25 <pharm> Jeremy is teaching all week, so if someone wants to bug him about getting a video camera for FinA they should probably email him...
04:20:27 <xerox> emk: I never used, it, what's its point?
04:20:35 <emk> You can say "transform every Salary (or Expression, or whatever) in the tree by applying this function"...
04:20:58 <xerox> emk: wow.
04:21:22 <emk> xerox: Yeah. The "Scrap Your Boilerplate" paper has some really cool examples.
04:22:10 <emk> "everywhere" first rebuilds all the child nodes of node by calling itself recursively. Then it applies your function to the rebuilt node.
04:22:38 <xerox> dons: the Monster thing is funny, we're reaching ordinals counting metaphors for monads!
04:23:39 <emk> So if you have a "simpleOptimize" function that can replace an Expression node with a simpler Expression node, "everywhere simpleOptimize expr" will recursively rebuild a expression in an optimized fashion. It's a nice little function, especially the generic version.
04:25:26 <emk> xerox: The Monster thing?
04:26:34 <musasabi> Any ideas how to write a RULE pragma matching over (>>=) ? I don't have an idea how to go over the variable binding.
04:27:33 <musasabi> I am trying to make the rule work over something like: "do a <- decodeWord8; b <- decodeWord8; ..." and combine the decodes.
04:29:04 <dcoutts> musasabi, I'd like to know that too. dons we wanted this for fusing hGetContents. Did we get anywhere ?
04:29:46 <dons> ah hmm. no, i don't think we did.
04:29:50 <dons> but seems doable..
04:31:54 <ventonegro> does anyone know when opengl for ghc 6.6 will be packaged for debian?
04:32:11 <SamB> do RULES support lambdas?
04:32:39 <SamB> obviosly not as the head of a match
04:33:50 <SamB> ventonegro: Igloo is probably the one to ask
04:34:07 <ventonegro> SamB, ah, thanks!
04:34:48 <ventonegro> i guess i'm gonna compile it myself for now
04:34:49 <musasabi> SamB: rules seem to support lambdas but it is hard to get anything done with them.
04:36:19 <SamB> ah. you can't do "(decodeWord8 >>= \a -> decodeWord8 >>= \b -> ...) = ..."...
04:36:35 <SamB> because you can't talk about the bound vars?
04:38:05 <dons> right.
04:38:21 <dons> you can use pointfree form and hope for the best though
04:38:35 <dons> f >>= g or (>>=) f g should match fine
04:39:00 <musasabi> dons: the problem is that one needs to look inside g for anything useful.
04:40:31 <SamB> dons: but that doesn't let you look into lambdas :-(
04:40:35 * roconnor cries
04:40:39 <SamB> roconnor: what?
04:40:58 <roconnor> what is the point of having a monospaced font, if the system turns fi into a ligature
04:41:08 <roconnor> sorry, it's unrelated to haskell
04:41:11 <Binkley> heh
04:41:14 <SamB> what system !??!?
04:41:18 <roconnor> coqide
04:41:29 <roconnor> but, I'm sure it gtk is responsible
04:41:31 <SamB> monospace fonts aren't supposed to *have* ligatures
04:41:41 * SamB blames pango
04:41:47 <SamB> or the font
04:41:48 <roconnor> could be
04:41:53 <roconnor> ah
04:41:58 <roconnor> I'm using FreeMono
04:42:02 <roconnor> maybe I get what I pay for
04:42:22 <musasabi> or I could just give up and play with the RULEs and just use infinite HLists to describe the lengths required by various serialization parts...
04:42:36 <SamB> well, first check it in a font editor/viewer like fontforge to see if it actually has a ligature
04:43:34 <SamB> then if it does, submit a bug for FreeMono
04:43:43 <SamB> if it doesn't, submit one for pango
04:43:47 <roconnor> I don't know enough about fonts to figure this out
04:44:02 <xerox> musasabi: sometimes I wish Oleg hanged out here on the channel :)
04:44:13 <roconnor> there are about a billion systems between coqide and what I see on the screen
04:44:14 <SamB> roconnor: it really isn't that hard
04:44:17 <roconnor> one of them has a bug
04:44:34 <SamB> just go look at the docs for fontforge...
04:45:06 <roconnor> but I'm more interested in proving that the rationals form a field
04:45:13 <pharm> roconnor: http://lists.alioth.debian.org/pipermail/pkg-fonts-bugs/2006-April/000064.html seems relevant...
04:45:16 <lambdabot> Title: [Pkg-fonts-bugs] Bug#358526: A working fix, http://tinyurl.com/y43zyl
04:45:57 <roconnor> pharm: that does seem relevent!
04:46:44 <pharm> roconnor: if you're into hacking the ttf. From a quick google it looks like opinions are devided on whether this is the fault of the fonts or pango...and whether pango should do anything about it if so...
04:46:47 <roconnor> heh, I need to set TZ=GMT to fix the bug
04:46:54 <roconnor> boy software sucks
04:47:19 <pharm> That's really weird...
04:47:33 <roconnor> *sniff* All I want to do is prove that the rationals are a field.
04:47:41 <pharm> How on earth does a font editing program have a dependency on the timezone?
04:47:44 <roconnor> It's not my fault that `field' begins with fi
04:48:01 <roconnor> maybe I can use german instead
04:49:08 <Syzygy-> @pl (. fst) . compare . fst
04:49:08 <lambdabot> (. fst) . compare . fst
04:49:19 <pharm> Having ligatures in a monospace font seems perverse...
04:49:23 <Syzygy-> ?type (.fs) . compare . fst
04:49:24 <lambdabot> Not in scope: `fs'
04:49:32 <Syzygy-> ?type (.fst) . compare . fst
04:49:33 <lambdabot> forall b a b1. (Ord a) => (a, b1) -> (a, b) -> Ordering
04:50:20 <Syzygy-> ?type (id ***) . flip (,)
04:50:21 <lambdabot> forall b b' a. a -> (b, b') -> (b, (b', a))
04:52:33 <Bobstopper> Wow... I just used cabal for the first time. I've got warm fuzzies crawling all over me
04:53:36 <norpan> eeew
04:53:43 <norpan> i hate when things crawl over you
04:54:45 <Bobstopper> naw, it's a whole new experience when they're warm fuzzies. I could happily sit in a barrel of warm fuzzies and often do while coding haskell.
04:55:20 <roconnor> cabal is pretty nice
04:55:47 <roconnor> But I mostly like the #!/usr/bin/runhaskell in .lhs trick.
05:00:01 <Bobstopper> hmm... I wonder if cabal could plug into some sort of utility to generate windows installer executables...
05:00:03 <pharm> My one gripe with cabal is that I always forget that I can have a per-user store when I'm installing non-system libraries & end up running it as root & writing into the main data files.
05:00:16 <Binkley> by "warm fuzzies" do you mean "monads"?
05:00:23 <pharm> nb. Looks like you can get AV kit in Oxford from http://www.ox.ac.uk/publicaffairs/mpu/hire.shtml
05:00:27 <lambdabot> http://tinyurl.com/yz2ytt
05:00:29 <pharm> Don't know if they charge though.
05:00:37 <musasabi> xerox: Getting HLists as a supported cabal package would be a good start.
05:00:49 <musasabi> xerox: but yes, getting him here would be very nifty.
05:01:19 <chessguy> i wonder if i could use haskell to figure out things like that x>y>z implies x>z
05:03:06 <Baughn> I don't see why not
05:03:41 <Baughn> ..of course, it would be a very large undertaking indeed, and there are already perfectly good automated proving systems around elsewhere
05:04:49 <chessguy> what i actually have is an inequality string like x>=y>=z>=0, and i want to find all the sensible inequality strings for 0,z,y,x,x+z,x+y,y+z, and x+y+z
05:05:23 <chessguy> it seems like a haskellish problem
05:07:03 <Cale> Is y+z > x?
05:07:17 <chessguy> unknown
05:07:19 <Cale> right
05:07:20 <desrt> it is.
05:07:38 <Baughn> Can't be, since x is a number larger than the largest number
05:07:42 <desrt> y or z alone are both > x.  added together they're WAY bigger
05:07:55 <Cale> no, they're both smaller
05:08:05 <Cale> they could add to something larger than x
05:08:09 <desrt> crazy math you have
05:08:19 <shapr> y0 desrt, how's code?
05:08:19 <chessguy> Baughn, suppose x=10,y=9,z=8
05:08:28 <desrt> shapr; i don't know.  i'm tired.
05:08:33 <desrt> classes melt code.
05:08:45 <shapr> I want some classes too!
05:08:51 <desrt> though i wrote a spiffy lambda calc interpreter for 706 the other day
05:08:53 <Baughn> chessguy: You can't just assign a random value to x, when I /know/ it is in fact the Number Larger Than the Largest Number
05:09:03 <desrt> apparently i seriously overdid it... but whatever.
05:09:16 <chessguy> ummm. ok then
05:09:45 <chessguy> Cale, does this seem like a good problem for haskell?
05:10:36 <Cale> chessguy: Sure, though I think you could probably work out which things are implied on paper.
05:10:58 <Cale> Or do you have a much more complex set of assumptions to begin with?
05:11:13 <chessguy> yes. there's actually one other parameter that i haven't mentioned, giving a total of about 50ish cases
05:11:26 <chessguy> but i want to generalize to more variables too
05:13:38 <chessguy> though that's going to be exponential, i guess
05:17:38 * Cale considers just modding down anything remotely industrial on reddit. :)
05:17:41 <Baughn> chessguy: Right. Well... you know that exponential-time problems are approximately impossible to solve for any decent N, yet humans /do/ solve this problem. So it isn't exponential-time for the right algorithm.
05:18:20 <Igloo> ventonegro: It was in NEW last I checked
05:18:56 <roconnor> do { let l =  [\x y z -> 0, \x y z->z,\x y z->y,\x y z->x,\x y z->x+z,\x y z->x+y,\x y z->y+z,\x y z->x+y+z]; a <- l; b <-l; e <- [<, <=]; quickCheck (\x y z -> x >= y && y >= z && z >= 0 ==> e (a x y z) (b x y z)}
05:18:58 <Philippa> Baughn: which problem is it, and do we actually solve or just approximate?
05:19:25 <ventonegro> Igloo, sorry, NEW? is that before experimental? :-)
05:19:46 <chessguy> Baughn, i've never heard this problem discussed by a human, much less solved by them
05:20:18 <desrt> humans are awesome
05:20:33 <roconnor> chessguy: presburger atirhtmetic?
05:21:03 <Igloo> ventonegro: It's a new package name, so it needs to be manually approved before it is released into the archive
05:21:31 <Baughn> Philippa: Solving math in general, I thought.. apparently not.
05:21:40 <ventonegro> Igloo, ah, ok
05:21:46 <ventonegro> Igloo, thanks for the info
05:21:53 <Igloo> ventonegro: If source or amd64 packages would help you then I could put a copy somewhere?
05:22:24 <ventonegro> Igloo, well, i'd be happy with source packages
05:22:36 <chessguy> Baughn, no, it's going from an inequality string for variables to an inequality string of variables with their sums
05:23:18 <Philippa> Baughn: in general we do take exponential time, there's so damn much to solve
05:23:20 <ventonegro> Igloo, somewhat unrelated, but as so many libraries are now packaged separately why has the ghc6 package grown so much?
05:23:32 <Philippa> but much of the time, we're not running a plain search - we're using piles and piles of heuristics
05:23:48 <Igloo> ventonegro: Because it includes GHC as a library
05:24:04 <Baughn> Philippa: We're /good/ at heuristics. Also at throwing massively parallel hardware at the problem, which right now /is/ the problem for me.
05:24:08 <ventonegro> Igloo, I see
05:24:56 <Baughn> chessguy: Is that even possible? I'd think the answer would be "unknowable", no matter the starting point
05:25:22 <Philippa> Baughn: much of the massive parallelism for the hard stuff comes from throwing many people at it...
05:25:31 <Philippa> the rest's just pattern-matching to fire heuristics for the most part
05:25:32 <chessguy> oops, i slipped slightly.
05:25:46 <chessguy> it's going from an inequality string for variables to sensible inequality strings of variables with their sums
05:26:46 <Baughn> Philippa: Pattern-matching, yes, but it's a parallel sort of pattern matching that is just plain impossible to implement on typical serial CPUs - computer vision is going /nowhere/, at least where I'm concerned.
05:27:27 <Baughn> Philippa: Not to mention that we seem to be more a case of a sufficiently large database than sufficiently smart algorithms. I don't have the database, either.
05:27:42 <Igloo> ventonegro: http://urchin.earth.li/~ian/gl/
05:27:43 <lambdabot> Title: Index of /~ian/gl
05:28:04 <ventonegro> Igloo, thanks very much!
05:30:13 <emk> Is there a good glossary of type theory notations anywhere?
05:31:15 <Philippa> Baughn: right. So the thing we're really not doing is solving an exponential problem reliably faster
05:31:32 <Philippa> we manage for small n a lot, of course...
05:32:21 <Baughn> We do manage good-enough approximations naturally for a /lot/ of exponential-time problems, though - often without even trying
05:32:34 <Baughn> It's very impressive, but also.. so very frustrating
05:35:29 <emk> Baughn: There's lots of theory about why NP-complete problems can be either (a) solved quickly in the "average" case, or (b) approximated quite well, isn't there?
05:36:26 <Baughn> emk: Oh yes. All NP-complete problems are equivalent, which means there are polynomial-time algorithms for solving /all/ of them to within some (arbitrary) percentage of perfection
05:36:48 <Cale> I wonder if there's a theory of approximate computational complexity, where one would talk about, say, quality-preserving polynomial-time reductions.
05:37:02 <Baughn> emk: ..well, equivalent for this purpose at least
05:37:20 <emk> I remember seeing a lot of material in a random algorithms book about how to analyze problems that were easier in practice than their worst-case bounds suggested.
05:37:27 <Smokey`> hmm, I take it that: Foo :: [a] -> Maybe a ... Foo [] = Nothing ... Foo (x:[]) = x ...  is not valid?  i'd actually have to check the length of the list, in  Foo (x:xs) = ... ?
05:37:48 <Cale> first of all, foo, not Foo
05:37:54 <Cale> (Foo is a dataconstructor name)
05:37:59 <Smokey`> yeah sorry :)
05:38:00 <emk> foo (x:[]) = Just x
05:38:04 <Baughn> emk: That's not NP-complete, though - those are just as bad in the average case as the worst case. I think you may be thinking of quicksort
05:38:08 <Cale> and secondly yeah, Just x
05:38:10 <Smokey`> yeah yeah typos aside :P
05:38:22 <Cale> also, you can write  foo [x] = Just x
05:38:39 <Cale> or else  foo (x:xs) = Just x
05:38:39 <Baughn> emk: The fast algorithms for np-completes are /approximations/. They're good enough for most purposes, but you can never know you get the /best/ answer.
05:38:51 <emk> Baughn: No, there are definitely whole classes of NP-complete problems where the average case is quite practical, even for complete solutions.
05:39:18 <emk> It's why cryptographers can't build a public-key algorithm from any old NP-complete problem...
05:39:19 <Smokey`> So ... (x:[]) is not a valid qualifier (not sure if qualifier would be the correct name :/)
05:39:46 <Baughn> emk: Define "practical". Are you sure you mean np-complete, and not np-hard?
05:40:07 <ndm> Baughn: average case complexity /= worst case, NP is worst case complexity
05:40:15 <chessguy> roconnor, you mentioned presburger arithmetic earlier....i'm not sure how that applies
05:40:25 <Cale> Smokey`: it's valid
05:40:40 <Cale> Smokey`: just giving some alternate possibilities for syntax :)
05:40:41 <emk> Baughn: Yeah. Proofs of NP-completeness only show that some inputs are equivalent to all other NP-complete problems. There's no reason that the average input can't be pretty easy in practice.
05:40:48 <Cale> [x] is often nicer to write
05:41:03 <Smokey`> hmmm, okay, I guess I'm doing something else wrong then ;)
05:41:16 <Baughn> emk: Hum. You have a point, but I have never run across such a problem - do you have a reference for me?
05:42:10 <emk> Well, the knapsack problem is a well-known one in crypto--early public key systems assumed that because it was NP-complete, it was hard to solve in practice.
05:42:32 <emk> It turned out that most choices of inputs were "easy", by cryptographic standards at least.
05:43:28 <Cale> lisppaste2: url
05:43:29 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
05:43:38 <Cale> Smokey`: post your code there, and I'll have a look
05:44:03 <Smokey`> Cale: nah it's okay now :)  it's happy now :)
05:44:10 <Cale> okay :)
05:44:21 <emk> Baughn: I've also seen some cases in a bioinformatics textbook, and IRC, there was some theory in here: http://www.amazon.com/gp/product/0521835402
05:44:34 <Smokey`> though I get the feeling I reinvented an already existing function (though, far less reusable), hehe
05:45:18 <Baughn> emk: Okay, thanks. I'll see if the library has one
05:45:36 <emk> Another interesting example is ML type inference: It's actually exponential in theory (not just NP-complete), but only if you build a peculiar kind of nested let statement. Every other case is trivially polynomial.
05:46:35 <Baughn> Whee. Does it disallow that construct, or is it implausible for anyone to actually write it except on purpose?
05:46:38 <emk> If a proof of NP-completeness maps the known-NP-complete problem into a small set of rare, pathological inputs in the problem you're proving NP-complete.
05:47:03 <emk> Baughn: I might show up in machine-generated code, but nobody would write it by hand.
05:47:25 <yaarg> s/ML/Hindley Milner/
05:47:43 <emk> yaarg: With polymorphic let, technically.
05:47:56 <yaarg> fair :P
05:48:33 <Philippa> um, polymorphic let is a critical part of HM, no?
05:48:46 <musasabi> small *infinite* set. (if the set is finite then the algorithm is trivially P)
05:49:08 <emk> Baughn: Anyway, it's not my field, but I think there's a bunch of stuff in the literature on problems that are much easier to solve/approximate in practice than in theory.
05:49:46 <yaarg> i can't actually remember
05:50:48 <emk> Philippa: For interesting languages, I think yes. But TAPL seems to think that polymorphic let is an interesting special feature, not something fundamental, IIRC.
05:51:04 <yaarg> mind rot..
05:51:05 <Philippa> no, it's critical to HM inference
05:51:09 * yaarg reads up on stuff
05:51:27 <Philippa> it's just not critical to parametric polymorphism in general (see System F, which doesn't have a let)
05:52:37 <emk> Philippa: Oh, yeah. H-M treats top-level definitions as a single polymorphic let. (D'oh.) But unless you can nest it in a particular way, it doesn't become exponential.
05:52:59 <Philippa> I hadn't seen it stated as "unless that" before, but that's a relief to know :-)
05:54:37 <emk> The pathological case is on page 334 of TAPL, if anyone wants to see ML type reconstruction go blooey.
05:57:48 <chessguy> blooey, eh? is that the technical term?
05:58:54 <Baughn> If blooey is exponential-time, what is kablooey?
05:59:48 <hyrax42> factorial?
05:59:55 <emk> http://en.wikipedia.org/wiki/Ackermann_function ?
05:59:57 <lambdabot> http://tinyurl.com/yhfzo5
06:00:33 <Baughn> emk: Don't mention that thing to me. I still have nightmares while sleeping...
06:00:58 <chessguy> heh. Ackermann is cool
06:01:43 <chessguy> i remember our algorithms class prof telling us about it. he told us the first couple terms, and we were all like "so what?". and then things went crazy :)
06:01:57 <hyrax42> O(busy beaver sequence)
06:03:22 <dons> ?type (((((:[]) :) :) :) :)
06:03:23 <lambdabot> forall a. [[[[a -> [a]] -> [a -> [a]]] -> [[a -> [a]] -> [a -> [a]]]] -> [[[a -> [a]] -> [a -> [a]]] -> [[a -> [a]] -> [a -> [a]]]]] -> [[[[a -> [a]] -> [a -> [a]]] -> [[a -> [a]] -> [a -> [a]]]] ->
06:03:23 <lambdabot> [[[a -> [a]] -> [a -> [a]]] -> [[a -> [a]] -> [a -> [a]]]]]
06:03:35 <dons> yay for type inference
06:03:38 <chessguy> nice
06:03:44 <Baughn> ..it went kablooey
06:03:54 <chessguy> nah, that couldn't be more than blooey
06:04:05 <dons> Cale has a true kablooey
06:09:37 <Cale> @type let f x = (x,x); f1 x = f (f x); f2 x = f1 (f1 x); f3 x = f2 (f2 x); f4 x = f3 (f3 x) in f4
06:09:52 <Baughn> Uh oh
06:09:52 <lambdabot> thread killed
06:10:06 <Lor> Wow.
06:10:34 <Lor> Nice sandboxing, though.
06:12:03 <Baughn> Hmm. Come to think of it... sandboxing haskell should be /easy/ - just don't let any IO values out
06:12:16 <Cale> Well, there's also the time-limitation thing
06:12:21 <Cale> but yeah
06:12:47 <flux__> and memory, and removing unsafe modules
06:13:36 <emk> Yeah, I suppose for people doing static code analysis, that "busy beaver" is the best candidate for "kablooey."
06:14:45 <Baughn> Does lambdabot attempt to limit memory usage, I wonder?
06:15:06 <Baughn> > [1..] !! (2^40)
06:15:07 <lambdabot>  1
06:15:14 <emk> Does anyone know a good glossary of type theory notations?
06:15:21 <Baughn> > [1..] !! (2^30)
06:15:25 <lambdabot> Terminated
06:15:35 <dons> Baughn: it does attempt to, yes.
06:15:37 <Cale> It sort of shows that once you have polymorphism, worrying about type programs always terminating is a little bit of a moot point, since you can get programs whose types are exponential in the length of the program.
06:16:50 <Cale> (on the other hand, they tend to be sort of stupid programs)
06:16:54 <dons> Baughn: yeah, the sandboxing is almost trivial. you just ask the typechecker to confirm the expression isn't in IO, and expose only a trusted base of modules
06:17:00 <dons> > print "x"
06:17:01 <lambdabot>  No IO allowed
06:17:15 <dons> ^^ type inference worked that out
06:17:27 <Cale> We could just have it print <IO action>
06:17:34 <dons> yep
06:17:35 <dons> > print
06:17:36 <lambdabot>  Add a type signature
06:17:37 <Cale> by writing a show instance for IO :)
06:17:41 <dons> > print :: IO ()
06:17:41 <lambdabot>    Expecting a function type, but found `IO ()'
06:17:41 <lambdabot>    Expected type: IO ()
06:17:42 <lambdabot> ...
06:17:51 <dons> > print :: () -> IO ()
06:17:53 <lambdabot>  <() -> IO ()>
06:17:56 <dons> but yeah. we could
06:18:10 <Philippa> > unsafePerformIO (putStr "boo!")
06:18:11 <lambdabot>  Not in scope: `unsafePerformIO'
06:18:18 <Philippa> not that I expect that to do anything, you understand :-)
06:18:29 <Philippa> but I figure it should be demonstrated
06:18:36 <dons> yeah. so actually working out the trusted base was a little harder than it should have been
06:18:55 <dons> a few little wholes via ST and so on have been shown. but otherwise that part wasn't too hard
06:18:57 <Cale> compiling a module with an unsafePerformIO in it should require a compiler switch
06:19:03 <Philippa> Cale: I disagree, it's much easier to accidentally write a non-terminating type program given a turing complete type system than to accidentally go exponential
06:19:15 <Cale> Philippa: yeah, that's true :)
06:19:27 <Cale> Philippa: that's sort of what I was hinting at there :)
06:20:02 <Baughn> dons: I see I'm going to have to look at lambdabot's code
06:20:24 <Cale> dons: what do you think of that idea? (Requiring a flag for unsafePerformIO to work)
06:20:24 <Philippa> dons: you can probably build a trustworthy version of the ST module, too
06:20:32 <Philippa> import/smaller export of the normal one
06:20:38 <Philippa> I think it's a good idea
06:20:39 <dons> Cale: yeah. would be ok.
06:21:16 <Cale> That way we wouldn't be lying quite as much when we tell people there's no IO a -> a
06:21:29 <Baughn> Cale: It feels too much like a gaping wound as is
06:21:34 <Philippa> I always have to point out to people that holing Haskell's system without getting caught is... difficult if you have the whole codebase handy, but it's even harder if you have to --ffsckmegentlywithunsafePerformIO
06:22:04 <dons> Baughn: btw, http://www.cse.unsw.edu.au/~dons/lambdabot/scripts/RunPlugs.hs
06:22:05 <lambdabot> http://tinyurl.com/h7nko
06:22:53 <dcoutts> Cale, but it's not just unsafePerformIO, there's a load of unsafe things in base. I was thinking that the compiler should help us track them.
06:22:53 <dons> ?users
06:22:53 <lambdabot> Maximum users seen in #haskell: 265, currently: 248 (93.6%), active: 33 (13.3%)
06:23:00 <Cale> dcoutts: yes
06:23:08 <Cale> dcoutts: I really think so too
06:23:55 <dcoutts> Cale, and that things that use unsafe things but are themselves safe could be marked as such with a pragma. Then it comes down to trusting the author of the package that they've done it right. So eg for base that'd be fine.
06:24:06 <Cale> yeah
06:24:21 <Cale> I totally agree with that plan :)
06:24:29 <Baughn> Cale: Being as I primarily use haskell for web services, I'd feel a /lot/ better if a simple filter on what is allowed to return IO would be enough to stop attacks
06:24:32 <dcoutts> no someone just has to implement it :-)
06:24:35 <dcoutts> no/now
06:24:57 <dcoutts> --safe-mode
06:25:03 <Cale> --broken-mode
06:25:10 <Cale> hehe
06:25:27 <dons> Baughn: right. basically you have to rule out IO, and then ensure no unsafe* is used. (but then are you actually allowing people to run arbitrary code?)
06:25:29 <Baughn> --std=h06? ;)
06:25:34 <Cale> I'm saying that we should have to turn on something in order to compile a module with unsafe bits
06:25:59 <Baughn> dons: No - no, I'm not, but I'm of the opinion that you can never have too much security
06:26:09 <Baughn> dons: Defense in depth, and all that
06:26:27 <Cale> maybe even not allowing that switch to occur in an OPTIONS_GHC pragma :)
06:26:40 <_matthew_> dons: how's hs-plugins with ghc6.6?
06:26:44 <Cale> so that whoever is building the module has to know that it's unsafe
06:26:47 <dcoutts> Cale, only on the command line, eg so you can put it in .cabal files where it's obvious
06:26:49 <dons> _matthew_: plan to do it this weekend.
06:26:54 <Cale> right
06:27:00 <_matthew_> dons: :)
06:27:15 <Cale> because if you can stick it in an OPTIONS_GHC, then it's no better than what we currently have
06:27:30 <Baughn> dons: You know, the existence of that lambdabot code is going to give me a massive argument in favor of haskell. Thanks!
06:28:23 <dons> yeah, i can sleep well at night knowing the h98 typechecker is hard at working ensuring no one hacks my box
06:28:43 <dons> > readFile "hack that!"
06:28:44 <lambdabot>  No IO allowed
06:29:37 <dons> proof carrying code for IO-free bots
06:30:44 <emk> Yeah, I'm not so interested in type systems for prevent my bugs, but it's really interesting to use them prove that only certain models of computation are being used in an arbitrary program..
06:30:45 <Philippa> Baughn: your #1 prevention against code injection attacks is using compiled code and being cautious with tools like hs-plugins
06:31:09 <Philippa> for values of cautious like not using it at all unless you've got a good reason to :-)
06:31:12 <Baughn> Philippa: Compiled..? You mean compiling it myself?
06:31:33 <Philippa> I mean compiling the app code on the server rather than running it through an interpreter
06:31:59 <Philippa> so that there's less chance of talking an interpreter into getting code from the wrong place
06:32:27 <Philippa> btw, if you're running code from the outside beware time/space attacks (both forms of DoS)
06:32:41 <Philippa> arbitrary code can still sit there forever or allocate all your memory
06:32:59 <Baughn> Philippa: I'm not (at the moment), but I might do so in the future - I'm very aware of /those/ attaacks
06:33:10 <Philippa> *nod*
06:33:30 <Philippa> strongly consider giving users a subturing scripting language you wrote and implemented yourself
06:33:32 <Baughn> That makes me very happy that GHC has a sane killThread. On the other hand.. is it possible to have per-thread heaps, maybe?
06:33:48 <Philippa> only in the sense each thread can be running its own ST
06:33:53 <Philippa> but that doesn't matter for pure code
06:33:58 <Philippa> well, not too much
06:34:10 <Philippa> you can always run it in a new OS-level process
06:34:53 <Baughn> I suppose.. this is getting a bit ahead of myself, though; I still need to /learn/ haskell properly.
06:44:45 <beelsebob> gyah
06:44:47 <beelsebob> silly make errors
06:45:36 <beelsebob> is Data.FiniteMap in any particular package?
06:45:52 <beelsebob> !paste
06:45:53 <ndm> beelsebob: the depreciated and dead package?
06:45:56 <beelsebob> @paste
06:45:56 <lambdabot> http://paste.lisp.org/new/haskell
06:46:12 <beelsebob> ndm: that's the one - the one that I have to you because I'm building something that uses it
06:46:24 <lisppaste2> beelsebob pasted "bah!" at http://paste.lisp.org/display/29089
06:46:25 <ndm> beelsebob: what?
06:46:38 <beelsebob> ndm: I'm building buddha - it uses Data.FiniteMap
06:46:44 <beelsebob> thus I need to use it
06:46:51 <ndm> beelsebob: hasn't that been updated and changed name?
06:46:57 <beelsebob> I haven't a clue
06:47:18 <beelsebob> yet another reason why ghc continuously moving the goal posts is a bad thing (TM)
06:47:21 <beelsebob> what is it now?
06:47:23 <Philippa> it's been replaced by Data.Map, yes
06:47:30 <Philippa> there's a compat module available somewhere though
06:48:01 <beelsebob> so... I now have to go through all this source code renaming all the functions?
06:48:03 <beelsebob> fucking useful
06:48:14 <Philippa> no, you have to find the compatability module
06:48:20 <Philippa> you do the rename later when you can be arsed
06:48:34 <Igloo> Far better that than to have all the nastiness still in our code in ten years time
06:48:58 <ndm> Igloo: yes, but you could remove it in 1 year, rather than 10 :)
06:49:14 <Philippa> ISTR they did
06:49:17 <ndm> Igloo: Data.PackedString for example will get removed the day its replacement comes out - now thats a bad idea!
06:49:24 <Philippa> point
06:49:34 <Philippa> how many people actually use PackedString though?
06:49:40 <ndm> Yhc
06:49:49 <Igloo> ndm: 6.4.1 was released more than a year before 6.6
06:49:57 <Igloo> (and included Data.Map)
06:49:59 <Philippa> also, wasn't FPS supposed to be a drop-in replacement originally?
06:50:13 <ndm> Philippa: its not though, its still not - no unicode support
06:50:23 <Philippa> ah
06:50:31 <ndm> Philippa: the unicode issue gets fixed in 6.8, the same day that PackedString dies
06:50:33 <Igloo> ndm: There's no reason the replacmeent needs to be a core library, anyway. You can write the replacement tomorrow if you want
06:50:46 <ndm> Igloo: thats inconvenient
06:50:51 <Philippa> that doesn't matter if it becomes a drop-in replacement at that point though
06:50:51 <beelsebob> the point I'm making is that there is a standard out there - the standard works - stick to it!!!!
06:50:52 <beelsebob> I should not have to edit someone's source code because the compiler has been updated by 0.2 versions since the code was released
06:50:54 <ndm> Igloo: and not the way depreciated modules should be done
06:50:58 <Igloo> (you can write the replacement tomorrow even if it /does/ end up being a core library, for that matter)
06:51:01 <Philippa> beelsebob: yeah, the standard is H98
06:51:19 <ndm> Philippa: drop in == same module name and interface
06:51:24 <beelsebob> Philippa: well... with the amendment for hierarchical modules
06:51:37 <beelsebob> so why the fuck does this standard code not fucking work
06:51:45 <beelsebob> (/me is not a happy bunny today)
06:51:49 <Philippa> because it's not standard code
06:51:56 <Philippa> the hierarchical libs were never standardised as such
06:52:10 <Philippa> H98's standard libs're rather more restricted
06:53:30 <Philippa> incidentally, you can still nab the original module from an earlier source release of GHC
06:53:59 <earthy> !sigh
06:54:08 <earthy> building ghc 6.6 from .hc files does not work.
06:54:15 <earthy> +for me
06:54:21 <Igloo> What goes wrong?
06:54:28 <earthy> I submitted a bugreport in trac
06:54:38 <earthy> multiple things go wrong ;)
06:54:54 <beelsebob> http://www.theregister.co.uk/2006/11/01/vista_delayed_until_20007/
06:54:57 <lambdabot> http://tinyurl.com/yag3g2
06:55:13 <Igloo> earthy: What are you trying to do?
06:55:28 * earthy and Arie Middelkoop are trying to get GHC into the nix build system
06:55:44 <Igloo> earthy: So not porting, just building from hc files on the same platform?
06:55:48 <earthy> yup
06:55:55 <earthy> very simple
06:56:00 <Igloo> OK, that didn't work for me either; haven't looked into it properly yet
06:56:30 * earthy is now trying to see if he can gets 6.4.2 to work building from .hc
06:56:44 <earthy> if that works we also have a reasonable bootstrapping path
06:56:57 <earthy> as nix allows multiple compilers to live next to each other
06:57:08 <earthy> (even multiple versions of the same compilers)
06:57:32 <Igloo> Why not do whatever you do for gcc?
06:57:50 * earthy doesn't know what is done for gcc
06:57:57 <earthy> looks like presence of gcc is presupposed. ;)
07:05:15 <earthy> just a pity that building ghc takes a day on my machine
07:05:30 <earthy> do step, wait day, do next step, wait day... :P
07:05:37 <Binkley> with or without optimization?
07:06:25 <earthy> with
07:06:39 <earthy> I want to end up with a compiler with optimization :)
07:06:46 <earthy> and I want to boot from scratch to a full set
07:07:06 <earthy> so there really is no way around it
07:07:41 <earthy> as soon as this is in the buildfarm things get better though
07:08:13 <Binkley> well, if you're making a lot of changes, you may want to rebuild with optimization off after each change, and then turn on optimizations once  you're done
07:16:22 <earthy> binkley: but I'm not doing changes. I'm just compiling ;)
07:16:41 <Binkley> well, you said "do step, wait day..." -- what steps are you talking about then?
07:16:59 <Binkley> oh, also, giving it a bigger heap can make a difference sometimes
07:17:19 <earthy> 'compile ghc' 'get hc files' 'compile ghc from hc files'
07:17:38 <earthy> takes about 2 days
07:17:46 <earthy> and yes, I do give it a slightly bigger heap
07:17:57 <earthy> but I'm on a 700 MHz G3
07:18:08 <earthy> not really the fastest of machines anymore
07:18:28 <Binkley> yeah, I remember when I was building ghc on a machine that slow...
07:18:43 <Binkley> back when dinosaurs roamed the earth ;-)
07:18:57 <earthy> yea, go ahead, make me feel old again. :)
07:19:26 <Binkley> Well, I just implied I was around when dinosaurs roamed the earth :-)
07:19:52 <earthy> when I bought this machine I thought it was might clever for being over 200 times faster than the first machine I bought
07:20:19 <Philippa> heh. If it helps any, I was brought up with punchcards in the house
07:20:23 <earthy> (which itself already was 30 times faster than the first machine I owned ;))
07:20:29 <Philippa> heh
07:20:43 <earthy> punchcards, I still have a few of those, punched with some Algol 60 code written by my father
07:21:17 <Binkley> my mom programmed on punchcards!
07:22:03 * earthy learned to program in BASIC (of all languages)
07:22:16 <earthy> glad to have haskell these days ;)
07:22:31 <psnl> my dad coded in Fortran for his Physics PhD. All the Physicists I know are still writing Fortran......
07:22:52 <_matthew_> psnl: ahh, but it'll be fortress soon for them!
07:23:08 <ohub> psnl; except the author of Darcs?
07:23:23 <psnl> ohub: never met him, which is a pity
07:24:10 <earthy> that's due to the NAG
07:25:04 * gds wonders about APL and J as languages for physicists...
07:26:13 <earthy> gds: they lost due to not having the NAG Fortran library available
07:26:58 <gds> :)
07:27:19 <earthy> ofcourse, by now NAG has been ported to C
07:27:35 <earthy> doesn't mean all the stuff that was built around it has been
07:28:25 * gds just googled, yeah...
07:28:48 <gds> Is there an effort (or a need for one) to port some/all of that stuff to haskell?
07:28:58 <earthy> not that I know of
07:29:22 <earthy> plus, do you know of a haskell compiler running on high-end NUMA hardware?
07:30:04 <earthy> (which is where NAG really shines... physics simulations take a *shitload* of computing power)
07:30:18 <gds> Cool :)
07:32:17 <roconnor> @seen ndm
07:32:17 <lambdabot> ndm is in #ghc, #haskell-overflow, #haskell-blah and #haskell. I last heard ndm speak 40m 58s ago.
07:33:22 <earthy> plus, ofcourse, fortran has always come with vendor support
07:35:35 <_frederik_> hello
07:36:12 <_frederik_> if i write a System.Posix.IPC.Shm, will it get into the ghc distro?
07:37:30 <Igloo> Why would it need to be in GHC, rather than a cabal package in hackage?
07:38:01 <_frederik_> where is all the other System.Posix stuff?
07:38:22 <_frederik_> i just want it to go where the other stuff is
07:38:27 <Igloo> If it naturally fits in with that, then possibly
07:38:52 <_frederik_> i don't know what would qualify as "naturally fits", if being under "System.Posix" doesn't
07:39:29 <Igloo> It depends on a number of things, including how stable and how big it is
07:39:52 <Igloo> The idea is to have as little as possible in the GHC distro, though
07:41:24 <_frederik_> well i want to add XShm support to X11, which is in the GHC distro. both could go in a separate package, but they seem like basic functionality which would be good to support out-of-the-box
07:41:50 <earthy> unless you are running ghc on a headless system
07:42:18 <Igloo> X11 is only in extralibs, which is going to disappear
07:42:28 <_frederik_> earthy: i do that all the time, and i also use X11 via ssh
07:42:37 <_frederik_> what is extralibs?
07:42:53 <earthy> libraries broken out of the main ghc tree
07:42:54 <Igloo> Things that used to be in GHC but aren't any more
07:43:07 <_frederik_> why will they disappear?
07:43:18 <earthy> the tarball will disappear, not the libs though, right?
07:43:35 <Igloo> Right, the libs will move to hackage
07:43:56 <Igloo> Because it's just a bandaid so the libs are easy to get during the migration
07:44:20 <roconnor> ndm: do you have the raw number for identifier lengths?
07:44:40 <roconnor> I would like to find the narrowest interval that containst at least 95% of the identifiers
07:44:50 <_frederik_> Igloo: so what are you saying. if i want to add something to X11, should i not bother because X11 is going to disappear?
07:44:57 <earthy> noe
07:45:00 * roconnor wonders what idetifier has 40 characters in it
07:45:16 <Igloo> _frederik_: X11 isn't disappearing, it's just not going to come with GHC
07:45:27 <earthy> which makes heaps of sense
07:45:38 <earthy> do the X11 libs come with gcc? no, they damn well don't
07:45:41 <_frederik_> Igloo: ok, so what's the procedure for contributing to it
07:45:43 <roconnor> oh, that isn't any
07:45:57 <roconnor> the longest is 34
07:46:38 <Igloo> _frederik_: http://www.haskell.org/haskellwiki/Library_submissions
07:46:41 <lambdabot> Title: Library submissions - HaskellWiki, http://tinyurl.com/y8yqmm
07:46:46 <roconnor> which identifers have 1 character in their names
07:47:05 <dcoutts> xlib is dead! long live xcb (or xhb)
07:47:37 <roconnor> http://haskell.org/ghc/docs/latest/html/libraries/fgl/Data-Graph-Inductive-Example.html#v%3Aa
07:47:39 <lambdabot> http://tinyurl.com/y7pmpw
07:47:52 <roconnor> a b c e
07:48:47 <_frederik_> Igloo: do they really want a trac ticket for simple patches?
07:48:53 <Igloo> _frederik_: Yes
07:50:34 <_frederik_> very well
07:51:47 <metaperl> great post: "There's a Monster in My Haskell" - http://www.haskell.org/pipermail/haskell-cafe/2006-November/019190.html
07:51:49 <lambdabot> Title: [Haskell-cafe] there's a monster in my Haskell!, http://tinyurl.com/y49m75
07:51:51 <_frederik_> as for XShm, there is no reason why it would not go in, is there?
07:53:08 <_frederik_> or System.Posix.IPC.Shm which it would depend on
07:55:54 <_frederik_> ping
08:02:30 <_frederik_> i'm wondering if i should start working on this stuff...
08:05:44 <Syzygy-> @check \x -> complement (-(x :: Int)) == (x - 1)
08:05:46 <lambdabot>  OK, passed 500 tests.
08:08:16 <Smokey`> 'night all.
08:08:41 <_frederik_> good night
08:10:31 <int-e> @version
08:10:32 <lambdabot> lambdabot 4p255, GHC 6.5 (OpenBSD i386)
08:10:32 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
08:11:01 <_frederik_> sigh. half the people here are talking to lambdabot. i wonder what happened to Igloo
08:11:21 <earthy> frederik: actually, there is a procedure for getting stuff into the libs
08:11:21 <scodil> why am I having such a hard time finding an array sorting function?
08:11:45 <_frederik_> earthy: like Igloo> _frederik_: http://www.haskell.org/haskellwiki/Library_submissions?
08:11:47 <lambdabot> Title: Library submissions - HaskellWiki, http://tinyurl.com/y2nnzd
08:11:59 <earthy> exactly like that. :)
08:12:14 <_frederik_> earthy: yeah we went over that a few lines ago
08:12:20 <earthy> so, if you build it and propose it, it will most likely be accepted.
08:12:25 <_frederik_> ok
08:12:39 <earthy> and yes, the trac tickets are important
08:12:44 <_frederik_> there's no aversion to X extensions?
08:12:57 <earthy> why would there be?
08:13:04 <_frederik_> why are trac tickets important?
08:13:06 <_frederik_> dunno
08:13:44 <earthy> because they support the workflow of the simons and isaac and document the proposed additions and changes to the libs
08:14:08 <earthy> the trac tickets basically gather everything in one easily managed place.
08:14:12 <_frederik_> i guess XShm is something that can be checked for at runtime so there's not going to be a compatibility problem
08:16:32 <_frederik_> earthy: well, i prefer mailing-list based systems. but i guess it's not hard to make a trac ticket
08:17:10 <weitzman> Random question: Any Google employees here?
08:18:06 <_frederik_> earthy: partly because it's a lot easier to send email offline, than browse the web offline.
08:19:09 <_frederik_> another question: if i want to add a bunch of stuff to X11, should i split it into separate patches, or do it all at once?
08:19:57 <earthy> if it's related, do it at once, if it isn't, split it up
08:20:16 <_frederik_> are XGetVisualInfo and XCreateImage related?
08:20:36 <_frederik_> if not, i just won't bother filling in the visual info functions
08:22:41 * _frederik_ goes to lab
08:24:10 <ndm> roconnor: yes
08:26:11 <ndm> roconnor: sent to the mailing list, the raw data
08:35:51 <malebria> Hello.
08:36:13 <therp> hello
08:36:20 <malebria> statusbarGetContextId returns ContextId, but this type is not exported by any modules in gtk2hs. How can I import it?
08:37:28 <Cale> dcoutts: question for you ^
08:41:55 <Cale> dons: are you about?
08:42:12 <Cale> dons: how do I get the quickcheck lambdabot module to work?
08:42:52 <shapr> @check \x -> complement (-(x :: Int)) == (x - 1)
08:42:53 <lambdabot>  OK, passed 500 tests.
08:43:41 <shapr> Or is that smallcheck?
08:43:49 <Cale> that's quickcheck
08:43:56 <Cale> I run a lambdabot too :)
08:44:06 <shapr> mathbot, yeah?
08:44:11 <Cale> yeah, mbot
08:44:28 <Cale> There seems to be extra code which I need to compile to get the quickcheck bits to run
08:47:26 <glguy> woot, tor for the win
08:47:38 <shapr> Has anyone tried ipv6 + tor?
08:49:13 <pharm>  [ircII]                                                             [OC: 290]
08:49:54 <shapr> pharm: ?
08:50:51 <shapr> Does lambdabot have a jabber interface?
08:53:02 <Dylan> shapr: you can make one by using bitlbee
08:53:09 <Dylan> it's quite easy.
08:53:56 <shapr> Yeah, just wondered if there was a genuine jabber interface.
08:54:13 <Dylan> well, bitlbee is better, as it gets lambdabot on aim, msn, jabber, and yahoo
08:54:38 <shapr> Jabber supports mime messages, encryption and utf-8; irc is limited to 512 chars per message and does not specify a charset.
08:54:48 <Dylan> I know. :-)
08:54:59 <pharm> shapr: ?
08:55:21 <glguy> sweet, tor gives me a 19 seconds ping time to shapr
08:55:31 <Dylan> I started writing an IRC client a few years ago (2 or 3), and this resulted in me inventing my own protocol... finally I'm writing transports for this to jabber and IRC..
08:55:32 <shapr> I'd like to be able to send Haskell source files directly to lambdabot for @plugs
08:56:11 <shapr> pharm: You sent <pharm>  [ircII]                                                             [OC: 290] does that mean you're on an OC290 and I should infer your bandwidth by comparing to an OC3?
08:56:48 * pharm checks back in IRC log
08:56:59 <pharm> oops. Wayward X paste I think.
08:56:59 <Dylan> (the progression was irc (urgh) -> jabber (eeew) -> silc (EEEK!)...
08:57:10 <shapr> Silc has some good points.
08:57:35 <Dylan> indeed. I don't like it not using something standardish like SSL (granted, it predates SSL)
08:58:17 <Dylan> it's just been easier to define my own protocol then implement any of the existing ones.
08:58:39 <Dylan> there's nothing else elegant as http for chat-type stuff.
08:58:53 <Dylan> (err, nothing of comparable elegance)
08:59:11 <norpan> the irc protocol is terrible
08:59:16 <Dylan> indeed.
08:59:36 <norpan> the server-to-server stuff is good
08:59:41 <norpan> but not the client-to-server
08:59:46 <lambdabot> Local time for glguy is Wed Nov 01 10:59:19 2006
09:00:18 <xerox> shapr: you know what, we could just have lambdabot read lisppastes!
09:00:18 <glguy> I'm doing a really lousy job at hiding my local endpoint :)
09:00:24 <glguy> oh, and my identity
09:00:53 <Dylan> my protocol is just a tab delimited thng, e.g. "CMD\targ1\targ2", with an (optional) escape mechanism.
09:02:17 <araujo> hello!
09:02:27 <shapr> hola
09:02:55 <araujo> ¡hola shapr!
09:04:24 <Bourbaki> moin
09:04:27 <Bourbaki> dons you there?
09:08:06 <Rene> I am attempting to compile HDBC-sqlite3. How do I get cabal to use the sqlite3.dll?
09:09:35 <blsecres> Rene: sqlite3.dll needs to either be in your %PATH% or in the current directory...at least that worked for me under mingw32
09:11:26 <earthy> damn... didn't point to the correct readline
09:11:30 <earthy> redo from start.
09:11:48 <Rene> I get ld.exe: cannot find -lsqlite3
09:13:34 <Rene> (That is when I do runghc Setup.lhs build)
09:14:24 <blsecres> Rene: I copied sqlite3.dll and sqlite3.def to /mingw/lib and ld found them, I'm not sure if ghc's ld reads LDFLAGS but that may need -L set
09:16:55 <Rene> Yes, that fixed it.
09:20:45 <Taral> @pl
09:20:45 <lambdabot> (line 1, column 1):
09:20:45 <lambdabot> unexpected end of input
09:20:45 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
09:24:29 <theoco> lambdabot: (1+1)
09:24:42 <beelsebob> >1+1
09:24:45 <beelsebob> > 1+1
09:24:48 <lambdabot>  2
09:24:50 <glguy> > 1+1
09:24:51 <lambdabot>  2
09:25:26 <theoco> > show(read "1" + read "1")
09:25:27 <lambdabot>  "2"
09:26:21 <glguy> ?version
09:26:21 <lambdabot> lambdabot 4p255, GHC 6.5 (OpenBSD i386)
09:26:21 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
09:27:21 <beelsebob> ?vixen do you fancy glguy?
09:27:21 <lambdabot> i do occassionally, i guess
09:27:42 <beelsebob> boring!
09:28:07 <beelsebob> @vixen do you fancy glguy?
09:28:07 <lambdabot> i do occassionally, i guess
09:35:06 <Taral> topic = "comp.lang.haskell" : topic
09:35:17 <xerox> Ehrm?
09:37:07 <bringert> > let topic = "comp.lang.haskell" : topic in topic
09:37:08 <lambdabot>  ["comp.lang.haskell","comp.lang.haskell","comp.lang.haskell","comp.lang.hask...
09:46:41 <int-e> @where stm
09:46:41 <lambdabot> http://research.microsoft.com/Users/simonpj/papers/stm/
09:49:09 <emu> bringert: i made good progress using snippets of code from your library
10:02:01 <glguy> "Lovecraft is, of course, interpreted. And, most importantly, in the past tense."
10:07:12 <arjanoosting> ifvoid: thanks!
10:08:22 * lispy <- bed; return $ headToWork lispy
10:08:38 <lispy> oh and hi!
10:21:23 <malebria> I had a connection problem.
10:21:35 <malebria> dcoutts: Have you seen my question?
10:24:42 <fourbissime> Hello there. Big haskell newbie speaking. i'd like to manipulate fixed size arrays of bits - things like doing XOR and such. but i'm a bit lost ... anyone has a tip ?
10:25:10 <Binkley> what are you trying to do?
10:25:18 <malebria> fourbissime: with [Bool] ?
10:25:55 <glguy> fourbissime: Have you looked at Data.Bits?
10:25:56 <Binkley> look at Data.Bits, maybe
10:26:16 <fourbissime> okay.
10:26:53 <scodil> speaking of arrays... why is it so hard to find an array sorting function? google gives me nothing
10:27:12 <theoco> scodil: qsort
10:27:18 <fourbissime> right now i'm struggling to understand how modules work ... so maybe i'll check this out later !
10:28:00 <scodil> theoco: in haskell?
10:28:26 <theoco> scodil: you have to write it
10:29:01 <scodil> yeah, so I sat down to do that, and I came across a strange problem: there is no inverse of the 'index' function for the Ix class
10:30:40 <scodil> so if you have some bounds, you can't find the midpoint to split at. at least, not in general. for Ints its no big deal, but for other types of indexes (tuples) you can't do it in an abstract way
10:31:01 <wolverian> was there recently a new paper on darcs patches theory?
10:31:40 <scodil> the Ix class defines the 'index' function to get an Int from an Ix, but you can't use that Int to access the array unless the Ix class of the array is itself Int. which defeats the purpose of having an Ix class.
10:32:11 <malebria> dcoutts_: are you there?
10:32:29 <scodil> why is this? is it just that people don't use arrays to write compilers, and therefor haskell has pisspoor arrays?
10:32:58 <wolverian> nevermind, there wasn't - found what I wanted.
10:33:02 <Binkley> I don't know about "people" in general, but GHC doesn't make much use of arrays
10:34:40 <scodil> i figured as much. Am I making any sense about this index thing?
10:35:01 <fasta> scodil: You did extensive benchmarking and found out GHC has "pisspoor arrays"?
10:35:01 <scodil> is this the reason that there is no haskell array sorting function anywhere on the internets?
10:35:15 <Binkley> what are you using arrays for?
10:35:32 <fasta> scodil: you smell like a troll.
10:35:39 <scodil> stuff i should probably be using a different language for, but thats not the issue.
10:35:45 <scodil> oh shutup i love haskell
10:36:04 <fasta> scodil: then tell me my GHC has "pisspoor arrays".
10:36:06 <Binkley> I don't endorse the idea that GHC has pisspoor *anything*, however, normally there are more natural ways to express things in Haskell than arrays
10:36:11 <fasta> er why
10:36:14 <scodil> i'm just a little confused about the Array and Ix classes.
10:36:16 <Cale> scodil: uh, why should you be able to get the midpoint? You can't even properly get that with Ints
10:36:32 <fasta> scodil: that's something different.
10:36:45 <fasta> scodil: you can claim that you have a pisspoor understanding of how it works.
10:36:46 <scodil> picking a pivot for quicksort, or finding the parent in heapsort
10:36:53 <Cale> rangeSize (l,u) == length (range (l,u))
10:36:54 <Binkley> well, it doesn't really make sense to be able to take the midpoint of two Ix-es, in general
10:36:57 <Binkley> an Ix could be anything
10:37:07 <Cale> If that's what you're looking for
10:37:45 <scodil> Cale: right I can map from by two Ix'es to Ints, do arithmetic with those ints, but then how do I use those ints to get into the array?
10:37:58 <scodil> there's no inverseIndex
10:38:26 <scodil> I should hope it's meant to be a bijection between Ixes and Ints, so why not define the inverse in the Ix class?
10:38:54 <glguy> If you want to treat the index as an Int, why not index the array with an Int?
10:39:23 <scodil> yeah I know, and thats why I'm doing, but if I sit down to write an array sorting function I'm going to try to make it as general as possible
10:39:32 <scodil> and when I did that I ran into this issue
10:39:43 <Binkley> if you read the documentation for Data.Ix, that lists the only properties you're allowed to assume about Ix-es; so tell me how you would write an inverseIndex function that doesn't make any other assumptions
10:40:03 <Animosity> does haskell have a class/function that works like strtok in c?
10:40:10 <fasta> scodil: you can invent your own typeclass if you think that helps and send it to libraries@haskell.org to convince other people to "fix" anything.
10:40:50 <Binkley> animosity: check out parser combinators
10:40:58 <fasta> Gaim for IRC!?!?! Does that work?
10:41:03 <Binkley> they're like strtok on steroids :-)
10:41:05 <scodil> Binkley: inverseIndex bounds i = take (rangeSize `div` 2) (range bounds)
10:41:07 <Cale> fasta: yes, poorly
10:41:10 <scodil> er, wait..
10:41:19 * glguy is using Trillian right now, out of necessity
10:41:22 <fasta> Cale: yes, well, I knew it existed, but I didn't know of users ;)
10:41:23 <scodil> Binkley: inverseIndex bounds i = (range bounds) !! (rangeSize `div` 2)
10:41:26 <glguy> ?type lex
10:41:27 <lambdabot> ReadS String
10:41:47 <Cale> glguy: necessity?
10:42:35 <Cale> scodil: perhaps you'd like the index type to be an instance of Enum?
10:42:49 <glguy> Cale: maybe not the right way to use the word
10:43:15 <Cale> glguy: X-Chat runs under windows :)
10:43:19 <glguy> I don't have any other options,atm
10:43:29 <glguy> Cale: like I said
10:43:32 <glguy> :)
10:43:37 <Binkley> scodil: are you sure that's what you mean?
10:44:56 <glguy> > (\s -> [(a,b,c,v) | (a,t) <- lex s, (b,u) <- lex t, (c,v) <- lex u]) "here's a test"
10:44:56 <Philippa> scodil: you should be able to make it work for a significant range of types in Ix, you'll just need an additional constraint
10:44:57 <lambdabot>  [("here's","a","test","")]
10:45:05 <Cale> Binkley: I think he means inverseIndex bounds i = (range bounds) !! i
10:45:08 <Animosity> for parser combinators do i need anything like tcl or such?
10:45:13 <Philippa> deal with it, your complaint is actually that GHC supports more power than you want to deal with
10:45:19 <scodil> oh right. yeah
10:45:26 <scodil> i was still thinking of the mid point
10:45:36 <scodil> for sorting
10:45:48 <Cale> Philippa: actually it is always invertible, so it would be nice if instances would provide those inverses
10:46:05 <Cale> (but harder on the instances)
10:46:09 <Binkley> Animosity: no, it's a Haskell library
10:46:19 <Animosity> thank you
10:46:31 <scodil> so whats an example of an Ix that isn't an Enum?
10:46:34 <Cale> http://www.cs.uu.nl/~daan/download/parsec/parsec.html
10:46:36 <lambdabot> http://tinyurl.com/syalv
10:46:52 <Cale> (Int, Int)
10:47:11 <Cale> Animosity: that link is for you :)
10:47:34 <Cale> Animosity: Parsec is included with GHC, it's in Text.ParserCombinators.Parsec
10:48:55 <Animosity> Cale thanks
10:49:12 <Binkley> scodil: for an example, see the documentation page for Data.Ix
10:49:17 <Binkley> the Colour datatype at the end
10:49:30 <Cale> Animosity: if you're just looking to break things into words or lines, there's 'words' and 'lines' in the Haskell prelude
10:49:55 <scodil> is there some undocumented array function, like unsafeRead, that lets you index an array using an Int instead of an Ix? That is the point of the Ix class after all, right? Mapping to Ints for purposes of indexing...right?
10:49:59 <glguy> Ix not being invertible allows you to export an instances of Ix without exporting its constructors and not allowing you to abuse Ix to get around the lack of constructors :)
10:50:06 <Cale> Animosity: It's also not so hard to write a more general version of that sort of thing using the list library, but I don't think anyone has bothered to actually add one.
10:50:53 <Binkley> scodil: if you wanted that, why not just use an array indexed on ints?
10:50:54 <Cale> glguy: well, what is exported is enough to invert the map, just not enough to do it efficiently
10:52:12 <scodil> Binkley: yeah thats what I'm going to do. I just wanted to make as few assumptions as possible. I think Cale got it right when he said I'm looking for Ix to imply Enum. Which is the case for the Colour example you pointed me to
10:52:42 <Philippa> gtg
10:53:25 <Binkley> just use bubblesort instead ;-)
10:53:30 <scodil> hah.
10:53:41 <scodil> or just sort elems
10:54:15 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Char.html#t%3AGeneralCategory -- this is new
10:54:17 <lambdabot> http://tinyurl.com/y94u22
10:54:22 <Cale> (I think)
10:54:33 <Binkley> well, yes, but again, that would raise the question of why you're using arrays in the first place :-)
10:55:04 <scodil> why are people here so hostile to arrays? you want me to store my 1000x1000 image as a list of lists?
10:55:09 <Cale> I don't tend to think of arrays as something that you'd normally want to sort.
10:55:30 <Cale> No, for a 1000x1000 image, sure, use an array
10:55:40 <Cale> I have no idea why you'd want to sort it though :)
10:55:56 <scodil> since you must know, i'm sorting an array of indices into another array, for the purposes of watershed transform
10:56:11 <scodil> the array-to-be-sorted is indexed by Ints, yes
10:56:21 <Cale> Why is the array of indices an array?
10:56:28 <scodil> so my issue about Ix inversion is not really an issue
10:57:04 <Binkley> because arrays are a sledgehammer
10:57:28 <Cale> Sometimes you'd be better off with a finite map or a list.
10:57:31 <scodil> how else would you tear out a wall?
10:57:44 <Cale> Lists are really good for iteration over.
10:57:44 <scodil> you say sledgehammer like its a bad thing
10:57:49 <Binkley> well, you should be sure you really want to tear it down first :-)
10:58:05 <scodil> I thought we agreed I did. 1000x1000 image and whatnot
10:58:10 <astrolabe> arrays are fine if you have something that is naturally indexed in n-dimensions, or that you want random access for.
10:58:14 <astrolabe> surely
10:58:22 <Cale> scodil: you have a 1000x1000 image of indices into another array?
10:58:22 <Binkley> yes, but the question still remains of why you use an array to store the array of indices
10:58:37 <Binkley> we agreed that an array is fine for a 1000x1000 image, and that you don't need to sort an image
10:58:50 <scodil> Cale: no I have a 1000^2 array of (Int,Int)s which index the image
10:59:38 <scodil> ok ok ok so when I write my sort function it has to be (Enum i, Ix i, MArray a) => ....
10:59:58 <Binkley> sure
11:00:03 <Binkley> a few type constraints never hurt anyone
11:00:46 <scodil> I just think its a little strange that Ix implies enum (via the !! operator) yet its not made explicit in the class heirarchy
11:00:58 <scodil> and its not at all efficient
11:02:40 <scodil> whats the story with 'deriving'?  Is that an under-the-hood thing or can I make my own classes derivable?
11:02:49 <fasta> scodil: under the hood
11:03:10 <fasta> scodil: with some tools you can hack up something though
11:03:26 <Binkley> scodil: see http://www.seas.upenn.edu/~sweirich/RepLib/haskell08-weirich.pdf
11:03:28 <lambdabot> http://tinyurl.com/ymrnlz
11:03:44 <scodil> thanks
11:04:40 <Binkley> well, if you were concerned about efficiency, you wouldn't be indexing into the array with a non-int type
11:05:25 <scodil> no not that kind of efficiency. big-O efficiency. constant-time versus linear-in-the-array-bounds
11:07:12 <scodil> and why shouldn't I use array's with tuple indicies? is it really that much slower?
11:07:34 <Cale> scodil: Well, Ix doesn't imply Enum
11:07:44 <Binkley> well, you would need to convert the tuple to an int every time you index the array
11:07:51 <Cale> scodil: Ix only implies that subranges of the type are enumerable
11:07:57 <Binkley> it's not that it's all that slow, but if you're concerned enough about performance to use arrays...
11:08:51 <fasta> scodil: it's rather pointless to talk about performance. Just code it and see whether it's fast enough.
11:08:54 <Cale> The index of (5,5) in the range ((0,0),(10,10)) is much different from the index of it in ((0,0),(20,10))
11:09:08 <scodil> Binkley: again I think we're not using performance/efficiency in the same way. Constant time lookup is all I care about. The only other container I could use would be a HashTable. Unless i'm forgetting something
11:09:25 <Cale> Arrays aren't always better than lists
11:10:14 <Binkley> you can use a Data.Map and then you wouldn't have to put your hash-table-using code in the IO monad
11:10:30 <astrolabe> but for random access in big structures, ! is much better than !!
11:10:41 <Cale> Oh certainly
11:10:55 <scodil> ah forget it. I'm just going to use Storables and malloc. That's all I really want anyways.
11:11:07 <Cale> If you just need sequential access though, I think lists would be preferred in most cases.
11:11:18 <fasta> malloc?
11:11:19 <Cale> scodil: What is this set of indices which you've picked out?
11:11:30 <Cale> How large is it?
11:11:48 <Cale> as large as the original image?
11:11:53 <scodil> yeah
11:12:05 <scodil> the algorithm involves visiting every pixel, in order of their brightness
11:13:04 <Cale> ah, okay. So you could sort the list of indices by their lookup in the image.
11:13:18 <scodil> yeah
11:13:42 <scodil> so if it was a List, then that list would need to exist in its entirety in memory, in order to be sorted, right?
11:14:05 <astrolabe> yes
11:14:06 <Binkley> maybe I'm missing something -- how would the same thing not hold for an array?
11:14:22 <Cale> yeah, that's true, but the same is true of an array
11:14:24 <scodil> you're right. the same would be true for an array
11:14:51 <scodil> but, if i'm not mistaken, the allure of lazy lists is that they usually don't really ever get fully contructured
11:14:56 <scodil> they're more like iterators
11:15:00 <scodil> which is why they're so fast
11:15:16 <Cale> actually, all that would get fully constructed is the list indices arr
11:15:20 <astrolabe> Difficult to see how you could sort something without constructing it.
11:15:27 <Cale> the sorted list might not be fully constructed
11:16:01 <Cale> In fact, the sort algorithm will only take O(n) time to generate the first element.
11:16:08 <astrolabe> Lazy lists can be good if you just want the first few sorted elements.  It might not bother with a full sort.
11:16:15 <astrolabe> Cale: :)
11:16:19 <dcoutts> depends on the sorting algorithm
11:16:26 <dcoutts> eg heap sort would be good
11:16:30 * xerox astrolabes astrolabe
11:16:35 <astrolabe> ow
11:16:57 <astrolabe> quick sort too
11:17:03 <dcoutts> it'd cost (n + m*log n) for the first m of n elements I think
11:17:08 <Cale> I think the sort in Data.List does this, doesn't it?
11:17:43 <Binkley> to quote my former advisor, "quicksorting infinite lists isn't very useful" :-)
11:17:49 <Cale> anyway, that's what I'd try first, and only if that really didn't work, would I switch to using an array.
11:17:54 <astrolabe> What if you want a sort where you can get the first few and the last few efficiently?
11:18:19 <Binkley> astrolabe: how would you determine the smallest element without looking at the entire list?
11:18:27 <Cale> astrolabe: you could implement a quicksort in terms of Data.Sequence
11:18:32 <astrolabe> Binkley you can't
11:18:44 <Cale> Binkley: by "quickly", we mean O(n) time
11:18:55 <Binkley> well, then you don't want to do a sort at all
11:18:56 <Binkley> you want a select
11:18:59 <astrolabe> But looking at the entire list is O(n),  sorting is O(nlogn)
11:18:59 <Binkley> it's a different algorithm
11:19:07 <Binkley> laziness doesn't revise your algorithms for you :-)
11:19:09 <Cale> Binkley: no, quicksort in Haskell works
11:19:15 <Cale> It actually does :)
11:19:24 <Binkley> Cale: yes, but not on infinite lists :-)
11:19:30 <Cale> Though yes, there's still a constant factor
11:19:39 <Cale> Well, O(n) where n is infinity
11:19:41 <Cale> heh
11:19:46 <fasta> > head $ sort [1..]
11:19:50 <lambdabot> Terminated
11:19:50 <Cale> Nobody is proposing to sort infinite lists
11:20:02 <Binkley> well, infinite lists are the only case where laziness makes a difference
11:20:08 <Cale> Just to get O(n) time for the head of a sorted list.
11:20:12 <Cale> no
11:20:12 * glguy proposes a sort algorithm for infinite lists
11:20:18 <fasta> > head $ sort [1..1000000]
11:20:20 <Cale> you're missing out :)
11:20:21 <lambdabot>  1
11:20:22 <Binkley> glguy, sounds like something for the Journal of Irreproducible Results
11:20:30 <Cale> Infinite lists aren't the only case laziness changes things
11:20:46 <Cale> any (isPrefixOf x) (tails y)
11:20:51 <Cale> What's the complexity of that?
11:21:07 <Binkley> Cale: which quicksort are you talking about here?
11:21:12 <Cale> Binkley: the usual one
11:21:16 <glguy> O(m*n)
11:21:18 <Binkley> well, ok, I'm talking about changing semantics rather than changing complexity
11:21:20 <Cale> glguy: right :)
11:21:54 <Cale> qsort [] = []; qsort (x:xs) = less ++ x : greater where (less,greater) = partition (<x) xs
11:22:00 <Binkley> Cale: I thought you were saying "quicksort in Haskell returns the first element in O(n) time"
11:22:04 <Binkley> but, *which* quicksort in Haskell?
11:22:09 <Cale> That one right there :)
11:22:12 * glguy reminds everyone that he is experiencing 5 second tor lag :)
11:22:27 <dolio> There's only one quicksort.
11:22:28 <glguy> Binkley: nope, merge sort does
11:23:14 <astrolabe> True quicksort is an 'in-place' algorithm though ;)
11:23:31 <Cale> astrolabe: that's a job for the compiler to work on :)
11:23:45 <Binkley> Cale: you mean qsort [] = []; qsort (x:xs) = (qsort less) ++ [x ++ (qsort
11:23:45 <dolio> Not necessarily. It's about how you partition at each step.
11:23:47 <Binkley> oops sorry
11:23:50 <Cale> Binkley: yeah
11:23:59 <Cale> qsort [] = []; qsort (x:xs) = qsort less ++ x : qsort greater where (less,greater) = partition (<x) xs
11:23:59 <Binkley> well ,you see my point
11:24:02 <Binkley> yeah
11:24:31 <Cale> That'll take O(n) time to locate the head of the list.
11:24:45 <dolio> Quicksort is "partition via the pivot, subsort, append."
11:25:18 <astrolabe> I guess O(n log m) for the first m elements.
11:25:19 <dolio> Mergesort is "divide in half, subsort, merge".
11:25:38 <Binkley> I'm willing to believe that's true. Too low on blood sugar to analyze algorithms atm :-)
11:25:44 <Binkley> I forget what the original question we were debating was, though
11:26:06 <dolio> And heapsort is... "stick into a heap, pull out of a heap." :)
11:26:11 <Cale> Binkley: whether lazy evaluation in a quicksort algorithm is enough to get the head in O(n)
11:26:14 <fasta> Cale: to take the first half of the elements will result in O(n log n) however.
11:26:16 <scodil> you were all telling me what my problem is
11:26:26 <Cale> fasta: yes
11:26:28 <fasta> scodil: next time you should do that
11:26:44 <scodil> do what?
11:26:59 <Binkley> ah, yes, well.
11:27:01 <fasta> scodil: telling us what your problem is in an understandable way.
11:27:07 <Binkley> I still say that if you want the head, you should use select rather than sort
11:27:09 <Binkley> but I see the point
11:27:14 <fasta> scodil: you make us guess what you want
11:27:28 <Cale> Yeah, you should, but if you want more than that, it can be handy.
11:27:41 <scodil> what? no way. I said "i want x" and you all say "you don't want x you want y. y is better"
11:27:52 <Binkley> well, if you want a constant number of elements, just use a select. that's O(n) still
11:28:01 <astrolabe> y is better.  It is unarguable.
11:28:15 <scodil> aparently so
11:28:16 <xerox> I suppose asking for the first n sorted element of an infinite list really reduces to (sort .) . take and nothing more complex.
11:28:29 <glguy> scodil: People who phrase their questions poorly tend to be people who don't know what it was that they really wanted
11:28:35 <Cale> xerox: you can't sort an infinite list
11:28:44 <glguy> so I imagine that they assumed that
11:28:47 <Binkley> using a particular programming language isn't just about syntax, it's about learning to think in that language
11:28:56 <Binkley> so, people are more interested in helping with the latter than the former
11:29:21 <Cale> I tend to think of lists as loops which haven't happened yet.
11:29:27 <xerox> Cale, I was at first attempting to write some partial evaluation that sorted the first known n elements that you asked for, lazily
11:29:38 <Cale> If I want to translate things into control flow, that is.
11:29:47 <xerox> But then I realized that (sort .) . take is really the best one can do.
11:30:23 <Cale> xerox: I agree, at the very least it's asymptotically equivalent to that.
11:31:17 <Cale> Using a custom select which selects n elements is probably more trouble to write than it's worth. A custom minimum finder however is good in the case that you only want 1.
11:31:35 <Binkley> no, I mean if you want a fixed number of elements, call select n times
11:31:44 <Binkley> and if you want an arbitrary number of elements, use sort
11:31:44 <Cale> Especially as it's just  foldl1' min
11:31:53 <astrolabe> Binkley that is O(n m)
11:31:55 <Cale> Binkley: that's probably worse than using sort
11:32:05 <Binkley> astrolabe: if m is constant, that's still O(n)
11:32:07 <Cale> Binkley: because of the much higher constant factor
11:32:14 <xerox> Cale, what's select?
11:32:15 <Binkley> Cale: like I said, if you want a constant number of elements.
11:32:24 <glguy> What is this /select/ business you people keep talking about
11:32:27 <Cale> Binkley: I'm saying just take n . sort
11:32:31 <astrolabe> Binkley what if the constant is 10^5?
11:32:39 <xerox> Cale that doesn't work
11:32:49 <Cale> glguy: a function which finds the minimum element and returns the remainder of the list
11:33:02 <Binkley> astrolabe: then I'd advocate sorting the list
11:33:10 <glguy> the time you spend reconstructing the list alone would kill you
11:33:13 <glguy> no?
11:33:15 <Cale> yes
11:33:21 <Binkley> anything other than 1, 2 or infinity isn't a constant ;-)
11:33:30 <scodil> why does (maximum xs) blow up my stack? (foldl max (head xs) xs) does too. I had to write my own recursive thing with an accumulator. Why is that?
11:33:46 <Binkley> scodil: how big a stack are you using and how big is your list?
11:33:52 <Binkley> and are you compiling with -O?
11:33:52 <Cale> Binkley: I think that even if you just want 5 elements, then selecting repeatedly will be worse than lazily sorting
11:33:54 <glguy> Cale, so it's like a partial select /sort/?
11:33:59 <glguy> Cale instead of a partial merge sort?
11:34:09 <astrolabe> Binkley, well, if you meant find the smallest 2 elements, then I agree to select twice, or even write a special routine.
11:34:12 <scodil> you should know that by now :) its (elems array) where array is my big ol array
11:34:15 <Binkley> Cale: I don't know. I would actually have to analyze the algorithm and try it on some benchmarks in order to know.
11:34:24 * glguy guesses that minimum doesn't use foldl1'
11:34:25 <scodil> and yes I am using -O
11:34:32 <Binkley> scodil: I don't know how big a stack you're using, due to my lack of mind-reading abilities :-)
11:34:41 <shapr> Has anyone used lambdabot via jabber directly? The config file mentions jabber a few times, but functions like jabberSignOn are "undefined". Does that mean this is code to be completed in the future?
11:34:52 <Cale> scodil: try foldl'
11:34:58 <Cale> scodil: It's in Data.List
11:35:07 <glguy> > minimum [1..1000000]
11:35:08 <lambdabot>  1
11:35:16 <glguy> > foldl1' min [1..1000000]
11:35:17 <lambdabot>  1
11:35:33 <Cale> > minimum [1..10000000]
11:35:36 <lambdabot>  1
11:35:39 <Cale> > minimum [1..100000000]
11:35:40 <glguy> I guess 1000000 wasn't the best test case
11:35:42 <lambdabot> Terminated
11:35:51 <glguy> ?fptools minimum
11:35:52 <lambdabot> minimum not available
11:36:16 <astrolabe> >maximum [1..1000000]
11:36:26 <astrolabe> > maximum [1..1000000]
11:36:28 <lambdabot>  1000000
11:36:52 <roconnor> ?fptools Data.List.minimum
11:36:52 <lambdabot> Data.List.minimum not available
11:36:53 <glguy> hugs defines minimum with foldl1
11:37:02 <roconnor> ?fptools Prelude.minimum
11:37:03 <lambdabot> Prelude.minimum not available
11:37:09 <roconnor> ?fptools Data.List
11:37:10 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
11:37:11 <astrolabe> computers are so fast these days that I can't tell how fast they should be.
11:37:14 <Binkley> scodil: try strictMaximum
11:37:28 <fasta> glguy: you should read an algorithms book to understand it
11:37:31 <astrolabe> maximum shouldn't blow up the stack.
11:37:41 <roconnor> minimum xs              =  foldl1 min xs
11:38:00 <Binkley> actually, though, for a list of ints, maximum should be rewritten to strictMaximum
11:38:02 <glguy> fasta: to understand what?
11:38:02 <roconnor> ... but minimum works on Ord
11:38:03 <fasta> glguy: Introduction to Algorithms, 2nd edition covers it.
11:38:04 <astrolabe> ooops.  It does on mine though.
11:38:08 <fasta> glguy: selection
11:38:14 <astrolabe> with hugs at least.
11:38:41 <Binkley> roconnor: yes, but in general you can't replace maximum and minimum with their strict versions
11:38:58 <glguy> fasta: umm, I think I've got a pretty good grasp already
11:39:12 <astrolabe> maximum = foldl1 max
11:39:25 <roconnor> sum                     =  foldl (+) 0
11:39:41 <roconnor> > sum [1..10000000] : Int
11:39:42 <lambdabot>  Not in scope: data constructor `Int'
11:39:43 <fasta> glguy: ok, so you know how you can generalize maximum to give an index such that it still works in O(n)?
11:39:46 <roconnor> > sum [1..10000000] :: Int
11:39:50 <lambdabot> Terminated
11:40:05 <roconnor> > sum [1..100000000] :: Int
11:40:09 <lambdabot> Terminated
11:40:22 <roconnor> why is there no stack overflow?
11:40:52 <Heffalump> roconnor: isn't sum foldl' (+) 0?
11:40:59 <int-e> > sum [1..1000000000000] :: Int
11:41:00 <lambdabot>  0
11:41:03 <fasta> glguy: ?
11:41:05 <Binkley> heh
11:41:13 <Binkley> > sum [1..10000000000000]::Integer
11:41:14 <roconnor> Heffalump: it doesn't seem that way
11:41:17 <lambdabot> Terminated
11:41:21 <roconnor> sum                     =  foldl (+) 0
11:41:31 <Binkley> sum          = foldl1' (+) 0
11:41:36 <glguy> fasta: maximum runs in O(n), right, but I'm not sure which generalization you are trying to ask for
11:41:38 <Binkley> > sum [1..100000000]::Int
11:41:41 <lambdabot> Terminated
11:41:56 <roconnor> Binkley: http://darcs.haskell.org/packages/base/Data/List.hs
11:41:59 <lambdabot> http://tinyurl.com/ydwlev
11:42:17 <Binkley> yes, that's what I'm looking at
11:42:19 <roconnor> well, #ifdef USE_REPORT_PRELUDE
11:42:39 <Binkley> Well, who would ever define that? ;-)
11:42:43 <dcoutts> it's still not strict in the accumulated value
11:43:06 <int-e> and arguably it can never be made strict
11:43:12 <dcoutts> indeed
11:43:17 <fasta> glguy: suppose you have my_list = sort [1..100000]. Then you want to have the value list !! 9000. You can get list!!9000 more efficient than first sorting it.
11:43:25 <int-e> because someone may have a weird lazy Num instance out there that will stop working then
11:43:28 <dcoutts> only for specialised versions where you know the concrete type
11:43:38 <Heffalump> int-e: good point
11:43:42 <fasta> > !! [1,2,3] 1
11:43:43 <lambdabot>  Parse error
11:43:45 <int-e> maybe  sum'  could be added though
11:43:47 <dcoutts> {-# SPECIALISE sum     :: [Int] -> Int #-}
11:43:50 <fasta> > [1,2,3] !! 1
11:43:51 <lambdabot>  2
11:43:51 <shapr> dons: I looked into running lambdabot via jabber... jabberSignOn is undefined, does that mean lambdabot over jabber doesn't work yet?
11:43:57 <glguy> fasta: the point is that in haskell with lazy evaluation, that sort will not sort he whole list
11:44:35 <Heffalump> roconnor: note the specialisations for Int and Integer
11:44:42 <int-e> fasta: sort [list of length n] !! k  is  O(n + log(n)*k)
11:44:43 <Heffalump> the compiler might be strictifying those
11:44:50 <dcoutts> Heffalump, but it doesn't seem to strictify them
11:45:08 <roconnor> Ah
11:45:10 <int-e> fasta: at least with the merge sort that ghc uses.
11:45:18 <int-e> fasta: or rather, Data.List
11:45:19 <roconnor> Heffalump: what if we do the same for min and max?
11:45:23 <dcoutts> or maybe it needs -O
11:45:32 <int-e> fasta: and it doesn't get better than that.
11:45:37 <dcoutts> since iirc SPECIALISE is implemented as rules
11:45:41 <fasta> glguy: The point is that that is larger than O(n).
11:45:46 <Binkley> roconnor: that's exactly what it does
11:45:47 <fasta> int-e: I know
11:46:47 <roconnor> ah, strict maximum
11:47:06 <int-e> oh, there's an O(n) algorithm for finding the median of a list, right?
11:47:13 <fasta> int-e: right
11:47:22 <fasta> int-e: but not only for the median
11:47:30 * shapr can find the curb too!
11:47:32 <fasta> int-e: for any index
11:47:40 * Heffalump can never remember that algorithm
11:47:57 <int-e> fasta: sure, you can construct that from the median (although I suspect there are faster ways)
11:48:04 <scodil> its like quicksort but you only go down one half of the recursion
11:48:04 <fasta> int-e: now you can convince glguy
11:49:04 <int-e> it's quite easy to see that there's a probabilistic algorithm with expected linear run time.
11:49:32 <scodil> quite easy. its obvious even
11:49:40 <Binkley> "obvious"
11:50:11 <int-e> glguy: http://en.wikipedia.org/wiki/Selection_algorithm
11:50:12 <glguy> median element is easy to find in one pass, sure
11:50:14 <lambdabot> http://tinyurl.com/apfno
11:50:23 <glguy> so how do we expand that to arbitrary
11:51:40 <int-e> simple, by bisection
11:52:02 <glguy> from wikipedia:  we can achieve the same time just by running the first k iterations of selection sort. If log n is much less than k, a better simple strategy is to sort the list and then take the first or last k elements.
11:52:16 <int-e> if median has runtime M(n), you get M(n) + M(n/2) + M(n/4) + ... < 2 M(n) + O(log(n)) = O(n)
11:52:37 <glguy> [13:33] glguy: Cale, so it's like a partial select /sort/?
11:52:55 <int-e> glguy: the point is that this argument is only valid for constant k (while n varies)
11:53:32 <glguy> sure
11:54:34 <glguy> from wikipedia: More efficient than any of these are specialized partial sorting algorithms based on mergesort and quicksort.
11:55:30 <int-e> headline: Selecting k smallest or largest elements
11:55:42 <int-e> we were only interested in the k-th one.
11:56:17 <int-e> at least that's what I thought.
11:57:01 <Agaths> > 5 / length [1,2]
11:57:02 <lambdabot>  add an instance declaration for (Fractional Int)
11:57:02 <lambdabot>   In the definition of `...
11:57:08 <Agaths> hmm
11:57:21 <glguy> headline: nonlinear general selection algorithm
11:57:26 <glguy> quote: This can be seen as an incomplete selection sort.
11:57:26 <glguy> that one?
11:58:04 <Cale> > 5 `div` length [1,2]
11:58:05 <int-e> Linear general selection algorithm - "Median of Medians algorithm" <-- this is the linear (worst case time) selection algorithm
11:58:05 <lambdabot>  2
11:58:15 <Cale> > 5 / fromIntegral (length [1,2])
11:58:16 <lambdabot>  2.5
11:59:59 <dolio> ?fptools Data.List
12:00:00 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
12:01:25 <fasta> > product[0..]
12:01:29 <lambdabot> Terminated
12:01:50 <fasta> This library function can be improved.
12:02:02 <sieni> > product [0,undefined]
12:02:03 <lambdabot>  Undefined
12:02:15 <fasta> Or not
12:02:26 <sieni> bad bottom
12:03:36 <Cale> > product [1,1..]
12:03:40 <lambdabot> Terminated
12:03:59 <Heffalump> clearly the optimiser is stupid ;-)
12:04:06 <Cale> :)
12:04:09 <fasta> sieni: do you know why 0*undefined=undefined (besides that it's just defined in this way)?
12:04:36 <Heffalump> fasta: to make it possible to define (*) directly using machine arithmetic, for one thing.
12:04:46 <Cale> Heffalump: It would be quite handy if it was smart enough to recognise that :)
12:05:01 <Heffalump> Cale: it ought not to turn _|_ into a value, anyway.
12:05:11 <Binkley> where's the -fsolve-halting-problem flag, anyway?
12:05:22 <fasta> Heffalump: there is undefined defined in hardware in IEEE754 (IIRC)?
12:05:33 <Heffalump> fasta: no, that's NaN
12:05:35 <fasta> Binkley: you need hardware support for that
12:05:40 <Heffalump> and it doesn't help with integer arithmetic
12:05:41 <Binkley> heh, good point.#
12:06:20 <fasta> Heffalump: oh, an exception is thrown.
12:06:32 <fasta> hmm, or not.
12:06:41 <fasta> Never mind, I don't know by heart
12:07:24 <fasta> Heffalump: care to elaborate a bit?
12:09:54 <Heffalump> fasta: NaN is a real value you can test for
12:10:07 <Heffalump> undefined is something that you can never test for directly (in pure code)
12:11:01 <fasta> Heffalump: yes, but implementing (*) by the hardware equivalent is not giving you undefined magically.
12:11:18 <fasta> Heffalump: It seems orthogonal from my POV currently.
12:12:20 <fasta> It seems undefined is implemented somewhere in the STG, which in turn is implemented in that small interpreter (for the C backend).
12:13:43 <Heffalump> fasta: you want the compiler to be able to make (*) strict, and thus remove boxing and unboxing wherever possible.
12:16:24 <fasta> case  mul of Mul Undefined _->undefined;Mul _ Undefined ->undefined;Mul a b->(*) a b
12:16:32 <fasta> Something like that needs to be somewhere.
12:17:06 <fasta> So, with or without boxes for efficiency it shouldn't matter.
12:17:14 * shapr hugs Binkley 
12:17:47 <fasta> Hmm, well it needs another test for zero then.
12:18:52 * Binkley hugs shapr
12:22:31 <fasta> Heffalump: still I think it has little to do with choosing the semantics in this way.
12:55:34 <vovik> anyone know how to do a constant time preorder bst traversal?
12:57:48 <fasta> vovik: you mean linear time?
12:58:47 <vovik> fasta: yes
12:58:57 <fasta> vovik: then why didn't you ask that? ;)
12:58:59 <vovik> fasta: linear time, O(n) not constant, sorry
12:59:18 <Botje> vovik: how can you make a preorder traversal NOT O(n) ?
12:59:29 <vovik> Botje: using ++
12:59:46 <fasta> vovik: that has little to do with the traversal
12:59:56 <Botje> what fasta said.
13:00:03 <vovik> fasta: the traversal needs to return a list
13:00:16 <fasta> vovik: so, again your question was ill possed.
13:00:19 <fasta> er posed
13:00:38 <fasta> vovik: homework?
13:00:45 <Botje> vovik: if you do a postorder traversal you can just use (:)
13:00:54 <Botje> and the list will be in the correct order
13:00:55 <vovik> fasta: well honestly what else am i going to do with the treenodes besides put them in a list
13:01:01 <vovik> fasta: sorta, not really
13:01:17 <vovik> botje: yes i realize that, but preorder is needed
13:01:34 <fasta> vovik: there are lots of things you can do with a treenode besides putting them in a list
13:01:59 <Botje> vovik: then just put them all in a list, and reverse the list before you return it?
13:02:02 <vovik> fasta: sure, but this seems like the most basic, except maybe just outputting them, somewhat pointless
13:02:20 <Botje> preorder traversal is O(n), reversal is O(n), so your final process is O(n)
13:02:26 <vovik> botje: reversing a postorder  == preorder?
13:02:31 <dolio> You have function from Tree -> F, where F is a function that appends the pre-order elements to an existing list.
13:02:33 <vovik> btoje: you sure?
13:02:34 <fasta> vovik: if it's not an academic exercise you can do what Botje says.
13:02:41 <dolio> And then at a branch, you compose functions.
13:03:03 <fasta> vovik: if you want more performance a real preorder can be done in the obvious way.
13:03:04 <Botje> vovik: very much so. or you have to invent a data structure that has O(1) append.
13:03:38 <fasta> vovik: and I still wonder about the performance in that case.
13:03:40 <vovik> botje: isn't the : operator O(1) to append?
13:03:53 <fasta> vovik: it is, that's what he's saying
13:04:01 <fasta> or implying
13:04:04 <Botje> : is O(1) to prepend
13:04:10 <Botje> i'm not sure about append.
13:04:24 <Botje> the type seems to imply it's not even possible.
13:04:25 <vovik> ok, so postorder then reversal will work, but i'm curious if there's a more 'elegant' way
13:04:48 <Botje> vovik: no, postorder OR preorder with reversal. if you use the (:) operator
13:05:08 <dolio> elems t = elems' t []
13:05:25 <vovik> ?
13:05:26 <dolio> elems' Leaf = id
13:05:50 <dolio> elems' (Branch a l r) = (a:) . elems' l . elems' r
13:05:53 <vovik> sorry, i'm pretty new to haskell and functional programming in general
13:05:59 <fasta> vovik: you can also use difference lists.
13:06:14 <Botje> vovik: this is not a haskell question, it's a general programming one :)
13:06:17 <fasta> vovik: which amounts to what dolio is doing
13:06:52 <vovik> botje: i could do this in any c style language, i would just pass a list as an argument and append to it
13:07:12 <Botje> vovik: but appends are almost always O(n).
13:07:15 <Botje> esp with linked lists.
13:07:26 <vovik> botje: append using :
13:07:28 <vovik> not  ++
13:07:31 <theoco> why doesn
13:07:38 <Botje> vovik: : only PREpends
13:07:43 <Botje> it can't append
13:07:55 <vovik> right, prepend is what i meant
13:07:58 <theoco> typing "exponent a 1 = 1" work in ghci?
13:08:06 <fasta> vovik: you can use the ST monad if you want
13:08:13 <Botje> theoco: you have to put the definition in a file and load that.
13:08:14 <vovik> fasta: what's that
13:08:16 <fasta> vovik: I don't think that will be easier, though.
13:08:18 <fasta> :P
13:08:30 <vovik> mkay i'd rather do it without using fancy language features
13:08:43 <vovik> just basic recursion and :
13:08:46 <fasta> vovik: it enables you to write C like abstractions in a functional way.
13:09:06 <vovik> fasta: i want to write functional style though :)
13:09:32 <fasta> vovik: well, some algorithms cannot be written in a functional style in an efficient way.
13:09:52 <Botje> vovik: just do [recurse left] ++ [x] ++ [recurse right] then
13:09:56 <vovik> fasta: sure, but it seems like this traversal should work
13:10:02 <Botje> let the compiler worry about the most efficient way to do it.
13:10:10 <vovik> botje: that's O(n^2)
13:10:12 <fasta> Botje: the compiler doesn't that much.
13:10:42 <fasta> Botje: it doesn't even do constant folding for this case: 2^16
13:10:49 <SamB> hmm. Can I get profiling with smaller ticks?
13:10:49 <Botje> that's lame :(
13:11:05 <Cale> hm?
13:11:18 <Cale> What's the question?
13:11:30 <vovik> can i pass as arguments to the traversal function 1 node and 1 list, to which i will prepend?
13:11:32 <fasta> Cale: preorder traversal in O(n) in a functional way
13:11:38 <SamB> Cale: who's question?
13:11:40 <vovik> mine
13:11:46 <vovik> o
13:11:48 <vovik> maybe not
13:12:24 <vovik> i can't seem to even figure out the syntax to pass a list of nodes as a parameter
13:12:30 <Cale> hm?
13:12:35 <Cale> okay
13:14:10 <vovik> anyone know the synax to pass a list of treenodes as a function argument?
13:14:34 <theoco> k, I know scheme but I can't write a haskell program to save my life
13:14:48 <Cale> vovik: just how you'd pass anything as an argument
13:15:03 <Cale> vovik: the syntax is exactly the same as with anything else
13:15:28 <vovik> cale: i've tried what seems like the same thing but it gives me error
13:15:30 <theoco> I have "module test\n\twhere\nfactorial 1 = 1\nfactorial n = n * factorial (n-1)
13:15:34 <theoco> whats wrong with that
13:15:36 <Cale> lisppaste2: url
13:15:36 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
13:15:42 <Cale> vovik: paste your code there
13:15:49 <vovik> cale: ok one sec
13:15:59 <Cale> theoco: module Test
13:16:14 <theoco> Cale: that really makes a difference?
13:16:17 <Cale> theoco: I think modules have to be named with an uppercase letter
13:16:28 <Binkley> SamB: what do you mean?
13:16:39 <Cale> also, if you give a module name, it should be the same as your filename
13:16:50 <Cale> so that the compiler will be able to find it
13:17:05 <SamB> like, it says:
13:17:07 <SamB>         total time  =        2.45 secs   (49 ticks @ 50 ms)
13:17:26 <lisppaste2> vovik pasted "preorder" at http://paste.lisp.org/display/29110
13:17:30 <fasta> Is it possible to define amb in Haskell? I don't think so.
13:17:32 <SamB> what if I want it to tick more often, say every 25 ms?
13:17:34 <vovik> cale: http://paste.lisp.org/display/29110
13:17:42 <Binkley> hmm...
13:18:02 <Binkley> The short answer is "no" but I'm not sure if it's changeable or if it's a hardware-dependent thing
13:18:03 <Botje> fasta: couldn't you abuse a monad fail method?
13:18:22 <Cale> vovik: first of all, your indentation is really strange
13:18:33 <vovik> cale: sorry, i'm new
13:18:48 <vovik> cale: any help on that is appreciated as well :)
13:18:48 <Cale> vovik: it's customary to line up the 'then' and 'else'
13:18:55 <Cale> like
13:18:57 <Cale> if ...
13:18:59 <Cale>    then ...
13:19:02 <Cale>    else ...
13:19:39 <Cale> Now, first oddity is that you're testing if x is Nil
13:19:52 <Cale> x is an element held by the tree here
13:20:01 <fasta> Botje: All the code would need to live inside that monad then, I think.
13:20:07 <Cale> so it would have to be a tree of trees, which I don't think is what you're trying for
13:20:12 <Binkley> hold on, I might have lied just now...
13:20:16 <vovik> cale: right, it's the base case for an empty node, the child of a leaf
13:20:25 <fasta> Botje: which would contradict that it would work thoughout the whole program.
13:20:29 <vovik> cale: hmm, you're right about that
13:20:51 <fasta> Botje: which implies that Haskell amb is not an angelic operator.
13:21:13 <Botje> okay, what's an angelic operator?
13:21:16 <yaxu> hello all
13:21:24 <vovik> cale: btw 'y' is supposed to be the list of nodes i was talking about
13:21:27 <yaxu> i made hugs coredump - is that usual?
13:21:30 <fasta> Botje: google tells you
13:21:37 <Botje> fair enough
13:21:51 <fasta> yaxu: newest release?
13:21:57 <Binkley> SamB: in rts/RtsFlags.c, it looks like you should be able to change the line that sets RtsFlags.MiscFlags.tickInterval to 50
13:22:09 <yaxu> fasta: 20050308
13:22:24 <fasta> yaxu: first step: upgrade
13:22:31 <yaxu> fasta: ok thanks
13:22:45 <fasta> yaxu: second step: install ghci ;)
13:23:11 <glguy> There was a september release of Hugs to coincide with the release of ghc 6.6
13:23:14 <fasta> yaxu: nah, hugs has some useful purposes.
13:23:35 <fasta> One being that it loads code faster than ghci.
13:23:40 <glguy> heh, generating core files
13:23:59 <fasta> Disadvantage of hugs is that it has a rather dump type inferencer.
13:24:19 <fasta> Dumb when compared to the rather smart GHC type inferencer.
13:24:20 <yaxu> fasta: well i'll try it in ghci first
13:25:22 <Cale> vovik: well, what is that list? :)
13:25:42 <vovik> cale: that list is a list of the elements in the tree in a preorder traversal
13:25:59 <vovik> cale: oh and preorder2 should just be preorder sorry
13:27:28 <glguy> heh, "XML is a giant step in no direction at all."
13:28:55 <Cale> vovik: It's possible to write preorder in a functional way so that it's O(n)
13:28:58 <xerox> Sounds like Topology.
13:29:05 <Cale> vovik: the trick is not to use (++)
13:29:22 <vovik> cale: right i understand that the trick is not to use ++ but to use : instead, which is what i'm working on
13:29:34 <Cale> well, really the trick is to use (.)
13:29:44 <vovik> cale: i don't even know what that operator does
13:29:45 <fasta> lamdbabot should shout "difference lists" every ten minutes.
13:29:52 <Cale> vovik: it composes functions
13:29:53 <fasta> vovik: function composition
13:30:00 <vovik> oic.
13:30:01 <Cale> (f . g) x = f (g x)
13:30:13 <vovik> right i know what composition is :)
13:30:21 <Cale> So you work with functions that add to a list rather than lists directly
13:30:40 <vovik> right, right, i thought i had to do it with : though
13:30:47 <Cale> for me, on a sample, the (++) version takes 6.89 seconds where the (.) version takes 0.30
13:30:49 <fasta> vovik: you can also use mappend and write an instance for monoid
13:30:59 <Cale> well, you will use (:)
13:31:11 <vovik> cale: ok so to use : i have to use composition as well?
13:31:43 <fasta> vovik: what else?
13:31:54 <fasta> vovik: anything else won't compile
13:32:08 <Cale> er
13:32:20 <vovik> hmm
13:32:35 <fasta> Cale: are you familiar with amb?
13:33:45 <lisppaste2> Cale pasted "using composition to build lists" at http://paste.lisp.org/display/29112
13:33:57 <Cale> fasta: perhaps
13:34:03 <theoco> Im having trouble with ex 3.8 in daume02yaht.pdf
13:34:24 <theoco> I get this error: not in scope 'mult'
13:34:26 <glguy> Has anyone been particularly impressed by their opensource PDF viewer? xpdf? evince? gv?
13:34:43 <Botje> cat.
13:34:52 <vovik> thanks all
13:34:59 <Binkley> glguy: well, my officemate once said that xpdf renders things about as well as a drunk kindergartener with a crayon
13:35:24 <Cale> theoco: let me find that question
13:35:53 <Cale> theoco: uh, how are you loading your file?
13:36:02 <Cale> theoco: you're supposed to define mult
13:36:14 <theoco> Cale: its in Test.hs, i go ghci Test.hs
13:36:18 <wolverian> evince is nice, gui-wise. I don't know how good libpoppler is at rendering when compared to, say, gv.
13:36:28 <Cale> lisppaste2: url
13:36:28 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
13:36:36 <Cale> theoco: could you paste it there?
13:36:45 <wolverian> (but I haven't had problems with it, besides the fact that I can't edit forms yet.)
13:36:53 <Cale> wolverian: not quite as good
13:37:00 <Cale> wolverian: but it's getting better
13:37:13 <wolverian> Cale, yeah. it seems to have people backing it. :)
13:37:46 <Cale> gv has the advantage that it displays things as it generates them, which for some postscript files is essential
13:38:16 <yaxu> how do i import ParsecLanguage with ghc?  "import ParsecLanguage ( haskellDef )" works in hugs but I'm having trouble working out how to do it in ghc
13:38:21 <yaxu> (ghc 6.4.2)
13:38:26 <theoco> Cale: err sorry, operater error
13:38:33 <theoco> Cale: I fixed it
13:38:35 <SamB> @hoogle Language
13:38:35 <lambdabot> Text.ParserCombinators.Parsec.Language :: module
13:38:35 <lambdabot> Text.ParserCombinators.Parsec.Language.LanguageDef :: String -> String -> String -> Bool -> CharParser st Char -> CharParser st Char -> CharParser st Char -> CharParser st Char -> [String] -> [
13:38:35 <lambdabot> String] -> Bool -> LanguageDef st
13:38:35 <lambdabot> Text.ParserCombinators.Parsec.Language.LanguageDef :: data LanguageDef st
13:38:36 <Cale> I've also had bizarre problems with evince with certain documents that use masking
13:38:40 <Cale> theoco: :)
13:38:48 <SamB> this one: <lambdabot> Text.ParserCombinators.Parsec.Language :: module
13:39:21 <Cale> Certain documents come out with chunky unantialiased lines.
13:39:45 <yaxu> SamB: thanks
13:40:15 <SamB> Binkley: ah, thanks
13:41:09 <therp> hmm.. #ghc is basically dead, is there any other forum where I could discuss my GHC hacking stuff?
13:41:27 <Binkley> therp: this one? :-)
13:41:30 <Cale> well, there's here :)
13:41:31 <shapr> shock!
13:41:34 <Binkley> omfg
13:41:48 <yaxu> well i'm overflowing ghci's stack, a bit better than dumping hugs's core i guess
13:41:58 <Binkley> yaxu, how big is your stack?
13:42:05 <Cale> probably 8M
13:42:34 <yaxu> i'll be doing something stupid, i just have to work out where
13:42:35 <Cale> yaxu: are you doing something tail-recursive?
13:42:41 <Binkley> you may want to try increasing your stack first
13:42:49 <Binkley> which, of course, won't help if you're in an infinite recursion.
13:43:13 <Cale> often tail-recursive things will build up huge expressions that overflow the stack when they're finally evaluated
13:43:33 <yaxu> i'm learning Parsec, I think this is just something I need to go through
13:43:50 <Cale> which is why if you're using tail-recursion, you really probably want to either use foldl' or insert seq's by hand.
13:44:31 <shapr> Does Parsec do left factoring itself?
13:44:37 <fasta> glguy: I like kpdf, especially with "search next" binded to s.
13:44:47 <Cale> no, it relies on the use of chainl and try for that
13:45:21 <yaxu> i'm not really sure what tail recursion is, reading the wikipedia page now...
13:45:21 <Cale> good point, you might be in an infinite loop that way
13:45:37 <Cale> tail recursion is where you have a function that immediately calls itself
13:45:54 <Cale> that is, it doesn't do something to the return value of the recursive call
13:46:09 <Cale> tail recursive functions get turned into loops
13:46:43 <yaxu> right, i might be doing that
13:46:58 <Cale> but they're usually the sorts of functions which also build up big expressions which don't get evaluated until the very end
13:47:24 <yaxu> this parser has ended up with a lot of recursive spaghetti
13:47:51 <Cale> well, one thing to look for is left-recursion too
13:48:00 <Cale> which is what shapr suggested
13:48:15 <Cale> because parsec doesn't handle that automatically for you
13:48:36 <therp> in GHC is there some more crude way of dumping the syntax tree than ppr? I'm losing too much information that way.
13:48:41 <Cale> if to run the parser foo, the first thing it does is run the parser foo, without consuming input, then you're in trouble :)
13:48:48 <Binkley> therp: are you running it with -dppr-debug?
13:49:25 <therp> binkley: ah thanks, that looks a bit better.
13:49:49 <yaxu> Cale: ah, that might be it actually :)
13:50:35 <Cale> yaxu: the usual solution to that is to use chainl, or find out some clever way to transform your grammar so it won't do that
13:51:06 <SamB> Binkley: apparantly the real way is -V
13:51:24 <therp> but somehow it's not sufficient. binkley given RdrNames, is there some kind of internalization like in lisp symbol interning? I have two expression that dump to the exactly identical ppr print "MyAdd.myAdd{v} 4 3" but for one instance it fails with a MyAdd.myAdd not in scope error, and the other succeeds. any hints?
13:53:35 <yaxu> Cale: or find and delete the stupid line and have it all magically work
13:53:52 <Cale> yaxu: hehe
13:54:12 <Cale> yaxu: well, I'm sort of assuming that if the line was there, it was probably put there for a reason :)
13:55:35 <Binkley> therp: what kind of thing is myAdd?
13:55:59 <yaxu> i'm trying to parse "bol2" a really interesting programming language based on tabla drum rhythm notation
13:56:06 <Binkley> SamB: I don't think so; -V displays the version :-)
13:56:22 <Binkley> if you mean -v, then that might encompass -dppr-debug
13:57:43 <therp> binkley: a function in an external module, don't ask what I'm doing. I have driddle a hole into template haskell so that it takes HsExpr instead of template haskell data structures (which would be converted to HsExpr later on anyway), but for some reason my directly supplied HsExpr is different from the one that results from template haskell conversion. that's where I'm stuck because mine does have some issues with name space scop
13:57:43 <therp> ing I guess..
13:58:02 <Binkley> O_o
13:58:12 <Binkley> it's not a data constructor, though?
13:58:46 <therp> no, it's not defined as such, and ppr dumps it with {v} which I guess means it's classified as varName
13:58:54 <Cale> therp: what are you doing!? hehe
13:58:54 <Binkley> well, data constructors have wrappers that are vars
13:58:57 <therp> and the error message would be different.
13:59:05 <Binkley> but the wrapper has the same unique as the constructor which is confusing when you read the dumps
13:59:13 <Binkley> but it sounds like that's not the problem here...
13:59:30 <therp> cale: I'm hacking Liskell macros via template haskell
13:59:40 <Binkley> when you say one fails and the other succeeds, what do you mean? what's the difference in the contexts for the two expressions?
14:00:23 <Cale> therp: ah, the lisp-syntax for Haskell thing?
14:01:42 <Cale> Binkley: so what part of GHC are you working on? (I assume you're working on GHC at Microsoft?)
14:02:06 <therp> pfew that's hard to explain :) one is generated via conversion of template haskell data structures to HsExpr (via hsSyn/Convert.lhs) and the other one is a hack for TH, that is basically another Constructor for the expected result type Exp that carries a HsExpr payload, which is plainly passed through the conversion in hsSyn/Convert.lhs
14:02:18 <therp> cale: right. that thing. I'm almost done with it
14:02:55 <Binkley> Cale: yes, you'd be right to assume that; I'm working on the strictness analyzer
14:03:27 <Cale> neat :)
14:03:53 <Binkley> yeah... I'm still scratching my head trying to figure out how I was lucky enough to end up here :-)
14:03:59 <therp> cale: two things are still worring me: functions used in splicing must be defined in other modules, and two: 'incremental splicing', that is a splicing expression returns another splice (so the splicing expansion must loop until it's finished)
14:03:59 <sylvan> Binkley, so will we finally be able to stop sprinkling "seq" all over our code any time soon?
14:04:04 <Binkley> sylvan: heh
14:04:16 <Binkley> Maybe! Give me a few weeks! :-)
14:04:23 <sylvan> Cool!
14:04:42 <SamB> sylvan: strictness analysis doesn't mean you don't need seqs...
14:05:11 <Cale> Well, it would help with that.
14:05:14 <Binkley> true. I was being a bit tongue-in-cheek :-)
14:05:20 <SamB> you might really not have enough strictness, for instance
14:06:29 <sylvan> It seems to me (perhaps incorrectly) that most of the space leaks that crop up are thing which really should be strict and that the compiler, ideally, should find.
14:07:04 <SamB> maybe if it specialized everything to hell and back!
14:07:17 <Cale> actually, I've seen a lot of code which leaked space due to failure to take advantage of laziness
14:07:30 <SamB> Cale: it works both ways
14:07:36 <Cale> right
14:07:41 <SamB> but the strictness analyser *really* won't help with those cases
14:07:57 <Heffalump> surely you leak time that way, not space
14:07:58 <sylvan> Cale: do you have any good examples of that... I can't think of any obvious ones...
14:08:04 <glguy> ?version -- manual latency test
14:08:04 <lambdabot> lambdabot 4p255, GHC 6.5 (OpenBSD i386)
14:08:04 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:08:04 <SamB> Heffalump: heh
14:09:05 <Cale> sylvan: well, it basically arises where you somehow manage to look at more input than absolutely required to start producing some output
14:09:37 <Cale> sylvan: for example, using partition/filter when you ought to use span/takeWhile
14:10:06 <Heffalump> that's algorithmic laziness, not semantic laziness, though
14:10:27 <sylvan> hmm I see
14:10:31 <Cale> Right
14:10:37 <Heffalump> it's not that the compiler did the wrong thing by too much strictness, it's that the programmer failed to write a streaming algorithm
14:10:45 <Cale> yeah
14:10:48 <Cale> I know :)
14:11:29 <Heffalump> of course, the problem is that this all forces us to think far too operationally
14:12:56 <sylvan> As much as I love laziness, I'm drifting more towards wanting everything strict by default (or lenient). It's just easier to reason about. And tends to be more efficient... Though I don't know of any pure languages which are also strict/lenient...
14:12:59 <Cale> Lazy evaluation is still evaluation :)
14:13:20 <Cale> I wouldn't say it's any harder to reason about than strictness, it's just different
14:13:35 <Cale> You have to change what things appear "efficient" in your head.
14:14:13 <Binkley> sylvan, I'm inclined to agree
14:14:19 <Cale> You're looking for productive functions, ones which produce part of their output quickly
14:14:22 <Binkley> Maybe someone should suggest that for Haskell' ;-)
14:14:34 <sylvan> You'll be banned form the list!
14:14:36 <Binkley> heh
14:15:02 <Cale> Have you heard my argument for laziness by default?
14:15:03 <Binkley> well, if I would be, then Simon would be banned as well :-)
14:15:27 <sylvan> I really want purity though. It's just SO nice...
14:15:35 <sylvan> So, e.g. ML is out
14:15:48 <Cale> Basically, you can classify data as "large" or "small" based on whether there are lots of subcomponents which could potentially be evaluated separately.
14:15:53 <Binkley> <obligatory disparaging remarks about ML>
14:15:58 <sylvan> I've heard this one!
14:16:09 <Cale> The only case where you *really* need strictness is large -> small
14:16:44 <palomer> the only case you really need strictness is when you want to do something useful
14:17:09 <palomer> did you guys miss me?
14:18:29 <cjeris> what's lenient evaluation?
14:18:31 <Cale> Not that I don't think it's important to make it easy to work with strict computations.
14:18:38 <sylvan> I think the cases where you *need* laziness are sort of apparent, so much so that you could incorporate a keyword or operator for it. I rarely find laziness doing something nice behind my back, I *know* when I'm doing something that could only be done with laziness.
14:18:50 <Cale> sylvan: really?
14:19:04 <Cale> sylvan: most of the things I write rely fairly heavily on laziness all over the place
14:19:22 <sylvan> Yes. I mean the really cool stuff with laziness comes from things like doing dynamic programming in Haskell
14:19:51 <ValarQ> sylvan: like python?
14:19:52 <Cale> I think the really cool things about laziness come from the added composability it gives you
14:19:57 <pejo> Cale, are you saying it's not harder to reason about lazy evaluation than strict?
14:19:58 <sylvan> you basically think "laziness to the rescue" when you write it :-)
14:20:04 <Cale> You can break your problem up in new ways
14:20:13 <Cale> pejo: yes, that's exactly what I'm saying :)
14:20:24 <Cale> pejo: outermost-first vs. innermost-first
14:21:07 <sylvan> sure, but when you do it, it's not unexpected. You know it's neat to define an infinite list of primes, say. So it's not that much of an added burden to have to use, say, := rather than = in the definition to make it lazy, or some special bracket, or keyword or whatever.
14:21:07 <pejo> Cale, what about space leaks?
14:21:42 <Cale> pejo: they're rare if you're aware of what you're doing. If you keep an eye on how things actually evaluate, it's no problem.
14:22:11 <sylvan> ValarQ, missed you. I don't know, does Python have a laziness keyword now? Haven't looked at it for years (I'm a big proponent of static typing, which is why) and even then I didn't really give it an honest chance, I'm afraid.
14:22:17 <Cale> and for a few places where you must force things early, you have seq
14:22:25 <Cale> Basically, you think in terms of demand
14:22:38 <sylvan> "missed you" in a "missed your comment" sort of way
14:22:55 <ValarQ> sylvan: it has generators and more recently got generator comprehensions
14:23:02 <Cale> and you try to design your functions so that things which demand only part of the output will cause as little evaluation to happen as possible
14:23:13 <Heffalump> cale: the case you referred to before, where things are needed twice, is the biggest problem, though
14:23:15 <sylvan> Right. Like C# with "yield" etc?
14:23:26 <pejo> Cale, I got the impression there is some effort to have the compiler neither improve, nor throw away sharing - due to exactly that fact.
14:23:37 <ValarQ> sylvan: i don't know C#
14:24:02 <Heffalump> Cale: also, the second you start reasoning about demand, you lose referential transparency
14:24:03 <sylvan> well you write "yield" in an arbitrary place in the generator and execution stops, so it's demand driven.
14:24:13 <Cale> Heffalump: how is that?
14:24:23 <ValarQ> sylvan: sounds exactly like generators in Python
14:24:27 <sylvan> so you could have a for loop, a recursive function, or whatever as your generator definition...
14:24:28 <Heffalump> cale: because it's not preserved. CSE can change laziness.
14:24:47 <Cale> Oh, you're including it in the semantics
14:24:57 <Pseudonym> CSE can't change laziness.
14:25:17 <Heffalump> it can change operational laziness
14:25:18 <Pseudonym> In the sense of the Haskell semantics.
14:25:28 <theoco> Could you write a 3d opengl game in haskell?
14:25:31 <Heffalump> which is the point under discussion
14:25:33 <Heffalump> theoco: yes
14:25:35 <Pseudonym> Ah, OK.
14:25:35 <ValarQ> theoco: it has been done
14:25:41 <Cale> I think Heffalump is working with some strange new semantics :)
14:25:49 <glguy> theoco: it's called Frag
14:25:56 <sylvan> theoco: you could even write your shaders in Haskell (see vertigo)
14:26:02 <Pseudonym> Haskell specifically doesn't even mandate full laziness.
14:26:16 <Pseudonym> So there's no way that CSE can break Haskell semantics.
14:26:36 <Heffalump> I'm just pointing out that Cale's claims that you can reason about laziness, while true, interact badly with other notions we take for granted about Haskell, like referential transparency.
14:26:40 <Cale> It only mandates non-strict semantics
14:27:15 <Cale> I don't agree that it affects referential transparency -- the values themselves are equal.
14:27:28 <Cale> The time and space taken to evaluate them may be different.
14:27:55 <Heffalump> I think we're just arguing about (English) semantics now :-) I'm sure you get my basic point.
14:28:04 <Cale> If you replace a function applied to a parameter with its result, the program still produces the same thing, it just may be more efficient.
14:28:08 <pejo> Cale, heh, two things highly interesting for reasoning, imho.
14:28:15 <Heffalump> anyway, bedtime.
14:28:22 * Heffalump disappears
14:28:54 <Pseudonym> Or less efficient.
14:28:59 <Pseudonym> In a memory usage sense.
14:29:02 <Cale> yeah
14:29:24 <Pseudonym> Naturally, unsafePerformIO and seq break everything.
14:29:35 * Pseudonym thinks
14:29:35 <scodil> would I have needed to install something special to get the FFI library with ghc 6.6? gtk2hs is telling me I don't have it
14:29:38 <Pseudonym> Actually, I'm not sure about seq.
14:30:03 <Cale> seq only messes things up as far as making things _|_ when they otherwise wouldn't be
14:30:10 <scodil> nm
14:30:44 <Pseudonym> Right.
14:30:58 <Pseudonym> If you CSE'd something that was in the first argument of a seq...
14:31:13 <Pseudonym> No, that'd also work.
14:31:25 <Pseudonym> It just might bring the bottom forward in time.
14:32:36 <Cale> anyway, I think it just takes practise to reason about laziness, the same way that when you were first learning to program, reasoning about efficiency of strict programs was hard.
14:32:40 <Pseudonym> In the case of two different calls to "error", for example, CSEing seq might cause one error to be raised where the other may have been raised had the CSE not been done.
14:33:06 <Pseudonym> I'm thinking of a complex scenario where you evaluate something which throws an error, the error is caught, and then you evaluate that again.
14:33:15 <Cale> in fact, I kind of find it more natural to reason about efficiency of lazy programs now :)
14:33:25 <Pseudonym> And the caffeine hasn't set in enough to deal with that scenario yet.
14:33:29 <Binkley> heh
14:33:49 <Cale> Because things only compute what you demand from them
14:34:02 <pejo> Cale, I'm not really worried about "natural", but it shouldn't be too complex.
14:34:09 <Cale> So they behave more like they'd behave if you were computing them on paper :)
14:34:15 <Pseudonym> The thing I like about laziness is that if you're disciplined is that it makes garbage collection maximally efficient.
14:34:37 <Cale> (I'm a mathy though :)
14:34:47 <pejo> Pseudo, what measure are you using for efficiency of gc?
14:35:10 <Pseudonym> pejo: In a language like Java, you have to explicitly null out pointers, say, if you pop an element from a stack.
14:35:18 <Pseudonym> Otherwise you get a space leak.
14:35:20 <Cale> ack! Haskell-cafe is generating lots of mail!
14:35:27 <Pseudonym> So you have to work to get GC efficiency.
14:35:38 <Cale> Select all -> archive :)
14:35:45 <Pseudonym> In Haskell, on the other hand, chances are good that as soon as an object gets created, it's time for it to be destroyed.
14:35:52 <Pseudonym> Because it's only created on demand.
14:36:09 <Pseudonym> If you think about locality and generational garbage collection...
14:36:14 <Pseudonym> That's maximal efficiency.
14:36:18 <pejo> Pseudo, so generate as much garbage as you can between gc's, with 0 live memory is maximum efficiency?
14:36:55 <Pseudonym> What I'm saying is that memory in Haskell programs naturally organises itself into generations.
14:37:15 <Pseudonym> And the youngest generation is usually extremely temporary.
14:37:42 <pejo> Pseudo, I was more curious about your measure of gc efficiency. Any copying collector will do fine if you have little live memory and lots of garbage.
14:37:56 <Pseudonym> I'm thinking specifically about generations.
14:38:01 <Pseudonym> In a generational GC.
14:38:04 <dcoutts> scodil, did you get it to work ?
14:38:21 <chessguy> > let lim = 13 in length [[a,b,c,d,e,f,g,h,i,j,k,l,m]|a<-[0..lim],b<-[a..lim],c<-[b..lim],d<-[c..lim],e<-[d..lim],f<-[e..lim],g<-[f..lim],h<-[g..lim],i<-[h..lim],j<-[i..lim],k<-[j..lim],l<-[k..lim],m<-[l..lim],a+b+c+d+e+f+g+h+i+j+k+
14:38:21 <lambdabot>  Parse error
14:38:29 <scodil> dcoutts: yeah I got it to compile, but the cairo demo is telling me that it can't find the cairo package
14:38:30 <Pseudonym> Erlang also has a kind of maximal efficiency, only for a different kind of GC.
14:38:41 <Pseudonym> In Erlang, heaps are thread-local.
14:38:51 <pejo> Pseudo, *specify* your measure of efficiency.
14:38:52 <dcoutts> scodil, you probably don't have cairo installed, or you've got too old a version of Gtk+
14:38:53 <Pseudonym> So you can GC them separately.
14:39:09 <dcoutts> scodil, you need Gtk+ 2.8 or later for cairo integration
14:39:10 <chessguy> > let lim = 13 in length [[a,b,c,d,e,f,g,h,i,j,k,l,m]|a<-[0..lim],b<-[a..lim],c<-[b..lim],d<-[c..lim],e<-[d..lim],f<-[e..lim],g<-[f..lim],h<-[g..lim],i<-[h..lim],j<-[i..lim],k<-[j..lim],l<-[k..lim],m<-[l..lim],a+b+c+d+e+f+g+h+i+j+k+l+m==lim]
14:39:14 <lambdabot> Terminated
14:39:24 <chessguy> can this code be streamlined?
14:39:30 <Pseudonym> pejo: In Haskell programs, data in the youngest generation lives for less time than in other languages.
14:39:55 <scodil> dcoutts: I got gtk 2.10
14:39:59 <Binkley> chessguy, can you use paste instead? i can't read it very well as-is
14:40:02 <Pseudonym> That's my argument.
14:40:07 <chessguy> oh, sure
14:40:09 <chessguy> @paste
14:40:10 <lambdabot> http://paste.lisp.org/new/haskell
14:40:19 <Cale> chessguy: you can compute m
14:40:31 <Cale> or, you can compute the whole thing by hand
14:40:36 <dcoutts> scodil, when you run ./configure use --enable-cairo it'll tell you what's missing.
14:40:37 <chessguy> oh?
14:40:37 <Pseudonym> So a generational GC will, in general, spend less time collecting in Haskell than in other languages.
14:40:47 <Pseudonym> By "other languages", I mean comparable languages like ML.
14:40:57 <pejo> Pseudo, and in order to maximize the efficiency of your gc, you want to maximize the amount of garbage produced?
14:40:59 <chessguy> how can i compute the whole thing by hand?
14:41:09 <Cale> well, actually, that's quite a bit of a pain
14:41:10 <glguy> anyone want to confirm that my reponse to this comment was "correct" so that I don't misrepresent monads to the unwashed reddit masses?
14:41:10 <glguy> http://programming.reddit.com/info/ojn6/comments/cor67
14:41:11 <Pseudonym> No.
14:41:13 <lambdabot> Title: Monads as spacesuits (reddit.com), http://tinyurl.com/yh7ug9
14:41:16 <Cale> Mathematica can do it though :)
14:41:26 <Pseudonym> Well, kind of.
14:41:27 <pejo> Pseudo, ok. Then I don't understand.
14:41:35 <Binkley> glguy, i think your response is completely right
14:41:39 <chessguy> Cale: how?
14:41:58 <Pseudonym> Given the same amount of memory used, you want to maximise the amount that becomes garbage in as short a time as possible.
14:42:53 <cjeris> glguy: you neglected to add that the author of the comment to which you responded should be kicked out an airlock... without the spacesuit which s/he clearly deems unnecessary.
14:42:59 <Binkley> haha
14:43:29 <Cale> chessguy: there are general ways to compute sums of polynomials, and the results are polynomials
14:43:31 <lisppaste2> chessguy pasted "here's the pasted code" at http://paste.lisp.org/display/29117
14:43:37 <Cale> (polynomials in the index)
14:43:53 <chessguy> can you give me something to google?
14:43:59 <pejo> Pseudo, is that statement any different from "Lets have plenty of intermediate structures"?
14:44:13 <Cale> Sure, also an explicit formula :)
14:44:14 <glguy> cjeris: he's lived inside the space suit all his life, he doesn't realize that he's wearing one
14:44:21 <chessguy> that would be great too
14:44:24 <Pseudonym> That's a good question.
14:44:36 <Pseudonym> The way I think of it is that intermediate structures are cheap.
14:44:43 <Cale> (6227020800 + 19802759040*n + 26596717056*n^2 + 20313753096*n^3 + 9957703756*n^4 + 3336118786*n^5 + 790943153*n^6 + 135036473*n^7 + 16669653*n^8 + 1474473*n^9 + 91091*n^10 + 3731*n^11 + 91*n^12 + n^13)/6227020800
14:44:51 <Pseudonym> Indeed, in a GRIN-like compiler, intermediate structures are often free. :-)
14:44:52 <glguy> = 42
14:44:59 <chessguy> how did you get that?
14:45:01 <Cale> where n = lim in your code
14:45:03 <Cale> Mathematica
14:45:21 <chessguy> with what function call?
14:45:25 <cjeris> glguy: actually, in the metaphor, it seems more like he's had random blood spurting out of his body from decompression injuries all his life, considers it normal, and doesn't understand the fuss about spacesuits. :)
14:45:26 <SamB> where can one get a GRIN-like compiler that doesn't take 1GB to compile things?
14:45:28 <Pseudonym> Not that GHC is GRIN-like.
14:45:38 <Cale> Simplify[Sum[1, {a, 0, n}, {b, a, n}, {c, b, n}, {d, c, n}, {e, d, n}, {f, e, n}, {g, f, n}, {h, g, n}, {i, h, n}, {j, i, n}, {k, j, n}, {l, k, n}, {m, l, n}]]
14:45:46 <SamB> note that that is the *RAM*
14:45:49 <pejo> Pseudo, I'm not saying intermediate structures are expensive, or cheap. Producing garbage takes time though, if we for a second disregard the space issues. There must be an interest to reduce the amount of intermediate structures, hence Wadler pondered the issue for a while.
14:46:00 <Pseudonym> Yes.
14:46:05 <SamB> pejo: hah
14:46:24 <SamB> well.
14:46:28 <Pseudonym> But what I'm saying is that you can ameliorate the cost of intermediate structures by making sure they're short-lived, and optimising the GC for that case.
14:46:46 <SamB> I'd say that using the not-yet garbage took more time!
14:47:19 <Pseudonym> You win in two ways.  One is that generational GC doesn't GC all of the heap.  The other is that you're GCing memory which is very, very likely to be in cache.
14:47:22 <SamB> oh, and aren't most collectors optimized for that?
14:47:33 <Pseudonym> SamB: It depends.
14:47:38 <pejo> Pseudo, sure, we both agree that a copying collector with 0 live memory is very cheap to collect, just swap a couple of pointers.
14:47:46 <Pseudonym> Sure.
14:47:51 <Cale> chessguy: I kind of forget the details, but the basic idea is that you convert the polynomial into the falling factorial basis, and there's a really simple formula for sums of polynomials in the falling factorial basis
14:47:52 <scodil> dcoutts: It doesn't want to install the packages. --with-PACKAGE=yes, right? I've got my ghc in a non-standard place.. could that be it?
14:48:06 <Cale> (which looks eerily like integration)
14:48:16 <Pseudonym> SamB: It would be a waste of effort to use generational GC in Erlang, for example.
14:48:16 <dcoutts> scodil, ./configure --enable-cairo
14:48:21 <chessguy> hmm, i'm trying to generalize the number of variables there
14:48:29 <glguy> I kind of feel that there could be two "Monad metaphore" pages on reddit every day, and no one that reads them is going to actually understand why Monads are so cool unless they actually start learning Haskell and actually use Monads
14:48:34 <dcoutts> scodil, configure will find ghc or complain.
14:48:34 <SamB> Pseudonym: you mean because threads die so soon?
14:48:42 <Pseudonym> Because heaps tend to be small.
14:48:47 <SamB> oh.
14:48:48 <Pseudonym> Individual heaps.
14:48:51 <chessguy> i did it using haskell for limits of 2 to 12, but then it got really time-intensive
14:48:52 <scodil> dcoutts: yeah that works. its not just cairo. nothing is getting installed with ghc. ghc-pkg list says nothing of gtk
14:49:06 <chessguy> it looks like it's exponential
14:49:08 <pejo> SamB, without knowing Haskell specifics there might be a case where the "not yet garbage" stuff just started to get calculated, and the collector sets in.
14:49:11 <Pseudonym> But on the other hand, generational GC is perfect for Haskell because data is only created on demand.
14:49:24 <SamB> twospace collectors are optimized for the "garbage" case even more than generational ones are
14:49:31 <dcoutts> scodil, what version of gtk2hs, what version of ghc and what os/platform ?
14:49:47 <Cale> chessguy: well, it's better to generalise to all polynomials in the index http://www.sjsu.edu/faculty/watkins/antidiff.htm
14:49:49 <lambdabot> Title: The Summation of Series Using the Anti-Differencing Operation, http://tinyurl.com/t3clf
14:49:53 <Pseudonym> SamB: In most Haskell programs, though, there are definite generations.
14:50:00 <SamB> Pseudonym: indeed
14:50:07 <SamB> like, your CAFs need to live somewhere
14:50:10 <pejo> Pseudo, and Haskell has more short lived data than O'caml or SML?
14:50:11 <scodil> dcoutts: whatever gtk2hs is in the darcs repo, ghc-6.6, ubuntu/x86(32bit)
14:50:16 <Cale> chessguy: That page could be better written, and use less-garish colours, but I think it contains the gist of it
14:50:17 <Pseudonym> That's also true of other languages like ML and Java, but it's even MORE so in Haskell.
14:50:26 <Pseudonym> pejo: Yes.
14:50:37 <Pseudonym> And more to the point, it's even shorter-lived.
14:50:40 <dcoutts> scodil, so what does it say when you make install ? it calls ghc-pkg and does that complain or what ?
14:50:44 <dcoutts> @paste
14:50:44 <lambdabot> http://paste.lisp.org/new/haskell
14:50:50 <dcoutts> use that ^^
14:50:57 <monochrom> I had a program (using something similar to mapAccumL) that has different space profiles under different GC parameters in GHC. :)
14:50:57 <dolio> Speaking of monads, there's isn't a breadth-first search monad floating about, is there?
14:50:59 <SamB> and basically any closure could be a sort of "generational retainer" or something like that...
14:51:18 <chessguy> ok, i'll check that out.
14:51:26 <Pseudonym> Actually, it suggests a style of Erlang programming where you explicitly hand data between threads to simulate generations.
14:51:30 <SamB> (saturated data constructors count as closures right?)
14:51:53 <scodil> dcoutts: oh it gave an error. hah.. the error was so long it filled up a whole screen and I didn't see that it said "error..." at the top. it says: ghc-6.6: cannot parse 'glib-' as a package identifier
14:52:42 <kpreid> SamB: saturated?
14:52:45 <dcoutts> scodil, can you paste the whole thing ?
14:52:48 <dcoutts> @paste
14:52:48 <lambdabot> http://paste.lisp.org/new/haskell
14:52:53 <Pseudonym> I'm sure I'm not the first person to have thought of that.  There is a huge Erlang LOC count in the world.
14:52:55 <SamB> well, consider (1:)
14:53:15 <SamB> that isn't saturated, because it only has one of its arguments
14:53:28 <kpreid> ah
14:53:38 <Pseudonym> Right, so it's going to be represented as something like:
14:53:49 <Pseudonym> f xs = Cons (Int 1#) xs
14:54:07 <lisppaste2> scodil pasted "gtk2hs error" at http://paste.lisp.org/display/29120
14:55:29 <dcoutts> scodil, so in the Makefile, what is VERSION defined to be ?
14:55:41 <dcoutts> scodil, and what about PACKAGE_VERSION ?
14:55:57 <dcoutts> scodil, eg, on my system it's "VERSION = 0.9.10.2"
14:56:10 <scodil> dcoutts: its nil here.
14:56:16 <scodil> dcoutts: VERSION =
14:56:22 <dcoutts> scodil, and PACKAGE_VERSION ?
14:56:38 <scodil> 0.9.10.2
14:56:56 <dcoutts> scodil, what version of autoconf and automake did you use ?
14:57:19 <scodil> autoconf 2.6, automake 1.8
14:59:11 <scodil> I just have to run autoconf and automake, right? or autoreconf? I'm not a pro with these two programs
15:01:23 <scodil> dcoutts : ah crap... ok I think I know whats going on. autoconf is calling automake1.4, and you need 1.8. holdon lemme fidget with it.
15:01:49 <dcoutts> scodil, yep. It really ought to complain if it's the wrong version.
15:02:06 <dcoutts> that often seems to happen on debian. I don't know why.
15:02:44 <scodil> i've only been using this distro for a few weeks. still trying how to change /usr/bin/autoconf to point to 1.8
15:06:46 <SamB> it works better if you say "automake-1.8"
15:21:43 <scodil> dcoutts: all set. works beautifully
15:22:05 <dcoutts> scodil, excellent!
15:23:01 * dcoutts goes back to hacking on the gtk2hs code generator
15:23:17 <scodil> code generator?
15:25:16 <dcoutts> scodil, the gtk2hs code and docs are semi-automagically generated
15:25:56 <scodil> does the OpenGL widget work in windows?
15:27:43 <dcoutts> scodil, yep
15:28:10 <Baughn> scodil: If you install opengl, anyway - MS no longer ships it by default, since it has proven resistant to embrace-and-extend
15:28:26 <mwc> Baughn, ugh, I had a nasty runin with embrace and extend
15:28:46 <scodil> when did they stop shipping it?
15:28:54 <scodil> last I checked winxp came with opengl 1.1 or something
15:29:11 <dcoutts> I tried it on win2k3
15:29:17 <mwc> It's kind of irrelevent, isn't it? The GPU manufacturers ship the drivers, and those have OGL
15:29:29 <Baughn> Not sure, but the xp-sp2 CD I have doesn't have it
15:29:46 <Baughn> mwc: That's only if you have an ati or nvidia gpu, really
15:30:03 <scodil> i've never had a problem with mingw and opengl
15:30:32 <dibblego> "./Setup.hs configure" --> "Setup.hs: Multiple description files found.  Please use only one of :" -- how do I *use* just one? how do I specify one? I tried Setup.hs --help and Setup.hs configure --help
15:30:48 <Botty> yeah, the opengl/directx situation is really sad
15:30:58 <dcoutts> dibblego, you must have only one in the dir.
15:31:06 <Botty> or at least what happened was
15:31:09 <dibblego> dcoutts, surely I can just specify which one
15:31:15 <dcoutts> dibblego, nope
15:31:20 <dibblego> bummer
15:31:47 <scodil> Botty: what are you referring to? the vista stuff, or just the fact that opengl is a second class citezen on windows?
15:32:25 <Botty> well, how microsoft has generally screwed over opengl, but yes, current stuff too
15:32:49 <scodil> all programming is a mess on windows anyways. macros with lowercase letters. functions names starting with uppercase letters. cats marrying dogs. general bedlam
15:33:14 <Botty> the only thing directx does better than opengl, in my opinion, is hardware control.  If you try to do something the hardware doesn't support in ogl it can drop into software mode
15:33:36 <Botty> yeah, win32 is what delayed my learning of C/C++ a few years...
15:33:50 <Baughn> That, and the win32 api is designed to /lock you in/. Not to be easy to program with - to be hard to port away from.
15:33:54 <Botty> well, I knew it, I just never used it much because it was ugly as hell
15:34:17 <scodil> the only arguments I hear in favor of directx are things that have nothing to do with graphics. meshes, keyboard and joystick, sound... stuff that belongs in other libraries
15:34:29 <scodil> i personally have never touched dx though, so I can't say much
15:35:22 <scodil> sweet. the close button on this opengl demo is huge
15:36:06 <Botty> ah. well, now the managed directx api is much better than opengl, but that's only a recent occurance
15:36:11 <dons> ?users
15:36:11 <lambdabot> Maximum users seen in #haskell: 265, currently: 243 (91.7%), active: 31 (12.8%)
15:36:30 <dons> morning.
15:36:38 <monochrom> ?lusers
15:36:38 <lambdabot> Maximum users seen in #haskell: 265, currently: 243 (91.7%), active: 32 (13.2%)
15:36:43 <monochrom> Eh!
15:36:46 <scodil> so, since we're in the haskell channel, and we're talking about 3d graphics, has anyone ever done any meshing in haskell? the cyclic/mutable nature of a mesh seems pretty challenging
15:36:54 <monochrom> ?husers
15:36:54 <lambdabot> Maximum users seen in #haskell: 265, currently: 243 (91.7%), active: 32 (13.2%)
15:36:59 <monochrom> ???!!!!!
15:37:13 <dons> spelling correction on your typos
15:37:15 <Baughn> scodil: Cyclic? /Mutable/?
15:37:22 <monochrom> Impressive
15:37:28 <Baughn> scodil: Are you talking about mesh deformation, or..?
15:37:32 <scodil> well ok it doesn't have to be mutable
15:37:35 <dons> ?Hisers
15:37:35 <lambdabot> Maximum users seen in #haskell: 265, currently: 243 (91.7%), active: 32 (13.2%)
15:37:55 <Baughn> ?mousers
15:37:56 <lambdabot> Maximum users seen in #haskell: 265, currently: 243 (91.7%), active: 32 (13.2%)
15:38:03 <Baughn> ..intriguing
15:38:17 <dcoutts> ?trusers?
15:38:17 <lambdabot> Unknown command, try @list
15:38:28 <dcoutts> ?trousers
15:38:29 <lambdabot> Unknown command, try @list
15:38:32 <dons> doh
15:38:34 <Botty> I've been messing with hopengl
15:38:40 <Botty> no meshes yet though
15:38:46 <scodil> I'm having trouble penetrating these "tie-the-knot" tutorials and stuff on the subject of cyclic data structures
15:39:03 <Botty> would be cool to have some procedural mesh generation stuff
15:39:05 <scodil> credit-card-transform and whatnot
15:39:18 <dcoutts> cyclic data structures are cool
15:39:23 <monochrom> I think they make it sound hard.
15:39:29 <scodil> i'll say
15:39:36 <Baughn> > take 4 $ cycle [1,2]
15:39:37 <lambdabot>  [1,2,1,2]
15:40:07 <scodil> from what i gather, the basic ingredient is carrying a hashtable (or some kind of map) of visited nodes.
15:40:08 <dcoutts> building a cyclic structure is easy, it's just a matter of naming the right thing.
15:40:34 <dcoutts> so yeah, that thing is often a lazy map / array whatever
15:40:35 <Baughn> Actually, cyclic structures are a lot easier to handle in Haskell than most other languages, since it doesn't have any objections to infinite computations
15:40:43 <monochrom> "xs = 1 : xs"  if you see that this gives xs = [1,1,1,1,...  you're 99% good.
15:40:59 <Botty> hmm, you know what would be cool? something like fold except it takes n elements of the list.
15:41:12 <dcoutts> like: fold . take ?
15:41:19 <monochrom> "xs = 1 : ys; ys = 0 : xs"  if you see that this gives xs = [1,0,1,0,...  and ys = [0,1,0,1,...  you're 99.99% good.
15:41:33 <Botty> foldn (\ a b c d -> a + b + c + d)
15:41:39 <Botty> that sort of thing
15:41:45 <Baughn> And if you go on to type "cycle [1,0]" instead, you're 99.999% good
15:41:52 <dcoutts> Botty, there's no need since we have take.
15:42:10 <Botty> oh. well, i suppose i should learn how to use that combo...
15:42:30 <Baughn> Botty: Indeed - haskell is /all/ about combos
15:42:39 <dcoutts> > foldl' (+) 0 . take 5 $ [1..]
15:42:40 <lambdabot>  15
15:42:41 <Botty> that's been frustrating me - always have to resort to recursion when its more than one.
15:42:43 <monochrom> All programming is about combos.
15:43:01 * Baughn recently "invented" 'map ($ 42) ...', and is still trying to do the same concisely in CL
15:43:45 <scodil> what is that, mapping an argument over a list of functions?
15:43:56 <monochrom> YES!
15:44:01 <scodil> rad
15:44:10 <Cale> Botty: well, you could make the result a tuple rather than a single value and use foldl/foldr
15:44:13 <Baughn> Yep, and while I can of course do the same in most other languages, it takes... more code.
15:44:20 <monochrom> map ($ 42) [f,g,h] = [f 42, g 42, h 42]
15:44:42 <_frederik_> when I use newArray, how do i insist that the result is an IOArray? i could cast it but the type variables for the index and element types aren't in scope
15:44:46 <Botty> Cale - true, but seems ugly
15:44:59 <dons> its nice that map f [42,...] is only a step away from map ($42) [f,g,..]
15:45:16 <SamB> @type newArray
15:45:18 <lambdabot> Not in scope: `newArray'
15:45:27 <SamB> @type Data.Array.MArray.newArray
15:45:28 <lambdabot> forall e (a :: * -> * -> *) (m :: * -> *) i. (Data.Array.Base.MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
15:45:33 <scodil> (a :: IOArray Int Thing) <- newArray ....?
15:46:02 <dons> a type annotation should do the trick
15:46:03 <Cale> Botty: perhaps, yeah. It's possible to write fold3/etc. like that though :)
15:46:35 <monochrom> Programming is about combos.  But some languages make combos harder than writing from scratch.  This is because programming is still paid by time/code spent rather time/code saved.
15:47:18 <SamB> (newArray :: (Ix i, MArray IOUArray e IO) => (i, i) -> e -> IO (IOUArray i e)) should work
15:47:22 <SamB> too
15:47:23 <Botty> ahah, I got it: foldn :: ([a] -> b -> b) -> b -> [a] -> b
15:47:46 <Botty> err i forgot
15:48:00 <Botty> foldn :: ([a] -> b -> b) -> Int -> b -> [a] -> b
15:48:02 <_frederik_> well, I think SamB's solution is the only one that will work
15:48:24 <SamB> also that idea of having types with holes in them would come in handy
15:48:26 <Botty> probably foldn :: Int -> ([a] -> b -> b) -> b -> [a] -> b instead
15:48:54 <_frederik_> i said "the type variables for the index and element types aren't in scope", i.e. the index and element types are type variables and not concrete types such as Int and Thing, Mr. scodil
15:49:25 <SamB> _frederik_: probably related to the lack of scoped type variables, eh?
15:49:35 <Botty> ?hoogle Int -> ([a] -> b -> b) -> b -> [a] -> b
15:49:36 <lambdabot> No matches, try a more general search
15:49:38 <_frederik_> but i think it's crazy if i have to use "(newArray :: (Ix i, MArray IOUArray e IO) => (i, i) -> e -> IO (IOUArray i e))"
15:49:47 <SamB> _frederik_: yeah, it is
15:50:07 <Botty> ?hoogle ([a] -> b -> b) -> Int -> b -> [a] -> b
15:50:08 <lambdabot> No matches, try a more general search
15:50:19 <Botty> ?hoogle (b -> [a] -> b) -> Int -> b -> [a] -> b
15:50:19 <monochrom> I have a troll detection heuristic.  It works like this.  If the same person asks about too many different areas in a short time, it is probably a troll.
15:50:20 <lambdabot> No matches, try a more general search
15:50:38 <monochrom> My detector got a signal just a few minutes ago.
15:50:57 <SamB> monochrom: not if they can show a program or two in which they are actually using those different areas
15:51:01 <SamB> or trying to do so
15:51:35 <xerox> monochrom: what about shapr? (:
15:51:38 <monochrom> Yes I have false positives.
15:51:40 <SamB> hah
15:51:47 <SamB> shapr is not a troll, duh
15:51:48 <shapr> wha?
15:52:12 <SamB> shapr: xerox was saying that you might tend to ask about a lot of different areas of Haskell in a short time
15:52:29 <shapr> Or even questions about magnetic gears and all sorts of other random stuff.
15:52:46 <dons> hmm, comp.lang.haskell       Functional programming with lazy evaluation
15:52:50 <SamB> well, *that* wouldn't affect monochrom's troll-o-meter
15:52:52 <xerox> haha I was trying to phrase something about magnetic+functional invention.
15:53:03 <monochrom> comp.lang.haskell has begun?
15:53:04 <SamB> because the troll-o-meter only goes off for haskell-related questions
15:53:11 <dons> news is weird
15:53:27 <dons> monochrom: yes, announcement today
15:53:42 <xerox> !
15:53:46 <monochrom> Rejoice
15:53:53 <SamB> whats it for?
15:53:58 <monochrom> Haskell.
15:55:11 <Cale> There's a comp.lang.haskell?
15:55:16 <monochrom> Oh have to wait until Nov 4.
15:55:24 <Cale> Why?
15:55:30 <Cale> We have the mailing lists
15:55:51 <SamB> who are the big 8?
15:55:54 <dcoutts> that's what I thought
15:57:09 <monochrom> I like newsgroups.
15:57:20 <shapr> I like spiffy.
15:57:31 <monochrom> This is because I pay US$45 per year to use a newsgroup server. XD
15:57:45 <SamB> maybe it is intended for the denizens of comp.lang.functional ?
15:58:11 <SamB> monochrom: surely you do not pay US $45 just for text groups?
15:58:20 <monochrom> I do.
15:58:32 <SamB> wow.
15:59:04 <xerox> Well, one pays one's provider, and it usually gives nntp access.
15:59:46 <scodil> dcoutts: these gtk2hs docs are really good. did you (guys) write all this by hand? or is it some kind of magic scraping of the gtk docs?
16:00:07 <dcoutts> scodil, as I said, the docs are semi-automagically generated.
16:00:25 <xerox> The automagical part is the fun one.
16:00:26 <scodil> so.. take them with a grain of salt
16:00:45 <scodil> like if it says it returns NULL or something
16:00:51 <xerox> hehe
16:01:05 <dcoutts> scodil, well we've got a cunning program that reads gtk-doc docbook and produces haddock docs, and then we hand edit that.
16:01:24 <dcoutts> scodil, you shouldn't find any NULLs, the generator takes care of that.
16:01:32 <scodil> no i tease. i'm sure they are as accurate as they are thorough
16:01:53 <dcoutts> there are a few bits here and there that are a bit Cish
16:02:13 <dcoutts> or references to unbound functions
16:02:30 <SamB> I thought those things were for porn addicts or movie pirates or whatever
16:02:52 <SamB> traffikerz in binaryz, whichever way
16:03:34 <Cale> monochrom: are you aware that there's already a haskell mailing list to usenet portal?
16:05:51 <monochrom> I read and post to the haskell mailing list directly.
16:06:39 <monochrom> This doesn't answer your question but I think it answers your next question.
16:11:09 <emu> what is gmane? -- jeopardy style
16:13:51 <scodil> i'd like to see a jeopardy game where the contests phrased their responses in the form a question, for reals. rising inflection on the end and everything
16:14:03 <scodil> as if they really didn't' know
16:14:07 <scodil> and were asking to find out
16:14:14 <_frederik_> hehe
16:15:01 <_frederik_> i think it would be hard to force people to do that: "sorry, your response wasn't inflected enough"
16:15:27 <_frederik_> "see, look at the inflectometer"
16:15:42 <scodil> our judges say no
16:15:53 <scodil> not baffled-sounding enough
16:18:10 <monochrom> "Is that gmane?  Is it just me or am I missing something?"
16:18:39 <monochrom> "Do I look like I know?"
16:23:54 <dons> dcoutts: did you see the PADL papers list is out?
16:24:02 <dcoutts> dons, I din't
16:24:03 <dons> http://www.informatik.uni-kiel.de/~mh/padl07/accepted.html
16:24:07 <lambdabot> Title: PADL'07: Accepted Papers, http://tinyurl.com/y45omo
16:24:13 <dons> also, registration and hotel info.
16:24:30 <dons> and John Hughes is giving an invited talk
16:24:44 <dcoutts> aye, better go ask the department for the promise of expenses dosh
16:24:49 <dcoutts> oh, nice
16:25:06 <dons> oh, the erlang bit stream erlang guys are there
16:26:17 <dcoutts> dons, aye, that just jumped out at me
16:26:36 <dons> wel that will be interesting. i wonder if we can improve on the haskell results :)
16:27:04 <merritt> hi everyone. i wondered if the following is possible to implement in haskell: a function, that takes an integer as input and gives its as output its set-theoretical account, which is recursively given by defining 0 as the empty set and n as the union of {n-1} and n-1. thus it starts with 0 = {}, 1 = {{}} = {0}, 2 = { {}, {{}} } = {0,1} and then 3 = {0,1,2} etc.
16:27:07 <dons> bit streams for haskell anyone?
16:27:14 <dcoutts> maybe we can get some advice or inspiration for a serialisation lib
16:27:17 <dons> yeah
16:27:18 <SamB> wth is gmane?!?
16:27:22 <merritt> for illustration: in lisp lingo the following would do: (defun fnord (x) (if (= x 0) nil (cons (fnord (- x 1)) (fnord (- x 1)))))
16:27:24 <merritt> in haskell this doesn't work with lists, because lists are not allowed to be heterogeneous (but would have to be of type [a,[a]]). is there another way without using lists? (tupels?)
16:27:25 <dons> SamB: google?
16:27:30 <SamB> heh!
16:27:36 <SamB> I fooled your inflecto-meter!
16:27:43 * SamB knows what gmane is ;-)
16:27:52 <dons> well, sometimes it's hard to tell...
16:28:18 <SamB> I do that on purpose, sometimes ;-)
16:28:27 <dons> not a healthy habit
16:29:02 <dons> merritt: hmm. interesting
16:29:40 <monochrom> Set theory is imperative.  Lambda calculus is functional.
16:29:41 <SamB> merritt: is that a binary tree?
16:29:42 * monochrom ducks
16:30:11 <SamB> hey wait
16:30:20 <SamB> aren't both branches identical?
16:30:51 <merritt> you're adding a list L to exactly this list L
16:31:25 <scodil> data Set i = Empty | Set i ...?
16:31:26 <merritt> which gives a new list L' that contains all elements of L and L itself
16:31:35 <dons> oh, best comment yet on coffeemug's lisp tutorial , "A bit easier than a Haskell interpreter in Lisp"
16:32:49 <fik> @what gmane
16:32:49 <lambdabot> I know nothing about gmane.
16:33:02 <merritt> scodil: does it work? i can't really tell; i got lost with defining new data types ...
16:33:12 <dons> i like how people on digg and swik have filed the lisp/haskell tut under the useful category of "cool"
16:33:27 <twanvl> newtype Set = Set [Set]
16:33:45 <scodil> merritt: i don't see why not. SamB got it I think when he said it was a tree
16:33:52 <scodil> or beter yet...
16:33:57 <scodil> what twanvl said
16:34:44 <merritt> ok, i'll try that. thx :)
16:35:26 <SamB> merritt: do you attach any significance to the parens you get when that is printed out in lisp?
16:35:53 <SamB> or would you just as well like it printed using the dot notation?
16:36:14 <scodil> fnord x [0] = []; fnord x i = (fnord (x-1)):(fnord(x-1)) ...?
16:36:22 <scodil> oops
16:36:23 <SamB> i.e. (cons () ()) -> (() . ())
16:36:31 <scodil> you see what I was going for
16:37:44 <merritt> SamB: i don't care about how it looks like in the end (not at all) -- problem is: i don't really know lisp and i just started to learn haskell a month ago..
16:38:36 <SamB> merritt: oh.
16:38:58 <fik> (cons '() '()) -> '(())
16:39:01 <scodil> you probably just want to take lists to be sets, and be careful not to put something in twice. then you can define pretty much how you would on pen and paper
16:39:24 <scodil> just think of [] as {}
16:39:39 <SamB> * (eq '() ())
16:39:39 <SamB> T
16:40:03 <kpreid> dons: I'm pulling new lambdabot stuff. what's disabledCommands and disabling the state plugin about?
16:40:04 <SamB> fik: also, yes I know it doesn't really print out like that
16:40:23 <SamB> my formatting was an alternative way you could print it
16:40:29 <merritt> scodil: i don't care if it's list or sets; the problem is that i can't do xs : xs because that would yield a non-homogeneuos list...
16:40:44 <SamB> T
16:40:44 <SamB> * '(() . ())
16:40:44 <SamB> (NIL)
16:40:44 <SamB> * (cons () ())
16:40:44 <SamB> (NIL)
16:40:52 <scodil> no the type of the list/set is Set = [Set]
16:40:58 <scodil> data Set = [Set] in haskell
16:40:59 <SamB> oops, stray T :-(
16:41:17 <SamB> scodil: you are being too literal-minded, I think
16:41:22 <twanvl> inc (Set x) = Set (Set x : x)
16:41:35 <SamB> data Bin = Branch Bin Bin | Empty
16:41:49 <SamB> that more accurately describes what merritt was doing
16:42:09 <scodil> we're forgetting the Ints
16:42:26 <SamB> the ints were args to fnord weren't they?
16:42:45 <SamB> yeah, there are no ints in the result
16:42:46 <desrt> has anyone here ever used HOL or any LCF-type system?
16:42:52 <scodil> does it just produce sets of sets of empty sets?
16:42:58 <scodil> i misunderstood
16:43:30 <desrt> even general knowledge about ML might help me :)
16:44:23 <SamB> * (fnord 4)
16:44:23 <SamB> ((((NIL) NIL) (NIL) NIL) ((NIL) NIL) (NIL) NIL)
16:44:24 <dons> kpreid: disabled commands is an optional list of commnds you'd like to disable
16:44:44 <dons> kpreid: the state plugin is disabled as it has a spam issue i've not sorted out yet
16:44:50 <kpreid> ah ok
16:45:20 <dons> also, the bot has a slowish space leak that i've not tried to track down. in a really busy installatoin, you might end up over 100M after a week or so
16:45:21 <merritt> SamB: :) yes, if that would work in haskell as easily.. ;)
16:45:35 <kpreid> also, it would be nice if the state was stored outside of the repository, so I didn't have to reject/resolve patches to it
16:45:36 <dons> i should really turn on -prof and spot the missing $!
16:45:40 <SamB> merritt: you do realize it is pretty useless, right?
16:46:01 <dons> kpreid: hmm. yes. i don't have a good distribution system for that htough
16:46:03 <kpreid> (since I'm running a not-a-lambdabot-hydra-head lambdabot)
16:46:13 <dons> oh?
16:46:17 <kpreid> swhask
16:46:24 <SamB> he says he isn't running a lambdabot backup
16:46:25 <merritt> SamB: lol. sure. it's just that i wondered about it and now can't let go ("that has to work somehow!")
16:46:34 <SamB> sure it can
16:46:39 <kpreid> that reminds me
16:46:46 <kpreid> dons: it would be nice if lambdabot had auto-reconnect
16:46:53 <kpreid> or is there an external thing to do that?
16:47:30 <SamB> hold on while I write it
16:47:51 <merritt> cool :)
16:48:19 <dons> there should be autoreconnect, but: while true  ; do ./lambdabot --online ; done -- also works
16:48:25 <dons> is it disconnecting?
16:48:38 <kpreid> hmm
16:48:42 <dons> (i'm getting rather good uptimes at the moment  - the bot seems to be in a happy place)
16:48:52 <kpreid> I'm pretty sure I've had lambdabot processes sticking around while disconnected
16:49:15 <kpreid> maybe just when it's a passive failure (i.e. nothing tells the bot it's gone)
16:49:41 <dons> oh yes. if there's a bad split then it can be left unconected, and not notice
16:49:43 <kpreid> I'll get that straight later.
16:49:53 <dons> best to kill -TERM then, which will flush the state and restart
16:49:57 <lisppaste2> SamB pasted "fnord.hs" at http://paste.lisp.org/display/29129
16:50:00 <kpreid> (the fix for that of course is for the bot to PING)
16:50:27 <dons> yes. its in there, but seems to have broken somewhere along the way
16:50:39 <SamB> merritt: there it is
16:50:46 <dons> actually, a new ping plugin would be pretty easy to write
16:50:50 <SamB> you stick that in a .hs file and load it up
16:50:54 <dibblego> I'll be releasing some Haskell/CABAL setting files for JetBrains IntelliJ IDEA
16:50:58 <dibblego> under a BSD licence
16:51:17 <kpreid> dons: for such a loop, it would be useful if lambdabot's exit status indicated whether the network connection was dropped, vs. signal/@quit
16:51:34 <kpreid> (so you don't get the "^C ... aaa it won't stop!"
16:52:23 <merritt> SamB: thanks a lot! :)
16:54:58 <dons> kpreid: screen is useful for that
16:55:09 <dons> dibblego: oh yes?
16:55:13 <SamB> merritt: of course, if you want a really interesting datatype, you need to have some more fields or more interesting constructor names
16:55:32 <dibblego> dons, yes I find them useful, so I figure others will too - I'll release it when I publish that document
16:56:15 <dibblego> dons, I use IDEA for haskell by the way - would be awesome with a full plugin
16:56:18 <merritt> SamB: yes
16:57:28 <dibblego> dons, a lot of Java users use IDEA (have you used it?)
16:57:46 <dibblego> if Haskell had a IDEA like Java has...
17:00:05 <dons> i've heard of it. never used it. my java days are many moons ago now
17:01:17 <dons> ?version
17:01:17 <lambdabot> lambdabot 4p255, GHC 6.5 (OpenBSD i386)
17:01:17 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:05:41 <beelsebob> @vixen will kitty tell niko?
17:05:41 <lambdabot> nevermind about that
17:06:16 <beelsebob> @vixen is squishielady sexeh?
17:06:17 <lambdabot> It's all about sex isn't it? :)
17:06:35 <beelsebob> @vixen threesome?
17:06:35 <lambdabot> yes
17:06:51 <beelsebob> @vixen asl
17:06:51 <lambdabot> 19/f/California
17:07:07 <Pseudonym> She's been 19 for some time now.
17:07:09 <beelsebob> @vixen what is the air speed velocity of an unladen swallow?
17:07:09 <lambdabot> Huntington Beach
17:07:11 * lispy waves
17:07:12 <Pseudonym> I suspect she's really in her 40s.
17:07:16 <dibblego> dons, there's some pretty cool stuff for Java - it is such a shame that is can only be applied to Java
17:07:19 <beelsebob> o.O
17:07:37 <lispy> i find programming in Excel in VBA is one of the most frustrating things i've ever doen professionally
17:07:47 <beelsebob> @vixen foursome?
17:07:48 <lambdabot> no
17:07:57 <beelsebob> @vixen orgy?
17:07:57 <lambdabot> no
17:08:01 <beelsebob> booring!
17:08:15 <Renkin> I can do both >map (/2) [2,4,8] and >map (2/) [2,4,8]...
17:08:25 <kpreid> dons: by the way, darcs pull takes a rather long time thinking before it lets me pick patches
17:08:34 <beelsebob> Renkin: correct
17:08:42 <Renkin> But how would I do that with a function divide x y = x / y?
17:08:50 <dons> kpreid: hmm. ok. i'll try an optimise
17:08:56 <dons> you using --partial ?
17:08:58 <Renkin> My question is, how do I only give the second argument to a function, for example.
17:09:01 <Renkin> ?
17:09:08 <kpreid> dons: no idea, how would I tell?
17:09:10 <mux> ?pl \x -> x == 1 || x == 2
17:09:10 <lambdabot> liftM2 (||) (1 ==) (2 ==)
17:09:11 <beelsebob> renkin: flip
17:09:14 <beelsebob> @type flip
17:09:16 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
17:09:18 <lispy> Renkin: map (`divide`2) [2,4,8] and also (2`divide`)
17:09:32 <dons> > let div2 = flip (/) 2 in div2 6
17:09:33 <lambdabot>  3.0
17:09:49 <dons> > let div2 = (/) 2 in div2 6
17:09:50 <lambdabot>  0.3333333333333333
17:09:54 <Igloo> dons: A tag is more likely to help than an optimise, I think
17:10:00 <Renkin> Ok, so there's no operator for applying a function to other arguments than the first?
17:10:05 <Renkin> Or something like that?
17:10:16 <beelsebob> Renkin: yes there is, there's the flip function
17:10:18 <lispy> Renkin: we just showed you two
17:10:20 <kpreid> Renkin: you can always convert between punctuation and letter names using () and ``
17:10:20 <beelsebob> it takes a function
17:10:26 <dons> ?version
17:10:26 <lambdabot> lambdabot 4p255, GHC 6.5 (OpenBSD i386)
17:10:27 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:10:29 <beelsebob> and returns a new one with the arguments the other way round
17:10:33 <dons> ah 250 odd patches since the last tag
17:10:48 <Renkin> Ok, thanks.
17:10:49 <beelsebob> @vixen do you like forcing your hands in?
17:10:49 <lambdabot> yah, i like
17:10:57 <Renkin> I was thinking something along the lines of $
17:11:09 <Renkin> But I guess it's the same, essentially
17:11:38 <beelsebob> @vixen sucky sucky $5?
17:11:38 <lambdabot> who's to say?
17:11:56 <beelsebob> @. elite vixen doom?
17:11:56 <lambdabot> |e7 Me ANzWer thAt 1a+ER, oKAy?
17:11:59 <lambdabot> .oO(this beelsebob guy seems creepy)
17:12:03 <kpreid> > let $$ = flip; divideByTwo = (/) $$ 2 in divideByTwo 10
17:12:03 <lambdabot>  Parse error
17:12:14 <beelsebob> dons: stop that
17:12:16 <kpreid> > let ($$) = flip; divideByTwo = (/) $$ 2 in divideByTwo 10
17:12:17 <lambdabot>  5.0
17:12:20 <Renkin> So for functions with more than two arguments, I'd have to build it myself using flip?
17:12:43 <kpreid> Renkin: build what?
17:12:46 <beelsebob> Renkin: alternatively... write the functions the right way rond
17:12:48 <dons> beelsebob: its not me. anyone with operator privs may control the bot...
17:12:54 <beelsebob> oh... okay
17:13:10 <beelsebob> @vixen was it dons with his hand up your arse?
17:13:10 <emu> \x y z -> f z y x
17:13:10 <lambdabot> nevermind about that
17:13:13 <beelsebob> o.O
17:13:17 <emu> @pl \x y z -> f z y x
17:13:17 <lambdabot> flip (flip . flip f)
17:13:24 <Renkin> kpreid: functions for just applying argument 2 and 3, for example
17:13:35 <Renkin> beelsebob: Yeah, I was just curious :)
17:13:36 <kpreid> flip is for argument 2
17:13:39 <Renkin> I don't really need this
17:13:50 <kpreid> you can define your own for argument 3, as emu showed
17:14:02 <kpreid> @. source index flip
17:14:03 <lambdabot> Prelude
17:14:03 <lambdabot>  not available
17:14:11 <kpreid> @fptools Prelude
17:14:12 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
17:14:18 <kpreid> @source Prelude
17:14:18 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
17:14:23 <kpreid> dons: quirk?
17:14:31 <Renkin> Ok, thanks
17:14:34 <beelsebob> @vixen ice-skating mongooses?
17:14:35 <lambdabot> no
17:15:00 <kpreid> hmf. that doesn't lead to a definition of flip
17:15:12 <Renkin> I'm in the process of "getting" the language, so I'm just trying out stuff
17:15:26 <beelsebob> @vixen sharks with frikin laser beams?
17:15:27 <lambdabot> yes
17:15:32 <lispy> flip f x y = f y x
17:15:52 <dons> fptools == source, yes.
17:15:59 <beelsebob> @vixen leave them in an easily escapable situation and expect that it all went to plan?
17:15:59 <lambdabot> who's to say?
17:16:11 <kpreid> dons: I mean that @. didn't work. stray newline/space?
17:16:20 <dons> ah yes
17:16:23 <kpreid> in which case @source should be more lenient
17:16:25 <lispy> beelsebob: do you mind playing with vixen in a private chat?
17:16:29 <kpreid> > everywhere
17:16:30 <lambdabot>  Not in scope: `everywhere'
17:16:39 <kpreid> dons: also, Data.Generics.{Schemes,Aliases}?
17:16:49 <Renkin> How come just typing a "+" in the interpreter doesn't give me the usual "no instance of Show for..."?
17:16:59 <dons> kpreid: you know how to darcs send ..
17:17:00 <kpreid> Renkin: because it's a syntax error
17:17:04 <kpreid> dons: er, true
17:17:11 <kpreid> dons: I've been out of the habit
17:17:20 <Renkin> kpreid: oh, right, because it's infix?
17:17:28 <Renkin> Argument first
17:17:30 <kpreid> Renkin: exactly. use (+)
17:17:47 <kpreid> Renkin: or if you're using ghci, you can enter ":info +"
17:17:50 <Renkin> Didn't think of that. It's quite obvious now that I do think
17:17:58 <Renkin> Ok
17:25:43 <Renkin> What is a good book on Haskell, intermediate level?
17:26:04 <lispy> ?wiki Books
17:26:04 <lambdabot> http://www.haskell.org/haskellwiki/Books
17:26:12 <Renkin> Ah, thanks.
17:26:22 <lispy> np :)
17:26:28 <lispy> i wasn't sure if it would work
17:26:36 <Renkin> I'm considering getting something to continue with after finishing The Craft of Functional Programming
17:26:41 <Renkin> ok :)
17:27:41 <dibblego> dons, http://xdweb.net/~dibblego/Lambdabot.hs.png it's just basic syntax highlighting - I've considered writing a complete plugin
17:28:23 <Cale> Remember that comments can be nested :)
17:28:28 <kpreid> dons: I see I was confused about Data.Generics; I didn't know it'd been made qualified
17:28:31 <kpreid> therefore I have another generics toy to show
17:29:53 <kpreid> > G.everywhere (G.mkT show) "abc"
17:29:55 <lambdabot>  "\"a\\\"b\\\\\\\"c\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\"\\\"\""
17:30:04 <kpreid> it's a bit like the infamous v, but finite :-)
17:30:54 <dibblego> Cale, are you talking to me?
17:31:03 <Cale> dibblego: hehe, yeah
17:31:14 <dibblego> Cale, why did you say that?
17:31:39 <Cale> Lots of syntax colourers get that sort of thing wrong.
17:32:09 <dibblego> yeah, there are some misnomers that are out of my control - unless I write a plugin
17:32:12 <dibblego> e.g. single quotes
17:32:16 <dibblego> but it gets comments right
17:34:24 <sjanssen> @hoogle choice
17:34:25 <lambdabot> Text.ParserCombinators.ReadP.choice :: [ReadP a] -> ReadP a
17:34:25 <lambdabot> Text.ParserCombinators.ReadPrec.choice :: [ReadPrec a] -> ReadPrec a
17:34:25 <lambdabot> Text.ParserCombinators.Parsec.Combinator.choice :: [GenParser tok st a] -> GenParser tok st a
17:39:08 <lispy> sjanssen: choice :: Illusion
17:39:18 <sjanssen> ha
17:39:39 <dons> anyone want to comment on http://programming.reddit.com/info/ox6s/comments :)
17:39:42 <lambdabot> Title: Ask Reddit: What the hell are monads? (reddit.com), http://tinyurl.com/yd7wrw
17:39:58 <dons> (and not just about IO -- people seem to be stuck on monads = IO)
17:40:19 <kpreid> yes
17:40:35 <kpreid> there should be more examples of practical non-IO monad usage in non-Haskell
17:40:57 <dons> one of the backtracking, cont or error handling monads might be interesting
17:41:11 <dons> since you get features that would normally require special runtime support
17:43:13 <lennart> The IO monad is the one everyone sees first, so it's easy to get stuck there
17:43:46 <chessguy> great explanation by tmoertel
17:44:11 <lispy> yeah, way better than the lame joke below it about Gonads
17:44:32 <lispy> not to mention the inaccuracies of said joke
17:44:34 <chessguy> yeah, that was stupi
17:44:36 <chessguy> d
17:44:39 <lispy> (woman have gonads too)
17:45:35 <lispy> *shrug* i don't think i'm in the target audience for reddit because i find the site to be boring and annoying :)
17:47:07 <lispy> darcs in CL is weird
17:47:09 <palomer> yo my bitches
17:47:20 <SamB> ???
17:47:21 <lispy> too bad the author doesn't contribute to darcs instead :(
17:47:28 <palomer> playing with domains and codomains is fun
17:47:28 <SamB> darcs in CL?
17:47:29 <palomer> weee
17:47:42 <lispy> http://common-lisp.net/project/cl-darcs/
17:47:44 <lambdabot> Title: cl-darcs
17:48:29 <SamB> its hard enough to get it to work *with* a type system
17:48:37 <lispy> heh
17:48:45 <lispy> looks like they don't a lot of work too
17:49:09 <lispy> their reasoning is that ghc is not portable enough
17:49:14 <lispy> interesing
17:50:10 <SamB> they use *svn* for versioning?
17:50:16 <SamB> that is so stupid
17:51:00 <kpreid> howso? if They can't run darcs, and their cl-darcs can't record, etc. yet...
17:51:19 <Smokey`> tmoertel_away: Loving your description of monads :)    I've had a relatively hard time understanding what monads are from the few popular tutorials around, but your description seems to have helped me slighty, with my understanding :)
17:51:19 <SamB> they should develop on a compatible OS!
17:51:24 <lispy> yeah, at least svn can be converted to darcs later
17:54:39 <SamB> hmm, what are MPTCs good for without fundeps?
17:55:25 <kpreid> SamB: monad transformers?
17:55:32 <kpreid> er, wait, that's the *type constructor*, not typeclass
17:55:38 <kpreid> sorry
17:57:10 <sjanssen> kpreid: were you going to patch lambdabot to fix that space issue?
17:57:32 <sjanssen> you don't have to anymore, I've already sent the patch to dons
17:58:03 <lispy> space issue?
17:58:19 <kpreid> with @source? okay
17:58:56 <lispy> ah, not a command i've used
18:01:09 * desrt exhales
18:01:13 <desrt> that was actually sort of fun
18:01:23 <desrt> HOL has taught me that theorem proving doesn't have to suck
18:02:02 <sjanssen> @hoogle randomElem
18:02:03 <lambdabot> No matches found
18:02:52 <desrt> being able to use the theorem prover as a library is fantastic
18:03:13 <desrt> being able to use it as a library from a language like ML is even better
18:03:39 <lispy> desrt: what do you use HOL to help with?  what problem does it solve?
18:03:44 <desrt> having your theorems as first order objects is really nice
18:03:52 <desrt> it was an assignment :)
18:03:53 <dolio> ?fptools Control.Monad.List
18:03:54 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/List.hs
18:04:17 <desrt> we had to prove that m^2 = 2*n^2 ==> m=n=0
18:04:49 <desrt> using a theorem prover of our choosing
18:05:48 <lispy> desrt: hmm...can you use HOL from haskell?
18:06:07 <desrt> i doubt it
18:06:10 * lispy was just wondering if you could use it at run-time in darcs to prove things
18:06:16 <desrt> but porting it would probably not be extremely difficult
18:06:26 <lispy> desrt: how do you use it from ml? is it an FFI thing?
18:06:30 <desrt> no.
18:06:36 <desrt> it's like you get thrown into ghci
18:06:41 <desrt> and you type :m HOL
18:06:47 <desrt> and now you use the library
18:07:11 <desrt> except instead of GHCI it's an ML interpreter
18:07:25 <desrt> and it's not 100% pure (thank god)
18:07:34 <desrt> i guess with haskell you could use global iorefs
18:07:36 <lispy> hmm...so you can't use it programatically?
18:07:40 <desrt> yes.  you can.
18:07:43 <desrt> because of the impurity
18:07:48 <desrt> it has this thing called the 'goal stack'
18:07:50 <dcoutts> dons, it's not obvious to me that the pl-ified code is that much easier. eg, what does that code actually do ?
18:07:56 <desrt> oh.  you said programatically
18:08:04 <desrt> yes.  you can do that to.  it's a normal library.
18:08:11 <lispy> desrt: neat
18:08:19 <desrt> there are two ways of proving things
18:08:24 <desrt> g `theorem`;
18:08:33 <desrt> puts it on the  goal stack (which you interact with via the interpreter)
18:08:44 <desrt> or you can be like
18:09:09 <desrt> val my_theorem = store_thm ("my theorem", `blah blah blah`, THIS THEN THAT THEN FOO);
18:09:15 <desrt> where `blah blah blah` is the theorem
18:09:24 <desrt> and THIS / THAT / FOO are steps in your proof strategy
18:10:02 <desrt> the cool part is that, in addition to applying theorems to prove things, you can manipulate them as first order objects
18:10:18 <desrt> so say i had a theorem that said `p(x) = x**2`
18:10:25 <desrt> and i really would prefer the form x*x
18:10:35 <fik> @type [[],[[]]]
18:10:37 <lambdabot> forall a. [[[a]]]
18:10:37 <desrt> if i have some theorem that says `!n (n**2) = (n*n)`
18:10:53 <desrt> then i can apply that theorem to my `p(x) = x**2` theorem and get a new theorem that says `p(x) = x * x`
18:11:13 <desrt> which might seem pretty boring... but theorems are very special things
18:11:20 <desrt> you cannot create them unless they are true
18:11:26 <desrt> (and you have proven their truth to HOL)
18:12:15 <lispy> desrt: http://hol.sourceforge.net/ ?
18:12:17 <lambdabot> Title: HOL 4 Kananaskis 3
18:12:19 <desrt> yes.
18:12:32 <dons> dcoutts: oh. its not easier. i just expected it to blow up :)
18:12:40 <dcoutts> dons, oh ok :-)
18:13:03 <dons> sjanssen: you worked out the space leak?
18:13:07 <desrt> lispy; there is also "HOL light" that uses o'caml instead of mosML
18:13:15 <desrt> which seems cool to me
18:13:21 <desrt> but the HOL4 one is extremely well documented
18:13:52 <lispy> desrt: i don't see where they talk about the ML interface
18:14:22 <desrt> see the "-"? :)
18:14:32 <desrt> that's an ML interpreter prompt :)
18:15:38 <lispy> ah, i'm not running hol, i was looking at the website
18:16:04 <dons> I tried to convey why monads are interesting in general, here, http://programming.reddit.com/info/ox6s/comments/coxoh   Any comments?
18:16:06 <lambdabot> Title: Ask Reddit: What the hell are monads? (reddit.com), http://tinyurl.com/ylqe7b
18:16:25 <dons> or any other points i missed?
18:16:41 <desrt> oh the irony.
18:17:00 <desrt> 3 days before i get on a plane to go visit the googleplex i get an email from a google recruiter
18:17:09 <dons> desrt: heh
18:17:18 <chessguy> recruiter for what?
18:17:25 <desrt> "google.com engineering team"
18:17:33 <chessguy> hey, that's a nice offer
18:17:54 <dons> ah they like gmail invites? can you pass them around? do you get 100 free to use?
18:17:55 <desrt> i think i'll ask him where his office is and drop in on him while i'm there :)
18:18:03 * desrt chuckles
18:18:06 <chessguy> lol
18:18:18 <desrt> anyway.  i'm officially in a good mood.
18:18:20 <desrt> hol is awesome.
18:18:25 <desrt> i'm going home :)
18:18:37 * Lemmih wonders if there's some way to ban or ignore qwe1234 on reddit.
18:20:24 <chessguy> what the...
18:20:29 <dons> yeah... i suppose they could block his IP. also, you can change the negative score to hide his comments earlier, say -1
18:20:40 <chessguy> is that a 14-line sudoku-solver?
18:20:50 <dons> but you should be able to /ignore particular users
18:21:03 <chessguy> oh, never mind
18:21:22 <dons> you know, we can,  as a community, make programming.reddit.com much more relevant to us .. that's been happening for the last few weeks
18:21:26 <dons> the quality is going up...
18:21:44 <dons> i'm happy if it becomes the place lisp, erlang, ocaml and haskell people go to talk.
18:22:20 <dons> it helps that the FP community is a great source for innovation ..
18:22:21 <SamB> hmm, a presice semantics for imprecise exceptions... how... paradoxical ;-)
18:25:31 <SamB> hmm, I hope they do remove the contexts on "newtype" and "data" declarations...
18:25:51 <SamB> I've thought they oughtn't to be there ever since I found out that they were standard :-(
18:26:45 <sjanssen> @hoogle mkRegex
18:26:45 <lambdabot> Text.Regex.mkRegex :: String -> Regex
18:26:45 <lambdabot> Text.Regex.mkRegexWithOpts :: String -> Bool -> Bool -> Regex
18:27:55 <dons> sjanssen: did you work out the space leak?
18:28:03 * dons gets karma+ ready
18:28:52 <sjanssen> dons: yep
18:30:34 * dons is kept in suspense
18:31:51 <sjanssen> we're talking about the @source issue, yeah?
18:34:35 <dons> hmm?
18:34:42 <dons> space leak? @source?
18:34:57 <sjanssen> what space leak are we talking about?
18:35:29 <dons> oh, as of about a month ago I broke something such that there's a slow space leak, so that our bot here will have over 100M in heap after a week or so
18:35:33 <dons> instead of the usual 10M
18:35:48 <dons> whihc i haven't profiled for yet
18:36:31 <sjanssen> oh, I hadn't heard about that one
18:38:50 <sjanssen> do you have any idea which part of lambdabot it's in?
18:39:30 <dons> no. profiling should make it really clear (after runnign for a day or so). I suspect its in @seen, since that's what I was hacking on at the time
18:39:54 <dons> could also be the contextual stuff, since that's forking a thread on every line of input
18:40:09 <dons> but, -prof knows all
18:40:22 <lispy> -prof is old and wise
18:40:34 <dons> So, who's coming to APLAS next week?
18:40:37 <SamB> dons: you are gathering all these threads when they die?
18:40:55 <shizzy0> APLAS?
18:41:18 <dons> i'm very hesitant to speculate without -prof info
18:41:28 <dons> but there is:
18:41:31 <dons>     doContextualMsg r = lift $ do
18:41:31 <dons>         x <- io $ newIORef []       -- track if any output was made, for offline mode
18:41:34 <dons>         withAllModules ( \m -> do
18:41:36 <dons>             act <- bindModule0 ( do
18:41:39 <dons>                             ms <- contextual m msg alltargets r
18:41:41 <dons>                             io $ modifyIORef x (null ms :)
18:41:44 <dons>                             lift $ mapM_ (ircPrivmsg alltargets . Just) ms )
18:41:46 <dons>             name' <- getName
18:41:49 <dons>             lift $ catchIrc act (debugStrLn . (name' ++) .
18:41:51 <dons>                 (" module failed in contextual handler: " ++) . show)
18:41:54 <dons>             )
18:41:56 <dons>         rs <- io $ readIORef x
18:41:59 <dons>         when (all id rs) $ ircPrivmsg alltargets Nothing
18:42:01 <dons> now, that IORef seems a bit dodgy
18:42:04 <dons> shizzy0: http://www.cse.unsw.edu.au/~aplas06/
18:42:04 <lambdabot> Title: APLAS'06
18:44:27 <SamB> hmm, some of these people make me wonder sometimes...
18:44:29 <dons> mmm, looks like lots of interesting things on the menu, http://www.cse.unsw.edu.au/~aplas06/programme.html
18:44:31 <lambdabot> Title: APLAS'06, http://tinyurl.com/y44lvj
18:44:36 <SamB> "error messages may confuse the novice programmer" indeed
18:44:45 <dons> heh
18:44:50 <SamB> the *lack* of immediate error messages would most likely confuse *me*!
18:44:52 <dons> bugs also can do that
18:45:02 <SamB> http://hackage.haskell.org/trac/haskell-prime/wiki/ExistentialQuantification
18:45:06 <lambdabot> Title: ExistentialQuantification - Haskell Prime - Trac, http://tinyurl.com/y6bk55
18:45:19 <SamB> see the "implicit quantification" proposal
18:46:44 <SamB> I hope they pick one of the ones with "exists"
18:46:57 <Smokey`> nothing more entertaining than an article on Monads, err i mean monsters :)
18:47:09 <SamB> the current overloading of "forall" based on whether it is before or after the data constructor is very bewildering
18:47:28 <SamB> Smokey`: warm fuzzy things
18:47:30 <SamB> ??
18:48:17 <Smokey`> SamB: indeed :)
18:48:31 <sjanssen> dons: running this command "yes 'context http://localhost' | ./lambdabot > /dev/null" makes lambdabot slowly eat memory on my box
18:49:13 <sjanssen> should that run in constant space?
18:50:06 <dons> hmm!
18:50:09 <dons> it should
18:50:29 <SamB> dons: probably it forks too much?
18:50:39 <SamB> not that that is likely all it does
18:51:27 <Smokey`> lambdabot likes memory, it makes him happy when he eats memory...     You're... not gonna let lambdabot starve ... are you? ;)
18:51:50 <dons> sjanssen: so yes, that contextual handler should really be running in constant space
18:52:39 <Igloo> What does context do?
18:53:03 <dons> its the handler for non-command 'commands'
18:53:13 <dons> so e.g. http://google.com
18:53:16 <lambdabot> Title: Google
18:53:36 <dons> which means that its doing some processing on every line of input, so it better run in constant spcae (which it did, but maybe i broke it :)
18:54:01 <SamB> dons: are you collecting the dead threads?
18:54:09 <SamB> or is that not needed?
18:54:18 <dons> shouldn't be needed
18:54:25 <SamB> also, why are you forking threads?
18:54:26 <dons> they can just finish when they finish
18:54:33 <dons> async processing
18:54:42 <SamB> how is that useful?
18:54:48 <dons> you don't want to be held up here because some bozo is doing something in #scheme :)
18:55:08 <dons> i suppose we could have a dedicated contextual handler thread
18:55:26 <dons> would be nicer (though its not like performance is an issue yet)
18:55:28 <Igloo> Hmm, I keep meaning to write some infrastructure for memory-use and time-complexty tests
18:55:55 <sjanssen> how does one build lambdabot with profiling?
18:56:15 <dons> use the -prof -auto-all  ghc-options: line in the cabal file
18:56:30 <SamB> why does lambdabot even have a cabal file?
18:56:38 <dons> umm...
18:56:38 <SamB> someone told me it is just a glorified shell script
18:56:49 <SamB> compared to what cabal files are *supposed* to be
18:56:56 <dons> i think you misunderstand that remark ;)
18:57:07 <dons> yes, it has a monadic cabal file
18:57:18 <dons> but it was my evil twin who wrote that
18:57:36 <SamB> the Makefile worked better, I think, though :-(.
18:58:03 <dons> it was a lot more complex and difficult to maintain. if you had to do that, you'd not be saying the makefile was better ;)
18:58:04 <Igloo> "cabal file" meaning Setup.hs?
18:58:10 <dons> meaning foo.cabal
18:58:22 <Igloo> In what sense is it monadic?
18:58:30 <dons> (the order of executable: entries is significant .. there's a dependency)
18:58:36 <Igloo> Ah
18:58:48 <dons> it builds a preprocessor first, which other executables use with -pgmF
18:58:55 <Igloo> Does --enable-profiling, or whatever it is, not work for executables?
18:58:57 <SamB> yes, but the cabal file does not WORK
18:59:13 <dons> SamB: is that idle speculation on your part? or do you have a bug report
18:59:16 <SamB> at least in the sense that it won't build the linkless version
18:59:38 <SamB> unless you fixed that and didn't tell me?
18:59:39 <dons> the cabal file works for what it was written to do
18:59:43 <Igloo> linkless?
18:59:52 <dons> so "not work" here you mean "doesn't do everything the old makefile did"
18:59:54 <SamB> well, relatively
19:00:23 <SamB> the proper dynamic build
19:00:26 <dons> sometimes SamB, I get the feeling you like to complain. more patches to complaints would be nice...
19:01:20 <SamB> well, *I* couldn't figure out how to do it *either*
19:01:32 <SamB> :-(
19:02:17 <Igloo> Well, I suspect you want cabal configurations to make it easy
19:02:21 <dons> oh, its not too hard. just build lambdabot as a libHSlambdabot.a library, and then have an executable that dyn loads that
19:02:40 <Igloo> Ah, I assumed you needed to compile a different way
19:02:43 <dons> it can be done in the cabal file, even .o loading from dist/build, but i've just not been bothered enough to do it
19:02:52 <dons> nah. cabal is fine
19:03:05 <dons> SamB: you see?
19:03:17 <SamB> mmm.
19:03:18 <sjanssen> there isn't a cabal option to build with profiling?
19:03:25 <dons> so, library: everything in Plugins/* and lamdabot itself. then an executable: Main.hs
19:03:26 <SamB> I don't really know how to use cabal.
19:03:35 <dons> then, ./lambdabot just loads objects from dist/build/*.o
19:03:43 <dons> sjanssen: oh, yes, -p to configure
19:03:43 <dibblego> I don't either
19:03:51 <Igloo> Hmm, is cabal really full of system calls?
19:03:55 * Igloo looks a little nervous
19:04:00 <dibblego> I don't know how to have a package dependency without this thing called hackagedb
19:04:13 <dons> depends: mylib
19:04:20 <dons> what's hackagedb got to do with it?
19:04:30 <SamB> dons: how to I get it to really load the plugins dynamically, though?
19:04:32 <dibblego> that's where you put your dependencies apparently
19:04:49 <dons> SamB: you look at Boot.hs
19:04:51 <Igloo> No, that's where clever tools could find your dependencies for you
19:04:53 <dibblego> and I can't find any options to do it from the disk
19:04:58 <SamB> see, I keep remembering what I ran into
19:06:21 <dibblego> if I import modules from some other package, how do I compile with cabal?
19:09:10 <dons> Cale, et al, can we add to this list: http://haskell.org/haskellwiki/Monad#Monads_in_other_languages
19:09:14 <lambdabot> Title: Monad - HaskellWiki, http://tinyurl.com/wrsvq
19:09:20 <dons> i have:
19:09:21 <dons>   * JavaScript
19:09:21 <dons>   * Scheme
19:09:21 <dons>   * C++
19:09:21 <dons>   * OCaml
19:09:23 <dons> so far
19:10:08 <Igloo> Any reason for the unlinked entries, dons?
19:10:20 <dons> lennart: nice idea, -funfolding-use-threshold=16
19:10:22 <dibblego> FYI, the C++ link gives 404
19:10:25 * Igloo would put them in a separate list, at least
19:10:27 <dons> Igloo: as suggestions for people to find it ...
19:10:36 <jgrimes> what support for SOAP is available for haskell? I couldn't find anything under libraries and tools.
19:10:43 <dons> fixing, dibblego thanks.
19:11:24 <jgrimes> except for HAIFA
19:11:29 <dons> Igloo: done.
19:11:48 <dons> Lemmih++ -funfolding-use-threshold=16
19:12:00 <dons> lennart: though my suggestion was really to "read the Core", not "use unboxing" :)
19:12:00 <jgrimes> which says it has a partial implementation of SOAP 1.1
19:12:12 <palomer> weird
19:12:16 <palomer> I can't work without music
19:12:21 <palomer> my psyche is too screwed up
19:21:04 <SamB> dons: so how *do* you recompile Modules.hs with a list of dynamic modules?
19:21:50 <dons> how would you do it? /me sees a learning opportunity
19:22:57 <SamB> you are just trying to trick me into figuring it out for you?
19:23:13 <SamB> I'll probably come up with something like "the maintainer must edit it manually"
19:23:19 <skew> dons, I was wondering why the fused Data.ByteString programs are any slower than C with read and explicit buffers.
19:23:40 <dcoutts> skew, we don't use mutable buffers
19:24:01 <dcoutts> so we need to allocate new buffers and let the GC collect old ones, that has a small cost.
19:24:01 <SamB> then again, C isn't usually fused
19:24:54 <skew> ah, you don't reuse the same buffer when folding results from getContents
19:25:12 <dons> yep. fusable Handles are one way to help (as would be seekable io). improving GHC's C-- layer with imperative optimisatoins like PRE would help too (rl is working on this)
19:25:12 <dcoutts> skew, no, we'd like to but we don't at the moment
19:25:37 <dcoutts> yeah, there's lots of low level stuff where gcc is still faster
19:25:40 <skew> you'd need some kind of uniqueness analysis, or fusing all the way through to getContents
19:25:43 <dcoutts> tight loops etc
19:25:48 <skew> I figured gcc was better at the low level stuff
19:25:59 <dcoutts> skew, no, we just need rules to be able to match it
19:26:13 <SamB> heh
19:26:18 <SamB> GCC sucks
19:26:34 <SamB> it is *stuck* with code that it can't have much hope of making sense of
19:26:43 <dcoutts> skew, if we've got a direct 'f =<< hGetContents' then there's no uniqueness to worry about
19:26:47 <SamB> or rather, it sucks to be GCC
19:26:59 <dcoutts> true, but it still does a pretty good job
19:27:13 <skew> SamB: still, I think it's better at optimizing inner loops than GHC
19:27:25 <dcoutts> right
19:27:38 <skew> GHC is great at turning beautiful function programs into tight loops, then is just goes "huh?" and punts
19:27:42 <Lemmih> dons: Sorry, I misunderstood.
19:28:05 <dcoutts> and gcc knows a lot about the architecture, which makes a difference at the low level with small loops
19:28:07 <skew> at least, that's the impression I've gotten from people who actually work on that stuff
19:28:38 <dons> yeah, so rl (our co-author) is right now writing a C-- -> SSA and back pass, and an example partial redundancy pass over SSA in GHC. the idea then would be that GHC's asm backend will get some highly tuned loop code to spit out, and gcc won't even be needed in the longer term (couple of years or so)
19:28:42 <SamB> it would be more effective in its punting if it would use "while" and "for" loops in C...
19:29:07 <dcoutts> SamB, it doesn't scale I think
19:29:07 <SamB> GCC can make better code for those
19:29:22 <SamB> dcoutts: I suppose not
19:29:25 <dcoutts> ie you could do while for some trivial things but ...
19:29:47 <SamB> but trivial loops are where the performance would be most sorely missed, no?
19:29:58 <dcoutts> C-- with it's explicit jumps / cut-to stuff is better for that
19:30:31 <dcoutts> the C backend is actually a constraint on ghc's code quality
19:30:56 <dcoutts> we could do better if we didn't have to produce C
19:31:09 <skew> I really enjoyed the Rewriting paper, largely because it's the first example I've seen where a high-level, general purpose language actually does end up with better performance than low level code, because it understands and optimizes things better
19:31:11 <SamB> hmm. Cabal is not complaining about all these modules I didn't list in the Exposed-modules: list...
19:31:20 <SamB> or anywhere else.
19:31:33 <dcoutts> SamB, it doesn't check, however they will not be exposed
19:31:50 <SamB> I think it ought to :-(.
19:32:05 <dcoutts> SamB, add a proper dep analysis stage to cabal
19:32:15 <dcoutts> currently it just relies on ghc --make
19:32:42 <dcoutts> skew, glad you liked it :-)
19:36:37 <skew> I've been thinking for a while that if you start with C and try to build any sort of abstraction you should lose to a higher-level language, because you'll always have to pay costs for things like uniform data representations, running pipeline stages separately and that sort of thing
19:37:14 <dibblego> dons, I would point CABAL to the .cabal file of the package that it depends on (on the disk) so that it can build it if required
19:38:23 <SamB> wait a minute
19:38:25 <SamB> this ain't gonna work
19:38:40 <dibblego> or the base directory containing package.cabal
19:38:41 <SamB> the library stuff has to be in the first part, rightr?
19:38:43 <SamB> er.
19:38:44 <SamB> right?
19:39:06 <dons> skew: thanks. that's a good point.
19:39:09 <dibblego> in the .cabal file?
19:39:20 <dibblego> yes
19:39:21 <dons> it's because the compiler can know more about what the code is doing
19:39:36 <SamB> so, this BotPP thing can't be built befor ethat!
19:39:39 <dibblego> if you were using my IntelliJ IDEA syntax highlighter, it would highlight those options for you :)
19:39:46 <skew> dcoutts, dons: do you know how the Data Parallel Haskell work is going? If they are actually targeting SIMD instructions it would be very interesting to tap into that for the ByteString operations.
19:40:05 <dons> its coming along, but its a one man job basically.
19:40:06 <dcoutts> I'd ask rl
19:40:06 <SamB> dibblego: I doubt it runs in Emacs...
19:40:09 <SamB> somehow
19:40:11 <dons> the compiler support is there for sparc
19:40:17 <dibblego> SamB, prolly not
19:40:19 <dons> just need to finish the gang threads and library
19:41:04 <dons> s/rl just needs/
19:41:08 <dons> (not me!)
19:41:14 <chessguy> so is there really no way to trace the execution of my haskell program? somehow see the intermediate steps?
19:41:18 <SamB> Am I the only one who thinks this may not be good?
19:43:08 <dibblego> ok, so I just found build-depends
19:43:13 <palomer> chessguy, hat
19:43:46 <chessguy> paolomer, shoe
19:43:54 <dons> chessguy: using hat or profiling. or hpc
19:44:00 <dons> or a tracing monad perhaps?
19:44:30 <palomer> tracking monad sounds hot
19:44:33 <chessguy> hmm, a tracing monad sounds interesting
19:44:44 <palomer> does anyone use monad transformer transformers?
19:45:11 <skew> they seem to use "vectorization" to talk about flattening a program on nested parallel arrays to work on segmented arrays
19:45:13 <dibblego> does ./Setup.hs install put the files in the link path?
19:45:31 <lispy> dons: can lambdabot be set to ignore people?  i juts had my lambdabot get into a bot fight...
19:46:25 <lisppaste2> chessguy pasted "speaking of monads..." at http://paste.lisp.org/display/29136
19:46:26 <dons> heh no. we don't have support for that.
19:46:35 <dons> but you can add it to the code where lambdabot ignores itself
19:46:50 <chessguy> someone suggested that it would be more haskell stylish to use a monad for the tree functionality here
19:46:57 <chessguy> anyone agree? what would be the benefit?
19:47:24 <skew> chessguy: have you seen Oleg's zipper stuff?
19:47:48 <chessguy> in ocaml?
19:47:55 <skew> or Haskell
19:48:07 <chessguy> i think the code i saw of his was in ocaml
19:48:19 <skew> you can avoid defining the Context type if you use monads a bit
19:48:41 <lispy> hmm...oleg does ocaml?  i didn't think ocaml's type system was turing complete :)
19:48:43 <chessguy> to store state, or what?
19:49:05 <skew> you write something like mapTree :: (a -> m b) -> Tree a -> m (Tree b),
19:49:27 <chessguy> in place of what?
19:49:29 <skew> and then if you use that with m being a delimited continuation monad you can turn the traversal inside-out
19:50:02 <skew> http://okmij.org/ftp/Computation/Continuations.html#zipper
19:50:03 <chessguy> mmm, ok, probably not the best place for a n00b monad-writer
19:50:05 <lambdabot> Title: Continuations and delimited control, http://tinyurl.com/y3rsg5
19:50:09 <dibblego> oh yay, I figured out how to have a build dependency
19:50:21 <skew> the delimited continuation monad alone was worth a few papers.
19:50:47 <dibblego> but can CABAL be pointed to the source to automatically build it?
19:51:21 * SamB suggests asking xerox about that
19:51:35 <lispy> dibblego: not that i'm aware of, but that could be a nice feature
19:51:45 <dibblego> lispy, righto ta
19:51:47 <chessguy> xerox is the one that suggested a zipper to me
19:51:58 <skew> this one in particular http://okmij.org/ftp/Haskell/Zipper1.lhs
19:52:01 <chessguy> except he point me to the haskell wiki page on it
19:52:05 <SamB> I was talking about dibblego's question
19:52:22 <skew> chessguy: there's also something I'm trying to find about turning a fold inside-out
19:52:25 <dibblego> xerox, can CABAL be pointed to the source to automatically build it?
19:52:36 <skew> ah, here on the same page: http://okmij.org/ftp/Computation/Continuations.html#enumerator-stream
19:52:39 <lambdabot> Title: Continuations and delimited control, http://tinyurl.com/yy4gm4
19:52:52 <SamB> xerox may be sleep ing at this time
19:52:59 <SamB> @localtime xerox
19:53:00 <lambdabot> Local time for xerox is Thu Nov  2 04:52:37 2006
19:53:01 <dons> dibblego: no. there's no "meta" cabal. cabal-get and so on are proposals to do that though
19:53:06 <dibblego> would be good if it could instrument for the coverage tool as well
19:53:10 <dons> you currently have to build the dependencies by hand
19:53:11 <dibblego> dons, ok ta
19:53:37 <SamB> whatever that thing is called, xerox was working on it last I knew
19:54:12 <lispy> what is ta short for?  i know it roughly means, "thank you" but i can't figure it out
19:54:31 <lispy> SamB: you're thinking of cabal-get or cabal-install or something?
19:54:59 <SamB> lispy: whichever it is called
19:55:33 <dons> we need a list of monads on the wiki too
19:55:45 <dons> from Identity to NonDet and DelimitedCont
20:00:37 <dibblego> http://xdweb.net/~dibblego/idea-haskell/Lambdabot.hs.png & http://xdweb.net/~dibblego/idea-haskell/lambdabot.cabal.png
20:00:41 <lambdabot> http://tinyurl.com/y7fpam
20:02:50 <nocotigo> :) so, haskell is blowing my mind.  anybody got a tutorial a lowly ruby guy might comprehend?
20:03:36 <dons> yaht is a good place to start
20:03:38 <dons> ?where yaht
20:03:38 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
20:03:45 <dolio> I like all the answers to "What the hell are monads?" by people who don't really know what monads are. :)
20:03:49 <dons> also, there are some textbooks listed on http://haskell.org
20:03:51 <lambdabot> Title: Haskell - HaskellWiki
20:04:02 <dons> nocotigo: welcome! we like ruby hackers. they love code!
20:04:07 <nocotigo> i do
20:04:18 <nocotigo> and i have a feeling i'll love haskell after a bit
20:04:21 <dons> > map (^2) [1..] -- a free infinite list for you!
20:04:22 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
20:04:30 <nocotigo> haha
20:04:31 <dolio> nocotigo: You could look at the recently done rubyquiz answers in haskell and compare them to the ruby solutions. :)
20:04:38 <dolio> I don't know how instructive that'd be.
20:04:41 <dons> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs) -- or some fibs
20:04:42 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
20:04:51 <dibblego> dolio, I replied to one earlier that attempted to explain it using gonads
20:04:52 <dons> ah yes, the ruby quiz answers
20:04:55 <nocotigo> seems like you really can do a lot with a small amount of code
20:04:57 <dons> ?where haskell-quiz
20:04:58 <lambdabot> I know nothing about haskell-quiz.
20:05:02 <dons> ggrr
20:05:05 <dolio> dibblego: Heh, yeah, I noticed. :)
20:05:22 <dons> ?where+ haskell-quiz http://haskell.org/haskellwiki/Haskell_Quiz
20:05:23 <lambdabot> Done.
20:05:23 <dolio> ?wiki haskell quiz
20:05:24 <lambdabot> http://www.haskell.org/haskellwiki/haskell quiz
20:05:28 <SamB> that makes more sense than the "monads and the Catholic Church" thing
20:05:31 <SamB> I think
20:05:42 <dons> nocotigo: yep. definitely. probably more concepts in less code than just about anything else.
20:06:02 <dons> there's a ruby-ish love of conciseness in the haskell community, you'll find
20:06:17 <dons> ?where haskell-quiz
20:06:17 <lambdabot> http://haskell.org/haskellwiki/Haskell_Quiz
20:06:29 <nocotigo> thanks for all the links
20:06:32 <nocotigo> :)
20:06:39 <lispy> dons: don't we already have LtU, do we really need reddit too? ;)
20:06:43 <dons> the main place to start is http://haskell.org, and hang out here for advice
20:06:45 <lambdabot> Title: Haskell - HaskellWiki
20:06:55 <dons> lispy: well, i like the interactivity of reddit more. its faster and cleaner
20:07:01 <dibblego> if you can do a lot more with a lot less, then what exactly is all that extraneousness representing?
20:07:04 <dons> LtU is a bit old school
20:07:06 <Igloo> I think there's a language called J or something which denser, but complete gibberish if you don't know the language
20:07:14 <nocotigo> haha
20:07:24 <nocotigo> if you can't tell what encoding the code is in
20:07:29 <nocotigo> i'd say you've gone too far
20:07:34 <dons> yeah, denseness isn't the best feature. perl can be dense too. its more about concept-richness
20:07:42 <dons> heh
20:07:56 <dons> ?remember nocotigo if you can't tell what encoding the code is in, i'd say you've gone too far
20:08:08 <dibblego> if you .tar.gz a .hs file, it's still the same information
20:08:14 <dibblego> there is no lossiness
20:08:25 <dolio> quicksort =: ($:@(}.#~{.>:}.),{.,[:$:}.#~{.<}.)`]@.(2:>#)
20:08:26 <dons> :) well, a bit, but yeah, that's something.
20:08:30 <dons> is htat J?
20:08:35 <dolio> That's J.
20:08:42 <nocotigo> wow
20:08:49 <dolio> glguy's pathological example, I think.
20:08:49 <dons> looks almost like an obfuscated version of the haskell pivot-based quicksort?
20:08:57 <nocotigo> the only thing worse would have to be BF
20:09:13 <lispy> ?bf ($:@(}.#~{.>:}.),{.,[:$:}.#~{.<}.)`]@.(2:>#)
20:09:14 <lambdabot> Done.
20:09:22 <lispy> doesn't seem to be valid bf ;)
20:09:24 <dons> not bf.
20:09:27 <lispy> or at least bf that does output
20:09:28 <nocotigo> haha
20:09:36 <dons> seems close to, qsort (x:xs) = qsort (filter (< x) xs) ++ [x] ++ qsort (filter (>= x) xs)
20:09:37 <nocotigo> <<<>>><<<<>>>....<<>>><>||
20:09:39 <dons> doesn't it?
20:09:39 <nocotigo> or... something
20:09:54 <lispy> ?bf <<<>>><<<<>>>....<<>>><>||
20:09:54 <lambdabot> Done.
20:09:58 <Igloo> Yeah, it is J, e.g. "Find the sum of digits in 100!" is +/"."0":!100x
20:10:03 <dons> ?let qsort []     = []
20:10:04 <lambdabot> Defined.
20:10:10 <dons> ?let qsort (x:xs) = qsort (filter (< x) xs) ++ [x] ++ qsort (filter (>= x) xs)
20:10:11 <lambdabot> Defined.
20:10:20 <dons> > L.qsort "haskell"
20:10:21 <lambdabot>  "aehklls"
20:11:12 <lispy> is there a good web browser for osx?
20:11:27 <dibblego> if you gzipped a .hs file, you'd have something similar to PERL
20:11:30 <nocotigo> camino? safari?
20:11:53 <lispy> nocotigo: i could try camino...safari doesn't do gmail correctly :(
20:12:00 <SamB> dibblego: except usually perl at least sorta resembles a text file
20:12:10 <SamB> in terms of not containing random binary
20:12:29 <dibblego> | base64-encode :)
20:12:35 <dons> nocotigo: so you have ghc installed on your box yet?
20:12:44 <nocotigo> dons: yup
20:13:00 <dons> nocotigo++ Level 1 completed.
20:13:44 <nocotigo> wooo
20:13:46 <dibblego> lispy, the OSX zealots around here rant on about Safari
20:14:32 <nocotigo> any browser that does acid2 correctly is ok by me
20:14:51 <dibblego> acid is flawed, welcome to the pure FP world friend
20:14:53 <nocotigo> i can't believe firefox isn't going to be there until 3.0
20:15:07 <nocotigo> dibblego: what's pure fp?
20:15:29 <dibblego> pure functional programming - where you are not permitted to update!
20:15:40 <lispy> well, you can update
20:15:47 <lispy> but not destructively!
20:15:55 <lispy> we objects not war!
20:16:00 <lispy> er we make objects not wark
20:16:06 * lispy gives up on typing
20:16:06 <SamB_XP> wark!
20:16:08 <SamB_XP> wark!
20:16:14 * SamB_XP chocobos
20:16:14 <lispy> wark!
20:16:26 * lispy puts the good little SamB_XP
20:16:32 <lispy> s/puts/pets/
20:16:44 <nocotigo> it does feel strange that there's no update operator
20:16:53 * dibblego puts the keys back in the right places on his keyboard
20:17:01 <dibblego> (lispy's keyboard) even
20:17:22 <lispy> dibblego: good luck, i use dvorak and have swaped some other keys!
20:17:35 <lispy> gah, but the main problem i'm having tonight is that my ibook is laggy
20:17:40 <dons> nocotigo: get in there a bit more, you'll find mutable state reappears after a while ..
20:17:48 <dibblego> nocotigo, if time were not infinitely divisible (Newton's flawed model), you could consider each time unit as passing the entire universe along separated only by a delta from the last
20:17:48 <dons> its a useful concept :)
20:18:10 <nocotigo> the idea that it doesn't matter what order things happen in is awesome
20:18:17 <dons> yeah
20:18:17 <nocotigo> everything's just properties of another thing
20:18:23 <nocotigo> i dig that already
20:18:23 <dons> since then you can make up the rules
20:18:43 <dons> (i.e. this is what the famous monads are for: making up the rules by which you wan tthings to evaluate)
20:19:00 <dons> but more on that in a few days
20:19:01 <nocotigo> so flow is more based on what is in the objects than like
20:19:01 <dons> :)
20:19:07 <nocotigo> hmmm
20:19:09 * nocotigo reads on
20:19:24 <dibblego> remember that haskell is lazily evaluated
20:19:35 <dons> read on! read on!
20:19:39 <dibblego> ?type readFile
20:19:40 <SamB_XP> I think he digs that, dibblego ;-)
20:19:40 <lambdabot> FilePath -> IO String
20:20:01 <Cale> Things actually do happen in one particular order in most implementations :)
20:20:15 <Cale> (but the language spec doesn't specify)
20:20:17 <SamB_XP> Cale: yeah, so?
20:20:19 <dibblego> s/implementations/Turing machines (if you will)
20:20:34 <Cale> Well, you do end up caring from time to time :)
20:20:44 <SamB_XP> the "things" that "happen" don't do much, usually
20:21:00 <Cale> Of course I agree that largely, you don't care, and that that's awesome :)
20:21:08 <dibblego> you only care because of some failure of abstraction if you ask me
20:21:14 <SamB_XP> yeah
20:21:23 <dibblego> you should be abstracted from that machine - so you can focus on representing software
20:21:24 <SamB_XP> like the fact that you don't actually have unbounded RAM
20:21:29 <nocotigo> there's a zen to this
20:21:30 <nocotigo> haha
20:21:40 <nocotigo> its not assigning a value
20:21:47 <nocotigo> its asserting that this has always been this
20:21:48 <Cale> right, it's a definition
20:21:49 <nocotigo> and always will be this
20:21:50 <nocotigo> hahaha
20:21:52 <nocotigo> i like it
20:21:56 <Cale> It's just like in mathematics
20:22:21 <dons> yeah, mutating a value under the hood is a nasty hack that we got sort of stuck with 50 years ago :)
20:22:30 <dons> its useful, but not a fundamental language feature
20:22:40 <dons> and gets in the way once you want to paralleise the code
20:22:45 <SamB_XP> not for a high-level language, no!
20:23:06 <SamB_XP> probably not even in GRIN
20:23:14 <nocotigo> the shower calls, but i'll be back thereafter
20:23:21 <nocotigo> thanks
20:23:36 <Cale> Just like in mathematics, you don't care about what order calculations happen in in order to say what something means, but there's a practical side to mathematics as well where you actually simplify things down and work out their values, and that's where the practical considerations of time and space come in :)
20:23:38 <dibblego> I prefer Backus' term - the von Neumann bottleneck
20:26:57 <dibblego> fps exists so that you have contiguous memory and so a performance enhancement, but it seems Data.Arary does the same thing?
20:27:11 <dibblego> *Data.Array
20:27:45 <SamB_XP> FPS does IO, though!
20:27:54 <SamB_XP> and Data.Array doesn't do nearly so many things
20:28:20 <SamB_XP> also, Data.Array itself is basically the H98 Array module
20:28:49 <lispy> dibblego: fps is specialized to byte strings too
20:29:03 <dons> dibblego: think of fps as a Word8-only new generation array library, with a much nicer interface than Data.Array
20:29:11 <dibblego> ah ok
20:29:17 <dons> the full DPH Array library generalises the fps arrays to arbitrary types
20:29:37 <SamB_XP> oh the day!
20:29:42 <dons> also, sjanssen has written Storable a => Vector a, providing bytestring-like interface to any type that can be unboxed
20:29:57 <dons> so, these are probably where the ArrayNG (tm) is heading
20:30:07 <dons> since we really want a list-like interface to arrays
20:30:17 <dons> and better perf, layered over fusion
20:31:03 <chessguy> sometimes i wonder if i'll ever understand more than 1 or 2% of what you guys talk about
20:31:15 <dibblego> lol same
20:31:19 <lispy> chessguy: yes you will
20:31:28 <SamB_XP> you must surely do already!
20:31:36 <sjanssen> chessguy: maybe you would, if we reduced our output to less than 99% bullshit ;)
20:31:40 <lispy> chessguy: i didn't used to have a clue, but dons was just speaking english to from my POV! ;)
20:31:43 <dibblego> I sometimes wonder if type classes really are broken or if there is something I am missing
20:31:54 <dibblego> but I'm holding out on my perspective until I can be sure
20:31:54 <dons> sjanssen: heh
20:32:00 <SamB_XP> probably they are a bit broken
20:32:00 <chessguy> SamB, i very much doubt it
20:32:02 <SamB_XP> crippled at least
20:32:16 <dons> chessguy: if things don't make sense, please say so.
20:32:19 <lispy> dibblego: think of them as interfaces
20:32:29 <dibblego> it seems you should pass (a -> a -> Bool) instead of constraining a to Eq for example
20:32:31 <chessguy> dons, i'd be saying so every other minute :)
20:32:31 <dons> notethat we've been at this for the last 5 years, so somewhere along the line we forgot what we didn't know :)
20:32:37 <Cale> dibblego: how are they broken?
20:32:42 <dibblego> lispy, interfaces (as we know them) are definitely broken
20:32:44 <Cale> dibblego: yeah, that's what it's equivalent to
20:32:44 <SamB_XP> dibblego: oh, that is what the "by" functions are for
20:32:50 <dibblego> Cale, but it's not equivalent
20:32:54 <Cale> huh?
20:33:06 <SamB_XP> Cale: you can't just pass in any old dictionary
20:33:06 <Cale> It's translated into that by the compiler
20:33:12 <dibblego> SamB, yes I saw those - reaffirming my belief
20:33:16 <dibblego> brb
20:33:23 <Cale> If you want it that way, you can write it that way :)
20:33:51 <lispy> dibblego: do you know why 'type class' is a good name for them?
20:33:59 <chessguy> ooh, you know what i should do?
20:34:01 <lispy> dibblego: because understanding that helped me understand how to uset them
20:34:13 <chessguy> work through SICP using haskell
20:34:13 <Cale> The whole point of typeclasses is to single out an instance. Now, you might argue we need better scoping constructs for instances and I'd possibly agree with that. :)
20:34:29 <SamB_XP> chessguy: huh?
20:34:30 <SamB_XP> how?
20:34:36 <SamB_XP> I mean, how is that what you should do?
20:34:44 <SamB_XP> not how would you do it -- that wouldn't be hard
20:34:54 <chessguy> it would be good experience
20:34:57 <lispy> Cale: i think we need an OO system instead of Modules...that's probably what i would work on changingin the languge if i were to modify it
20:35:05 <chessguy> and maybe a good resource for someone else
20:35:19 <jgrimes> sigfpe's article on geometric algebra for free was somewhat enlightening about some of the cool stuff you can get for free with type classes. Though I don't really know how to apply it outside of the scope of his article.
20:35:26 <lispy> chessguy: create a darcs repo of your code
20:35:32 <Cale> lispy: how much of an OO system?
20:35:45 <chessguy> you mean my SICP code?
20:36:02 <chessguy> i don't really have a spare http server handy
20:36:02 <lispy> Cale: currently, a lot of module use seems to be using them roughly the way you'd use singleton objects
20:36:13 <lispy> Cale: if that helps to make sense
20:36:20 <Cale> er, no it's not :)
20:36:25 <Cale> :)
20:36:36 <Cale> In particular, modules don't have state
20:36:39 * lispy tries to think how to articulate
20:36:47 <lispy> Cale: they can!
20:36:51 <lispy> Cale: CAFs
20:36:59 <SamB_XP> come on!
20:37:00 <Cale> CAFs aren't state, they're constants
20:37:09 <lispy> Cale: what's the difference?
20:37:17 <chessguy> i'd be glad to send the code to someone who does have a darcs repo though
20:37:22 <Cale> the difference between constants and mutable variables?
20:37:52 <dibblego> lispy, yes I do - but I'll reserve my perspective until I can argue it completely - which I can't
20:37:53 <lispy> Cale: okay, well, haskell98 aside, we can have state in modules
20:38:26 <Cale> Only via unsafePerformIO, which I wouldn't consider as part of any language discussion. It's more of a way to modify the language than part of it.
20:38:38 <dibblego> I find it reassuring though that I predicted such things, then came across the *By functions
20:38:40 <jgrimes> what is a CAF?
20:38:50 <lispy> Cale: but, that's unfair given that people do it in the existing libraries
20:39:00 <dons> found some more, http://haskell.org/haskellwiki/Monad#Monads_in_other_languages (a lot more)
20:39:03 <lambdabot> Title: Monad - HaskellWiki, http://tinyurl.com/wrsvq
20:39:07 <Cale> lispy: I'd argue that they shouldn't.
20:39:22 <Cale> Even the use in the Random library is dubious.
20:39:28 <lispy> Cale: and if they had objects instead of modules,i don't think they would nee dit
20:39:47 <Cale> I think singleton objects are essentially design flaws.
20:39:51 <jgrimes> nevermind.
20:39:54 <jgrimes> figured it out
20:39:55 <lispy> Cale: consider if a module was first class and could be parameterized when created
20:40:05 <lispy> 'created'
20:40:15 <lispy> when 'loaded' if you prefer
20:40:17 <SamB_XP> lispy: you mean imported?
20:40:21 <lispy> sure
20:40:25 <Cale> Okay, mutable state aside, what would that mean?
20:40:50 <lispy> well, what if you could put such a module in to a state monad and 'update'it as needed
20:40:55 <Cale> Suppose there are no top-level mutable state values, since I will not change my mind that those are a terrible idea.
20:41:24 <lispy> also, consider the module hierarchy
20:42:05 <lispy> Data.* for example seems in some places like hierarchy of collection classes
20:42:33 <SamB> it is an illusion
20:43:11 <lispy> Cale: if module became first class and parameterizable I suspect they would then do all the useful things that objects do
20:43:15 <Cale> Would modules be types?
20:43:20 <lispy> Cale: with the possible exception of polymorphism
20:44:02 <Cale> I'm not entirely clear on what you're actually suggesting still...
20:44:09 <dibblego> I don't think singleton objects can exist
20:44:20 <dibblego> they are an illusion
20:44:43 <lispy> Cale: currently first class module doesn't make a lot of sense because there isn't much you'd want to do with one
20:44:51 <Cale> dibblego: oh, they can exist, they're just a design flaw :)
20:44:59 <dibblego> Cale, I don't believe that is the case
20:45:01 <lispy> Cale: but once we start parameterizing them, you'd probably want to have multiple of instances of the same module
20:45:07 <dibblego> Cale, show me one
20:45:27 <Cale> dibblego: In which language?
20:45:30 <lispy> Cale: and you'd want to start holding them in lists and so on
20:45:35 <dibblego> Cale, select one
20:45:39 <SamB_XP> dibblego: you were looking for ML?
20:45:41 <jgrimes> I'm having trouble getting a lambdabot to register with nickserv. What steps should have been done to get it to do this?
20:45:47 <dibblego> SamB_XP, nope?
20:45:57 <lispy> jgrimes: did you edit the configuration?
20:46:02 <lispy> iirc, Config.hs
20:46:04 <jgrimes> lispy, yes.
20:46:07 <dibblego> Cale, I will only accept a singleton if you can show me the boundaries of the universe
20:46:13 <lispy> jgrimes: is it possible the name is taken?
20:46:28 <lispy> jgrimes: or also, any error messages?
20:46:41 <jgrimes> lispy, well. I have registered the nick.
20:46:48 <Cale> dibblego: What's to stop the language from simply having a primitive that says "this class may only be instantiated once in any given execution of the program"?
20:46:49 <dibblego> the singleton is often erroneously attributed to a widely scoped updating register
20:46:54 <jgrimes> lispy, I don't see any error messages
20:46:58 <dibblego> Cale, the laws of the universe
20:47:02 <Cale> dibblego: oh?
20:47:03 <lispy> jgrimes: hmm...to be honest i've never tried to get my lambdabot to register
20:47:09 <dibblego> Cale, show me such a class
20:47:11 <Cale> dibblego: the universe doesn't apply here :)
20:47:18 <lispy> jgrimes: how you do know it's not ident'd? by /whois?
20:47:27 <dibblego> Cale, it most definitely does - and not only that, this illusion causes a high percentage of software problems
20:47:37 <dibblego> ever heard "but it worked on my machine!"?
20:47:39 <Cale> singleton class Trivial { }
20:47:44 <jgrimes> lispy, yes
20:47:49 <dibblego> Cale, that is bounded
20:47:57 <Cale> hm?
20:47:57 <lispy> jgrimes: okay, i'm not qualified to help further ;)
20:48:06 <dibblego> Cale, I can create two - of course!
20:48:09 <jgrimes> lispy, thanks for trying :)
20:48:09 <lispy> jgrimes: we probably need dons or Cale to help
20:48:13 <Cale> dibblego: why is that?
20:48:17 <dibblego> Cale, all I need to do is step outside the bound
20:48:21 <chessguy> oy. the more i do stuff like haskell, and other mathematical and theoretical computer science stuff, the less i want to do typical 'software engineering' stuff when i graduate. but chances are, that's where i'm going to get stuck :(
20:48:25 <Cale> dibblego: Suppose my language just disallows it?
20:48:31 <dibblego> Cale, it can't
20:48:35 <dibblego> Cale, show me such a language
20:48:36 <Cale> dibblego: oh?
20:48:42 <Cale> I could write such a language
20:48:46 <dibblego> you cannot
20:48:47 <lispy> chessguy: yes, you could get stuck writing VBA applications once in a while, ugh...
20:48:54 <Cale> dibblego: you're insane
20:48:57 <Cale> hehe
20:48:58 * lispy was much happier when writing his software in Haskell
20:48:59 <chessguy> even stuff like web apps
20:49:06 <chessguy> would be boring
20:49:08 <nocotigo> i'm in a php shop currently...
20:49:08 <dibblego> Cale, sorry mate, but you've fallen victim to a big illusion
20:49:10 * nocotigo shudders
20:49:26 <kpreid> dibblego: I think I know what you mean and you're not explaining your point very well.
20:49:29 <dibblego> Cale, in Java, the singleton is often erroneously attributed to a "class-loader scoped updating register"
20:49:30 <jgrimes> nocotigo, same. PHP and PL/SQL
20:49:34 <lispy> nocotigo: if i had to write a lot of php i'd probably make a code generator in haskell
20:49:35 <chessguy> but hardly anybody uses haskell
20:49:40 <dibblego> kpreid, I haven't started explaining it
20:49:44 <kpreid> Cale: any singleton can be duplicated by duplicating the system which enforces the uniqueness constraint.
20:49:44 <Cale> dibblego: I don't mean singleton in the sense that it cannot be instantiated in multiple separate programs. I mean that in any one program compiled by my compiler, I ensure that the class is only instantiated once.
20:49:47 <jgrimes> lispy, I've thought about possibly doing that.
20:49:53 <dibblego> in Java, I just need to create two class loaders and I have two
20:49:57 <jgrimes> lispy, it'd be a nice learning experience.
20:49:58 <nocotigo> jgrimes: the only relief i get is coding javascript
20:50:01 <dibblego> Cale, then the bound is "the program"
20:50:08 * kpreid takes no position on whether this is relevant
20:50:09 <nocotigo> js is actually a great language, i think
20:50:10 <Cale> dibblego: That's all I mean by "singleton"
20:50:12 <jgrimes> nocotigo, same. with modern js libraries it is actually kind of fun.
20:50:15 <dibblego> Cale, in which case, when you create "a different program", you have violated the law
20:50:20 <Cale> in fact, that's all *anyone* means by "singleton"
20:50:21 <dibblego> Cale, therefore, "it worked on my machine!"
20:50:26 <dibblego> Cale, no it isn't
20:50:32 <dibblego> Cale, the index in a for loop is a singleton
20:50:37 <lispy> my complaint with js is that the browser lets you type trash and doesn't complain
20:50:46 <dibblego> Cale, for(int i = 0; i < x ;i++) // i is a singleton
20:50:50 <chessguy> dude, read design patterns
20:50:55 <dibblego> I just bound my context to for loops
20:51:00 <lispy> i *make* mistakes, the computer should try to *help* me by pointing out *ridiculous* things i do
20:51:03 <dibblego> chessguy, it's rubbish I burnt it
20:51:16 <dibblego> there is *no such thing* as a singleton
20:51:18 <chessguy> nonstandard vocabulary is not cool
20:51:20 <nocotigo> lispy: i get around that with firebug and friends in firefox
20:51:20 <dibblego> unless you fix your bounds
20:51:24 <Cale> dibblego: you're generalising a very specific definition such that it no longer means the same thing
20:51:36 <dibblego> some people fix it at "the program" (e.g. Cale), some at "the class loader" (Java)
20:51:41 <Cale> dibblego: If you want to communicate with others, I recommend you just come up with a new term for this.
20:51:45 <dibblego> Cale, there is no specific definition
20:51:51 <dibblego> Cale, I did already - illusion
20:52:15 <Cale> Sure there is. A singleton is a *class* which may only be instantiated once in a given program.
20:52:19 <jgrimes> hm, what would a php generator look like... the semantics are so messed up =/
20:52:20 <dibblego> I have also successfully communicated it hundreds of times - therefore, I will continue to use that term
20:52:28 <chessguy> dibblego, everyone but you thinks of a program-level singleton when they talk about a singleton
20:52:29 <dibblego> Cale, then you cannot have such a thing in Java
20:52:36 <dibblego> chessguy, no they don't
20:52:39 <Cale> dibblego: perhaps you can't
20:52:57 <dibblego> Cale, the Java community would disagree (then the terminology is unsatisfactory?)
20:53:04 <dibblego> Cale, chessguy will disagree
20:53:20 <Cale> oh?
20:53:22 <dibblego> illusion is the best term to use (I have explored this line of reasoning)
20:53:27 <Cale> chessguy: do you disagree with my definition?
20:53:31 <chessguy> not at all
20:53:35 <Cale> see?
20:53:38 <Cale> It's just you :)
20:53:42 <dibblego> chessguy, do you agree that a singleton canno exist in Java
20:53:42 <Cale> hehe
20:53:51 <chessguy> uh, no
20:53:56 <dibblego> no, chessguy has a contradiction now (reductio ad absurdum - false assumption)
20:54:03 <dibblego> Cale, now chessguy has a contradiction
20:54:05 * Xgc chuckles.
20:54:16 <Cale> In that case, he's probably wrong about Java
20:54:25 <nocotigo> now we need a monad for error handling!
20:54:30 <nocotigo> haha.... right?
20:54:36 <dibblego> Cale, agreed - in which case, when I point out that contradiction, he will agree with my original point
20:54:37 <Cale> heh
20:54:49 <chessguy> http://www.javaworld.com/javaworld/jw-04-2003/jw-0425-designpatterns.html has code for a singleton in java, though it looks like crap
20:54:51 <dons> nocotigo: you can do error handling in a monad, yep
20:54:52 <lambdabot> Title: Simply Singleton - Java World, http://tinyurl.com/fg3dl
20:54:54 * nocotigo goes back to tutorial reading
20:55:02 <dibblego> chessguy, that doesn't fit the definition that was provided
20:55:06 <Xgc> chessguy: But that doesn't meet the definition presented here.
20:55:07 <Cale> dibblego: I doubt it. In any evert, it's probably a good idea to prohibit singletons in any language.
20:55:11 <Cale> event*
20:55:13 <dibblego> chessguy, I can create two of those in "the program"
20:55:19 <dons> nocotigo: also , i just created this list for you :) http://haskell.org/haskellwiki/Monad#Monads_in_other_languages
20:55:21 <lambdabot> Title: Monad - HaskellWiki, http://tinyurl.com/wrsvq
20:55:32 <chessguy> dibblego, how?
20:55:33 <dibblego> Cale, I argue that the illusion is only valuable in that it should be avoided - as should any updating register (hence pure FP)
20:55:38 <dibblego> chessguy, easily
20:55:41 <Xgc> chessguy: See ClassLoader
20:55:43 <dibblego> chessguy, keep googling
20:55:53 <nocotigo> dons: thanks!
20:56:06 <chessguy> you're the one making the non-standard allegation. i have nothing to prove
20:56:11 <dons> nocotigo: but you'll want to learn more haskell first
20:56:16 <Cale> dibblego: I don't consider arbitrary mutable state variables to be singletons, I consider them to be mutable state variables.
20:56:21 <dibblego> also, I don't accept that "the program" is an acceptable definition, but that no definition is acceptable
20:56:32 <dons> (btw, the ruby monad tut looks quite nice)
20:56:40 <dibblego> Cale, then again, show me a "singleton"
20:56:43 <nocotigo> thats the one i clicked :)
20:56:51 <dibblego> I have yet to see one
20:57:02 <jgrimes> dons, what steps beyond changing the config for a lambdabot would one take to get it registering  with nickserv?
20:57:03 <dibblego> (more specifically, I have yet to see the boundaries of our universe)
20:57:23 <Cale> dibblego: I did, in pseudocode. That defines a program global class which may only be instantiated once per program. For simplicity, pretend there's no separate compilation.
20:57:30 <dibblego> doesn't category theory cover this stuff anyway?
20:57:32 <dons> jgrimes: change the Config.hs, and possibly create a State/passwd file
20:57:35 <jgrimes> dons, I've also added the password to State/passwd
20:57:39 <dons> which contains a "paswd"
20:57:45 <Cale> dibblego: no, category theory doesn't define singleton
20:57:51 <dons> (with quotes, as it is 'read')a
20:57:53 <dibblego> no, but it defines "categories"
20:57:58 <jgrimes> dons, ah, ok
20:58:07 <jgrimes> dons, thats probably it :)
20:58:09 <dons> jgrimes: should be it then. some servers though do some funny games with ping that we don't handle
20:58:20 <Cale> well, yes, but they're nothing like ordinary "categories" in the English word sense
20:58:20 <dons> (not freenode or slashnet though)
20:58:33 <Cale> They're more like graphs.
20:58:35 <chessguy> nothing like them?
20:58:42 <Cale> Well, a little like them
20:58:45 <chessguy> :)
20:58:50 <dibblego> Cale, exactly my point - perhaps I should clarify the correlation or abandon the idea
20:58:59 <Cale> but one wouldn't define the English word "category" in that way :)
20:59:14 <dibblego> I refuse to be delusional about this stupid singleton crap though
20:59:23 <Cale> nor do the "objects" in category theory have anything to do with "object oriented programming"
20:59:41 <dibblego> euphemisms are the reason we have Java markets and not Haskell markets
20:59:43 <chessguy> isn't a mathematical collection pretty much a collection of abstract objects and functions on them?
20:59:55 <Cale> category
21:00:00 <dibblego> I don't subscribe to hyperbole, hence I burnt GoF
21:00:04 <chessguy> uh, yeah,
21:00:10 <chessguy> pardon my typing
21:00:20 <chessguy> it's been a long day
21:00:44 <chessguy> my brain's starting to fall behind my fingers
21:00:45 <dibblego> I read Pierce on Category Theory and although I didn't "get it" first time around, I had the vague understanding that it is relevant to this point
21:01:18 <Cale> Uh, it's probably not
21:01:26 <dibblego> I'll bet it is
21:01:31 <dibblego> since you were wrong to start with :)
21:01:42 <dibblego> hence, if you thought it was, then it probably wasn't :)
21:01:47 <Cale> huh?
21:01:51 <dibblego> never mind
21:01:51 <chessguy> lol
21:01:57 <Cale> What was I even wrong about?
21:01:58 <chessguy> what an ornery schmuck
21:02:02 <dibblego> that singletons exist
21:02:06 <Cale> They do
21:02:20 <dibblego> in your boundaries that you call "the program"
21:02:25 <Cale> Maybe singletons don't exist in your imaginary world :)
21:02:30 <dibblego> but 99% of Java developers reject your definition
21:02:38 * dibblego sighs
21:02:43 <Cale> But they certainly do in mine, and almost everyone else's.
21:02:45 <dibblego> stupid religions
21:02:57 <dibblego> they don't coincide
21:03:07 <dibblego> they exist *in your head*
21:03:07 <Cale> Words only have meanings based on agreed-upon definitions
21:03:10 <dibblego> and *in that person's head*
21:03:12 <dibblego> etc. etc.
21:03:19 <dibblego> and the definition is not agreed
21:03:24 <Cale> Nothing exists until we agree that it does, of course.
21:03:29 <dibblego> agreed
21:03:32 <dibblego> so let's move on
21:03:36 <nocotigo> you guys arguing semantics or programming?
21:03:39 <dibblego> nobody agrees
21:03:48 <dibblego> I wouldn't argue it if it wasn't so important
21:03:53 <Cale> dibblego: So I just can't talk to you :)
21:04:01 <dibblego> Cale, or 99% of Java developers
21:04:07 <Cale> dibblego: because you don't want to share my language
21:04:08 <dibblego> Cale, *nobody* agrees
21:04:10 <Cale> That's fine
21:04:18 <dibblego> Cale, right, so you can converse *in your head* all you like
21:04:24 <Xgc> Nothing exists?  Doesn't that statement cause some computer to burn to a crisp in an early Star Trek?
21:04:30 <dibblego> and *anyone else who just so happens* to coincide, which is very minimal
21:04:33 <Cale> Most people agree with me enough that I feel like I'm communicating with them :)
21:04:39 <nocotigo> Xgc: haha
21:04:42 <dons> i always wonder why this channel gets kind of nuts around 5am GMT
21:04:51 <Cale> dons: dibblego :)
21:04:53 <Cale> hehe
21:05:05 <dibblego> Cale, then democracy does not define fact, but the "people that you communicate with"
21:05:07 <dibblego> how absurd
21:05:07 <dons> something to do with late afternoon in .au, late night in the US. and europe still asleep
21:05:19 <Cale> dibblego: I don't believe in facts.
21:05:19 <dibblego> I converse with 0.5% of the population and we agree that the world is flat, therefore it is
21:05:19 <monochrom> Is there a sandbox on Haskell Wiki ?
21:05:26 <dibblego> how ridiculous
21:05:30 <Cale> dibblego: why not?
21:05:31 <nocotigo> even satan himself couldn't take this one
21:05:32 <dons> so you get the combination of tired aussies and drunken/tired north americans ;)
21:05:32 <dibblego> neither do I
21:05:33 <nocotigo> haha
21:05:49 <dibblego> why not what
21:05:51 <dibblego> ?
21:05:53 <Cale> dibblego: If you want to believe the world is flat, I'll defend your right to do so.
21:06:01 <dons> monochrom: yes. there's a test page
21:06:06 <Cale> I personally, don't think it will make you very successful.
21:06:07 <dons> have a look under 'Help' I think
21:06:09 <monochrom> I think the "demo" in "democracy" precisely refers to the people and emphetically not facts.
21:06:09 <dibblego> that the world is flat because my very confined population said so?
21:06:20 <jgrimes> dons, yeah, I didn't have the quotes. I should have looked at the source to see how it was reading the file.
21:06:22 <monochrom> It spells "democracy" not "theocracy" afterall.
21:06:24 <Cale> dibblego: I may not believe this myself.
21:06:29 <jgrimes> dons, but it all works now, so :D
21:06:33 <dons> now. when do we move the non-haskell talk to #haskell-blah, dibblego ?
21:06:37 <dons> jgrimes: great!
21:06:41 <dibblego> Cale, great then there is no such thing as a singleton
21:06:42 <Cale> dibblego: You can choose whatever assumptions you like, and I'll be okay with that
21:06:52 <Cale> dibblego: But that doesn't mean I'll agree :)
21:07:08 <dibblego> dons, why ask me?
21:07:12 <dons> dibblego: oh, btw, you're coming down for APLAS?
21:07:16 <dibblego> dons, yes
21:07:19 <dons> cool
21:07:33 <Cale> It just means that I might not want to even bother talking to you about things in places where our language differs too greatly.
21:07:47 <dibblego> Cale, next time you say "singleton", I'll perform a O(1) lookup and type synonym it with "the program"
21:07:54 <Cale> thanks :)
21:08:09 <dibblego> I hope I don't have to do that for the whole world, but I'll make exceptions for you :)
21:08:19 <Cale> If that really does coincide with my definition of singleton in your head
21:08:21 <dibblego> that's an awfully big association map
21:08:31 <Cale> "the program" doesn't coincide with "singleton" in my head
21:08:38 <chessguy> from ##java
21:08:39 <chessguy> 00:02] <chessguy> what's a singleton?
21:08:39 <chessguy> [00:04] <snooplsm> only 1 instance of that object chessguy
21:08:51 <Cale> see?
21:08:51 <dibblego> chessguy, ##java is a source of untruth
21:09:00 <Cale> Other people are agreeing with this language choice
21:09:00 <chessguy> [00:06] <chrismon> a singleton is a class which only permits a single instance
21:09:04 * lispy thinks this isn't haskell anymore
21:09:06 <Cale> hehe
21:09:15 <dibblego> chessguy, they have a contradiction in their logic (hence they use Java)
21:09:17 * nocotigo thinks singletons are crappy global vars
21:09:21 <Cale> lispy: well it *was* a discussion about Haskell
21:09:21 <chessguy> lol
21:09:23 <dibblego> chessguy, didn't I just show you that
21:09:31 <Cale> nocotigo: they amount to that
21:09:33 <lispy> Cale: yeah, was
21:09:38 <dibblego> noclouds, s/global/bounded by some context that exists in the observer's head
21:09:46 * weitzman is trying to figure out the benefit of redefining singleton to mean something other than what people have always used it to mean
21:09:51 <Cale> nocotigo: So we're really disagreeing on the definition of something which we all agree is stupid.
21:09:57 <nocotigo> :)
21:09:59 <nocotigo> fair nuff
21:10:05 <Cale> heh
21:10:14 <dibblego> "people" have not defined it to mean anything - just ask ##java where there is a contradictory definition to Cale
21:10:14 <chessguy> so java users are by definition self-contradictory, and yet since 99% of them supposely disagree with us, we should be concerned, even though they actually don't
21:10:19 <chessguy> trippy
21:10:29 <Cale> furthermore, we probably even agree that all the definitions which are on the table for it are bad ideas
21:10:36 <dibblego> chessguy, no you contradicted yourself earlier - it's invalid
21:10:46 <dibblego> chessguy, only one of things you said can be true
21:10:54 <dibblego> Cale, yes we agree there
21:11:01 <chessguy> what was my contradiction?
21:11:07 <monochrom> weitzman: consider defining singleton to be a person with a singleton mind...  :)
21:11:08 <Cale> dibblego: Are you saying that chessguy, snooplsm, chrimson and I are not people?
21:11:31 <chessguy> my girlfriend won't be happy about that news
21:11:32 <Cale> Because I'm willing to say that we all have the same definition of singleton
21:11:39 <dibblego> Cale, chessguy doesn't have a definition (since he has two that a contradictory at the moment) and I was referring to all people
21:11:49 <nocotigo> apparently singleton is in australia
21:11:50 <Cale> dibblego: no he doesn't
21:11:54 <dibblego> chessguy, scroll up, I told you I could create two
21:11:58 <dibblego> Cale,  yes he does
21:12:04 <monochrom> I am writing up an essay about "getRidOfIO :: IO a -> a" being a contradiction.
21:12:14 <chessguy> you have yet to prove that
21:12:17 <dibblego> he showed me a scoped register to the class loader - which is not "the program"
21:12:21 <desrt> unsafePerformIO?
21:12:23 <dibblego> chessguy, need I? it's basic Java stuff
21:12:42 <dibblego> chessguy, Xgc referred you to java.lang.ClassLoader
21:12:44 <Cale> dibblego: besides, this isn't java stuff, it's OOP stuff.
21:12:52 <desrt> monochrom; i am confused.
21:12:52 <dibblego> Cale, wtf?
21:12:57 <Cale> Java is not exactly the best example of an object oriented language
21:13:00 <chessguy> anyway, even if java doesn't support it right, the concept of a singleton is well-defined
21:13:01 <dibblego> so?
21:13:08 <desrt> "Haskell - the language of ICFP winners 3 years running"
21:13:12 <desrt> this is no longer true.
21:13:14 <dibblego> chessguy, no it isn't - postulate another definition
21:13:15 <monochrom> I am joking, OK?
21:13:18 <Cale> desrt: no, it is
21:13:24 <chessguy> desrt, it's still the language they used
21:13:28 <Cale> desrt: The winners used Haskell this time
21:13:32 <desrt> even though 2D was their prefered language? :)
21:13:35 <Cale> right
21:13:38 * desrt chuckles
21:13:39 <desrt> fair.
21:13:46 <nocotigo> i could see universal things like "true" being a singleton
21:13:49 <nocotigo> am i way off?
21:14:01 <dibblego> chessguy, to most Java developers, a singleton is scoped to the class loader (which contradicts Cale's definition for example - therefore, it is not "well defined")
21:14:14 <monochrom> dons: the only sandbox I find is on mediawiki, so it won't test <hask>
21:14:30 <chessguy> dibblego, <chessguy> anyway, even if java doesn't support it right, the concept of a singleton is well-defined
21:14:33 <dibblego> nocotigo, this turns to philosophy, which I am deliberately avoiding, but it's a good question in that context :)
21:14:43 <dibblego> chessguy, "well defined for Java developers"
21:14:58 <Cale> nocotigo: true isn't a singleton :)
21:15:02 <Cale> hehe
21:15:02 <monochrom> dibblego is avoiding philosophy?  This is a contradiction!
21:15:17 <dibblego> chessguy, when those Java ninnies start working with multiple class loaders, they trip over their definition (I watched it happen when I was working on the WebSphere implementation)
21:15:27 <nocotigo> singleton = the forms!!!
21:15:27 <Cale> True and false are just labels we apply to statements.
21:15:37 <dibblego> monochrom, I am trying to remain relevant to values in softwaredevelopment :)
21:15:41 <chessguy> ok, getting too deep now
21:15:48 <chessguy> time for me to call it a night
21:15:49 <dons> monochrom: well, you can create a page :) here, http://www.haskell.org/haskellwiki/Sandbox
21:15:51 <lambdabot> Title: Sandbox - HaskellWiki
21:15:54 <dibblego> "it worked on my machine" happens exactly because of that stupid GoF book
21:15:57 <Pseudonym> Dammit.
21:16:02 <nocotigo> neo was a singleton
21:16:04 <Pseudonym> I shouldn't waste time programming in Fractran.
21:16:06 <nocotigo> ok i'm done
21:16:14 <Cale> there's no one "right way" to label every statement with "true" and "false"
21:16:15 <monochrom> I fear that its history will clog the server in the long run, dons.
21:16:20 <weitzman> dibblego: Even if two versions of the same code are loaded in two different class loader hierarchies, it will still be the case that Blah.singleton == Blah.singleton in either hierarchy
21:16:30 <monochrom> I guess "preview" is useful afterall.
21:16:51 <dibblego> weitzman, a) no b) does == make it a singleton?
21:17:00 * Pseudonym accidentally discovered a way to compile a high-level language to Fractran by hand
21:17:04 <Pseudonym> Now my productivity is shot.
21:17:13 <dibblego> weitzman, I have code samples, but I was deliberately avoiding those too
21:17:25 <lispy> why are we still talking about singletons?
21:17:34 <lispy> Pseudonym: Fractran?
21:17:39 <dibblego> here's one http://jqa.tmorris.net/GetQAndA.action?qids=68&showAnswers=true
21:17:42 <lambdabot> Title: Java Questions and Answers - FAQ #45, http://tinyurl.com/j2x55
21:17:49 <monochrom> Excellent!  <hask>>>=</hask> works as I want! XD
21:17:50 <nocotigo> cause they're ambiguous like God, and therefore the argument could go on forever
21:18:10 <dibblego> the argument can conclude that there is only such thing relative to the observer
21:18:15 <monochrom> God!  God is less ambiguous than this.
21:18:19 <Cale> nocotigo: right. This is stupid
21:18:35 <nocotigo> on a positive note, i still dig haskell :)
21:18:35 <monochrom> chessguy said it's too deep.  I say it's too shallow.
21:18:44 <Pseudonym> lispy: http://scienceblogs.com/goodmath/2006/10/prime_number_pathology_fractra.php
21:18:47 <Cale> So I think we can agree that not only are singletons an anti-pattern, discussing them at all is as well.
21:18:47 <lambdabot> http://tinyurl.com/vxjge
21:18:59 <lispy> Pseudonym: checking it out
21:18:59 <dibblego> Cale, sure
21:19:03 <Cale> let us never speak of them again
21:19:11 <dibblego> Cale, yay! :)
21:19:21 <nocotigo> the unutterable word...
21:19:33 <nocotigo> we /are/ getting philosophical
21:19:41 <weitzman> dibblego: I don't know exactly what you're trying to show with that example, but the semantics of how Java reuses string constants isn't really related to the idea of singletons
21:19:48 <nocotigo> religious even
21:20:06 <dibblego> weitzman, it shows that two class loader scoped "variables" are not equivalent
21:20:08 <weitzman> In fact, if you have two different String classes loaded, you can't even use them interchangably
21:20:19 <dibblego> there are not two different String classes loaded
21:20:22 <weitzman> You need a shared interface loaded by a parent class loader
21:20:56 <weitzman> Agreed
21:20:57 <dibblego> weitzman, two class loader scoped variables are not equivalent
21:21:08 <dibblego> not even with == necessarily
21:21:12 <weitzman> It's the same string class, and two different string instances
21:21:24 <monochrom> May I sing a hymn that offends atheists?
21:21:47 <nocotigo> monochrom, sure?
21:21:57 <weitzman> I'm not aware of any promise that the language spec makes about strings being internally equal of you load classes in different hierarchies
21:22:03 <monochrom> I mean as I sing I also type in the text here in this channel XD
21:22:08 <Pseudonym> o/~ Bill Joy moves in a mysterious way / His objects to perform... o/~
21:22:08 <weitzman> When people talk about singletons, they usually talk about them concretely
21:22:13 <dibblego> weitzman, it didn't use to, but now it does, for reasons that I gave
21:22:15 <weitzman> Blah.a, where a is static
21:22:17 <nocotigo> monochrom, as long as you're singing it as you type
21:22:20 <weitzman> Or blah.a()
21:22:25 <dibblego> weitzman, yes, class loader scoped variables
21:22:34 <dibblego> "people" being "Java developers"
21:22:40 <dibblego> not "people" in the general sense ala Cale
21:22:42 <lispy> Pseudonym: cool
21:22:45 <weitzman> And from any given reference point, you've always been loaded by a specific class loader
21:22:51 <weitzman> So the static stuff will always look the same
21:22:59 <lispy> Pseudonym: did you write an interpreter for it yet?
21:23:35 <weitzman> The only way to cross the boundary is through a shared parent interface or a class loaded at a higher classloader level
21:23:50 <Pseudonym> Yup.
21:23:57 <dibblego> the boundary is already crossed as soon as you create it
21:23:59 <weitzman> And the fact that this doesn't share internal strings perfectly is a random implementation detail of no interest
21:24:00 <Pseudonym> http://andrew.bromage.org/Fractran.hs
21:24:07 <lispy> Pseudonym: i'm guessing it would be a short program, but i didn't read the specification closely enough yet :)
21:24:15 <dibblego> that you use == to define "equivalence" is not necessarily definitive
21:24:22 <Pseudonym> There's also a Haskell one-liner, but it's pretty obscure.
21:24:36 <dibblego> I could even use the output of System.identityHashCode() as some differentiator
21:24:40 <Pseudonym> But amusingly, I worked out a way to compile a small loop-and-register-oriented language into Fractran mechanically./
21:24:51 * lispy thinks he should change his last name to org so he can register jason.org and have it be his name :)
21:25:17 <weitzman> dibblego: When Java programmers talk about the singleton pattern, they've always meant == equivalence in my experience
21:25:30 <dibblego> weitzman, no they don't
21:25:30 <Pseudonym> [2%7,3%11,13%17,19%23,51%65,1%13,46%95,1%19,5%6,91%2,209%3]
21:25:35 <Pseudonym> That's GCD in Fractran.
21:25:44 <weitzman> The point being to have exactly one instance of a class, saving the resources of creating more than one if it isn't necessary
21:26:03 <Pseudonym> You give it 2^a * 3^b as input, and you get 5^gcd(a,b) as output.
21:26:14 <Cale> Pseudonym: implement Fractran in Fractran!
21:26:15 <dibblego> weitzman, it's only unnecessary if the class has only RT operations
21:26:22 <Pseudonym> Cale: Well, that's the thing, isn't it.
21:26:27 <Pseudonym> You need GCD for that, don't you.
21:26:31 <Cale> right :)
21:26:35 <dibblego> weitzman, Java users are just reinventing FP
21:26:40 <Pseudonym> That's why I figured I'd try GCD first.
21:26:53 <Pseudonym> The thing is, first you need to work out a way to encode lists of rationals.
21:26:57 <monochrom> Pseudonym: You are using Goedel numbering!!!!
21:27:00 <weitzman> Excuse me, but what do you mean by RT operations?
21:27:06 <Pseudonym> Of course!
21:27:09 <dibblego> referentially transparent
21:27:21 <monochrom> Why didn't you talk about it during Halloween???!!!!
21:27:39 <weitzman> == is defined on every class, thus ensuring that two separate instances can be distinguished
21:27:41 <Cale> If people don't shut up about Java, my foot's going to start getting itchy :)
21:27:44 <dibblego> weitzman, the euphemism is "immutable"
21:27:47 <Pseudonym> I prefer to talk about Goedel number on All Saint's Day.
21:27:49 <monochrom> "Because I was implementing it during Halloween!!!!"
21:27:51 * weitzman stops talking about Java
21:27:52 <Pseudonym> It seems more appropriate.
21:27:55 <Cale> hehe
21:28:07 * dibblego stabs Java in the face
21:28:11 <Pseudonym> Besides, it's the 2nd already here.
21:28:31 <dibblego> it's my birthday today and I got a book on Goedel
21:28:53 <monochrom> I listen to a requiem on my birthdays.
21:29:25 * lispy likes to pretend he doesn't exist on his b-day
21:29:38 <weitzman> For my birthday all I got was an assurance from my parents that if I decide what I want one day they'll give it to me, within reason
21:29:39 <palomer> yo my bitches
21:29:47 <weitzman> That was...10 months ago?
21:29:50 <Pseudonym> I will not yo your bitches.
21:30:02 <monochrom> hee
21:30:05 <lispy> yo yo yo your bitch...
21:30:13 <dibblego> Goedel, Eschel and Bach: An Eternal Golden Braid
21:30:20 <palomer> I don't think you understand, you're my bitches and I'm yoing you
21:30:54 <Pseudonym> Eeeuuw.
21:31:19 <weitzman> I said this earlier, but I'm going to repeat it just in case: Any google employees here?
21:31:24 * monochrom closes his eyes and appears to be meditating
21:31:39 <weitzman> Present or past
21:32:12 <lispy> weitzman: future maybe
21:32:16 <lispy> ;)
21:32:16 <palomer> pfft, as if you can type with your eyes closed
21:32:25 <weitzman> lispy: That relates to my problem
21:32:32 <lispy> Pseudonym: why is gcd needed to implement fractran in fractran?
21:32:56 <Pseudonym> lispy: Errr... good point.
21:33:03 <Pseudonym> Ah, I know.
21:33:09 <Pseudonym> Rational multiplication.
21:33:35 <lispy> Pseudonym: you only need gcd to make rational multiplication well-defined though :)
21:33:53 <monochrom> This is typed with my eyes closed
21:34:05 <lispy> monochrom: i read it with your eyes closed
21:34:10 <monochrom> OK I can't prove it, but I honestly did that.
21:34:36 <monochrom> I taught myself touch-typing
21:34:56 <dibblego> dons, http://plugins.intellij.net/plugin/?id=266 that is the Ruby equivalent to what I did
21:35:01 <palomer> touch typing is black magic
21:36:30 <lispy> Pseudonym: as for encoding rational numbers, i'm kinda stumped
21:36:48 <lispy> Pseudonym: maybe you could do like 2^numerator * 3^denominator for your numbers?
21:36:59 <Pseudonym> Yeah, but then you need a list of them.
21:37:09 <lispy> hrm...
21:37:20 <lispy> well, you have inifinitely many primes :)
21:38:39 <desrt> glguy!
21:38:43 <desrt> i hear that 0 = 1
21:39:14 <glguy> desrt: I never made that claim, but I don't doubt you'd defend it ;)
21:39:20 <lispy> > let 0 = 1 in 0
21:39:21 <glguy> desrt: and good evening to you too
21:39:21 <lambdabot>  0
21:39:21 * desrt grins
21:39:27 <desrt> glguy; 'sup?
21:40:00 <lispy> interesting that doesn't cause a parse error
21:41:14 <glguy> I'm just trying to figure out how to run irssi with torify
21:41:22 <glguy> so that I can access the hidden service
21:41:24 <glguy> from work
21:41:29 <glguy> (which blocks 6667)
21:41:47 <glguy> rather than using Trillian from my win box
21:42:25 <int-e> lispy: why? '0' is just a pattern there.
21:42:52 <int-e> > let True = False in True -- same thing, basically.
21:42:53 <lambdabot>  True
21:44:04 <Pseudonym> I think what you need to implement Fractran in Fractran is basically a universal Minsky machine.
21:44:17 <int-e> lispy: it just binds no variables and is thus superfluous; I suppose a compiler could warn about that.
21:46:19 <lispy> int-e: hm...
21:46:29 <lispy> > let _ = undefined in 3
21:46:30 <lambdabot>  3
21:46:36 <int-e> yep.
21:46:37 <lispy> i guess let is very permissive
21:47:07 <lispy> i expected some error about not being able to redefine a literal
21:47:10 <int-e> you can do that in a top-level binding as well
21:47:19 <desrt> if you say let x = y
21:47:23 <desrt> it's a pattern match
21:47:30 <desrt> the pattern match is only evaluated if needed
21:47:51 <desrt> if you tried to match True = False you'd just get a pattern match failure
21:47:52 <lispy> well, when i have an identifier or operator on the lhs that makes totalsenseto me
21:47:54 <desrt> but it never needs to happen
21:47:56 <int-e> True = False -- confuse newbies, do nothing really
21:49:26 <lispy> yeah, i mean it creates an ananymous pattern match...and so it's an ananymous function to the extreme!;)
21:50:09 <int-e> it's so anonymous that the compiler will soon totally forget about its existence :)
21:50:39 <lispy> it's the aborted fetus of programs!
21:50:47 <int-e> you can use this for fooling the type checker though
21:50:53 <lispy> oh?
21:51:01 <int-e> @type let f x in let True = x in x in f
21:51:02 <lambdabot> parse error on input `in'
21:51:08 <int-e> @type let f x = let True = x in x in f
21:51:10 <lambdabot> Bool -> Bool
21:51:24 <int-e> > let f x = let True = x in x in f False
21:51:25 <lambdabot>  False
21:52:05 <int-e> @type (`asTypeOf` True)
21:52:07 <lambdabot> Bool -> Bool
21:52:25 <lispy> wired!
21:52:28 <lispy> er weird
21:52:32 <lispy> i'm not reallygetting it
21:52:44 <lispy> why does the type checker even notice
21:52:56 <lispy> ?type let True = x in x
21:52:57 <lambdabot> Not in scope: `x'
21:52:57 <lambdabot>  
21:52:57 <lambdabot> <interactive>:1:16: Not in scope: `x'
21:53:01 <int-e> because to match  True and x,  x and True must have the same type
21:53:20 <int-e> the pattern match is not ignored completely.
21:53:36 <lispy> why does it need to match True andx?
21:54:04 <int-e> let True = x <-- this is only valid if the left and right side have the same type
21:54:21 <lispy> Oh
21:54:36 <lispy> > let 0 = 'a' in 0
21:54:37 <lambdabot>  add an instance declaration for (Num Char)
21:54:37 <lambdabot>   When checking the pattern: 0...
21:54:41 <lispy> cool
21:56:02 <desrt> tor for irc?  seriously?
21:56:34 <lispy> desrt: speech is not free in all partsof theworld
21:56:58 <lispy> desrt: my understanding is that tor helps some people circumvent local lawsabout speeech
21:58:31 <Cale> We should turn "i would like to post mesg this list" into an internet craze
21:58:32 <desrt> i guess tor allows you to dissent to the axiom of choice without fear of persecution
21:58:43 <glguy> what about tor?
21:58:56 <desrt> 00:55 <lispy> desrt: my understanding is that tor helps some people circumvent local lawsabout speeech
21:59:20 <Cale> It also helps spammers circumvent bans
21:59:44 <glguy> it helps you use your neighbors wireless without revealing what you are using it for :)
21:59:44 <glguy> IRC!
21:59:56 <ski> (:
21:59:58 <glguy> it lets you get past a work firewall that blocks irc
22:00:09 <ski> > let () = undefined in 3
22:00:10 <lambdabot>  3
22:00:28 <desrt> ski; unless the term on the left appears in the right side then it won't be evaluated
22:00:39 <glguy> and it allows me to vote dons for president without reprisal from the gov't
22:00:42 <desrt> note 'let True = False in True' is not the term appearing
22:00:52 <desrt> True is a nullary data constructor with no bound variables :)
22:01:43 <ski> desrt : istr getting errors if the lhs doesn't bind variables .. maybe that was in earlier version of hugs or ghc, though
22:02:21 <lispy> so, as i understand it, case is the language construct which forces evaluation..so what about seq, same thing?  is seq implemented by case?
22:02:58 <skew> Pseudonym: how about something like 2^numerator*3^denominator*5^tail for lists?
22:03:13 <skew> as long as you can implement logBase 5
22:03:37 <lispy> oh, that's clever
22:03:51 <lispy> although, the list will get very large!
22:04:02 <ski> lispy : it was, i think
22:04:56 <desrt> that's cale's trick!
22:05:10 <Cale> No, it's actually Gödel's :)
22:05:15 <desrt> whatever
22:05:19 <desrt> i'm sure he got it from you
22:05:25 <Cale> heh
22:06:36 <sjanssen> lispy: you could imagine that seq is implemented with pattern matching
22:06:52 <lispy> sjanssen: in that case, seq could be implemented by case
22:07:00 <ski> sjanssen : for functions, too ?
22:07:03 <Cale> lispy: it used to be
22:07:19 <desrt> is seq magic?
22:07:20 <lispy> sjanssen: but, how does seq know which pattern?
22:07:22 <sjanssen> it can't actually be implemented by case, because of the type signature
22:07:41 * ski thinks general seq is evil
22:07:43 <lispy> ?type seq
22:07:45 <lambdabot> forall b a. a -> b -> b
22:07:53 <desrt> i could write seq if i had Eq a
22:08:00 * desrt isn't sure how to write it fully polymorphically
22:08:34 <ski> what was the rationale for removing the 'Eval' class ?
22:09:12 <monochrom> Cale: do you type ö using SCIM?
22:09:25 <desrt> i pity the fool without a compose key
22:09:29 <Cale> Actually, I just use my compose key
22:09:38 <monochrom> alright
22:09:56 <desrt> cale receives no pity :)
22:10:01 <sjanssen> @where paste
22:10:02 <lambdabot> http://paste.lisp.org/new/haskell
22:10:04 <Cale> I just use SCIM for things like ⊕ and ∫
22:10:25 <lispy> what is it about seq and case that doesn't work?
22:10:34 <lisppaste2> sjanssen pasted "seq as a type class" at http://paste.lisp.org/display/29142
22:10:59 <Cale> It also makes it pretty easy to type ひらがな, カタカナ, and 漢字.
22:11:09 <Pseudonym> Night.
22:11:25 <lispy> sjanssen: hmm...okay
22:12:12 <lispy> ?type let seq' = case a of _ -> \b -> b in seq
22:12:13 <sjanssen> lispy: it's the type signature of seq "forall a b. a -> b -> b", you can't pattern match against 'a', because you don't know a's type
22:12:14 <lambdabot> Not in scope: `a'
22:12:28 <ski> sjanssen : that is ok
22:12:43 <lispy> ?type let seq' = \a -> case a of _ -> \b -> b in seq
22:12:44 <lambdabot> forall a b. a -> b -> b
22:12:58 <sjanssen> lispy: that won't actually do anything
22:13:10 <sjanssen> _ is an irrefutable pattern, so it won't force evaluation
22:13:11 <lispy> sjanssen: right, just trying to get the type right using case
22:13:15 <ski> > let seq' = \a -> case a of _ -> \b -> b in seq'
22:13:15 <lambdabot>  Add a type signature
22:13:25 <ski> @type let seq' = \a -> case a of _ -> \b -> b in seq'
22:13:26 <lambdabot> forall t t1. t -> t1 -> t1
22:13:32 <ski> > let seq' = \a -> case a of _ -> \b -> b in seq' undefined 'a'
22:13:33 <lambdabot>  'a'
22:13:33 <sjanssen> @type flip const
22:13:34 <lambdabot> forall a b. b -> a -> a
22:15:51 <lispy> so seq is more like an abstract machine primitive that has been exposed to the language?
22:16:13 <desrt> it's magic.
22:16:22 <sjanssen> lispy: yes, seq can't be implemented in pure Haskell
22:16:25 <desrt> i promise you that its implementation features at least one # sign
22:17:24 <sjanssen> @index seq
22:17:24 <lambdabot> Prelude, Control.Parallel
22:17:28 <ski> @type seq
22:17:30 <lambdabot> forall b a. a -> b -> b
22:17:32 <ski> @type (>>)
22:17:33 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
22:17:36 <desrt> seq :: a -> b -> b
22:17:37 <desrt> seq _ y = y
22:17:42 <ski> coincidence ?
22:17:43 <lispy> so we have case and seq which force some evaluation, is there anything else which cannot be represented by those two?
22:18:02 <desrt> which is exactly equivalent to the fancy cases thing
22:18:16 <desrt> since either the argument needs to be evaluted for _ or not
22:18:22 <desrt> (not)
22:18:31 <ski> desrt : ?
22:18:32 <desrt> this is inside, though, #ifdef __HADDOCK__
22:18:35 <lispy> seq _ y = y doesn't do anything
22:18:41 <desrt> so it's a dummy
22:18:42 <sjanssen> desrt: that's only for Haddock purposes
22:19:09 <desrt> 'seq' is nowhere in the prelude
22:19:13 <desrt> i guess it's fundamental
22:19:19 <glguy> lol, it's like everyone in #haskell managed to chime into the Ask Reddit question on monads
22:19:35 <sjanssen> desrt: :info seq in ghci says it's <wired into compiler>
22:19:36 * desrt expected some seq a b = some #magicThingHere# a b
22:20:10 <skew> yeah, it's pretty much magic
22:20:13 <glguy> tmoertel_away, Cale, dons, dibblego... did I miss someone else?
22:20:30 <monochrom> seq a b = #case# a #of# _ #-># b  :)
22:20:38 <desrt> :)
22:20:47 <desrt> monochrom; do you listen to lush?
22:20:47 <skew> the case in Core always forces evaluation, I think
22:20:51 <dons> glguy: yeah, apparently #haskell runs the agenda ;)
22:21:08 <dons> possibly that because a lot of #haskellers are used to writing about CS
22:21:25 <glguy> of course dibblego didn't manage to add much insight to the conversation q-:
22:21:37 <glguy> but he did chime in
22:21:43 <monochrom> Democracy doesn't work.  Not just me.
22:21:48 <glguy> "Gonads are not specific to males or females."
22:21:59 <monochrom> I like Monsters.
22:22:01 <desrt> i was gonna say "you shouldn't be so unkind"
22:22:02 <lispy> that reminds me, i don't think i've ever needed or used any CS at my programming job
22:22:03 <desrt> but uh.. ya
22:22:26 <desrt> lispy; listen to dijkstra
22:22:29 <dons> lispy: never a recursive loop or a binary tree?
22:22:40 <dons> surely not...
22:22:47 <monochrom> Structured programming is CS.
22:22:49 <skew> you could probably get by with seq a b = case unsafeCoerce# a of LT -> b | _ -> b
22:22:58 <desrt> monochrom; incorrect.  that's software engineering.
22:23:12 <monochrom> http://www.vex.net/~trebla/humour/book_for_sale.html
22:23:15 <lambdabot> Title: Book For Sale, http://tinyurl.com/y9729k
22:23:22 <monochrom> software engineering is CS
22:23:23 <lispy> dons: well, it's just sad how CS-wise trivial the problems at work are (not saying they are easy tho)
22:23:29 <dons> ah well
22:23:35 <desrt> Computer Science is no more about computers than astronomy is about telescopes.
22:23:35 <desrt> -- E. W. Dijkstra
22:23:40 <desrt> :)
22:23:47 <lispy> desrt: aye, i know that one
22:23:52 <desrt> he has another one i think
22:24:04 <monochrom> I know how to show a Dijkstra contradiction.
22:24:04 <desrt> something about how the purpose of computer science is to determine how to avoid using computers
22:24:27 <desrt> dijkstra had some bad ideas
22:24:37 <lispy> dons: i can't think of the last time i needed more than a list or a lexer, pretty much never need a parser or a complex datastructure
22:24:50 * desrt has a strongly held belief called "lack of goto considered harmful"
22:24:57 <monochrom> Ha.
22:25:01 <desrt> i'm serious
22:25:06 <monochrom> But I'm talking about Dijkstra against Dijkstra.
22:25:11 <desrt> kids that grew up with goto knew what the computer was doing
22:25:21 <desrt> and loops were basically abstractions of goto.  easy to understand
22:25:30 <desrt> if you just throw them in with the loops to start they have no idea what the hell is going on
22:25:41 <dons> lispy: what kind of data do you manipulate?
22:25:49 <monochrom> Those kids do not understand least fixed points.
22:25:52 <lispy> dons: boring data :)
22:25:53 <desrt> you get a better intuative feel for how a program runs by using goto
22:26:00 <desrt> intuitive, too
22:26:10 <desrt> monochrom; exactly.
22:26:13 <lispy> dons: i'm just pissed about work lately since they changed the project i'm on :)
22:26:18 <dons> i can see how in say web programming you wouldn't usually seem to need much theory, but then if you want to do say, concurrency or continuations right, well...
22:26:22 <lispy> "Use VBA, not CS"
22:26:23 <desrt> repetition and selection might be theoretically nice
22:26:24 <dons> ah well
22:26:35 <desrt> but nobody gives a damn when they're learning
22:26:37 <Lemmih> lispy: (re-very small program) It's like saying 'let Nothing = Just 10 in Nothing'. You don't redefine 'Nothing', you pattern-match it.
22:26:42 <monochrom> I am talking about kids who know goto.  These kids will not understand least fixed point or denotational semantics.
22:26:54 <lispy> Lemmih: yeah, int-e was showing me
22:26:58 <desrt> Lemmih; covered up there ^ :)
22:27:02 <dons> Lemmih: so its a k pattern with no function name?
22:27:07 <lispy> > let 0 = 'a' in 0
22:27:08 <lambdabot>  add an instance declaration for (Num Char)
22:27:08 <lambdabot>   When checking the pattern: 0...
22:27:16 <dons> a k pattern constant
22:27:17 <Lemmih> Oops, Sorry. Didn't notice it.
22:27:18 <desrt> it still needs to typecheck
22:27:22 <lispy> Lemmih: and it does get type checked at least
22:27:31 <dons> > let x = 1  in x
22:27:32 <lambdabot>  1
22:27:38 <dons> > let f 0 = 1  in f 0
22:27:39 <lambdabot>  1
22:27:41 <desrt> that was awful boring :)
22:27:42 <dons> > let 0 = 1  in 0
22:27:43 <lambdabot>  0
22:27:53 <desrt> 0 isn't a variable
22:28:03 <dons> no, its a k pattern constant
22:28:10 <dons> yeah?
22:28:14 <skew> it's like let LT = EQ in GT
22:28:19 <desrt> and 'f 0 = 1' is sugar for f (\0 -> 1) (if you will)
22:28:24 <desrt> f=
22:28:39 <desrt> wow.  (\0 -> 1) is valid syntax
22:28:40 <dons> ?pl let 0 = 1 in 0
22:28:40 <skew> a lazy pattern that never gets around to failing because you didn't use any bindings from it in the body
22:28:40 <lambdabot> 1
22:28:41 <int-e> > let undefined = undefined in undefined -- but unlike this ;)
22:28:41 <desrt> i love pattern matching
22:28:42 <lambdabot>  Add a type signature
22:28:48 <int-e> > let undefined = undefined in undefined :: Int
22:28:49 <lambdabot>  Exception: <<loop>>
22:28:53 <ski> mrf, someone should reply to jng at http://programming.reddit.com/info/ox6s/comments and say that he basically describes Clean !
22:28:56 <lambdabot> Title: Ask Reddit: What the hell are monads? (reddit.com), http://tinyurl.com/yd7wrw
22:28:59 <dons> yeah, a lazy k pattern
22:29:19 <lispy> > (\0 -> 1) 0
22:29:20 <lambdabot>  1
22:29:20 <desrt> better than an n+k pattern!!! (so i'm told by haskell humour)
22:29:26 <int-e> 'Well first of all the concept of monads wouldn't really be useful in Lisp, because most lisps are "impure"' *yawn*
22:29:26 <desrt> but
22:29:29 <desrt> > (\0 -> 1) 1
22:29:30 <dons> ski: ah yes. i thought so too
22:29:30 <lambdabot>  Non-exhaustive patterns in lambda
22:29:37 <desrt> see? :)
22:29:43 <dons> (about it basically talking about uniqueness types)
22:29:51 <ski> right
22:30:17 <dons> (ignoring other issues like how to implement continuatoins or so on, it would seem Clean with uniquness types for IO, and monads for doing everything else, is still a good mix)
22:30:41 <dons> so you could happily have IO via Clean-style uniqueness typing, but you'd still want monads for all the other stuff
22:30:41 <ski> or rather, that s/he wants uniqueness types to ensure the efficient implementation can be used
22:31:16 <ski> i'd like to have *both* unique IO *and* monadic IO
22:31:29 <monochrom> Can you pull an "IO a -> a" trick with uniqueness type?
22:31:35 <ski> monochrom : no
22:31:40 <dons> ski, yeah
22:31:50 <dons> both would be fine with me
22:31:57 <skew> sure you can, you could provide a primitive with a type like Unique a -> a
22:32:03 <dons> ski, feel free to reply. raise the overall standard a bit :)
22:32:41 <dons> is the syntax he used lisp-ish? just wondering how you could be thinking about implementing IO, but not know about Clean..
22:32:45 <skew> I think unique values mostly look nice for being able to mix different pieces of state, without overly constraining evaluation order
22:32:46 <ski> of course one should be able to open up an 'IO a' into a '*World -> (a,*World)' and vice versa, too
22:32:56 <dons> unless you were from a dyn-typed FP background
22:33:03 <ski> skew : yes
22:33:27 <skew> but I think we need better syntax for monads that don't require a fixed evaluation order anyway
22:33:29 <ski> sometimes you'd like more control (i.e. not overspecifying order) of separate parts of the state
22:33:33 <dibblego> I can't tell if jng is explaining monads or the so-called "right way"
22:34:07 <palomer> right way?
22:34:21 <dibblego> "The right way is not available yet (but I'm designing a language... :) )."
22:34:21 <andygill> skew:  thats what SPJ talked about as a weakness of monads
22:34:26 <ski> skew : a richer translation that could translate into other things than just '(>>=)' always, would be nice, yes
22:35:03 <ski> one possible step in this direction is to introduce 'Applicative'/'Idiom' class, imo
22:35:20 <dons> skew: yeah, its been talked about a bit. as andygill says. there's a chance to get famous there if you can write the paper :)
22:35:21 <andygill> for example, do v1<- ... ; v2 <- m2 ; f v1 v2.   you've stated the order of (monadic) evaluation.
22:35:40 <dons> so the monadic ordering over-constraints a lot of problems
22:35:45 <andygill> You want to somehow say the order does not matter.
22:35:46 <ski> dibblego : i'm interpreting that what jng says after that is an explanation of how things should work in her/his language
22:35:48 <skew> you could do something along the lines of <<f v1 v2>>
22:35:57 <ski> andygill : yes
22:36:01 <skew> probably want a separate class for monads that promise to be commutative
22:36:17 <ski> andygill : a very simple solution is just to not use '(>>=)' so much
22:36:18 <andygill> But you also need a monad like thing ... as skew says
22:36:54 <lispy> so youw ant something like: do v1 <- m1 || v2 <- m2; f v1 v2
22:37:10 <lispy> that just means v1 and v2 happen sometime before f?
22:37:27 <ski> do (v1,v2) <- mpar m1 m2; f v1 v2
22:37:39 <skew> It's not necessary to avoid bind, as long as you work in a monad that promises e1 >>= \x -> e2 >> e3 == e2 >> e1 >>= \x -> e3 if e2 doesn't mention x
22:38:16 <ski> skew : but the proper way to handle that is to translate to using a monadic operation built for just that, i think
22:38:36 <skew> what kind of operation would you build just for that?
22:38:44 <ski> (s/translate to/either translate to or directly use/)
22:38:53 <ski> mpar :: m a -> m b -> m (a,b)
22:39:11 <skew> oh, I guess that works
22:39:38 <ski> if you want, you could allow that in sequential monads, too (so that it is sequential there)
22:39:53 <skew> but just having an operation like that is weaker than promising that >>= is as commutative as allowed by data dependencies
22:39:59 <lispy> and arrows don't solve the problem?
22:40:26 <skew> there are enough things which are perfectly good monads, that we'd like to hide behind pure-looking syntax
22:41:05 <lispy> i find it interesting that, "
22:41:17 <ski> skew : yes .. but how to easily check when we can in fact commute commands in 'do' ?
22:41:19 <lispy> I bet somebody got a really nice bonus for that feature." talks only about things you'd find in windows
22:41:47 <lispy> because, windows is the only OS where i use the sort of truely 'rude' programs the blogger describes
22:42:28 <ski> i recall a paper in which they wanted a more parallel 'ap' than the default one
22:42:44 <skew> We sometimes point out that imperative/impure languages just fix one choice of monad
22:42:59 <dons> skew: yeah, maybe we should do that more often
22:43:08 <lispy> skew: which choice is that?
22:43:11 <dons> it seems massively underappreciated
22:43:25 <dons> since the "outsiders" think: monad == IO hack
22:43:37 <skew> Something like ST + a lot of unsafeCoerce# to make C
22:43:57 <dibblego> dons, I agree - I've met two people who see it that way
22:43:57 <skew> Java ~= Exceptions + Mutable state + IO
22:44:13 <skew> The trendy ones mix in Cont
22:44:19 <lispy> skew: okay, i see
22:44:29 <dons> hmm. a little blog entry on that would be nice to see.  list all programming languages as special cases of haskell with monads..
22:44:40 <lispy> skew: kinda had that brewing in the back of my head lately, glad to see i'mnot way off :)
22:44:44 <dibblego> dons, that would be awesome
22:45:03 <skew> But anyway, even in Haskell we've still got a few things allowed in "pure" values that can be broken off into monads
22:45:22 <ski> though, i'd like a locally impure syntax in haskell ..
22:45:35 <lispy> ski: let?
22:45:47 <lispy> what do you mean by impure?
22:45:57 <lispy> impure meaning any side-effects?
22:46:01 <ski> yes
22:46:10 <ski> but only locally :)
22:46:13 <skew> lispy: a syntax for writing code that looks like plain expressions, but is actually in some commutative monad
22:46:29 <ski> hm, maybe s/local/lexical/ is better wording
22:46:38 <lispy> droundy mentioned it would be nice to split up IO into monads that just support some of the functionality of IO, but i thnik once you allow certain thingns, you've allowed a hole for everything
22:46:45 <skew> Raising exceptions, for one
22:46:52 <ski> skew : yes, i'm thinking about a such (module commutative)
22:47:00 <ski> (s/module/modulo/)
22:47:49 <skew> More subtly, nontermination (at least as subtle as realizing that mutable state allowed in just about every language under the sun is a design choice)
22:48:35 <skew> A pure terminating sublanguage is really nice to have when you start using functions in preconditions, introduce dependent types, etc.
22:48:48 <lispy> skew: yes
22:50:19 <lispy> but, if i may play devil's advocate...how do monads/type correctness all these wonderful things help me get software to work together to solve a problem?
22:50:40 <ski> better modularity
22:52:03 <ski> you can rely on things that aren't in state monad will not depend on that state
22:52:07 <skew> lispy: depends, are you a super genius who can keep all your preconditions and system invariants and such in your head?
22:52:30 <ski> so, one of the points of monads is that you don't need to use them everywhere
22:54:03 <lispy> no, i'm more thinking, i can barely get the programs to agree to share data and now i have to deal with monads?
22:54:41 <skew> mostly, this stuff is about making it easier to reason about things by using monads or especially their absence to show you what parts of the program can't possibly be screwing up your code by side effect
22:54:53 <dons> yep
22:55:20 <ski> exactly
22:58:00 <skew> and types are largely about writing down the contract of a function once and telling the compiler to keep track of things, rather than trying to get it all straight yourself, and being rewarded with bugs that only manifest during demos when you slip up.
22:59:26 <monochrom> That never happens.
22:59:47 <monochrom> Bugs manifests only after the developer has got the paycheck.
22:59:54 <skew> well, ok, usually things are not quite that malicious
23:00:11 <skew> but at least in a sever randomly crashing a few times a week...
23:00:35 <monochrom> "Software development" in its current "best" practice is fraudulent.
23:00:57 <monochrom> I'm joking.
23:00:58 * ski would like to see e.g. 'sequence' rewritten in terms of 'Idiom'
23:01:22 <monochrom> Doesn't the idiom paper have it?
23:01:41 <skew> There's a third and largely unappreciated point to types too
23:01:50 <ski> monochrom : i mean in the libs ..
23:02:10 <skew> which is using typeclasses and such to get the compiler to derive parts of your code from types (hopefully after inferring those types for you)
23:02:11 <monochrom> OH!
23:03:09 <ski> sequence :: (FunctorI f,Idiom i) -> f (i a) -> i (f a)
23:03:34 <ski> mapI :: (FunctorI f,Idiom i) -> (a -> i b) -> f a -> i (f b)
23:03:38 <ski> etc
23:04:30 <ski> (s/i) ->/i) =>/)
23:05:46 <desrt> types are for fools
23:05:54 <ski> @hoogle FunctorM
23:05:55 <lambdabot> Data.FunctorM :: module
23:05:55 <lambdabot> Data.FunctorM.FunctorM :: class FunctorM f
23:08:25 <ski> @type Data.FunctorM.fmapM
23:08:26 <lambdabot> forall (f :: * -> *) b (m :: * -> *) a. (Data.FunctorM.FunctorM f, Monad m) => (a -> m b) -> f a -> m (f b)
23:08:39 <andygill> @type (.)
23:08:40 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
23:09:38 <ski> (so 'mapI' would subsume 'mapM' and 'fmapM')
23:10:46 <Bobstopper> @seen dcoutts
23:10:46 <lambdabot> dcoutts is in #haskell-overflow, #ghc, #haskell and #gentoo-haskell. I last heard dcoutts speak 3h 30m 40s ago.
23:11:09 <Bobstopper> Any gtk2hs knowledgable people around?
23:11:37 <dons> hang out for a couple of hours and dcoutts should appear like the genii of the gtk-rendered lamp
23:11:48 <lispy> heh
23:11:52 <Bobstopper> Actually, maybe I can describe my problem outside gtk2hs...
23:12:30 <Bobstopper> gtk2hs has a few functions such as onClicked which has the type Button -> IO () -> IO ()
23:12:46 <lispy> okay, so my reason for asking obnoxious questions about types and monads is cuz i would never be able to convince my peers that they are useful.  They would basically take the argument that they can already program fine without them, so what's the big deal?
23:12:47 <dons> yep, they register handlers, don't they?
23:12:53 <Bobstopper> Yep.
23:13:09 <Bobstopper> Ok, I have some handlers which are not IO, but instead a StateT around a IO object
23:13:18 <dons> lispy: the blub syndrome. you don't know what you're missing if you don't understand it. Asm programmers say the same thing I suppose
23:13:20 <monochrom> lispy: do they really program fine?
23:13:29 <desrt> is programming gtk from haskell any less painful these days?
23:13:31 <Bobstopper> This has caused a lot of issues with thrying to thread state through etc. Should I just give up and resort to global IORefs ?
23:13:34 <dons> Bobstopper: hmm.
23:13:50 <dons> Bobstopper: runStateT $ my handler ?
23:13:56 <lispy> monochrom: well, to the expected standards :) (yes, i realize thatt logic is circular)
23:14:48 <Bobstopper> Yeah, I've written some functions which basically do that. However I can't figure how to thread the state through
23:14:49 <dons> Bobstopper: better check with dcoutts. if you're stuck with IO, and can't pass the state to a handler ia runStateT, then a global MVar is equivalent .
23:15:05 <Bobstopper> Here's one attempt: lift2 cmd sm = sm >>= (lift . cmd . return)
23:15:15 <Bobstopper> here's another: lift2 cmd sm = get >>=  lift . cmd . evalStateT sm
23:15:23 <lispy> exception handling is the problem i had with gui programming in haskell...i had to make something like runAndHandle :: IO () -> IO (), which popped up a message box on exceptions (what else can you do?)
23:15:37 <user317> does anyone know where i can find ghc's documentation on compiling haskell to C?
23:15:43 <Bobstopper> The first threads the state through, but it gets called outside the onClicked method, so all my handlers get called at GUI startup.
23:15:53 <dons> user317: yes, the 'Porting' guide in the user manual
23:15:56 <dons> from haskell.org/ghc
23:15:57 <Bobstopper> The second doesn't thread the state at all
23:16:44 <user317> thanks dons
23:17:18 <ski> Bobstopper : what should the type of 'lift2' be ?
23:17:31 <lispy> Bobstopper: yeah, i think the most obvious and painful solution is to let them share a ref
23:17:42 <lispy> Bobstopper: whether that's an IORef or an STRef is up to you
23:17:59 <Bobstopper> ski: lift2 :: Monad m => (m a -> m b) -> StateT s m a -> StateT s m b
23:18:51 <Bobstopper> Ok, I guess I'll have to bite the bullet. It seems to almost ruin the point of programming in Haskell though :(
23:19:29 <ski> hm, i'm not sure you can do that 'lift2' with exactly that type
23:20:01 <ski> in what situation are you trying to use it ?
23:20:29 <ski> hrm, maybe i'm stupid
23:20:35 <Bobstopper> ski: in gtk2hs as described above. eg passing StateTs to onClicked methods.
23:21:18 <ski> (m, no i wasn't)
23:21:20 <dons> Bobstopper: if you're forced into IO, then its not the end of the world to use a global variable. its just StateT in a way :)
23:21:35 <dons> really, its ok. nothing falls apart ;)
23:21:52 <dons> but still, see what dcoutts recommends
23:22:00 <monochrom> Right, two handlers registered indepedent of each other, each of  type StateT (IO ...), will not share state.
23:22:47 <user317> does haskell generate ropi C code, it doesn't look like it to me atm
23:22:49 <monochrom> Don't feel sad to commit imperative programming in Haskell.  It is the finest imperative language.
23:23:03 <dons> user317: ropi?
23:23:12 <ski> lift2 :: Monad m => (forall f. Functor f => m (f a) -> m (f b)) -> StateT s m a -> StateT s m b
23:23:17 <ski> that would work, i think
23:23:23 <dons> ghc compiles via C and assembly, as well as bytecode.
23:23:36 <user317> read only position independent
23:23:47 <user317> no writable globals
23:23:49 <dons> ah. on the mac, yes.
23:23:51 <Bobstopper> ok, I might just use the global IORefs then. Thanks for the help.
23:23:53 <dons> not elsewhere
23:24:16 <ski> Bobstopper : do you think it would be too awkward to use my version of 'lift2' ?
23:25:15 <dons> user317: if you really care, ask on glasgow-haskell-users@, and note that haskell is a language, ghc, nhc, yhc, hugs ... are implementatoins, and it depends which one you use
23:25:25 <Bobstopper> ski: hmm... onClicked and friends have types like b -> IO () -> IO a. Would your lift2 work?
23:25:37 <ski> (hm, not sure the 'Functor f => ' is needed)
23:25:50 <monochrom> I wish to lay an arrow interface on gtk2hs.  It may alleviate the sins of the world.
23:26:07 <user317> dons, thanks, i am just trying to figure out how much effort it would be to get ghc building on an embedded platform that i work on
23:26:10 <ski> Bobstopper : i didn't follow from the beginning, so i don't know exactly where you want to use 'lift2'
23:26:16 <dons> user317: what arch?
23:26:26 <user317> dons, its arm based
23:26:38 <dons> hugs or nhc/yhc may be better options
23:26:45 <Bobstopper> without the functor, your typesig is basically what I'm after. Did you have a function definition for it?
23:26:48 <dons> nhc was design for embedded systems, and yhc is its child
23:27:09 <user317> dons, but the binaries need to be ropi, and i need to be able to interface it with C
23:27:13 <dons> user317: sounds interesting though. feel free to ask on glasgow-haskell-users@haskell.org
23:27:32 <user317> dons, thanks
23:27:43 <dons> interfacing with C is ok. not sure about the binaries, best check on the relevant compiler lists
23:28:06 <dons> it may be possible to get the right outcome, with -fvia-C -optc-some-flag-here
23:28:10 <ski> @type Control.Monad.State.SteteT
23:28:11 <lambdabot> Not in scope: data constructor `Control.Monad.State.SteteT'
23:28:23 <ski> @type Control.Monad.State.runSteteT
23:28:25 <lambdabot> Not in scope: `Control.Monad.State.runSteteT'
23:28:33 <Bobstopper> @type Control.Monad.State.StateT
23:28:34 <lambdabot> forall a (m :: * -> *) s. (s -> m (a, s)) -> StateT s m a
23:28:52 <ski> err, typo :/
23:28:59 <ski> ty
23:29:13 <dons> user317: Igloo has some experience building ghc on the arm
23:29:35 <dons> and i've seen nhc built to generate linux/arm executables on a credit-card sized embedded system
23:30:13 <monochrom> AH!
23:31:57 <monochrom> onClick is in terms of IO.  We have everything else in terms of StateT (IO ...).  We wish to lift the former into the latter, so as to obtain state threading.
23:32:11 <roconnor> who is dan piponi?
23:32:51 <monochrom> onClick b :: IO() -> IO().  Want lifted_onClick b :: StateT s IO () -> StateT s IO ().
23:33:30 <user317> dons, i need to do more then just built it, we have a bunch of stuff restricting how memory is allocated, processes started etc..., and it doesn't map easily to posix, everything has to have a context
23:33:58 <monochrom> It probably is not possible.
23:35:27 <ski> a problem is that the argument of type 'StateT s IO ()' might change the state, so how are we going to transform this down to 'IO ()' ?
23:36:00 <monochrom> onClick registers the IO side, not the StateT side.  The StateT side has to be lost.
23:36:07 <ski> yes
23:36:41 <ski> (but the 'IO' side could depend on the current state, for deciding what to do, as well)
23:37:28 <monochrom> I am always suspicious of "registering a handler".
23:37:57 <ski> who knows how many times (or when) 'onClick' will call it's argument 'IO ()' .. how are we going to make the corresponding 'State s IO ()' communicate with the rest of the state monad ?
23:38:10 <ski> s/it's/its/
23:38:28 <Bobstopper> Yeah... a futile task I suppose
23:38:42 <Bobstopper> Ok, well at least now I know it can't be done. Thanks :)
23:39:18 <ski> Bobstopper : possibly my idea could be used .. but not in your case, since 'onClick' takes and returns 'IO ()', i.e. '()' instead of some polymorphic thing where we could insert our state
23:39:40 <ski> (so maybe it could work with redesign of 'onClick' ..)
23:40:36 <ski> hm
23:40:45 <monochrom> Heh!  unsafeInterleaveIO is also a "register a handler"
23:40:50 <ski> what would happen if we use an IORef ?
23:41:12 <Bobstopper> global IORefs are the change I'm making now.
23:41:18 <Bobstopper> it should work
23:41:25 <ski> Bobstopper : i mean for defining 'lift2' :)
23:41:26 <Bobstopper> I was just being a little stubborn :)
23:41:57 <Bobstopper> Oh right... Hmm..
23:43:13 <monochrom> an IORef is agreed upon.  (may even be global)  all StateT operations such as get/set are coded to update that IORef too.
23:43:33 <monochrom> this begs the question.
23:43:33 <dons> mm. there are now 101,435,253 websites online, up from 97.9 million last month
23:44:31 <dons> oh, the first site, supposedly, http://www.w3.org/History/19921103-hypertext/hypertext/WWW/TheProject.html
23:44:35 <dblhelix> @where darcs
23:44:35 <lambdabot> Title: The World Wide Web project, http://tinyurl.com/3apuu
23:44:35 <lambdabot> http://darcs.net/
23:44:49 <ski> monochrom : which ?
23:45:09 <monochrom> All questions.  Why use StateT in the first place, for example.
23:45:11 <Bobstopper> ski: actually, IORefs won't help my exact situation... because I actually have two StateTs within eachother, so I wanted a generic Monad in StateT s m a rather than StateT s IO a
23:45:31 <monochrom> Horror
23:45:53 <ski> StateT s0 (StateT s1 m) a  ~=  StateT (s0,s1) m a   iirc
23:46:38 <dons> yeah, don't nest. that's just going to hurt, isn't it?
23:47:09 <ski> well, i meant that one can probably make conversion function to nest and unnest
23:47:33 <Bobstopper> Yeah, it's the same, but I have one StateT in another library, and I needed to add to the state held in it. Thus an extra StatT on top. How should I have done it?
23:47:45 <ski> dons : if s/he in some cases wants to just use one of the two states ..
23:48:33 * Bobstopper must be somehow missing the point of monad transformers...
23:48:58 <ski> (Bobstopper : i think your idea sounds reasonable)
23:50:13 <ski> Bobstopper : hm, anyway .. it seems that you probably can't define your 'lift2' for any arbitrary monad ..
23:51:56 <Bobstopper> :( Oh well, it was an learning exercise anyway.
23:53:34 <ski> hmmm
23:53:39 <ski> lift2 :: (IO a -> IO b) -> StateT s IO a -> StateT s IO b
23:53:39 <ski> lift2 cmd sm = StateT $ \s0 ->
23:53:39 <ski>   do ref <- newIORef s0
23:53:39 <ski>      b <- cmd $ do
23:53:39 <ski>        s1 <- readIORef ref
23:53:41 <ski>        (a,s2) <- sm `runStateT` s1
23:53:44 <ski>        writeIORef ref s2
23:53:46 <ski>        return a
23:53:49 <ski>      s3 <- readIORef ref
23:53:51 <ski>      return (b,s3)
23:53:54 <ski> Bobstopper : could that do what you want ?
23:54:17 <dons> yeah, that's the kind of thing
23:54:45 <ski> it type-checks, at least :)
23:57:09 <Bobstopper> Hmm... looks reasonable, yeah
23:57:18 <dons> oh fun. idea to save the tasmanian devil from extinction: reintroduce it to the .au mainland, and let it clean up the feral cats and foxes.
23:57:25 <monochrom> Not according to my understanding.
23:58:50 <Bobstopper> Any idea which has a side effect of reducing the feral cat count in Australia is a good idea to me. Short of maybe nuking everything...
23:59:11 <Bobstopper> I just wish global IORefs had reduced cat population as one of their side-effects...
23:59:28 * ski grins
