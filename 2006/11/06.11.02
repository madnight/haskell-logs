00:00:09 <Bobstopper> I might have to stick with the global IORefs. I was getting tired of all the liftIOs everywhere anyway.
00:00:23 <Bobstopper> ski++
00:01:37 <dons> using io = liftIO is a bit nicer
00:01:47 <Bobstopper> I did that but it was still annoying
00:02:18 <Bobstopper> putting it in almost every line of 100+ line code is pretty tedious
00:02:31 <dons> oh, hmm, io $ do ....
00:02:51 <dons> i.e. lift chunks at a time if possible
00:03:08 <Bobstopper> Yeah, tried that for a while but the ordering meant all the do blocks kept getting broken up by stuff that worked in the current monad.
00:03:48 <Bobstopper> so it added work in most places
00:04:22 <ski> (Bobstopper : did that mean my idea code would work ?)
00:04:24 <Smokey`> ...tasmanian devils will be far more of a problem than feral cats (though foxes - can be very big issues)
00:05:00 <dons> Smokey`: but it would be fun ! devils are angry, noisy mini-Russel Crowes. Who wouldn't want those roamin the bush?
00:06:11 <Bobstopper> ski: Yeah, it probably would work if I found a way to make it work with the nested StateTs. I might use your solution yet if I decide to keep only the inner StateT.
00:06:59 <Smokey`> dons: some people like roamin' in the bushes :P
00:07:42 <Bobstopper> @remember dons devils are angry, noisy mini-Russel Crowes. Who wouldn't want those roamin the bush?
00:07:50 <Smokey`> those people generally don't want angry/vicious little things attacking them, and will kill them (in the process, possibly getting bitten, and potentially getting disease) :P
00:08:04 <theoco> haskell I think needs to be easier to learn, I liked scheme a lot cause it was so easy to learn :(
00:08:28 <monochrom> haskell is very easy to learn
00:08:54 <theoco> monochrom: you must be very smart ;)
00:08:58 <Smokey`> theoco: as a newbie to haskell, I would have to say the basics are very easy to learn, but getting your head around thse abstract ideas like Moands, can be difficult.
00:10:18 <monochrom> I am not smart.  I just sold my intuition to satan.
00:11:31 <dons> my girlfriend actually served Russell Crowe at the oxfam shop she worked at a year or so ago. He was a bit stern, and payed with a wad of cash, iirc.
00:12:32 <dons> </end-dons-fact-of-the-day>
00:13:13 <monochrom> No!
00:13:17 <ski> Bobstopper : couldn't you use a 'Monad m => StateT s2 m a -> StateT (s1,s2) m a' for lifting into a combined state monad ?
00:13:58 <desrt> monads are not an idea!
00:14:00 <ski> (Bobstopper : instead of the ordinary 'lift' i mean .. or what was your problem with nested 'StateT's ?)
00:14:03 <desrt> monads are nothing!
00:14:34 <monochrom> They say Mozart's Mass in C minor K427 is uplifting.  I'm going to name my next monad transformer or arrow transformer MozartMassInCMinorK427T
00:14:59 <monochrom> monads are monsters.
00:15:22 <ski> the identity monad is initial
00:15:23 <Smokey`> and fuzzy things.
00:15:42 <dons> mo	heh
00:16:13 <dons> mo\tnochrom
00:16:34 <monochrom> http://www.haskell.org/pipermail/haskell-cafe/2006-November/019190.html
00:16:36 <lambdabot> Title: [Haskell-cafe] there's a monster in my Haskell!, http://tinyurl.com/y49m75
00:16:49 <monochrom> It's lovely!
00:17:07 <ski> hm, is 'Ignore' defined by 'data Ignore a = I' a terminal monad ?
00:17:50 <Bobstopper> ski: that could be another option... hmm.
00:18:21 <Bobstopper> I suppose if I wrote some sort of generic wrapper function which automatically converted all the original monad functions it would make sense...
00:19:06 <ski> "Fortunately, monsters gladly contribute their values towards the creation of more monsters" :D
00:21:24 <int-e> oh yes, monsters are cute :)
00:23:02 <monochrom> Gremlins anyone? ...
00:23:35 <monochrom> poisoned candies and release dates are myths. :)
00:24:14 * monochrom suggests Template Haskell to Bobstopper, heh heh heh, I mean bwahahahahaha....
00:24:52 * Bobstopper doesn't get it...
00:27:00 * ski for a short while thought that Bobstopper's problem would be a good use case for 'mapT', but alas ..
00:32:54 <desrt> ?type mapT
00:32:55 <lambdabot> Not in scope: `mapT'
00:33:03 <desrt> ?hoogle mapT
00:33:04 <lambdabot> Data.Generics.Basics.gmapT :: Data a => (b -> b) -> a -> a
00:33:08 <desrt> oh crikey.
00:33:31 <monochrom> Template Haskell is another learning curve, that's why.
00:34:53 <ski> mapT :: (MonadFunctor t,Monad m,Monad n) -> (forall x. m x -> n x) -> t m a -> t n a
00:34:56 <ski> of course
00:50:49 <dblhelix> @hoogle bounds
00:50:50 <lambdabot> Array.bounds :: Ix a => Array a b -> (a, a)
00:50:50 <lambdabot> Data.Array.bounds :: Ix i => Array i e -> (i, i)
00:50:50 <lambdabot> Data.Array.IArray.bounds :: (HasBounds a, Ix i) => a i e -> (i, i)
00:55:47 <dblhelix> @where indices
00:55:47 <lambdabot> I know nothing about indices.
00:59:20 <dons> hah http://www.smh.com.au/news/web/utube-sues-youtube/2006/11/02/1162339964137.html
00:59:22 <lambdabot> Title: Utube sues YouTube - web - Technology - smh.com.au, http://tinyurl.com/yyhsmb
01:07:30 <dblhelix> how to build happy??
01:08:59 <yaarg> hrm?
01:09:14 <yaarg> ./configure; make; make install?
01:11:32 <Bobstopper> ski: I ended up taking your suggestion and wrote a function which combines my state monads. It works much better now. Thanks :)
01:11:39 <Bobstopper> ski++
01:13:02 <Bourbaki> moin
01:17:46 <dblhelix> yaarg: the version available for download does not compile, though
01:18:10 <Bourbaki> dons are you awake?
01:25:54 <dblhelix> @hoogle IntArray
01:25:55 <lambdabot> No matches found
01:27:20 <ski> Bobstopper : glad it helped
01:37:36 <lisppaste2> therp pasted "GHC hacking - FastString identity?" at http://paste.lisp.org/display/29147
01:37:54 <therp> I would be happy for any suggestions..
01:42:09 --- topic: '["Design a #haskell tshirt - Distribute your cognition!", "Haskell - the language of ICFP winners 3 years running", "Logs: http://tunes.org/~nef/logs/haskell/"]'
01:42:09 --- topic: set by dons on [Tue Oct 31 01:30:26 2006]
01:42:09 --- names: list (clog petekaz pingu exnor kolmodin_ therp drbean resiak TSC rblackwe kaol df__ ajonat_ swiert Bourbaki related tessier_ drrho x3m dblhelix slipstream JohnMeacham Baughn_ Spark vegai_ eno__ koffein scw tmoertel_away Patterner Blicero atsampso1 lisppaste2 slime_mold Plareplane scsibug xerox cdfh fabiim sylvan shapr theoco weitzman thief_grr Sweetsha1k Pupeno khaladan hyrax42 russo ramkrsna toyz qz Syzygy- astrolabe Philippa cjpatrick GeoBesh)
01:42:09 --- names: list (matthew-_ Tigge dcoutts flux__ kzm Lemmih SimonRC ulfdoz klutometis desrt thou ToRA lispy Nioate Kattana Foxyloxy cmeme _matthew_ Akheron Igloo profmakx earthy sigfpe_ Khisanth norpan audreyt wolverian ski musasabi magagr aleator bran_ thebug arcatan ozone carp dons psnl kalven mux rycee pejo emu)
01:54:21 <therp> I hope nobody minds if I repeat that after the join-flood cleared everyones history. "therp pasted "GHC hacking - FastString identity?" at http://paste.lisp.org/display/29147"
02:18:28 <Lemmih> therp: Try printing their unique identifier.
02:19:39 <therp> lemmih: how would I do that?
02:20:44 <therp> I just modified the instance Outputable RdrName to print the Exact/Unqual/Qual/Orig classification, but I suppose you don't mean that
02:28:50 <Lemmih> therp: -fppr-debug, I think. Not sure, though.
02:30:51 <therp> lemmih: ah, -dppr-debug it is. the output is produced with that option (otherwise you wouldn't see {v} after the RdrName)
02:46:57 <kzm> FFI to a C function that sets int *count and int **items.  I'd like to have it return [Int].  Is there an example I could look at?
02:47:55 <kzm> I guess I could write a ptrsToList function that iterates over the arrays...
02:49:20 <therp> I absolutely do not get what's this GHC problem is about.
03:17:11 * Lemmih frowns at Bulat.
03:19:25 <Philippa> what's the latest?
03:21:37 <kzm> Possible to print the value of a Ptr?
03:21:56 <kzm> I get:  No instance for (Integral (Ptr CULong))
03:22:43 <Lemmih> kzm: It's an instance of Show.
03:23:17 <kzm> uhm...right.  Since I'm debugging I wanted an Int, but I guess I can use a string as well.
03:25:26 <kzm> OOOOH, yes!  Damn, I'm good!
03:25:37 <kzm> Ahem - that is, I mean, thank you Lemmih. :-)
03:26:27 * ski misread 'Bulat' as 'Borat'
03:27:29 <kzm> Bulat: Monadic learnings of category theory for make benefit glorious language of Haskell?
03:27:44 <Lemmih> heh (:
03:30:01 <pejo> What does that mean?
03:30:56 <kzm> Not that I care about the odd wasted byte, but - the docs for my C function kindly suggest I free the returned pointer table... How?
03:31:34 <Lemmih> kzm: ptrsToList == peekArray?
03:32:38 <therp> haha kzm :)
03:33:01 <kzm> Lemmih, I see.
03:34:30 <Lemmih> kzm: alloca $ \countPtr -> alloca $ \itemsPtrPtr -> do yourCFunc countPtr itemsPtrPtr; count <- peek countPtr; itemsPtr <- peek itemsPtrPtr; items <- peekArray count itemsPtr; free itemsPtr; return items?
03:35:56 <kzm> Something like that, yes.
03:36:20 * kzm didn't find 'free' in the FFI docs, prolly looking at the wrong place.
03:36:39 <Lemmih> @index free
03:37:08 <Lemmih> Oh no, lambdabot has fallen.
03:37:49 <kzm> There you go, it's not just me.
03:40:56 <kzm> peekArray is strict enough that the itemsPtr won't be free'd too early?
03:41:45 <kzm> (seems to work - but you never know)
03:45:59 <Lemmih> kzm: Yeah, peekArray is strict.
03:47:11 <kzm> I guess a lazy version isn't too useful, as the array is there anyway.
03:55:01 <ndm> @users
03:59:40 <dons> netsplit
04:03:36 <araujof> heya!
04:03:39 * araujof from univ.
04:03:49 <araujof> ha, it looks like there exist a big split here
04:04:28 <Baughn> lambdabot has split, for certain
04:17:42 <araujof> Baughn, i tried to connect , and it was splitting
04:18:35 <dons> :( for hours now. worse ... netsplit ... ever....
04:19:06 <dons> on the other hand, there's a nice monad (well sort of nice) thread happening on reddit http://programming.reddit.com/info/ox6s/comments
04:19:28 <dons> while we twiddle our thumbs waiting for lambdabot to return :)
04:19:47 <SamB_XP> hmm, it looks like *we* are the split people?
04:20:09 <Bourbaki> dons didnt you forget something ;)?
04:20:29 <dons> sigh.
04:20:46 <SamB_XP> --- *** Notice -- Server is currently split, channel modes are limited
04:21:04 <Bourbaki> http://video.google.de/videoplay?docid=1850454753477709166
04:21:06 <dons> i've got about 10 people waiting on my mailing inbox atm. i need to unsubscribe from some things so i can actually get through it all
04:21:09 <Bourbaki> http://video.google.de/videoplay?docid=-3606231954830775250
04:21:18 <Bourbaki> the other project im working in the mean time btw :)
04:21:48 <dons> ok good.
04:22:01 <dons> dcoutts: oh, looks like we uncovered a bug in yhc and nhc :)
04:22:07 <dcoutts> oh ?
04:22:34 <dons> they say: Constructor :*: used at 590:22-590:24 is not defined.
04:22:35 <therp> hm, isn't there any GHC developer mailing list?
04:22:38 <dons> in Data.ByteString.Lazy
04:22:44 <ndm> bad dons, bad dcoutts
04:22:45 <dons> therp: yep, cvs-ghc@haskell.org
04:22:53 <dons> ndm: what could it be?
04:23:04 <ndm> dons: anything, the name resolution bug is a pile of crap
04:23:10 <ndm> * bug -> code
04:23:15 <dcoutts> heh
04:23:15 <dons> therp: though glasgow-haskell-users@haskell.org is also fine
04:23:23 <ndm> (although sometimes i think its one big bug, rather than a piece of code)
04:23:29 <dons> heh
04:23:30 * beelsebob notes that ndm appears to be implying that name resolution in yhc is a bug
04:23:41 <beelsebob> damn - he beat me
04:23:42 <dons> it shouldn't resolve names at all, clearly.
04:23:47 <ndm> beelsebob: a million bugs, just waiting to bite :)
04:23:47 <dons> lets use #include instead!
04:24:37 <araujof> dons!
04:24:47 <Philippa> does YHC do recursive module dependencies, and if so how?
04:24:54 <ndm> Philippa: no
04:24:58 <therp> dons: well, the question I seek answers for is really too weird in contrast to the content that usually comes on g-h-u :)
04:25:17 <SamB_XP> are you kidding? it didn't even chase dependencies last I heard
04:25:58 <dons> araujof: thanks for the translation work
04:26:03 <Philippa> heh. Well, normal dependencies don't actually require any more support than finding the compiled code...
04:26:07 <dons> should that be araujo' ?
04:26:15 <dons> Philippa: hehe.
04:26:34 <Philippa> ndm: is it something that you're planning to support?
04:26:39 <araujof> dons, It's cool!
04:26:43 <araujof> dons, yeah, it's me :-)
04:26:52 * araujof connected from univ.
04:26:54 * araujof connected from univ.
04:27:12 <dons> so it should be araujo-universidad? :)
04:27:15 <araujof> dons, i hope to get a bit more stuff translated ....
04:27:20 <dons> cool
04:27:30 <ndm> Philippa: requires fixing the type checker and name resolution, but yes, we hope
04:27:38 <dcoutts> araujof, btw, I did test hsshellscript, it's ok by me
04:27:38 <dons> yeah, the #haskell.es team seems to be doing a great job.
04:27:39 <araujof> dons, haha i wanted that name too, but it was too long :-)
04:27:43 <Philippa> cool
04:27:55 <araujof> dcoutts, cool! , i will commit when i get home then :-)
04:28:00 <dcoutts> ta
04:28:05 <Philippa> I have funky uses for recursive dependencies that I've probably told you about before :-)
04:28:19 <Philippa> (and they get even better if you support enough extensions for an encoding of extensible records)
04:28:38 <araujof> dons, hah yeah, we got even a new record on the users number a few days ago :-)
04:29:01 <dons> great!
04:29:16 <dons> we've also got a lambdabot in #gentoo-uy as well
04:29:20 <araujof> dons, i am also telling to a friend of mine to translate the pages to chinese
04:29:27 <dons> wow!
04:30:17 <araujof> dons, he isn't into Haskell too much _yet_ , but he is already in the road to enlightenment
04:33:18 * araujof needs to present the project within a few minutes
04:33:33 <araujof> agh, im a bit hungry, i wonder if i should get some food first
04:35:34 <araujof> ok, off to class
04:35:40 <araujof> back in a few hours
04:45:41 <shapr> Good morning #haskell!
04:45:58 <therp> good morning shapr
04:46:15 <profmakx> for certain values of morning ;)
04:47:23 <dons> such as 1147pm :)
04:49:09 <dons> ?welcome back Kotter-bot!
04:49:37 <lambdabot> Unknown command, try @list
04:49:40 <shapr> It's 6:48am here, that's morning in Alabama.
04:50:13 <profmakx> so you are 7 hours behind me. catch me if you can ;)
04:50:15 <shapr> I do wish the internet would start using a single time for scheduling meetings.
04:50:21 <profmakx> tc?
04:50:59 <shapr> internet time from swatch?
04:51:16 <profmakx> outch
04:51:19 <profmakx> i meant utc
04:51:40 <dons> ?users
04:51:41 <lambdabot> Maximum users seen in #haskell: 265, currently: 143 (54.0%), active: 5 (3.5%)
04:51:48 <shapr> Wow, netsplits?
04:51:53 * dons wonders when the big split will end 
04:51:57 <dons> yeah, a few hours now
04:52:19 <dons> though lambdabot was finally able to get back, so maybe its getting better
04:53:24 <int-e> hmm, still only 3 links on this server
05:01:09 <dons> int-e: how'd you work that out?
05:01:26 <profmakx>  /links
05:01:45 <profmakx> /map does not work on freenode however
05:02:20 * dons learns some things everyday. 
05:03:56 <shapr> You can try /quote help
05:04:07 <shapr> That'll show you the raw list of commands offered by the server.
05:04:51 * profmakx wonders how a /map of freenode would look
05:06:56 <shapr> yow!
05:07:12 <xerox> ?yow!
05:07:13 <lambdabot> I can't think about that.  It doesn't go with HEDGES in the shape of
05:07:13 <lambdabot> LITTLE LULU -- or ROBOTS making BRICKS ...
05:07:38 * shapr boings cheerfully
05:25:41 <musasabi> I wish "newtype Foo = forall a. Foo (FooEx a)" was allowed.
05:31:43 <dblhelix> @seen JaffaCake
05:31:43 <lambdabot> I saw JaffaCake leaving #ghc 5d 21h 43m 54s ago, and .
05:32:27 <shapr> musasabi: I guess the limits are typeclass limitations in data declarations?
05:33:01 <musasabi> shapr: but one can have: "type Foo = forall a. FooEx a"
05:36:55 <Baughn> Hang on, is Either a monad?
05:38:24 <Baughn> @type option
05:38:26 <lambdabot> Not in scope: `option'
05:38:56 <dons> ?instances Monad
05:38:57 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
05:39:29 <dons> i have to say that ((->) r) is my favourite, mostly because we didn't know how to use it till @pl came along and who'd us the way
05:39:33 <xerox> Baughn: yep
05:39:45 <dons> s/showed/  who'd?? sleep time!
05:40:00 <Baughn> dons: Then is http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Either.html incorrect, or am I missing something crucial?
05:40:02 <lambdabot> http://tinyurl.com/wtlo6
05:40:39 <dons> > Right () >> Left "done" >> Right ()
05:40:41 <xerox> Baughn: Maybe a is the type of computation that either result in a Just a or fail in a Nothing.  Either a b instead can be viewed as the type of computations that result in a Right a, or fail with an error Left b.
05:40:42 <lambdabot>  Left "done"
05:41:11 <dons> > Right (1+2) ; Left "oh no!" ; Right 3
05:41:11 <lambdabot>  Parse error
05:41:14 <dons> > do Right (1+2) ; Left "oh no!" ; Right 3
05:41:15 <lambdabot>  Left "oh no!"
05:41:36 <dons> right, those docs seem to be missing the Monad instance
05:41:47 <dons> it only has the Functor instance hmm
05:42:32 <Baughn> Is it safe for me to use, then? It'd be troublesome if the monad interface went away in a later version
05:42:34 <dons> now, where is that pesky instance
05:42:41 <dons> oh, it's safe I think :)
05:42:59 <xerox> dons: I think it's hidden inside the Error instance..  ErrorT?
05:43:04 <dons> ah maybe
05:43:25 <dons> xerox++
05:43:26 <dons> instance (Error e) => Monad (Either e) where
05:43:26 <dons>     return        = Right
05:43:26 <dons>     Left  l >>= _ = Left l
05:43:26 <dons>     Right r >>= k = k r
05:43:28 <dons>     fail msg      = Left (strMsg msg)
05:43:32 <xerox> ^_^
05:44:04 <dons> > do x <- Right "yes" ; return x
05:44:05 <lambdabot>  Add a type signature
05:44:47 <xerox> And I thought you needed {} there.
05:45:04 <dons> nah, should be fine.
05:45:12 <dons> > do x <- Right "yes" ; return x :: Either () String
05:45:13 <lambdabot>  add an instance declaration for (Error ())
05:45:13 <lambdabot>   In a 'do' expression: x <- R...
05:45:19 <dons> > do x <- Right "yes" ; return x :: Either String String
05:45:21 <lambdabot>  Right "yes"
05:45:44 <xerox> > fail "Yikes!" :: Either String ()
05:45:45 <lambdabot>  Left "Yikes!"
05:46:07 <dons> > do x <- return "yes" ; case x of "no" -> fail "no!" _ -> return x :: Either String String
05:46:08 <lambdabot>  Parse error
05:46:17 <dons> > do x <- return "yes" ; case x of "no" -> fail "no!" ; _ -> return x :: Either String String
05:46:18 <lambdabot>  Right "yes"
05:46:26 <dons> > do x <- return "no" ; case x of "no" -> fail "no!" ; _ -> return x :: Either String String
05:46:27 <lambdabot>  Left "no!"
05:48:34 <Baughn> What would be nice is if this documentation optionally showed all the functions that work on a type, without having me do a depth-first search. -_-
05:48:49 <dblhelix> dons: what workaround to you recommend for the lack of INSTACE_TYPEABLE macro in ghc 6.6 if it comes to building hs-plugins?
05:48:55 <dons> Baughn: hoogle might help there
05:49:07 <Baughn> dons: Indeed
05:49:07 <dons> dblhelix: we don't need our own Data.AltTypeable anymore
05:49:13 <dons> the workaround is to appear this weekend :)
05:49:34 <dons> currently hs-plugins _can't_ be used with 6.6, for 2 reasons i'll fix this weekend
05:49:55 <dons> dblhelix: is now number 7 person to ask :)
05:50:06 <dblhelix> ah, that's unfortunate.. I was trying to build goa :(
05:50:26 <dons> right. you can still, lambdabot doesn't need hs-plugins
05:50:32 <dons> thus goa doesn't need hs-plugins
05:50:49 * dblhelix is surprised...
05:50:53 <xerox> (:
05:50:57 <dons> plugins are optional for lambdabot.
05:50:58 * dblhelix thought lambdabot needed plugins
05:51:09 <dons> you can built it statically or dynamically linked
05:54:41 --- topic: '["Design a #haskell tshirt - Distribute your cognition!", "Haskell - the language of ICFP winners 3 years running", "Logs: http://tunes.org/~nef/logs/haskell/"]'
05:54:41 --- topic: set by dons on [Tue Oct 31 01:30:26 2006]
05:54:41 --- names: list (clog fik sjanssen SamB_XP Zr40 orbitz _matthew_ matthew-_ carp Kattana lispy Foxyloxy khaladan jak x3m Codex_ mGem CrewdenX Prip mr_ank mattam ndm moonlite koffein nnunley gaal jcreigh gzl Dylan ksandstr lOkadin boliver_ triple_ thneed Twigathy SamB tessier badalex saccade_ wagle mathrick gour Eidolos Trixsey palomer Captain_Fourier arguile_ pandres Cale petekaz pingu therp drbean resiak TSC df__ dblhelix slipstream JohnMeacham Baughn)
05:54:41 --- names: list (vegai eno__ tmoertel_away atsampso1 lisppaste2 Plareplane cdfh sylvan shapr theoco Pupeno Philippa Tigge kzm Lemmih SimonRC ulfdoz klutometis desrt profmakx Khisanth norpan ozone arcatan thebug bran_ aleator magagr musasabi largos)
05:54:46 <dblhelix> anyway, happy seems broken... which seems strange... but I could  not build it immediately with ghc 6.6... is this a known issue?
05:54:55 <dons> yikes!
05:55:13 <dons> looks like the server just got rebooted without warning?
05:55:31 <dblhelix> anyone built happy lately?
05:55:39 <dons> ?yow
05:56:10 <Baughn> dons: By the way, could you turn off the identification requirement for messaging lambdabot? It's not likely to get annoyed by spam, but I can't identify..
05:56:14 <lambdabot> Tex SEX!  The HOME of WHEELS!  The dripping of COFFEE!!  Take me to
05:56:16 <lambdabot> Minnesota but don't EMBARRASS me!!
05:56:30 <dons> Baughn: hmm. I thought it was off?
05:56:46 <dons> what was the command for that again?
05:56:53 <xerox> ?botsnack
05:56:59 <Baughn> dons: ..it was - I got the error from my /msg to *nickserv*!
05:57:01 <Baughn> Bugger
05:57:15 <xerox> Freenode is wavey today.
05:57:19 <dons> uh hu.
05:57:34 <dons> ?bot
05:57:50 <shapr> dons: Did you see my question about lambdabot on jabber? Does it work?
05:57:51 <int-e> yay, more netsplits
05:58:00 * shapr boings
05:58:04 <int-e> and server reboots
05:58:08 <int-e> apparently
05:58:13 <dons> shapr: i don't know if it works, shapr.
05:58:16 <shapr> oh, ok.
05:58:21 <dblhelix> dons: how to build lambdabot without plugins
05:58:23 <dblhelix> ?
05:58:27 <shapr> thanks for the answer :-)
05:58:36 <xerox> dblhelix: I think you use the right Makefile
05:58:37 <dons> dblhelix: should build without by default.
05:58:41 <xerox> Arrr.
05:58:48 <dons> dblhelix: the .cabal file from darcs should be setup for no plugins by dflt
05:59:09 <dblhelix> dons: tnx
06:01:45 <dons> no lambdabot can't connect at all :/
06:02:09 <roconnor> hey, everyone's back
06:02:38 <dons> nope. 137 nicks. 'bout half?
06:02:48 <dons> are all the servers back?
06:03:08 <roconnor> It was lonely with just 5
06:03:09 <dons> ah, the .eu ones are.
06:03:26 <profmakx> if the servers were rebooted at least all the idlers were cleaned up :)
06:03:32 <dons> doh!
06:03:37 <profmakx> dos attack
06:03:39 <dons> now we play the waiting game...
06:03:39 <profmakx> gnarf
06:03:49 <dons> profmakx: oh? you read that?
06:03:50 <roconnor> whew, I was afraid of a unix attack
06:04:26 <profmakx> 15:03:32 [freenode] -christel(i=christel@freenode/staff/gentoo.christel)- [Global Notice]
06:04:46 <dons> ah. good.
06:05:01 <dons> hey, i actually met christel a couple of weeks ago
06:05:58 <dons> nope, bot still can't get on. hmm
06:06:11 <dblhelix> @where fps
06:06:35 <dons> http://www.cse.unsw.edu.au/~dons/fps.html
06:06:45 <dblhelix> :)
06:07:22 <dons> hmm, i'm getting: unable to connect server irc.freenode.org port 6667 [non-recoverable failure in name ... from the bot
06:07:51 <dblhelix> apparently there's a dos going on...
06:08:02 <dons> including dns?
06:08:53 <dons> well, it was a pretty good effort. we were netsplit for hours.
06:08:58 <dons> and maybe still are.
06:09:24 <profmakx> how many users are there on freenode?
06:11:19 <dons> ah indeed, it is still split
06:11:21 <roconnor> I don't see anything about a freenode dos attack on google news
06:11:58 <dons> quick .. submit it! :)
06:12:30 * tmoertel needs espresso _bad_
06:12:33 <roconnor> this just in, freenode dosed...  now do I submit to google?
06:12:46 <profmakx> slashdot?
06:12:56 <roconnor> of course
06:12:56 <profmakx> wuahahah
06:13:23 <roconnor> we can include an irc:freenode.net link
06:13:32 <dons> heh
06:13:39 <roconnor> then freenode can be dossed and dotted
06:20:14 <dblhelix> dons: scripts/BotPP.hs:21:17:
06:20:14 <dblhelix>     Could not find module `Data.ByteString.Char8':
06:20:14 <dblhelix>       it was found in multiple packages: fps-0.7 base
06:22:04 <dons> why did you install fps on top of your ghc 6.6 :)
06:22:08 <dons> ghc-pkg unregister fps
06:24:06 <dblhelix> dons: because lambdabot's cabal pkg descr told cabal that lambabot needs fps :)
06:24:11 <dblhelix> I guess
06:24:12 <dons> ah well
06:24:18 <dons> live and learn. and update docs :)
06:26:13 <dons> is anyone else able to: nslookup chat.freenode.net ?
06:27:36 <roconnor> Non-authoritative answer:
06:27:36 <roconnor> *** Can't find chat.freenode.net: No answer
06:27:39 <SamB> dons: cabal listens to docs?
06:27:53 <dblhelix> dons: not just the docs, the pkg descr, I guess?
06:28:33 <dons> dblhelix: hmm. are you using the 6.6 .cabal file?
06:28:42 <dons> lambdabot.cabal.ghc-6.6
06:29:15 <dons> i.e. mv lambdabot.cabal.ghc-6.6 lambdabot.cabal ; before you run ./build
06:29:36 <dblhelix> dons: mmm...
06:29:45 <dblhelix> dons: oops
06:30:12 <dons> roconnor: now isn't that strange
06:30:34 <roconnor> I don't know.  Is that one way of dealing with a DOS?
06:30:50 <dons> well it means i can't resolve the server from lambdabot...
06:30:55 <dons> so i guess it might be one way :}
06:31:12 <dons> similar to the 'turn off power supply' soln
06:31:27 <dons> (though those still here get to stay and play)
06:31:31 <SamB> dons: I've almost got a dynamic lambdabot going
06:31:35 <dons> cool
06:31:57 <roconnor> dons: chat.eu.freenode.net resolves
06:32:02 <dons> ah good
06:32:16 <dons> yes, i think its only europe back online
06:32:39 <dons> oh no, all the others are there now /links
06:33:00 <SamB> dons: should I just replace lambdab.cabal.plugins with that version, or should I make yet another .cabal variant?
06:33:04 <SamB> er.
06:33:18 <dons> SamB: fix the .plugins one
06:33:23 <SamB> ah good
06:33:48 <SamB> oh, I suppose I should do something to make sure BotPP is built *before* Cabal is invoked...
06:33:58 <roconnor>  /links?
06:35:29 <dons> nope. loooks like the bot will have to wait till tomorrow, chat.eu.freenode.net port 6667 [Connection refused]
06:36:51 <roconnor> we don't need a bot, we have dons!
06:36:58 <roconnor> @where fps
06:37:16 <xerox> http://www.google.com/
06:37:33 <dblhelix> anyone any idea how to provide cabal support for project involving uuag-files?
06:37:52 <dons> unrecognised command: @where. Try sending me $money
06:38:00 <dblhelix> /s/project/projects
06:38:03 <SamB> $money
06:38:15 <dons> http://www.cse.unsw.edu.au/~dons/fps.html
06:38:48 <dblhelix> mmm.. that's an idea: every user should get a daily quotum of lambdabot queries...
06:38:54 <dons> heh
06:39:14 <int-e> lambdabot 'deluxe'
06:39:31 <int-e> lambdabot prime?
06:39:36 <Baughn> I suspect that'd just make someone introduce turingbot
06:40:43 <dons> ok. night all. i've left the bot trying to connect, so if the dns recovers, hopefully it will connect on its own
06:42:22 <SamB> Baughn: is that based on turing machines, or does it attempt to pass the turing test?
06:42:32 <roconnor> @karma+ dons
06:43:18 <Baughn> SamB: It's based on the turing machine abstraction of computation, as opposed to the entirely different lambda abstraction. As such it has Super Turing Powers!
06:43:32 <roconnor> dons now has a karma of 983820135
06:43:53 <Baughn> ..clearly an example of voting fraud
06:44:11 <psi> is something wrong with freenode?
06:44:42 <psi> had to try a bunch of different servers before i could connect
06:44:55 <Baughn> psi: It's under siege by slavering mobs of zombies
06:45:04 <SamB> @hoogle FilePath -> FilePath
06:45:12 <SamB> oh right
06:45:13 <SamB> damn
06:45:38 <SamB> now I can't flood the channel with my pathetic attempts to find API functions
06:45:48 <dons> psi, which server worked?
06:45:53 <Baughn> See, that's why I /msg the bot
06:46:05 <psi> dons, lem.freenode.net
06:46:14 <roconnor> Distribution.Compat.FilePath.dropAbsolutePrefix :: FilePath -> FilePath
06:46:22 <Baughn> (#haskell is in window 3. lambdabot is in window 4. Yay!)
06:48:29 <roconnor> @botsnack
06:49:00 <lambdabot> :)
06:49:37 <dons> so lem.* is in somehere behind 20  HostLine2-gw.Moscow.gldn.net, 366.755 ms away. so don't expect timely responses :)
06:49:48 <dons> ?uptime
06:49:49 <lambdabot> uptime: 2m 2s, longest uptime: 6d 23h 44m 3s
06:49:53 <dons> ok. not too bad actually
06:50:05 <dons> ?google testing
06:50:08 <lambdabot> http://www.testing.com/
06:50:09 <lambdabot> Title: Testing Foundations - Brian Marick
06:50:34 <dons> > 1+2
06:50:38 <lambdabot>  3
06:50:47 <dons> #haskell stumbles on
06:50:56 * dons `on` sleep
07:05:11 <SamB> arg
07:05:19 * SamB shouldn't be playing with lambdabot now :-(
07:05:27 * SamB should have left for the bus
07:15:13 <explicitjelly> re
07:25:51 <fasta> Someone killed freenode.... why did they do that?
07:27:14 <gds> fasta: you think it was a DoS? (a "someone")
07:27:22 <gds> or just randomness?
07:27:32 <fasta> gds: I suppose randomness.
07:27:48 <fasta> gds: If it was not, it was Microsoft.
07:28:14 <fasta> gds: they are clearly opposing free software, and since freenode support that it must go down.
07:28:19 <fasta> gds: ;)
07:28:29 <gds> :)
07:28:59 <fasta> Freenode is not a service that has 99,99999% uptime.
07:29:10 <fasta> I think they just want people to donate.
07:29:36 <fasta> To let them feel what the consequences are when they "pull the plug".
07:29:55 <fasta> It's odd their website was still up.
07:30:07 <norpan> the consequences are that we actually will get something done at work instead of chatting on irc all day :)
07:30:08 <fasta> So, I don't think it was a DoS attack
07:43:45 <mav> help
07:44:31 <dcoutts_> how?
07:44:32 <lambdabot> dcoutts_: You have 1 new message. '/msg lambdabot @messages' to read it.
07:45:03 <dcoutts_> heh
07:45:22 <dcoutts_> poor mav, I wonder what he/she/it wanted
07:48:56 <glguy> good morning everyone
07:49:54 <xerox> good evening
07:50:09 <dcoutts_> good afternoon
07:50:38 <glguy> speaking of time craziness, there was a really neat Nova special on black holes a the centers of galaxies last night
07:50:46 <fik> @logs
07:50:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
07:51:03 <roconnor> what's up with black holes.
07:51:05 <Binkley> it probably says something that I read that and thought of black holes in the GHC RTS sense
07:51:11 <dcoutts_> fik, it thought you meant docs
07:51:33 <glguy> Binkley: How does the RTS use the term 'black hole'?
07:51:45 <dcoutts_> roconnor, I think it's mostly down with black holes, not up.
07:52:18 <dcoutts_> fik, see http://tunes.org/~nef/logs/haskell/
07:52:19 <lambdabot> Title: Index of /~nef/logs/haskell
07:52:38 <glguy> In a few billion years, a lot of the milky way is going to be screwed, because there is a large gaseous ring of matter that's going to become a star cluster and then get sucked into the black hole in the center of the milkyway
07:52:38 <Binkley> glguy, it's a structure that gets created when your code has a certain kind of infinite loop
07:52:43 <glguy> ah
07:52:57 <fik> dcoutts, yes. you got it! i had to reenter the channel. thank you.
07:53:06 <xerox> dcoutts. the dessert we ate at your parents' house, was that just only meringue and raspberries covered with (whipped?) cream?
07:53:20 <dcoutts_> xerox, I really can't remember
07:53:28 <xerox> it was great
07:53:28 <roconnor> glguy: how many billion years?
07:53:34 <glguy> and when that star cluster gets to the black hole, the radiation beams that result will sterilize a large portion of the galaxy
07:53:45 <fasta> roconnor: 10^-9 ;)
07:53:45 <glguy> roconnor: the number was too big for me to care
07:53:46 <fik> @localtime labdabot
07:53:51 <glguy> :)
07:53:56 * roconnor cares
07:54:01 <Binkley> glguy: oh good. if it was 1 billion years, i'd be really worried ;-)
07:54:05 <roconnor> I'll have to get out of here before then.
07:54:17 * roconnor makes a note on his agenda
07:54:41 <roconnor> oh
07:54:41 <glguy> Oh, and after that happens, the galaxy Andromeda is going to eat our galaxy
07:54:45 <glguy> it's heading right for us
07:54:50 <Binkley> aw, but I like our galaxy
07:54:54 <Binkley> :....-(
07:54:55 <glguy> and it's black hole at the center is much bigger
07:55:02 <dcoutts_> I'm not sure my calendar  software will cope with me creating appointments due in half a billion years
07:55:12 <roconnor> galaxies don't collide the same way cars do.
07:55:12 <Binkley> not if you're using outlook, anyway
07:55:28 <glguy> roconnor: right, it takes another billions of years for mthem to merge
07:55:31 <Binkley> roconnor: well, that's good. think of what their insurance premiums would be otherwise...
07:55:59 <roconnor> glguy: don't we just need a radition hardend suit?  How much radiation are we talking about?
07:56:05 <br1> I'm trying to develop intuition to understand sortBy ((. snd) . compare . snd) and the like.  Any hints?
07:56:22 <dcoutts_> br1, pointify it
07:56:38 <glguy> roconnor: they seemed to suggest that not even stars survived the radiation beams that form out the axis of a feeding black hole
07:56:50 <roconnor> oh
07:56:54 <roconnor> that's pretty serious
07:56:55 <glguy> roconnor: so I don't know what level suit you need
07:57:10 <roconnor> so maybe getting out of Dodge is the best thing to do.
07:57:17 <dcoutts_> probably you just want to be a long way away
07:57:22 <glguy> or dead
07:57:27 <br1> dcoutts_: Yes.  I understand what it does.  I just can't read it without pointifying it first
07:57:33 <glguy> if you are already dead, the radiation can't hurt you
07:57:36 <dcoutts_> br1, neither can I.
07:57:44 <Baughn> glguy: It might be possible to survive by redundantly encoding ourselves as giant-scale robots - individual parts on the size of houses, that sort of thing
07:57:44 <br1> dcoutts_ :)
07:57:57 <Baughn> Of course, that assumes you avoid a direct hit
07:58:37 <glguy> Baughn: I think that when you are talking about galaxy clusters, house sized hands are not "giant-sized" /-:
07:59:37 <Baughn> glguy: That's why there is redundancy - /nothing/ will survive a giant hit, so you build to survive the ambient radiation
07:59:48 <Baughn> Er, s/giant/direct/. Though mostly correct.
07:59:59 <dcoutts_> @type (. snd) . compare . snd
08:00:00 <lambdabot> forall a a1 b. (Ord b) => (a1, b) -> (a, b) -> Ordering
08:00:03 <fik> dcoutts, the timestamps in http://tunes.org/~nef/logs/haskell/ is from San Francisco (US) time zone?
08:00:04 <lambdabot> Title: Index of /~nef/logs/haskell
08:00:15 <dcoutts_> fik, no idea, sorry
08:00:28 <dcoutts_> br1, so yeah, looking at the type helps
08:00:45 <Binkley> fik: yes
08:01:06 <Binkley> since it's 0800 in San Francisco right now, and that's what the last entries in the log say
08:01:06 <dcoutts_> @type comparing snd
08:01:08 <lambdabot> Not in scope: `comparing'
08:01:12 <dcoutts_> @type Data.Ord.comparing snd
08:01:14 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Ordering
08:01:22 <Baughn> glguy: Oh, and not house-sized hands; house-sized smallest features.
08:01:26 <glguy> I was reading something really neat about black holes where information can't fall into a black hole, to the outside observer information gets close to a black hole and then is emited as xray radiation
08:01:44 <dcoutts_> br1, so that's what it does. Which is also much simpler.
08:01:59 <glguy> unless you are the thing falling in, and then you never actually finish falling in
08:02:11 <Baughn> glguy: It's amazing the lengths some people will go to to avoid getting rid of information, but..
08:02:41 <Baughn> glguy: If you're the one falling in, you fall in just fine; the eternal fall is only from a stationary viewpoint
08:03:16 <dcoutts_> br1, the odd bit is the (.snd) .
08:03:18 <glguy> ah, well, I may have misquoted that part of the theory
08:04:02 <dcoutts_> br1, although it's written after compare, it actually applies snd to compare's second input
08:04:31 <dcoutts_> br1, so it's an unintuitive and silly way of writing it.
08:05:48 <roconnor> @type (.snd)
08:05:49 <lambdabot> forall a b c. (b -> c) -> (a, b) -> c
08:10:08 <xerox> dcoutts_: it is not odd!
08:10:16 <xerox> Is it?
08:10:20 <dcoutts_> xerox, it's backwards
08:10:29 <Igloo> dcoutts_: What GHCs is cabal meant to build with?
08:10:39 <xerox> Yes, because it needs to apply the function before the "next" in the pipe.
08:10:42 <dcoutts_> Igloo, 6.2.2 and above.
08:10:48 <dcoutts_> :type (.snd)
08:10:50 <Igloo> Ah, hmm
08:10:56 <dcoutts_> @type (.snd)
08:10:58 <lambdabot> forall a b c. (b -> c) -> (a, b) -> c
08:11:08 <xerox> It is just (\f -> f . snd)
08:11:12 <dcoutts_> xerox, (snd.) is much less odd
08:11:15 <glguy> ?type second
08:11:16 <lambdabot> forall (a :: * -> * -> *) c d b. (Arrow a) => a b c -> a (d, b) (d, c)
08:11:41 <xerox> I think it is as odd as the other one... ?
08:12:37 <dcoutts_> @pl \x y -> compare (snd x) (snd y)
08:12:37 <lambdabot> (. snd) . compare . snd
08:12:58 <dcoutts_> it's that we've got (. snd) after compare !
08:13:02 <xerox> It means that the first argument to (.), i.e. the next part in the pipe, has some arguments to consume
08:13:14 <dcoutts_> but it's applying snd to the input of compare
08:13:41 <dcoutts_> why should what we do to the first arg go before the function, and what we do to the second go after ?
08:13:51 <dcoutts_> Igloo, is there a problem ?
08:14:21 <xerox> It is applying snd to the second argument of (.).
08:14:30 <dcoutts_> anyway, obviously this should be written as sortBy (comparing snd) or sortBy (comparing `on` snd)
08:14:56 <dcoutts_> err sortBy (compare `on` snd)
08:15:14 <Igloo> dcoutts_: It either means jumping through some hoops or raising the minimum GHC required to build GHC. Hopefully the hoops won't be too painful, though
08:15:43 <dcoutts_> Igloo, oh, it's got other compat stuff actually, it might build with older ghc, it just will not work with older ghc
08:16:30 <Igloo> not work as in won't be able to register packages for?
08:16:33 <dcoutts_> right
08:16:59 <dcoutts_> so the lib itself will build with anything back to 5.04.3
08:17:20 <Igloo> It doesn't build with 6.0 for reasons I haven't looked into, but I'll see if I can just build Setup.hs with -i CabalSrcLocation
08:17:36 <Igloo> 5.04.3 doesn't work as System.Posix doesn't exist
08:17:48 <Igloo> It might be fixable, but I'm not going to worry about that for now at least
08:17:53 <dcoutts_> how did it work with ghc-6.6 then ?
08:18:06 <dcoutts_> didn't you test that with 5.04.3 ?
08:18:28 <dcoutts_> or is it because it only got built by stage1 ?
08:18:31 <Igloo> When building 6.6, cabal gets built with the stage 1 compiler
08:18:34 <dcoutts_> riht
08:18:55 <Igloo> But I'd like to be able to build stage 1 with cabal  :-)
08:19:02 <dcoutts_> ah
08:19:09 <dcoutts_> build ghc itself using cabal
08:19:25 <dcoutts_> that's going to be harder
08:19:44 <dcoutts_> because then cabal will have to know how to work with 5.04 and 6.0
08:20:01 <dcoutts_> though the package format is ok, since we do that for 6.2 anyway
08:20:02 <Igloo> Oh, yeah, that does require registering a library, doesn't it. Hmm.
08:20:10 <dcoutts_> might work
08:20:13 <dcoutts_> with some fiddling
08:21:17 <dcoutts_> Igloo, the package format of 5.0, 6.0 and 6.2 is (mostly) the same.
08:21:55 <dcoutts_> so it's worth a go, you'll probably need some workarounds for behaviour in earlier versions of ghc that got fixed in 6.2 and above.
08:21:59 <Igloo> *nod*, I'll just give it a whirl and see what breaks
08:22:22 <dcoutts_> I think there were some things to do with paths and stub files etc etc
08:23:54 <dcoutts_> and you'll need to not use the "auto=True|False" thing in the package syntax for 5.04. I think, that got added in ghc 6.0.
08:48:14 <Animosity> http://paste.lisp.org/display/29160 what's wrong with this? i get 'unexpected keyword then'
08:48:37 <fons> hi everybody
08:48:39 <fons> :)
08:48:44 <br1> else then -> else
08:48:45 * fons is happy tody
08:48:47 <Animosity> ah dang
08:48:51 <fons> today heh
08:48:53 <Animosity> i must be blind
08:48:56 <Animosity> thanks br1
08:49:20 <br1> np
08:49:47 <fons> I finally got LADSPA working for haskell http://www.ladspa.org/
08:49:48 <lambdabot> Title: Linux Audio Developer's Simple Plugin API (LADSPA)
08:50:22 <fons> but .... I would need a place to host it before sending a RFC to haskell-cafe (so that people can download it and review it if the want)
08:50:36 <metaperl> hello, is anyone working through the SOE examples? which Haskell implementation did you use?
08:52:10 <Lajexander> what do I do when I have something that works perfectly in the hugs terminal but when loading the same code I get a type error?
08:52:45 <fons> Lajexander, what do you mean by loading?
08:52:49 <xerox> You paste the code on http://paste.lisp.org/new/haskell
08:53:04 <metaperl> Lajexander: and the terminal session
08:54:03 <Cale> metaperl: I haven't, but there's a Graphics.SOE module that comes with GHC
08:54:12 <metaperl> Cale: OK . Thanks
08:55:42 <lisppaste2> Lajexander pasted "IO (suxx0rz)" at http://paste.lisp.org/display/29162
08:56:47 <Cale> can I see your data declaration?
08:56:59 <Cale> (specifically, the one for Sudoku)
08:57:06 <int-e> do        sud <- sudoku -- is wrong
08:57:15 <Cale> My guess is that it doesn't have an IO action in it
08:57:20 <Lajexander> oh fuck
08:57:22 <int-e> data Sudoku = Sudoku [Maybe <something>]
08:57:23 <Lajexander> i saw the error
08:57:34 <int-e> Cale: see list at end :)
08:57:40 <Cale> int-e: ah
08:58:03 <Lajexander> Cale: an example at the end
08:58:13 <Lajexander> Sudoku = Sudoku [[Maybe Int]]
08:58:24 <Cale> Lajexander: "sud <- sudoku" means to run sudoku and bind the result to sud
08:58:24 <int-e> ah, of course.
08:58:55 <Lajexander> ehm... i thought '<-' was used to "store" something loaded
08:59:38 <Cale> If you want to declare functions/values/etc. you can use let inside do
08:59:47 <Cale> do let sud = sudoku
08:59:55 <Cale>        sequence_ ...
09:00:00 <Cale> er
09:00:06 <Cale> not that many spaces :)
09:00:13 <Cale>    sequence_ ...
09:00:24 <_rnz-> let x = the geek, for y = 1 + the dumb shit of pie + variable X of coder nerd
09:00:26 <Cale> (otherwise, you'd be inside the let still)
09:00:38 <Lajexander> could a '<-' be used here? (just so that i learn how it works)
09:00:39 <fons> Cale, the audio plugin library is working, thanks for your help :)
09:00:45 <Cale> fons: awesome :)
09:01:20 <fons> Cale, now I'd like to host it somewhere so that people can comment (don't have a website myself) is haskel.org's wiki appropiate?
09:01:22 <Cale> Lajexander: well, you use it to run IO actions and get their results...
09:01:39 <Lajexander> oh, i get it
09:01:43 <Cale> fons: I don't see why you shouldn't be able to carve out a space for it there
09:01:48 <Lajexander> so line <- getLine
09:01:51 <Cale> right
09:02:22 <_rnz-> cale
09:02:24 <Cale> where the part on the right hand side of the <- must actually be an action
09:02:40 <_rnz-> you know how when we watch ant mounds, and ant farms, the ants mindlessly move around getting a job done for the "conglomerate"
09:02:41 <metaperl> audreyt: ping?
09:02:43 <_rnz-> of their ant family?
09:02:50 <Animosity> http://paste.lisp.org/display/29163 can anyone tell me why I get clearpathT234 as multiply defined?
09:02:51 <audreyt> metaperl: pong?
09:02:55 <_rnz-> coders are like mindless robots, it seems fun, but it really is a robotic function :)
09:03:26 <Cale> _rnz-: What's your point?
09:08:06 <_rnz-> hello fellow robots
09:08:06 <_rnz-> !
09:08:07 <_rnz-> :)
09:09:00 <glguy> Ugh... using Tor blows, I need a better way to get around the firewall
09:13:54 <profmakx> ?users
09:13:54 <lambdabot> Maximum users seen in #haskell: 265, currently: 205 (77.4%), active: 27 (13.2%)
09:14:03 <Lajexander> Animosity: Just curious, what's a T243?
09:14:10 <Lajexander> **
09:14:15 <Lajexander> *234*
09:14:55 <Cale> I'm betting it's a 2-3-4 tree
09:15:05 <Cale> http://en.wikipedia.org/wiki/2-3-4_trees
09:16:07 <Animosity> 2-3-4 tree that's correct, ill make an annotation with the structure
09:16:47 <Animosity> http://paste.lisp.org/display/29163#1
09:17:17 <Animosity> it seems that if i move the clearpathT234 n Empty = Empty to someplace belows it doesn't complain any more
09:19:09 <Lajexander> Animosity: what are you using it for? it seems WAY out of control... and I can't get http://www.cse.ohio-state.edu/~bondhugu/acads/234-tree/index.shtml to work :(
09:19:13 <lambdabot> Title: Animated working of a Two-Three-Four tree - a kind of B-Tree, http://tinyurl.com/twtbb
09:20:31 <Animosity> clearpath would be the function that checks if there are any 4 nodes on the path down to the leaf into which ill insert the next element
09:20:33 <kosmikus> ndm: is your System.FilePath cabalized?
09:20:58 <Animosity> if there are any 4 nodes it breaks them, by promoting the middle element of the 4 node up, and creating 2 2-nodes as children
09:22:12 <Animosity> the code is ugly indeed and may be out of control since
09:22:16 <Animosity> <- haskell newb
09:23:23 <Lajexander> Animosity: what is the purpose of what you're writing?
09:23:57 <Animosity> have to create a 2-3-4 tree, words as keys
09:24:19 <Animosity> and be able to search for a given key
09:24:22 <Animosity> that's all
09:24:51 <palomer> you're all nuts!
09:32:58 <Animosity> yeah i can't get past this multiply defined error
09:33:02 <Animosity> don't know what's wrong
09:36:34 <syntaxfree> WebFunctions definitely needs better docs.
09:37:00 <Animosity> ok i found the error, have one clearPath not clearpath
09:38:37 <syntaxfree> even if you want case dependence, compilers could easily catch something like "Didn't find easypath, but there's an easyPath, do you mean that?"
09:38:40 <lispy> ?palomer
09:38:40 <lambdabot> (_|_)
09:46:09 <ndm> kosmikus: yes]
09:47:07 <chessguy> @quote palomer
09:47:07 <lambdabot> palomer hasn't said anything memorable
09:47:18 <chessguy> @quote dibblego
09:47:18 <lambdabot>  I believe that OO is intrinsically defective and digresses from a formal definition of "software"
09:47:29 <chessguy> @quote dibblego
09:47:30 <lambdabot>  I believe that OO is intrinsically defective and digresses from a formal definition of "software"
09:47:35 <chessguy> @quote dibblego
09:47:35 <lambdabot>  I believe that OO is intrinsically defective and digresses from a formal definition of "software"
09:47:39 <syntaxfree> I can't get my mind to understand OO.
09:47:43 <chessguy> awww
09:47:52 <syntaxfree> maybe I'm stupid or something.
09:47:53 <chessguy> syntaxfree, consider yourself lucky
09:48:18 <syntaxfree> why?
09:48:36 <chessguy> because, OO is (probably)
09:48:37 <chessguy> intrinsically defective and digresses from a formal definition of "software"
09:48:53 <syntaxfree> FP is such a small community, I have to figure out the magical incantations of academic papers to get something done.
09:49:01 <syntaxfree> I'm specifically talking about WebFunctions here.
09:49:37 <chessguy> there's nothing magical about it. i hate that insinuation.
09:50:34 <chessguy> just because you haven't learned something, doesn't mean there's not a very logical explanation for it.
09:50:40 <palomer> @palomer
09:50:40 <lambdabot> Hrmph
09:50:42 <syntaxfree> all I'm saying is that WebFunctions is underdocumented.
09:50:48 <lispy> ?quote chessguy
09:50:49 <lambdabot>  i didn't think pennsylvania had anybody cool enough to know haskell in it
09:50:54 <syntaxfree> I do understand Haskell to the level of the larger tutorials like YAHT.
09:51:01 <syntaxfree> ?quote syntaxfree
09:51:01 <lambdabot>  one could use the euro symbol for left-associative $.
09:51:02 <norpan> ?quote norpan
09:51:02 <lambdabot>  your sentence missing a verb
09:51:21 <lispy> ?quote lispy
09:51:22 <lambdabot>  lambdabot, changing the way Haskllers think since 2003
09:51:26 <tobbes> I don't know if this question is haskell-related enough, but I'm looking for a haskell mode for emacs (under windows if that makes any difference) and a newbie-friendly walkthrough on how to actually configure emacs to run with it
09:51:42 <lispy> tobbes: haskell-mode
09:51:51 <lispy> ?google haskell-mode emacs
09:51:53 <lambdabot> http://haskell.org/haskell-mode/
09:51:53 <lambdabot> Title: Haskell Mode for Emacs
09:51:55 <syntaxfree> ?quote syntaxfree
09:51:56 <lambdabot>  <Bourbaki> the best thing i have ever read in economy is a statement of some guy "i have never met the homo oeconomicus" <syntaxfree> I have never met a catamorphism, either.
09:52:02 <tobbes> thx
09:52:31 <palomer> oh my, my computer science days may be over
09:52:39 <palomer> and I had such big dreams!
09:53:15 <kosmikus> ndm: but not released, right?
09:53:51 <ndm> kosmikus: not released as a 1.0,  but the code is all there, and the cabal stuff, and the docs
09:54:00 <ndm> kosmikus: its a 0.9
09:54:56 <kosmikus> ndm: the question is more whether it's properly released as a stable version with a tarball, or whether it's just available as a darcs repo
09:55:14 <ndm> kosmikus: just a darcs repo, but i can shove up a tarball if you want
09:55:16 <kosmikus> ndm: it's harder for me to, say, make a Gentoo ebuild for it if only the latter ...
09:55:46 <ndm> kosmikus: i want to look at it again, address a few of SimonM's points, then i'll give a tarball for you
09:55:51 <ndm> kosmikus: maybe a few weeks
09:56:44 <ndm> anyway, have to dash now - bye
09:56:47 <kosmikus> ok. but then I'll not use it for lhs2tex-1.12 ;)
09:56:56 <ndm> :(
09:56:59 <ndm> thats a shame
09:57:03 <ndm> ok, will do it tomorrow
09:57:04 <palomer> intrinsically defective?
09:57:16 <kosmikus> ndm: well, let's talk again when you have more time
09:57:40 <ndm> kosmikus: i can move my day around, and do it tomorrow - so i'll send out a release announcement on haskell@haskell.org tomorrow evening
09:57:41 <palomer> 
09:57:46 <palomer> did you guys see that:O?
09:57:51 <ndm> bye
09:57:53 <lispy> palomer: no
09:57:59 <palomer> <:(
09:58:06 <lispy> palomer: i read ?\205\201?\204?
09:59:00 <dcoutts_> palomer, yep, I see two chars, one looks like a small square and the other a small 'L'
10:00:32 * lispy was just thinking, "If I'd used scala (and compiled to .NET) instead of haskell, I wonder if my manager would have had less problems with me using an exotic language."
10:00:35 * palomer high fives dcoutts 
10:00:53 <palomer>  
10:12:48 <syntaxfree> what wiki software did the old hawiki run?
10:13:33 <kpreid> moinmoin
10:13:38 <tobbes> Hmm, i still don't get it to work
10:13:38 <syntaxfree> oo.
10:13:39 <syntaxfree> good to know.
10:13:46 <syntaxfree> the new one is what?
10:13:49 <kpreid> mediawiki
10:14:10 <syntaxfree> I find CamelCase wikis cozier.
10:14:18 <tobbes> I need to create .emacs file right? and I put it in the Emacs folder?
10:15:27 <pejo> tobbes, .emacs should be in $HOME
10:17:05 <tobbes> OK, do I need to put the entire emacs installation there?
10:17:29 <pejo> tobbes, no, .emacs is your individual config file. Each user can have one.
10:18:05 <Lajexander> what's wrong here?
10:18:05 <Lajexander>     do	contents <- readFile filePath
10:18:05 <Lajexander> 	lin	 <- lines contents
10:18:25 <Binkley> Lajexander: think about what type lines has
10:18:39 <Lajexander> oh, right! lines isn't an IO a - type
10:18:44 <Lajexander> my bad...
10:18:45 <Binkley> yep
10:18:55 <Binkley> you can either bind it with a let, or use liftM
10:20:18 <Lajexander> hmm... i think i have some silly indentation fault... I'll make a lisp post...
10:26:56 <tobbes> sorry stupid question again, I don't understand what is said in the installation instructions. what lines do I need to the .emacs file to make it run haskell mode automatically for .hs files?
10:28:20 <lisppaste2> Binkley pasted "emacs haskell-mode" at http://paste.lisp.org/display/29167
10:28:37 <Binkley> you'll need to change the first line according to where your xemacs (or emacs) is installed, obviously
10:29:53 <Cale> http://www.syntaxpolice.org/darcs_repos/haskell-mode/installation-guide.html
10:29:56 <lambdabot> Title: Haskell Mode for Emacs: Installation Guide, http://tinyurl.com/ybfzob
10:33:55 <tobbes> Binkley well, it doesn't work for me
10:34:18 <Binkley> what goes wrong?
10:36:50 <tobbes> It doesn't load anything I also copied and pasted the lines at http://www.syntaxpolice.org/darcs_repos/haskell-mode/installation-guide.html
10:37:39 <tobbes> I'm running windows
10:37:54 <tobbes> but the procedure should still be the same, right?
10:40:29 <Binkley> and you reloaded your .emacs file?
10:42:06 <tobbes> I restarted emacs a number of times.
10:42:08 <tobbes> :)
10:42:44 <tobbes> when i open a file with .hs the mode is not switched
10:43:00 <Lajexander> vim is the shit
10:43:11 <glguy> hear hear!
10:43:42 <Binkley> can you paste the contents of your .emacs file? (or the relevant part, if you have other stuff in it)
10:44:01 <tobbes> I'll msg you?
10:44:27 <Binkley> just use paste -- http://paste.lisp.org/new/haskell
10:45:00 <tobbes> (add-to-list 'load-path (expand-file-name "~/emacs/site/jde/lisp"))
10:45:00 <tobbes> (setq load-path (cons "~/emacs" load-path))
10:45:00 <tobbes> (setq auto-mode-alist
10:45:00 <tobbes>       (append auto-mode-alist
10:45:00 <tobbes>               '(("\\.[hg]s$"  . haskell-mode)
10:45:00 <tobbes>                 ("\\.hi$"     . haskell-mode)
10:45:01 <desrt> scala has pattern matching.  i am happy.
10:45:02 <tobbes>                 ("\\.l[hg]s$" . literate-haskell-mode))))
10:45:04 <tobbes> (autoload 'haskell-mode "haskell-mode"
10:45:06 <tobbes>    "Major mode for editing Haskell scripts." t)
10:45:08 <tobbes> (autoload 'literate-haskell-mode "haskell-mode"
10:45:10 <tobbes>    "Major mode for editing literate Haskell scripts." t)
10:45:12 <tobbes> (add-hook 'haskell-mode-hook 'turn-on-haskell-font-lock)
10:45:14 <tobbes> (add-hook 'haskell-mode-hook 'turn-on-haskell-decl-scan)
10:45:16 <tobbes> (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
10:45:18 <tobbes> (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
10:45:20 <tobbes> (add-hook 'haskell-mode-hook 'turn-on-haskell-simple-indent)
10:45:22 <tobbes> (add-hook 'haskell-mode-hook 'turn-on-haskell-hugs)
10:45:24 <tobbes> (add-hook 'haskell-mode-hook 'turn-on-haskell-ghci)
10:46:16 <mainland> pick a single indent mode
10:46:21 <mainland> and one of hugs/ghci
10:46:28 <Binkley> yeah, don't use both haskell-indent and haskell-simple-indent
10:47:12 <mainland> i get very frustrated with languages that don't have pattern matching :)
10:48:12 <xerox> desrt: what is scala about?
10:48:32 <ski> (hm .. more sudokus ..)
10:48:36 <desrt> xerox; it's close to java
10:48:52 <desrt> xerox; but with a considerably reworked syntax and a lot of niceities from functional programming
10:48:55 <tobbes> ok I removed turn-on haskell ghci and turn-on-haskell-simple-indent
10:49:02 <tobbes> still doesn't work :)
10:49:14 <glguy> scala can be compiled to run on the .NET framework, no?
10:49:16 <desrt> xerox; but it's like java in the sense of how it has loops and if statements and variables and arrays and whatnot
10:49:21 <glguy> (in addition to the Java JRE)
10:49:22 <desrt> and it compiles to the JVM
10:49:34 <desrt> ya.. it also has a CLR compiler
10:49:54 <desrt> it can call any java libraries natively
10:50:01 <desrt> i assume it can probably do the same for .net
10:50:25 <Binkley> tobbes, do you get any error messages when you start up emacs? or nothing?
10:50:31 <xerox> Pattern matching is indeed a powerful feature.
10:51:10 <desrt> certainly makes implementing a lambdacalc interpreter a lot easier :)
10:51:21 <desrt> i wonder if they have haskell-like data construction
10:52:04 <metaperl> audreyt: ping? did you get my private messages?
10:53:06 <desrt> it has lambda, too
10:53:09 <tobbes> Binkley nothing
10:53:09 <desrt> although not by name :)
10:54:00 <Binkley> tobbes: and what directory did you save the haskell mode files in?
10:54:03 <mattrepl> anyone know of a module for polygon clipping?  need it to calculate intersections for simple polygons
10:54:06 <desrt> also supports curried forms
10:54:48 <tobbes> C:\Emacs\emacs-21.3
10:56:45 <Binkley> well, I'm not seeing a line in what you pasted that actually loads the package
10:56:58 <Binkley> that could be the problem
10:57:19 <tobbes> Binkley what do I need to add?
10:57:50 <xerox> desrt: do you have any nice code extract to paste, for fun?
10:58:11 <Binkley> for starters, did you put the files in c:\emacs\emacs-21.3 or a subdirectory of that directory?
10:58:36 <tobbes> the files came in a directory
10:58:55 <tobbes> I pasted that directory into c:\emacs-21.3
10:59:16 <desrt> xerox; google for ScalaByExample
10:59:18 <desrt> xerox; nice pdf fil
10:59:32 <desrt> xerox; section 7 is about the pattern mtching
11:00:24 <tobbes> the full path should be C:\Emacs\emacs-21.3\haskell-mode-2.1
11:00:44 <tobbes> aha
11:00:45 <metaperl> any ghc build experts here: the docs refer to mk/build.mk but that file does not exist: http://haskell.org/ghc/docs/6.6/html/building/sec-porting-ghc.html
11:00:48 <lambdabot> Title: 9. Porting GHC, http://tinyurl.com/y93k78
11:02:05 <tobbes> maybe I need to add emacs 21.3 and not emacs to the loadpath :)
11:02:32 <Igloo> metaperl: You need to make it if you want one
11:02:46 <metaperl> Igloo:  oh ok thanks
11:02:53 <tobbes> no, still nothing
11:07:06 <Binkley> tobbes: then you need the line, (load "c:\emacs\emacs-21.3\haskell-mode-2.1\haskell-site-file")
11:07:13 <Binkley> you may need to escape the backslashes or something
11:13:41 <Dylan> or use forward slashes. win32 accepts those.
11:14:07 <araujo> hellu!
11:15:12 <tobbes> OK i added the load line with / slashes
11:15:19 <tobbes> it still doesn't work
11:15:53 <Binkley> did you add it at the beginning or the end?
11:16:25 <tobbes> at the beginging
11:16:34 <tobbes> after set loadpaths
11:16:35 <tobbes> and stuff
11:17:16 <Binkley> well, it definitely needs to be before (setq auto-mode-alist...
11:17:16 <tobbes> (add-to-list 'load-path (expand-file-name "~/emacs/site/jde/lisp"))
11:17:17 <tobbes> (setq load-path (cons "~/emacs-21.3" load-path))
11:17:17 <tobbes> (load "~/emacs-21.3/haskell-mode-2.1/haskell-site-file")
11:17:29 <astrolabe> Has anyone here used the ghcprof graphical profiler?
11:17:39 <Binkley> is your emacs-21.3 directory in ~ or in c:\emacs?
11:17:48 <Binkley> astrolabe: a long time ago
11:17:59 <tobbes> well ~ is c:/Emacs
11:18:11 <tobbes> and it's in c:/Emacs/
11:18:21 <astrolabe> Binkley: I can't find an executable called ghcprof in my instalation
11:18:23 <Binkley> your home directory is c:/emacs?
11:18:41 <tobbes> yes
11:19:20 <Binkley> astrolabe:  did you build from source or download binaries?
11:19:22 <tobbes> I moved the line
11:19:26 <tobbes> still nothing
11:19:39 <Binkley> tobbes: just for fun, try replacing ~ with c:\emacs
11:19:47 <tobbes> oki
11:20:02 <abrim> Tobbes: If no home directory is set, emacs will default to c:/ so you might try putting the .emacs file there
11:20:50 <astrolabe> Binkley: binaries
11:21:03 <abrim> or check the environment variable to see if its set.  See http://www.gnu.org/software/emacs/windows/faq3.html 'where do I put my .emacs file'
11:21:06 <lambdabot> Title: Installing Emacs, http://tinyurl.com/y9282q
11:21:10 <tobbes> yes
11:21:19 <tobbes> I set it manually to c:/Emacs
11:21:33 <tobbes> I tried load c:/Emacs/emacs21.3 etc
11:21:37 <tobbes> no result
11:21:44 <Binkley> astrolabe: well, i see a ghcprof.prl file under my bin directory in ghc-6.4.2
11:22:08 <astrolabe> I have that!
11:22:27 <Binkley> yeah, that's ghcprof
11:23:33 <tobbes> I tried putting .emacs in c:/ didn't help
11:24:14 <xerox> You ought to call it _emacs I think.
11:24:28 <xerox> www.emacswiki.org surely has that information.
11:25:18 <tobbes> ok
11:25:22 <tobbes> i'll try that
11:25:22 <tobbes> thx
11:26:19 <mwc> Hehehehe, we finally got a windows machine infected with emacs... excellent...
11:26:48 <Renkin> I never really used emacs
11:26:53 <Renkin> Shame on me, I guess :)
11:27:09 <desrt> emacs is a terrible disease to wish on anyone
11:27:31 <Renkin> People who use it praise it like Christ himself
11:27:38 <xerox> I'm using Circe version from CVS (2006-08-15 19:38:32) with GNU Emacs 22.0.50.1 (of 2006-08-19)
11:27:43 <desrt> christ is a terrible disease to wish on anyone
11:27:47 <Renkin> haha
11:28:44 <tobbes> YES
11:28:45 <tobbes> thx
11:28:52 <tobbes> It works ;)
11:28:53 <xerox> You're welcome.
11:28:58 <tobbes> thank's all
11:29:17 <gour> is there stable gtk support in xemacs?
11:29:37 * gour is asking although prefer (g)vim
11:30:14 <xerox> gour: yeah, but it is a light support as far as it goes
11:30:31 <xerox> Err, I know you can --enable-gtk in GNU Emacs.  No idea about XEmacs.
11:30:37 <gour> xerox: gtk-2.x ?
11:30:45 <xerox> Yes.
11:30:57 <gour> xerox: any snapshot around?
11:31:03 <xerox> Yes.
11:31:08 <gour> url?
11:31:16 <xerox> I mean, there are .debs made by some freedesktop.org guy.
11:31:28 <xerox> What are you looking for exactly?
11:32:12 <gour> to see how emacs-gtk looks like , i.e. look is also important factor to me
11:32:17 <Cale> desrt: Did you hear about the trivial religion that I came up with? Its tenets consist of a single statement: "Believing in this statement will make you happier". It's like a terminal object in the category of religions and theomorphisms.
11:32:55 <Binkley> best religion ever! what are you calling it?
11:33:10 <xerox> It does look like Emacs, the tool bar and menu bar are drawn by using GTK, and it also uses GTK-based GUIs for dialog panes.  That is how far it goes.
11:33:41 <arcatan> hmm, that isn't so bad
11:33:48 <xerox> Oh, and the scroll bar is also GTK-rendered.  Given that I hide all of this stuff, and not use any dialog, it really doesn't matter to me.
11:34:38 <Cale> Hmm... I suppose it does need a catchy name.
11:34:53 <desrt> Cale; that's not bad
11:35:07 <desrt> it's clearly a form of monotheism
11:35:16 <Binkley> if it had a name I would list it as my religion on various social networking sites :-)
11:35:16 <xerox> Cale, YUCK.
11:35:17 <desrt> (taken to the absolutely utter extreme)
11:36:00 <desrt> The Statement is holy.  Believe Him.
11:36:13 <Cale> hehe
11:36:28 <xerox> ?remember Cale desrt: Did you hear about the trivial religion that I came up with? Its tenets consist of a single statement: "Believing in this statement will make you happier". It's like a terminal object in the category of religions and theomorphisms.
11:37:07 * araujo always hated statements
11:37:33 <int-e> araujo: so you leave out the final period and hope noone notices you making one
11:37:43 <desrt> you pretty much have everything that a religion is
11:37:54 <desrt> you should have some kind of a book, though
11:37:57 <araujo> int-e, you mean the function composition operator?
11:38:02 <desrt> i think it'll probably be pretty short
11:38:04 <xerox> desrt: I suppose there is more
11:38:14 <Cale> More like a holy pamphlet
11:38:23 <desrt> more like a holy fortune cookie
11:38:27 <Cale> hahaa
11:38:36 <Cale> That's awesome
11:39:09 <desrt> bah
11:39:14 <desrt> i better get some namerican $$
11:39:18 <Cale> The world's first edible religion
11:39:21 * desrt counts the supply
11:39:36 <araujo> Haskell , the first religion with no statements
11:39:37 <Binkley> "desserts aren't always right." "but they're so sweet!"
11:40:21 * desrt has US$50 that has been sitting in his room depreciating in value for the past 5 years
11:40:24 <desrt> bah.
11:40:34 <desrt> when i bought this stuff it was actually worth something
11:41:12 <int-e> @quote
11:41:13 <lambdabot> syntaxfree says: <Bourbaki> the best thing i have ever read in economy is a statement of some guy "i have never met the homo oeconomicus" <syntaxfree> I have never met a catamorphism, either.
11:41:14 * desrt makes a point of getting some  too
11:41:19 <Binkley> try having $2000 in a bank account depreciating in value :P
11:41:29 <xerox> desrt: where do you live what kind of money do you use?
11:41:38 <desrt> CA$
11:42:07 <xerox> I $.  We, Dinner.
11:42:10 * desrt is about to go on the sort of a trip that requries US$ and 
11:42:53 <desrt> xerox; cheers :p
11:44:05 <glguy> ahh, the joys have finally having full unicode support
11:44:13 <Cale> desrt: Make sure to make some sort of jab at Andrew for supporting the conservatives, eh? Maybe something along the lines of "taxing income trusts was a great idea, eh?"
11:44:17 <desrt> http://finance.yahoo.com/q/bc?s=USDCAD=X&t=5y
11:44:19 <lambdabot> Title: USDCAD=X: Basic Chart for USD to CAD - Yahoo! Finance
11:44:27 <desrt> this is the reason i'm upset that i had $50USD sitting on my desk for 5 years :)
11:44:58 <desrt> Cale; andrew?
11:45:06 <desrt> andrew curtis?
11:45:20 <Cale> yeah :)
11:45:34 <desrt> i don't understand
11:45:52 <Cale> desrt: don't worry, Stephen Harper has a plan to make your US dollars worth something again, relative to Canadian dollars.
11:46:01 <desrt> what does our conservative government (who just recently came into power) have to do with the decline of the US$ over the past 5 years?
11:46:06 <desrt> oh.
11:46:11 <desrt> the liberals had a plan for that too
11:46:23 <desrt> expensive CA$ is bad for our economy, unfortunately :(
11:46:47 <glguy> makes Americans not want to buy your goods?
11:46:51 <desrt> ya
11:47:02 <desrt> CA/US have the largest trade relationship on earth
11:47:06 <desrt> so that tends to hurt us
11:47:23 <Binkley> cf. the Arrogant Worms' "Canadian Crisis Song"
11:47:41 <desrt> it's sort of evil
11:48:16 <desrt> because lowering the price of canadian dollars, essentially, lets people in the export business pay their employees less money while still charging the same to their buyers across the border
11:48:40 <desrt> but since we have so many people in the export business, .... gotta make em happy
11:50:01 <petekaz> OT: Isn't there a kernel based file observer library?  I.e, it can notify you if the file is moved, etc ...
11:50:10 <desrt> inotify?
11:50:23 <petekaz> hmmm ... maybe that is it.
11:50:26 <petekaz> thanks.
11:50:34 <desrt> it is.  it was written by a friend and fellow student :)
11:50:38 <desrt> (at mcmaster)
11:50:46 <integral> Doesn't FAM abstract that stuff?
11:50:53 <desrt> FAM is to be avoided.
11:50:59 <integral> ah
11:51:04 <desrt> old crusty API
11:51:04 <petekaz> ahh .. fam is what i was thinking of.
11:51:08 <glguy> inotify sounds like that "linucks" stuff
11:51:19 <desrt> and certainly not a "kernel-based" library
11:51:20 <integral> is there something newer that abstracts over linux/bsd/windows/unix?
11:51:28 <desrt> integral; probably not :(
11:51:42 <pejo> (Fam wasn't very portable)
11:51:45 <integral> *sigh* Maybe the GNOME people have done something :-/
11:51:54 <desrt> gnome-vfs has a built-in inotify backend
11:52:00 <desrt> and will fallback to using FAM if needed
11:52:07 <desrt> and there is a replacement famd called 'gamin'
11:52:22 <desrt> which has the fam API but lacks some of its less favourable properties (like requiring you to run portmapper daemon)
11:52:50 <desrt> that's about the lay of the land right now
11:52:54 <pejo> desrt, do people consider that a problem?
11:53:03 <desrt> pejo; yes.  very much.
11:53:14 <desrt> gnome-vfs is at an unfortunate place in the gnome stack
11:53:20 <desrt> gtk, for example, isn't allowed to depend on gnome-vfs
11:53:35 <desrt> and some stuff in gtk (like the recently used file support) wants to do filesystem monitoring
11:53:42 <integral> it almost needs to be out at glib level
11:53:47 <desrt> and because of not being able to depend on gnome-vfs, it can't
11:53:47 <pejo> desrt, isn't nfs unusable without portmap, even as a client?
11:53:50 <desrt> integral; exactly.
11:53:55 <desrt> integral; and it will be soon
11:54:10 <desrt> pejo; very few people use nfs
11:54:17 <desrt> (as a % of total desktop linux users)
11:54:31 <pejo> What do they use, CIFS?
11:54:33 <desrt> so very few people would otherwise need portmap
11:54:44 <desrt> they use harddrives and ext3
11:54:45 <glguy> afs?
11:55:10 * integral can't name a single decent network file system :-/
11:55:18 <desrt> nfs is really the best you can have :(
11:55:38 <desrt> someone basically needs to write a better nfs _WITHOUT_ overengineering the thing
11:55:47 <desrt> all of these new filesystems are way overengineered
11:56:02 <glguy> nfs always worked great for me until it didn't
11:56:09 <glguy> and when it didn't it failed spectacularly :)
11:56:11 <desrt> nfs is great... just crufty :(
11:56:34 <desrt> integral; anyway... glib will grow a file monitoring API soon
11:56:42 <desrt> integral; or so goes the plan
11:56:57 <pejo> desrt, nfsv4, will solve all problems. Just like v3, and v2, ..
11:57:10 <desrt> erm
11:57:14 <desrt> v4 is already out
11:57:31 <pejo> Sure, and how many places have adopted it?
11:57:32 * integral keeps meaning to set that up but didn't have new kernels...  but I do now
11:59:11 * desrt hates the university bookstore with a passion
11:59:26 <glguy> I've been sticking to using scp for any network file transfering that I've done lately
11:59:42 <glguy> I haven't needed seemless access to whole directories lately
11:59:44 <desrt> i've decided that apple no longer deserves to be the target of my hatred for my macbook not working
11:59:57 <integral> That's okay when you're not using a network FS to access gobs of disk you don't have
12:00:22 <dino-> I'm having some trouble understanding how to get, say, the first 10 random ints out of randomRs
12:00:31 <glguy> otherwise I always use cifs because everyone else is using windows
12:00:38 <mtahti> Hi, I need to use Data.Array and Data.Map at the same time but they both define (!). How do I get around this?
12:00:38 <desrt> ?hoogle randomRs
12:00:39 <lambdabot> Random.randomRs :: (Random a, RandomGen b) => (a, a) -> b -> [a]
12:00:40 <lambdabot> System.Random.randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
12:01:12 <glguy> is that an "unsafe" function?
12:01:19 <desrt> it doesn't look like it
12:01:23 <desrt> which is deeply disturbing...
12:01:29 <glguy> or does it just assume you are done using that generator?
12:01:32 <Cale> mtahti: import at least one of them qualified, or import one of them hiding (!)
12:01:40 <desrt> glguy; you'd have to be done
12:01:49 <glguy> ?type randomR
12:01:53 <desrt> glguy; since calling that function again on the same generator would give you the same numbers
12:01:53 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
12:02:00 <desrt> ok.  that's better.
12:02:14 <int-e> desrt: you can get a random generator, split it, put one half back and use the other to generate an infinite sequence with randomRs
12:02:16 <dolio> How would you return the generator after generating infinite randoms?
12:02:18 <mtahti> Cale: I tried hiding but then I couldn't access it using qualified name
12:02:30 <glguy> dolio: infinite randoms?
12:02:35 <glguy> AH
12:02:42 <dolio> randoms and randomRs is an infinite list of randoms.
12:02:56 <Cale> mtahti: It's possible to just import that one function qualified
12:03:05 <dino-> So, how would I use that, like: take 10 <something magical here>
12:03:38 <glguy> replicateM 10 (getRandom) -- using Cale's MonadRandom
12:03:53 <dolio> > take 10 (randomRs (1, 10) (newStdGen 10))
12:03:54 <lambdabot>    The function `newStdGen' is applied to one arguments,
12:03:54 <lambdabot>   but its type `...
12:03:55 <Cale> > take 10 (randoms (mkStdGen 1))
12:03:56 <lambdabot>  Add a type signature
12:04:02 <Cale> > take 10 (randoms (mkStdGen 1)) :: [Int]
12:04:04 <lambdabot>  [-604496784,-727467101,-1561284000,165957600,1725846479,4503537,1008336584,-...
12:04:18 <mtahti> Cale: Ok, thanks. I'll try that.
12:04:29 <Cale> > take 10 (randomRs ('a','z') (mkStdGen 1)) :: [Char]
12:04:30 <lambdabot>  "nklzozinyu"
12:04:37 <dino-> > take 10 (randoms (getStdGen)) :: [Int]
12:04:38 <lambdabot>  add an instance declaration for (RandomGen (IO StdGen))
12:04:48 <Cale> @type getStdGen
12:04:49 <lambdabot> IO StdGen
12:04:51 <Cale> Ot
12:04:53 <int-e> newStdGen >>= return . take 10 . random
12:04:56 <Cale> It's an IO action
12:04:58 <dolio> Yarr, I always confuse my stdGen functions.
12:05:00 <Cale> you'd have to run it
12:05:46 <Cale> getStdGen isn't such a good idea, newStdGen is better. I wish it was implemented so as to take some system entropy though.
12:06:34 <dino-> But getStdGen and newStdGen have the same type.
12:06:41 <dino-> :/
12:06:44 <dolio> Does { g <- getStdGen ; h <- getStdGen } put the same generator in both g and h?
12:06:52 <Cale> yes
12:07:02 <dolio> Ah, well, there you go.
12:07:52 <Cale> @fptools System.Random
12:07:52 <lambdabot> http://darcs.haskell.org/packages/base/System/Random.hs
12:08:14 <Cale> theStdGen :: IORef StdGen
12:08:14 <Cale> theStdGen  = unsafePerformIO $ do
12:08:14 <Cale>    rng <- mkStdRNG 0
12:08:14 <Cale>    newIORef rng
12:08:18 <Cale> extremely evil
12:08:34 <desrt> so i'm guessing the genreators are pseudorandom
12:08:42 <desrt> oh
12:08:42 <Cale> mkStdRNG :: Integer -> IO StdGen
12:08:42 <Cale> mkStdRNG o = do
12:08:42 <Cale>     ct          <- getCPUTime
12:08:42 <Cale>     (TOD sec _) <- getClockTime
12:08:42 <Cale>     return (createStdGen (sec * 12345 + ct + o))
12:08:43 <desrt> maybe not :)
12:08:56 <desrt> oh.  maybe.
12:09:13 <dolio> The generators themselves are pseudorandom.
12:09:22 <desrt> with evil impure behaviour
12:09:28 <dolio> > randoms (mkStdGen 10)
12:09:29 <Cale> yes, the actual StdGen values hold the state of pseudorandom number generators.
12:09:29 <lambdabot>  Add a type signature
12:09:35 <dolio> > randoms (mkStdGen 10) :: [Int]
12:09:36 <lambdabot>  [-1258130923,-870666468,433432625,-1228884604,793723731,1488653119,609706456...
12:09:38 <dolio> > randoms (mkStdGen 10) :: [Int]
12:09:38 <Cale> They're completely pure
12:09:39 <lambdabot>  [-1258130923,-870666468,433432625,-1228884604,793723731,1488653119,609706456...
12:10:09 <desrt> an interesting idea would be to create a real random number source while in context of IO
12:10:16 <Cale> but the program initialises a generator (fortunately only accessible by IO) which is based on the time
12:10:18 <dino-> So, basically, trying to use getStdGen was breaking my ass here.
12:10:19 <desrt> and then somehow pass that through
12:10:31 <desrt> i think you'd have to be unsafe
12:10:35 <desrt> but i'm not sure
12:10:46 <Cale> well, you could get a pseudorandom seed which was good from IO
12:10:55 <desrt> no.  real random
12:11:05 <desrt> i mean like, say, the 'makeRandom' thing opened /dv/urandom
12:11:09 <Cale> well, you'd never want that to become non-IO :)
12:11:17 <desrt> and it gave you what is essentially a file handle that you can read() without being in IO
12:11:23 <Cale> actually, we're already doing lazy IO
12:11:33 <_rnz-> ?reply she may have , but she prefers anal cumshots instead
12:11:34 <lambdabot> Unknown command, try @list
12:11:34 <_rnz-> oops
12:11:37 <Cale> so getContents on /dev/urandom will give you that
12:11:50 <desrt> that's a good point
12:11:51 <_rnz-> Cale, do you enjoy coding, and doing math, and using the power of the human brain?
12:11:52 <_rnz-> :)
12:11:59 <desrt> lazy IO is really scary
12:12:02 --- mode: ChanServ set +o Cale
12:12:10 <Cale> bye :)
12:12:37 <_rnz-> hahahahaa, cale is to slow for the bankick. .  . nice try cale, but be quicker on the gun next time, no power trip for you
12:12:38 <_rnz-> hahahahaa, cale is to slow for the bankick. .  . nice try cale, but be quicker on the gun next time, no power trip for you
12:12:53 <desrt> but not too slow for the ban
12:12:56 <Cale> actually, the ban list is just full
12:12:59 <desrt> hahahah
12:13:05 <profmakx> 50 bans
12:13:06 <profmakx> O.O
12:13:10 <desrt> how do so many people get banned from #haskell?
12:13:14 <desrt> you guys need to clean it out more often
12:13:22 <Cale> most of them are probably the same guy
12:13:26 <desrt>           *!*n=angLia@tor/session/external/x-91044492e4520215 [by
12:13:30 <desrt> like seriously
12:13:42 <desrt> i doubt that that hostmask is ever able to exist again
12:13:48 <glguy> That's what bots are for, maintaining ban lists
12:14:02 <Cale> good point
12:14:05 <profmakx> glguy  your turn ^^ make lambdabot manage banlist ^^
12:14:11 <desrt> or rather, i doubt that it's cryptographically feasible for that hostmask to exist again :)
12:14:21 --- mode: Cale set -b *!*=debian-t@tor/session/external/x-38357f3653849e28
12:14:24 --- mode: Cale set -b *!*n=angLia@tor/session/external/x-91044492e4520215
12:14:30 <glguy> profmakx: I'd rather an eggdrop managed the channel and lambdabot stuck to haskell...
12:14:32 --- mode: Cale set -b *!*@tor/session/external/x-885a0c9fc14ab93d
12:14:36 --- mode: Cale set -b *!*@tor/session/external/x-edafcb1e62df3dfe
12:14:45 <desrt> 15:11 -!- 36 - #haskell: ban sear@*!*@* [by sagan.freenode.net, 6615373 secs
12:14:49 <desrt> this is a totally bogus ban
12:14:53 --- mode: Cale set +b *!*=jungzzz@66.0.46.*
12:15:10 <desrt> impossible for it to match anyone
12:15:27 --- mode: Cale set -b sear@*!*@*
12:15:34 <glguy> > 22458/60
12:15:36 <lambdabot>  374.3
12:15:42 <profmakx> glguy but thats not as much fun as coding the functionality in haskell
12:16:08 --- mode: Cale set -o Cale
12:16:08 <desrt> 15:11 -!- 42 - #haskell: ban desrt*!n=desrt@* [by sagan.freenode.net, 6615373 secs
12:16:11 <desrt> wtf!!
12:16:12 <glguy> why do all of the bans say 22458 seconds ago? (at least on my computer)
12:16:27 <profmakx> thats because of the splits today
12:16:28 <desrt> glguy; probably set by a server netjoining another
12:17:34 <glguy> we'd need a lot fewer bans if the channel required identification like #openbsd did
12:17:49 <desrt> that's a fucking awful idea
12:17:51 <desrt> quite frankly
12:18:20 <xerox> desrt: because it mentions OpenBSD? (:
12:18:28 <desrt> xerox; ha ha
12:18:42 <glguy> People who are smart enough to want to learn haskell are smart enough to figure nickserv out
12:18:46 <desrt> because nickserv is oppressive
12:19:05 <glguy> desrt: you are identified to nickserv...
12:19:08 <int-e> how is it oppressive?
12:19:09 <desrt> i have to be
12:19:23 <desrt> int-e; you'd have to have grown up on efnet to understand
12:19:39 <glguy> efnet being like the wild west was not a good thing
12:19:47 <desrt> nickserv represents opers medeling in things that should be settled among the users themselves
12:19:49 <glguy> having to squat on your nick all day so someone else didn't get it
12:19:55 <desrt> it's an unnecessary use of power
12:19:57 <glguy> having to have 10 bot botnets to guard hannels
12:20:15 <int-e> efnet's use of mailing black lists for IRC is silly
12:20:34 <glguy> IRC isn't supposed to be a game you play
12:20:45 <spiffy> I think im doing something "spiffy Dumb (TM)"
12:20:53 <spiffy> is there a paste bin i can use?
12:20:53 <desrt> freenode isn't irc
12:21:01 <spiffy> to show what im doing
12:21:06 <glguy> ?paste
12:21:07 <lambdabot> http://paste.lisp.org/new/haskell
12:21:32 <int-e> anyway. requiring nickserv identification just raises the bar for attackers very slightly. it's not a solution to any problem, except the one that it solves - avoiding people from using your nick.
12:21:38 <int-e> err, preventing
12:21:54 <glguy> when you want it, more specifically
12:21:55 <desrt> it doesn't even do a great job of that
12:22:03 * desrt is often signed in for weeks at a time without identifying
12:22:27 <desrt> nickserv is no assurance that the person with your nick will be you
12:22:39 <desrt> but it's nice to let you recover your nick if people don't play nice
12:22:43 <glguy> except when it says you are "identified"
12:22:50 <desrt> right
12:22:52 <int-e> right, although nickserv can be configured so that they'll have a lot of trouble staying online
12:23:00 <int-e> with that nick
12:23:09 <desrt> int-e; i really don't like that particular feature
12:23:12 <glguy> which, if the channel was correctly configured, would happen a lot more
12:23:30 <lisppaste2> spiffy pasted "Broken Type" at http://paste.lisp.org/display/29170
12:23:32 <dino-> So, I still feel a little confused. It's not such a great idea to use getStdGen?
12:23:39 <desrt> it's like a car that lets you get in and start driving it
12:23:49 <desrt> but stalls on the highway if you don't put the key in within 5 minutes
12:23:55 <glguy> desrt: it's like a car that when you try to use it tells you not to drive it
12:23:58 <glguy> unless you are the owner
12:23:58 <int-e> dino-: because you'll re-use the same generator for several sequences
12:24:01 <glguy> and you ignore that message
12:24:08 <glguy> and drive it anyway
12:24:11 <desrt> glguy; that message is sort of implicit
12:24:12 <glguy> and then get pulled over
12:24:12 <Cale> dino-: you can use it, but newStdGen is just as easy to use, and will give you a different generator each time
12:24:19 <spiffy> So, i know what i did was wrong. Im wondering whats right
12:24:24 <desrt> glguy; actually, i think it's probably quite explicit in the law
12:24:32 <dino-> Ok
12:24:33 <desrt> "you can't drive away in cars you don't own" has got to be in there somewhere
12:24:42 <glguy> desrt: well... nickserv warns you right off the bat that you are using someone elses name
12:24:52 <desrt> glguy; it doesn't do it very loudly
12:25:11 <desrt> it tosses it in among all the other login junk in the server status window
12:25:14 <int-e> desrt: it can do it more loudly if the nick owner wishes
12:25:20 <desrt> interesting.
12:25:27 <xerox> You could drive with eachother's cars to #haskell-blah (;
12:25:49 <glguy> xerox: I would never steal a car!
12:25:55 <int-e> /ns help set kill
12:26:11 <int-e> I don't advocate its use, but the feature exists.
12:26:26 <desrt> i'd just end up hurting myself more than anyone else
12:27:29 <glguy> Kill protection is disabled on this network
12:27:46 <desrt> now that's an interesting idea
12:28:01 <int-e> oh ok. I don't really care actually.
12:28:08 <desrt> so it's not even like the car that stalls.  it just lets you drive it around anyway :)
12:28:56 <int-e> the ghost command is really all I want.
12:28:59 <dino-> I think I've also been confused about what a StdGen is.
12:29:36 <desrt> the desrt_ effect is minorly annoying
12:29:45 <desrt> so ghost is nice
12:29:46 <xerox> dino-: a number generator
12:29:55 <xerox> ?docs Data.Random
12:29:55 <lambdabot> Data.Random not available
12:29:58 <desrt> not sure it's enough to justify having a nickserv, but whatever :)
12:30:00 <glguy> I can't stand desrt_ either
12:30:00 <xerox> ?docs System.Random
12:30:01 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
12:30:02 <dino-> That function newStdGen :: IO StdGen, but you have to pass it something.
12:30:22 <xerox> dino-: newStdGen is an IO action returning a StdGen
12:30:39 <desrt> glguy; your connection seems to go up/down a lot when you're using tor
12:30:45 <desrt> glguy; so you get the glguy_ effect more often than most
12:30:54 <spiffy> also: compound lets dont work for me. very frustrating
12:30:55 <glguy> desrt: I hate having to use tor
12:31:00 <xerox> dino-: click on that url, then click on "StdGen" in the box that has "data StdGen" written inside it, at the top.
12:31:00 <desrt> work?
12:31:12 <glguy> yeah
12:31:17 <desrt> fascists
12:31:48 <xerox> hehe, tor gets tor-ough.
12:32:04 <desrt> it's sort of ironic
12:32:06 <glguy> freenode should accept connections on all ports when you are connecting to irc.
12:32:17 <desrt> since the reason a lot of people firewall irc is exactly because of the lack of nickserv/chanserv :)
12:32:49 <desrt> on some networks, being on irc with a certain name or in a certain channel is like saying "DIRECT YOUR PACKETS HERE, KIDDIES!"
12:33:03 <desrt> so people firewall it
12:33:11 <dino-> Yeah. I've been reading that. But not getting what it means. Thank you.
12:33:46 <glguy> I realize that it would defeat the point of the system, but it'd be cool to have some idea of where my packets were being routed thorugh
12:34:25 <glguy> how many hops were actually between me and the channel
12:34:35 <desrt> glguy; surely as the client end you can find that out
12:34:47 <spiffy> can someone post a simple function that uses let to make more than 1 binding?
12:34:59 <glguy> desrt: I don't think so... you access freenode as a hidden service
12:35:07 <desrt> > let f = succ in f (f 1)
12:35:08 <lambdabot>  3
12:35:12 <desrt> like this?
12:35:20 <emu> > let a = 1 ; b = 2 in (a,b)
12:35:20 <kpreid> > (\a -> let b = a + 1; c = a + 2 in a + b) 1
12:35:21 <lambdabot>  (1,2)
12:35:22 <lambdabot>  3
12:35:26 <spiffy> alright
12:35:27 <desrt> oh.  like that :)
12:35:29 <spiffy> that all works
12:35:31 <emu> newline suffices instead of ;
12:35:41 <spiffy> emu: thats where it all breaks down
12:35:42 <kpreid> spiffy: let follows the rules of block layout
12:35:42 <xerox> dino-: the library offers a RandomGen g class, with three methods: next :: g -> (Int, g), split :: g -> (g, g), getRange :: g -> (Int,Int).  It also offers an instance, named StdGen, which guarantees a range of at least 30 bits.  The range is where the Int number returned by next resides.
12:35:44 <desrt> see also
12:35:52 <desrt> > let (a, b) = (1, 2) in a + b
12:35:53 <emu> spiffy: no it doesn't.  it's Layout
12:35:54 <lambdabot>  3
12:36:02 <emu> spiffy: be sure you indent correctly.
12:36:18 <spiffy> emu: just to double check, whats correctly?
12:36:27 <glguy> desrt: that's actually the cool thing about hidden services.  As the user I can't figure out where the service is located, and the service can't determine where the user is located
12:36:36 <emu> indenting two or more lines to the same column, consecutively, is like putting them in the same block
12:36:54 <spiffy> how many spaces indented?
12:37:04 <xerox> > let evens = map (+1) odds; odds = 1 : map (+1) evens in transpose [odd,evens] -- spiffy
12:37:05 <lambdabot>    Expecting a function type, but found `[a]'
12:37:05 <emu> any number really, though usually it's done in steps of 4
12:37:06 <lambdabot>    Expected type: [a]
12:37:06 <lambdabot>   ...
12:37:08 <xerox> oops.
12:37:17 <desrt> glguy; that's nice
12:37:33 <spiffy> any other rules for let blocks? still cant see my mistake in the layout
12:37:55 <mauke> yeah, start a new line after any keyword that wants layout
12:38:05 <psi> let a = 1
12:38:07 <psi>     b = 2
12:38:22 <psi> in a + b
12:38:36 <spiffy> hmm
12:38:37 <spiffy> well
12:39:02 <kpreid> the non-first lines of a block must be indented to the same column as the first line of the block.
12:39:02 <spiffy> using semicolons works
12:39:08 <spiffy> so ill stick to that
12:39:09 <kpreid> that's all.
12:39:33 * dcoutts never uses semicolons
12:39:47 * glguy just listened to his voice mail... had 3 message going back to 10/13
12:39:51 <dcoutts> just line it up and it works and looks nicer
12:39:53 <desrt> layout is nice and funny
12:40:01 <glguy> dcoutts: hear hear! (-:
12:40:21 <spiffy> laugh i will paste bin my code and someone can tell me where my layout error is
12:40:24 <desrt> if you write code that is aesthetically nice then it usually automatically works without you thinking about it
12:40:49 <desrt> but most people don't actually know what the rules are
12:40:51 <glguy> additionally, if you are using any tabs, your tab stop must be set to 8
12:41:00 <glguy> (I don't know if anyone else already covered that)
12:41:23 <mauke> glguy: no, it doesn't have to be
12:41:37 <mauke> I use tabs with ts=4
12:41:50 <spiffy> im using 4.
12:41:54 <desrt> mauke; if you mix tabs and spaces or use layout without making new lines for everything then glguy is more or less right
12:42:20 <xerox> I use smart-indent of haskell-mode, and have Emacs put spaces in place of tabs.
12:42:20 <mauke> anyone who mixes tabs and spaces for indentation should be beaten
12:42:27 <glguy> it can work, but GHC reads a \t as 8 spaces
12:42:27 <desrt> i disagree strongly.
12:42:28 <spiffy> d'oh
12:42:38 <desrt> in C if you're using tabs you really need to be using spaces too
12:42:45 * glguy uses expandtab, so it doesn't so much matter
12:42:47 * spiffy didnt check off insert tabs as spaces
12:42:52 <mauke> desrt: what, why?
12:42:54 <desrt> glguy; ya.  that's the sanest solution.
12:43:11 <desrt> mauke; lemme make an example
12:43:11 <desrt> ?paste
12:43:12 <glguy> mauke: because you tab to the correct indentation level, and then space any further
12:43:13 <lambdabot> http://paste.lisp.org/new/haskell
12:43:23 <mauke> glguy: why would I space any further?
12:43:35 <glguy> mauke: statements that span many lines
12:43:48 <mauke> tabs
12:43:52 <glguy> function(argument,
12:43:54 <glguy>          argument
12:44:03 <mauke> function(
12:44:05 <mauke>     arg1,
12:44:07 <mauke>     arg2
12:44:08 <mauke> );
12:44:24 <lisppaste2> desrt pasted "indent example" at http://paste.lisp.org/display/29172
12:44:29 <lisppaste2> spiffy pasted "Constraint problem --apparently?" at http://paste.lisp.org/display/29173
12:44:49 <mauke> desrt: eww, ugly
12:44:55 <desrt> mauke; no.  very important.
12:45:18 <desrt> mauke; if you use tabs to skip across the length of 'some_long_function_name ' then your code layout utterly breaks if you change your tabstop size
12:45:28 <desrt> mauke; with my way you're ok
12:45:41 <lisppaste2> mauke annotated #29172 with "my style" at http://paste.lisp.org/display/29172#1
12:46:00 <desrt> but you can still change the tabstop to modify the logical indent level
12:46:03 <spiffy> someone explain why makeSuit is wrong?
12:46:07 <emu> never use tabs
12:46:11 <desrt> emu; i agree :)
12:46:16 <emu> it's just opening yourself up for getting fucked
12:46:19 <mauke> spiffy: what's the error?
12:46:22 <sjanssen> spiffy: what is the error message?
12:46:22 <Igloo> mauke: Would you use that style if tabs didn't exist?
12:46:41 <mauke> Igloo: dunno
12:46:50 <desrt> if you _insist_ on using tabs then you need spaces anyway
12:46:51 <spiffy> Cannot justify constraints in explicitly typed binding
12:46:55 <desrt> so why not just use spaces? :)
12:47:16 <mauke> but I definitely wouldn't put a space between a function and "(", and I wouldn't indent that far to the right
12:47:30 <glguy> I prefer the mixed (properly) tabs and spaces. some people prefer more indent than others when editing code
12:47:47 <mauke> glguy: d'accord
12:47:50 <emu> mixing them just makes it worse
12:48:05 <sjanssen> spiffy: [1..10] will default to Integer, so there's one potential problem
12:48:22 <mauke> spiffy: that's not a complete error message
12:48:29 <dino-> Ok, I'm getting it a little. Those things like newStdGen are in IO. Actions. From the capture, what int-e and Cale were saying: newStdGen >>= ....
12:48:30 <emu> working on large projects I often come across code which looks somewhat indented, except that it's offset completely wrong by *ahem* some multiple of spaces
12:49:03 * desrt didn't know that umontreal existed
12:49:08 <emu> and in Haskell, that actually hurts
12:49:14 <glguy> Visual Studio will correct the spaces for you
12:49:28 <Cale> dino-: yeah, you can use them that way, or else use do-notation, like g <- newStdGen, which will run the action and bind the generator it constructs to g
12:49:29 <glguy> and that's what we have at work
12:49:31 <emu> it can't correct Haskell because spaces alter semantics
12:49:39 <dino-> Thank you guys. I feel very dense. You're patient people.
12:49:49 <desrt> glguy; visual studio _can_ correct the spaces for you because in any language that VS supports spaces don't affect the meaning of the program
12:49:49 <glguy> emu: I don't mix tabs in haskell code
12:49:51 <emu> and I'm surprised Visual Slutio can do Automatic Indentation finally.  new fangled eh, something Emacs has being doing for 25 years
12:50:02 <glguy> desrt: I'm aware, but you were talking about C
12:50:24 <desrt> glguy; looked like you were replying to emu
12:50:39 <glguy> emu: but emacs still doesn't work as a boot loader
12:50:57 <emu> init=/usr/bin/emacs
12:51:03 <glguy> emu: and most operating system have *some* mechanism to start up the computer
12:51:09 <desrt> the need for a kernel will soon be gone
12:51:16 <desrt> i hear they already have a vfs
12:51:38 <emu> look, last time I used any fancy schmancy M.S. product, it couldn't even do automatic indentation.  I can't believe people pay money for that.
12:51:52 <glguy> I prefer NetBSD to emacs (-:
12:51:55 <ral1> oin #python
12:52:01 <_frederik_> how does one use type variables in patterns in methods in instance declaration?
12:52:04 <emu> ral1: caughtya
12:52:05 <_frederik_> s
12:52:06 * glguy is no supporter of Msft, just uses it at work
12:52:12 <_frederik_> in ghc6.6
12:52:14 <ral1> emu: oops.
12:52:31 <ral1> oin #haskellsux
12:53:00 <emu> eta oin?
12:53:07 <desrt> moin with a broken m key?
12:53:07 <mauke> shrdlu
12:53:23 * glguy thinks tor might be scrambling text
12:53:34 <desrt> glguy; that seems very unlikely
12:53:42 <spiffy> mauke: I can post the whole thing but i didnt want to spam
12:53:54 <mauke> that's why you put it in the paste
12:54:10 <ral1> emu, I was meaning to join #python but I typed "oin #python" instead of "/join #python".  Then I was embarassed, so I said "oin #haskellsux" as a joke.
12:54:23 <glguy> desrt: that's part what makes a sarcastic comment funny
12:54:41 <desrt> glguy; glad i could help :)
12:54:42 <lisppaste2> mcspiff annotated #29173 with "error message" at http://paste.lisp.org/display/29173#1
12:55:07 <emu> and i said "eta oin" as in the phrase to indicate a typing error on old linotype machines
12:55:12 <emu> etaoin shrdlu
12:55:25 <sjanssen> spiffy: replace [1..10] with [1 :: Int .. 10]
12:55:43 <ral1> *Sigh*.  I don't know how to resize windows in fluxbox, (you can't just grab the corner), so for now I'm reading this with a tiny window.
12:55:48 <xerox> > [1..10] :: [Int]
12:55:50 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
12:56:03 <_frederik_> nevermind
12:56:04 <glguy> ral1: can you hold control or alt and drag with one of the mouse buttons?
12:56:14 <spiffy> sjanssen: that did it
12:56:15 <glguy> ral1: I use Alt + Right mouse button on this WM
12:58:44 <ral1> glguy: That's pretty sweet.  That actually worked.
12:59:14 <ral1> It's funny because I'm using an ibook (hence no right mouse button) and so it's alt+f10 + drag on this system.  Very awkward!
13:00:13 <lisppaste2> spiffy annotated #29173 with "Another Constraint problem" at http://paste.lisp.org/display/29173#2
13:00:27 <spiffy> Tried to clean it up a bit, didnt really work.
13:00:29 * psi uses fn+ctrl or alt for middle/right-click
13:00:40 <xerox> ral1: fluxbox on os x?
13:01:42 <ral1> xerox: yup
13:01:51 <xerox> Yuck.
13:02:00 <ral1> xerox: to each his own.
13:02:16 <xerox> What's the good part of that?
13:02:39 <ral1> xerox: Well, do you like fluxbox?
13:02:47 <xerox> I used it in the past
13:04:19 <Syzygy-> dolio: The one point I would have wanted to make in that reddit debate. And you come and do it before I get around. :P
13:04:38 <ral1> xerox: The very best part is that my power cord broke near the end so I sawed it open with a pocket knife and soldered it and then dipped it wax.  So now I have this gnarly cludge on the side of the ibook.  It kind of makes me feel like a pirate.
13:04:52 <dino-> I use fluxbox for a couple of years now. Although I do have resizing regions on both bottom corners and always have. Maybe some kind of config switch.
13:04:53 <dolio> Heh. The Leibniz thing? :0
13:04:59 <Syzygy-> Yah.
13:05:14 <xerox> ?arr
13:05:14 <lambdabot> Aye Aye Cap'n
13:05:36 <Syzygy-> I would have added that the category theorists aren't really very united on a term, so apart from monad, it's also called triples and a bunch of other names, but you made the point way too eloquent...
13:05:57 <Cale> spiffy: You'll find it works if you replace one decker with decker'
13:06:18 <spiffy> Cale: It also works if i spin decker out to be its own function and add a proper type def.
13:06:33 <spiffy> is it possible to add a type def to a lambda?
13:06:40 <dolio> Yeah, I saw that on wikipedia when I was looking for where the name came from, but figured I wouldn't bother with it.
13:06:40 <Cale> yeah, you could also just give it a type signature
13:06:51 <dolio> Is the "ad" from adjoint functor?
13:07:25 <Cale> Well, the same way you add a type signature to anything
13:07:39 <lisppaste2> spiffy annotated #29173 with "Finally working version " at http://paste.lisp.org/display/29173#3
13:08:30 <spiffy> Cale: sorry, i mean to "let" version of decker
13:08:38 <lisppaste2> Cale annotated #29173 with "polymorphic signature" at http://paste.lisp.org/display/29173#4
13:08:57 <spiffy> o wow.
13:09:08 * spiffy is starting to like this whole haskell thing
13:09:28 <Syzygy-> dolio: I don't really know the exact etymology of 'monad'... However, at least 'triple' is enough widespread for one serious source of the theory to have it in the title:
13:09:33 <Syzygy-> Toposes, triples and theories
13:09:38 <Syzygy-> by Michael Barr and one more.
13:09:42 <Cale> monad is a portmanteau of monoid and triad
13:09:57 <dolio> Ah, okay.
13:10:24 <Cale> It has nothing to do with the older philosophical word "monad"
13:10:40 <Syzygy-> Nothing at all.
13:10:49 <Syzygy-> Ah, that's the etymology.
13:11:00 <Syzygy-> Yeah, triad is another of the terms often used for it (according to tt&t)
13:11:27 <dolio> I remembered the monoid part, but I couldn't remember what other word it was combined with.
13:11:49 <Cale> They were originally referred to as triples until people started to agree that was a stupidly ambiguous name :)
13:13:32 <Cale> Hehe, also, is it toposes, or topoi? Nobody can seem to agree on that.
13:13:58 <dolio> In any case, they weren't invented by Leibniz, as part of the integral and differential calculi, which is where functional languages come from. :)
13:14:09 <xerox> Is topoi theory the one about all the different kinds of logic?
13:15:52 <spiffy> woohoo, finally figured out a situation where foldl/r is useful.
13:16:12 <ral1> spiffy: do tell.
13:16:14 <astrolabe> It is a kind of generalisation of sets I think xerox
13:16:14 <xerox> Consuming lists?
13:16:19 <Syzygy-> xerox: It's the one where logic is a sheaf of categories...
13:16:32 <Syzygy-> Cale: I like topoi, but then I'm  a sucker for the classics..
13:16:37 <Syzygy-> Barr uses Toposes
13:16:38 <xerox> Syzygy-: I'm sorry I don't know what a sheaf is.
13:16:49 <spiffy> i ended up with a list of list, used foldl to stick'em all togeather
13:16:51 <Syzygy-> xerox: I'm pretty certain you won't want to know...
13:17:02 <astrolabe> I bet he does :)
13:17:07 <Syzygy-> dolio: However, Leibniz -did- talk about monads. They're just a completely other beast.
13:17:34 <dolio> Right, I know. :) Fundamental constituents of stuff, and such.
13:17:41 <ral1> spiffy, with '++'?
13:17:41 <roconnor> @seen sigfpe
13:17:42 <lambdabot> I haven't seen sigfpe.
13:18:09 <Syzygy-> Yah
13:18:14 <xerox> It looks like a _very_ abstract thing.
13:18:41 <roconnor> right, monads are the fundamental building blocks of the universe, right?
13:19:11 <Syzygy-> @pl \xs -> [y | x <- xs, y <- x^2]
13:19:11 <lambdabot> (: [y <- x ^ 2]) . ((y | x) <-)
13:19:16 <dolio> I'm sure the link he posted is a good explanation of what Leibniz was talking about, but it has nothing to do with functional programming. :)
13:19:33 <Syzygy-> ?type (: [y <- x ^ 2]) . ((y | x) <-)
13:19:35 <lambdabot> parse error on input `<-'
13:19:37 <Syzygy-> dolio: Yah.
13:19:47 <xerox> Syzygy-: @. pl undo it
13:20:03 <Syzygy-> xerox: huh?
13:20:30 <xerox> @. pl undo do { x <- xs; y <- x^2; return y }
13:20:31 <lambdabot> (^ 2) =<< xs
13:20:31 <roconnor> Syzygy-: pl doesn't understand list comprehensions
13:20:37 <Syzygy-> roconnor: Ah.
13:20:40 <Syzygy-> What is undo?
13:20:40 <xerox> Whatever *that* means.
13:20:43 <Syzygy-> @type undo
13:20:45 <lambdabot> Not in scope: `undo'
13:20:46 <xerox> Desugars do forms.
13:20:46 <roconnor> but pl likes to pretend it does
13:20:49 <Syzygy-> Ah.
13:21:19 <Syzygy-> > (^2) =<< [1,2,3,4,5]
13:21:20 <xerox> Then there is @compose that threads the data from a lambdabot command to another.
13:21:20 <lambdabot>  add an instance declaration for (Num [b])
13:21:20 <lambdabot>   In the list element: 5
13:21:43 <xerox> > (^2) `fmap` [1,2,3,4,5]
13:21:44 <lambdabot>  [1,4,9,16,25]
13:21:46 <ral1> spiffy: are you going to make that script play "Texas Hold 'Em"?
13:21:47 <Syzygy-> Ah.
13:22:00 <xerox> \xs f -> xs >>= return . f   ==>   fmap
13:22:15 <xerox> \f xs -- anyway
13:25:49 <Syzygy-> afk
13:25:52 <Syzygy-> *gone*
13:27:51 <xerox> ?type flip (>>=) . (return .)
13:27:53 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b) -> m a -> m b
13:28:03 <xerox> eh.
13:28:45 <xerox> fmap = (=<<) . (return .)
13:33:50 <sieni> argh
13:44:54 <fons> how can I add package modules in ghci ?
13:45:14 <fons> :a GHC.Base leads to <no location info>: module `GHC.Base' is a package module
13:46:23 <therp> try :module +GHC.Base
13:47:03 <fons> great!
13:47:04 <fons> :)
13:47:08 <fons> thanks
13:48:42 <ral1> fons: are you recompiling ghci?
13:49:12 <fons> ral1, no
13:49:15 <fons> why?
13:50:18 <ral1> fons I was just trying to figure out what it means to add package modules to ghci...
13:50:45 <fons> ral1, hehehe, maybe I wasn't that clear :)
13:54:16 <fons> and is there a way to get the reduction number like in hugs?
14:02:00 <xerox> fons: no, but you can do :set +s if you like information on memory used
14:02:13 <fons> xerox, thanks
14:05:43 <metaperl> what do you have to import to get average to work?
14:12:43 <lisppaste2> metaperl pasted "2 questions" at http://paste.lisp.org/display/29187
14:16:41 <kpreid> metaperl: (1) it's not in the standard library; (2) the parentheses have no significance there
14:17:06 <metaperl> kpreid: thanks
14:17:07 <kpreid> average xs = sum xs / length xs
14:17:24 <kpreid> or, average = liftM2 (/) sum length
14:17:44 <metaperl> that liftM2 is beyond me at the moment :)
14:17:48 <metaperl> so I will use the former
14:18:43 <glguy> liftM2 (/) sum (fromIntegral . length)  --or-- liftM2 (/) sum genericLength -- (-:
14:21:24 <mathewm> now, how is sum of type (Monad a) => a b ?
14:22:01 <desrt> ?type sum
14:22:03 <lambdabot> forall a. (Num a) => [a] -> a
14:22:07 <kpreid_> mathewm: a is (->)
14:22:12 <Cale> mathewm: ((->) e) is a monad for any e
14:22:20 <desrt> monad sum seems like a neat idea
14:22:26 <mathewm> just when I thought I knew what was going on...
14:22:28 <Cale> hehe
14:22:36 <Cale> do you know the reader monad?
14:22:36 <desrt> #mercury is a grave
14:22:38 <kpreid_> mathewm: a.k.a. the reader monad
14:22:39 <Cale> It's just that
14:22:58 <Cale> > do {x <- (+1); y <- (*2); return (x,y)} 5
14:23:01 <lambdabot>  Parse error
14:23:03 <desrt> its channel membership is a strict subset of #haskell's membership
14:23:14 <Cale> > (do {x <- (+1); y <- (*2); return (x,y)}) 5
14:23:15 <lambdabot>  (6,10)
14:23:21 <Cale> there we go :)
14:23:50 <Cale> 5 is passed as an implicit parameter to each of the computations run
14:23:55 <mathewm> what package defines the four functions of Monad for (->) a ?
14:24:01 * desrt thinks about directly using mercury's logic rules for writing the reduction rules for lambda calculus
14:24:12 <edwardk> its in Control.Monad.Reader right?
14:24:16 <Cale> Control.Monad.Reader or Control.Monad.Instances (i. 6.6)
14:24:19 <desrt> i hope it's good at tree pruning.
14:24:44 <xerox> > ((*2) `fmap` (+2)) 10
14:24:45 <lambdabot>  24
14:24:55 <malcolm> has anyone here viewed the GHC hackathon videos?
14:24:55 <lambdabot> malcolm: You have 1 new message. '/msg lambdabot @messages' to read it.
14:25:14 <mathewm> I watched them (and was present)
14:25:44 <malcolm> I was wondering whether people found them useful or not
14:25:53 <Cale> fmap as a generalisation of function composition, heh. If we put the reader instance in the prelude, we could rename fmap to (.)
14:26:12 <Philippa> heh
14:26:24 <Philippa> that's beautifully twisted
14:26:33 <Cale> that would be pretty awesome, actually
14:26:34 <malcolm> it is taking me a long time to cut and upload the videos, for which I apologise
14:26:36 <astrolabe> Does anyone know how I can make ghcprof.prl work?  The GHC user manual says '$ ghcprof <prog>.prof', but that just gets me "'ghcprof' is not recognised as an internal or external command, operable program or batch file."
14:26:44 <kpreid_> {fmap,liftM,(.)}!
14:26:57 <Cale> yeah, and we wouldn't need map either, of course
14:26:58 <glguy> Cale: I've been asking for that for a while (in channel) (-:
14:27:10 <kpreid_> {map,fmap,liftM,(.)}!!
14:27:24 <glguy> succ . [1,2,3,4] -- sweet
14:27:57 <desrt> is there a unit monad?
14:28:06 <Cale> Identity
14:28:08 <Cale> yeah
14:28:09 <desrt> er.. maybe better called identity monad
14:28:11 <desrt> right
14:28:12 <glguy> There's an identity monad
14:28:16 <kpreid> in Control.Monad.Trans
14:28:35 <Cale> There should be an IdentityT, just for completeness
14:28:37 <desrt> so fmap succ (1)
14:28:45 <desrt> still 2
14:28:51 <Cale> In case people need a base case for monad transformer transformers
14:29:04 <desrt> it should work without help, though
14:29:21 <kpreid> > (succ `fmap` succ) `fmap` [1,2,3,4]
14:29:22 <lambdabot>  [3,4,5,6]
14:29:22 <Cale> Well, you'd need to wrap that in an Identity
14:29:41 <desrt> ya.  that's very lame.
14:29:48 <xerox> malcolm: what's the url? I want to see them.
14:30:01 <dons> xerox: on the ghc wiki
14:30:03 <desrt> i guess it makes sense, though
14:30:07 <kpreid> @type (succ `fmap` succ) `fmap` msum [1,2,3,4]
14:30:09 <desrt> if you look at []
14:30:09 <lambdabot> forall (m :: * -> *) a. (Functor m, Enum a, MonadPlus m, Num (m a)) => m a
14:30:10 <xerox> (!)
14:30:17 <desrt> is that the identity monad containing a list or the list monad?
14:30:21 <kpreid> er
14:30:24 <desrt> you'd have ambiguity
14:30:32 <malcolm> xerox: http://hackage.haskell.org/trac/ghc/wiki/Hackathon
14:30:35 <lambdabot> Title: Hackathon - GHC - Trac, http://tinyurl.com/f5y5y
14:31:01 <Cale> We should just start on a #haskell prelude :)
14:31:15 <kpreid> @type ((succ `fmap` succ) `fmap` msum `fmap` return) [1,2,3,4]
14:31:16 <malcolm> xerox: or more accurately, http://hackage.haskell.org/trac/ghc/wiki/AboutVideos
14:31:16 <lambdabot> forall a. (Enum [a], Num a) => [a]
14:31:18 <lambdabot> Title: AboutVideos - GHC - Trac, http://tinyurl.com/w2uvy
14:31:20 <xerox> Cale yes please!
14:31:21 <desrt> Prelude'
14:31:32 <kpreid> that's still not right
14:31:32 <desrt> ala wolfram's Haskell'
14:31:45 <xerox> Wolfram's?!
14:31:51 <kpreid> @type ((succ `fmap` succ) `fmap` msum `fmap` return) `fmap` [1,2,3,4]
14:31:52 <lambdabot> forall (m :: * -> *) a. (Enum (m a), MonadPlus m, Num (m a)) => [m a]
14:31:53 <desrt> he claims credit for the name
14:32:07 <lisppaste2> metaperl annotated #29187 with "cannot get homebuilt average function to work" at http://paste.lisp.org/display/29187#1
14:32:16 * kpreid quits
14:32:31 <glguy> Cale: a #haskell haskell impl. would need to support Monad comprehensions :)
14:32:39 <xerox> kpreid: we have Monad m, Num (m a) actually.
14:32:50 <desrt> and 'map' would just be 'fmap'
14:32:52 <metaperl> IGNORE MY QUESTION... I AM GOING HOME... BE ON in 30 MINUTES... LATER
14:32:55 <malcolm> xerox: there are approx five more hours of video still to be processed and uploaded...
14:33:01 <xerox> malcolm: cool!
14:33:03 <xerox> malcolm++
14:33:09 <Cale> yeah, apparently if someone hacks monad comprehensions back into GHC on a switch, the patch will be accepted
14:33:21 <desrt> Cale; how does that ban thing work, again?
14:33:30 <desrt> Cale; you have slightly less than 30 minutes to figure it out :)
14:33:34 <Cale> heh
14:33:42 <xerox> Cale, yarr.  Offer to do it for some amount, aren't you looking forward working? :)
14:34:04 <glguy> > let avg xs = sum xs / (fromIntegral . length) xs in avg [1,3,7,10]
14:34:05 <lambdabot>  5.25
14:34:14 <Cale> I sent another resume off yesterday on request, haven't heard back yet.
14:34:25 <desrt> ?hoogle mfilter
14:34:26 <lambdabot> No matches found
14:34:32 <desrt> why does such a thing not exist?!
14:34:35 <kpreid> ?hoogle filterM
14:34:36 <lambdabot> Monad.filterM :: Monad a => (b -> a Bool) -> [b] -> a [b]
14:34:36 <lambdabot> Control.Monad.filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
14:34:36 <lambdabot> Data.Graph.Inductive.Query.Monad.graphFilterM :: GraphM m gr => (Context a b -> Bool) -> GT m (gr a b) [Context a b]
14:34:42 <desrt> thank goodness
14:34:43 <glguy> ban thing?
14:35:00 <desrt> kpreid; no.  that's not right at all
14:35:08 <kpreid> desrt: oh, mzero
14:35:10 <Cale> glguy: earlier the banlist was full when we needed to ban someone :)
14:35:15 * kpreid thinks
14:35:30 <glguy> filterM
14:35:33 <desrt> kpreid; that's more like a filter where each instance of the predicate runs in the monad
14:35:38 <glguy> m* is for MonadPlus stuff
14:35:39 <kpreid> right, that's what fooM is
14:35:43 <kpreid> @type guard
14:35:45 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
14:35:47 <glguy> *M is for Monad stuff :)
14:35:57 <desrt> i men more like Monad m => (a -> Bool) -> m a -> m a
14:36:14 * glguy might be lagged up to 1 minute now
14:36:18 <desrt> so like mfilter even (Just 1) = Nothing
14:37:03 <kpreid> @type \f x = guard (f x); return x
14:37:04 <lambdabot> parse error on input `='
14:37:09 <kpreid> @type \f x -> guard (f x); return x
14:37:10 <lambdabot> parse error on input `;'
14:37:11 <desrt> ya.  guard is definitely involved :)
14:37:15 <kpreid> @type \f x -> do guard (f x); return x
14:37:17 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => (a -> Bool) -> a -> m a
14:37:27 <desrt> can't just be x
14:37:31 <desrt> you need x >>=
14:37:40 <Botty> whoah, guards are monads?
14:37:49 <xerox> Nope.
14:37:54 <kpreid> @type \f -> (>>= \x -> do guard (f x); return x)
14:37:55 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => (a -> Bool) -> m a -> m a
14:38:00 <desrt> much better :)
14:38:06 <kpreid> @pl \f -> (>>= \x -> do guard (f x); return x)
14:38:06 <glguy> do { a <- x; guard (pred a); return a }
14:38:07 <lambdabot> (line 1, column 8):
14:38:07 <lambdabot> unexpected ">"
14:38:07 <lambdabot> expecting lambda abstraction or expression
14:38:13 <kpreid> @. pl undo \f -> (>>= \x -> do guard (f x); return x)
14:38:14 <lambdabot> (=<<) . (`ap` return) . (((>>) . guard) .)
14:38:25 <desrt> i guess guard is only defined on MonadPlus
14:38:32 <desrt> since you need a zero
14:38:37 * kpreid nods
14:39:01 <desrt> (\f -> (>>= \x -> do guard (f x); return x)) even [1..]
14:39:02 <Cale> yeah, that's an H98 stupidity
14:39:05 <desrt> > (\f -> (>>= \x -> do guard (f x); return x)) even [1..]
14:39:05 <xerox> Nope
14:39:06 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
14:39:09 <desrt> :)
14:39:10 <xerox> guard fails
14:39:17 <Cale> They merged MonadZero and MonadPlus
14:39:26 <desrt> perfect.
14:39:32 <Cale> and so you need a plus even if you only want a zero
14:39:49 <kpreid> @type msum
14:39:51 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [m a] -> m a
14:40:13 <desrt> > msum Nothing
14:40:14 <lambdabot>  Couldn't match `[m a]' against `Maybe a1'
14:40:15 <kpreid> @type msum . fmap return
14:40:17 <glguy> Much better response times now
14:40:17 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => [a] -> m a
14:40:23 <desrt> oh.  right
14:40:27 <desrt> > msum [Nothing]
14:40:28 <lambdabot>  Add a type signature
14:40:34 <desrt> > msum [Nothing::Maybe Int]
14:40:35 <lambdabot>  Nothing
14:40:41 <desrt> i'd have expected Just 0
14:40:46 <glguy> ?hoogle genericFilter
14:40:47 <lambdabot> No matches found
14:41:09 <kpreid> > mzero :: Maybe
14:41:11 <lambdabot>    `Maybe' is not applied to enough type arguments
14:41:11 <lambdabot>   Expected kind `?', b...
14:41:14 <kpreid> > mzero :: Maybe Int
14:41:15 <lambdabot>  Nothing
14:41:18 <desrt> Cale; is the list of extra modules that lambdabot has in scope available?
14:41:35 <Cale> It's available as part of the lambdabot source code
14:41:42 <xerox> @listmodules
14:41:43 <lambdabot> babel base bf check compose dice dict djinn drhylo dummy elite eval fact free fresh ft haddock help hoogle instances karma lambda localtime log more pl poll pretty quote search seen slap small spell
14:41:43 <lambdabot> state system tell todo topic type undo unlambda url version vixen where
14:41:50 <xerox> @listcommands
14:41:51 <lambdabot> Unknown command, try @list
14:41:53 <desrt> not those type of modules
14:41:59 <xerox> Oh.
14:42:01 <xerox> @version
14:42:02 <lambdabot> lambdabot 4p257, GHC 6.5 (OpenBSD i386)
14:42:03 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:42:17 <Cale> It's in RunPlugs.hs
14:42:35 <Cale> http://www.cse.unsw.edu.au/~dons/lambdabot/scripts/RunPlugs.hs
14:42:37 <lambdabot> http://tinyurl.com/h7nko
14:42:43 <desrt> i think ephy has crashed
14:42:47 <glguy> > [id] <*> [()]
14:42:49 <lambdabot>  Not in scope: `<*>'
14:42:57 <tessier> Can haskell load and replace code on the fly like erlang can?
14:43:00 <glguy> )-,:
14:43:10 <glguy> hsplugins can
14:43:12 <Cale> tessier: dons wrote a library for that
14:43:19 <Cale> called hs-plugins yeah
14:43:25 <kpreid> glguy: <*>?
14:43:27 <tessier> Interesting...
14:43:30 <Cale> http://www.cse.unsw.edu.au/~dons/hs-plugins/
14:43:31 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules
14:43:31 <desrt> heh
14:43:33 <glguy> kpreid: Control.Applicative
14:43:35 <desrt> obnoxious list :)
14:43:41 <kpreid> ah, 6.6 stuff
14:43:47 <xerox> UH, what's that?
14:44:01 <glguy> Applicatives are Monads - bind
14:44:03 <xerox> I should really get around compiling 6.6.
14:44:04 * kpreid reads about Control.Applicative
14:44:04 <Cale> it's ap
14:44:10 <xerox> Ah, I see.
14:44:16 <Cale> > [id] `ap` [()]
14:44:21 <lambdabot>  [()]
14:44:33 <desrt> interesting question
14:44:38 <Cale> xerox: make an Ubuntu package if you do :)
14:44:44 <desrt> if something has a type signature that does not include IO
14:44:56 <glguy> it doesn't do IO :)
14:44:59 <desrt> and if you do not allow it to call unsafePerformIO (by whatever mechanism)
14:45:03 <glguy> (yeah, i know what unsafe functions are)
14:45:05 <desrt> then is it unhackable?
14:45:06 <kpreid> <*> is like (>>= fmap)?
14:45:09 <xerox> Cale, too bad I'm on OS X Intel now.  I was thinking about installing ubuntu again though.
14:45:11 <xerox> > [(+2),(*3)] `ap` [1..3]
14:45:13 <lambdabot>  [3,4,5,3,6,9]
14:45:15 <Philippa> glguy: more accurately, monads - join
14:45:32 <Cale> desrt: essentially, unless GHC has bugs :)
14:45:32 <Baughn> desrt: Fairly unhackable. It's one line of defence; you should add as many as possible.
14:45:36 <xerox> desrt: it is referentially transparente
14:45:38 <xerox> *transparent
14:45:52 <desrt> Cale; that's extremely nice
14:45:55 <glguy> desrt: if you use the result from that function in an IO action
14:46:16 <Baughn> desrt: Separate user account, sandbox, not using other people's code that returns IO, vetting your own code thoroughly, and so on
14:46:32 <desrt> Cale; and i guess since 'show' has no instance for IO
14:46:43 <desrt> it's pretty much safe to show (anything)
14:46:49 <Cale> desrt: I want to make it so that uses of unsafePerformIO require a compiler flag, and using things using unsafePerformIO will too, unless a pragma is supplied.
14:46:50 <desrt> so long as unsafePerformIO doesn't exist
14:47:03 <desrt> Cale; that's a fantastically good idea
14:47:13 <desrt> or, at the very least, have a compiler flag to stomp out unsafeness
14:47:26 <Cale> desrt: yeah, you could also write an instance of Show for IO that just printed "<IO action>" or some such
14:47:28 <Baughn> desrt: Only IO that's returned from main actually happens, so even if Show was instanced for IO - it couldn't possibly /do/ the IO
14:47:30 <xerox> desrt: if you do, say, (return 3 :: IO Int), in GHCi prompt, from 6.5 up, it will print out 3.  Hence they have Show a => Show (IO a) ;)
14:47:46 <desrt> Baughn; wrong
14:47:53 <desrt> Baughn; unsafePerformIO IO happens too
14:47:55 <Baughn> desrt: Modulo unsafePerformIO
14:47:58 <desrt> right
14:47:59 <Cale> desrt: That's a bizarro feature of ghci in 6.6
14:48:10 <desrt> Cale; it says <IO Action>?
14:48:14 <Cale> desrt: It wasn't in 6.4x
14:48:38 <xerox> Yeah, everybody did strange faces to me when I mentioned that at AngloHaskell.
14:48:39 <Cale> ghci6.6 just converts an IO action x to x >>= print
14:48:49 <Cale> when you type one on the prompt
14:49:15 <xerox> hehe, it's different, I think.  Try return () :: IO ().
14:49:20 <desrt> that's sane...ish
14:49:27 <desrt> does it even print out the ()?
14:49:31 <xerox> No.
14:49:37 <Cale> 6.4.2 won't
14:49:39 <desrt> to cale
14:49:40 <Cale> 6.6 will
14:49:44 <desrt> that's _weird_
14:49:51 <xerox> Will it?
14:49:57 <monochrom> I think runST uses unsafePerformIO.
14:50:04 <desrt> monochrom; surely not
14:50:05 <Cale> yes, they changed the behaviour
14:50:15 <Cale> monochrom: yeah, probably
14:50:18 <Cale> hehe
14:50:33 * desrt is annoyed by all the unsafety around
14:50:39 <monochrom> So, runST would require the unsafe flag
14:50:43 <Cale> It's hard to get an infinite polymorphic variable supply source without it.
14:50:44 <xerox> My 6.5 doesn't, Cale.
14:50:49 <glguy> it's only unsafe if you can't prove that it's safe
14:50:49 <desrt> have you seen how many global iorefs are in ghc?
14:50:54 <Cale> monochrom: No, a pragma would be added to runST
14:51:01 <Cale> to mark it as safe
14:51:07 <monochrom> Ah, now I understand.
14:51:38 <Cale> desrt: the only one I know about from fptools is in System.Random
14:51:53 <Philippa> I was thinking only require the flag when compiling the module itself, not modules that import it
14:51:54 <desrt> i mean in the compiler
14:51:57 <desrt> not the libraries
14:52:01 <Cale> oh, I have no idea
14:52:03 <desrt> lots :)
14:52:14 <Cale> wow, that's bad
14:52:17 <desrt> they store their flags/options/arguments like that
14:52:26 <Cale> oh, come on :)
14:52:29 <desrt> then the various bits of the compiler that use them just pull them out of the ether
14:52:39 <Cale> Use a freaking reader monad :)
14:53:07 <Cale> or at least pass them as parameters
14:53:17 <desrt> unpacked_static_opts = unsafePerformIO (readIORef v_Static_hsc_opts)
14:53:19 <desrt> heh
14:53:25 <Cale> I don't understand where the attraction to global IORefs comes from
14:53:59 <desrt> GLOBAL_VAR(v_Static_hsc_opts, [], [String])
14:54:01 <xerox> Speed?
14:54:01 <desrt> uhhh
14:54:09 <desrt> is that ... haskell?
14:54:12 <Cale> heh, yeah, and you'd better hope that IORef is set by the time unpacked_static_opts is first demanded
14:54:23 <desrt> i love how they give ghc a run through the C preprocessor :)
14:55:10 <desrt> Cale; i'm confident that they are pretty sure
14:55:25 <Cale> hehe, this is not behaviour befitting something bearing the title "glorious" :)
14:55:38 <desrt> i'm glad i could open your eyes to this :p
14:55:43 <Cale> hehe
14:55:52 <Cale> I haven't really looked at the GHC source
14:56:00 <dons> mm there really should be a paper "15 years of monads" or something like that, giving a survey of the state of things
14:56:25 <dons> since a lot of cool ideas have been coded in monads, since Wadler stopped writing about them ;)
14:56:28 <ral1> dons: good idea.
14:56:53 <Cale> liftA :: Applicative f => (a -> b) -> f a -> f b
14:56:58 <Cale> oh good, another fmap
14:57:17 <desrt> what is an applicative?
14:57:23 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html
14:57:24 <desrt> less or more restrictive than a functor?
14:57:29 <Cale> more
14:57:29 <lambdabot> http://tinyurl.com/yyo64c
14:57:39 <Cale> It's somewhere between functor and monad
14:57:42 <dons> ral1, heh. my dmesg says: "ral0 at cardbus0 dev 0 function 0 "Ralink Technology, Inc"
14:57:44 <desrt> i see
14:57:53 <desrt> so why bother with liftA?
14:57:58 <desrt> if all Fs are As
14:58:06 <Cale> silliness
14:59:46 <Cale> {(.), map, fmap, liftA, liftM} could all be replaced with a single function
15:00:00 <desrt> not .
15:00:15 * SamB wonders wth lambdabot is loading ./dist/build/Main.o
15:00:18 <SamB> *STILL*
15:00:28 <Cale> > ((+1) `fmap` (*2)) 5
15:00:30 <lambdabot>  11
15:00:34 <desrt> oh.
15:00:38 <dons> SamB: Main.o is the entry point
15:00:40 <desrt> what the HELL just happened?
15:00:44 <SamB> dons: not *anymore*!
15:00:45 <desrt> ?type fmap
15:00:48 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
15:00:54 <Cale> that's the reader monad/functor instance
15:00:56 <dons> hmmm...
15:01:01 <Cale> ((->) e) is a monad
15:01:14 <Cale> (that's a partially applied arrow type constructor)
15:01:14 <SamB> now I've split it and Main.hs only has the main function
15:01:22 <SamB> and calls LMain for the rest
15:01:23 <desrt> that's really messed up
15:01:35 <Cale> > (do x <- (+1); y <- (*2); return (x,y)) 5
15:01:37 <lambdabot>  (6,10)
15:01:37 <dons> SamB: how is that different?
15:01:43 <SamB> DMain has the dynmain function, and likewise calls LMain for the rest
15:01:44 <Cale> cool, eh?
15:01:53 <dons> SamB: ah, i see.
15:01:53 <Baughn> @type ('a' `fmap` (*2)) 5
15:01:55 <lambdabot>   Couldn't match `a -> b' against `Char'
15:01:55 <lambdabot>    Expected type: a -> b
15:02:00 <dons> SamB: ok. yes. yi works like this.
15:02:03 <desrt> it'll be a good year or so before i understand what's going on there :)
15:02:07 <Baughn> @type ((const 'a') `fmap` (*2)) 5
15:02:08 <lambdabot> Char
15:02:08 <SamB> well, DMain imports DynModules whereas Main imports Modules
15:02:14 <Baughn> @type ((const 'a') `fmap` (*2))
15:02:16 <lambdabot> forall a. (Num a) => a -> Char
15:02:20 <dons> it was a hack to have Main.hs be both the static and dynamic entry point
15:02:24 <Cale> 5 is used as an implicit parameter for (+1) and (*2)
15:02:26 <SamB> yes
15:02:27 <dons> SamB: ok.
15:02:33 <dons> a cute hack ;)
15:02:37 <Cale> > join (*) 5
15:02:39 <lambdabot>  25
15:02:43 <xerox> desrt: what does Monad m => m a becomes if the monad is ((->) e) ?
15:02:46 <Cale> square = join (*)
15:02:52 <xerox> *become, sorry I can't type today
15:02:56 <desrt> f function from a to e
15:03:00 <desrt> *a fu
15:03:01 <Cale> function from e to a
15:03:04 <xerox> Nope.
15:03:12 <desrt> oh.
15:03:15 <desrt> (->) e
15:03:16 <desrt> not ->e
15:03:19 <Cale> right
15:03:26 <desrt> so let me get this straight
15:03:29 <SamB> dons: can I get trace output from hs-plugins?
15:03:29 <desrt> functions are monads?
15:03:34 <Cale> Too bad section notation isn't supported for type constructors :)
15:03:35 <xerox> So your actions are all being fed up an "implicit" parameter, or an environment if you want, of type e.
15:03:38 <Cale> yeah
15:03:44 <Cale> Do you know the reader monad?
15:03:45 <desrt> deep.
15:03:48 <desrt> no
15:03:53 <xerox> (Well, functions are arrows.)
15:03:54 <Cale> this is just the reader monad, if you look that up
15:04:00 <dons> SamB: yep. compile hs-plugins with -DDEBUG, iirc
15:04:07 <xerox> It's okay, we can go through it.
15:04:07 <dons> should be details in the .cabal file
15:04:13 <Cale> though typically, there's some extra packaging
15:04:15 <desrt> this is the weirdest thing i've seen in a while
15:04:22 <desrt> and i just recently saw generics
15:04:24 <desrt> so that's saying a lot :)
15:04:33 <xerox> So you have this `e'nvironment passed around all the time.  An useful action would be... getting it.  Hence get.
15:04:41 <desrt> i get the feeling category theory will make more sense if i read the reader monad :p
15:04:46 <Cale> get = id
15:05:04 <xerox> (:
15:05:27 <Cale> > (do x <- (+5); y <- id; return (x,y)) 0
15:05:28 <lambdabot>  (5,0)
15:05:36 <Cale> > (do x <- (+5); y <- id; return (x,y)) 1
15:05:37 <lambdabot>  (6,1)
15:06:10 <xerox> Now try the opposite, Monad (a,w).
15:06:31 <Cale> Is there a direct instance of that?
15:06:37 <xerox> Probably not.
15:06:47 <SamB> dons: I have to recompile?
15:06:53 <desrt> i take it the reader monad is something that, when you fromReader, you give a value
15:06:56 <Cale> I think it would me Monad ((,) w)
15:07:00 <Cale> which would make it (w,a)
15:07:02 <desrt> and anything inside that monad can 'get' to obtain a copy of the value
15:07:09 <xerox> I think it is newtyped as: newtype Writer w a = Writer (a,w).
15:07:13 <Cale> desrt: exactly
15:07:25 <xerox> ?docs Control.Monad.Writer
15:07:26 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Writer.html
15:07:33 <desrt> makes sense
15:07:35 <SamB> there ought to be an env var or something :-(
15:07:37 <desrt> but it's still pretty fucking magic
15:07:47 <xerox> Yes it is.
15:07:56 <dons> SamB: you do.
15:08:04 <kpreid> oh, hi dons. I have my own lambabot build problem :) : "Could not find module `System.Eval.Haskell':"
15:08:13 <kpreid> since pulling patches recently
15:08:19 <xerox> This time you can see your actions as returning a tuple (result, log).
15:08:27 <Cale> desrt: you know the monads as containers analogy?
15:08:28 <desrt> kpreid; on haloween that module was renamed to System.Evil.Haskell
15:08:31 <dons> kpreid: hmm. you using the plugins-based .cabal file?
15:08:32 <xerox> And the special feature is `tell'ing out, through the log.
15:08:33 <desrt> kpreid; you'll have to make the change
15:08:42 <kpreid> dons: yes, because I run an eval bot
15:08:43 <desrt> Cale; i've heard about it from time to time, yes
15:08:51 * SamB tries rebuilding lambdabot from scratch first
15:08:53 <Cale> desrt: It applies fairly nicely -- your containers are indexed by values of type e
15:08:53 <dons> kpreid: ok. sounds like hs-plugins is hidden for some reason
15:09:01 <dons> did you upgrade cabal _after_ building plugins?
15:09:01 <desrt> Cale; i sort of get it
15:09:07 <desrt> it's like an infiniteMap
15:09:14 <Cale> indeed
15:09:20 <dons> (plugins needs Cabal as a dep, so if you change Cabal, ghc-pkg will hide plugins)
15:09:22 <kpreid> dons: all I've done is darcs pull; ./build
15:09:27 <dons> hmm. odd
15:09:35 <xerox> Cale, how are they indexed?
15:09:38 <dons> check ghc-pkg lists plugins as visible
15:09:45 <SamB> kpreid: how long has it been since your last pull?
15:10:05 <kpreid> SamB: month(s)
15:10:06 <Cale> xerox: as in you can imagine a function e -> a as a gigantic array which has a value of type a for every value of type e
15:10:09 <desrt> haskell has got to be the only programming language on earth that you need a phd in theoretical mathematics to understand
15:10:22 <Cale> @quote Cale
15:10:22 <lambdabot>  Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
15:10:28 <Cale> oh well :)
15:10:33 <dons> common misconception, desrt :) you don't need a phd in math.
15:10:36 <SamB> desrt: *I* don't have a phd in theoretical mathematics
15:10:36 <kpreid> desrt: I dispute that.
15:10:38 <xerox> Cale, but in fact you use one ((->) e) at time
15:10:39 <Philippa> desrt: I don't even have a BSc
15:10:39 <Cale> I was sort of hoping for the Diamond quote
15:10:40 <dons> does _anyone_ in this channel have a phd in math?
15:10:42 <SamB> I don't even have an associates degree
15:10:45 <Philippa> (in anything)
15:10:55 <Cale> I don't
15:10:57 <Philippa> SamB: or that, though I think I could walk with the UK equivalent
15:10:59 <SamB> (which is a two-year thing)
15:11:04 <desrt> i don't think anyone in this channel fully understands haskell, either :)
15:11:06 <Cale> I only have a bachelor's degree in pure math
15:11:09 <dons> desrt: heh
15:11:17 <Cale> I get by :)
15:11:24 <desrt> that's like claiming you know all the commands in vim
15:11:27 <desrt> or all the key combinations in emacs
15:11:41 <kpreid> dons: I don't know how to use ghc-pkg, but 'ghc-pkg list' outputs "plugins-1.0" without parentheses around it
15:11:42 <SamB> desrt: you never said anything about the undestanding being quite complete!
15:11:47 <dons> we have a few phds in prog.lang theory, which is a few more than most language communities
15:11:55 <Cale> hehe
15:11:56 <desrt> SamB; fair enough.  i had intended it.
15:12:02 <SamB> kpreid: that *is* how to use ghc-pkg
15:12:04 <Cale> What does GvR have?
15:12:06 * desrt understands that 1+1=2 but that isn't a complete understanding :)
15:12:17 <dons> Cale: a chip on his shoulder?
15:12:18 <SamB> > let 1+1 = 3 in 1+1
15:12:19 <lambdabot>  3
15:12:20 <Philippa> Cale: a title he issued himself?
15:12:22 <Cale> dons: haha
15:12:30 <SamB> hah
15:12:39 <desrt> SamB; you actually bound the "+" sign there
15:12:44 <kpreid> SamB: er, let me rephrase that: all I know about it I learned by running it with no arguments, and that doesn't include what the parentheses mean
15:12:46 <desrt> SamB; no ones were harmed in the creation of this let
15:12:47 <SamB> desrt: I know that, yes ;-)
15:13:05 <Philippa> +s, however...
15:13:09 <desrt> + got raped
15:13:10 <SamB> I wonder what happnes if I evilly replace "2" with "3" in Python...
15:13:12 <Cale> @remember dons [When asked what qualifications Guido van Rossum has...] a chip on his shoulder?
15:13:50 <desrt> mercury takes a really long time to compile
15:13:53 <desrt> time to learn scala, i think
15:14:12 <dons> desrt: can you just check for me, is mercury implemented in haskell?
15:14:52 <Cale> desrt: but definitely look into the reader and writer monads -- each one is like half of the state monad, and you'll probably understand monads a bunch better after seeing those two :)
15:15:10 <desrt> dons; it's in C
15:15:16 <Cale> eek
15:15:24 <desrt> ghc is in C too
15:15:25 <desrt> so, ...
15:15:27 <Cale> I suppose hugs is written in C
15:15:33 <dons> desrt: the compiler isn't in C.
15:15:42 <desrt> ok.  mercury is similar to an old ghc
15:15:47 <desrt> a lot of it is written in itself
15:15:49 <desrt> but it backends to .c
15:15:55 <kpreid> dons: so I conclude that plugins *is* visible; now what?
15:15:55 <xerox> desrt: anyway, if you smooch together Reader and Writer (not at language level), you get Monad (s -> (a,s)) a.k.a. State Monad.
15:15:57 <desrt> and the entire thing is really really slow
15:16:11 <desrt> is the writer monad the one that gives you the result of the most recent write?
15:16:23 <dons> kpreid: hmm. try cleaning out and rebuilding
15:16:25 <kpreid> no, it appends all of them
15:16:28 <dons> check that configure finds it
15:16:30 <Cale> xerox: yeah, you have to tie them together nicely though :)
15:16:31 <kpreid> that's why the output has to be a Monoid
15:16:37 <desrt> odd.
15:16:46 <desrt> so it's not quite like state, then
15:17:03 <Philippa> it's less useful if you can't do something cumulative with the history
15:17:03 <kpreid> dons: how do I do that? ./Setup.hs clean?
15:17:09 <xerox> desrt: it is nice because the "log" is abstracted out as a monoid.  So you just need a unit and a closed binary operation on the type.
15:17:24 <Cale> desrt: well, you can't quite read what's been written even
15:17:39 <Cale> desrt: at least, without creating a new deeper context
15:17:50 <Cale> there's an operation  listen :: m a -> m (a,w)
15:17:52 <xerox> desrt: that makes list monoids with [] and (++).  Or endofunctions too, (a -> a), with id and (.).
15:18:08 <Cale> which catches what something in particular writes, but no get
15:18:10 <desrt> i don't want to think about math anymore.  i have a headache :(
15:18:23 * kpreid just tries it
15:18:29 <xerox> Sorry, it's just the way it is.
15:19:05 <xerox> A value of type Writer [String] () is a computation that returns (), and logs a list of strings.
15:19:24 <xerox> (The type is isomorphic to ((),[String]).)
15:19:27 <Cale> > (Product 5) `mappend` (Product 10)
15:19:28 <lambdabot>  Not in scope: data constructor `Product'
15:19:30 <Cale> aww
15:19:36 <xerox> Uh?
15:19:47 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html
15:19:49 <lambdabot> http://tinyurl.com/szdxl
15:19:53 <Cale> I suppose it's a 6.6ism
15:20:03 <kpreid> it is
15:20:16 <kpreid> all the newtypes in Data.Monoid are new
15:20:17 <xerox> Yeah, that's what /latest/ stand for ;)
15:21:09 <dons> i have the following email in my inbox, any suggestions?  :
15:21:10 <dons> what book/ressource would you recommend to a person from industry who would
15:21:12 <dons> like to learn Haskell?
15:21:28 <xerox> What about #haskell ?
15:21:30 <SamB> detox!
15:21:34 <SamB> they need detox!
15:21:36 <monochrom> Practical OCaml
15:22:01 <xerox> He could just ask here as you are doing.  I usually tell people to come here.
15:22:10 <dons> monochrom: you haven't actually read the book though, have you monochrom ? ;)
15:22:11 <monochrom> I guess it depends on the meaning of "from industry".
15:22:14 <kpreid> > ((+1) `mappend` (*2)) 2
15:22:15 <monochrom> No.
15:22:15 <lambdabot>  5
15:22:27 <SamB> you shouldn't suggest books you haven't read!
15:22:40 <kpreid> that won't work in 6.6!
15:22:43 <SamB> people might spend good money on them and find out they aren't as good as you thought!
15:22:49 <JKnecht> .oO(think that's how I got here)
15:22:49 <xerox> kpreid: argh!!
15:22:54 <lispy> dons: there is a haskell tutorial on the wiki for people with C/Java/Python background
15:23:09 <kpreid> xerox: I assume to avoid overlapping instances. 6.6 uses the newtype Endo
15:23:10 <SamB> kpreid: it is sad :-(
15:23:12 <dons> yeah, but has anyone actually used that to learn?
15:23:27 <lispy> dons: hang on, i'll ask my python friend
15:23:31 <SamB> kpreid: not only overlapping, but also humanly incoherent
15:23:33 <dons> We need a collection of resources for good programmers from other languages
15:23:37 <dons> separate from the intro material
15:24:12 <monochrom> See, that's the problem.  "from industry" may mean good programmers or may mean bad programmers.
15:24:20 <dons> in this case, good.
15:24:33 <monochrom> Do we have a collection of tutorials for bad programmers?
15:24:43 <SamB> well, self-proclaimed bad programmers can be helped ;-)
15:25:07 <SamB> you just send them to the "new user" tutorials
15:25:08 <SamB> or whatever
15:25:08 <ptolomy> by-the-by, anyone know off-hand what the code that Stefan Holderman posted on his blog does? (I'm too lazy to check, and "***" scares me)
15:25:28 <lispy> dons: i guess he found it, but didn't read it
15:25:31 <xerox> ptolomy: (f *** g) (x,y) = (f x, g y)
15:25:42 <Cale> wtf? A link to a blank paste form at nopaste is on reddit.
15:25:53 <SamB> hah
15:26:01 <lispy> clever
15:26:01 <SamB> practical joke?
15:26:07 <lispy> Cale: paste some haskell goodnesS!
15:26:11 <monochrom> The problem is that bad programmers will assess tutorials for good programmers as "ivory tower", and moreover bad programmers are the vocal majority.  It gets you bad press.
15:26:37 <kpreid> ptolomy: arrow combinators are often useful on plain functions (but that code was awful)
15:26:49 <Cale> we should complain to rafb.net to get Haskell syntax highlighting
15:26:59 <lispy> hand them geshi
15:27:12 <monochrom> hmm what is geshi?
15:27:14 <metaperl> hey, my homegrown average function is giving me an odd type error: http://paste.lisp.org/display/29187#1
15:27:15 <dons> insightful, monochrom. i agree.
15:27:23 <SamB> bad programmers who *think* they are good programmers should see no ivory tower!
15:27:31 <lispy> monochrom: it's the php library that haskellwiki is uisng to do coloring
15:27:34 <Cale> metaperl: you need a fromIntegral
15:27:41 <Cale> length returns an Int
15:27:42 <SamB> and those who *know* they are bad programmers should be smart enough to start with the introductory material!
15:27:46 <monochrom> Ah! No wonder geshi sounds familiar.
15:27:47 <Cale> and you can't use / on Ints
15:27:56 <kpreid> metaperl: that was my mistake
15:28:10 <monochrom> @remember monochrom The problem is that bad programmers will assess tutorials for good programmers as "ivory tower", and moreover bad programmers are the vocal majority.  It gets you bad press.
15:28:12 <metaperl> kpreid: yes, but thanks for helping me along
15:28:16 <kpreid> metaperl: use genericLength or fromIntegral . length.
15:28:27 <kpreid> metaperl: the latter is faster but incorrect for Really Long Lists.
15:28:49 <lispy> personally, i'm not sure i can write good code in most languages
15:29:00 <mathewm> flip (.) = (>>=)  ???
15:29:20 <xerox> flip (.) = (>>>)
15:29:22 <lispy> take VBA for example, how do i do testing?  how do a manage control flow?  How do I create datastructures?  I dunno...i can't figure the damned thing out...
15:29:30 <mathewm> :(
15:30:00 <kpreid> but (>>>) is almost (>>=) except for a newtype...
15:30:36 <mathewm> what newtype?
15:30:41 <kpreid> Kleisli
15:31:24 <metaperl> kpreid: genericLength is not loaded into ghci by default...
15:31:36 <mathewm> is this right?:    (>>=) :: (Monad m) => (r -> a) -> (a -> r2 -> b) -> ( r3 -> b )
15:31:53 <mathewm> well, scratch the context
15:32:32 <mathewm> I am trying to wrap my head around    instance Monad (->) r
15:33:20 <Cale> all the r's are the same
15:33:25 <SamB> hmm.
15:33:29 <kpreid> metaperl: import List or Data.List
15:33:34 <metaperl> oh ok
15:33:56 <Cale> (>>=) :: (r -> a) -> (a -> (r -> b)) -> (r -> b)
15:34:06 <mathewm> how are all the r's unified?
15:34:11 <Cale> (>>=) :: (r -> a) -> (a -> r -> b) -> r -> b
15:34:18 <mathewm> because it is the same Monad?
15:34:20 <Cale> right
15:34:30 <Cale> For each r, (->) r is a monad.
15:34:35 * mathewm scratches his chin.
15:34:55 <Cale> one interesting thing is to look at fmap here :)
15:35:14 <SamB> @type (>>=)
15:35:16 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
15:35:28 <Cale> fmap :: (Functor f) => (a -> b) -> f a -> f b
15:35:40 <Cale> fmap :: (a -> b) -> (r -> a) -> (r -> b)
15:35:51 <Cale> So fmap = (.)
15:35:59 <mathewm> hmmm
15:36:00 <Cale> also, join
15:36:05 <Cale> @type join
15:36:07 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
15:36:17 <Cale> (r -> (r -> a)) -> (r -> a)
15:36:31 <Cale> join f x = f x x
15:36:33 <xerox> mattam: flip (.) = (. (return .)) . (>>=) -- at best
15:37:08 <xerox> (If you want to express it in terms of (>>=).)
15:37:17 <Cale> xerox: you're overly comfortable with sections of composition :)
15:37:24 <SamB> dons: hmm. it says it couldn't load bf, drhylo, or ft!
15:37:25 <xerox> I love that stuff.
15:38:17 * Cale mods down everything on programming.reddit.com which has anything to do with the industry.
15:38:53 <Cale> hehe, I only want entirely impractical articles about programming!
15:39:44 <Cale> What's with all this junk about ASP.NET? Why would I care about that? :)
15:39:49 <lisppaste2> metaperl annotated #29187 with "confused on output type of a summing function" at http://paste.lisp.org/display/29187#2
15:40:13 <metaperl> I think my output type should Int or Integer not (Ord t) t
15:41:40 <Cale> You can give it the type [Integer] -> Integer -> Integer
15:41:47 <Cale> it just gave it a more general type
15:42:04 <Cale> Ints and Integers are both in the Ord and Num typeclasses
15:42:31 <Cale> and that's the minimal set of functionality you need to get that function to run, because it adds and compares with >
15:42:46 <Cale> @type 0
15:42:47 <lambdabot> forall t. (Num t) => t
15:43:05 <Cale> @type let f x = 0 < x in f
15:43:06 <lambdabot> forall a. (Ord a, Num a) => a -> Bool
15:43:18 <lispy> If every thing looks like a nail to you, then I bet the only tool you deem worthy of owning is a hammer.
15:44:18 <lispy> i think that's an important corollary to "If you have a hammer, everything looks like a nail"
15:44:26 <metaperl> Cale: thanks. I see
15:44:56 <monochrom> Everything looks like a value to me.  I just want to apply functions to them.
15:44:57 <yaxu> lispy: and i bet the only thing you can find is a screwdriver
15:45:29 * xerox steals monochrom's CT book
15:45:43 <monochrom> I don't have a CT book.
15:46:08 <yaxu> not any more
15:46:31 <monochrom> The great thing about me is that I don't read any book, and I don't read any web tutorial.  I don't know where I learned everything.
15:46:33 <xerox> Then you should take one!  It is about those objects things and morphisms between them.
15:46:47 <monochrom> I know CT but I don't have a book.
15:48:07 <monochrom> I guess I learned everything from the papers of Bird and Wadler.  I downloaded and read them.
15:48:26 <audreyt> dons: ooh, I'll see you in PADL, I just discovered that :)
15:48:36 <dons> hey, great!
15:48:40 <audreyt> dons: come to my POPL opening keynote as well :)
15:48:56 <dons> opening keynote at POPL?!
15:49:04 <audreyt> yes, on Pugs.
15:49:07 <monochrom> Then someone comes along and asks where can they learn the same thing.  I point them to the papers.  They say "noooo they're too academic, I'm from industry, do you know of a tutorial?"
15:49:13 <dons> audreyt++ wow!
15:49:24 <dons> audreyt: yep, i'll be there.
15:49:24 <psnl> audreyt: class
15:49:36 <desrt> woosh
15:50:06 <monochrom> Well frankly I don't know of too many tutorials, and the few I have looked at, I don't like them.  They're "too industry".
15:50:29 <lispy> i think it helps to have both a tutorial and a more 'academic' version
15:50:35 <lispy> get it from two different angles
15:52:26 * desrt does some carpet-dragging
15:53:27 <kpreid> dons: I did the clean and build and got the same error (Could not find module `System.Eval.Haskell')
15:53:57 <SamB> kpreid: I would suggest maybe updating hs-plugins?
15:54:11 <kpreid> ah
15:54:28 <monochrom> By "too industry" I mean this.  You know how some academic papers use toy problems as examples, i.e., "here is a problem (which is very easy to solve or no one cares), here is how elegantly you can solve it using our approach."  Well, that's a fair criticism.  However, on the flip side, ...
15:55:13 <EvilRanter> "here is a magneto-hydrodynamics problem. let's put the round peg that is haskell into this excruciatingly square hole"
15:55:51 <kpreid> SamB: it claims to be "1.0" and I don't see a later-sounding version at http://www.cse.unsw.edu.au/~dons/hs-plugins/
15:55:52 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules
15:55:56 <monochrom> The industry tutorials use toy solutions.  That is, "here is a problem (which is very hard and is crucial to business success), here is code to solve it, the idea is linear search..."
15:56:00 <SamB> isn't the expression "trying to fit a square peg into a round hole"?
15:56:17 <SamB> hah
15:56:29 <lispy> SamB: right, but that doesn't type check
15:56:38 <lispy> SamB: so you have to rephrase it for haskell :)
15:56:53 <SamB> maybe Haskell is the hole
15:56:55 <EvilRanter> samB, yeah, but haskell is so much nicer than MHDics
15:56:59 <monochrom> Use a square monad.
15:57:04 <SamB> hah
15:57:11 <EvilRanter> so haskell is round, MHDics is square...
15:57:30 <EvilRanter> meh. the analogy works for me.
16:02:09 <ral1> EvilRanter: I think that appllying haskell to MHDics sounds awesome.
16:02:34 <SamB> dons: anything I should test before sending you a patch?
16:02:39 <SamB> I mean, besides that it runs?
16:03:03 <SamB> it can't YOW properly!
16:03:10 <EvilRanter> ral1, I know very little about MHDics, other than that it's very complicated continuous maths, so I'm not qualified to have an opinion, TBH
16:03:27 <EvilRanter> I imagine it involves painful differential equations
16:05:26 <dons> check that it works. you need to convince me.
16:05:34 <dons> and check offline and online mode
16:05:45 <dons> also, better check dynamic reload/unload works
16:05:50 <kpreid> SamB/dons: help?
16:07:10 <ral1> EvilRanter: Oh.
16:07:47 <dons> kpreid: have you tried rebuilding plugins?
16:07:47 <_SamB_bot> dons: You have 1 new message. '/msg _SamB_bot @messages' to read it.
16:07:49 <SamB> @bot
16:07:49 <_SamB_bot> :)
16:07:49 <lambdabot> :)
16:08:01 <ral1> EvilRanter: I just thought it would be sweet because you could have the best of both worlds: fluids and electrictro-magnetism.  I guess trying to write out equations for all that might suck, but the experiments are sweet.
16:08:12 <dons> good. but you might want to test it in a different test channel
16:08:16 <SamB> oh.
16:08:20 <dons> SamB: since you'll need to exercise it fairly well
16:08:28 <dons> (the unload/reload stuff)
16:08:51 <SamB> dons: I didn't really change that code though.
16:08:54 <EvilRanter> ra1, sorry. :P  my main knowledge of it comes from a maths lecturer acquaintance of mine who, when asked "wanna teach MHD next year?" replied "sounds interesting... okay, i'll read up on it over vac!"
16:08:58 <SamB> so if it is broken I can blame you.
16:09:52 <EvilRanter> ral1, but i agree, the experiments i know of sound like fun
16:14:14 <dons> SamB: sure. but I at least need to know if it works.
16:14:26 <dons> it's about convincing me that it is safe to apply your patch.
16:14:52 <dons> and for something as critical as this, i need a lot of convincing :)
16:15:13 <SamB> how about you look at it?
16:15:31 <SamB> basically all I did was mess with the Cabal and restructure the Main stuff...
16:15:45 <dons> does dynamic-unload work?
16:15:56 <dons> or dynamic-reload?
16:15:56 <SamB> and pass the list of plugin names around in the monad, instead of reading it from Modules
16:16:12 <SamB> they seem to!
16:16:27 <SamB> now I'm just making sure none of these modules are important
16:16:50 <dons> if you think its solid, then send it. if it still needs improvement, then wait, and send it later.
16:17:15 <SamB> I think its solid unless I somehow missed out on a module that should be "static"
16:17:56 <mathewm> why do you need to import Control.Monad.Instances?
16:18:44 <dons> to get the instances?
16:19:25 <mathewm> I was wondering why they are not implicit
16:19:45 <xerox> Do you know what is regex-compat
16:19:56 <SamB> you would also like for the compiler to Google for instance declarations?
16:20:12 <xerox> GHC building is failing out on that: unknown-package: regex-compat
16:20:13 <mathewm> sure
16:20:17 <SamB> hahahaha
16:20:24 <mathewm> :)
16:20:38 <Igloo> xerox: What are you trying to do?
16:20:40 <xerox> SamB did you see that tool from the HAppS author
16:20:45 <xerox> Igloo: building GHC
16:20:52 <Igloo> xerox: What version, and with what version?
16:20:52 <mathewm> lists are monads, without importing anything, right?
16:20:58 <SamB> dons: I seem to have unloaded everything unloadable and it still seems to work in offline mode...
16:20:58 <Cale> yes
16:21:05 <Cale> That instance is in the Prelude
16:21:10 <mathewm> ok
16:21:12 <monochrom> imported from the Prelude
16:21:13 <Cale> The ((->) e) instance really should be in the Prelude as well, I think
16:21:16 <mathewm> so (->) r
16:21:20 <mathewm> isn't in the prelude...
16:21:32 <xerox> Igloo: I have got the latest darcs, right now, and I am using 6.5.20060608 to build it, on OS X Intel
16:21:39 <Cale> If it was, I'd support renaming fmap to (.) :)
16:21:41 <mathewm> is there a reason it wouldn't be in a Prelude'?
16:21:46 <xerox> Cale, me too!
16:21:50 <Cale> It wasn't in the Haskell 98 prelude
16:21:58 <Igloo> xerox: Building darcs versions with another darcs version isn't supported
16:22:07 <Cale> People didn't realise how valuable it could be
16:22:17 <xerox> Igloo: AH. What could I do?
16:22:37 <Igloo> xerox: The easiest thing would be to get a binary 6.6 from the download page
16:22:53 <Cale> It sure would make some things look rather different to use (.) in place of map
16:22:57 <xerox> Igloo: that sounds good, mind to link me?
16:23:10 <Cale> But I think we'd probably get used to it.
16:23:13 <dcoutts> dons, so my supervisor says I should definitely work on another stream fusion paper and come to .au next year. :-) He and I will talk about it in more detail tomorrow.
16:23:14 <Igloo> http://www.haskell.org/ghc/download_ghc_66.html
16:23:17 <lambdabot> Title: GHC: Download version 6.6, http://tinyurl.com/ybqjsb
16:23:30 <SamB> dons: I sent you the patch
16:23:41 <SamB> I hope I didn't leave out any files or anthing stupid like that
16:23:42 <monochrom> f . [1,2,3] = [f 1, f 2, f 3]
16:23:43 <xerox> dcoutts yay!!
16:23:48 <dcoutts> @yarr!
16:23:49 <lambdabot> Get out o' me way, yeh landlubber
16:23:57 <dons> ok, thanks SamB
16:24:01 <dons> dcoutts: great!
16:24:17 <Cale> f . (Just 5) = Just (f 5)
16:24:22 <dons> SamB: i always check my patch applies and works in a separate tree.
16:24:28 <dons> its a good idea if you're making big changes or adding files
16:24:34 <EvilRanter> Cale, f . Nothing = Nothing?
16:24:34 <SamB> yeah, I was hoping you did
16:24:38 <Cale> EvilRanter: yeah
16:24:41 <xerox> Cool.
16:24:46 <SamB> because otherwise I'd have to wait, what, a week for you to test it?
16:24:48 <Cale> EvilRanter: that's how it *would* look :)
16:24:54 <EvilRanter> that's somewhat not Haskell
16:25:00 <EvilRanter> shurely
16:25:13 <Cale> That's Haskell with a slightly different Prelude :)
16:25:24 <EvilRanter> er
16:25:25 <monochrom> I will totally refuse explaining to newbies why f . [1,2,3] = [f 1, f 2, f 3].
16:25:32 <Igloo> SamB: I think he was hinting that you might want to do the same
16:25:32 <dolio> If only it were.
16:25:33 <xerox> That's nice though
16:25:35 <Cale> monochrom: oh?
16:25:42 <SamB> Igloo: oh, point
16:25:47 <monochrom> I understand it.  It's too hard to explain.
16:26:06 <Cale> monochrom: I don't think it's all *that* bad. I think it would be harder to explain why (.) is composition at that point.
16:26:13 <SamB> Igloo: he did say "my"
16:26:40 <Igloo> SamB: Right, so he clearly wasn't saying that he would test /your/ patch in that way
16:26:52 <SamB> Igloo: no, I'm agreeing with you
16:26:59 <SamB> sorry for the confusion
16:27:04 <Igloo> Heh, OK  :-)
16:27:59 <mathewm> another silly proposition:  liftM = (.) ?
16:28:00 <Cale> I mean, you can just say that (.) is a function which applies a function to every element of various types of datastructure. One of these types of datastructure is functions from some type r. So it takes a function (a -> b) and a function (r -> a) and gives a function (r -> b), which is just composition.
16:28:06 <Cale> mathewm: it would be
16:28:17 <xerox> Igloo: and then I can't build darcs with the 6.6 binary from the download page, can I?
16:28:32 <Cale> {(.), map, fmap, liftA, liftM} would all be the same
16:28:37 <xerox> (I mean the darcs version)
16:28:43 <mathewm> Cale: :) thanks
16:29:13 <monochrom> You know, the natural numbers are very nice.
16:29:15 <Igloo> xerox: Why not?
16:29:19 <Cale> I think it's actually somewhat of a good idea, because it gets people thinking about things in a new way.
16:29:38 <xerox> Igloo: I see what you meant before now
16:29:47 <Cale> When you can see that lots of the things around you are really the same thing, that's a minor form of enlightenment :)
16:29:58 <monochrom> After you have understood something about the natural numbers, you say, gee, it can be generalized to transfinite ordinals.  And things are even nicer.
16:30:51 <Cale> at least, sometimes :)
16:31:21 <monochrom> Things are so nice that the natural numbers are just a special case of transfinite ordinals.  So, you go back to the kindergarten curriculum and say, let's revise it so it teaches transfinite ordinals, and then during highschool we can show them how to specialize to the natural numbers.
16:31:34 <Botty> lol
16:31:34 <Cale> hehe
16:31:45 <Cale> You know, we almost could.
16:31:49 <monochrom> THE SAME THING IS HAPPENING TO HASKELL.
16:32:05 <Cale> I don't consider it much of a problem :)
16:32:12 <Baughn> Ah yes. That would be similar to me learning algebra instead of arithmetic in primary school, then?
16:32:18 <Cale> Remember, avoid popularity at all costs.
16:32:28 <monochrom> The same thing had been done before.  It was called New Math.  It failed.
16:32:40 <Cale> They didn't teach ordinals in new math.
16:33:07 <Cale> In fact, they did a somewhat poor job of teaching the "advanced" subjects they did.
16:33:12 <monochrom> Right.  They just did set theory.  If they added or replaced with ordinals, it would fail quicker.
16:33:19 <Pseudonym> I'm not sure about transfinite ordinals.
16:33:21 <Pseudonym> I don'
16:33:27 <Pseudonym> I don't think you can understand them without induction
16:33:36 <SamB> set theory actually makes reasonably good sense to youngsters, though
16:33:45 <monochrom> I don't think you can understand ordinals without natural numbers.
16:33:53 <Pseudonym> Kids do understand the difference between ordinals and cardinals.l
16:33:56 <Cale> Have you ever tried teaching things like that to kids?
16:34:02 <SamB> especially if you have "the set of green objects" or "the set of objects you aren't allowed to eat before dinner"
16:34:03 <Cale> They pick things up really quickly
16:34:04 <Baughn> "3 is defined as 1 + 1+ 1
16:34:05 <Pseudonym> They have a gut feeling about the difference between "one, two, three" and "first, second, third".
16:34:07 <Cale> It's quite amazing
16:34:18 <Baughn> "3 is defined as 1 + 1 + 1" is /not/ the thing to tell a first-grader
16:34:24 <Bobstopper> What's this "fairbairn threshold"?
16:34:28 <monochrom> Similarly, I don't think you can understand (.) as the functor map before you understand (.) as function composition, map as list functor map, ...
16:34:53 <Cale> Well, explain those as separate functions with the same syntax
16:35:12 <Pseudonym> I have enough difficulty explaining that addition is commutative.
16:35:16 <Cale> hehe
16:35:36 <xerox> Yeah, hopefully in future the barriers will lower for everything... ?
16:35:46 <Cale> I think that part of the problem is that we're *so* scared to provide proper definitions.
16:35:48 <Baughn> Pseudonym: Children getting born without mathematical intuition now?
16:36:05 <Cale> and logic just isn't taught anymore
16:36:07 <jgrimes_> I think we should just start kids out by using algebras to explain the various topics
16:36:22 <Cale> algebras in which sense?
16:37:00 <jgrimes_> abelian groups, rings, etc.
16:37:11 <Baughn> jgrimes_: Nonono. They tried that - on me - it didn't work.
16:37:20 <Pseudonym> Baughn: I think my daughter just happens to be more into language.
16:37:27 <Pseudonym> She asked me the other day what "sardonic" means.
16:37:28 <Pseudonym> She's FOUR.
16:37:33 <Cale> hehe
16:37:43 <xerox> Wow.
16:37:43 <monochrom> wait til she asks what liftM means
16:37:46 <Cale> I could read fairly well by then :)
16:37:49 <Baughn> Pseudonym: Worry when she starts understanding the answer
16:37:54 <Pseudonym> :-)
16:38:01 <Pseudonym> She hasn't quite grasped metaphor.
16:38:16 <Pseudonym> She was listening to a song, and pointed out, quite correctly, "That man can't really touch the sky."
16:38:58 <Baughn> Understanding that the sky isn't touchable even in principle is interesting by itself, though
16:39:06 <Pseudonym> Yes.
16:39:29 <Pseudonym> She now undersand that "the sky" doesn't really exist as something "up there".
16:39:55 * Baughn applauds. Humanity in general missed that one for thousands of years.
16:39:56 <Cale> I remember complaining to my grandmother that heaven couldn't really be in the clouds because clouds are made of water vapour and would never support anything. I asked whether heaven was on another planet. :)
16:40:06 * Pseudonym hasn't explained Rayleigh scattering yet, though
16:40:27 <Smokey`> lol Pseudonym :)
16:40:30 <Smokey`> Bright daughter :)
16:40:32 <Baughn> Pseudonym: Try rainbows after that - and /not/ that cop-out lens experiment
16:40:35 <Pseudonym> Though she worked out all by herself the correct answer to "why is the sky blue".
16:40:43 <Pseudonym> Her answer: "It isn't, always."
16:41:00 <Cale> :)
16:41:17 <Cale> "Does the sun go around the Earth, or is it the other way around?"
16:41:17 <monochrom> She will be a fine logician.
16:41:22 <Pseudonym> She will be, yes.
16:41:31 <monochrom> or lawyer
16:41:32 <xerox> The density of ":)" has raised as we started talking of tiny humans :)
16:41:34 <mathewm> head [] really stinks
16:41:37 <Jedi_Amara> That's cute :)
16:41:48 <jgrimes_> xerox: nice observation :)
16:41:53 <Baughn> ..meanwhile, my nieces have a fine grasp of mobile phone typism and..  japanese. Odd.
16:42:30 <Jedi_Amara> My cousins have fun reading French.
16:42:36 <Cale> I think it's important to treat children as people. There's too many parents who will only give their kid baby talk for far too long.
16:42:37 <kpreid> mathewm: listToMaybe!
16:43:00 <kpreid> hm
16:43:12 <monochrom> I treat children as people.  If they say to me "good morning", I say to them "good morning".
16:43:17 <Smokey`> Cale: I couldn't agree more :)
16:43:19 <Bobstopper> Cale: I agree
16:43:22 <jgrimes_> Cale, very true.
16:43:27 <monochrom> You'll be surprised how I'm actually the minority.
16:43:36 <chessguy> this is great. we just got our first notes on "application domains for functional programming"
16:43:42 <xerox> Goodnight.
16:43:50 <Jedi_Amara> I talk to babies normally. People react in strange ways.
16:43:54 <jgrimes_> night :)
16:44:02 <chessguy> 1.) prototyping. 2.) AI research (symbolic computation and list processing). 3.) parallel programming
16:44:02 <Pseudonym> Night.
16:44:24 <mathewm> import Prelude hiding (head,tail,init,last)
16:44:28 <Pseudonym> Don't knock #3.
16:44:29 <Baughn> People react the way they feel they're expected to behave. I wonder if the baby-talk is as prevalent in other cultures?
16:45:07 <Pseudonym> Baughn, I think it's instinctive.  People talk to babies in a manner half-way between how they babble and how adults talk.
16:45:47 <jgrimes_> I haven't see a large amount of AI research in haskell, which, I would like to see.
16:45:51 <jgrimes_> seen, even.
16:46:07 <chessguy> jgrimes, just wait until i finish my GP framework in haskell
16:46:19 <Bobstopper> Robert De Niro's character in "Meet the Fockers" was somewhat ridiculed in the movie for treating babies like people.
16:46:28 <Baughn> Pseudonym: There's probably some benefit to that, but.. they keep it up too long, which at the very least can lead to speech deficiencies. (see anecdote)
16:46:49 <jgrimes_> chessguy: when are you planning a release? that would be very interesting. :)
16:47:02 <chessguy> about 2037
16:47:19 <jgrimes_> :p
16:47:36 <chessguy> i'm having a hard time finding time to work for it
16:47:51 <dcoutts> anyone know how to make a blank line with Text.PrettyPrint.HughesPJ ? I can make a line with spaces in, but I'd rather not.
16:48:02 <chessguy> even though haskell makes it easy
16:48:10 <jgrimes_> chessguy: what GP frameworks are you modeling it after? (if any..)
16:48:13 <Pseudonym> Baughn, yes, I agree.
16:48:21 <Igloo> dcoutts: text ""?
16:48:29 <Pseudonym> Oddly enough, I didn't have this problem with either child.
16:48:32 <dcoutts> Igloo, hmm, yeah I guess.
16:48:33 <chessguy> the one described in Koza's book, i suppose
16:48:36 <Cale> I could speak fairly normally by the time I was 18 months, mostly because one of the first words I learned was "this", and I would get my parents to carry me around and I'd point at things asking what they were called.
16:48:36 <Pseudonym> The elder one is autistic, and didn't really talk anyway.
16:48:41 <chessguy> not the code there, but the idea
16:48:49 <Pseudonym> The younger was reading full sentences by her third birthday.
16:49:13 <Jedi_Amara> Cale: That's awfully cute :)
16:49:19 <chessguy> i was reading hardy boy books by the time i was about 5 or 6
16:49:21 <kpreid> SamB/dons: I've rebuilt hs-plugins and have the same result
16:49:22 * dcoutts wonders why if (<+>) means (<>) with a space, ($+$) doesn't mean ($$) with a space.
16:49:35 <Pseudonym> My first word was, apparently, "microphone".
16:49:42 <Cale> Mine was "logo"
16:49:49 <Cale> I would point out company logos :)
16:49:53 <Pseudonym> Cale: Into programming languages even then, eh?
16:50:05 <chessguy> mine was "haskell"
16:50:08 <chessguy> ok, maybe not
16:50:09 <Cale> in the graphic design sense :)
16:50:18 <Jedi_Amara> I have no idea what mine was - I should ask my parents
16:50:20 <Baughn> Any normal people in here? What happened to "mom" or "dad"?
16:50:24 <chessguy> lol
16:50:34 <chessguy> normal people? in a haskell channel?
16:50:53 <Pseudonym> It's interesting that almost every language in the world has its word for "mother" beginning with an "m" sound.
16:51:04 <Smokey`> hehe, my first word was 'light' :)
16:51:06 <Baughn> At the very least lambdabot is normal, yes?
16:51:08 <Pseudonym> The exceptions are almost all "artificial" languages like Bahasa Indonesia.
16:51:20 <Pseudonym> Or Esperanto.
16:51:27 <dcoutts> Baughn, I'm British, I don't say 'mom', I say 'mum'.
16:51:29 <Cale> Pseudonym: also, the words for yes and no are pretty similar, except for Japanese, where they're kind of reversed.
16:51:36 <Baughn> dcoutts: Mum's the word?
16:51:40 <dcoutts> quite
16:51:50 <Pseudonym> Cale: I think that comes fro proto-Indo-European, though.
16:52:03 <Pseudonym> Grimm's Law explains all that.
16:52:27 <Cale> probably. I'm not sure how much I believe in linguistics. There's a lot of retrofitted history there.
16:52:35 <Pseudonym> I don't see the connection between "yes" and "si".
16:52:50 <Pseudonym> It's probably there, though.
16:52:52 <Jedi_Amara> My first word was, apparently, "em"
16:53:15 <Jedi_Amara> which is, in Vietnamese, the way I would refer to myself when addressing an older sister/brother/person of same generation
16:53:33 <Jedi_Amara> so basically, my first word was self-referential... an egotist even then?
16:53:38 <Cale> hehe
16:54:02 <dons> ?where yaht
16:54:03 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
16:54:04 <xerox> Mine was "cotto", which means "ready to eat" (after cooking).
16:54:05 <Jedi_Amara> and my second word was "day nay" - "here". :)
16:54:12 * xerox heads back to bed
16:54:21 <Jedi_Amara> Oh, nice, xerox is ready to eat
16:54:44 <chessguy> ?localtime xerox
16:54:45 <lambdabot> Local time for xerox is Fri Nov  3 01:54:21 2006
16:54:47 <Pseudonym> I'll get the rosemary dressing.
16:54:59 <chessguy> a late-night snack before going to bed perhaps?
16:55:14 <ral1> Is anyone hanging out in the San Francisco Bay area?  I hear that there is a hackathon this weekend..
16:55:21 <Baughn> I give - my first word was, approximately, "mad". Or "dom". Or... how come all combinations of "mom" and "dad" come out like /that/? Is there some conspiracy in the english language?
16:55:23 <chessguy> hackathon?
16:55:33 <ral1> chessguy: That's what I heard.
16:55:43 <chessguy> what's a hackathon?
16:55:58 <ral1> chessguy: People are going to hang out with laptops and work on software.
16:56:03 <ral1> There will be a hottub.
16:56:13 <chessguy> heh. nice
16:56:19 <chessguy> for any particular group/project?
16:56:29 <Baughn> chessguy: It will be very expensive. People will travel from all over the globe to sit in the same room typing on laptops.
16:56:36 <Pseudonym> Laptop + hottub == disaster waiting to happen
16:56:37 <SamB> hanging out with laptops working on software in a hottub?
16:56:46 <Pseudonym> OTOH, it brings a new meaning to water-cooling.
16:56:59 <ral1> chessguy:  I don't know much details about the hackathon.  I'm trying to find out more.
16:57:08 <Pseudonym> You could save energy by pre-heating the hot tub off everyone's heatsinks.
16:57:10 <Baughn> That's been a common failure mode of water-cooling for /ages/
16:57:12 <ral1> Pseudonym: haha.
16:57:32 <SamB> or are you supposed to alternate the hottubbing and the laptopping?
16:57:46 <Baughn> Nah, just need to be careful
16:57:48 <Pseudonym> That's an expensive context switch.
16:58:03 <ral1> chessguy: For the record, I don't think that hot tubs are normal for hackathons.
16:58:14 <chessguy> i was guessing not :)
16:58:39 <chessguy> i see something about an event in september: http://hackage.haskell.org/trac/ghc/wiki/Hackathon
16:58:42 <lambdabot> Title: Hackathon - GHC - Trac, http://tinyurl.com/f5y5y
16:59:04 <chessguy> oh, and one in chicago next weekend
16:59:12 <chessguy> in perl
16:59:22 <ral1> general shoutout: I am in the bay area for a few days.  I love haskell.  If anyone wants to work on something with me or even just stand around for a half hour (over coffee perhaps) jabbing about how sweet haskell is, definitely let me know.
16:59:46 <monochrom> I don't want to be standing while coffeeing :)
17:01:10 <chessguy> Andrew Gove?
17:01:46 <SamB> dons: oh, huh, I broke normal compiling :-(
17:04:33 <chessguy> so anybody else think this list is somewhat incomplete? application domains for FP: 1.) prototyping. 2.) AI research (symbolic computation and list processing). 3.) parallel programming
17:04:43 <Pseudonym> Yes.
17:04:49 <Pseudonym> It's missing type hackery research.
17:04:58 <dcoutts> hmm, methinks that HaXml's parser is far too slow
17:05:09 <dcoutts> the lexer is quick but the parsing is very slow
17:05:14 <Igloo> What are you working on , Duncan?
17:05:25 <dcoutts> Igloo, it's the Gtk2Hs code generator
17:05:33 <Igloo> Aha
17:06:04 <dcoutts> it eats many large xml files, scans hundreds of existing .hs source files and then generates hundreds of .hs files
17:06:23 <Igloo> :-)
17:06:29 <dcoutts> most of the time is spent parsing things
17:07:17 <dcoutts> though most of the code is dealing with lots of trees and big maps, that bit is all quite quick
17:07:29 <dcoutts> oh and the regexes are sloooo
17:08:19 <dons> SamB: ah see. that's what I mean ...
17:08:38 <SamB> apparantly I messed up in BotPP :-(
17:08:42 <dons> double check , then double that again
17:08:53 <SamB> which is one of the least bad places to mess up, IMO
17:09:15 <Botty> chessguy - what about general programming?
17:09:16 <dons> yeah, BotPP is pretty easy to fix
17:09:36 <SamB> also it tends not to have particularly subtle failure modes
17:09:38 <dons> what about high-assurance software?
17:09:44 <SamB> either it worked or it didn't
17:09:51 <dons> that's where most of the money in FP (or Haskell) seems to be.
17:10:21 <dons> also, compiler and theorem prover construction, and domain specific languages
17:10:45 <chessguy> Botty, it's not my list
17:10:52 <chessguy> i'm quite annoyed with it myself
17:10:58 <Botty> ah
17:11:02 <chessguy> what do you mean by general programming though?
17:11:09 <dons> chessguy: blog it :) that'll make you popular with your lecturers
17:11:17 <chessguy> lol
17:11:26 <dons> people should blog more criticisms of poor courses, content and academics
17:11:29 <dons> keep them honest
17:11:35 <SamB> chessguy: of course the list is incomplete
17:11:46 <SamB> any list of application domains is either incomplete or depressing
17:11:50 <dons> now, who was it who was doing their FP course in Miranda and Gofer, just a few weeks ago?
17:11:50 <chessguy> it's not just incomplete
17:11:54 <chessguy> it's misleading
17:12:00 <dons> that's the kind of thing that should be exposed to the blog world
17:12:04 <dcoutts> indeed
17:12:15 <SamB> yes!
17:12:19 <SamB> how outdated!
17:12:30 <SamB> they should be using... um... nhc98 and clean or something
17:12:59 <monochrom> @remember SamB any list of application domains is either incomplete or depressing
17:13:13 * dcoutts is teaching his FP practical next week with GHC, Gtk2Hs and HOpenGL
17:13:18 <dons> http://julipedia.blogspot.com/2006/06/functional-programming-and-haskell.html
17:13:21 <lambdabot> http://tinyurl.com/uub3m
17:13:22 <dons> that's it.
17:13:44 <chessguy> i'm so sick of this stupid "principles of programming languages" class. it's basically "how c and c++ are implemented"
17:13:56 <SamB> i.e., a language with a finite number of application domains is depressingly limited
17:14:14 <monochrom> Oh a finite list!
17:14:19 <dons> oh, they could choose between Miranda and Haskell, but if they chose haskell they didn't get support from the course notes
17:14:34 <SamB> monochrom: well, if you try to make an infinite bullet list, you run out of ammo ;-)
17:14:35 <monochrom> haha support from course notes
17:14:45 <SamB> hah
17:14:52 <SamB> compilers are more important than notes
17:14:57 <dons> heh
17:15:15 <monochrom> "Hello course notes, I am unable to install Miranda..."
17:15:25 <dons> but using Miranda leaves out 15 years of development. no monads, for example
17:15:42 <dons> (that's like learning scheme without continuations, i'd argue)
17:15:54 <Igloo> dons: Is that due to talking to you at the SoC thing?
17:16:02 <dons> Igloo: hmm?
17:16:04 <monochrom> "Hello?  Why is my course notes not talking to me!"
17:16:20 <Igloo> dons: The comment at the bottom of http://julipedia.blogspot.com/2006/06/functional-programming-and-haskell.html implies they're both SoC people
17:16:24 <lambdabot> http://tinyurl.com/uub3m
17:16:32 <dons> oh, I didn't see that!
17:16:35 <Igloo> Or si that a different SoC?
17:16:59 <Igloo> Oh, wait, 14 months. Guess not then  :-)
17:17:27 <dons> i think he was a pugs student?
17:17:51 <monochrom> chessguy: it is still useful to know how c and c++ are implemented.  it is also how many languages can be implemented.  It is also, though a bit more far-fetched, something one can borrow to implement Haskell.
17:17:57 <lispy> dons: remember what you said yestarday about using recursion when i said i felt like i did very little CS at work?
17:18:23 <dons> yeah
17:18:44 <lispy> dons: i just wrote a recursive function in VBA to get a list of files, and it dies when it returns because the system call for getting the next directory entry can't handle the recursion :(
17:19:06 <dons> *cough*
17:19:07 <monochrom> OH! non-reentrant?
17:19:11 <MarcWeber> dons: If you want to give my haskell function/ module completion vimscript another try you can get it here: http://mawercer.de/marcweber/vim/vimlib/ ( -> installers ) I still have to ensure that it works on windows.
17:19:13 <chessguy> monochrom, i don't mind learning that. what i mind is that in my whole computer science degree i'm going to get maybe a couple weeks of formal training in functional programming
17:19:14 <lambdabot> Title: Index of /marcweber/vim/vimlib
17:19:21 <dons> MarcWeber: ah great. will do
17:19:39 <monochrom> Same for me, chessguy.  But I survived.
17:19:45 <dons> chessguy: yeah, you have to pick your unis carefully.
17:19:52 <jgrimes> chessguy: same for me.
17:19:56 <dons> you tend to get the good CS theory at only certain places
17:20:12 <SamB> see, this is why I'm majoring in engineering
17:20:18 <psnl> chessguy: which country do you live in?
17:20:26 <monochrom> I thank the school and the profs for whatever they taught me.  But it is the beginning, not the end.
17:20:41 <chessguy> on the plus side, the head of the department here is big in evolutionary computation, so if i go to grad school that will be good
17:20:43 <chessguy> i'm in the US
17:21:03 <Botty> chessguy: like GAs?
17:21:09 <chessguy> yes
17:21:15 <MarcWeber> dons: You can save this all to an additional runtimepath. Than its easy to remove again.
17:21:29 <lispy> dons: this is after getting all manner of errors that could be avoided with type checking :(
17:21:34 <chessguy> though he won't like me using a functional language for it
17:21:39 <monochrom> My mother school was a polytechnic university.  short on theory, strong in practicals.
17:21:48 <SamB> chessguy: why not?
17:21:50 <Botty> I used to love those until I had a talk with a mathematician/coder who knows of other methods
17:21:54 <monochrom> Now, do I look like an engineer or a theorist?
17:22:03 <SamB> because you will wear out the grids?
17:22:04 <chessguy> because, he's also big on using c/c++
17:22:17 <Botty> for GAs? ugg
17:22:22 <SamB> maybe you can write an EDSL that generates C?
17:22:22 <chessguy> yeah
17:22:29 <chessguy> EDSL
17:22:30 <chessguy> ?
17:23:03 <chessguy> Botty, everyone knows how much faster c/c++ is (*rolls eyes*)
17:23:13 * lispy looks for a different primitive
17:23:15 <Botty> ;)
17:23:37 <lispy> you can still use C for tight loops with haskell
17:23:56 <Botty> well, if you have to compile each generation/member you're pretty screwed with c/c++
17:23:58 <lispy> take for instance Data.ByteString and GSLHaskell
17:24:07 <SamB> chessguy: it can be if you generate it from your Haskell program ;-)
17:24:10 <EvilRanter> chessguy, only when dealing with finite objects :P
17:24:22 <SamB> faster than trying to get GHC to optimize your code right, I mean
17:24:30 <chessguy> what's an EDSL?
17:24:38 * lispy is ---><--- close to writing an eDSL to generate this VBA code
17:24:50 <SamB> "embedded domain specific language"
17:25:39 <chessguy> never heard of that
17:25:47 <SamB> you make them
17:26:01 <monochrom> lispy: I advise using breadth-first search.  At least it's still a CS-ish technique. :)
17:26:38 <lispy> monochrom: just to list directories?
17:26:40 <lispy> hehe
17:26:53 <lispy> i should use iterative deepening :)
17:27:00 <Botty> you make a language for a specific task, to automate coding.  good DSLs make stuff much more maintainable, bad ones screw you over (might end up just modifying the generated code)
17:27:31 <Botty> It's basically the final frontier of abstraction ;)
17:27:37 <chessguy> iterative deepening? i've never heard that applied outside alpha beta
17:27:43 * EvilRanter -> bed
17:28:06 <monochrom> recursive directory search is an alpha-beta with boring values of alpha and beta.
17:28:19 <chessguy> lol
17:28:50 <audreyt> that's quotable :)
17:29:09 <chessguy> @remember monochrom recursive directory search is an alpha-beta with boring values of alpha and beta.
17:30:43 <chessguy> "recursive functions always have multiple copies of their stack frames"....zzzzz
17:31:11 <chessguy> we've spent 20 minutes talking about that now :)
17:31:59 <audreyt> EDSL is not really the final frontier...
17:32:04 <audreyt> EDSP is
17:32:13 <audreyt> Embedded Domain Specific Programmer (preferably AI)
17:32:18 <Botty> hah
17:32:31 <Botty> well, that's just a special case of EDSL
17:32:43 <audreyt> well but the point is you don't need to write programs in that L :)
17:32:48 <Botty> because what you say to it is the program...
17:32:55 <Botty> i suppose then its just a DSL
17:32:58 <audreyt> it should figure that out from the domain...
17:33:08 <audreyt> without me telling it
17:33:08 <Botty> how does it know the domain?
17:33:11 <Botty> ah
17:33:25 <audreyt> well, by researching into relevant information I think
17:33:39 <jgrimes> that sounds like a fun problem
17:33:54 <Botty> it'd still be a very very concise DSL :)
17:34:09 <Botty> well, I suppose general language actually
17:34:32 <audreyt> before Pugs showed up, people used to say the only way to run perl6 code is to ship a complementary clone of larry wall with each installation of perl6...
17:34:39 <audreyt> that's a case of embedded programmer.
17:34:59 <chessguy> lol. "most languages use static scope". good to know and forget :)
17:35:18 <dons> audreyt: hehe
17:35:35 <audreyt> dons: what are you hacking on nowadays?
17:35:39 <dons> yay for pugs! breaking the sterotypes and misconcepts of both perl6 and haskell!
17:35:56 * audreyt is preparing for tomorrow's CONISLI opening talk as surrogate for larry
17:35:59 <SamB> also breaking libraries and compilers alike!
17:36:08 <jgrimes> yeah, I have to say that I am fairly impressed with pugs/the pugs contributors
17:36:11 <Igloo> Of course, the advent of pugs has set back the development of cloning processes by decades
17:36:24 <SamB> Igloo: huh?
17:36:30 <audreyt> rofl
17:36:43 <Igloo> SamB: Well, now there's no need to develop the technology needed to clone LW
17:36:43 <SamB> oh, you mean because they aren't researching into cloning Larry Wall?
17:36:48 <dons> audreyt: 2 things, polymer simulation via runtime generated code, and stream fusion for lists
17:38:23 <dons> ?users
17:38:23 <lambdabot> Maximum users seen in #haskell: 265, currently: 204 (77.0%), active: 34 (16.7%)
17:38:28 <dons> ?users #haskell.jp
17:38:29 <lambdabot> Maximum users seen in #haskell.jp: 4, currently: 3 (75.0%), active: 1 (33.3%)
17:38:33 <dons> 4! good
17:38:37 <dons> ?users #haskell.es
17:38:37 <lambdabot> Maximum users seen in #haskell.es: 13, currently: 9 (69.2%), active: 3 (33.3%)
17:39:47 <dons> audreyt: i've been thinking abit about how the ruby guys are suffering (stalling?) because they can't get threads or continuations into their VM. seems like pugs has a massive advantage there -- and its only going to grow with time.
17:40:06 <audreyt> well, yeah, because GHC RTS is too good :)
17:40:27 * audreyt will test out the new coverage feature too
17:40:33 <audreyt> we've been pining for that for months
17:40:49 <dons> even a 10% productivity benefit per year for pugs devs working on the compiler and rts is going to add up over time, eventually you'll be streets ahead
17:41:18 <audreyt> and it's far more than 10%
17:41:22 <dons> right.
17:41:32 <audreyt> because it's really hard to get right :)
17:41:44 <dons> its very exciting right now. smp ghc rts appearing _exactly_ when it was needed
17:41:56 <audreyt> and with stm as the abstraction layer.
17:42:39 <dons> right. so a smaller community, with a better foundation can outperform a larger community working with broken tools
17:42:48 <dons> quality not quantity, for language and compiler construction
17:42:56 <audreyt> it's not a smaller community :)
17:43:02 <chessguy> what's the point of implementing perl6 in haskell?
17:43:04 <audreyt> the rubyVM project has exactly two people working on it.
17:43:09 <dons> ah yes!
17:43:19 <audreyt> chessguy: well, exactly the point of implementing perl 6 :)
17:43:24 <dons> so much smaller. not a good sign for them
17:43:26 <audreyt> and what's the point of that? well it's fun.
17:43:39 <chessguy> ok, fair enough
17:44:09 <audreyt> otherwise how can I find convenient excuses to try every single item on GHC changelog :)
17:44:16 <dons> :)
17:44:37 <dons> and really, its the perfect choice for a difficult to implement perl6 spec.
17:44:52 <audreyt> SPJ calls it "ferociously difficult."
17:44:56 <dons> you want a compiler construction DSL :)
17:45:03 <audreyt> and a VM DSL
17:45:05 <dons> and we happen to have one, designed for building ghc.
17:45:30 <audreyt> well, for years the primary application for GHC is itself
17:45:36 <audreyt> that is very much unlike other self-hosted languages
17:45:56 <dons> yeah. no wonder there are all these language tools
17:45:57 <SamB> yeah
17:46:00 <audreyt> nobody would think GCC is the primary application of C :)
17:46:18 <dons> a language that developed as a tool for building languages by the prog. lang. research community
17:46:26 <dons> surprise ... turns out to be good for writing compilers in
17:46:33 <Pseudonym> No, the primary application of C was Unix.
17:46:54 <dons> Pseudonym: why is mercury written in C?
17:46:58 <Pseudonym> Unsurprising there are so many operating systems and single-use tools written in C.
17:47:00 <dons> I was surprised to learn.
17:47:01 <Pseudonym> It's not.
17:47:03 <dons> ah?
17:47:17 <dons> oh, sorry. its ghc-style.
17:47:21 <dons> mercury compiler, C rts?
17:47:21 <Pseudonym> Yeah.
17:47:35 * dons forgot that. hunts for espresso
17:47:37 <Pseudonym> The Mercury compiler does ship with the C sources for easy bootstrapping.
17:47:54 <Pseudonym> But that's that the Mercury compiler outputs.
17:48:14 <Pseudonym> Don't worry, not the first time I had that misunderstanding.
17:48:20 <SamB> dons: okay, I think I've almost fixed the static build
17:48:27 <dons> SamB: ok good.
17:48:36 <SamB> I have fixed the preprocessor
17:48:50 <Pseudonym> When I ported Mercury to FreeBSD, someone on the mailing list said, "anyone who writes code using GCC register variables is asking for trouble".
17:48:54 <Pseudonym> Not realising it was generated code.
17:48:57 <dons> heh
17:49:10 <dons> they thought it was written by hand?
17:49:11 <SamB> evidently the first argument (which was being ignored) is the *original* source file, whereas the second arg is the *immediate* source file
17:49:11 <audreyt> its codegen is that good?
17:49:23 <dons> or the pretty printer :)
17:49:31 <audreyt> or the random comment generator.
17:49:34 <Pseudonym> The high-level C mode is pretty good, actually.
17:49:36 <dons> SamB: something like that.
17:49:42 <Pseudonym> Nah, the code looks likeL
17:49:43 <dons> SamB: probably should document it. it confused me too
17:49:45 <Pseudonym> PUSH(r0);
17:49:46 <Pseudonym> etc
17:50:08 <SamB> dons: well, I used a reasonable variable name
17:50:11 <SamB> (orig)
17:55:32 <dons> audreyt, hmm, reddit has an interesting comment to the effect that perl6 junctions are similar to the list monad? is that right?
17:55:54 <audreyt> not exactly... junctions are Sets with a boolean operator on it
17:56:03 <audreyt> and operation on it always parallelize
17:56:19 <audreyt> think Fortress/APL vectors, but as a set not a sequence
17:56:25 <Pseudonym> So more like fold[lr]
17:56:27 <Pseudonym> ?
17:56:29 <audreyt> (1|2) < 3 # True
17:56:31 <dons> ah ok. so more like parallel folds and maps/
17:56:39 <audreyt> (1|4) < 3 # True
17:56:47 <audreyt> (1&4) < 3 # False
17:57:23 <dons> no wonder you want to run these things on the gpu
17:57:30 <audreyt> more funkily:
17:57:38 <audreyt> sub is_prime (Int $n --> Bool) {
17:57:42 <audreyt> $n % all(2 .. $n.sqrt+1)
17:57:44 <audreyt> er
17:57:50 <audreyt>     $n % all(2.. $n.sqrt+1)
17:57:51 <audreyt> }
17:58:04 <audreyt> sub has_twin_prime (Int $n --> Bool) {
17:58:18 <audreyt>     is_prime($n & ($n + (2 | -2)));
17:58:18 <audreyt> }
17:58:34 <audreyt> where all() builds a junction with the AND operator on it
17:58:49 <audreyt> and & and | are infix constructors of AND and OR junctions, respectively.
17:58:54 <dons> mmm. I smell FP :)
17:59:04 <Igloo> Yes - all() seems very like all  :-)
17:59:05 <audreyt> this is actually APL :)
17:59:15 <audreyt> not really... because
17:59:19 <audreyt> all(1, 2, 3) + 4
17:59:24 <audreyt> is all(5, 6, 7)
17:59:35 <audreyt> so it carries the junction forward in all operations
17:59:41 <Igloo> OK
17:59:48 <audreyt> it's really a smart parallelizable set
18:00:06 <audreyt> the design is such that on GPUs or multicore then each forkIO can have affinity on its element
18:00:16 <audreyt> and it's indeed scaling linearly, thanks to GHCRTS=-N :)
18:00:24 <dons> yeah, nice.
18:01:01 <Igloo> The above examples smell like more DWIM creeping in, though
18:01:30 <SamB> remindes my of Numerical Python
18:01:33 <dons> heh. or maybe a (-> a) arrow or something funky like that
18:01:35 <Igloo> In the isprime example it collapses it to a Bool in a certain way, but with +4 it does that to all the elements
18:02:24 <dons> Igloo: + is typeclassed ;)
18:02:34 <dons> and there's an instance of Num [Int] I suppose ;)
18:02:47 <SamB> dons: hmm, apparantly there is a *reason* why I don't build lambdabot statically
18:03:23 <Igloo> dons: Yeah, it's almost that, but some operations that were a -> a -> a are now a -> a -> b with fundeps or something
18:03:30 <dons> yeah
18:03:44 * Igloo suspects it would be at least half an oleg to implement the same semantics in Haskell
18:03:56 <dons> there's some fame to be made if you can provide a type static type system for perl6
18:04:11 <dons> like Peter thiemann's one for javascript, or simon's erlang type system
18:04:22 <SamB> Igloo: *half* an oleg?
18:04:36 <SamB> don't you think half an oleg would be kind of ... dead?
18:04:51 <emu> does half an oleg x2 make 1 oleg?
18:04:56 <Igloo> SamB: oleg is the unit of measurement for type trickery
18:04:56 <dons> SamB: so were you going to tell me what the reason was? or you just like to create suspends?
18:05:11 <SamB> dons: it takes forever to link!
18:05:20 <dons> Igloo: we should have a scoring system for haskell type puzzles
18:05:25 <dons> like with gymnastics of diving
18:05:35 <dons> 3.2 Olegs, with a half pike hlist
18:05:52 <dons> s/of/or/
18:06:02 <Igloo> 3.2 Olegs? Doesn't >1 mean impossible?
18:06:09 <SamB> Igloo: hah
18:06:18 <dons> SamB: update your hardware with a linker-gpu ;)
18:06:21 <audreyt> dons: there's no static type system for perl6 because we have 1)union 2)constrained 3)derived types
18:06:29 <SamB> dons: linker gpu?
18:06:34 <SamB> what the hell?
18:06:35 <audreyt> so it's bound to be undecidable incoherent and overlapping :)
18:06:40 <dons> audreyt: oh yeah, i know. its hard!
18:06:47 <audreyt> no it's proven to be impossible
18:06:57 <audreyt> which is why we only do local type inference :)
18:07:02 <audreyt> (other inferences are advices only.)
18:07:10 <dons> but surely static semantics could be given for things like the junctions, or the way context works
18:07:22 <dons> so pieces of the language
18:08:01 <dons> would be an interesting research puzzle, anyway
18:08:15 <audreyt> operational semantics, you mean
18:08:39 <audreyt> then yes. well that's what I'm doing, and maybe you'll see it published some day if I practice on my LaTeX-fu more :)
18:09:32 <dons> ?google symbols-a4.pdf
18:09:35 <lambdabot> http://www.ctan.org/tex-archive/info/symbols/comprehensive/symbols-a4.pdf
18:09:36 <dons> is all you need ;)
18:12:07 <lispy> whoa, they finially fixed perl so that function have parameters?
18:12:26 <lispy> that's pretty cool
18:12:32 <emu> fixed perl? lol
18:12:41 <lispy> that's probably been my #1 thing i didn't like about perl
18:13:26 <audreyt> yes, and the parameters are named, and typed :)
18:13:38 <lispy> sweet
18:13:50 <lispy> i may actually learn some perl6 someday
18:13:52 <audreyt> the thing I miss in Hs compared to p6 is the ability to pass thing sby name
18:14:42 <emu> call by name?
18:14:49 <emu> named parameters?
18:14:49 <audreyt> er no, very simply:
18:14:55 <audreyt> f x y = x+y
18:15:06 <audreyt> curried = f {y=2}
18:15:16 <dons> ah interesting
18:15:16 <audreyt> curried 1 -- 3
18:15:19 <emu> like records
18:15:33 <audreyt> yes.
18:15:38 <Dylan> curry-by-name?
18:15:43 <audreyt> *nod*
18:15:51 * Dylan nods.
18:15:52 <dons> records for arguments. could be interesting when args > 2, and flip gets confusing
18:15:55 <audreyt> in perl6: &f.assuming(y=>2)(1) == 3
18:16:01 <Dylan> kind of like how named arguments work in ocaml.
18:16:06 <audreyt> yup.
18:17:12 <Dylan> in ocaml, you could: let f ~x ~y = x + y ;; let curried = f ~y: 2
18:17:22 <dons> so you'd write: curried x = f x y where y = 2, or something, if flip wasn't nice.
18:17:27 <dons> but yeah, nice.
18:17:53 <audreyt> Dylan: yes, and I quite like that
18:18:17 <audreyt> it provides more documentation on the call site
18:18:21 <Dylan> hmm, it's really sad that refuse to use ocaml any more.
18:18:29 <audreyt> and leads to clearer code when args>2
18:19:00 <Dylan> indeed. Named arguments + currying is nice.
18:19:35 <dons> hmm "that refuse to use ocaml any more" ?
18:19:49 <Dylan> err, it's late. "That I refuse to use ocaml any more"
18:19:57 <dons> oh, you do?
18:20:03 <audreyt> because you are committed to Dylan?
18:20:05 <Dylan> of course, I can remember the lack of libraries and documentation.
18:20:22 <dons> what are you using instead?
18:20:34 <Dylan> audreyt: No, because of the small, abusive community.
18:20:42 <Dylan> dons: haskell, of course.
18:20:45 <audreyt> ah.
18:20:48 <dons> that's unfortunate. protect the community1
18:21:00 <dons> Dylan: do you find the docs and libs any better over this side of the ditch?
18:21:05 <Dylan> Also, QPL'd compiler is evil.
18:21:09 <dons> yeah
18:21:10 <audreyt> <lwall> the community can eventually fix the language, but the language cannot fix the community
18:21:13 <Dylan> dons: much better.
18:21:21 <dons> audreyt: exactly.
18:21:42 <dons> and the community is maybe 80% of the success of a language
18:21:52 <lispy> Dylan: ah, yeah and there is a certain someone in #ocaml that is just a jerk to new comers
18:22:00 <audreyt> of course, otherwise we'll all be speaking Lojban :)
18:22:13 <Dylan> lispy: it's not just #ocaml. The mailing list is dry compared to haskell-cafe.
18:22:15 <lispy> Dylan: I think his name was Dilen....er...oh n/m ;)
18:22:22 <lispy> Dylan: ah
18:22:35 <lispy> Dylan: the few times i had questions in #ocaml i found it a very off putting experience
18:23:06 <Dylan> in #ocaml, I was one of only three people to answer questions to newbies.
18:23:23 <dons> Dylan: let us know if there's anything that needs improving.
18:23:41 <audreyt> ...or just go ahead improve it :)
18:23:43 <Dylan> dons: so far, I could a quickref for calling C code in haskell.
18:23:47 <dons> i'm constant surprised by insights outsiders bring into our processes and community. it really helps smooth things out and streamline everything
18:23:52 <Dylan> *could use a quickref.
18:23:54 <dons> Dylan: ah good idea!
18:24:00 * dons makes a note
18:24:11 <dons> there's Wc, which turned into an ffi tut:
18:24:14 <dons> ?wiki Wc
18:24:14 <lambdabot> http://www.haskell.org/haskellwiki/Wc
18:24:23 <Dylan> I'm learning to use slang, and figure I'll do a very direct binding of it in haskell
18:24:30 <dons> ah right. yes.
18:24:36 <dons> you had a look at my curses binding?
18:24:42 <Igloo> Having argument names (and default values) in the type would be the way to go, IMO
18:25:08 <audreyt> there's also http://www.haskell.org/hawiki/FfiTutorial on the old wiki
18:25:10 <lambdabot> Title: FfiTutorial - The Haskell Wiki
18:25:16 <Dylan> dons: I did, but it's too much for me to learn from. I need to do it myself with a very little description of how to do it. The less description, the better.
18:25:19 <dons> Igloo: hmm, like default methods for classes (re. default values?)
18:25:20 <audreyt> Igloo: well it's already parsed as part of imp-param
18:25:29 * lispy >>= home
18:25:41 <Igloo> Hmm, maybe default values aren't workable, actually
18:25:53 <Igloo> You'd have to explicitly tell a function it has all its arguments
18:26:00 <Dylan> ocaml has default values in the type signature.
18:26:03 <Igloo> audreyt: I don't follow
18:26:03 <audreyt> f :: (x :: Int) -> (y :: Int) -> Int
18:26:14 <audreyt> Igloo: there is already code for
18:26:18 <audreyt> f :: (?x :: Int)
18:26:18 <SamB> !???!
18:26:19 <audreyt> etc
18:26:31 <audreyt> on the lhs of =>
18:26:36 <Igloo> Ah, I see. Writing the parser is probably easiest bit, though  :-)
18:27:03 <audreyt> er no, what I mean is carry regular stuff as part of context
18:27:10 <audreyt> the name-position associations that is
18:27:42 <audreyt> piggyback on existing implicit-parameter context structure
18:28:04 <audreyt> but instead of (let ?x) binding, modify the call syntax to allow
18:28:09 <audreyt> func{ x = 1, y => 2}
18:28:13 <audreyt> in exactly analogy of
18:28:17 <audreyt> DataCon{ x = 1, y = 2 }
18:28:20 <Igloo> Wouldn't that clash though?
18:28:23 <audreyt> (the => above should be =>)
18:28:36 <audreyt> it will, so need some other bracket
18:28:41 <audreyt> func {{ x = 1, y => 2 }}
18:28:58 <audreyt> (the three => above should be =)
18:29:26 <emu> why not go full out bash $(( ${ $[ {{ << ( blah
18:29:42 <audreyt> well, perl6 allows any balanced Ps/Pe brackets in Unicode
18:30:07 <SamB> Ps/Pe?
18:30:23 <audreyt> that's 185 of them
18:30:37 <audreyt> balanced start/end quote pairs
18:30:56 <Igloo> In fact, I think we can even use record syntax for supplying the arguments without ambiguity
18:31:18 <SamB> how!
18:31:21 <Igloo> f :: (x :: Int) -> (y :: Int) -> Int
18:31:21 <Igloo> f a b = a + b
18:31:21 <Igloo> (f {y = 3}) 1 = 1 - 3 = -2
18:31:22 <audreyt> but foo{ x = 1} is currently record update for the return value of foo
18:31:31 <SamB> audreyt: exactly!
18:31:40 <Igloo> but foo has function type here
18:31:41 <audreyt> unless you do something unthinkable
18:31:46 <audreyt> namely make -> on recupdate
18:31:48 <audreyt> ...exactly.
18:31:53 <SamB> UNTHINKABLE INSTANCES?
18:32:03 <audreyt> -fallow-unthinkable-instances
18:32:11 <audreyt> -- brain explosion considered nonfatal
18:32:24 <Igloo> Oh, but GHC will try to bind x before it knows that
18:33:16 <ikegami--> -fbehave-as-my-good-friend
18:33:21 <Igloo> No, I think it could be done
18:33:22 <Dylan> @hoogle assert
18:33:23 <lambdabot> Control.Exception.assert :: Bool -> a -> a
18:33:23 <lambdabot> Test.HUnit.Base.assert :: Assertable t => t -> Assertion
18:33:23 <lambdabot> Control.Exception.assertions :: Exception -> Maybe String
18:33:25 <_SamB_bot> Control.Exception.assert :: Bool -> a -> a
18:33:25 <_SamB_bot> Test.HUnit.Base.assert :: Assertable t => t -> Assertion
18:33:25 <_SamB_bot> Control.Exception.assertions :: Exception -> Maybe String
18:33:27 <audreyt> I think {{}} or some other quote is a bit saner to the eyes
18:33:31 <Dylan> Sorry!
18:33:51 <audreyt> but (+){ x = 1, y = 2 } has a certain charm
18:34:08 <Igloo> A first pass can tell that that f is bound to something with a type signature, and it will always have to have a type signature if it names things
18:34:21 * SamB thinks Haskell should support binding Ps/Pe pairs
18:35:02 <ikegami--> what is Ps/Pe?
18:35:11 <dons> the problem would be that new syntax requires a high score on the power scale
18:35:19 <ikegami--> (sorry if you have already mentioned it, I have to read the previous messages)
18:35:24 <audreyt> http://www.fileformat.info/info/unicode/category/Ps/index.htm
18:35:25 <_SamB_bot> Title: Unicode Character Category 'Punctuation, Open', http://tinyurl.com/yf6ot5
18:35:28 <lambdabot> Title: Unicode Character Category 'Punctuation, Open', http://tinyurl.com/yf6ot5
18:35:46 <SamB> @quit
18:35:47 <lambdabot> Not enough privileges
18:35:54 <Igloo> dons: Right, we should go through our code looking for where we would have liked to have it
18:36:06 <dons> right. the small examples aren't so good.
18:36:23 <Igloo> The problem is in many cases we might have written it a different way due to not having it, though
18:36:26 <audreyt> also it should probably only work with functions declared that way. maybe
18:36:30 <dons> (\x y -> x + y) 1 2, or curred x = f x y where y = 2
18:36:30 <SamB> okay, maybe not rebinding
18:36:33 <ikegami--> audreyt: thanks
18:36:43 <Igloo> audreyt: If you have the names in the types then that's a given
18:36:51 <SamB> maybe writing COMPILERS that operate on things in brackets like that ;-)
18:37:09 <audreyt> Igloo: interestingly that makes typeclass signatures constraining
18:37:25 <Igloo> audreyt: HDYM?
18:37:53 <audreyt> class Foo a where f :: (t :: a) -> (x :: Int) -> Int
18:38:07 <audreyt> instance Foo T where f t x = ...
18:38:17 <audreyt> hm. maybe it doesn't have to say "f t x" there
18:38:19 <ikegami--> looks like a dependent type
18:38:21 <audreyt> "f x y" will do
18:38:25 <Igloo> Right
18:38:29 <ikegami--> as Cayenne or Agda
18:39:00 <audreyt> since all the annotation do is establish mappings from fields to positions
18:39:04 <audreyt> arguably that means
18:39:04 <Dylan> dons: would a C function with no arguments and void return type just be an IO ()?
18:39:05 <Igloo> Hmm, you could have arguments default if they have a default and a {} is applied
18:39:22 <dons> Dylan: yep.
18:39:22 <audreyt> f :: (x :: a) -> Int -> Int
18:39:25 <audreyt> is still legal
18:39:37 <desrt> hah.  mercury is done compiling
18:39:38 <Igloo> Right
18:39:39 <dons> Dylan: if its side effecting, its in IO.
18:39:41 <desrt> that took a really really long time
18:39:51 <dons> and () maps to the void value
18:40:02 <audreyt> but that almost warrants new signature syntax
18:40:07 <audreyt> as I did on gadt-recs
18:40:10 <dons> (you cna have pure ffi bindings too, for say, sin() )
18:40:14 <Igloo> I don't think we can allow    let g = f in g { x = 3}   sadly
18:40:17 <audreyt> f :: { x :: a, y :: Int } -> Int
18:40:31 <audreyt> er I mean
18:40:41 <audreyt> f { x :: a, y :: Int } :: Int
18:40:46 <SamB> err?
18:40:47 <SamB> no!
18:40:48 <audreyt> that's a bit scary. :)
18:40:56 <SamB> I like the former better
18:40:57 <audreyt> probably not a good idea.
18:41:08 <ikegami--> but very interesting
18:41:08 <audreyt> yeah, I like the former better too
18:41:13 <SamB> the latter looks too much like Agda
18:41:25 <SamB> which I don't understand
18:41:26 <Igloo> I think it would be nice to be able to use that as an option
18:41:38 <audreyt> -fallow-unthinkable-records
18:41:39 <SamB> (It is a stripped down version of cayyene
18:41:48 <Igloo> It would  make it easier to update the arguments taken if people weren't assuming they were in certain positions
18:41:53 <ikegami--> because I'm one of developers of Agda, the notation of Agda is familiar for me
18:42:05 <audreyt> Igloo: this screams for record punning
18:42:27 <SamB> ikegami--: you should work on the docs, I think. at least if you are still using the ones you were using when last I looked at them...
18:42:32 <ikegami--> however many Haskell programmers aren't familier with Agda because Agda is so minar
18:42:41 <audreyt> let (x, y) = (1, 2) in f{ x, y }
18:42:52 <SamB> which look like copies of the Cayenne docs for the same things
18:42:59 <Dylan> dons: any examples for function pointers and signals? http://www.s-lang.org/doc/html/cref-10.html#ss10.10
18:43:03 <lambdabot> Title: {The S-Lang C Library Reference}: Keyboard Input Functions, http://tinyurl.com/ykxdht
18:43:23 <dons> funpts are Ptr (Int -> IO ()) , for example
18:43:36 <dons> and signals you handle with signals, let me find some code
18:43:51 <dons> Dylan: should be in the ffi spec, the function ptr stuff
18:43:54 <lisppaste2> dylan pasted "haskell slang" at http://paste.lisp.org/display/29196
18:44:03 <ikegami--> SamB: we, developers of Agda, share the same opnion that there is a very few document for Agda
18:44:08 <ikegami--> I'm sorry that
18:44:29 <dons> I enjoyed the Agda paper at icfp 05 on verifying Core from GHC.
18:44:36 <dons> but more info and tuts on that would be good! :)
18:44:41 <Dylan> slang nicely breaks up into seperate modules, it seems.
18:44:43 <ikegami--> exactly
18:45:07 <Dylan> I think, realistically, the slang library could be re-written in haskell.
18:45:21 <audreyt> but then you have to maintain it...
18:45:23 <Dylan> Not now, but, it's not that difficult.
18:45:38 <audreyt> coding is not he hard part :)
18:45:53 <Dylan> well, it would be a lot nicer.
18:46:03 <dons> Dylan: the stuff on setting up posix signal handlers is here http://www.cse.unsw.edu.au/~dons/code/hmp3/Main.hs
18:46:05 <lambdabot> http://tinyurl.com/y269ge
18:46:06 <Dylan> although slang is already 100% nicer than ncurses.
18:46:17 <audreyt> totally agreed
18:46:25 <audreyt> # never really survived ncurses
18:46:25 <Dylan> dons: thanks
18:46:30 <dons> 100% nicer than nice = 0 ... ?
18:46:38 <Dylan> dons: heh
18:46:54 <Dylan> I only use one application that isn't ncurses or slang-based.
18:47:15 <Dylan> I really am amazed that anything at all uses ncurses.
18:47:28 <lispy> what!
18:47:32 <lispy> ncursesis cool!
18:47:34 <dons> oh, its not so bad. once you write a nice api on top of it in another language
18:47:39 <Dylan> ncurses is *difficult*
18:47:47 <dons> something like Text.PrettyPrint for curses is my dream
18:47:53 <Dylan> and also arbitrarily difficult
18:48:03 <dons> i've got a bit of a sketch for rendering curses screens via ppr combinators
18:48:08 <audreyt> dons: Wx/XTC on AALib? :)
18:48:10 <dons> maybe it would be easier over slang though
18:48:11 <SamB> does anyone have a clue why Epigram is so much more well known than Agda?
18:48:12 <Dylan> the colorpair idea doesn't make sense on a lot of terminals.
18:48:27 <audreyt> ok, maybe not AALib.
18:48:28 <ikegami--> dons: your idea about ncurses library sounds very nice
18:48:42 <dons> since a curses screen is just a 2-D text box
18:48:50 <lispy> dons: yup
18:48:54 <dons> it fits the Hughes-Jones ppr style very nicely
18:48:55 <lispy> would be very cool
18:49:11 <ikegami--> and easily to imagine how to work
18:49:14 <dons> and you can newtype each element in the screen, and write an instance PprCurses for that type
18:49:14 <lispy> dons: is hat the same ase HughesPJ?
18:49:24 <dons> the api would be the same, yeah
18:49:25 <Dylan> dons: there's a lot fewer screen manip functions in SLsmg
18:49:43 <dons> oh yeah. you only want to use a tiny subset of [n]curses
18:49:45 <Igloo> It's not quite the same as you need to be able to say "the second line from the bottom"
18:49:48 <palomer> yo my bitches
18:49:50 <dons> basically the ocurses/curses api only
18:49:58 <dons> Igloo: right. you have a proper box
18:50:04 <ikegami--> i envy dons because he has many interesting idea and also is very creative
18:50:05 <dons> and you can't go passed the rhs
18:50:07 <Igloo> But you could do something similar, with expanding things somewhat like tex's fills
18:50:37 <lispy> ikegami--: that sounds like a description for many people in #haskell! :)
18:50:49 <lispy> ikegami--: (both the envious and the creative :)
18:51:04 <dons> one nice thing is that you can attach a forkIO redraw thread to sub-boxes on the screen
18:51:11 <dons> so they can be redrawn individually
18:51:18 <dons> (hmp3 does this)
18:51:27 <ikegami--> :)
18:51:36 <dons> hmm, I should really polish up this Console.Curses.PrettyPrint at some point
18:51:38 <lispy> dons: i have to tell you...i always read that with an extra 'u' ;)
18:51:43 <SamB> I would *really* like to see some kind of pretty-printer style framework for UIs
18:53:21 <SamB> dons: okay, here is your fixed patch
18:53:31 <Dylan> hmm, though, if dons polishes that up, I will have no motivation to write slang bindings.
18:53:43 <dons> heh
18:53:52 <dons> we could use the same api over slang though
18:54:03 <dons> just a box/fmt combinator set, with two backends
18:54:10 <dons> SamB: thanks
18:54:26 <lisppaste2> dylan pasted "haskell slang testcase" at http://paste.lisp.org/display/29198
18:54:34 * SamB goes to check that it isn't missing any crucial files for the *other* way
18:54:39 <Dylan> my goal for tonight/tomorrow --- make that run!
18:55:25 <dons> hmm. there'd almost be a HW paper in a curses ppr lib
18:55:38 <dons> if it could have a couple of wildly different backends
18:56:02 <audreyt> e.g. a HGL backend
18:56:03 <lispy> Dylan: your assume function looks a little weird to me
18:56:25 <dons> Dylan: when (status == -1) $ error s
18:56:25 <lispy> oh, i see
18:56:39 <Dylan> Ah, right.
18:56:48 <Dylan> it's a sketch.
18:57:06 <dons> Dylan: and also, we have Foreign.C.Error.throwErrnoIfMinus1
18:57:12 <dons> ?docs Foreign.C.Error
18:57:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C-Error.html
18:57:18 <lispy> dons: could some TH make it so he doesn't have to pass in the function name?
18:57:22 <dons> specifically for getting at errno strings in errors from C libs
18:57:27 <lispy> dons: or maybe your assert trick?
18:57:39 <Dylan> Slang doesn't use errno
18:57:47 <dons> ah ok
18:58:55 <lispy> Dylan: also, withSlang f = do init; f; reset
18:59:08 <lispy> so then, main = withSlang $ do ...
18:59:58 <Dylan> isn't there a bracket function anyway?
19:00:12 <lispy> there is
19:00:16 <dons> yep; bracket init reset f
19:00:21 <dons> will ensure reset is called
19:00:27 <dons> you'll want that, at least curses does
19:00:35 <Dylan> now, here's the thing...
19:00:45 <lispy> so in that case, you probably want withSlang = bracket init reset
19:00:45 <Dylan> do I need to make it do reset on sigint?
19:01:29 <lispy> no idea :)
19:01:29 <Dylan> actually, no. in C, I needed to call exit(1) in sigint and the atexit handler was called
19:02:02 <Dylan> so, I don't need to use SLang_set_abort_signal, I think
19:14:14 <Dylan> sweet zombie jesus
19:14:23 <Dylan> this isn't hard.
19:14:46 <SamB> I never understood that expression
19:14:57 <Pseudonym> I think it's a lesser known heresy.
19:15:12 <dons> audreyt: what ws that dictionary translation trick you had?
19:15:16 <Dylan> SamB: you see, in the future, jesus comes back as a zombie and  destroys all the VHSes,
19:15:23 <Pseudonym> They believe that Jesus didn't actually rise from the dead, but did become a sweet zombie.
19:15:27 <SamB> I don't thinkj it is intelligent-sounding enough to really be a heresy
19:15:36 <dons> let _"hello" = "bonjour" in _"hello" -- or something?
19:16:05 <Pseudonym> If I called it "sucrohaitianism" it would sound intelligent.
19:16:39 <dons> ah, found it, instance Dictionary French where _'goodbye' = "adieu"
19:16:43 <Dylan> sweet zombie jesus is from futurama, which is about the only prime-time cartoon to feature jokes written by PhDs.
19:16:59 <SamB> ah
19:17:02 <Pseudonym> Given that there aren't a lot of prime-time cartoons...
19:17:05 <Dylan> this could be good or bad depending on who you ask.
19:17:14 <dons> > let _'goodbye' = "adieu" in show _'goodbye'
19:17:16 <lambdabot>  "\"adieu\""
19:17:23 <dons> > let _'goodbye' = "adieu" in _'goodbye'
19:17:24 <lambdabot>  "adieu"
19:17:28 <SamB> how many other cartoons have PhD-written jokes?
19:17:51 <Pseudonym> You don't know how many Pixar employees write jokes.
19:17:54 <Dylan> http://www.mathsci.appstate.edu/~sjg/futurama/degrees.html
19:17:59 <lambdabot> Title: Dr. Sarah's Mathematical Backgrounds of Futurama Writers, http://tinyurl.com/yml8k8
19:18:01 <dons> what about PhD Comics, SamB :)
19:18:19 <SamB_XP> hmm. I meant cartoon TV series', I think
19:19:27 <lispy> does the autho of PhD comics hold a PhD yet?
19:20:24 <Pseudonym> http://www.blogger.com/profile/5577411
19:20:28 <Pseudonym> Not that he does cartoons.
19:20:33 <Pseudonym> And true, he doesn't have a PhD.
19:21:39 <SamB_XP> PhD comics is good though
19:21:45 <Dylan> "Ken: Well, sure [those years of education were worth it].  For example, Bender's serial number is 1729, a historically significant integer to mathematicians everywhere; that "joke" alone is worth six years of grad school, I'd say."
19:21:52 <Pseudonym> :-)
19:24:47 <lispy> heh, and now numbers like 1729 are known as taxicab numbers
19:31:44 <lispy> "Every positive integer is one of Ramanujan's personal friends."
19:32:03 <lispy> that's what littlewood said after hearing about the taxicab thing
19:32:49 <Pseudonym> http://www.mathsci.appstate.edu/~sjg/futurama/nearmiss.html
19:32:52 <lambdabot> Title: David X. Cohen's Fermat Near-Miss Finders in C, http://tinyurl.com/92kwm
19:32:55 <Pseudonym> OK, that's cool.
19:35:20 <lispy> yeah, that is interesting
19:45:35 <hyrax42> ?pl let apl [] = \x -> x; apl (f:fs) = \x -> apl fs (f x) in apl
19:45:35 <lambdabot> (line 1, column 9):
19:45:35 <lambdabot> unexpected "["
19:45:35 <lambdabot> expecting pattern or "="
19:46:17 <hyrax42> ?pl (let apl [] = \x -> x; apl (f:fs) = \x -> apl fs (f x) in apl)
19:46:18 <lambdabot> (line 1, column 10):
19:46:18 <lambdabot> unexpected "["
19:46:18 <lambdabot> expecting pattern or "="
19:47:20 <hyrax42> hm
19:47:38 <hyrax42> ?type let apl [] = \x -> x; apl (f:fs) = \x -> apl fs (f x) in apl
19:47:39 <lambdabot> forall t. [t -> t] -> t -> t
19:47:53 <hyrax42> ?help pl
19:47:54 <lambdabot> pointless <expr>. Play with pointfree code.
19:52:17 <hyrax42> ?pl flip (foldl (flip ($)))
19:52:18 <lambdabot> flip (foldl (flip id))
19:52:49 <sjanssen> hyrax42: pl can't handle the list pattern matching
19:53:13 <hyrax42> oh
19:53:14 <hyrax42> hm
19:56:17 <lispy> ?scheck \f x -> (f::Int -> Int) `id` x == f $ (x::Int)
19:56:18 <lambdabot>  Couldn't match `Int' against `Int -> Int'
19:56:28 <lispy> ?check \f x -> (f::Int -> Int) `id` x == f $ (x::Int)
19:56:30 <lambdabot>  Couldn't match `Int' against `Int -> Int'
19:57:00 <lispy> ?type id
19:57:02 <lambdabot> forall a. a -> a
19:57:22 <lispy> ?check \f x -> id (f::Int -> Int) x == ($) f (x::Int)
19:57:23 <lambdabot>  OK, passed 500 tests.
20:14:23 <palomer> if it passed 500 tests then it must be true.
20:16:52 <lispy> decidedly so
20:19:31 <skew> ?check \f x -> (\f x -> if x < 2^128 then f x else 0) (f::Integer -> Integer) x == ($) f (x::Integer)
20:19:32 <lambdabot>  OK, passed 500 tests.
20:19:46 <Cale> actually, there are cases where a finite number of tests can prove that something is true
20:20:17 <skew> like, if you know the size of the program being tested
20:20:51 <lispy> or if you know the size of the types
20:21:03 <Cale> Or if it's a polynomial equation :)
20:21:11 <lispy> like, and, or and not can be proven correct with testing
20:21:31 <lispy> oh, oh, or if it's in C and uses pointers
20:21:36 <skew> bah, finite types and polynomials are boring because that finite test suite is actually computable
20:21:38 <lispy> i can prove it has a bug!
20:21:41 <lispy> just by knowing that much :)
20:22:09 <Cale> "For every triangle ABC, the angle bisectors intersect at one point"
20:22:37 <Cale> It's enough to check that for angle A and B chosen from {10,20,30,40,50,60,70,80} degrees.
20:22:51 <Cale> Which is 64 triangles.
20:23:12 <lispy> but more improtantly, software engineering is not about math
20:23:24 <lispy> so "proving" is not applicable
20:24:03 <lispy> proving a program correct doesn't get that next feature written or help stick to the budget
20:24:21 <lispy> so who needs it?
20:24:25 <Cale> The reason is that the coordinates of the intersections of the pairs of angle bisectors are rational functions of degree <= 7 in tan(A/2) and tan(B/2), so if they agree at 64 points, then they're identical :)
20:24:26 <lispy> </rhetorical>
20:24:38 <skew> it stops that next bug from being written
20:24:54 <Cale> It helps save lives :)
20:24:56 <skew> It's not usually full correctness your after
20:25:02 <Cale> you're
20:25:05 <lispy> skew: we're risk averse, we don't like to speculate about the future :)
20:25:16 <skew> but usefull little lemmas like "hey, this program doesn't segfault"
20:25:34 <skew> which can be proven by running the code through the proper tools, e.g. GHC
20:27:12 * lispy is just bitter
20:27:47 <lispy> you go from Haskell to VBA in just a couple hours and it's culture shock...you remember why programming is hard and pisses people off
20:28:02 <Cale> hehe
20:28:12 <Cale> mmm... VBA
20:28:26 <Cale> Are you using lots of global variables and unnecessary assignments?
20:28:51 <lispy> set foo = somefunction()
20:29:05 <lispy> and then it runs to that point and says, "Ooops, foo isn't defined."
20:29:12 <lispy> so you Dim foo as Blah
20:29:31 <lispy> then it runs to that point again and says, "Opps, somefunction didn't return an object"
20:31:05 <lispy> this is where i get frustrated and wonder why Excel can't just tell me that foo isn't defined and somefunction doesn't have the right return type?
20:31:22 <lispy> it's not undecidable, is it?
20:31:24 <skew> doesn't dynamic typing just make you feel so free?
20:32:12 <Cale> "Since FORTRAN will virtually eliminate coding and debugging ..." (Specifications for the IBM FORmula TRANslating System FORTRAN, November 10, 1954)
20:32:16 <Cale> ahaha
20:32:48 <lispy> ?quote largos
20:32:48 <lambdabot>  [on programming languages] "...and I'd rather not own as much rope as c/c++ gives you."
20:32:57 <lispy> skew: i feel that free ^^^^
20:32:59 <Cale> Dynamic typing combined with the need for static type declarations is awesome
20:33:08 <Cale> It's the best of both worlds!
20:33:40 <lispy> at least you can just say everything is a variant
20:33:53 <lispy> and then nothing matters
20:34:02 <lispy> oh, except for each loops still need objects
20:34:08 <lispy> which means they don't seem to work with collections
20:34:16 <lispy> or at least not the collections i tried to use
20:34:23 <Cale> just make a whole bunch of global variants named a0 through a100 and use those throughout the program. Never pass parameters explicitly.
20:35:10 <Cale> have functions which do crazy permutations on those 101 variables, like rotating them
20:35:43 <Cale> use those permutations in order to only ever explicitly refer to a0, a1 and a2
20:36:09 <lispy> Cale: yeah, i tried using recursion (omg!) and my program started crashing because the system call to get the directory contents couldn't deal with the recursion
20:36:17 <Cale> ahahahaha!
20:36:53 <lispy> fortunately i found taht you can programmatically call Excel's find files feature and it takes a boolean to control searching in subdirs
20:36:55 <lispy> so it was fixable
20:37:46 <lispy> my other option was to read the directory contents, sort it in a "collection" (the only non-array contrainer) and then iterate through it again going into the directories (so breadth-first search)
20:38:32 <lispy> s/sort/store/
20:39:37 <Cale> I love the fact that the language implementation actually actively prevents you from doing anything which would be considered the least bit smart.
20:41:23 <lispy> yeah
20:41:27 <lispy> i "love" that too
20:41:35 <lispy> and i'm pretty ticked off about it :)
20:41:58 <skew> how about writing COM components in Haskell?
20:42:15 <Cale> Write a Haskell -> VBA compiler
20:42:29 <skew> there uesd to be H/Direct and stuff
20:42:52 <Cale> It would only result in the slowest running programs ever :)
20:43:36 <Cale> But yeah, a proper way to call Haskell code from those kinds of applications would be good.
20:46:45 <Cale> "There's an old story about the person who wished his computer were as easy to use as his telephone. That wish has come true, since I no longer know how to use my telephone." (Bjarne Stroustrup)
20:56:22 <Cale> Wow, this pdf is suggesting that to do away with memory leaks, any given malloc in the code will just allocate space in a cyclic fashion between k slots, essentially blowing things away as it wraps around.
20:59:10 <palomer> how does that solve anything?
20:59:31 <Cale> By not allocating any more than k elements.
20:59:40 <Cale> and silently failing sometimes
20:59:50 <palomer> ????
20:59:56 <Cale> It's ridiculous
21:00:03 <palomer> the heap is limited anyways
21:00:17 <Cale> yeah, but the assumption is that k will be pretty small
21:00:35 <Cale> and you might never need those old values you allocated, so the program might still work
21:00:49 <palomer> what difference does cyclic allocation make?
21:00:50 <Cale> How's that for an insane perspective?
21:01:02 <palomer> oh, it will always allocate
21:01:07 <palomer> even if it's running into old memory?
21:01:13 <Cale> Like, rather than allocating new space after k mallocs, it returns the first pointer it returned.
21:01:23 <Cale> and cycles around
21:01:40 <palomer> so you're program might get screwed up
21:01:42 <Cale> yeah
21:01:44 <palomer> but at least it's using very little memory?
21:01:47 <Cale> yeah
21:02:31 <palomer> newpointer = (lastpointer+newmemoryneeded) % 5000; lastpointer = newpointer
21:03:45 <Cale> well, the idea is a little more complicated, each malloc in the code uses a different cycle
21:04:24 <Cale> and they have actually tried doing things like running allocation normally, and when the number of live objects gets too high, start switching to cycling them
21:07:06 <dolio> Good for low resource environments like planes and nuclear reactors. :)
21:07:24 <Cale> haha
21:08:01 <Cale> oh, another thing they do, rather than bounds checking, just silently fail to write anything out of bounds.
21:10:55 <dolio> I guess that's better than randomly killing other memory.
21:11:00 <dolio> Although they've re-added that.
21:16:09 <palomer> 	how about this
21:16:16 <palomer> every time you allocate more than you have
21:16:20 <palomer> your computer explodes
21:16:28 <palomer> that way, every one will be extra careful not to do it
21:19:45 <Cale> We could always go the epigram way of basically requiring the programmer to provide proofs of correctness before we'll even compile the thing :)
21:20:52 <palomer> my method is hardware expensive
21:20:58 <palomer> yours is programmer time expensive
21:21:00 <palomer> I like my way better
21:21:03 <Cale> hehe
21:21:17 <palomer> or maybe you could zap the person who wrote the code
21:21:18 <palomer> ZAP
21:21:43 <palomer> the firefox programmers will shake like they have tourettes!
21:21:54 <palomer> why does korean manga suck so much?
21:22:31 <Cale> The writers are too busy playing starcraft?
21:23:33 <palomer> oh my
21:23:40 <palomer> Cale said something genuinely funny
21:23:40 <Botty> lets make a functional web browser and represent the internet as a monad
21:23:48 <palomer> WHATS HAPPENING?
21:23:58 <palomer> the internet is a monad
21:24:01 <palomer> it was created by God
21:24:05 <palomer> who happens to also be a monad
21:24:18 <Botty> I'm a monad
21:24:50 <Cale> Botty: I've thought about doing that, it seems like a great idea for a library.
21:25:40 <Botty> the internet? yes, doesn't seem like a bad idea.  I still don't have a concrete grasp of monads, only theoretical.  haven't actually written my own yet
21:25:52 <palomer> the internet is a terrible idea
21:26:09 <palomer> I still can't believe Cale said something funnier than anything I've ever said
21:28:06 <palomer> a haskell browser would demonstrate the awesome speed you guys keep boasting aobut
21:28:07 <palomer> about
21:28:16 <palomer> (which, on my side of things, can never be felt)
21:28:32 <Cale> Botty: The web interaction state normally held by the browser -- so things like cookies, form interaction, etc.
21:28:48 <Cale> palomer: have you seen Data.ByteString?
21:28:59 <Cale> It's pretty cool, we're beating C programs :)
21:29:11 <palomer> the java programmers make similar claims
21:29:38 <palomer> it doesn't change the fact that haskell is as slow as frozen molasses
21:30:04 <Cale> actually, I think it might
21:30:21 * palomer just can't win
21:30:27 <Cale> Most of the slowness of Haskell programs is from the fact that strings are 12 times larger than ordinary.
21:30:57 <Cale> and are linked lists, so you can't really do some manipulations quickly
21:31:00 <palomer> but they're so convenient
21:31:14 <palomer> what does Data.Bytestring change?
21:31:24 <palomer> makes things faster but less convenient?
21:31:27 <Cale> yeah, Data.ByteString basically keeps all the convenience by providing the same interface
21:31:52 <Cale> but it implements lots and lots of fusion and does block IO
21:32:03 <palomer> you can map on it?
21:32:17 <Cale> yeah
21:32:21 <palomer> it implements the same typeclasses as List?
21:32:59 <Cale> there's no typeclass to use for that, but it implements operations with the same names, so you just import it qualified and stick qualifiers on the functions you use
21:33:30 <palomer> it doesn't implement any typeclasses at all?
21:33:47 <palomer> operations does not a useful type make
21:34:02 <skew> what typeclasses do lists implement that are actually useful with IO?
21:34:18 <palomer> who said anything about IO?
21:34:23 <Cale> Data ByteString
21:34:24 <Cale> Eq ByteString
21:34:24 <Cale> Monoid ByteString
21:34:24 <Cale> Ord ByteString
21:34:24 <Cale> Read ByteString
21:34:24 <Cale> Show ByteString
21:34:26 <Cale> Typeable ByteString
21:34:31 <Cale> just those
21:34:54 <skew> It's for replacing strings, not lists in general
21:34:56 <Cale> There's also Data.ByteString.Lazy, which uses L2-cache sized blocks
21:35:27 <palomer> if String continues to be [Char], then I don't think anything is going to change
21:35:34 <palomer> are you going to change that binding?
21:35:49 <Cale> Not yet, but it's almost a drop-in replacement.
21:36:08 <palomer> there's also the fact that functions I write of type [a] -> ... don't work with ByteString
21:36:23 <Cale> People have encountered things like 60x speedups using that library.
21:36:54 <Cale> Right, and you wouldn't want to use them with it, if you want performance. Cons recursion is slow for that.
21:37:08 <palomer> is slow for what?
21:37:18 <Cale> For manipulating strings.
21:37:33 <palomer> you mean ByteStrings?
21:37:39 <Cale> Well, sure.
21:38:12 <palomer> any recursive function manipulating ByteStrings will be slow?
21:38:13 <palomer> eh?
21:38:33 <Cale> Well, you can expect things which process character-by-character to be slow
21:38:47 <skew> any recursive function on String = [Char] will be slow
21:38:51 <Cale> Because the automatic program transformations in the ByteString library won't be as effective.
21:39:11 <Cale> and because that's sort of what makes [Char] slow in the first place
21:39:47 <palomer> automatic program transformations?
21:39:53 <palomer> so we won't need to think of ByteString?
21:40:10 <skew> it's like fusion
21:40:26 <skew> http://www.cse.unsw.edu.au/~dons/papers/fusion.pdf
21:40:28 <lambdabot> http://tinyurl.com/y6ln6n
21:47:56 <sjanssen> cons recursion isn't all that slow
21:48:15 <skew> it's a bit slow to be doing for each character
21:48:49 <sjanssen> skew: it isn't as if many ByteString algorithms work on more than character at a time
21:49:41 <skew> oh, recursing down a ByteString is probably faster than with String, at least if things are inlined
21:50:51 <sjanssen> I don't think inlining has any bearing on that
21:51:11 <Cale> yeah, the idea is that if you explicitly write out cons recursion, you've lost the high-level description of what's going on which lets you optimise
21:51:36 <sjanssen> ByteString should be as good or better than any list when writing recursively
21:51:50 <skew> sure it does, tail on a ByteString just makes a new value with a pointer one step further along, and a shorter length
21:52:04 <skew> without inlining some time would be wasted allocating them
21:52:17 <skew> with inlining it should come out close to a tight loop
21:53:54 <sjanssen> Cale: at least until some genius figures out an automatic transformation from recursive code to Stream transformations
21:54:21 <Cale> sjanssen: right.
21:54:53 <dons> you could always write your recursive pass on streams though
21:54:54 <Cale> sjanssen: I think it's at least as hard as deciding that some code implements matrix inversion and then optimising A A^(-1) x to x
21:55:12 <dons> unstream . myrecursivething . stream ;)
21:55:30 <Cale> (in the general case)
21:55:45 <sjanssen> Cale: sounds about right.  The key word in the sentence is "genius" ;)
21:55:49 <Cale> Maybe there are heuristics for turning things into foldrs and such.
21:56:12 <skew> maybe fusion rules could help?
21:56:15 <dons> but yeah, doing it automagickally sounds hard. i suspect there's been some thought about it, for foldr/build perhaps
21:56:17 <sjanssen> yeah, or a handful of cases that work for most problems
21:57:10 <dons> anyway, there's lots of room to keep improving the compiler
21:57:29 <dons> we've basically got a list of useful transforms to apply waiting to be implemented: the future is bright!
21:57:39 <skew> hmm, except they are not supposed to change the types
21:57:43 <dmead> hi guys
21:58:14 <dons> skew: but we can mechanically change the types now, with associated types
21:58:23 <dons> so a library can specify optimised representations under the hood
21:58:27 <sjanssen> dons: a list, eh?
21:58:32 <dons> that's hardly explored at all yet
21:58:47 <dons> its more user-land optimisations, like rewrite rules
21:58:57 <dons> so who knows what we'll be doing with that in the next 5 years
21:59:27 <skew> but a function written on ByteString that uses only a restricted set of operations could be changed to use streams instead
21:59:35 <skew> and I don't think that falls under associated types
21:59:38 <dons> family [a] .... data instance [!Word8] = ByteString or something
21:59:52 <dons> skew: oh yes, that's another thing entirely
22:00:23 <dons> and then there's parallel /DPH bytestrings...
22:00:40 <skew> and SIMD
22:00:52 <dons> hands up if you want your maps running on the GPU :)
22:00:56 <dons> right.
22:01:20 <dons> its just around the corner. there's either code, or the sketches of how do do this stuff, already underway
22:01:57 <dons> i really think this multicore world makes things very exciting for haskell hackers
22:01:57 <skew> is there any code out there for defining things generically over tuple, like classes for converting between tuples and HList, maybe?
22:02:22 <dons> just need to get a 16 core mips box.. mmm. xmas is soon...
22:03:11 <skew> with more concurrency, fewer people will laugh at us when we whine abuot how programming is so hard we need help from languages and compilers.
22:03:50 <skew> maybe some generic instances would help?
22:04:49 <sjanssen> skew: I tend to stay away from tuples . . . they kinda suck
22:05:07 <dons> skew, yeah, massive parallelism is going to be very disruptive
22:05:08 <skew> I'd like to be able to put together a Gen (some, arguments) and a some->arguments->(to,results) to get Gen (some,arguments,and,results)
22:05:33 <dons> it could really be an extinction like event, if the chip guys can get the big core #s out.
22:05:42 <dmead> dons
22:05:48 <dmead> check this out
22:05:50 <dmead> http://www.xprogramming.com/xpmag/dbcHaskellBowling.htm
22:05:53 <lambdabot> Title: Haskell Bowling, http://tinyurl.com/yndnpr
22:05:57 <dons> if you need to write a normal program that uses 80 cores, conventional imperative programming is just not going to cut it
22:06:04 <dons> you _have_ to use FP techniques
22:07:43 <skew> I'm trying to avoid boilerplate at this step where I combine a reference implementation and input generator to get test cases ready for export
22:08:06 <dons> dmead: ok. nice.
22:08:27 <dons> though the pattern matching is a bit ugly.
22:08:33 <dons> we need to school people better on good style
22:08:39 <dmead> yea you can do it nicer with case matching
22:08:44 <dmead> but i wanted to show recursion
22:08:49 <dmead> clearly
22:09:33 <dons> hehe "Dan's assertion, as I recall it, was that Haskell lets us express the program "in the way we think". On the contrary, what Haskell does in my opinion is let us express the program in the way Haskell thinks"
22:09:41 <dons> so True!
22:09:46 <sjanssen> this code smells a little funny
22:09:47 <dmead> hehehe
22:10:07 <dons> it helps if you already think like haskell
22:10:21 <dons> i have an endless supply of thunks in my brain, maybe that helps
22:10:26 <dons> so many things i'm going to do later
22:10:31 <dons> when my gf demands them
22:10:36 <dmead> lol
22:11:17 <sjanssen> do you demand that your gf forces requests via pattern matching?
22:11:29 <dmead> my advisor has convinced me that the fp style is just more natural
22:11:42 <skew> well, Haskell ~ Category Theory ~ Algebraic Topology ~ Quantum Gravity (If John Baez et. al. are on the right track)
22:11:49 <dons> sjanssen: i've a theory that haskell's use is growing outside of its traditional core of chalmes and oxford undergrads. and as a result people aren't getting trained in the best FP style as well. they're taking what they cann from the net.
22:11:56 <dons> s/chalmers/
22:12:06 <dmead> dons: i started in lisp
22:12:10 <dons> cool
22:12:14 <dons> another refugee!
22:12:19 <dmead> so some of my pattern matching isn't that great yet
22:12:26 <dmead> but really, when your approching the end of a list
22:12:29 <dmead> what else can you do?
22:12:34 <dmead> besides have patterns for it
22:12:40 <dons> dmead: oh, is that your code?
22:12:43 <dmead> yea
22:12:46 <dmead> in the article
22:12:48 <skew> do you really nead the x:y:z:[] case?
22:12:48 <dons> yay!
22:12:50 <dmead> thats my code
22:12:58 <dons> dmead++
22:13:06 <dmead> karma for me?
22:13:06 * dons adds this to the HWN.
22:13:09 <dmead> weee
22:13:10 <wolverian> "Recursive methods tend to be confusing, in my opinion." hrm. really?
22:13:24 <dmead> don't bust ron's balls too much
22:13:28 <dmead> he's an old fart
22:13:32 <dons> yeah, its fine
22:13:39 <wolverian> oh, maybe that explains it. :-)
22:13:44 <dons> thanks so much for taking up the challenge :)
22:13:56 <dmead> hehe i was totally in the seat of heat
22:14:04 <dons> dmead gets free beer all day!
22:14:08 <dmead> wheee
22:14:22 * dons `throw` beer >>= dmead
22:14:27 <dmead> lol
22:14:51 <dmead> catch (beer)
22:14:52 <dmead> drink
22:14:54 <dmead> =p
22:15:04 <dons> ?yow!
22:15:05 <lambdabot> Where do your SOCKS go when you lose them in th' WASHER?
22:16:04 <dmead> dons: whats HWN?
22:16:45 <dons> the haskell weekly news! :)
22:16:54 <dons> http://sequence.complete.org
22:17:05 <dons> (note the blog section)
22:17:52 <skew> oh, the last few rolls don't count on their own.
22:17:58 <sjanssen> dmead: your code looks very nice when you replace the if expressions with guards
22:18:10 <dmead> yea i haven
22:18:14 <dmead> t looked at guards yet
22:18:25 <dmead> i know it can be smaller
22:18:26 <dons> yeah, if is really only for inline conditionals. at the decl level always guards (or pattern guards) are better
22:18:42 <sjanssen> @where paste
22:18:42 <lambdabot> http://paste.lisp.org/new/haskell
22:18:50 <dons> sjanssen: want to clean up the code a bit? i might stick up a reply on planet.haskell
22:18:55 <dons> always good to spread the love :)
22:19:15 <dmead> show me some guard action =p
22:19:33 <dons> so basically this:
22:19:34 <lisppaste2> sjanssen pasted "guards, fiddle with alignment" at http://paste.lisp.org/display/29207
22:19:34 <dons> score (x:y:z:xs) = if  (x == 10)             then x + y + z +  score(y:z:xs)
22:19:35 <dons> becomes
22:19:54 <dons> score (x@10:y:z:xs) = x + y + z +  score(y:z:xs)
22:19:55 <dons> or something
22:20:02 <dons> if you really need guards, sjanssen can show you :)
22:20:10 <dmead> kk
22:20:23 <dmead> links me to where you posted this?
22:20:24 <dmead> i can't find it
22:20:30 <dons> --> http://paste.lisp.org/display/29207
22:21:04 <dmead> ahhh
22:21:05 <dons> those == should be k pattern,s, I reckon.
22:21:13 <dons> well, the first one
22:21:22 <dmead> how is that different from case of blah blah
22:21:39 <dons> sjanssen: but the type is now wrong? lists v tuples?
22:21:45 <dons> oh sorry.
22:21:48 * dons needs food
22:21:58 <dmead> where'd you put it on the hwn
22:22:01 <dmead> i don't see it =(
22:22:03 <skew> wizard needs food, badly
22:22:10 <dons> dmead: oh. it will be in the blog section next week
22:22:16 <dmead> kk
22:22:34 <dons> there's really a common pattern happening in this code, i wonder if there's a fold we could use
22:22:55 <dons> Cale: around? a puzzle for you.
22:23:02 <dons> unless sjanssen  gets it first
22:26:06 <dmead> yea you can defiantly simplify it
22:26:20 <skew> what kind of fold would you use?
22:28:06 <skew> defiantly simplify.
22:28:23 <dons> i'd use the right kind of fold
22:28:28 <Ulfalizer> defiant? :)
22:28:36 <Ulfalizer> is someone forcing you not to simplify?
22:28:52 <dmead> *definitely
22:28:59 <dmead> gtk spells
22:29:02 <dmead> badly
22:29:10 <dmead> err
22:29:12 <dmead> =p
22:29:18 <Ulfalizer> whatever :P
22:32:45 <sjanssen> I'm going to stand by my first attempt.  Adding k patterns or @'s just makes things more messy
22:33:55 <sjanssen> unless there's a handy abstraction I'm missing
22:41:14 <dons> nah, its fine.
22:42:01 <lisppaste2> skew annotated #29207 with "structural approach" at http://paste.lisp.org/display/29207#1
22:42:46 <dons> sjanssen: so what courses are you studying this sessoin?
22:42:49 <skew> "The Haskell would be much shorter even if it were extended to address those concerns", indeed
22:42:53 <dons> and how're they going?
22:43:41 <dons> nice skew
22:43:44 <sjanssen> dons: compiler construction is the only interesting one, it's going well
22:44:01 <dons> ?pl sum (take 2 (concat rest))
22:44:02 <lambdabot> sum (take 2 (join rest))
22:44:04 <dmead> after i did the write up for ron i went looking for other haskell versions
22:44:05 <dmead> i found this
22:44:07 <dmead> http://blog.moertel.com/articles/2006/04/05/the-bowling-game-kata-in-haskell
22:44:10 <lambdabot> Title: The Bowling Game Kata in Haskell, http://tinyurl.com/y7kvlx
22:44:19 <dmead> it's the shortest possible way i think
22:44:22 <dons> sjanssen: cool. what kind of compiler are you building?
22:44:29 <dons> dmead: oh, its the same puzzle?
22:44:34 <dmead> yes
22:44:42 <dons> ah yes!
22:44:45 <dmead> that guy does it in much less code
22:44:49 <dons> dmead, meet tmoertel
22:44:54 <sjanssen> dons: a compiler for a language called "StaticJava", but it's really closer to C
22:44:55 <dmead> ?
22:44:57 <dons> (the author hands you here ;)
22:45:01 <dons> grr
22:45:07 <dons> "hangs out here"
22:45:16 <dmead> ahh
22:45:18 <dons> i _really_ need some lunch. its 6pm now ...
22:45:19 <dmead> oh yea
22:45:20 <dmead> i didn't notice
22:45:25 <dmead> i do remember him now
22:45:35 <skew> is that actually much shorter?
22:45:47 <dons> so that bog was about him heading to the meeting you were at? but he went to the coffee shop instead?
22:45:48 <dmead> i think
22:45:50 <dons> s/blog/
22:45:53 <dmead> he's got some test code in here
22:45:55 <dons> must .. find ... sugar
22:46:10 <dmead> either way
22:46:15 <dmead> haskell totally beats java
22:46:35 <dons> tmoertel's is nice in the QuickCheck way he develops the code
22:47:42 <dmead> the HUnit stuff?
22:47:42 <dons> everyone seems to see immediately how expressive/dense haskell can be
22:47:51 <dons> dmead: the QuickCheck properties
22:47:57 <dons> (not HUnit)
22:48:06 <dmead> ah
22:48:11 <dons> "It might be amusing to try to do the same solution in, say, Ruby, which would probably be more compact and perhaps would cleave closer to the Haskell style"
22:48:21 <skew> tmoertel's bowling game solution just uses HUnit
22:48:24 <dons> i.e. by the end of the article he's talking about other languages trying to emulte haskell's richness
22:48:34 <dmead> ah yea
22:48:34 <dons> oh, am i thinking of a different article .. hmm..
22:48:52 <dons> ah, i was thinking of http://programming.reddit.com/goto?id=ons7
22:48:59 <lambdabot> Title: Introductory Haskell: Solving the Sorting-It-Out Kata
22:49:33 <dmead> gotcha
22:50:37 <dons> maybe haskell programmers should go around performing amazing programming feats for entertainment of geeks, like travelling yo-yo experts
22:50:45 <dmead> lol
22:50:49 <dons> "what me pull a monad out of my hat!"
22:50:58 <dmead> when i was doing it he was totally like
22:51:06 <dmead> "i don't think it's even possible to do this with recursion"
22:51:13 <dons> now, why don't we have instance Monad YoYo ...
22:51:14 <dmead> =p
22:51:16 <dons> dmead: heh!
22:51:39 <dmead> blah
22:51:42 <dmead> but anyway
22:51:55 <dmead> i've got a mutual recursion problem i've been working on for 2 weeks
22:52:02 <dmead> for my theorem prover
22:52:20 <dmead> if i can't fix it in another few days i'll post the problem and see what people think
22:52:43 <dons> you seen the demo theorem provers on haskell.org, btw?
22:53:49 <dons> http://haskell.org/haskellwiki/Libraries_and_tools/Theorem_provers
22:53:52 <lambdabot> Title: Libraries and tools/Theorem provers - HaskellWiki, http://tinyurl.com/kfmhl
22:54:01 <dmead> yeaa i don't wanna read them
22:54:03 <dmead> i'll be tainted
22:54:17 <dons> :)
22:54:51 <dons> tainted with the tableauxs and the h-o unification! its a disease!
22:55:02 <dmead> lol
23:12:11 <lisppaste2> skew annotated #29207 with "slightly tweaked tmoertel solution" at http://paste.lisp.org/display/29207#2
23:13:15 <kosmikus> morning
23:16:19 <dblhelix> ?yow
23:16:20 <lambdabot> This PORCUPINE knows his ZIPCODE ... And he has "VISA"!!
23:16:43 <dblhelix> ah, lambdabot's feeling better... good
23:16:43 <kosmikus> hi dblhelix, how's .uu ?
23:17:04 <dblhelix> kosmikus: cgn's noisy
23:17:18 <dblhelix> because of renovation and such...
23:17:22 <kosmikus> how long will the move take?
23:18:13 <dblhelix> if i understood it correctly another group is repatriating next week (from kruyt to cgn)... I'm not sure about the group that's in bbl now...
23:18:37 <dblhelix> but our corridor is in pretty good shape now...
23:19:21 <dblhelix> how's hcar?
23:19:22 <kosmikus> will the koffiekamer stay where it currently is?
23:20:41 <kosmikus> dblhelix: a bit more than 30 submissions so far. not bad for 3 days before the deadline ...
23:20:46 <dblhelix> I'm not sure, actually... I thought it was a temporary facilitation... but I kinda like it where it is now... just a few steps away...
23:21:14 <dblhelix> who's composed the generics entry, this time?
23:21:17 <kosmikus> but the 0-floor will not belong to cs anymore, right?
23:21:25 <kosmikus> dblhelix: no one
23:22:27 <kosmikus> I will send a final reminder to the mailing list today, to encourage a few more people to start writing.
23:22:28 <dblhelix> no, the 0-floor will house general admin...
23:22:56 <dblhelix> ah, well good luck with that... I'm off (meeting with jur)
23:23:11 <Cale> dons: http://programming.reddit.com/info/p66e/comments -- I chimed in here too :)
23:23:14 <lambdabot> Title: Are monads actually used in anything except Haskell ? (reddit.com), http://tinyurl.com/yhg87v
23:23:22 <kosmikus> dblhelix: ok, have fun
23:32:14 <lOkadin> can lambda calculus be expressed in terms of predicate calculus?
23:33:09 <lOkadin> oh it really doesn't matter nm
23:34:46 <lOkadin> is there somewhere I can get a list of all haskell syntax?
23:35:39 <dmead> http://haskell.org/tutorial/indextutorial.html
23:35:41 <dmead> there
23:35:42 <lambdabot> Title: Haskell 98 Index, http://tinyurl.com/vkur4
23:35:58 <skew> If you want something more comprehensive, http://haskell.org/onlinereport/ or http://darcs.haskell.org/ghc/compiler/parser/Parser.y.pp
23:36:00 <lambdabot> Title: The Haskell 98 Language Report
23:36:16 <dmead> skew
23:36:25 <dmead> is there some docs on how to trace functions in hugs?
23:37:13 <lOkadin> thanks :)
23:43:32 * Cale adds another post :) http://programming.reddit.com/info/p66e/comments/cp6u8?context=5
23:43:34 <lambdabot> Title: Are monads actually used in anything except Haskell ? (reddit.com), http://tinyurl.com/yzqzhx
23:43:49 <Cale> I really should probably just put this somewhere and link to it :)
23:47:54 <dons> yeah. so i think the summary is: smart people see that they're cool, but even if they get that they're not limited to IO, they don't quite see why state encapsulation is useful in a stateful language
23:48:09 <wolverian> what is the point of the ST monad? why not use IO?
23:48:17 <dons> so. .. people need to understand strong typing and polymorphism as well, before they really get it.
23:48:45 <wolverian> (sorry, I'm sure there is a point, I wasn't trying to degrade it :)
23:49:33 <dons> you can encapsulate a stateful computation inside pure code, with ST.
23:49:42 <wolverian> ah.
23:49:44 <dons> so that it behaves as a pure chunk
23:49:46 <dons> can't do that with IO.
23:49:50 <wolverian> thanks!
23:50:02 <skew> also, if you use ST you know the code is just using mutable variables, rather than formatting your hard drive
23:50:17 <dons> yeah. you just get tate. no state and the universe and everything.
23:51:35 <Cale> whee
23:51:50 <Cale> well, that was quite a bit of writing :)
23:52:29 <dons> Cale: i think monads have an even harder time than continuations. the masses don't really get continuations that well, unsurprising that monads, which are newer and need an even more expressive language, aren't widely used, or understood.
23:52:39 <Cale> yeah :)
23:52:49 <dons> *sigh*
23:52:53 <dons> but LINQ and C# give me hope
23:53:05 <Cale> Even though personally, I think I had an easier time understanding monads than continuations
23:53:06 <dons> and the perl6 guys probably have a decent monad implementation
23:53:11 <dons> yeah me too :)
23:53:16 <dons> audreyt: monads in pugs?
23:54:22 <Cale> Who is taw? I think I've seen them around.
23:56:54 <roconnor> @remember <skew> also, if you use ST you know the code is just using mutable variables, rather than formatting your hard drive
