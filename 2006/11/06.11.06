00:00:13 <dons> several people have had nhc running on the arm
00:00:43 <mwc> Ahhh, I don't have a compiler or anything for the ipaq... too bda
00:00:51 <mwc> Ugh, 3 am... Sleep must now.
00:06:53 <dons> oh, did people know about http://homepages.cwi.nl/~jve/cs/
00:06:55 <lambdabot> Title: Computational Semantics and Type Theory
00:07:15 <dons> full text (?) online
00:07:29 <dons> (with Haskell)
00:08:07 <merus> cool!
00:08:32 <dons> how did we not know about this/
00:08:56 * merus sighs as his CD-ROM drive slowly dies.
00:12:12 <merus> No mention of Wittgenstein in the section on games :(
00:21:14 <juhp> can someone remind me where to find yi-gtk again?
00:23:00 <dons> darcs get --partial http://www.cse.unsw.edu.au/~dons/code/yi+gtk
00:23:01 <lambdabot> Title: Index of /~dons/code/yi+gtk
00:23:04 <dons> ?where yi+gtk
00:23:05 <lambdabot> darcs get http://www.scannedinavian.org/repos/yi/
00:23:13 <hf> q
00:23:13 <dons> ?where+ yi+gtk http://www.cse.unsw.edu.au/~dons/code/yi+gtk
00:23:14 <lambdabot> Done.
00:23:38 <juhp> thanks guys
00:45:35 <kzm> dons: did you read the jve book?  Any opinion on it?
00:47:34 <kzm> Anybody know its license?
00:48:08 <dons> haven't read it yet.
00:49:01 <kzm> Looks good, but I'm just slightly hesistant to print 320 pages on our printer... :-)
00:50:46 <dons> well, that's what pdf viewers are for :)
00:50:55 <dons> save the trees, man!
00:51:01 <juhp> and glasses ;o)
00:51:07 <kzm> Burn the trees!
00:51:27 * kzm was carrying firewood until 1:30 am last night...
00:52:42 <juhp> lol
00:52:45 <kzm> Besides, my employer doesn't like it when I scribble in the margins of a PDF.  Even if I use a whiteboard marker.
00:53:42 <kzm> From an environmentalist perspective - it'd be better to use the trees before burning them, though.  For printing PDFs for instance.
00:58:30 <dons> heh
01:07:57 * therp always used to have a bad conscience when printing PDFs, until he read the skeptical environmentalist
02:03:09 <dons> ?yow!
02:03:10 <lambdabot> This PIZZA symbolizes my COMPLETE EMOTIONAL RECOVERY!!
02:46:27 <Smokey`> hmm, does haskell have anything similar to a ternary operator?  or do I just have to nest let ... in / ... where statements where possible? :/
02:46:45 <Smokey`> mmm, not that you can nest them, heh
02:47:02 <Cale> if p then x else y
02:47:25 <Cale> and you shouldn't have to nest lets that you don't want to
02:47:43 <dons> > let x = 1 ; y = 2 ; z = 3 in z + y * x
02:47:45 <Smokey`> hmm, how I missed if/else statements in the haskell tutorial is beyond me.
02:47:45 <lambdabot>  5
02:47:56 <dons> > (if True then 1 else 2) + 3
02:47:57 <Cale> they aren't statements, but expressions
02:47:58 <lambdabot>  4
02:48:39 <Smokey`> ty Cale/dons :)
02:48:52 <dons> > (case True of True -> 1 ; _ -> 2) + 3  -- its all let and csae anyway
02:48:53 <lambdabot>  4
02:49:16 <dons> new domain xerox ?
02:50:19 <kzm> Read the first two chapters of the book - easy and clear so far.
02:50:38 <dons> cool. kzm, want to review it for the HWN??
02:50:44 <kzm> No. :-)
02:50:46 <dons> just a pragraph or two..
02:50:53 <dons> or some notes..
02:50:55 <kzm> Okay, you talked me into it.
02:51:01 <dons> yay!
02:51:03 <kzm> We'll see.
02:51:12 <dons> kzm++ and more if you can send in 2 paragraphs on it
02:51:16 <kzm> I have some real work I need to do, too.
02:51:19 <kzm> 1+/par?
02:51:29 <dons> deal!
02:51:59 <Igloo> kzm: Do an odd number of paragraphs. Then he'll have to implement fractional karma!
02:52:38 <kzm> I don't know if I'm qualified.  But...I guess you get what you pay for. :-)
02:52:41 <dons> just think of all the fromIntegrals I'd need..
02:52:50 <dons> that's the spirit!
02:52:53 <xerox> Hiya dons.
02:53:05 <xerox> yaxu started blogging, you saw?
02:53:16 <dons> oh?
02:54:26 <dons> ?users
02:54:26 <lambdabot> Maximum users seen in #haskell: 265, currently: 232 (87.5%), active: 25 (10.8%)
02:54:55 <xerox> I'm not sure I have it in the backlog...
02:57:12 <xerox> http://doc.gold.ac.uk/~ma503am/alex/haskellmusic
02:57:14 <xerox> There you go.
02:57:17 <lambdabot> Title: Haskell music | Alex McLean, http://tinyurl.com/y75x5u
02:59:14 <merus> That's pretty l33t.
03:00:14 <dons> so so cool
03:00:26 <dons> ?seen yaxu
03:00:27 <lambdabot> I saw yaxu leaving #haskell 10h 51m 20s ago, and .
03:02:01 <psnl> ?seen ndm
03:02:02 <lambdabot> I saw ndm leaving #ghc, #haskell, #haskell-blah and #haskell-overflow 8h 39m 31s ago, and .
03:02:05 <ski> @keal
03:02:07 <lambdabot> i cant think anymore
03:03:22 <kzm> keal?
03:03:28 <ski> yes
03:03:37 <psnl> @keal
03:03:38 <lambdabot> my proof show math is broken right now
03:03:43 <ski> (:
03:03:58 <kzm> @seen keal
03:03:58 <lambdabot> I haven't seen keal.
03:04:11 <kzm> I must have missed something.
03:04:12 <ski> keal's been both in here and in #math
03:04:31 <psnl> keal; the proof that no matter how daft you can be, there is always someone dafter
03:04:39 <dons> heh
03:04:45 <ski> (istr he was schizophrenic)
03:04:45 <dons> http://programming.reddit.com/info/pl6u/comments
03:04:50 <lambdabot> Title: Livecoding music with Haskell (reddit.com), http://tinyurl.com/y5e7rq
03:05:09 <kzm> psnl, somehow I find that a relief.  Should I be worried?
03:05:12 <dons> i'd really like to see this link into Haskore somehow.
03:05:17 <ski> are ya flodding reddit with haskell ?
03:05:25 <dons> one per day, if new things emerge
03:05:34 <ski> cool
03:05:36 <flux__> hm, can you run background threads within ghci?
03:05:40 <dons> if nothing new happens, then I'm not submitting
03:05:43 <dons> flux__: yeah
03:05:53 <dons> (I think -- pretty sure i've done that with the irc bot)
03:06:45 <dons> livecoding sound in an FP language is *news* I think.
03:06:56 <dons> it breaks a few assumptions I had about how that would work
03:07:15 <ski> what's livecoding ?
03:07:18 <earthy> dons: why?
03:07:24 <earthy> it's been done
03:07:36 <dons> music happening live , and you're tweaking the code on the fly
03:07:44 <earthy> using hs-plugins, yeah
03:07:50 <dons> earthy: oh i was thinking compilation errors would really break the rhythm :)
03:08:03 <earthy> ah, but it doesn't quite work that way ;)
03:08:06 <ski> dons : like generating graphics live, instead of showing prerendered data ?
03:08:13 <earthy> see http://www.youtube.com/watch?v=eLS6GHXWMpA
03:08:19 <dons> yeah, so i see. you have latencies and timestamps and so on
03:08:46 <flux__> there was a related demo on doing something like that at research.microsoft.com, but with F# and directx
03:08:47 <dons> ski, yeah, I guess (?). seafood did that with Pan and also tried it with sound
03:08:50 <flux__> it was neat
03:09:02 <earthy> ski: livecoding is generating music with code edited on the fly
03:09:07 <earthy> ski: see the demo ;)
03:09:13 <dons> its a nice domain: you get to use haskell EDSLs, rapid prototyping .. all the fun stuff
03:09:16 <xerox> Can you hear sound in the demo?
03:09:43 <flux__> earthy, hm, where?
03:09:52 <flux__> oh, never mind
03:10:03 <dons> yeah, same guy earthy :)
03:10:29 <dons> the youtube one is yaxu too, who was here yesterday.
03:10:35 <earthy> yeah, but to me it doesn't count as news anymore ;)
03:10:49 <dons> ah well. it didn't get publicised at the time afaik (?)
03:10:50 <earthy> saw it months ago
03:10:59 <earthy> possibly not
03:11:20 <dons> looks like he's decided to use haskell for his post grad work on this, so that's great
03:11:28 * earthy nods
03:12:02 <dons> carry on the music-in-haskell flame from haskore ..
03:12:42 * ski wonders how to run the demo
03:13:26 <dons> the flash one?
03:13:43 <ski> oh, the flash was the demo ..
03:24:27 <xerox> Hiya bringert.
03:24:32 <bringert> hi xerox
03:30:00 * JKnecht just squatted a domain and wonders how quickly it's propagated
03:30:41 <JKnecht> meansofproduction.biz
03:31:16 <Cale> It's not resolving here
03:31:55 * bringert goes out looking for german fast food
03:32:40 <JKnecht> you're in toronto?
03:32:54 <dons> http://meansofproduction.biz
03:33:00 <dons> nope. lambdabot doesn't seem to know about it
03:33:42 <dons> though I see: Domain Registration Date:                    Mon Nov 06 11:17:03 GMT 2006 :)
03:33:47 <JKnecht> well it's less than a hour old but is routing here
03:34:09 <dons> is that what, 15 minutes ago?
03:35:47 <JKnecht> should be pretty immediate, at least in eastern North America; toronto only about a 150 clicks from here should be about same
03:36:27 <JKnecht> dons: your in AU, no?
03:36:33 <dons> yep
03:36:33 <JKnecht> you're
03:37:29 <JKnecht> the records propagate immediately but some authority stuffs take closer to the full 72 hours I think
03:38:10 <Jedi_Amara> it hasn't propagated here yet
03:38:26 <Jedi_Amara> (vic)
03:38:47 <JKnecht> BC?
03:38:58 <Jedi_Amara> au
03:39:23 * JKnecht <-- will chill.
03:50:35 <kzm> To use binary - should I rip it out of lambdabot?  Is there a download?
03:50:49 <kzm> That is (New)Binary.
03:51:14 <dons> ?where NewBinary
03:51:15 <lambdabot> darcs get http://www.n-heptane.com/nhlab/repos/NewBinary
03:51:24 <dons> or check the libraries and tools page under 'data structures' iirc
03:51:33 <dons> the lambdabot one has been modified and specialised
03:51:52 <dons> hmp3 has a good one too
03:51:54 <dons> ?where hmp3
03:51:55 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
03:52:18 <kzm> Modified and specialized generally enough for my use? :-)
03:55:03 <kzm> whine, whine: I wish ghc would come with dummy packages so that .cabal files don't need to be so ghc-version dependent.
03:55:39 <dons> I think NewBinary would be ok, but grabbing the one from hmp3 might be easier
03:55:55 <dons> it's missing some instances (that you can add back from NewBinary)
03:56:21 <Igloo> kzm: Dummy packages?
03:56:56 <blakkino> there is a good book for learning haskell?
03:57:14 <blakkino> (not an introduction.. somethings that at least try to go from start to end..)
03:57:24 <dons> blakkino: yep. start on http://haskell.org
03:57:25 <dons> also:
03:57:25 <lambdabot> Title: Haskell - HaskellWiki
03:57:27 <dons> ?where yaht
03:57:27 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
03:57:41 <kzm> Igloo, uhm - well, NewBinary specifies that it depends on 'lang', which seems to have gone away for 6.6.
03:57:47 <dons> blakkino: also, we have #haskell.it for italian speakers :)
03:58:02 <dons> blakkino: http://haskell.org/haskellwiki/Books_and_tutorials
03:58:02 <xerox> hey!
03:58:05 <kzm> So it'd be nice if 6.6. simply ignored the dependency, instead of requiring me to edit the .cabal file.
03:58:05 <lambdabot> Title: Books and tutorials - HaskellWiki, http://tinyurl.com/vqzky
03:58:12 <dons> xerox: well if you're not going to pimp it ...
03:58:21 <xerox> Vieni su #haskell.it!
03:58:29 <dons> :)
03:58:38 <dons> ?babel it en Vieni su #haskell.it
03:58:39 <lambdabot>  You come on # haskell.it
03:58:45 <dons> close enough
03:59:12 <xerox> ?babel en it pimp it
03:59:13 <lambdabot>  pimp esso
03:59:23 <dons> heh
03:59:28 <xerox> 0.o
03:59:33 <merus> alas -.-;
03:59:48 <xerox> blakkino: cosa ti porta su #haskell?
04:02:41 <dons> ?users
04:02:42 <lambdabot> Maximum users seen in #haskell: 265, currently: 229 (86.4%), active: 25 (10.9%)
04:02:47 <dons> ?users #haskell.it
04:02:48 <lambdabot> Maximum users seen in #haskell.it: 6, currently: 2 (33.3%), active: 1 (50.0%)
04:02:52 <dons> ?users #haskell.es
04:02:52 <lambdabot> Maximum users seen in #haskell.es: 13, currently: 9 (69.2%), active: 1 (11.1%)
04:02:56 <dons> ?users #haskell.se
04:02:56 <lambdabot> Maximum users seen in #haskell.se: 12, currently: 8 (66.7%), active: 1 (12.5%)
04:03:01 <xerox> Aw.
04:03:06 <dons> ?users #haskell.de
04:03:06 <lambdabot> Maximum users seen in #haskell.de: 2, currently: 2 (100.0%), active: 0 (0.0%)
04:03:16 <dons> ?users #haskell.fi
04:03:16 <lambdabot> Maximum users seen in #haskell.fi: 6, currently: 6 (100.0%), active: 2 (33.3%)
04:03:21 <dons> busy!
04:03:33 <dons> ?users #haskell.jp
04:03:33 <xerox> Italy beats Germany, but is beaten by Finland, Spain, and Sweden :(
04:03:33 <lambdabot> Maximum users seen in #haskell.jp: 4, currently: 5 (125.0%), active: 0 (0.0%)
04:03:42 <xerox> AH the Japanese too :(
04:03:53 <dons> ?users #haskell.fr
04:03:53 <lambdabot> Maximum users seen in #haskell.fr: 1, currently: 1 (100.0%), active: 0 (0.0%)
04:04:00 <xerox> HA!
04:04:00 <dons> (they all use ocaml)
04:04:10 <xerox> haha
04:04:12 <dons> ?users #haskell.hr
04:04:13 <lambdabot> Maximum users seen in #haskell.hr: 3, currently: 2 (66.7%), active: 1 (50.0%)
04:04:19 <xerox> uh.
04:04:22 <xerox> Where's that?
04:04:28 <dons> croatian speakers
04:04:38 <xerox> Eastern Europe.
04:04:41 <int-e> @users #haskell.de
04:04:41 <lambdabot> Maximum users seen in #haskell.de: 2, currently: 2 (100.0%), active: 1 (50.0%)
04:04:49 <int-e> easy 50%.
04:04:53 <dons> heh
04:04:56 <dons> new record!
04:04:56 <xerox> hehe
04:05:06 <xerox> one shall be lambdabot
04:05:17 <int-e> lambdabot is the other user.
04:05:24 <gour> dons: is it possible that eg. 'where paste' in #haskell.hr paste in proper channel?
04:05:43 <dons> hmm. example?
04:05:59 <xerox> you want to ask chandler, gour
04:06:16 <dons> ah, you mean the lisppaste?
04:06:30 <gour> dons: invoking where paste would paste in haskell not haskel.hr
04:06:32 <Igloo> Does lambdabot log these numbers, dons?
04:06:48 <dons> Igloo: it logs the maximums
04:07:02 <dons> gour: hmm 'where paste'? what do you mean?
04:07:04 <dons> ?where paste
04:07:05 <dons> ?
04:07:05 <lambdabot> http://paste.lisp.org/new/haskell
04:07:15 <Igloo> Oh, the currents might be interesting too
04:07:18 <gour> dons: but try that in #haskell.hr
04:07:39 <dons> ah, so you mean lisppaste sends the result to the wrong channel?
04:07:50 <gour> right
04:08:17 <xerox> dons: not only
04:08:25 <gour> just imahine flood from all haskell.xx channels
04:08:33 <xerox> dons: does @where paste say sial.pbot.whatever/perl6 in #perl6?
04:08:55 <dons> hmm?
04:09:01 <dons> i'm not sure what it does in #perl6 ...
04:10:09 <dons> ?users #haskell.de
04:10:10 <lambdabot> Maximum users seen in #haskell.de: 2, currently: 2 (100.0%), active: 1 (50.0%)
04:10:54 <xerox> dons, I think his point is that @where uses a static database?
04:11:05 <xerox> I mean, hardcoded strings
04:11:09 <dons> yeah
04:11:14 <dons> it doesn't change based on the channe
04:11:15 <xerox> They are not channel-dependent
04:11:18 <dons> right
04:11:28 <dons> so @where paste in perl6 gives you #haskell :)
04:11:30 <dons> ah well
04:11:38 <xerox> and so does on haskell.hr
04:11:41 <dons> yes
04:12:34 <gour> hmm, check http://paste.lisp.org/channels
04:13:24 <dons> right. so its not like there's a #haskell.hr to paste to , as far as lisppaste knows
04:15:48 <gour> dons: should i email to get included?
04:15:52 <dons> you could
04:15:55 <gour> ok
04:16:20 <dons> and we can add an entry for paste.lisp.org/*/haskell.hr  to the where database
04:16:31 <int-e> . o O ( @where+ paste lisppaste, url )
04:16:43 <dons> good idea
04:17:33 <kzm> ?users #haskell.no
04:17:33 <lambdabot> Maximum users seen in #haskell.no: 1, currently: 0 (0.0%), active: 0 (NaN%)
04:17:41 <kzm> Whee!
04:17:53 <dons> ?join #haskell.no
04:17:58 <dons> ?users #haskell.no
04:17:58 <lambdabot> Maximum users seen in #haskell.no: 0, currently: 2 (Infinity%), active: 1 (50.0%)
04:18:18 <kzm> Hmm... getting crowded.
04:18:21 <dons> heh
04:18:30 <dons> kzm, now its your duty to recruit
04:19:22 <dons> and all the people in the #haskell.* channels should look at what the #haskell.es guys have done in translating the wiki ... http://haskell.org/haskellwiki/Es/Haskell
04:19:24 <lambdabot> Title: Es/Haskell - HaskellWiki
04:19:30 <dons> hint hint ..
04:19:32 <dons> :)
04:20:32 <dons> cool, so we have .no .se and .fi
04:21:18 <roconnor> http://www.lcc.uma.es/~blas/pfHaskell/gentle/intro.html has a broken link
04:21:20 <dons> just need the estonian guys to get their act together :) where's giksos ...
04:21:20 <lambdabot> Title: Una introducción agradable a Haskell: Introducción, http://tinyurl.com/y8eb86
04:21:50 <dons> ah yes
04:22:31 <int-e> @users #haskell_ru
04:22:31 <lambdabot> Maximum users seen in #haskell_ru: 2, currently: 1 (50.0%), active: 0 (0.0%)
04:22:44 <dons> should be #haskell.ru realy
04:27:23 <SamB_XP> you could ask the one user to move, reconfigure lambdabot (and manually relocate her for this session), and ask that person to move...
04:27:26 <SamB_XP> er.
04:27:28 <SamB_XP> wait
04:27:41 <pejo> About translations - don't most programmers speak (read) english quite well?
04:27:45 <SamB_XP> I hate it when I forget what I've said and what I haven't said yet.
04:27:52 <dons> most european ones do, pejo
04:28:03 <dons> however, i'd *really* like to see the .jp guys do some translations
04:28:10 <SamB_XP> one of those things about asking the user to move was meant to say "get a redirection set up"
04:28:24 <dons> there's huge numbers of web pages about haskell written in japanese, and 2 textbooks, but we hardly ever hear from those guys
04:28:54 <dons> and it makes sense for the big language groups to translate, like spanish. that helps a lot of people
04:29:08 <dons> we probably should have chinese and japanese, since that's a lot of non-english speaking hackers
04:29:24 <pejo> dons, ah. Was pondering russia/estonia/etc, didn't think of Japan/China.
04:29:33 <dons> yeah, russian would be another.
04:29:51 <dons> i.e. a huge group of hackers that often don't come across the the english channels
04:30:12 <dons> i should ask bulat, he was interested in some translation efforts
04:30:15 <pejo> There are? Guess we should learn russian.
04:30:39 <pejo> dons, he's from russia?
04:30:44 <dons> Bulat, yeah.
04:30:45 <SamB> hmm, isn't chinese (in its written form, anyway) one of those "trade languages" or whatever?
04:31:25 <dons> the pugs guys have a nice dual translation going, and they have a lot more active chinese-speaking hackers that haskell seems to
04:31:33 <dons> s/than/
04:31:54 <dons> so it would be worth it, but takes motivation.
04:32:18 <pejo> SamB, don't think the written chinese will help the guys from japan that much.
04:32:32 <pejo> But still, 1 billion or whatever - quite a few users.
04:33:14 <SamB> pejo: true...
04:34:26 <JKnecht> pejo: actually it might. Kanji and Chinese are essentially the same character set
04:36:57 <JKnecht> (in China they're called Hanzi)
04:39:47 <SamB> well, but, how come Ranma's father can't read chinese?
04:40:31 <pejo> JKnecht, I avoid reading norwegian/danish texts, and those are much more related than just the same character set. :-)
04:42:44 <dons> heh
04:44:55 <Baughn> Is there such a thing as first-class patterns? That is, can I conveniently package up a pattern, pass it into a function and match against it?
04:45:01 <SamB> @docs Test.QuickCheck
04:45:02 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/QuickCheck/Test-QuickCheck.html
04:46:01 <bringert> Baughn: not really.
04:46:25 <bringert> you can possibly fake some of it with (a -> Maybe b) functions
04:46:58 <Baughn> I can say '\x -> case x of <whatever> -> true otherwise false', but that is not exactly convenient
04:46:59 <bringert> like Control.Exception.catchJust
04:48:18 <dons> yeah, so you can package up a function that performs the match
04:49:19 <SamB> what are you writing?
04:50:12 <roconnor> SamB, what's the status of the ``bit shift inline'' patch?
04:50:23 <roconnor> still fish is broken and that's it?
04:50:45 <kzm> dons: what is the point of openBinIO (it takes a parameter _mod which is unused, AFAICT)?
04:51:34 <Baughn> dons: Still, that's not very efficient. I'd like to avoid writing noticably more code than just the match itself - and in some cases I'd like to just pass /part/ of the match
04:51:41 <Baughn> dons: First-class types would be nice
04:51:42 <dons> kzm, where's that? in newBinary?
04:51:59 <dons> Baughn: yeah, there's a couple of papers around on first class patterns
04:52:03 <dons> i comes up about once a year
04:52:17 <kzm> dons: yes.  And in hmp3's Binary.hs
04:52:43 <kzm> There's openBinIO_ without this argument - appears to just binarize a handle.
04:53:11 <dons> i don't know :) i can only imagine its legacy from NewBinary
04:53:29 <dons> note i even had typeOf infer a silly type for it, openBinIO :: Handle -> t -> IO BinHandle
04:53:37 <roconnor> haskell does binary IO?
04:53:39 <dons> pretty sure that's not a phantom or anything special
04:53:49 <dons> roconnor: of course (?)
04:53:54 <roconnor> amazing
04:53:57 <dons> why?
04:54:11 <roconnor> I don't ever recall doing binary IO in haskell
04:54:13 <kzm> openBinIO_ h = openBinIO h (error "..")
04:54:28 <dons> roconnor: oh its really easy. just a specialised version of Read/Show
04:54:35 <dons> that has put/get, for the Binary class
04:54:48 <dons> instead of producing strings, it dumps binary data to a hande
04:54:51 <dons> le
04:55:05 <dons> kzm: legacy
04:55:10 <dons> if in doubt ... "legacy'
04:55:50 <dons> ?google the bits between the lambdas binary
04:55:55 <lambdabot> http://portal.acm.org/citation.cfm?id=286860.286872
04:56:25 <dons> (there's a paper with that title describing the approach, it goes waaay back to haskell 1991 iirc)
04:56:41 <Baughn> ..now there's a site that should be filtered out
04:57:55 <pejo> Baughn, portal.acm.org? Why?
04:58:23 <Baughn> pejo: Not everyone has a subscription, and the first non-acm site works just fine
04:58:35 <dons> the subscription thing sucks, yeah.
04:58:50 <dons> also, haskell papers live on haskell.org under the 'research papers' link
04:59:01 <dons> often you'll find it there
05:00:12 <kzm> dons: hmp3 isn't updated for 6.6?
05:00:26 <dons> not yet. i should do that
05:00:34 <dons> should be an easy job (just the cabal file)
05:00:41 <dons> hmm. maybe i already put in a 6.6 .cabal file?
05:01:24 <kzm> I just removed the fps dependency.
05:01:38 <kzm> building now.  However, I got a parse error from Binary.hs...?
05:01:46 <kzm> (in ghci, now while building)
05:02:23 <kzm> Binary.hs:191:45: parse error on input `)'
05:02:58 <kzm> Relevant lines:
05:03:00 <kzm>    190  newFastMutInt = IO $ \s ->
05:03:01 <kzm>    191    case newByteArray# size s of { (# s', arr #) ->
05:03:02 <kzm>    192    (# s', FastMutInt arr #) }
05:04:15 <dons> missing -cpp? not sure, looks ok
05:04:24 <araujo> morning
05:04:28 <kzm> No, without -cpp it fails much earlier :-)
05:05:01 <kzm> And anyway, it builds nicely with cabal.
05:07:41 <kzm> Ah, just needs -fglasgow-exts
05:08:37 <dons> ok. good. so its just the fps dep?
05:09:40 <kzm> Seems to be, yes.
05:09:55 <kzm> Again: virtual packages in ghc-6.6, please.
05:10:29 <dons> how about conditional cabal?
05:11:15 <kzm> Well - that way you'd only need to update it in one direction, at least.  I'd still prefer to not have a moving target.
05:11:49 <kzm> BTW, isn't it a good idea to put in pragmas for flags (-fglasgow-exts -cpp)?
05:12:17 <dons> should be yeah. unless its in the .cabal file
05:12:25 <dons> which i guess it is?
05:12:27 <Igloo> I'd prefer extensions listed in the cabal file, personally
05:12:44 <dons> me too :)
05:12:59 <dons> only hurts when you're ripping code out of one package, to put into another
05:13:20 <dons> extensions:          CPP, ForeignFunctionInterface
05:13:48 <Igloo> It's a bit unfortunate you then have to apply an extension too all modules or none, but that's not really hugely worse than having to apply it to all functions in a module or none
05:13:50 <pejo> Well. The ripping code is work of a programmer, who should arguably have some knowledge about it.
05:15:35 <kzm> And it hurts when you try to experiment with ghci.
05:15:54 <kzm> I guess one should read the .cabal file before playing.
05:15:58 <Igloo> Ah, interesting
05:16:33 <Igloo> Maybe you should be able to "ghci foo.cabal"
05:17:04 <kzm> Or have :l Foo check any .cabal files for extensions?  Recursively up the directory tree? :-)
05:17:43 <Igloo> That would be easier were it not for the ability to tell cabal your source is in some subdirectory
05:17:50 <kzm> Usually, ghci is good at producing sensible error messages ("use -fglasgow-exts if you want to..")
05:18:33 <dons> hey yaxu
05:18:36 <kzm> (but not in this case).  Well, never mind, I got it now.
05:18:51 <yaxu> hey dons
05:19:08 <kzm> And the nice thing about ripping out somebody else's code, is that you can change the else's policy on these things :-)
05:19:17 <Igloo> Or maybe specifying the extension in the cabal file shouldn't actually turn them on, but merely allow them to be turned on by LANGUAGE pragmas?
05:19:28 <dons> yaxu: http://programming.reddit.com/info/pl6u/details :)
05:19:29 <yaxu> dons: did you see my blog entry?  doesn't say much, will continue the thread in a couple of days
05:19:32 <lambdabot> Title: Livecoding music with Haskell (reddit.com), http://tinyurl.com/yg5svv
05:19:59 <yaxu> ah :)
05:20:11 <earthy> yeah, cool stuff that
05:20:34 <earthy> now, to integrate it with the dance stuff for visualisation...
05:21:03 <dons> and a pan graphics/video mixer
05:21:08 <Syzygy-> Oooooohhh... Is this ... yeah, it is Alex.
05:21:16 <Syzygy-> Neat.
05:21:24 <Syzygy-> I gotta sit down with his framework at some point.
05:21:35 <yaxu> Syzygy-: what, feedback.pl?
05:21:59 <Syzygy-> yaxu: Nah, I played with feedback.pl years ago... About the same time I got involved in cleaning up the ChucK codebase
05:22:34 <Syzygy-> But I got him to give me his code for juggling livecoding in Haskell a while ago, and I'd like to sit down, tweak it, mix in Haskore and Supercollider and then get back to livecoding again...
05:22:47 <yaxu> Syzygy-: i am him :)
05:22:52 <Syzygy-> Whoa.
05:22:54 <Syzygy-> Hey there.
05:22:56 <dons> Syzygy-: you know who you're talking to? :)
05:22:57 * Syzygy- is Mikael...
05:22:57 <yaxu> hello
05:22:58 <dons> hehe
05:23:10 <Syzygy-> dons: I had no idea whatsoever. Wasn't that clear?
05:23:31 <dons> I thought "Is this ... yeah, it is Alex" was directed at yaxu, in aroundabout way :)
05:23:44 <Syzygy-> Nono... That was directed at the link posted...
05:23:47 <dons> heh
05:24:19 <yaxu> Syzygy-: my newer code is talking to supercollider
05:24:21 <kzm> One problem with Binary is that it is based on some old NHC stuff, and the original source must be cited.  Does that preclude me from distributing a program using it under the GPL?
05:24:24 <Syzygy-> yaxu: You wouldn't happen to have the youtube clip in some .. non-flash format somewhere? I cannot persuade my Firefox/Flash to play nice with the rest of my sound system, so anything in flash runs soundlessly...
05:24:37 <Syzygy-> yaxu: Have you been looking at Haskore anything?
05:24:43 <yaxu> Syzygy-: well it is pretty trivial to send OSC to supercollider
05:24:54 * Syzygy- glanced at it recently, and was VERY inspired by what I saw...
05:24:58 <dons> kzm, its part of ghc too, which is BSD licensed
05:25:04 <yaxu> Syzygy-: i thought i had it somewhere but can't find it
05:25:10 <dons> so GPL should be fine.
05:25:11 <yaxu> (a .mov)
05:25:11 <Syzygy-> Though it does kinda assume a rather classical view on music...
05:25:23 <Syzygy-> .mov I could feed to mplayer, and thus wathc...
05:25:30 <yaxu> Syzygy-: i haven't looked at haskore yet
05:25:34 <kzm> dons, okay.  Let's hope Malcolm and Colin won't sue me :-)
05:25:51 <dons> yeah, Haskore comes from Hudak's jazz improv stuff , doesn't it?
05:25:57 <Syzygy-> Possibly.
05:26:04 <yaxu> Syzygy-: i'm really inspired by BP2 at the moment, which assumes a different view
05:26:15 <dons> (there's a famous april 1 joke from 1991 where hudak anounces he's stepping down from working on haskell, to take up live jazz)
05:26:27 * Syzygy- 'll probably try to raise the issue of livecoding+haskore with Henning Thielemann among other stuff in Leipzig, early december...
05:27:02 <mentomorph> Hi, I'd like to make my first monad but I get an error msg... Can u help me here?`
05:27:02 <mentomorph> type Program a = Int -> Int
05:27:02 <mentomorph> instance Monad Program where ....
05:27:02 <mentomorph> Type synonym `Program' should have 1 argument, but has been given 0
05:27:27 <Syzygy-> mentomorph: Is Program parametrized by some other type?
05:27:37 <psykotic> "A retired veteran and candidate for Oklahoma State School Superintendent says he wants to make schools safer by creating bulletproof textbooks."
05:27:40 <Syzygy-> i.e. what is the a in your > type Program a = Int -> Int
05:27:46 <dons> if you think of monads as containers, they have to contain some element type
05:27:57 <dons> like [a] or IO a
05:28:01 <mentomorph> It'll be IO
05:28:28 <Syzygy-> So you'll want instance Monad Program IO ... or instance Monad Program a ... or something along those lines
05:28:32 <dylan> psykotic: interesting! I put a very thick piece of bullet-proof plexiglass in my backpack, on the off chance someone tries to shoot me in the back at college.
05:28:43 <dons> dylan: oh, good idea.
05:29:03 <mentomorph> that doesent work either
05:29:11 <dons> mentomorph: if you get stuck further, we may need to see the code
05:29:14 <dons> lisppaste2: url
05:29:15 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
05:29:25 <psykotic> dylan, me, i just punch people preemptively.
05:29:28 <dons> since i'm not sure I can think of a good use for Monad (Int -> Int) ?
05:29:44 <dylan> psykotic: punching, hah. That's what the walking stick is for!
05:29:46 <Syzygy-> yaxu: By BP2 you're talking about the Bol processor, right?
05:29:52 <yaxu> Syzygy-: yes
05:30:04 <yaxu> Syzygy-: re that blog entry
05:30:11 <Syzygy-> *nodnod*
05:30:59 <yaxu> Syzygy-: although i haven't used it, just read about it
05:31:04 <mentomorph> ok, I'll think a bit harder... and get back to you... thx.
05:31:17 <dons> yet, don't be afraid to ask design questoins
05:31:30 <dons> about when and why to use a monad, and when to create your own
05:31:41 <Syzygy-> Hmmm... Is it really that different in mental model?
05:32:02 <mentomorph> great, thank you.
05:35:15 <yaxu> Syzygy-: i don't know how it compares with haskore, but it seems to treat time in an interesting way
05:45:13 <dylan> hmm, (Monad m) => m (t -> a) -> t -> m a is an interesting function.
05:45:26 <xerox> yaxu: might I have the .mov too?
05:46:15 <xerox> yaxu: I've been readin the BP2 stuff recently
05:47:46 <shapr> @yow !
05:47:47 <lambdabot> Did an Italian CRANE OPERATOR just experience uninhibited sensations in
05:47:47 <lambdabot> a MALIBU HOT TUB?
05:47:56 <xerox> Yes!
05:48:01 <shapr> yaxu: Teff is demonically cute.
05:49:37 <shapr> Syzygy-: Did you get a non-flash clip from yaxu ?
05:50:03 <Syzygy-> Not yet, no...
05:50:11 <Syzygy-> He couldn't really find it so far...
05:50:13 * xerox bounces
05:50:13 <dons> this is what i mean about the secret russian haskell mafia, http://dtim.livejournal.com/
05:50:15 <lambdabot> Title: Dark they were
05:50:30 <dons> "Haskell, QuickCheck  test-driven design" for example
05:50:39 <Syzygy-> I have no idea why people are so interested in yows...
05:51:05 <shapr> Have you read the "understanding zippy" series of strips from Zippy the Pinhead?
05:51:11 <Syzygy-> "Sexy types" ... I wonder whether he's talking about type theory...
05:51:14 <Syzygy-> shapr: Nope.
05:51:43 <Syzygy-> Haha! The let 1+1=3; 3+1=7 in 1+1+1 also pops up at that blog...
05:52:04 <shapr> I think Zippy is equal parts deep philosophy and random salt. I'm not always sure which is which though.
05:52:06 <dons> ha!
05:52:30 <dons> ah, he has an english blog too, http://folding-maps.blogspot.com/
05:52:51 <dons> does anyone know Dimitri?
05:52:58 <Binkley> Understanding Zippy is sort of like learning Haskell... you have to allow time for your brain to get warped in exactly the right way, but then it all makes sense
05:53:00 <Syzygy-> Without content though...
05:53:07 <shapr> Binkley: yeah!
05:53:12 <dons> right on.
05:53:22 <shapr> dons: Dimitri Golub* ?
05:53:37 <dons> "Dimitri Timofeev", http://folding-maps.blogspot.com/
05:53:45 <Syzygy-> Binkley: Learning Haskell wasn't as much a matter of warping my brain as it was a matter of getting someone to tell me about it in a way that didn't assume I had no idea of what a category is... :P
05:53:46 <dons> the guy of the secret russian haskell blog
05:54:04 <Binkley> Syzygy-: heh, that's the opposite of most people's problem
05:54:24 <Binkley> but I know I certainly felt like my brain was getting warped when I was trying to understand what a monad was
05:54:40 <xerox> Do you know of anybody involved in writing a book about Haskell?
05:54:52 <shapr> CosmicRay was doing that.
05:54:56 <Binkley> xerox, besides the books about it that already exist?
05:55:05 <xerox> Yes
05:55:26 <shapr> That's his haskell-v8 project. I'm tempted to resurrect it and see if I/we can get out the first "Learn Haskell in 24 years" book.
05:56:04 <Binkley> I definitely think there needs to be a "Haskell for Dummies" book
05:56:11 <dons> and Dmitri seems to get lots of comments on his blog too!http://dtim.livejournal.com/106199.html
05:56:13 <lambdabot> Title: dtim: 2+2=?
05:56:28 <shapr> Or maybe Haskell with State?
05:56:33 <dons> its amazing there's these secret haskell communities we don't hear about.
05:56:39 <xerox> Before, I was trying to FORCE blakkino to be taught by me... and he told me, that if I loved teaching Haskell, I could have been writing a book.  He would buy it!
05:57:01 <shapr> xerox: Ok, you're officially part of the secret Haskell book writing community!
05:57:08 <dons> xerox: heh
05:57:17 <xerox> dons: I mean, that's an excellent idea :)
05:57:18 <dons> ssss! its a secret!
05:57:21 * Igloo has visions of secret meetings in secluded places at midnight, involving arcane rituals and Haskell hacking
05:57:36 <Binkley> step 1: write secret Haskell book. step 2: *REDACTED*. step 3: PROFIT
05:57:39 <dons> if you look at dmitri's blog its a bit like that
05:57:52 <dons> "russian russian russain "non-exhaustive patterns" more russian russian"
05:57:56 <dons> looks like spells to me
05:58:01 <xerox> haha, you mixed up the book idea with the arcane-secret stuff. You read too much science fiction.
05:58:10 <shapr> Haskell programmers being lazy, those meetings will probably happen about tea time.
05:58:20 <Igloo> That's not really Russian; it's elvish transliterated...
05:58:26 <shapr> Elvish is alive!
05:58:29 <Binkley> no, no... Haskell programmers being lazy, the meetings won't happen until the results of the meetings are demanded are needed
05:58:32 <Binkley> i.e., never
05:58:35 <shapr> Good point
05:58:38 <shapr> That's why no books?
05:58:41 <Binkley> I wish all meetings were like that
05:59:02 <Syzygy-> Gleh. How do I use guards again??
05:59:04 <shapr> Speaking of which, I have a meeting in a few hours and should prepare for it...
05:59:06 <Binkley> heh
05:59:08 <pejo> Binkley, unevaluated+
05:59:56 <dons> shapr: though there's more books than I ghouth, we found about 5 last week, http://www.haskell.org/haskellwiki/Books_and_tutorials#Textbooks
05:59:59 <dons> now with pictures
06:00:00 <lambdabot> Title: Books and tutorials - HaskellWiki, http://tinyurl.com/y4yvp2
06:00:09 <dons> "ghouth" oh my. bed time!
06:00:25 <dons> *I almost wrote it in backwards speak*
06:00:27 <dons> that's scary
06:04:14 * dons `ap` sleep
06:05:10 <yaxu> Syzygy- / shapr: http://yaxu.org/20/hs.avi
06:07:13 <yaxu> better quality than the youtube one as well i expect....
06:08:20 <xerox> Thanks!
06:10:10 <yaxu> a perl livecoding demo is in the same directory
06:10:29 <xerox> yaxu: it doesn't play in quicktime, neither does in vlc :(
06:11:40 <yaxu> xerox: bah, works in mplayer here
06:11:49 <xerox> :(
06:12:19 <dons> hmm, i can't seem to get through on that url? Connection timed out.
06:12:19 <dons> Retrying.
06:12:50 <dons> seems to be timing out. weird
06:12:51 <yaxu> :/
06:13:06 <dons> got it from a different machine
06:13:07 <dons> that's odd
06:13:09 <DeeJay> @pl \x s -> f x ++ s
06:13:11 <lambdabot> (++) . f
06:13:33 <yaxu> dons: how far does the traceroute get?
06:13:45 <Syzygy-> yaxu: Wooot! thanks!
06:13:53 <yaxu> xerox: it seems to be divx, should work in vlc
06:14:06 * Syzygy- shall watch it any second now. :)
06:14:20 <xerox> yaxu: it's the audio that doesn't play
06:14:31 <yaxu> xerox: ah right
06:15:18 <Syzygy-> Neat.
06:15:33 <dons> bit worrying when you see the packages go: sydney -> los angeles -> dallas -> chicago -> new york -> london -> ...
06:15:51 <Syzygy-> First obvious thing to ask, and your probable answer is yes: Have you thoughts about how to make the transition to new code smoother?
06:15:52 <yaxu> it's only a minute-long demo, not very exciting really
06:15:59 <xerox> :(
06:16:13 <yaxu> xerox: weird it doesn't play, it's just mp3
06:16:19 <dons> but i got it playing in mplayer on openbsd, so that's good
06:16:28 <dons> with sound!
06:16:37 <yaxu> Syzygy-: yes, i just need to timestamp my OSC messages a couple of seconds in the future
06:17:15 * Syzygy- has it with my mplayer-bin on gentoo/64...
06:17:49 <xerox> :(
06:17:56 <xerox> yaxu: do you have other formats?
06:18:49 <yaxu> Syzygy-: the jump is just haskell waiting for the new code to be read
06:19:14 <Syzygy-> Ah.
06:19:33 <yaxu> Syzygy-: i just need to artificially induce some latency
06:19:37 <Syzygy-> Ah.
06:20:02 <yaxu> right now i'm playing with parsing rather than embedding though
06:20:03 <Syzygy-> So it's not a matter of "hack your head off" but rather of "gotta make sure the code actually cares"
06:20:36 <yaxu> how do you mean?
06:20:54 <yaxu> xerox: no, i could try and convert it but mp3 should work everywhere
06:20:59 <yaxu> Syzygy-: what o/s?
06:23:25 <Syzygy-> Gentoo linux
06:24:35 <Syzygy-> grmbl... I shouldn't shouldn't shouldn't flirt with livecoding... But it's just so damn difficult not to....
06:24:37 <yaxu> Syzygy-: sorry i meant to ask xerox
06:24:41 <Syzygy-> Oh.
06:24:43 <Syzygy-> :)
06:24:53 <yaxu> xerox: which os are you using?
06:25:14 <dons> that screencast is really inspiring though.
06:25:16 <dons> yaxu++
06:25:22 <Syzygy-> yaxu++
06:25:26 <Syzygy-> (agreed)
06:25:45 <dons> so the notation is intereting to us PL people. i wonder if you could steal haskore notation, or adapt it?
06:25:58 <xerox> yaxu: OS X
06:26:03 <dons> (it has arbitrary precision "notes" now, iirc, not just hte usual western music scale)
06:26:15 <Syzygy-> yaxu: What is your M.Sc. topic?
06:26:33 <Syzygy-> PL people?
06:26:45 * Syzygy- is VERY interested in merging this with Haskore btw...
06:27:06 <dons> "programming langugage", since we care a lot about EDSLs, syntax, notation, semantics .. :)
06:27:10 <earthy> livecoding is schweet
06:27:37 <earthy> but the syntax in the flash demo wasn't quite as schweet
06:27:45 <dons> yeah :)
06:27:49 <earthy> would love to see the new syntax, yaxu
06:28:26 <dons> so i guess you need a quite concise language to make this doable?
06:28:36 <Syzygy-> Huh? "Could not find module Network.Socket" - shouldn't ghc be pretty much capable of finding that on its own?
06:28:45 <dons> Syzygy-: missing -package network?
06:28:50 <dons> its in the extra libs now
06:29:00 <dylan> (or --make?)
06:29:14 <Syzygy-> Oh right.
06:29:26 <Syzygy-> --make I had. -package network though.
06:29:31 * dons watches the screencast again
06:30:50 <dylan> how do I argue with someone that says C is a "good, fast, portable, general-purpose language"?
06:31:46 <dons> dylan: i think you don't?
06:31:58 <Baughn> dylan: Direct him to ##c? We're good at it.
06:32:12 <dylan> well, it's unstated, but the person that stated that things that C is the generalist-purpose language at all.
06:32:13 <dons> heh
06:32:22 <dylan> *thinks
06:32:24 <Syzygy-> yaxu: What do you use Network.Socket for? *curious*
06:32:47 * Syzygy- is trying to build the sources I just pulled from you...
06:32:50 <dylan> Baughn: why two #'s?
06:32:58 <dons> i wonder what kind of DSL syntax is suited to live coding?
06:33:05 <dons> something without lots of parens I suppose
06:33:08 <Baughn> dylan: Unofficial channel
06:33:16 <dylan> Ah
06:33:54 <yaxu> yes the simple language in that screencast was just a thought experiment really
06:33:59 <Syzygy-> Right. So next question: hs-plugins is masked with all sorts of reasons for amd64 on gentoo. Anyone have any idea why, or if I can get around it?
06:34:09 * Syzygy- is kinda looking a bit at dons... :)
06:34:15 <dylan> the bothersome bit is really "[if you want to solve a] wide variety of problems fairly efficiently, C is the only choice"
06:34:24 <Baughn> dylan: The people who know a language best are often best at arguing against it, and for C this is /definitely/ the case
06:34:25 <dons> Syzygy-: it works on amd64 afaik. pretty certain
06:34:33 <yaxu> my msc topic is not completely set but i want to make a music dsl, then model use of it
06:34:47 <dylan> I use hs-plugins on amd64. :)
06:34:55 <dons> cool
06:35:05 <dons> Syzygy-: not with 6.6 yet though
06:35:07 <dylan> it's ... no different than any other arch.
06:35:08 <dons>  ghc 6.4.x
06:35:18 <dons> yeah, if ghci works , then so does hs-plugins
06:35:21 <Syzygy-> dons: That's kinda my problem though... I bumped up to 6.6 a while ago...
06:35:24 <dons> (basically)
06:35:32 <Syzygy-> What issues face me there?
06:35:32 <dons> ok. so you can't use hs-plugins then. for now
06:35:36 <Syzygy-> Oh bugger.
06:35:45 <dylan> maintainers, both gentoo and debian, seem to have this psycological problem with amd64
06:35:46 <yaxu> Syzygy-: Network.Socket is probably used from the hsc library i'm using for sending osc
06:35:53 <Syzygy-> yaxu: Ah.
06:36:04 <Syzygy-> dylan: Hehe
06:36:04 <dons> Syzygy-: unless you also install ghc 6.4.2
06:36:27 <yaxu> dons: livecoding needs to be easy to write but not necessarily easy to read
06:36:38 <yaxu> dons: imho
06:36:57 <dylan> perhaps a livecoding language would be like vim's normal-mode?
06:37:01 <dons> right. so symbols, and single letter idents are fine
06:37:04 <dons> and magic numbers
06:37:13 <dons> like sed for music, i can imagine, almost
06:37:25 <Syzygy-> dons: grmbl... yeah.... It seems to be installed in parallell, but ... seems I'll need to juggle environment annoyingly much.
06:37:33 <Syzygy-> What bars hs-plugins@6.6 so far?
06:37:46 <dons> there's a mail on the libraries@ list with the 3 porting issues
06:38:07 <dons> hopefully this week, sometime
06:38:11 <dons> since lots of people are starting to care
06:38:23 <yaxu> dons: others take the view that the audience should be able to read and understand the code
06:38:30 <dons> ah interesting
06:38:42 <yaxu> dons: i think that's a distraction
06:38:55 <dons> and is there much work on connecting the DSL to conventional music notation or so?
06:39:17 <dons> the thing you posted resembled, what, a list of rhythms that you modify on the fy
06:39:20 <dons> fly,
06:39:30 <dons> so i guess that's closer to representing what's operationally actually happening
06:39:32 <dylan> where is the youtube thing for the livecoding?
06:39:40 <yaxu> i believe it's very difficult to read or write conventional music notation with software
06:39:45 <dons> yeah
06:40:47 <Syzygy-> Though by extending Haskore (or possibly also over other routes), it wouldn't be that much of a problem putting together a system where the auditory rendering is simultaneous with score rendering through some rendering engine....
06:40:57 <Syzygy-> Giving, sorta, an extra visualisation aid...
06:41:07 <dons> ah, interesting idea
06:41:25 <yaxu> my bol2 based stuff allows you to describe polymetric rhythms in one string
06:41:33 <Syzygy-> There was, as I understood the Haskore notes, already bidnings for rendering Midi, at least one softsynth and scores.
06:41:37 <dons> i was thinking that haskore notation itself might be useful to steal
06:41:45 <dons> oh, so it needs to be very concise
06:41:49 <dons> to be flexible?
06:42:34 <dons> here's the haskore src, fwiw, http://darcs.haskell.org/haskore/src/Haskore/Music.lhs
06:42:37 <lambdabot> http://tinyurl.com/yxq3jv
06:43:07 <yaxu> sorry will have to leave this conversation until later :/  i'm at the day job
06:43:19 <dons> so its more like an embedding of conventional notation.
06:43:28 <dons> ok. talk later yaxu!
06:43:28 <dylan> stupid non-haskell day jobs. :(
06:43:37 <norpan> indeed
06:43:41 <dons> why can't we all live code haskell for $$ ?
06:43:47 <yaxu> would appreciate talking this through further though dons
06:43:48 <dons> i'd pay to see it :)
06:44:14 <dons> yaxu: of course :)
06:44:17 <Syzygy-> Cya. yaxu
06:44:18 <dylan> My coding tends to occure in bursts every 20 minutes
06:44:29 * Syzygy- definitely want to tag on to further discussions as well...
06:44:44 <yaxu> Syzygy-: yes same goes for you obviously
06:44:48 <Syzygy-> :)
06:45:04 * xerox was teaching Haskell, aww
06:45:13 <dons> yaxu: oh, I talked to Sean. he said they did get it working, the live coding and the music, based on ideas from Pan for graphics
06:45:20 <dons> i'm asking for more info/code
06:45:22 <yaxu> oh great!
06:45:46 <yaxu> will read the haskore docs later too
06:53:07 <fons> hi all
06:54:45 <vincenz> Anyone very familiar with ghc/
06:55:51 <vincenz> I was skimming through the lock-free multi-core paper, and there they claim they can duplicate the calculation of a thunk because thunks are pure.  Now what I wonder is, what about thunks that contain IO actions, I mean sure, in the haskell language it is pure, but at some level it must turn impure for it to do side-effects.  What about those thunks then?
06:56:26 <dmead> haskell uses monads for IO
06:56:35 <vincenz> dmead: I know that
06:56:40 <dmead> IO is part of the typing system
06:56:43 <vincenz> ...
06:56:43 <psykotic> he's talking about unsafePerformIO style stuff
06:56:49 <vincenz> yes but at some point you have to have side-effects
06:56:51 <psykotic> suppose you have a thunk which, when forced, does an unsafePerformIO
06:56:58 <dmead> ah
06:57:01 <vincenz> no I'm talking about the haskell code being compiled to some lower level code
06:57:18 <vincenz> at some point, you actually have to perform the IO actions
06:57:23 <vincenz> and you could envision some of them being in a thunk
06:57:25 <dmead> seems like it'd get unpure then
06:57:35 <vincenz> dmead: no, purity is only at the type-system
06:57:37 <vincenz> erm
06:57:38 <vincenz> type-level
06:57:45 <dmead> hmm
06:57:46 <vincenz> monads are just a way to hide it
06:57:50 <dmead> ah
06:57:58 <vincenz> imo
06:58:03 <vincenz> don't quote me on it
06:58:08 <dmead> yea i agree with that
06:58:21 <dmead> but i havent done io in haskell
06:58:37 <dmead> seems like hugs takes care of that imo
06:58:50 <dmead> that is, if your not developing an app
06:59:04 <vincenz> simple example
06:59:23 <vincenz> foldr1 (>>) $ map (print) $ [1..10]
06:59:27 <vincenz> now that's one big thunk
06:59:32 <vincenz> with many thunks in a list
06:59:35 <vincenz> those thunks aren't pure
06:59:43 <vincenz> so how does the lock-free multi-core ghc work with that
06:59:52 <Binkley> vincenz: to understand this you need to think about the translation into GHC's intermediate language
06:59:56 <Binkley> (or any compiler's intermediate language)
06:59:59 <vincenz> Binkley: which is what I'm askign :)
07:00:17 <Binkley> anything that does IO is essentially a function that takes a "RealWorld" thing as an argument
07:00:21 <vincenz> option 1) iO stuf is not thunkified but linearized
07:00:31 <vincenz> option 2) ...
07:01:00 <Binkley> vincenz: a good way to understand this might be to compile that example program with GHC's -dverbose-core2core flag
07:01:00 <vincenz> Binkley: well yes, ST RealWorld
07:01:04 <vincenz> Binkley: tho many people disagree
07:01:11 <Binkley> you can see all the intermediate representations
07:01:20 <Binkley> vincenz: disagree with what?
07:01:20 <Igloo> vincenz: The above code is pure. It's only run the resulting action is executed in the IO monad that you have side effects
07:01:27 <vincenz> Binkley: what I'm mostly concerned with is the claim that no thunks at the IL level are nonpure
07:01:43 <vincenz> s/non/im/
07:01:46 <psykotic> the "real world object" view of io is very bogus imo.
07:02:12 <Maddas> psykotic: How so?
07:02:13 <Binkley> vincenz: then look at the IL representation of an example program and you can see it for yourself :-)
07:02:14 <psykotic> an honest faithful description of interaction involves some kind of process calculus.
07:02:15 <vincenz> Igloo: I know that, but if you look at the multi-core lock-free paper, they say that all thunks have no side-effects and thus they can easily be evaluated more than once... how does this work with IO code?
07:02:20 <vincenz> Binkley: thanks for the suggestion :)
07:02:59 <psykotic> maddas: first of all, it's an interpretation, so i'm referring to the validity/usefulness of the interpretation.
07:03:06 <Binkley> vincenz: a thunk is a function that takes no arguments. by definition of a thunk, then, anything that does IO can't be a thunk
07:03:25 <psykotic> maddas: if you look at IO in terms of meta and object language it's a lot clearer.
07:03:34 <Igloo> vincenz: I don't know the details
07:03:57 <Binkley> is that clear?
07:04:00 <vincenz> Binkley: hmm, good perspective
07:04:15 <Binkley> now, of course, if you use unsafePerformIO, all bets are off
07:04:18 <Binkley> that's why it's unsafe :-)
07:04:32 <psykotic> btw i think dons, etc were discussing this kind of thing a day or two ago
07:04:58 <psykotic> might be able to find something in the logs
07:06:22 <vincenz> Binkley: no I know about unsafe :P
07:09:38 <dylan> oh my. I've been typoing "samba" as "sambda". I must have \ on the brain
07:11:08 <yaxu> i got some spam about a nomad meet in london and read it as...
07:11:14 <Binkley> monad meet?
07:11:47 <yaxu> Binkley++ # yes
07:11:54 <Maddas> dylan: at least you aren't typing lambda as lambada ^_-
07:12:16 <psykotic> lambada theory is my speciality
07:12:23 <Maddas> :-)
07:12:30 * psykotic can go very low
07:12:36 <yaxu> was interested that monad is the seventh most popular word on this channel
07:12:37 <Binkley> the lambada calculus: expressing all possible dances with only 3 syntactic forms
07:12:47 <yaxu> (i typoed monad as monday then...)
07:12:53 <related> monad
07:13:50 <psykotic> instead of comonad we should just use damon. which is pretty close to demon/daemon now that i think of it.
07:14:02 <Binkley> heh
07:14:03 <psykotic> danom, doh. not so much fun, that.
07:14:12 <dylan> comonad should be called gonad. ;)
07:14:18 <Binkley> :-(
07:14:32 <psykotic> or how about wonad, for the upside down m :)
07:14:37 <Binkley> then web filtering software would screen out functional programming web sites
07:14:38 <psykotic> nads of woe
07:15:45 <lisppaste2> mentomorph pasted "sequencing" at http://paste.lisp.org/display/29377
07:17:04 <mentomorph> hi again, could u take a look at this little snippet. I'd like to sequence two functions using bind or something else. Thank you.
07:17:35 <mentomorph> the code doesen't afcourse work.
07:17:38 <Binkley> what's your question?
07:18:21 <vincenz> I think we should call a comonad a "fooblazerty" to denote that words are just that, words, arbitrarily chosen tags to represent a concept
07:18:36 <Binkley> no, no
07:18:39 <Binkley> "cowarmfuzzything"
07:18:47 <vincenz> comonster
07:18:50 <Binkley> yes
07:19:07 <psykotic> cozyhappyfuntime
07:19:21 <Binkley> Do not taunt Happy Fun Monad.
07:19:28 <psykotic> it's sending a subtle subliminal message
07:19:44 <psykotic> instead of 'cobind' it will be 'hug'
07:19:57 <vincenz> cobind = dehug
07:19:59 <vincenz> binding = hugging
07:25:41 <related> Snuggle tested, hippy approved
07:26:03 <Binkley> let's just rename Haskell "Snuggles"
07:26:49 <norpan> dr snuggles!
07:26:52 <psykotic> we need to name concepts after tele tubbies. the kids will be begging their parents for haskell!
07:27:24 <related> Just drop the mathematical jargon and replace it was accessible language.
07:27:30 <related> was=with
07:27:38 <related> (Clearly I should not be tasked with the latter)
07:27:41 <Binkley> instead of "cannot construct infinite type", type error messages could say things like "where's po??????"
07:28:28 <Syzygy-> Ah concept is the dual of an ncept...
07:29:02 <xerox> @slap Syzygy-
07:29:03 <lambdabot> why on earth would I slap Syzygy-
07:29:12 * Syzygy- would like to point out that the mathematical jargon was what made me go to haskell..
07:29:25 <Syzygy-> xerox: Just like the dual of commutativity is mmutativity...
07:29:33 <Syzygy-> And the dual of a cow is w
07:29:33 <psykotic> Syzygy-, i have just the language for you, sir!
07:29:37 <Syzygy-> psykotic: Oh?
07:29:47 <earthy> this is weirding me out
07:29:50 <Syzygy-> Hehe
07:30:05 <psykotic> Syzygy-, i was thinking of a language with simple concepts named arbitrarily after complicated mathematical concepts.
07:30:05 * xerox consolates earthy 
07:30:16 <Syzygy-> xerox: This kind of jokes abound in homological algebra studies... We had a lot of fun with it back when I did my MSc
07:30:35 <Syzygy-> psykotic: I don't see the applicability on monads/comonads of that remark...
07:30:35 <psykotic> the thom cobordism design pattern
07:30:48 <Syzygy-> But then again I actually think in categories reasonably well..
07:30:49 <Binkley> some friends of mine at berkeley were going to name their office the "homological office", since everyone in the office was gay, a logician, or both
07:30:53 <Syzygy-> Hehe
07:33:31 <psykotic> Syzygy-, speaking of abstract nonsense, i wonder if you can liken diagram chasing to "program generation" from types.
07:33:42 <psykotic> it has a lot of the same flavor.
07:34:52 <Syzygy-> psykotic: Program generation as in "Find me something that has -this- signature"?
07:34:56 <psykotic> in diagram chasing you're looking at the constraints and using assumptions to compose existing things at each step, and usually there are only a few "obvious" next steps to do. you often have that characteristic when generating the "obvious" program inhabiting some kind of type.
07:35:04 <Syzygy-> psykotic: It's kinda similar, yeah...
07:35:40 <Syzygy-> When you consider a Haskell function to be a morhpism between types, you end up very close to diagram chasing, since you basically want to chase up some relevant morphism from a stock bunch of well-known morphsims...
07:35:55 <psykotic> right
07:36:29 <psykotic> and the way you decide the next step in a diagram chase is often similar, intuitively. you look at the gadgets you have and look at how to make progress, and usually that is guided by some local "compatibility" notion.
07:37:13 <psykotic> of course usually in diagram chases you are interested in much more complex things, like certain diagrams being commutative
07:37:20 <Syzygy-> This is, by the way, to a large extent what I meant earlier... Having a programming language where the whole coder culture as well as the program syntax is amenable to talking about it as if it were category theory makes it very easy for my brain to wrap around it. The diagram chase revolution happened a couple of years ago, and so the transition to Haskell is much easier...
07:37:34 <Syzygy-> (diagram chase revolution happened -to- -me- a couple of years ago)
07:37:43 <psykotic> hehe
07:37:49 <psykotic> it's really cool once you "get" diagram chasing
07:38:04 <psykotic> it felt like the same when i "got" dynamic programming. suddenly i could just churn it out on demand.
07:38:24 <psykotic> stuff like the five-lemma or snake lemma or whatever was suddenly super easy.
07:38:28 <Syzygy-> I remember very clearly going from one day "WHAT THE HOLY F*** are they DOING??" to the next "Ah. It's just a diagram chase. What? You mean I should -write- it -out-??"
07:38:47 <psykotic> yeah, forcing someone to write down a diagram chase is a crime
07:38:58 <psykotic> it requires a black board or a piece of paper where you can do points of pointing
07:39:03 <Syzygy-> It's one of those things that just suddenly go *snap* and then you cannot understand how it was difficult before.
07:39:24 <Syzygy-> Though, y'know, Weibel actually writing it down (3 pages for one of the simpler lemmas) was integral in my snapping.
07:39:51 <dmead> someone find my wallet
07:39:55 <dmead> =(
07:41:57 * tmoertel :: Espresso -> IO Work
07:43:02 <vincenz> dons: ping
07:43:56 <psykotic> Syzygy-, i remember reading a book that had really nice notation for showing diagram chases. they highlighted paths under consideration and annotated objects with elements furnished at those objects
07:44:15 <Syzygy-> Neat!
07:44:19 <Syzygy-> Remember which it was?
07:44:27 <psykotic> nope, sorry
07:44:30 <Syzygy-> Awwww.
07:44:35 <psykotic> it was really very simple
07:44:57 * Syzygy- tears his hair... And and or DO NOT ASSOCIATE!!! 
07:45:19 <Syzygy-> grmbl.... Damn homework... Damn students... Blech.
07:47:18 * vincenz repliedto dons' post on reddit
07:48:30 <vincenz> http://programming.reddit.com/info/ox6s/comments/cpmbc
07:48:33 <lambdabot> Title: Ask Reddit: What the hell are monads? (reddit.com), http://tinyurl.com/se2em
07:53:59 <roconnor> \scheck \a b c -> (a && b) || c == a && (b || c)
07:54:07 <roconnor> @scheck \a b c -> (a && b) || c == a && (b || c)
07:54:09 <lambdabot>   Failed test no. 4. Test values follow.: True, False, False
07:55:02 <roconnor> @scheck \a b c -> ((a == b) == c) == (a == (b == c))
07:55:03 <lambdabot>  Completed 8 test(s) without failure.
07:55:28 <roconnor> @scheck \a b c -> a == b == c == a == b == c
07:55:30 <lambdabot>    precedence parsing error
07:55:30 <lambdabot>     cannot mix `(==)' [infix 4] and `(==)' ...
07:56:29 <roconnor> can we make == left associative?
07:57:00 <mwc> @type Bool
07:57:01 <lambdabot> Not in scope: data constructor `Bool'
07:57:02 <mwc> er
07:57:06 <mwc> @type (==)
07:57:07 <lambdabot> forall a. (Eq a) => a -> a -> Bool
07:57:22 <mwc> My point is that you could only make that associative when a == Bool.
07:57:39 <roconnor> mwc: the type checker would catch error.
07:57:58 <mwc> meh, I think the use there is what and is for.
07:58:03 <mwc> @type and
07:58:05 <lambdabot> [Bool] -> Bool
07:59:02 <roconnor> @scheck \a b c -> (foldl1 (==) [a, b, c, a, b, c])
07:59:03 <lambdabot>  Completed 8 test(s) without failure.
07:59:07 <roconnor> @scheck \a b c -> (foldr1 (==) [a, b, c, a, b, c])
07:59:08 <lambdabot>  Completed 8 test(s) without failure.
08:01:09 <roconnor> mwc: (==) is very different from and as you can see
08:01:18 <roconnor> @scheck \a b c -> (and [a, b, c, a, b, c])
08:01:19 <lambdabot>   Failed test no. 2. Test values follow.: True, True, False
08:02:38 <lispy> okay, every time emacs does that (segfaults) it makes me move a bit closer to wanting to finish helisp
08:02:48 <mwc> roconnor, true, I was thinking mostly in terms of checking a lot of boolean cnditions
08:03:08 <mwc> True == foo  == bar == baz...
08:03:19 <roconnor> ah, but that is something different
08:03:25 <mwc> F == F == T would also pass with left association
08:03:26 <roconnor> but now I see your point
08:03:48 <roconnor> people would think that a == b == c means a == b && b == c
08:04:10 <therp> lispy: you might want to have a look at "Lisp in small pieces" :)
08:04:42 <therp> lispy: I just read http://www.codersbase.com/index.php/Helisp and it states that you have trouble to implement the evaluator
08:05:11 <mwc> The emacs lisp interpreter is segfaulting?
08:05:25 <mwc> I would have thought that code was mostly frozen since about 1990
08:07:36 <mwc> roconnor, that's another good point. There's an old adage from C++ about operator overloading to not do it unless you're gonna behave just like int.
08:08:22 <roconnor> (False == False) == True
08:08:23 <mwc> Of course, if you try hard enough, I suppose you can hammer and break any concept to conform to a field :)
08:08:25 <roconnor> > (False == False) == True
08:08:27 <lambdabot>  True
08:08:33 <roconnor> > False == (False == True)
08:08:35 <lambdabot>  True
08:13:29 <xerox> @check \xs -> length xs > 1 ==> foldl1 (==) xs == foldr1 (==) xs
08:13:31 <lambdabot>  OK, passed 500 tests.
08:13:35 <xerox> heh
08:13:58 <vincenz> @check \x -> x ==> x
08:14:00 <lambdabot>  OK, passed 500 tests.
08:14:05 <vincenz> @check \x -> x ==> (not x)
08:14:07 <lambdabot>  Falsifiable, after 0 tests: True
08:14:34 <vincenz> @check \a b -> a && b ==> a || b
08:14:35 <lambdabot>  Arguments exhausted after 307 tests.
08:14:41 <vincenz> @type (&&)
08:14:43 <lambdabot> Bool -> Bool -> Bool
08:14:48 <vincenz> lol
08:14:55 <vincenz> " Arguments exhausted after 307 tests."
08:15:08 <vincenz> That's a new one
08:15:33 <therp> 307!?
08:15:34 <vincenz> @tell dons What does this mean in quickcheck " Arguments exhausted after 307 tests.":  @check \a b -> a && b ==> a || b   (which should obviously pass all tests)
08:15:36 <lambdabot> Consider it noted.
08:15:54 <xerox> you only want booleans a and b such that a && b is true, mhh
08:16:09 <vincenz> well what bout this:
08:16:14 <vincenz> @check \x -> x ==> x
08:16:16 <lambdabot>  OK, passed 500 tests.
08:16:20 <vincenz> that should fail even faster then
08:16:44 <vincenz> @check \x -> (not x) ==> (not x)
08:16:45 <lambdabot>  OK, passed 500 tests.
08:17:04 <shapr> vincenz: It means that quickcheck got bored of generating inputs that matched your conditions, it ran out.
08:17:14 <vincenz> shapr: it should run out even faster for one bool
08:17:19 <vincenz> shapr: and 307 is excessive
08:17:23 <boegel> @check \(x,y) x /y == 2 ==> y/2==0
08:17:23 <lambdabot>  Parse error
08:17:30 <boegel> figures
08:17:47 <vincenz> @check \a b c -> a && b && c ==> a || b || c
08:17:49 <lambdabot>  Arguments exhausted after 130 tests.
08:18:05 <vincenz> @check \a b c d e f -> a && b && c && d && e && f ==> a || b || c || d || e || f
08:18:06 <lambdabot>  Arguments exhausted after 17 tests.
08:18:08 <vincenz> :D
08:19:00 <vincenz> @check \a b c d e f g h i j k l m n-> a && b && c && d && e && f && g && h && i && j && k && l && m && n ==> a || b || c || d || e || f || g || h || i || j || k || l || m || n
08:19:02 <lambdabot>  Arguments exhausted after 0 tests.
08:19:19 <vincenz> that's a bug
08:19:57 <vincenz> @tell dons Even worse, this one is exhaused after 0 tests (coould even happen with fewer arguments, haven't done a full test) : @check \a b c d e f g h i j k l m n-> a && b && c && d && e && f && g && h && i && j && k && l && m && n ==> a || b || c || d || e || f || g || h || i || j || k || l || m || n
08:19:58 <lambdabot> Consider it noted.
08:20:33 <vincenz> I guess it has to do with the ==>
08:20:47 <int-e> yes.
08:20:50 <_matthew_> yes. the args are randomly generated.
08:20:52 <vincenz> instead of just checking if the whole clause is true
08:21:02 <vincenz> it must early abort if the left side is false
08:21:20 <vincenz> funky
08:21:27 <int-e> "Arguments exhausted" is not a failure.
08:21:50 <int-e> it just tells you that it never got to test the right side.
08:21:55 <vincenz> yeps
08:22:09 <_matthew_> so it's not a bug
08:22:12 <vincenz> but I think that for bounded variables, quickcheck should be able to test em all
08:22:14 <int-e> and given how it works, that's not a bug.
08:22:24 <vincenz> I see it as a bug on the implementational level
08:22:33 <_matthew_> um, it does 500 (iirc) tests
08:22:40 <int-e> it would have to test 16384 cases ...
08:22:47 <vincenz> int-e: you could use a threshold function
08:22:48 <_matthew_> it's not its fault if none of them pass the predicate
08:22:51 <int-e> and it does 500, indeed.
08:23:05 <int-e> vincenz: show code. I think it's hard.
08:23:13 <vincenz> int-e: enumerate em all
08:23:31 <int-e> that's what scheck does
08:23:45 <vincenz> @scheck \a b c d e f g h i j k l m n-> a && b && c && d && e && f && g && h && i && j && k && l && m && n ==> a || b || c || d || e || f || g || h || i || j || k || l || m || n
08:23:48 <lambdabot>  Completed 16384 test(s) without failure.  But 16383 did not meet ==> condition.
08:24:09 <vincenz> that was fast
08:25:10 <norpan> 2^14 is not much
08:25:43 <_matthew_> what happens if you tell quickcheck to do 16384 tests?
08:26:11 <xerox> It is not quick anymore :P
08:26:52 <_matthew_> mmm, so not only do we need dependant types, but some further theory to *rename functions* based on the values of the arguements... ;)
08:26:56 <int-e> it probably generates some duplicates
08:27:06 <vincenz> @scheck \a b c d e f g h i j k l m n o p q r s t u v w x y z -> a && b && c && d && e && f && g && h && i && j && k && l && m && n && o && p && q && r && s && t && u && v && w && x && y && z==> a || b || c || d || e || f || g || h || i || j || k || l || m || n || o || p || q || r || s || t || u || v || w || x || y || z
08:27:06 <_matthew_> !
08:27:12 <lambdabot>  resource = let heg = let ... in ... in heg
08:27:18 <vincenz> woah
08:27:31 <vincenz> !
08:28:00 <vincenz> resource = let chf = let ... in ... in chf
08:28:03 <vincenz> is what I got back
08:28:12 <vincenz> that an easter egg?
08:33:04 <xerox> haha
08:48:45 * boegel poofs off
08:52:06 <mr_ank> @yarr!
08:52:07 <lambdabot> Aye
09:04:26 <beelsebob> dons, dcoutts you two about?
09:08:34 <shapr> I had nightmares about lennart last night. What's up with that?
09:09:37 <Binkley> oh yeah?
09:09:40 <Igloo> Maybe it's a sign you should switch to Java
09:09:50 <vincenz> or c#
09:09:55 <Binkley> I had a dream about Bulat last night and I haven't even met him
09:10:08 <vincenz> Binkley: must be his english :)
09:10:23 <Binkley> heh
09:10:31 <Binkley> I think it means I shouldn't read the Haskell mailing list before bed
09:10:41 <vincenz> sometimes I wonder if he just writes in russian andthen uses google translator
09:10:43 <Binkley> heh
09:10:47 <vincenz> cause I did that once on adept's russian blog
09:10:49 <vincenz> and it sounded similar
09:12:40 <Igloo> I e-mailed a German company from a .li address in German and English a few days ago, and they replied in English only, which I thought was odd
09:15:03 <lispy> therp: that description is old
09:15:25 <lispy> therp: iirc the interpreter works fine now and i know the compiler can do mutually recursive functions
09:16:46 <largos> lispy: mornin'
09:16:52 <lispy> moin
09:18:22 <mwc> Igloo, maybe your german is... not so good.
09:18:46 <vincenz> did you use something like "ich spreche nicht deutsch"
09:19:05 <Igloo> Some nice person on IRC translated it for me. Of course, I have no idea how good his German is  :-)
09:19:09 <mwc> Ich Bein Ein Berliner! Schnell! Snitzel weiner octoberfest!
09:19:36 <mwc> (you can use that in your next letter Igloo)
09:19:55 <vincenz> "zu bist eine swein"
09:20:07 <mwc> Igloo, more likely than not they took a look at your name and your tld and decided you were probably a native english speaker
09:20:15 <sjanssen> vincenz: did you get that from a Indiana Jones movie?
09:20:53 <sjanssen> s/a/an
09:20:58 <vincenz> erm, no, why?
09:21:26 <mwc> sjanssen, no, it's a... Remember, J is spelt with an I...
09:21:31 <sjanssen> I dunno, sounds like something that might be in a movie
09:21:35 <shapr> dons: Hey, friend of mine just suggested on #ScannedInAvian that the GHC library docs each link to their own haskellwiki page so it'd be easy to find examples and make/read comments.
09:21:35 <sjanssen> mwc: ha
09:21:45 <shapr> Igloo: Maybe I should mention that to you instead :-)
09:22:40 <lispy> this livecoding music is really cool
09:22:41 <Igloo> shapr: Small examples ought to be in the docs themselves, but very few have them
09:23:39 <lispy> the php manual lets comments, but i can't say that it helps their manual
09:25:01 <lispy> does anyone still have a link to Shriram's video taped talk? (the recent one about continuations)
09:25:02 <Igloo> shapr: I think if things get written that are too large to include in the haddock docs then we should link to them
09:31:37 <lispy> Cale: ping?
09:43:11 <lispy> i think the video was for a paper titled, "Interaction-Safe State for the Web"
09:43:22 <lispy> ?logs
09:43:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
09:43:27 <lispy> ?where logs
09:43:28 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
09:43:45 <pkhuong> lispy: isn't the problem solved if you uses dynamic scoping and your continuations capture dynamically scoped variables correctly?
09:43:54 <pkhuong> -s
09:44:15 <shapr> Igloo: If each ghc-doc module or library has its own wiki page, you'll get small examples quickly.
09:44:17 <lispy> pkhuong: which problem, finding the video? ;)
09:44:53 <vincenz> lispy: it's easy to find on google video
09:45:00 <pkhuong> no, the one they try to solve. Just rebind a special variable that's scoped around the whole computation.
09:45:28 <vincenz> pkhuong: that's what they do, they use a hashtable: unique id -> thunk
09:45:29 <lispy> vincenz: ah, god idea, i didn't watch it there so i didn'tt hink to check there
09:45:45 <vincenz> pkhuong: you can look at the unique id as a sort of dynamic variable
09:46:01 <pkhuong> vincenz: true. It just seemed like a really convoluted way to do it.
09:46:12 <vincenz> pkhuong: not really
09:46:14 <lispy> vincenz: i'm not finding it
09:46:22 <vincenz> lispy: google for shriram and continuations
09:46:32 <vincenz> hmm crap
09:46:38 <vincenz> just a sec
09:46:57 <lispy> i watched from a link to msr originally
09:47:06 <vincenz> wait
09:47:16 <vincenz> yeah
09:47:20 <vincenz> I got it from reddit
09:47:24 <vincenz> aha!
09:47:28 <vincenz> http://programming.reddit.com/goto?id=jb4v
09:47:34 <vincenz> just search programming.reddit for shriram
09:47:44 <lispy> thanks
09:47:50 <lispy> i searched tehre but i looked for flapjax
09:48:01 <vincenz> "The one like Shriram Krishnamurthi talking about continuations for web programming at MS's Lang .NET symposium (WMV)"
09:50:50 <lispy> "Don Syme on Type-safe, scalable, efficient scripting on .NET " hhmm...i could use that
09:52:33 <lispy> oh, Don is working on F#
09:53:12 <lispy> i hoped he was bringing type saftey to the .NET languages which 99.9% of .NET programmers are required to use :)
09:53:27 <_dolio> Heh. Dream on. :)
09:53:52 <shapr> Where do I get the regex-parsec package?
09:54:28 <shapr> Ah, darcs.haskell.org ?
09:54:49 <shapr> Is this one guaranteed to be the latest? -> http://darcs.haskell.org/packages/regex-parsec/
09:54:53 <lambdabot> Title: Index of /packages/regex-parsec, http://tinyurl.com/ylyrq4
09:59:33 <largos> lispy: ah, dang. I was all excited about that titel too
10:00:56 <sjanssen> where do tests for the base libraries go?
10:04:17 <kzjs> How can I represent the return character (as a single character) in haskell code?  Are there any base library functions that convert int's to characters? (without returning the 2 character value \r)
10:04:52 <sjanssen> kzjs: do you want '\n'?
10:10:00 <int-e> > ord '\n'
10:10:00 <lambdabot>  10
10:10:00 <dolio> Is Text.Regex efficient now in 6.6 (using ByteString)?
10:10:00 <dolio> Or does the separate Text.Regex.Lazy still outperform it?
10:10:00 <dolio> And Text.Regex.Parsec as well, I suppose.
10:12:12 <kzjs> Ah, no, I have a list of delimiters to remove from a string (ie: !.,?) and want to add the return character (\r) and tab character (\t) to that list, since they are all that remain in the text im parsing.  I'm thinking I can just do a "!.,?" ++ toChar(13) or something? does a function like that exist?
10:14:55 <dolio> Why not just "!.,?\t\r" ?
10:15:13 <dolio> I believe chr is the function you're looking for, by the way.
10:15:19 <dolio> > chr 65
10:15:21 <lambdabot>  'A'
10:16:10 <dolio> > chr 13
10:16:12 <lambdabot>  '\r'
10:17:42 <lispy> > char 2025
10:17:43 <lambdabot>  Not in scope: `char'
10:17:46 <lispy> > chr 2025
10:17:48 <lambdabot>  '\2025'
10:18:17 <dolio> > maxBound :: Char
10:18:19 <lambdabot>  '\1114111'
10:18:19 <kzjs> dolio: if i compare a character to that list character by character though, will it compare, eg a == '\r'   ... or a =='\' and on the next pass a == 'r'
10:18:29 <kzjs> or am i misunderstanding and \r is treated as a single character?
10:18:40 <lispy> > chr 13 == '\r'
10:18:42 <lambdabot>  True
10:18:54 <dolio> \ escapes in a character/string literal.
10:19:01 <dolio> '\\' is the character \.
10:19:32 <kzjs> ahh, okay
10:19:38 <kzjs> thanks!
10:19:40 <lispy> > chr 13 `elem` "one\rtwo"
10:19:41 <lambdabot>  True
10:19:49 <dolio> No problem.
10:28:15 <norpan> hmmm
10:28:24 <norpan> > ord '\n'
10:28:25 <lambdabot>  10
10:43:07 <dancor> does haskell run into stack space limits on non-tail recursion?
10:44:56 <dolio> It can.
10:45:17 <dancor> are there any language which do not
10:45:24 <dancor> s/ge/ges
10:45:45 <dolio> > let len [] = 0; len (_:xs) = 1 + len xs in len [1..5000000]
10:45:49 <sjanssen> there are also cases where Haskell doesn't run into stack space limits on non-tail recursion when other languages would
10:45:50 <lambdabot> Terminated
10:45:56 <dolio> > let len [] = 0; len (_:xs) = 1 + len xs in len [1..500000]
10:45:58 <lambdabot>  500000
10:46:04 <dolio> > let len [] = 0; len (_:xs) = 1 + len xs in len [1..1000000]
10:46:07 <lambdabot>  1000000
10:46:09 <dylan> any languages that run on machines with infinite stack space...?
10:46:22 <sjanssen> > length [1..5000000]
10:46:26 <lambdabot>  5000000
10:46:28 <psnl> dylan: CFLs?
10:46:36 <dancor> languages which will do recursion with the full memory of the machine
10:46:58 <dolio> There might be a compiler flag to turn off stack space limits.
10:47:15 <sjanssen> dancor: this isn't exactly a language question.  An implementation of Haskell could use an unbounded stack
10:47:59 <sjanssen> one could even make C use an unbounded stack
10:48:07 <dancor> interesting
10:48:25 <psnl> sjanssen: been there, done that ;-)
10:48:59 <dancor> what languages are haskell-like but not lazy
10:49:03 <dancor> i guess ml?
10:49:22 <psnl> dancor: there is a branch of haskell thats non-lazy
10:49:22 <dylan> ML lacks type classes and monads.
10:49:36 <sjanssen> dancor: it's probably more accurate to say that Haskell is like ML and not the other way around
10:49:40 <dylan> (well, you can have monads, but not as nicely)
10:50:01 <sjanssen> dancor: does laziness scare you? ;)
10:50:23 <dancor> sjanssen: yes :)  well i'm not always sure i want the overhead
10:51:25 <dancor> is laziness important for making naive recursios like a(n) = a(n - 1) + a(n - 2) fast?
10:51:44 <dancor> s/sios/sions
10:51:58 <sjanssen> dancor: memoization is what you'd need to make that fast
10:52:03 <sjanssen> or just don't do that
10:52:10 <dcoutts> Igloo, rooms booked for 9am-1pm on the 16th. Yes, I'll need MAC addresses.
10:52:25 <dancor> sjanssen: but isn't that the simplest way to express that
10:52:40 <astrolabe> dancor: that would be slow
10:52:52 <sjanssen> dancor: if the overhead of laziness is too much, add strictness!  It's easy in the latest GHC
10:53:13 <dancor> sjanssen: wouldn't it be cool if you cool do things simply and the language/compiler would make them fast
10:53:23 <dancor> s/you cool do/you could do
10:53:23 <Igloo> cdfh: OK, cool, thanks
10:53:32 <Igloo> Woah, that went wrong
10:53:39 <Igloo> dcoutts: OK, cool, thanks
10:53:45 <sjanssen> dancor: that probably is the simplest way to write that.  But we're programmers, we have to make sacrifices to practicality every once in a while
10:53:49 <dcoutts> heh
10:54:02 <dcoutts> Igloo, will we need a video projector ?
10:54:21 <Igloo> I doubt it
10:54:37 <dancor> sjanssen: do you think languages will progress to the point where that kind of recursion will be ok
10:55:19 <dcoutts> Igloo, do you remember what time the main stuff starts ?
10:55:48 <Igloo> no
10:56:36 <roconnor> apparently I don't understand seq
10:59:39 <fons> hi all
11:00:45 <sjanssen> dancor: possibly
11:02:06 <ptolomy> I'm a little ashamed of how often I check the Shootout page to see if new Haskell entries have been added
11:02:36 <dolio> I've heard of compilers that can turn a naive fibonacci algorithm into a linear one. But that particular example isn't too hard as such optimizations go.
11:03:06 <gzl> um
11:03:15 <gzl> is it me or is the ghc 6.6 distribution for os x intel messed up?
11:04:07 <gzl> aha. it's me.
11:04:10 <gzl> good
11:04:32 <dancor> sjanssen: do you think making that kind of thing fast could be impossible in some halting-problem-esque way?
11:05:06 <lispy> did you guys see that the shootout has upgraded ghc?
11:05:09 <lispy> http://shootout.alioth.debian.org/debian/haskell.php
11:05:16 <pkhuong> dolio: it's neat, they generalize strength reduction to static dynamic programming. Lots of interesting optimisations are expressible that way.
11:05:16 <lambdabot> http://tinyurl.com/yap2gq
11:05:20 <lispy> look at the very bottom where they say which version
11:06:16 <lispy> dons: time to start optimizing again :)
11:07:16 <edwardk> heh, just got some random email to give an invited talk at some conference i've never heard of, trying to figure out if its spam or what the angle is =)
11:07:35 <dolio> lispy: The upgrade alone improved some scores. :)
11:08:06 <lispy> edwardk: heh, cool
11:08:27 <lispy> dolio: do you happen to have the before and after scores?
11:08:56 <edwardk> its got a bunch of references to real people and refers to a .edu address for the conference information, etc.
11:09:10 <dolio> lispy: No, but the gentoo box is still running 6.4.2.
11:09:30 <Binkley> heh, and I just noticed that a paper I co-wrote that I didn't think was even *published* was cited someplace
11:09:33 <dolio> lispy: So unless GHC is way better on semprons than Pentium 4s, the scores went up.
11:09:52 <Binkley> edwardk: try randomly generating a paper and submitting it, to see what happens. though that's been done before
11:10:02 <lispy> dolio: well, if they are using amd64 then i would expect worse scores
11:10:02 <astrolabe> edwardk: maybe they'll review your talk, and decide it's only suitable for a normal slot, and you'll have to pay to attend.
11:10:12 <roconnor> edwardk: it is spam, more or less.
11:10:21 <lispy> dolio: simply because the amd64 stuff isn't as well optimized
11:10:27 <roconnor> the idea is that you get a vacation in florida and charge the university.
11:10:31 <dolio> Is sempron 64-bit?
11:10:43 <roconnor> so if you are immoral you can go.
11:10:50 <lispy> dolio: ah, i was hoping you knew
11:10:51 <edwardk> roconnor, astrolabe: kinda figured =)
11:11:02 <edwardk> or in this case to bulgaria =)
11:11:06 <roconnor> oh
11:11:08 <dolio> I was thinking it's 32.
11:11:16 <roconnor> bulgaria.  That doesn't sound sunny at all.
11:11:25 <arcatan> iirc, some semprons are 32-bit, some 64-bit
11:11:25 <edwardk> have friends there, could visit =)
11:11:26 <dolio> Sempron is the more budget chip, I believe.
11:14:17 <edwardk> seems like the classic hey lets someone to publish something that we can lock up in our journal and require folks to pay us to get access to it kind of thing.
11:46:47 <glguy> What is actually happening when IRSSI is "syncing" the channel
11:47:04 <glguy> and way might that take 204 seconds?
11:49:46 <glguy> ?version
11:49:47 <lambdabot> lambdabot 4p257, GHC 6.5 (OpenBSD i386)
11:49:47 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
11:56:08 <therp> wow cool, GHC is able to lift a function from one linker space into its own compiler linker space. that's pretty neat. welcome, compiler state modifying meta-programming!
11:57:30 <Syzygy-> therp: Oh?
11:57:34 <lisppaste2> mixc pasted "Haskell Trees" at http://paste.lisp.org/display/29390
11:58:11 <therp> syzygy: I was convinced that this will fail when coding it, but it didn't
11:58:36 <fons> does anyone now if there is any plan of releasing a new version of GHC soon (it doesn't seem likely to happen but I would love that it did due to bug http://hackage.haskell.org/trac/ghc/ticket/933)
11:58:40 <lambdabot> Title: #933 (Separate compilation fails with existential records) - GHC - Trac, http://tinyurl.com/ykyou4
11:58:42 <fons> know*
12:01:33 <Syzygy-> fons: 6.6? Or -yet- another?
12:02:20 <fons> Syzygy-, a stable branch version
12:03:00 <Syzygy-> No idea.
12:03:40 <dcoutts> @seen xerox
12:03:41 <lambdabot> I saw xerox leaving #haskell.it, #haskell-overflow and #haskell 45m 20s ago, and .
12:14:13 <spamyboy> Pleas anyone click on this link (afiliat): http://www.tufat.com/aff.php?id=3138 (i need more 40 click to purcha one script) Thank you
12:14:16 <lambdabot> Title: Darren's Script Archive - chatrooms, image galleries, applets, advanced php/mysq ...
12:14:38 <dylan> ...
12:15:14 <Heffalump> well, at least he was honest..
12:16:27 <Igloo> fons: I don't think that will be fixed in 6.6.x
12:17:00 <Igloo> fons: according to the current plan, at least
12:20:11 <dylan> glguy: irssi is waiting for the list of users to stop
12:20:24 <dylan> as it gets one user per line or something
12:34:15 <_frederik_> is it still necessary to modify Setup.hs if one wants to preprocess a source file?
12:43:21 <edwardk> -frederik- with -cpp?
12:44:35 <xerox> ?pl \x -> you x off
12:44:36 <lambdabot> flip you off
12:46:10 <_frederik_> edwardk: not really
12:48:03 <edwardk> _frederik_: preprocess how?
12:48:46 <_frederik_> edwardk: well, if i go into detail it will be confusing. but it's more general than what ghc supports by default. i basically want to run a command to produce the .c or .o file which ghc will use
12:49:11 <edwardk> founds like you need to hack up the Setup.lhs
12:49:16 <edwardk> er sounds like
12:50:43 <edwardk> > let (.) :: Functor f => (a -> b) -> f a -> f b; (.) = fmap in ((+2) . (*3)) . [1..10]
12:50:44 <lambdabot>  [5,8,11,14,17,20,23,26,29,32]
12:51:00 <edwardk> that never gets old
12:52:53 <syntaxfree> I can't help but notice there's no Panther build of GHC 6.6
12:53:01 <syntaxfree> Where can I file a formal request?
12:53:12 <xerox> Panther?
12:53:20 <syntaxfree> OS X 10.3
12:53:27 <syntaxfree> The current builds require 10.4
12:53:33 <xerox> oh.
12:53:44 <syntaxfree> which both costs money and doesn't run well on slightly lower end Macs, like my early-2005 mini.
12:53:57 <xerox> oh :(
12:54:05 <Igloo> If you want an OS that doesn't cost money, try www.debian.org  :-)
12:54:21 <syntaxfree> Heh. I've done the Linux thing for about four or five years.
12:54:30 <xerox> Igloo: every time I try to install ubuntu I fail, on this iMac, grrrr.
12:54:36 <Igloo> What is it that actually needs 10.4?
12:54:45 <Heffalump> xerox: get some proper hardware ;-)
12:54:50 <syntaxfree> Hacking is fun, but not when you need to hack your way out of every little simple problem.
12:55:02 <Igloo> xerox: debian.org doesn't provide ubuntu
12:55:08 <xerox> Heffalump: it's pretty cool
12:55:12 <xerox> Igloo: I know
12:55:12 <syntaxfree> Dunno, I'm downloading the 10.4 build to check out.
12:55:26 <syntaxfree> 10.4 is a different OS from the kernel up, though.
12:56:14 <syntaxfree> anyway, I'd wager it's rather simple to build for 10.3 as long as you know how to compile .dpkg installers already (I don't)
12:56:42 <Igloo> syntaxfree: Do you really mean .dpkg, .deb or .dmg?
12:56:57 <Heffalump> what's .dpkg and .dmg?
12:57:04 <syntaxfree> .dmg is a disk image.
12:57:07 <Igloo> dmg is some MacOS thing
12:57:17 <syntaxfree> often containing a .app you can drag to your applications folder.
12:57:21 <Igloo> I can only remember it because I pronounce it "damage"
12:57:24 <syntaxfree> GHC is distributed as a .dpkg, which is an installer.
12:57:26 <edwardk> they tend to toss around disk images as their official distribution format.
12:57:41 <edwardk> Igloo: thats pretty much standard usage, most of my friends at apple do too =)
12:57:52 <syntaxfree> GHC won't behave well as a nifty .app, so they install it at /usr/local/bin as a normal unixy app.
12:58:08 <syntaxfree> the .dpkg is a graphical self-installer format.
12:58:19 <Igloo> syntaxfree: Where is the .dpkg for 10.4?
12:58:32 <syntaxfree> inside the tarball.
12:59:04 <Igloo> Oh, fair enough. I assumed it was just a bindist
12:59:49 <syntaxfree> oh. this time there's no .dpkg at all, just shell scripts.
13:00:03 <syntaxfree> GHC 6.4 shipped with a .dpkg. Far more professional.
13:01:14 <syntaxfree> (it seems to be installing.)
13:01:47 <syntaxfree> In other news, today I realised I understand the PhD/Squiggol factorial version of "The Evolution of a Haskell Programmer". How screwed up is that?
13:03:17 <Binkley> heh
13:03:20 <edwardk> SyntaxNinja: heh
13:03:22 <edwardk> er
13:03:23 <Binkley> I think there should be some kind of award for that
13:03:25 <edwardk> syntaxfree: heh
13:03:46 <syntaxfree> I should really stop reading Erik Meijer papers and work on my own research some more.
13:04:26 <edwardk> syntaxfree: hehe, yeah, went and collected a bunch of things on the bird meertens formalism, read them in the background while doing other stuff, and all of a sudden one day it just clicked.
13:06:06 <edwardk> er, and sitting down to show that the generalized catamorphism is less useful than the list one because there is no way to readily pair up constructors and destructors to get a REALLY fast foldr/build rule like we have with lists was a bit disheartening, there is a paper by ghani et all that has a cata/ana fusion rule, but its ugly
13:06:14 <Binkley> as matt groening said, "the best way to avoid the stomach-churning agony of having to finish your thesis: read another paper"
13:06:41 <syntaxfree> the problem being that my thesis is completely unrelated to computer programming.
13:06:42 <Binkley> edwardk: what do you mean? you'd just need a build for each datatype
13:06:42 <edwardk> Binkley: heh that explains my obsession with papers and lack of thesis progress quite well.
13:06:44 <Binkley> well, that is ugly
13:06:49 <Binkley> but build is ugly in the first place
13:06:56 <syntaxfree> And by completely unrelated I mean "my thesis topic would exist if computers were never invented".
13:07:14 <edwardk> Binkley: there is a cata/ana fusion, form, thats fine, the problem comes in in the augment case as i recall
13:07:19 <edwardk> one sec, digging up the paper
13:07:37 <Binkley> edwardk, i find this comic to be quite relevant also (re: the thesis comment) -- http://www.phdcomics.com/comics/archive.php?comicid=413
13:07:40 <syntaxfree> oh geeze.
13:07:47 <lambdabot> Title: Piled Higher and Deeper, http://tinyurl.com/cgjaz
13:07:48 <syntaxfree> I attempted to install ghc-6.6 and now it broke my ghc 6.4
13:07:51 <Binkley> heh
13:08:03 <edwardk> syntax: yeah happened to me too
13:08:08 <syntaxfree> blinkley: is that the "carrying papers around makes you feel productive" one?
13:08:25 <Binkley> syntaxfree: no, it's a list of things to do while waiting for your experiment to finish, and one is "read a couple of research papers"
13:08:28 <syntaxfree> I'm gonna try and compile it.
13:08:30 <Binkley> but the illustration for that is just awesome
13:08:42 <Binkley> Yeah, you people wouldn't have these problems if you would just build ghc from source :P
13:08:43 <edwardk> its timing out for me
13:08:47 <edwardk> there we go
13:08:48 <Binkley> (you'd have different, more horrible problems)
13:09:37 <Codex_> more fun problems!
13:09:43 <Binkley> ha
13:09:49 <Binkley> depends on your definition of "fun"
13:10:07 <syntaxfree> ah, jesus.
13:10:14 <syntaxfree> now I don't have a working ghc.
13:10:17 <Binkley> heh
13:10:17 <wchogg> I have a question:  is Control.Arrow going anywhere or will it remain supported in GHC in the forseeable future?
13:10:37 <syntaxfree> (all because I wanted the happy happy fun fun GSLHaskell)
13:10:43 <Igloo> wchogg: Why do you ask?
13:10:44 <edwardk> i hope it doesn't leave almost everything i have coded depends on it
13:11:09 <wchogg> Igloo:  Mostly because I'm working on a project that I think would work best with arrows.
13:11:31 <Igloo> wchogg: Arrows will stay around, I'm sure, but the library might become packaged separately
13:11:37 <edwardk> http://portal.acm.org/citation.cfm?id=1086403&dl=&coll=GUIDE&CFID=15151515&CFTOKEN=6184618 is the paper i was thinking of
13:11:39 <lambdabot> Title: Monadic augment and generalised short cut fusion, http://tinyurl.com/yltufg
13:11:53 <Binkley> oh, wow
13:11:54 <wchogg> Igloo:  Okay.  That's really all I need.
13:11:59 <Binkley> thanks -- that's good to know about
13:12:23 <Binkley> heh, and i should know about it, too, since one of the authors was one of my research advisors in the past
13:12:26 <Binkley> but i didn't
13:12:32 <syntaxfree> oh such grace.
13:12:39 <syntaxfree> I need a working GHC to install GHC.
13:12:46 <Binkley> well, yeah
13:12:52 <Binkley> from source, anyway
13:12:55 <Binkley> should install just fine from binaries
13:12:56 <edwardk> i find "cata_f h (augment_f g k) = g (h . (>>! pmap (cata_f h)) . unIn . k))" to be a particularly ugly reduction rule. =)
13:12:56 * syntaxfree tries to find the rather professional-looking .dpkg he got 6.4.2 from.
13:12:59 <Binkley> heh
13:13:04 <syntaxfree> well, IT DOESN'T!
13:13:05 <edwardk> Binkley: which one?
13:13:13 <Igloo> what happens?
13:13:14 <Binkley> edwardk: patricia johann#
13:13:19 <Binkley> just for a summer, though
13:13:23 <edwardk> ah
13:13:41 <syntaxfree> to add insult to injury, that installer is vanished.
13:13:48 <syntaxfree> Now I never ever shall have GHC again.
13:13:49 <edwardk> met neil ghani at the ICFP, but didn't know i'd read a ton of his papers at the time. =)
13:13:51 * syntaxfree cries.
13:13:54 <Binkley> heh
13:13:56 <edwardk> we just talked a bit about comonads
13:14:22 <Binkley> patty is pretty cool. I ought to look at that paper.
13:14:31 <wchogg> What about comonads?
13:14:34 <Binkley> insofar as I fool myself into thinking I'm ever going to work on deforestation again
13:14:35 <Igloo> syntaxfree: Following the isntructions ought to just work even with no GHC installed
13:14:38 <syntaxfree> comonads need a better name.
13:14:48 <Binkley> like we said earlier, cowarmfuzzythings
13:14:49 <syntaxfree> Like "crabby patties".
13:14:55 <syntaxfree> "monads" are ok.
13:15:09 <syntaxfree> but "comonads" reads "como-nads" rather than "co-monads".
13:15:38 <edwardk> Binkley: i like cowarmfuzzies, they give me something to think about =-)
13:15:41 <Binkley> heh
13:15:53 <Binkley> it has the added benefit of being parsable as "cow-armfuzzies"
13:15:55 <syntaxfree> I wish Haskell supported squiggol brackets.
13:16:05 <edwardk> they need a shorter name than warmfuzzythings, like 'blanket' or 'slipper' or something =)
13:16:18 <wchogg> Maybe just call them plushies?
13:16:22 <edwardk> heh
13:16:27 <Binkley> heh
13:16:30 <edwardk> class Plushy m where
13:16:40 <Binkley> the functional programming community definitely needs to make more furry fandom references.
13:16:43 <Binkley> I decree it.
13:17:18 <syntaxfree> I've decreed about a month ago that Haskell was to be henceforth called "Concord".
13:17:26 <edwardk> so what would a coPlushy be? needs a less scary name, coFoo is scary mathspeak =)
13:17:26 <syntaxfree> GHC was to be renamed the Genius Concord Compiler.
13:18:00 <syntaxfree> oh. I found a 6.4.1 installer.
13:18:06 <syntaxfree> Oh, fancy next-next-next-finish installers.
13:18:07 <wchogg> But are people still working on comonads in Haskell?  The last thing I remember was someone proving that OI broke referential transparency.
13:18:14 <syntaxfree> So professional.
13:18:39 <edwardk> wchogg: I'm using them a fair bit. OI was a bit of a hack at getting one done, it could be implemented in Clean, but not haskell basically.
13:19:12 <dolio> Didn't someone recently post a supposedly transparent OI to one of the mailing lists?
13:19:13 <syntaxfree> edwardk: on a slightly more serious note, the prefix "co" should be changed to "bizarro", as per Jerry Seinfeld tradition.
13:19:17 <edwardk> the other uses are still valid though
13:19:19 <edwardk> SyntaxNinja: heh
13:19:26 <wchogg> edwardk:  what are you using them for in particular?  I'm not really familiar with the properties they give you.
13:19:31 <edwardk> er syntaxfree: heh
13:19:54 <edwardk> wchogg: i'm using them in a more restricted type system to reintroduce options for contraction and weakening.
13:20:05 <edwardk> linear logic's exponential modality can be viewed as a comonad for instance.
13:20:08 <syntaxfree> bizarro monads. Now that's something worth getting into.
13:20:30 <edwardk> syntaxfree: "what happens in bizarro world, stays in bizarro world"
13:21:08 <syntaxfree> well, bizarro . bizarro = id.
13:21:26 <edwardk> yeah not a comonad-like property
13:21:44 <syntaxfree> it could be argued that the id world is just the bizarro world inside the bizarro world.
13:21:46 <edwardk> you'd neat twice as bizarro is still bizarro, which is a pretty bizarro property =)
13:21:57 <edwardk> er you'd need
13:23:21 <syntaxfree> when do I need -extralibs.tar.bz2?
13:24:19 <dylan> I wish I could pattern match on bytestrings.
13:24:22 <Binkley> heh, random google groups searching turns up some fun stuff sometimes...
13:24:22 <Binkley> http://groups.google.co.uk/group/comp.lang.functional/browse_frm/thread/4b89e5f8160ce0d1
13:24:24 <lambdabot> Title: Google Groups : comp.lang.functional, http://tinyurl.com/y4hruy
13:25:05 <glguy> You need extralibs when you are compiling and want to use the libraries that you expect ghc to have
13:26:03 <edwardk> its funny what  14 years of coding will do for a project =)
13:26:07 <Binkley> heh
13:27:24 * SamB doesn't think that bizarro . bizarro = id
13:27:45 * SamB thinks that bizarro \ne bizarro, too
13:27:48 <SamB> or.
13:27:56 <glguy> dylan: you to eat your cake and have it too?
13:27:59 <syntaxfree> did you watch the "Bizarro Jerry" episode?
13:28:05 <SamB> rather, bizarro x /= bizarro x
13:28:27 <SamB> or should I say is-not-necessarily-equal-to?
13:28:35 <syntaxfree> do you say bizarro breaks referential transparency?
13:28:40 <SamB> yes!
13:28:43 <syntaxfree> I don't think you've seen "Bizarro Jerry".
13:28:49 <edwardk> it is bizarro after all =)
13:28:56 <syntaxfree> Bizarro Kramer is all about referential transparency.
13:29:00 <Binkley> heh
13:29:01 <SamB> indeed, I have not seen bizarro jerry
13:29:15 <dylan> glguy: yes.
13:29:17 <syntaxfree> and I'm sure the Bizarro Kramer, with his neat and respectful ways, would find the ordinary Kramer quite bizarro.
13:29:27 <edwardk> bizarro to me usually transforms into some sort of cheesy late 70s superman comic reference for some reason
13:29:41 <gour> dons: ping
13:29:58 <SamB> edwardk: for me it is just a superman reference
13:30:18 <edwardk> fair enough
13:31:10 <syntaxfree> so, is -extralibs supposed to be compiled separately?
13:33:23 <syntaxfree> or do I need it to compile 6.4?
13:33:28 <syntaxfree> er, 6.6
13:33:33 <syntaxfree> I'm bootstrapping it from 6.4.1
13:33:47 <SamB> no, you only need the corelibs
13:34:05 <SamB> or something is quite wrong with 6.6...
13:34:25 <syntaxfree> so I only need -extralibs if I need some bizarro stuff in my compiled programs?
13:34:37 <SamB> it need not be "bizarro"
13:34:57 <syntaxfree> what need it be?
13:35:06 <SamB> also it is useful if you want that stuff for your non-compiled programs ;-)
13:35:21 <syntaxfree> what stuff?
13:36:02 <SamB> @google "ghc/libraries/extra-packages"
13:36:03 <syntaxfree> cool. Perl is used to bootstrap Haskell.
13:36:05 <lambdabot> http://darcs.haskell.org/ghc/libraries/extra-packages
13:36:15 <SamB> that lists the packages in extralibs, okay?
13:36:21 <syntaxfree> It's nice, since Haskell is being used to bootstrap Perl these days.
13:36:36 <syntaxfree> Okay. But is extralibs compiled separately, or do I need it in the same directory as the ghc-6.6 sources?
13:37:07 <SamB> you would have the per-package directories under ghc/libraries with the main libraries
13:37:46 <syntaxfree> hmm. so I need to set them (-extralibs) up in the proper folders before compiling GHC?
13:38:05 <SamB> well, that is the most convenient way, yes
13:38:11 <syntaxfree> okie dokie.
13:38:14 <SamB> it should be fairly simple and is probably documented somewhere
13:38:18 <syntaxfree> sorry if the questions were starting to get annoying.
13:38:31 <SamB> I don't build from tarballs personally ;-)
13:38:32 <syntaxfree> I think I'm more at home with the bananas than with the makefiles.
13:38:39 <SamB> heh
13:38:51 * syntaxfree is partial to barbed wire, though.
13:39:01 <SamB> how 'bout them lozenges?
13:39:17 <syntaxfree> I haven't come accross them.
13:39:21 <SamB> oh.
13:39:24 <syntaxfree> By the way, open-ended question.
13:39:31 <SamB> I must be confusing lozenges with lenses or something..
13:39:42 <syntaxfree> ah, lenses, yes. Anamorphisms.
13:39:45 <syntaxfree> Annas.
13:39:53 * SamB didn't really get that squiggol stuff too well
13:40:12 <syntaxfree> anyway, I'm managing to parse "FP with bananas, etc. etc." and "Bananas in space" sort of fine, if slowly.
13:40:33 <syntaxfree> I'm trying to learn type theory from freely available material. What other papers/tutorials/whatever I can get in a pdf would you recommend?
13:40:45 * syntaxfree is also trying... trying slowly ... to parse Freyd's "Abelian categories".
13:43:49 <matuso> hi
13:49:29 <dolio> Wow. A slashdot *comment* posted to reddit. :)
14:04:34 <glguy> ?ver
14:04:35 <lambdabot> Maybe you meant: vera version
14:04:38 <glguy> ?version
14:04:39 <lambdabot> lambdabot 4p257, GHC 6.5 (OpenBSD i386)
14:04:40 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:26:08 <SyntaxNinja> who is in charge of www.haskell.org wiki these days?
14:30:41 <SamB_XP> "in charge"?
14:41:34 <glguy> time to stop lagging in and out of the channel... tor ftl
14:48:48 <osfameron> evening
14:49:04 <osfameron> anybody got any advice on how to install the "binary" for OSX ?
14:49:11 <osfameron> it appears to require make and gcc to install it
14:49:15 <osfameron> which doesn't seem very binary to me
14:52:23 <SamB> osfameron: maybe you only need those to use it
14:52:27 <SamB> ?
14:52:42 <osfameron> SamB: hmmm?
14:53:01 <SamB> well, you would need GCC anyways
14:53:03 <zptao> i dunno what it means in the haskell context, but binary generally refers to anything but plaintext
14:53:19 <SamB> I guess you wouldn't technically need make
14:53:36 <osfameron> I'd think binary meant you got an executable you could invoke, and it just worked
14:53:50 <osfameron> this one comes with an INSTALL file that suggests running configure and make
14:54:10 <merus> perhaps you downloaded the wrong thing?  I had the link yesterday, but I've misplaced it.
14:54:12 <osfameron> and of course, my dad never installed the developer tools for osx, and has lost the system disks
14:54:18 <SamB> oh, great
14:54:23 <merus> Well, it certainly requires the dev tools.
14:54:30 <osfameron> merus: ooo, possibly.  let me check.  This was for ghc
14:54:33 <SamB> you had better download them off the website?
14:54:39 <osfameron> SamB: yarrr
14:54:43 <osfameron> the problem being he has 10.3
14:54:56 <osfameron> and the latest version of xcode 2.4.1 needs 10.4
14:55:05 <osfameron> and I can't find the download link for the earlier version
14:55:12 <dons> ?users
14:55:12 <lambdabot> Maximum users seen in #haskell: 265, currently: 230 (86.8%), active: 30 (13.0%)
14:55:23 <merus> Ah!  That's unfortunate.  They stopped distributing 10.3's devtool.
14:55:30 <merus> They = Apple.
14:55:34 <SamB> excellent!
14:55:34 <osfameron> unfortunate?
14:55:36 <osfameron> it's criminal
14:55:39 <osfameron> apple--
14:55:46 <SamB> @karma apple
14:55:46 <lambdabot> apple has a karma of -1
14:56:27 <chessguy> is there a complement to filter? that only keeps elements for which the boolean function is false?
14:56:44 <merus> You could theoretically upgrade your gcc and libtools... but I don't know how to do that, or if it would work.
14:56:56 <osfameron> don't suppose any of you have a copy of the devtools sitting on a webserver somewhere? ;-)
14:57:06 <dons> chessguy: filter (not . f)
14:57:06 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
14:57:12 <monochrom> @hoogle (a->Bool)->[a]->[a]
14:57:13 <SamB> @pl (\f xs -> filter (not . f) xs)
14:57:14 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
14:57:14 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
14:57:14 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
14:57:14 <lambdabot> filter . (not .)
14:57:24 <SamB> chessguy: filter . (not .)
14:57:38 <chessguy> hmm, why is that composed?
14:57:48 <SamB> what?
14:57:56 <monochrom> because it works
14:57:57 <chessguy> @type (filter . (not .))
14:57:58 <SamB> why wouldn't it be composed?
14:57:58 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
14:58:17 <chessguy> @type (filter . (not .)) (==1)
14:58:19 <lambdabot> forall a. (Num a) => [a] -> [a]
14:58:24 <chessguy> interesting
14:58:36 <SamB> @pl (filter . (not .)) (==1)
14:58:37 <lambdabot> filter (1 /=)
14:58:55 <monochrom> Woah!  It has intelligence!
14:59:00 <SamB> no
14:59:03 <SamB> just good rules
14:59:17 <SamB> @pl f . fix . const . g
14:59:17 <lambdabot> f . fix . const . g
14:59:29 <chessguy> (\x y -> x+y) 3 4
14:59:32 <chessguy> > (\x y -> x+y) 3 4
14:59:33 <lambdabot>  7
14:59:35 <SamB> that still doesn't work, despite a rule that you'd think would tell it it could do that
14:59:49 <SamB> chessguy: are you trying to play with @pl?
14:59:56 <SamB> because > is not the same thing as @pl
15:00:11 <SamB> @pl [1..4]
15:00:12 <lambdabot> [1..4]
15:00:17 <chessguy> > True && False
15:00:19 <lambdabot>  False
15:00:19 <SamB> @pl [1..4] !! 2
15:00:20 <lambdabot> [1..4] !! 2
15:00:31 <SamB> @pl True && False
15:00:31 <lambdabot> False
15:00:48 <SamB> @pl (\x y -> x+y) 3 4
15:00:49 <lambdabot> 7
15:01:00 <SamB> however sometimes it does just give the answer
15:01:37 <pejo> osfameron, if you register you can download the devtools for free, if you're talking about the 10.4 stuff.
15:01:56 <osfameron> pejo: nope, 10.3
15:02:09 <SamB> if necessary, I'm sure you can find non-apple builds...
15:02:13 <osfameron> luckily, someone with serious google foo, just found me http://connect.apple.com/cgi-bin/WebObjects/MemberSite.woa/104/wa/download?path=%2FDeveloper_Tools%2Fxcode_v1.5%2Fxcode_tools_1.5_cd.dmg.bin&wosid=8i6NspbzoLzI2nkS3wF1KaTN7JQ
15:02:18 <lambdabot> http://tinyurl.com/vuf7t
15:02:26 <SamB> wow
15:02:29 <SamB> what a horrible URL
15:02:29 * osfameron pats lambdabot
15:02:43 <SamB> didn't they used to have an FTP site?
15:02:55 <SamB> or a reasonable HTTP approximation?
15:03:00 * SamB always liked those
15:03:14 <osfameron> they seem to want to make it difficult to get the tools to make you upgrade to whatever big cat it's currently on
15:03:43 <chessguy> ok, i have a bit-pattern like 1###0####### (# means don't care) and a list of lists of binary digit, where each element in the list has the right number of bits. i want to remove all the lists which match the pattern. suggestions?
15:03:49 <SamB> why, I once downloaded some old version of Mac OS from their website to run in an emulator!
15:04:45 <SyntaxNinja> SamB_XP: yeah, like who maintains it.
15:05:03 <SyntaxNinja> does anyone know who maintains the wiki on www.haskell.org? is it just john peterson?
15:05:25 <SamB> @pl (0x800 ==) . (0x880 .&.)
15:05:25 <lambdabot> (2048 ==) . (2176 .&.)
15:05:28 <shapr> Do you mean haskellwiki?
15:05:35 <SamB> hmm, not much of an improvement
15:05:35 <shapr> That's Ashley Yakeley
15:05:52 <SamB> chessguy: does that look reasonable?
15:06:32 <chessguy> i have no idea what you just did
15:07:20 <SamB> @type filter (not . (0x800 ==) . (0x880 .&.))
15:07:22 <lambdabot> forall a. (Bits a) => [a] -> [a]
15:07:38 <chessguy> where did you get the 0x800 and 0x880
15:07:50 <SamB> 0x880 is the bits you care about
15:08:00 <SamB> 0x800 is the values you want them to have
15:08:12 <SamB> or, rather, don't want them ot have
15:08:24 <chessguy> hmmm
15:08:33 <chessguy> i'll have to experiment with that
15:08:45 <chessguy> (i actually lied, i have a bunch of those bit patterns)
15:09:15 <SamB> you could easily write a compiler that will make these functions for you
15:09:54 <chessguy> ok, i'll play with it. thanks
15:10:28 <SamB> from strings in the format of "1###0#######", even
15:10:30 <int-e> mask1 [] = 0; mask1 ('1':xs) = 2*mask1 xs+1; mask1 (_:xs) = 2*mask1 xs
15:10:35 <SamB> you could do it dynamically or statically
15:10:59 <int-e> that gives the 0x800 in SamB's code.
15:11:51 <SamB> (personally I suggest dynamically, unless you have some kind of wierd TH deathwish or something...)
15:12:30 <SamB> well actually that wouldn't be hard to use with TH anyway
15:14:24 <syntaxfree> this chance matter of compiling programs gets old, fast.
15:14:32 <syntaxfree> now it says I need a new gn u make.
15:14:58 <syntaxfree> I'm afraid I'll need an intermediate version of gnu make to make the newest gnu make, given my present luck.
15:15:01 <monochrom> syntaxfree = syntaxninja?
15:15:10 <syntaxfree> no, syntaxfree = myself.
15:15:15 <syntaxfree> I'm here all the time.
15:15:20 <syntaxfree> All the time = about 10, 12 hours a week.
15:16:07 * syntaxfree gloats, boasts and snickers about his new keyboard. Smooth stuff.
15:17:03 <int-e> fun thing to say 2 minutes after joining a channel isn't it :)
15:17:50 <syntaxfree> anyway, what kind of gnu make I need to compile ghc 6.6?
15:18:03 <SamB> a working one?
15:18:07 <int-e> 3.81 worked for me
15:18:09 <SamB> not gnarly and gnold?
15:19:04 <syntaxfree> Mingus:~/downloads/ghc-6.6 syntax$ make --version
15:19:04 <syntaxfree> GNU Make version 3.79, by Richard Stallman and Roland McGrath.
15:19:04 <syntaxfree> Mingus:~/downloads/ghc-6.6 syntax$ make && sudo make install
15:19:04 <syntaxfree> mk/config.mk:31: *** GNU make version 3.79.1 or later is required..  Stop.
15:19:04 <syntaxfree> *sigh*
15:19:07 <syntaxfree> It MUST be me.
15:20:11 <syntaxfree> it's god chastizing me for messing with the bananas before getting the basics right.
15:21:39 <SamB> "make" is hardly the basics
15:21:49 <SamB> (of Haskell)
15:22:06 <syntaxfree> I know.
15:22:16 <syntaxfree> But I lack compiler knowledge.
15:22:19 <SamB> naesten@hydrogen:~/hacking/haskell/delimited% make --version
15:22:19 <SamB> GNU Make 3.80
15:22:31 <syntaxfree> Or graph theory knowledge.
15:22:36 <syntaxfree> or assembly language knowledge.
15:22:50 <syntaxfree> or C knowledge. Haskell and Scheme (and some PHP, enough to make me puke) are everything I know.
15:23:01 <syntaxfree> I have NO business messin' with the bananas.
15:23:23 <osfameron> always bring a banana to a party!
15:23:53 * syntaxfree actually prefers barbed wire.
15:24:02 <jgrimes> o.o
15:24:14 <SamB> hmm, I find barbed wire too painful to chew, personally
15:24:29 <int-e> 3.79.1 seems to date from july 2000? that's oooold.
15:24:37 <SamB> osfameron: wouldn't it be nicer to bring a whole bunch?
15:24:52 <SamB> Copyright (C) 2002  Free Software Foundation, Inc.
15:24:54 <SamB> btw
15:25:09 <SamB> for 3.80
15:25:20 <osfameron> SamB: a whole bunch of barbed wire?
15:25:31 <SamB> of bananas
15:26:22 <syntaxfree> I need to get my room tidy.
15:26:27 <syntaxfree> And then get some research done.
15:26:34 <int-e> oh, maybe the file datas on ftp://ftp.gnu.org/gnu/make/ are the correct release dates.
15:27:10 <SamB> ah! a proper FTP site!
15:27:11 <int-e> it seems you have to be rather unlucky to have 3.79.
15:27:27 <SamB> hmm
15:27:37 <SamB> they all say 12:00:00 AM
15:27:45 <SamB> that smacks of DOS
15:27:54 <SamB> I think...
15:28:21 <syntaxfree> oddly enough, it's what shipped with this box (OS X 10.3.7) and the update to 10.3.9 failed to update it.
15:28:37 <syntaxfree> that's funny, because I used to have problems because my gcc was *too new*
15:28:51 <SamB> oh, well, at least it is a gmake!
15:29:08 <SamB> just build a newer one, why don'tcha?
15:29:19 <syntaxfree> I'm building.
15:29:28 <syntaxfree> i'm just bitching that there's no one-click install.
15:30:15 <SamB> WTH is a one click install?
15:30:54 <int-e> where you click on a million menu items to find the one button that if clicked once will install the software.
15:31:07 <SamB> oh, those
15:31:21 <mauke> click the Terminal icon, then type tar xfz foo.tar.gz && cd foo && ./configure && make && make install
15:31:55 <int-e> . o O ( if by 'click the terminal icon' you mean 'press ctrl-alt-x' ;-) )
15:32:44 <int-e> (sorry. personal key binding.)
15:33:29 <mwc> Shame guys... a python article hits slashdot and not a single Haskell comment?
15:33:34 <mwc> :)
15:33:35 <vincenz> yeah
15:33:37 <vincenz> bastards
15:33:51 <mauke> int-e: I don't have a keybinding for that because I don't need it that often
15:34:10 <int-e> fair enough.
15:34:36 <dons> if a haskell article hit slashdot, i supposed we'd be drowned in python comments
15:34:47 <mauke> (I'm massively multiplexed: 4 desktops, each Konsole contains 2 or 3 tabs, each tab runs screen)
15:35:33 <dons> ?where+ SmallCheck http://www.cs.york.ac.uk/fp/smallcheck0.2.tar
15:35:33 <lambdabot> Done.
15:35:33 <dons> but still no darcs repo :/
15:36:05 <vincenz> dons: heard about hte quickcheck thing?
15:36:40 <dons> sure. exhausted just means the random instance strugged to find enough unique inputs
15:36:44 <dons> its harmless
15:36:52 <dons> well, in that it doesn't indicated anything bad.
15:37:04 <vincenz> :)
15:37:06 <vincenz> I found it funky
15:37:22 <vincenz> \a b c d e f g h -> a && b && c && d && e && f && g ==> a
15:37:32 <vincenz> \a b c d e f g h -> a && b && c && d && e && f && g && h ==> a
15:37:35 <vincenz> @check \a b c d e f g h -> a && b && c && d && e && f && g && h ==> a
15:37:37 <lambdabot>  Arguments exhausted after 3 tests.
15:37:43 <vincenz> @check \a b c d e f g h -> a && b && c && d && e && f && g ==> a
15:37:44 <lambdabot>  Add a type signature
15:37:47 <vincenz> thought so
15:43:50 <monochrom> One-click build, slashdot, python.  This world is sick.
15:45:45 <palomer> yo my bitches
15:45:52 <palomer> working on a 14 inch screen is fun!
15:45:54 <palomer> go CRT!
15:45:57 * mwc smacks palomer 
15:46:09 <monochrom> heh not even 15?
15:46:17 <mwc> CRT = Cathode Ray of SATAN
15:46:29 <mwc> My first computer had a 12" multiscan :)
15:46:49 <monochrom> That's smaller than my laptop.
15:47:43 <monochrom> Is palomer working at a bank?  That's where one can find such screens nowadays. :)
15:49:56 <zptao> whats the correlation between python and haskell
15:50:03 <monochrom> Their letters are disjoint.
15:51:45 <zptao> burnt
16:01:27 <syntaxfree> ah, but that's no fun.
16:01:27 <dons> cheers related
16:01:27 <related> I'm not very good at trash talk.
16:01:28 <dons> > fix $ \f -> 1 : 1: zipWith (+) f (tail f) -- have a lambda :)
16:01:28 <dons> oh bot split too :/
16:01:28 <dons> ?bot
16:01:28 <dons> ye syes...
16:01:28 <dons> ?bot
16:01:28 <dons> w/ in4
18:25:41 --- topic: '["Design a #haskell tshirt - Distribute your cognition!", "Haskell - the language of ICFP winners 3 years running", "Logs: http://tunes.org/~nef/logs/haskell/"]'
18:25:41 --- topic: set by dons on [Tue Oct 31 01:30:26 2006]
18:31:25 <dolio> I think I got rid of mine. It wasn't very good.
18:32:02 <EvilRanter> I have one that seems to be quite good (not that I've read much of it)
18:32:27 <dolio> Although I probably didn't sell it back to the bookstore, since they pay like 5% of what it costs.
18:32:32 <EvilRanter> but it's from a library, so u _can't_ keep it
18:32:34 <EvilRanter> *i
18:50:28 <dylan> what does this mean?
18:50:30 <dylan> import {-# SOURCE #-} Keymap
18:50:42 <dylan> (or better, where is a list of ghc pragmas?)
18:51:23 <EvilRanter> http://www.google.co.uk/search?q=GHC+pragmas
18:51:25 <lambdabot> Title: GHC pragmas - Google Search
18:52:30 <chessguy> so, my OS prof said tonight that FP violates the principle of locality a lot. comments?
18:54:13 <dylan> huh?
18:54:30 <dylan> how does FP violate locality?
18:54:41 <chessguy> locality as in paging?
18:55:53 <jgrimes> I didn't think locality really mattered anymore?
18:55:58 <jgrimes> without the '?'
18:56:00 <jgrimes> :)
18:56:12 <dylan> err, does FP mandate that about the hardware anyway?
18:56:44 <dylan> sounds like a compiler issue, not a language paradign issue.
18:57:24 <falconair> the professor probably meant that whereas in C an array fairly closely represents how data will be laid out in memory, functional programing allows less control of hardware
18:57:58 <EvilRanter> aren't Haskell Arrays stored sequentially in memory?
19:00:01 <chessguy> well, the example she used was lisp, and she said it's basically implemented with pointers all over the place
19:00:15 <chessguy> so caching doesn't help, because it's not likely to bring in anything useful
19:00:27 <EvilRanter> lisp has "vectors", doesn't it?
19:00:32 <mauke> how is that different from C?
19:00:40 <mauke> C data structures are full of pointers too
19:00:49 <dylan> modern C/C++ toolkits use lots of pointers.
19:00:58 <dylan> witness gtk...
19:00:58 <chessguy> but you can use sequential stuff like arrays
19:01:00 <EvilRanter> that's basically "whee, garbage collection etc" rather then "whee, functional programming"
19:01:14 <EvilRanter> perl, python etc will pointer all over the place, too
19:01:30 <dylan> they'll pointer on the carpet too!
19:01:34 <jgrimes> ;p
19:01:35 <chessguy> lol
19:02:04 <dylan> of course, C will segfault in your bed, so it evens out.
19:02:06 <chessguy> well, i doubt she's up on the latest compiler implementations anyway
19:02:16 <chessguy> was just curious what you guys thought
19:02:25 <pkhuong-> wow. ugliest code ever, but it works, and it'll be parallelisable :\
19:02:29 <mauke> that's just data structures, not language
19:02:31 <falconair> perhaps the professor was pointing out that C is closer to the machine, where as FPs concentrate less on performance...seems like a valid point to me
19:02:57 <pkhuong-> falconair: that's debatable. (purely functional) scheme can be compiled to HDL.
19:02:58 <chessguy> no, it was specifically in the context of things like caching
19:03:23 <EvilRanter> also, there has been such things as dedicated lisp-machines in the past
19:03:31 <psykotic> pkhuong-, the correspondence there is fairly non-local though. with C you have a local and fairly close 1-to-1 correspondence.
19:03:53 <pkhuong-> but yeah, wrt laying your data out, C and C++ have the upper hand.
19:03:54 <chessguy> i've wondered about specialized architecture for FP...did it give much performance boost?
19:04:07 <EvilRanter> I'm led to believe it did
19:04:35 <psykotic> chessguy, generally not enough when you take the market advantages of general purpose hardware into account
19:04:42 <falconair> pkhuong-: i understand, also that ocaml is sometimes faster than C, however C lets me work very closely with memory location, most functional programmers wouldn't do that
19:06:48 <sjanssen> pkhuong-: have you tested whether it has good parallelism (I'm assuming you're talking about your fibonacci program)?
19:06:58 <pkhuong-> sjanssen: well, i'm testing it period.
19:07:25 <pkhuong-> but the last pass is sum (map ...).
19:11:05 <pkhuong-> mm. silent overflows :\
19:11:23 <pkhuong-> ah, Integer, sorry.
19:12:31 <Adamant> would Haskell get any notable improvement from a Haskell Machine? has anyone thought about doing one as a project, maybe on a FPGA/CLPD?
19:12:49 <Adamant> how would you make a Haskell machine anyway?
19:13:10 <EvilRanter> big stack, optimisations for lists and arbitrary integers...
19:13:51 <pkhuong-> good luck getting it to run at a decent fraction of 3.4 GHz.
19:14:10 <EvilRanter> yes, quite
19:14:39 <EvilRanter> you'd need to be a big name processor manufacturer to be able to rival existant imperative-optimised processors
19:14:50 <EvilRanter> (optimise for lazinesss, of course)
19:15:01 <EvilRanter> and there's nowhere near enough demand
19:15:17 <chessguy> just use arbitrarily large memory
19:19:02 <pkhuong-> is there a parallelized fold (for when the order you have a zero and the operator is associative)
19:20:07 <sjanssen> pkhuong-: nope
19:20:39 * lispy waves
19:21:23 * EvilRanter oscillates
19:23:39 * dmead undulates
19:25:27 * sjanssen remains stationary
19:26:52 * EvilRanter measures sjanssen's position, so his velocity is no longer known
19:27:49 <EvilRanter> hm. for some odd reason, all these practical exercises say "use .lhs files!" even tho they rarely ask for non-haskell-code answers
19:28:01 <EvilRanter> and bird tracks break my editor's autoindent
19:28:43 * EvilRanter considers switching to \begin{code} and \end{code}, even 'tho he's not using TeX
19:29:51 <dons> Adamant: FP hardware was popular in the 80s, but its only a research issue unless you can make the hardware a commodity
19:30:05 <dons> better success working out how to implement graph reduction on stock hardware .. :)
19:30:11 <dons> which is what was done instead.
19:30:40 <dibblego> ?doc Eq
19:30:41 <lambdabot> Eq not available
19:30:49 <SamB_XP> yeah. if graph reduction becomes the done thing, they *might* try to figure out how to accelerate it...
19:30:52 <dibblego> ?hoogle Eq
19:30:54 <lambdabot> Prelude.Eq :: class Eq a
19:30:54 <lambdabot> Prelude.EQ :: Ordering
19:30:54 <lambdabot> Text.PrettyPrint.HughesPJ.equals :: Doc
19:31:01 <dibblego> ?docs Eq
19:31:02 <lambdabot> Eq not available
19:31:11 <dibblego> bleh, can I get a link to the GHC docs?
19:31:14 <dons> sjanssen: so did you get the `par` versoin out?
19:31:19 <dons> ?docs Data.List
19:31:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
19:31:39 <dibblego> ta
19:31:54 <sjanssen> dons: no, I started doing homework I should've been doing earlier ;)
19:32:01 <sjanssen> I'll probably try some more tomorrow
19:32:19 <dons> heh ok
19:32:29 <scodil> anyone here use the gsl bindings from alberto ruiz?
19:33:20 <kpreid> dons: I'm experimenting with an unpl
19:33:22 <scodil> it gives me an error "Something is amiss; requested module  GSL-0.6:GSL differs from name found in the interface file GSL:GSL"
19:33:36 <scodil> this seems like something I should be able to fix... anybody got any ideas?
19:34:24 <chessguy> heh. "Something is amiss". that's cute
19:34:51 <scodil> it would be cuter if it was just a warning
19:36:51 <dmead> is there a way to put a hugs prompt in a web page?
19:37:00 <dmead> like with memory pipes in perl or something?
19:37:33 <dons> kpreid: cool
19:37:46 <dons> scodil: hmm. compiled with two different versions of the compiler?
19:37:51 <kpreid> I've been writing it to operate on Language.Haskell.Syntax
19:38:01 <dons> ah good .that would be much better
19:38:09 <dons> kpreid: if you want to port @pl over , that'd rock.
19:38:14 <kpreid> but now I'm wondering if Template Haskell (which I don't know anytthing about) might be better to use, or rather if I *can* use it
19:38:23 <kpreid> because I need to do things like find fresh names
19:38:34 <dons> hmm. seems hard.
19:38:43 <dons> fresh names would be easy with the Unique supply
19:38:46 <dons> ?hoogle Unique
19:38:47 <lambdabot> Data.Unique :: module
19:38:48 <lambdabot> Data.Unique.Unique :: data Unique
19:38:48 <lambdabot> Data.Unique.hashUnique :: Unique -> Int
19:39:05 <scodil> dons: yeah I've got 6.4 in /usr but I'm using 6.6 in my home directory, and I'm trying to install to that one. what other options to cabal, besides --with-compiler, affect this?
19:39:05 <sieni> does anyone have a phone at hand that could help me out?
19:39:10 <kpreid> no, I mean names that don't collide with the existing ones
19:39:20 <dmead> dons: care to take a look at my prover?
19:39:24 <dons> scodil: you need to ensure all 3 of ghc-pkg, ghc and ghci point to the right places
19:39:25 <sieni> I literally lost my phone even though I had it at hand something like one hour ago
19:39:28 <dons> dmead: bit busy
19:39:32 <dons> but feel free to post it
19:39:32 <dmead> kk
19:39:33 <EvilRanter> dmead, will http://darcs.haskell.org/lambdaweb/lambdaweb.html do?
19:39:35 <kpreid> do you know if TH lets you invoke a parser to produce TH's data structures?
19:39:37 <lambdabot> Title: Lambdabot Web Interface, http://tinyurl.com/y75z98
19:39:42 <sieni> dons: do you have a phone at hand
19:39:45 <sieni> ?
19:40:10 <EvilRanter> actually embedding a hugs prompt straight into a page would be a gaping security hole, mind
19:40:14 <dons> sieni: hmm. no. my girlfriend has my phone today.
19:40:16 <dons> why?
19:40:20 <dmead> evilranter: that seems broken
19:40:26 <dons> to ring it ? :)
19:40:31 <sieni> well, it would be much easier to locate my phone ;-)
19:41:11 <sieni> I've been searching for it for something like 20 minutes and I've used it this morning so it must be somewhere in this apartment
19:41:40 <dons> msg me your international number, and i'll see if i can buzz it from a landline on the desk nearby...
19:42:22 <EvilRanter> > do { f <- readFile "/etc/passwd"; putStr f }
19:42:23 <lambdabot>  No IO allowed
19:42:26 <dons> if only we had irc->sms plugins for the bot
19:42:38 <dons> lambdabot school's EvilRanter on the topic of IO :)
19:42:45 <EvilRanter>  /\ if IO were allowed, that'd be a hole you could drive a truck thru
19:42:57 <EvilRanter> and, if it were a direct interface to hugs, blocking IO'd be a bit tricky
19:43:11 <dmead>         * rror: 404 Not Found
19:43:11 <dmead> 1
19:43:11 <dmead>         * Error: 404 Not Found
19:43:11 <dmead> 2
19:43:11 <dmead>         * Error: 404 Not Found
19:43:12 <dmead> 32
19:43:14 <dmead>         * Error: 404 Not Found
19:43:16 <dmead> run 1
19:43:18 <dmead>         * Error: 404 Not Found
19:43:20 <dmead> run 1 + 1
19:43:22 <dmead>         * Error: 404 Not Found
19:43:24 <dmead> run
19:43:26 <dmead> =(
19:43:29 <EvilRanter> er?
19:43:50 <dmead> :<
19:43:54 <jcreigh> dmead: please don't paste in-channel.
19:43:59 <dmead> sry :<
19:47:57 <pkhuong-> @paste
19:47:58 <lambdabot> http://paste.lisp.org/new/haskell
19:48:37 <kpreid_> hm, if I use TH's structures I can't use generics
19:55:27 <lisppaste2> pkhuong pasted "fib..." at http://paste.lisp.org/display/29417
19:55:38 <pkhuong-> fricken ugly :|
19:56:07 <pkhuong-> someone please give me hints (:
19:57:04 <scodil> ok i really can't get this gsl thing to install. i've set every cabal option that looks remotely like a path to point to the ghc in my home directory, but I still get a version mismatch:  Something is amiss; requested module  GSL-0.6:GSL differs from name found in the interface file GSL:GSL
20:04:15 <dolio> Why are you computing b^n with iterate?
20:06:04 <pkhuong-> dolio: no idea.
20:08:42 <EvilRanter> pkhuong-, i think the vicious inefficiency of your program crashed dolio's computer...
20:08:45 <EvilRanter> (j/k)
20:09:31 <pkhuong-> EvilRanter: that was mean :p In the spirit of make it do more flops for the marketing dept, pkhuong presents parFib! ;)
20:10:42 <sjanssen> pkhuong-: how quickly does this run?
20:10:58 <pkhuong-> how do I test that?
20:11:13 <pkhuong-> ghc doesn't want to compile it, though linking fails :\
20:12:50 <b0ss_> WOW U GUYS PROGRAM IN HASKELL
20:13:00 <b0ss_> do you guys have a harvard deegree in advanced science
20:13:10 <b0ss_> LOL
20:13:25 <SamB_XP> I don't think
20:13:30 <SamB_XP> I even have sophomore standing
20:13:31 <SamB_XP> yet
20:13:43 <b0ss_> wow
20:13:46 <b0ss_> u must be smart
20:13:51 <b0ss_> im from the perl chatroom
20:13:57 <b0ss_> nice to mee your haskellers
20:15:11 * SamB_XP goes to bed
20:15:16 <b0ss_> dam
20:15:23 <b0ss_> u guys r smarter den us perlers
20:15:28 <b0ss_> have fun haskellers
20:15:32 <SamB_XP> there are plenty of other haskellers...
20:15:43 <b0ss_> so ass there are c ++
20:15:47 <stuuf> duh, the next version of perl is written in haskell
20:16:14 <b0ss_> no wonder why im scared..
20:16:24 <psykotic> nice tagteam troll, guys
20:17:07 <kpreid_> hm, @unpl is a lot fuzzier than @pl
20:17:20 <EvilRanter> @unpl (.)(.)(.)
20:17:21 <lambdabot> Maybe you meant: pl undo url
20:17:25 <kpreid_> e.g. should map (+1) xs become map (\x -> x + 1) xs?
20:17:40 <EvilRanter> I'd say so
20:17:48 <EvilRanter> maybe have an @unpl and a @veryunpl
20:18:03 <kpreid_> yeah, I'm considering providing a list of combinators you'd like deleted
20:18:17 <EvilRanter> that'd get user-hostile...
20:18:35 <kpreid_> well, in the bot there'd be a canned variety
20:27:04 <scodil> ls
20:27:21 <EvilRanter> ls - command not found
20:27:29 <pkhuong-> . .. _frederik_ Adamant ...
20:27:40 <EvilRanter> heh. same joke.
20:27:49 <scodil> yuk yuk. like its never happened to you
20:28:02 <EvilRanter> cannot read from / - kernel panic
20:28:51 <scodil> so anybody have any advice on this cabal version mismatch thing? GSL-0.6:GSL differs from name found in the interface file GSL:GSL
20:29:49 <shapr> palomer: I agree with dons, you're detracting from the channel. Shape up or ship out.
20:29:50 <scodil> can I just hack the hi file and change GSL-0.6 to GSL?
20:31:48 <dmead> industry hacks annoy me greatly
20:32:06 <EvilRanter> as in, hackish tricks, or hackish people?
20:32:19 <dmead> hackish people
20:32:50 <dmead> this one guy i'm talking to keeps trying to deny that recursive programming is better than iterative
20:32:54 <EvilRanter> yes, those're irritating
20:33:16 <dmead> http://www.xprogramming.com/xpmag/index.htm
20:33:18 <lambdabot> Title: XP Magazine Index
20:33:19 <dmead> he wrote an article about it
20:33:26 <dmead> 3rd entry and up
20:33:54 <shapr> hi b0ss_
20:33:56 <shapr> How's code?
20:34:10 <b0ss_> i wastn being disrepectfull
20:34:16 <b0ss_> im srry if you took it the wrong way
20:34:16 <shapr> dmead: Dude, you hang out with Ron Jeffries?
20:34:20 <b0ss_> i was just wondering
20:34:22 <b0ss_> how do you do it
20:34:23 <b0ss_> haskell
20:34:25 <b0ss_> is very
20:34:26 <b0ss_> very
20:34:27 <b0ss_> hard
20:34:28 <dmead> yea
20:34:46 <shapr> b0ss_: Ok, just seemed like it. Do you want the short intro to Haskell? I wrote a simple bite sized taste test.
20:34:50 <dmead> he ran an openspace thing 2 weeks ago
20:34:55 <b0ss_> shore
20:34:58 <dmead> and he wrote an article about my haskell code
20:34:58 <b0ss_> id liek to see more of it
20:35:17 <dmead> yet he keeps denying to me the power of recursion
20:35:23 <shapr> b0ss_: Tell me what you think - http://www.haskell.org/hawiki/HaskellDemo
20:35:25 <lambdabot> Title: HaskellDemo - The Haskell Wiki
20:35:28 <psykotic> dmead, why are you even arguing with him?
20:35:39 <psykotic> i bet he has trouble even tying his own shoes.
20:35:43 <dmead> cause he's an idiot and needs to be shut up?
20:35:46 <dmead> hehe
20:35:52 <shapr> Hm, I rather like Ron Jeffries.
20:35:55 <dmead> shapr: he's all hype
20:35:57 <EvilRanter> "This rule is not, in my opinion, obvious or communicative." -- boo hoo to you, too
20:36:00 <shapr> I've been reading his writings for years on the original wiki.
20:36:09 <shapr> I've learned a lot of good stuff from him.
20:36:13 <dmead> i'm sure he known agile well
20:36:18 <psykotic> shapr, see i always thought he was all hot air. compare to a guy like ward, who really is a good programmer.
20:36:23 <b0ss_> explain a guard
20:36:25 <shapr> Yeah, Ward rocks.
20:36:34 <dmead> i talked to my advisor today
20:36:40 <EvilRanter> Ward... Cunningham?
20:36:42 <dmead> he doesn't think jeffries knows what he's doing
20:36:47 <dmead> ah ah
20:36:55 <shapr> b0ss_: A guard is where you can put in conditional code, if the first chunk of code turns out true, the second chunk will be executed.
20:37:02 <b0ss_> o
20:37:03 <shapr> EvilRanter: Yeah, that Ward.
20:37:04 <b0ss_> i see
20:37:22 <b0ss_> wow haskell is stil harder then perl
20:37:27 <dmead> nah
20:37:28 <dino-> How can I eta reduce this: \x -> x - 1
20:37:29 <dmead> hehe
20:37:31 <shapr> b0ss_: I think it's just what you get used to.
20:37:36 <dmead> shapr: i'm sure he's a good consultant
20:37:49 <b0ss_> yeah but at least we dont program ins python
20:37:50 <dmead> shapr: but hes not really good at high level concepts
20:37:55 <dino-> I tried (- 1) but that :: (Num a) => a when I want it to :: (Num a) => a -> a
20:37:59 <shapr> b0ss_: I knew Python, Java, VB, and some other languages before I learned Haskell.
20:38:09 <b0ss_> pythong is anti perl
20:38:15 <b0ss_> -g
20:38:21 <jcreigh> b0ss_: I've found "Yet Another Haskell Tutorial" to be helpful: http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
20:38:24 <psykotic> and thank god for that
20:38:25 <shapr> dmead: I'd say that a function call is a more basic idea than a loop, and that recursion is just function calls.
20:38:25 <lambdabot> http://tinyurl.com/p6ooc
20:39:00 <dolio> dino-: subtract 1
20:39:16 <EvilRanter> > ((-1)+)
20:39:17 <lambdabot>  Add a type signature
20:39:21 <dmead> shapr: i dont agree. theres a huge difference between thinking interitavely and thinking recursivly
20:39:21 <EvilRanter> @type ((-1)+)
20:39:23 <lambdabot> forall a. (Num a) => a -> a
20:39:28 <shapr> dmead: Tell me more?
20:39:46 <dmead> if you go look on jefferies site
20:39:48 <dino-> Fabulous. You guys kick ass.
20:39:50 <psykotic> dmead, i think this is only an issue when you learned things in the "wrong order".
20:40:11 <dmead> i learned interation first, but i was young enough to change =p
20:40:16 <EvilRanter> dino-, or (+ -1), if you want a quiter version of mine
20:40:23 <Cale> iteration
20:40:28 <dmead> right right
20:40:35 <EvilRanter> I do think that unary minus is silly, tho
20:40:41 <dmead> shapr: go on jefferies website
20:40:57 <dino-> Thanks
20:41:04 <dmead> http://www.xprogramming.com/xpmag/dbcHaskellBowling.htm
20:41:04 <EvilRanter> just rename "negate" to "neg". that's short enough, and strips a special case out of the syntax. geez.
20:41:07 <lambdabot> Title: Haskell Bowling, http://tinyurl.com/yndnpr
20:41:08 <dmead> shapr: read that
20:41:37 <dmead> shapr: it took me 20 minutes and a few rules ron wrote on the chalkboard for me to solve the puzzle recursivly
20:41:43 <psykotic> dmead, so, he's full of crap, but there's no need to get worked up about it. you hear the "avoid recursion" mantra everywhere in the mainstream programming world.
20:42:09 <dmead> =/
20:42:16 <dmead> i know man
20:42:34 <dmead> it's sad kinda
20:42:37 * shapr shrugs
20:42:42 <shapr> We all have something to learn.
20:43:06 <dmead> yep, i just got worked up about him cause i'm 23 and he's 60 something
20:43:07 <shapr> Somethings I just never seem to get my head around, but other things are easy.
20:43:13 <shapr> dmead: I can understand that.
20:43:24 <psykotic> shapr, but the difference is keeping an open mind. some people (like ron in this case) have already made their mind up, it seems.
20:43:25 <shapr> I'm sure I would have gotten even more worked up...
20:43:45 <dmead> it's like your grandparents trying to tell you 1 + 1 = 3
20:43:50 <shapr> psykotic: Yup, it's hard to keep an open mind. It requires a lot of work to put aside familiar things and look at something clearly.
20:43:50 <dmead> its like what the hell...
20:44:13 <psykotic> shapr, sure, but otoh if i see a lot of people (or even a few smart people) extolling something as great i always try to take a good look before dimissing it.
20:44:38 <psykotic> even if it looks insane to me at first sight (like K) :)
20:44:45 <dmead> K?
20:44:56 <shapr> concatenative lang
20:45:04 <dmead> ah
20:45:21 <shapr> Related to Joy, APL, PostScript, etc
20:45:28 <dmead> yea i got turned on to functional langauges last year
20:45:30 <dmead> in LISP
20:45:30 <EvilRanter> APL!
20:45:31 <pkhuong-> psykotic: I there are limits to everyone's mind. I think K is past mine ;)
20:45:35 <EvilRanter> huzzZZzzah!
20:45:44 <dmead> anyone got a link to K?
20:46:28 * EvilRanter tinkered with a language that was interpreted exclusively by pattern-matching off the start and putting the result back on the start until nothing was left
20:46:30 <pkhuong-> http://www.kx.com IIRC
20:46:32 <lambdabot> Title: Kx Systems Provides High Performance Relational Database Solutions
20:46:34 <dmead> yea, first thing my teacher said when i told him jeffries is poo pooing recursion was "is he a good programmer"
20:46:44 <Pupeno> When I do pattern matching like dt@(MyDataType a b c) I get the fourth variables defined, right ? dt, a, b and c ?
20:47:12 <shapr> dmead: I agree with you that recursion is simpler/easier/more expressive than looping. But I think that generalizes to GOTO being the poor man's continuation passing style, and I think CPS is the essence of all that.
20:47:29 <dmead> CPS?
20:47:38 <jcreigh> continuation passing style
20:47:41 <dmead> oh
20:47:42 <shapr> That brings an idle question to mind, what's the essence of loops if continuation passing style is the essence of recursion?
20:47:47 <dmead> never head that before
20:47:53 <pkhuong-> shapr: shivers would say CPS.
20:47:59 <dmead> o0
20:48:01 * shapr thinks about that.
20:48:01 <psykotic> shapr: what makes programming in CPS bearable is that you have parameter passing and lexical scope, unlike a low-level goto-like primitive.
20:48:16 <EvilRanter> shapr, loops -> recursion -> function calls -> CPS
20:48:50 <psykotic> well, continuations are "obviously" the essence of all control flow.
20:49:01 <psykotic> if you try to formalize what control flow means, you end up with continuations.
20:49:15 <Pupeno> dmead: YAHT, page 53.
20:49:18 <pkhuong-> if you read the document shiver prepared for his tenure, he sees CPS as neatly unifying all the control flow operators under an operation that's even simpler than a full procedure call.
20:49:29 <shapr> Which document is that?
20:49:33 <psykotic> in fact this was how the semanticists discovered continuations.
20:49:40 <EvilRanter> can CPS be expressed via Monads, or vice-versa?
20:49:46 <dmead> interesting
20:49:47 <EvilRanter> ...or both?
20:49:53 <psykotic> EvilRanter, both, if you don't care about the type aspect.
20:50:00 <EvilRanter> hurrah
20:50:01 <dmead> brb
20:50:21 <EvilRanter> and, of course, the essence of both is axiomatic set theory, if you can be bothered going that far.
20:50:32 <shapr> dmead: btw, I wrote a TDD version of QuickCheck.
20:50:42 <psykotic> monadic style is very close to continuation passing style. if you write a simple lambda calculus evaluator in continuation passing style you only have to change a few symbols to make it a monadic style evaluator.
20:51:22 <psykotic> shapr, interesting, how is it different?
20:51:23 <pkhuong-> http://clark.lcs.mit.edu/~shivers/tenure/ , research statement
20:51:26 <lambdabot> Title: Olin Shivers tenure material
20:51:41 <pkhuong-> page 2, CPS and the lambda-calculus
20:51:43 <shapr> psykotic: It saves failing random generator seeds for later retest.
20:52:04 <dons> did we ever find a "Monads and CPS: compared" paper?
20:52:17 <pkhuong-> dons: didn't you give me 2 links 2 days ago?
20:53:02 <shapr> dmead: I don't think Ron Jeffries really gets recursion. You could point him at the monadic parsers implemented in Java and ask him to show you a loop version of those. Either his brain will explode or we'll all learn something cool :-)
20:53:31 <psykotic> shapr, or even ask him to do a binary tree traversal in a specific order.
20:54:19 <pkhuong-> psykotic: there are people who'd store the nodes in a stack and not realize that they're implementing recursion by hand.
20:54:42 <psykotic> pkhuong-, right, i know, and that's absurd.
20:55:00 <psykotic> it gets even more funny when you have multiple continuations. then you need your stack items to be tagged with the continuation.
20:55:11 <psykotic> at that point you're basically hand-CPSing your program AND writing a mini interpreter
20:55:48 <psykotic> for instance, consider doing an in-order traversal of a trinary tree. there are two continuations of recursive calls: returning from the first recursive call, and return from the second recursive call.
20:56:29 <psykotic> so in people you see people start having a stack of structs where one of the fields is an enum tag and crap like that. it's sad.
20:56:38 <dolio> I remember doing that as an extra credit assignment in my data structures class. :)
20:56:39 <psykotic> err, so sometimes
20:56:51 <shapr> dmead: To me, that article says that Ron is not comfortable thinking recursively.
20:56:56 <dolio> The teacher showed it with two stacks, but it was extra credit to do it with one, I think. :)
20:59:04 <dmead> shapr: pretty much
20:59:49 <dmead> shapr: i dont know quickcheck yet, but what does your version do?
21:00:09 <shapr> I've got a few crazy ideas that I'm trying to hammer out into something I can write into a blog entry. One of them is a way to measure "complexity of change" in a program or abstraction.
21:00:29 <dmead> shapr: yea, in the third article he even quotes someone his age as saying he really should get it at this point
21:00:39 <dmead> hmmm cool
21:01:02 <shapr> The way I write recursion you have "1. how to stop" and "2. how to go one step towards the goal"
21:01:02 <pkhuong-> shapr: complexity of change?
21:01:44 <kpreid> Is there another name for this? stabilize f x = let x' = f x in if x' == x then x else stabilize f x'
21:01:49 <shapr> I perceive that approach as being simpler than an iterative approach in all the ways I can come up with.
21:02:07 <dmead> yep
21:02:07 <Smokey`> hmm, do haskell functions still have say, a 'call stack' (or equivilent) overhead?  I'm assuming not, which means recursion in haskell is much more desirable...
21:02:25 <dibblego> Smokey`, the compiler implements tail call elimination
21:02:29 <dmead> Smokey: you ,mean does haskell support tail recursion?
21:02:51 <dmead> shapr: yea it's exactly like the proof for the counting numbers
21:02:51 <pkhuong-> shapr: I find it easier to define a size relation and try to express the solution to the problem in terms of that of `smaller' instances.
21:02:59 <EvilRanter> kpreid, (snd . until (uncurry (==)) f) also works
21:03:03 <Smokey`> I mean, is there any 'extra overhead' (in cycles, or memory usage), in calling another function?
21:03:07 <dmead> shapr: instead of a base case you have the termination case
21:03:25 <Smokey`> eg, in C, you'd have both cycle and memory overhead, because you've got to create a new call stack...
21:03:28 <dmead> Smokey: no, tail recursion means the resulting binary is the same as if it where written in interation
21:03:29 <dibblego> Smokey`, no
21:03:33 <Smokey`> v. nice :)
21:03:37 <dmead> *iteration
21:03:47 <Smokey`> that's just sexy :)
21:03:51 <dmead> yea it's from lisp/scheme
21:03:53 <dmead> =p
21:03:54 <EvilRanter> @pl  stabilize f x = let x' = f x in if x' == x then x else stabilize f x'
21:03:55 <lambdabot> stabilize = fix (ap . flip (ap . (flip =<< (if' .) . (==))) =<<)
21:04:00 <EvilRanter> hurrah!
21:04:11 <ThreeQ> in the general case there is some overhead...
21:04:14 <EvilRanter> @type ap
21:04:15 <ThreeQ> just not for tail calls
21:04:16 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
21:04:22 <kpreid> EvilRanter: I think there's a (,) missing in yours
21:04:29 <kpreid> @pl \x -> (x,x)
21:04:30 <ThreeQ> unless the compiler inlines it
21:04:30 <lambdabot> join (,)
21:04:36 <dmead> Smokey: you have to specifically wrote your functions in tail recursive style
21:04:40 <dmead> *write
21:04:46 <EvilRanter> kpreid, that's what the uncurry()'s for
21:04:51 <EvilRanter> @type uncurry
21:04:53 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
21:05:11 <kpreid> @type \f -> (snd . until (uncurry (==)) f)
21:05:12 <lambdabot> forall b. (Eq b) => ((b, b) -> (b, b)) -> (b, b) -> b
21:05:18 <kpreid> @type \f x -> let x' = f x in if x' == x then x else stabilize f x'
21:05:19 <shapr> pkhuong-: size relation?
21:05:20 <lambdabot> Not in scope: `stabilize'
21:05:32 <kpreid> @type let stabilize f x = let x' = f x in if x' == x then x else stabilize f x' in stabilize
21:05:34 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> a
21:05:52 <Smokey`> dmead: special syntax, or just providing a case for (a:[])/[a], or [] ?
21:06:13 <dmead> Smokey: nope, just a style
21:06:37 <dmead> Smokey: search for it, it's not too bad, you just return your data in the termination case
21:06:41 <pkhuong-> shapr: say < on naturals, but any (partial) order works, like in lattices, sets (# of elements) or say lexicographic ordering on tuples.
21:06:43 <dmead> and a few other things i think
21:06:47 <shapr> pkhuong-: The basic idea behind complexity of change is "how many other parts can be affected by this one thing?" My theory is that any class or instance code can talk to state in any instance in OOP, but that stacked monad transformers only affect their own stack, thus making monad transformers cost less mental effort to change. I'm not sure if that's right though.
21:07:41 <dmead> seems right maybe
21:07:42 <dmead> o0
21:07:43 <Cale> hmm, any computational geometers around who know a fast way to compute an approximate volume of the intersection of two d-dimensional hyperspheres? Currently all I have is something which is a fairly crude Monte-Carlo method for generating uniformly distributed points in one sphere, and testing whether they lie in the other.
21:08:22 <shapr> Nobody ever asks questions like that on #python or #java...
21:08:27 <dmead> Smokey: i think you also have to use an accumulator, and return that in your termination case
21:08:50 <dmead> Smokey: but i haven't look at it in haskell, just lisp
21:08:55 <dmead> but it's probably the same
21:09:14 <dmead> shapr: welcome to academia
21:09:55 <psykotic> cale: so in 3d it would be two 2-spheres intersecting in a disk?
21:10:04 <kpreid> Hm. @unpl can't undo everything @pl does without type information.
21:10:17 <kpreid> @pl \f x -> f x x
21:10:18 <lambdabot> join
21:10:19 <Cale> actually, I should say balls :)
21:10:20 <psykotic> cale: it seems like there should be a simple trig formula for the radius of the (n-1)-sphere of intersection, and once you have that you can calculate its hypervolume.
21:10:25 <psykotic> ah.
21:10:42 <kpreid> unless it would treat every monadic, arrow, etc op as being on readers and functions, respectively
21:10:43 <dmead> hehe you said balls...
21:10:43 <psykotic> yeah balls are harder
21:10:44 <EvilRanter> so, in the 2-plane it'd be like the intersect in a venn diagram?
21:10:57 <Smokey`> dmead: yeah, but the looks of it tail recursive functions require an accumulating parameter...
21:11:02 <Cale> EvilRanter: right
21:11:27 <dmead> Smokey: yep, say you want to make a function foo
21:11:28 <shapr> I'd love to continue this discussion, but I must sleep.
21:11:50 <shapr> dmead: Hey, at least you got more people to check out Haskell, that's good stuff :-)
21:11:51 <kpreid> psykotic: the radius isn't enough information, is it?
21:11:51 <dmead> Smokey: you have foo, which passes your data and an accumulator at a starting stay to foo-aux
21:12:08 <dmead> Smokey: and foo-aux does the recursion in tail form
21:12:14 <pkhuong-> Smokey`: depends on what you're doing. If you're building something, you often need an accumulating parameter. But if you're searching an element in a list, for example, you don't need any accumulator. The accumulator is a bit like a specialised continuation ;)
21:12:16 <dmead> shapr: yes =)
21:13:10 <Cale> What I'd *really* like to know is... Let v be a vector of unit length. For which radius r is V_d(B(0,1) intersect B(v,r))/V_d(B(0,1)) = 1/2, where V_d is the d-dimensional hypervolume.
21:13:15 <psykotic> kpreid, you need two radii, the "radius" of the spherical cap and the radius of the sphere itself.
21:13:30 <kpreid> both spheres, no?
21:14:04 <Cale> I have an exact solution for d = 3, d = 2 is surprisingly a bit harder, and I only have a numerical solution. (Though the equation isn't so bad to solve numerically)
21:14:16 <psykotic> once you have those two things you can (1) figure out the arc length (easy trig) and (2) generate a hypersurface of revolution, calculating its hypervolume with an iterated integral.
21:14:41 <Cale> psykotic: that seems likely
21:14:50 <psykotic> cale: that was talking about the sphere case btw
21:15:02 <Cale> ah, okay. :)
21:15:08 <kpreid> seems to me the shape of the intersection has 3 parameters: one 'radius' and two 'surface curvature'/'radius of one input sphere'
21:15:18 * kpreid stops talking outside of his field now
21:15:20 <Cale> http://mathworld.wolfram.com/Sphere-SphereIntersection.html basically carries it out for the sphere case
21:15:23 <lambdabot> Title: Sphere-Sphere Intersection -- from Wolfram MathWorld, http://tinyurl.com/y4al39
21:15:51 <Cale> http://mathworld.wolfram.com/Circle-CircleIntersection.html -- this is a bit worse, you end up with some mess involving arccosines
21:15:53 <lambdabot> Title: Circle-Circle Intersection -- from Wolfram MathWorld, http://tinyurl.com/y7rh39
21:15:54 <psykotic> kpreid, see kevin? you only need two :)
21:17:02 <kpreid> psykotic: not getting it. I still see three, as I described, for the total volume
21:17:06 <psykotic> the "radius" of the spherical cap i referred to is what the diagram calls a
21:17:15 <scodil> isn't circle-circle intersection just solving a system? solve for the two points that are both equidistant from the centers, where "distance" is dependant on the radius of the ball
21:17:20 <psykotic> kpreid, i was talking about surface area (i.e. sphere not ball intersection)
21:17:48 <psykotic> they also calculate the volume of the "lens" (which i assume is what call is talking about there)
21:17:55 <Cale> scodil: We're really looking for the area that is the intersection of two discs
21:18:03 <kpreid> ah, see, I was talking about the volume :)
21:18:15 <psykotic> two spheres have zero intersection volume, so that's easy! :)
21:18:23 <scodil> the two intersection points define a line. clip both circles against that line
21:19:06 <kpreid> but Cale said he meant balls, and his described approximation matches that as well, so.
21:19:30 <psykotic> kpreid, i know but i started the thread about spheres before his correction.
21:19:55 <kpreid> oh, I see
21:21:29 <scodil> Cale: this might be overkill, but http://portal.acm.org/citation.cfm?id=161139&dl=GUIDE&coll=GUIDE&CFID=5222607&CFTOKEN=29623358
21:21:34 <lambdabot> http://tinyurl.com/yn6dzj
21:21:49 <kpreid_> psykotic: I understand now
21:22:00 <Cale> cool
21:22:27 <palomer> yo my bitches
21:22:32 * palomer high fives Cale
21:22:46 <psykotic> cale: you could at least speed up your monte-carlo thing by generating points within a bounding box of the intersection lense.
21:23:07 <psykotic> that could be done pretty easily by finding extremas of the sphere along various axes
21:23:55 <Cale> psykotic: yeah. They're easy in my case. It still doesn't scale too well to high-dimensions though.
21:24:01 <psykotic> yup
21:24:14 <psykotic> the "corner" in the bounding box grow disportionately large very fast :)
21:24:18 <psykotic> corners, even
21:24:53 <psykotic> i wonder what symmetries can be exploited here
21:25:16 <palomer> I once did a presentation on symmetries
21:25:32 <EvilRanter> is there anything to be said for considering a (n-1)-dimensional slice thru the centres of both n-spheres?
21:25:52 <palomer> symmetries of a set has to do with which propositions are stable under which functions
21:26:25 <EvilRanter> I dunno if, if you find the volume of the intersection within that (n-1)-space, you can multiply that by something to get the volume in the n-space or something
21:26:46 <palomer> for example, the proposition x = 0 is stable under the function x |-> -x
21:27:15 <EvilRanter> palomer, we're dealing with geometric symmetry here, not set symmetry
21:27:24 <palomer> oh, but they are one and the same
21:27:34 <palomer> set symmetry is but a generalisation
21:27:52 <palomer> take a circle
21:28:01 <palomer> we say that it's symmetric about the line x = 0
21:28:05 <dibblego> the Longest Common Subsequence (LCS) problem can be solved by "dynamic programming" -- wtf is dynamic programming?
21:28:15 <scodil> dibblego: python
21:28:20 <palomer> what does that mean?
21:28:21 <psykotic> scodil, no :)
21:28:25 <scodil> i kid i kid
21:28:26 <dibblego> scodil, I don't think so
21:28:37 <psykotic> dibblego, it refers to a technique for reusing solutions to subproblems
21:29:03 <psykotic> the classic example is solving fibonacci in linear time rather than exponential time
21:29:06 <EvilRanter> memoization?
21:29:19 <palomer> python > haskell
21:29:21 <palomer> python ftw!
21:29:35 <psykotic> EvilRanter, yeah, related.
21:29:50 <scodil> dibblego: if I know the lcs of (0,n-1) and I know the lcs of (1,n) then I can find the lcs of (0,n)
21:29:51 <pkhuong-> EvilRanter: + DFS, pretty much.
21:29:55 <psykotic> EvilRanter, usually in DP you solve things "bottom-up" in an order where solutions are ready when you need them
21:30:37 <dibblego> mk thanks
21:30:38 <psykotic> so in the fib think moving up from 0 to n rather than down from n to 0.
21:30:43 <dmead> so channel
21:30:45 <dmead> whos voting tomorrow
21:30:46 <dmead> ?
21:30:59 <dmead> of the americans that is
21:31:00 <EvilRanter> don't look at me, i'm .uk
21:32:07 <psykotic> hilarious. someone threw a bunch of clothes out of their window a few floors above me a few days ago. (i'm on the 24th floor).
21:32:26 <psykotic> suddenly, just now, a rope drops down and some guy is repelling down after the clothes that got stuck in various places on the way down
21:33:02 <dmead> rofl
21:33:20 <dmead> funny
21:33:53 <psykotic> actually they dropped a full suitcase down that other day. it was fairly late at night and i was sitting at my computer (right at the window) and all this shit falls down
21:34:06 <psykotic> scared the hell out of me, thought someone committed suicide
21:36:13 <Adamant> wtf?
21:36:23 <Adamant> are your neighbors insane?
21:36:33 <dmead> or rock climbers?
21:36:47 <psykotic> yeah, i have no idea why it happened. maybe a couple were in an argument or something.
21:36:59 <Adamant> I hope they have a good rig if they are above the 24th floor
21:37:15 <psykotic> if that was the case it was really irresponsible. the sidewalk down below is very populated at most times of the time (it's seoul, 2nd densest city in the world) and someone could easily get killed.
21:37:16 <palomer> you're all nuts!
21:37:43 <dmead> where are you psyk?
21:37:45 <Adamant> who is denser? Sao Paulo?
21:38:14 <psykotic> macau according to wikipedia
21:38:33 <psykotic> oh wait, no, i was just looking at asia.
21:39:04 <psykotic> so, not 2nd densest, but still very dense :)
21:39:45 <Adamant> I bet. a lot of Koreans are packed into a pretty small country, so the cities have to be crazy dense
21:40:14 <psykotic> there's a decent amount of land ass but almost no one lives outside of the major cities
21:40:19 <psykotic> err, land mass. freudian :)
21:40:19 <Adamant> shapr, thanks for the intro to Haskell thing you posted
21:41:15 <Adamant> Korea is interesting
21:43:46 <palomer> I went to korea two months ago
21:43:59 <palomer> korea isn't that small
21:44:03 <palomer> it has way more arable land than japan
21:44:09 <palomer> and half the population
21:44:45 <Adamant> palomer, it doesn't look that big on a globe.
21:45:00 <Adamant> at least, S. Korea proper
21:45:39 <palomer> it only has a single freakishly big city
21:45:54 <palomer> all the others are bite sized
21:45:58 <Adamant> ah.
21:46:10 <palomer> chop off 80% of japan
21:46:11 <psykotic> i guess that depends on your definition of bite sized :)
21:46:20 <palomer> that's how much of japan is arable
21:46:23 <palomer> compare that with korea
21:46:24 <psykotic> busan has 3.7 million
21:46:38 <lispy> bite size would have to be from godzilla's POV
21:46:44 <Adamant> is it busan or pusan?
21:46:46 <lispy> i mean, if we're involving japan :)
21:46:58 <palomer> busan in the new romanization
21:47:02 <palomer> pusan in the old
21:47:02 <psykotic> Adamant, i think the new canonical latinized spelling is busan but both owrk
21:47:07 <Adamant> ah.
21:47:09 <palomer> it's pronounced pusan though
21:47:19 <palomer> (though pronouncing it busan is _not_ incorrect)
21:48:01 <EvilRanter> Graphics.Rendering.OpenGL under Hugs?
21:48:23 <psykotic> and then you have a bunch of smaller cities with a few million each
21:48:59 <psykotic> daegu has 2.5 million, ulsan has a mil, daejeon has 1.5 mil, etc
21:49:35 <EvilRanter> ... is such a thing possible?
21:50:28 <palomer> though are pretty bite sized
21:50:30 <palomer> wouldn't you guys say?
21:58:22 <kjdwf> cale
22:31:18 <pkhuong-> gah. Monads keep appearing out of nowhere.
22:32:34 <pkhuong-> I'm working on a runtime code generation thing. I have code that looks like (build arg1 (\ res1 -> (build arg2 (\ res2 -> ...))))  (already noted by the metaocaml team, but still...)
22:37:00 <monochrom> monads are pervasive
22:38:37 <psykotic> like midi-chlorians
22:41:13 <dmead> lol
22:41:35 <dmead> newrtype midichlorian = monad
22:41:38 <dmead> =pp
22:54:33 <lispy> what is this "proof-directed debugging" all about?
22:56:14 <enolan> Anyone here using ghc 6.6 on an intel mac? I've a problem with HOpenGL, from the binary package and I was wondering if it was fixed by recompiling from source.
22:59:39 <lispy> pkhuong-: simple but useful abstractions are like that
23:00:40 <pkhuong-> lispy: I'll use my `sweet monad' package (it's actually in CL) once I have a better grasp on the problem (:
23:22:05 <dolio> "But Python is a general scripting language, whereas PHP is web-optimized"
23:22:16 <dolio> You think we can get haskell "web-optimized"? :)
23:22:26 <monochrom> Yes.
23:22:28 <pkhuong-> News at 11: php is optimised.
23:22:33 <EvilRanter> we can get haskell "web 2.0 optimised"
23:22:48 <EvilRanter> use continuations to implement session state. er, or something
23:23:45 <pkhuong-> EvilRanter: actually, with AJAX, continuations aren't as needed as with normal interaction, it seems.
23:24:23 <monochrom> There are other approaches than continuations.  All approaches are elegant in Haskell.
23:24:55 <monochrom> Haskell is everything-optimized.
23:25:57 <EvilRanter> it's not Ron Jeffries optimised :P
23:28:50 <psykotic> ron-optimization is retardation
23:29:29 <monochrom> Any Turing-complete computer can emulate a retard. :)
23:29:48 <monochrom> @yow
23:29:50 <lambdabot> Now I'm concentrating on a specific tank battle toward the end of World
23:29:50 <lambdabot> War II!
23:29:56 <monochrom> Like that :)
23:32:37 <dolio> @protontorpedo
23:32:39 <lambdabot> I got some info b 4 about how lazy eval makes macros not needed please expand...
23:33:10 <pkhuong-> oh, those are real people O.o
23:33:24 <EvilRanter> nonono, the point is that lazy eval means you _don't_ expand 'til you _really_ have to!
23:41:51 <Cale> @keal
23:41:52 <lambdabot> they dumbified you
23:41:54 <Cale> @keal
23:41:55 <lambdabot> proofs are no longer sound
23:42:49 <psykotic> haha, is keal a former resident?
23:43:31 <gour> dons: ping
23:43:42 <EvilRanter> @protontorpedo
23:43:43 <lambdabot> what does haskell do better than java perl or ruby?
23:43:51 <merus> nothing!
23:43:51 <psykotic> @polomer
23:43:53 <lambdabot> Hrmph
23:43:55 * merus laughs
23:44:02 <merus> kidding...  kidding
23:44:05 <psykotic> @palomer
23:44:07 <lambdabot> I think you're all nuts
23:44:31 <Cale> psykotic: yeah
23:44:33 <Cale> @keal
23:44:34 <lambdabot> evaluating expressions is ALL haskell does?????
23:44:37 <Cale> @keal
23:44:39 <merus> lol!
23:44:39 <lambdabot> #haskell needs to take its meds
23:44:42 <Cale> @keal
23:44:42 <lambdabot> and yes that was with zero formal training in all realms
23:44:46 <Cale> @keal
23:44:47 <lambdabot> just seeing how offtopic i could get everyone
23:44:58 <profmakx>  evaluating expressions is ALL haskell does????? <- that one is gold
23:46:37 <psykotic> executing instructions is ALL a computer does?
23:46:45 <Adamant> how do you define data types in ghci?
23:47:18 <Adamant> getting sick of writing stuff in a text file and importing it
23:47:32 <Cale> Adamant: you don't
23:47:42 <Cale> Keep your text editor open
23:47:51 <Adamant> ugh.
23:47:55 <Cale> When you save the file, type :r in ghci to reload it
23:49:03 <dolio> Perhaps it's time to acquaint yourself with haskell mode. :)
23:49:12 <dolio> I should switch back to emacs.
23:49:16 <Adamant> it very well may be.
23:50:03 <dolio> I've been getting very confused lately, with my zsh key bindings on vim mode, and ghci using emacs bindings.
23:50:56 <monochrom> Firing neurons is all a human does?
23:51:18 <dolio> Heh, you'll get lots of argument about that.
23:51:39 <monochrom> Like what?
23:52:31 <dolio> "... Hard Problem of Consciousness ..." etc.
23:54:58 <monochrom> I almost forgot.  Yes.  Lots of circular arguments I'll get.
23:55:27 <dolio> :) I'm not saying you'll get them from me, but you can find them if you look.
23:56:17 <dolio> There isn't a way to make ghci use vim-style keys, is there?
23:56:57 <monochrom> ghci uses the readline library.  there is probably a way to tell the readline library your favourite keys
23:57:03 <Smokey``> monochrom: heh, I'd agree with you - untill you brought up ocnciousness :P
23:57:18 <dolio> Ah, okay.
23:57:20 <EvilRanter> dolio, i think it'd be easier to layer some of GCI's functionality into vim...
23:57:24 <Smokey``> conciousness*    But that's only because I can't even fathom one's conciousness.
23:57:26 <monochrom> Consciousness is not a hard problem.
23:57:34 <EvilRanter> it's a squishy one!
23:57:46 <dolio> Perhaps, but I'm not much of a vim guru.
23:58:31 <monochrom> I mean this.  The real problem is how humans are so arrogant as to refuse to compare themselves with machines.
23:59:23 <zptao> you read too many scifi books
