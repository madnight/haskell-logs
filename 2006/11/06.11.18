00:00:22 <sjanssen> the program does seem to be doing all of it's work
00:02:58 <dons> the yield seems to matter... :)
00:03:34 <sjanssen> yeah.  I added explicit synchronization and got the same run time
00:14:16 <dons> mm. we should have strict-by-default MVars
00:14:29 <dons> or maybe putMVar'
00:14:36 <dons> seems to come up a lot
00:21:27 <lispy> C has currying
00:21:36 <lispy> but only for arrays
00:21:50 <lispy> (well, pointers too)
00:22:13 <lispy> char myarray[ROW][COL]; myarray[i] <-- that's a curried function!
00:22:23 <lispy> or maybe the term is uncurried
00:22:27 <lispy> i always mix them up
00:22:33 <dons> mmm
00:22:47 <lispy> i know....not really...
00:22:52 <dons> so partialy applied array indexing
00:22:54 <lispy> but it's kinda, sorta like it
00:22:57 <dons> :)
00:22:58 <lispy> yeah
00:23:18 <robreim> I'm totally switching to C then
00:23:38 <psykotic> haskell ripped off c, clearly
00:23:52 <psykotic> why use an immitation when you can have the real deal!
00:24:04 <lispy> totally!
00:24:10 <dons> very wise
00:25:55 <dons> sjanssen: http://haskell.org/haskellwiki/Shootout/Chameneos#Proposed_version
00:26:00 <lambdabot> Title: Shootout/Chameneos - HaskellWiki, http://tinyurl.com/y7rw7u
00:38:16 <vegai> dons: What motivated your changes in the complement function?
00:39:33 <dons> have it compress better
00:41:29 <vegai> Ah.
00:43:40 <emu> lisppaste2: url
00:43:40 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
00:43:45 <Maddas> lispy: yeah, and function pointers are just curried functions (partially applied to 0 arguments)! ;-)
00:44:24 <lisppaste2> emu pasted "trouble with type variables" at http://paste.lisp.org/display/30145
00:44:40 <pkhuong-> Maddas: until you add a runtime generated trampoline.
00:45:04 <pkhuong-> (i'm looking at gcc right now ;)
00:45:09 <lisppaste2> emu annotated #30145 with "the error" at http://paste.lisp.org/display/30145#1
00:45:32 <emu> i might be tired, but i'm not understanding the error in the above code
00:45:46 <emu> the odd thing, i got it to work when I used the same type for StateT and ErrorT
00:47:06 <Maddas> pkhuong-: I didn't mean to be technically correct in any way. :-)
01:04:01 <emu> well, i can get it to work with glasgow-exts
01:04:05 <emu> but still.. sigh
01:05:58 <lisppaste2> emu annotated #30145 with "with glasgow-exts" at http://paste.lisp.org/display/30145#2
01:30:16 <lispy> did we enjoy a netsplit?
01:30:40 <lispy> i actually can't tell (my client hides them from me) but i just got a message about this channel
01:30:49 <lispy> -ChanServ- [#haskell] logs @ http://tunes.org/~nef/logs/haskell/ -
01:30:49 <lispy>       we put the funk in funktion
01:30:50 <lambdabot> Title: Index of /~nef/logs/haskell
01:31:19 <arcatan> indeed we did
01:31:22 <lispy> but i don't recall getting that everyday
01:31:36 <lispy> arcatan: okay, thanks
01:38:34 <dons> ?users
01:38:34 <lambdabot> Maximum users seen in #haskell: 270, currently: 238 (88.1%), active: 14 (5.9%)
01:39:11 <dons> warning to haskell developers: don't get lazy about 'darcs dist'. something kosmikus reminded me of a while back, http://programming.reddit.com/goto?id=rgdu
01:39:14 <lambdabot> Title: Step Away from the REPL: "we don't do releases"
01:43:27 <dons> hmm, could google code hosting be useful the community? http://code.google.com/hosting/
01:43:28 <lambdabot> Title: Google Code - Project Hosting
01:43:56 <lispy> dons: ore even have darcs create the dist automaticall
01:44:25 <dons> yes.
01:44:36 <dons> hmm. there's haskell projects on google's hosting already ... that i haven't heard about!
01:44:40 <dons> http://code.google.com/hosting/search?q=haskell&btn=Search+Projects
01:44:43 <lambdabot> Title: Google Code, http://tinyurl.com/y294bd
01:48:26 <lispy> i just added a comment about using post-hooks to automate this
01:48:39 <dons> hmm, more haskell code http://code.google.com/p/pandoc/
01:48:41 <lambdabot> Title: pandoc - Google Code
01:48:41 <lispy> more people should use post-hooks!
01:48:56 <dons> we need a tutorial!
01:48:57 <lispy> they solve (easily) many of the problems people have
01:49:08 <lispy> put the following in _darcs/prefs/defaults:
01:49:08 <lispy> apply posthook darcs dist
01:49:08 <lispy> apply run-posthook
01:49:14 <lispy> not sure if that's tutorial worth!
01:49:32 <dons> we should have a darcs tips wiki page on haskell.org
01:49:47 <lispy> but the darcs wiki already has one :)
01:50:54 <dons> what's this? http://code.google.com/p/hal-light/
01:50:56 <lambdabot> Title: hal-light - Google Code
01:51:05 <dons> and this? http://code.google.com/p/inv/
01:51:06 <lambdabot> Title: inv - Google Code
01:52:06 <lispy> dons: where was your "start a haskell project" page on the wiki again?
01:52:17 <lispy> i can put the darcs dist trick with a link to that blog entry there
01:52:19 <dons> http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
01:52:21 <dons> yep
01:52:22 <lambdabot> Title: How to write a Haskell program - HaskellWiki, http://tinyurl.com/yy6xkk
01:52:52 <dons> we need to sort this hosting issue for cabal projects this year
01:54:36 <lispy> oh someone already linked that to that page
01:54:39 <lispy> was it you? ;)
01:54:43 <dons> yes :)
01:57:27 <lispy> i'm guilty of not announcing my projets
01:57:45 <lispy> but, i guess that's because i always feel like i want to do a lot more before people really hear about it :)
02:02:30 <lispy> oh they give you a bug tracker
02:02:42 <lispy> ugh
02:02:44 <lispy> svn?
02:03:21 <dons> see anything on other support?
02:03:41 <lispy> i'm looking but no
02:04:10 <Syzygy-> Grmbl. I don't seem to have the Control.Monad.Whatever-packages in my ghc installation...
02:04:22 <lispy> Syzygy-: -package mtl
02:04:25 <Syzygy-> Anyone know what I need to do to et hold of them? gentoo:ghc 6.6 with overlay.
02:04:26 <Syzygy-> Ah.
02:04:27 <lispy> maybe?
02:04:36 <Syzygy-> ghc-6.6: unknown package: mtl
02:04:39 <dons> hmm http://www.ibiblio.org/fosphost/exhost.htm
02:04:40 <lambdabot> Title: Comparison of Free/Open Source Project Hosting (FOSPHost) Sites Available for Ho ...
02:05:03 <dons> Syzygy-: extra packages. got to grab it separately (from the extra-libs bundle)
02:05:32 <lispy> dons: oy! not a single one uses darcs
02:06:06 <dons> i heard berlios did. maybe that was a rcs dream though
02:06:20 <lispy> dons: all we really need is darcs+trac and a team of monkeys to script and keep it running
02:06:24 <dons> yeah
02:06:27 <dons> and disk space
02:06:51 <lispy> dons: okay maybe some do then, my check was a bit lazy
02:06:57 <lispy> dons: i just searched the page for darcs ;)
02:07:17 <dons> berlios only seems to mention CVS/SVN
02:08:40 <Syzygy-> dons: How do I do that? Is it gentoo-packaged? Or do I go some other path?
02:09:16 <dons> well, its certainly available from ghc's page. but i suspect it is in gentoo too..
02:12:15 <lispy> dons: do we really need to host people's projects, or just host compiled binaries?
02:12:29 <dons> packages is fine.
02:12:34 <dons> (I think)
02:12:44 <dons> as long as you can upload the result of darcs dist
02:12:47 <lispy> yeah, it seems like the way debian does it would work
02:13:47 <lispy> i'm imagining, you upload it, the machine tries to build it/install it/test it and if that passes it then moves it to a package location
02:22:47 <lispy> dons: oh, lookie: http://www.abridgegame.org/pipermail/darcs-users/2005-July/007982.html
02:22:50 <lambdabot> Title: [darcs-users] Re: darcs and source forge equivalent, http://tinyurl.com/y2cz6y
02:23:30 <lispy> i think we have an answer, 1) get everyone who sets up a project at sf.net to request darcs, 2) just do what is described there until sf.net adds darcs
02:23:45 <Syzygy-> dons: Ok. Found it.
02:24:05 <dons> lispy, hmm. yes. that might work
02:25:52 <lispy> dons: the same approach would probably work here as well http://savannah.gnu.org/
02:25:54 <lambdabot> Title: Welcome [Savannah]
02:36:18 <lispy> dons: is there a thread or where we con mention that idea?
02:36:27 <lispy> (the one about requesting and using the webspace)
02:45:52 <dons> lispy: hmm. we could come up with something on haskell-cafe@, and then try to make it happen?
02:50:49 <emu> oo boy, my very first own monad transformer
02:51:08 <dons> yay!
02:54:39 <lisppaste2> emu pasted "TimedStateT" at http://paste.lisp.org/display/30149
02:55:23 <lispy> dons: maybe, i thought we already had a thread on it from the way you were talking :)
03:02:05 <dons> lispy: oh, its sort of been on and off over the last year or so between cabal-involved pepopel
03:12:47 <christine> dons: how are you today master?
03:18:00 <therp> is there any documentation the symbols GHC produces in an O file? In a module Foo having object bar, I see Foo_bar_(closure|info|srt) and I wonder what these objects are
03:18:45 <therp> also there seems to be a module init symbol __stginit_Foo, and some other infos scs_info, siz_info, six_info..
03:19:53 <dons> so you've got the closure, the info table, the static reference table. one source would be the STG paper, http://haskell.org/haskellwiki/Research_papers/Runtime_systems
03:19:56 <lambdabot> Title: Research papers/Runtime systems - HaskellWiki, http://tinyurl.com/jyutg
03:20:02 <dons> some of the newer things might be documented in the GHC Commentary
03:20:21 <dons> and the src of ghc itself
03:21:10 <dons> also
03:21:13 <dons> http://hackage.haskell.org/trac/ghc/wiki/Commentary
03:21:16 <lambdabot> Title: Commentary - GHC - Trac, http://tinyurl.com/ocuyo
03:21:54 <therp> dons: thanks will have a look at the paper. Actually I'm never really lucky with the trac search. It mostly finds junk
03:27:01 <therp> dons: would it be ok to replace the link of the first paper by a direct link? this crappy asp thing does not work out of the box and requires some strange counterintuitive popup unblocking for microsoft.com
03:27:20 <therp> s/out of the box/out of the box on firefox/
03:27:25 <dons> please do it, if you have a direct link
03:27:38 <therp> it's easily guessable for the link below
03:28:00 <therp> oh haskellwiki requires a login..
03:29:30 <dons> yep, but its trivial to get an account
03:29:34 <dons> please do!
03:30:30 <therp> dons: done already
03:33:38 <christine> still can't uninstall WinHugs... any ideas?
04:05:26 <astrolabe> christine: just delete the directory?
04:06:15 <christine> tried that...
04:06:25 <christine> won't work...
04:07:16 <Philippa_> what user rights do you have on that machine? You might just not have the right to delete or uninstall programsx
04:07:17 <Philippa_> -x
04:08:45 <christine> i have all the rights.
04:10:05 <psykotic> so, in what sense does deleting it not work?
04:10:21 <christine> i tried the uninstall program but it sais it does not work on either windows nor ms-dos...
04:38:14 <lisppaste2> pitecus pasted "Typeclass problem" at http://paste.lisp.org/display/30152
04:38:35 <pitecus> How can I fix this?
04:41:21 <dons> looking...
04:41:46 <dons> so that looks like an arrow, f b c -> f a b -> f a c
04:42:19 <dons> ?hoogle <<<
04:42:20 <lambdabot> Control.Arrow.(<<<) :: Arrow a => a c d -> a b c -> a b d
04:42:33 <dons> no?
04:42:45 <pitecus> looks like...
04:42:58 <pitecus> I didn't know about arrow
04:43:21 <dons> ?docs Control.Arrow
04:43:21 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html
04:43:29 <dons> ?source Control.Arrow
04:43:30 <lambdabot> http://darcs.haskell.org/packages/base/Control/Arrow.hs
04:43:39 <pitecus> thanks dons
04:43:51 <xerox> ?pl (<<<)
04:43:52 <lambdabot> (<<<)
04:43:54 <dons> so there's
04:43:55 <dons> instance Arrow (->) where
04:43:56 <dons>     arr f = f
04:43:56 <dons>     f >>> g = g . f
04:44:09 <dons> which covers your instance Composable (->) where
04:44:46 <dons> now , I think you should be able to get an Arrow Map instance, probably even already written out there
04:44:53 <dons> ?google instance Arrow (Map k)
04:44:56 <arjanb> Arrow isn't a solution to that 'Functor instance for Set' like problem
04:44:58 <lambdabot> http://types2004.lri.fr/SLIDES/uustalu.pdf
04:45:16 <dons> ah right.
04:45:17 <erider> good morning all
04:45:39 <christine> good morning...
04:45:40 <dons> that's involved. hmm. Cale might have some ideas, he was working on the Ord problem using the new GADT/typechecking/typeclass stuff
04:46:08 <dons> pitecus: have a look at the Functor and Monad instances for Map
04:46:16 <dons> you might be able to steal some ideas from that
04:46:20 <dons> ?source Data.Map
04:46:21 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
04:46:46 <pitecus> Is it possible to just add Ord contraints to an instance?
04:48:13 <dons> you might be able to get away with something, possibly you can make the Compose class less general?
04:48:31 <dons> you need to compose maps of different key and elem types?
04:48:48 <pitecus> it works if I add Ord constraints to the class
04:48:59 <dons> ah ok :)
04:49:01 <pitecus> but then it restricts also the instance for functions
04:56:12 <arjanb> right otherwise you have to resort to type trickery
04:57:19 <pitecus> I added two more type arguments to the composable class, and constrained them only in the Map instance, and that seems to work...
04:57:59 <arjanb> in general running into type class problems means you adding too much abstraction upfront
04:58:38 <pitecus> Could be
05:00:07 <dons> arjanb: good advice.
05:17:28 <therp> hm, dons: I have the impression that you are familiar with the haskell.org infrastructure, who would be responsible for darcs.haskell.org?
05:26:58 <dons> simonM is mostly responsible, at least for handing out accounts
05:28:52 <therp> dons: ah no, I just wanted to point out a possible inconsistancy in the apache conf
05:51:41 <dons> must .. not .. reply ... to fromJust thread
05:54:14 <tibbe> dons: what's going on there now? I've kinda given up on it
05:54:21 <tibbe> i.e. given me dependent types ;)
05:54:30 <astrolabe> @seen dcoutts
05:54:30 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts speak 10h 22m 35s ago.
05:54:35 <dcoutts> @arr!
05:54:35 <lambdabot> Har de har har!
05:54:50 <astrolabe> dcoutts: wow. that was quick
05:55:02 * dcoutts is now awake
05:55:11 <astrolabe> can I ask you a gtk2hs question please?
05:55:52 <dcoutts> aye
05:55:54 <astrolabe> drawWindowCal <- drawingAreaGetDrawWindow drawingAreaCal
05:56:09 <astrolabe> this line of code causes my program to say
05:56:30 <dcoutts> the drawing area needs to be realised
05:56:44 <astrolabe> Ah.  what does that mean?
05:56:45 <dcoutts> ie the widget has to be just about to be shown already
05:56:47 <dons> tibbe: oh, just analysing the 106 uses of fromJust in darcs
05:56:59 <tibbe> dons: :)
05:57:03 <dons> and the 7 open bugs related to "Data.Maybe.fromJust: Nothing"
05:57:11 <tibbe> heh
05:57:15 <dcoutts> astrolabe, so you could it for the first time in the onRealise event, or you can always do it in the onExpose for example
05:57:38 <dcoutts> hmm, is that noted in the docs I wonder.
05:57:56 <dcoutts> astrolabe, I should make the gtk2hs link to a wiki then I could get you to note that down :-)
05:58:23 <dons> tibbe: i'm thinking that maybe this thread can just be pointed to for ever after if someone uses fromJust. that should be just as good as DEPRECATED fromJust ;)
05:58:45 <tibbe> :D
05:58:54 <astrolabe> dcoutts: good idea, I probably don't understand it well enough yet, but I'll look at onRealise (I don't have one yet).
05:59:04 <astrolabe> karma+ dcoutts
05:59:05 <astrolabe> thanks
05:59:07 <tibbe> I think it can be used as a general support thread for anything since all possible combinations of words has probably been written there ;)
05:59:11 <profmakx> btw. Nice work @ language shootout
05:59:16 <astrolabe> @karma+ dcoutts
05:59:16 <lambdabot> dcoutts's karma raised to 36.
05:59:24 <dcoutts> astrolabe, you probably don't need one, just get the drawWindow when you actually need to do some drawing, eg in onExpose
05:59:40 <dons> profmakx: oh, you mean the new chameneos?
05:59:41 <tibbe> I really need some food, bbl
05:59:45 <astrolabe> ok will do.
05:59:51 <profmakx> yes, dons
05:59:57 <profmakx> just saw it on reddit
06:02:22 * gds plays with vim7 on ubuntu....
06:02:33 <Saizan> hi
06:02:42 <profmakx> hello Saizan
06:03:02 <gds> Is it just me, or does the ubuntu vim7 haskell file deal only with indentation, while the vim6 one deals only with colour?
06:03:24 <Saizan> mmh I've a question on a snippet of code inside of the tutorial All About Monads..
06:04:21 <Syzygy-> gds: The two main reasons for my comment yesterday is (1) gds and totherme evoke completely different reactions as nicks, and (2) that cat evokes something completely different again from 'gds'...
06:04:36 <gds> lol :)
06:04:47 <Saizan> http://www.nomaware.com/monads/html/errormonad.html <-- here, when he istances (Either e) as a MonadError, it just doesn't compile..
06:04:49 <lambdabot> Title: The Error monad, http://tinyurl.com/hgna5
06:05:35 <gds> Syzygy-:  That cattey thing was a gift from my S.O. - kind of an in-joke I guess :)
06:06:07 <gds> and unfortunately, there was already a "gds" on LJ, so I fell back to one of my older aliases :)
06:06:20 <dons> > fail "fooey" :: Either String ()
06:06:21 <lambdabot>  Left "fooey"
06:06:43 <dons> > return "kablooey" :: Either String String
06:06:44 <lambdabot>  Right "kablooey"
06:06:49 <dcoutts> astrolabe, what gui are you working on btw?
06:07:04 * dcoutts is always looking for more screenshots
06:07:39 <Saizan> dons, yes, but how do I write the istance correctly?
06:08:51 <Saizan> I mean, ghc complains that (Either e) hasn't enough type parameters, but if I add something like (Either e a) it gives me a kind error
06:10:01 <astrolabe> dcoutts: my longer term goal is to write an interface for a go program, and maybe a calculator thingy I've been thinking about.
06:10:10 <dcoutts> astrolabe, nice
06:10:43 <astrolabe> dcoutts: At the moment to help me learn, I'm just writing something to help me plan what I'm going to book my time to.
06:10:52 <astrolabe> which is very boring :)
06:11:43 <dcoutts> heh :-)
06:14:16 <astrolabe> I think the wiki link is a very good idea by the way.  You might get a lot of your work done for you.
06:14:26 <dcoutts> yeah
06:14:33 <dcoutts> I'll do it for the next release
06:14:40 <dcoutts> and ask for contributions
06:15:39 <astrolabe> I guess I need to 'register an interest' in expose events
06:39:15 <astrolabe> oh wow. thanks dcoutts, that just seems to work :O
06:39:20 <dcoutts> great
07:06:22 <dons> ?yow
07:06:23 <lambdabot> Uh-oh!!  I forgot to submit to COMPULSORY URINALYSIS!
07:06:46 <fabiim> anyone uses emacs with haskell mode?
07:07:02 <psi> a lot of people do
07:07:17 <fabiim> lol
07:07:32 <chessguy> notepad in haskell mode is better :)
07:08:14 <xerox> fabiim: yep
07:08:19 <fabiim> I don't know much about emacs , but my question is simple , how do I get to highlight functions names ?
07:08:54 <xerox> (global-font-lock-mode 1)
07:10:27 <fabiim> i have only global-font-lock-mode ...
07:10:32 <fabiim> can't get to write 1
07:11:46 <pejo> fabiim, M-x global-font-lock-mode should be enough if you're in emacs.
07:12:40 <fabiim> oh , i didn't meant to highlight the functions i create . those which are in the beginning  of the lines are highlighted
07:12:56 <fabiim> i want to highlight functions used in the right side of equations
07:13:54 <pejo> font-lock-maximum-decoration might help you there. Unsure. I'm quite happy with the default I must say.
07:14:44 <fnord123> wa wa wee wa, haskell is beating erlang on some concurrency tests on the alioth benchmarks.
07:15:55 <_matthew-> don't trust those
07:16:07 <_matthew-> at least one of those is wrongly implemented in erlang
07:16:52 <dons> clearly at least one is correctly implemented in haskell though ;)
07:17:15 <fabiim> i don't have that too ... well it wasn't too important anyway , but how can i read haskell mode documentation  , the link in this page is broken http://haskell.org/haskell-mode/
07:17:16 <lambdabot> Title: Haskell Mode for Emacs
07:18:59 <fnord123> concurrency in haskell. i like. high five
07:20:23 <fnord123> is this a new haskell lightweight threads lib used there or is it plain old Control.Concurrent?
07:21:04 <fnord123> er, nm, i found the code link. :-/
07:39:13 <crazycman> hi, I have a problem, maby someone can help me
07:39:47 <crazycman> I am doing this:
07:40:10 <guerra> if its too big paste
07:40:12 <guerra> @paste
07:40:12 <lambdabot> http://paste.lisp.org/new/haskell
07:40:53 <crazycman> defining a typeclass tree like this
07:41:26 <lisppaste2> crazycman pasted "my problem" at http://paste.lisp.org/display/30161
07:41:52 <crazycman> then i get this type error
07:42:23 <lisppaste2> crazycman annotated #30161 with "the type error i get:" at http://paste.lisp.org/display/30161#1
07:47:20 <dolio> Well, root has type "Tree t => t -> a" which means it's required to return a value of any arbitrary type of the caller's choosing.
07:48:11 <dolio> But in your instance for BTree, it can only return the type stored by the tree.
07:49:25 <dolio> In fact, the only definition you could have there that would type correctly would be: "root (BLeaf a) = undefined", I think.
07:50:32 <crazycman> But i tryed it like this: class Tree t where root :: t a -> a, (like in the functor class) and i still get an error
07:51:26 <dolio> Well, in that case, you should probably have something like: "instance Tree BTree where ..."
07:52:18 <crazycman> i give it a try, thank you
07:52:33 <dolio> No problem.
08:28:25 * SamB wonders what graphing software goes nice with LaTeX...
08:37:47 <CosmicRay> arjanoosting: thanks for your fix
08:38:57 <arjanoosting> no problem
08:39:25 <CosmicRay> feel free to switch the Maintainer line to yourself at any point ;-)
08:39:39 <CosmicRay> if you will be setting up a darcs repo for it, I will remove mine and set it to HTTP redirect to yours
08:40:20 <CosmicRay> dons: ping
08:56:14 <fons> hi all
08:56:35 <fons> I din't anderstand why the FFI doesn't allow type signatures
08:57:34 <fons> class a where; function :: a -> IO()
08:58:11 <fons> class Class a where: function :: a -> IO()
08:58:38 <fons> exportable :: Class a => a -> IO()
08:59:23 <fons> exportable :: Class a => StablePort a -> IO()
09:03:03 <Lemmih> fons: What has that to do with the FFI?
09:03:22 <fons> Lemmih, I cannot export exportable
09:03:42 <fons> I rewrite it
09:03:51 <fons> class Class a where: function :: a -> IO()
09:04:03 <fons> exportable :: Class a => StablePtr a -> IO()
09:04:26 <fons> exportable ptr = do {deref <-  deRefStablePtr; function deref}
09:05:14 <fons> the type signature doesn't allow me to export "exportable"
09:05:18 <Lemmih> How would that work form C?
09:05:53 <fons> a stable pointer would be passed previously
09:06:09 <fons> Class a => StablePtr a
09:06:21 <fons> and the exportable would be called
09:06:34 <fons> I don't see why it could be implemented
09:06:38 <Lemmih> fons: And how would you figure out the type of the stableptr?
09:07:41 <fons> exportPtr :: Class a => StablePtr a
09:08:16 <fons> Lemmih, the C code doesn't have to now about the type
09:08:33 <Lemmih> fons: 'StablePtr Int' is different from 'StablePtr ()', right? What (haskell) type is a pointer in C?
09:08:33 <fons> it is just an opaque pointer
09:09:49 <Lemmih> fons: It sure does. Your function needs that type to figure out which 'function' to call.
09:10:37 <Lemmih> fons: Which 'function' should 'exportable((void*)NULL);' call?
09:11:49 <fons> Lemmih, is that allowed?
09:12:08 <Lemmih> fons: NULL pointers in C? Why, yes.
09:12:16 <fons> Lemmih, Isn't the low level representation of a StablePTr suppoested to be opaque?
09:12:21 <fons> supposed
09:13:27 <fons> and furthermore, aren't StablePtrs supposed to be created within haskell code?
09:13:45 <Lemmih> fons: Sure, but they don't have to be.
09:14:12 <Lemmih> fons: And there's no way to preserve type information into C-land.
09:14:16 <fons> Lemmih, then the behaviour is undefined I guess
09:14:56 <Lemmih> fons: Any argument would be as bad as NULL.
09:15:08 <fons> Lemmih, I don't really see why
09:15:25 <Lemmih> fons: What's the type of an arbitrary C pointer?
09:15:38 <Lemmih> fons: You see that the type is needed, right?
09:17:03 <Lemmih> fons: How about making the dictionary passing explicit: exportable :: (a -> IO ()) -> StablePtr a -> IO ()?
09:17:39 <fons> Lemmih, that's not accepted by the FFI either
09:18:45 <Lemmih> Well, of course not. You need a FunPtr.
09:19:57 <Lemmih> fons: What are you trying to do, btw?
09:20:43 <fons> I'm programming a plugin sdk
09:20:50 * duality cries
09:21:18 <duality> "record update for non-Haskell-98 data type is not yet supported"
09:21:40 <fons> the plugin has to provide certain functions
09:22:52 <fons> those functions have a handle whose type will be defined by the plugin programmer (not known to the C marshaler)
09:23:03 <fons> which type
09:27:17 <Lemmih> fons: a -> IO ()?
09:27:59 <fons> Lemmih, I solved ith using existentials
09:28:08 <fons> although I hate them
09:29:33 <Lemmih> And what's the problem now?
09:33:50 <Renkin> If I have a function  fun x = \(y, z) -> res  where res = ...   where y and z is used to define res, it doesn't compile because y and z are unknown, how can I solve that?
09:34:35 <Renkin> Without making (y, z) a proper argument
09:35:53 <crazycman> \y, z -> ... without paranthesis
09:36:02 <duality> Why not make (y,z) a proper argument?
09:36:28 <duality> If you insist, fun x = \(y,z) -> let res = ..y..z.. in res
09:36:37 <Renkin> crazycman: but I have a type State = (x, y, ...)  that I'm using.
09:37:03 <Renkin> duality: Because in my real problem I have it within a constructor
09:37:16 <Renkin> fun x = Const (\(y, z) -> res)
09:37:24 <Renkin> Maybe that's ugly
09:37:42 <Renkin> I wanna hide the implementation of a datatype that's just defined to be a function
09:37:44 <duality> That's standard.  Then you have to use let.
09:37:45 <Lemmih> Renkin: Use a 'let', as duality said.
09:37:53 <Renkin> Ok, thanks
09:38:11 <lisppaste2> pitecus pasted "Cryptic typeclass error" at http://paste.lisp.org/display/30166
09:38:16 <duality> The prototypical source code of the State monad is full of this :)
09:38:40 <pitecus> I don't undertand whats going on there
09:38:49 <pitecus> Could anyone help?
09:40:52 <lisppaste2> crazycman annotated #30161 with "it works like this" at http://paste.lisp.org/display/30161#2
09:43:12 <Lemmih> pitecus: It may be a problem that the type 't' isn't used by 'findHead'/'defaultFindHead'.
09:43:14 <kosmikus> dons: you asked about directories in our version control paper? what do you want to know?
09:43:48 <Lemmih> pitecus: Try: class TreebankConfig c t | c -> t where
09:44:18 <pitecus> Lemmih, what does the bar mean?
09:44:39 <Lemmih> pitecus: That 'c' determines 't'.
09:46:28 <pitecus> This worked
09:46:37 <pitecus> But don't really understand why
09:46:48 <pitecus> Anything I can read?
09:48:18 <fons> Lemmih, here is a better explanation of my problem http://www.haskell.org/pipermail/haskell-cafe/2006-November/019654.html
09:48:20 <lambdabot> Title: [Haskell-cafe] Type signatures in FFI exported functions, http://tinyurl.com/y7zt98
09:49:34 <kilimanjaro> Is haskell pronounced similarly to "rascal"?
09:49:50 <mwc> pitecus, what a fundep does is say that for any given type on the left side of the arrow, the right side is uniquely determined. Take the state monad. State Int means that the state type must be Int
09:49:51 <pejo> How on earth do you indent if inside a do-block where the branches contain do-blocks themselves too? Currently I have "if cond then RET do RET [stmts] RET return exp else RET do  RET [stmts] RET return exp' - and that looks like crap.
09:49:57 <mwc> kilimanjaro, I say Has-Kill
09:51:09 <pitecus> mwc, i see
09:51:18 <Lemmih> fons: What you're trying to do doesn't make sense. Using type classes from C is more trouble than it's worth.
09:53:10 <mwc> Aren't typeclasses how we do pseudo-OO bindings for OO-like libs (GTK)
09:56:01 <Lemmih> They can be used for a lot of things. Staying in Haskell is a requirement, though.
09:57:23 <Renkin> I don't know how to use let to without making the function messy
09:57:26 <Renkin> I'll pase it I guess
10:00:27 <Lemmih> fons: Are you sure you fixed the problem with exportable' and exportable''?
10:00:50 <fons> I fixed it with exportable' I'm sure bout that
10:01:13 <lisppaste2> Renkin pasted "A mess" at http://paste.lisp.org/display/30168
10:01:49 <Renkin> Is that beyond re-structurable? =)
10:01:50 <Lemmih> fons: Have you tested them?
10:02:23 <fons> as I said in the mail, the problem remains with exportable'' because in Haskell98 dictionaries are not packed with data constructors
10:02:26 <fons> Lemmih, not yet
10:02:31 <Excedrin> is it possible to have multiple modules in a single file, or is module only acceptable at the beginning?
10:02:40 <fons> I'm still recoding everything
10:03:07 <Lemmih> fons: Being able to export the functions isn't everything. It's very likely that they'll segfault when you call them.
10:03:40 <Lemmih> Renkin: MkProgram program where program (x,y) dir p c = let ... in ...?
10:04:03 <fons> Lemmih, then the compiler should be able to worn the user about that
10:04:22 <fons> Lemmih, anyway ... I'll try it
10:04:28 <Renkin> Lemmih: Ah, yeah, that sounds nice. I'll try that, thanks
10:04:42 <Lemmih> fons: Being evil with pointers is something the compiler can't warn about (:
10:05:15 <Renkin> I'm new to Haskell
10:05:21 <fons> Lemmih, it's not being evil, cause all the pointers are legally created by haskell and is type consistent
10:06:52 <Lemmih> fons: It /is/ evil. You'd be way better off with a record.
10:09:45 <Lemmih> fons: data Foo a = Foo { action1 :: a -> IO () }; exportable :: StablePtr (Foo a, a) -> IO ()
10:11:19 <Lemmih> That's essentially what you're doing.
10:13:09 <SimonRC> Is there anything like SLIME for Haskell?
10:14:57 <SimonRC> I saw a SLIME demo and really liked it.
10:15:35 <LoganCapaldo> SLIME is many things, any particular features you were enamored of?
10:16:49 <LoganCapaldo> SimonRC: http://www.haskell.org/haskell-mode/
10:16:50 <lambdabot> Title: Haskell Mode for Emacs
10:20:24 <SimonRC> looks interesting...
10:20:37 <SimonRC> I didn't realise that haskell-mode could do that
10:34:34 <SamB> @hoogle getArgs
10:34:36 <lambdabot> System.getArgs :: IO [String]
10:37:32 <LoganCapaldo> hoogle?
10:37:50 <LoganCapaldo> @help hoogle
10:37:51 <lambdabot> hoogle <expr>. Haskell API Search for either names, or types.
10:38:07 <LoganCapaldo> silly name
10:38:22 <lennart> cool name
10:38:38 <LoganCapaldo> the two are not mutually exclusive ;)
10:39:10 <lennart> true
10:39:44 <LoganCapaldo> @hoogle IO [String]
10:39:44 <lambdabot> System.getArgs :: IO [String]
10:39:45 <lambdabot> System.Console.Readline.filenameCompletionFunction :: String -> IO [String]
10:39:45 <lambdabot> System.Console.Readline.usernameCompletionFunction :: String -> IO [String]
10:40:18 <LoganCapaldo> It's amazing how much info is inherent in types in Haskell
10:41:00 <LoganCapaldo> You can almost search for a function by what it does
10:41:14 <lennart> yes, sometimes you can
10:41:39 <LoganCapaldo> I like it
10:41:43 <lennart> polymorphic type give a lot of information
10:41:52 <psnl> LoganCapaldo: almost... if some people have their way, then the next languages will be completely like that
10:42:01 <lennart> like if a function has type 'a->a' you know which function it is
10:42:11 <Heffalump> well, if it's strict
10:42:21 <Heffalump> otherwise you know which of two functions it is
10:42:33 <lennart> ok, so i always ignore partial functions.  they are uninteresting ;)
10:44:11 <lisppaste2> dolio annotated #30168 with "suggestion" at http://paste.lisp.org/display/30168#1
10:45:01 <duality> partial functions are interesting :)
10:45:10 <dolio> Renkin: ^
10:53:51 <RemiTurk> good evening
10:55:27 <lisppaste2> monochrom annotated #30119 with "truely existential" at http://paste.lisp.org/display/30119#3
11:06:24 <fons> Lemmih, I understand
11:17:31 <araujo> Hello!
11:18:11 <Korollary> wow. I guess I didnt realize how much Sensible Soccer sucked at the time...
12:01:22 <tibbe> > let intercalate x = concat . intersperse x in fromJust $ Just ["wakeup", "haskell!"]
12:01:24 <lambdabot>  ["wakeup","haskell!"]
12:01:37 <tibbe> > let intercalate x = concat . intersperse x in intercalate $ fromJust $ Just ["wakeup", "haskell!"]
12:01:38 <lambdabot>  <[[[Char]]] -> [[Char]]>
12:01:44 <tibbe> omfg
12:01:47 <tibbe> > let intercalate x = concat . intersperse x in intercalate " " $ fromJust $ Just ["wakeup", "haskell!"]
12:01:49 <lambdabot>  "wakeup haskell!"
12:02:14 <Korollary> I hate this game
12:02:54 * vincenz buys Korollary sudoku
12:03:20 <Syzygy-> @type ["foo"]
12:03:21 <lambdabot> [[Char]]
12:03:51 <Syzygy-> @type (concat . intersperse)
12:03:52 <lambdabot>   Expecting a function type, but found `b'
12:03:53 <lambdabot>    Expected type: a1 -> [[a]]
12:04:10 <Syzygy-> @type (concat . intersperse " ")
12:04:11 <lambdabot> [[Char]] -> [Char]
12:04:25 <Syzygy-> @type (concat . intersperse [" "])
12:04:26 <lambdabot> [[[Char]]] -> [[Char]]
12:04:40 <tibbe> > fromJust Nothing
12:04:40 <lambdabot>  Add a type signature
12:04:53 <tibbe> > fromJust Nothing :: Maybe Int
12:04:54 <lambdabot>  Exception: Maybe.fromJust: Nothing
12:05:08 <tibbe> > head []
12:05:09 <lambdabot>  Add a type signature
12:05:14 <tibbe> > head [] :: Int
12:05:16 <lambdabot>  Exception: Prelude.head: empty list
12:07:01 <tibbe> @pl concat $ intersperse " "
12:07:02 <lambdabot> join (intersperse " ")
12:07:16 <tibbe> why does @pl prefer join to concat? more general?
12:07:31 <tibbe> @type join
12:07:32 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
12:07:58 <tibbe> join [1]
12:08:01 <tibbe> > join [1]
12:08:02 <lambdabot>  add an instance declaration for (Num [a])
12:08:02 <lambdabot>   In the list element: 1
12:08:10 <tibbe> > join [[1]]
12:08:11 <Syzygy-> > join . intersperse " " ["wakeup","haskell"]
12:08:11 <lambdabot>  [1]
12:08:12 <lambdabot>    Expecting a function type, but found `[a]'
12:08:12 <lambdabot>    Expected type: a1 -> m ...
12:08:22 <Syzygy-> > join (intersperse " ") ["wakeup","haskell"]
12:08:23 <lambdabot>  Couldn't match `[a1] -> a' against `[a1]'
12:08:29 <Syzygy-> @type join
12:08:31 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
12:08:37 <tibbe> > (join . intersperse " ") ["wakeup","haskell"]
12:08:39 <lambdabot>  "wakeup haskell"
12:08:39 <Syzygy-> > join ((intersperse " ") ["wakeup","haskell"])
12:08:41 <lambdabot>  "wakeup haskell"
12:08:47 <tibbe> :)
12:08:51 <Syzygy-> Ah.
12:09:08 <tibbe> $ is usually better when calling the created function
12:09:26 <tibbe> join $ intersperse " " $ ["wakeup","haskell"]
12:09:36 <tibbe> >join $ intersperse " " ["wakeup","haskell"]
12:09:41 <tibbe> > join $ intersperse " " ["wakeup","haskell"]
12:09:43 <lambdabot>  "wakeup haskell"
12:10:01 <dolio> > join . intersperse " " $ ["wakeup", "haskell"]
12:10:02 <lambdabot>  "wakeup haskell"
12:11:42 <tibbe> > let f = \x -> x x in f (\y -> y y)
12:11:43 <lambdabot>    Occurs check: cannot construct the infinite type: t = t -> t1
12:11:43 <lambdabot>    Expe...
12:15:51 <tibbe> ?hoogle fix
12:15:52 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
12:15:52 <lambdabot> Control.Monad.Fix :: module
12:15:52 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
12:20:39 <_matthew-> any ideas how I can make the following line more efficient?
12:20:46 <_matthew->             x'' = if abs x' < epsilon then 0 else if abs x' > maxForce then maxForce * (abs x') / x' else x'
12:21:08 <_matthew-> i.e., that last abs x' / x' is just to get the +1 vs -1 multiplier
12:21:24 <_matthew-> what would people suggest for making it less expensive?
12:22:41 <coffeemug> hey guys
12:23:16 * Botje drinks from coffeemug 
12:23:31 <dolio> signum x' is probably clearer than (abs x') / x', at least.
12:23:50 <coffeemug> :)
12:24:00 <coffeemug> is Cabal being maintained?
12:24:12 <coffeemug> I went to the wiki to browse the tickets
12:24:20 <Korollary> it is
12:24:27 <coffeemug> there are a lot of high priority stuff from a year ago
12:24:44 <coffeemug> I tried to login to submit a ticket via instructions (guest/haskell)
12:24:47 <coffeemug> that doesn't seem to work
12:25:01 <_matthew-> dolio : ahh, thanks, I didn't know of signum
12:25:23 <coffeemug> also hackageDB link seems to be down
12:26:50 <Korollary> check with dons or dcoutts
12:27:13 <pkhuong-> _matthew-: you could probably write a signum_eps that returns -1, 0 or 1. That'd make your code simpler.
12:29:31 <_matthew-> yeah, I've effectively got that now. I was just concerned about the speed.
12:32:14 <pkhuong-> _matthew-: if this were ##c, i'd tell you to just get to the bits and go branch-free, but I don't think it's a good idea :)
12:33:02 <_matthew-> um I think that might be unwise ;)
12:33:47 <Botje> _matthew-: you could factor out the calls to abs x'
12:34:18 <_matthew-> err, well surely ghc will do that anyway
12:35:11 <_matthew-> (of course, that's not a good excuse for poor programming style...)
12:36:43 <fons> Lemmih, I finally tested it, and I works just fine
12:37:26 <fons> Lemmih, that means that by using existentials you can export polymorphic functions to C
13:08:25 <SamB> fons: well, see, they don't *look* polymorphic!
13:31:50 <emu> @hoogle noMsg
13:31:51 <lambdabot> Control.Monad.Error.noMsg :: Error a => a
13:31:51 <lambdabot> Foreign.C.Error.eNOMSG :: Errno
14:01:12 <Botje> @pl \c -> c : delete c "abc"
14:01:13 <lambdabot> ap (:) (flip delete "abc")
14:01:14 <heatsink> > runWriter $ pass $ tell "hey" >> return ((), \x -> "(" ++ x ++ ")")
14:01:16 <lambdabot>  ((),"(hey)")
14:01:28 <heatsink> What is pass for?
14:02:02 <emu> yow, haddock compile is killing my system
14:02:02 <emu> why is Html; module taking so long?
14:04:21 <emu> phooey, ran out of memory
14:05:44 <therp> is there any way I can write stuff like this
14:05:50 <therp> sorry [(3, (\x -> show x)), ("hello", id)] :: [(a, a -> String)]
14:06:26 <therp> I want a list of tuples, where one is a "blob" and the second one is a function that processes this blob
14:06:52 <therp> (actually s/blob/private arbitrary object/)
14:06:57 <heatsink> therp: use existential types
14:07:05 <SamB> oh, well, you can't do that with tuples...
14:07:15 <therp> samb: with anything else?
14:07:21 <SamB> with existentials, yes
14:07:32 <therp> heatsink: hm, I can only briefly remember them from TAPL
14:07:38 <heatsink> I'm curious why it's not sufficient to just have (a, String)
14:07:51 <emu> because its a different a each element
14:08:06 <heatsink> Actually... why not just have [String]?
14:08:06 <SamB> heatsink: I wonder rather why it isn't sufficient to just have [String]
14:08:25 <therp> heatsink: it was actually just a short description. in fact the first thing is IORef a, while the second is IORef a -> Foo -> IO Foo
14:08:33 <heatsink> ok
14:09:03 <therp> existential types you say. ok thanks will have a look at that topic
14:09:32 <heatsink> I haven't actually used them, so I won't be much help with actually writing the code.
14:09:56 <therp> unfortunately I have returned TAPL back to the library..
14:10:05 <heatsink> TAPL is a book?
14:10:13 <emu> i have a copy next to me
14:10:30 <therp> heatsink: types and programming languages, by B.pierce
14:11:00 <heatsink> ah.
14:11:32 <therp> ha, google knows TAPL.
14:13:51 <LoganCapaldo>  therp I am jealous of your library
14:15:18 <therp> logancapaldo: don't you have any university library near by?
14:15:41 <LoganCapaldo> heh
14:15:51 <LoganCapaldo> my universities library bites
14:16:10 <LoganCapaldo> Although i think I can check stuff out of NYU
14:16:20 <LoganCapaldo> now that I think about it
14:16:28 <LoganCapaldo> we have a "relationship"
14:17:04 <spiffy> inter-library loans are pretty common
14:17:09 <spiffy> errr
14:17:30 <SamB> @remember dibblego [in ##c] <dibblego> ?type map <SamB> no lambdabot in ##c, silly! <dibblego> I'm so used to lambdabot following me around
14:18:05 <emu> http://www.haskell.org/hawiki/ExistentialTypes
14:18:09 <lambdabot> Title: ExistentialTypes - The Haskell Wiki, http://tinyurl.com/yyexea
14:19:06 <heatsink> :)
14:19:12 <therp> emu: thanks found that already. also trust the haskellwiki
14:19:28 <Cale> haha, we should put lambdabot in ##c :)
14:19:54 <Cale> @version
14:19:55 <lambdabot> lambdabot 4p272, GHC 6.5 (OpenBSD i386)
14:19:55 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
14:19:59 <SamB> Cale: thats funny, Baughn said the same thing
14:20:02 <Cale> @type comparing
14:20:04 <lambdabot> Not in scope: `comparing'
14:20:06 <Cale> hmm
14:20:15 <Cale> oh, it's not even 6.6
14:34:27 <Cale> @list
14:34:28 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
14:35:04 <Cale> @join ##c
14:35:10 <Cale> hmm
14:43:53 <Renkin> I have a type Program defined in the following style: "data Program = Const1 Program | Const2 Int Program | ... | Stop"
14:44:22 <Renkin> Where the last Program argument of most constructors is what should run after it.
14:44:48 <Renkin> Constructors Stop and Fork Program Program  doesn't have any following program.
14:45:32 <Renkin> Now, I can't come up with a good  >>-function that should sequence two programs.
14:45:57 <Renkin> I don't have a Cons, so to say.
14:46:26 <heatsink> Renkin, It seems like f >>- g would find all instances of "Stop" in f and replace them with g.  Is that right?
14:46:45 <Renkin> Yeah.
14:46:53 <Heffalump> what about in the case of a Fork?
14:47:12 <Renkin> Heffalump: It should run two programs in parallell
14:47:14 <Heffalump> what does (Fork a b >>- c) evaluate to?
14:47:29 <Heffalump> is it (Fork (a >>- c) (b >>- c)) ?
14:47:59 <Renkin> Didn't think that far yet :)
14:48:11 <Heffalump> well, it's easy to define apart from that
14:48:13 <kpreid> if you use record syntax you can write the simple cases trivially:
14:48:27 <kpreid> a >>- b = a { nextProgram = b }
14:48:36 <Heffalump> (Const1 a) >>- b = Const1 (a >>- b)
14:48:41 <kpreid> er, wait, that's not right
14:48:42 <Heffalump> Stop >>- b = b
14:48:55 <Heffalump> kpreid: I don't think it helps much
14:49:07 <Heffalump> cos since not everything has a nextProgram, you still have to list the constructors that do before looking at it
14:49:15 <kpreid> yes
14:49:24 <kpreid> I'm assuming most things have a nextProgram
14:49:24 <Renkin> Ah, that's right
14:49:38 <Renkin> Yeah, all except Stop and Fork
14:49:42 <kpreid> a >>- b = a { nextProgram = (nextProgram a) >>- b }
14:49:55 <kpreid> that shouldl work
14:50:04 <kpreid> whether you want it is a different question
14:50:15 <Heffalump> kpreid: oh, and if you put all the cases without a nextProgram first, it'll be fine
14:50:20 <Heffalump> good plan
14:50:36 <heatsink> as long as programs aren't cyclic.
14:50:40 <Heffalump> Renkin: well, you still need to decide what Fork does
14:51:01 <Heffalump> heatsink: laziness will take care of that
14:51:04 <Renkin> Anything that comes after a fork should probable be ignored
14:51:18 <Heffalump> if a is an infinite loop, a >>- b is too, but when you come to evaluate it you'll get a
14:51:48 <heatsink> ok.
14:52:19 <Renkin> About  a >>- b = a { nextProgram = (nextProgram a) >>- b }
14:52:25 <Renkin> What's {} ?
14:52:30 <kpreid> record syntax
14:52:35 <kpreid> in this case, a record update
14:52:51 <Renkin> And what is that? =)
14:52:58 <kpreid> a { b = c } means "the record a, with the value of the field b replaced with c"
14:53:15 <kpreid> records are just data with labeled fields
14:53:28 <Renkin> Ah, ok
14:53:41 <kpreid> data Program = Const1 { nextProgram :: Program } | Const2 { foo :: Int; nextProgram :: Program } | ...
14:54:26 <Renkin> Ok, cool. Hadn't seen that before
14:57:20 <tobbes> greetings trying to map +1 on [1] gets me "Illegal hugs98 class-constraint"
14:57:25 <tobbes> what's wrong?
14:58:05 <tobbes> Prelude> map +1 [1]
14:58:06 <tobbes> ERROR - Illegal Haskell 98 class constraint in inferred type
14:58:06 <tobbes> *** Expression : map + fromInt 1 [1]
14:58:06 <tobbes> *** Type       : (Num ([a] -> (b -> c) -> [b] -> [c]), Num a, Num ((b -> c) -> [b] -> [c])) => (b -> c) -> [b] -> [c]
14:59:51 <twanvl> You need parentheses, (+1) not +1
15:00:04 <tobbes> ah
15:00:07 <tobbes> thx
15:00:38 <tobbes> does that apply in general to map?
15:00:54 <tobbes> do I need to put functions to map in parenthesis?
15:01:33 <Excedrin> no
15:01:37 <heatsink> tobbes, when you apply fewer than two arguments to an operator you need parentheses.
15:01:56 <heatsink> > let x = (5+) in x 1
15:01:58 <lambdabot>  6
15:02:21 <Botje> @pl \x y -> fst x `compare` fst y
15:02:22 <heatsink> > let x = (*21) in x 2
15:02:22 <lambdabot> (. fst) . compare . fst
15:02:23 <lambdabot>  42
15:02:47 <Excedrin> > let x = (*) 21 in x 2
15:02:49 <lambdabot>  42
15:03:55 <tobbes> Ok one more question I have a function from [a] -> [[a]] and I have defined it as sublists x:xs = x:(map (sublists) xs)
15:04:49 <tobbes> *** Type           : [a] -> [a]
15:04:49 <tobbes> *** Does not match : a -> a
15:04:49 <tobbes> *** Because        : unification would give infinite type
15:05:55 <heatsink> @type let f = undefined :: [Int] -> [[Int]] in map f
15:05:57 <lambdabot> [Int] -> [[Int]] in map f :: [[Int]] -> [[[Int]]]
15:06:04 * beelsebob wonders if the tiger build of ghc-6.6 will work in leopard
15:06:23 <tobbes> ah
15:19:58 <Lajexander> ERROR "for_great_justice.hs":38 - Inferred type is not general enough <-- wtf? what did i do?
15:21:16 <Cale> Lajexander: you gave something a more general type signature than it actually has
15:21:23 <Lajexander> oh
15:24:12 <Lajexander> it works! yay!
15:25:39 <heatsink> @hugs
15:25:40 <lambdabot> Unknown command, try @list
15:28:05 <LoganCapaldo> @djinn [a] -> [[a]]
15:28:06 <lambdabot> -- f cannot be realized.
15:28:33 <LoganCapaldo> :(
15:29:26 <pkhuong> @djinn a -> [a]
15:29:26 <lambdabot> -- f cannot be realized.
15:29:39 <heatsink> @djinn a -> b -> (a, b)
15:29:39 <lambdabot> f a b = (a, b)
15:29:57 <LoganCapaldo> @type (:[])
15:29:59 <lambdabot> forall a. a -> [a]
15:30:04 <pkhuong> heh, no list axioms, I guess.
15:30:33 <heatsink> @djinn a -> [a] -> [a]
15:30:34 <lambdabot> f _ a = a
15:30:40 <Lajexander> i want to do som haskell coding to learn more and get experience... anyone know of any good open source project?
15:30:54 <heatsink> ghc ;)
15:31:01 <Lajexander> hehe
15:31:12 <eviltwin_b> experience, not crucible :)
15:31:41 <heatsink> does darcs need any hacking?
15:31:48 <Lajexander> seriously, could someone point me in the right direction?
15:32:04 <Lajexander> darcs is cool =)
15:32:16 <Excedrin> lambdabot seems like a good place to start hacking
15:32:36 <Lajexander> how do i get the lambdabot source?
15:32:43 <kpreid> @version
15:32:43 <lambdabot> lambdabot 4p272, GHC 6.5 (OpenBSD i386)
15:32:44 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
15:33:22 <Lajexander> gotta get darcs first ;)
15:33:43 <pkhuong> or wget.
15:34:35 <Heffalump> has anyone used hs-plugins to build hierarchical modules?
15:34:36 <Lajexander> fuck! darcs isn't in ubuntus synaptic... i have no clue about what i should do now...
15:34:54 <heatsink> I think you can download it from darcs.net
15:35:15 <metaperl> Lajexander: what do you like about ubuntu over debian?
15:35:39 <Lajexander> ehm... nice installer?
15:35:48 <Lajexander> never used debian...
15:35:54 <metaperl> i see
15:36:25 <Lajexander> i SHOULD be using freeBSD, i just can't be bothered to do "the switch" just
15:36:41 <Lemmih> Why should you be using freeBSD?
15:36:48 <Lajexander> i'll probably change OS when i have more than one computer
15:37:01 <Lajexander> Lemmih: h4xx0r points
15:37:18 <pkhuong> open > free
15:37:20 * pkhuong ducks
15:37:52 <Lajexander> pkhuong: what are you using?
15:38:34 <pkhuong> a mixture of open, free, colinux and solaris.
15:38:49 <metaperl> that sounds painful
15:39:47 <pkhuong> no. s/colinux/OS X/ once 10.5 is released, hopefully.
15:40:08 <Lajexander> OK, so I have darcs*.tar.gz... what now?
15:40:49 <metaperl> gzip -dc filename.tar.gz | tar xvf -
15:41:05 <heatsink> metaperl, no tar xzf?
15:41:25 <metaperl> heatsink: I never did do that :) but I guess you could
15:42:25 <Lajexander> what do i do now? make "something" "something", right?
15:42:55 <metaperl> Lajexander: there are build instructions at darcs.net and probably in the dir you just created :) you are worse than me about crying for help :)
15:43:14 <metaperl> oh also there is #darcs
15:43:41 <Lajexander> i hate installing shit on windows... this is probably the main reason why love freeBSD/ports
15:44:11 <metaperl> are you build in windows?
15:44:33 <Lajexander> im using ubuntu
15:44:47 <pkhuong> apt-get install darcs ?
15:45:12 <Lajexander> i'm doing it the hard way... i have to learn this at some point
15:45:56 <tobbes> how would one go about to build a program to generate all sublists of a list? I know this is probably a stupid question but I really would like just a hint on where to begin
15:46:42 <LoganCapaldo> tobbes: well first you have to define "sublist"
15:47:42 <tobbes> yes, and I was thinking of having a function sublist :: [a] -> Int - Int -> [a]
15:48:00 <tobbes> which would take the elements from index x to index y
15:48:24 <tobbes> the problem is it would be terribly inefficent
15:48:43 <metaperl> well, one thing to do is to generate them all from 1 .. length(inputList)-1
15:48:54 <metaperl> generate all of length1, length2, etc
15:49:09 <tobbes> hmm yes
15:49:21 <tobbes> and then start from the next index
15:49:22 <LoganCapaldo> Is [1, 4] a sublist of [1,2,3,4] tobbes?
15:49:36 <tobbes> no
15:49:40 <LoganCapaldo> ok
15:49:42 <SamB> you mean like map tails . inits?
15:49:45 <tobbes> not as I was planing to define it
15:49:56 <SamB> > map tails . inits $ [1..]
15:49:57 <lambdabot>  [[[]],[[1],[]],[[1,2],[2],[]],[[1,2,3],[2,3],[3],[]],[[1,2,3,4],[2,3,4],[3,4...
15:50:00 <newsham> ?pl \x -> return ("<" ++ x) `mplus` (return x)
15:50:01 <lambdabot> ap (mplus . return . ('<' :)) return
15:50:05 <SamB> hmm.
15:50:13 <Renkin> So I have a data Program = Const1 ... Program | Const2 ... Program | Stop which generates programs that're like lists with many constructurs and Stop instead of Nil...
15:50:18 <tobbes> hmm tails u say...
15:50:36 <SamB> that doesn't quite work, does it?
15:51:19 <LoganCapaldo> > tails [1,2,3,4]
15:51:21 <lambdabot>  [[1,2,3,4],[2,3,4],[3,4],[4],[]]
15:51:38 <twanvl> > concat . map (tail . inits) . tails $ "abcd"
15:51:39 <lambdabot>  ["a","ab","abc","abcd","b","bc","bcd","c","cd","d"]
15:51:56 <tobbes> hmm i get undefined function for tails
15:52:05 <Renkin> Now I need the function that runs a program, by going through it step by step and so to speak "change the state" of an entity..
15:52:06 <LoganCapaldo> import Data.List
15:52:27 <Lajexander> haskell supports sets, right?
15:52:29 <pkhuong> ?type foldl
15:52:30 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
15:52:42 <Renkin> Coming from imperative programming, I can't figure out a way to replace changing the states of things
15:52:49 <pkhuong> Renkin: if your program is a trace, like a list, foldl is your friend.
15:53:24 <lispy> Renkin: or try the state monad
15:53:28 <Renkin> pkhuong: Ok, I'll look at that
15:53:45 <Renkin> lispy: Ah, so there's a state monad :)
15:53:51 <Cale> You don't really change the state of anything, you just compute the new state from the old one :)
15:54:15 <Renkin> Cale: Exactly, and that was easier when I had type Program = State -> (State, Result)
15:54:26 <Renkin> But now I have it more abstract.
15:54:42 <Renkin> And my brain is too tired to figure it out. =)
15:54:44 <tobbes> cool
15:54:46 <tobbes> thx
15:55:04 <newsham> question: should this be a monad?  http://www.thenewsh.com/~newsham/x/machine/Transform2.hs  (Trans a)
15:55:07 <lambdabot> http://tinyurl.com/woq3j
15:55:25 <newsham> (maybe tplus = mplus, tzero = mzero,   tcomp = bind?)
15:55:31 <SamB> Renkin: the difference is very little...
15:56:17 <Renkin> SamB: Yeah, I know.. but I'm kinda new to this so I haven't learned to see the obvious things yet :)
15:56:18 <Cale> tcomp has the wrong type for bind, however, this looks a lot like the Kleisli Arrow for the list monad
15:56:31 <newsham> you guys were mentioning kleisli arrow yesterday
15:56:34 <newsham> and that went over my head
15:56:34 <SamB> @type State
15:56:36 <lambdabot> forall a s. (s -> (a, s)) -> State s a
15:57:13 <Renkin> Yeah, that does seem really helpful. Thanks :)
15:57:15 <newsham> i basically have a bunch of transformations (ie.  return . (++ ">"))    and I want ot be able to combine them together in various ways
15:57:17 * eviltwin_b wonders if he wants to write "hscope", or figure out how to use hoogle on local sources
15:57:37 <Renkin> So using the State monad is the best way to do it? Would any other solution basically be to implement it yourself?
15:58:25 <newsham> is there something i can read that will explain this kleisli arrow thing in a way that my leetle brain can deal with?
15:58:26 <Renkin> @info State
15:58:27 <lambdabot> State
15:58:31 <Renkin> Heh..
15:58:56 <Renkin> Which module is it in?
15:59:02 <twanvl> If the state is very simple it might be better to pass it around explicitly
15:59:09 <twanvl> Control.Monad.State
15:59:18 <Renkin> Ok, thanks
16:00:08 <newsham> so a kleisli is (a -> mb)  (like my transforms) ?
16:00:09 <Renkin> twanvl: It's 3-4 variables
16:00:19 <Renkin> Or, values
16:01:35 <newsham> is my (Trans a) an instance of Kleisli List a?
16:01:56 <newsham> (or Kleisli a [a] rather?)
16:02:35 * SamB thought Kleisli was a newtype
16:02:43 <SamB> @type Kleisli
16:02:45 <lambdabot> forall b a (m :: * -> *). (a -> m b) -> Kleisli m a b
16:03:55 <newsham> samb: got some simple page that explains kleisli?  does it apply to my http://www.thenewsh.com/%7Enewsham/x/machine/Transform2.hs ?
16:03:57 <lambdabot> http://tinyurl.com/yc63jv
16:07:23 * SamB doesn't know
16:07:26 <newsham> people keep saying magical kleisi word, but no details :(
16:07:49 <SamB> newsham: have you looked at the patch sent to the mailing list (there *was* a patch, wasn't there?)
16:08:33 <newsham> url and/or thread topic?  i imagine h-cafe?
16:08:49 <dons> moin
16:08:54 <newsham> hi dons
16:09:29 <newsham> how're things down undah?
16:10:52 <dons> sunday-morning-ish
16:12:02 <newsham> dons: got url for info on kleisi arrow?
16:12:35 <dons> ?docs Control.Arrow
16:12:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html
16:12:38 <Lajexander> how are sets implemented in haskell?
16:12:46 <dons> ?docs Data.Set
16:12:47 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
16:13:01 <newsham> dons: know of anything more descriptive?
16:13:04 <dons> ?source Data.Set
16:13:04 <lambdabot> http://darcs.haskell.org/packages/base/Data/Set.hs
16:13:11 <dons> newsham: the arrow material on the research wiki?
16:13:28 <Lajexander> >{1,2,3}
16:13:33 <dons> > [1,2,3]
16:13:35 <lambdabot>  [1,2,3]
16:13:43 <Lajexander> > {1,2,3}
16:13:44 <lambdabot>  Parse error
16:13:47 <newsham> is the research wiki on www.haskell.org?
16:13:55 <dons> your making up syntax, Lajexander
16:14:03 <dons> newsham: http://haskell.org/haskellwiki/Research_papers/Monads_and_arrows#Arrows
16:14:06 <lambdabot> Title: Research papers/Monads and arrows - HaskellWiki, http://tinyurl.com/fgd83
16:14:09 <newsham> dons: thakn you
16:14:24 <newsham> ahh, the wiki page for research papers.. gotcha :)
16:14:33 <Lajexander> dons: just trying a little... it's how i'm used to write sets
16:14:35 <dons> > S.empty
16:14:36 <lambdabot>  Add a type signature
16:14:42 <dons> > S.empty :: Set Int
16:14:42 <threeq> newsham: also, http://sigfpe.blogspot.com/2006/06/monads-kleisli-arrows-comonads-and.html
16:14:43 <lambdabot>  Not in scope: type constructor or class `Set'
16:14:46 <lambdabot> Title: A Neighborhood of Infinity: Monads, Kleisli Arrows, Comonads and other Rambling  ..., http://tinyurl.com/jhldt
16:14:50 <dons> > S.empty :: S.Set Int
16:14:52 <lambdabot>  {}
16:14:53 <Lajexander> i was thinking of doing some basic model theory in haskell =)
16:14:57 <newsham> threeq: danke.
16:15:20 <dons> > S.fromList [1..10,1,2,39,12,1]
16:15:21 <lambdabot>  Parse error
16:15:35 <dons> > S.fromList $ [1..10] ++ [1,2,39,12,1]
16:15:37 <lambdabot>  {1,2,3,4,5,6,7,8,9,10,12,39}
16:17:16 <Lajexander> wtf?
16:17:29 <Lajexander> howcome he can?
16:17:40 <Lajexander> > Set [1..10]
16:17:41 <lambdabot>  Not in scope: data constructor `Set'
16:18:53 <dons> Lajexander: read the docs for Data.Set
16:18:57 <dons> ?docs Data.Set
16:18:57 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
16:19:03 <norpan> > Data.Set.fromList [1..10]
16:19:04 <lambdabot>  Not in scope: `Data.Set.fromList'
16:19:08 <norpan> no?
16:19:15 <dons> > S.fromList [1..10]
16:19:17 <lambdabot>  {1,2,3,4,5,6,7,8,9,10}
16:19:31 <norpan> bah, secret qualifications
16:19:48 <dons> M.Map, and S.Set
16:20:19 <norpan> and G.Night
16:21:27 <dons> dcoutts: what's the status of ghc 6.6 in gentoo?
16:22:18 <dons> sjanssen: note that ghc 6.6 is now on the debian shootout box too (the one that isn't updated very often :/) http://shootout.alioth.debian.org/debian/haskell.php
16:22:21 <lambdabot> http://tinyurl.com/yap2gq
16:30:24 <newsham> some of the shootout programs were a bit complicated due to optimization.
16:30:39 <newsham> with the new default grading rules, would it make more sense to use the simpler, less optimized programs?
16:31:00 <newsham> (ie optimized for small code and/or readability)
16:32:01 <dolio> I thought it was decided that since they use gzip bytes, we should manually inline as much code as possible now. :)
16:32:24 <pkhuong> depends on the block size :p
16:32:41 <fnord123> in an instance decl, where I'm defining a show method for my data constructor, I'm told I don't have enough args in the line 'instance Show MyDataType where ...'
16:32:44 <Saulzar> Copy and paste coding can be encouraged :)
16:33:03 <newsham> is MyDataType paramaterized?
16:33:18 <fnord123> so I try putting in 'instance Show MyDataType arg1 arg2 where ...' and it says 'too many type args'
16:33:41 <newsham> instance Show (MyDataType a b) where ?
16:35:19 <fnord123> newsham: I tried that and got a long messy error saying it could not deduce "(Show arg1) from the context (Show (MyDataType arg1 arg2) arising from the use of 'show' at myfile.hs:xyz... Probably fix: add (Show arg1) to the class or instance method 'show'...
16:35:36 <fnord123> however, the type of arg1 is irrelevant (afaik)
16:36:07 <lispy> what does ghc mean when it complains about orphaned instances?
16:36:17 <fnord123> or I would have thought it would be at this point; only if I try to make a MyDataType later on should it find out that I don't have a show for whatever arg1 is.
16:36:54 * fnord123 strokes his chin while wondering if he's confusing C++ template programming for an assumed Haskell behaviour.
16:39:32 <kosmikus> fnord123: you usually need "instance (Show arg1, Show arg2) => Show (MyDataType arg1 arg2) where ..."
16:39:47 <dolio> fnord123: Are you trying to use "show" on the contents of the MyDataType in your new definition of show?
16:40:39 <fnord123> I am. I am using where ... MyDataType a1 a2 = "Data " ++ show a1 ++ "  " ++ a2
16:40:57 <kosmikus> fnord123: so you need to do what I said ...
16:41:01 <fnord123> s/a2/show a2/
16:41:23 <dolio> Yeah, you need to specify it, then.
16:42:24 <fnord123> zounds!
16:42:31 <fnord123> dolio++
16:42:34 <fnord123> kosmikus++
16:43:14 <dons> lispy: orphaned instances: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#orphan-modules
16:43:16 <lambdabot> Title: 4.6. Filenames and separate compilation, http://tinyurl.com/yyunf2
16:43:22 <dons> ?where+ orphans http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#orphan-modules
16:43:23 <lambdabot> Done.
16:44:57 <Lajexander> @google syntax tree
16:45:00 <lambdabot> http://en.wikipedia.org/wiki/Abstract_syntax_tree
16:47:12 <beelsebob> @index hasBounds
16:47:12 <lambdabot> bzzt
16:47:15 <beelsebob> fail
16:47:19 <beelsebob> @hoogle hasBounds
16:47:20 <lambdabot> Data.Array.IArray.HasBounds :: class HasBounds a
16:53:07 <newsham> "It all seems so natural I'm astonished to find that Control.Comonad isn't a part of the standard Haskell distributions."
16:53:40 <wolverian> comonad? :)
16:54:04 <newsham> i'm reading this in http://sigfpe.blogspot.com/2006/06/monads-kleisli-arrows-comonads-and.html, they talk about the general pattern (something like a monad in reverse)
16:54:07 <lambdabot> Title: A Neighborhood of Infinity: Monads, Kleisli Arrows, Comonads and other Rambling  ..., http://tinyurl.com/jhldt
16:54:52 <newsham> is "functor" something that transforms functions (lift?)
16:55:03 <dons> ?type fmap
16:55:04 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
16:56:03 <newsham> ?type lift
16:56:05 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *). (MonadTrans t, Monad m) => m a -> t m a
16:57:07 <tobbes> is there a library implementing backtracking for haskell?
16:58:14 <newsham> one of the monad tutorials uses state monad to do backtracking.  Here's my translation of it to standard lib functions, w/ ref to original:  http://www.thenewsh.com/%7Enewsham/x/machine/eightqueens.lhs.txt
16:58:17 <lambdabot> http://tinyurl.com/sapva
16:58:31 <newsham> probably best to read the original first
16:59:16 <newsham> err.. Maybe monad + state monad
16:59:42 <dolio> The list monad can be used to do backtracking on its own, as well (I think).
17:00:02 <dolio> Just write the algorithm to find all solutions, and take the head.
17:00:05 <newsham> if you use monad you can get one solution w/ backtracking.  if you switch the same code to use list monad, you get all solutions
17:00:23 <newsham> err.. maybe monad
17:00:44 <newsham> maybe monad's kinda a baby list monad, no? :)
17:01:41 <dolio> Yeah. I'm not sure if it would work with maybe on its own, though.
17:03:02 <tobbes> take care
17:03:31 <dolio> Or, wait, is the state monad just to hold the state of the board?
17:03:40 <newsham> yah.
17:04:09 <dolio> Oh, well, in that case, yeah, I guess maybe just always gives you the first solution.
17:04:32 <dolio> Whereas list gives you as many as you demand.
17:09:56 <newsham> :t arr
17:10:00 <newsham> ?type arr
17:10:01 <lambdabot> forall (a :: * -> * -> *) c b. (Arrow a) => (b -> c) -> a b c
17:10:15 <newsham> I dont understand this
17:10:43 <newsham> > arr (+)
17:10:44 <lambdabot>  add an instance declaration for (Show (a b (b -> b)))
17:10:58 <beelsebob> @where lambdabot
17:10:59 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
17:11:54 <dolio> arr lifts a pure function into an arbitrary arrow.
17:12:23 <Botty> ok, so i admit it, vim looks nice
17:12:32 <newsham> i think i gotta read hughes first
17:12:33 * SamB thinks that there is a functor from [] computations to Maybe computations
17:13:10 <SamB> or maybe I have the wrong term...
17:13:31 <SamB> I really need to work on my CT knowledge
17:13:34 <dolio> For instance, for kleisli arrows a -> m b, arr f = Kleisli (return . f)
17:13:40 <dons> an injection, SamB?
17:14:02 <SamB> dons: er. no. not an injection.
17:14:04 <dons> via,
17:14:05 <dons>    , listToMaybe        -- :: [a] -> Maybe a
17:14:05 <dons>    , maybeToList    -- :: Maybe a -> [a]
17:15:31 <SamB> I think listToMaybe is the function involved in whatever kind of relationship.
17:15:59 <dons> > listToMaybe [1..10]
17:16:00 <lambdabot>  Just 1
17:16:18 <dons> > maybeToList (Just 1)
17:16:19 <lambdabot>  [1]
17:16:49 <newsham> ?pl \f g x -> mplus (f x) (g x)
17:16:49 <lambdabot> liftM2 mplus
17:16:55 <dons> SamB: oh a NatTrans?
17:17:08 <dons> class (Functor f, Functor g) => NatTrans f g where
17:17:08 <dons>     eta :: f a -> g a
17:17:29 <dons> instance NatTrans [] Maybe where eta = listToMaybe
17:17:44 <dons> instance NatTrans Maybe [] where eta = maybeToList
17:17:57 <dons> instance NatTrans [] []             where eta = id
17:17:57 <dons> instance NatTrans Maybe Maybe       where eta = id
17:18:44 <newsham> why do I get a type error when I do     tplus = liftM2 mplus ?
17:18:56 <Riastradh> Does anyone here happen to know why `show-paren-mode's effect has a delay in Haskell Mode, despite a zero value of `show-paren-delay', in GNU Emacs 22?
17:19:44 <SamB> well, for instance, listToMaybe x `mplus` listToMaybe y == listToMaybe (x `mplus` y)...
17:19:49 <SamB> that is what I meant...
17:20:17 <newsham> > "test" >>= (liftM2 mplus) (return . ("<" ++)) return
17:20:18 <lambdabot>  Couldn't match `[Char]' against `Char'
17:20:26 <newsham> > ["test"] >>= (liftM2 mplus) (return . ("<" ++)) return
17:20:28 <lambdabot>  ["<test","test"]
17:20:47 <dons> ?check \x y -> let _=x::T;_=y::T in listToMaybe x `mplus` listToMaybe y == listToMaybe (x `mplus` y)
17:20:48 <lambdabot>  OK, passed 500 tests.
17:20:50 <newsham> > ["test"] >>= (liftM2 mplus) (return . ("<" ++)) return >>= (return . (++ ">"))
17:20:51 <lambdabot>  ["<test>","test>"]
17:21:10 <newsham> > ["test"] >>= (liftM2 mplus) (return . ("<" ++)) return >>= (liftM2 mplus) (return . (++ ">")) return
17:21:11 <shapr> @karma
17:21:12 <lambdabot>  ["<test>","<test","test>","test"]
17:21:12 <lambdabot> You have a karma of 28
17:22:01 <newsham> that doesnt work for me when I run it in ghci (No instance for (Monad ((->) [Char]))
17:22:22 <dolio> You need Control.Monad.Reader.
17:22:27 <dolio> Or .Instances in 6.6.
17:22:46 <newsham> ahh, works if I import Control.Monad.Reader
17:23:08 <newsham> what definition is Reader is it requiring?
17:23:09 <dufflebunk> Is there somewhere which has examples of thing like IO? I want to open a file and turn it into a list of strings, each string is one line of the file. But I'm having a hard time figuring out the IO stuff.
17:23:18 <dufflebunk> Needless to say, I'm a beginner.
17:23:24 <dolio> instance Monad ((->) r)
17:23:46 <dolio> Which is the same as the reader monad without the newtype constructor.
17:23:53 <Lajexander> dufflebunk: i can give you something
17:23:59 <newsham> ahh, is that what (liftM2 mplus) is lifting over? :)
17:24:22 <dufflebunk> Lajexander: ok, thanks I'd appreciate it
17:24:26 <dons> dufflebunk: readFile "/tmp/f" >>= return . lines
17:24:39 <dons> > readFile "/tmp/f" >>= return . lines
17:24:40 <lambdabot>  <IO [[Char]]>
17:24:47 <dolio> Yeah, when you use monad combinators to do funky stuff with function composition, that's what it uses.
17:25:01 <dons> dufflebunk: but start on http://haskell.org
17:25:02 <lambdabot> Title: Haskell - HaskellWiki
17:25:09 <dons> and also, a good tutorial:
17:25:11 <dons> ?where yaht
17:25:12 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
17:25:17 <Lajexander> dons: that's probably not the easiest way
17:25:27 <dufflebunk> dons: gack, and I though Perl was the worst for line noise
17:25:46 <dufflebunk> although I think I saw >>= somwhere... `bind` ?
17:25:51 <dons> yep.
17:25:59 <dons> ?redo readFile "/tmp/f" >>= return . lines
17:26:00 <lambdabot> do { _ <- readFile "/tmp/f"; return} . lines
17:26:05 <dons> heh
17:26:08 <dons> sjanssen: ^^
17:26:17 <dons> do x <- readFile "/tmp/f" ; return (lines f)
17:26:34 <dons> is another optoin
17:26:39 <dons> ?pl readFile "/tmp/f" >>= return . lines
17:26:40 <lambdabot> lines `fmap` readFile "/tmp/f"
17:26:43 <dons> might also be ok ;)
17:26:47 <Lajexander> dufflebunk: PM
17:27:22 <dons> dufflebunk: the IO stuff is pretty easy once you remember that you're keeping side effecting code completely separate from pure code
17:27:30 <dons> like perl's taint checking, for all dangerous code
17:27:58 <dons> lots of IO tutorials on haskell.org, anyway
17:28:08 <newsham> ?pl \f g x -> f x >>= g
17:28:09 <lambdabot> flip . ((>>=) .)
17:28:25 <sjanssen> dons: Language.Haskell pretends that all operators are the same fixity, so that's the first part of the bug
17:28:34 <sjanssen> and the second part looks like my fault
17:29:09 <dons> ok. i wonder how hard a fixity pass would be to add to the tree?
17:29:18 <dolio> ?redo foo >>= return
17:29:18 <lambdabot> do { _ <- foo; return}
17:29:30 <sjanssen> probably not too hard
17:29:42 <dufflebunk> dons: Those all return lazy lists, right?
17:29:59 <newsham> ?pl \x -> mzero
17:29:59 <lambdabot> const mzero
17:30:18 <Lajexander> dufflebunk: my nick isn't registered... that might cause a problem :/
17:30:19 <dons> dufflebunk: lines is returning a lazy list, yeah, and readFile returns a lazy file stream
17:30:22 <int-e> ?redo foo >>= \x -> return x
17:30:23 <lambdabot> do { x <- foo; return x}
17:30:38 <newsham> ?pl foldl (liftM2 mplus) (const mzero)
17:30:38 <lambdabot> foldl (liftM2 mplus) (const mzero)
17:30:41 <dons> > take 10 [1..] -- lazy
17:30:42 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
17:31:20 <newsham> is there a way to rewrite   "foldl (liftM2 mplus) (const mzero)" in a simpler way, maybe using liftM of some sort?
17:31:22 <dufflebunk> Lajexander: yeah, you're not alowed to pm unless registered
17:31:58 <newsham> is that a lift of msum?
17:32:21 <dolio> Might be.
17:32:26 <dolio> ?type liftM msum
17:32:27 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m1, MonadPlus m) => m1 [m a] -> m1 (m a)
17:32:39 <sjanssen> @type do {x <- m; x <- m2; return x} -- is this legal?
17:32:41 <lambdabot> Not in scope: `m'
17:32:41 <lambdabot>  
17:32:41 <lambdabot> <interactive>:1:17: Not in scope: `m2'
17:32:44 <dolio> ?type foldl (liftM2 mplus) (const mzero)
17:32:46 <lambdabot> forall b (m :: * -> *) a. (MonadPlus m) => [b -> m a] -> b -> m a
17:32:59 <dons> sjanssen: looks ok
17:33:07 <dons> ?type \m m2 -> do {x <- m; x <- m2; return x}
17:33:07 <newsham> I want [a -> ma] -> (a -> ma)
17:33:08 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a1 -> m a -> m a
17:33:34 <dons> newsham: foldl ap  -- or lifted (.) ?
17:33:48 <dons> ah, you got it though
17:34:10 <dons> ?type foldl (liftM2 mplus) (const mzero) [putChar, putChar]
17:34:12 <lambdabot>   No instance for (MonadPlus IO)
17:34:12 <lambdabot>    arising from use of `mplus' at <interactive>:1:14-18
17:34:14 <newsham> yah, wondering if there's a simpler way
17:34:29 <Lajexander> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/funht/lab-assignments/lab4/ <-- try making it yourself first before cheating with my soloution ;)
17:34:33 <lambdabot> Title: Lab 4 - Sudoku -- Intro. to Func. Prog. (TDA555/INN040ht) -- HT2006, http://tinyurl.com/suct5
17:36:24 <pkhuong> unfair. That's a really fun assignment.
17:36:58 <dons> the chalmers guys have all the fun
17:37:12 <Lajexander> indeed we do
17:37:39 <dons> you could hardly set that as an assignment question now though, could you?
17:37:46 <dons> given the 30-odd sudoku solns on haskell.org...
17:38:18 <Lajexander> but D2 was NOT fun to write
17:38:34 <Lajexander> dufflebunk: checked the lab assignment?
17:38:54 <pkhuong> heh... That'd be an interesting assignment in something like C++, though. Give the basic idea of using the list monad and just forcing every square in a fixed order, let them implement it :)
17:39:21 <dons> ?users #haskell.se
17:39:21 <lambdabot> Maximum users seen in #haskell.se: 12, currently: 10 (83.3%), active: 2 (20.0%)
17:39:24 <dufflebunk> Lajexander: I'm looking at it, yeah
17:39:33 <int-e> E2. Implement a function: (!!=) :: [a] -> (Int,a) -> [a] .... *sigh*
17:39:34 <newsham> doesnt seem terribly hard to solve in c++.
17:39:50 <newsham> i wrote a python one without using any higher-order programming a while back.
17:40:10 <dons> int-e?
17:40:21 <dons> ?type insert
17:40:23 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
17:40:32 <int-e> dons: quoting from that lab assignment page
17:40:41 <dons> yeah, but why the sigh? bad style you think?
17:40:54 <int-e> dons: I strongly dislike using lists as arrays
17:41:01 <dons> yeah. fair enough
17:41:08 <pkhuong> newsham: the idea is to implement the list-monad solution.
17:41:34 <Lajexander> hey... this is the first programming we got to do
17:41:43 <int-e> but maybe for an introduction it's ok. don't know.
17:41:46 <newsham> yah, i did searching with backtracking as part of the solution.  its easy to do using recursion.
17:41:58 <Lajexander> don't complain too much... Koen knows what he's doing :)
17:42:00 <newsham> i'm not trying to detract from how easy backtracking is in haskell.
17:42:06 <newsham> just that doesnt seem like a horrible problem in c++
17:42:43 <pkhuong> again, my point was that implementing backtracking via lazy-list in C++ would be `interesting'.
17:42:51 <newsham> (I only did backtracking when guessing was necessary, but of course the code for backtracking would have worked for a pure guessing strategy)
17:43:08 <newsham> oh, you mean implement it by building a lazy list first.
17:43:13 <newsham> sorry, i completely misunderstood you
17:43:35 <newsham> i'll go back to my corner now
17:47:08 <alec> I want to save a data structure to disk.  In Python I'd call that pickling, in Java I'd call that Serializing, but I can't find what it's called in Haskell to figure out how to do it.  Any hints?
17:47:37 <kpreid> alec: for simple cases, read and show will do
17:48:11 <shapr> For more complicated cases, poke {dons,dcoutts,musasabi,etc} and beg for binary serialization.
17:48:23 <alec> kpreid, shapr: thanks
17:48:48 <dons> sjanssen: i'm just tweaking the fasta entry with the profiler, btw.
17:49:09 <dons> i'll submit it later (since 6.6 is on 2/3 shootout boxes now)
17:49:17 <shapr> Fast binary serialization is nearly ready. I think musasabi had some working code a coupla weeks ago.
17:49:26 <dons> ?wiki Binary_IO
17:49:27 <lambdabot> http://www.haskell.org/haskellwiki/Binary_IO
17:49:51 <dons> alec ^^
17:50:01 <alec> dons: looking now, thanks
17:50:10 <dons> but yeah, check with musasabi for the lastest and greatest in industrial binary serialisation, using bytestrings
17:50:46 <dons> I'd recommend firstly read/show, if that's no good, and your structure's simple, dump it to a bytestring. then try NewBinary
17:51:00 <Korollary> whacko question: can you serialize something like [putStr "foo"]?
17:51:04 <dons> finally, if performance is critical (i.e. $profit involved) get hold of musasabi's code
17:51:12 <dons> Korollary: you can in Clean
17:51:19 <shapr> alec: During dev, Read/Show serialization is really helpful.
17:51:21 <dons> (ie. dump the bytecode to disk)
17:51:47 <shapr> @seen musasabi
17:51:47 <lambdabot> musasabi is in #ghc, #haskell.se, #haskell-overflow, #haskell-blah and #haskell. I don't know when musasabi last spoke.
17:53:06 <shapr> I hope musasabi is okay.
17:53:15 <dons> he was here a couple of days ago.
17:54:00 <dons> well, 06.11.12
17:54:02 <shapr> I haven't seen him in about a week.
17:54:03 <blsecres> alec:
17:54:04 <dons> so a week ago
17:54:17 <blsecres> oops, sorry
17:55:10 <shapr> Didn't Bulat do some binary stuff as well? Should his Streams package be mentioned on BinaryIO?
17:55:35 <desrt> eval env (Variable v) | Just e <- lookup v env = e
17:55:45 <desrt> this will just fail to pattern match if lookup returns nothing, right?
17:56:18 <shapr> Oh hey, I had this crazy idea in the shower a coupla weeks ago...
17:56:23 <Korollary> oh no
17:56:29 <desrt> shower ideas are always the best
17:56:31 <Smokey``> good ideas always come from the shower :)
17:56:32 <shapr> Couldn't you use a GADT to explicitly represent a state machine?
17:56:39 <dons> shapr: yeah, streams could be up there.
17:58:27 <pkhuong> shapr: unfold and state transitions by selecting the right child?
17:58:40 <shapr> yeah
17:58:46 <shapr> er wait
17:58:52 <shapr> hmm
17:59:06 <shapr> ack
17:59:14 <dons> [Way OT] so there was this research published this week showing a link between red meat consumption and breast cancer in women (from a study of nurses). many many stories written about it. however, today, 5 days later, i find the first article criticle of the study: FOX News "No Beef to Breast Cancer Scare" . Fox, the source of great academic review and critiques
17:59:42 <dons> (just funny that it would be Fox all alone countering the research)
18:00:42 <dons> ?uptime
18:00:43 <lambdabot> uptime: 1d 22h 3m 10s, longest uptime: 7d 1h 24m 44s
18:00:45 <dons> ?users
18:00:46 <lambdabot> Maximum users seen in #haskell: 270, currently: 239 (88.5%), active: 36 (15.1%)
18:00:50 <dons> shapr: oh , did you see ^^
18:01:40 <shapr> whoa, 270!
18:02:17 <Lajexander> good night
18:03:42 <Korollary> Heh. http://www.somebits.com/weblog/tech/bad/whySoapSucks.html
18:03:45 <lambdabot> Title: Nelson's Weblog: tech / bad / whySoapSucks, http://tinyurl.com/ykdy32
18:03:49 <SamB> @quote dibblego
18:03:50 <lambdabot>  [in ##c] <dibblego> ?type map <SamB> no lambdabot in ##c, silly! <dibblego> I'm so used to lambdabot following me around
18:04:58 <SamB> of course, now mbot is there...
18:05:51 <int-e> haha
18:06:23 <dons> mbot is in ##c?
18:06:32 <dons> victory is at hand
18:06:59 <dons> sjanssen++ more patches!
18:07:15 <shapr> Wow, the C programming language community is starting to use tools written in Haskell. Do you think they're aware of that?
18:07:33 <dons> amazing
18:07:44 <Korollary> nobody in his right mind would write an irc bot in c anyway.
18:07:44 <dons> i wonder if they use lisppaste
18:08:00 <Smokey``> they probably use sf paste...
18:08:25 <Botty> I think they mostly use rafb, IIRC
18:08:49 <SamB> well, mbot wasn't in there until after I typed the @remember for that quote in here and Cale said that there should be a lambdabot in ##c
18:09:06 <SamB> and Baughn had said that already...
18:09:23 <dons> what's it used for?
18:09:35 <dons> and do we need a lambdabot2 now that we're over the channel limit?
18:09:43 <SamB> well, Baughn and Cale were playing with it, I think...
18:09:57 <SamB> this was earlier in my today
18:10:52 <SamB> so it isn't like many of ##c's know about it or how to use it yet. and anyway, its coolest features are all haskell-oriented
18:11:26 <pkhuong> SamB: C REPL in haskell?
18:11:36 <dons> heh
18:11:40 <Korollary> you could add cdecl-like funcitonality
18:12:17 <Korollary> iow, "our grammar blows. Help us."
18:12:43 <SamB> maybe baughn could use it to run his code-killer ;-)
18:19:35 <dufflebunk> dons: *sigh* I feel so dumb. I'm trying to use that chunk of code you gave me, and I'm passing the resulting list to map. But I keep getting an error about expected [String] not matching IO [String]. How should I use map on an IO [String]?
18:21:06 <dons> for exampel:
18:21:20 <dons> main = do
18:21:20 <dons>     f <- readFile "/etc/passwd"
18:21:20 <dons>     let s = (unlines . map reverse . lines) f
18:21:21 <dons>     putStr s
18:22:17 <dons> did you check out the tutorials page?
18:22:59 <dufflebunk> Yeah, I read through the one for C programmers yesterday and I've been going through the gentle guide today.
18:23:34 <dufflebunk> Unfortunatly they usually only give very short examples, not showing how things are supposed to go together.
18:23:37 <dons> ok, so the key thing is, whenever something is of type IO a, where 'a' is any other type, you have to be "in" the IO monad.
18:24:04 <dons> in practice, what this means is that if something has type IO a, you use <- to get its value
18:24:11 <dons> (i.e. the result of evaluating the IO action)
18:24:19 <dons> hence:  f <- readFile "/etc/passwd"
18:24:27 <dons> gives you an 'f' which is just a normal String
18:24:34 <dons> which you can then pass to anything that takes a String
18:25:24 <dons> so you'll find that since main :: IO (), you start with main = do ... something ...
18:25:39 <dons> where you'll do a bit of IO, then pass pure values down to pure haskell code
18:25:47 <dons> the IO stuff becomes a skin layer over the program
18:26:30 <dufflebunk> Oh, ok. So the IO part of the type isn't visible until outside the do stuff
18:26:58 <JohnMeacham_> what do you think the best name for the primitive# convention used by ghc, "trailing octothorpe" or "abafthash"
18:27:01 <dons> so doing IO is pretty easy: just remember to use do to open an IO block, use <- to evaluate an IO actoin, and 'return' to return values from an IO fragment of code
18:27:16 <dons> JohnMeacham_: hmm :}
18:27:32 <dons> dufflebunk: hmm, not really, maybe. depends on what you mean
18:27:41 <dons> the IO type "infects" anything that uses IO
18:28:01 <dons> so if you use a 'readFile' somewhere, it gives that expression IO type, and anything that calls that expression must be in IO too
18:28:35 <dons> the IO call taints all its users with the sticky side effecting poison :)
18:28:46 <dufflebunk> dons: Ok, thanks. I think I understand it better. I'm starting to recall stuff from Clean and it's World variable which I used a long time ago
18:29:03 <dons> (just means that you use do-notation for anything that does IO, and don't forget the 'return' at the end of an IO block)
18:29:06 <newsham> hmm.. this Kleisi thing looks like exactly what i want
18:29:14 <dons> dufflebunk: right, its similar to the World stuff
18:29:15 <newsham> kleisli rather
18:29:22 <dons> the IO monad threads the world invisibly in the background
18:29:41 <dons> sequencing the code, such that side effects occur in an imperative order
18:30:06 <dons> JohnMeacham_: so there's a conflict between # used to denote unboxed type
18:30:11 <dons> and to denote 'primitive'
18:30:32 <dons> s/conflict/distinction/
18:31:37 <JohnMeacham_> I want to support type classes for unboxed types. so you can have class UnboxedNum (a :: #) where.. jhc supports the syntax, I have not written a middle end to support it yet though.
18:32:04 <dons> sounds very nice!
18:33:07 <JohnMeacham_> jhc supports '!' as a kind, which are boxed, but strict values. so they don't have _|_ but can be passed to polymorphic functions. currently, it won't infer such types, but you can use kind annotations to get them.
18:33:08 <SamB_XP> mmm.
18:33:44 * SamB_XP wonders if GHC could do that...
18:33:50 <dons> any write up on this, JohnMeacham_?
18:33:52 <newsham> > (arr (++ ">") >>> ("<" ++)) "hi"
18:33:55 <lambdabot>  "<hi>"
18:34:01 <dons> sounds extremely useful
18:34:12 <SamB_XP> it sounds awful nice-looking
18:34:13 <dons> and so far we haven't said anything about portable unboxed types for Haskell'
18:34:31 <SamB_XP> well, I think maybe Haskell''' would be a better target
18:34:50 <dons> pity. unboxed types are something of a real-world issue, the focus of Haskell'
18:35:35 <SamB_XP> well, yes, but isn't Haskell' also focusing on more mature ideas?
18:37:11 <dons> well unboxed types have been in ghc since what 1992?
18:37:33 <SamB_XP> yeah, but portable unboxed types don't exist at all
18:37:55 * desrt notes that writing a lambdacalc interpreter in haskell "the easy way" is a lot easier than the hard way
18:37:58 <dufflebunk> woohoo! It workd.
18:39:19 <JohnMeacham_> see E/TypeCheck.hs for the current state. it only describes the kind system used in core, the one exposed to the user is somewhat more complex in order to support inference and limited kind polymorphism
18:40:51 <SamB_XP> *more* complex?
18:41:02 <SamB_XP> how... interesting.
18:44:40 <hyrax42_> ?type (>>>)
18:44:41 <lambdabot> forall (a :: * -> * -> *) d b c. (Arrow a) => a b c -> a c d -> a b d
18:45:32 <hyrax42_> is it correct to say that haskell monads are monads on the category of types?
18:47:00 <newsham> ?type ((arr return) <+> (arr return)) "test"
18:47:01 <lambdabot>   No instance for (ArrowPlus (->))
18:47:02 <lambdabot>    arising from use of `<+>' at <interactive>:1:14-16
18:49:01 <dolio> ?type ((Kleisli return) <+> (Kleisli return)) "test"
18:49:02 <lambdabot>   The function `((Kleisli return) <+> (Kleisli return))'
18:49:03 <lambdabot>   is applied to one arguments,
18:49:18 <dolio> ?type runKleisli ((Kleisli return) <+> (Kleisli return)) "test"
18:49:20 <lambdabot> forall (m :: * -> *). (ArrowPlus (Kleisli m), Monad m) => m [Char]
18:49:39 <dolio> >  runKleisli ((Kleisli return) <+> (Kleisli return)) "test"
18:49:40 <lambdabot>  add an instance declaration for (Show (m [Char]))
18:49:51 <dolio> >  runKleisli ((Kleisli return) <+> (Kleisli return)) "test" :: [[Char]]
18:49:52 <lambdabot>  ["test","test"]
18:50:09 <newsham> Kleisli return is like (arr return) ?
18:50:19 <dolio> No.
18:50:29 <dolio> Kleisli is the constructor for kleisli arrows.
18:50:50 <newsham> runKleisli ((Kleisli (++ ">")) <+> (Kleisli return)) "test"
18:50:55 <dolio> Kleisli m a b is the type of arrows a -> m b
18:50:59 <newsham> > runKleisli ((Kleisli (++ ">")) <+> (Kleisli return)) "test"
18:51:00 <lambdabot>  Couldn't match `Char' against `[Char]'
18:51:19 <newsham> > runKleisli ((Kleisli (++ ">")) <+> (Kleisli return)) ["test"]
18:51:20 <lambdabot>  Couldn't match `Char' against `[Char]'
18:52:23 <newsham> > ((arr (++ ">")) *** (arr return)) "test"
18:52:24 <lambdabot>  Couldn't match `([Char], b)' against `[Char]'
18:52:24 <dolio> arr lifts a pure function into that type, so arr return makes a -> m (n b).
18:52:39 <dolio> For some monad n.
18:52:47 <newsham> > ((arr (++ ">")) &&& (arr return)) "test"
18:52:48 <lambdabot>  add an instance declaration for (Show (m [Char]))
18:52:49 <lisppaste2> emu pasted "which Extension is this?" at http://paste.lisp.org/display/30192
18:53:13 <emu> I'm trying to figure out what to put in the "Extensions:" field to make the above msg go away.  it compiles fine with -fglasgow-exts
18:53:25 <newsham> > ((arr (++ ">")) &&& (arr ("<" ++))) "test"
18:53:26 <lambdabot>  ("test>","<test")
18:53:44 <emu> I thought it might be TypeSynonymInstances but that didn't work
18:53:49 <dolio> If you think about arrows a ~> b as a computation that takes a value of type a, and returns a value of type b, possibly using some state (or soemthingl like that), arr lifts a pure function into such a computation (which won't use any implicit state, since it's pure).
18:54:27 <newsham> hmm.. gotta run
19:02:58 <newsham> > runKleisli ((Kleisli (return . (++ ">"))) <+> (Kleisli (return . ("<" ++)))) "test" :: [String]
19:03:00 <lambdabot>  ["test>","<test"]
19:03:03 <newsham> now we're getting somewhere
19:03:17 <newsham> not exactly pretty though
19:10:10 <newsham> > let kr f = (Kleisli (return . f)) in runKleisli ((kr id) <+> (kr (++ ">")) >>> (kr id) <+> (kr ("<" ++))) "test"
19:10:11 <lambdabot>  add an instance declaration for (Show (m [Char]))
19:10:17 <newsham> > let kr f = (Kleisli (return . f)) in runKleisli ((kr id) <+> (kr (++ ">")) >>> (kr id) <+> (kr ("<" ++))) "test" :: [String]
19:10:18 <lambdabot>  ["test","<test","test>","<test>"]
19:11:15 <newsham> perfect!
19:11:16 <eviltwin_b> consider e.g. (kr $ ++ ">")
19:11:22 <eviltwin_b> to mae it a little cleaner
19:11:25 <dolio> For Kleisli, \f -> Kleisli (return . f) should be arr.
19:12:13 <newsham> > runKleisli ((arr id) <+> (arr (++ ">")) >>> (arr id) <+> (arr ("<" ++))) "test" :: [String]
19:12:15 <lambdabot>  ["test","<test","test>","<test>"]
19:12:28 <newsham> ahh, I was using arr earlier and for some reason I got it in my head that I needed to use Kleisli explicitely
19:13:11 <dolio> You need Kleisli if you already have something of type a -> m b. arr will turn (a -> b) into (a -> m b).
19:14:01 <johnnowak> a boring, practical question to be sure... i'm writing some basic image processing algorithms for a class that i'd like to display in real-time. what library for haskell is the easiest and most stable way to stick images on the screen as part of some event loop? i'm currently doing it via GLUT in C but I'm not sure if the HOpenGL libraries are well-maintained
19:14:42 <johnnowak> just displaying basic RGB interleaved matrices
19:15:33 <Botty> as far as i can tell they haven't been updated in 3 years.  Doesn't really need to be though, as hopengl is just a wrapper
19:16:37 <Botty> should be a way of loading in arbitrary image data, I don't remember how though
19:16:54 <johnnowak> thanks Botty
19:19:03 <dibblego> can you write shell scripts in haskell?
19:19:16 <dibblego> s/shell//
19:19:45 <JohnMeacham_> SamB_XP: it is really quite simple actually, I don't have to extend PTS's at all to support all of these interesting kinds and PTS's are simpler than system F to begin with IMHO.
19:20:58 <JohnMeacham_> the one exposed to the user has things like *! which can unify with any boxed kind, strict (!) or lazy (*) for instance. in core, everything has concrete types so these arn't needed.
19:21:00 <dibblego> I guess you'd just use System.system
19:22:10 <Smokey`> JohnMeacham: HOpenGL w/ GLUT (part of HOpenGL iirc) should be fine for real time display of your images...  I'd be more worried about the speed of haskell for the image processing. (personally, having tried deal with performance in haskell... it's difficult - atleast for me, who's not soo experienced with haskell)
19:22:28 <Smokey`> unless you're doing the image processing in shaders?
19:22:28 <dons> dibblego: http://haskell.org/haskellwiki/Libraries_and_tools/Operating_system#Shell
19:22:31 <lambdabot> Title: Libraries and tools/Operating system - HaskellWiki, http://tinyurl.com/wpeo9
19:22:37 <dibblego> dons, thanks
19:22:51 <Smokey`> (in which case make sure HOpenGL supports extensions... not sure if it does/doesn't)
19:22:54 <dons> (in practice, I use system wrapped as
19:22:54 <dons> run :: String -> IO ()
19:22:55 <dons> run s = do
19:22:55 <dons>     v <- system s
19:22:55 <dons>     when (v /= ExitSuccess) $ error $ s ++ ": returned non-zero status"
19:23:52 <Smokey`> I really should get around to writing an EGL implementation for haskell... would be a great learning excersize.
19:23:53 <dibblego> ok, so you do use system in the end
19:24:13 <dons> dibblego: examples: http://www.cse.unsw.edu.au/~dons/code/hwn/utils/publish.hs, http://www.cse.unsw.edu.au/~dons/code/progress/progress.hs, http://www.cse.unsw.edu.au/~dons/code/darcs-graph/Graph.hs, http://www.cse.unsw.edu.au/~dons/code/darcs-mail/Main.hs)
19:24:15 <lambdabot> http://tinyurl.com/f2wn7
19:24:19 <dibblego> dons, thanks
19:26:51 <dons> hehe "I love how every time someone finds a problem with Common Lisp, someone in the Haskell world says "Ooh, we have that problem too" and fixes it."
19:28:31 <Smokey`> dons: okay, I'm still relatively new to Haskell but want to start contributing to the community (in terms of creating/maintaining libraries), can you point me in the right direction of some of some things i'll need to understand in relation creating/distributing libraries? :)
19:28:47 <dons> yes! I can!
19:28:53 <dons> http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
19:28:56 <lambdabot> Title: How to write a Haskell program - HaskellWiki, http://tinyurl.com/yxe296
19:29:13 <dons> and
19:29:19 <dons> for libraries, http://haskell.org/haskellwiki/Library_submissions
19:29:22 <lambdabot> Title: Library submissions - HaskellWiki, http://tinyurl.com/ymprrq
19:29:46 <Smokey`> Excellent, excellent, and more execellent :)  Thanks very muchly dons :)
19:29:53 <dons> the first is advice on setting up your own project, the second is the process for contributing to the base libraries
19:30:13 <Smokey`> *nod*
19:30:49 <dons> let me know where things are too brief, and I'll fill out those sections
19:31:07 <Smokey`> sure thing.
19:35:40 <Botty> dons - why the haddock documentation.  Its a good guideline, but what about when its just a wrapper?
19:36:15 <Botty> I'd just have docs that detail the differences with the C library
19:37:42 * Botty has written most of the code for a Graphics.UI.GLFW module
19:38:07 <dons> for libraries, its a good idea (very good idea)
19:38:37 <dons> there are exceptoins I guess, but in general the haskell version will have different types, nicer interfaces and so on
19:38:40 <dons> (usually)
19:38:44 <dons> which you'll want to document
19:39:04 <Botty> true.  Other times, the original C lib was very well written :)
19:39:14 <dons> yep
19:39:30 <dons> I just quote 'ncures' man page, with some elaborations for my curses binding, for example
19:39:38 <dons> man ncurses
19:40:31 <blsecres> is that hscurses or the binding used in hmp3?
19:40:47 <dons> the one used in hmp3
19:41:02 <dons> hscurses is a different binding written by Stefan Wehr, based on the one used in riot
19:41:51 <Cale> dons: have vincenz and I been removed from the lambdabot admin list?
19:42:02 <Cale> (It doesn't look like that in the darcs source)
19:42:04 <dons> don't think so
19:42:15 <dons> double checking ...
19:42:20 <blsecres> OK, playing around with hscurses right now trying to figure out if I really want to mess with curses
19:42:24 <Cale> We couldn't get it to join a channel
19:42:26 <dons>         admins          = [
19:42:27 <dons>                 "Pseudonym",    "shapr", "vincenz",    "Igloo",
19:42:29 <dons>                 "Cale",         "dons", "TheHunter",    "musasabi", "Lemmih"
19:42:29 <dons>         ],
19:42:33 <dons> Cale: ok, that should be fixed now
19:42:38 <dons> we were over the channel limit
19:42:42 <Cale> ah
19:42:43 <dons> so i've split lambdabot into 2
19:42:54 <dons> we have lambdabot2 in the #haskell.lang channels now
19:43:00 <dons> and lambdabot everywhere else
19:43:06 <Cale> cool
19:43:08 <dons> that gives us 10 channel breathing room
19:43:23 <Cale> This is a network-wide limit?
19:43:27 <dons> blsecres: I like hmp3's binding myseful, its very small
19:43:34 <dons> but it needs to be bundled up separately
19:43:38 <dons> Cale: freenode-wide yeah
19:43:44 <dons> hence lisppaste*
19:49:02 <desrt> some clients ought to be exempted from the channel limit
19:50:20 <SamB_XP> well, consider the load on lambdabot ;-)
19:50:55 <desrt> lambdabot is tough.
19:50:59 <desrt> it has the power of lambda.
19:52:10 <SamB_XP> hmm, apparantly the folks in ##c don't appreciate the URL filter...
19:52:31 <dons> Smokey`: i've expanded on the docs with a walkthrough: http://haskell.org/haskellwiki/How_to_write_a_Haskell_program#Structure
19:52:34 <lambdabot> Title: How to write a Haskell program - HaskellWiki, http://tinyurl.com/yxe296
19:52:49 <dons> though I'll think i'll wrap that whole process up as a script that generates a new project tree automagically
19:52:57 <SamB_XP> well, one folk
19:55:08 <dolio> ?type (+++)
19:55:10 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
19:55:18 <dolio> ?type (<+>)
19:55:20 <lambdabot> forall (a :: * -> * -> *) c b. (ArrowPlus a) => a b c -> a b c -> a b c
19:56:22 <meddle> hey.. i'm rather new to haskell, and i've been digging through tutorials and documentation like mad, trying to get a better grasp of monads and monad transformers. i'm using ghc 6.6, and some of the libraries referenced in the docs (like Control.Monad.{Cont,State,Trans}) just aren't there. Where do I find these?
19:57:00 <dons> meddle: they're in the extra-libs package
19:57:29 <meddle> ah. should've looked a little harder. thanks. :)
19:57:32 <dons> which you can download and build with ghc, or should also be available in your OS' package system
19:57:44 <SamB_XP> so why don't those come with GHC again?
19:57:56 <SamB_XP> or, at least, why not the MTL?
19:58:02 <dons> distribute your cognit^h^h^h^h build system
19:58:15 <SamB_XP> ???
19:58:50 <dons> its so we can start releasing mtl updates and so on not tied to ghc releases
19:59:13 <dons> make everything a bit more losely coupled, and things can move faster
19:59:22 <Botty> hmm, why not do both?
19:59:56 <dons> anyway, we have package systems. this is what they're for :)
19:59:59 <Botty> include the latest version of mtl at packaging time for a ghc version, and just keep on releasing new mtl versions for those who care
20:00:14 <dons> you don't have gcc come bunded with every c library ever written ;)
20:00:39 <Botty> sure, but monads are almost like part of the lang
20:00:45 <dons> Botty: they are released together, core-libs and extra-libs
20:00:57 <Botty> (note, I don't even know how to use transformations)
20:01:08 <Botty> oh, cool
20:01:13 <SamB_XP> well. I think the "GHC" package should be one of them metapackages
20:01:19 <dons> yeah.
20:01:28 <dons> let the package system work out what should be bundled
20:01:38 <dons> it could add say gtk2hs or missingH or something too
20:01:52 <SamB_XP> um.
20:02:00 <SamB_XP> that sounds a little much ;-)
20:50:49 <dobblego> can I tell runghc to look for module M in ./M/M.hs?
20:52:27 <dons> is M.hs called module M.M where -- ?
20:52:40 <dons> if so, ghc will know to look there
20:52:55 <dobblego> oh I had module M where
20:52:58 <dons> if its some arbitrary src dir, you can set that in the .cabal file
20:53:15 <dons> hs-source-dirs:  M
20:53:16 <dons> for exapmle
20:53:27 <dobblego> I'm not using cabal at the moment
20:53:38 <dobblego> but I've done it with cabal before
20:53:43 <dons> dibblego: you might want to have a look at: http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
20:53:45 <lambdabot> Title: How to write a Haskell program - HaskellWiki, http://tinyurl.com/yxe296
20:53:54 <dons> i just updated it with a heap of new things
20:54:04 <dons> including a walk through with cabal, darcs and quickcheck
20:54:06 <eviltwin_b> hm, so hs-plugins blows up because Typeable.h doesn't have INSTANCE_TYPEABLE[12], just INSTANCE_TYPEABLE0.  known, or is something wrong on my box?
20:54:07 <dobblego> ok
20:54:10 <dobblego> thanks
20:54:32 <hyrax42_> d'oh I missed the answer (if any) to my question
20:54:45 <hyrax42_> haskell monads... category is types?
20:56:16 <dobblego> dons, http://rafb.net/paste/results/v3tDF265.html
20:57:02 <dons> hyrax42_: check:
20:57:03 <dons> --    /Functional Programming with Overloading and
20:57:04 <dons> --        Higher-Order Polymorphism/,
20:57:04 <dons> --      Mark P Jones (<http://www.cse.ogi.edu/~mpj/>)
20:57:04 <dons> --        Advanced School of Functional Programming, 1995.
20:57:14 <hyrax42_> dons: thanks
20:57:17 <dons> eviltwin_b: no hs-plugins with 6.6 yet
20:57:27 <dobblego> dons, that's excellent
20:57:39 <hyrax42_> I was just looking at Wadler's Monads for Funcitonal Programs (also 1995)
20:57:43 <hyrax42_> but it isn't quite what 'm after
20:58:39 <dons> hyrax42_: also http://www.haskell.org/haskellwiki/Research_papers/Monads_and_arrows#Monads
20:58:43 <lambdabot> Title: Research papers/Monads and arrows - HaskellWiki, http://tinyurl.com/yyte4n
21:00:12 <dons> ?paste
21:00:12 <lambdabot> http://paste.lisp.org/new/haskell
21:00:18 <dons> dobblego: rafb sucks . use lisppaste :)
21:00:21 <hyrax42_> hmm I already had a copy of the Mark Jones paper on my HD
21:00:24 <dobblego> of course
21:00:28 * hyrax42_ needs to organse all that
21:00:31 <hyrax42_> *organise
21:00:39 <dobblego> ?paste
21:00:39 <lambdabot> http://paste.lisp.org/new/haskell
21:01:04 <lisppaste2> dibblego pasted "runghc cannot find my module" at http://paste.lisp.org/display/30198
21:01:23 <lisppaste2> dons pasted "More stuff" at http://paste.lisp.org/display/30199
21:01:28 <dons> ^^ example
21:02:38 <dobblego> ah thanks
21:06:37 <hyrax42_> ? (1/0) == (1/0)
21:06:45 <hyrax42_> > (1/0) == (1/0)
21:06:47 <lambdabot>  True
21:06:56 <hyrax42_> > sqrt (-2)
21:06:58 <lambdabot>  NaN
21:07:08 <pkhuong> > sqrt (-2) == (1/0)
21:07:10 <lambdabot>  False
21:07:10 <hyrax42_> > (sqrt (-1)) == (sqrt (-1))
21:07:12 <lambdabot>  False
21:07:13 <pkhuong> phew :)
21:07:16 <hyrax42_> shoudl also be false
21:07:21 <hyrax42_> so it is
21:07:45 <pkhuong> > 1/0
21:07:46 <lambdabot>  Infinity
21:07:49 <pkhuong> ah...
21:07:55 <pkhuong> > (1/0) == (2/0)
21:07:56 <lambdabot>  True
21:08:13 <pkhuong> mm, not sure I like that. Should +/- Inf be comparable for equality?
21:08:24 <hyrax42_> they're just floating point values
21:08:32 <pkhuong> yeah, I guess it's sometimes useful.
21:08:34 <dons> ?check \x -> let _=x::Double (sqrt x) == (sqrt x)
21:08:35 <lambdabot>  Parse error
21:08:38 <Botty> > -1/0
21:08:39 <lambdabot>  -Infinity
21:08:42 <dons> ?check \x -> let _=x::Double in (sqrt x) == (sqrt x)
21:08:44 <lambdabot>  Falsifiable, after 1 tests: -2.6666666666666665
21:09:00 <dons> ?check \x -> let _=x::Int in (sqrt x) == (sqrt x)
21:09:01 <lambdabot>  add an instance declaration for (Floating Int)
21:09:10 <dons> ?check \x -> let _=x::Float in (sqrt x) == (sqrt x)
21:09:11 <Botty> heh
21:09:12 <lambdabot>  Falsifiable, after 0 tests: -4.0
21:09:25 <dons> > sqrt (-4.0)
21:09:26 <lambdabot>  NaN
21:09:28 <dons> :)
21:09:36 <hyrax42_> ?check \x -> let _=x::Double in x > 0 ==> (sqrt x) == (sqrt x)
21:09:38 <lambdabot>  OK, passed 500 tests.
21:09:46 <dons> ?check \x -> x > 0 ==> let _=x::Float in (sqrt x) == (sqrt x)
21:09:47 <lambdabot>  OK, passed 500 tests.
21:10:00 <hyrax42_> nothing particularly surprising
21:10:10 <hyrax42_> just wanted to check on NaN != NaN
21:10:12 <dons> > 1.1 + 2.2
21:10:14 <lambdabot>  3.3000000000000003
21:10:16 <shapr> Weird thought about lazy eval: If you write a problem simulation, lazy eval will only execute the parts of the code that you really need.
21:10:41 <shapr> I think that's a software engineering proof that lazy eval is better than strict eval for applications development.
21:10:43 <Botty> shapr - isn't that the point?
21:10:49 <hyrax42_> what you mean "problem simulation"
21:10:58 <pkhuong> shapr: only for sloppy code :p
21:11:30 <hyrax42_> ?type foldr (1+) 0
21:11:31 <lambdabot> forall b. (Num (b -> b), Num b) => [b -> b] -> b
21:11:45 <hyrax42_> ?type foldr
21:11:47 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
21:11:59 <shapr> Strict programs must either introduce explicit laziness, or they have to have more purpose specific code.
21:12:05 <hyrax42_> foldr (const (1+)) 0
21:12:19 <hyrax42_> ?type foldr (const (1+)) 0
21:12:21 <lambdabot> forall a b. (Num b) => [a] -> b
21:13:33 <hyrax42_> ?check let _= xs::[Int] in length xs == foldr (const (1+)) 0 xs
21:13:35 <lambdabot>  Not in scope: `xs'
21:13:46 <hyrax42_> ?check \xs -> let _= xs::[Int] in length xs == foldr (const (1+)) 0 xs
21:13:48 <lambdabot>  OK, passed 500 tests.
21:14:08 * hyrax42_ feels like a haskell newbie all over again
21:15:19 <shapr> hyrax42_: The most efficient use of paid programmer time is to write the most generally useful code. So you'd write a simulation for as much of the problem as possible. But laziness gives you automatic 'purpose specific' code inside generalized code.
21:15:58 <hyrax42_> hm
21:16:49 <hyrax42_> unrelated, but does anyone know the type of (==) in SML?
21:17:00 <hyrax42_> forall a. a -> a -> Bool?
21:17:41 <dons> or is there some Eq module thingy?
21:17:56 <hyrax42_> that is what I am wondering
21:19:16 <hyrax42_> what is a non-infix function that should have a restricted type but may be (completely) polymorphic in a language without type classes
21:19:22 <hyrax42_> that is likely to be in the standard lib
21:19:32 <hyrax42_> (I dunno how to get smlnj to tell me the type of (==))
21:22:32 <hyrax42_> ok I did it with a lambda
21:22:50 <hyrax42_> it tells me "Warning: calling polyEqual" and gives it type a -> a -> Bool
21:24:04 <hyrax42_> must instances always be declared/derived?
21:24:35 <hyrax42_> or is there some way to specify that *every* member of class A is a member of class B?
21:24:45 <hyrax42_> *also a member of
21:25:24 <dons> class B a => A a where ...
21:25:55 <dons> consider:
21:25:56 <dons> class  (Eq a) => Ord a  where
21:25:56 <dons>     compare      :: a -> a -> Ordering
21:25:56 <dons>     (<), (<=), (>), (>=) :: a -> a -> Bool
21:26:37 <hyrax42_> yes, but the implementatio of compare must be given for each type
21:26:47 <hyrax42_> as well as the instance declaration
21:27:26 <hyrax42_> if there is some default implementation of all methods of class B, could you just write
21:27:36 <hyrax42_> class (A a) => B a where
21:27:49 <hyrax42_> method :: ...
21:27:52 <hyrax42_> method = ...
21:28:12 <dolio> You can do "instance B a => A a where ..." (possibly with a glasgow flag).
21:28:18 <hyrax42_> aaaahh
21:28:22 <dolio> But that will preclude you from declaring any other instances of A.
21:28:35 <hyrax42_> really?
21:28:56 <dolio> Yeah.
21:29:06 <dolio> It can cause problems if you think about it.
21:29:06 <hyrax42_> even for types not in B?
21:29:25 <dolio> Suppose you also did "instance C a => A a where ..." and there was overlap between C and B.
21:29:45 <dolio> And members of classes can change with imports and such.
21:29:48 <hyrax42_> ohh right
21:29:58 <hyrax42_> actually I knew all this
21:30:10 <hyrax42_> since I was using fallow-overlapping-instances not too long ago
21:30:14 <hyrax42_> to see what its limitations were
21:30:25 <hyrax42_> well not really
21:30:28 <hyrax42_> just poking around
21:30:31 <dolio> Yeah, not even that lets you do it, in my experience.
21:30:44 <hyrax42_> hrm
21:30:46 <hyrax42_> kk
21:32:12 <dolio> Actually... I may be misremembering...
21:32:27 <dolio> I think my particular example of it not working had a fundep, as well.
21:32:42 <dolio> So maybe if you don't have fundeps in there, you can do it. I'm not sure.
21:32:54 <hyrax42_> I can't remember exactly what I was doing :/
21:33:02 <hyrax42_> I used fundeps at some point in the same exercise
21:33:20 <hyrax42_> I was trying to make a stupidly parametric finite automaton
21:33:55 <hyrax42_> which was parametric over a state container monad, so that deterministic and non-deterministic automata could use the same code
21:34:27 <dolio> Ah.
21:34:47 <hyrax42_> yea, it was mostly useless
22:04:46 <dobblego> ?hoogle Eq a => a -> a -> [a] -> [a]
22:04:48 <lambdabot> No matches, try a more general search
22:05:14 <dobblego> is there a "replace all occurrences of x with y"?
22:05:38 <dobblego> ?hoogle Eq a => [a] -> [a] -> [[a]] -> [[a]]
22:05:39 <lambdabot> No matches, try a more general search
22:06:00 <dons> > map (\c -> case c of 'x' -> 'y' ; _ -> c) "haskexkelxx"
22:06:01 <lambdabot>  "haskeykelyy"
22:06:23 <dobblego> mk ta :)
22:06:58 <dons> sjanssen: submitted your fasta entry, https://alioth.debian.org/tracker/index.php?func=detail&aid=304147&group_id=30402&atid=411646
22:06:59 <lambdabot> http://tinyurl.com/y358h6
22:07:19 <dons> (with a couple of small tweaks, one just to make the pack/packAddress rule fire)
22:08:24 <dobblego> if the replace was all "xx" with "yy" would I do a similar thing but with elemIndex?
22:11:51 <hyrax42_> dons: I finally got to the "relevant" part of that paper!
22:12:00 <hyrax42_> functional programming with banans and lenses
22:13:44 <hyrax42_> hmmm data types as fixed points of functors
22:13:52 <hyrax42_> that fits with what I was thinking
22:14:05 <dobblego> ?hoogle Eq a => [a] -> [a] -> Bool
22:14:06 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
22:14:06 <lambdabot> List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
22:14:15 <hyrax42_> all
22:14:16 <hyrax42_> any
22:14:21 <hyrax42_> oh wait
22:14:26 <hyrax42_> d'oh
22:14:43 <hyrax42_> those are the ... -> [a] -> Bool functiosn I always forget anyway
22:14:50 <dons> today's link, http://programming.reddit.com/info/rj6l/details
22:14:53 <lambdabot> Title: Modular type classes: Haskell type classes as a particular use of ML modules (re ..., http://tinyurl.com/y6a6po
22:15:14 <hyrax42_> there's a daily link quota?
22:15:19 <dons> :)
22:15:41 <hyrax42_> the ecology at reddit is rather interesting
22:16:24 <hyrax42_> which mostly goes back to its starting as a lisp project, as far as I can think, anyway
22:16:38 <dons> yep
22:16:58 <dons> that's it I think. and a good effort by the lisp, haskell, erlang ... people to keep it at some reasonable quality
22:16:59 <hyrax42_> of course, lisp has sort of faded since then, as a topic of interest to redditors
22:17:12 <dons> still you see lots of lisp stories
22:17:16 <hyrax42_> but non-mainstream languages are quite of interest
22:17:22 <hyrax42_> yeah there was a clump in the last 2-3 days
22:17:37 <dons> yeah i think gizmo submitted like 5 :)
22:17:45 <dons> (bad karma doing that)
22:17:55 <hyrax42_> but whoever it was who posted that thing "5 minutes coding is worth 5 hours reading blog posts" was spot on
22:18:03 <hyrax42_> I read a *tonne* about haskell before trying it out
22:18:14 <dons> since we've got a 20 year back catalogue of haskell stories too, I think its more sensible to just put up one story daily
22:18:17 <hyrax42_> and I realise now I learned pretty much nothing in that time
22:18:23 <dons> you have to write code
22:18:45 <hyrax42_> exactly, at most or at least one a day
22:18:46 <hyrax42_> ?
22:18:53 <dons> yeah, once a day at least
22:18:56 <dons> I try to do that.
22:19:15 <hyrax42_> well if I can get myself together, I might write somethign up about doing my AI class project in haskell
22:19:18 <dons> and do all the exercises people post here
22:19:23 * hyrax42_ really needs to get back to that
22:19:25 <dons> yeah, that'd be cool
22:19:35 <hyrax42_> otherwise I won't win the competition!
22:19:54 <lisppaste2> dibblego pasted "comments? efficiency? style?" at http://paste.lisp.org/display/30205
22:20:06 <hyrax42_> what's on my side is that the recommended way of doing it in Java (the "supported" language) is stupid
22:20:25 <hyrax42_> taking no advantage at all of easy mutable state
22:20:35 <dons> looking dibblego
22:20:47 <hyrax42_> so I get all the benefits of lazy evaluation and at no performance cost compared to my peers
22:20:49 <dobblego> I think I prefer if/then/else to guards
22:21:17 <hyrax42_> in fact, even a performance advantage, since there is less overhead at runtime I think using haskell types than java objects
22:21:18 <dobblego> hyrax42, I have written a Java API (lists, arrays, etc.) without using the = opeator
22:21:45 <hyrax42_> hehe
22:21:48 <dobblego> let me get a snippet for you :)
22:22:48 <dons> guards are nicer once you have >= 3 branches
22:23:07 <lisppaste2> dibblego pasted "the non-base-case (name?) for the equivalent of inits" at http://paste.lisp.org/display/30206
22:23:18 <dobblego> yeah I agree
22:23:28 <hyrax42_> dobblego: MY EUESYS!@
22:23:47 <hyrax42_> it's great how generics are suddenly useful once they get added to Java
22:23:52 <dobblego> hyrax42, if that were expanded, you'd see the map function as well :)
22:24:14 <hyrax42_> sheeesh
22:24:20 <hyrax42_> what was this an exercise in?
22:24:27 <hyrax42_> patience?
22:24:31 <dobblego> trying to salvage Java
22:24:43 <hyrax42_> "salvage"?
22:24:55 <dobblego> yes, make it work - write "software" with it
22:25:15 <dobblego> it does work for what it's worth
22:25:27 <hyrax42_> 17.5 quadrillion people would say it works, and that they can write "software" in it as is
22:25:36 <dobblego> it is also to close the gap for the leap from Java to something like Haskell
22:25:40 <hyrax42_> do you actually use this?
22:25:42 <dobblego> I know they'd say that
22:25:44 <dobblego> yes I do
22:25:52 <hyrax42_> for real purposes?
22:26:02 <dobblego> I hold that those gazillion people are in contradiction
22:26:04 <dobblego> yes
22:26:18 <hyrax42_> for self or other?
22:26:22 <dobblego> it is far better than the core API
22:26:34 <dobblego> myself and a couple of colleague
22:26:34 <dobblego> s
22:26:37 <hyrax42_> but it must perform like a dog?
22:26:44 <dobblego> but, it is not tried and tested yet
22:26:55 <dobblego> that's the bit I don't know yet :)
22:27:00 <hyrax42_> just port quickcheck to java
22:27:02 <hyrax42_> no problems
22:27:04 <hyrax42_> ;)
22:27:07 <dobblego> yep, that's the next step
22:27:17 <dobblego> first I have to write a state monad
22:27:27 <hyrax42_> public class List<T> implements Arbitrary {
22:27:28 <hyrax42_> ....
22:27:31 <hyrax42_> }
22:27:55 <hyrax42_> of curiosity, what do you and your colleagues do with it?
22:28:03 <lisppaste2> dons annotated #30205 with "guards, quickcheck" at http://paste.lisp.org/display/30205#1
22:28:13 <dons> dobblego: ^^ with bonus QuickCheck property ;)
22:28:24 <dobblego> hyrax42, J2EE gunk
22:28:25 <dobblego> thanks dons
22:29:01 <dobblego> dons, the only change is s/if then else/guards?
22:29:05 <dons> yup
22:29:09 <dobblego> ok cool
22:29:15 <dons> far more library-style to use guards there
22:29:19 <hyrax42_> now you translate that to java?
22:29:20 <hyrax42_> ;)
22:29:48 <dons> dobblego: you might try to think of some other QuickCheck properties of the code
22:29:49 <dobblego> hyrax42, I don't use type-classes for the Java equivalent :), I'd write it as (a -> a -> Bool) -> [a] -> [a] -> [a]
22:29:51 <dobblego> -> [a]
22:30:14 <dobblego> dons, I'll just try to understand what you did first :)
22:30:33 <hyrax42_> where funcitonal types are wrapped up in different classes depending on how many arguments they have?
22:30:49 <dons> oh, just some boilerplate , and one simple property that I thought of:
22:30:50 <dons>     length xs == length ys ==>
22:30:50 <dons>         length (replaceAll xs ys zs) == length zs
22:31:04 <dobblego> ?type (==>)
22:31:06 <lambdabot> Not in scope: `==>'
22:31:08 <dons> if the args are the same length, the string length after replacement should be the same as when it started
22:31:25 <dons> ?type (Test.QuickCheck.==>)
22:31:27 <lambdabot> forall a. (Test.QuickCheck.Testable a) => Bool -> a -> Test.QuickCheck.Property
22:31:39 <dobblego> oh right
22:31:40 <dons> its an implication
22:32:10 <dobblego> an implication as in predicate logic?
22:32:11 <dons> now you can blog about how hard it would be to write this function in java, along with automated testing of it
22:32:20 <dobblego> no thanks
22:32:35 <dons> that's the metaphor. you're stating a property: if length xs == length ys then length (replaceAll xs ys zs) == length zs is true
22:32:50 <dons> which quickcheck then goes and try to establish
22:32:50 <dobblego> ah I see it
22:33:05 <dons> well, it tries to find counter examples, anyway
22:33:13 <hyrax42_> hold on
22:33:14 <dons> and if you have exhaustion, you've got a proof
22:33:22 <hyrax42_> datatypes as fixed points of functors
22:33:24 <dobblego> yeah I understand that
22:33:36 <hyrax42_> (sorry category theory diversion from the category theory newb)
22:33:49 <hyrax42_> say we have just one "base type" X
22:34:14 <hyrax42_> and a type constructor M :: * -> *
22:34:45 <hyrax42_> the fixed point is {X, M(X), M(M(X)), ...}
22:34:46 <hyrax42_> right?
22:35:19 <hyrax42_> but what is the corresponding mapping M(f) where f : X -> X
22:35:40 <hyrax42_> to make M a functor
22:35:43 <hyrax42_> or am I waaay off here
22:36:03 <dobblego> I didn't intend to explicitly state that writing Maybe in Java was hard; it was the subliminal message :)
22:36:24 <hyrax42_> did you post that to reddit at some point?
22:36:28 <dobblego> yes
22:36:31 <hyrax42_> ok
22:36:36 <Cale> dobblego: have you looked at Scala?
22:36:43 <dobblego> Cale, no, but it's on my list
22:36:57 <Cale> It's somewhere halfway in between Java and Haskell :)
22:37:10 <dobblego> yeah so I've heard - I really should some time
22:38:36 <dobblego> writing these scripts where every function returns IO () makes it clear why people have a tendency to write "imperative" code with haskell if they are not disciplined
22:39:30 <Cale> Well, the one thing which puts an end to that pretty quickly is the realisation that you can call non-IO things from IO things.
22:43:51 <hyrax42_> ahhhh it seems maybe Moggi's paper is what I wanted
22:44:09 <hyrax42_> though it is a bit more in the category theory than I am comfortable with at this point
22:44:38 <hyrax42_> but it's *REALLY* nice to see that my intuitions on certain things are correct
22:44:45 <hyrax42_> given my shakey category theory grounds
22:45:16 <hyrax42_> anyway, I'll have to read these things over the holidays or something
22:45:21 <hyrax42_> crunch time approaches
22:48:15 <eviltwin_b> anothrer way to break yourself of it is to use >>= directly instead of do{} in simple cases :)
22:56:48 <psykotic> hyrax: moggi's papers are the best place to understand computational monads if you aren't afraid of a little math, imo.
22:58:58 * psykotic is getting really tired of the millions of papers that purport to give an understanding of monads by analogies with monsters/spacemen/whatever :)
22:59:11 <Botty> lol
22:59:22 <Botty> what's especially funny is they all copy from eachother
22:59:29 <Botty> text, even diagrams
23:00:27 <dons> psykotic: i think we might have reached a critical point in fact. i suspect the number of new monad tutorials will trend downwards -- everyone gets them now
23:00:43 <dons> i don't think we need more tutorials on them, anyway
23:01:05 <Eidolos> I still don't get monads. :)
23:01:29 * dobblego hands Eidolos some acid and a spaceman book
23:01:34 <Eidolos> :D
23:01:44 <dons> > runState (do x <- get ; put (x^2) ; return "foo") 7 -- side effects in a back channel
23:01:46 <lambdabot>  ("foo",49)
23:02:10 <pkhuong> Eidolos: implement them in another language :)
23:02:14 <dons> encapsulate your effects .. now!
23:02:17 <Eidolos> I do get the point of them, that they're a way of sneaking side effects like IO into a pure language, but I don't see _how_ they work.
23:02:40 <dons> not sneaking! common misconceptoin
23:02:51 <Eidolos> :)
23:03:01 <pkhuong> Eidolos: imo, they're like continuations. You can hear the same explanations a thousand times, but it's not good until you get an Eureka!.
23:03:07 <dobblego> it's just a different view of the same world
23:03:08 <pkhuong> s/not/no/
23:03:36 <dons> see http://programming.reddit.com/info/ox6s/comments/coxiv and http://programming.reddit.com/info/ox6s/comments/coxoh
23:03:39 <lambdabot> Title: Ask Reddit: What the hell are monads? (reddit.com), http://tinyurl.com/y23zcc
23:03:41 <psykotic> dons: we don't need more tutorials, we just need one good one. :)
23:03:41 <Eidolos> I'll get it someday, I'll just keep reading them tutorials. :)
23:03:49 <dons> pkhuong: yeah, i agree. they're like continuations
23:04:02 <dons> so expect ruby to be struggling to add them to ruby 3.0 in 15 years time
23:04:03 <psykotic> if i had to give someone three sources to read for a good understanding of monads i'd say moggi, wadler and sigfpe's blog :)
23:04:10 * eviltwin_b thinks of them as a way to build up functional composition one piece at a time
23:04:33 <pkhuong> dons: and, like continuations, implementing them yourself often triggers the eureka :)
23:04:34 <eviltwin_b> >>= being the "append a new composition to the chain" operator
23:04:38 <Smokey`> Eidolos: if it makes you feel any better, I don't get monads either :)
23:04:55 <eviltwin_b> er, a neew function
23:04:56 <dons> pkhuong: right. its like a lot of skills: you have to use them to understand them
23:05:39 <pkhuong> dons: Using the State monad probably isn't as enlightening as implementing it.
23:05:42 <dons> so, your homework for today *everyone* is to hand in a custom monad by 9am tomorrow. ;)
23:05:55 <dons> less talk, more code!
23:06:00 <dons> pkhuong: yeah.
23:06:03 * eviltwin_b plans to go to bed soon and will probably wake up past 9am local :>
23:06:11 <dons> it looks like magic till you roll your own.
23:06:14 * eviltwin_b should probably have gone to bed an hour ago :/
23:06:24 <pkhuong> yeah, and then it seems almost obvious. :\
23:07:08 <eviltwin_b> it's all magic.  my mom had the same problem with basic algebra :)
23:07:10 <dons> ?quote Baughn
23:07:12 <lambdabot>  I think I'm beginning to understand this language. I just defined 1+1=3.
23:07:15 <dons> ?quote Baughn
23:07:16 <lambdabot>  I think I'm beginning to understand this language. I just defined 1+1=3.
23:07:34 <Smokey`> oh yeah, I can see myself doing that... considering I dont even know what a monad is supposed to do... (i realise it's aclass, and it has a a bind function, and a return function... and binding one monad to a function, passes it's result to the function... or 'something', but I dont see a huge point except the fact you know the limits of said monad (but that's the same with every class), and I'm trailing off and off into the weird depths 
23:07:36 <dons> ?remember Baughn I once explained monads to a non-programmer: 'And? What's so hard about that?'
23:07:45 * Smokey` 's brain explodes just trying to think
23:09:35 <pkhuong> dons: well, that's almost the reaction my gf (BA in anthropology) had :\
23:09:53 <psykotic> is anyone here very familiar with godel's construction of first-order logic inside PA?
23:11:04 <dobblego> Germans/Austrians get mad if you say Godel
23:11:13 <dobblego> Goedel or Go (umlaut) del
23:11:18 <psykotic> goedel then. i don't have umlauts on this keyboard.
23:11:25 <dobblego> me neither :) so use oe
23:13:30 <dobblego> ?hoogle [([a], [a])] -> [a] -> [a]
23:13:31 <lambdabot> No matches, try a more general search
23:14:57 <psykotic> ?unzip2
23:14:58 <lambdabot> Unknown command, try @list
23:15:01 <psykotic> ?type unzip2
23:15:02 <lambdabot> Not in scope: `unzip2'
23:15:43 <psykotic> dobblego, i think the natural inhabitant of that type is an unzip followed by a concat in each component
23:15:59 <dobblego> I'm trying to write a better replace function
23:16:02 <pkhuong> psykotic: it's -> [a] -> [a], not -> ([a], [a])
23:16:16 <psykotic> oh doh
23:16:16 <dobblego> Eq a => [([a], [a])] -> [a] -> [a]
23:16:24 <pkhuong> psykotic: made the same mistake at first :)
23:16:45 <dobblego> replace [("aa", "AA"), ("bb", "BB")] "abcaabbcaabaanbb" == "abcAABBcAAbAAnBB"
23:17:22 <dobblego> I'm sure it's one of those funky functions that I need
23:18:56 <psykotic> ?hoogle (a -> b) -> (a, a) -> (b, b)
23:18:57 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
23:19:11 <hyrax42_> psykotic: (jumping up a bit) not afraid of a little maths, no
23:19:34 <hyrax42_> I just have no experience with category theory, and don't have the tiem to fill that in just now
23:19:42 <psykotic> wtf, that's a pretty odd place to find that function
23:20:30 <psykotic> hyrax42, you don't really need anything for moggi's papers if you aren't too interested in the technical details and have at least a vague notion of what a category is
23:20:41 <hyrax42_> isn't it just ($) *** ($)?
23:20:48 <hyrax42_> or no
23:20:51 <hyrax42_> not even
23:20:56 <dons> ?type (($) *** ($))
23:20:57 <hyrax42_> just ***?
23:20:58 <lambdabot> forall a b a1 b1. (a -> b, a1 -> b1) -> (a -> b, a1 -> b1)
23:21:05 <mauke> ?type id***id
23:21:07 <lambdabot> forall b b'. (b, b') -> (b, b')
23:21:15 <dons> ?djinn (a -> b, a1 -> b1) -> (a -> b, a1 -> b1)
23:21:16 <lambdabot> f a = a
23:21:23 <dons> heh
23:21:40 <psykotic> i just want to lift a function to a function on pairs, is that asking too much? :)
23:21:48 <dons> ?djinn (a -> b) -> (c -> d) -> (a, c) -> (b, d)
23:21:49 <lambdabot> f a b (c, d) = (a c, b d)
23:22:06 <hyrax42_> stuff from Arrow is good for that often
23:22:10 <hyrax42_> Control.Arrow
23:22:15 <dons> psykotic: that's what Arrow is for ;) tuple hacking
23:22:25 <dons> ?plf a b (c, d) = (a c, b d)
23:22:26 <lambdabot> a = fix (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .))
23:22:37 <mauke> @pl \f (x, y) -> (f x, f y)
23:22:38 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
23:22:43 <dons> ?pl f a b (c, d) = (a c, b d)
23:22:44 <lambdabot> f = flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
23:22:56 <hyrax42_> ?type length *** length
23:22:57 <lambdabot> forall a a1. ([a], [a1]) -> (Int, Int)
23:23:16 <psykotic> ?type (***)
23:23:17 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
23:23:35 <hyrax42_> instances-importing Control.Arrow Arrow
23:23:43 <hyrax42_> ?instances-importing Control.Arrow Arrow
23:23:43 <dons> ?docs Control.Arrow
23:23:44 <lambdabot> (->), Kleisli m
23:23:45 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html
23:23:50 <hyrax42_> there is a function instance
23:24:07 <hyrax42_> lots of fun to be had
23:24:10 <mauke> ?type join (***)
23:24:11 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
23:24:19 <hyrax42_> precisely
23:24:23 <psykotic> hyrax42, btw regarding the functor stuff you asked about earlier. in general there isn't a unique way to associate a functor to a "bare" type constructor.
23:24:49 <hyrax42_> then why does Mark Jones speak of types being defined as the fixed point of functors
23:25:09 <psykotic> you mean algebraic data types?
23:25:13 <hyrax42_> hm depends on the meaning of "bare" I assume
23:25:14 <hyrax42_> I don't know
23:25:15 <hyrax42_> he says
23:25:16 <hyrax42_> datatypes
23:25:26 <hyrax42_> or lemme see the sentence exaclty
23:25:53 <psykotic> usually they are defined via initial algebra semantics. you have a functor F, and you have a notion of an F-algebra, and the "natural" data type associated with F is the initial F-algebra.
23:25:57 <hyrax42_> "These ideas have already been
23:25:57 <hyrax42_> widely studied from a categorical perspective where datatypes are constructed as
23:25:58 <hyrax42_> fixed points of functors."
23:26:23 <hyrax42_> eugh more words I don't know
23:26:31 <psykotic> right, i'm pretty sure he's talking about algebraic data types. the idea is quite simple. think about something like defining a language via a context-free grammar.
23:26:33 <hyrax42_> F-algebra
23:27:22 <hyrax42_> well what I'm missing is that a functor requires a mapping of objects (types?) and arrows (functiosn?)
23:27:27 <psykotic> so a language is a set of strings over some alphabet. a context-free grammar is a specification of a language. so the question is how to associate a language with a CFG.
23:27:35 <hyrax42_> but a type constructor in haskell does not require the second
23:27:57 <psykotic> and usually that's done by taking an "inductive closure" with respect to a set of closure operators, each one corresponding to a production of the language.
23:28:01 <psykotic> err, a production of the CFG.
23:28:55 <psykotic> hyrax42, well, here's the idea. suppose you have the list data type. data List a = Empty | Cons a (List a).
23:29:07 <hyrax42_> I guess my problem is my notion of a lot of these things is built up intiutionally from using haskell
23:29:11 <lisppaste2> dibblego pasted "what am I doing wrong?" at http://paste.lisp.org/display/30209
23:29:14 <hyrax42_> it took me a while to "spot the monad"
23:29:26 <hyrax42_> psykotic: ok
23:29:41 <hyrax42_> consider it supposed
23:29:45 <psykotic> hehe
23:31:03 <hyrax42_> are we doing something with the supposition?
23:31:09 <hyrax42_> otherwise I'll just optimise it to _
23:31:33 <psykotic> well, i was trying to write something up that would be useful, but you seem more interested in being an ass.
23:31:35 <pkhuong> hyrax42: i think he's trying to write a \mu in irc.
23:31:53 <hyrax42_> oh it was meant in jest
23:31:58 <hyrax42_> I'm sorry
23:32:15 <hyrax42_> I was about to say that the silence indicates somehting is comming
23:32:16 <psykotic> no worries
23:32:17 <hyrax42_> coming
23:33:28 * hyrax42_ is unsure of current status of conversation :(
23:34:22 <psykotic> okay, so let's say we fix the "element type" a to some specific A. we have an associated functor F = Id + A * X.
23:34:47 <hyrax42_> ok slowly what is the + and *
23:34:59 <hyrax42_> and the Id for that matter
23:35:58 <psykotic> + and * are sum and product in the category we're working in. Id is the identity functor. actually maybe working in the categorical setting isn't the most useful thing to do. the CFG example might be more useful to get an idea of how recursively defined objects can be constructed via fixed points, if that's the point you're shaky on.
23:36:57 <hyrax42_> well I can see how recursively defined objects can be defined via fixed points
23:37:08 <psykotic> not just defined, but constructed.
23:37:26 <hyrax42_> but my problem is with the defintion of functor and of type constructors
23:37:39 <hyrax42_> it seems to me that a functor requires a mapping of the arrows as well as the objects
23:37:45 <hyrax42_> but type constructors don't do that
23:38:01 <hyrax42_> unless I'm mistaken to think that the arrows are functions
23:38:05 <psykotic> right, and it does. if you're just given a map between types (a type constructor) you don't necessarily have a naturally associated map between functions.
23:38:48 <hyrax42_> then how can one say something like "datatypes are fixed points of functors" without that map between functions
23:38:58 <hyrax42_> *in general
23:39:06 <psykotic> the idea in the initial algebra approach to data types is that the functor we're talking about describes the "shape" of the data type.
23:39:41 <psykotic> so when i wrote down that crazy thing with + and * and Id the idea was that the shape should look similar to my data List a = Empty | Cons a (List a) thing
23:39:44 * hyrax42_ is thinking of this differentiating datatypes mumbo jumbo he's glanced at *ever* so briefly
23:40:46 <hyrax42_> and to be clear, I don't mean mumbo jumbo in a derogatory way, just to indicate that I do not understand it
23:41:36 <psykotic> well, so getting back to the functor. the object/type part of the functor isn't the type constructor for the data type.
23:41:53 <psykotic> that's merely the _specification_ of the data type. we have to "pump" that specification to get the limit, which is the data type.
23:42:02 <hyrax42_> hmm
23:42:35 <dobblego> any hints about what I am doing wrong?
23:42:48 <hyrax42_> foldr (union.apply) {base types}
23:42:48 <psykotic> if you're somewhat familiar with domain theory, the idea is that if we have a partially defined data type corresponding to a functor F then we can apply F to it to get a "more defined" data type.
23:42:49 <hyrax42_> ?
23:43:19 <dobblego> I can see why it is wrong, but I can't see how I should fix it
23:43:21 <hyrax42_> or no that's just bad in too many ways
23:43:24 <dobblego> http://paste.lisp.org/display/30209
23:44:21 <hyrax42_> I am doing a class on domain theory next term
23:44:33 <hyrax42_> I suppose really I should just let this sit not-quite-understood
23:44:48 <hyrax42_> and wait till I have a firmer grasp on the underlying structures
23:44:48 <psykotic> so... suppose we starte with the totally undefined data type which we might call Undef. we can apply F once to get Id + A * Undef. if we apply F to this we get Id + A * (Id + A * Undef) = Id + A* Id + A * A * Undef. If we apply F to this we get Id + A * (Id + A * Id + A * A * Undef) = Id + A * Id + A * A * Id + A * A * A * Undef.
23:44:55 <hyrax42_> oooh
23:45:14 <hyrax42_> coinduction?
23:45:15 <psykotic> so you can get see that by "pumping" this F we get lists of longer and longer lengths.
23:45:29 <psykotic> and the intuition is that in the limit we get the data type of actual arbitrary-length lists.
23:45:59 <psykotic> and this limit is a fixed-point of F.
23:46:39 <hyrax42_> could that be described as coinduction? since we are taking the intersection of all these sets, yes?
23:46:59 <psykotic> why? because suppose X is the data type of lists of A's. then applying F to it we get Id + A * X. But this is equal to X because a list is either empty (Id) or an A and another list (the X--the tail).
23:47:02 <psykotic> yeah.
23:47:12 <MP0> hmm, I'm calling compiled scheme bytecode from java... do I get to ++ java now?
23:47:24 <pkhuong> ++kawa ;)
23:47:43 <psykotic> isn't SISC nicer? :)
23:48:02 <pkhuong> i have no idea. I only use java for school.
23:48:35 <MP0> I don't know, I'm using kawa as you correctly guessed.
23:48:50 <MP0> I wish the compiled .class files were more self-contained
23:49:04 <hyrax42_> psykotic: 'm still failing to see the "arrows to arrows" part of F
23:49:11 <hyrax42_> unless that is allowed to be partial
23:49:16 <hyrax42_> which you sort of alluded to
23:49:26 <MP0> SISC says it uses "interpretation techniques" ... I don't think that's in the same league as kawa
23:49:26 <hyrax42_> or didn't
23:51:32 <hyrax42_> psykotic: thanks for the explanations
23:52:15 <hyrax42_> things are... a little less unclear
23:52:20 <psykotic> hyrax42, sorry i'm trying to clear some things up, since you're now getting me confused too :)
23:52:32 <hyrax42_> but what is clear is I should get a handle on the underlying things first
23:52:39 <hyrax42_> oh sorry
23:53:03 <psykotic> hehe
23:53:06 <hyrax42_> well like I said I have an intuitional understanding of these structures from using haskell
23:53:16 <hyrax42_> I didn't know "where" the monad was
23:53:18 <hyrax42_> until last week
23:53:47 <hyrax42_> so probably a lot of the other things are at least as shaky
23:54:18 <hyrax42_> anyway, I have a prof who likes this stuff (category theory, domain theory &c.) who I can pester
23:54:29 <hyrax42_> instead of the populace of #haskell
23:54:36 <hyrax42_> :p
