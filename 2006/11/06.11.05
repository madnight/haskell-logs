00:00:27 <Botty> (lists of possible errors, the exact text returned)
00:00:36 <pzpz> dons: yah, any idea of how it's implemented ?
00:00:50 <dons> > M.fromList [(1,'a'), (2,'b'), (3,'c')]
00:00:52 <lambdabot>  {1:='a',2:='b',3:='c'}
00:00:53 <Lemmih> ?source Data.Map
00:00:53 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
00:01:05 <pzpz> oh, that's nifty.
00:01:12 <Botty> Clearly the compiler knows what's wrong, otherwise the error wouldn't be returned, so why can't it just tell you that a backslash isn't escaped?
00:01:32 <dons> > M.lookup 2 ( M.fromList [(1,'a'), (2,'b'), (3,'c')] ) :: Maybe Char
00:01:33 <lambdabot>  Just 'b'
00:01:42 <dons> > M.lookup 10 ( M.fromList [(1,'a'), (2,'b'), (3,'c')] ) :: Maybe Char
00:01:44 <lambdabot>  Nothing
00:01:45 <pzpz> Botty: because then it would be too useful :)
00:01:47 <Botty> better yet, tell you either a backslash isn't escaped or the character following the backslash is not a valid escape sequence
00:01:54 <Botty> yeah...
00:02:31 <dons> Botty: if you think there's a better error that could be reported, that's quite possibly true. a patch is the best suggestion, otherwise a test program and the example, confusing output, along with a better suggested output, is the appropriate step  to take
00:03:10 <dons> n.b everyone, HCAR submissions due tomorrow!
00:03:17 <pzpz> any solution for a noisy laptop fan?
00:03:27 <dons> if you've written in haskell project in the last 6 months, let kosmikus know.
00:03:32 <dons> pzpz: a hammer?
00:03:34 <Botty> well, this one isn't that bad.  One problem is that you don't want to make messages too verbose
00:03:37 <dons> or disconect the fan?
00:03:52 <pzpz> dons: it's the only fan. :\
00:03:57 <Botty> pzpz: liquid cooling ;P
00:04:03 <dons> turn down the cpu?
00:04:15 <dons> my fan tends to switch off if i clock it down to 600 MHz
00:04:37 <pzpz> that's a slow solution :(
00:04:51 <dons> but yeah, physically cooling the device might be a good idea
00:04:56 <dons> let the air circulate around it
00:04:57 <Botty> right a little util to throttle the cpu when the fan turns on
00:05:14 <pzpz> torquing my chasis seems to work. but I'm sure it's introducing sideeffects.
00:05:32 <Botty> yes, you need to keep your methods pure
00:06:29 <pzpz> Data.map uses treees
00:07:23 <pzpz> logn is far too slow!
00:08:00 <EvilRanter> ...
00:09:04 <dons> pzpz: are you sure?
00:09:09 <Botty> yikes
00:09:28 <dons> what application are you writing? what's the use case?
00:09:29 <Botty> then again, i dunno how a haskell hashing algo would be done
00:09:38 <dons> hashing is pure, so that's not too hard
00:09:42 <dons> ?hoogle hash
00:09:44 <lambdabot> Data.HashTable.hashInt :: Int -> Int32
00:09:44 <lambdabot> Data.HashTable.hashString :: String -> Int32
00:09:44 <lambdabot> Data.Unique.hashUnique :: Unique -> Int
00:10:05 <Botty> sure, but you can only hash those 3
00:10:09 <Botty> or wait
00:10:11 <Botty> lol
00:10:13 <pzpz> dons: oh, i'm just being sarcastic. a tree would easily be sufficient for what i'm writing.
00:10:14 <dons> IntMap is also better if you have Int keys
00:10:15 <Botty> well, probably others
00:10:18 <dons> pzpz: :)
00:10:20 <Botty> but its not a class
00:10:35 <dons> I wasn't sure, I was thinking "maybe he's being sarcastic" ,, but had to check ;)
00:10:40 <pzpz> i could get away with o(n^2)
00:11:11 <pzpz> i'm implementing a im server/client that no one will ever use.
00:11:12 <dons> see sometimes we get people who really do think log n will be a killer for their little toy app used in their uni assignments...
00:11:17 <dons> and they're using hugs or some such anyway ..
00:11:29 <dons> right. log n forever!
00:11:39 <pzpz> logn is pretty quick :)
00:11:41 <dons> pzpz: but if its good, we might use it...
00:12:23 <pzpz> dons: against the like of jabber? mebbe. but I'd have to do a complete rewrite by the time I'm able to write more-usable haskell code.
00:12:41 <Botty> uh, O(1) forever!
00:15:03 <Botty> dons - by doing hashing in haskell, i was thinking about the catchall hashing implemented in many languages, which does some hashing on the internal representation when there is no better method
00:15:45 <Lemmih> We have StableName for that.
00:15:45 <Botty> kinda like deriving Hashable (just made that up, i think)
00:16:01 <dons> yeah, you can do that if you really want
00:16:20 <Botty> oh, cool
00:20:25 <pzpz> anyone care to give opinions/methods for handling/modifying a global variable (such as a table holding connections)
00:20:48 <pzpz> I'm hesistant to pass it around everywhere, yet -- I see no other option.
00:21:34 <edwardk> pzpz: type Global = StateT Foo IO then embed all your functions in the Global monad.
00:21:46 <edwardk> and you can pull out state from it using IORefs
00:21:56 <edwardk> actually you can get by with ReaderT Foo IO if you want
00:22:29 <edwardk> gives you a downright imperative setting to work in if you want it
00:25:19 <pzpz> edwardk: thanks, reading 'bout that.
00:31:39 <pzpz> bah -- how do you use includes with ghci?
00:32:11 <edwardk> as in #include?
00:32:16 <edwardk> or import?
00:32:22 <pzpz> err, import
00:32:30 <edwardk> :m + Data.Char
00:32:37 <pzpz> ty.
00:32:40 <edwardk> or something similar works well for expanding the current environment
00:44:49 <pzpz> edwardk, which of the methods is preferred?
00:44:49 <pzpz> (if any)
00:49:35 <edwardk> oh for the ReaderT Foo IO thing? or for expanding the environment
00:58:12 <pzpz> edwardk: yah -- IOref/ReaderT/expanding environemnt?
01:00:41 <edwardk> i'd say do the ReaderT Foo IO thing, then make Foo a struct containing members that have nice names and which are IORefs, and then run the reader monad with the environment.
01:53:04 <pzpz> how would i make a structure of IORefs?
01:54:09 <edwardk> data MyGlobals = MyGlobals { foo :: IORef Int, bar :: IORef (Array Int Char) }
01:55:05 <edwardk> then construct that while you are in the IO monad, and runStateT or whatever to run the larger "lego" monad
01:56:14 <pzpz> i'm trying to absorb this all now, been reading for since you mentioned your approach.
01:56:30 <edwardk> pzpz: lemme see if i have an example you can use
01:56:37 <pzpz> what about trying to make an IORef to a Data.Map?
01:56:48 <pzpz> well, an empty Data.Map
01:57:02 <dons> why the IORef?
01:57:18 <edwardk> dons: well, he said globals like he wanted lots of them
01:57:27 <pzpz> just one, actually
01:57:27 <edwardk> early on when the conversation started
01:57:36 <dons> a good state type with a record might be more appropriate?
01:57:38 <edwardk> if its just one, then you can carry it around in a state monad no problem
01:57:44 <dons> once you've got a StateT going
01:57:45 <pzpz> a client table
01:57:53 <edwardk> dons: thats the context. StateT Foo IO
01:58:06 <lispy> an IORef to a Data.Map probably isn't that great in terms of saving computation, but putting IORefs into a Data.Map is probably a pain syntatically
01:59:04 <edwardk> an IORef for one thing isn't a good idea, but if you have 50-100 globals floating around coz of a die-hard C inspired background, then IORefing the globals isn't a terribleway to go to avoid having to repack the struct every time
02:00:46 <pzpz> well -- i'll explain what i'm trying to do. I need to maintain a map containing (String->Handle)
02:01:15 <pzpz> which is updated as new clients connect
02:01:48 <edwardk> ok, then that should probably just be carried around in a basic state monad
02:03:56 <pzpz> *reading more about monads*
02:04:06 <dons> right, like the similar Map held in lambdabot
02:04:11 <dons> for remembering where its connected to
02:04:15 <dons> which is just a StateT Map
02:04:28 <edwardk> putting together a barebones example
02:05:01 <pzpz> the state monad is something allows you to do esentially, a = a + 1 ?
02:05:30 <edwardk> the state monad is like letting you carry around an implicit variable with you everywhere you go, then use 'get' to read it and 'put' to set it.
02:05:42 <edwardk> so you can treat it like a global.
02:05:42 <dons> yep, modify (+1) :)
02:06:52 <lispy> pzpz: just to help confuse, there is also STRef which is just like IORef but doesn't require full-blown IO (meaning you can reference a mutable variable till your heart is content, but you can't go off and do arbitrary things like writng to the disk)
02:07:30 <pzpz> lispy: appreciated :)
02:09:31 <dons> ?users
02:09:32 <lambdabot> Maximum users seen in #haskell: 265, currently: 220 (83.0%), active: 8 (3.6%)
02:11:16 <musasabi> Data.Map is quite fast for most cases.
02:11:30 <musasabi> It is quite hard to beat it with mutable things.
02:11:59 <lispy> yes, i would highly recommend using Data.Map and State/StateT unless you demonstrate via profiling that it's causing a performance problem
02:12:10 <lispy> then you can try out Refs
02:12:59 <lispy> usually the unacceptable performance comes from the algorithm...and pure code tends to be the easiest to retool for a new algorithm
02:13:08 <pzpz> Still learning how to use monads that aren't as simple as the identity
02:13:28 <lispy> pzpz: list and maybe are good for learning about monads
02:13:37 <lispy> but may not help you much with state
02:14:58 <dons> ?type runState
02:15:00 <lambdabot> forall s a. State s a -> s -> (a, s)
02:15:09 <dons> ?type evalState
02:15:10 <lambdabot> forall a s. State s a -> s -> a
02:15:16 <dons> ?type execState
02:15:17 <lambdabot> forall s a. State s a -> s -> s
02:15:24 <dons> (should be fst/sndState...)
02:15:52 <lispy> yeah the difference between run/eval/exec is not good from a learnability point of view
02:16:04 <dons> > execState (do modify (+1) ; modify (*2)) 1
02:16:06 <lambdabot>  4
02:16:20 <lispy> when two ideas are very similar you ideally give them names that exemplify their difference...
02:16:24 <edwardk> @paste
02:16:26 <lambdabot> http://paste.lisp.org/new/haskell
02:16:47 <lisppaste2> edwardk pasted "for pzpz" at http://paste.lisp.org/display/29321
02:16:48 <dons> > flip execState 1 $ do modify (+1) ; modify (*2) ; modify (*7) -- encapsulte your state!
02:16:50 <lambdabot>  28
02:17:02 <edwardk> pzpz: look at that, it contains a quick snippet that does what you want
02:17:08 <edwardk> including a couple of examples of functions
02:17:22 <pzpz> edwardk: super. reading :)
02:17:39 <pzpz> http://www.nomaware.com/monads/examples/example15.hs is pretty confusing.
02:17:44 <lambdabot> http://tinyurl.com/y2v6eq
02:17:45 <edwardk> yeah
02:17:53 <edwardk> i wanted something you could get your head around
02:18:02 <dons> ?pl modify (\state -> M.insert x y state)
02:18:02 <lambdabot> modify ((M .) . insert x y)
02:18:09 <dons> ?pl modify (\state -> insert x y state)
02:18:10 <lambdabot> modify (insert x y)
02:18:31 <edwardk> dons: didn't golf it very far =)
02:18:38 <edwardk> dons: was trying to keep everything explicit
02:18:40 <dons> :)
02:19:21 <edwardk> thats why there are redundant uses if myinsert, vs. doing it by hand
02:19:29 <edwardk> to show different ways to do things
02:20:33 <lispy> and M.lookup can have a more general type if it help
02:20:38 <edwardk> basically the idea is that StateT 'wraps' an IO monad in a container that carries around an additional variable, in this case of type MyMap, which is a Data.Map
02:20:38 <lispy> ?type M.lookup
02:20:40 <lambdabot> Couldn't find qualified module.
02:20:46 <lispy> ?type Data.Map.lookup
02:20:48 <lambdabot> forall a (m :: * -> *) k. (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
02:20:55 <edwardk> lispy: yeah i know, the mylookup was dumbed down to KISS =)
02:21:22 <lispy> edwardk: keep it stupid, simple?
02:21:29 <edwardk> yeah =)
02:21:34 <dons> edwardk: seen the new data parallel haskell paper?
02:21:41 <edwardk> dons: saw it haven't read it
02:22:07 <lispy> i modded it up on general principle but i didn't read it yet either
02:22:45 <dons> i reckon we'll own the other team once everyone starts using transparently parallel arrays
02:23:00 <dons> so we get 3 kinds of paralleism.
02:23:02 <edwardk> heh
02:23:04 <dons> smp+forkIO
02:23:07 <dons> smp+par
02:23:18 <dons> smp+dph (transparently parallel ops)
02:23:46 <edwardk> pzpz: does that code make sense?
02:24:03 <dons> the sparc and mips guys should be handing out multicore boxes to the haskell compiler team...
02:24:07 <lispy> dons: what team?
02:24:14 <dons> #haskell, of course :)
02:24:26 <dons> we do have one mips guy, actually
02:24:28 <pzpz> edwardk: it's becoming more clear :p
02:24:34 <lispy> <dons> i reckon we'll own the other team once everyone starts
02:24:34 <lispy>       using transparently parallel arrays
02:24:47 <dons> oh, *all* the other teams
02:24:59 <lispy> dons: i still don't get it :)
02:25:11 <dons> what does WOOT stand for?
02:25:16 <dons> :)
02:26:05 <lispy> urban dictionary says
02:26:06 <lispy> Woot originated as a hacker term for root (or administrative) access to a computer.
02:26:13 <edwardk> pzpz: the trick that you might take some time on, is that a StateT Foo IO monad isn't an IO monad, its its own animal, but it is a member of MonadIO so you can liftIO $ to get at the IO monad contained inside it if you have wrapped an IO monad in it (which I did by saying that StateT MyMap IO was the type of MyState)
02:26:55 <dons> oh, i see many defs actually. "we own the other team" was what i was thinking of
02:27:44 <edwardk> or you can just access whatever interior monad you wrapped by saying 'lift' and then performing some action in the interior monad, here lift and liftIO are equivalent, coz we just have a StateT Foo IO. if we had StateT Foo (ReaderT Bar IO) a then lift would give you access to the ReaderT and liftIO would take you all the way inside (as would lift . lift) to the IO monad
02:27:49 <lispy> dons: so by team you mean other programming communities?
02:27:51 <dons> yes, wikipedia suggestgs the above, and w00t == root access celebration
02:28:12 <lispy> sorry i'm being dense today:)
02:28:25 <edwardk> dons: and here i thought it came from basketball and woot-there-is or whatever =)
02:28:30 <dons> not literally. just that we win the race. which is a good thing.
02:28:56 * dons wonders what time it is in lispy land
02:29:01 <dons> ah, 2am?
02:29:11 <lispy> yeah
02:29:13 <lispy> tiredam
02:29:13 <dons> oh, and even earlier in edwardk land.
02:29:22 <dons> ?localtime edwardk
02:29:23 <lambdabot> Local time for edwardk is Sun Nov 05 05:28:55 2006
02:29:29 <lispy> why do i see imvu adds everywhere
02:29:49 <lispy> and they always have sexy digital teenagers
02:30:20 <edwardk> yeah
02:30:53 <edwardk> been debating the nature of truth in ##logic =/
02:31:15 <lispy> in ##gah-get-some-rest you mean :)
02:31:21 <edwardk> easier to lose such a debate as it gets later and later =)
02:31:30 <dons> lispy: imvu == 3d chat teenager thing?
02:31:35 <edwardk> lispy: yeah there too =)
02:31:43 <lispy> dons: yeah, guess so, pretty um....odd
02:31:48 <pzpz> so modify modifies whatever's being passed around in the statemonad?
02:31:55 <edwardk> pzpz: yeah
02:31:55 <dons> "Shop for 3D Clothes". "5 Million Members"
02:31:58 <dons> man, i'm out of the loop
02:31:59 <edwardk> @type modify
02:31:59 <lispy> ?type modify
02:32:00 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => (s -> s) -> m ()
02:32:01 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => (s -> s) -> m ()
02:32:18 <edwardk> basically it calls get and put like i did at the top of stateMain
02:32:22 <lispy> dons: that's a loop i don't think i miss...
02:32:36 <dons> modify f = do x <- get ; put (f x)
02:32:48 <pzpz> gotya.
02:32:51 <edwardk> which is why i included both as an example
02:33:01 <dons> lispy: but 3d clothes! that's one whole extra dimension over irc
02:33:16 <integral> modify  = (put . f) =<< get
02:33:31 <dons> ?. pl undo do x <- get ; put (f x)
02:33:32 <lambdabot> put . f =<< get
02:33:42 <dons> integral wins.
02:33:59 <lispy> dons: heh, if you guys all had sexy teenager outfits that might make irc a bit more....interestng
02:34:03 <dons> heh
02:34:09 <dons> i'm a 100% hotty
02:34:13 <dons> a/s/l ?
02:34:21 <dons> ?vixen-on
02:34:22 <lambdabot> What's this channel about?
02:34:23 <lispy> lambdabot: a/s/l?
02:34:34 <dons> do you like 3d clothes?
02:34:34 <lambdabot> yah, i like
02:34:36 <lispy> ?vixen a/s/l?
02:34:37 <lambdabot> 19/f/California
02:34:37 <dons> cool!
02:34:38 <lambdabot> how cool?
02:34:48 <lispy> wanna come over?
02:34:48 <lambdabot> no
02:34:51 <lispy> :(
02:34:51 <lambdabot> hahaha.
02:34:56 <dons> so 3d chat eh? what kind of avatar do you have?
02:34:56 <lambdabot> any kind
02:35:01 <dons> flexible.
02:35:02 <lambdabot> Whatever
02:35:05 <dons> ?vixen-off
02:35:06 <lambdabot> Bye!
02:35:14 <lispy> i don't like vixen anymore
02:35:15 <lispy> she's mean
02:35:19 <pzpz> kk -- i've gotta sleep
02:35:22 <dons> lispy got served.
02:35:24 <pzpz> thanks for the help all.
02:35:29 <lispy> pwn'd by a bot!
02:35:34 <lispy> pzpz: good luck
02:35:38 <edwardk> lispy can't even chat up the bot, ouch.
02:36:01 <lispy> it's just like that in real life too
02:41:01 <dons> hi go! I see you're in .jp, we also have a new #haskell.jp channel for japanese speakers
02:41:07 <dons> ?users #haskell.jp
02:41:08 <lambdabot> Maximum users seen in #haskell.jp: 4, currently: 1 (25.0%), active: 0 (0.0%)
02:41:18 <dons> needs some advertising
02:41:44 <dons> ?users #haskell.es
02:41:45 <lambdabot> Maximum users seen in #haskell.es: 13, currently: 9 (69.2%), active: 1 (11.1%)
02:42:29 <wolverian> ?users #haskell.fi
02:42:30 <lambdabot> Maximum users seen in #haskell.fi: 1, currently: 0 (0.0%), active: 0 (NaN%)
02:42:34 <wolverian> :(
02:42:43 <dons> doesn't exist. but it should be created!
02:42:50 <dons> ?join #haskell.fi
02:43:01 <dons> ?users #haskell.se
02:43:01 <lambdabot> Maximum users seen in #haskell.se: 12, currently: 8 (66.7%), active: 1 (12.5%)
02:43:27 <dons> ?users #haskell.fi
02:43:27 <lambdabot> Maximum users seen in #haskell.fi: 2, currently: 3 (150.0%), active: 1 (33.3%)
02:43:33 <dons> yay!
02:43:38 <dons> 150.0%
02:43:58 <dons> i'll add #haskell.fi to the official list
02:44:02 <wolverian> thanks :)
02:44:14 <lispy> 150%?
02:44:16 <dons> and feel free to pimp the chan to all the .fi guys
02:44:26 <dons> lispy: no idea. sometimes the @seen state can lag a bit
02:44:35 <dons> and we don't have #haskell.fr but we should...
02:44:54 <dons> or #haskell.de hmm.
02:45:14 <bdash> dons: haskell.au?   or is it language-based rather than locale?
02:45:15 <dons> ?users #haskell_ru
02:45:15 <lambdabot> Maximum users seen in #haskell_ru: 2, currently: 1 (50.0%), active: 0 (0.0%)
02:45:21 <dons> language based so far
02:45:34 <dons> or OS-based (#gentoo-haskell)
02:45:37 <dons> ?seen lambdabot
02:45:38 <lambdabot> Yes, I'm here. I'm in #haskell.fi, #ScannedInAvian, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell_ru, #haskell.jp, #haskell.es, #haskell.se, #haskell.it, #haskell-overflow, #
02:45:38 <lambdabot> haskell-blah and #haskell
02:46:10 <dons> I think I'll jsut create #haskell.de and #haskell.fr and see what happens
02:46:14 <dons> ?join #haskell.de
02:46:18 <dons> ?join #haskell.fr
02:46:24 <dons> ?users #haskell.de
02:46:24 <lambdabot> Maximum users seen in #haskell.de: 0, currently: 1 (Infinity%), active: 0 (0.0%)
02:46:29 <dons> ?users #haskell.fr
02:46:29 <lambdabot> Maximum users seen in #haskell.fr: 0, currently: 1 (Infinity%), active: 0 (0.0%)
02:46:34 <dons> :)
02:47:57 <nornagon> heh.
02:48:04 <dons> ?users #haskell.de
02:48:04 <lambdabot> Maximum users seen in #haskell.de: 0, currently: 1 (Infinity%), active: 0 (0.0%)
02:48:15 <nornagon> ?users #haskell
02:48:16 <lambdabot> Maximum users seen in #haskell: 265, currently: 223 (84.2%), active: 14 (6.3%)
02:48:27 <dons> ok. so we know have Swedish, Spanish, Finnish, Japanese, German, French, Italian and Russion chans
02:48:40 <dons> ?users #haskell.it
02:48:41 <lambdabot> Maximum users seen in #haskell.it: 6, currently: 1 (16.7%), active: 0 (0.0%)
02:48:54 <dons> but some of them need a bit of love
02:49:10 <dons> the full list is here for anyone interested http://haskell.org/haskellwiki/IRC_channel#Other_Haskell_channels
02:49:13 <lambdabot> Title: IRC channel - HaskellWiki, http://tinyurl.com/y8vyw7
02:49:40 * gour would like to see someone in #haskell.hr :-(
02:49:53 <dons> we really need to popularise  #haskell.jp in my opinion, since there's an active .jp haskell community (two textbooks), but we hardly see those guys here
02:49:58 <dons> ?join #haskell.hr
02:50:04 <dons> ?users #haskell.hr
02:50:05 <lambdabot> Maximum users seen in #haskell.hr: 0, currently: 2 (Infinity%), active: 1 (50.0%)
02:50:06 <nornagon> gour: ... hungarian?
02:50:21 * kowey mentions #haskell.fr on #ocaml
02:50:24 <edwardk> heh am there, but no one else is other than this strange lambdabot person =)
02:50:24 <gour> nornagon: croatian
02:50:30 <dons> kowey++ cheers
02:50:32 <nornagon> i see.
02:50:39 <gour> dons: /me does not want to be alone ;)
02:51:22 <dons> ok, added it to the list gour, http://haskell.org/haskellwiki/IRC_channel#Other_Haskell_channels
02:51:25 <lambdabot> Title: IRC channel - HaskellWiki, http://tinyurl.com/y8vyw7
02:51:49 <gour> dons: thanks, maybe someone will show up
02:52:20 <dons> especially if you advertise to people you know
02:52:38 <dons> ?users #haskell.fr
02:52:38 <lambdabot> Maximum users seen in #haskell.fr: 1, currently: 2 (200.0%), active: 1 (50.0%)
02:52:47 <nornagon> http://paste.lisp.org/display/29316 <-- why doesn't this work? someone said something about it not being evaluated in the IO monad, but ... I don't get it. :P
02:52:57 <dons> i wonder if a #haskell.no chan would be sustainable.
02:52:57 <gour> dons: will do, but for now i only know about one (potential) user - my friend
02:53:01 <dons> :)
02:53:32 <nornagon> dons: none of the current language channels get very used... why not wait until there's some demand?
02:53:47 <dons> the .es and .se chans are used fairly well
02:53:56 <dons> the .es guys are even translating the wiki
02:54:05 <dons> anyway, i figure if we create them, that lowers the barrier for people to join
02:54:22 <dons> ?users #haskell.es
02:54:22 <lambdabot> Maximum users seen in #haskell.es: 13, currently: 9 (69.2%), active: 0 (0.0%)
02:54:25 <nornagon> nifty.
02:54:30 <dons> ?users #haskell.se
02:54:31 <lambdabot> Maximum users seen in #haskell.se: 12, currently: 8 (66.7%), active: 1 (12.5%)
02:54:35 <nornagon> but not if there's noone in there :)
02:54:44 <dons> well, lambdabot will always be there :)
02:55:12 <kowey> the .es guys might maybe consider translating yaht, now that it's been liberated
02:55:14 <int-e> @botsnack
02:55:15 <lambdabot> :)
02:55:27 <dons> int-e, so you think a .de chan would work?
02:55:32 <gour> dons: lambdabot is now my friend in #haskell.hr, but wants to paste in #haskell
02:55:33 <nornagon> i'll hang out in #haskell.jp, more because I want to learn some japanese than because I know it. I hope fluency is contagious. Maybe if I hang out in enough japanese channels, I'll pick it up...
02:55:51 <int-e> I don't know.
02:56:07 * nornagon prods someone vaguely at http://paste.lisp.org/display/29316
02:56:15 <dons> ?users #haskell.de
02:56:15 <lambdabot> Maximum users seen in #haskell.de: 2, currently: 1 (50.0%), active: 0 (0.0%)
02:56:58 <dons> so what's the issue, nornagon ?
02:57:10 <nornagon> dons: it doesn't compile.
02:57:10 <dons> the precise error?
02:57:15 <nornagon> sec
02:57:24 <dons> zip looks pure
02:57:30 <dons> s/encounters/
02:57:32 <nornagon>     Couldn't match `Int' against `IO a'
02:57:42 <dons> oh, but randbetween is in IO, isn't it?
02:57:51 <nornagon> yeah.
02:58:07 * dons hacks up a fix
02:58:13 <nornagon> awesome.
02:58:25 <lispy> nornagon: what you have isn't really a good way to use random
02:58:32 <tessier__> hack hack hack hack
02:58:36 <nornagon> lispy: how should I do it better?
02:59:04 <dons> ah yes. that random list is in IO
02:59:09 <dons> a true random supply would be nicer
02:59:49 <nornagon> ?
03:00:05 <lispy> so one option is to create a stream of ranom
03:00:07 <lispy> er random
03:00:10 <nornagon> yeah
03:00:11 <dons> so the problem is your randbetween is side effecting
03:00:15 <lispy> another is to have a monad interface
03:00:16 <nornagon> i thought about that
03:00:17 <nornagon> mhm
03:00:19 <dons> but you're using it in randOf, which looks pure
03:00:32 <nornagon> i have no idea about monads yet.
03:00:53 <dons> what's the overall problem? to pick random elemns from the list?
03:00:54 <nornagon> I'm trying to get a grasp of the rest of the language before i wrap my head fully around monads.
03:00:57 <nornagon> yes
03:01:18 <nornagon> I'm trying to generate a stream of elements from the given list
03:01:21 <nornagon> randomly
03:01:35 <lispy> it looks like you want randOf :: [a] -> a, but strictly speaking this won't be possible
03:01:35 <dons> ok
03:01:45 <dons> so a random stream of indicies inside the list bound would be useful
03:01:50 <dons> and then use that to map elements from the list
03:01:52 <nornagon> randOf [1,2] should give something like [1,1,2,2,2,1,2,2,1,2,...]
03:01:55 <dons> generating a random stream of those list items
03:02:01 <dons> right
03:02:29 <nornagon> yeah
03:02:34 <nornagon> how do i get random streams?
03:02:40 <dons> ?type System.Random.randoms
03:02:41 <lambdabot> forall a g. (Random a, RandomGen g) => g -> [a]
03:03:01 <lispy> ?type System.Random.randomRs
03:03:01 <dons> so its a matter of getting the right RandomGen
03:03:02 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
03:03:22 <dons>   -- | Plural variant of 'randomR', producing an infinite list of
03:03:23 <dons>   -- random values instead of returning a new generator.
03:03:23 <dons>   randomRs :: RandomGen g => (a,a) -> g -> [a]
03:03:38 <dons> inside the interval
03:04:46 <int-e> don't use getStdGen btw, use newStdGen
03:04:58 <xerox> G'day!
03:05:06 <xerox> dons - Any news from yaxu?
03:06:05 <lispy> int-e: why is that?
03:06:08 <dons> so, we have:
03:06:11 <dons> main = do
03:06:11 <dons>     g <- newStdGen
03:06:11 <dons>     let rands = randomRs (0,1) g
03:06:11 <dons>     print rands
03:06:25 <dons> [0,1,1,1,0,0,0,1,0,1,1,0,0,0,1,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,1,0,1,0,1,0,0
03:06:29 <int-e> lispy: because if you use getStdGen repeatedly, you'll get the same StdGen
03:06:48 <dons> nornagon: so from there, you should be able to tweak that random list, rands, to fit your requirements?
03:06:49 <int-e> lispy: while newStdGen splits the existing StdGen - so you get a new one every time
03:07:00 <nornagon> dons: i think so :)
03:07:25 <nornagon> dons: can I get a higher scoped version?
03:07:45 <dons> you mean, a list at the top level?
03:07:48 <nornagon> rands = randomRs (0,1) newStdGen
03:07:49 <nornagon> yes
03:07:57 <nornagon> i guess that's monadick
03:07:59 <nornagon> er
03:08:00 <dons> nope. but you could use a state monad
03:08:01 <nornagon> monadic
03:08:09 <dons> right. that newStdGen has to be called at some point
03:08:10 <int-e> lispy: if you're careful and use setStdGen to put a new StdGen back, or if you use it only once, getStdGen is fine, of course. But newStdGen is less likely to cause problems.
03:08:10 <nornagon> how's that done?
03:08:33 <dons> nornagon: so you want to treat the rands list as a global state value ?
03:08:40 <nornagon> yeah.
03:08:54 <nornagon> i want to be able to take values off it
03:08:54 <dons> one minute...
03:09:13 <dons> well, you can do that by threading it around of course. but a little monad should also do nicely
03:09:47 <nornagon> *nod*
03:09:57 <lispy> dons: i was sort of thinking 'instance MonadRandom [a] where' or something might be helpful, but i wasn't sure what to do with it
03:11:11 <lispy> http://haskell.org/haskellwiki/New_monads/MonadRandom
03:11:14 <lambdabot> Title: New monads/MonadRandom - HaskellWiki, http://tinyurl.com/yalp6h
03:12:16 <xerox> Yeah, you can, lispy.
03:12:57 <kowey> say... lambdabot doesn't have an IRC log feature yet, does it? (it?)
03:13:14 <dons> it does, yes
03:13:40 <lispy> ?where logs
03:13:41 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
03:13:58 <dons> nornagon: http://paste.lisp.org/display/29316#1
03:14:01 <xerox> That is not lambdabot logging, tough.
03:14:10 <dons> kowey: but it doesn't log publically unless you ask me to have that happen
03:14:17 <lispy> xerox: right, just thought i'd check thou
03:14:30 <kowey> ok, could you enable public logging of #darcs, please?
03:14:40 <dons> yep. just a tic ...
03:15:36 <nornagon> dons: that looks scary.
03:16:07 <dons> kowey: http://www.cse.unsw.edu.au/~dons/irc/darcs/
03:16:08 <lambdabot> Title: Index of /~dons/irc/darcs
03:16:25 <dons> nornagon: so you can access the random supply wherever you need it via 'get'
03:16:36 <int-e> lispy: ah, getStdRandom is different - it's a wrapper that also puts back the final generator.
03:16:39 <dons> an example is the 'pop' functoin, which just pops the next elem off the state
03:16:40 <kowey> ooh, backlogs even! ( dons++ )
03:16:44 <dons> :)
03:17:02 <nornagon> dons: ah, okay
03:17:04 <nornagon> um
03:17:08 <int-e> lispy: could still perform weirdly in conjunction with unsafeInterleaveIO, but heh, that's unsafe.
03:17:18 <lispy> int-e: hmm
03:17:25 <nornagon> what if i want two different streams of random numbers?
03:17:27 <dons> nornagon: for your problem of taking the randoms and using them to generate a random list, the monad is overkill
03:17:37 <dons> nornagon: then you split the current random supply
03:17:42 <dons> check the docs for System.Random
03:17:46 <nornagon> i, uh, see
03:17:49 <nornagon> :/
03:18:03 <int-e> @index unsafeInterleaveIO
03:18:05 <lambdabot> System.IO.Unsafe
03:18:38 <nornagon> so, can i define a pure list whose nth value is a random (but always the same for equal n) value from a given list?
03:18:43 <dons> nornagon: but shall we write  a small simple program to take a list of words and generate a random stream of them?
03:18:49 <nornagon> yes.
03:18:55 <nornagon> that would be helpful.
03:19:03 <dons> let's do that then..won't need state monads at all :)
03:19:13 <nornagon> excellent.
03:20:35 <xerox> nornagon: in some sense, you can.  You can define a monadic action inside MonadRandom that return what you want.
03:20:51 <lispy> eventually you'll want fromList
03:21:05 <int-e> lispy: come to think of it, even that is ok.
03:21:09 <nornagon> ?type fromList
03:21:10 <lambdabot> Not in scope: `fromList'
03:21:14 <nornagon> i see.
03:21:34 <lispy> fromList :: (MonadRandom m) => [(a,Rational)] -> m a
03:21:59 <lispy> this version of fromList only gives one element, but the important thing is that it lets you give the distribution
03:22:18 <lispy> we could modify fromList to return a list which satisfies the distribution
03:22:54 <xerox> lispy: it was really fun to use that in nymphaea.
03:22:54 <lispy> and you might also want a fromNormalList or fromGaussianList
03:23:11 <lispy> xerox: what is nymphaea?
03:23:22 <int-e> lispy: that comes at a cost though; you can't interleave evalRandomIO at all - forcing the result will force the whole computation.
03:23:51 <dons> lispy: url
03:23:57 <dons> lisppaste2: url
03:23:58 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
03:24:01 <lispy> dons: http://haskell.org/haskellwiki/New_monads/MonadRandom
03:24:04 <lambdabot> Title: New monads/MonadRandom - HaskellWiki, http://tinyurl.com/yalp6h
03:24:09 <lispy> oh, sorry
03:24:43 <xerox> @where nymphaea
03:24:43 <lambdabot> http://haskell.galois.com/~paolo/nymphaea
03:25:10 <xerox> The core first worked with lists, then was abstracted out to monads, and then monadrandom kicked in, *very* nice...
03:25:13 <lisppaste2> dons pasted "randomise your args" at http://paste.lisp.org/display/29323
03:25:18 <lispy> xerox: neat
03:25:27 <dons> nornagon: ^^
03:25:34 <nornagon> *looks*
03:25:53 <nornagon> ?type when
03:25:55 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
03:26:17 <dons> is that the idea?
03:26:30 <nornagon> i beleive so, let me read it through
03:27:07 <nornagon> what's mapM_?
03:27:12 <nornagon> ?type mapM_
03:27:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
03:27:22 <dons> it applies a monadic function to each element of a list
03:27:23 <lispy> nornagon: it's like map but for mands
03:27:26 <nornagon> maps a monad .. that
03:27:28 <lispy> er monads
03:27:29 <dons> in this case, prints the list item once perl ine
03:27:53 <dons> ie.. foreach @xs print
03:28:08 <nornagon> what's the g on the end of the let ns = line?
03:28:11 <dons> could have used forM_ strs putStrLn -- these days
03:28:18 <dons> that's the random generator
03:28:22 <dons> ?type randomRs
03:28:24 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
03:28:24 <nornagon> ah
03:28:26 <nornagon> right
03:28:50 <nornagon> excellent
03:28:58 <nornagon> i think i can fiddle that to do what I want.
03:29:15 <dons> yep, once you've got your arg list, and your random list, then its easy
03:29:43 <dons> ?pl (\n -> args !! n)
03:29:44 <lambdabot> (args !!)
03:32:48 <nornagon> what's ?pl?
03:32:56 <ex0r[a]> if I have a list like so: [Node "a" lis, Node "b" lis, Leaf "c"], is there a nice quick and easy way to extract all the strings?
03:33:03 <lispy> nornagon: it removes the parameters
03:33:33 <lispy> ?pl foo x y = x + y
03:33:34 <lambdabot> foo = (+)
03:33:37 <ex0r[a]> preferably ["a","b","c"]
03:34:09 <lispy> ex0r[a]: you'd have to write something like Tree a -> a, then map it onto the list
03:34:19 <ex0r[a]> hmm
03:34:28 <nornagon> lispy: ?pl n congruent to n?
03:34:47 <lispy> nornagon: huh?
03:34:52 <dons> ?pl \x -> f x
03:34:53 <lambdabot> f
03:34:58 <nornagon> are they the same thing?
03:35:04 <lispy> nornagon: exactly the same
03:35:06 <dons> it performs "pointfree" refactorings mechanically
03:35:10 <nornagon> ah.
03:35:21 <dons> ?pl map (\x -> x +1) [1..10]
03:35:21 <lambdabot> map (1 +) [1..10]
03:35:32 <dons> ?wiki Pointfree
03:35:33 <lambdabot> http://www.haskell.org/haskellwiki/Pointfree
03:36:04 <dons> nornagon: fwiw, I put up the code on the wiki for all time, http://haskell.org/haskellwiki/Random_list
03:36:05 <lambdabot> Title: Random list - HaskellWiki
03:37:16 <nornagon> dons: cool :)
03:38:59 <dons> ?users #haskell.de
03:38:59 <lambdabot> Maximum users seen in #haskell.de: 2, currently: 2 (100.0%), active: 1 (50.0%)
03:39:03 <dons> ?users #haskell.fr
03:39:03 <lambdabot> Maximum users seen in #haskell.fr: 1, currently: 2 (200.0%), active: 1 (50.0%)
03:39:15 <dons> all your .de and .fr guys... channels for all!
03:40:18 <Syzygy-> I don't wanna go in a channel of my own. I wanna stay here, with you guys!
03:40:48 <dons> that's ok too :)
03:41:02 <dons> ?users #haskell.es
03:41:03 <lambdabot> Maximum users seen in #haskell.es: 13, currently: 9 (69.2%), active: 0 (0.0%)
03:41:05 <dons> ?users #haskell.se
03:41:06 <lambdabot> Maximum users seen in #haskell.se: 12, currently: 8 (66.7%), active: 1 (12.5%)
03:41:09 <dons> ?users #haskell.jp
03:41:10 <lambdabot> Maximum users seen in #haskell.jp: 4, currently: 2 (50.0%), active: 1 (50.0%)
03:41:12 <dons> ?users #haskell.fi
03:41:13 <lambdabot> Maximum users seen in #haskell.fi: 5, currently: 5 (100.0%), active: 2 (40.0%)
03:41:13 <Syzygy-> We have #haskell.se!?
03:41:21 <dons> its the oldest
03:41:25 <Syzygy-> Heh
03:41:31 <dons> ?seen lambdabot
03:41:32 <lambdabot> Yes, I'm here. I'm in #haskell.hr, #haskell.fr, #haskell.de, #haskell.fi, #ScannedInAvian, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell_ru, #haskell.jp, #haskell.es, #haskell.
03:41:32 <lambdabot> se, #haskell.it, #haskell-overflow, #haskell-blah and #haskell
03:41:51 <Syzygy-> What's #haskell-overflow??
03:42:00 <nornagon> so, i have two lists i need to slurp random bits from -- do i just create two RandomGens? is there a better way so i don't have to repeat myself?
03:42:06 <dons> a place for technical 'breakout' sessions
03:42:32 <dons> you could create two, or you could split the current one
03:42:39 <xerox> Syzygy-: we had discussion on derivatives of types, and much more, there :)
03:42:56 <Syzygy-> MWAH!
03:43:03 <int-e> a lot of Data.ByteString discussions, too.
03:43:04 <dons> ?type System.Random.split
03:43:05 <Syzygy-> And noone told me!? :(
03:43:05 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
03:43:24 <dons> yeah, the bytestring paper was basically written in #haskell-overflow
03:43:24 <psykotic> any lambda calculus meisters here? :P
03:43:25 <xerox> Syzygy-: it was some time ago, in fact.  But the people interested in the subject are still around, I think.
03:43:31 <Syzygy-> xerox: ah.
03:43:32 <dcoutts> heh, yeah :-)
03:43:35 <dons> psykotic: should be several, including lambdabot
03:43:39 <psykotic> can anyone confirm/refute that the predecessor function on church numerals is not lambda-definable in the simply-typed lambda calculus?
03:43:59 <psykotic> i seem to remember this is the case
03:44:29 <psykotic> i don't have the barendregt door-stop here, so i can't look it up
03:44:32 <nornagon> dons: that will get me two randomgens that spit numbers in the same range, right?
03:44:36 <dons> ?lambda ( \x .x ) 1
03:44:36 <lambdabot> 1
03:44:45 <dons> nornagon: should do, yes.
03:44:49 <dons> check the docs
03:44:51 <dons> ?docs System.Random
03:44:52 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
03:44:57 <nornagon> my lists are different sizes :D
03:45:10 <nornagon> I'm already looking at that.
03:45:14 <dons> oh, the generator can be split
03:45:21 <dons> but then you create different lists with randomRs or some such
03:45:32 <nornagon> ah
03:45:33 <nornagon> okay.
03:45:52 <xerox> int-e: yes! It was awesome to be able to follow the ticking cogwheels of the "Rewriting Haskell Strings" paper :)
03:46:15 <nornagon> hm.
03:46:53 <nornagon> let ans   = randomRs (0,length acts-1) ... but how do i extract the second part of the split tuple?
03:47:42 <nornagon> i could do (_, g2) <- split g, right? but that's a bit ugly.
03:48:00 <dons> so for example, to create two different bounded random lists:
03:48:02 <dons>     let (g,g') = split gs
03:48:02 <dons>         ns   = randomRs (0,length args-1) g
03:48:02 <dons>         ms   = randomRs (0,7) g'
03:48:10 <lispy> ?fptools System.Random
03:48:10 <lambdabot> http://darcs.haskell.org/packages/base/System/Random.hs
03:48:11 <dons> where earlier we had:
03:48:12 <dons>     gs   <- newStdGen
03:48:28 <nornagon> ah, okay then.
03:48:50 <nornagon> that wasn't how I was thinking of doing it, but that works.
03:49:20 <dons> for exapmle:
03:49:21 <dons> $ runhaskell /tmp/A.hs the quick brown fox
03:49:22 <dons> ("brown",7)
03:49:22 <dons> ("quick",2)
03:49:22 <dons> ("brown",0)
03:49:23 <int-e> > let pred = (\a x y -> a (\b c -> c (b x)) (\d -> y) (\e -> e)); church n f x = iterate f x !! n; unchurch f = f succ 0 in [unchurch . pred . church $ n | n <- [0..10]]
03:49:24 <dons> ("the",4)
03:49:24 <lambdabot>  [0,0,1,2,3,4,5,6,7,8,9]
03:49:27 <dons> ("quick",5)
03:49:35 <dons> int-e++
03:50:37 <musasabi> grah @ too long function names - isCodePointMaybeCanonicallyComposableHangulStart :-(
03:50:44 <dons> oh my
03:51:18 <int-e> > length "isCodePointMaybeCanonicallyComposableHangulStart"
03:51:20 <lambdabot>  48
03:52:03 <lispy> is it possbile to do 'instance Random [a]' so that random returns one element?
03:52:59 <lispy> guess not
03:53:12 <lispy> random :: RandomGen g => g -> (a,g)
03:53:28 <lispy> so it would unify as, random :: RandomGen g => g ([a], g)
03:53:37 <Cale> > length "HasUnderlyingSemigroupElementOfMonoidByAdjoiningIdentityElt"
03:53:38 <lambdabot>  59
03:53:45 <Cale> ha! Take that!
03:54:00 <Cale> And it's using short forms
03:54:32 <dons> is that some mathematica ident?
03:54:38 <Cale> No, GAP.
03:54:55 <Cale> GAP has no module system, and a huge huge library
03:55:11 <Cale> and many extremely specific functions
03:55:19 <dons> heh
03:55:46 <Cale> I still love the functionality it provides :)
03:55:49 <psykotic> they still haven't added a module system to gap? damn
03:56:20 <profmakx> thats on purpose with gap
03:56:22 <Cale> Well, there are modules in one sense, but no module namespaces
03:56:29 <profmakx> that there are specific functions
03:56:34 <lispy> hmm...i wonder about creating a monad on top of [a] using mapAccumL instead of map
03:56:44 <psykotic> cale: modules in the sense that you can load some stuff from a file? :)
03:56:55 <int-e> psykotic: pred in the simply typed lambda calculus would need to have the type ((t -> t) -> t -> t) -> (t -> t) -> t -> t , right? hmm.
03:56:56 <Cale> yeah :)
03:56:57 <profmakx> because it turns out that one can write most efficient algorithms in CGT only in special cases
03:57:04 <profmakx> so we do ^^
03:57:46 <psykotic> int-e: hmm. i can swear the inability to lambda-define pred in lambda-> is a classic result.
03:58:27 <psykotic> there were two guys who gave a classification of the lambda-definable functions on natural numbers in lambda-> and it turned out pred wasn't possible to define.
03:58:36 <int-e> psykotic: with HM types, church numerals are polymorphic - so I cheated.
03:58:43 <psykotic> yeah
04:00:02 <psykotic> ahh, found it.
04:00:21 <psykotic> statman-schwichtenberg theorem
04:00:28 <psykotic> it indeed isn't lambda-definable in lambda->
04:02:21 <lisppaste2> nornagon pasted "Bear with me..." at http://paste.lisp.org/display/29324
04:02:31 <psykotic> that also suggests why church had a hell of a time finding out how to code pred initially
04:02:55 <psykotic> even though he was working in the untyped setting the functions that are typeable in the simply typed calculus are in some sense more "intuitive"
04:03:43 <nornagon> so, um. How do I do this 'get some lines from stdin' thing?
04:05:15 <dcoutts> ls <- return . lines =<< getContents
04:05:33 <dcoutts> that gets all lines from stdin
04:05:52 <xerox> ls <- lines `fmap` getContents
04:06:19 <dcoutts> @pl return . lines =<< getContents
04:06:20 <lambdabot> lines `fmap` getContents
04:06:21 <xerox> ?pl \f xs -> return . f =<< xs
04:06:21 <lambdabot> fmap
04:06:23 <xerox> :)
04:06:24 <dcoutts> heh, nice
04:07:01 <int-e> psykotic: interesting
04:07:02 <xerox> The first time I saw that used was in pugs code.
04:08:02 <dcoutts> I used mplus for the first time the other day
04:08:12 <dcoutts> with the Maybe type
04:08:50 <dcoutts> I think fmap, mplus and unfoldr are under-appreciated
04:08:52 <nornagon> dcoutts: I want to prompt, get a line, prompt, get a line, ...
04:09:04 <nornagon> until the line is empty or EOF is reached
04:09:18 <dcoutts> nornagon, ah ok, you'll need getLine
04:09:24 <dcoutts> @type getLine
04:09:26 <lambdabot> IO String
04:09:28 <nornagon> yeah
04:09:32 <nornagon> but, see my paste
04:09:42 <nornagon> http://paste.lisp.org/display/29324
04:10:57 <nornagon> oops, i see the reason for the second error there.
04:11:02 <dcoutts> nornagon, it might help your understanding if you added type signatures to your getThing, GetEntities etc
04:11:04 <dons> you're missing a g' on       ans     = randomRs (0,length acts-1)
04:11:15 <nornagon> dons: right, just noticed that.
04:11:24 <nornagon> dcoutts: okay, i'll try that...
04:11:56 <dons> IO stuff can't be used like this: return $ n : getThings prompt
04:11:57 <dcoutts> nornagon, when I get type errors that I don't understand, my general strategy is to add type annotations until it becomes clear to me.
04:12:08 <dons> you mean to say: do x <- getThings ; return $ n : xs
04:12:19 <dons> (notice: not tail recursive)
04:12:21 <xerox> dcoutts, did you use all of them together in one expression?
04:12:33 <nornagon> dons: what's that n?
04:12:39 <dcoutts> xerox, heh, no. Can you think of an example? :-)
04:12:41 <dons> in,   if (null n) then return [] else return $ n : getThings prompt
04:12:50 <nornagon> ah
04:13:11 <dcoutts> unfoldr = unstream for lists :-)
04:13:11 <nornagon> and what about xs? >.>
04:13:25 <xerox> dcoutts, I'm not too familiar with unfoldr, that Maybe type has to be generated in some nice way...
04:13:27 <dons> oh, typo
04:13:37 <dons> do xs <-  getThings ; return $ n : xs
04:13:44 <dcoutts> xerox, it's just the co-algebra for the list type :-)
04:13:47 <dons> ?pretty do xs <-  getThings ; return $ n : xs
04:13:49 <lambdabot> "Parse error" at column 38
04:13:56 <dons> ?pretty f = do xs <-  getThings ; return $ n : xs
04:13:57 <lambdabot>  f = do xs <- getThings
04:13:57 <lambdabot>     return $ n : xs
04:14:03 <dons> well, close, bar for tabs
04:14:20 <dons> ?. pl undo do xs <-  getThings ; return $ n : xs
04:14:21 <dcoutts> xerox, so you know every algebraic data type has a fold function right?
04:14:21 <lambdabot> (n :) `fmap` getThings
04:14:25 <dons> mm
04:14:33 <dcoutts> xerox, and the form of it depends in the structure of the data type
04:14:57 <dcoutts> xerox, and a fold is an algebra, a way of consuming values of that type
04:14:59 <nornagon> so i need a nested do thing?
04:15:13 <xerox> dcoutts - Right.
04:15:16 <dons> yeah, else do xs <- ...
04:15:23 <nornagon> 'k.
04:15:30 <dcoutts> xerox, so a co-algebra gives use the opposite, an unfold for each data type that lets us construct values of the type
04:16:24 <dcoutts> xerox, so fold works by iteratively consuming a value, bit by bit, unfold generates a value by iterating and generating it bit by bit.
04:16:26 <xerox> We don't have a generalized fold function, do we?  Wait, we probably do in 6.6.
04:16:37 <psykotic> what are some nice nontrivial coalgebraic data types?
04:16:45 <psykotic> i seem to remember something about finite state automata?
04:16:56 <dcoutts> psykotic, there are ones for trees for example
04:17:01 <dcoutts> @type List.unfoldr
04:17:03 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
04:17:25 <xerox> dcoutts, yeah, my problem is that the generating function returns a Maybe (a,b), for which I can't find a good (read pointless) generating expression.
04:17:29 <nornagon> awesome, I gut it working.
04:17:37 <nornagon> I wish I understood why!
04:17:59 <dcoutts> xerox, so it returns Nothing for the end of the list, or Just (x, next) for an element
04:18:19 <dcoutts> xerox, it's not the only way of writing it, it could equally have been:
04:18:56 <dcoutts> unfoldr :: (s -> Bool) -> (s -> a) -> (s -> s) -> b -> [a]
04:19:00 <dcoutts> or something
04:19:07 <dcoutts> oops b/s
04:20:04 <psykotic> so in this case the Maybe (a,b) is like a cons-style definition of a stream?
04:20:12 <dcoutts> yeah
04:20:48 <nornagon> how do i get a three-way zip?
04:20:52 <int-e> unfoldr' pred elem next = unfoldr (\s -> guard (pred s) >> return (elem s, next s))
04:21:04 <dcoutts> nornagon, zip3
04:21:10 <dcoutts> or zipWith3
04:21:15 <nornagon> like [a] -> [b] -> [c]
04:21:16 <nornagon> er
04:21:26 <nornagon> like [a] -> [b] -> [c] -> (a,b,c) ?
04:21:30 <dcoutts> @hoogle zipWith
04:21:31 <lambdabot> Prelude.zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
04:21:31 <lambdabot> List.zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
04:21:32 <lambdabot> List.zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]
04:21:32 <nornagon> ?type zip3
04:21:34 <lambdabot> forall c b a. [a] -> [b] -> [c] -> [(a, b, c)]
04:21:41 <nornagon> excellent.
04:21:48 <int-e> I forgot who came up with using 'guard' in unfoldr, but it's clever.
04:21:48 <xerox> > let unfoldr p succ last x | p x = x : unfoldr p succ last (succ x) | otherwise = [last x] in unfoldr (<10) succ id 0
04:21:51 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10]
04:22:02 <dcoutts> @type guard
04:22:03 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
04:22:07 <xerox> Is last needed?
04:22:19 <xerox> > let unfoldr p succ x | p x = x : unfoldr p succ (succ x) | otherwise = [] in unfoldr (<10) succ id 0
04:22:20 <lambdabot>    The function `unfoldr' is applied to four arguments,
04:22:20 <lambdabot>   but its type `(...
04:22:23 <xerox> > let unfoldr p succ x | p x = x : unfoldr p succ (succ x) | otherwise = [] in unfoldr (<10) succ 0
04:22:24 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
04:22:45 <nornagon> dons: it's getting a bit crowded in my let... I need a third stream
04:22:59 <dcoutts> xerox, try defining splitBy :: Eq a => a -> [a] -> [[a]] using unfoldr :-)
04:22:59 <xerox> It's like a bounded |iterate|, I like that.
04:23:04 <nornagon> (a different random stream of things out of ents)
04:23:14 <dcoutts> xerox, iterate is an unfoldr too
04:23:25 <dcoutts> xerox, it needn't be bounded, but it can be bounded
04:24:01 * psykotic dreams of bananas, lenses and barbed wire
04:24:03 <dcoutts> @type iterate
04:24:04 <lambdabot> forall a. (a -> a) -> a -> [a]
04:24:09 <int-e> > let unfoldr' pred next elem = unfoldr (\s -> guard (pred s) >> return (elem s, next s)) in unfoldr' (<10) succ id 0
04:24:11 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
04:24:25 <xerox> dcoutts, it's nice to have a bounded as well as the not-bounded version, I probably like the boolean-predicate one better than the maybe-returning one.
04:24:44 <dcoutts> @type \f -> unfoldr (Just . f)
04:24:46 <lambdabot> forall b a. (b -> (a, b)) -> b -> [a]
04:24:51 <psykotic> the maybe-returning one seems closer to the stream-style view
04:24:53 <dcoutts> oops
04:25:25 <dcoutts> @type \f -> unfoldr (\s -> let s' = f s in Just (s', s'))
04:25:27 <lambdabot> forall a. (a -> a) -> a -> [a]
04:26:16 <dcoutts> xerox, often the sharing is essential, or you have to recalculate things in each function that you could do all in one go with the Maybe version
04:27:09 <dcoutts> eg in iterate via unfoldr I'd have to call f twice I think with the bool predicate one
04:27:21 <dcoutts> since next and elem would need to call f
04:27:40 <dcoutts> oh, hmm maybe not
04:27:41 <psykotic> there's an interesting relationship to two commonly seen ways of implementing OO-style iterators, here
04:27:57 <psykotic> the python style is to have a next() method on iterators that throws an exception saying "i'm done"
04:28:16 <dcoutts> iterate f = unfoldr (\s -> Just (s, f s))
04:28:51 <dcoutts> psykotic, but they also have a isnext right ? relying on exceptions is silly.
04:29:00 <psykotic> no, they don't have an isnext
04:29:02 <dcoutts> or at_end() or whatever
04:29:06 <dcoutts> nothing ?
04:29:19 <dcoutts> they always just throw an exception at the end ?
04:29:22 <psykotic> no, and i think that's a good thing in general. sometimes you don't know in advance whether you're done until you try, and some things aren't reversible/redoable.
04:29:31 <dcoutts> indeed
04:29:33 <psykotic> for instance, think of file IO
04:29:40 <dcoutts> so it should return Maybe a
04:29:48 <psykotic> so then you need to add buffering and things get iffy
04:29:49 <dcoutts> or the python equivalent
04:29:59 <psykotic> right, and the alternative is the GOF-style iterator which has hasNext(), etc
04:30:06 <psykotic> equivalent to the bool version
04:30:27 <dcoutts> does any oop language have tree iterators ?
04:30:38 <dcoutts> I don't mean iters that go linearly through a tree
04:30:47 <dcoutts> it mean one that exposes the branching
04:31:07 <psykotic> that's what the visitor pattern is :)
04:31:24 <psykotic> although they implement it via interfaces instead of higher-order functions, etc
04:31:25 <musasabi> dcoutts: don't most iterators support that? iter->current->right or somesuch.
04:31:32 <dcoutts> @type Data.Tree.unfoldForest
04:31:33 <lambdabot> forall a b. (b -> (a, [b])) -> [b] -> Forest a
04:31:47 <musasabi> dcoutts: with C++ style templated iterators.
04:31:50 <psykotic> for instance, in a compiler you might have a visitor interface for traversing an expression tree.
04:31:53 <dcoutts> musasabi, but that's just linear isn't it ?
04:32:33 <musasabi> dcoutts: what kind of an interface are you after then?
04:32:53 <musasabi> i.e. how should branching be exposed.
04:33:08 <dcoutts> instead of giving you one new iter when you say next, it gives you several, corresponding to the branching factor
04:33:26 <dcoutts> eg look at unfoldr vs unfoldTree
04:33:26 <psykotic> no, i can't think of any uses quite like that
04:33:37 <dcoutts> @type Data.List.unfoldr
04:33:39 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
04:33:41 <dcoutts> @type Data.List.unfoldTree
04:33:42 <lambdabot> Not in scope: `Data.List.unfoldTree'
04:33:49 <dcoutts> @type Data.Tree.unfoldTree
04:33:51 <lambdabot> forall a b. (b -> (a, [b])) -> b -> Tree a
04:33:59 <psykotic> what you often see are precanned traversal/combination patterns where you can provide the visitor functions for different kinds of clauses in an algebraic data type
04:34:33 <dcoutts> I expect it's because their iterators are mutable
04:34:48 <dcoutts> and so can only really express linear patterns
04:34:59 <musasabi> but they can (ugly!) clone their iterators.
04:35:00 <dcoutts> to do trees you need to make new iters
04:35:06 <dcoutts> yes, true
04:36:34 <psykotic> it's easy to do nonmutable iterators, it's just that the OO people usually don't :)
04:36:48 <Pupeno> Good morning.
04:55:12 <dons> mmm. .. http://wiki.tcl.tk/13844
04:55:16 <lambdabot> Title: Monadic TOOT
04:55:18 <dons> and the syntax almost works
04:56:06 <dons>     $res match {
04:56:06 <dons>  	Nothing:	-> { return }
04:56:06 <dons>  	{Just: a}	-> {
04:56:07 <dons>  	    concat $a [iterate $func $a]
04:56:32 <dons> like if haskell got drunk and had a one night stand with perl5
05:04:33 <Heffalump> I thought perl6 was the child of that relationship
05:20:11 <musasabi> Was there an efficient map structure for "Subset of Int" -> Bool, with efficient support for ranges ?
05:22:01 <musasabi> e.g. a total range of ~1 million with ~200 single ints and ~50 ranges and need efficient membership tests.
05:25:11 <musasabi> Data.Map and .Set seem to lack the necessary functions (mainly findLowerOrEq or somesuch)
05:30:54 <araujo> morning
05:31:53 <sek> > :t floor
05:31:54 <lambdabot>  Parse error
05:32:02 <sek> @type floor
05:32:03 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
05:32:44 <sek> how come when i run [1,2..(floor $ sqrt 100)] thats ok, but when i do [ x | x<-[1,2..(floor $ sqrt n)], n `mod` x == 0] that mucks up?
05:34:33 <psykotic> @type sqrt
05:34:35 <lambdabot> forall a. (Floating a) => a -> a
05:34:39 <sek> > [ x | x<-[1,2..(fromIntegral $ floor $ sqrt n)], n `mod` x == 0]
05:34:40 <lambdabot>  Not in scope: `n'
05:34:41 <psykotic> @type mod
05:34:43 <lambdabot> forall a. (Integral a) => a -> a -> a
05:35:07 <sek> > let n = 100 in [ x | x<-[1,2..(fromIntegral $ floor $ sqrt n)], n `mod` x == 0]
05:35:08 <lambdabot>  Add a type signature
05:35:10 <psykotic> the problem is that the use of mod restricts n and x to be integers. you need to do sqrt (fromIntegral n)
05:35:51 <psykotic> (i think)
05:35:56 <sek> > let n = 100 in [ x | x<-[1,2..(floor $ sqrt $ fromIntegral n)], n `mod` x == 0]
05:35:57 <lambdabot>  [1,2,4,5,10]
05:36:03 <sek> aha
05:36:19 <sek> so what exactly does the integral type mean?
05:36:48 <Baughn> Whole numbers, I would assume
05:36:55 <Baughn> Int, Integer, Word32, ...
05:37:47 <sek> thanks
05:38:42 <psykotic> @type 100
05:38:43 <lambdabot> forall t. (Num t) => t
05:38:56 <psykotic> notice how it isn't an _integer_ literal
05:39:05 <Baughn> ?instances Integral
05:39:06 <lambdabot> Int, Integer
05:39:21 <sek> i see
05:39:28 <psykotic> i guess that's what confused  you
05:39:38 <Baughn> ?instances-importing Data.Word Integral
05:39:39 <lambdabot> Int, Integer, Word, Word16, Word32, Word64, Word8
05:39:48 <sek> why didnt it work by doing fromIntegral $ floor ..
05:40:12 <psykotic> because there you were doing the fromIntegral at the end. sqrt wants its argument to be a Floating.
05:40:41 <psykotic> sqrt :: (Floating a) => a -> a
05:40:52 <sek> > sqrt 5
05:40:53 <lambdabot>  2.23606797749979
05:40:58 <sek> > floor $ sqrt 5
05:41:00 <lambdabot>  2
05:41:06 <sek> and floor returns an Integral
05:41:40 <psykotic> err
05:41:43 <Baughn> And conversion to Floating (apart from the other issues) isn't automatic because of the loss in precision, I suppose
05:42:04 <psykotic> floor $ sqrt 5 means floor(sqrt 5) not sqrt(floor 5)
05:42:42 <psykotic> so i don't see how you could expect the fromIntegral at the front in your example to have any bearing on sqrt's argument
05:48:39 <joelr1> good afternoon!
05:55:12 <pitecus> would it be a very bad idea to have a field for the parent in nodes in a tree?
05:56:05 <joelr1> does ghc use simd instructions now?
05:56:39 <Baughn> pitecus: Not if you need them, but it does ensure that you can't GC /part/ of the tree
05:56:46 <Baughn> pitecus: Why?
05:56:48 <Lemmih> joelr1: I don't think so.
05:57:00 <Baughn> joelr1: It does if GCC does... maybe
05:57:17 <pitecus> I ve never seen such trees used in Haskell so i was wondering
05:57:23 <joelr1> Baughn: right, makes total sense
05:57:32 <pitecus> They would be quite handy for what Im doing
05:57:33 <joelr1> Lemmih: do you have a mac/intel?
05:57:46 <Baughn> pitecus: You can use exactly whatever datastructure you like
05:57:46 <joelr1> Lemmih: what's your main "ghc support" machine?
05:58:09 <Baughn> pitecus: They're uncommon in haskell because lazy evaluation and the usual recursion make them redundant in many cases, but certainly not all
05:58:37 <pitecus> Baughn, OK thanks
05:59:26 <Baughn> pitecus: Also, having a parent pointer somewhat precludes having multiple parents
06:00:13 <pitecus> Baughn, well thats OK for a tree, no?
06:00:17 <Baughn> pitecus: (And of course, you should strive to use something in the Data hierarchy instead of inventing your own)
06:00:48 <Baughn> pitecus: If it really is a tree, sure, but it's often very useful to grab parts of it and graft onto another tree
06:01:27 <pitecus> I was using Data.Tree but its a bit of a pain because given a node i need to access both its descendant and ancestors
06:01:31 <Baughn> pitecus: Especially as they can't be altered behind your back..
06:01:44 <Lemmih> joelr1: An old AMD box.
06:01:48 <Baughn> pitecus: Well, if that's what you need, having a parent pointer makes /perfect/ sense
06:02:04 <joelr1> Lemmih: i see
06:02:05 <pitecus> Baughn, I ll go for it then
06:02:12 <pitecus> Baughn, thanks again
06:04:28 <dcoutts> Lemmih, btw, would you like a spare amd64 cpu? I've got one going spare as I'm upgrading to a dual core version. Though you'd probably need a different motherboard.
06:05:46 <dcoutts> you'd need a motherboard with a 939 socket that takes DDR1 ram
06:06:10 * Lemmih doesn't have the cash to buy a new motherboard.
06:06:17 <psykotic> Baughn, there are issues with having parent pointers. for instance it means that you cannot easily share subtrees between different trees as is usual in e.g. updating an existing tree. if you update the root node, for instance, you'll need to rebuild the entire tree.
06:06:33 <Baughn> psykotic: Indeedy, I mentioned that
06:06:35 <dcoutts> Lemmih, me neither, oh well.
06:06:42 <Lemmih> dcoutts: Thanks, though.
06:06:43 <psykotic> oh sorry, i'm still in backscroll
06:06:44 <Baughn> Though not /that/
06:07:03 <Baughn> pitecus: You do realize that you have to rebuild the entire tree if you alter even a single leaf, I hope. I didn't.
06:07:28 <ndm> Baughn: not true, you require O(log n) space to do an insert, not O(n)
06:08:02 <Baughn> Hmm. Right. The entire chain of parents, then
06:08:07 <ndm> yep
06:08:13 <dcoutts> Lemmih, np, well if you find a cheap second hand mb some time then tell me.
06:08:18 <Baughn> Which, happily, doesn't actually alter complexity - but still..
06:08:31 <psykotic> but hey, that in turn forces you to rebuild the entire tree when you have parent pointers.
06:08:49 <psykotic> when you rebuild those parent chain nodes you also have to rebuild their children in order for the left.parent = me invariant to hold, etc
06:09:07 <Baughn> ..oh yeah. Nice.
06:09:20 <dcoutts> psykotic, actually you'd need to rebuild the entire tree if you changed any node, not just the root.
06:09:38 <psykotic> dcoutts, right i just took that as an example since it's easiest to see it in that case.
06:10:37 * dcoutts goes offline to restart X to see if he can get opengl working
06:10:47 <psykotic> it might be better to split up parent information to be on the side to allow for sharing
06:10:53 <psykotic> alternatively you could use a zipper, but it depends on what you're doing.
06:10:56 <pitecus> So you need to rebuild the whole tree iven if you just change the label in one node?
06:11:38 <psykotic> what exactly are you doing where you need this?
06:11:51 <Baughn> pitecus: You can't actually /change/ a node - you need a new one, which means you need a new parent, and so on - but when you get around to changing the root, you then need to change all its /children/ - that is, the entire tree - to fix the parent pointers
06:12:20 <psykotic> in any case it is easy to use a zipper to make "batch updates" very fast
06:12:29 <Baughn> psykotic: Zipper?
06:12:30 <psykotic> even if the problem doesn't really fit zippers beyond that
06:12:31 <pitecus> Baughn, yes the new node would have the same parent as the old one tho
06:13:05 <psykotic> Baughn, yeah, zippers rock. google for huet, functional perl, zipper.
06:13:10 <psykotic> pearl
06:13:18 <Baughn> pitecus: Sure, but you'd have to change the child pointer in the parent. Which would require updating the child pointer in /its/ parent, and the parent pointer in its other child, and...
06:13:55 <pitecus> Oh I m starting to see...
06:14:15 <Baughn> psykotic: Oh, yay. I've been using some severely infinite trees to memoize functions
06:14:43 <Baughn> (A map of the domain of all possible strings, as it turns out. -_-)
06:15:10 <pitecus> I m trying to use those trees to represent parsed sentences and then traverse the the tree extracting various features for each node. Those features need access to the node's context so it'd easiest to do with parent pointers
06:16:00 <Baughn> pitecus: With parent pointers you get O(n) update. How much updating were you planning to do?
06:16:48 <psykotic> pitecus, it's much "functional" to pass the context down if needed.
06:16:51 <psykotic> err, more
06:17:06 <psykotic> as you are recursing down the tree you are accumulating the context, so it's easy to pass around
06:17:07 <pitecus> Baughn, well once the tree is built i might want to map it to a tree with the same shape but with node labels transformed in some way
06:17:13 <pitecus> Not much more than that
06:17:42 <xerox> dcoutts_: what about this as splitAt in terms of unfoldr:
06:17:42 <xerox> > let splitAt x = unfoldr (\xs -> case break (x==) xs of ([],_) -> Nothing; (xs,[]) -> Just (xs,[]); (xs,ys) -> Just (xs, tail ys)) in splitAt ' ' "how do you do"
06:17:44 <lambdabot>  ["how","do","you","do"]
06:18:25 <Baughn> pitecus: Well.. that would be O(n) regardless, so I suppose that'sokay
06:18:35 <pitecus> psykotic I see. The thing is the amount of context needed will vary as i experiment with different features
06:18:51 <Baughn> pitecus: But you'll want to build the initial tree with a special-purpose O(n) algorithm, not repeated insertions
06:19:36 <psykotic> pitecus, that shouldn't be a big problem in any case. updating the context-passing code is easy.
06:19:51 <psykotic> you can pass the immediate parent down, or you can cons up the whole parent chain on your way down and pass that in
06:21:27 <pitecus> psykotic, hmm passing the parent chain should be OK
06:21:57 <xerox> If you need a static shared context, you might just use a Reader monad.
06:22:29 <xerox> Then you do { environment <- ask; ... } to retrieve it anytime.
06:22:29 <pitecus> xerox, No actually the context is different for each node
06:22:39 <spiffy> hello
06:22:46 <xerox> Ah.  What is the context?  Are you thinking of a Zipper?
06:23:06 <pitecus> context is the ancestors of a node in this case
06:23:20 <pitecus> xerox, I dont know anything about Zipper
06:23:24 <xerox> Then a Zipper might really be what you want!
06:23:26 <Pupeno> I have a library with two modules, one depends on the other. How can I load into ghci the one that depends in the other, it fails to find it ? (note: I am using emacs with its haskell-mode).
06:23:37 <Baughn> pitecus: http://alan.petitepomme.net/cwn/2003.04.15.html, note 5
06:23:40 <lambdabot> Title: Caml Weekly News, http://tinyurl.com/yk7r4l
06:24:35 <pitecus> Thanks Baughn
06:24:43 <pitecus> xerox where is this Zipper thing?
06:25:25 <xerox> pitecus: a Zipper is a type isomorphic to the given one, but with a different view on it, i.e. a tuple whose first member is the current "place" in the tree, and the second is a context type, which is really the first type with a "hole", to mark a place.
06:25:31 <xerox> http://www.haskell.org/haskellwiki/TheZipper
06:25:33 <lambdabot> Title: Zipper - HaskellWiki
06:26:03 <spiffy> Alright, I have my random number module all import. I can get random numbers of type IO Int, is there a way to get just an Int?
06:26:04 <psykotic> Baughn, oleg did this pretty cool hack of a transactional file system as a zipper
06:26:23 <Baughn> spiffy: You don't want to do that
06:26:31 <pitecus> Cool, thanks, xerox Baughn
06:26:35 <spiffy> I dont?
06:26:51 <Baughn> spiffy: It's unsafe. You can, however, produce an infinite list of random ints and use that.
06:27:02 <spiffy> I like the sound of that.
06:27:13 <psykotic> great. my girlfriend just tried to heat some make-up in our microwave and was surprised to find it exploded.
06:27:27 <Pupeno> Otherwise I get the error "Could not find module `Network.Server.Common'".
06:27:27 <xerox> pitecus: when you went through that you should also check the Zipper Monad!
06:27:31 <Baughn> psykotic: *sweatdrop*
06:27:39 <pitecus> I will
06:28:02 <xerox> psykotic: a *very* general Zipper! And continuations for threading! Insane amounts of Olegness.
06:28:11 <spiffy> Baughn: how do i get this list?
06:28:41 <psykotic> xerox: right, that was part of it. the file system style zipper was actually huet's original example (rather than a zipper for binary trees, say).
06:28:42 <Baughn> spiffy: main = do list <- functionReturningRandomIOList; dostuff list; return whatever
06:29:13 <xerox> psykotic: do you know of any applications of the Web?
06:29:18 <spiffy> hmmm makes sense
06:29:26 <spiffy> thanks
06:29:26 <Baughn> spiffy: Function's not hard to define, but there's a good chance your randomness library already has one
06:29:32 <psykotic> no, i just read the paper, and it doesn't seem more useful than something like oleg's generic zipper.
06:29:50 <psykotic> isn't the whole point of the web to kill the boilerplate for making zippers for algebraic data types?
06:29:52 <spiffy> and then my types will all match?
06:30:07 <xerox> spiffy, if you want dostuff to be a pure function, you might want to |do rs <- randomList; let result = dostuff rs; return result|.
06:30:34 <Baughn> spiffy: If you get it right, they'll match
06:30:53 <sek> ok i am having a similar problem again:p phi n = let pd = primedivisors n in floor $ product [1 - 1/x | x<-pd]
06:31:01 <sek> pd :: [Int]
06:31:16 <xerox> psykotic: maybe one could use a zipper approach to save the per-user navigation state in a web application.
06:31:36 <sek> i dont really even need the floor in there as that product will always be an *.0
06:31:42 <Baughn> @hoogle IO Int
06:31:44 <lambdabot> System.Console.Readline.getCompletionQueryItems :: IO Int
06:31:44 <lambdabot> System.Console.Readline.getEnd :: IO Int
06:31:44 <lambdabot> System.Console.Readline.getMark :: IO Int
06:31:51 <Baughn> ..that's odd. No random?
06:31:59 <xerox> @hoogle random
06:31:59 <lambdabot> Random.random :: (Random a, RandomGen b) => b -> (a, b)
06:32:00 <lambdabot> System.Random.random :: (Random a, RandomGen g) => g -> (a, g)
06:32:00 <lambdabot> Random :: module
06:32:05 <int-e> sek: a) you forgot to multiply by n I think b) I think you'd have better luck with pure integer arithmetic
06:32:06 <xerox> @hoogle+
06:32:06 <lambdabot> System.Random :: module
06:32:07 <lambdabot> System.Random.Random :: class Random a
06:32:07 <lambdabot> Random.randomIO :: Random a => IO a
06:32:08 <psykotic> xerox: that's an interesting idea. although since you'll want to persist things ideally i'm tempted to just use state :)
06:32:25 <Baughn> Oh goodie
06:32:48 <sek> i took out the (n : [1-...] ) while playing around
06:32:54 <xerox> psykotic: I think using the Zipper Monad can be fun, some higher-level ideas can be expressed quite nicely with the actions it provides.
06:32:54 <Baughn> spiffy: ..so you also have the option of explicitly passing the PRNG around, state and all. That's actually pretty neat.
06:32:59 <psykotic> xerox: oh yeah.
06:33:03 <sek> int-e how would i go about sticking to integer arithmetic?
06:33:08 <psykotic> xerox: regarding web stuff though, i imagine the way to go is program within some kind of "session monad".
06:33:16 <psykotic> that way you can easily deal with persistence and so on.
06:33:23 <xerox> psykotic: have you seen HAppS?
06:33:26 <psykotic> no
06:33:36 <int-e> sek: and you're probably missing some conversions in your code. this will work better:   foldl' (\n p -> n `div` p * (p-1)) n pd  [untested]
06:33:47 <xerox> It provides some weird monad, its approach is quite interesting.
06:34:49 <int-e> sek: or maybe (\n p -> n - n `div` p) instead of the multiplication
06:34:51 <xerox> If I remember correctly the author's words: first, it imposes a total order on the requests, then you can handle them as pure functions from (Request,State) to State, or something.
06:35:54 <spiffy> randomRs :: RandomGen g => (a, a) -> g -> [a]
06:36:03 <sek> int-e, it is product (n : [1 - 1/x | x<pd])  so n is multiplied only once, not for every prime divisor
06:36:14 <spiffy> thats from the standard Random library in ghc
06:36:25 <spiffy> does that take a PRNG?
06:37:03 <int-e> sek: do you know what  foldl  does?
06:37:05 <sek> int-e, i could theoretically do the result `div` 10   as many times as there are elements in pd but that seems counter productive:p
06:37:24 <int-e> sek: n is only multiplied once in my code, too.
06:37:32 <sek> yeah, did i understand wrongly then?, hm ok
06:37:35 <psykotic> xerox: btw speaking of zippers do you know of mcbride's work on differentiating regular data types?
06:37:43 <xerox> psykotic: yes!
06:37:53 <psykotic> that stuff is awesome. it would be cool to program something like the web based on differentiation.
06:38:00 <int-e> sek: I should probably have picked a different identifier in the closure.
06:38:02 <psykotic> maybe in generic haskell?
06:38:17 <xerox> Do you want automatic generation of Zippers for ADTs? :)
06:38:20 <psykotic> yeah
06:38:21 <int-e> sek: (\m p -> m - m `div` p) instead of the same with n.
06:38:29 <xerox> DrIFT can do that?
06:38:33 * xerox doesn't know
06:38:34 <psykotic> dunno what that is
06:38:51 <xerox> musasabi probably knows.
06:39:19 <xerox> It indeed looks like one needs Template Haskell to do such a thing.
06:39:49 <psykotic> the relationship between delimited continuations and zippers is nice too
06:40:03 <psykotic> it makes a lot of sense if you understand shift/reset in terms of evaluation contexts and metacontexts.
06:40:29 <int-e> sek: a (less efficient?) alternative that's easier to understand would be to use  n `div` product pd * product [p - 1 | p <- pd]
06:40:33 <sek> ah ok. That cnfused me:p
06:40:48 <psykotic> you basically reify the data contexts as evaluation contexts and use shift/reset to get at these reified data contexts. that's oleg's generic zipper hack afaik.
06:41:44 <sek> that binds around the *, right?
06:42:03 <int-e> sek: no. that's (n`div` product pd) * product [p - 1 | p <- pd]
06:42:17 <sek> yeah thats what i meant
06:42:23 <int-e> oh.
06:42:31 <int-e> then yes ;)
06:42:39 <sek> heh thanks
06:42:52 <xerox> psykotic: uhm, I've only seen one implementation of shift/reset in Haskell, and it wasn't exactly *handy* to use.
06:43:19 <xerox> psykotic: do you have time to explain delimited continuations a bit?
06:43:21 <psykotic> xerox: well, you can do a callcc and state monad stack and you have shift/reset
06:43:47 <psykotic> (the various delimited control operators can be implemented in terms of call/cc and a mutable cell)
06:44:12 <xerox> I wonder if callCC + State is a natural way to explain that in Haskell, or even implement it.
06:44:20 <psykotic> probably not but it works. :)
06:44:48 <psykotic> the most natural way to think about shift/reset, imo, is in operational terms and specifically in terms of evaluation contexts.
06:44:57 <xerox> I remember somebody writing a block entry about the use of delimited continuations in Haskell for writing an interpreter for some language.
06:45:14 <xerox> psykotic: care to elaborate? Sounds interesting.
06:45:34 <psykotic> yeah, sure.
06:47:24 <psykotic> take an expression like (reset (+ 1 (+ 2 (shift k (+ 1 (k (k 3))))))). (reset ...) acts as a context delimiter. if you imagine a "hole" in place of the (shift ...) term you have (reset (+ 1 (+ 2 []))). this is a delimited context. associated with this delimited context we have the "plugging in" function (lambda (x) (+ 1 (+ 2 x))).
06:48:49 <psykotic> the rule is that the above expression reduces to (reset (+ 1 (k (k 3)))) where k is bound to the context of the shift, in this case k = (lambda (x) (+ 1 (+ 2 x))). (k 3) = (+ 1 (+ 2 3)) = (+ 1 5) = 6, (k (k 3)) = (k 6) = (+ 1 (+ 2 6)) = (+ 1 8) = 9. (+ 1 (k (k 3))) = (+ 1 9) = 10.
06:49:10 <psykotic> so it reduces to (reset 10). the rule is that (reset <value>) reduces to <value>, so (reset 10) becomes 10.
06:49:15 <xerox> Why do you want to write the (reset .. (shift ..)) form instead of (lambda (x) ..) ?
06:49:43 <psykotic> in this case there's no reason you would :)
06:50:14 <psykotic> one thing that's interesting is that you can have shifts within shifts.
06:50:28 <psykotic> of course the main motivation behind delimited control is that suddenly your continuations are composable, since they actually return.
06:51:06 <psykotic> if you want more details it's probably better to check out the first few sections of ken shan's "from shift to control".
06:51:12 <xerox> Why does the (+ 2 ..) disappear?
06:51:29 <psykotic> where?
06:51:47 <xerox> "The rule is that the above expression reduces to (reset (+ 1 (k (k 3))))"
06:51:57 <psykotic> the whole point is that when the shift is reduced it "aborts" the context. it replaces everything up to the enclosing reset with the body of the shift, with the k bound to the context.
06:52:27 <xerox> So (+ 1 ..) should be aborted as well?
06:52:31 <psykotic> right
06:52:56 <xerox> Resulting in (reset (k 3)) or (reset (k (k (k 3)))) ?
06:53:13 <psykotic> sorry, where?
06:53:21 <psykotic> there's no more shifts left so you only have that happen once
06:54:04 <psykotic> once you have reduced the shift to (reset (+ 1 (k (k 3)))) you don't have any shifts any more.
06:54:23 <psykotic> at that point you just perform reductions as usual, with the delimited context-reified-as-plug-function bound to k
06:54:39 <xerox> I don't understand why it does reduce to (reset (+ 1 (k (k 3)))) :-/
06:55:26 <psykotic> that's just the rule. (reset ... (shift k e) ...) => (reset e) where we bind k to the context represented as a plug-in function.
06:55:40 <xerox> You say it aborts the context up to the nearest reset, so it should give (reset (k 3)) shouldn't it?
06:55:55 <xerox> Uhm.
06:56:14 <xerox> My problem is that I don't understand why the (+ 1 ..) is still there.
06:56:22 <psykotic> because it was in the shift's body.
06:56:29 <psykotic> (shift k (+ 1 (k (k 3))))
06:56:33 <xerox> AH!
06:56:59 <xerox> It confused me, sorry. I thought it was the (+ 1 ..), first argument of the (reset ..) form.
06:57:16 <psykotic> doh, yeah that was a silly choice of constants :)
06:57:39 <psykotic> anyway check out that ken shan paper's first few sections. it has some very down to earth exposition in the first section and a very understandable formal definition in the second section in terms of contexts and metacontexts (delimited contexts).
06:58:02 <fasta> How can I call a process and get its stdout?
06:58:20 <xerox> (reset (* 2 (+ 1 (shift k (+ 1 (* 2 (k 3)))))))
06:58:20 <xerox> ==>  (reset (+ 1 (* 2 (k 3))))
06:58:20 <xerox> ==>  (lambda (x) (+ 1 (* 2 (* 2 (+ 1 x))))) ?
06:58:26 <xerox> fasta: see System.Process
06:58:47 <xerox> ...or if you like popen, lambdabot's source has one implementation of it.
06:58:53 <xerox> Was that right psykotic?
06:59:28 <xerox> Oh, no.
06:59:44 <xerox> It is just (+ 1 (* 2 (* 2 (+ 1 3)))).
06:59:46 <fasta> xerox: oh, well, I just want to do something similar as expect, and I don't understand expect.
06:59:56 <xerox> What is expect?
07:00:02 <psykotic> xerox: the k would be bound to (lambda (x) (* 2 (+ 1 x))) in this case. so the last reduction is wrong. it would be (reset (+ 1 (* 2 ((lambda (x) (* 2 (+ 1 x))) 3))) = (reset (+ 1 (* 2 (* 2 (+ 1 3)))))
07:00:10 <psykotic> xerox: yeah, you got it
07:00:15 <xerox> psykotic: yay!
07:00:20 <fasta> xerox: expect allows you to control interactive applications programmatically.
07:00:45 <fasta> xerox: I made a script that does work, but I cannot understand why it works.
07:00:50 <xerox> psykotic: this is evil.
07:01:03 <xerox> psykotic: there is no problem in using k more than once, right?
07:01:20 <psykotic> xerox: right, that's the whole point. think of call/cc: the continuation, when called, never returns so isn't composable.
07:01:22 <xerox> And basically, what you pass to k, is what you put in the hole in place of shift, right?
07:02:00 <psykotic> right. so reducing (shift k e) when k is not bound in e is basically like reducing e itself, for instance.
07:02:16 <psykotic> err, (shift k (k e))
07:02:44 <xerox> Can you make "loops" out of reset/shift?
07:03:11 <psykotic> sure
07:03:15 <psykotic> you can have a shift within the shift
07:03:47 <xerox> fix f = (reset (f (shift k (k k)))) -- ?
07:04:28 <xerox> No, that's probably wrong.
07:04:44 <xerox> A shift within the shift...
07:04:59 <psykotic> right, and that's where it can get mind bending :)
07:05:17 <psykotic> the nice thing about the reduction-based definition is that you can always work it out on paper even when it gets hairy
07:05:18 <xerox> Does the innermost shift capture the actual shift in its context?)
07:05:24 <psykotic> yes
07:05:28 <xerox> Oh, I want to see the reductions!
07:06:25 <xerox> `do' is really easy to explain in terms of its reductions.
07:12:14 <psykotic> btw one neat way you can do with delimited continuations is generators
07:12:38 <psykotic> you use a reset for the top-level of the generator and do a shift of a (cons <answer> k) every time you want to yield
07:12:58 <psykotic> so basically that spits out the answer and the context of the generator at that point
07:13:48 <psykotic> when you want to get the next answer from the generator you just call the cdr
07:15:04 <audreyt> ...and that's exactly how Pugs implements perl6 coroutines :D
07:15:12 * audreyt praises resetT and shiftT
07:15:34 <psykotic> nice
07:15:47 <psykotic> i think the generators trick is the one-trick pony all the delimited continuation papers pull out :)
07:15:58 <audreyt> I think web continuations is also fun.
07:16:05 <psykotic> yeah that's the other one.
07:16:10 <psykotic> admittedly that one is bigger.
07:16:30 <audreyt> and you can emulate state! (but that one is not fun at all)
07:16:33 <xerox> audreyt: where did you get resetT and shiftT ?
07:16:41 <psykotic> sure, you can emulate all monads with delimited continuations!
07:16:47 * psykotic digs out his code, hrm
07:16:56 <audreyt> xerox: SPJ et al
07:16:59 <audreyt> resetT :: Monad m => ContT a m a -> ContT r m a
07:16:59 <audreyt> resetT e = C.lift $ e `runContT` return
07:17:01 <xerox> Where where!
07:17:02 <audreyt> shiftT :: Monad m => ((a -> ContT r m s) -> ContT s m s) -> ContT s m a
07:17:02 <audreyt> shiftT e = ContT $ \k -> e (C.lift . k) `runContT` return
07:17:07 <xerox> Ooooh.
07:17:07 <audreyt> er, that's all
07:17:10 <audreyt> copy and paste :)
07:17:14 <xerox> mtl?
07:17:20 <audreyt> import qualified Control.Monad.Cont as C (lift)
07:17:21 <audreyt> yes.
07:17:25 <psykotic> http://paste.lisp.org/display/26252
07:17:34 <psykotic> (will make your head hurt)
07:17:38 <xerox> Good.
07:17:48 <Pupeno> So... what should I use to do Binary IO with GHC 6.6 ?
07:18:53 <int-e> what is this 'binary IO' people keep talking about?
07:19:24 <audreyt> psykotic: well, I had innoculation.
07:19:27 <audreyt> it makes perfect sense to me :)
07:19:33 <psykotic> hah!
07:19:50 <audreyt> the inoculation is in the form of "Linguisic Side Effects"
07:19:59 <audreyt> where exactly the same code is ported to the English platform.
07:20:06 <audreyt> on the HumanBrain VM
07:20:10 <audreyt> try reading that paper sometime :)
07:20:12 <psykotic> hehe, yeah i glanced through his thesis
07:20:20 <psykotic> it's a cute idea
07:20:48 <audreyt> ccshan = my childhood friend, and his work has continued to warp my brain for 10+ years :)
07:21:09 <Pupeno> int-e: input output where you deal with bytes, bits, words, etc.
07:22:03 <arcatan> linguistic side effects sound like logical fallacies with more sciency name
07:22:34 <psykotic> arcatan, hah! it's actually a very simple  but profound idea: dealing with context in linguistics.
07:22:49 <psykotic> side-effect-freeness is all about context-independence
07:23:39 <psykotic> continuations are _all_ about context, so it's in hindsight it's not a huge surprise that they show up in that guise.
07:23:45 <fasta> Can anyone look here? http://pastebin.ca/239926
07:23:59 <fasta> It's IO weirdness.
07:24:02 <psykotic> i think it was felleisen who first made the explicit connection between continuations and evaluation contexts; that must have been in the early 80's.
07:24:16 <psykotic> (by evaluation contexts i mean explicitly syntactical contexts, not some vague notion of "context")
07:25:27 <fasta> xerox: do you have any explanation for that behaviour?
07:28:25 <xerox> fasta: try changing that like with an hFlush ?
07:28:34 <xerox> fasta: or try different buffering modes?
07:28:48 <xerox> ?type readIO
07:28:53 <lambdabot> forall a. (Read a) => String -> IO a
07:29:15 <fasta> xerox: I already tried hFlush, but maybe not on the right handle...
07:29:27 <fasta> It does not do buffering.
07:29:31 <fasta> I.e. it's Nothing
07:30:08 <xerox> I mean what you set with hSetBuffering, what is Nothing?
07:30:21 <fasta> I didn't set the buffering.
07:30:30 <fasta> xerox: flushing the input helped
07:30:33 <fasta> xerox: thanks
07:30:55 <xerox> You might also try with a different buffering, which could save you from the pain of flushing things in precise times, I think.
07:31:00 <xerox> Just experiment :)
07:32:18 <fasta> Hmm, it's not really solved yet. I will take your advice however.
07:34:23 <fasta> It works :)
07:34:32 <fasta> Much easier than learning expect
07:41:39 <xerox> Hiya yaxu!
07:41:46 <xerox> How did the Haskell Live Music go?
07:42:10 <yaxu> was ok, i need more practise
07:42:24 <yaxu> and to stop supercollider from crashing
07:42:32 <xerox> Cool! Any recording available? :)
07:42:45 <yaxu> no i will make a screencast soon tho
07:43:28 <yaxu> was a reasonable proof of concept
07:43:40 <xerox> dons was all excited about that :)
07:44:08 <spiffy> hmmm I think I may have painted myself into a corner.
07:44:51 <spiffy> I have a function with a type signature as follows: [a] -> ([a] -> Int) -> [a]
07:45:02 <fasta> Hmm, it will only work when I execute it in ghci. When I compile it stops working, while I don't input anything by hand... odd.
07:45:15 <spiffy> I want a random INt, therefore i get IO Int
07:45:24 <spiffy> is there anyway to get these two to work togeather?
07:45:51 <xerox> That function only takes a function [a] -> Int as argument, how do you want to use your IO Int with it?
07:46:50 <spiffy> essentially what i need to do is change the type signature to ([a]->IO Int) -> [a]
07:46:57 <spiffy> or what i want to do
07:47:03 <spiffy> but i dont think I can
07:47:11 <xerox> What does this [a] -> Int function do?
07:47:31 <ndm> length
07:47:34 <spiffy> ?
07:47:39 <lennart> const 0?
07:47:46 <spiffy> all of the above work
07:47:58 <ndm> both of the above work, but not massively more than that...
07:48:01 <xerox> Types don't "work" by theirself.
07:48:05 <int-e> I think it's supposed to return a random number (hence IO) from 0 to length of the list.
07:48:06 <int-e> and index.
07:48:09 <int-e> -d
07:48:15 <spiffy> int-e would be correct
07:48:43 <fasta> Why does this code work when I execute it in ghci, but not when compiled with ghc --make Main.hs? http://pastebin.ca/239982
07:48:44 <spiffy> im trying to shuffle a deck of cards. That function returns the index of the current deck that should be consed on to the final deck.
07:48:44 <int-e> and no I don't think it can be made to work. you need a different interface.
07:49:21 <Baughn> There's always unsafePerformIO, at least until it gets summarily ripped out, spindled, folded and mutilated in the next release
07:49:33 <Baughn> (No, don't use it)
07:49:44 <lennart> It's not part of Haskell98
07:50:10 <spiffy> ok, so short of that, whats my best option?
07:51:17 <xerox> The best option may vary depending on what are you up to learn.
07:51:24 <Baughn> Three options - grab an infinite list of random numbers, return (Int, RandomGen) instead of just Int, or return IO Int
07:51:36 <spiffy> alright
07:51:38 <int-e> one idea is to change it to  [a] -> ([a] -> IO Int) -> IO [a]. another is to deal with appropriate StdGens directly, [a] -> ([a] -> StdGen -> (Int, StdGen)) -> StdGen -> ([a], StdGen)
07:51:50 <spiffy> hmmm
07:51:56 <Baughn> PRNGs are deterministic, so you don't /need/ IO to use them - you just need to keep track of state
07:51:57 <int-e> the latter almost screams for using an appropriate monad.
07:52:07 <lennart> exactly
07:52:08 <spiffy> State monad?
07:52:16 <Baughn> Oh yes
07:52:20 <spiffy> afk for a few minutes
07:52:23 <lennart> random numbers have nothing to do with IO, except getting a seed
07:52:27 <int-e> http://haskell.org/haskellwiki/New_monads/MonadRandom was mentioned earlier I think
07:52:30 <lambdabot> Title: New monads/MonadRandom - HaskellWiki, http://tinyurl.com/yalp6h
07:52:35 <fasta> Anyone?
07:52:39 <lennart> pseudo-random numbers, i should say
07:53:02 <lennart> real random numbers would be all about IO :)
07:53:11 <int-e> fasta: your program terminates, all child processes are killed, all file descriptors closed. chances are all this happens before the command is actually sent.
07:53:17 <psykotic> anyone who uses arithmetic methods to produce random numbers is in a state of sin.
07:53:22 <int-e> fasta: while in ghci the program continues to run.
07:53:28 <Baughn> > (mkStdGen 0)
07:53:33 <lambdabot>  1 1
07:53:40 <fasta> int-e: ok, then I know what to do.
07:53:53 <lennart> psykotic: well, they aren't really random, but they are good enough for government use
07:54:01 <fasta> int-e: thanks, I had that problem earlier.
07:54:07 <psykotic> lennart, i know, that's a famous von neumann quote though :)
07:54:39 <xerox> lennart: maybe you can have your randomness generator in its own forall, a-la ST!
07:54:42 <psykotic> lennart, btw i randomly came across your old c compiler hack for ioccc recently, damn nice!
07:55:33 <int-e> xerox: hmm, that isn't good, is it?
07:55:46 <Baughn> > take 20 $ let foo g = let (a,b) = next g in a : foo b  in foo (mkStdGen 0)
07:55:48 <lambdabot>  [2147482884,2092764894,1390461064,715295839,79337801,347273588,1427314282,18...
07:55:49 <xerox> How is that not good?
07:55:51 <int-e> xerox: well whatever executes that monad must go into IO
07:56:13 <xerox> Everything that it is executed now goes into IO, via main?
07:56:13 <Baughn> spiffy: There you are. One infinite list, to go.
07:56:14 <int-e> xerox: because it's not pure.
07:56:29 <xerox> ST isn't either?
07:56:55 <psykotic> xerox: was it you whom i discussed "splitting" prngs with a long time ago?
07:57:04 <int-e> ST is essentially pure. running the same ST action with the same arguments several times produces the same results
07:57:20 <int-e> true randomness doesn't have that property.
07:57:30 <psykotic> i think the context was quickcheck and passing down independent prngs to subtrees for test generation purposes.
07:58:34 <lennart> psykotic: thanks :)
07:58:59 <ihope> Haskell!
07:59:07 <psykotic> lennart, for similar madness see http://fabrice.bellard.free.fr/otcc/. he actually spits out x86 code :)
07:59:11 <lennart> xerox: My Mersenne-Twister encapsulates the generator in ST and uses runST to hide it
07:59:11 <lambdabot> Title: OTCC : Obfuscated Tiny C Compiler
07:59:36 <xerox> see int-e? that's doable!
07:59:50 <dino-> I was going through this the other day with some of you guys.
08:00:10 <int-e> xerox: that's a pseudo random number generator, and the ST action certainly has a seed as its argument
08:00:22 <int-e> xerox: same seed, same pseudorandom sequence, a pure function.
08:00:25 <dino-> > newStdGen >>= return . take 10 . randomRs (0,9) >>= print
08:00:26 <lambdabot>  No IO allowed
08:00:31 <dino-> > newStdGen >>= return . take 10 . randomRs (0,9)
08:00:31 <lambdabot>  No IO allowed
08:00:33 <Baughn> psykotic: Oh, no - that's just wrong
08:00:34 <xerox> lennart: is that like so?
08:01:16 <lennart> xerox: sounds right :)
08:01:33 <xerox> Alright.  I wonder what was I thinking.
08:02:00 <xerox> Though, if you have linearity in your type system, that seem doable!
08:02:41 <xerox> Because every action will be executed at most one time.
08:03:20 <lennart> int-e: for true randomness you can't use ST, of course.  But you could still have an operation like "getRandomInts :: IO [Int]".  So you get your infinite list of random numbers in one place and the consumers don't have to know where they came from.
08:03:36 <int-e> lennart: yes, of course.
08:04:28 <int-e> lennart: I meant, how should I say, the root of the calculation that generates the random numbers.
08:05:06 <fasta> int-e: ok, it works completely now. :)
08:05:17 <int-e> fasta: nice
08:05:52 <xerox> Even if you need more power to the type system to do that, it's still interesting.  Random beside IO.
08:07:22 <xerox> Maybe some of the power of F_C is enough to grant us the right to do that, now in 6.6.
08:08:26 <psykotic> xerox: you mentioned F_c the other day too--how much of haskell's type system does it encompass?
08:08:38 <xerox> psykotic: everthing of it, and more!
08:08:55 <xerox> @babel en it encompass
08:08:57 <lambdabot>  comprenda
08:08:59 <psykotic> including multiparameter type classes, functional dependencies, and other assorted craziness?
08:09:00 <xerox> Right.
08:09:11 <int-e> xerox: but even with linear types you need a source of the randomness that's outside of the pure world, don't you?
08:09:11 <xerox> Yes!  Even Associated Types.
08:09:44 <xerox> int-e: the compiler takes care of that?
08:10:00 <Pupeno> Are there functions to perform search and replace on Strings (search and replace of strings, not of chars) ?
08:10:12 <xerox> psykotic: they also say that there is some *more* power whose practical use wasn't still discovered.
08:10:37 <xerox> Pupeno: no, but there should be...
08:12:11 <Pupeno> Ok, I'll use Text.Regex then.
08:12:33 <xerox> Pupeno: you might also want to know that there is a faster (lazy) regexp engine out there, on sourceforge.
08:12:57 <psykotic> lazy in what way? NDA-style?
08:13:29 <psykotic> NFA even
08:14:40 <xerox> It uses Parsec, IIRC.
08:15:04 <Pupeno> I am not after speed... yet.
08:15:26 <xerox> The standard one is *really* slow.
08:15:43 <psykotic> hmm that reminds me, does anyone know of any papers that derive efficient regex matchers by partially evaluating a naive one?
08:15:55 <psykotic> it seems like the kind of thing the pe people would do
08:17:08 <xerox> Partially evaluate is like turning a strict language in a lazy one?
08:17:55 <fasta> How can I do Haskell's runInteractiveProcess in Scheme48?
08:19:09 <xerox> Better ask on #scheme I suppose :)
08:20:11 <pejo> psykotic, keyword you're looking for is "KMP-test".
08:20:23 <spiffy> Baughn: thanks :)
08:20:53 <psykotic> pejo: i know about using substring searching for culling, and i know the PE guys have derived KMP and BM from naive string matchers. i was thinking more of deriving e.g. the subset construction by partial evaluation.
08:21:50 <spiffy> now to figure out how that works.
08:24:09 <pejo> psykotic, ah, I should have read more carefully.
08:40:08 <jgrimes> morning
08:45:38 <beelsebob> morning all
08:45:53 <beelsebob> anyone here an expert on the various different Haskell web development kits?
08:50:24 <Pupeno> Evaluating "" (Unicode char 8592) on GHCi gives an error "<interactive>:1:2: lexical error in string/character literal at character '\134'", what's the problem ?
08:50:51 <dcoutts> I'm not sure ghci can grok unicode yet
08:50:55 <beelsebob> ghci doesn't support unicode
08:50:56 <dcoutts> though ghc can in source files
08:52:17 <emk> Hmmm. Is there are conventional notation for "has type" (other than the colon)?
08:52:54 <Igloo> The double colon
08:53:00 <ndm> beelsebob: Yhc :)
08:53:15 <emk> I'm using \in, which is common enough in older mathematical typing papers, but has a nasty conflict with `elem`.
08:53:15 <ndm> beelsebob: the newest Haskell web development kit :)
08:53:34 <beelsebob> ndm: I'm needing one that I can use in the here and now
08:53:38 <beelsebob> reliably
08:53:51 <jgrimes> ndm, oh really? what new features this time? :)
08:54:09 <ndm> jgrimes: as yet unreleased, and its not my project, so i don't want to blow its announcement
08:54:13 <Igloo> beelsebob: What functionality do you need?
08:54:21 <jgrimes> ndm, ah I see, just enough to get us salivating
08:54:26 <ndm> jgrimes: give it two days and you'll see it fly by on haskell@
08:54:41 <beelsebob> Igloo: I need it to be able to talk to a DB (probably mySQL), and I need it to do the complex calculations I need nice and easily in Haskell
08:54:45 <ndm> jgrimes: but this one is actually sufficiently useful that i might start doing paid work based on it
08:54:59 <jgrimes> ndm, oh wow, thats pretty sweet then :)
08:55:03 <jgrimes> can't wait to see it
08:55:18 <Igloo> OK, I haven't done the DB part of mine yet
08:55:26 <ptolomy> Ooh. Shootout has 6.6 now.
08:55:31 <jgrimes> ptolomy, :O
08:55:43 <beelsebob> Igloo: what's your one?
08:55:52 <beelsebob> does it have some kind of backend storage mechanism?
08:56:53 <Igloo> beelsebob: The bit that's done is just HTML generation. It's at http://urchin.earth.li/darcs/ian/html-monad/ with http://matrix.chaos.earth.li/~ian/dikidev/Index being an example
08:56:54 <lambdabot> Title: Index of /darcs/ian/html-monad
08:57:47 <jgrimes> beelsebob, I've had some limited experiences with Hope and HAppS, and both seem pretty nice. I didn't do any DB work with HAppS, just used its built-in methods for keeping state, but with Hope it is pretty straightforward.
08:57:50 <ptolomy> I know it is a bit silly, but I'm curious: Are there Bytestring versions of shootout entries waiting in the wings, or should somebody get to work?
08:59:57 <jgrimes> ptolomy, there might be... you'll have to check with the people that are usually most involved with that
09:00:01 <jgrimes> dons would probably know
09:00:19 <ptolomy> I should probably make my own versions for fun either way, I suppose.
09:00:25 <jgrimes> ptolomy, yeah, that would be fun
09:11:51 <dmn> hi
09:11:57 <thneed> hi
09:12:25 <jgrimes> hello :)
09:13:01 <dmn> ;]
09:14:11 <dmn> i'm having trouble handling tabs in strings. for example, i'd like to print a tab - print "\t" doesn't do the trick.. or to remove all whitespace in a line - [c | c <- line, c /= ' ', c /= '\t'] - it treats \t as a literal string composed od \ and t..
09:14:16 <dmn> how should i go about this ?
09:15:45 <dmn> same goes for \n
09:16:34 <dmn> anyone ?
09:17:32 <xerox> dmn: print '\t' ?
09:17:53 <xerox> putStr "\t" ?
09:18:10 <beelsebob> jgrimes: sounds good
09:18:25 <xerox> to remove whitespaces: concat . words
09:18:48 <Korollary> why not filter . isSpace?
09:18:51 <Korollary> err
09:18:53 <Korollary> no dot
09:18:55 <dmn> that takes 2 iterations
09:19:14 <xerox> Well, let's hope there are RULES for that :)
09:19:17 <dmn> hm, the list comprehension probably takes 2 as well
09:19:25 <ndm> xerox: not in Yhc or Hugs :)
09:19:34 <xerox> Let's not use them.
09:20:06 <dmn> xerox how can i check if a character is a tab then ?
09:20:25 <ndm> dmn: == '\t'
09:20:33 <xerox> ('\t' ==)
09:20:36 <xerox> Oops.
09:20:37 <jgrimes> beelsebob, I was fairly pleased with both actually. I've been meaning to find some more time to play around with HAppS, since it is a fairly complete server infrastructure and thus very neat. :)
09:20:55 <beelsebob> what sort of stuff needs set up to get HAppS working?
09:21:02 <beelsebob> is it just an apache plug in?
09:21:34 <dmn> hm
09:21:36 <dmn> ok thanks
09:21:41 <jgrimes> beelsebob, no, HAppS is a standalone server
09:21:56 <beelsebob> okay - and it deals with all web requests?
09:22:06 <beelsebob> does it become impossible to use a different server for http?
09:22:17 <jgrimes> beelsebob, no, you can use another server on another port
09:22:27 <xerox> dmn: that, or pattern  matching.
09:22:27 <beelsebob> okay
09:22:33 <jgrimes> or, I'm sure if you are running apache there is a way to forward requests to it, but I haven't tried that
09:22:49 <beelsebob> so really HAppS should be set up on a non-standard http port and run completely seperately
09:22:59 <beelsebob> probably with transparent forwarding
09:23:38 <jgrimes> beelsebob, if you have need for apache being the default, yes thats probably the best solution :)
09:24:01 <beelsebob> well - I'd be hosting it on a server that uses Apache for a lot of other things
09:24:01 <xerox> > let peel = (>>= blade) where blade '\t' = []; blade x = [x] in peel "a\tb\tc\td"
09:24:03 <lambdabot>  "abcd"
09:24:13 <beelsebob> so that would be the only way to do it by the sounds of it
09:24:20 <jgrimes> beelsebob, yeah, in that case
09:24:25 <ndm> beelsebob: what are you trying to do? which project?
09:24:28 <araujo> :-)
09:24:32 <xerox> dmn: -^ example of pattern matching
09:25:59 <beelsebob> ndm: I'm trying to get a guild website for WoW running
09:26:09 <beelsebob> we're using a completely different system from all the other guilds
09:26:17 <beelsebob> (because it sucks for anyone with real work to do)
09:26:22 <beelsebob> so I have to code it
09:26:50 <ndm> beelsebob: cool :)
09:27:08 <beelsebob> we appear to have stirred up a lot of interest on our server
09:27:58 <beelsebob> mostly by not using DKP
09:29:47 <dmn> is isAlphaNum the opposite of isSpace ?
09:29:57 <dmn> err
09:30:04 <dmn> no wait
09:30:14 <dmn> yeah
09:30:29 <dmn> that should be it
09:30:34 <ndm> > (isAlphaNum ':', isSpace ':')
09:30:36 <lambdabot>  (False,False)
09:30:45 <ndm> dmn: no ^^
09:30:50 <dmn> hm
09:30:58 <dmn> what is the opposite then ?:)
09:31:02 <ndm> not . isSpace is the opposite
09:31:22 <ndm> @scheck \x -> isAlphaNum x /= isSpace x
09:31:24 <lambdabot>  add an instance declaration for (Serial Char)
09:31:25 <lambdabot>   In the definition of `pvf...
09:31:30 <ndm> @qcheck \x -> isAlphaNum x /= isSpace x
09:31:32 <lambdabot> Maybe you meant: check scheck
09:31:37 <ndm> @check \x -> isAlphaNum x /= isSpace x
09:31:39 <lambdabot>  Falsifiable, after 0 tests: '\1076544'
09:39:28 <Pupeno> lisppaste2: url
09:39:29 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
09:40:22 <lisppaste2> Pupeno pasted "Naive String replace" at http://paste.lisp.org/display/29332
09:40:48 <Pupeno> Is there any obvious problem with that naive String replace function (aside inefficiency) ?
09:44:44 <araujo> heya
09:44:49 <araujo> oh, off to eat!
09:45:34 <lisppaste2> ex0r pasted "n-ary tree find children" at http://paste.lisp.org/display/29333
09:47:25 <ex0r> any help with that little snippet?
09:47:58 <Igloo> what sort of help?
09:48:03 <ex0r> map (children search) lis is the issue, I just cant figure out how to work it
09:48:39 <ex0r> *** Type : [Maybe [a]]
09:48:39 <ex0r> *** Does not match : Maybe [a]
09:48:47 <yaxu> dons: i've started blogging http://doc.gold.ac.uk/~ma503am/alex/haskellmusic
09:48:52 <lambdabot> Title: Haskell music | Alex McLean, http://tinyurl.com/y75x5u
09:48:54 <yaxu> dons: will add more detail later this week
09:48:57 <ex0r> I cant figure out how to get rid of the list map makes so I can return it
09:48:59 <dylan> gah, I hate it when
09:49:05 <dylan> I do that.
09:49:11 <jgrimes> ex0r, yeah, you are going to have a list of Maybes, rather than a list in a Maybe
09:49:17 <xerox> yaxu: cool
09:49:35 <ex0r> yeah I just cant figure out how to switch it back to what I want
09:49:45 <jgrimes> ex0r, have a look at sequence
09:50:49 <Igloo> ex0r: catMaybes might be what you want, but I'm not sure what your distinction between Just [] and Nothing is
09:52:38 <ex0r> hmm
09:53:06 <jgrimes> yeah. sequence is going to give Nothing if you have even one Nothing in the list
09:53:33 <jgrimes> so that may not be what you want
09:53:46 <xerox> yaxu: that paper has an interesting name, is it possible to understand it without any kind of prior "proper" musical knowledge?
09:53:46 <ex0r> well by definition I shouldnt have any nothings in the list;
09:54:15 <ex0r> actually
09:54:22 <ex0r> maybe I would :S
09:54:28 <jgrimes> > sequence [Just 1, Just 2, Just 3]
09:54:29 <lambdabot>  Just [1,2,3]
09:54:31 <jgrimes> > sequence [Just 1, Just 2, Nothing]
09:54:32 <lambdabot>  Nothing
09:54:48 <ihope> > catMaybes [Just 1, Just 2, Nothing]
09:54:50 <lambdabot>  [1,2]
09:54:56 <jgrimes> :D
09:55:15 <ex0r> there should never be nothing in the same list because nothing would only occur if at any given level there were no nodes
09:55:31 <Pupeno> I do IO.hPutStrLn output "" and instead of ending with "" on output, I end up with plain "\220\222\220\222\220\222\220\222" (yes, plain, not scaping, I mean, there's an ascii backslash, three numbers, etc). What am I doing wrong here ?
09:55:35 <ex0r> a node cant have a child of "Empty" if it already has other Leaf/Nodes
09:55:45 <ex0r> but yes I see what you mean
09:55:50 <xerox> ?type let catBaybes xs = [x | (Just x) <- xs] in catMaybes
09:55:52 <lambdabot> forall a. [Maybe a] -> [a]
09:56:11 <Igloo> ex0r: I think your datastructures and/or types are wrong, but it depends exactly what you're trying to do
09:56:55 <xerox> Pupeno: I don't think GHC supports unicode literals in source files.
09:57:05 <ihope> Pupeno: sure you didn't accidentally "show" it somewhere?
09:57:43 <ex0r> unfortunately i've already written most of the other functions I need based on that structure :O
09:58:12 <jgrimes> GHC supports UTF-8 in source files as of 6.6 iirc
09:58:13 <ex0r> im sure I can make an (albeit probably messy) work around
09:58:36 <Pupeno> It is not even the proper unicode code points (8592 and 8594) and even if I write "\8592\8594..." I get the same "\220\222..."
09:58:58 <Pupeno> xerox: doesn't it support it from 6.6 ? I am running 6.6. Writting it as scaped numbers doesn't help.
09:59:10 <Pupeno> ihope: I don't think so, but I can make an even simpler testcase.
09:59:23 <yaxu> xerox: definitely -- i don't have any proper musical knowledge
09:59:37 <xerox> Pupeno: I don't know about 6.6 yet
09:59:42 <jgrimes> I was able to use Greek letters in source files for GHC 6.6, for what it's worth
09:59:45 <xerox> yaxu: wow. I'll take a look.
09:59:49 <yaxu> xerox: and it's not based on western music anyway
09:59:53 <xerox> jgrimes: wow!
10:00:02 <SimonRC> How's the new newsgroup propogating?  We haven't got it here in dur.ac.uk yet.
10:00:07 <yaxu> right, off to eat + see some fireworks
10:00:15 <SimonRC> you eat fireworks?
10:00:21 <SimonRC> :-P
10:00:37 <yaxu> right, off to eat + (see some fireworks)
10:03:18 <lisppaste2> ex0r annotated #29333 with "more" at http://paste.lisp.org/display/29333#1
10:03:27 <Pupeno> oh, it's not ascii "\220", it's a char... but not the right one.
10:03:43 <ex0r> that annotation is what I started with
10:04:05 <ex0r> works fine, but obviously only works from the top node of a tree
10:04:25 <ex0r> I was trying to recurse down a tree, find the correct node, then do it
10:04:25 <ex0r> not sure if my datatype is restricting that
10:06:19 <jgrimes> ex0r, so in your later version, what is the "search" for?
10:06:22 <Pupeno> ok, maybe its just emacs handling Unicode improperly... wouldn't be the first time.
10:06:47 <ex0r> search basically relates to the "a" of tree a
10:07:15 <ex0r> trying to find a node on the tree who's "a" value matches search
10:07:25 <jgrimes> ok
10:07:41 <ex0r> then just grab its children and feed them back
10:08:00 <ex0r> of course, there is a problem of if search isnt found, which is why its Maybe
10:08:19 <jgrimes> so you are trying to search for this value, rather than just return the children as the comments say?
10:08:27 <ex0r> both
10:08:31 <jgrimes> o.o
10:08:46 <ex0r> find them value, return its children if found, otherwise return nothing :D
10:08:48 <jgrimes> you want the children of the node that matches the string?
10:08:51 <ex0r> the*
10:08:52 <jgrimes> ok.
10:08:57 <ex0r> yes :P
10:09:23 <ex0r> its always the damn recursion that gets me, I never learn :O
10:09:29 <Pupeno> lisppaste2: url
10:09:29 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
10:10:14 <lisppaste2> Pupeno pasted "Unicode arrows" at http://paste.lisp.org/display/29334
10:11:15 <Pupeno> No, its not Emacs. I confirmed with Firefox. The source code contains the right characters but the output doesn't.
10:11:46 <xerox> yaxu :(
10:11:59 <lisppaste2> Pupeno annotated #29334 with "Output" at http://paste.lisp.org/display/29334#1
10:12:13 <xerox> SimonRC: why is the news group born?
10:12:44 <jgrimes> ex0r, so what is your problem now? can you not use catMaybes?
10:13:29 <ex0r> im just reading up on it, I hope so
10:14:01 <jgrimes> ex0r, ok :)
10:14:19 <ex0r> catMaybes returns a list does it?
10:14:32 <jgrimes> yes
10:14:37 <ex0r> if so wont I end up with a [[a]] if I wrap it round map
10:14:44 <ex0r> or am I not udnerstanding
10:15:19 <ex0r> ironictype
10:15:19 <jgrimes> @type catMaybes
10:15:19 <lambdabot> forall a. [Maybe a] -> [a]
10:15:19 <jgrimes> you are going to have a list of Maybes
10:15:19 <jgrimes> right?
10:15:22 <ex0r> yes
10:16:10 <jgrimes> so, catMaybes returns a list [a] from a list [Maybe a].
10:16:29 <xerox> YEs.
10:16:30 <ex0r> ah
10:18:15 <Pupeno> putStrLn destroy the Unicode characters.
10:19:52 * ex0r[afk] brainFood
10:29:24 <palomer> my screen's busted
10:29:37 <xerox> @palomer
10:29:42 <lambdabot> Pfft
10:29:42 <palomer> so I'm using this 14.5 inch
10:29:42 <palomer> CRT
10:29:52 <palomer> this brings me wayyyy back
10:33:43 <nothingmuch> @karma+ dons
10:33:44 <lambdabot> dons's karma raised to 81.
10:33:53 <nothingmuch> for making lambdabot also respond to @moosages
10:34:34 <jgrimes> @moosages
10:34:35 <lambdabot> You don't have any new messages.
10:34:39 <jgrimes> :p
10:35:44 <palomer> @palomer
10:35:44 <lambdabot> Hrmph, looks like I killed the channel
10:43:09 <palomer> a bigger screen is such an advantage
10:43:14 <jgrimes> true
10:43:19 <palomer> for example, the type is so small I can't see what I'm typing
10:45:02 <xerox> dons: ping
10:46:35 <Pupeno> When I putStr a string and there's a char over 255 it just wraps over ASCII instead of using Unicode.
10:46:46 <sjanssen> Pupeno: check you email ;)
10:46:51 <sjanssen> s/you/your
10:47:01 <xerox> Pupeno: there is some UTF-8.hs floating around I think, maybe it can be of help?
10:47:05 <fons> hi all
10:47:29 <Pupeno> sjanssen: So far nothing here, but I'll keep cheking. Thank you.
10:48:24 <sjanssen> Pupeno: ah, I sent it about 20 min. ago.  Here's a relevent quote "The problem is that GHC's output functions only print the lowest 8 bits of each code point.  To print these higher code points, you'll need to translate your [Char] into a byte encoding that your terminal will understand (most likely UTF-8)."
10:48:55 <Pupeno> sjanssen: yes, I've made another test that lead me to that conclution (I've sent it some minutes ago). Thank you.
10:49:06 <sjanssen> and like xerox pointed out, there are such translators in the wild.  I'm sure someone will respond to your message with some help soon
10:50:20 <sjanssen> Pupeno: http://repetae.net/repos/jhc/UTF8.hs -- like this
10:53:56 <xerox> sjanssen: and then what you use to actually display the byte encoding?
10:54:28 * Pupeno has the same question.
10:54:32 <sjanssen> @hoogle [Word8] -> IO ()
10:54:33 <lambdabot> No matches, try a more general search
10:54:47 <sjanssen> @hoogle Handle -> [Word8] -> IO ()
10:54:48 <lambdabot> No matches, try a more general search
10:55:06 <Pupeno> @hoogle Word8 -> IO ()
10:55:07 <lambdabot> No matches, try a more general search
10:55:17 <palomer> every time you run an IO (), the world changes
10:55:26 <Pupeno> @hoogle Handle -> Word8 -> IO ()
10:55:28 <lambdabot> No matches, try a more general search
10:55:30 <xerox> palomer: your world changes
10:55:44 <Pupeno> @hoogle Word8 -> Char
10:55:45 <lambdabot> No matches, try a more general search
10:55:47 <sjanssen> hmm, I thought there was such a function, but it looks like all the binary IO functions expect pointers
10:56:00 <sjanssen> I bet I can code one up in under 4 min.
10:56:37 <Pupeno> Why is that all my projects end up in Binary IO... its a course.
10:56:37 <Pupeno> it's.
10:59:54 <sjanssen> @where paste
10:59:54 <lambdabot> http://paste.lisp.org/new/haskell
11:00:20 <lisppaste2> sjanssen pasted "hPutBytes :: Handle -> [Word8] -> IO ()" at http://paste.lisp.org/display/29338
11:01:05 <mauke> > fst (fix (\ ~(e', o') -> (\n -> if n == 0 then True else o' (n - 1), \n -> not (e' n)))) 42
11:01:07 <lambdabot>  True
11:01:38 <sjanssen> @pl hPutBytes h xs = withArray xs (\p -> hPutBuf h p (length xs))
11:01:40 <lambdabot> hPutBytes = ap withArray . (. length) . flip . hPutBuf
11:02:54 <Pupeno> sjanssen: thank you.
11:03:10 * sjanssen forages for lunch
11:05:04 * Itkovian gives sjanssen a gun
11:06:55 <xerox> mauke++
11:07:22 <mauke> hmm?
11:09:23 * SamB tries to figure out how you implement delimited continuations
11:09:58 * SamB tries using the ADT method to gain insight into the nature of the problem
11:10:10 <mauke> what's a delimited continuation?
11:10:21 <SamB> well
11:10:26 <pkhuong> mauke: you capture a part of the stack instead of the whole stack.
11:10:41 <SamB> I was looking at this article
11:10:43 <SamB> http://blog.moertel.com/articles/2005/09/13/scope-herding-with-delimited-continuations
11:10:43 <mauke> wait, what stack?
11:10:45 <pkhuong> so you get a function instead of something weirder (:
11:10:48 <lambdabot> Title: Scope herding with delimited continuations, http://tinyurl.com/uzce6
11:11:04 <SamB> and I came up with this typeclass:
11:11:06 <SamB> class Monad m => MonadDelim m where
11:11:07 <SamB>     reset :: m a -> m a
11:11:07 <SamB>     shift :: ((a -> m b) -> m b) -> m a
11:12:04 <mauke> .oO( http://haskell.org/hawiki/ContinuationsDoneRight )
11:12:06 <lambdabot> Title: ContinuationsDoneRight - The Haskell Wiki, http://tinyurl.com/yyafab
11:13:00 <SamB> hmm?
11:13:06 <SamB> oh, btw...
11:13:17 <SamB> @wiki MonadCont done right
11:13:18 <lambdabot> http://www.haskell.org/haskellwiki/MonadCont done right
11:13:26 <mauke> that's where I've seen this shift/reset stuff
11:16:53 <xerox> Somebody should save that page putting it on the new wiki, maybe with some insightful explanation? :)
11:16:59 <ndm> how do i get a copy of the Haskell XML Toolbox?
11:17:13 <ndm> @where hxt
11:17:13 <lambdabot> http://www.fh-wedel.de/~si/HXmlToolbox/
11:17:18 <ndm> the link seems to be down :(
11:17:48 <SamB> xerox: I put a copy on the page. Hopefully the original authors intended (or wished) it to go in the library and so had it under an implicit MIT license?
11:17:51 <SamB> er.
11:17:54 <SamB> on the new wiki.
11:18:16 <SamB> the *real* url is http://www.haskell.org/haskellwiki/MonadCont_done_right though
11:18:19 <lambdabot> Title: MonadCont done right - HaskellWiki, http://tinyurl.com/ucttc
11:22:37 <musasabi> Is there a function like splitBy :: (a -> Bool) -> [a] -> [[a]] - split into subsequences using the predicate to test for a separator.
11:23:03 <_dolio> ?type breakBy
11:23:05 <lambdabot> Not in scope: `breakBy'
11:24:48 <_dolio> > break isSpace "This is a sentence."
11:24:50 <lambdabot>  ("This"," is a sentence.")
11:24:53 <xerox> @let splitBy p = unfoldr (\xs -> case (break p xs) of ([],_) -> Nothing; (xs,[]) -> Just (xs, []); (xs,ys) -> Just (xs, tail ys))
11:24:54 <lambdabot> Defined.
11:25:00 <xerox> > L.splitBy (' '==) "like this one, which is cute."
11:25:01 <lambdabot>  ["like","this","one,","which","is","cute."]
11:25:37 <mauke> > L.splitBy (' ' ==) "  a  b  c  "
11:25:39 <lambdabot>  []
11:25:46 <xerox> Pfft.
11:25:47 <mauke> failed
11:27:02 <palomer> gah!
11:27:06 * palomer kills latex
11:28:14 <_dolio> @let splitBy2 p = filter (not . p . head) . groupBy ((==) `L.on` p)
11:28:15 <lambdabot> <local>:2:53: Not in scope: `L.on'
11:28:19 <musasabi> xerox: thanks.
11:28:43 <_dolio> @let on f g a b = (f a) `g` (f b)
11:28:44 <lambdabot> Defined.
11:28:48 <_dolio> @let splitBy2 p = filter (not . p . head) . groupBy ((==) `L.on` p)
11:28:48 <lambdabot> <local>:3:60:     Expecting a function type, but found `t_a1RT'       Expecte...
11:29:49 <palomer> hrmph
11:29:53 <palomer> to change latex packages
11:29:56 <palomer> or not to change latex packages
11:29:58 <palomer> that is the question
11:30:00 * palomer kills latex
11:30:07 <palomer> oh my god
11:30:18 <palomer> I started shacking my legs again
11:30:24 <palomer> slike a child does
11:30:40 <_dolio> Oops.
11:30:51 <_dolio> @let on f g a b = g a `f` g b
11:30:51 <lambdabot> <local>:3:15:     Occurs check: cannot construct the infinite type: t = t -> ...
11:31:02 <_dolio> @unset on
11:31:02 <lambdabot> Unknown command, try @list
11:31:03 <musasabi> xerox: just changing the first arm of the unfoldr-case exp to ([],[]) -> Nothing, solves the problems.
11:31:07 <_dolio> Bah.
11:31:17 <xerox> musasabi: great!  /me takes note
11:31:21 <_dolio> @unlet on
11:31:21 <lambdabot>  Parse error
11:41:31 <palomer> holy crap that's ugly
11:41:33 <palomer> but, c'est la vie
11:54:03 <mauke> how do I combine continuations, IO and state in a single monad?
11:54:33 <ihope> What do you want to do?
11:54:51 <mauke> write a do-while loop in haskell
11:55:04 <ihope> Can't you use plain IO for that?
11:55:25 <ihope> doWhile :: IO Bool -> IO a -> IO [a]
11:55:39 <mauke> I want to do it with setjmp/longjmp
11:55:43 <integral> mauke: StateT + ContT over IO
11:55:46 <palomer> IO rocks your world
11:55:53 <integral> monad transformers are simple really, honest
11:56:04 <mauke> I haven't used them before
11:56:21 <integral> @kind Control.Monad.Cont.ContT
11:56:36 <palomer> monad transformers aren't _that_ easy
11:56:45 <lambdabot> * -> (* -> *) -> * -> *
11:56:47 <palomer> they can be quite tricky sometimes
11:56:54 <integral> mauke: The key bit is that StateT and ContT don't commute in this case, so you need to decide if your state will be saved/restored by your set/longjmps, or preserved.
11:57:05 <mauke> let me think
11:58:50 <mauke> I guess it should be saved/restored
11:59:27 <palomer> you're all nuts!
11:59:56 <integral> o_O
12:00:20 <ihope> doWhile :: IO Bool -> (a -> IO (a,b)) -> a -> IO (a,[b]), even...
12:00:34 <ihope> Uh oh, netsplit.
12:00:34 <mauke> it should be easy: loop entry puts the current continuation on a stack, loop restart pops and invokes
12:03:56 <ihope> Yay, unsplit.
12:07:59 <SamB> hmm. is it just me or would GNTs be nice? (i.e., gnewtypes)
12:08:22 <edwardk> ?
12:09:00 <SamB> i.e. newtype Delim a where Delim :: ((a -> Delim b) -> b) -> Delim a
12:09:12 <palomer> hrmph
12:09:13 <edwardk> ahh
12:09:14 <palomer> 7 pages and counting
12:09:16 <palomer> theses suck.
12:09:27 * araujo now wonders what to do wth this existential type
12:10:18 <edwardk> not sure i see the point, if it only has one constructor the result type shouldn't be more specific than the non-generic version.
12:10:47 <SamB> well, it doesn't want me using out-of-scope tyvars otherwise :-(
12:11:01 <palomer> :-(
12:11:22 <edwardk> ah hrmm
12:11:39 <edwardk> can't just give in and make it a data?
12:11:47 <SamB> well yes
12:13:26 <mauke> ok, now I'm confused as to what the type of my blocks should be
12:14:39 <SamB> okay, that doesn't really work too well anyway
12:24:51 <lisppaste2> ex0r pasted "-" at http://paste.lisp.org/display/29342
12:25:04 <ex0r> does that first function look right? I'm getting errors
12:25:40 <ndm> ex0r: runtime or compile time errors? what error message?
12:26:08 <ex0r> *** Type : [Maybe [a]]
12:26:08 <ex0r> *** Does not match : Maybe [a]
12:26:20 <ex0r> I had this error before but it seems to have come back
12:26:20 <ndm> ex0r: the full complete error
12:26:28 <ndm> ex0r: and which line does it point to
12:26:47 <ex0r> *** Term : Just (catMaybes (map (children search) lis))
12:26:47 <ex0r> *** Type : Maybe [[a]]
12:26:47 <ex0r> *** Does not match : Maybe [a]
12:26:47 <ex0r> *** Because : unification would give infinite type
12:27:06 <ex0r> type error in conditional etc
12:27:19 <ndm> @type catMaybes
12:27:20 <sjanssen> @hoogle catMaybes
12:27:43 <ex0r> I dont see why its a [[a]] and not just [a]
12:27:53 <ndm> Maybe.	catMaybes	:: [Maybe a] -> [a]
12:28:08 <ex0r> seeing as map returns a list, catMaybes takes a list and returns one
12:28:13 <ex0r> :S
12:30:41 <ndm> ex0r: whats the type of children?
12:32:00 <ex0r> Maybe [a]?
12:32:07 <sjanssen> ex0r: I think you want to concat the result of catMaybes
12:34:08 <lambdabot> forall a. [Maybe a] -> [a]
12:34:10 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
12:34:26 <sjanssen> (map (children search) lis) :: [Maybe [a]]
12:34:32 <mauke> children :: Maybe [a]]; -> map :: [Maybe [a]]; -> catMaybes :: [[a]]; -> Just :: Maybe [[a]]
12:34:35 <sjanssen> welcome to the conversation, lambdabot
12:35:19 <ex0r> htm
12:35:20 <ex0r> hrm*
12:35:46 <ex0r> concat is indeed what I need by the looks of it
12:36:30 <mauke> whoa, lift (lift (print 42))
12:38:01 <ex0r> hmm, works but I seem to have coded out one of my requirements in the process
12:38:23 <ex0r> if the search param is not found, I wanted to see if I could make it return nothing
12:38:28 <ex0r> instead of Just []
12:38:39 <ex0r> I can see why it doesnt, I just need to figure out how to change it
12:45:00 <mauke> @hoogle lift
12:45:01 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m a
12:45:01 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
12:45:01 <lambdabot> Language.Haskell.TH.Syntax.lift :: Lift t => t -> Q Exp
12:45:27 <mauke> why isn't lift magical :(
12:46:19 <sjanssen> mauke: you could write a magical lift, but it'd require overlapping instances
12:56:10 <ihope> Magical?
12:57:07 <ihope> Let's have a Magic monad.
12:57:47 <ihope> data Magic a = Mundane a | Magic
12:58:18 <ihope> Except we need more than that, don't we?
12:58:35 <ihope> data Magic a = Mundane a | Magic (FairyDust -> DragonScales -> Incantation -> IO a)
12:59:09 <mauke> I want to be able to write lift $ whatever instead of lift $ lift $ lift $ whatever
12:59:44 <ihope> Oh.
12:59:46 <sjanssen> mauke: maybe you can do something like the MonadFoo classes (MonadState, etc.)?
13:00:02 <ihope> lift2, lift3, etc.?
13:02:39 <ihope> And we need some way of creating FairyDust and DragonScales, don't we?
13:03:20 <edwardk> mauke: liftIO is a little magical it goes all the way inside
13:03:33 <ihope> killDragon :: Warrior -> IO (Maybe DragonScales)
13:03:47 <ihope> Let's see you do that in Java!
13:04:03 <edwardk> you can make liftState and liftReader, etc to correspond and find the nearest MonadState or MonadReader
13:04:37 <dolio> There's MonadBase on the wiki somewhere that does lifts like that for a lot of things.
13:05:35 <sjanssen> edwardk: only problem with that approach is that O(mn) instances are needed
13:06:04 <sjanssen> where m is the number of transformers and n is the number of lifting classes
13:08:01 <edwardk> sjanssen: heh well, i would guess that there should be some form of way to do it via MPTCs that hasn't been done yet
13:08:31 <sjanssen> edwardk: I've attempted that, but it seems it requires overlapping/undecidable instances
13:08:48 <edwardk> undecidable at least
13:09:59 <mauke> ok, I think I got setjmp/longjmp working
13:10:22 <mauke> now all I have to do is write functions to manage the context stack
13:10:35 <ihope> Wait, you're writing functions setjmp and longjmp?
13:11:27 <mauke> yes
13:12:03 <ihope> Are you going to implement labels and goto, too?
13:12:58 <mauke> well, goto is essentially longjmp
13:13:51 <ihope> Are there multiple jump buffers?
13:14:17 <mauke> yes, each setjmp returns a buffer
13:14:30 <ihope> I see.
13:40:54 <Pupeno> If I do func (x:xs) | (fromIntegral x) < 10 = ...; | (fromIntegral x) < 20 = ...; will ghc optimize those fromIntegral calls ?
13:41:26 <norpan> no
13:41:41 <norpan> if you mean it will only do one call; no it won't
13:42:10 <Pupeno> ok. Thanks.
13:45:01 <mauke> oh, damn. I'm lost in type errors
13:45:56 <Botty> this probably illuminates my incomplete comprehension of haskell's type system, however, why can't I do this:
13:46:11 <Botty> data Expr = Op Char | Application Op Expr Expr
13:46:54 <mauke> that doesn't make sense
13:47:26 <mauke> type Op = Char; data Expr = Application Op Expr Expr;
13:48:05 <dolio> It's because Op is a constructor function: Char -> Expr
13:48:08 <dolio> Not a type.
13:48:31 <Botty> right, but I can't limit a constructor to only accept types constructed by a particular constructor?
13:48:59 <dolio> No.
13:49:00 <mauke> all constructors construct the same type; that's the point
13:49:14 <mauke> if you want a different type, make a different type
13:49:31 <Botty> ok
13:49:46 <dmn> is the sml-style "case x of a | b => c" (as opposed to "case x of a => c | b => c") syntax present in haskell ?
13:49:55 <dmn> in some similar form at least
13:50:08 <Heffalump> dmh: no
13:50:13 <dmn> :/
13:50:43 <Heffalump> case x of a -> var ; b -> var where var = c
13:52:18 <ihope> data ExprTree = Application Char ExprTree ExprTree; data Expr = Op Char | Tree ExprTree
13:52:24 <Heffalump> that's quite close but your where clause will end up beneath all the cases
13:52:28 <Heffalump> which isn't as readable
13:52:52 <Heffalump> oh, and you'd have to pass any bound values as parameters, dunno if that would happen in SML too
13:55:38 <dmn> basically the answer is no ;]
13:56:50 <dolio> I believe it's been suggested before.
13:56:54 <kzjs> I have the following data declaration:  data TTFTree a = Empty | Node (TTFTree a) a (TTFTree a) a (TTFTree a) a (TTFTree a) deriving Show    but when I try and use it in a function:   testing123 :: TTFTree   it says "Illegal type in type expression",  any ideas why?
13:57:03 <dolio> Although "a | b" probably wouldn't be the syntax.
13:57:16 <dolio> Since that's already the syntax for case with boolean guards.
13:57:34 <mauke> kzjs: TTFTree isn't a type
13:58:10 <astrolabe> You need TTFTree a, or TTRTree Int, or something like that
13:59:01 <Botty> hmm, well I'll just only stick Ops in Application's first arg
13:59:29 <ihope> kzjs: TTFTree isn't a type, but, say, TTFTree Bool is.
13:59:54 <ihope> ...Yeah, like they said.
14:00:12 <lennart> howdy all
14:02:32 <astrolabe> hi lennart
14:34:09 <genneth> is there anyone about to help with a really newbie problem with happs?
14:39:41 <dons> moin
14:39:47 <dons> ?users
14:39:48 <lambdabot> Maximum users seen in #haskell: 265, currently: 232 (87.5%), active: 27 (11.6%)
14:40:33 <musasabi> genneth: feel free to ask.
14:41:48 <genneth> it's really silly; i can't seem to get the examples to run correctly
14:41:49 <genneth> :S
14:42:41 <genneth> they start, but any tcp connection to them get dropped immediately
14:43:01 <genneth> netstat shows them as listening on the correct port
14:43:10 <musasabi> On the correct port? (what OS / GHC / ... )
14:43:43 <genneth> strace, however, shows them being interrupted by SIGALARM constantly
14:43:50 <genneth> OS: fc6, GHC: 6.6
14:44:04 <musasabi> SIGALARM is normal GHC behaviour.
14:44:18 <genneth> okay; good to eliminate that
14:46:54 <musasabi> genneth: can you try the httpd.hs example (should listen on port 5000 automatically) ?
14:47:10 <musasabi> that should isolate the reason much further.
14:47:50 <genneth> it also doesn't work
14:47:57 <musasabi> (this seems like a new issue, most of the testing is done on GHC 6.6 + Debian, but even Windows works)
14:48:07 <musasabi> hmm, how does it fail?
14:48:24 <genneth> connecting to port 5000 with nc just results in the tcp connection being closed immediately
14:48:37 <genneth> in firefox it claims to not be able to make a connection with the server
14:48:42 <genneth> in strace, nothing can be seen
14:48:56 <sebell> genneth: netstat?
14:49:26 <genneth> genneth@ishtar ~/src/HAppS % netstat -tnap | grep httpd
14:49:26 <genneth> (Not all processes could be identified, non-owned process info
14:49:26 <genneth>  will not be shown, you would have to be root to see it all.)
14:49:26 <genneth> tcp        0      0 0.0.0.0:5000                0.0.0.0:*                   LISTEN      7605/httpd
14:49:36 <musasabi> genneth: strace -f -e network -e signals= ./httpd
14:50:11 <genneth> genneth@ishtar ~/src/HAppS/examples % strace -f -e network -e signals= ./httpd
14:50:11 <genneth> Process 7685 attached
14:50:11 <genneth> [pid  7684] socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 5
14:50:11 <genneth> [pid  7684] setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
14:50:11 <genneth> [pid  7684] bind(5, {sa_family=AF_INET, sin_port=htons(5000), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
14:50:11 <genneth> [pid  7684] listen(5, 128)              = 0
14:50:13 <genneth> [pid  7684] accept(5, 0x57e180, [16])   = -1 EAGAIN (Resource temporarily unavailable)
14:50:15 <genneth> Process 7686 attached
14:50:26 <genneth> connecting w/ nc or browser does nothing to that strace output
14:51:39 <musasabi> sounds very weird. has anything with Haskell and sockets worked with your machine?
14:52:07 <genneth> hmm
14:52:19 <genneth> it's just been installed
14:52:25 <genneth> so i haven't tried yet
14:52:59 <chessguy> you could try dons' IRC bot code
14:53:30 <musasabi> I can give a short example code (which is like the HAppS one) in 5min.
14:53:50 <genneth> just tried a port scanner that i had lying about
14:53:52 <genneth> worked
14:54:01 <genneth> though that only tests the client side stuff; no listen, etc.
14:54:56 <chessguy> try this code: http://haskell.org/haskellwiki/Roll_your_own_IRC_bot/Source
14:54:59 <lambdabot> Title: Roll your own IRC bot/Source - HaskellWiki, http://tinyurl.com/fdzc5
14:55:24 <chessguy> that should work out of the box
14:56:47 <musasabi> genneth: http://youzen.b2.fi/~musasabi/s.hs <- does this work for you.
14:58:56 <musasabi> genneth: remember to give it -threaded (same as with the HAppS examples by default) so it tests the same thing.
14:59:12 <genneth> even w/o threaded, it doesn't work...
14:59:12 <genneth> :S
14:59:14 <genneth> oh dear
14:59:16 <genneth> genneth@ishtar ~/Programming % strace -f -e network -e signals= ./s
14:59:17 <genneth> socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 3
14:59:17 <genneth> setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
14:59:17 <genneth> bind(3, {sa_family=AF_INET, sin_port=htons(5000), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
14:59:17 <genneth> listen(3, 128)                          = 0
14:59:18 <genneth> accept(3, 0xa7e040, [16])               = -1 EAGAIN (Resource temporarily unavailable)
14:59:43 <genneth> is that failed accept supposed to be there?
15:00:09 <musasabi> that EAGAIN is ok. Let me paste what it produces for me.
15:01:02 <musasabi> http://youzen.b2.fi/~musasabi/s.txt
15:02:01 <genneth> hmm
15:02:19 <genneth> for me, it just doesn't do anything when i connect to it
15:02:34 <musasabi> It sounds like a GHC problem rather than HAppS related (unless the code in s.hs is broken in some way - it is essentially the same thing that HAppS uses)
15:02:42 <genneth> indeed
15:03:15 <genneth> actually, it looks like it might be just be my computer
15:03:22 <genneth> ghc 6.4 produces the same problems
15:03:32 <genneth> i'm almost certain i don't have a firewall...
15:04:08 <genneth> not on loopback, anyway
15:06:30 <genneth> musasabi: thanks for the help
15:06:33 <musasabi> np
15:06:54 <musasabi> hope you find a solution. (/sbin/iptables -L -v, might be your friend)
15:13:43 <genneth> hmm
15:13:45 <genneth> interesting
15:13:54 <genneth> it works if i don't connect from my own machine...
15:14:06 * genneth goes hunting in iptables
15:14:36 * SamB doesn't think the "reset" function likes typeclasses
15:19:33 <matley> can you suggest me a book to learn haskell?
15:20:33 <xerox> The Haskell Road to Logic, Maths, and Programming is cool
17:42:12 --- topic: '["Design a #haskell tshirt - Distribute your cognition!", "Haskell - the language of ICFP winners 3 years running", "Logs: http://tunes.org/~nef/logs/haskell/"]'
17:42:12 --- topic: set by dons on [Tue Oct 31 01:30:26 2006]
17:42:54 <dons> as usual, if you want hints and advice, stick it in darcs somewhere visible
17:43:46 <coffeemug> dons: it's in darcs
17:43:57 <coffeemug> http://sources.defmacro.org/weblocks is the web server
17:44:01 <dons> great
17:44:01 <lambdabot> Title: Index of /weblocks
17:44:13 <coffeemug> and http://sources.defmacro.org/hs-record is the web framework stuff
17:44:16 <lambdabot> Title: Index of /hs-record
17:44:27 <coffeemug> you can always look at it but it's definetly not ready for public consumption :)
17:44:33 <dons> right-o
17:44:39 <coffeemug> as usual, any hints or advice is always very very welcome
17:45:01 <dons> what are you plans for it? a full scale haskell project? or tut purposes only?
17:46:04 <dons> and have you looked at HAppS
17:46:23 <coffeemug> I've looked at HAppS
17:46:35 <coffeemug> the reason I'm not reusing is that my main purpose is to learn Haskell myself
17:46:48 <dons> yep, of course.
17:46:52 <dons> the more code the merrier
17:46:54 <coffeemug> I will then publish this stuff, write a tutorial
17:47:10 <coffeemug> my ultimate goal is to quit my job and start a business
17:47:36 <coffeemug> if this stuff works out, I'll use it to write small business software
17:47:45 <coffeemug> stuff like practice management for medical offices
17:47:53 <dons> sounds promising.
17:48:11 <coffeemug> it'll probably fail miserbly
17:48:15 <dons> :)
17:48:17 <coffeemug> miserably
17:48:18 <coffeemug> :)
17:48:21 <dons> you can but try.
17:48:28 <coffeemug> exactly
17:48:42 <dons> and hope that the productivity benefits help you out
17:48:56 <coffeemug> I don't know, may be I'm an idiot and using java or RoR is a better way
17:49:14 <coffeemug> but somehow I feel I'm going in the right direction
17:49:16 <dons> what's it that galois says? something about how they end up having the client ask them to slow down delivering new code, since they get it out too fast for the client to adopt and use
17:49:20 <Smokey`> please, don't use the J word while i'm reading ;)
17:49:51 <coffeemug> dons: yeah, that's my ultimate goal
17:50:32 <Smokey`> exam, heavily oriented around J#$% in, 1 hour. sigh
17:50:35 <pkhuong-> coffeemug: if you can interface to PBX, you'd be surprised by the shoddiness of the current offerings for hotel management systems.
17:50:39 <dons> and languages with similar features in the past have provided this kind of benefit. lisp notably. and haskell has some 20 years on lisp in terms of reducing debugging time further still
17:50:58 <dons> pkhuong-: interesting!
17:51:11 <coffeemug> pkhuong-: yeah, most software in such industries is utter crap
17:51:21 <Botty> procedural has a bit of an advantage as far as debugging because you can stick in console outputs willy nilly
17:51:39 <dons> ?type Debug.Trace.trace
17:51:41 <lambdabot> forall a. String -> a -> a
17:51:42 <dons> Botty: ^^
17:51:46 <Botty> :O
17:51:59 <coffeemug> yeah, there's always unsafe IO for that stuff
17:52:04 <Botty> I suppose it doesn't modify the env, but how do you know it will be execed?
17:52:31 <dons> by understanding the flow of control though your code... ?
17:52:49 <sjanssen> Botty: by pattern matching against the value that trace returns
17:52:52 <sjanssen> or seq
17:53:06 <dons> trace "made it here" $ do continue on my merry way
17:53:26 <dons> trace "made it here" $ 1+2 -- or do something pure even
17:53:30 <Botty> ohh
17:53:50 <Botty> so you can really place it anywhere, the rest of it just acts as id sorta
17:53:54 <Botty> ?type id
17:53:55 <dons> yeah
17:53:56 <lambdabot> forall a. a -> a
17:53:59 <Botty> yeah
17:54:01 <dons> its a magic id, for debugging
17:54:12 <Smokey`> sweet :D this'll help me alot :)
17:54:28 <dons> ok. so next tutorial: Debugging Haskell: A survey of techniques ...
17:55:03 <dylan> dons: Could I pick your brain on some things re- my slang binding?
17:55:22 <coffeemug> dons: I'd really a tutorial on haskell debugging
17:56:23 * dylan is glad other people forget required words in their sentences like he does.
17:56:38 <beschmi> are there plans on having ghci-debug  (the SoC project) in ghc 6.8?
17:58:11 <coffeemug> hmm
17:58:18 <palomer> quick, someone tell me what the compose sign is
17:58:20 <coffeemug> how can I enforce strictness on a particular function argument?
17:58:35 <gzl> the compose sign?
17:58:37 <coffeemug> just put a bang?
17:58:55 <dons> dylan: go for it.
17:59:16 <dons> coffeemug, you got ghc 6.6 or 6.4.x ?
17:59:25 <coffeemug> 6.4
17:59:26 <aFlag> palomer, function composition? It's .
17:59:29 <dons> the former: f x y !z a = .... -- -fbang-patterns
17:59:43 <palomer> in latex
17:59:45 <coffeemug> but I dumped hs-plugins so I have no reson not to upgrade
17:59:46 <dons> the latter: f x y z a = z `seq` ...
17:59:49 <dylan> dons: alrighty. I'm wondering how far to "haskell flavor" this. For instance, SL_getkey returns either an int from 0..255 or 0xFFF on error... should I translate that to return Maybe CChar?
17:59:50 <dons> ok. good
17:59:58 <coffeemug> thanks
18:00:23 <dylan> (and return Nothing on the error value)
18:00:25 <palomer> darn
18:00:28 <dons> dylan: yeah, I'd do that. or Maybe Key ; type Key = Word8 ?
18:00:32 <palomer> I don't have any more printing money
18:00:34 <palomer> :(
18:00:47 <dons> or data Key = Key !Word8 | Error
18:01:02 <dons> but yes, a Maybe type (or something isomorphic to it) is the way to go
18:01:30 <dons> beschmi: yeah.
18:01:38 <dylan> The other thing is -- should I just rename the functions along the lines of the way haskell renames POSIX functions?
18:01:41 <dons> there are definitely plans. it should happen.
18:01:53 <dons> dylan: your choice, i guess.
18:01:54 <coffeemug> dons: seq enforces strict eval on a or b?
18:02:05 <dylan> dons: which is more common?
18:02:23 <coffeemug> so a `seq` b will cause strict evaluation of b?
18:02:27 <dons> coffeemug: a
18:02:48 <dons> dylan: what alternatives are you suggesting?
18:02:51 <dons> ?type seq
18:02:53 <lambdabot> forall b a. a -> b -> b
18:02:58 <dons> so force a, return b
18:03:21 <dylan> dons: well, SLsmg_init -> Slang.Screen.initialize, SLang_getkey -> Slang.getkey
18:03:37 <dylan> SLkp_getkey -> Slang.Keypad.getkey
18:03:41 <dons> yeah. the second ones look better
18:03:41 <beschmi> dons: cool
18:03:46 <dons>  and haskell people will be more likely to feel good
18:04:02 <dylan> perhaps extending this to getKey?
18:04:12 <dylan> (as camel case is the norm?)
18:04:16 <dons> yeah
18:04:22 <pkhuong-> oh, doh, how is >> textually called?
18:04:36 <dons> `then`
18:04:39 <dons> is one name
18:05:07 <pkhuong-> mm.. not a very good verb :)
18:05:25 <dons> a `then` b :)
18:05:56 <pkhuong-> (then a b) isn't a nice.
18:06:09 <dons> do a ; b
18:06:18 <dylan> dons: okay, init -> initialize is good, yes? What about for 'reset'?
18:06:26 <dons> seems ok.
18:06:32 <dons> Slang.reset, yeah?
18:06:40 <dylan> yeah. and Slang.Screen.reset
18:06:40 <dons> even Slang.init works for me
18:06:54 <dylan> well, with init, I have to import Prelude hiding (init)
18:06:55 <dons> its only the explicit namespace prefixes that i'd worry about
18:07:01 <dons> ah ture
18:07:22 <sjanssen> dylan: or import qualified Slang
18:07:32 <syntaxfree> question: aren't C structs like Haskell types?
18:07:32 <dylan> of course, I'd recommend importing these modules qualified, but it's a bit confusing if init behaves differently than normal init
18:08:12 <sjanssen> syntaxfree: I don't think C structs are nearly as expressive
18:08:14 <dylan> it isn't like slang has extensive documentation, so, I don't lose much by having slightly different names.
18:08:20 <dons> the type of C structurs are isomorphic to a bit of Haskell's type system :)
18:09:23 <dons> but, e.g. a List type in C isn't a true recursive type, nor does a struct reflect the types of its fields, like a product type might do in haskell
18:09:31 <psykotic> dons: how do you model the semantics of unions? :)
18:09:51 <dons> well, they're just sum types, yeah?
18:09:57 <dons> but with some extra weirdness?
18:09:59 <dylan> dons: hmm, for SLang_init_tty, should that be Slang.init_tty or camel cased?
18:10:02 <psykotic> they're not disjoint unions.
18:10:08 <syntaxfree> I'm asking because I'm intrigued by hungarian notation.
18:10:14 <dmead> yo dons
18:10:16 <dons> that's the "extra weirdness" :)
18:10:26 <psykotic> right but a disjoint union is not a faithful model was my point :)
18:10:28 <syntaxfree> what is this sum/product/exponential type talk?
18:10:40 <dons> dmead: hey
18:10:44 <dmead> jeffries wrote two more aritcles on my thingy
18:10:49 <dmead> cause he got so much feedback
18:10:50 <dmead> http://www.xprogramming.com/xpmag/dbcRecurringDrama.htm
18:10:54 <lambdabot> Title: Recurring Drama, http://tinyurl.com/tclzx
18:10:56 <dons> oh good.
18:10:57 <coffeemug> hmm
18:10:58 <dmead> http://www.xprogramming.com/xpmag/dbcHaskellHassle.htm
18:11:01 <lambdabot> Title: More Hassling with Haskell, http://tinyurl.com/wuc24
18:11:02 <coffeemug> seq is really useful :)
18:11:10 <dons> psykotic: well a Ptr could always be used :)
18:11:28 <syntaxfree> why is hungarian notation needed?
18:11:32 <dmead> i'm trying to convince him why the data sets need to be padded with zeros at the end
18:11:33 <dons> but I suspect there's some fairly simple encoding? my C unions are severely rusty though
18:11:35 <psykotic> dons: if you just want to embed a description, that's different, yeah.
18:11:38 <pkhuong-> psykotic: actually, it's undefined what happens if you access a different member of an union than the one that was last assigned to, so disjoint union would be ok.
18:11:48 <syntaxfree> Can't you just create a type "horizontal position" and a type "vertical position" so they're not summable by accident?
18:11:49 <psykotic> i mean you can at worst case just embed the syntax tree as a type if all you want is a description.
18:11:57 <psykotic> pkhuong-, ah, interesting.
18:14:18 <psykotic> someone needs to take these guys like ron jeffries and bob martin and gag them
18:14:41 <dons> not rigorous enough, psykotic ? feels a bit hand wavey at times
18:15:09 <psykotic> i just feel like they're full of hot air. compare to someone like ward cunningham who's actually a bad ass programmer.
18:15:34 <dons> i'm happy to see in the outside world though. even if the fundamental concepts aren't getting conveyed
18:15:41 <dons> s/see any FP/
18:15:52 <psykotic> yeah
18:15:57 <dons> it benefits us all here.
18:16:13 <pkhuong-> who are `ron jerries and bob martin'?
18:16:14 <psykotic> as long as it isn't hype (that can backfire) :)
18:16:25 <pkhuong-> ah
18:16:31 * dons hopes there's been enough research to ensure its not hype :)
18:16:44 <dons> unlike a certain hypeful language of the slow, interpreted, OO variety
18:16:50 <psykotic> hehe
18:17:04 <psykotic> you don't have to convince me, i'm just saying that overselling anything can lead to backlash
18:17:08 <dons> yeah
18:17:26 <dons> i agree. has to be moderate, and accurate at all times.
18:17:35 <dmead> haha
18:17:37 <dons> rigour is something the community does well.
18:17:41 <dmead> yea psykotic
18:17:57 <dmead> jeffries is very....
18:18:07 <dmead> up front is the polite word
18:18:08 <dmead> ah ah
18:18:09 <psykotic> all these consultant types are useless
18:18:35 <dmead> yea
18:18:50 <dmead> jeffries wrote an article on some of my code
18:18:59 <psykotic> i think guys like bob martin and ron jeffries have so deep conflicts of interest that it's hard to take them very seriously. and whenever i try to take them seriously and look at what they're really pushing, i throw up a little in my mouth.
18:19:06 <dmead> i just emailed him saying he needs to think recursivly
18:19:07 <dmead> ah ah
18:19:15 <dons> the stuff about recursion "flaws" i don't get. i mean... how hard are inductive proofs on lists...
18:19:21 <dmead> yea
18:19:30 <dons> its not like you need TDD to check this stuff...
18:19:35 <dmead> well he was sort of right
18:19:45 <dmead> my code failed, but only when it wasn't padded at the end
18:19:51 <dons> interesting, anway.
18:19:55 <dons> good workd dmead
18:19:57 <dons> dmead++
18:19:59 <dmead> tks
18:20:18 <jgrimes> lispy, ping
18:20:20 <dmead> i'll be putting up my prover for public scrutiny soon
18:20:29 <dmead> i want it to get a good pounding
18:20:36 <dons> cool
18:21:19 <kpreid___> <syntaxfree> what is this sum/product/exponential type talk?
18:21:22 <dons> i wish the 'commerical users of FP' consortium would get organised.
18:21:29 <kpreid___> syntaxfree: for an approximate understanding:
18:21:29 <dmead> hmm
18:21:31 <dmead> yea
18:21:39 <syntaxfree> I remember Ron Jeffries from the c2.com wiki.
18:21:44 <dons> it's taking too long :/ a united front from the ocaml, erlang, lisp, scheme and haskell companies would be very very useful
18:21:47 <kpreid___> syntaxfree: consider the number of possible values a type has
18:22:09 <dmead> syntaxfree: the first article is about my code
18:22:25 <dmead> http://www.xprogramming.com/xpmag/dbcHaskellBowling.htm
18:22:27 <lambdabot> Title: Haskell Bowling, http://tinyurl.com/yndnpr
18:22:30 <kpreid___> syntaxfree: Bool has 2; Ordering has 3; (Either Bool Ordering), a sum type, has 2 + 3, 5; (Bool, Ordering), a product type, has 2 * 3, 6.
18:22:46 <dmead> he kept telling me theres nothing really different from thinking interatively than recursively
18:22:47 <syntaxfree> ah.
18:22:53 <dmead> which is a crock
18:23:08 <syntaxfree> I get it :)
18:23:16 <dmead> =)
18:23:50 <dons> well, iteratively is just a special case of recursive thinking :)
18:23:51 <kpreid> syntaxfree: so since these operations on types preserve the correspondence between types and numbers, they in a sense *are* sum and product on types
18:24:09 <syntaxfree> meaning they're categorial sum and product?
18:24:25 * syntaxfree knows random bits of cat theory.
18:24:28 <kpreid> dunno. all I know about category theory I learned from Haskell. :)
18:24:36 <psykotic> mumble, mumble, cardinality is a CCC-functor from the FinSet CCC to the Nat CCC. :)
18:24:38 <kpreid> I'd imagine the answer is "YES!" but I don't know.
18:24:49 <dmead> =o
18:24:55 <dmead> i wanted to take combinatorics
18:24:59 <dmead> but it was at 9am
18:25:00 <dmead> ah ah
18:28:51 <psykotic> dmead: Nat is a category whose objects correspond to natural numbers and morphisms correspond to "less than or equal" relations. the product/coproduct/exponentials in this category correspond to the usual arithmetic notions.
18:29:47 <psykotic> it is cartesian-complete, meaning that you have products/coproducts/exponentials for all objects.
18:30:05 <syntaxfree> dmead is the Dan Mead mentioned in the article?
18:30:14 <psykotic> FinSet is a category of finite sets and mappings between sets as morphisms. it is also cartesian complete. there is a functor from FinSet to Nat that "decategories" by assigning to a set its size.
18:30:16 <coffeemug> wow
18:30:26 <psykotic> and the nice thing is that this functor preserves the product/coproduct/exponential structure
18:30:27 <coffeemug> I just implimented some basic state management for the web app
18:30:30 <coffeemug> this stuff really rocks :)
18:30:35 <coffeemug> I love haskell man
18:30:39 <dons> great
18:30:44 <coffeemug> I've never felt anything even remotely close about java
18:30:47 <coffeemug> or c/c++
18:30:52 <coffeemug> or even lisp :
18:30:53 <coffeemug> :)
18:30:58 <dons> functional programming can make you love programming again
18:31:06 <dmead> aye
18:31:07 <dmead> i am
18:31:09 <coffeemug> though lisp is still pretty cool in my book
18:31:11 <dmead> =)
18:31:21 <coffeemug> I wish there was a lazy pure lisp
18:31:21 <syntaxfree> what's the bowling scoring problem like?
18:31:22 <palomer> yeah, I love screaming at my screen after correcting my 50th type error
18:31:26 <palomer> gives me wood
18:31:38 <dmead> you wanna try it?
18:31:43 <dons> i.e. haskell without the syntax and typechecker?
18:31:57 <syntaxfree> you want a dynamic lazy language?
18:32:01 <dons> wouldn't be too hard to preprocess lazy pure lisp to a subset of haskell :)
18:32:18 <syntaxfree> if you have a dynamic lazy language s-expr syntax is trivial to implement.
18:32:19 <coffeemug> without syntax, yes
18:32:23 <coffeemug> without type checker - not sure :)
18:32:32 <dmead> o0
18:32:34 <coffeemug> yeah it is
18:32:36 <syntaxfree> you want s-expr haskell.
18:32:39 <coffeemug> may be it will be my next project :)
18:32:45 <dons> we have a couple of projects by lisp refugees to add lisp syntax as a preprocessor to ghc
18:32:51 <dons> lispy, who was working on that/
18:32:52 <psykotic> didn't sigfpe do a typeless haskell-ish language?
18:33:04 <dmead> syntaxfree: http://butunclebob.com/files/downloads/Bowling%20Game%20Kata.ppt
18:33:07 <lambdabot> http://tinyurl.com/s9o2y
18:33:08 <psykotic> i seem to recall he blogged about it
18:33:12 <homotopicus> What are the morphisms of Nat?
18:33:19 <dons> yeah, s-expr haskell. there's at least one guy working on that.
18:33:27 <dmead> it's a problem he gives to people in lots of different languages
18:33:27 <psykotic> homotopicus, less-than-or-equals relations. there is a morphism m -> n iff m <= n as numbers
18:33:41 <coffeemug> it's just so much more elegant than TH
18:33:47 <jcreigh> 01:46 <therp> how needs a lisp interpreted when GHC can take lisp stuff directly :) http://clemens.endorphin.org/liskell.png .. that thing got much bigger last weak. at the moment I'm working on a macro transformation to template haskell.
18:33:56 <dons> ah that's it
18:34:08 <homotopicus> psykotic: What does the functor from FinSet to Nat do on morphisms of finite sets?
18:34:30 <spiffy> If I have two func, f,g::Int->Int does it make any sense that f.g 16 gives a type error?
18:34:49 * dons isn't sure Liskell's an improvement syntax wise, but it sure is cool!
18:34:56 <spiffy> Couldn't match expected type `a -> Int' against inferred type `Int'
18:35:11 <kpreid> dons: wait till he has macros :-)
18:35:12 <psykotic> homotopicus, hrm, good point, it doesn't look like this is a functor if you take this structure on Nat.
18:35:16 <dons> (f. g) 16
18:35:24 <spiffy> d'oh
18:35:35 <dons> > let f = (+1) ; g = (^2) in f (g 16)
18:35:37 <lambdabot>  257
18:35:41 <homotopicus> psykotic: If you restrict to injective mappings you are okay
18:35:44 <psykotic> homotopicus, yeah
18:35:45 <dons> > let f = (+1) ; g = (^2) in f . g $ 16
18:35:47 <lambdabot>  257
18:35:47 <psykotic> but that's unnatural
18:35:55 <dons> > let f = (+1) ; g = (^2) in (f . g) 16
18:35:55 <homotopicus> But Nat is a very boring category anyway
18:35:56 <lambdabot>  257
18:36:00 <dylan> dons: here's a tought one. there's a bunch of functions with the prefix SLtt and I'm not sure what 'tt' is short for, other than it's low-level terminal functions.
18:36:00 <psykotic> yeah that's right
18:36:02 <homotopicus> well, its just the ordinal omega
18:36:03 <dons> > let f = (+1) ; g = (^2) in f . g 16 -- and wrong
18:36:04 <lambdabot>  add an instance declaration for (Num (a -> b))
18:36:05 <dylan> err, tought.
18:36:09 <psykotic> it's just the diagram for Nat as a poset
18:36:26 <dons> dylan: well you could put them in a sub module, wit the .TT. name space
18:36:27 <homotopicus> Its useful to consider omega-shaped diagrams in other categories though.
18:36:32 <syntaxfree> may I take the chance to climb on my personal soap box and say that Ron Jeffries isn't Haskell's greatest enemy, it's Guido van Rossum.
18:36:33 <dons> or just leave them as is till you work out what they're good for
18:36:38 <spiffy> dons: I always impress myself. Give me as many choices as you want. I will without fail choose the one wrong one.
18:36:47 <dylan> Slang.Lowlevel? Slang.Terminal?
18:36:47 <dons> syntaxfree: heh. more guido bashing eh/
18:36:48 * syntaxfree shuts up about Guido van Rossum lest he gets banned from the channel.
18:36:54 <homotopicus> For instance, if you want some notion of "transfinite composition"
18:36:56 <jcreigh> "reduce() is evil! Make the pain stop!"
18:37:02 <dylan> dons: well, one of them is SLtt_get_terminfo
18:37:16 <dons> let the ruby guys take on guido. and the FP people can distribute, multicore and smp their way into people's homes by stealth
18:37:18 <kpreid> spiffy: clearly you need to be provided with two equally wrong choices
18:37:22 <homotopicus> Take the colimit of some functor from omega to your favorite category, and then you're in business.
18:37:22 <syntaxfree> jcreigh: he thinks FP is a matter of syntax. But I can't talk about Guido anymore.
18:37:28 <dmead> syntaxfree: who is that?
18:37:41 <spiffy> kpreid: I just go into an infite loop :P
18:37:42 <jcreigh> dmead: Creator of Python
18:37:45 <psykotic> homotopicus, what do you mean by an omega-shaped diagram? something with a "top" object?
18:37:48 <syntaxfree> the leader/creator of Python.
18:37:50 <dmead> syntaxfree: ahha yea
18:37:52 <dons> let's not. dmead, pythong guy. famous for wanting to remove fold and map from python. also famous for inventing python i suppose.
18:37:55 <dmead> syntaxfree: they stole the languagae
18:38:09 <dmead> hmm
18:38:16 <homotopicus> psykotic: Given categories C and D, a D-shaped diagram in C is a functor from D to C.
18:38:20 <dons> serisouly though, syntaxfree, old old news. don't keep bring it up :)
18:38:27 <Adamant> Dey Tuuk Our Fold!
18:38:29 <dons> unless he blogs something new on the topic.
18:38:40 <homotopicus> psykotic: This is a useful notion, because you can define limits and colimits rather slickly in this manner.
18:38:42 <syntaxfree> Okay ;)
18:38:50 <psykotic> homotopicus, right, you can take limits of arbitrary diagrams.
18:38:53 <psykotic> (well, you can try)
18:39:00 <dons> meanwhile we can busily set about running our folds and maps on the gpu
18:39:23 <psykotic> homotopicus, i was more curious about what category omega is
18:39:40 <psykotic> you mean N adjoined with the first uncountable ordinal?
18:39:42 <homotopicus> psykotic: Oh, I'm sorry... omega is the smallest infinite ordinal.
18:39:57 <psykotic> err, first infinite, not uncountalbe
18:39:58 <psykotic> yeah
18:40:05 <homotopicus> psykotic: or, N, as they say
18:40:30 <homotopicus> psykotic: The set theorists like to draw an omega instead of an N to make themselves feel special
18:40:35 <dmead> ha
18:40:38 <psykotic> yeah i see what you're staying. the general diagrams view is neat. i think i saw it in may's book.
18:40:48 <homotopicus> J. Peter May?
18:40:50 <psykotic> yeah
18:40:55 <psykotic> concise course in algebraic topology
18:40:56 <jgrimes> oh, someone mentioned 6.6 is on the debian shootout machine. Are replacement benchmarks already created?
18:41:03 <homotopicus> psykotic: I've been reading that too =)
18:41:05 <jgrimes> ghc 6.6, that is
18:41:13 <dolio> folds on the gpu?
18:41:18 <psykotic> homotopicus, terrible, terrible book if you don't already know most of the material :)
18:41:41 <homotopicus> psykotic: I had a year of algebraic topology behind me before I started.  I cut my teeth on Spanier.
18:41:42 <psykotic> i don't imagine somehow learning the rudiments of covering space theory derives a lot of enlightenment from abstract nonsense involving orbit categories.
18:41:49 <psykotic> err, someone
18:41:52 <homotopicus> psykotic: And I still find the book unreasonably hard!
18:42:03 <homotopicus> psykotic: Well, you make the connection with Galois theory that way
18:42:43 <psykotic> you can make that without going overboard with abstract nonsense :)
18:43:02 <psykotic> you can mutter something about covering spaces and galois extensions and people will probably go 'aha' to a sufficient degree to appreciate the relationship
18:43:15 <homotopicus> psykotic: Yeah but this way is actually formal...
18:43:26 <dons> jgrimes: right. there are some.
18:43:28 <dons> but we can just start.
18:43:30 <homotopicus> psykotic: Grothendieck used it to define the first homotopy group of a scheme, I believe.
18:43:31 <psykotic> right but may doesn't even try to present the intuitive notions. it's all abstract nonsense, all the time :)
18:43:32 <dons> let me find you the shared wiki page
18:44:02 <homotopicus> psykotic: I hate to break it to you, but spatial intuitions are a fiction, created by Satan.  There is only abstract nonsense =)
18:44:14 <dons> jgrimes: so i've done a few sketches, but you're _very_ welcome to start writing your own solutoins
18:44:18 <dons> competition breeds better code
18:44:24 <psykotic> may is the anti-hatcher
18:44:29 <satan> i didn't create anything, much less spatial intuitions :P
18:44:29 <homotopicus> Haha!
18:44:40 <dons> jgrimes: http://www.haskell.org/haskellwiki/Great_language_shootout
18:44:42 <lambdabot> Title: Great language shootout - HaskellWiki, http://tinyurl.com/tgujz
18:44:46 <jgrimes> dons, all right, cool deal.
18:44:47 <psykotic> i seriously cannot imagine anyone learning algebraic topology from may's book
18:44:52 <dons> jgrimes: so you can rewrite any you like with 6.6 and bytestring
18:45:09 <dmead> is 6.6 stable?
18:45:10 <psykotic> it's the kind of book that's nice to study when you already know the material at a gut level and want to see how to make the formalisms ultra slick
18:45:31 <dons> then benchmark against the current implementation, and if its faster, post it to the top of the relevant wiki page
18:45:31 <homotopicus> psykotic: Its also nice for a bridge from Algebraic Topology to Homotopical Algebra
18:45:34 <dons> dmead: yes.
18:45:41 <homotopicus> psykotic: ie - if you want to study Quillen model categories
18:45:47 <jgrimes> dons, all right, will do.
18:45:57 <dmead> dons: where do i complain about it not being in portage =p
18:46:18 <dmead> or apt for that matter
18:46:23 <psykotic> yeah, model categories aren't my bag. i like the less abstract end of topology. bring back milnor! :)
18:46:44 <psykotic> i know enough about scary things like derived functors and triangulated categories to be dangerous, unfortunately.
18:46:45 <homotopicus> psykotic: Everyone at my department is obsessed with Milnor and Gromov.  I can't stand it.
18:46:59 <dons> dmead: it is in apt now i think
18:47:19 <dons> dmead: and gentoo is what we care about though , since that's what isaac needs for the shootout box
18:47:33 <dmead> shootout?
18:47:34 <psykotic> homotopicus, dunno if you've read any of milnor's old monographs but that stuff is beautiful.
18:47:35 <dons> which is dcoutts's domain
18:47:45 <psykotic> homotopicus, like his lectures on the h-cobordism theorem. that's one of my favorite math monographs of all time.
18:47:52 <homotopicus> psykotic: I can imagine it is, I just have zero geometric intuition.
18:48:16 <homotopicus> psykotic: My aversion for the stuff is more out of a sense of confusion than anything
18:49:07 <psykotic> btw someone scanned in a lot of his monographs and posted them online, hang on
18:49:17 <homotopicus> ahh, nifty
18:49:35 <psykotic> http://www.maths.ed.ac.uk/~aar/surgery/index.htm
18:49:39 <lambdabot> http://tinyurl.com/yls23p
18:49:59 <psykotic> search for milnor. "lectures on the h-cobordism theorem" is there
18:50:40 <psykotic> a lot of that stuff is a lot more geometrical than what you see these days though, so it might scare you. they liked doing a lot of stuff in the piecewise linear category.
18:51:32 <homotopicus> psykotic: Thanks for the link.
18:52:32 <homotopicus> psykotic: There was supposed to be a book on algebraic topology by Eilenberg and Dyer that was based in homotopical algebra, intended as an introduction to the subject.
18:52:34 <psykotic> he proves poincare for n > 4 in the "applications" section :)
18:52:45 <psykotic> just a minor application, hehe
18:53:00 <homotopicus> psykotic: I think May's approach could be made into something intelligable... if Eilenberg had lived long enough to make his book.
18:53:20 <homotopicus> psykotic: Well, its always good to give a few trivial examples.
18:53:37 <psykotic> i know someone who's at chicago and they really do use may's book for the first year grad course on at
18:53:54 <psykotic> it sounds terrible. one week for k-theory. uh yeah.
18:54:03 <psykotic> it might be "hardcore" but it seems pretty pointless to go at that pace.
18:54:58 <jgrimes> psykotic, homotopicus, what book would you guys suggest for someone wanting to learn modern abstract algebra on his/her own? (I won't be able to take a class on it for another two semesters)
18:55:01 <homotopicus> "the theorem has several important implications - including the proof of the generalized poincare conjecture in dimensions > 4"
18:55:24 <homotopicus> I can't imagine writing an introduction like that
18:55:32 <psykotic> milnor is a pimp
18:55:52 <homotopicus> jgrimes: A mixture of Jacobsen and Hungerford
18:56:18 <psykotic> those books might be a little tough depending on your mathematical maturity
18:56:25 <dons> jgrimes: one nice thing would be to fix chameneos so it is legal
18:56:40 <jgrimes> dons, all right, maybe I'll look at it first then. :)
18:56:40 <dons> it is slightly invalid, but once fixed should be the first or 2nd fastest entry
18:56:59 <dons> if you fix it, it can be submitted immediately, and is probably worth 3 or 4 rankings higher
18:57:47 <jgrimes> psykotic, yeah, that is somewhat a concern.
18:57:50 <jgrimes> dons, all right
18:57:53 <homotopicus> They are tough, but thorough.  You'll really know what you're doing if you make it through.  Plus, Hungerford is incredibly detailed.
18:58:30 <homotopicus> jgrimes: I would start by learning naive and axiomatic set theory pretty well first
18:58:30 <psykotic> the first book i read was really basic but great at the time when i didn't have a lot of experience with mathematics.
18:58:44 * psykotic tries to find it.
18:59:11 <psykotic> a first course in abstract algebra by fraleigh. don't laugh, homotopicus  :)
18:59:22 <homotopicus> psykotic: Fraleigh!  I remember that one
18:59:27 <homotopicus> actually, that one isn't bad.
18:59:32 <psykotic> it has some really nice intuitive proofs of a lot of the fundamental proofs. he really emphasizes the "counting" angle.
18:59:37 <jgrimes> homotopicus, fair enough
18:59:38 <psykotic> err, fundamental theorems.
18:59:39 <homotopicus> The latest edition has three chapters on homology towards the end
19:00:25 <psykotic> in any case fraleigh alongside a more hardcore book like hungerford would be a good combo i tihnk
19:00:30 <homotopicus> Agreed
19:00:41 <homotopicus> Man I love hungerford....
19:00:47 <jgrimes> psykotic, homotopicus, all right, sounds good. thanks.
19:01:02 <psykotic> jgrimes: and make sure you get the right hungerford book! :)
19:01:04 <homotopicus> "We're now going to use our theorems on modules over PIDs to do about a semester's worth of linear algebra in 20 pages or so"
19:01:22 <jgrimes> psykotic, which one would that be? :)
19:01:25 <psykotic> homotopicus, have you read rotman's modern abstract algebra?
19:01:41 <homotopicus> psykotic: I haven't, though I've seen his algebraic topology book
19:01:43 <psykotic> it's kind of messy and the first revisions had a LOT of typos, but it has some good stuff in there ala that.
19:02:01 <psykotic> lots of stuff you don't usually see in linear algebra, like alternating algebras and so on
19:02:18 <psykotic> alternating and multilinear goodness
19:02:19 <homotopicus> psykotic: So he defines the determinant in The Right Way?
19:02:21 <psykotic> yeah
19:02:24 <homotopicus> good
19:02:36 <psykotic> dilation factor of the lift to the top-dimensional alternating algebra :)
19:02:46 <homotopicus> ahh wonderful
19:03:23 <psykotic> jgrimes, "Abstract Algebra: An Introduction"
19:03:36 <psykotic> jgrimes, there's a GTM he did too, which people also refer to as just "Hungerford".
19:03:43 <psykotic> don't get that one :)
19:03:48 <jgrimes> psykotic, all right. :) thanks
19:04:05 <homotopicus> Oh, that's the one I was talking about
19:04:17 <homotopicus> the GTM one will be fine if he has fraleigh kicking around
19:04:46 <psykotic> yeah, actually, now that i look at the toc i had in mind the gtm too
19:04:54 <psykotic> the introduction one looks basic
19:05:07 * spiffy needs to stop trying to understand monads at night
19:05:41 <psykotic> spiffy: they're just monoids on the category of endofunctors over some category, what's the big deal?
19:05:42 <psykotic> :)
19:05:47 <jgrimes> psykotic, homotopicus, ok, sounds good then. thanks for the help.
19:05:51 <homotopicus> yeah exactly.
19:05:56 <homotopicus> jgrimes: No problem
19:06:03 <spiffy> laugh
19:06:06 <spiffy> Exactly.
19:06:16 <spiffy> or
19:06:25 <spiffy> they dont seem to be anything.
19:06:32 <homotopicus> psykotic: Actually, that definition is problematic if C isn't small.
19:06:35 <spiffy> its the middle ground im missing
19:06:41 <homotopicus> psykotic: Unless you admit Grothendieck universes.
19:06:59 <dons> psykotic: quoted!
19:07:03 <spiffy> I think, well hope, that if I can understand the State monad the universe will reveal all its secrets to me.
19:07:23 <homotopicus> spiffy: Welcome to the grand drug that is category theory.
19:07:35 <homotopicus> spiffy: Enlightenment always seems like it will be in the next abstraction.
19:07:43 <psykotic> to be honest i don't think you need to understand even a tiny bit of category theory to understand computational monads. :)
19:07:53 <homotopicus> agreed!
19:08:09 <homotopicus> psykotic: But he probably wants to impress his friends.
19:08:21 <psykotic> actually the category theory angle was confusing to me at first because i knew about triples from algebraic topology
19:08:30 <psykotic> and, yeah, they're quite different :)
19:08:40 <dons> ?remember psykotic [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
19:08:43 <homotopicus> psykotic: Triples in the sense of Beck's thesis?
19:09:07 <psykotic> homotopicus, i can't remember who introduced them, i thought it was cartan maybe?
19:09:15 <psykotic> they're described in eilenberg-cartan at any rate
19:09:27 <psykotic> i mean what modern folks call monads. i think they called them "standard triples" in eilenberg-cartan.
19:09:57 <homotopicus> psykotic: I didn't know they were featured in that book.
19:10:29 <homotopicus> psykotic: I know that Beck's thesis involves cohomology theories obtained through comonads, with cartan-eilenberg cohomology as an example.
19:10:33 <psykotic> homotopicus, i believe so, they're at the center of the "let's do homology theories for god damn EVERYTHING" program
19:11:05 <spiffy> Hmmm, I must say the plusOne example from GHC's State docs is really less than helpful. Or maybe im just missing the big picture
19:11:22 <psykotic> i haven't done any math for years now though so maybe i'm misremembering
19:11:55 <psykotic> homotopicus, think of simplicial objects (Delta, etc), monads sneak in there somehow iirc
19:12:08 <sjanssen> spiffy: why is it less than helpful?
19:12:11 <dons> spiffy: of , for Control.Monad.State?
19:12:16 <homotopicus> psykotic: I'm not sure.  I know about that stuff through Barr's latest book, 'Acyclic Models' - I haven't read cartan-eilenberg
19:12:17 <dons> yeah, i thought so too (a long time ago)
19:12:21 <homotopicus> Which is a crime I guess
19:12:24 <dons> ?type evalState
19:12:26 <lambdabot> forall a s. State s a -> s -> a
19:12:37 <spiffy> Maybe im not getting it (tired, cranky) but im not seeing any ..well state
19:12:44 <dons> > evalState (do modify (+1)) 7
19:12:45 <lambdabot>  ()
19:12:52 <jgrimes> oh, yeah, that was the same problem I had with that example
19:12:52 <dons> > execState (do modify (+1)) 7
19:12:54 <psykotic> homotopicus, that book is scary.
19:12:54 <lambdabot>  8
19:12:55 <homotopicus> but I have a copy of MacLane's 'Homology' at least =P
19:12:58 <jgrimes> I didn't see how there was any state...
19:13:08 <dolio> The state is used in the tick function.
19:13:16 <dons> > execState (do x <- get ; put (x*2) ; return 9) 7
19:13:17 <lambdabot>  14
19:13:17 <psykotic> homotopicus, i know about the acyclic models theorem and it's awesome but i took one look at that book and ran away.
19:13:28 <dons> > runState (do x <- get ; put (x*2) ; return 9) 7
19:13:30 <lambdabot>  (9,14)
19:13:44 <psykotic> homotopicus, it has an awesome _geometric_ character to it :)
19:13:48 <dons> spiffy: does that help?
19:13:54 <jgrimes> what finally made me get monads is when I really, really needed to use them
19:14:02 <homotopicus> psykotic: pffft
19:14:04 <homotopicus> hehe
19:14:06 <psykotic> homotopicus, do you know the proof of the homotopy property for singular homology by acyclic models?
19:14:13 <dons> > runState (do (_:x:xs) <- get ; put xs ; return x) [1..]
19:14:14 <lambdabot>  (2,[3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
19:14:39 <spiffy> oo now im not gonna sleep tonight
19:14:47 <psykotic> homotopicus, the usual geometric proof is to subdivide the prism resulting from taking the product of simplices. it's really messy when done that way but it can be done like BAM with acyclic models.
19:14:55 <homotopicus> psykotic: I know the proof of excision via barycentric subdivision via acyclic models
19:15:01 <psykotic> ah right
19:15:05 <dons> > 1 + (execState (do (_:x:xs) <- get ; put xs ; return x) [1..]) -- encapsulate a stateful computation
19:15:05 <lambdabot>  add an instance declaration for (Num [a])
19:15:13 <homotopicus> psykotic: Yeah, to show that you get a chain homotopy from your subdivided chain to the original chain complex
19:15:18 <homotopicus> psykotic: Its wonderful
19:15:20 <dons> > 7 : (execState (do (_:x:xs) <- get ; put xs ; return x) [1..]) -- encapsulate a stateful computation
19:15:22 <lambdabot>  [7,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
19:15:53 <spiffy> give me a second to look it over. I feel an "aha!" coming on
19:16:01 <dons> cool!
19:16:15 <psykotic> homotopicus, the way in which the models are used has a head-hurting quality to it that reminds me of higher-order programming :)
19:16:27 <psykotic> it's really bizarre when you first see it
19:16:32 <spiffy> so does execState generate a state or?
19:16:40 <dons> ?type execState
19:16:42 <lambdabot> forall s a. State s a -> s -> s
19:16:52 <dons> takes a stateful computation, an initial state, and runs it, returning the final state
19:17:05 <dons> > execState (modify (+1)) 0
19:17:07 <lambdabot>  1
19:17:22 <spiffy> modify modifies the state im guessing?
19:17:27 <spiffy> the intial state
19:17:32 <dons> > execState (do x <- get ; put (x+1)) 0
19:17:32 <homotopicus> psykotic: Things with head-hurting qualities are often the most interesting things
19:17:33 <lambdabot>  1
19:17:35 <dons> yep
19:17:48 <homotopicus> psykotic: Like Kan extensions and ends
19:18:59 <psykotic> homotopicus, btw if you want to ever take a walk on the geometric wild side, check out bredon's "topology and geometry" from the library. it's wonderful and also has some light stuff on acyclic models.
19:20:05 <spiffy> hmmm
19:20:13 <psykotic> homotopicus, it has a lot of topics i haven't really seen treated elsewhere at an expository level.
19:20:33 <dons> ?let state = flip execState
19:20:34 <lambdabot> Defined.
19:20:52 <homotopicus> psykotic: I've seen that book.  I'll probably take a look at it when I get some time.
19:20:58 <dons> > L.state 0 $ do x <- get ; put (x*2) ; y <- get ; put (y+1)
19:20:59 <lambdabot>  1
19:21:10 <psykotic> homotopicus, he also has a book on sheaves. (ohh, scary!) :)
19:21:21 <dons> > L.state 7 $ do x <- get ; put (x*2) ; y <- get ; put (y+1) -- imperative programming
19:21:23 <lambdabot>  15
19:21:37 <homotopicus> psykotic: The best book on that by far is MacLane and Moerdijk
19:21:38 <dons> > 2 * (L.state 7 $ do x <- get ; put (x*2) ; y <- get ; put (y+1)) -- as a subset of pure FP.
19:21:40 <lambdabot>  30
19:21:52 <homotopicus> psykotic: Hartshorne really gets my goat sometimes, and I think its poorly written
19:22:05 <psykotic> hartshorne is crazy
19:22:28 <psykotic> what's the name of the other big AG book. uh
19:22:29 <homotopicus> yeah, I don't know how anyone knows algebraic geometry from reading that book
19:22:38 <homotopicus> Eisenbud?
19:22:40 <psykotic> right
19:22:42 <psykotic> i liked that one
19:22:44 <homotopicus> I don't like that one either
19:22:45 <homotopicus> heh
19:22:48 <spiffy> im not seeing (mentally) why that adds up to 15
19:22:50 <homotopicus> I'm picky
19:22:50 <psykotic> i like it MORE than hartshorne. it's slim pickings.
19:23:05 <spiffy> 0 wait
19:23:09 <spiffy> * O wait
19:23:11 <spiffy> yes i do
19:23:22 <spiffy> get/put is like push/pop onto a stack?
19:23:27 <homotopicus> My main problem right now is that I'm taking an algebraic number theory course, and I'm technically supposed to know that stuff
19:23:33 <dons> yeah, it reads and writes the state.
19:23:39 <psykotic> homotopicus, btw there's an awesome little book you should get.
19:23:56 <spiffy> so, how do I return the current state?
19:23:56 <homotopicus> oh?
19:24:01 <psykotic> computational algebraic geometry by hal schenck. don't let the title put you off, it's wonderful.
19:24:04 <dons> > L.state [] $ do xs <- get ; put ("haskell": xs)
19:24:05 <lambdabot>  ["haskell"]
19:24:23 <dons> spiffy: so you can get two values back from a state monad, the return value, and the state itself
19:24:45 <dons> > (flip runState) [] $ do xs <- get ; put ("haskell": xs) ; return ()
19:24:46 <lambdabot>  ((),["haskell"])
19:24:53 <dons> > (flip execState) [] $ do xs <- get ; put ("haskell": xs) ; return ()
19:24:54 <lambdabot>  ["haskell"]
19:24:58 <homotopicus> psykotic: I'll look into that one, it might help with my state of general confusion right now
19:24:58 <dons> > (flip evalState) [] $ do xs <- get ; put ("haskell": xs) ; return ()
19:25:00 <lambdabot>  ()
19:25:20 <dons> spiffy: so those three functions show how to get either the final state, the final return value, or both
19:25:23 <psykotic> homotopicus, drool over this, http://assets.cambridge.org/052182/964X/toc/052182964X_toc.pdf :)
19:25:24 <spiffy> is there a log of this?
19:25:27 <lambdabot> http://tinyurl.com/y872n7
19:25:30 <spiffy> this channel
19:25:36 <dons> yep, check the topic
19:25:38 <dons> ?logs
19:25:38 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
19:25:43 <dons> not that one :)
19:25:49 <dons> ?wiki IRC_channel
19:25:49 <lambdabot> http://www.haskell.org/haskellwiki/IRC_channel
19:25:52 <dons> has the story
19:25:58 <psykotic> homotopicus, actually you probably already know this, but it's a cute and concise exposition.
19:26:14 <spiffy> excellent
19:27:04 <spiffy> so
19:27:07 <spiffy> hmmm
19:27:12 <spiffy> im getting there
19:27:15 <spiffy> slowly but surely
19:27:25 <homotopicus> psykotic: That looks nice.  I know next to nothing about Grobner bases
19:28:13 <spiffy> so we can return a state a variable. The next logical step is to run a State action (is that the right term?) with that as a starting state.
19:28:23 <dons> yeah
19:28:26 <homotopicus> Hmm, what's the connection with regular sequences and mapping cones?
19:28:57 <spiffy> im guessing withState is what I want?
19:29:18 <dons> to run a stateful computation, you used evalState or execState or runState
19:29:26 <spiffy> mmhmm
19:29:44 <dons> > 1 + 3 + (execState (do x <- get ; put (x + 1)) 0)
19:29:46 <lambdabot>  5
19:30:19 <dons> see how I ran a side-effecting chunk of code as part of that expression?
19:30:23 <dons> ?type put
19:30:25 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => s -> m ()
19:30:35 <dons> returns (), but has the side effect of setting the state as well
19:30:55 <spiffy> yup
19:31:02 <dons> but we can encapsulate it inside an execState, so that from the outside its just a referentially transparent code chunk, whose result is determined soley by its input state
19:31:16 <spiffy> yes
19:31:50 <dons> stateful, imperative programming is just a special case of pure functional programming with monads :)
19:32:08 <psykotic> and conversely. gentlemen, start your turing machines!
19:32:18 <dons> heh
19:32:19 <pkhuong-> which is just a special case of conway's game of life
19:32:23 <psykotic> vroom vroom
19:32:24 <pkhuong-> damn... beat me to it.
19:32:31 <dolio> > execState (withState (const 5) (do { x <- get ; put (x + 1) ; return x })) 1
19:32:33 <lambdabot>  6
19:32:44 <dons> dolio++
19:33:30 <dolio> Does that work like local in Reader?
19:33:38 <dons> ?type withstate
19:33:40 <lambdabot> Not in scope: `withstate'
19:33:43 <dons> ?type withState
19:33:44 <lambdabot> forall a s. (s -> s) -> State s a -> State s a
19:35:38 <SamB_XP> @type runRWS
19:35:40 <lambdabot> Not in scope: `runRWS'
19:35:42 <SamB_XP> aww.
19:36:02 <SamB_XP> @type execStateT
19:36:04 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m s
19:36:14 <dolio> > runState (withState (+1) (get)) 0
19:36:16 <lambdabot>  (1,1)
19:36:25 <SamB_XP> hmm.
19:36:31 <dolio> I suppose not, since it doesn't reset it afterwards.
19:36:33 <SamB_XP> so what is the point of the argument?
19:36:40 <dons> which argument?
19:36:50 <spiffy> well
19:36:55 <SamB_XP> I mean, if it is going to do that to the entire rest of the computation, why have
19:36:58 <SamB_XP> @type withState
19:36:59 <sjanssen> withState f m = State $ runState m . f
19:37:00 <lambdabot> forall a s. (s -> s) -> State s a -> State s a
19:37:00 <spiffy> ive learned a hell of a lot today
19:37:04 <spiffy> thank you all
19:37:07 <SamB_XP> why not just
19:37:13 <spiffy> I have plenty to sleep on
19:37:24 <SamB_XP> (s -> s) -> State s ()
19:37:28 <SamB_XP> or something?
19:37:29 <spiffy> seeya later.
19:37:41 <dolio> ?type modify
19:37:44 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => (s -> s) -> m ()
19:37:54 <coffeemug> StateT isn't an instance of MonadReader?
19:38:28 <SamB_XP> sure it is
19:38:33 <SamB_XP> if the monad underneath is
19:38:39 <SamB_XP> @instances MonadReader
19:38:40 <lambdabot> r ((->) r), r (ErrorT e m), r (RWS r w s), r (RWST r w s m), r (Reader r), r (ReaderT r m), r (StateT s m), r (WriterT w m), r' (ContT r m)
19:38:43 <sjanssen> it looks like withState f m = modify s >> m
19:39:03 <kpreid> > runState (do withState (+1) get; get) 0
19:39:05 <lambdabot>  (1,1)
19:39:12 <coffeemug> so I can do ask on StateT, not just get, right?
19:39:27 <SamB_XP> coffeemug: only if you have a reader underneath
19:39:38 <coffeemug> ahh
19:39:39 <coffeemug> I see
19:39:46 <SamB_XP> @type runStateT ask
19:39:48 <lambdabot> forall s (m :: * -> *) r. (MonadReader r (StateT s m)) => s -> m (r, s)
19:39:51 <coffeemug> no, that's not what I'm looking for
19:40:06 <coffeemug> basically State and Reader fulfill the same tasks on read
19:40:11 <coffeemug> but for State you use get
19:40:15 <coffeemug> and for Reader you use ask
19:40:22 <SamB_XP> not really
19:40:31 <SamB_XP> but, they are similar
19:40:56 <coffeemug> I look at Reader as a readonly State
19:41:02 <coffeemug> so I don't have to pass the state around all the time
19:41:09 <coffeemug> am I not looking at it in the right way?
19:41:33 <SamB_XP> well.
19:41:44 <SamB_XP> > runReader (local (+1)) 0
19:41:45 <lambdabot>    Expecting a function type, but found `Reader r a'
19:41:46 <lambdabot>    Expected type: R...
19:41:47 <SamB_XP> hmm.
19:41:57 <SamB_XP> @type runReader
19:41:58 <lambdabot> forall a r. Reader r a -> r -> a
19:42:07 <dolio> > runReader (local (+1) ask) 0
19:42:09 <lambdabot>  1
19:42:13 <SamB_XP> oh, right.
19:42:19 <SamB_XP> oh.
19:42:20 <SamB_XP> but.
19:42:30 <SamB_XP> > runReader (do local (+1) ask; ask) 0
19:42:32 <lambdabot>  0
19:42:46 <SamB_XP> you can't do that with MonadState...
19:42:50 <kpreid> SamB_XP: perhaps withState has a bug and nobody ever used it?
19:42:59 <SamB_XP> kpreid: its possible!
19:43:10 <kpreid> the documentation is bizarre though
19:43:10 <dolio> Well, you could implement local for state.
19:43:13 <SamB_XP> or maybe it just plain isn't good for anything in the first place
19:43:30 <SamB_XP> dolio: yeah, yeah...
19:43:36 <kpreid> from the documentation I'd think it was withState f = liftM f . ask
19:43:44 <kpreid> er, liftM f ask
19:43:53 <dolio> local f m = do x <- get ; modify f ; m ; put x
19:44:02 <SamB_XP> dolio: heh
19:44:11 <dolio> Or, you'd have to get the result of m and return it, too.
19:45:12 <dons> we should probably look at rewriting the state and stateT monad docs
19:45:18 <dons> they could be much more instructive
19:45:33 <dons> and apparently, i've heard, monads are hard for those not used to the concept of state
19:46:05 <SamB_XP> that, and MonadState is one of the most basic parts of the MTL
19:46:22 <dolio> The problem with making State and StateT instances of MonadReader would be that it would then require extra work to use a stack with both State(T) and Reader(T).
19:46:47 <SamB_XP> also, it wouldn't be too efficient
19:47:00 <SamB_XP> just don't even bother
19:47:25 <dons> did you guys see the monds-in-ocaml comment on reddit?
19:48:03 <dons> this was interesting, http://programming.reddit.com/info/p66e/comments/cp9me
19:48:07 <lambdabot> Title: Are monads actually used in anything except Haskell ? (reddit.com), http://tinyurl.com/whhug
19:48:11 <dons> " basically never use the imperative features of ML without encapsulating them in a monad. My code is too unmodular otherwise."
19:48:50 <psykotic> but that's by neel :)
19:48:59 <psykotic> i don't think he's an example of an average ml hacke
19:49:00 <psykotic> hacker
19:49:06 <dons> ah :)
19:49:12 <dons> who's he then?
19:49:20 <psykotic> he's a language monger like the rest of us
19:49:27 <dons> fair enough
19:49:32 <psykotic> i think he's an associate professor at cmu
19:49:38 <psykotic> in the programming languages group
19:49:52 <psykotic> neel krishnaswami
19:49:53 <dons> i think the concept of encapsulation of effects is just not well understood outside our community. which is a real pity
19:49:57 <dons> ah . cool.
19:50:04 <dons> that explains a lot then :)
19:51:44 <psykotic> you're probably right about that
19:51:57 <psykotic> it might have to be served in a more palletable form as "private heaps" or something like that
19:52:08 <dons> yeah
19:52:12 <kpreid> dons: well, and the capability security community :-)
19:52:29 <kpreid> (the encapsulation is in different dimensions, but hey)
19:52:38 <dons> and those guys. some of whom are part of the PL crowd too
19:52:59 <SamB_XP> we need to infect more universities
19:53:04 <SamB_XP> and colleges
19:53:08 * kpreid is a capability guy
19:53:13 <SamB_XP> and departments
19:53:37 <sjanssen> and people
19:53:41 <coffeemug> that's not going to work sam
19:53:49 <SamB_XP> how so?
19:53:59 <coffeemug> when I went to Stony Brook Uni in 2001
19:54:07 <coffeemug> CS 101 has about 200 people
19:54:15 <coffeemug> now they have about 50
19:54:18 <psykotic> heh
19:54:25 <coffeemug> simply because people don't go into CS anymore
19:54:27 <dons> we had 600 in 2001, and now about 200
19:54:31 <psykotic> even at institutions with ultra qualified people they teach stuff like java for the intro cs classes
19:54:44 <psykotic> my old school had people like wynskel, danvy, filinski, etc in the cs department but it was still java crap for the intro course
19:54:47 <coffeemug> so what that means is that they lower the standards :)
19:54:57 <SamB_XP> okay.
19:54:59 <dons> (those 600 got a good dose of monads though ;)
19:55:07 <SamB_XP> I'd think less people would mean *raise* the standards
19:55:12 <coffeemug> no
19:55:15 <coffeemug> how so?
19:55:16 <SamB_XP> because clearly less people means more determined people ;-)
19:55:18 <coffeemug> if less people apply
19:55:24 <coffeemug> they need to lower the standards
19:55:26 <psykotic> coffeemug, if it means that more _qualified_ people apply
19:55:26 <dons> with smaller numbers you can't teach the harder courses -- lack of demand
19:55:28 <SamB_XP> or, you could give a poll
19:55:38 <psykotic> more people might be a result of people seeing dollar signs
19:55:42 <SamB_XP> "do you want high standards, or do you want the boring Java classes"
19:55:48 <coffeemug> yeah, that's certainly true
19:55:50 <dolio> I'm pretty sure my university had all engineering students take the intro to programming course.
19:55:55 <dolio> I wonder how they'd react to Haskell.
19:55:57 <coffeemug> but in the US departments want funding
19:56:04 <dons> so you have to drop 'very advanced compiler construction' or 'monads and leibniz for biochemists"
19:56:05 <coffeemug> and funding is a function of a number of students
19:56:14 <SamB_XP> well, maybe more would apply if they tought less Java!
19:56:18 <SamB_XP> or gave an option
19:56:30 <coffeemug> I doubt it :)
19:56:36 <sjanssen> SamB_XP: I don't think Java scares away students
19:56:36 <jgrimes> I also doubt it
19:56:37 <psykotic> dons: for cross-discipline courses like that i think it's probably a good idea to teach something like java.
19:56:48 <SamB_XP> ack no
19:56:49 <psykotic> at least if the focus is to give them skills useful in their discipline, as opposed to a taste of programming.
19:56:55 <SamB_XP> teach fortran instead or something
19:57:01 <psykotic> yeah, whatever
19:57:05 <SamB_XP> or C
19:57:09 <dolio> Ours was C++, I beileve.
19:57:16 <psykotic> my point is that the cs people will learn the real stuff soon enough
19:57:20 <jgrimes> I know that most of the engineering students I've talked to hate programming because they think it is all Java
19:57:24 <jgrimes> at my school
19:57:25 <jgrimes> that is
19:57:35 <psykotic> at my school i think they had a mandatory course in denotational semantics in the third semester, and at that point the cs people were ready
19:57:46 <SamB_XP> THIRD SEMESTER?>
19:57:58 <SamB_XP> hmm. what school is that?
19:58:08 <psykotic> SamB, maybe it was fourth. keep in mind that this was daimi that probably has more semanticists than any other department :)
19:58:08 <homotopicus> That's not unreasonable if discrete mathematics has been imparted by then
19:58:23 <dons> psykotic: yeah, cross-faculty stuff should be in say java. i could live with that
19:58:27 <psykotic> a lot of the original denotational semantics pimps are at daimi
19:58:34 <psykotic> wynskel, nielsen, etc
19:58:44 <psykotic> (actually wynskel is at cambridge now, but that's semi-recent)
19:58:50 <dons> we do our POPL and Adv. FP courses in Haskell. also the theorem proving course
19:58:56 <SamB_XP> oh, well, I was actually wondered why they wait so long
19:59:00 <SamB_XP> re.
19:59:01 <SamB_XP> er.
19:59:02 <SamB_XP> wondering.
19:59:30 <psykotic> heh
19:59:59 <SamB_XP> hmm.
20:00:01 <dolio> Third semester's pretty good. I don't think we ever studied it.
20:00:05 <psykotic> they also had a nice third or fourth semester course dModLog (models and logic)
20:00:21 <dolio> Although it's in a book for one of the courses.
20:00:23 * SamB_XP wonders how difficult a CS/Mech E. double major is, and where you could get it decently...
20:00:40 <coffeemug> basically given current application statistics only the best schools can afford to have high standards
20:00:51 <coffeemug> and I'm happy with that
20:01:06 <coffeemug> most programmers these days don't need to be good
20:01:07 <coffeemug> or great
20:01:29 <SamB_XP> hmm, wouldn't it be the fact that the best schools would *be* the schools with the highest standards?
20:01:37 <dons> :/ more php for all then
20:01:50 <coffeemug> chicken and egg
20:02:04 <SamB_XP> how do you measure "best"?
20:02:38 <SamB_XP> isn't it typically based on the quality of the educations given?
20:03:10 <dons> there's some connection between the quality of the research output and the 'bestness' I suspect..
20:03:35 <psykotic> ah, just checked the new curriculum at daimi, they have a fourth quarter (quarter, not semester) course in programming languages that seems to use haskell primarily
20:03:45 <dons> nice
20:03:46 <psykotic> well, haskell, scala and prolog it appears
20:04:13 <psykotic> nice, type inference algorithms in a fourth quarter course, that's on the pensum.
20:04:28 <dons> good
20:05:19 <palomer> type inference isn't hard
20:05:25 <palomer> we do it here in the third semester
20:05:32 <palomer> it's really badly taught though
20:05:36 <palomer> the teacher's a shrew
20:05:48 <psykotic> well i'm thinking back to the people i knew at the end of the first year and i'm trying to imagine them making sense of it
20:05:57 <psykotic> and it's pretty hilarious. but yes, i agree.
20:05:59 <SamB_XP> palomer: do you need a shrew tamer?
20:06:32 <psykotic> HM type inference is so simple that you could probably give it as a guided exercise
20:06:33 <SamB_XP> hmm, how do people survive quarters?
20:06:45 <psykotic> (at least if people already know a little about unification)
20:06:55 <dons> yeah, we give it as a tutorial exercise in one course
20:07:23 <psykotic> SamB, it's actually nicer since it means the stuff you prep for on exams is more recent.
20:08:11 <palomer> I DO need a shrew tamer
20:08:17 <psykotic> they instituted the quarter system after i left though, but that was the intention
20:08:35 <SamB_XP> there has to be a drawback
20:08:50 <homotopicus> Quarters really bugged me when I was an undergrad
20:08:53 <palomer> to learning about type inference?
20:08:59 <palomer> it gets in the way of learning about useful stuff
20:09:04 <SamB_XP> no, to quarters
20:09:12 <SamB_XP> type inference is cool
20:09:15 <SamB_XP> I think
20:09:18 <homotopicus> Yeah, you can't go as deep as you would like with quarters
20:09:20 <psykotic> SamB, to quarters? not really. they just make certain courses take multiple quarters, with the quarter exam being like a midterm.
20:09:30 <SamB_XP> psykotic: oh.
20:09:36 <SamB_XP> that doesn't sound so bad then.
20:09:48 <SamB_XP> except it might make the scheduling more complicated
20:09:50 <psykotic> of course it's unlike a midterm in counting exactly like a true exam.
20:09:52 <psykotic> yeah.
20:10:14 <psykotic> otoh i prefer this over what we had in my freshman year
20:10:24 <SamB_XP> do they give summers off?
20:10:29 <psykotic> i had a 1 year linear algebra course with a final oral exam where you had to prepare one year's worth of proofs.
20:10:31 <SamB_XP> or parts thereof?
20:10:45 <SamB_XP> 1 year course?
20:10:53 <psykotic> you drew a theorem at random and had to immediately walk through the proof without references or even preparation (usually you have like 20 minutes prep after drawing the problem, but not in this course).
20:11:04 <psykotic> that was insane.
20:11:14 <SamB_XP> wow
20:11:18 <SamB_XP> that *is* insane
20:11:28 <palomer> proofs are easy. have you ever tried digging a ditch?
20:11:32 <palomer> THAT'S insane
20:11:34 <psykotic> it was a pass/fail course so it wasn't that crucial.
20:11:42 <psykotic> but i still thought it was kind of weird.
20:11:55 <SamB_XP> hmm, but remembering how to dig a ditch is easier than remembering how to prove twenty bajilion theorems
20:12:02 <homotopicus> I don't understand the pedagogical benefit of such a policy
20:12:03 <undated> I dug a hole with a sharpened rock once.
20:12:08 <psykotic> homotopicus, me neither.
20:12:13 <palomer> you don't remember theorems
20:12:16 <palomer> they simply make sense.
20:12:41 <psykotic> palomer, not to 90% of people learning them for the first time they don't :)
20:12:43 <SamB_XP> you might remember the theorems
20:12:45 <homotopicus> Except or the Tychenoff theorem for an arbitrary family of spaces =P
20:12:45 <SamB_XP> but not the proofs
20:12:50 <homotopicus> *for
20:13:02 <palomer> yes the proofs!
20:13:12 <palomer> if a theorem makes sense it's because you can prove it to someone
20:13:16 <palomer> or else, it doesn't make sense
20:13:19 <psykotic> well, the idea to "remembering" proofs is to remember the core idea and being able to reproduce anything
20:13:24 <dons> don't mind palomer. he's very contrary
20:13:29 <palomer> mind me!
20:13:33 <psykotic> but unfortunately most mathematical exposition doesn't emphasize that enough.
20:13:44 <chessguy> sometimes proving a theorem requires taking a really arbitrary step
20:13:52 * palomer contemplates going to the library and getting a book on linguistics
20:13:57 * johnnowak handwaves
20:13:59 <psykotic> right, and that's what you need to remember. you need to remember the milestones, not the individual steps.
20:14:10 <chessguy> it's not necessarily enough to just understand the proof
20:14:11 <psykotic> usually every proof has just one good idea, maybe a few.
20:14:20 <psykotic> often none :)
20:14:25 <homotopicus> Except for Godel's Incompleteness Theorems
20:14:30 <psykotic> right, hah
20:14:30 <dons> chessguy: yeah, i remember this step in the proof of soundness of LF, they pull Kripke structures out of the air... now I didn't see that coming ..
20:14:40 <chessguy> LF?
20:14:41 <homotopicus> Which contain all of the foundations of modern mathematical logic in some form or another
20:14:48 <palomer> LF is for schmucks
20:14:51 <palomer> I hate LF
20:15:05 <dons> type system for encoding type systems :)
20:15:13 <dons> palomer: constructive as always, I see.
20:15:22 <chessguy> sounds...brainy
20:15:26 <coffeemug> well
20:15:29 <coffeemug> why only types and kinds?
20:15:34 <coffeemug> limited and inelegant
20:15:41 <coffeemug> if you could develop a base type system
20:15:44 <palomer> because they're schmucks
20:15:48 <coffeemug> and then encode type systems in it recursively
20:15:54 <palomer> and they're funky kinds
20:15:59 <palomer> kinds which takes terms and return types
20:15:59 <coffeemug> ...
20:16:02 <palomer> what's the deal with that?
20:16:58 <palomer> I believe that the worth of something is reflected by the people who work on it
20:17:03 <palomer> LF is worked on by a shrew
20:17:10 <homotopicus> hehe, shrews everywhere
20:17:15 <dons> heh
20:17:17 <homotopicus> Kirpke is a shrew if you ask me
20:17:20 <chessguy> what does LF stand for?
20:17:21 <homotopicus> err, Kripke
20:17:35 <dons> Logical Framework
20:17:48 <dons> ?google twelf
20:17:50 <lambdabot> http://www.cs.cmu.edu/~twelf/
20:17:50 <lambdabot> Title: The Twelf Project
20:17:53 <palomer> llama f*#$*
20:18:39 <chessguy> an emacs interface :)
20:18:49 <gzl> Kripke is tough to understand these days.
20:18:59 <gzl> in person.
20:19:07 <homotopicus> Kripke is irrelevant these days
20:19:27 <gzl> regardless.
20:19:35 <homotopicus> The last time I saw him speak, it was mind numbing bitching about interpretations of his work by British philosophers
20:19:50 <gzl> I saw him give a talk called The Road to Godel. actually pretty interesting.
20:19:59 <gzl> but hard to follow because of his redonkulous speaking style.
20:20:08 <dons> yeah, strange guy
20:20:13 <homotopicus> Did he have food in his beard?
20:20:16 <chessguy> redonkulous? lol
20:20:23 <gzl> I couldn't see.
20:20:24 <gzl> I don't think so
20:20:51 <chessguy> ?dict redonkulous
20:20:52 <lambdabot> Supported dictionary-lookup commands:
20:20:52 <lambdabot>  all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
20:20:52 <lambdabot> Use "dict-help [cmd...]" for more.
20:21:05 <chessguy> ?dict all-dicts redonkulous
20:21:06 <lambdabot> Supported dictionary-lookup commands:
20:21:06 <lambdabot>  all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
20:21:06 <lambdabot> Use "dict-help [cmd...]" for more.
20:21:13 <dons> ?spell redonkulous
20:21:14 <lambdabot> ridiculous redoubles Regulus rednecks wrinklies
20:21:35 <gzl> hahaha
20:21:38 <gzl> it's not a real word
20:21:48 <coffeemug> question
20:21:55 <dolio> Redonkulous is more ridiculous than ridiculous, but less ridiculous than recockulous.
20:22:03 <gzl> yep.
20:22:04 <coffeemug> I want a function getState to apply to both the State monad and the Reader monad
20:22:09 <gzl> http://www.urbandictionary.com/define.php?term=redonkulous
20:22:11 <coffeemug> so I create a class, say MyReader
20:22:12 <lambdabot> Title: Urban Dictionary: redonkulous, http://tinyurl.com/ggmvm
20:22:27 <coffeemug> and now I want to create two instance
20:22:29 <coffeemug> instances
20:22:34 <coffeemug> one for State and one for Reader
20:22:47 <coffeemug> how would my instance declaration look like?
20:23:08 <coffeemug> instance MyReader (Reader a) where
20:23:16 <coffeemug> but that's not right
20:24:15 <dons> Reader a , State a => MyStateReader a -- ? not sure what you're trying to do
20:25:00 <coffeemug> dons: basically State offers get to read the state
20:25:07 <coffeemug> and Reader offers ask to read the state
20:25:11 <coffeemug> I'd like to generalize this
20:25:20 <coffeemug> so I can use one function to do this
20:25:24 <coffeemug> one function name
20:25:44 * dons peeks around in Control.Monad.*
20:26:37 <dons> can you not just use either one of the existing monads .. i.e. State only, or a RWS, or a transformer to layer?
20:26:58 <coffeemug> here's why I'm doing it
20:27:13 <dons> but yeah, you could have a class that provides 'read' or something, that has an instance for Reader, and another for State
20:27:13 * chessguy has noticed lately that dons likes the word 'layer'
20:27:13 <coffeemug> I want to separate "business logic" from "presentation"
20:27:23 <dons> chessguy: oh?
20:27:29 <coffeemug> so business logic code will get State so it can read and write state
20:27:39 <dons> ok
20:27:44 <dons> and then present with reader only?
20:27:49 <coffeemug> but presentation will get Reader so it can only read state created for it earlier
20:28:05 <dons> yep. good. so you can statically ensure that the presenter doesn't tweak anything on you
20:28:11 <coffeemug> also business logic will be IO
20:28:15 <coffeemug> and presentation won't be
20:28:22 <dons> oh, so StateT IO ?
20:28:26 <coffeemug> this way I'll get a really clean separation
20:28:30 <coffeemug> yeah
20:28:32 <dons> i.e. StateT IO a , verus Reader a
20:28:38 <coffeemug> pretty much
20:28:44 <coffeemug> one thing I couldn't figure out
20:28:47 <coffeemug> is what RWS is
20:28:50 <dons> why not get the state back out of the StateT, then runReader a
20:29:01 <coffeemug> dons: that's exactly what I do
20:29:22 <coffeemug> dons: but my state is rather complex, it's a map of things, and I abstract dealing with the map away
20:29:29 <dons> ok
20:29:30 <coffeemug> so they just call my function
20:29:39 <coffeemug> say, getSessionState
20:29:49 <coffeemug> and internally getSessionState calls get
20:29:55 <coffeemug> but for reader it has to call ask
20:30:03 <dons> yep. ok. let's see if we can write this ..
20:30:27 <dons> so you want bounded polymorphic function getSessionState, parameterised by the monad
20:30:40 <coffeemug> yes
20:30:59 <coffeemug> it's a bit hard for me to write higher order instance declarations
20:31:56 <dons> :)
20:32:55 <chessguy> so in my 'principles of programming languages' class, we're going to start studying FP this week. which means i have to decide how much of a pain in the neck i'm going to be when my prof starts making ridiculous statements about it
20:33:15 <coffeemug> :)
20:33:30 <coffeemug> dons: what does the pipe (|) mean in class declarations?
20:33:52 <chessguy> oh! i saw that used the other day
20:33:57 <chessguy> Cale was explaining it
20:34:07 <chessguy> but i don't remember what he called it
20:34:09 <psykotic> chessguy, there's usually not much point in doing that kind of thing and a lot of point in not doing it :)
20:34:44 <dons> that's a functional dependency. it states some relation between types
20:34:46 <chessguy> bleah. but nobody in the class is gonna have a clue
20:34:52 <dons> i.e. C m r | m -> r
20:34:52 <dolio> What are you going to learn? Scheme?
20:35:01 <chessguy> dolio, yes
20:35:05 <dons> means that the type m determines the type r, such that when you know m you also know which type r you have
20:35:09 <chessguy> of course, i'll probably write everything in haskell first
20:35:19 <coffeemug> hmm
20:35:20 <coffeemug> ok
20:37:50 <psykotic> dons: what's the simplest interesting example of its use?
20:40:07 <dons> the main point of them is to make multi-parameter type class instance tractable
20:40:20 <dons> s/instances/
20:40:39 * dcoutts is exhausted
20:40:39 <coffeemug> when I say class MyStateReader (m a) where ...
20:40:46 <coffeemug> I get Type found where type variable expected
20:41:00 * dcoutts has been finishing updating a FP practical
20:41:09 <coffeemug> why is that?
20:41:10 <dolio> 'class Collection c e | c -> e' is a common example.
20:41:20 <dcoutts> (but it does now do 3d stuff, which is very cool)
20:41:20 <dolio> Where c is the collection type, and e is the element type.
20:42:22 <psykotic> dolio, so when you instantiate it you give a recipe for deriving e from c?
20:43:03 <dolio> Yeah, you can only declare c an instance once.
20:43:18 <dolio> Like 'instance Collection [a] a'.
20:43:24 <psykotic> right
20:43:26 <dons> so basically i'm imagining this:
20:43:28 <dons> class (Monad m) => Readable s m | m -> s where state :: m s ; state = ask
20:43:28 <dons> instance (MonadReader m r) => Readable r m where state = ask
20:43:28 <dons> instance (MonadState  m r) => Readable s m where state = get
20:43:33 <dons> coffeemug ^^
20:43:37 <dons> now, just to tweak it.
20:43:44 <dons> so it actually type checks :)
20:44:01 <dons> oh, that default method shouldn't be there
20:44:03 <coffeemug> heh
20:45:46 <dons> hmm. what we're really doing is writing a monad transformer though, I thin
20:45:48 <dons> k
20:48:03 <coffeemug> higher order types make my head spin a bit
20:48:04 <coffeemug> :)
20:49:38 <chessguy> only a bit?
20:49:47 <coffeemug> quite a bit :)
20:49:48 <dons> ok, this type checks:
20:49:51 <dons> {-# OPTIONS -fglasgow-exts -fallow-undecidable-instances #-}
20:49:51 <dons> module M where
20:49:51 <dons> import Control.Monad.Reader
20:49:51 <dons> import Control.Monad.State
20:49:52 <dons> instance (MonadState s m) => MonadReader s m where ask = get
20:49:54 <dons> :)
20:50:00 <chessguy> spammer!
20:50:20 <dons> now, i'm not sure if that is cheating or what..
20:51:20 <chessguy> hmm, what does having a line with {-# OPTIONS...#-} do?
20:51:20 <dolio> You'll need to implement local, as well.
20:51:43 <coffeemug> doesn't type check for me
20:51:54 <coffeemug> what does your class declaration look like?
20:52:04 <coffeemug> chessguy: it's like passing parameters to ghc
20:52:18 <dons> ah yes, local is missing
20:52:43 <coffeemug> dons: what does your class look like?
20:53:33 <dons> ok. seems to work.
20:53:39 <dons> I can use 'ask' in a State s m
20:53:46 <dons> lisppaste2: url
20:53:47 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
20:54:47 <lisppaste2> dons pasted "State s m => Reader s m" at http://paste.lisp.org/display/29359
20:55:36 <palomer> note to #haskell: drinking 2 litres of milk is a bad idea
20:56:19 <scodil> i'm having trouble with some type checking. what exactly is the difference between "expected" type and "inferred" type?
20:56:51 <dons> expected is what needs to be there for it to type check, inferred is what you've actually got
20:56:52 <Botty> scodil - expected is the type it expects to be there, inferred is what you used instead
20:57:05 <dons> jinx
20:57:21 <Botty> hah, it'd be a jinx if we actually said the same thing
20:57:44 <lisppaste2> dons pasted "with type annotations " at http://paste.lisp.org/display/29360
20:57:51 <coffeemug> hmm
20:57:53 <lisppaste2> dolio annotated #29359 with "local" at http://paste.lisp.org/display/29359#1
20:57:56 <coffeemug> I get an overlapping instances error
20:57:59 <kpreid> isn't that arbitrary depending on what the compiler infers first?
20:58:04 <palomer> expected and inferred mean that the creators of ghc were too lazy to implement user friendly type errors
20:58:12 <Botty> hehehe
20:58:17 <chessguy> lol
20:58:21 <dons> coffeemug: did you include the required OPTIONS pragma?
20:58:34 <coffeemug> I did
20:58:41 <coffeemug> undecidable is the same is overlapping?
20:58:49 <dons> nope
20:58:56 <dons> maybe I need a | m -> s in there
20:59:10 <dons> thanks dolio
20:59:12 <dons> dolio++
21:00:29 <lisppaste2> dons annotated #29360 with "updated with local" at http://paste.lisp.org/display/29360#1
21:00:45 <dons> so now. maybe we need to see what actual instance you've got for Reader and State
21:00:48 <dons> and how you're using them
21:00:54 <dons> but I think the hard part is over now :)
21:01:26 <coffeemug> I'm using StateT
21:01:29 <coffeemug> may be that's why?
21:01:37 <dons> ah, yeah, maybe .. :)
21:01:54 <dons> right, so you actually want to use ask inside a StateT IO m s
21:02:10 <dons> which we can do i think ...
21:02:13 * dons hacks
21:02:32 <scodil> is there a haskell rule of thumb that says "don't annotate until you have to, or until you're done writing"? cause they're should be
21:03:06 <coffeemug> well
21:03:14 <coffeemug> you can't not annotate in many cases because of the tools
21:03:30 <coffeemug> for example, I think haddoc doesn't recognize your functions unless you annotate
21:03:35 <coffeemug> also hstags doesn't either
21:06:24 <dons> hmm, we already have: instance (Monad m) => MonadState s (StateT s m) where
21:06:33 <dons> i.e. get, so ask = get should just about work.
21:12:04 <lispy> how's #haskell?
21:12:28 <coffeemug> :)
21:12:31 <lispy> ?users
21:12:32 <lambdabot> Maximum users seen in #haskell: 265, currently: 222 (83.8%), active: 29 (13.1%)
21:13:04 <lispy> coffeemug: ideally you annotate anything in the module which is exposed
21:13:23 <lispy> which for me, usually means everything
21:14:24 * beschmi has some emacs code that uses ghc-api to add type annotations to function definitions
21:14:32 <lispy> scodil: if you're going to write in a type sig it's usually best to write the most general one possible
21:14:41 <lispy> beschmi++
21:14:45 <jgrimes> lispy, I've got it working as far as I can tell, but for some reason the testharness isn't getting the output when it runs the programs.
21:14:45 <lispy> beschmi: that is so cool
21:14:54 <jgrimes> lispy, but I've done some manual tests
21:14:59 <jgrimes> lispy, and they all work
21:15:12 <lispy> jgrimes: interesting
21:15:28 <lispy> jgrimes: what version of ghc?
21:15:31 <jgrimes> 6.6
21:15:42 <lispy> okay, i've been using 6.4.2
21:15:50 <jgrimes> I haven't taken time to look at why the test harness isn't working yet.
21:15:55 <jgrimes> too many other projects :)
21:15:55 <lispy> maybe compileAndRun needs a tweak
21:16:23 <lispy> jgrimes++
21:16:35 <beschmi> lispy, http://beschmi.cloaked.no-ip.org/shim/
21:16:37 <lambdabot> Title: Index of /shim
21:16:51 <beschmi> i've stolen a lot of code from slime )
21:17:22 <lispy> beschmi: cool, i dont' have a new enough ghc but when i do i'll take a look
21:18:32 <jgrimes> beschmi, that looks very interesting. :)
21:21:33 <coffeemug> beschmi: why don't you extend it to check haskell code on the fly like Visual Haskell does?
21:21:40 <coffeemug> that would be very very useful
21:21:41 <dons> coffeemug: so basically you want t avoid using both 'get' and 'ask' in StateT, State and Reader, where required. i.e. this has to type:
21:21:45 <dons> k :: StateT Integer IO Integer
21:21:47 <dons> k = do x <- ask             -- something Reader
21:21:50 <dons>        put (x+1)            -- something State
21:21:52 <dons>        liftIO $ print "yes" -- something StateT IO
21:21:55 <dons>        return x             -- and done
21:21:57 <dons> now, I'm walking in circles trying to actually make that work :)
21:21:59 <beschmi> coffeemug, that's the next thing on my todo list
21:22:07 <dons> so I think now the best option is to ask on haskell-cafe@haskell.org
21:22:18 <dons> or just live with using 'ask' in Reader, and 'get' in State/StateT
21:22:20 <coffeemug> beschmi: are you going to submit this to the emacs mode guys?
21:22:27 <dons> or challenge Cale
21:22:40 <coffeemug> dons: I don't care about ask and get
21:22:47 <dons> hehe ok
21:22:49 <coffeemug> dons: my initial hunch was to create a new class
21:22:51 <lispy> dons: we should totally have a CaleChallenge
21:22:57 <Cale> huh?
21:22:58 <coffeemug> dons: and create a new function like getState
21:23:08 <dons> yeah. I know
21:23:11 <coffeemug> and do two instances
21:23:15 <coffeemug> but that doesn't work, does it?
21:23:15 <dons> but that's harder than making State an instance of Reader
21:23:34 * lispy gets busy with homework again
21:23:34 <coffeemug> dons: so you can do that with StateT, right?
21:23:41 <dons> Cale, so the challenge is: write an instance of Reader that works for State _and_ StateT
21:23:44 <dons> we hvae State already.
21:23:53 <dons> http://paste.lisp.org/display/29359#1
21:23:56 <coffeemug> beschmi: ?
21:24:01 <beschmi> coffeemug: i'm not sure
21:24:10 <beschmi> coffeemug: since it contains haskell code
21:24:15 <dons> so that the above StateT fragment works, and you can just use 'ask' whenever you want to read-only get the state
21:24:18 <coffeemug> beschmi: so what?
21:24:27 <dons> independent of which State,StateT or Reader you're in
21:24:43 <Botty> http://haskell.org/haskellwiki/Haskell_Quiz/Bytecode_Compiler/Solution_Michael_Sloan
21:24:47 <lambdabot> Title: Haskell Quiz/Bytecode Compiler/Solution Michael Sloan - HaskellWiki, http://tinyurl.com/tcmju
21:24:49 <Botty> completely re-written
21:24:52 <dons> nice
21:25:05 <coffeemug> beschmi: I'd love to use such a feature
21:25:13 <Botty> dunno if it's my own, original method, or the more functional method we talked about yesterday
21:25:14 <dons> ah, here's the state/reader, http://paste.lisp.org/display/29360
21:25:29 <coffeemug> it's just that people probably won't know about it unless you submit it to the emacs guys
21:25:32 <Botty> erm, just a sec
21:25:33 <beschmi> coffeemug: you can use it together with the default emacs-mode
21:25:35 <dons> Cale: but i got stuck on StateT.
21:25:42 <Botty> I edited without checking compiling (made a few changes)
21:26:01 <beschmi> coffeemug: i'm just not sure if it's better to keep it separate
21:26:03 <Cale> why won't that code there work in any MonadState?
21:26:48 <coffeemug> beschmi: I know, but the only way I found out about it was by accidently sitting in this channel
21:26:57 <coffeemug> this stuff isn't online or documented anywhere :)
21:27:03 <dons> Cale, due to:
21:27:04 <dons> A.hs:23:12:
21:27:04 <dons>     Overlapping instances for MonadReader Integer (StateT Integer IO)
21:27:04 <dons>       arising from use of `ask' at A.hs:23:12-14
21:27:26 <dons> so maybe we need to constraint the instance a bit hmm.
21:27:29 <coffeemug> beschmi: I'm just trying to say, make it available (especially when you add on the fly checking)
21:27:39 <coffeemug> put it on the wiki or smtg
21:27:48 <coffeemug> many people would kill for this code :)
21:29:04 <dons> so the challenge is to make this compile: http://paste.lisp.org/display/29362
21:29:10 <beschmi> coffeemug, of course. i'm just trying to clean some things up before making it public
21:29:52 <coffeemug> beschmi: cool
21:29:58 <coffeemug> beschmi: this is great, thanks man
21:30:50 <coffeemug> dons: I'm gonna go to sleep
21:30:57 <coffeemug> dons: if this thing clears up could you email me?
21:31:03 <dons> heh sure.
21:31:06 <coffeemug> thanks
21:31:19 <coffeemug> it's no big deal to use two functions
21:31:22 <dons> yeah
21:31:24 <coffeemug> but would be very nice to use one
21:31:26 <dons> but should be soluble
21:31:32 <dons> right.
21:31:34 <sjanssen> dons: "x <- evalStateT k 0" part won't work
21:31:43 <dons> ah. what did i do there?
21:31:52 <sjanssen> you probably meant let
21:31:53 <dons> ?type evalStateT
21:31:55 <lambdabot> forall a (m :: * -> *) s. (Monad m) => StateT s m a -> s -> m a
21:32:00 <dons> hmm, m a
21:32:05 <sjanssen> oh, I'm wrong ;)
21:32:37 <Botty> dons - http://haskell.org/haskellwiki/Haskell_Quiz/Bytecode_Compiler/Solution_Michael_Sloan , open to any suggestions
21:32:41 <lambdabot> Title: Haskell Quiz/Bytecode Compiler/Solution Michael Sloan - HaskellWiki, http://tinyurl.com/tcmju
21:32:49 <dons> Botty: cool. i'll check it out
21:33:16 <Cale> dons: aha, it's the default lifting instance that's messing everything up
21:33:33 <dons> ah! hmm
21:33:50 <sjanssen> yeah, that instance is going to need overlapping instances
21:34:06 <dons> and then we need to make sure the right one gets picked
21:34:07 <Botty> dons - please also tell me if my method is new :)
21:34:24 <coffeemug> ok guys
21:34:24 <coffeemug> gn
21:34:25 <Cale> Even with allow-overlapping-instances, it wants to choose the wrong one
21:34:26 <Botty> I imagined how a person reads an expression and based it off that
21:34:44 <sjanssen> I think the right thing to do here is write specific instances for State and StateT
21:34:46 <coffeemug> dons: please email me the resolution if you guys ever get there :)
21:34:50 <dons> yep
21:34:55 <coffeemug> gn
21:34:56 <dons> sjanssen: ah maybe
21:34:57 <Cale> yeah, that's about all you can do
21:34:58 <dons> night1
21:35:08 <Cale> Or remove the instance that's in fptools :)
21:35:38 <Cale> But then people would lose their lifting instances and that would be bad :)
21:36:00 <sjanssen> hmm, yeah
21:36:51 <sjanssen> does overloaded get work in nested StateT's?
21:43:35 <Pupeno> Is anybody working on a library to properly encode/decode strings to UTF-8 and maybe others ? To have a set of IO functions that handle that correctly ?
21:45:52 <dolio> Bulat's streams might do that somewhat conveniently.
21:46:02 <dolio> But that's more of a replacement for the entire IO system.
21:46:30 <beschmi> http://haskell.org/haskellwiki/Library/Streams
21:46:34 <lambdabot> Title: Library/Streams - HaskellWiki, http://tinyurl.com/wh6l4
21:47:29 <Botty> dons - here's an interpreter for it:
21:47:31 <Botty> interpret s (1:x1:x2:xs) = interpret ((x1 * 2^8 + x2):s) xs
21:47:31 <Botty> interpret s (2:x1:x2:x3:x4:xs) = interpret ((x1 * 2^24 + x2 * 2^16 + x3 * 2^8 + x4):s) xs
21:47:31 <Botty> interpret (s1:s2:s) (o:xs) = interpret (((case o of 10 -> (+); 11 -> (-); 12 -> (*); 13 -> (^); 14 -> div; 15 -> mod) s1 s2):s) xs
21:47:32 <Pupeno> That's on my TOREAD list. I think I should increase its prority.
21:47:32 <Botty> :)
21:47:39 <dons> ?pl \f c -> prec c . f
21:47:40 <lambdabot> flip ((.) . prec)
21:48:40 <Botty> I should really test stuff before i paste...
21:49:25 <dons> Botty: http://haskell.org/haskellwiki/Talk:Haskell_Quiz/Bytecode_Compiler/Solution_Michael_Sloan
21:49:28 <lambdabot> Title: Talk:Haskell Quiz/Bytecode Compiler/Solution Michael Sloan - HaskellWiki, http://tinyurl.com/vhcd7
21:49:36 <dons> I just went through and refactored it for fun, only checking it type checked
21:49:54 <dons> i like the 'prec' idea
21:50:06 <Botty> thanks. stands for precedence
21:50:13 <Botty> though thats not really what it does
21:50:13 <sjanssen> why not use Parsec for parsing?
21:50:32 <dons> ?pl foldl (\f c -> prec c . f) id "+-*/^"
21:50:33 <lambdabot> foldl (flip ((.) . prec)) id "+-*/^"
21:50:36 <Botty> sjanssen - well, parsecs stuff for this is special case anyway.  I wanted to write my own
21:51:12 <beschmi> http://beschmi.cloaked.no-ip.org/shim.png <- function name completion in emacs
21:52:04 <palomer> emacs is a half decent operating system
21:52:58 <dons> it's this kind of thing on reddit that just bores me to tears " Installing Wordpress Multiuser on Windows"
21:53:07 <dons> that's _not_ programming
21:53:31 <dons> maybe there should be windowsadvice.reddit.com
21:53:42 <palomer> did you guys read the article about how "open source" is not a verb
21:53:48 <palomer> I don't see how it's not a word
21:53:51 <palomer> err, verb
21:53:52 <Botty> whoah.  I like how the foldl prec thing works
21:54:00 <dons> hehe
21:54:17 <dons> foldl (\f c -> (prec c) . f) id ['+', '-', '*', '/', '^'] :: [Tok]
21:54:17 <dons>                                                              -> [Tok]
21:54:26 <jcreigh> dons: or a tagging system instead of "subreddits"
21:54:41 <dons> Botty, so prec :: Char -> [Tok] -> [Tok]
21:54:44 <theoco> palomer: I agree seems like a verb to me, besides the fact it is two words
21:54:44 <dons> jcreigh: yeah maybe
21:54:59 <Botty> even though you wrote the operators in the wrong order :)
21:55:07 <Botty> or you just used the wrong fold ;p
21:55:10 <dons> ah but the foldl should handle that ?
21:55:17 <dons> i think a foldr with the other way around might eb shorter
21:55:28 <dons> anyway, the result should be: prec a . prec b . prec c
21:55:37 <dons> right? so that's the same as prec a . prec b . prec c . id
21:55:59 <dons> which is foldl (\f c -> prec c . f) id [a, b , c]
21:56:14 <dons> at least that's the intuition, i might have th efold around the wrong way
21:56:48 <dons> the idea is to use (.) to concat the the list of [prec a, prec b, prec c]
21:57:01 <dons> i.e. foldl (.) id . map prec [a,b,c] -- would be another
21:57:08 <dons> ?type foldl (.) id
21:57:10 <lambdabot> forall b. [b -> b] -> b -> b
21:57:11 <Botty> right
21:57:22 <dons> so i manually fused the fold and the map
21:57:29 <Botty> foldr (\c f -> prec c . f) id "+-*/^%" is correct
21:58:16 <palomer> ICFP is for chumps
21:59:03 <dons> ?pl \c f -> prec c . f
21:59:04 <lambdabot> (.) . prec
21:59:07 <dons> which is nice
21:59:17 <dons> foldr ((.) . prec) id "+-*/^%"
21:59:25 <dons> take that ruby!
21:59:42 <Botty> mm yes :)
22:02:05 <Botty> I actually really like this sort of parsing method.  I think something similar (but much more complicated) to the precedence method can be used for natural language.
22:03:12 <dons> yeah, its cute
22:04:17 <lispy> ?palomer
22:04:17 <lambdabot> (_|_)
22:06:59 <dons> btw, palomer, you're still being relentlessly negative and carping. I think we'd all appreciate it if you didn't bother with the random whining remarks. we're trying hard to keep this a fun place to hang out.
22:07:33 <dons> it's great that your back and all, but if you actually contributed some solutions and code, instead of bitchy remarks it would be nicer for everyone.
22:08:36 <dons> palomer: ^^ in case your irc client doesn't spot that.
22:13:17 <Botty> Ahaha
22:13:28 <Botty> my interpreter:
22:13:29 <Botty> interpret (s1:s) [] = s1
22:13:29 <Botty> interpret s (1:x1:x2:xs) = interpret ((x1 * 2^8 + x2):s) xs
22:13:29 <Botty> interpret s (2:x1:x2:x3:x4:xs) = interpret ((x1 * 2^24 + x2 * 2^16 + x3 * 2^8 + x4):s) xs
22:13:29 <Botty> interpret (s1:s2:s) (o:xs) = interpret (((case o of 10 -> (+); 11 -> (-); 12 -> (*); 13 -> (^); 14 -> div; 15 -> mod) s1 s2):s) xs
22:13:39 <Botty> ruby's interpreter: http://www.rubyquiz.com/interp.rb
22:14:20 <dolio> Heh.
22:14:28 <dons> palomer: what's the difference between what you've written since you've been back, http://www.cse.unsw.edu.au/~dons/tmp/palomer.txt, and guys like AI_coder that we kick for trolling ?
22:14:30 <lambdabot> http://tinyurl.com/y3j7sm
22:15:02 <jcreigh> Botty: is that for the latest Ruby Quiz?
22:15:41 <Botty> #100, if that's the latest
22:16:03 <Botty> yes
22:16:34 <dolio> About 2/3 of that is unit tests.
22:18:03 <dolio> Still, it's still a lot more than 4 lines, I suppose.
22:18:12 <Botty> yes
22:18:20 <falconair_> I just started going through a paper referenced here recently "XLinq: XML Programming Refactored (The Return Of The Monoids)" ... is there a reference which explains using monoids to process xml, collections (or any linear/tree/graph datastructure) WITHOUT using visual basic? (perhaps using algabraic data types?)
22:18:30 <Botty> I don't even need unit tests, its workingness is self evident
22:18:49 <dons> hmm. i'm almost certain there's something on monoids for data structures...
22:18:54 <dons> since we use them for [a]
22:19:15 <dons> falconair_: checked 'monoid' on scholar.google.org or citeseer?
22:19:29 <dons> ?docs Data.Monoid
22:19:30 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html
22:19:38 <dons> ?source Data.Monoid
22:19:39 <lambdabot> http://darcs.haskell.org/packages/base/Data/Monoid.hs
22:19:59 <dons> ah, so the src would be a mark jones paper
22:20:10 <dons> the famous 'Functional Programming with Overloading and Higher-Order Polymorphism'
22:21:42 <falconair_> ok, i'm printing it out...i'm assuming that the XLinq paper is similar to the Bananas, Brackets, Lenses,... paper by Eric Meijer (more examples from the industry, less category theory)?
22:35:53 <Botty> ?check \x :: Int -> foldl (\c (i, n) -> c + n * 2^(i*8) ) 0 . zip [3,2,1,0] (map (\i -> (x `div` 2^(i*8)) `mod` 256 ) [3,2,1,0]) == x
22:35:55 <lambdabot>  Parse error
22:36:40 <dons> the type annotatoin in a pattern is a non-h98 extension
22:36:45 <dons> Plarepla@69-11-51-199.sktn.hsdb.sasknet.sk.ca] has joined #haskell
22:36:48 <dons> grr
22:36:57 <lispy> proton?
22:36:59 <Botty> ?check \x -> foldl (\c (i, n) -> c + n * 2^(i*8) ) 0 (zip [3,2,1,0]) (map (\i -> (x `div` 2^(i*8)) `mod` 256 ) [3,2,1,0]) == x
22:37:00 <lambdabot>    Expecting a function type, but found `[b]'       Expected type: [(a1, t ...
22:37:08 <dons> no, pasto
22:37:19 <lispy> i don't know pasto
22:37:35 <dons> so you can use ?check \x -> let _=x::Int in ... instead
22:38:00 <Botty> ?check \x -> foldl (\c (i, n) -> c + n * 2^(i*8)) 0 (zip [3,2,1,0] (map (\i -> (x `div` 2^(i*8)) `mod` 256 ) [3,2,1,0])) == x
22:38:02 <lambdabot>  Add a type signature
22:38:13 <lispy> dons: as for palomer, i've been asking him to be more positive too...i think it would be good for him.  He's a nice guy, but yeah, a bit too whinny
22:38:27 <Botty> ?check \x -> let _=x::Int in foldl (\c (i, n) -> c + n * 2^(i*8)) 0 (zip [3,2,1,0] (map (\i -> (x `div` 2^(i*8)) `mod` 256 ) [3,2,1,0])) == x
22:38:29 <lambdabot>  OK, passed 500 tests.
22:38:31 <Botty> woot
22:38:53 <Botty> ?scheck \x -> let _=x::Int in foldl (\c (i, n) -> c + n * 2^(i*8)) 0 (zip [3,2,1,0] (map (\i -> (x `div` 2^(i*8)) `mod` 256 ) [3,2,1,0])) == x
22:38:55 <lambdabot>  Completed 10 test(s) without failure.
22:40:26 <dons> lispy, i'm concerned that he's the "noisy non-contributor" personality, who says so much that we don't realise the negative effect he has. the svn guys had to remove someone from their lists for the same kind of reason
22:41:11 <dons> i struggle to find times where i have found his input useful or insightful. let alone any time when he's helped a beginner
22:41:14 <dons> which worries me
22:41:24 <lispy> yeah
22:41:34 <lispy> framed that way i see the concern
22:41:35 <dons> i guess we'll see how things go in the next week or so
22:42:25 <dons> if you check the log since he's been back, i don't see very little relevant contributions :/
22:42:31 <dons> s/don't//
22:42:34 <lispy> right
22:42:49 <dons> http://www.cse.unsw.edu.au/~dons/tmp/palomer.txt
22:42:51 <lambdabot> http://tinyurl.com/y3j7sm
22:42:55 <ibid> dons, submitted a long time ago, even discussed here :)
22:43:10 <dons> good :)
22:43:26 <dons> ibid, btw, did we formerly have tmoertel's blog on planet.haskell?
22:43:35 <falconair_> can 'monad comprehensions' be used to traverse graphs as well as trees, lists?
22:43:41 <dons> has it disappeared, or do i imagine it.
22:43:55 <ibid> dons: i don't recall from that nick
22:44:29 <dons> tom moertel, http://blog.moertel.com/articles/tag/haskell
22:44:31 <lambdabot> Title: Tom Moertel's Weblog - tag haskell
22:44:39 <dons> if we've not asked him, I think maybe we should.
22:45:02 <ibid> dons: the only reason blogs have been disabled is that it has (semi)permanent technical difficulties, or technical incompatibility with planet-style aggregation
22:45:15 <dons> ah ok. so perhaps i'll ask him then :)
22:46:30 <dons> tmoertel_away: ^^ would you like to have your blog syndicated to planet.haskell.org ? if so, ping ibid with the rss feed (is there an rss feed?)
22:47:33 <ibid> dons: why is it that everybody submits just haskell-related content?  the experience with planet debian is that planet is best when it's not just a technical forum but forum of technical people. notice my and cosmicray's posts :)
22:48:41 <dons> hmm. not sure. i suppose i've only asked people with a significant haskell content, perhaps that biases it?
22:48:48 <dons> (hey, i write on music sometimes  :)
22:48:54 <dons> (and cats)
22:49:24 <dons> ibid, maybe have some text to   that effect on the page? stating the goal?
22:49:42 <dons> "Not just a technical forum"
22:49:44 <ibid> dons: i'm waiting for HCAR to publish it :)
22:49:49 <dons> ok good.
22:50:02 <ibid> dons: do you know how much a wait is that?
22:50:10 <dons> hmm, a couple of weeks?
22:50:14 <dons> takes a little while
22:50:18 <sjanssen> I suspect that planet.haskell.org has more content on catamorphisms than cats
22:50:22 <dons> heh
22:50:22 <ibid> oki probably should publish it myself
22:50:35 <dons> ?remember sjanssen I suspect that planet.haskell.org has more content on catamorphisms than cats
22:51:16 <ibid> dons: the main point is, it's content by haskell people, not just haskell content by people.  there are multitude of ways to qualify as "haskell person", one of which is "writes lots of haskell stuff in blog"
22:51:57 <ibid> dons: another is "everybody in haskell knows who you are and what you did to haskell", which qualified wadler :)
22:52:06 <dons> right.
22:52:23 <sjanssen> "did to" sounds negative ;)
22:52:38 <ibid> sjanssen: hah
22:52:41 <dons> i've found the recent bloggers by having their stuff turn up in my google blog search query=hsakell rss feed
22:52:51 <dons> which tracks down anyone writing on haskell
22:52:57 <ibid> dons: yes, i know :)
22:52:59 <dons> so that then biases the results, since i forward those guys to you
22:53:04 <ibid> dons: you've mentioned :)
22:53:14 <dons> now, i wonder how we can fix that
22:53:16 <ibid> i probably should blog my HCAR entry
22:53:22 <ibid> dons: is there a need?
22:53:44 <dons> you're not concerned? i though you raised this because we didn't have enough non-geek content? :)
22:53:44 <ibid> dons: just keep an eye on bloggers at the lists and the new newsgroup?
22:53:54 <dons> yeah ok
22:54:00 <ibid> dons: nope, i was wondering why everyone submits haskell-tagged feeds
22:54:08 <dons> ah yes.
22:54:18 <Cale> Did anyone figure out why there's a new newsgroup?
22:54:18 <dons> they want to hide their non-haskell content from you
22:54:26 <ibid> Cale: because it was asked for
22:54:34 <dons> Cale: no idea. last change to save it?
22:54:52 <Cale> There's already gmane, isn't there?
22:54:59 <ibid> Cale: there was a request for discussion a few weeks ago, posted in comp.lang.functional and on haskell list
22:55:09 <ibid> Cale: read the discussions (in news.groups)
22:55:32 <dons> ibid, is there a lot of news group content that i miss in the weekly news?
22:55:41 <ibid> dons: you might want to prod the group proponent to write an entry to HCAR
22:56:02 <dons> hmm. yes.
22:56:11 <ibid> dons: the new group has no propagated to my server yet, so i don't know about that, but comp.lang.functional has a lot of haskell content
22:56:27 <dons> yeah. hmm. i should start monitoring it then
22:56:52 <ibid> dons: i'd expect most of the haskell content to move to the new group once it propagates
22:57:17 <dons> ok good. that makes it easier
22:57:22 <Botty> hmm, how do i have an expression for when none of the guards in a function apply?
22:57:48 <Cale> I don't understand why people would bother with creating a usenet group when there are already perfectly good mailing lists. This is just going to make it more difficult to keep on top of things, isn't it?
22:57:49 <sjanssen> Botty: | otherwise = someCode
22:57:55 <Botty> oh, ok, thanks
22:58:13 <ibid> Cale: go read the discussion
22:58:44 <ibid> Cale: briefly, there are a lot of people in usenet who don't frequent the lists and who write about haskell
22:58:49 <ibid> well, some at least
22:58:52 <dons> yeah, that's a bit scary
22:59:09 <dons> are there projects that rise and fall in usenet and never make it to the outside world?
22:59:39 <ibid> i am myself more a usenetter than a mailing lister :)
22:59:52 <dons> its not efficient (for such a small community) to be fragmented :/
23:00:07 <dons> we miss collaboration chances, patches, solutions ...
23:00:08 <ibid> to me, if it's not in usenet, it needs to be damn good for me to  bother with it
23:00:18 <dons> wow
23:00:30 <sjanssen> is this just a question of tool preference?
23:00:31 <ibid> well, used to at least
23:00:35 <dons> but there are some things that have to happen via email: patches to the base libraries, for example
23:01:00 <dons> hi tom. we were just wondering if you'd like to have your blog syndicated on planet.haskell.org
23:01:07 <ibid> dons: of course. i was talking about general discussions, helping newbies etc. -cafe kind of stuff
23:01:11 <dons> since you're kinda the leading light of the haskell blog community ... :)
23:01:27 <ibid> sjanssen: tool preference is a part of it
23:01:46 <ibid> sjanssen: but usenet is also a community (a large and diverse one, true)
23:01:58 <dons> ibid, what's the best web interface to usenet, for me to track it ?
23:02:07 <dons> to track the comp.lang.*.haskell stuff
23:02:43 <dons> i'll see if I can include usenet in future HWN issues.
23:03:03 <tmoertel> dons, ibid: I just msg'd ibid w/ the Atom feed URL
23:03:44 <tmoertel> dons: I use groups.google.com for usenet surfing
23:05:00 <ibid> dons: groups.google.com is okay, though it has trouble with posting in usenet-accepted style
23:05:19 <Botty> hmm, has anyone made an interpreter that auto-reloads files that you load?
23:05:24 <Botty> (for haskell)
23:05:27 <Botty> would be nice...
23:05:35 <ibid> dons: but for serious use you'd want to use a newsreader
23:05:36 <dons> Botty: yeah, there's a script for ghci to do this
23:05:36 <Botty> I mean files that you modify
23:05:39 <Botty> cool
23:06:03 <dons> Botty: investigate the :define command to ghci, let's you run arbitrary haskel code
23:06:13 <dons> tmoertel: great.
23:06:19 <ibid> added
23:11:11 <Botty> haha, just found something that the ruby thing doesn't test, and most of the entries probably can't do
23:11:22 <Botty> -(1+2)
23:11:41 <zptao> does Haskell involve a lot of math?
23:11:52 <zptao> just wondering before i try it
23:12:06 <Botty> not necessarily, however it is often used by mathier folks
23:12:22 <merus> Haskell is awesome for maths :)
23:12:27 <Botty> yes
23:12:33 * merus is a "mathier folk"
23:13:39 <Cale> zptao: You don't need a lot of mathematical knowledge to use Haskell
23:13:51 <merus> I'm in a pickle, though.  I'm running OS X 10.3.9 and it seems like the only compiler that still supports it is hugs :(
23:13:55 <Cale> zptao: But the programming language as a whole has a sort of mathematical feel to it
23:14:17 <merus> Using the word "compiler" kinda loosely :)
23:14:53 <Botty> yeah, the language is formally based on mathematics, making it much more attractive to mathy people, but you don't really need to know that to use it
23:15:56 <Cale> For instance, you can substitute things which are equal in order to understand your program better, which is nice.
23:16:03 <tmoertel> dmead: are you still conversing w/ ron jeffries about the bowling stuff?
23:36:16 <Botty> how do I represent an IO action that does nothing?
23:36:25 * Botty already tried IO ()
23:37:47 <tmoertel> Botty: the type or the value?
23:37:56 <Botty> value
23:38:07 <tmoertel> return ()
23:38:14 <Botty> oh, ok
23:38:44 <mwc> Huh? What did I miss, GHC stopped supporting GHC 10.3.x?
23:39:14 <sieni> mwc: OS X?
23:39:21 <sieni> shit
23:39:24 <mwc> yeah
23:39:26 <mwc> that's what I meant
23:39:36 <mwc> I read it up above in the convo involving merus
23:39:38 * sieni has OS X 10.3 too at home :-(
23:40:02 <sieni> I would have wanted to wait until 10.5 before upgrading, but what the heck...
23:40:20 <merus> It may just be I can't find the older version of GHC
23:40:52 <mwc> merus,http://www.haskell.org/ghc/download_ghc_641.html#macosx
23:40:54 <merus> I can't upgrade to 10.5 -- no DVD drive :(
23:40:55 <lambdabot> Title: GHC: Download version 6.4.1, http://tinyurl.com/t63wa
23:41:14 <mwc> I think they don't build it for 10.3 anymore, but you shouldn't have any trouble doing your own build of 6.6 once 6.4 is installed
23:41:41 <sieni> mwc: ahh, well I'm grabbing it from macports anyway
23:41:42 <merus> Thanks, I'll try that.
23:42:11 <merus> hacking around in hugs is ... annoying :/
23:42:20 <dons> who said its not supported?
23:42:25 <dons> do we have a ref for that/
23:42:46 <dgoldsmith> merus: you can get 10.4 on CDs by exchanging the media.
23:42:49 <mwc> dons, I read something earlire... seems they just don't build for 10.3 anymore.
23:43:08 <dons> maybe none of the devs have 10.3 still (i.e. wolfgang or audreyt)
23:43:13 <dons> if someone does though, build it and post the binary
23:43:17 <mwc> that's what I figured
23:43:44 <dons> everything's supported :) even ia64, which we don't want to support
23:43:52 <merus> dgoldsmith: There's no reason for me to upgrade, anyway.  My laptop only has about a year left.
23:43:55 <Botty> there's only 2 main devs? holy crap!
23:43:56 <mwc> Heh, why does everybody hate IA64?
23:44:01 <dons> Botty: for the mac
23:44:03 <mwc> Botty, for mac
23:44:05 <Botty> ohhh
23:44:06 <dons> there's a few others.
23:44:09 <merus> Sorry, perhaps saying "not supported" was a lie :<
23:44:10 <dons> quite a few :)
23:44:18 <mwc> merus, no worries, it's all been sorted out
23:45:06 <merus> Now I can finally get around to using that Groebner basis implementation... mwahahahaa...
23:46:18 <mwc> I'd warn you that compiling on a powerbook is slow... Took upwards of 6 hours on my 1.5 Ghz PB G4 with 1.25 GB ram
23:48:54 <mwc> dons, I'd think that given all the parallelism a typical haskell program encodes, IA64 would be a playground of code generation tricks
23:49:18 <mwc> I've always heard that the trick to generating code for it is to find massive amounts of parallelism
23:50:33 <dons> yeah, they're just expensive, hot and slow :|
23:50:41 <Botty> ah, that's the one that uses the long instructions eh?
23:50:48 <dons> if they were a commodity machine, then the story might be different
23:51:05 <Botty> forgot what they are at the moment, its like you fit 6 or so instructions into 64 bits or something
23:51:15 <dons> ia64 is only supported because HP gave one away to a group with a ghc developer
23:51:34 <mwc> I'd love to see ARM supported
23:51:43 <Botty> ooh yes ARM ASM is awesome
23:51:50 <mwc> Get some haskell on my ipaq
23:54:08 <dons> Igloo's working on it.
23:54:15 <dons> until then there's nhc98 which does work on the ipaq
23:54:18 <dons> and hugs
23:58:04 <mwc> huh, I can't find downloads for either of them for ARM/WinCE
23:59:46 <dons> oh, probably not packaged up nicely. it would be strictly build-it-yourself-but-should-workd
