00:05:03 <dons> pkhuong: actually, i think i have a reference for CPS v monads. let me check ...
00:07:07 <dons> pkhuong: hmm, maybe "Environments, Continuation Semantics and Indexed Categories', http://www.cs.bham.ac.uk/~hxt/research/TACSfinal.ps. ah also "Monads and composable continuations', http://homepages.inf.ed.ac.uk/wadler/papers/composable/composable.ps.gz
00:07:11 <lambdabot> http://tinyurl.com/t4r2z
00:08:14 <dons> someone needs to distill the details, tradeoffs and issue, and blog it for all to see...  :)
00:10:29 <pkhuong> nice try ;) Good night.
00:10:39 <dons> heh
00:10:44 <pkhuong> (and thank you)
00:10:56 <dons> sure! and hope to see you back here.
00:12:41 <Botty> ooh, hey, can haskell preprocess 'error's
00:12:56 <Botty> eg, if you supply a function with constants which will for sure make it error
00:13:05 <Botty> maybe i should narrow it down to ghc
00:13:47 <dons> what do you mean by 'preprocess' ?
00:13:53 <dons> do you have an example
00:14:42 <Botty> > let foo x = if x then error "uh oh" in foo True
00:14:42 <lambdabot>  Parse error
00:15:04 <Botty> > let foo x = if x then error "uh oh" else 12 in foo True
00:15:05 <lambdabot>  Exception: uh oh
00:15:17 <Botty> but get that exception at compile time
00:16:12 <Botty> perhaps as a warning, not an error
00:17:26 <Botty> actually, I just found another way to do my thing where I don't need such errors, but still, an interesting idea i think
00:19:27 <dons> if you leave a case out in a pattern match, you'll get a warning
00:20:16 <dons> > let foo x = case x of (_:_) -> True in foo []
00:20:18 <lambdabot>  Non-exhaustive patterns in case
00:20:24 <dons> (compile time)
00:20:38 <Botty> ah
00:20:46 <dons> > let foo x = case x of (_:_) -> True ; [] -> error "hey" in foo []
00:20:47 <lambdabot>  Exception: hey
00:21:02 <dons> now, ndm's new Catch tool will probably spot this error is always going to happen
00:21:07 <dons> also, HPC can spot it as well
00:21:15 <dons> they're extra analysis tools though
00:21:21 <dons> not built in to the compiler
00:21:55 <Lemmih> Does HPC say what code is guaranteed to run?
00:22:07 <dons> at least it knows code that won't run
00:22:13 <dons> ?where hpc
00:22:14 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_Program_Coverage
00:22:36 <Lemmih> dons: Yes, by running it. It doesn't guarantee anything.
00:22:45 <dons> ah right
00:22:47 <dons> yes of course.
00:22:56 <dons>  so you would need Catch for that then
00:23:03 <dons> to actually find this statically
00:23:19 <dons> or maybe ESC , Dana Xu's tool?
00:23:24 <Heffalump> is that released?
00:23:36 <dons> don't think so (?)
00:24:19 <dons> and why isn't she on the mailing lists and in #haskell.. she might get patches if she was!
00:24:28 <dons> maybe i should email her shapr-style and invite?
00:25:17 <Heffalump> it doesn't actually work on Haskell, AFAIK
00:25:32 <Heffalump> though her web page implies she wants to make it do so
00:25:38 <Botty> my god, I can't believe there's no Map a b -> [a] -> [b]
00:25:43 <wolverian> heh, these introduction to FP slides have a nice chart of pure FP history
00:25:48 <dons> hmm? isn't the paper called "ESC for Haskell" or some such?
00:25:57 <Heffalump> dons: IM full Haskell
00:26:08 <Heffalump> Botty: isn't it just map (fromJust . lookup) ?
00:26:10 <dons> Botty: what does that function do? return all the elems that are associated with a list of keys?
00:26:12 <wolverian> wow, nhc is old.
00:26:25 <dons> ?type map (fromJust . M.lookup)
00:26:26 <lambdabot> Couldn't find qualified module.
00:26:33 <dons> ?type map (fromJust . Data.Map.lookup)
00:26:34 <lambdabot>   Expecting a function type, but found `b'
00:26:35 <lambdabot>    Expected type: a1 -> Maybe a
00:26:37 <Botty> dons - no, translate a list using the map
00:26:58 <Heffalump> that's what dons said
00:27:03 <dons> yeah :)
00:27:16 <Heffalump> @type map (fromJust . flip (Data.Map.lookup))
00:27:17 <Botty> yeah, i suppose ;)
00:27:17 <lambdabot>   Expecting a function type, but found `b'
00:27:18 <lambdabot>    Expected type: a1 -> Maybe a
00:27:26 <Heffalump> @type Data.Map.lookup
00:27:27 <lambdabot> forall a (m :: * -> *) k. (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
00:27:28 <Lemmih> ?type \m -> map (fromJust . flip Data.Map.lookup m)
00:27:29 <lambdabot> forall a a1. (Ord a1) => Data.Map.Map a1 a -> [a1] -> [a]
00:27:38 <dons> ?type \m -> map (\k -> fromJust . Data.Map.lookupk  m)
00:27:40 <lambdabot> Not in scope: `Data.Map.lookupk'
00:27:42 <Heffalump> hmph.
00:27:47 <dons> ?type \m -> map (\k -> fromJust . Data.Map.lookup k m)
00:27:49 <lambdabot> forall a a1 a2. (Ord a) => Data.Map.Map a (Maybe a1) -> [a] -> [a2 -> a1]
00:27:57 * Heffalump incompetent :-)
00:28:20 <dons> ah, Lemmih wins
00:28:26 <dons> Lemmih++
00:28:31 <Lemmih> heh
00:28:34 <Heffalump> @karma Lemmih
00:28:35 <lambdabot> Lemmih has a karma of 24
00:28:38 <Heffalump> @karma dons
00:28:38 <lambdabot> dons has a karma of 80
00:28:47 <Heffalump> ah, he may have won the battle, but dons is clearly winning the war ;-)
00:28:51 <dons> ?karma Heffalump
00:28:51 <lambdabot> Heffalump has a karma of 6
00:28:54 <dons> oh!
00:29:20 <dons> i guess you lost a bit of karma due to alzhiemers/lack of persistent state prior to 2005
00:29:51 <Heffalump> yeah, and I'm not around that much these days
00:29:58 <Heffalump> I doubt I ever had much though
00:30:21 <Botty> thanks, but that's also pretty ugly.  should go in the lib
00:30:30 <dons> ?pl \m -> map (fromJust . flip Data.Map.lookup m)
00:30:31 <lambdabot> map . ((fromJust . flip Data . Map) .) . lookup
00:30:36 <Heffalump> Botty: conversely, I've never had a use for it, and I think the lib is already pretty cluttered
00:30:49 <dons> ?let mapMap = \m -> map (fromJust . flip Data.Map.lookup m)
00:30:49 <Heffalump> @type flip Data
00:30:50 <lambdabot> <local>:14:36: Not in scope: `Data.Map.lookup'
00:30:51 <lambdabot> Not in scope: data constructor `Data'
00:31:00 <Heffalump> this whole . thing is silly.
00:31:04 <Botty> wierd. I'm using it twice in a short piece of code
00:31:04 <dons> ?let mapMap = \m -> map (fromJust . flip M.lookup m)
00:31:05 <lambdabot> <local>:14:36:     Ambiguous type variable `a' in the constraint:       `Ord ...
00:31:20 <dons> Botty: just define mapMap or some such :)
00:31:23 <Heffalump> you can always define it yourself, of course.
00:31:32 <Botty> of course
00:31:50 <lispy> Cale: without knowing how the inital image was created this may not be easy to recreate
00:31:58 <Botty> I will, but still.  I think it is more worthy than alot of the functions in that module
00:32:52 <Heffalump> Botty: ah, now that may be true :-)
00:43:41 <Botty> alright, thanks
00:43:50 <Botty> ?type \m -> fromJust . flip Data.Map.lookup m
00:43:51 <lambdabot> forall a a1. (Ord a) => Data.Map.Map a a1 -> a -> a1
00:45:53 <dons> ?pl \m -> fromJust . flip lookup m
00:45:54 <lambdabot> (fromJust .) . flip lookup
00:46:00 <dons> ah, that's `dot`
00:46:09 <dons> fromJust `dot` flip lookup
00:46:23 <Heffalump> @type `dot`
00:46:24 <lambdabot> parse error on input ``'
00:46:28 <Heffalump> @type dot
00:46:29 <lambdabot> Not in scope: `dot'
00:46:39 <dons> dot = (.) . (.) -- named it this morning
00:47:09 <dons> ?type let dot = (.) . (.) in fromJust `dot` flip Data.Map.lookup
00:47:10 <lambdabot> forall a a1. (Ord a) => Data.Map.Map a a1 -> a -> a1
00:47:38 <dons> could do with a better name. i'm open to suggestions.
00:47:43 <Botty> I hear ((.).(.)) is pretty fun to play with
00:47:47 <dons> if it keeps coming up like this, i might try to get it into Data.Functoin
00:47:57 <dons> yeah, ((.)$(.)) too
00:48:01 <Heffalump> can you explain what it does?
00:48:09 <Heffalump> without resorting to a definition :-)
00:48:14 <dons> handles pointfree application of two args
00:48:30 <dons> so avoids the (f .) . g or (. f) . g form
00:48:30 <Heffalump> @pl (\x y -> f (g x y))
00:48:31 <lambdabot> (f .) . g
00:48:35 <dons> for soaking up extra args
00:48:42 <Heffalump> @pl (\f g x y -> f (g x y))
00:48:42 <lambdabot> (.) . (.)
00:48:52 <Heffalump> @pl (\f g x y z -> f (g x y z))
00:48:53 <lambdabot> (.) . (.) . (.)
00:48:56 <dons> now, ust need to phrase that in a way that makes it convincing for libraries@, like `on` has done
00:49:03 <dons> so yeah, there's dot2 dot3 ...
00:49:15 <Heffalump> I think what you are calling dot should be dot2
00:49:23 <Heffalump> and (.) should be dot or dot1
00:49:30 <dons> ah yes.
00:49:49 <dons> but I don't want to have dot2 for the most common case.
00:50:07 <Heffalump> I think it would be _far_ too confusing to have (.) and dot be different.
00:50:17 <dons> true.
00:50:18 <Heffalump> We've already got enough trouble with the . for name scoping.
00:51:00 <dons> f . g , f .: g , f ..: g ...
00:51:07 <dons> so (.) . (.) could be .:
00:51:11 <dons> not sure though
00:51:16 <Heffalump> I don't see the logic of the : there
00:51:27 <dons> stack the .'s vertically :)
00:51:32 <Heffalump> would it be illegal to make (..) an operator?
00:51:48 <dons> well, its odd numbered, so you'd have: .  ...  .....
00:51:50 <Botty> ?type (..)
00:51:51 <lambdabot> parse error on input `..'
00:51:55 <Botty> guess not
00:51:59 <dons> ?type . .
00:51:59 <Heffalump> dons: only if you think of the definition
00:52:00 <lambdabot> parse error on input `.'
00:52:04 <dons> ?type (.) (.)
00:52:05 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
00:52:14 <dons> ?type (.) . (.)
00:52:15 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
00:52:23 <Heffalump> dons: IM if you think of the definition in terms of (.) . (.)
00:52:30 <dons> ah yes.
00:52:30 <Heffalump> the direct definition makes it seem like it should be even numbered
00:52:42 <dons> you mean \f g x y -> f (g x y)
00:52:43 <Heffalump> not even numbered, naturally numbered
00:52:43 <dons> ?
00:52:44 <Heffalump> yes
00:52:59 <satan> hmmm how can i check if an element exists at a certain index in a list?
00:52:59 <Heffalump> and I think that definition is much more helpful than the pointfree obfuscation, fun though that is
00:53:05 <dons> so its dot dot2 dot3
00:53:14 <Heffalump> satan: is it a finite list?
00:53:23 <dons> satan: one of the index funtion?
00:53:24 <satan> Heffalump: nope
00:53:28 <dons> ?type elemAt
00:53:30 <lambdabot> Not in scope: `elemAt'
00:53:46 <dons> well, you can always index
00:53:48 <Heffalump> or rather, not guaranteed to be finite, I guess.
00:53:51 <roconnor> dons: isn't it f .:: g?
00:53:54 <Heffalump> dons: not if it might not be there
00:54:02 <Heffalump> how about length (take n xs) == n
00:54:04 <satan> and get an exception if its not there?
00:54:26 <Heffalump> @run length (take 3 [1,2])
00:54:26 <dons> hmm, elemIndex ?
00:54:28 <lambdabot>  2
00:54:31 <Heffalump> ? length (take 3 [1,2])
00:54:37 <Heffalump> @eval length (take 3 [1,2])
00:54:42 <Heffalump> gah, I can never remember this one..
00:54:46 <Heffalump> > length (take 3 [1,2])
00:54:46 <dons> > elemIndex 'x' "haskexll"
00:54:47 <satan> i wanna see if there's an element at xs !!4, if not, then return 0
00:54:47 <lambdabot>  2
00:54:48 <lambdabot>  Just 5
00:54:50 <satan> thats what i wanna do
00:55:18 <Heffalump> > (\xs -> if length (take 4 xs) == 4 then xs!!4 else 0) [1,2,3]
00:55:19 <lambdabot>  0
00:55:22 <Heffalump> > (\xs -> if length (take 4 xs) == 4 then xs!!4 else 0) [1,2,3,4]
00:55:23 <lambdabot>  Exception: Prelude.(!!): index too large
00:55:31 <Heffalump> > (\xs -> if length (take 5 xs) == 5 then xs!!4 else 0) [1,2,3,4,5]
00:55:33 <lambdabot>  5
00:55:33 <Heffalump> (oops :-)
00:56:19 <Heffalump> shorter is
00:56:20 <dons> > (\ n x xs -> case elemIndex x xs of Nothing -> False ; Just i -> n == i ) 4 'x' "haskxell"
00:56:22 <lambdabot>  True
00:56:43 <Heffalump> > (\xs -> if null (drop 4 xs) then 0 else xs!!4) [1,2,3,4,5]
00:56:45 <lambdabot>  5
00:56:46 <dons> > (\ n x xs -> case elemIndex x xs of Nothing -> False ; Just i -> n == i ) 4 'x' "hasXXXell"
00:56:47 <lambdabot>  False
00:57:32 <dons> ?let isAt = \ n x xs -> case elemIndex x xs of Nothing -> False ; Just i -> n == i
00:57:33 <lambdabot> <local>:14:24:     Ambiguous type variable `a' in the constraint:       `Eq a...
00:57:42 <dons> ?undefine
00:57:43 <lambdabot> Undefined.
00:57:45 <dons> ?let isAt = \ n x xs -> case elemIndex x xs of Nothing -> False ; Just i -> n == i
00:57:45 <lambdabot> <local>:1:24:     Ambiguous type variable `a' in the constraint:       `Eq a'...
00:57:50 <dons> boo
00:58:44 <dons> ?let isAt = \ (n::Int) x xs -> case elemIndex x xs of Nothing -> False ; Just i -> n == i
00:58:45 <lambdabot>  Parse error in pattern
00:59:04 <dons> ?let isAt = \ n x xs -> case elemIndex x xs of Nothing -> False ; Just i -> (n::Int) == i
00:59:05 <lambdabot> <local>:1:24:     Ambiguous type variable `a' in the constraint:       `Eq a'...
00:59:09 <satan> hmm
00:59:52 <satan> so when i access element #s 0,1,2,3 of [5,6], i should get [5,6,0,0]. is that even possible?
01:00:17 <dons> isAt :: forall a. (Eq a) => Int -> a -> [a] -> Bool
01:00:17 <dons> isAt n x xs | Just i <- elemIndex x xs = n == i
01:00:17 <dons>             | otherwise                = False
01:00:30 <satan> instead of Index too large when i try xs!! 2 or higher
01:00:38 <dons> satan: if you add ++ (repeat 0) to the list
01:00:49 <dons> so that it will hand you back extra 0's if you need them
01:01:00 <satan> dons: hmm even if its infinite
01:01:06 <satan> i guess it won't make a difference then
01:01:11 <dons> as long as you don't demand the entire list
01:01:21 <satan> thats true
01:01:25 <satan> let me try that
01:03:00 <int-e> > let tuples r xs = tuples' r xs (drop r xs); tuples' 0 _ _ = [[]]; tuples' r ts xs = [y:ys | (y:xs', ts') <- zip (tails xs) (tails ts), ys <- tuples' (r-1) ts' xs'] in length $ tuples 250 [1..250]
01:03:02 <lambdabot>  0
01:03:38 <satan> dons: ok that didnt work, it froze at 100% cpu usage
01:04:13 <int-e> > let tuples r xs = tuples' r xs (drop r xs); tuples' 0 _ _ = [[]]; tuples' r xs ts = [y:ys | (y:xs', ts') <- zip (tails xs) (tails ts), ys <- tuples' (r-1) xs' ts'] in length $ tuples 250 [1..250]
01:04:14 <lambdabot>  1
01:09:26 <dons> hmm. does the perl6 wiki page imply that pugs will _not_ be the official perl6?
01:09:31 <dons> http://en.wikipedia.org/wiki/Perl_6
01:09:44 <dons> "there is a fairly complete implementation written in Haskell called Pugs. Two alternate implementations exist, based on PGE and Perl 5, and Larry Wall announced at YAPC::Europe in Birmingham that one of these implementations would become a Perl 6 alpha release this Christmas (2006)"
01:09:59 <dons> any pugs guys know the story?
01:10:02 <profmakx> fficial perl 6 should be written in PHP
01:10:16 <satan> dons: thanks for your help, i think i got it working now :)
01:10:23 <dons> "one of these" is possibly ambiguous ?
01:10:28 <dons> satan: no worries1
01:10:57 <lispy> dons: based on what i've heard (nothing reliable) i would guess it means one of either PGE or Perl 5
01:11:32 <dons> i suppose pugs can be a reference implementation (and maybe the one that supports perl6 best :)
01:12:04 <dons> ah, the article seems to imply that pugs will be the bootstrap compiler, for once the perl6 implementation is done.
01:15:18 <lispy> heh, i'm stuck on this smalltalk interpreter because i can't figure out how to boot strap it
01:15:46 <Botty> hmm, just noticed one thing that's great about haskell - much easier to step through execution with your mind
01:15:52 <lispy> the source dist contained a binary file which is a memory dump from the java version using the Serializable interface
01:15:55 <Botty> i suppose a result of the statelessness
01:16:15 <lispy> Botty: referential transparency is nice
01:16:30 <lispy> Botty: i call it equational reasoning...you can substitute as needed
01:16:35 <Botty> yep
01:16:38 <dons> yeah. since evaluation order isn't defined
01:16:39 <lispy> forget debugging, prove why it's wrong!
01:16:56 <dons> so you just reduce it whichever way you see fit, and which order you do that won't affect the result
01:17:14 <dons> there's more than one way to do it! :)
01:17:32 <lispy> so i have a dump of a bunch of java objects, and i want to find out about their internals
01:17:48 <lispy> so i wrote a class which takes one of these 'SmallObjects' and prints out the guts
01:17:54 <dons> scary
01:18:06 <lispy> but when i run the program it goes into a loop trying to print the first on
01:18:17 <lispy> sort of like the way fix show behaves
01:18:22 <dons> Botty: what are you working on?
01:18:57 <Botty> the arithmetic compiler :)
01:19:07 <Botty> trying to make it as nice as possible
01:19:15 <Botty> eg concise
01:19:22 <dons> ah great.
01:19:26 <dons> let me know if you want a code review
01:19:40 <satan> Could there be any other non-obvious causes for this error: parse error on input `=' ?
01:19:41 * dons <3 refactoring
01:19:43 <Botty> I'll post it when it can do 1+1 ;)
01:19:51 <satan> i've checked for indentation and the = obviously, all seems to be fine
01:19:54 <Botty> its very very clever
01:20:00 <dons> satan: case x of y = z -- is the most common cause
01:20:03 <Botty> well, i think it is
01:20:06 <dons> instead of ->
01:20:12 <Botty> sadly the cleverness has bit me in the ass and it doesn't work
01:20:15 <dons> Botty: cool!
01:20:23 <satan> dons: ok, thanks
01:20:24 <Botty> (yet)
01:20:30 <lispy> Botty: have you heard the saying about clever programming?
01:20:34 <dons> satan: was that it?
01:20:45 <Botty> lispy - no, but i can infer the general drift
01:20:52 <satan> nope
01:21:09 <lispy> Botty: basically it goes like this, debugging is twice as hard (at least) as writing code, so if you write the code as clever as possible then by definition you're too dumb to debug it!
01:21:14 <satan> its in a module
01:21:32 <profmakx> or too lazy
01:21:36 <profmakx> which would apply to me
01:21:39 <dons> hmm. could it be a missing -fglasgow-exts ? (are you using pattern guards?)
01:22:10 <satan> dons: nope, it was working fine before, but now is giving me this error
01:22:12 <satan> bizarre
01:22:31 <Botty> ah, well, I think with referential transperency its only 1.5x, max, and my cleverness maxima isn't even approached ;)
01:23:00 <dons> and the typing helps reduce the debug load to < 1x imo.
01:23:29 <satan> dons: this is the line: Series as * Series bs = Series ...
01:23:32 <dons> it was about 1:1 for fps, I think, and that was a hard task to code correctly
01:23:32 <satan> at that =
01:23:36 <dons> satan: mising brackets
01:23:42 <lispy> Botty: don't worry about it, i just like quoting it because i thinks it's clever...and iirc it's by one of the inventers of C
01:23:47 <Botty> load, perhaps, but that might increase the average difficulty of the problem, as errors are deeper than simple stuff
01:23:49 <dons> satan: do you have more context for that though?
01:24:02 <satan> oh, it was working fine before without any brackets...
01:24:07 <Botty> lispy - ah, lol. that explains that
01:25:03 <satan> dons: sure, this is the full line: >	Series as * Series bs = Series (map (\x -> sum $ map ((\(c,d) -> (as ++ (repeat 0)) !! c * (bs ++ (repeat 0)) !! d) ) (zip [0..x] (reverse [0..x]))) [0..])
01:26:22 <dons> is that a top level definition of * ?
01:26:26 <satan> yes
01:26:40 <dons> you'll need brackets i'm pretty certain
01:26:43 <dons> parens
01:26:48 <satan> around?
01:27:17 <dons> really needs some 'where' clauses though. that's hard to read
01:27:23 <dons> (Series as) * (Series bs) = Series ...
01:27:34 <int-e> dons: no
01:27:36 <satan> i had some lol, but took em out, thinking they might be a problem
01:27:38 <dons> oh, and its recursive?
01:27:44 <satan> no, not recursive
01:28:06 <int-e> > let Just a + Just b = a in Just 3 + Just 4
01:28:08 <lambdabot>  3
01:28:10 <dons> > let Just n * Just m = Just (n * m) in (Just 1) * (Just 3)
01:28:11 <lambdabot>    Occurs check: cannot construct the infinite type: a = Maybe a
01:28:11 <lambdabot>    Expe...
01:28:45 <dons> ah ok. int-e++ (of course the pattern match works like that, doh!)
01:29:14 <satan> ok this is it with a where clause
01:29:16 <satan> >	Series as * Series bs = Series (map (f) [0..]) where
01:29:16 <satan> >		f x = sum $ map ((\(c,d) -> (as ++ (repeat 0)) !! c * (bs ++ (repeat 0)) !! d) ) (zip [0..x] (reverse [0..x]))
01:29:21 <int-e> satan: it shouldn't be a toplevel declaration I think - it should go into an instance declaration
01:29:39 <dons> yeah. and way too many sub-lambdas. needs more refactoring :)
01:29:46 <satan> right, my bad, sorry, it is in an instance declaration
01:29:49 <int-e> oh, and you shouldn't use !! at all
01:29:54 <lispy> maybe series should be an instance of Num or Functor and then you can lift the operators
01:29:54 <satan> no?
01:30:20 <lispy> or maybe that is happening :)
01:30:33 <satan> all im doing is calculating the coefficient of each power of an infinite series
01:30:40 <lispy> nice
01:30:51 <int-e> satan: consider: zip (as ++ repeat 0) (reverse (take (x+1) (bs ++ repeat 0)))
01:30:55 <satan> so for x^2, i gotta look at x^0 and x^2, x and x, x^2 and x^0 and so on
01:31:00 <dons> > [2..0]
01:31:02 <lambdabot>  []
01:31:21 <dons> > [3,2..0]
01:31:22 <lambdabot>  [3,2,1,0]
01:31:57 <satan> int-e: that would replace what exactly in my code? sorry, its late
01:32:04 <dons> ?check \x -> reverse [0..(x::Int)] == [x,x-1..0]]
01:32:05 <lambdabot>  Parse error
01:32:08 <dons> ?check \x -> reverse [0..(x::Int)] == [x,x-1..0]
01:32:10 <lambdabot>  OK, passed 500 tests.
01:32:37 <dons> (underappreciated feature of the day, pred-generating enums)
01:32:48 <int-e> satan:  zipWith (*) (as ++ repeat 0) (reverse (take (x+1) (bs ++ repeat 0)))  can replace everything the map does.
01:32:55 <dons> ?check \x -> reverse [0..(x::Int)] == [x,pred x..0]
01:32:56 <lambdabot>  OK, passed 500 tests.
01:33:20 <satan> wow
01:33:43 <int-e> satan: warning, this is untested. but I think it's correct anyway.
01:34:06 <dons> ?check \x -> let _ = x :: Int in reverse [0..x] == [x,pred x..0]
01:34:08 <lambdabot>  OK, passed 500 tests.
01:34:15 <satan> ok, no worries, i'll check it out in a sec
01:34:21 <satan> how do i resolve the = error though
01:34:33 <satan> mind you, it was working well with my nastier, older, incorrect code
01:34:49 <int-e> satan: did you quote the actual error?
01:34:56 <satan> yes
01:35:31 <satan> Series.lhs:49:29: parse error on input `='
01:36:32 <int-e> satan: maybe there is an indentation problem?
01:36:58 <int-e> satan: it's hard to guess, could you paste your code somewhere?
01:37:03 <satan> yeah possibly
01:37:05 <satan> ok 1 sec
01:38:16 <satan> ah nm found it
01:38:21 <satan> you were right
01:38:32 <satan> it wasnt showing in Kate, but it was a tab and not 8 spaces
01:38:45 <satan> but when i pasted it in pastebin, it was off by 1 space or whatever
01:39:02 <int-e> I see.
01:39:10 <int-e> tabs are bad :)
01:40:37 <dons> I suggest vim with:
01:40:38 <dons> syn match tabNasty display "\t"
01:40:38 <dons> hi link tabNasty Todo
01:40:39 <dons> :)
01:40:44 <dons> for a garish orange tab
01:41:04 <int-e> Tabulators not using the One True Tab Size (tm) are worse, of course.
01:41:40 <profmakx> or which value of OTTS?
01:41:49 <int-e> 8.
01:43:18 <int-e> it's really the only value that has a chance of working almost everywhere.
01:43:23 <Botty> uh, 4 is actually the OTTS
01:43:37 <Botty> 8 is wayy too big ;)
01:43:59 <profmakx> there you go ...
01:44:04 <Heffalump> 3.
01:44:15 <int-e> Botty: using tabs for indentation is bad.
01:44:19 <Heffalump> yes
01:44:22 <Heffalump> especially in Haskell
01:44:26 <profmakx> reminds me of the discussion we had when fixing coding style
01:44:40 <Botty> I know, I only use them for languages that use them
01:44:53 <Botty> python, only, i guess
01:45:21 <int-e> I've stopped indenting with tabs years ago, even in C and python.
01:45:32 <profmakx> i press tab
01:45:35 <dons> its always annoying to be forced to use semantically significant tabs in make
01:45:37 <xinming> How to test a list is empty while we are in guards please?
01:45:37 <int-e> sure, I do that.
01:45:38 <profmakx> but its really spaces
01:46:07 <dons> > let f x |null x = True | otherwise = False in f []
01:46:08 <int-e> let me clarify, by 'Tab Size' I meant the number of spaces a \t represents.
01:46:08 <lambdabot>  True
01:46:22 <int-e> not an indentation depth.
01:46:53 <dons> > let f x | null x = "empty" | otherwise = show x in f [1..10] -- xinming
01:46:54 <lambdabot>  "[1,2,3,4,5,6,7,8,9,10]"
01:47:02 <satan> int-e: it works, thanks a ton, much faster too wow
01:47:16 <dons> > let f x | null x = "empty" | otherwise = show x in f []
01:47:18 <lambdabot>  Add a type signature
01:47:33 <dons> > let f x | null x = "empty" | otherwise = show x in f ( [] :: [()] )
01:47:34 <lambdabot>  "empty"
01:47:51 <int-e> satan: ok, if you want to improve this further, try to express Series (a:as) * Series bs   in terms of Series as * Series bs  and a calculation that involves a and bs.
01:48:17 <xinming> lisppaste2: url
01:48:17 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
01:48:26 <int-e> satan: that should save some superfluous multiplications by 0 :)
01:48:27 <satan> thats what i was thinking of for division :P
01:49:10 <pzpz> hey all -- i'm playing with forkIO, and it's acting differently in ghci as opposed to ghc (neither correct). It's a simple prog that forks a sender and listener, but I'm not sure what I'm doing incorrectly:
01:49:12 <satan> int-e: if i do what you said, a calculation involving a and bs, will it still work for infinite lists?
01:49:14 <pzpz> http://paste.lisp.org/display/29262
01:49:18 <lisppaste2> xinming pasted "Test null list question,." at http://paste.lisp.org/display/29263
01:49:26 <dons> pzpz: you using -threaded in ghc?
01:49:39 <pzpz> dons: negative. lets see if tha thelps.
01:49:47 <xinming> dons: Please check that. thanks.
01:49:48 <dons> yeah, so compile with -threaded
01:49:48 <roconnor> > 2*(log (1/2))
01:49:50 <lambdabot>  -1.3862943611198906
01:49:51 <xinming> In getRecord
01:50:04 <roconnor> > 2*(log 2)
01:50:05 <lambdabot>  1.3862943611198906
01:50:15 <roconnor> > sqrt(2)*(log 2)
01:50:16 <lambdabot>  0.9802581434685472
01:50:23 <int-e> satan: if done right, yes.
01:50:25 <dons> pzpz: yes. you'l need -threaded to avoid blocking on io
01:50:32 <dons> ( this code reminds me of something ... ;)
01:50:32 <int-e> satan: quite easily actually
01:50:37 <satan> int-e: that if is the size of Africa :(
01:50:39 <roconnor> > sqrt(2*(log 2))
01:50:40 <lambdabot>  1.1774100225154747
01:50:42 <roconnor> ah
01:50:47 <Botty> ah. found the bug.
01:50:50 <satan> int-e: ok, i'll optimize later :)
01:50:56 <roconnor> > sqrt(2*(log 2))*2^61
01:50:57 <lambdabot>  2.714922669395445e18
01:51:19 <int-e> satan: ok, let me rephrase that. I'd expect it to work for infinite lists, but there's certainly a way to do it wrong.
01:51:27 <roconnor> @google sqrt(2*(log 2))*2^61 nanoseconds in years
01:51:28 <lambdabot> sqrt(2 * log(2)) * (2^61) nanoseconds = 56.6963275 years
01:51:38 <dons> xinming: but you also have a type error
01:51:40 <dons>     | null xs         = getIndex xs i
01:51:40 <dons>     | otherwise       = (-1, "Error", -1)
01:51:46 <satan> int-e: ah ok
01:51:49 <dons> the two branches have different result types
01:51:50 <Botty> > let trans m = fromJust . flip Data.Map.lookup (Data.Map.fromList m) in trans [('a',1),('b',2)] 'a'
01:51:51 <lambdabot>  Not in scope: `Data.Map.fromList'
01:51:54 <dons> getInde xs i :: Int
01:51:58 <dons> but the other :: Record -- ?
01:52:06 <dons> Botty: M.fromList
01:52:12 <Botty> > let trans m = fromJust . flip Data.Map.lookup (M.fromList m) in trans [('a',1),('b',2)] 'a'
01:52:13 <lambdabot>  Not in scope: `Data.Map.lookup'
01:52:15 <xinming> dons:  oops.. thanks...  >_<
01:52:23 <Botty> > let trans m = fromJust . flip M.lookup (Data.Map.fromList m) in trans [('a',1),('b',2)] 'a'
01:52:24 <lambdabot>  Not in scope: `Data.Map.fromList'
01:52:35 <Botty> > let trans m = fromJust . flip M.lookup (M.fromList m) in trans [('a',1),('b',2)] 'a'
01:52:37 <lambdabot>  1
01:52:43 <Botty> bah!
01:52:50 <Botty> > let trans m = fromJust . flip M.lookup (M.fromList m) in trans [('a',1),('b',2)] 'b'
01:52:51 <lambdabot>  2
01:52:53 <dons> don't you want to map it?
01:53:16 <Botty> nah, they're small, constant lists
01:53:27 <dibblego> hello ellybolly
01:53:33 <dons> heya dibblego
01:53:45 <pzpz> forkIO ( printLotsOfZeros ) >> printLotsOfOnes
01:53:53 <dibblego> g'day dons, watching the test or not interested?
01:54:03 <dons> not so much. league isn't so much my thing.
01:54:07 <pzpz> should this interleave ones and zeros, or not?
01:54:13 <dons> just caught the last 5 mins of the first half
01:54:31 <dons> watching iron chef instead :)
01:54:41 <Botty> Instead of:
01:54:41 <Botty> precedence x = trans [(Add, 1), (Sub, 1), (Mul, 2), (Mod, 2), (Div, 3), (Pow, 3), (LPar, 4), (RPar, 4)] x
01:54:41 <Botty> opFromChar = trans [('+', Add), ('-', Sub), ('*', Mul), ('/', Div), ('^', Pow), ('%', Mod), (')', RPar)]
01:54:41 <Botty> Should I just do a bunch of defs
01:54:43 <dibblego> aha :)
01:55:27 <dons> pzpz: checking...
01:57:02 <dons> pzpz: forkIO (mapM_ putChar (repeat '0')) >> mapM_ putChar (repeat '1')
01:57:03 <dons> works for me
01:57:05 <dons> in ghci
01:57:47 <dibblego> that Gus guy (commentator) rants more crap than I do
01:57:57 <dons> prints "1111111111100000000001010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010"
01:58:01 <dons> :)
01:58:02 <pzpz> dons: my paste isn't following that tend though.
01:58:08 <pzpz> s/tend/trend
01:58:09 <dons> dibblego: heh!
01:58:25 <dons> pzpz: what OS?
01:58:29 <pzpz> forkIO (send handle) >> (listen sock)
01:58:34 <dibblego> one of the guys in my squash team wears a shirt that reads "Shut Up Gus!" -- I so understand where they are coming from
01:58:55 <pzpz> dons: linux, 2.6
01:58:59 <lispy> Gus?
01:59:03 <dons> ok. let me try your code
01:59:08 <dons> lispy: talking footy in .au :)
01:59:14 <dibblego> lispy, Phil Gould - a football commentator - very annoying
01:59:26 <pzpz> dons: I'm sure i'm overlooking some sort of io blocking aspect though
01:59:34 <dons> yeah, checking ..
01:59:41 <Botty> *Main> parse "1+1"
01:59:41 <Botty> *** Exception: Mismatched parenthesis
01:59:42 <Botty> teehee
01:59:46 <dons> close!
02:00:03 <lispy> dons: heh, you're usually talking .au when i get confused ;)
02:00:18 <dons> pzpz: aren't you missing putStr "Message? " >> hFlush stdout
02:00:20 <dons> heh
02:00:27 <dons> lispy, yeah-no, maybe you're right
02:00:28 <pzpz> dons:  I'm still not sure why ghci executes it more correctly than my compiled version
02:00:38 <dons> buffering I suspect ...
02:00:39 <lispy> dons: that's what i'm talking about!
02:00:55 <dibblego> we're Austr-alien
02:01:26 <pzpz> dons: that flush did it. makes sense too ^_^
02:01:31 <dibblego> the term "football" is only known to Australians as we are referring to it
02:02:01 <dibblego> for everyone else (even aussies on the other side of the country), there is ambiguity
02:02:10 <dons> dibblego: seen "Kenny", the .au film/doco about a portaloo business owner?
02:02:17 <dibblego> NSW/QLD know it means rugby league
02:02:20 <dons> key phrase: "sillier than a bum full of smarties"
02:02:24 <dibblego> dons, nope
02:02:30 <dibblego> lol
02:02:49 <dons> i saw it on the plane coming back from SF, its just so ridiculously funny in a .au sense of humour way.
02:03:03 <Smokey`> dibblego: the intelligent NSW people know it 'really' means soccer, though we understand what you mean ;)
02:03:19 <dons> heh
02:03:20 <dibblego> Smokey`, they don't have intelligent people in NSW
02:03:25 <dons> oi!
02:03:28 * dibblego runs from dons 
02:03:43 * dons notes down this for when dibblego is in sydney next week..
02:03:53 <Smokey`> dibblego: by the looks of things, they don't have intelligent people where you come from either ;)  j/k :)
02:03:58 * dibblego fuels the NSW/QLD rivalry
02:04:10 <Smokey`> oh QLD... well that explains everything. ;)
02:04:11 * lispy needs a base case
02:04:23 * dibblego places Smokey` in a pub full of aussies watching "football"
02:04:25 <dons> ah here we go, some quotes, ""busier than a one-armed bricklayer in Baghdad"
02:04:43 * Smokey` drinks mass amounts of booze?
02:04:45 <dibblego> least we know what friggin' time it is
02:05:24 * beelsebob giggles
02:05:27 <Smokey`> dibblego: 'least we dont think it'll fade the blinds, or it'll make the cows go sour? ;)
02:05:34 <dibblego> configuring apache and using IRC simultaneously results in some funny looking httpd.conf files
02:05:48 <dibblego> Smokey`, skin cancer if you ask our premier
02:05:55 * beelsebob sits watching the world anialate each other chearing for Scotland :P
02:06:10 <lispy> dibblego: just  use emacs for irc and embrace the true nature of irc, multiplayer text editing
02:08:25 <Botty> arrg
02:08:43 <Botty> that issue was from assuming that list union found the set union of the lists
02:08:52 <Botty> eg, all the elements that are in both
02:09:10 <lispy> instead it's append?
02:09:57 <Botty> ah never mind
02:10:15 <Botty> it is a set union, just for some reason i got it confused with intersection
02:11:21 <dons> hey thebug. long time no see!
02:13:07 <dons> hmm. i wonder if thinkature would be useful for us here
02:13:19 <dons> a way to augment lisppaste and inline @eval
02:14:08 <pzpz> woot. my retarded server works!
02:14:14 <dons> cool
02:14:26 <dons> and you can run it multicore with what -N2 ?
02:14:27 <lispy> retarded == slow?
02:15:05 <pzpz> i'm sure it's implemented inefficiently.
02:15:29 <pzpz> and it's pretty useless, unless I really feel like talking to myself inbetween terminals.
02:15:32 <vegai> retard 5. Automotive, Machinery. an adjustment made in the setting of the distributor of an internal-combustion engine so that the spark for ignition in each cylinder is generated later in the cycle.
02:15:37 <vegai> perhaps that one? :P
02:16:10 <pzpz> I dont' think that applies at all :)
02:16:41 <dons> pzpz, to automagicaly get it on multiple cores, you've got 6.6 right?, use +RTS -N2
02:16:47 <dons> to get threads on two separate cores
02:17:09 <vegai> ah, I see...
02:17:28 <dons> ok, who wants to try out this new collaborative doodle-space with me?
02:17:28 <pzpz> dons: I'd do so if I had more than one cpu :)
02:17:30 <Botty> retard 20. Musical, Abbreviation. a slowing of the tempo over specific measures of a musical composition
02:18:55 <dons> lispy: want to create an account here: http://thinkature.com/home/
02:18:58 <lambdabot> Title: Thinkature - Please log in
02:19:11 <dons> its an online doodle space, like lispaste but for graphics and so on
02:19:14 <pzpz> dons: you have a platform nice enough to play with those features? :)
02:19:23 <dons> i'm about to create a haskell page .. let's see if its any good
02:19:29 <dons> pzpz: yeah, a 4 core linux server at uni
02:19:46 <dons> hmmm. ..there's also that 40 cpu sparc box ... maybe i should get an account on that.
02:20:08 <pzpz> dons: :) any limitation on -N ?
02:20:37 <dons> not that i know of. check 'Concurrency and parallelism' under libraries and tools on haskell.org
02:21:22 <dons> argh, crashed my browser
02:21:28 <dons> i hate javascript
02:21:35 <lispy> that'll learn ya
02:21:47 <pzpz> flash is worse.
02:22:02 <dons> ok. i'l try it again in a few weeks. let them immprove the perf a bit
02:22:30 <dons> i think a local client for shared doodling might be better performance wise than using javascript as a defactor jvm
02:22:35 <dons> grr. web 2.0--
02:22:43 <lispy> dons: if it has 40 CPUs how much ram does it have?
02:22:50 <dons> 180G or so
02:22:59 <lispy> nice
02:23:13 <lispy> dons: you should do some HUGE bytestring benchmarks if you can get some cpu time
02:23:17 <dons> heh
02:23:30 <beelsebob> @hoogle (a -> Bool) -> (a -> Bool)
02:23:31 <lambdabot> No matches, try a more general search
02:23:37 <dons> yeah, this is what the data parallel arrays are being tested on
02:23:44 <beelsebob> @hoogle Bool -> Bool
02:23:46 <lambdabot> Prelude.not :: Bool -> Bool
02:23:46 <lambdabot> Prelude.(&&) :: Bool -> Bool -> Bool
02:23:46 <lambdabot> Prelude.(||) :: Bool -> Bool -> Bool
02:24:16 <pzpz> the new dualcore intel cores have any SMP motherboards?
02:24:23 <lispy> dons: oh, did you read the optimizing C thing on reddit?
02:24:24 <beelsebob> yes
02:24:30 <beelsebob> pzpz: apple.com/macpro
02:24:30 <dons> lispy: yeah. saw the comments
02:24:48 <lispy> dons: wasn't that great about ocaml blowing C out of the water
02:25:17 <lispy> a garbage collected functional language beating the pants off of C :)
02:25:26 <dons> yeah. that rocks.
02:25:36 <dons> we know it can be done. and its getting easier and easier
02:26:29 <lispy> yeah, although, simulations still seem to be a tricky spot performance wise in haskell according to the folklore
02:26:47 <dibblego> "software" is pure FP, "hardware" is imperative - the first person to write an efficient translator (read: compiler) from one to the other wins
02:26:51 <pzpz> beelsebob: does it use a proprietary motherboard?
02:27:01 <dons> dibblego: heh. exactly
02:27:30 <beelsebob> pzpz: no idea - I think they got intel to design it - whatever, it's a cheep fast computer, the motherboard alone would probably cost about a third of the price of that box on HE discount
02:27:44 <beelsebob> dibblego: wrong - the first one to make some functional hardware wins
02:28:03 <beelsebob> e.g. FPGAs that can have ways of programming other FPGAs passed around over them
02:28:18 <dibblego> beelsebob, not possible, but I was reading about hardware that can only be addressed as if it were pure
02:28:25 <lispy> i was actually reading the STG paper just to think about that very thing...but i their STG machine is way higher level than i think you'd see in hardware
02:28:32 <dibblego> hardware will always have updating registers
02:28:40 <Botty> why aren't functional fpgas possible?
02:28:41 <beelsebob> why?
02:28:45 <pzpz> "The world's most advanced operating system including the latest versions of these system applications:"
02:28:55 <pzpz> I've always loved apple's advertising.
02:28:56 <dibblego> I don't know what a FPGA is
02:29:07 <dibblego> is memory infinite?
02:29:22 <beelsebob> pzpz: If you really want you can put linux or windows on it... but I wouldn't recomend it... what you want to do can probably be done in OS X
02:29:36 <dons> Botty: they are and have been. they were popular in the 80s (well, FP machines, not FPGAs)
02:29:38 <Botty> it's basically a chip where you program on the gates
02:29:40 <beelsebob> dibblego: it's a fully programable gate array
02:29:43 <lispy> field programmable something array, basically a software programmable processor
02:29:47 <dons> the good thing is that we can compile it to commodity hardware just as well
02:29:49 <beelsebob> it can be programed on the fly to do something new
02:29:52 <therp> lispy: gate array
02:29:58 <dibblego> I'll bet the hardware is still updating registers
02:30:09 <beelsebob> dibblego: only if you program it to
02:30:16 <Botty> can even program modern cpus on them, and run decent emulations
02:30:21 <beelsebob> it is quite litterally a big array of gates that can be set up any way you like
02:30:31 <Botty> yep
02:30:46 <beelsebob> if you want you can set them up to be asynchronous and not have any registers
02:30:50 <lispy> some day as a hobbie i will buy an FPGA and write my own processor and operating system
02:31:01 <beelsebob> see... I don't want to build the processor
02:31:02 <Botty> lispy - don't we all :)
02:31:17 <beelsebob> I want my programs  to rebuild the processor as it goes
02:31:23 <dons> lispy: get famous with your SMP-Ruby interpreter first ... ;)
02:31:23 <Botty> hehe
02:31:24 <dibblego> well, I don't know much about that, so I'll retract until I do
02:31:30 <therp> I met a guy at ECLM06 that told me he is able to compile lisp expressions to FPGA code, quite impressive I'd say.
02:31:36 <beelsebob> I pass a higher order function - so when it get called it reprograms a gate array to do that function and passes in the arguments
02:31:51 <Botty> yeah, I'd probably have a board with a master fpga and 8 slaves. run up to 8 programs!
02:31:53 <dibblego> the expression of software should be completely isolated from any such notion as hardware - most certainly
02:31:57 <dons> on a similar theme, there's lava and hawk, haskell-like languages that compile to fpgas
02:32:03 <dons> used for specifying hardware
02:32:09 <dons> bluespec too, iirc
02:32:10 <lispy> therp: there was someone in #lisp who was writing their senior capstone in lisp and the capstone requirement for all the seniors was an OS :)
02:32:11 <dibblego> i.e. Haskell (reminds me of the "is Haskell 5GL?" thread a while back)
02:32:21 <dons> (actually a commerical company)
02:33:13 <lispy> therp: their reasoning was that their peers would be struggling with C code for several months just trying to get the file system working and he would just toss out some lisp and be done with it
02:33:24 <therp> lispy: sorry, what's your definition of (senior) capstone, my english->german translation doesn't make sense
02:33:47 <dons> writing micro kernels in FP langs is almost mainstream these days :)
02:33:49 <lispy> therp: ah, a project done at the end of school which demonstrates your competence
02:34:12 <dons> like an honours project in .au or the uk?
02:34:19 <lispy> yeah
02:34:33 <dons> or diploma ... something something in german.
02:34:40 <lispy> iirc, a capstone is the stone at the top of the arch that holds the arch together
02:34:45 <pzpz> endgame!
02:34:52 <therp> lispy: hehe :) that's quite resonable. that reminds me of the game company that was doing most of the engine work in Lisp and therefore were able to a work lot more productive than their competitors.. (the company was bought by sony and sony was shocked that the asset they bought was lisp. they converted everything to C/C++, and now the company isn't top-league anymore)
02:35:13 <therp> lispy&dons: ah ok :)
02:35:27 <lispy> therp: oh geez...the company that made crash?
02:35:30 <dons> ah Diplomarbeit maybe?
02:35:40 <dons> ?babel de es Diplomarbeit
02:35:42 <lambdabot> babel module failed: IRCRaised Prelude.head: empty list
02:35:46 <dons> heh
02:36:12 <therp> dons: yes, that would make a good translation. I'm not sure if the requirements match. I wasn't required to write an OS for my diplomarbeit :)
02:36:13 <dibblego> I should be doing my honours degree
02:36:19 <dons> hehe
02:36:21 <dibblego> speaking of those
02:36:41 <therp> lispy: I'm not sure. I sadly forgot the half to the story. I think they made PS2 games
02:36:59 <therp> s/to/of/
02:37:01 * beelsebob sits here rocking backwards and forwards in a corner at the mention of degrees
02:37:19 <dibblego> I nearly did - was accepted and ready to go - but then my sister got sick
02:37:50 <bdash> therp: Naughty Dog Software, I believe
02:37:54 <bdash> http://www.franz.com/success/customer_apps/animation_graphics/naughtydog.lhtml
02:37:58 <lambdabot> Title: Franz Inc Customer Applications: Naughty Dog Software, http://tinyurl.com/5jd8r
02:38:28 <therp> bdash: ah right! that's the story :)
02:38:57 <Botty> ohh. they made the tools in lisp
02:39:14 <Botty> certainly tools do take a signifigant part of the effort
02:39:34 <therp> full ack
02:40:03 <pzpz> garbage collection doesn't do very in time-critical game engines :)
02:40:20 <lispy> pzpz: but we have linear types now
02:40:22 <pzpz> ver well
02:40:25 <Botty> ug, that's a horrible article
02:40:31 <lispy> pzpz: did you see the recent paper about linear lisp?
02:40:37 <pzpz> lispy: no, please link.
02:41:00 <therp> pzpz: I think Allegro CL is pretty good about not-interrupting anything with it's garbage collection. so I don't think that's much of an issue
02:42:02 <dons> i wonder if its even going to matter once we have parallel gc finished ...
02:42:06 <lispy> pzpz: you know, what this isn't recent at all: http://home.pipeline.com/~hbaker1/LinearLisp.html
02:42:09 <lambdabot> Title: ACM Sigplan Notices 27, 8 (Aug. 1992), 89-98., http://tinyurl.com/wdwgj
02:42:12 <dons> since you just run the GC on the extra core.
02:42:12 <lispy> pzpz: but i saw it recently...
02:42:27 <dons> do game boxes have multiple cores yet?
02:42:32 <Botty> dons - who says there's only one
02:42:44 <lispy> dons: i think the cell processor is like that
02:42:45 <dons> exactly
02:42:53 <Botty> ps3 will have like 6
02:42:58 <dons> if there's 32 cores who cares if you've got GC, as long as its parallel?
02:43:06 <dons> *the rules of the game have changed completely*
02:43:06 <pzpz> lispy: on my reading list, thanks :)
02:43:13 <bdash> therp: according to the wikipedia article, the custom lisp dialect they used (GOAL) lacked GC
02:43:36 <pzpz> dons: i think the xbox360 has 3 cores
02:43:47 <beelsebob> yep
02:43:56 <beelsebob> 3 modified PPC970s
02:44:01 <dons> am i right in thinking that GC-based languages become more feasible with multicores + parallel GC?
02:44:16 <dons> anyone know game dev enough?
02:44:23 <mayweed> hello
02:44:32 <mayweed> dons: no
02:44:32 <dons> hi mayweed
02:44:36 <mayweed> but sometimes
02:44:37 <therp> bdash: interesting. but I think Sony killed GOAL
02:44:43 <pzpz> dons: sure -- however, games tend to push the system to the limits
02:44:44 <Botty> no, it has 2 PPC cores and 6 custom cores
02:44:46 <bdash> therp: yes
02:44:46 <mayweed> I go on gamedev to play with lua
02:44:52 <mayweed> funny
02:44:57 <beelsebob> Botty: I was refering to the XBox360
02:45:04 <Botty> ohh
02:45:12 <pzpz> dons: if you can render more particle effects as opposed to running mark and sweep, the player would prefer the pretty particles.
02:45:30 <bdash> therp: there's an interesting thread on GOAL + Naughty Dog + Sony at http://lists.midnightryder.com/pipermail/sweng-gamedev-midnightryder.com/2005-August/003789.html, if you're into that kind of thing :)
02:45:33 <lambdabot> Title: [Sweng-gamedev] Higher Level Languages (Was: Next Gen Multiplatform Load Balanci ..., http://tinyurl.com/atj48
02:45:34 <Botty> actually, 8 custom cores
02:45:42 <Botty> SPUs I think their called
02:45:49 <therp> bdash: sometimes the rules of business are plain stupid. I also hate Apple for buying Fingerworks (the made GREAT touch sensitive keyboards) and they just closed it. How does that make sense?
02:45:53 <beelsebob> Botty: that's one cell you're talking about, not the whole PS3
02:46:02 <Botty> yeah
02:46:04 <beelsebob> a cell processor has on PPC chip and 7 SPUs
02:46:07 <beelsebob> one*
02:46:19 <Botty> but the PS3 has only one cell :)
02:46:22 <beelsebob> although the PPC chip has a lot of it's maths processing stripped out
02:46:32 <Botty> ah
02:46:43 <beelsebob> at the moment, they have no cells, but that's because they can't make any o the damn things :P
02:46:43 <Smokey`> it has a total of 8 SPUs (the original design), though one is unaccessible (it does security/maintenance operations for the PPC core), and iirc the PS3's cell processor has one less SPU than normal.
02:46:50 <Botty> hmm, thought I read that it had two PPCs, ahwell, that'd be too big anyway
02:47:06 <Smokey`> blade servers though, should have 8 SPUs, where as the PS3 has 7.
02:47:09 <Botty> Smokey` - ah
02:47:29 <therp> bdash: that message looks familiar to me. I think I've read it before.. maybe from planet.lisp.org
02:47:34 <beelsebob> Botty: not really - the PPC is a *very* small chip - it's the vast amounts of cache on most that takes up die space
02:48:05 <Botty> hmm, really.
02:48:14 <beelsebob> yep, teeny tiny risc chip
02:48:21 <beelsebob> strip of the AltiVec unit and it's tiny
02:48:22 <Botty> how many do you think you could fit on a chip without cache?
02:48:29 <beelsebob> many lots
02:48:37 <Botty> hmm sweet
02:48:38 <beelsebob> I saw a picture of one of the PPCs that went in macs
02:48:42 <beelsebob> they were basically 90% cache
02:49:05 <Botty> that's my main CPU architecture idea - stream based microcores.  Like an fpga only the blocks are cpus
02:49:21 <beelsebob> ohhh... that sounds fun
02:49:25 <Botty> yeah
02:49:29 <beelsebob> so you can have a higher order CPU
02:49:38 <beelsebob> and not one that actually has to find board space like in my idea
02:49:46 <dons> Botty: how's the compiler going?
02:49:48 <Botty> yeah
02:50:40 <Botty> dons - I'll just put it up, it doesn't work yet, too clever for its own good.  I'm pretty tired, so there's probably little chance of finishing it now
02:53:46 <Botty> http://haskell.org/haskellwiki/Haskell_Quiz/Bytecode_Compiler/Solution_Michael_Sloan
02:53:49 <lambdabot> Title: Haskell Quiz/Bytecode Compiler/Solution Michael Sloan - HaskellWiki, http://tinyurl.com/tcmju
02:54:10 <dons> cheers, i'll have  look
02:54:21 <Botty> everything but infixParse works right
02:54:30 <Botty> and it works sort of pseudo
02:54:36 <dons> cool
02:54:50 <Botty> problem is it's a lexer + parser, and clever at that
02:56:57 <Botty> It's a method I invented years ago, and only recently found out that it was first used by Djitska, and called the "Shunting Yard" algorithm
03:00:08 <Botty> beelsebob - The thing about the stream processor, is with a proper OS in some kind of master , one microcore is fine.  It'd just be slow as hell.  This removes the limitation of fpgas that you need more fpgas/gates for bigger programs.  Yet it keeps the parallelism of fpgas.  Should be pretty impressive.
03:00:16 <psykotic> the shunting algorithm always seemed overly complex to me as an operator precedence parsing algorithm.
03:00:45 <psykotic> there's a much simpler algorithm based on recursive descent.
03:00:53 <Botty> psykotic - really.  I came up with it when I was 10...
03:01:07 <psykotic> that's nice.
03:01:08 <Botty> good ol qbasic :)
03:01:20 <Botty> maybe 12 actually
03:01:26 <Botty> 10 was ebnf...
03:02:13 <lispy> i already had a PhD in mad science by the time i was 10
03:02:23 <Botty> where is this mystical precedence algorithm of simplicity?
03:02:29 <int-e> this is basically recursive descent with an explicitely managed control stack *shrugs*
03:02:56 <psykotic> Botty, it's what you get when you abstract out the pattern used for rolling recursive descent expression parsers into a function parameterized by precedence level.
03:03:00 <Botty> yeah, its probably pretty procedural.  I'm still a newb to functional
03:03:17 * lispy &
03:03:33 <Botty> psykotic - well, that would explain why i didn't figure it out with qbasic
03:04:00 <ValarQ> better use ValarQbasic
03:04:19 <Botty> heh, is that qbasic in haskell?
03:05:03 <ValarQ> nope :o)
03:05:09 <Botty> aww
03:05:20 <ValarQ> not used qbasic myself so it's a bit tricky
03:05:48 <psykotic> botty: http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm, look at what he describes as "precedence climbing"
03:05:51 <lambdabot> Title: , http://tinyurl.com/y3crdo
03:06:40 <Botty> I suppose I should just use parsec and remove all cleverness
03:07:11 <Botty> what's most clever is that everything is an operator, and it uses the rules of precedence for ordering
03:07:46 <psykotic> i'm not sure but i suspect parsec's operator precedence parser uses "precedence climbing"
03:07:56 <psykotic> since it's the most natural from the point of view of functional programming, imo
03:08:01 <Botty> likely
03:08:39 <Botty> agg i hate this guy's pseudocode
03:09:34 <dons> Botty: did you see the other impl already up?
03:09:43 <Botty> yep
03:11:40 <Botty> ahwell, I'll look at it later
03:23:42 <dons> ?yow!
03:23:42 <lambdabot> I just accepted provolone into my life.
03:24:03 <araujo> morning
03:25:18 <dons> morning araujo
03:25:23 <dons> ?localtime araujo
03:25:25 <lambdabot> Local time for araujo is Sat Nov  4 07:24:02
03:25:31 <Lemmih> ?time dons
03:25:31 <dons> morning indeed!
03:25:35 <lambdabot> Local time for dons is Sat Nov  4 22:25:09 2006
03:25:57 <araujo> dons, hi!
03:26:03 <araujo> :-)
03:35:21 <triple_> mm...provolone
03:43:04 <lisppaste2> int-e pasted "mystery function" at http://paste.lisp.org/display/29265
03:47:30 <dons> oh, interesting, another reason unsafePerformIO is evil. on the SMP runtime system separate threads can evaluate a pure thunk twice, without harm
03:47:52 <dons> so if you hide a side effect inside an unsafePerformIO, it might get run twice if you've got threads accessing that thunk concurrently
03:49:14 <int-e> yep. I wonder how that affects getContents.
03:49:42 <dons> you shouldn't be sharing lazy streams amongst threads though
03:49:47 <dons> :)
03:50:17 <int-e> ok, I read my file, hand it off to some pure function which uses 'par' ...
03:50:43 <dons> so i wonder if unsafeInterleave is ok.
03:51:18 <dons> then also, remember, the Handle is MVard
03:51:30 <dons> so you can't do concurrent reads anyway
03:51:37 <int-e> does that really help?
03:52:01 <dons> well, it would order the demands on the handle reader, wouldn't it?
03:52:13 * dons reads on ...
03:53:19 <int-e> the problem - as I see it - is, that if you have two threads forcing the same list thunk (as produced by getContents) they'll both run into the takeMVar, and read a block (sequentially, but the harm is already done). subsequently, one of these blocks gets lost.
03:55:14 <int-e> you really need to lock the list thunk. I don't know if that's done.
03:56:13 <dons> hmm. the paper distinguishes cheap and expensive thunks, with locks placed on expensive ones
03:56:20 <dons> i wonder if that affects things
03:57:42 <int-e> the paper (that I have in mind) also mentions that there should be some primitive, 'once' perhaps, but they haven't made up their mind about the details yet.
03:57:58 <dons> yeah, justOnce :: a -> a
03:58:11 <dons> http://programming.reddit.com/info/pdr4/details :)
03:58:14 <lambdabot> Title: Multi-core, lock-free Haskell programming [pdf] (reddit.com), http://tinyurl.com/y6zpjb
03:58:38 <int-e> yep, I've skimmed that :)
04:01:17 <roconnor> @djinn (a -> Either b c) -> Either (a -> b) (a -> c)
04:01:18 <lambdabot> -- f cannot be realized.
04:02:01 <roconnor> @scheck \a b c -> (a <= b || c) <= (a < = b) || (a <= c)
04:02:01 <lambdabot>  Parse error
04:02:20 <roconnor> @scheck \a b c -> (a <= b || c)
04:02:21 <lambdabot>  Add a type signature
04:02:27 <roconnor> @scheck \a b c -> (a <= b || c)::Bool
04:02:27 <lambdabot>  Add a type signature
04:02:37 <int-e> @scheck \a b c -> (a <= b || c) <= (a <= b) || (a <= c)
04:02:40 <lambdabot>  Completed 8 test(s) without failure.
04:03:21 * roconnor can't see my error
04:03:53 <roconnor> oh
04:03:55 <roconnor> a space
04:04:21 <roconnor> @djinn (a -> Either b c) -> Not (Not (Either (a -> b) (a -> c)))
04:04:21 <lambdabot> f a b =
04:04:22 <lambdabot>   void (b (Right (\ c ->
04:04:22 <lambdabot>           void (case a c of
04:04:22 <lambdabot>              Left d -> b (Left (\ _ -> d))
04:04:22 <lambdabot>              Right e -> b (Right (\ _ -> e))))))
04:06:16 <roconnor> @scheck \a b c -> (a <= b || c) == (a <= b) || (a <= c)
04:06:18 <lambdabot>  Completed 8 test(s) without failure.
04:06:28 <xerox> G'day.
04:07:29 <xerox> > [a <= b | a <- [True,False], b <- [True,False]]
04:07:31 <lambdabot>  [True,False,True,True]
04:08:35 <xerox> > [(a,b,a <= b) | a <- [0,1], b <- [0,1]]
04:08:37 <lambdabot>  [(0,0,True),(0,1,True),(1,0,False),(1,1,True)]
04:08:38 <int-e> @scheck \a b -> (a ==> b) == (a <= b)
04:08:39 <lambdabot>  Couldn't match `Property' against `Bool'
04:09:11 <int-e> right.
04:12:03 <xXBlazZeXx> vinge.freenode.netsers
04:14:04 --- mode: ChanServ set +o dons
04:14:09 --- kick: xXBlazZeXx was kicked by dons (dons)
04:14:12 --- mode: ChanServ set -o dons
04:14:48 <int-e> dons: I wonder if it's enough to put a  justOnce  (once we have it) into unsafeInterleaveIO.
04:15:08 <dons> I find it hard to imagine that ghc 6.6 came out without a solutoin to this.
04:15:17 <dons> want to ask on glasgow-haskell-users@ ?
04:15:25 <dons> or try to produce a test program?
04:15:43 <dons> but yeah, a justOnce would seem to make sense.
04:18:57 <int-e> well, it seems hard to trigger on an uniprocessor system ;-)
04:19:36 <dons> hmm. i should really install 6.6 since i have this 4 core box at uni.
04:19:37 <int-e> so no, I can't really produce a test program. an idea would be to get two smp tasks to calculate a checksum of some big file.
04:19:48 * dons builds ghc ..
04:30:50 <dons> got a test program int-e?
04:31:26 <dons> processor       : 0
04:31:30 <dons> model name      : Intel(R) Xeon(TM) CPU 2.80GHz
04:31:31 <dons> ...
04:31:39 <dons> processor       : 7
04:31:43 <dons> model name      : Intel(R) Xeon(TM) CPU 2.80GHz
04:31:45 <dons> :)
04:34:19 <int-e> hmmm.
04:34:25 <pitecus> Does the function g like this have a standard name:
04:34:28 <pitecus> g f [] = f []
04:34:28 <pitecus> g f (x:xs) = f (x:g f xs)
04:35:02 <dons> ?pl g f (x:xs) = f (x:g f xs)
04:35:03 <lambdabot> g = fix (flip flip tail . (ap .) . flip flip head . ((.) .) . liftM2 (.) (.) . (flip ((.) . (:)) .))
04:35:10 <Syzygy-> o.O
04:35:12 <dons> looks like a fold of some kind.
04:35:28 <nornagon> woah.
04:35:30 <nornagon> scary.
04:35:35 <int-e> @index par
04:35:35 <lambdabot> GHC.Conc, Control.Parallel, Graphics.HGL.Utils, Graphics.HGL
04:36:13 <nornagon> I'm new to haskell (and to functional programming in general, but less so). I'm having odd discrepancies between hugs and ghc. I'm writing a simple 'running sum' program, and when I try to print a prompt then get a line... in GHC, the prompt gets printed after the line is read.
04:36:23 <pitecus> What does ?pl do?
04:36:31 <dons> its to do with line buffering in ghci, nornagon
04:36:40 <nornagon> ah
04:36:44 <dons> try setting the buffering to ubuffering in ghci,
04:36:46 <nornagon> so how do I flush?
04:36:48 <dons> or for example, flusing
04:36:51 <dons> ?type hFlush
04:36:52 <lambdabot> Not in scope: `hFlush'
04:36:56 <dons> ?hoogle hFlush
04:36:58 <lambdabot> IO.hFlush :: Handle -> IO ()
04:37:02 <dons> like that.
04:37:07 <nornagon> okay.
04:37:18 <nornagon> hFlush stdout?
04:37:19 <dons> do putStr "my promopt> " ; hFlush stdout -- for exampe
04:37:20 <dons> yep
04:37:26 <nornagon> awesome
04:37:27 <nornagon> thanks
04:37:44 <xerox> pitecus: g f [1,2,3] = f (1 : f (2 : f (3 : f []))), I'm not sure what one would use it for.
04:38:04 <dons> pitecus: @pl does point free refactorings. sometimes it does amusing things :)
04:38:21 <xerox> pitecus: "?pl" turns Haskell code to points-free form, i.e. it eliminates all the named arguments.
04:38:28 <dons> ?pl \f g x y z -> f (g x y z)
04:38:29 <lambdabot> (.) . (.) . (.)
04:39:00 <nornagon> hm, apparently hFlush and stdout are not in scope -- do I import IO?
04:39:09 <dons> import System.IO
04:39:09 <xerox> @index hFlush
04:39:10 <lambdabot> System.IO
04:39:13 <nornagon> ah
04:39:17 <nornagon> ty
04:39:18 <dons> so in ghci you'd:  :m + System.IO
04:39:28 <dons> and in your source file, you'd: import System.IO
04:39:34 <Baughn> nornagon: import qualified System.IO as IO -- and IO.hFlush
04:39:36 <dons> btw, have you tried compiling the code in ghc?
04:39:43 <xerox> Baughn: yuck, why?
04:39:46 <nornagon> yeah, i'm using ghc proper
04:39:50 <nornagon> not ghci
04:39:52 <dons> ok.
04:40:12 <Baughn> xerox: To avoid namespace collisions. I never import an /entire/ package unqualified, just single symbols
04:40:17 <nornagon> excellent, it works now.
04:40:27 <nornagon> Next: WORLD DOMINATION!
04:40:32 <dons> yay!
04:40:32 <pitecus> xerox, maybe this: g (' ':) "abcd"
04:40:39 <pitecus> " a b c d "
04:40:42 <dons> nornagon: what are you working on?
04:40:43 <xerox> pitecus: yeah.
04:41:01 <nornagon> dons: learning haskell :) nominally to write a tracker in.
04:41:06 <xerox> intersperse = init . tail . g (' ':)
04:41:09 <dons> cool.
04:41:21 <dons> let us know if you have any other questions or want advice on coding style.
04:41:24 <nornagon> A tracker being some kind of music creation program, in case anyone's wondering.
04:41:27 <nornagon> sure :)
04:41:35 <dons> ah nice!
04:41:36 <xerox> intersperse = (init . tail .) . g . (:) -- in fact
04:41:41 <nornagon> I'm sure I'll have plenty, some stuff's a bit mind-bendy.
04:41:50 <dons> nornagon: have you seen Haskore?
04:41:55 <nornagon> no..?
04:41:57 <dons> its a famous music composition system in haskell
04:42:06 <nornagon> interesting
04:42:10 <dons> let me find a url ..
04:42:19 <nornagon> trackers are generally a "bit different"
04:42:29 <dons> http://www.haskell.org/haskore/
04:42:31 <lambdabot> Title: The Haskore Computer Music System
04:42:43 <dons> it's a little old, but nice to look at
04:45:28 <xerox> Anybody knows what algebraic equation could have been illustrated by this shape, as the description mentions? <http://www.getty.edu/art/gettyguide/artObjectDetails?artobj=53247>
04:45:29 <lambdabot> http://www.getty.edu/art/gettyguide/artObjectDetails?artobj=53247>
04:45:38 <nornagon> wow, ihope is everywhere.
04:45:47 <nornagon> hi ihope!
04:46:13 <ihope> Yes, I am everywhere. And hello.
04:46:16 <lisppaste2> int-e pasted "SMP test program?" at http://paste.lisp.org/display/29269
04:47:11 <dons> int-e, ok, trying it
04:47:14 <int-e> dons: woops. s/'b'/'z'/
04:47:15 * ihope makes it everywhere but #debian
04:47:21 <nornagon> so... would I be right in saying monads let some bits of code be stateful and ordered while letting other bits of code be context free and lazy and happy?
04:47:38 <ihope> nornagon: yep, I think so.
04:48:40 <int-e> dons: anyway, it's a first idea. I don't know if my use of `par` is correct, and I don't know if it even has a chance of triggering a race. the expected output is 'True'; if it prints 'False', something went wrong.
04:48:56 <int-e> dons: i.e. it got different sums from different threads.
04:49:02 <dons> ok. yes.
04:49:04 <dons> running it ...
04:49:21 <dons> ah, better set some multiple cpu threads. hang on ...
04:49:48 <xerox> int-e: "yes abqszzzq" ?
04:49:58 <xerox> "echo abqszzzq" maybe?
04:50:08 <dons> $ yes abqszzzq | head -c 100000 | ./a.out +RTS -N4
04:50:08 <dons> False
04:50:11 <dons> !
04:50:29 <xerox> yuck.
04:50:37 <dons> $ yes abqszzzq | head -c 100000 | ./a.out +RTS -N1
04:50:38 <dons> True
04:50:38 <dons> $ yes abqszzzq | head -c 100000 | ./a.out +RTS -N2
04:50:38 <dons> False
04:50:42 <dons> int-e++
04:50:45 <int-e> cool
04:50:58 <xerox> Could you explain what "yes foo" does?
04:51:14 <dons> > repeat "foo"
04:51:16 <lambdabot>  ["foo","foo","foo","foo","foo","foo","foo","foo","foo","foo","foo","foo","fo...
04:51:17 <dons> roughly
04:51:22 <int-e> yes is a program that prints a line all over on stdout
04:51:29 <ihope> unlines . repeat, I think.
04:51:31 <int-e> normally 'y' (hence the name)
04:51:41 <xerox> I thought it only returned "true".  I see, thanks.
04:52:10 <dons> so can we state what is happening here?
04:52:37 <dons> enough to ask SimonM about it.
04:54:45 <int-e> Hmm. Ok, we have a  list thunk (returned by getContents) that, when entered, does IO.
04:55:13 <dons> yep
04:55:27 <int-e> If more than one thread enters it at the same times, we read two blocks for the same list thunk - which results a) in loss of blocks for both threads b) in both threads seeing different lists.
04:55:57 <dcoutts> which would be bad :-)
04:56:07 <dons> dcoutts: did you see the above result?
04:56:14 <dons> -N1 v -N2
04:56:25 <dcoutts> dons, I've never reproduced it, but I was indeed worried about the possability.
04:56:28 <int-e> to trigger it, we need a) fool the compiler into performing the same computation twice. basically fooling CSE, that's what 'fool' does in my code and b) read as many blocks as possible - hence the NoBuffering.
04:56:29 <dons> so I think this is a practical case of what Simon was talking about regarding lazy io and lazy bytestrings
04:56:40 <dcoutts> yeah, we'd have just the same problem with bytestrings
04:57:08 <dcoutts> JaffaCake suggested we need a locking unsafePerformIO
04:57:08 <dons> yeah, so it runs fine when running in a single OS thread
04:57:21 <dons> but once we actually use two OS threads we get the condition
04:57:29 <dons> yeah, the SMP paper talks about justOnce :: a -> a
04:57:43 <dons> to avoid the 'pure' thunk getting evaluated twice
04:57:48 <int-e> but it doesn't exist in ghc. (maybe it has a different name?)
04:58:01 <dons> not sure it exists. i've not seen any patch
04:58:10 <dcoutts> so we need reallyUsafePerformIO = unlockedPerformIO :-)
04:58:17 <dons> i bet if we send in a test case where we got it in practice they'd think about it.
04:58:20 <dons> yeah
04:58:23 <int-e> anyway, I'm happy that my first attempt worked. that's more than I expected :)
04:58:28 <dons> yeah. that rocks.
04:58:44 <dons> and so nicely, a haskell program that returns different results based on -N1 and -N2 !
04:58:59 <dcoutts> so actually we need 3 flavours, no sharing, locked and unlocked
04:59:14 <int-e> what's 'no sharing'?
04:59:38 <dcoutts> int-e, where we don't want one use of unsafePerformIO to be commoned-up with another
04:59:51 <int-e> oh, because the stuff gets inlined, right.
05:00:04 <int-e> 'we believe inlining this is safe, blah, blah' :)
05:00:06 <dcoutts> eg unsafePerformIO $ mallocByteString n >>=
05:00:10 <dons> yeah
05:00:21 <dcoutts> the above should never be commoned up
05:00:25 <dons> oh, and one thing
05:00:31 <dcoutts> since then two strings will overwrite each other
05:00:32 <dons> does that 'par' do what we think it does?
05:00:42 <dons> was there an issue with .. oh hang on, no that was pseq and seq
05:01:08 <dcoutts> but we have many examples in the ByteString lib where it is completely safe to do an unlocked, inlined CSE-abla unsafePerformIO
05:01:13 <dons> seq exported as pseq by accident
05:01:17 <dcoutts> mostly for reading existing bytestrings
05:01:18 <int-e> I don't know if the `par` y  is actually needed.
05:01:28 <mayweed> does anyone work on that: http://hackage.haskell.org/trac/ghc/ticket/288 ?
05:01:31 <lambdabot> Title: #288 (amd64-FreeBSD-5.3 port?) - GHC - Trac, http://tinyurl.com/yf3wef
05:02:40 <dcoutts> dons, int-e, so am I right in thinking that all we need is for ordinary unsafePerformIO and unsafeInterleaveIO to be locked.
05:03:02 <dcoutts> then we can introduce non-locking versions that people can use if they really really know what they're doing.
05:03:08 <int-e> anyway, to fix it, something like  justOnce  is needed, and the obvious place to put it is these two primitives.
05:03:33 <dons> yeah
05:03:55 <int-e> (unsafePerformIO and unsafeInterleaveIO. With the existing libraries I think it's best to add  unlocked*  rather than changing everything to use a  locked*  version)
05:04:15 <dcoutts> int-e, surely we want safe by default ?
05:04:22 <dons> int-e, would you like to post this test program, the output i provided, and a summary of this discussion on a Trac ticket?
05:04:28 <int-e> dcoutts: yes.
05:04:37 <dons> mayweed: best ask on glasgow-haskell-users@haskell.org
05:04:48 <dcoutts> int-e, sorry, I misinterprded you, we were both agreeing :-)
05:04:48 <mayweed> dons: will do it
05:05:06 <mayweed> I might work on it
05:05:12 <int-e> dons: can do.  did you use  ..'z' ?
05:05:22 <mayweed> to code in haskell on my main box
05:05:32 <mayweed> which is FBSD/Amd64
05:05:38 <dons> ..z int-e?
05:05:44 <dcoutts> then we should lobby for System.IO.Unsafe.(inline|unlocked)Unsafe(Interlave|Perform)IO
05:06:08 <int-e> dons: in this line:  ts = map (:hs) ['a'..'b'] ... I originally intended to use ..'z'.
05:06:25 <dons> ah , let me try that
05:06:44 <int-e> dons: but if ..'b'  worked, that's great.
05:06:59 <dons> so I:
05:07:00 <dons> $ ghc -O A.hs -threaded
05:08:01 <dons> /tmp/ghc5400_0/ghc5400_0.hc:275:0:
05:08:01 <dons>      warning: implicit declaration of function 'newSpark'
05:08:09 <dons> -- good sign I got the right rts
05:08:21 <dons> $ yes abqszzzq | head -c 100000 | ./a.out +RTS -N1
05:08:22 <dons> True
05:08:22 <dons> $ yes abqszzzq | head -c 100000 | ./a.out +RTS -N2
05:08:22 <dons> False
05:08:31 <dons> $ uname -msr
05:08:31 <dons> Linux 2.6.15.3-general i686
05:09:06 <dons> with SMP kernel
05:10:05 <dons> with:
05:10:07 <dons> CPU7: Intel(R) Xeon(TM) CPU 2.80GHz stepping 08
05:10:08 <dons> Total of 8 processors activated (44807.44 BogoMIPS).
05:10:14 <dons> -- now that's some BogoMIPS!
05:10:56 <dons> and yes, with 'a' .. 'b' and 'a' .. 'z'
05:11:21 <dons> hmm. should be ableto run hmp3 with 5 threads on 5 cores this way
05:11:28 <dons> a dedicated core for updating the status bar :)
05:11:30 <dcoutts> hah hah
05:11:44 <dcoutts> will it sound better ? :-)
05:11:57 <dons> It must do!
05:12:18 * dons <3 the concurrent future
05:13:11 <dcoutts> dons, btw did I say?, assuming I can find funding, I will be coming to .au
05:13:37 <dons> yeah! great!!
05:13:50 <dons> streams onward-ho!
05:13:53 <dcoutts> my supervisor is very happy for me to switch to this project as my main thesis topic :-)
05:13:55 <dcoutts> woo!
05:14:04 <dons> great. it should be a really fun topic for a phd
05:14:08 <dons> very motivating
05:14:10 <dcoutts> aye
05:15:08 <dons> haskell needs a dedicated phd (or two) to work on performance improvements  :)
05:15:12 <dcoutts> so I'll talk to ChilliX about funding and ask around here too
05:15:14 <dons> so this is very timely.
05:15:14 <dcoutts> heh, yeah
05:15:15 <dons> yep
05:15:44 <dons> yeah, definitely talk to ChilliX, I know there are some grants for organising cross-university collaboration
05:16:03 <dcoutts> yeah, he mentioned that
05:16:24 <dons> also, i need to book my ticket for Nice soon, and I was thinking I'd come and see you guys in Oxford, whether we have the infrastructure hackathon or not.
05:16:31 <dcoutts> cool
05:16:35 <dons> any ideas on the hackathon before PADL?
05:16:41 <dons> will you be around ?
05:16:43 <dcoutts> I can get a room
05:16:49 <dcoutts> in the comlab for us
05:17:09 <dons> it'd be cool to get ndm and beelsebob and anyone else who can make it down for a couple of days
05:17:14 <dcoutts> yeah
05:17:15 <dcoutts> how long were you thinking of saying here?
05:17:32 <dons> hmm, 3 or 4 days before PADL? could stay longer I think
05:17:43 <dcoutts> I can put you up here at my and my gf's flat for a few days
05:17:49 <dcoutts> we've got a spare room
05:17:49 <dons> i'll need to check the schedule precisely
05:17:56 <dcoutts> 10 min walk from the comlab
05:18:01 <dons> oh, thanks. i'll keep that in mind!
05:18:46 <dcoutts> (or 5 min by unicycle)
05:18:51 <dons> heh
05:20:10 * Igloo bets it would take dons more than 5 mins by unicycle
05:20:22 <dons> I think maybe so!
05:20:50 <Igloo> Possibly as many as 6 and a half!
05:21:17 <dcoutts> minutes or days ?
05:21:22 <dons> heh
05:21:47 <dons> ok. i'll try to work out a timetable this week
05:22:39 <dcoutts> I bumped into a couple of my students the other day and they asked me why so many Haskell people ride unicycles.
05:22:48 <dons> hehe
05:22:51 <dons> what did you say?
05:23:05 <dcoutts> I said just just what all the cool people do
05:23:23 <dons> maybe hmm .. we should have a logo based on the single, foundational unicycle wheel
05:23:37 <Igloo> one wheel to rule them all, one ...
05:24:03 <dcoutts> but perhaps a better answer is that it's the most practical way of programming and getting about :-)
05:24:27 <dons> true!
05:24:42 <dons> yeah, lock free cycling + hacking
05:24:56 <dons> you don't want to stop programming just because you need to ride a bike
05:25:09 <dcoutts> true, I don't carry any locks, I just bring my cycle into the office
05:26:36 <int-e> dons, dcoutts: http://hackage.haskell.org/trac/ghc/ticket/986
05:26:39 <lambdabot> Title: #986 (SMP race condition in getContents) - GHC - Trac, http://tinyurl.com/y7rv86
05:27:27 <dcoutts> int-e, looks good
05:27:57 <dons> int-e++
05:28:02 <dcoutts> The unicycle makers should market to business people on the basis that it'll save them time, faster than waling, can still carry an umbrella and talk on the mobile phone while on the move.
05:28:24 <dons> s/Steward/Stewart/ :)
05:28:36 <dons> dcoutts: hands free cycling.
05:29:17 <int-e> dons: oops, sorry
05:30:00 <dons> its fine :)
05:30:54 <int-e> Heh, I won't fret over it.
05:31:20 <beelsebob_> what's this about hackathon and unicycling?
05:35:34 <dons> beelsebob_: we're thinking about having a haskell infrastructure hackathon before POPL/PADL in January
05:35:40 <dons> in Oxford.
05:35:51 <beelsebob_> fun
05:35:55 <beelsebob_> I could probably do that
05:35:59 <dons> to work on things like cabal, libraries, compilers and so on
05:36:09 <beelsebob_> makes sense
05:36:22 <beelsebob_> I could probably try and hack some more libraries into yhc and/or hat
05:36:36 <dons> i'll be up from .au, and we can probably find a few others from around the place
05:36:56 <beelsebob_> in fact... do a wine like approach - have some people there with real code they want to work in Hat and try and get it to squeeze in
05:37:09 <dons> yeah, that'd be good
05:39:25 <dons> ok. we should probably create a wiki page and sketch some ideas
05:39:35 <dons> as was done for AngloHaskell and EuroHaskell in the past
05:50:36 <int-e> did anyone look at my 'mystery function'?
05:57:03 <dons> oh, what was that?
05:57:34 <int-e> http://paste.lisp.org/display/29265 (2 hours ago)
05:58:22 <roconnor>  int-e is it decss?
05:58:31 <xerox> Type-check it doesn't count as execution right? :)
05:59:08 <int-e> roconnor: na, it's a rather simple problem. :)
06:03:52 <roconnor> ah, of course,  it does exactly what it says is to does
06:04:57 <int-e> actually it's just a result of microoptimization - I looked at the final code and found it quite unobvious.
06:06:04 <roconnor> the drop r-1 and take r-1 are odd
06:06:13 <roconnor> soulds like your input is off by one.
06:06:17 <roconnor> er
06:06:19 <roconnor> sounds
06:06:26 <int-e> it's not :)
06:06:59 <roconnor> is fun 0 supposed to be the same as fun 1?
06:10:45 <int-e> good question.
06:11:56 <roconnor> @quickcheck \x -> drop 0 (x::[Int]) == drop (-1) x
06:11:57 <lambdabot> Unknown command, try @list
06:12:04 <roconnor> @check \x -> drop 0 (x::[Int]) == drop (-1) x
06:12:05 <lambdabot>  OK, passed 500 tests.
06:13:42 <lisppaste2> int-e annotated #29265 with "spoiler" at http://paste.lisp.org/display/29265#1
06:13:58 <Dylan> hmm, it seems my haskell avangelism has worked, a little. XD
06:15:29 <yaxu> i'm going to perform some music from the ghci command prompt tonight :)
06:15:48 <int-e> roconnor: I deliberately left out the  fun 0  case.
06:15:51 <Pupeno> yaxu: what ?
06:16:18 <yaxu> Pupeno: i don't know what yet, it will be improvised
06:16:30 <yaxu> i'm on last so i guess it should be a danceable
06:16:55 <Pupeno> yaxu: it was more of a "what are you talking about ?" than "What will you be playing ?".
06:17:34 <yaxu> Pupeno: i'm a beginner haskell programmer, but managed to make a parser for composing rhythms
06:18:02 <yaxu> Pupeno: it sends the rhythms to supercollider for synthesis
06:18:24 <yaxu> i haven't had time to make any kind of interface so will just have a few instances of it running in ghci
06:18:40 <yaxu> a few instances of ghci running it, rather
06:18:57 <Pupeno> Interesting.
06:20:02 <dons> yaxu: sounds cool!
06:20:32 <yaxu> come over if you're in london uk
06:20:34 <yaxu> http://pawfal.org/openlab/
06:20:36 <lambdabot> Title: OpenLab
06:20:41 <dons> is that using the supercollider binding?
06:20:51 <xerox> dons, you and dcoutts will go to Venice in January right?
06:20:53 <yaxu> dons: no not really
06:20:58 <dons> xerox: Nice.
06:21:04 <xerox> Nice, France?
06:21:07 <dons> yep
06:21:16 <dcoutts> na it's horrible
06:21:19 <dcoutts> ;-)
06:21:29 <xerox> Ah-ha.  That's even closer to me :)
06:21:39 <yaxu> dons: i'm using the osc stuff from it for sending messages to sc, but not defining the synthesiser in haskell yet
06:21:48 <psykotic> anything on the coast is tres bien :)
06:21:52 <dons> yaxu, would be great to see the code when you're done. also, see here http://haskell.org/haskellwiki/Libraries_and_tools/Music_and_sound
06:21:55 <lambdabot> Title: Libraries and tools/Music and sound - HaskellWiki, http://tinyurl.com/y5jw6h
06:22:27 <psykotic> xerox: do you know the cap d'agde area?
06:22:33 <dons> yaxu: and if you want to blog about it, i think it would be really cool to hear about.
06:22:34 <psykotic> not too far from carcasonne, etc
06:23:18 <dons> anyone know if haskore is used for composing things 'live' ?
06:23:24 <xerox> nope, psykotic, I live in Italy :)
06:23:46 <yaxu> dons: thanks, i didn't know about the haskell dsp stuff
06:23:53 <psykotic> xerox: ah, i thought you might be familiar with south france in general.
06:24:04 <yaxu> dons: my impression was that haskore is for composing rather than improvising
06:24:14 <dons> yaxu: yeah, that is right I think
06:24:22 <xerox> psykotic: you live there?
06:24:35 <yaxu> dons: my parser is based on bernard bel's BP2
06:24:37 <psykotic> xerox: nope but i have a friend in the area, i visit whenever i get a chance. :)
06:24:47 <dcoutts> xerox, google maps claims it's just 280km, 4 hours drive away.
06:24:52 <psykotic> i'm stuck in south korea these days and miss south europe more than a little
06:24:56 <dcoutts> xerox, so maybe see you there :-)
06:25:03 <xerox> dcoutts yeah, I thought you said venice the other day :)
06:25:07 <psykotic> also north italy
06:25:18 <dcoutts> xerox, I'm sure I said Nice
06:25:20 <yaxu> dons: am happy to share my code, won't be releasing it officially until it's less of a mess though
06:25:22 <dcoutts> nm
06:25:31 <xerox> Yeah, the problem mine, duncan :)
06:25:45 <dcoutts> xerox, na, I mumble :-)
06:25:53 <dons> yaxu: sure, be sure to let us know when its available
06:25:58 <dons> sounds very exciting
06:26:02 <yaxu> dons: it's part of my MSc project, I will be blogging about it at http://doc.gold.ac.uk/~ma503am/
06:26:07 <lambdabot> Title: Alex McLean
06:26:31 <xerox> @localtime psykotic
06:26:32 <yaxu> dons: will do, and will add it to that haskell/music wiki page
06:26:33 <lambdabot> Local time for psykotic is Sat Nov  4 23:26:18
06:26:37 <xerox> wow, that's quite far!
06:26:40 <dons> yeah, that'd be great.
06:27:27 <dons> mmm. actually we have a couple of people who've worked on sound-based DSLs in Haskell
06:27:38 <dons> most of the work has been on image manipulation DSLs
06:28:02 <dons> but a guy at Sydney, seefried, did some work on sound generating EDSLs
06:28:16 <yaxu> dons: oh i'd really like to hear about that
06:28:31 <dons> i'll ping Sean and see if I can find some notes on it
06:28:49 <dons> (it's Sunday morning here in .au, so might be a couple of days till I hear back)
06:29:00 <yaxu> ok :)
06:29:21 <spiffy> shuffle old | (length deck) > 1 = let (card, shuffled) = deal old (length old -1)
06:29:33 <spiffy> shouldnt that keep the length from ever being negative?
06:29:37 <dons> his work on live image manipulation is here, http://www.cse.unsw.edu.au/~sseefried/pantheon_gallery.html
06:29:39 <lambdabot> Title: Sean Seefried - PanTHeon Gallery, http://tinyurl.com/vc2kf
06:29:59 <dons> more stuff on his web page, and a couple of papers, http://www.cse.unsw.edu.au/~sseefried/
06:30:00 <lambdabot> Title: Sean Seefried
06:31:17 <dons> this is really a nice domain for haskell though. there's been a lot of work on EDSLs for related ideas to your work, I think.
06:32:14 <yaxu> very good to hear
06:32:28 <yaxu> although now i'm parsing rather than embedding
06:32:46 <dons> some more things on the image work here http://haskell.org/haskellwiki/Research_papers/Domain_specific_languages
06:32:49 <lambdabot> Title: Research papers/Domain specific languages - HaskellWiki, http://tinyurl.com/ykgtom
06:32:50 <dons> ah ok.
06:33:41 <dons> seems like it would a nice project to write the DSL directly in haskell
06:33:51 <yaxu> yes but there is a problem
06:34:04 <yaxu> i want to make a language for improvisation
06:34:32 <dons> right, so you need to avoid finding errors till as late as possible?
06:34:36 * dons speculates
06:35:02 <yaxu> no it's not about that, i'm trying to think how to explain it
06:35:26 <yaxu> so i write a function in haskell that generates a rhythm of infinite length
06:35:43 <yaxu> i'm playing that rhythm, then i edit that function
06:35:55 <yaxu> and reload it using hs-plugins
06:36:04 <yaxu> that's not going to work, is it?
06:36:33 <dons> yeah, it'd be a bit awkward. if you could run it in ghci though
06:36:38 <yaxu> i'm not explaining it very well, but there seems to be a mismatch between EDSLs and dynamic programming
06:36:58 <dons> so a key feature is replacing code on the fly?
06:37:03 <yaxu> yes
06:37:17 <dons> yeah, so running in an interpreter (or a custom interpreter for the DSL) would be simpler
06:37:35 <dons> ie. .:reload in ghci could be nice, if there wasn't state you had to reproduce
06:37:45 <yaxu> state is the problem
06:37:51 <dons> yeah, i can imagine
06:38:06 <dons> so how is this typically done? using actual hot swapping in the perl interpreter?
06:38:13 <yaxu> but maybe state isn't all that important
06:38:15 <integral> .oO( hs-plugins )
06:38:30 <integral> Some one asked on the ghc-users ML about a modified ghci that didn't destroy the state
06:38:51 <xerox> In some sense that's what Yi does, right?
06:38:55 <dons> yeah
06:38:57 <dons> and lambdabot
06:39:00 <xerox> Right.
06:39:04 <dons> its quite possible to preserver state and hot swap with hs-plugins
06:39:10 <yaxu> dons: in perl i'm just reloading methods of objects and the data stays intact
06:39:10 <dons> not sure its the lightest weight solution though
06:39:15 <dons> right.
06:39:29 <yaxu> dons: aha
06:39:46 <dons> lambdabot's made up of 80 or so plugins which we fix and replace on the fly, for example.
06:39:52 <dons> ?yow!
06:39:52 <lambdabot> I had pancake makeup for brunch!
06:40:08 <dons> but i bet its lighter weight when replacing code in an interpreter
06:40:11 <dons> more like :reload inghci
06:40:41 <yaxu> yeah i did get hs-plugins working with a simple music edsl
06:41:03 <dons> oh, very nice! i had no idea.
06:41:12 <dons> i wish the users told me about this kind of use of the library.
06:41:59 <yaxu> dons: http://youtube.com/watch?v=eLS6GHXWMpA
06:42:35 <yaxu> dons: aha, you are dons of ~dons/hs-plugins/ then :)
06:42:58 <dons> yes ! :)
06:43:08 <Pupeno> Since YAHT was the best out there, does that mean that the Wikibook is the new best ?
06:45:26 <chessguy> what in the world is that music?
06:45:55 <dons> live haskell music!
06:46:24 <dons> i should really try to get flash working on openbsd at some point.
06:48:06 <dons> yaxu: do let us know how it goes. sounds like lots of fun.
06:48:17 <dons> if you can blog about it, i'll write something for the haskell weekly news on it
06:48:42 <integral> theoretically you should be able to use the GHC API to embed ghci+bytecode-whatnots in your program :-/
06:49:15 <dons> yep.
06:51:07 <MarcWeber> I've trouble getting my own darcs server using ssh. Using root user works, using owner 'darcs' fails with "Permission denied (publickey,keyboard-interactive)". Where is the difference?
06:51:39 <dons> check on #darcs maybe?
06:51:49 <dons> if no one here knows
06:51:49 <dcoutts> na, it's an ssh setup problem
06:52:11 <dcoutts> try logging in manually, you'll see the same problem
06:52:13 <MarcWeber> dons After installing ssh keys it worked
06:52:20 <dcoutts> right
06:52:30 <MarcWeber> dcoutts: Logging in manualy does work. That's od
06:52:46 <integral> (ssh -v is sometimes handy)
06:53:09 <dcoutts> MarcWeber, so you're saying it currently works manually but not via darcs ?
06:53:32 <MarcWeber> integral: ssh didn't make any problem, neither did darcs get root@server:path but darcs@server:path did make trouble
06:53:56 <integral> ah.
06:54:15 <int-e> does root@  require password input?
06:54:24 <MarcWeber> dcoutts: manually and using root. but not using darcs. I've installed ssh keys now and it does work using darcs user now.
06:54:42 <MarcWeber> int-e: no. right.
06:56:11 <MarcWeber> anyway my problem is solved. Thanks for listening. I want to make sure my vim scripts work on windows as well. cu
06:58:35 <yaxu> dons: ok will do!  will ask you about seefried in a couple of days too
07:00:46 <dons> great, and good luck with the talk/music/performance! :)
07:02:44 <yaxu> dons: you seem to have the same cat as me
07:03:32 <dons> heh
07:03:53 <dons> is nina a quantum super-position cat perhaps? :)
07:04:05 <dons> because i don't know where she is right now. hmm..
07:05:11 <shapr> shapr-style!
07:05:13 <shapr> w00
07:05:33 <yaxu> olga the cat is asleep upstairs afaik
07:05:35 <shapr> dons: What happens in Nice France?
07:05:53 <dons> PADL and POPL, so the bytestring paper will be presented
07:05:53 <chessguy> @quote shapr
07:05:54 <lambdabot>  The legal system is the ultimate denial of service attack.
07:06:03 <yaxu> http://www.flickr.com/photos/yaxu/276317639/
07:06:04 <shapr> Oh I see.
07:06:05 <lambdabot> Title: Olga bright eyes on Flickr - Photo Sharing!
07:06:25 <dons> shapr: did yo usee yaxu's live haskell music?
07:06:32 <shapr> No?
07:06:42 <shapr> I want to see it!
07:06:54 <dons> yaxu, url? :)
07:07:00 <chessguy> that's a scary cat
07:07:12 <chessguy> <yaxu> dons: http://youtube.com/watch?v=eLS6GHXWMpA
07:07:33 <dons> as i understand, he's currently using haskell to parse music for a live demo tonight? and he's done some live haskell coding to music with hs-plugins
07:07:33 <shapr> chessguy: thanks
07:07:46 <dons> live haskell code that produces music :)
07:08:14 <dons> yaxu: that's nina cat!
07:08:25 <chessguy> so the music changes according to what keys he's hitting? or according to the code that he's playing with?
07:08:28 <shapr> Hm, does that include a download link same as google video? Flash doesn't work in my browser.
07:08:34 <dons> mine either :/
07:08:43 <dons> chessguy: the code
07:08:55 <dons> :reload the function and get a new rhythm sequence, i think
07:09:00 <xerox> ?arrr
07:09:01 <lambdabot> Aye Aye Cap'n
07:09:10 <dons> so like Pan stuff for live image hacking, but for music
07:09:20 <xerox> dons, and then you play mendelbrot
07:09:25 <xerox> *mandelbrot
07:09:34 <shapr> I've heard of that sort of live performance, and I've wanted to try it myself.
07:09:37 <chessguy> oh i see
07:09:42 <xerox> shapr: me too!
07:09:44 <dons> well, yeah, seefried does this to play with patterns and algorithmic images
07:09:59 <dons> tweaking values producing different kinds of visual effects on the fly
07:10:10 <shapr> yaxu: Is your code available, or is the process documented so others can recreate it?
07:10:18 <shapr> yaxu: Would you write about this for TMR? :-)
07:10:31 <dons> yeah, I think he's hacking right now. the perl stuff looks like its available.
07:10:39 <xerox> shapr, aha, you are asking him for a tutorial!
07:11:00 <xerox> This is evil, you made up this TMR thing to have people write papers on things you like!
07:11:15 <chessguy> what's TMR?
07:11:32 <dons> shapr, hoempage http://doc.gold.ac.uk/~ma503am/
07:11:32 <xinming> Hello, Is there a shortcut for getting accessor for these type? :-P
07:11:35 <xinming> type Record = (Int, String, Int)
07:11:35 <lambdabot> Title: Alex McLean
07:11:46 <dons> xinming: fst3/snd3/thd3
07:11:50 <dons> which you can write yourself :)
07:11:53 <shapr> My gf is in flying back to Sweden tomorrow, so I don't have much time to talk till she's gone home. I'll be back to chat more tomorrow!
07:11:56 <dons> othrewise, use a record type and get free accessors
07:11:59 <xerox> xinming: no. If you don't count (\(x,_,_)->x) as one of them
07:12:10 <dons> data Record = Record { a :: Int, b :: String , c :: Int }
07:12:15 <dons> Record 1 "foo" 7
07:12:23 <dons> then you have a , b and c as accessors
07:12:23 <xinming> and If we  wish to get the Frist one, We have to write a function,
07:12:31 <dons> so, a x == the value of a
07:12:31 <xinming> dons: thanks, that's what I want.
07:12:34 <Dylan> dons: so... which is better for the pretty printer combinator thing? A char-by-char system, or something that returns chars and possibly "special" things like function keys and other multi-byte sequences?
07:12:41 <xerox> shapr: enjoy!
07:12:53 <dons> Dylan: for input or output?
07:12:59 <Dylan> dons: input
07:13:01 <yaxu> sorry got distracted with pictures of cats
07:13:12 <dons> our cats look very similar!
07:13:28 <yaxu> shapr: i could probably dig out a .mov if it's useful
07:13:45 <Dylan> I can use SLang_get_key() to just read chars and leave the processing keypad stuff to haskell, or use SLkp_getkey and have keypad processing done in C.
07:13:56 <dons> i'd do the processing on the .hs side
07:14:11 <dons> unless getting keypads is easier
07:14:19 <dons> so you could get symbolic arrows and so on
07:14:26 <Dylan> well, keypads requires this interesting hack to get the constants to work.
07:14:31 <yaxu> shapr: i'm happy to share the code but i'm a beginner programmer so it's not very good.  it's part of my MSc project, when i've done it properly it will be released properly
07:14:35 <dons> right, you need hsc2hs or something?
07:14:52 <yaxu> shapr: well an experienced perl programmer but a beginner haskell programmer
07:14:55 <Dylan> dons: http://odin.hardison.net/darcs/haver/client/src/Slang/SLkp.hsc
07:14:59 <lambdabot> http://tinyurl.com/y3wddz
07:14:59 <dons> yaxu: if you host it, you're likely to get lots of useful feedback :)
07:15:43 <dons> Dylan: looks fine
07:16:08 <Dylan> dons: I'll expose the lower-level getkey as well.
07:16:13 <yaxu> shapr: i didn't know about TMR, very happy to write about this stuff though
07:16:30 <dons> ?. pl undo getkey = do i <- getkey';  return (decode i)
07:16:31 <lambdabot> (line 1, column 21):
07:16:31 <lambdabot> unexpected "{"
07:16:31 <lambdabot> expecting variable, "(", operator or ")"
07:16:33 <chessguy> so what is TMR?
07:16:39 <xerox> yaxu: The Monad.Reader
07:16:39 <dons> ?. pl undo getkey = do i <- getkeyPrime;  return (decode i)
07:16:40 <lambdabot> (line 1, column 21):
07:16:40 <lambdabot> unexpected "{"
07:16:40 <lambdabot> expecting variable, "(", operator or ")"
07:16:50 <dons> ?. pl undo do i <- getkeyPrime;  return (decode i)
07:16:50 <lambdabot> decode `fmap` getkeyPrime
07:16:52 <Dylan> dons: the only thing with the lower-level getkey is you'll have to know how different terminals send alt-foo, up/down/left/right, etc
07:16:54 <xerox> yaxu: I think it would be great if you wrote an article for the next TMR issue
07:17:00 <dons> Dylan: yeah
07:17:13 <xerox> yaxu: I think we also chatted the first time you mentioned this thing here, afterwards
07:17:19 <ihope> @hoogle undo
07:17:21 <lambdabot> System.Console.Readline.UndoBegin :: UndoCode
07:17:21 <lambdabot> System.Console.Readline.UndoDelete :: UndoCode
07:17:21 <lambdabot> System.Console.Readline.UndoEnd :: UndoCode
07:17:25 <dons> yaxu: yeah, and anything you blog on this we'd love to hear about.
07:17:30 <dons> even feed it to planet.haskell.org
07:17:34 <ihope> Oh.
07:17:36 <ihope> @help undo
07:17:36 <lambdabot> undo <expr>
07:17:37 <lambdabot> Translate do notation to Monad operators.
07:17:40 <Dylan> dons: it's still a nightmare binding SLkp_define_key(char *, unsigned int) to haskell.
07:17:56 <Dylan> (it'd be possible with extensible types, though)
07:17:58 <dons> hmm, Ptr CChar and Word32 ?
07:18:00 <xerox> dons, you are taking the name "planet" in its broader sense!
07:18:07 <yaxu> well the code i used for that youtube movie is here - http://yaxu.org/hs/
07:18:10 <lambdabot> Title: Index of /hs
07:18:15 <Dylan> dons: the unsigned int would need to be turned into the Key type
07:18:16 <dons> yaxu++
07:18:21 <dons> Dylan: right.
07:18:59 <yaxu> that talks to something i wrote in C rather than supercollider
07:19:26 <yaxu> Application.hs is the entry point
07:19:27 <dons> yaxu, my girlfriend just asked about the picture of Nina you took :)
07:19:32 <dons> she thought it was our cat :)
07:19:35 <yaxu> heh
07:19:38 <ex0r[a]> small question, in haskell can you place an if then else inside brackets as an argument of a function?
07:19:46 <dons> 'cept for the collar, which is the give away
07:19:57 <ex0r[a]> like: (Node (if x==z then y else z) (map (replace x y) lis))
07:20:01 <kpreid> ex0r[a]: if you couldn't it would be bizarrely irregular
07:20:11 <Dylan> ex0r[a]: it is an expression, same as any other
07:20:15 <kpreid> ex0r[a]: Haskell has very few bizarre irregularities
07:20:22 <ex0r[a]> ok
07:20:22 <dons> > (if True then 7 else 8) + 1
07:20:30 <lambdabot>  8
07:21:18 <yaxu> when is the next tmr out?
07:22:04 <dons> I think the deaadline is Jan 10 or so? so a little while :)
07:22:25 <dons> until then there is the haskell weekly news for blog articles and so on
07:23:25 <dons> I see a forkIO! you can't be too much of a beginner :)
07:23:26 <yaxu> http://www.flickr.com/photos/yaxu/127126732/ # nina has a secret family
07:23:28 <lambdabot> Title: shiny cats on Flickr - Photo Sharing!
07:24:04 <dons> omg! :)
07:24:22 <dons> she is a very shiny cat
07:24:22 <yaxu> the last one was oct 2005?
07:25:42 <yaxu> dons: the forkIO using code isn't mine - sorry that was just a dump of my haskell directory from a couple of months ago
07:27:00 <Dylan> speaking of cats... http://midgetbutton.com/~spoony/milk.jpg
07:27:15 <lisppaste2> xinming pasted "Where I did wrong please." at http://paste.lisp.org/display/29275
07:27:20 <Dylan> (those cats are *not* related)
07:27:22 <kpreid> dons: I used a forkIO when I was a beginner
07:27:40 <xinming> hmm, Why will I failed if I change the type to data...
07:27:51 <Dylan> I also forkIO'd in my first-ish haskell program
07:28:10 <dons> yeah, just thinking that forkIO is one of the easier things to use
07:28:21 <kpreid> the program in question never really got anywhere (though it did what it was written to do)
07:28:25 <dons> xinming: data requires a constructor
07:28:42 <dons> so type T = (A,b,C) --> data T = R A B C
07:28:55 <dons> so type T = (A,b,C) --> data T = R { a :: A, b :: B , c :: C }
07:29:00 <dons> if you want to label the fields
07:29:29 <xinming> dons: Can the Constructor be the same as type name?
07:29:36 <spiffy> yup
07:29:37 <xinming> data Record = Record {getIndex :: Int, getName :: String, getPrice :: Int}
07:30:20 <dons> looks good.
07:30:44 <xinming> But in http://paste.lisp.org/display/29275  <-- -It fails...
07:30:58 <yaxu> i can't find the sourcefile for that youtube movie, sorry
07:31:17 <spiffy> xinming: What fails?
07:31:22 <spiffy> i.e what error
07:31:40 <dons> xinming: the -1 needs to be in parens
07:31:42 <dons> (-1)
07:31:51 <xinming> Couldn't match expected type `Record'
07:31:57 <dons> > Just -1
07:32:00 <lambdabot>  add an instance declaration for (Num (a -> Maybe a))
07:32:01 <dons> > Just (-1)
07:32:03 <lambdabot>  Just (-1)
07:32:27 <xinming> Ok, thanks...
07:32:38 <xinming> dons: It does compile for now.
07:32:39 <dcoutts> xinming, note also that the line "| null xs = getRecord xs i" is going to cause you problems.
07:32:48 <dons> so here (Record -1 "Error" -1) should be (Record (-1) "Error" (-1))
07:32:57 <dons> but it is better to use Just a and Nothing to signal error
07:33:08 <dons> so getRecord :: Database -> Int -> Maybe Record
07:33:16 <dons> and     | getIndex x == i = Just x
07:33:28 <dons>        |  otherwise =  Nothing
07:33:31 <dons> something like that.
07:33:38 <xinming> dons: thanks, I'm just picking up haskell again. :-)
07:34:07 <dons> :)
07:35:14 <spiffy> haskell is one of those languages i pick up every few months. Usually results in me getting angry. Few months later, see some nice haskell code. Repeat.
07:36:11 <pejo> dons, how is the Haskell Search Engine supposed to be used, just like google, but you get better results?
07:36:17 <dons> spiffy, ah well, next time you try, let us know. should be possible with careful anger^h^h^h type checker management issues :)
07:36:26 <dons> pejo: yeah, you get haskell.org-specific results
07:36:35 <dons> but its a bit experimental
07:36:44 <dons> it probably needs tuning by someone who is interested in search
07:37:00 <dons> it seems to have archived the mailing list rather well
07:37:13 <dons> oh, i should add the url of the complete 1990-2000 mailing list
07:37:23 * dons does so
07:37:24 <xinming> spiffy: hehe, Haskell is really hard to learn. I've tried to learn this last year. But I give up. What it stops me is all because of It's storng type, And what you see is always error return.
07:37:25 <pejo> dons, so it's not intended to give hits outside of Haskell.org? (Oleg's homepage, the fp groups of different universities, etc?)
07:37:33 <dons> nope.
07:37:39 <dons> but if you can find those, tell me, and we can add them
07:38:34 <dons> oleg's site would be one good src
07:38:40 <dons> as would any specifc haskell uni courses
07:38:41 <xerox> xinming: what does it mean "and what you see is always error return" ?
07:39:05 <pejo> dons, but not the research pages of unsw?
07:39:14 <dons> we could add that, yeah
07:39:22 <dons> i'm looking for the richest srcs first
07:39:39 <xerox> xinming: it is the compiler trying to tell you that in some type system your proof, or program, is not working.
07:39:52 <pejo> dons, Ah. Ok. (SPJ homepage is probably nice too, unsure of how it compares to Oleg's).
07:39:57 <dons> yeah good idea
07:40:32 <pejo> (Not that I'm reading my bookmark list, noo).
07:41:13 <xerox> xinming: what about strong typing stops you?
07:41:37 <dons> the compilation errors, i guess
07:41:50 <dons> better to have bugs earlier than later, imo.
07:41:54 <xinming> xerox: Just say that My return type is wrong.
07:41:58 <spiffy> hmmm type errors havent been a major problem for me.
07:42:14 <xerox> xinming: your return type is very important, you should think carefully about it
07:42:46 <xinming> and I always don't know where to find error. unlike other language. eg perl 5. :-P
07:43:20 <dons> ah well, only takes a bit of practice.
07:43:32 <xerox> That is something the error message also want to try to express better it can, I think.  That's why it tells you the line and column numbers, for one.
07:43:32 <dons> the compiler is finding bugs that in other languages won't be found till runtime
07:43:34 <xinming> yes, thanks, I'm doing that.
07:44:00 <xerox> It also give you a lot of context, ``this is happening in the application ... in the expression ... in the expression ...''.
07:44:25 <xerox> Then it tells you what has the wrong type
07:45:03 <xerox> Somebody could write a "walkthrough to the GHC error message" article.
07:45:53 <xerox> Oh, also, the first error is the most important, subsequent errors are to treat only after having solved the first one.  If I understand it correctly.
07:45:56 <spiffy> xerox: there is one for hugs i believe
07:46:16 <spiffy> http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/errors/allErrors.html
07:46:17 <xerox> I never really used hugs :-\  GHCi looked so much better.
07:46:19 <lambdabot> Title: Some common Hugs error messages, http://tinyurl.com/yltnpd
07:46:50 <spiffy> probably some overlap, although im sure other can comment better on that than me
07:47:10 <spiffy> whats the best way to track down an infinite loop?
07:47:14 <xerox> Have you seen GHCi error messages?
07:47:19 <spiffy> no
07:47:22 <spiffy> not lately
07:47:25 <xerox> You should really try that.
07:47:38 <dons> spiffy: an infinite loop can be spotted by compiling with profiling
07:47:52 <spiffy> can hugs do that?
07:47:54 <xerox> Or by the program outputting <<Loop>> :)
07:47:55 <dons> then you inspectt the profiling output and look at what's on top of the call stack
07:47:59 <dons> not hugs, ghc
07:48:08 <dons> really, you'll want ghc to do anything serious in haskell
07:48:15 <spiffy> hmmm looks like ill get to see those error messages :)
07:48:16 <dons> compilation, concurrency, all the extras ...
07:48:35 <dons> > let f = f in f
07:48:35 <xerox> dons, I think I got GHC for learning too, got annoyed of short error messages easily
07:48:36 <lambdabot>  Add a type signature
07:48:40 <dons> > let f = f in f :: ()
07:48:41 <lambdabot>  Exception: <<loop>>
07:48:57 <dons> yeah, you may as well learn with the real thing.
07:49:06 <dons> otherwise you get a hugs-ish impression of the language
07:49:31 <spiffy> d'oh. Found my error. Used < instead of >
07:49:38 <xerox> GHC tells you all!
07:49:50 <spiffy> ill get GHC anyways
07:50:36 <dons> ?users
07:50:36 <lambdabot> Maximum users seen in #haskell: 265, currently: 244 (92.1%), active: 28 (11.5%)
07:50:40 <dons> ?uptime
07:50:42 <lambdabot> uptime: 2d 1h 2m 57s, longest uptime: 6d 23h 44m 3s
07:51:30 <spiffy> Im really starting to get the Haskell way, and im likeing it.
07:51:37 <dons> cool!
07:51:38 <spiffy> My code seems a lot shorter.
07:52:09 <spiffy> Im going to say a lot of that is type classes.
07:52:17 <dons> > fix $ \f -> 1 : 1 : zipWith (+) f (tail f) -- have a complimentary thunk!
07:52:19 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
07:53:01 <spiffy> ha I can even read that!
07:54:02 <spiffy> I think what changed learning haskell for me was learning lisp. Got experience with hof functions, etc. gives a nice base for haskell.
07:54:27 <dons> mm. yes, that would help a lot
07:54:40 <dons> like haskell without the syntax or type system
07:54:48 <dons> so you get the core concepts
07:54:56 <spiffy> Ive been considering writing a short tutorial going from either lisp or javascript to haskell.
07:55:05 <spiffy> Very basic, just to get over a few initial humps.
07:55:05 <dons> so lisp is apparently now a gateway drug to hard core haskell
07:55:16 <spiffy> I think javascript could be too.
07:55:19 <dons> spiffy: that would be cool.
07:55:22 <yaxu> graham hutton's example chapters from programming in haskell really helped me
07:55:26 <dons> have you seen the recent lisp-in-haskell tutorial?
07:55:30 <yaxu> i'm looking forward to being able to buy the rest of it...
07:55:56 <spiffy> dons: I did. I was really impressed. learning Parsec is now on my to-do list.
07:56:24 <yaxu> spiffy: i found learning parsec surprisingly easy after having such a hard time learning haskell
07:56:40 <spiffy> hmmm that would be nice :)
07:57:02 <yaxu> it has good documentation
07:57:04 <spiffy> Im thinking about adding a simple config system based on it to my current project as an excuse to learn it.
07:57:11 <xerox> dons: does that expression expand to a binary tree?
08:04:11 <satan> Any idea why "fn4 as bs = [head bs /  as] ++ fn4 as (tail bs)" gives me:No instance for (Fractional [a]) when i call it?
08:04:47 <Lemmih> satan: 'as' is a list?
08:04:53 <satan> yes
08:05:35 <Lemmih> satan: You're trying to divide a number with a list?
08:05:39 <satan> nm got it
08:05:48 <satan> bah its early
08:06:14 <satan> thanks :)
08:06:47 <chessguy> awww, even i coulda figured that one out if i had seen it quicker
08:22:19 <xerox> ?type (\f -> let y = f y in y)
08:22:19 <lambdabot> forall t. (t -> t) -> t
08:22:22 <xerox> This type is a lie, isn't it?
08:23:05 <jgrimes> doesn't seem like it to me.
08:23:32 <chessguy> (\f -> let y = f y in y) 3
08:23:37 <chessguy> > (\f -> let y = f y in y) 3
08:23:38 <lambdabot>  add an instance declaration for (Num (a -> a))
08:24:03 <xerox> Beside being an obvious lie in the logical interpretation (if "if t, then t", then t), I am not sure why there should be such a type t.
08:24:03 <chessguy> > (\f -> let y = f y in y) (*1)
08:24:05 <lambdabot>  Exception: <<loop>>
08:25:17 <int-e> xerox: fix is not expressible in the typed lambda calculus.
08:26:13 <xerox> Still we have it?
08:26:13 <chessguy> @type fix
08:26:15 <lambdabot> forall a. (a -> a) -> a
08:27:41 <xerox> Anybody knows the papers about this least fixed point idea?
08:28:02 <int-e> fix makes the language turing complete
08:28:14 <psykotic> xerox: (t -> t) -> t implies that any term inhabiting that type must be bottom.
08:29:13 <int-e> > fix (1:) -- really?
08:29:15 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:29:34 <int-e> psykotic: oh, what kind of terms are you talking about?
08:29:59 <psykotic> presumably he was talking about simply typed LC
08:30:13 <xerox> simply?
08:30:17 <psykotic> if he's talking about the CH correspondence
08:30:35 <psykotic> xerox: you have a bunch of base types and a type constructor ->
08:30:40 <psykotic> no polymorphism or anything like that
08:30:51 <xerox> No, I am seeing polymorphism in that type!
08:31:06 <psykotic> oh, right. polymorphism gives you fix.
08:31:21 <psykotic> you can express fix internally in a polymorphic lambda calculus.
08:31:26 <xerox> Oh. How does that work?
08:31:50 <psykotic> at least i think so, let me think for a sec.
08:31:56 <xerox> Thank you.
08:33:46 <psykotic> actually, no, i'm wrong.
08:33:48 * chessguy smells burning rubber
08:34:15 <psykotic> if you have recursive types you can type fix. but in System F the type language is basically simply typed lambda calculus so you can't define recursive types from within System F itself.
08:34:39 <xerox> Ack!
08:34:49 <xerox> Do you know what do we get with System Fc ?
08:35:22 <psykotic> what's the c for?
08:35:40 <jgrimes> type coercions
08:36:22 <jgrimes> http://research.microsoft.com/%7Esimonpj/papers/ext%2Df/
08:36:25 <lambdabot> Title: Simon Peyton Jones: papers, http://tinyurl.com/yfcn5o
08:36:31 <psykotic> as in subtyping?
08:36:50 <psykotic> ah, no, i see
08:37:10 <spiffy> hmmm is GHCi just a dos window on windows?
08:37:17 <spiffy> or is there a "pretty" mode
08:37:37 <jgrimes> also for information about the implementation in GHC: http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/FC
08:37:40 <lambdabot> Title: IntermediateTypes - GHC - Trac, http://tinyurl.com/y76qhn
08:38:15 <Lemmih> spiffy: A console /is/ pretty (:
08:38:41 <xerox> Lemmih: what kind of console?
08:39:03 <spiffy> well, is there a more winhugs like mode for GHCi?
08:39:12 <xerox> Nope.
08:39:29 <spiffy> hmmm.
08:39:52 <spiffy> GHCi emacs mode?
08:40:05 <xerox> Yeah!
08:40:08 <xerox> That works.
08:40:10 <jgrimes> if you use emacs (or are willing to learn) you have have ghci or hugs in a buffer.
08:40:25 <jgrimes> and... you just thought of that. :)
08:40:53 <spiffy> hehe, is there a haskell major/minor mode package aviable?
08:41:11 <xerox> Yes.
08:41:13 <jgrimes> yes indeed.
08:41:16 <xerox> ?where haskell-mode
08:41:17 <lambdabot> http://www.iro.umontreal.ca/~monnier/elisp/
08:41:36 <spiffy> thanks
08:41:43 <psi> http://www-users.cs.york.ac.uk/~ndm/projects/guihaskell.php <- something like winhugs, I guess.
08:41:45 <lambdabot> Title: Neil Mitchell - GuiHaskell, http://tinyurl.com/yd743k
08:41:50 <psi> but it's says it's not finished
08:43:06 <yaxu> how do i stat a file in haskell?
08:43:27 <yaxu> ie find out last modified time
08:45:18 <spiffy> not really a haskell question, but how do I install packages in emacs? (im use to a package manager doing it)
08:45:39 <chessguy> is emacs the most common haskell IDE?
08:45:45 <xerox> chessguy: possibly
08:46:12 <xerox> spiffy: you unpack the tarball somewhere, and then tell emacs to load its main file, and (require ..) what it (provides ..)
08:46:15 <dino-> yaxu: I see some stuff in System.Posix.Files
08:46:15 <yaxu> found it, getModificationTime
08:47:10 <spiffy> cool
08:47:11 <dino-> Ah, System.Directory
08:47:51 <yaxu> yep
08:47:53 <xerox> spiffy: in the case of haskell-mode it provides a site-file, so you can just do, say, "(load "~/Elisp/haskell-mode-2.1/haskell-site-file.el")".
08:48:21 <dino-> Looks like you may possible be able to do it with System.Posix.Files too, like modificationTime :: FileStatus -> EpochTime
08:48:26 <dino-> s/you/it/
08:48:43 <dino-> :o  Can't speak.
08:49:07 <xerox> spiffy: it obviously has got to have some docs, I highly advice you to read that, I might be not in synch with the very latest developments.
09:47:52 <sieni> hmm... I read most of SPJ et al.:s paper about composable memory transactions and got the feeling that Haskell is actually way cooler than I previously thought
09:49:05 <epimorphic> what's the url?
09:52:21 <roconnor> @where STM
09:52:21 <lambdabot> http://research.microsoft.com/Users/simonpj/papers/stm/
09:52:28 <roconnor> epimorphic: there
09:52:35 <epimorphic> thanks!
09:55:38 <Monse> hello, anyone can help me out a little with a piece of code?
09:56:05 <roconnor> maybe
09:56:07 <arjanb> ?paste
09:56:08 <lambdabot> http://paste.lisp.org/new/haskell
09:56:09 <shapr> could be
09:58:33 <Monse> well, first of all, i'm a total newbie, I have read several tutorials and papers, the thing is, I want to make a program that takes two lists and make all the pairs, well I know how I could do it in scheme or something like it, but I'm looking a solution in haskell that would let me remember a list even when it is gone..
09:58:54 <Monse> so, any ideas would be fine.
09:59:01 <xinming> Which module should I load for turning int to string?
09:59:14 <xinming> toString fucntion isn't imported by default.
09:59:25 <jgrimes> > show 22345
09:59:27 <lambdabot>  "22345"
09:59:41 <roconnor> Monse: how would you do it in scheme?
10:00:04 <xinming> thanks.
10:00:06 <xinming> >_<
10:00:14 <jgrimes> xinming, any type that has an instance of the Show class can be "shown" with the show function
10:00:55 <jgrimes> @type show
10:00:57 <lambdabot> forall a. (Show a) => a -> String
10:01:11 <jgrimes> which is basically what that says.
10:01:29 <jgrimes> and show is in the Prelude :)
10:01:36 * roconnor considers forgetting about scheme and showing Monse the monadic solution to the problem.
10:02:07 <Monse> well, I would run through the "cars" of the lists making all the pairs, the thing is that If I got [1,2] [4,5] I would expect [(1,4),(1,5),(2,4),(2,5)] as you see the first number is always the car of the first list but the second number of the pair is like the second list in a circular way?
10:02:33 <roconnor> Monse: in Haskell this problem is most easily solved by list comprehensions
10:02:53 <roconnor> > [(a,b) | a<-[1,2] b<-[4,5]]
10:02:54 <lambdabot>  Parse error
10:02:59 <roconnor> > [(a,b) | a<-[1,2], b<-[4,5]]
10:03:00 <lambdabot>  [(1,4),(1,5),(2,4),(2,5)]
10:03:04 <Monse> yea I know it that way..
10:03:09 <roconnor> ok
10:03:12 <Monse> the thing is I have to implement it
10:03:19 <roconnor> is this an assignment?
10:03:27 <Monse> yea kind of
10:03:49 <roconnor> you should be able to more or less directly translate your scheme code to Haskell code.
10:03:55 <kpreid> Monse: since the comprehension *is* an implementation, you'll have to specify what you want to not use in the implementation
10:04:00 <Monse> All I want to know is a way I can make the second list circular (moving thru it several times without reaching its end)
10:04:05 <kpreid> or, yes, translate your scheme code
10:04:14 <kpreid> > cycle [1,2]
10:04:16 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
10:04:23 <kpreid> you can do it with cycle
10:04:38 <dino-> :t cycle
10:04:41 <pkhuong-> Monse: I just don't see why you want the second list to be circular if you want the cartesian product.
10:04:45 <roconnor> @type cycle
10:04:45 <dino-> ?type cycle
10:04:47 <lambdabot> forall a. [a] -> [a]
10:04:48 <lambdabot> forall a. [a] -> [a]
10:04:53 <shapr> @type type
10:04:54 <xinming> jgrimes: I ever thought I would use toString to show it. :-)
10:04:58 <lambdabot> parse error on input `type'
10:05:29 <Monse> well that was and Idea of how to implement it pkhuong-
10:06:01 <Monse> run thru the first list and pairing them with the cars of the second list
10:06:05 <dino-> Nested loops without the comprehension.
10:06:35 <pkhuong-> Monse: `running through' an infinite list can take a long time.
10:07:11 <roconnor> pkhuong-: I think Monse wants to only cycle one of the lists.
10:07:55 <Monse> yes roconnor, I want to cycle the second list only
10:08:06 <Monse> and finish the module when the first list reaches []
10:08:22 <Monse> that would give me all the pairs.. I think.
10:08:56 <SamB> > zip (1..) (cycle ["fee", "fie", "foe", "fum"])
10:08:57 <lambdabot>  Parse error
10:08:59 <Cale> > sequence [[1,2], [5,6]]
10:09:01 <lambdabot>  [[1,5],[1,6],[2,5],[2,6]]
10:09:06 <Cale> > sequence [[1,2], [3,4], [5,6]]
10:09:08 <lambdabot>  [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
10:09:08 <SamB> > zip [1..] (cycle ["fee", "fie", "foe", "fum"])
10:09:09 <lambdabot>  [(1,"fee"),(2,"fie"),(3,"foe"),(4,"fum"),(5,"fee"),(6,"fie"),(7,"foe"),(8,"f...
10:09:43 <Monse> sequence sounds nice
10:09:47 <kpreid> > (\as bs -> zip (replicate (length bs) as) (cycle bs)) [1,2] [3,4]
10:09:49 <lambdabot>  [([1,2],3),([1,2],4)]
10:10:00 <kpreid> > (\as bs -> zip (concat $ replicate (length bs) as) (cycle bs)) [1,2] [3,4]
10:10:01 <lambdabot>  [(1,3),(2,4),(1,3),(2,4)]
10:10:08 <jgrimes> @fptools Prelude
10:10:08 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
10:10:19 <kpreid> > (\as bs -> zip (concat $ map (replicate (length bs)) as) (cycle bs)) [1,2] [3,4]
10:10:20 <SamB> hmm?
10:10:21 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
10:10:22 <Cale> It works fairly well, but the second list ought to be finite for things to work right. You'd be better off starting with the infinite list, and then flipping the pairs.
10:10:28 <kpreid> > (\as bs -> zip (concatMap (replicate (length bs)) as) (cycle bs)) [1,2] [3,4]
10:10:30 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
10:10:34 <kpreid> there!
10:10:47 <kpreid> a solution involving cycle
10:10:55 <roconnor> :)
10:11:03 <Monse> well that was kind of what I was looking
10:11:28 <kpreid> of course it might as well be
10:11:30 <kpreid> > (\as bs -> zip (concatMap (replicate (length bs)) as) (concat $ replicate (length as) bs)) [1,2] [3,4]
10:11:32 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
10:11:33 <int-e> > sequence [[1..],[1,2]]
10:11:35 <lambdabot>  [[1,1],[1,2],[2,1],[2,2],[3,1],[3,2],[4,1],[4,2],[5,1],[5,2],[6,1],[6,2],[7,...
10:11:38 <Monse> (\as bs -> zip (concatMap (replicate (length bs)) as) (cycle bs)) ['a','b'] ['c','d']
10:11:46 <int-e>  > (\as bs -> zip (concatMap (replicate (length bs)) as) (cycle bs)) [1..] [1,2]
10:11:49 <int-e> > (\as bs -> zip (concatMap (replicate (length bs)) as) (cycle bs)) [1..] [1,2]
10:11:50 <lambdabot>  [(1,1),(1,2),(2,1),(2,2),(3,1),(3,2),(4,1),(4,2),(5,1),(5,2),(6,1),(6,2),(7,...
10:12:11 <Monse> Oh, I thought everyone had access to the bot
10:12:11 <Cale> I like how sequence recasts the Cartesian product computationally
10:12:19 <Cale> Everyone does
10:12:35 <Cale> You have to prefix your expression with "> "
10:12:36 <roconnor> Monse you need the '> ' prefix
10:12:46 <Monse> oh, sorry
10:12:57 <Monse> > (\as bs -> zip (concatMap (replicate (length bs)) as) (cycle bs)) ['a','b'] ['c','d']
10:12:59 <lambdabot>  [('a','c'),('a','d'),('b','c'),('b','d')]
10:13:13 <roconnor> > (\as bs -> map (\(as,b) -> map (,b) as) (map (as,) bs)) [1,2] [3,4]
10:13:14 <lambdabot>  Parse error
10:13:22 <int-e> @run unwords ["This","works","too,","I","think."]
10:13:23 <lambdabot>  "This works too, I think."
10:13:50 <Monse> what I was trying to show you is that when you concat the CHARS I would expect something like ("ac","ad","bc","bd")
10:14:07 <kpreid> Is there a monad which does, er, 'fair' nondeterminism, where even if one subbranch has infinite choices the computation will find the finite answers if there are any?
10:14:21 <roconnor> > (\as bs -> map (\(as,b) -> map (\a -> (a,b)) as) (map (as,) bs)) [1,2] [3,4]
10:14:22 <lambdabot>  Parse error
10:14:28 <kpreid> Monse: tuples of characters aren't strings.
10:14:29 <pkhuong-> kpreid: I think oleg has a page on that.
10:14:55 <jgrimes> yes he does
10:14:58 <roconnor> > (\as bs -> map (\(as,b) -> map (\a -> (a,b)) as) (map (\b -> (as,b)) bs)) [1,2] [3,4]
10:15:00 <lambdabot>  [[(1,3),(2,3)],[(1,4),(2,4)]]
10:15:11 <Monse> yes, I know kpreid.. but I need it to work that way :P
10:15:14 <roconnor> > (\as bs -> concatMap (\(as,b) -> map (\a -> (a,b)) as) (map (\b -> (as,b)) bs)) [1,2] [3,4]
10:15:16 <lambdabot>  [(1,3),(2,3),(1,4),(2,4)]
10:15:27 <Monse> It is all cool with numbers
10:15:29 <roconnor> @pl (\as bs -> concatMap (\(as,b) -> map (\a -> (a,b)) as) (map (\b -> (as,b)) bs))
10:15:30 <lambdabot> (((map =<< flip (,)) . snd =<<) .) . map . (,)
10:15:36 <roconnor> ah perfect
10:15:38 <kpreid> Monse: don't use zip then:
10:15:47 <kpreid> > zip ['a'] ['b']
10:15:48 <lambdabot>  [('a','b')]
10:15:49 <roconnor> (((map =<< flip (,)) . snd =<<) .) . map . (,) [1,2] [3,4]
10:15:51 <pkhuong-> kpreid: http://okmij.org/ftp/Computation/monads.html#LogicT and the one after.
10:15:53 <lambdabot> Title: Monads, http://tinyurl.com/kdhqf
10:15:54 <kpreid> > zipWith (\x y -> [x,y]) ['a'] ['b']
10:15:54 <roconnor> > (((map =<< flip (,)) . snd =<<) .) . map . (,) [1,2] [3,4]
10:15:55 <lambdabot>  ["ab"]
10:15:57 <lambdabot>    Expecting a function type, but found `(a, b)'
10:15:57 <lambdabot>    Expected type: a1 ->...
10:16:06 <kpreid> Monse: use (zipWith (\x y -> [x,y])) instead.
10:16:06 <roconnor> > ((((map =<< flip (,)) . snd =<<) .) . map . (,)) [1,2] [3,4]
10:16:07 <lambdabot>  add an instance declaration for (Num [a])
10:16:08 <lambdabot>   In the list element: 4
10:16:12 <kpreid> @pl (\x y -> [x,y])
10:16:12 <lambdabot> (. return) . (:)
10:16:16 <Monse> well, I figured a solution yesterday
10:16:18 <kpreid> (eq)
10:16:20 <kpreid> (ew)
10:16:20 <int-e> > transpose ["abc", "bde"]
10:16:21 <lambdabot>  ["ab","bd","ce"]
10:16:53 <chessguy> > zipWith (++) ["abc", "bde"]
10:16:54 <lambdabot>  <[[Char]] -> [[Char]]>
10:17:00 <Monse> > [[a,b] | a<-['a','b'], b<-['c','d']]
10:17:02 <lambdabot>  ["ac","ad","bc","bd"]
10:17:07 <kpreid> > transpose ["ab", "cde"]
10:17:07 <Monse> that way
10:17:08 <lambdabot>  ["ac","bd","e"]
10:17:11 <roconnor> @type (((map =<< flip (,)) . snd =<<) .) . map . (,)
10:17:12 <chessguy> what the heck is that message?
10:17:12 <lambdabot> forall a a1. a1 -> [[a]] -> [(a, [a])]
10:17:30 <roconnor> @type (\as bs -> concatMap (\(as,b) -> map (\a -> (a,b)) as) (map (\b -> (as,b)) bs))
10:17:32 <lambdabot> forall a a1. [a] -> [a1] -> [(a, a1)]
10:17:39 <roconnor> @pl (\as bs -> concatMap (\(as,b) -> map (\a -> (a,b)) as) (map (\b -> (as,b)) bs))
10:17:40 <lambdabot> (((map =<< flip (,)) . snd =<<) .) . map . (,)
10:17:47 <roconnor> um?
10:17:52 <roconnor> wtf?
10:17:54 <chessguy> > zipWith (++) (head ["abc", "bde"]) ( tail ["abc", "bde"])
10:17:55 <lambdabot>  Couldn't match `[a]' against `Char'
10:18:01 <Monse> omg my head is going crazy hehe
10:18:09 <roconnor> @. type pl (\as bs -> concatMap (\(as,b) -> map (\a -> (a,b)) as) (map (\b -> (as,b)) bs))
10:18:12 <lambdabot> forall a a1. a1 -> [[a]] -> [(a, [a])]
10:18:16 <int-e> (=<<) = concatMap
10:18:21 <roconnor> @type (\as bs -> concatMap (\(as,b) -> map (\a -> (a,b)) as) (map (\b -> (as,b)) bs))
10:18:23 <lambdabot> forall a a1. [a] -> [a1] -> [(a, a1)]
10:18:43 <roconnor> why is pl changing the type of my function?
10:18:59 <xerox> pl is untyped
10:19:12 <xerox> (and doesn't understand all the syntax)
10:19:14 <int-e> cse
10:19:24 <roconnor> why is pl changing the semantics of my function?
10:19:29 <int-e> it does CSE.
10:19:35 <int-e> and it's untyped.
10:19:37 <xerox> cool.
10:19:46 <xerox> and how does cse affect typing?
10:19:48 <Monse> Ok, well code for numbers seems to work fine, but what about chars as I told you?
10:19:49 <roconnor> why does CSE change the semantics of my function?
10:20:06 <int-e> because terms aren't usually polymorphic
10:20:27 <Cale> Monse: hm?
10:20:29 <xerox> uhm.
10:20:38 <int-e> I'm sure your two  (map (\b -> (*,b))  have different types there.
10:20:50 <Monse> is there a way to know when I'm receiving chars in a list so I can call: [[a,b] | a<-['a','b'], b<-['c','d']] and when they are numbers I can call (\as bs -> zip (concatMap (replicate (length bs)) as) (cycle bs)) ['a','b'] ['c','d'] ?
10:20:50 <int-e> and I think @pl unified them.
10:21:13 <roconnor> oh
10:21:16 <Cale> Monse: You could use a typeclass
10:21:47 <Monse> well Cale if you got a nice paper on that I would really appreciate it
10:21:59 <Cale> um... I could get you one
10:22:13 <Monse> or any other easy solution besides mine guys?
10:22:46 <Cale> Basically, the idea with typeclasses is that you define a class, which is essentially a predicate on types, together with some functionality wherever that predicate holds. In this case, you could do something like:
10:22:49 <Monse> because I really need it to print ["ac","ad","bc","bd"] when the lists are chars..
10:23:04 <Monse> Ok Cale
10:23:29 <Cale> Oh, right, so you actually want to change the type of the result structurally...
10:23:40 <Monse> yes
10:23:51 <Cale> That's doable with typeclasses, but uses a bit more machinery than was available in Haskell 98
10:24:09 <Cale> I suppose you could do it something like...
10:24:20 <Cale> class Munge a b | a -> b where
10:24:39 <Cale>    munge :: [a] -> [a] -> [b]
10:24:56 <Cale> instance Munge Char [Char] where
10:25:02 <Cale>    munge = ...
10:25:19 <Cale> instance Munge Integer (Integer, Integer) where
10:25:24 <Cale>    munge = ...
10:25:52 <Monse> umm
10:26:01 <Cale> the "| a -> b" bit is called a functional dependency, and means that b is uniquely determined by a for purposes of type inference
10:26:09 <int-e> heavy machinery to allow confusing code :/
10:26:15 <Cale> yeah
10:26:27 <Cale> It would be better to pick one type and stick with it
10:27:02 <Monse> :S
10:27:05 <Cale> so if you want to return a list of strings in the Char case, you should probably return a list of lists of integers in the integer case
10:27:38 <Cale> then you don't need confusing levels of polymorphism
10:27:53 <Codex_> if you have instance Munge Char [Char], you couldnt do instance Munge Char (Char, Char) ?
10:28:08 <Cale> Codex_: right, because of the functional dependency
10:28:13 <Codex_> because of the "uniquely determined by" thing
10:28:31 <int-e> Codex_: you could try and the compiler will bark at you for trying
10:28:36 <Cale> You could if that "| a -> b" was missing, but the function would be annoying to use
10:29:13 <Cale> because it would be very easy to have ambiguities where the compiler doesn't know which one to pick, and you end up having to annotate things
10:29:28 <Monse> ummm
10:29:35 <Monse> I have a little problem
10:29:42 <Monse> -> Haskell 98 does not support dependent parameters
10:30:00 <Cale> right
10:30:25 <Cale> Well, just always return lists of lists then -- is there any need to return proper pairs?
10:30:41 <int-e> you can also have two functions
10:30:42 <Cale> munge xs ys = sequence [xs, ys]
10:30:50 <Cale> or sure, have two functions
10:30:52 <Monse> umm
10:31:06 <int-e> . o O ( munge2 = liftM2 (,) )
10:31:20 <int-e> + a type signature
10:31:49 <Cale> > liftM2 (,) [1..3] [4..6]
10:31:50 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
10:32:01 <Monse> what is liftM2?
10:32:10 <Monse> Oh I see..
10:32:30 <chessguy> cross product
10:32:41 <Monse> > liftM2 (,) ['a'..'b'] ['c'..'d']
10:32:43 <lambdabot>  [('a','c'),('a','d'),('b','c'),('b','d')]
10:32:55 <Monse> > liftM2 () ['a'..'b'] ['c'..'d']
10:32:56 <lambdabot>    Expecting a function type, but found `()'
10:32:56 <lambdabot>    Expected type: a1 -> a2 ...
10:33:01 <Monse> umm
10:33:08 <Cale> > liftM2 (\x y -> [x,y]) ['a'..'b'] ['c'..'d']
10:33:10 <lambdabot>  ["ac","ad","bc","bd"]
10:33:14 <int-e> liftM2 works for pretty much the same reason as sequence.
10:33:50 <Monse> nice :D
10:34:20 <Monse> liftM2 (\x y -> [x,y]) [1..2] [3..4]
10:34:29 <Monse> > liftM2 (\x y -> [x,y]) [1..2] [3..4]
10:34:29 <Cale> > liftM2 (\x y -> [x,y]) [1..2] [3..4]
10:34:30 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
10:34:31 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
10:34:38 <Monse> thats it!
10:35:22 <jcreigh> 10\{10{100}\} (Googolplex, twice RLE'd)
10:35:41 <Monse> liftM2 is in the prelude?
10:35:55 <Cale> Control.Monad
10:35:58 <int-e> @index liftM2
10:35:58 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
10:37:01 <Monse> I see
10:37:53 <Monse> thats the problem..
10:37:59 <Monse> I can't use that
10:38:08 <Cale> Or just "Monad" if you're using Haskell98
10:38:45 <Monse> yes, I mean, I can't use anything that it is not in the prelude
10:39:07 <Monse> I am supposed to implement something using maybe map and that kind of functions..
10:39:27 <Cale> > let f xs ys = [[x,y] | x <- xs, y <- ys] in f [1..3] [4..7]
10:39:28 <lambdabot>  [[1,4],[1,5],[1,6],[1,7],[2,4],[2,5],[2,6],[2,7],[3,4],[3,5],[3,6],[3,7]]
10:39:40 <Cale> > let f xs ys = [[x,y] | x <- xs, y <- ys] in f ['a'..'c'] ['d'..'f]
10:39:41 <lambdabot>  Improperly terminated character constant
10:39:42 <Cale> > let f xs ys = [[x,y] | x <- xs, y <- ys] in f ['a'..'c'] ['d'..'f']
10:39:44 <lambdabot>  ["ad","ae","af","bd","be","bf","cd","ce","cf"]
10:40:02 <Monse> omg
10:40:07 <Cale> and if you don't want list comprehensions, it's possible to rewrite that in terms of concatMap
10:40:19 <Monse> how much time have you being doing haskell?
10:40:27 <Cale> couple of years
10:40:29 <monochrom> 10 years
10:40:41 <Monse> umm hehe
10:40:46 <Monse> this is my second day.. lol
10:40:51 <Cale> I could have done all this over a year ago though :)
10:40:57 <monochrom> http://www.norvig.com/21-days.html
10:40:58 <lambdabot> Title: Teach Yourself Programming in Ten Years
10:41:07 <Cale> Including the sequence and liftM2 trick :)
10:41:07 <Monse> hehe
10:41:17 <Monse> what about the second day?
10:41:33 <Cale> List comprehensions I pretty much understood after a week or so :)
10:41:38 <monochrom> I took a vacation on the second day.
10:41:39 <Monse> I did [[a,b] | a<-['a','b'], b<-['c','d']] hehe
10:41:45 <Cale> hehe
10:41:56 <Monse> hehe
10:42:04 <monochrom> Oh list comprehension is trivial.  30 minutes.
10:42:15 <Monse> yes
10:42:34 <Cale> Yeah, it doesn't take long to understand that, and then learn how it translates into prelude functions
10:42:35 <Monse> thing was adding the let f xs ys
10:42:43 <pkhuong-> Cale: I must be one of the weird few who understand do-notation but nothing else ;) Ok I lie, I can read pidgin haskell because of all the papers.
10:42:44 <Cale> Oh, that's just to make it an expression
10:43:06 <Monse> yes :D
10:43:08 <Cale> pkhuong-: hehe, I want monad comprehensions back :)
10:43:18 <monochrom> Everything in Haskell can be done in the do-notation.
10:43:33 <pkhuong-> Cale: it's gone!?
10:43:40 <Cale> > let f xs ys = do { x <- xs; y <- ys; return [xs, ys] }
10:43:41 <lambdabot>  Parse error
10:43:50 <Cale> > let f xs ys = do { x <- xs; y <- ys; return [xs, ys] } in f [1..3] [4..6]
10:43:52 <lambdabot>  [[[1,2,3],[4,5,6]],[[1,2,3],[4,5,6]],[[1,2,3],[4,5,6]],[[1,2,3],[4,5,6]],[[1...
10:44:07 <Cale> > let f xs ys = do { x <- xs; y <- ys; return [x, y] } in f [1..3] [4..6]
10:44:09 <lambdabot>  [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
10:44:12 <Cale> oops :)
10:44:12 <Monse> ok slow down guys hehe
10:44:21 <Cale> pkhuong-: yeah, went with H98
10:44:46 <pkhuong-> damn, I'll have to hack that into the CL reader, just to spite you guys ;)
10:44:48 <Cale> pkhuong-: Some people on the Haskell committee hated polymorphism
10:44:58 <Monse> ok, back to my situation
10:45:10 <Monse> If I use let f xs ys = [[x,y] | x <- xs, y <- ys] in f ['1'..'3'] ['4'..'5']
10:45:13 <Monse> > let f xs ys = [[x,y] | x <- xs, y <- ys] in f ['1'..'3'] ['4'..'5']
10:45:14 <lambdabot>  ["14","15","24","25","34","35"]
10:45:18 <Monse> :(
10:45:35 <Cale> Monse: they're strings, because you're passing in characters
10:45:42 <Cale> a list of characters is a string
10:46:21 <Monse> oh right
10:46:23 <Monse> lol
10:47:33 <Monse> sorry =)
10:48:13 <Monse> brb guys ty
11:02:53 <pejo> Cale, didn't monad comprehensions give confusing error messages for the 'average case'?
11:04:15 <dcoutts> and once you have do notation there's less demand for monad comprehensions
11:05:56 <Cale> pejo: Not if you understand monads. I also don't consider confusing error messages a reasonable reason for removing a good feature, I consider it a reason to improve error messages :)
11:07:54 <pejo> Cale, well, show some consideration for us poor programmers who don't understand monads, lazy evaluation, or anything else!
11:07:56 <pejo> ;)
11:08:35 <Cale> I actually think monad comprehensions provide a good alternate view for learning monads
11:08:43 <Philippa> Cale: that only really works on the basis that there's a known way to improve the error messages
11:08:59 <Philippa> if not, it's not such a good idea
11:09:51 <jgrimes> Now I'm interested... where is some literature on monad comprehensions?
11:12:05 <Monse> hi guys, i'm back
11:12:43 <Monse> well, now my next step is making that let f xs ys.. a function, here is my idea:
11:12:50 <Monse> pairs :: [a] -> [a] -> [b]
11:12:52 <Monse> pairs xs ys = [[x,y] | x <- xs, y <- ys]
11:13:02 <monochrom> poor programmers may use C
11:13:24 <mauke> Monse: the type looks wrong
11:14:11 <Monse> mm indeed it is wrong
11:14:13 <Philippa> speaking of poor programmers, my (as in, owned by me - borrowed the crap lappy I'm on off my dad) only comp at the moment's a Zaurus. Admittedly, this means I own a Zaurus.
11:14:42 <Monse> pairs :: [a] -> [a] -> [[a]]
11:14:44 <Monse> pairs xs ys = [[x,y] | x <- xs, y <- ys]
11:14:54 <lOkadin> does lambda bot extend easily?
11:15:26 <Monse> I think thats the correct way to do it, am I wrong?
11:15:26 <pkhuong-> Philippa: does it have VGA out? You can already ssh, you can't be that poor :p
11:15:34 <mauke> Monse: try it :-)
11:15:40 <lOkadin> hmmm, i'll go try and compile it
11:15:46 <Monse> I did, and it worked
11:15:59 <lOkadin> @url lambdabot
11:16:00 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
11:16:14 <Monse> how would you define this type? [[a]]
11:16:17 <Monse> list of list?
11:16:26 <ski> list of list of a
11:17:16 <Philippa> pkhuong: nope. The screen's great for casual use and I'd probably be happy reading papers on it. Not got a suitable machine to SSH to atm
11:17:24 <Philippa> it's going to take me a while to get things like IRC clients built
11:17:32 <Philippa> as it doesn't ship with GCC
11:17:36 <Monse> I tried this yesterday and I don't know why it didnt worked hehe
11:19:16 <Monse> well, ty very much guys
11:19:47 <monochrom> [[a]] is list of list of a.  example: [ [1], [0,2], [] ]  is [[Int]]
11:20:08 <mauke> ITYM (Num a) => [[a]]
11:20:51 <monochrom> Oh bother.  I hate numbers.
11:20:52 <Monse> :o
11:21:01 <Monse> ok
11:21:33 <Cale> hehe
11:21:45 <Cale> See, this is why we have to teach typeclasses right away
11:22:06 * Maddas read that as 'typing classes'
11:22:13 <Cale> Numbers require polymorphism, why can't comprehensions? :)
11:22:17 <Cale> hehe
11:22:54 <monochrom> OH!  "poor" error messages aren't poor if every kindergarten kid knows typing classes!
11:23:05 <int-e> Then people would meet comprehensions with incomprehension.
11:24:31 <int-e> I wonder if Cale wants [1,2,3] to mean return 1 `mplus` return 2 `mplus` return 3 `mplus` mzero
11:24:35 <mauke> mmh, monad incomprehensions
11:24:49 <monochrom> Heh heh heh, fractional and negative fixities.
11:25:03 <int-e> @type return 1 `mplus` return 2 `mplus` return 3 `mplus` mzero
11:25:05 <lambdabot> forall (m :: * -> *) a. (Num a, MonadPlus m) => m a
11:25:18 <ski> no, plain relative fixities, not numbers !
11:25:35 <monochrom> I mean Finally!  Someone realizes that you need a dense lattice!
11:25:56 <monochrom> Yeah, alternatively relative partial fixities.
11:26:08 <ski> partial ?
11:26:10 <mauke> @type foldr id undefined (return 1 `mplus` return 2 `mplus` return 3 `mplus` mzero)
11:26:10 <int-e> but look at the grammar in the report ... you need to change the whole language!!!1
11:26:11 <lambdabot> forall a. (Num (a -> a)) => a
11:27:23 <monochrom> This actually bothers me.  After 10 years of suffering line-numbered BASIC and 20 years of denouncing it, people still think using natural numbers for fixities makes sense.
11:27:52 <int-e> anyway I'm happier with fractional fixities than I was with automatic fixity assignment to satisfy the needs of some editor.
11:28:10 <int-e> but I can't say they're needed.
11:28:13 <ski> monochrom : yes
11:30:15 <monochrom> Godawful Dark Age.
11:30:19 <xerox> monochrom: fixity means arity?
11:30:33 <ski> infixl 6 +
11:30:44 <int-e> fractional arities?!
11:30:48 * int-e glares at xerox 
11:30:57 <monochrom> fixity means operator precedence.
11:31:04 <int-e> that's not what partial application means.
11:31:25 <monochrom> If you have experienced line-numbered BASIC or Fortran you know the problem.
11:32:23 * ski has
11:32:49 <monochrom> If you have studied lattice theory or analysis you know the solution. :)
11:33:07 <int-e> actually
11:33:12 <int-e> you mean precedence :)
11:33:43 <ski> doesn't fixity include precedence ?
11:34:19 <monochrom> I now realize.
11:34:39 <int-e> yes, but it also includes associativity which isn't a number
11:34:45 <ski> m
11:35:01 <monochrom> We have been talking about just the precedence part.
11:35:14 <int-e> but fractional arity really cracked me up :)
11:35:15 * ski has pondered some on decoupling the left- and right- precedence of an infix operator
11:35:21 <monochrom> Somehow using Haskell too much caused me to forget the word "precedence".
11:35:41 <monochrom> Wow that's crazy!
11:36:01 <ski> why ?
11:36:02 <monochrom> I'm sure now the Schemers are all laughing at us.
11:36:25 <ski> isn't lambda like this ?
11:36:40 <ski> hm
11:36:57 <int-e> well, scheme has no syntax whatsoever, so of course they have no syntax trouble.
11:36:59 <pkhuong-> monochrom: more like being reminded of C++.
11:37:51 <monochrom> More reason they laugh at us.  "I told you so - you shouldn't have syntax in the first place!"
11:37:57 <int-e> I know that to a lisp thinking mind that's a virtue but I never quite got there.
11:38:00 <ibid> scheme does have syntax, and it's the chief reason why i don't write stuff in it
11:38:48 <mauke> scheme's syntax is optimized for the parser
11:38:59 <ibid> no it isn't
11:39:03 <integral> Or structured editor
11:39:19 <ibid> the lisp syntax is an accident, historically
11:39:23 <monochrom> scheme's syntax is optimized for intelligence
11:39:35 <mauke> monochrom: I'd say it's the opposite
11:39:55 <monochrom> "the ability to perform computer functions"
11:39:56 <therp> ibid: enjoy http://clemens.endorphin.org/liskell.png
11:40:43 <ibid> bah
11:40:55 <integral> That's a hacked GHC?
11:41:29 <therp> integral: positive. and since today this thing has a meta programming facility and tomorrow it will be easy to use :)
11:41:53 <therp> I'm just too tired to code it today :)
11:41:55 <integral> Different from Template Haskell, or just easier to use?
11:41:56 <pkhuong-> therp: nice.
11:42:01 <ibid> the lisp syntax was actually an abstract syntax that was used because nobody got around to defining the "real" lisp syntax until all lispers had embraced the dark side :)
11:42:24 <Adamant> Liskell sounds cooool
11:42:27 <mauke> it shows
11:43:28 <therp> integral: well, not that different. Liskell macros will be a parse tree transformer, that thanks to instances and type classes should be quite easy to write, without the need for bracket ala template haskell
11:43:38 <integral> neat :)
11:44:12 <therp> integral: and the ultimate plan is to make macros invisible. the thing I don't like in TH is that you always see it's TH. you don't embrase it as new programming language construct
11:44:14 <monochrom> How do you do pattern matching?
11:44:37 <therp> monochrom: http://clemens.endorphin.org/Factorial.lsk - the file is quite different from the screen shot, this compiles yes
11:45:06 <therp> adamant: I plan to write a paper for ILC07 about it, but well, I have to finish coding first.
11:45:14 <Igloo> therp: Compiles as standard Haskell without cpp?
11:45:34 <therp> igloo: yes, precisely
11:45:44 <Adamant> therp - good luck. looks fun.
11:46:02 <Adamant> therp, can you add types?
11:46:15 <Adamant> type declarations, I mean
11:46:31 <therp> igloo: the problem I fighted with yesterday (and the two days before) was originating from the macro facility, but now it works fine. I've just written Common Lisp "cond" as Liskell macro that expands to a series of if-s
11:46:56 <Adamant> ah, now I see.
11:47:03 <therp> adamant: yes, look at the Factorial.lsk file. you can define classes, data type, new types, type synonyms .. the whole arsenal
11:47:31 <kpreid> If "f \x -> g" were allowed, then \...-> would be like an operator with high left-precedence and low right-precedence.
11:47:37 <kpreid> Er.
11:47:43 <Igloo> therp: Hmm, having looked closer, I'm sure there are things in there that aren't valid Haskell syntax
11:47:44 <kpreid> I just replied to scrollback.
11:47:50 <therp> adamant: but I'm not sure if all the syntax will stay that way. I'm not convinced about everything in this file.
11:48:30 <integral> Igloo: I asked above: therp's modified the compiler
11:48:33 <therp> igloo: maybe. the compiler doesn't mind :)
11:48:38 <Adamant> therp, I like it already. I'm sure any changes will be for the better
11:49:52 <therp> adamant: thanks :) - and it's so much fun coding. except the 2 days with the FastString interning bug, but that's life .. err a programmers life :)
11:50:06 <Adamant> I bet!
11:50:53 <monochrom> A Bug's Life?
11:51:12 <kpreid> therp: what's >?
11:51:24 <kpreid> therp: is it =>?
11:51:47 <therp> kpreid: a type context, yes
11:51:50 <ski> kpreid : or you could see '\...->' as a prefix operator that from the inside (i.e. right) binds weakly, but from the outside binds strongly (so it looks like an atomic expression)
11:52:23 <kpreid> ski: but the inside and outside are determined by the precedence, not vice versa
11:52:43 <therp> kpreid: I might change it to something more readable. that's the thing I like least. I think I will change it to "=>"
11:53:02 <therp> paying tribute to the Haskell heritage :)
11:53:05 <ski> kpreid : yes ..
11:53:09 <kpreid> therp: overall, I approve of the experiment :)
11:53:31 <therp> kpreid: coding that was 100% experiment :)
11:53:32 <kpreid> therp: the ugliest bit is 'deftypesig'
11:53:40 <ski> yes
11:53:46 <ski> why 'def' at all there ?
11:53:50 <ski> it's not a definition
11:54:02 <therp> kpreid: yes that's ugly too, any other suggestions :)
11:54:12 <ski> plain 'typesig' ?
11:54:18 <kpreid> well, just having top-level (:: ...) comes to mind
11:54:20 <ski> or '::' ?
11:55:00 <kpreid> therp: how does (define l (: 1 2 3 4)) work?
11:55:07 <therp> hm, I rather like words for that. but hm, I don't mind
11:55:48 <therp> kpreid: that's only an explicit list. it's not the thing you know as :. it was a glitch in my mind that I didn't chose [] for that. will be changed tomorrow I guess.
11:55:59 <kpreid> ah
11:56:06 <monochrom> Everything is a definition.  0=1 is the most famous definition.
11:56:29 <kpreid> therp: ((f 1) 2) == (f 1 2)?
11:56:44 <therp> kpreid: as I said, that's not the final version. It still poke it so that it can glide into its true shape :)
11:56:52 <therp> krpeid: correct
11:57:55 <therp> kpreid: if the first element of a parenthesized list is not special than it a regular left associative application
11:58:01 <ski> so '[]' would be a keyword, then ?
11:58:08 <therp> s/than it/then it's/
11:58:15 <ski> ok
11:58:38 <therp> ski: yes, but not in terms of special parser keyword. the whole thing is parsetree to parsetree translated and the translater recognizes this stuff
11:59:02 <pkhuong-> therp: re macros, do you think quasiquotation-style operators would be doable?
11:59:13 <xerox> (, 1 2) yuck.
11:59:34 <ski> therp : i meant like 'define' and 'let' and macros are keywords
11:59:43 <therp> pkhuong: I hope I don't need such things, because building Liskell code with lists and symbols is quite easy
12:00:31 <therp> ski: yes, in that sense '[]' is a keyword. for types it results in List type and for expressions it results in an explicit list (or will result tomorrow when I change it)
12:00:53 <ski> why would it be a keyword for types ?
12:01:04 <therp> but please give me a few days to prepare a paper about that. I hope that will answer most of the questions and reveal the true sense of doing this experiment :)
12:01:32 <ski> also i'm wondering about the '>' in the 'defclass'
12:02:18 <therp> ski: because GHC does not construct List/Tuple types as it constructs user defined types, therefore the parsetree converter has to handle it seperately to make it work for the GHC backeneds
12:02:20 <kpreid> in the definstance? that's just "instance () => Bar Integer" I assume
12:02:37 <ski> no, 'defclass' i meant
12:02:38 <therp> kpreid: right, I still have to code an abbriviation for that
12:02:51 <ski> i also wonder why it is like that in haskell
12:03:01 <kpreid> I see a -> function arrow in the defclass, but no >
12:03:19 <therp> ski: that's only the superclass list. thing of ">" as "=>"
12:03:25 <ski> (defclass (> ((Show a)) (Foo a))
12:03:28 <ski>   ...)
12:03:31 <ski> yes
12:03:32 <xerox> What is '>' ?
12:03:38 <kpreid> oh, I missed that
12:03:50 <xerox> Oh, you just explained that, sorry.
12:03:53 <ski> but i wonder why it is '=>' in haskell 'class' declarations
12:04:07 <therp> ski: super classes
12:04:19 <xerox> int-e: I never tweaked fixities, do anything useful come from that?
12:04:25 <monochrom> logical implication
12:04:30 <ski> yes, but the direction of the '=>' always seemed counter-intuitive, to me
12:04:37 <ski> foo :: Bar a => Baz b
12:04:39 <xerox> Another example of entail!
12:04:41 <ski> can be read as
12:04:48 <ski> Bar a => foo :: Baz b
12:04:54 <dcoutts> noooo!
12:04:56 <xerox> a \in Bar => Baz b
12:05:03 <ski> i.e., if 'a' is in 'Bar', then 'foo' has type 'Baz b'
12:05:06 <ski> s/b/a/
12:05:09 <xerox> Yes! (:
12:05:22 <ski> and
12:05:28 <int-e> xerox: sure. for example a left associative (++) would be more inefficient than a right associative one.
12:05:35 <ski> instance Eq a => Eq (Maybe a)
12:05:37 <edwardk_> ski: yeah
12:05:54 <ski> is read as, if 'a' is in 'Eq', then 'Maybe a' is in 'Eq'
12:06:02 <ski> but
12:06:08 <ski> class Eq a => Ord a
12:06:10 <monochrom> aEq  Maybe a  Eq
12:06:12 <int-e> xerox: and I hope I don't need to explain why having different precedences is useful. oh, a right associative division would be confusing ;)
12:06:13 <dcoutts> xerox, in a pretty printing library, what should the priorities of <> and $$ be ?
12:06:15 <xerox> int-e: how does associativity depend on fixity?
12:06:23 <ski> "if 'a' is in 'Eq' then 'a' is in 'Ord'" ???
12:06:28 <ski> it just seems wrong
12:06:31 <xerox> dcoutts, I never used a pretty printing library :(
12:06:41 <dcoutts> xerox, people want to be able to say: text "foo" <> bar $$ baz
12:06:50 <xerox> What does that mean?
12:06:55 <monochrom> "class Eq a => Ord a"  is just to maintain the parallel with "instance Eq Int => Ord Int"
12:06:57 <Igloo> dcoutts: <> should bind tighter
12:06:58 <edwardk_> ski: the instance => seems to run the wrong way =)
12:07:07 <dcoutts> xerox, Igloo's right.
12:07:10 <ski> edwardk_ : no, the 'class' '=>', imo
12:07:23 <int-e> xerox: hmm. I've been using fixity for 'precedence and associativity'.
12:07:23 <edwardk_> er class one
12:07:27 <edwardk_> you're right
12:07:31 <ski> monochrom : i don't see a parallel
12:07:44 <int-e> xerox: which is technically wrong
12:07:47 <monochrom> notational parallel.
12:07:50 <edwardk_> should be class Ord a <: Eq a or something
12:07:54 <int-e> xerox: sorry
12:08:02 <edwardk_> they even commented on it in some early paper
12:08:08 <dcoutts> xerox, you want <> (which is horizontal cat) to bind tighter than $$ (vertical cat)
12:08:12 <ski> "if 'a' is in 'Ord', then 'a' is in 'Eq'" is true
12:08:26 <dcoutts> xerox, because we often lay many things out on one line
12:08:26 <ski> since to declare instance of 'Ord' you must have declared instance of 'Eq'
12:08:41 <ski> so, it seems to me the other direction works fine
12:08:49 <monochrom> Do not try to "understand" "class Eq a => Ord a".  Try to understand "instance Eq a => Eq (Maybe a)", then just copy the notation for class.
12:08:56 <xerox> int-e: if I understand correctly, using fixity declarations you can avoid the use of parenthesis.
12:09:10 <xerox> dcoutts, sorry, "cat" ?
12:09:13 <ski> edwardk_ : i guess one could use '<:' .. but i think implication would work nice, too
12:09:24 <edwardk_> monochrom: sure, i've just been collecting better notations and that one always bugged me =)
12:09:30 <dcoutts> xerox, horazontal and vertical concatenation
12:09:56 <dcoutts> Igloo, I discovered to my cost how important this is yesterday. I redefined $$ and $+$ locally to mean the right things but forgot to set their fixity.
12:09:59 <int-e> xerox: actually the infix* declarations have nothing to do with fixity. they declare the associativity and precedence of an infix operator
12:10:02 <monochrom> Existential types use the notation "forall".
12:10:07 <ski> monochrom : but i can't refrain from trying to understand !
12:10:12 <xerox> dcoutts, ah, I see. And then, depending on the context, it (shows and?) concatenates the value with a certain connector, like ", " or whatever else?
12:10:20 <Igloo> heh
12:10:20 <ski> monochrom : that is intuitive
12:10:28 <xerox> int-e: what is fixity?
12:10:39 <monochrom> Everything is intuitive.  Just change intuition.
12:10:41 <int-e> xerox: they do not affect  prefix operators (normal functions), or postfix operators (uh, none I can think of)
12:10:51 <int-e> xerox: *that's* fixity.
12:11:04 <ski> monochrom : if you wrote the keyword after the constructor .. it should be 'exists'
12:11:06 <monochrom> I find "class ... => ..." very intuitive.  I have just explained the intuition.
12:11:44 <monochrom> Very few people have programmable intuition.
12:11:59 <ski> monochrom : where ?
12:12:02 <int-e> xerox: so do you mean associativity (left, none, right) or precedence?
12:12:13 <monochrom> Try to understand "instance Eq a => Eq (Maybe a)", then just copy the notation for class.
12:12:22 <monochrom> That's the intuition.
12:12:24 <ski> :resize 50
12:12:26 <ski> er
12:12:33 <xerox> int-e: I don't mean anything, trying to understand what people were talking about.
12:13:00 <int-e> xerox: precedence mainly, I think. But I didn't follow some parts of the discussion
12:13:13 <ski> (i don't see how just copying to a differenti situation is intuition ..)
12:13:28 <monochrom> haha you're too smart
12:13:31 <Philippa> monochrom: in my experience many people have programmable intuition, it's a matter of having been exposed to the right intuitions for long enough for them to be programmed in
12:14:00 <monochrom> Yeah I lied.  Most people have programmable intuition.  Just repeat ad nauseum.
12:14:27 <int-e> intuitively, I'd say that people have programmable intuition ...
12:14:30 * int-e grins broadly.
12:16:17 <monochrom> This is proven in classrooms.  If you rephrase an assertion a million ways (this is not describing a million different perspectives), students believe you and also comment "you're very insightful, helpful, intuitive".
12:16:38 <monochrom> An assertion rephrased a million times becomes a truth.
12:16:48 <int-e> xerox: anyway if you'd come up with an operator that you want to mix with + and * and that binds stronger than + but weaker than *, that wouldn't be possible in Haskell, because there is no precedence available between that assigned to + (6) and that assigned to * (7). That's the discussion, they want to be able to assign a fixity of 6.5.
12:17:34 <xerox> Wow.
12:17:37 <int-e> monochrom: right, the trick is to avoid seeming too repetititive.
12:18:08 <monochrom> Yeah of course, need to keep them listening.
12:18:09 <jgrimes> awww, lispy is using 64-bit registers in helisp
12:18:10 <jgrimes> =/
12:18:12 <int-e> xerox: darn. note that where I wrote 'fixity' I meant 'precedence'.
12:18:34 <monochrom> In the old camp you tie down the student so you can just repeat and he/she must listen.
12:18:53 <xerox> int-e: hehe
12:18:56 <monochrom> That is called brainwashing.
12:19:13 <monochrom> In the new camp you have to pretend to be ethical.
12:19:43 <xerox> You are seeming to imply that students will not *think* about what you say.
12:19:43 <int-e> make your pupils like being brainwashed ;)
12:20:03 <monochrom> Students will think about what you say the first 20 times.
12:20:28 <xerox> I usually think about what teacher say when they say it.  I enjoy pauses too.
12:21:21 <monochrom> For example you say "a 10% increase followed by a 10% increase is *more* than one single 20% increase".  When you say that for the first 20 times, students will reject, "woah wait a second there, 10+10=20, you think we're fools?"
12:21:29 <monochrom> That is students thinking.
12:21:36 <monochrom> Now tell me if you prefer it that way.
12:21:59 <xerox> I don't know what people think.
12:22:00 <Philippa> I prefer to show them the right sum
12:22:10 <Philippa> namely (x*1.1)*1.1
12:23:59 <monochrom> Actually I was giving too much credit to students.  Their real response these days is, "woah wait a second there, calculator shows 10+10=20, you think we're fools?"
12:24:18 <Philippa> that part doesn't matter though
12:24:28 <Philippa> calculation's what calculators're for, no?
12:24:44 <xerox> I am not sure I know these "students" you are talking about then.
12:24:53 <Philippa> if we actually taught people to treat things sufficiently mechanically, it wouldn't matter
12:24:53 <kpreid> The weirdest part is the "'increase' means add 1 (or 100)".
12:25:19 <monochrom> But now the question is: so where is this "thinking" that the students allegedly do?
12:25:32 <Philippa> right, it's a case of unfortunate linguistic overloading, students haven't learnt that a percentage increase is a multiplication rather than an addition
12:25:44 <Philippa> monochrom: the bit where they parse increase as + not *
12:26:00 <Philippa> they *have* thought, they've just not realised that they've thought incorrectly
12:26:12 <Philippa> what you described was bad teaching because it failed to highlight that difference
12:26:46 <xerox> I can afford being just completely in the hands of the teacher.  In fact I only skim the teaching material and dive into background issues, or related ones, when I am being taught something.
12:27:01 <pkhuong-> Philippa: it is an addition... Just the addition of a fraction of the original total :\
12:27:44 <Philippa> pkhuong-: the second one isn't. It's better conceptualised by adding 100% to the percentage you're multiplying by, then you never mess up
12:28:00 <xerox> In fact, usually I don't *really* read the recommended resources, and go hunting for other things.
12:28:16 <Philippa> :-) Yeah, I did that a lot at uni. Though there're places where I wish I had done
12:28:44 <pkhuong-> Philippa: that's how I compute it, but I can see why increase can be applied without really overloading the term... Back to the original point: if it'snot in the textbook, i'm not listening ;)
12:28:49 <SamB> Philippa: yeah, I hate "percentage increases"...
12:29:48 <xerox> I don't know if it is good, but it doesn't seem to be the way monochrom describes "students" act.
12:30:19 <SamB> if they are used, they should be taught like...
12:30:26 <SamB> 100% = 1
12:31:12 <Philippa> I've seen equivalent attitudes, usually from people who're just in at whatever level they're at for the piece of paper
12:31:42 <SamB> I have that attitude only when my teacher makes less sense than my textbook
12:31:45 <Philippa> but monochrom's described attitudes on both sides - the students can't try to improve if all they get is stated facts and no reasoning or intuition
12:31:48 <Philippa> intuition is critical
12:31:58 <SamB> the one about not paying attention if it isn't in the textbook
12:32:12 * araujo `offTo` eat :: IO Food
12:32:48 <satan> how would i generate an exception? say i was dividing a/b, and b was zero, I don't want infinity, but a 'Divide by Zero' exception instead
12:32:50 <monochrom> I though eating consumed food rather than produced food, i.e., Food -> IO ()
12:34:10 <SamB> hmm.
12:34:35 <SamB> shouldn't that be MVar Food -> IO ()?
12:34:39 <dmead> lol
12:34:55 <monochrom> Even better.
12:34:56 <dmead> e.consume()
12:37:01 <xerox> fix (brunch :: Food new, Food leftover => new -> leftover) diverges
12:42:06 <monochrom> Hmm why does it diverge?  More and more food leftover in the long run?
12:44:24 <monochrom> satan: if b==0 then error "..." else a/b
12:44:30 <syntaxfree> I submitted my tutorials to the Communities and Activities Report.
12:44:40 <monochrom> There are more advanced ways.
12:44:52 <syntaxfree> I'm not sure they're substantive enough to be listed there, but I decided I'd let the editors decide.
12:45:35 <satan> monochrom: thanks, i was trying fail, and it gave me weird errors
12:45:53 <satan> now i know that that's because it's a monad etc..
12:46:15 <monochrom> satan: if b==0 then throw (ArithException DivideByZero) else a/b   -- this requires importing Control.Exception
12:46:34 <satan> ohh ok
12:46:36 <satan> thanks
12:47:02 <brent[]> hi, i'm trying to work through an example in YAHT, could someone tell me what im doing wrong here: http://rafb.net/paste/results/MNLNhk17.html
12:47:40 <syntaxfree> what's the error?
12:47:50 <brent[]> *** Exception: Prelude.read: no parse
12:48:24 <syntaxfree> maybe you need an empty string base case.
12:48:32 <syntaxfree> It never compiles, or it fails when you play with it?
12:48:45 <brent[]> i can run getNumbers as is
12:49:03 <brent[]> when i call numStats, i get the error after entering "0"
12:49:16 <syntaxfree> head [] is an error.
12:49:27 <syntaxfree> It doesn't look like the error message you got, though.
12:49:44 <syntaxfree> > head []
12:49:45 <lambdabot>  Add a type signature
12:49:47 <brent[]> i'm in ghci by the way
12:49:57 <int-e> > read "a" :: Int
12:49:59 <lambdabot>  Exception: Prelude.read: no parse
12:50:05 <xerox> What does "equality witness" mean?
12:50:13 <xerox> `witnesses' in fact.
12:50:24 <syntaxfree> xerox: legal context?
12:50:37 <xerox> Formal systems.
12:50:54 <SamB> you mean like System FC?
12:51:25 <xerox> Right.
12:52:18 <SamB> I think they are a third sort of "value"
12:52:59 <SamB> (after values and types)
12:53:02 <SamB> maybe fourth
12:53:09 <xerox> Types of kinds?
12:53:13 <SamB> (perhaps kinds count too)
12:53:21 <int-e> as I understand them, witnesses save you the bother of representing proofs as values.
12:53:39 <xerox> So is `witnesses' a formal term?
12:53:42 <SamB> though actually these look kind of like proofs to me
12:53:59 <SamB> they look like nothing so much as type constructors
12:54:06 <SamB> or rather types
12:54:15 <SamB> or maybe those are the types...
12:54:21 <SamB> it looks wierd.
12:54:43 <pkhuong-> xerox: well, IIUC, witnesses used as proofs for proposition of the type Exists x, ... So if you can show one such x, you've got yourself a proof.
12:55:32 <syntaxfree> in other word, witness = example.
12:55:40 <xerox> Cool.
12:55:46 <Philippa> witness = evidence
12:55:47 <int-e> SamB: the witnesses don't contain the proofs though. The proofs are in the rules that introduce witnesses.
12:56:13 <Philippa> yep, the witness is just the finished product - shows you've done the reasoning
12:56:23 <int-e> 'I can assure you that the types A and B are equal! I was their when the compiler proved that!'
12:56:36 <xerox> there?
12:56:38 <int-e> there.
12:56:39 <int-e> yes.
12:56:43 <xerox> I see, nice :)
12:58:01 <SamB> int-e: oh.
12:58:05 <SamB> how do you tell?
12:59:20 <int-e> SamB: I forgot all the details but the final result was very clear indeed. ;)
13:00:41 <SamB> hmm.
13:00:51 <SamB> type Coercion     = Type
13:00:52 <SamB> type CoercionKind = Kind        -- A CoercionKind is always of form (ty1 :=: ty2)
13:01:22 <syntaxfree> I wonder if I count a tutorial listed in the Communities and Activities Report as a publication quoting me for a publications resume.
13:02:10 <SamB> so is a Coercion just a "witness"
13:02:11 <SamB> ?
13:15:56 <brent[]> syntaxfree: and int-e thanks, i more or less get it.
13:19:19 <satan> is there a function to check if one list is a sublist of another?
13:19:42 <syntaxfree> or . zipWith elem  should do it.
13:19:56 <syntaxfree> oops, and . zipWith elem
13:21:01 <satan> thanks :)
13:21:54 <xerox> F_C does not strive to do everything; rather we hope that it strikes an elegant balance between expressiveness and complexity. While our motivating examples were GADTs and associated types, we believe that F_C may have much wider application as a typed target for sophisticated HOT (higher-order typed) source languages.
13:22:44 <satan> syntaxfree: so that'll work only if the sublist is contiguous, right? not if the elements are present but spread apart
13:23:02 <satan> i mean [1,2,3,4] has [3,4] but not [2,4]
13:25:24 <int-e> SamB: yes, I think so. ": is evidence that a value of type  can be used in any context that exepcts a value of type , and vice versa" says the paper, about "type-equality coercions", short "coercions". They are types, so I guess that's what that declaration defines.
13:26:38 <int-e> SamB: you can use them in a cast to convert from  to . Oh,  is the :=: I suppose.
13:34:49 <SamB> I still don't see the difference between them and proofs :-(.
13:38:19 <xerox> SamB they are axioms?
13:38:32 <SamB> xerox: oh
13:38:43 <SamB> the witnesses are *axioms*?
13:38:47 <int-e> they're assertions. although the  part looks a lot like it carries complete proofs around.
13:39:12 <SamB> yeah
13:39:20 <int-e> but I think you can inject them as axioms into the system.
13:39:20 <SamB> thats why I'm not seeing the difference
13:39:23 <agnostic-c> Are there any dbm haskell libraries?
13:39:33 <int-e> in the  part.
13:39:58 <SamB> oh, well, GHC.Prim.CoUnsafe lets you do that, I think
13:40:32 <xerox> On the other hand, the type functions you get, are open.
13:41:25 <SamB> yeah, I *am* just looking at the Coercions created from uses of "newtype"...
13:41:39 <SamB> and unsafeCoerce#
13:42:39 <lisppaste2> xerox pasted "Error message, slightly " at http://paste.lisp.org/display/29291
13:42:48 <xerox> wrong?
13:43:23 <syntaxfree> agnostic-c dbm?
13:43:28 <nominolo> hm, is there a notation for hexadecimal constants in haskell?
13:43:41 <SamB> > 0xdeadbeef
13:43:42 <lambdabot>  3735928559
13:43:49 <int-e> SamB: right, the axiom rule introduces coercions without proof.
13:43:54 <syntaxfree> > 0xff
13:43:56 <lambdabot>  255
13:43:56 <nominolo> d'oh
13:44:02 <nominolo> > 0x42
13:44:04 <lambdabot>  66
13:44:16 <SamB> int-e: I haven't looked at the paper yet, really
13:45:21 <monochrom> http://www.haskell.org/onlinereport  has info on hexadecimal constants in haskell
13:45:23 <lambdabot> Title: The Haskell 98 Language Report
13:45:30 <monochrom> People should read it more.
13:45:45 <monochrom> Too many Haskellers rely on words of mouth.
13:47:29 <Philippa> SamB: given sufficiently compound types, a witness may require the use of multiple axioms to create...
13:47:37 <SamB> Philippa: sure
13:47:51 <SamB> I don't recall having seen any
13:48:19 <Philippa> coercions on tuples'd be a good place to start
13:48:28 <agnostic-c> syntaxfree: like the bsd db library
13:48:48 <Philippa> as would transitivity - A=B and B=C...
13:48:51 <syntaxfree> database?
13:49:20 <Philippa> speaking of syntaxfree, I just realised the ultimate fate of the app I was planning on writing myself for my Zaurus...
13:49:38 <Philippa> ...which is to become a lisp based around a structural editor
13:49:58 <syntaxfree> I have been thinking of buying a palmtop, but I don't think I ever mentioned it here.
13:50:03 <Philippa> the original concept being, of course, a list-keeping/checking-off app for stuff like shopping lists :-)
13:50:21 <agnostic-c> syntaxfree: yeah. without some acid features, but it's supported on every unix system around
13:50:30 <syntaxfree> acid?
13:51:15 <Philippa> a set of properties that you want in a database system
13:51:22 <edwardk_> acd = atomicity, consistency, isolation, durability
13:51:26 <agnostic-c> http://en.wikipedia.org/wiki/ACID
13:51:46 <int-e> SamB: I think the proof part is optional and doesn't affect type checking. if you drop it you get witnesses in the usual sense.
13:51:54 <Philippa> I always forget and thus have to look up the exact expansion, because when I have it I can just remember as "system won't fuck up without you asking nicely"
13:51:54 <pzpz>  conn@(h, host, port) <- accept sock  -- what exactly does the @ do?
13:51:58 <pzpz> and what is it called?
13:52:03 <syntaxfree> it's an as-pattern.
13:52:06 <edwardk_> you want actons to be atomic, result in the a consistent database, work as if no other transaction was runnng at the same tme, and you want the database to remember what you did.
13:52:08 <syntaxfree> @google as-pattern
13:52:10 <Philippa> it's an "as-pattern". Binds the entire tuple to conn
13:52:10 <lambdabot> http://www.mtnmath.com/whatrh/node106.html
13:52:11 <lambdabot> Title: Intuition as pattern recognition
13:52:12 <int-e> SamB: but I understand your confusion now :)
13:52:15 <syntaxfree> :(
13:52:21 <pzpz> ry
13:52:22 <pzpz> ty
13:52:23 <Philippa> so conn becomes shorthand for (h, host, port)
13:53:01 <pzpz> so it's esentially giving a handle to the tuple as conn
13:53:36 <lispy> dons: ping?
13:54:07 <pzpz> lispy: destination unreachable.
13:54:10 <kpreid> > (\a@~[()] -> ()) undefined
13:54:11 <lambdabot>  Parse error
13:54:21 <kpreid> > (\a@[()] -> ()) undefined
13:54:22 <lambdabot>  Undefined
13:54:30 <kpreid> > (\a@(~[()]) -> ()) undefined
13:54:32 <lambdabot>  ()
13:54:40 <kpreid> > (\_@(~[()]) -> ()) undefined
13:54:40 <lambdabot>  Parse error
13:54:43 <syntaxfree> obfuscated haskell! yay!
13:55:07 <agnostic-c> haskell has a golf course?
13:55:23 <SamB> int-e: except for the fact that afaict GHC doesn't actually store the theorem?
13:55:50 <int-e> @type (\a@ ~[()] -> ())
13:55:52 <lambdabot> [()] -> ()
13:56:24 <int-e> SamB: it doesn't? it's in the kind.
13:56:38 <monochrom> What is the longest function that returns () in constant time? :)
13:56:49 * araujo `backFrom` lunch :: IO Here
13:56:54 <int-e> SamB: (ty1 :=: ty2), asserting that ty1 and ty2 can be used interchangably.
13:57:07 <kpreid> monochrom: const "...arbitrary string..." ()
13:57:13 <monochrom> hee
13:57:16 <kpreid> er, reverse that
13:57:23 * araujo wonders if lispy already uploaded code to the darcs repo
13:57:24 <xerox> flip const "..." ()
13:58:21 <int-e> > foldr const () (repeat ()) -- just unfold this as far as desired
13:58:22 <lambdabot>  ()
13:58:42 <xerox> hehe
13:58:43 <lispy> araujo: well, i added a HACKING file
13:58:48 <xerox> not bad.
13:58:52 <lispy> araujo: but i don't have write permission on the repo :)
13:59:25 <lispy> araujo: oh wait...are you talking about the smalltalk thing?
14:00:01 <lispy> araujo: i didn't endup getting any code written because i need a way to dump an 'image' made by java out to something that i can make sense of
14:00:11 <lispy> araujo: i'm close, but still very far
14:00:18 <lispy> maybe i should post what i have anyway...
14:02:30 <araujo> lispy, yeah :-)
14:02:40 <lispy> araujo: uploading now
14:02:47 <araujo> lispy, yeah, please, upload
14:03:06 * araujo is interested on this kind of stuff
14:03:31 <araujo> lispy, i myself have thought of this idea sometimes too
14:04:03 <Baughn> Was the ((->) r) monad added after 6.6, or am I missing some import somewhere in ghci?
14:04:17 <jgrimes> lispy, there is a lot more to helisp than you make it out to be in the description :p
14:04:55 <roconnor> Baughn: Control.Monad.Reader?
14:06:02 <Baughn> Right
14:09:14 <lispy> araujo: http://www.codersbase.com/index.php/SmallWorld
14:09:17 <lambdabot> http://tinyurl.com/yaz4pm
14:09:34 <lispy> jgrimes: i need to reorganize it and fix that description
14:09:57 <jgrimes> lispy, oh ok.
14:09:57 <shapr> jiihaa
14:10:00 <lispy> jgrimes: originally it was only an interpreter, but very recently i've made it into a copmiler
14:10:08 <jgrimes> so I see :)
14:10:22 <lispy> unfortunately the parser doesn't talk to the compiler yet :(
14:10:26 <jgrimes> :(
14:10:31 <xerox> shapr: she departed?
14:10:34 <araujo> lispy, nice
14:10:49 <shapr> xerox: Nah, tomorrow afternoon.
14:11:16 <jgrimes> lispy, are you doing any type analysis before compiling? or are you just outputting the asm with type checks?
14:11:34 <lispy> jgrimes: neither!
14:11:37 <jgrimes> oh, nice
14:11:39 <jgrimes> :)
14:11:47 <lispy> jgrimes: but, i would like to add some of that
14:12:06 <xerox> shapr: so you've got some time to chat, anyway :)  How's things?
14:12:14 <lispy> jgrimes: currently the assembly is just a list of strings and i unlines it
14:12:50 <lispy> jgrimes: but, it might be worthwhile to create a haskell datastructure to represent the asm, then things like peephole optimization becomes easier
14:13:26 <lispy> jgrimes: also, some day it might be nice to move away from needing GNU as, but for now that's not so bad...keeps the code terrible simple (by comparison)
14:13:58 <jgrimes> lispy, yeah, I was going to ask about that too. gas syntax isn't the best in the world :)
14:15:23 <araujo> lispy, we need to do something against those .java files :-)
14:15:31 <lispy> araujo: indeed
14:15:51 <lispy> araujo: i noted somewhere the first hurdle is that damned image file :)
14:18:03 <jgrimes> lispy, and also... I noticed you were using 64-bit registers, which, my processor is lacking :)
14:18:07 <araujo> lispy, This is the same guy of Little ST right?
14:19:12 <lispy> araujo: ah yes
14:19:16 <araujo> I have a copy of it somewhere
14:19:21 <lispy> jgrimes: patches are welcome!
14:19:31 <jgrimes> lispy, yeah, I think I'll do that
14:19:32 <jgrimes> :)
14:19:33 * araujo wanted to do the same with LST
14:19:36 <lispy> jgrimes: cool!
14:19:37 <Cale> Reddit is looking reasonably positive at the moment. Yesterday most of my arrows were blue. :)
14:19:46 <lispy> jgrimes: so if you do that i've already started planning for it
14:19:54 <lispy> jgrimes: there is a RegValue that will need to be fixed to Int32
14:20:30 <lispy> jgrimes: and then in the file with all the tests, we need to base the ones of the form 2^61... interms of maxBound::RegValue
14:21:06 <lispy> jgrimes: but after that i'm not sure how to structure things
14:22:52 <Botty> Cale - I'd like to see the tests applied to bzr/hg appled to darcs
14:23:04 <jgrimes> lispy, ok
14:23:24 <Cale> Botty: yeah
14:23:41 <lispy> Botty: what are those?
14:24:06 <lispy> the last time i used bzr, darcs was much bettr tested by comparison
14:24:16 <lispy> plus this term I'm writing a DarcsSim to simulate users
14:24:30 <SamB> lispy: neato
14:24:31 <lispy> so if you have ideas on how to do testing of darcs, this is a good time to speak up :)
14:24:38 <Botty> lispy - http://sayspy.blogspot.com/2006/11/bazaar-vs-mercurial-unscientific.html
14:24:40 <lambdabot> Title: Coder Who Says Py: Bazaar vs. Mercurial : An unscientific comparison, http://tinyurl.com/sao6c
14:25:00 <Botty> Hg appears to beat the pants off Bzr
14:25:01 <SamB> make sure to include forgetful administrators!
14:25:13 <SamB> also --partial
14:25:43 <Botty> lispy - cool, I hven't yet actually used darcs, but it sounds very nice
14:26:01 <lispy> Botty: thank you, i'll bookmark this
14:26:22 <Botty> no problem
14:27:39 <lispy> in fact, today i need to only work on darcssim or it will never get written :)
14:28:44 <SamB> so, um, who has ops?
14:29:16 <Igloo> why?
14:29:48 <SamB> oh, I was going to suggest kicking lispy if he gets into any unrelated conversations ;-)
14:30:37 <SamB> hmm.
14:31:07 <SamB> I just saw a coercion of kind (Int# :=: Any).
14:31:12 <SamB> that doesn't sound right to me :-(
14:31:27 <Syzygy-> Huh?
14:34:09 <akemp> anyone strong in HaskellDB?
14:34:36 <Captain_Fourier> hmm
14:35:54 <araujo> lispy, so, you intend to represent the class hierarchy through a recursive ADT?
14:35:58 <edwardk> samb: darcs is written in haskell, its related =)
14:37:52 <SamB> I meant things unrelated to darcssim
14:38:05 <SamB> like, oh, System FC probably
14:38:06 <edwardk> ah =)
14:38:43 <edwardk> heh, i wouldn't mind striking up a conversaton on the latter subject, but from the souns of it the result would be lispy flying out of the channel =)
14:42:53 * araujo throws shuriken lambdas around
14:43:13 <Oejet> Where did mmap go?
14:43:36 <araujo> @hoogle mmap
14:43:37 <lambdabot> No matches found
14:44:09 <lispy> heeh
14:44:16 <lispy> SamB: why did you want an op?
14:44:17 <SamB> hmm.
14:44:39 <SamB> lispy: to kick you if you got distracted
14:44:50 <lispy> araujo: i'm all ears...but Cale and I thought about it a lot last night and that was the simplest thing that seems to work
14:44:57 <lispy> SamB: ah!
14:45:00 <lispy> SamB: now i get it
14:45:32 <lispy> jgrimes: also, note that wordsize = 8 at the moment, and that would be really wasteful (if it works at all) with 32bit processors
14:45:49 <lispy> jgrimes: i think wordsize is defined in Immediate.hs
14:45:54 <jgrimes> lispy, ok
14:46:27 * lispy buckles down :)
14:48:10 * SamB sneaks up behind lispy and ignites his boosters
14:48:57 <lispy> lol
14:49:42 <SamB> hmm. this refactored simplifier code does not like me.
14:56:35 <araujo> lispy, So, objects are going to be also ADT right?
14:56:50 <lispy> araujo: what do you mean?
14:57:16 <araujo> lispy, i wonder about the consistency between class and object representation on ST.
14:57:28 <lispy> araujo: if you look at the trace of running the java you'll see that Class and MetaClass are both impremented as a recursive structure of SmallObject
14:58:06 <lispy> araujo: well, in ST, everything is an Object
14:58:14 <lispy> araujo: classes, metaclasses, numbers, everything
14:58:19 <araujo> Yeah
14:58:35 <lispy> (this is roughly everything i know about ST ;)
14:58:36 <araujo> How do you intend to represent an 'object' to preserve such a consistency?
14:59:02 <lispy> araujo: you don't think SmallObject is sufficient?
14:59:12 <araujo> lispy, i am just asking you :-)
14:59:34 <lispy> araujo: okay, well it looks like i didn't finish my thought in SmallObject.hs
14:59:40 <araujo> The file is a bit tiny _yet_ as to give me a general idea too.
15:00:05 <lispy> araujo: we need to change it to SmallInt SmallObject [SmallObject] Int
15:00:29 <lispy> araujo: if we are to strictly emulate the inherintance in the java version
15:01:06 <lispy> araujo: but where i got lost, and why i want te examine the image is because given that i still don't know how to create nilObject
15:01:34 <lispy> araujo: i don't see how to represent the class of nilObject
15:01:43 <lispy> araujo: and i don't know enough ST to guess :)
15:02:06 <araujo> lispy, yeah, i see that nilObject is incomplete
15:02:21 <araujo> OK, let me see if i can come up with something :-}
15:02:26 <lispy> araujo: okay!
15:02:28 <lispy> araujo: good luck
15:02:36 * araujo came to Haskell from Smalltalk btw
15:02:44 <lispy> araujo: ah, cool
15:02:57 <lispy> see if this were lisp i would have a clue :)
15:03:58 <araujo> hah
15:04:04 <Philippa> ST has object identity, doesn't it?
15:04:21 <araujo> btw, i think somebody else is also writing a lisp interpreter in Haskell.
15:04:23 <Philippa> so nilObject is nilObject and isn't anything else and inheritance aside that's the only thing you really need?
15:04:42 <lispy> araujo: several, there is scheme in 48 hours and some others
15:04:43 <araujo> Philippa, pretty much, Everything else happens through polymorphism
15:05:06 <lispy> araujo: my goal is something that can be used to run elisp...imagine this as a plugin to yi :)
15:05:28 <araujo> nice
15:05:37 <Philippa> was polymorphism even talked about until OO seeped into more traditionally imperative "OO" languages?
15:07:33 <araujo> Philippa, you mean .. if ST already had the concept of polymorphism?
15:09:49 <Philippa> I think more accurately if ST users did. I don't see it as language level in ST at all, and it isn't really per se in C++
15:12:10 <araujo> Philippa, Sure.
15:12:25 <araujo> I actually dare to say that it dates back to Lisp hackers.
15:12:37 <Philippa> fair enough, that figures
15:12:54 <magnus-> I wish haskell would let arguments of if..then..else, case...of, == etc inside a monad
15:13:24 <xerox> mif, mcase.. yeah. You can write them with liyang stuff :)
15:15:22 <magnus-> everything should run in a monad
15:16:01 <magnus-> the default, the lazy, pure functional monad should be visible and replacable
15:16:05 <xerox> Everything that `runs' in a monadic sense should run in a monad.
15:16:21 <xerox> What do you mean by lazy, pure functional monad?
15:16:52 <Philippa> I think that makes the mistake of constraining things to monadic signiatures - otherwise I'm with you though
15:16:56 <Baughn> @hoogle Bool -> a -> a -> a
15:16:57 <lambdabot> No matches, try a more general search
15:17:13 <lispy> magnus-: you want? mif :: Monad m => m Bool -> m a -> m a
15:17:19 <lispy> or ifm
15:17:25 <magnus-> lispy: yes
15:17:28 <Philippa> you want a more general concept though, one that covers all meaningful notions of "computation yielding a", including for constrained a
15:17:42 <magnus-> lispy: um wait. I said yes too soon :)
15:17:58 <lispy> ?type liftM3 if'
15:18:00 <lambdabot> Not in scope: `if''
15:18:16 <lispy> ?type liftM3 (\b t e -> if b then t else e)
15:18:18 <lambdabot> forall a3 (m :: * -> *). (Monad m) => m Bool -> m a3 -> m a3 -> m a3
15:18:23 <xerox> mif :: Monad m => m Bool -> m a -> m a -> m a
15:18:30 <xerox> mif :: Monad m => m Bool -> m a -> m b -> m () ? :)
15:18:34 <xerox> mif_ sorry
15:18:39 <wchogg> Has anyone else ever read the Lightweight Static Capabilities paper?
15:18:59 <magnus-> those things seem interesting
15:19:15 <lispy> magnus-: anyway, my point for speaking up is this, don't forget about the liftM family and other monadic utility functions
15:20:02 <magnus-> I hadn't realized I could use liftM-like stuff on if..then.else
15:20:12 <magnus-> case..of still won't work
15:20:20 <lispy> magnus-: you just have to wrap it in a lambda
15:20:29 <lispy> yeah, case would be tricky
15:20:34 <lispy> to do it in general
15:21:14 <Baughn> There's no if-function in the standard library?
15:21:15 <Philippa> mcase is a macro rather than a function, essentially. Just as case is a language construct rather than yet another function (given data constructors as language constructs)
15:21:42 <lispy> Baughn: i wish there was, but no you have to define if' b t e = if b then t else e, yourself
15:22:34 <lispy> magnus-: you may also like 'when
15:22:39 <lispy> ?type when
15:22:40 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
15:22:54 <magnus-> In every argument position to a function or special form I would like to be able to put a monad computation instead of a pure computation
15:23:32 <Baughn> magnus-: Isn't that what >>= is for?
15:23:35 <lispy> for the first part we have liftM*, for the second requirement...not as helpful :)
15:23:47 <magnus-> to avoid things like do a <- f x; b <- g y; case (a,b) of ....
15:23:56 <magnus-> lispy: yup. thanks :)
15:24:36 <lispy> ?undo do <- f x; b <- g y; return (a, b)
15:24:37 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 4}) "Parse error"
15:24:39 <lispy> ?undo do <- f x; b <- g y; return (a, b);
15:24:40 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 4}) "Parse error"
15:24:47 <lispy> ?undo do a <- f x; b <- g y; return (a, b);
15:24:47 <lambdabot> f x >>= \ a -> g y >>= \ b -> return (a, b)
15:24:56 <Baughn> ?pl f x >>= \ a -> g y >>= \ b -> return (a, b)
15:24:57 <lambdabot> (`fmap` g y) . (,) =<< f x
15:25:00 <lispy> ?pl . undo do a <- f x; b <- g y; return (a, b);
15:25:01 <lambdabot> (line 1, column 1):
15:25:01 <lambdabot> unexpected "."
15:25:01 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
15:25:08 <lispy> Baughn: thanks
15:25:23 <lispy> ?. pl undo do a <- f x; b <- g y; return (a, b);
15:25:24 <lambdabot> (`fmap` g y) . (,) =<< f x
15:25:39 <Baughn> lispy: That one is uncommonly unpenetrable
15:25:41 <magnus-> haha that pointfree style is seriously hard to understand
15:25:50 <lispy> what??
15:25:53 <lispy> no way.... :)
15:26:00 <Baughn> Sometimes ?pl gives me gems like ($ 42), not to mention fmap, but.. yeah. ;)
15:26:11 <lispy> in this case fmap == liftM
15:26:47 <Baughn> ..quite. liftM for monads, fmap for functors - any monads around that aren't functors?
15:26:49 <lispy> a human is more likely to type it this way: f x >>= (`fmap` g y) . (,)
15:27:05 <lispy> Baughn: in haskell it's possible, mathematically speaking no
15:27:40 <lispy> or maybe even, f x >>= (\x -> (fmap x g y) . (,)
15:27:51 <lispy> (modulo the missing paren)
15:27:59 <Baughn> lispy: Some humans might be more likely to write it like that, but I'm still busily burning new pathways and can't even parse it easily yet
15:28:03 <magnus-> I would still type do a <- f x; b <- g y; return (a,b)
15:28:27 <magnus-> and wish that I could type (f x, g y)
15:28:34 <araujo> lispy, look, i recommend you to use gnusmalltalk
15:28:38 <lispy> Baughn, magnus-: indeed, i would do it with do notation too, just trying to amke the output of pl a bit more human friendly
15:28:49 <araujo> it has a handy lightweight tk class browser
15:28:53 <lispy> araujo: you think starting with smallworld is bad? ;)
15:29:13 <araujo> lispy, no, we could get some ideas out of gst too
15:29:20 <lispy> araujo: ah
15:29:39 <lispy> araujo: i just thought this version was clever and small so would be a good place to start, but yeah it's feeling like a deadend
15:29:41 <araujo> For example, for how to implement the objects and such, it'd be easier.
15:29:44 <Baughn> lispy: And if it turns out that pointless style is in fact easier to read, write and understand than normal style?
15:30:09 <araujo> lispy, we can take of both what we find easier in each of them :-)
15:30:15 <Baughn> ..why is it called "pointsfree", anyway?
15:30:33 <lispy> Baughn: only in some cases, pointfree basically breaks down you have more than one value flowing
15:30:34 <magnus-> no binding points?
15:30:38 <lispy> Baughn: because the points are the parameters
15:30:42 <lispy> Baughn: and you remove them
15:30:55 <Baughn> lispy: And add... dots, more often than not
15:31:33 <lispy> Baughn: right, but in math that would be the little circle for function composition istead of a point :)
15:31:51 <lispy> araujo: okay, that sounds very reasonable
15:33:22 <lispy> araujo: here is an approach we could try
15:33:31 <lispy> araujo: have things like nil as a haskell value
15:33:37 <lispy> data Nil = Nil
15:33:39 <magnus-> maybe function application itself should have the type Monad m -> m (a->b) -> m a -> m b
15:34:06 <lispy> araujo: and then have a type class SmallObject which provides an interface for introspection
15:34:18 <lispy> araujo: this requires more work on the haskell side, but may be a lot easier to understand
15:34:36 <lispy> ?type liftM
15:34:37 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
15:35:00 <lispy> magnus-: that's the type of liftM ;)
15:35:11 <magnus-> ugh :)
15:36:13 <lispy> araujo: because going this way, i think we need a haskell representation of Class and MetaClass
15:36:51 <lispy> araujo: but those aren't really haskell concepts, those are pure ST concepts
15:39:50 <lispy> ihope: hey, how's it going?
15:40:08 <ihope> Oh, it's... well, it's going.
15:40:18 <lispy> heh
15:40:22 <ihope> About average.
15:41:59 <lispy> araujo: i'm leaving (maybe for the evening) so if you have more thoguhts, feel free to /msg me
15:42:12 <xerox> edwinb: ping?  Pass by ##logic when you happen to be at the keyboard.
15:48:20 <araujo> lispy, good, sure
15:48:35 <araujo> lispy, yeah, i am thinking to represent Nil  as a plain ADT
15:49:45 <jgrimes> lispy, hm, for some reason the test harness isn't catching the output of the compiled files. don't guess you have run into this problem before?
15:55:12 <jgrimes> lispy, for all of the tests I have run manually, the 32bit registers and instructions seem to work just dandy.
15:55:33 <jgrimes> of course I would like to get the test cases working to actually verify :p
16:16:11 <wchogg> So if you compose two monads you always get back an applicative functor, but are there results on what subset of monads are closed under composition?  Wouldn't that be related to the ability to define a monad transformer?
16:17:41 <xerox> Are there monad for which you can't write a transformer?
16:17:48 <xerox> *monads
16:18:08 <wchogg> Well that's what I'm wondering, actually.
16:18:23 <xerox> I think you can always write a transformer.
16:18:57 <xerox> Maybe it's time to go through some paper from Wadler? :)
16:19:05 <wchogg> Well, how is that not the same as being able to compose any two monads?  You're lifting all the actions from one into the other, right?
16:19:37 <wchogg> Yeah, maybe Lambda Man can help me.
16:24:15 <SamB> um
16:24:26 <SamB> have you seen an IO transformer lately?
16:26:03 <wchogg> I'm going to go out on a limb and say "no"?
16:27:00 <wchogg> I'm not sure why I wrote that as a question, actually.
16:32:22 <kpreid> I'd also like to know whether any monads other than IO/ST/STM/... can't be written as transformers
16:37:10 <SamB> so how do you tell if you've successfully written a transformer version of a given monad?
16:38:08 <wchogg> I guess prove that the monad laws still hold?
16:38:21 <SamB> hah
16:38:32 <SamB> that only proves that you've written a monad transformer!
16:38:58 <wchogg> Ah!  You're asking how you prove it's the right monad you get out?
16:39:35 <SamB> indeed!
16:40:03 <wchogg> Then I guess I don't know.
16:41:02 <xerox> Well, you just need the IO constructor to write IOT, don't you?
16:42:07 <kpreid> Well, you can approximate telling by comparing the behavior of FooT Identity with Foo.
16:45:08 <dons> ?uptime
16:45:08 <lambdabot> uptime: 2d 9h 57m 24s, longest uptime: 6d 23h 44m 3s
16:45:12 <dons> ?users
16:45:13 <lambdabot> Maximum users seen in #haskell: 265, currently: 238 (89.8%), active: 32 (13.4%)
16:53:15 <audreyt> dons: to create new typeclass at runtime.
16:53:28 <audreyt> can libghc do that, or do I want hs-plugins, or something?
16:56:36 <Igloo> ghc-as-a-library can do it, in the same way as ghci does when it reads Haskell source from a file
17:00:16 <audreyt> cool.
17:00:32 <Baughn> ?pl \(a,b) -> (a+1,b)
17:00:33 <lambdabot> first (1 +)
17:00:36 * audreyt goes on hacking on the krazy Make-GHC-Into-Smalltalk plan
17:01:08 <audreyt> i.e. a metaclass protocol API that allows augmentation and creation of runtime typeclasses and data types
17:08:28 <dons> audreyt: hmm ghc-api could do it. you want new clases or new clsas instances?
17:08:32 <dons> hs-plugins can do it as wel
17:08:47 * dons drinks coffee then types
17:08:58 <audreyt> how do you drink types?
17:09:15 <audreyt> is hs-plugin 6.6 happy yet?
17:09:39 <dons> not yet. but you're number 13 who's asked. including 3 today.
17:09:46 <dons> and i haven't even had breakfast yet..
17:13:24 <dons> SamB: around?
17:13:26 <lisppaste2> xerox pasted "IOT" at http://paste.lisp.org/display/29302
17:13:39 <xerox> SamB -^
17:13:40 <dons> what's the consequences of using unchecked shifts in the Data.Bits rotates?
17:13:46 <dcoutts> poor dons, how you suffer from people using your software :-)
17:14:02 <dcoutts> yeah, I didn't quite follow that
17:14:04 <dons> bah! users!
17:14:33 <xerox> See my thug? :P
17:14:41 <dons> there should be some QuickChecks or something at least, so people feel confident things aren't breaking
17:16:04 <Pupeno> Working with types in Haskell is a bit like taking care of the units of mesurements in physics, once all your calculations lead to the right units you are likely to have done the right calculations.
17:16:58 <dons> audreyt: is there a reasonable implementation of monads in perl6?
17:17:06 <dons> Pupeno: that's a nice analogy
17:17:12 <audreyt> dons: sure, but there is no syntactic support
17:17:31 <Pupeno> dons: thank you.
17:18:40 <pkhuong> audreyt: how do you deal with the lack of static typing?
17:18:52 <dons> audreyt: is the syntax/parser perl6 magic  flexible enough to allow syntactic support?
17:19:23 <dons> morning pkhuong
17:19:54 <dons> xerox: did we hear how yaxu went with his live haskell music dj show?
17:19:56 <Igloo> Woo, ghc 6.6 is in etch now!
17:20:00 <dons> yay!
17:20:03 <xerox> dons: nope
17:20:04 <pkhuong> dons: evenin'
17:20:31 <xerox> dons: was he going to do some demonstration?
17:20:40 <dons> yep.
17:20:44 <xerox> wow.
17:20:50 <dons> he's done quite a few i think, in perl and at least one in haskell
17:20:57 <dons> there's a wired article about him :)
17:20:59 <xerox> yeah, I've seen those
17:21:05 <xerox> uh, I didn't know that.
17:22:40 <xerox> @localtime xerox
17:22:41 <lambdabot> Local time for xerox is Sun Nov  5 02:22:18 2006
17:22:47 <xerox> Tomorrow :)  G'night.
17:22:47 <dons> "06:15:29 <yaxu> i'm going to perform some music from the ghci command prompt tonight :)"
17:23:53 <dons> http://www.wired.com/news/technology/0,71248-0.html?tw=wn_index_1
17:23:56 <lambdabot> Title: Wired News: Real DJs Code Live, http://tinyurl.com/fkfmy
17:24:38 * Igloo trembles in the face of code like   TWENTY != 0
17:25:15 <dons> oh my
17:26:52 <audreyt> dons: yes.
17:27:04 <audreyt> pkhuong: perl6 has optional static typing :)
17:27:07 <audreyt> aka, gradual.
17:27:23 <audreyt> pkhuong: http://www.cs.colorado.edu/~siek/pubs/pubs/2006/siek06:_gradual.pdf
17:27:27 <lambdabot> http://tinyurl.com/y428q7
17:27:55 <mjl69> > 7
17:27:56 <lambdabot>  7
17:28:19 <pkhuong> audreyt: ok.
17:33:41 <dons> dcoutts: got a ref for those 16 core mips boxes?
17:33:47 * dcoutts looks
17:33:47 <dons> i'm trying to persuade rl ...
17:34:59 <dcoutts> dolio, http://www.movidis.com/
17:35:01 <lambdabot> Title: Movidis
17:35:02 <dcoutts> oops
17:35:04 <dcoutts> dons, ^^
17:35:15 <dons> cheers!
17:35:43 <dcoutts> dons, it is sold somewhat as an appliance, so they only support one particular version of debian
17:35:44 <dons> now just to convince Chilli that we need 16 cores to get our papers written
17:35:48 <dcoutts> heh
17:36:24 <dcoutts> dons, or for the same money you can get an 8 core (each core multiplexes 4 threads) sparc
17:36:41 <dcoutts> which is probably the better option given rl's existing work with sparc
17:37:09 <dcoutts> so it does 32 threads all told, at 1Ghz iirc
17:37:53 <dcoutts> the mips does 16 threads at 600Mhz
17:38:07 <dons> yeah, i think he might need intel though
17:38:21 <dcoutts> really? why?
17:38:25 <dons> since there's already the massive sparc box in berlin
17:38:49 <dcoutts> oh he needs something other than sparc because he's already got sparc covered ?
17:39:12 <dons> 12:38  rl> yeah, x86
17:39:12 <dons> 12:38  rl> i have enough sparcs :)
17:39:15 <dcoutts> hah
17:39:29 <dons> i.e. commodity hardware
17:39:33 <dons> not special purpose stuff
17:39:56 <dcoutts> then it'll be expensive, multi-way x86 isn't that cheap if you want lots of cores/cpus
17:40:20 <dcoutts> ask JaffaCake what they paid for 4 cpu dual core
17:40:48 <dcoutts> it was more than $3k I believe
17:40:49 <dons> yeah. i think 8 x86/amd64 cores is something around what he's looking at. maybe 4 would be ok. (we hvae a couple of 4 core servers here, but they're under heavy load -- we need a dedicated ghc box)
17:41:31 <dons> the mips box would make a nice home firewall :)
17:41:51 <dcoutts> hah hah
17:41:59 <dcoutts> you need a 16 core firewall ?
17:42:45 <pkhuong> dcoutts: the regex engine can probably be abused in interesting ways.
17:42:55 <dons> i suppose i could run 16-threaded hmp3 on it, for the home sound system
17:43:01 <syntaxfree> regex engine??
17:43:12 <dons> this is my current firewall, http://www.cse.unsw.edu.au/~dons/via_openbsd.html
17:43:14 <lambdabot> Title: OpenBSD on the VIA ML-series Mini-ITX, http://tinyurl.com/tmj82
17:43:23 <dons> so something small with more cores would be also good
17:43:52 <dons> fanless boxes are super nice
17:44:00 <syntaxfree> my box has no fans.
17:44:06 <Igloo> Fans should be illegal
17:44:15 <Adamant> someone in #erlang was benchmarking a T1/Niagara processor for SSL
17:44:21 <Adamant> crazy, crazy performance
17:44:27 <syntaxfree> it's absolutely silent, and cool. I had forgotten computers are usually warm when I went changing RAM sticks for my dad today.
17:44:29 <dons> oh yeah?
17:44:34 <dcoutts> pkhuong, not sure what you mean
17:44:46 <dons> Adamant: any other detais? what's that , special crypto instructions? lots of cores?
17:44:50 <Adamant> especially because they have a Modular Arithmetic Unit on each
17:44:53 * dcoutts would like a T1 box for smp ghc
17:44:53 <dons> ah right
17:44:55 <Adamant> both
17:45:17 <pkhuong> dcoutts: there's a hardware dfa engine.
17:45:24 <dcoutts> oh, I didn't spot that
17:45:27 * dons dreams that smp erlang and smp ghc will take over the world in the next 5 years
17:45:47 <Adamant> I hope Sun can make them cheaper, right now their power savings promises don't turn into actual cash saved
17:46:05 <Adamant> unless electric bills shoot up.
17:46:11 <Botty> if you could get ghc to target the cell...
17:46:14 <Baughn> I bet they would around here - electrical bills are through the roof
17:46:26 <dons> if someone gave one of the porters a cell box
17:46:37 <Botty> lol
17:46:47 <Adamant> just wait until the PS3 is released
17:46:49 <dons> at some point the hardware people should be thinking about donating their boards to the compiler guys ...
17:46:50 <Botty> yeah
17:46:51 <Adamant> "cheap" Cell box!
17:46:55 * Igloo volunteers to be given a cell
17:47:09 <dons> if they really want people to start buying them
17:47:10 <Adamant> PS3 is even running Linux
17:47:15 <Botty> Adamant - that's my plan, if they actually get linux to use the SPEs
17:48:09 <Botty> the yellow dog thing just runs on the PPC, pretty lame
17:48:36 <dcoutts> Botty, you can use the SPE's under linux, they appear as slightly odd devices
17:48:47 <Botty> oh, sweet
17:49:02 <Botty> so i suppose a spacial smp SPE ghc could use them ;)
17:49:08 <dcoutts> I think they get their own special purpose virtual file system for setting them up, getting code running on them etc.
17:49:21 <dcoutts> Botty, that's much harder
17:49:57 <Botty> yes, very difficult, i know, the point is its possible, and very cheap
17:49:57 <dcoutts> the local memory is very small, you'd really have to strip the rts down to the minimum to have it run on the SPEs
17:50:08 <Botty> ah yeah
17:50:28 <dcoutts> currently the rts itself is bigger than the local memory
17:50:34 <Botty> I'm fairly ignorant of haskell's rts, but couldn't it be distributed aross the spes?
17:51:09 <dcoutts> you'd do stuff like scheduling and IO on the host
17:51:21 <Botty> yep
17:51:21 <dcoutts> and major GCs
17:51:22 <pkhuong> also, the SPEs suck on branchy code. You'd likely want to only send them heavily numeric fragments.
17:52:07 <dcoutts> then you're not going to get any advantage from running Haskell on a cell
17:52:18 <Botty> thankfully, the main application of such power would likely be numeric
17:53:10 <dcoutts> I quite like the local memory concept, it's much more predictable than cache
17:55:05 <edwardk>  hrmm. is there an array monad of some sort?
17:55:35 <dons> ST ?
17:55:36 <Botty> edwardk - list monad, and yes
17:55:43 <Botty> at least i think...
17:55:46 <edwardk> maybe instead of concatMap, adds another dimension
17:55:52 <edwardk> botty: the list one i know =)
17:56:30 <edwardk> dons: i mean like a generalization of the List monad to Arrays
17:58:15 <dolio> That might be tough, since the indices of arrays have to be specified.
17:59:15 <edwardk> dolio: yeah just playing with some weird fmap cases and was wondering if someone had done it for arrays
18:05:15 <dons> "a research language and its environment can become pop-culture and its combatants may attempt world domination. ... Haskell would be a good candidate these days. But why not also mentioning C++ in its spring time?"
18:05:20 <dons> LtU.
18:05:36 <syntaxfree> dons: where's that quotation from?
18:06:11 <dons> an LtU thread, here, http://lambda-the-ultimate.org/node/1807#comment-21964
18:06:14 <lambdabot> Title: Want to learn something new | Lambda the Ultimate, http://tinyurl.com/y5xyav
18:06:20 <araujo> oh no, they have found us
18:07:32 <dons> our secret world domination plans are revealed! who's the double agent ?
18:09:47 <syntaxfree> Slashdot hardly covers FP.
18:10:22 <dolio> He should learn Epigram.
18:10:25 <Adamant> how do you bootstrap ghc onto a new machine?
18:10:35 <Adamant> machine architecture
18:10:37 <dons> you compile ghc to .c files on an existing  machine
18:10:43 <dons> then move those .c files to the new machine
18:10:46 <dons> and compile them with gcc
18:10:50 <Adamant> cool!
18:11:07 <dons> see the 'porting' section of the ghc user's guide.
18:11:53 * syntaxfree has got a headache from too much whistling.
18:12:48 <dons> oh nice, Ehud Lamm suggests Haskell first, to th new guy on ltU
18:13:45 <dons> and it seems a widespread view that lisp or erlang can be used as the gateway to haskell
18:13:50 <dons> like haskell-lite without the type system
18:14:40 <dons> it's nice that everyone seems to agree that haskell is ultimately the language to aim for mastery of
18:14:55 <emu> lisp is a gateway drug, yes
18:15:01 <dons> and that erlang, sml, lisp are just stepping stones to haskell (or maybe OCaml)
18:15:11 <dons> though even ocaml is sometimes suggested as a stepping stone to haskell
18:15:26 <dons> no one uses haskell as a stepping stone .. 'cept maybe to epigram
18:16:10 <dolio> Heh.
18:16:34 <dons> i've never seen: learn haskell, it will help you pick up ocaml. its always the other way around
18:16:44 <edwardk> ah, the mutidimensional array thing won't work, the type of the array changes as it goes.
18:16:48 <dolio> Epigram makes you use xemacs, though. Quite a downer. :)
18:16:54 <dons> yeah, was thining that edwardk ....
18:17:03 <edwardk> trying Array Int =)
18:17:07 <dons> wh'ats with these theorem provers needing emacs guis?
18:17:17 <edwardk> dons: lazy programmers
18:17:31 <edwardk> dons: almost no one builds a theorem prover with a UI they rely on emacs or proof general
18:17:36 <emu> emacs is kinda a gui toolkit
18:17:42 <dolio> I guess you can program epigram without xemacs, but then it won't do its half of the work for you.
18:17:55 <edwardk> one of the reason why no one in the windows world proves theorems ;)
18:18:39 <dons> right
18:19:35 <ihope> emacs does proofs?
18:19:46 <ihope> (Or is it Emacs?)
18:19:57 <dolio> People build a mode for their prover in emacs.
18:20:10 <dolio> Instead of writing a gui from scratch.
18:20:39 <dolio> At least, that's how epigram is.
18:20:47 <emu> why reinvent the wheel
18:21:52 <EvilRanter> wow. deriving's quite clever.
18:23:50 <ral1> Word.
18:27:08 <dons> ?type words
18:27:09 <lambdabot> String -> [String]
18:28:52 <emu> ?type many1 letter
18:28:53 <lambdabot> Not in scope: `many1'
18:28:53 <lambdabot>  
18:28:53 <lambdabot> <interactive>:1:6: Not in scope: `letter'
18:29:29 <dons> ?hoogle many1
18:29:30 <lambdabot> Text.ParserCombinators.ReadP.many1 :: ReadP a -> ReadP [a]
18:29:31 <lambdabot> Text.ParserCombinators.Parsec.Combinator.many1 :: GenParser tok st a -> GenParser tok st [a]
18:29:31 <lambdabot> Text.ParserCombinators.ReadP.skipMany1 :: ReadP a -> ReadP ()
18:36:36 <dons> does anyone have some comonad papers to add: http://haskell.org/haskellwiki/Research_papers/Monads_and_arrows#Comonads
18:36:39 <lambdabot> Title: Research papers/Monads and arrows - HaskellWiki, http://tinyurl.com/y5qxtj
18:36:42 <dons> edwardk, Cale?
18:37:00 <dons> I wonder if i should start a reddit thread: "What the hell are comonads?"
18:37:05 <dons> ;)
18:37:31 <ral1> hi dons.
18:37:38 <dons> hey ral1
18:37:43 <ral1> I'm at a hackathon.
18:37:48 <dons> oh?
18:37:50 <ral1> In San Jose.
18:37:51 <dons> which hackathon?
18:37:53 <dons> cool
18:38:00 <ral1> Yeah.
18:38:11 <ral1> I'm really interested to use yi by the way.  I think I've told you before.
18:38:26 <dons> ah yes?
18:38:34 <dons> well, you can ust use it. it makes a reasonable vi :)
18:38:37 <dons> s/just/
18:38:54 <dons> in a lot less code
18:39:04 <dons> what kind of hackathon are you at?
18:39:07 <ral1> Yeah.  in my dreams, I'd like to refactor all the code I use until it's all haskell.
18:39:19 <dons> heh .me too!
18:39:22 <ral1> It's a house full of people with laptops.  Nerds mostly.
18:39:30 <dons> for a specific project?
18:39:30 <ral1> There's a pool and a hot tub and some snacks.
18:39:50 <dons> it's not a ... haskell hackathon is it?
18:41:12 <ral1> dons,
18:41:18 <ral1> dons: I'm sorry, no.
18:41:23 <ral1> People work on their own thing.
18:41:31 <ral1> You can read about it on superhappydevhouse.org
18:45:08 <edwardk> *MArray> listArray (1,10) [1..10] >>= \x -> listArray (1,2) [1*x,2*x]
18:45:08 <edwardk> array (1,20) [(1,1),(2,2),(3,2),(4,4),(5,3),(6,6),(7,4),(8,8),(9,5),(10,10),(11,6),(12,12),(13,7),(14,14),(15,8),(16,16),(17,9),(18,18),(19,10),(20,20)]
18:45:09 <edwardk> works
18:45:13 <edwardk> but its kinda cheesy =)
18:45:53 <edwardk> i really dislike that forced flat key structure.
18:46:01 <ral1> Has anyone worked with polynomials before?
18:46:34 <edwardk> dons: one sec.
18:46:54 <edwardk> The Dual of Substitution is Redecoration is a BIG comonad paper you are missing.
18:47:07 <edwardk> otherwise hrmm, checking my pile of papers
18:48:15 <dons> got that one
18:48:24 <dons> just updating the page now
18:48:47 <edwardk> signals and comonads uustalu and vene
18:51:30 <edwardk> oh and another big one missing, uustalu vene, pardo, recursion schemes from comonads
18:53:27 <edwardk> uustalu has a comonads from inductive and coinductive types paper that i got from the university here but i don't think is online that i'd recommend as well.
18:56:46 <dons> oh, great title for a monad transformer paper, "Semantic Lego", http://citeseer.ist.psu.edu/188147.html
18:56:54 <edwardk> heh
19:00:53 <edwardk> dons: oh yeah, computational comonads and intensional semantics by brookes and geva.
19:01:30 <edwardk> almost to the bottom of the pile of papers that include comonads, filtering out the crap as i go
19:03:05 <edwardk> er thats about it
19:03:11 <dons>  ok. great.
19:03:27 <dons> edwardk++
19:03:37 <edwardk> recursive coalgebras from comonads is also there, capretta uustalu vene, but its way mathy for most fp'ers.
19:10:52 <lisppaste2> edwardk pasted "a cheesy array monad" at http://paste.lisp.org/display/29310
19:10:59 <edwardk> told you it was cheesy
19:11:53 <edwardk> basically just packing and unpacking arrays to pretend they are lists and putting them back together.
19:12:33 <edwardk> might be a lot faster if i turned around and actually took the arrays i got back and counted up those rather than the lists.
19:36:49 <edwardk> is Data.Foldable a 6.6 thing?
19:37:24 <spiffy> how would i go about getting a random number? in either hugs or ghc
19:37:42 <dcoutts> edwardk, yep
19:37:53 <dcoutts> spiffy, see the Random module
19:37:55 <edwardk> dcoutts: k, going through the pain of upgrading then =)
19:38:11 <spiffy> dcoutts: thanks
19:39:13 <edwardk> heh, ok, i'll bite whats the difference between the 'base' and 'core' rpm? =)
19:39:24 <edwardk> way to choose overly generic names =)
19:42:06 <dolio> 'Every time I use vim, I can't help thinking about the fact that "Vim" is also a brand of detergent useful for cleaning toilets.'
19:42:20 <dolio> 'That's why I use vim for PHP programming.'
19:42:27 <edwardk> hehehe
19:42:38 <edwardk> and why i use it to write coldfusion
19:43:46 <edwardk> while i sit here and wait for that to install, has anyone given any thought to what a codo syntax would do/desugar to?
19:44:38 <edwardk> =>> for ; delimited statements i grok, just trying to think of what corner cases there are.
19:46:11 <dolio> Would codo result in a comonad?
19:46:28 <dolio> Or just a value?
19:48:06 <edwardk> well, it seems to me that it would result in a sequence of comonad extensions, that would in the end give you something you could easily extract a value from
19:48:13 <edwardk> but shouldn't do the extraction for you
19:48:57 <edwardk> the <- stuff would be a little funny too i guess
19:49:55 <dolio> Yeah, what's cobind? c a -> (c a -> b) -> c b?
19:50:37 <dolio> That doesn't really seem to lend itself to the same kind of notation as monads.
19:51:00 <dolio> But my comonad experience is pretty small.
19:51:19 <edwardk> w a -> (w a -> b) -> w b yeah
19:51:30 <edwardk> just playing with it to see where it goes
19:51:41 <edwardk> wondering if all folks need is aa comonad syntax to find uses =)
19:52:25 <emu> there is a billboard in Queens with a big logo: "VIM"
19:53:52 <dolio> Maybe dataflow languages would be a better place to look for comonadic syntax.
19:53:58 <dolio> Since that's one of the aplications.
19:54:20 <dolio> Since monad syntax is similar to imperative languages.
19:54:31 <edwardk> yeah but dataflow is far from mainstream and is far from all you can do with comonads
19:55:55 <edwardk> currently playing with codo [[foo]] where  [[ a ; b ]] = a .>> b and [[ x <- a ; b ]] = a =>> \x -> b
19:56:18 <edwardk> pretty standard monadic notation just rebundled to use the =>> and .>> instead
19:57:08 <edwardk> x would be a comonad not a value, unlike the current do syntax. naked expressions like b would return values not comonads, unlike now.
19:58:08 <edwardk> can steal zednenem's comonad transformer idea and go from there =)
19:58:18 <dolio> :)
20:00:06 <ral1> Since y'all were talking about reading papers, does anyone have any suggestions about how to read pdfs online?  It is kind of my least favorite medium.  I'm using ghostview.
20:00:33 <edwardk> i just use acrobat and a big sideways lcd screen
20:00:59 <dons> gv is nice enough
20:01:16 <dolio> You could have google turn it into html.
20:01:25 <edwardk> *gag*
20:01:30 <dolio> :)
20:02:49 <edwardk> 6.6 didn't give us any sort of Control.Comonad did it?
20:03:21 <dolio> Nah.
20:03:23 * syntaxfree is still trying to parse page 15 of Freyd's "Abelian categories".
20:03:47 <dolio> I've seen something like it 3rd party.
20:03:54 <dolio> With state-in-context or whatever.
20:04:07 <dolio> And probably co-reader.
20:04:26 <edwardk> yeah i've got a couple of those
20:04:43 <edwardk> was just checking to make sure we didn't get something official when i wasn't looking
20:04:53 <syntaxfree> I find vim much much easier to use than emacs.
20:05:11 <syntaxfree> Maybe it's because the first text editor I ever used, in the 80s, had modes.
20:05:20 <pkhuong> syntaxfree: it's not your fault.
20:05:41 <edwardk> heh in my case, the first text editor i used, in the 80s was vim, so thats probably why i still use it =)
20:06:10 <syntaxfree> up until 1991, you couldn't import software in Brazil. So there was a local software industry.
20:06:11 <dolio> I learned emacs first, but vim has distinctly more pleasing key bindings for moving around.
20:06:22 <Dylan> I like the c command
20:06:25 <syntaxfree> Complete with cheesy Unix clones, and even a cheesy Mac clone.
20:06:36 <Dylan> e.g. cw, c$, c/(<CR>
20:06:39 <edwardk> syntax: thats incredibly bizarre =)
20:06:46 <syntaxfree> I don't think the cheesy unices had vim, though, and anyway, I had a cheesy DOS clone.
20:07:01 <syntaxfree> it came with a word processor based around a tag language much like HTML.
20:07:08 <syntaxfree> Carta Certa 3 -- the one and only :)
20:07:08 <Dylan> emacs had the problem of not telling me how to close it when it started.
20:07:27 <Dylan> nor me being aware of linux virtual terminals
20:07:57 <edwardk> Dylan: heh yeah thats probably it i was scarred for life as a young kid the first few times i tried to open emacs and it wouldn't relinquish the terminal until i managed to slam ctrl-z =)
20:08:03 <Dylan> I think I must've used control-z, kill -9 %1
20:08:04 <syntaxfree> (a language like HTML, but not close to HTML)
20:08:08 <edwardk> yup =)
20:08:27 <Dylan> vim on the other hand told me how to use it on startup
20:08:44 <syntaxfree> you'd have things like <IN>This is bold text <II>this is italic</IN> this is italic but not bold </II>
20:08:59 <Dylan> my vim config is now rather large, actually. including different text folding, colors, and a permenent status bar (like irssi, mutt, and slrn have)
20:09:07 <syntaxfree> The Carta Certa folks actually predate XML in twenty years in that it had a simple database format involving those tags.
20:09:36 <syntaxfree> (The simple database format being used for those automatic letter generation schemas where you fill in names and addresses)
20:10:01 <Dylan> btw, anyone know a good command-line address book, other than abook?
20:10:17 * syntaxfree just uses his cellphone for addresses.
20:10:32 <Dylan> syntaxfree: for email addresses too.
20:10:43 <Dylan> I'd like to have all contact info for friends in one place.
20:10:43 <syntaxfree> yes, for email addresses too.
20:10:53 <edwardk> Dylan: grep? =)
20:11:03 <Dylan> edwardk: her her.
20:11:09 <syntaxfree> you could code one in 15 lines of Haskell.
20:11:29 <syntaxfree> most of it being probing for command-line flags, too.
20:11:32 <Dylan> I could! but first I need to write a haver client using this infant slang bindings I wrote.
20:12:05 <Dylan> (haver being a toy protocol nobody has ever heard of or is ever likely to use)
20:12:08 <syntaxfree> I'd consider using a web-based app.
20:12:27 <Dylan> well, I could d othat
20:12:33 <syntaxfree> @google haver protocol
20:12:35 <syntaxfree> consider a wiki.
20:12:36 <lambdabot> http://search.cpan.org/~dhardison/Haver-Core-0.08/lib/Haver/Protocol.pm
20:12:45 <pkhuong> syntaxfree: or gmail.
20:12:50 * Dylan whistles.
20:12:52 <Dylan> I want to use mutt. :P
20:13:12 <Dylan> mutt's alias function is just a little too simple as I can't associate phone numbers and such with it
20:13:14 <emu> does vim have decent s-expr movement commands?
20:13:18 <emu> i could never find much
20:13:37 <syntaxfree> VINE.
20:13:45 <syntaxfree> I mean, VINAL.
20:14:15 <emu> i like vim's movement commands, but emacs has all that + very nice s-expr commands
20:14:16 <Dylan> it would not be hard to defne s-expr movement commands
20:14:25 <emu> especially with packages like paredit
20:14:26 <lisppaste2> edwardk annotated #29310 with "a slightly less cheesy array monad" at http://paste.lisp.org/display/29310#1
20:16:22 <edwardk> at least now it counts up elements by striding over arrays.
20:17:08 <Dylan> btw, anyone that writes a program that uses dotfiles:
20:17:20 <Dylan> Never remove and overwrite the dotfile!
20:18:01 <Dylan> This breaks stuff for people that symlink in all their dotfiles from another directory
20:18:48 <edwardk> ok, codo down, next, comonad comprehensions.
20:20:14 <dolio> The latter should be pretty trivial if you have the former.
20:20:19 <edwardk> dolio: yeah =)
20:20:27 <dolio> Or, I suppose, the former and some kind of "guard" function.
20:20:33 <edwardk> dolio: now just trying to figure out what it means in this context.
20:21:05 <edwardk> dolio: trying to find use cases for either basically.
20:21:22 <edwardk> dolio: and unlike do, i can't just throw another keyword at it. codo works
20:21:26 <edwardk> but [] is already taken.
20:21:34 <edwardk> er [ |  ]
20:21:40 <dolio> Yeah.
20:22:20 <dolio> I guess it's not exactly the same situation, either.
20:22:29 <dolio> Since you can have plane boolean expressions in codo.
20:22:34 <dolio> They just get turned into w Bool.
20:22:46 <edwardk> yup
20:23:00 <ChilliX> Stuff to read for people who are interested into nested data parallel programming in Haskell: http://www.cse.unsw.edu.au/~chak/papers/CLPKM06.html
20:23:02 <lambdabot> Title: Research Papers of Manuel Chakravarty, http://tinyurl.com/yyj2ur
20:23:28 <dons> ChilliX: great!
20:23:35 <ChilliX> :)
20:24:58 <dons> One step closer to the massively concurrent future
20:33:26 <dolio> Bah, data parallelism. You youngsters born after 1980.
20:36:18 <ChilliX> dolio: ?
20:36:43 <dolio> That was my 'reddit posix fanboy scoffs at data parallelism' reference.
20:37:34 <dolio> Someone commented that data parallelism would make languages like Haskell more attractive on multi-core machines in the future.
20:38:06 <dolio> And he contended that C and POSIX would work fine.
20:38:39 <ChilliX> C and POSIX to program multicores?
20:38:56 <dolio> I guess.
20:39:20 <dons> hehe
20:39:27 <dolio> He also said TCL was the only functional language he'd heard of, so it's hard to tell if he was for real.
20:39:45 <dons> and I said: we welcome our competitors to use C and Posix on their 80 core machines. In fact, we encourage them to ;)
20:39:45 <ChilliX> I guess for people with strong masochistic tendencies, that's an option.
20:40:06 <ChilliX> dons: lol
20:40:57 <ChilliX> Anybody who wants to do serious parallel programming in C and POSIX just has never tried it.
20:41:26 <dolio> Yeah, well, I guess his argument was that it works fine on current multiprocessors.
20:41:37 * ChilliX fondly remembers how he tortured 4th years students with excatly that in his Distributed Systems course.
20:41:37 <pkhuong-> ChilliX: well... it was really really embarrassingly parallel?
20:41:42 <dolio> But that's like 4 processes to fill all the cpus at most.
20:42:33 <ChilliX> pkhuong: hehe
20:42:36 <pkhuong-> dolio: I have a 400 MHz system with 3 times that. You just don't hang with the right people ;)
20:42:49 <syntaxfree> what _are_ GADTs, after all?
20:43:26 <dolio> :) Yeah, I need to make more friends with exotic hardware.
20:44:01 <ChilliX> Sure you can keep four PEs busy with a C and POSIX program.  Bit of a pain, but possible.
20:44:13 <ChilliX> But 4 PEs is boring.
20:44:14 <dolio> I assume he's talking about conventional 2 - 4 cpu machines.
20:44:33 <dolio> You don't program your Cray with posix threads, I imagine.
20:44:36 <ChilliX> I mean, you can even do it in asm + POSIX, no problem, really.
20:44:37 <Dylan> I think people confuse the interface of unixy OSes with the implementation of unixy OSes.
20:46:44 <Dylan> and this leads them into arguments where they defend the status-quo on the basis of how it looks, when the point is the mechanism of the thing.
20:47:17 <pkhuong-> it'd be good to preemptively ban n=bare@207.237.33.33. I'm gonna guess he's visiting every channel with > n users.
20:48:28 <Cale> dons: are *we* ready for that one? :)
20:49:32 <Cale> (re: wth are comonads)
20:49:52 <InterTwined> LOL THE GAY NIGGER ASSOCIATION OF AMERICA CLAIMS RESPONSIBILITY FOR LILOS DEATH AND SENDS GOOD WISHES TO ALL HIS GAY INTERNET LOVERS.  HAPPY BIRTHDAY LILO! I HOPE YOUR GETTING ALL THE DICKS YOU CAN HANDLE IN HELL!
20:49:53 <InterTwined> LOL THE GAY NIGGER ASSOCIATION OF AMERICA CLAIMS RESPONSIBILITY FOR LILOS DEATH AND SENDS GOOD WISHES TO ALL HIS GAY INTERNET LOVERS.  HAPPY BIRTHDAY LILO! I HOPE YOUR GETTING ALL THE DICKS YOU CAN HANDLE IN HELL!
20:49:54 <InterTwined> LOL THE GAY NIGGER ASSOCIATION OF AMERICA CLAIMS RESPONSIBILITY FOR LILOS DEATH AND SENDS GOOD WISHES TO ALL HIS GAY INTERNET LOVERS.  HAPPY BIRTHDAY LILO! I HOPE YOUR GETTING ALL THE DICKS YOU CAN HANDLE IN HELL!
20:49:58 <Cale> oh look
20:49:59 <Smokey`> ugh, kb.
20:50:07 --- mode: ChanServ set +o Cale
20:50:38 --- mode: Cale set +b *!*@207.237.33.*
20:50:42 --- mode: Cale set -o Cale
20:50:49 <Smokey`> Cale++
20:51:29 <ChilliX> Cale: we do scale very nicely to 16 PEs on sparse matrix vector multiplication with no trailing off of the curve up to this point.  It's only one, but a non-trivial, benchmark and it doesn't tell us about 80 PEs, but it leaves hope.
20:52:04 <Cale> ChilliX: not that -- I was replying to a much earlier message dons directed at me
20:52:17 <ChilliX> ah
20:52:34 <Cale> (regarding starting a "What the hell are comonads?" thread on reddit :)
20:53:01 <dons> Cale: re. comonads, i thought if we started the thread, we might find out if anyone understands them well enough to explain them :)
20:53:11 <Cale> good point
20:53:36 <Cale> It's an easy concept abstractly
20:53:37 <pkhuong-> dons: no, you want "What are comonads used for?"
20:53:59 <dfeuer> What's a comonad?
20:54:10 <dons> "Ask Reddit: Are comonads used in anthing at all?"  :)
20:54:12 <Cale> but I'm not really sure their real uses in structuring domain specific languages is fully known
20:55:06 <Cale> dfeuer: Like monads, only you have extract :: w a -> a instead of return, and split :: w a -> w (w a) instead of join
20:55:28 <dolio> They're used in papers! :)
20:56:09 <dfeuer> I don't remember what join does.
20:56:25 <dfeuer> join :: w (w a) -> w a  ?
20:56:28 <ChilliX> dolio: lol
20:56:30 <dfeuer> err
20:56:35 <dfeuer> m (m a) -> m a ?
20:56:38 <dolio> Join is like concat, only for general monads.
20:56:58 <dfeuer> I don't really have a good grasp of monads :-/
20:57:24 <dfeuer> I mean, I can read the monad laws and such, but it doesn't add up to much in my brain.
20:57:30 <Cale> x >>= f = join (fmap f x)
20:57:33 <dolio> Although I suppose it depends on the monad what effect it has specifically.
20:57:59 <Cale> It tends to do something a little like removing a level of indirection
20:58:22 <Cale> join x = do y <- x; y
20:58:42 <dfeuer> Where'd y come from?
20:58:47 <dfeuer> oh
20:58:48 <dfeuer> duh.
20:58:51 * dfeuer read wrong.
20:58:59 <dolio> > join (*) 2
20:59:01 <lambdabot>  4
21:00:20 <Cale> > join [[1,2,3],[4,5],[6,7,8]]
21:00:21 <dfeuer> Cale, I don't understand that definition of join.
21:00:21 <lambdabot>  [1,2,3,4,5,6,7,8]
21:00:30 <Cale> dfeuer: x computes a computation
21:00:42 <dfeuer> right....
21:00:48 <Cale> so you run x, then it gives you a computation, and you run that
21:00:57 <dfeuer> ohhhhhh
21:00:57 <dfeuer> riht.
21:01:00 <dfeuer> right
21:01:07 <dfeuer> I must be tired.
21:01:12 <Cale> join x = do y <- x; v <- y; return v
21:01:21 <Cale> perhaps that's more obvious somehow?
21:02:14 <dfeuer> It would've been a few minutes ago, but I figured it out already ;-)
21:02:18 <dons> http://programming.reddit.com/info/pgwc/comments
21:02:21 <lambdabot> Title: Hot off the press: Data Parallel Haskell: a status report (reddit.com), http://tinyurl.com/sgv5w
21:02:34 <dons> i wonder if 365 new hasell papers are published a year
21:10:47 <Pete_I> doubting it
21:11:16 <Pete_I> wouldn't doubt php gets more papers than haskell though
21:11:24 <Pete_I> ugh...
21:11:29 <dons> heh, you reckon? i don't think i've ever seen a php paper
21:11:43 <Pete_I> depends how you define "paper"
21:12:37 <dons> peer review research papers. there's 10 haskell papers at the haskell workshop each yeah, another 10 or so at ICFP, then maybe 5 at PADL, 5 at POPL, some more at CUFP, TLDI, TFP, HIM... I wouldn't be surprised that there were 100 a year
21:13:37 <Pete_I> ah, in that case, i'd be supprised if php got 4/year
21:14:19 <dons> i.e. if you look over the 100s on haskell.org published in the last 20 years here , http://haskell.org/haskellwiki/Research_papers
21:14:23 <lambdabot> Title: Research papers - HaskellWiki, http://tinyurl.com/yx8sfs
21:14:25 <dons> at that's not even close to getting them all
21:15:07 <dons> ah, scholar.google.com sez Results 1 - 10 of about 11,900 for haskell, under the CS subcategory
21:15:21 <ral1> Wooooorrrrrrrdddddd..   ral1 here representing Haskell at the superhappydevhouse hacka-a-thon in San Jose!!!!!!
21:15:27 <dons> oh, but that includes a few authors named haskell
21:15:30 <dons> hey ral1.
21:15:33 <dons> how's the hot tub?
21:15:35 <ral1> hey dons.
21:15:43 <ral1> I've no time for hot tub.
21:16:03 <ral1> I'm hanging out with a group of no less than a half dozen people who are TOTALLY excited about haskell.
21:16:15 <ral1> We're implementing some polynomial algebra
21:16:21 <dons> good! :) hack hack hack
21:16:28 <dons> ral1++
21:16:39 <edwardk> ral1: =)
21:20:02 <dons> maybe we could get one of these to run lambdabot on, http://www.sun.com/emrkt/blackbox/index.jsp?cid=250292
21:20:04 <lambdabot> Title: Project Blackbox, http://tinyurl.com/yg484f
21:26:18 <ral1> I'm trying to post the code that we're writing to the haskellwiki, but no luck.
21:26:27 <dons> why isn't it working?
21:34:08 <ral1> dons: ehhh.   I don't know... I've not done it before.  It seems that you have to create a user... I'm working on it.  We're having fun, by the way.
21:34:46 <dons> you do.
21:34:54 <dons> just register a name and a password
21:34:59 <dons> then you can create pages and so on
21:35:08 <dons> clicking on 'login' should do the trick
21:35:27 <dons> haskell source can be colorised by wrapping it in <haskell> </haskell> tags in the wiki
21:37:29 <ral1> dons: I'm logged in.  I created a link called AddPolynomials.  Uhhhhh... I think it's right on the front page.  At least it is when I'm loged in.  But when I click on it, it gives me all these crazy errors.
21:37:54 <dons> hmm
21:38:05 <dons> i don't think the page is created yet
21:38:09 <dons> let me create it for you
21:38:10 <dons> ...
21:38:21 <dons> what do you want the title to be?
21:39:21 <Pupeno> Was network.alt deprecated in favor of Network 2.0 (GHC 6.6) ?
21:39:54 <ral1> Okay.  Simple question.  How do you create a link?  I thought it was DoubleCaps, but that didn't seem to work.   .   Bear with me.  I'm almost there.
21:40:05 <dons> ral1, here you go: edit this page: http://haskell.org/haskellwiki/Add_Polynomials
21:40:08 <lambdabot> Title: Add Polynomials - HaskellWiki, http://tinyurl.com/y27jsn
21:40:10 <dons> you'll need to log in to edit it
21:40:34 <dons> ral1, I see you've logged in as Ral1 , good
21:40:43 <dons> and you've been editing your own talk page?
21:42:35 <dons> Pupeno: I think network.alt has been moved to become the new extra network package?
21:42:38 <dons> i think...
21:43:05 <dons> ral1, got the page up? you worked out how to edit it?
21:43:09 <Pupeno> dons: by moved you mean moved into GHC as Network ?
21:43:39 <dons> there's an extra network package distributed with ghc now. but i'm not sure if its the old network factored out, or if it was network.alt moved in
21:43:55 <dons> check the cvs log, or ask musasabi/Lemmih/et al when they're around
21:45:38 * Lemmih doesn't know.
21:48:12 <AI_coder> any nerds want to have a conversation?
21:48:20 <AI_coder> i know if you're in a math irc channel maths debating you've got to be a nerd
21:48:39 <dons> hi AI_coder. provocative as usual
21:48:44 --- mode: ChanServ set +o Cale
21:48:53 <Lemmih> Pupeno: I don't think so.
21:49:05 --- mode: Cale set +b AI_coder!*@*
21:49:33 <Pupeno> Lemmih: so, I should still use net-alt.
21:49:38 <dons> yes. he should be kicked and banned.
21:49:42 <dons> same pattern as before
21:49:43 --- kick: AI_coder was kicked by Cale (Cale)
21:49:55 <dons> 06.10.15:23:53:49 <AI_coder> Who likes maths debating?
21:50:02 --- mode: Cale set +b *!*=AI@*.eatel.net
21:50:08 --- mode: Cale set -o Cale
21:50:38 <dons> Cale: does he come here from #math?
21:50:51 <lispy> another one of Cale's fan bois :)
21:50:57 <Cale> No, I just banned him there afterward though too
21:51:04 <dons> good.
21:51:16 <Lemmih> Pupeno: Yes.
21:51:17 <Cale> (he was doing the same thing simultaneously in both channels)
21:51:24 <Pupeno> Ok. thanks.
21:51:37 <dons> he's almost a clone of gschuett/protontorpedo, in that he follows a script
21:52:04 <dons> this is almost protontorpedo's twin brother: <AI_coder> So the difference between ai and technology is what?
21:52:31 <Lemmih> Pupeno: network-2.0 is just network-1.0 minus the CGI module, afaik.
21:52:53 * lispy wonders if there is a script kiddie forum full of "annoying guy on irc" scripts
21:52:55 <Pupeno> Ok. Thanks.
21:53:03 <Cale> "Firefox Vista problem , News Google new Toolkit Ajax" -- is this even being written by a human?
21:53:11 <dons> ral1, you worked out the editing. good
21:53:42 <lispy> Cale: i would say no
22:24:12 <Pete_I> Cale, if it is, they don't speak english very well
22:24:33 <Pete_I> have the subject-adjective mixed up :/
22:50:31 <lispy> man, if you turn your back on reddit for like a minute tons of stupid crap gets posted :)
22:51:57 <edwardk> what is 'reddit'?
22:52:11 <lispy> http://programming.reddit.com/
22:52:14 <lambdabot> Title: reddit.com: programming - what&#39;s new online
22:52:26 <lispy> edwardk: a news aggregator where you get to vote on the articles posted
22:52:59 <edwardk> ah, one of those digg type things, etc.
22:54:12 <dons> lispy: so true
22:54:25 <dons> all the crap makes me hold back getting a 'freedom from the press' tshirt :)
22:54:34 <Botty> yeah, look at that number 1, jeez ;P
22:54:42 <dons> i'm fairly happy with the quality of programming.reddit.com though
22:54:56 <dons> seems to be a good bunch of people keeping an eye on that. lisp hackers ++
22:55:09 <dons> Botty: heh
22:55:11 <pkhuong-> dons: it's been going downhill for the last couple months.
22:55:27 <dons> pkhuong-: I wonder if programming.reddit can be turned around?
22:55:32 <dons> i'd hate to have to fork :)
22:56:08 <dons> there's really room for a quality programmer site, more dynamic and less academic than LtU
22:56:51 <dons> having this cross-posted to the front page - i'm not sure if that's helpful
22:56:54 <dons> s/things/
22:57:45 <pkhuong-> dons: i've been meaning to build something to let people share annotations on webpages/pdfs, etc. Add a hotness index and it might be interesting.
22:57:45 <dons> s/fairly happy/there's 2 articles a day in the top 20 that i find interesting/ hmm
22:59:01 <dons> yeah, if something better came along, which worked, and could maintain quality somehow (via and idiot-captcha ;) that'd be cool
22:59:12 <dons> s/and/an/
22:59:46 <pkhuong-> but, MS Paint in Java and expression templates for matrices in CL first.
23:00:04 <dons> heh
23:00:09 <dons> then $profit1
23:00:48 <pkhuong-> dons: then haskell, I think.
23:00:59 <dons> great!
23:01:53 <dons> you've reached stage2 of the path to typed lambda goodness: stage 1) pre-contemplation. 2) contemplation 3) hacking 4) world domination
23:02:08 <pkhuong-> wow. Veldhuizen's (Blitz++) phd thesis has an average of ~.5 footnote/page.
23:02:30 <pkhuong-> dons: i'm afraid I'll try to bring parallelisation to CL though ;)
23:02:35 <dons> hehe.
23:03:32 <dons> re. Veldhuizen, that's pretty good for fairly obscure work, in the scheme of things. I guess plugins/extensible compilers (that's the guy, right?) are hot
23:05:01 <pkhuong-> yeah, guaranteed optimisations + generatively optimised DSELs.
23:07:11 <lispy> ?type splitBy
23:07:12 <lambdabot> Not in scope: `splitBy'
23:45:19 <pzpz> How would I do:  String ++ IO String ?
23:47:38 <pzpz> nevermind. spelling errors are elusive.
23:48:31 <lispy> ioString >>= \x -> string ++ x
23:48:33 <lispy> that's one wa
23:52:02 <dons> ?pl ioString >>= \x -> string ++ x
23:52:02 <lambdabot> (string ++) =<< ioString
23:52:18 <dons> ?pl ioString >>= \x -> return (string ++ x)
23:52:19 <lambdabot> (string ++) `fmap` ioString
23:52:38 <pzpz> yaya. I wasn't aware that failing to escape a backslash resulted in a pretty unhelpful error message.
23:52:58 <pzpz> Client.hs:17:21: lexical error in string/character literal
23:53:07 <pzpz> b
23:56:30 <Botty> its worse when its a legal escape, eg: "oh\noes"
23:57:37 <Lemmih> Unhelpful? It tells you what's wrong and where the error located.
23:58:28 <Botty> Lemmih - stuff like this should be considered bad for the sake of improving compilers for noobs.
23:58:37 <pzpz> Lemmih: true. but as with most languages -- the compiler output is usually most helpful when you've keyed the general faults for all messages.
23:59:03 <dons> pzpz: that's a pretty good error , i think. :)
23:59:19 <pzpz> speaking of keying -- other than map, are there are any real hash implementations in the prelude?
23:59:29 <dons> Data.Map and Data.HashTable
23:59:33 <dons> Data.IntMap too
23:59:36 <Botty> My main problem is with compilers that have giant numbered lists of errors
23:59:42 <dons> for other uses, there's HsJudy
23:59:45 <pzpz> checking it out.
23:59:53 <dons> Data.Map is almost always what you want
