00:09:56 <pzpz> bah, i'm trying to write a simple function that uses Data.Map to somewhat from a limited char set to a gimpy ascii-value. however, some magical monad m is getting in my way
00:10:13 * pzpz needs to proofread
00:10:30 <pzpz> ...somewhat map from a limited...
00:10:55 <Lemmih> You probably want that monad to be Maybe.
00:11:46 <pzpz> i'm not actually using any monads explicitly
00:12:26 <pzpz> lisp.org is struggling, so here's the simple code: http://paste.lisp.org/display/30713
00:13:29 <pzpz> it complained about giving a type definition to alleviate an issue with a monad "m", and what i came up with doesn't seem help other than providing another error message.
00:13:58 <Korollary> pzpz: think about the type of the expression import qualified Data.Map as M
00:13:58 <Korollary> nmap = M.fromList (zip ([1..9]++[0]) "AEGIORTX!0")
00:14:02 <Korollary> amap = M.fromList (zip "AEGIORTX!0" ([1..9]++[0]))
00:14:02 <Korollary> msg = "ITG!AAEXEXIRRG!GRXIOIXGEREAGO"
00:14:02 <Korollary> toAscii :: Ord k => [k] -> (M.Map k a) -> [a]
00:14:02 <Korollary> toAscii []     _ = []
00:14:02 <Korollary> toAscii (x:xs) m = (M.lookup x m) : toAscii xs m
00:14:04 <Korollary> Couldn't match expected type `a' (a rigid variable)
00:14:07 <Korollary>            against inferred type `m a'
00:14:09 <Korollary>       `a' is bound by the type signature for `toAscii'
00:14:12 <Korollary>         at homework9.hs:7:36
00:14:14 <Korollary> err
00:14:17 <Korollary> sorry
00:14:33 <Korollary> pzpz: think about the type of (M.lookup x m)
00:14:45 <pzpz> hm
00:14:53 <Korollary> ?type Data.Map.lookup
00:14:54 <lambdabot> forall a (m :: * -> *) k. (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
00:15:22 <Korollary> the result is of type "m a" as long as stands for some kind of Monad.
00:15:26 <pzpz> it's belonging to some monad
00:15:54 <Korollary> right. toAscii doesn't take that kind of argument.
00:16:11 <dons> ?yow
00:16:12 <lambdabot> Now I am depressed ...
00:16:18 <dons> ?users
00:16:18 <lambdabot> Maximum users seen in #Haskell: 64, currently: 62 (96.9%), active: 2 (3.2%)
00:16:27 <dons> weird..
00:16:29 <Korollary> netsplit
00:16:32 <dons> ah
00:16:39 <dons> and the channel changed
00:16:44 <dons> that's odd.
00:16:49 <Korollary> yeah the maximum changed somehow?
00:16:59 <dons> "#Haskell"
00:17:05 <Botty> uhh
00:17:22 <Korollary> did you have a maximum for "#Haskell" ?
00:17:27 <Korollary> er
00:17:33 <dons> ?users #haskell
00:17:33 <lambdabot> Maximum users seen in #haskell: 276, currently: 134 (48.6%), active: 10 (7.5%)
00:17:37 <dons> ?seen lambdabot
00:17:38 <lambdabot> Yes, I'm here. I'm in #scannedinavian, #unicycling, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell-overflow, #haskell-blah, #Haskell and #ScannedInAvian
00:17:53 <dons> netsplits are weird
00:17:54 <Korollary> wow
00:18:00 <Korollary> channel renaming split
00:18:08 <pzpz> i'm not sure then how to build a list from a value in a monad
00:18:21 <pzpz> >>: ? haha
00:18:21 <dons> in which monad?
00:18:32 <dons> ?type replicate
00:18:35 <lambdabot> forall a. Int -> a -> [a]
00:18:36 <dons> ?type repeat
00:18:37 <lambdabot> forall a. a -> [a]
00:18:53 <dons> > return (replicate 7 'x') :: Maybe [Char]
00:18:55 <lambdabot>  Just "xxxxxxx"
00:19:12 <pzpz> dons: i'm trying to build a list from repeated Data.Map.lookups
00:19:16 <pzpz> which return type (m a)
00:19:17 <Korollary> pzpz: you need to decide which monad you want the result to be in. For instance, Data.Maybe was suggested.
00:19:28 <dons> yep. pzpz you can constrain it to Maybe, usually
00:19:38 <dons> its the most useful monad for lookups, I find
00:19:47 <dons> since you get Nothing if its not found
00:20:00 <dons> and then you could use catMaybes or some such to get all the lookups that worked, as a list
00:20:03 <dons> ?docs Data.Maybe
00:20:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Maybe.html
00:20:10 <Korollary> list is a monad, too.
00:20:11 <dons> pzpz: its a nice little puzzle :)
00:20:12 <metaperl> lisppaste2 must be dead?
00:20:17 <metaperl> ?paste
00:20:18 <lambdabot> http://paste.lisp.org/new/haskell
00:20:24 <dons> netsplit badness?
00:20:32 <dblhelix> again?
00:20:46 <dons> ?seen lisppaste2
00:20:46 <lambdabot> I saw lisppaste2 leaving #darcs and #haskell 2h 7m 24s ago, and .
00:20:48 <metaperl> anyway, I created an infinite loop when I had hoped to take terms of this additions lazily: http://paste.lisp.org/display/30715
00:20:51 <pzpz> dons, Korollary : got it, just need to figureout how to get rid of all the Justs :)
00:21:10 <Botty> hah, wow, splits really mess with bots
00:21:15 <dons> ?type catMaybes
00:21:16 <lambdabot> forall a. [Maybe a] -> [a]
00:21:22 <dons> pzpz ^^ the type sez it all ;)
00:21:29 <dblhelix> no Justs there :)
00:21:36 <dons> metaperl: wrong language? :)
00:21:38 <pzpz> ahh
00:22:07 <dons> metaperl: though some laziness-in-perl6 examples would be cool.. :)
00:22:24 <metaperl> dons - ? sAdd a b = s : sAdd b s where s = a + b  -- seems simple enug but it creates  an infinite loop
00:22:46 <dons> sure. you'll need to take some results
00:22:52 <dmead> hey dons
00:23:01 <metaperl> i'm trying to write something to do successive additions... but it created an infinite loop as soon as I ran it: http://paste.lisp.org/display/30715
00:23:12 <dons> is that a scanl, I think it is.
00:23:24 <metaperl> > let s = a + b in sAdd a b = s : sAdd b s
00:23:25 <lambdabot>  Parse error
00:23:55 <dons> ?type let f a b = s : f b s where s = a + b in f 1 2 
00:23:57 <lambdabot> forall a. (Num a) => [a]
00:24:09 <dons> > let f a b = s : f b s where s = a + b in f 1 2
00:24:10 <lambdabot>  [3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711,28...
00:24:17 <dons> > let f a b = s : f b s where s = a + b in take 10 $ f 1 2
00:24:19 <lambdabot>  [3,5,8,13,21,34,55,89,144,233]
00:24:38 <metaperl> dons - what is wrong with my code : http://paste.lisp.org/display/30715
00:24:57 <dons> looks ok to me.
00:25:01 <dons> how are you using that function?
00:25:08 <metaperl> I just called it
00:25:12 <metaperl> sAdd 2 4
00:25:27 <metaperl> it spewed an infinite stream of numbers immediately
00:25:37 <dons> *M> take 10 $ sAdd 1 2
00:25:37 <dons> [3,5,8,13,21,34,55,89,144,233]
00:25:48 <dons> metaperl: of course it will , you demanded the result :)
00:25:53 <dons> and it tried to provide it
00:26:04 <metaperl> i thought it would be lazy and do nothing
00:26:10 <metaperl> guess not 
00:26:14 <dons> you want to bind the result, I think:
00:26:15 <dons> *M> let ns = sAdd 1 2
00:26:16 <dons> *M> 
00:26:25 <dons> *M> ns !! 10
00:26:25 <dons> 377
00:26:43 <dons> but if you try to evaluate it in just as "sAdd 1 2" , you're asking for the entire result
00:27:01 <metaperl> ok now I want to create a list which shows the ratio between successive terms
00:27:01 <dons> it does lazily generate the list though, as you wanted
00:27:05 <pzpz> is there any way to force evaluation?
00:27:23 <dons> pzpz: seq/length/$!/$!!/bang patterns/case/... the list is long :)
00:27:33 <dons> metaperl: ok. so a fold over taht list
00:27:38 <pzpz> i mean, 
00:27:43 <dons> metaperl: you have a clue for how to fold over it?
00:27:45 <dons> or want hints?
00:27:53 <metaperl> yeah, take some and then fold
00:27:54 <pzpz> ie:   let a = [really expensive comprehension]
00:27:57 <metaperl> no seed needed
00:28:06 <dons> metaperl: right. no need to take till after the fold though
00:28:12 <pzpz> if i call a 5 times, will it recompute the list?
00:28:15 <dons> pzpz: nope
00:28:27 <dons> lazy, shared values forever
00:28:36 <dons> it'll compute it once, then share that result
00:28:38 <pzpz> oh, goodie.
00:28:45 <dons> since its pure, its not going to change its value
00:29:04 <dons> (unlike a side effecting function, where the result depends also on whatever the global state is doing)
00:29:08 <pzpz> dons: any good documenation on haskell internals?
00:29:15 <dons> language internals?
00:29:19 <dons> or compilers?
00:29:26 <metaperl> wait, if I'm dividing two integers but want floating point results, what do I do... take 10 $ foldl (/) (sAdd 4 5)
00:29:42 <dblhelix> @seen SyntaxNinha
00:29:42 <lambdabot> I haven't seen SyntaxNinha.
00:29:44 <pzpz> dons: either. all i know is that it's a lazy pure language.
00:29:44 <dons> all the documentation under the sun is at haskell.org (you probably want to read the 'Spineless tagless G machine" paper
00:29:47 <dblhelix> @seen SyntaxNinja
00:29:48 <lambdabot> I saw SyntaxNinja leaving #haskell, #darcs and #haskell-blah 4d 4h 42m 39s ago, and .
00:29:55 <dons> visit http://haskell.org, and begin your quest :)
00:29:58 <lambdabot> Title: Haskell - HaskellWiki
00:30:00 <pzpz> dons: ty :)
00:30:06 <dons> metaperl: / should be ok
00:30:09 <therp> good morning
00:30:18 <dons> you might need fromIntegral if you've constrained the type somewhere
00:30:23 <metaperl> pzpz - wikipedia has a free book on Haskell called YAHT... a lot ofpeople like it.
00:30:29 <dons> ?where yaht
00:30:30 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
00:30:33 <dons> yeah, it's rather good
00:30:58 <dons> > fix ((1:) . scanl (+) 1) -- ok, a lazy list
00:30:59 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
00:31:14 <pzpz> i've been reading "The Craft of Functional Programming", any opinions on that?
00:31:36 <dmead> dons: you any good with parsec?
00:31:48 <metaperl> pzpz - i'm reading it too -- i like it
00:32:12 <dons> > let ns = fix ((1:) . scanl (+) 1) in scanl1 (/) ns
00:32:14 <lambdabot>  [1.0,1.0,0.5,0.16666666666666666,3.333333333333333e-2,4.166666666666667e-3,3...
00:32:54 <dons> metaperl: if you want all the results, lazily, you need scanl (or scanl1) not foldl
00:33:01 <dons> foldl is a scanl that returns only the last result
00:33:02 <metaperl> take 10 ( foldl (/) (sAdd 123 980) ) 
00:33:11 <metaperl> oh
00:33:17 <metaperl> I dont know scanl... more to learn
00:34:21 <metaperl> zvon is my friend - http://www.zvon.org/other/haskell/Outputprelude/scanl_f.html
00:34:24 <lambdabot> Title: Haskell : scanl, http://tinyurl.com/y27shh
00:34:27 <dons> ?type foldl 
00:34:29 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
00:34:37 <dons> > foldl1 (+) [1..10]
00:34:39 <lambdabot>  55
00:34:43 <dons> > scanl1 (+) [1..10]
00:34:45 <lambdabot>  [1,3,6,10,15,21,28,36,45,55]
00:34:47 <dons> all the results
00:35:08 <dons> > \xs -> let _=xs::[Int] in last (scanl (+) xs) == foldl (+) xs
00:35:09 <lambdabot>    Expecting a function type, but found `[a]'
00:35:09 <lambdabot>    Expected type: [a]
00:35:09 <lambdabot>   ...
00:35:17 <dons> > \xs -> let _=xs::[Int] in last (scanl1 (+) xs) == foldl1 (+) xs
00:35:19 <lambdabot>  <[Int] -> Bool>
00:35:27 <dons> ?check \xs -> let _=xs::[Int] in last (scanl1 (+) xs) == foldl1 (+) xs
00:35:29 <lambdabot>  Exception: Prelude.last: empty list
00:35:33 <dons> heh
00:35:44 <dons> ?check \xs -> not (null xs) ==> let _=xs::[Int] in last (scanl1 (+) xs) == foldl1 (+) xs
00:35:45 <lambdabot>  OK, passed 500 tests.
00:36:08 <metaperl> take 10 ( scanl (/) h t ) where h = head s ; t = tail s' s = sAdd 23 12  -- generate idea
00:36:10 <dons> metaperl: that's the relationship between foldl(1) and scanl(1)
00:36:18 <dons> yep
00:36:48 <dblhelix> dons: are you familiar with cabal internals?
00:37:26 <dons> metaperl: btw, I saw your blog recently about "no junior haskell positions" very interesting. I know that we teach haskell to many non-programmers (i.e. in comp1A-style courses) so I don't think the language is necessarily the issue. any thoughts on what is problematic would be interesting though
00:37:31 <dons> dblhelix: a little, not a lot
00:37:33 <gour> dons: i complained that lib docs are missing examples long ago...so your effort is very welcome ;)
00:37:46 <dons> dmead: don't use parsec much. i'm roughly familiar with it
00:37:50 <dons> gour: cool!
00:38:08 <dons> gour: I think ideally a wiki version of the haddocks, that generated darcs patches, would be ideal...
00:38:18 <dons> so anyone reading the docs online could fix them, and submit a darcs patch
00:38:36 <dblhelix> dons: any idea where and when cabal decides when a file is to be recompiled again?
00:38:37 <gour> right
00:38:46 <dons> dblhelix: well, it asks ghc, or hugs, or ...
00:38:50 <dons> which then decides
00:38:59 <metaperl> dons - I guess the huge issue is how quickly you can do the things you can do in "Learning Perl" --- where most of them are I/O based and way more intuitive in Perl right off the bat... sure you are hanging yourself for large scale software design, but Monads right off the bat can confuse people
00:39:16 <dons> exactly! I couldn't agree more
00:39:24 <dons> we need 'Practical Haskell' that starts with IO
00:39:29 <dblhelix> dons: in this case, it's about a preprocessed file
00:39:33 <gour> dons: but, i hope examples will end up in official docs as well?
00:39:37 <dons> since its really rather easy, i guess people want to spend more time solving hard problems
00:39:46 <dons> gour: yes, that's the plan
00:39:52 <gour> dons: coll ;)
00:39:53 <dons> i've been adding them manually when people ask here
00:39:59 <dons> but a better process would be good
00:40:28 <dons> metaperl: so i've been writing a few 'real world' tutes, the unix tools one, and the irc bot
00:40:40 <dons> and there are some plans for a full 'practical haskell' book floating around
00:40:49 <dons> metaperl: so you've definitely spotted a hot issue
00:40:55 <Korollary> plans?
00:41:01 <metaperl> CosmicRay has had that plan for awhile
00:41:12 <dons> we just have so many theory lovers who're happy to blog and write about STM, monads, comonads, topology,.... :)
00:41:15 <metaperl> I think "haskell on all 8 cylinders" is what he's doing?
00:41:29 <dons> oh, i've not heard of that.
00:41:46 <metaperl> it's an SGML book at his website
00:41:48 <dons> we'll probably see 5 'practical haskell's next year or two...
00:41:54 <metaperl> @google haskell on 8 cylinders
00:41:57 <lambdabot> http://www.syntaxpolice.org/darcs_repos/haskell-v8/haskell-v8.pdf
00:41:58 * dons needs to finish phd first.
00:42:07 <dons> oh, SyntaxNinja, not CosmicRay?
00:42:25 <metaperl> how do I flip the arguments to (/)
00:42:28 <metaperl> @type flip
00:42:30 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
00:42:32 <dons> ah, it is cosmicRay, just one syntaxninja's site
00:42:35 <Korollary> I am writing bits of the reports in a linear fashion for myself. It's quite difficult.
00:42:40 <dons> metaperl: flip, or use a lambda
00:42:42 <dons> ?type (/)
00:42:44 <lambdabot> forall a. (Fractional a) => a -> a -> a
00:42:46 <metaperl> (/) . flip
00:42:47 <dons> ?type flip (/)
00:42:48 <lambdabot> forall b. (Fractional b) => b -> b -> b
00:42:57 <metaperl> (/) . flip 2 4
00:43:01 <dons> ?type (\x y -> y / x)
00:43:03 <lambdabot> forall a. (Fractional a) => a -> a -> a
00:43:07 <dblhelix> dons: how much time left on for your phd?
00:43:08 <metaperl> ? (/) . flip 2 4
00:43:14 <dons> > flip (/) 2 4
00:43:16 <lambdabot>  2.0
00:43:22 <dons> > (/) 2 4
00:43:23 <lambdabot>  0.5
00:43:30 <dons> dblhelix: 6 months!
00:43:46 <dblhelix> dons: ouch :)
00:43:56 * dblhelix has another 2.5 years
00:44:01 <Korollary> dons: what's after?
00:44:08 <dons> $profit of course :)
00:44:13 <dblhelix> but I wonder where the first 1.5 went :)
00:44:14 <dons> i'll start a commerical monad tutorials business
00:44:19 <Korollary> heh.
00:44:26 <dons> dblhelix: hehe
00:44:48 <Korollary> we need telemarketing.
00:45:08 <Korollary> "This fantastic tutorial is yours for $20 if you call right now!"
00:45:09 <dons> i saw an article on the news tonight about outsourcing tutoring from US to India
00:45:11 <Svrog> i kinda wonder how much haskell tutorials will help in making people more interested in haskell
00:45:37 <dons> maybe we could start $20/hr (that's the bangalore rate) haskell-tutoring in here :)
00:45:54 <dons> Svrog: applications are much much better
00:45:58 <dons>  and commerical adoption
00:46:16 <dons> so pugs, darcs, ... ++ and credit suisse, linspire, galois, ... ++ :)
00:46:41 <Svrog> no matter how simple the tutorials are, most programmers have a hard time understanding why they even need monads or why they'd want to use haskell instead of say python
00:47:07 <Svrog> yes, applications would probably me more useful
00:47:09 <Korollary> They don't "need" to use haskell. The case must be made by well written applications.
00:47:19 <dons> my not so secret theory is that massive multicore machines will be so disruptive that everyone will be using erlang and haskell by 2010
00:47:49 <dons> so i'm writing a multicore irc bot for this month's monad.reader
00:47:55 <gour> dons: language in (haskell) tutorials has to be more simple and free from (unnecessary) academic jargon if you want average programmers becoming interested using haskell as general-programming language.
00:48:04 <dons> when you get implicit smp scalability with basically zero effort, that's gotta look good
00:48:13 <dons> gour: agreed
00:48:43 <dons> real code, real problems: we know how to solve them (people have been working on the theory for 20 years). getting that across to the average joe python-man is the next step
00:48:47 <gour> dons: "if you cannot explain to 5-year old kid, then it means...". not exactly, but in that spirit
00:48:57 <arcatan> some kind of practical haskell tutorial would be useful
00:48:59 <Svrog> gour: i still dont know how much that will help
00:49:27 <dons> we just have to do things that the other guys can't do well.
00:49:34 <dons> that's why ruby-on-rails worked.
00:49:44 <Korollary> by giving away code
00:49:45 <gour> Svrog: based on my experience in the attempt to share haskell (although learning it by myself) it would
00:49:49 <dons> now, there's a bunch of things that are nicer in haskell, but there's also a few killers in their domain
00:50:04 <dons> things like parsec/compiler constructoin, and anything that requires verification.
00:50:12 <dons> and now , big multicore problems
00:50:36 <Svrog> most programmers look for languages that look easier at first glance
00:50:42 <gour> Svrog: lot of people complained that "haskell is for intellectual mast.", ie. not very practical
00:50:50 <Svrog> thats why basic used to be so popular
00:50:52 <Svrog> it looked easy
00:50:52 <dons> so showing how foo-bar is a bit nicer in haskell, that's been going on for a few years, and is somewhat good. but showing some really hard problems that are way easier in haskell, that might help
00:50:56 <Svrog> python is the new basic
00:51:13 <arcatan> parsec is really a killer application
00:51:24 <arcatan> or, a library
00:51:34 <Korollary> Not a lot of people write parsers, though. Maybe they should, but they don't.
00:51:51 <dons> the thing is that haskell is highly practical: you can go from writing OS's in it, to filesystems, to editors, to compilers, to web servers , to theorem provers
00:51:59 <dons> there's not that many languages covering such a range
00:52:02 <Svrog> well the other thing is that a whole bunch of other languages now have their own parser combinator libs inspired by parsec
00:52:24 <dons> so just because there's a lot of theory and hard research in there, doesn't mean it isn't pracitcal: the goal of the research is to solve practical problems in a better way
00:52:39 <Svrog> even boost spirit was inspired by parsec
00:52:47 <dons> oh, didn't know that. very interesting
00:53:01 <Svrog> i think it says it in the docs
00:53:07 <Svrog> hang on - ill try to find it
00:53:25 <metaperl> there's someting wrong with the output of my scanl call: http://rafb.net/paste/results/Zs6pYB26.html
00:53:26 <arcatan> everybody always says that Haskell is truly mind-blowing experience. While that is nice, it doesn't give very practical image of haskell
00:53:41 <Korollary> It's practical to blow your own mind.
00:53:44 <dons> arcatan: yeah. we have to show the code. show the apps
00:54:18 <dons> what's wrong with it metaperl ?
00:54:29 <metaperl> the result of the first division is 1.0
00:54:36 <metaperl> but the first two terms are 2 and 1
00:54:38 <metaperl> 2 / 1 = 2
00:55:05 <dons> try scanl with a default of 1 for the first value
00:55:10 <dons> (you want the tail of the list, I think)
00:55:24 <metaperl> why didnt it take the first two terms as documented
00:55:43 <metaperl> http://www.zvon.org/other/haskell/Outputprelude/scanl1_f.html
00:55:45 <lambdabot> Title: Haskell : scanl1, http://tinyurl.com/vlpsv
00:55:54 <dons> -- | 'scanl1' is a variant of 'scanl' that has no starting value argument:
00:55:54 <dons> --
00:55:54 <dons> -- > scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
00:55:57 <dons> see the x1
00:56:11 <metaperl> oh it dups it
00:56:27 <metaperl> That zvon page is wrong. WRONG
00:56:34 <dons> read the real docs :)
00:56:40 <dons> ?docs Data.List
00:56:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
00:57:10 <dons> isn't the zvon page also unmaintained/old?
00:59:05 <metaperl> I dont now
00:59:11 <metaperl> i emailed webmaster@svon.org just now
00:59:21 <Svrog> maybe im lying :(
00:59:27 <Svrog> cant find anything about parsec in spirit docs
00:59:35 <dons> yeah, anyway, I think you're the only person still reading zvon's page: grab the haddocks instead :)
01:01:12 <dons> metaperl: just for fun, here's something to ponder:
01:01:15 <dons> > unfoldr (\(a,b) -> let s = a + b in Just (s, (b,s))) (0,1)
01:01:16 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
01:02:07 <dblhelix> dons: did you just write a histomorphism? ;)
01:02:18 <dons> heh
01:02:19 <gour> dons: btw, what's with paste lisppaste? it's not present in eg. #haskell.hr any longer?
01:02:28 <dons> oh. hmm. netsplit?
01:02:39 <dons> is lambdabot2 still in #haskell.hr?
01:02:43 <dons> ?users
01:02:45 <lambdabot> Maximum users seen in #Haskell: 64, currently: 62 (96.9%), active: 2 (3.2%)
01:02:57 <gour> dons: yes
01:02:59 <dons> hmm. lambdabot is a bit kooky
01:03:16 <Korollary> more than 2 active
01:03:47 <Korollary> well, is the definition of active depend on channel size?
01:03:57 <Korollary> I can't form coherent sentences.
01:04:15 <dons> the active count means "spoke in the last 4 hours"
01:04:30 <Korollary> well, obviously more than 2 active then
01:04:42 <Svrog> #haskell.hr? a croatian haskell channel?
01:04:44 <dons> mm, weird, lambdabot",":[#Haskell]
01:04:48 <dons> Svrog: yep
01:04:49 <int-e> but it didn't see all users ... so
01:04:51 <Svrog> cool :)
01:04:57 <Korollary> 4 hours is way too long imho.
01:04:58 <gour> Svrog: yes, at least attempt
01:05:00 <dons> ?wiki IRC_channel
01:05:23 <lambdabot> http://www.haskell.org/haskellwiki/IRC_channel
01:06:29 <int-e> hmm.
01:07:30 <dons> ?users
01:07:31 <lambdabot> Maximum users seen in #Haskell: 198, currently: 197 (99.5%), active: 7 (3.6%)
01:07:44 <dons> this channel name change is weirding me out
01:08:23 * dons tries again
01:08:36 <int-e> @users #haskell
01:08:36 <lambdabot> Maximum users seen in #haskell: 276, currently: 3 (1.1%), active: 1 (33.3%)
01:08:40 <int-e> @users #Haskell
01:08:40 <lambdabot> Maximum users seen in #Haskell: 198, currently: 197 (99.5%), active: 7 (3.6%)
01:08:46 <int-e> ow
01:08:57 <metaperl> I want to rework a list of integers into a collection of 2-tuples. E.g: [1,2,3,4,5,6] => [(1,2), (2,3), (3,4), (4,5), (5,6)]
01:09:16 <Heffalump> how did the name change?
01:09:20 <int-e> dons: you saw that? it treats #haskell and #Haskell as different channels
01:09:35 <Heffalump> or is it just that someone confused it by joining #Haskell?
01:09:56 <pzpz> metaperl : you can do (x:y:zs)
01:09:57 <greentea> Hi all.
01:10:34 <metaperl> pzpz - yes, thanks
01:10:36 <metaperl> greentea hi
01:10:38 <dons> int-e: yeah.
01:10:44 <dons> but why did the name appear at all?
01:10:59 * gour reports that paste is working in #haskell.hr now
01:11:05 <pzpz> metaperl: you'll just need more special cases :(
01:11:25 <metaperl> no, I'm fine. I'm dealing with an infinite list
01:11:56 <pzpz> ahh
01:12:00 <dons> > let n = [1..] in zip n (tail n)
01:12:02 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12,...
01:12:11 <metaperl> oh sweet
01:12:18 <pzpz> you could also do it ninja style :(
01:12:25 <dons> laziness forever!
01:13:10 <dons> pzpz: you mean the 'zip' is ninja style?
01:13:49 <dons> trying a different irc server
01:14:03 <pzpz> more ninja than:
01:14:34 <pzpz> > let n (x:y:z) = (x,y) : n z in n [1..]
01:14:57 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21,...
01:15:07 <pzpz> i thought i was retarded for a moment.
01:15:30 <dons> heh
01:15:40 <dons> you're zipping with (,) though
01:15:47 <dons> > zipWith (,) [1..] [1..]
01:15:49 <lambdabot>  [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11),(12,1...
01:15:51 <pzpz> > let n (x:y:z) = (x,y) : n (y:z) in n [1..]
01:15:51 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12,...
01:15:52 <dons> > zipWith (+) [1..] [1..]
01:15:53 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
01:16:05 <dons> > zipWith (,) [1..] [2..]
01:16:06 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12,...
01:16:17 <dons> > let s = zipWith (,) s (tail s)
01:16:18 <lambdabot>  Parse error
01:16:30 <dons> > let s = [1..] in zipWith (,) s (tail s)
01:16:31 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12,...
01:16:32 <pzpz> pretty neato
01:16:36 <int-e> @users #haskell
01:16:36 <dons> > let s = [1..] in zip s (tail s)
01:16:36 <lambdabot> Maximum users seen in #haskell: 276, currently: 199 (72.1%), active: 11 (5.5%)
01:16:37 <lambdabot>  [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12,...
01:16:41 <dons> :)
01:16:42 <int-e> weird.
01:17:13 <dons> int-e: so I had it join the irc.freenode server, instead of a weird russian one i'd been using since the great netsplit of a couple of weeks ago
01:17:18 <dons> ?users
01:17:19 <lambdabot> Maximum users seen in #haskell: 276, currently: 199 (72.1%), active: 11 (5.5%)
01:17:23 <dons> so that looks right
01:17:26 <dons> ?users #haskell
01:17:27 <lambdabot> Maximum users seen in #haskell: 276, currently: 199 (72.1%), active: 11 (5.5%)
01:17:30 <dons> ?users #Haskell
01:17:30 <lambdabot> Maximum users seen in #Haskell: 198, currently: 195 (98.5%), active: 11 (5.6%)
01:17:36 <dons> hmm.
01:17:38 <int-e> he he
01:17:38 <dons> ah well
01:17:50 <dons> at least it thinks it's here.
01:21:30 <dibblego> can it join #jtiger by default? :)
01:21:31 <int-e> strangely everything seemed all right before the crash earlier today
01:23:48 <metaperl> lisppaste2 back?
01:24:07 <dmead> i think lambdabot needs to understand a netsplit ;o
01:24:25 <lisppaste2> metaperl pasted "scanl is killing me!" at http://paste.lisp.org/display/30717
01:24:50 <dblhelix> is haskell.org down??
01:25:03 <greentea> dblhelix: i'm having trouble accessing Hoogle at the moment.
01:25:11 <johnnowak> dblhelix: it isn't responding for me.
01:25:33 <dmead> same here
01:26:26 <int-e> metaperl: you want \a b -> a/b or just (/), I think
01:26:45 <metaperl> int-e - pairing returns tuples though
01:27:05 <int-e> metaperl: oh. but then you need \(a,b) (c,d) -> something  as the first argument to scanl
01:27:15 <metaperl> oh!!!!!
01:27:45 <int-e> (where 'something' is a pair again)
01:27:49 <int-e> err
01:28:01 <int-e> yes.
01:28:19 <pzpz> > let d = (mod 1 2) / 3
01:28:20 <lambdabot>  Parse error
01:29:18 <pzpz> how do I avoid that ambiguity other than using no monomorphic types?
01:31:43 <dons> dblhelix: hmm. might be down
01:34:29 <dons> hmm, that's not an ambiguity :)
01:34:36 <dons> > > let d = (mod 1 2) / 3 in d
01:34:36 <lambdabot>  Parse error
01:34:43 <dons> > let d = (mod 1 2) / 3 in d
01:34:44 <lambdabot>  Add a type signature
01:34:55 <dons> that is though
01:34:55 <pzpz> i'v eadded Int to everything, still not working :(
01:35:01 <therp> I think I woke up tonight, because my dream stopped type checking. I mean I didn't mind because a bad dream anyway.. but, still.
01:35:10 <therp> +it was
01:35:20 <dons> let d = fromIntegral (mod 1 2) / 3 in d
01:35:23 <vincenz> heya dons
01:35:23 <lambdabot> vincenz: You have 1 new message. '/msg lambdabot @messages' to read it.
01:35:30 <dons> > let d = fromIntegral (mod 1 2) / 3 in d
01:35:30 <vincenz> @messages
01:35:31 <lambdabot>  0.3333333333333333
01:35:31 <lambdabot> pkhuong said 1d 8h 13m 32s ago: i'd help you with the JS, but I don't have a lot of time and you're not here. Paste the script if you want.
01:35:47 <dons> pzpz, see the type of mod vs the type of (/)
01:35:48 <pzpz> dons: dur. i just looked that definition oto
01:35:49 <dons> ?type mod
01:35:50 <lambdabot> forall a. (Integral a) => a -> a -> a
01:35:50 <dons> ?type (/)
01:35:52 <lambdabot> forall a. (Fractional a) => a -> a -> a
01:35:58 <dons> ?type fromIntegral
01:36:00 <lambdabot> forall b a. (Num b, Integral a) => a -> b
01:36:26 <dons> unless you want integer div, i.e. `div`
01:36:30 * vincenz waves
01:36:34 <dons> > (mod 1 2) `div` 3
01:36:36 <lambdabot>  0
01:36:36 <dons> heya vincenz !
01:36:43 <metaperl> is there some pretty printer for lists? I want each element on a separate line
01:36:45 <dons> > fromIntegral (mod 1 2) / 3
01:36:47 <lambdabot>  0.3333333333333333
01:36:54 <dons> metaperl: you can write one: map print xs
01:37:05 <vincenz> metaperl: what about "intercalate "\n" . map show $ xs"
01:37:16 <metaperl> @type intercalate
01:37:18 <lambdabot> Not in scope: `intercalate'
01:37:24 <vincenz> intercalate will be in 6.8
01:37:24 <dons> intercalate = concat . intersperse
01:37:27 <metaperl> MissingH has that
01:37:32 <vincenz> dons: not quite
01:37:38 <metaperl> unlines
01:37:38 <dons> > concat . intersperse "\n" $ map show [1..10]
01:37:40 <lambdabot>  "1\n2\n3\n4\n5\n6\n7\n8\n9\n10"
01:37:41 <metaperl> @type unlines
01:37:42 <lambdabot> [String] -> String
01:37:45 <vincenz> dons: notice the extra param
01:37:49 <dons> > unlines . concat . intersperse "\n" $ map show [1..10]
01:37:49 <lambdabot>  Couldn't match `String' against `Char'
01:37:54 <metaperl> @type lines
01:37:56 <lambdabot> String -> [String]
01:37:58 <dons> > lines . concat . intersperse "\n" $ map show [1..10]
01:37:59 <lambdabot>  ["1","2","3","4","5","6","7","8","9","10"]
01:38:05 <dons> > map print . lines . concat . intersperse "\n" $ map show [1..10]
01:38:07 <lambdabot>  [<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO...
01:38:10 <dons> :)
01:38:15 * dons gets funky monad style
01:38:15 <vincenz> :D
01:39:05 <metaperl> to use intersperse, I must import what?
01:39:13 <ski> @type mapM print
01:39:15 <lambdabot> forall a. (Show a) => [a] -> IO [()]
01:39:28 <Heffalump> @type mapM_ print
01:39:30 <lambdabot> forall a. (Show a) => [a] -> IO ()
01:39:30 <ski> s/mapM/mapM_/
01:39:44 <ski> (:
01:41:24 <dibblego> dons, is it possible to have lambdabot permanently in #jtiger or is it at the channel limit?
01:41:49 <vincenz> dibblego: what is jtiger?  the tiger language in java or the new java language?
01:42:00 <vincenz> lambdabot: @channels
01:42:00 <lambdabot> Unknown command, try @list
01:42:02 <vincenz> @seen lambdabot 
01:42:03 <lambdabot> Yes, I'm here. I'm in #scannedinavian, #unicycling, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell-overflow, #haskell-blah, #haskell, #Haskell and #ScannedInAvian
01:42:09 <dibblego> vincenz, it's a crappy thing I wrote for unit testing in Java a couple of years ago
01:42:22 <vincenz> Heh, scannedinavian is nearly empty
01:42:25 <vincenz> dibblego: oh right
01:42:31 <vincenz> dibblego: You know that tiger is a "language" right?
01:42:37 <vincenz> just an fyi :0
01:42:45 <vincenz> @join #jtiger
01:42:46 <dibblego> yes
01:42:58 <vincenz> There you go :)
01:43:01 <dibblego> ta
01:44:35 <dons> dibblego: we can do that. i'll add it to the config list
01:44:55 <dibblego> dons, thanks
01:46:53 <dons> metaperl: use hoogle to find intersperse
01:46:56 <dons> ?hoogle intersperse
01:46:57 <lambdabot> List.intersperse :: a -> [a] -> [a]
01:47:02 <dons> i.e. Data.List 
01:47:17 <metaperl> dons - thanks. I forget about hoogle. It is a terrific resource
01:47:22 <dons> ?index intersperse
01:47:23 <lambdabot> Data.List
01:47:34 <dons> (not as smart as hoogle)
01:50:34 <dons> looks like haskell.org is back, i wonder if its sunday morning cron jobs
01:50:48 <opqdonut> :)
01:51:54 <pzpz> haskell can't evaluate exponents of a negative degree?
01:52:18 <opqdonut> pzpz: different exponentations
01:52:24 <opqdonut> ?type (**)
01:52:27 <opqdonut> ?type (^)
01:52:34 <lambdabot> forall a. (Floating a) => a -> a -> a
01:52:36 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
01:52:46 <opqdonut> ?type exp
01:52:48 <lambdabot> forall a. (Floating a) => a -> a
01:53:01 <pzpz> ahhhh
01:53:03 <opqdonut> ?type ^^
01:53:05 <lambdabot> parse error on input `^^'
01:53:08 <opqdonut> ?type (^^)
01:53:10 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
01:53:19 <dons> pzpz: haskell can if you believe it can :)
01:53:35 <dons> (its not an inherant language limitation ;)
01:53:40 <Lemmih> Anyone got some simple quickchecks?
01:54:13 <Heffalump> ?check 1==2
01:54:14 <lambdabot>  Falsifiable, after 0 tests:
01:54:16 <nornagon> where can i find a good list of exercises in haskell?
01:54:24 <dons> Lemmih: yep: www.cse.unsw.edu.au/~dons/code/pqc/examples/Example.hs
01:54:35 <dons> (i think that's it)
01:54:58 <metaperl> nornagon - SJT's book?
01:55:13 <Lemmih> dons: Great, thanks.
01:55:57 <nornagon> metaperl: ?
01:56:03 <opqdonut> ?check repeat a == tail $ repeat a
01:56:03 <lambdabot>  Not in scope: `a'
01:56:13 <metaperl> nornagon - what sort of exercises do you want?
01:56:16 <opqdonut> ?check repeat 1 == tail $ repeat 1
01:56:16 <lambdabot>    Expecting a function type, but found `a'       Expected type: [a],      ...
01:56:36 <opqdonut> ?check (repeat 1) == (tail $ repeat 1)
01:56:42 <lambdabot> Terminated
01:56:45 <opqdonut> :)
01:57:14 <Lemmih> dons: Is the last property supposed to fail?
01:57:41 <nornagon> metaperl: some simple stuff to start with, but also some more complicated things as well - i'm reading through the Clean book, they have a lot of good ones. Things like various list acrobatics, binary tree stuff, etc.
01:57:50 <nornagon> not sure quite how to describe what i want.
01:58:09 <metaperl> nornagon - oh . well have you seen YAHT?
01:58:12 <metaperl> ?YAHT
01:58:13 <lambdabot> Unknown command, try @list
01:59:22 <dons> Lemmih: i think so ... i just took it from the quickChcek docs
01:59:26 <metaperl> nornagon - i keep a faq of interesting things I notice here: http://www.livingcosmos.org/Members/sundevil/haskell/faq
01:59:30 <lambdabot> Title: FAQ &mdash; The Living Cosmos, http://tinyurl.com/vzxov
01:59:39 <dons> Lemmih: use some equational reasoning :)
02:00:48 <nornagon> metaperl: cool, i'll check out YAHT, and that faq page looks funky
02:00:52 * Lemmih has written an automatic quickcheck tester using the ghc-api.
02:00:58 <metaperl> :)
02:00:59 <dons> Lemmih: hmm!
02:01:06 <dons> Lemmih++
02:01:41 <Lemmih> Called 'cabal-test'. Run it near a cabal project and it will automatically test the library and binaries.
02:01:55 <dons> cool!
02:01:59 <Lemmih> (the quickcheck functions don't even have to be exported)
02:02:18 <dons> ah, it runs the quickcheck properties in a src tree? 
02:02:25 <dons> very tricksy!
02:02:26 <Lemmih> It sucks that ghc-6.6 doesn't parse haddock info.
02:03:56 <lisppaste2> metaperl annotated #30717 with "problem zipping a list with itself" at http://paste.lisp.org/display/30717#1
02:04:09 <Lemmih> dons: I'm interpreting the files. The export list can be avoided that way.
02:04:30 <dons> yep
02:05:51 <dons> metaperl: your first argument to zip is an Integer
02:05:52 <dons> not a list
02:06:11 <dons> you need to generate your lazy list of sAdds
02:06:13 <dons> and zip that
02:06:24 <dons> ?let sAdd a b = s : sAdd b s where s = a + b
02:06:25 <lambdabot> Defined.
02:06:29 <metaperl> dons - that wasnt true until I added that type signure
02:06:43 <dons> ah, the type sig is wrong :)
02:06:56 <dons> what's the type of sAdd :)
02:06:59 <metaperl> i need infinitely large integers
02:07:05 <metaperl> oh!!!
02:07:05 <metaperl> ack
02:07:09 <dons> hehe
02:07:25 <metaperl> different error now
02:07:27 <dons> I use a script to infer the type sigs
02:07:33 <dons> avoiding those kind of typos
02:08:22 <lisppaste2> metaperl annotated #30717 with "no instance for /" at http://paste.lisp.org/display/30717#2
02:10:14 <metaperl> is there an infinitely large floating point type?
02:11:13 <dons> metaperl: 
02:11:14 <dons> ratio :: Integer -> Integer -> [(Integer, Integer, Double)]
02:11:14 <dons> ratio a b = [ (a,b, fromIntegral b / fromIntegral a) | (a,b) <- pairing a b ]
02:11:24 <dons> metaperl: nope, only in external libraries
02:11:28 <dons> or use Ratio
02:11:36 <dons> ?type 1233213212 % 1231231232
02:11:37 <lambdabot> forall a. (Integral a) => Ratio a
02:11:47 <dons> > 1233213212 % 1231231232
02:11:48 <lambdabot>  4003939%3997504
02:11:50 <dons> ?docs Data.Ratio
02:11:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Ratio.html
02:13:05 <metaperl> @type fromIntegral
02:13:07 <lambdabot> forall b a. (Num b, Integral a) => a -> b
02:13:35 <dons> converting the Integer to something suitable for /
02:14:21 <metaperl> yes b / a is causing problems - expected type Double (from type signature) inferred type Integer (because of its operands)
02:14:46 <dons> right, that's what the fromIntegral is for
02:15:50 <Lemmih> dons: When does 'pRun' stop?
02:15:56 <dons> wow. the world has changed. i'm watching tv and an add for a mobile phone supporting "blogging" comes on...
02:16:20 <dons> Lemmih: when the list is used up:
02:16:21 <dons>     forM_ [1..n] $ forkIO . thread work chan
02:16:21 <dons>     let wait xs i
02:16:21 <dons>             | i >= n     = return () -- done
02:16:21 <dons>             | otherwise = case xs of
02:16:23 <dons>                     Nothing : xs -> wait xs $! i+1
02:16:25 <dons>                     Just s  : xs -> putStr s >> hFlush stdout >> wait xs i
02:16:28 <dons>     wait ps 0
02:17:01 <dons> the threads just take jobs from the list until the list of jobs is empty
02:17:12 <vincenz> off to lunch
02:21:24 <Svrog> when compiling multiple files, does ghc pass all the c files to gcc at once or does it call gcc individually for each file?
02:23:30 <Svrog> is there a way to get it to pass all the files to gcc all at once? other than manually generating the c sources and then passing that to the compiler
02:23:47 <jmmv> hi
02:23:50 <Svrog> hi
02:25:38 <flux__> svrog, gcc *.c ?
02:25:45 <Svrog> huh
02:25:54 <Svrog> no i mean when compiling haskell files
02:25:56 <flux__> suitable for generating a single object, though
02:25:59 <flux__> oh, right :)
02:26:11 <flux__> I didn't even think I was on #haskell when I saw that question :-)
02:26:11 <fik> @djinn ((a->b) -> c -> a)
02:26:11 <lambdabot> -- f cannot be realized.
02:26:25 <fik> @djinn (a->b) -> c 
02:26:26 <lambdabot> -- f cannot be realized.
02:27:02 <Svrog> was just wondering cause gcc v4 has -combine command line argument which allows it to do whole program optimization but it needs all the sources passed to the compiler at once
02:27:54 <Svrog> no idea whether it would make any difference for haskell code though
02:28:17 <dons> Svrog: hmm.very interesting!
02:28:32 <dons> we can certainly do it: --keep-tmp-files to dump all the .c in a dir
02:28:47 <dons> and add --combine to the command ghc would normally use
02:29:04 <dons> Svrog: but this is almost certainly worth a query on the glasgow-haskell-user@haskell.org mailing list. please!
02:29:21 <dons> perhaps include a link to the -combine info page
02:29:40 <Svrog> haha np
02:29:56 <opqdonut> @help djinn
02:29:56 <lambdabot> djinn <type>.
02:29:57 <lambdabot> Generates Haskell code from a type.
02:29:57 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
02:30:04 <dons> ?djinn a -> b -> (a,b)
02:30:04 <lambdabot> f a b = (a, b)
02:30:07 <dcoutts> all you'd have to do is generate the .hc files for each .hs module
02:30:12 <dons> ?. pl djinn a -> b -> (a,b)
02:30:12 <lambdabot> f = (,)
02:30:14 <dcoutts> then use gcc -combine on them all
02:30:21 <Svrog> btw i sent an email to the haskell cafe mailing list regarding that hashing function
02:30:27 <opqdonut> ?djinn a -> b -> c
02:30:28 <lambdabot> -- f cannot be realized.
02:30:30 <dons> dcoutts: right. but then I wonder if maybe ghc should even get its own -combine flag.. if its worthwhile
02:30:46 <dons> opqdonut: you ever used a theorem prover in an irc bot before? :)
02:30:46 <opqdonut> ?djinn a -> (b -> a)
02:30:47 <lambdabot> f a _ = a
02:30:56 <opqdonut> dons: hehe :)
02:31:08 <opqdonut> ?djinn (a -> b) -> a
02:31:09 <lambdabot> -- f cannot be realized.
02:31:11 <opqdonut> :(
02:31:14 <dcoutts> dons, I expect it isn't. It's mostly for higher level C optimisations which gcc can't do anyway for ghc-generated code.
02:31:19 <opqdonut> ?djinn (a -> a) -> a
02:31:19 <lambdabot> -- f cannot be realized.
02:31:25 <opqdonut> ?type fix
02:31:26 <lambdabot> forall a. (a -> a) -> a
02:31:31 <opqdonut> :D i won
02:31:42 <dcoutts> dons, however whole program optimisation for ghc itself... totally different story.
02:31:47 <dons> yep
02:32:10 <dons> ?djinn Either a b -> Either b c -> Either a c
02:32:10 <lambdabot> -- f cannot be realized.
02:32:16 <dons> ?djinn Either a b -> Either b c -> Either a (b,c)
02:32:17 <lambdabot> -- f cannot be realized.
02:32:26 <dons> ?djinn Either a b -> Either b a
02:32:26 <lambdabot> f a =
02:32:27 <lambdabot>   case a of
02:32:27 <lambdabot>   Left b -> Right b
02:32:27 <lambdabot>   Right c -> Left c
02:32:31 <opqdonut> not perfect i see
02:32:55 <opqdonut> ?djinn a
02:32:56 <lambdabot> -- f cannot be realized.
02:33:12 <opqdonut> ?djinn (a,a) -> a
02:33:13 <lambdabot> f (a, _) = a
02:33:21 <opqdonut> ?djinn (a,a) -> [a]
02:33:22 <lambdabot> -- f cannot be realized.
02:33:27 <opqdonut> :(
02:33:38 <dons> recursive types are a bit hard
02:33:51 <opqdonut> true
02:34:09 <opqdonut> ?djinn a->b
02:34:09 <lambdabot> -- f cannot be realized.
02:34:11 <dons> more info: http://www.cse.unsw.edu.au/~dons/code/lambdabot/scripts/Djinn/examples
02:34:13 <lambdabot> http://tinyurl.com/y7ga6w
02:34:29 <fik> :)
02:38:38 <augustss> ?users
02:38:38 <lambdabot> Maximum users seen in #haskell: 276, currently: 216 (78.3%), active: 24 (11.1%)
02:39:07 <opqdonut> ?users #scannedinavian
02:39:07 <lambdabot> Maximum users seen in #scannedinavian: 3, currently: 2 (66.7%), active: 0 (0.0%)
02:39:12 <opqdonut> :D
02:40:43 <dons> ?users #perl6
02:40:43 <lambdabot> Maximum users seen in #perl6: 167, currently: 121 (72.5%), active: 2 (1.7%)
02:40:54 <dons> cool, that's up 20 since last time i checked
02:47:07 <flux__> hmm.. been reading c.l.c++.m and the topic of undefined behavior popped up (again) - does haskell have any?
02:49:42 <augustss> arithmetic overflow
02:50:18 <Svrog> when you drop an IO monad you can get all sorts of weird stuff happening - some of that may qualify as undefined behavior :)
02:51:01 <augustss> IO doesn't really count, it's undefined by design :)
02:51:05 <Svrog> true
02:51:07 <Svrog> hehe
02:53:02 <Heffalump> surely IO is reasonably well defined, it's unsafePerformIO that isn't
02:53:13 <Heffalump> (ok, it's not defined as part of the language standard)
02:53:34 <Heffalump> in H98, attempting to store more than 29 bits of info in an Int is undefined.
02:53:45 <augustss> it also interacts with the rest of the world, so anything can happen
02:53:50 <Heffalump> oh, augustss said that, sorry
02:54:07 <Heffalump> augustss: yes, but in a defined way depending on what the rest of the world does
02:54:24 <augustss> true
02:55:07 <Heffalump> time and space behaviour is completely undefined
02:55:57 <augustss> yes, but that's true for almost all languages
02:56:12 <Heffalump> sure, I'm just scraping the bottom of the barrel here :-)
02:56:18 <augustss> heh
02:56:22 <Heffalump> don't some languages mandate tailcall optimisation in certain circumstances?
02:57:00 <augustss> yes, scheme
02:57:27 <dons> the interactions between some of the -fglasgow-exts aren't written down, I suspect...
02:57:42 <pzpz> > 5 :: (Real Integer)
02:57:43 <lambdabot>    Class `Real' used as a type
02:57:44 <lambdabot>   In the type `Real Integer'
02:57:44 <lambdabot>   In an exp...
02:58:01 <pzpz> how do I define a type to be of that class?
02:58:18 <augustss> instance Real Foo where ...
02:58:21 <dons> instance Real MyType where ... body of real instance ....
02:58:44 <Heffalump> does the H98 catch operation catch non-IO errors?
02:58:44 <dons> pzpz: you want to define your own Reals? :)
02:59:22 <augustss> well, some of them might be called non-IO errors.  like UserError
02:59:23 <pzpz> no. i'm just trying to have arbitrary-long division in a few functions
02:59:28 <xinming> Pastorn: ping
02:59:32 <augustss> but they are all gnereated in the IO monad
02:59:36 <Heffalump> oh, it's probably not defined what happens if you implement a type class without satisfying the rules that type class implies, sicne the implementation of library code is not defined
03:00:05 <pzpz> > 5/2 :: Integer
03:00:07 <lambdabot>  add an instance declaration for (Fractional Integer)
03:00:07 <lambdabot>   In the expression:...
03:00:10 <augustss> well, are there any rules required by any classes?
03:00:13 <xinming> @tell Pastorn hmm, sorry, my system rebooted yesterday, so, I lost the channel name for your room, please tell me again. :-)
03:00:13 <lambdabot> Consider it noted.
03:00:34 <Heffalump> instance Eq Foo where { x == y = True ; x /= y = True }
03:00:39 <Heffalump> that'd probably confuse some things
03:00:54 <augustss> I don't tthink so.  it would only confuse people :)
03:01:28 <Heffalump> I'm sure there are library operations that use Eq and Ord which could use any of the underlying operations in their implementation.
03:01:39 <Heffalump> Then their behaviour would be undefined, since we can't see the implementations.
03:01:45 <pzpz> :t 5/2
03:01:54 <pzpz> >:t 5/2
03:01:59 <augustss> Sure, like sort.  But the library operations are defined by their sample Prelude code
03:02:33 <augustss> so they must behave like that when given weird instances
03:02:33 <Heffalump> isn't there an implicit assumption that the underlying type class will be correctly implemented?
03:02:43 <augustss> There shouldn't be
03:02:45 <Heffalump> Otherwise their implementations are unnecessarily constrained
03:02:47 <Heffalump> hmm, ok
03:03:31 <augustss> Well, I know that I took great care when implementing Haskell not to use any assumptions about what instances should do.
03:03:58 <augustss> Because the report sure didn't use to specify anything.  that could have changed.
03:04:20 <Heffalump> you're right that itdoesn't seem to
03:04:34 <pzpz> > 5/2 :: Fractional
03:04:36 <lambdabot>    Class `Fractional' used as a type
03:04:36 <lambdabot>   In the type `Fractional'
03:04:36 <lambdabot>   In an...
03:04:48 <pzpz> i give up. how do i use Fractional Integers?
03:06:17 <TSC> pzpz: What do you want to do with them?
03:06:21 <augustss> pzpz: what do you want to do?
03:06:28 <TSC> (Maybe you want Ratio Integer?)
03:06:29 <augustss> > 5 `div` 2
03:06:30 <lambdabot>  2
03:06:48 <augustss> > fromIntegral 5 / 2
03:06:49 <lambdabot>  2.5
03:06:56 <augustss> > 5%2
03:06:58 <lambdabot>  5%2
03:07:44 <augustss> integers are by definition not fractional.  they have no decimals
03:07:49 <fik> @hoogle fix
03:07:50 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
03:07:50 <lambdabot> Control.Monad.Fix :: module
03:07:50 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
03:07:51 <Heffalump> oh, what "undefined" causes to be printed out is not defined ;-)
03:08:03 <fik> @doc Control.Monad.Fix
03:08:03 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-Fix.html
03:08:15 <augustss> Heffalump: it should make the program loop :)
03:08:27 <Heffalump> the prelude implies that it should cause the program to abort
03:08:33 <Heffalump> s/prelude/report/
03:08:45 <Heffalump> it's just the message associated with this that is not defined
03:08:46 <augustss> bah, weaklings!
03:09:07 <Heffalump> I bet you'd prefer rm -rf /
03:09:09 <pzpz> i have the funvtion :    d = (rMod (e**(-1)) phi)
03:09:36 <pzpz> and it seems I can't figure out how to get all the types to play together at this hour.
03:09:41 <augustss> it can't do rm -rf / unless it has IO type
03:10:04 <Heffalump> oh, yeah
03:10:06 <augustss> pzpz, you probably want Double
03:10:28 <pzpz> augustss: no, i'd like arbitrary length
03:10:40 <augustss> pzpz: fromInteger is a good way to convert an Integer to a Double
03:11:19 <augustss> pzpz: there are no arbitrary precision floating point numbers.  nor any real numbers.
03:11:45 <augustss> well, there are libraries, but they don't come with Haskell
03:12:12 <pzpz> what the hell is (Fractional Integer) then that ghci keeps babbling about? 
03:12:35 <augustss> It's probably complaining there there is no such thing.
03:12:54 <augustss> that you are trying to use it, but it doesn't exist
03:13:22 <pzpz> augustss: ah, that's a possibility
03:14:12 <Syzygy-> pzpz: Are you doing RSA right now?
03:14:18 <pzpz> Syzygy-: yep.
03:14:44 <augustss> pzpz: but RSA doesn't need anything but Integer
03:14:54 <Syzygy-> Figures. Now, if you write it that way, you're introducing division in a type that doesn't support and doesn't understand it.
03:15:14 <Syzygy-> That's where the Fractional comes from. The e**(-1) means 1/e, and thus is a division, requiring the Rationals.
03:15:31 <Syzygy-> But what you really want to do is use the Euclidean algorithm to find the inverse of e mod phi.
03:16:25 <pzpz> Syzygy-: i began reading about the extended euclidean algorithm, but ran off to do haskell first :(
03:16:39 <Syzygy-> pzpz: You really, REALLY, need to read up on it.
03:16:56 <Syzygy-> That's the way you get around to getting fractions mod things.
03:17:14 <Syzygy-> Since you don't want to calculate in the rationals, but rather in the units of Z/phiZ
03:17:51 <pzpz> Syzygy-: understandable. reading what I should have read now :)
03:18:58 <psnl> anyone here looked at the ghc internals?
03:19:55 <Lemmih> psnl: Kinda.
03:21:20 <psnl> is it easy to understand?
03:21:26 <Lemmih> No.
03:21:49 <psnl> ok, cool. I'll stick that idea back on the pile
03:22:58 <gour> Lemmih: what would happen if simons get hit by the bus?
03:26:12 <Lemmih> gour: It'd be the end of Haskell as we know it (:
03:26:49 <gour> Lemmih: right and it's not good at all
03:30:45 * Oejet starts a fund raising to put soft cushions on all Cambridge buses.
03:31:18 <gour> Oejet: is it enough?
03:31:28 <augustss> the internals are not easy to understand. but nor are they impossible to understand
03:32:03 <gour> ok, but how many people could resume ghc-dev?
03:32:25 <augustss> still, we should encourage the simons not to get hit by busses
03:32:43 <augustss> for their own sake :)
03:32:57 <gour> right, let'em live looooong
03:33:30 <augustss> gour: i think the question is if you can find others that will be funded to do ghc work
03:33:37 <gour> still, isn't it scary taht haskell compiler(s) are depending on just a bunch of people (including jhc & yhc) ?
03:34:01 <augustss> with funding, you could find enough people to continue the work
03:34:08 <gour> hopefully
03:34:12 <augustss> gour: I don't find it scary
03:34:52 <augustss> there are plenty of people competent enough to write a haskell compiler
03:34:59 <gour> augustss: you would jump to another language?
03:35:00 <ich660> hi
03:35:14 <augustss> gour: no, i'd keep using haskell
03:35:16 <Lemmih> ich660: Hiya.
03:35:30 <thegraham> Sorry for a newbie question, but if I've got a list [False,True,True,False] is there a function that returns True if the list contains True and False if it doesn't?
03:35:45 <augustss> the answer is: yes
03:35:51 <augustss> :)
03:36:04 <Syzygy-> > any id [False, True, True, False
03:36:05 <lambdabot>  Parse error
03:36:05 <Syzygy-> ]
03:36:07 <ich660> i am a haskell newbie, and i need help, hope to find it here
03:36:08 <Syzygy-> > any id [False, True, True, False]
03:36:10 <lambdabot>  True
03:36:22 <Syzygy-> > any not [False, True, True, False]
03:36:23 <lambdabot>  True
03:36:34 <augustss> > or [False, True, True, False]
03:36:36 <lambdabot>  True
03:36:49 <Syzygy-> augustss: Won't work for [True]
03:37:04 <augustss> > or [True]
03:37:05 <lambdabot>  True
03:37:09 <Syzygy-> Exactly.
03:37:25 <Syzygy-> This list doesn't contain False, and thus the function should return False.
03:37:27 <augustss> and what's non-working about that?
03:37:39 <Syzygy-> > any id [False]
03:37:40 <lambdabot>  False
03:37:51 <arcatan> ich660: please ask and we'll see if anyone is able to help you
03:37:54 * Syzygy- proposes (l -> any id l && any not l)
03:38:06 <augustss> "a function that returns True if the list contains True and False if it doesn't" sounds like or to me
03:38:27 <Syzygy-> Oooooh. I misread. Sorry, yeah, that's or.
03:38:42 <Syzygy-> I parsed it as "returns True if the list contains True and False"
03:38:45 <thegraham> Thanks Syzygy and augustss, I need it to return True if there is just True in the list, so any id seems good. Thanks :D
03:38:57 <Syzygy-> thegraham: or is better for that though.
03:39:04 <Syzygy-> At least more readable.
03:40:31 <ich660> i have to check 2 two lists if they are equivalent, no matter what order and how often an element is in the list
03:40:50 <ich660> i have already managed to eliminate duplicate elements
03:40:54 <Syzygy-> Compare (sort . nub) list
03:41:07 <Syzygy-> If the order doesn't matter, then order the lists and then compare...
03:41:09 <Lemmih> dons: There are other tools for extracting and running quickcheck tests, right?
03:41:40 <thegraham> > or [True]
03:41:42 <lambdabot>  True
03:42:44 <augustss> ich660: are the list elements in Ord?
03:43:58 <ich690> augustss: no
03:44:10 <augustss> Syzygy-: a faster way is 'map head . group . sort'
03:44:31 <Syzygy-> Point.
03:44:52 <augustss> ich690: then you should write a function that does a subset test and use that both ways
03:45:06 <psykotic> ich690, if they are only in Eq then i doubt you can do better than O(mn).
03:45:13 <augustss> like 'subset xs ys = all (`elem` ys) xs'
03:45:36 <augustss> and ' same xs ys = subset xs ys && subset ys xs'
03:46:08 <vincenz> > or []
03:46:09 <lambdabot>  False
03:46:13 <vincenz> > and []
03:46:14 <lambdabot>  True
03:46:45 <psykotic> > or $ repeat False
03:46:47 <lambdabot>  Exception: <<loop>>
03:46:57 <vincenz> > and $ map or [[]]
03:46:59 <lambdabot>  False
03:47:05 <vincenz> > or $ map and [[]]
03:47:07 <lambdabot>  True
03:47:10 <vincenz> !
03:47:13 <vincenz> that's buggy
03:47:21 <augustss> not, it's not
03:47:27 <Syzygy-> > map and [[]]
03:47:29 <lambdabot>  [True]
03:47:30 <Heffalump> > or $ repeat True
03:47:31 <lambdabot>  True
03:47:37 <Syzygy-> > map or [[]]
03:47:38 <lambdabot>  [False]
03:47:49 <vincenz> augustss: yes it is
03:47:50 <Syzygy-> Looks perfectly expected to me...
03:47:57 <augustss> yep
03:48:02 <vincenz> ...
03:48:05 <vincenz> I meant on the functional level
03:48:07 <Heffalump> map and [[]] = [True] , or [True] = True
03:48:09 <psykotic> > let or' = foldl (||) False in or' $ repeat True
03:48:14 <vincenz> not on the level of it's returning things that are inconsistent with it's beahviour
03:48:14 <lambdabot> Terminated
03:48:15 <Heffalump> what's the problem with that?
03:48:37 <Heffalump> psykotic: you see, foldl is evil ;-)
03:48:39 <augustss> vincenz: I don't understand
03:48:53 <ich690> thx @ augustss and syzygy
03:49:00 <Syzygy-> np
03:49:28 <psykotic> > let or' = foldr (||) False in or' $ repeat True
03:49:30 <lambdabot>  True
03:49:38 <psykotic> Heffalump, yeah, i was expecting that to happen
03:49:56 <Heffalump> oh, yes, it's entirely expected. Just goes to show how evil foldl is ;-)
03:50:24 <augustss> or is specified to behave like 'foldr (||) False'
03:50:50 <vincenz> augustss: I'd expect them to be the same
03:51:11 <augustss> vincenz: yes, but I don't understand why you'd expect that
03:51:44 <augustss> vincenz: it's like saying you expect 'and' and 'or' to do the same thing
03:52:22 <vincenz> augustss: no I'd expect an empty network of ors on top of ands and ands on top of ors to return the same
03:52:40 <Heffalump> well, your expectation is wrong :-)
03:52:54 <vincenz> Heffalump: only because the function is defined that way in haskell
03:52:58 <augustss> vincenz: but I don't see why you'd expect that :)
03:53:09 <vincenz> augustss: I don't see why I shouldn't expect that
03:53:24 <psykotic> vincenz,  this is hardly something unique to haskell
03:53:26 <augustss> empty and things are not the same as empty or things
03:53:40 <Syzygy-> vincenz: You shouldn't expect it because empty operations in general are defined giving the result most reminiscent of an identity of that operation.
03:54:00 <vincenz> Syzygy-: yes I know that, but I think that's only so for convenience sake
03:54:05 <Syzygy-> It's the same with with ands and ors as with sums, products, unions, intersections...
03:54:11 <vincenz> that way you can do it recursively
03:54:30 <Syzygy-> It is so for convenience sake, BECAUSE you can make most everything you want to state about the operations much more transparently.
03:54:37 <Heffalump> do you agree that n^0 = 1 for n > 0 ?
03:54:48 <vincenz> Heffalump: yes
03:54:54 <psykotic> hopefully for n >= 0. there is a unique function from the empty set to itself, too.
03:54:56 <Syzygy-> Because it is the way you'd need things to be defined in order to avoid special case handling.
03:55:05 <Heffalump> but you don't agree that "and [] = True" ?
03:55:12 <vincenz> Heffalump: that is entirely uncorrelated
03:55:20 <Syzygy-> No, it's not.
03:55:25 <psykotic> vincenz, what about the sum of an empty list being 0? or the product being 1?
03:55:27 <vincenz> And I wasn't disagreeing with the and
03:55:30 <Syzygy-> n^0 is an empty product. and [] is an empty and.
03:55:32 <augustss> vincenz: but it's not two empty networks when you do [[]]
03:55:32 <vincenz> I am disagreeing with the or of an empty list
03:55:43 <Heffalump> ok, you don't agree that "or [] = False"?
03:55:44 <augustss> the outer network isn't empty
03:55:47 <Syzygy-> So you'd want or [] = True?
03:55:50 <vincenz> ...
03:55:53 <Heffalump> it's the same principle.
03:56:08 <Heffalump> we want "or (as ++ bs) = or as || or bs"
03:56:18 <Heffalump> just like we want x^(a+b) = x^a * x^b
03:56:27 <Syzygy-> If an empty or is true, then you'd need special handling to avoid or to be the same thing as const True.
03:57:10 <vincenz> Heffalump: and again you make analogies out of the blue, what is even stronger you use the same analogy (^) for both 'and' and 'or'
03:57:17 <augustss> if you build the hardware for [[]] it would be non-empty :)
03:57:29 <Heffalump> that's because the same analogy applies
03:57:36 <augustss> or the hardware for 'or $ map and [[]]'
03:57:45 <Heffalump> and there is an analogy between 'and' and 'or' too
03:57:48 <vincenz> I disagree but anyways, this discussion is fruitless and moot, so let's agree to disagre
03:57:51 <vincenz> +e
03:57:59 <Heffalump> we want all three things to be true, "and (as ++ bs) = and as && and bs" too
03:58:04 <Heffalump> ok :-)
03:58:10 <vincenz> :)
03:58:19 <augustss> vincenz: but if you don't get this point, you're really missing out on something fundamental
03:58:33 <Heffalump> though I am interested in whether you actually don't think the laws I stated should be true
03:58:53 <vincenz> Heffalump: You're reworking my words
03:58:55 <psykotic> vincenz, what about the sum of an empty list being 0? this is in in fact exactly identical as the 'or' result corresponds to pi/product notation in the ring Z/2Z.
03:59:05 <vincenz> But anyways
03:59:10 <vincenz> As stated above, let's agree to disagree :)
03:59:13 * vincenz wants to get back to his paper
03:59:18 <psykotic> cop out :)
03:59:18 <Heffalump> vincenz: ok, I'll phrase it neutrally, do you think "or (as ++ bs) == or as || or bs" should be true or not?
03:59:47 <Syzygy-> I could agree to let you out of the discussion, but I wouldn't agree to disagree, since I sincerely believe your position to be highly detritemental to your understanding of the mathematics involved.
04:00:01 <vincenz> Heffalump: I disagree with the analogy for the (^) not with the rule.  I realize that from the rule the rule about [] can be derived.  Fine there, what I just seems wrong to me is that switching ands and ors for an empty network should give teh same result
04:00:17 <vincenz> Syzygy-: you're trying to employ personal attacks to get me back into the discussion which at this moment in time I hvae no desire of pursuing
04:00:28 <augustss> vincenz: but the network is NOT empty
04:00:33 <Heffalump> well, if you accept the rules I stated, you have to accept that switching ands and ors does make a difference
04:00:35 <vincenz> It's sunday, and I'm at the office cause I have to work
04:00:46 <vincenz> Heffalump: yes I know, it just seems odd for an empty or semi-empty network
04:01:17 <Heffalump> well, I don't find it odd, but even if it was it wouldn't be a good enough reason to break a much more fundamental law
04:01:25 <vincenz> Heffalump: the part I -was- somewhat disagreeing with was the analogy to the (^) but that's a moot point to this entire discussion and I'll just take it as an analogy for exemplification isntead of a deeply formalized one
04:01:37 <augustss> vincenz: you should build the networks with wired and/or and you'll see :)
04:02:14 <vincenz> > and $ map or []
04:02:16 <lambdabot>  True
04:02:18 <vincenz> > or $ map and []
04:02:19 <lambdabot>  False
04:02:23 <vincenz> empty network
04:02:30 <vincenz> well, empty inputs
04:02:34 <Heffalump> well, it's not deeply formalized, no, but I do think it's natural to expect (+, ^, *) to follow the same algebra as (++, and, &&)
04:02:36 <augustss> yep
04:02:42 <augustss> empty inputs.
04:03:18 <augustss> if you do gates with wired and/or (which is the closest I can think of in terms of hardware), they behave like that
04:03:33 <vincenz> perhaps, I just had a kneejerk reaction at seeing a difference
04:05:18 <augustss> it's because AND and OR are different :)
04:05:37 <vincenz> which is the argument I was using against Heffalump about using (^) for both :P
04:05:40 <Heffalump> AND is just OR upside down :-)
04:05:55 <vincenz> anywho
04:05:55 <augustss> yes.  they are different, but the same
04:06:07 <vincenz> >>= work `at` office
04:08:14 <ich645> hi, i'm back again programm still not working maybe i show you what i've done so far!?
04:08:59 <ich645> sameSet :: Eq a => [a] -> [a] -> Bool
04:09:05 <ich645> nub :: Eq a => [a] -> [a]
04:09:11 <ich645> nub [] = []
04:09:19 <ich645> nub (x:xs) = x : filter (x /=) (nub xs)
04:09:28 <ich645> sameSet a b 
04:09:37 <ich645> | nub a == nub b = True
04:09:44 <ich645> | otherwise = False
04:09:58 <vincenz> augustss: yes they are, they're duals :)
04:10:15 <Heffalump> ich645: shouldn't you sort them too?
04:10:22 <Heffalump> == on lists doesn't take into account order
04:10:31 <ich645> yes, but thats my problem 
04:10:33 <Heffalump> or rather does take into account order
04:10:46 <Heffalump> oh, no Ord instance
04:11:03 <Heffalump> also, if they're already sets, is there any need to do nub?
04:11:13 <gour> @where paste
04:11:13 <lambdabot> http://paste.lisp.org/new/haskell
04:11:43 <gour> ich645: you can also use ^^^ to paste, it's easier
04:12:25 <ich645> heffalump: yes nub is necessary, because [ 3, 3, 5] should be the same as [3, 5]
04:12:30 <Heffalump> fair enough
04:12:47 <Heffalump> well, you'll need to do an element by element check that each element of each list is in the other
04:13:14 <umike> hi! can you help newbie ? i habe code let num1 = read x :: [Integer]
04:13:14 <umike>           let num2 = read y :: [Integer]
04:13:14 <umike>           let result = num1 + num2 .... why last expression doesn't work ?
04:13:32 <Heffalump> @type (+)
04:13:34 <lambdabot> forall a. (Num a) => a -> a -> a
04:13:50 <Heffalump> it doesn't work because [Integer] isn't an instance of Num
04:14:49 <gour> vincenz: your discussion is 7.5 exercsise in thompson's Craft of FP book
04:14:57 <gour> *exercise
04:16:53 <gour> (section "primitive recursion over lists")
04:17:30 <vincenz> gour: the haskell solution is obvious :)
04:18:03 <gour> vincenz: so, this is the reason behing then, true?
04:18:37 <ich645> Heffalump: how can i do this (i am an absolute beginner, started Haskell 2 weeks ago)
04:19:47 <gour> ich645: you're using thompson's book?
04:21:28 <ich645> gour: no not yet, but already ordered it
04:22:06 <gour> ich645: ah, ok. it's very good book. i thought you're solving exercises from it
04:22:39 <araujo> morning
04:25:32 <Svrog> why does ReadP have underscores in some of the function names? seems a bit inconsistent with the rest of haskell
04:25:57 <Svrog> also are there any docs or papers on ReadP?
04:26:13 <umike> hm, how to sum two integers variables  and write result to third? 
04:27:25 <Svrog> umike: let x = a + b in x? or are you asking something different?
04:28:48 <Svrog> someone mentioned Parsek earlier, where can i find that? and how is it different from Parsec and ReadP?
04:29:02 <ich645> anybody any suggestions for me?
04:29:53 <gour> ich645: paste the full task & your code somewhere
04:29:57 <augustss> ich645: yes, define a function that tests if one set is a subset of another by checking that all elements are there
04:30:17 * vincenz waves at Philippa 
04:30:33 <augustss> ich645: then use the function both ways on the two sets
04:31:08 <Heffalump> ich645: how would you check if x was an element of ys?
04:35:03 <gour> Heffalump: writing 'elem' function
04:35:56 <dons> on the topic of the behaviour of undefined being undefined, I quite like: undefined | False       = undefined
04:36:27 <dons>  -- from Gofer 2.3
04:36:45 <augustss> yes, it's cute
04:38:12 <ich645> whats cute?
04:38:49 <augustss> undefined | False = undefined
04:39:08 <dons> ?let undef | False = undef
04:39:09 <lambdabot> Defined.
04:39:19 <dons> > f x = L.undef in f ()
04:39:20 <lambdabot>  Parse error
04:39:26 <dons> > let f x = L.undef in f ()
04:39:26 <lambdabot>  Add a type signature
04:39:29 <gour> ich645: 'nice'
04:39:30 <dons> ah
04:39:37 <dons> > let f x = L.undef in f () :: () 
04:39:38 <lambdabot>  Exception: <local>:8:0-20: Non-exhaustive patterns in function undef
04:39:41 <dons> :)
04:40:09 <ich645> i know what cute means, but how can someone find haskell code 'cute' :-)
04:40:23 <dons> what's not cute about: undefined | False = undefined   ? :)
04:40:47 <gour> lol
04:41:16 <dons> ?undefine
04:41:17 <lambdabot> Undefined.
04:41:25 <ich645> well ... mybe youre right, its somehow really cute @ dons
04:41:35 <dons> ?let undef = undef
04:41:36 <lambdabot> Defined.
04:41:40 <Cale> Haskell code can be cute in the way that certain pieces of mathematics can be cute :)
04:41:43 <dons> > let f x = L.undef in f () :: () 
04:41:44 <lambdabot>  Exception: <<loop>>
04:41:49 <dons> that'd do too!
04:42:24 <dons> (I guess gofer didn't do blackholing or something?)
04:42:48 <augustss> undef=undef is too obvious :)
04:42:58 <Cale> > fix ((0:) . scanl (+) 1)
04:43:00 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
04:43:00 <dons> heh
04:43:22 <ich645> well, i thought people find boyfriends, girlfriends and kittys cute, but haskell code and maths, thats new to me *g*
04:43:50 <augustss> ich645: your horizons are expanding... :)
04:43:50 <dons> Cale's fib is cute like kitty-cats are cute
04:44:05 <ich645> :-))
04:44:09 <Cale> It's a certain combination of clever with pretty.
04:44:50 <Cale> (mathematics and code can certainly be beautiful)
04:45:10 <ich645> ok, i also want cute code for my programm ....
04:46:08 <augustss> same xs ys = superset xs ys && superset ys xs where superset xs = all (`elem` xs)
04:46:13 <dblhelix> for me, nothing beats fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
04:46:38 <dblhelix> > 0 : 1 : zipWith (+) fibs (tail fibs)
04:46:39 <lambdabot>  Not in scope: `fibs'
04:46:44 <dons> Lemmih: nice work on cabal-test :)
04:46:59 <augustss> @pl \ xs -> all (`elem` xs)
04:47:00 <lambdabot> all . flip elem
04:47:00 <dblhelix> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
04:47:02 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
04:47:26 <dblhelix> @karma+ Lemmih
04:47:27 <lambdabot> Lemmih's karma raised to 29.
04:47:31 <augustss> @pl \ xs ys -> f xs ys && f ys xs
04:47:31 <lambdabot> ap (ap . ((&&) .) . f) (flip f)
04:47:37 <augustss> ugh
04:47:45 <dons> and pqc is only umm 3 days old. we got 'agile' up the wazoo 
04:48:01 <dons> augustss: mm. could have done better there
04:48:02 <kfish> ?pqc
04:48:03 <lambdabot> Maybe you meant: ghc pl
04:48:12 <dons> we should add some more rules/cleverness
04:48:21 <dons> ?where pqc
04:48:22 <lambdabot> http://www.cse.unsw.edu.au/~dons/pqc.html
04:48:36 <augustss> dons: i'm not sure how to do better, but it looks ugly
04:48:37 <kfish> ah :-)
04:48:37 <Cale> isSubstringOf x y = any (isPrefixOf x) (tails y)
04:48:44 <dons> ?where+ cabal-test http://darcs.haskell.org/~lemmih/cabal-test
04:48:45 <lambdabot> Done.
04:49:05 <dons> Cale: got a cute monadic refactoring of \ xs ys -> f xs ys && f ys xs ?
04:49:31 <dons> ?pl \ xs ys -> f xs ys && f xs ys
04:49:32 <lambdabot> ap (ap . ((&&) .) . f) f
04:49:44 <astrolabe> heh
04:49:53 <dons> ?pl \ xs -> f xs && f xs
04:49:54 <lambdabot> liftM2 (&&) f f
04:49:56 <astrolabe> we need an @obfuscate
04:50:10 <dons> ?unpl ap (ap . ((&&) .) . f) f
04:50:10 <lambdabot> ((\ k s ->
04:50:11 <augustss> @pl \ x y -> f x y && f x y
04:50:11 <lambdabot>   (\ w -> (&&) (f k w)) >>= \ p -> s >>= \ o -> return (p o))
04:50:11 <lambdabot>   >>= \ c -> f >>= \ b -> return (c b))
04:50:11 <lambdabot> ap (ap . ((&&) .) . f) f
04:50:16 <dons> hehe
04:50:22 <dons> astrolabe: that'd do /
04:50:35 <astrolabe> yeah :)
04:50:48 * dblhelix has finally implemented cabal support for the utrecht attribute grammar system :)
04:50:55 <dons> dblhelix++
04:51:04 <dons> dblhelix: now post the darcs repo :)
04:51:51 <dblhelix> dons: first, adapt the uuag system, so I don't have to rely on dirty hacks this much ;)
04:52:18 <dblhelix> and, btw, how to 'touch' files in a non-posix way?
04:52:40 <augustss> hmmm, how about 'curry . liftM2 (&&) (uncurry f) (uncurry (flip f))'
04:53:03 <dblhelix> right now I just overwrite the file with its original contents :)
04:53:27 <dons> augustss: yeah, that's where I was heading too. but feels unsatisfactory
04:53:28 <dblhelix> don't want to rely on -package unix
04:53:45 <augustss> dons: i know, it's even longer
04:53:52 <astrolabe> I think the original is very clear
04:54:14 <dons> dblhelix: renameFile twice? :)
04:54:42 <astrolabe> look up how 'touch' works?
04:54:48 <augustss> dons: wouldn't touch the file on Posix
04:55:05 <dblhelix> astrolabe: touch calls utime()
04:55:27 <astrolabe> is that posix?
04:55:32 <dblhelix> yes
04:55:39 <augustss> and why do you need to touch files at all?  seem like a hack
04:55:46 <astrolabe> touch works on my windows machine
04:55:47 <dblhelix> augustss: it is
04:56:28 <dblhelix> cabal's interface for preprocessors is a bit to limited for my needs... that's why I need the hack
04:57:18 <dblhelix> anyway, my gf wants to go and catch a movie right now... so i'll guess i have to think about this later... or during the movie... ;)
04:57:44 <astrolabe> you better pay attention
04:58:07 <dblhelix> astrolabe: good idea, thnx
04:58:26 <dblhelix> cu guys and gals later!
05:02:43 <ich645> what would be the simplest and shortest code for my problem?
05:03:01 <ich645> (:-) not the cutest)
05:04:15 <Cale> ich645: what was your problem?
05:04:38 <Svrog> is there a way to enter ByteString literals in haskell? or do i have to use Data.ByteString.Char8.pack?
05:05:04 <ich645> check equivalency of two lists
05:05:17 <ich645> sameSet :: Eq a => [a] -> [a] -> Bool
05:05:30 <ich645> sameSet a b
05:05:37 <ich645> | nub a == nub b = True
05:05:44 <ich645> | otherwise = False
05:05:56 <Botje> what's so hard about that?
05:06:16 <psykotic> ich: didn't lennart already post a two liner?
05:06:18 <Botje> sameSet a b = nub a == nub b :P
05:06:38 <dons> ?pl sameSet a b = nub a == nub b
05:06:39 <lambdabot> sameSet = (. nub) . (==) . nub
05:06:42 <dons> dot!
05:07:08 <Magicman> Wouldn't that screw up [1,2,3] == [2,1,3]?
05:07:09 <psykotic> sameSet as bs = as `subset` bs && bs `subset` as where subset as bs = all ('elem' bs) as
05:07:30 <augustss> Svrog: if my patch is merged into ghc there will soon be a way
05:07:40 <Svrog> ah
05:07:44 <Svrog> cool :)
05:07:48 <ich645> Magicman: yes
05:07:48 <Magicman> (with (==) being the sameSet operator in that case)
05:07:57 <dons> Svrog: pack "foo" currently
05:07:58 <ich645> sorry didn't explain enough
05:08:04 <dons> (don't worry, that's efficient for string literals)
05:08:17 <Svrog> cool :)
05:08:40 <augustss> Svrog: the patch is in the hands of the ghc maintainers... :)
05:08:48 <Svrog> ah
05:08:58 <Svrog> so would that appear in 6.7 or 6.8?
05:09:00 <Svrog> or sooner?
05:09:04 <Svrog> 6.6.1?
05:09:10 <augustss> i have no clue
05:09:10 <ich645> thanks a lot
05:09:23 <dons> augustss: people are asking for it (without knowing about the patch). good sign!
05:09:34 <augustss> yep
05:09:36 <Svrog> :)
05:09:41 <arcatan> dunno about shortest or simplest, but here's my try.. sameSet a b = let un = sort . nub in un a == un b
05:10:13 <augustss> arcatan: we are not allowed Ord
05:10:18 <arcatan> oh
05:11:50 <ich645> arcatan, augustss: i already experienced it too (ord not ok)
05:11:59 <augustss> same as bs = null (as' \\ bs') && null (bs' \\ as') where as'=nub as; bs' = nub bs
05:13:27 <ich645> bf is calling see u later
05:20:16 <Svrog> dons: someone on the mailing list suggested using -funfolding-use-threshold and after compiling with -funfolding-use-threshold=24 the hash function now runs only 2-3 times slower than c :)
05:24:06 <thegraham> How do I find out if the value in my list of length one (i.e. [4], say x) is contained in a list (i.e. [3,4], say xs)? I can do "elem x!!0 xs", but there must be a better way...
05:25:24 <astrolabe> head is nicer than !! 0  in my opinion
05:25:41 <astrolabe> but make sure you know the list isn't empty
05:27:06 <Cale> thegraham: perhaps generalise to arbitrary lists?
05:27:33 <Cale> all (`elem` xs) x
05:28:14 <Cale> then it will work with empty lists, or longer lists
05:28:20 <thegraham> Cale: thanks! That is great!
05:30:53 <astrolabe> In C, if f is a function, and p is a pointer to a function, which is correct, 'p = f' or 'p = &f'?  (sorry for OT)
05:31:14 <psykotic> both are valid
05:31:32 <astrolabe> really?  How come?
05:32:05 * psykotic refrains from answering that.
05:32:06 <psykotic> :)
05:32:09 <astrolabe> anyway, thanks
05:46:36 <araujo> http://blog.lostlake.org/index.php?/archives/18-Functional-languages-will-rule.html#extended
05:46:39 <lambdabot> Title: Functional languages will rule - David Pollak's Blog, http://tinyurl.com/uwtfu
05:49:29 <gour> araujo: but haskell is out of game there
05:49:31 <vegai> TinyURL's private joke, embedding 'wtf'?
05:51:34 <araujo> gour, according to him ......
05:52:14 <tibbe> umpaumpa
05:52:29 <gour> araujo: right, but that 'poker attempt' gives credit to erlang
05:52:36 <tibbe> wrong channel xD
05:53:02 <dons> i found that blog a bit boring/and or annoying. "I spent 10 minutes with Foo, 5 minutes with Blah. Some blog said somethin about X"
05:53:14 <astrolabe> 'As a side note, I was going to try Haskell, the allegedly purest functional language, until I read this post, and decided not to spend a lot of time with Haskell.'
05:54:09 <araujo> gour, mm.. that isn't an article about the poker attempt
05:54:26 <araujo> that's an article about functional programming in general.
05:54:33 <mwc> I haven't seen Haxe yet, linked to from that blog
05:55:03 <dons> so who's going to release a new cabalised lib today?
05:55:13 <dons> I'm really hoping to get 7 a week out of you guys.... :)
05:55:24 <dons> maybe i should advertise that in the HWN.
05:56:05 <dons> anyone want to port something fun from perl or ruby over, for extra credit?
05:56:15 <dons> rails perhaps?
05:56:30 <dons> ?users
05:56:30 <lambdabot> Maximum users seen in #haskell: 276, currently: 232 (84.1%), active: 33 (14.2%)
05:56:38 <dons> ?users #Haskell
05:56:38 <lambdabot> Maximum users seen in #Haskell: 198, currently: 180 (90.9%), active: 20 (11.1%)
05:56:46 <dons> that netsplit is a weird one.
05:58:31 <dons> some blogs to cheer you up: "If I won the lottery I might be tempted to write an MVC framework for Haskell."
05:58:39 <dons> http://n3dst4.livejournal.com/50393.html
06:00:18 <Lemmih> MVC?
06:00:46 <dons> i've no idea what that is. but his heart is in the right place :)
06:01:22 <dons> Massive Vector Computer? 
06:01:28 <twanvl> Model View Controller?
06:01:36 <ibid> hah
06:01:36 <dons> ah probably that
06:01:43 <ibid> which MVC
06:01:52 <ibid> there is the old one and the wrong one...
06:02:40 <Svrog> night
06:04:48 <psnl> model view controller is one of the normal design patterns. you have a model of your system, a way to view that model, normally a gui, and a way to control changes to the model, the controller
06:07:04 <tibbe> is there a particular type of library that people would like in haskell? (that doesn't exist currently) preferably small, I need some motivation to write something
06:08:07 * astrolabe wants the big things fixed :)
06:08:57 <dons> kfish: I tried to reply to your mail, but the address bounces?
06:09:06 <kfish> really?
06:09:16 <kfish> hmm, try conrad.parker@gmail.com
06:09:17 <dons> the metadecks one?
06:09:27 <kfish> strange, most of my mail goes there
06:09:34 <kfish> (and just redirects to gmail anyway)
06:09:52 <kfish> could you forward me the bounce? :-)
06:09:59 <dons> ok, i forwarded that to your gmail
06:10:14 <kfish> ta
06:10:57 <dons> tibbe: one idea would be to find some list of popular libs in a language you know, say perl on cpan or ruby or ... and then pick one that interests you, and port it
06:11:10 <tibbe> hmm, good idea
06:11:14 <dons> they probably have rankings somewhere in terms of popularity/downloads
06:11:33 <tibbe> yes
06:11:59 <dons> also, something that you'd like to write an application for would be good, since then you're more likely to use the api, and improve it
06:12:19 <dons> we should have a list of 'requested'  libs. a wish list
06:12:31 <dons> actually, might be worth preparing that list before the hackathon
06:13:04 <tibbe> I'm kinda envious of ruby's website
06:13:09 <dons> there's some things in erlang and clean that could be profitably ported (with little effort in the case of Clean)
06:13:24 <dons> yeah, its glitzy ..
06:13:25 <tibbe> yeah
06:13:45 <tibbe> perhaps a haskell bling bling project ;)
06:14:12 <dons> there news is less active than haskell.org though ;)
06:14:20 <tibbe> although the pro ruby example they have on the front page is kinda funny
06:14:56 <dons> i think its random
06:15:06 <tibbe> the hello world one?
06:15:14 <dons> ah yes. that's what i have too
06:15:25 <tibbe> i reloaded and got it again
06:16:05 <tibbe> nitro is listed as the top ruby project
06:16:08 <tibbe> a web framework
06:16:17 <tibbe> thought rails was but both are the same kind of thing
06:16:19 <dons> there's some other one about (worryingly!) : 
06:16:20 <dons> # Ruby knows what you
06:16:20 <dons> # mean, even if you
06:16:20 <dons> # want to do math on
06:16:20 <dons> # an entire Array
06:16:34 <tibbe> :)
06:16:46 * mwc has a violent flashback to valarray
06:16:49 <tibbe> perhaps something like the camping framework, a super small web framework
06:17:19 <vegai> or advance happs?
06:17:38 <dons> yeah, some happs stuff if you're into web frameworkish things
06:17:44 <dons> something on top of happs
06:18:01 <dons> a small web framework would be welcome
06:18:07 <tibbe> wow, the whole top list on rubyforge is web stuff
06:18:21 <dons> where speed is not of the essence ;)
06:18:25 <tibbe> HAppS always scares me, feels like it does so much :)
06:18:32 <tibbe> probably just my superstition though
06:18:38 <tibbe> yeah
06:18:53 <dons> well, you can always bug musasabi, shapr and alexj about it
06:19:01 <vegai> HAppS really would benefit from a "from novice to expert" kind of large tutorial
06:19:06 <dons> yeah
06:19:15 <vegai> Ruby has Why. That is not a small asset.
06:19:19 <dons> the gtk2hs guys seem to have that down. happs definitely needs some tuts/blogs
06:20:02 <vegai> (Why, the guy who wrote the Poignant Guide)
06:21:25 <tibbe> if you look at web servers like mongrel look a bit more focused
06:21:56 <vegai> more focused than what?
06:22:02 <tibbe> happs
06:22:28 <tibbe> i think the best idea is to have a small web server that runs haskell apps in it and a big webserver with load balancing in front
06:22:39 <tibbe> ie cgi/fcgi is not a good idea
06:23:19 <tibbe> i read a convincing article on the subject, one sec
06:24:06 <wy> hi all
06:24:18 <tibbe> http://blog.duncandavidson.com/2006/06/the_web_is_a_pi.html
06:24:21 <lambdabot> http://tinyurl.com/y458nv
06:24:21 <tibbe> wy: hi
06:24:26 <wy> I started to use Haskell today and got some problems
06:24:31 <wy> Hi tibbe 
06:24:37 <tibbe> shoot
06:25:12 <wy> I can't run the first few examples from "A Gentle Introduction to Haskell, Version 98"... for example inc x=x+1
06:25:30 <wy> it says "ERROR - Syntax error in input (unexpected `=')"
06:25:47 <ski> put definitions in a source file
06:25:49 <tibbe> you're using hugs?
06:25:55 <wy> yes I'm using hugs
06:25:56 <ski> or, if you're using ghci, use
06:26:05 <ski> let inc x = x + 
06:26:30 <wy> I have problem installing ghc
06:26:38 <wy> so I'm using Hugs now
06:26:42 <mukai> In hugs prompt, you cannot define any values
06:26:54 <wy> That's too bad...
06:26:57 <mukai> what is your platform?
06:26:58 <ski> well, you can have local definitions ..
06:27:04 <wy> Ubuntu Linux
06:27:07 <ski> > let inc x = x + 1 in inc (inc 10)
06:27:08 <lambdabot>  12
06:27:15 <mukai> ski: I agree
06:27:35 <ski> (but that forgets 'inc' afterwards)
06:27:41 <wy> I see...
06:27:46 <mukai> In Ubuntu, you can apt-get install ghc
06:28:25 <ski> wy : so, when using hugs, put your definitions into MyTest.hs, then load that
06:28:31 <ski> :l MyTest.hs
06:28:48 <ski> (you can use ':r' to reload)
06:28:58 <wy> ski: I don't think that's convenient. Should I use ghc instead?
06:29:05 <ich354> hi, how exactly does "subset xs ys = all(`elem` ys) xs" work
06:29:21 <mukai> If you write your code in Emacs, C-xC-l is your friend
06:29:42 <ski> wy : if you want to be able to define things directly at the interative toplevel, then yes
06:29:55 <Syzygy-> ich354: It checks that for each element of xs, the function (`elem` ys) is true.
06:30:08 <mukai> This command start up a Haskell session in a buffer, and load the file you write
06:30:14 <ski> wy : though, i've never found it a big burden to edit file, then reload with ':r', with hugs (nor ghci)
06:30:38 <dons> mukai: welcome!
06:30:45 <Syzygy-> ich354: x `elem` xs returns True if x is an element of the list xs, and false otherwise.
06:30:49 <Syzygy-> ?type elem
06:30:49 <wy> ski: I have also problem setting up haskell-mode in Emacs
06:30:50 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
06:30:51 <mukai> dons: hello
06:30:53 <dons> mukai == Jun Mukai?
06:30:56 <mukai> yes
06:31:04 <dons> doubly welcome! :)
06:31:24 <Syzygy-> ich354: And all takes some function [a] -> Bool and returns true if it returns True for all elements of the given list...
06:31:30 <Syzygy-> ?type all
06:31:31 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
06:31:36 <dons> mukai: did you write a haskell book? -- i've heard rumours..
06:32:03 <mukai> ah
06:32:09 <mukai> I wrote, in Japanese
06:32:18 <dons> mukai: also, we have a new irc channel, #haskell.jp if you're interested 
06:32:24 <ski> wy : well, i just installed haskell-mode with apt ..
06:32:50 <dons> mukai: ah! with the birds on the cover?
06:32:56 <dons> http://www.amazon.co.jp/gp/product/4839919623
06:33:00 <mukai> http://www.amazon.co.jp/gp/product/4839919623/
06:33:01 <mukai> yes
06:33:02 <lambdabot> http://tinyurl.com/yb9gv4
06:33:20 <dons> mukai++ 
06:33:32 <mwc> Those are some vaguely evil looking birds
06:33:34 <dons> (we've talked a lot about the cover of that book .. its very cool!)
06:33:51 <ich354> syzgy: thx, what is `elem` is it a function?
06:33:53 <vincenz> yay for c+
06:33:56 * vincenz mutters
06:34:18 <dons> ich354: yep   
06:34:25 <dons> ?type elem
06:34:25 <vincenz> There you are, trying to figure out why osmething doesn't work, you keep going at it and going at it, debugging all over, no output, no compiler error.  Then you notice that you're missing #include <iostream>
06:34:26 <wy> ski: what are the lines you put into .emacs?
06:34:30 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
06:34:36 <vincenz> And btw debugging through STL is like dying
06:34:38 <dons> > elem 'x' "haskxelxx"
06:34:42 <lambdabot>  True
06:34:53 <dons> > 'x' `elem` "haskxelxx" -- ich354 
06:34:54 <lambdabot>  True
06:35:15 <mwc> vincenz: OT, but I have a C++ book on Templates that has a whole section on "Deciphering the error novel."
06:35:24 <dons> kfish: meet mukai (you're in the same country, I think)
06:35:29 <wy> I see. That's the problem of aptitude. apt-get installed ghc for me correctly now. Thank you!
06:35:35 <vincenz> mwc: nono, debugging not compiler errors
06:35:37 <psykotic> there are things like stlfilt that work with msvc and gcc's error messages to make them more useful
06:35:40 <vincenz> cause I wanted to trace what was going on
06:35:41 <ich354> Syzygy: sorry overread your hint
06:35:50 <psykotic> vincenz, write some gdb macros for drilling into vectors, maps, etc
06:35:52 <vincenz> you wouldn't believe how much spam you get in your stack-trace due to stl
06:36:07 <vincenz> psykotic: no idea on how to do that, but if anything I -don't- want gdb going into stl
06:36:11 <vincenz> so I can follow my code
06:36:16 <vincenz> anyways, it's fixed
06:36:19 <vincenz> oddly enough
06:36:42 <wy> Is Emacs an approprient tool for writing haskell programs?
06:36:53 <dons> wy, yep
06:37:05 <dons> emacs' haskell-mode is well regarded, and many use it
06:37:45 <cinema> vincenz, have you tried to implement "Statically verified type-preserving code transformations in haskell" ?
06:37:55 <wy> dons: can you help me setting it up? I put the lines from the start of haskell-mode.el into my .emacs but it doesn't work. I haven't seen any hint on which interpreter to use
06:37:56 <_matthew-> although it's indentation is imprecise
06:38:01 <vincenz> cinema: hmm?
06:38:04 <cinema> vincenz, I'm suffering a lot in trying
06:38:24 <cinema> vincenz, It's about typed-verified compilers
06:38:24 <vincenz> cinema: tbh I think that'd be simpler, at least you don't get heisenbugs
06:38:37 <jmuk> wy: http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
06:38:39 <vincenz> like not getting compiler errors cause you're missing iostream, but still not getting output
06:38:40 <lambdabot> Title: Haskell mode for Emacs - HaskellWiki, http://tinyurl.com/w7vnb
06:39:01 <cinema> I've got type-checking errors, not compiler errors
06:39:40 <cinema> The idea is to implement a type-preserving CPS transformation
06:40:52 <vincenz> cinema: what sort
06:41:05 <wy> jmuk: Thank you. But I can't get haskell inferior buffer started, although the file buffer is already in Haskell mode
06:42:06 <psykotic> cinema, the usual fischer-plotkin cps transform is already well-behaved on types, isn't it?
06:42:10 <cinema> vincenz, you have to implement higher-order constraints to guide the haskell type-checker
06:42:28 <tibbe> was there some kind of a problem where .cabal files required fps and now when fps is in ghc core the .cabal build fails?
06:42:49 <cinema> psykotic, the constraints are implemented at the type-level
06:43:09 <vincenz> cinema: have an example?
06:43:12 <jmuk> wow, I lost the page I referred
06:43:32 <cinema> vincenz, yes : http://www-etud.iro.umontreal.ca/~guillelj/tct.pdf
06:43:34 <jmuk> wy: add (add-hook 'haskell-mode-hook 'turn-on-haskell-hugs) into your .emacs
06:43:36 <lambdabot> http://tinyurl.com/yajnmt
06:44:19 <cinema> it is based on previous work by Geoffrey Washburn & Stephanie Weirich, "Boxes go Banana"
06:44:42 <wy> jmuk: it works. thank you!
06:45:16 <augustss> cinema: so you're putting GADTs to work.  cool
06:45:24 <cinema> Boxes go Banana : http://www.cis.upenn.edu/~geoffw/research/papers/MS-CIS-03-26.pdf
06:45:26 <lambdabot> http://tinyurl.com/yzem89
06:45:42 <cinema> augustss, I'd like to... But it is not that easy
06:46:19 <augustss> no, it's not
06:46:45 <jmuk> My .emacs for haskell-mode is uploaded at http://www.city5.org/etc/dot.emacs.haskell-mode.txt
06:46:46 <cinema> very few lines of code, many hours of pain
06:46:48 <lambdabot> http://tinyurl.com/yy6n36
06:47:35 <cinema> but now GHC supports the mix of type classes and GADTs
06:47:52 <cinema> so at least it should work eventually
06:47:59 <wy> jmuk: It seems the mode works different from other language interpreter modes? How can I evaluation a region?
06:48:27 <cinema> if someone wants to look at the code...
06:48:27 <augustss> cinema: yeah, the new ghc support seems much better (and trickier to implement)
06:49:13 <jmuk> wy: AFAIK, haskell-mode does not support evaluating region
06:49:15 <cinema> augustss, this is what I'd like to check
06:49:19 <augustss> cinema: btw, I think you should have some type theory citation of GADTs.  they are after all, over 20 years old there.
06:49:19 <jmuk> It can only load a file
06:49:37 <wy> jmuk: then how do I work with that?
06:50:51 <jmuk> what is the problem?
06:51:42 <wy> I put "let inc x=x+1 in inc 4" into a file and hit "C-c C-l" and it said "/home/wy/prog/haskell/1.hs:1:22: parse error (possibly incorrect indentation)Failed, modules loaded: none."
06:51:54 <ich354> i've got a code segment, what for so i need the first line?  sameSet :: Eq a => [a] -> [a] -> Bool       subset xs ys = all(`elem` ys) xs      sameSet a b = subset a b
06:52:12 <ich354> *do
06:52:19 <jmuk> no, you can write only "inc x = x + 1", and then type C-xC-l
06:52:29 <jmuk> the interpreter has your inc function
06:52:54 <tibbe> what's the link to the getting started with your haskell project on the wiki?
06:54:49 <wy> jmuk: thank you. and how can I evaluate "inc 4"?
06:55:40 <jmuk> you just type "inc 4" in the prompt of the interpreter
06:56:11 <_matthew-> ?type mapM_
06:56:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
06:56:19 <_matthew-> tnx
06:56:38 <wy> it doesn't work. the prompt changed to *Main after I load the file
06:57:02 <psnl> this is a bit of an odd question, but how do you put _ in a latex document?
06:57:11 <jmuk> Yes, your prompt is correct
06:57:21 <jmuk> the result of :type inc ?
06:57:28 <tibbe> I need some catchy mathy sounding names for my new project directory, any ideas? :)
06:57:28 <_matthew-> psnl \_
06:57:31 <augustss> psnl \_
06:57:43 <psnl> thanks guys
06:58:19 <augustss> tibbe: Pascal? :)
06:58:25 <tibbe> taken ;)
06:58:37 <augustss> Riemann
06:58:52 <jmuk> The prompt *Main is the module name currently loaded.
06:58:59 <wy> jmuk: It works now. It seems when I got something wrong, I'll lose anything that's in the interpreter
06:59:13 <jmuk> If you do not specify the module name, Haskell uses `Main' for your module
06:59:38 <jmuk> What does the interpreter say?
07:00:31 <wy> If I put "inc x=x+1 <cr> inc 4" in my file and load it. There will be error, and then the inc is undefined.
07:01:30 <wy> It seems I should get another interpreter. ghc seems not very user friendly.
07:01:40 <jmuk> You cannot write some expression in the toplevel of a file
07:02:14 <jmuk> inc x = x + 1 <cr>main = print (inc 4), for exmaple
07:04:33 <truetom> hi
07:05:31 <wy> jmuk: that works, but nothing is printed
07:05:32 <truetom> is it correct that if a function uses 'putStr' has to return a monad?
07:05:45 <truetom> is it correct that if a function uses 'putStr' it has to return a monad?
07:05:55 <jmuk> type "main" in interpreter, it will print 5
07:05:56 <Syzygy-> ?type putStr
07:05:58 <lambdabot> String -> IO ()
07:06:00 <Syzygy-> Yup.
07:06:48 <truetom> hmm, is it possible to return something like ( IO(), Integer ) instead (a tuple) ?
07:06:57 <jmuk> And if you execute runhugs with your file, it also prints 5.
07:07:27 <vincenz> dons: where are the irclogs?
07:07:41 <jmuk> loading file does not execute values
07:07:48 <vincenz> dons: nm, found it
07:07:55 <vincenz> hmm, nm
07:10:49 <tibbe> dons: I tried the write your first haskell program guide and ran into an error:
07:10:51 <tibbe> runhaskell Setup.lhs configure --prefix=$HOME
07:10:51 <tibbe> Setup.lhs line 2: unlit: No definitions in file (perhaps you forgot the '>'s?)
07:10:51 <tibbe> phase `Literate pre-processor' failed (exitcode = 1)
07:10:58 <tibbe> I usually use a Setup.hs
07:12:58 <wy> It seems Haskell needs some time for me to get used to
07:14:52 <wy> I defined a datatype data Color = Red | Green | Blue | Indigo | Violet. Then I typed "Red" into the interpreter and got an error instead of something like "val it = Red: Color" as in sml
07:18:28 <wy> join #OCaml
07:18:59 <Heffalump> you don't want to do that!
07:19:00 <jmuk> wy: If you can print the data, the type must be instance of type class Show
07:19:06 <Heffalump> who knows what you might catch
07:19:07 <jmuk> I know OCaml too
07:19:19 <wy> jmuk: That's good!
07:19:35 <jmuk> you define the type data Color = Red | Green .... deriving Show
07:19:36 <Heffalump> what was the error?
07:19:49 <Heffalump> (but yeah, what jmuk says is probably the issue)
07:20:17 <wy> jmuk: It works, again. Thank you!
07:20:38 <wy> I think there should be another tutorial for tutorials.
07:21:20 <wy> When the tutorial examples can't work at a novice's prompt, there should be another tutorial ;-)
07:23:32 <tibbe> how do I message someone?
07:23:54 <wy> jmuk: I have problem with caml.inria.fr. I wonder if OCaml is still alive?
07:24:06 <eviltwin_b> tibbe: (a) register with nickserv (b) /msg nick whatever
07:24:26 <tibbe> ok
07:24:31 <Heffalump> wy: I'm fairly sure it should be still alive
07:24:33 <ski> (wy : sorry got disconnected .. i didn't put anything in '.emacs' (haven't got so far in learning emacs, yet ..))
07:24:42 <eviltwin_b> (freenode blocks /msg from unregistered users, apparently due to spam)
07:24:50 <jmuk> wy: I know but i do not use OCaml now. sorry
07:26:22 <wy> Heffalump: so they have some problem with the site
07:28:11 <wy> jmuk: So if I want to do the programming interactively. I should derive from Show every thing?
07:28:34 <jmuk> yes
07:29:22 <wy> Does that hurt on speed or other things? Do you have some trick that allows me not writing that?
07:29:40 <truetom> does haskell have some "command line" monad?
07:31:30 <ski> wy : if you don't use the Show instance, it will work the same
07:31:51 <truetom> Something like getLine but with being able to edit before hitting return?
07:32:26 <wy> ski: but then I can't see what I'm doing...
07:34:29 <ski> wy : you asked about whether it would hurt speed .. and i belive it won't
07:35:02 <wy> ski: I see. So I need to type "deriving Show" often
07:35:09 <ski> (except it could be said to hurt speed of coding a little, since you have to add the 'deriving' clause in the code ..)
07:36:16 <ski> (hm, istr hugs having an option that one can use to print using an internal printing, that doesn't require 'Show', though ..)
07:37:20 <wy> ski: OK. I think I'd better stick to ghc for a few days.
07:40:38 <tibbe> what's the name of the more general words?
07:45:13 <wy> What's the block comment chars?
07:45:21 <tibbe> wy {- -}
07:46:12 <ski> {- and they {- nest -} properly -}
07:46:39 <tibbe> @where prelude-source
07:46:39 <lambdabot> I know nothing about prelude-source.
07:46:46 <tibbe> @where prelude source
07:46:47 <lambdabot> I know nothing about prelude.
07:46:50 <tibbe> @where prelude
07:46:51 <lambdabot> I know nothing about prelude.
07:46:55 <tibbe> @where source
07:46:55 <lambdabot> I know nothing about source.
07:46:58 <tibbe> gah
07:47:03 <eviltwin_b> @source Prelude
07:47:04 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
07:48:24 <beginner> hi there, i wanted to use 'partition' but hugs returned an error
07:48:29 <beginner> Hugs> partition odd [1, 5, 2, 4, 3]
07:48:30 <xinming_> sorry, disconnected.
07:48:39 <beginner> ERROR - Undefined variable "partition"
07:48:58 <beginner> can someone help?
07:48:58 <glguy> You'll need to load the Data.List module
07:49:11 <beginner> how do i do this?
07:49:18 <glguy> :m Data.List
07:49:22 <glguy> if that fails
07:49:25 <glguy> :also Data.List
07:49:29 <glguy> (I dont' use Hugs much)
07:50:54 <beginner> doesn't work
07:51:16 <beginner> :-(
07:51:27 <glguy> what version of Hugs are you running?
07:51:46 <dmead> beginner: add "import Data.List" to the top of your source file
07:51:46 <beginner> sep 2006
07:52:12 <jmuk> beginner, :l Data.List
07:52:29 <truetom> :m Data.List
07:52:34 <glguy> lol
07:52:43 <glguy> :m Data.List     will work in GHC
07:52:50 <ski> ':m' doesn't work unless 'Data.List' is already loaded
07:52:53 <glguy> :l Data.List     will work in Hugs
07:53:40 <glguy> > partition odd [1, 5, 2, 4, 3]
07:53:42 <lambdabot>  ([1,5,3],[2,4])
07:54:08 <eviltwin_b> if you're in +98 mode it might just have to be :m List
07:55:56 <beginner> thx, :l Data.List worked
07:56:15 <beginner> How can i include this in my .hs file, the same way?
07:57:06 <jmuk> dmead wrote this, you add "import Data.List" to the top of your source file
07:57:32 <beginner> oh, sorry, thx
07:58:01 <dmead> yea the import system is much like java
07:58:09 <dmead> just without *
07:59:40 <ihope> If I wanted to, could I call a Haskell-type type a type " la Haskell"?
08:01:55 <Saizan> [164851] <beginner> thx, :l Data.List worked <-- my ghci complains with "<no location info>: module `Data.List' is a package module"
08:02:25 <Saizan> where's the error?
08:02:51 <ski> use ':m' with ghci
08:03:20 <ski> (it is already loaded, you just have to point your currentD[D[D[D[D focus to it)
08:03:51 <Saizan> thanks :O
08:04:19 <Saizan> (i see, so i could use it even in prelude using qualified names?)
08:04:49 * ski doesn't understand question
08:05:51 <astrolabe> No.  You can't see List functions unless you import List.
08:06:24 <astrolabe> (or load it)
08:08:02 <beginner> i found a good site (from my point of view) its like api for java, heres the link
08:08:09 <beginner> http://www.zvon.org/other/haskell/Outputglobal/index.html
08:08:12 <lambdabot> Title: Haskell, http://tinyurl.com/fuqg8
08:08:29 <beginner> don't know if you already knew the site
08:08:41 <astrolabe> I find it useful too
08:08:46 <beginner> there you can see List functions
08:09:12 <astrolabe> also http://www.haskell.org/ghc/docs/latest/html/libraries/
08:09:14 <lambdabot> http://tinyurl.com/ojrj6
08:11:15 <ski> (btw ':m' works in hugs, too .. but there 'Data.List',etc isn't already loaded, so you have to load them somehow (either explicitely, or by loading a module that loads 'Data.List' itself), before being able to use ':m' with them)
08:18:05 <Magicman> From Data.Array: ixmap :: (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e -> Array i e
08:18:15 <Magicman> Shouldn't that last part be Array i e -> Array j e?
08:18:48 <astrolabe> no
08:19:28 <astrolabe>  it does    arrayJ ! (f i)
08:20:21 <astrolabe> do you see?
08:20:38 <ski> arrayI i = arrayJ ! (f i)
08:20:46 <ski> er
08:20:56 <ski> arrayI ! i = arrayJ ! (f i)
08:21:09 <Magicman> So if you try to index the "new" i-array at an index n, it changes n to n' using the f, and then it indexes the old j-array?
08:21:12 <ski> (not actual haskell-code)
08:21:21 <astrolabe> Magicman: yes
08:22:02 <Magicman> Hmm... okay thanks :)
08:30:09 <tibbe> .
08:30:35 <astrolabe> '.'?
08:33:17 <tibbe> testing my internet connection :)
08:33:26 <tibbe> it's crap right now, goes up and down
08:35:53 <ski> the same
08:42:53 <tibbe> in france by any chance?
08:44:41 <tibbe> @hoogle (a -> b -> c) -> [(a,b)] -> [c]
08:44:43 <lambdabot> No matches, try a more general search
08:46:15 <shapr> Good Morning #haskell !
08:46:29 <shapr> How's code everybody?
08:46:29 <malebria> Hello there.
08:46:46 <astrolabe> good afternoon oh one-wheeled-one
08:46:59 <malebria> gtk2hs is broken in sid..
08:47:08 <shapr> greetings oh navigational instrument
08:47:12 <malebria> Is there somewhere I can find the debian package for ghc6.4?#
08:47:17 <astrolabe> :)
08:47:25 <astrolabe> malebria: what is 'sid'?
08:47:59 <eviltwin_b> debian unstable
08:47:59 <malebria> astrolabe, development version of debian.
08:48:15 * astrolabe wants a functional gui api
08:48:22 <astrolabe> thank you
08:50:18 <Igloo> malebria: http://snapshot.debian.net/archive/2006/03/27/debian/pool/main/g/ghc6/ has 6.4.1-2.1
08:50:21 <lambdabot> Title: Index of /archive/2006/03/27/debian/pool/main/g/ghc6, http://tinyurl.com/yl3alg
08:50:28 <malebria> Igloo, thanks...
08:50:45 <malebria> this snapshot.debian.net is very nice, I didn' t knew it.
08:50:51 <wy> Is there a library for writing GUI in haskell?
08:51:25 <malebria> wy, gtk2hs
08:51:29 <astrolabe> hs2Gtk among others
08:51:30 <malebria> haskell.org/gtk2hs
08:51:49 <astrolabe> it is a wrapper around gtk
08:52:15 <astrolabe> It is quite a thin wrapper.  Mostly it is in IO
08:52:44 <tibbe> anyone up for a peer review? a whopping 50 lines of code?
08:52:52 <tibbe> @where paste
08:52:53 <lambdabot> http://paste.lisp.org/new/haskell
08:55:25 <lisppaste2> tibbe pasted "REST lib" at http://paste.lisp.org/display/30729
08:59:59 <shapr> intercalate is an usual name.
09:01:10 <tibbe> using strings for the sql feels bad for testability
09:01:17 <shapr> Have you seen HaskellDB?
09:01:54 <tibbe> i haven't decided on a sql lib yet, i need one that doesn't assume that tables are known at compile time, but i guess none of them do that?
09:02:12 <tibbe> looking into haskelldb now
09:04:03 <tibbe> i need something simple so i can get testing with sqlite
09:04:14 <tibbe> thinking of integrating it with happs
09:04:45 <shapr> happs has a datatype that pretends to be a relational table underneath, have you seen it?
09:05:36 <malebria> Igloo, I needed ghc6.4.2+
09:05:42 <malebria> To use with sid gtk2hs
09:06:00 <malebria> Igloo, in the ghc6 package, it gives this link:
09:06:13 <malebria> http://snapshot.debian.net/archive/2006/06/28/debian/pool/main/g/ghc6/
09:06:17 <lambdabot> http://tinyurl.com/ylg4ak
09:06:24 <tibbe> shapr: briefly, the tables need to be able to change dynamically, i don't know any field or table names at compile time
09:06:26 <Igloo> malebria: Right, but that one doesn't work. You could try e-mailing the admins
09:08:31 <malebria> Igloo, ok, thanks.
09:09:06 <malebria> Igloo, I found it, thanks.
09:09:37 <malebria> There are some months missing in snapshot
09:13:04 <Pastorn> xinming: it's #i-like-hof
09:21:15 <glguy> ?seen xinming
09:21:16 <lambdabot> xinming is in #haskell and #perl6. I last heard xinming speak 1h 32m 43s ago.
09:28:52 <alexj__> does anyone here know if there is a standard name for   x .$ f = f x  -- I am making up the .$ name here.
09:30:19 <wy> Is there a way to go to the error location in emacs haskell-mode?
09:30:33 <mwc> I'd go with <$ to make it clear the application is proceeding to the left, but no std name as far as I know
09:30:53 <glguy> alexj__: flip?
09:31:00 <glguy> x `flip` f = f x
09:31:11 <glguy> hmm
09:31:29 <glguy> or rather flip id
09:31:39 <alexj__> ?
09:32:02 <glguy> > let (.$) = flip id in 3 .$ (+1)
09:32:03 <lambdabot>  4
09:32:08 <glguy> like that?
09:32:25 <alexj__> yes
09:32:41 <alexj__> but isn't it simpler to define it as   x .$ f = f x ?
09:33:02 <wy> I wonder is there a way to go to the error location in emacs haskell-mode?
09:33:33 <glguy> alexj__: sure, either way the result is the same (and there isn't a single function that does that in the Prelude)
09:33:43 <glguy> you'd have to use two like I mentioned
09:34:03 <kpreid> @pl \x f -> f x
09:34:03 <lambdabot> flip id
09:35:21 <alexj__> I am trying to improve the HAPpS API and I want to do something like this : [oGET $ retVal Index .$ xml, oPOST $ myFunc .$ xml ]
09:35:30 <alexj__> does that make sense?
09:35:58 <alexj__> I want the user easily to be able to specify that the output should be xmlized or converted to JSON or whatever.
09:36:40 <tibbe> alexj__: I'm just curious, what are you using happs for?
09:37:07 <alexj__> passnet is the public thing I am doing.
09:37:17 <alexj__> there are other projects that aren't public.
09:38:28 <alexj__> tibbe you doing web dev?
09:38:35 <alexj__> tiibe: you doing web dev?
09:38:38 <tibbe> alexj__: I'm writing a REST lib
09:38:54 <alexj__> HAppS is targetted at REST.
09:39:03 <alexj__> what are you doing in the REST lib?
09:39:05 <tibbe> how do you mean?
09:39:11 <tibbe> url -> sql query matching
09:39:22 <tibbe> and accepted encoding to some encoding mapping
09:39:30 <tibbe> just toying with some ideas
09:39:43 <tibbe> s/matchin/mapping
09:39:57 <tibbe> ie you type /posts/1 and it just works
09:40:06 <tibbe> or post some xml to /posts
09:40:29 <tibbe> just seing how far i can push the REST thinking
09:40:42 <tibbe> probably a bad idea but it's fun
09:41:41 <alexj__> ok.  are you using HAppS to do it?
09:41:46 <tibbe> i need some simple sql lib
09:41:53 <tibbe> well it's not connected to happs yet
09:41:58 <alexj__> ah ok.
09:42:01 <tibbe> but it should be trivial once it's done
09:42:05 <alexj__> cool.
09:42:16 <glguy> > 2 (succ $)
09:42:16 <lambdabot>  add an instance declaration for (Num ((a -> a) -> a1))
09:42:17 <lambdabot>   In the definitio...
09:42:21 <tibbe> i need an sql lib that doesn't assumbe i know table and field names at compile time
09:42:27 <glguy> > ($ 2) succ
09:42:29 <lambdabot>  3
09:42:37 <tibbe> glguy: I could have told you that!
09:42:54 <glguy> ? so
09:42:59 <glguy> I was just offering it up as another way
09:43:09 <tibbe> ;)
09:43:16 <wy> Is there a way to override the system functions such as head and tail?
09:43:24 <tibbe> wy, you can hide them
09:43:29 <phas> hi
09:43:33 <tibbe> hi
09:43:35 <phas> i've a structure in C
09:43:39 <phas> like
09:43:43 <glguy> import Data.List hiding (head, tail)
09:43:46 <phas> struct BLAH{
09:43:46 <sjanssen> import Prelude hiding (head, tail) -- like that wy
09:43:48 <tibbe> wy, import Data.List hiding(head, tail)
09:43:50 <phas> cha* foo
09:43:52 <phas> ehm
09:43:55 <phas> char* foo
09:44:01 <phas> char bar[N]
09:44:14 <glguy> looks like sjanssen would be more correct than me :)
09:44:17 <phas> if i try to access them with hsc2hs
09:44:17 <glguy> ?index head
09:44:18 <lambdabot> Data.List, Prelude
09:44:18 <tibbe> wy, you can also import only specific functions: import Foo (fun1, fun2)
09:44:34 <glguy> or we might both be correct
09:44:45 <phas> like #{peek BLAH, foo]
09:44:52 <sjanssen> glguy: yeah, I'm not sure how that works off the top of my head
09:44:52 <tibbe> is there a good way to hide some of the prelude without qualifying everything?
09:44:54 * sjanssen tests
09:44:54 <phas> >>= peekCStrint
09:45:03 <wy> I see. Thank you!
09:45:03 <phas> i can acces the first but not the second :|
09:45:07 <phas> any hints?
09:45:55 <wy> And is there a way to redefine functions when there is some function with the same name in the running interpreter?
09:47:32 <sjanssen> glguy: looks like you need to hide it in each import that exports head
09:47:36 <tibbe> wy, let f = ... doesn't work?
09:47:48 <tibbe> ie just redefine it
09:47:54 <phas> ?help
09:47:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:47:59 <phas> ?list
09:48:00 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
09:48:03 <glguy> > let head = tail in head [1,2]
09:48:04 <lambdabot>  [2]
09:48:12 <sjanssen> glguy: so you always need import Prelude hiding (head), and if you have imported Data.List, you'll have to hide it there too
09:48:19 <phas> ?seen dcoutts
09:48:19 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I last heard dcoutts speak 7h 16m 22s ago.
09:48:21 <glguy> sjanssen: seems reasonable
09:48:30 <phas> ?seen dons
09:48:30 <lambdabot> dons is in #ghc, #haskell-overflow, #haskell and #Haskell. I last heard dons speak 3h 6m 52s ago.
09:49:20 <wy> tibbe: Surely it works. I'm just wondering if there is a way to undefine function?
09:49:30 <sjanssen> wy: what do you mean by "redefine"?  Note that if you write a function called "head" that shadows the Prelude head, functions that already use head won't work differently
09:49:40 <tibbe> wy: dunno, sorry
09:50:02 <phas> maybe you can do by handy :P
09:50:07 <sjanssen> wy: :r in ghci will unload all the functions that you've defined with let
09:50:09 <phas> accessing the simble table :P
09:50:28 <phas> symbol table
09:50:34 <glguy> wy: make a file with the imports in it
09:50:37 <glguy> wy: load that
09:50:41 <glguy> and then do the rest in the interpreter
09:51:07 <wy> lunch time. See you!
09:54:29 <tibbe> I need some simple stream based xml parsing, is HaXmL what I'm looking for?
09:55:50 <Binkley> tibbe: I've used HaXmL quite successfully for that. Don't know what else is out there, though.
09:56:07 <tibbe> my document is really simple, one top level element with children to that, I need the as [(Key, Value)]
09:56:24 <Binkley> yeah, that was about the level of stuff I was doing
09:56:40 <tibbe> I don't know the schema beforehand
09:58:51 <Binkley> you don't need to know the schema
10:00:43 <wy> Back. I want to know how to go to the error location in haskell-mode. Anyone knows how?
10:01:13 <SamB_XP> wy: there are no error locations in Haskell source ;-)
10:01:38 <SamB_XP> however compilation-minor-mode might be useful
10:03:48 <tibbe> wy, i've forgot how to do it, if you find out please tell me
10:04:02 <ikaros> hi, anyone compiled and installed hide?
10:04:16 <ikaros> the 2.x version
10:09:03 <tibbe> Binkley: how did you get stream parsing?
10:09:50 <gour> ikaros: you mean hIDE?
10:10:50 <ikaros> yes sorry ;)
10:11:08 <gour> ikaros: there is 2.x somewhere?
10:11:22 <ikaros> well i read in the wiki
10:11:32 <ikaros> http://www.haskell.org/haskellwiki/HIDE
10:11:35 <lambdabot> Title: HIDE - HaskellWiki
10:11:39 <ikaros> and used the darcs repo 
10:11:56 <ikaros> thought it would be sort of 2.x ;) 
10:12:11 <gour> ikaros: ahh, ok. that's the proposal for a new one.  i forgot about 1.x :-(
10:12:24 <ikaros> look at point 4 in the wiki
10:12:31 <gour> ikaros: i doubt it is buildable, ask Lemmih
10:13:23 <ikaros> ok.. im new to haskell and trying to find some kind of ide.. i got a eclipse plugin but i wanted to try some more
10:14:07 <ikaros> so the 1.0 of hIDE is usable? i found a link to an IDE called haste but the site seems to be dead
10:14:19 <gour> ikaros: i'd also like to have something less bloated than eclipse
10:14:36 <lispy> s/bloated/broken/
10:14:42 <ikaros> =)
10:14:46 <gour> ikaros: in the meantime i use PIDA
10:15:45 <gour> ikaros: http://pida.berlios.de/
10:15:46 <lambdabot> Title: Home - PIDA
10:15:48 <ikaros> and you can recommend it?
10:15:59 <ikaros> thx yes i just found a pkg build for my distro
10:16:26 <gour> ikaros: well, if you are familiar with gvim, latest code is in, see http://pida.berlios.de/developers/
10:16:28 <lambdabot> Title: Developers - PIDA
10:16:48 <gour> ikaros: it's light and recognizes darcs repos
10:17:01 <ikaros> i will have a look at it thx
10:17:15 <sjanssen> gour: this looks neat
10:17:20 <gour> ikaros: there is also #pida, but not so live
10:17:49 <sjanssen> I like the approach of embedding an editor, instead of making me learn yet another set of key bindings
10:17:52 <Saizan> there's also emacs in haskell mode
10:17:53 <gour> sjanssen: i like it since there is no hIDE
10:18:25 <sjanssen> gour: do you know much about the project?  what's it written in?
10:18:32 <ikaros> Saizan, i know but im not into emacs.
10:18:42 <gour> sjanssen: python, it uses kiwi too
10:19:31 <gour> sjanssen: main dev is busy with life atm :-(
10:20:46 <sjanssen> gour: hmm.  If it were C, it'd be easy to write plugins for it in Haskell
10:20:51 <gour> sjanssen: there are few editors available
10:21:26 <gour> sjanssen: well, missinhg should provide for python <---> haskell
10:21:40 <sjanssen> oh right, forgot about that
10:22:18 <gour> for now, there is gvim + darcs + few useful plugins in one place, cute
10:23:00 <sjanssen> gvim + darcs sounds like 66% of what I need
10:23:06 <gour> sjanssen: checkout latest code with bzr - 0.4beta
10:23:21 <lispy> emacs has darcsum, i wonder if that could be ported to vim
10:23:39 * gour thinks life is too short for emacs
10:24:01 <ikaros> my opinion ;)
10:24:24 <gour> sjanssen: and visit #pida asking for more (aa_ is main dev )
10:27:28 <Saizan> I started using it few weeks ago learning lisp, and it's just easy to use for what i need
10:28:21 * eviltwin_b thinks life is too short to *not* use emacs.  or vim, which is vi trying to be emacs :)
10:28:43 <eviltwin_b> (...and succeeding beyond your wildest nightmares)
10:31:06 <emu> i've been working on making haskell-mode more IDEy
10:33:20 <Saizan> like?
10:34:05 <Saizan> it needs something to manage the building maybe
10:44:06 <Syzygy-> sigfpe__: First time @ #haskell?
10:44:23 <sigfpe__> I've lurked a tiny bit
10:44:36 <Syzygy-> Ah. You're the reason I'm here, y'know... ;)
10:44:41 * Syzygy- is michi of mikael.johanssons.org
10:45:04 <sigfpe__> Yup, I guessed
10:45:21 <sigfpe__> Unfortunately, can't chat, gotta go out right now...
10:58:21 <emu> Saizan: hmm? use cabal for that
10:58:35 <emu> i was thinking more along the lines of doc/introspective tools
11:00:12 <Saizan> emu: i was thinking of something that creates a .cabal and a Setup file for me and runs it on demand :D
11:01:29 <emu> yea that wouldn't be too hard
11:01:34 <emu> i'll think about that too
11:02:21 <emu> i typically develop interactively using C-c C-l to load the file
11:02:28 <Saizan> me too
11:02:38 <tibbe_> I need a SAX parser.
11:03:05 <lispy> tibbe_: is that the event based xml parser?
11:03:10 <tibbe> lispy: yes
11:03:31 <lispy> tibbe: ah okay, there is some stuff about using lazy xml pasers in haskell to get the same effect
11:03:44 <tibbe> lispy: you think haxml would do?
11:03:55 <lispy> tibbe: but i don't know if any of the existing haskell xml parsers are actually lazy
11:04:01 <lispy> tibbe: not sure
11:04:11 <lispy> tibbe: lazy parsers are extremely hard to make it seems
11:04:13 <tibbe> lispy: ok
11:04:32 <tibbe> lispy: i'll try haxml
11:04:56 <tibbe> lispy, do you know which xml parsers are currently being maintained?
11:05:02 <tibbe> i.e. is there any options?
11:05:24 <lispy> tibbe: okay, if you need high performance, i submitted some patches to haxml recently to get better performance when writing the xml, but i don't know if anyone has done the same for the parsing end (I converted it to use data.bytestring)
11:05:35 <lispy> haxml and hxt
11:05:40 <lispy> or is it htx
11:05:58 <tibbe> hxt
11:06:10 <tibbe> i have a really simple document i want to parse
11:06:12 <tibbe> @paste
11:06:12 <lambdabot> http://paste.lisp.org/new/haskell
11:06:33 <lispy> tibbe: do you have a dtd?
11:06:47 <lispy> if so, haxml can generate the code for manipulating your document
11:07:23 <lisppaste2> tibbe pasted "simple xml to parse" at http://paste.lisp.org/display/30734
11:07:52 <tibbe> lispy: no, the element names are not known until runtime
11:07:58 <tibbe> and they might change during runtime
11:08:33 <tibbe> i want to extract the name of the top element and convert the elements directly beneath it to key-value pairs
11:08:37 <lispy> tibbe: is this jabber?
11:08:54 <tibbe> lispy: nope, some REST stuff i'm playing with
11:09:18 <lispy> okay, well haxml can work, i haven't really played with the general xml combinators though
11:09:23 <tibbe> I want: Xml -> (TopNodeName, [(Key, Value)] -- all strings
11:09:38 <tibbe> missing a )
11:09:40 <lispy> i bet that should be easy
11:09:49 <tibbe> it should be!
11:09:58 <tibbe> it's even regex easy
11:10:13 <LoganCapaldo> @hoogle Xml -> (String, [(String, String)])
11:10:14 <glguy> It's funny to me that the top link of programming.reddit.com discusses how lazy evaluation is faster than eager evaluation
11:10:14 <lambdabot> No matches, try a more general search
11:10:16 <tibbe> since there's no arbitrary nesting
11:10:20 <glguy> yet there are no comments at all
11:11:49 <tibbe> glguy: perhaps many feel they're not qualified to comment
11:11:58 <tibbe> although, that has never stopped anyone....
11:12:43 <newsham> offtopic: anyone here know XSL and wouldnt mind answering a few questions (in /msg)
11:13:43 <LoganCapaldo> well assuming an ideal lazy evaluator and an ideal strict evaluator, for an arbitrary program wouldn't the lazy evaluator have to be at least as fast as the strict evaluator?
11:14:00 <Binkley> glguy: just wait till qwe1234 gets there...
11:14:30 <glguy> Binkley: I've found myself agreeing with qwe1234 on two occasions =/
11:14:32 <newsham> wouldnt there be overhead code in a lazy evaluator to make sure that values were computed once and only once?
11:14:44 <Binkley> glguy: well, even a broken clock is right twice a day
11:14:53 <newsham> (ie. an indirect jump, and code to replace the jump once a value has been computed)
11:14:54 <glguy> Binkley: but I did write: I'm pretty sure that qwe1234 is just part of some psychology experiment to see how a social bookmarking site responds to complete ignorance.
11:14:58 <lispy> newsham: with sometimes of analysis that can be removed in special cases
11:15:00 <glguy> Binkley: and got +12 for it
11:15:01 <Binkley> heh, yeah, I think I saw that
11:15:11 <Binkley> flaming him is generally a good way to get points
11:16:50 <eviltwin_b> newsham: depends on whether you're doing memoization, or common sub-expression elimination
11:16:54 <eviltwin_b> the latter is compile-time
11:18:12 <SamB_XP> newsham: well, GHC leaves the latter to the garbage collector sometimes...
11:19:12 <SamB_XP> depends on whether it can figure out how to update the closure in-place or not...
11:19:39 <newsham> even the presence of the indirect jump is overhead, no?
11:19:47 <newsham> (small though it may be)
11:20:50 <SamB_XP> yeah...
11:21:25 <SamB_XP> although I think it might actually just be a "case" or similar...
11:24:37 <alexj__> @help
11:24:38 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:24:50 <alexj__> @list
11:24:50 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
11:27:57 <mentomorph> Hi, please I "IO is not applied to enough type arguments" from ghci in "type Program = ReaderT DrawWindow (WriterT [IO] (IO String))
11:28:06 <mentomorph> I get "IO...
11:28:19 <alexj__> @type g x y = let ?f = \x-> x in ?f x ++ (show (?f y))
11:28:21 <lambdabot> parse error on input `='
11:28:25 <eviltwin_b> [IO] is meaningless, it needs a type
11:28:39 <eviltwin_b> that is, [IO something]
11:28:46 <alexj__> @type \x y -> let ?f = \x-> x in ?f x ++ (show (?f y))
11:28:47 <lambdabot> [Char] -> [Char] -> [Char]
11:28:59 <LoganCapaldo> even if its just type Program a = ...[IO a]...
11:29:10 <alexj__> @type \x y ->let f = \x-> x in f x ++ (show (f y))
11:29:11 <mentomorph> aah! thx
11:29:11 <lambdabot> forall a. (Show a) => [Char] -> a -> [Char]
11:29:32 <alexj__> anyone here know why using implicit type variables changes the type of these two expressions?
11:30:30 <lispy> alexj__: no idea, but this looks very similar to a post from haskell-cafe recently
11:30:58 <eviltwin_b> alexj__: monomorphism restriction on implicit variables?
11:32:31 <alexj__> eviltwin_b: ok.  if I wanted to reuse the same function on different types passed as an implicit var.  how do I specify its type so that is allowed?
11:33:06 * eviltwin_b is not an expert on implicit vars
11:33:25 <eviltwin_b> but I did read over the ghc docs on implicit variables recently and noted the monomorphism restriction
11:33:34 <eviltwin_b> might check the ghc docs to see if they have suggestion
11:33:44 <eviltwin_b> s
11:34:11 <alexj__> what I am currently doing is this: tt' h p = let ?withPassNet=wpn 
11:34:13 <alexj__>               ?withPassNet'=wpn 
11:34:14 <alexj__>               ?withPassNet''=wpn  
11:34:16 <alexj__>           in passNet' b "passnet" "user" regImpl (h::String) p
11:34:26 <alexj__> so I can use wpn in three different type contexts.
11:34:34 <alexj__> but that is really really ugly.
11:39:23 <glguy> alexj__: use 
11:39:25 <glguy> ?paste
11:39:25 <lambdabot> http://paste.lisp.org/new/haskell
11:39:45 <glguy> for long pastes if you want them to be formatted corectly, and to be read ty people in the channel
11:45:08 <alexj__> glguy: oh that's useful!
11:45:58 <tibbe> what would be a good variable name for a list of key-value pairs [(String, String)]? :)
11:46:28 <Botje> dictionary? assocList? aList?
11:47:12 <tibbe> hmm, yes something like that
11:47:18 <tibbe> dict sounds good to me
11:47:20 <tibbe> or assoc
11:50:23 <augustss> or keyValues, or kvs
11:50:42 <Korollary> where did lennart go and who's this augustss person?
11:50:52 <SamB_XP> well, like, what is it for?
11:51:37 <tibbe> SamB_XP: well, any key-value mapping to xml
11:51:50 <tibbe> ie translate key to tag and value to text content
11:52:06 <tibbe> i was looking for an idiomatic name
11:52:08 <SamB_XP> I'd go with alist or aList
11:52:44 <tibbe> i read that as "a list"
11:53:20 <SamB_XP> maybe assocs then...
11:53:32 <tibbe> ?hoogle (a -> b -> c) -> (a, b) -> c
11:53:33 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
11:53:33 <tibbe> yeah
11:53:43 <tibbe> oh, uncurry eh
11:53:55 <emu> when you use the +RTS -t option to output a statistic, does "14.60 GC (14.70 elapsed)" mean 14 seconds spent in GC?
11:54:07 <tibbe> > uncurry (++) ("a", "b")
11:54:09 <lambdabot>  "ab"
11:55:15 <tibbe> @pl ++ " = " ++
11:55:15 <lambdabot> (line 1, column 1):
11:55:15 <lambdabot> unexpected "+"
11:55:15 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
11:55:27 <tibbe> @pl (++ " = ") ++
11:55:27 <lambdabot> (line 1, column 14):
11:55:28 <lambdabot> unexpected end of input
11:55:28 <lambdabot> expecting white space or simple term
11:55:32 <tibbe> @pl ((++ " = ") ++)
11:55:33 <lambdabot> ((++ " = ") ++)
11:55:38 <tibbe> doh
11:57:08 <tibbe> ?type uncurry ((++ " = ") ++)
11:57:09 <lambdabot>   Expecting a function type, but found `[a]'
11:57:10 <lambdabot>    Expected type: [a]
12:00:27 <mentomorph> /quit That's all folks!
12:00:38 <newsham> @unpl ((++ " = ") ++)
12:00:39 <lambdabot> (\ b -> (\ a -> a ++ " = ") ++ b)
12:01:46 <tibbe> i tried to write (\(k, v) -> k ++ " = " ++ v) in terms of uncurry
12:02:08 <newsham> @pl \(k, v) -> k ++ " = " ++ v
12:02:09 <lambdabot> uncurry ((. (" = " ++)) . (++))
12:02:44 <tibbe> yeah, didn't look very nice
12:05:07 <tibbe> if i write something in template haskell how portable will it be?
12:05:55 <Igloo> Not very, currently
12:06:01 <lispy> tibbe: afaik, TH is ghc only...i don't think even hugs supports it
12:06:28 <Igloo> I think it will become as portable as GHC, but possibly not until 6.8
12:06:29 <tibbe> lispy: but if i compile stuff everything is statically linked right?
12:06:46 <tibbe> if i make a lib out of my code
12:06:52 <emu> heh, raising the minimum allocation area size reduced my GC overhead by an order of magnitude
12:06:54 <lispy> tibbe: TH happens at compile time if that's what you mean
12:06:56 <tibbe> how portable would that be?
12:07:19 <wy> SamB: Then how do I find out what's wrong?
12:07:47 <lispy> Igloo: i thought TH was available whenever GHC is, or am i missing something?
12:07:59 <Igloo> Whever GHCi is
12:08:09 <SamB_XP> wy: uh, you tried compilation-minor-mode?
12:08:18 <Igloo> Hmm, insert some more letters in that first word
12:08:31 <lispy> WHevaaoeuaouer? ;)
12:08:45 <lispy> Igloo: okay, i guess that makes sense
12:08:56 <Igloo> Who gave you permission to capitalise my 'h'?!
12:09:15 <lispy> tibbe: what do you mean by portability specifically?
12:09:56 <wy> There is something like /home/wy/prog/haskell/1.hs:87:16: parse error on input `|' from ghc. But I can't go to the line from haskell-mode. I think that's not a problem of haskell, but haskell-mode
12:10:26 <tibbe> lispy: hmm, TH is something the compiler does right, some kind of preprocessing?
12:10:44 <lispy> tibbe: yeah, you manipulate ASTs at compile time essentially
12:11:26 <emu> is it possible to change the default minimum allocation area size at compile-time, so i don't have to supply it in the RTS options always?
12:11:34 <tibbe> lispy: what about nhc98 and the other haskell implementations, are they compilers?
12:11:37 <lispy> emu: yes
12:11:52 --- mode: ChanServ set +b palomer!*@*
12:11:52 <lispy> ?google ghc documentation rts options static
12:11:55 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Conventions
12:11:56 <lambdabot> Title: Commentary/Rts/Conventions - GHC - Trac
12:12:07 <lispy> hm...that's not the page i wanted
12:12:15 <palomer_> can someone remove that nickban
12:12:16 <emu> i've been opking around the manual a bit
12:12:39 <lispy> tibbe: ah okay, if by portability you mean working on all haskell implementations, then it's very unportable, from what i understand...and only ghc supports it (afaik)
12:12:54 <palomer_> what should I use for regular expressions in haskell?
12:13:10 <tibbe> lispy: ok
12:13:13 <palomer_> I want to separate a string into a list of words
12:13:27 <sjanssen> palomer_: the new regexp packages in GHC 6.6, perhaps?
12:13:32 <metaperl> palomer_ - is there a fixed delimiter?
12:13:32 <lispy> emu: look at section 4.14.5 on this page: http://www.haskell.org/ghc/docs/6.4.2/html/users_guide/runtime-control.html
12:13:34 <lambdabot> Title: 4.14. Running a compiled program, http://tinyurl.com/ylz9pu
12:13:42 <sjanssen> > words "palomer, will this work?"
12:13:44 <lambdabot>  ["palomer,","will","this","work?"]
12:14:06 <metaperl> if not, MissingH has something that will work
12:14:48 <emu> lispy: yep. but that's RTS options
12:14:58 <newsham> "palomer, will this work?" >>= unwords . return
12:15:00 <emu> Text.Regex.splitRegex works
12:15:03 <newsham> > "palomer, will this work?" >>= unwords . return
12:15:05 <lambdabot>  Couldn't match `String' against `Char'
12:15:14 <lispy> palomer_: i've not used regexp in haskell, but from what i read on the mail list, there are two regexp implementations that come with ghc and two that are seperate....if you use ghc i'd start there
12:15:29 <emu> import Text.Regex, enjoy
12:16:00 <lispy> emu: but you can set the RTS options at compile time to whatever default you need at run-time.  I've done this and it works...but maybe you're option is not available as an RTS option?
12:16:12 <newsham> > unwords $ map return "palomer, will this work?" 
12:16:14 <lambdabot>  "p a l o m e r ,   w i l l   t h i s   w o r k ?"
12:16:44 <emu> lispy: er, but how do you specify them?
12:16:48 <palomer_> eh?
12:16:50 <LoganCapaldo> @type unwords $ map return
12:16:51 <lambdabot>   Expecting a function type, but found `a'
12:16:52 <lambdabot>    Expected type: [String]
12:16:53 <tibbe> hmm, what needs escaping in an sql string?
12:17:01 <palomer_> I want "haha hoho" -> ["haha","hoho"]
12:17:11 <newsham> > words "haha hoho"
12:17:13 <lambdabot>  ["haha","hoho"]
12:17:28 <palomer_> what if there's garbage between haha and hoho?
12:17:30 <lispy> emu: that web page explains :)  You create a .C file with a particular character constant defined, like char* ghc_rts_opts = "blah"; and link it in :)
12:17:34 <tibbe> can hugs load libs compiled with ghc?
12:17:38 <palomer_> like \t and such
12:17:40 <emu> oh that C part
12:17:43 <emu> ugh
12:17:43 <newsham> > words "haha    with garbage !@#@!# hoho"
12:17:45 <lambdabot>  ["haha","with","garbage","!@#@!#","hoho"]
12:17:53 <LoganCapaldo> > words "a\tb"
12:17:54 <lambdabot>  ["a","b"]
12:18:00 <palomer_> okay!
12:18:20 <_magus_> I have a cabal question, how do I know what to put in 'Build-Depends:'?
12:18:26 <lispy> emu: yes, being able to do it from Haskell or on the ghc commandline is a wishlist item, but i would imagine it has low priority
12:18:45 <lispy> emu: of course you can increase the priority by letting the devs know it matters to you
12:20:10 <emu> can cabal deal with this C stub file or do I need to hack it ion
12:20:11 <emu> in
12:20:59 <lispy> cabal should be able to deal with it
12:21:06 <lispy> there is a section for C files
12:21:15 <emu> ok, thanks
12:21:18 <palomer_> is there a function to test the multiplicity of each element in a list?
12:21:25 <lispy> iirc, that's how i did it when i needed it, but i don't have that .cabal file handy to show you
12:22:09 <lispy> palomer_: are your elements in Eq?
12:22:19 <palomer_> yup
12:22:29 <palomer_> they're even in Ord
12:22:47 <lispy> ah okay, then sort the list and group it
12:23:13 <lispy> ?type group . sort
12:23:15 <lambdabot> forall a. (Ord a) => [a] -> [[a]]
12:23:46 <lispy> then you just map down it making tuples of the element and length of list :)
12:23:49 <palomer_> that gives the multiplicity?
12:24:05 <palomer_> ah, ok
12:24:39 <lispy> ?type map (\xs -> (head x, length xs)) . (group . sort)
12:24:40 <lambdabot> Not in scope: `x'
12:24:41 <_magus_> Cabal question: how do I know what to put in 'Build-Depends:'?
12:24:46 <lispy> ?type map (\xs -> (head xs, length xs)) . (group . sort)
12:24:47 <lambdabot> forall a. (Ord a) => [a] -> [(a, Int)]
12:25:04 <lispy> palomer_: that may need to check for empty lists, not sure
12:25:34 * palomer_ prefers $ to .
12:25:35 <LoganCapaldo> > map (\xs -> (head xs, length xs)) . (group . sort) []
12:25:36 <lambdabot>    Expecting a function type, but found `[[a]]'
12:25:36 <lambdabot>    Expected type: a1 -> ...
12:25:37 <palomer_> is it just me?
12:25:45 <LoganCapaldo> > (map (\xs -> (head xs, length xs)) . (group . sort)) []
12:25:46 <lambdabot>  Add a type signature
12:25:50 <sjanssen> _magus_: it should contain all of the packages that contain the modules you use
12:26:01 <LoganCapaldo> palomer_: they don't do the same thing though...
12:26:41 <sjanssen> _magus_: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html -- the package for each module is listed on the right
12:26:43 <lambdabot> http://tinyurl.com/eoao7
12:26:51 <lispy> palomer_: and once you have that list [(a, Int)] you can use lookup to request the multiplicity of a particular element
12:26:54 <palomer_> LoganCapaldo, true, but one can usually be sued for the others
12:27:10 <lispy> _magus_: i don't know how to determine that
12:27:11 <_magus_> sjanssen, thanks!
12:27:13 <palomer_> @pl map (\(a,b)->(b,a))
12:27:13 <lambdabot> map (uncurry (flip (,)))
12:27:17 <sjanssen> palomer_: I used to prefer $, but now I use . for all but the last
12:27:33 <lispy> ?pl \xs -> (head xs, length xs)
12:27:34 <lambdabot> liftM2 (,) head length
12:27:56 <palomer_> sjanssen, what changed your mind?
12:28:21 <sjanssen> palomer_: not entirely sure.  Popular preference was one factor
12:28:44 * glguy agrees with sjanssen on the (.) ($) usage
12:28:54 <palomer_> there's something to agree about?
12:29:25 <_magus_> sjanssen, great, that means only MissingH and System.FilePath aren't covered by base (in this case), any ideas for those two?
12:29:45 <palomer_> @pl \x -> map (\(a,b) -> (b,a)) $ reverse . sort $ map (\x -> (length x,head x)) . (group . sort) $ x
12:29:46 <lambdabot> map (uncurry (flip (,))) . reverse . sort . map (liftM2 (,) length head) . group . sort
12:29:55 <palomer_> now that's one bitching combinator
12:30:08 * palomer_ hugs haskell
12:30:52 <palomer_> ok, now how do I read a file:P
12:30:55 <sjanssen> _magus_: the .cabal files for those projects will say.  You can also run "ghc-pkg list" and look for the reasonable looking choices
12:30:58 <vincenz> palomer_: easier way than that
12:31:01 <sjanssen> @type readFile
12:31:02 <lambdabot> FilePath -> IO String
12:31:33 <palomer_> @hoogle FilePath
12:31:34 <glguy> sortBy (comparing snd) . map (liftM2 (,) head length) . group . sort
12:31:34 <lambdabot> Distribution.Compat.FilePath :: module
12:31:34 <lambdabot> Prelude.FilePath :: type FilePath
12:31:34 <lambdabot> Distribution.Compat.FilePath.breakFilePath :: FilePath -> [String]
12:31:44 <vincenz> @pl \x -> sortBy (\x y -> snd y `compare` snd x) . map (liftM2 (,) length head) . group . sort $ x
12:31:44 <lambdabot> sortBy (const (liftM2 compare snd snd)) . map (liftM2 (,) length head) . group . sort
12:31:52 <vincenz> @type sortBy (\x y -> snd y `compare` snd x) . map (liftM2 (,) length head) . group . sort
12:31:54 <lambdabot> forall a. (Ord a) => [a] -> [(Int, a)]
12:31:59 <_magus_> sjanssen, 'ghc-pkg list' looks good, I'm assuming I just drop the version number?
12:32:04 <vincenz> @type sortBy (\x y -> snd y `compare` snd x) . map (liftM2 (,) head length) . group . sort
12:32:05 <lambdabot> forall a. (Ord a) => [a] -> [(a, Int)]
12:32:11 <glguy> sortBy (rcomparing snd) . map (liftM2 (,) head length) . group . sort
12:32:13 <sjanssen> _magus_: yeah
12:32:13 <vincenz> palomer_: no need to reverse like that
12:32:25 * glguy always defines comparing and rcomparing
12:32:40 <sjanssen> _magus_: there's also syntax for specifying which versions are compatible, but you probably don't need to worry about that
12:32:56 <_magus_> sjanssen, I think you're right about that... thanks for your help
12:33:00 <palomer_> comparing? what's comparing?
12:33:02 <palomer_> @hoogle comparing
12:33:03 <lambdabot> No matches found
12:33:15 <glguy> comparing f x y = f x `compare` f y
12:33:24 <glguy> rcomparing f x y = f y `compare` fx
12:33:33 <sjanssen> @type Data.Ord.comparing
12:33:34 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
12:33:40 <emu> when i tried this program the other day, at first, it took 19 minutes to process one test file.  now it takes 8 seconds to do the same.  woohoo
12:33:42 <vincenz> glguy: why not make it more generic?
12:34:09 <vincenz> swing g f x y = f x `g` f y
12:34:15 <vincenz> then you can do
12:34:15 <sjanssen> glguy: why rcomparing rather than "sortBy (flip . comparing snd)"?
12:34:23 <vincenz> flip (swing compare snd)
12:34:31 <glguy> sjanssen: because rcomparing look cleaner to me
12:34:37 <tibbe> "The rest of us normally-brained Haskell programmers measure our type-hackery in milli-Olegs." :D
12:35:00 <vincenz> that's like mega-perls?
12:35:07 <glguy> vincenz: fine, comparing = swing compare
12:36:31 <glguy> vincenz: and swing = join . liftM2 -- ?
12:36:36 <vincenz> erm
12:36:43 <vincenz> @type join . liftM2
12:36:45 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> a1 -> r) -> m a1 -> m r
12:36:49 <vincenz> no
12:36:52 <glguy> hmm
12:36:54 <glguy> oh
12:37:02 <glguy> swing = (join . ) . liftM2
12:37:08 <vincenz> @type (join .) . liftM2
12:37:09 <lambdabot>   Occurs check: cannot construct the infinite type: m = (->) (m a2)
12:37:10 <lambdabot>    Expected type: (a1 -> a2 -> r) -> m a1 -> m a2 -> m a2 -> a
12:37:36 <vincenz> @pl \g f x y -> f x `g` f y
12:37:37 <lambdabot> join . ((flip . ((.) .)) .) . (.)
12:37:42 <vincenz> there you go
12:37:44 <vincenz> ain't that obvious?
12:37:44 <glguy> hmm :)
12:38:02 <lispy> ah
12:38:06 <lispy> silly me
12:38:20 <lispy> and i thought it would be complicated :)
12:38:38 <vincenz> @type \g f x y -> uncurry g $ liftM2 f f x y
12:38:40 <lambdabot> forall a b c a2. (a -> b -> c) -> ((a2 -> (a, b)) -> a2 -> (a, b)) -> ((a2 -> (a, b)) -> a2) -> (a2 -> (a, b)) -> c
12:39:11 <glguy> what is that supposed to do?
12:39:20 <vincenz> @djinn (a -> a -> b) -> (c -> a) -> c -> c
12:39:21 <lambdabot> f _ _ a = a
12:39:33 <vincenz> @djinn (a -> a -> b) -> (c -> a) -> c -> c -> b
12:39:34 <lambdabot> f a b c _ = a (b c) (b c)
12:39:34 <sjanssen> @djinn (a -> b -> c) -> ((a2 -> (a, b)) -> a2 -> (a, b)) -> ((a2 -> (a, b)) -> a2) -> (a2 -> (a, b)) -> c
12:39:35 <lambdabot> f a _ b c =
12:39:35 <lambdabot>   case c (b c) of
12:39:35 <lambdabot>   (d, e) -> a d e
12:40:05 <tibbe> does the guy who wrote SafeStrings hang out here?
12:41:00 <phas> ?seen dons
12:41:00 <lambdabot> dons is in #ghc, #haskell-overflow, #haskell and #Haskell. I last heard dons speak 5h 59m 16s ago.
12:41:06 <phas> ?seen dcoutts
12:41:07 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc and #haskell-overflow. I last heard dcoutts speak 10h 9m 4s ago.
12:41:55 <sjanssen> tibbe: SafeString?
12:42:09 <glguy> I've never heard SafeStrign mentioned in #haskell
12:42:22 <glguy> What does it do
12:42:39 <tibbe> type based solution for cross-site scripting
12:42:55 <tibbe> http://blog.moertel.com/articles/2006/10/18/a-type-based-solution-to-the-strings-problem
12:42:57 <lambdabot> Title: A type-based solution to the "strings problem": a fitting end to XSS and SQL-inj ..., http://tinyurl.com/uv94m
12:43:17 <sjanssen> tibbe: he hangs out here, tmoertel is his nick
12:43:28 <tibbe> sjanssen: oki
12:43:36 <LoganCapaldo> I read that and was annoyed because I had the same idea and did nothing about it :)
12:43:41 <tibbe> i was wondering if he ever released something
12:44:01 <glguy> Was SQL injection ever really an "unsovled" problem for anyone but PHP programmers?
12:44:02 <sjanssen> tibbe: don't think so
12:44:07 <tibbe> i need to combine lots of xml, sql, html and urls right now
12:44:30 <tibbe> glguy: it rears its ugly head once in a while
12:44:50 <tibbe> usually it's not on some high value site though
12:45:27 <tibbe> you have to remember to put in your "h" and stuff in ruby for example
12:45:42 <glguy> ?
12:45:45 <glguy> put in your "h"?
12:45:54 <tibbe> it's an escape
12:46:17 <tibbe> <?= h "my thing that needs to be escaped" ?>
12:46:35 <tibbe> html escape
12:46:36 <glguy> SQL injection is sovled by using parameterized queries though
12:46:41 <tibbe> there's also an sql escape
12:46:52 <tibbe> glguy: how do you mean?
12:47:16 <glguy> you shouldn't ever be doing : "SELECT FROM X WHERE USER =" + username
12:47:37 <chessguy> well, unless you've made sure the string in username is safe
12:47:42 <tibbe> RoR has those, but sometimes you need to escape to regular SQL and better not forget to escape properly
12:47:46 <tibbe> and not double escape
12:48:21 <tibbe> anyway, you need to escape once and only once and forgetting to do it once can lead to trouble
12:48:24 <glguy> the correct answer is: (for example) q = new query ("select from x where user = ?"); a.parameter.add(username)
12:48:33 <LoganCapaldo> heh
12:48:34 <glguy> not to screw about with escaped strings
12:49:26 <tibbe> I took a programming language safety course at chalmers last year, then XSS attacks where still very common
12:49:31 <LoganCapaldo> what about Select AllColumns (Table "x") (Eq "user" username)
12:49:33 <tibbe> the most common vulnerability
12:49:50 <tibbe> i wish i remember the stats, let me go check if I can find them
12:50:19 <glguy> stopping people from embedding HTML code in stuff is different than stopping SQL injection
12:50:21 <LoganCapaldo> I imagine that would be pretty hard to inject into, even if you were really lazy
12:50:50 <tibbe> Language-Based Security was the course's name
12:51:00 <LoganCapaldo> Just don't expose the apis that take the strings of SQL
12:51:09 <tibbe> glguy: yes, but it's also a problem if you can embedd javascript
12:51:16 <tibbe> it's also a XSS vulnerability
12:51:21 <glguy> The DBA at my work would revoke my DB rights if he caught me manually concatenating queries
12:51:29 <glguy> tibbe: sure, but that's a different problem
12:51:58 <tibbe> glguy: well the cause is the same
12:52:02 <tibbe> unchecked string input
12:52:09 <glguy> and should be solved in a similar manner
12:52:25 <tibbe> apparently I can't access my uni's web site from here
12:52:27 <glguy> not hoping that you remembered to check all strigns, but using a safe interface
12:52:43 <tibbe> such as safe strings
12:52:57 <glguy> like I said, I don't know anything about SafeStrings
12:53:10 <wy> I find that haskell-mode can't indent the expressions properly. What editors do you guys use?
12:53:11 <glguy> I was just arguing that the sql-injection problem was solved
12:53:28 <yaxu> tibbe: are you on a laptop that you also take to uni?
12:53:54 <tibbe> glguy: let me see if I can get the data on the number of attacks
12:54:00 <tibbe> yaxu: yes
12:54:06 <sjanssen> wy: I use vim, and spend too much time indenting manually
12:54:11 <yaxu> tibbe: when that happens to me it's because i am trying to use my uni's wired internet settings at home
12:54:15 <glguy> tibbe: I'm not arguing that people know about the solutions, just that they eist
12:54:23 <_matthew-> it's a type problem - String is too wide a type so don't use it for SQL
12:54:29 <tibbe> yaxu: I'm outside their firewall now, that's the problem
12:54:47 <tibbe> glguy: but I'm not sure if they are as successful as you believe
12:55:21 <palomer__> hrmph
12:55:26 <wy> sjanssen: Uhh... It seems it shouldn't use indentation to express grouping
12:55:33 <tibbe> glguy: Ruby on Rails has such a solution you mention, an api that's supposed to do it for you
12:55:37 <palomer__> writing a function which takes a string and says if its an english noun doesn't seem easy to come by
12:55:37 <wy> Same problems as Python
12:55:42 <tibbe> glguy: but it's non-trivial
12:55:46 <glguy> tibbe: sure, but then you have to code in Ruby
12:55:55 <sjanssen> glguy: SafeStrings is tmoertel's attempt at handling the strings problem with Haskell's type system
12:56:11 <_matthew-> haskelldb anyone?
12:56:12 <glguy> hmm, I'll have to do some reading
12:56:30 <tibbe> glguy: what I'm saying is that RoR has XSS problems even with it's api, it's hard to get all possible leaks, escaping everything might be wrong as well
12:57:15 <glguy> I like reddit's comment system
12:57:19 <tibbe> of course it can be done, the question is how easy it is
12:57:24 <sjanssen> wy: you can always use explicit layout with { } and ; if you want
12:57:41 <glguy> all HTML is escaped, formattign is done in a customer fashion
12:58:11 <glguy> custom*
12:58:43 <glguy> (my ssh session has been lagged today, I'm getting whole lines typed before the screen refreshes)
12:59:35 <wy> How can I group let y   = 2
12:59:35 <wy>     f x = x+y
12:59:35 <wy> in f 3 with {} and ;?
12:59:37 <palomer__> what would you guys use to get the first 100 elements of a list?
12:59:45 <Philippa> take 100
13:00:00 <glguy> let { y = 2; f x = x + y} in f 3
13:00:01 <palomer__> thx
13:00:40 <tibbe> is there two palomer?
13:04:00 <_matthew-> @seen Igloo 
13:04:01 <lambdabot> Igloo is in #darcs, #ghc, #haskell and #Haskell. I last heard Igloo speak 55m 2s ago.
13:05:06 <Igloo> Hello
13:05:24 <tibbe> palomer_: you were awfully strict before ;)
13:05:28 <wy> Why doesn't this work? let x=2 in ff = (\y->y+x)
13:05:50 <mauke> you can't use = in expressions
13:05:59 <glguy> wy because after the in must come an expression
13:06:09 <glguy> let ... in ...      is one expression
13:06:15 <_matthew-> Igloo, libghc6-opengl-dev
13:06:18 <palomer_> tibbe, strict about what?
13:06:21 <_matthew-> I've just installed it
13:06:27 <_matthew-> along with the glut one
13:06:38 <_matthew-> and I'm getting  linkage errors
13:06:45 <tibbe> palomer_: nevermind, it was a joke ;)
13:06:46 <palomer_> if anyone writes me a function which recognizes english nouns I'll kiss them
13:06:57 <_matthew-> such as "undefined reference to glutMainLoop"
13:07:15 <_matthew-> on a custom compiled ghc6.6, all is well. any ideas?
13:07:28 <Igloo> _matthew-: Can you give me an example program please?
13:07:29 <tibbe> glguy: the slides they put online didn't include the data, they wrote an automatic XSS vulnerabiliy checker for SQL, they found many vulnerable sites to say the least
13:07:29 <phas> where i can find how to register a lib in ghc?
13:07:51 <phas> you know, for making it available for other programs
13:07:58 <wy> Then how can I pass the function from the expression "let x=2 in (\y->y+x)" to the outside?
13:07:58 <glguy> tibbe: yeah, I can imagine that a lot of people don't use parameterized queries or even know to escape the strings when they don't
13:08:11 <Igloo> phas: The recommended way is to cabalise it, and then cabal takes care of it for you
13:08:31 <glguy> wy: ff = whatever where y = 2
13:08:38 <sjanssen> palomer_: I'll give you the first and last lines; isNoun "potato" == True; ...; isNoun _ = False
13:08:51 <palomer_> pfffft
13:09:00 <palomer_> isn't there a limit to the size of a haskell file?
13:09:06 <tibbe> glguy: I'm having some trouble proving my point since I don't have concrete statistics on how many sites with parametrized queries (like ruby on rails) which has these kinds of vulnerabilities.
13:09:17 <phas> Igloo: ok,of course, but at the moment i need to make some quick test and i don't know how to cabalize my lib, because is a binding and some parts are in C and i don't know very well how to use cabal
13:09:45 <_matthew-> Igloo: err, before I do that, are there any special ghc flags or anything that I need?
13:10:26 <Igloo> _matthew-: --make or -package GLUT (I assume)
13:10:36 <Igloo> _matthew-: Oh, did you install the glut package too?
13:11:11 <_matthew-> yes
13:11:38 <_matthew-> mmm. am using make
13:11:45 <_matthew-> as in --make
13:11:51 <_matthew-> one program coming right up
13:13:09 <_matthew-> @paste
13:13:09 <lambdabot> http://paste.lisp.org/new/haskell
13:15:17 <lisppaste2> _matthew- pasted "libghc6-(opengl|glut)-dev issue" at http://paste.lisp.org/display/30747
13:16:40 <_matthew-> similar linkage failure with -package GLUT
13:16:54 <LoganCapaldo> _matthew-: I have import Graphics.Rendering.OpenGL in my random "play with GLUT" app
13:17:08 <LoganCapaldo> in addition to import Graphics.UI.GLUT
13:17:18 <LoganCapaldo> are you sure mainLoop doesn't come from there?
13:17:58 <_matthew-> well it doesn't compile if I add that
13:18:10 <LoganCapaldo> Neat! :)
13:18:11 <_matthew-> and with a custom compiled ghc6.6, that import is unneeded
13:18:32 <LoganCapaldo> well it was worth a shot
13:18:40 <_matthew-> sure.
13:19:09 <_matthew-> I have the freeglut +-dev stuff installed too.
13:19:21 <_matthew-> could be a missing dependancy I guess. just not sure what
13:22:20 <_matthew-> mmm. I now doubt that - on the same machine with a custom compiled ghc6.6, the debian package gives linkage errors
13:22:42 <_matthew-> if that machine had enough to build haskell opengl and glut then it should have enough to link
13:23:03 <_matthew-> so looks like an unhappy package. Igloo ?
13:24:19 <wy> Can I write "if" statements without "else"?
13:25:09 <_matthew-> wy: no. what would the type of the expression be if the condition fails?
13:25:12 <glguy> wy: only in Monadic code, and there its called a when
13:25:41 <glguy> when (i > 0) (print i)
13:25:58 <Igloo> _matthew-: When you say custom compiled, do you mean with the extralibs tarball or building it with cabal?
13:26:05 <glguy> which becomes: if (i >0) then (print i) else (return ())
13:26:18 <_matthew-> Igloo, extralibs
13:26:36 <_matthew-> tar, ./configure, make, make install
13:26:37 <Igloo> Right, the cabal file doesn't have an ld-options while the package.conf.in does
13:27:32 <_matthew-> ok... so the deb packages are build the cabal way and so don't specify linkage options?
13:27:43 <Igloo> Looks that way
13:28:07 <Igloo> Oh, no, I see, it's meant to make a buildinfo file
13:28:16 <wy> It's strange that "fff x = if (x<0) then 1 else []" can be typed. It's fff :: (Num [a1], Num a, Ord a) => a -> [a1]. What does this mean?
13:28:47 <vincenz> @type "fff x = if (x<0) then 1 else []
13:28:49 <lambdabot> lexical error in string/character literal
13:28:50 <vincenz> @type fff x = if (x<0) then 1 else []
13:28:52 <lambdabot> parse error on input `='
13:29:00 <glguy> ?type if (x<0) then 1 else []
13:29:01 <lambdabot> Not in scope: `x'
13:29:08 <glguy> ?type \x-> if (x<0) then 1 else []
13:29:10 <lambdabot> forall a a1. (Ord a, Num a, Num [a1]) => a -> [a1]
13:29:22 <glguy> that means that lambdabot uses a custom parser
13:29:23 <sjanssen> wy: the literal "1" is overloaded.  The type means that given an instance of Num for [a1], fff has that type
13:29:58 <glguy> (what sjanssen said)
13:30:05 <vincenz> glguy: no, lambdabot just parses exps, not defs
13:30:08 <vincenz> for @pl
13:30:13 <sjanssen> glguy: this doesn't have anything to do with lambdabot
13:30:16 <_matthew-> Igloo: I've tried adding a -lGLUT to ghc and ld goes "cannot find -lGLUT" which looks like a parsing error, so I assume I'm specifying that wrongly
13:30:22 <glguy> sjanssen: I'm aware of that now
13:30:30 <glguy> sjanssen: which is why I deferred to yoru answer
13:30:38 <vincenz> > [] + [1]
13:30:39 <lambdabot>  add an instance declaration for (Num [a])
13:30:39 <lambdabot>   In the definition of `bwv': b...
13:30:45 <vincenz> @type \a -> [a] + [1]
13:30:46 <lambdabot> forall a. (Num [a], Num a) => a -> [a]
13:31:24 <Igloo> _matthew-: Just -lGLU, I think
13:32:07 <wy> sjanssen: How can 1 be overloaded? Isn't it just the integer 1?
13:32:25 <_matthew-> Igloo: no, sorry, same thing - undefined ref to glutMainLoop
13:32:28 <sjanssen> wy: nope, it translates into "fromInteger 1"
13:32:35 <Igloo> _matthew-: Oh, sorry, -lglut
13:32:45 <sjanssen> and that's a non-overloaded 1 ;)
13:32:58 <_matthew-> Igloo : BINGO! many thanks
13:33:02 <wy> sjanssen: I can't understand
13:33:08 <vincenz> > fromInteger $ fromInteger 1
13:33:10 <lambdabot>  1
13:33:17 <vincenz> > fromInteger $ fromInteger $ fromInteger $ 1
13:33:19 <lambdabot>  1
13:33:22 <sjanssen> > 1 / 2 -- no / operator for Integers, so Haskell will give us a Double instead
13:33:24 <lambdabot>  0.5
13:33:31 <vincenz> > fix fromInteger
13:33:33 <lambdabot>  Exception: <<loop>>
13:33:37 <_matthew-> Igloo: is that something to add to my Makefile permanently or is it an issue with the current deb package?
13:33:49 <Igloo> _matthew-: The latter
13:33:54 <LoganCapaldo> What is fix?
13:33:55 <Igloo> Bah, my test build works
13:33:57 <LoganCapaldo> I don't get it
13:34:05 <LoganCapaldo> @type fix
13:34:07 <lambdabot> forall a. (a -> a) -> a
13:34:21 <sjanssen> wy: fromInteger is an operation in the Num class, it converts an Integer to some Num type
13:34:31 <LoganCapaldo> @type \f -> f f
13:34:32 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
13:34:32 <lambdabot>    Expected type: t
13:34:41 <LoganCapaldo> well I guess it's not that
13:34:47 <LoganCapaldo> @hoogle fix
13:34:47 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
13:34:48 <lambdabot> Control.Monad.Fix :: module
13:34:48 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
13:34:59 <wy> sjanssen: So it's something to do with type classes? I have read that yet
13:35:10 <mauke> fix f = let x = f x in x
13:35:10 <eviltwin_b> the literal "1" can stand for an Int, an Integer, a Double, etc.  basically, anything in the type class Num
13:35:14 <_matthew-> Igloo: thanks for your help
13:35:26 <Igloo> np
13:35:26 <wy> Does fix mean "fixpoint"?
13:35:35 <augustss> fix f = f $ f $ f ...repeat ifinitelt... $f $ undefined
13:35:40 <sjanssen> wy: right, it involves type classes
13:35:40 <Korollary> fix finds fixpoints
13:35:44 <augustss> infinitely
13:35:48 <wy> sjanssen: Thank you :)
13:36:03 <sjanssen> fix f = f (fix f)
13:36:28 <LoganCapaldo> so what like
13:36:44 <LoganCapaldo> > 2 ^ -3
13:36:45 <lambdabot>    precedence parsing error
13:36:45 <lambdabot>     cannot mix `(^)' [infixr 8] and prefix ...
13:36:50 <Cale> augustss: only you'd never actually reach the point where you'd write undefined that way
13:36:52 <LoganCapaldo> > 2 ^ (-3)
13:36:54 <lambdabot>  Exception: Prelude.^: negative exponent
13:36:59 <Cale> (because that would mean that it was finite)
13:37:05 <LoganCapaldo> > 1 / 2 ^ (3)
13:37:07 <lambdabot>  0.125
13:37:32 <sjanssen> > 2 ^^ (-3)
13:37:33 <lambdabot>  0.125
13:37:36 <augustss> Cale: I know, but it's a good approximation :)
13:37:47 <sjanssen> > 2 ** (-3)
13:37:48 <lambdabot>  0.125
13:38:03 <vincenz> @type (^)
13:38:05 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
13:38:05 <vincenz> @type (^^)
13:38:07 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
13:38:07 <vincenz> @type (**)
13:38:08 <lambdabot> forall a. (Floating a) => a -> a -> a
13:38:24 <Cale> Right, if you choose some finite number of f's and end with undefined, then you get a good approximation to the behaviour of fix f
13:38:33 <augustss> (2%1)^^(-3)
13:38:42 <augustss> > (2%1)^^(-3)
13:38:43 <lambdabot>  1%8
13:38:48 <Saizan> uhm why the fixed point combinator doesn't typecheck?
13:39:09 <Cale> @type let fix f = f (fix f) in fix
13:39:11 <lambdabot> forall t. (t -> t) -> t
13:39:15 <augustss> Cale: and then you take the limit of the finite ones
13:39:21 <Cale> augustss: yeah
13:39:32 <Saizan> > :type \f -> (\x -> f (x x)) (\x -> f (x x))
13:39:32 <lambdabot>  Parse error
13:39:37 <vincenz> @type let fix f = fix (f .f)
13:39:38 <Cale> @type x x
13:39:39 <lambdabot> not an expression: `let fix f = fix (f .f)'
13:39:40 <lambdabot> Not in scope: `x'
13:39:40 <lambdabot>  
13:39:40 <lambdabot> <interactive>:1:2: Not in scope: `x'
13:39:41 <mauke> @type let fix f = let x = f x in x in fix
13:39:42 <lambdabot> forall t. (t -> t) -> t
13:39:42 <Cale> @type \x -> x x
13:39:44 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
13:39:45 <lambdabot>    Expected type: t
13:39:50 <vincenz> @type let fix f = fix (f .f) in fix
13:39:52 <lambdabot> forall c t. (c -> c) -> t
13:39:57 <Saizan> ?type \f -> (\x -> f (x x)) (\x -> f (x x))
13:39:58 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
13:39:59 <lambdabot>    Expected type: t
13:40:13 <Cale> x x doesn't typecheck for any x
13:40:29 <augustss> fix can only be type check (in haskell) by using some kind of built in recursion
13:40:33 <vincenz> @type \x -> (x x)
13:40:34 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
13:40:35 <lambdabot>    Expected type: t
13:40:39 <Cale> That fixpoint combinator only works in untyped lambda calculi
13:41:11 <Saizan> uhm, i see
13:42:04 <palomer_> groupByTwo (a:b:cs) = (a,b):(groupByTwo cs);groupByTwo [] = [] 
13:42:10 <palomer_> anyone have a nice combinator for that?
13:42:21 <augustss> Saizan: you can avoid value recursion by using a recursive type
13:42:54 <Saizan> for example?
13:43:04 <glguy> palomer_: groups n = map (take n) . takeWhile (not. null) . interate (drop n)
13:43:08 <resiak> palomer_: what about groupByTwo [1] ? :)
13:43:23 <augustss> Saizan: some version of data D = C (D->D)
13:43:26 <glguy> palomer_: groups n = unfoldr (liftM2(>>)(guard.not.null)(return.splitAt n))
13:43:31 <palomer_> resiak, that fails
13:43:58 <resiak> palomer_: heh :)
13:44:02 <glguy> palomer_: unless you wanted tuples, then:
13:44:02 <newsham> zip the evens and odds?
13:44:11 <palomer_> yeah, I wanted tuples
13:44:26 <palomer_> [1,2,3,4] -> [(1,2),(3,4)]
13:45:20 <palomer_> how do you get the even elements?
13:45:22 <glguy> then, I don't see how you will get a pretty point-free version
13:45:30 <augustss> @pl \ xs -> zip (iterate (tail.tail) xs) (tail (iterate (tail.tail) xs))
13:45:30 <lambdabot> ap (zip . iterate (tail . tail)) (tail . iterate (tail . tail))
13:45:47 <glguy> palomer_: and I think you are misusing combinator
13:45:50 <glguy> I could be wrong again today
13:46:01 <palomer_> combinator is any closed term
13:46:26 <palomer_> in lambda calculus, at least
13:47:28 <glguy> hmm ok
13:47:35 <Krunch> why doesn't this work ? http://paste.debian.net/17322
13:47:37 <glguy> I usually hear it in the monad context
13:47:45 <glguy> so I wasn't sure
13:47:55 <palomer_> hrmph, how would you guys split a list into contiguous segments that satisfy a predicate?
13:48:18 <mauke> @type groupBy
13:48:19 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
13:50:14 <palomer_> @pl map tolower
13:50:15 <lambdabot> map tolower
13:50:18 <glguy> Krunch: what exactly do you want that function to do?
13:51:03 <Cale> Krunch: maybe you want to recurse on (drop y (z:zs)) instead?
13:51:20 <Krunch> glguy: i want it to keep only x elements on y
13:51:28 <Cale> er
13:51:41 <Krunch> Cale: yes that's what i tough but it looks like it doesn't work either
13:51:59 <glguy> join . takeWhile (not . null) . map (take x) . iterate (drop y) -- like this?
13:52:06 <Cale> Well, let's write this in a saner way :)
13:52:20 <Cale> yeah, like glguy did :)
13:52:44 * Krunch looks up takeWhile and iterate
13:52:46 <Cale> though you might want to use concat, which is in the Prelude rather than join which is in Control.Monad
13:53:01 <glguy> anyone else: is "x on y" another common idiom that I don't know
13:53:11 <Cale> glguy: I've never seen this
13:53:46 <Cale> I'm not completely sure of the meaning of 'on' here.
13:53:58 <glguy> closest I can guess is "of"
13:54:02 <newsham> > map (,) (unfoldr (liftM2(>>)(guard.not.null)(return.splitAt 2))) [1..23]
13:54:03 <lambdabot>    The function `map' is applied to three arguments,
13:54:04 <lambdabot>   but its type `(a -...
13:54:29 <newsham> wait, that wont work
13:54:46 <glguy> Cale: I think people are attracted to my nearly whitespace free version of that function ;)
13:54:48 <Krunch> glguy: yes i meant "of"
13:54:56 <newsham> ?pl \[a,b] -> (a,b)
13:54:57 <lambdabot> (line 1, column 2):
13:54:57 <lambdabot> unexpected "["
13:54:57 <lambdabot> expecting pattern
13:55:15 <glguy> newsham: lambda-expressions can't be partial matching
13:55:22 <glguy> (or whatever the correct term is)
13:55:25 <mauke> glguy: why not?
13:55:40 <glguy> mauke: because I get errors when I try to do that?
13:55:50 <LoganCapaldo> ?pl \([a,b]) -> (a,b)
13:55:51 <lambdabot> (line 1, column 3):
13:55:51 <lambdabot> unexpected "["
13:55:51 <lambdabot> expecting pattern
13:55:51 <newsham> good reason
13:55:57 <LoganCapaldo> Funny
13:56:07 <mauke> > (\[a,b] -> (a,b)) "xy"
13:56:08 <lambdabot>  ('x','y')
13:56:25 <newsham> ?pl \(x:y:xs) -> (x,y)
13:56:26 <lambdabot> ap ((`ap` tail) . (. head) . (const .) . (,) . head) tail
13:56:36 <mauke> ?pl \x -> (head x, head (tail x))
13:56:37 <lambdabot> liftM2 (,) head (head . tail)
13:56:41 <glguy> today isn't my day, but I've had errors tryign that
13:56:43 <glguy> so who knows
13:56:44 <glguy> =/
13:57:51 <palomer_> hrmph, I wonder if there's a version of words that keeps the intervening garbage
13:58:22 <palomer_> (or, rather, groupBy)
13:58:27 <glguy> groupBy isSpace?
13:58:36 <LoganCapaldo> funny, is \[...] not working a recent change?
13:58:45 <LoganCapaldo> oh wait it does work
13:58:47 <mauke> I think it's a bug in @pl
13:58:57 <glguy> errr
13:59:15 <glguy> groupBy (\x y -> isSpace x == isSpace y)?
13:59:25 <LoganCapaldo> I only ask because I have code that looks like \[(a,b)] -> .. and  it works fine
13:59:33 <palomer_> glguy, but I'd want to keep the spaces
13:59:35 <palomer_> for example:
13:59:37 <glguy> > groupBy (\x y -> isSpace x == isSpace y) "a   bcd d"
13:59:38 <lambdabot>  ["a","   ","bcd"," ","d"]
13:59:41 <LoganCapaldo> Although I've recently realized it should probably fst . head
14:00:04 <palomer_> foo "haha \t   \t hoho \t  " would return ["haha","\t   \t ", "hoho"," \t  "]
14:00:46 <palomer_> > groupBy (\x y -> isAlpha x == isAlpha y) "a   bcd d"
14:00:48 <lambdabot>  ["a","   ","bcd"," ","d"]
14:00:51 <palomer_> nice
14:00:57 <palomer_> thx
14:01:07 <glguy> so I gave you what you wanted?
14:01:39 <palomer_> yup
14:01:41 <glguy> today's score glguy: 1
14:01:47 <glguy> woot
14:01:48 <palomer_> glguy++
14:02:11 * glguy isn't counting negative points
14:02:35 <palomer_> call this function foo
14:02:40 <palomer_> concat foo x == x?
14:02:47 <palomer_> err, concat $ foo x == x ?
14:03:29 <glguy> (concat $ foo x) == x ?
14:03:36 <palomer_> yeah
14:03:44 <glguy> map return --?
14:03:59 <glguy> map (:[]) --?
14:04:11 <glguy> AH
14:04:17 <glguy> you mean that crap with the groupBy...
14:04:20 <palomer_> concat . (groupBy (\x y -> isAlpha x == isAlpha y)) == id 
14:04:23 <palomer_> ?
14:04:25 <glguy> and you need a name for it
14:04:43 <glguy> I don't see why that wouldn't be teh case
14:04:49 <glguy> but I bet that means that it isn't
14:05:08 <palomer_> <:O
14:06:32 <glguy> palomer_: ask quick-check or small-check?
14:07:00 <mauke> is there a better way to write this: http://rafb.net/paste/results/84atcG52.html ?
14:07:02 <palomer_> I tested it on a small book
14:07:04 <palomer_> it seems to be the case
14:07:07 * palomer_ crosses his fingers
14:08:49 <wy> Why is it called "ad hoc polymorphism"?
14:08:54 * palomer_ wishes there was a lookupBy function
14:09:07 <Cale> wy: Why is what called that?
14:09:10 <sjanssen> mauke: if not (elem family [afUnix, afInet, afInet6]) then stuff else undefined
14:09:31 <sjanssen> mauke: you can also use guard
14:09:41 <wy> Cale: Why is the polymorphism in Haskell called that?
14:09:44 <palomer_> there must be a lookupBy function somewhere!
14:09:45 <Cale> It's not
14:09:47 <mauke> sjanssen: no, I need to put actual code in the cases :-)
14:10:00 <Cale> (If it is, then that's almost certainly wrong)
14:10:01 <palomer_> haskell polymorphism is hardcore polymorphism
14:10:04 <tibbe> what's an idiomatic way of naming safe file, db functions, etc that always closes their resource correctly? withFile? withConnection?
14:10:06 <vincenz> @check \x ->  concat . (groupBy (\x y -> isAlpha x == isAlpha y)) $ x == x
14:10:07 <lambdabot>  Couldn't match `[Char]' against `Bool'
14:10:10 <mauke> 'undefined' is just a place holder
14:10:12 <sjanssen> mauke: I'd stay the course then
14:10:15 <vincenz> @check \x -> (concat . (groupBy (\x y -> isAlpha x == isAlpha y)) $ x) == x
14:10:16 <lambdabot>  OK, passed 500 tests.
14:10:22 <palomer_> woot
14:10:28 <wy> Cale: The tutorial says so.
14:10:37 <Cale> That's odd
14:10:51 <palomer_> yay for vincenz!
14:11:34 <Cale> I suppose typeclass-bounded polymorphism could technically be used in order to set up something similar to ad-hoc polymorphism, but that's not really how it's used.
14:12:16 <Cale> Ad-hoc polymorphism is when you define individual values polymorphically by redefining them at specific types, and then the particular definitions apply in exactly those type contexts.
14:12:35 <Heffalump> that's precisely what type classes do, surely
14:12:42 <Cale> Not quite.
14:13:27 <Cale> When you apply an value which is ad-hoc polymorphic, you apply it at exactly one type.
14:13:33 <eviltwin_b> type classes are structured, not ad-hoc
14:14:45 <Cale> Typeclass polymorphism is a way of restricting the parameters in a parametrically polymorphic system so as to range over particular (open) sets of types.
14:15:10 <Cale> So a better term would be bounded parametric polymorphisc.
14:15:15 <Cale> polymorphism*
14:16:46 <newsham> http://en.wikipedia.org/wiki/Polymorphism_(computer_science)
14:16:49 <lambdabot> http://tinyurl.com/yl9jyl
14:16:50 <wy> I think it's different from the parametric polymorphism in sml
14:17:08 <Cale> The parametric polymorphism in sml is unbounded
14:17:38 <wy> By unbounded, you mean without inheritance?
14:17:52 <Cale> If you have a type variable 'a, it can stand for any type whatsoever.
14:18:05 <Cale> This is the same in Haskell when you don't use typeclasses.
14:18:22 <wy> So that 'a is unbounded. I see..
14:18:24 <Cale> However, in Haskell, I can say  sort :: Ord a => [a] -> [a]
14:18:36 <Cale> which means that a ranges over ordered types
14:18:50 <wy> Maybe we should call it unquantified?
14:19:09 <Cale> No, they're all still quantified
14:19:15 <Cale> (implicitly, by forall)
14:19:16 <wy> Or quantified by just the univeral quantifier
14:19:26 <wy> Ah. Yes. That's the point
14:19:40 <Cale> With typeclasses, we have a way to restrict the forall quantifier a bit
14:19:53 <Cale> sort :: forall a. Ord a => [a] -> [a]
14:19:56 <Cale> @type sort
14:19:58 <lambdabot> forall a. (Ord a) => [a] -> [a]
14:20:04 <wy> I see. That's exactly what I'm looking for
14:20:58 <Cale> So it's not quite ad-hoc -- you have well-defined interfaces which are implemented at various types, and which give a way to restrict the type variables occurring in type signatures.
14:21:26 <Cale> Which tutorial?
14:21:53 <wy> http://www.haskell.org/tutorial/classes.html
14:21:55 <lambdabot> Title: A Gentle Introduction to Haskell: Classes
14:22:02 <Cale> I've heard a few people refer to typeclass polymorphism as ad-hoc, but I think it's a bit of an insult :)
14:22:44 <wy> I didn't recognize ad hoc as a bad word. It seems there are some area called "ad hoc networks"
14:22:55 <Cale> Certainly, you can construct classes with only a single method in them with an arbitrary type, and then create instances at each of the types where you want that value to be available, but that's not how anyone uses it.
14:23:26 <Cale> (and it would generally be quite inconvenient to use it that way)
14:23:48 <mauke> @karma+ static typing
14:23:49 <lambdabot> static's karma raised to 1.
14:23:51 <mauke> argh
14:23:59 <mauke> @karma- static
14:24:00 <lambdabot> static's karma lowered to 0.
14:24:36 <Cale> and even then, you get a little more expressiveness than ad-hoc polymorphism, because you can refer to that class in the type signatures of functions/values which use it.
14:25:03 <Cale> (and thus, they get to be polymorphic as well)
14:25:38 <piggybox> What's the preferred database interface for Haskell? HaskellDB?
14:25:55 <wy> If I define a type class: "class MyEq a where (===) :: a -> a -> Bool". And then define operator "===" as "instance MyEq Color where x === y  =  x `colorEq` y"
14:26:12 <wy> Does that mean the type is derived like this...?
14:26:28 <wy> T |- a::Color  T |- Color instanceof MyEq
14:26:28 <wy> -------------------------------
14:26:28 <wy> T |- (a===a)::Bool
14:28:01 <Heffalump> doesn't parametric polymorphism mean that values of all types get treated the same?
14:28:20 <monochrom> roughly speaking
14:28:51 <Heffalump> so I don't see how typeclass polymorphism can count
14:30:09 <monochrom> typeclass polymorphism is distinct from parametric polymorphism.
14:31:12 <wy> monochrom: yes. I can see that. sml uses parametric polymorphism. So I can't write a function that can print any value.
14:31:40 <pzpz> ^ doesn't do fast exponentiation, does it?
14:32:18 <monochrom> You can always write fun print_any_value _ = println "<someone is trying to print any value here>"
14:33:06 <wy> monochrom: But I have to write a function to convert my datatype to strings
14:33:09 <sjanssen> pzpz: yes, it does
14:33:24 <newsham> wy: show?
14:34:06 <monochrom> > 1^398293834
14:34:08 <lambdabot>  1
14:34:11 <monochrom> That's fast.
14:34:18 <opqdonut> >0^0
14:34:26 <opqdonut> > 0^0
14:34:27 <lambdabot>  1
14:34:48 <opqdonut> > (0^^0,0**0)
14:34:48 <wy> newsham: sorry in thtat sentence we are talking about sml
14:34:49 <lambdabot>  (1.0,1.0)
14:34:55 <opqdonut> yay :)
14:35:53 <monochrom> Write a function to convert specifically your datatype to strings.  Don't expect it to be generalisable.
14:36:00 <opqdonut> > fix (0^)
14:36:02 <lambdabot>  Exception: <<loop>>
14:36:05 <opqdonut> :)
14:37:17 <augustss> > 1^(2^1000000)
14:37:21 <lambdabot> Terminated
14:37:52 <wy> monochrom: But I think the system knows how to print that. Many datatypes are so trivial that writing them is tedious job. That's why I think I need another kind of polymorphism to do that for me
14:37:58 <augustss> > 1^(2^100000)
14:38:02 <lambdabot> Terminated
14:38:20 <augustss> > 1^(2^10000)
14:38:22 <lambdabot>  1
14:38:27 <monochrom> Haskell has "deriving Show".
14:38:40 <monochrom> I consider it a hack, but what the heck.
14:38:49 <newsham> this is #haskell.
14:38:51 <wy> monochrom: yep. That's better for me.
14:39:05 <sjanssen> what is wrong with deriving?
14:39:16 <monochrom> A general solution is some kind of generic or meta programming.  But what the heck, for now, "deriving Show" is good enough for me.
14:39:18 <augustss> it's a hack :)
14:40:10 <augustss> what's wrong with deriving is thatit only works for a small set of classes
14:40:10 <wy> sjanssen: nothing wrong. I was looking for something like "deriving Show" in sml can failed to find it. That's why I'm trying haskell
14:40:45 <monochrom> A problem, hypothetical perhaps, is: suppose I don't like the present algorithm of "deriving Show", I want to change that algorithm.
14:41:27 <newsham> you can "instance Show", you dont need to "deriving"
14:42:11 <sjanssen> I'm not convinced of the "different algorithm" argument, but yes, it'd be nice if any class could be derived
14:42:40 <mattam> sjanssen: it would be magic too
14:42:43 <sjanssen> can TH hook in to deriving?
14:42:51 <tibbe> why does emacs indent the line after a do differently each time, I can't figure out why
14:43:05 <newsham> i want deriving Binary
14:43:18 <monochrom> hit <tab> several times.
14:43:20 <wy> How can I derive my own Show for a type?
14:43:34 <eviltwin_b> instance Show MyType where ...
14:43:45 <eviltwin_b> instead of ...deriving Show
14:43:54 <monochrom> data Woah = Funny Int | More Woah deriving Show
14:43:58 <newsham> data MyType = A Int | B;  instance Show Mytype where show (A x) = show x; show B = "bee"
14:45:35 <wy> I see. So "show" is a method of the "Show" class?
14:45:41 <newsham> yessir
14:46:02 <newsham> ?type show
14:46:04 <lambdabot> forall a. (Show a) => a -> String
14:46:11 <aFlag> hello, would anyone recommend me a good hopengl tutorial? (I don't know C opengl)
14:46:25 <wy> How can I know what method a class have?
14:46:35 <augustss> but showsPrec is the slightly more general method in Show
14:46:40 <sjanssen> wy: reading the documentation? ;)
14:46:43 <monochrom> RTFM.  Or ask :info Show
14:46:48 <sjanssen> @docs
14:46:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
14:46:51 <opqdonut> wy: hoogle is a good starting point
14:47:07 <newsham> ooh, :info!  I didnt know that.
14:47:11 <newsham> i've been wanting that often
14:47:17 <monochrom> Kids these days.
14:47:20 <opqdonut> :DDD
14:47:25 <opqdonut> too true, too true
14:47:38 <eviltwin_b> heh
14:47:38 <i-luv-my-kbd> Where does ghc look for files when you import them? 
14:47:44 <opqdonut> some people seem to hold irc as a replacement for common sense, experimenting, and docs
14:48:18 <wy> opqdonut: who's hoogle?
14:48:27 <kpreid> @google hoogle
14:48:27 <opqdonut> wy: google it :)
14:48:29 <lambdabot> http://haskell.org/hoogle/
14:48:29 <lambdabot> Title: Hoogle
14:48:37 <newsham> ?hoogle a -> [a]
14:48:39 <lambdabot> Prelude.repeat :: a -> [a]
14:48:39 <lambdabot> List.intersperse :: a -> [a] -> [a]
14:48:39 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
14:48:43 <opqdonut> wy: it's the haskell api search engine
14:48:49 <monochrom> OTOH, a thousand years ago the majority of the people learned all things through words of mouth and hearsay too.
14:49:06 <monochrom> I see that civilization has not advanced in essence.
14:49:12 <aFlag> what's otoh?
14:49:16 <newsham> mono: baby steps
14:49:20 <opqdonut> aFlag: On The Other Hand
14:49:23 <LoganCapaldo> @hoogle OTOH
14:49:23 <lambdabot> No matches found
14:49:27 <LoganCapaldo> darn
14:51:04 <augustss> @hoogle No matches found
14:51:05 <lambdabot> Did you mean: No Matches Found
14:51:22 <opqdonut> :D
14:51:34 <augustss> @no I didn't
14:51:34 <lambdabot> Maybe you meant: . bf ft id pl undo v wn yow
14:51:41 <wy> :info is good! It will be even better if I can go to the definition from there
14:52:06 <aFlag> :-/
14:52:10 <wy> It seems haskell-mode doesn't recognize file names and line numbers?
14:52:11 <monochrom> It will be better if you can just get a Haskell chip implant.
14:52:15 <aFlag> seems like hopengl is not very popular
14:52:38 <opqdonut> yeah ocaml guys are stealing all the opengl leetness
14:53:08 <wy> monochrom: I mean it. It can be done
14:53:38 <monochrom> Actually I don't know what it means.
14:53:54 <monochrom> Now I know what it means.
14:54:14 <aFlag> opqdonut: how come?
14:54:15 <monochrom> Sheesh English is such a language optimized for clarity.
14:55:28 <tibbe> is it possible to import some functions from a module as qualified and some as unqualified?
14:55:38 <augustss> @wn
14:55:57 <monochrom> Use two import lines.
14:56:00 <augustss> tibbe: yes.  Use two import clauses
14:56:17 <dons> moin
14:56:23 <monochrom> vous
14:56:47 <tibbe> augustss: order matters?
14:56:52 <augustss> no
14:57:39 <augustss> @wn blah
14:57:40 <lambdabot> *** "blah" wn "WordNet (r) 2.0"
14:57:41 <lambdabot> blah
14:57:41 <lambdabot>    n : pompous or pretentious talk or writing [syn: {bombast}, {fustian},
14:57:41 <lambdabot>      {rant}, {claptrap}]
14:58:28 <augustss> heh
14:59:08 <augustss> lambdabot knows more than you'd think
15:00:33 <aFlag> pompous?
15:00:36 <tibbe> i never find a good place to put my helper functions, for example, i've just written a higher/safer layer on top of HSQL, where should i put that? i always end up with some Utils.hs
15:00:55 <aFlag> blah sure have a different meaning in portuguese
15:02:12 <newsham> babooz
15:02:49 <augustss> @wn claptrap
15:02:51 <lambdabot> *** "claptrap" wn "WordNet (r) 2.0"
15:02:51 <lambdabot> claptrap
15:02:51 <lambdabot>    n : pompous or pretentious talk or writing [syn: {bombast}, {fustian},
15:02:51 <lambdabot>      {rant}, {blah}]
15:02:59 <newsham> @wn babooz
15:03:01 <lambdabot> No match for "babooz".
15:03:10 <augustss> @wn fustian
15:03:12 <lambdabot> *** "fustian" wn "WordNet (r) 2.0"
15:03:12 <lambdabot> fustian
15:03:12 <lambdabot>    n 1: pompous or pretentious talk or writing [syn: {bombast}, {rant},
15:03:12 <lambdabot>       {claptrap}, {blah}]
15:03:12 <lambdabot>    2: a strong cotton and linen fabric with a slight nap
15:03:22 <tibbe> ?hoogle mapM
15:03:23 <aFlag> @wn yatta
15:03:23 <lambdabot> Prelude.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
15:03:23 <lambdabot> Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
15:03:23 <lambdabot> Prelude.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
15:03:24 <lambdabot> No match for "yatta".
15:03:28 <augustss> @wn nap
15:03:29 <lambdabot> *** "nap" wn "WordNet (r) 2.0"
15:03:30 <lambdabot> nap
15:03:30 <lambdabot>    n 1: a period of time spent sleeping; "he felt better after a
15:03:30 <lambdabot>      little sleep"; "there wasn't time for a nap" [syn: {sleep}]
15:03:31 <lambdabot>    2: a soft or fuzzy surface texture
15:03:33 <lambdabot> [10 @more lines]
15:03:53 <aFlag> @wn hopengl
15:03:55 <lambdabot> No match for "hopengl".
15:04:07 <aFlag> @wn shrimp
15:04:10 <lambdabot> *** "shrimp" wn "WordNet (r) 2.0"
15:04:10 <lambdabot> shrimp
15:04:10 <lambdabot>    n 1: disparaging terms for small people [syn: {runt}, {peewee}, {half-pint}]
15:04:10 <lambdabot>    2: any of various edible decapod crustaceans [syn: {prawn}]
15:04:10 <lambdabot>    3: small slender-bodied chiefly marine decapod crustaceans with
15:04:11 <lambdabot> [3 @more lines]
15:04:33 <augustss> decapod, eh?
15:04:44 <aFlag> hum
15:04:48 <aFlag> @wn decapod
15:04:50 <lambdabot> *** "decapod" wn "WordNet (r) 2.0"
15:04:50 <lambdabot> decapod
15:04:50 <lambdabot>    n 1: crustaceans characteristically having five pairs of
15:04:50 <lambdabot>      locomotor appendages each joined to a segment of the
15:04:50 <lambdabot>      thorax [syn: {decapod crustacean}]
15:04:52 <lambdabot>    2: cephalopods having eight short tentacles plus two long ones
15:05:09 <aFlag> oh, i see
15:05:35 <aFlag> I hadn't read about that since high school hehe
15:05:39 <agocorona> a new ipod?
15:07:44 <aFlag> I've learned a bunch of useless stuff in high school :(
15:08:21 <monochrom> There exists such a thing as /msg lambdabot
15:08:41 <Captain_Fourier> its ok aFlag 
15:11:08 <dons> ok, so the scienceblogs guy is off to a good start on his haskell tutorial series: http://scienceblogs.com/goodmath/2006/11/why_haskell.php
15:11:10 <lambdabot> http://tinyurl.com/y8dzbl
15:11:37 <aFlag> some guy around here was doing the nehe tutorials in haskell. I lost the page he kept the code though :(
15:11:38 <dons> have we seen Mark in here yet?
15:13:03 <dons> http://programming.reddit.com/info/sijx/comments
15:13:06 <lambdabot> Title: Why Haskell? (reddit.com), http://tinyurl.com/ynauv9
15:13:07 <dons> is the reddit link
15:14:34 <monochrom> I should go sign up on reddit.
15:14:45 <monochrom> Then I can get to post one item.
15:14:49 <monochrom> "Why Reddit?"
15:15:22 <Captain_Fourier> i prefer lambda the ultimate
15:15:24 <kpreid> is there an existing typeclass X (c a) with operations a -> c a and c a -> c a -> c a?
15:15:43 <kpreid> i.e. MonadPlus without bind / Monoid with return
15:15:50 <dons> reddit is more dynamic than LtU, and reaches a different audience
15:15:59 <dons> they both have merit.
15:16:12 <palomer_> hmm
15:16:20 <palomer_> words seems to consider \160 a seperable character
15:16:30 <Botje> \160 is a VTAB
15:16:33 <Botje> which is whitespace.
15:16:37 <palomer_> what's VTAB?
15:16:43 <palomer_> does it have an escape sequence?
15:16:59 <kpreid> > "\v"
15:17:01 <lambdabot>  "\v"
15:17:05 <kpreid> > "\160"
15:17:06 <lambdabot>  "\160"
15:17:07 <palomer_> oh
15:17:12 <palomer_> it's also a korean character
15:17:18 * palomer_ kicks korea
15:17:24 <Botje> kick your encoding, rather.
15:17:24 <kpreid> you have an encoding problem
15:17:30 <kpreid> no
15:17:31 <palomer_> is there a version of words that only separates on "\n \t" ?
15:17:32 <kpreid> no, it isn't
15:17:57 <aFlag> what's the option I have to pass to ghc to see which packages I have installed?
15:18:00 <newsham> palo: see the src for words.  its a short simple func.  you can reuse the code almost veratim for derivatives
15:18:03 <palomer_>      young  
15:18:07 <newsham> ghc-pkg -list ?
15:18:10 <Botje> every paper on monads I read mentions that both List and Maybe are monads, are there any examples of thses uses?
15:18:11 <palomer_> haskell says that's:
15:18:27 <palomer_> "     young \236\160\138\236\157\128 \n"
15:18:39 <aFlag> newsham: that's it, thanks
15:18:45 <dons> > fail "foo" :: [String] -- one example
15:18:46 <lambdabot>  []
15:18:54 <newsham> > [1,2,3,4] >>= \x -> [+x, -x]
15:18:55 <lambdabot>  Parse error
15:19:04 <newsham> > [1,2,3,4] >>= (\x -> [+x, -x])
15:19:05 <lambdabot>  Parse error
15:19:19 <newsham> > [1,2,3,4] >>= (\x -> [+x, 0-x])
15:19:20 <lambdabot>  Parse error
15:19:22 <pkhuong> >  [1,2,3,4] >>= (\x -> [x, -x])
15:19:23 <lambdabot>  [1,-1,2,-2,3,-3,4,-4]
15:19:24 <dons> teXesc :: String -> String
15:19:25 <dons> teXesc xs = (\c -> if c == '#' then "\\#" else [c]) =<< xs
15:19:37 <dons> was an example, instead of :  foldr (\x xs -> if x == '#' then '\\':'#':xs else xs) [] "#stuff$#"
15:19:45 <newsham> oh, heh
15:21:34 <newsham> > [1,2,3] >>= (\x -> [4,5,6] >>= (\y -> return (x+y)))
15:21:36 <lambdabot>  [5,6,7,6,7,8,7,8,9]
15:22:00 <Botje> O_O
15:22:08 <Botje> that's cool
15:22:30 <dcoutts> lispy, oh, so can haxml now parse from a lazy bytestring ? Or you've got patches to do it? I'd like to see it go in as I've found haxml far too slow for my linking (loading several mb of .xml files).
15:22:38 <newsham> > do { x <- [1,2,3]; y <- [4,5,6]; return (x+y) }
15:22:38 <dcoutts> phas, pong
15:22:40 <lambdabot>  [5,6,7,6,7,8,7,8,9]
15:22:51 <phas> -dcoutts- HI!
15:22:57 <newsham> > [x+y | x <- [1,2,3], y <- [4,5,6]]
15:22:59 <lambdabot>  [5,6,7,6,7,8,7,8,9]
15:23:03 <phas> i've a problem and need an hint!
15:23:13 <phas> i've a struct with some 
15:23:15 <phas> char *foo
15:23:19 <phas> and some
15:23:23 <phas> char bar[]
15:23:25 <dcoutts> peekCString
15:23:35 <phas> yeah, works on firts
15:23:38 <phas> but not on seconds
15:23:39 <Botje> some day i'll finally finish my first 10 ACM problems and i'll be famous.
15:23:40 <dcoutts> peekCStringLen
15:23:48 <phas> char bar[N]
15:24:08 <phas> mmh let's
15:24:08 <phas> see
15:24:13 <dcoutts> @hoogle CStringLen
15:24:13 <lambdabot> Foreign.C.String.CStringLen :: type CStringLen
15:24:14 <lambdabot> Foreign.C.String.newCStringLen :: String -> IO CStringLen
15:24:14 <lambdabot> Foreign.C.String.peekCStringLen :: CStringLen -> IO String
15:24:17 <dcoutts> phas, check the docs for the Foreign.*
15:24:57 <phas> yes i lurked it
15:25:06 <palomer_> > isAlpha '\236'
15:25:08 <lambdabot>  True
15:25:19 <phas> but it's not a string with size in it
15:25:23 <phas> is a null terminated
15:25:25 <palomer_> ok, how is 236 alpha?
15:26:05 <dcoutts> phas, if it's null terminated then you can use *CString if you've got an explicit length then use *CStringLen
15:26:14 <kpreid> @read '\236'
15:26:15 <lambdabot> dummy module failed: IRCRaised Prelude.read: no parse
15:26:19 <kpreid> @read "\236"
15:26:19 <lambdabot>  
15:26:27 <palomer_> oh my
15:26:35 <kpreid> palomer_: it's an i-with-`
15:26:42 <phas> -dcoutts-: there are two null terminated string
15:26:47 <kpreid> in latin1/first-256-of-unicode
15:26:52 <phas> one declared as char *foo
15:26:59 <phas> and the oter char bar[N]
15:27:03 <phas> both null terminated
15:27:12 <dcoutts> phas, then use peekCString twice
15:27:20 <phas> doesn't work in the second case!
15:27:25 <phas> segmentation fault
15:27:36 <dcoutts> use & somewhere
15:28:15 <dcoutts> phas, check the generated .hs code to see if it's looking sane
15:28:26 <aFlag> doesn't hopengl come with ghc anymore?
15:28:52 <phas> seems so
15:29:02 <dcoutts> phas, oh, wait the second one is an array in the struct itself
15:29:04 <phas> also, he success in retrieving the pointer
15:29:12 <phas> yeah right
15:29:26 <phas> but's not the same if structure is malloc-ed?
15:30:28 <dcoutts> so you need to peekCString at the ptr + member offset
15:31:01 <phas> yeah of course
15:31:17 <phas> version<- ((#{peek ID3, version} csPtr)) >>= peekCString >>= return . Just
15:31:41 <dcoutts> right, so that's getting the thing, dereferencing it and using that as a CString
15:31:48 <aFlag> darn debian
15:31:51 <dcoutts> you want offsetof or something
15:32:13 <phas> i don't follow you
15:32:25 <dcoutts> peekCString (csPtr `plusPtr` #{ offsetof ID3, version })
15:32:45 <phas> what's the difference?
15:33:14 <dcoutts> in the first you're calculating (csPtr `plusPtr` #{ offsetof ID3, version }) and then reading a pointer out of that location
15:33:30 <dcoutts> which you then dereference (BANG) and try to get a string from
15:34:02 <dcoutts> in the second you calculate the start address of the string and read it out
15:34:18 <phas> oh
15:34:18 <phas> i see
15:34:20 <phas> thank you
15:34:50 <dcoutts> phas, I think there is some kind of struct member offset macro in hsc2hs, check the docs
15:35:13 <phas> ok
15:46:59 <phas> dcoutts: peekCString (#{ptr ID3, version } csPtr) >>= return . Just
15:47:02 <phas> worked!
15:47:23 <dcoutts> ah, ptr is the offset of macro.
15:47:39 <phas> :)
15:48:24 <phas> damned C and damned pointers :P
15:48:30 <newsham> mmm C
15:49:05 <mbishop> eww C
15:49:32 <phas> all those ... "unsafness"
15:49:50 <newsham> unsafePerformC { for(i = 0; i < 10; i++) {...} }
15:50:07 <phas> i mean, is so strange see a program compiled by GHC that crash :P
15:50:55 <newsham> newsham@discover$ ghc-6.6
15:50:55 <newsham> Segmentation fault
15:50:58 <newsham> :(
15:51:35 <phas> LOL
15:53:12 <SamB_XP> phas: hmm, shouldn't the buffer size be involved somewhere?
15:53:33 <newsham> if he's using CString, wont it just fetch till NUL termination?
15:53:55 <phas> i don't think so, because like newsham says, there il the \0 in the end of string
15:54:00 <phas> and CString look for it
15:56:04 <SyntaxNinja> w00t 
15:56:05 <lambdabot> SyntaxNinja: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:57:21 <phas> a little OT question
15:57:30 <phas> but aren't C char unsigned short int?
15:57:37 <SyntaxNinja> oh lambdabot, tell people to use email.
15:59:07 <SamB_XP> @tell people use email!
15:59:08 <lambdabot> Consider it noted.
15:59:15 <aFlag> what package is StateUtil module in? I've searched for haskell StateUtil on google and it gave me only 3 address
15:59:20 <aFlag> and no useful one
16:01:39 <sjanssen> aFlag: I've never heard of that module
16:01:51 <aFlag> hum
16:02:26 <wy> How can I express a datatype like the sml type "datatype term = Var of string | Num of int" in Haskell?
16:02:41 <sjanssen> data Term = Var String | Num Int
16:03:08 <LoganCapaldo> Hey look at that! extraneous keywords jsut disappear ;)
16:03:31 <monochrom> And when you want polymorphism, " a' blah " becomes "Blah a".
16:03:44 <monochrom> err " 'a blah" becomes "Blah a"
16:05:13 <monochrom> You can also translate "Op of (int,string)" to "Op (Int,String)" but it is more common in Haskell programs to use "Op Int String" i.e. currying.
16:06:20 <dons> phas: C char is a unsigned byte (not a short int). i.e. Word8 in Haskell
16:06:27 <dons> phas: you doing some bytestring hacking?
16:06:35 <LoganCapaldo> You can translate Op of int * string to Op Int String ;)
16:07:06 <dons> an lo! extraneous keywords just disappear :)
16:07:12 <LoganCapaldo> (I figured it was ok since you already corrected yourself on the a' )
16:07:43 <monochrom> C char is unsigned?!
16:08:10 <LoganCapaldo> I though char x; was compiler dependent for some reason
16:08:19 <monochrom> Yeah I forgot exact SML syntax.
16:08:28 <Binkley> yes, Virginia, C chars are unsigned
16:08:47 <Igloo> dons, phas: Or you might want Foreign.C.Types.CChar, depending on what you are doing
16:08:53 <newsham> C chars are signed.
16:08:59 <dons> yeah, even better.
16:09:11 <newsham> unsigned char x;  is an unsigned char-sized variable.
16:09:14 <dons> SyntaxNinja: any chance you'll make the hackathon?
16:09:14 <Igloo> Or Foreign.C.Types.CUChar for unsigned
16:09:26 <monochrom> C char is signed?!
16:09:32 <newsham> yes sir.
16:09:38 <Igloo> signedness of C's char isn't specified I believe
16:09:40 <SyntaxNinja> dons: where?
16:09:54 <newsham> igloo: i'm pretty sure it is.
16:10:01 <newsham> sizeof C char isnt specified.
16:10:02 <dons> SyntaxNinja: http://www.haskell.org/haskellwiki/Hac_2007
16:10:04 <lambdabot> Title: Hac 2007 - HaskellWiki
16:10:11 <dons> (Oxford, a few days before POPL/PADL)
16:10:11 <Igloo> I'm pretty sure it varies by arch
16:10:26 <monochrom> I have this hard cover K&R 2ed with Kernighan's autograph with me here, and it says char is implementation dependent.
16:10:27 <newsham> i'm pretty sure it doesnt.
16:10:31 <nick8325> newsham: no, i don't think c says whether char is signed or unsigned
16:10:40 <dons> SyntaxNinja: I want to make Hac07 the place we get hackage *done*
16:10:42 <nick8325> newsham: and sizeof(char) is 1 by definition, iirc
16:10:43 <newsham> mono: it says the size is impl dependant?
16:10:49 <newsham> nick: nope.
16:10:57 <monochrom> It says even the sign is dependent.
16:11:03 <newsham> mono: ahh, so i'm wrong.
16:11:13 <SamB_XP> sizeof(char) == 1
16:11:14 <Igloo> newsham: A public authoritative reference is probably imopssible to find, but e.g. http://www.arm.linux.org.uk/docs/faqs/signedchar.php says ' The C standards do say that "char" may either be a "signed char" or "unsigned char" and it is up to the compilers implementation or the platform which is followed.'
16:11:20 <nick8325> newsham: comp.lang.c says it is...
16:11:20 <lambdabot> Title: ARM Linux - Documentation - FAQs - Signed Char, http://tinyurl.com/v3ma6
16:11:27 <nick8325> newsham: sizeof(char), that is
16:11:39 <monochrom> But you can make gcc assumptions I guess.
16:12:11 <monochrom> But these days kids don't read hard cover books and I think they're missing out.
16:12:14 <SamB_XP> now, char may have all sorts of ranges...
16:12:45 <nick8325> newsham: http://c-faq.com/malloc/sizeofchar.html, http://c-faq.com/stdio/getcharc.html
16:14:04 <SyntaxNinja> dons: I so want hackage to get done!
16:14:04 <SamB_XP> monochrom: I'm pretty sure the softcover says the same thing...
16:14:29 <SyntaxNinja> dons: do you have a list of who is coming yet?
16:14:39 <SyntaxNinja> dons: do you have a prioritized list for what needs to happen to get hackage done?
16:15:09 <phas> dons: no i'm getting something for hmp3 :P
16:15:13 <Igloo> SyntaxNinja: Does/will cabal-setup cache compilation of Setup.hs? And can it be told to clean its cache?
16:15:24 <phas> dons i'm tryin to add id3 support
16:15:36 <monochrom> hehehe
16:15:45 <phas> the char question was for a weirdness i saw in the id3 lib
16:15:50 <phas> an "unsigned char"
16:18:23 <SyntaxNinja> dons: I don't think I'll be there physically, unless someone is sponsoring me (ha!) but maybe I can be online...
16:19:13 <SyntaxNinja> Igloo: what do you mean by cache?
16:19:36 <Igloo> SyntaxNinja: Does it compile it and leave Setup.o, Setup,hi and setup lying around?
16:20:09 <SyntaxNinja> dons: let me make sure I have this right.  you'd be starting at 2AM my time on Jan 10
16:21:09 <SyntaxNinja> Igloo: I think it uses runhaskell if it can. I'm not positive.
16:21:14 <Igloo> OK
16:21:30 <Igloo> I think dons was really asking if you could be tempted to visit the UK for a few days
16:21:39 <Igloo> But yes, 2am your time sounds right
16:21:47 <dons> SyntaxNinja: ok, we need a plan for hackage before the hackathon. dcoutts Igloo and I will be there, 7 others have registered so far. Lemmih and kosmikus are thinking about it, afaik
16:22:02 <dcoutts> @arr
16:22:02 <lambdabot> I'll keel haul ya fer that!
16:22:09 <dcoutts> hia SyntaxNinja :-)
16:22:19 <dons> before the hackathon, a list of tasks would be good. hackage stuff, and key libraries to port from other langs
16:22:19 <LoganCapaldo> @arr me mateys
16:22:20 <lambdabot> I'll keel haul ya fer that!
16:22:26 <dons> as well as bugs to fix, and releases to make
16:22:55 <aFlag> I got this piece of code from a HOpengl tutorial: http://rafb.net/paste/results/pXMPTM44.html
16:22:55 <aFlag> but ghc won't compile it, it says there's duplicate instance of HasSetter and HasGetter. Is there a ghc extension that will make it work? Or it's just wrong?
16:22:55 <dons> phas: ok. great! id3 support is highly welcome
16:22:56 <SyntaxNinja> hey duncan
16:23:18 <Igloo> dons: I thought it was 7 total?
16:23:24 <SyntaxNinja> dons, dcoutts: it would be great for Ross to be there if possible.  he is a great cabal hacker
16:23:44 <dons> yes, so far. oh, that was incorrect above (the "others")
16:23:50 <dons> SyntaxNinja: ah good. yes, I'll ask Ross now
16:24:10 <dcoutts> SyntaxNinja, yes, he came to the discussion in Oxford the other day. It was very helpful to have another point of view. We ended up adopting many of his suggestions. Igloo and I are still writing that up.
16:24:33 <SyntaxNinja> Igloo: I'd love to visit oxford for a few days, but I don't think I can swing the vacation or the travel $ at the moment. been away from work a lot.
16:24:49 <Igloo> *nod*
16:24:51 <dcoutts> SyntaxNinja, btw, and news on either Trac 0.10 or me getting write perms on /srv/trac/gtk2hs/db/trac.db
16:25:01 <dcoutts> (on darcs.h.o)
16:25:18 <dcoutts> any/any
16:25:22 <dcoutts> doh
16:25:31 * dcoutts can't type at all this evening
16:25:34 <dcoutts> and/any
16:25:52 <dons> so if you guys want to nut out a plan for how to finish hackage, to the point we can upload and download packages before the hackathon, that'd be cool.
16:25:54 <SyntaxNinja> dcoutts: yeah, I'm eager to hear about configurations
16:25:56 <dons> SyntaxNinja: did you see the new erlang CPAN?
16:26:17 <SyntaxNinja> dons: no. is it 1337?
16:26:21 <phas> dons: now i've some difficoult in understanding hmp3 code :( it's all fps!
16:26:27 <phas> but is very well commented :D
16:26:31 <dcoutts> SyntaxNinja, aye, we think we have something plausible. Though Igloo want's to use more {}'s in the syntax :-)
16:27:00 <SyntaxNinja> dcoutts: looking forward to seeing the writeup.  any preview available?
16:27:00 <dcoutts> SyntaxNinja, since it becomes a little tricky to see which configuration applies to what otherwise
16:27:20 <dcoutts> SyntaxNinja, I'm hoping Igloo will send us the next iteration soon
16:27:30 * dcoutts prods Igloo :-)
16:27:38 <SyntaxNinja> I'm so excited that you guys are taking initiative on this.  we need to get as many eyes on cabal as possible.
16:27:43 <SyntaxNinja> especially w/ this tricky configuration stuff.
16:27:58 <SyntaxNinja> if you came away w/ something that you all like, I'm happy
16:28:04 <dons> SyntaxNinja: http://cean.process-one.net/
16:28:07 <lambdabot> Title: Comprehensive Erlang Archive Network
16:28:15 <Igloo> dcoutts: Yeah, ran out of time this weekend, sorry. Hopefully I'll get to it early this week.
16:28:26 <SyntaxNinja> w0w
16:28:27 <dcoutts> Igloo, great
16:29:36 <SyntaxNinja> we must beat erlang
16:29:41 <dons> yes!
16:31:16 * SyntaxNinja didn't even know there _were_ 17 platforms ;)
16:32:26 <dons> heh. there's > 55 netbsd ports. we're lagging behind!
16:33:57 <SyntaxNinja> dons: any guess how long the sessions will go?  10AM - 10PM? :)
16:34:02 <SyntaxNinja> maybe I can SIP in
16:34:16 <dons> SyntaxNinja: yeah, something like that.
16:34:28 <Igloo> Do they list their 17 platforms anywhere?
16:35:13 <dons> 15 of them might be ericsson switches... ;)
16:35:17 <dcoutts> are 14 of them different linux distros? ;-)
16:36:04 <mbishop> 15 of them are probably Nortel-50, Nortel-100, etc.. heh
16:36:20 <Igloo> Ah, there's a dropdown on http://cean.process-one.net/download/
16:36:22 <lambdabot> Title: CEAN Downloads
16:36:32 <dons> ah here: http://cean.process-one.net/stats/
16:36:35 <lambdabot> Title: CEAN Usage Statistics
16:36:53 <Igloo> ROFL!
16:37:10 <Igloo> Up to 17 platforms, but 12 of those have no packages available
16:37:18 <dons> oops
16:37:23 <dcoutts> we support most of those platforms
16:37:26 <Igloo> Oh, no, that's downloads
16:37:49 <Igloo> OK, that's not quite so amusing, then  :-)
16:37:50 <dons> wow, more mac than linux/x86 users
16:38:49 <Igloo> The Linux arches are exactly the set Debian will be releasing with
16:39:03 <mbishop> goes to show you mac weenies like their erlang I guess :P
16:39:12 <dcoutts> Igloo, yes, I thought you covered all of those
16:39:21 <dcoutts> Igloo, do you actually have ghc on them all?
16:39:28 <Igloo> Yes, and m68k too
16:39:44 <dcoutts> I think the only one gentoo has that debian doesn't is ppc64
16:40:01 * mbishop plans on buying an hp jornada 720, wants ghc that works on intel strongarm
16:40:09 <dcoutts> we're lacking s390, arm and mips.
16:40:13 <Igloo> I think there is a Debian ppc64 project somewhere that has GHC, as they sent me a patch to add themselves to the arch list
16:40:26 <Igloo> And HURD, too
16:40:32 <dcoutts> heh
16:40:36 <dcoutts> yeah it works fine unregisterised
16:41:00 <mbishop> s390 has such a huuuuge user base
16:41:01 <dcoutts> and there's the fbsd kernel ports
16:41:02 * mbishop coughs
16:41:25 <aFlag> Syzygy-: hi, how did you solved the matrixExcursion problem?
16:41:31 <dcoutts> mbishop, yes, and both of them want to run ghc :-)
16:41:39 <mbishop> :P
16:42:18 <newsham> i wish ghc would run on linux/x86. :(
16:42:25 <mbishop> If my poor ultrasparc II wasn't so out of date with software, I might install ghc on it
16:42:47 * ptolomy wonders how many haskell brainf*** interpreter/compilers and ray tracers exist.
16:42:47 <mbishop> I think it still has a 2.6.7 kernel, and gentoo heh :/
16:43:07 <Igloo> newsham: Eh?
16:43:07 <aFlag> kernel 2.6.7 isn't so bad
16:43:11 <newsham> newsham@discover$ ghc-6.6
16:43:11 <newsham> Segmentation fault
16:43:33 <mbishop> aFlag: true, and I was told I was lucky for using a 2.6 kernel on a u2 without having major problems
16:43:36 <aFlag> debian sarge uses linux 2.6.8
16:43:39 <mbishop> so I never wanted to upgrade heh
16:43:41 <dons> ptolomy: i know of 10 or so raytracers, and at least one BF interpreter (the one in lambdabot)
16:43:54 <dons> ptolomy: check the haskell.org libraries and applications page, under 'graphics' for the ray tracer list
16:43:55 <wy> Is there something like "apply" in haskell?
16:43:57 <ptolomy> I've seen at least 3 BF interpreters.
16:43:58 <newsham> ghc-6.4 works fine.  built ghc-6.6 a fwe days ago and it crashes
16:44:06 <newsham> wy: like ($) ?
16:44:10 <newsham> ?type ($)
16:44:11 <dons> wy: white space (if you're asking what I suggest)
16:44:12 <lambdabot> forall b a. (a -> b) -> a -> b
16:44:15 <dons> > id 3
16:44:16 <lambdabot>  3
16:44:18 <dons> > id $ 3
16:44:19 <ptolomy> (not including mine.)
16:44:19 <lambdabot>  3
16:44:32 <dcoutts> SyntaxNinja, do you have root on darcs.haskell.org ? or is there someone else I should email?
16:44:32 <wy> I mean apply a function to a list, maybe...
16:44:33 <dons> > let apply f x = f x in id `apply` 3
16:44:34 <lambdabot>  3
16:44:45 <dons> > map ord "haskell"
16:44:47 <lambdabot>  [104,97,115,107,101,108,108]
16:45:08 <LoganCapaldo> wy: Do you want Lisp style apply?
16:45:21 <LoganCapaldo> (apply #'+ '(2 3)) ?
16:45:25 <kpreid> wy: there can be no general apply in that way
16:45:44 <kpreid> well, Printf-style hacks, perhaps
16:45:47 <LoganCapaldo> cuz then uncurry might work
16:45:48 <dcoutts> SyntaxNinja, I don't want to pester but at the moment I'm trying to prepare a Gtk2Hs release and our bug tracker is currently stuffed and I had been hoping to use it to keep track of things that need to be fixed before the release.
16:45:52 <newsham> > ($) (+) 2 3
16:45:54 <lambdabot>  5
16:46:08 <dons> > id (+) 2 3
16:46:09 <lambdabot>  5
16:46:11 <aFlag> hey dons you were around when Syzygy- asked about the matrixExcursion funcion, do you remember where it is defined?
16:46:27 <dons> oh, a while ago. hmm. in SoE was it?
16:46:27 <wy> LoganCapaldo: something like that maybe. But I see, list is not the basic type of haskell...
16:46:38 <dons> Syzygy-: you remember? 
16:47:53 <wy> LoganCapaldo: or maybe we can define something that can extract the elements from a list and call the function on them?
16:48:08 <LoganCapaldo> wy: that's what map is
16:48:14 <aFlag> it was in opengl I think
16:48:24 <LoganCapaldo> > map (\x -> x + 1) [1,2,3]
16:48:25 <lambdabot>  [2,3,4]
16:48:28 <wy> LoganCapaldo: I mean exactly lisp 
16:48:31 <LoganCapaldo> Oh
16:48:33 <wy> lisp's apply
16:48:37 <LoganCapaldo> I don't think so
16:48:49 <LoganCapaldo> > uncurry (+) (1,2)
16:48:51 <lambdabot>  3
16:48:53 <dylan> hmm, how does one handle lazy strings when resources need to be freed? e.g. closing a handle or waiting on a process.
16:49:00 <wy> But that's tuple
16:49:00 <LoganCapaldo> Is as close as you are going to get
16:49:02 <dons> aFlag: hmm, i don't remember where it was. i think the issue was that it was either only in the older, or the newer opengl
16:49:07 <dons> and he had the wrong version
16:49:08 <newsham> > let binop f (x:y:[]) = f x y in binop (+) [1,2]
16:49:10 <lambdabot>  3
16:49:26 <dons> dylan: attach a finaliser?
16:49:33 <aFlag> seems like it's called preservingMatrix nowdays
16:49:37 <dons> that is run when the GC notices there are no references anymore
16:49:51 <dylan> dons: I can do that to a string, eh?
16:49:58 <dons> dylan: i.e. this is how you can mmap transparenty. attach 'unmap' as a finaliser
16:50:07 * dylan is rewriting wmiirc in haskell.
16:50:08 <dons> dylan: why would you need to do it for a string?
16:50:32 <dons> if you're pulling from a Handle, the handle will be closed once you've read the string
16:50:35 <dylan> dons: MissingH.Cmd's pipeFrom
16:50:49 <dylan> I need to wait on the process when I'm done reading from it.
16:51:10 <dons> ok. cool. try forcing the string with a seq/length call
16:51:13 <dons> and then waiting on the process
16:51:22 <dylan> seq, of course!
16:51:33 <dons> length is better though (i.e. a deep seq)
16:52:00 <dylan> so, let foo = length s?
16:52:13 <dons> gimme a sec ... finding you the canonical case:
16:52:20 <dons> http://www.cse.unsw.edu.au/~dons/code/lambdabot/Lib/Process.hs
16:52:22 <lambdabot> http://tinyurl.com/y2lucu
16:52:28 <dons> evaluate (length output)
16:52:29 <dons> basically
16:52:35 <dons> then waitForProcess pid
16:53:01 <dylan> of course, the Right Thing right now would be using some 9p2000 library rather than callign wmiir, but anyway
16:53:17 <dons> mm :)
16:53:32 <dons> oh, i have a wmii script in haskell. let me find it...
16:54:30 <dons> http://www.cse.unsw.edu.au/~dons/tmp/key-handler.hs
16:54:30 <dylan> getting a 19inch wide screen made using ion3 impossible, as it doesn't keep my urxvts aligned in a grid
16:54:31 <lambdabot> http://tinyurl.com/yad24a
16:54:59 <dons> that's the wmiirc I wrote a while back for wmii-4 iirc
16:55:04 <dons> not sure what state its in, but it worked at the time
16:56:58 <dons> ?remember slava Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich internet application-driven environment. Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
16:57:32 <dylan> ... does that sentence actually carry any meaning?
16:57:46 <SyntaxNinja> dcoutts: I have root.
16:58:01 <SyntaxNinja> dcoutts: hang on, lemmy look at darcs.h.o
16:58:07 * cjeris wants ghc for wii.  "Build and deploy an army of functional dependencies and multi-parameter type classes to defend Hyrule from the menacing MUTATRON and his legion of Java programmers!"
16:58:12 <dons> the inclusion of Yoneda's lemma (http://sigfpe.blogspot.com/2006/11/yoneda-lemma.html) is funny :)
16:58:14 <lambdabot> Title: A Neighborhood of Infinity: Reverse Engineering Machines with the Yoneda Lemma, http://tinyurl.com/umko8
16:58:41 <dcoutts> SyntaxNinja, great, could I trouble you to chown duncan /srv/trac/gtk2hs/db/trac.db
16:58:56 <dons> lovely, cjeris :)
16:59:22 <Blackfoot> how is one supposed to extract a ReadS value?
16:59:34 <Blackfoot> like from readOct? (i'm pretty new to haskell)
16:59:41 <Smokey`> you're telling me, the 2 and a bit days trying to figure out how to force evaluation of a list, i could've just used length?
16:59:45 <dons> ?type readOct
16:59:46 <lambdabot> forall a. (Num a) => ReadS a
17:00:03 <dons> ?type  readOct "07" 
17:00:04 <lambdabot> forall a. (Num a) => [(a, String)]
17:00:11 <dcoutts> SyntaxNinja, or indeed the whole /srv/trac/gtk2hs -R if you think appropriate, but the only bit I really need is write access to that db so I can delete the spam.
17:00:13 <dons> > readOct "07" 
17:00:15 <lambdabot>  [(7,"")]
17:00:27 <dons> > fst . head $ readOct "07" 
17:00:28 <Blackfoot> dons: right, so if I just wanted the integer 7
17:00:29 <lambdabot>  7
17:00:49 <dons> > readOct "07 08 and some other stuff" 
17:00:50 <lambdabot>  [(7," 08 and some other stuff")]
17:00:53 <Blackfoot> is that the "right" way to do it?  I thouhgt there might be a "read" string
17:00:54 <SyntaxNinja> dcoutts: your wish is my command.
17:01:07 <dcoutts> SyntaxNinja, yay, thanks.
17:01:07 <dons> > read "8" :: Int
17:01:08 <lambdabot>  8
17:01:17 <dons> > read "0xff" :: Int
17:01:19 <lambdabot>  255
17:01:28 <dons> > read "08" :: Int
17:01:30 <lambdabot>  8
17:01:33 <palomer_> dons, could you unban my nick?
17:01:37 <Blackfoot> > read "034"
17:01:38 <lambdabot>  Add a type signature
17:01:44 <dons> palomer_: i thought i did.
17:01:53 <Blackfoot> > read "034" :: Int
17:01:54 <lambdabot>  34
17:02:00 <dons> ah chanserv.
17:02:19 <dons> Blackfoot: using readOct with fst . head would be ok
17:02:29 <Blackfoot> ok, cool, thanks dons
17:03:00 <LoganCapaldo> @type fst.head
17:03:01 <lambdabot> forall a b. [(a, b)] -> a
17:03:33 <LoganCapaldo> @type (\[(x,_)] -> x)
17:03:35 <lambdabot> forall a b. [(a, b)] -> a
17:04:13 <SyntaxNinja> @seen shapr
17:04:14 <lambdabot> shapr is in #ScannedInAvian and #haskell. I last heard shapr speak 7h 59m 13s ago.
17:04:24 <jcreigh> @type (\(x,_):_ -> x)
17:04:26 <lambdabot> parse error on input `:'
17:04:29 <SamB_XP> @pl (\[(x,_)] -> x)
17:04:30 <lambdabot> (line 1, column 3):
17:04:31 <lambdabot> unexpected "["
17:04:31 <lambdabot> expecting pattern
17:04:44 <jcreigh> @type (\((x,_):_) -> x)
17:04:45 <LoganCapaldo> There goes that pl bug again :)
17:04:46 <lambdabot> forall a b. [(a, b)] -> a
17:04:50 --- mode: ChanServ set +o dons
17:04:51 <SamB_XP> @type (\[(x,_)] -> x)
17:04:52 <lambdabot> forall a b. [(a, b)] -> a
17:04:53 --- mode: dons set -b palomer!*@*
17:04:57 --- mode: ChanServ set -o dons
17:05:19 <SamB_XP> @. pl . djinn type (\[(x,_)] -> x) 
17:05:21 <lambdabot> (line 1, column 1):
17:05:21 <lambdabot> unexpected "-"
17:05:21 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
17:05:25 <SamB_XP> @. djinn type (\[(x,_)] -> x) 
17:05:27 <lambdabot> -- f cannot be realized.
17:05:40 <SamB_XP> oh, right.
17:05:43 <SamB_XP> not complete, is it?
17:05:59 <SamB_XP> @pl (\((x,_):[]) -> x)
17:06:00 <lambdabot> (line 1, column 10):
17:06:01 <lambdabot> unexpected "["
17:06:01 <lambdabot> expecting natural, identifier, "_" or "("
17:06:07 <SamB_XP> @pl (\((x,_):_) -> x)
17:06:08 <lambdabot> fst . head
17:06:18 <LoganCapaldo> Wow
17:06:30 <LoganCapaldo> that's a smart lambdabot
17:06:32 <dons> did a pretty good job there
17:07:13 <dons> hey greentea 
17:07:13 <greentea> Hi all.
17:07:18 <greentea> Hey dons.
17:07:22 <dons> how's code?
17:07:43 <greentea> Heh, insufficient at the moment. Haven't been able to code much of late. :-(
17:08:02 <greentea> How are you?
17:08:19 <dons> good! :)
17:09:54 <greentea> :-)
17:13:00 <dons> oh, we have an emacs cabal mode now: http://mapcar.org/haskell/cabal-mode/
17:13:01 <lambdabot> Title: Cabal-mode for Emacs
17:13:02 <dons> rockin!
17:13:47 <Korollary> dons: I don't use vi. What does one need to get highlighting etc. to work for vi?
17:14:04 <dons> in vim or vi?
17:14:09 <dons> (makes a difference...)
17:14:12 <Korollary> hm, vim I guess. 
17:14:17 <dons> :syntax on
17:14:29 <Korollary> it comes with it?
17:14:30 <dons> :set nocompatible 
17:14:32 <dons> also helps
17:14:33 <dons> Korollary: yep
17:14:36 <Korollary> oh ok
17:15:34 <dons> SyntaxNinja: yay, Ross is in for the hackathon.
17:17:06 <SyntaxNinja> dons: sweeeeet
17:17:58 * dons feels some momentum building
17:18:07 <Korollary> fictitious
17:18:12 <dons> maybe :)
17:22:48 <psnl> dons: do you mind if I show up and don't hack on ghc? 
17:25:36 <dons> psnl: well, the plans is libraries, new library ports, cabal, any compiler, ...
17:25:43 <dons> so you don't have to hack on ghc.
17:26:09 <dons> so a lot of functional infrastructure hacking
17:26:15 * psnl was thinking about finding some bit of hat thats just grunt work and implementing that
17:26:50 <dons> yep. there's some ideas on the hac07 page. you could add more
17:27:14 <dons> or find some nice popular library in a foreign language, and port that
17:27:15 <dibblego> can type synonyms have bounded polymorphic parameters?
17:27:37 <dibblego> type X a b = a -> b -- make a of type-class Eq for example
17:28:12 <dons> data Eq a => X a b = a ~~> b -- ?
17:28:23 <dibblego> hm
17:28:27 <dibblego> wtf is ~~> ?
17:28:40 <dons> just rolled my own arrow constructor, pointless really here :)
17:28:52 <dibblego> mk :)
17:28:58 <psnl> @seen ndm
17:28:59 <lambdabot> I saw ndm leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 3d 9h 53m 33s ago, and .
17:30:32 <dons> newtype Eq a => a ~~> b = EqArrow (a -> b)
17:30:33 <dons> f :: Integer ~~> Integer
17:30:33 <dons> f = EqArrow (\x -> x+1)
17:30:35 <dons> for fun?
17:30:55 <dons> not even sure if its useful though
17:31:53 <dons> dibblego: I guess it is useful, you get a constraint, i.e. this doesn't work:
17:31:53 <dons> newtype Floating a => a ~~> b = EqArrow (a -> b)
17:31:54 <dons> f = EqArrow (\x -> x+1::Int)
17:35:30 <dons> interesting to see the positive response to http://scienceblogs.com/goodmath/2006/11/query_for_readers_interested_i.php
17:35:32 <lambdabot> http://tinyurl.com/ykdpsh
17:35:49 <dons> casually asking if people would like more haskell blogs, and "Since posting the question on a holiday weekend saturday night, I've gotten 50 responses, and they're unanimously in favor. I will start working on it, and the first parts should appear on the blog later this week."
17:36:22 <SyntaxNinja> I love you all, goodbye.
17:37:19 <dcoutts> dons, oh, nice.
17:37:33 * dcoutts means Ross turning up for a bit
17:37:58 <dons> yeah
17:38:34 <dons> ?remember PaulPotts Haskell is an even "redder" pill than Lisp or Scheme
17:38:43 <dons> (http://geeklikemetoo.blogspot.com/2006/11/some-haskell-basics.html)
17:38:46 <lambdabot> Title: Geek Like Me, Too: Some Thoughts on Haskell, http://tinyurl.com/yxfg9v
17:39:02 <Korollary> dons: thats a math blog. it would be weird if they werent in favor
17:39:14 <dons> Korollary: agreed
17:39:34 <dons> I'm more interested in the fact they're not haskell regulars. bringing in a lot of math guys would be great.
17:39:48 <dons> its an under exploited niche for the language
17:40:17 <Korollary> more people = better Num classes
17:40:31 <dons> exactly
17:40:47 <dons> more math libs in general 
17:41:27 <Korollary> there's no reason why those people should use Python
17:48:21 <wy> I'm wondering how is Eq.== defined. It seems that it can compare any datatype derived from it.
17:51:25 <kpreid> wy: it is defined differently for every instance of Eq.
17:51:34 <kpreid> also, Eq is not a package, it is a typeclass
17:51:46 <kpreid> "Eq.==" would only make sense if Eq were a package
17:52:50 <wy> kpreid: I see. Then how can I express == is a member of Eq?
17:53:06 <kpreid> there is no haskell syntax to describe that
17:53:36 <kpreid> just say "== of Eq" or some such
17:53:43 <dibblego> ?where yaht
17:53:44 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
17:53:44 <wy> So Eq will know the structure of anything defined with "data" ?
17:54:21 <kpreid> no
17:54:29 <kpreid> only things for which an Eq instance has been defined or derived
17:54:50 <kpreid> those things could be data or newtype or some extension
17:55:12 <monochrom> It's operator overloading.
17:55:40 <dibblego> is it just me and my pdf reader, or does the YAHT contents page *not* link to the relevant section?
17:55:52 <dibblego> it is such a pain manually navigating it
17:56:25 <kpreid> my readers agree that there are no links
17:57:34 <monochrom> I think it's just you
17:57:41 <monochrom> who find it painful :)
17:58:02 <dons> wy: the typeclass Eq provides the following operations:
17:58:03 <dons> class  Eq a  where
17:58:03 <dons>     (==), (/=)       :: a -> a -> Bool
17:58:03 <dons>     x /= y       = not (x == y)
17:58:03 <dons>     x == y       = not (x /= y)
17:58:04 <dibblego> suppose you find the topic in section 7, how do you get to section 7?
17:58:18 <dons> any type which is an instance of Eq has to provide some notion of == and /=
17:58:22 <dons> ?instance Eq
17:58:22 <lambdabot> Maybe you meant: instances instances-importing
17:58:26 <dons> ?instances Eq
17:58:27 <lambdabot> (), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
17:58:45 <dons> now, the compiler can derive (recursively) an Eq instance for your custom type, given a set of primitive Eq from which to build
17:58:48 <wy> kpreid: I'm just feeling strange that I don't have to define == for the datatypes. If I define it, it should be something like: 
17:58:48 <wy> instance (Eq a) => Eq (Tree a) where 
17:58:48 <wy>   Leaf a         == Leaf b          =  a == b
17:58:48 <wy>   (Branch l1 r1) == (Branch l2 r2)  =  (l1==l2) && (r1==r2)
17:58:48 <wy>   _              == _               =  False
17:59:04 <monochrom> Yes.
17:59:16 <dons> right, so that's a recursive Eq, and you can get away with deriving Eq mechanically
17:59:32 <wy> I have to know the structure of Tree to define this. So Eq have some knowledge of data type constructors
17:59:42 <dons> indeed it does
17:59:44 <monochrom> No. "deriving" does.
17:59:50 <dons> Eq doesn't, the compiler does.
17:59:54 <dons> yes. the magic 'deriving'
17:59:59 <wy> I see. deriving :_
18:00:05 <LoganCapaldo> Ooooo that's what that keyword does
18:00:11 <dons> Eq is just the class above, not the associated 'deriving' power
18:00:22 <LoganCapaldo> silly me
18:00:28 <dons> i.e. Eq is just the set of types for which == and /= work
18:00:31 <LoganCapaldo> I thought it was like instance but for a list
18:00:34 <LoganCapaldo> of types
18:01:05 <monochrom> "deriving" reads your mind.
18:02:10 <dons> wy: make sense?
18:02:23 <wy> dons: yes. it makes sense
18:02:33 <dons> I suspect type classes must be a fairly obvious innovation to an *ML programmer
18:03:04 <wy> dons: yes. I've been looking for it
18:03:36 <wy> dons: It seems that's what's called object oriented programming
18:03:51 <Korollary> Not quite imho
18:04:20 <wy> Korollary: what's the difference?
18:04:55 <aFlag> is ocaml syntax different from standard ml? I was reading a book with examples in ML, but I couldn't make them run on ocaml interpreter
18:05:06 <edwardk> aflag: yeah
18:05:10 <aFlag> I then got that smj and it worked fine
18:05:10 <dons> there's connections between an object and a type class, but the OO world tend to conflate 3 different concepts into a class: a set of types, a new concrete type, and an instance. these 3 things are all separate in Haskell
18:05:38 * mbishop just won an hp jornada 720 on ebay for $88
18:05:40 <eviltwin_b> yeh, OCaml is a different beast
18:05:56 <monochrom> ML provides a hack called "eqtype".  After learning it, there are two possible outcomes.  One possibility is that the person wishes to generalize "eqtype" to "mytype", "yourtype", "histype", ... in which case you invent type classes.  The other possibility is to use modules.
18:05:57 <dons> and true parametric polymorphism is usually fairly awkward in OO/class-based languages
18:06:13 <mbishop> I kind of like ocaml
18:06:17 <dons> and modules are type classes with associated types :)
18:06:37 <aFlag> ml functors can work kinda like typeclasses, can't they?
18:06:46 <monochrom> If you have decided to use modules, it is kind of hard to back out to the original question and see type classes.
18:06:48 <dons> yep. with associated types, and some other magic besides, I think
18:06:52 <mbishop> I don't particularly like OO howerver
18:07:05 <wy> dons: It's fairly clear to me after reading "Little MLer" and "Little Java, a Few Patterns"
18:07:11 <eviltwin_b> there was recently a paper about the equivalence of type classes and ML functors, no?
18:07:14 <aFlag> does ocaml have OO stuff?
18:07:24 <mbishop> aFlag: yes, that's why it's *O*caml
18:07:28 <eviltwin_b> (well, recently on reddit)
18:07:31 <dons> SPJ once described type classes as a 'solid, simple, reliable 1990 corolla" (or similar car), while ML functors are some kind of Porsche: fast, powerful, too much for most people
18:07:47 <dons> eviltwin_b: yep, a few papers have appeard
18:08:02 <aFlag> eviltwin_b: I don't know, I thought that because I recently read about functors and I thought that they could be used like typeclasses, but I didn't go as far as researching it
18:08:19 <aFlag> how can a functional programming language be object oriented?
18:08:25 <wy> mbishop: If you used Lisp, you will feel ML's type system is a good thing. If you have used sml, you will feel Haskell's is a good thing.
18:08:29 <aFlag> I mean the idea of an object is about changing state
18:08:54 <mbishop> wy: I've used lisp, and I like ocaml's type system (or lack there of...at least from the programmers perspective)
18:08:57 <aFlag> and you usually don't which to have functions changing state in functional programing
18:09:21 <sorear> lisp and ML are functional with side effects
18:09:27 <aFlag> I heard once that there was a Object-Haskell or something like that, but it didn't make sense to me
18:09:36 <wy> aFlag: I think OOP doesn't mean change of states. It means you can use a function to operate on different types
18:09:55 <dons> and the object concept artificially limits how you can encapsulate state (all that public/private stuff). you could roll a monad to achive almost any encapsultion property you like -- without needing new keywords or language support
18:09:56 <aFlag> sorear: yes, but the idea is using them only when needed, and not for the representation of everything
18:09:57 <mbishop> aFlag: OHaskell
18:10:51 <aFlag> wy: isn't that polimorphism?
18:10:54 <dons> Cale, math people, do you know of more math-related resources other than those here: http://haskell.org/haskellwiki/Haskell_and_mathematics  for haskellers?
18:10:57 <lambdabot> Title: Haskell and mathematics - HaskellWiki, http://tinyurl.com/yerb92
18:11:00 <aFlag> wy: in that sense  haskell would be OO, then
18:11:19 <mbishop> I still find haskell's syntax to be awkward...probably just because I don't think in the functional sense
18:11:48 <dons> do you think its related to the functional nature of the language? isn't it just syntax?
18:11:48 <aFlag> mbishop: really? I find it much cleaner then ML
18:11:56 <dons> i.e. python's and ruby's is roughly similar
18:11:57 <aFlag> and WAY cleaner than lisp :)
18:12:05 <dons> other than special concise lambdas and currying
18:12:08 <wy> aFlag: OO means object oriented. I think haskell is not "oriented". You still have freedom not to use OOP
18:12:11 <mbishop> aFlag: I don't like SML syntax much, but I like Ocamls syntax for some reason
18:12:19 <mbishop> course I still prefer s-exprs :P
18:12:22 <dons> heh
18:12:25 <dibblego> mbishop, imperative programming is just a different view of the same world
18:12:31 <wy> mbishop: actually I found Lisp syntax the best
18:12:39 <mbishop> wy: me too
18:12:47 <aFlag> wy: really?
18:12:55 <aFlag> wy: don't you find it confusing?
18:13:01 <LoganCapaldo> Forth syntax ftw
18:13:02 <monochrom> Haskell is value-oriented.
18:13:12 <dons> dibblego: isn't imperative programming a view into only a small part of the world? the part where everything is instance Monad IO 
18:13:25 <dons> no instance Monad Cont or instance Monad [a] to be had
18:13:34 <wy> mbishop: In fact, if we have a language that has Lisp syntax and Haskell type system. That will be near ideal
18:13:37 <mbishop> I like haskell, it's just...I find there's too many different characters in the syntax I suppose
18:13:38 <sorear> Lisp syntax is good for parsing, but I keep mismatching parens; Haskell is less typo-inducing
18:13:52 <LoganCapaldo> dons: Tell that to the machine code emitted by ghc ;)
18:13:56 <dons> imperative programming is just a legacy evaluation strategy from before we knew how to generalise evaluation strategies
18:13:58 <mbishop> sorear: well with emacs, my parens are matched for me :P
18:14:09 <dibblego> dons, I was meaning more in a philosophical sense, but otherwise, yes
18:14:14 <dons> :)
18:14:25 <monochrom> hahaha too many different characters
18:14:26 <kpreid> wy: therp is working on that
18:14:37 <mbishop> monochrom: what? I'm serious heh, it almost reminds me of perl :/
18:15:05 <wy> kpreid: Do you think that's a good idea?
18:15:21 <kpreid> wy: I haven't tried it yet.
18:15:30 <dons> being good for parsing (for machines) seems an odd thing to optimise a language for, I think. languages are written and read by humans, after all. optimise for them :) (same reason we moved away from machine code in the first place) </controversial> 
18:15:43 <monochrom> I have seen a language with only two different characters. (One of them is space.) It's hard to use.
18:15:52 <sorear> Python has actually had a failed proposal to use APL symbols (PEP 3099 I think)
18:16:02 <mbishop> dons: well you know, they have almost that exact quote in SICP, and they are talking about lisp so :P
18:16:07 <Korollary> dons: It's an important value when you intend to write macros all over.
18:16:08 <dons> heh
18:16:14 <wy> kpreid: Is therp an id on IRC?
18:16:14 <dons> Korollary: ah yes, very true
18:16:16 <mbishop> I find lisp syntax incredibly easy to read
18:16:17 * mbishop shrugs
18:16:20 <dons> Korollary: as TH displays
18:16:24 <kpreid> wy: yes
18:16:53 <wy> kpreid: Does the project has a web site. I'm certainly interested in that
18:17:03 <dons> mbishop: anyway, its jsut syntax. you can use the S-expr subset of haskell all day if you want :)
18:17:10 <kpreid> wy: I don't know; ask therp. I expect it doesn't yet.
18:17:23 <kpreid> dons: show me a data declaration in that subset :)
18:17:25 <dons> > (map (+1) (1:(2:(3:[]))))
18:17:26 <lambdabot>  [2,3,4]
18:17:46 <wy> kpreid: Where is he? Seems not online now
18:17:46 <mbishop> dons: indeed, I like haskells ideas, it's just the syntax that slightly puts me off, but I'm sure with a little use I'd get used to it
18:17:58 <kpreid> wy: I agree, he's not online now
18:18:18 <dons> mbishop: cool. the syntax is one of the best features once you submit to it
18:18:20 <aFlag> dons: what do you mean by general evalutation strategy?
18:18:24 <sorear> I've gotten used to it; haskell has destroyed my ability to type C
18:18:25 <LoganCapaldo> Shouldn't that be: (map (+1) ((:) 1 ((:) 2 ((:) 3 []))))
18:18:27 <mbishop> I was reading that microsoft paper about monads...apparently a monad is an "action" that takes a "copy" of the world, applies a side effect to that world, and then produces the result, and the new resulting world..correct?
18:18:30 <wy> Do you think functional languages can't have macros like those of Lisp?
18:18:56 <dibblego> mbishop, yep, hence the "different view"
18:18:59 <dons> aFlag: you can write a custome Monad instance, and suddenly your do block behaves like Prolog, or C, or a continuation system, or a region-allocating language.
18:19:01 <kpreid> mbishop: here's a tip: 'all those characters' are just punctuationy identifiers, just like /= in lisp
18:19:16 <aFlag> hum
18:19:20 <mbishop> kpreid: yeah, that's what I was thinking
18:19:21 <kpreid> mbishop: the underlying syntax only has a few things, like -> <- :: [...]
18:19:22 <dons> aFlag: monads let you change how your code is evaluated( i.e. imperative, backtracking,....)
18:19:22 <aFlag> I see your point
18:19:27 <glguy_> mbishop: That's one way to look at the *IO* Monad
18:19:32 <dibblego> mbishop, you can apply that view of the physical world as well
18:19:37 <Korollary> dons: Are there any neat TH examples on the wiki?
18:19:43 <dons> since the evaluation order isn't hard coded into the language, its up for grabs
18:19:48 <kpreid> mbishop: you can always write a + b as (+) a b, in all contexts
18:19:51 <aFlag> dons: that's not a functional property, though. As far as I know, only haskell have monads
18:19:56 <dons> and imperative programming is just the subset where instance Monad IO holds
18:20:20 <monochrom> Some of you might think that "function" works better than "\", "public class X extends Y" works better than "X :> Y", ...  But as someone who did not grow up in an English-speaking world, I can tell you, for an Indian or a Chinese (these are the only programmers who matters, no?), those "function", "public", "class", "extend" are all just Greek to them, not any better than "\" and ":>".
18:20:20 <kpreid> or ST or STM...
18:20:20 <aFlag> By the way, I still don't really understand much about monads :(
18:20:22 <mbishop> neat
18:20:25 <dons> right, you need typeclasses and maybe do-syntax , to make the language usable: http://haskell.org/haskellwiki/Monad#Monads_in_other_languages
18:20:28 <lambdabot> Title: Monad - HaskellWiki, http://tinyurl.com/y2fdhw
18:20:28 <wy> I think Lisp syntax is ideal because that essentially the abstract syntax tree. It doesn't have ambiguity. It frees you so that you can use almost any word or character to write your function.
18:20:35 <LoganCapaldo> Io (www.iolanguage.com) is pass-by-expression, so you can have arbitrary evaluation order in that as well
18:20:52 <glguy_> Monads have been implemented in many languages
18:20:54 <mbishop> monochrom: that's true, and I never really though how symbols are so universal...neat :)
18:21:02 <dons> aFlag: http://programming.reddit.com/info/ox6s/comments/coxoh
18:21:04 <lambdabot> Title: Ask Reddit: What the hell are monads? (reddit.com), http://tinyurl.com/ylqe7b
18:21:19 <mbishop> thought*
18:22:01 * mbishop runs off, will be back latter
18:22:05 <aFlag> monochrom: I'm not sure, english is not my native language and I still find keywords in a natural language easier than just symbols
18:22:10 <wy> If we use a lisp syntax, there would be no need for operator association, priority, or many reserved keywords...
18:22:26 <dibblego> aFlag, that should change with practice
18:22:30 <monochrom> A long time ago someone translated BASIC to Chinese, i.e., a programming language isomorphic to BASIC but all keywords and built-in functions are in Chinese.  It was implemented on Apple II.
18:23:05 <wy> monochrom: I guess I've seen that language when I was young
18:23:06 <dibblego> aFlag, the Java developers around me get annoyed when I start "refactoring" their methods into a combination of _ and $ :)
18:23:41 <Korollary> wy: and there would be an explosion in the amount of ( characters.
18:23:48 <Korollary> nothing is free.
18:24:11 <aFlag> dibblego: I'm sure that once you get use with a certain symbol, it becomes natural to you, but there's no need to scare people that are not familiar with the symbols
18:24:15 <wy> Korollary: I love ((((())))))) ;-)
18:24:37 <dibblego> aFlag, I prefer to become familiar with the formality of the expression, not its arbitrary identifier
18:25:02 <aFlag> what's the formal way to say private?
18:25:10 <dibblego> where :)
18:25:28 <wy> Korollary: With a syntax like that, you can write programs that tranform programs more easily.
18:25:30 <dibblego> consider a function of type a -> a -> Bool
18:25:41 <monochrom> An Indian or Chinese willing to learn a bit of English is of course going to find "extend" a bit better than ":>".  But the catch is he always forgets whether it is "extend" or "extends".
18:25:53 <dibblego> I prefer to consider that, than "EqualRelation" or whatever you decide to call it today
18:26:01 <Korollary> wy: Presupposing that you need to transform programs. It's not the only game in town.
18:26:27 <aFlag> monochrom: hum, that's true, I always used to forget where I should use throw and where I should use throws in java
18:27:19 <wy> Korollary: I still find macros a good thing. So I'm wondering if the idea of macro conflict with functional style
18:27:54 <monochrom> So, I don't know.  I just think it's useful to remind everyone that certain "natural" things are really "trained" instead.
18:28:10 <dibblego> monochrom++
18:28:16 <aFlag> it would be nice if I code code in portuguese, though
18:28:42 <dibblego> monochrom, the best way to be reminded of that, is to have children
18:28:45 <aFlag> s/code code/could code/
18:28:49 <Korollary> wy: No, macros don't conflict per se as the transformed program is again functional. It's just yet another abstraction method. In this case macros abstract over syntax. There are other abstraction methods. Haskell has type classes and interesting composition opportunities thanks to its lazy eval. There's also TH for haskell for metaprogramming just like ocaml has camlp4.
18:28:54 <monochrom> I think overall programmers use the word "natural" too much in their debates on programming languages.  Almost half of their "natural"s are artificial.
18:28:57 <Cale> wy: I don't think they do, but laziness really helps replace a lot of the tasks which you'd normally do with macros.
18:29:12 <dibblego> I think "almost half" is a conservative estimate
18:29:40 <monochrom> Somehow I don't have children and I still see a lot of my own habits as "unnatural".
18:29:48 <dibblego> I wonder what proportion of programmers have children versus the rest of the world
18:29:57 <monochrom> I think living in a multicultural country helps alot.
18:30:00 <Korollary> monochrom: I prefer gobbledygook = intuitive ;)
18:30:06 <dibblego> yep, so do I
18:30:21 <dons> dibblego: you've got kid(s) right?
18:30:26 <dibblego> dons, 2
18:30:31 <aFlag> monochrom: but still, if you come to think about it, most of your code will have english words anyhow
18:30:36 <dons> :)
18:30:46 <aFlag> all the functions from the standard library are in english
18:31:59 <monochrom> I certainly wouldn't want to invent a symbol to replace the word "head".
18:32:19 <LoganCapaldo> !!0 is a symbol ;)
18:32:32 <monochrom> or "tail".
18:33:01 <LoganCapaldo> (\(x:xs)->xs) is a loongsymbol ?
18:33:12 <aFlag> monochrom: or fold, map, and so on
18:33:18 <monochrom> or "data".
18:33:57 <monochrom> Hahaha I be damned if someone replaced all Haskell keywords by symbols!
18:34:04 <aFlag> ehhe
18:34:13 <monochrom> "Martian Haskell"
18:34:14 <LoganCapaldo> You'd be programming in APL then wouldn't you?
18:34:18 <dons> we do have proper lambdas and foralls now....
18:34:31 <monochrom> APL's not got lazy evaluation.
18:34:58 <LoganCapaldo> I heard it has a very loosely specified order of evaluation though
18:35:01 <sorear> nor first class functions IIRC
18:35:02 <glguy_> nor has it more than about 4 types :)
18:36:38 <monochrom> Oh the other day I came up with this idea of translating the Prelude into Chinese, i.e., use Chinese names; and to encourage similar translations to Japanese, Arabic, ...
18:38:20 <sorear> C-INTERCAL supports keywords in over 10 languages - great for obfuscation.
18:40:26 <monochrom> Thus you can go like "import B10N.Prelude.Chinese; main =  $  20 'a' ".  (That's print $ replicate 20 'a' )
18:40:36 <monochrom> B10N stands for Babelization.
18:41:38 <sorear> why 'main'?
18:42:28 <dibblego> ?hoogle Set a -> [a]
18:42:29 <lambdabot> Data.Set.elems :: Set a -> [a]
18:42:30 <lambdabot> Data.Set.setToList :: Set a -> [a]
18:42:30 <lambdabot> Data.Set.toAscList :: Set a -> [a]
18:42:38 <dons> ?docs Data.Set
18:42:39 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Set.html
18:43:14 <monochrom> The tale goes like this.  There is a group of cool programmers inventing Haskell and developing GHC.  It has become so close to the ideal language and compiler that the power that be becomes worried.  So the power that be introduces Unicode into Haskell source.  Henceforth the developers of GHC use a million different versions of the Prelude in their contributions to GHC and cannot understand each other, and all is good again.
18:44:12 <dibblego> why are there so many Set a -> [a] functions? elems, toList, toAscList; they are all O(n) after all
18:45:40 <sorear> all three do exactly the same things (notice the 'Source code' link at the top of the lib doc page)
18:46:27 <sorear> ??? orthogonality with fromList/fromAscList ???
18:47:42 <sjanssen> sorear: seems like the most plausible explanation
18:50:41 <kpreid> toAscList is obvious: it will remain ascending even if elems/toList don't
18:50:47 <kpreid> elems and toList are strange
18:52:27 <sorear> I've had a Neat Idea(tm), I have ~200 lines of demo. implementation, ~200 lines of descriptive text, now - where do I put it? #haskell ? haskell@... ? haskell-cafe@... ? /haskellwiki ? ...
18:52:48 <Korollary> what kinda demo?
18:52:52 <dons> is it a library, or a tutorial?
18:53:01 <dons> is it cabalised?
18:53:25 <sorear> library; restricted IO module with permissions inference
18:53:36 <dons> sorear: ok. then: http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
18:53:39 <lambdabot> Title: How to write a Haskell program - HaskellWiki, http://tinyurl.com/yxe296
18:53:40 <dons> sounds cool!
18:53:54 <dons> (basically, cabalise it, add a web page to the haskell wiki, announce on haskell@)
18:53:56 <LoganCapaldo> Permissions inference?
18:54:06 <dons> sorear: you need hosting?
18:54:11 <sjanssen> kpreid: they're the same implementation
18:54:18 <LoganCapaldo> Is that like type inference, but for permissions?
18:54:30 <sorear> it uses type inference
18:54:37 <kpreid> sjanssen: so I saw said above. my statement stands
18:54:56 <sjanssen> kpreid: it's hard to imagine an implementation of Set that would have a fromList that doesn't produce elements in order
18:55:42 <sorear> you can say e.g. copy d s = readRIORef s >>= writeRIORef d
18:56:04 <eviltwin_b> hm?  one based on a hash table instead of a list
18:56:09 <edwardog> Is there a way to get inline haskell interpreted in html?
18:56:26 <sorear> the inferred type is (Elem (WriteRef a) o, Elem (ReadRef b) o) => RIORef a c -> RIORef b c -> RIO o ()
18:56:30 <edwardog> (Like php)
18:57:02 <monochrom> Hahahaha I know!
18:57:05 <sorear> while trying to get refs sanely handled I managed to subsume ST as well
18:57:34 <monochrom> toAscList is in-order, elems is pre-order, setToList is post-order.   Isn't that cool?  XD
18:59:46 <monochrom> edwardog: like this?  http://www.vex.net/~trebla/haskell/xlhs.xhtml
19:01:27 <edwardog> monochrom: That's pretty nifty. Thanks
19:05:19 <sorear> one tiny nagging question. I'm 16, contract age (US) is 18, can I still license keyboard output?
19:06:31 <dons> you mean, put a license on your code?
19:07:07 <sorear> yes
19:07:26 <monochrom> "keyboard output" is a strange phrase...
19:07:34 <dons> almost certainly yes :) i've never heard otherwise..
19:07:54 <dons> you need some kind of license, otherwise 'all rights reserved' applies
19:07:58 <Korollary> monochrom: One day we will code using tablets and stylus!
19:08:14 <monochrom> One day we won't code.
19:08:31 <Korollary> thats much later
19:08:36 <sjanssen> when we're dead!
19:08:36 <monochrom> But I'm thrilled that the starting age of Haskelling is getting lower and lower.
19:08:39 <dcoutts> sorear, copyright licences are not contracts
19:09:16 <monochrom> In a few years we will beat the starting age of drinking.
19:09:33 <monochrom> And in a decade we will have kids Haskelling before they have sex.
19:09:42 <dcoutts> monochrom, hah, in the US the drinking are is 21 in most states so that's easy
19:09:44 <glguy_> when kids start rebelling against their imperative language coding parents
19:09:57 <monochrom> No, of course not drinking legally.
19:10:00 <dons> sorear: is the 'project page' grokable?
19:10:10 <sorear> Well I was 15 when I started...
19:10:17 <sorear> what is 'project page'?
19:10:35 <dons> this guy: http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
19:10:37 <lambdabot> Title: How to write a Haskell program - HaskellWiki, http://tinyurl.com/yxe296
19:11:21 <sorear> Yes it makes sense, I even read it earlier, I just never thought of 'sample implementation' as being is-a 'program', silly me
19:13:49 <wy> I'm reading the chapter of the tutorial "http://www.haskell.org/tutorial/classes.html" and found the analogy from Haskell to OOP not quite right. It seems (type classes = abstract classes), (types = classes), and (values = objects).
19:13:50 <lambdabot> Title: A Gentle Introduction to Haskell: Classes
19:14:50 <kpreid> wy: in Java terms, a type class is an interface, and 'instance' is 'implements'
19:15:49 <wy> Uhh... Then what's the difference between a interface and an abstract class?
19:16:35 <eviltwin_b> a Java interface is effectively an abstract class
19:16:53 <sorear> type classes can have default methods, so they are more general than interfaces
19:17:21 <sorear> like non-abstract funs in an abstract class
19:19:11 <Korollary> Careful making such analogies. You can't pass an Int to a function that expects a double as if Num is an interface.
19:20:38 <LoganCapaldo> 2pts for Korollary
19:20:40 <sorear> IANAJP, sorry...
19:21:06 <LoganCapaldo> Oh wait
19:21:13 <LoganCapaldo> takes away the points
19:21:17 <emu> hmm, I think I discovered a problem with SerTH: when reading a serialized form of `Nothing', it gets confused and doesn't know which type of Maybe it is
19:21:20 <LoganCapaldo> You can't do that in Java either
19:21:39 <wy> It seems one thing is missing. Can't I overload functions?
19:22:06 <LoganCapaldo> The function that expects a double wouldn't have type (Num a) => a -> <whatever>
19:23:10 <sjanssen> wy: not ad-hoc like in some languages
19:23:40 <wy> It seems the idea of function overloading in C++ and other OOPs is conflict with the idea of the type system of the functional languages. They break the type system?
19:23:52 <sorear> would you put a massively enhanced IO monad currently named RIO in System.RIO.* or Control.Monad.RIO.* ??
19:24:18 <sorear> I'm sure you could simulate overloading with MPTC's, but why?
19:24:29 <kpreid> I'd put it in System.IO.RIO
19:24:52 <wy> sorear: I realized that with this type system. I needn't overloading
19:24:57 <LoganCapaldo> wy: That's why you can only overload in the context of a type class
19:26:39 <wy> I wonder if "deriving" is accessing something like "universal class" or "Object" ?
19:26:50 <Korollary> no
19:27:20 <eviltwin_b> the behavior of deriving is specified by the haskell98 report
19:27:42 <wy> Korollary: Then are there types deriving Show that can't be printed?
19:27:52 <Korollary> LoganCapaldo: Yes. That's why typeclasses are like C++ templates, not classes.
19:28:31 <eviltwin_b> if you try to derive Show for a type which incorporates a type that does not have a Show instance you get a compile-time error
19:30:01 <sorear> If you derive a Show on a higher-kinded type, then the type will only have Show if its used args have Show
19:30:14 <sorear> data Pair a = Pair a a deriving(Show)
19:30:26 <sorear> Pair Int : has Show
19:30:37 <sorear> Pair (Integer -> Bool) : doesn't
19:31:04 <monochrom> That is right.
19:31:12 <sjanssen> instance Show (a -> b) -- and now it does ;)
19:33:35 <dons> emu: you'd have to constrain the type to Maybe Int -- or whatever 
19:33:51 <wy> sjanssen: Can you give me a complete example of defining show on a->b? I'll try it
19:33:53 <dons> since its ambiguous which instance of 'a' you're building from Maybe a
19:34:30 <sjanssen> wy: you can't define a reasonable defn. of Show for a -> b . . . I was being ornery
19:34:58 <sorear> instance Show (a -> b) where show f = "<function>" . is not reasonable but it is legal
19:34:59 <kpreid> sure you can
19:35:11 <sorear> used to be in the Prelude, even <sigh>
19:35:31 <Korollary> the problem is read, heh.
19:35:34 <dons> instance Show (a -> b) where showsPrec _ _ = showString "<function>"
19:35:42 <dons> *M> show Char.ord
19:35:42 <dons> "<function>"
19:35:52 <dons> > ord -- using a different show instance
19:35:54 <lambdabot>  <Char -> Int>
19:36:12 <monochrom> AH!  Yes, there is the expectation read(show f) = f.  Can't do it to functions.
19:36:38 <dons> sorear: the show instance for functions is in Text.Show.Functions, but a read instance is hard without a compiler
19:36:44 <sorear> Sure you can. (Pure haskell or generic, pick one)
19:36:56 <sjanssen> monochrom: you could have the compiler spit out the internal representation, but that violates the reasonable clause
19:37:44 <sorear> instance (Enum a, Bounded a, Show b) => Show (a -> b) where show f = show [ f x | x <- [ minBound .. maxBound ] ]
19:37:52 <dons> as Clean does for its serialisable functoins (via bytecode read/show)
19:38:08 <dons> sorear: :)
19:38:14 <monochrom> Then it is out of the hands of the programmer.
19:38:18 <sorear> show not = "[True, False]" (note : this is Brain-HC, not GHC)
19:40:35 <sorear> instance (Enum a, Bounded a, Read b) => Read (a -> b) where read str = let (tt :: [b]) = read str in \f x -> tt !! (fromEnum x - fromEnum minBound) 
19:41:04 <wy> sorear: Why can't I let instance (Enum a, Bounded a, Show b) => Show (a -> b) where show f = show [ f x | x <- [ minBound .. maxBound ] ] to work?
19:41:44 <dons> sorear++ nice idea:
19:41:45 <sorear> I probably mistyped something.  Also Brain-HM is notoriously buggy.
19:41:45 <dons> *M> show not
19:41:45 <dons> "False -> True, True -> False"
19:41:51 <dons> instance (Enum a, Bounded a, Show a, Show b) => Show (a -> b) where
19:41:51 <dons>     show f = ppr $ zip n (map f n)
19:41:51 <dons>         where n = [minBound ..]
19:41:51 <dons>               ppr []         = []
19:41:51 <dons>               ppr [(x,y)]    = show x ++ " -> " ++ show y 
19:41:52 <sjanssen> @type \f -> show [ f x | x <- [ minBound .. maxBound ] ]
19:41:54 <dons>               ppr ((x,y):xs) = show x ++ " -> " ++ show y ++ ", " ++ ppr xs
19:41:54 <lambdabot> forall a a1. (Show [a], Bounded a1, Enum a1) => (a1 -> a) -> String
19:42:27 <dons> *M> take 100 $ show Char.ord
19:42:28 <dons> "'\\NUL' -> 0, '\\SOH' -> 1, '\\STX' -> 2, '\\ETX' -> 3, '\\EOT' -> 4, '\\ENQ' -> 5, '\\ACK' -> 6, '\\a' -> 7"
19:42:32 * dons thinks this is fun
19:42:39 <sjanssen> wy: it should be "instance (Enum a, Bounded a, Show [b]) => Show ..."
19:42:42 <Korollary> yeah it's whacky
19:43:08 <kpreid> dons: ppr can be simplified with intercalate!
19:43:12 <dons> it can
19:43:17 <kpreid> down with explicit comma cases!
19:43:55 <kpreid> then there's my favorite imperative comma hack:
19:43:56 <sorear> Show [b]? wow, I've been using haskell for months, I thought constraints had to be type variables
19:44:02 <dons> also,               ppr ((x,y):xs) = printf "%s -> %s, " (show x) (show y)
19:44:11 <wy> sjanssen: Still not working. Can you give me the complete working code?
19:44:18 <kpreid> ppr _ [] = []
19:44:18 <kpreid> ppr c (x:xs) = c ++ (process x) ++ ppr ", " xs
19:44:39 <kpreid> start with ppr ""
19:46:05 <sjanssen> @where paste
19:46:05 <lambdabot> http://paste.lisp.org/new/haskell
19:46:29 <lisppaste2> sjanssen pasted "show functions" at http://paste.lisp.org/display/30779
19:47:27 <dons> is there some reasonable Show for functions that prints part of the domain of the function on one line, that we could add to lambdabot
19:47:48 <dons> so something like what I suggested above, but compressed to show the first few cases, the last few cases, and some sample from the middle of the enum
19:48:14 <kpreid> that seems a little funny
19:48:19 <dons> here's my start: http://www.cse.unsw.edu.au/~dons/tmp/A.hs
19:48:33 <dons> but it could be very useful for quickCheck displaying failing cases for functions...
19:48:34 <SamB_XP> @scheck \f x -> (f x :: Bool) == ((f . not) x)
19:48:36 <lambdabot>   Failed test no. 3. Test values follow.: {True->True;False->False}, True
19:48:39 <dons> right
19:48:40 <dons> like that.
19:49:24 <dons> the instance (Serial a, Show a, Show b) => Show (a->b) where
19:49:28 <dons>  in Smallcheck.hs
19:49:38 <SamB_XP> yeah ;-)
19:49:49 <dons> but we don't want Serial, or do we?
19:49:58 <dons> i.e. Enum/Bounded might be better
19:50:01 <dons> or enum  + take
19:50:06 <SamB_XP> eek
19:50:07 <SamB_XP> but.
19:50:27 <SamB_XP> that only works on really things that are in Enum, doesn't it?
19:50:36 <sorear> Integer isn't bounded, Integer->Bool is isomorphic to REALS
19:51:08 <SamB_XP> sorear: oh, really?
19:51:16 <SamB_XP> oh, right
19:52:02 <SamB_XP> you could encode reals in binary, right?
19:52:09 <wy> It works like magic :-)   *Main> show (||) "[[False,True],[True,True]]"
19:52:20 <dons> cool huh.
19:52:26 <sorear> that is the thought
19:52:26 <sjanssen> Serial might be the most reasonable choice
19:52:40 <dons> sjanssen: do you want to have a go at writing the instance?
19:52:48 <dons> it might even be worth its own lambdabot command
19:52:53 <sorear> IIRC Double has an Enum instance
19:53:09 <dons> ?instances Enum
19:53:10 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
19:53:27 <sorear> suggest: pretty print, gives nice lined up table
19:53:31 <sorear> (or graph)
19:53:43 <dons> for irc we need to pack the data into 1 or at most 2 lines though
19:53:49 <dons> offline can be a different story
19:53:53 <newsham> hmm.. if I have a class HTML and  (HTML a) and (HTML b), I cant "intersperse a [b]" ?
19:54:22 <dons> newsham: right. you'd need to a -> b-ify first, or make the list type heterogenous
19:54:22 <sorear> Yes. a and b must be unifyable
19:54:24 <SamB_XP> newsham: isn't there an Html type?
19:54:33 <SamB_XP> @hoogle a -> Html
19:54:35 <lambdabot> Text.Html.debugHtml :: HTML a => a -> Html
19:54:35 <lambdabot> Text.Html.toHtml :: HTML a => a -> Html
19:54:41 <SamB_XP> ah, yeah, see?
19:54:57 <SamB_XP> @hoogle a -> b -> Html
19:54:58 <lambdabot> No matches, try a more general search
19:55:03 <SamB_XP> @hoogle a -> [b] -> Html
19:55:05 <lambdabot> No matches, try a more general search
19:55:06 <newsham> yes, I want to   intersperse "|" with a list of hotlink's
19:55:15 <SamB_XP> @hoogle [a] -> b -> Html
19:55:17 <lambdabot> No matches, try a more general search
19:55:24 <SamB_XP> oh well...
19:55:26 <SamB_XP> anyway.
19:55:28 <sorear> Html-ize them first, or use existential boxes
19:55:41 <SamB_XP> sorear: isn't that what Html is?
19:56:01 <SamB_XP> @type Text.Html.Html
19:56:03 <lambdabot> [Text.Html.HtmlElement] -> Text.Html.Html
19:56:06 <SamB_XP> oh, no.
19:56:38 <newsham> this is basically what I want to do:  tLinks ls = foldr1 (+++) (intersperse "|" hls) where
19:56:38 <newsham>     hls = map (\(l,t) -> hotlink l [toHtml t]) ls
19:56:58 <newsham> ie. a bunch of links (url,text) separated by "|" characters
19:57:22 <newsham> I can do    (hotlink ...) +++ "|" +++ (hotlink ...)
19:57:29 <sorear> wait... Html sounds like it should be a monad
19:57:33 <newsham> but putting them in a list with intersperse isnt working
19:57:40 <SamB_XP> newsham: no, no...
19:57:45 <SamB_XP> not a monad!
19:57:52 <newsham> i didnt say its a monad
19:57:57 <SamB_XP> er.
19:57:58 <SamB_XP> sorear: 
19:58:01 <SamB_XP> sorry ;-)
19:58:17 <newsham> so why cant I intersperse two things that are both in the HTML class?
19:58:45 <wy> dons: You definition of show is not working. Can you paste the complete code for me? thank you~
19:59:39 <sorear> ?hoogle [Html] -> Html
19:59:40 <lambdabot> Text.Html.menu :: String -> [Html] -> Html
19:59:43 <SamB_XP> because you can't have [exists a. Html a => a]
20:00:23 <newsham> so I can use +++ between these things, but I cant put them in a list and foldr1 +++ across the list
20:00:25 <newsham> that seems silly
20:01:15 <dons> wy: http://www.cse.unsw.edu.au/~dons/tmp/A.hs
20:01:21 <sorear> if you're going to use toHtml, do it first, have a [Html], then use concatHtml (?)
20:01:43 <sorear> breaks separation of concerns, but it beats thinking about the alternatives.
20:01:56 <newsham> ahh, toHtml saves the day
20:01:58 * eviltwin_b *blinks* at the reddit paper on shell-as-monads
20:02:08 <sorear> Hetero lists are doable, but they are not haskell's strong suite
20:02:39 <dons> eviltwin_b: yeah, its kinda obvious (you can even do the list monad if you're tricky...)
20:02:44 <SamB_XP> newsham: didn't I suggest that already?
20:02:56 <dons> i prefer existentials for hlists, static typing, light syntax
20:03:00 <newsham> samb: i dunno, hard ot follow everyone typing and me coding in another window and looking up stuff and so forth
20:03:23 <dons> these guys: 
20:03:30 <dons> ?wiki Heterogenous_collections
20:03:30 <lambdabot> http://www.haskell.org/haskellwiki/Heterogenous_collections
20:04:02 <sorear> The perfect language would have `natural
20:04:10 * dons finds it interesting that he no longer has to paste articles to reddit about haskell
20:04:22 <dons> seems like all the reddit regulars are doing it instead
20:04:22 <sorear> 'syntax sugar for Hlists et al....
20:04:44 <dons> sorear: yeah. at least existentials aren't too heavy. 
20:04:51 <sorear> .... the perfect language would also come with a free bottle of memory enhancement pills.
20:05:00 <dons> but with ADTs , who needs special hlists
20:05:08 <dons> > [Left 1, Right 'x']
20:05:09 <lambdabot>  [Left 1,Right 'x']
20:05:48 <sorear> ADTs are the reason I use 1 language
20:05:56 <sorear> last year I used ~16
20:06:10 <dons> sorear: hehe
20:07:01 <dons> so here's the unix / monad page: http://programming.reddit.com/info/sjzw/details
20:07:04 <lambdabot> Title: UNIX pipes as IO monads (reddit.com), http://tinyurl.com/y3nu96
20:07:08 <dons> (quite a classic if you've not seen it before)
20:07:36 <dons> (even more fun with h4sh: http://www.cse.unsw.edu.au/~dons/code/h4sh/DOC)
20:07:37 <lambdabot> http://tinyurl.com/y7ugvj
20:08:28 <sorear> Less complete idea:
20:08:47 <sorear> class Apply f a r | f -> a r where ap :: f -> a -> r
20:09:08 <sorear> instance Apply (a -> b) a b where ap = ($) {- needs special handling -}
20:09:32 <eviltwin_b> hm, what's this map command it references?
20:09:52 <sorear> instance Monad m => Apply m (a -> b) (m a) (m b) where ap = Control.Monad.ap
20:10:02 <eviltwin_b> or are you assuming the existience of one?
20:10:07 <sorear> instance Apply (Array ix e) ix e where ap = (!)
20:10:12 <sorear> map ?
20:10:41 <eviltwin_b> <dons> (even more fun with h4sh: http://www.cse.unsw.edu.au/~dons/code/h4sh/DOC)
20:10:43 <lambdabot> http://tinyurl.com/y7ugvj
20:11:06 <sorear> erps, instance Monad m => Apply (m (a -> b)) (m a) (m b) where ap = Control.Monad.ap
20:11:44 <sorear> I'd like instance Monad m => Apply (a -> m b) (m a) (m b) where ap = (=<<)
20:11:51 <sorear> but that violates the fundeps
20:12:08 <SamB_XP> heh
20:18:20 <sjanssen> sorear: the fundeps aren't the problem there
20:18:27 <sjanssen> it's a potentially overlapping instance
20:19:50 <sjanssen> actually, both the fundeps and the overlapping are a problem
20:20:22 <wy> Why can't this example work? http://paste.lisp.org/display/30780
20:20:53 <sjanssen> wy: please paste an error message
20:21:57 <fnord123> Integer -> Maybe Natural I would have thought
20:22:16 <wy> sjanssen: error message pasted
20:22:50 <sjanssen> wy: Num requires that the type is an instance of Eq and Show
20:23:15 <wy> sjanssen: then how do I modify it?
20:23:49 <sjanssen> wy: annotated
20:24:14 <sjanssen> wy: did you know that pings can be sent to the channel when you paste/annotate?
20:24:26 <dons> at least if you go via:
20:24:27 <dons> ?paste
20:24:28 <lambdabot> http://paste.lisp.org/new/haskell
20:25:22 <fnord123> sjanssen: in wy's problem, why is the type of toNatural :: Integer -> Natural and not Integer -> Maybe Natural?
20:25:51 <sjanssen> fnord123: well, that's another problem entirely
20:25:59 <wy> sjanssen: It works. Thank you!
20:26:03 <sjanssen> that's a question of style, really
20:26:19 <monochrom> callCC (\c -> fix c)   -- Cale you're a genius!
20:26:37 <fnord123> I would have thought not having Maybe would be an error..
20:26:45 <wy> monochrom: Haskell has call-cc?
20:26:48 <sorear> Back to kbd, the idea is that overloaded ap could be the null operator...
20:26:58 <sorear> Yes.  it is impl'd as a monad
20:27:18 <monochrom> Not first class.  Just inside a monad specially for that.  See Control.Monad.Cont
20:27:18 <sorear> data Cont a = Cont ((a -> r) -> r)
20:27:35 <wy> sorear: Great! Is it like the call-cc of Scheme?
20:27:38 <monochrom> But inside that monad it's as good as first class.
20:27:46 <sorear> Yes. Just like.
20:28:01 <sorear> The monad automagically rewrites your code in CPS.
20:28:20 <wy> sorear: I see. So it's a code walker?
20:28:35 <sorear> do { a ; b } means a >> b
20:29:11 <sorear> Cont implements >> as (\cont -> let newc x = cont (b x) in a newc)
20:29:13 <dons> its just how the monad works, wy. you plug in whatever evaluation rule you want. continuation for example, or imperative eval, or backtracking, or ...
20:30:10 <monochrom> It is enlightening that there exists a monad in which I can do arbitrary jumping.  My world is undone.
20:30:17 <wy> dons: sounds great! Hope I can get to that tomorrow
20:30:37 <dons> ?wiki Monad
20:30:38 <lambdabot> http://www.haskell.org/haskellwiki/Monad
20:30:40 <dons> gives a few examples
20:31:08 <sorear> So (with overloaded null operator) we can have e.g echo = putStrLn getStrLn
20:31:26 <sorear> that desugars as echo = (ap putStrLn getStrLn)
20:31:35 <sorear> the (I wish) bind instance triggers
20:31:44 <sorear> echo = getStrLn >>= putStrLn
20:32:12 <sorear> If it can be made to work... all the niceties of a full-blooded strict language
20:32:54 <sorear> getStrLn = case getChar of { '\n' -> [] ; x -> x : getStrLn }
20:33:01 <sorear> hmm, case is a problem
20:33:23 <wy> I wonder why if (1<0) then a1+a2 else 2 work if a1 and a2 are Natual type. There is a fromInteger in the instance. But why does if...then...else call that function?
20:34:10 <sorear> sure... (1 < 0) === (fromInteger 1 < fromInteger 0)
20:34:23 <sorear> (1 < 0) :: (Num a, Ord a) => a
20:34:48 <sorear> oops
20:34:54 <wy> sorear: but that has nothing to do with the return type
20:34:57 <sorear> (Num a , Ord a) => Bool
20:35:07 <sorear> ie, ambig, default kicks in
20:35:09 <wy> the return type is Natual now
20:35:54 <wy> So my question is how is toInteger used in this?
20:36:02 <wy> fromInteger. sorry
20:36:05 <monochrom> !!!!! Apposition is to be overloaded too???? !!!!!
20:36:19 <Cale> wy: hm?
20:36:28 <sorear> if must have a single type, 2's type (Num a => a) unifies with (a1 + a2) :: Natural, giving Natural
20:36:39 * monochrom looks at the ground.  It's disappearing!  It's becoming abstract, virtualized!
20:37:00 <Cale> if (1<0) then a1+a2 else 2  translates to  if 1 < 0 then a1 + a2 else fromInteger 2
20:37:07 <Cale> if that's what you mean...
20:37:09 <wy> sorear: I see... all is done with unification
20:37:39 <Botty> My proposal for a new Data.List function:
20:37:43 <Botty> sortWith f = sortBy (\x y -> compare (f x) (f y))
20:38:09 <sorear> I've had that too.
20:38:17 * monochrom writes down in his diary: "The year 2006 sees the most profound breakthrough in Haskell.  Both composition and apposition are generalized.  This is a monumental year."  This diary is bound to be an important historical account in the future.
20:38:18 <sorear> I called it sortShwartz
20:39:10 * Botty wonders what apposition is :)
20:39:12 <monochrom> So, does Schwartzchild mean withChild?
20:39:16 <Botty> I suppose it could be $
20:39:19 <wy> Botty: me too
20:39:28 <monochrom> apposition is application by juxtasposition, i.e., f x
20:39:37 <Botty> oh ok
20:39:40 <wy> btw: how can I type in an action in irc?
20:39:58 <Botty> wy - /me <action>
20:40:07 <monochrom> /quit action
20:40:15 * wy knows how to use it now
20:40:20 <sorear> I believe i heard something about `on` being used for that now
20:40:20 <sorear> Nice long thread on haskell*, (flamewar?)
20:40:20 <sorear> erm, /command ?
20:40:41 <monochrom> try it! heeheehee
20:41:06 <fnord123> Since I suspect there is a high intersection of (ps and pdf users) and OS X  users in this channel, I suppose I'll ask here as well as #macosx: If there a way to make .ps files 'readable' in Preview? The default font used in the conversion is simply awful.
20:42:09 <Cale> maybe you can get gv running under X?
20:42:29 <wy> sorear: Do I need another unification algorithm for doing that type inference ?
20:42:34 <fnord123> s/If/is/
20:43:15 <sorear> One unification handles everything, iff you use H98.
20:43:32 <dons> ?users
20:43:33 <lambdabot> Maximum users seen in #haskell: 276, currently: 228 (82.6%), active: 26 (11.4%)
20:43:34 <sorear> Extensions + type inference = deep black art
20:43:53 <sorear> + lots of M-R papers
20:43:54 <wy> I mean ... It seems I need an algorithm other than that of ML's
20:44:30 <sorear> HM handles type classes and higher kinded variables, but chokes soon after
20:45:24 * wy wonders if sorear is a programming language researcher
20:45:36 <sorear> No.
20:45:42 <Botty> heh, can't even type his DOHs properly he's so tired
20:45:52 <sorear> I have however made it my life goal to know everything
20:46:10 <eviltwin_b> ...about nothing?
20:46:19 <eviltwin_b> (old joke)
20:46:23 * wy regard sorear as de Vinci II
20:47:04 <Botty> there's quite alot to be known about nothing
20:48:09 <eviltwin_b> $x knows more about less and less until eventually he knows everything about nothing; $y knows less and less about more andmore until eventually he knows nothing aboiut everything
20:48:17 <eviltwin_b> for various values of $x and $y
20:48:57 <wy> I see. Haskell is using the full unification algorithm. So it can type ((\f-> if (f True) then 1 else 2) (\x->x))
20:49:14 <wy> which sml doesn't type
20:49:38 <sorear> Haskell uses the "give a random error and let the programmer insert sigs at random" inference algo
20:49:55 <wy> sorear: really? uhh
20:51:25 <Botty> ?type (\f-> if (f True) then 1 else 2) (\x->x)
20:51:27 <lambdabot> forall t. (Num t) => t
20:52:11 <dibblego> wy, take a look at Chameleon
20:52:27 <dibblego> http://www.comp.nus.edu.sg/~sulzmann/chameleon/download/haskell.html
20:52:30 <lambdabot> Title: A Haskell Programmer's Guide to Chameleon, http://tinyurl.com/weqs4
20:53:55 <wy> dibblego: what's that?
20:54:14 <dibblego> er, sorry, I misread
20:55:25 <wy> Thanks! I've learned a lot today! Good night ^^
20:56:58 <Botty> dibblego - thanks for linking to that, I was just designing a functional language just like that :O
20:59:15 <dibblego> Botty, I saw a talk on it at APLAS
21:00:18 <Botty> cool
21:07:58 <dons> ?users #Haskell
21:07:59 <lambdabot> Maximum users seen in #Haskell: 198, currently: 147 (74.2%), active: 12 (8.2%)
21:10:19 <Botty> ?users #haskell
21:10:20 <lambdabot> Maximum users seen in #haskell: 276, currently: 227 (82.2%), active: 20 (8.8%)
21:13:00 * Botty wonders where it gets diffferent activity levels 0-o
21:14:24 <sorear> case sensitive ???
21:21:26 <dons> yeah, some kind of bug. grr
21:21:36 <int-e> @index lowerCaseString
21:21:36 <lambdabot> bzzt
21:22:08 <dons> basically, the nicks aren't checked for case insensitivity, and some people seem to have #Haskell in their associated info
21:22:21 <dons> but , also, it does seem to get the number for #haskell right, so its a bit weird
21:22:29 <dons> ?users
21:22:29 <lambdabot> Maximum users seen in #haskell: 276, currently: 225 (81.5%), active: 21 (9.3%)
21:22:34 <dons> agrees with my client
21:23:58 <Botty> hmm, I get 228 in my client
21:24:09 <eviltwin_b> same
21:24:23 <dons> ?users
21:24:23 <lambdabot> Maximum users seen in #haskell: 276, currently: 226 (81.9%), active: 21 (9.3%)
21:24:29 <dons> eh, close enough :)
21:24:31 <int-e> ?users #Haskell
21:24:31 <lambdabot> Maximum users seen in #Haskell: 198, currently: 147 (74.2%), active: 11 (7.5%)
21:24:40 <int-e> 11 active, eh?
21:24:45 * eviltwin_b wonders what it's looking at
21:25:01 <dons> so that would be people who joined when the weird netsplit was on, and this place was breifly named #Haskell by some weird server
21:25:11 <int-e> @users #Haskell
21:25:12 <lambdabot> Maximum users seen in #Haskell: 198, currently: 148 (74.7%), active: 12 (8.1%)
21:25:20 <int-e> at the user's /join command
21:25:31 <Botty> dons - sure, but why are they active?
21:25:42 <dons> they've said something here in the last 4 hrs
21:26:01 <Botty> oh, but joined to a different capitalization... that's wonky!
21:28:26 <eviltwin_b> wack.
21:31:42 <dufflebunk> I've got a dumb question which I know is answered in one of the tutorials but I can't find it.
21:31:45 <Botty> from a quickie sampling of the user list it appears everyone is on '#Haskell'.
21:32:02 <dons> dufflebunk: ask away
21:32:11 <dons> Botty: yeah, the netsplit did something weird
21:32:14 <dufflebunk> If a function's type needs two classes, Like Ord a, and Eq b, how is it given?
21:32:24 <Cale> (Eq a, Ord b) => ...
21:32:28 <Cale> er
21:32:45 <Cale> Well, I got the variables swapped of course :)
21:32:48 <eviltwin_b> strike that! reverse it!
21:32:52 <dons> can anyone think of a library function with two class constraints?
21:32:57 <dons> ?type sortBy -- but with 2
21:32:59 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
21:33:00 <sjanssen> @type fromIntegral
21:33:01 <dufflebunk> Cale: Thanks, that worked :)
21:33:02 <lambdabot> forall b a. (Num b, Integral a) => a -> b
21:33:06 <dons> sjanssen++
21:33:08 <dons> of course
21:33:47 <dons> ?hoogle (C a , D b) => a -> b
21:33:48 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
21:33:49 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
21:33:49 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
21:33:58 <sjanssen> @type Data.Map.lookup
21:33:59 <dons> no class patterns then :)
21:33:59 <lambdabot> forall a (m :: * -> *) k. (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
21:34:01 <Botty> hmm, I suppose people's PRIVMSG signals could give a different case i suppose.  Been a while since i've written a bot though, so i'm pretty fuzzy
21:34:27 <Botty> i suppose i have a problem with supposing too much, i suppose
21:35:05 <dons> sjanssen: ok smarty pants ;) find me one with two class constraints on the same tyvar
21:36:37 <dons> I guess we don't have anything that requires Ord'd Monad
21:37:20 <sjanssen> this one is tough
21:37:45 <dons> it would be a very interesting case if we could find one in the libraries
21:38:20 <dons> finding one in user code usually just means they don't know the class hierarchy (i.e. Eq a , Ord a) => ...
21:40:40 <monochrom> there is an instance (Ix a, Show a, Show b) => Show (Array a b).  This has an implication on the corresponding show function.
21:40:55 <Botty> ?type numericEnumFromThenTo
21:40:57 <lambdabot> Not in scope: `numericEnumFromThenTo'
21:41:06 <dons> ?hoogle FromThenTo
21:41:07 <lambdabot> Language.Haskell.TH.FromThenToR :: Exp -> Exp -> Exp -> Range
21:41:07 <lambdabot> Language.Haskell.TH.fromThenToE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
21:41:07 <lambdabot> Language.Haskell.TH.fromThenToR :: ExpQ -> ExpQ -> ExpQ -> RangeQ
21:41:14 <dons> ?hoogle enumFromThenTo
21:41:14 <lambdabot> Prelude.enumFromThenTo :: Enum a => a -> a -> a -> [a]
21:41:15 <lambdabot> Language.Haskell.Syntax.HsEnumFromThenTo :: HsExp -> HsExp -> HsExp -> HsExp
21:41:42 <Botty>  numericEnumFromThenTo::(Fractionala,Orda)=>a->a->a->[a]
21:41:45 <eviltwin_b> ?hoogle (@?=)
21:41:46 <Botty> in the prelude
21:41:46 <lambdabot> Did you mean: (
21:41:47 <lambdabot> Prelude.undefined :: a
21:41:47 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
21:41:56 <Botty> maybe the prelude writers don't know the hierarchy :)
21:42:11 <sjanssen> @type Test.QuickCheck.utils.isAssociative
21:42:12 <lambdabot> Not in scope: `Test.QuickCheck.utils'
21:42:13 <lambdabot>  
21:42:13 <lambdabot> <interactive>:1:22: Not in scope: `isAssociative'
21:42:14 <eviltwin_b> ?hoogle (Test.HUnit.Base.@?=)
21:42:14 <lambdabot> Hoogle Error: Parse Error: Unexpected character '
21:42:23 <sjanssen> @type Test.QuickCheck.Utils.isAssociative
21:42:24 <lambdabot> forall a. (Eq a, Show a, Test.QuickCheck.Arbitrary a) => (a -> a -> a) -> Test.QuickCheck.Property
21:42:41 <lispy> ?hoogle Test.HUnit.Base.@?=
21:42:42 <lambdabot> Hoogle Error: Parse Error: Unexpected character '
21:42:46 <sjanssen> there are a couple in that module
21:42:47 <lispy> bad hoogle
21:42:50 <Botty> (and yes, i know looking in the prelude is pretty rediculous)
21:42:55 <sjanssen> but this one has _three_
21:42:59 <monochrom> Data.Array.mapArray :: (MArray a e' m, MArray a e m, Ix i) => (e' -> e) -> a i e' -> m (a i e)   This has two constraints on a.
21:43:23 <sjanssen> these are amazingly rare
21:44:04 <monochrom> three is awesome
21:45:16 <dons> huh. i wonder what that says about the code?
21:45:20 <dons> that there should be a superclass
21:45:27 <dons> or needs more refactoring
21:45:36 <dons> almost worth a haskell-cafe@ query
21:46:26 <Cale> lots of haskell on reddit
21:46:29 <brad__> dons, i always see obscure url references to libraries mentioned on haskell-cafe, is there anything like cpan for haskell? one place to put libs?
21:46:32 <sjanssen> perhaps library functions tend to express only one "concept" at a time
21:47:10 <dibblego> ?hoogle Set -> a -> a
21:47:11 <lambdabot> Data.Set.fold :: (a -> b -> b) -> b -> Set a -> b
21:47:23 <dibblego> that sucks
21:47:42 <dons> brad__: we're working on hackage, a unified page. currently the main place is: http://haskell.org/haskellwiki/Libraries_and_tools
21:47:45 <lambdabot> Title: Libraries and tools - HaskellWiki, http://tinyurl.com/j6sf3
21:47:51 <dons> sjanssen: yeah. so amost the sign of needing redesign
21:47:56 <brad__> awesome, thanks dons
21:47:56 <sjanssen> more class constraints means the function is more specific, and therefore has less opportunity for reuse
21:48:06 <brad__> now a question for the #haskell crew
21:48:07 <dons> brad__: here's the beta hackage (cpan for haskell) http://hackage.homedns.org/view/
21:48:21 <lambdabot> Title: Libraries and Tools for Haskell
21:48:32 <dons> getting hackage done is the main goal of the upcoming hckathon
21:48:51 <lispy> oh, cool bring it to fruition!
21:48:57 <lispy> do it to it
21:49:08 <brad__> so with 'filter' i can create a list from another is elements pass a test, what about for tuples? lets say i have a list [(Integer,String)], and i want to filter them based on a test to the Integer. is there an elegant way to do this?
21:49:42 <Botty> brad__ - nope, because you wouldn't be able to determine the type of the resulting tuple
21:49:55 <Botty> err wait
21:49:56 <brad__> thanks Botty!
21:49:57 <Botty> sorry
21:49:58 <Korollary> I think you misunderstood him
21:49:58 <lispy> well, one way is filter (p . fst), where p is the predicate you want to test on the number
21:50:06 <Botty> I did, didn't look at the code
21:50:16 <Botty> err, list decleration
21:50:35 <sjanssen> > filter (even . fst) [(2, "stuff"), (3, "junk")]
21:50:37 <lambdabot>  [(2,"stuff")]
21:50:46 <dons> > filter ((>3) . fst) $ zip [1..] "haskell"
21:50:47 <lambdabot>  [(4,'k'),(5,'e'),(6,'l'),(7,'l')]
21:50:48 <lispy> > filter ((==1) . fst) [(1,'a'), (2, 'b'), (1, 'c')]
21:50:50 <lambdabot>  [(1,'a'),(1,'c')]
21:50:56 <brad__> thanks guys!
21:50:58 * Botty just read "so with 'filter' i can create a list from another is elements pass a test, what about for tuples?" and jumped to conclusions
21:51:00 <Cale> sjanssen: damn you, that's almost exactly the example I was typing!
21:51:06 <Cale> hehe
21:51:23 <Korollary> ?djinn [(Integer, String)] ->  Bool
21:51:24 <lambdabot> f _ = False
21:51:31 <Korollary> how useful
21:51:31 <dons> hehe
21:51:45 <dons> it needs polymophism to really get going
21:52:06 <dons> there's not many useful functions that can be derived on monomorphic types, via free theorems
21:52:06 <lispy> i feel that way in the mornings
21:52:11 <Korollary> still, djinn is under no obligation to do anything useful.
21:52:15 <Cale> Does it work with recursive types?
21:52:19 <lispy> but once i get my polymorphism i'm good for the day
21:52:22 <dons> it does, just.
21:52:47 <Cale> does it ever write a recursive function?
21:52:48 <Korollary> ?vixen discriminate some integers please?
21:52:49 <lambdabot> you have very nice manors
21:53:02 <Cale> heh
21:53:04 <dons> ?djinn-add type S s a = (s -> (a, s))
21:53:16 <dons> ?djinn a -> S s a
21:53:17 <lambdabot> f a b = (a, b)
21:53:34 <dons> ?djinn S s a -> (a -> S s b) -> S s b
21:53:35 <lambdabot> f a b c =
21:53:35 <lambdabot>   case a c of
21:53:35 <lambdabot>   (d, e) -> b d e
21:53:43 <dons> return and bind for a state monad 
21:54:08 <dons> ?djinn-add data ListN a as = Nil | Cons a as
21:54:11 <Korollary> oops
21:54:15 <brad__> oh by the way, dons, i saw on reddit you mentioned that there were "two" good books coming out for haskell. one i know of is hutton's book, what was the other?
21:54:16 <lispy> ?type \a b = (a, b)
21:54:17 <lambdabot> parse error on input `='
21:54:24 <sjanssen> it'd be nice if djinn could work with abstract data types.  I'd like to define "data List a" and foldr, and see what happens
21:54:26 <lispy> ?type \a b -> (a, b)
21:54:26 <dons> ?djinn-add type List a = Fix (ListN a)
21:54:27 <lambdabot> forall a b. a -> b -> (a, b)
21:54:36 <dons> ?djinn List a -> ListN a (List a)
21:54:36 <lambdabot> f _ = Nil
21:54:37 <sjanssen> could do the same thing with a dummy Monad type and bind
21:54:46 <dons> ?djinn List a -> Bool
21:54:46 <lambdabot> f _ = False
21:54:56 <dons> ?djinn-add out :: List a -> ListN a (List a)
21:55:02 <dons> ?djinn-add in :: ListN a (List a) -> List a
21:55:10 <dons> ?djinn List a -> Bool
21:55:11 <lambdabot> f _ = False
21:55:19 <dons> ah well
21:55:34 <Korollary> f _ = constant just works.
21:55:36 <dibblego> can anyone tell me what criteria you use to prefer either Set.toAscList, Set.elems or Set.toList?
21:55:41 <Korollary> I will tell my boss.
21:55:44 <dons> brad__: well, I was actually thinking of the 'haskell on full throttle' that CosmicRay is writing
21:55:57 <dons> and a practical haskell i'm planning... but Hutton's is also on the list, yes
21:56:09 <brad__> oh dons i will definitely buy your book
21:56:23 <dons> hehe. well i need to write it, after i finish my phd. better do that first.
21:56:36 <brad__> my former coworker wrote a popular oreilly book, made almost nothing off of it
21:56:45 <dons> oh, interesting.
21:56:45 <lispy> dons: now, don't get your priorities mixed up...the phd isn't important ;)
21:56:47 <Cale> dibblego: I think there's no difference
21:57:04 <dibblego> righto then
21:57:12 <dons> -- | /O(n)/. Convert the set to a list of elements.
21:57:13 <dons> toList :: Set a -> [a]
21:57:13 <dons> toList s = toAscList s
21:57:15 <Cale> dibblego: basically use whichever based on which 'from' functions you might be using nearby
21:57:21 <dons> ?source Data.Set
21:57:21 <lambdabot> http://darcs.haskell.org/packages/base/Data/Set.hs
21:57:21 <Korollary> dibblego: I think elems is useless.
21:57:33 <sjanssen> what animal would O'Reilly assign to Haskell?
21:57:40 <Korollary> sjanssen: a lazy one
21:57:42 <dons> hmm.
21:57:54 <dons> something pure and functional 
21:58:08 <dons> and maybe kinda big
21:58:13 <dons> a bear?
21:58:16 <sjanssen> Korollary: the animal has to spring in to action when forced too
21:58:27 <Cale> Is sloth taken?
21:58:27 <Korollary> a cat maybe
21:58:38 <lispy> i think i saw sloth aleardy
21:58:39 <dons> some kind of exotic cat
21:58:53 <Korollary> the kind that villains in Bond movies pet
21:59:10 <sorear> bacteria that live underground eating the oil mixed with groundwater... divide once every 10k years... do a lot with a little, slowly...
21:59:11 <dons> though ther's also the evil birds from jmuk's book...
21:59:23 <lispy> i'd be happy with some type of armored creature
21:59:31 <lispy> like an armadillo
21:59:47 <eviltwin_b> taken already, I think
21:59:58 <dons> these guys: http://www.amazon.co.jp/gp/product/4839919623
22:00:15 <sjanssen> is there a story behind those birds?
22:00:35 <Korollary> they look angry
22:00:44 <dons> they shoot lasers from their eyes?
22:00:45 <lispy> the angry birds of FP
22:00:49 <brad__> thanks again for the answers provided people, as always, #haskell is problem solver. take care!
22:00:55 <lispy> fricken lazer beamns
22:01:05 <dons> oh, and this one hasa seal: http://www.amazon.co.jp/gp/product/4797336021/ref=pd_bxgy_b_img_b/250-8743205-5320215
22:01:08 <lambdabot> http://tinyurl.com/ym6452
22:02:12 <dons> the new brazil textbook has some kind of unicyclist (?) shapr would love that. http://www.novateceditora.com.br/livros/haskell/
22:02:15 <lambdabot> http://tinyurl.com/yjkv9g
22:02:44 <sjanssen> weird
22:02:58 <sjanssen> the ever present Haskell-unicycle connection
22:03:04 <dons> yeah. strange
22:03:16 <Korollary> and 8 cylinders
22:03:23 <Korollary> and the 1990 corolla
22:03:37 <dons> yep hmm.
22:03:56 <Korollary> covers the entire spectrum
22:07:32 <dons> I'm trying to clean up the irc page, any suggestions: http://haskell.org/haskellwiki/IRC_channel
22:07:33 <lambdabot> Title: IRC channel - HaskellWiki
22:09:33 <dons> int-e++ patches
22:14:01 * lispy goes to read it
22:14:53 <dibblego> why prefer List.union over List.(++) ?
22:14:55 <desrt> dons; you wrote an stg paper, didn't you?
22:14:59 <desrt> dons; i can't find it on your site
22:15:08 <dons> yeah, my honours thesis, a long time ago :)
22:15:14 <dons> let me find it...
22:15:43 <lispy> i like it
22:15:43 <dons> written in 36 hours of caffeine fuelled freakery, http://www.cse.unsw.edu.au/~pls/thesis/dons-thesis.ps.gz
22:15:44 <lambdabot> http://tinyurl.com/y5n7fl
22:15:45 <desrt> someone in our programming languages class gave a talk on friday about how to compile a haskell-like language to C
22:15:45 <newsham> oh, pshaw, your thesis wasnt spinless!
22:16:16 <newsham> spineless even
22:16:23 <desrt> it wasn't too great.  he planned poorly and ran out of time by a rather wide margin... so i recommended to the class to check out your paper but then i couldn't find it anymore :)
22:16:42 <desrt> thanks.
22:16:43 <dons> i ran out of time too, but not so badly perhaps.
22:17:23 <dons> i'm sure its full of mistakes :) 
22:17:24 <desrt> yup.  this is the one.
22:17:29 <sjanssen> dons: too late to correct a typo? ;)
22:17:40 <desrt> doesn't matter.  it clarifies the concept quite nicely, even if the details might be wrong.
22:17:42 <dons> kinda :)
22:18:02 <dons> sjanssen: though if someone comes up with a fun new VM, i might look at rewriting it. javascript is a little bit tempting
22:18:28 <dons> that document illustrates my last use of java, fwiw.
22:18:30 <dons> oh the memories
22:21:02 <desrt> :)
22:21:12 <lispy> good way to put it :)
22:21:14 * desrt emails it to jacques with recommendation to forward to the class mailing list
22:23:15 <dons> heh. ok
22:25:37 <desrt> you'd be suprised.  bits of the haskell community leak into that class.
22:25:44 <dons> cool
22:26:28 <desrt> is there someone around named oleg?
22:28:30 <Botty> ?seen oleg
22:28:30 <lambdabot> I haven't seen oleg.
22:29:01 <dons> desrt: yeah, but not here :)
22:29:07 <dons> ?google oleg
22:29:09 <lambdabot> http://www.olegproducts.com/
22:29:09 <lambdabot> Title: Oleg Saxophones, Flutes, Woodwind Ligatures and Accessories
22:29:13 <dons> not quite
22:29:16 <dons> ?google oleg haskell
22:29:16 <desrt> dons; his name comes up from time to time
22:29:17 <lambdabot> http://okmij.org/ftp/
22:29:18 <lambdabot> Title: This FTP site
22:29:20 <dons> that one
22:29:36 <desrt> Unless specified otherwise, all the code and the documentation on this site is in public domain.
22:29:40 <desrt> huh.
22:30:11 <dons> let's try int-e's new patch
22:30:36 <sieni> desrt: huh what?
22:30:52 <dons> ?users #haskell
22:31:03 <dons> oh, i got spam delived to lambdabot@manzano.cse.unsw.EDU.AU yesterday
22:31:05 <dons> funny
22:31:06 <int-e> @users #hAskeLL
22:31:11 <dons> i'm not sure lambdabot needs penis pills
22:31:17 <lambdabot> Maximum users seen in #haskell: 276, currently: 227 (82.2%), active: 13 (5.7%)
22:31:23 <dons> cool
22:31:25 <desrt> ?penislength
22:31:28 <lambdabot> Maximum users seen in #haskell: 276, currently: 227 (82.2%), active: 14 (6.2%)
22:31:31 <dons> and matches the client count
22:31:34 <lambdabot> Unknown command, try @list
22:31:45 <desrt> hm.  he's shy about it.
22:32:13 <Botty> ?users
22:32:14 <lambdabot> Maximum users seen in #haskell: 276, currently: 227 (82.2%), active: 15 (6.6%)
22:35:04 <Botty> ?penislength would actually be a pretty good alias for ?users
22:35:04 <lambdabot> Unknown command, try @list
22:45:32 <i-luv-my-kbd> anyone awake? 
22:48:09 <glguy_> nope
22:49:51 <Botty> Currently 15 members of the channel (6.6%) are active.
22:50:00 <glguy_> ?users
22:50:01 <lambdabot> Maximum users seen in #haskell: 276, currently: 228 (82.6%), active: 18 (7.9%)
22:50:07 <Botty> well, 18 then
22:50:14 <i-luv-my-kbd> Well, this is awefully sleepy. 
22:50:53 <Botty> would be cool to give lambdabot some AI.  Whoever runs (dons?) probably wouldn't appreciate it analyzing everything everyone says though
22:51:14 <Botty> and the chan might not appreciate its likely stupidity
22:51:17 <glguy_> Botty: lambdabot already analyzes everything
22:51:50 <glguy_> What words are used the most, who used them last, who says the most curse words, who writes the longest sentences
22:52:04 <Botty> sure, but deeper. like checking a database of questions and equating that to a normal command (eg, "anyone awake?" = "?users")
22:52:11 <glguy_> ahh
22:53:39 <Botty> better yet, searching the docs.  eg "Is there a function to apply a function to every element of a list?" = internal google/hoogle and return if the results are relavent enough.
22:53:56 <dons> Botty: actually, a MegaMonad style plugin for lambdabot would be fun
22:54:24 <dons> i-luv-my-kbd: learning haskell?
22:56:04 * Botty looks up MegaMonad - wow, looks funny
22:56:46 <dons> and i have the entire logs handy... if someone wants to write a megamonad plugin..
23:00:04 <Botty> so, megamonad isn't actually useful for automatically dealing with automizeable questions, but rather for entertaining diversion?
23:04:05 <dons> that would be it. :) 
23:04:06 <Botty> oh, just markov stuff then
23:04:25 <dons> yup
23:04:26 <Botty> I'll give it a shot - what's the bot test chan again?
23:04:29 <dons> feel free to add AI
23:04:39 <dons> anyone you like :) #haskell-overflow would be fine
23:04:45 <dons> or #my-random-zjkdjfkasdf-chan
23:05:11 <Botty> heh, i thought there was one for that one haskell irc bot tutorial
23:05:16 <glguy_> so was MegaMonad a bot or a pothead?
23:05:44 <Botty> hard to tell the difference these days, innit?
23:05:49 <i-luv-my-kbd> dons: yeah.  I'm working on some haskell.  I'm going to wrap it up though. It's late here.  Morning there? 
23:06:15 <ValarQ> morning over here
23:06:28 <dons> afternoon here
23:06:51 <dons> > fix ((1:) . scanl (+) 1) -- have a fixpoint
23:06:54 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
23:08:46 <jcreigh> I wish haskell had eval. then we could write quines with "fix eval" :)
23:09:32 <glguy_> > fix ( (1:) . (1:) . (zipWith (+) `ap` tail))
23:09:33 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
23:09:35 <glguy_> weee ;)
23:09:40 <glguy_> welp, bedtime
23:10:26 <dons> ?type System.Eval.Haskell.eval -- jcreigh ;)
23:10:28 <lambdabot> forall a. (AltData.Typeable.Typeable a) => String -> [System.Eval.Utils.Import] -> IO (Maybe a)
23:15:04 <jcreigh> whoa...really? how would that even work?
23:15:49 <dons> how do you think lambdabot evals your strings... 
23:15:56 <dons> > 1+2 -- eval me now baby 
23:15:57 <lambdabot>  3
23:19:51 <jcreigh> I know, but lambdabot is magic.
23:20:20 <jcreigh> (meaning, I thought it was doing nasty tricks in GHC's guts or something)
23:20:35 <ValarQ> not that nasty
23:21:53 <ValarQ> it uses mr Stewards hs-plugins library for evaluation if im not mistaken
23:22:00 <dons> right
23:22:08 <dons> no guts
23:22:16 <ValarQ> s/ards/arts/
23:22:57 <Heffalump> how does fix eval give you a quine?
23:23:28 <jcreigh> Heffalump: well, quines would be the fixpoints of the eval function, right?
23:23:43 <Heffalump> a quine is a program that prints out its own source, yes?
23:23:48 <jcreigh> Heffalump: yeah.
23:24:05 <Heffalump> oh, I see
23:24:14 <Heffalump> you mean it should be a fixpoint of show . eval
23:24:26 <Heffalump> or print . eval
23:24:28 <Heffalump> or something like that
23:24:42 <Heffalump> (probably show . eval since that has the right type)
23:24:54 <lispy> a quine in lisp would be about 2 lines
23:24:59 <lispy> or maybe you could do it in one
23:25:26 <lispy> they actually have a function in CL to read the source file for the function which is being called :)
23:26:01 <lispy> quines are foozles! ;)
23:26:03 <jcreigh> lispy: that's cheating. As is the "empty file" quine that works in some languages.
23:26:18 <Botty> and here I thought that lisp was whitespace agnostic
23:27:48 <Heffalump> jcreigh: ok, so suppose x = show (eval [] x)
23:27:56 <Heffalump> how do you actually make a quine?
23:29:31 <jcreigh> Heffalump: what do you mean? I was joking about fix eval actually finding a quine...
23:30:39 <Heffalump> ah :-)
23:30:54 <Heffalump> oh, well, it finding one and a fixpoint giving you one are different matters
23:37:59 <jcreigh> > printf "%08x" 1234
23:38:00 <lambdabot>  Add a type signature
23:38:43 <lispy> > printf "%08x" (1234:Int)
23:38:44 <lambdabot>  Not in scope: data constructor `Int'
23:38:46 <lispy> > printf "%08x" (1234::Int)
23:38:47 <lambdabot>  Add a type signature
23:38:49 <dons> result type too
23:38:51 <lispy> hmm...
23:38:59 <lispy> > printf "%08x" (1234::Int) :: String
23:39:00 <lambdabot>  "000004d2"
23:39:02 <dons> > printf "%s" "foo" :: String -- sprintf
23:39:04 <lambdabot>  "foo"
23:39:12 <dons> > printf "%s" "foo" :: IO () -- printf
23:39:14 <lambdabot>  <IO ()>
23:39:42 <lispy> > printf "%08x" 1234 :: String
23:39:42 <lambdabot>  Add a type signature
23:39:50 <Heffalump> @type printf
23:39:51 <lispy> so both type signatures are needed in mine
23:39:52 <lambdabot> forall r. (PrintfType r) => String -> r
23:40:00 <dons> > printf "%08x%s" (42 :: Int) "foo" :: String -- an constrain to which integer instance
23:40:02 <lambdabot>  "0000002afoo"
23:40:27 <Heffalump> > printf "%d" :: Int -> String
23:40:28 <lambdabot>  <Int -> [Char]>
23:40:45 <dons> since there's no instance Num-poly instance:
23:40:45 <dons> instance PrintfArg Int where
23:40:45 <dons>     toUPrintf i = UInt i
23:40:45 <dons> instance PrintfArg Integer where
23:40:45 <dons>     toUPrintf i = UInteger i
23:40:57 <dons> (maybe there could be , given some -fglasgow-exts)
23:42:07 <jcreigh> > let s = "let s = %s in printf s (show s)" in printf s (show s) :: String
23:42:08 <lambdabot>  "let s = \"let s = %s in printf s (show s)\" in printf s (show s)"
23:43:08 <dons> almost
23:43:22 <jcreigh> oh, missing :: String, right?
23:43:57 <jcreigh> > let s = "let s = %s in printf s (show s) :: String" in printf s (show s) :: String
23:43:59 <lambdabot>  "let s = \"let s = %s in printf s (show s) :: String\" in printf s (show s) ...
23:44:03 <jcreigh> gah
23:44:19 <jcreigh> well, it works in ghci. :)
23:46:46 * Botty wonders why ./configure and ./build on lambdabot trigger "Permission denied"
23:47:18 <dons> chmod +x build
23:47:20 <dons> ./build
23:48:03 <Botty> ah, thanks
23:48:43 * Botty also wonders why darcs dls all the patches and not just pristine
23:50:15 <dons> you didn't use --partial ?
23:54:44 <Botty> dons - no, i did
23:54:58 <Botty> Copying patch 283 of 283... done!
23:54:58 <Botty> Applying patch 282 of 282... done.
23:55:08 <Botty> Maybe i misinterpreted the meaning of that bit
23:55:23 <dons> yeah, that looks fine
