00:10:24 <goltrpoat> oh hmm.  http://www.jetbrains.net/confluence/display/MPS/Epigram
00:10:27 <lambdabot> Title: Epigram - JetBrains.net, http://tinyurl.com/wjfcq
00:10:47 <goltrpoat> at least i get to not use emacs.
00:10:58 <Itkovian> meuning
00:12:05 <goltrpoat> was that "morning" with a new jersey accent and a german spelling?
00:12:05 <goltrpoat> hehe
00:18:04 <therp> funny, I just had a chat over a cup of tea about epigram yesterday.. now I hear it for the second time in my life in 12 hours..
00:30:23 <Itkovian> goltrpoat: actually, it's more a french accent, at least according to 'allo 'allo :-)
00:34:56 <kzm> @hoogle (><)
00:34:57 <lambdabot> Did you mean: (><)
00:34:57 <lambdabot> Prelude.undefined :: a
00:34:57 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
00:35:19 <kzm> actually; I suppose I did mean that.
00:35:28 <kzm> @type (><)
00:35:29 <lambdabot> Not in scope: `><'
00:36:12 <bringert> kzm: what is it supposed to be?
00:36:12 <lambdabot> bringert: You have 1 new message. '/msg lambdabot @messages' to read it.
00:36:28 <kzm> maps two functions to a tuple, it seems.
00:36:45 <goltrpoat> @hoogle ><
00:36:46 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
00:36:47 <kzm> > :t (><)
00:36:48 <kzm> (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
00:36:48 <lambdabot>  Parse error
00:36:59 <kzm> Ah, right.
00:37:04 <kzm> No parens, then.
00:37:07 <goltrpoat> hoogle gets confused by the parentheses
00:37:08 <goltrpoat> yeah
00:37:23 <kzm> Looking at Jon Fairbairn's bwt challenge.
00:37:46 <kzm> It seems we can make things more efficient by sorting the tails and use the heads for the bwt.
00:37:48 <bringert> dons: sweet! (re the PDF example)
00:38:26 <kzm> bringert, if you don't mind my asking:  PDF example?
00:39:00 <bringert> kzm: the PDF edition of Haskell Weekyl News has a new experimental layout: http://www.cse.unsw.edu.au/~dons/tmp/20061114.pdf
00:39:02 <lambdabot> http://tinyurl.com/y2jezz
00:39:09 <bringert> eh, Weekly
00:40:05 <bringert> dons: maybe the slogan should be a footer?
00:40:26 <kzm> Nice!
00:44:04 <Itkovian> I second that
00:46:25 <mwc> I third it...
00:46:28 <mwc> what did I just third?
00:51:13 <araujo> helo!
00:52:30 <jeffz> hi, in http://www.haskell.org/~pairwise/intro/section3.html http://www.cs.uu.nl/%7Eafie/haskell/tourofsyntax.html is broken (404), possible alternate: http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html
00:52:32 <kolmodin> morning araujo
00:52:32 <lambdabot> Title: Haskell for C Programmers, http://tinyurl.com/yklpdo
01:01:07 <kzm> How hard is it to make a cyclic ByteString, I wonder?
01:02:47 <kolmodin> kzm: you could make a cyclic lazy bytestring
01:03:51 <kzm> kolmodin, I think I'd just use a regular one, and have an indexing operator using `mod`.  That should work for negative indices as well (or is that `quot`?)
01:04:58 <kolmodin> oh, there is already a Lazy.cycle
01:05:20 <kzm> Hmm.. guess I'll have to check that.
01:12:41 <mwc> > map (`mod` 10) [-10..10]
01:12:42 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0]
01:12:58 <mwc> > map (`quot` 10) [-10..10]
01:13:00 <lambdabot>  [-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1]
01:13:11 <mwc> > map (`rem` 10) [-10..10]
01:13:12 <lambdabot>  [0,-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,0]
01:14:31 <mwc> On a related note, I'd like to complain about the lack of something like properFraction with mod/div behaviour (towards negative infinity)
01:15:23 <mwc> > properFraction -1.5 -- I want (-2,0.5)
01:15:24 <lambdabot>  add an instance declaration for (Fractional (a -> (b, a)))
01:15:38 <Eidolos> > splitAt 3 [1..5]
01:15:39 <lambdabot>  ([1,2,3],[4,5])
01:16:06 <Eidolos> > 3 `splitAt` [1..5]
01:16:07 <lambdabot>  ([1,2,3],[4,5])
01:16:20 <Eidolos> > [1..5] `splitAt` 3
01:16:21 <lambdabot>  Couldn't match `Int' against `[a]'
01:16:26 <Eidolos> aw fine :)
01:18:08 <mwc> That's always amused me about `` notation. splitAt 3 [1..5] seems to be well named, splitAt 3 is a function splitting at the third element. But 3 `splitAt`  [1..5] looks wrong
01:24:42 <bringert> maybe there should be another notation for infixed flipped functions?
01:26:22 <Excedrin> does GHCi implement an interpreter?
01:27:12 <mwc> bringert, I think so, but then again, too much syntactic sugar rots the brain.
01:27:36 <mwc> Excedrin, yeah, it's sort an interpreter. I'd rather call it an interactive toplevel.
01:27:59 <mwc> Interpreters to me conjure up batch systems that execute code and halt.
01:29:52 <Excedrin> openmcl's repl is like: read, compile, execute, print, loop
01:30:51 <Excedrin> I think of Hugs as an interpreter and ghc as a compiler (based on the 'c' in the name, and that it does that whole source to source transformation thing), so I was curious if it worked more like openmcl or more like hugs
01:31:23 <mwc> I think it's compiled to one of the intermediate stages
01:31:43 <Excedrin> ok that makes sense, thanks
01:32:06 <mwc> That's my understanding, but I'm not a ghc hacker
01:34:05 <Excedrin> also, neat, a couple people have looked at my ladder stuff, I hope it's useful
01:34:18 <dons> bringert: want to send me the footer patch? :)
01:34:30 <dons> oh, i should put it into tdarcs first
01:52:10 <robreim> ?status hs-plugins
01:52:10 <lambdabot> Unknown command, try @list
02:10:08 <dons> robreim: ack.
02:23:15 <dblhelix> @seen SyntaxNinja
02:23:15 <lambdabot> I saw SyntaxNinja leaving #haskell and #darcs 1d 4h 52m 6s ago, and .
02:23:35 <dancor> what is the idiomatic way to do a list slice
02:24:22 <mauke> drop, take
02:24:49 <dblhelix> splitAt
02:24:53 <dblhelix> @type splitAt
02:24:55 <lambdabot> forall a. Int -> [a] -> ([a], [a])
02:25:10 <dblhelix> > splitAt 5 [1..10]
02:25:11 <lambdabot>  ([1,2,3,4,5],[6,7,8,9,10])
02:25:26 <dblhelix> > take 5 [1..10]
02:25:27 <lambdabot>  [1,2,3,4,5]
02:25:34 <dancor> > splitAt 5 (map (* 2) [1..10])
02:25:36 <dblhelix> > drop 5 [1..10]
02:25:36 <lambdabot>  ([2,4,6,8,10],[12,14,16,18,20])
02:25:37 <lambdabot>  [6,7,8,9,10]
02:25:49 <psykotic> > let slice m n = take (n - m) . drop m in slice 5 10 [1..]
02:25:51 <lambdabot>  [6,7,8,9,10]
02:26:24 <psykotic> (actually that's probably off-by-1 from what you want)
02:26:40 <dblhelix> @bs
02:26:41 <lambdabot> Done.
02:32:42 <opqdonut> @help bs
02:32:43 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:36:07 <therp> hm type synonyms are not subject to export/import?
02:36:31 <dons> sure they are.
02:37:09 <dons> not as T(..) though, iirc
02:38:01 <therp> ah, I was confused for a second. the problem source is circular imports
02:39:10 <mlh> mlh_: you stink
02:39:19 <opqdonut> ok
02:39:21 <opqdonut> gtk
03:00:27 <therp> hm, is there any other way to get rid of circular imports than stuffing all things in a single module? that seems wrong
03:01:44 <Pastorn> have a "main" module that imports all and that never needs to be imported
03:01:47 <Pastorn> or something
03:03:51 <therp> how would adding a 3rd module cut the circle?
03:04:37 <Pastorn> move your functions around a little.. that's what i did to solve that problem
03:09:35 <therp> I found a solution, but it seems utterly wrong. but well, I'm in hack mode now; code cleanup is ok after making profits.
03:12:44 <Pastorn> therp: what are you making?
03:13:02 <therp> pastorn: I'm hacking on GHC
03:13:30 <therp> so any associated profits are immaterial...
03:14:30 <Pastorn> :)
03:33:01 <dancor> is there a way to 'import Data.Map' but have 'map' mean 'GHC.Base.map' and not get an ambiguity error
03:33:39 <int-e> import Data.Map hiding (map)
03:34:10 <roconnor> Data.Map is intended to be imported qualified
03:34:12 <int-e> but generally it seems to be better to import Data.Map qualified,  import qualified Data.Map as M   (or Map)
03:34:21 <roconnor> import Data.Map as M
03:34:32 <roconnor> like int-e says
03:35:06 <int-e> and then use M.map and so on.
03:49:46 <earthy> what's the right wiki these days? haskellwiki or hawiki?
03:50:36 <Igloo> haskellwiki
03:50:40 <earthy> good. :)
03:50:55 <therp> I wonder why .hs-boot files in GHC exist.. to break up circular imports? It seems so
03:51:10 <Igloo> yes
03:51:35 <therp> igloo: and {-# SOURCE #-} in the import directive is use to referr to the boot file right?
03:52:11 <Igloo> yup
03:54:09 <therp> igloo: is there a way to generate these boot files? because they don't look that complicated
03:54:51 <Igloo> Just copy the bits you need out of the .hs file
03:54:52 <therp> hm, also I wonder is this techniques only used in GHC? I can't find a reference to the SOURCE pragma..
03:55:05 <therp> at least none in the GHC users manual
03:55:15 <Igloo> It's much nicer if you can avoid circular imports IMO, incidentally
03:56:17 <Igloo> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion talks about it, but it ought to be in the pragmas section too
03:56:20 <lambdabot> Title: 4.6. Filenames and separate compilation, http://tinyurl.com/yyunf2
03:56:33 <therp> thanks
04:20:56 <mwc> It looks to me like .hs-boot files could be (nearly) automagically generated
04:25:24 <kzm> Is there any default function to print a timestamp?
04:25:42 <dons> ?hoogle cpuTime
04:25:43 <lambdabot> CPUTime :: module
04:25:43 <lambdabot> CPUTime.cpuTimePrecision :: Integer
04:25:43 <lambdabot> CPUTime.getCPUTime :: IO Integer
04:25:48 <dons> perhaps/
04:25:56 <kzm> Thanks, will check.
04:33:19 <dons> ?users
04:33:19 <lambdabot> Maximum users seen in #haskell: 276, currently: 253 (91.7%), active: 17 (6.7%)
04:36:51 <bringert> dons: the PDF looks really good
04:37:06 <bringert> I have posted your prototype outside my office
04:37:36 <bringert> dons: thank you for all your work on HWN!
04:40:21 <boegel> bringert: are you the new HWN editor?
04:40:40 <bringert> no no
04:40:57 <bringert> boegel: I didn't mean that dons' work was over
04:41:30 <bringert> I just meant:
04:41:32 <bringert> dons++
04:41:34 <boegel> bringert: oh, ok... dons: how many entries do you have for the new HWN?
04:41:35 <Itkovian> no, dons does a good job, he can keep it
04:41:38 <boegel> @karma+ dons
04:41:38 <lambdabot> dons's karma raised to 92.
04:41:45 <boegel> w0w!
04:41:57 <Itkovian> when do we have to bow before we talk to him?
04:42:00 <Itkovian> at 100?
04:42:22 <kzm> There should at least be a free T-shirt or something.
04:42:35 <bringert> Itkovian: shouldn't that depend on the karma difference?
04:42:40 <mauke> @hoogle (Num a) => a -> Double
04:42:41 <lambdabot> No matches, try a more general search
04:42:45 <bringert> @karma bringert
04:42:45 <lambdabot> You have a karma of 17
04:42:49 <Itkovian> @karma Itkovian
04:42:49 <lambdabot> You have a karma of 0
04:42:52 <Itkovian> heh
04:42:58 <mwc> @karma mwc
04:42:58 <lambdabot> You have a karma of -1
04:42:59 <kzm> I think we should have fractional karmas.
04:43:00 <mwc> HAHA
04:43:13 <Itkovian> shit he beat us to it
04:43:17 <cjay> complex karmas!
04:43:22 <kzm> Or perhaps karma could be a partial order?
04:43:31 <kzm> Having a total order is clearly overspecifying things.
04:43:35 <Itkovian> kzm: yes, such that we always get smaller increments as we approach dons' karma
04:43:41 <mwc> Hyperreal karmas?
04:43:48 <Itkovian> imaginary ones
04:43:49 <mwc> Itkovian, karma dilation?
04:44:04 <kzm> Or use a ladder approach, like chess tournaments.  So that karma increments from people with more karma than you counts more?
04:44:11 <mwc> Itkovian, I tried to hack lambdabot on a lark :)
04:44:23 <kzm> @rank
04:44:24 <lambdabot> Maybe you meant: ask run
04:44:36 <kzm> Maybe I did, maybe Nothing.
04:45:00 <Itkovian> She can be a pain in the Gonads
04:48:01 <boegel> @vixen do you like Itkovian?
04:48:01 <lambdabot> sure, i definitely don't hate
04:48:12 <boegel> well, not hating is good, I guess :P
04:48:37 <Itkovian> it's a start
05:07:44 <kzm> Hmm... wasn't there some natural language work done in Haskell?
05:08:11 <norpan> tokigt
05:08:37 <kzm> hva er tokigt?
05:09:18 <norpan> jag vet inte
05:12:51 <dcoutts> mwc, btw, about the c2hs heisenbug...
05:13:40 <dcoutts> mwc, it depends on whether __LDBL_COMPAT is defined
05:13:46 <dcoutts> #ifdef __LDBL_COMPAT
05:13:46 <dcoutts> # include <bits/libio-ldbl.h>
05:13:46 <dcoutts> #endif
05:14:14 <dcoutts> so it seems that on your and my system that's not defined, but on other people's systems it is apparently
05:16:20 <bringert> kzm: yes, GF for example
05:16:23 <bringert> @where GF
05:16:24 <lambdabot> http://www.cs.chalmers.se/~aarne/GF/
05:17:40 <bringert> kzm: also GenI http://wiki.loria.fr/wiki/GenI
05:22:23 <mwc> dcoutts, I think I'll just try to make c2hs compile a binding for a header I'll write with a typeof in it, and then from there we can get somebody with such a system to give it a shot
05:23:30 <dcoutts> or use c2hs --cppopts=-D__LDBL_COMPAT
05:24:02 <dcoutts> mwc, if you use a typeof in a header then you'll quickly see that your c2hs can't parse it.
05:24:33 <dcoutts> we know c2hs can't parse typeof, the variation between systems is just if the headers include typeof or not by default
05:24:47 <mwc> so my plan was to try and get that working in something less gnarly than glibc
05:24:52 <dcoutts> sure
05:25:03 <mwc> I assume that __typeof() is being expanded to typeof() somewhere
05:25:14 <dcoutts> a one line header should do
05:25:25 <mwc> I think that's how those GCC special keywords work, __inline, for instance
05:25:32 <dcoutts> mwc, I think gcc accepts __typeof directly
05:25:37 <dcoutts> oh, hmm
05:25:46 <mwc> just that I thought keywords hidden thatway had __ after the word as well
05:26:20 <ndm> dcoutts, do you think this is a good idea for the FilePath into base argument? http://haskell.org/haskellwiki/FilePath/Support
05:26:21 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
05:26:23 <lambdabot> Title: FilePath/Support - HaskellWiki, http://tinyurl.com/y6gkuv
05:27:13 <ndm> dcoutts, the obvious way - namely the same as for posix, i'll add a few examples though
05:27:30 <kzm> bringert, neat!
05:27:44 <dcoutts> mwc, in the gcc parser they have tokens for typeof, __typeof and __typeof__, similarly for inline and several other similar extensions
05:28:00 <dcoutts> mwc, I'm looking at gcc-3.4.6/gcc/c-parse.y
05:28:32 <mwc> http://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Alternate-Keywords.html#Alternate-Keywords
05:28:35 <lambdabot> Title: Alternate Keywords - Using the GNU Compiler Collection (GCC), http://tinyurl.com/yk52cw
05:28:38 <dcoutts> ndm, I'm not sure having a list of names is a good initial approach, it looks like a petition
05:28:39 <mwc> okay, I'll have a look as well
05:29:00 <mwc> defined alternate keywords use __foo__
05:29:01 <dcoutts> ndm, I think people should just email in reply to the proposal. I know I will.
05:29:15 <ndm> dcoutts, i suspect we'll need some way to keep track of how everyone feels - i am thinking the thread might get quite long...
05:29:50 <dcoutts> ndm, then feel free to keep a count, but I worry that it looks a little pushy to start that way.
05:30:03 <dcoutts> ndm, we need to give the dissenters a fair hearing
05:30:14 <ndm> dcoutts, good point - i'll probably maintain that as a document on my local copy, and then if needed show it out
05:30:24 <mauke> @hoogle (Enum a, Enum b) => a -> b
05:30:26 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
05:30:26 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
05:30:26 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
05:30:33 <mauke> bah
05:30:37 <ndm> dcoutts, i agree - that was also one of the ideas behind it - to give disentters a chance to say so, and say what their reasons are
05:31:18 <xerox> ?type toEnum . fromEnum
05:31:19 <lambdabot> forall a a1. (Enum a, Enum a1) => a1 -> a
05:31:41 <dcoutts> ndm, my point is that it should be too personal
05:31:52 <dcoutts> erm, shouldn't
05:31:59 <ndm> dcoutts, fair enough, i've taken it down
05:32:12 <dcoutts> ndm, but reasons are a good thing!
05:32:27 <dcoutts> ndm, sorry if I wasn't clear
05:32:59 <dcoutts> ndm, so we should try to fairly summarise the reasons for and against
05:33:10 <dcoutts> ndm, I've got a couple reasons for
05:33:15 <ndm> dcoutts, nope - that was what i wanted to check, that it wasn't too much like holding a vote/signing a petition
05:33:25 <dcoutts> ndm, right, ok
05:34:23 <ndm> i intend to propose it tomorrow, to give people a chance to comment on teh library today - although i think most people are satisfied with it
05:34:43 <dcoutts> ndm, ok great. Yeah I'm pretty happy.
05:34:44 <ndm> dcoutts - what are your reasons for supporting it?
05:35:08 <dcoutts> ndm, well one reason for it going into base rather than a separate lib is so Setup.hs scripts can use it
05:35:50 <dcoutts> ndm, Setup.hs scripts are not allowed to use anything outside of base and Cabal, since otherwise we can't even guarantee that we can compile them.
05:36:10 <dcoutts> ndm, and we could remove our version from Cabal
05:36:24 <ndm> that would be nice
05:36:40 <dcoutts> indeed it would
05:36:47 <dcoutts> I like the </> operator :-)
05:37:43 <ndm> yeah, darcs has that too, so i followed their lead
05:37:54 <dcoutts> ndm, the fact that you've put so much effort into the properties partially counteracts the "mere string munging" arguments.
05:38:12 <dcoutts> a 'proper' FilePath adt would need similar properties
05:39:22 <earthy> would calling 'runghc Setup.hs build' as a make command be sensible?
05:39:24 <ndm> yep, thats a good one
05:39:28 <dcoutts> ndm, though of course the main argument is that Haskell98 specifies type FilePath = String
05:39:42 <earthy> now we're on the topic of cabal anyway... ;)
05:39:50 <dcoutts> and so until someone fixes that for Haskell' or Haskell2 then we should make it as useful as possible.
05:39:52 <ndm> earthy: the dependancies would not be calculated, so you'd basically just have a shell script
05:40:30 <earthy> ndm: this would be used from vim, using the :make command in vim
05:40:50 <Igloo> ndm: What's the reason for putting filepath into base?
05:40:51 <earthy> so basically all you want is the shell script that does the build (and possibly returns bunches of errors)
05:41:08 <ndm> Igloo: so you can use it in Cabal Setup's
05:41:18 <dcoutts> Igloo, lots of things need it, we can't use it in Setup.hs without doing that.
05:41:31 <ndm> Igloo: and its a small thing, otherwise people will be tempted to "string hack" on their own, which invariably breaks in weird circumstances
05:41:39 <Igloo> Why can't we use it in Setup.hs?
05:41:40 <dcoutts> Igloo, and we already have lots of Dir/File ops in base
05:41:55 <dcoutts> Igloo, Setup.hs may only use the base and Cabal packages
05:42:02 <Igloo> Why?
05:42:03 <ndm> most people will do reverse . dropWhile (/= '.') . reverse instead of dropExtentsion, if thats their only use
05:42:10 <dcoutts> Igloo, since otherwise we can't even compile Setup.hs!
05:42:23 <ndm> unfortunately folder.ext\file will totally go wrong
05:42:27 <ndm> (hat does this!)
05:42:31 <Igloo> ghc --make will work, and hugs will work AFAIK. What doesn't work?
05:42:44 <dcoutts> Igloo, suppose I don't have the filepath package installed yet? How do I build a Setup.hs that uses the package ?
05:42:55 <Igloo> dcoutts: That's an argument for making it a core library
05:43:10 <earthy> file path handling should be a core lib, imho
05:43:22 * Igloo isn't arguing it shouldn't be
05:43:27 <earthy> dcoutts is. :)
05:43:30 <dcoutts> Igloo, perhaps it is, at the same time you can pull out the System.Directory etc too
05:43:33 <Igloo> (although I haven't actually looked at the library)
05:43:52 <ndm> i think it belongs in the base we have now
05:44:04 <ndm> and belongs outside once base is the compiler specific bits
05:44:15 <ndm> things like Data.Map have absolutely no place in base, really
05:44:16 <Igloo> There's a bug about breaking base up. I don't think we should be stuffing more into it
05:44:19 <dcoutts> yes, if base is further split then FilePath would go with the other IO/file/dir bits
05:44:56 <ndm> FilePath i think is an exception, its not stuffing more in, its putting what should have really been there all along in - more papering over a hole
05:45:53 * dcoutts departs
06:09:32 <ndm> @tell dcoutts I've added some takeDirectory on Windows properties, if there are any other functions which are unclear just ask
06:09:32 <lambdabot> Consider it noted.
06:17:49 <gaal> hey, could someone remind me how to use cabalized packages with runghc?
06:18:40 <gaal> runghc --Xcabal-dir --Xcabalized-package MyMain.hs
06:19:12 <gaal> assuming the package is already built and registered in packages.conf in cabal-dir, what are the --Xes?
06:23:12 <xinming> Is there a way to refer lambda itself with lambda?
06:23:17 <xinming> within
06:23:59 <mauke> not directly
06:24:26 <LoganCapaldo> Y combinator? ;)
06:24:27 <mauke> > fix (\self n -> if n < 2 then 1 else n * self (n - 1)) 5
06:24:28 <lambdabot>  120
06:25:07 <xinming> mauke: So, we have to use fix function?
06:25:09 <xinming> thanks.
06:25:30 <LoganCapaldo> fix...point?
06:25:43 <mauke> xinming: or use "let" to give it a name
06:26:09 <mauke> > let foo n = if n < 2 then 1 else n * foo (n - 1) in foo 5
06:26:10 <lambdabot>  120
06:26:20 <xinming> thansk
06:45:39 <xinming> > let test = (\(x:xs) (y:ys) -> (x:y:[]) : test xs ys) in test "aaaa" "bbbb"
06:45:47 <lambdabot>  Non-exhaustive patterns in lambda
06:45:59 <xinming> hmm, How can I write case of here then?
06:46:22 <xinming> or, simply, I can't do that. :-)
06:46:50 <mauke> > let test (x:xs) (y:ys) = [x,y] : test xs ys in test "aaaa" "bbbb"
06:46:52 <lambdabot>  Non-exhaustive patterns in function test
06:46:53 <integral> yes, you can write case of there
06:47:16 <mauke> > let test (x:xs) (y:ys) = [x,y] : test xs ys; test [] _ = []; test _ [] = [] in test "aaaa" "bbbb"
06:47:17 <lambdabot>  ["ab","ab","ab","ab"]
06:47:22 <xinming> integral: hmm, I just wish to write some one liner... :-P
06:47:30 <xinming> within one clause.
06:48:03 <integral> > let test = (\a ~(y:ys) -> case a of { [] -> []; (x:xs) -> (x,y) : test xs ys }) in test "aaaa" "bbbb"
06:48:04 <lambdabot>  [('a','b'),('a','b'),('a','b'),('a','b')]
06:48:14 <integral> xinming: Like I just did?
06:48:45 <xinming> integral: hmm, thanks, the latter...
06:49:11 <integral> TBH, I'd just use Data.List.transpose
06:49:12 <xinming> what does ~(y:ys) mean there?
06:49:28 <integral> I'm not entirely sure, I just felt it was appropiate (... !)
06:50:53 <ndm> xinming: it means that the user is evil
06:51:26 <ndm> > case [] of {~(y:ys) -> error "haskell's semantics are broken" ; [] -> error "haskell's semantics are sensible"}
06:51:27 <lambdabot>  Add a type signature
06:51:44 <ndm> > (case [] of {~(y:ys) -> "haskell's semantics are broken" ; [] -> "haskell's semantics are sensible"}) :: String
06:51:46 <lambdabot>  "haskell's semantics are broken"
06:52:07 <integral> I just couldn't be bothered to write another case of :)
06:52:12 <ndm> xinming: it means match, even though you don't really match, delay the match until its needed
06:52:24 <ndm> integral: a let?
06:52:24 <xinming> ndm: thanks...
06:52:34 <integral> ndm: huh?
06:52:53 <ndm> > let test = (\a yys -> let (y:ys) = yys in case a of { [] -> []; (x:xs) -> (x,y) : test xs ys }) in test "aaaa" "bbbb"
06:52:55 <lambdabot>  [('a','b'),('a','b'),('a','b'),('a','b')]
06:53:08 <ndm> now thats semantically valid, and not that much longer
06:53:40 <integral> ah.
06:55:56 <xinming> let test = (\a ~(y:ys) -> case a of { [] -> []; (x:xs) -> x:y : test xs ys; } ) in test "aaaa" "bbbb"
06:56:06 <xinming> > let test = (\a ~(y:ys) -> case a of { [] -> []; (x:xs) -> x:y : test xs ys; } ) in test "aaaa" "bbbb"
06:56:07 <lambdabot>  "abababab"
06:56:21 <xinming> why won't the result be ["ab", "ab", "ab" , "ab"]
06:56:35 <xinming> I know, in some sense, they are idential....
06:56:39 <xinming> But... :-D
06:56:44 <opqdonut> no they aren't
06:57:25 <opqdonut> @t ["ab"]
06:57:26 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
06:57:35 <opqdonut> @type ["ab"]
06:57:37 <lambdabot> [[Char]]
06:57:45 <opqdonut> @type "ab"
06:57:46 <lambdabot> [Char]
06:58:03 <xinming> @type ["ab", "ab"]
06:58:05 <lambdabot> [[Char]]
06:58:45 <xinming> Ok, sorry, i think I know...
06:59:06 <xinming> cool.
06:59:53 <opqdonut> > foldr (++) "" ["ab","ab"]
06:59:55 <lambdabot>  "abab"
07:04:32 <dcoutts_> @seen dons
07:04:34 <lambdabot> dons is in #ghc, #haskell-overflow and #haskell. I last heard dons speak 49m 36s ago.
07:04:58 <dblhelix> shouldn't dons be sleeping?
07:05:31 <ndm> @localtime dons
07:05:32 <lambdabot> Local time for dons is Wed Nov 22 02:02:23 2006
07:05:41 <ndm> its only 2am
07:06:09 <dylan> trippy. ion3 does floating windows the same as dwm now.
07:06:38 <dcoutts_> dons, we've got the room, ah but I booked it 11-13th, hmm was 10-12th essential or should I go and fix it?
07:06:49 <dblhelix> ndm: yeah, you're right... dons is taking being a lazy programmer far too serious... only, 2am... why should he be sleeping?
07:07:28 <ndm> dblhelix: i am never in bed before 3, and typically get up about midday
07:07:44 <ndm> (apart from this morning when someone decided to start chainsawing at 8:30am...)
07:07:48 * dblhelix gets up at 5am :S
07:08:07 * dblhelix goes in at 10.30pm or so
07:08:14 <kiloboot> @localtime kiloboot
07:08:15 <lambdabot> Local time for kiloboot is Tue Nov 21 18:05:13 2006
07:08:34 <dcoutts_> dons, we will need to ask everyone to provide wired MAC addresses and anyone wanting power will need to have their laptop powerpack checked on the morning of the first day for electrical safety.
07:08:34 * ndm leaves to help undergrads with compiler theory
07:09:17 <dcoutts_> dons, but 20 is ok, but also a maximum for the room we'll be using.
07:12:11 <Igloo> dcoutts_: People will want 13th to travel to PADL
07:20:48 <dcoutts_> Igloo, hmm, ok perhaps I should go now and fix it.
07:31:52 <dcoutts_> Igloo, ah, we were confused anyway, we wern't looking at the calendar and said 10-12 as Thursday-Saturday when if course 10-12th is Wednesday to Friday. I've cc'ed you and dons on the email.
07:32:52 <dcoutts_> Igloo, we'll be using the library reading room, you know on floor 2, that longish room just outside the library.
07:32:58 <Igloo> Right
07:33:12 <dcoutts_> it will just take 20, and it's got plenty of tables we can move about
07:33:23 <dcoutts_> and there's plenty of power and ethernet ports
07:33:55 <dcoutts_> but all laptops will need Terry to do a safety test or they're not allowed to be plugged in
07:33:56 <Igloo> So the room is definitely booked for the right days?
07:34:03 <dcoutts_> Igloo, yes.
07:35:31 <dcoutts_> Igloo, though the room booking book hasn't actually been made yet, but Joe has it in her email so she'll add it once she starts the new book
07:35:43 <Igloo> Heh, OK
07:36:53 <dcoutts_> Igloo, so if Terry can confirm that he'll be around then we're ok. Otherwise everyone has to run their laptops on battery :-)
07:37:24 <Igloo> BYO diesel generator?  :-)
07:37:28 <dcoutts_> heh, yes
07:46:00 <glguy> is that like a bio-diesel generator?
07:46:01 <glguy> ;)
07:50:50 <dcoutts_> Igloo, how do I format a table on the wiki so it goes in it's own div. I want to get people to add their MAC addresses on the registration page.
07:51:19 <dcoutts_> currently it flows the text onto the same line which looks like ***
07:51:36 <Igloo> Do you mean paragraph?
07:51:45 <Igloo> If so, just a blank line before/after it should work
07:53:14 <dcoutts_> doesn't seem to work
07:53:35 <Igloo> Where is it?
07:56:59 <dcoutts_> Igloo, ok, I'll save the current state of my changes:
07:57:06 <dcoutts_> http://haskell.org/haskellwiki/Hac_2007/Registration
07:57:08 <lambdabot> Title: Hac 2007/Registration - HaskellWiki, http://tinyurl.com/yyf6zv
07:58:50 <Igloo> Ah, I've only tried tables in the trac wiki
08:00:28 <dcoutts_> Igloo, there's an example table on the libraries/guis page
08:03:17 <Igloo> dcoutts_: Remove the align's
08:04:10 <dcoutts_> Igloo, ah ok
08:04:36 <dcoutts_> I copied that from the wikipedia editing help :-)
08:08:13 <xinming> lisppaste2: url
08:08:13 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
08:08:46 <lisppaste2> xinming pasted "How can I shorten this code." at http://paste.lisp.org/display/30368
08:08:52 <xinming> :-P
08:09:09 <xinming> Just dup every character in a string.. I know my implementation is ugly. :-P
08:09:10 <xinming> thanks.
08:10:39 <sjanssen> > concatMap (\x -> [x, x]) "hello"
08:10:41 <lambdabot>  "hheelllloo"
08:10:51 <sjanssen> @pl (\x -> [x, x])
08:10:52 <lambdabot> ap (:) return
08:11:56 <sjanssen> > foldr (\x xs -> x:x:xs) [] "hello"
08:11:58 <lambdabot>  "hheelllloo"
08:12:07 <Pastorn> why not just \x:xs -> x:x:xs
08:12:07 <sjanssen> @pl (\x xs -> x:x:xs)
08:12:08 <lambdabot> liftM2 (.) (:) (:)
08:12:22 <sjanssen> ooh, I like that one
08:12:30 <Pastorn> that's \x:xs -> x:x:f xs
08:12:47 <sjanssen> > foldr (liftM2 (.) (:) (:)) [] "hello"
08:12:48 <lambdabot>  "hheelllloo"
08:12:49 <xinming> Ouch...
08:12:51 <xinming> thanks...
08:13:00 <xinming> I think I know... all types are just Char...
08:13:11 <Pastorn> @type liftM2
08:13:11 <xinming> So, no need to use [x, x]
08:13:12 <eviltwin_b> is it me or is ap (:) return directly usable with mplus?
08:13:12 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
08:13:19 <Pastorn> wicked
08:13:25 <eviltwin_b> wait, no, >>=
08:13:27 <sjanssen> xinming: you should probably avoid the liftM2 version
08:13:29 <Pastorn> and no concat
08:13:49 <xinming> BTW, How about adding a count?
08:14:03 <sjanssen> xinming: what do you mean, specifically?
08:14:22 <xinming> hmm, add a count on repeat time over each char.
08:14:58 <pkhuong> > (>>= take 3 $ repeat) "hello"
08:14:59 <lambdabot>    The operator `>>=' [infixl 1] of a section
08:14:59 <lambdabot>     must have lower prece...
08:15:18 <sjanssen> > let dup n xs = concatMap (replicate n) xs in dup 4 "hello"
08:15:19 <lambdabot>  "hhhheeeelllllllloooo"
08:15:38 <Pastorn> annoted...
08:15:45 <lisppaste2> Pastorn annotated #30368 with "edited..." at http://paste.lisp.org/display/30368#1
08:16:09 <xinming> cool...
08:16:20 <sjanssen> Pastorn: it's generally considered better style to use a HOF in cases like this
08:16:26 <sjanssen> so concatMap or foldr
08:16:38 <xinming> but I don't understand them... >_<
08:16:39 <Pastorn> sjanssen: HOF?
08:16:49 <xinming> but thanks anyway,
08:16:51 <sjanssen> Pastorn: higher order function
08:17:02 * xinming goes to read the documentation on concatMap.
08:17:26 <Pastorn> yeah... what about map?
08:17:27 <sjanssen> xinming: it's easy.  concatMap f xs = concat (map f xs)
08:18:07 <Pastorn> map (\x -> x:x) "wold"
08:18:15 <Pastorn> *word*
08:18:20 <sjanssen> Pastorn: that isn't well typed
08:18:24 <sjanssen> @type (:)
08:18:30 <lambdabot> forall a. a -> [a] -> [a]
08:18:39 <xinming> thanks
08:19:17 <eviltwin_b> @index ap
08:19:18 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
08:19:18 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
08:25:48 <Pastorn> ximning: still there
08:26:22 <Pastorn> ?
08:27:42 <xinming> Pastorn: yes, I am,
08:28:00 <xinming> Just go and read haskell tutorial. :-P
08:28:24 <Pastorn> xinming: join #i-like-hof
08:29:20 <sjanssen> @type \l -> GHC.Base.build (\c n -> foldr (\x xs -> x `c` (x `c` xs)) n l)
08:29:22 <lambdabot> forall a. [a] -> [a]
08:29:33 <sjanssen> and there is a version that takes advantage of GHC's list fusion
08:31:45 * shapr awakens
08:31:52 <glguy> I wonder if Microsoft actually had to summon Balthazor, Lord of the Lawyers, and bound him in a Redmond crypt so that they could come up with , and execute their "open sores" slight of hand trick
08:37:56 <sjanssen> @quote
08:37:57 <lambdabot> sebazzz says: <sebazzz> vos no te diste cuenta, pero cuando estas en pedo, y si yo estoy, te saco del alcanse todo objeto contundente
08:38:29 <Syzygy-> ...
08:38:49 <glguy> ?babel es en vos no te diste cuenta, pero cuando estas en pedo, y si yo estoy, te saco del alcanse todo objeto contundente
08:39:03 <lambdabot>  vos you did not realize, but when these in pedo, and if I am, I remove from alcanse all forceful object to you
08:39:45 <sjanssen> @quote
08:39:46 <lambdabot> astrolabe says: I put my thing in inverted commas because it isn't a really stalactite, but it looks like one, and contains nitrates from urea.
08:40:21 <dblhelix> @seen SyntaxNinja
08:40:22 <lambdabot> I saw SyntaxNinja leaving #haskell and #darcs 1d 11h 8m 59s ago, and .
08:44:15 <alexj__> @seen Musasabi
08:44:16 <lambdabot> Musasabi is in #ghc, #haskell-overflow, #haskell-blah and #haskell. I don't know when Musasabi last spoke.
08:55:28 <durdn> hi all, I have another newbie question :)
08:55:40 <durdn> this is puzzling me
08:56:05 <opqdonut> just ask
08:56:06 <durdn> i have a load function
08:56:07 <durdn> load             :: String -> IO Diary
08:56:07 <durdn> load fname = do fromHandle <- openFile fname ReadMode
08:56:07 <durdn>                 contents <- hGetContents fromHandle
08:56:07 <durdn> --                putStrLn contents
08:56:07 <durdn>                 hClose fromHandle
08:56:09 <durdn>                 return (readDiary contents)
08:56:15 <durdn> if I remove the putStrLn everything works
08:56:20 <opqdonut> please paste in the pastebin
08:56:25 <opqdonut> @where pb
08:56:25 <lambdabot> I know nothing about pb.
08:56:28 <opqdonut> @where paste
08:56:29 <lambdabot> http://paste.lisp.org/new/haskell
08:56:32 <durdn> ok sorry :)
08:57:00 <bringert> durdn: what happens when you have the putStrLn
08:57:41 <durdn> bringert: then the function returns []
08:57:56 <bringert> durdn: btw, you could write that function as load = liftM readDiary . readFile
08:58:24 <durdn> yep still have to get used to write things better
08:58:35 <durdn> anyway without the putStrLn I get
08:58:36 <durdn> *HStats> load "test.txt"
08:58:36 <durdn> []
08:58:40 <lispy> ndm: okay, i've waited a week, was I supposed to see a big yhc release now?
08:58:57 <bringert> durdn: do you modify the file after calling load?
08:58:58 <lispy> ndm: (because i haven't seen any announcements)
08:59:09 <durdn> if I uncomment the putStrLn it reads the stuff perfectly
08:59:30 <bringert> hGetContents and readFile read lazyily, and the putStrLn forces contents to be evaluated, which forces the read
08:59:42 <lisppaste2> durdn pasted "puzzling behaviour" at http://paste.lisp.org/display/30376
09:00:01 <bringert> if something happens to the file before you force evaluation of the contents, you can get weird behavior
09:00:08 <durdn> bringert: that must be it
09:00:32 <durdn> bringert: so my next question is how do I force the evaluation ?
09:00:58 <lispy> durdn: the standard ways are to request the length of the input
09:01:33 <lispy> durdn: for example, do c <- getContents; evaluate $ length c
09:01:46 <lispy> ?hoogle evaluate
09:01:47 <lambdabot> Control.Exception.evaluate :: a -> IO a
09:01:47 <lambdabot> Test.QuickCheck.evaluate :: Testable a => a -> Gen Result
09:01:57 <lispy> you want the one from Control.Exception
09:02:07 <Pastorn> what's the name for doing something like changing from (a -> b -> c) to (b -> a -> c)
09:02:09 <durdn> perfect
09:02:14 <lispy> or you could write do c <- getContents; seq (length c) (return ())
09:02:28 <opqdonut> Pastorn: flip
09:02:30 <lispy> Pastorn: flip?
09:02:34 <Pastorn> danke
09:02:34 <opqdonut> ?hoogle flip
09:02:35 <lispy> ?type flip
09:02:35 <durdn> will try with evaluate, thanks a lot bringert and lispy
09:02:36 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
09:02:37 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
09:02:38 <Ontolog> ?paste
09:02:42 <lambdabot> http://paste.lisp.org/new/haskell
09:03:51 <lispy> durdn: i just wish we had strict versions of those getContents functions, but afaik we don't
09:04:19 <lisppaste2> Ontolog pasted "Trouble getting treeFold right" at http://paste.lisp.org/display/30377
09:04:22 <araujo> hi!
09:04:29 <lispy> araujo: hi
09:04:39 <durdn> lispy: no worries, it's just that I am still in the first mind bending phase of getting Haskell ;)
09:05:00 <glguy> Does anyone know what the status of Gtk2Hs on GHC 6.6 is?
09:05:10 <lispy> durdn: right, and i think anyone that has tried to really use getContents hase been stumped by this behavior...
09:05:20 <lispy> durdn: which tells me it's broken :)
09:05:22 <glguy> in the works? not possible due to major technical hang up?
09:05:37 <durdn> lispy: evaluate worked like a charm !
09:05:47 <lispy> glguy: dcoutts is probably the only one around here who knows
09:05:50 <lispy> durdn: cool!
09:05:58 <durdn> lispy: thanks ! :D
09:06:01 <glguy> ?seen dcoutts
09:06:01 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts speak 3h 20m 1s ago.
09:07:28 <araujo> hello lispy !
09:07:31 <dozer> is there a way to re-write this cleanly?
09:07:42 <dozer> \(a', _) -> a == a'
09:08:08 <dozer> perhaps something like: #1 . (==)
09:08:10 <dozer> ?
09:08:12 <opqdonut> dozer: (==a)
09:08:18 <opqdonut> i'd guess
09:08:38 <opqdonut> yep, that's what you want probably
09:08:39 <lispy> ?pl \(a', _) -> a == a'
09:08:40 <lambdabot> (a ==) . fst
09:08:56 <lispy> or just ask lambdabot how to simplify it :)
09:09:05 <opqdonut> :)
09:09:07 <dozer> lol
09:09:20 <dozer> map snd $ filter ((a ==) . fst)
09:09:33 <Ontolog> hello
09:09:40 <dozer> so this is meant to pull out all the 2nd elements where the first element is a - yes?
09:09:42 <Ontolog> I need help with a haskell code
09:09:53 <psnl> Ontolog: homework?
09:09:59 <Ontolog> it is for your displayment here http://paste.lisp.org/display/30377
09:10:05 <Ontolog> no i am study of independent
09:10:19 <glguy> What expression are we golfing?
09:10:23 <Ontolog> it is hobby for me to stufy of independent haskell
09:10:27 <opqdonut> dozer: won't lookup do what you want?
09:10:42 <opqdonut> ?hoogle lookup
09:10:43 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
09:10:43 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
09:10:43 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
09:10:44 <lispy> but lookup only does the first match
09:10:45 <glguy> dozer: [y | (x,y) <- xs, a == x]
09:10:54 <opqdonut> lispy: point
09:11:09 <dozer> glguy - that looks like it, thanks
09:11:51 <psnl> Ontolog: written some lisp?
09:11:55 <lispy> list comps. are a good replacement for filter as they are often easier to read
09:12:27 <glguy> I use list comprehensions when dealing with tuples a lot because all of the fsts and snds start to hide the intention
09:12:41 <dozer> hell yeah, that looks clean now that it's in place
09:12:42 <glguy> intent*
09:12:55 * glguy wonders
09:12:55 <lispy> right, and if you use bigger tuples you have to write fst and snd anyway
09:13:16 <glguy> > [x | (1,x) <- [(2,3),(1,2)]]
09:13:17 <lambdabot>  [2]
09:13:18 <Ontolog> hello
09:13:18 <dozer> I got fed up today, so I thought I'd have a go at writing a petri-net simulator
09:13:31 <dozer> lots of dingling about with two-color graph structures
09:13:35 <Ontolog> has anyone have help me with my code pastings http://paste.lisp.org/display/30377
09:13:49 <lispy> Ontolog: i need to hurry on to work :9
09:13:52 <lispy> er :(
09:14:13 <Ontolog> nobody knows how to make this code a good function?
09:14:20 <glguy> Ontolog: what code?
09:14:24 <Ontolog> http://paste.lisp.org/display/30377
09:14:35 <Ontolog> listFold function needs the good code for make work
09:15:20 <glguy> Ontolog: it woudl be simpler to deal with if Leaf nodes held no data
09:15:36 <Ontolog> but this is how the exercise makes it
09:15:47 <dozer> I'd add lots of debug print statements and see where it is going wrong, but that's my approach to debuging any program that runs but does the wrong thing
09:15:47 <glguy> that's a shame :(
09:15:48 <Ontolog> i am using the "yet another haskell tutorial"
09:16:29 <dozer> @hoogle trace
09:16:30 <lambdabot> Debug.Trace.trace :: String -> a -> a
09:16:31 <lambdabot> Debug.Trace :: module
09:16:31 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
09:16:31 <Ontolog> yes it is shame no good code can be have for function
09:16:52 <glguy> english as second language?
09:16:57 <dozer> you want the first of those - wrap a bit of your function in trace with a message to get stuff printed out
09:17:10 <Ontolog> yes i speak english as my secondary of language
09:17:13 <glguy> Ontolog: I think I know
09:17:48 <glguy> Ontolog: by including the 'c' in both the left and right folds
09:17:53 <glguy> and then adding them together
09:17:57 <glguy> you are doubling C
09:18:29 <Ontolog> yes i think you have correct however i do not own the idea for fix trouble
09:18:46 * Ontolog is from glorious nation http://en.wikipedia.org/wiki/Kazakstan
09:19:27 <glguy> I find the Borat comedy to be tasteless, so I hope you aren't attempting to play off of that
09:19:56 <Ontolog> i have hear about this borat make funny at my country
09:20:31 <sek> there's something strange going on with something im running. whats the pastebin?
09:20:38 <Ontolog> ?paste
09:20:39 <lambdabot> http://paste.lisp.org/new/haskell
09:21:11 <lisppaste2> sek pasted "problem" at http://paste.lisp.org/display/30378
09:22:13 <glguy> sek: what is your problem
09:22:14 <sek> maybe im being stupid but that seams obsurd to me
09:22:23 <newsham> > multgroupelems 1987
09:22:24 <lambdabot>  Not in scope: `multgroupelems'
09:22:35 <glguy> *Main> (multgroupelems 1987) == [1..1986]
09:22:35 <glguy> True
09:23:10 <sek> if you're interested its multgroupelems n = [ x | x<-[1..(n-1)], (gcd x n) == 1]
09:23:20 <sek> but that shouldnt really matter as that test returns true
09:23:47 <glguy> > let f n = [ x | x<-[1..(n-1)], (gcd x n) == 1]
09:23:48 <lambdabot>  Parse error
09:24:02 <glguy> > let f n = [ x | x<-[1..(n-1)], (gcd x n) == 1] in f 1987 == [1..1986]
09:24:04 <lambdabot>  True
09:24:27 <glguy> > let f n = [ x | x<-[1..(n-1)], (gcd x n) == 1] in = [ x | x<-[1..(n-1)], (gcd x n) == 1]
09:24:28 <lambdabot>  Parse error
09:24:48 <sek> > [x | x<-[1..1986], ((x^111) `mod` 1987)==1]
09:24:49 <newsham> > let f n = [ x | x<-[1..(n-1)], (gcd x n) == 1] in f 10
09:24:50 <lambdabot>  [1,647,1339]
09:24:51 <lambdabot>  [1,3,7,9]
09:25:13 <newsham> > let f n = [ x | x<-[1..(n-1)], (gcd x n) == 1] in (f 10) == [1..9]
09:25:15 <lambdabot>  False
09:25:19 <glguy> > let f n = [ x | x<-[1..(n-1)], (gcd x n) == 1] in [x | x<-(f 1987), ((x^111) `mod` 1987)==1]
09:25:20 <lambdabot>  [1,647,1339]
09:25:30 <glguy> > let f n = [ x | x<-[1..(n-1)], (gcd x n) == 1] in [x | x<- [1..1986], ((x^111) `mod` 1987)==1]
09:25:32 <lambdabot>  [1,647,1339]
09:25:34 <sek> omg
09:26:02 <glguy> sek: can't reproduce it
09:26:15 <sek> what do you mean?
09:26:27 <glguy> sek: it worked just fine just now
09:26:30 <glguy> ^
09:26:32 <sek> yeah
09:26:40 <dozer> mm - it would be nice if the list comprehension sysntax worked for anything that was mappable and foldable
09:26:41 <sek> why isnt it working in what i pasted?
09:26:52 <dozer> I need to do it over Set
09:27:06 <newsham> > let f n = [ x | x<-[1..(n-1)], (gcd x n) == 1] in (f 1987) == [1..1986]
09:27:07 <lambdabot>  True
09:27:11 <glguy> sek: no telling
09:27:15 <sek> heh
09:27:45 <sek> i spent 3 hours considering the mathematical implications of x^111 = 1 mod1987 only having 1 solution mod1987
09:27:55 <sek> and it was haskell letting me down all along
09:28:07 <glguy> What version of GHC is that
09:28:17 <sek> 6.4
09:28:25 <glguy> 6.4.1? .2? or just 6.4?
09:28:35 <sek> just 6.4 --version says
09:28:57 <glguy> sek: you probably specified a type of Int
09:29:22 <glguy> > (10 ^ 111, 10 ^ 111) :: (Int, Integer)
09:29:23 <lambdabot>  (0,1000000000000000000000000000000000000000000000000000000000000000000000000...
09:29:34 <vincenz> hmm
09:29:35 <vincenz> odd
09:29:45 <sek> Int in all of these
09:29:46 <glguy> which, when you take to the ^111 could be a problem
09:29:54 <vincenz> > 10^100 :: Int
09:29:56 <lambdabot>  0
09:29:59 <sek> i see
09:30:01 <vincenz> > 10^40 :: Int
09:30:03 <lambdabot>  0
09:30:08 <vincenz> > 10^40 `mod` 1
09:30:09 <glguy> > 2 ^ 111 :: Int
09:30:09 <lambdabot>  0
09:30:10 <vincenz> > 10^40 `mod` 2
09:30:10 <lambdabot>  0
09:30:11 <lambdabot>  0
09:30:19 <sek> i'll try swapping to Integer
09:30:19 <vincenz> > 10^40 `mod` (2^32)
09:30:20 <glguy> sek: and Int can only handle 0 ^ 111 and 1 ^ 111
09:30:21 <lambdabot>  0
09:30:24 <vincenz> > 10^40 `mod` (2^32) :: Integer
09:30:25 <lambdabot>  0
09:30:34 <vincenz> ah obviously
09:30:34 <vincenz> duh
09:31:35 <glguy> sek: explicit type definitions are for the lose ;)
09:32:30 <sek> i think its time for a %s/Int/Integer/g  in my math.hs file
09:32:30 <glguy> vincenz: did you mean: (10^40) `mod` (2^32) ?
09:32:51 <glguy> > (10^40) `mod` (2^32)
09:32:53 <lambdabot>  0
09:33:14 <glguy> > 10^(40 `mod` (2^32))
09:33:15 <lambdabot>  10000000000000000000000000000000000000000
09:33:56 <glguy> hmm, I guess I didn't know that ^ would be applied before `mod`... I thought that `operators` were second only to regular function application
09:34:30 <glguy> Anyone know the precedence of `functions` off-hand?
09:34:59 <glguy> I know how to look these up: infixr 8 ^
09:36:01 <dozer> hum - got a kind error
09:36:07 <sek> how can i do Int to Integer conversions?
09:36:19 <glguy> ?type fromIntegral
09:36:20 <lambdabot> forall b a. (Num b, Integral a) => a -> b
09:36:21 <glguy> ?type fromInteger
09:36:23 <lambdabot> forall a. (Num a) => Integer -> a
09:37:12 <sek> ah, ok. thanks again
09:37:19 <glguy> > fromIntegral (10 :: Int) :: Integer
09:37:21 <lambdabot>  10
09:38:15 <vincenz> glguy: they can be custom-defined
09:38:24 <glguy> vincenz: but what do they default to?
09:38:41 <vincenz> dunon
09:42:56 <vincenz> > 1 + 2 `mod` 3
09:42:57 <lambdabot>  3
09:43:07 <vincenz> > 3 * 2 `mod` 3
09:43:09 <lambdabot>  0
09:43:14 <vincenz> aha!
09:43:21 <vincenz> glguy: stronger than +, less strong than *
09:43:38 <glguy> vincenz: I bet that `mod` has a specially set precedence
09:43:43 <vincenz> yeah, was thinking the same
09:43:44 <glguy> because the default is infixl 9
09:43:53 <vincenz> > let foo = mod in 3 * 2 `foo` 3
09:43:54 <lambdabot>  6
09:43:56 <vincenz> yep
09:44:12 <glguy> I didn't know you could set the precedence, but that makes a lot of sense that you would set it to less than ^
09:44:27 <glguy> since most languages just use % and give it the precedence of * and /
09:44:48 <vincenz> welcome to haskell
09:44:51 <glguy> ?fptools mod
09:44:51 <lambdabot> mod not available
09:45:02 <glguy> ?index mod
09:45:02 <lambdabot> Prelude
09:45:06 <glguy> ?fptools Prelude
09:45:07 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
09:45:22 <vincenz> @. index fptools mod
09:45:22 <lambdabot> bzzt
09:45:27 <vincenz> @. fptools index mod
09:45:28 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
09:45:29 <vincenz> ;)
09:46:10 <glguy> hmmm, mod is exported by that file, but not defined in it
09:46:22 <glguy> and only one precedence level is altered
09:49:55 <alexj__> @seen shapr
09:49:55 <lambdabot> shapr is in #haskell-blah, #ScannedInAvian and #haskell. I last heard shapr speak 1h 18m 8s ago.
09:52:19 <ndm> lispy: ycr2js?
09:52:38 <dozer> ?type fst . (==a)
09:52:39 <lambdabot> Not in scope: `a'
09:52:55 <dozer> ?type \a -> fst . (==a)
09:52:56 <lambdabot>   Couldn't match `(a, b)' against `Bool'
09:52:56 <lambdabot>    Expected type: a1 -> (a, b)
09:53:26 <dozer> ?type \a -> (==a) . fst
09:53:27 <lambdabot> forall a b. (Eq a) => a -> (a, b) -> Bool
09:54:13 <dozer> ?type filter (==a) . fst
09:54:15 <lambdabot> Not in scope: `a'
09:54:29 <dozer> ?type \a -> filter (==a) . fst
09:54:31 <lambdabot> forall a b. (Eq a) => a -> ([a], b) -> [a]
09:54:58 <vincenz> @join (filter (==a) . fst)
09:55:02 <vincenz> rec type
09:55:08 <vincenz> @type join (filter (==a) . fst)
09:55:09 <lambdabot> Not in scope: `a'
09:55:17 <vincenz> @type join (\a -> filter (==a) . fst $ a)
09:55:19 <lambdabot>   Occurs check: cannot construct the infinite type: a = ([a], b)
09:55:19 <lambdabot>    Expected type: ([a], b)
09:57:48 <dozer> ?type \a -> filter (\ab -> fst ab == a)
09:57:49 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> [(a, b)]
09:58:08 <Igloo> Woo
09:58:13 * Igloo scores Cabal bug #100!
09:58:43 <dozer> ?type \a -> map snd $ filter (\ab -> fst ab == a)
09:58:44 <lambdabot>   Expecting a function type, but found `a'
09:58:45 <lambdabot>    Expected type: [(a, b)]
09:59:11 <alexj__> shapr: you up?
09:59:34 <dozer> ?type \a -M map snd filtered where filtered = filter (\ab -> fst ab == a)
09:59:36 <lambdabot> parse error on input `-'
09:59:56 <dozer> ?type \a -> map snd filtered where filtered = filter (\ab -> fst ab == a)
09:59:57 <lambdabot> parse error on input `where'
10:05:01 <ndm> @tell lispy Yhc Javascript back end, http://www.haskell.org/haskellwiki/Yhc/Javascript
10:05:02 <lambdabot> Consider it noted.
10:09:25 <glguy> dozer: where-statements exist at the declaration level and not the expression level
10:09:41 <dozer> ah, thanks
10:09:54 <glguy> let f = a where a = b in f
10:11:07 <glguy> (while let-in produces an expression)
10:11:27 <shapr> alexj__: y0
10:12:13 <glguy> dozer: additionally, you wanted: man snd . filtered
10:25:00 <Ontolog> http://paste.lisp.org/display/30377
10:25:08 <Ontolog> This is the problem nobody can solve!
10:25:37 <vegai> cleverly asked.
10:26:53 <vegai> Ontolog: I'm very tired so I might be seeing things, but...
10:27:03 <lisppaste2> Ontolog annotated #30377 with "Can you write a fold function for a BinaryTree structure?" at http://paste.lisp.org/display/30377#1
10:27:03 <vegai> shouldn't you apply p only at the leaf?
10:27:21 <Ontolog> hmm
10:27:24 <Ontolog> ill try
10:27:35 <vegai> No, that's not right.
10:27:54 <vegai> perhaps you should apply it only at the branch
10:28:03 <vegai> experiment, perhaps the answer lies therein
10:29:42 <edwinb> you need a function for Leaf as well as Branch
10:29:50 <edwinb> since Leaf has an argument of type a
10:29:59 <vegai> hmm
10:30:22 <Ontolog> treeFold p c (Leaf x) = (p) c x
10:30:26 <Ontolog> it's there edwinb
10:30:32 <edwinb> so the type you have for treeFold should be something like (a -> b) -> (b -> a -> b -> b) -> BinaryTree a -> b
10:30:54 <edwinb> I don't see it...
10:31:01 <vincenz> use bringert's stuff!
10:31:32 <xerox> Isn't defining a fold for an ADT something an algorithm could do?
10:31:35 <ndm> i prefer my stuff, my Play instance
10:31:40 <xerox> I.e. a catamorphism, IIRC.
10:31:41 <Ontolog> Hey this works but I don't know why:
10:31:41 <Ontolog> treeFold p c (Leaf x) = (p) c x
10:31:41 <Ontolog> treeFold p c (Branch left x right) = (p) c (treeFold p (treeFold p x left) right)
10:31:57 <ndm> i think its more general than bringert's, but i'm still trying to prove it
10:32:10 <xerox> Ontolog: looks cool.  No parens needed around p though.
10:32:18 <ndm> its definately shorter with less boiler plate per invokation
10:34:01 <Igloo> dcoutts_: Do cabal bug reports go to any mailing list?
10:34:46 <dcoutts> Igloo, you mean does the trac send emails to cabal-devel, answer no. I wish it would. I've asked SyntaxNinja a couple times.
10:34:47 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
10:35:03 <dcoutts> @tell lambdabot yes, thanks I know.
10:35:04 <Igloo> OK, ta
10:35:04 <lambdabot> Nice try ;)
10:35:37 <dcoutts> glguy, darcs version of Gtk2Hs works with ghc 6.6
10:40:30 <lisppaste2> Cale annotated #30377 with "of course" at http://paste.lisp.org/display/30377#2
10:43:10 <Cale> I didn't give mine the same type as yours, because it seems to me that for yours you could just do a traversal and then an ordinary foldl
10:46:15 <lisppaste2> Cale annotated #30377 with "traversal way" at http://paste.lisp.org/display/30377#3
10:46:58 <Cale> (that also shows a trick for walking a tree in a far more efficient way than using (++)
10:47:02 <Cale> )
10:49:08 <Cale> You shouldn't have deleted your typesignature, it was catching a bug for you. :)
10:49:32 <ben23> I'm trying to figure out which element in a list occurs the most often
10:49:45 <Cale> Are the elements in the class Ord?
10:49:46 <ben23> but since I'm new to haskell, I'm having problems with that
10:49:57 <ben23> they are sorted yes
10:50:13 <Cale> ah, look at 'group' in the Data.List library
10:50:26 <Cale> > group [1,1,2,2,2,2,2,3,3,4,4,4,5]
10:50:27 <lambdabot>  [[1,1],[2,2,2,2,2],[3,3],[4,4,4],[5]]
10:50:41 <Cale> > sortBy (\group [1,1,2,2,2,2,2,3,3,4,4,4,5]
10:50:42 <lambdabot>  Parse error
10:50:44 <Cale> oops
10:51:00 <Oejet> > group [1,2,3,4,1,2,3,4]
10:51:01 <lambdabot>  [[1],[2],[3],[4],[1],[2],[3],[4]]
10:51:04 <Cale> > sortBy (\x y -> compare (length y) (length x)) . group $ [1,1,2,2,2,2,2,3,3,4,4,4,5]
10:51:05 <lambdabot>  [[2,2,2,2,2],[4,4,4],[1,1],[3,3],[5]]
10:51:38 <ben23> I see
10:51:39 <Cale> That can be made more efficient by storing the counts first and then projecting back
10:52:05 <Cale> > map snd . sort . map (\x -> (length x, x)) . group $ [1,1,2,2,2,2,2,3,3,4,4,4,5]
10:52:06 <lambdabot>  [[5],[1,1],[3,3],[4,4,4],[2,2,2,2,2]]
10:52:19 <Cale> > map snd . sort . map (\x -> (- length x, x)) . group $ [1,1,2,2,2,2,2,3,3,4,4,4,5]
10:52:20 <lambdabot>  [[2,2,2,2,2],[4,4,4],[1,1],[3,3],[5]]
10:52:53 <xerox> > map snd . sort . map (length &&& id) . group $ [1,1,2,2,2,2,2,3,3,4,4,4,5] -- will *ever* the map fuse? :)
10:52:55 <lambdabot>  [[5],[1,1],[3,3],[4,4,4],[2,2,2,2,2]]
10:53:20 <opqdonut> xerox: \o/ arrows
10:54:29 <dozer> I'm having trouble with data statements that include (* -> *) kinds
10:55:08 <Cale> @kind Control.Monad.RWS.RWST
10:55:10 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
10:55:29 <Cale> what's up? :)
10:55:31 <dozer> thx - will look at that source
10:55:40 <glguy> o.O
10:55:42 <xerox> hehe
10:55:51 <Cale> I'm not sure that was what I was suggesting :)
10:56:02 <glguy> dozer: are you working with Monad Transformers
10:56:03 <Cale> Actually, a simpler monad transformer might be goos
10:56:07 <Cale> good*
10:56:18 <dozer> definitely not
10:56:44 <glguy> dozer: where are you encountering (* -> *) kinds
10:56:45 <dozer> -- Petri-net weighting
10:56:45 <dozer> data PetriNetArch pna => WPNet p t i pna = WPNet { arch :: pna p t,
10:56:45 <dozer>                                                    ptw  :: Data.Map.Map (p, t) i,
10:56:45 <dozer>                                                    tpw  :: Data.Map.Map (t, p) i }
10:56:59 <dozer> src/PetriNet.hs:117:26:
10:56:59 <dozer>     Kind mis-match
10:56:59 <dozer>     Expected kind `* -> * -> * -> * -> *',
10:56:59 <dozer>     but `WPNet' has kind `* -> * -> * -> (* -> * -> *) -> *'
10:56:59 <dozer>     In the instance declaration for `WeightedPetriNet WPNet'
10:57:11 <glguy> next time use a pastebin?
10:57:17 <dozer> sorry :)
10:58:41 <Cale> dozer: can you paste more of the code on lisppaste?
10:58:46 <Zara> Hello can someone tell me what's wrong with this code?delta :: (Float -> Float) -> Float -> (Float -> Float)
10:58:47 <Zara> delta  a n = \n -> a (n+1) - a n
10:58:49 <Zara> ?
10:59:10 <glguy> Zara: why are you reusing n
10:59:15 <Cale> well, for one, the outer n is being shadowed by the inner one, I doubt you want that
10:59:17 <glguy> and shadowing the one in the declaration
10:59:19 <greenrd> Does Haskell 98 have the property that if you float an expression to the toplevel, it can't make a program which fails to typecheck, typecheck afterwards? And does this property or something like it have a name?
11:00:02 <Zara> wait I'll tell you the exact error
11:00:24 <glguy> Zara: delta a n = a (n+1) - a n
11:00:40 <Cale> dozer: that code on its own works for me
11:00:59 <Cale> dozer: (assuming there's a trivial class PetriNetArch)
11:01:12 <Zara> I want it to return a function Da(n)=a(n+1) - a(n)
11:01:19 <dozer> http://paste.lisp.org/display/30388
11:01:29 <Zara> Am I doing wrong to type delta sqrt 4?
11:01:42 <glguy> Zara: that's fine, when you call delta, just use: delta sqrt
11:02:19 <Cale> If you apply the 4, you'll just get a number, but of course you will :)
11:02:30 <glguy> > let delta a n = a (n+1) - a n in map (delta sqrt) [1..4]
11:02:31 <lambdabot>  [0.41421356237309515,0.31783724519578205,0.2679491924311228,0.2360679774997898]
11:02:37 <Zara> the point is I dont get anything
11:03:00 <Zara> ERROR - Cannot find "show" function for:
11:03:01 <Zara> *** Expression : delta sqrt 4
11:03:01 <Zara> *** Of type    : Float -> Float
11:03:04 <Zara> except this
11:03:11 <glguy> Zara: like I said, get rid of \n ->
11:03:32 <glguy> ?type delta a n = \n -> a (n+1) - a n
11:03:33 <lambdabot> parse error on input `='
11:03:37 <glguy> ?type delta a n = a (n+1) - a n
11:03:39 <lambdabot> parse error on input `='
11:03:49 <glguy> ?type let delta a n = \n -> a (n+1) - a n in delta
11:03:50 <lambdabot> forall a a1 t. (Num a1, Num a) => (a -> a1) -> t -> a -> a1
11:03:52 <glguy> ?type let delta a n = a (n+1) - a n in delta
11:03:54 <lambdabot> forall a a1. (Num a1, Num a) => (a -> a1) -> a -> a1
11:04:34 <xerox> newsham: ping
11:05:42 <Zara> delta :: (Float -> Float) -> Float -> (Float -> Float)
11:05:43 <Zara> delta  a n =  a (n+1) - a n
11:05:46 <Zara> delta :: (Float -> Float) -> Float -> (Float -> Float)
11:05:46 <Cale> dozer: okay, this is a design problem and I'm not 100% sure how to fix it without properly reading and understanding all this, but do you see how in the class declaration for WeightedPetriNet, you apply the constructor wpn to p, t, i and (pna p t) ?
11:05:47 <Zara> delta  a n =  a (n+1) - a n
11:05:48 <Zara> ?
11:06:02 <dozer> yes
11:06:08 <glguy> Zara: that's the version you want
11:06:21 <glguy> no \n ->
11:06:38 <Cale> dozer: okay, so that's what's giving it the kind * -> * -> * -> * -> *
11:06:48 <glguy> or: delta a = \n -> a (n+1) - a n -- but this is unnecessary and ugly
11:06:49 <Cale> it's taking 4 plain old types, and producing another type
11:06:56 <dozer> fine, that makes sense
11:06:59 <Zara> ERROR file:.\delta.hs:2 - Type error in explicitly typed binding
11:06:59 <Zara> *** Term           : delta
11:06:59 <Zara> *** Type           : (Float -> Float) -> Float -> Float
11:06:59 <Zara> *** Does not match : (Float -> Float) -> Float -> Float -> Float
11:07:02 <Zara> I get that
11:07:15 <Cale> Okay, so now look at your WPNet
11:07:30 <Cale> aha, I know how to fix this :)
11:07:31 <glguy> delta :: (Flaot -> Float) -> Float -> Float
11:07:51 <Cale> the pna parameter is of kind (* -> * -> *) there, not of kind *
11:08:26 <dozer> in the WPNet decl?
11:08:42 <dozer> yes, that also makes sense - hence the badness
11:08:50 <glguy> Zara: in this case you would be better off not explicitly specigying the type
11:09:07 <Zara> but I want to return a function...like this lets say:deriv :: (Float->Float)->Float->(Float->Float)
11:09:34 <Zara> deriv f dx = \x -> (f(x+dx)-f x) /dx
11:09:53 <glguy> Zara: you don't need to write these thigns as lambdaexpressions
11:10:13 <glguy> deriv f dx x = (f (x+dx) - f x) / dx -- will do just fine
11:10:47 <glguy> ?type let deriv f dx x = (f (x+dx) - f x) / dx in deriv
11:10:49 <lambdabot> forall a. (Fractional a) => (a -> a) -> a -> a -> a
11:10:56 <Zara> that is to say the same thing without \x..
11:11:09 <dozer> Zara: you can define the function in the normal way, and then only supply the first few args, and you will atomatically get back a function that is expecting the rest
11:11:37 <glguy> Zara: also, a -> a -> a  is the same as : a -> (a -> a)
11:11:42 <glguy> -> is right associative
11:16:28 <alexj__> anyone here understand implicit parameters?  why are these types different: g x y = let ?f = \x-> x in ?f x ++ (show (?f y)) and g' x y = let f = \x-> x in f x ++ (show (f y))
11:17:21 <alexj__> does ?f cause the typechecker to do something difffernt than it would with an explicit variable?
11:17:26 <dozer> Cale: removing that (=>) clause improves things somewhat, but now I have a kind problem with "instance LabelledPetriNet LPNet"
11:17:55 <dozer> Expected kind `* -> * -> * -> * -> *', but `LPNet' has kind `* -> * -> * -> * -> * -> *'
11:18:51 <Cale> yeah, I'm still working on that one -- the good news is that I got your code to compile without it :)
11:19:08 <dozer> lol, thx
11:21:16 <Cale> okay, I think it's down to ordinary type errors in the instance for LPNet
11:22:13 <Zara> delta :: (Float -> Float) -> Float -> Float
11:22:13 <Cale> http://paste.lisp.org/display/30388#1
11:22:14 <Zara> delta  a  n = a (n+1) - a n
11:22:18 <Zara> I did that
11:22:26 <Zara> typed delta sqrt 4
11:22:51 <Zara> and saw 0.236068 does the woek?
11:23:21 <Zara> what other functions can I use?I want to do it with integers..
11:24:13 <Cale> delta sqrt 4 = sqrt 5 - sqrt 4 = 2.2360... - 2 = 0.2360...
11:24:18 <dozer> Cale: if I comment out everything after the where of that instance decl, I still get the sam error
11:25:17 <Cale> dozer: really? I just get a bunch of missing method warnings
11:25:46 <ptolomy> If I want to have N threads wait and act on data entered by another thread, what is the best way to go about that? Like, if I want the main thread to send messages to the rest of the threads (same message) and they are to do nothing until they get it..
11:25:47 <dozer> ghc-6.5
11:25:52 <dozer> perhaps that's it?
11:26:18 <Cale> I only have 6.4 and 6.7.recent
11:26:24 <Cale> er, 6.4.2
11:26:44 <Cale> and they both load it fine that way
11:26:51 <Cale> so maybe a bug in 6.5?
11:27:11 <dozer> fine with the {- before the instance, or directly after it?
11:27:12 <Cale> you should at least upgrade to 6.6
11:27:17 <dozer> yes, I should
11:27:23 <ptolomy> Ideally, I'd want a 1->Many MChan.
11:27:47 * earthy hugs SYB and Language.Haskell.Syntax
11:28:09 <dozer> it doesn't seem to have hit apt yet for kubuntu
11:28:31 <Zara> Main> delta square 5
11:28:32 <Zara> ERROR - Undefined variable "square"
11:28:44 <Zara> ??Shouldn't square be in hugs?
11:30:09 <ptolomy> Is there any easy way to do a sort of thread-safe STM mutlicast thing without tracking the number of receivers?
11:32:44 <ptolomy> I suppose I could do an empty MVar, then have each listening thread empty the MVar, refill it, then wait on it again except the writer thread, which would not refill it and since it is FIFO, that may work.
11:33:35 <nmadnani> Hi Everyone, I am trying to build hugs on Mac OS X 10.4 but for some reason it's not building the X11 package
11:33:46 <newsham> ?hoogle (a -> a -> b) -> a -> b
11:33:48 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
11:34:06 <newsham> ?pl \op x -> x `op` x
11:34:06 <lambdabot> join
11:34:11 <CosmicRay> nmadnani: do you have X11 installed on the mac?
11:34:19 <newsham> > join (*) 3
11:34:21 <nmadnani> Yes, I do
11:34:21 <lambdabot>  9
11:34:41 <CosmicRay> well, that exhausts my theory then
11:35:00 <nmadnani> I am trying out an HGL HelloWorld program and when I run it with Hugs, I get the following error:
11:35:15 <nmadnani>  Can't find imported module "Graphics.X11.Xlib"
11:35:56 <CosmicRay> have you googled for info on hugs on osx?
11:36:16 <nmadnani> Yes, I did try that but I could not find anything specific about X11
11:36:22 <Cale> Perhaps you can get a binary package which has the X11 libs already?
11:36:25 <Cale> hmm
11:36:40 <nmadnani> Well, I did do that as well
11:36:43 <nmadnani> using DarwinPorts
11:36:56 <nmadnani> but that did not detect the installed X11
11:37:04 <nmadnani> and so did not install the X11 package either
11:37:09 <newsham> where is "join" defined?
11:37:18 <newsham> ?hoogle join
11:37:19 <lambdabot> Monad.join :: Monad a => a (a b) -> a b
11:37:19 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
11:37:19 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
11:37:33 <newsham> that's not the join in   "join (*) 3" is it?
11:38:56 <glguy> newsham: yes it is :)
11:39:03 <glguy> newsham: import Control.Monad.Reader
11:39:29 <newsham> Prelude> :module +Control.Monad
11:39:29 <newsham> Prelude Control.Monad> :t join
11:39:29 <newsham> join :: (Monad m) => m (m a) -> m a
11:39:30 <newsham> Prelude Control.Monad> join (*) 3
11:39:33 <newsham> error...
11:39:37 <glguy> newsham: import Control.Monad.Reader
11:39:53 <newsham> so its not the one that I asked about.
11:39:58 <glguy> no, it is
11:40:09 <newsham> ?hoogle join
11:40:10 <lambdabot> Monad.join :: Monad a => a (a b) -> a b
11:40:11 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
11:40:11 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
11:40:18 <newsham> I just used Control.Monad.join and got an error
11:40:19 <glguy> the specific Monad instances is defined in Control.Monad.Reader
11:40:26 <glguy> the function is Control.Monad.join
11:40:31 <newsham> oh
11:40:43 <glguy> 6.6 might let you import Control.Monad.Instances
11:41:39 <glguy> 6.6 allows: :m Control.Monad Control.Monad.Instances if you want the join eample to work
11:41:42 <newsham> which monad instance is that?
11:41:44 <nmadnani> So, am I correct in assuming that in order to use Graphics.HGL, I need to have Graphics.X11 working ?
11:41:48 <glguy> (->) r
11:41:50 <nmadnani> on the mac, at least
11:41:52 <nmadnani> ?
11:42:25 <alexj__> ndm: just looks at the yhc javascript link you posted.  are you involved with the project?
11:42:31 <glguy> > ( \m -> do { a <- m; b <- a; return b } ) (*) 3
11:42:32 <lambdabot>  9
11:42:33 <newsham> is (->) "Functor" ?
11:42:57 <glguy> ((->) r) is a monad, and a functor
11:43:09 <ndm> alexj__: yes, but someone else wrote the javascript stuff - i'm involved heavily with the Core side of it
11:43:20 <glguy> ( (+1) `fmap` (*2) ) 4
11:43:23 <glguy> > ( (+1) `fmap` (*2) ) 4
11:43:24 <ndm> alexj__: however, if you have any questions about Yhc, I'll probably know the answer ;)
11:43:25 <lambdabot>  9
11:43:52 <nmadnani> Is there a mailing list for hugs that I can post my question to ? I don't see one on their homepage
11:43:57 <alexj__> ndm: ok.  I'm basically interested in figuring out how to plug it into happs nicely.
11:44:28 <glguy> newsham: in ((->) r), fmap is function composition, aka (.)
11:44:31 <alexj__> I am also looking at flapjax on the client side.  doing functional reactive programming on the client side in haskell woudl be useful.
11:44:33 <ndm> alexj__: we generate Javascript, which can be called by normal javascript, so i guess the question is how you want it done - its pretty flexible
11:44:34 <newsham> hmm.. Control.Monad.Instances doesnt describe the (->) one
11:44:46 <newsham> docs I mean.
11:44:52 <nmadnani> never mind, I found it
11:45:02 <ndm> yes, flapjax is way cool, although i think its use is probably occasional, rather than the norm
11:45:25 <alexj__> flapjax is useful for some tasks.
11:45:38 <ndm> indeed, and where is it useful, its 100% the best thing
11:45:48 <newsham> so for (->) r,   >>= is composition?
11:45:53 <ndm> i'm just still trying to figure out how often its the best thing
11:45:56 <glguy> newsham: nope, liftM is
11:46:30 <ndm> alexj__: what were your plans/needs for happs?
11:46:37 <ndm> @where happs
11:46:38 <lambdabot> http://happs.org
11:46:41 <alexj__> me too.  I'm currently debugiing server side stuff and cleaning up some happs issues I hope to hit the client side again next week.
11:46:49 <newsham> can you explain this monad to me?  (or is it in one of the tutorials?)
11:47:01 <newsham> f >>= k = \r -> k (f r) r
11:47:10 <alexj__> ndm: I am using it to build some commercial projects I am excited about.
11:47:31 <alexj__> I am making a bet that doing it in haskell will  be long term better.
11:47:36 <palomer_> can you guys remove my nickban?
11:47:40 <ndm> alexj__: once Yhc has a DOM library with static typing, i intend to use Yhc JS for commercial stuff as well
11:47:56 <glguy> palomer_: weren't you banned for being generally disruptive and disagreeable
11:48:10 <ndm> alexj__: well since Yhc is standard Haskell, and pretty reliable so far, its a reasonable bet - although its still quite new
11:48:29 <glguy> newsham: do you understand the Reader monad?
11:48:45 <newsham> i havent used it much, though i think i have an idea of what it does.
11:48:55 <palomer_> glguy, those were the reasons given, I believe; why do you bring them up?
11:49:17 <newsham> ((->) r)   is a function that takes r as an argument and returns something?
11:49:34 <glguy> r is the "environment"
11:49:42 <glguy> it is applied to a function when it is bound
11:49:53 <glguy> it's like having an implicit asks on every binding
11:50:16 <glguy> > ( do { a <- asks (*); b <- asks a; return b } ) 3
11:50:18 <lambdabot>  9
11:50:26 <alexj__> does yhc support the extensions that happs uses?
11:50:32 <glguy> ?type ( do { a <- asks (*); b <- asks a; return b } )
11:50:34 <lambdabot> forall r (m :: * -> *). (Num r, MonadReader r m) => m r
11:50:35 <alexj__> e.g. template haskell?
11:50:40 <ndm> alexj__: no
11:50:51 <newsham> ?type asks
11:50:53 <Zara> f (2^3) (fact 13) (fact 3) : does it compute all them at a time?
11:50:53 <lambdabot> forall a (m :: * -> *) r. (MonadReader r m) => (r -> a) -> m a
11:51:07 <ndm> alexj__: its pretty much Haskell 98, although just because the server uses Haskell++, the client doesn't have to
11:51:14 <alexj__> agreed.
11:51:21 <glguy> Zara: it only computes them when it needs them
11:51:28 <alexj__> I just like the idea of typechecking all the way to the client.
11:51:28 <palomer_> > let a = [1..] in a==a --boo!
11:51:31 <newsham> hmm.. i'll have to investigate this more slowly later..  gotta get work done.
11:51:33 <lambdabot> Terminated
11:51:43 <palomer_> that sucks
11:52:14 <ndm> that would be cool, but pretty scary to do :)
11:52:26 <ndm> the client will type check, but the server/client interaction won't
11:52:38 <ndm> we are considering a server monad, perhaps generating happs code
11:52:49 <ndm> i.e. you can call into a monad, which does a server interface with ajax
11:54:42 <ndm> alexj__: i have to head off now, but if you have any questions feel free to email either the yhc list (yhc -at- haskell.org) or Dimitry (golubovsky -at- gmail.com), who wrote the JS stuff
11:55:01 <ndm> alexj__: i'm sure we'd be interested in getting Yhc Javascript more useable for all :)
11:55:12 <alexj__> ndm: yes.
11:55:23 <alexj__> zipless end-to-endness would be cool.
11:55:40 <ndm> indeed :)
11:55:54 <palomer_> http://www.haskell.org/haskellwiki/Embedding_CFG <--this looks like a better alternative to parsec
11:55:57 <lambdabot> Title: Embedding CFG - HaskellWiki, http://tinyurl.com/y3w9ut
11:55:58 <ndm> have you seen links? it offers that, but no haskell goodness (no typeclasses, no monads, impure, strict)
11:56:17 <alexj__> yeah. I looked at links.  but it missed a bunch of stuff I wanted.
11:56:23 <alexj__> this looks like it is much closer.
11:56:37 <alexj__> the big issue is whether you model apps from the client or the server. but I think that is resolvable.
11:56:55 <nomeata> Hi. Is there a very exact and fast way to get time differences?
11:57:07 <ndm> agreed, anyway - must dash - bye
11:57:09 <alexj__> ndm: I have to run too.  good stuff!
11:57:22 <nomeata> i.e. a simple counter with high precision that does not need have to an absolute meaning.
11:59:54 <eviltwin_b> something in System.Time?
12:00:24 <nomeata> I only see getClockTime but that does not even seem to be monotonous when used in short succession
12:00:39 <eviltwin_b> er?
12:02:07 <eviltwin_b> that may return the same time in very short succession, in which case your OS does not provide high resolution time and you lose.
12:02:21 <eviltwin_b> (or not high enough resolution for your use, at least)
12:02:30 <nomeata> hmm. got to go. I’ll ask again later, sorry and thanks
12:02:57 <eviltwin_b> I've also seen it not be increasing, on older SCO for instance :)
12:04:33 <SamB_XP> doesn't monotonic mean "nondecreasing"?
12:04:47 <SamB_XP> (or "nonincreasing")
12:05:02 <eviltwin_b> monotonic means it changes by a predictable amount between calls
12:05:19 <mauke> whoa
12:05:20 <eviltwin_b> so a useful timeer function is both monotonic and increasing
12:05:40 <eviltwin_b> but may not be strictly increasing of your OS doesn't support e.g. real nanosecond timers
12:06:01 <eviltwin_b> (or your CPU is so fast that nanosec resolution isn;t good enough!)
12:06:26 <glguy> While "monotonous" means "is something very boring or uninteresting."
12:08:49 <ptolomy> Any thoughts on a good way to do 1->many multithreaded message passing, with listening threads sleeping until something is received?
12:09:41 <SamB_XP> eviltwin_b: where do you get this definition?
12:10:41 <eviltwin_b> I'm paraphrasing
12:11:50 <Oejet> ptolomy: What are your semantics?  Can messages get lost?  Must _all_ listening threads synchronise on the read?
12:13:07 <ptolomy> Oejet: I'm trying to have no messages be lost, read can be asynchronous.. I'm trying to do it without having to track the number of threads.
12:13:23 <vincenz> glguy: monotonous means that df/dx is either positive or negative over the entire x-axis
12:13:34 <SamB_XP> or at least it doesn't change signs
12:14:00 <SamB_XP> eviltwin_b: I meant, what did you read that means the same thing as that
12:14:42 <ptolomy> i may be being unreasonable, though. not sure how I expect to know if all listening threads have gotten the data without knowing how many listening threads there are.
12:16:08 <glguy> vincenz: I was making the assumption that monotonic and monotonous were different
12:16:14 <glguy> however it appears that they are not
12:17:11 <SamB_XP> I've never heard a good english speaker use "monotonic" to mean "boring", afaik...
12:17:56 * eviltwin_b is being brainless
12:18:13 <glguy> I'd only heard monotonous used as "boring, uneventful" and monotonic used for sequences
12:18:14 <eviltwin_b> 2 hours sleep last night, sorry
12:18:20 <glguy> I just always thought of them as different words
12:19:06 <emu> ?pl \x y -> (f x):y
12:19:12 <lambdabot> (:) . f
12:21:27 <glguy> ?jargon recursion
12:21:28 <lambdabot> *** "recursion" jargon "Jargon File (4.3.1, 29 Jun 2001)"
12:21:29 <lambdabot> recursion n. See {recursion}. See also {tail recursion}.
12:21:29 <lambdabot>  
12:22:21 <metaperl> @hoogle [a] -> Int
12:22:22 <lambdabot> Prelude.length :: [a] -> Int
12:22:30 <palomer_> SamB_XP, weren't you interested in parsers before?
12:22:41 <SamB_XP> hmm?
12:22:45 <metaperl> @hoogle [a] -> (\a -> b) -> Int
12:22:46 <lambdabot> Hoogle Error: Parse Error: Unexpected character '\a -> b) -'
12:22:59 <metaperl> I want a function to count the occurrences of a certain item
12:23:13 <vincenz> metaperl: length . filter (== x)
12:23:26 * SamB_XP was just going to say the same thing
12:23:27 <metaperl> yes I thought it was already there
12:23:30 <metaperl> but thanks vincenz
12:23:41 <palomer_> SamB_XP, did you do some work on parsing?
12:23:52 <SamB_XP> what sort of work?
12:23:59 <vincenz> palomer_: hi
12:24:29 <glguy> count p = foldl' (\n x -> if p x then (n + 1) else n) 0
12:24:30 <palomer_> vincenz, yo
12:24:39 <palomer_> SamB_XP, I don't know, any work!
12:24:49 <SamB_XP> well...
12:24:50 <vincenz> glguy: seems rather lame, go with std functionality, it's clearer
12:25:09 <mauke> @hoogle a -> [a] -> Int
12:25:10 <lambdabot> No matches, try a more general search
12:25:15 <SamB_XP> I've written some parsers, I wrote a function for that packed string parser library...
12:25:20 <palomer_> SamB_XP, tell me what you think of http://www.haskell.org/haskellwiki/Embedding_CFG
12:25:23 <lambdabot> Title: Embedding CFG - HaskellWiki, http://tinyurl.com/y3w9ut
12:25:44 <palomer_> it's based on Cale's idea, I think it could replace parsec
12:25:55 <glguy> vincenz: they both use standard functions , the difference only exists if performance matters
12:26:05 <SamB_XP> you can't replace Parsec very quickly
12:26:12 <Cale> palomer_: did you get the semantics bit working?
12:26:15 <vincenz> glguy: no it doesn't, you assume fusion doesn't exist
12:26:25 <SamB_XP> it isn't like a packed string or a finite map library ;-)
12:26:32 <palomer_> Cale, yeah
12:26:35 <palomer_> Cale, check it out
12:27:01 <glguy> vincenz: length doesn't fuse (according to the last time this came up in channel)
12:27:14 <palomer_> Cale, you can also get it to work with fixed points, but that requires MAD gadt hacking
12:27:27 <Cale> hehe
12:27:30 <palomer_> mad GADT hacking
12:27:37 <palomer_> and Fix is pointless
12:27:42 <vincenz> glguy: it should
12:27:47 <SamB_XP> what sort of pointless?
12:28:01 <palomer_> SamB_XP, adding a fixed point to the parser
12:28:14 <palomer_> doesn't add anything
12:28:25 <SamB_XP> well, you definately need some combinators there
12:28:26 <palomer_> since your grammar can still be infinitally big (and usually is)
12:29:22 <palomer_> Cale, is it possible to work some magic and have it parse left recursive grammars?
12:29:32 <SamB_XP> hmm, ah, won't you want to export functions that build these?
12:29:41 <SamB_XP> not the type constructors?
12:29:53 <SamB_XP> er, not the *data* constructors.
12:29:55 <SamB_XP> sorry ;-)
12:30:12 <palomer_> I'll export Check and :| and ~& and ~&& and ~&&& and ~&&&&
12:30:51 <palomer_> just look how clean the syntax is though!
12:30:56 <SamB_XP> check isn't a nice name
12:30:56 <Cale> and a Functor instance?
12:31:03 <palomer_> Cale, sure
12:31:13 <SamB_XP> I think Parsec's function has a nicer name
12:31:20 <palomer_> instance Functor (Grammar a) where fmap = FMap
12:31:22 <SamB_XP> @hoogle satisf
12:31:22 <lambdabot> Text.ParserCombinators.ReadP.satisfy :: (Char -> Bool) -> ReadP Char
12:31:23 <lambdabot> Text.ParserCombinators.Parsec.Char.satisfy :: (Char -> Bool) -> CharParser st Char
12:31:47 <Cale> hmm, actually, you should look at Control.Applicative closely
12:32:02 <SamB_XP> of course, I've never understood why some of those functions only work on Chars
12:32:06 <lisppaste2> metaperl pasted "trying to go points-free" at http://paste.lisp.org/display/30394
12:32:34 <palomer_> SamB_XP, speed hacks?
12:32:40 <metaperl> any idea how to make this function cleaner: http://paste.lisp.org/display/30394
12:32:58 <SamB_XP> palomer_: I doubt it
12:33:06 <SamB_XP> probably they are just in the wrong module
12:33:32 <Cale> metaperl: the points-free version would be  (* 100) . (`div` 2) . length . filter (== 1234)
12:33:37 <palomer_> Cale, what does Control.Applicative give me?
12:34:10 <Cale> palomer_: a nicer alternative to ~&&&
12:34:17 <palomer_> is it possible to work some magic and get an infinite term in terms of pointers?
12:34:33 <metaperl> Cale: are you making a f ( g ( h ( i x) ) ) where f = (* 100) g  = (`div` 2) h = length and i = filter (== 1234)
12:34:54 <newsham> http://www.thenewsh.com/~newsham/x/machine/mand2.hs.txt
12:34:57 <lambdabot> http://tinyurl.com/y6f6mm
12:35:18 <Cale> metaperl: hm? Yeah basically that's what it amounts to.
12:36:04 <metaperl> wow, that's pretty slick. thanks
12:36:06 <metaperl> :)
12:36:55 <dozer> Cale: I've upgraded to ghc 6.6, and it compiles now.
12:36:57 <Cale> Of course, using points-free style for arithmetic is a little questionable in general.
12:37:01 <Cale> dozer: cool
12:37:06 <palomer_> <:o
12:37:06 <dozer> thanks for your help
12:37:12 <Cale> No problem
12:37:16 <dozer> (took a while as I had a piza in the middle)
12:37:41 <Cale> @pl \x -> x^3 + 3 * x^2 + 5 * x + 12
12:37:42 <lambdabot> (12 +) . ap ((+) . liftM2 (+) (^ 3) ((3 *) . (^ 2))) (5 *)
12:37:51 <Cale> hehe
12:38:06 <Cale> such a good example of where not to use points-free form :)
12:38:13 <metaperl> Cale: I guess what I was asking is how would you write that function? Is my origiinal version similar to how you would write it?
12:38:32 * edwardk waves hello.
12:38:32 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:39:06 <newsham> proc x -> do { cube <- (arr (^ 3)) -< x; sq <- (arr (^ 2)) -< x; returnA -< (cube + 3 * sq + 5 * x + 12) }
12:39:34 <Cale> metaperl: it's not far off -- I'd probably have written it as something like  numberOfBottles = length . filter (== 1234) $ lis_barcode
12:40:03 <xerox> newsham!
12:40:07 <newsham> hi xerox.
12:40:08 <metaperl> ok thanks
12:40:16 <metaperl> sup rox
12:40:47 <dozer> Cale: appart from it being a bit buggy, does my code look vaguely like haskell should?
12:41:03 <encryptio> what would i use to repeat a function over its results? (ex: (*10) applied 4 times to 2 gives 20000)
12:42:03 <Cale> dozer: I think I'd have imported Data.Set as S and Data.Map as M, and then imported the type constructors separately unqualified
12:43:32 <Cale> You have an extraordinarily general framework there -- it might be good though. In the past, I've found that for complicated tasks, having lots of typeclass constraints available is a really good way to catch bugs.
12:44:01 <Cale> > iterate (*10) 2 !! 4
12:44:04 <lambdabot>  20000
12:44:15 <dozer> thx
12:44:16 <Cale> encryptio: like that
12:44:27 <encryptio> coo. thanks
12:44:27 <dozer> now to write the actual petrinet simulator :)
12:44:40 <metaperl> @type iterate
12:44:42 <lambdabot> forall a. (a -> a) -> a -> [a]
12:45:07 <glguy> > execState (replicateM 4 (modify (*10))) 2 -- I'm aware that this is an ugly solution
12:45:10 <lambdabot>  20000
12:45:15 <Cale> hehe
12:45:29 <encryptio> @type modify
12:45:31 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => (s -> s) -> m ()
12:45:39 <Cale> It's only a matter of time before we're using MonadCont :)
12:46:34 <glguy> > fix ((2:) . map (*10)) !! 4
12:46:36 <lambdabot>  20000
12:47:15 <glguy> > scanl (*) 2 [10,10..] !! 4
12:47:17 <lambdabot>  20000
12:48:14 <glguy> > 2 * product (replicate 4 10)
12:48:16 <lambdabot>  20000
12:48:22 <glguy> :yawn:
12:55:55 --- mode: ChanServ set +o Cale
12:56:31 --- mode: Cale set +b #haskell!*@*
12:56:33 <Cale> er
12:56:41 --- mode: Cale set -b #haskell!*@*
12:57:11 <glguy> ?
12:57:13 --- mode: Cale set +b *!*=dawg@*.inre.asu.edu
12:57:17 <Cale> there we go
12:57:17 <SamB_XP> hah
12:57:33 <SamB_XP> were you trying to ban the channel from that guy?
12:58:00 <glguy> Did he do something in a different channel? #math maybe?
12:58:07 <Cale> I had the order correct to begin with, but the server was giving me some flak about * being an unknown mode char
12:58:11 <Cale> yeah
12:58:27 <glguy> #latin ruffus    H   0  i=dawg@cc102j15.inre.asu.edu [wtf omg bbq]
12:58:37 <Cale> and his pattern in the past has been to come here and annoy us after getting banned from #math
12:58:44 --- mode: Cale set -o Cale
12:58:50 <glguy> ah
12:58:54 <Cale> so this is just a preemptive ban to prevent that
12:59:22 <glguy> a preemptive strike eh? you think he might have weapons?
12:59:29 <spiffy> Im a fan of trolls. Makes what I say look less stupid.
12:59:49 <glguy> Hmm, I don't know, that was pretty dumb
12:59:52 <Cale> actually, he used to have quite sophisticated weapons
13:00:11 <Cale> I sort of doubt he has a botnet anymore.
13:00:34 <spiffy> glguy: see, no troll and the truth comes out!
13:00:39 <Cale> since he used to immediately log back in from another machine after being banned, and he hasn't done that lately
13:00:57 <glguy> those people probably reformatted their ocmputers
13:02:21 <encryptio> lisppaste2: url
13:02:21 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
13:04:04 <vincenz> Cale: why were you opped
13:04:25 <Cale> vincenz: in order to preemptively ban a troll.
13:04:29 <vincenz> who?
13:04:41 * vincenz filters out part/ban/quit messages
13:04:42 <Cale> qpt (current nick is ruffus)
13:04:53 <Cale> *!*=dawg@*.inre.asu.edu
13:05:11 * vincenz nods
13:05:25 <encryptio> noob q: 0 is not an Int, Integer, or Double until it's found to be one of them, right? it's only a "0 :: Num a => a" which means it'll morph to whatever is needed?
13:05:55 <spiffy> ?type 0
13:05:57 <lambdabot> forall t. (Num t) => t
13:06:03 <spiffy> looks good to me
13:06:13 <spiffy> ?type 0::Int
13:06:14 <lambdabot> Int
13:06:18 <glguy> Cale: do you know any good examples of what Cont is used for other than "escape continuations"?
13:06:22 <SamB_XP> encryptio: pretty much
13:07:08 <metaperl> How would I create a list of all pairs of a list? E.g. [1,2,3,4] => [(1,2), (1,3), (1,4), (2,3), (2,4), (3,4)]
13:07:18 <Cale> http://citeseer.ist.psu.edu/claessen99functional.html -- this discusses an interesting monad transformer not unlike Cont which is used to add concurrency to any monad.
13:07:35 <lambdabot> http://tinyurl.com/t96hb
13:07:45 <SamB_XP> wow!
13:07:48 <SamB_XP> concurrency?
13:08:04 <glguy> > filterM (const [True,False]) [1,2,3,4] -- doesn't solve your problem exactly, but is intresting
13:08:04 <spiffy> metaperl: You wanna look at the list monad
13:08:05 <lambdabot>  [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4]...
13:08:08 <SamB_XP> does it do SMP and all?
13:08:41 <glguy> > [(a,b) | (a:as) <- tails [1,2,3,4], b <- as]
13:08:43 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
13:08:46 <Cale> > [[x,y] | (x:xs) <- tails [1,2,3,4], y <- xs]
13:08:48 <lambdabot>  [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
13:08:54 <Cale> bah :)
13:08:57 <metaperl> tails, hmm
13:08:58 <glguy> Cale: a high=five!
13:09:01 <vincenz> Cale: ah seen that one before :)
13:09:24 <spiffy> ?type tails
13:09:26 <lambdabot> forall a. [a] -> [[a]]
13:09:34 <Cale> > tails [1,2,3,4]
13:09:35 <lambdabot>  [[1,2,3,4],[2,3,4],[3,4],[4],[]]
13:09:41 * spiffy likes
13:10:01 <metaperl> returns the list of initial segments of its argument list, shortest last
13:10:12 <spiffy> I like it
13:10:12 <metaperl> ? heads [1,2,3,4]
13:10:17 <metaperl> > heads [1,2,3,4]
13:10:17 <Cale> > let isSubstringOf x y = any (isPrefixOf x) (tails y) in "orl" `isSubstringOf` "Hello, World!"
13:10:18 <lambdabot>  Not in scope: `heads'
13:10:19 <lambdabot>  True
13:10:20 <glguy> > inits [1..4]
13:10:21 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4]]
13:10:42 <metaperl> > tail [1,2,3,4]
13:10:43 <lambdabot>  [2,3,4]
13:10:47 <metaperl> >tail [2,3,4]
13:10:54 <metaperl> > tail [2,3,4]
13:10:56 <lambdabot>  [3,4]
13:10:59 <metaperl> > tail [3,4]
13:11:01 <lambdabot>  [4]
13:11:04 <metaperl> ahah!
13:12:14 <russo> hey guys is module aka % defined in haskell?
13:12:22 <russo> do i need to maybe import something?
13:12:24 <vincenz> > 1 `mod` 2
13:12:25 <glguy> mod
13:12:25 <lambdabot>  1
13:12:32 <metaperl> > tails [1,2,3,4]
13:12:33 <lambdabot>  [[1,2,3,4],[2,3,4],[3,4],[4],[]]
13:12:41 <vincenz> > 5 `mod` 2
13:12:43 <lambdabot>  1
13:12:48 <russo> do you need the back ticks?
13:12:54 <glguy> > (-3) `rem` 5
13:12:55 <lambdabot>  -3
13:12:56 <vincenz> russo: no
13:12:57 <glguy> > (-3) `mod` 5
13:12:58 <lambdabot>  2
13:12:59 <vincenz> > mod 5 2
13:13:00 <lambdabot>  1
13:13:16 <vincenz> if you want to infix it, then yes
13:13:44 <russo> aha! thanks :) i've programming in other functional langugages las couple of months
13:13:56 <glguy> other function languages?
13:13:59 <glguy> functional*
13:14:03 <Cale> > ((+) `foldr` 0) [1,2,3,4,5]
13:14:04 <lambdabot>  15
13:14:06 <russo> yes :)
13:14:12 <vincenz> russo: I think he was asking which
13:14:12 <glguy> weird ;)
13:14:16 * vincenz shushes glguy 
13:14:17 <russo> nope
13:14:24 <vincenz> russo: which ones?
13:14:26 <russo> i have to at my university
13:14:36 <russo> opal... its something really stupid at TU-Berlin
13:14:36 <metaperl> Coq
13:14:39 <russo> its unique here :)
13:14:52 <glguy> I was asking which, but since it was interpreted otherwise, I jsut rolled with it
13:14:53 <Zara> how can I do I do this: initpart 4 infones?I mean initpart is a hugs function?// infones :: [Int] infones = 1 : infones
13:15:20 <vincenz> Zara: What is initpart
13:15:37 <vincenz> > let ones = 1:ones in take 4 ones
13:15:38 <lambdabot>  [1,1,1,1]
13:15:41 <glguy> > let infones = 1:infones in take 4 infones
13:15:42 <lambdabot>  [1,1,1,1]
13:15:46 <Zara> initpart :: Int -> [u] -> [u]
13:15:47 <Zara> initpart n [] = []
13:15:47 <Zara> initpart 0 list = []
13:15:47 <Zara> initpart n (h:t) = h : (initpart (n-1) t)
13:15:52 <Zara> I made it
13:16:00 <vincenz> ah good :)
13:16:04 <vincenz> Zara: just do it
13:16:05 <glguy> > take 4 [1,1..]
13:16:07 <lambdabot>  [1,1,1,1]
13:16:07 <vincenz> initpart 4 infones
13:16:25 <Zara> returns n first elements of a list
13:16:32 <Zara> or so I think :)
13:16:45 <russo> is there a division that does whole division?
13:16:50 <glguy> div
13:16:51 <vincenz> > 4 `div` 6
13:16:52 <russo> i mean an operation for it
13:16:53 <lambdabot>  0
13:16:56 <spiffy> > take 5 [1..10]
13:16:57 <russo> oh thanks :)
13:16:57 <lambdabot>  [1,2,3,4,5]
13:17:16 <glguy> > 14 `divMod` 5
13:17:17 <vincenz> Zara: I am not certain what you are asking... you ahve the function, you have the data, you know how to call it...
13:17:18 <lambdabot>  (2,4)
13:17:31 <vincenz> glguy: uglyg
13:17:47 <Zara> And I also have ERROR - Undefined variable "infones"
13:17:49 * russo is a bit bored and is writing a program to convert time in seconds to minutes and seconds and return them in <minutes>:<seconds> :)
13:17:58 <kosmikus> russo: that it's unique doesn't necessarily mean it's stupid ...
13:18:02 <glguy> vincenz: there are plenty of times that divMod can be used when its not ugly to do so
13:18:23 <russo> kosmikus: you can't type numbers greater than 36
13:18:29 <russo> you have to enter them as a string
13:18:31 <kosmikus> russo: why not?
13:18:35 <russo> i.e. "37"!
13:18:46 <kosmikus> interesting ...
13:18:51 <vincenz> > let dotime seconds = let t = seconds `divMod` 60 in read (fst t) ++ ':':read (snd t) in dotime 100
13:18:52 <lambdabot>  add an instance declaration for (Integral String)
13:18:53 <lambdabot>   In the definition of ...
13:19:01 <kosmikus> russo: is there a reason for this?
13:19:09 <russo> anyway it allows them to keep declaring datatypes within one another... or thats what our prof said
13:19:21 <glguy> vincenz: try: let (q,r) = x `divMod` y in stuff q r x y etc
13:19:22 <russo> it was a decision they made which allows them to do other cool stuff
13:19:33 <vincenz> should be show
13:19:34 <vincenz> not read
13:19:56 <russo> so you can define datatypes within datatypes with in datatypes and there won't be any problems with type :)
13:19:57 <vincenz> > let dotime t = let (m,s) = t `divMod` 60 in show m ++ ':':show s in dotime 1000
13:19:59 <lambdabot>  "16:40"
13:20:02 <resiak> Bleh, I only realised today what Fun in the Afternoon _is_, and that I was in the same building as it and missed it :(
13:20:02 <vincenz> like that?
13:20:03 <glguy> is that the y-combinator? (Nshag's part message)
13:20:08 <russo> :D eyah
13:20:10 <Zara> vincenz:the 2 functions should be in the same .hs file?
13:20:22 <vincenz> Zara: that would be the simplest
13:20:23 <kosmikus> russo: I don't see yet what one has to do with the other, but I'll believe you for now :)
13:20:48 <russo> ok and hopefully that'll turn into believing me later too :)
13:20:49 <Cale> russo: It looks a lot like ML, at least in terms of features
13:20:59 <russo> i dunno tbh
13:21:00 <Zara> but not necessary though?Can I just open hugs and type initpart 4 infones?
13:21:05 <Cale> what's different about it, apart from syntax? :)
13:21:09 <russo> i think its lazy evaluation though
13:21:14 <russo> which ml isnt
13:21:17 <SamB_XP> yeah, why can't the compiler convert 5256 to "5256"?
13:21:19 <Cale> oh, then Haskell :)
13:21:28 <vincenz> SamB_XP: show
13:21:41 <glguy> SamB_XP: is joking, right?
13:21:52 <vincenz> SamB_XP: go back to perl!
13:21:57 <Cale> or maybe Lazy ML
13:22:06 <SamB_XP> I'm talking about what russo was saying
13:22:17 <SamB_XP> I don't understand why 37 wouldn't be allowed?
13:23:08 <glguy> Ah, I wasn't reading russo's comments
13:23:10 <russo> SamB_XP: i couldn't tell you i just know its hard enough to compile on a unix system... and imposible on a mac :(
13:23:21 <russo> the compiler
13:23:36 <kosmikus> which might be the reason I never tried it
13:23:37 <russo> i mean it is an interpretor like hugs
13:23:41 <glguy> and this is for a psychology class?
13:23:56 <glguy> so see how much programmers can take
13:23:58 <glguy> ? :)
13:25:12 * glguy is surprised that 36 is allowed...if you input numbers in base 36, which I am guessing is what he is talking about
13:25:15 <glguy> 0-9 a-z
13:25:27 <glguy> and only in single digits
13:25:38 <russo> its 1-36 and all base 100
13:25:46 <glguy> base 100?
13:25:47 <russo> and 0 also
13:25:51 <russo> so 100,200,300
13:25:55 <russo> etc
13:26:11 <russo> maybe its just the design of the interpretor
13:26:20 <russo> and they defined how it reads lines
13:26:24 <russo> i dunno...
13:26:36 <glguy> sounds like a reality tv show for programmers
13:27:30 <spiffy> more like Saw
13:27:40 <russo> is there a good pastebin for haskell
13:27:45 <spiffy> ?paste
13:27:46 <lambdabot> http://paste.lisp.org/new/haskell
13:27:47 <russo> i can't seem to find my error
13:28:32 <lisppaste2> russo. pasted "seconds to mintues and seconds <minutes>:<seconds> as a string" at http://paste.lisp.org/display/30399
13:28:56 <russo> ahh crap
13:28:59 <russo> i forgot my error
13:29:16 <lisppaste2> russo. annotated #30399 with "error" at http://paste.lisp.org/display/30399#1
13:29:46 <russo> i wanted to use an int
13:29:52 <russo> or better yet an unsigned int
13:30:01 <russo> but atm i have a float
13:30:47 <Cale> ah, in Opal, 0,1,2,etc. are just identifiers. So probably they've only bothered to define up to 36 in their prelude.
13:31:56 <russo> i found it
13:32:16 <russo> show was having problems because i was doing a calculation
13:32:39 <russo> is there unsigned int in haskell?
13:32:50 <sjanssen> russo: yes
13:32:53 <sjanssen> @hoogle Word
13:32:54 <lambdabot> Data.Word :: module
13:32:54 <lambdabot> Data.Word.Word :: data Word
13:32:54 <lambdabot> System.Win32.Types.WORD :: type WORD
13:33:08 <russo> umm
13:33:22 <russo> how would it be
13:33:26 <russo> in a function declaration
13:33:30 <russo> UnsignedInt?
13:33:43 <sjanssen> s2m :: Word -> String
13:33:46 <ptolomy> What is the haskell syntax for multi-line string literals? quote continuation with '\'?
13:33:58 <sjanssen> you'd also have to import Data.Word
13:33:59 <russo> sjanssen: i'm not using a word
13:34:04 <russo> am I?
13:34:16 <russo> is there nat in haskell
13:34:21 <sjanssen> russo: that is the unsigned int in Haskell
13:34:33 <russo> oh
13:34:36 <russo> is it just Nat
13:34:44 <russo> i'm asking whats the syntax for the type
13:34:45 <russo> :D
13:34:47 <russo> the name rather
13:34:57 <sjanssen> russo: it's called Word
13:35:03 <russo> :O
13:35:10 <russo> i thought you were joking
13:35:13 <chessguy> nat = 1 : map (+1) nat
13:35:15 <russo> who came up with that?
13:35:26 <russo> why did they call it word :S
13:35:27 <sjanssen> I dunno, the name is a bit name
13:35:38 <sjanssen> s/bit name/name
13:35:45 <sjanssen> bah, I'm so dumb!
13:36:13 <russo> what do i need to import for word
13:36:23 <lisppaste2> Cale annotated #30399 with "guards, where" at http://paste.lisp.org/display/30399#2
13:36:23 <glguy> Haskell didn't pick "Word", the term comes from a unit of memory
13:36:26 <russo> import Data.Word?
13:36:38 <Cale> russo: have a look there :)
13:37:14 <Cale> I just used Integer, the usual unbounded integer type in Haskell.
13:37:18 * russo shakes fist at Cale for using guards :)
13:37:21 <vincenz> Cale: you do mod twice!
13:37:37 <Cale> er, true, that should be m
13:37:38 <vincenz> just use
13:37:40 <vincenz> yeah :)
13:37:43 <lisppaste2> glguy annotated #30399 with "using divmod more" at http://paste.lisp.org/display/30399#3
13:37:44 <vincenz> and it should be (m,s)
13:37:58 <sjanssen> russo: people don't use Word very often
13:38:05 <vincenz> glguy: 'xactly
13:38:08 <vincenz> but learn to align code :)
13:38:11 <lisppaste2> Cale annotated #30399 with "like this" at http://paste.lisp.org/display/30399#4
13:38:19 <glguy> vincenz: I was going for speed!
13:39:12 <russo> i don't get what (d,m) does
13:39:20 <Cale> vincenz: (m,s)?
13:39:22 <Cale> > divMod 123 60
13:39:30 <lambdabot>  (2,3)
13:39:33 <russo> oh wow
13:39:36 <lisppaste2> vincenz annotated #30399 with "even better" at http://paste.lisp.org/display/30399#5
13:39:38 <Cale> wow, lambdabot is slow right now
13:39:41 <russo> ok
13:39:44 <russo> :)
13:39:45 <russo> well i don't know these functions :)
13:39:52 <russo> you 1337 haskellers :)
13:39:53 <vincenz> > show 0
13:39:54 <lambdabot>  "0"
13:39:54 <lisppaste2> glguy annotated #30399 with "using shows and showString" at http://paste.lisp.org/display/30399#6
13:39:55 <vincenz> ;)
13:40:11 <Cale> vincenz: indeed
13:40:12 <vincenz> Cale: you don't need extra 0 logic
13:40:16 <Cale> vincenz: right
13:40:24 <russo> glguy: that won't work for 9
13:40:29 <Zara> why initpart 4 infones returns only [1,1,1,1]?Infones makes an endless list of 1 right??
13:40:32 <jdev> @pl \(x,y) -> x++":"++y
13:40:32 <russo> glguy: you'll get 9 instead of 09
13:40:32 <lambdabot> uncurry ((. (':' :)) . (++))
13:40:33 <russo> :)
13:40:45 <Cale> russo: 9 < 10
13:40:55 <russo> oh sorry i misread it then :)
13:40:59 <glguy> Cale: maybe not in that language he was talking about
13:41:02 <sjanssen> @check 9 < 10
13:41:03 <lambdabot>  OK, passed 500 tests.
13:41:10 <russo> argh that is good :)
13:41:13 <sjanssen> @scheck 9 < 10
13:41:16 <lambdabot>  Completed 1 test(s) without failure.
13:41:53 <lisppaste2> glguy annotated #30399 with "oneliner with shows" at http://paste.lisp.org/display/30399#7
13:42:04 <Cale> Zara: infones isn't defined as part of Haskell, but you can define it with  infones = 1 : infones
13:42:18 <Cale> Zara: also, by initpart, do you mean take?
13:42:28 <Zara> I did it works ..
13:42:33 <Cale> > let ones = 1 : ones in take 4 ones
13:42:34 <lambdabot>  [1,1,1,1]
13:42:40 <jdev> > repeat 1
13:42:42 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:42:49 <glguy> Cale: we went through all of this a couple pages back :)
13:42:51 <Cale> or indeed, use repeat :)
13:42:59 <glguy> > [1,1..]
13:43:01 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:43:03 <jdev> I wonder...
13:43:12 <jdev> @pl let x = 1 : x in x
13:43:13 <lambdabot> fix (1 :)
13:43:26 <Cale> glguy: ah, quite a ways back, yeah, I missed that part of the conversation
13:43:32 <lisppaste2> vincenz annotated #30399 with "even better" at http://paste.lisp.org/display/30399#8
13:43:37 <vincenz> what do you think of that
13:43:38 <Cale> Zara: so what's the question? Why does it work?
13:43:56 <vincenz> glguy: you're missing (d,m) like me
13:44:17 <glguy> russo: sorry you asked?
13:44:23 <glguy> vincenz: I think we killed it
13:44:27 <Cale> <Zara> initpart :: Int -> [u] -> [u]
13:44:27 <Cale> <Zara> initpart n [] = []
13:44:27 <Cale> <Zara> initpart 0 list = []
13:44:27 <Cale> <Zara> initpart n (h:t) = h : (initpart (n-1) t)
13:44:44 * glguy wonders if printf would do this on its own
13:44:48 <Cale> let's apply initpart to ones where ones = 1 : ones
13:44:57 <russo> no i liked it :)
13:45:02 <russo> it was good
13:45:03 <Zara> Cale:yep sth like that..
13:45:08 <Cale> initpart 4 ones
13:45:08 <russo> i didn't think about it that way
13:45:32 <Cale> will match the last pattern, because we see that ones is h : t, where h = 1 and t = ones
13:45:39 <russo> glguy: that wouldn't work in opal though
13:45:52 <newsham> is there a function n -> [a] -> [[a]] which will make a list of groups of n from [a] ?
13:45:55 <russo> although i should try
13:45:56 <Cale> so: initpart 4 ones = 1 : (initpart (4 - 1) ones)
13:46:08 <Zara> and then n=3
13:46:11 <Cale> right
13:46:13 <newsham> ie  f 3 "abcdefghi" ->  ["abc", "def", "ghi"]
13:46:26 <glguy> vincenz: I wasn't going to jump to "if" statements until someone else did... can't stand 'em usually :)
13:46:28 <mauke> @hoogle Int -> [a] -> [[a]]
13:46:29 <lambdabot> No matches, try a more general search
13:46:38 <Zara> and when n=0 it returns []?
13:46:39 <vincenz> glguy: okok
13:46:56 <glguy> > unfoldr (liftM2 (>>) (guard.not.null) (return.splitAt 3)) ['a'..'i']
13:46:58 <lambdabot>  ["abc","def","ghi"]
13:47:00 <vincenz> glguy: there's worse
13:47:16 <glguy> vincenz: they aren't terrible, i just avoid if it's clean to do so
13:47:36 <vincenz> you could -always- add two "0"
13:47:42 <vincenz> and then just drop until you have but two letters
13:48:50 <Cale> split n = take n . takeWhile (not . null) . iterate (drop n)
13:48:57 <Cale> er
13:49:01 <Cale> split n = map (take n) . takeWhile (not . null) . iterate (drop n)
13:49:22 <Johhaidiiijavall> How can i get suffle list order ?
13:49:40 <glguy> > printf "%02d" (9 :: Int) :: String
13:49:41 <lambdabot>  "09"
13:50:24 * vincenz shudders at the sight of printf
13:50:47 <glguy> s2m :: Integer -> String
13:50:47 <glguy> s2m time = uncurry (printf "%d:%02d") (divMod time 60)
13:50:48 <glguy> ?
13:51:16 <glguy> uncurry (printf "%d:%02d") (divMod time 60) $ 124
13:51:20 <glguy> > uncurry (printf "%d:%02d") (divMod time 60) $ 124
13:51:21 <lambdabot>  Not in scope: `time'
13:51:30 <glguy> > uncurry (printf "%d:%02d") (divMod 124 60)
13:51:31 <lambdabot>  Add a type signature
13:51:33 <glguy> > uncurry (printf "%d:%02d") (divMod 124 60) :: String
13:51:34 <lambdabot>  Add a type signature
13:51:41 <glguy> > uncurry (printf "%d:%02d") (divMod (124 :: Int) 60) :: String
13:51:43 <lambdabot>  "2:04"
13:54:42 <russo> > divMod (50 4)
13:54:43 <lambdabot>  add an instance declaration for (Num (t -> a))
13:54:57 <glguy> > divMod 50 4
13:54:58 <lambdabot>  (12,2)
13:56:06 <russo> oh yeah
13:56:10 <russo> that was opal :)
13:56:22 <russo> you need () for the apllication
13:56:27 <russo> divMod 50 4
13:56:36 <russo> > divMod 50 4
13:56:38 <lambdabot>  (12,2)
13:56:41 <russo> yeah
13:56:42 <russo> ok
13:56:49 <russo> divMod 50 11
13:56:55 <russo> > divMod 50 11
13:56:56 <lambdabot>  (4,6)
14:04:13 <vincenz> @join #scheme
14:09:05 <Zara> doublesum :: (Int -> Int -> Int) -> Int -> Int
14:09:05 <Zara> doublesum f 0 =0
14:09:05 <Zara> doublesum f n = doublesum f (n-1) + sum 1
14:09:05 <Zara>      where  sum :: Int -> Int
14:09:05 <Zara>            sum k
14:09:05 <Zara>                      | k==n = f n n
14:09:08 <Zara>                      | otherwise = f n k + f k n + sum (k+1)
14:09:09 <Zara>                            
14:09:12 <Zara>                    
14:09:18 <Zara> why sum comes out as undefined symbol?
14:09:23 <vincenz> woah
14:09:26 <vincenz> @paste
14:09:26 <lambdabot> http://paste.lisp.org/new/haskell
14:09:39 <Zara> sorry
14:10:04 <Renkin> I was wondering.. why is there map when fmap works on all functors?
14:10:52 <Renkin> Oh, I might have the answer..
14:11:33 <Renkin> fmap is defined to be map for lists?
14:11:40 <Renkin> Or something?
14:11:44 <lisppaste2> Zara pasted "unexpected symbol "sum"" at http://paste.lisp.org/display/30405
14:11:58 <glguy> map is just the simple case specific to lists to make it easier to teach Haskell
14:12:09 <Renkin> Ok
14:12:21 <glguy> or for when you don't want a function to act over all Functors, just lists
14:12:46 <wolverian> Zara, watch your indentation.
14:13:14 <Renkin> Ok, so there's not like a fmap = map for Instance [] in Functor?
14:13:22 <Renkin> How do I check that in GHCi, btw?
14:14:30 <Zara> wolverian:indentation?(this time I'm lost in translation :))
14:15:20 <glguy> Renkin: that's probably how it is defined
14:15:31 <glguy> Renkin: but fmap could work on lists without map existing
14:16:27 <glguy> for example: fmap succ (Just 1) -- there isn't a Maybe specific fmap
14:17:00 <Renkin> But isn't there a specific definition for fmap in Instance Maybe ?
14:17:10 <glguy> yeah, but it doesn't use a different name
14:17:14 <glguy> it's just fmap
14:17:15 <Renkin> Ah, yeah
14:17:16 <mauke> yeah, fmap = liftM :-)
14:17:29 <Renkin> Heh :)
14:17:47 <wolverian> Zara, indentation is the whitespace you before the lines.
14:17:51 <wolverian> s/you/you use/
14:17:54 <glguy> ?fptools Functor
14:17:55 <lambdabot> Functor not available
14:19:12 <Renkin> Every monad is a functor, right?
14:19:20 <vincenz> yes
14:19:35 <glguy> every monad can be made to be a functor...
14:19:38 <Renkin> So why isn't there an "instance Functor Monad"
14:19:50 <Renkin> Oh, hehe
14:19:52 <glguy> Renkin: because that isn't how Haskell works
14:19:54 <Renkin> Monad is also a class
14:20:00 <Renkin> Yeah, I realized that now
14:20:20 <Renkin> I guess I should think about things a bit more before I ask =)
14:20:59 <glguy> I think that fmap is more popular than liftM in a lot of cases because it has one less character
14:21:13 <Renkin> liftM also has to be imported, it seems
14:21:14 <Zara> wolverian: should all the lines be aligned without whitespaces in the beginning?
14:21:49 <Renkin> @index liftM
14:21:50 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
14:22:09 <Renkin> I'm starting to like lambdabot
14:22:29 <xerox> ?yow
14:22:30 <lambdabot> Adopt my lifestyle or I'll have to press charges.
14:22:53 <Renkin> Heh :)
14:22:56 <wolverian> Zara, no, but sum's type is indented too much.
14:25:37 <lisppaste2> Zara pasted "doublesum un-spaced" at http://paste.lisp.org/display/30408
14:27:03 <encryptio> Zara: the type and the definition of sum have to start at the same character
14:27:20 <Renkin> >map ((^) 2) [1..15]
14:27:39 <Renkin> No?
14:28:21 <Zara>  at the same character?
14:28:30 <lisppaste2> encryptio annotated #30408 with "One possible correct way" at http://paste.lisp.org/display/30408#1
14:28:45 <Renkin> > 1+1
14:28:47 <lambdabot>  2
14:28:57 <Renkin> > map ((^) 2) [1..15]
14:28:58 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768]
14:29:08 <encryptio> Zara: see my paste...
14:30:48 <glguy> > scanl1 (*) [2,2..]
14:30:53 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
14:31:39 <Zara> I saw it,solaris'hugs likes it,WINXP hugs98 doesn't like it at all
14:35:40 <russo> hey guys can one implement disktra in haskell
14:35:42 <russo> ?
14:35:46 <Zara> thanx anyway,now I'll re-space my programs wit bugs..
14:36:22 <sjanssen> russo: yes, one can
14:36:37 <russo> so how just if in columns and then fi
14:36:37 <glguy> russo: Haskell is a general purpose programming language
14:37:30 <Renkin> What's a simple monad I can write for practice?
14:37:52 <glguy> Identity
14:38:05 <sjanssen> Renkin: Maybe
14:38:19 <glguy> sjanssen's suggestion is "better"
14:38:21 <Renkin> Ok
14:38:50 <Renkin> I'll try Maybe then
14:39:15 <sjanssen> russo: the fastest implementations rely on mutable state, but one can write a elegant and not terribly slow functional version
14:39:43 <glguy> additionally, you can write the mutable state version in Haskell too
14:40:04 <Pastorn> is there any "monads for dummies" document?
14:40:19 <LoganCapaldo> There are a billion of them
14:40:21 <Renkin> http://www.haskell.org/haskellwiki/Monads_as_containers
14:40:23 <lambdabot> Title: Monads as containers - HaskellWiki, http://tinyurl.com/yylt9j
14:40:26 <Renkin> Reading that right now
14:40:46 <sjanssen> I prefer monads as monsters
14:41:08 <Renkin> There is one like that?
14:41:37 <sjanssen> Renkin: it isn't a real tutorial, just a little joke from this last Halloween
14:41:47 <Renkin> Ah :)
14:41:50 <Renkin> Pastorn: http://www.haskell.org/haskellwiki/Monad#Monad_Tutorials
14:41:52 <lambdabot> Title: Monad - HaskellWiki, http://tinyurl.com/ybnke3
14:42:41 <dons> ?docs Data.Graph.Inductive
14:42:41 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/fgl/Data-Graph-Inductive.html
14:42:43 <Renkin> Is lambdabot omnipotent or something?
14:42:56 <glguy> ?yow
14:42:56 <lambdabot> How's the wife?  Is she at home enjoying capitalism?
14:43:07 <Renkin> Haha
14:43:20 <glguy> ?vixen Are you omnipotent?
14:43:20 <lambdabot> i think you know the answer to that one, silly
14:43:30 <sjanssen> @remember Renkin Is lambdabot omnipotent or something?
14:43:49 <mauke> @randomquote
14:43:50 <lambdabot> Unknown command, try @list
14:44:42 <Renkin> What does remember do?
14:44:54 <sjanssen> @quote Renkin
14:44:55 <lambdabot>  Is lambdabot omnipotent or something?
14:45:00 <Renkin> Oh :)
14:45:07 <mauke> @keal
14:45:08 <lambdabot> perhaps i just genius and never tested
14:45:38 <Pastorn> Renkin: thanks
14:46:35 <dons> ?users
14:46:36 <lambdabot> Maximum users seen in #haskell: 276, currently: 254 (92.0%), active: 49 (19.3%)
14:46:48 <bringert_> @vixen are you a bot which just runs 4000 regexps?
14:46:48 <lambdabot> a bot? what is that?
14:46:50 <glguy> ?photontorpedo
14:46:51 <lambdabot> how does haskell compare to say java?
14:46:58 <glguy> ?photontorpedo
14:46:59 <bringert_> hi dons
14:46:59 <lambdabot> I personally emailed paul graham the lisp guy today after reading about python in E raymonds essay he metions ruby n python is u cant use lisp
14:47:09 <dons> morning bringert_
14:47:30 <bringert_> the PDF edition is really nice
14:47:44 <dons> cool
14:47:57 <glguy> ?keal
14:47:57 <lambdabot> you think i am one of them persnipity uppity men are pig lesbian mathematicians?
14:47:57 <dons> i'll try to get the last 5 editions re-pdf-ified today
14:47:58 <glguy> was keal from a long time ago?
14:48:07 <dons> from january
14:48:22 <glguy> long enough ago :)
14:49:02 <sjanssen> wow, that kealism sounds like a bot
14:50:55 <vraj> @help
14:50:56 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:51:06 <Cale> @keal
14:51:06 <lambdabot> perhaps i just genius and never tested
14:51:09 <Cale> @keal
14:51:09 <lambdabot> i only trust opensource tools. where can i download haskell for windows?
14:51:18 <Cale> haha
14:51:44 <glguy> sounds like a tool, but is he open source?
14:52:09 <pkhuong> glguy: you're welcome to bring a woman of your choice to fork away.
14:52:46 <glguy> I'm not sure that I follow
14:53:07 <Acker_> Hi all, I made a function called "productoPunto" that obtains the dot product of two vectors like this: productoPunto [1,2,3] [4,5,6], that give me 32, I'm looking to how to simplifly more the function [I just start Haskell yesterday ¬¬]
14:53:25 <Acker_> this is my fuction "productoPunto x y = sum (map product (transpose x y))"
14:53:32 <bringert_> dons: some radom ideas: - make slogan a footer, - also make a full edition in PDF, for leaving around the department lunch room (in color?), - break most of the latex header stuff out into a latex document class, - put a vertical line between the columns, - fill the end with just headlines from the stuff that didn't make the PDF, - put info about HWN in fine print in footer: editor, purpose, copyright, history ("published since August 20
14:53:48 <glguy> pp xs ys = sum $ zipWith (*) xs ys -- would work too
14:54:02 <bringert_> I might do some of that when I find the time
14:54:26 <mauke> @type transpose
14:54:27 <lambdabot> forall a. [[a]] -> [[a]]
14:54:36 <mauke> how does that compile then?
14:54:42 <glguy> > transpose [[1,2,3],[4,5,6]]
14:54:44 <lambdabot>  [[1,4],[2,5],[3,6]]
14:54:58 <mauke> his code says transpose x y, not transpose [x,y]
14:55:14 <bringert_> dons: oh, and create a nice logo in svg/eps, to include in the PDF version, on t-shirts, put on places where HWN is posted
14:55:44 <glguy> he started yesterday... so he might not know about import Data.List and wrote his own
14:55:44 <bringert_> the logo could just be the name + maybe a slogan
14:55:57 <Acker_> Ya, I just started yesterday
14:56:01 <Acker_> :(
14:56:09 <fik> @djinn [[a]] -> [a]
14:56:10 <lambdabot> -- f cannot be realized.
14:56:19 <fik> @hoogle [[a]] -> [a]
14:56:20 <lambdabot> Prelude.concat :: [[a]] -> [a]
14:56:21 <glguy> join
14:56:37 <dons> bringert_: yeah, a logo would be good
14:56:45 <dons> need some inspriration though
14:56:59 <dons> (actually, i was thinking about tshirts for the hackathon....)
14:57:07 <JohnMeacham_> what would you call RULES pragmas which actually make things worse in the short run, but should fire if they allow another rule to fire that will make things better overall. I am thinking METARULES or ANTIRULES
14:57:39 <bringert_> dons: yeah, logos and names are always the hardest part
14:57:40 <SamB_XP> JohnMeacham: MAGICRULES ;-P
14:57:45 <pkhuong> JohnMeacham: investment ;)
14:57:46 * bringert_ likes the template haskell logo
14:58:01 <dons> JohnMeacham_: a lot of rules make things worse in the short term
14:58:16 <sjanssen> JohnMeacham: SPECULATIVE or PROSPECTIVE are good words, but too long for a pragma
14:58:37 <Renkin> CATALYST
14:58:40 <cjeris> JohnMeacham: WISHFUL ?
14:58:52 <dons> fps is full of rules that translate f into streamed-f, which is slower *unless* fusion occurs. in which case it is better. we then have backup rules that fire later, and rewrite any unfused funs back to the fast version
14:58:56 <sjanssen> heh, how about "RULES?"
14:59:07 <sjanssen> and then if you really want them to fire, "RULES!"
14:59:18 <fik> @hoogle transpose
14:59:19 <glguy> optional
14:59:19 <lambdabot> List.transpose :: [[a]] -> [[a]]
14:59:19 <lambdabot> Data.Graph.transposeG :: Graph -> Graph
15:01:34 <JohnMeacham_> dons: indeed, which is why ghc requires all that wacky phase ordering stuff, I am just going to sidestep that whole mess by the introductuon of antirules or whatever.
15:01:48 <JohnMeacham_> I like CATALYST. nice.
15:02:45 <vraj> @help free
15:02:45 <lambdabot> free <ident>. Generate theorems for free
15:02:55 <Johhaidiiijavall> Hei, is there easyer way to do this: bins n = (map ((:)'0') (bins (n-1))) ++ (map ((:)'1') (reverse (bins (n-1))))
15:03:05 <Johhaidiiijavall> bins 2  ==>  ["00","01","10","11"]
15:03:16 <mauke> @pl bins n = (map ((:)'0') (bins (n-1))) ++ (map ((:)'1') (reverse (bins (n-1))))
15:03:17 <glguy> replicateM 2 "01"
15:03:18 <lambdabot> bins = fix (ap (ap . (((++) . map ('0' :)) .) . (. subtract 1)) (((map ('1' :) . reverse) .) . (. subtract 1)))
15:03:19 <glguy> > replicateM 2 "01"
15:03:21 <lambdabot>  ["00","01","10","11"]
15:03:48 <dons> JohnMeacham_: hmm. sounds interesting. so no more imperative rule engine! :)
15:04:44 <glguy> Johhaidiiijavall: ^^
15:04:58 <SamB_XP> JohnMeacham: so are these CATALYSTS required to be bidirectional, or do you actually speculatively apply rules?
15:05:32 <JohnMeacham_> dons: yeah, I don't know if I can supplant it fully. but my main goal is to get list fusion going on without any particular phase ordering of rules needed. also to support foldr/build and unfoldr/destroy deforestation concurrently.
15:05:43 <Johhaidiiijavall> glguy. replicateM ? on what module?
15:05:50 <glguy> ?index replicateM
15:05:50 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
15:06:07 <glguy> Control.Monad is the easiest, but any will work
15:06:40 <Johhaidiiijavall> import List will not work ?
15:06:49 <glguy> import Control.Monad
15:06:52 <glguy> would work
15:07:06 <JohnMeacham_> I think I will go with CATALYST. I like it. come by for your beers Renkin.
15:07:52 <Johhaidiiijavall> glguy, where i can find info about replicateM ?
15:08:03 <sjanssen> @docs Control.Monad
15:08:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
15:08:38 <elmaia> Hello All
15:08:56 <Johhaidiiijavall> thanx
15:09:06 <elmaia> I'm from Brazil and I'm doing homework using Haskell
15:09:23 <elmaia> But I'm newbee, can some one help me
15:09:25 <elmaia> ?
15:09:30 <SamB_XP> no!
15:09:33 <Cale> elmaia: sure
15:09:36 <SamB_XP> (not until you ask a real question ;-)
15:09:37 <glguy> Nope, you haven't asked any Haskell questions yet
15:09:45 <elmaia> Well
15:09:46 <JohnMeacham_> > replicateM 5 "01"
15:09:47 <lambdabot>  ["00000","00001","00010","00011","00100","00101","00110","00111","01000","01...
15:09:56 <JohnMeacham_> cool. what a neat way to count in binary.
15:10:02 <SamB_XP> neato
15:10:07 <elmaia> I have a list with some elements type Stars
15:10:10 <glguy> > filterM (const [True,False]) [1..4]
15:10:11 <lambdabot>  [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4]...
15:10:16 <elmaia> type Stars = (Int,Int,Int)
15:10:30 <SamB_XP> hmm...
15:10:33 <Cale> > [replicate k ['a'..'z'] | k <- [1..]] >>= sequence
15:10:34 <lambdabot>  ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s"...
15:10:38 <elmaia> I made a function that receive a list of Stars
15:10:41 <Cale> > [replicate k ['a'..'c'] | k <- [1..]] >>= sequence
15:10:42 <lambdabot>  ["a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aac",...
15:10:55 <JohnMeacham_> does that make the powerset?
15:11:00 <elmaia> and make a XOR with all elements
15:11:12 <Cale> all nonempty strings on an alphabet
15:11:20 <Cale> > [replicate k "01" | k <- [1..]] >>= sequence
15:11:22 <lambdabot>  ["0","1","00","01","10","11","000","001","010","011","100","101","110","111"...
15:11:22 <sjanssen> JohnMeacham_: no, but filterM (const [True, False]) does
15:11:27 <elmaia> after I take the result and make XOR with all elements from this same list
15:11:38 <sjanssen> > filterM (const [True, False]) "abc"
15:11:39 <lambdabot>  ["abc","ab","ac","a","bc","b","c",""]
15:11:41 <elmaia> 'til this point was easy
15:12:07 <SamB_XP> > let hex x = "0x" ++ replicateM "0123456789abcdef" ! x in hex [0..]
15:12:07 <lambdabot>    Expecting a function type, but found `Array i e'
15:12:07 <lambdabot>    Expected type: Ar...
15:12:18 <elmaia> Now, I need to filter the elements from this list after XOR with the original elements and select ...
15:12:21 <SamB_XP> > let hex x = "0x" ++ replicateM "0123456789abcdef" !! x in hex [0..]
15:12:23 <lambdabot>    Expecting a function type, but found `[a]'
15:12:23 <lambdabot>    Expected type: [a]
15:12:23 <lambdabot>   ...
15:12:27 <Cale> elmaia: I'm not completely sure I understand the problem description, but okay...
15:12:32 <SamB_XP> > let hex x = "0x" ++ replicateM 8 "0123456789abcdef" !! x in hex [0..]
15:12:33 <lambdabot>  Couldn't match `Int' against `[a]'
15:12:36 <glguy> > filterM(\_->[False..])[1..3]
15:12:37 <lambdabot>  Parse error
15:12:40 <elmaia> shots :: Config -> [Stars]
15:12:42 <elmaia> shots c = do list <- (xorAllOne c (xorAll c))
15:12:43 <elmaia>              return [ strd(x) <= strd(y)| x<-list, y<-c]
15:12:43 <SamB_XP> > let hex x = "0x" ++ replicateM "0123456789abcdef" 8 !! x in hex [0..]
15:12:45 <lambdabot>  Couldn't match `Int' against `[Char]'
15:12:45 <glguy> > filterM(\_-> [False..])[1..3]
15:12:46 <lambdabot>  Parse error
15:12:49 <JohnMeacham_> sweet. now feed the output of that into an iota (or jot) interpreter, and we have just created the shortest program that will calculate the sum of human knowledge.
15:12:56 <elmaia> Take a look at this function
15:13:00 <JohnMeacham_> can we fit it one one line?
15:13:01 <SamB_XP> > let hex x = "0x" ++ (replicateM 8 "0123456789abcdef" !! x) in hex [0..]
15:13:02 <lambdabot>  Couldn't match `Int' against `[a]'
15:13:08 <SamB_XP> > let hex x = "0x" ++ (replicateM "0123456789abcdef" 8 !! x) in hex [0..]
15:13:09 <lambdabot>  Couldn't match `Int' against `[Char]'
15:13:16 <SamB_XP> arg.
15:13:18 <elmaia> xorAll :: [Stars] -> Stars
15:13:20 <elmaia> xorAll ls = foldr1 x ls where
15:13:21 <elmaia>    x (a,a',a'') (b,b',b'') = (0,0,xor a'' b'')
15:13:23 <elmaia> xorAllOne :: [Stars] -> Stars -> [Stars]
15:13:24 <elmaia> xorAllOne ls s = map (f s) ls where
15:13:26 <elmaia>    f (a,b,c) (d,e,f) = (d,e,xor c f)
15:13:27 <elmaia>    
15:13:29 <elmaia> shots :: Config -> [Stars]
15:13:30 <elmaia> shots c = do list <- (xorAllOne c (xorAll c))
15:13:32 <elmaia>              return [ strd(x) <= strd(y)| x<-list, y<-c]
15:13:36 <elmaia> Where Stars = (Int,Int,Int)
15:13:44 <glguy> > filterM(\_->[False ..])[1..3]
15:13:44 <elmaia> and Config = [Stars]
15:13:45 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
15:13:47 <Renkin> JohnMeacham: Cool :) Where do you serve them?
15:13:55 <JohnMeacham_> http://ling.ucsd.edu/~barker/Iota/  iota would be better
15:14:01 <dolio> SamB_XP: map hex [0..] ?
15:14:02 <glguy> elmaia: you should be using
15:14:03 <glguy> ?paste
15:14:04 <lambdabot> http://paste.lisp.org/new/haskell
15:14:05 <elmaia> But the function Shots doesn't work
15:14:07 <JohnMeacham_> Renkin; Pasadena, Ca, USA
15:14:12 <SamB_XP> > let hex x = "0x" ++ (replicateM 8 "0123456789abcdef" !! x) in map hex [0..]
15:14:14 <lambdabot>  ["0x00000000","0x00000001","0x00000002","0x00000003","0x00000004","0x0000000...
15:14:18 <SamB_XP> dolio: ah, no wonder ;-)
15:14:22 <elmaia> paste ?
15:14:24 <SamB_XP> well. it seems to work ;-)
15:14:33 <Renkin> JohnMeacham_: Aw, an ocean apart, thanks anyway ;)
15:14:36 <SamB_XP> > let hex x = "0x" ++ (replicateM 8 "0123456789abcdef" !! x) in map hex [-1,-2..]
15:14:38 <lambdabot>  Exception: Prelude.(!!): negative index
15:14:42 <elmaia> Is this a command ?
15:14:53 <vraj> ?paste
15:14:54 <lambdabot> http://paste.lisp.org/new/haskell
15:15:04 <SamB_XP> ^ this is a URL!
15:15:06 <SamB_XP> go there
15:15:33 <lisppaste2> elmaia pasted "My code" at http://paste.lisp.org/display/30409
15:15:48 <elmaia> ready
15:16:36 <Cale> hmm
15:16:42 <Itkovian> elmaia: what happens when you want to fold over some triples that do not match your pattern?
15:16:48 <Cale> elmaia: what's the error?
15:16:50 <Itkovian> in xorAll
15:17:01 <Itkovian> hmm
15:17:04 <Itkovian> forget that
15:17:04 <glguy> [ strd(x) <= strd(y)| x<-list, y<-c] -- what does thhis mean?
15:17:07 <glguy> errr
15:17:09 <glguy> NEVERMIND
15:17:11 <Cale> Itkovian: every triple matches that pattern
15:17:16 <glguy> <= less than equal
15:17:19 <Itkovian> Cale: yes, I'm half asleep
15:17:28 <elmaia> What I'm trying to do is ...
15:17:35 <SamB_XP> heh
15:17:37 <glguy> Itkovian: I think my comment was dumber, so don't feel bad ;)
15:17:44 <SamB_XP> did you think it <= meant "is implied by"?
15:17:54 <Itkovian> @karma glguy
15:17:55 <lambdabot> glguy has a karma of 8
15:17:56 <glguy> yeah, I was thinking in terms of class constraints
15:18:00 <elmaia> select all elements from list where the third element from x is <= the third element from c
15:18:05 <Itkovian> ah yes, now I feel not that bad :-)
15:18:07 <SamB_XP> heh
15:18:19 <Cale> elmaia: aha, but that's not what it does :)
15:18:39 <elmaia> And what I do ?
15:18:43 <elmaia> Better...
15:18:49 <elmaia> What's wrong ?
15:18:49 <glguy> OH, I incorrectly determined what was going wrong?
15:19:00 <Cale> [x | x <- list, y <- c, strd x <= strd y]
15:19:19 <Cale> though that doesn't traverse them in parallel
15:19:32 <elmaia> I'll try, 2 seconds
15:19:36 <Cale> it forms all pairs of elements from list and c
15:19:54 <Cale> and then includes the element of x in the list if strd x <= strd y
15:20:03 <glguy> > [(x,y) | x <- [1..3], y <- [1..3]] -- Illustration of what Cale said
15:20:05 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
15:20:14 <elmaia> return [x | x<-list, y<-c, strd(x) <= strd(y)]
15:20:26 <Cale> > [(x,y) | x <- [1..3], y <- [1..3], x < y]
15:20:29 <lambdabot>  [(1,2),(1,3),(2,3)]
15:20:33 <Cale> > [(x,y) | x <- [1..5], y <- [1..5], x < y]
15:20:34 <lambdabot>  [(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)]
15:20:50 <Cale> > [ x | x <- [1..5], y <- [1..5], x < y]
15:20:52 <lambdabot>  [1,1,1,1,2,2,2,3,3,4]
15:20:55 <elmaia> But I want only the elements from X
15:21:04 <elmaia> y doesn't matter
15:21:13 <LoganCapaldo> > [(x,y) | (x,y) <- zip [1..3] [1..3] ] --- Ilustration of the other thing
15:21:13 <SamB_XP> how about [x | (x,y) <- zip [1,2,3] [4,3,2], x <= y]?
15:21:15 <lambdabot>  [(1,1),(2,2),(3,3)]
15:21:17 <SamB_XP> > [x | (x,y) <- zip [1,2,3] [4,3,2], x <= y]
15:21:18 <lambdabot>  [1,2]
15:21:19 <elmaia> And doesn't worked
15:21:27 <elmaia> didn't work,,,
15:21:37 <glguy> > [x | x <- [1..3], any (x <) [1..3]]
15:21:39 <lambdabot>  [1,2]
15:21:47 <elmaia> Where I paste all the files to look ?
15:22:44 <lisppaste2> elmaia pasted "Code" at http://paste.lisp.org/display/30411
15:22:56 <elmaia> Look at end of file
15:23:43 <elmaia> SamB_XP, not ZIP
15:24:04 <psnl> anyone know anything about the http module?
15:24:12 <elmaia> the tuple is a kind : Starts
15:24:47 <elmaia> Maybe I'm not being able to explain what I want
15:25:01 <dons> sjanssen: i've got a puzzle for you: implement a parallel QuickCheck 'test' function, that forks each property to test, with results communicated back to the main thread via a Chan for printing. then see how much faster fps' Properties.hs runs
15:25:10 <dons> sjanssen: if it works nicely, we could push it into -package QuickCheck
15:25:14 <dons> interested?
15:25:58 <elmaia> Cale, did you see the code ?
15:26:21 <Johhaidiiijavall> how can i go throw all list's elements ?
15:27:06 <dons> throw?
15:27:09 <dons> through.
15:27:11 <dons> map!
15:27:11 <dibblego> through
15:27:15 <LordBrain> i wanted to try quickCheck, but I didn't see how to make a generator for [(String,Handle)]
15:27:15 <dons> > map (*2) [1..10]
15:27:18 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
15:27:33 <dons> > map show [1..10]
15:27:34 <lambdabot>  ["1","2","3","4","5","6","7","8","9","10"]
15:27:37 <LordBrain> actually no.. it was TVar [(String,Handle)]
15:27:41 <dons> > map toUpper "haskell"
15:27:43 <lambdabot>  "HASKELL"
15:27:54 <dons> Johhaidiiijavall: makes sense?
15:28:29 <Johhaidiiijavall> hmm.. this is not what i wanted :P
15:28:42 <dons> what were you trying to do? iterate through a list?
15:28:56 <dibblego> ?type iterate
15:28:58 <lambdabot> forall a. (a -> a) -> a -> [a]
15:29:14 <elmaia> someone can help my ?
15:29:22 <dibblego> iterate (*2) 7
15:29:26 <dibblego> > iterate (*2) 7
15:29:27 <lambdabot>  [7,14,28,56,112,224,448,896,1792,3584,7168,14336,28672,57344,114688,229376,4...
15:29:43 <dons> Johhaidiiijavall: look in Data.List for list functions
15:29:45 <dons> ?docs Data.List
15:29:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
15:29:49 <dons> ^^ here
15:29:54 <LordBrain> hmm i built a program which acts as a client or as a server, p2p, and understands BEncode (ripped off conjure for that).. I haven't decided where to go from here...
15:30:11 <dons> elmaia: did you work out where to paste?
15:30:12 <dons> ?paste
15:30:12 <lambdabot> http://paste.lisp.org/new/haskell
15:30:13 <dons> ^^ here
15:30:22 <Itkovian> dons I think he pasted
15:30:25 <elmaia> I put there
15:30:45 <LordBrain> i think i'll put hs-plugins in it..
15:30:46 <elmaia> elmaia pasted "Code" at http://paste.lisp.org/display/30411
15:30:46 <Johhaidiiijavall> i want to make a list of list where are elements, except i element. gaps [1..4]  ==>  [[2,3,4],[1,3,4],[1,2,4],[1,2,3]]
15:31:56 <russo_> hey guys how do import another file with haskell
15:31:58 <elmaia> my problem is with the function shot
15:32:05 <dons> russo_: import Foo
15:32:05 <russo_> so import another file into the program i'm using atm
15:32:08 <russo_> k thanks
15:32:09 <elmaia> import File
15:32:29 <LordBrain> if its a haskell module, you just use the import command
15:32:39 <dons> Johhaidiiijavall: google for 'permute haskell', perhaps
15:33:43 <elmaia> Couldn't match expected type `Stars' against inferred type `[a]'
15:33:45 <elmaia>     In the first argument of `return', namely
15:33:46 <elmaia>         `[x | x <- list, y <- c, (strd (x)) <= (strd (y))]'
15:33:48 <elmaia>     In the expression:
15:33:49 <elmaia>         return ([x | x <- list, y <- c, (strd (x)) <= (strd (y))])
15:33:51 <elmaia>     In the expression:
15:33:52 <elmaia>         do list <- (xorAllOne c (xorAll c))
15:33:54 <elmaia>            return ([x | x <- list, y <- c, (strd (x)) <= (strd (y))])
15:34:35 <SamB_XP> > let gaps xs = zip (tail (tails xs)) (inits xs) in gaps [1..7]
15:34:36 <lambdabot>  [([2,3,4,5,6,7],[]),([3,4,5,6,7],[1]),([4,5,6,7],[1,2]),([5,6,7],[1,2,3]),([...
15:34:40 <SamB_XP> hmm.
15:34:42 <russo_> dons: i'm getting ERROR "/opt/local/lib/hugs/packages/hugsbase/MusicFile.hs" - Module "Main" already loaded
15:34:48 <SamB_XP> > let gaps xs = zipWith (++) (tail (tails xs)) (inits xs) in gaps [1..7]
15:34:49 <lambdabot>  [[2,3,4,5,6,7],[3,4,5,6,7,1],[4,5,6,7,1,2],[5,6,7,1,2,3],[6,7,1,2,3,4],[7,1,...
15:35:00 <SamB_XP> nope.
15:35:10 <SamB_XP> > let gaps xs = zipWith (++) (inits xs) (tail (tails xs)) in gaps [1..7]
15:35:11 <lambdabot>  [[2,3,4,5,6,7],[1,3,4,5,6,7],[1,2,4,5,6,7],[1,2,3,5,6,7],[1,2,3,4,6,7],[1,2,...
15:36:15 <russo_> do i need to set export for the functions that i want
15:36:17 <elmaia> Hello
15:36:25 <elmaia> I almost did
15:36:29 <elmaia> take a look
15:36:39 <elmaia> shots :: Config -> [Stars]
15:36:41 <elmaia> shots c = let list = (xorAllOne c (xorAll c))
15:36:42 <elmaia>           in [x | x<-list, y<-c, strd(x) <= strd(y)]
15:36:54 <elmaia> *Nim> shots [(1,1,1),(2,1,2)]
15:36:57 <elmaia> [(1,1,2),(2,1,1),(2,1,1)]
15:37:03 <elmaia> Almost...
15:37:05 <Botty> russo_ - It's not required in an import, but its nice to keep the number of valid identifiers down
15:37:34 <russo_> Botty: did you see the error that i'm getting
15:41:05 <russo_> how would i prevent it from loading main... again
15:41:05 <glguy> elmaia: it's considered rude to paste large blocks of text like that, particularly when you do it over and over
15:41:05 <LordBrain> russo_: if you dont specify exports, everything is exported, and if you dont specify functions imported, everything is imported.
15:41:05 <elmaia> the right result, what I intend, should be [(2,1,1)]
15:41:05 <russo_> how do i specify exports? export <function> ?
15:41:05 <glguy> module MyModule (that, that, theother) where
15:41:05 <glguy> s/that/this
15:41:05 <LordBrain> russo_: you can only have one main function, and if you dont give the module a name, it will be the Main module, which you can only have one of
15:41:05 <LordBrain> so you want a line at the top that is something like
15:41:05 <russo_> LordBrain: how do i give it a module name?..
15:41:05 <russo_> export <filename>
15:41:05 <russo_> i dunno i should probably just listen :)
15:41:05 <LordBrain> module MusicFile where
15:41:05 <russo_> well i'm trying to load adiffernt program into MusicFile
15:41:05 <LordBrain> oh ok
15:41:05 <LordBrain> whats the name of hte file you want loaded?
15:41:05 <Johhaidiiijavall> what tails does ?
15:41:05 <russo_> S2M
15:41:05 <LordBrain> ok
15:41:05 <Johhaidiiijavall> not tail, tails
15:41:11 <LordBrain> does S2M contain haskell functions?
15:41:28 <LordBrain> (just checking here.. want to make sure we're on the same page)
15:41:51 <SamB_XP> tails flies around, sometimes carrying sonic ;-)
15:41:53 <russo_> LordBrain: i think i got it
15:41:55 <russo_> ty
15:42:07 <LordBrain> yw
15:43:38 <elmaia> Someone could help me with my program ?
15:51:07 <Pastorn> Just x >>= (\ x -> if (x == 0) then fail "zero" else Just (x + 1) ) <-- could someone please walk me through this?
15:51:19 <Pastorn> > Just 4 >>= (\ x -> if (x == 0) then fail "zero" else Just (x + 1) )
15:51:20 <lambdabot>  Just 5
15:51:26 <Pastorn> > Just 0 >>= (\ x -> if (x == 0) then fail "zero" else Just (x + 1) )
15:51:27 <lambdabot>  Nothing
15:51:38 <Pastorn> > Nothing >>= (\ x -> if (x == 0) then fail "zero" else Just (x + 1) )
15:51:39 <russo_> another question how do you generate a new line in haskell
15:51:40 <lambdabot>  Nothing
15:51:58 <Lemmih> russo_: "\n"?
15:52:07 <Pastorn> russo_: putStrLn ""
15:52:28 <Pastorn> > Nothing == Just 0
15:52:29 <lambdabot>  False
15:53:16 <Pastorn> it can't do that! it aint natural!!
15:56:43 <dcoutts> Igloo, you about? do you have any admin rights on darcs.haskell.org ? I'm trying to fix the gtk2hs bug tracker
15:57:22 <dcoutts> I'm trying to use sqlite to fix the gtk2hs db (ie delete all the spam)
15:57:38 <Igloo> I don't think I have anything you don't
15:57:41 <dcoutts> but the .db file isn't writable by me, only root and www-data
15:57:52 <dcoutts> Igloo, ok, I'll proj SyntaxNinja if he turns up
15:58:30 <dcoutts> @tell SyntaxNinja how goes it with getting trac 0.10 installed? (he says hopefully)
15:58:31 <lambdabot> Consider it noted.
15:59:21 <dcoutts> @tell I'm looking forward to the spam protection. In the mean time can I have write access to /srv/trac/gtk2hs/db/trac.db so that I can manually delete the spam tickets using the sqlite command line interface?
15:59:21 <lambdabot> Consider it noted.
15:59:25 <dcoutts> doh!
15:59:31 <dcoutts> @tell SyntaxNinja I'm looking forward to the spam protection. In the mean time can I have write access to /srv/trac/gtk2hs/db/trac.db so that I can manually delete the spam tickets using the sqlite command line interface?
15:59:32 <Igloo> :-)
15:59:32 <lambdabot> Consider it noted.
15:59:48 <Igloo> We need an @ask alias for @tell
16:00:03 <dcoutts> aye
16:00:19 <Lemmih> @ask Igloo Don't we have that already?
16:00:20 <lambdabot> Consider it noted.
16:01:23 <Igloo> Ah, we just need dcoutts to use it, then  :-)
16:01:24 <lambdabot> Igloo: You have 1 new message. '/msg lambdabot @messages' to read it.
16:01:33 <dcoutts> heh, ok
16:02:42 <SamB_XP> I think it is a psuedo-alias
16:08:43 <dons> today's paper: http://programming.reddit.com/info/rxqb/comments
16:08:47 <lambdabot> Title: Verifying Haskell programs by combining testing and proving [pdf] (reddit.com), http://tinyurl.com/vcz83
16:12:03 <Oejet> Ah, that is why the Haskell posts at Reddit have gotten so high scores lately. ;-)
16:12:20 <Johhaidiiijavall> What are segments? segments [3,4,5,5,1,2,3]  ==>  [[3,4,5,5],[1,2,3]]
16:12:43 <Johhaidiiijavall> segments [1,2,3,4]        ==>  [[1,2,3,4]]
16:12:51 <Johhaidiiijavall> segments [4,3,2,1]        ==>  [[4],[3],[2],[1]]
16:12:59 <Johhaidiiijavall> like what the hell
16:13:08 <LoganCapaldo> Can't you guess?
16:13:21 <Johhaidiiijavall> nothing comes to my mind
16:13:32 <LoganCapaldo> It looks like it finds sequences of increasing numbers to me
16:13:52 <LoganCapaldo> course that's just a guess
16:14:03 <LoganCapaldo> @hoogle segments
16:14:03 <lambdabot> Network.URI.normalizePathSegments :: String -> String
16:22:38 <psykotic> / let segments = foldr (\x y -
16:22:45 <psykotic> err, sorry, mischan
16:23:04 <dons> heh
16:23:32 <lispy> i think you need a scanl or unfoldr?
16:23:33 <lambdabot> lispy: You have 1 new message. '/msg lambdabot @messages' to read it.
16:23:39 <lispy> hah! i've got mail...
16:24:19 <lispy> eewww....a js backend for yhc
16:24:20 <psykotic> lispy: i don't think so. you can do a foldr with a seed of type ([[a]], Maybe a).
16:24:53 <psykotic> actually, foldl, not foldr, i guess
16:27:27 <Adamant> compile Haskell to Javascript
16:27:31 <psykotic> or it might be easier to do a split based on a zipWith (<=) xs (tail xs)
16:29:05 <lispy> what about a good old fashioned groupBy?
16:29:24 <lispy> > groupBy (<=) [4,3..1]
16:29:25 <lambdabot>  [[4],[3],[2],[1]]
16:29:32 <lispy> > groupBy (<=) [1..5]
16:29:34 <lambdabot>  [[1,2,3,4,5]]
16:29:40 <lispy> seems to work :)
16:29:51 <SamB_XP> > groupBy (<=) [1,2,3,4,5,1,0]
16:29:53 <lambdabot>  [[1,2,3,4,5,1],[0]]
16:30:00 <dons> psykotic: so what you hacking on today?
16:30:02 <lispy> oh deer
16:30:05 <lispy> er dear*
16:30:14 <dons> hey MP0, how's code?
16:30:29 <lispy> why did that one split funny?
16:30:34 <psykotic> dons: nothing yet, as i just woke up :)
16:30:38 <dons> me too!
16:30:42 <dons> ?time psykotic
16:30:44 <lambdabot> Local time for psykotic is Wed Nov 22 09:28:58
16:30:54 <dons> ?time dons
16:30:56 <lambdabot> Local time for dons is Wed Nov 22 11:27:26 2006
16:31:00 <dons> oh I didn't realise we had similar time zones.
16:31:04 <psykotic> i'm in korea
16:31:08 <SamB_XP> dons: don't you already know what time it is?
16:31:16 <dons> SamB_XP: I thought it was 10 actually
16:31:32 <dcoutts> g'morning dons
16:31:42 <dons> g'evening dcoutts
16:31:45 <dcoutts> :-)
16:31:52 <dons> I got the mail re. booking rooms. looks good.
16:31:56 <dons> what do the 'safety checks' involved?
16:32:00 <MP0> dons, code is good. I was playing with KAVA to try Scheme on java but it just makes me realize how good laziness and memoization is.
16:32:07 <dcoutts> dons, so we have that day ok, Terry replied to me to say he'll probably be there
16:32:18 <dons> ok
16:32:35 <dcoutts> dons, not sure exactly, I've never had it done, but I don't think it takes that long
16:32:45 <dons> i should draft an announce.
16:33:01 <dons> dcoutts: are we waiting on any other confirmation?
16:33:33 <dcoutts> dons, yes, the room I wanted isn't available but the secretary said we could almost certainly find another that is ok and move tables and chairs in as appropriate.
16:33:52 <dcoutts> dons, so I think it's safe to update the wiki and announce
16:33:59 <dons> ok.
16:34:04 <dons> update it to reflect what?
16:34:12 <dcoutts> erm
16:34:19 <dons> that the room is not the one that's on there?
16:34:34 <SamB_XP> that you don't know where you are meeting?
16:34:37 <lispy> i must be slow today
16:34:42 <lispy> can someone explain this to me?
16:34:42 <lispy> > groupBy (<) ([1..5] ++ [5,4..1])
16:34:44 <lambdabot>  [[1,2,3,4,5,5,4,3,2],[1]]
16:34:46 <dcoutts> dolio, I think it's just that we need people to register, with MAC addresses etc
16:34:48 <dcoutts> doh
16:34:51 <dcoutts> dons, ^^
16:34:55 <dons> ok
16:34:55 <SamB_XP> lispy: simple.
16:35:09 <SamB_XP> groupBy takes an equivalence relation, not a partial order!
16:35:20 <dcoutts> dons, and that they'll have to subject themselves (or their laptops) to electrical testing.
16:35:34 <lispy> > groupBy (<=) ([1..5] ++ [5,4..1])
16:35:35 <lambdabot>  [[1,2,3,4,5,5,4,3,2,1]]
16:35:54 <lispy> that fairs no better and isn't (<=) an equivalence relation?
16:35:56 <dons> dcoutts: ah electrical testing. interesting.
16:36:28 <dcoutts> dons, yes, it's a safety requirement that all stuff that is plugged into the mains in the building be checked prior to use.
16:36:51 <dcoutts> or it probably invalidates their fire insurance etc
16:36:54 <SamB_XP> lispy: what equivalence classes does (<=) give you?
16:36:56 <dcoutts> so they're quite anal about it
16:36:57 <dons> ok fair enough
16:37:06 <dons> yes, they're getting that way down here too
16:37:28 <greentea> Hi all.
16:37:32 <lispy> SamB_XP: in this case it appears to be Int ;)
16:37:42 <lispy> SamB_XP: as in everything ends up being equivalent
16:37:50 <dons> hey greentea
16:38:38 <LoganCapaldo> I just finished writing segments. Man, mine is way longer than your guys
16:38:50 <lispy> LoganCapaldo: well, mine is buggy ;)
16:39:13 <LoganCapaldo> @paste
16:39:13 <lambdabot> http://paste.lisp.org/new/haskell
16:39:44 <lisppaste2> LoganCapaldo pasted "segments" at http://paste.lisp.org/display/30419
16:41:22 <LoganCapaldo> As you can see, I tried to write imperative code recursively ;)
16:41:32 <lispy> LoganCapaldo: it would be easier to read if you use pattern matching instead of explicit case statements :)
16:41:42 <dons> heh, we've hit 400k hits on the haskell.org front page since March or so.
16:41:47 <SamB_XP> lispy: um, aren't equivalence relations required to be reflexive?
16:42:29 <lispy> SamB_XP: reflexive means x == y ===> y == x, right?
16:42:33 <dons> and 1,944,610 page views ws this year so far
16:42:40 <SamB_XP> lispy: yeah
16:42:54 <SamB_XP> I don't see that happening with <=!
16:42:54 <dcoutts> dons, we may want to be explicit about the numbers being limited to 20 and ask for email contact details so we can contact them if we have too many people and need to aks what people are interested in etc to narrow down the numbers etc.
16:42:58 <lispy> oh, actually, that's symmetric
16:43:10 <SamB_XP> lispy: oh, I guess I don't know my terms
16:43:14 <SamB_XP> however, that is what I meant
16:43:16 <dons> dcoutts: yes ok.
16:43:24 <dons> i think maybe a table on the registeratoin page with 20 slots
16:43:26 <lispy> SamB_XP: yeah, i figured that's the trouble spot :)
16:47:33 <dons> dcoutts: i'm a little concerned about putting my mac addresses on the web page...
16:47:52 <dcoutts> dons, mm, ok, then we need to accumulate them some other way
16:48:11 <dcoutts> dons, and full names and email addresses
16:48:21 <dons> yes. ok. mm
16:48:48 <dcoutts> dons, feel free to munge the registration page that I changed earlier
16:48:59 <dons> how about they email dons.hac07@ with the name, contact details, mac addresses
16:49:06 <dons> and add their name and a link to the web page to the registration page
16:51:12 <dcoutts> dons, ok with me
16:51:39 <psnl> dcoutts: the testing; any idea how to do it? is it a PAT test?
16:51:46 <dcoutts> dons, so long as I can get a complete list before the event starts that's fine.
16:51:50 <dons> yes ok.
16:52:02 <dons> i'll add a file to the hac07 darcs repo
16:52:07 <dons> and collect registratoin details there
16:52:10 <dcoutts> psnl, what's the context? I'm not sure what you're talking about.
16:52:13 <dcoutts> dons, great.
16:52:49 <psnl> dcoutts: 00:31 < dcoutts> dons, and that they'll have to subject themselves (or their laptops) to electrical testing.
16:53:20 <dcoutts> psnl, ah that, I don't actually know what it involves
16:53:36 <dcoutts> I could ask
16:53:57 <psnl> my guess is PAT
16:54:05 <dcoutts> it might be that tests done by other institutions would be transferable
16:54:15 <dcoutts> I guess I should check
16:54:19 <psnl> dcoutts: yeah
16:55:24 <lispy> i already know i'm a so-so conductor, but i'm not sure about my laptop :)
17:00:34 <lisppaste2> psykotic pasted "my segments" at http://paste.lisp.org/display/30421
17:01:12 <lispy> reverse!
17:01:18 <lispy> but that's strict...
17:02:35 <lispy> ?quote lispy
17:02:36 <lambdabot>  a := new Maybe(); a.envalue(1);
17:02:38 <psykotic> actually that could be done using foldr, i'm an idiot
17:02:38 <lispy> ?quote lispy
17:02:39 <lambdabot>  one thing that's funny about programming in haskell is, it's the only language i know where i sometimes rewrite code so it will work on 'inifinite' datastructures
17:02:43 <lispy> ^^^
17:03:35 <lisppaste2> psykotic annotated #30421 with "foldr version" at http://paste.lisp.org/display/30421#1
17:03:51 <Pete_I> shouldn't that be "infinite"?
17:03:52 <lispy> no we're talking
17:03:59 <lispy> Pete_I: yes
17:04:10 <lispy> Pete_I: hang out here enoguh and you'll know i can't spell ;)
17:04:20 <Pete_I> i'm noticing already :)
17:04:38 <Pete_I> *enough
17:04:48 <lispy> mostly it's just that my fingers dance faster than i can read it back...so i just let the typos happen...
17:07:59 <LoganCapaldo> psykotic: woah.
17:08:15 <psykotic> logan :)
17:08:21 <TomMD> Question: I have a module that is ment to interact with many different instances of itself.  I want to test the system out with a light weight inter module communication - I.e. I want to not execute 'n' binaries with IPC, but have the module instantiated 'n' times in one binary with a native haskell "IPC".
17:08:55 <TomMD> So, my problem is that the module has some globals (MVars).  How can I get each instantiation to use a different MVar and keep it in the same binary?
17:08:55 <psykotic> LoganCapaldo, the algorithm can be understood in imperative terms. the "state" of the folder is the list of segments built up so far, and the last element encountered.
17:09:21 <psykotic> LoganCapaldo, basically at each step you compare the current element to the last element and depending on the result you either put the element onto an existing segment, or start a new segment containing that element.
17:10:19 <elmaia> Hi
17:10:21 <elmaia> Me again
17:10:36 <LoganCapaldo> Ooooo, its not confusing my eyes just skimmed the "where" clause too fast and I didn't realize f did what it did :)
17:10:41 <elmaia> Other question, this I think it's easier
17:10:56 <LoganCapaldo> Still shorter than mine :)
17:11:08 <elmaia> I wan't to do a function that
17:11:21 <elmaia> f :: Int -> String
17:11:46 <elmaia> and F must do this :
17:12:10 <LoganCapaldo> @djinn Int -> String
17:12:11 <lambdabot> -- f cannot be realized.
17:12:17 <LoganCapaldo> darn
17:12:21 <dons> dcoutts: what's the wifi issue regarding "There is no guarantee that wireless will actually be available"?
17:12:34 <dons> does that mean we will have ether though?
17:12:35 <dons> no matter what.
17:12:38 <elmaia> f n = g 1 ( g 2 ( g 3 "Teste"))) where
17:12:40 <dcoutts> dons, the lab doesn't have wireless yet
17:12:48 <elmaia> g :: Int -> String
17:12:53 <dons> ok. but ether. so we could add our own access point if needed?
17:12:54 <dcoutts> dons, but wired can pretty much be guaranteed
17:13:08 <elmaia> and 1,2,3 are element from list [1..n]
17:13:16 <dons> ok
17:13:28 <elmaia> ?paste
17:13:28 <lambdabot> http://paste.lisp.org/new/haskell
17:13:35 <dons> dcoutts: so here's the new registration page: http://haskell.org/haskellwiki/Hac_2007/Registration
17:13:37 <lambdabot> Title: Hac 2007/Registration - HaskellWiki, http://tinyurl.com/yyf6zv
17:13:46 <dcoutts> dons, well the lab has not yet decided on its policy on wireless yet, some people have been using it ad-hoc but I don't know if the top admin chap will let us use it. It's hopeful though.
17:13:49 <dons> and i just sent a test mail to the hac07 address. does that contain all the info you need?
17:14:40 <dcoutts> dons, yes I think that's fine
17:14:48 <dons> ok
17:14:48 <lisppaste2> elmaia pasted "Funcion" at http://paste.lisp.org/display/30422
17:15:16 <elmaia> Someone can see pasted and help me ?
17:15:44 <Lemmih> elmaia: g :: Int -> String -> String?
17:15:58 <dcoutts> dons, hmm, we might not want to make it look like it's a first-come-first-served registration
17:16:09 <elmaia> Yes
17:16:12 <elmaia> sorry
17:16:15 <dcoutts> dons, ie having a list of 20 might not be best
17:16:17 <dons> dcoutts: right ok.
17:16:39 <dcoutts> dons, we should certainly say that it's limited to 20 as you have done though.
17:16:47 <dons> i'll remove the numbers then
17:16:57 <elmaia> Lemmih: Yes... Exactly
17:16:59 <dcoutts> dons, and say that if we are oversubscribed that we'll decide on some vaguely fair basis
17:17:12 <dons> ok
17:17:19 <dcoutts> dons, what is the basis on which we'll decide ?
17:17:55 <TomMD> dcoutts: is this as open as the hackathon or not?
17:18:07 <dcoutts> TomMD, we're limited to numbers, that's all
17:18:12 <dcoutts> it's otherwise open
17:18:13 <dons> I suppose similar to the SoC process
17:18:33 <dons> its open, but if we have >20 we'll need to prune based on core hacking ability, i suspect
17:18:38 <Lemmih> elmaia: Is it folding left or right?
17:18:59 <elmaia> The order no matter
17:19:06 <dcoutts> dons, and/or on if we have clumps of people who want to collaborate on a project
17:19:10 <dons> yes
17:19:24 <elmaia> Important is do that ,any way
17:19:45 <dcoutts> dons, so in the email a free-form description of what they're interested in would probably help
17:19:56 <dons> good idea
17:19:56 <elmaia> I think to use foldr, but g receive 2 parameters from diferent types
17:20:15 <Lemmih> elmaia: You should use 'foldr', not 'foldr1'.
17:20:21 <Lemmih> @type foldr
17:20:23 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
17:20:29 <lispy> TomMD: the only solutions i can think of to your problem is to model your desired solution using haskell data types (not the module system)
17:20:49 <elmaia> sorry
17:20:59 <elmaia> I didn't understand
17:22:12 <elmaia> Let me sse
17:22:17 <elmaia> Let me sse
17:22:19 <Lemmih> elmaia: You have a list [1 .. n] and a string "Teste". How does that fit with 'foldr'?
17:22:35 <TomMD> lispy: thanks, but for this case I can't see that being successful.  I am considering altering the code such that I have an arg (specifying which instance the module is) and a function that accesses the proper MVar in an array.  I was just hoping I could get away with not altering the code and just using some cool compile trick.
17:23:16 <elmaia> I put 1, 2 ,3 just to do easier to undestand, actually the first parameter is another Type
17:23:22 <lispy> TomMD: well, haskell modules behave like singletons
17:23:37 <lispy> TomMD: so i don't see how you can instance modules without a lot of tricks
17:23:53 <Lemmih> elmaia: You have a list [1,2,3] and a string "Teste". How does that fit with 'foldr'?
17:24:03 <elmaia> It's take a number and return the number in " " ++ with the second parameter
17:24:14 <elmaia> example
17:24:25 <elmaia> g 2 "Teste"
17:24:33 <elmaia> return "  Teste"
17:24:39 <TomMD> lispy: yes, so what I really mean to say is that I will have an array of states and and array for each "MVar" and pass in the state, alter the code to access the proper MVar.
17:25:29 <Lemmih> elmaia: We're trying to define 'f', right?
17:25:35 <elmaia> yes
17:26:20 <lispy> TomMD: so you're basically making an OO interpreter in your program? ;)
17:26:29 <Lemmih> elmaia: What's the type of "foldr g"?
17:27:00 <elmaia> I don't know, I know that g :: Int -> String -> String
17:27:16 <dons> dcoutts: ok, updated, http://haskell.org/haskellwiki/Hac_2007/Registration
17:27:19 <lambdabot> Title: Hac 2007/Registration - HaskellWiki, http://tinyurl.com/yyf6zv
17:27:25 <elmaia> anf f :: Int -> String
17:27:34 <Lemmih> And foldr has the type: (a -> b -> b) -> b -> [a] -> b
17:27:47 <elmaia> I think so
17:27:49 <elmaia> yes
17:28:33 <dcoutts> dons, ok, only edit I'll make is to remove the "Note that numbers are limited to 20." in the definately bit so it's clear it's not first-come first-served
17:28:49 <Lemmih> elmaia: The first argument to foldr must have the type 'a -> b -> b'. How does that type compare to the type of 'g'?
17:29:22 <dcoutts> dons, and perhaps change it from "definitely" to "definitely could make it" or something?
17:29:32 <dons> ok
17:29:45 <dons> you editing it/
17:29:59 <elmaia> I'll paste the code I did, I think is what you are trying to explain me, but I'm a newbee I not being able to explain
17:30:26 <TomMD> lispy: Arrr, don't phrase it like that!  I just have some functions, and they access MVars, and I want to run the function many times and have it not bother the MVar of the other (concurrent) run.  So I will be replacing every "{put,take}MVar m" with a "{put,take}MyMVar Id m" and start the whole thing up with a unique Id at each forkIO.
17:30:55 <dons> elmaia: you speak spanish? we also have a spanish-speaking haskell channel. /join #haskell.es
17:31:08 <elmaia> No
17:31:23 <elmaia> portuguese maybe :) ?
17:31:31 <dcoutts> dons, done editing
17:31:33 <lispy> TomMD: :) sorry, part of my comments is related to my ideas that haskell modules really want to be objects not modules...I want them to be first class, parameterizable and for you to be able to make as many as you want
17:31:35 <dons> ah sorry, portuguese :)
17:32:03 <dons> elmaia: yes, we don't have a channel yet for brazillians and portuguese, unfortunately
17:32:06 <dons> we should start one
17:32:06 <Lemmih> elmaia: If you aren't familiar with Haskell's type-system, you can always ask GHCi or Hugs.
17:32:21 <elmaia> I use
17:32:31 <elmaia> GHCi
17:32:45 <Lemmih> @type foldr (undefined :: Int -> String -> String)
17:32:46 <lambdabot> String -> [Int] -> String
17:32:52 <elmaia> ?paste
17:32:53 <lambdabot> http://paste.lisp.org/new/haskell
17:33:10 <dons> dcoutts: ok. good. i'll draft an announce
17:33:16 <dcoutts> dons, great
17:33:38 <elmaia> Yes
17:33:42 <elmaia> I did it
17:33:53 <elmaia> where undefined is my g
17:34:10 <elmaia> printGame :: Int -> IO ()
17:34:12 <elmaia> printGame n = foldr g (concat (map (++"\n") (map n2String [1..n]))) [1..n] where
17:34:14 <elmaia>    g a s = (n2String a) ++ s
17:34:33 <elmaia> n2String :: Int -> String
17:34:35 <elmaia> n2String n = concat (map f [1..n]) where
17:34:36 <elmaia>    f _ = ['*']
17:34:44 <elmaia> Sorry for the code in channel
17:34:53 <elmaia> but ?paste is not working
17:35:03 <TomMD> why isn't -fglasgow-exts a default flag these days?
17:35:19 <lispy> TomMD: that's the point of haskell' ;)
17:35:22 <TomMD> Not that it is a big deal, but I think everyone assumes it.
17:35:25 <TomMD> lol, ok, fine.
17:35:56 <dons> basically because then ghc wouldn't behave like nhc,yhc,jhc,hugs,hbi,hbc,...
17:37:25 <elmaia> Lemmih
17:37:27 <Igloo> dons: If numbers are a problem then knowing what dates people can make might be useful
17:37:32 <Lemmih> elmaia: Yes?
17:37:36 <elmaia> I found my mistake
17:37:45 <Lemmih> elmaia: Good.
17:37:46 <elmaia> printGame :: Int -> IO ()
17:37:57 <elmaia> printGame :: Int -> String
17:38:08 <elmaia> or put putStr before my foldr
17:38:18 <elmaia> thanks to help me
17:38:20 <xinming> seen Pastorn
17:38:23 <elmaia> for help me
17:38:38 <Pastorn> hee
17:38:39 <Pastorn> here
17:38:41 <xinming> ?seen Pastorn
17:38:42 <lambdabot> Pastorn is in #darcs, #haskell-blah and #haskell. I last heard Pastorn speak 2s ago.
17:38:44 <dons> Igloo: good idea. i'll add a field
17:38:51 <xinming> Pastorn: hi, I'm back. :-P
17:38:56 <xinming> Pastorn: what's the time there?
17:39:02 <dons> hey xinming noclouds
17:39:05 <Pastorn> secret
17:39:06 <dons> grr. tabs1
17:39:14 <elmaia> Someone here use LINUX and GHT2HS or WXHASKELL ?
17:39:39 <dons> probably not in capitals :)
17:39:55 <Pastorn> xinming: where we were before
17:40:18 <xinming> Pastorn: bbl, need to go wc...
17:40:22 <xinming> :-P
17:41:14 <greentea> dons: When i see names like that in all caps, i start thinking that the person writing them must be a COBOL or FORTRAN programmer. ;-)
17:42:08 <SamB_XP> what about UNIX
17:42:29 <elmaia> yes
17:42:37 <elmaia> I program in FORTRAN  :)
17:42:50 <greentea> :-D
17:43:18 <elmaia> but it's not becouse of this, is just to see BETTER :)
17:43:28 <greentea> SamB_XP: Personally, i write 'Unix' rather than 'UNIX' . . . . but this is getting OT. :-)
17:43:32 <greentea> elmaia: Ah. :-)
17:43:35 <psykotic> on the other hand, to some of us it looks like you're SHOUTING
17:43:36 <psykotic> :)
17:43:49 <elmaia> but
17:43:59 <elmaia> some one use Linux and gtk2hs or wxhaskell ?
17:44:05 <elmaia> someone use Linux and gtk2hs or wxhaskell ?
17:44:14 <dcoutts> yep, linux and gtk2hs
17:44:45 <dcoutts> elmaia, well actually, gtk2hs and linux, windows and solaris :-)
17:44:46 <SamB_XP> wxHaskell, it is called
17:44:55 <SamB_XP> but I don't actually use it
17:45:09 <dcoutts> (Gtk2Hs technically too but I tend not to complain)
17:45:19 <elmaia> becouse I use Slackware and gtk2hs doesn't compile here
17:45:32 <dcoutts> elmaia, can you paste the error
17:45:33 <dcoutts> @paste
17:45:34 <lambdabot> http://paste.lisp.org/new/haskell
17:45:55 <elmaia> and wxHaskell gives me Segmantion fault in all programs, 'till HelloWorld
17:47:53 <elmaia> just a minute
17:47:56 <elmaia> is compiling
17:49:24 <lisppaste2> elmaia pasted "Error compiling gtk2hs" at http://paste.lisp.org/display/30424
17:49:29 <elmaia> here
17:49:47 <dcoutts> elmaia, if you're using ghc-6.6 then you need the latest darcs version of gtk2hs
17:49:48 <elmaia> And I checked, this file is not in the directory
17:49:54 <elmaia> sim
17:50:00 <elmaia> both
17:50:06 <elmaia> latest version
17:50:54 <dcoutts> elmaia, you're using the latest released version, 0.9.10. That version does not build with ghc-6.6. You need the latest darcs version of Gtk2Hs to use ghc-6.6.
17:51:13 <elmaia> what adress ?
17:51:27 <elmaia> http://darcs.haskell.org/gtk2hs ?
17:51:29 <lambdabot> Title: Index of /gtk2hs
17:51:31 <elmaia> address
17:51:36 <dcoutts> elmaia, http://haskell.org/gtk2hs/development/#development
17:51:39 <lambdabot> http://tinyurl.com/ycs6n2
17:52:00 <dcoutts> elmaia, yes, that's the darcs repo, as linked from the dev page on the gtk2hs site
17:52:42 <elmaia> I'll try again
17:52:55 <elmaia> But I have tried that
17:55:37 <elmaia> " /usr/local/share/aclocal/ccstdc.m4:23: warning: underquoted definition of AM_PROG_CC_STDC
17:55:38 <elmaia> configure.ac:117: error: possibly undefined macro: AC_MSG_ERROR
17:55:39 <elmaia>       If this token and others are legitimate, please use m4_pattern_allow.
17:55:41 <elmaia>       See the Autoconf documentation.
17:55:43 <elmaia> autoreconf: /usr/local/bin/autoconf failed with exit status: 1
17:55:44 <elmaia> elmaia@pentiumiii:~/gtk2hs>
17:56:18 <dcoutts> elmaia, you're probably using an old version of automake, see the bit about debian and automake-1.9
17:56:36 <dcoutts> try doing automake-1.9 and then run autoreconf again
17:56:46 <elmaia> elmaia@pentiumiii:~/gtk2hs> automake --version
17:56:47 <elmaia> automake (GNU automake) 1.9.6
17:56:49 <elmaia> Written by Tom Tromey <tromey@redhat.com>.
17:57:55 <dcoutts> elmaia, try running automake-1.9 or similar. I've seen plenty of systems which lie about the version that get's invoked by default. Debian is worst for that.
17:58:38 <elmaia> I use Slackware, I was me that instaled automake
17:58:39 <lispy> elmaia: people have done studies showing that lower case letters are actually easier for people to read :)
17:58:39 <elmaia> That's is the true version
17:58:55 <elmaia> lispy :)
17:59:12 <dcoutts> elmaia, so does running automake work then?
17:59:14 <elmaia> I'll try to use only lowercase
17:59:26 <dcoutts> elmaia, and it needs autoconf-2.58 or later
17:59:32 <dcoutts> which you've probably got
17:59:46 <elmaia> elmaia@pentiumiii:~/gtk2hs> autoconf --version
17:59:48 <elmaia> autoconf (GNU Autoconf) 2.60
17:59:49 <elmaia> Written by David J. MacKenzie and Akim Demaille.
18:00:00 <dcoutts> elmaia, I've seen lots of systems where there is the right version of automake installed but when you run it, it still runs an old version.
18:00:07 <elmaia> I have all pre-req...
18:00:56 <dcoutts> elmaia, so does running automake work then?
18:01:10 <SamB_XP> lispy: they needed to do studies to figure this out?
18:01:35 <elmaia> dcoutts: What ?
18:01:44 <lispy> SamB_XP: strictly speaking, the scientific method says that you need to prove everything
18:01:53 <lispy> SamB_XP: so yes :)
18:02:05 <SamB_XP> lispy: prove causality!
18:02:07 <dcoutts> elmaia, ie running automake-1.9 or just automake. Does that complain with the same error message?
18:02:25 <lispy> SamB_XP: prove the scientific method!
18:02:27 <dcoutts> if that works ok then run autoreconf again
18:02:32 <SamB_XP> lispy: exactly!
18:02:35 <elmaia> I have no automake-1.9
18:02:42 <elmaia> just automake
18:02:46 <SamB_XP> if you can't prove that, you can't prove everything
18:02:55 <elmaia> I use Slack, Debin that put sufix in words
18:03:07 <elmaia> I have just one automake
18:03:15 <lispy> SamB_XP: hang on, i'll work on it as soon as i get done solving this halting problem
18:03:22 <SamB_XP> heh
18:03:37 <SamB_XP> how about that incompetence theorem?
18:03:39 <dcoutts> elmaia, so, does it give the same error message or not ?
18:03:52 <dons> dcoutts, Igloo: draft announce: http://www.cse.unsw.edu.au/~dons/code/hac07/announce.txt
18:03:54 <lambdabot> http://tinyurl.com/y5ge7t
18:03:54 <elmaia> yes
18:03:55 <dons> opinions?
18:03:57 <elmaia> same error
18:04:06 <elmaia> automake and autoreconf
18:04:23 <dons> ?join #haskell.hac07
18:04:49 <elmaia> checking for ghc-pkg... /usr/local/bin/ghc-pkg
18:04:50 <elmaia> ./configure: line 4839: syntax error near unexpected token `GLIB,glib-2.0'
18:04:52 <elmaia> ./configure: line 4839: `PKG_CHECK_MODULES(GLIB,glib-2.0 >= 2.0.0 gobject-2.0 >= 2.0.0, , { { echo "$as_me:$LINENO: error:'
18:05:07 <elmaia> cd ~/gtk2hs
18:05:08 <elmaia> automake
18:05:10 <elmaia> ./configure
18:05:13 <elmaia> That error
18:05:17 <SamB_XP> since you can't prove everything, you had better not need to...
18:05:23 <lispy> how do they consider this an intro tutorial? http://resources.businessobjects.com/labs/cal/tutorial_calintro.html
18:05:25 <lambdabot> Title: Tutorial_CalIntro.cal, http://tinyurl.com/v324x
18:05:27 <elmaia> autoreconf the oher error
18:05:33 <elmaia> other
18:05:42 <dcoutts> elmaia, ah, perhaps the real error is that you don't have pkg-conf installed
18:05:55 <SamB_XP> and since you don't need to prove everything, you need to figure out what stuff is stuff you should try to prove
18:06:00 <lispy> "Here is a Prelude.hs, it's an intro to haskell!"
18:06:03 <dcoutts> elmaia, pkg-config installs some automake macros, like PKG_CHECK_MODULES
18:06:19 <elmaia> pkg-config
18:06:24 <elmaia> let me see
18:07:22 <elmaia> elmaia@pentiumiii:~/gtk2hs> pkg-config --version
18:07:23 <elmaia> 0.15.0
18:07:46 <dcoutts> elmaia, I've got 0.20
18:09:05 <dcoutts> dons, "announce that the" grammar is a bit dodgy there.
18:09:21 <dons> dcoutts: --> #haskell.hac07
18:09:33 <fons> hi all
18:09:39 <dcoutts> dons, I don't understand
18:09:53 <dons> hac07 channel :)
18:10:01 <dcoutts> ah
18:10:28 <elmaia> 'll try 0.21 now
18:11:06 <dcoutts> elmaia, are you involved with packages for slackware at all? we could try and make this process easier for slackeare users. Mind you with a released tarball it's much easier anyway.
18:11:24 <greentea> Hi fons.
18:11:32 <elmaia> tar.gz
18:11:36 <elmaia> not .tgz
18:11:47 <elmaia> tarball, ./configure and make, make install
18:12:13 <fons> can anyone tell me why ghc calls the C compiler (for compiling the FFI stubs at least)   with -mdynamic-no-pic ?
18:13:08 <fons> it prevents creating dynamicaly loadable modules (bundles) including haskell code
18:13:14 <dmead> hi kids
18:13:39 <fons> which on the other hand is completely plausible in Linux at least
18:14:21 <fons> (through -optl -shared)
18:14:24 <elmaia> Exist some funcion in Prelude that replace String for String ? some like replace :: String -> String -> String ?
18:15:36 <lispy> ?hoogle String -> String -> STring
18:15:37 <lambdabot> No matches, try a more general search
18:15:40 <lispy> ?hoogle String -> String -> String
18:15:41 <lambdabot> Distribution.PreProcess.Unlit.plain :: String -> String -> String
18:15:41 <lambdabot> Distribution.PreProcess.Unlit.unlit :: String -> String -> String
18:15:41 <lambdabot> Text.Regex.subRegex :: Regex -> String -> String -> String
18:16:02 <lispy> elmaia: we have Regexs apparently ^^
18:17:51 <elmaia> Same error
18:18:05 <elmaia> elmaia@pentiumiii:~/gtk2hs> pkg-config --version
18:18:07 <elmaia> 0.21
18:18:58 <dcoutts> elmaia, so what exactly is the error now? the one about PKG_CHECK_MODULES or the one about AC_MSG_ERROR ?
18:19:03 <elmaia> yes
18:19:16 <dcoutts> which one ?
18:19:52 <elmaia> ./configure: line 4839: `PKG_CHECK_MODULES(GLIB,glib-2.0 >= 2.0.0 gobject-2.0 >= 2.0.0, , { { echo "$as_me:$LINENO: error:'
18:24:11 <elmaia> and wxHaskell ?
18:24:22 <elmaia> I have problem with this
18:24:30 <elmaia> And I prefer wxHaskell
18:24:41 <elmaia> could someone help me ?
18:25:12 <elmaia> gtk2hs doesn't work and I'm almost giving up.
18:25:38 <dcoutts> elmaia, or you can try this recent gtk2hs .tar.gz snapshot:
18:25:50 <dcoutts> http://haskell.org/~duncan/gtk2hs/gtk2hs-0.9.10.2.tar.gz
18:25:52 <lambdabot> http://tinyurl.com/ycmua5
18:25:58 <dcoutts> so no messing with automake
18:26:07 <elmaia> I tried
18:26:21 <elmaia> doesn't work
18:26:26 <elmaia> too :)
18:26:47 <elmaia> wxHaskell, someone ?
18:27:19 <Pastorn> heh...
18:27:23 <dcoutts> elmaia, wxHaskell doesn't work wit ghc-6.6 either I think
18:27:34 <dcoutts> unless someone has fixed it very recently and not told me
18:27:51 <Pastorn> elmaia: do NOT use wxHaskell with ghc 6.2 or 6.4
18:27:55 <elmaia> someone added a patch in darcs to work
18:28:16 <elmaia> I saw in Haskell-Cafe
18:28:21 <Pastorn> elmaia: i have a linky for you
18:28:36 <elmaia> send me
18:30:00 <Pastorn> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/funht/ <-- beginners course... has wxHaskell info (and a link to a very good wxHaskell tutorial at one of the last pages in one of the pdf/ppt-files)
18:30:03 <lambdabot> Title: Introduction to Functional Programming (TDA555/INN040ht) -- HT2006, http://tinyurl.com/yxsy2x
18:30:40 <elmaia> Thanks a lot
18:30:43 <Pastorn> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/ <-- also has some stuff on wxHaskell... the lecture ppts are nice
18:30:46 <lambdabot> Title: Advanced Functional Programming -- HT2006, http://tinyurl.com/ttog6
18:30:55 <elmaia> but my problem is do wxHaskell woks
18:31:03 <Pastorn> ??
18:31:06 <elmaia> works
18:31:10 <lispy> elmaia: it works
18:31:19 <elmaia> my wxHaskell doesn't works
18:31:30 <lispy> but a better phrasing would be: "but my question is, does wxHaskell work"
18:31:46 <psnl> anyone used Text.Regex ?
18:31:57 <lispy> psnl: someone has ;) but not me
18:32:04 <elmaia> configuration:
18:32:05 <elmaia>  library:     wxhaskell-0.10.1  (release 0)
18:32:07 <elmaia>  compiler:    ghc-6.6
18:32:08 <elmaia>  wxwidgets:   gtk-2.7.1
18:32:10 <elmaia>  with openGL: no
18:32:12 <elmaia>  library dir: /usr/local/lib
18:32:12 <Pastorn> there is some info on that on the last link
18:32:21 <elmaia> I had this after ./configure
18:32:22 <elmaia> let's try make now
18:33:02 <Pastorn> the guy who holds the course created it (or at least had very much to say)
18:33:07 <elmaia> no
18:33:07 <lispy> elmaia: where did you get your copy of wxhaskell? the one at sf.net doesn't appear to work with ghc6.6
18:33:10 <elmaia> problem
18:33:32 <elmaia> darcs get http://darcs.haskell.org/wxhaskell
18:33:34 <lambdabot> Title: Index of /wxhaskell
18:34:00 <lispy> elmaia: okay, that should be the new version, but i haven't played with that one so i won't be much help
18:34:05 <elmaia> "
18:34:06 <elmaia> /usr/local/include/wx-2.7/wx/html/htmlwin.h:208: error:   overriding 'virtual bool wxHtmlWindowMouseHelper::OnCellClicked(wxHtmlCell*, wxCoord, wxCoord, const wxMouseEvent&)'
18:34:08 <elmaia> wxc/src/extra.cpp: In function 'long int wxGetNumberFromUser(wxChar*, wxChar*, wxChar*, long int, long int, long int, wxWindow*, int, int)':
18:34:09 <elmaia> wxc/src/extra.cpp:1910: error: cannot convert 'wxPoint' to 'int' for argument '8' to 'long int wxGetNumberFromUser(wxChar*, wxChar*, wxChar*, long int, long int, long int, wxWindow*, int, int)'
18:34:11 <elmaia> make: ** [out/wxc/extra.o] Erro 1
18:34:34 <lispy> elmaia: hmm...i dunno, i haven't seen that one yet
18:34:37 <elmaia> I tried with ghc 6.2
18:35:05 <Pastorn> if you look at the latter of the two links you will see that that will not work
18:35:07 <elmaia> with ghc 6.2 compile
18:35:33 <elmaia> but... all programs, 'till HelloWorld gives me SEGMANTION FAULT
18:35:35 <dcoutts> @seen SyntaxNinja
18:35:36 <lambdabot> I saw SyntaxNinja leaving #haskell and #darcs 1d 21h 3m 53s ago, and .
18:36:05 <Pastorn> yes... we have a similar problem at school
18:37:16 <elmaia> and ...
18:37:18 <Pastorn> if we start a wx program from GHCI we have to restart ghci for every new testing
18:37:53 <elmaia> did it fix  ?
18:38:08 <elmaia> ghci and ghc
18:38:13 <elmaia> segmantion fault
18:38:20 <elmaia> both
18:38:40 <elmaia> and 6.6 ... no compile
18:39:04 <Pastorn> as i have said two times already: READ ON THE PAGE I LINKED TO
18:39:12 <elmaia> I having a lot of problem with GUI
18:39:28 <lispy> elmaia: does this segfault? ghc -e 'putStrLn "hello, world"'
18:40:43 <elmaia> no
18:40:53 <lispy> okay, so hello world works
18:40:57 <elmaia> just using wx and wxcore package
18:41:07 <elmaia> helloWorld using wxHaskell
18:41:25 <lispy> does 'ghc -package wxhaskell' cause a problem?
18:41:31 <elmaia> yes
18:41:34 <elmaia> seg fault
18:41:41 <lispy> okay, then look at Pastorn's link
18:41:44 <elmaia> it's compile
18:41:54 <elmaia> but run the program... seg fault
18:42:03 <lispy> look at Pastorn's link
18:42:13 <Pastorn> four times...
18:42:14 <elmaia> I looked
18:42:25 <elmaia> but it's very big
18:42:36 <elmaia> Pastorn, can you direct me ?
18:42:44 <Pastorn> just click on something that says wxHaskell
18:42:50 <dons> elmaia: you need to write some more code, then get back to us
18:42:59 <dons> we can't help unless you make some progress on your own
18:43:14 <dons> (asking the same thing over and over is only going to annoy people)
18:44:02 <elmaia> Pastorn
18:44:04 <elmaia> 2 links
18:44:06 <elmaia> first
18:44:14 <elmaia> wxHaskell sourceforge
18:44:27 <elmaia> 2nd: wxHaskell example
18:44:30 <Pastorn> nah... the SECOND of those i pasted
18:44:39 <elmaia> let me see
18:44:52 <Pastorn> on the page you get to click on wxHaskell somewhere
18:47:34 <lispy> elmaia: you may also want to look at this solution http://www.haskell.org/pipermail/glasgow-haskell-bugs/2005-October/005639.html
18:47:37 <lambdabot> Title: GHC 6.5 (Visual Haskell) bug with wxHaskell, http://tinyurl.com/y4kjl7
18:48:32 <elmaia> Pastorn
18:48:43 <elmaia> there tell me to use ghc 6.4
18:48:47 <elmaia> just this
18:48:55 <elmaia> I had tried this too
18:49:14 <elmaia> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/wxhaskell.html
18:49:16 <lambdabot> Title: Advanced Functional Programming -- HT2006 -- WxHaskell, http://tinyurl.com/y2u223
18:49:36 <elmaia> same link
18:49:36 <lispy> SM>   $ ghc-pkg describe wxcore >wxcore.pkg
18:49:36 <lispy> SM>   ... edit wxcore.pkg to remove lang dependency ...
18:49:36 <lispy> SM>   $ ghc-pkg update wxcore.pkg
18:49:37 <lispy> Okay, after removing both lang and concurrent from the wxcore
18:49:41 <lispy> dependencies, everything works (at least as of now). Thanks.
18:50:32 <lispy> no more help from me until you've used to use ghc-pkg to check if the package wrongly has a lang or concurrent dependency
18:50:43 <elmaia> lispy
18:50:45 <elmaia> Windows
18:50:48 <elmaia> I use LINUX
18:50:55 <lispy> i don't care
18:51:01 <elmaia> doesn't work
18:51:06 <elmaia> I had tried to
18:51:08 <elmaia> too
18:51:24 * lispy goes back to his work
18:52:11 <elmaia> my work depends on gtk2hs or wxHaskell
18:52:24 <elmaia> And I'll repeat
18:52:28 <elmaia> My program compile
18:52:38 <Pastorn> go to #ghc
18:52:38 <Excedrin> do you get paid for your work?
18:52:40 <elmaia> the problem is when run
18:53:02 <elmaia> no
18:53:09 <elmaia> University
18:53:09 <dons> elmaia: can you write up your problem and email haskell-cafe@haskell.org please?
18:53:16 <elmaia> dons
18:53:21 <dons> you'll get a considered response that way
18:53:21 <elmaia> tried too
18:53:27 <lispy> if you had really looked at the solution i was showing you, you'd see that it fixes a problem where wxhaskell programs compile but do not run
18:53:28 <elmaia> :)
18:55:02 <elmaia> >> Compilation error message from ghc -v -package wx:
18:55:05 <elmaia> >> Glasgow Haskell Compiler, Version 6.5, for Haskell 98, compiled by
18:55:06 <elmaia> >> GHC version 6.4 Using package config file: c:\Program Files\Visual
18:55:15 <elmaia> The link you post had this
18:55:27 <elmaia> Compilation error
18:57:22 <lispy> well, look at that command line
18:57:27 <lispy> no files were specificed
18:57:31 <lispy> i asked you to run the same test
18:57:39 <lispy> you also received a crash from ghc
18:57:46 <hyrax42> wow
18:58:07 <hyrax42> I'm just reading (the start of) the Awkward Squad
18:58:10 <lispy> the problem fixed in that thread was that at run-time ghc couldn't load the right libraries to run the wxhaskell problem
18:58:17 <hyrax42> truly 'twere dark ages before Haskell 98
18:58:27 <hyrax42> main :: [Response] -> [Request]?
18:58:39 <hyrax42> eek
18:59:36 <complaisant> hi.. need some help here
18:59:49 <hyrax42> ?paste
18:59:50 <lambdabot> http://paste.lisp.org/new/haskell
19:00:01 <greentea> hyrax42: Yes, i must admit that when i read that, i wondered how Haskell was at all usable in its earlier forms.:-)
19:00:17 <complaisant> i need to make a function using mod that uses generates values between [97-122] like this
19:00:31 <hyrax42> I'm tempted to track down the Hudak paper that surveys the pre-monadic era
19:00:35 <complaisant> cicle 124 97 122 = 98
19:00:49 <hyrax42> (it's no mistake that it sounds like a geological age!)
19:00:52 <lispy> > concatMap chr [97..122]
19:00:53 <lambdabot>  Couldn't match `[b]' against `Char'
19:00:54 <psnl> : undefined reference to `regexzmcompatzm0zi71_TextziRegex_mkRegex_closure'
19:00:59 <psnl> mutter mutter
19:01:39 <lispy> > map chr [97..122]
19:01:40 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
19:01:55 <hyrax42> > chr 48
19:01:56 <complaisant> > mod 100 2
19:01:56 <lambdabot>  '0'
19:01:57 <lambdabot>  0
19:01:59 <hyrax42> ahhh
19:02:13 <hyrax42> I remember ascii 48 as being interesting , and that must be why
19:02:15 <complaisant> > "ola"
19:02:17 <lambdabot>  "ola"
19:02:18 <greentea> hyrax42: Yes, the introduction of monads to Haskell comes across as the equivalent of the Cambrian explosion. :-)
19:02:39 <hyrax42> quite
19:02:54 <hyrax42> perhaps we should start a taxonomy of monads
19:03:04 <jdev> > map (chr.(+97).(`mod`26).(-97).ord) "hello, world!"
19:03:05 <lambdabot>  add an instance declaration for (Num (Int -> Int))
19:03:09 <lispy> > (124 + 97) `mod` 122
19:03:11 <lambdabot>  99
19:03:18 <jdev> Oh.
19:03:18 <dibblego> does the language provide anything extra for monads besides do?
19:03:39 <greentea> dibblego: Well, exceptions are implemented via monads, no?
19:03:40 <hyrax42> were typeclasses present in the pre-monadic era?
19:03:41 <greentea> (For example.)
19:04:04 <hyrax42> * in the standard haskell of the time
19:04:06 <jdev> @ty (- 97)
19:04:07 <lambdabot> forall a. (Num a) => a
19:04:14 <dibblego> greentea, they are all just functions afaik
19:04:37 <hyrax42> ?t subtract
19:04:37 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
19:04:42 <hyrax42> ?ty subtract
19:04:43 <lambdabot> forall a. (Num a) => a -> a -> a
19:04:44 <jdev> > map (chr.(123-).(`mod`26).(123-).ord) "hello, world!"
19:04:46 <lambdabot>  "helloznworldo"
19:04:53 <greentea> dibblego: Sorry, what are all functions?
19:05:01 <hyrax42> ?ty (`subtract` 97)
19:05:03 <lambdabot> forall a. (Num a) => a -> a
19:05:05 <jdev> > map (chr.(123-).(`mod`26).(136-).ord) "hello, world!"
19:05:06 <dibblego> greentea, the implementation of exceptions, there is nothing in the language
19:05:08 <lambdabot>  "uryybm{jbeyqb"
19:05:09 <complaisant> HELP : i need a function that given a value X and a range LOWER , UPPER gives the value X between in that range.. can anyone help me with this? i know that i can do that with mod but i don't remember the calculations
19:05:23 <hyrax42> that is something that has sort of bothered me
19:05:30 <hyrax42> haskell exceptions cannot give a trace, can they?
19:05:33 <psykotic> @type min
19:05:35 <lambdabot> forall a. (Ord a) => a -> a -> a
19:05:43 <greentea> dibblego: Yes, that's my understanding too; monads are used to implement them.
19:05:53 <dons> hyrax42: yeah, typeclsases go back to 88 or so
19:05:57 <dibblego> greentea, right, so nothing that the languages provides
19:05:59 <greentea> Basically, i view monads as being devices to give one more control over how the language works.
19:06:00 <dons> monads circa 92
19:06:09 <dibblego> there are no keywords for example related to exceptions
19:06:13 <psykotic> complaisant, clamp lo hi x = max lo (min hi x)
19:06:22 <dons> right, since you implement them on top of monads, dibblego  :)
19:06:36 <dibblego> ok, so 'do' is the only language feature related to monads?
19:06:47 <dons> basically, yeah.
19:06:51 <lispy> dibblego: the IO monad is built in, iirc
19:06:52 <dibblego> ok thanks
19:07:02 <dons> (think of monad comprehension syntax, or the RealWorld# token in GHC)
19:07:08 <dibblego> thanks lispy
19:07:11 <jdev> @scheck map (chr.(122-).(`mod`26).(135-).ord) "teststring" == "grfgfgevat"
19:07:11 <dons> but in terms of what's in h98, there's not that much
19:07:13 <lambdabot>  Completed 1 test(s) without failure.
19:07:26 <lispy> complaisant: you want a random number generator?
19:07:30 <complaisant> no no..
19:07:31 <lispy> ?type randomRs
19:07:33 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
19:07:37 <complaisant> its like this..
19:07:42 <psykotic> complaisant, don't the clamp i posted do what you want?
19:07:46 <complaisant> no..
19:07:56 <lispy> > (124 + 97) `mod` 122 -- not what you want either?
19:07:57 <complaisant> i want it to produce alphas
19:07:57 <lambdabot>  99
19:08:10 <complaisant> so i want it to b in the range of [97-122]
19:08:23 <lispy> what are alphas?
19:08:24 <complaisant> if the number is 123 it should produce 97
19:08:38 <complaisant> alphabet
19:08:43 <dibblego> an Italian car manufacturer
19:08:54 <hyrax42> that's alfa
19:09:05 <dibblego> that's Ferrari
19:09:07 <lispy> > (123 - 97) `mod` (122-97+1) + 97
19:09:09 <lambdabot>  97
19:09:36 <lispy> that would be my guess at what you want given that description
19:10:50 <complaisant> yes lispy
19:10:59 <lispy> complaisant: does it make sense to you
19:11:49 <lispy> for one it should be painfully obviously why those numbers give 97 :)
19:12:07 <lispy> ie, 123 - 97 = 122 - 97 + 1
19:13:42 <lispy> ?let rangeMod lo hi v = ((v - lo) `mod` (hi - lo + 1)) + lo
19:13:44 <lambdabot> Defined.
19:14:08 <lispy> rangeMod 100 97 122
19:14:21 <lispy> > rangeMod 97 122 100
19:14:21 <lambdabot>  Not in scope: `rangeMod'
19:14:25 <lispy> > L.rangeMod 97 122 100
19:14:27 <lambdabot>  100
19:14:55 <jdev> > map (chr.(122-).(`mod`26).(246-)) $ zipWith (+) (map ord "verysecrettestmessage") (map ord $ fix ("signal"++))
19:14:57 <lambdabot>  "mlwkrotyjfsojarqrcrnj"
19:15:20 <lispy> ?check \x -> x >= 97 && x <= 122 ==> L.rangeMod 97 122 (x::Int) == x
19:15:22 <lambdabot>  Arguments exhausted after 0 tests.
19:15:52 <dons> ?scheck \x -> x >= 97 && x <= 122 ==> L.rangeMod 97 122 (x::Int) == x
19:15:53 <lambdabot>  Completed 10 test(s) without failure.  But 10 did not meet ==> condition.
19:15:58 <dons> scheck ++
19:16:20 <jdev> Bah.  Off-by-one from excessive cuteness.
19:16:26 <jdev> > map (chr.(122-).(`mod`26).(245-)) $ zipWith (+) (map ord "verysecrettestmessage") (map ord $ fix ("signal"++))
19:16:27 <lambdabot>  "nmxlspuzkgtpkbsrsdsok"
19:16:59 <lispy> so is "signal" your salt?
19:17:00 <jdev> There.  Now Haskell is up to semi-ancient standards of cryptography.  (-:
19:17:43 <lispy> heh, and it does modern too: http://files.codersbase.com/rsa.hs
19:18:01 <dibblego> ?type return
19:18:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
19:18:52 <lispy> rsa :: (Int, Int) -> Integer -> Integer
19:18:52 <lispy> rsa (n, e) mesg = (toInteger(mesg)^(toInteger(e))) `mod` toInteger(n)
19:19:08 <lispy> i should fix this implementation up some day and make it actually work
19:19:24 <lispy> i have a strong pseudo prime generator in haskell that i can make it talk to for keys
19:23:31 <lispy> i wrote that RSA to demonstrate that i knew haskell
19:23:39 <lispy> was a fun assignment
19:23:43 <lispy> we also had to prove we learned lisp
19:24:28 <lispy> so i wrote a program, about 30-40 lines which read itself in, did a recursive tree search on its own source, found the symbol waldo and returned itself wrapped in another program which when evaluated would return the symbol waldo :)
19:24:56 <fons> I'm running osx and ghc doesn't accept -dynamic :(
19:25:04 <lispy> with the description, "In lisp you can't tell the difference between code and data."
19:26:12 <lispy> lisp may not be staticly typed, but it is expressive :)
19:28:20 <complaisant> lispy it doesn't make sense 2 me.. i didnt got it
19:29:00 <complaisant> i could pass it to code but it doesn't work as i wanted 2
19:29:04 <hyrax42> jdev: is that vigenere?
19:29:35 <lisppaste2> complaisant pasted "caesar cipher" at http://paste.lisp.org/display/30428
19:29:56 <complaisant> http://paste.lisp.org/display/30428
19:30:12 <complaisant> hyrax cesar
19:30:58 <hyrax42> I don't think so
19:31:11 <hyrax42> caesar has no keyword
19:31:24 <complaisant> right.. but it has shifts
19:31:31 <hyrax42> vigenere is a rotating caesar according to a keyword
19:31:38 <hyrax42> which is what jdev did afaict
19:32:48 <complaisant> jdev?
19:33:14 <lispy> ?pl onlyAlpha = filter (\x -> isAlpha x)
19:33:14 <lambdabot> onlyAlpha = filter isAlpha
19:33:20 <complaisant> lol
19:33:21 <hyrax42> jdev: > map (chr.(122-).(`mod`26).(245-)) $ zipWith (+) (map ord "verysecrettestmessage") (map ord $ fix ("signal"++))
19:33:47 <complaisant> fix?
19:34:16 <Excedrin> > map (L.replace "Hello, World" "...") [", ","asdf",""]
19:34:17 <hyrax42> > take 20 $ fix ("signal"++)
19:34:18 <lambdabot>  ["Hello...World","Hello, World","...Hello, World"]
19:34:19 <lambdabot>  "signalsignalsignalsi"
19:34:27 <hyrax42> I would have preferred
19:34:31 <complaisant> i think u don't need to use that fix.. i'd made it before without it. but alright.. something like that
19:34:32 <lispy> complaisant: so, the program looks correct except one spot i'm not sure about prcedence, what is your test that it fails?
19:34:38 <hyrax42> > take 20 $ cycle "signal"
19:34:40 <lambdabot>  "signalsignalsignalsi"
19:34:48 <hyrax42> but some people really like fix
19:34:56 <lispy> > fix showv
19:34:57 <lambdabot>  Not in scope: `showv'
19:34:58 <lispy> > fix show
19:34:59 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
19:35:05 <lispy> fix is fun!
19:35:28 <lispy> i might change: (nr - low) `mod` (big-low+1) + low
19:35:31 <hyrax42> until I can play like the pros, I'll just sniff disdainfully at it
19:35:32 <hyrax42> ;)
19:35:38 <lispy> to put parens around everything but the + low
19:35:47 <complaisant> omg! no more wine 4 table complaisant <-- forgot :w in vim !!! -.-
19:36:43 <lispy> complaisant: are you using your cipher now?  because i didn't quite understand that :)
19:37:03 <hyrax42> it might be better to have 'circle' take care of the ord/chr
19:37:06 <hyrax42> no?
19:37:26 * lispy thinks so
19:37:40 <lispy> and having 97 and 122 is awkward
19:37:47 <hyrax42> ?ty let circle = ord $ (chr nr - chr low) `mod` (chr big - chr low + 1) + low in circle
19:37:49 <lambdabot> Not in scope: `nr'
19:37:49 <lambdabot>  
19:37:49 <lambdabot> <interactive>:1:33: Not in scope: `low'
19:37:52 <hyrax42> oops
19:37:53 <lispy> ord 'a' and ord 'z' would be better, no?
19:38:08 <hyrax42> ?ty let circle low big nr = ord $ (chr nr - chr low) `mod` (chr big - chr low + 1) + low in circle
19:38:10 <lambdabot>   Couldn't match `Char' against `Int'
19:38:10 <lambdabot>    Expected type: Char
19:38:14 <jdev> hyrax42: Yes, that's what it should be.  (Sorry; I wasn't watching this window then.)
19:38:27 <hyrax42> jdev: not terribly ancient then
19:38:31 <lispy> when you just write 122 in your code, 122 becomes an annonymous constant, and those are bad
19:38:33 <hyrax42> though I guess semi-ancient works
19:38:55 <hyrax42> also becomes hard to change
19:39:00 <hyrax42> if used frequently
19:39:05 <lispy> hyrax42: right
19:39:09 <hyrax42> "is this 122 the same as that 122?"
19:39:14 <lispy> hyrax42: and it's hard to inferr what it means
19:39:16 <hyrax42> magic numbers = bad
19:39:28 <fons> anyone running OSX?
19:39:33 <hyrax42> fons: aye
19:39:34 <lispy> fons: i am
19:39:38 <hyrax42> 10.4.8 PPC
19:39:39 <lispy> fons: but i don't know how to help you :(
19:39:41 <hyrax42> on G4
19:39:48 * lispy too
19:39:54 <hyrax42> with ghc 6.4.2_2 from darwinports
19:40:08 <hyrax42> but I don't think I now how to help you either
19:40:18 <fons> hyrax42, did you try to compile anything with -dynamic?
19:40:43 <fons> lispy, just compile something with ghc and the -dynamic flag  and tell me if it worked
19:41:13 <fons> hyrax42, that would really help
19:41:27 <lispy> $ ghc -dynamic -e 'putStrLn "hello, world!"'
19:41:27 <lispy> hello, world!
19:41:37 <lispy> that example maybe too simple though :)
19:42:05 <fons> lispy, uhm, don't know if -e actually links and creates an executable
19:42:15 <fons> lispy, can you do it from a file?
19:42:36 <fons> Main.hs and show me the output of ldd  ?
19:42:37 <lispy> $ ghc -o main Main.hs -dynamic
19:42:37 <lispy> /usr/bin/ld: can't locate file for: -lHShaskell98_dyn
19:42:37 <lispy> collect2: ld returned 1 exit status
19:42:52 <lispy>  /usr/bin/ld: can't locate file for: -lHShaskell98_dyn
19:42:57 <fons> there we go
19:42:59 <lispy> (that line didn't paste before)
19:43:01 <fons> agrgrrgrggrgr
19:43:08 <dons> dcoutts: you'll love Sydney this time of year, 40.0°
19:43:20 <lispy> dons: ouch!
19:43:23 <fons> why is it claimed that ghc supports -dynamic in darwin?
19:43:29 * dons melts just a little. HWN might be a few hours late today
19:43:45 <fons> lispy, what ghc and os versions are you running?
19:44:45 <lispy> Darwin lychee 8.8.0 Darwin Kernel Version 8.8.0: Fri Sep  8 17:18:57 PDT 2006; root:xnu-792.12.6.obj~1/RELEASE_PPC Power Macintosh powerpc
19:44:48 <pkhuong> dons: do you need help with something easy like proofreading?
19:44:50 <lispy> ghc6.4.2
19:45:32 <lispy> fons: does that help, or is there a specific command i can run to get the nmubers you want?
19:45:45 <mwc> dons, what's your humidity at? In Saskatchewan, I suffered through 40 degree summers and -40 degree winters, but at least it was dry
19:45:50 <fons> lispy, that was just great
19:45:59 <fons> although it just confirms the problem
19:46:07 <fons> I'll fill a bug report
19:46:36 <dons> pkhuong: if you're around ina  couple of hours I could do with a proof read. i'll ping you
19:47:27 <dons> mwc, humidy 8%
19:47:39 <hyrax42> fons: /usr/bin/ld: can't locate file for: -lHShaskell98_dyn
19:47:59 <fons> hyrax42, thanks
19:48:00 <dons> down as low as 1% a couple of suburbs over. huh
19:48:07 <hyrax42> dunno if that helps really
19:48:16 <hyrax42> what does -dynamic do
19:48:17 <dons> that would explain the bush fire smoke...
19:49:13 <dibblego> ?where yaht
19:49:13 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
19:49:14 <psykotic> dons: that's crazy low
19:49:24 <SimonRC> hmmm
19:49:29 <SimonRC> soppose:
19:49:42 <SimonRC> cons x y = \f -> f x y
19:49:49 <dons> for those who don't follow the haskell@ list: http://www.haskell.org/pipermail/haskell/2006-November/018742.html
19:49:52 <lambdabot> Title: [Haskell] ANNOUNCE: Haskell Hackathon, Hac 07, http://tinyurl.com/yjyyms
19:50:22 <SimonRC> this is the normal way of doing things in the lambda calculus, yes?
19:50:35 <lispy> i should be one haskell@ but i don't much/any traffic
19:51:11 <dons> lispy: very high quality though
19:51:14 <hyrax42> SimonRC: doesn't look quite right to me, but I'm no expert
19:51:30 <lispy> dons: i mean, i think there is a glitch, because i don't get any announcements
19:51:42 <SimonRC> And with simple extensions, you get algebraic data types, pattern-matching, properties (as in C#), etc
19:52:03 <SimonRC> This seems to be more powerful than anyhitn I have seen in any other language.
19:52:30 <psykotic> right, that's church encoding. (there's another trick called bohm-baraducci encoding)
19:52:31 <SimonRC> Except maybe the ghc "abstarct data type" extension
19:52:31 <hyrax42> oh SimonRC I'm sorry!
19:52:40 <SimonRC> hyrax42: ??
19:52:40 <lispy> ?type \x y -> \f -> f x y
19:52:43 <lambdabot> forall t t1 t2. t -> t1 -> (t -> t1 -> t2) -> t2
19:52:54 <hyrax42> I thought your thing made no sense
19:52:59 <hyrax42> I was at fault
19:53:04 <SimonRC> lambda calculus doesn't work too well with MH typing, IIRC
19:53:12 <SimonRC> hyrax42: erm, that's fine
19:53:18 <jdev> @pl \x y f -> f x y
19:53:19 <lambdabot> flip . flip id
19:53:24 <SimonRC> I am used to being smarter than people :-P
19:53:38 <hyrax42> since of course car x _ = x; cdr _ y = y
19:53:42 <SimonRC> hyrax42: yup
19:53:46 <lispy> SimonRC: ouch!
19:53:55 <psykotic> what's " lambda calculus doesn't work too well with MH typing" supposed to mean?
19:53:55 <SimonRC> I was kidding, hence the smiley.
19:54:02 <lispy> SimonRC: watch out for the osmossis then...
19:54:21 <hyrax42> lispy: I love #haskell for that reason
19:54:24 <lispy> SimonRC: if you hang out with stupid people, you may reach equilibrium
19:54:26 <hyrax42> I learn a *lot* here by osmosis
19:54:43 <SimonRC> psykotic: in Hindley-Milner, IIRC, a function cannot have a type that allows you to pass it to itself, so the Y operator has not H-M type, IIRC.
19:55:04 <psykotic> SimonRC, yeah, that's right. otoh it can be typed using rank-2 polymorphism, which haskell supports.
19:55:07 <lispy> SimonRC: you're thinking of fix
19:55:09 <SimonRC> I've tried it.  GHC says "infinite type" or something like that
19:55:17 <SimonRC> psykotic: ooh
19:55:19 <lispy> the y combinator
19:55:28 <psykotic> you need to be able to express (forall a. a -> a) on the left of the arrow (->)
19:55:32 <SimonRC> ah, I meant combinator, not operator
19:55:34 <lispy> ?google defining  y combinator haskell mu
19:55:36 <lambdabot> http://www.mail-archive.com/haskell@haskell.org/msg19233.html
19:55:36 <lambdabot> Title: Re: [Haskell] How to define Y combinator in Haskell
19:55:37 <dons> > let f = f f in f
19:55:37 <lambdabot>    Occurs check: cannot construct the infinite type: t = t1 -> t
19:55:38 <lambdabot>    Expe...
19:55:42 <jdev> The rank-2 polymorphism has to be explicitly annotated, IIRC.
19:55:45 <psykotic> (or you can use recursive types as lispy just demonstrated)
19:55:52 <psykotic> jdev, that's not a problem, you only need to do it once.
19:55:52 <mwc> dons, that's just beautiful. This summer we hit 37 degrees at 100% humidity
19:55:57 <dons> heh
19:56:14 <dons> 1% is the lowest i've ever seen here. scary
19:56:24 <SamB_XP> @type id id
19:56:26 <lambdabot> forall a. a -> a
19:56:41 <dons> ?type fix fix
19:56:42 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
19:56:43 <lambdabot>    Expected type: (a -> a) -> a -> a
19:56:45 <dons> ah nice
19:56:48 <lispy> but, fortunately you don't have to resort to tricks
19:57:02 <lispy> ?let myfix f = f (myfix f)
19:57:03 <lambdabot> Defined.
19:57:10 <lispy> > L.myfix show
19:57:12 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
19:57:25 <hyrax42> ?ty L.myfix
19:57:26 <SimonRC> ?type fix
19:57:26 <lambdabot> Couldn't find qualified module.
19:57:28 <lambdabot> forall a. (a -> a) -> a
19:57:30 <lispy> equational reasoning to the resuce!
19:57:38 <lispy> rescue*
19:57:53 <dons> ?check take 100 (L.myfix show) == take 100 (fix show)
19:57:54 <lambdabot>  OK, passed 500 tests.
19:57:55 <lispy> > take 30 . map length . group . fix $ show
19:57:57 <lambdabot>  [1,1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,511,1,1023,1,2047,1,4095,1,8191,1,...
19:57:58 <dons> :)
19:58:13 <lispy> (one of my favorite examples of fix and show)
19:58:41 <lispy> i did fibs too...but that one is hard to remember :)
19:58:50 * lispy takes a bow
19:58:54 <lispy> thank you, thank you!
19:59:07 <dons> :)
19:59:07 <dons>  
19:59:23 <hyrax42> > take 30 . map length . filter (/= "\"") . group . fix $ show
19:59:27 <lambdabot> Terminated
19:59:56 <hyrax42> ?ty group
19:59:58 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
20:00:46 <hyrax42> :?
20:01:01 <hyrax42> >take 3 $ group . fix $ show
20:01:08 <hyrax42> > take 3 $ group . fix $ show
20:01:09 <lambdabot>  ["\"","\\","\""]
20:01:28 <hyrax42> > take 5 $ group . fix $ show
20:01:29 <lambdabot>  ["\"","\\","\"","\\\\\\","\""]
20:01:44 <complaisant> map (chr.(122-).(`mod`26).(245-)) --> wtf is this?
20:01:55 <hyrax42> > take 5 $ filter (/= "\"") . group . fix $ show
20:01:56 <lambdabot>  ["\\","\\\\\\","\\\\\\\\\\\\\\","\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\","\\\\\\\\\\...
20:02:15 <LoganCapaldo> @type map (chr.(122-).(`mod`26).(245-))
20:02:16 <lispy> darc
20:02:16 <hyrax42> > take 5 $ map length . filter (/= "\"") . group . fix $ show
20:02:17 <lispy> oops
20:02:18 <lambdabot> [Int] -> [Char]
20:02:19 <lambdabot>  [1,3,7,15,31]
20:02:44 <hyrax42> > take 8 $ map length . filter (/= "\"") . group . fix $ show
20:02:46 <lambdabot>  [1,3,7,15,31,63,127,255]
20:02:50 <SimonRC> can I express something like "data Foo = Bar T1 T2 | Baz T3" as "foo_bar dat1 dat2 = \f_bar f_baz -> f_bar dat1 dat2; foo_baz dat3 = \f_bar f_baz -> f_baz dat3"?
20:02:53 <hyrax42> so what was wrong before
20:03:11 <SimonRC> it seem right
20:04:11 <lispy> hyrax42: i think you just requested too many elements of the list
20:04:24 <lispy> hyrax42: it's a lot of function calls to create an exponentially increasing number of quotes :)
20:04:25 <hyrax42> bah
20:04:28 <psykotic> simon: except for the missing type annotations, it looks good.
20:04:29 <hyrax42> bah I say
20:04:38 <hyrax42> daily show time
20:04:57 <SamB_XP> @type let foo_bar dat1 dat2 = \f_bar f_baz -> f_bar dat1 dat2; foo_baz dat3 = \f_bar f_baz -> f_baz dat3 in (foo_bar, foo_baz)
20:04:59 <lambdabot> forall t t1 t2 t3 t4 t5 t6. (t -> t1 -> (t -> t1 -> t2) -> t3 -> t2, t4 -> t5 -> (t4 -> t6) -> t6)
20:05:09 <jdev> > map ((-2*).(1-).shiftL 1) [0..]
20:05:10 <lambdabot>    The operator `*' [infixl 7] of a section
20:05:11 <lambdabot>     must have lower precede...
20:05:28 <jdev> > map (((-2)*).(1-).shiftL 1) [0..]
20:05:29 <lambdabot>  Add a type signature
20:06:00 <LoganCapaldo> Add a type  signature? That gives me an urge to say "No, you figure it out."
20:06:15 <jdev> > map ((!!)(fix show)) $ map (((-2)*).(1-).shiftL 1) [0..]
20:06:19 <lambdabot> Terminated
20:06:46 <jdev> > take 5 $ map ((!!)(fix show)) $ map (((-2)*).(1-).shiftL 1) [0..]
20:06:47 <lambdabot>  "\"\"\"\"\""
20:06:52 <SamB_XP> LoganCapaldo: she is as stubborn as she is beautiful
20:07:10 <jdev> Wheeeee.
20:07:10 <psykotic> @lambada
20:07:11 <lambdabot> (line 1, column 1):
20:07:12 <lambdabot> unexpected end of input
20:07:12 <lambdabot> expecting white space or simple term
20:07:15 <psykotic> :)
20:07:17 <jdev> > take 20 $ map ((!!)(fix show)) $ map (((-2)*).(1-).shiftL 1) [0..]
20:07:19 <lambdabot>  "\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\""
20:07:59 <hyrax42> or not
20:08:06 <SamB_XP> > map (((-2)*).(1-).shiftL 1) [0..]
20:08:07 <lambdabot>  Add a type signature
20:08:18 <SamB_XP> > map (((-2)*).(1-).shiftL 1) [0..] :: [Int]
20:08:20 <lambdabot>  [0,2,6,14,30,62,126,254,510,1022,2046,4094,8190,16382,32766,65534,131070,262...
20:08:38 <LoganCapaldo> @type shiftL
20:08:40 <lambdabot> forall a. (Bits a) => a -> Int -> a
20:09:01 <hyrax42> ?hoogle (Bits a) => a -> Integer -> a
20:09:02 <lambdabot> No matches, try a more general search
20:09:23 <jdev> ?instances Bits
20:09:25 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
20:09:34 <hyrax42> allthough I suppose that any number shifted by more than 2^30 would be a bit bigger than could reasonably fit in RAM
20:09:39 <hyrax42> at least shifted left
20:09:54 <hyrax42> and any number that could be shifted right by 2^30, same
20:10:07 <hyrax42> but "morally" there should be a genericShiftL
20:10:14 <hyrax42> or "ethically"
20:13:16 <hyrax42> ?t const (const 3))
20:13:17 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
20:13:25 <hyrax42> ?ty const $ const 3
20:13:26 <lambdabot> forall b b1 a. (Num a) => b -> b1 -> a
20:13:55 <hyrax42> I'm guessing nobody did, but is there a Unit monad where
20:14:18 <hyrax42> (>>=) = const $ const Unit; return = const Unit?
20:14:26 <hyrax42> ?ty const.const 3
20:14:28 <lambdabot> forall b a a1. (Num a1) => a -> b -> a1
20:19:20 <dmead> does anyone know a way to define an infix operator without using the ugly colon?
20:19:33 <dmead> i have :\/ but having just v
20:19:36 <dmead> would make my day
20:19:39 <dmead> :)
20:20:06 <dolio> Only infix constructors start with a colon.
20:20:33 <dolio> So you could do (\/) = (:\/)
20:21:12 <dmead> err
20:21:14 <dmead> constructors
20:21:17 <dolio> Or call the constructor anything else, for that matter, and just define whatever infix operator you want to combine them.
20:21:28 <dmead> hmm
20:21:46 <dolio> Well, in that case, no, all infix operator constructors need to start with colons.
20:21:51 <cjs> Hey, is it possible to write a library in Haskell for use by a C program? Is it reasonable?
20:22:14 <dolio> Although you can do 'data Foo a b = a `Foo` b', I think. But that's probably not what you're looking for.
20:22:23 <LoganCapaldo> cand you do one of these? a `v` b, replace the ugly colon with some ugly backticks?
20:22:25 <lispy> cjs: yes and  yes
20:22:46 * LoganCapaldo is slow
20:22:51 <lispy> cjs: the C program starts up the haskell rts and calls exported functions
20:22:59 <dmead> hmm
20:23:01 <dmead> so
20:23:06 <dmead> infix `v`
20:23:10 <dmead> correct?
20:23:16 <lispy> cjs: or in some cases, you can have the haskell program start up the rts (in the case of shared libraries)
20:23:26 <lispy> cjs: do you want more information about doing it, or were you just curious?
20:24:03 <dolio> Yeah, you can make any function infix by placing it in backquotes.
20:24:19 <dolio> Well, any named function.
20:24:23 <dmead> it's a constructor i have to pattern match against
20:24:26 <dmead> not a function
20:26:02 * lispy plays information broker today
20:26:03 <dolio> That'll work.
20:26:40 <cjs> If you've got a link to more info, I'd like to look into it.
20:26:48 <dolio> Although, it'll have to be a capital V, since it's a constructor.
20:26:53 <lispy> cjs: to give a real world example of it being useful, at my job i wrote a haskell dll and then had our main application (written in C/C++) call the dll to get some work done
20:27:11 <hyrax42> lispy: they let you get away with that?
20:27:17 <hyrax42> ?ty newIORef
20:27:18 <lambdabot> Not in scope: `newIORef'
20:27:28 <lispy> cjs: this is a good example of things y ou can do: http://web.mit.edu/ghc/www/users_guide/win32-dlls.html
20:27:31 <lambdabot> Title: 11.5. Building and using Win32 DLLs, http://tinyurl.com/y2g3a8
20:27:35 <hyrax42> ?index newIORef
20:27:36 <lambdabot> Data.IORef
20:27:44 <hyrax42> ?ty Data.IORef.newIORef
20:27:45 <lambdabot> forall a. a -> IO (GHC.IOBase.IORef a)
20:27:47 <cjs> I've got a ruby library that parses SWF files, lets you muck about with them and combine them, and then rewrites them. Performance is abysmal, and it doesn't link to PHP, so maybe this is the time to finally sit down and do something in Haskell.
20:27:54 <lispy> hyrax42: kinda, recently they said, "please no more haskell, we don't know the language so it makes us uncomfortable" :(
20:28:06 <hyrax42> :(
20:28:31 <cjs> It's either Haskell or OCaml, anyway, but _Practical OCaml_has rather put me off that language....
20:28:32 <hyrax42> did you offer help to anyone who wanted to learn?
20:28:42 <hyrax42> or were you just going and doing your own thing
20:28:42 <dolio> Heh. Is the book that bad?
20:28:50 <lispy> cjs: i don't know why this page is at mit, but this part of the manual is really good: http://web.mit.edu/ghc/www/users_guide/sec-ffi-ghc.html
20:28:52 <lambdabot> Title: 8.2. Using the FFI with GHC, http://tinyurl.com/y3qskq
20:28:56 <cjs> Oh, man, it's truly, truly awful.
20:29:09 <dmead> dolio: it compiles with a v but not a V
20:29:11 <lispy> cjs: also, tehre is the ffi addendum and you want to also look at the haskell wiki (but google doesn't search it...)
20:29:31 <dolio> dmead: Really? It lets you use v as a constructor, but not V? That's odd.
20:29:39 <lispy> hyrax42: they don't seem interested in learning it
20:29:54 <lispy> hyrax42: kind of like, "What's wrong with .NET?"
20:30:00 <dolio> I suppose that can happen. The book I bought on python really turned me off to it.
20:30:21 <dons> lispy: who said that? your work?
20:30:33 <dmead> hmm
20:30:36 <cjs> The code is bad, the formatting is screwed so it looks twice as bad as it needs to, it's condescending to its intended audience (experienced programmers, but with little or no FP experience), and it doesn't explain the 'odd' FP things whilst explaining stuff any programmer would know. If I'd not already learned a bit of Haskell before tackling this, I wouldn't have understood half of the first chapter.
20:30:41 <hyrax42> did you tell them about SPJ and Tim Harris and STM?
20:30:41 <dmead> wheres the paste thingy
20:30:43 <dmead> @paste
20:30:44 <lambdabot> http://paste.lisp.org/new/haskell
20:30:44 <lispy> dons: that's their attitude, but they didn't flat out saying that plainly
20:30:48 <lispy> dons: and yes my work
20:30:48 <hyrax42> (that channel 9 video was pretty interesting)
20:30:50 <dons> yeah, i've never seen worse reviews than that for 'practical ocaml'
20:31:02 <dolio> I remember several pages describing, in detail, the process for deciding the total ordering of hash tables, and I couldn't read any further.
20:31:05 <dons> people really want a book with that name, so you have a lot to live up to if you write it
20:31:16 <dmead> dolio: i'll paste hold on a ticck
20:31:24 * hyrax42 imagines a "Practical Haskell"
20:31:24 <cjs> Well, especially since the same publisher's Practical Common Lisp is so good.
20:31:38 <lispy> hyrax42: did i see what with SPJ?
20:31:41 <cjs> We need a Practical Haskell, at least for people like me.
20:31:50 <dons> we do.
20:31:56 <dons> or 2 or 3...
20:31:58 <lispy> cjs: practical ocmal is by the peter guy?
20:32:02 <lispy> cjs: and it's not good?
20:32:03 <hyrax42> no did you tell them that insperation to C# is coming from haskell
20:32:06 <lispy> hhmmmrm
20:32:09 <SamB_XP> but, by that token it will either suck or be a good bit of work ;-)
20:32:10 <cjs> The Haskell School of Expression is great, except I just don't find the material that interesting. I need to write web servers and networking protocols and so on.
20:32:11 <hyrax42> not that it really makes a difference to practitioners
20:32:22 <dons> cjs, yeah, exactly
20:32:33 <cjs> No, Practical OCaml is by a different guy, Joshua B. Smith.
20:32:35 <SamB_XP> hyrax42: it gives you more to look forward to
20:32:48 <lispy> cjs: Ah
20:32:59 <lispy> cjs: makes me feel better now :)
20:33:11 <hyrax42> what would be an example worthy of Practical Haskell though
20:33:26 <hyrax42> what is the example used in the ocaml book
20:33:27 <cjs> There's no way that the Practical Common Lisp author could have done anything a quarter that bad.
20:33:29 <hyrax42> the central project?
20:33:30 <complaisant> @paste
20:33:31 <lambdabot> http://paste.lisp.org/new/haskell
20:33:44 <hyrax42> PCL is pretty good
20:33:49 <SamB_XP> cjs: what if it was called "impractical ocaml"?
20:33:53 <lispy> one thing i've noticed and been told by experts is that in an organization you can bring up ideas on how to do things better, and if people don't have a motivation to do it...you might as well stop there...so i did
20:34:03 <hyrax42> but I didn't find the motivating example too motivating
20:34:06 <cjs> Oh, and some of the quotes I could come up with.
20:34:06 <lisppaste2> #haskell pasted "infix logic?" at http://paste.lisp.org/display/30435
20:34:11 <dmead> there
20:34:15 <dmead> can someone look at that?
20:34:24 <hyrax42> and it's far too easy to skim over macro magic and not really know what it's doing
20:34:24 <lispy> i want to use haskell at work, but my co-workers resist it and make up problems...so i won't bother using haskell when it gives them the option to resist
20:34:37 <SamB_XP> dmead: you are #haskell are you?
20:34:40 <cjs> "Finally, functors are moderately difficult to understand. It's unfortunate that you had to be exposed to them so soon."
20:34:40 <dmead> lol woops
20:34:41 <dmead> ah ah
20:34:51 <lisppaste2> dmead pasted "infix logic?" at http://paste.lisp.org/display/30436
20:35:20 <hyrax42> cjs: ick
20:35:26 <lispy> instead i'll fight with .NET...
20:35:29 <hyrax42> though with a Practical Haskell, it'd be simiilar with monads
20:35:36 <lisppaste2> dolio annotated #30435 with "This compiles for me." at http://paste.lisp.org/display/30435#1
20:35:39 <hyrax42> to do *anything* practical, you need IO
20:35:56 <cjs> Oh, it's not impractical at all; it's quite practical. It's just that, and this is the worst thing, at least so far (chapter 9 of 30), what I've seen doesn't look any better than using any other language.
20:36:03 <lispy> if i were writing practical haskell i'd just start with "Tackling the awkward squad" when it was time to introduce monads
20:36:29 <hyrax42> and I think the first little bit would need to be explaining the virtues of the type system
20:36:40 <hyrax42> since it is most imporactical if your program doesn't compile
20:36:48 <cjs> I'd just start in with monads. First thing. Just enough to get a feeling of how to use them.
20:36:49 <lispy> show them the IO monad because that's what imperative programmers will be familiar with monad-wise, then spring board into the ways to generalize it :)
20:36:59 <cjs> Well, I might wait until chapter 2, to get the basic syntax out of the way, first.
20:37:57 <hyrax42> what cause is there to use ST monad over IO monad
20:37:57 <sieni> and anyway, once you see how well the IO monad and STM monad integrate together, you actually see how cool a feature monadic IO is.
20:37:58 <SamB_XP> personally, I'd not start with programs
20:38:03 <SamB_XP> programs are boring
20:38:12 <cjs> Oh, and get TDD in there early. That was a brilliant thing about PCL. And it's why I've yet to do more with POC than type in a few things at the toplevel.
20:38:13 <sieni> hyrax42: you can get the state out, for example
20:38:28 <hyrax42> but it doesn't even have a concrete type I thought
20:38:48 * SimonRC procedes to be amazed how simple turning programs into untyped lambda calculus is, if you turn things into Haskell first.  e.g. translating ADTs is a simple mechanical operation.
20:38:48 <hyrax42> ?
20:38:56 <dibblego> lispy, there are ways of overcoming those hurdles
20:39:15 <lispy> cjs: POC?
20:39:35 <cjs> Practical OCaml.
20:39:59 <psykotic> i hear that book was a trainwreck
20:40:02 <lispy> dibblego: getting a different job seems best :)
20:40:25 <cjs> Ah, you missed my comments above.
20:40:33 <cjs> I put a review at the end of the comments on the LtA page.
20:40:40 <SamB_XP> psykotic: apparantly it gives the impression that there is nothing special about ocaml, compared to ordinary imperative languages...
20:40:45 <dmead> dolio: thanks, I didn't see it was a backquote
20:41:58 <cjs> Well, probably some special stuff comes later, though I doubt it gets as special as the functional reactive animations chapter of HSoE (which blew my mind).
20:42:21 <dons> what? people don't like bug free code :/ http://programming.reddit.com/info/rxqb/details
20:42:23 <lambdabot> Title: Verifying Haskell programs by combining testing and proving [pdf] (reddit.com), http://tinyurl.com/ylkwm8
20:42:25 <dolio> Ah, okay.
20:42:35 <cjs> But mostly, even small, simple, sorta-imperative programs should still be beautful, not ugly as they are in this book.
20:42:57 <cjs> (Not that I find OCaml's syntax half as nice as Haskell, anyway.)
20:43:30 <arjanb> dons: probably some people are annoyed with the number of haskell posts
20:43:31 * SimonRC loves translating (a subset of) Haskell into untyped lambda calculus:
20:43:31 <SimonRC> plus =  \       x y -> case x of { Zero       -> y ; Succ    n  -> Succ (plus x y) }
20:43:35 <SimonRC> plus = (lambda (x y)  (x           (lambda ()    y) (lambda (n)   (succ (plus n y)))))
20:44:06 <dons> arjanb: could be. one a day is too many? (though 10 lisp posts a day...)
20:44:22 <dolio> dons: Maybe someone will go argue with himself about that paper, as well.
20:44:28 <dons> heh
20:44:53 <dons> that was funny esp. at the end "oh, I get it... they're recording their intention to commit' ...
20:45:12 <dons> after 3 rambling posts saying simon et al are fools
20:45:42 <dolio> Yeah. "This stuff will never work... etc." Don't they have actual results?
20:45:53 <dolio> I mean, I can use STM right now. :)
20:46:03 <dolio> Unless they're lying about how it's implemented.
20:47:08 <psykotic> @quote qwe1234
20:47:09 <lambdabot>  a language with type inference isn't more expressive -- because type declarations are redundant, much like 'sigils' in perl.
20:47:20 <psykotic> a word from the zen master
20:47:47 <SimonRC> incidently, does ghc actually make translations like the one I showed above (if I defined the Nat datatype appropriately)?
20:48:29 <dolio> It's interesting that he's using "expressive" in that sentence as if it's meaningful, considering he doesn't think "expressive" means anything.
20:49:06 <psykotic> SimonRC, no. it's not really very good as an implementation.
20:49:18 <SimonRC> I meant as an internal thing
20:49:33 <psykotic> System Fc has built in support for algebraic data types AFAIK
20:50:34 * SamB_XP thinks qwe1234 hasn't seen typeclasses for what they are 
20:51:23 <SamB_XP> psykotic: of course it does!
20:51:45 <psykotic> SamB, yes :)
20:51:51 <SamB_XP> Core does at any rate
20:51:57 <lispy> SimonRC: i recommend you read the H98 report and then look at papers about ghc, like compiling to stock hardware, spinless tag less g machine and there is at least one about compiling FP languages by the same authors
20:52:07 <hyrax42> anyone here familiar with the moggi paper?
20:52:15 <hyrax42> notions of computation...
20:52:21 <SamB_XP> also, look at coreSyn/CoreSyn.lhs ;-)
20:52:21 <psykotic> hyrax42, yes
20:52:31 <hyrax42> does he define bind in there?
20:52:44 <psykotic> he uses join, iirc
20:52:54 <hyrax42> so the "usual" mu, eta
20:52:58 <lispy> you can define bind interms of join
20:53:00 <hyrax42> does he call them join/return?
20:53:03 <hyrax42> oh I know
20:53:11 <hyrax42> but I want to explain the use of monads to a prof of mine
20:53:13 <hyrax42> *in haskell
20:53:22 <hyrax42> and he is familiar with moggi's notions
20:53:32 <lispy> @pl \f x -> join $ liftM f x
20:53:32 <lambdabot> (=<<)
20:53:39 <SimonRC> lispy: I only really mention it because the whole ADTs-are-functions-of-functions thing is currently clicking for me
20:53:57 <psykotic> SimonRC, that's one encoding, not "what they are".
20:54:11 <SimonRC> but its a very elegant encoding
20:54:15 <psykotic> in fact there is an alternative but related encoding in the lambda calculus which has some advantages.
20:54:16 <psykotic> yeah sure.
20:54:40 <lispy> there is an amusing read of how i discovered bind in terms of join here: http://codersbase.com/index.php/Haskell
20:54:54 <hyrax42> ?pl \f -> (>>= return.f)
20:54:55 <lambdabot> fmap
20:55:24 <hyrax42> so in some sense the bind/return defintion is "simpler" than the join/fmap/return defintion
20:55:31 <hyrax42> ?
20:55:46 <lispy> for programming
20:55:49 <SimonRC> IIRC, the traditional Unlambda one for a number "num" is (foldr (.) id . repeat num)
20:56:01 <SimonRC> i.e. it applies the argument to itself num times
20:56:11 <lispy> i think math-wise, the other formulation is probably more natural since it evolved there first
20:56:14 <hyrax42> well I mean sort of how NAND is "simpler" than (AND, NOT)
20:56:29 <hyrax42> since NAND can define all boolean operations
20:56:34 <lispy> ah, okay
20:56:41 <lispy> in that case they call NAND universal
20:56:44 <lispy> same with NOR
20:57:14 <dolio> fmap can be defined on things that aren't monads, though.
20:57:23 <hyrax42> so here bind, return encompass the definition of fmap, while no combination of 2 of return, join, fmap can get the third?
20:59:31 <arjanb> right
21:00:39 <hyrax42> though fmap is not defined implicitly that way for any given monad, is it?
21:01:39 <dolio> Only if you use liftM.
21:02:07 <dolio> I doubt anyone defines the Functor instance using liftM.
21:02:35 <SamB_XP> dolio: why not?
21:02:39 <dolio> Since it's extra indirection, and fmap isn't too hard to define.
21:02:48 <dolio> In my experience, at least.
21:02:54 <SamB_XP> it would most likely be inlined
21:03:16 <hyrax42> I think he means you could write a direct fmap without needed bind
21:11:44 <dmead> ugg
21:11:58 <dmead> `V` works as an infix constructor
21:12:07 <dmead> but `&` does not
21:12:07 <dmead> =/
21:12:23 <lispy> dmead: :&: should work
21:12:31 <dolio> & is not a proper constructor name.
21:12:50 <dolio> Only capitalized function names, and operators beginning with colon.
21:12:52 <dmead> i'm trying to figure out how to use a normal syntax for logic
21:13:01 <dmead> no : or `
21:13:02 <Lemmih> dons: Are you traveling from Australia to the UK for a Hackathon?
21:13:26 <lispy> dmead: well, you can't just usurp haskell's syntax :)
21:13:30 <dmead> =/
21:13:42 <dmead> hmm
21:13:55 <lispy> dmead: but with parsec or happy you could fairly easily write a parser
21:14:00 <dmead> hmm
21:14:20 <dmead> yea that seems like overkill though
21:14:41 <dmead> needing : for an infix constructor is really not nice
21:16:26 <dolio> What exactly was the problem with defining other operators that do the same thing? The lack of a nice looking automatic Show?
21:16:27 <Excedrin> where are >>= and return instances for [] documented?
21:17:05 <dmead> dolio: well, i've got a prefix implementation that i wrote the nice looking show for, it's reading that i'm more concerned about
21:17:19 <dolio> Ah, I guess that's a pain, too.
21:17:34 <dmead> if the constructors don't need the : or ` baggage i could just start gobbling up lists of formulas
21:17:44 <dmead> and not need to worry about editing them
21:18:07 <dmead> you can
21:18:29 <dmead> you can't show the code for an derrived instance, can you?
21:18:39 <dmead> as in derriving (Read)
21:18:53 <dmead> if i actually wanted to look at the Read that hugs comes up with
21:19:30 <dolio> I don't know.
21:19:35 <dmead> ;/
21:26:20 <dmead> nobody?
21:26:21 <dmead> =/
21:27:32 <lispy> dmead: it would be implementation specific and i don't know how to get ghc or hugs to give you that information
21:27:51 <dmead> ah
21:28:18 <dmead> yea i guess i'm being picky, but it'd be nice to have access to tonnes of test data
21:28:26 <dons> Lemmih: i'm going to be in france fro PADL/POPL, so skipping across to Oxford seems worthwhile :)
21:30:11 <lispy> dmead: well, ask dons if he knows of anyway to dump that sortof info
21:30:22 <lispy> dons: in your travels have you seen a -dump-instances or similar?
21:30:33 <dmead> hi dons =p
21:30:50 <dons> lispy: yeah there's a flag to show the derived instances, iirc
21:30:56 <dons> check the ghc user's guide
21:30:56 <dmead> hmm
21:31:01 <dmead> what about hugs?
21:31:19 <dons> no idea
21:31:19 <lispy> it's not deprecated yet? ;)
21:31:23 <dmead> =p
21:31:33 <dmead> i've been usin hugs, seems alot faster than ghci
21:31:55 <lispy> well, darcssim is to the (pathetic) point where i can simulate one user
21:32:05 <lispy> not real happy with the design, but it's limping along
21:32:37 <dmead> dons: is that how i'd take a look at the code generated from a "deriving (Read, Show)" word?
21:32:58 <dolio> dmead: The haskell docs for the Read class give a sample derived Read instance.
21:33:06 <Excedrin> what's darcssim?
21:33:14 <lispy> ?where darcssim
21:33:14 <lambdabot> I know nothing about darcssim.
21:33:17 <lispy> gam
21:33:18 <dmead> dons: but it's for a prefix tree, which requires no or little parsing
21:33:24 <dmead> err
21:33:35 <dmead> dolio: but it's  for a prefix tree, which requires no or little parsing
21:33:44 <lispy> dons: that's an example of lambdabot forgetting things
21:34:05 <dolio> dmead: It has an infix constructor.
21:34:14 <lispy> ?where+ darcssim http://codersbase.com/index.php/DarcsSim
21:34:15 <lambdabot> Done.
21:34:22 <lispy> Excedrin: ^^
21:34:30 <dmead> hmm
21:36:35 <lispy> Excedrin: it's written in scala at the moment (class requirement) but i hope to rewrite in in haskell after the term
21:38:49 <zeeeee> hi all, i'm trying to setup missingh, but './setup configure' ends prematurely with 'setup: cannot satisfy dependency regex-compat-any'. any help?
21:39:16 <lispy> zeeeee: i know the problem, but i don't know the solution :)
21:39:34 <lispy> zeeeee: you need to find that package (regex-compat) and install it
21:39:42 <lispy> ?where regex
21:39:42 <lambdabot> I know nothing about regex.
21:39:45 <lispy> ?where regex-compat
21:39:46 <lambdabot> I know nothing about regex-compat.
21:40:36 <lispy> dons: i did get the hac announcement now
21:40:54 <dons> you have to install the extra-libraries , zeeeee
21:41:00 <lispy> dons: both of darcs-devel and one of your other lists....probaly libraries
21:41:06 <dons> li	ok good
21:41:11 <dons> so not haskell@ though
21:41:20 <lispy> dons: i'm thinking i'm wrong about being on that list
21:41:41 <dons> zeeeee: http://www.haskell.org/ghc/download_ghc_66.html
21:41:46 <lispy> dons: what is the intended difference between cafe and haskell?
21:41:53 <dons> grab the extralibs if they're in your package system
21:42:13 <dons> haskell@ is announcements/jobs/conferences, haskell-cafeis talk and discussoin
21:42:24 <newsham> are there any overviews of the various web app frameworks for haskell w/ copmarisons?
21:42:25 <lispy> dons: oh, and did you see that lambdabot  forgot about darcssim, i'm pretty sure i added it a while back when SamB asked about it, but she didn't know about it today
21:42:38 <dons> yes
21:42:39 <dons> i'll check
21:42:51 <lispy> dons: i know darcssim isn't in haskell at the moment, but i hope to have it there eventually :)
21:42:57 <dons> cool
21:43:02 <lispy> (if that were a requirement to @wheer)
21:43:26 <lispy> as for tonight, i think i shall take a break...so afk!
21:43:32 * lispy &
21:47:46 <AtnNn> @hoogle Read a => String -> Maybe a
21:47:47 <lambdabot> No matches, try a more general search
21:49:27 <AtnNn> @djinn Read a => String -> Maybe a
21:49:28 <lambdabot> Cannot parse command
21:51:32 <zeeeee> dons: i'm not sure what to install from there. "find . -name *regex*" on the extracted extralibs tarball found nothing
21:51:44 <zeeeee> '*regex*'
21:53:24 <chessguy> 'evening
21:53:31 <chessguy> err, well, 'morning now
21:53:52 <zeeeee> also, would i need the matching version number for my ghc? (i installed via fc5 yum, meaning i have ghc 6.4.2, not 6.6)
21:56:01 <zeeeee> hm, extralibs don't even exist for 6.4
21:56:08 <zeeeee> ok, what's going on
21:57:14 <dons> zeeeee: *oh*
21:57:24 <dons> you need to go back one misingh version
21:57:34 <zeeeee> dons: ah
21:57:36 <dons> the latest relesae is 6.6 only, i think
21:57:54 <zeeeee> dons: they should fix their INSTALL
21:57:58 <dons> $ ghc-pkg-6.4.2 list MissingH
21:57:58 <dons> /home/dons/lib/ghc-6.4.2/package.conf:
21:57:58 <dons>     MissingH-0.14.4
21:58:03 <dons> works
21:58:54 <zeeeee> dons: what's ghc-pkg? is it related to cabal?
21:59:20 <dons> its the package system tool
21:59:21 <zeeeee> (haven't heard of former, haven't used latter)
21:59:27 <dons> cabal is a build system,
21:59:31 <dons> which registers packages with ghc-pkg
21:59:49 <zeeeee> dons: er, i meant hackagedb
21:59:56 <zeeeee> or hackage
21:59:59 <zeeeee> or whatever it's called
22:00:09 <dons> hackage is a CPAN-like system
22:00:22 <dons> i.e. online (cabalised) package hosting
22:00:35 <zeeeee> dons: ah, so ghc-pkg is my interface to hackage
22:00:44 <dons> nope
22:00:48 <dons> hackage isn't operational yet
22:00:51 <dons> (its in beta)
22:00:53 <zeeeee> oh
22:00:58 <dons> ghc-pkg is the interface to ghc's package data base
22:00:59 <dons> on your disk
22:01:06 <zeeeee> ahh, i see
22:01:09 <dons> cabal uses it to register libraries with ghc
22:08:24 <zeeeee> i asked this in #fedora but in case someone here can help: i added a haskell repository (http://www.haskell.org/fedora/), but when i do 'sudo yum search cpphs', nothing is found, even though i see 'haskell-stable' listed as a repository in yum's output.
22:10:01 <hyrax42> what are rough spots in hackage?
22:22:42 <Acker_> anyone who speak Spanish=
22:29:34 <newsham> Setup.hs: cannot satisfy dependency regex-compat-any
22:29:38 <newsham> what package do I want?
22:30:37 <zeeeee> newsham: wow, i, like, totally just asked that question...but in the context of installing missingh
22:30:49 <zeeeee> newsham: you may want to look into extralibs
22:30:57 <zeeeee> ghc-extralibs
22:31:10 <zeeeee> newsham: but that's all i can asy
22:31:11 <zeeeee> *say
22:32:17 <newsham> and where is that?
22:33:09 <zeeeee> newsham: http://www.haskell.org/ghc/download_ghc_66.html
22:33:12 <lambdabot> Title: GHC: Download version 6.6, http://tinyurl.com/ybqjsb
22:33:15 <zeeeee> hi all, when i install missingh, i configured prefix=$HOME/..., but 'setup install' tries to update my /usr/.../package.conf. is there any way around this (if say we have no root access)?
22:33:30 <newsham> i'm using ghc6.4
22:33:36 <zeeeee> newsham: same here
22:33:45 <zeeeee> newsham: solution was to use an older missingh
22:34:55 <newsham> i dont understand.
22:35:13 <newsham> regex-compat is part of the latest ghc but not 6.4?
22:35:56 <newsham> i cant deal with this now.
22:36:24 <zeeeee> hm, i guess the answer to my question is "No, that's impossible." (see http://haskell.org/hawiki/LibraryInfrastructure_2fComments#head-33cd081929f76e196e928db191649bde1c33602b)
22:36:26 <lambdabot> Title: LibraryInfrastructure/Comments - The Haskell Wiki, http://tinyurl.com/yxgzjz
22:38:05 <Lemmih> zeeeee: setup install --user, should work, right?
22:39:03 <zeeeee> Lemmih: oh, let my try that
22:39:36 <zeeeee> Lemmih: thanks!
22:53:38 <araujo> yay!
22:55:15 <beantmt> okay, if I am defining an enumerated type like "data Position = foo | bar | foobar" how can I make sure the type is a member of class Eq?
22:56:02 <Excedrin> throw some: deriving (Eq)
22:56:12 <beantmt> I've done stuff like foo :: (Eq a) => a before but just not sure how to do it in this case
22:56:24 <dons> data P = F | B | FB deriving (Eq,Enum,Ord) -- ?
22:56:25 <araujo> Anybody knows some module/lib to work with post fix notation?
22:56:44 <dons> araujo: there was a paper by okasaki on it . let me see...
22:56:47 <beantmt> deriving... okay, that's what I needed.
22:56:53 <beantmt> I'm bad at Haskell by the way :)
22:56:53 <araujo> dons, good
22:57:05 <dons> beantmt: don't worry, everyone is!
22:57:21 <Excedrin> beantmt: or create an Eq instance via: instance Eq Position where (==) a b = some_comparison_func a b
22:57:24 <beantmt> heheh
22:58:00 <Excedrin> maybe with CamelCase instead of _, but whatever
22:58:11 <sieni> dons: what's this with building hs-plugins?: Setup.lhs: Warning: The field "hs-source-dir" is deprecated, please use hs-source-dirs.
22:58:18 <sieni> dons: and Setup.lhs: cannot satisfy dependency haskell-src-any
22:58:20 <dons> please use hs-source-dirs :)
22:58:26 <dons> sieni: hmm, what ghc are you using?
22:58:50 <sieni> I just upgraded to 6.6 and darcs pulled hs-plugins
22:59:00 <dons> ok. hs-plugins doesn't work yet with 6.6..
22:59:05 <dons> due to the .hi and package format changing
22:59:08 <sieni> I didn't know I was using hs-source-dir either :-)
22:59:09 <dons> faq :)
22:59:22 <sieni> argh :-)
22:59:39 <dons> araujo: the paper is "Techniques for embedding postfix languages in Haskell", Chris Okasaki, 2002 Haskell Workshop
23:00:15 <araujo> dons, thanks!
23:00:19 <dons> http://www.eecs.usma.edu/webs/people/okasaki/hw02.ps
23:00:22 <lambdabot> http://tinyurl.com/tcn62
23:00:30 <dons> usma!
23:01:16 <dons> ah yes, he works (or worked?) there
23:02:40 <araujo> dons, yeah, got it on google :-)
23:03:00 <dons> cool
23:14:09 <skeh> Anyone here handy with Haskell IO()
23:15:17 <glguy> Your best bet is to just ask your question to the channel
23:16:22 <skeh> I am trying to read one line at from in.txt and assign each line to a variable
23:16:38 <skeh> do
23:16:38 <skeh> >		input <- readFile "in.txt"
23:16:42 <Excedrin> that's a lot of variables
23:16:46 <dmead> > :info forall
23:16:47 <lambdabot>  Parse error
23:16:52 <dmead> > info
23:16:53 <lambdabot>  Not in scope: `info'
23:16:56 <dmead> > forall
23:16:57 <lambdabot>  Not in scope: `forall'
23:17:00 <dmead> :type forall
23:17:08 <dons> > readFile "/tmp/f" >>= return .lines
23:17:09 <lambdabot>  <IO [[Char]]>
23:17:14 <dons> skeh: how's that?
23:17:16 <glguy> dmead: try experimenting by messaging lambdabot directly?
23:17:20 <skeh> there will only be 5 lines in in.txt
23:17:27 <dmead> i'm trying to learn parsec
23:17:29 <dmead> ;/
23:17:30 <dons> easy then
23:17:33 <dmead> forall isn't working
23:17:39 <dmead> i want +98 or -98?
23:17:41 <glguy> > fmap lines (readFile "/tmp/f")
23:17:42 <lambdabot>  <IO [[Char]]>
23:18:02 <dons> > do [a,b,c,d,e] <- readFile "/tmp/f" >>= return . lines ; return (a,b,c,d,e)
23:18:04 <lambdabot>  <IO ([Char],[Char],[Char],[Char],[Char])>
23:18:07 <dons> :)
23:18:12 <skeh> thanks dons
23:18:21 <glguy> input <- readFile "/tmp/f" -- this causes the file to be read, and the contents of the file to be assigned to "input"
23:19:01 <glguy> dons: you know better tha nto write a >>= return . f  :-p
23:19:09 <dons> yes
23:19:13 <dons> ?pl a >>= return . f
23:19:14 <lambdabot> f `fmap` a
23:19:16 <dons> as you say
23:19:34 <dons> ?type \f a -> f `liftIO` a
23:19:36 <lambdabot> forall t a. (MonadIO ((->) t)) => IO a -> t -> a
23:20:12 <dons> though there's probably a nice use of >=> or <=< waiting there...
23:20:20 <dons> ah maybe not
23:22:04 <glguy> >=>?
23:22:37 * Maddas rubs his eyes
23:23:47 <dons> kleisli composition, but that's :: (Monad m) => (a -> m b) -> (b -> m c) -> (a -> m c)
23:23:49 <Excedrin> > do h <- openFile "/tmp/f" ReadMode ; line1 <- hGetLine h ; line2 <- hGetLine h
23:23:50 <lambdabot>  Parse error
23:23:51 <dons> so not what we're looking for here
23:24:40 <dons> kiloboot: you're bouncing a bit?
23:25:19 <glguy> threeq as well
23:25:22 <Excedrin> no System.IO :P
23:25:55 <glguy> i dont' think that that is the problem
23:26:05 <glguy> > do { do h <- openFile "/tmp/f" ReadMode ; line1 <- hGetLine h ; line2 <- hGetLine h
23:26:05 <lambdabot>  Parse error
23:26:12 <glguy> > do { do h <- openFile "/tmp/f" ReadMode ; line1 <- hGetLine h ; line2 <- hGetLine h; return (line1, line2) }
23:26:14 <lambdabot>  Not in scope: `hGetLine'
23:26:29 <glguy> there, now it's a problem
23:26:47 <Excedrin> yea, lambdabot and I figured that out in pm
23:27:31 <glguy> ugh, i need sleep
23:39:23 <kiloboot> dons: what do you mean?
23:40:52 <dons> your connection seems to keep dropping and reconnecting. maybe 3 or 4 times anyway. doesn't matter.
23:41:39 <dons> kiloboot: welcome! :)
23:42:03 <dons> kiloboot: you learning haskell? or one of the many russians who seem to know it quite well?
23:43:40 <kiloboot> dons: sure, i'm learining Haskell. trying to dive deep into language. haskell is beatiful.
23:43:52 <dons> :)
23:44:22 <sieni> dons: what would need to be done to compile hs-plugins with ghc 6.6?
23:44:25 <dons> > fix ((1:) . scanl (+) 1) -- have a fixpoint :)
23:44:26 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
23:45:05 <dons> sieni: the .hi file parser needs to be fixed a little. the Typeable stuff torn out , and the package parser checked to ensure it handles module versions (and the symbol lookup also has to handle module versions now)
23:45:17 * lispy gobbles up a fixpoint
23:45:25 <kiloboot> dons: with long imerative background it's not too easy to think differently... but I like math, it would be helpful for me in such haskell deep diving...
23:45:56 <dons> some people find a bit of math helps, but its not required.
23:46:12 <dons> understanding recursion and induction probably helps
23:47:06 <dons> there's actually a new textbook on learning maths by using haskell
23:47:22 <kiloboot> dreaming about L4/Yhc machine , with native code on the fly... Like JNode (www.jnode.org), or IoL4
23:47:29 <dons> mmm :)
23:47:40 <dons> you've seen the other L4-haskell work?
23:47:45 <greentea> dons: Which book is that?
23:47:56 <dons> greentea: http://haskell.org/haskellwiki/Books_and_tutorials#Textbooks
23:47:59 <lambdabot> Title: Books and tutorials - HaskellWiki, http://tinyurl.com/vqzky
23:48:04 <greentea> Thanks. :-)
23:48:19 <dons> oh, wrong link actually:
23:48:39 <dons> http://haskell.org/haskellwiki/Haskell_and_mathematics#Textbooks
23:48:40 <dons> that one
23:48:41 <lambdabot> Title: Haskell and mathematics - HaskellWiki, http://tinyurl.com/yerb92
23:48:54 <kiloboot> dons: there is a russian man (Darkus), who had written a haskell book (in press now). Eager waiting for book...
23:49:03 <dons> kiloboot: oh! do you have a url for it?
23:49:18 <dons> we should add it to the textbooks page
23:49:27 <dons> to this list: http://haskell.org/haskellwiki/Books_and_tutorials#Textbooks
23:49:29 <lambdabot> Title: Books and tutorials - HaskellWiki, http://tinyurl.com/vqzky
23:49:50 <greentea> dons: Hall and O'Donnell?
23:50:17 <greentea> Or Doets and van Eijck?
23:50:25 <dons> greentea:  Kees Doets and Jan van Eijck
23:50:30 <greentea> *nod* Thanks.
23:50:31 <dons> "The purpose of this book is to teach logic and mathematical reasoning in practice, and to connect logical reasoning with computer programming. Throughout the text, abstract concepts are linked to concrete representations in Haskell."
23:51:00 <greentea> In truth, learning Haskell has meant that there's far too much reading i want to do. :-)
23:51:07 <dons> hehe
23:52:52 <kiloboot> dons: about book - not yet. L4/Yhc - I've read a lot of information about: L4, house, hardware monads...
23:53:13 <zeeeee> kiloboot, dons: where can i find more info about this L4 + haskell work?
23:53:45 <dons> here: http://haskell.org/haskellwiki/Research_papers/Program_development#Operating_systems
23:53:47 <lambdabot> Title: Research papers/Program development - HaskellWiki, http://tinyurl.com/y4929f
23:54:06 <lispy> kiloboot: one thing that might occur to you about imperative vs. functional is that functional programs are "inside-out" compared to imperative (concerning control flow)
23:54:14 <kiloboot> dons: Now looking what changes should we made in Yhc/RTS + Yhe to make thing works. Big path made by small steps
23:54:28 <dons> great!
23:54:37 <dons> kiloboot: you on the yhc mailing list?
23:54:45 <dons> i'm sure they'll be interested in what you're looking at
23:55:49 <kiloboot> lispy: yes, Haskell mostly from top to bottom -> C from bottom to top
23:57:13 <lispy> kiloboot: but also, in haskell you create the control flow once and then pass in the behavior, contrasted with imperative where you usually have to keep writing the control flow and the behiavor...well that usually has to be rewritten as well
23:57:39 <lispy> kiloboot: map and fold are examples of what i mean
23:58:13 <lispy> kiloboot: anyway, just a meta comment to help you adjust your thinking to FP
23:58:57 <kiloboot> lispy: yes, Prelude good point on this
