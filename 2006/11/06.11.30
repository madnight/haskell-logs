00:10:05 <dons> mmm today was the busiest day we've had in channel, http://www.cse.unsw.edu.au/~dons/irc/haskell-06.html >350k of text :)
00:10:06 <lambdabot> Title: #haskell @ freenode.org stats by dons, http://tinyurl.com/kpre5
00:11:46 <monochrom> probably because of the blog on why fp doesn't matter.
00:12:01 <dons> i'm sure that helped
00:12:21 <dons> you mean, why the halting problem means you can't make proofs about program? :)
00:12:54 <monochrom> Strange, somehow everyone mentioned that, and somehow I can't recall seeing that on that blog.
00:13:16 <dons> yeah, in the section about verifying traffic control software
00:13:39 <monochrom> Ah.
00:14:09 <kfish> dons: heh, what's the timezone on those stats?
00:14:28 <dons> west coast US
00:15:01 <dons> oh hang on. maybe mot. the logs are, but the stats would be .au time
00:15:22 <astrolabe> where was this blog?
00:17:56 <kfish> dons: i would have expected sydney standard mean time :-)
00:22:45 <astrolabe> Does anyone have a link to a recent blog on why fp doesn't matter please?
00:25:58 <monochrom> astrolabe: http://warp9point99.blogspot.com/2006/11/sincere-comment-on-functional.html
00:26:01 <lambdabot> Title: warp 9.99!: A sincere comment on functional programming, http://tinyurl.com/yhc4w6
00:26:18 <monochrom> I exaggerate.
00:27:27 <astrolabe> thank you
00:27:59 <shapr> astrolabe: Do you want to see my response?
00:30:43 <dolio> I'd probably enjoy them.
00:31:16 <astrolabe> For goodness sake!  Some people shouldn't be allowed to write blogs.  There should be some kind of competancy test.
00:31:50 <shapr> astrolabe: dons said exactly that earlier.
00:31:57 <shapr> er, maybe it was dcoutts
00:32:01 <astrolabe> shapr: yes please but I have to go now, I'll try to catch your comments or you later. Also I'll ask how the chessboard is going ;)
00:32:16 <shapr> oh right, I got distracted :-)
00:34:05 <Svrog> ive seen the author of the blog post quite a lot on lambda the ultimate - usually arguing about functional languages
00:36:45 <shapr> dolio: Most of my response boils down to two points, 1. the thing he says is beneficial that is not referential transparency is in fact referential transparency and 2. many of the points he responds to are not actually being communicated by that blog post
00:37:22 <Svrog> i wouldnt usually remember someone like that but he seemed quite uninformed and very persistent in that he'd bring up the same stuff in heaps of different threads regarding functional languages
00:37:38 <shapr> Yeah, that's my summary as well. Persistently uninformed.
00:37:39 <dolio> shapr: Yeah, that was my reaction to a lot of his stuff.
00:38:14 <dolio> "You don't need referential transparency. All you need is for the functions to depend only on their arguments."
00:38:22 <shapr> exactly
00:38:43 <dolio> It was either that, or my thinking, "Who exactly makes this claim about functional languages?"
00:38:52 <thyko_> how do i jump out of a ghci prompt
00:38:58 <shapr> :q
00:39:01 <thyko_> get out  of it?
00:39:03 <shapr> :q
00:39:13 <thyko_> boom!
00:39:14 <thyko_> thanks
00:39:19 <shapr> That's short for :quit
00:39:22 <shapr> But you might like :help
00:39:49 <dolio> Like "Hot deployment is not possible with an imperative language." Who would claim that?
00:40:08 <shapr> dolio: Nobody :-)
00:40:30 <shapr> dolio: or "Imperative programs can not be assisted by formal proofs." wtf?
00:40:30 <dons> dolio: its a very strange blog post, i wouldn't waste brain cycles on it
00:40:39 <thyko_> http://rafb.net/paste/results/snGJfl23.html
00:40:44 <dolio> Heh.
00:40:51 <thyko_> why is that cose giving me errors?
00:40:52 <dons> something about 'strawman' springs to mind...
00:41:15 <dolio> I do like his code re-ordering example. :)
00:41:30 <dons> thyko_: where's 'x' coming from?
00:42:16 <thyko_> hey, im 48 hours old in this
00:42:27 <dons> ?paste is better too
00:42:28 <lambdabot> http://paste.lisp.org/new/haskell
00:42:29 <thyko_> yeah it should be 'signum x =
00:42:37 <thyko_> '
00:42:40 <dons> yep :)
00:42:57 <lisppaste2> dons pasted "thyko" at http://paste.lisp.org/display/30989
00:42:58 <dons> thyko_: ^^
00:43:23 <shapr> dolio: http://www.scannedinavian.com/~shae/achilleas-response - hope it's not too snippy
00:43:26 <lambdabot> http://tinyurl.com/ydgmvl
00:43:41 <dons> wasabi is addictive. I used to find it crazy hot, now I need to put it on everything.
00:43:57 <dolio> Whatever. I enjoy snippy. :)
00:44:35 <shapr> dons: awesome!
00:45:54 <dons> QuickCheck has also bee ported to Java
00:46:00 <dons> and ruby
00:46:44 <dons> shapr: I'd just say "you are on crack" to "The halting problem proves that no algorithm can be proven correct" ;)
00:47:00 <shapr> dons: Yeah, that would have been faster =)
00:47:26 <shapr> Maybe I should have just thought "Achilleas is on crack." instead of responding and saved myself some time.
00:48:02 <johnnowak> shapr: i'm sure many appreciated it
00:48:40 <dons> its just a silly, rambling blog by someone who doesn't understand basic things. it might even be a MegaMonad of troll posts to reddit ...
00:48:54 <dons> it has a certain MegaMonad quaity
00:49:01 <johnnowak> it's not necessarily -- this is how people learn.
00:49:08 <johnnowak> some people learn more loudly than other though...
00:49:12 <dons> hehe true
00:49:20 * kosmikus is reading
00:49:54 <dons> kosmikus: the original? I think we're giving it more attention that is deserved..
00:50:20 <kosmikus> hehe
00:50:23 <shapr> On the downside, Achilleas' persistent lack of clue is most of the reason I stopped posting/reading on LtU.
00:50:26 <kosmikus> that's what I think now, too
00:50:47 <dons> shapr: ah, so this guy has a history?
00:50:53 <dons> there should be keyboard licenses
00:51:02 <shapr> He's the loudest of several who have almost that same attitude.
00:51:07 <kosmikus> it's almost embarassing to write such a long article about a concept (referential transparency) that you obviously haven't even bothered to look up in a dictionary
00:51:21 <shapr> Truly
00:51:28 <dons> s/almost//
00:51:50 <kosmikus> well, I'm a tolerant person :)
00:51:58 <shapr> SFTW! is rarely heard on #haskell, but for once, I think it is deserved.
00:52:04 <shapr> um STFW!
00:52:06 <Svrog> im always tempted to reply to posts and threads like that but i try to force myself not to do it
00:52:08 * shapr needs sleep
00:52:42 <dons> on the good sign of the blog space, did people see alphecar's new monad tutorial?
00:52:50 <shapr> Yeah, pretty colors!
00:53:09 <Svrog> link?
00:53:17 <dons> http://programming.reddit.com/info/t123/comments
00:53:19 <lambdabot> Title: A Newbie in Haskell land (reddit.com), http://tinyurl.com/y5p3br
00:53:20 <dolio> shapr: One thing: your response to "Are they possible only in functional languages? No way!" reads like you didn't see the "only".
00:53:31 <Svrog> thanks
00:53:35 <AtnNn> yeeah, i reaed that. how dose deriving Monad work?
00:53:46 <shapr> dolio: Oh, I didn't, doh!
00:54:02 <dons> yeah, we need more tuts on actually deriving Monad*. underutilised
00:54:09 <dolio> Of course, that seems like another example of "nobody claims they're only ..."
00:54:19 <shapr> Yeah, can you really derive a two parter like (MonadReader Int) ?
00:54:28 <shapr> I had no idea!
00:54:48 <dons> its newtype deriving, isn't it?
00:55:46 <dons> AtnNn: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#newtype-deriving
00:55:48 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
00:57:05 <shapr> oh cool
00:57:41 <AtnNn> yeah, that is cool
00:57:45 <kosmikus> "The halting problem proves that no algorithm can be proven correct" <- ??
00:59:16 <flux__> I would assume that the context limits the set of algorithms it is referring to..
00:59:42 <dons> kosmikus: its been the WTF of the day ;)  --> $ grep 'halting problem' 06.11.29  | wc -l
00:59:46 <dons> 13
00:59:55 <johnnowak> poor boy.
01:00:08 <greentea> kosmikus: Yes, that's obviously wrong; it's actually been proved that there a situations in which we can't know whether a person's stupidity will ever terminate.
01:00:11 <dons> flux__: don't assume anything!
01:00:17 <shapr> greentea: bwahaa
01:00:23 <dons> greentea: hehehe
01:00:29 <kosmikus> dons: ok
01:00:41 <shapr> greentea: Of course, somedays I feel that way about myself...
01:01:09 <dons> ?remember greentea it's actually been proved that there a situations in which we can't know whether a person's stupidity will ever terminate.
01:01:38 <lispy> who said that anyway?
01:01:49 <dons> oh no. not again!
01:01:51 <dons> let's kill it!
01:02:00 <dons> quick, look at this instead --> http://www.alpheccar.org/en/posts/show/60
01:02:02 <lambdabot> Title: A newbie in Haskell land or another monad tutorial
01:03:06 <greentea> shapr: i /know/ that about myself. :-) But i try to at least access some input which i hope will reduce the value of stupidity_level. :-)
01:03:07 <lispy> ?where logs
01:03:08 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
01:03:59 <AtnNn> if you are interested, you can also take a look at this: http://www-etud.iro.umontreal.ca/~laurieti/parser.html
01:04:02 <lambdabot> Title: Interesting parsers in Haskell, http://tinyurl.com/y92bhx
01:05:05 <dons> AtnNn: oh nice. is that yours ?
01:05:08 <AtnNn> yes
01:05:45 <dons> AtnNn++ nice work
01:05:49 <AtnNn> thanks
01:06:14 <dons> AtnNn: you should reddit it :)
01:06:34 <AtnNn> you think?
01:07:17 <dons> yeah, I reckon. I can post if if you like, or you can do it
01:07:41 <AtnNn> ill do it, worst that can happen is getting a few hits
01:08:26 <dons> great.
01:08:34 <dons> dump the url here, since people will want to read it
01:09:10 <dons> you might want to look at using HsColour to do syntax highlighting of the haskel lcode
01:09:16 <dons> can make them quite pretty to look at :)
01:10:03 <dons> here's a quick demo, http://cgi.cse.unsw.edu.au/~dons/blog/2006/09/10#colours
01:12:30 <AtnNn> it looks nice
01:15:01 <dons> ah, I see the link now, http://programming.reddit.com/info/t1vq/comments
01:20:55 <ProfTeggy> kosmikus, which article are you reading?
01:23:57 <metaperl> dons - I am fairly proud of my self-reteaching on how to write your own version of unzip : http://sequence.complete.org/node/235  ... the last section "an entirely different approach", I am particularly wired about... it might have an input into your efforts to teach Haskell
01:24:56 <metaperl> parallel, not parrallel :)
01:24:56 <kosmikus> ProfTeggy: oh, only that blog entry that everyone here was talking about
01:25:11 <kosmikus> ProfTeggy: it's not important
01:26:09 <dons> metaperl: nice! yes, the trick that you can reflect the type syntax to give you a sketch of the actual implementation i also use
01:26:17 <dons> all the time for folds and scans, for example
01:26:26 <dons> ?type foldl
01:26:27 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
01:26:58 <dons> > foldl (\a b -> a+1) 0 [1..10]
01:27:00 <lambdabot>  10
01:27:35 <metaperl> yes, it was a neat thing to trip up on.
01:27:36 <dons> metaperl: its probably not widely appreciate how useful it is to have the same syntax for the type and value level in haskell (unlike say ML)
01:27:50 <dons> that (1,2) :: (Int,Int) must be really useful
01:27:53 <metaperl> yeah . I dont know ML but I can appreciate your point
01:27:58 <metaperl> yeah
01:28:12 <metaperl> so are you going to take over sequence?
01:28:19 <dons> and for nice types like [(a, b)] -> ([a], [b]), it definitely helps
01:28:28 <metaperl> nice?
01:28:30 <dons> metaperl: well maybe. i'd prefer to just make the skin a bit more modern
01:28:31 <TSC> Is there a typo?  : "unzip [] = ([].[])"
01:28:36 <dons> s/nice/well structured/
01:28:37 <metaperl> is "nice" being used technically?
01:28:44 <metaperl> oh :)
01:28:53 <dons> a type that has a bit of structure to it
01:28:56 <metaperl> yes
01:29:59 <xerox> metaperl: why the second case?
01:30:10 <metaperl> xerox - what 2nd case?
01:30:15 <xerox> unzip
01:30:44 <metaperl> xerox - are you referring to a particular line of code?
01:31:01 <xerox>       unzip  (a, b) : []  = (a : [], b : []) -- rewrite in cons notation
01:31:34 <TSC> I think that's just "working out"
01:31:36 * metaperl looks
01:31:48 <metaperl> oh yea, that is just derivation
01:31:49 <TSC> It leads to the last line
01:31:52 <metaperl> yes
01:31:58 <xerox> ah.
01:32:14 <xerox> nevermind
01:32:22 <metaperl> :)
01:32:23 * xerox goes to catch the bus
01:32:27 <metaperl> later!
01:37:36 <tibbe> it's the last day of my internship an I've got nothing to do, can someone recommend a good paper?
01:38:04 <lispy> tibbe: which subject?
01:38:45 <tibbe> um, doesn't matter much, something at my level ;)
01:38:55 <tibbe> don't ask me what my level is cause i don't know
01:39:13 <tibbe> something useful perhaps
01:39:33 <tibbe> like the classics, tackling the aqward squad etc
01:40:44 <lispy> tibbe: http://idea-log.blogspot.com/2005/10/why-are-continuations-so-confusing-and.html
01:40:46 <lambdabot> Title: idea.log: Why Are Continuations So Confusing, and What Do They Really Do?, http://tinyurl.com/yjcpqd
01:41:59 <lispy> tibbe: http://www.cs.pdx.edu/~sheard/papers/PutCurryHoward2WorkFinalVersion.ps
01:42:02 <lambdabot> http://tinyurl.com/yxpzws
01:43:39 <tibbe> lispy, thanks, I'll check em out
01:43:57 <lispy> tibbe: http://homepages.cwi.nl/~ralf/OOHaskell/
01:43:59 <lambdabot> Title: Haskell's overlooked object system
01:44:04 <lispy> tibbe: enjoy :)
01:44:57 <lispy> tibbe: one last one and then i'll go to bed: http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
01:44:59 <lambdabot> Title: Monad Transformers Step by Step, http://tinyurl.com/esboz
01:45:19 <tibbe> alright, I'll print those and find me a nice chair
01:45:21 <tibbe> take care
01:46:16 <lispy> tibbe: you may want to swap oohaskell for hlist
01:50:41 <tibbe> lispy: ok
01:52:17 <araujo> morning
02:06:55 <kosmikus> moin swiert
02:09:10 <Philippa> mornin'
02:13:17 <swiert> hi kosmikus
02:42:12 * malcolm_ hassles dons once again about his fps patches
02:42:36 <glguy> ?localtime dons -- wonders what time it is down there
02:42:38 <lambdabot> Local time for dons is Thu Nov 30 21:37:11 2006
02:46:33 <Saizan> where is he from? Australia?
02:46:50 <glguy> I believe that that is where he is now
02:46:58 <glguy> but I don't think that is where he's from
03:32:03 <dons> mm, new haskell code, what's this: http://shejun.blogspot.com/2006/11/meep-for-developers.html
03:32:05 <lambdabot> http://tinyurl.com/y72qqa
03:32:15 <dons> malcolm_: acknowledged
03:32:52 <malcolm_> dons: actioned? :-)
03:33:24 <dons> getting there (busy organising travel to the UK today). its on my front-of-mind list
03:33:28 <dons> oh "meep: Meep (or MEEP) is a free finite-difference time-domain (FDTD)
03:33:29 <dons> simulation software package developed at MIT to model electromagnetic
03:33:31 <dons> systems.
03:33:41 <dons> written in haskell!
03:34:03 <dons> ?where+ meep http://ab-initio.mit.edu/~meep/meep/
03:34:04 <lambdabot> Done.
03:34:39 <dons> ah, mostly C, but some new haskell code in there.
03:35:45 <therp> is there some low level printing command that will dump you the constructor of an object, regardless whether it's deriving from Show? GHC
03:35:48 <dons> mm. looks like haskell's doing code generation
03:36:09 <dons> therp, nope. derive Show
03:36:39 <earthy> or Data
03:36:57 <earthy> if you only want the constructor. ;)
03:36:59 <dons> good idea earthy
03:37:02 <therp> because, I need to debug a piece of code and want to inspect the objects..
03:37:34 <dons> perhaps use a proper debugger like hat then? or derive Show and print things
03:37:50 * earthy thinks   deriving (Show, Typeable, Data)   should almost be default
03:39:14 * robreim thinks show should probably be such that x == (read . show) x. Which is probably why it isn't currently default.
03:39:39 <earthy> um
03:39:52 <earthy> the derived instances do have that property, IIRC
03:40:00 <dons> robreim: that's supposed to be the case. there's a few interesting exceptions, but that should generally hold
03:40:26 <dons> deriving Read and Show bloats code a bit
03:40:30 <mux> @check (\x -> (read . show) x == x) :: String -> Bool
03:40:33 <lambdabot>  OK, passed 500 tests.
03:40:40 <robreim> earthy: yeah, but unless I'm wrong were you suggesting everything should have show by default? I imagine it'd be pretty hard to have a good read by default to mirror it...
03:40:56 <earthy> robreim: why?
03:42:00 <robreim> I figure stuff like (read . show) (putChar 'x') == putChar 'x' would be hard
03:42:06 <therp> hm, maybe a compilation switch would be nice that makes every ADT deriving from Show, Typeable, Data when given.
03:42:17 <earthy> robreim: how would you derive show for that? :)
03:42:29 <earthy> there's no instance of show for functions
03:42:39 <earthy> in general
03:42:47 <robreim> earthy: Ah, so you you were'nt saying what I thought you were :)
03:42:55 <dons> > ord -- only special ones
03:42:57 <lambdabot>  <Char -> Int>
03:43:02 <robreim> I mistook you as saying you thought everything should have show by default :)
03:43:25 <earthy> I was saying every ADT should have show by default if derivable
03:43:40 <robreim> *nods* gotcha
03:44:49 <earthy> okay
03:44:58 <earthy> my code isn't being called.
03:45:11 <earthy> *huh*!?
03:45:31 <earthy> pity I don't have hat on my machine yet
03:46:20 <malcolm_> hat still needs a bit of work to bring it up to the current state of play in Haskell land, unfortunately
03:46:34 <earthy> I'm still at 6.4.1 anyway
03:47:08 <malcolm_> earthy: hat is probably more OK for 6.4.1 than 6.6, true
03:48:31 <dons> mm. yaxu's work is getting noticed in blog land, http://hemiolesque.blogspot.com/2006/11/algorithmic-music-in-real-time.html
03:48:34 <lambdabot> Title: Hemiolesque: Algorithmic Music in Real Time, http://tinyurl.com/y542df
03:51:01 <dons> dcoutts: mm. interesting response on the list, "One may say that ByteString makes
03:51:05 <dons> explicit what the "Optimistic Haskell Compiler" aimed to make implicit"
03:51:21 <dons> (lazy bytestrings, he means. doings steps of strict chunks, then suspending)
03:51:50 <pejo> dons, optimistic compiler as in the work by Ennals?
03:52:05 <dons> there were two, Ennals, and another
03:52:08 <earthy> !autolart
03:52:19 <earthy> no wonder my code isn't called
03:52:24 <earthy> I'm running the wrong binary
03:52:24 <pejo> dons, eager Haskell - Maessen (sp?)?
03:52:29 <dons> ah yes.
03:52:32 <dons> that's the one.
03:52:37 <pejo> (Someone pointed me to that work yesterday, I thought htey meant Ennals work).
03:53:18 <dons> that's an interesting connection to eager eval, I think.
03:53:27 <dons> that we can do it in a library for some data types, mm...
04:11:24 <pejo> dons, have you pondered the possibility of the bytestring speedups without modifying code, instead fiddling with the compiler?
04:13:58 <dons> pejo, well we've done a lot of talking to spj about improving the rules system, and the optimiser (particularly specConstr) which made the whole thing posible
04:13:59 <SamB_XP> pejo: huh?
04:14:04 <dons> so i'll just leave that to simon :)
04:14:30 <dons> but adding optimisations via user-land rewrite rules is a lot more "agile" than having to modify the compiler
04:14:36 <dons> so if you can do it that way, i encourage it
04:14:57 <SamB_XP> yeah, you only need to improve the compiler when something is wrong with it!
04:15:17 <dons> and we can use lots of domain specific knowledge that doesn't work as a general optimisation
04:15:25 <pejo> dons, I'm not that familiar with the inner structure of the optimizer, what is specConstr?
04:16:03 <dons> its a particular little optimisation we need to work really well to strip away constant constructor applications from the Stream data type.
04:16:13 <pejo> dons, improving the rules system as in making it more flexible, or adding more rules?
04:16:27 <dons> more powerful, matching better, more stable
04:16:47 <SamB_XP> the rules system is the part of the compiler that deals with rules
04:16:56 <SamB_XP> the rules are ... the rules, of course!
04:17:34 <dons> this recent change (today!) is something we requested for the fusion work: http://www.haskell.org/pipermail/cvs-all/2006-November/051770.html
04:17:37 <lambdabot> Title: SpecConstr, http://tinyurl.com/tt428
04:18:07 <pejo> SamB, one could choose to distribute a set of rules with the compiler, considering it to be a part of the rules system (ie all installations of ghc 6.6 would have those rules, whereas some installations would have even more rules).
04:18:18 <SamB_XP> pejo: um.
04:18:41 <SamB_XP> the rules are lexically scoped, so, um, how are you going to include rules in the compiler for things that aren't wired in?
04:18:52 <SamB_XP> and, uh, why would you want to?
04:19:29 <SamB_XP> when you could just include them in the relevant source file?
04:20:48 <Cale> Hmm, what do people think of the whole defaulting thing? If anything, I was originally of the opinion that the defaulting mechanism should be generalised, since it seems unusual (at least at first) that it should only work with Num
04:21:13 <SamB_XP> it isn't nice that it doesn't work for Bits, I'll say that much
04:21:40 <Cale> The things people are proposing to do with it sound a bit like the wrong idea to me.
04:21:53 <SamB_XP> > 3 `xor` 243
04:21:54 <lambdabot>  Add a type signature
04:22:00 <Cale> You really need to allow more than one default type per class.
04:22:13 <SamB_XP> definately
04:22:34 <pejo> SamB, I think we misunderstood eachother.
04:22:45 <Cale> Removing defaulting altogether sounds like it's probably horribly inconvenient.
04:22:46 <SamB_XP> pejo: oh?
04:22:50 <SamB_XP> pejo: what did you mean?
04:22:57 <SamB_XP> Cale: quite so!
04:23:30 <SamB_XP> at the very very least, I think it should be possible to tell the compiler "treat this class like Num and friends"
04:23:32 <Cale> (On the other hand, I'm not opposed to removing the MR, as it's given me nothing but confusing problems)
04:23:39 <pejo> SamB, there must be some "global" rules, for things in the Prelude for example.
04:23:53 <malebria> @paste
04:23:54 <lambdabot> http://paste.lisp.org/new/haskell
04:23:59 <SamB_XP> pejo: those rules are in the source for Prelude
04:24:04 <pejo> dons, interesting.
04:24:07 <SamB_XP> except the rules for primitive things, of course
04:24:12 <lisppaste2> malebria pasted "Impossible?" at http://paste.lisp.org/display/31005
04:24:19 <Cale> for example, try writing something like  forM = flip mapM, and then using it in an ST computation without giving it a type signature
04:24:26 <SamB_XP> those rules are in prelude/PrelRules.lhs, or maybe it is just .hs
04:24:36 <SamB_XP> or maybe I forget the filename altogether
04:24:59 <pejo> SamB, and the Prelude comes with the compiler..
04:25:12 <SamB_XP> pejo: well, yes, but that is incidental
04:25:15 <Cale> malebria: uh-oh!
04:25:26 <SamB_XP> pejo: so does Data.ByteString, anyway
04:25:40 <SamB_XP> so those rules come with the compiler just as much as the ones for Prelude
04:26:07 <malebria> Cale: should I report it?
04:26:14 <Cale> malebria: I think so
04:26:27 <SamB_XP> (now, mind you, GHC's Prelude doesn't actually define more than one or two functions directly -- most of them are in other modules)
04:26:29 <Cale> malebria: It's extremely unclear where the bug would be from just that though
04:26:43 <Cale> malebria: Perhaps see if you can get it to repeat on a subset of your code
04:26:48 <malebria> Maybe sending the file that was being compiled by the time?
04:26:57 <Cale> yeah
04:27:12 <SamB_XP> malebria: I'd send the whole tree
04:27:41 <malebria> I'll send everything.
04:27:55 <malebria> I just noticed that I wasn't even editing this file.
04:28:14 <malebria> It hasn't changed since last correct build.
04:28:16 * Cale wonders if it has to do with the old .o files sitting around.
04:28:19 <malebria> So the problem is in the others.
04:28:30 <SamB_XP> Cale: surely you can't be serious
04:28:42 <Cale> and/or .hi's
04:28:50 <SamB_XP> exactly ;-)
04:29:17 <dcoutts> dons, if we can match on monadic binds then we could do some examples without having to change user's code. If we can make hGetContents fuse with consumers for example.
04:29:43 <Cale> Maybe save a copy the tree with all the temporaries, and then delete all the temporaries and rerun the compile.
04:29:54 <malebria> Cale: good idea.
04:30:21 <SamB> hmm.
04:30:26 <SamB> what would that do for you?
04:31:08 <malebria> After make clean; make it compiled ok.
04:31:12 <SamB> anyway, clearly the compiler shouldn't be using fromJust their
04:31:16 <SamB> er.
04:31:19 <SamB> there
04:31:28 <SamB> wherever *that* is
04:31:35 <Cale> SamB: well, this is a bug, so who knows what it really does for you :)
04:32:29 <SamB> I suppose if you built the compiler for profiling, perhaps with -auto-all, you'd be able to get a better idea where the problem was
04:32:52 <Cale> yeah, and ran it with -xc
04:33:43 <Cale> augh, people are proposing the type of the right hand parameter to ^ be specialised to Int
04:33:58 <Cale> If anything, Int should be removed from the Prelude.
04:34:33 <Cale> It's a useful optimisation, but performance with Integer is quite acceptable for most things.
04:34:56 <SamB> Cale: well yes
04:35:18 <SamB> about -xc
04:35:31 <Cale> also, I rather like the types of (^), (^^), and (**)
04:35:38 <SamB> @type (^^)
04:35:40 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
04:35:54 <SamB> yeah, there's nothing wrong with the type of ^ for sure...
04:36:17 <SamB> and ^^ has a nice enough type, though I can never remember what it is
04:36:18 <Cale> They almost exactly correspond to three definitions of exponentiation from mathematics.
04:36:22 <malebria> =(
04:36:26 <malebria> I lost the interface files.
04:36:29 <SamB> ** is a bit annoying, though, having both arguments the same type
04:36:42 <Cale> Well, there's nothing you can do about that!
04:36:44 <malebria> I've backuped a link to the directory with .tar.gz
04:36:52 <SamB> are you certain?
04:36:55 <Cale> yep
04:37:23 * SamB pouts
04:37:26 <Cale> The whole idea behind ** is that a ** b = exp(log a * b)
04:37:56 <Cale> That form of exponentiation comes from the fact that you have an exp and log, and multiplication.
04:38:53 <SamB> in maths you can do $a^b$ even when $b \in {\mathbb Z}$
04:40:18 <SamB> well.
04:40:22 <SamB> thats not a good example.
04:40:35 <SamB> also when b is a rational
04:55:34 <Cale> @type (^^)
04:55:36 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
04:55:42 <Cale> SamB: ^^
04:56:42 <SamB> I said *b*
04:56:48 <Cale> If you move to rational exponents, you're going to get things like (sqrt 2) as results.
04:57:07 <SamB> I meant, with **...
04:57:07 <Cale> Which means you need something like algebraic numbers or real numbers.
04:57:28 <Cale> ah, I see what you mean
04:58:00 <Cale> Yeah, I suppose you could take that into consideration. Normally I'm content to completely ignore that definition of exponentiation.
04:58:37 <Cale> It's usually not worth the extra trouble of defining 2^(1/2) before defining 2^(sqrt(2))
04:58:51 <Cale> (as well)
04:59:26 <Cale> Though I can see in some cases where you might want that.
05:07:07 * greentea is away: I'm busy
05:17:51 <CosmicRay> good morning, everyone!
05:20:55 <tibbe> hmm, is it possible to enforce purity in a dynamically typed language, I can't imagine how that could be done :/
05:22:02 <tibbe> CosmicRay, good morning
05:23:04 <Cale> tibbe: purity as in no-IO?
05:23:14 <Cale> and/or no side effects?
05:23:15 <Cale> Sure
05:24:04 <Cale> You can use a monad for IO, and simply not allow values typed in the IO monad to ever be observed farther than saying "I am an IO action"
05:24:25 <CosmicRay> morning tibbe
05:24:38 <tibbe> Cale, no side effects
05:24:42 <Cale> and then just not have primitives for state
05:24:50 <Cale> (apart from those in that monad)
05:25:09 <Cale> I was thinking about writing a scheme which did this.
05:25:22 <tibbe> me too :)
05:25:26 <malcolm_> Cale: can you give an example of why you might need more than one default for a class?
05:25:31 <tibbe> not a scheme exactly but
05:25:47 <Philippa> malcolm_: "in this module I am working with Currency"?
05:26:14 <malcolm_> Philippa: huh?
05:26:16 <Cale> malcolm_: well, Data.Bits
05:26:33 <Philippa> malcolm_: for Num or similar
05:26:39 <Philippa> or do you mean more than one within the same module?
05:26:55 <malcolm_> Cale: what defaults would you want?  how would you distinguish them?
05:27:01 <Cale> I'm not sure whether that issue might just resolve itself once the restriction that defaults have to be from Prelude classes goes away
05:27:17 <Cale> Things which are instances of Num, mostly.
05:27:47 <Philippa> yeah, generalising defaulting to any class fixes a lot
05:27:56 <Philippa> hmm... might be more awkward with MPTCs
05:28:22 <malcolm_> Cale: so, if the type is in both Num and Currency (or Bits or whatever), then just defaulting the Currency value to your chosen type is enough, no?
05:28:27 <Philippa> if you take an instances-are-modules approach, defaulting's just a special case of instancing anyway - the one where you've got no type info to work with
05:28:43 <Philippa> malcolm_: Currency was intended as a type, not a class
05:29:01 <malcolm_> Cale: you can ignore the Num part, because it is a superclass of Currency anyway
05:29:11 <Cale> malcolm_: Suppose Currency is a class which is not a superclass of Num
05:29:24 <Philippa> mmm, point. Some of the laws don't necessarily work right
05:29:29 <Philippa> different rounding, stuff like that
05:29:34 <Cale> er, subclass
05:29:36 <malcolm_> Philippa: Oh, I see.  But per-module defaults would allow you to do that anyway.
05:30:09 <Cale> (for whatever reason, perhaps we want to allow for currencies where it doesn't make sense to multiply)
05:30:33 <malcolm_> Cale: if your Bits class is not a subclass of Num, then a default on the Bits-only value is easy.
05:30:50 <Philippa> *ah*, yeah. Different default if multiple classes apply
05:31:34 <malcolm_> Cale: it only gets tricky if your value is constrained by both Num and Bits, where there is no hierarchical relationship between those two classes. and their defaults are different.
05:31:39 <Philippa> creating a new subclass of them both with no new methods doesn't fix it IIRC - the typechecker won't refer to it
05:31:59 <Cale> If you have a different default for Bits and Num, and both end up landing in some context, you get an error then, which might actually be the right thing, but there's no way to configure the defaults so you don't.
05:32:07 <Cale> right
05:32:27 <Cale> How about if we allow for more than one class to be specified in a default decl?
05:32:30 <Axioplase> Hi
05:32:46 <malcolm_> Philippa: I was going to say that in such a case, you could add a signature for the new subclass - but in that case you might as well just add a type signature for the value and be done with it - no defaulting required
05:32:50 <Philippa> then you get all the overlap and so forth issues that occur with MPTCs already
05:33:22 <Philippa> which isn't to say don't allow it, just that they're there
05:34:08 <malcolm_> My view is that, if you have to do complicated things with overlapping defaults to get the system to pick the right one, then you will probably get the default decls wrong.  Why not just force the user to resolve the ambiguity in a more definite and obvious way - with a type sig.
05:34:37 <Axioplase> Hum... If class B herits from class A. Can class B redefine A's operators ? (just as in usual OOP)
05:34:44 <Cale> malcolm_: I suppose that makes some sense.
05:34:58 <Philippa> Axioplase: it's not classes that define operators, it's instances
05:35:02 <Axioplase> Or can it just define new operators ?
05:35:04 <malcolm_> However, I'm prepared to be persuaded by a really cool example that needs multiple defaults per class...
05:35:14 <Philippa> but B can't give new types for A's methods
05:35:57 <Axioplase> Philippa: as long as the type suits, if it can have an other behaviour, then I'm happy
05:37:39 <Philippa> Axioplase: do you understand how type classes differ from OO classes? Starting with the fact they're not types?
05:37:40 <Cale> malcolm_: yeah, it's not altogether clear that one must exist, it just seems moderately likely. There might be a way that this fits in with class aliases to end up making the whole thing a moot point though.
05:37:53 <ndm> @seen dcoutts
05:37:53 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts speak 1h 8m 37s ago.
05:38:11 <thyko> is there some kind of IDE for Haskel on linux?
05:38:15 <CosmicRay> what does everyone think of Haskell Utility Library (HUL) as the new name for MissingH?
05:38:30 <ndm> yuk
05:38:30 <CosmicRay> thyko: the standard answer, of course, is Emacs.  there is also hIDE, I think, but I don't know how mature it is
05:38:34 <Philippa> works
05:38:39 <Philippa> is it still going to be GPL?
05:38:43 <ndm> I like MissingH
05:38:50 <Volatile> there's always vim
05:38:52 <Axioplase> thyko: vim :)
05:39:00 <CosmicRay> Philippa: I will probably make it LGPL
05:39:08 * Volatile is coding haskell in vim as we speak
05:39:16 <CosmicRay> ndm: I've gotten a number of complaints that the name is not very descriptive
05:39:17 <Axioplase> Though its indent file is quite bad.
05:39:18 <malcolm_> CosmicRay: didn't some people (including me) suggest splitting MissingH up into mulitple smaller libraries?  Each of those needs a name
05:39:29 <thyko> CosmicRay: why does mode-haskell have so many other modes with it
05:39:30 <earthy> cosmicray: I'd prefer 'Haskell Utility Libraries'
05:39:32 <CosmicRay> the general plan is to split off the major parts into individual packages (eg, ConfigParser, HVFS, etc)
05:39:35 <thyko> in the tgz?
05:39:38 <earthy> implying the fact that you can pick and choose
05:39:45 <CosmicRay> MissingH will then be whatever small pieces don't get accepted into base
05:39:55 <ndm> CosmicRay: I think the library for missing functions is still great as MissingH, for the main part
05:39:59 <thyko> or is mode-haskell all i need?
05:40:07 <Philippa> CosmicRay: LGPL's not so bad for me, but probably a barrier for a number of commercial users still given comments at CUFP and similar
05:40:11 <CosmicRay> ndm: btw, feel free to darcs send me those patches you were talking about
05:40:18 <Philippa> but hey, I'm one of those BSD nutters - what do I know?
05:40:20 <CosmicRay> Philippa: really, LGPL is a barrier even?
05:40:26 <CosmicRay> what are their complaints?
05:40:31 <CosmicRay> LGPL is really not that different from BSD
05:40:34 <ndm> CosmicRay: i might wait til you have a new repo set up
05:40:42 <thyko> CosmicRay: ?
05:40:49 <Philippa> Probably managerial. Though there're also the potential issues with GHC/cross-module inlining
05:40:59 <CosmicRay> thyko: what are you asking?
05:41:11 <ndm> Philippa: not really, thats not a violation of the GPL if a compiler does it for you
05:41:12 <thyko> is mode-haskell all i need?
05:41:19 <CosmicRay> thyko: ah, yes, I think it is.
05:41:27 <Philippa> ndm: if it bugs me, it'll scare the shit out of a manager...
05:41:37 <Philippa> ...and it won't be worth assigning a lawyer to check over
05:41:37 <sek> im failing once again to understand the difference between all these number types. I have written: countInts :: RealFrac a => (a, a) -> Integer \n countInts (n1, n2) = (floor n2) - (floor n2)   and try to apply countInts (5/2, 15/2) and it gives 0
05:41:40 <SamB> ndm: surely it is at least as bad as static linking?
05:41:52 <thyko> what are the other modes for then? coz the archive comes with like 5 other modes
05:42:02 <ndm> Philippa: all a manager will know is "GPL = bad", i don't think he'll care about "cross-module what-d-ya-ma-call-it"
05:42:05 <Philippa> SamB: the problem's that it's stronger, no?
05:42:18 <Philippa> ndm: but he might care that "there are issues with LGPL and GHC"
05:42:37 <Cale> sek: it's not a type problem ;)
05:42:43 <ndm> SamB, yes, but GHC does both, so i don't think its any worse
05:42:44 <Cale> sek: x - x is usually 0
05:42:51 <sek> oh crap
05:42:53 <earthy> LGPL does require the end-user to be able to re-link
05:42:55 <pejo> thyko, doesn't the documentation tell?
05:43:01 <Philippa> ndm: it's an issue given that the usual fix is to distribute the .o files on demand
05:43:04 <sek> hoora! thanks
05:43:09 <Cale> no problem
05:43:29 <sek> i was playing around with RealFrac and Fractional for ages, i must have mucked it up at some point:p
05:43:30 <thyko> pejo: not really, its not clear to me
05:43:33 <malcolm_> most Haskell projects I know with LGPL also have the wxWidgets-style exception clause
05:43:38 <dcoutts_> ndm, pong
05:43:43 <thyko> i think i'll read it again
05:43:56 <malcolm_> ... that says relinking is not mandatory
05:44:04 <dcoutts_> malcolm_, oh yes, we still need to do that for Gtk2Hs which is LGPL
05:44:25 <ndm> dcoutts, i have more details on my compiler optimisation, which you did ask about in the past: http://www-users.cs.york.ac.uk/~ndm/downloads/slides-haskell_with_go_faster_stripes-30_nov_2006.pdf
05:44:28 <lambdabot> http://tinyurl.com/yebdlc
05:44:46 <dcoutts_> we went with LGPL since Gtk+ is LGPL but of course Gtk+ is distributed as shared libs .so/.dll so relinking is trivial.
05:44:55 <dcoutts_> ndm, oh nice, thanks
05:44:56 <Philippa> yeah, LGPL-sans-relinking is close enough to BSD for the purpose
05:44:57 <SamB> Philippa: how is it stronger?
05:45:21 <Philippa> SamB: with the relinking clause, having bits of the originally-used version of the lib show up in the object code is a bit of a bugger
05:45:28 <dcoutts_> SamB, changes to the library itself cannot be kept closed
05:45:41 <SamB> dcoutts: sure
05:46:31 <SamB> Philippa: hmm. oh, you mean since you never had clean .o files this way.
05:46:58 <Philippa> right, so in practice the only way to do a clean relink is to either skip the optimisation or hand out the source
05:47:07 <pejo> thyko, index.html in the package tells, font locking, declaration scanning, documentation, indentation, and interaction with ghci/hugs.
05:54:46 <sek> > let legendre = \a p -> if a`mod`p==0 then 0 else let r=p`mod`4*a in -1^(sum$map countInts [((2*x-1)*r/(2*a), x*r/a ) | x<-[1..(floor$fromIntegral a/2)]]) in  legendre 4 7
05:54:47 <lambdabot>  Not in scope: `countInts'
05:55:19 <sek> ok this could be a problem to type out in full
05:55:47 <sek> its complaing about no instance of No instance for (RealFrac Integer) arising from the use of countInts
05:56:02 <chessguy> maybe pastebin your code?
05:56:14 <chessguy> @paste
05:56:14 <lambdabot> http://paste.lisp.org/new/haskell
05:56:59 <lisppaste2> sek pasted "legendte symbol" at http://paste.lisp.org/display/31010
05:57:44 <sek> shouldnt (2*x-1)*r/(2*a) be a RealFrac?
05:59:11 <chessguy> @type floor$fromIntegral a/2
05:59:12 <lambdabot> Not in scope: `a'
05:59:33 <chessguy> @type floor$fromIntegral (3::Integer)/2
05:59:34 <lambdabot> forall b. (Integral b) => b
06:00:08 <chessguy> @type mod
06:00:09 <lambdabot> forall a. (Integral a) => a -> a -> a
06:00:42 <chessguy> hmmm
06:01:00 <dcoutts_> dons, ping
06:02:29 <lisppaste2> asbeta pasted "multi-line declarations in GHCi" at http://paste.lisp.org/display/31011
06:03:59 <sek> chessguy, any luck?
06:04:12 <Lemmih> asbeta: ';'
06:04:36 <asbeta> does it work in 6.4.2?
06:04:38 <Lemmih> asbeta: f 0 = ...; f n = ...
06:04:40 <opqdonut> asbeta: you can do 'let f foo = ...' then 'let f bar = ...'
06:04:52 <asbeta> i mean i have really long declaration
06:05:00 <asbeta> i'd like to split it, but i can't
06:05:14 <opqdonut> well, you can as long as its indented correctly
06:05:16 <asbeta> it doesn't fit into one line basically :)
06:05:18 <Lemmih> opqdonut: That'd shadow the first definition.
06:05:52 <asbeta> opqdonut: in interactive shell?
06:06:06 <opqdonut> Lemmih: oh?
06:07:23 <Lemmih> asbeta: You can turn it into a one-liner with ';'.
06:08:01 <asbeta> declaration i wont is somewhat big AST
06:08:04 <asbeta> *want
06:08:44 <asbeta> it doesn't fit into one line in windows
06:08:59 <chessguy> sek, i'm still playing with it
06:09:02 <asbeta> that's the problem :)
06:09:15 <Lemmih> asbeta: Lines are infinitely long.
06:09:38 <asbeta> probably not in the windows console
06:10:09 <Lemmih> asbeta: Are you sure it doesn't just wrap the line?
06:10:25 <Lemmih> asbeta: (You can't create new data types at the GHCI top-level, btw)
06:11:10 <asbeta> it wraps the line 3 times
06:11:35 <Lemmih> That shouldn't be a problem.
06:11:51 <asbeta> and it isn't, but i can't make it longer :)
06:12:29 <asbeta> there's about 256 symbols
06:12:35 <Lemmih> How about writing your code in a file?
06:12:50 <asbeta> i would really want to avoid this
06:12:57 <Lemmih> Why?
06:13:06 <asbeta> the code is an example, it's to be pasted and evaluated
06:13:19 <asbeta> there's many such examples, user may want to play with them
06:13:57 <chessguy> sek, still here?
06:14:00 <sek> yeah
06:14:14 <Lemmih> asbeta: That might be impossible if you're (for some reason) limited to 256 characters.
06:14:24 <chessguy> i think the problem may be that / deals with members of the class Fractional, and not RealFrac
06:14:47 <sek> hmm ok
06:14:56 <chessguy> though i'm still a n00b, so take what i say with a grain of salt
06:15:18 <chessguy> @hoogle (RealFrac a) => a -> a -> a
06:15:20 <lambdabot> Prelude.asTypeOf :: a -> a -> a
06:15:20 <lambdabot> Prelude.const :: a -> b -> a
06:15:20 <lambdabot> Prelude.seq :: a -> b -> b
06:15:21 <sek> i'm at loss when it comes to numerical types
06:15:27 <chessguy> sek, me too
06:15:35 <sek> is there a tutorial about this somewhere?
06:15:36 <Saizan> asbeta, why don't you provide a separate .hs? or better you write all in a .lhs
06:15:45 <malebria> Hello there.
06:15:52 <sek> why cant there be Int and double, heh
06:15:55 <malebria> (urban:4763): GLib-GObject-CRITICAL **: g_object_ref: assertion `G_IS_OBJECT (object)' failed
06:16:02 <malebria> I'm getting this error with gtk2hs.
06:16:12 <asbeta> what's .lhs?
06:16:13 <chessguy> sek, there are :)
06:16:23 <Saizan> asbeta: literate haskell source
06:16:28 <sek> yeah i mean those be the only ones, hehe
06:16:30 <chessguy> but they don't mean quite the same as in...certain other languages
06:16:43 <Saizan> where comments are regular and code is ">" commented
06:16:54 <malebria> I tried to "debug" the problem adding some hPutStr stderr before and after some code, and I found out that it's in the line:   (draw_window :: DrawWindow) <- drawingAreaGetDrawWindow draw
06:16:57 <Saizan> ?where literate haskell
06:16:57 <lambdabot> I know nothing about literate.
06:17:22 <malebria> dcoutts: Any idea?
06:17:33 <asbeta> hmmm
06:17:43 <asbeta> might be interesting
06:17:55 <Saizan> http://www.haskell.org/onlinereport/literate.html
06:17:57 <lambdabot> Title: The Haskell 98 Report: Literate Comments, http://tinyurl.com/mdran
06:18:24 <Axioplase> is it possible to enable infinite types ?
06:19:25 <Philippa> as in [[[[[[[...]]]]]]]? No, and they're not desirable
06:19:27 <lisppaste2> sek pasted "legendre symbol" at http://paste.lisp.org/display/31012
06:19:30 <metaperl> convert file to a list of lines... what fn does that?
06:19:49 <sek> chessguy, as you can i have another way of doing it but its HARDLY a substitute in efficiency
06:19:51 <Axioplase> Philippa: yes, that kind of infinite type.
06:20:07 <Philippa> whatever you're trying to do with one, it's wrong
06:20:09 <Philippa> HTH :-)
06:20:23 <metaperl> I'm working on an SJT exercise to justify a paragraph. How would I type up a paragraph in a file and then present it to my program as a list of lines... how would I do that?
06:20:35 <asbeta> but firstly i'll try to make wrapper for ghci so that every declaration will be terminated with ;; :)
06:20:35 <chessguy> sek, one idea might be to try to break up what you're doing a little bit, to get a better idea of the proper typing of the different parts
06:20:49 <Philippa> metaperl: read in the paragraph, then pass it to lines to break it up?
06:21:17 <metaperl> Philippa - the entire file contains just one paragraph... how would you read that?
06:21:24 <Philippa> readFile
06:21:31 <metaperl> thanks
06:21:40 <Philippa> hint: System.IO contains all the IO stuff you'll want with plain text for now
06:21:47 <Philippa> so RTFDocs :-)
06:21:52 <sek> (2*x-1)*r/(2*a) this expression is the problem, i want it to be a RealFrac. x is a RealFrac, r is an integral and a is an Integer
06:23:43 <chessguy> mmm, i think x is a fraction
06:23:47 <chessguy> Fractional
06:24:20 <sek> @type floor
06:24:21 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
06:24:44 <sek> ok sorry x is an Integral i think
06:24:53 <chessguy> oh, yes
06:25:06 <chessguy> so that whole expression is Fractional
06:25:23 <sek> k so Integral*Integral/Integer != Realfrac  :p
06:25:51 <chessguy> @type (2:Integer)*(3:Integer)/(2:Integer)
06:25:52 <lambdabot> Not in scope: data constructor `Integer'
06:25:52 <lambdabot>  
06:25:52 <lambdabot> <interactive>:1:15: Not in scope: data constructor `Integer'
06:26:03 <chessguy> @type (2::Integer)*(3::Integer)/(2::Integer)
06:26:04 <lambdabot>   No instance for (Fractional Integer)
06:26:05 <lambdabot>    arising from use of `/' at <interactive>:1:25
06:26:41 <chessguy> @type (/)
06:26:41 <sek> @type (3::Integral)*(4::Integral)/(5::Integer)
06:26:42 <lambdabot> forall a. (Fractional a) => a -> a -> a
06:26:43 <lambdabot>   Class `Integral' used as a type
06:26:43 <lambdabot>   In the type `Integral'
06:26:51 <sek> ehm, sorry
06:26:53 <malebria> Where do I get the possible caractheres to define a symbol?
06:27:05 <malebria> like > . * & <
06:27:20 <malebria> I can't use ( [ { right?
06:30:18 <malebria> Why should I use another compiler instead of ghc?
06:31:15 <chessguy> anyway, good luck. i've gotta go take my earth science test (joy, rapture and bliss)
06:31:25 <sek> yikes
06:31:27 <sek> good luck:)
06:32:18 <yaarg> malebria: do you really mean symbols or rather identifiers?
06:32:25 <Lemmih> malebria: $ascsymbol = [\!\#\$\%\&\*\+\.\/\<\=\>\?\@\\\^\|\-\~ \xa1-\xbf \xd7 \xf7]
06:32:38 <malebria> Lemmih: thanks.
06:32:45 <malebria> yaarg: that's  what I meant.
06:32:50 <yaarg> right
06:33:18 <malebria> About the compilers, why do people use different compilers, what are their advantages?
06:34:27 <yaarg> ghc is de facto, but hugs is more lightweight and "easier"
06:34:48 <glguy> who suggested that you do that?
06:35:13 <malebria> glguy: Nobody, I'm just wondering about why they are used.
06:35:30 <sek> can anyone recommend a way to get around making something like (3::Integer)/(4::Integer) work? ie if 3 and 4 are fixed to be Integers
06:36:01 <sek> ideally the result of / would be a RealFrac
06:37:05 <Lemmih> sek: Use fromIntegral?
06:37:46 <sek> > (fromIntegral (3::Integer)) / (fromIntegral (4::Integer))
06:37:54 <lambdabot>  0.75
06:37:57 <Syzygy-> @type (fromIntegral (3::Integer))/(fromIntegral (4::Integer))
06:37:58 <lambdabot> forall b. (Fractional b) => b
06:38:09 <Syzygy-> Hmmm. That didn't go as I had hoped.
06:38:27 <sek> > floor $ (fromIntegral (5::Integer)) / (fromIntegral (2::Integer))
06:38:28 <lambdabot>  2
06:38:32 <sek> hmm ok
06:38:41 <Syzygy-> Oh, right. So it tells me that it can be any typeclass that implements Fractional.
06:38:47 <Lemmih> > 5 `div` 2
06:38:48 <lambdabot>  2
06:40:18 <sek> ok and how can i make the result of floor to be an Integer?
06:45:09 <metaperl> @seen TheHunter
06:45:10 <lambdabot> I haven't seen TheHunter.
06:52:43 <Xavier_> Hello everyone
06:52:51 <psnl> hello
06:53:38 <glguy> ?type floor
06:53:40 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
07:13:51 <glguy> > "ping"
07:13:52 <lambdabot>  "ping"
07:14:17 <psnl> > "pong"
07:14:19 <lambdabot>  "pong"
07:15:25 <glguy> I've had to connect to IRC via TOR for the last few days... I just wondered if the conversation had stopped, or if I was disconnected (-:
07:47:44 <earthy> interesting.
07:47:50 <earthy> cabal relinks even if no file has been recompiled
07:53:10 <Lemmih> earthy: GHC does.
07:53:22 <Lemmih> earthy: And it has been fixed in ghc6.6.
07:57:59 <lisppaste2> metaperl pasted "let's have an efficiency discussion about this split function" at http://paste.lisp.org/display/31014
07:58:23 <metaperl> anyone free for an optimization chat? :)
07:59:41 <metaperl> I'm concerned with going through the same parts of the string twice
08:01:29 <Axioplase> the question may be not very precise, but is there a more intuitive word having the meaning of "lift" as in "lift something in something else" ? Seems to be a quite used verb I sometimes read in computer articles...
08:04:58 <CosmicRay> heh, great,  I got a comment from "Simon" on my blog.  I have no idea who that was ;-)
08:05:04 <CosmicRay> and the comment was haskell-related
08:05:22 <cjeris> metaperl: all you have to do is make one function that returns (getWord st, dropWord st); see 'words' in the standard prelude.
08:05:35 <Axioplase> CosmicRay: It's Garth's uncle
08:05:52 <Axioplase> CosmicRay: I'm sure you know Simon and Garth's uncle.
08:06:05 <CosmicRay> oh, of course, doesn't everyone?
08:06:21 <sjanssen> where is the web interface to lambdabot?
08:07:15 <CosmicRay> how does one add a library to hoogle?
08:10:31 <Philippa> Axioplase: "lift Foo [from its current location Bar] into a higher place Baz"
08:11:09 <Philippa> so "lifted types" are lifted into a set that also has _|_, the undefined value
08:11:29 <metaperl> cjeris - yes I downloaded ghc but I'm having problems finding words there
08:11:48 <Philippa> fmap "lifts" functions into the relevant structure
08:11:50 <Philippa> etc etc
08:13:44 <metaperl> never mind, I found Prelude.hs online
08:16:25 <Axioplase> Philippa: ha ! so lifted ints are the flat integers domain ?
08:17:02 <Axioplase> anyway, I think I got it now... thanks.
08:18:37 <meep> metaperl: words is defined in http://haskell.org/onlinereport/list.html
08:18:38 <lambdabot> Title: The Haskell 98 Library Report: List Utilities
08:18:54 <metaperl> meep - yes, thanks.
08:26:42 <CosmicRay> is there a nice cabal example somewhere of how I would include the unix package if I'm on unix, and not include it if I'm on windows?
08:26:46 <CosmicRay> in my deps
08:27:30 <Igloo> I could give you an example that won't work until configurations are implemented
08:27:39 <CosmicRay> that wouldn't be much help then ;-)
08:27:44 <Igloo> For now you'd hav to use a hook, which I think would be possible
08:27:50 <CosmicRay> I'm trying to eliminate the ugly winprep.bat and winbuild.bat in MissingH
08:27:58 <CosmicRay> Igloo: I can't figure out how to do that from the docs.
08:28:04 <Igloo> I'd leave them there until configurations happen
08:28:27 <CosmicRay> surely a hook should be fairly simple and fairly clean?
08:28:57 <CosmicRay> System.Info can tell me what I need to know
08:35:16 <araujo> hello!
08:35:25 <CosmicRay> Igloo: does autoconf actually work on windows?
08:35:44 <lisppaste2> pitecus pasted "boilerplate" at http://paste.lisp.org/display/31016
08:35:58 <Igloo> Yes
08:36:29 <pitecus> Can I somehow reduce the amount of boilerplate in the i"nstance Interface Wrap" declaration?
08:40:30 <dcoutts_> CosmicRay, running autoconf on windows can be painful, but the result produced by autoconf/automake can certainly run on windows under cygwin or mingw/MSYS
08:41:09 <dcoutts_> I build Gtk2Hs on windows, that way - build the tarball (including generating configure) on linux and run it on windows
08:41:36 <sjanssen> lol, anyone catch Bulat's reply to "[Haskell-cafe] Command line utility that shrinks/simplifies functions applications ?"?
08:42:34 <dcoutts_> @tell malebra your drawingArea is probably not 'realised' yet so there is no corresponding DrawWindow yet. I guess that really drawingAreaGetDrawWindow should return Maybe DrawWindow
08:42:35 <lambdabot> Consider it noted.
08:44:24 <CosmicRay> dcoutts: how could it run under mingw, considering that there's no posix shell?
08:44:26 <sjanssen> Nicola: "On the IRC channel #haskell (which I cannot access now from work) I saw somebody using a tool which automatically simplifies expressions,composition of multiple functions to the bare minimum."
08:44:35 <CosmicRay> or does ghc install a posix shell
08:44:40 <dcoutts_> CosmicRay, mingw+MSYS
08:44:41 <sjanssen> Bulat: "it is the IRC channel itself"
08:44:51 <CosmicRay> msys is some component that ghc doesn't install?
08:44:58 <chessguy> sjanssen, we ARE the tool :)
08:45:13 <dcoutts_> CosmicRay, correct, it's an add-on for mingw. It's the posix shell.
08:45:20 <CosmicRay> ah
08:45:42 <CosmicRay> see I don't really need autoconf at all.  I just need some little thing that says, ahh, this is not windows, and adds the unix package.
08:46:09 <dcoutts_> CosmicRay, So you do really need a full mingw+MSYS install. The minimal mingw components that ghc installs is not enough. eg the C compiler isn't even usable without passing extra explicit flags.
08:46:24 <CosmicRay> well I can't expect users to have that.
08:46:28 <dcoutts_> Indeed
08:46:33 <dcoutts_> CosmicRay, I see. What you need is Cabal configurations!
08:46:43 <kpreid> pitecus: this is unhelpful, but I know ghc can derive such boilerplate in the case 'newtype (Interface a) => Wrap a = Wrap a deriving Interface'. no idea about your case though
08:46:46 <dcoutts_> see the latest proposal on cabal-devel
08:46:51 <CosmicRay> yes, like igloo said.  but I'm the impatient sort and don't want to wait ;-)
08:47:03 <dcoutts_> you could help us implement it :-)
08:47:07 <CosmicRay> it seems I should be able to just append "unix" to some list in a hook
08:47:22 <CosmicRay> dcoutts: not if you want it done in n years, n<=2 ;-)
08:47:22 * dcoutts_ has no idea about hooks
08:47:28 <pitecus> kpreid, thanks
08:47:29 <dcoutts_> heh
08:47:49 * CosmicRay has a newborn baby and is renovating an 1890s farmhouse at the moment
08:48:17 <kpreid> pitecus: one input in this vicinity can cause GHC to say 'My brain just exploded.'
08:48:50 <vegai> in soviet russia, YOU blow up GHC's brain!
08:49:06 <pitecus> I'm probably doing it wrong
08:49:13 <chessguy> ?remember vegai in soviet russia, YOU blow up GHC's brain!
08:49:28 * vegai blushes.
08:49:50 <therp> has GHC a russian related meaning I'm missing?
08:50:10 <LoganCapaldo> therp: No. It's one of those "meme" things
08:50:15 <campusblo> hello everybody
08:50:16 <kpreid> therp: no, it's the 'in soviet russia' joke
08:50:25 <campusblo> need haskell help
08:50:28 <campusblo> need haskell help
08:50:42 <campusblo> anyone have a lil time here?
08:50:52 <Cale> campusblo: sure, lots of people, ask away
08:50:53 <therp> ah ok :), I guess I should not be confused by the things that sometimes scroll by my eyes on #haskell.
08:50:55 <glguy> the way it works is you ask your question...
08:50:55 <chessguy> campusblo, your best bet is to just ask
08:51:11 <Syzygy-> Asking once instead of thrice is also a good idea. :)
08:51:24 <campusblo> lol ok
08:51:27 <chessguy> therp: i would be more concerned if you WEREN'T confused by things scrolling by your eyes on #haskell
08:51:29 <campusblo> i have a paper due tomorrow
08:51:44 <campusblo> i understand the language somewhat but this is our first real homework
08:52:02 <therp> chessguy: btw have you had fun with the GP kernel I sent you the other day?
08:52:02 <campusblo> i need to basically design a program to input a into a database
08:52:10 <chessguy> therp: heh
08:52:15 <chessguy> i haven't touched it, lol
08:52:24 <campusblo> text like name first name last name etc
08:52:32 <chessguy> school's insane right now
08:52:34 <therp> chessguy: actually, I would have been surprised :)
08:52:43 <campusblo> i have to add and remove records from a csv
08:52:47 <campusblo> anybody know how to do that?
08:52:58 <chessguy> therp, though i'm actually using a c++ GP library at the moment
08:53:08 <LoganCapaldo> @hoogle CSV
08:53:09 <lambdabot> No matches found
08:53:16 <campusblo> done that
08:53:17 <LoganCapaldo> @where CSV
08:53:18 <lambdabot> I know nothing about csv.
08:53:22 <therp> chessguy: ah I hope you don't suffer much. I have seen a lot of ugly ones
08:53:23 <campusblo> oh
08:53:28 <chessguy> ?where darcs
08:53:28 <lambdabot> http://darcs.net/
08:53:32 <campusblo> you mean in this channel?
08:53:33 <Syzygy-> Comma-separated-values, LoganCapaldo
08:53:44 <Syzygy-> (or possibly character-separated)
08:53:45 <chessguy> therp, yeah. well i managed to get this one working a while back
08:53:47 <LoganCapaldo> Syzygy-: I know what it stands for :)
08:53:50 <Cale> http://www.xoltar.org/languages/haskell/CSV.hs
08:53:53 <lambdabot> http://tinyurl.com/y3j2vg
08:53:57 <LoganCapaldo> I was hoping for Text.CSV or something
08:54:00 <campusblo> @hoogle CSV
08:54:01 <lambdabot> No matches found
08:54:19 <sjanssen> campusblo: I think your prof. wants you to write your own CSV parser
08:55:02 <Cale> Yeah, it's pretty likely that you're not just supposed to use a pre-made library :)
08:55:21 <therp> chessguy: well I think in 2 month I can start to touch GP again
08:55:33 <Cale> CSV is not *completely* trivial though, do you need to handle things like quotes?
08:55:34 <chessguy> in lisp?
08:55:42 <LoganCapaldo> If I were a professor I'd let people use a pre-made library :)
08:55:50 <therp> chessguy: sortof. Liskell it will be. the thing I'm hacking at the moment
08:55:57 <chessguy> oh, that's right
08:55:59 <therp> chessguy: Lisp+Haskell Hybrid
08:56:11 <sjanssen> @type takeWhile -- here is your first hint, campusblo
08:56:13 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
08:56:25 <sjanssen> @type dropWhile -- and it's companion
08:56:26 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
08:56:39 <campusblo> sjanssen what?
08:57:07 <sjanssen> campusblo: those are the key functions to writing your very own CSV parser
08:57:12 <campusblo> im sure they do
08:57:31 <campusblo> firstly im not so sure what parsing is
08:57:53 <campusblo> ive created a variable which is a list of list of strings
08:58:00 <sjanssen> > takeWhile (/= ',') "wonder,what,will,happen"
08:58:01 <lambdabot>  "wonder"
09:01:10 <glguy> > groupBy (\x y -> (x == ',') == (y == ','))  "wonder,what,will,happen"
09:01:12 <lambdabot>  ["wonder",",","what",",","will",",","happen"]
09:02:20 <osfameron> how is the (x == ',') == (y == ',')  working?
09:02:57 <osfameron> from other programming languages it would look like you're testing the equality of 2 unequal lambda expressions, which doesn't make sense
09:02:58 <LoganCapaldo> osfameron: It's like a toggle
09:03:48 <glguy> osfameron: things are grouped when they are both commas, or both not commas
09:03:52 <LoganCapaldo> grab while the contigous characters are both not ,s or both are commas
09:04:07 <glguy> > groupBy (\x y -> (x == ',') == (y == ','))  "wonder,,,,,,,what,will,happen"
09:04:09 <lambdabot>  ["wonder",",,,,,,,","what",",","will",",","happen"]
09:04:11 <osfameron> right, I get what it's doing, I'm just having trouble with how the syntax specifies that :-)
09:04:42 <glguy> if commas were supposed to be separated, you might be able to:
09:04:58 <LoganCapaldo> (',' == ',') => True; ('b' == ',') => False; True == False => False
09:05:01 <sjanssen> osfameron: (x == ',') results in a Bool, same with (y == ','), then the middle == tests whether the two Bool values are the same
09:05:26 <osfameron> ah, right, I was misparsing that completely
09:05:29 <osfameron> that makes sense
09:06:24 <osfameron> it's a rather "cute" way of doing it, in the way that unmaintainable perl hacks can be cute though, isn't it?
09:07:46 <gds> @pl \x y -> (x == ',') == (y==',')
09:07:46 <lambdabot> (. ((',') ==)) . (==) . ((',') ==)
09:08:22 <glguy> (\x y -> (x == ',') == (y == ',')) isn't really a "complex hack" expression
09:08:42 <osfameron> no, I get that, I was just misreading because I don't really get haskell yet
09:08:43 <LoganCapaldo> I wouldn't call ti robust though
09:08:57 <LoganCapaldo> CSV can have empty fields right? "a,,b"
09:08:58 <osfameron> but it's the "wrong" way to do parsing a csv, though it's cute
09:09:43 <glguy> Writing your own CSV parser would usually be considered the wrong way
09:09:45 <glguy> I agree
09:10:07 <glguy> CSV has quoted fields and escaped quotes inside them
09:10:20 <osfameron> and possibly even newlines
09:10:21 <CosmicRay> @paste
09:10:21 <lambdabot> http://paste.lisp.org/new/haskell
09:10:26 <osfameron> though most parsers just crap out on those
09:10:47 <lisppaste2> CosmicRay pasted "Cabal hooks" at http://paste.lisp.org/display/31018
09:11:03 <CosmicRay> Igloo: can you tell me why my code seems to be ignored in this paste?
09:11:26 <CosmicRay> actually
09:11:27 <CosmicRay> never mind.
09:11:30 <CosmicRay> I just figured it out.
09:11:44 <glguy> > groupBy (\x y -> x /= ',' && y /= ',') "asdf,asdf,asdf,,,adf"
09:11:46 <lambdabot>  ["asdf",",","asdf",",","asdf",",",",",",","adf"]
09:13:03 <LoganCapaldo> lambdabot needs syntax hilighting :)
09:13:36 <osfameron> glguy: how does that work with ",,," ?
09:13:57 <glguy> it only groups things that are both not commas
09:14:24 <dmhouse> Can you unbox all strict values?
09:15:00 <gds> @doc List.groupBy
09:15:00 <lambdabot> List.groupBy not available
09:15:03 <gds> @doc List
09:15:04 <lambdabot> List not available
09:15:07 <gds> :(
09:15:12 <glguy> Data.List maybe
09:15:20 <gds> @doc Data.List
09:15:20 <yaarg> wwwwwwhat
09:15:20 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
09:15:25 <gds> :)
09:20:02 <osfameron> glguy: ah - I thought it grouped things as either "true" or "false".  So actually groupBy either groups 2 things or doesn't... ok
09:21:59 <Cale> groupBy will start by comparing everything to the first element, and the first group will consist of the first element of the list, together with all the following elements of the list such that the test succeeds up until the first failure
09:22:23 <VerbalDK> netsplit?
09:25:51 <VerbalDK> wb
09:29:02 <Cale> groupBy (<) [1,2,3,4,3,4,1,2,3,1,2]
09:29:05 <Cale> > groupBy (<) [1,2,3,4,3,4,1,2,3,1,2]
09:29:07 <lambdabot>  [[1,2,3,4,3,4],[1,2,3],[1,2]]
09:30:32 <glguy> let csvP = csvField `sepBy` (char ','); csvField = between (char '"') (char '"') (munch (const True)) <++ munch (/= ',')
09:30:41 <glguy> I know that doesn't handle escaped quotes
09:31:11 <glguy> and does a few other things wrong too :)
09:31:38 <glguy> like... doesn't allow commas inside quotes yet
09:32:07 <cjeris> @karma- csv
09:32:08 <lambdabot> csv's karma lowered to -1.
09:32:33 <cjeris> glguy, is that Parsec?
09:32:51 <glguy> ReadP
09:33:03 <glguy> Parsec might be better
09:33:08 <osfameron> csv is rather horrible as a format, and it's also unspecified iirc
09:33:12 <SyntaxNinja> y0
09:33:43 <LoganCapaldo> @where ReadP
09:33:43 <lambdabot> I know nothing about readp.
09:33:48 <LoganCapaldo> @doc ReadP
09:33:49 <lambdabot> ReadP not available
09:33:58 * cjeris calls SyntaxNinja's spherical harmonic and raises with a bessel function
09:34:00 <chessguy> @hoogle ReadP
09:34:01 <lambdabot> Text.ParserCombinators.ReadP :: module
09:34:01 <lambdabot> Text.ParserCombinators.ReadP.ReadP :: data ReadP a
09:34:01 <lambdabot> Text.ParserCombinators.ReadPrec :: module
09:34:12 * chessguy pats himself on the head
09:34:45 <LoganCapaldo> chessguy: But I wanted this: http://cvs.haskell.org/Hugs/pages/libraries/base/Text-ParserCombinators-ReadP.html :)
09:34:48 <lambdabot> http://tinyurl.com/yaaf4w
09:35:00 <chessguy> picky, picky
09:36:28 <haskellFriend> hi all
09:36:54 <haskellFriend> have a little puzzle for you
09:37:33 <haskellFriend> takeUntilRep :: Eq a => [a] -> [a]
09:37:55 <haskellFriend> function that takes elements from list until repeated one found
09:38:01 <haskellFriend> takeUntilRep [1,2,3,3]    ==>  [1,2,3]
09:38:12 <haskellFriend> takeUntilRep [1,2,1,4,2]  ==>  [1,2]
09:38:18 <haskellFriend> or something like that
09:38:20 <opqdonut> you want us to implement this?
09:38:20 <sjanssen> haskellFriend: is this homework?
09:38:29 <haskellFriend> noo
09:38:42 <haskellFriend> I'm doing this for myself
09:38:59 <haskellFriend> just practiceing ang got stuck
09:39:47 <opqdonut> f x:xs ys = if x in ys then ys else (f xs x:ys)
09:40:04 <opqdonut> and then takeUntilRep would be a wrapper for this
09:41:08 <opqdonut> (that of course isn't ready-to-run code)
09:41:35 <haskellFriend> yeah I figured it out
09:41:39 <opqdonut> :)
09:41:53 <haskellFriend> thanks I'll work on it a bit
09:42:57 <opqdonut> yeah that works
09:43:01 <SyntaxNinja> dons: is Alex McLean here, by chance?
09:43:04 <opqdonut> it just returns them in reverse order
09:43:21 <kpreid> > (\xs -> last $ filter (\xs -> xs == nub xs) $ inits xs) [1,2,1,4,2]
09:43:22 <lambdabot>  [1,2]
09:43:28 <kpreid> hee hee
09:43:52 <sjanssen> kpreid: now, what is the complexity of that algorithm?
09:43:53 <opqdonut> > let f (x:xs) ys = if (x `elem` ys) then ys else (f xs (ys++[x]));  f _ ys = ys
09:43:54 <lambdabot>  Parse error
09:44:06 <opqdonut> hrmm, worked in ghci
09:44:09 <kpreid> @pl (\xs -> xs == nub xs)
09:44:09 <lambdabot> ap (==) nub
09:44:28 <kpreid> > last . filter (ap (==) nub) . inits $ [1,2,1,4,2]
09:44:29 <cjeris> @type ap
09:44:30 <lambdabot>  [1,2]
09:44:31 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
09:45:04 <cjeris> @type (ap (==))
09:45:05 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> Bool
09:45:29 <opqdonut> kpreid: i take off my hat for you
09:46:15 <haskellFriend> function nub is unfamiliar for me?
09:46:15 <kpreid> opqdonut: just use @pl enough and you'll get it
09:46:29 <opqdonut> haskellFriend: returns list with duplicates removed
09:46:40 * cjeris can't see the monad...
09:46:45 <opqdonut> cjeris: list monad
09:46:47 <kpreid> haskellFriend: this is a silly version. don't use it for anything practical.
09:46:51 <kpreid> cjeris: no, reader monad
09:46:54 <opqdonut> oh
09:46:56 <sjanssen> > let takeUniq' s [] = []; takeUniq' s (x:xs) = if S.member x s then [] else x : takeUniq' (S.insert x s) xs; takeUniq = takeUniq' S.empty in takeUniq [1, 2, 3, 1, 4, 5] -- reasonable complexity
09:46:58 <lambdabot>  [1,2,3]
09:47:12 <kpreid> sjanssen: O(n^3), I think
09:48:02 <kpreid> nub doesn't specify its complexity
09:48:14 <sjanssen> it's O(n^2) -- it has to be
09:48:27 <sjanssen> because it doesn't have an Ord constraint
09:48:33 <kpreid> ok, so O(n^3) for my function
09:49:05 <haskellFriend> I'm working on WinHugs :D so ghc syntax in unfamiliar for me still
09:49:29 <sjanssen> haskellFriend: my example will work in hugs if you replace "S." with "Data.Set."
09:49:37 <sjanssen> or import qualified Data.Set as S
09:49:59 <cjeris> kpreid: qwark?  can you explain more?  I don't see any type with a name containing Reader anywhere...
09:50:00 <kpreid> haskellFriend: lambdabot has its own idiosyncratic imports for evaluation
09:50:21 <kpreid> cjeris: the type ((->) e) is also the reader monad
09:50:57 <cjeris> kpreid: where ((->) e) means e -> , right?
09:51:00 <kpreid> yes
09:51:08 <kpreid> > ((+1) >>= (+)) 10
09:51:10 <lambdabot>  21
09:51:13 <cjeris> ok, thanks, i'll try to puzzle it out from there.
09:51:45 <kpreid> so each value of the monad is a function from an external input to the monadic result
09:52:13 <kpreid> thus you can rewrite all multiple uses of parameters into use of it
09:52:14 <haskellFriend> opqdonut: thanks your solution seemed to be the simplest and it helped :)
09:52:53 <kpreid> > (do x <- (+1); y <- (+2); return (x,y)) 0
09:52:55 <lambdabot>  (1,2)
09:52:57 <kpreid> > (do x <- (+1); y <- (+2); return (x,y)) 10
09:52:59 <lambdabot>  (11,12)
09:53:04 <kpreid> cjeris: see?
09:53:34 <cjeris> oh, so >>= is kinda like the lifting arrow in a pushout diagram
09:53:43 <opqdonut> haskellFriend: np, hf
09:53:55 <kpreid> I don't know what a pushout diagram is, so I can't say.
09:54:54 <kpreid> Anyway, 'ap' in the reader monad ends up applying a 2-arg function to the external input and the result of some function applied to the external input.
09:55:13 <cjeris> thanks, that helps a lot.  it's funny that haskell even has a way to eliminate multiple uses of a single argument...
09:55:26 <kpreid> Thus (ap (==) nub) == (\e -> (==) e (nub e))
09:55:39 <kpreid> Or rather, more generally:
09:55:55 <kpreid> (ap a b) == (\e -> (a e) (b e))
09:57:07 <kpreid> cjeris: I don't think any of this was put in for that purpose in particular...
09:58:02 <haskellFriend> How can I cast from Fractional to Int
09:58:24 <haskellFriend> I have natToBin :: Int -> and I call natToBin (x/2)
09:58:40 <cjeris> kpreid: because ap a b == b >>= \b -> a b == \e -> (a e) (b e), i get it.
09:58:57 <kpreid> haskellFriend: one of the first four functions in http://haskell.org/hoogle/?q=%28RealFrac+a%2C+Integral+b%29+%3D%3E+a+-%3E+b
09:59:00 <lambdabot> Title: (RealFrac a, Integral b) => a -> b - Hoogle, http://tinyurl.com/y4yn83
09:59:19 <haskellFriend> thanks this link was useful
10:00:19 <paolino> Is there a ghci with history,completion and line editing ?
10:02:26 <Cale> paolino: yes, it's called ghci
10:02:36 <glguy> ghci already has history and line editing, but I don't know about completion
10:02:49 <opqdonut> paolino: you have to compile ghci with readline support
10:03:18 <edwardk> completion would be neat to have, its already using readline, its not too hard to add tab completion to readline
10:03:32 <Cale> It has filename completion
10:03:41 <Cale> but not function completion
10:03:59 <edwardk> would be tricky to get let something = foo in some<tab> to work right though
10:04:01 <sjanssen> ghci has function completion
10:04:02 <cjeris> > (foldl (>>=) (1*) (take 10 (replicate (*)))) 3
10:04:03 <lambdabot>    Expecting a function type, but found `[a]'
10:04:03 <lambdabot>    Expected type: [a -> a ...
10:04:41 <paolino> ah , the make command didn't ask me for it.
10:04:46 <edwardk> oh?
10:04:56 <ulph> can I paste 7 lines of code?
10:05:02 <edwardk> @paste
10:05:03 <lambdabot> http://paste.lisp.org/new/haskell
10:05:14 <edwardk> pate there please, ulph
10:05:58 <lisppaste2> ulph pasted "question about types" at http://paste.lisp.org/display/31020
10:06:19 <paolino> mmhh the port in freebsd has no configuration for ghci
10:06:34 <opqdonut> anyone have a good link for the reader monad?
10:07:07 <sjanssen> ulph: change return t to return Nothing
10:07:34 <cjeris> > foldl (>>=) (1*) (take 10 $ repeat (*)) $ 3
10:07:35 <lambdabot>  177147
10:07:50 <cjeris> woo, makes sense now.  thanks kpreid!
10:07:56 <edwardk> sjanssen thats equivalent no?
10:08:04 <Cale> edwardk: no
10:08:05 <sjanssen> Haskell doesn't cast the "Maybe a" to a "Maybe b" even though t is Nothing
10:08:07 <edwardk> oh ah
10:08:11 <edwardk> sorry =)
10:08:19 <edwardk> didn't see the two different maybes involved
10:09:13 <ulph> sjanssen: ah thanks. it was the solution in my more complicated real case too :)
10:09:38 <edwardk> ah interesting, i just realized that phantom types don't wor in my language from that example =)
10:09:44 <sjanssen> ulph: no prob., it's practically a Haskell FAQ
10:10:03 <paolino> and the port depend on readline port, strange
10:10:08 <sjanssen> edwardk don't believe in no ghosts
10:10:27 <sjanssen> paolino: is there something weird about your terminal?
10:10:33 <edwardk> sjanssen: heh. well, they work, they just become interchangeable. didn't spot the distinction until now
10:10:52 <kpreid> ulph: fwiw, if you like I think you can replace your case with a fmap/liftM
10:11:34 <kosmikus> the HCAR is out :)
10:11:35 <paolino> sjanssen: it's an xterm clone
10:11:42 <ndm> kosmikus: well done
10:11:47 <ndm> kosmikus: am already reading it :)
10:12:13 <kosmikus> you're quick :)
10:12:44 <ulph> kpreid: i'll look into that thanks :)
10:14:15 <Saizan> uhm, on windows ghci is not supposed to have any tab completion, isn't it?
10:15:07 <kpreid> ulph: oh, wait, it isn't, because in the Nothing case it's a return and in the Just case it's using the IO action. never mind.
10:15:21 <kpreid> it would have been: liftM ((\(M m') -> m') . f) t
10:16:01 <ulph> i also need to put class constraints on variable for the return function of the monad instance. how can i do that?
10:16:17 <kpreid> you can't.
10:16:22 <ulph> hm.
10:16:28 <kpreid> you'd have to define your own variant of the Monad class.
10:18:38 <paolino> sjanssen: how can I check if it's a terminal problem ?
10:19:11 <Cale> Interestingly enough, you can avoid those constraints for bind with newer GHC 6.7's
10:19:17 <Cale> (but not for return)
10:19:20 <sjanssen> paolino: I dunno, just throwing that out there ;)
10:19:34 <sjanssen> paolino: oh, and what version of GHC are we talking about?
10:19:48 <paolino> 6.4.2
10:20:06 <sjanssen> I think the completion is new to 6.6
10:20:41 <paolino> uh, freebsd is not well supported eh
10:21:34 <sjanssen> 6.6 hasn't been out all that long, about a month, I think
10:22:24 <edwardk> sjanssen: ah, which is why i can't see the behavior (need hsplugins, stuck with 6.4)
10:23:49 <paolino> ok, I suppose line editing should be there in 6.4.2
10:23:56 <sjanssen> yes
10:26:11 <scsibug_> does hs-plugins not work with 6.6?
10:29:09 <eviltwin_b> not yet
10:29:23 <eviltwin_b> join the list of folks pestering dons about it? :)
10:29:54 <paolino> me ?
10:30:06 <paolino> no
10:31:32 <eviltwin_b> scsibug, re hs-plugins
10:31:54 <edwardk> scsibug: not yet
10:34:44 <scsibug> thanks...definitely explains why it didn't compile 10 minutes ago when I tried
10:35:38 <edwardk> scsibug: yeah the test cases do incredibly weird things =)
10:35:56 <cjeris> where do I put the type annotation to avoid the restriction to Int that comes from replicate?
10:35:57 <cjeris> > let stack op a b = foldr1 op $ replicate b a; arrows n = (iterate stack (*)) !! (n + 1) in take 2 (map (($ 3).($ 3).arrows) [0..])
10:35:59 <lambdabot>  [27,2030534587]
10:36:08 <SamB> @hoogle genericReplicate
10:36:09 <lambdabot> List.genericReplicate :: Integral a => a -> b -> [b]
10:36:10 <lambdabot> Data.List.genericReplicate :: Integral i => i -> a -> [a]
10:36:21 <SamB> cjeris: try using that instead?
10:37:51 <cjeris> SamB: perfect, thank you!  of course...
10:38:00 <cjeris> > let stack op a b = foldr1 op $ genericReplicate b a; arrows n = (iterate stack (*)) !! (n + 1) in take 3 (map (($ 3).($ 3).arrows) [0..])
10:38:02 <lambdabot>  Exception: stack overflow
10:38:05 <cjeris> :(
10:38:39 <cjeris> I suppose I can't reasonably ask for 3^27 stack frames
10:40:53 <newsham> thats only 1775 * 2^32
10:41:28 <SamB> cjeris: is there a way to do it without the stack frames?
10:41:34 <SamB> i.e. can you possibly fold the other way?
10:42:21 <cjeris> SamB: in any case the next number is 3^(3^ ...( ^3)...) with 3^27 layers of exponent, it would take a while to print :)
10:42:55 <SamB> oh
10:43:09 <newsham> also 27 is 3^3
10:43:45 <SamB> cjeris: I really don't think that will fit in RAM anyway
10:44:02 <SamB> especially not with sequentially allocated numbers
10:44:15 <tibbe> @where source
10:44:15 <lambdabot> I know nothing about source.
10:44:19 <tibbe> @source
10:44:19 <lambdabot>  not available
10:44:24 <tibbe> @source Prelude
10:44:24 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
10:44:51 <tibbe> @source Data.List
10:44:52 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
10:46:10 <newsham> > let r f n = foldl (.) id (take n $ repeat f) in (r (^3) 3) 2
10:46:12 <lambdabot>  134217728
10:47:00 <newsham> > let r f n = foldl (.) id (take n $ repeat f) in (r (+ 2) 3) 0
10:47:01 <lambdabot>  6
10:47:10 <tibbe> why can't I find the source of foldl?
10:47:40 <SamB> probably it is hidden in GHC.Base?
10:47:47 <SamB> @source GHC.Base
10:47:48 <lambdabot> GHC.Base not available
10:47:50 <SamB> hmm.
10:47:59 <tibbe> GHC.Base is hidden as well ;)
10:48:05 <glguy> foldl            :: (a -> b -> a) -> a -> [b] -> a
10:48:05 <glguy> foldl f z []      = z
10:48:05 <glguy> foldl f z (x:xs)  = foldl f (f z x) xs
10:48:06 <newsham> http://haskell.org/onlinereport/standard-prelude.html  foldl defined in here
10:48:10 <lambdabot> Title: The Haskell 98 Report: Standard Prelude, http://tinyurl.com/y2wv6o
10:48:10 <tibbe> lambdabot: go find GHC.Base, seek!
10:48:18 <kolmodin> tibbe: it's in GHC.List
10:48:23 <SamB> unfortunately the source locations are from haddock's iface files, apparantly...
10:48:26 <tibbe> kolmodin: ok thanks
10:48:33 <glguy> In Hugs type:    :f foldl
10:48:55 <tibbe> I thought foldl used an accumelator, I wonder where I got that idea from
10:49:09 <SamB> um...
10:49:12 <SamB> @type foldl
10:49:14 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
10:49:21 <SamB> what do you think "a" is?
10:49:35 <SamB> maybe it isn't called "acc" here...
10:49:39 <SamB> @type scanl...
10:49:41 <lambdabot> parse error (possibly incorrect indentation)
10:49:42 <SamB> @type scanl
10:49:43 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
10:49:49 <SamB> hmm.
10:49:58 <SamB> @type mapAccumR
10:50:00 <lambdabot> forall y acc x. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
10:50:07 <SamB> oh, theres one with an acc...
10:50:13 <retybok> How can i convert an Integral to Floating in haskell?
10:50:20 <SamB> the really confusing thing is that mapAccumR and mapAccumL have the same type!
10:50:27 <astrolabe> @type fromIntegral
10:50:28 <LoganCapaldo> lambdabot does not support trailling off in thought apparently :)
10:50:28 <lambdabot> forall b a. (Num b, Integral a) => a -> b
10:50:37 <SamB> LoganCapaldo: indeed!
10:50:43 <retybok> astrolabe: fabulous
10:50:45 <retybok> thanks
10:50:58 <astrolabe> No problemo :)
10:51:09 <cjeris> LoganCapaldo: the problem is that (...) :: forall a b. a -> b
10:51:32 <LoganCapaldo> heh
10:51:43 <LoganCapaldo> does it use unsafePerformIO then?
10:51:55 <cjeris> it's also spelled `andThenAMiracleOccurs`
10:53:19 <newsham> unsafePerformIO $ walkOnWater
10:53:30 <tibbe> > unsafeLaunchMissiles
10:53:31 <lambdabot>  Not in scope: `unsafeLaunchMissiles'
10:53:49 <tibbe> I'm moving back to Sweden today, yay! :D
10:54:02 <newsham> couldnt you have picked a warmer time of year?
10:54:04 <astrolabe> Is there a term for an algorithm that does the same sequence of operations, no matter what the input data is?  Eg multiplying two matrices would probably be this kind of algorithm.
10:54:44 <astrolabe> tibbe: You'd feel guilty if dons had implemented that.
10:55:17 <vegai> he has. It's an action that outputs "Not in scope: `unsafeLaunchMissiles'" and then proceeds to launch some missiles
10:55:21 <campusblo> hi im back with my haskell parse project
10:55:21 <glguy> astrolabe: the matrix multiplication algorithm is still dependent upon the dimensions of the input... does that count?
10:55:36 <campusblo> im trying to parse a file
10:55:39 <newsham> plausible deniability
10:55:57 <astrolabe> glguy: sorry a bad example.  I mean multiplying two 3x3 matrices.
10:56:02 <SamB> astrolabe: nonsense, dons doesn't even believe in allowing people to read /etc/passwd!
10:56:14 <vincenz> unsafePerformIO $ missile >> country
10:56:47 <campusblo> i have tried as suggested takeWhile (/= ',') "wonder,what,will,happen"
10:56:55 <campusblo> but all i get is wonder
10:56:59 <campusblo> the other words drop out
10:57:04 <vincenz> campusblo: of course
10:57:05 <resiak> yes, that's what takeWhile does
10:57:12 <campusblo> anybody knows why that is?
10:57:13 <astrolabe> what did you want?
10:57:30 <glguy> ?type break
10:57:32 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
10:57:45 <vincenz> > map takeWhile (/= ',') . iterate (drop 1 . dropWhile (/= ',') $ "wonder,what,will,happen"
10:57:46 <lambdabot>  Parse error
10:57:47 <LoganCapaldo> Ok, so I keep seeing this assertion that unsafePerfomIO lets you define cast :: a -> b, can anyone point me to the actual code for such an abomination?
10:57:52 <campusblo> i thought that if i typed that id get wonder what will happen
10:57:52 <vincenz> > map takeWhile (/= ',') . iterate (drop 1 . dropWhile (/= ',')) $ "wonder,what,will,happen"
10:57:54 <lambdabot>    Expecting a function type, but found `[b]'
10:57:54 <lambdabot>    Expected type: b -> c
10:57:54 <lambdabot>  ...
10:57:58 <vincenz> @type iterate
10:57:59 <lambdabot> forall a. (a -> a) -> a -> [a]
10:58:09 <astrolabe> > filter (/= ',') "walk, on, water"
10:58:10 <lambdabot>  "walk on water"
10:58:11 <user317> is there any way to compute an OR in a way that will execute both parts in parallel?
10:58:11 <campusblo> i want to drop the commas
10:58:48 <LoganCapaldo> > words $ filter (/= ',') "walk, on, water"
10:58:50 <lambdabot>  ["walk","on","water"]
10:59:05 <glguy> > span (/= ',') "asdf,jkl;"
10:59:08 <lambdabot>  ("asdf",",jkl;")
10:59:15 <resiak> Is there a predefined generalisation of words?
10:59:24 <campusblo> filter works
10:59:29 <vincenz> > map (takeWhile (/= ',')) . iterate (drop 1 . dropWhile (/= ',')) $ "wonder,what,will,happen"
10:59:31 <lambdabot>  ["wonder","what","will","happen","","","","","","","","","","","","","","","...
10:59:39 <vincenz> > takeWhile (not . null) . map (takeWhile (/= ',')) . iterate (drop 1 . dropWhile (/= ',')) $ "wonder,what,will,happen"
10:59:40 <lambdabot>  ["wonder","what","will","happen"]
10:59:49 <LoganCapaldo> import Perl; split "," "walk,on,water" ;)
10:59:53 <cjeris> user317: are you asking for parallel in the computational-performance sense, or merely not short-circuity?
11:00:00 <astrolabe> vincenz: are you obfuscating?
11:00:02 <chessguy> is there not a built-in function for filter (/= foo) list
11:00:02 <emu> splitRegex (mkRegex ",")
11:00:04 <campusblo> right i got this from bambot while trying to parse a file
11:00:08 <vincenz> astrolabe: no?
11:00:22 <vincenz> @type break
11:00:24 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
11:00:40 <vincenz> astrolabe: mine -splits- the string
11:00:41 <emu> $%^&* perl
11:00:48 <user317> cjeris, short-circuitry, i don't know which clause will terminate first, and i want the first one that does
11:01:01 <astrolabe> vincenz: ah, sorry
11:01:15 <LoganCapaldo> > splitRegex (mkRegex ",") "walk,on,water"
11:01:15 <lambdabot>  Not in scope: `mkRegex'
11:01:33 <emu> @hoogle mkRegex
11:01:34 <lambdabot> Text.Regex.mkRegex :: String -> Regex
11:01:34 <lambdabot> Text.Regex.mkRegexWithOpts :: String -> Bool -> Bool -> Regex
11:01:35 <LoganCapaldo> @help import
11:01:36 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:01:43 <astrolabe> @pl \x f -> filter (not.f) x
11:01:43 <lambdabot> flip (filter . (not .))
11:01:55 <vincenz> @pl \c -> takeWhile (not . null) . map (takeWhile (/= c)) . iterate (drop 1 . dropWhile c)
11:01:55 <lambdabot> (takeWhile (not . null) .) . ap ((.) . map . takeWhile . (/=)) (iterate . (drop 1 .) . dropWhile)
11:01:56 <LoganCapaldo> @module
11:01:56 <lambdabot> Unknown command, try @list
11:02:00 <vincenz> unwords = that applied to ' '
11:02:04 <vincenz> erm, words even
11:02:31 <LoganCapaldo> > Text.Regex.splitRegex (Text.Regex.mkRegex ",") "walk,on,water"
11:02:32 <lambdabot>  Not in scope: `Text.Regex.mkRegex'
11:02:44 * LoganCapaldo mumbles
11:02:46 <LoganCapaldo> @list
11:02:47 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
11:02:59 <chessguy> @hoogle Regex
11:03:00 <lambdabot> Text.Regex :: module
11:03:00 <lambdabot> Text.Regex.Regex :: data Regex
11:03:00 <lambdabot> Text.Regex.Posix.regExtended :: Int
11:03:41 <vincenz> @quote chessguy
11:03:42 <lambdabot>  i didn't think pennsylvania had anybody cool enough to know haskell in it
11:04:04 <cjeris> user317: sorry, i don't know how to do real parallel programming in haskell...
11:05:34 <chessguy> @quote vincenz
11:05:35 <lambdabot>  sure, give us your homework and we'll email it straight to your teacher :)
11:05:44 <newsham> rick santorum doesnt know haskell?
11:05:51 <SamB> hmm?
11:05:57 <chessguy> newsham, dunno, haven't talked to him lately
11:06:03 <newsham> @quote newsham
11:06:04 <lambdabot>  there are Just 1 types of people, Nothing and those who understand monads
11:06:05 <chessguy> i doubt anyone has
11:06:28 <rahikkala> :D
11:06:42 <LoganCapaldo> I want a t-shirt with that one
11:06:54 <lisppaste2> glguy pasted "readp csv parser (stub)" at http://paste.lisp.org/display/31022
11:07:12 <newsham> i wonder if "Just 2" woulda been better.
11:07:34 <astrolabe> heh
11:08:09 <SamB> newsham: no, see
11:08:23 <campusblo> sorry i keep getting dropped
11:08:27 <campusblo> why doesnt this work filter (/= ',') ["walk", "on", "water"]
11:08:30 <SamB> its like that "there are only 10 kinds of people"
11:08:31 <SamB> shirt
11:08:41 <newsham> samb: yah..  i know, thats what i based it on.
11:08:53 <haskellFriend> ok I 'm doing some recursion stuff and got in trouble
11:08:56 <chessguy> @quote SamB
11:08:57 <lambdabot>  fworp: next time, load your shirt up in to GHCi *before* having it printed
11:09:02 <emu> > parseTest (sepBy1 (many1 letter) (skipMany1 (oneOf " ,"))) "a,b,c"
11:09:02 <lambdabot>  Not in scope: `oneOf'
11:09:04 <haskellFriend> rotations :: [a] -> [[a]]
11:09:05 <newsham> but if you do "just 2" its more subtle since it reads more grammatically correct
11:09:09 <resiak> chessguy: because none of the elements of that list are of type Char
11:09:10 <haskellFriend> rotations [1,2,3]  ==>  [[2,3,1], [3,1,2], [1,2,3]]
11:09:12 <SamB> how... appropriate!
11:09:15 <resiak> chessguy: sorry
11:09:16 <SamB> a t-shirt quote!
11:09:21 <resiak> campusblo: because none of the elements of that list are of type Char
11:09:26 <haskellFriend> returns all rotations of a list :)
11:09:28 * chessguy snarls at resiak
11:09:29 <SamB> newsham: but that isn't perplexing to those not in on it
11:09:33 * resiak cowers
11:09:35 <newsham> true
11:09:40 <haskellFriend> how can I tell when to stop
11:09:50 <SamB> however, the Just 1 way doesn't quite make any sense anyway
11:10:13 <campusblo> hello can someone tell me why this doesnt work? filter (/= ',') ["walk", "on", "water"]
11:10:27 <newsham> probably should be Just 0.
11:10:36 <newsham> because Nothing is the lowest value, and Just 0 is the next lowest value
11:10:40 <LoganCapaldo> Just Nothing
11:10:40 <newsham> the 2nd value.
11:10:49 <SamB> um, but the lowest value is zero!
11:10:52 <newsham> in (Maybe Int)
11:11:05 <sjanssen> campusblo: ',' is a Char, "walk" is a String, /= requires that both args are the same type
11:11:06 <SamB> in plain-old naturals
11:11:18 <astrolabe> campusblo: I dont thing you are reading what people write
11:11:20 <glguy> campusblo: you are comparing a Char to a String
11:11:20 <glguy> > let f xs = zipWith (++) (tails xs) (inits xs) in f [1,2,3,4]
11:11:21 <lambdabot>  [[1,2,3,4],[2,3,4,1],[3,4,1,2],[4,1,2,3],[1,2,3,4]]
11:11:24 <newsham> just like "10" is the 2nd value in binary,  Just 0 should be the second value in Maybe Int, no?
11:11:35 <Xavier_> ?type filter
11:11:36 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
11:11:38 <LoganCapaldo> Just Nothing I say!
11:11:53 <SamB> newsham: 10 is the third value, silly
11:11:55 <LoganCapaldo> Then it's completely abstract
11:11:55 <SamB> 0 1 10
11:11:58 <newsham> logan: you're counting in Maybe Maybe a ?
11:12:05 <LoganCapaldo> Yeah, why not?
11:12:15 <newsham> what's a? :)
11:12:19 <Xavier_> see campusblo, filter takes a function from type a to type Bool, and a list of type a. You're feeding him a function that takes a Char and feeding him a list of strongs
11:12:24 <Xavier_> ?type ','
11:12:26 <lambdabot> Char
11:12:29 <LoganCapaldo> Doesn't matter :)
11:12:34 <LoganCapaldo> @type Just Nothing
11:12:35 <lambdabot> forall a. Maybe (Maybe a)
11:12:36 <Xavier_> ?type ["walk","on","water"]
11:12:38 <lambdabot> [[Char]]
11:12:46 <Xavier_> s/strongs/strings/
11:12:53 <newsham> *shrug*  I'm not a monad but i play one on irc.
11:12:58 <campusblo> thanks sjhansen and astroblade
11:13:21 <chessguy> what a sham!
11:13:22 <LoganCapaldo> @type Just Just Nothing
11:13:24 <lambdabot>   The function `Just' is applied to two arguments,
11:13:24 <lambdabot>   but its type `a -> Maybe a' has only one
11:13:30 <LoganCapaldo> @type Just $ Just Nothing
11:13:31 <lambdabot> forall a. Maybe (Maybe (Maybe a))
11:13:48 <LoganCapaldo> when will it end???
11:13:54 <newsham> turtles all the way down
11:14:05 * resiak contemplates a Perhaps monad
11:14:08 <emu> @type fix Just
11:14:09 <lambdabot>   Occurs check: cannot construct the infinite type: a = Maybe a
11:14:09 <lambdabot>    Expected type: a -> a
11:14:16 <chessguy> slain!
11:14:44 <retybok> How do i execute a list of actions? (ie [IO ()])
11:14:53 <glguy> sequence_
11:15:15 <haskellFriend> glguy almost there
11:15:16 <emu> > sequence_ [putStrLn "a"]
11:15:16 <retybok> glguy: thanks
11:15:17 <lambdabot>  <IO ()>
11:15:20 <LoganCapaldo> @type let f x = Just $ f x in f
11:15:21 <lambdabot>   Occurs check: cannot construct the infinite type: a = Maybe a
11:15:21 <lambdabot>    Expected type: a
11:15:26 <haskellFriend> > let f xs = zipWith (++) (tails xs) (inits xs) in f [1,2,3]
11:15:28 <lambdabot>  [[1,2,3],[2,3,1],[3,1,2],[1,2,3]]
11:15:42 <haskellFriend> > let f xs = zipWith (++) (tails xs) (inits xs) in f [1,2,3] == [[2,3,1], [3,1,2], [1,2,3]]
11:15:44 <lambdabot>  False
11:16:00 <haskellFriend> not the result i need
11:16:10 <newsham> > data Tups = Maybe (a, Tups)
11:16:11 <lambdabot>  Parse error
11:16:32 <LoganCapaldo> I don't think ol' lambda lets you define types
11:17:08 <sjanssen> LoganCapaldo: right, expressions only
11:17:18 <newsham> that wouldnt work anyway, though, right?
11:17:26 <newsham> would need a to be bound into Tups somehow?
11:17:33 <campusblo> ok so my original problem is that i need to parse a file
11:17:40 <glguy> haskellFriend: then use your mind and figure out how to slightly modify the output to make it do what you need
11:17:42 <sjanssen> and limited definitions via let
11:17:47 <newsham> or can I make a forall a    Maybe (a , Tups) ?
11:17:56 <campusblo> [ [ "First", "Last", "Team" , "Colour" ],
11:17:56 <campusblo>            [ "Natale" , "Sharpe" , "SW" , "Red" ],
11:17:56 <campusblo>            [ "Kayode", "Anthony", "Bulls", "White"],
11:17:56 <campusblo>            [ "Mandesa" , " Anthony" , "Jays" , " Blue"],
11:17:56 <campusblo>            [ "Lorna"' "Charles", "WI", "Maroon"] ]
11:18:03 <campusblo> thats the file
11:18:08 <sjanssen> newsham: yes, a needs to be bound somehow
11:18:34 <resiak> what's the deal with campusblo randomly quitting eery few minutes?!
11:18:48 <campusblo> sorry i got dropped again
11:18:51 <sjanssen> newsham: but, data Tups a = Maybe (a, Tups a) and data Tups = forall a. Maybe (a, Tups) are distinct
11:18:54 <LoganCapaldo> campusblo: Don't paste in the room please, and if that's the file, you don't need to parse it, just compile it :)
11:18:57 <campusblo> so i set up a variable to test the parser
11:18:57 <SamB> @pl (\x -> f x `op` g x)
11:18:57 <lambdabot> liftM2 op f g
11:19:15 <campusblo> oh sorry i didnt know i could not paste
11:19:23 <campusblo> the parse is part of the homework
11:19:28 <LoganCapaldo> @paste
11:19:28 <lambdabot> http://paste.lisp.org/new/haskell
11:19:31 <SamB> @paste
11:19:32 <lambdabot> http://paste.lisp.org/new/haskell
11:19:33 <SamB> oops
11:19:40 * SamB is slowish
11:19:43 <chessguy> @slap SamB
11:19:44 <lambdabot> why on earth would I slap SamB
11:19:48 <SamB> heh
11:19:52 <glguy> > "ping"
11:19:54 <LoganCapaldo> @slap lambdabot
11:19:54 <lambdabot>  "ping"
11:19:54 * lambdabot beats up lambdabot
11:19:57 * chessguy slaps lambdabot and starts getting carried away
11:19:57 * SamB wonders if that is karma-based?
11:19:58 <LoganCapaldo> woah
11:20:03 <newsham> is it possible to do the latter?  data Tups = forall a. Maybe (a, Tups) ?
11:20:05 <LoganCapaldo> that's odd...
11:20:06 <SamB> @slap Java
11:20:07 * lambdabot smacks Java about with a large trout
11:20:10 <SamB> @slap Java
11:20:10 * lambdabot smacks Java about with a large trout
11:20:12 <SamB> @slap Java
11:20:13 * lambdabot beats up Java
11:20:15 <newsham> cause that would be useful having variable length things with various types
11:20:23 <SamB> @slap Java
11:20:24 * lambdabot beats up Java
11:20:27 <SamB> @slap dons
11:20:28 * lambdabot smacks dons about with a large trout
11:20:30 <sjanssen> @slap SamB -- enough spam
11:20:31 * lambdabot slaps SamB -- enough spam
11:20:33 <SamB> okay, I guess not
11:20:51 <Xavier_> haskellFriend > check List.nub, should prove helpful to you
11:20:58 <LoganCapaldo> newsham: Variable length things with various types? Hoogle HList I think
11:21:08 <newsham> *nod* i've heard of it, havent used it yet
11:21:09 <campusblo> i need to convert from a string to a two dimensional array
11:21:13 <glguy> Xavier_: might be a bit overkill in this situation, now?
11:21:14 <glguy> no*
11:21:18 <chessguy> LoganCapaldo, oh really? that sounds interesting
11:21:23 <chessguy> @hoogle HList
11:21:24 <lambdabot> No matches found
11:21:24 <campusblo> thats why i have been trying the filter command
11:21:28 <newsham> just thinking of things like  zip3, zip4, zip5, etc.
11:21:38 <newsham> if you could make a variable length tuple, you could do zipN, no?
11:21:43 <chessguy> ?docs HList
11:21:44 <lambdabot> HList not available
11:21:57 <chessguy> @go haskell HList
11:21:59 <lambdabot> http://www.mail-archive.com/haskell@haskell.org/msg18907.html
11:21:59 <lambdabot> Title: [Haskell] HList with new records, in darcs.haskell.org
11:22:05 <glguy> > let f xs = drop 1 $ zipWith (++) (tails xs) (inits xs) in f [1,2,3,4]
11:22:07 <lambdabot>  [[2,3,4,1],[3,4,1,2],[4,1,2,3],[1,2,3,4]]
11:22:08 <LoganCapaldo> @where HList
11:22:09 <lambdabot> http://homepages.cwi.nl/~ralf/HList
11:22:22 <haskellFriend> come on :D
11:22:30 <Xavier_> glguy > well he just seems to want to remove the duplicate
11:22:38 <haskellFriend> > let f xs = tail(zipWith (++) (tails xs) (inits xs)) in f [1,2,3,4]
11:22:39 <lambdabot>  [[2,3,4,1],[3,4,1,2],[4,1,2,3],[1,2,3,4]]
11:22:46 <lisppaste2> metaperl annotated #31014 with "how would you implement joinLine withoutf foldl1?" at http://paste.lisp.org/display/31014#1
11:23:28 <metaperl> > inits [1..4]
11:23:30 <lambdabot>  [[],[1],[1,2],[1,2,3],[1,2,3,4]]
11:23:37 <glguy> Xavier_: no, I think he wants to remove the first one
11:23:37 <glguy> haskellFriend: that breaks on []
11:23:37 <glguy> > drop 1 []
11:23:37 <glguy> > tail []
11:23:38 <lambdabot>  Add a type signature
11:23:39 <lambdabot>  Add a type signature
11:24:14 <Botje> metaperl: i'd use "words" :]
11:24:26 <Botje> or rather unwords
11:24:32 <metaperl> Botje - yes, but I'm trying to do all from scratch
11:24:58 <haskellFriend> > let f xs = tail(zipWith (++) (tails xs) (inits xs)) in f []
11:24:59 <lambdabot>  Add a type signature
11:25:15 <haskellFriend> interesting WinHugs gets it
11:26:36 <LoganCapaldo> > let f xs = tail(zipWith (++) (tails xs) (inits xs)) in f [] :: [Bool]
11:26:37 <lambdabot>  Couldn't match `Bool' against `[a]'
11:26:41 <LoganCapaldo> heh
11:26:50 <LoganCapaldo> > let f xs = tail(zipWith (++) (tails xs) (inits xs)) in f [] :: [a]
11:26:51 <lambdabot>  [a]
11:26:51 <lambdabot>    Inferred type: [[a1]]
11:26:51 <lambdabot>   In the application `f []'
11:26:51 <lambdabot>   In the ex...
11:26:59 <LoganCapaldo> > let f xs = tail(zipWith (++) (tails xs) (inits xs)) in f [] :: [[a]]
11:27:00 <lambdabot>  Add a type signature
11:27:19 <glguy> it wants [()]
11:27:24 <glguy> or some other actual type sig
11:27:29 <LoganCapaldo> > let f xs = tail(zipWith (++) (tails xs) (inits xs)) in f [] :: [()]
11:27:30 <lambdabot>  Couldn't match `()' against `[a]'
11:27:39 <LoganCapaldo> > let f xs = tail(zipWith (++) (tails xs) (inits xs)) in f [] :: [[()]]
11:27:41 <lambdabot>  []
11:28:23 <glguy> so it works, cool
11:28:27 <haskellFriend> ok thanks to all of you
11:28:45 <haskellFriend> going to play some pool and live a real life ;)
11:28:49 <glguy> I hope you get a good grade
11:28:57 <vincenz> He left already
11:29:05 <vincenz> I hate people that don't wait 10 seconds before disco'ing
11:29:22 <glguy> Ah, I have joins/quits muted
11:29:31 <glguy> and I'm usually lagged bad enough that it wouldn't matter anyway ;)
11:29:35 <vincenz> I have quit muted
11:29:38 <vincenz> but I was trying to say something to him
11:29:42 <vincenz> and my tabcompletion failed
11:30:11 <glguy> haskellFriend was n=haskellF@gw.webmedia.ee * haskellFriend
11:30:21 <glguy> I'll just keep that in mind for the next time he asks a question ;)
11:30:35 * SamB wonders why Lemmih doesn't use his computer more
11:31:02 <moonlite> Does anyone here know Finnish? I'd like a sentence translatedm preferrably to swedish, it might be vulgar, but that's the point, i want to slam the banhammer on a bastard at a webforum i moderating.
11:31:26 <vincenz> finnish != swedish
11:31:37 <vincenz> SamB: /
11:31:39 <vincenz> SamB: ?
11:31:46 <glguy> moonlite: Just bring down the banhammer for using an unsupported language, accuse him of being a commi or something ;)
11:31:59 <moonlite> vincenz: i know. It's ok to translate it to english too
11:32:07 <vincenz> Oh!
11:32:09 <SamB> vincenz: I have an ssh account on it...
11:32:11 <vincenz> as in -from- finnish
11:32:12 <glguy> vincenz: I think he wants to go Finnish -> Swedish...
11:32:31 * vincenz refers to his earlier comment in #oassi
11:32:33 <moonlite> vincenz: yeah exactly. :)
11:32:40 <vincenz> Or as my friend put it "someone who's been working the last 100+ hours on writing a paper"
11:32:49 <vincenz> well with random moments of sleep intermingled
11:33:04 <SamB> vincenz: hmm?
11:33:15 <SamB> oh. you are talking about yourself now.
11:33:21 <vincenz> No about swedes
11:33:25 <SamB> I suppose Lemmih must have other computers.
11:33:45 <vincenz> Btw who is on Lazy Bottoms team next year?
11:34:04 <SamB> not I, I take forever to do these things!
11:34:05 <Lemmih> SamB: I don't use my computer?
11:34:33 <SamB> Lemmih: well. I haven't seen too many processes of yours...
11:34:45 <vincenz> SamB: stop spying
11:35:53 <Lemmih> SamB: I'm using it to run a website+blog.
11:35:56 <SamB> vincenz: hey, if I see a highish CPU usage process, I might want to, uh, stop running my enormously-bad black-knot solver
11:36:08 <SamB> Lemmih: why do you need a dual P4 to run a *blog*?
11:36:21 <Lemmih> It was cheap (:
11:36:27 <Botje> the web server software is written in malebolge.
11:36:28 <vincenz> Not the TCO :)
11:36:30 <vincenz> that thing sucks energy
11:36:48 <vincenz> as soon as I brick my laptop and buy a mac, I'll use my bricked laptop as server :D
11:37:07 <newsham> doesnt shapr have a blog program in happs?
11:37:12 <SamB> Botje: is that even turing complete?
11:37:24 <vincenz> SamB: only femalebolge is
11:37:25 <Botje> SamB: no idea, there's only one program ever written in it :]
11:37:39 <Botje> GL proving it, though.
11:38:39 <SamB> Lemmih: how can that be cheap?
11:38:46 <SamB> if those things are cheap, why don't I have one?
11:39:26 <campusblo> hello i want to break up a string into several lines
11:39:44 <campusblo> how do i implement the \n
11:39:59 <campusblo> or can that be used?
11:40:04 <kpreid> > lines "hello\nworld"
11:40:06 <lambdabot>  ["hello","world"]
11:40:59 <campusblo> ok thanks
11:41:17 <campusblo> im new to this
11:42:06 <astrolabe> campusblo: Asking here is good, but I found skimming through the prelude helpful for questions like that.
11:42:45 <LoganCapaldo> plus theres always hoogle
11:42:55 <LoganCapaldo> @hoogle String -> [[String]]
11:42:56 <lambdabot> No matches, try a more general search
11:42:59 <LoganCapaldo> err
11:43:03 <campusblo> ok ill look there
11:43:06 <campusblo> whats hoogle
11:43:15 <campusblo> is that a site or is that in hakskell
11:43:16 <LoganCapaldo> @hoogle Char -> [[Char]]
11:43:17 <lambdabot> No matches, try a more general search
11:43:18 <campusblo> hugs?
11:43:25 <LoganCapaldo> @where hoogle
11:43:25 <lambdabot> http://www.haskell.org/hoogle
11:43:26 <sjanssen> w00t: fromJust error at Push.lhs:136 compiled 11:00:10 Jun  7 2006
11:43:32 <campusblo> thanks
11:43:33 <sjanssen> maybe fromJust really /is/ evil
11:43:50 <LoganCapaldo> I'm dissapointed
11:43:54 <LoganCapaldo> @type lines
11:43:55 <lambdabot> String -> [String]
11:44:05 <LoganCapaldo> oh
11:44:10 <LoganCapaldo> I'm such a fool
11:44:21 <LoganCapaldo> @hoogle String -> [String]
11:44:22 <lambdabot> Prelude.lines :: String -> [String]
11:44:23 <lambdabot> Prelude.words :: String -> [String]
11:44:23 <lambdabot> Text.Regex.splitRegex :: Regex -> String -> [String]
11:44:42 <LoganCapaldo> why don't I just type the wrong type in? ;)
11:45:20 <fincher> is there anyone here who has worked on lambdabot?
11:45:29 <sjanssen> fincher: I have
11:45:47 <SamB> probably a bunch of people
11:45:54 <fincher> sjanssen: are there any threaded commands in lambdabot?  I.e., commands that might download some data from a remote site, and can't be made to block the bot?
11:45:57 <SamB> I have a bit myself
11:46:18 <edwardk> i uh, slapped together a 20 line plugin if it counts =P
11:46:30 <sjanssen> http://www.google.com -- the tinyurl and title fetching are asynchronous
11:46:31 <lambdabot> Title: Google
11:47:10 <LoganCapaldo> bad example lol
11:47:25 <campusblo> ok i got to hoogle but whats this @ thing
11:47:25 <sjanssen> LoganCapaldo: I'd say it's a good example
11:47:30 <fincher> sjanssen: how does something asynchronous like that work in a purely functional language?
11:47:51 <sjanssen> the tinyurl took to long, so lambdabot abandoned it
11:47:52 <SamB> fincher: it isn't *only* a functional language
11:48:08 <fincher> sjanssen: if I give a value to two callbacks, wouldn't the second one have an invalid value when it finally called back?
11:48:12 <LoganCapaldo> sjanssen: Oh? I thought it had a length minimum before it tinyurl'd
11:48:14 <LoganCapaldo> silly me
11:48:16 <SamB> it does, after all, have first class imperative computations
11:48:34 <fincher> SamB: which are still built on top of a purely functional core, no?
11:48:42 <sjanssen> LoganCapaldo: oh, that might be true now, don't really know
11:49:39 <sjanssen> fincher: the asynchronous stuff uses the IO monad -- which is fully imperative.  It has mutable references, IO, threading, etc.
11:49:52 <fincher> sjanssen: ah.
11:50:06 <SamB> yeah, IO isn't built on the functional core...
11:50:16 <cjeris> campusblo: /msg lambdabot @help list
11:50:32 <SamB> it is built in an implementation-defined way
11:50:44 <eviltwin_b> hrm.  so, no GUI libs currently work with ghc6.6?
11:50:44 <fincher> sjanssen: in my (python) IRC bot, each callback gets an Irc object, which they can call "queueMsg" on.  Of course, the Irc object is mutable, so that's no big deal.
11:50:58 * eviltwin_b has been trying to build a large number of them and they all lose in odd ways
11:51:07 <SamB> it still counts as pure, though, because you still have referential transparency.
11:51:13 <fincher> but I was trying to think about how I would do that with a purely-functional Irc object.
11:51:20 <SamB> unless you start using unsafe* functions, of course...
11:52:24 <SamB> now, structuring your thread-using program is of course tricky as always...
11:52:27 <fincher> it doesn't seem like it would be possible to implement a purely-functional Irc object like that.
11:52:50 <SamB> yeah.
11:53:24 <SamB> I bet you could write a purely-functional monad, though.
11:53:28 <campusblo> @help
11:53:29 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:53:33 <campusblo> @help list
11:53:34 <lambdabot> list [module|command]
11:53:34 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
11:53:36 <SamB> but probably not with the pre-emptive threading
11:53:39 <SamB> ;-)
11:54:07 <campusblo> @help map
11:54:07 <lambdabot> map. #haskell user map
11:55:02 <campusblo> @help list
11:55:03 <lambdabot> list [module|command]
11:55:03 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
11:55:11 <SamB> campusblo: um
11:55:16 <SamB> that is for help with lambdabot commands
11:55:17 <campusblo> i feel lame. im trying to get the hang of this
11:55:27 <SamB> not haskell concepts
11:56:02 <SamB> I mean, @help is
11:56:11 <SamB> if you want to know about map, you can do...
11:56:15 <SamB> @type map
11:56:17 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
11:56:24 <SamB> or...
11:56:26 <campusblo> 'list'
11:56:30 <SamB> @docs Prelude
11:56:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
11:56:33 <campusblo> @list
11:56:34 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
11:57:12 <SamB> the @list command used to take a long time, so I guess thats why it now just points at that file...
11:57:14 <fincher> SamB: how would you write a purely-functional monad?
11:57:39 <SamB> @source Control.Monad.State
11:57:40 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
11:57:45 <SamB> fincher: there is one!
11:58:12 <campusblo> sorry i got dropped
11:58:24 <campusblo> so if i want to get a list of these @ commands what do i do?
11:58:25 <chessguy> by the way, campusblo, haskell is not for the faint of heart. not getting everything right away is not lame.
11:58:36 <campusblo> like a help
11:58:53 <campusblo> ok chessguy
11:59:00 <campusblo> thanks
11:59:12 <metaperl> campusblo - but dont give up. it's worth it!
11:59:18 <metaperl> campusblo - i'm back for my 3rd beating
11:59:21 <campusblo> its not that bad. i have some exercises to do here and i have an idea of what i want to do
11:59:33 <chessguy> that list is just a list of lambdabot commands. they're not haskell commands
11:59:36 <campusblo> its just taking a while
11:59:40 <metaperl> campusblo - haskell is the language of choice of the World's only international programming competition. 3 years rnning
11:59:53 <campusblo> ok
11:59:56 <campusblo> so here is my problem
12:00:06 <campusblo> i need to break a list up into a two dimensional array
12:00:15 <campusblo> sorry a string
12:00:20 <fincher> same thing :)
12:00:35 <sjanssen> metaperl: ICFP contest is not the only international programming competition
12:00:42 <Maddas> Indeed
12:00:42 <Botje> IOCCC!
12:00:43 <metaperl> fn :: String -> [ [String] ]
12:00:48 <Cale> campusblo: CSV, right?
12:00:50 <retybok> how do I get a list of all odd numbers?
12:00:54 <metaperl> sjanssen - oh .. I didn't now that
12:00:57 <Cale> > [1,3..]
12:00:59 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
12:01:03 <retybok> wow
12:01:06 <retybok> Cale: thanks
12:01:07 <metaperl> that was easy :)
12:01:15 <campusblo> yes csv
12:01:20 <Botje> > [1,-1..]
12:01:21 <sjanssen> metaperl: yes, there's the ACM ICPC (for college students).  Probably more too
12:01:22 <lambdabot>  [1,-1,-3,-5,-7,-9,-11,-13,-15,-17,-19,-21,-23,-25,-27,-29,-31,-33,-35,-37,-3...
12:01:25 <Botje> yay! works
12:01:26 <chessguy> let odds = 1 : map (+2) odds in odds
12:01:47 <Cale> campusblo: do you have to be able to handle quoted strings that possibly have commas in them?
12:01:47 <chessguy> > let odds = 1 : map (+2) odds in odds
12:01:48 <fincher> Cale: so if you do [2, 3, 5, 7, 11, 13, 17...] do you get a list of the prime numbers?
12:01:48 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
12:01:52 <campusblo> so i know i can filter out the commas
12:01:55 <Cale> fincher: nope :)
12:01:58 <retybok> how about all odd numbers between a and b?
12:02:17 <campusblo> and i know i can use \n to break it up into a bunch of strings
12:02:23 <campusblo> now i need every string on a new line
12:02:30 <glguy> > [x * 2 - 1 | x <- [1..]]
12:02:32 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
12:02:41 <Cale> > let sieve (x:xs) = x : sieve [y | y <- xs, y `mod` x /= 0] in sieve [2..]
12:02:43 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:02:52 <Botje> > iterate (+2) 1
12:02:53 <chessguy> > let a = 5; b = 23; odds = a : map (+2) odds in takeWhile (< b) odds
12:02:54 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
12:02:55 <lambdabot>  [5,7,9,11,13,15,17,19,21]
12:02:59 <Cale> retybok: [a,a+2..b]
12:03:07 <retybok> Cale: thanks again
12:03:17 <campusblo> cale basically the string looks like this. " tom,green,red,florida"
12:03:19 <glguy> > enumFromTo 3 6
12:03:21 <lambdabot>  [3,4,5,6]
12:03:53 <campusblo> sorry cale
12:03:58 <Cale> campusblo: how about:
12:04:09 <campusblo> actually they dont specify the string
12:04:22 <campusblo> i have to figure out a string and then break it into an array
12:04:24 <Cale> 37,"green, tom", blue
12:04:28 <campusblo> or i can use lists
12:04:31 <campusblo> or lists of strings
12:04:34 <campusblo> or lists of lists
12:04:39 <Cale> how should things like that be handled?
12:05:13 <campusblo> they dont specify anything. they just say i have a csv file and do whatever to make
12:05:19 <campusblo> a 2 dimensional array
12:05:47 <campusblo> it a bunch of records that they want in a table
12:06:00 <campusblo> im zipping with \n
12:06:04 <campusblo> im filtering for comma
12:06:16 <campusblo> but after that i dont know exactly how to write it down
12:06:23 <chessguy> well, for one thing, you probably don't literally want an array in haskell (even though they exist)
12:06:48 <chessguy> what do you have to do with the table, once you have it?
12:06:52 <campusblo> no probably not i probably want something like this
12:07:10 <campusblo> im using wxHaskell to create a database
12:07:28 <campusblo> so i have to be able to add data
12:07:30 <campusblo> change records
12:07:44 <campusblo> wxHaskell is the gui
12:08:20 <campusblo> you understand what i mean?
12:08:29 <metaperl> I've had "curry" mixed up with "partial function" for awhile I think ..  map length  is a partial function, not a curried function
12:08:41 <Cale> no
12:08:54 <Cale> A partial function is one which is not defined for some input values.
12:08:54 <sjanssen> metaperl: map is a curried function
12:09:05 <metaperl> oh
12:09:09 <campusblo> cale you understand what i mean?
12:09:18 <sjanssen> writing "map length" could be called "partial application", if you'd like
12:09:19 <Cale> campusblo: I don't know the answer to my question :)
12:09:34 <metaperl> map takes 2 args... if I say "map length" then it still needs an... oh partial application... but it is not currying.. ok thanks
12:09:50 <emu> ?pl \x y -> compare (snd x) (snd y)
12:09:51 <lambdabot> (. snd) . compare . snd
12:09:57 <campusblo> oh well my original question. how do i parse?
12:10:06 <Cale> campusblo: do you have to deal with quoted strings that might have commas in them (which makes things harder), or don't you?
12:10:10 <emu> ?pl \(_,x) (_,y) -> compare x y
12:10:10 <lambdabot> (`ap` snd) . (. fst) . const . compare . snd
12:10:29 <sjanssen> metaperl: curring is the stlye of using repeated application for multiple arguments, rather than a tuple type
12:10:45 <metaperl> @type curry
12:10:46 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
12:10:54 <astrolabe> campusblo: can you give an example input, and the output you would want for it?
12:10:57 <campusblo> i get to choose my strings. at this point im doing the easiest thing
12:11:04 <Cale> okay
12:11:07 <sjanssen> curry takes a tuple style function, and turns it into a curry-style function
12:11:16 <metaperl> oh ok
12:11:42 <fincher> it'd be nice if there could be a generic curry.
12:11:55 <campusblo> if i can get this "1","Amy","Blues"
12:11:55 <campusblo> "2","Bob","Reds"
12:11:57 <Cale> one thing which you might be interested in reading is the Prelude source for 'words' and/or 'lines', because they're similar
12:11:59 <fincher> (generic on the size of the tuple, that is)
12:12:07 <campusblo> from "1","Amy","Blues"
12:12:07 <campusblo> "2","Bob","Reds"
12:12:32 <campusblo> "1,Amy,Blues,2,Bob,Reds"
12:12:34 <Cale> http://haskell.org/onlinereport/standard-prelude.html -- search for 'lines'
12:12:36 <lambdabot> Title: The Haskell 98 Report: Standard Prelude, http://tinyurl.com/y2wv6o
12:12:36 <campusblo> i would be happy
12:13:01 <campusblo> in other words one long line into several lines
12:13:12 <astrolabe> eh
12:13:19 <astrolabe> I thought I understood you then
12:13:42 <astrolabe> @type intersperse
12:13:43 <lambdabot> forall a. a -> [a] -> [a]
12:13:56 <campusblo> but the lines must be broken up at specific points. and the points arent equidistant
12:14:19 <Cale> > let cutInto n = map (take n) . takeWhile (not . null) . iterate (drop n) in cutInto 3 [1..12]
12:14:21 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12]]
12:14:29 <campusblo> in other words if someone misses an entry in a database it should not all go off
12:14:34 <Cale> ah, not equidistant?
12:14:46 <Cale> How do you tell where they begin?
12:14:53 <campusblo> no they need to be marked with a character
12:15:03 <campusblo> thats the first part
12:15:14 <Cale> how about newline?
12:15:25 <campusblo> basically you are entering lines through a gui and at the end of every line there needs to be a character
12:15:39 <campusblo> that way if the person skips a field it still knows that the line is done
12:15:42 <Cale> well, of course there already is such a character
12:15:49 <campusblo> right
12:15:54 <campusblo> so i zip with that character
12:16:02 <Cale> > lines "Hello\nworld"
12:16:03 <lambdabot>  ["Hello","world"]
12:16:12 <Cale> zip?
12:16:31 <campusblo> thats the function we got in class
12:16:37 <Cale> > zip [1,2,3] [4,5,6]
12:16:39 <lambdabot>  [(1,4),(2,5),(3,6)]
12:16:45 <Cale> are you sure that's what you want?
12:16:59 <campusblo> yes
12:17:03 <Cale> hmm
12:17:12 <Cale> I don't understand why
12:17:21 <campusblo> actually not really but thats what everybody is doing
12:17:31 <campusblo> because you enter in a gui
12:17:49 <campusblo> so you have an unending list of \n
12:18:05 <Cale> huh
12:18:13 <LoganCapaldo> > map (\(x,y) -> x ++ [y]) zip ["hello", "world"] ['\n','\n'..]
12:18:14 <lambdabot>    The function `map' is applied to four arguments,
12:18:14 <lambdabot>   but its type `(a ->...
12:18:18 <campusblo> sorry got dropped
12:18:25 <LoganCapaldo> > map (\(x,y) -> x ++ [y]) $ zip ["hello", "world"] ['\n','\n'..]
12:18:26 <lambdabot>  ["hello\n","world\n"]
12:18:34 <Cale> are you sure you don't just want map?
12:18:39 <campusblo> right i want something like taht
12:18:45 <campusblo> i can use map
12:18:48 <LoganCapaldo> map would be less silly
12:18:54 <campusblo> we just did zip in class and its what i remember
12:18:58 <Cale> > map (\x -> x ++ "\n") ["Hello", "world"]
12:19:00 <lambdabot>  ["Hello\n","world\n"]
12:19:06 <dolio> He wants zipWith, no?
12:19:39 <Cale> > zipWith (++) ["Hello", "World"] ['\n','\n'..]
12:19:40 <lambdabot>  Couldn't match `[Char]' against `Char'
12:19:50 <Cale> > zipWith (++) ["Hello", "World"] (map return [\n','\n'..])
12:19:51 <lambdabot>  Parse error
12:20:02 <Cale> er
12:20:04 <dolio> > zipWith (\x y -> x ++ [y]) ["hello", "world"] ['\n', '\n' ..]
12:20:04 <Cale> > zipWith (++) ["Hello", "World"] (map return ['\n','\n'..])
12:20:06 <lambdabot>  ["hello\n","world\n"]
12:20:07 <lambdabot>  ["Hello\n","World\n"]
12:20:24 <campusblo> could be zipwith too i guess
12:20:30 <Cale> yeah, but at that point, you might as well just use map
12:20:34 <LoganCapaldo> > zipWith (++) ["Hello", "World"] ["\n", "\n"..]
12:20:35 <lambdabot>  add an instance declaration for (Enum [Char])
12:20:35 <lambdabot>   In an arithmetic sequence...
12:20:40 <LoganCapaldo> darn
12:20:51 <dolio> > zipWith (ap (++) return) ["hello", "world"] ['\n', '\n' ..]
12:20:53 <lambdabot>    Expecting a function type, but found `[a]'
12:20:53 <lambdabot>    Expected type: [a] -> [...
12:21:11 <campusblo> so ok i can use map i guess
12:21:17 <dolio> Oh, right. Never mind with that.
12:21:32 <Cale> zipWith f xs (repeat y) = map (\x -> f x y) xs
12:21:46 <campusblo> but the idea is that the person enters info into the database and i should able
12:21:46 <Cale> or if you want
12:21:57 <Cale> zipWith f xs (repeat y) = map (flip f y) xs
12:22:28 <campusblo> to get a table output
12:22:39 <campusblo> and its stored in a string
12:23:07 <campusblo> writeTableToFile::String ->Table -> IO()
12:23:07 <campusblo> --formats the data provided an writes it to the specified file
12:23:23 <campusblo> so this is some of what i have to write
12:23:34 <Cale> and what is the Table type? [[String]]?
12:25:19 <campusblo> if that means a list of list of strings then yes
12:25:39 <Cale> yeah
12:26:22 <Cale> How well-formatted should the table be?
12:26:58 <campusblo> well ideally i guess a missed entry should have a variable assigned to it
12:27:05 <Cale> If it's only necessary that it be machine-readable, I'd personally just 'show' the table, and write that to the file, because then it can be read in again with 'read'
12:27:17 <campusblo> like " missed entry "
12:27:22 <campusblo> or something
12:27:24 <Cale> or just ""
12:27:51 <campusblo> nah ppl have to read it
12:28:04 <campusblo> but at this point ill work with one then create the other
12:29:02 <campusblo> maybe i need to back up and give the full list of what i have to do.
12:29:17 <campusblo> I have to use a gui to create databases
12:29:25 <LoganCapaldo> @type read
12:29:27 <lambdabot> forall a. (Read a) => String -> a
12:29:29 <Cale> Is there an assignment PDF online?
12:29:48 <Cale> (or website, etc.)
12:29:48 <campusblo> basic databases
12:30:05 <campusblo> yeh but its password protected. i could send you a document though
12:30:08 <campusblo> word
12:30:24 <Cale> sure, I think I can open that with openoffice.
12:30:43 <campusblo> youd probably ask better quesetions than me anyway
12:32:05 <campusblo> i just sent a file to you privately
12:32:24 <campusblo> you seeing it?
12:32:55 <LoganCapaldo> Is fps == Data.ByteString, or am I bonkers?
12:33:15 <SamB> LoganCapaldo: perhaps both are true
12:33:24 <sjanssen> LoganCapaldo: yes
12:33:47 <LoganCapaldo> Is there a rationale for this confusing to me naming scheme?
12:33:57 <sjanssen> Data.ByteString used to be called Data.FastPackedString
12:34:02 <campusblo> hey cale i tried to dcc you
12:34:05 <LoganCapaldo> aha
12:34:15 <campusblo> how can i send this thing to you?
12:34:25 <LoganCapaldo> it's all clear to me now
12:36:15 <campusblo> Cale?
12:37:02 <LoganCapaldo> ooo
12:37:07 <LoganCapaldo> Chasing modules ghc is
12:37:14 <LoganCapaldo> whatever that means
12:44:22 <Renkin> I try to define return for a new monad like: return x = ... return x ...  where I want the return x in the right expression to be the return of IO. Is that expressable?
12:44:35 <Renkin> I tried  return x = ... return x :: IO a ...
12:44:55 <SamB> umm.
12:45:08 <SamB> hmm.
12:45:14 <sjanssen> Renkin: probably need parens around (return x :: IO a)
12:45:19 * SamB doesn't usually write monads directly in terms of IO
12:45:40 <sjanssen> Renkin: but, if your function is correct, the type signature is probably not required
12:45:42 <Renkin> I think I tried all combinations of paraens
12:45:51 <Renkin> Yeah..
12:46:09 <Renkin> I'm probably not doing it right. I'm trying to define a tricky monad
12:47:47 <Renkin> Tricky to me, at least :)
12:51:44 * LoganCapaldo successfully built yi
12:52:49 <pitecus> Can GADTs be used with record syntax?
12:57:05 <kosmikus> definitely not in 6.4.* ... I'm not aware that this has been changed in 6.6, but it might be.
12:57:30 <campusblo> how do i import a module?
12:57:41 <LoganCapaldo> import A.Module
12:58:01 <campusblo> what is the A?
12:58:10 <LoganCapaldo> an example
12:58:13 <yaxu> that would be a directory called A
12:58:18 <yaxu> with a file Module.hs in
12:58:44 <campusblo> ok
12:59:31 <yaxu> you can also just import specified functions
12:59:32 <retybok> how do you trace the execution of your program in haskell, knowing you can't add nice little printf's throughout your code?
12:59:44 <campusblo> thanks
12:59:45 <SamB> @hoogle trace
12:59:46 <yaxu> import A Module (f)
12:59:46 <lambdabot> Debug.Trace.trace :: String -> a -> a
12:59:47 <lambdabot> Debug.Trace :: module
12:59:47 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
12:59:51 <yaxu> import A.Module (f)
12:59:54 <yaxu> i meant
12:59:58 <SamB> > trace "Hi!" ()
12:59:59 <campusblo> oh thats cool
13:00:00 <lambdabot>  Not in scope: `trace'
13:00:01 <yaxu> would import f from A/Module.hs
13:00:06 <yaxu> rather than everything
13:00:09 <SamB> hm.
13:00:14 <SamB> not imported :-(.
13:00:23 <campusblo> parse error
13:00:25 <campusblo> on input
13:00:33 <retybok> thanks
13:00:39 <campusblo> for the import
13:00:46 <campusblo> what does that mean?
13:01:22 <yaxu> do you have something like module Main where
13:01:39 <yaxu> you would put the import after that
13:03:13 <campusblo> yaxu the modules are in the same directory
13:03:32 <campusblo> i double click on the main module adn the other module is in the same directory
13:03:49 <yaxu> that's fine
13:05:04 <yaxu> http://www.mathematik.uni-marburg.de/~priebe/docs/mirror/tutorial/modules.html
13:05:06 <yaxu> maybe that helps
13:05:07 <lambdabot> Title: A Gentle Introduction to Haskell: Modules, http://tinyurl.com/ujxrs
13:05:18 <retybok> sorry, really a noob, but i can't find the trace function
13:05:26 <retybok> i suppose i must import some module?
13:05:47 <rahikkala> import Debug.Trace iirc
13:06:16 <retybok>     Could not find module `Debug':
13:08:31 <retybok> anybody know why?
13:08:50 <newsham> what haskell are you using?
13:08:53 <rahikkala> retybok: If you're using hugs, it's just import Trace
13:08:58 <retybok> ghci
13:09:06 <retybok> well, ghc
13:09:23 <newsham> which version?
13:10:04 <lispy> ?hoogle Trace
13:10:05 <lambdabot> Debug.Trace :: module
13:10:05 <lambdabot> Debug.Trace.trace :: String -> a -> a
13:10:05 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
13:10:18 <rahikkala> Inside ghci you'd use :m +Debug.Trace
13:10:22 <retybok> 6.6
13:10:37 <retybok> actually
13:10:46 <retybok> i'm typing import Debug.Trace in some .hs file
13:10:55 <retybok> and then I :load it in ghci
13:12:03 <LoganCapaldo> I don't think that'll work
13:12:11 <LoganCapaldo> the import will only have scope for the file
13:12:12 <retybok> why?
13:12:28 <retybok> LoganCapaldo: that's the plan, i want to use the module in the file
13:12:47 <LoganCapaldo> ok
13:12:52 <retybok> actually, compiling it with ghc i get the following error:
13:12:54 <LoganCapaldo> heh
13:12:56 <LoganCapaldo> nvm
13:13:02 <retybok> sphere-primes.hs:44:0: parse error on input `import'
13:13:56 <retybok> mmm
13:14:05 <rahikkala> I don't know much about the syntax involved, but I place my import lines right in the beginning of a file (after the module declaration, that is)
13:14:07 <retybok> turns out you must import modules before everything else
13:14:10 <retybok> is that correct?
13:14:24 <LoganCapaldo> that would make sense
13:14:27 <retybok> rahikkala: i think that was the problem
13:16:16 <kosmikus> yes, that's the case
13:17:22 <Excedrin> retybok: import has to occur at the top
13:22:18 <gour> does goa works with 6.6?
13:23:27 <emu> what do people typically use for logging in large applications?
13:23:38 <emu> Debug.Trace/
13:23:39 <emu> ?
13:26:10 <adrian221> Hi. I'm trying to do regOpenKey from System.Win32.Registry with GHC. Everything works fine, but i get "internal error: resumeThread: thread not found" after a second. What happens?
13:26:38 <metaperl> @seen Cale
13:26:38 <lambdabot> Cale is in #oasis, #ghc and #haskell. I last heard Cale speak 56m 14s ago.
13:26:51 <metaperl> Cale - ping?
13:27:55 <ascii> @where mtl
13:27:56 <lambdabot> www.cs.brown.edu/~jwicks/mtl_reference/
13:31:43 <hmich> Hi all! Sorry for probably rather stupid question. I've read in YAHT that class Printable t where toString :: t -> String
13:31:43 <hmich> instance Show t => Printable t where toString = show
13:32:00 <hmich> is illegal
13:32:09 <hmich> what's the right way to do this kind of thing?
13:32:27 <shapr> SHAZAM!
13:32:50 <shapr> hmich: Really? That's illegal?
13:33:39 <hmich> yeah, ghc says
13:33:39 <hmich>     Illegal instance declaration for `Printable t'
13:33:40 <hmich> 	(The instance type must be of form (T a b c)
13:33:40 <hmich> 	 where T is not a synonym, and a,b,c are distinct type variables)
13:33:40 <hmich>     In the instance declaration for `Printable t'
13:34:03 <hmich> or am i doing something wrong?
13:35:23 <Cale> hello, sorry for leaving abruptly there :)
13:36:31 <metaperl> Cale - I figured out what I was trying to do. I came up with a data flow diagram I needed
13:36:36 <shapr> hmich: It seems that YAHT is correct.
13:38:01 <adrian221> OK, one last time :) I'm trying to do regOpenKey from System.Win32.Registry with GHC. Everything works fine, but i get "internal error: resumeThread: thread not found" after a second. Any1 knows whats wrong?
13:39:21 <AtnNn> hmich: i geet the same error without -fglasgow-exts and -fallow-overlapping-instances
13:41:40 <shapr> hmich: Yeah, with -fglasgow-exts and -fallow-undecidable-instances it works fine
13:41:47 <shapr> hmich: Not that I know exactly why...
13:42:10 <hmich> yes, i checked this, thanks
13:42:20 <hmich> but is there some workaround in vanilla haskell-98?
13:43:33 <hmich> basically i want to define polymorhic function that will convert values to strings almost as show except several types, where i want to specify precise behaviour
13:44:13 <campusblo> hi how do i break one list into several lists?
13:44:31 <shapr> campusblo: use a STICK!
13:44:44 <LoganCapaldo> @hoogle [a] -> [[a]]
13:44:45 <lambdabot> List.inits :: [a] -> [[a]]
13:44:45 <Cale> campusblo: break how?
13:44:46 <lambdabot> List.tails :: [a] -> [[a]]
13:44:46 <lambdabot> List.group :: Eq a => [a] -> [[a]]
13:45:16 <Excedrin> > splitAt 5 "Hello World"
13:45:18 <lambdabot>  ("Hello"," World")
13:46:10 <kosmikus> hmich: I think the Haskell-98 way is to declare "class Show a => Printable a where toString :: t -> String; toString = show"
13:46:39 <kosmikus> hmich: then you still have to give instance declarations for all types you want to be in Printable, but you don't have to give any method definition as long as you just want to reuse show
13:47:24 <campusblo> [ "Jack", "Red", "Jane", Green" ] to [["jack","red"],[Jane,Green]]
13:48:05 <Excedrin> > splitAt 2 "jrjg"
13:48:06 <lambdabot>  ("jr","jg")
13:48:42 <Cale> > map (take 2) . takeWhile (not . null) . iterate (drop 2) . words $ "Jack Red Jane Green"
13:48:44 <lambdabot>  [["Jack","Red"],["Jane","Green"]]
13:48:46 <campusblo> [["jack","red"],["Jane,"Green"]]
13:49:55 <campusblo> i dont want to take 2 i want a character to mark the end though for my task
13:50:06 <campusblo> so how could i design something to do that
13:50:10 <shapr> Is this homework?
13:50:22 <campusblo> yes
13:50:31 <Cale> campusblo: look at the implementation of 'words' and 'lines' in the Prelude
13:50:53 <Cale> http://www.haskell.org/onlinereport/standard-prelude.html
13:50:56 <lambdabot> Title: The Haskell 98 Report: Standard Prelude, http://tinyurl.com/y4sua7
13:51:59 <hmich> kosmikes: there is a problem with this approach. If i specify some instances then i won't be able to use toString with any types except explicitly instantiated
13:52:48 <lisppaste2> metaperl annotated #31014 with "Not sure how cycle creates an infinite list" at http://paste.lisp.org/display/31014#2
13:52:56 <monochrom> whee
13:53:42 <kosmikus> hmich: yes, there are other problems as well. but I don't think you can do much better within Haskell 98 ...
13:55:00 <monochrom> metaperl: perhaps it is helpful to think "cycle xs = xs ++ cycle xs"
13:56:16 <monochrom> If I ask for "take 3 (cycle [a,b])", that expands to "take 3 ([a,b] ++ [a,b] ++ cycle[a,b])" to fill the need of take 3.
13:56:45 <monochrom> An "infinite" list is a finite list that is longer than your need.
13:57:18 <metaperl> monochrom yes that works better
13:58:34 <monochrom> I believe the form "cycle xs = let xs' = xs ++ xs' in xs'" is a code optimization by hand.  It may have performance advantages.
13:58:53 <metaperl> I suppose. it seems hard to understand.. very circular
13:59:00 <Cale> it does, because ++ is only evaluated once.
13:59:02 <emu> what's the deal with hWaitForInput? GHC documentation describes it with "NOTE: in the current implementation, this is the only case that works correctly (if t is non-zero, then all other concurrent threads are blocked until data is available)."
13:59:10 <campusblo> im sorry my connection keeps dropping.
13:59:30 <campusblo> ok i see the functions in the prelude but how do i implement them or where can i get info on how to implement?
14:00:04 <Cale> well, I linked you to a document with sample implementations
14:00:11 <campusblo> so i know lines breaks up into lines but where do i get an example
14:00:33 <lispy> > lines "one\ntwo\nthree"
14:00:34 <lambdabot>  ["one","two","three"]
14:00:34 <campusblo> what i see is string -> string
14:00:43 <Cale> String -> [String]
14:01:05 <campusblo> ok thanks
14:01:08 <Cale> lines            :: String -> [String]
14:01:08 <Cale> lines ""         =  []
14:01:08 <Cale> lines s          =  let (l, s') = break (== '\n') s
14:01:08 <Cale>                       in  l : case s' of
14:01:08 <Cale>                                 []      -> []
14:01:09 <Cale>                                 (_:s'') -> lines s''
14:01:49 <Cale> I'm not sure I'd write it that way, but that works.
14:02:06 <campusblo> thats the part i saw. i just didnt know how to add the \n s
14:02:07 <lispy> yeah, i was just going to say, that's uglier than it has to be :)
14:02:18 <monochrom> I rewrite operationally-optimized code into mathematically-optimized code, and that helps me see what it intends to result.  Then I see how the mathematically-optimized code corresponds to the operationally-optimized code and how it's more efficient, (and even the representation in the machine), and I'm very happy.  Having a million perspectives is nice.
14:02:22 <campusblo> you guys are at the point where you can tell
14:02:54 <Cale> campusblo: "add the \n's" ?
14:03:03 <Cale> This is code to split a string on \n's.
14:03:23 <Cale> You mean, add them back into each of the lines?
14:03:58 <earthy> lines?
14:04:01 <campusblo> i meant that from that page i could see what the function did but not how to call it
14:04:05 <earthy> unlines?
14:04:12 <Cale> oh
14:04:22 <campusblo> nevermind. im gonna try it. thanks for the help
14:04:26 <Cale> It's a function, you just apply it to a String
14:04:38 <Cale> > lines "a\nb\nc"
14:04:40 <lambdabot>  ["a","b","c"]
14:05:28 <lispy> > unlines (lines "a\nb\nc")
14:05:29 <lambdabot>  "a\nb\nc\n"
14:05:38 <lispy> boo! at unlines
14:05:50 <campusblo> ok but i didnt know what the separator was
14:06:04 <campusblo> wow unlines looks like it might help me too
14:06:05 <Cale> well, newline
14:06:25 <lispy> it might help, but unlines . lines != id
14:06:35 <lispy> which is unfortunate
14:06:48 <campusblo> ok thanks. im super newbie going back to work now. will be back im sure. im making progress
14:07:05 <lispy> > lines "a\n\nb\nc"
14:07:06 <lambdabot>  ["a","","b","c"]
14:07:14 <newsham> any aussies have early word on how december is?
14:08:27 <monochrom> probably fine sunny Friday morning, most suitable for sleeping :)
14:08:52 <newsham> hmm, i dont get to sleep on friday mornings
14:10:28 <campusblo> is there a difference between lines and words?
14:10:36 <campusblo> i just tried both on a string and got the same result
14:10:55 <LoganCapaldo> > lines "hello world\nseven eight"
14:10:56 <lambdabot>  ["hello world","seven eight"]
14:11:15 <LoganCapaldo> > words "hello world\nseven eight"
14:11:16 <lambdabot>  ["hello","world","seven","eight"]
14:11:44 <newsham> unlines (map return "foo")
14:11:46 <metaperl> the Haskell prelude is fon-kay
14:11:51 <newsham> > unlines (map return "foo")
14:11:53 <lambdabot>  "f\no\no\n"
14:12:34 <newsham> > unwords (map return "foo")
14:12:35 <lambdabot>  "f o o"
14:13:09 <campusblo> suppose i wanted to break a list into lists?
14:13:18 <campusblo> what would i use?
14:13:23 <monochrom> break by what criterion?
14:13:32 <campusblo> a marker
14:13:38 <campusblo> like \n
14:13:57 <campusblo> or a character like |
14:14:00 <monochrom> A simple way is to copy the code of lines and change \n to your marker.
14:14:25 <campusblo> and id do that how exactly?
14:15:06 <LoganCapaldo> @paste
14:15:06 <lambdabot> http://paste.lisp.org/new/haskell
14:15:11 <campusblo> wait i want to break a list into a list of lists
14:16:27 <lisppaste2> LoganCapaldo pasted "recursive break" at http://paste.lisp.org/display/31045
14:16:43 <LoganCapaldo> campusblo: something like that
14:16:43 <monochrom> After doing that for several different markers, you may like to abstract it from the particular marker.
14:16:49 <campusblo> ["1","2","\n","3","4"] into [["1","2"],["3","4"]]
14:16:54 <campusblo> thats what i want to do
14:17:45 <monochrom> The ultimate way is to use Text.Regex.splitRegex.  It allows a regex for the marker too.  Very general.
14:18:03 <LoganCapaldo> look at what I pasted
14:18:13 <metaperl> I'm confused about this ... any p            =  or . map p    -- I'm wondering if that is (or . map) p OR or . (map p)
14:18:27 <Cale> or . map p
14:18:30 <LoganCapaldo> you'd say genericSplits (== "\n") ["1","2","\n","3","4"]
14:18:30 <Cale> or . (map p)
14:18:54 <metaperl> ok thanks
14:18:57 <Cale> function application binds tighter than any operator
14:19:10 <metaperl> yes, I've heard that trillions of times here. so I suspected that
14:19:51 <Cale> another way to check...
14:19:54 <Cale> @type or . map
14:19:56 <lambdabot>   Expecting a function type, but found `b'
14:19:56 <lambdabot>    Expected type: (a -> b) -> [Bool]
14:20:08 <Cale> so it can't be (or . map) p
14:20:13 <metaperl> ah
14:23:40 * metaperl packs up and heads home
14:25:37 <Masklinn> hello all
14:27:06 <lispy> Masklinn: hello, welcome to #haskell
14:28:01 * Masklinn is the guy who's been seen here as Xavier_ for the last few days
14:28:20 <Masklinn> (just so you know)
14:28:32 <campusblo> wait guys. im still a bit confused. this is what i want to do. can somebody type a command to do this ["1","2","\n","3","4"] into [["1","2"],["3","4"]]
14:28:57 <campusblo> to get from the list to the list of lists?
14:28:59 <Cale> well, lines won't do that for you
14:29:19 <Cale> but a variant would
14:29:39 <campusblo> what would you suggest?
14:29:41 <LoganCapaldo> campusblo: look, at, what, I pasted
14:30:14 <campusblo> splits?
14:30:26 <LoganCapaldo> yes
14:30:31 <monochrom> This is very productive indeed.
14:30:34 <campusblo> im sorry but i keep getting disconnected and everytime i do eveything disappears when i log back on
14:30:44 <campusblo> i put splits in a prelude and tried it
14:30:54 <Cale> so probably (and this should be in the Prelude or List library, but it's not), you want to write a variant of lines, perhaps called breakOn or some such, which will take a parameter for what element to split on, and do exactly the same task of splitting the thing into lists.
14:30:56 <campusblo> in a module sorry
14:31:11 <LoganCapaldo> genericSplits (== "\n") ["1","2","\n","3","4"]
14:31:12 <lispy> ?hoogle breakOn
14:31:13 <lambdabot> No matches found
14:31:28 <LoganCapaldo> ?hoogle break
14:31:29 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
14:31:29 <lambdabot> GHC.ConsoleHandler.Break :: ConsoleEvent
14:31:29 <lambdabot> Data.PackedString.breakPS :: (Char -> Bool) -> PackedString -> (PackedString, PackedString)
14:31:34 <campusblo> i got an error
14:31:43 <monochrom> I trust Text.Regex.splitRegex.
14:32:05 <lispy> > takeWhile (/="\n") ["1","2","\n","3","4"]
14:32:07 <lambdabot>  ["1","2"]
14:32:53 <campusblo> ok now how would i get the 3 4 ?
14:32:54 <monochrom> I'll advertise once again LoganCapaldo's http://paste.lisp.org/display/31045
14:33:12 <monochrom> Just to end this nonsense.
14:33:38 <lisppaste2> LoganCapaldo annotated #31045 with "["3", "4"]" at http://paste.lisp.org/display/31045#1
14:34:23 <LoganCapaldo> It's just words with s/isSpace/f/
14:34:31 <Cale> > let splits p = map (takeWhile  takeWhile (not . null) . iterate (drop 1 . dropWhile (not . p)) in splits "this is fun but it doesn't work quite right with trailing delimiters "
14:34:32 <lambdabot>  Parse error
14:34:35 <Cale> er :)
14:34:45 <Cale> let splits p = map (takeWhile (not . p)) . takeWhile (not . null) . iterate (drop 1 . dropWhile (not . p)) in splits "this is fun but it doesn't work quite right with trailing delimiters "
14:34:54 <Cale> > let splits p = map (takeWhile (not . p)) . takeWhile (not . null) . iterate (drop 1 . dropWhile (not . p)) in splits "this is fun but it doesn't work quite right with trailing delimiters "
14:34:55 <lambdabot>  Couldn't match `a -> Bool' against `[Char]'
14:35:12 <Cale> oh, I'm pasting wrong :)
14:35:20 <Cale> > let splits p = map (takeWhile (not . p)) . takeWhile (not . null) . iterate (drop 1 . dropWhile (not . p)) in splits (==' ') "this is fun but it doesn't work quite right with trailing delimiters "
14:35:21 <lambdabot>  ["this","is","fun","but","it","doesn't","work","quite","right","with","trail...
14:35:30 <Cale> > let splits p = map (takeWhile (not . p)) . takeWhile (not . null) . iterate (drop 1 . dropWhile (not . p)) in splits (==' ') "trailing delimiters "
14:35:32 <lambdabot>  ["trailing","delimiters"]
14:35:50 <Cale> (note that it didn't leave a blank string at the end)
14:35:56 <lispy> is /= = not (=)
14:36:02 <lispy> is /= = not (==) ?
14:36:06 <Cale> (/=) = not (==)
14:36:12 <Cale> at least, usually
14:36:17 <lispy> that's cool
14:36:33 <Cale> also, you need a generous definition of not
14:36:39 <LoganCapaldo> Cale: If we are going by perl (which was what I was shooting for) it shouldn't anyway
14:36:41 <lispy> i mean, it's cool that haskell is that high level, and yet it's also very efficient
14:36:43 <Cale> (x /= y) = not (x == y)
14:36:58 <Cale> however
14:36:59 <dino-> :t (=)
14:37:03 <dino-> heh
14:37:07 <dino-> ?type (=)
14:37:09 <lambdabot> parse error on input `='
14:37:18 <monochrom> = is a keyword
14:37:23 <campusblo> yay it works
14:37:27 <Cale> > ((0/0) /= (0/0)) == not ((0/0) == (0/0))
14:37:29 <lambdabot>  True
14:37:29 <campusblo> praise cuthulhu
14:37:41 <Cale> > (0/0) == (0/0)
14:37:43 <lambdabot>  False
14:37:50 <lispy> > True == False == True
14:37:50 <lambdabot>    precedence parsing error
14:37:51 <lambdabot>     cannot mix `(==)' [infix 4] and `(==)' ...
14:37:51 <Cale> ah, right
14:37:57 <Cale> > (0/0) /= (0/0)
14:37:58 <lispy> > True == (False == True)
14:37:59 <lambdabot>  True
14:38:00 <lambdabot>  False
14:38:07 <Cale> hehe
14:38:27 <lispy> > True == (False == False)
14:38:29 <lambdabot>  True
14:38:40 <monochrom> I am saddened.  That kid had a gimme attitude.
14:39:03 <lispy> monochrom: who, campusblo?
14:39:07 <monochrom> yeah
14:39:28 <lispy> yeah, cale is too helpful :)
14:39:43 <Excedrin_> wasn't Smerdyakov kicked or banned or something for refusing to help with homework?
14:40:05 <astrolabe> That doesn't sound likely
14:40:21 <Cale> I don't mind giving homework solutions to people who beg, since they'll probably just fail their exams if they didn't actually understand.
14:40:22 <monochrom> I haven't been kicked or banned yet. :)
14:40:43 <lispy> Cale: haah
14:40:47 <astrolabe> @karma+ Cale
14:40:48 <lambdabot> Cale's karma raised to 31.
14:40:59 <LoganCapaldo> Hmm
14:41:04 <Masklinn> Cale > that's not even certain, some people have amazing bullshitting skills
14:41:14 <LoganCapaldo> @karma- LoganCapaldo
14:41:14 <lambdabot> You can't change your own karma, silly.
14:41:22 <LoganCapaldo> avast!
14:41:25 <lispy> lambdabot: actually youcan
14:41:32 <Cale> It's much harder to bullshit on paper during a 3 hour exam where you can't communicate with anyone.
14:41:34 <Masklinn> besides, i always learned that one should fail early when programming, shouldn't it apply in real life too?
14:41:40 <lispy> if you do Java plus plus, it will decrement your karma :)
14:41:58 <LoganCapaldo> Really?
14:42:00 <lispy> yeah
14:42:03 <LoganCapaldo> @karma+ Java
14:42:03 <lambdabot> LoganCapaldo's karma lowered to -1.
14:42:05 <fincher> hmm.
14:42:06 <LoganCapaldo> LOL
14:42:08 <lispy> it's a nice little joke someone put  in
14:42:13 <fincher> where's the code for the State monad?
14:42:17 <monochrom> LoganCapaldo++
14:42:21 <astrolabe> That's excellent
14:42:37 <lispy> fincher: do you just want to see how it's implemented?
14:42:41 <astrolabe> @where Monad.State
14:42:41 <lambdabot> I know nothing about monad.state.
14:42:49 <fincher> lispy: yes
14:42:51 <lispy> fincher: if so, you don't really need the source, you just need a good tutorial!
14:42:56 <lispy> ?google all about monads
14:43:00 <lambdabot> http://www.nomaware.com/monads/
14:43:00 <lambdabot> Title: Nomaware | Monads
14:43:07 <lispy> fincher: ^^
14:43:11 <astrolabe> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
14:43:13 <lambdabot> http://tinyurl.com/yx2t8w
14:43:18 <Cale> http://www.nomaware.com/monads/html/statemonad.html
14:43:20 <lispy> fincher: relevant snippets are given
14:43:20 <lambdabot> Title: The State monad, http://tinyurl.com/yldt3d
14:43:30 <Cale> scroll down there, and you'll get a definition
14:43:32 <astrolabe> Ah, but no source here I don't think
14:43:45 <Cale> @libsrc Control.Monad.State
14:43:46 <lambdabot> Unknown command, try @list
14:43:48 <Cale> er
14:44:12 <Cale> @source Control.Monad.State
14:44:12 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
14:44:18 <Cale> rrright
14:44:31 <dino-> Don's got it too: http://www.cse.unsw.edu.au/~dons/data/State.html
14:44:33 <lambdabot> Title: Haskell State Monad, http://tinyurl.com/y9pxpc
14:48:46 <Excedrin> in response to a typical homework question, he'd say stuff like this:
14:48:49 <Excedrin> <Smerdyakov> I am not convinced that it would be ethical to provide further information.
14:49:21 <monochrom> I should try that next time when dons is around to police over the community :)
14:49:35 <Excedrin> <Smerdyakov> I would offer you my assistance if I believed that this was an appropriate academic situation.
14:50:00 <Excedrin> lambdabot should have a bunch of Smerdyakov quotes for situations when people ask for homework help
14:50:08 <monochrom> But my recollection is that the ban was for something unrelated.
14:50:28 <Excedrin> it was for grating on shaprs nerves apparently (I'm reading logs)
14:51:39 <hmich> @list
14:51:40 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
14:56:30 <_mysty_> Hello
14:57:10 <AtnNn> hi
14:57:41 <_mysty_> Is it possible to make write a Deque in Haskell with constant time pushing and popping from both sides?
14:57:58 <AtnNn> you mean a Deck?
14:58:11 <_mysty_> Double Ended Queue
14:58:34 <sjanssen> _mysty_: yes
14:58:48 <_mysty_> Really?
14:58:57 <_mysty_> What data structure would you use?
14:59:14 <_mysty_> Or where can I read about it?
14:59:16 <sjanssen> _mysty_: check out Data.Sequence.  It's included with GHC 6.6
14:59:28 <sjanssen> _mysty_: it uses 2-3 finger trees
14:59:32 <sjanssen> @docs Data.Sequence
14:59:33 <lambdabot> Data.Sequence not available
14:59:36 <_mysty_> Are you sure it's constant time? I'll have a look
14:59:40 <sjanssen> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Sequence.html#v%3A%3C%7C
14:59:42 <lambdabot> http://tinyurl.com/um3d4
14:59:48 <sjanssen> _mysty_: see the referenced paper
15:00:06 <sjanssen> it's O(1) amortized, as I recall
15:00:24 <_mysty_> oh, ok. Thanks!
15:01:33 <sjanssen> Ralf Hinze and Ross Paterson, "Finger trees: a simple general-purpose data structure" -- is a beautiful paper, I highly recommend it
15:02:10 <cjeris> sjanssen: more recent than Okasaki's book?
15:02:30 <sjanssen> cjeris: yes, published this year
15:02:48 <shapr> Excedrin: Nah, smerdyakov was banned for driving away newbies.
15:03:04 <sjanssen> Hinze and Paterson use a novel monoid-based interface to provide a /very/ flexible data structure
15:03:12 <shapr> 2-3 Finger Trees?
15:03:15 * mgsloan probably would have learned haskell 2 years ago if it wasn't for smerdy
15:03:43 <Cale> mgsloan: yeah, there's a reason we banned him
15:03:44 <sjanssen> with their Data.FingerTree code you can write heaps, seqeunces, sets, finite maps, priority search queues, ranged sets, and probably more
15:04:07 <shapr> Excedrin: If Smerdyakov had been banned the first time he got on my nerves, no one would remember him =)
15:04:19 <Cale> sjanssen: It's strange that it's not in base
15:04:37 <mgsloan> shapr - it wasn't in this channel though, which is the funny thing
15:05:20 <shapr> Which channel was it?
15:05:31 <shapr> He's made a wasteland of several channels.
15:05:41 <sjanssen> Cale: yeah.  I've though about writing some data structures with it and submitting them to Edison
15:05:57 <cjeris> sjanssen: that's a gruesome image... a tree festooned with bloody severed fingers
15:06:00 <dons> moin
15:06:18 <shapr> g'day dons
15:06:24 <dons> mm. edison should maybe be a core package eh?
15:06:30 <dons> hey shapr
15:06:42 <shapr> cjeris: people eat candy hearts for valentine's day, that's far weirder.
15:07:13 <sjanssen> dons: maybe, can't remember exactly what "core" means.  The thread on -libraries is far too long
15:07:46 <mgsloan> i think it was something like '#tfp' I visited it for a few days.  We talked about languages a bit, which was interesting.
15:08:06 <shapr> mgsloan: So how did he influence your decision to learn Haskell?
15:09:38 <mgsloan> well, haskell came up, and it sounded interesting, but it was mainly advocated by smerdy, someone I had already decided was an ass, so in my mind haskell became labeled as "the language for elitest asses"
15:10:59 <DebolazX> Ah, the human mind. :-)
15:12:02 <shapr> Yeah, I admit that I've never learned Common Lisp because of some of its rabid users.
15:12:32 <shapr> After talking to those particular users my thought was "With community like that, who needs enemies?"
15:12:36 <mgsloan> He was also big on the idea of only using a keyboard, something which is pretty unreasonable to me.  I figured that his choice of language and choice of input device were due to their trait of making the user feel '1337' in skills, because they can manage to use such a crappy system.
15:12:45 * shapr snickers
15:12:47 <mgsloan> heh
15:13:26 <shapr> I like to use only the keyboard as well, but that's just because it costs me 'switching time' to swap from touch typing with boths hands to mousing and then back.
15:13:40 <shapr> Has nothing to do with leetness :-)
15:13:48 <cjeris> shapr: i can understand and even empathize a bit with Common Lispers' bitterness, but that's not the same as wanting to listen to it...
15:13:49 <mgsloan> so basically I had negative respect for his opinions, so something he advocates comes off as being crappy
15:14:10 <shapr> cjeris: I think it's silly to be bitter.
15:14:13 <TSC> Even a village idiot is right some of the time (:
15:14:15 <shapr> If you have a good tool, use it.
15:14:41 <mgsloan> shapr - heh, yeah i suppose.  For intensive keyboard tasks that's certainly good, but he was saying like just using lynx and command prompt (no gui).  Actually yeah, most of his bitching was about guis
15:14:41 <SamB_XP> mgsloan: he didn't mention that he got banned from #haskell for being an elitist ass?
15:15:02 <shapr> I didn't switch to emacs because people advertised it to me, I switched because my Finnish friends could do amazing code tricks that my editor couldn't do.
15:15:08 <mgsloan> samb - no, though perhaps this was before he was banned (2-3 years ago)
15:15:15 <SamB_XP> could be
15:15:27 <shapr> mgsloan: Ok, that's just weird. I use firefox, but it does lots of keyboarding stuff.
15:15:36 <cjeris> shapr: it is silly, but perhaps natural that having one's good idea marginalized over time, for reasons that have little to do with its value as an idea, can turn one into a bitter ideologue
15:15:45 <SamB_XP> lynx is disgusting
15:16:01 <SamB_XP> and how do you ever manage to use the commandline without a zillion xterms?
15:16:05 <mgsloan> shapr - yeah.  I use my mouse mostly in firefox - side buttons for forward/back.  same switch time principle
15:16:33 <shapr> I use the "type part of a link" to jump to a link and then hit enter to choose that link.
15:16:42 <eviltwin_b> samb_xp: screen
15:16:52 <shapr> I do wish it supported C-v and M-v
15:17:03 <mgsloan> huh
15:17:10 <sjanssen> shapr: have you heard of Conkeror?
15:17:22 <shapr> Konq is the KDE browser, yeah?
15:17:27 <Masklinn> yeah
15:17:31 <cjeris> shapr: what's the key for 'type part of a link' ?
15:17:34 <mgsloan> one reason I don't like learning those crazy text editors is then it messes me up for doing stuff in messenger/firefox
15:17:38 <Masklinn> from which Safari was spawned
15:17:50 <SamB> eviltwin_b: oh, well, true
15:17:52 <eviltwin_b> (but I'm no anti-GUI type; I use screen more for when I can't use a gui, like on a low speed link)
15:18:05 <hmich> why does a relatively small program (around 200 lines of code) take up to 1.2 meg when compiled to native binary with ghc? Is there some kind of virtual machine stuffed in there that just interprets precompiled haskell bytecode?
15:18:07 <shapr> mgsloan: It's just a pref setting in firefox.
15:18:08 <sjanssen> shapr: this is Conkeror with a 'C', it's a interface modification to Firefox that emulates emacs
15:18:10 <SamB> I still need to learn a termnal-based IRC client
15:18:13 <LoganCapaldo> Conkeror, not to be confused with Konquoreror is emacs keybindings for ff
15:18:15 * eviltwin_b has more than once needed to log in to work machines over his cellphone.  ug
15:18:16 <shapr> sjanssen: Sounds nifty
15:18:27 * LoganCapaldo uses it in vi mode
15:18:46 <sjanssen> LoganCapaldo: oh?  I started learning it but then got lazy
15:18:47 <SamB> and figure out how to get things to all work together in terms of things like "Home" and "End"...
15:18:52 <Cale> hmich: not quite, but there is a lot of runtime stuff -- the libraries you use are statically linked into your binary
15:19:00 <shapr> mgsloan: Have I seen your name in the Python community?
15:19:06 <sjanssen> the learning curve is annoying when you just want to browse the internet
15:19:10 <LoganCapaldo> sjanssen: I cheat. I only use it on the laptop
15:19:23 <LoganCapaldo> (IOW, I'm not using it right now)
15:19:35 <shapr> cjeris: It's just a pref setting in firefox
15:19:37 <LoganCapaldo> Mostly because I hate the freaking touchpad thing
15:19:41 <SamB> Cale: where *is* the bytecode interpreter?
15:19:57 <mgsloan> shapr - I don't think so.  I've used it a bit, but not participated communally :P near all the google results (except mgsloan.com, hah) are me
15:20:20 <Masklinn> SamB > Why would there be one?
15:20:43 <fincher> I think I would like Haskell much better if Haskell programmers didn't insist on using so many darn operators instead of functions.
15:20:56 <shapr> aha, jemfinch returns
15:21:01 <Cale> SamB: that would be yhi?
15:21:07 <fincher> (personally, I find this paper on Deques much harder to read with all the operators)
15:21:12 <fincher> shapr: just had a few monadic questions :)
15:21:13 <Cale> fincher: like what?
15:21:15 <Masklinn> aren't operators just functions with fewer characters and infix syntax?
15:21:17 <Cale> >>= ?
15:21:41 <Cale> < ?
15:21:42 <mgsloan> for some reason all the crappy google results for "mgsloan" are listed first - like blog comments and registrations to sites i don't even care about
15:21:57 <hmich> Cale: but I don't think that i use many libraries - there are only several imports. And then how does it handle non-exhaustive patterns?
15:22:00 <Cale> which operator use is excessive?
15:22:06 <SamB_XP> Masklinn: if by fewer characters, you mean that you don't have to type the `` around their names...
15:22:42 <SamB_XP> @google mgsloan
15:22:45 <Masklinn> SamB > no, I mean that operators are usually 1-3 characters while fuctions are often many more.
15:22:45 <lambdabot> http://wiki.mozilla.org/User:Mgsloan/URL_Box
15:22:46 <lambdabot> Title: User:Mgsloan/URL Box - MozillaWiki
15:22:58 <syntaxfree> is the Community and Activities Report composed in LaTeX?
15:23:00 <hmich> Cale: it seems that the programs finds determines these patterns in runtime
15:23:00 <Cale> hmich: Well, there is a runtime, but the code which is running is native code, it just operates in a somewhat odd way :)
15:23:07 <shapr> syntaxfree: yes
15:23:11 <Masklinn> Plus if you want to use operators as regular functions (with prefix syntax) you have to add 2 characters
15:23:25 <hmich> Cale: i see
15:23:30 <syntaxfree> what is that nice stylesheet with the nice subtitles font?
15:23:44 <Cale> If you'd like to know about how it works, there's a great paper on it
15:23:58 <Cale> @google Spineless Tagless G-machine
15:24:00 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
15:24:04 <Cale> that one
15:24:20 <hmich> Cale: thanks
15:24:34 <Cale> (If you're unfamiliar with citeseer, the link to the paper itself is in the top right corner :)
15:26:03 <hmich> Cale: no, i'm familiar with it =) first place to search for some nice article
15:27:02 * mgsloan <3 citeseer
15:27:39 <hmich> Cale: so haskell compiler implements some kind of abstract machine like the one described in this article?
15:27:45 <Cale> yeah
15:27:55 <mgsloan> took me a while to find the dl links after getting it in google a bunch though...
15:28:09 <mgsloan> I figured it was some sort of metadata for data not available online or something
15:28:28 <Cale> yeah, I always have to make sure to point out to people where the link is
15:28:49 <Cale> Nobody actually looks there the first time around
15:29:05 <pejo> (scholar.google.com is great for finding papers too, and the link there is easier to find).
15:30:17 <syntaxfree> d-oh. I'm about the only person to mention his nickname on the Report.
15:31:00 <Cale> The Haskell' report?
15:31:08 <hmich> scholar.google.com will most likely lead you to something like portal.acm.com where you need a subscription to download an article
15:31:12 <syntaxfree> heh. I wish.
15:31:13 <syntaxfree> No, no.
15:31:19 <syntaxfree> the HCAR.
15:31:23 <Cale> ah
15:31:36 <syntaxfree> I'm just an economist.
15:31:41 <syntaxfree> I ain't one of the smart guys, no :)
15:32:21 * shapr isn't either!
15:32:56 <monochrom> I am cute and wise.
15:33:08 <shapr> monochrom: Hey, I want to talk to you more about laziness as self-modifying code.
15:33:29 <shapr> Though right now I have to go to the store...
15:33:38 <syntaxfree> @karma shapr
15:33:39 <lambdabot> shapr has a karma of 30
15:33:42 <syntaxfree> @karma syntaxfree
15:33:42 <lambdabot> You have a karma of 1
15:33:54 <syntaxfree> You're better off ;)
15:34:03 <monochrom> I think "@google Spineless Tagless G-machine" will do wonder on that subject.
15:34:31 <fincher> Masklinn: Operators are functions with less memorable names.
15:34:53 <fincher> Masklinn: the fact that so many operators have to be accompanied with mnemonic descriptions is excellent evidence of that fact :)
15:35:07 <Cale> fincher: which operators do you feel are excessive?
15:35:11 <syntaxfree> I'd'say, operators are functions.
15:35:26 <shapr> fincher: I've seen just as many functions that need descriptions.
15:35:29 * syntaxfree 'd like a specific operator for "compare'.
15:35:35 <fincher> Cale: in the paper I'm reading, -< and >-
15:35:38 <monochrom> functions are operators.  I am not making it up.  Landin said that.
15:35:38 <syntaxfree> maybe ><
15:35:44 <fincher> but I'm having dinner, I'll catch up on my reading when I get done :)
15:35:46 <shapr> syntaxfree: I did start #haskell, but I still haven't had any CS or math classes.
15:35:49 <Cale> fincher: The finger trees paper?
15:35:54 <fincher> yup
15:35:54 <LoganCapaldo> what, not <=>?
15:35:56 <Masklinn> syntaxfree how about <=>?
15:35:57 <syntaxfree> shapr: oh.
15:36:11 <syntaxfree> <=> for "if and only if" in a formal inference system.
15:36:25 <syntaxfree> maybe >=<
15:36:38 <shapr> syntaxfree: That's one reason I get irritated at people who say that Haskell requires a PhD in FP and/or math.
15:36:39 <syntaxfree> but >< is closer to the one found in some calculators.
15:36:43 <twanvl> =?=
15:36:54 <syntaxfree> shapr: I don't. I feel flattered ;)
15:36:56 <Cale> fincher: they're actually used as parameters there, so you don't even need to remember what they mean
15:37:00 <syntaxfree> twanvl's good.
15:37:05 <syntaxfree> >?<
15:37:10 <shapr> syntaxfree: heh!
15:37:15 <shapr> syntaxfree: good attitude!
15:37:25 <Cale> fincher: it just lets them write the function definitions more simply -- trees are much prettier when you use an infix operator to build them
15:37:31 <syntaxfree> shapr: I can even grok (some of) the bananas stuff.
15:37:46 <syntaxfree> I'm hopeful that I can find an application in my field.
15:37:56 <monochrom> It is intriguing that people outside our circle make a big distinction between operators and functions.  "functions must be in English, operators must be in symbols"  (So what about Chinese characters?)
15:38:41 <eviltwin_b> it does make lexing easier...
15:38:55 <LoganCapaldo> monochrom: what about lisp?
15:38:56 <monochrom> Yes.
15:39:06 <LoganCapaldo> Operators? What operators?
15:39:07 <monochrom> OK, some people, not all people.
15:39:25 <Cale> I suppose when you're in mathematics, the distinction between various notations for functions starts to matter a whole lot less.
15:39:30 <syntaxfree> monochrom: maybe it's that most people here have had Lisp experience.
15:39:32 <Excedrin> is there a distinction between functions and actions?
15:39:51 <syntaxfree> Cale: generally, operators arise in an algebraic context and functions in an analytic one.
15:40:13 <Cale> That's sort of kinda true.
15:40:26 <syntaxfree> At least up to the maths level I've taken.
15:40:26 <Cale> There are plenty of infix operators used in analysis too though.
15:40:35 <Cale> and plenty of plain-looking functions in algebra
15:40:42 <syntaxfree> well, true, but they're not a central study object.
15:40:46 <Cale> (think about homomorphisms)
15:40:54 <monochrom> Quickly you learn in math that the algebraic operator + is analytically a C^oo function in both arguments.
15:40:59 <syntaxfree> yes, in algebra that's more true than in analysis.
15:41:09 <Cale> homomorphisms are certainly a central object of study :)
15:41:28 <syntaxfree> well, yes, but "+" is not a central object of study in analysis.
15:41:41 <syntaxfree> I really have more experience with analysis than algebra. Remember, I'm an economist.
15:41:48 <Cale> Well...
15:41:48 <syntaxfree> Economists do it with models :-P
15:41:55 <monochrom> My point is the math people has two words but they aren't as anal as many programmers on this.
15:42:11 <Cale> There are a lot of topological Abelian groups which might be important to analysts.
15:42:32 <syntaxfree> okay, okay :)
15:42:53 <Cale> Well, technically, all that the word "operator" means to a mathematician is that the domain of the function is a Cartesian power of its codomain.
15:43:07 <Cale> (or occasionally, that it's a subset of that)
15:43:33 <dons> sjanssen++ patches
15:43:34 <Cale> So it's not even a notational thing
15:43:35 <syntaxfree> I really think Haskellers not overstating the  functions-operator distinction has more to do with Lisp experience than mathematics.
15:43:48 <syntaxfree> How many people here arrived to Haskell without ever touching Lisp or Scheme?
15:43:49 <mgsloan> > (+) foldl' 0 [0..10]
15:43:49 <lambdabot>  Couldn't match `a -> b -> a' against `[a1]'
15:43:59 <cjeris> Cale: except to functional analysts, where it means it's a linear map :)
15:44:00 <mgsloan> > (+) `foldl` 0 [0..10]
15:44:01 <lambdabot>  add an instance declaration for (Num ([a] -> b))
15:44:17 <pejo> syntaxfree, I did.
15:44:21 <Cale> cjeris: a linear operator is a linear map T: V -> V
15:44:29 <mgsloan> syntaxfree - I have
15:44:29 <monochrom> Yes, few of us did math, most of us did lisp.
15:44:57 <cjeris> Cale: iirc Dunford & Schwartz don't impose such a restriction, but it doesn't matter.
15:44:57 <dons> kosmikus++ HCAR is out
15:45:08 <mgsloan> and I'm only in a semester of calculus, though I know more math 'above' it
15:45:31 <syntaxfree> I think I might have used Haskell once before taking the scheme course, but I did little more than verify that [1,2,3,4] == 1:2:3:4:[]
15:45:35 <mgsloan> > ((+) `foldl` 0) [0..10]
15:45:36 <lambdabot>  55
15:45:43 <syntaxfree> "used Haskell" == tried Hugs.
15:46:03 <syntaxfree> kosmikus is the guy behind HCAR?
15:46:10 <dons> yep
15:46:14 <monochrom> "used Haskell for sale!"
15:46:36 <syntaxfree> monochrom: @google confessions of an used programming language salesman
15:46:53 <Cale> @google confessions of an used programming language salesman
15:46:54 <syntaxfree> \bot didn't pick that.
15:46:56 <lambdabot> http://research.microsoft.com/~emeijer/Papers/ICFP06.pdf
15:47:13 <monochrom> somehow I think I have seen that before..
15:47:31 <syntaxfree> it's the Linq sales pitch for Haskellers.
15:47:42 <syntaxfree> There's a Linq sales pitch for VBers elsewhere.
15:48:56 <dibblego> trying to install HAppS; do I need regex-compat for GHC 6.4.1?
15:49:45 <dons> mod up! :) --> http://programming.reddit.com/info/t5sy/details
15:49:47 <monochrom> Nice, I need to know Linq.
15:49:48 <lambdabot> Title: Haskell community and projects report out now! (reddit.com), http://tinyurl.com/yhraf2
15:50:00 <emu> STM kicks ass
15:50:07 <syntaxfree> From what I've understood, Linq is basically monadic comprehensions for Visual Basic.
15:50:21 <syntaxfree> yay!
15:50:30 <syntaxfree> its on reddit. And I'm quoted on it ;)
15:50:54 <syntaxfree> it's a shame I look like a dork mentioning my irc nickname, but it's still fun that something Haskell-related mentions me,
15:51:18 <Cale> I wish more people in the report mentioned their IRC nicks.
15:51:43 <monochrom> This is the longest abstract I have ever seen!
15:51:48 <dons> yeah. we should ask kosmikus to add that
15:52:07 <syntaxfree> I don't understand what's technically innovative about Reddit.
15:52:27 <syntaxfree> I know it's Paul Graham-funded, but why did he choose to fund a Digg clone and why is it growing so fast?
15:53:00 <syntaxfree> It seems to me quite inferior to Digg in features, though it has nicer links and a nicer community.
15:53:00 <monochrom> Of course the innovation is always in the sociology not in the technology.
15:53:05 <dons> its got less crap that digg, its lighter, more PL stories :)
15:53:20 <dons> its all about the community, as usual
15:53:31 <monochrom> Technically it's just a computer program.
15:53:39 <SamB_XP> yeah
15:53:44 <SamB_XP> well.
15:53:50 <syntaxfree> it's growing very fast, fast enough that the community should turn to crap at some point.
15:53:59 <dons> monochrom: whoa there... don't get technical on us!
15:54:16 <SamB_XP> actually I'd say it is a computer program, some data, and a bunch of relationships between people and ideas and things like that
15:54:28 <Cale> we should make an effort to mod down almost anything about business, and flood the thing with references to technical papers :)
15:54:28 <dons> syntaxfree: not if we keep the lisp and haskell stories high .. that should drive away lots of people :)
15:54:37 <dons> Cale: agreed.
15:54:57 <kpreid> naah
15:55:00 <monochrom> Game theory is a more suitable framework for studying these successes and failures.
15:55:06 <SamB_XP> monochrom: indeed!
15:55:08 <syntaxfree> already one gets some "Britney Spears without panties" links in the main reddit.
15:55:18 <SamB_XP> but conversation theory would probably work even better
15:55:21 <kpreid> don't mod down the business stuff, you'll drive away people who should be exposed to good ideas :-)
15:55:22 <LoganCapaldo> What?
15:55:24 <syntaxfree> monochrom: curiously enough, I have a big exam in theoretical game theory next week.
15:55:29 * LoganCapaldo goes to main reddit page
15:55:31 <syntaxfree> I've been studying for it all day.
15:55:32 <kpreid> (note: I don't use reddit)
15:55:37 <dibblego> is it even possible to use HAppS with GHC 6.4.1? I have dependency dissatisfaction - wants base >= 2.0
15:55:48 <SamB_XP> hmm
15:55:50 <SamB_XP> lazy backup
15:55:52 <Cale> I'm also actually kind of annoyed when I go there and see things where the only connection to programming is that the project itself happens to be open source.
15:55:59 <monochrom> (Of course it will take another 100 years for game theory to develop enough machinery to model communities.  But when it's done, it's still game theory, i.e., what rules you impose on your web site leads to what results.)
15:56:01 <SamB_XP> is that where you wait until after you have lost your data to back it up?
15:56:15 <dons> dibblego: I'm not sure its possible to use the new HAppS. ask alexj when he turns up -- or shapr
15:56:21 <dibblego> ok ta
15:57:18 <syntaxfree> reddit has pretty much no rules. It's a lot of moderation imposed from above.
15:57:39 <syntaxfree> It's a tad less discretionary than Slashdot, but a lot more than k5 or digg.
15:57:47 <monochrom> The rule of letting readers mod up or down things is an interesting new rule.
15:57:59 <SamB_XP> monochrom: it isn't just what rules, though
15:58:12 <SamB_XP> it is also what reputation the website has, who you invite to it, etc.
15:58:29 <monochrom> "who you invite to it" becomes part of the rules in game theory.
15:58:51 <syntaxfree> it'd be easier to model if it was invite-only.
15:59:11 <monochrom> reputation is both rule and result.  You have a self-referencing equation.
15:59:12 <syntaxfree> OTOH, invite-only communities sometimes become a big back-patting festival.
15:59:43 <syntaxfree> I used to be on Brainstorms, and everyone was so preoccupied being nice to others discussion was never interesting.
15:59:47 <Cale> I should write a program which automatically mods down any article containing the word "Agile"
16:00:06 * dibblego votes Cale's comment to go into the quotes collection
16:00:28 <monochrom> @remember Cale I should write a program which automatically mods down any article containing the word "Agile"
16:01:58 <dons> EHC has uniqueness typing ...
16:02:00 <dons> cool!
16:02:14 <emu> i saw that
16:02:25 <dons> they should put the src in darcs.
16:02:31 <emu> hmm, yes, we should post all sorts of academic papers to reddit since ltu is dying..
16:02:47 <Philippa> yeah, that'd be a great way to ensure LtU does die
16:02:51 <monochrom> ...
16:03:04 <syntaxfree> reddit doesn't quite seem like the medium for academic papers.
16:03:15 <dons> yeah, its got a bit of an anti-pdf vibe
16:03:25 <dons> but an LtU that was as easy to submit to as reddit....
16:03:27 <syntaxfree> I don't like LtU, though. The /. style only works for /. and k5.
16:03:27 <emu> maybe they'd prefer PS
16:03:35 <dons> LtU with its editor control stuff. urgh
16:03:44 <hyrax42> is this report biannual?
16:03:47 <dons> yep
16:03:57 <hyrax42> ok I was a bit confused
16:03:59 <monochrom> Why not sign up as an LtU editor?
16:04:11 <hyrax42> since I have only been doing haskell stuff for 6 months or so, but remember the last report
16:04:30 <syntaxfree> Reddit/del.icio.us/Digg are much easier to read with its long-list-of-links style.
16:04:48 <syntaxfree> Posting entries to /.-style sites requires writing a summary, too.
16:04:52 <Philippa> I wouldn't read as much with that style though
16:05:09 <monochrom> I require writing a summary.
16:05:46 <syntaxfree> well, I'm just stating what draws me in or away from a website.
16:06:26 <monochrom> I guess I'm old and obsolete.
16:07:31 <syntaxfree> I wish there was a reddit-like site for CFPs.
16:07:43 <syntaxfree> There's simply no good way to scoop for CFPs in my field.
16:07:50 <LoganCapaldo> CFPs?
16:07:56 <syntaxfree> EventSeer is CS and SE-oriented, mostly.
16:08:01 <syntaxfree> call for papers.
16:08:07 <dons> syntaxfree: so like we do with haskell@ taking all the haskell related conf announces?
16:08:52 <syntaxfree> dons: I mean something that concentrated different academic communities.
16:09:01 <dons> ah
16:09:10 * syntaxfree 's field is industrial economics.
16:10:28 <dons> mmm. do I see a newbie asking for @pl on the mailing list... ? :)
16:10:41 <eviltwin_b> yep
16:10:41 <syntaxfree> ;)
16:10:52 <syntaxfree> we should post the HCAR to /.
16:10:56 <dons> hehe
16:11:01 <syntaxfree> I mean, a lot of people.
16:14:23 <monochrom> scary.  the haskell community is out to get you!
16:14:38 <dons> monochrom: ?
16:15:00 <monochrom> the haskell community is out to post to reddit, slashdot, everywhere...
16:15:16 <dons> hehe.
16:16:01 <monochrom> I think in time we will surpass Python and contend Perl.
16:17:06 <dons> monochrom: in what sense?
16:17:13 <dons> community visibility?
16:17:16 <monochrom> in mind share
16:17:45 <dons> maybe. we have magic monads to hook people, and help differentiate us from the rest of FP
16:18:10 <dons> it helps there's a lot of successful authors in the community
16:18:19 <dons> so there's a good stream of new material being written daily
16:18:48 * monochrom writes a paper "The Unreasonable Effectiveness of Haskell"
16:18:58 <dons> and of course, having most of the fun new programming language technologies rocks
16:19:09 <dons> since everyone else has to play catch up
16:20:11 <Botje> monads have to be the singly most tutorialized feature _EVER_
16:20:17 <monochrom> "Why would such a mathematical, abstract tool attract so many popular science authors who do not explain the tool in its mathematical, abstract term?"
16:20:20 <dons> you want SMP+STM, GADTs, arrows, .... sorry, you'll need haskell. that's a good thing
16:21:01 <lispy> Botje: check the stats, it's also a very popular word here
16:21:04 <lispy> ?where stats
16:21:04 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
16:21:54 <syntaxfree> <p>The 11th <a href="http://www.haskell.org/community">Haskell Community and Activities Report</a> has been released this November 30th. From the overview: <i>The Haskell Communities and Activities Report was initiated at the 2001 Haskell workshop, as a status report of the Haskell community as a whole, to be updated twice a year. The purpose is twofold: (a) to establish what communities, people and projects are out there, working with or on Haskell,
16:21:54 <syntaxfree> oops. didn't mean to paste that here :(
16:21:59 <dons> so even if C++ and Java get closures, or C# gets comprehensions, that's still technology from the 80s or earlier. all the fun stuff is still beyond their reach
16:22:23 <syntaxfree> C# will have monad comprehensions, which we don't have.
16:22:33 <dons> syntaxfree: there's not true monad comprehensions though
16:22:36 <Botje> lispy: with reason. every non-trivial problem has several solutions, of which at least half involve monads in some way.
16:22:45 <dons> Cale's look into it. you get list comprehensions, with special syntax, iirc
16:22:58 <dons> Cale, and you can't declare new monads, is that right?
16:23:16 <monochrom> Perhaps Phil Wadler started the ball rolling.  He explained Haskell a bit more concretely than before.  From then on, heh, you can say "it went downhill".  Every generation of Haskell programmers explains it a bit more concretely than before.  Eventually it's concrete enough for a critical mass.
16:23:28 <Cale> dons: hm?
16:23:34 <Deformative> What was haskell written in before they wrote it in itself?  C? or asm?
16:23:41 <dons> Cale: remember we talked about C#'s comprehensions?
16:23:44 <syntaxfree> Haskell?
16:23:51 <syntaxfree> you mean GHC?
16:23:51 <dons> and you pointed out they aren't terribly general purpose?
16:24:02 <dons> Deformative: miranda
16:24:06 <Deformative> Ye sI do syntaxfree.
16:24:07 <dons> and lisp
16:24:09 <SamB> Lazy ML!
16:24:11 <dons> (depending on which version you look at)
16:24:13 <dons> and Lazy ML!
16:24:28 <Cale> LINQ is similar to list comprehensions together with a good part of the Haskell list library, but the cool part is that they're translated into various other query languages.
16:24:31 <Deformative> Hmm,  interesting.
16:24:35 <SamB> right now it is written in Haskell and in C
16:24:44 <Deformative> A language can not run more efficiantly than the language it is written in,  correct?
16:24:44 <SamB> for some reason hugs is written in C
16:24:50 <Cale> So a LINQ query is translated into SQL when interfacing with a real database server.
16:24:53 <dons> Deformative: there's no reason to assume that
16:24:57 <syntaxfree> dons: wait, GHC was bootstrapped from Miranda?
16:25:07 <dons> Deformative: its a kind of meaningless statement :)
16:25:17 <Cale> But on the language side of things, there's not much interesting to Haskell programmers -- it's the backends where all the cool bits are.
16:25:23 <dons> syntaxfree: I *think* the first GHC was written in Miranda.. but I've not got a reference for that
16:25:28 <syntaxfree> Anyway, I've submitted a link to the HCAR to Slashdot.
16:25:30 <Deformative> dons,  well doesn't it bump it down to the lower level language untill it reaches binary?
16:25:44 <SamB> well, what is "faster"
16:25:53 <dons> Deformative: so Haskell programs compiled via C sometimes beat C programs. so I'm not sure what it tells you :)
16:25:58 <SamB> when applied to two very different languages?:
16:26:13 <dons> other than that sometimes a compiler for a high level language can produce low level code optimised in ways the low level compiler wouldn't attempt
16:26:21 <SamB> (especially considering it is more usefully applied to compilers)
16:26:41 <SamB> dons: well, you could write the code that way!
16:26:51 <dons> right. so you could write your C programs in .hc form
16:27:08 <SamB> oh, well, not quite...
16:27:23 <Deformative> Hmm,  I find that odd, and interesting at the same time,  /me shrugs.
16:27:49 <SamB> but I meant you could do the same sorts of optimizations
16:27:57 <kpreid> Deformative: In the case of a *compiler*, the implementation language of the compiler doesn't matter; the target language of the compiler does.
16:27:59 <SamB> if you didn't care about ever changing your program again
16:28:02 <dons> Deformative: basicaly, at a higher level of abstraction, you can do optimisations you can't do on the lower level representation. i.e. string fusion or reordering of pure computations
16:28:21 <kpreid> In the case of an interpreter, it's closer to being true, but see what dons just said
16:28:28 <LoganCapaldo> Deformative: It doesn't have to "bump it down". Machine code is just bytes. You could go straight from Haskell to generating machine code with a Haskell compiler written in /bin/sh
16:28:28 <SamB> well, JIT!
16:28:29 <newsham> there is information that the programmer has that is not conveyed to the compiler and the compiler cant easily recover
16:28:31 <dons> so sometimes a higher level language compiler will proudce C code for a problem better than you could write if you wrote the C manually
16:28:33 <SamB> too.
16:28:42 <SamB> and what the hell is an interpreter anyway?
16:28:58 <SamB> I've never seen anything that doesn't use some sort of an IR
16:28:58 * monochrom is petrified.  Haskell compiler written in /bin/sh ?!
16:29:01 <SamB> afaik
16:29:16 <newsham> (also for historic reasons most C compilers dont optimize "galactically" between compilation units)
16:29:17 <LoganCapaldo> It was just an example ;)
16:29:45 <LoganCapaldo> Doesn't MLton optimize "galatically"?
16:29:52 <kpreid> SamB: you've never seen a trivial lisp interpreter?
16:30:00 <monochrom> I have written an interpreter for "1+2+3" in Parsec without much IR.
16:30:13 <SamB> kpreid: they interpret lists
16:30:13 <newsham> JIT can do some interesting optimizations because they can detect some optimization opportuinties that are hard or impossible to detect statically
16:30:16 <monochrom> But of course it's dumb. :)
16:30:17 <SamB> not files
16:30:20 <Deformative> I think it's cool that the haskell compiler is written in more than one language,  well,  I think it is based on what I saw earlier.
16:30:39 <kpreid> SamB: In my opinion, that's a silly distinction.
16:30:39 <SamB> well, perhaps command.com does not in fact use an IR
16:31:21 <SamB> I believe I've heard that it reopens the file every line
16:31:25 <kpreid> SamB: I have a (almost-)Haskell interpreter that operates on Language.Haskell.Syntax trees. How do you feel about that?
16:31:29 <monochrom> Yeah, it is not an important distinction.  Try drawing a line between operators and functions instead. :)
16:32:00 <kpreid> I wouldn't call something an IR until it is structurally different from the program source as understood by humans.
16:32:41 <dons> so is anyone here going to HAL?
16:33:01 <dons> I'd be interested in getting a write up (with credit, of course!) http://www.iba-cg.de/haskell.html
16:33:03 <lambdabot> Title: ||: iba Consulting Gesellschaft - intelligent business architecture:||
16:33:16 <dons> mm, maybe these guys should be on the industry page too..
16:33:46 <dons> dibblego: have you seen these guys? do you know what haskell work they do?
16:33:59 <dibblego> never heard of them
16:34:19 <SamB> kpreid: hmm, does it handle precedence?
16:34:33 <kpreid> Language.Haskell.Parser.
16:34:43 <dons> dibblego: might be worth checking out what they're doing
16:34:47 <SamB> I bet it doesn't handle precedence
16:34:54 <SamB> how *can* it handle precedence?
16:34:58 <dibblego> yeah, my German is a bit rusty :)
16:35:01 <dons> hehe
16:35:02 <kpreid> oh, I see
16:35:18 <SamB> it doesn't know what the precedences *are*
16:36:01 <kpreid> "The parser does not take precedence and associativity into account, so it will leave HsInfixApps associated to the left."
16:36:04 <kpreid> hmf
16:36:17 <kpreid> OK, I didn't know that
16:36:36 <kpreid> I hereby claim it's an irrelevant detail to my point :)
16:36:59 <dons> kpreid: well you can easily rewrite the tree yourself. i think that's the usual idea
16:37:08 <user317> why cant i import control.monad.cont?
16:37:13 <kpreid> maybe you can't draw any sharp line between parsing and compilation, but it's still useful to distinguish the tasks
16:37:28 <dons> user317, import Control.Monad.Cont
16:37:33 <dons> as long as you have the 'mtl' package installed
16:37:43 <dons> user317: (its in the 'extra-libs' library bundle)
16:37:49 <kpreid> user317: either you need -package mtl, or to spell it Control.Monad.Cont.
16:38:05 <user317> oh i see
16:38:06 <user317> thanks
16:38:56 <mjl69> ##c
16:38:57 <dons> ?users
16:38:58 <lambdabot> Maximum users seen in #haskell: 276, currently: 243 (88.0%), active: 44 (18.1%)
16:39:03 <mjl69> oh
16:39:04 <dons> mjl69: wrong chan.
16:39:16 <dons> welcome though, have a lambda:
16:39:20 <dons> > (\x -> x) 2
16:39:21 <lambdabot>  2
16:39:23 <mjl69> wrong tab.  sorry
16:39:29 <dibblego> why would `which ghc` and ghc give 6.6 and 6.4.1 respectively? it's got me stumped
16:39:58 <monochrom> start a new shell and try again
16:40:04 <user317> hmm, some reason i don't have mlt installed
16:40:10 <mjl69> I just use ##c to keep the connection alive.
16:40:11 <newsham> > d f = f.f in d (\x -> x) 2
16:40:11 <lambdabot>  Parse error
16:40:15 <dons> user317: yeah, its in the extra-libs bundle
16:40:16 <dibblego> ah that did it - still stumps me
16:40:27 <dons> user317: so you need to install that package separately with ghc 6.6
16:40:39 <newsham> > let d f = f.f in d (\x -> x) 2
16:40:41 <lambdabot>  2
16:40:53 <monochrom> the old shell had its hash of locations of executables on the PATH not updated.  try something like "rehash" at the old shell.
16:41:26 <dons> mmm blogs are fun: "So this extremely strongly typed language suddenly becomes
16:41:26 <dons> capable of ignoring types much like perl and friends, while still enforcing them completely rigidly
16:41:29 <dons> (so that you can't make a 'mistake' like trying to add an integer to a string). It's hard to
16:41:32 <dons> explain."
16:41:57 <dons> monochrom: re. mindshare ^^ we've got some mindshare in blog land now I think
16:41:59 <monochrom> hehehehe
16:42:11 <wolverian> I still like implicit coercion, even after a year of haskell.
16:42:12 <dons> type inference is magic
16:42:45 <monochrom> people need enlightening
16:43:00 <monochrom> but it's ok, it's happening now.
16:43:19 <wolverian> (then again, a year ago I didn't like typing at all. I do now.)
16:43:25 <dibblego> why is it hard to explain?
16:43:25 <dons> hehe
16:43:25 <wolverian> (so, haskell++)
16:43:38 <dons> dibblego: its not :)
16:43:40 <dibblego> monochrom, the old shell is gone now :)
16:43:51 <user317> does anyone run gentoo, i cant seem to find an ebuild for the extra libs, is there one anywhere?
16:44:12 <eviltwin_b> csh: rehash; sh/ksh/zsh: hash -r
16:44:18 <protoscript> gentlemen, are any of you familiar with xemacs haskel--mode? I decided to torture myself by learning emacs and haskell at the same time (partially just to force myself to finally learn emacs)
16:44:19 <dons> user317: I don't think ghc 6.6 is in gentoo yet, is it?
16:44:27 <user317> dons, its in the haskell overlay
16:44:33 <protoscript> unfortunately,  haskell mode doesn't seem to be working very well
16:44:37 <dons> user317: ah ok. then the extra libs must be in there too
16:44:44 <user317> dons, but i dont see an ebuild for the 6.4.2 version either
16:44:45 <dons> user317: perhaps ask on #gentoo-haskell ?
16:45:04 <dons> user317: 6.4.2 doesn't have extra libs separate. they're all in one big package
16:45:10 <vincenz> Hiya dons
16:45:14 <user317> dons, oh ic
16:45:15 <dons> ?users #gentoo-haskell
16:45:15 <lambdabot> Maximum users seen in #gentoo-haskell: 20, currently: 15 (75.0%), active: 5 (33.3%)
16:45:24 <Excedrin> protoscript: what's wrong with haskell-mode?
16:45:25 <dons> hey vincenz
16:46:07 <protoscript> for one, it is not color-coding at all
16:46:13 <protoscript> i opened the sample fontlock file
16:46:21 <protoscript> and everything is black/white
16:46:33 <LoganCapaldo> protoscript: you need to enable or set font-lock or whatever its called
16:46:41 <LoganCapaldo> (if you didn't do that)
16:46:42 <eviltwin_b> M-x font-lock-mode
16:46:45 <protoscript> I didn't
16:46:50 <protoscript> thanks
16:47:34 <protoscript> More nonsense: Symbols function definition is void: charsetp
16:47:41 <protoscript> maybe because I am using xemacs/windows
16:47:45 <protoscript> :-/
16:48:11 <Excedrin> charsetp is missing from xemacs
16:48:17 <Cale> hmm, how do you include < in some code in reddit without it turning into an explicit &lt; ? It seems they wrap things in <pre> but also do character translation inside that.
16:48:37 <Excedrin> add "(defun charsetp (x) nil)" to your .xemacs init.el
16:48:45 * vincenz needs a hug
16:49:17 <protoscript> excedring: thanks, I will see if I can find that and let you know how it goes
16:49:29 <vincenz> dons? Cale?
16:49:33 * protoscript hugs vincenz
16:49:36 <vincenz> :)
16:49:37 <protoscript> there there
16:49:41 <vincenz> Thank you
16:49:45 <protoscript> np
16:49:46 <Cale> what happened?
16:49:52 <vincenz> Working on a paper for the whole week, I'm spent
16:49:57 <vincenz> and some crappy stuf resurfaced from my memory
16:50:31 <Cale> http://programming.reddit.com/info/t5n0/comments -- hehe
16:50:35 <lambdabot> Title: Morse Encoder (reddit.com), http://tinyurl.com/y8qnrj
16:50:50 <vincenz> :)
16:50:52 * vincenz hugs Cale 
16:50:59 <Cale> aww
16:51:08 <vincenz> Shush
16:51:14 <Cale> heh
16:51:17 <vincenz> Or you're not on the lazy bottoms team as consultant
16:52:02 <mgsloan> hmm, does anyone know if anyone has worked on low level functional? eg, core stuff (and perhaps speed sensitive stuff) written with like a Mem monad, or with some builtin low level semantics?
16:52:02 <dons> Cale: nice!
16:52:06 <vincenz> Anyways, my paper is almost finished, so that's a good thing
16:52:16 <dons> mgsloan: mm. there's ANF
16:52:29 <dons> (which is practically functional asm)
16:52:29 <vincenz> dons: or GHC's extension of ANF
16:52:36 <dons> right
16:52:42 <vincenz> dons: yeah, there was a paper proving the equivalence between ANF and SSA
16:52:43 <vincenz> :)
16:53:13 <mgsloan> oh, interesting, thanks
16:53:37 <vincenz> "compiling with continuations" is the title
16:53:39 <vincenz> forgot the author
16:54:03 <dons> here, also, http://www.cse.unsw.edu.au/~chak/papers/CKZ03.html
16:54:04 <lambdabot> Title: Research Papers of Manuel Chakravarty, http://tinyurl.com/y6ut2s
16:54:06 <dons> that books is by Appel
16:54:12 <vincenz> rght
16:54:23 <mgsloan> dons - yeah, that's the paper i got to with a google
16:54:25 <monochrom> yeah, the continuation advocate has to be Appel :)
16:54:31 <dons> Cale: have you seen remorese?
16:54:36 <Cale> yeah
16:54:58 <monochrom> If you come across "monads are fun!" it's probably Wadler.  If you come across "continuations are fun!" it's probably Appel. :)
16:55:24 <dons> heh
16:55:28 <dons> quoted!
16:55:38 <protoscript> wow Excedrin, you effing rock
16:55:40 <dons> ?remember monochrom If you come across "monads are fun!" it's probably Wadler.  If you come across "continuations are fun!" it's probably Appel.
16:56:00 <protoscript> that worked
16:56:04 <kfish> > map fun ["monads", "continuations"]
16:56:05 <lambdabot>  Not in scope: `fun'
16:56:09 <dons> heh
16:56:12 <lispy> haha
16:56:18 <lispy> clasic
16:56:30 <protoscript> now I have syntax highlighting for haskell, which is at least half the picture
16:56:53 <dons> maybe you have to supply your own fun, kfish :
16:56:55 <dons> > \fun -> > map fun ["monads", "continuations"]
16:56:56 <lambdabot>  Parse error
16:57:05 <kfish> heh
16:57:06 <dons> > \fun -> map fun ["monads", "continuations"]
16:57:07 <eviltwin_b> no comment :>
16:57:07 <lambdabot>  Add a type signature
16:57:11 <dons> hehe
16:57:29 * vincenz places a big red blink (yes you wonder how you can make blinking things that are not on the computer) sign on his forehead.
16:57:38 <emu> protoscript: have you loaded haskell-site-file and turned on the indent and doc features?
16:57:39 <vincenz> "GEEK"
16:57:45 <protoscript> no :-/
16:57:58 <protoscript> and i haven't figured out how to tie it to ghci
16:58:02 <vincenz> protoscript: Is your name at all refering to prototype-based OO?
16:58:04 <protoscript> i am a total newb with both
16:58:10 <protoscript> vincenz: yes
16:58:19 <dons> people are posting gmh articles now, to reddit. mm.
16:58:20 <protoscript> i am obsessed with prototype-based languages
16:58:24 <dons> http://programming.reddit.com/info/t5vi/comments
16:58:26 <lambdabot> Title: A tutorial on the expressiveness and universality of fold [PDF] (reddit.com), http://tinyurl.com/yc9k5p
16:58:52 <vincenz> protoscript: IO?
16:58:55 <vincenz> protoscript: Self?
16:59:04 <protoscript> i was planning to write one named protoscript, but then I found Io and between that and ruby, I was satisified enough to wait to learn more about other languages
16:59:16 * vincenz nods
16:59:21 <protoscript> http://www.iolanguage.com/about/samplecode/
16:59:23 <lisppaste2> emu pasted "haskell-mode configuration" at http://paste.lisp.org/display/31062
16:59:27 <lambdabot> Title: io - about - sample code
16:59:28 <vincenz> well prototype based is, to me, the ultimate of oo-basd coding
16:59:34 <vincenz> just like haskell is the extremum of FP
16:59:35 <protoscript> yes
16:59:36 <vincenz> though I have to admit
16:59:37 <vincenz> IO sucks
16:59:42 <vincenz> I don't like the way it deals with locals
16:59:47 <vincenz> well sucks is a big word
16:59:48 <vincenz> it's nice
16:59:52 <vincenz> but I don't like how it deals with locals
16:59:59 <vincenz> it's easy to make errors
16:59:59 <protoscript> i just like how malleable it is
17:00:04 <protoscript> the code is data stuff
17:00:08 <emu> protoscript: also i recommend checking out haskell-mode CVS, the release is old
17:00:09 <protoscript> yes it is odd
17:00:17 <protoscript> emu: ok. thanks
17:00:28 <protoscript> i will do that
17:00:48 <monochrom> I need data-is-code.
17:00:49 <protoscript> first i have to find haskell-site-file ;-)
17:01:00 <emu> protoscript: it's part of haskell-mode. see the thing i pasted.
17:01:14 <protoscript> ah missed that
17:02:28 <protoscript> emu: where do I put that code?
17:02:38 <emu> in your ~/.emacs
17:03:15 <dons> anyone at MIT know about this haskell project: http://shejun.blogspot.com/2006/11/meep-for-developers.html
17:03:17 <lambdabot> http://tinyurl.com/y72qqa
17:03:18 <dons> ?
17:03:53 <protoscript> emu: is .xemacs/init.el ok?
17:04:30 <emu> yes
17:04:45 <protoscript> ok cool. not usre if i even have a .emacs... is that the equivalent for xemavs?
17:04:49 <monochrom> I am not at MIT, but I can translate the Chinese. :)
17:04:50 <emu> what you just said
17:05:04 <emu> XEmacs is trying to be all funky and have their own initialization file
17:05:07 <protoscript> awesome. thanls so much
17:05:17 <eviltwin_b> it does help when you use both
17:05:23 <emu> certainly
17:05:29 <eviltwin_b> (not that I do; my init files have long caused fsfemacs to coredump...)
17:05:33 <emu> i haven't used XEmacs in years, so, I'm out of touch
17:05:53 <eviltwin_b> for some odd reason it's preferred around CMU :>
17:06:03 <emu> yes, they always had 'emacs' linked to xemacs
17:10:05 <monochrom> Meep is defined in http://ab-initio.mit.edu/wiki/index.php/Meep_Introduction
17:10:08 <lambdabot> Title: Meep Introduction - AbInitio, http://tinyurl.com/tbv9o
17:10:45 <protoscript> duh it's finite difference  time-domain
17:10:47 <protoscript> sheesh
17:11:09 <protoscript> ;)
17:12:54 <monochrom> I can say that to anything.
17:13:33 <dibblego> I have fps-0.8 and base (GHC 6.6) installed, which is stopping a lambdabot build -- is there any simple way to remove fps-0.8?
17:14:06 <monochrom> there is a way to hide a package
17:14:13 <dons> dibblego: ghc-pkg unregister fps
17:14:20 <dibblego> ah yes I remember
17:14:20 <dibblego> thanks
17:14:22 <lispy> hmm...why does that stop the build?
17:14:37 <dons> lispy: two Data.ByteStrings? (though supposedly that should be ok...)
17:14:44 <eviltwin_b> it's alreadyin base so ghc whines about finding two package matches
17:14:45 <dibblego> Could not find module `Data.ByteString.Char8':
17:14:46 <dibblego>       it was found in multiple packages: fps-0.8 base
17:14:58 <dons> and you're using the right .cabal file?
17:15:01 <dons> dibblego: the one for ghc 6.6?
17:15:05 <sjanssen> dibblego: you should not have fps installed with GHC 6.6
17:15:31 <lispy> i'm surprised you could build/install fps on ghc6.6, it failed the time i tried it :)
17:15:32 <dibblego> dons, yes
17:15:41 <dibblego> sjanssen, I know, but I had 6.4
17:15:57 <monochrom> Haha I love the way it says "could not find" instead of "could find too many"
17:16:10 * eviltwin_b was able to build it, then discovered it was in base and edited the packages database to remove it
17:16:21 <dons> heh
17:16:27 <dons> monochrom: mm. good point
17:16:34 <eviltwin_b> (and nuked the directory for it)
17:16:47 <dibblego> yeah it confused me at first
17:17:03 <dibblego> perhaps "could not resolve"
17:17:51 <monochrom> Haha now I have caused another patch submission to GHC.
17:18:10 <emu> ?pl \x n -> n + 1
17:18:10 <lambdabot> const (1 +)
17:18:20 <monochrom> Which leads to my karma raising a bit.
17:18:42 <monochrom> an announcement to the Haskell community of the patch
17:18:42 * shapr boings
17:18:53 <dibblego> hello shapr
17:18:54 <monochrom> a lot of kudos sent around
17:18:55 <protoscript> emu: so, if I want to automatically set font-lock-mode, can I put something in my init.el file? More generally, done "some-kinda-command" always (or usually?) map to a lisp function?
17:18:56 * lispy waves at shapr
17:18:58 <Nafai> Hey shapr
17:19:05 <syntaxfree> http://just-humour.blogspot.com/2006/11/programming-languages-are-like-women-by.html
17:19:07 <lambdabot> http://tinyurl.com/y6tq55
17:19:08 <Cale> hmm, points-free guards...
17:19:09 <emu> protoscript: globally, or just for haskellmode?
17:19:11 * vincenz boings shapr into the basketball basket
17:19:22 <monochrom> and a reddit post on this.  "GHC now says the right thing when there are duplicate modules!"
17:19:26 <protoscript> just for haskell mode i guess, or everything if that isn't possible
17:19:26 <shapr> hiya dibblego
17:19:38 <emu> protoscript: yes, all M-x commands are lisp functions ("interactive" ones)
17:19:43 <shapr> greetings Mistah Dagit
17:19:45 <monochrom> And then we all go mod that up.
17:19:47 <emu> protoscript: emacs in general is very easily programmable
17:19:53 <shapr> Nafai: y0 y0, are you learning Haskell?
17:20:06 <Nafai> shapr: Thinking about it
17:20:09 * shapr throws baskets at vincenz 
17:20:22 <dons> > map (^2) [1..] -- Nafai just do it! :)
17:20:23 <emu> protoscript: note the add-hook 'haskell-mode-hook lines?
17:20:23 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
17:20:34 <protoscript> yes
17:20:43 <emu> protoscript: just add one which calls 'font-lock-mode, i believe
17:20:45 <eviltwin_b> add (font-lock-modd 1) to the haskell-mode-hook, or or global try (global-font-lock-mode t)
17:20:48 <Nafai> dons: Heh :)
17:20:53 <shapr> Nafai: It's worth it
17:20:53 <shapr> Nafai: Hey, I have a job writing Haskell now.
17:20:57 <eviltwin_b> er, (font-lock-mode 1)
17:20:59 <emu> might be better off with waht eviltwin suggested
17:21:10 <Nafai> shapr: Awesome, better than my job writing Java
17:21:11 <emu> (add-hook 'haskell-mode-hook (lambda () (font-lock-mode 1)))
17:21:15 <protoscript> thanks os much gents
17:21:41 <eviltwin_b> another quote on the (lambda ...), no?
17:21:44 <protoscript> emu: that's awesome
17:21:46 <emu> not necessary
17:21:50 <shapr> Nafai: programming jobs are always better than ditch digging jobs.
17:22:03 <Nafai> I was reading "Haskell for C Programmers" today
17:22:06 <Nafai> shapr: Indeed
17:22:14 <emu> actually, quoting lambda bothers me because it reveals the primary problem with emacs lisp
17:22:31 <protoscript> emu: which are?
17:22:41 <emu> "dynamic" scope
17:22:45 <protoscript> ah
17:22:47 <protoscript> right
17:22:54 * eviltwin_b prefers to be reminded that it's not quite right...
17:23:02 <protoscript> hehe
17:23:02 <shapr> Nafai: Anyway, what will make up your mind about learning Haskell? What interests you, or what requirements do you have?
17:23:23 <eviltwin_b> otoh the last real lisp I used was maclisp :)
17:23:25 <emu> last time i checked, #'(lambda ..) '(lambda ..) and (lambda ..) were all equivalent in emacs lisp, but, i don't do enough of it to be sure
17:23:51 * EvilRanter prefers Scheme for the very reason emu cites
17:24:04 <lispy> LISP - She is an aging beatnik, who lives in a rural commune with her hippie cousins SMALLTALK and FORTH. <-- /me is rofling hard
17:24:07 <EvilRanter> altho Haskell > *.
17:25:17 <Nafai> I guess I'm partially motivated because I want to learn something more elegant than Java that I do at work and for consulting.  So I've been thinking about Lisp (already done some CL and Scheme), Haskell, Smalltalk, and Factor
17:25:23 <emu> protoscript: if you are familiar with functional programming you'll see that "hooks" in emacs are just thunks or parameterless functions
17:25:43 <shapr> Nafai: Oh, I like it! Keep on learning!
17:26:18 <Nafai> Ultimately, my interest in learning something elegant and cool is tempered by the fact that I want something that is ultimately useful -- can I write tools with it for my own use
17:26:40 <Nafai> That's why I keep coming back to Python because of the standard library and the other good libraries available
17:26:47 <protoscript> emu: not particularly. but i recognize the concept from gui callbacks
17:27:10 <emu> protoscript: like function pointers with user data?
17:27:12 <Nafai> But I guess I can't describe it other than I want something "more" than the type of programming I'm used to doing
17:27:31 <protoscript> yes
17:27:43 <emu> Nafai: i'm pretty newb to haskell too, but i've assembled a number of tools for my work and i really like the library support so far
17:28:08 <emu> protoscript: yes, you'll learn about higher order functions w/closures as you proceed, and recognize that usage i'm sure
17:28:23 <dons> Nafai: you've seen http://haskell.org? Click on the libraries page -- there's hundreds, and more appear weekly
17:28:43 <glguy> Python and haskell both use source code files and use whitespace based blocks
17:28:45 <Nafai> Right, I've been looking through there today
17:28:53 <glguy> (I forget what else they have in common (-; )
17:29:11 <dons> python has a form of list comprehension too
17:29:18 <protoscript> factor is the other language i was considering spending my time with, before haskell finally won me over
17:29:23 <glguy> ah yes, [x + 2 for x in a]
17:29:59 <dons> > let a = [1..10] in [ x + 2 | x <- a ]
17:30:00 <lambdabot>  [3,4,5,6,7,8,9,10,11,12]
17:30:09 <Nafai> I just need to figure out the best way to get those libraries on my system if they aren't packaged for Ubuntu
17:30:28 <emu> Nafai: the Cabal system offers that
17:30:43 <dons> right, so almost all build with the same cabal build system, offering a uniform interface to installing haskell packages
17:30:51 <glguy> Haskell has generally awesome data types (-;
17:33:36 <protoscript> emu: it worked
17:33:43 * Nafai looks at cabal
17:33:46 <protoscript> thanks
17:34:28 <emu> protoscript: when editing a haskell file, you can hit TAB to cycle through indentations of the line
17:34:35 <dons> shapr: did you see the new unicycle haskell textbook?
17:34:39 <emu> this is a pretty unique mode, as far as i know
17:34:45 <protoscript> now i need to wire it up to ghc. that's the only other thing i really 'need' to be happy
17:34:52 <protoscript> ...?
17:34:55 <protoscript> confused
17:34:58 <emu> protoscript: right, so hit C-c C-l to fire up inf-haskell mode
17:34:58 <protoscript> bu ti will test
17:35:07 <emu> and load the file
17:35:10 <Nafai> unicycle haskell textbook?  Sounds like something shapr would write
17:35:33 <dons> shapr: http://www.novateceditora.com.br/livros/haskell/ !
17:35:36 <lambdabot> http://tinyurl.com/yjkv9g
17:35:54 <dons> is that a man riding a unicycle up a hill to find a lambda at the top?
17:36:09 <protoscript> yeah it can't find "hugs"
17:36:28 <emu> do C-u M-x run-haskell
17:36:57 <emu> to set the default, add this line to init: (setq haskell-program-name "ghci")
17:37:13 <protoscript> awesome
17:38:02 <emu> in general, you can use C-h m to get help about the current mode of a buffer, including keybindings
17:38:59 <protoscript> oh wow
17:39:04 <protoscript> that will be a life savor
17:39:05 <protoscript> thanks
17:39:10 <protoscript> i went thru the emacs tutorial
17:39:13 <protoscript> but that was a while ago
17:39:19 <protoscript> need to do it agaun'
17:39:22 <emu> C-h t for tutorial, C-h ? for the rest of the things you can do
17:39:57 <Nafai> I guess part of the reason I'm interested in Haskell is I'm interested in compilers and interpreters and I've seen a lot about implementing them with Haskell lately
17:40:29 <lispy> ?quote Pseudonym
17:40:29 <lambdabot>  A "newbie", in Haskell, is someone who hasn't yet implemented a compiler.  They've only written a monad tutorial.
17:40:55 <lispy> Nafai: ^^
17:42:13 <syntaxfree> dons: a brazilian Haskell book!
17:42:44 <lispy> it's not the quote i wanted, but strangle appropraite
17:42:51 <Nafai> Are there any docs on how to use cabal?
17:42:51 <lispy> strangly*
17:42:56 <lispy> yes
17:42:58 <emu> haskell.org/cabal
17:43:12 <kpreid> Does it count if it's a compiler *to* Haskell?
17:43:14 <lispy> ?where how_to_write_a_haskell_program
17:43:14 <lambdabot> I know nothing about how_to_write_a_haskell_program.
17:43:15 <emu> it's generally easy though: runhaskell Setup.hs configure/build/install
17:43:41 <eviltwin_b> ?wiki how_to_write_a_haskell_program
17:43:42 <lambdabot> http://www.haskell.org/haskellwiki/how_to_write_a_haskell_program
17:43:44 <lispy> the first real haskell program i wrote was an embedded domain specific compiler :)
17:43:45 <eviltwin_b> hm, nope
17:44:02 <lispy> Nafai: try the how-to-write-a-haskell-program page too for cabal info
17:44:08 <syntaxfree> compiler?
17:44:09 <lispy> eviltwin_b++
17:44:17 <syntaxfree> How do you even write a compiler? :~
17:44:46 <lispy> syntaxfree: in my case, i write a .S file and let gnu as compile that and then link with a small C module that calls into the linked code
17:44:46 <dibblego> just type ghc; it's a higher-order function
17:44:48 <kpreid> module Compiler where ...
17:44:52 <emu> a compiler is a function from (Source a, Target b) => a -> b
17:44:59 <lispy> ?where helisp
17:45:00 <lambdabot> http://www.codersbase.com/index.php/helisp
17:45:02 <lispy> syntaxfree: ^^
17:45:12 <Nafai> lispy: Thanks
17:45:15 <lispy> syntaxfree: look at the CodeGen monad and also Compile.hs
17:45:24 <syntaxfree> .S?
17:45:29 <lispy> syntaxfree: assembly
17:45:33 <syntaxfree> oh.
17:45:42 <eviltwin_b> .S is typically assembler-via-cpp
17:45:52 <eviltwin_b> (.s is straight assembler)
17:46:18 <lispy> eviltwin_b: ah, that's nice to know
17:46:18 <emu> there's books out there to help you with the basic ideas about intermediate representations and various dataflow analysis
17:46:30 <emu> i happened to use Appel, though, i wasn't particularly attached
17:48:33 <lispy> when it comes to compilers i'm often surprised at how many of the things i would guess to be easy are very hard and vice versa
17:49:30 <protoscript> lispy: example?
17:51:45 <lispy> tail call optimization is actually pretty simple
17:51:52 <lispy> i wouldn't have guessed that
17:52:09 <Excedrin> lispy: relisp passed most tests on my machine; it failed 3 I think
17:52:37 <protoscript> lispy: that's counterintuitive to me too
17:52:40 <lispy> Excedrin: interesting, any idea why it failed those? oh, maybe overflow in some of the integer testst
17:52:56 <jdev> Tail call optimization is easy if the language doesn't make it hard and/or impossible.
17:52:58 <lispy> Excedrin: i think that was reported but i didn't fix it yet
17:53:28 <jdev> See, for example, C, where it's annoying and only sometimes possible, because of &.
17:53:40 <lispy> Excedrin: next on my list is a commandline flag to determine if you're getting a x86_64 or x86_32 and then to find a machine to test the 32bit stuff on
17:54:35 <lispy> Excedrin: also, i'd like to support ppc and win32 (requires some changes to the header of the .s file)
17:55:06 <emu> QuickCheck is very cool, but, I'm finding myself in a bit of a dilemma with it: because my program accepts such large and complex test cases, how can I be sure I am generating valid data?
17:56:12 <lispy> emu: yes, writing good test case generators is certainly tricky
17:58:51 <emu> i almost feel like i need meta-tests
18:00:06 <mgsloan> emu - it's certainly a phenomena
18:00:40 <eviltwin_b> quis custodiet ipsos custodes?
18:00:42 <mgsloan> tests are sort of a double-check that it works.  metatests make it a triple check
18:00:57 <mgsloan> well, maybe not triple check
18:01:22 <emu> well, so long as they become simpler, it could help ensure that your test cases are valid
18:01:42 <emu> it might work, since it's not a proof
18:02:06 <lispy> emu: with testing you won't find everything anyway, so you should try to balance the cost-benefit of writing good tests and actually having those tests catch bugs
18:09:58 <heatsink> How d'ya pronounce 'monad'?
18:11:01 <sjanssen> heatsink: I don't, very often
18:11:24 <emu> nobody knows, since it can only be heard from within
18:11:41 <heatsink> Must be hard to give lectures on the subject.
18:11:53 <emu> that's why nobody understands it
18:11:53 <jcreigh> "warm fuzzy thing"
18:12:14 * Nafai compiles gtk2hs
18:12:18 <heatsink> Well, they are usually explained through koans anyway.
18:12:44 <eviltwin_b> the monad that can be pronounced is not the true monad?
18:12:48 <lispy> heatsink: moe-nad
18:13:14 <heatsink> ok.  Like nomad.
18:14:03 <lispy> cool, by my metric for knowing programming languages i now know scaal
18:14:05 <lispy> er scala
18:14:09 <lispy> i found my first compiler bug :)
18:14:14 <heatsink> :)
18:14:29 <newsham> hi
18:14:34 <lispy> hi
18:14:39 <lispy> newsham: welcome to #haskell ;)
18:14:56 <mwolak> what would you do if you encountered a language with a bug-free compiler? (Stop laughing!)
18:15:04 <jcreigh> lispy: wow, I must have some really deep knowledge of ColdFusion, then. :)
18:15:05 <lispy> > fix $ \f -> 1 : 1 : zipWith (+) f (tail f) -- have a fibs on the house
18:15:06 <heatsink> mwolak, add features!
18:15:06 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
18:15:15 <eviltwin_b> start hacking on it?
18:15:17 <lispy> jcreigh: haha
18:15:17 <eviltwin_b> yeh
18:15:41 <lispy> mwolak: it would take me a long time to be sure i knew the language
18:15:45 <newsham> anyone wanna review some happs code?
18:16:32 <protoscript> jcreigh: hahahaha
18:17:15 <jcreigh> everybody laughs, but it's not funny.
18:18:10 <Nafai> What's happs?
18:18:19 <newsham> ?go happs
18:18:29 <newsham> how does that cmd go? :)
18:18:35 <lambdabot> search module failed: IRCRaised thread killed
18:18:41 <newsham> http://happs.org/HAppS/README.html
18:18:41 <eviltwin_b> ?where happs
18:18:43 <lambdabot> Title: HAppS -- Haskell Application Server (version 0.8.4 )
18:18:43 <lambdabot> http://happs.org
18:21:42 <heatsink> > head $ show $ 2 ^ (3*10 ^ 5)
18:21:47 <lambdabot> Terminated
18:27:37 <mwolak> anyone know about ghc's usge of SSE in the native code generator?
18:29:06 <mwolak> I've seen hints that it does use SSE (at least with x86_64), but nothing more
18:30:24 <heatsink> Given what it takes to auto-vectorize code, I would guess that it uses pattern recognition to generate SSE code for some unboxed array operations.
18:32:17 <mwolak> even that would be pretty sweet, especially if I knew what operations it could work with
18:32:42 <lispy> jcreigh: i've heard that coldfusion makes php look nice
18:33:18 <svref> How do I pick apart a "time string" for conversion to an Int?  E.g. parse "12:55pm" -> (12,55,True)
18:34:35 <mgsloan> svref - write a parser?
18:35:05 <lispy> > (\x -> (takeWhile (/=':') x, takeWhile (not.isAlpha) dropWhile (/=':') x)) "12:55"
18:35:06 <lambdabot>    The function `takeWhile' is applied to four arguments,
18:35:06 <lambdabot>   but its type ...
18:35:24 <lispy> > (\x -> (takeWhile (/=':') x, takeWhile (not.isAlpha) (dropWhile (/=':') x))) "12:55"
18:35:25 <lambdabot>  ("12",":55")
18:35:47 <lispy> svref: that will get you kinda close assuming your time strings are really consintent
18:35:57 <svref> Thanks.
18:36:08 <svref> I didn't "get" reads.
18:36:15 <svref> is it a variable?
18:36:19 <svref> err.
18:36:26 <lispy> > read "1" :: Int
18:36:28 <lambdabot>  1
18:36:38 <svref> > :t reads
18:36:38 <lambdabot>  Parse error
18:36:45 <svref> @type reads
18:36:47 <lambdabot> forall a. (Read a) => ReadS a
18:37:23 <lispy> oh
18:37:25 <mgsloan> > let parseTime (h1:h0:':':m1:m0:c:'m') = (h1 * 10 + h0, m1 * 10 + m0, c == 'p') in parseTime "12:55am"
18:37:25 <svref> How can a global constant have a polymorphic type?
18:37:26 <lambdabot>  Couldn't match `[Char]' against `Char'
18:37:38 <lispy> svref: usually people mean happy or parsec when they say write your own parser :)
18:37:40 <kpreid> svref: (a) ReadS is a type alias for a function
18:37:47 <kpreid> svref: (b) constants can be polymorphic
18:37:50 <kpreid> @type maxBound
18:37:51 <lambdabot> forall a. (Bounded a) => a
18:37:56 <kpreid> @type mzero
18:37:57 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
18:38:00 <kpreid> @type mempty
18:38:01 <lambdabot> Not in scope: `mempty'
18:38:06 <kpreid> @type Data.Monoid.mempty
18:38:08 <mgsloan> lispy - not in my case :) I usually write my own for simple stuff
18:38:08 <lambdabot> forall a. (Data.Monoid.Monoid a) => a
18:38:11 <sjanssen> in Haskell, all values are constants
18:38:14 <mgsloan> though probably parsec is simpler
18:38:35 <kpreid> actually, mempty could include a function type
18:38:46 <mgsloan> > let parseTime (h1:h0:':':m1:m0:c:'m':[]) = (h1 * 10 + h0, m1 * 10 + m0, c == 'p') in parseTime "12:55am"
18:38:47 <lambdabot>  add an instance declaration for (Num Char)
18:38:47 <lambdabot>   In the definition of `parseT...
18:38:56 <heatsink> mwolak, there are some SSE references in compiler/nativeGen/MachCodeGen.hs and compiler/nativeGen/MachInstrs.hs
18:39:07 <mgsloan> doh!
18:39:16 <svref> mgsloan: I like your case-matching idea.
18:39:17 <mgsloan> nevermind, just use lispy's
18:39:29 <mgsloan> yeah, it makes it clear
18:39:55 <lispy> do { hour <- manyTill digit (char ':'); char ':'; min <- manyTill digit (char 'a' <|> char 'A' <|> char 'P' <|> char 'p'); <-- this might get you close with parsec
18:40:16 <lispy> oneof "aApP" would be better tho
18:40:54 <mgsloan> > let parseTime (h1:h0:':':m1:m0:c:'m':[]) = (read [h1,h0] :: Int, read [m1,m0] :: Int, c == 'p') in parseTime "12:55am"
18:40:56 <lambdabot>  (12,55,False)
18:42:01 <mgsloan> > let parseTime (h1:h0:':':m1:m0:c:'m':[]) = (read [h1,h0] :: Int, read [m1,m0] :: Int, toLower c == 'p') in parseTime "12:55PM"
18:42:03 <lambdabot>  Non-exhaustive patterns in function parseTime
18:42:21 <mgsloan> ah. the m
18:42:22 <TSC> Capital M
18:42:42 <mgsloan> yeah, was gonna try to make it more general, but the case matching method isn't good for that :)
18:42:46 <heatsink> mwolak, in the version I have (which isn't HEAD) there is some mention of SSE but it looks like there's no sse codegen.
18:42:56 <mwolak> nifty, thanks
18:44:20 <heatsink> Oh, and from the comments, I think they intend to use SSE just because the x87 FP stack is difficult to generate code for.
18:46:57 <lispy> parseTime = do { hour <- manyTill digit (char ':'); char ':'; min <- manyTill digit (oneof "apAP"); afternoon <- dayTime; return (hour, min, atfternoon)} afternoon = do { oneof "aA"; oneof "mM"; return False } <|> do { oneof "pP"; oneof "mM"; return True }
18:47:01 <lispy> (not tested)
18:47:09 <lispy> won't handle whitespace
18:47:34 <jcreigh> lispy: yeah, pretty much. (WRT Coldfusion vs. PHP)
18:48:23 <lispy> (you could add support for spaces by inserting calls to 'spaces' in the right places)
18:48:29 <lispy> jcreigh: that's really sad
18:50:41 <jcreigh> lispy: yeah. I just tell myself "Okay, you've basically got the same level of abstraction as an excessively verbose, garbage collected C. People have done great things with less."
18:50:54 <lispy> :)
18:51:08 <lispy> positiveoutlook++
18:51:16 <jcreigh> and then I tell myself "GAHH!!! WHY DID THEY DO THAT?!?"
18:51:17 <heatsink> @karma positiveoutlook
18:51:18 <lambdabot> positiveoutlook has a karma of 1
18:53:23 <pitecus> why does GHC complain about cyclic module imports? whats wrong with those?
18:53:50 <heatsink> It's set up to process one module at a time.
18:54:11 <heatsink> Specifically in typechecking, I htink.  With cyclic module imports, it has to typecheck multiple modules simultaneously.
18:54:34 <pitecus> lame, no?
18:54:39 <heatsink> If you need cyclic modules, you can use hi-boot files.
18:54:56 <pitecus> hi-boot?
18:55:01 <heatsink> I mean hs-boot
18:55:24 <mgsloan> > parseTime xs = ((read xs) :: Int, (read $ dropWhile (/=':')) :: Int, 'pm' == lower $ dropWhile (not . isAlpha)) in parseTime "2:55Pm"
18:55:25 <lambdabot>  Parse error
18:55:47 <pitecus> are those hs-boot documented somewhere?
18:55:49 <mgsloan> > let parseTime xs = ((read xs) :: Int, (read $ dropWhile (/=':')) :: Int, 'pm' == lower $ dropWhile (not . isAlpha)) in parseTime "2:55Pm"
18:55:49 <lambdabot>  Improperly terminated character constant
18:56:19 <heatsink> http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
18:56:21 <lambdabot> Title: 4.6. Filenames and separate compilation, http://tinyurl.com/yyunf2
18:56:22 <mgsloan> > let parseTime xs = ((read xs) :: Int, (read $ dropWhile (/=':')) :: Int, "pm" == take 2 $ lower $ dropWhile (not . isAlpha)) in parseTime "2:55Pm"
18:56:22 <lambdabot>  Not in scope: `lower'
18:56:42 <heatsink> mgsloan, You can also private-message lambdabot.
18:56:46 <mgsloan> > let parseTime xs = ((read xs) :: Int, (read $ dropWhile (/=':')) :: Int, "pm" == take 2 $ map (toLower) $ dropWhile (not . isAlpha)) in parseTime "2:55Pm"
18:56:47 <lambdabot>    Expecting a function type, but found `a'
18:56:47 <lambdabot>    Expected type: String
18:56:47 <lambdabot>   ...
18:56:58 <mgsloan> yes, people suggest that to me a lot....
18:57:10 <Nafai> Anyone here know about gtk2hs?  Is wnck wrapped?
18:57:24 <lispy> i really wish scala had a channel on freenode
18:57:35 <pitecus> thanks heatsink
18:57:36 <lispy> this compiler bug is driving me nuts
18:58:56 <heatsink> np
19:05:22 <syntaxfree> c++
19:05:28 <syntaxfree> @karma c
19:05:29 <lambdabot> c has a karma of 12
19:05:35 <syntaxfree> hehehe
19:06:10 <sjanssen> @karma c++
19:06:11 <lambdabot> c++ has a karma of -4
19:06:15 <sjanssen> c++++
19:06:21 <sjanssen> @karma c++
19:06:21 <lambdabot> c++ has a karma of -4
19:06:31 <heatsink> @karma c
19:06:31 <jcreigh> c++--
19:06:32 <lambdabot> c has a karma of 12
19:06:42 <jcreigh> @karma c++
19:06:43 <lambdabot> c++ has a karma of -4
19:08:36 <augustss> @karma c--++
19:08:37 <lambdabot> c--++ has a karma of 0
19:08:47 <heatsink> @karma cmm
19:08:48 <lambdabot> cmm has a karma of 0
19:08:56 <Excedrin> @karma- c++
19:08:57 <lambdabot> c++'s karma lowered to -5.
19:09:08 <lispy> ?karma Java
19:09:08 <lambdabot> Java has a karma of -2
19:09:22 <augustss> @karma haskell
19:09:23 <lambdabot> haskell has a karma of 13
19:09:54 <lispy> @karma chameleon
19:09:54 <lambdabot> chameleon has a karma of 0
19:09:59 <augustss> @karma pascal
19:09:59 <lambdabot> pascal has a karma of 0
19:10:00 <heatsink> haha
19:10:08 <jcreigh> what? only 13?
19:10:12 <jcreigh> haskell++
19:10:18 <heatsink> @karma java
19:10:19 <lambdabot> java has a karma of -15
19:10:21 <lispy> ?karma #haskell
19:10:21 <lambdabot> #haskell has a karma of 2
19:10:23 <heatsink> it's case sensitive
19:10:34 <augustss> bah!
19:11:07 <Excedrin> @karma C++
19:11:08 <lambdabot> C++ has a karma of 0
19:11:40 <augustss> @karma brainfuck
19:11:41 <lambdabot> brainfuck has a karma of 0
19:12:24 <mgsloan> you know, you guys can private message the bot ;) j/k
19:12:42 <slime_mold> > List.nub $ Random.randomRs (1,10) (Random.mkStdGen 4)
19:12:47 <lambdabot> Terminated
19:12:54 <Excedrin> @karma-all
19:12:55 <lambdabot>  dons                   92
19:12:55 <lambdabot>  audreyt                39
19:12:55 <lambdabot>  dcoutts                37
19:12:55 <lambdabot>  Cale                   31
19:12:55 <lambdabot>  lambdabot              31
19:12:56 <lambdabot> [451 @more lines]
19:12:59 <slime_mold> :(
19:13:11 <syntaxfree> the fun is in the sharing, mgsloan.
19:13:13 <sjanssen> @yow dons is up to 92?
19:13:13 <lambdabot> ... I don't like FRANK SINATRA or his CHILDREN.
19:13:42 <syntaxfree> @yow the text affects the result?
19:13:43 <lambdabot> It's NO USE ... I've gone to "CLUB MED"!!
19:13:56 <sjanssen> syntaxfree: nope, it's ignored
19:13:58 <syntaxfree> shapr++++++++++
19:14:22 <syntaxfree> I'd like to write some lambdabot commands.
19:14:32 <syntaxfree> I've given up trying to compile it on the mac though.
19:14:49 <syntaxfree> There should be some simple way to just define Haskell functions and submit them.
19:14:55 <lispy> syntaxfree: why no luck on the mac?
19:14:56 <syntaxfree> Each user should have his own namespace.
19:15:07 <mgsloan> syntaxfree - I know. I guess people get annoiyed when I botch haskell code repeatedly.
19:15:11 <syntaxfree> lispy: I've tried about four times, with varying results.
19:15:30 <lispy> syntaxfree: i haven't tried it on the mac yet, but debian amd64 was sealy
19:15:32 <lispy> easy*
19:15:43 <syntaxfree> easy -> sealy is an entertaining typo.
19:15:48 <syntaxfree> I wonder how it came up
19:16:07 <lispy> i'm on a dvorak keyboard so some typos are much easier
19:16:26 <syntaxfree> oh. I envy those disciplined enough to switch to dvorak.
19:16:38 <lispy> it's very good for your rsi
19:17:00 <syntaxfree> I can type approximately 120wpm in portuguese in this microsoft keyboard on the QWERTY layout. Everytime I try dvorak I feel like a small child.
19:17:16 <mgsloan> hehe
19:17:24 <mgsloan> I can't think fast enough for it to make a difference
19:17:24 <lispy> 120wmp? i have no idea what i can type or with what accuracy
19:17:42 <syntaxfree> I'm somewhat slower typing in english.
19:17:52 <syntaxfree> Mainly because I still second-guess myself a lot on the grammar.
19:17:53 <augustss> my typing is very slow.  that's why I use Haskell.
19:18:19 <syntaxfree> Programming is probably 0.1% of what I type.
19:18:27 <Nafai> Where do I get the latest haskell mode for emacs?
19:18:58 <dons> Nafai: its available from http://haskell.org, click on the 'Libraries and applications' link, and then under 'Program development'
19:18:59 <lambdabot> Title: Haskell - HaskellWiki
19:19:55 * syntaxfree just uses SubEthaEdit.
19:20:15 * mgsloan wishes he could use subethaedit
19:21:09 <syntaxfree> why can't you?
19:21:15 <Excedrin> do you use the collaboration stuff?
19:21:42 <mgsloan> syntaxfree - I don't have a mac
19:21:58 <syntaxfree> uhh. why do you want subethaedit, then?
19:22:13 <mgsloan> because it looks really really nice :)
19:22:38 <mgsloan> they should make a linux ver.  I'd pay quite a bit for it
19:22:44 <mgsloan> tubad they're mac devotees
19:23:06 <syntaxfree> What's so special about SEE you can't find in linux editors?
19:23:17 <mgsloan> collaboration stuff mostly
19:23:37 <mgsloan> I also like simplicity - vim or emacs isn't really my style...
19:23:58 <Excedrin> scite?
19:24:02 <syntaxfree> I use vim when on windows.
19:24:08 <mgsloan> though technically i use vim mostly now, its usually only in insert mode
19:24:10 <syntaxfree> Actually cream, but I activate modes.
19:24:21 <eviltwin_b> kdevelop is said to be nice on linux
19:24:29 * eviltwin_b has yet to encounter a non-buggy version, though
19:24:51 <syntaxfree> that's why I got myself a Mac.
19:25:01 <syntaxfree> fed up of ironing out buggy bits in Linux.
19:25:16 <protoscript> :-/
19:25:34 <eviltwin_b> likewise (and fbsd)
19:26:28 * shapr boings
19:26:34 <syntaxfree> Macs are really nicely engineered and you can get a lot out of your mind.
19:26:39 <protoscript> when i try to use run-haskell I get
19:26:47 <Excedrin> one of my co-workers believes that Windows users migrate to Linux when they become fed up with Windows and the same idea for Linux to Mac, and Mac to Windows
19:26:50 * eviltwin_b wonders if he should get a mallet
19:27:09 <syntaxfree> I'm sure someone nerdier than me can buy the right components and assemble a quality PC, but quality control in PCs lately has gone to crap.
19:27:15 <protoscript> ghc gives me "Could not find module"
19:27:48 <Excedrin> protoscript: did you try -v ?
19:28:27 <protoscript> said "not in scope: v"
19:28:45 <Excedrin> runhaskell takes the full path with .hs extension; as in runhaskell -v hello.hs
19:28:56 <syntaxfree> Unlike most PCs my Mac is really really silent and really really cool.
19:29:03 <syntaxfree> My mom's PC is untouchable after half an hour of use.
19:29:17 <syntaxfree> (cool as in not warm)
19:30:11 <protoscript> i may have guessed the problem
19:30:22 <protoscript> i know the console mode of windows
19:30:34 <protoscript> sometimes doesn't like long path names
19:30:52 <protoscript> and mine is "c:\Documents and Settings\jared\My Documents\code\haskell\exercise.hs"
19:31:19 <syntaxfree> why do you
19:31:21 <syntaxfree> break your
19:31:23 <syntaxfree> sentences
19:31:26 <syntaxfree> as if you were writing
19:31:29 <syntaxfree> free verse?
19:31:46 <protoscript> The same reason
19:31:50 <protoscript> (that you do ;)
19:31:52 <heatsink> heh
19:32:00 <heatsink> I wrote a
19:32:02 <heatsink>     little
19:32:04 <heatsink>         program
19:32:08 <heatsink> It doesn't seem to -- work --
19:32:26 <protoscript> syntaxfree: look at your last right before you said that
19:32:57 <eviltwin_b> wait, haskell now has a poetry mode? :>
19:33:02 <protoscript> honestly tho
19:33:24 <protoscript> i think it has something to do with talking to really impatient people online years ago before most tools said "soandos is typing a response"
19:33:48 <protoscript> and people would interupt my typing every 3 seconds saying "hello?"
19:33:51 <protoscript> "are you there"?"
19:33:54 <protoscript> "where are oyu"
19:34:52 <syntaxfree> yes, the oyu.
19:34:57 <syntaxfree> the oyu often are missing.
19:35:12 <dons> ?users
19:35:13 <lambdabot> Maximum users seen in #haskell: 276, currently: 234 (84.8%), active: 37 (15.8%)
19:35:42 <dons> Cale: did you think about putting your morse code gen on the wiki?
19:35:50 <dons> nice little exercise
19:35:52 <jcreigh> > 37.0 / 234.0
19:35:53 <lambdabot>  0.1581196581196581
19:35:56 <lispy> morse code gen?
19:36:19 <lispy> dons: morse code sounds like a lambdabot plugin
19:36:36 <syntaxfree> @YOW
19:36:37 <lambdabot> Unknown command, try @list
19:36:41 <syntaxfree> @yow
19:36:41 <lambdabot> My uncle Murray conquered Egypt in 53 B.C.  And I can prove it too!!
19:38:34 <mgsloan> yes, lets have a lambdabot plugin for everything done in haskell with textual applicability! /me votes for a darcs acessor that DCCs you the files
19:38:40 <eviltwin_b> periodically sends out -.-. --.- .... ... when it's lonely?
19:39:33 <jcreigh> or maybe ... --- ... instead of "Terminated"
19:40:54 <syntaxfree> I'd sure like to have my Caesar auto-decrypter in LB.
19:42:12 <lispy> ?bf ... --- ...
19:42:13 <lambdabot> Done.
19:42:25 <lispy> ?bf -.-. --.- .... ...
19:42:25 <lambdabot> Done.
19:42:33 <lispy> hmm...those programs don't seem to produce output :)
19:42:51 <jcreigh> I don't think those are BF instructions.
19:43:12 <jcreigh> no, sorry, you're right.
19:43:18 <lispy> i wrote @bf, but i never remember the syntax :)
19:43:47 <syntaxfree> bf is brainfuck?
19:43:51 <syntaxfree> @help lambda
19:43:52 <lambdabot> lambda <expr>. Evaluate the lambda calculus expression, <expr>
19:43:55 <jcreigh> syntaxfree: yeah
19:43:59 <syntaxfree> @lambda  2 + 2
19:44:00 <lambdabot> 4
19:44:00 <mgsloan> yeah, it fucks with your brain like that
19:44:16 <lispy> ?help bf
19:44:16 <lambdabot> bf <expr>. Evaluate a bainf*ck expression
19:44:27 <mgsloan> heh, bain
19:45:02 <syntaxfree> @todo
19:45:03 <lambdabot> 0. SamB: A way to get multiple results from a google search
19:45:03 <lambdabot> 1. dons: improve formatting of @dict
19:45:03 <lambdabot> 2. dons: write Haskell Manifesto
19:45:03 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
19:45:03 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
19:45:05 <lambdabot> [19 @more lines]
19:45:53 <LoganCapaldo> @bf ++++.
19:46:00 <lambdabot> Done.
19:46:20 <LoganCapaldo> done?
19:46:31 <LoganCapaldo> . is print right?
19:46:52 <syntaxfree> @spell haskeel
19:46:54 <lambdabot> Haskel Haskell has keel has-keel Haskel's
19:47:06 <syntaxfree> @spell spall
19:47:07 <lambdabot> spell spill sepal spa ll spa-ll
19:47:08 <dons> dcoutts: around?
19:47:11 <syntaxfree> ?
19:47:19 <shapr> @spell shapr
19:47:20 <lambdabot> Shapiro Sharp sharp shape shaper
19:47:26 <lispy> ?bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
19:47:27 <lambdabot>  Hello World!
19:47:50 <mgsloan> ?bf ++++++++++[>
19:47:51 <lambdabot> Done.
19:47:59 <lispy> LoganCapaldo: it will scrub the output and it disables the input instruction
19:48:12 <lispy> mgsloan: that's not a valid program
19:48:25 <mgsloan> yeh, was just wondering if that'd print h or something ;p
19:48:34 <newsham> anyone have opinions on haskell encryption libraries?
19:48:40 <LoganCapaldo> ?bf Hey look everything is comment!
19:48:40 <lambdabot> Done.
19:48:43 <lispy> i think it aborts compilation on compile error :)
19:49:00 <shapr> newsham: There's the standard cryptolib, and there's musasabi's hsopenpgp wrapper
19:49:02 <mgsloan> ?bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++..+++.>++.<<+++++++++++.>.+++.------.--------.>+.>.
19:49:06 <lambdabot>  Hejjm Smpjb!
19:49:10 <mgsloan> :)
19:49:12 <shapr> newsham: I think there's also an hsgnutls wrapper
19:49:35 <newsham> "standard cryptolib" meaning?  part of ghc?  is it in C or haskell?
19:49:44 <syntaxfree> @help get-shapr
19:49:45 <lambdabot> get-shapr. Summon shapr instantly
19:49:55 <mgsloan> lol!
19:49:56 <newsham> > get-shapr
19:49:58 <lambdabot>  Not in scope: `shapr'
19:50:01 <shapr> afaik, cryptolib is in pure haskell
19:50:09 <mgsloan> @get-shapr
19:50:09 <lambdabot> shapr!!
19:50:11 <newsham> where?
19:50:18 <shapr> Though I think the licenses vary on the modules.
19:50:31 <shapr> yes?
19:50:46 <lispy> i implemented RSA and strong psuedo primes if you want to do the crypto at a low level :)
19:50:46 <shapr> someone sent out the SHAPR-SIGNAL!
19:50:49 <newsham> also, any comments on happs code yet?
19:51:05 <heatsink> Does your shapr-sense tingle when that happens?
19:51:07 <newsham> lispy: looking for hashes and maybe block ciphers.  not pub key at the moment.
19:51:09 <shapr> newsham: Sorry, I've been distracted by paying my rent..
19:51:21 <newsham> no problem.  rent first, happs 2nd.
19:51:21 <lispy> shapr: heh, well put
19:51:25 <shapr> heatsink: Nah, I just get distracted from whatever I was focussing on at the time.
19:51:31 <lispy> shapr: welcome back to the US ;)
19:51:38 <newsham> ?where cryptolib
19:51:39 <lambdabot> I know nothing about cryptolib.
19:51:39 <SamB> shapr: so much for your being a billionaire with cool gadgets and martial arts training!
19:51:49 <shapr> lispy: Problem is... my money is in Sweden.
19:51:58 <shapr> newsham: http://www.haskell.org/crypto/doc/html/
19:52:03 <newsham> danke
19:52:13 <SamB> shapr: ... and they won't give it back?
19:52:14 <lispy> shapr: would you recommend sweden to others USians?
19:52:33 <shapr> lispy: Depends on your requirements.
19:52:38 <lispy> i think in a few years time i should stop living in the US
19:52:48 <shapr> That's the same thing I would say to Swedes who asked about living in the USA.
19:52:51 <newsham> hmm.. looks perfect.
19:52:54 <lispy> japan might be a nice place to move, but the language barrier is high :)
19:53:04 <shapr> Sweden is a good place to be poor, but a bad place to be rich.
19:53:05 <dylan> I'm with lispy.
19:53:19 <shapr> Also, you have to be thin to live in Sweden.
19:53:28 <SamB> hmm, and apparantly they don't like immigrants to be poor?
19:53:31 <shapr> And you really need to be in good shape if you want to fit into polite company.
19:53:34 <lispy> shapr: i'm not a terrible big guy if you recall :)
19:53:47 * SamB is thin, but not in shape exactly
19:53:53 <shapr> SamB: Poor is okay as long as you pay enough taxes.
19:54:00 * lispy is going to run a marathon in April
19:54:10 <mwc> SamB, a season of X-country skiing will fitten you right up
19:54:16 <shapr> lispy: Ok, you'll do fine in Sweden.
19:54:21 <SamB> do they offer to let you pay extra taxes?
19:54:26 <shapr> Sweden has a lot of rules though.
19:54:35 <mwc> last I checked it burned more calories and taxed your heart harder then running
19:54:43 <lispy> shapr: mind if we move to #haskell-blah?
19:54:46 <shapr> When I wanted to change my residence permit type, the immigration office was upset because there wasn't a form for that.
19:54:53 <SamB> mwc: I don't want to burn calories
19:54:57 <SamB> what I mean is I'm puny
19:55:01 <kfish> lispy, japan is a great place to move to :-)
19:55:12 <SamB> I worked hard to eat all those calories!
19:55:13 <shapr> SamB: Pix of you?
19:55:15 <SamB> come on!
19:55:17 * mgsloan buys food based on maximizing calorie/$ ratios
19:55:21 <dons> shapr: did   you see my link earlier to the unicycle haskell textbook?
19:55:28 <SamB> um, I could go grab the camera and take some I guess
19:55:33 <SamB> if I could find the cable
19:55:42 * shapr looks
19:56:16 <dons> http://tinyurl.com/yjkv9g
19:56:52 <dons> nice, don't you think? :)
19:57:33 <newsham> Setup.hs: cannot satisfy dependency NewBinary-any
19:57:42 <dons> you've not got newbinary installed?
19:57:42 <newsham> hmm.. not in ghc-6.6?   where's that live again?
19:57:48 <dons> ?where NewBinary
19:57:49 <lambdabot> darcs get http://www.n-heptane.com/nhlab/repos/NewBinary
19:58:01 <newsham> gracias
19:58:03 <shapr> dons: wow!
19:58:44 * dylan feels like he's been on a vision quest for a window manager for the last few weeks.
19:59:01 <dons> dylan: did the spirit guide speak to you?
19:59:02 <dylan> and it's all lambdabot's fault for being useful.
19:59:14 <eviltwin_b> time to write hswm?
19:59:32 <dylan> for now, dwm + dmenu + xbindkey is good.
19:59:39 <dons> oh, what do you use xbindkey for?
19:59:55 <dylan> launching things on function keys
20:00:09 <dons> oh nice. so that's how you worked around the config.h issue?
20:00:21 <dylan> it is possible with editing dwm's config.h, but it isn't the window manager's job to start applications.
20:00:50 <dylan> That and adding new bindings at runtime is useful.
20:00:51 <lispy> kfish: nice, do you live there now?  are you native or transplanted?
20:01:10 <lispy> dylan: ever looked at sawfish?
20:01:14 <sjanssen> blast!  Did the dwm website change again?
20:01:17 <dylan> lispy: does sawfish tile?
20:01:44 <lispy> dylan: it could if you like, it's extensible via librep, basically it's the emacs of wms
20:02:09 <newsham> how hard is it to have a system where it detects if the src to some component changes, and reloads that component if it has changed?
20:02:31 <newsham> i am writing web page templates in haskell, and it would be useful to have templates reload without restarting the web server.
20:02:53 <newsham> so that presentation could be worked on while the system is running
20:02:57 <Nafai> This is annoying; for some reason haskell-mode doesn't indent things right
20:03:19 <shapr> There are two emacs indent modes, you may want to try the other.
20:03:39 <shapr> newsham: hs-plugins for HAppS!
20:03:41 * shapr boings!
20:03:46 <kfish> lispy: i'm australian, moved to japan in october (for study)
20:03:58 <newsham> shapr: yah, but just for some parts (like templates)
20:04:14 * araujo finally got back from shopping
20:04:25 <lispy> kfish: tokyo or else where?
20:04:33 <kfish> lispy, kyoto
20:04:38 <newsham> can happs even do IO during its main loop operation?
20:04:48 <shapr> I know it can...
20:04:52 <lispy> kfish: ah, i've heard that's a really beautiful old city
20:05:00 <newsham> (by that i mean, can I register IO to happen as a programmer using HAppS)
20:06:00 <shapr> Yeah, I know you can do it. I'm just not sure how.
20:06:27 <dons> sjanssen: I think its suckless.org now?
20:06:54 <dibblego> you can, it's in the HAppS.MACID package
20:07:15 <newsham> dons: how hard/easy is it to do that kind of thing in hs-plugins?  seems similar to that video on dynamic music inhaskell that was on the list recently
20:08:55 <sjanssen> dons: found it, my delicious link was incorrect
20:09:41 <dons> newsham: what do you want to do?
20:09:54 <dibblego> let f m n = array (0, m - 1) (zip [0..m - 1] (replicate m (array (0, n - 1) (zip [0..n - 1] (replicate n 0))))) in f 2 3 -- there is surely a better way to have a 2-dimensional matrix?
20:10:27 <newsham> dons: lets say I have Templs.hs with a lot of functions that generate HTML (templates).  I would like to test if the .hs changes and if so reload that module
20:10:33 <newsham> so that future invocations use the newer version
20:10:48 <newsham> so that the presentation of html pages can be tweaked without restarting the application
20:11:14 <dons> newsham: you can do exactly that. see HSP
20:11:49 <newsham> ahh, HSP is already doing that?
20:14:20 <jcreigh> @hoogle Right a -> a
20:14:22 <lambdabot> No matches, try a more general search
20:15:30 <jcreigh> are there "fromRight" or "fromLeft" functions?
20:15:36 <eviltwin_b> Right isn't a type, it's a constructor
20:15:50 <eviltwin_b> @hoogle Either a b -> a
20:15:51 <lambdabot> Prelude.either :: (a -> c) -> (b -> c) -> Either a b -> c
20:16:15 <eviltwin_b> hm, nope :)
20:16:30 <jcreigh> @type fromJust
20:16:32 <lambdabot> forall a. Maybe a -> a
20:16:42 <kpreid> jcreigh: you can make them
20:16:44 <jcreigh> oh, right.
20:16:54 <kpreid> e.g. 'either undefined id'
20:17:04 <kpreid> or (\(Left x) -> x)
20:17:24 <kpreid> but it's better to not have to
20:18:50 <jcreigh> I'm using the latter. What is either (the function) supposed to do?
20:19:12 <jdev> @ty fromJust . either (Just) (const Nothing)
20:19:14 <lambdabot> forall b a. Either a b -> a
20:19:49 <eviltwin_b> looks to me like it checks to see if its argument is Left a or Right b and runs the first function on the former, the second on the latter
20:20:02 <eviltwin_b> (yay type signatures that all but describe functions)
20:20:26 <jcreigh> > either (+2) (*7) (Left 3)
20:20:27 <lambdabot>  5
20:20:33 <jcreigh> > either (+2) (*7) (Right 3)
20:20:35 <lambdabot>  21
20:20:53 <jcreigh> eviltwin_b++
20:21:32 <sjanssen> @. djinn type either
20:21:34 <lambdabot> f a b c =
20:21:34 <lambdabot>   case c of
20:21:34 <lambdabot>   Left d -> a d
20:21:34 <lambdabot>   Right e -> b e
20:21:46 <kpreid> the fewer concrete types used in a type signature, the more you know about what it does
20:21:50 <kpreid> also depends on the type
20:22:28 <kpreid> for example, 'either' can be rederived from its type and choosing to avoid having undefined cases
20:22:33 <kpreid> on the other hand:
20:22:37 <jdev> > map (either (+2) (*7) . ($3)) [Left,Right]
20:22:39 <lambdabot>  [5,21]
20:22:40 <kpreid> @hoogle [a] -> [a]
20:22:41 <lambdabot> Prelude.cycle :: [a] -> [a]
20:22:41 <lambdabot> Prelude.init :: [a] -> [a]
20:22:41 <lambdabot> Prelude.reverse :: [a] -> [a]
20:22:48 <kpreid> @hoogle+ [a] -> [a]
20:22:48 <lambdabot> Prelude.tail :: [a] -> [a]
20:22:49 <lambdabot> List.intersperse :: a -> [a] -> [a]
20:22:49 <lambdabot> Prelude.(:) :: a -> [a] -> [a]
20:22:57 <kpreid> *many* functions of [a] -> [a]
20:23:41 <eviltwin_b> arguably your rule holds only when it's not the same type repeated
20:24:00 <eviltwin_b> how much can you derive from the signature a -> a -> a, after all?
20:24:26 <kpreid> well, my rule is fuzzy :-)
20:24:35 <kpreid> @djinn a -> a -> a
20:24:36 <lambdabot> f _ a = a
20:24:40 <kpreid> @djinn a -> a -> (a, a)
20:24:41 <lambdabot> f a b = (b, a)
20:24:56 <kpreid> @djinn a -> a -> (a, a, a, a)
20:24:56 <lambdabot> f a b = (b, b, b, a)
20:25:31 <eviltwin_b> hm
20:25:39 <eviltwin_b> @djinn Either a b -> a
20:25:40 <lambdabot> -- f cannot be realized.
20:25:55 <kpreid> djinn never gives a partial(?) function
20:25:57 <sjanssen> eviltwin_b: total functions only
20:26:08 <sjanssen> @djinn Either a b -> Maybe a
20:26:08 <lambdabot> f a =
20:26:08 <lambdabot>   case a of
20:26:08 <lambdabot>   Left b -> Just b
20:26:08 <lambdabot>   Right _ -> Nothing
20:26:28 <eviltwin_b> ah
20:26:52 <kpreid> @djinn Maybe a -> Maybe b -> Either a b
20:26:52 <lambdabot> -- f cannot be realized.
20:27:01 <jcreigh> @djinn [a] -> a
20:27:02 <lambdabot> -- f cannot be realized.
20:27:17 <kpreid> @djinn Maybe a -> Maybe b -> Either (Either a b) ()
20:27:18 <lambdabot> f a b =
20:27:18 <lambdabot>   case a of
20:27:18 <lambdabot>   Nothing -> case b of
20:27:18 <lambdabot>         Nothing -> Right ()
20:27:18 <lambdabot>         Just c -> Left (Right c)
20:27:19 <lambdabot>   Just d -> Left (Left d)
20:27:36 <jcreigh> how does djinn work?
20:28:29 <jcreigh> I think I asked before, but all I understood of the answer was "You don't have a comp-sci degree." :)
20:30:40 <dons> ?where djinn
20:30:40 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
20:31:07 <jdev> @djinn Maybe a -> Maybe b -> Either (Either () (a,b)) (Either a b)
20:31:07 <lambdabot> f a b =
20:31:08 <lambdabot>   case a of
20:31:08 <lambdabot>   Nothing -> Left (Left ())
20:31:08 <lambdabot>   Just c -> case b of
20:31:08 <lambdabot>        Nothing -> Left (Left ())
20:31:09 <lambdabot>        Just d -> Left (Right (c, d))
20:31:17 <dons> jcreigh: here you go, in all its glory:
20:31:18 <dons> Djinn interprets a Haskell type as a logic formula using the
20:31:19 <dons> Curry-Howard isomorphism and then a decision procedure for
20:31:19 <dons> Intuitionistic Propositional Calculus.  This decision procedure is
20:31:19 <dons> based on Gentzen's LJ sequent calculus, but in a modified form, LJT,
20:31:19 <Korollary> dons: How is hsplugins going for 6.6? It's sad not being able to build lambdabot with eval.
20:31:21 <dons> that ensures termination.  This variation on LJ has a long history,
20:31:23 <dons> but the particular formulation used in Djinn is due to Roy Dyckhoff.
20:31:26 <dons> The decision procedure has been extended to generate a proof object
20:31:28 <dons> (i.e., a lambda term).  It is this lambda term (in normal form) that
20:31:31 <dons> constitutes the Haskell code.
20:31:33 <dons>   See http://www.dcs.st-and.ac.uk/~rd/publications/jsl57.pdf for more
20:31:36 <dons> on the exact method used by Djinn.
20:31:38 <dons> Korollary: I know!
20:31:39 <lambdabot> http://tinyurl.com/yyhc9w
20:31:41 <dons> won't be long.
20:31:43 * dons wants lambdabot and 6.6 too
20:31:53 <newsham> dons: building hs-plugins from darcs src on 6.6 windows:
20:31:54 <newsham> src/AltData/Typeable.hs:452:0:
20:31:54 <newsham>     parse error (possibly incorrect indentation)
20:32:01 <dons> newsham: yes, I know
20:32:03 <jcreigh> oh, magic.
20:32:06 <newsham> ok
20:32:06 <jcreigh> :)
20:32:06 <dons> don't build hs-plugins with ghc 6.6 yet
20:32:14 <mgsloan> and here I thought that djinn just generated code from a type signature :)
20:32:16 <newsham> *nod* thanks.
20:32:44 <jcreigh> dons: thanks, I'll check out the PDF and see how quickly my eyes glaze over.
20:32:46 <Korollary> jcreigh: fwiw, I am not sure most people with CS degrees know about Curry-Howard. One must takes courses in type theory.
20:32:55 <jdev> @djinn Maybe a -> Maybe b -> Either (Either a b) (Either () (a,b))
20:32:56 <lambdabot> f a b =
20:32:56 <lambdabot>   case a of
20:32:56 <lambdabot>   Nothing -> case b of
20:32:56 <lambdabot>         Nothing -> Right (Left ())
20:32:56 <lambdabot>         Just c -> Left (Right c)
20:32:58 <lambdabot>   Just d -> Left (Left d)
20:33:13 <dons> jcreigh: so basically the type is treated as a theorem, and theorem proving techniques are used to find a proof of that theorem  -- i.e. a term with that type (via Curry-Howard)
20:33:51 <kpreid> @djinn+ would be mildly amusing. "make the other arbitrary choice"
20:33:51 <lambdabot> Cannot parse command
20:34:00 <mgsloan> hrh
20:34:02 <mgsloan> heh
20:34:19 <mgsloan> djinn* - list all choices :O
20:34:29 <Korollary> how about djinnfold when it generates code until it passes quickcheck?
20:34:37 <mgsloan> ooh ;p
20:34:47 <sjanssen> Korollary: YES!
20:35:01 * sjanssen vows to never write actual code again
20:35:07 <mgsloan> make that into a language!
20:35:14 <sjanssen> only properties and type signatures
20:35:18 <SamB_XP> hah
20:35:20 <Korollary> you could even have it make choices using genetic algorithms
20:35:33 <mgsloan> then again eeryone will need to buy uber computers to have reasonable compile times
20:35:41 <SamB_XP> ... wouldn't you need analog properties for that?
20:35:47 <Korollary> not everyone. just those who are rich and dont want to think.
20:35:48 <jcreigh> okay, so djinn has some Prelude functions and whatnot as axioms, and then and then tries to prove the type you given via some clever methods from Propositional Calculus?
20:35:52 <sjanssen> might be tough to generate "main :: IO ()" for many programs
20:35:53 <mgsloan> korrolary - nah ant colony would be better
20:35:57 <chessguy> not if you use genetic programming instead of genetic algorithms :)
20:36:21 <jcreigh> s/\(and then \)\1/\1/
20:36:23 <SamB_XP> Korollary: you jest, surely!
20:36:32 <SamB_XP> properties involve more thinking than code!
20:36:45 <Excedrin> main :: IO () should result in simply putStrLn "Hello, World!"
20:37:54 <sjanssen> SamB_XP: but you ought to write properties regardless, so it's less work in the end
20:38:10 <SamB_XP> well, true
20:38:13 <SamB_XP> but I so rarely do
20:38:18 <SamB_XP> especiall for monadic stuff
20:38:44 <Korollary> it need not be quickcheck properties, it could also be simple testcases.
20:46:54 <heatsink> Can type synonyms be declared at a scope smaller than a module?
20:47:36 <sjanssen> no
20:47:57 <heatsink> hm, ok
20:55:53 <dons> sjanssen: we just need lexically scoped classes with associated types ;)
20:59:34 <Cale> wow, did I ever go on a long rant there
20:59:43 <Cale> http://programming.reddit.com/info/t3xg/comments
20:59:46 <lambdabot> Title: MSU also switching intro CS classes to Python (and has some questions) (reddit.c ..., http://tinyurl.com/sugzc
21:00:46 <dons> I'm just glad to be at a school where we still teach foundational material to beginners ... :|
21:01:32 <Excedrin> I don't think I'd write any reply to someone who says, "PHP is my favorite language..."
21:01:43 <Nafai> Heh
21:02:12 <jcreigh> Excedrin: yeah, that triggered my "automatic downmod" reflex.
21:02:21 <dons> I worry a bit about the understanding of types that teaching newbies python will bring. At least they get a grasp using Java
21:02:34 <Cale> That's true
21:02:40 <dons> though scheme has been used of course, for millenia
21:02:43 <Excedrin> Python's type stuff is weird and inconsistent
21:02:45 <Cale> right
21:03:20 <Cale> Yeah, I recall laughing pretty hard when I read the section of the python manual on types :)
21:03:49 <Cale> But if they ignore that, they might manage to get some decent things in.
21:04:36 <Ugarte> Excedrin: What are you referring to?
21:05:36 <Nafai> There wouldn't happen to be any Haskell libraries for charting, would there?
21:06:04 <Ugarte> What do you mean, charting?
21:06:45 <Nafai> producing bar charts, plots, pie charts, etc
21:07:26 <Cale> http://dockerz.net/software/chart.html
21:07:28 <lambdabot> Title: A haskell chart library
21:07:54 <Cale> It's something, anyway :)
21:08:47 <Nafai> Might do what I want, thanks
21:09:13 <dons> Nafai: there's also a binding to gnuplot around
21:09:29 <Excedrin> Ugarte: I've always thought that type(type) should return <type 'function'> for example. Then there's str, int, tuple, etc in __builtins__ but no "module", so checking if something is of module type requires using type(__builtins__) or something
21:11:04 <Excedrin> it's also weird that an instance returns <type 'instance'> instead of the class, but I guess that's changing
21:11:35 <Ugarte> Excedrin: Those are valid points, but I don't really find them that bothersome.
21:18:45 <Ugarte> Excedrin: I mean, the type(type) thing is more a complaint about inconsistent naming, since "type" is also the name of a type.
21:18:49 <Ugarte> *shrug*
21:20:36 <campusblo> hi folks im back
21:20:47 <campusblo> trying to learn the language
21:21:16 <campusblo> so first question. how do i take a list member out of a list of strings if i know the member name
21:21:57 <campusblo> i.e. ["1","2","3","4"] and i want to remove 3
21:22:10 <dons> remove it and return what? the list , or the element 3?
21:22:20 <dons> > find (=="3") ["1","2","3","4"]
21:22:21 <lambdabot>  Just "3"
21:22:22 <campusblo> return the list without the element
21:22:29 <dons> > filter (=="3") ["1","2","3","4"]
21:22:31 <lambdabot>  ["3"]
21:22:34 <dons> > filter (/="3") ["1","2","3","4"]
21:22:35 <lambdabot>  ["1","2","4"]
21:22:49 <campusblo> ok i guess that works
21:22:54 <darkdescendant> Hey all
21:22:55 <campusblo> the filter
21:22:55 <dons> ?docs Data.List
21:22:56 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
21:23:05 <dons> ^^ lots of string functions to learn
21:23:19 <darkdescendant> Got a type question (type conversion actually)
21:23:28 <dons> great
21:23:36 <darkdescendant> I have the following function defintiions:
21:23:37 <darkdescendant> ft p0 v0 a t = p0 + v0 * t1 - 0.5 * a * t1^2 where t1 = t/1000
21:23:37 <darkdescendant> f n = (map (ft 1000 0 9.8) [0..] ) !! n
21:23:44 <dons> ah yes, yo udo :)
21:23:52 <kosmikus> dons: ask me about what?
21:24:17 <darkdescendant> Basically, I am calculating a time based value where t is given in milliseconds.
21:24:17 <lispy> wasn't someone asking this same function defition question last night?
21:24:30 <darkdescendant> Yeah, me, but that was just to get it working. :-)
21:24:59 <dons> kosmikus: oh, people were wondering about having an optional irc nick field in the HCAR
21:25:05 <dons> so that they'd be able to associate names and nicks :)
21:25:19 <campusblo> so i want to call this filter deleteString
21:25:31 <dons> campusblo: ok.
21:25:49 <kosmikus> dons: maybe it'd be better to have a list of the HCAR-relevant nicks in the #haskell entry?
21:25:49 <campusblo> where a deleteString will do  filter (/="3") ["1","2","3","4"]
21:25:57 <darkdescendant> What I would like is to be able to give the time in seconds instead. 14.2 instead of 14200. I know that !! n requires an Int value so 14.2 won't work directly.
21:25:58 <dons> > let deleteString x s = filter (/= x) s in deleteString "foo" ["a","b","foo","c"]
21:25:59 <lambdabot>  ["a","b","c"]
21:26:05 <kosmikus> dons: but in general, I'm not opposed to it. people just have to do it :)
21:26:16 <dons> kosmikus: ok.
21:26:45 <dons> darkdescendant: so use Double?
21:27:02 <dons> > fromIntegral (14200::Int) / 1000
21:27:03 <darkdescendant> However, I have been unable to figure out how to get the fractional value 14.2 and turn it into 14200. Even if I multiply by 1000 I still get an error indexing the list.
21:27:04 <lambdabot>  14.2
21:27:15 <dons> > printf "%3f" (fromIntegral (14200::Int) / 1000 :: Double) :: String
21:27:16 <lambdabot>  "14.2"
21:27:21 <dons> > printf "%.2f" (fromIntegral (14200::Int) / 1000 :: Double) :: String
21:27:22 <lambdabot>  "14.20"
21:27:23 <campusblo> damn you guys are fast
21:27:30 <campusblo> do i have to define s as a string?
21:27:40 <dons> campusblo: it could be any list
21:27:54 <dons> campusblo: have a go at writing it now you've seen the idea.
21:28:02 <campusblo> ok thanks
21:28:10 <dons> you can always paste any problems you have:
21:28:11 <dons> ?paste
21:28:11 <lambdabot> http://paste.lisp.org/new/haskell
21:28:13 <dons> that way
21:29:09 <darkdescendant> dons: How do you go the other way? Form 14.2 -> 14200::Int
21:30:28 <dons> > floor ((14.2::Double) * 1000) :: Int
21:30:29 <lambdabot>  14200
21:32:56 <campusblo> what's an IO?
21:32:57 <darkdescendant> dons: Thanx. I would never have gotten that.
21:33:49 <dons> campusblo: a type for code that does IO
21:33:51 <campusblo> as in deleteDataBase :: DataBase -> IO()
21:34:07 <dons> campusblo: so that's a function that takes a value of type DataBase, and does some IO with it
21:34:18 <dons> campusblo: check out http://haskell.org, and start reading:
21:34:19 <lambdabot> Title: Haskell - HaskellWiki
21:34:19 <dons> ?where yaht
21:34:20 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
21:34:21 <Excedrin> :t (!!)
21:34:27 <Excedrin> @type (!!)
21:34:29 <lambdabot> forall a. [a] -> Int -> a
21:34:32 <campusblo> that answer sounds like a recursion :)
21:34:52 <Excedrin> darkdescendant: note that the index is Int, but the list is of any type
21:36:33 <dons> campusblo: well, here's a really quick intro: Haskell distinguishes by type code that does IO
21:36:36 <dons> > getLine
21:36:37 <Excedrin> hrm, actually ignore me, I think I misunderstood what you were asking
21:36:38 <lambdabot>  <IO [Char]>
21:36:44 <dons> does some IO, and returns a list of characters
21:36:50 <dons> ?type putStr
21:36:51 <lambdabot> String -> IO ()
21:36:59 <dons> takes a String, and prints it out, doing some IO, and returns ()
21:37:14 <dons> so you can tell by the type if any code does IO. this is a really useful property
21:37:39 <dons> for more info, you best grab a textbook or a tut, and start hacking
21:38:01 <campusblo> ok i think i get the idea
21:39:00 <campusblo> but i dont get this here deleteTable :: DataBase -> TableName->IO()
21:39:11 <campusblo> thats for deleting a table from a database
21:39:17 <campusblo> should it not return a database?
21:39:20 <dons> ok, so that function takes 2 arguments, a DataBase, and a TableName, and does some IO with it
21:39:28 <dons> looks like it mutates the database in place
21:39:52 <dons> I presume this code is talking to an external database?
21:39:58 <campusblo> yes
21:40:32 <campusblo> when you say mutates the database in place?
21:41:06 <campusblo> it deletes a table from a database but doesnt produce a database. thats why im confused
21:41:31 <Excedrin> do you understand IO?
21:41:50 <campusblo> nope
21:42:00 <dons> more reading first then!
21:42:10 <campusblo> im guessing it means prints to a screen or something
21:42:14 <dons> since irc is not going to be the place to understand this stuff. fire up ghci, and start typing things in.
21:43:07 <campusblo> where can i get IO functions to try?
21:43:31 <dons> you have ghci or hugs installed?
21:43:38 <campusblo> yes
21:44:01 <dons> Prelude> :t putStrLn
21:44:01 <dons> putStrLn :: String -> IO ()
21:44:01 <dons> Prelude> putStrLn "hello, world"
21:44:01 <dons> hello, world
21:44:15 <dons> but you'll want a tutorial. YAHT is a good one. there's lots of others on haskell.org
21:44:18 <dons> ?where yaht
21:44:18 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
21:44:21 <dons> ^^ so grab that
21:44:36 <campusblo> thanks
21:45:02 <Excedrin> http://haskell.org/hoogle/?q=IO
21:45:04 <lambdabot> Title: IO - Hoogle
21:46:10 <dons> Cale: more code for you to write: http://clintons-cpp-examples.blogspot.com/2006/11/braille-encoder.html
21:46:13 <lambdabot> http://tinyurl.com/y9hu5a
22:05:44 <smithll> f :: Int -> [Int]
22:05:44 <smithll> f x = [1+x,2*x]
22:05:44 <smithll> return 5 >>= f >>= f
22:15:27 <smithll> :t ($)
22:15:32 <dons> ?type ($)
22:15:33 <lambdabot> forall b a. (a -> b) -> a -> b
22:15:47 <dons> > let f x = [1+x,2*x] in return 5 >>= f >>= f
22:15:48 <lambdabot>  [7,12,11,20]
22:16:02 <dons> ?pl let f x = [1+x,2*x] in return 5 >>= f >>= f
22:16:03 <lambdabot> liftM2 (:) (1 +) (return . (2 *)) =<< [6, 10]
22:16:07 <dons> huh
22:16:13 <dons> > liftM2 (:) (1 +) (return . (2 *)) =<< [6, 10]
22:16:15 <lambdabot>  [7,12,11,20]
22:16:35 <smithll> dons Do you get that?
22:17:05 <dons> that's not too bad I guess. list monad fun
22:17:12 <dons> I wouldn't write it though..
22:17:18 * lispy either
22:17:27 <dons> ?type liftM2 (:) (1 +) (return . (2 *))
22:17:29 <lambdabot> forall a. (Num a) => a -> [a]
22:17:38 <dons> ?type liftM2 (:) (1 +) (return . (2 *)) 2
22:17:39 <lambdabot> forall a. (Num a) => [a]
22:17:43 <dons> liftM2 (:) (1 +) (return . (2 *)) 2
22:17:48 <dons> > liftM2 (:) (1 +) (return . (2 *)) 2
22:17:49 <lambdabot>  [3,4]
22:17:55 <dons> cute
22:18:07 <dons> > liftM2 (,) (1 +) (return . (2 *)) 2
22:18:08 <lispy> if it uses instance Monad ((->) r), then i don't like to use it in real code...yet :)
22:18:08 <lambdabot>  add an instance declaration for (Show (m a))
22:18:44 <dons> > ((+1) *** (2*)) (2,2)
22:18:45 <lambdabot>  (3,4)
22:18:49 <dons> ?pl ((+1) *** (2*)) (2,2)
22:18:49 <lambdabot> ((1 +) *** (2 *)) (2, 2)
22:19:04 <dons> ?pl \x -> (x,x)
22:19:05 <lambdabot> join (,)
22:19:14 <dons> > ((+1) *** (2*)) . join (,) $ 2
22:19:15 <lambdabot>  (3,4)
22:23:37 <dons> smithll: you learning haskell?
22:23:58 <protoscript> I'm going crazy
22:24:10 <protoscript> If I run everything from my command line
22:24:16 <protoscript> ghci loads my file correctly
22:24:34 <dons> ?paste the error please
22:24:34 <lambdabot> http://paste.lisp.org/new/haskell
22:24:45 <dons> (I'm guessing there's an error...?)
22:25:34 <lisppaste2> protoscript pasted "my folly" at http://paste.lisp.org/display/31089
22:25:48 <protoscript> when i load it from xemacs, using run-haskell, it won't load
22:26:15 <dons> can you try removing the quotes?
22:26:18 <dibblego> did you use -v as suggested?
22:26:23 <protoscript> yes
22:26:27 <protoscript> but when I do that, it works
22:26:41 <smithll> Yes working through the monad thing.
22:26:48 <smithll> http://www.alpheccar.org/en/posts/show/60
22:26:52 <lambdabot> Title: A newbie in Haskell land or another monad tutorial
22:26:52 <dons> smithll: cool. how's the experience?
22:27:01 <dons> yeah, that's a nice little demo
22:27:13 <smithll> mind expanding :-)
22:27:22 <dons> ?type runReader
22:27:24 <lambdabot> forall a r. Reader r a -> r -> a
22:27:31 <dons> ?type flip runReader
22:27:33 <lambdabot> forall a b. b -> Reader b a -> a
22:27:42 <protoscript> ah i think i did something wrong before
22:27:47 <protoscript> i will create a new paste
22:27:51 <dons> > flip runReader 0 $ do x <- asks ; return (x+1)
22:27:52 <lambdabot>  Couldn't match `Reader b' against `(->) (r -> a)'
22:28:01 <dons> > flip runReader 0 $ do x <- ask ; return (x+1)
22:28:02 <lambdabot>  1
22:28:15 <dons> > flip runState 0 $ do x <- ask ; put (x+1) ; return "done"
22:28:15 <lambdabot>  add an instance declaration for (MonadReader r (State r))
22:28:16 <lambdabot>   In a 'do' exp...
22:28:20 <lisppaste2> protoscript pasted "my folly v2" at http://paste.lisp.org/display/31090
22:28:22 <dons> > flip runState 0 $ do x <- get ; put (x+1) ; return "done"
22:28:23 <lambdabot>  ("done",1)
22:28:48 <dons> protoscript: the quotes ..
22:28:51 <dons>   locations searched:
22:28:51 <dons>     "C:\code\haskell\exercise/hs".hs
22:29:04 <dons> you can't use quotes there.
22:29:20 <dons> I think that you can now use quotes in a recent ghc 6.6 snapshot
22:29:20 <protoscript> but that's the thing, I am not entering those... xemacs is, based on the name of my file, I guess
22:29:36 <dons> ah ok.
22:29:42 <dons> so perhaps ask on haskell-cafe@haskell.org then
22:29:48 <protoscript> notice between exercise and hs
22:30:01 <protoscript> thanks I will try that
22:30:03 <dons> the mode author can probably advise you. you have the latest haskell-mode code?
22:30:21 <protoscript> probably not.. i
22:30:31 <protoscript> 'm still using the fmost recent stable release
22:30:44 <dons> ok. try that first
22:31:16 <protoscript> of course ... :-) thanks for all of your help
22:41:16 <vegaiW> Hey. Can lambdabot still be built without hs-plugins?
22:56:47 <Excedrin> vegaiW: yes
23:06:37 <campusblo> where can i get a list of the prelude functions and how they are built?
23:06:49 <vegaiW> Excedrin: Ok, great. :)
23:07:13 <Excedrin> campusblo: http://www.haskell.org/ghc/docs/latest/html/libraries/
23:07:15 <lambdabot> http://tinyurl.com/ojrj6
23:07:30 <Excedrin> campusblo: I'm not sure if that's what you want
23:08:01 <campusblo> what i want is to actually be able to see how theh prelude functions work
23:08:47 <Excedrin> http://darcs.haskell.org/packages/base/Prelude.hs
23:08:50 <lambdabot> http://tinyurl.com/yncerr
23:09:00 <Excedrin> @source Prelude
23:09:01 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
23:09:04 <Excedrin> @source Data.List
23:09:05 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
23:09:08 <Excedrin> etc
23:09:46 <campusblo> ok thanks
23:12:32 <campusblo> how do i add a list to a list of lists?
23:12:54 <campusblo> any suggestions?
23:12:56 <Excedrin> > "foo" ++ "bar"
23:12:58 <lambdabot>  "foobar"
23:13:28 <Excedrin> @type "foo"
23:13:30 <lambdabot> [Char]
23:13:30 <newsham> hi
23:13:41 <newsham> @type quickly
23:13:42 <lambdabot> Not in scope: `quickly'
23:13:49 <Excedrin> @type (++)
23:13:51 <lambdabot> forall a. [a] -> [a] -> [a]
23:14:13 <newsham> @type battleship in range, prepare to fire.
23:14:15 <lambdabot> parse error on input `in'
23:14:34 <newsham> @type battleship sited prepare to fire
23:14:36 <lambdabot> Not in scope: `battleship'
23:14:37 <lambdabot>  
23:14:37 <lambdabot> <interactive>:1:11: Not in scope: `sited'
23:15:54 <campusblo> [["1","2"],["3","4"]]["5","6"] to [["1","2"],["3","4"],["5","6"]]
23:16:38 <Excedrin> reread ^^
23:16:47 <campusblo>  [["1","2"],["3","4"]] -> ["5","6"] -> [["1","2"],["3","4"],["5","6"]]
23:17:06 <campusblo> thats what i want to do add a list to a list of lists
23:17:54 <campusblo> any suggestions?
23:18:07 <Excedrin> yes, reread what I said a few lines back
23:18:12 <newsham> > [["1"], ["2","3"]] ++ [["4"], ["5", "6"]]
23:18:14 <lambdabot>  [["1"],["2","3"],["4"],["5","6"]]
23:18:37 <campusblo> oh ok
23:19:12 <campusblo> thanks
23:26:24 <newsham> added xsrf protection to my happs stuff
23:32:23 <Excedrin> newsham: are you using darcs?
23:34:11 <newsham> no
23:34:15 <newsham> cvs currently
23:34:53 <lispy> tailor!
23:35:02 <lispy> ... will convert your cvs to darcs
23:38:37 <newsham> how many councellors does it take to change a lightbulb?  one, but the lightbulb has to want to change.
23:40:07 <Pete_I> that's funny
23:40:42 <newsham> it also explains why i'm not changing to darcs.
23:41:25 <earthy> cvs?!
23:41:29 <Excedrin> I downloaded the .tgz that you linked a while ago, the templating stuff is interesting
23:41:30 <earthy> wow. that's like... ancient
23:41:45 <Excedrin> Templs.hs doesn't need to import HAppS
23:43:48 <newsham> yah, templs is using standard ghc library Text.Html
23:44:52 <newsham> there's also HSP for doing server-side pages.. i havent used it, but it looks like it has a nice syntax
23:44:55 <newsham> ?where hsp
23:44:56 <lambdabot> http://www.cs.chalmers.se/~d00nibro/hsp
23:46:20 <newsham> I was going to try to use XSLT for templating but it seemed like a chore to get it to do what i wanted
23:46:30 <newsham> especially when i want some templates to be able to call other templates
23:46:54 <newsham> using haskell felt a little weird at first, but after getting used to the Text.Htlm library, its really easy to use
23:47:17 <Excedrin> I wrote a HAppS app that I posted to the Haskell-cafe, I used Text.Html too, but I assumed xslt was the "right" thing
23:47:41 <newsham> yah, thats the impression I got from their tutorial.
23:48:06 <newsham> which is why i started investigating it.  i talked to my brother who does web devel a little and he seemed to think xslt wasnt that great, too.
23:48:40 <lispy> newsham: yeah, just want to make sure you know there are tools to facilitate a change if you want to change
23:48:56 <newsham> lispy: ty.
23:49:25 <mgsloan> xslt is generally pretty verbose for simple operations, but can be elegant it the sense of doing everything in one thing, XML, which isn't a very elegant format
23:49:36 <Excedrin> my app is simpler than yours I think, but it's here if you'd like to take a look at it: http://harlan.lerp.com/~sic/ladder/
23:49:38 <lambdabot> Title: Index of /~sic/ladder
23:50:00 <lispy> mgsloan: heh
23:50:16 <lispy> mgsloan: and if you like discarding safety in your transformations
23:50:40 <lispy> mgsloan: Oh, and don't mind spending a hour tweaking the whitespace in the output
23:50:43 <mgsloan> I saw a thing comparing XML and s-expr, and people argued "but lisp is a language!".  What's funny is Lisps s-expr are basically a data format.
23:50:45 <newsham> mgsloan: for simple templates seemed ok.
23:50:47 <Excedrin> http://harlan.lerp.com:9990/ <- to see the actual app
23:50:48 <mgsloan> hehe yeah :)
23:51:02 <newsham> but what if you build one template, and you have another template that wants to call it 3 times with different bodies and parameters?
23:51:14 <lispy> mgsloan: yeah, i've heard that argument too...it's on a wiki about refactoring right?
23:51:22 <mgsloan> I have no idea, I tried to use it once and wrote a program instead
23:51:33 <lispy> mgsloan: me too
23:52:02 <newsham> for exapmle, I have a page template which calls a header and a footer template, and a section template.  the section template calls a links template
23:52:12 <newsham> inside the body of each page, I use the section template many times
23:52:37 <newsham> xslt doesnt handle that very well
23:52:45 <newsham> I wish it did..
23:53:02 <Excedrin> if you don't mind sharing, could you make another tgz? I'd like to see the updates
23:53:25 * mgsloan attempts to locate xml/s-expr thing
23:53:27 <newsham> i'm not working on the same example code.  i could port my changes to it, but it would take a while.
23:53:39 <mgsloan> was really recent, like a blog post maybe
23:53:59 <Excedrin> nah, don't bother... are there changes to the templating stuff since then?
23:59:08 <mgsloan> hmm, ohwell
23:59:45 <mgsloan> s-exprs should have become the standard markup though
