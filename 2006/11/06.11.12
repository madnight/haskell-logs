00:03:12 <dobblego> can you use guards with ghci?
00:03:37 <dons> > f x | x = True | otherwise = False in f True -- yes ?
00:03:38 <lambdabot>  Parse error
00:03:43 <dons> > let f x | x = True | otherwise = False in f True -- yes ?
00:03:44 <lambdabot>  True
00:03:53 <dobblego> gah forgot let
00:04:01 <dobblego> ta
00:04:03 <dons> Cale: also want to add:
00:04:03 <dons> -- | @'forever' act@ repeats the action infinitely.
00:04:04 <dons> forever     :: (Monad m) => m a -> m ()
00:04:04 <dons> forever a   = a >> forever a
00:04:07 <dons> opinions?
00:04:20 <Cale> yes :)
00:05:08 <dons> what about the >=> syntax (versus =>>= and more traditional @@ suggested a few weeks ago)?
00:05:31 <dons> I think 4 chars is no good for composition
00:05:37 <dons> and arrows have >>> iirc?
00:05:47 <dons> ?type (Control.Arrow.>>>)
00:05:49 <lambdabot> forall (a :: * -> * -> *) d b c. (Arrow a) => a b c -> a c d -> a b d
00:06:26 <dolio> >>> is what that is if you already have a (Kleisli m).
00:06:40 <dolio> But having it for a -> m b could be handy, too.
00:06:46 <dons> yeah.
00:07:44 <dons> so i'm interested in identifier preferences. see this thread: http://www.haskell.org/pipermail/libraries/2006-October/006049.html
00:07:46 <lambdabot> Title: Speaking of small functions, http://tinyurl.com/y5g8hy
00:08:09 <Cale> I actually don't mind most of those options for Kleisli composition, though @@ does seem traditional
00:08:45 <dons> right, but then the flipped version doesn't have a good form?
00:09:00 <dons> otherwise, I'd prefer the traditional @@
00:09:09 <dons> >=>, <=< seems kind of nice
00:09:17 <dons> also, do we want to play any fixity games?
00:09:42 <dons> we have: infixr 1 <<<, ^<<, <<^, infixr 1 =<<
00:10:01 <dons> so that might be appropriate for <=< and >=>
00:17:24 <dons> interesting, http://www.indeed.com/jobtrends?q=haskell
00:17:26 <lambdabot> Title: haskell Job Trends | Indeed.com
00:18:42 <Saulzar> Trouble is a lot of those are probably from recruiters who's name is Haskell...
00:18:49 <dons> yeah
00:19:05 <Saulzar> I had a search a while ago, looking for a job - just about anything turning up was because their name was Haskell
00:19:19 <dons> at least things are heading in the right directoin, http://www.indeed.com/jobtrends?q=C%2B%2B%2C+java
00:19:22 <lambdabot> Title: C++, java Job Trends | Indeed.com, http://tinyurl.com/vopze
00:19:43 <Saulzar> Or included in a list of, "bonus to know any of : awk, sed, perl, QBASIC, COBOL or Haskell" :)
00:19:56 <dons> and http://www.indeed.com/jobtrends?q=perl
00:19:57 <lambdabot> Title: perl Job Trends | Indeed.com
00:20:14 <dons> so at least haskell and ruby are trending up, http://www.indeed.com/jobtrends?q=ruby
00:20:16 <lambdabot> Title: ruby Job Trends | Indeed.com
00:20:52 <Saulzar> Hmm, interesting...
00:21:06 <dons> http://www.indeed.com/jobtrends?q=haskell%2C+erlang%2C+ocaml%2C+lisp
00:21:07 <therp> but "dead" seems to be a more important property than Haskell and Ruby
00:21:09 <lambdabot> Title: haskell, erlang, ocaml, lisp Job Trends | Indeed.com, http://tinyurl.com/yc5u9n
00:21:12 <dons> heh
00:21:37 <dons> so being dead might be a good career move
00:21:53 <therp> probably the last one
00:22:00 <Saulzar> I've been doing C++ stuff, realistically I don't see any possibility with interesting programming languages other than academic stuff
00:22:01 <dons> the big spike in dead programmers seems to have been back on 05 though
00:22:09 <johnnowak> clearly Scheme is the way to go: http://tinyurl.com/ykj3lg
00:22:11 <lambdabot> Title: haskell, erlang, ocaml, lisp, scheme Job Trends | Indeed.com
00:22:12 <therp> dons: certainly true for artists
00:22:38 <dons> Saulzar: but you know about the various hard-edge defence/verificatoin companies using haskell now, along with the big financial places like credit suisse and jane st?
00:23:05 <roconnor> http://www.indeed.com/jobtrends?q=haskell%2C+erlang%2C+ocaml%2C+lisp%2C+sml
00:23:07 <lambdabot> Title: haskell, erlang, ocaml, lisp, sml Job Trends | Indeed.com, http://tinyurl.com/yd9ctg
00:23:25 <dons> scheme e?  :)
00:23:29 <dons> s/eh/
00:23:42 <johnnowak> dons: whatever brings in the money :)
00:24:03 <dons> so hmm. haskell is approaching lisp /sml mainstream-ness?
00:24:11 <Saulzar> Yeah, I've seen that - but it's fairly specialised kind of stuff.
00:24:14 <dons> pretty good for a new language
00:25:05 <dons> I think experience counts for a lot.I can't really imagine doing anything *new* in anything but haskell.
00:30:51 <dons> http://www.google.com/trends?q=lisp&ctab=2&geo=all&date=all   ;)
00:30:53 <lambdabot> Title: Google Trends: lisp, http://tinyurl.com/uy7wa
00:31:06 <dons> (the haskell results are highly obfuscated by noise0
00:33:39 <EvilRanter> hm. winhugs can't cope with (repeat getLine), apparently
00:33:48 <dons> ~how so?
00:34:05 <dons> ?type repeat getLine
00:34:07 <lambdabot> [IO String]
00:34:26 <EvilRanter> Hugs> repeat getLine
00:34:26 <EvilRanter> [primbindIO (hGetChar stdin) (hGetLine_v1068 ((catch (hGetChar stdin) $ hGetLine_v1066) >>= hGetLine_v1065 ((catch (hGetChar stdin) $ hGetLine_v1066) >>= hGetLine_v1065 ((catch (hGetChar stdin) $ hGetLine_v1066) >>= hGetLine_v1065 ((catch (hGetChar stdin) $ hGetLine_v1066) >>= hGetLine_v1065 ((catch (hGetChar stdin) $ hGetLine_v1066) >>=...
00:34:33 <dons> ?t (sequence . repeat) getLine
00:34:33 <EvilRanter> ad infinitum
00:34:33 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
00:34:40 <dons> huh. nice!
00:34:52 <dons> ?type  (sequence . repeat) getLine
00:34:53 <lambdabot> IO [String]
00:34:55 <dons> is probably more useful?
00:35:05 <EvilRanter> hugs.exe works, winhugs.exe don't.
00:35:12 <dons> better report the bug.
00:35:25 <dons> hugs-bugs@ ?
00:35:37 <EvilRanter> @hugs-bugs
00:35:37 <Cale> hehe, it's printing the IO actions?
00:35:38 <lambdabot> Unknown command, try @list
00:35:50 <dons> <hugs-bugs@haskell.org>
00:35:56 <dons> Cale: yeah, I think so?
00:36:01 <weitzma1> For the record, it works fine for me in the May 2006 WinHugs on XP
00:36:02 <dons> I presume there's some error msg at the end?
00:36:13 <EvilRanter> dons, {Interrupted} :P
00:36:26 <dons> Hugs.Base> repeat getLine
00:36:26 <dons> ERROR - Cannot find "show" function for:
00:36:26 <dons> *** Expression : repeat getLine
00:36:26 <dons> *** Of type    : [IO String]
00:36:57 <dons> not that even (sequence . repeat) getLine is terribly useful..
00:37:17 <EvilRanter> actually, nm. I think the problem was that I was trying to show it directly
00:37:28 <EvilRanter> "do xs <- sequence $ repeat getLine; return xs" works fine
00:37:33 <dons> still, *weird*
00:37:40 <dons> should at least report the missing show instance
00:39:01 <EvilRanter> for [IO String]?
00:41:49 <dons> > repeat getLine
00:41:50 <lambdabot>  No IO allowed
00:42:06 <dons> Prelude> repeat getLine
00:42:06 <dons> Top level:
00:42:06 <dons>     No instance for (Show (IO String))
00:42:20 <dons> Hugs.Base> repeat getLine
00:42:20 <dons> ERROR - Cannot find "show" function for:
00:42:20 <dons> *** Expression : repeat getLine
00:42:20 <dons> *** Of type    : [IO String]
00:42:32 <EvilRanter> is sequence strict?
00:42:45 <dons> and even:
00:42:47 <dons> $ hbi
00:42:47 <dons> Welcome to interactive Haskell98 version 0.9999.5c Pentium 2004 Jun 29!
00:42:48 <dons> Loading prelude... 1 values, 4 libraries, 200 types found.
00:42:49 <dons> Type "help;" to get help.
00:42:51 <dons> > repeat getLine
00:42:52 <lambdabot>  No IO allowed
00:42:53 <dons> # ;
00:42:56 <dons> Error: Internal error: id lookup: VV`Prelude.Show`_LibIO.IO~a
00:42:58 <dons> :)
00:43:18 <dons> sequence forces the list argument
00:43:23 <dons> ?type sequence
00:43:24 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
00:43:47 <EvilRanter> > const () undefined
00:43:48 <lambdabot>  ()
00:44:06 <EvilRanter> > const () $ sequence [return undefined]
00:44:07 <lambdabot>  Add a type signature
00:44:19 <EvilRanter> > const () $ sequence [return undefined :: IO()]
00:44:20 <lambdabot>  ()
00:44:37 <EvilRanter> wait, that does't help...
00:45:29 <EvilRanter> > sequence [return (), return undefined :: IO()] >>= return . (!! 0)
00:45:30 <lambdabot>  No IO allowed
00:47:41 * EvilRanter is trying to work out if lines <- liftM (takeWhile $ not.null) (sequence $ repeat getLine) should work
00:47:54 <EvilRanter> it seems to not stop getting input at a blank line
00:49:57 <EvilRanter> or rather, trying to work out why it doesn't work
00:50:01 <dons> *Main> main >>= print
00:50:01 <dons> s
00:50:01 <dons> d
00:50:01 <dons> f
00:50:01 <dons> ["s","d","f"]
00:50:08 <dons> main = loop []
00:50:08 <dons> loop xs = do
00:50:08 <dons>     s <- getLine
00:50:08 <dons>     case s of
00:50:09 <dons>         [] -> return (reverse xs)
00:50:11 <dons>         x  -> loop (x:xs)
00:50:14 <dons> then refactor :)
00:50:34 <EvilRanter> I've got that already
00:50:42 <EvilRanter> I was trying to write it without manual recursion
00:51:41 <EvilRanter> well,
00:51:41 <EvilRanter> loop = do line <- getLine; if null line then return [] else liftM (line:) loop
00:51:59 <xinming> lisppaste2: url
00:51:59 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
00:54:56 <dons> EvilRanter: well one step would be to factor out your own control structure:
00:54:59 <dons> main = untilNull getLine
00:54:59 <dons> untilNull f = loop []
00:54:59 <dons>   where
00:54:59 <dons>      loop xs = do
00:54:59 <dons>         s <- f
00:55:01 <dons>         case s of
00:55:04 <dons>             [] -> return (reverse xs)
00:55:06 <dons>             x  -> loop (x:xs)
00:55:55 <dons> the problem is that you need to short circuit before you run sequence.
00:56:14 <EvilRanter> sequence forces evaluation of its args, then?
00:57:27 <dons> yeah, it has to force the actoins in the list.
00:57:35 <dons> you can see that here:
00:57:35 <dons> untilNull f = do
00:57:36 <dons>     s <- sequence (repeat f)
00:57:36 <dons>     return (takeWhile (not.null) s)
00:57:47 <dons> now, there should be a way to write this though...
00:58:28 <EvilRanter> @hoogle (m a -> m b) -> m (a -> b)
00:58:29 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
00:58:29 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
00:58:29 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
01:01:06 <weitzma1> For an unsatisfying solution, you could use exceptions
01:01:35 <EvilRanter> eew
01:05:11 <EvilRanter> "liftM (not.null) getLine" works for one line
01:05:53 <EvilRanter> but is "liftM (p::Bool)" transformable to be a suitable argument to takeWhile?
01:06:37 <EvilRanter> @type liftM (0==)
01:06:38 <lambdabot> forall a1 (m :: * -> *). (Monad m, Num a1) => m a1 -> m Bool
01:06:43 <EvilRanter> @type takeWhile
01:06:45 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
01:07:32 <lispy> ?type liftM2 takeWhile
01:07:34 <lambdabot> forall a (m :: * -> *). (Monad m) => m (a -> Bool) -> m [a] -> m [a]
01:08:13 <lispy> why are you lifting (0==) ?
01:08:38 <EvilRanter> for an arbitary example of (p::a->Bool)
01:08:48 <EvilRanter> (which is what p should've been above)
01:09:32 <dons> ?type takeWhile
01:09:34 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
01:09:52 <lispy> i don't see "liftM (not.null) getLine" in the above code
01:10:08 <EvilRanter> that's cos it's not there
01:10:49 <lispy> i like what dons pasted
01:10:52 <lispy> 00:57 <dons> untilNull f = do
01:10:52 <lispy> 00:57 <dons>     s <- sequence (repeat f)
01:10:53 <lispy> 00:57 <dons>     return (takeWhile (not.null) s)
01:11:12 <EvilRanter> that goes on forever, 'cos of sequence's behaviour
01:11:17 <EvilRanter> otherwise it'd do nicely
01:11:36 <lispy> ah okay
01:11:48 <EvilRanter> I was saying that "liftM (not.null) getLine" works for one line of input
01:11:54 <EvilRanter> and I'm trying to extend it to N lines
01:13:04 <lispy> ?type liftM (not.null) getLine
01:13:06 <lambdabot> IO Bool
01:13:41 <EvilRanter> so can i somehow get takeWhile to interface with an IO Bool instead of a Bool as the first argument?
01:13:56 <EvilRanter> sorry,
01:14:10 <EvilRanter> IO a->IO Bool rather than a->Bool
01:14:11 <dons> perhaps,
01:14:13 <dons> main = repeatWhileM (not.null) getLine
01:14:13 <dons> repeatWhileM :: Monad m => (a -> Bool) -> m a -> m [a]
01:14:13 <dons> repeatWhileM p a = loop []
01:14:13 <dons>   where
01:14:15 <lispy> do b <- {- some IO Bool -}; takeWhile b ...
01:14:15 <dons>     loop xs = do
01:14:18 <dons>         v <- a
01:14:21 <dons>         if not (p v) then return (reverse xs) else loop (v:xs)
01:14:49 <lispy> ?type liftM2 takeWhile
01:14:50 <lambdabot> forall a (m :: * -> *). (Monad m) => m (a -> Bool) -> m [a] -> m [a]
01:15:04 <lispy> that version  does IO (a -> Bool)
01:15:37 <EvilRanter> yeah, I've already tried that. there doesn't seem to be soemthing that can take an IO a -> IO b and produce an IO(a -> b)
01:15:51 <dons> right.
01:15:51 <lispy> wasn't there a function for (m a -> m b) -> m (a -> b) ?
01:15:52 <EvilRanter> probably 'cos that would make very little sense, on reflection
01:16:04 <EvilRanter> lispy, I thought so, but i can't find it, now
01:16:29 <lispy> ?hoogle (m a -> m b) -> m (a -> b)
01:16:30 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
01:16:30 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
01:16:30 <lambdabot> Data.Generics.Schemes.everywhere' :: (a -> a) -> a -> a
01:17:27 <lispy> ?type liftM2 (==) (return 0)
01:17:29 <lambdabot> forall (m :: * -> *) a. (Monad m, Num a) => m a -> m Bool
01:17:53 <lispy> ?type liftM2 (==)
01:17:55 <lambdabot> forall a2 (m :: * -> *). (Monad m, Eq a2) => m a2 -> m a2 -> m Bool
01:20:07 <lispy> ?type \s -> s >>= liftM (not.null) >>= liftM2 takeWhile s
01:20:09 <lambdabot>   Couldn't match `m a2' against `Bool'
01:20:09 <lambdabot>    Expected type: Bool -> m1 b
01:20:22 <lispy> ?type \s -> s >>= liftM (not.null) >>= liftM2 (flip takeWhile) s
01:20:22 <dons> mmm http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.html
01:20:24 <lambdabot>   Couldn't match `m a2' against `Bool'
01:20:24 <lambdabot>    Expected type: Bool -> m1 b
01:20:25 <lambdabot> http://tinyurl.com/y6zbwc
01:20:28 <EvilRanter> I'm currently thinking something like takeWhile (liftM $ not.null) (repeat getLine)
01:20:32 <EvilRanter> but something that works
01:21:03 <robreim> @seen dcoutts
01:21:04 <lambdabot> dcoutts is in #darcs, #haskell-overflow, #haskell, #gentoo-haskell and #ghc. I last heard dcoutts speak 3h 52m 43s ago.
01:21:27 <lispy> ?hoogle whileM
01:21:28 <lambdabot> No matches found
01:21:30 <lispy> ?hoogle while
01:21:32 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
01:21:32 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
01:21:32 <lambdabot> Data.PackedString.dropWhilePS :: (Char -> Bool) -> PackedString -> PackedString
01:21:37 <lispy> ?hoogle until
01:21:38 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
01:21:38 <lambdabot> System.Win32.File.mOVEFILE_DELAY_UNTIL_REBOOT :: MoveFileFlag
01:21:52 <EvilRanter> intriguing. I guess dcoutts is the nocturnal sort...
01:22:12 <dons> heya alpheccar
01:22:19 <therp> what a strange win32 flag
01:22:19 <alpheccar> hi!
01:22:24 <dons> welcome!
01:22:39 <lispy> therp: yes, i have a quote about taht
01:22:43 <lispy> ?quote lispy
01:22:43 <lambdabot>  one thing that's funny about programming in haskell is, it's the only language i know where i sometimes rewrite code so it will work on 'inifinite' datastructures
01:22:51 <lispy> ?quote lispy
01:22:51 <lambdabot>  lambdabot, changing the way Haskllers think since 2003
01:22:51 <dons> > fix ((0:) . scanl (+) 1) -- have a lazy list on the house :)
01:22:53 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
01:23:00 <lispy> ?quote lispy
01:23:00 <lambdabot>  the biggest reason most developers i know don't fix a bug is because they don't know it exists yet
01:23:06 <lispy> ?quote lispy
01:23:07 <lambdabot>  a := new Maybe(); a.envalue(1);
01:23:12 <lispy> ?quote lispy
01:23:12 <lambdabot>  one thing that's funny about programming in haskell is, it's the only language i know where i sometimes rewrite code so it will work on 'inifinite' datastructures
01:23:18 <lispy> heh, never mind
01:23:28 <EvilRanter> ?quote EvilRanter
01:23:31 <dons> hmm, anyone ping haskell.org?
01:23:32 <lambdabot>  I find "your a moron! unban me, or i shall TAUNT YOU A SECOND TIME!!" to be a particularly poor attempt
01:23:55 <dons> ping seems ok. http seems down?
01:23:59 <dons> http://haskell.org -- :/
01:24:05 <EvilRanter> same here
01:24:30 <lispy> sad!
01:24:44 * dons mails the admins
01:25:02 <lispy> ah, well i said something to the effect of equating taht flag with vertical tab
01:25:15 <enolan> What does $= do inside a do?
01:25:32 * enolan is mucking with Frag
01:25:53 <dons> $ or $= ?
01:25:56 <dons> not sure what $= is
01:26:03 <lambdabot> enolan: You have 1 new message. '/msg lambdabot @messages' to read it.
01:26:16 <lispy> <lispy> in 80 years, when computers don't get booted or rebooted someone will send an email to a mail list and say, "Does anyone actually use vertical tabs??"
01:26:45 <EvilRanter> ?type ($=)
01:26:47 <lambdabot> Not in scope: `$='
01:26:56 <lispy> $= is usually a wrapper for some sort of write*Ref function
01:27:06 <EvilRanter> people ask that already
01:27:45 <lispy> right
01:29:24 <lispy> ?pl take 20 . filter (/=1) . map length . group . fix $ \s -> "\":\":" ++ concat (zipWith (\x y -> x ++ y ++ ":") (filter (/=":") (group s)) (tail (filter (/=":") (group s))))
01:29:28 <lambdabot> take 20 (filter (1 /=) (map length (group (fix (("\":\":" ++) . join . ap (zipWith ((. (++ ":")) . (++)) . filter (":" /=) . group) (tail . filter (":" /=) . group))))))
01:29:28 <lambdabot> optimization suspended, use @pl-resume to continue.
01:29:32 <lispy> so easy to read!
01:29:43 <lispy> optimizations suspended?
01:29:50 <lispy> ?pl-resume
01:29:52 <lambdabot> take 20 (filter (1 /=) (map length (group (fix (("\":\":" ++) . join . ap (zipWith ((. (++ ":")) . (++)) . filter (":" /=) . group) (tail . filter (":" /=) . group))))))
01:30:43 <lispy> interesing that @pl removes a lot of uses of (.)
01:31:51 <lispy> this is a useful little guy
01:31:51 <lispy> ((. (++ ":")) . (++))
01:32:26 <lispy> ?let appendBy b = ((. (++ b)) . (++))
01:32:28 <lambdabot> Defined.
01:32:48 <lispy> ?pl \b -> ((. (++ b)) . (++))
01:32:49 <lambdabot> (. (++)) . flip (.) . flip (++)
01:33:27 <lispy> actually
01:33:33 <lispy> i think the argument order is wrong
01:34:03 <lispy> ?let appendBy b x y = x ++ b ++ y
01:34:03 <lambdabot> <local>:4:0: Varying number of arguments for function `appendBy'
01:34:19 <lispy> ?undefine appendBy
01:34:20 <lambdabot> Undefined.
01:34:22 <lispy> ?let appendBy b x y = x ++ b ++ y
01:34:23 <lambdabot> Defined.
01:34:36 <lispy> ?pl b x y = x ++ b ++ y
01:34:37 <lambdabot> b = fix (flip ((.) . (++)) . (++))
01:34:46 <lispy> ?pl \b x y -> x ++ b ++ y
01:34:47 <lambdabot> flip ((.) . (++)) . (++)
01:43:26 <lispy> dons: did you fix the serialization bug in @where?
01:52:25 <dons> there was a bug?
01:53:05 <lispy> well, sometimes we add things and then a couple days later it's not there
01:53:14 <lispy> so yeah :)
01:53:33 <lispy> i thought you even mentioned it once
01:53:45 <lispy> perhaps i was being crazy again
01:54:21 * beelsebob hugs everyone
01:55:39 <Philippa> 'lo beelsebob
01:57:18 <beelsebob> lo Philippa, how's you doing?
02:00:09 * beelsebob_ prods Philippa again - sorry, my internet sucks at the moment
02:03:00 <Philippa> beelsebob: am doing well
02:03:51 <lispy> or
02:03:53 <lispy> oops
02:09:25 <dmead> is gtk haskell useable with hugs>
02:09:26 <dmead> ?
02:23:57 <EvilRanter> dmead, not AFAIK
02:48:12 <beelsebob_> dons: you remember my somewhat comical ejection from $php?
02:48:14 <beelsebob_> #php even
02:48:31 <wolverian> I don't!
02:49:22 <beelsebob_> wolverian: http://paste.lisp.org/display/29709
02:49:49 <beelsebob_> I just got reinstated by the channel op, and the other op slapped down :D
02:53:53 <Philippa> cool
02:54:40 <dons> heh. crazy chan
02:54:55 <dons> so the ops fight amongst themselves?
02:55:26 <wolverian> I used to join, say "http://tnx.nl/php" (that's all) and get kicked a minute later
02:55:28 <lambdabot> Title: PHP in contrast to Perl
02:55:33 <wolverian> repeat a few times a day when I'm feeling down :)
02:55:45 <dons> is the channel normally that full of people switching bans  and ops on and off?
02:55:51 <wolverian> yes.
02:55:52 <dons> wolverian: heh. bad ;)
02:55:57 <wolverian> it's a mess.
02:56:04 <dons> dysfunctional
02:56:14 <wolverian> (granted there were 600 people there last when I visited, but e.g. freenode #perl has 400+ people and manages fine)
02:56:27 <dons> yeah.
02:56:38 <dons> 600. our industry is a joke
02:56:48 <dons> no wonder the web sucks
02:56:54 <wolverian> no, they're the codemonkeys we trot on.
02:57:05 <wolverian> <#php> ignore the elephant!
02:57:50 <dons> we trot on monkeys?
02:57:56 <dons> hey mtahti
02:58:15 <wolverian> well, I like to imagine that when I'm feeling depressed about the industry.
02:58:18 <dons> ?users #haskell.fi
02:58:18 <lambdabot> Maximum users seen in #haskell.fi: 9, currently: 9 (100.0%), active: 1 (11.1%)
02:58:23 <dons> 9! nice.
02:58:31 <wolverian> it's growing slowly and quietly ;)
02:58:40 <beelsebob_> mmm... monkeys
02:58:54 <dons> so when will we see a haskell.org/Fi/ translation project?
02:59:00 <mtahti> Hello dons
02:59:19 <wolverian> hm. I'm not sure. I use english so much I don't always feel comfortable in finnish anymore. :P
02:59:21 <dons> the spanish guys are showing everyone else up! http://haskell.org/haskellwiki/Es/Haskell
02:59:22 <lambdabot> Title: Es/Haskell - HaskellWiki
02:59:25 <dons> heh
02:59:49 <wolverian> granted I'd like to see HHGTH in finnish
03:00:04 <lispy> beelsebob_: that's sad
03:00:06 <vegai> #haskell.fi!
03:00:13 <dons> yeah, i agree that its not such a pressing issue for western/northern europe, where english is very widely spoken.
03:00:15 <vegai> ?users #haskell.fi
03:00:16 <lambdabot> Maximum users seen in #haskell.fi: 10, currently: 10 (100.0%), active: 3 (30.0%)
03:00:19 <dons> yay
03:00:20 * vegai smirks.
03:00:23 <beelsebob_> lispy: it's great, isn't it
03:00:23 <lispy> beelsebob_: that jymmm sounds like a power tripper
03:00:24 <dons> ?users #haskell.es
03:00:25 <lambdabot> Maximum users seen in #haskell.es: 13, currently: 9 (69.2%), active: 0 (0.0%)
03:00:28 <dons> ?users #haskell.se
03:00:28 <lambdabot> Maximum users seen in #haskell.se: 12, currently: 10 (83.3%), active: 1 (10.0%)
03:00:47 <dons> the swedish mafia still has the edge just slight to the .fi crowd ;)
03:00:52 <lispy> beelsebob_: so what was the answer to your problemL
03:01:03 <dons> ?users #haskell.jp
03:01:04 <lambdabot> Maximum users seen in #haskell.jp: 5, currently: 3 (60.0%), active: 1 (33.3%)
03:01:07 <dons> 5 . good.
03:01:07 <beelsebob_> lispy: my interpretation of the discussion went along these lines "why is this like this", "I don't know but I'll kick you because yo found a hole in my ego"
03:01:22 <beelsebob_> lispy: $_SESSION did not have type array - or at least not at that point in time
03:01:31 <wolverian> beelsebob_, your assumption of logic in the language was wrong, though.
03:01:31 <lispy> beelsebob_: you need to take 10 minutes from the keyboard
03:01:33 <beelsebob_> until you call session_start(), $_SESSION does not have a type
03:01:49 <dons> beelsebob_: is there even a concept of types in php?
03:01:53 <beelsebob_> dons: yep
03:01:57 <beelsebob_> very week types
03:02:00 <beelsebob_> but types all the same
03:02:07 <dons> is that new feature? :)
03:02:21 <lispy> i like that if you use an array as a string in php it has the value "Array"
03:02:23 <wolverian> beelsebob_, is it dual typed into container and value types like perl?
03:02:30 <dons> lispy: nice!
03:02:34 <dons> how ... useful!
03:02:44 <beelsebob_> wolverian: not a clue
03:03:06 <beelsebob_> dons: tbf... if you use an array as a string in Haskell you get a type error :P
03:03:14 <beelsebob_> not even "Array"
03:03:17 <dons> and so you should.
03:03:30 <lispy> yeah, i was feeding an Array of strings (I thought I had one string) to a mysql database an it kept complaining that there was a syntax error, "Array" in line 1
03:03:38 <dons> exactly.
03:03:40 <beelsebob_> I agree - I'm saying that in terms of a weekly typed language, getting "Array" is the correct behaviour
03:04:01 <dons> what about concat. map show ?
03:04:05 <beelsebob_> if I try to print an array as a string, I shoud get something telling me what I tried to print
03:04:11 <dons> or, um, show
03:04:18 <beelsebob_> dons: yes indeed
03:04:33 <wolverian> yeah, perl does that.
03:04:40 <dons> > ord -- ;)
03:04:42 <lambdabot>  <Char -> Int>
03:04:58 <xerox> G'day!
03:05:04 <lispy> if i had just thrown an error, "Parameter type mismatch" i would have figured it out sooner
03:05:19 <lispy> i was stuck on that particular "Array" thing for most of an hour, iirc
03:05:22 <beelsebob_> lispy: well yes, but that would be intelligent
03:05:47 <lispy> i kept searching my huge sql file for "Array"
03:05:56 <nomeata> Hi. I have to look through various files for dependencies on other files, and that recursively, without circles (hopefully). Currently, it runs only in the IO monad and does not re-use already gathered information, which I’d like to improve. How should I do that? StateT Data.Map IO, or some writer, or what?
03:06:07 <lispy> and was afraid to try printing the contents of the file to the browser because it was many megs
03:06:33 * beelsebob_ goes to have a shower
03:06:56 <lispy> nomeata: i'd try using ReaderT
03:07:10 <dons> nomeata: Data.Graph?
03:07:14 <dons> or some tree structure?
03:07:48 <nomeata> the tree structure is not important, in the end I just want to know what files depend on what other files
03:07:54 <nomeata> I just want to save some work in between.
03:08:50 <lispy> ?tell jgrimes if you don't think you'll be working on the x86 helisp stuff again anytime, please send me a patch (even if it's not complete) because it will save me time in the long run :)
03:08:51 <lambdabot> Consider it noted.
03:09:57 <lispy> nomeata: if you use a Reader then you can cache the information in the environment
03:10:36 <lispy> nomeata: Reader will work so that as you go along you keep adding to your knowledge and you can revert back
03:10:38 <xerox> ...which basically means passing a parameter to all your actions.
03:11:01 <lispy> nomeata: if you use Writer then you can build up, say, a list of things you've figured out
03:11:46 <lispy> but i don't remember if you have good access to that list with the Writer
03:12:09 <lispy> and if this business with the Reader/Writer seems confusing just go with StateT like you suggested
03:13:32 <nomeata> ok, state sounds ok, after all I have to write new entries, but I have to read entries to check if I actually have to do anything when I encounter a possible new dependency
03:15:12 <lispy> Reader is really nice for that in compilers/interpreters because it lets you simulate scoping rules really easily...otherwise it's probably not as helpful
03:15:20 <nomeata> and inside, for the caching? Data.Map?
03:16:00 <nomeata> (lookup speed is not critical, <1000 entries)
03:16:03 <lispy> i wouldn't worry about performance so much
03:16:23 <lispy> but if lookup provides the api you want then ya, Data.Map is good
03:17:13 <lispy> one thing which is cool about Data.Map's lookup over the one in Prelude is that it will call fail in the monad its in
03:17:40 <lispy> instead of always returning Maybe a
03:18:34 <lispy> guessing the bottle neck of a haskell program before it's written is really, really hard
03:18:44 <nomeata> a function insertIfNotPresent :: (Map a) -> a -> (m a) -> m (Map a) would be intersting
03:19:07 <nomeata> the bottle neck currently is that the file gets parsed it was parsed before. what happens other than that I don’t care
03:19:28 <lispy> ?type maybe
03:19:29 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
03:20:12 <lispy> nomeata: well, insert will overwrite
03:20:19 <lispy> nomeata: is that a problem?
03:20:34 <lispy> ?type insert
03:20:36 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
03:20:42 <nomeata> yes, because then the (m a) computation would have to run, which is what I want to avoid
03:21:36 <nomeata> insertIfNotPresent map e gen = if e `in` map then return map else v <- gen; return $ insert (e,v) map
03:21:39 <nomeata> (pseudohaskell)
03:22:24 <wolverian> could be called add?
03:23:08 <lispy> insertIfNotPresent map key action = do case lookup map key of Nothing -> action >>= \x -> return (insert map (k,x)); Just _ -> return map
03:23:11 <lispy> something like that
03:23:35 <lispy> oops, extra do at the beginning
03:24:06 <nomeata> yes, that looks good
03:24:10 <sieni> I just noticed what a PITA is to try to play with monads in scheme
03:25:01 <lispy> ?hoogle add
03:25:01 <sieni> it's no fun to try to overload `return' without type inference :-)
03:25:02 <lambdabot> Time.addToClockTime :: TimeDiff -> ClockTime -> ClockTime
03:25:02 <lambdabot> Data.FiniteMap.addListToFM :: Ord key => FiniteMap key elt -> [(key, elt)] -> FiniteMap key elt
03:25:02 <lambdabot> Data.FiniteMap.addListToFM_C :: Ord key => (elt -> elt -> elt) -> FiniteMap key elt -> [(key, elt)] -> FiniteMap key elt
03:25:26 <lispy> sieni: heh
03:26:15 <sieni> maybe I'll add a type checker as well ;-)
03:26:17 * nomeata will now try to implement: genDepMap  :: Monad a => (a -> m [a]) -> (M.Map a [a])
03:26:41 <nomeata> genDepMap  :: Monad a => [a] -> (a -> m [a]) -> (M.Map a [a]) actually, with an inital list of candiates
03:27:07 <lispy> this would be a good time to make a monad
03:27:39 <lispy> like a StateT something
03:27:48 <nomeata> you mean in the implementation of the function? yes, in there I want to use StateT
03:28:03 <nomeata> and the caller only has to supply the dependency function and a list of known files.
03:31:05 * nomeata feels like stacking a ReaderT on top to keep track of the TODO list :-]
03:45:48 * EvilRanter is away: brunch
03:51:06 <musasabi> dons: what is the preferred way of doing a monadic mapAccumL over a ByteString?
04:02:08 <dons> musasabi: i'm not sure there's a preferred way. the safer the better.
04:02:13 <dons> (and the faster the better)
04:02:29 <dons> musasabi: also, do you still have an account for the occasional shootout commit?
04:04:04 <musasabi> dons: I think I have it. (haven't used it in a while)
04:04:48 <musasabi> Testing crypto is evil as quickcheck will just starve the machine entropy source and freeze things :-(
04:04:49 <nomeata> it was easier without stateT in the end
04:04:51 <nomeata> @paste
04:04:51 <lambdabot> http://paste.lisp.org/new/haskell
04:05:17 <musasabi> oh well, rewrote things to pregenerate the monadic part of the accumulator parameter.
04:05:28 <lisppaste2> nomeata pasted "Dependency Map generator. Easier without StateT?" at http://paste.lisp.org/display/29731
04:05:42 <nomeata> but I’m open to suggestions if it would have been nicer with StateT or something like that
04:06:35 <dons> musasabi: you might be interested to comment on this, http://programming.reddit.com/info/qjkz/comments
04:06:39 <lambdabot> Title: Haskellers, are you coding for money ? if so, what ? for whom ? (reddit.com), http://tinyurl.com/ycelxw
04:06:42 <dons> (about commercial haskell use)
04:09:02 <musasabi> hmm, have to write something there if I find time. (irl + work is keeping me too busy and have lots of thing that should have done in october)
04:09:09 <musasabi> s/i//
04:09:14 <dons> yep
04:12:59 <nomeata> what is the easiest way to turn a (Map a [a]) into a Data.Graph?
04:13:46 <nominolo> what happened on planet haskell? it now includes all entries of sigfpe
04:18:11 <wolverian> does ghci understand utf8 characters in names? I want to use finnish! :)
04:19:51 * EvilRanter is back (gone 00:34:03)
04:20:31 <musasabi> wolverian: you can use escapes in any case.
04:20:52 <wolverian> musasabi, escapes?
04:21:18 <wolverian> ah, ibid helped me. ibid, thanks :)
04:21:18 <musasabi> wolverian: just use something like xsymbol and you will get things you want.
04:21:36 <wolverian> (my ghci is 6.4 so it wants latin1)
04:24:45 <robreim> Using an arrows library such as afrp, would the recommended way to perform monadic operations such as IO be to wrap it up in a Kleisli?
04:24:59 <robreim> s/afrp/yampa/
04:35:25 <Lajexander> does anyone here have any experience with ms excel files? my girlfriend had a big project in her "statistics for biologists" call and i was thinking of remaking it in haskell, for fun
04:36:23 <Lajexander> so do anyone know how to take a column in a spreadsheet document and make a list of it
04:36:33 <yaxu> is it possible to communicate with some forked background process via a ghci prompt?
04:37:49 <yaxu> i think i should read "tackling the awkward squad"
04:37:58 <yaxu> awkward is such an awkward word
04:38:12 <Philippa> save the spreadsheet as CSV and parse from there?
04:38:41 <nomeata> what does     Inferred type is less polymorphic than expected mean?
04:40:20 <Lajexander> Philippa: what's csv?
04:40:56 <Baughn> Lajexander: Ask excel to save in csv, open it and you'll see. ;)
04:41:06 <Baughn> It's human-readable. Mostly.
04:41:23 <lisppaste2> nomeata pasted "less polymorphic than expected" at http://paste.lisp.org/display/29733
04:41:27 <Lajexander> heh, i'll ask openoffice =)
04:41:46 <nomeata> can someone help me understand that error message?
04:59:58 <Lemmih> nomeata: ::()?
05:00:17 <sieni> quadruple eyes?
05:00:20 <nomeata> Lemmih: oh, did I paste the debug version? moment.
05:00:51 <lisppaste2> nomeata annotated #29733 with "without debug" at http://paste.lisp.org/display/29733#1
05:02:56 <Igloo> nomeata: Because a is universally quantified in the local binding, but is required to be the a in the outer binding due to the use of m
05:03:12 <Igloo> nomeata: If you want a type sig you'd have to use scoped type variables
05:04:26 <robreim> nomeata: it loads fine in ghc 6.6
05:06:14 <robreim> (the annotation does anyway)
05:11:39 <nomeata> ok, thanks
05:24:36 <therp> it's not possible to define more than one module per file isn't it?
05:25:40 <Igloo> Not in any of the implementations, no
05:28:10 <therp> because I'm looking at the template haskell restriction that compile-time code must come from other module. I figured I would intersect a module Foo into a set of "bind groups", define each as Foo1, Foo2, while FooN imports Foo(N-1) and can use its code and exports module Foo(N-1) again and all its new symbols. The file would close with a module definition Foo importing and exporting the last FooN.
05:28:41 <therp> so that everything sits in a single file.
05:32:08 <therp> actually I'm planing to do that automatically and in the compiler, without ever touching files.. but well. that's not that clean I guess.
05:46:27 <Baughn> How many forkIO threads can I expect to run simultaneously?
05:47:41 <SamB> Baughn: only as many as you have CPU cores...
05:48:38 <kolmodin> I don't think that's what he ment :)
05:48:59 <Baughn> Correct, yet useless. I'm not going to bother clarifying my question, though, since you understood it perfectly. :P
05:49:04 <SamB> hehe
05:49:07 <kolmodin> :)
05:49:35 <SamB> oh, okay, well, how many native threads would you expect to be able to run?
05:49:57 <Baughn> Not very many at all, but IIRC forkIO uses a N:M threading model
05:50:14 <SamB> @docs Control.Concurrent.forkIO
05:50:14 <lambdabot> Control.Concurrent.forkIO not available
05:50:17 <SamB> @docs Control.Concurrent
05:50:18 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
05:50:41 <SamB> oh, wait, forkIO is the lightweight kind...
05:50:58 <SamB> IO and OS are so similar looking...
05:51:00 <SamB> ;-)
05:51:07 <Baughn> Yep, and I'd like you to tell me I can fork off twenty thousand or so at the same time. ;)
05:51:20 <SamB> well...
05:51:38 <sylvan> Baughn, as a rough target, depending on what kind of performance constraings you have etc... 10^6 is perfectly possible
05:52:13 <sylvan> But again, this is highly dependent on what you actually do with them, how many are active at one time etc... and what system you have
05:52:20 <Baughn> sylvan: I'll have to test that. Does that assume a 64-bit system?
05:52:49 <Baughn> sylvan: Well, I'm not expecting to get more work done at a time than with event-handling; 99.9% of them should be blocked on read most of the time
05:53:00 <sylvan> No not really, though depending on how much memory you allocate you could go over 4 gigs with that many :-)
05:53:23 <Baughn> So.. wait, ghc produces a stackless program? Or how does that work?
05:54:57 <SamB> it looks like the overriding cost is the amount of stack...
05:55:51 <SamB> and my GHC seems to have a 1k default stack size...
05:56:04 <SamB> (they grow, though, so don't worry ;-)
05:56:22 <Baughn> They.. grow? By getting moved? Er...
05:56:27 <Baughn> Okay, this is not C. Gotcha. :P
05:56:28 <SamB> yes
05:56:50 <sylvan> Right 1k stack size can quickly eat up your memory so you would want to reduce that if that happense :-)
05:57:14 <SamB> yeah, there really doesn't seem to be much point in using a C compiler in the build process if you are just going to erase the C stack, does there?
05:57:30 <SamB> sylvan: right ;-)
05:58:30 <sylvan> How much allocation dose a thread in Erlang do? IIRC it was something insanely low like 13 bytes or somethig like that.. Anyone know?
05:58:42 <Baughn> That makes me jealous. I've been striving to fit sufficient numbers of (immovable) C threads into the address space, and even with a 48-bit VMA that's hard
05:59:51 <SamB> now, note that I have not determined the actual per-thread overhead...
06:00:14 <SamB> I have trouble eyeballing sizeof()
06:02:19 <Baughn> So, if I'm reading this documentation correctly.. if I attempt to read from a network socket and the read can't be immediately satisfied, /all/ threads are blocked until it is? Except in GHC, in which case some other thread runs instead?
06:03:13 <SamB> hmm, I don't know about non-GHC, but GHC is supposed to work as you describe, yes
06:04:47 <Baughn> ..it appears that that doesn't happen in non-ghc either, but it could be clearer
06:05:02 <guerra> anyone know a good guide to learn gtk2hs basics?
06:05:26 <Baughn> Gah. Or not. Seems contradictory.
06:05:34 <SamB> hmm, I'm leaving for church soon...
06:05:37 <dcoutts> guerra, there's hello world, there's an intro presentation, there's a glade tutorial
06:05:49 <dcoutts> guerra, there's a bunch of demo programs
06:06:29 <guerra> dcoutts and also u know it so u can help in case i want, wxhaskell doesnt have many examples on web
06:06:38 <guerra> in case i need
06:06:51 <dcoutts> guerra, sadly there isn't yet a "one true guide", though we do intend to write one
06:07:04 <dcoutts> guerra, but the demo progs are a good place to start
06:07:26 <dcoutts> guerra, http://haskell.org/gtk2hs/documentation/
06:07:27 <lambdabot> Title: Gtk2Hs » Documentation
06:07:57 <guerra> dcoutts i see, will try to learn it quick, what i need from it is a menu to start game, a function that rewrites something on the screen all the time and some input boxes
06:08:29 <dcoutts> guerra, use glade
06:08:36 <guerra> whats it?
06:08:46 <dcoutts> http://eddy.writelinux.com/gtk2hs/GladeGtk2Hs.html
06:08:49 <lambdabot> Title: Developing Gnome Apps with with Glade and Haskell Gtk2Hs, http://tinyurl.com/y4l3xj
06:08:53 <SamB> like a souped-up VB
06:08:59 <SamB> without the nasty programming language
06:09:18 * dcoutts was about to @slap SamB for saying that
06:09:24 <Spark> its really nothing like vb
06:09:28 <guerra> cooool
06:09:30 <dcoutts> but he recovered in the knick of time :-)
06:10:24 <SamB> I say souped-up because you don't have to position things by pixels, but instead you lay them out and they can automatically resize
06:11:44 <dcoutts> yes, like html
06:12:22 <Spark> i'd like to learn how to make gtk apps look less... grey
06:12:26 <Spark> it must be possible with skins and so on
06:12:28 <Spark> and .gtkrc
06:12:33 <SamB> Spark: it has the things about VB that people actually like, though
06:12:35 <Spark> but ive never seen a walkthrough
06:13:10 <guerra> dcoutts well, will have to go to linux and install it since i had to use windows cause wxhaskell has a bug in my slack
06:14:01 <dcoutts> guerra, Gtk2Hs also works on Windows, but it's easier on Linux
06:14:10 <dcoutts> in fact glade works on Windows too
06:14:21 <guerra> dcoutts how comes?
06:14:45 <dcoutts> guerra, how come what? that it's easier on linux?
06:15:01 <guerra> dcoutts no, glades in windows, found it already
06:15:31 <dcoutts> guerra, well gtk+ is portable software, so it works in windows too
06:15:53 <Spark> (just not very well)
06:15:57 <guerra> dcoutts im already downloading all for windows, easier right now
06:16:07 <guerra> Spark: why?
06:16:21 <Spark> i keep seeing people complain about it
06:16:26 <Spark> usually speed problems
06:16:37 <guerra> hummm i see
06:16:54 <spiffy> ahh...finally got emacs and haskell-mode all setup.
06:17:38 <dcoutts> Spark, you mean ndm complaining about speed with threads?
06:18:14 <dcoutts> Spark, I'm not aware of it being slow, people's usual complaint is about it not always looking perfect compared to other windows apps
06:31:19 <Lemmih> bringert: ping.
06:49:23 <xs> is it possible to get a backtrace when error is called?
06:50:17 <Lemmih> Not really.
06:50:29 <xs> that really sucks
06:50:34 <xs> thanks
06:51:01 <wolverian> hat?
06:51:39 <xs> whenever i've tried to use it, it has been a world of pain
06:51:56 <xs> especially if you use library (like gtk)
06:52:36 <dcoutts> that kind of thing would be easier once gtk2hs uses cabal
06:53:02 <pitecus> How can i use where in a lambda?
06:53:08 <pitecus> I can get it to parse
06:53:31 <dcoutts> pitecus, you can't directly
06:53:34 <lennart> pitecus: you can't
06:53:37 <dcoutts> use let instead
06:53:59 <lennart> it's not a bug, it's a feature :)
06:54:08 <dcoutts> or you can use a case expression which is allowed to have where clauses
06:54:26 <dcoutts> pitecus, it's the difference between declaration and expression context
06:54:39 <dcoutts> let is in expressions, where is in declarations
06:54:40 <pitecus> fair enough...
07:07:36 <|m0rph|> hello, can you tell me what happened to package data and util on release 6.6 ?
07:13:18 <|m0rph|> anyone ?
07:20:15 <Lemmih> |m0rph|: They were obsolete, I think.
07:21:26 <|m0rph|> I have a problem then
07:21:44 <|m0rph|> I need to use libraries that were made on 6.4.1
07:21:53 <|m0rph|> but my intel mac only runs 6.6 :D
07:23:42 <dcoutts> |m0rph|, what is it that still uses util & data? In my experience, many packages that 'need' util and data in fact do not need them at all.
07:23:51 <dcoutts> and if they do, they're easy to port
07:24:16 <|m0rph|> I have a lot of imports
07:24:18 <|m0rph|> let me check
07:24:37 <|m0rph|> contrib/ATermLib/library/ATermReadWrite.hs:35:7:
07:24:37 <|m0rph|>     Could not find module `Memo':
07:24:37 <|m0rph|>       Use -v to see a list of the files searched for.
07:24:45 <|m0rph|> this Memo is from util or data
07:24:47 <|m0rph|> not sure
07:24:52 <dcoutts> ah, memo really is gone
07:25:01 <|m0rph|> argh :/
07:25:16 <dcoutts> anyone know if there is a replacement? Igloo?
07:25:30 <Igloo> I don't think there is
07:25:44 <dcoutts> though it's still possible to install the hslibs with ghc-6.6 I think
07:25:52 <dcoutts> it's just that few people need them
07:26:04 <Igloo> I doubt it's easy
07:26:16 <Igloo> Much better to make a memo package
07:26:48 <|m0rph|> that's someone else code, i dont even know what Memo is for ..
07:27:04 <|m0rph|> another way is to make ghc 6.4.2 run on my mac
07:27:11 <|m0rph|> I just need the interpreter
07:33:09 <|m0rph|> how can i install the older packages?
07:37:21 <guerra> after i installed ghc gtk+ gtk2hs, i extracted glade, do i need to do anythign so it works? cause i can use ir, but could nto see the build option
07:38:20 <dcoutts> guerra, not sure what you mean about a build option.
07:38:33 <guerra> the option that generates teh code
07:38:41 <dcoutts> you don't use that
07:38:55 <dcoutts> you load the glade xml file in your program
07:38:59 <dcoutts> see the tutorial
07:39:07 <guerra> ok sry
07:39:14 <dcoutts> s'ok
07:39:37 <dcoutts> generating the code is how it used to be done for C, but everyone agreed that it's not a good method
07:42:11 <guerra> i see now, im reading the tuto calmly....im a bit nervous since i have already lost too much time with gui things
07:46:16 <dcoutts> guerra, or just look at the code of the glade demo:
07:46:36 <dcoutts> http://darcs.haskell.org/gtk2hs/demo/glade/GladeTest.hs
07:46:39 <lambdabot> http://tinyurl.com/yyfjtf
07:47:10 <dcoutts> it's just a matter of laoding named widgets from the glade xml file
07:47:50 <guerra> hummm
07:48:02 <guerra> wil ltry here and will let u know if its working for me ^^
08:08:15 <Jules_> could somebody help me writing a removeAll function?
08:08:27 <Jules_> removeAll xs ys should remove all elements in xs from ys
08:08:36 <Jules_> but only once
08:08:48 <Jules_> so: removeAll "a" "aa" => "a"
08:09:16 <Jules_> I have a version but I'd like to make it faster
08:09:26 <Jules_> remove x (y:ys) = if x == y then ys else y:remove x ys
08:09:31 <Jules_> removeAll1 xs = foldr1 (.) (map remove xs)
08:09:44 <Jules_> is this the best way to do this?
08:11:43 <lennart> Jules_: why not use \\
08:12:26 <lennart> > "abcab" \\ "ba"
08:12:35 <lambdabot>  "cab"
08:13:53 <roconnor> hmmm, I'm having trouble finding my thread with gmane
08:15:46 <Jules_> thanks lennart I didn't know about \\
08:16:23 <lennart> if you are really worried about speed you should probably use Data.Set rather than lists
08:17:56 <roconnor> Data.Multiset?
08:19:06 <lennart> yeah, multiset would be good.  Data.Map would do with a thin layer on top
08:23:20 <Jules_> the program operates on string input data so it might be slower to convert to multiset and back to string again
08:23:29 <Jules_> but I'm going to try Data.Multiset
08:23:34 <Jules_> thanks for your help
08:30:48 <SimonRC> How far has comp.lang.haskell got?  Google hasn't got it, and neither has JANET.
08:30:55 <roconnor> @type mapMaybe
08:30:57 <lambdabot> forall b a. (a -> Maybe b) -> [a] -> [b]
08:37:22 <yaxu> haskell++ # reassuringly difficult
08:37:36 <dcoutts> mapMaybe = map . fmap right ?
08:38:06 <dcoutts> @type (map . fmap) :: (a -> Maybe b) -> [a] -> [b]
08:38:08 <lambdabot>   Couldn't match the rigid variable `a' against `f a'
08:38:08 <lambdabot>    `a' is bound by the polymorphic type `forall a b. (a -> Maybe b) -> [a] -> [b]'
08:38:28 <dcoutts> @type (map . fmap)
08:38:29 <lambdabot> forall (f :: * -> *) a b. (Functor f) => (a -> b) -> [f a] -> [f b]
08:38:34 <dcoutts> ah
08:39:11 <dcoutts> so mapMaybe is a filter . map
08:41:51 <Lemmih> @type \fn -> foldr (\a b -> maybe b (:b) (fn a))
08:41:54 <lambdabot> forall a a1. (a -> Maybe a1) -> [a1] -> [a] -> [a1]
08:42:20 <roconnor> @type catMaybes
08:42:21 <lambdabot> forall a. [Maybe a] -> [a]
08:42:36 <lennart> I thought mapMaybes f = catMaybes.map f
08:43:39 <xerox> ?type mapMaybe
08:43:40 <lambdabot> forall b a. (a -> Maybe b) -> [a] -> [b]
08:44:00 <xerox> @type fmap . map
08:44:01 <lambdabot> forall (f :: * -> *) a b. (Functor f) => (a -> b) -> f [a] -> f [b]
08:44:20 <xerox> @type fmap . fmap
08:44:21 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b. (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
08:49:36 <Pupeno> Is there a way to undo :set -v in ghci ?
08:51:58 <dcoutts> ndm, hia, did you catch the discussion on haddock and hoogle yesterday ?
08:52:07 <ndm> dcoutts, on IRC?
08:52:11 <dcoutts> yep
08:52:17 <ndm> nope, was offline all day
08:52:25 <dcoutts> we were talking about more integration
08:52:36 <dcoutts> we want haddock docs with built-in search
08:52:43 <dcoutts> probably using .cgi or something
08:52:48 <dcoutts> so only for hosted docs
08:52:55 <ndm> that sounds easy enough
08:53:21 <ndm> my suggestion would be that hoogle does all the searching
08:53:29 <ndm> and i let anyone upload hoogle databases
08:53:51 <dcoutts> well the point would be that it'd use precisely the database for the docs in question
08:53:53 <ndm> then the search box can point at haskell.org/hoogle?package=... and the haddock stuff only needs very simple HTML
08:54:01 <ndm> yes, exactly
08:54:04 <dcoutts> ie it'd be local
08:54:07 <ndm> hoogle 4 will have that feature
08:54:18 <dcoutts> the server would need hoogle command line installed or similar
08:54:21 <ndm> hosted docs?
08:54:27 <ndm> yeah, that can be done
08:54:37 <dcoutts> so haddock should optionally generate a html search form like the contents and index links at the top of each page
08:54:38 <ndm> requires each server to install hoogle, so might be a bit more effort
08:54:45 <dcoutts> yes
08:54:56 <ndm> whereas a central hoogle could index remote haddock documentation quite easy
08:55:07 <ndm> i.e. less install/configure work for individual sites
08:55:10 <Igloo> Local but optional is best IMO
08:55:16 <dcoutts> and that would link to a .cgi in the root of the docs dir, and that cgi would call hoogle command line
08:55:27 <ndm> i already have hoogle.cgi
08:55:29 <dcoutts> and it'd use the hoogle db for that set of docs
08:55:39 <ndm> yeah, thats certainly not too hard to set up
08:56:16 <ndm> probably for hoogle 4 though, not hoogle 3
08:56:26 <dcoutts> so just like haddock currently generates $ROOT/haddock.css, $ROOT/<pkg>.haddock, it should now optinoally generate $ROOT/hoogle.db and $ROOT/hoogle.cgi
08:56:55 <dcoutts> so there's no hoogle configuration necessary on the server side
08:57:14 <dcoutts> the command line proj just needs to be installed an on the path for the cgi
08:57:18 <dcoutts> proj/prog
08:57:45 <ndm> yeah, sounds doable
08:58:02 <ndm> so you want the normal hoogle.exe to be capable of being a command line tool and a web interface?
08:58:22 <dcoutts> yes
08:58:35 <ndm> that can be done
08:59:03 <dcoutts> so the cgi will just get the results back from calling the command line
08:59:18 <dcoutts> or I suppose if hoogle already generates html then that might be simpler
08:59:18 <ndm> i think the cgi should be ultra minimal
08:59:28 <dcoutts> though it wouldn't fit the haddock css theme
08:59:30 <ndm> i.e. call hoogle and pipe the results out
08:59:37 <ndm> add a -use-haddock-css flag
08:59:38 <dcoutts> unless the hoogle html is nicely cssable
08:59:42 <dcoutts> nice
08:59:55 <ndm> i have an XML output mode for hoogle already
09:00:01 <ndm> and it is nicely css'able
09:01:05 <ndm> so that leaves me with the debate, do i now do some work on my PhD or on hoogle :)
09:01:12 <dcoutts> heh heh
09:01:19 <Igloo> No contest, surely!
09:01:52 <ndm> i spent yesterday on Dr Haskell, so feel my phd should get some love sometime soon
09:02:15 <ndm> Dr Haskell can now recognise sum [] = 0; sum (x:xs) = x + sum xs; and suggest you use a fold
09:03:28 <dcoutts> does it suggest you use sum ? :-)
09:03:42 <ndm> it could do :)
09:03:46 <dcoutts> how about the tricky one about when to use foldl vs foldr ?
09:03:48 <ndm> but no, it doesn't
09:03:54 <dcoutts> that'd really help beginners I reckon
09:04:01 <ndm> it prefers to suggest foldr :)
09:04:13 <ndm> but can suggest reverse as a foldl
09:04:34 <dcoutts> the choice depends on knowing the strictness of the function
09:04:35 <ndm> if the user wrote an accumulating parameter, foldl gets it
09:04:49 <ndm> yeah, there is no way it can spot that
09:04:56 <ndm> i was just happy that it can spot map's :)
09:05:04 <dcoutts> aye, purely syntactic
09:05:08 <ndm> indeed
09:05:11 <xerox> do it on .hi files?
09:05:19 <hyrax42> ugh
09:05:20 <xerox> rather "with" .hi files
09:05:24 <ndm> Yhc has no strictness info
09:05:33 <xerox> hm?
09:05:34 <hyrax42> I am really not in the mood of programming "safe" C
09:05:44 <dcoutts> hyrax42, then use unsafe C :-)
09:06:13 <ndm> @dice
09:06:14 <lambdabot> unexpected end of input: expecting number
09:06:17 <hyrax42> ok I'll generalise "safe" C to just plain C
09:06:19 <ndm> @help dice
09:06:20 <lambdabot> dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
09:06:32 <hyrax42> ?dice 1d1-5
09:06:32 <xerox> @dice 1d2
09:06:32 <lambdabot> unexpected "-": expecting digit, "+" or end
09:06:33 <lambdabot> 1d2 => 2
09:06:41 <hyrax42> ?dice 1d1
09:06:42 <lambdabot> 1d1 => 1
09:06:53 <ndm> @dice 1dhoogle+catch
09:06:53 <lambdabot> unexpected "h": expecting number
09:07:05 <ndm> @dice 1d1+2 -- 1 == hoogle, 2 == catch
09:07:06 <lambdabot> unexpected "-": expecting "+" or end
09:07:11 <ndm> @dice 1d1+2
09:07:12 <lambdabot> 1d1+2 => 3
09:07:12 <xerox> launch one dice of two sides @1d2
09:07:23 <xerox> thats 1d1 + 2 = 1 + 2 = 3
09:07:24 <ndm> @dice 1d2
09:07:25 <lambdabot> 1d2 => 1
09:07:52 <xerox> Hoogle won!
09:07:53 * ndm will point out dcoutts to Colin as the reason his PhD has no progress
09:08:10 <dcoutts> sorry!
09:08:18 <xerox> and lambdabot.
09:20:37 <guerra> dcoutts i installed the gtk2hs and when itried to test a program it says it cant find the files i imported. what do i do?
09:21:08 <dcoutts> guerra, check that it's installed properly, what does "ghc-pkg list gtk" say ?
09:21:19 <dcoutts> guerra, is this linux or windows ?
09:21:23 <guerra> windows
09:22:39 <dcoutts> guerra, so what does "ghc-pkg.exe list gtk" say ?
09:23:37 <guerra> C:/ghc/ghc-6.4.1\package.conf:
09:23:46 <guerra> and nothing else
09:23:56 <dcoutts> ok, then it didn't install properly
09:24:09 <dcoutts> is this the only version of ghc you have installed?
09:24:26 <dcoutts> and the installer didn't give any error messages ?
09:24:27 <guerra> yes, unistalled the 6.4 i used with wxhaskell
09:24:31 <guerra> nope
09:24:41 <dcoutts> hrm
09:25:09 <dcoutts> lemme check what the log flag is...
09:26:32 <guerra> it asked me for the ghc version 6.4.1 and i isntalled, then it asked me to put the gtk package inthe enviroment variables and i did
09:26:40 <guerra> after that the installer didnt complain
09:27:45 <dcoutts> guerra, re-run the gtk2hs installer from the command line and use the option: /LOG=gtk2hs-install.log
09:28:11 <dcoutts> then we want to look at the resulting gtk2hs-install.log
09:28:14 <dcoutts> @paste
09:28:15 <lambdabot> http://paste.lisp.org/new/haskell
09:28:28 <dcoutts> you can post it at that site ^^^
09:31:41 <guerra> dcoutts says its too large, mayeb u wanna a specific part
09:32:21 <dcoutts> guerra, is there anywhere else you can post it? otherwise you can email it to me
09:32:32 <dcoutts> guerra, we want to see the bit where it's registering things
09:32:36 <dcoutts> which is near the end
09:32:49 <dcoutts> we want to see the result codes of the ghc-pkg.exe registration bit
09:32:52 <guerra> ok, lemme see if i can find it
09:34:40 <guerra> dcoutts lemme mail it, its better
09:35:55 <xerox> ⩶
09:35:56 <xerox> ops
09:36:47 <guerra> dcoutts sent
09:36:54 <dcoutts> ta
09:37:49 <dcoutts> guerra, ok try this:
09:38:07 <dcoutts> C:\ghc\ghc-6.4.1\bin\ghc-pkg.exe update "C:\Program Files\Gtk2Hs\glib.package.conf"
09:38:25 <dcoutts> does it give an error message ?
09:40:16 <guerra> yes, says  glib2.0 doesnt exist
09:40:38 <guerra> and suggests to use --force
09:40:41 <guerra> to override
09:41:28 <dcoutts> guerra, hmm glib-2.0 is the C lib
09:41:38 <dcoutts> could you check that it does indeed exist ?
09:41:44 <guerra> sure
09:41:45 <dcoutts> it'll be in the gtk bin dir
09:42:13 <dcoutts> and open "C:\Program Files\Gtk2Hs\glib.package.conf" in a text editor and check that the path for the gtk/glib C libs is correct
09:42:28 <dcoutts> it should point to the gtk bin dir
09:43:13 <guerra> dcoutts the include file miss in C:\Program Files\Common Files\GTK\2.0
09:43:20 <guerra> folder
09:43:34 <Pupeno> I've got this error: "Could not find module `System.FD': it is a member of package Streams-0.1.7, which is hidden", how do you un-hide a package ?
09:44:39 <dcoutts> guerra, ah, check the glib.package.conf, what is the "library-dirs:" field ?
09:45:09 <dcoutts> guerra, my suspicion is that ghc doesn't like the gtk+ libs being installed in a path that contains a space.
09:45:19 <dcoutts> ie under "Program Files"
09:45:26 <guerra> humm
09:45:38 <dcoutts> I'll have to make sure that works for the next release
09:46:09 <guerra> it says
09:46:13 <guerra> dcoutts library-dirs: "C:/Program Files/Common Files/GTK/2.0/lib","C:/Program Files/Gtk2Hs"
09:46:37 <dcoutts> guerra, oh, that's not where gtk is installed is it?
09:46:47 <guerra> actually yes
09:46:53 <dcoutts> oh ok
09:46:55 <guerra> its there
09:48:35 <dcoutts> guerra, so my suggestion is to try installing Gtk+ in C:\GTK or something else without a space
09:48:45 <guerra> sure
09:49:07 <guerra> dcoutts doing that
09:49:16 <dcoutts> if that works, then I'll have to investigate it fix it for next time.
09:49:51 <dcoutts> I think I tested installing Gtk2Hs in a path with a space, but not Gtk+
09:53:16 <guerra> ok, reinstalled, now i reinstall gtk2hs?
09:53:23 <dcoutts> guerra, yep
09:57:05 <guerra> dcoutts when running it got the same error
09:57:13 <guerra> with -v option i got
09:58:26 <guerra> it searched in Graphics/UI/Gtk/Glade.hs and it searched in Graphics/UI/Gtk/Glade.lhs
10:01:33 <pitecus> Is there something like !! which doesnt throw an error but returns a Maybe?
10:02:54 <ndm> @hoogle [a] -> Int -> Maybe a
10:02:55 <lambdabot> No matches, try a more general search
10:03:15 <ndm> pitecus: no
10:03:27 <ndm> pitecus: but me and dons were going to set up a library with such a function in it
10:03:49 <newsham> @hoogle Int -> [a] -> Maybe a
10:03:51 <lambdabot> No matches, try a more general search
10:04:00 <dcoutts> guerra, that looks like path space problems again. Which is rather confusing as I'm sure I tested that.
10:04:08 <pitecus> ndm, cool
10:04:09 <dcoutts> guerra, oh wait, no
10:04:18 <dcoutts> guerra, that just means it didn't register again
10:04:31 <dcoutts> guerra, "ghc-pkg list gtk" probably still says nothing
10:04:46 <dcoutts> guerra, so try that registration command again and lets see what is says now
10:04:53 <guerra> k
10:04:57 <dcoutts> C:\ghc\ghc-6.4.1\bin\ghc-pkg.exe update "C:\Program Files\Gtk2Hs\glib.package.conf"
10:06:20 <guerra> same glib error
10:06:32 <guerra> dcoutts which version of gtk should i install?
10:06:46 <guerra> dcoutts maybe im doin something very wrong
10:06:49 <dcoutts> guerra, gtk+ 2.6 or 2.8
10:07:10 <guerra> dcoutts 2.8.18 is ok?
10:07:13 <dcoutts> http://haskell.org/gtk2hs/archives/2005/06/24/installing-on-windows/
10:07:15 <dcoutts> guerra, sure
10:07:16 <lambdabot> Title: Gtk2Hs » Blog Archive » Installing on Windows, http://tinyurl.com/wj36k
10:10:08 <guerra> dcoutts omg, i m ashamed..... had teh runtime version DUUUUUUH
10:10:19 <dcoutts> guerra, ah :-)
10:10:29 <dcoutts> guerra, hmm, the gtk2hs installer should check that
10:10:33 * Daveman waves to xerox
10:10:42 <dcoutts> it should have given an error message, sorry about that
10:10:50 * xerox ⌇ to Daveman 
10:10:56 * dcoutts needs to overhaul the gtk2hs win32 installer
10:11:14 <ndm> dcoutts, have you heard of my HsInstaller project?
10:11:34 <Daveman> heehee :)
10:11:39 <dcoutts> ndm, nope, is it great? :-)
10:11:41 * xerox looks at the Hoogle computer, with its empty seat
10:11:47 <guerra> dcoutts is me who must  be sry :P thanks for the help ^^
10:11:57 <dcoutts> ndm, the main problems I find are with the paths and C libs etc
10:12:07 <dcoutts> ndm, registering the ghc packages isn't too hard
10:12:32 <ndm> @paste
10:12:33 <newsham> can anyone help me with my loan question?
10:12:33 <lambdabot> http://paste.lisp.org/new/haskell
10:12:36 <newsham> oops, wrong channel
10:12:55 <lisppaste2> ndm pasted "HsInstaller (email to sof)" at http://paste.lisp.org/display/29742
10:13:31 <ndm> dcoutts, i want to start a unified Haskell installer project, so all Haskell programs (Yhc, Hugs, GHC, Gtk2Hs, any Cabal program) can use the same installer
10:13:43 <ndm> the above is an email i sent to sof
10:14:01 <dcoutts> ndm, that'd be cool though I would not be able to help with a .msi installer since I cannot test it.
10:14:19 <dcoutts> ndm, I do not have admin access to any windows box so can't use .msi installers
10:14:27 <ndm> dcoutts, what do you currently use to install it?
10:14:34 <dcoutts> it's a .exe installer
10:14:38 <dcoutts> I use InnoSetup
10:14:41 <ndm> dcoutts, its not a requirement to use .msi, its just a requirement to all use the same installer
10:14:53 <ndm> is that any good? open source?
10:15:06 <dcoutts> it's not too bad, yes open source
10:15:13 <dcoutts> it uses pascal as it's scripting language
10:15:16 <ndm> are your install scripts public?
10:15:19 <dcoutts> yep
10:15:30 <dcoutts> they are in the darcs repo
10:15:31 <ndm> cool, might talk to you at Fita about htat
10:15:36 <dcoutts> though I think slightly out of date
10:15:41 <ndm> i suspect i'll never get the .msi scripts off sof...
10:15:45 <dcoutts> so make sure I've updated them if you want to really use it
10:15:52 <dcoutts> ndm, heh
10:16:01 <ndm> and would like to standardise on something, not too fussed what
10:16:08 <dcoutts> yes, it'd be great
10:16:48 <dcoutts> ndm, have you given any thought to installing libs that are FFI bindings ?
10:16:57 <dcoutts> it's currently a mighty PITA
10:17:22 <ndm> dcoutts, i was going to focus on one off apps (Yhc/Gtk2hs/GHC) and user downloadable apps (hoogle, catch etc), but leave libraries til later
10:17:37 <dcoutts> yeah, they're the harder case
10:17:39 <ndm> although it would be nice for a single solution to emerge
10:17:41 <dcoutts> leave them for later
10:18:00 <dcoutts> I think something based on the MS manifests thing is most promising
10:18:25 <dcoutts> though that doesn't allow non-admin installs
10:18:34 <dcoutts> but then neither does msi :-)
10:18:49 <dcoutts> perhaps that's not so important
10:19:03 <ndm> does .msi really disallow all non-admin installs?
10:19:21 <ndm> i am sure i've installed .msi's on my work machine, and i'm not admin their
10:19:34 <dcoutts> well you can open it to non-admin but I think that would allow you to root the box
10:19:58 <dcoutts> or at least that's what my windows sys admin said when I asked
10:20:07 <xerox> o_o
10:20:07 <dcoutts> when I asked for him to let me use msi
10:20:11 <ndm> i think that sounds like lies :)
10:20:23 <dcoutts> I would have thought so
10:20:27 <ndm> i installed GHC 6.4.2 which is an MSI at work
10:20:39 <ndm> i suspect most non-admins can install .msi's, only you are banned
10:20:54 <dcoutts> seems the installer service ought to be able to do it on behalf of a user, using their permissions
10:21:03 <ndm> yep
10:21:05 <dcoutts> so no writing to global registry or files etc
10:21:18 <ndm> indeed, but thats fully supported
10:21:20 <guerra> dcoutts know what thsi error is? Loading package glib-0.9.10 ... can't load .so/.DLL for: glib-2.0 (addDLL: unknown error)
10:21:24 <dcoutts> so perhaps my admin is just mis-informed, it's quite possible
10:21:40 <ndm> yeah, perhaps - well i want to get something everyone can use, not too fussed what :)
10:21:50 <dcoutts> guerra, is the gtk lib dir on the %PATH% ?
10:21:54 <ndm> anyway, dinner calls - see you thursday
10:21:58 <dcoutts> @arr!
10:21:59 <lambdabot> Shiver me timbers!
10:22:03 <dcoutts> ndm, yep :-)
10:22:30 <dcoutts> guerra, oh, wait. it doesn't work in ghci
10:22:36 <dcoutts> guerra, not with ghc-6.4.1 anyway
10:22:40 <guerra> oh ya forgota that
10:23:00 <dcoutts> guerra, we got ghc improved so that it can be made to work now, and it'll work in the next gtk2hs release
10:23:32 <guerra> dcoutts cool
10:27:43 <guerra> dcoutts lets hope it works now ^^
10:28:38 * dcoutts crosses his fingers
10:33:05 <guerra> dcoutts im gettin a bucnh of fake: undefinied references - whats it?
10:33:54 <dcoutts> guerra, you mean linking errors ?
10:34:52 <guerra> dcoutts like C:/ghc/ghc-6.4.1/libHSrts.a(Main.o)(.text+0x43):Main.c: undefined reference to ` ZCMain_main_closure'
10:35:02 <dcoutts> guerra, oh you forgot --make
10:35:18 <dcoutts> ghc --make HelloWorld.hs
10:35:36 <SamB_XP> that *is* a very unfriendly error message, though
10:35:44 <dcoutts> yeah
10:35:59 <SamB_XP> I mean, why would he want something called :Main.main in his program, anyway?
10:36:02 <dcoutts> it's because ghc doesn't currently record in the .o file which packages the thing depends on
10:36:29 <guerra> SamB_XP: yes me with my lack of experience would never guess that :P
10:36:43 <dcoutts> guerra, basically always use --make
10:36:52 <guerra> dcoutts did and got no errors
10:37:27 <SamB_XP> guerra: you wouldn't even be able to guess at the un-mangled symbol name, right?
10:37:58 <guerra> SamB_XP:  haha nope :P
10:38:23 <SamB_XP> of course, being able to guess at it doesn't help much unless you have a clue what it means...
10:38:28 <dcoutts> SamB_XP, the plan is for ghc packages to be single .so files containing all the .hi and package.conf information
10:38:38 <dcoutts> then ghc will be able to tell you exactly what is missing
10:38:49 <dcoutts> if you omit --make and forget all the -package flags
10:38:50 <SamB_XP> dcoutts: oh, nice
10:39:06 <SamB_XP> I might need to find more RAM, though
10:39:12 <dcoutts> why?
10:39:20 <SamB_XP> probably not, I guess
10:39:40 <dcoutts> the .hi bits do not need to be loaded at runtime
10:39:55 <SamB_XP> oh, I meant because the whole package would need loading...
10:40:07 <dcoutts> but it doesn't which is nice :-)
10:40:15 <dcoutts> .so files get loaded on demand
10:41:05 <SamB_XP> hmm, true
10:41:13 <SamB_XP> I hadn't thought of that
10:41:26 <SamB_XP> in that case, I might just need to go find some more address bits ;-)
10:41:28 * SamB_XP kids
10:41:43 * SamB_XP has plenty more address space than RAM ;-)
10:42:48 <SamB_XP> I do, however, think that someone should consider having GHC do *something* about spatial locality of code
10:43:57 <dcoutts> profile driven feedback
10:44:15 <SamB_XP> yeah, I was thinking that too
10:44:19 <dcoutts> and generating the basic blocks in a better order
10:44:34 <dcoutts> well with the fasm backend we have the level of control to do that
10:44:38 <SamB_XP> but even just having *some* regard for order of code would be nice ;-)
10:44:59 <SamB_XP> um, the C compiler doesn't generally rearrange functions...
10:45:23 <dcoutts> exactly, so we can only control that with the fasm backend.
10:45:27 <SamB_XP> the mangler rearranges stuff, but it basically works out to be a "zip"
10:45:48 <SamB_XP> I meant that the compiler could just generate the C in the desired order...
10:46:10 <SamB_XP> ... a good start would be to have the Cmm in that order...
10:46:35 <SamB_XP> which should take care of *both* ways, afaik
10:51:30 <guerra> dcoutts whats this, u know? (main.exe:5512): libglade-WARNING **: could not convert string to type `GdkPixbuf' for property `icon'
10:55:05 * EvilRanter is away: dinner
11:02:11 <ndm> once Yhc -O beats GHC with Haskell level transformations, then perhaps people will stop being worried about assembly micro-optimisations for a while ;)
11:03:33 <Igloo> ndm: Not me; I can do the Haskell level transformations myself, but the lower level stuff is just impossible
11:04:19 <roconnor> Igloo: you mean you destroy modularity?
11:04:53 <ndm> Igloo: what if i wrote a more efficient G-machine?
11:09:48 <kpreid> @tell EvilRanter (\x y -> guard x >> y) :: MonadPlus m => Bool -> m a -> m a
11:09:48 <lambdabot> Consider it noted.
11:13:13 <guerra> anyone knows?
11:14:00 <Igloo> roconnor: Modularity isn't too much an issue where it matters
11:14:41 <Igloo> ndm: I'd have to see how it compared...
11:16:48 <roconnor> @type unless
11:16:49 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
11:31:33 <psicho> hello all
11:32:10 <psicho> i would like to ask if anybody could help me with a haskell prog i have to make
11:33:17 <dcoutts> guerra, probably the stock icon name is wrong or the icon is missing.
11:33:50 <sylvan> psicho: Don't ask to ask, just ask! :-)
11:34:00 <guerra> dcoutts ooh cause by a stock then
11:35:39 <psicho> well i just wanted to be polite , but sorry
11:35:58 <guerra> psicho: dont get offended, just a general rule around :P
11:36:35 <psicho> basicaly i have this peace of working code : http://pastebin.com/822739 , and i have to make a little modification to it but im so so lame with haskell that i dont realy know how
11:38:08 <yaxu> psicho: is this coursework?
11:38:08 <psicho> what that little code do ,is that it takes a list of barcodes and produce a formated bill , and i have to modifi it ,so it would be able to produce a formated bill with a discount
11:39:22 <psicho> coursework? :) sorry i dont understand that word, but they gave me this task at school
11:40:07 <yaxu> in the UK coursework means schoolwork that goes towards your final grade
11:40:37 <yaxu> so you are asking for help but not an answer I guess :)
11:40:38 <psicho> nah its just some kind of homework, nothing special
11:41:47 <psicho> well any kind of help would come in handy
11:42:01 <psicho> cuz im realy very lame with haskell,
11:42:44 <yaxu> do you know other computer languages?
11:43:00 <psicho> well i know C
11:44:07 <psicho> but it doesnt help me with haskell, it just make me do things in a different way i should do
11:44:23 <yaxu> yes indeed they are quite different
11:45:14 <yaxu> this is an intro to haskell for c programmers - http://www.haskell.org/~pairwise/intro/intro.html
11:45:17 <lambdabot> Title: Haskell for C Programmers, http://tinyurl.com/gcyso
11:45:50 <psicho> is it posible to learn it within a day ? :)
11:46:05 <yaxu> for this task, yes
11:46:39 <yaxu> i would recommend reading this more than anything - http://www.cs.nott.ac.uk/~gmh/preview.pdf
11:46:40 <psicho> ok so im gonna read it , but if a fail to modifi it i will come back :D
11:46:57 <yaxu> i found it much clearer than the other tutorials
11:47:15 <psicho> thanx for the links
11:48:17 <araujo> Hello
11:48:21 <yaxu> i don't know what other advice to give, i'm quite a beginner haskell programmer too
11:48:38 <psicho> the problem is that i have to make this bill prog till Wednesday
11:49:07 * araujo writing a small Haskell editor for fun
11:50:17 <guerra> dcoutts weird cause i removed all the stock stuff i had in the gui im creating and it still wont work........any idea?
11:50:38 <yaxu> psicho: i think you need to look carefully at formattotalprice
11:50:43 <dcoutts> guerra, it doesn't work, or just gives that warning ?
11:51:03 <guerra> it gives the warning when i execute and doesnt show teh gui
11:51:20 <yaxu> araujo: a Haskell editor for editing Haskell
11:51:21 <yaxu> ?
11:55:06 <dcoutts> guerra, the warning is probably unrelated, are you sure you're showing the window ?
11:55:07 <guerra> dcoutts i did everything like in the example of that tutorial u sent me, the only difference is the gui, i created mine already
11:55:22 <dcoutts> calling widgetShowAll ?
11:56:35 <guerra> dcoutts i do that in the haskell program ?
11:57:23 <dcoutts> guerra, yes
11:57:34 <araujo> yaxu, yup
11:57:37 <araujo> dcoutts!!!!!
11:57:48 <dcoutts> guerra, like this:
11:57:48 <dcoutts> http://darcs.haskell.org/gtk2hs/demo/glade/GladeTest.hs
11:57:50 <lambdabot> http://tinyurl.com/yyfjtf
11:57:58 <dcoutts> hia araujo :-)
11:59:22 <yaxu> araujo: are you using curses?  i'd like a look if you get something working
11:59:30 <guerra> dcoutts yaaaaaaaaaaaaaaaaaaaaaaaa worked, :P was newbie agaion hahahaha thanks man
11:59:35 <guerra> dcoutts cya later
11:59:40 <dcoutts> well done :-)
12:00:17 <guerra> dcoutts many thanks :D
12:00:18 <yaxu> araujo: if you have an editor written in its own language you can do fun stuff with interactive programming
12:00:39 <yaxu> araujo: like write a program that edits itself before your eyes
12:00:41 <dcoutts> eg yi
12:00:55 <araujo> yaxu, no , i am playing with gtk atm
12:01:33 <araujo> yeah, it might give you nice interactive tricks
12:05:37 <newbcoder> I am trying to install haskell on my comp account
12:05:40 <newbcoder> but I don't have so much space
12:05:43 <newbcoder> is there a way to build a "minimum haskell" ?
12:06:05 <sylvan> newbcoder, hugs?
12:06:17 <newbcoder> also; wtf is yhc?
12:06:21 <newbcoder> hmm, I am runing linux
12:06:25 <stepcut> york haskell compiler
12:06:28 <jcreigh> newbcoder: install it on your own machine?
12:06:58 <newbcoder> I meant what is new about yhc?
12:07:06 <newbcoder> jcreigh, I want to use it on this many many node cluster
12:07:06 <yaxu> echo "please install ghc" | mail root -s "haskell needed asap"
12:07:11 <newbcoder> but I have limited space on the cluster in my home dir
12:07:13 <sylvan> newbcoder, hugs is fairly lightweight.. IIRC there is also a "minimal" package that is even smaller
12:07:16 <stepcut> newbcoder: it compiles to byte-code, and has a small, highly portable runtime for running the bytecode
12:07:16 <jcreigh> newbcoder: ah, okay.
12:07:53 <newbcoder> hmm; one more dumb qusetion; how does hugs and ghc compare?
12:07:58 <sylvan> It's fairly fast at doing the actual compiling as well (unlike GHC, say)
12:08:17 <sylvan> newbcoder:  ghc usually produces faster code, hugs usually compiles faster
12:08:34 <sylvan> newbcoder:  hugs may be more portable as well
12:09:02 <newbcoder> but the language is largely the same?
12:09:06 <dechunker> How do I determine what type of object a file path references (file, directory, fifo, socket, ...)?
12:09:11 <newbcoder> i.e. they both confirm tro nearly the same haskell standard?
12:09:12 <sylvan> Both support Haskell98
12:09:28 <newbcoder> so both work with "Haskell school of expression" ?
12:09:37 <sylvan> Haskell98 is the latest standard. GHC has some extensions for that, and Hugs support quite a few of those as well.
12:10:09 <ndm> newbcoder: windows or linux?
12:10:10 <sylvan> newbcoder: I think both has a special SOE module which contains all the graphics stuff fro SOE... Not 100% sure though...
12:10:29 <newbcoder> linux
12:10:40 <newbcoder> okay, but other than the graphics stuff; everything in SOE should work in hugs?
12:10:56 <ndm> newbcoder: i recommend hugs over GHC, since its faster to start learning (faster compilation by miles)
12:11:08 <ndm> newbcoder: but lots of people switch to GHC after they've learnt
12:11:51 <newbcoder> ghc requires ghc to compile; hugs looks like it compieslf rom C?
12:12:57 <Cale> newbcoder: yeah, though you just shouldn't compile GHC yourself unless you're hacking on it
12:13:08 <jcreigh> newbcoder: One option to use Haskell in that clustered environment might be to compile your programs locally with GHC and then upload the binary to the cluster. (I've never tried such a thing, but it seems like if binary was statically linked, it would work. Assuming the cluster in Linux-based as well.)
12:13:26 <jcreigh> *is linux-based
12:14:47 <newbcoder> cluster is 64bit only; my dekstop is 32bit
12:14:54 <newbcoder> okay; hugs installed
12:15:01 <jcreigh> gah.
12:15:01 <newbcoder> where can I read up on using haskell for systems scripting
12:15:04 <newbcoder> in the spirit of linspire?
12:15:13 <newbcoder> is there's like a haskell cookbook
12:15:14 <jcreigh> Well, there's cross-compiling, but that's black magic, so probably not an option.
12:15:16 <newbcoder> itd' be great
12:17:27 <Cale> newbcoder: there are some libraries available which work in that direction. If you're just learning the language, I'd recommend starting out without worrying about IO, and picking up IO once you understand ordinary evaluation :)
12:17:50 <Cale> (not that it has to be done that way, but I think it would make more sense, personally)
12:24:55 <newbcoder> is "All about Mondas" avaliable as a PDF anywyhere?
12:24:59 <newbcoder> hard to print html files
12:38:54 <yaxu> "In Haskell 98, the ClockTime type is abstract."
12:39:01 <yaxu> does that mean I can't construct one?
12:39:55 <ndm> @hoogle a -> ClockTime
12:39:57 <lambdabot> No matches, try a more general search
12:42:28 <yaxu> hm
12:46:08 <Pupeno> lambdabot: paste?
12:46:15 <jcreigh> @paste
12:46:16 <lambdabot> http://paste.lisp.org/new/haskell
12:46:18 <Pupeno> lisppaste2: url ?
12:46:18 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
12:46:38 <lisppaste2> Pupeno pasted "simple use of streams" at http://paste.lisp.org/display/29752
12:47:17 <Pupeno> Does anybody know why http://paste.lisp.org/display/29752, a simple use of Bulat's Streams gives "*** Exception: illegal operation" wher running ?
12:48:40 <yaxu> @hoogle a-> a -> ClockTime
12:48:41 <lambdabot> No matches, try a more general search
13:13:05 <LiquidEngineer> hello
13:13:05 <lambdabot> LiquidEngineer: You have 1 new message. '/msg lambdabot @messages' to read it.
13:13:57 <LiquidEngineer> anyone know of a good fortran chatroom?
13:14:15 <LiquidEngineer> I'm surprised there's not one on Freenode...
13:20:39 <Pupeno> What does [:e:] mean in "instance (Binary e) => Binary [:e:] where" ?
13:21:13 <sjanssen> Pupeno: parallel array
13:21:53 <Pupeno> haddock gives me a Parse error on [:e:]
13:21:57 <chessguy> 'afternoon
13:22:19 <sjanssen> yeah, Haddock wont understand it, it's a GHC extension
13:22:46 <Pupeno> oh :/
13:23:18 <sjanssen> some libraries use the C preprocessor and use "#ifdef __HADDOCK__" around such things
13:23:31 <sjanssen> oh, I mean "#ifndef __HADDOCK__"
13:24:48 <Pupeno> Thanks.
13:27:43 <lispy> i think the next version of haddock will be fine with ghc extensions
13:27:56 <lispy> iirc, someone worked on that this summer
13:57:07 <lispy> or
13:57:09 <lispy> oops
14:08:19 <dcnstrct> Hi.  I'm new to the haskell.  I'm currious about how easy or hard it is to write various things in a X-platform way using haskell.  Is it difficult to write cross platform haskell code that makes use of sockets API ?
14:14:05 <hyrax42> dcnstrct: I believe so
14:17:07 <ibid> dcnstrct: no more difficult thatn in C
14:17:41 <hyrax42> oh woops, I meant to say I belive it's not too hard
14:18:00 <hyrax42> I've done at least some basic stuff that ran without trouble in OS X and some linux or other
14:18:28 <dcnstrct> ibid, C is terrible for writing x-platform sockets code isnt it ?
14:19:05 <dcnstrct> ok maybe not terrible
14:19:29 <lispy> ndm: okay, just running on the CLR is a start, but if it could be made to support COM and directly interface with other .NET languages that would be amazingly useful to industry types
14:19:58 <ndm> lispy, yes it would, but we need someone who wants to do that to step up and help...
14:20:25 <lispy> ndm: :)
14:21:08 <lispy> i have too much on my plate with my research, full-time work and the other projects i'm already trying to help on
14:21:27 <ndm> yep, me too...
14:35:06 <Botty> ?users
14:35:07 <lambdabot> Maximum users seen in #haskell: 265, currently: 253 (95.5%), active: 26 (10.3%)
14:38:17 <sjanssen> @quote
14:38:18 <lambdabot> jrmole says: any program that could read minds would just evolve into a porn downloader
14:42:56 <lispy> heh, i remember that
14:43:29 <lispy> ?quote
14:43:29 <lambdabot> Paltas says: i read that the python developer considered to remove nearly all functional programming methods from python.. wondered if he got a stroke or something..
14:44:59 <dons> what does this program print for people:
14:44:59 <dons> http://www.cse.unsw.edu.au/~dons/tmp/t.c
14:45:17 <dons> i get different results depending on the machine i'm on :)
14:45:32 <sjanssen> 101
14:45:43 <pkhuong> dons: it's undefined, btw.
14:45:49 <pkhuong> erh wait.
14:45:52 <dons> yeah, i get 101 on linux, and 200 on my openbsd box :)
14:46:04 <lispy> dons: that's not valid C
14:46:05 <sjanssen> this is an Intel Mac with i686-apple-darwin8-gcc-4.0.1
14:46:22 <lispy> i don't think
14:46:30 <lispy> but then again, gcc doesn't complain with -Wall
14:46:56 <lispy> i get 101 on Darwin lychee 8.8.0 Darwin Kernel Version 8.8.0: Fri Sep  8 17:18:57 PDT 2006; root:xnu-792.12.6.obj~1/RELEASE_PPC Power Macintosh powerpc
14:47:21 <dons> gcc version?
14:47:31 <lispy> $ gcc --version
14:47:31 <lispy> powerpc-apple-darwin8-gcc-4.0.1 (GCC) 4.0.1 (Apple Computer, Inc. build 5363)
14:47:33 <sjanssen> 200 on Sparc Solaris, gcc 3.4.5
14:47:51 <spiffy> 200 on gcc version 4.1.2 20060928 (prerelease) (Ubuntu 4.1.1-13ubuntu5)
14:48:20 <dons> mmm:
14:48:22 <dons> $ gcc-2.95 t.c
14:48:22 <dons> $ ./a.out
14:48:22 <dons> 200
14:48:22 <dons> $ gcc-3.3 t.c
14:48:24 <dons> $ ./a.out
14:48:25 <pkhuong> 200 on 3.4.6 (ia32)
14:48:27 <dons> 200
14:48:29 <dons> $ gcc-3.4 t.c
14:48:32 <dons> $ ./a.out
14:48:34 <dons> 200
14:48:37 <dons> $ gcc-4.0 t.c
14:48:40 <dons> $ ./a.out
14:48:42 <dons> 101
14:48:45 <dons> interesting
14:49:00 <sjanssen> dons: how did you stumble on to this one?
14:49:02 <pkhuong> dons: looks like a regressio in 4.0
14:49:04 <lispy> reading it, i sort of expect 201 as the answer :)
14:49:06 <pkhuong> 4.1 has it like 3.4
14:49:27 <dons> pkhuong: ?
14:49:40 <dons> you get a different result from 4.0 to 4.1?
14:49:43 <pkhuong> yes
14:49:48 <dons> ah good.
14:49:57 <dons> sjanssen: oh, a colleague found it
14:50:21 <lispy> $ gcc-3.3 t.c
14:50:26 <lispy> $ a.out
14:50:26 <lispy> 200
14:50:48 <Botje> that's undefined behavior, right?
14:50:57 <pkhuong> Botje: no, just really unintuitive.
14:51:04 * spiffy would love to know what experiment he just participated in was :)
14:51:09 <pkhuong> Pretty sure 4.0 has it wrong.
14:51:19 <dons> yeah that's what I think too.
14:51:30 <pkhuong> no sequence point in the x =... expression, i think.
14:51:49 <lispy> why is it giving 200 instead of 201
14:51:52 <lispy> that's what i don't get
14:51:56 <dons> good test case for handing to 1st year students (that's what its going to be used for, I think ... ;)
14:52:19 <pkhuong> lispy: ++ increments after the whole expression/sequence point.
14:52:40 <pkhuong> so p is only updated after it's been dereferenced and a[0] incremented.
14:53:06 <pkhuong> dons: that dude deserves to burn in hell if he exposes people like me to that :p
14:53:07 <lispy> so x is 201 and *p is still 200 okay
14:53:15 <pkhuong> yes.
14:53:18 <pkhuong> no
14:53:19 <pkhuong> x is 101
14:53:20 <lennart> dons: that looks like a compiler bug to me :)
14:53:36 <lennart> the 101, i mean
14:54:09 <lispy> pkhuong: i think *(p++) means that p incremented before it is dereferenced, is this wrong?
14:54:19 <lennart> after
14:54:19 <pkhuong> lispy: yes.
14:54:23 <pkhuong> (it is wrong)
14:55:39 <lispy> okay, but as far as x is concerned, *(p++) = *(p+1), it's just that p doesn't get the effect until after the assignment?
14:56:13 <pkhuong> lispy: no. it's *post* increment
14:56:20 <lennart> no, *(p++) has the same value as *(p)
14:56:22 <norpan> *(p++) = *p
14:56:26 <pkhuong> so *(p++) ~=*p; p = p+1;
14:57:09 <liyang> (There aren't enough =/equality/assignment symbols in ASCII.)
14:57:10 <norpan> i had some idiot writing p = p++ expecting that it would be the same as p = p + 1
14:57:23 <pkhuong> lol.
14:57:24 <norpan> err, not idiot
14:57:39 <norpan> in verilog, but still
14:57:45 <norpan> system verilog
14:58:05 <lispy> i'm not sure this code has a defined behavior
14:58:08 <lennart> system verilog,eh
14:58:13 <norpan> he wouldn't accept that the increment operation got optimized away
14:58:15 <lispy> but i guess that's the point
14:58:18 <lennart> didn't know there were any users of that
14:58:31 <norpan> i wish there weren't :)
14:58:53 <lispy> so does ++ count asa function call
14:58:58 <JKnecht> gcc version 4.0.0 20050519 (Red Hat 4.0.0-8): 101
14:59:05 <lennart> system verilog is one of the worst "designs" i've ever seen
14:59:22 <lennart> so i bet it will be popular
14:59:25 <Codex_> lispy: if you've overloaded the ++ operator, yes.
14:59:26 <lennart> :(
14:59:26 <norpan> yeah
14:59:36 <lispy> because in C if you have multiple function calls in one statement the order of evaluation is undefined
15:00:25 <norpan> p = p++ is evaluated like this: the value of the rhs is set to p, p is incremented, p is assigned the value of the rhs, that is: p
15:00:33 <norpan> before the increment...
15:00:45 <norpan> so, p = p++ optimizes to nothing
15:01:06 <Pupeno> Does anybody know how to read and write from standard input/output with Streams ?
15:01:17 <norpan> anyway, bed time
15:01:39 <dons> ?remember lennart system verilog is one of the worst "designs" i've ever seen. so i bet it will be popular
15:02:01 <norpan> at least sv is better than pure verilog
15:02:12 <lennart> norpan: but in C I don't think p=p++ is well defined.  There are two effects on p with no sequence point between
15:02:15 <fabiim>  if abcd = takeWhile isAlpha works , why abcd = map toUpper (takeWhile isAlpha)  won't ?
15:02:36 <norpan> lennart: it's not well defined, you are right
15:02:49 <dons> fabiim: abcd = map toUpper . takeWhile isAlpha
15:02:51 <lennart> norpan: pure verilog is still relatively simple, which can't be said for sv
15:02:56 <dons> ?type map toUpper . takeWhile isAlpha
15:02:57 <lambdabot> [Char] -> [Char]
15:03:01 <dons> ?type map toUpper (takeWhile isAlpha)
15:03:03 <lambdabot>   Expecting a function type, but found `[a]'
15:03:03 <lambdabot>    Expected type: [Char]
15:03:17 <fabiim> uhh , composition  !! haskell so damn sexy
15:03:23 <dons> :)
15:03:47 <norpan> lennart: well, it's complicated enough to be that simple :)
15:04:05 <lennart> yeah, it is
15:04:26 <lennart> verilog should only be used as a target language, never a source language
15:04:54 <norpan> the hardware industry is conservative, you know :)
15:05:05 <lennart> oh, i know, i know
15:06:31 <lispy> so it comes down to this, both 3.3 and 4.0 are effectively choosing to ignore one post increment, and choosing differently
15:07:51 <lennart> 200 is a valid result
15:08:39 <lisppaste2> lispy pasted "Example that maybe shows the ignoring?" at http://paste.lisp.org/display/29755
15:09:42 <norpan> if the behaviour is undefined, in theory any value is a valid result :)
15:10:08 <lispy> can we rename it unsafePostIncement?
15:10:14 <lispy> Increment*
15:10:38 <lennart> but I don't think (*p++)++ is undefined
15:10:49 <lispy> x = unsafePostIncrement (*(unsafePostIncrement p));
15:12:53 <lennart> if everything unsafe in C was marked as such it would be a very verbose language
15:12:59 <lispy> ;)
15:13:27 <lispy> if we assumed the inter ++ happens first then 200 would be correct
15:14:03 <lispy> and if we assumed the outer one happens first, i think we get the same thing...
15:14:21 <lispy> you increment 100, throw it away, then increment p
15:14:33 <lennart> it doesn't matter in which order the two ++ happen.  they affect different memory locations
15:14:59 <lennart> one increments p, the other increments what p points to
15:15:08 <lispy> right
15:15:20 <lispy> but i was still doing it the pedestrian way :)
15:15:28 <lispy> i'm now convinced that 200 is the only answer
15:15:31 <lispy> 101 is invalid
15:15:40 <bitwiseshiftleft> here's a stupid question: how does one reduce the executable size of a haskell program?
15:15:41 <lennart> absolutly
15:15:52 <lennart> bitwiseshiftleft: strip?
15:16:08 <lennart> bitwiseshiftleft: dynamic linking?
15:16:47 <lennart> bitwiseshiftleft: what platform are you using?
15:16:50 <bitwiseshiftleft> lennart: so compiled the null program, and it's 308kb.  after strip, it's 217k
15:16:53 <bitwiseshiftleft> lennart: linux
15:17:12 <lispy> bitwiseshiftleft: hnop?
15:17:19 <lennart> bitwiseshiftleft: yeah, there's a lot of cruft that is always linked in.
15:17:26 <lennart> bitwiseshiftleft: switch to jhc :)
15:17:40 <lennart> bitwiseshiftleft: I assume this was ghc?
15:18:05 <bitwiseshiftleft> lennart: this is ghc, yeah
15:18:14 <lispy> having small binaries can be nice but for desktop systems i don't really see it mattering much :)
15:18:36 <lispy> if this had to run from a floppy or something i could see the complain
15:18:51 <bitwiseshiftleft> lispy: the problem is, you link in, like, anything, it gets enormous
15:19:33 <lennart> yes, it's a problem
15:19:35 <dons> bitwiseshiftleft: yeah on the mac you can dynamically link the rts
15:19:39 <lispy> is this partially because of parametric polymorphism?
15:19:42 <dons> so helloworld is about 8k
15:20:05 <fabiim> how could I search a list in a bigger list? I don't see any function like that  in Prelude so I assume there is some kind of haskell trick do it easily
15:20:06 <dons> but basically you've got that rts linked in statically. that's all.
15:20:09 <bitwiseshiftleft> dons: that's great.  any way to do it on linux?
15:20:09 <lennart> nothing to do with polymorphism, just the way the runtime is set up
15:20:33 <dons> bitwiseshiftleft: I *think* it works experimentally on x86/linux. but you'll need to ask on glasgow-haskell-users@ for the precise details
15:20:39 <dons> it would be experimental
15:20:47 <lispy> fabiim: what do you want it to return?
15:20:49 <bitwiseshiftleft> dons: ok, i'll have to look into that
15:20:52 <lispy> fabiim: Bool?
15:21:02 <fabiim> humm let me see ...
15:21:23 <lispy> ?hoogle issubsequenceof
15:21:24 <lambdabot> No matches found
15:21:26 <lennart> fabiim: do you mean looking for, e.g., [1,2] in [0,1,2,3]?
15:21:29 <lispy> ?hoogle subsequenceof
15:21:29 <dons> > find [1,2,3] [[9],[10,100], [1,2,3],[213,23]]
15:21:30 <lambdabot> No matches found
15:21:31 <lambdabot>  Couldn't match `a -> Bool' against `[a1]'
15:21:33 <fabiim> how about the  big list without the searched list
15:21:50 <fabiim> lennart: yes
15:21:59 <dons> > find (==[1,2,3]) [[9],[10,100], [1,2,3],[213,23]]
15:22:01 <lambdabot>  Just [1,2,3]
15:22:11 <dons> > find (==[1,2,7]) [[9],[10,100], [1,2,3],[213,23]]
15:22:13 <lambdabot>  Nothing
15:22:27 <lispy> dons: but the second list would be the concat of your second list
15:22:44 <araujo> brb
15:22:45 <lennart> > any (isPrefix [1,2]) (tails [0,1,2,3])
15:22:47 <lambdabot>  Not in scope: `isPrefix'
15:22:52 <dons> > elemIndex [1,2,3] [[9],[10,100], [1,2,3],[213,23]]
15:22:53 <lambdabot>  Just 2
15:23:03 <twanvl> > any (isPrefixOf [1,2]) (tails [0,1,2,3])
15:23:04 <lambdabot>  True
15:23:09 <lennart> thanks :)
15:23:35 <fabiim> whow
15:24:01 <lispy> ?pl \x xs -> any (isPrefixOf x) (tails xs)
15:24:02 <lambdabot> (. tails) . any . isPrefixOf
15:24:55 <lennart> looks a bit like magic :)
15:25:24 <bitwiseshiftleft> is there a good way to make a global IORef?
15:25:31 <lennart> no
15:25:32 <bitwiseshiftleft> or one which is like, global within a module?
15:25:41 <dons> another use for dot = (.) . (.)
15:25:53 <dons> tails `dot` any . isPrefixOf
15:25:56 <lispy> bitwiseshiftleft: you'll need to tell your compiler not to inline the IORef
15:26:06 <lispy> bitwiseshiftleft: and use unsafePerformIO when yo create it
15:26:07 <dons> ?type let dot = (.) . (.) in tails `dot` any . isPrefixOf
15:26:09 <lambdabot>   precedence parsing error
15:26:09 <lambdabot>     cannot mix `dot' [infixl 9] and `(.)' [infixr 9] in the same infix expression
15:26:17 <dons> ?type let dot = (.) . (.) in tails `dot` (any . isPrefixOf)
15:26:17 <bitwiseshiftleft> lispy: ok, i guess that's probably the best that can be done
15:26:18 <lambdabot>   Couldn't match `[a]' against `Bool'
15:26:19 <lambdabot>    Expected type: [a1] -> [[a1]] -> [a]
15:26:30 <lennart> bitwiseshiftleft: global variables are a pain to make.  and rightly so! ;)
15:26:41 <bitwiseshiftleft> lennart: why rightly so?
15:26:59 <lennart> because they are evil
15:27:10 <lispy> bitwiseshiftleft: well, for one, when should they happen relative to othere global IORefs?
15:27:14 <bitwiseshiftleft> mhm.  is this like the way that memo tables are evil?
15:27:32 <dons> hey thetallguy
15:27:37 <bitwiseshiftleft> lispy: doesn't matter, right?  IORef allocation has no side effects...
15:27:38 <lennart> bitwiseshiftleft: memo tables can be evil
15:27:54 <bitwiseshiftleft> lennart: how so?
15:27:57 <lennart> bitwiseshiftleft: when is the memotable garbage collected?
15:28:09 <lispy> bitwiseshiftleft: well, i just told you to use unsafePerformIO :)
15:28:11 <thetallguy> Howdy dons
15:28:16 <dons> ?users #haskell.fi
15:28:16 <thetallguy> I owe you some edits.
15:28:16 <lambdabot> Maximum users seen in #haskell.fi: 10, currently: 9 (90.0%), active: 2 (22.2%)
15:28:19 <dons> ?users #haskell.se
15:28:19 <lambdabot> Maximum users seen in #haskell.se: 12, currently: 9 (75.0%), active: 3 (33.3%)
15:28:20 <thetallguy> Got distracted.
15:28:23 <dons> ?users #haskell.es
15:28:24 <lambdabot> Maximum users seen in #haskell.es: 13, currently: 9 (69.2%), active: 5 (55.6%)
15:28:25 <dons> ?users #haskell.de
15:28:26 <lambdabot> Maximum users seen in #haskell.de: 5, currently: 3 (60.0%), active: 0 (0.0%)
15:28:39 <bitwiseshiftleft> lispy: true.  still, it would be nice if there were a clean way to do it
15:28:39 <dons> thetallguy: you owe  me some edits?
15:28:58 <thetallguy> The o'caml tutorial you converted.
15:29:02 <dons> ah :)
15:29:07 <bitwiseshiftleft> lennart: memo table garbage collection should be up to the application, but like, it's a well-studied problem
15:29:08 <dons> yes. i need to finish that
15:29:13 <lispy> bitwiseshiftleft: sure, but afaik, no one solves all deep problems with it in a way that the community is happy with
15:29:29 <thetallguy> The introduction to lists only shows the [,] form
15:29:34 <bitwiseshiftleft> lispy: true enough :-)
15:29:44 <thetallguy> then goes straight to pattern matching with the x:xs syntax
15:29:49 <lennart> bitwiseshiftleft: well, if it's up to the application you need to assume/enforce some evaluation order
15:29:50 <thetallguy> with no indication that they are the same
15:30:03 <thetallguy> I think it was a bug in the original tutorial.
15:30:45 <bitwiseshiftleft> lennart: you're right, but sometimes it would be nice to have a way to make a memoized function that still counts as a function
15:31:02 <lennart> bitwiseshiftleft: I'm not saying there are no legitimate uses of global variables.  just that you should to think hard before using one.
15:31:07 <dons> thetallguy: ah yes.
15:31:10 <bitwiseshiftleft> lennart: sure
15:32:24 <lennart> bitwiseshiftleft: perhaps a local use of a variable would be better?  one where the memo table can be collected when the function is no longer in use?
15:32:51 <lispy> IMO, this is why i think haskell modules should be like classes in OO languages
15:33:08 <lennart> nonono, that would ruin haskell
15:33:10 <bitwiseshiftleft> lennart: oh, i wasn't going to use the global variable for a memo table. i was just comparing it to things haskell doesn't do well, and people sometimes excuse that by saying they're evil
15:33:44 <dons> lispy: you want maybe a value representing a module with an existential wrapping up the interface?
15:33:55 <thetallguy> ?seen stepcut
15:33:56 <lambdabot> stepcut is in #haskell and #haskell-blah. I don't know when stepcut last spoke.
15:34:29 <lispy> dons: i'm not sure, but i wish modules were first class and you could instantiate different versions of them and have polymorphism between them
15:34:31 <dons> bitwiseshiftleft: sounds interesting. do you have a code example somewhere?
15:34:35 <lennart> bitwiseshiftleft: not everything haskell does badly is evil.  but i happen to think global variables are :)
15:34:49 <thetallguy> Is anyone else as excited about yhc as I am?
15:34:51 <fabiim> does the lambdabot runs on haskell? lol
15:34:54 <dons> lispy: ask bob harper to implement module functors in ghc for us? :)
15:35:02 <dons> fabiim: of course.
15:35:11 <fabiim> lolol =)
15:35:12 <dons> ?version
15:35:13 <lambdabot> lambdabot 4p263, GHC 6.5 (OpenBSD i386)
15:35:13 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
15:35:16 <lispy> thetallguy: does ndm count :)
15:35:43 <thetallguy> No.
15:35:55 <dons> yeah, there's a bit of buzz around yhc, isn't there. the mailing list traffic seems to be going up
15:35:55 <thetallguy> Well, yes, I suppose he does.
15:36:00 <ndm> does ndm could for what?
15:36:05 <thetallguy> I'll tel you what excited me.
15:36:09 <bitwiseshiftleft> dons: well, at some point i needed to build something equivalent to Unique, but in STM rather than in IO
15:36:11 <lispy> instead of having the module store a global value, couldn't the value be constructed when the module is instantiated?
15:36:20 <thetallguy> 145k executable for yhi
15:36:26 <ndm> ah seen it now, yes, i'd be really interested to know
15:36:33 <dons> bitwiseshiftleft: ok, so StateT Unique STM ?
15:36:36 <thetallguy> and approx 225 bytes for helloworl.
15:36:53 <ndm> thetallguy: i reckon taking out libgmp could make that nearer 100Kb, if you don't want arbitrary precision int's
15:36:54 <thetallguy> Granted, those will probably grow a bit.
15:36:59 <lennart> lispy: first class modules are cool.  but they open up a new can of worms.  e.g., are types defined in different instances of the same module equal or not?
15:37:06 <bitwiseshiftleft> dons: StateT ?
15:37:18 <thetallguy> We'vee been putting ocaml into our initial ram disk
15:37:20 <dons> bitwiseshiftleft: you want to layer a unique supply over the STM monad?
15:37:25 <ndm> thetallguy: no, those sizes are pretty much fixed - maybe a little for a few extra primitives, but nothing massive
15:37:27 <bitwiseshiftleft> dons: yeah
15:37:27 <dons> sounds like a job for the StateT monad transformer.
15:37:32 <thetallguy> mixing bash and ocaml, etc.
15:37:35 <thetallguy> a mess.
15:37:41 <ndm> thetallguy: although remember that there are the .hbc libraries, which are included in the size
15:37:45 <dons> bitwiseshiftleft: let me find you an example
15:37:50 <lispy> lennart: interesting
15:37:52 <thetallguy> No matter.
15:38:04 <thetallguy> We pull in only the libraries we need.
15:38:10 <thetallguy> the point is, it can be embedded.
15:38:15 <ndm> yes, it certainly can
15:38:19 <lispy> lennart: but if it's just a matter of type theory, i'm sure haskell researchers ane the most capabale to solve the problems :)
15:38:30 <ndm> i want to write a .hbc file linker at some point as well, ideal for embedding
15:38:37 <thetallguy> So, finally, one language can be used everywhere...
15:38:42 <dons> bitwiseshiftleft: here, http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot and http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
15:38:45 <lambdabot> Title: Roll your own IRC bot - HaskellWiki, http://tinyurl.com/y4prf8
15:38:51 <thetallguy> Nice work, ndm.
15:38:52 <lispy> bitwiseshiftleft: have you seen MonadUnique?
15:38:55 <ski> (bitwiseshiftleft : 'newIORef' has performs effects, yes)
15:38:58 <lennart> lispy: in Cayenne I had first class modules, but I also use structural type equality instead of nominal type equality as Haskell does.
15:39:09 <bitwiseshiftleft> lispy: no, what's MonadUnique?
15:39:14 <dons> bitwiseshiftleft: basicaly you lift your code into a new monad, type Foo = StateT Unique STM, and then you can use both State and STM monad ops
15:39:16 <thetallguy> I don't care about the 50k for gdm.
15:39:20 <thetallguy> Worthwhile.
15:39:32 <lispy> ?google haskell wiki MonadUnique
15:39:34 <lambdabot> http://haskell.org/hawiki/MonadUnique
15:39:35 <lambdabot> Title: MonadUnique - The Haskell Wiki
15:39:39 <dons> ?docs Control.Monad.State
15:39:39 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
15:39:42 <ndm> yes, but i'm sure you could do a smaller sized integer implementation
15:40:01 <thetallguy> Sre.
15:40:16 <thetallguy> Sure, but compared to what I've got now.
15:40:25 <thetallguy> It's already ahead.
15:40:32 <ndm> yes, thats good to hear
15:40:46 <ndm> well the feature of Yhc that I am really excited isn't quite public yet, but should be in a few days
15:40:54 <bitwiseshiftleft> dons: hm, cool, i might be able to use that...
15:40:58 <thetallguy> Although, the fact that it crashes when you use the gdm...
15:41:12 <ndm> yeah, i'm sure tom will fix that soon
15:41:13 <thetallguy> ...but I assume my bug report will help get that fixed.
15:41:25 <ndm> thetallguy: who are in in real life?
15:41:38 <thetallguy> Clifford Beshers
15:41:50 <ndm> ah, cool :)
15:41:53 <thetallguy> I'm also sitting here with a little arm processor box.
15:41:59 <thetallguy> chumby.com
15:42:03 <lennart> mmmmmm, arm
15:42:07 <thetallguy> built by a friend of mine
15:42:24 <thetallguy> It's designed as a clock radio replacement, plus...
15:42:55 <thetallguy> I'd love to make a haskell applet that would stream down new little bytecode binaries
15:42:59 <thetallguy> do graphics, etc.
15:43:10 <ndm> yeah, that would be very cool
15:43:14 <thetallguy> Hard to put GHC on such a device.
15:43:24 <dons> lisppaste: url
15:43:25 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
15:43:28 <thetallguy> Fun stuff, but not if you have to do it in perl.
15:43:40 <ndm> i have a thing that is almost capable of generating GCC C from Haskell via Yhc
15:43:55 <stepcut> thetallguy: s/gdm/gmp/
15:44:00 <ndm> much much smaller than GHC, and since its just C, cross compiling is a lot smaller
15:44:01 <thetallguy> Utjat wpi;d be cpp; tpp
15:44:22 <thetallguy> but I think the bytecode would be the best in this situation
15:44:35 <thetallguy> or it wil be if I can get the wireless working.
15:44:57 <lisppaste2> dons pasted "StateT [Integer] IO" at http://paste.lisp.org/display/29757
15:44:57 <ndm> sounds good :)
15:45:05 <dons> bitwiseshiftleft: 6^
15:45:46 <thetallguy> the framebuffer is 320x240x5x6x5
15:46:11 <bitwiseshiftleft> dons: huh?
15:46:11 <thetallguy> NHave to figure out how to do bit shifting in Haskell
15:46:22 <lispy> it's easy
15:46:24 <dons> bitwiseshiftleft: http://paste.lisp.org/display/29757
15:46:29 <lispy> look at Data.Bit
15:46:29 <ndm> thetallguy: Data.Bits
15:46:31 <dons> an example of a unique supply layered over IO
15:46:33 <lispy> or is it Bits
15:46:37 <dons> you can extend that to STM if you want :)
15:46:38 <ndm> @hoogle Bit
15:46:39 <lambdabot> Data.Bits.bit :: Bits a => Int -> a
15:46:40 <lambdabot> Data.Bits :: module
15:46:40 <lambdabot> Data.Bits.Bits :: class Num a => Bits a
15:47:00 <thetallguy> Thanks.  I know where it is, just haven't played with it yet.
15:47:02 <bitwiseshiftleft> dons: cool
15:47:13 <bitwiseshiftleft> dons: thanks, i should be able to use that...
15:47:22 <bitwiseshiftleft> getting jhc now...
15:47:45 <dons> jhc? ok...  :)
15:48:06 <dons> could be a bit experimental, be wary :)
15:48:21 <bitwiseshiftleft> dons: well, i'm not installing over ghc.  but i want to try it out, and see how much it improves that 308k
15:48:41 <ndm> bitwiseshiftleft: Yhc will generate smaller code...
15:48:41 <dons> yeah, the problem may be performance or library/language feature support.
15:48:53 <dons> ndm, yhc supports mtl?
15:48:57 <dan2> is there a complete book on Haskell that's free?
15:49:02 <ndm> dons: no chance!
15:49:12 <bitwiseshiftleft> ndm: yhc, huh?  *googles*
15:49:14 <dons> realy??
15:49:23 <dons> bitwiseshiftleft: http://haskell.org/haskellwiki/Implementations
15:49:29 <lambdabot> Title: Implementations - HaskellWiki, http://tinyurl.com/y2epsa
15:49:30 <ndm> well not currently... - one day i hope
15:49:34 <dons> dan2: http://haskell.org/haskellwiki/Books_and_tutorials#Textbooks
15:49:41 <lambdabot> Title: Books and tutorials - HaskellWiki, http://tinyurl.com/vqzky
15:50:09 <dons> bitwiseshiftleft: you may require ghc, ghci or hugs then. if you want to use StateT
15:50:10 <Igloo> dons: The impression I have is that nhc/yhc will try to find someone to rewrite the type checker once Haskell' stabilises
15:50:19 <dons> that'd be a good plan
15:50:47 <dons> ndm, any work on intergrating the work on compressed bytecode interpreters for nhc into yhc?
15:50:48 <ndm> my plan is to rip out the parser and type checker, and rewrite pretty much everything from the parsing to the start of the code generation
15:51:05 <ndm> dons: not even looked at it, the bytecode is Tom's area more than mine
15:51:39 <bitwiseshiftleft> dons: hm.  conflicting goals.  because ghc extensions are cool, but small applications are cool, too.  since even for a desktop app, loading up megabytes is annoying
15:51:52 <ndm> i think the way forward for Haskell is a Haskell compiler with an untyped intermediate language
15:52:05 <dons> bitwiseshiftleft: megabytes probably won't happen if its small
15:52:08 <ndm> (i realise everyone in the world disagrees with me, but hey, that makes life more fun :) )
15:52:09 <lispy> is Haskell' going with fundeps or ATs?
15:52:16 <Igloo> ndm: Why, OOI?
15:52:16 <dons> anyway, you can just use #!/bin/runhaskell and leave it as src
15:52:17 <ndm> lispy: fundeps
15:52:28 <ndm> Igloo: OOI?
15:52:33 <Igloo> Out Of Interest
15:52:35 <dons> ndm. untyped. now you're scaring me.
15:52:36 <bitwiseshiftleft> bitwiseshiftleft: just linking in gtkhs is over a megabyte...
15:52:44 <dons> how do you catch the bugs in the optimisations?
15:52:52 <bitwiseshiftleft> maybe there's a dynamic option somewhere
15:53:00 <ndm> Igloo: because there are lots of cool transformations you can do in an untyped world that you can't in a typed one - defunctionalisation for one
15:53:03 <lispy> bitwiseshiftleft: why is executable size so important?
15:53:12 <ndm> dons: maybe i can just write correct code in the first place ;)
15:53:30 <dan2> does Haskell offer full access to all the bits in an Integer?
15:53:40 <dons> ?instances Bits
15:53:41 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
15:53:48 <dons> ?instances-importing Data.Bits Bits
15:53:49 <lambdabot> Int, Integer
15:53:51 <Igloo> ndm: Is there a simple proof of why you can't defunctionalise in a typed language?
15:53:52 <dons> yes :)
15:54:00 <bitwiseshiftleft> lispy: it's not hugely important, but i'd like to minimize code bloat.  and i'd like to be able to run embedded, since i have an embedded box and some projects that could use a functional language
15:54:03 <dons> (to dan2)
15:54:17 <ndm> Igloo: you can, its just massively harder - and the obvious method requires a dependantly typed language
15:54:19 <dan2> sweet
15:54:21 <dons> bitwiseshiftleft: if you need embedded size, yhc is probably the best bet
15:54:29 <bitwiseshiftleft> dons: ok, i'll try it out
15:54:32 <dons> (having been born a long time ago for that purpose)
15:54:42 <dan2> dons: from a user perspective, how easy is it to use Haskell to export it's functions to say C?
15:54:44 <dons> but still, i'd try ghc before you get too frustrated with missing libs..
15:54:54 <dons> dan2: pretty easy. foreign export foo
15:55:01 <dan2> sweet
15:55:04 <lispy> bitwiseshiftleft: okay, well, ghc is probably a bad choice for embedded systems...otoh, yhc borrows a lot of code from a compiler that used to be fore embedded stuff
15:55:20 <Igloo> Fair enough; I haven't read anything about the algorithms, so can't really comment
15:55:25 <ndm> Yhc is better than nhc for embeded stuff
15:55:35 <dan2> dons: I just need something a bit easier to write audio and video codecs in
15:55:46 <ndm> Igloo: no one has, its my algorithm (based on the paper by Reynolds from at least 30 years ago)
15:56:12 <Igloo> ndm: I meant the existing ones, not yours in particular
15:56:18 <lennart> Igloo: You can defunctionalise in a typed language.  you just need the right type system
15:56:44 <ndm> Igloo: its not a massively common thing to want to do (most people don't want first order haskell...)
15:57:18 <bitwiseshiftleft> hm, jhc doesn't make... oh well, trying yhc
15:57:23 <dan2> dons: and importing from C?
15:57:41 <lispy> ndm: some day i'll have to try out yhc just to findout why you're so excited about it :)
15:57:56 <lispy> ndm: mind you, i'm sure it's good, but i don't know anything about it first hand :)
15:58:00 <bitwiseshiftleft> ... for that matter, yhc doesn't either.
15:58:01 <ndm> lispy: give it a week, watch for the announcement, and you'll see
15:58:10 <ndm> bitwiseshiftleft: what is the issue with Yhc?
15:58:51 <bitwiseshiftleft> make: entering an unknown directory, libffi not found
15:59:05 <lispy> ndm: i could guess that your announcement wil be related to your extended static analysis
15:59:05 <ndm> bitwiseshiftleft: don't do make, do scons
15:59:18 <ndm> lispy: entirely wrong by a mile ;)
15:59:25 <lispy> oh well, hmm..
15:59:28 <lispy> i'll have to wait and see
15:59:32 <ndm> (and its not my announcement, hence why i can't give you any details yet, or else i would)
15:59:54 <bitwiseshiftleft> ndm: ok.  trying scons...
16:00:10 <ndm> bitwiseshiftleft: i'll open a bug that make should say "please use scons"
16:00:21 <lispy> ndm: not trolling (although it may sound like it), what do you like about scons?
16:00:48 <lispy> ndm: i've heard it's slow and awkward
16:00:59 <ndm> lispy: nothing, its slow and awkward
16:01:06 <lispy> :(
16:01:12 <ndm> well not particularly slow, but definately awkward
16:01:24 <ndm> i have heard good things about cmake, i want to give that a try at some point
16:01:37 <lispy> what about cabal?
16:02:01 <ndm> slow, awkward, broken :)
16:02:14 <Botty> cmake is alright for c/c++.  Dunno about haskell
16:02:33 <lispy> ndm: hey now, i love cabal :)
16:02:39 <ndm> doesn't do dependancy analysis, totally underpowered for building a compiler, even too underpowered to build the base libraries
16:02:45 <lispy> ndm: (but i know it's also immature)
16:02:49 <ndm> lispy: i love the concept, but its not there yet
16:03:13 <ndm> lispy: any idea what should be used to build Yhc? (really, if you have any good ideas i'd be interested)
16:03:31 <Igloo> ndm: Hmm? Cabal can build the libraries for hugs, and I have  patches for it to build them for GHC too
16:03:40 <sjanssen> perhaps a fast, natural, and working version of Cabal?
16:03:41 <ndm> we have a python guy who does the scons stuff, and its now pretty reliable and powerful, but it was painful to get to that stage
16:03:48 <lispy> ndm: i get really sick of autotools/make, but really that seems to be the most mature and available :(
16:04:14 <ndm> Igloo: does it? ok, thats good news - i thought there was some make file hackery on top of cabal
16:04:35 <ndm> lispy: not cross platform...
16:04:45 <Igloo> Only in as much as you need something to build the Setup.hs files and run it in each directory
16:04:53 <lispy> Igloo: i'd like to see darcs support building with cabal but when i tried it I found that you needed a different cabal file for every platform
16:04:57 <Igloo> And you can runhaskell instead of the former
16:05:19 <Igloo> lispy: If you use the default hooks then it will run configure
16:05:47 <lispy> Igloo: i haven't read that chapter of the cabal manual yet, so i was afraid to try it
16:06:08 <lispy> Igloo: plus, i wanted to get rid of configure :)
16:07:36 <lispy> ndm: maybe we need the docbook equivalent of make
16:07:50 <ndm> lispy: docbook equivlaent?
16:07:55 <ndm> (docbook sucks!)
16:08:01 <lispy> one format which you then "compile" down to some other build system
16:08:03 <Igloo> You probably can't get rid of it completely, but it should probably all end up being split off into packages darcs uses
16:08:14 <dons> dan2: on the C side you doing something like: #include "GHc-generated-header.h" ; hs_init() ; haskellfunction() ; hs_exit();
16:08:23 <ndm> lispy: I believe cmake has that intention
16:08:29 <dons> dan2: check the foreign function interface report
16:08:31 <dan2> dons: wow, that is easy
16:08:31 <dons> on haskell.org
16:08:49 <arjanoosting> Igloo: should --split-objs work on all architectures?
16:09:07 <Igloo> arjanoosting: No
16:09:29 <Igloo> arjanoosting: I'm not sure if more than x86/amd64 will work, but those 2 certainly should
16:09:36 <dons> dan2: here, for example:
16:09:37 <dons> #include "EvalHaskell.h"
16:09:37 <dons> int main(int argc, char *argv[])
16:09:37 <dons> {
16:09:37 <dons>   int *p;
16:09:40 <dons>   hs_init(&argc, &argv);
16:09:42 <dons>   p = fibs(20);
16:09:44 <dons>   if (p == NULL) printf("failed!\n"); else printf("%d\n",*p);
16:09:47 <dons>   hs_exit();
16:09:49 <dons>   return 0;
16:09:55 <dons> so of course you can start up and shutdown haskell, and run lots of things in between
16:09:55 <dan2> wow
16:10:04 <dons> here we just run fibs(), a haskell foreign export
16:10:18 <arjanoosting> Igloo: so for now I should only use it on x86 and amd64?
16:10:26 <Igloo> arjanoosting: Yup
16:10:34 <arjanoosting> Igloo: thanks
16:10:53 <Igloo> np
16:12:57 <dons> cool Bulat's installing linux
16:13:07 <ndm> nooooooooooooooooooooooooooooo!
16:16:30 <sjanssen> ha, everybody in the channel is happy/doesn't care . . . except for ndm ;)
16:17:09 <ndm> sjanssen: we are loosing one of the few windows haskell people, everyone should care - once you loose me, Bulat, Esa - then no one will ever get to use Haskell without first installing Linux
16:17:32 <dons> yes, more windows people are needed. many more
16:17:43 <lennart> ndm: unfortunatly I have to agree.  we need more windows users
16:18:02 <sjanssen> ndm: this is a good point.  I imagine that Bulat isn't ditching Windows entirely
16:18:05 <ndm> lennart: i suspect we have plenty of windows users, just very few core developers
16:18:05 <dons> more windows devs, anyway.
16:18:09 <lennart> i'm one of the people forced to used windows :(
16:18:25 <ndm> i would guess windows + hugs is the way a large chunk of students learn haskell
16:18:33 <sjanssen> ndm: recommend that Bulat tries "Linux From Scratch", he'll be back to Windows in a few days . . .
16:18:47 <ndm> i am one of the few windows people in our department
16:18:57 <ndm> which makes me massively more productive, and generally happier :)
16:19:14 <Igloo> Is that what they get up there, ndm?
16:19:27 <Igloo> It's Solaris/hugs down here, or at least it was when I was an UG
16:19:46 <ndm> Igloo: its Linux on the undergrad machines, but i try and persuade them to boot windows
16:20:04 * johnnowak blinks
16:20:06 <ndm> and unsurprisingly, the ones who boot windows woop the ones who stick to the recommeneded linux
16:20:13 <ndm> less time configuring their editor, more time coding
16:20:35 <ndm> (esp for Ada, which has an autocomplete GUI under windows, vs the recommended emacs where none can even save a file)
16:20:37 <dons> more time installing virus handling and patches, though.. ;)
16:21:04 <ndm> patches are automatic on shutdown - i spend less time doing that than anyone running Linux
16:21:19 <ndm> as long as you don't browse for porn using IE you are fine from viruses
16:21:54 <Philippa_> only currently true
16:22:05 <CosmicRay> ndm: you obviously odn't know people running debian ;-)
16:22:11 <Philippa_> pre-SP2, if you weren't behind NAT or otherwise doing something about security you'd get owned in seconds
16:22:40 <johnnowak> what do most people working with haskell on OS X use?
16:22:47 <Philippa_> warez is risky too, even if you're only looking for a crack for something you own
16:22:47 <ndm> Philippa_: most broadband routers end up behind a NAT by default nowadays - but yes, a Win98 machine is fun :)
16:23:02 <sjanssen> johnnowak: for an editor?  I use Vim
16:23:02 <Philippa_> yes, but not everyone's behind a router
16:23:21 <johnnowak> sjanssen: same here -- just working about a haskell-enabled ide of sorts
16:23:22 <ndm> most student households are, which is my general field of experience
16:23:34 <Philippa_> *nod*
16:23:40 <Philippa_> plenty of student machines full of spyware, though
16:23:47 <johnnowak> sjanssen: wondering rather
16:24:01 <ndm> yes, and i know exactly how they got the spyware (see about 13 lines back)
16:24:10 <Philippa_> doesn't have to be porn
16:24:14 <Philippa_> doesn't have to involve IE
16:24:30 <ndm> in my experience it almost always was
16:24:46 <Philippa_> *nod* - so you know lots of wankers, big surprise :-)
16:25:10 <ndm> good friends, lonely people :)
16:26:50 <dons> ?users
16:26:50 <lambdabot> Maximum users seen in #haskell: 265, currently: 234 (88.3%), active: 37 (15.8%)
16:29:39 <dons> urgh, http://www.coconut-palm-software.com/the_visual_editor/?p=88
16:29:43 <lambdabot> http://tinyurl.com/yn7l5n
16:29:55 <dons> System.out.println(((Long)0L).equals(0)); -> False
16:30:01 <dons> silly Java.
16:31:22 <dylan> ?lusers
16:31:23 <lambdabot> Maximum users seen in #haskell: 265, currently: 235 (88.7%), active: 36 (15.3%)
16:31:24 <Pseudonym> Could be worse.
16:31:27 <dylan> heh
16:31:31 <Pseudonym> In Haskell, the equivalent would be a type error.
16:31:52 <astrolabe> surely that is much better
16:31:58 <Igloo> For a brilliant "silly C#", see http://lambdaman.blogspot.com/2006/10/things-that-dont-suck-and-things-that.html
16:32:01 <lambdabot> Title: One for the Morning Glory: Things that Don't Suck and Things that Do, http://tinyurl.com/y8osxj
16:32:05 <dons> yeah, that's the problem. it should be caught
16:32:12 <sjanssen> I'm guessing the 0 autoboxes to an Int (or whatever it's called), and that case isn't handled in the .equals() method
16:32:17 <Igloo> (about half way down)
16:33:00 <Pseudonym> Oh, $DEITY.
16:33:02 <Pseudonym> That C# thing.
16:33:12 <Pseudonym> So... sorting breaks?
16:34:28 <Igloo> Well, sorting is impossible, given the obvious postcondition
16:34:34 <dons> did everyone catch the codo/comonad blog article by sigfpe
16:34:40 <Pseudonym> You could topologically sort!
16:34:44 <dons> best comonad writeup .. ever.
16:34:46 <Pseudonym> And collect cliques.
16:34:55 <Pseudonym> dons: Link?
16:34:55 <merus> dons: where?  I <3 sigfpe
16:35:13 <dons> http://sigfpe.blogspot.com/2006/06/monads-kleisli-arrows-comonads-and.html
16:35:16 <lambdabot> Title: A Neighborhood of Infinity: Monads, Kleisli Arrows, Comonads and other Rambling  ..., http://tinyurl.com/jhldt
16:35:32 <dons> including, http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.html
16:35:36 <lambdabot> http://tinyurl.com/y6zbwc
16:39:01 <dons> makes me want -package comonad in the extralibs
16:39:39 <dons> btw, while people are still here, does anyone have any comments on this patch I'm going to propose:
16:39:43 <dons> infixr 1 <=<, >=>
16:39:45 <dons> -- | Left-to-right Kleisli composition of monads.
16:39:48 <dons> (>=>)       :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
16:39:50 <dons> f >=> g     = \x -> f x >>= g
16:39:53 <dons> -- | Right-to-left Kleisli composition of monads. '(>=>)', with the arguments flipped
16:39:56 <dons> (<=<)       :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
16:39:58 <dons> (<=<)       = flip (>=>)
16:40:01 <dons> -- | @'forever' act@ repeats the action infinitely.
16:40:03 <dons> forever     :: (Monad m) => m a -> m ()
16:40:06 <dons> forever a   = a >> forever a
16:40:08 <dons> to Control.Monad
16:40:52 <sjanssen> dons: forever is a very nice addition
16:41:05 <Pseudonym> >=> is >>>, right?
16:41:33 <Pseudonym> Only without the Kleisli wrapper.
16:41:37 <dons> yep
16:41:54 <dan2> dons: what if you import a C call that uses a structure as it's parameter?
16:41:54 <dons> which is traditionally @@ , but we also want to add the flipped version
16:42:13 <dons> structs are handled by using Storabe to marshal the data
16:42:18 <dons> dan2, you have the FFI spec?
16:42:19 <Pseudonym> Well, my comment is: I don't like it, but I don't see a good alternative.
16:42:23 <dan2> no...?
16:42:33 <Pseudonym> That's THREE operators for the same thing.
16:42:40 <dons> Pseudonym: so I don't think we can use >>> and <<<
16:42:43 <dons> can we?
16:42:50 * Pseudonym thinks about that
16:42:57 <dons> and @@ is out, since there's no obvious flip
16:42:57 <Pseudonym> Probably not.
16:43:14 <dons> other suggestoins were =>>= which I find too verbose
16:43:34 <dons> dan2: http://www.cse.unsw.edu.au/~chak/haskell/ffi/
16:43:34 <lambdabot> Title: The Haskell 98 Foreign Function Interface 1.0
16:43:54 <Pseudonym> The other problem with that is that you have a whole bunch of operators that look similar but there's no rhyme or reason to them.
16:44:02 <dons> I wonder if there's any operator traditionally used in category theory for this that we can steal?
16:44:17 <Pseudonym> The real issue here, IMO, is that maybe Haskell shouldn't support monads.
16:44:23 <Pseudonym> Just support arrows.
16:44:27 <dons> oh, ok. that's a different issue.
16:44:29 <astrolabe> How about something with '.' in it, since the operator is a bit like '.'
16:44:31 <Pseudonym> Yeah.
16:44:33 <dons> or comonads, if you read sigfpe ;)
16:44:38 <Pseudonym> That way you don't have operator duplication.
16:44:42 <dons> yeah, so i thought about:  >.>
16:44:44 <dons> and <.<
16:44:50 <Pseudonym> Ideally, you'd like >>> to work with arrows, monads and comonads.
16:45:02 <Pseudonym> Can you do that?
16:45:02 <dons> which is nice, though >.> = flip (.) in hudak's book
16:45:14 <dons> mmm.
16:45:15 * Pseudonym thinks
16:45:17 <sjanssen> @pl \x -> f x >>= g
16:45:18 <lambdabot> (g =<<) . f
16:45:20 <dons> maybe we could export >>> from Control.Monad
16:45:34 <dons> (seems unliekly we'd import both Arrow and Monad ?)
16:45:36 <Pseudonym> You might be able to do it with ATs.
16:45:38 <dons> hmm. no.
16:45:46 <Pseudonym> Or something.
16:46:10 <dcoutts> dolio, I like it. Yes =>= is better than =>>=
16:46:13 <dcoutts> and the reverse
16:46:21 <dcoutts> oops I meant dons ^^
16:46:33 <dons> =>= or >=> ?
16:46:38 <dcoutts> erms
16:46:39 <dcoutts> oops
16:46:46 <dcoutts> whichever you proposed :-)
16:46:49 <dons> :)
16:47:03 <mattrepl> this is a little late, but in reference to sigfpe's comonad post, how about putting http://programming.reddit.com/info/ox6s/comments/coxiv and http://programming.reddit.com/info/ox6s/comments/coxoh on the wiki?  Both were excellent posts on monads with information not in other monad introductions
16:47:09 <lambdabot> Title: Ask Reddit: What the hell are monads? (reddit.com), http://tinyurl.com/y23zcc
16:47:14 <dons> mattrepl: hmm. good idea.
16:48:05 <fabiim> if foo returns a maybe a , and i want so use a in foo2 , how should i do that?
16:49:34 <dons> > let foo = Just 7 in case foo of Nothing -> 0 ; Just x -> x
16:49:35 <lambdabot>  7
16:50:07 <sjanssen> perhaps these comments can be merged into a "monads as computation" article?
16:50:17 <sjanssen> to complement the "monads as containers" article
16:50:46 <dobblego> ?type fromJust
16:50:47 <lambdabot> forall a. Maybe a -> a
16:51:16 <dons> mattrepl: thanks for sorting out those links. i'll stick them on the wiki
16:51:35 <fabiim> dons , did not  get it
16:52:23 <dons> you use pattern matching to extract the part you need
16:52:33 <dons> > case Just 7 of Just x -> x ; Nothing -> 0
16:52:34 <lambdabot>  7
16:52:49 <dons> > case Nothing of Just x -> x ; Nothing -> 0
16:52:51 <lambdabot>  0
16:53:39 <fabiim> ahh! great . thanks =)
16:55:15 <mattrepl> dons: sure thing, thanks for posting it in the first place.  both those posts were the first I had seen of, as sjanssen said, "monads as computation"
16:55:35 <dons> yeah, seems we have really lacked a good explanation of this kind of thing
16:55:41 <dons> too many people think monad == IO hack
16:55:57 <dobblego> speaking of things on the wiki, I wish there were decent explanations/examples of memoising
16:55:57 <dons> I added the links here http://haskell.org/haskellwiki/Monad#Monad_Tutorials
16:56:00 <lambdabot> Title: Monad - HaskellWiki, http://tinyurl.com/y2fdhw
16:56:06 <dons> and here http://haskell.org/haskellwiki/Books_and_tutorials#Using_monads
16:56:09 <lambdabot> Title: Books and tutorials - HaskellWiki, http://tinyurl.com/vqzky
16:57:16 <Adamant> what innovative monads does Haskell have?
16:57:38 <Adamant> basically, stuff no other language really has yet
16:58:07 <sjanssen> Adamant: the parser monad in Parsec is pretty compelling
16:58:25 <dons> Adamant: STM is pretty fine. (atomic memory transactions)
16:58:27 <Adamant> I liked the comparison with other languages, like Lisp
16:58:36 <dons> http://haskell.org/haskellwiki/Monad#Interesting_monads
16:58:39 <lambdabot> Title: Monad - HaskellWiki, http://tinyurl.com/y2fdhw
16:58:45 <sjanssen> ah, I always forget STM
16:59:06 <dons> the monadic region allocation semantics is very nice too
16:59:20 <dons> also, continuations as a monad is a great relief :)
16:59:26 <Adamant> what are the new monads for massive parallelism?
16:59:31 <sjanssen> and STM is one of the best advertisements for Haskell that I've ever seen
16:59:55 <dons> yeah. STM + the SMP rts I think will be very important in the next few years..
17:00:03 <dylan> and forkIO's ease of use
17:00:12 <dons> yeah.
17:00:22 <sjanssen> Adamant: STM is a monad that solves the concurrent shared state problem in a novel way
17:03:17 <dons> interesting "The point is that when you try a new technique it'll often make you worse, at least initially. You have to work with something unfamiliar, perhaps also unlearn something else that gets in the way. During that period you performance has dipped. Only with perseverance can you get through this and reach a higher plateau."
17:03:26 <dons> http://martinfowler.com/bliki/ImprovementRavine.html
17:03:30 <lambdabot> Title: MF Bliki: ImprovementRavine, http://tinyurl.com/yb77z4
17:04:08 <dylan> hmm, that hasn't happened to me. Every new and differnet programming-thing gets almost instant better results.
17:05:34 <dons> I'm thinking it applies to some heavily imperative people who try out functional programming
17:05:43 <dylan> Ah.
17:05:46 <dons> the guys who start by asking how to do mutable global variables :)
17:06:02 <dons> and then fall into the ravine :)
17:06:29 <dylan> I was writing things like this in perl: $finder = finder(  filename('svn') => remove_file(), qr/ )
17:06:40 <dons> ah, nice comment: "This sounds a bit like Paul Graham's Blub Paradox. Except if you're a Blub programmer you don't realize there are higher plateaus to be reached."
17:07:05 <dylan> err, whatever. where filename() returns a predicate function, and remove_file() returns something that would be of type IO in haskell. ;)
17:07:18 <dons> heh
17:07:19 <dobblego> I'll bet people who spend their lives studying Sociology can predict these kind of comments
17:08:49 <dylan> I remember being introduced to lambdas (in perl) from the programming perl, 2nd edition book. I used them heavily ever since...
17:08:58 <dylan> like some kind of cocaine addiction.
17:08:59 <dons> oh, that's nice.
17:09:01 <dons> heh
17:09:39 <dons> you need to apply lambdas at least 5 times a day to feel normal?
17:09:47 <dons> I find over time i need more and more.
17:10:00 <dylan> the classic example being mktag('p'); p($text) # outputs "<p>$text</p>"
17:10:04 <dons> though, sometimes I get the same effect by using (.) pointfree instead
17:10:16 <Botty> the ravine thing can be likened to finding better local maxima, by moving down in value
17:10:35 <dons> Botty: yeah. a simulated annealing on the productivity space
17:10:37 <dylan> haskell is actually far easier to explain to non-programmers than perl is.
17:10:55 <dons> agreed. hence scheme and haskell are used for non-programmer courses
17:11:13 <dons> though haskell is heading away from beginners and more towards the professional programmers, I think
17:11:18 <dylan> it's so cool! I actually get to write in a scheme-like lisp dialect!
17:11:28 <dobblego> I have said it before; my 5 year old is learning haskell
17:11:32 <dylan> for work!
17:12:04 <dons> dobblego: so cool!
17:12:11 <dylan> it's 1-lisp... has dynamic scope, though
17:12:29 <dobblego> dons, he thinks it is anyway :) he doesn't know he is learning haskell of course - but he understands basic algebra using ghci
17:12:37 <dons> heh . cool.
17:12:50 <dons> i've had my mum solve a couple of math problems in ghci
17:13:02 <dylan> haskell needs some turtle graphics functions
17:13:10 <dobblego> he has figured out gaim, so he messages me, "what are you doing?" and I respond, "Programming - if you want to as well, you need to keep playing ghci"
17:13:31 <sjanssen> "playing ghci", nice!
17:13:50 <dylan> My fiancee's 3 year old keeps asking to play 'the typing game'
17:13:56 <dylan> which essentially using vim, so...
17:14:11 <dylan> hopefully I'll have him using haskell in 2 years. ;)
17:14:40 <dobblego> he finds basic mathematics fun, so to him, it is a game
17:15:00 <dons> my supervisor's child was using irc at hmm, 6 months
17:15:06 <dons> he liked to type :)
17:15:06 <dobblego> by the way, edubuntu rocks for kids
17:15:08 <dylan> LOL.
17:16:21 <dobblego> I can give him something like 87 = x + 43, what is x? and he will figure it out and check with ghci
17:16:46 <dobblego> that's more than what most of my ex-IBM colleagues could achieve in terms of computer programming
17:16:47 <dylan> dobblego> something else he might find fun is yacas.
17:16:49 <ndm> dobblego: thats scary for a 5 year old
17:16:55 <dons> dobblego: heh
17:17:05 <dobblego> dylan, never heard of it - I'll take a look
17:17:35 <dylan> yacas would be easy to implement in haskell, of course.
17:18:00 <dobblego> edubuntu comes with all sorts of cool applications for kids
17:18:19 <dylan> in yacas you can type 2 + x + 30 and it'll print x+32
17:18:46 <dobblego> ah nice
17:18:47 <dylan> it can also solve equations, including quadradic ones. (it gives both answers)
17:18:54 <dobblego> I'll put it on for him
17:19:04 * dobblego ssh home
17:19:14 <dobblego> gah, his machine is off
17:20:40 <vincenz> dobblego: congrats :)
17:20:54 <vincenz> dobblego: I think it's a noble pursuit to teach your kids stuff like that at a young age
17:20:54 <dobblego> vincenz, what I did?
17:20:59 <dobblego> ah right, thanks
17:21:17 <dobblego> "what I did?" -- that's my 3 year old coming out in me
17:21:31 <vincenz> hehe, haskell comments :P
17:21:32 <vincenz> --
17:21:36 <dobblego> yeah that too
17:21:42 <dobblego> know what a horsegropper is?
17:21:51 <vincenz> that's not your 3 year old, it's your 5 yar old
17:21:54 <dons> mm. nice. http://programming.reddit.com/info/qmtc/details
17:21:55 <vincenz> npoe
17:21:58 <lambdabot> Title: Monads, a Field Guide (reddit.com), http://tinyurl.com/srbex
17:22:10 <dobblego> a horsegropper is a type synonym for grasshopper in 3 year old
17:22:11 <vincenz> s/npoe/nope
17:22:14 <dobblego> I have a 3 year old as well
17:22:24 <dons> dobblego: that's a good one :)
17:22:31 <vincenz> dobblego: oh I know, I was referring ot the haskell comments, as your 5 year old is learning haskell :)
17:22:48 <dobblego> my 3 year old is getting a edubuntu/PC for christmas :)
17:23:00 <dobblego> stop the fights
17:23:12 <vincenz> I didn't know about edubuntu, thanks for the tip ;)
17:23:43 <vincenz> dons: those drawings are messed up
17:23:54 <vincenz> dons: I like the comment tho
17:24:04 <vincenz> "...I only saw each of them for a fleeting moment..."
17:24:16 <vincenz> (just like nirvana :D)
17:25:48 * dcoutts is glad to have ndm in the Gtk2Hs marketing department :-)
17:26:12 <vincenz> dcoutts: how's that?
17:26:14 <ndm> i basically wrote "use Gtk2Hs because of dcoutts" - which is a reasonable argument to make
17:26:19 <dcoutts> heh :-)
17:26:33 <dcoutts> ndm, you'll also be glad to know I have restored my access to a win2k3 box
17:26:46 <vincenz> dcoutts: I think the people are screaming vista :P
17:26:46 <dcoutts> so I'll be able to improve the 0.9.11 instaler
17:26:49 <ndm> good good :)
17:28:09 <mattrepl> are there any active haskell projects for distributed computation?  nothing fancy, just a simple architecture like MapReduce
17:28:21 <dons> yeah, DPH.
17:28:46 <dons> as well as just your everyday GHC with SMP support
17:28:59 <dons> but you want cluster support?
17:29:10 <ndm> Yhc has something like that being worked on
17:29:40 <dcoutts> you could do MapReduce without any compiler support
17:29:40 <mattrepl> yeah, I was thinking that GHC with SMP can be used to make use of multiple processors at any node
17:29:48 <dons> so for smp machines, http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell, for clusters and mobile computing, see the research pages, http://haskell.org/haskellwiki/Research_papers/Parallelism_and_concurrency
17:29:51 <lambdabot> Title: GHC/Data Parallel Haskell - HaskellWiki, http://tinyurl.com/y77oeb
17:30:03 <dons> also http://haskell.org/haskellwiki/Libraries_and_tools/Concurrency_and_parallelism
17:30:05 <lambdabot> Title: Libraries and tools/Concurrency and parallelism - HaskellWiki, http://tinyurl.com/wvlsw
17:30:49 <mattrepl> thanks
17:32:25 <guerra> can i call a function inside the conditions in another function definition? in the |
17:32:45 <dons> yeah
17:33:06 <guerra> thanks
17:33:14 <dons> > let f x y | x `elem` y = 1 | otherwise = 0 in f 'x' "haskexl"
17:33:16 <lambdabot>  1
17:33:39 <vincenz> dons dons dons
17:33:51 <dons> yes?
17:34:15 <ndm> > cycle "dons "
17:34:17 <lambdabot>  "dons dons dons dons dons dons dons dons dons dons dons dons dons dons dons ...
17:34:20 <vincenz> > let f x y -> fromEnum $ x `elem` y  in f 'x' "haskellx"
17:34:20 <lambdabot>  Parse error
17:34:27 <vincenz> > let f x y = fromEnum $ x `elem` y in f 'x' "haskellx"
17:34:29 <lambdabot>  1
17:34:31 <dons> of course.
17:34:33 <vincenz> :D
17:34:39 <vincenz> @pl f x y = fromEnum $ x `elem` y
17:34:40 <lambdabot> f = (fromEnum .) . elem
17:34:46 <dons> oh, that's dot too!
17:34:59 <dons> ?type let dot = (.) . (.) in fromEnum `dot` elem
17:35:00 <lambdabot> forall a. (Eq a) => a -> [a] -> Int
17:35:11 <sjanssen> @type (.) . (.)
17:35:13 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
17:35:31 <vincenz> dot, you mean boobs
17:35:33 * dons is almost ready to campaign for (.).(.) to go into Data.Function
17:35:43 <dons> along with (.)$(.)
17:35:50 <vincenz> dons: strippes with cash?
17:35:52 <vincenz> +r
17:36:00 <sjanssen> dons: I think you need a better name than "dot"
17:36:04 <dons> yes.
17:36:09 <dons> that's the only thing holding me back
17:36:09 <ndm> boobs ;) ?
17:36:18 <dons> since we want: (.), dot2, dot3 , ...
17:36:30 <sjanssen> @type (.)$(.)
17:36:31 <vincenz> @type (.)$(.)
17:36:31 <lambdabot> forall a b c a1. (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
17:36:33 <lambdabot> forall a b c a1. (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
17:36:39 <dons> ?pl \f g x y -> f ( g x y )
17:36:40 <lambdabot> (.) . (.)
17:36:46 <vincenz> never seen the use for (.)$(.)
17:37:16 <jcreigh> if I ask what (.) . (.) is good for, am I going to regret it?
17:37:24 <sjanssen> @. pl djinn (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
17:37:25 <lambdabot> f = ((.) .)
17:37:27 <dons> (fromEnum .) . elem  -> fromEnum `dot` elem
17:37:45 <dons> i.e. soaking up n args pointfree style
17:37:47 <sjanssen> jcreigh: it's composition where the second function takes two arguments
17:37:53 <ndm> concat `dot` map == concatMap ?
17:37:56 <dons> without hard-on-the-brain (f .) . 's
17:38:12 <dons> ?type concatMap
17:38:13 <lambdabot> forall b a. (a -> [b]) -> [a] -> [b]
17:38:23 <dons> ?type let dot = (.) . (.) in concat `dot` map
17:38:24 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
17:38:31 <sjanssen> a verbose name for dot is "compose2"
17:38:32 <dons> mm.
17:38:41 <dons> ap2 ap3 ..?
17:38:47 <ndm> i remember seeing that before, in a Haskell L-Systems paper
17:39:06 <ndm> it was like point-free for fun, and to find abstractions
17:39:24 <sjanssen> @pl \f g x y z -> f $ g x y z
17:39:25 <lambdabot> (.) . (.) . (.)
17:39:38 <dons> yeah, I suspect the various pointfree libs around might have a name for it already
17:39:47 <dons> in bananas and lenses maybe?
17:39:54 <ndm> dons: did you see my wiki post on the safe library?
17:40:03 <dons> yes!
17:40:30 <dons> ndm, btw, http://programming.reddit.com/info/qaxl/comments :)
17:40:32 <lambdabot> Title: "Without QuickCheck I don&#39;t think it would have been possible to write the l ..., http://tinyurl.com/tyn6l
17:40:33 <ndm> it would be a beautiful project for someone begining Haskell
17:40:42 <guerra> i defined exclusiveOr as an Int and one of my conditions is |x < (exclusiveOr xor x) where x is an interger. ghc says i applied exclusiveOr to too many args. Any ideas?
17:40:46 <dons> http://www.cse.unsw.edu.au/~dons/Pointless/Combinators.hs
17:40:48 <lambdabot> http://tinyurl.com/y2dqt9
17:41:20 <ndm> oh, cool - scary that hoogle has 3 points, but a random blog post has 24...
17:41:26 <dolio> Is there no Oleg type hackery that overloads (.) for composition of functions of arbitrary arity? :)
17:41:30 <dolio> We should just use that.
17:41:45 <dons> more here, http://www.cse.unsw.edu.au/~dons/Pointless/
17:41:45 <lambdabot> Title: Index of /~dons/Pointless
17:41:57 <heatsink> guerra, you are calling exclusiveOr with two arguments: xor and x
17:41:58 <dons> ndm, its all in having a provocative title, I find
17:42:15 <guerra> but exclusiveOr is a variable and xor is the function here
17:42:19 <jcreigh> maybe compose2, compose3, etc.
17:42:40 <dons> i.e. you don't put 'hoogle' in the title, you put "Searching libraries with type queries", or something
17:43:01 <dobblego> > let drop' n _ | n < 0 = Nothing; drop' 0 xs = Just xs; drop' _ [] = Nothing; drop' n (_:xs) = drop' (n - 1) xs in drop' 3 [1,2,3]
17:43:02 <lambdabot>  Just []
17:43:15 * desrt lands, showers
17:43:19 <ndm> dons: someone else added it ages ago
17:43:24 <dons> yeah
17:43:28 <heatsink> guerra: there is a syntax to use functions like infix operators, put the name in backquotes ``.  Otherwise, it always parses function calls the same way.
17:43:54 <guerra> heatsink: u mean teh function name?
17:44:00 <heatsink> yea
17:44:04 <dons> > let f = id in (+) `f` (2 `f` 3)
17:44:05 <lambdabot>  add an instance declaration for (Num (t -> a))
17:44:11 <heatsink> (x y z) call x with arguments y, z
17:44:16 <dons> > let f = id in (+) `f` 2 3
17:44:17 <lambdabot>  add an instance declaration for (Num (t -> a))
17:44:22 <heatsink> (x `y` z) call y with arguments x, z
17:44:31 <dons> stupid precedence ;)
17:44:39 <dons> > let f = id in ((+) `f` 2) 3
17:44:40 <lambdabot>  5
17:44:55 <guerra> ooooh got it
17:45:13 <dons> > (^2) `map` [1..]
17:45:13 <jcreigh> and (op) to call an infix function normally.
17:45:15 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
17:45:17 <jcreigh> > (+) 2 2
17:45:19 <lambdabot>  4
17:45:39 <vincenz> > (join (*)) `map` [1..]
17:45:41 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
17:45:50 <dons> :)
17:46:09 <dobblego> :t join
17:46:09 <vincenz> > 100000000000 ^
17:46:10 <lambdabot>  Parse error
17:46:11 <vincenz> > 100000000000 ^2
17:46:12 <dobblego> ?type join
17:46:13 <lambdabot>  10000000000000000000000
17:46:14 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
17:46:45 <jcreigh> is join \f x -> f x x
17:46:52 <vincenz> for functions yes
17:46:55 <vincenz> the monad is the reader monad
17:47:04 <vincenz> (a ->)
17:48:02 <heatsink> let a m n = if m == 0 then n+1 else a (m-1) $ if n == 0 then 1 else a m $ n-1 in a 4 1
17:48:04 <heatsink> > let a m n = if m == 0 then n+1 else a (m-1) $ if n == 0 then 1 else a m $ n-1 in a 4 1
17:48:09 <lambdabot> Terminated
17:48:16 <heatsink> > let a m n = if m == 0 then n+1 else a (m-1) $ if n == 0 then 1 else a m $ n-1 in a 3 3
17:48:18 <lambdabot>  61
17:48:48 <dons> > runReader 7 $ do x <- ask ; id x
17:48:49 <lambdabot>  add an instance declaration for (MonadReader (m b) m)
17:48:49 <lambdabot>   In a 'do' express...
17:48:58 <dons> > runReader 7 $ do x <- ask ; return x
17:48:59 <lambdabot>  add an instance declaration for (Num (Reader (m r) a))
17:49:08 <vincenz> > runReader 7 $ do { x <- ask; return x}
17:49:09 <lambdabot>  add an instance declaration for (Num (Reader (m r) a))
17:49:29 <vincenz> > runReader (const 7) $ do { x <- ask; return x}
17:49:30 <lambdabot>    Expecting a function type, but found `Reader r a'
17:49:30 <lambdabot>    Expected type: R...
17:49:34 <dons> I don't think i've ever seen explicit Reader do notation for (-> a)
17:50:14 <vincenz> oh!
17:50:19 <dons> > runReader (do x <- ask ; return x) 7
17:50:20 <lambdabot>  7
17:50:21 <vincenz> > runReader ( do { x <- ask; return x}) 7
17:50:22 <vincenz> exactly
17:50:23 <lambdabot>  7
17:50:25 <dons> always get it around the wrong way!
17:50:31 <dons> they really should be flipped
17:50:34 * vincenz beeps dons for similar timing
17:50:59 <dons> > runReader (do x <- asks id ; id x) 7
17:51:00 <lambdabot>    Occurs check: cannot construct the infinite type: r = Reader r a
17:51:00 <lambdabot>    E...
17:51:02 <guerra> heatsink: but when i do that with black quotes it says there is a string literal lexical error :P
17:51:15 <dons> > runReader (do x <- id =<< ask ; return x) 7
17:51:16 <lambdabot>    Occurs check: cannot construct the infinite type: r = Reader r b
17:51:16 <lambdabot>    E...
17:51:38 <heatsink> guerra: Maybe you are using single quotes?
17:51:50 <heatsink> Single quote ' ' ' ' backquote ` ` ` `
17:52:09 <guerra> heatsink: lemme see
17:52:29 <heatsink> guerra: On my keyboard, backquote is the same key as tilde
17:53:11 <vincenz> most qwerty's
17:53:35 <guerra> heatsink:  mine is abnt2 and i make confusion with that
17:53:44 <Adamant> > cycle 'spam'
17:53:45 <lambdabot>  Improperly terminated character constant
17:53:55 <vincenz> > cycle "spam"
17:53:56 <lambdabot>  "spamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspamspa...
17:54:09 <vincenz> @type cycle
17:54:12 <lambdabot> forall a. [a] -> [a]
17:54:24 <guerra> heatsink: is this right? x < (exclusiveOr `xor` x)
17:54:31 <heatsink> yes
17:55:27 <guerra> heatsink: ok, just worked, many thanks ^^
17:55:52 <heatsink> what is abnt2?
17:56:28 <int-e> > concat . cycle . tranpose $ ["l ","os","vp","ea","lm","y "]
17:56:28 <lambdabot>  Not in scope: `tranpose'
17:56:34 <int-e> > concat . cycle . transpose $ ["l ","os","vp","ea","lm","y "]
17:56:36 <lambdabot>  "lovely spam lovely spam lovely spam lovely spam lovely spam lovely spam lov...
17:57:42 <vincenz> > concat . cycle . transpose $ ["i  k", "nif!", "tsr!", "- e!", "eaa "]
17:57:44 <lambdabot>  "int-e is a freak!!! int-e is a freak!!! int-e is a freak!!! int-e is a frea...
17:58:06 <guerra> heatsink: its a keyboard layout we use for portuguese language
17:58:27 <heatsink> ah, ok.
17:58:27 <guerra> heatsink: so u can make thngs like ç éàãâ
18:02:04 <int-e> > cycle . concat $ [[]]
18:02:06 <lambdabot>  Add a type signature
18:02:23 <heatsink> > ord 'ç'
18:02:24 <lambdabot>  Improperly terminated character constant
18:02:29 <heatsink> > ord 'c'
18:02:31 <lambdabot>  99
18:02:35 <heatsink> > ord 'ç'
18:02:35 <lambdabot>  Improperly terminated character constant
18:02:36 <int-e> > concat . cycle $ [[]] :: [Int]
18:02:38 <heatsink> hmm.
18:02:40 <lambdabot> Terminated
18:03:06 <heatsink> I guess you can't use portugese variable names :)
18:05:11 <Smokey`> exams, uni, done, finished for the year... 3 month holiday yay!
18:12:05 <guerra> heatsink:  lol looks like not ^^
18:13:05 * dcoutts pushes a huge pile of gtk2hs code gen patches
18:14:43 * araujo wonders if it is worthy a gtk2hs recompilation
18:14:57 <dcoutts> araujo, no, because it's only the code generator
18:15:06 <dcoutts> so no actual code you use has changed yet
18:16:04 <edwardk> heatsink: you can, just not in lambdabot
18:16:10 <araujo> dcoutts, ok
18:17:28 <erider> hola araujo como te vaj?
18:17:52 <araujo> hola erider
18:18:10 <araujo> erider, bien , playing a bit with gtk2hs
18:18:21 <erider> cool!
18:18:34 <araujo> :-)
18:18:58 * erider is going to sleep long day manana 
18:21:25 <ralf`> any volunteers to help me figure out /msg in this new (to me) irc client?
18:21:39 <dan2> is there an implementation of newton polynomial (newton interpolation) in haskell?
18:22:29 <dons> ralf`: what client?
18:22:36 <ralf`> dan2: I've got some little haskell programs for multiplying and adding polynomials.
18:22:57 <ralf`> dan2: It shouldn't be too hard to write the piece you're looking for.
18:23:06 <dan2> hmm ok
18:23:48 <ralf`> dan2: But before I go re-inventing wheels, let's put our heads together and see what's out there for talking about polynomials in haskell.
18:24:04 <dan2> hmm ok
18:24:19 <ralf`> dons: did you hear me?  I just typed "/msg dons erc"
18:24:23 <dan2> I have close to zero haskell experience except that I've heard it's used by a lot of mathematicians and I have extensive amount of time working with Ocaml
18:24:27 <dons> yes :)
18:24:44 <vincenz> as a resident ocaml->haskell convert
18:24:51 <vincenz> I can assure you'll love haskell
18:24:53 <dons> http://haskell.org/haskellwiki/Haskell_and_mathematics
18:24:56 <lambdabot> Title: Haskell and mathematics - HaskellWiki, http://tinyurl.com/yerb92
18:25:00 <vincenz> But you'll have to learn to get ride of tail-call recursion
18:25:01 <ralf`> dons: Can you write me back something so I can see what erc does?
18:25:16 <dobblego> dan2, good to see you comin' round - welcome comrade :)
18:25:28 <dons> ralf`: i'm writing back... do you see anything?
18:25:33 <dons> is it possible you haven't identified?
18:25:37 <dan2> heh
18:25:56 <dan2> vincenz: hmm?
18:26:02 <dan2> vincenz: no tail calls?
18:26:11 <vincenz> tail call is bad in haskell
18:26:15 <vincenz> it's the opposite from ocaml
18:26:17 <vincenz> due to laziness
18:26:20 <dan2> so it's like C
18:26:22 <dan2> bad
18:26:23 <vincenz> no
18:26:26 <vincenz> I mean in the sense of
18:26:32 <vincenz> tail call is not the best way of doing things
18:26:37 <ralf`> dons: I don't see anything.  Yes.  It's possible that I didn't identify.
18:26:40 <vincenz> not in the sense of c
18:26:49 <ralf`> dons: What is it now?  /nickServ IDENTIFY?
18:27:07 <vincenz> I do believe that haskell tail-call optimizes, but the most common use case for tail call in ocaml is building up lists, in haskell, typically, due to laziness, tail-call is a BAD idea, cause you're forcing the entire list into memory
18:27:10 <dobblego> /msg NickServ IDENTIFY
18:27:42 <dons> ralf`: yep
18:27:46 <dons> with the password
18:29:41 <ralf`> dons: Yeah.  About the password.  I don't really use one.  I just leave that field blank during the interaction with erc-select.
18:30:05 <ralf`> dons: Now, of course, I'd _rather_ be using yi, but getting that working is on my list of a million things to do.
18:30:14 <dons> heh
18:30:31 <ralf`> dons: You were helping me work on that when I was at the San Jose hack-a-thon two weeks ago Remember?
18:30:44 <ralf`> can you chat in yi by the way?
18:31:18 <dan2> ralf`: I also have the option of using a mathematical kernel I think
18:32:09 <dan2> but I've only got maxima at my disposal
18:32:54 <dons> ralf`: nope.
18:35:03 <ralf`> dan2: What you're saying sounds like a good beginning project in haskell.
18:35:12 <ralf`> I'd just go ahead and write it.
18:37:35 <ralf`> dan2: You can check out http://haskell.org/haskellwiki/Add_Polynomials. Um... It's kind of thrown together.  You'll have to comment out the multiply function.
18:37:38 <lambdabot> Title: Add Polynomials - HaskellWiki, http://tinyurl.com/y27jsn
18:39:08 <ralf`> dan2: There is nothing impressive about that code.  It's just that we'll have to agree on a type if we want to share code about Polynomials.
18:40:38 <dan2> ralf`: so in a nutshell here's what I need to find.  Calculate the Newton or Lagrange Polynomial (guarantees all points specified are hit by curve).  Calculate the derivative and find the zeroes.  Recursively apply Polynomial on zeroes and find next set of zeroes.  Identify which points are zeroes in X amounts of the data sets
18:41:26 <ralf`> dan2: I was at this party where we decided that the type of a polynomial should be [(Int,Int)], where it's assumed that the pairs are (coefficient,exponent) and that they are sorted by exponent.  Another obvious choice is to have the exponent encoded as the place in the list.  So x^2 + 1 = [1,0,1].
18:41:59 <dan2> uhh, ok
18:42:52 <ralf`> dan2: I have to go now, but I wish you luck.  Please link any code that you write off of the url that I mentioned.k
18:43:37 <The_Ball> what is wrong with this code? http://pastebin.ca/247160
18:43:42 <heatsink> Is this for one-variable polynomials only?
18:44:53 <heatsink> The_Ball, which character is at line 11, column 12 in the original file?
18:44:57 <dolio> The_Ball: [x | xs] is a prolog style list.
18:45:01 <int-e> The_Ball: try (x:xs) instead of [x | xs]
18:45:33 <The_Ball> ah : im still in prolog mode :)
18:46:23 <int-e> @type any
18:46:25 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
18:46:48 <dolio> > any (True : repeat False)
18:46:49 <lambdabot>    Expecting a function type, but found `[a]'
18:46:49 <lambdabot>    Expected type: a -> Boo...
18:47:06 <dolio> > any id (True : repeat False)
18:47:08 <lambdabot>  True
18:47:39 <The_Ball> also, how do i load the char library so i can use isDigit() ?
18:47:47 <int-e> The_Ball: note that the [x] case isn't necessary.
18:47:52 <int-e> The_Ball: import Data.Char
18:47:55 <int-e> @index isDigit
18:47:56 <lambdabot> Data.Char
18:48:07 <The_Ball> int-e, no it's not, thanks for that
18:48:43 <dons> > map isDigit "123xdfds123"
18:48:45 <lambdabot>  [True,True,True,False,False,False,False,False,True,True,True]
18:49:17 <MP0> neat!
18:49:27 <MP0> map isDigit "123xdfds123"
18:49:41 <MP0> oh well
18:50:06 <MP0> oh!
18:50:17 <dcoutts> Igloo, I'm getting wierd behaviour from darcs, I'm wondering if it's possible that it could be to do with the version of darcs installed on darcs.haskell.org. I can push to a fresh local copy of the remote repo, but can't push to that same repo without getting conflicts.
18:50:24 <MP0> > map isDigit "123xdfds123"
18:50:25 <lambdabot>  [True,True,True,False,False,False,False,False,True,True,True]
18:50:28 <dons> :)
18:50:41 <ralf`> > :t foldl
18:50:41 <lambdabot>  Parse error
18:50:46 <ralf`> :t foldl
18:50:52 <ralf`> Hmm.
18:50:53 <dons> > fix ((0:) . scanl (+) 1) -- have a list for free
18:50:55 <dolio> ?type foldl
18:50:55 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
18:50:57 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
18:50:57 <dons> ?type foldl
18:50:58 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
18:51:10 <ralf`> ?type foldl
18:51:11 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
18:51:13 <dcoutts> Igloo, ie I do darcs get http:://the.remote.thing/; and then push my patches to that local copy without problem. But trying to push directly to the remote copy fails with lots of conflicts. I don't get it.
18:51:13 <int-e> The_Ball: another idea, you can use || instead of the if.  isDigit x || containsNum xs  does not evaluate the right argument if the left one is true. and finally, you could use 'any' but that's probably counterproductive if you're just beginning.
18:51:15 <ralf`> Yeah.  That's what I meant.
18:51:54 <dcoutts> Igloo, unless it's because I'm using darcs 1.0.8 here and darcs.haskell.org has 1.0.5
18:52:13 <The_Ball> thanks for the hint, exam in 40 minutes so i probably won't remember
18:52:18 <dons> MP0: learning haskell?
18:52:33 <ralf`> > foldl (&&) True (map isDigit "123xcxedf323")
18:52:34 <MP0> Attempting to
18:52:34 <lambdabot>  False
18:52:44 <MP0> It's hard to fold my brain around higher order functions
18:52:59 <ralf`> > foldl (||) True (map isDigit "123xcxedf323")
18:53:00 <lambdabot>  True
18:53:07 <dons> The_Ball: you at ANU?
18:53:12 <The_Ball> rafl, very nice!
18:53:13 * dons guesses its exam time :)
18:53:30 <int-e> @check foldl (||) False == or
18:53:31 <lambdabot>  add an instance declaration for (Eq ([Bool] -> Bool))     In the definition...
18:53:32 <The_Ball> dons, not sure what ANU is, so i guess not
18:53:39 <int-e> @check \l -> foldl (||) False l == or l
18:53:41 <lambdabot>  OK, passed 500 tests.
18:53:42 <Adamant> what does a "class" mean in Haskell terms?
18:53:50 <int-e> @check \l -> foldl (&&) True l == and l
18:53:51 <lambdabot>  OK, passed 500 tests.
18:53:53 <ralf`> MP0: Wait until you do.  Then you'll go back to an imperative language, and you'll be like, "Can't I just map a function over it?"
18:54:04 <dons> The_Ball: you have an exam? where is it?
18:54:15 <The_Ball> at griffith university, australia
18:54:23 <dons> (I was guessing you're doing a haskell course at the australian national university, in Canberra)
18:54:26 <dons> ah Griffith!
18:54:32 <dons> they have a haskell course?
18:54:49 <MP0> ralf: I already want lambda functions in Java.
18:54:49 <The_Ball> prog languages & paradigms
18:54:55 <dolio> > foldl (||) False (True : repeat False)
18:54:58 <heatsink> Adamant: A class is a set of types on which some functions work.
18:55:00 <lambdabot> Terminated
18:55:08 <dolio> > or (True : repeat False)
18:55:09 <dons> cool. I tutor the 'concepts of programming languages' course at UNSW.
18:55:10 <lambdabot>  True
18:55:10 <The_Ball> last exam in my degree :D
18:55:15 <dons> great!
18:55:16 <Adamant> heatsink, thanks!
18:55:18 <vincenz> dolio: foldr
18:55:20 <int-e> dolio: oh yeah, should be foldr.
18:55:23 <dons> > (\x -> x * 2) 2 -- have a lambda!
18:55:25 <lambdabot>  4
18:55:25 <dobblego> The_Ball, I was lecturer there last year (Gold Coast campus)
18:55:41 <The_Ball> dobblego, i see, im at nathan
18:55:43 <heatsink> Adamant, what, that made sense?
18:55:46 * heatsink is surprised
18:55:47 <dolio> > foldr (||) False (True : repeat False)
18:55:49 <lambdabot>  True
18:55:52 <dobblego> they do Haskell at Nathan campus?
18:56:02 <dons> where's that?
18:56:09 <Adamant> heatsink, I think it did
18:56:10 <dobblego> Brisbane - south side
18:56:13 <The_Ball> dobblego, prog languages & paradigms
18:56:13 <dons> ah right.
18:56:21 <The_Ball> dobblego, arock
18:56:21 <dons> cool. courses we didn't know about
18:56:48 <heatsink> I thought that was unclear and I was going to give an example...
18:56:49 <Adamant> if you can apply certain functions to a set of types, those set of types are a class
18:57:00 <dobblego> The_Ball, I work in the city
18:57:53 <Adamant> heatsink, I'm also looking at "Standard Classes" on Haskell.org
18:57:54 <heatsink> Adamant, what you said is incorrect, at least if taken literally.  Maybe you can give me an example.
18:57:54 <The_Ball> dobblego, need a graduate?
18:58:24 <chessguy> 'evening
18:58:51 <ralf`> chessguy: hello.
18:59:02 <ralf`> chessguy: Do you really like chess, as your name suggests?
18:59:13 <ralf`> chessguy: Do you use any software to think about chess?
18:59:25 <The_Ball> well, off to my last exam in a long time!
18:59:33 <MP0> good luck
18:59:39 <dons> "chessguy" is short for "cheese guy"
18:59:39 <chessguy> i do indeed like it
18:59:47 <ralf`> ?type OR
18:59:48 <lambdabot> Not in scope: data constructor `OR'
18:59:50 <The_Ball> cheers, i'll need it
18:59:50 <dons> ?type or
18:59:51 <ralf`> ?type or
18:59:52 <lambdabot> [Bool] -> Bool
18:59:53 <lambdabot> [Bool] -> Bool
18:59:54 <chessguy> and i've played around with a lot of chess software
19:00:19 <ralf`> chessguy: any in Haskell?L
19:00:36 <chessguy> no, but i'm writing my own
19:00:43 <ralf`> chessguy: I remember building a "chessboard" class when I was learning c++.
19:00:47 <ralf`> I used to like chess a lot.
19:00:50 <Pseudonym> I want to play chess with lambdabot.
19:00:52 <Adamant> well, Haskell, org lists a functor as a class. The functor definition gives a class that must meet fmap :: (a -> b) -> f a -> f b
19:01:38 <ralf`> > or (map isDigit "123xcxedf323")
19:01:40 <lambdabot>  True
19:01:50 <Adamant> so, it's sort of like defining your own type, only at a more advanced level?
19:02:11 <ralf`> The_Ball: So the foldl above is redundant, since you have or, which acts on lists as (foldl (||) True).
19:02:12 <Adamant> or am I completely off.
19:02:21 <dolio> > any isDigit "123xcxedf323"
19:02:23 <lambdabot>  True
19:02:40 <heatsink> Adamant, classes aren't really types.  Like I said, classes are sets of types.
19:02:43 <ralf`> ?t any
19:02:44 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
19:02:47 <ralf`> ?type any
19:02:49 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
19:02:59 <sjanssen> I'd like to note that or is defined via foldr, not foldl
19:03:03 <heatsink> Some types are in Functor (which is a set of types), some are not.
19:03:11 <Adamant> ah, ok.
19:03:15 <sjanssen> here is the key difference:
19:03:37 <sjanssen> > foldr (||) True (repeat True)
19:03:39 <lambdabot>  True
19:03:49 <heatsink> If a type is in Functor, then you can use fmap with that type.
19:03:50 <sjanssen> > foldl (||) True (repeat True)
19:03:54 <lambdabot> Terminated
19:04:04 <dons> mmm! http://programming.reddit.com/info/qnir/details
19:04:07 <lambdabot> Title: Write 4 lambda calculus interpreters in Haskell in 40 minutes [pdf] (reddit.com), http://tinyurl.com/y78vej
19:04:09 <heatsink> fmap is category theory related, so I'd rather explain with Ord...
19:04:31 <dons> lennart++
19:04:32 <ralf`> dons: re: your suggestion to blog code, I'm thinking of getting a page on facebook.
19:04:37 <dons> ah good.
19:04:54 <ralf`> Alternatives are blogspot, my own server (see syntaxthug.syntaxpolice.org/mathsciencetour
19:04:55 <ralf`> )
19:05:00 <ralf`> or I don't know what else.
19:05:34 <ralf`> Facebook is good?
19:05:46 <ralf`> dons: Here are my reservations in a nutshell.
19:05:48 <heatsink> A type is in Ord if values in the type have a total ordering, i.e. for any values x and y, x<y or x==y or x>y.
19:06:14 <heatsink> Adamant, can you give me a specific type that is in Ord, and a specific type that is not in Ord?
19:06:48 <ralf`> According to one model, my code-writing self is divided into three concentric zones, separated by permeable membranes, through which thoughts may or may not pass.
19:06:56 <heatsink> (that's my way of knowying that you're following the explanation)
19:07:45 <Adamant> an integer type would be in Ord, a string type would not necessarily be in Ord
19:08:00 <Adamant> unless you defined an ordering somehow
19:09:10 <heatsink> Actually, strings are in Ord.  The ordering is defined in the prelude.  But I think you have the idea.
19:09:15 <ralf`> I downloaded this here http://www.math.upenn.edu/~wilf/DownldGF.html math book and read the first ten pages.  I love having a traveling math library on my hard drive.
19:09:17 <lambdabot> Title: Download generatingfunctionology
19:09:56 <Adamant> yeah, well, I was trying to say that string Ordering is not as obvious as Integer ordering, although you can order strings. :)
19:10:00 <ralf`> I'm trying to write little balls of haskell code as I actively read it.
19:10:07 <heatsink> File handles are not ordered.  So it doesn't make sense to call (file1 < file2).  But it makes sense to call (3 < 6).
19:11:00 <ralf`> dons: I was saying about blogging, I think that once thoughts flow through my keyboard onto my hard drive, a certain privacy is lost.  I have experimented with blogging a bit, but It's hard for me to make sense of it.
19:11:07 <Adamant> thanks heatsink. :)
19:12:50 <dcoutts> Igloo, I think what happened was that the patch got applied to the working copy but not to the set of patches, then subsequent pushes failed due to conflicts in the working copy. wierd.
19:12:53 <ralf`> dons: do you have a blog?
19:13:23 <dons> yep :) you can find it from planet.haskell.org
19:13:25 <heatsink> Basically, you can say that a function only makes sense if its operand types are in some type classes.
19:13:30 <heatsink> np, hope that helped.
19:13:54 <dcoutts> Igloo, btw, any idea why it aways says: Control socket connect(/tmp//darcs-ssh/darcs.haskell.org): Connection refused
19:24:37 <ralf`> Anyone know of anything going on in the SF area right now?
19:26:12 <Captain_Fourier> i love that question
19:27:16 <Excedrin> I'm watching TV in the SF area right now
19:28:49 <Captain_Fourier> i like the general question
19:29:13 <Captain_Fourier> what is the best way to find out if/when stuff is going on in an area
19:29:47 <dolio> Oh, San Francisco.
19:30:20 <ralf`> Reading file "Data.List":
19:30:21 <ralf`> ERROR "Data.List" - Unable to open file "Data.List"
19:30:21 <ralf`>  
19:30:36 <ralf`> that's the error I get when I try to run hugs on anything wiht an import statement.
19:31:07 <dons> do you have ghc installed?
19:31:14 <dons> its more fun for the whole family
19:31:38 <dons> anyway, hugs Foo.hs seems to just work
19:31:50 <dolio> Perhaps you need to install additional packages? Debian surprised me by not including a lot of the hierarchical libraries with the basic ghc package.
19:31:50 <dons> are you using:   import Data.List ?
19:31:59 <dons> yeah, but the base package comes with hugs..
19:32:15 <dons> does: runhugs Foo.hs  -- work?
19:33:08 <ralf`> dons: yeah. precicely.  import Data.List
19:33:55 <ralf`> dons: no runhugs Foo.hs does not work.
19:34:08 <ralf`> logging out now.  I hope to fix this issue soon.
19:34:10 <ralf`> g'night.
19:34:20 <ralf`> My friend Cassie in SF says good night.
19:34:36 <int-e> ralf`: try 'import List'
19:35:10 <int-e> Cassie: but i think Data.List not existing means that your hugs is way old.
19:35:17 <dmead> =o
19:36:49 <Cassie> #G00D N173#
19:37:21 <int-e> @. elite yow
19:37:22 <lambdabot> I wiS|-| I Waz 0N A (INcinna7i 57rEe+ C0RnER |-|0lDIng a cLe4N DOg!
19:37:22 <Cassie> int-e: import List worked.
19:37:28 <Cassie> er...
19:37:44 <Elifant> Hello all! Please tell me what's wrong in the following code: newtype Test = Test {var :: String}; main = putStrLn $ show $ var Test{var="a"}, Hugs says: Program error: pattern match failure: instShow_v16_v1443 (Test_Test "a")
19:37:48 <int-e> ralf`: I followed the nick change, don't worry
19:37:52 <dons> good.
19:37:54 <ralf`> int-e: import List worked.
19:38:04 <ralf`> int-e: Yeah, but you weren't supposed to.
19:38:15 <dons> Elifant: the first 'var' is wrong.
19:38:22 <int-e> ralf`: then part and rejoin with a new nick
19:38:35 <int-e> ralf`: nick changes get broadcasted on IRC
19:39:03 <ralf`> int-e: thx.  There really are two of us here, by the way.
19:39:03 <int-e> at least to the people on the same channel with you
19:39:19 <Elifant> dons: hm... what should I write instead?
19:39:21 <int-e> good night ralf`
19:41:30 <dons> Elifant: how about:
19:41:31 <dons> newtype Test = Test {var :: String}
19:41:31 <dons>     deriving Show
19:41:31 <dons> main = print $ Test {var="a"}
19:41:46 <dons> huh. fails in hugs. *weird*
19:41:57 <dons> works fine in ghci:
19:41:58 <dons> $ runhaskell A.hs
19:41:59 <dons> Test {var = "a"}
19:42:34 <Elifant> I don't need to show Test, I extract 'var' from it first
19:42:55 <dons> looks like a hugs bug!
19:43:11 <dons> as it works fine in ghci/ghc:
19:43:12 <dons> $ runhaskell A.hs
19:43:12 <dons> "a"
19:43:17 <dons> main = print (var x)
19:43:17 <dons>     where x = Test { var = "a" }
19:43:24 <Elifant> I thought so, but it's hard to miss this during testing :)
19:43:31 <dons> can you report the test program I pasted above to hugs-bugs@haskell.org ?
19:43:44 <dons> also, you might just want to install ghc
19:44:02 <Elifant> ok, thanks a lot!
19:44:06 <dons> note that if you avoid the record syntax, it works:
19:44:07 <dons> main = print (var x)
19:44:07 <dons>     where x = Test "a"
19:44:34 <Elifant> At least there is a way to get it working :)
19:45:25 <Elifant> but it's inconvenient to use positional arguments, I have lot of them...
19:46:18 <dons> its a hugs bug. use ghc :)
19:46:28 <dons> (and amazing that its broken!)
19:47:01 <dons> (you'll be able to compile your program to fast binaries, if you use ghc instead, too)
19:47:26 <dons> hugs implements some record extensions, i wonder if that is involved somehow
19:48:46 <Elifant> I should try -98 key...
19:49:03 <Elifant> I didn't help :(
19:49:15 * Elifant goes to install ghc...
19:49:57 <sjanssen> the program works correctly in Hugs if you use a data decl. instead of newtype
19:50:37 <Elifant> yes!
19:51:02 <Elifant> I remember even hugs' system libraries use newtype...
19:51:56 <sjanssen> I think it's pretty rare to use this record creation syntax with a newtype, which is why it hasn't been caught yet
19:52:23 <Elifant> but is it supported by standard?
19:53:19 <sjanssen> after all, do you need to name the field if the data type only has one field?
19:53:32 <sjanssen> Elifant: I believe the GHC behavior is standard
19:53:52 <Elifant> sjanssen: it's a test sample, just to ask question :)
19:53:55 <Elifant> ok, so I'll use 'data' and report bug to hugs anyway, thanks all!
19:54:53 <dons> sjanssen: hmm. yes. good point sjanssen
19:55:10 <dons> lots of records with newtypes in mtl though
19:55:26 <dons> newtype State s a = State { runState :: s -> (a, s) }
19:55:41 <dons> ah, but never constructed
19:55:45 <Elifant> I give 'newtype' for records from some tutorial
19:55:47 <sjanssen> dons: that's just so they get the runFoo functions for free
19:55:53 <dons> yeah
19:56:16 <sjanssen> also, newtype record update seems to be broken
19:56:23 <int-e> dons: it's construction and record updates that break (try:   (Test "") { var = "a" } .. same bug.
19:56:47 <dons> Elifant: so you're reporting a hugs bug?
19:57:30 <Elifant> Yes, I'll report this bugs to hugs soon.
19:59:46 <encryptio> noob question: why do i get a type error when i use  putStr (someFunction getContents)  , but not when i use  myContents <- getContents     putStr (someFunction myContents)   ?
20:00:21 <dons> you have to evaluate the getContents IO action first
20:00:30 <Cale> encryptio: because getContents is an action, not a string
20:00:33 <dons> i.e. putStr . someFunction =<< getContents -- ok
20:00:57 <dons> do str <- getContents ; putStr (someFunction str)
20:02:30 <dons> i.e. the type of getContents is (IO String), but you're giving it to something that wants just a String
20:02:44 <Cale> str <- getContents will run the action getContents and bind its result to the variable str
20:02:59 <Cale> @wiki Introduction_to_IO
20:03:00 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
20:03:02 <encryptio> ah. ok.
20:03:09 <dons> you can't pass side-effecting functions (doing IO) to functions that want a pure String, since that would mix side effects into pure code, breaking all sorts of language guarantees :)
20:03:12 <Cale> read that, should clear up a few things :)
20:06:48 <dons> hmm. this should have a lot more mod ups than it does, http://programming.reddit.com/info/qnir/details
20:06:52 <lambdabot> Title: Write 4 lambda calculus interpreters in Haskell in 40 minutes [pdf] (reddit.com), http://tinyurl.com/y78vej
20:07:28 <vincenz> karmawhore :P
20:07:53 <dons> i prefer: lambdapimp
20:08:07 <dons> you really want to read .Net articles all day/
20:08:49 <encryptio> that wiki page suceeds in making my brain hurt
20:08:51 <Cale> yeah, there's too much crap on programming.reddit
20:10:25 <dons> there's fresh, original, *interesting* content produced by the haskell community each day
20:10:55 <dons> and that's far more relevant to the FP-centric programming.reddit than a lot of the other superficial items
20:10:57 <encryptio> i assume =<< is the mirror operation of >>=, no?
20:11:01 <dons> yep
20:11:06 <Cale> encryptio: yes
20:11:07 <dons> ?type flip (>>=)
20:11:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
20:11:12 <dons> ?type (=<<)
20:11:13 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
20:11:33 <Cale> (x >>= f) = (f =<< x)
20:12:13 <Cale> Like, come on guys, it's not webdesign.reddit.com or computers.reddit.com
20:12:15 <dons> thanks for submitting the bug report, Elifant
20:12:17 <dons> Elifant++
20:12:21 <dons> Cale: exactly.
20:12:42 <dons> if I have to read another article on making some pretty button with some ajax lib .. urgh.
20:13:21 <Elifant> dons: quick reaction :) are you hugs' developer?
20:13:44 <dons> i read the hugs-bugs@ list :)
20:13:52 <Pseudonym> Hang on, isn't the new fresh stuff what planet.haskell is for?
20:13:57 <Elifant> :) I'm stupid
20:14:50 <Cale> there's also lots of crap about business on there lately
20:15:11 <dons> Pseudonym: yeah, but not everyone blogs to planet.haskell.org
20:15:34 <dons> also, programming.reddit.com has interesting ocaml, erlang, .. artcles
20:15:44 <dons> so its a bit more of a meta site
20:16:20 <dylan> LtU is pretty interesting, though sparse.
20:16:25 <Pseudonym> planet.haskell could be a LtU-alike.
20:16:31 <Pseudonym> A place to aggregate Haskell-specifica.
20:16:43 <dons> yeah. needs more qulified haskell bloggers though
20:17:15 <dons> its doing fairly well, I think.
20:18:04 <dons> of course, this article by lennart ruins our week 4 tutorial quesiton in cs3161 here at UNSw -- implement HOAS for the minhs interpreter :)
20:18:07 <dons> ah well
20:18:19 <dons> we'll just have to change it to write a code gen or an smp interpreter or something fun ;)
20:18:40 <lennart> heh
20:20:44 <lennart> HOAS is surprisingly trivial :)
20:23:03 <dons> hmm. this would make a good article for the new Monad.Reader, have you considered that lennart ?
20:23:17 <Pseudonym> Haskell will never be able to fully compete with Scheme until we have enough "write a Haskell compiler in 30 minutes" tutorials.
20:23:22 <Pseudonym> We're seriously lagging behind there.
20:23:25 <dons> Pseudonym: heh.
20:24:38 <lennart> dons: I could, but it would involve work ;)
20:24:43 <dons> heh
20:25:08 <lennart> Pseudonym: the trouble is that haskell syntax is so xomplicated that you can't even write a parser in 30 minutes
20:25:41 <Pseudonym> Sadly, Haskell will never be as condescending as Scheme, then.
20:27:56 <lennart> we'll have to try harder then!
20:28:41 <Pupeno> Pseudonym: what do you mean by that ?
20:28:55 <Adamant> Pseudonym, why do you think that being able to write a Scheme interpreter in a short amount of time is a bad thing?
20:29:26 <dons> I think Pseudonym might have been joking ;)
20:29:48 <Pseudonym> Yeah.
20:29:51 <dons> (there's a rather famous haskell tutorial with the title "Write Yourself Scheme in 48 hours)
20:30:10 <Pseudonym> There's a LOT of homebrew unoptimising Scheme compilers written in a short time out there.
20:30:20 <Pseudonym> And a LOT of tutorials based on that idea.
20:30:32 <Pseudonym> It's a cottage industry, like monad tutorials in Haskell.
20:32:56 <stepcut> With ghc as a library, I figure you'll be able to write a ghc compiler in under 3 minutes pretty soon ;)
20:34:30 <NewbieHaskell> hi, what are the commands in haskell, the equivalent of a "car" of some list in Scheme..
20:34:37 <Cale> head
20:35:05 <dons> > head [1..]
20:35:05 <Cale> But you probably shouldn't use head and tail in most cases. You should pattern match.
20:35:06 <lambdabot>  1
20:35:07 <NewbieHaskell> Cale, this commands. dont work ?
20:35:08 <NewbieHaskell>  	 \(a:b) -> a
20:35:08 <NewbieHaskell> 		\lista -> car lista
20:35:08 <NewbieHaskell> 		car [a..b] = a
20:35:08 <NewbieHaskell> 		\[a,b] -> a
20:35:08 <NewbieHaskell> 		car = \a b -> a
20:35:12 <NewbieHaskell> sorry..
20:35:19 <NewbieHaskell> :|
20:35:23 <dons> > (\(a:b) -> a) [1..]
20:35:24 <dmead> =|
20:35:25 <lambdabot>  1
20:35:38 <vincenz> > let car = head in car [1..10]
20:35:40 <lambdabot>  1
20:35:43 <Cale> > (\[a,b] -> a) [1,2]
20:35:44 <lambdabot>  1
20:35:55 <dmead> > map (1+) [1..10]
20:35:57 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
20:35:57 <dons> > let car (a:_) = a in car [1..]
20:35:59 <lambdabot>  1
20:36:17 <vincenz> > let cdr (_:r) = r in cdr [1..]
20:36:19 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
20:36:20 <NewbieHaskell> :|.s
20:36:26 <dons> make sense?
20:36:35 <vincenz> dons: ah the ever present avalanche of examples once a noob shows up
20:36:42 <dmead> :s
20:36:42 <dons> we live to help!
20:36:44 <dmead> !
20:36:50 <dons> :)
20:36:51 <Adamant> Pseudonym, sorry about assuming stuff.
20:37:00 <dons> !s.'-~
20:37:00 <Cale> NewbieHaskell: I have a sneaking suspicion that there's some sort of problem with the way that you're working with the haskell compiler/interpreter.
20:37:17 <NewbieHaskell> eheh no..
20:37:21 <dmead> > "hi" . "there
20:37:22 <lambdabot>  Improperly terminated string
20:37:25 <dmead> > "hi" . "there"
20:37:25 <lambdabot>  Couldn't match `b -> c' against `[Char]'
20:37:38 <dmead> > putStr
20:37:40 <lambdabot>  <[Char] -> IO ()>
20:37:46 <dmead> > putStr "hello"
20:37:47 <lambdabot>  No IO allowed
20:37:53 <dmead> > do putStr "hello"
20:37:54 <lambdabot>  No IO allowed
20:37:56 <dmead> =(
20:37:56 <dons> the type checker schools dmead
20:38:01 <dmead> ;o
20:38:11 <dmead> i have to learn monads next weekend
20:38:18 <dmead> so i can get my prover to pint out proofs
20:38:21 <dmead> *print
20:38:25 <vincenz> nono
20:38:29 <dmead> so millions of logic students can cheat
20:38:31 <dmead> =p
20:38:33 <vincenz> don't correct, it was clearly a freudian slip
20:38:36 <spiffy> dmead: id be happy with pints.
20:38:38 <vincenz> you want it to pimp out proofs
20:38:43 <dmead> lol
20:38:58 <spiffy> o we're all so funny in #haskell ;-)
20:39:02 <dons> heh, reddit  sez:  Favouring composition over inheritance is a sign of a maturing programmer
20:39:28 <vincenz> dons: we should start one "Favouring referential transparency over side-effects is a sign of a maturing programming"
20:39:37 <vincenz> I wonder how one tells when they're over-ripe, tho
20:39:38 <dons> heh
20:39:46 <dons> they do it all on the type level
20:39:48 <dons> that's the sign
20:39:50 <dmead> i program too much
20:40:00 <dmead> i need to get my fat ass out for a run =>
20:40:08 <dmead> > run
20:40:10 <lambdabot>  Not in scope: `run'
20:40:14 <dmead> see?
20:40:15 <vincenz> > let run = run in run
20:40:16 <lambdabot>  Add a type signature
20:40:40 <Pseudonym> I thought you said "i need to get my fat ass out for a nun".
20:40:41 <dmead> > data Excercise = running
20:40:42 <lambdabot>  Parse error
20:41:01 <Pseudonym> Not being Catholic, I found that a bit weird.
20:41:03 <dmead> > data Excercise = running | walking
20:41:04 <lambdabot>  Parse error
20:41:05 <dons> Pseudonym: oh my.
20:41:06 <spiffy> get that r upcased! lazy good for nothing...
20:41:09 <dmead> parses ERROR
20:41:10 <dmead> hehe
20:41:24 <dmead> > data Excercise = Running | Walking
20:41:25 <lambdabot>  Parse error
20:41:26 <dmead> oh yea
20:41:28 <dmead> wtf
20:41:58 <dons> expressions only, thanks
20:42:03 <spiffy> right
20:42:11 <dmead> > data Excercise = Running  a | Walking a
20:42:11 <spiffy> just like gchi
20:42:12 <lambdabot>  Parse error
20:42:14 <dmead> hmm
20:42:17 <dons> dmead: ...
20:42:23 <dons> ?help run
20:42:24 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
20:42:29 <dons> <expr> !
20:42:35 <dons> not <type decl> ;)
20:42:35 <dmead> ohh
20:43:00 <dmead> lambdabot is a fancy hugs interaction?
20:43:01 <sjanssen> @let data Excercise = Running | Walking -- is this allowed?  can't remember.
20:43:02 <lambdabot> Invalid declaration
20:43:04 <Cale> lennart: You know, since IdInt is a newtype, if you don't mind using extensions, you can just derive Enum.
20:43:16 <dons> sjanssen: you wrote the parser fix to prevent it, iirc
20:43:25 <sjanssen> dons: heh, this is true
20:44:43 <sjanssen> ah yes, it isn't allowed because of that type checker bug
20:45:28 <NewbieHaskell>  car [a..b] = a     <-- that works ?
20:45:40 <int-e> hmm. Succ = \n.\z.\s.s n;  ... shouldn't that be  \n.\z.\s.s (n s z)?
20:46:02 <sjanssen> NewbieHaskell: if car = head, then yes
20:46:24 <sjanssen> and fromEnum a < fromEnum b
20:46:31 <spiffy> > head [1..10]
20:46:33 <lambdabot>  1
20:46:48 <spiffy> let car = head in car [1..10] --if you insist
20:46:52 <int-e> lennart: sorry, my last question was for you.
20:46:59 <spiffy> > let car = head in car [1..10] --if you insist
20:47:01 <lambdabot>  1
20:47:03 <sjanssen> > head [1..0]
20:47:04 <lambdabot>  Exception: Prelude.head: empty list
20:47:35 <Cale> NewbieHaskell: that's not a valid declaration, but it is something which is true given that the list is nonempty.
20:47:53 <Cale> car (x:xs) = x
20:47:58 <spiffy> > let list = 1 : [ x | x<- 1 + (head list)] in head list
20:47:59 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
20:48:00 <lambdabot>    Expected...
20:48:06 <spiffy> opps
20:48:09 <Cale> that's a valid declaration
20:48:09 <dons> ?lam (\n.\z.\s.s (n s z))
20:48:10 <lambdabot> <<Plugin.Lambda.LMEngine.EvalMonad Dynamic -> Plugin.Lambda.LMEngine.EvalMonad Dynamic>>
20:48:14 <dons> ?lam (\n.\z.\s.s (n s z)) 2
20:48:15 <lambdabot> <<Plugin.Lambda.LMEngine.EvalMonad Dynamic -> Plugin.Lambda.LMEngine.EvalMonad Dynamic>>
20:48:21 <dons> ?lam (\n.\z.\s.s (n s z)) i
20:48:22 <lambdabot> <<Plugin.Lambda.LMEngine.EvalMonad Dynamic -> Plugin.Lambda.LMEngine.EvalMonad Dynamic>>
20:48:24 <dons> bah
20:48:26 <Cale> whee
20:48:28 <spiffy> :|
20:49:21 <dons> ?let car (a:b) = a
20:49:22 <Cale> > let list = 1 : list in head list
20:49:23 <lambdabot> Defined.
20:49:23 <lambdabot>  1
20:49:26 <dons> > L.car [1..10]
20:49:28 <lambdabot>  1
20:49:35 <spiffy> so why didnt mine work Cale?
20:49:47 <Cale> spiffy: 1 + (head list) is not a list
20:49:55 <spiffy> d'oh of course
20:50:52 * spiffy still hasnt had a situation where infinite lists were useful enough to actually play around with them
20:51:16 <Botty> ?let cdr (a:b) = b
20:51:17 <lambdabot> Defined.
20:51:22 <Cale> You have to sort of play around with them in useless ways for a while before you start to see places where they'd be useful
20:51:56 <spiffy> Hmmm
20:52:07 <Cale> and often it's not just infinite, but really ridiculously long lists where useful cases are
20:53:24 <spiffy> fair enough
20:53:46 <Cale> Like where you're searching for some solution to a problem, and each iteration produces a few potential possibilities to try
20:54:02 <Cale> Essentially, writing breadth-first searches :)
20:54:06 <spiffy> ahh ok
20:54:46 <Cale> In fact, you can make them behave like depth-first searches by simply not working with the intermediate lists.
20:55:19 <Cale> (this requires a bit of care to set up, but it's what the list monad is really good at)
20:55:32 <dons> a nice example from ghc:
20:55:33 <dons>         key_map = listToFM ([(moduleName (ms_mod s), ms_hsc_src s)
20:55:33 <dons>                             | s <- summaries]
20:55:33 <dons>                            `zip` [1..])
20:56:20 <spiffy> so what uses key_map?
20:56:45 <dons> something in ghc somewhere
20:57:06 <jgrimes> what are the reasons behind have ^^ as a separate function from ^?
20:57:07 <lambdabot> jgrimes: You have 1 new message. '/msg lambdabot @messages' to read it.
20:57:21 <dons> ?type (^^)
20:57:22 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
20:57:24 <Botty> ?tyoe ^
20:57:25 <dons> ?type (^)
20:57:26 <lambdabot> parse error on input `^'
20:57:27 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
20:57:36 <spiffy> is that infinite or just really long
20:57:45 <dons> its lazy :)
20:57:46 <jgrimes> fair enough
20:57:51 <dons> so its as long as it needs to be
20:58:28 <dons> here's a nice one, from yi:
20:58:31 <dons>   catchDyn (sequence_ . km =<< getChanContents ch
20:58:46 <dons> the input from getChanContents is all keystrokes (lazily) enteried into the editor
20:58:48 <jgrimes> lispy, I'll send you the patch. some of it changes a few things outside of a newfile (Compile32). mostly just imports for testing
20:58:58 <dons> which is treated as a simple list, and processed as data appears
20:59:09 <spiffy> now thats neat
20:59:18 <spiffy> i could see that being handy
21:01:20 <spiffy> now when you see lazly, does that mean as soon as text is entered control jumps to there?
21:02:10 <dons> the keyhandler (naturally) blocks waiting on keys to be processed, forking off handler threads as required.
21:02:27 <spiffy> ahhh
21:02:27 <dons> and no special support is required, beyond having a lazy list for the input
21:02:37 <spiffy> even for the threading?
21:02:51 <dons> well, in this case, 'km' is the function of type :: Char -> IO ()
21:03:04 <dons> which handles each input char that arrives
21:03:11 <dons> sorry, [Char] -> IO ()
21:03:12 <Pupeno> @paste
21:03:13 <lambdabot> http://paste.lisp.org/new/haskell
21:03:18 <spiffy> ahh ok
21:03:24 <lisppaste2> Pupeno pasted "'put ?" at http://paste.lisp.org/display/29765
21:04:28 <Pupeno> In that piece of code, near the end, 'put_ and 'get are used. What are these apostrophee-starting identifiers ? ghc seems to have no problem with it but haddock interprets them as non-closed character literals.
21:06:09 <dino-> Is it not valid/correct to put type signatures in instance declarations?
21:08:53 <dino-> I'm getting a "Misplaced type signature" error.
21:10:43 <int-e> lennart: I was wrong. you just have a very different number representation than I'm used to.
21:12:33 <dons> dino-: paste the code?
21:12:35 <dons> ?paste
21:12:36 <lambdabot> http://paste.lisp.org/new/haskell
21:15:20 <lisppaste2> dino- pasted "no type sig for instance?" at http://paste.lisp.org/display/29766
21:15:56 <dons> yes, no type sigs in the instance
21:16:15 <dino-> I'm going through the haskellwiki/Monads_as_containers page and they've got type sigs in instance declarations, is why I tried it.
21:16:27 <dino-> http://www.haskell.org/haskellwiki/Monads_as_containers
21:16:31 <lambdabot> Title: Monads as containers - HaskellWiki, http://tinyurl.com/yylt9j
21:16:34 <int-e> Hmm. My toy interpreter (de Bruijn indices based) evaluates lennart's example in 0.012 seconds on my 1.8 GHz Athlon. (http://int-e.home.tlink.de/haskell/lambda_.hs -- still lacks a nice parser that deals with a proper dictionary. the core evaluation routine is 10 lines of code)
21:16:37 <dino-> Down where it says 'instance Monad [] where'
21:16:44 <MP0_> do you guys know of a good way to wean oneself off of imperative languages?
21:17:06 <dons> install ghc :)
21:17:11 <dons> and hack
21:17:15 <dino-> MP0_: I've been trying. Difficult, but very rewarding.
21:17:37 <MP0_> I've done the first part... the second part is, like dino said, difficult.
21:17:51 <dons> go through a tutorial?
21:17:53 <dons> ?where yaht
21:17:54 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
21:17:57 <dons> is a good one.
21:18:29 <dons> this is a good one if you know irc http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
21:18:32 <lambdabot> Title: Roll your own IRC bot - HaskellWiki, http://tinyurl.com/y4prf8
21:18:33 <dobblego> MP0_, attempting to reason about your imperative code in great detail
21:18:57 <MP0_> dobblego: to what end?
21:18:57 <dons> (kinda of gives you the flavour for why imperative programming is just a special case of declarative programming)
21:20:13 <MP0_> I guess I wish algol-derivatives weren't so comfortable. At least while I learn.
21:20:46 <MP0_> I like the Roll your own IRC bot tutorial though!
21:24:29 <MP0_> Can Haskell be used in low-memory environments like the embedded space?
21:24:36 <mwc> dcoutts, holy GTK2HS commit rampage, badmat
21:24:40 <mwc> *batman
21:24:53 <dons> MP0_: yeah, nhc/yhc were designed for use on embedded systems
21:24:56 <mwc> MP0_, that would depend on the implementation
21:25:02 <sjanssen> POW!
21:25:05 <sjanssen> KERPLAT!
21:25:06 <dons> ZAP!
21:25:08 * MP0_ looks them up
21:25:13 <dons> BIFF!
21:27:22 <MP0_> ooh la la, YHC has ansi C portable runtime
21:27:29 <MP0_> music to my ears!
21:28:15 <dons> C runtimes are rather common... ;)
21:28:32 <mwc> MP0_, what exactly do you mean by embedded space
21:28:40 <MP0_> I dunno, ANSI C ones don't seem to be terribly common... LUA has one.
21:29:04 <mwc> I could see using YHC in something like a car PC or something... It wouldn't be my first choice to write the rom of a microwave or a wristwach
21:29:08 <MP0_> embedded processors. I guess it might be unrealistic to target a PIC
21:29:28 <mwc> You're talking about something like a geode? or maybe an Xscale?
21:29:34 <MP0_> nothing that high end
21:29:38 <MP0_> maybe 186
21:30:08 <mwc> I think that if you run a 32 bit OS on the platform, Haskell can be a good choice
21:30:17 <MP0_> 8 and 16 bits
21:30:25 <mwc> below that, I think you're better off with C and assembler
21:30:41 <Pseudonym> BTW, nitpick>
21:30:49 <Pseudonym> Just because it's embedded doesn't mean it's small.
21:30:59 <mwc> Yeah, like my example of a car PC
21:31:00 <MP0_> yeah... Lua's looking like a good choice, although I really have to make sure it's tables don't take up too much memory.
21:31:02 <Pseudonym> A pacemaker is an embedded device.  So is an MRI scanner.
21:31:13 <Pseudonym> So is an atomic force microscope.
21:31:21 <Pseudonym> As I discovered when I had to move offices to make room for one.
21:31:39 <mwc> heh :)
21:34:08 <mwc> afaik, haskell has to be garbage collected. Maybe something like region based memory is availible, but in the end you're depending on the computer being able to do smart things with the memory. If you're on a 16 bit system, you probably need to be careful about how you use resources. That probably means manual control of memory
21:35:32 <MP0_> yeah, besides I don't think my fellow C programmers would be too fond of seeing haskell intermediaries in the build tree.
21:36:56 <mwc> On the otherhand, I think haskell could be a fine choice for an MRI or a SEM
21:37:23 <MP0_> It's just that I'd really like to get the number of defects in the code down.
21:38:02 <dobblego> which mailing list is the haskell weekly newsletter sent to?
21:38:43 * Botty wonders if it has to be sent anywhere
21:39:05 <mwc> MP0_, I'd be the first to testify that learning haskell has made me a vastly better C++ programmer
21:39:09 <dobblego> I'm looking for a quote from Ron Jeffries
21:40:10 <Botty> http://www.haskell.org/haskellwiki/Haskell_Weekly_News
21:40:14 <lambdabot> Title: Haskell Weekly News - HaskellWiki, http://tinyurl.com/yhepg7
21:40:15 <MP0_> It's more that doing things in C means working away from the problem domain. It's also kinda hard to unit test the way it is.
21:40:46 <dons> dobblego: haskell@haskell.org
21:40:51 <dons> the main announce list
21:40:54 <dobblego> ta
21:40:59 <dons> which *everyone* should be subscribed to
21:41:03 <dobblego> ah found it, thanks
21:41:14 <dobblego> everyone in the whole wide world even?
21:41:29 <dons> mwc: but they use java on embedded systems... no?
21:41:35 <dons> dobblego: yes :)
21:42:14 <Pseudonym> mwc: Me too!
21:42:57 <dobblego> when people like Ron Jeffries make statements like that, it is a huge step backward for those wishing to learn how to program a computer
21:43:10 <dobblego> and I object to that
21:43:11 <Pseudonym> Having worked on small embedded firmware for a while, I do tend to find that the problem domain _is_ the low-level hardware crap.
21:44:08 <Pseudonym> So programming in C isn't a huge loss.
21:44:29 <Pseudonym> Another example is Linux,.
21:44:51 <Pseudonym> Linux is the low-level bit-twiddling layer that you find in every application.
21:45:00 <Pseudonym> User space is the high-level problem-domain layer.
21:46:07 <Botty> dobblego - he's got a point though.  The way haskell thinks might just be closer to how people, I mean mathematicians think
21:46:11 <edwardk> you know its time to stop when you are seeking inspiration for your syntax in APL
21:46:31 <dons> heh
21:47:18 <dobblego> Botty, few things annoy me - but things like this do
21:47:21 <Botty> I don't even know how I think - its like a reverse blackhole
21:47:31 <MP0_> Depends on the task... some of the stuff we work on is close to the hardware and a state machine in C is a great solution, but other times the hardware is mostly abstracted away.
21:48:00 <dons> hehe "Considering that my manager doesn't know a tail call from sodomy ..."
21:48:01 <MP0_> and the main obstacles to higher level languages is low memory.
21:48:07 <dobblego> some poor bastard out there wants to learn how to program a computer - and he has got to contend with that kind of rubbish
21:48:19 <Botty> dobblego - well, at least he says its 'his opinion'
21:48:42 <mwc> dons, java on embedded systems? God, I hope now
21:48:49 <Botty> yeah, I agree elitism is bad
21:48:53 <dobblego> yes, making it all the more elusive and difficult to identify as rubbish to the naive observer
21:49:18 <dons> mwc, how much space do you have on a phone? do they still count as embedded? I seem to recall microwaves running java back in the 90s though
21:49:31 <dons> ?google java embedded systems
21:49:34 <lambdabot> http://java.sun.com/products/personaljava/w3mulc.pdf
21:49:40 <dobblego> one need only pull one's head out of one's arse to see that all that recursive stuff does not make it "less clear"
21:49:59 <dons> dobblego: heh. don't worry about it.
21:50:10 <mwc> modern phones are pretty sophisticated, it could host Haskell easily
21:50:19 <dons> yeah (shapr's does!)
21:50:29 <mwc> On the otherhand, a Motorola FLipPhone from 1995... not so much :)
21:50:50 <dons> i think nhc used to run in 400k ram or something?
21:50:57 <dobblego> with one's head up one's arse, one couldn't help thinking recursively anyway
21:51:04 <dons> very small, anyway, with all the heap compression and bytecode compression
21:51:13 <dons> dobblego: heh
21:54:38 <Cale> dobblego: Well, here's one argument for it -- ordinary people don't really think in terms of iteration or recursion. They think in terms of higher-order functions. What do you do when you want to wash the dishes? You have a sink full of them, and you simply wash them all. You don't number them, you probably don't even consciously break the problem into washing a single dish and washing the rest.
21:55:29 <Cale> It's a lot more like "map wash dishes" than an iterative loop, or some explicit recursive breakdown of the problem.
21:55:50 <dons> yeah
21:56:00 * Botty tries to think of a real world thing that doesn't map itself well to haskell
21:56:17 <Botty> maybe i should say concept rather than problem
21:56:22 <Cale> So the argument is that functional languages provide the tools necessary to write these higher-order ways of thinking which you use all the time.
21:56:33 <dons> we think in terms of maps all the time. and folds fairly often
21:59:17 <dons> I grew up on a sheep farm, and never counted sheep out with a for loop, it was always exactly: foldl (const (+1)) 0 sheep
21:59:44 <Botty> yep, you used a foreach loop
22:00:03 <Botty> (burn, btw ;) )
22:00:14 <Pseudonym> I would use: sum [ legs s | s <- sheep ] `div` 4
22:00:18 <dons> heh
22:00:26 <dons> you counted the legs?
22:00:27 <sjanssen> dons: I hope you didn't have very many sheep . . . that foldl could build a very large thunk
22:00:31 <dons> hehe
22:00:34 <Pseudonym> I didn't grow up on a sheep farm.
22:00:41 <dons> it was a foldl' , you're right, sjanssen
22:00:53 <Pseudonym> If you're already counting legs, though, this saves on work.
22:01:48 <Excedrin> it seems sketchy to assume that all sheep have 4 legs
22:02:04 * Botty thinks that if haskell was truely intelligent, you wouldn't have to differentiate folds /me isn't trying to be a negative nancy, just seems like it's an area haskell could improve on
22:02:16 <chessguy> the ones without 4 legs have already been turned into a tasty lamb dinner
22:02:17 <dons> seen class Foldable ?
22:03:01 <sjanssen> Botty: but foldr and foldl mean different things
22:03:12 <Pseudonym> mmmm... lamb dinner...
22:03:23 <chessguy> Pseudonym, my thoughts exactly
22:03:24 <Botty> sjanssen - can be inferred from the parameters and expression though
22:03:43 <mwc> @type foldl
22:03:45 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:03:46 <mwc> @type foldr
22:03:49 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
22:03:54 <sjanssen> sure, GHC could turn foldr (+) into foldl' (+) when + is integer addition
22:04:04 <sjanssen> but that's a fairly limited optimization
22:04:13 <Botty> well, I suppose if a and b are the same then you can't know....
22:04:21 <mwc> So you mean just look at the type of the function passed into fold and see if the result is the type of the first or second?
22:04:33 <Botty> mwc - yes
22:04:34 <dobblego> Cale, I agree somewhat
22:04:40 <sjanssen> Botty: even if a and b are the same, foldl and foldr can be different
22:04:59 <sjanssen> > foldr (||) False (repeat True)
22:05:00 <lambdabot>  True
22:05:10 <sjanssen> > foldl (||) False (repeat True)
22:05:10 <Botty> If they are different then foldl or foldr is implied
22:05:14 <lambdabot> Terminated
22:06:27 <sjanssen> I would not be happy if I wrote "magicFold (||) False (repeat True)", and the compiler chose the second version
22:07:17 <Botty> well, yes, that's where my idea breaks down, when a and b are the same
22:12:06 <Botty> I suppose foldl and foldr are better because then you make the difference explicit, and if you have the parameters in the wrong order it will cause you to look at the code again and perhaps catch bugs
22:14:05 <Cale> Well, the difference is especially important in a language with non-strict semantics
22:14:15 <Cale> foldr works with infinite lists, foldl doesn't
22:15:02 <Botty> yeah, and determining if the list is infinite or not isn't always possible
22:21:41 <jcreigh> > take 5 (foldr (:) [] [1..])
22:21:42 <lambdabot>  [1,2,3,4,5]
22:22:09 <Botty> > take 5 (foldl (:) [] [1..])
22:22:11 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
22:22:11 <lambdabot>    Expected...
22:22:48 <Botty> though apparently it keeps some track of infinite lists..
22:23:12 <jcreigh> > foldl (flip (:)) [] [1..5]
22:23:14 <lambdabot>  [5,4,3,2,1]
22:26:06 <Botty> > take 5 (foldl (++) [] [1..])
22:26:08 <lambdabot>  add an instance declaration for (Num [a])
22:26:22 <Botty> > take 5 (foldr (++) [] [1..])
22:26:23 <lambdabot>  add an instance declaration for (Num [a])
22:26:59 <jcreigh> it's trying to do [] ++ 1, and it can't, because ++ works on lists. (which 1 is not.)
22:27:02 <int-e> lennart: http://int-e.home.tlink.de/haskell/DeBruijn2.hs beats HOAS in terms of speed, at least for your example. I don't know why.
22:27:05 <lambdabot> http://tinyurl.com/un5e8
22:27:46 <Botty> yeah, sometimes I don't think
22:40:23 <jcreigh> @type iterate
22:40:25 <lambdabot> forall a. (a -> a) -> a -> [a]
22:40:41 <jcreigh> > (iterate cos 1.0) !! 100
22:40:42 <lambdabot>  0.7390851332151607
22:40:56 <jcreigh> > cos $ (iterate cos 1.0) !! 100
22:40:58 <lambdabot>  0.7390851332151607
22:42:24 <jcreigh> > fix cos
22:42:25 <lambdabot>  Exception: <<loop>>
22:42:55 <jcreigh> > fix (\_ -> 12)
22:42:57 <lambdabot>  12
22:43:06 <jcreigh> > fix (1:)
22:43:08 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
22:44:58 <jcreigh> > fix (\x -> if x < 10 then x + 1 else 10)
22:44:59 <lambdabot>  Exception: <<loop>>
22:45:12 <jcreigh> @type fix
22:45:14 <lambdabot> forall a. (a -> a) -> a
22:49:11 <dolio> fix computes (effectively) the limit of the sequence: _|_, f _|_, f (f _|_) ...
22:49:50 <jcreigh> But it's hard to write an interesting function that has a base case for _|_ :)
22:49:51 <dolio> So trying to find the fixed point of a function on numbers won't work.
22:51:15 <dolio> Unless you do something like: f = \g x -> if test x then x else g x
22:52:11 <dolio> But that's not really the same.
22:53:55 <dolio> > fix (\g x -> if x < 10 then g (x + 1) else 10) 1
22:53:57 <lambdabot>  10
22:59:36 <bran__> anyone compile ghc 6.6 with darwin ports? i'm getting this error:
22:59:36 <bran__> --->  Configuring ghc
22:59:37 <bran__> Error: Target com.apple.configure returned: configure failure: shell command "cd "/opt/local/var/db/dports/build/_opt_local_var_db_dports_sources_rsync.rsync.darwinports.org_dpupdate_dports_lang_ghc/work/g
22:59:41 <bran__> ...
23:01:21 <xnito> hello
23:02:18 <dgoldsmith> bran__: I've successfully used the binary distributions, and rebuilt from the source distribution. I haven't tried darwin ports. Are you building on PPC or Intel>
23:02:21 <dgoldsmith> ?
23:02:39 <bran__> intel
23:03:30 <dgoldsmith> bran__: If you don't need OpenGL the Intel distribution works fine. It has a packaging error that breaks OpenGL. You can work around that by rebuilding from source.
23:04:22 <dgoldsmith> I don't know what the problem is you're seeing with darwin ports. I haven't used that mechanism much.
23:08:25 <xnito> does anyone know how to import in the the hugs interpreter without loading a file?
23:10:42 <dons> you mean, other than:
23:10:43 <dons> Hugs.Base> :l Data.Char
23:10:44 <dons> Data.Char>
23:11:58 <dons> otherwise, you might consider ghc/ghci, they're more up to date and featureful than hugs these days
23:14:06 <xnito> I have both GHCI and hugs
23:14:49 <dons> in ghci, you do:
23:14:50 <dons> $ ghci
23:14:51 <dons> Prelude> :m Char
23:14:51 <dons> Prelude Char> :m + List
23:14:51 <dons> Prelude Char List> :t sortBy
23:14:53 <dons> sortBy :: (a -> a -> Ordering) -> [a] -> [a]
23:14:58 <dons> to bring other modules into scope
23:15:04 <satan> hello all
23:15:14 <dons> hey satan
23:15:19 <satan> how goes it?
23:15:35 <dons> lambda-riffic!
23:15:46 <satan> ahaha
23:15:51 <xnito> a ta thanks
23:16:50 <satan> ok so im doing a proof by induction to prove that xs ++ xs = xs, where xs is an infinite list
23:17:10 <satan> and for the inductive step, i have (x:xs ++ x:xs) = x:xs, well i need to show that that's true
23:17:59 <satan> so on the LHS, i get x:(xs ++ x:xs), but not sure how to proceed there....
23:18:15 <NewbieHaskell> hello, somebody knows Scheme ?  why, when i have two lists  W and U ..   w '(a b c d)   u '(e b c d)   <-- i apply this..  (set-car! (cdr u) (car w))
23:18:44 <dblhelix> satan: why don't you try to prove the more general xs ++ ys = xs if xs is infinite?
23:19:09 <satan> dblhelix: hmm thats a good idea
23:19:29 <dblhelix> satan: your inductive proof then needs tree cases: two base cases for [] and _|_ and one inductive step for (:)
23:19:54 <satan> right, so for ys = [], we get xs ++ [] = xs, easy enough
23:20:11 <satan> er, i guess we should do the induction on xs, not ys
23:21:48 <dons> in case people didn't see earlier, this is rather nice: http://programming.reddit.com/info/qnir/comments
23:21:52 <lambdabot> Title: Write 4 lambda calculus interpreters in Haskell in 40 minutes [pdf] (reddit.com), http://tinyurl.com/yzyy4n
23:22:12 <dolio> Is induction appropriate?
23:22:28 <Elifant> urrrr, it seems I have found another bug in hugs... the code is about 10 lines, could I post it here?
23:22:39 <chessguy> dons, you're a never-ending source of interesting stuff :)
23:22:39 <dolio> Certainly you can't do induction when on the list that's always infinite.
23:22:41 <int-e> @paste
23:22:41 <lambdabot> http://paste.lisp.org/new/haskell
23:22:44 <satan> dolio: i guess, how else would one prove it?
23:22:49 <xerox> G'day.
23:22:52 <dolio> satan: Coinduction?
23:23:02 <satan> dolio: i don't know what that is
23:23:47 <dons> Elifant: use the @paste.
23:23:49 <dons> good work!
23:23:58 <xerox> chessguy: neverendingSource = mdo { interestingStuff <- dons; rest <- neverendingSource; return (interestingStuff:rest) }
23:25:01 <satan> so with induction, if i had x:xs ++ ys, then i'd get x:(xs ++ ys), and since the inductive hypothesis is xs ++ ys = xs, that resolves to x:xs
23:25:12 <lisppaste2> Elifant pasted "Hugs bug (Segfault)" at http://paste.lisp.org/display/29775
23:25:12 <satan> so it does work, or am i goofing somewhere?
23:25:25 <chessguy> xerox, you're weird
23:25:45 <dolio> Yes, but since it's an infinite list, xs isn't smaller than x:xs, so there's a problem.
23:25:50 * xerox finishes to wake up
23:25:53 <dons> Elifant: also, did you get ghc installed? :)
23:26:04 <satan> dolio: oh i see
23:26:06 <Elifant> not yet :) I don't loose hope
23:26:31 <dons> Elifant: nice!
23:26:32 <dons> $ runhugs -98 A.hs
23:26:32 <dons> State: Test {var = zsh: illegal hardware instruction (core dumped)  runhugs -98 A.hs
23:26:35 <dons> Elifant++
23:26:35 <Elifant> At last, I may be useful for improving Hugs ^)
23:26:48 <dolio> I have a paper on coinduction, but I haven't read it yet. So unfortunately, I can't actually help you prove your theorem. :)
23:27:01 <Elifant> I seems it didn't like double "let v = ..."
23:27:03 <satan> dolio: ah alright, well, thanks anyway :)
23:27:06 <dolio> But I think it's an appropriate tool to prove things about infinite lists.
23:27:08 <satan> dblhelix: thanks
23:27:21 <dons> Elifant: it loops in ghc (you encoding recursion in the type there?)
23:27:24 <chessguy> dolio, for a minute i thought you said "I have written a paper on coinduction, but I haven't read it yet..."
23:27:31 <xerox> dons: type-level fix?
23:27:47 <dolio> Heh. Yes, and I don't test my programs, I only prove them correct.
23:28:00 <dons> an no. recursion on the value level :)
23:28:01 <dons>     let v = v + 1
23:28:06 <dons> > let v = v + 1 in v
23:28:08 <lambdabot>  Exception: <<loop>>
23:28:10 <dons> :)
23:28:19 <dolio> This is the paper I have. I don't know if it's a good one: http://citeseer.ist.psu.edu/jacobs97tutorial.html
23:28:22 <lambdabot> http://tinyurl.com/tetsc
23:28:33 <dons> Elifant: a = do
23:28:33 <dons>     s <- get
23:28:33 <dons>     let v = var s
23:28:33 <dons>     put $ Test (v+1)
23:28:49 <dons> $ runhugs -98 A.hs
23:28:49 <dons> State: Test {var = 1}
23:28:49 <dons> $ runghc A.hs
23:28:49 <dons> State: Test {var = 1}
23:28:55 <Elifant> dons, I know how to correct this, but is my program is incorrect?
23:29:06 <dons> let v = v ... is recursive, so it will loop. hugs shouldn't crash though
23:29:18 <xerox> a = modify ((+1) . var)
23:29:22 <dons> ghc behaves correctly and loops.
23:29:38 <Elifant> hm.... I have to go reread tutorials...
23:29:42 <dons> (well, hugs loops too, but kills the stack or something)
23:30:17 <Elifant> I thought each V lives in it's own scope...
23:30:30 <Elifant> which consists of following lines
23:30:33 <dons> yeah,
23:30:33 <dons> a :: State Test ()
23:30:33 <dons> a = modify $ \(Test x) -> Test (x+1)
23:30:59 <dons> Elifant: but in your let v = v ... the v you're defining is in scope on the rhs
23:31:10 <dons> let you can have to let v's, but not a let v = v ...
23:31:40 <dons> (unless you have some lazy structure that lets you get away with circular defns)
23:31:43 <Elifant> it's unexpected, I thought right part is evaluated in previous scope
23:31:44 <dons> > let s = 1:s in s
23:31:45 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
23:31:55 <dons> see how that worked?
23:32:05 <Elifant> some time needed ^)
23:32:15 <dons> > let s = 1 + s in s -- will diverge
23:32:17 <lambdabot>  Exception: <<loop>>
23:32:30 <Elifant> yes, but... I have to unroll 'do' notation manually to understand...
23:33:08 <Elifant> should I post this to hugs-bugs?
23:33:22 <dons> yep
23:33:36 <dons> hugs should spot the blackhole, or fail gracefully
23:33:45 <dons> you could also write:
23:33:46 <dons> a = do x <- gets var
23:33:46 <dons>        put (Test (x+1))
23:33:51 <xerox> ?remember dons hugs should spot the blackhole, or fail gracefully
23:33:53 <xnito> no it shouldnt
23:34:17 <dons> or diverge in some other sensible way.
23:34:36 <xerox> xnito: but it has enough information, why shouldn't it?
23:34:55 <xnito> take 5 ones where ones = 1:ones
23:35:13 <dons> that's fine, its not a blackhole
23:35:23 <dons> > let ones = 1:ones in take 5 ones
23:35:25 <lambdabot>  [1,1,1,1,1]
23:35:29 <xerox> > let evens = map (+1) odds; odds = 1 : map (+1) evens in transpose [odds,evens]
23:35:31 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20],[21,...
23:35:39 <dons> > let s = 1 + s in s -- is the problem
23:35:41 <lambdabot>  Exception: <<loop>>
23:35:46 <dolio> ghci doesn't detect black holes either, does it?
23:35:55 <dolio> Only compiled code.
23:35:56 <dons> yeah, same rts.
23:36:03 <dons> oh, hmm, *maybe*
23:36:05 <dons> but hugs doesn't:
23:36:06 <dons> $ runhugs -98 A.hs
23:36:07 <dons> State: Test {var = zsh: illegal hardware instruction (core dumped)
23:36:07 <dons> :)
23:36:09 <xnito> can it warn about them?
23:37:00 <Botty> > let evens = map (+1) odds; odds = map (+1) evens in transpose [odds,evens]
23:37:01 <lambdabot>  Exception: <<loop>>
23:37:14 <dons> dolio: yeah, ghci doesn't spot the black hole
23:37:17 <xerox> Botty: no strings in your boots to grip to :)
23:37:27 <xerox> straps, or whatever.
23:37:30 <Botty> yeah, I know, was curious what it'd do ;)
23:37:45 <dons> Elifant: a simple test case:
23:37:49 <dons> for hugs bugs:
23:37:51 <dons> Hugs.Base> let s = 1 + s in s
23:37:51 <dons> zsh: illegal hardware instruction (core dumped)  hugs
23:38:04 <dons> Move to ghci!
23:38:08 <int-e> Ok, puzzle time. In Lennart's lambda calculator, find and fix the two subtle problems in the subst function.
23:38:13 <dons> heh
23:38:21 <dons> substitution is irksome though
23:38:22 <xnito> I've never tried the lambdabot
23:38:27 <int-e> in the DeBruijn module
23:38:42 <xnito> > 1 + 1
23:38:44 <lambdabot>  2
23:38:47 <xnito> yay
23:38:50 <dons> :)
23:39:05 <int-e> dons: did you see my de bruijn module?
23:39:06 <dons> > fix $ \f -> 1 : 1 : zipWith (+) f (tail f)
23:39:08 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
23:39:18 <dons> int-e, no?
23:39:38 <int-e> dons: http://int-e.home.tlink.de/haskell/DeBruijn2.hs
23:39:42 <lambdabot> http://tinyurl.com/un5e8
23:40:21 <xnito> >take 30 sprimtes where sprimes =  1 : nubBy (\x y->y `rem` x == 0) [2..]
23:40:27 <dons> int-e: nice.
23:40:33 <xnito> whoops
23:40:33 <Botty> @pl \x -> x `mod` 2 == 0
23:40:34 <dons> xnito: leading space, > take ..
23:40:34 <lambdabot> (0 ==) . (`mod` 2)
23:40:48 <dons> > take 30 sprimtes where sprimes =  1 : nubBy (\x y->y `rem` x == 0) [2..]
23:40:49 <lambdabot>  Parse error
23:41:02 <int-e> dons: it's fast, too. faster than HOAS for Lennart's test case.
23:41:08 <dons> and its expressions only, so no 'where' clauses
23:41:18 <xnito> >take 30 sprimes where sprimes =  1 : nubBy (\x y->y `rem` x == 0) [2..]
23:41:22 <dons> > let primes = 1 : nubBy (\x y->y `rem` x == 0) [2..] in take 30 primes
23:41:24 <lambdabot>  [1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,10...
23:41:38 <dons> ?pl \x y->y `rem` x == 0
23:41:39 <lambdabot> flip flip 0 . ((==) .) . flip rem
23:41:59 <dons> > let primes = 1 : nubBy (flip flip 0 . ((==) .) . flip rem) [2..] in primes
23:42:00 <lambdabot>  [1,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,10...
23:42:00 <Botty> ?hoogle (a->Bool) -> [a] -> ([a],[a])
23:42:02 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
23:42:02 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
23:42:02 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
23:42:27 <dons> int-e, hmm!
23:42:44 <Botty> > partition (0 ==) . (`mod` 2) [1..]
23:42:45 <lambdabot>  Couldn't match `a1 -> [a]' against `[a2]'
23:42:54 <dons> missing $
23:43:01 <Botty> > partition (0 ==) . (`mod` 2) $ [1..]
23:43:02 <lambdabot>  add an instance declaration for (Integral [a])
23:43:17 <dons> (`mod` 2) [1.] ?
23:43:27 <dons> is that a map ?
23:43:39 <dons> ah, i see.
23:43:41 <Botty> > partition . (0 ==) . (`mod` 2) $ [1..]
23:43:43 <lambdabot>  Couldn't match `a -> Bool' against `Bool'
23:43:47 <dons> > partition ((0 ==) . (`mod` 2)) [1..]
23:43:48 <lambdabot>  ([2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
23:45:07 <xnito> ?hoogle
23:45:07 <lambdabot> HOOGLE - Haskell API Search
23:45:08 <lambdabot> (C) Neil Mitchell 2004-2006, York University, UK
23:45:08 <lambdabot>  
23:45:37 <Botty> > let foo = partition . (0 ==) . (`mod` 2) $ [1..] in zip (fst foo) (snd foo)
23:45:39 <lambdabot>  Couldn't match `a -> Bool' against `Bool'
23:45:55 <dons> let foo = partition ((0 ==) . (`mod` 2)) [1..] in zip (fst foo) (snd foo)
23:45:57 <Botty> > let foo = partition ((0 ==) . (`mod` 2)) $ [1..] in zip (fst foo) (snd foo)
23:45:59 <lambdabot>  [(2,1),(4,3),(6,5),(8,7),(10,9),(12,11),(14,13),(16,15),(18,17),(20,19),(22,...
23:46:15 <Botty> > let foo = partition ((0 ==) . (`mod` 2)) $ [1..] in zip (snd foo) (fst foo)
23:46:17 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21,...
23:46:45 <satan> how would i define a datatype that was isomorphic to another datatype?
23:47:11 <dons> by writing: data T = ... :) fill in the .'s
23:47:29 <satan> haha
23:47:55 <dons> well, wouldn't you just show that there's a bijectoin between the inhabitants of the type?
23:48:03 <satan> i guess i should ask what it means for one datatype to be isomorphic to another?
23:48:10 <dons> see above :)
23:48:14 <satan> right
23:48:46 <satan> and by show, you mean prove that this bijection exists? that they're 1 to 1
23:49:03 <dons> type MyMaybe a = (Bool, a)  <~>  data Maybe a = Nothing | Just a, yeah, establish the bijection, and in the presence of seq and bottom.
23:49:21 <dons> so proceed by induction of the types structure
23:49:27 <satan> seq?
23:50:02 <dons> yeah, so if you're tricky with seq you can distinguish two types that appear isomorphic
23:50:22 <dons> (exercise for the reader)
23:50:31 <satan> er what is seq?
23:50:51 <dons> oh, the 'strict' function, which forces its first argument , before returning the second
23:50:58 <dons> > undefined `seq` 7
23:51:00 <lambdabot>  Undefined
23:51:25 <satan> i see, thanks, i'll try that
23:53:42 <xerox> > ap (zip . snd) fst (partition ((0 ==) . (`mod` 2)) [1..])
23:53:43 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21,...
23:53:50 <xerox> yarr.
23:54:53 <Botty> nice
23:55:13 <xerox> FSVO nice (:
23:55:41 <xerox> > [(x,x+1) | x <- [1,3..]]
23:55:42 <xnito> ?hoogle ap
23:55:42 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21,...
23:55:43 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
23:55:43 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
23:55:43 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
23:55:52 <xerox> :X
23:55:54 * Botty wonders if my generated meaning for FSVO, For Sure, Very Obviously, is correct
23:56:06 <int-e> dons: oh, do you have any idea what that Misc module is that Lennart uses?
23:56:09 <xerox> (For Some Values Of)
23:56:24 <xerox> int-e: where is this Lennart LC stuff?
23:56:26 <Botty> oh
23:56:33 <dons> http://programming.reddit.com/info/qnir/comments
23:56:36 <lambdabot> Title: Write 4 lambda calculus interpreters in Haskell in 40 minutes [pdf] (reddit.com), http://tinyurl.com/yzyy4n
23:56:41 <int-e> http://www.augustsson.net/Darcs/Lambda/
23:56:44 <lambdabot> Title: Index of /Darcs/Lambda
23:56:56 <dons> Misc?
23:57:02 <dons> I don't see it in the src
23:57:17 <dons> oh hmm.
23:57:21 <dons> maybe he forgot to record?
23:57:54 <dons> @tell lennart The lambda modules import Misc, but Misc.lhs isn't in the darcs repo? http://www.augustsson.net/Darcs/Lambda/
23:57:54 <lambdabot> Consider it noted.
23:59:05 <xerox> Is this English? “It also exports a simple type if identifiers that parse and print in a nice way.”
23:59:44 <Botty> fractured english
