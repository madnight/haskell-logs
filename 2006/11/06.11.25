00:00:31 <lispy> emu: if you get desparate you can supply -prof in the ghc-options
00:00:36 <lispy> desperate
00:00:53 <dons> there's a long form for executabe binaries
00:00:58 <dons> ./Setup.lhs --help
00:01:17 <dons>  runhaskell Setup.lhs configure --help
00:01:27 <dons> Ã¨  -p       --enable-library-profiling      Enable library profiling
00:01:27 <dons>            --disable-library-profiling     Disable library profiling
00:01:27 <dons>            --enable-executable-profiling   Enable executable profiling
00:01:27 <dons>            --disable-executable-profiling  Disable executable profiling
00:01:35 <emu> oo
00:01:53 <emu> see i was trying to read the cabal manual, silly me
00:03:15 <lispy> emu: yeah, the manually is okay at documenting .cabal files, but it's a bit lacking in other dimensions
00:03:23 <lispy> s/manually/manual/
00:03:31 * lispy wonders how me makes typos like that so often
00:03:41 <emu> Dynamic linking required, but this is a non-standard build (eg. prof).
00:04:18 <emu> that's with both lib and exe profiling enabled
00:11:30 <Svrog> how hard is it to build ghc under windows so it dynamically links against gmp?
00:12:53 <Svrog> and same question for linux (unless it already does that under linux?)
00:13:41 <lispy> Svrog: dynamic linking is a touchy subject with ghc
00:14:22 <Svrog> hmm
00:18:48 <emu> on linux it dynamically links to gmp
00:18:49 <emu> it has to
00:19:00 <Svrog> ah
00:19:02 <Svrog> cool
00:19:24 <emu> sigh, i dunno what is up with this profiling thing
00:20:12 <lispy> ghc: 1, emu: 0, :(
00:21:24 <Svrog> according to this: http://hackage.haskell.org/trac/ghc/wiki/ReplacingGMPNotes dynamic libs are distributed only for os x
00:21:27 <lambdabot> Title: ReplacingGMPNotes - GHC - Trac, http://tinyurl.com/vrtqn
00:21:37 <emu> whoa
00:21:40 <emu> might have worked manually
00:22:45 <Svrog> and it says most distributions of ghc use static libs - so i guessed that was the case for linux too? at least regarding gmp
00:23:27 <emu> my binaries link gmp dynamically.  haskell libs are static though
00:23:42 <Svrog> ah
00:23:44 <Svrog> cool
00:26:41 <int-e> @users
00:26:42 <lambdabot> Maximum users seen in #haskell: 276, currently: 247 (89.5%), active: 17 (6.9%)
00:27:10 <emu> so after i built it, i was able to do ghc -prof --make manually
00:27:12 <emu> weird
00:27:14 <emu> anyhow!
00:27:36 <emu> time to determine whether SerTH, or my weird graph building algo, is at fault
00:43:57 <Svrog> http://eric_rollins.home.mindspring.com/haskellAnt.html
00:43:59 <Svrog> interesting
00:43:59 <lambdabot> Title: Multi-Core Ant Colony Optimization for TSP in Haskell, http://tinyurl.com/yxy3md
00:59:46 <dons> not found?
01:00:18 <dons> nope .works. weird
01:00:19 <Svrog> ?
01:00:37 <Svrog> the link?
01:00:51 <dons> any date on that article? looks interesting
01:00:54 <dons> must be fairly new?
01:01:18 <Svrog> yeah it seems interesting - no idea about the date
01:01:21 <Svrog> i only just found it
01:01:43 <dons> the MLton numbers seem suspiciously good
01:01:54 <dons> like the haskell one was implemented wrongly, or ml is cheating
01:02:07 * dons should read more first
01:02:21 <Svrog> i assumed it's cause the ghc code hasnt been optimized
01:02:42 <dons> yeah, seems so
01:02:45 <Svrog> the page about erlang compares all 3, ghc, erland and mlton
01:02:46 <Svrog> http://eric_rollins.home.mindspring.com/erlangAnt.html
01:02:48 <lambdabot> Title: Multi-Core Ant Colony Optimization for TSP in Erlang, http://tinyurl.com/y3zxsm
01:02:58 <Svrog> erlang appears to scale better
01:03:14 <Svrog> but not surprisingly it's pretty slow
01:05:38 <dons> oh could be sometime in the last year, it refers to GHC 6.5
01:05:48 <Svrog> maybe
01:06:10 <dons> the guy seems not to know how to do destructive updates in haskell
01:06:46 <dons> interesting, anyway
01:06:49 <Svrog> yup
01:07:33 <dons> i wish these guys would ask on haskell-cafe@
01:07:51 <dons> when people try things like this, its useful for us to find out how they go, and what their issues are
01:09:32 <Korollary> is the article still up?
01:09:44 <Korollary> http://eric_rollins.home.mindspring.com/erlangAnt.html
01:09:46 <lambdabot> Title: Multi-Core Ant Colony Optimization for TSP in Erlang, http://tinyurl.com/y3zxsm
01:09:49 <dons> seems so
01:09:53 <Korollary> dang. I can't resolve it.
01:09:56 <dons> (at least in the proxy..)
01:10:01 <dons> i can't bring it up either
01:10:08 <dons> let me grab it from the unsw proxy...
01:10:47 <dons> http://www.cse.unsw.edu.au/~dons/tmp/haskellAnt.html
01:10:48 <lambdabot> Title: Multi-Core Ant Colony Optimization for TSP in Haskell, http://tinyurl.com/ycfhut
01:12:16 <Korollary> thanks
01:13:03 <tibbe> I've read a few explanations of closures now that refer to high-order functions as closures, isn't the function required to actually capture a variable for it to be a closure?
01:13:05 <Svrog> i think the thing with sml and caml is that its easier to get naively written code to run well
01:13:42 <Korollary> Well, from our experience in the shootouts, I can say that intuitively it's harder than usual to get a feeling of how fast your haskell implementation of something is. You can't expect most people to hack something up easily.
01:14:12 <Svrog> yeah
01:15:09 <dons> tibbe: yeah, capturing the local environment is the essence
01:15:58 <dons> Svrog, Korollary: yeah. getting easier though. strict strings remove a lot of the issues that newbies encounter
01:16:04 <dons> so i'm hopeful
01:16:24 <dons> since then we behave like clean
01:17:07 <Korollary> well, when they use strict strings, they still don't get the right feeling.
01:17:35 <Korollary> it just delays their confusion
01:18:01 <Korollary> are there any benchmarks for the Data.Sequence stuff?
01:21:10 <Svrog> strict strings?
01:21:23 <dons> ?where fps
01:21:23 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
01:21:30 <Svrog> ooh
01:21:36 <dons> (in Data.ByteString with ghc 6.6)
01:21:41 <Svrog> oh
01:21:42 <Svrog> cool
01:22:03 <tibbe> > let threshold = 150 in filter (x > threshold) [100,200,300]
01:22:04 <lambdabot>  Not in scope: `x'
01:22:11 <tibbe> > let threshold = 150 in filter (\x -> x > threshold) [100,200,300]
01:22:13 <lambdabot>  [200,300]
01:22:20 <tibbe> is the lambda there a closure?
01:22:23 <Korollary> yes
01:22:51 <tibbe> > filter (\x -> x > 150) [100,200,300]
01:22:53 <lambdabot>  [200,300]
01:22:59 <tibbe> but there it's not?
01:23:04 <dons> > let threshold = 150 ; f x = x > threshold in filter f [100,200,300] -- more obviously?
01:23:05 <lambdabot>  [200,300]
01:23:25 <dons> tibbe: well its still bound its local environment , it just the empty env
01:23:41 <dons> its all closures in haskell
01:23:43 <Korollary> tibbe: actually, any lambda is a closure.
01:23:49 <tibbe> but then everything is a closure?
01:24:06 <tibbe> ok
01:24:22 <Korollary> In other laguages, some primitives like numbers are not.
01:25:09 <Korollary> but haskell has to have closures for everything for laziness
01:25:17 <tibbe> I'm reading a Martin Fowler article where he explains closures and I read it as if he thinks everything is a closure
01:25:47 <tibbe> def managers(emps)
01:25:47 <tibbe> 	return emps.select {|e| e.isManager}
01:25:47 <tibbe> end
01:25:56 <tibbe> is the block a closure here?
01:26:18 <Korollary> that looks like it
01:27:04 <Korollary> wait, is that the lambda syntax of ruby?
01:27:09 <tibbe> yes
01:27:19 <tibbe> \e
01:27:27 <Korollary> ok, the block is a closure with an empty env
01:28:11 <tibbe> but then everything is a closure?
01:28:12 <Svrog> so ByteStrings are preferable to PackedStrings?
01:28:29 <dons> PackedStrings are worse than [Char]
01:28:34 <Svrog> wow
01:28:38 <Korollary> tibbe: as I said, it depends on the language. For some languages, you can define some values to be primitives other than closures.
01:28:55 <tibbe> hmm
01:29:21 <Svrog> are PackedStrings then pretty much completely useless?
01:29:23 <tibbe> there's no need for any heap allocation in that example
01:29:33 <dons> Svrog: yes.
01:29:36 <Svrog> haha
01:29:40 <dons> :) they're deprecated now
01:29:46 <dons> and will be replaced with unicode bytestrings
01:29:52 <Svrog> cool - ill use ByteStrings then hehe
01:30:12 <tibbe> how's unicode coming along?
01:30:30 <Korollary> tibbe: I am guessing that block is heap allocated before it's passed to emps.select.
01:32:40 <tibbe> Korollary: but does it need to do that? it looks like it could just use a function pointer
01:32:52 <tibbe> (if it where compiled that is)
01:32:57 <Svrog> dons: how do you convert a CString to a ByteString? do you have to convert it to a String first or is there a more direct approach?
01:33:19 <Svrog> oh
01:33:20 <Svrog> n/m
01:33:23 <Svrog> just found it in the docs
01:33:25 <Svrog> heh
01:33:32 <Svrog> packCString
01:33:33 <Svrog> heh
01:33:35 <Svrog> cool :)
01:34:37 <dons> never convert to String :)
01:34:52 <Korollary> tibbe: if isManager is a closure as well (possibly taking a hidden self arg), you could probably pass that directly without allocating a new closure. I don' know really.
01:34:56 <Svrog> hehe
01:35:47 <tibbe> Korollary: I would guess isManager is just a regular virtual method
01:58:19 <goltrpoat> wow.  #haskell.ru is happenin.
01:58:27 <russo_> sweet
01:58:31 <russo_> theres a russian haskell channel :D
01:58:44 <russo_> aww
01:58:48 <goltrpoat> hehe
01:58:51 <goltrpoat> in a manner of speaking.
01:58:51 <russo_> i'm the only one there :(
01:59:12 <russo_> so manny russian haskell programmers... so little in #haskell.ru
01:59:38 <goltrpoat> hmm.. the only russian haskell programmer i know of is bulat
02:00:11 <goltrpoat> for a suitably loose definition of 'russian'
02:00:32 <goltrpoat> since his name sounds tatar, i think
02:21:20 <goltrpoat> realized the other day that no one seems to have written a raytracer or a photon tracer in haskell, and it seems like it's borderline perfect for that.  things like csg operations and brdfs and get rather pretty
02:21:42 <goltrpoat> think i might throw something together and post it as a paper or a tutorial or just put it in darcs and let people hack on it
02:22:01 <fourbissime> Hi there. I'm trying to learn haskell right now but I feel like I always miss something. I saw there are a few books on haskell and I feel like getting one. So i'm here to ask : which one would you suggest ?
02:22:56 <goltrpoat> hmm.. i thought 'the road to logic, maths and programming' was great, but then i loaned it to someone and they said that it was the worst textbook they've ever read, in terms of presentation
02:23:00 <lispy> istr, school of expression being highly rated
02:23:13 <goltrpoat> SoE is quite good, yeah
02:23:36 <fourbissime> okay good !
02:23:43 <tibbe> goltrpoat: someone I know wrote a small ray tracer during as a course project, dunno if it was any good
02:24:00 <tibbe> s/as/
02:24:19 <tibbe> (yes that's an empty string)
02:24:24 <goltrpoat> hehe
02:27:30 <Lemmih> fourbissime: 'The Craft of Functional Programming' is also good.
02:29:13 <goltrpoat> tibbe:  i was thinking something that's not quite a toy, but not quite a shippable product either -- primitives, csg operations, a brdf interface, xml scene description, stochastic sampling, etc.
02:29:42 <goltrpoat> would prolly need to break some stuff out into C to make it usable, not planning on that though
02:30:14 <lispy> goltrpoat: shaders?
02:30:24 <goltrpoat> well, i was lumping that into the brdf interface
02:30:37 <lispy> ah okay, i'm not really up on the terminology
02:31:10 <lispy> but i did help write a ray tracer in lisp once, in a past life
02:31:17 <goltrpoat> ah cool
02:34:02 <fourbissime> thanks for the tip guys. bye.
02:34:13 <lispy> bye
02:37:04 <Svrog> ?pl (\x y z -> (x, y, z))
02:37:04 <lambdabot> (,,)
02:37:08 <Svrog> lol
02:37:11 <Svrog> nice
02:37:45 <lispy> it generallizes
02:37:58 <lispy> > (,,,,,) 1 2 3 4 5 6
02:38:00 <lambdabot>  (1,2,3,4,5,6)
02:38:35 <lispy> > zipWith3 (,,) [1..4] [5..8] [9..12[
02:38:36 <lambdabot>  Parse error
02:38:37 <lispy> > zipWith3 (,,) [1..4] [5..8] [9..12]
02:38:39 <lambdabot>  [(1,5,9),(2,6,10),(3,7,11),(4,8,12)]
02:40:33 <tibbe> haskell has great obfuscation potential
02:44:32 <Svrog> code strictly using combinators could be more easily represented in graphical form - think lego bricks or circuits or little engines built of many other smaller parts put together
02:44:38 <goltrpoat> i remember going on a brief pointfree kick shortly after starting to learn haskell, and then making the mistake of trying to reuse that codebase
02:45:14 <goltrpoat> and spending a couple of hours figuring out what about 5 functions did.  pencil and paper and all.
02:45:27 <Svrog> it takes some time getting used to it
02:46:37 <goltrpoat> well, it was stuff like.. (.) . (fst .)
02:47:04 <goltrpoat> i'm sure there are people who can read that, but i probably never will find that easier to read than the pointful version
02:47:51 <goltrpoat> er.  i guess i should say 'im sure there are people who can read that *easily*'
02:48:06 <lispy> yeah "(foo .) . baz" is really hard for me to read
02:48:08 <Svrog> how's this for obfuscated: |._31]\,(,~"1,])^:4,:'* '
02:48:17 <lispy> Svrog: perl?
02:48:19 <Svrog> that's j code to print a sierpinski triangle :)
02:48:46 <goltrpoat> note to self:  avoid j at all costs
02:48:47 <goltrpoat> haha
02:48:52 <lispy> $ perl
02:48:52 <lispy> |._31]\,(,~"1,])^:4,:'* '
02:48:52 <lispy> syntax error at - line 1, near "|"
02:48:52 <goltrpoat> jk, been meaning to check it out
02:48:53 <Svrog> j is much cooler than perl - not from the point of view of being more obfuscated - but it's actually a very interesting language
02:48:58 <lispy> seems to not be perl :)
02:49:44 <Svrog> i found this recently when going through j mailing lists - they were competing who can write the shortest program to print the triangle
02:49:54 <opqdonut> J is a great language
02:49:59 <Svrog> yes
02:50:10 <Svrog> i only just started learning it
02:50:10 <opqdonut> shame the implementation seems a bit closed
02:50:15 <Svrog> yeah
02:50:16 <opqdonut> and installing on linux didn't work for me
02:50:36 <opqdonut> an open-source clone shouldn't be hard to implement, i'd say
02:50:55 <opqdonut> a fast one might be a challenge, but a naive implementation should be easy
02:51:04 <goltrpoat> i was rather excited about strongtalk
02:51:07 <Svrog> ive heard implementing array languages is quite tricky - dunno though - never tried writing one
02:51:22 <goltrpoat> but the environment randomly crashed on me about 5 times in a row while doing something rather innocuous
02:51:24 <goltrpoat> so i gave up
02:52:04 <goltrpoat> i hope someone comes up with something along those lines that's actually stable at some point
02:52:23 <opqdonut> Svrog: me neither, i've only implemented a small subset of scheme/lisp
02:53:52 <dons> goltrpoat: re. raytracers: http://haskell.org/haskellwiki/Libraries_and_tools/Graphics#Ray_Tracing
02:53:55 <lambdabot> Title: Libraries and tools/Graphics - HaskellWiki, http://tinyurl.com/y5jm5k
02:54:08 <goltrpoat> oy.
02:54:12 <goltrpoat> how'd i miss that
02:55:05 <Svrog> i just got Could not find module `System.Console.Readline' when compiling ghc
02:55:14 <dons> its in package readline
02:55:23 <dons> add --make or -package readline to the command line
02:55:41 <Svrog> but im getting this when im trying to rebuild ghc
02:55:51 <Svrog> it's been compiling for 3 hours now and it just failed :(
02:55:55 <dons> oh, on the mac?
02:55:58 <Svrog> yes
02:56:02 <goltrpoat> actually, i guess that's fine.  they look like they either have smaller scope, or pursue different goals
02:56:13 <dons> you need to make sure that it can find the readline lib
02:56:19 <dons> the Mac ghc wiki page talks about this
02:56:23 <Svrog> oh
02:56:36 <Svrog> hopefully i wont have to compile everything from the beginning..
02:56:48 <dons> don't think so
02:57:49 <dons> Svrog: http://hackage.haskell.org/trac/ghc/wiki/X86OSXGhc
02:57:51 <lambdabot> Title: X86OSXGhc - GHC - Trac, http://tinyurl.com/fnmrx
02:57:57 <dons> (mac details for readline there, iirc)
02:58:01 <Svrog> ah
02:58:03 <Svrog> thanks :)
02:58:43 <goltrpoat> sidenote:  i don't know how i missed this either, but it's cool as hell.  http://www.mathbin.net/
03:00:07 <Svrog> does code compiled with ghc need readline? or just ghc itself?
03:01:02 <lispy> ?where+ mathbin http://www.mathbin.net/
03:01:03 <lambdabot> Done.
03:01:09 <lispy> ?where+ mathpaste http://www.mathbin.net/
03:01:09 <lambdabot> Done.
03:01:35 <lispy> ?localtime lispy
03:01:37 <lambdabot> Local time for lispy is Sat Nov 25 02:58:12 2006
03:01:39 <lispy> arg!
03:01:42 <lispy> ?yar
03:01:43 <lambdabot> Prepare to be boarded!
03:01:43 <dons> Svrog: only ghci
03:01:56 * lispy fades into the ether
03:03:07 <Svrog> ah
03:19:59 <dons> hand me some TYPES for this COMONAD!
03:20:04 <dons> ?yow
03:20:05 <lambdabot> Your CHEEKS sit like twin NECTARINES above a MOUTH that knows no BOUNDS --
03:20:36 <_matthew-> mmm. interesting
03:22:50 <goltrpoat> this UNIVERSAL QUANTIFIER is DISAPPOINTING my great-grand-UNCLE
03:22:58 <goltrpoat> k, i wouldn't make a good zippy.
03:23:43 <opqdonut> @yow
03:23:44 <lambdabot> ... bleakness ... desolation ... plastic forks ...
03:23:48 <opqdonut> @yow
03:23:49 <lambdabot> An Italian is COMBING his hair in suburban DES MOINES!
03:23:51 <Philippa_> 'lo goltrpoat
03:23:54 <goltrpoat> hey philippa
03:24:33 <goltrpoat> what are you doing these days, anyway.  haven't seen you in a while.
03:25:43 <Philippa_> Mostly the same old lack of career. Other news in PM, as it's largely way off-topic
03:26:25 <goltrpoat> lack of career.. you didn't end up going for a phd?
03:26:31 <Philippa_> I never graduated
03:26:43 <goltrpoat> ah
03:33:44 <goltrpoat> oh, so i don't know if you remember or not, you recommended TAPL and ATTPL to me a while back, finally got around to getting them (in other words, finally got to the point where i figured i'd make sense of them)
03:33:48 <goltrpoat> awesome stuff.
03:33:55 <goltrpoat> went through TAPL like a novel, heh.
03:38:36 <Svrog> never graduated? a uni dropout?
03:38:45 <Philippa_> I've not technically dropped out yet either
03:38:53 * Svrog is a uni dropout
03:38:54 <Svrog> hehe
03:53:15 <araujo> morning!
04:08:08 <lisppaste2> metaperl annotated #30573 with "type error - help needed" at http://paste.lisp.org/display/30573#8
04:09:42 <metaperl> araujo - good morning
04:10:17 <xerox> alpha_number_word doesn't return a list, metaperl.
04:10:52 <metaperl> xerox but I want to iterate over each word generated by (words phrase)
04:10:55 <xerox> breakdown = [ (w,alpha_number_word w) |  w <- words phrase] ?
04:11:08 <metaperl> oh
04:11:09 <metaperl> :)
04:11:42 <araujo> hello metaperl
04:11:50 <metaperl> hi
04:13:03 <araujo> [ (w,alpha_number_word w) |  w <- words phrase ]
04:13:06 <araujo> probably that?
04:13:48 <metaperl> yeah - thats it... you didnt see xerox's comment above? your's is a sptting image :)
04:14:11 <Cale> "With the money I saved I can buy more old computers to make my wife even angrier." -- haha
04:14:25 <Cale> http://clintonforbes.blogspot.com/2006/11/review-17-macbook-pro-vs-cambridge-z88.html
04:14:27 <lambdabot> Title: The rantings of Clinton Forbes: Review: 17" MacBook Pro vs Cambridge Z88, http://tinyurl.com/ykqgva
04:14:29 <araujo> metaperl, hah i didn't :-)
04:14:34 <Cale> (sort of funny)
04:14:35 <metaperl> how to get the 3rd element of a 3-tuple
04:14:49 <xerox> (\(_,_,x) -> x)
04:14:58 <metaperl> oh
04:15:41 <goltrpoat> you may want to use type annotations rather liberally
04:16:11 <goltrpoat> errors have a tendency of manifesting themselves pretty far from the problem site otherwise
04:16:43 <Philippa_> I need to write an H-M implementation that does type slicing sometime
04:17:01 <Philippa_> that can get you the minimum conflicting set of constraints, and thus highlight where the problem likely actually is
04:17:18 <Philippa_> you can, incidentally, more or less run the same thing by hand with an ordinary typechecker - it's just damn tedious
04:18:23 <goltrpoat> type slicing?
04:18:26 <Svrog> hi Cale
04:18:39 <Cale> hello
04:18:50 <Svrog> -> monad instance rocks :)
04:20:30 <Cale> It does :)
04:21:11 <Philippa_> goltrpoat: you're prolly best googling it for now, I need that breakfast :-) Will get back to you if you don't find anything though
04:21:53 <goltrpoat> yeah, took some time to find a link
04:22:11 <goltrpoat> dinesh has a paper that seems to talk about exactly that
04:22:53 <metaperl> is there a built-in function to uppercase characters?
04:23:23 <astrolabe> @type toUpper
04:23:24 <lambdabot> Char -> Char
04:23:31 <metaperl> astrolabe thanks
04:24:02 <goltrpoat> oh.. so basically, for a particular assumption, we figure out what relies on that assumption, compute the intersection of the result when one or more are violated, and find the "smallest" element by whatever metric?
04:24:48 <Philippa_> yeah, where the metric is the set of constraints from which we can infer the rest
04:24:55 <goltrpoat> gotcha
04:25:02 <lisppaste2> metaperl annotated #30573 with "uppercase a string on the fly... how to?" at http://paste.lisp.org/display/30573#9
04:25:02 <goltrpoat> that's pretty cool.
04:25:06 <Philippa_> which translates to the smallest number of use sites and/or definitions
04:25:29 <xerox> metaperl: map toUpper :: String -> String
04:26:15 <metaperl> oh, so instead of c <- w  ... I would do c <- map toUpper w
04:26:51 <metaperl> beautiful. thanks
04:26:55 <twanvl> or c <- w, let c' = toUpper c
04:27:11 <metaperl> a let in a list comp? never knew about that
04:28:10 <goltrpoat> are you sure you want breakdown to be a list of tuples, btw
04:28:22 <metaperl> goltrpoat as opposed to?
04:28:39 <goltrpoat> the first elements of breakdown are not used anywhere
04:28:53 <goltrpoat> (in alpha_number_word i mean)
04:29:14 <metaperl> they are a form of diagnosis... they show the mapping that was used in the final sum...
04:29:46 <metaperl> A book I am reading has a mapping from letters to numbers and I want to show the intermediate mappings as well as the final sum
04:29:58 <goltrpoat> oh i see, so there is a point to this :)  just checking.
04:30:11 <metaperl> :)
04:30:31 <metaperl> goltrpoat - that is an unusual name... what does it mean?
04:30:57 <astrolabe> goltrpoat: could you tell me the type-slicing link you found please?
04:31:07 <xerox> Hiya labe.
04:31:14 <astrolabe> wotcha
04:35:55 <goltrpoat> astrolabe:  http://citeseer.ist.psu.edu/dinesh98slicingbased.html
04:35:58 <lambdabot> http://tinyurl.com/vxnoq
04:37:15 <goltrpoat> not exactly H-M, but what philippa said sort of clicked after i read the first paragraph
04:39:17 <xerox> Jeez.  How do you fiddle with the implementation of type checking in Pascal?  Free Pascal compilers?
04:40:37 <goltrpoat> they used this:  http://citeseer.ist.psu.edu/438475.html
04:41:32 <goltrpoat> and im guessing there either was an open source implementation of that last paper somewhere, or someone took a month off and wrote one
04:44:49 <Philippa_> goltrpoat: someone's done it for H-M as well
04:45:48 <goltrpoat> yeah, it certainly seems like a cleaner and more useful concept in H-M
04:46:34 <Philippa_> http://citeseer.ist.psu.edu/haack04type.html
04:47:06 <goltrpoat> oh thanks
04:47:42 <Philippa_> though it's based on Damas' approach which types the same things as H-M but uses intersection types rather than universal quantification internally
04:47:55 <goltrpoat> i wrote a proof of concept typechecker a little while back, been meaning to combine that with the other language stuff ive been doing on the side and turn it into something semi-useful
04:51:03 <goltrpoat> one idea was a referentially transparent functional OO language, where records (sufficiently decrippled) are more or less a central concept, and methods are implicitely in a state monad of sorts
04:51:14 <Philippa_> I keep meaning to do all kinds of language-related stuff. Including getting GHC working on my Zaurus and perhaps getting a nice keyboard to use with it so I can hack in bed instead of just thinking about it
04:51:35 <Philippa_> *nod* - I'd considered using something like that as the foundation for an object-capability-based wiki
04:54:25 <goltrpoat> one nice thing about the idea is that it sort of translates into cardelli's agent stuff, if a decent solution can be obtained for distributed typeclass dictionaries
04:55:08 <goltrpoat> ("translates" = "gets rid of all the ugly stuff")
04:55:13 <lisppaste2> metaperl annotated #30573 with "I need to get expected type versus inferred type nailed down once and for all" at http://paste.lisp.org/display/30573#10
04:56:04 <Philippa_> assuming they're held immutable, "everyone gets a copy" should be good enough
04:56:10 <Philippa_> or at least, everyone who cares
04:56:14 <goltrpoat> well, the problem is with "everyone gets a copy"
04:56:24 <goltrpoat> imagine a new site goes online, with a new instance
04:57:29 <goltrpoat> so now the new site's context for that class holds that new instance, and everyone else's holds another instance.  without something looser, you can't just pass an agent along from the new site, until you've propagated the new context to everyone else
04:58:02 <araujo> @type (toUpper . head)
04:58:04 <lambdabot> [Char] -> Char
04:58:09 <araujo> metaperl, ^^
04:58:42 <metaperl> @type filter
04:58:44 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
04:58:52 <goltrpoat> so one issue is that it's easiest to do this through a central repository -- but if that goes online, then we'd like to be able to function to some extent.  ideally, you'd pretend everything is existentially quantified until the nameserver comes back up.
04:58:53 <araujo> filter is returning [(Char, Int)]
04:59:02 <goltrpoat> er.  online = offline
04:59:20 <metaperl> oh
04:59:41 <metaperl> how do you know which type is expected and which is inferred?
05:01:29 <metaperl> oic
05:02:20 <metaperl> it says In the second argument of ($), namely filter .... therefore it inferred the type of that second argument... but the next thing in the chain had different expectations!
05:02:31 <araujo> yes
05:03:25 <goltrpoat> the inferred type is what would make that particular subexpression kosher -- i.e. the least constrained type for that subexpression, taking it on its own.  the expected type is what is expected due to the type signature of something that the subexpression is used with.
05:03:45 <metaperl> yes
05:03:48 <goltrpoat> eg: in "a" ++ 'a', the inferred type of the offending subexpression is Char, the expected type is [Char]
05:04:03 <metaperl> spoken like a true scholar
05:04:06 <metaperl> :)
05:04:10 <goltrpoat> heh
05:05:40 <goltrpoat> (to take it further, (++) :: [a] -> [a] -> [a], the type of "a" is [Char], so (++) "a" :: [Char] -> [Char], hence expected type [Char])
05:06:46 <metaperl> you are correct, but you overused a... choose a different string when giving an example. "cat" "dog" or something like that a and "a" in the same discussion can be confusing
05:07:11 <metaperl> [a] and "a" are different but not different enough ... [a] and "dog" is better
05:07:30 <goltrpoat> does (++) :: [sometype] -> [sometype] -> [sometype] work for you? :)
05:07:44 <metaperl> it has to be [Char]
05:07:53 <metaperl> @type (++)
05:07:54 <lambdabot> forall a. [a] -> [a] -> [a]
05:07:57 <goltrpoat> sometype is the tyvar
05:08:02 <metaperl> yes
05:08:15 <metaperl> and "a" is a strng, but it loks too similar to the var
05:08:29 <goltrpoat> bah.
05:08:40 <metaperl> dozen = 13
05:08:46 <metaperl> 2 * dozen = 26
05:08:51 <metaperl> yes, but no at the same time
05:08:58 <goltrpoat> surely we can tell the difference between strings in the body of the function, and tyvars in a signature of a different function.
05:09:18 <metaperl> yes, but ... never mind
05:13:18 <goltrpoat> philippa:  anyway, it seems that the more interesting type systems have issues with RPC-style scenarios
05:13:38 <goltrpoat> either you have to pass the whole dictionary with each closure, which seems wasteful to say the least
05:13:43 <goltrpoat> or you centralize it, and lose some of the benefits
05:13:56 <Philippa> you only have to do that on the face of things
05:14:20 <Philippa> you can eg centralised-ID it, so that you get passed the ID for a dictionary and grab it once and cache it
05:14:29 <goltrpoat> im sure there's some sort of hackery that can be done like caching dictionaries on each client etc
05:14:31 <goltrpoat> right
05:14:42 <Philippa> hell, doesn't have to be centralised as such, the ID can include an address for whatever's got the dictionary
05:15:08 <goltrpoat> and i guess then we just assume that whatever's doling out dictionaries is never going to go offline (that's what i meant by losing some of the benefits, you can't do peer to peer in a meaningful manner)
05:15:10 <Philippa> and all that stuff can be part of the evaluation mechanism rather than part of the language. So it can be pretty much invisible
05:15:31 <Philippa> sure you can. Just extend the ID to include eg a chain of known addresses that have had a copy
05:15:54 <goltrpoat> oh, point.
05:16:06 <goltrpoat> synchronizing that doesn't sound pleasant though.
05:16:20 <Philippa> you don't need to, you just need to know of at least one machine with a copy
05:16:34 <Philippa> odds are the machine that called you has one...
05:16:40 <goltrpoat> point #2.
05:17:13 <goltrpoat> yeah, the chain of known addresses is a good idea, hadn't thought of that.
05:17:41 <goltrpoat> i'm generally a little wary of not synchronizing this type of thing -- eventually everything in the chain will go offline
05:17:43 * EvilRanter is away: </here>
05:18:07 <Philippa> yeah, but at that point you've just lost the machine you're returning to as well
05:18:16 <Philippa> and hey, why haven't you got a copy yet?
05:18:29 <Philippa> surely that's the first thing you did when you were first given the chain?
05:18:45 <goltrpoat> well.. yes, but in cardelli's case, the machine that just cloned an agent on my machine, may not care about its lifetime
05:18:56 <goltrpoat> in fact, it may instantiate it and go offline immediately
05:19:12 <goltrpoat> but actually that seems solvable
05:19:27 <Philippa> dictionary passing becomes part of instantiation? :-)
05:19:32 <goltrpoat> yeah.
05:19:46 <goltrpoat> that's one way
05:20:17 <Philippa> oh yeah, you can avoid full sync while taking an interative approach: "here's the other machines I know about with a copy at time X" whenever you get pinged for a copy
05:20:23 <Philippa> iterative, even
05:20:53 <goltrpoat> another way is combining it with the id list, coming up with a partial graph and asking if the machine you're instantiating an agent on has a chain to an existing peer with the dictionary
05:21:26 <Philippa> *nod* - anyway, it's thoroughly attackable. Immutability sure as hell helps here
05:21:27 <goltrpoat> i guess there's always the chance someone goes offline during the roundtrip though.
05:21:37 <goltrpoat> yeah, you're right.
05:25:31 <goltrpoat> i guess my first thought while reading that paper was "it needs to be typed", my second thought was "pessimistic concurrency is going to kill this in a big project", and a couple of days later, fp+stm+... popped up
05:26:58 <goltrpoat> haven't thought about it a lot obviously, but it seems like it'd be a lot cleaner with something like what i described earlier
05:28:44 <Svrog> night
05:29:24 <goltrpoat> anyway, how the hell did we get here from H-M hackery
05:35:00 <Philippa> heh. I dunno, I should probably go do stuff though
05:35:06 <Philippa> need to leave the house in less'n'two hours
05:35:10 <goltrpoat> i should probably go to bed at some point.
05:35:30 <goltrpoat> cept i have a sudden urge to write a theorem prover as an EDSL.
05:35:42 <lisppaste2> metaperl annotated #30573 with "How do I know when to use ($)" at http://paste.lisp.org/display/30573#11
05:35:43 <goltrpoat> (in haskell obviously)
05:35:58 <metaperl> @type ($)
05:36:00 <lambdabot> forall b a. (a -> b) -> a -> b
05:36:42 <goltrpoat> metaperl:  what's the type of toUpper . head ?
05:37:13 <metaperl> @type toUpper
05:37:15 <lambdabot> Char -> Char
05:37:27 <metaperl> head returns the head of a list, no matter what type
05:37:31 <metaperl> why did you ask that?
05:38:37 <goltrpoat> the lhs of the $ is [Char] -> Char.  the rhs therefore needs to be [Char]
05:38:55 <goltrpoat> instead, it's [(Char, something)]
05:39:28 <metaperl> goltrpoat - not in the paste I just made: http://paste.lisp.org/display/30573#11http://paste.lisp.org/display/30573#11
05:39:30 <metaperl> http://paste.lisp.org/display/30573#11
05:39:31 <goltrpoat> f $ g x <==> f (g x)
05:39:44 <metaperl> that's different
05:39:49 <metaperl> i have f . g $ x
05:39:53 <goltrpoat> oh, i was looking at <lisppaste2> metaperl annotated #30573 with "How do I know when to use ($)" at http://paste.lisp.org/display/30573#11
05:40:01 <metaperl> and i wondered how that differed from f . g x
05:42:15 <tibbe> metaperl: someone already explained the difference to you?
05:42:28 <metaperl> no no one did
05:42:32 <twanvl> f . g $ x = (f . g) x = f $ g x = f (g x)    /=    f . g x = \y -> f (g x y)
05:43:08 <metaperl> ah!
05:43:10 <metaperl> thanks
05:44:05 <goltrpoat> f . g $ x means (f . g)(x).  eg, toUpper . head $ "hello" == 'H'.  f . g x means f . (g x), since application binds tighter.  so (toUpper . head [const 'x']) '?' == 'X'
05:45:33 <tibbe> so function application binds tigheter than function composition with .
05:45:51 <tibbe> so f . g x evaluates as (f) . (g x)
05:47:00 <goltrpoat> @type toUpper . head [const 'x']
05:47:02 <lambdabot> forall a. a -> Char
05:47:13 <metaperl> what is const?
05:47:29 <goltrpoat> @type const
05:47:30 <tibbe> \x -> \y -> x
05:47:31 <lambdabot> forall a b. a -> b -> a
05:47:41 <goltrpoat> ignores the b parameter and returns the a argument
05:47:47 <tibbe> ie gives you a function that always returns the same thing
05:47:50 <goltrpoat> > const 'x' 'y'
05:47:51 <tibbe> ---> constant
05:47:52 <lambdabot>  'x'
05:48:09 <metaperl> ah
05:48:45 <goltrpoat> but then:
05:48:51 <goltrpoat> > toUpper . head $ "hello world"
05:48:52 <lambdabot>  'H'
05:49:01 <goltrpoat> alternatively:
05:49:07 <goltrpoat> > (toUpper . head) "hello world"
05:49:09 <lambdabot>  'H'
05:49:20 <tibbe> I usually view $ as unix pipes
05:49:56 <tibbe> or something
05:50:20 <dcoutts> no, that's (.)
05:50:21 <lambdabot> dcoutts: You have 2 new messages. '/msg lambdabot @messages' to read them.
05:50:52 <tibbe> ah yes, . sorry
05:50:55 <tibbe> but from right to left
05:50:59 <dcoutts> yep
05:51:27 <tibbe> perhaps left to right would feel more natural to some
05:51:29 <dcoutts> @pl \f g x -> g (f x)
05:51:29 <lambdabot> flip (.)
05:52:33 <tibbe> let (..) = flip(.), f = head .. toUpper in f "hello world"
05:52:36 <tibbe> > let (..) = flip(.), f = head .. toUpper in f "hello world"
05:52:37 <lambdabot>  Parse error
05:52:50 <tibbe> > let (..) = flip(.); f = head .. toUpper in f "hello world"
05:52:50 <lambdabot>  Parse error
05:53:03 <tibbe> > let (..) = flip (.); f = head .. toUpper in f "hello world"
05:53:03 <lambdabot>  Parse error
05:53:17 <tibbe> ?#"#"Eªßð?¤®ðew
05:53:18 <lambdabot> Unknown command, try @list
05:53:24 <tibbe> @die
05:53:25 <lambdabot> unexpected end of input: expecting number
05:53:39 * tibbe surrenders to lambdabot
05:53:40 <goltrpoat> shouldn't that be a bug
05:53:41 <tibbe> white flag
05:53:48 <Lemmih> '..' is reversed.
05:53:52 <Lemmih> *reserved
05:53:53 <goltrpoat> > let operator = flip (.); f = operator head toUpper in f "hello world"
05:53:54 <lambdabot>  'H'
05:54:03 <goltrpoat> oh duh.
05:54:12 <Lemmih> > [1 .. 10] -- for lists.
05:54:14 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
05:55:03 <tibbe> > let (.|.) = flip (.); f = head .|. toUpper in f "hello world"
05:55:05 <lambdabot>  'H'
05:55:24 <goltrpoat> the old cock'n'balls combinator.
05:55:29 <tibbe> haha
05:57:29 <dcoutts> anyone want to help me write an intro Gtk2Hs tutorial? or help improve the new glade tutorial ?
05:57:47 <dcoutts> we're using txt2tags (much like wiki markup)
05:57:50 <dcoutts> and darcs
05:57:51 <tibbe> I would if I knew Gtk, Gtk2Hs and glade :)
05:57:58 <dcoutts> :-)
05:59:42 <dcoutts> http://haskell.org/gtk2hs/docs/tutorial/glade/
05:59:43 <lambdabot> Title: Gtk2Hs Â» Glade Tutorial, http://tinyurl.com/y8kq2f
05:59:58 <dcoutts> and sources:
06:00:00 <dcoutts> http://darcs.haskell.org/gtk2hs/docs/tutorial/
06:00:03 <lambdabot> Title: Index of /gtk2hs/docs/tutorial, http://tinyurl.com/te2yq
06:00:10 <goltrpoat> oddly enough, SPJ's 'implementing functional languages: a tutorial' paper is a remarkably fast way to get a lot of this intuitively.  i remember distinctly disliking the coding style in the paper, but i think that was due to some expositionary constraints (eg, not veering off on a tangent about transformers)
06:00:18 <tibbe> > let wc = length . lines in wc "hello\nworld\n"
06:00:19 <lambdabot>  2
06:06:37 <Saizan> parse2Tree' (x:xs) | isNumber x = ((Node x Nil Nil),xs)
06:06:37 <Saizan>                    | otherwise  = let (l,xs') = parse2Tree' xs
06:06:37 <Saizan>                                       (r,xs'')= parse2Tree' xs'
06:06:37 <Saizan>                                   in ((Node x l r),xs'')
06:07:31 <Saizan> I strongly suspect that this function could use a monad, some hints?
06:08:07 <Saizan> i tried State but i couldn't make it work
06:15:20 <tibbe> what does it do?
06:16:20 <Saizan> it reads an arithmetic expression in prefixed notation and creates the corresponding tree
06:17:29 <tibbe> well parsec runs with a monad for backtracing i believe
06:17:36 <goltrpoat> saizan:  if that's the entirety of it, then what's the need for a monad?
06:17:48 <goltrpoat> i mean, that looks succint enough
06:18:04 <Saizan> goltrpoat: understanding monad through simple code ^^
06:19:09 <goltrpoat> oh, if you're just trying to get the hang of it, then for that application, reading/implementing hutton's 'monadic parser combinators' might be a good idea
06:19:11 <tibbe> although it looks like a catamorphism
06:19:18 <tibbe> perhaps I can be rewritten
06:19:27 <tibbe> with some highorder magic
06:20:08 <Saizan> goltrpoat: uhm where do i find that?
06:20:21 <goltrpoat> tibbe:  isn't that about as readable as it's going to get? :)  any motivation for making it more complex would come to out of extending the language
06:20:41 <twodogsandacat> hi all.
06:20:52 <tibbe> goltrpoat: just for the exercise :)
06:20:59 <goltrpoat> saizan:  http://www.cs.nott.ac.uk/~gmh/monparsing.pdf
06:21:05 <pkhuong-> tibbe: you could implement it via foldr + a stack of arguments.
06:21:17 <Saizan> by the way the "problem" is that the second recursive call should start where the first end
06:21:19 <goltrpoat> oy.  come to = have to come
06:21:24 <tibbe> pkhuong-: I had something like that in mind
06:21:24 <goltrpoat> not sure what happened there.
06:22:12 <twodogsandacat> could i kindly ask for some peer review?
06:22:20 <twodogsandacat> i wrote my first haskell program...
06:22:49 <tibbe> twodogsandacat: sure
06:22:55 <tibbe> @paste
06:22:56 <lambdabot> http://paste.lisp.org/new/haskell
06:23:41 <twodogsandacat> one sec
06:24:05 <lisppaste2> twodogsandacat pasted "knight's travails" at http://paste.lisp.org/display/30663
06:24:16 <twodogsandacat> it's a solution to a ruby quiz.
06:24:35 <twodogsandacat> i'm still struggling with haskell so it's not very good... but it works...
06:25:43 <tibbe> hmm, doesn't Integer have an infinity representation?
06:25:57 <mux> I think it does
06:26:00 <mux> > 1/0
06:26:02 <lambdabot>  Infinity
06:26:25 <twodogsandacat> ooopsie
06:27:10 <tibbe> twodogsandacat: so you might use that instead
06:27:22 <twodogsandacat> ok, i'll do that
06:27:52 <ihope> So in general, numbers are represented as sets by making them the sets of lesser numbers?
06:28:17 <ihope> Like representing pi as the set of rationals less than pi?
06:28:27 <tibbe> I don't know if representing a board might be more efficient using something like, data Loc = Loc Int Int and data Board = Map Loc <something>
06:28:51 <tibbe> Map Loc Cost probably
06:28:55 <ihope> ...Wrong channel.
06:29:17 <twodogsandacat> ok.
06:29:18 <tibbe> ihope: I also confuse #math and #haskell alot
06:29:32 <tibbe> twodogsandacat: I don't know if it's better, just a thought
06:29:44 <twodogsandacat> yes, it's something to look up.
06:30:58 <tibbe> it's possible to get unpack functions for your datatype like your getCost and getSquare
06:31:08 <tibbe> don't remember the syntax, don't use it often
06:31:21 <tibbe> I need to make some lunch now though, ask some of the regulars :)
06:31:31 <twodogsandacat> ok, thank you!
06:32:02 <tibbe> you're welcome
06:37:27 <goltrpoat> i suppose Data.Graph.Inductive.Query.SP might come in handy, if one wanted to make it slightly less readable, but quite a bit shorter
06:38:38 <goltrpoat> ('less readable' just by obscurity, since i don't think a lot of people use Data.Graph.Inductive on a daily basis)
06:38:46 <twodogsandacat> well, i'm off for a walk with the dogs...take care.
06:39:15 <goltrpoat> i take it he didn't like that suggestion.
06:40:59 <goltrpoat> as a side note:  why the abbreviations?  would Data.Graph.Inductive.Query.ShortestPath been that much more difficult to type?
06:41:04 <goltrpoat> been=have been
06:41:42 <goltrpoat> i mean, MST is fine as an abbreviation, since it's a standard one
06:41:47 <goltrpoat> SP isn't though (i don't think)
06:44:04 <dcoutts> goltrpoat, the FGL lib is generally plagued by excessive use of short identifiers
06:44:15 <dcoutts> dfs dff dfs' wtf?
06:45:30 <dcoutts> it has two problems, one is the short names, the other is that nodes are always indenified by int's and so you have to maintain the key <-> node id mapping yourself which is a major pita
06:45:41 <goltrpoat> yeah, that's just silly
06:46:11 <dcoutts> sure, it's more effecient to use contigious int ids, but that's not the problem I'm trying to solve
06:47:21 <dcoutts> so every time I've used fgl for something I've not felt that I can use it directly, it's too ugly
06:47:40 <dcoutts> so I have to make a wrapper that manages the node id <-> node key mappings
06:48:16 <dcoutts> I'm often dealing with graphs with nodes with string keys (eg program variables).
06:48:55 <goltrpoat> right
06:51:55 <goltrpoat> i guess in the case of program variables, all you'll probably need is topological sort and a way to identify SCCs to get your binding groups, which is two topo sorts
06:52:14 <goltrpoat> so the argument could be made that it's a small enough of a subset of functionality that it shouldn't dictate the library design
06:52:21 <goltrpoat> still a pain in the ass though, yeah.
07:00:30 <goltrpoat> bedtime, adios.
07:09:15 <metaperl> dcoutts can you build standalone GUI apps with gtk / haskell?
07:09:24 <dcoutts> metaperl, of course
07:11:50 <phas> !paste
07:12:06 <phas> uhm
07:12:09 <Lemmih> ?paste
07:12:10 <lambdabot> http://paste.lisp.org/new/haskell
07:12:49 <phas> uh :P
07:17:04 <lisppaste2> phas pasted "FFI mess" at http://paste.lisp.org/display/30665
07:17:21 <phas> i've a little problem with FFI
07:17:25 <phas> i pasted ... all
07:17:49 <phas> in short, the compiler can't find the simbol of the function in the .o
07:19:01 <Pastorn> @type unlines
07:19:06 <lambdabot> [String] -> String
07:19:43 <Pastorn> > unlines ["nisse hult"]
07:19:47 <lambdabot>  "nisse hult\n"
07:20:23 <Lemmih> phas: Link against libid3.o?
07:22:00 <phas> Lemmih: worked... but doesn't --make handle this?
07:22:46 <Lemmih> It has no way to know libid3.(o|c) is the file you want.
07:23:03 <phas> ok
07:24:34 <Pastorn> @hoogle words
07:24:35 <lambdabot> Prelude.words :: String -> [String]
07:24:35 <lambdabot> Data.PackedString.wordsPS :: PackedString -> [PackedString]
07:24:35 <lambdabot> Prelude.unwords :: [String] -> String
07:37:11 <Pastorn> @hoogle lookup
07:37:13 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
07:37:13 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
07:37:13 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
07:37:29 <Pastorn> @source Prelude
07:37:29 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
07:43:11 <Pastorn> that wasn't very informative...
07:48:45 <gour> @where yhc
07:48:46 <lambdabot> http://www.cs.york.ac.uk/~ndm/yhc
08:07:00 <gour> @where jhc
08:07:01 <lambdabot> http://repetae.net/john/computer/jhc/
08:19:39 <xinming> http://paste.lisp.org/display/30671#1
08:19:50 <xinming> anyone here would help me simplify the code.
08:20:10 * EvilRanter is back (gone 03:02:20)
08:30:40 * monochrom â™¥ haskell
08:31:14 <Syzygy-> dons: Ping!
08:31:45 <Syzygy-> dons: I'm trying to build lambdabot (ghc6.6/gentoo/etc) from the darcs repo, and once I get through the dependencies, it blows up with the following error:
08:31:48 <Syzygy-> scripts/BotPP.hs:21:17:
08:31:50 <Syzygy-> scripts/BotPP.hs:21:17:    Could not find module `Data.ByteString.Char8':
08:31:53 <Syzygy->       it was found in multiple packages: fps-0.7 base
08:31:58 <glguy> lambdabot works on GHC 6.6 now?
08:31:59 <glguy> ?version
08:32:00 <lambdabot> lambdabot 4p272, GHC 6.5 (OpenBSD i386)
08:32:00 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
08:32:16 <dcoutts> Syzygy-, you don't need the fps package anymore now that you're using ghc-6.6
08:32:36 <Syzygy-> dcoutts: Right. So rather edit it out of the cabal than build with it?
08:32:42 <dcoutts> yep
08:32:42 <tibbe> xinming, getOneBlock create a list of length 3 with sublists of length 3 right?
08:32:42 * xerox â™¡ â™¥
08:32:56 <xinming> tibbe: yes.
08:35:02 <Syzygy-> dcoutts: Would you know where I'd find the module Text.Regex ?
08:35:06 <tibbe> xinming: getOneBlock = map (take 3) . take 3
08:35:18 <dcoutts> Syzygy-, in the regex-compat module
08:35:47 <dcoutts> we need an IDE that suggests corrections to common compliation problems :-)
08:35:47 <tibbe> xinming: plus the concat and transpose
08:35:53 <tibbe> xinming: a sec
08:35:54 <Syzygy-> And how do I unhide that?
08:36:01 <Syzygy-> >       it is a member of package regex-compat-0.71, which is hidden
08:36:01 <lambdabot>  Parse error
08:36:02 <xinming> tibbe: thanks. :-)
08:36:11 <Syzygy-> (ooops, forgot lambdabot...)
08:36:24 <tibbe> xinming: getOneBlock = concat . transpose . map (take 3) . take 3
08:37:49 <tibbe> @pl concat . transpose . map (take 3) . take 3
08:37:50 <lambdabot> join . transpose . map (take 3) . take 3
08:37:56 <tibbe> um
08:37:58 <tibbe> of course
08:38:22 <xinming> concat = join?
08:38:34 <glguy> concat is join on lists
08:39:10 <xerox> [[a]] -> [a]
08:39:18 <tibbe> what's the dual to take and drop?
08:39:21 <tibbe> another split?
08:39:26 <tibbe> :t split
08:39:31 <tibbe> @type split
08:39:31 <EvilRanter> :t splitAt
08:39:32 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
08:39:38 <xerox> take and drop aren't duals of theirself?
08:39:41 <tibbe> EvilRanter: thanks
08:39:53 <Syzygy-> AH!
08:39:59 <tibbe> xerox: well yes but my English is not good enough to express what I wanted to say :)
08:40:08 <Syzygy-> The clou was 'cp lambdabot.cabal.ghc-6.6 lambdabot.cabal'
08:40:15 <xerox> Syzygy-: ha!
08:40:29 <tibbe> xinming: what's remaining doing?
08:40:56 <tibbe> xerox: and it takes to long to explain what I wanted while lying down in my sofa :)
08:41:21 <xinming> tibbe: hmm, Ok, I'll give your a link where Pastorn gave me for practise. :-)
08:41:27 <xinming> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/funht/lab-assignments/lab4/
08:41:30 <lambdabot> Title: Lab 4 - Sudoku -- Intro. to Func. Prog. (TDA555/INN040ht) -- HT2006, http://tinyurl.com/suct5
08:41:48 <tibbe> xinming: remaining looks like an infinite loop
08:41:57 <xinming> I'm trying that. I know the implementation on blocks might be right. :-P
08:41:59 <tibbe> or no sorry
08:42:01 <tibbe> misread
08:42:18 <xinming> tibbe: No, It's not, I tried that, It's working. but I know it's ugly. :-P
08:43:34 <tibbe> xinming: splitAt might help you, it does what take and drop does together
08:43:42 <tibbe> > splitAt 3 [1,2,3,4,5,6]
08:43:44 <lambdabot>  ([1,2,3],[4,5,6])
08:44:09 <xinming> tibbe: Ok, thanks, bbl,
08:44:13 <glguy> and it does it more efficiently than doing a take and a drop
08:44:18 <xinming> I'll try to implement it using splitAt
08:44:53 <Syzygy-> @where fptools
08:44:53 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/building/sec-cvs.html
08:45:15 <tibbe> ?hoogle (a->c) -> (b->d) -> (a,b) -> (c,d)
08:45:16 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
08:45:22 <tibbe> oh
08:45:26 <tibbe> what's that :)
08:45:43 <dcoutts> @djinn (a -> b) -> (c -> d) -> (a, c) -> (b, d)
08:45:44 <lambdabot> f a b (c, d) = (a c, b d)
08:45:55 <dcoutts> you can tell what it must do by its type
08:45:59 <dcoutts> there is no choice
08:46:18 <tibbe> :)
08:46:24 <tibbe> (f a, f b)
08:46:35 <tibbe> it was more like, cool, there's a function that does that
08:47:03 <tibbe> dcoutts, and it could be _|_ right ;)
08:47:08 <tibbe> infinte recursion...
08:47:13 <dcoutts> well, or _|_ yes
08:47:35 <xinming> How do I unbox the (a, b) using list comprehension please?
08:48:02 <glguy> [ f a b | (a,b) <- listofasandbs]
08:48:04 <dcoutts> [ ... | (a,b) <- abs ]
08:48:38 <glguy> aka: map (uncurry f) abs
08:48:49 <xinming> Oh, thanks
08:49:00 <dcoutts> pattern matching is good for you, my students are always trying to use fst/snd/head/tail
08:49:09 <tibbe> xinming: you really don't need list comprehensions the way you are using them
08:49:16 <tibbe> it's just a map
08:51:21 <tibbe> what's wrong with (><) f g (x, y) = (f x, g y)
08:52:05 <glguy> ?type (><)
08:52:06 <lambdabot> Not in scope: `><'
08:52:33 <tibbe> (a -> b) -> (c ->d) -> (a,b) -> (c,d)
08:52:34 <glguy> is that standard somewhere? or just another way to write: f *** g
08:52:38 <tibbe> ?hoogle (a -> b) -> (c ->d) -> (a,b) -> (c,d)
08:52:39 <lambdabot> No matches, try a more general search
08:52:48 <glguy> ?. hoogle type (***)
08:52:50 <lambdabot> Hoogle Error: Parse Error: Unexpected character '* -> * -> '
08:53:04 <glguy> ?type (***)
08:53:06 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
08:53:08 <tibbe> ?hoogle (a->c) -> (b->d) -> (a,b) -> (c,d)
08:53:10 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
08:53:36 <glguy> > (succ *** pred) (3,7)
08:53:38 <lambdabot>  (4,6)
08:54:00 <tibbe> > let (***') f g (x, y) = (f x, g y)
08:54:00 <lambdabot>  Improperly terminated character constant
08:54:13 <tibbe> argh
08:54:33 <tibbe> ?hoogle (***)
08:54:35 <lambdabot> Did you mean: (***)
08:54:35 <lambdabot> Prelude.undefined :: a
08:54:35 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
08:54:45 <tibbe> ???
08:54:51 <Syzygy-> > let (*|*) f g (x,y) = (f x, g y) in (succ *|* pred) (3,7)
08:54:52 <glguy> > (succ &&& pred) 5
08:54:53 <lambdabot>  (4,6)
08:54:54 <tibbe> it's not my day today
08:54:54 <lambdabot>  (6,4)
08:55:24 <xerox> Syzygy-: you should investigate the Arrow (->) instance.
08:55:46 <Syzygy-> Whoa. I build lambdabot. Try to run it. And it eats memory, then bails out not getting enough.
08:56:03 <xerox> Give her enough memory.
08:56:04 <Syzygy-> Initialising plugins ...................................lambdabot: out of memory (requested 1686110208 bytes)
08:56:18 <Syzygy-> xerox: I have a gig. How much does she need?
08:56:26 <glguy> so hs-plugins works in ghc 6.6 now?
08:56:28 <xerox> You thightwad!
08:56:34 <xerox> tight*
08:56:43 <sjanssen> Syzgy-: there must be something wrong
08:56:46 <Syzygy-> glguy: I have no idea. When I know it does, I'll be sucked into livecoding again...
08:56:51 <Syzygy-> sjanssen: My thought as well...
08:56:59 <sjanssen> is there anything strange about your setup?
08:58:02 <Syzygy-> I dunno. ghc-6.6, gentoo, nothing particularily weird done...
08:58:07 <Syzygy-> Trying to keep it all vanilla.
08:58:37 <Syzygy-> @tell dons Tried to build lambdabot. It crashes, requesting 1.5G for plugin memory initialisations
08:58:38 <lambdabot> Consider it noted.
08:58:56 <tibbe> xinming: I think you can make your code shorter and unbelievably complicate with some (***) :)
08:58:57 <xerox> Syzygy-: you might try to compile it with profiling?
08:58:59 <tibbe> and splitAt
08:59:00 <dcoutts> Syzygy-, I don't think hs-plugins is ported to ghc-6.6 yet.
08:59:18 <monochrom> (***) is not complicated.
08:59:19 <dcoutts> though perhaps it is now, I've not checked recently
08:59:38 <Syzygy-> dcoutts: I heard something recently about it being worked on, but crags being around. That's what keeping me on track with doing mathematics and not playing with yaxu's code right now...
08:59:39 <tibbe> monochrom: well you should see my use of it ;)
09:00:06 <Syzygy-> dcoutts: But the lambdabot seems to only require hs-plugins if you really want to be able to evaluate expressions in ti too...
09:00:17 <monochrom> could you repeat your use of it?
09:01:18 <tibbe>  (concat . transpose . map (take 3)) *** id $ (splitAt 3 [[1,2,3],[4,5,6,7]])
09:01:29 <tibbe> I haven't started with the second part that goes instead of id
09:01:47 <glguy> tibbe: what is your goal?
09:01:50 <monochrom> I think it's ok.
09:02:13 <tibbe> glguy: to make it a one liner ;)
09:02:25 <glguy> tibbe: =/ no, what one-liner are you trying to make
09:02:38 <tibbe> all this should be fed to some sort of catemorphism
09:02:44 <Syzygy-> > (concat . transpose . map (take 3)) *** id $ (splitAt 3 [[1,2,3],[4,5,6,7]])
09:02:46 <lambdabot>  ([1,4,2,5,3,6],[])
09:02:47 <tibbe> http://paste.lisp.org/display/30671
09:02:52 <tibbe> xinming's code
09:03:04 <monochrom> If you have a task requiring 100 steps, you cannot code it in 99 tokens or less.
09:03:05 <dcoutts> woo!
09:03:06 * dcoutts is now a member of the GNOME foundation
09:03:33 <tibbe> monochrom: but there's loads left until I get down to 99!
09:03:35 <monochrom> But there is a school of thought that says you should code it in 1000 tokens or more.
09:04:03 <tibbe> monochrom: The Kingdom of Nouns school?
09:04:13 <monochrom> Heh yeah
09:04:30 <xerox> > join . transpose $ [[1,2,3],[4,5,6,7]] -- Syzygy- tibbe
09:04:32 <lambdabot>  [1,4,2,5,3,6,7]
09:04:38 <tibbe> monochrom: initially I was just pointing out to xinming that he could drop the list comprehensions, then it got a life of its own in my head
09:04:53 <monochrom> That is good.
09:05:03 <agocorona> the Hs-plugins can perform call-backs?
09:05:06 <tibbe> xerox: aren't you missing the drop 3 part?
09:05:18 <xerox> What do you mean?
09:05:46 <tibbe> it's supposed to not use all the elements only the first three
09:05:52 <CosmicRay> has anyone written haskell support for swig?
09:06:01 <dcoutts> CosmicRay, not so far as I know.
09:06:02 <xinming> tibbe: I've annoted the version
09:06:03 <xerox> tibbe: I don't understand that
09:06:05 <tibbe> getOneBlock xs = concat $ transpose [take 3 x | x <- take 3 xs]   -- xerox
09:06:12 <xinming> tibbe: please check. :-)
09:06:17 <CosmicRay> rats.
09:06:19 <glguy> generateBlocks = map getOneBlock . takeWhile (not.null) . iterate remaining xs
09:06:24 <tibbe> xerox: that's what I started with, before I went crazy
09:07:26 <agocorona> I mean, for example, a hs-plugin need to acces data in the applicaction. It is possible ?
09:07:28 <tibbe> xinming: :) I still don't see why you need the list comprehension, it's just a map
09:07:34 <xinming> glguy: ... I don't understand. :-) I want a version which I can understand. :-P
09:07:34 <xinming> glguy: I'm not at your level. >_<
09:07:56 <glguy> I was just rewritting that one function, and throwing it out for tibbe to consider
09:07:56 <xinming> tibbe: yes, but for me, It sometimes, easy for me to understand.
09:08:01 <tibbe> [take 3 x | x <- take 3 xs] === map (take 3) . take 3
09:08:15 <xinming> tibbe: Ok, thanks.
09:08:24 <tibbe> xinming: ok, just a stylistic preference I have, you can have a list comprehension instead of the filter as well
09:08:59 <glguy> > take 3 []
09:09:00 <lambdabot>  Add a type signature
09:09:03 <tibbe> but you'll probably see map and filter much more often in those cases than explicit list comprehensions
09:09:06 <glguy> > take 3 [] :: [()]
09:09:07 <lambdabot>  []
09:09:17 <glguy> the special case of remaining is unnecessary
09:09:18 <tibbe> takeUpTo 3 ;)
09:09:43 <tibbe> generateBlocks is almost a map
09:09:54 <xinming> glguy: why?
09:10:08 <tibbe> ?hoogle (a -> b) -> ([a] -> [b]) -> [a] -> [b]
09:10:10 <lambdabot> No matches, try a more general search
09:10:15 <glguy> xinming: because the first part will return [] anyway, and [] ++ xs is xs
09:10:18 <tibbe> a map that modifies the tail
09:11:01 <tibbe> ?hoogle (a -> b) -> ([a] -> [a]) -> [a] -> [b]
09:11:02 <lambdabot> No matches, try a more general search
09:11:48 * dcoutts notices norpan in #gnome
09:11:48 <dcoutts> norpan, I didn't know you were a gnome person especially
09:11:54 <xinming> glguy: deleted. :-P
09:12:25 <glguy> http://paste.lisp.org/display/30671#4
09:12:34 <tibbe> > let map' _ _ [] = []; map' f g (x:xs) = f x : map' f g (g xs) in map' (+ 1) (map (+1)) [1,2,3]
09:12:36 <lambdabot>  [2,4,6]
09:12:39 <xerox> I've got a problem with http://www.nomaware.com/monads/html/errormonad.html
09:12:41 <tibbe> oh yes!
09:12:41 <lambdabot> Title: The Error monad, http://tinyurl.com/hgna5
09:12:47 <xerox> Is that instance wrong?
09:12:57 <xerox> instance MonadError (Either e)
09:13:11 <tibbe> I've rewritten double but now it's much more complicated!
09:13:19 <tibbe> > let map' _ _ [] = []; map' f g (x:xs) = f x : map' f g (g xs)
09:13:20 <lambdabot>  Parse error
09:13:40 <tibbe> cleaning time, afk
09:13:59 <glguy> remaining = uncurry (++) . ((map (drop 3)) *** id) . splitAt 3
09:14:21 <glguy> ((map (drop 3)) *** id) == first (map (drop3))
09:15:18 <xinming> hmm, BTW, is there a way to avoid the filter (/= []) in my implementation?
09:15:30 <xinming> I don't know why, there will be a [] more...
09:16:00 <jmmv> hi
09:17:36 <xerox> ?docs Control.Monad.Error
09:17:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Error.html
09:17:43 <xerox> ?source Control.Monad.Error
09:17:44 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Error.hs
09:17:59 <monochrom> xerox: I suppose it is not wrong, but its utility is lower if e is not an instance of Error.
09:18:10 <xerox> I think it should be Error e => MonadError e (Either e)
09:18:58 <monochrom> The mtl certainly does that.
09:19:47 <glguy> Either String a, and Either IOError a are instances of MonadError
09:19:50 <xerox> It also provides default values for the error class functions: class Error a where { noMsg  :: a, strMsg :: String -> a, noMsg = strMsg "", strMsg _ = noMsg }
09:20:17 <xerox> (is that a bottom?)
09:20:21 <monochrom> But you see throwing and catching don't really need the Error methods, so syntactically you aren't obliged.
09:20:45 <monochrom> Yes until you override one of them.
09:21:20 <xerox> What is the point of the class Error?
09:23:01 <monochrom> To be user-friendly?  To satisfy the ever-increasing demand for "better error messages"?  To enable (or even force) you to write programs usable by newbies only?
09:23:50 <xerox> In the mtl they do everything at the highest level possible, instance (Monad m, Error e) => of some transformer.
09:24:02 <xerox> Beats me.
09:24:38 <monochrom> It institutionalizes the prejudice that errors must have messages.
09:24:45 <xinming> remaining xs = let (xs', ys') = splitAt 3 xs in (map (drop 3) xs') ++ ys'
09:25:02 <xinming> anyone here can tell me if this line would cause infinite loop?
09:25:39 <monochrom> If you study CS enough you will find that it is very common for even the brightest people to hardcode their prejudice in otherwise general theories.
09:25:41 <xerox> monochrom: does it do that sticking an "Error e => Either e" between your m and your a in "Monad m => m a"?
09:26:00 <monochrom> Yes.
09:26:34 * xerox grumbles.
09:28:40 <xerox> I should study the prejudice put into explaining some other mathematics now.
09:34:01 <xinming> glguy: the special case for y in yl@(y:ys) is necessary. otherwise, It would cause inifinite loop.
09:34:07 <xinming> glguy: I just now tried that.
09:34:28 <glguy> hm, ok
09:35:03 <phas> if i have imported with FFI a function that gives me a pointer to a struct
09:35:11 <phas> how can i get the struct from the pointer
09:35:20 <phas> for using peek and poke?
09:36:04 <xinming> Ok, thanks all for your help.
09:37:30 <glguy> Does anyone know which person is which on the channel9 STMvideo?
09:39:24 <pejo> glguy, Simon Peyton Jones has a picture of himself on his homepage, and talks about Haskell a lot in the Video. :-)
09:45:18 <Heffalump> does lambdabot (potentially) know people's email addresses?
09:46:22 <xerox> She logs
09:46:45 <glguy> Stomp on those PhD students to build an STM wall. =)
09:50:01 <phas> a.out: internal error: resumeThread: thread not found
09:50:02 <phas>     Please report this as a compiler bug.  See:
09:50:02 <phas>     http://www.haskell.org/ghc/reportabug
09:50:04 <phas> WTF?!
09:50:05 <lambdabot> Title: 1.2. Reporting bugs in GHC
09:52:19 <opqdonut> :D
09:59:31 <metaperl> I have an interesting type issue. A String without spaces I want to consider a word. A string with spaces I want to consider a phrase. I want a function alpha_number :: Word -> Int   and another alpha_number :: Phrase -> Int
10:01:26 <opqdonut> then you'll just have to enforce the difference on the "constructor" level
10:02:11 <metaperl> oh...  alpha_number Word "hello"    ... alpha_number Phrase "hello world"
10:02:32 <metaperl> type Phrase = String
10:02:33 <metaperl> ???
10:03:01 <metaperl> i need some help. I've never built my own types before
10:04:26 <astrolabe> 'data MyString = Word String | Phrase String'?
10:04:29 <metaperl> well never mind. it's not critical. I will delve into it later if I decide to be that precise. for now I have two fns . alpha_number_word and alpha_number_phrase
10:04:46 <metaperl> astrolabe , yes, but I think Word is a Haskell thing already
10:05:07 <astrolabe> good point
10:05:13 <metaperl> Werd
10:05:14 <metaperl> :)
10:05:19 <metaperl> Mot
10:05:20 <astrolabe> but I'm sure you could fix that
10:05:31 <metaperl> I'll just use some other terminology
10:05:38 <metaperl> or use French or something
10:09:29 <metaperl> so can I overload alpha_number with different implementations for Werd and Phrase simply putting a type signature right above the implementation for each?
10:10:27 <eviltwin_b> you want a type class, I think
10:10:31 <opqdonut> yep
10:10:55 <metaperl> more stuff still above my head... hmm.. well when I get to that part of SJT, then I will rework my code.. .thanks for the input
10:11:13 <metaperl> I'm not a student, but I'm using SJT's book to learn Haskell
10:11:16 <metaperl> step by step
10:12:48 <opqdonut> metaperl: i recommend reading yaht first so you have a general picture
10:12:52 <opqdonut> @where yaht
10:12:52 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
10:13:05 <metaperl> opqdonut - that book have too many typos for me..
10:13:12 <opqdonut> ???
10:13:35 <glguy> has*
10:13:39 <opqdonut> ah, the book has correctly inflected verbs and it bothers you?
10:13:48 <metaperl> I actually like "Haskell Road to Logic Math and Computer Programming" but it does not go deep enough into Haskell, but his presentation of Haskell was excellent
10:13:52 <opqdonut> glguy: damn you, you spoiled my punchline
10:13:59 <metaperl> ok, ok, hahahah , very funny :)
10:14:19 <metaperl> and SOE was good, but the graphics module is hard to getup and running
10:14:42 <metaperl> and Bird/Wadler's book is costlly and I cannot order a new copy to examine it - only used is available
10:14:50 <metaperl> and online report is too dense
10:14:55 <metaperl> and gentle intro is not gentle
10:14:57 <metaperl> :)
10:15:01 <metaperl> so thank the lord for SJT
10:15:11 <metaperl> or I would never make it
10:15:33 <astrolabe> yaht is a wikibook
10:15:34 <opqdonut> metaperl: what was your problem with yaht
10:15:44 <astrolabe> if you see mistakes, you could correct them
10:16:02 <metaperl> I think I tried contacting him
10:16:09 <opqdonut> astrolabe: is it?
10:16:28 <metaperl> oh it might be a wikibook now... it wasnt 1-2 years ago
10:16:43 <astrolabe> http://en.wikibooks.org/wiki/Haskell/YAHT
10:16:57 <opqdonut> oh okay
10:18:03 <astrolabe> I don't remember that many typos either, but maybe I just didn't see them
10:19:18 <glguy> The only typos that bother me are the ones in code blocks
10:19:48 <glguy> but SoE has a couple and I still enjoy the book
10:20:16 <opqdonut> okay, i don't remember typos in the pdf version
10:42:01 <norpan> dcoutts: i'm everywhere
10:42:08 <dcoutts> heh heh
10:43:35 <dcoutts> and another member of the Chalmers conspiracy ;-)
10:44:20 <dcoutts> Rule 1. You do not talk about the Chalmers conspiracy
10:44:52 <dcoutts> I just talked to a gnomer who knew someone who does Haskell for their day job in something related to the US military
10:45:42 <monochrom> That is deeper than a Chalmers conspiracy.  That is a US military conspiracy!
10:46:08 <dcoutts> Though somehow I don't see the US military sponsoring the Haskell hackathon (or indeed the hackathon organisers accepting such sponsorship)
10:46:54 <monochrom> It does so through the facade of the Pheonix Foundation.
10:47:16 <dcoutts> doesn't Galois do some of that kind of contracting?
10:47:28 <monochrom> HHMMMM!  Galois...
10:48:38 <Heffalump> and Aetion
10:54:25 <dcoutts> http://www.aetion.com/jobs.html
10:54:27 <lambdabot> Title: Aetion Technologies LLC - Jobs
10:54:30 <dcoutts> looks like fun ^^
10:54:46 <dcoutts> except the bit about moving to Ohio ;-)
10:57:13 <dcoutts> Heffalump, you just got a Haskell job, who's that with?
10:57:25 <dcoutts> (if you don't mind me asking)
10:59:17 <Igloo> Isn't Okasaki a military person?
10:59:33 <dcoutts> yes I think he is.
10:59:53 <dcoutts> With some US military training school I believe.
11:00:07 <dcoutts> No idea what he does apart from publishing papers.
11:00:35 * Igloo doesn't see why we wouldn't accept sponsorship, anyway. It's not like we boycott edison  :-)
11:01:55 <dcoutts> Igloo, I didn't say we wouldn't.
11:02:10 <dcoutts> but since it's not going to happen there's no need to debate it
11:02:34 <Igloo> Indeed  :-)
11:02:46 <dcoutts> Igloo, since you're here, where did we get with the configurations proposal?
11:02:58 <dcoutts> or don't you work on the weekend? :-)
11:03:08 <Igloo> We need to write some BNF, I think
11:03:11 <dcoutts> now that it's your day^H^H^H night job.
11:03:18 <dcoutts> right.
11:03:27 <dcoutts> though for that we need to decide on the brackets issue
11:03:40 * Igloo might do it later tonight, but is in the middle of something else ATM
11:03:44 <dcoutts> np
11:03:45 <Igloo> Oh, I thought we decided
11:04:12 <dcoutts> Igloo, I think we might meet some resistance
11:04:18 <Igloo> I like the idea of, independently, migrating cabal to a    library { ... } syntax, too
11:04:34 <dcoutts> aye, if we can make it independent then that'd help
11:04:52 <dcoutts> can we find a syntax that works with the current scheme?
11:05:17 <dcoutts> the basic problem was indicating if a configuration applied to the lib or an executable
11:05:33 <Igloo> Maybe we should just talk about semantics for now, with explicit braces?
11:05:40 <dcoutts> sure
11:05:53 <dcoutts> good idea, split the issue and deal with syntax later
11:06:30 <dcoutts> I think we could just have it apply to the thing preceding stanza. Though we could get a better syntax if we moved to using {}.
11:07:41 <astrolabe> dcoutts: I'm writing to a drawing area using a pangoLayout.  I can control the foreground colour of my text by changing the foreground of the gc, but I can't seem to control the background, by changing the background of the gc.  Any idea why that could be?
11:08:20 <dcoutts> astrolabe, there is no background. It jsut draws text. If you want a coloured rectangle behind the text then you can draw one.
11:08:41 <astrolabe> dcoutts: thanks very much.  I see.
11:09:27 <dcoutts> astrolabe, there are functions for getting the logical and inked extents of a layout of text.
11:10:09 <astrolabe> It all seems very complicated to me
11:10:22 <astrolabe> But I guess that's because gtk is
11:10:46 <dcoutts> partly, and partly because there's a lot of features that you can control
11:10:55 <dcoutts> what are you doing btw ?
11:11:18 <astrolabe> Something boring to learn gtk2hs
11:11:20 <dcoutts> when you get into the details, text layout is a complex topic
11:11:33 <astrolabe> A sort of time planner for work
11:11:57 <dcoutts> astrolabe, perhaps using a pango layout is more detail than you need
11:12:03 <dcoutts> there's a simple cairo api
11:12:50 <dcoutts> or the pango stuff which gives you much more control and somewhat higher performance
11:12:55 <lennart> is there an easy way to diff two repos in darcs?
11:12:56 <astrolabe> The pango stuff doesn't seem too to just print a line of text.
11:13:10 <dcoutts> astrolabe, use the simple cairo text api
11:13:27 <astrolabe> dcoutts: I'll have a look.  Thanks
11:13:51 <dcoutts> http://haskell.org/gtk2hs/archives/2005/11/10/getting-started-with-cairo/
11:13:55 <lambdabot> Title: Gtk2Hs Â» Blog Archive Â» Getting started with Cairo, http://tinyurl.com/s9sfo
11:14:02 <dcoutts> astrolabe, ^^ that shows an example
11:14:27 <dcoutts> actually that uses the pango stuff with cairo
11:14:35 <dcoutts> but in a simple way
11:15:22 <dcoutts> the cairo "toy" text api is just: moveTo x y >> showText "Hello!"
11:15:35 <dcoutts> http://haskell.org/gtk2hs/docs/current/Graphics-Rendering-Cairo.html#5
11:15:37 <lambdabot> http://tinyurl.com/tkkq9
11:17:40 <astrolabe> thank you
11:22:57 <jwp> ugh, ghc snapshots corrupt? (http://www.haskell.org/ghc/dist/current/dist/)
11:22:58 <lambdabot> Title: Index of /ghc/dist/current/dist
11:24:18 <jwp> mm, STABLE snaps seem ok
11:53:19 <klapmuet1> if I have no previous experience with _real_ functional programming, should I rather go for 'the little schemer' or with haskells 'soe'?
11:56:12 <monochrom> Both.
11:56:30 * glguy bought both the same day
11:57:17 <klapmuet1> but you both agree that I should read the little schemer first? ;-)
11:57:52 <glguy> The Little Schemer emphasises writing recursive functions
11:58:08 <glguy> instead of writing iterative loops
11:58:24 <glguy> if you feel like you could learn more on that topic, then definitely start there
11:58:50 <glguy> it also gets into functions that return functions
11:58:56 <glguy> that functions are values
11:59:07 * Korollary sets up the doomsday device
11:59:29 <glguy> if someone kills you, your device will go off?
11:59:31 <klapmuet1> glguy: okay... I'll get both and start with the little schemer... I definately need to look at recursive functions ;-)
11:59:45 <monochrom> There is no doomsday device.
11:59:58 <klapmuet1> no fighting in the war room!
12:02:19 <monochrom> Godawful my stuff is listed among the Haskell tutorials on the wiki?!
12:03:20 * monochrom hunts down "who did it!"
12:15:38 <newsham> hmm.. python error when visiting the darcs page :)
12:16:02 <monochrom> Of course it was dons.  It happened at 22:19, 1 April 2006.
12:16:12 <monochrom> Binary search is very useful :)
12:19:22 <newsham> anyone know the URL to the darcs windows binary?
12:23:14 <glguy> xinming: you around?
12:23:25 <glguy> ?paste
12:23:25 <lambdabot> http://paste.lisp.org/new/haskell
12:25:16 <glguy> > let groups n = unfoldr (liftM2(>>)(guard.not.null)(return.splitAt n)) in groups 9 [1..81]
12:25:18 <lambdabot>  [[1,2,3,4,5,6,7,8,9],[10,11,12,13,14,15,16,17,18],[19,20,21,22,23,24,25,26,2...
12:26:36 <Cale> > let groups n = map (take n) . takeWhile (not . null) . iterate (drop n) in groups 9 [1..81]
12:26:37 <lambdabot>  [[1,2,3,4,5,6,7,8,9],[10,11,12,13,14,15,16,17,18],[19,20,21,22,23,24,25,26,2...
12:27:09 <glguy> That's not the point, I'm not worried about the definition of groups in this case
12:27:37 <glguy> > let groups n = unfoldr (liftM2(>>)(guard.not.null)(return.splitAt n)) ; starting = groups 9 [1..81] in concat . map (map concat . groups 3 . transpose) . groups 3 $ starting
12:27:38 <lambdabot>  [[1,10,19,2,11,20,3,12,21],[4,13,22,5,14,23,6,15,24],[7,16,25,8,17,26,9,18,2...
12:27:55 <newsham> > let groups n = unfoldr (liftM2(>>)(guard.not.null)(return.splitAt n)) in map (foldl (\a b -> (a `shiftL` 1) + b)) (groups 8 [1,1,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1]
12:27:55 <lambdabot>  Parse error
12:28:03 <newsham> > let groups n = unfoldr (liftM2(>>)(guard.not.null)(return.splitAt n)) in map (foldl (\a b -> (a `shiftL` 1) + b)) (groups 8 [1,1,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1])
12:28:05 <lambdabot>  add an instance declaration for (Bits [a])
12:28:05 <Botty> > let groups n xs = (take n xs) : (groups n (drop n xs)) in groups 9 [1..81]
12:28:06 <glguy> that is the one-liner that does what xinming was asking for earlier
12:28:07 <lambdabot>  [[1,2,3,4,5,6,7,8,9],[10,11,12,13,14,15,16,17,18],[19,20,21,22,23,24,25,26,2...
12:28:33 <Botty> I think mine takes the cake for most intelligible
12:28:54 <glguy> Botty: yours doesn't end
12:29:17 <Botty> hmm
12:29:23 <newsham> > let groups n = unfoldr (liftM2(>>)(guard.not.null)(return.splitAt n)) in map (foldl (\a b -> (a `shiftL` 1) + b) 0) (groups 8 [1,1,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1])
12:29:23 <glguy> that's why Cale has the takeWhile
12:29:24 <lambdabot>  Add a type signature
12:29:31 <newsham> > let groups n = unfoldr (liftM2(>>)(guard.not.null)(return.splitAt n)) in map (foldl (\a b -> (a `shiftL` 1) + b) 0) (groups 8 [1,1,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1]) :: Int
12:29:31 <Botty> > let groups n xs = (take n xs) : (groups n (drop n xs)) in groups 9 [1..18]
12:29:32 <lambdabot>  Couldn't match `Int' against `[b]'
12:29:33 <lambdabot>  [[1,2,3,4,5,6,7,8,9],[10,11,12,13,14,15,16,17,18],[],[],[],[],[],[],[],[],[]...
12:29:36 <newsham> > let groups n = unfoldr (liftM2(>>)(guard.not.null)(return.splitAt n)) in map (foldl (\a b -> (a `shiftL` 1) + b) 0) (groups 8 [1,1,0,0,1,0,1,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1]) :: [Int]
12:29:37 <lambdabot>  [203,69,5]
12:29:39 <Botty> ah, i see
12:30:59 <glguy> ?tell xinming Here is some code that does something similar to the Sudoku function you were playing with earlier: let groups n = unfoldr (liftM2(>>)(guard.not.null)(return.splitAt n)) ; starting = groups 9 [1..81] in concat . map (map concat . groups 3 . transpose) . groups 3 $ starting
12:31:00 <lambdabot> Consider it noted.
12:31:18 <Botty> > let groups n xs = (take n (takeWhile (not . null) xs)) : (groups n (drop n xs)) in groups 9 [1..18]
12:31:19 <lambdabot>  add an instance declaration for (Num [a])
12:31:19 <lambdabot>   In an arithmetic sequence: [1...
12:31:26 <Botty> eh, nevermind
12:31:47 <glguy> Botty: Cale's is already the "most readable"
12:32:36 <Botty> > let groups 0 _ = []; groups n xs = (take n xs) : (groups n (drop n xs)) in groups 9 [1..18]
12:32:38 <lambdabot>  [[1,2,3,4,5,6,7,8,9],[10,11,12,13,14,15,16,17,18],[],[],[],[],[],[],[],[],[]...
12:32:47 <glguy> Cale, I like that definition of unfoldr that you use, but I do think that it is less general
12:33:11 <Botty> dunno about most readable.  Most pointfree and using-builtin-functions-y
12:33:37 <glguy> builtin functions are almost always more readable than explicit recursion (imho)
12:35:07 <Botty> well, I suppose once prelude functions become more meaningful, immediately graspable than the language's basic list functionality, i suppose
12:38:05 <glguy> > let groups n = unfoldr (liftM2(>>)(guard.not.null)(return.splitAt n)) ; starting = groups 9 [1..81] in (>>= map concat . groups 3 . transpose) . groups 3 $ starting
12:38:06 <lambdabot>  [[1,10,19,2,11,20,3,12,21],[4,13,22,5,14,23,6,15,24],[7,16,25,8,17,26,9,18,2...
12:38:13 * glguy thought to abused the >>=
12:38:17 <glguy> abuse*
12:40:56 <Botty> I guess I think that learning to read recursive functions is much easier than getting an intuitive grasp on the prelude functions and partial functions passed through these functions
12:42:18 <xahlee> of interest: http://www.malevole.com/mv/misc/killerquiz/ (programing lang inventor or serial killer quiz)
12:42:19 <lambdabot> Title: malevole - Programming Language Inventor or Serial Killer?
12:42:39 <Botty> It's cool to be so masterful at haskell that you can write such code which recombines the basic concepts defined in the prelude in inventive ways, but that doesn't make it better for the reader
12:43:12 <monochrom> Haha, I have written my first infinite loop with callcc.  That is, an infinite loop that produces nothing; a bug.
12:43:26 * eviltwin_b certainly needs to work to comprehend those things still
12:44:37 <newsham> ?pastebin
12:44:38 <lambdabot> Unknown command, try @list
12:44:45 <glguy> http://paste.lisp.org/new/haskell
12:44:50 <pejo> Botty, the stuff in the prelude can pretty much be trusted to be correct though. If you glue it together thats all your fault. If you write it all yourself you might do a mistake when implementing the prelude as well.
12:45:10 <monochrom> Botty: your point basically explains why VB programmers write their own sorts and searches rather than call library functions.  As a corollary it explains why software is not reused.
12:45:39 <Botty> Hmm, good points
12:45:40 <lisppaste2> newsham pasted "why instance error?" at http://paste.lisp.org/display/30687
12:45:49 <newsham> anyone know whats up here?
12:46:10 <newsham> this code is verbatim from a tutorial :(   also I tried several variations (ie. using [Book] instead of Books).
12:46:30 <Igloo> You need -fglasgow-exts
12:46:39 <monochrom> Combine with pejo's points, we see why average software is so buggy.  The libraries have correct functions, but everyone writes from scratch and wrong.
12:46:56 <Botty> pejo - in many cases, I think you are more likely to make a mistake with your glue when it is that complicated, rather than sort of pseudo-reimplementing the prelude
12:47:15 <newsham> igloo: what's the reason?
12:47:17 * eviltwin_b 's point was more about not grokking point-free too well yet
12:47:22 <glguy> Botty: I would just argue that acompetent Haskell programmer is more likely to understand the version using the Prelude than to understand the explicit one
12:47:30 <Igloo> newsham: It's not a valid Haskell 98 instance head
12:47:42 <glguy> Botty: but to a new programmer, not knowing the Prelude could be a hurdle, but they need to get over that hurdle anyway
12:47:43 <newsham> what would make it valid?
12:47:47 <monochrom> When you glue things, a strong and static type system is a great check on gluing compatible things at least.
12:47:48 <Igloo> newsham: ([] Book) is not of the form (T a b c ...)
12:47:50 <Botty> glguy - possibly.  That just means I'm still new :)
12:48:06 <Botty> I can understand it, but it takes like 45 seconds.  Mine is like 5 secs
12:48:22 <glguy> of course you can understand yours... you wrote it
12:48:23 <monochrom> Perl glues are buggy because you don't know you're gluing a list producer to a hash consumer.
12:48:23 * Igloo AFKs
12:48:38 <Botty> glguy - heh, not because I wrote it though
12:48:40 <monochrom> Haskell glues are almost if-it-compiles-it-works.
12:48:50 <newsham> (that fixed it, btw, but i would be interested in knowing why)
12:48:58 <Botty> monochrom - yeah, almost.
12:49:16 <monochrom> Of course if you write from scratch, nothing short of a complete theorem prover will help.
12:50:01 <newsham> <Igloo> newsham: ([] Book) is not of the form (T a b c ...)
12:50:08 <newsham> is that supposed to be "is of the form" ?
12:50:21 <monochrom> I actually think this.  The empirical observation is "almost".  It is just "almost" because there is still 5% of coding from scratch.  If it's 100%, it's 100% if-it-compiles-it-works.
12:50:47 <monochrom> err, the last sentence should be: If it's 100% glue, it's 100% if-it-compiles-it-works.
12:51:24 <Botty> Well, haskell can't actually do all kinds of type constraints.  This is one reason for an error command
12:51:46 <Botty> or at least, prevalence of the error command within the prelude
12:53:20 <monochrom> Suppose I learn the English language.  Sooner or later I have to learn the rich vocabulary.  I cannot say "please put that thing you use to eat on that flat surface you store things and perform actions on" all day long.
12:53:36 <monochrom> Eventually I have to learn to say "please put the fork on the table".
12:53:58 <monochrom> The former is anti-use-the-Prelude, the latter is pro-use-the-Prelude.
12:54:43 <monochrom> I have heard no one advocating a method of teaching English to newbies based on the former.
12:54:46 <glguy> You can tell that monochrom likes the Prelude simply because he said pro/anti-prelude instead of pro/anti-from-scratch
12:56:22 <Botty> hehe
12:57:35 <Botty> > let groups _ [] = []; groups n xs = (take n xs) : (groups n (drop n xs)) in groups 9 [1..18]
12:57:37 <lambdabot>  [[1,2,3,4,5,6,7,8,9],[10,11,12,13,14,15,16,17,18]]
12:58:36 <glguy> > let groups _ [] = []; groups n xs = let (a,b) = splitAt n xs in a : groups n b in groups 9 [1..18]
12:58:38 <lambdabot>  [[1,2,3,4,5,6,7,8,9],[10,11,12,13,14,15,16,17,18]]
12:59:10 <Botty> > let groups n = map (take n) . iterate (drop n) in groups 9 [1..18]
12:59:11 <lambdabot>  [[1,2,3,4,5,6,7,8,9],[10,11,12,13,14,15,16,17,18],[],[],[],[],[],[],[],[],[]...
12:59:43 * dcoutts sends email to gtk2hs-users trying to solicit help with a gtk2hs intro tutorial
12:59:45 <glguy> now just add a takeWhile and you'll be at Cale's version
12:59:45 <Botty> thing is, if cale took the naive approach with the prelude functions, he'd have made the same mistake I made with naive recursion
13:00:06 <Botty> heh, yeah, I got that by copying cale's and removing the takewhile :)
13:00:31 <dcoutts> it's now ultra easy to contribute, we've got a skeleton in the gtk2hs darcs repo + makefiles to build the html
13:00:37 <dcoutts> http://haskell.org/gtk2hs/docs/tutorial/intro/
13:00:39 <lambdabot> Title: Gtk2Hs Â» Documentation Â» Intro Tutorial, http://tinyurl.com/yneplk
13:01:07 <Cale> Botty: hm?
13:01:34 <Botty> nothing, just discussing the groups function
13:01:48 <glguy> \original new n -> original == concat new && all ((==n).length) new
13:02:01 <Cale> It's pretty obvious that iterate (drop n) is going to have a tail of all empty lists though.
13:02:33 <Cale> (provided that the input is finite)
13:03:17 <Botty> true
13:08:50 <glguy> > take 4 $ evalState (filterM (\_ -> gets (==0) >>= \b -> if b then return False else (modify (subtract 1) >> return True)) [1..]) 9
13:08:52 <lambdabot>  [1,2,3,4]
13:09:01 <glguy> > take 10 $ evalState (filterM (\_ -> gets (==0) >>= \b -> if b then return False else (modify (subtract 1) >> return True)) [1..]) 9
13:09:05 <lambdabot> Terminated
13:09:21 <Botty> ok, I agree, it;s better in near all cases to use prelude functions, though not for readability
13:09:26 <glguy> ?hoogle takeWhileM
13:09:27 <lambdabot> No matches found
13:09:41 <glguy> Botty: good, then you are half the way there ;)
13:09:48 <Botty> hehe
13:11:08 <glguy> "What is delicious."
13:12:32 <Cale> candy
13:12:39 <glguy> :)
13:13:06 <Cale> Penny Arcade is awesome
13:17:29 <Excedrin> has anyone here ever received a response from email to the EFF?
13:17:43 <Excedrin> it seems like a black-hole for emails
13:17:50 <newsham> are you being sued?
13:18:19 <glguy> he's asking license questions
13:18:54 <glguy> they are probably too busy losing lawsuits and setting negative legal precedents
13:19:00 <Excedrin> no, I sent an email asking to clarify something about GPL and copyright
13:22:35 <Igloo> newsham: No, not of the form. The "a b c" have to be type variables
13:24:33 <Excedrin> this Streams library looks interesting
13:28:27 <glguy> I was looking at the grammar dependency graphs on LtU... does anything like this exist for Haskell?
13:35:06 <pejo> glguy, url?
13:37:43 <arjanoosting> Igloo: did you have time for the FTBFS of haskell98-report yet? Yes I am annoying ;-)
13:38:22 <Igloo> arjanoosting: Nah, you're right to prod me  :-)
13:40:39 <arjanoosting> Igloo: are you intending to do an upload soon?
13:41:36 <Igloo> arjanoosting: OK, just finished what I was doing so I'll look at it now
13:42:03 <arjanoosting> :-)
13:42:14 <glguy> pejo: URL to "What is delicious."? (if so, I don't know, I'm just quoting because it came to mind)
13:42:24 <glguy> "Any sufficiently complicated Common Lisp or Scheme program will eventually be rewritten in C++, Java, or Python."
13:42:31 <glguy> --It's Bitwize's Corollary to Greenspun's Tenth Law.
13:56:31 <araujo> glguy, That's to make it more complex?
13:57:12 <glguy> I don't know, ti was a LtU comment... figured I'd share it
14:01:45 <deadbeef> hi there
14:01:51 <fik_> hi
14:01:53 <deadbeef> excuseme, an ot question:
14:02:05 <deadbeef> anyone here as an account on acm.org ? i'd like to get a paper
14:02:12 <fik_> what does "ot" mean?
14:02:13 <deadbeef> http://portal.acm.org/citation.cfm?id=321253&dl=ACM&coll=portal <- this one
14:02:16 <lambdabot> http://tinyurl.com/y2t39s
14:02:16 <deadbeef> offtopic
14:04:22 <Heffalump> you can buy individual articles, AFAIK
14:06:39 <dgriffi3> deadbeef: If you are at a university your library might have a subscription
14:06:50 <deadbeef> i could try
14:06:51 <deadbeef> thanks a lot
14:07:53 <fik_> hey, dead. i can download tuesday at university. if you can't until then...
14:08:54 <deadbeef> np, i could go on monday
14:09:11 <deadbeef> thanks a lot btw
14:09:27 <fik_> k
14:28:17 <dons> ?users
14:28:18 <lambdabot> Maximum users seen in #haskell: 276, currently: 258 (93.5%), active: 25 (9.7%)
14:31:15 <kaol> it might be nifty if lambdabot put a graph of user stats visible on a web page somewhere
14:31:44 <lennart> dons: I've sent the overloaded strings patch to the ghc maintainers now
14:31:51 <Botty> could have lots of cool graphs, average activity, frequency of particular terms
14:32:08 <jcreigh> words per nick. :)
14:32:15 <Botty> question is would the work involved be worth it?
14:32:15 <Botty> yeah
14:32:25 * kaol carefully does not volunteer to implement that ;-)
14:32:48 <Botty> karma per nick
14:33:13 <dons> Excedrin: cool.
14:33:14 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
14:33:19 <dons> lennart: cool (I mean)
14:33:31 <dons> kaol: stats, you mean like?
14:33:34 <dons> ?where stats
14:33:35 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
14:34:44 <kaol> hah. I considered first asking if there were stats somewhere already, too.
14:35:06 <Heffalump> was there any conclusion on overloaded strings (and bools) for Haskell' ?
14:35:07 <lennart> heh, dons, you are almost as active as lambdabot
14:35:16 <dons> scary
14:35:31 <lennart> Heffalump: no conclusion that I have seen.
14:35:39 <Heffalump> shame :-(
14:35:55 <Heffalump> having them would make using fast string classes much nicer
14:36:00 <lennart> I think we need to test it before it goes into Haskell'
14:36:06 <Heffalump> true
14:36:46 <lennart> hopefully the patch will get merged so people can test overloaded string literals
14:36:59 <lennart> overloaded booleans are trickier
14:37:26 * Heffalump hasn't really thought about the issues
14:37:50 <sjanssen> overloaded booleans seem less necessary
14:38:07 <lennart> I'm using overloaded booleans for our DSEL, but it's a bit clunky
14:40:37 <lennart> Heffalump: when do you start?
14:40:47 * earthy thinks any special denotation should allow overloading
14:41:03 <Heffalump> lennart: can you not tell the difference between private messages and channel messages? :-)
14:41:05 <earthy> booleans, otoh, are in a sense just constructors.
14:41:09 <lennart> overloaded [...] notation would be great
14:41:12 <Heffalump> (but January 2nd)
14:41:42 <lennart> Heffalump: yes.  And I replied privatly and nothing seems to happen.
14:42:03 <Heffalump> oh. I wonder if people not registered are completely banned from sending private messages.
14:42:39 <lennart> probably.  it could explain we people never seem to notice when i answer their private messages (like you) :)
14:42:56 <Heffalump> yes, it would :-)
14:43:04 <Heffalump> how annoying.
14:43:22 <lennart> I wish there was some feedback when the message fails.
14:43:54 <eviltwin_b> <Heffalump> oh. I wonder if people not registered are completely banned from sending private messages.
14:44:03 <eviltwin_b> yes, for the past 5 months or so I think
14:44:47 <lennart> I could register if I knew how. :)
14:44:55 <Heffalump> I think you just talk to nickserv
14:45:02 <eviltwin_b> /msg nickserv help
14:45:04 <Heffalump> (/msg nickserv help is probably a good start)
14:45:12 <eviltwin_b> (which will go through, nickserv is an exception)
14:47:05 <dons> hmmm. we need to get hackagedb done! http://cean.process-one.net/  (erlang's hackage I think)
14:47:09 <lambdabot> Title: Comprehensive Erlang Archive Network
14:49:09 <jcreigh> @hoogle Int -> IO ()
14:49:10 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
14:49:10 <lambdabot> System.Console.Readline.setCompletionQueryItems :: Int -> IO ()
14:49:10 <lambdabot> System.Console.Readline.setEnd :: Int -> IO ()
14:49:33 <pejo> Isn't there a message when the messages don't go through? I seem to remember finally getting fed up with the error messages w hen sending people messages and registering.
14:49:56 <eviltwin_b> I got one but in xchat it went with the server messages or something like that
14:50:16 <eviltwin_b> (befre I was registered)
14:50:36 <pejo> Ah. There are irc clients with windows out there.
14:50:56 <eviltwin_b> tabs :)
14:55:12 <Igloo> lennart: You probably did get a notice in a status window, but in most IRC clients it's very easy to miss
14:55:39 <dcoutts> Ok, Haskell hackers, here's a challenge: build a wiki front end to a darcs repo. Changes made in the wiki should be submitted via darcs send.
14:56:11 <Heffalump> making twiki use darcs rather than RCS might be quite easy
14:56:13 <Igloo> dcoutts: Why should they be made by darcs send?
14:56:23 <dcoutts> Igloo, so they can be sent upstream
14:56:31 <dcoutts> but sure, just modify the local version
14:57:00 <lennart> Hmmm, seems Lennart is already registered, and last connected from Belgium.  Oh well.
14:57:02 <dcoutts> record in the local version, and a feature to send them upstream
14:57:08 <Igloo> dcoutts: http://matrix.chaos.earth.li/~ian/diki/Index is a start, anyway, but i need more tuits to polish it and add missing basic features
14:57:10 <lambdabot> Title: Diki
14:57:27 <dcoutts> "Diki" heh nice name
14:58:03 <dcoutts> Igloo, ok, but I'm not exactly looking for a CMS style wiki. I want a wiki front end to a code repo.
14:58:21 <dcoutts> well a generic repo
14:58:50 <Igloo> Doesn't sound like a wiki to me
14:59:48 <dcoutts> Ok, just a darcs repo front end
14:59:58 <dcoutts> that allows you to edit and send patches
15:00:26 <dcoutts> the point being that like a wiki, anyone can contribute via a web interface
15:00:38 <jcreigh> hmm...I'm looking for to sleep for X seconds (or milliseconds or whatever. seconds resolution is good enough.)... Control.Concurrent.threadDelay looks like what I want, but I can't figure out to use it. eg, I expected threadDelay 5000 >> putStrLn "hello" to sleep for 5 seconds and then print "hello" instead of printing hello immediately.
15:01:03 <jcreigh> I'm guessing I have to wrap in IO in a thread or something.
15:01:25 <Lemmih> jcreigh: Try: threadDelay (5*10^6)
15:01:28 <dcoutts> jcreigh, are you sure you've got the unit right?
15:01:46 <jcreigh> bloody microseconds.
15:01:59 <jcreigh> seriously, the timer resolution is probably around 10-20ms...
15:02:01 <jcreigh> :-)
15:02:13 <Igloo> dcoutts: You could probably reuse most of diki (once it's done), anyway. You just need to skip the pretty-print step
15:02:26 <dcoutts> Igloo, right.
15:02:38 <dcoutts> that and add a send button.
15:02:45 <dcoutts> Igloo, you're using cgi ?
15:03:19 <Igloo> dcoutts: Yup
15:04:51 <jcreigh> Lemmih, dcoutts: thanks. I started reading the docs for that function, and my eyes must have glazed over after "Suspends the current thread fora given number of..."
15:09:39 <dons> dcoutts: i think ikiwiki might have darcs support already
15:10:10 <dcoutts> dons, but what I really want is to let anyone send in patches to haskell code
15:10:11 <dons> would be a nice little project though, a wiki frontend to a darcs repo
15:10:14 <dons> yes
15:10:32 * Heffalump thinks the attitude to take is a darcs backend to an (existing) wiki
15:10:52 <dons> dcoutts: did you see the CEAN link? (erlang hackage?)
15:11:01 <dcoutts> eg, we're hosting our Gtk2Hs tutorials in darcs in the txt2tags format. ndm said we should use a wiki, but it seems to me we could get the best of both.
15:11:33 <dcoutts> dons, I didn't, I just google for "CEAN erlang" do I?
15:11:52 <phas> hi dcoutts
15:11:59 <dcoutts> hello phas
15:12:08 <dons> http://cean.process-one.net/
15:12:11 <lambdabot> Title: Comprehensive Erlang Archive Network
15:12:14 <phas> i'm getting mad with my binding :|
15:12:27 <phas> but is the library that is messy
15:15:13 <phas> if i have a pointer to a struct
15:15:25 <phas> and i have to access to a member of the struct with #peek
15:15:46 <phas> i have to... uh, i don't know the term... "*-ate" the pointer right?
15:16:37 <dcoutts> dons, yes it looks like ikiwiki nearly has darcs support
15:16:38 <dcoutts> http://ikiwiki.kitenet.net/about_rcs_backends.html#index3h2
15:16:43 <lambdabot> Title: about rcs backends, http://tinyurl.com/y4vnzr
15:17:05 <dcoutts> phas, dereference ?
15:17:15 <phas> yeah :P
15:17:16 <phas> ok
15:17:44 <dcoutts> phas, http://darcs.haskell.org/gtk2hs/gtk/Graphics/UI/Gtk/General/Structs.hsc
15:17:46 <lambdabot> http://tinyurl.com/vuuve
15:17:53 <dcoutts> that has some examples you might find helpful
15:17:57 <phas> i love you
15:18:03 <dcoutts> heh
15:19:54 <phas> i think that haskell *seriusly* need a "examples page"
15:20:01 <phas> (not only haskell, in fact)
15:20:43 <dons> phas: we have an examples page...
15:21:01 <dons> click on 'Example code' on haskell.org
15:21:20 <dons> ?wiki Example_code
15:21:21 <lambdabot> http://www.haskell.org/haskellwiki/Example_code
15:21:27 <phas> ok eheh
15:21:36 <phas> yes i know it
15:22:02 <phas> but it's not very exaustive
15:22:23 <phas> and i think that varius examples should be linked in the Hierarchical Library
15:24:45 <dcoutts> a list of links to interesting source code might help
15:25:41 <dcoutts> real examples of various techniques
15:25:52 <phas> yeah! and various tools
15:26:04 <phas> hsc2hs p.e.
15:26:59 <phas> but in Hierarchical Library itself many functions aren't described and there's no single example on how use them
15:27:05 <mbishop> What is "Literate Haskell"?
15:27:07 <phas> fortunately Haskell is very clear
15:28:06 <LordBrain> literate haskell files have .lhs extensions usually, you can write arbitrary text in there to document what you are doing, everything is a comment unless it's prefixed with a >
15:28:56 <Botty> it's a style that promotes good documentation
15:28:57 <LordBrain> so literate haskell is just a text file, with some haskell embedded, but in such a way that it can be parsed
15:30:14 <Botty> if the arbitrary text is latex (perhaps other things as well?) you can generate prettyprinted documentation
15:34:04 <Dubber> mbishop: literate programming is an idea that hasn't really gone anywhere
15:41:51 <Dubber> because most people don't write programs with the main goal of publishing them in a journal
15:41:52 <dcoutts> Dubber, we use it in programming practicals so that the students can have their report and their code all in one file.
15:43:15 <Botty> well, its handy if you really want to understand a lib well
15:43:21 <Dubber> and if the tex source code is the gold standard for LP, the idea should be banished from the face of the earth
15:44:03 <Dubber> comments about a programmer's stream of consciousness are useless to anyone else
15:44:11 <Dubber> and tex is full of that
15:44:34 <Heffalump> the darcs source uses literate Haskell, FWIW
15:45:24 <monochrom> No one says literate programming must record a stream of consciousness.
15:45:34 <dcoutts> Heffalump, would you say darcs make good use of it?
15:45:52 <monochrom> If you see it actually happen, that is because most coders are poor writers to begin with.
15:46:07 <Heffalump> to what little extent I've read the source, yes
15:46:51 <monochrom> Most coders are poor writers.  There is a reason they become coders rather than journalists.
15:47:31 <dcoutts> and often they don't much practise or feedback on their writing
15:47:56 <dons> yeah. maybe we should have 'document a library' tests at uni
15:47:56 * dcoutts will be back later
15:48:02 <monochrom> Just look at coders blogs and you'll see.
15:48:11 <dons> and judge for style and accuracy how well they document the code
15:48:16 <dcoutts> monochrom, rate me! rate me!
15:48:24 <monochrom> Perhaps I am just strengthening Dubber's point. :)
15:48:36 * dcoutts finds a stream-of-consciousness blog post ...
15:48:44 <shapr> d00d
15:48:49 <shapr> @seen shapr
15:48:50 <lambdabot> You are in #haskell, #ScannedInAvian and #haskell-blah. I last heard you speak just now.
15:48:54 <monochrom> I am both a good programmer and a good writer.  Literate programming in my hand does wonders.
15:48:55 <pejo> Bear in mind that plenty of people don't speak english as their native tongue.
15:48:58 <dcoutts> @slap shapr
15:48:59 * lambdabot slaps shapr
15:49:00 <shapr> yow!
15:49:29 <shapr> Dubber: I like literate programming. I think it's great!
15:49:35 <monochrom> Knuth is a marvelous programmer and marvelous writer.  Literate programming in his hand is music.
15:50:15 <shapr> I think my writing is better than my coding.
15:50:18 <dcoutts> shapr, how do I motivate people to contribute to some documentation?
15:50:41 <dcoutts> shapr, I've been trying to get help with a Gtk2Hs intro tutorial for the best part of a year.
15:50:49 <shapr> Ask them to teach their relatives how to use the library.
15:50:55 <monochrom> One could propose testing students' ability of documentation.  The problem is: who will grade them?
15:51:22 <shapr> The other students should.
15:51:26 <dcoutts> monochrom, why do you think it's much different to grading code?
15:51:41 <monochrom> Because there is a machine for grading code. :)
15:51:51 <dcoutts> monochrom, yeah, me. :-)
15:51:56 <Botty> lol
15:51:59 <shapr> I've learned the most about documentation by teaching others how to use something.
15:52:12 <shapr> I taught my sister some Haskell a few days ago, and she had a lot of really basic questions.
15:52:30 <monochrom> I think shapr's is an excellent solution to the problem I stated.  I now have hope.
15:52:31 <Dubber> programmers who don't comment really should be fired on sight
15:52:48 <shapr> It really depends on the quality of the comments.
15:52:59 <Botty> really depends on the quality of the code :)
15:53:00 <shapr> I once had to work on a program that was commented badly, and in Finnish.
15:53:01 <dcoutts> shapr, mm. This is part of the problem. I not necessarily the best person to write an intro tutorial since I have a completely different perspective on Gtk2Hs to a new user.
15:53:07 <Dubber> if there aren't any, then the quality is zero
15:53:18 <shapr> Dubber: I disagree.
15:53:26 <Dubber> shapr: you're fired
15:53:30 <Botty> yeah, alot of code is self documenting
15:53:31 <dcoutts> hah hah
15:53:32 <shapr> Good thing I don't work for you.
15:53:51 <monochrom> Incidentally it's also the answer to "how much detail and rigour should I hand in in my proofs?"  A great teacher of mine says, "yeah that's a tough question, but imagine your classmate trying to make sense out of your proof..."
15:54:00 <Botty> yeah christ, you'll just get crappy coders who spend all day writing c++; //Increments variable c
15:54:03 <dcoutts> Botty, yes, quite a bit. Though only at one level of detail.
15:54:04 <shapr> dcoutts: So, teach your sister how to use Gtk2hs, and everytime she asks a question, write that down.
15:54:14 <Dubber> Botty: fire them too
15:54:24 <dcoutts> shapr, the other thing, is I want external contributers. I have enough to do :-)
15:54:36 <shapr> hm
15:54:39 <dcoutts> shapr, I've been emailing gtk2hs-users list trying to recruit people :-)
15:54:40 <Botty> Dubber - then you've ruled out the good and the bad
15:54:41 <Dubber> shapr: good thing you don't work for me
15:54:44 <shapr> Dubber: truly
15:54:45 <dcoutts> we'll see what happens this time.
15:54:59 <dcoutts> typically we just get discussion of tools
15:55:01 <Dubber> Botty: eh, no, not at all
15:55:03 <shapr> Thing is, the comments are not the spec, the code is the spec.
15:55:08 <blsecres> was the gtk2hs tutorial posted on haskell cafe the other day decent?
15:55:18 <Botty> Dubber  - true, but willing employees will be hard to find
15:55:23 <shapr> If understandable docs could be automatically derived from executable code, then you'd have something good.
15:55:29 <dcoutts> blsecres, I've improved it and it's now hosted on the gtk2hs site.
15:55:43 <shapr> But comments don't always change when code changes.
15:55:52 <shapr> And in that case, they're misleading instead of helpful.
15:55:57 <dcoutts> blsecres, I'm just waiting for the original author to ok it and then I'll link it from the docs page.
15:55:57 <Botty> I comment when I do something that is tricky, or the code doesn't speak for itself
15:56:10 <shapr> Bad comments cost more work than no comments at all.
15:56:12 <Dubber> before someone can write understandable comments he has to understand what the code is doing himself.  and a lot of programmers in the industry, frankly, don't.
15:56:30 <dcoutts> blsecres, but that's not quite the same as an intro tutorial. It's a great step-by-step guide to getting started with glade though.
15:56:31 <shapr> Dubber: Can we see some of your Haskell code in order to get a feel for your standards?
15:56:33 <Botty> so my code has fewer comments than most, but I spend more time making the code understandeable
15:56:46 <Botty> Dubber - true
15:56:48 <Dubber> I do not write haskell code
15:56:52 <shapr> Dubber: Ah, I see.
15:57:09 <pejo> Dubber, if people have no clue how their code works - how can it work at all? There must have been a (vague) specification they started from.
15:57:09 <Dubber> shapr: also if you don't get out of here I'm calling security
15:57:13 <shapr> I think that you may underestimate the readability of high level code.
15:57:19 --- mode: ChanServ set +o shapr
15:57:22 <shapr> security is here
15:57:26 <Dubber> hey take it easy
15:57:37 <Botty> That's the main problem of programming, actually, fully understanding the problem and its solution in entirety
15:57:52 * mbishop prostrates himself on the ground
15:57:58 * shapr grins
15:58:03 <dcoutts> hah hah hah
15:58:03 <Dubber> pejo: who said it worked
15:58:11 <dons> ok documentation fiends, if you think the libraries are lacking in documentation, please note where and how HERE! :
15:58:15 <dons> http://haskell.org/haskellwiki/Improving_library_documentation
15:58:17 <lambdabot> Title: Improving library documentation - HaskellWiki, http://tinyurl.com/yaokls
15:58:24 <dons> and then we can improve it.
15:58:42 <dons> its hard to know what needs improving unless all the eyes out there reading the haddocks tell us
15:58:54 <dcoutts> dons, and with a wiki interface to the darcs repo we can write haddock docs directly and send them in :-)
15:58:58 <shapr> Dubber: In my experience, high level code (Haskell is one example) is more readable than low level code like C.
15:59:00 <dons> yeah
15:59:03 <shapr> dcoutts: Oh yeah!
15:59:23 <dcoutts> shapr, we were discussing that before you popped by
15:59:24 <dons> yeah, random web people can contribute doc patches
15:59:34 <shapr> Oh, I should read the log?
15:59:36 <dons> (a bit like pugs' cheap commit bits for testing)
15:59:53 <dcoutts> dons, yeah, docs are one of the best examples where you need very low barrier to contribution to get things improved
15:59:58 <shapr> truly
16:00:03 <dcoutts> because many fixes are just one line or so
16:00:05 <shapr> Dubber: Are you learning Haskell?
16:00:09 <dons> right
16:00:13 <dcoutts> but you also need editorial oversight
16:00:42 --- mode: shapr set -o shapr
16:00:47 <Botty> I would contrib to the docs if they were wikied
16:01:03 <shapr> Yeah, I'd contribute more if they were wiki accessible.
16:01:32 <dcoutts> I'd suggest not actually making them into a wiki, but let people record and send darcs patches via a web interface
16:01:43 <Dubber> shapr: I have a purely academic interest in haskell
16:01:50 <monochrom> is mtl part of base?
16:01:50 <shapr> Dubber: Oh?
16:01:59 <shapr> Dubber: Does that mean you're taking a class in Haskell?
16:02:05 <Dubber> no it does not
16:02:06 <dcoutts> monochrom, no, it's the "mtl" package
16:02:27 <shapr> Dubber: Does that mean you don't actually want to learn the language, but you're just here to spread your opinions?
16:02:42 <Dubber> what
16:02:57 <shapr> Or maybe you have some specific questions about Haskell that I could help you with?
16:02:59 * dcoutts needs to reboot to make his dvd drive work :-(
16:03:00 <monochrom> what is purely academic interest?
16:03:07 <shapr> dcoutts: I have that problem
16:03:16 <dcoutts> aye, it's a pita, later folks
16:03:38 <shapr> Dubber: Yeah, just that. What do you mean when you say that you have a purely academic interest?
16:04:46 * shapr pokes Dubber 
16:04:55 * Dubber giggles
16:05:04 <shapr> Dubber: So, what would you like to learn about Haskell?
16:05:50 <Excedrin> in the "roll your own irc bot" it mentions using forkIO to add a command line interface, it's not clear what should be forked, any hints?
16:06:14 <monochrom> * Dubber giggles. Learning Haskell? I'm SPJ, don't you see?!
16:07:12 <Korollary> ?time Dubber
16:07:13 <lambdabot> Local time for Dubber is Sat Nov 25 2006 4:03pm
16:07:25 <Korollary> Pacific time
16:07:47 <dons> Excedrin: forkIO the loop that reads from stdin
16:08:07 <dons> that way you can have network stuff handled in a separate thread to the command line
16:08:57 <dons> mmm. I think a docu-fest should be part of Hac07 too
16:09:11 <Excedrin> dons: ok, but that loop needs the handle to the socket, so it can write stuff to the server, right?
16:09:19 <dons> right
16:09:31 <dons> so: forkIO $ runST myloop st
16:09:35 <dons> for example
16:09:44 <Heffalump> that can't be type correct, can it?
16:09:52 <Heffalump> @type (forkIO, runST)
16:09:53 <lambdabot> Not in scope: `forkIO'
16:09:54 <lambdabot>  
16:09:54 <lambdabot> <interactive>:1:9: Not in scope: `runST'
16:09:57 <Korollary> Yeah, a wiki is better than darcs patches for docs.
16:10:15 <dons> not runSt, runStateT
16:10:26 <Dubber> I tried to look at some of that darcs code but the site was too slow
16:10:28 <Heffalump> ahh :-)
16:10:43 <Heffalump> what URL?
16:10:58 <Dubber> the one I got by googling darcs
16:11:21 <Heffalump> would pasting it to the channel be beneath you?
16:11:35 <Dubber> I don't have it at hand
16:11:53 <Korollary> the darcs wiki was hosed earlier today
16:12:01 <shapr> black friday darsc?
16:12:24 <Heffalump> hmm, http://abridgegame.org/cgi-bin/darcs.cgi/darcs/Add.lhs?c=annotate just sits there for me
16:12:48 <dons> shapr: do you see we now have .es and ro (romanian) transations underway for haskell.org?
16:12:51 <pejo> Heffalump, if that is the same as darcs.net it's out of qouta.
16:12:54 <Heffalump> Dubber: you could just download the source instead
16:13:00 <Heffalump> pejo: ah :-(
16:13:39 <shapr> dons: Wow, that's amazing
16:14:04 <Heffalump> hmm, way past my bedtime
16:14:07 <dons> its audreyt's cheap commit bit principle at work
16:14:09 * Heffalump disappears
16:14:32 <lambdabot> http://tinyurl.com/y7dorx
16:17:12 <shapr> SamB_XP: see your privmsgs?
16:17:19 <SamB_XP> yeah
16:17:45 <SamB_XP> I also see scrollback. I should have tried the /lastlog thingy, but I hadn't thought of it...
16:22:49 <xinming> glguy: I'm sorry for that I didn't reply, I wasn't at computer.
16:22:50 <lambdabot> xinming: You have 1 new message. '/msg lambdabot @messages' to read it.
16:27:56 <sreeram> hi all, i have a question about typeclasses from a language design perspective. i know that typeclasses let you do ad-hoc poly-morphism. What are the pros/cons of using typeclasses to achieve ad-hoc polymorphism?
16:28:32 <dons> sreeram: they make ad hoc polymorphism less ad hoc
16:28:55 <sreeram> dons, do they in particular make type inferencing easier?
16:28:57 <dons> since you can simply create new bounded polymorphic functions define over a set of types
16:29:30 <dons> hmm. they'd make type inference a little harder than not having them...
16:30:05 <dons> for more information, I recommend: http://haskell.org/haskellwiki/Research_papers/Type_systems#Type_classes
16:30:08 <lambdabot> Title: Research papers/Type systems - HaskellWiki, http://tinyurl.com/yan24w
16:30:14 <dons> in particular, http://homepages.inf.ed.ac.uk/wadler/papers/class/class.ps.gz
16:30:17 <lambdabot> http://tinyurl.com/uvmh4
16:30:22 <dons> and http://www.cse.ogi.edu/~mpj/pubs/springschool.html
16:30:26 <lambdabot> Title: Redirect: Web resource has moved, http://tinyurl.com/yygdy8
16:30:37 <sreeram> thanks
16:30:46 <dons> which is apparently here now: http://web.cecs.pdx.edu/~mpj/pubs/springschool.html
16:30:54 <dons> (classic paper on typeclasses)
16:30:55 <lambdabot> Title: Functional Programming with Overloading and Higher-Order Polymorphism, http://tinyurl.com/yzsecv
16:38:42 <dons> I'm so glad, we've had > 2000 hits to the 'how to write a haskell project' page in the last week. i hope that means we'll see 2000 new libraries and apps,  http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
16:38:45 <lambdabot> Title: How to write a Haskell program - HaskellWiki, http://tinyurl.com/yxe296
16:43:02 <Excedrin> a lot of those hits are probably reddit people who read the first paragraph to find out what it's about and then split
16:44:06 <dons> yep :)
16:44:18 <dons> (hmm, though it wasn't posted to reddit was it?)
16:44:27 <dons> maybe it got mentioned in passing
16:44:53 <dons> i've seen 3 or 4 newbies on the mailing list asking about the process on that page though, so that's a good sign
16:44:58 <dons> lower the barriers to contributing!
17:10:21 <umike7> hello all! can anyone with small newbie problem. i want to read two args and print their sum to console, but can't understand how to use read to convert args !! 0 to int ?
17:11:32 <Svrog> convert a string to an int?
17:11:51 <Svrog> (read "3")::Int
17:13:31 <dons> > do [x,y] <- getArgs ; print (read x + read y)
17:13:32 <lambdabot>  Not in scope: `getArgs'
17:13:34 <umike7> yes, something like num1 <- (read args !! 0) :: Int
17:13:39 <psykotic> you probably want the Maybe Int instance though
17:14:05 <psykotic> well for a simple app like that it's probably okay to bail out the whole program if there's a read error :)
17:14:15 <dons> > let args = ["1","2"] in map read args :: [Integer]
17:14:16 <lambdabot>  [1,2]
17:14:21 <dons> > let args = ["1","2"] in sum (map read args :: [Integer])
17:14:23 <lambdabot>  3
17:14:30 <lisppaste2> Svrog pasted "how do I go about making this run faster?" at http://paste.lisp.org/display/30705
17:14:43 <psykotic> > (read "x") :: Int
17:14:44 <lambdabot>  Exception: Prelude.read: no parse
17:14:53 <psykotic> > (read "x") :: Maybe Int
17:14:55 <lambdabot>  Exception: Prelude.read: no parse
17:15:07 <dons> Svrog: can you profile it first?
17:15:12 <Svrog> i did
17:15:18 <dons> paste the prof then
17:15:27 <dons> (and you're using -O -funbox-strict-fields ?)
17:15:29 <Svrog> ok - ill paste the c version i was translating this from too
17:15:43 <Svrog> im using -O but not -funbox-strict-fields
17:15:46 <dons> (you might have gone overboard with the strictness annotations ;)
17:16:02 <lisppaste2> Svrog annotated #30705 with "test code" at http://paste.lisp.org/display/30705#1
17:16:05 <dons> oftimes, a new strict types is better than a tuple
17:16:14 <dons> i.e. data T = T !Int !Int !Int
17:16:21 <lisppaste2> Svrog annotated #30705 with "C code" at http://paste.lisp.org/display/30705#2
17:16:25 <dons> mixer (T  a b c) = ...
17:16:34 <Korollary> It could be nice to have sugar for strict tuples.
17:16:49 <dons> yeah, we're planning an entire strict prelude type module
17:16:57 <dons> with strict pairs, strict sums , eithers, ...
17:17:04 <Korollary> ah
17:17:04 <dons> its very useful in the array fusion stuff, and elsewhere i suspect
17:17:06 <Svrog> currently the c code runs about 20 times faster :(
17:17:08 <dons> module Data.Strict
17:17:17 <dons> Svrog: ok, you can definiitely catch that a bit
17:17:27 <Igloo> You'll need language changes to have nice tuple sugar, though
17:17:28 <dons> I'd hope for 1-4x C in practice
17:17:52 <Korollary> Igloo: Yes. They're in the grammar.
17:17:56 <dons> data a :*: b = !a :*: !b -- is ok
17:18:45 <Korollary> Although I am not a big fan of tuples. (a,b) is too anonymous. data declarations serve as better documentation.
17:19:14 <psykotic> Korollary, i guess there's always that trade-off. same with Either, really.
17:19:54 <Korollary> type synonyms also help
17:20:08 <psykotic> my rule of thumb is that if i only need something for "internal" purposes (e.g. the "state seed" of a fold) i'll use tuples, otherwise i'll go for an ADT.
17:20:25 <lisppaste2> Svrog annotated #30705 with "profile" at http://paste.lisp.org/display/30705#3
17:21:15 <psykotic> Korollary, it's not just the documentation, it's also the fact that you are getting less use out of the type inference/checking.
17:22:03 <Korollary> psykotic: true. Perhaps a version of newtype that doesnt clutter with the explicit coercions?
17:22:59 <psykotic> btw you can always tell if a new haskell programmer is from a lisp/scheme program by looking at whether they overuse tuples/lists :)
17:23:04 <psykotic> (i did)
17:23:12 <psykotic> err, background, not program
17:23:25 <Korollary> You can also do the inverse
17:23:44 <Svrog> btw after recompiling ghc 6.6 from sources -N still doesnt work
17:23:57 <psykotic> an ml/haskell program moving to lisp you mean? always using explicitly declared record types rather than cons lists?
17:24:28 <Korollary> psykotic: probably. My (few) scheme programs probably look awkward to other schemers.
17:25:48 <Svrog> dons: i.e. data T = T !Int !Int !Int <-- should i use data or newtype for that?
17:26:07 <Svrog> does it matter?
17:26:28 <Botty> > unwords ["Hello", "World!"]
17:26:30 <lambdabot>  "Hello World!"
17:28:00 <Korollary> hmm, by saying other I almost implied that I was one myself.
17:28:06 <Korollary> need a drink
17:28:27 <Svrog> and regarding strictness annotations - yeah i know ive gone overboard - did that in desparation when nothing else i tried worked hehe
17:28:57 <Svrog> they dont seem to make it run any slower
17:31:38 <umike7> do let args = ["1", "2"]; print (read x + read y)
17:31:47 <umike7> >do let args = ["1", "2"]; print (read x + read y)
17:34:38 <umike7> why such construction doesn't work ? putStrLn("Result: " ++ show(num1 + num2))
17:36:00 <umike7> num1 and nu,2 integers ... let num2 = read y :: [Integer]
17:37:22 <dancor> > let x = "4"; y = "5" in putStrLn (read x ++ read y)
17:37:23 <lambdabot>  <IO ()>
17:37:35 <dancor> > let x = "4"; y = "5" in putStrLn $ show $ read x + read y
17:37:36 <lambdabot>  <IO ()>
17:38:12 <dancor> > let x = "4"; y = "5" in show $ read x + read y
17:38:13 <lambdabot>  "9"
17:39:50 <dancor> > let x = "4"; y = "5" in sequence $ [putStrLn $ show $ read x + read y]
17:39:51 <lambdabot>  <IO [()]>
17:40:11 <dancor> lambdabot will not do my io
17:40:21 <SamB_XP> dancor: it isn't supposed to
17:40:22 <Botty> it's not supposed to
17:41:16 <Svrog> ok - replacing the tuple with a strict type and adding -funbox-strict-fields made it go a bit faster - now it's 10 times slower than the c code
17:41:40 <Botty> whoah, that's interesting.  "it isn't", "It's not", "It is not"
17:42:07 <eviltwin_b> english is fun :>
17:43:16 <Botty> interesting how 'is' can be compounded with either of two adjacent words in that sentence
17:43:41 <Korollary> Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo
17:45:16 <dylan> I really dislike the construction "do not <verb>" being used when "<verb> not" would suffice.
17:46:04 <Svrog> Buffalo from Buffalo that buffalo from Buffalo buffalo also buffalo buffalo from Buffalo :)
17:46:10 <Botty> seems to me like "<verb> not" is a rather awkward construction (as a native english speaker)
17:46:24 <Botty> kinda yoda like
17:46:33 <blsecres> we Anglos love our helper verbs
17:46:45 <dancor> ask not
17:47:41 <Botty> yeah, i suppose its used in speeches ("Ask not what your country can do for you, but what you can do for your country")
17:48:09 <dancor> may not, cannot, shouldn't, will not, have not
17:48:16 <dancor> supposed is a verb
17:49:01 <Botty> Hmm, I think the difference is if its command form or not
17:49:35 <eviltwin_b> just a rhetorical form, I think
17:49:45 <dylan> Actually
17:50:01 <dylan> "verb not" only fell out of favor relatively recently.
17:50:09 <Korollary> german has verb not.
17:50:20 <dylan> English does too -- "do not" is not a special case.
17:50:53 <dancor> english has <helper> <neg> <main verb>
17:51:26 <dylan> Or <neg> <verb>, I think it's the passive voice, but it's been a while since I studied that.
17:53:37 <dons> Svrog: i'd use a newtype
17:53:38 <dylan> Does anyone else write "can't" or "won't", but speak/subvocalize that as "can not" and "will not"?
17:54:15 <eviltwin_b> I only use the latter forms in formal writing
17:54:21 <blsecres> I rarely write contractions unless it's a SMS or short email
17:54:27 <Svrog> yeah - only after i asked that question and tried using newtype i got an error that newtype only works for wrapping single values and i have 4 heh
17:55:24 <Svrog> ok - managed to get it to the point where it's now 5 times slower
17:55:27 <Svrog> not sure what to do next
17:55:56 <lisppaste2> Svrog annotated #30705 with "what next?" at http://paste.lisp.org/display/30705#4
17:58:10 <Svrog> umm.. actually no - it's still roughly 10 times slower :(
18:00:25 <twanvl> The problem could be in the shifts, there were was a mailing list thread about their performance recently
18:00:42 <Svrog> hmm
18:06:10 <dylan> @docs System.Posix
18:06:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix.html
18:12:12 <Cale> @define unfoldr' p f g = map f . takeWhile p . iterate g
18:12:12 <lambdabot> (line 1, column 8):
18:12:13 <lambdabot> unexpected "="
18:12:13 <lambdabot> expecting var, "head", "tail", "null", bool, num, character, "[", string, "(", operator, simple term or end of input
18:12:28 <Cale> @list
18:12:29 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
18:12:43 <Cale> oh right
18:12:48 <Cale> @let unfoldr' p f g = map f . takeWhile p . iterate g
18:12:49 <lambdabot> Defined.
18:13:17 <Cale> @let unfoldr2 c = unfoldr' isJust (fst . fromJust) (c . snd . fromJust) . c
18:13:19 <lambdabot> Defined.
18:13:39 <Cale> > L.unfoldr2 (\x -> guard (x > 0) >> return (x, x-1)) 10
18:13:41 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
18:14:23 <Cale> > unfoldr (\x -> guard (x > 0) >> return (x, x-1)) 10
18:14:24 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
18:14:59 <Cale> > L.unfoldr' (> 0) id (+ (-1)) 10
18:15:00 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
18:15:14 <Cale> equivalent :)
18:15:30 <Svrog> hehe cool
18:18:59 <Cale> hmm, maybe not :)
18:19:20 <Cale> no, it works fine
18:19:34 <Cale> > L.unfoldr2 (\x -> guard (x > 0) >> return (2*x, x-1)) 10
18:19:36 <lambdabot>  [20,18,16,14,12,10,8,6,4,2]
18:25:28 <wferi> Hi! If I'd like to have a separate scanner in front of my Parsec parser, am I really bound to implement the scanner itself in Parsec to be able to get SourcePos values for passing them to the parser? I mean the second argument of Parsec.token has type tok -> SourcePos, so tok must contain a SourcePos, the constructor of which isn't exported.
18:29:19 <Cale> newPos :: SourceName -> Line -> Column -> SourcePos
18:29:20 <eviltwin_b> you can use the functions in ParsecPos to update an existing SourcePos, e.g. to reflect what your subsidiary parser returns as the current source position
18:29:45 <Cale> @hoogle newPos
18:29:46 <lambdabot> Text.ParserCombinators.Parsec.Pos.newPos :: SourceName -> Line -> Column -> SourcePos
18:29:59 <eviltwin_b> huh.  not documented
18:30:07 <Cale> No, it's in the GHC documentation
18:30:11 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec-Pos.html
18:30:13 <lambdabot> http://tinyurl.com/y45sfj
18:30:19 <Cale> also,
18:30:27 <Cale> @hoogle initialPos
18:30:27 <lambdabot> Text.ParserCombinators.Parsec.Pos.initialPos :: SourceName -> SourcePos
18:30:29 <eviltwin_b> ah.  I use the original docs as a reference, but I guess that's 5 years old now
18:30:57 <Cale> yeah, they're still quite good though, it would be nice if someone merged them
18:31:48 <wferi> Thanks, guys... are these functions available from the very beginnings of Parsec?
18:32:05 <Cale> hm?
18:32:17 <Cale> I don't know if they were always there, but they're in Parsec now
18:32:39 <wferi> ok, thanks, again.
18:33:29 <newsham> lots of haskell fans praise haskell for promoting correctness, but then they use parsec which allows ad-hoc parser creation.  I dont get it.
18:34:08 <newsham> parsec lets you build parsers that have subtle flaws in them, that dont have a clear, easy to read grammar.
18:34:27 <wferi> what do you recommend? I'm all ears.
18:34:53 <Cale> You can always write code which is incorrect -- what in particular are you referring to?
18:35:06 <newsham> I think any more traditional parser generator that takes in a CFG and generates code for a parser (not familiar with them in haskell.. isnt happy like that?)
18:35:16 <Cale> happy is like that
18:35:32 <newsham> cale: for example, if you dont properly specify that backtracking is needed over an alternation of two parsers
18:35:44 <newsham> you will get a parser which doesnt parse the language you had intended it to parse
18:35:57 <Cale> Sometimes :)
18:36:14 <eviltwin_b> you can make the same general kind of mistakes with any parser generator, though
18:36:19 <Cale> Sure, you only have one token of lookahead by default.
18:36:19 <newsham> more generally, there is no assurance that the parser you write parses he grammar you intended
18:36:36 <eviltwin_b> you're welcome to come up with a Ph.D project in parser theory to resolve this :)
18:36:48 <newsham> if you generate code from a parser spec, you can have a fairly good assurance that the parser parses the grammar you entered
18:37:20 <Cale> You could use ReadP
18:37:42 <Cale> Normally, it's enough just to remember that <|> in parsec is not symmetric.
18:38:06 <newsham> sure.. i'm not saying its not usable.. you can still write good software with it.
18:38:43 <newsham> but i think having mechanisms that give you high assurances (ie. generator from grammar, strong type checking, pre-/post- conditions, etc.) are good things
18:38:48 <Cale> If you treat it like you're entering a CFG, then of course it will seem "broken"
18:38:55 <newsham> and ad-hoc parsing is a step backwards
18:39:05 <newsham> (just cause its monadic and we like monadic things)
18:39:25 <Cale> It's not quite ad-hoc either, it's just another system. Perhaps not quite as good for some purposes.
18:41:22 <wferi> Why don't people use UUParsing or ReadP instead to avoid the famous <|> trick of Parsec?
18:41:49 <Svrog> i like parsec because it's all done from within the language, no other tools required - i'm not quite sure what you mean by ad-hoc, you still have strong type checking and all, in fact you have the type system on your side
18:41:59 <Cale> because it's slower, and those libraries don't provide quite as nice error messages
18:42:25 <blsecres> ...and Parsec has good documentation
18:42:26 <Cale> http://en.wikipedia.org/wiki/Parsing_expression_grammar -- this is what Parsec really gives you, as opposed to a CFG.
18:42:30 <lambdabot> http://tinyurl.com/y4mbzg
18:43:07 <newsham> parser generator from a CFG is a formal method.  i agree that combinator parsing is "another system", but I think you'd be hard pressed to say its a formal system (especially since there are no tools that specify when backtracking may be needed, or what the language actually being parsed is)
18:44:11 <Cale> (well, almost)
18:45:18 <newsham> (I agree that its not that hard to use, and you can write up some parsers pretty quickly using it, and it integrates beautifully with the rest of haskell code since it is itself haskell code...  but i wouldnt want to trust my life to it :)
18:45:20 <Svrog> hmm.. i dont follow. what the language being parsed is?
18:45:52 <newsham> svprog: given a parser written with parsec, can you tell me formally what the grammar accepted by the parser is?
18:46:29 <Svrog> formally?
18:46:44 <newsham> ie:  while(lookahead == 'a') next(); if(lookahead == 'b') accept();    will accept the language "a*b"
18:46:44 <Svrog> parsec roughly translates to bnf
18:46:50 <Cale> Is there an algorithm which determines whether the language given by a particular CFG is inherently ambiguous?
18:46:58 <Svrog> the code pretty much looks like bnf
18:47:09 <Cale> Svrog: only it's not the same as BNF
18:47:10 <newsham> cale: i think that's an undecidable property.
18:47:16 <Svrog> well no
18:47:26 <Svrog> but you could say the same about any parser generator
18:48:02 <Cale> Well, there's an important difference. If you write p <|> q, that's not really the same as p | q in BNF
18:48:12 <Svrog> true
18:48:40 <Cale> p is tried first, and if it manages to eat even one character before failing then the whole expression fails
18:48:53 <Svrog> still though to me it sounds like the argument is more about the implementation of parsec, rather than the idea behind it
18:49:02 <Cale> If it doesn't manage to eat a character, then q is tried.
18:49:06 <Svrog> the limitations and compromises made for the existing implementation
18:49:20 <Cale> Yeah, it's possible to get symmetric choice
18:49:26 <Cale> (Look at ReadP)
18:49:56 <jcreigh> is ReadP distinct from Parsec, or an extension to it?
18:50:03 <Cale> distinct
18:50:06 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text-ParserCombinators-ReadP.html
18:50:09 <lambdabot> http://tinyurl.com/uo5wd
18:51:03 <Svrog> is readP newer? dont think ive ever seen that before
18:51:10 <Cale> slightly
18:51:13 <Svrog> ah
18:51:29 <Cale> It's been around for at least a couple of years now
18:51:34 <Svrog> ah
18:51:35 <Svrog> haha
18:52:02 <augustss> readP is very cool.  same idea as parsek (not parsec)
18:52:14 <Cale> Yeah, Parsek is pretty nice too.
18:52:18 <newsham> the parsec parser is recursive decent and requires left factoring, right?
18:52:33 <newsham> (which is why the expressions are handled with their own little lib)
18:52:34 <Cale> newsham: this is true of any monadic parser
18:52:48 <Cale> newsham: actually, you can just use chainl for them
18:53:11 <Cale> The expression parsing thing is sort of just a useful example of what can be done with the primitives.
18:53:14 <augustss> but yes, you do need to left factor the grammar in one way or another
18:53:46 <augustss> or at least avoid left recursion
18:54:24 <Cale> Of course, you could probably write a function which would take some value representing a CFG and give you a Parsec parser for it if you wanted.
18:54:43 <Cale> (maybe even do the left-factoring for you)
18:54:48 <newsham> i'm a fan of GLR parsers because they can handle any grammar without modification.  less chance for programmer error,  less demands on programmer time.
18:55:08 <SamB_XP> of course, it would most likely not give you any AST...
18:55:24 <Cale> newsham: But do they give you really efficient parsers?
18:55:49 <newsham> sam: when transforming the grammar you can add code to do the inverse transform on the constructed parse trees to recover the ast shape you want
18:56:12 <newsham> cale: worst case performance poor, but "normal" performance pretty close to linear.
18:56:28 * SamB_XP doesn't remember CFGs having parse trees of any useful sort
18:56:37 <augustss> worst case n^3?  like Earley.
18:56:44 <Cale> yeah
18:56:47 <Svrog> hmm.. so with ReadP in the standard library, is there any reason at all to continue using Parsec?
18:56:55 <newsham> i think the more popular GLRs worst cases are exp, not n^3.
18:57:11 <augustss> Parsec has quite a few useful things on top of the primitives
18:57:31 <SamB_XP> also, error messages are nice to have
18:57:52 <newsham> you can still have error productions
18:57:53 <Svrog> other than that is ReadP more limited in some way?
18:58:14 <Cale> Svrog: performance is not quite as good
18:58:19 * SamB_XP wasn't talking about GLR
18:58:22 <Svrog> fair enough
18:58:25 <newsham> oh
18:58:29 * SamB_XP was talking about Parsec over ReadP
18:58:38 <Svrog> i might switch over the ReadP then
18:58:39 <dons> Svrog: how you going now with your bit shifting code?
18:58:46 <Svrog> not good :(
18:58:49 <Svrog> still 10 times slower
18:58:56 <newsham> * SamB_XP doesn't remember CFGs having parse trees of any useful sort
18:58:57 <dons> ok. we can definitely do better
18:59:06 <dons> would you like to post it to haskell-cafe@ and ask for advice?
18:59:11 <Svrog> http://paste.lisp.org/display/30705#4
18:59:23 <newsham> ASTs are usually not too far from the simple grammar (before any massaging needed to make them LL(1) or LALR(1) or whatever)
18:59:27 <Svrog> yeah i might do that
18:59:50 <dons> I'd like you to post it to haskell-cafe@haskell.org too, since then we'll have a bit more time to consider whether its libraries, compiler or user code causing the trouble
19:00:05 <Svrog> np
19:00:08 <dons> esp. with the new improvements to the bit shifting libs
19:00:23 <Cale> newsham: Runtime modification of parsers is very handy
19:00:27 <Svrog> i compared the current version against hashString in Data.HashTable and it's a bit faster
19:01:06 <Svrog> but compared to the C version of the same function it's 10 times slower - and the C version has actually been simplified to read in 1 char at a time rather than an int at a time
19:01:06 <dons> can you also include the command line you use to compile the source
19:01:10 <dons> and the ghc version
19:01:12 <Cale> You can construct configuration files which are read in order to construct a parser for a given language, which in some cases is really nice.
19:01:14 <Svrog> so the c version can be even faster
19:01:19 <Svrog> yup
19:01:22 <Svrog> no problem
19:01:38 <dons> oh, i had some fast bytestring hash code around here somewhere..
19:01:44 <newsham> cale: you can generate GLR's at runtime too.
19:01:58 <Svrog> the actual algorithm is from http://www.burtleburtle.net/bob/hash/
19:01:58 <newsham> thats what parser compilers do :)
19:02:00 <lambdabot> Title: Hash Functions and Block Ciphers
19:02:03 <dcoutts> dons, the code from our paper?
19:02:06 <Svrog> it's one of the better hashing functions ive found
19:02:24 <Svrog> lookup3.c
19:03:23 <dcoutts> foldl' (\h c -> h * 33 + c) 5381
19:03:46 <Cale> newsham: using an embedded language? (Perhaps, but I'm unaware of an implementation)
19:04:12 <dcoutts> http://www.cse.yorku.ca/~oz/hash.html
19:05:28 <newsham> compiler compiler just maps a string to a parser table.  the parser engine is then data-driven by the table.  you can do string -> table at runtime.
19:06:04 <newsham> (or even some internal representaiton of CFG to table)
19:06:11 <Cale> newsham: I mean, in something like a combinator library.
19:07:20 <Cale> I think it's possible, but I've never seen anyone do it -- also, there are issues with typing the results of the parser.
19:07:28 <dons> dcoutts: oh, i was thinking of an old hash that used to be in Data.ByteString
19:07:56 <dcoutts> dons, oh I didn't remember there was one.
19:08:16 <dcoutts> but most hashes are just foldl's so should be easy to do outside the lib
19:08:46 <Svrog> dons: http://www.burtleburtle.net/bob/hash/doobs.html
19:08:48 <lambdabot> Title: A Hash Function for Hash Table Lookup, http://tinyurl.com/y5kykp
19:09:00 <dons> anyone want to help this guy: http://scienceblogs.com/goodmath/2006/11/query_for_readers_interested_i.php
19:09:02 <lambdabot> http://tinyurl.com/ykdpsh
19:11:04 <newsham> "A Table is actually a class rather than a datatype. Until someone implements the TemplateHaskell (hint! hint!), you will need to instantiate the class manually."  heh
19:25:44 <dons> thanks for the comments there Cale
19:41:00 <Svrog> dons: should i attach the profile in the email to haskell-cafe?
19:41:31 <Svrog> or is it enough if i just attach the code, options used to compile the code, os, ghc version
19:53:54 <newsham> i wish happs had more documentation :(
20:00:11 <robreim> dons: hs-plugins?
20:12:02 <dons> Svrog: send the profile too
20:12:04 <dons> robreim: yes.
20:13:03 <robreim> Great! Where can I get it?
20:15:07 <Korollary> @where hsplugins
20:15:07 <lambdabot> I know nothing about hsplugins.
20:15:11 <Korollary> @where hs-plugins
20:15:11 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
20:16:34 <robreim> I mean where can I get the version updated for ghc6.6
20:16:43 <robreim> Or where's the darcs repo
20:24:00 <robreim> found the repo
20:26:11 <dons> not done yet!
20:26:27 * shapr hugs dons 
20:26:44 * dons pugs shapr. oh, that doesn't work
20:26:47 * shapr grins
20:28:15 <robreim> Oh ok. Sorry, overly reliant on context :)
20:31:04 <monochrom> I have a crazy idea. Suppose someone releases a Python implementation in Haskell.  What will the Python community do?
20:32:30 <eviltwin_b> wasn't there work on a pythin byte-compiler to parrot?  how much worse can it be?
20:32:36 <eviltwin_b> er, python
20:34:44 <pkhuong> monochrom: start using the haskell FFI to have a shot at having efficient programs?
20:35:56 <monochrom> In general it will attract some Python people to Haskell.
20:36:03 <shapr> Probably not
20:36:15 <shapr> Max Skaller wrote vpython in OCaml, it just irritated people.
20:36:27 <monochrom> Really!
20:36:51 <eviltwin_b> wow
20:36:58 <monochrom> How do people react to this irritation?
20:37:14 <monochrom> And do they have a reason (good or bad) to feel irritated?
20:37:28 <shapr> Python is mostly a community centered around Guido and the other people who work on the core interpreter.
20:37:54 <eviltwin_b> so not so much because of OCaml as because "there is no Python but Python and Guido is its prophet"
20:38:02 <Svrog> why were they irritated?
20:38:09 <shapr> There's only one implementation, and it's the real 'standard'. Other implementations seem to cause cognitive dissonance.
20:38:20 <Svrog> oh
20:38:21 <wolverian> eviltwin_b, there still is, pirate.
20:38:43 <shapr> Notice that Stackless Python didn't make it into the mainline implementation.
20:39:03 <shapr> Christian Tismer had first class continuations in Python long before I knew Haskell existed.
20:39:38 <shapr> The fact that Guido and the rest of the team rejected his ideas was a big push for me to find something else to use for a primary language.
20:40:04 * eviltwin_b doesn't pay much attention to the Python community.  this just confirms it...
20:40:12 <shapr> monochrom: On the other hand, PyPy is making great progress, and is encouraged by the community, so you may have a point.
20:40:24 <shapr> PyPy is an attempt to implement Python in Python.
20:40:25 <monochrom> This irritation is another possibility I predict actually.  This is the crazy part I promised.  Perhaps an additional Haskell implementation will irritate them enough to change Python in attempt to evade easy FP implementations.  The end result is a language totally unusable.  But I see I have opened a can of worms not directly useful for #haskell.
20:42:18 <monochrom> "modified 12 seconds ago by Carl Friedrich Bolz" the PyPy news page says.  Someone's watching us?  XD
20:42:23 <shapr> I'd definitely like to have a full Python parser in Haskell, I'd use it to clean up Python code en masse.
20:43:03 <shapr> Starkiller was a neat approach to statically typed Python by Michael Salib. I tried to persuade him to rewrite it in Haskell.
20:43:47 <shapr> CosmicRay's python to haskell bridge would make it much easier. Python's built in parser module lets you get hold of internal AST values, so...
20:44:41 * shapr beats libdvdcss2 with a stick
20:45:03 <Svrog> im still puzzled how exactly python and ruby became so popular
20:45:23 <shapr> Python was very easy to teach.
20:45:30 <Svrog> yeah but no easier than smalltalk
20:45:38 <eviltwin_b> people looking for alternatives to perl that didn't have the reputation ofbeiong unmaintainable
20:45:43 <Svrog> in fact it didnt add anything smalltalk didnt already have
20:45:49 <shapr> Yeah, but Smalltalk is something that must be taught (in my experience) and Python can be self taught easily.
20:45:49 <Svrog> with the exception of more syntax
20:45:56 <Svrog> hmm
20:45:58 <Svrog> i dunno
20:46:05 <shapr> Also, Smalltalk has an image problem.
20:46:10 <Svrog> thats true
20:46:14 <eviltwin_b> and smalltalk has a repu ==shapr
20:46:31 <shapr> But I mean that punnily, in that Python works on files and directories, and Smalltalk requires an image.
20:46:48 <Svrog> oh
20:46:48 <Svrog> haha
20:46:54 <eviltwin_b> aren't there implementations that don't?
20:46:59 <Svrog> yes
20:47:08 <eviltwin_b> but in any case smalltalk also has a reputation bfor being slow
20:47:17 <wolverian> I'm put off by the whole environment for programming thing, with smalltalk.
20:47:22 <Svrog> i think gnu smalltalk doesnt need images and is just command line based
20:47:24 <wolverian> (or should I say squeak?)
20:48:01 <shapr> wolverian: Yeah, that's part of the image problem. It's hard to incrementally learn Smalltalk (squeak) because it doesn't obviously integrate with existing tools (emacs).
20:48:23 <Svrog> smalltalk is no slower than python - or at least in theory there is no reason why it would be slower - they're both dynamically typed and interpreted so they're both quite slow
20:48:50 <shapr> Of course, JIT technology came from Self, which was a very fast 'smalltalk'
20:48:58 <Svrog> yes
20:49:08 <Svrog> self was a step forwards from smalltalk - python and ruby step backwards
20:49:09 <shapr> That's where Starkiller's static typing ideas started.
20:49:22 <eviltwin_b> nevertheless the reputation exists, deserved or no, and so people don't look at it
20:49:28 <shapr> Yeah, Self was amazingly awesome, I wish Sun had chosen it to be their New Language instead of Java.
20:49:35 <Svrog> yeah
20:49:46 <shapr> Sadly, Sun killed Self and poured advertising into Java instead.
20:50:07 <Svrog> not only that - they hired jruby devs shortly after firing the self devs
20:50:45 * eviltwin_b suspects a business decision there
20:50:51 <Svrog> yeah
20:50:59 <Adamant> huh?
20:51:12 <eviltwin_b> after all, they successfully conned IBM into converting their Smalltalk installed base to Java
20:51:15 <Svrog> another frustrating thing is that the first version of self was released at sun when they were just starting their work on java
20:51:16 <Adamant> I though Self died a few years ago
20:51:36 <shapr> It's not really dead.
20:51:37 <Adamant> they just hired JRubt devs.
20:51:44 * eviltwin_b wonders if they floated both Java and Self at IBM and IBM only saluted Java, or something
20:51:54 <Svrog> nah
20:51:59 <Svrog> i dont think they pushed self at all
20:52:26 <Svrog> they just reused the jit tech in java
20:53:01 <shapr> Yeah, the HotSpot VM had all the cool Self tech.
20:57:44 <shapr> Crap, I have to reboot to read this DVD.
20:58:12 <monochrom> You are not the first one to have to do that today.  There must be a conspiracy.
20:58:25 <Svrog> what kind of a dvd is that?
21:00:22 <shapr> It's Ice Age 2, I just rented it. But either libdvdcss2 is b0rk3d, or my prissy DVD drive is upset again.
21:00:39 <Svrog> hmm
21:00:51 <Svrog> weird
21:01:13 <shapr> My dvd drive tends to stop working after its first error, requiring a reboot. I put in a scratched audio cd earlier, resulting in reams of errors.
21:01:33 <shapr> Worse Is Better hardware.
21:01:55 <Svrog> lol
21:25:45 <glguy_> Are there any US residents in channel that are not aware that there is a $2 bill?
21:25:52 * glguy_ just read http://windell.oskay.net/humor/qqqfiles/extras/taco.html
21:25:55 <lambdabot> Title: The QQQ Files Â» Extras Â» The "Taco Hell" Story, http://tinyurl.com/y43xez
21:26:53 <chessguy> oh that's a classic story
21:27:10 <Adamant> glguy_, most people know they are. some people don't, though, because the $2 bill is pretty rare
21:27:18 <Adamant> *there is
21:27:27 <chessguy> i heard it's going to be becoming more common
21:27:51 <glguy_> They said on the radio that strip clubs were giving them as change to improve tips for the dancers
21:29:29 <Adamant> ah, and some people got confused? the problem is some strip clubs make you buy lame coupons that look like fake money, you tip strippers, buy beer and food, etc. with them
21:30:14 <Adamant> so someone might have thought they were getting ripped off with one of those programs.
21:30:29 <Adamant> I know too many people who go to strip clubs.
21:31:01 <glguy_> Oh, I don't know about *coupons* i just heard they were giving out the bills to improve tips...
21:31:11 <Adamant> ah. yeah, makes sense
21:35:13 <Adamant> http://www.woz.org/letters/general/78.html
21:35:14 <lambdabot> Title: Welcome to Woz.org
21:35:34 <Adamant> Woz has some great stories about $2 bills.
21:36:27 <MikeJS> and lasers
21:37:35 * eviltwin_b knows someone who keeps a supply of $2 bills just to confuse people with
21:37:55 <eviltwin_b> apparently he regularly runs into people who think they're fake because "therer is no such thing"
21:40:10 <MikeJS> http://yro.slashdot.org/article.pl?sid=05/04/08/2213237&tid=98
21:40:15 <lambdabot> Title: Slashdot | Best Buy Has Man Arrested for Using $2 Bills, http://tinyurl.com/9ytpx
21:40:34 <sieni> w
21:42:16 <eviltwin_b> what did you expect?  lots of people think they need a passport to go to New Mexico...
21:42:24 * eviltwin_b *headdesk*
21:42:52 <mbishop> haha
21:43:03 * mbishop has some $2 bills
21:43:08 <mbishop> I wouldn't spend them though
21:43:48 <glguy_> eviltwin_b: he should keep an "IDIOT" stamp for the foreheads of the people that challenge him
21:44:11 <eviltwin_b> he probably does; he's that kind of person
21:48:08 <Pseudonym> We have $2 coins now.
21:48:30 <glguy> Who is "we"?
21:48:36 <glguy> ?whois Pseudonym
21:48:37 <Pseudonym> Australia
21:48:37 <lambdabot> Unknown command, try @list
21:48:57 <glguy> coins make sense for $1 and $2 amounts... they last longer
21:49:22 <Pseudonym> Yeah.
21:49:35 <glguy> but htey are heavier and bulkier
21:49:41 <Pseudonym> Inflation means that smaller coins are less useful over time, and smaller notes should morph into coins.
21:49:44 <glguy> which is a problem for businesses
21:49:50 <Pseudonym> Not necessarily.
21:49:57 <Pseudonym> Our $2 coins are quite small.
21:50:05 <glguy> well... that is why many stores in the US didn't use the $1 coins
21:50:15 <glguy> I don't know much about the AU coins
21:50:22 <Pseudonym> You complain about bulk, but still have 1c coins.
21:50:26 <Pseudonym> What's up about that/
21:50:33 <glguy> Umm, I don't own a store
21:50:34 <glguy> so ...
21:50:43 <glguy> couldn't tell you
21:50:57 <sieni> 1 dollar coin is quite bulky
21:50:59 <Pseudonym> :-)
21:51:47 <Pseudonym> We got rid of 1c and 2c coins some time ago.
21:52:40 <glguy> someone who isn't aware enough to know that there is a $2 bill (in the US) probably wouldn't be able to grasp how oblivious they really were
21:53:00 <glguy> I don't know how you could explain the situation to the clerk in that Taco bell example
21:53:11 <glguy> "reasoning" with him would be right out
21:59:30 <Pseudonym> The Australian $2 coin is 20.5mm in diameter and weighs 6.6g.
21:59:37 <Pseudonym> That's pretty light.
21:59:51 * dmead is pumped up with caffine and ready to code....
22:00:45 <lispy> dmead: i should try that in the morning
22:00:56 * lispy yawns
22:01:38 <dmead> =)
22:01:48 <dmead> oh yea
22:01:57 <dmead> I have another parsec question for you
22:02:06 <dmead>  it's kinda newbie but i don't see it in the docs
22:02:14 <dmead> i've got a negation operator
22:02:16 <dmead> ~
22:02:22 <dmead> and it's defined as prefix
22:02:31 <dmead> but parsec throws an error if i try and chain them
22:02:37 <lispy> hmm..
22:02:40 <dmead> ~(~P) works
22:02:43 <dmead> ~~P does not
22:02:45 <lispy> code snippet?
22:02:50 <lispy> i see
22:03:01 <dmead> let me upload
22:03:35 <dmead> http://taz.cs.wcupa.edu/~dmead/code/InfixLogic.hs
22:03:40 <lambdabot> http://tinyurl.com/sbanx
22:04:08 <dmead> if you test double negation with the variable s5
22:04:13 <dmead> it fails as ~~P
22:04:19 <dmead> but works as ~(~P)
22:04:36 <lispy> okay, hang on, on this machine i can't view .hs files
22:04:50 <eviltwin_b> just for grins, try ~ ~P
22:05:12 <dmead> kk
22:05:26 <lispy> dmead: have you experimented to find which parser fails?
22:05:35 <eviltwin_b> (I'm thinking it might be parsing ~~ as a single token and then choking on it not being a token)
22:05:44 <lispy> dmead: you can add debugging info/better error messages with the <?> combinator
22:05:49 <dmead> yea
22:05:53 <dmead> i can see which of the parsers fail
22:05:59 <dmead> it's the first one
22:06:02 <dmead> logicsentance
22:06:09 <dmead> it gives the correct error
22:06:32 <lispy>  Could not find module `ParsecExpr':
22:06:39 <dmead> woah
22:06:52 <dmead> switch to the other imports
22:06:55 <eviltwin_b> you need to run in haskell98 mode
22:06:56 <dmead> the one i labeled as gh
22:06:56 <dmead> c
22:07:09 <eviltwin_b> or that
22:07:22 <sieni> what is this AssocNone thingie?
22:07:41 <dmead> binary operators in logic don't associate left or right like math does
22:08:08 <lispy> *InfixLogic> anExpr s5
22:08:09 <lispy> ~~P<->P
22:08:11 <lispy> so it worked?
22:08:17 <dmead> no
22:08:20 <dmead> look at the string, i added a paren
22:08:21 <sieni> yeah, but how an unary operator can have associativity?
22:08:38 <sieni> well, it doesn't, but anyway :-)
22:08:55 <dmead> hmm
22:09:05 <dmead> s5 = "~~P<->P"
22:09:08 <dmead> will fail
22:09:32 <dmead> maybe i need to add a section to the parser for a chain of negations?
22:10:36 <lispy> oh, you use an operator table?
22:10:44 <lispy> i've never tried that with parsec
22:11:16 <dmead> oh
22:11:19 <dmead> what are you supposed to do?
22:11:34 <dmead> (this is what was in the parsec docs)
22:11:38 <lispy> it's not a value judgement :)
22:11:43 <lispy> just an observation
22:11:47 <dmead> ah
22:12:07 <dmead> yea, parsec seems really hot but the docs aren't up to date =/
22:13:31 <lispy> dmead: i would bet that it sees "~~" as one token
22:13:34 <dmead> woops
22:13:36 <dmead> hmm
22:13:43 <dmead> netsplit?
22:13:48 <jcreigh> dmead: I'm thinking yeah
22:13:51 <dmead> hehe
22:13:52 <eviltwin_b> yeh, netsplit
22:14:09 <dmead> lispy: odd cause i'm not using whitespace at all
22:14:10 <eviltwin_b> did adding a space woprk?
22:14:17 <lispy> hmm...it does not like the input "~ ~P <-> P"
22:14:23 <eviltwin_b> ParsecToken does spaces for you automatically
22:14:23 <dmead> it can't handle white space
22:14:37 <dmead> i read you have to specify it
22:14:46 <dmead> try doing anExpr "P v P"
22:14:48 <eviltwin_b> if you're using the operator table it will be doing whitespace processing
22:14:49 <dmead> it will fail on the white space
22:14:55 <dmead> oh
22:14:56 <dmead> hmm
22:15:13 <dmead> ahh
22:15:15 <dmead> it doesn't fail
22:15:20 <dmead> just is wrong
22:15:28 <dmead> anExpr "P v P"
22:15:31 <dmead> returns P
22:15:34 <dmead> =/
22:15:45 <dmead> anExpr "PvP"
22:15:45 <lispy> it fails on same input with spaces
22:15:48 <dmead> hmm
22:16:00 <eviltwin_b> hm, okay, no ParsecToken usage there
22:16:09 <eviltwin_b> but I think that means the operator table is dubious at best
22:16:20 <eviltwin_b> I thought that was hooked into ParsecToken
22:16:25 <dmead> oh
22:16:26 <eviltwin_b> (but it's been a while)
22:16:29 <dmead> hmm
22:17:13 <eviltwin_b> hm, yeh, I thought buildExpressionparser did that.  maybe not though
22:17:52 <dmead> you may be right but it's probably deeper in the modules
22:17:55 <eviltwin_b> nope, never mind
22:18:00 <dmead> k
22:18:01 <dmead> hehe
22:18:01 <eviltwin_b> you're using "string" to parse them
22:18:09 <eviltwin_b> so it won't do spaces and won
22:18:23 <eviltwin_b> t be combining them to create an unexpected ~~ token
22:18:52 <dmead> oh
22:19:01 <dmead> what else can i use?
22:19:08 <eviltwin_b> the other thought I had is that associativity is sually overloaded in parser generators, such that if you declare non-associative then you can't combine items like that
22:19:12 <dmead> char would fail miserably yea?
22:19:21 <dmead> hmm
22:19:26 <eviltwin_b> you don't want char
22:19:28 <dmead> maybe i should make ~ associ left
22:19:47 <eviltwin_b> typically you'd use symbol from ParsecToken but then you need to declare whiespace, comments, etc.
22:19:48 <dmead> gah
22:20:01 <dmead> hmm
22:20:17 <eviltwin_b> I suspect just declaring associativity would be good enough
22:20:25 <eviltwin_b> since for a prefix op it can't really mean anything else
22:20:36 <eviltwin_b> you're probably okay for the binary ops
22:20:40 <dmead> hmm
22:20:50 <dmead> ok, i'll try seperating ~ into it's own list element
22:20:53 <dmead> so it has precidence
22:20:58 <dmead> and give it assocleft
22:21:14 <eviltwin_b> you probably do want it to have higher precedence, yes
22:21:19 <dmead> damn it
22:21:24 <dmead> anExpr "~~P"
22:21:28 <dmead> fails
22:21:45 <dmead> ~(~P)
22:21:46 <dmead> still works
22:49:09 --- topic: '["Haskell - the language of ICFP winners 3 years running", "Distribute your cognition", "Logs: http://tunes.org/~nef/logs/haskell/"]'
22:49:09 --- topic: set by ChanServ on [Sat Nov 25 22:42:48 2006]
22:49:20 <emu> wtf
22:49:23 <dmead> =/
22:49:39 <emu> i guess i just came back to the computer at the right time
22:50:56 <dibblego> @join #jtiger
22:51:26 <eviltwin_b> boomage
22:51:46 <lambdabot> Not enough privileges
22:52:01 <emu> ok, drunken debugging time
22:52:14 * emu pokes emu_ 
22:52:27 <emu> damn imitator
22:57:32 <dmead> ;o
22:57:42 <MikeJS> that was fun
22:57:52 <eviltwin_b> boomage
22:57:55 * emu kicks emu_ 
22:57:59 <Botty> this is why everyone should switch to jabber
22:58:04 <emu> lol
22:58:09 <dmead> =p
22:58:22 <dmead> you'd think netsplits would have been solved like... 10-15 years ago
22:58:39 <Botty> yeah, they were :)
22:58:42 <Botty> jabber
22:58:51 <dmead> =p
22:59:16 <Botty> then again, jabber is xml
22:59:39 <emu> jabber is a mess
22:59:42 <eviltwin_b> [01:25] <allbery_b> <badtaste> lilo must be upset with someone </badtaste>
22:59:49 <Botty> yeah, most jabber servers are pretty weak
22:59:51 <emu> it's xmliscated
23:00:03 <Botty> yeah, xml is teh suxors
23:00:24 <Botty> someone should really make a decent chat protocol
23:00:51 <dmead> or at least find a way to divert connections easily when a leave goes down
23:00:58 <dmead> *leaf
23:01:32 <Botty> yeah.  IRC is pretty hacky too.  Something extensible and configurable would be cool
23:01:46 <dmead> hmm
23:02:02 <dmead> i think a bit of xml handed off to a client would be good to tell it how to switch leafs
23:04:05 <Botty> irc arch has to be left behind in general.  jabber has its own problems though (xml, server you login to could slow you down lots, etc)
23:04:34 <Botty> it's an interesting problem, but not that interesting to me.  someone else can do it
23:05:10 <dmead> yea, i agree
23:05:45 <Botty> would be cool to have discussion management within a room.  have various conversations going on at once, not just one big one where people preface messages with names
23:06:02 <Svrog> one thing that annoys me with most chat/im programs (icq being an exception) is the usage of names as identifiers - so when someone registers a name you wanted, you either have to pick a different name or add some random crap into the name to differentiate it from the existing registered names
23:06:30 <Botty> Svrog - yeah, that's one nice thing about jabber.  the names are unique to the server you log on to
23:06:32 <Svrog> i like the idea of using unique numbers, like icq or phone numbers, and then let users pick their own nicknames that dont have to be unique
23:06:39 <Botty> (and you can access other server's chats)
23:08:17 <Botty> Hmm, treewise discussion like a forum... except smaller posts on average
23:39:19 <Korollary> sigfpe_: love your blog.
23:40:33 <arcatan> I wish I understood sigfpe's blog (if he's the neighborhood of infinity guy)
23:59:27 <Lemmih> dcoutts_: ping.
