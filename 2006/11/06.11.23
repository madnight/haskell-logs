00:00:06 <Korollary> with array doubling up for a lot of other things
00:00:13 <Korollary> and hashtables acting like sets, etc.
00:01:39 <audreyt> yeah, because gradual typing wasn't invented back then, and shorthands/puns was (sadly) overemphasized
00:02:35 <Korollary> when you say gradual typing, do you mean that there can be perl programs that fail to compile? or are they just warnings?
00:03:16 <audreyt> they can fail to compile if you compile in optimized mode, which assumes no runtime augmentation (closed type hierarchy) by default
00:03:29 <audreyt> under that mode all annotations must typecheck
00:03:32 <Korollary> no runtime augmentation = type erasure?
00:03:52 <audreyt> for static types, yes.
00:03:59 <audreyt> perl6 has those ada-inspired constraint types that can't be erased
00:04:04 <audreyt> though we lift them into assertions
00:04:24 <Korollary> are those the things like integers between 5 and 10 and such?
00:04:41 <audreyt> subset SmallInt of Int where { 5 < $_ < 10 }
00:04:43 <audreyt> yes.
00:05:19 <audreyt> er, <=.
00:05:34 <audreyt> subset SmallInt of Int where 5..10; # better
00:06:01 <Korollary> both are somewhat awkward as syntax imho
00:06:48 <audreyt> I think it's directly from Ada
00:07:01 <audreyt> except "is" is renamed to "where"
00:07:26 <Korollary> no biggie
00:07:56 <glguy> Has anyone one read the article linked off programming.reddit "Ruby: Zero, Blankk, and Nil"?
00:08:00 <audreyt> sub f ($x where 5..10) { ... } # too
00:08:08 <Korollary> glguy: link?
00:08:20 <glguy> http://programming.reddit.com/info/s3tk/comments
00:08:23 <lambdabot> Title: Ruby: Zero, Blank, and Nil (reddit.com), http://tinyurl.com/yjrfes
00:08:33 <glguy> (scroll down to my comment if you wondered what I thought of it)
00:08:54 <glguy> It scares me that the fact that you can do this in Ruby doesn't bother anyone
00:09:15 <glguy> even worse, that people don't seem to think it's the worst idea ever
00:09:18 <Korollary> "Ruby is a bit more strongly typed that PHP" Eh?
00:09:47 <Korollary> Why do these GC'd languages have null anyway?
00:09:58 <audreyt> Korollary: Maybe is too hard to type
00:10:01 <audreyt> and to type
00:10:06 <monochrom> heh
00:10:24 <monochrom> There is a false sense of "I need a default value"
00:10:49 <monochrom> A lot of things are just legacy and untenable.
00:10:59 <Korollary> I also wonder why it's "Maybe String" to begin with.
00:11:00 <glguy> Hmm, I'm getting null reference exceptions, rather than writing a method to check all of the conditions for me, or fixing my code... maybe I should add the offending method to the Nil class
00:11:05 <glguy> yeah, that's what I will do
00:11:28 <Korollary> It almost sounds like it's a map lookup, so it's got to be Maybe String.
00:11:44 <glguy> C# has a string.IsNullOrEmpty(x) method, I can't imagine that would be too challenging for this Ruby programmer to bother with
00:12:09 <Korollary> glguy: when is a C# string reference null?
00:13:02 <glguy> Korollary: string is a reference type, so... any time it is null
00:13:08 <audreyt> when it's set to null. :)
00:13:38 <Korollary> so c# references can be null? I don't write java anymore, but I thought you couldn't do that.
00:13:47 <glguy> Korollary: IsNullOrEmpty is a static method on the string class
00:14:02 <monochrom> java has null.  curse them.
00:14:07 <audreyt> Korollary: they can. just like java.
00:14:52 <Korollary> awesome
00:15:11 <audreyt> all reference types are implicitly nullable
00:15:17 <glguy> in C#, things that derive from ValueType can't be null
00:15:19 <audreyt> which is crazy; String ought to be a value type :)
00:15:22 <glguy> and can't be inherited, I believe
00:15:45 <Korollary> fun stuff
00:15:48 <audreyt> glguy: in C#2, you can declare a "nullable value type", which is essentially "Maybe Valuetypefoo"
00:15:55 <glguy> right: int?
00:16:02 <glguy> int? a = null;
00:16:09 <glguy> and then there is the ?? syntax
00:16:09 <audreyt> aye. I actually like that
00:16:12 <glguy> a ?? defaultvalue
00:16:22 <audreyt> ? is easier to type, and to type, than Maybe :)
00:16:36 <Korollary> sugar can be sweet
00:17:46 <zptao> splenda sweet ;)
00:18:05 <Korollary> nah. Maybe has nutritional value.
00:18:20 <audreyt> sholdn't be too hard to hack into GHC
00:18:22 <audreyt> type (a :?:) = Maybe a
00:18:29 <audreyt> following the 6.6 right-section syntax
00:18:29 <glguy> bah, Ruby zealots have started modding my anti-ruby comment down
00:18:38 <Korollary> lol
00:18:41 <audreyt> or is that left-section.
00:19:02 <audreyt> postfix type functions!
00:19:14 <monochrom> why would you make an anti-ruby comment anyway?
00:19:23 <Korollary> it may make sense
00:19:28 <glguy> The type system doesn't support sections... i thought Cale had a quote wishing it did in lambdabot
00:19:36 <glguy> ?quote Cale
00:19:37 <lambdabot>  I've written an entire IRC bot as what was essentially a single extremely long shell pipeline.
00:19:48 <audreyt> f :: String:?: -> Int:?: -> String:?:
00:19:48 <glguy> ?quote Cale
00:19:49 <lambdabot>  I know I always have trouble explaining what the weather is like without involving foldr somehow.
00:20:03 <glguy> ?quote Cale
00:20:04 <lambdabot>  desrt: Did you hear about the trivial religion that I came up with? Its tenets consist of a single statement: "Believing in this statement will make you happier". It's like a terminal object in the
00:20:04 <lambdabot> category of religions and theomorphisms.
00:20:17 <Korollary> ow
00:20:24 <opqdonut> ?quote glguy
00:20:25 <lambdabot>  Hmm, for next Halloween, he could dress up as someone who recognizes 2^1024 on sight!
00:20:33 <opqdonut> ?quote glguy
00:20:33 <lambdabot>  Hmm, for next Halloween, he could dress up as someone who recognizes 2^1024 on sight!
00:20:37 <opqdonut> :(
00:20:38 <Korollary> ?quote
00:20:38 <lambdabot> sebazzz says: <sebazzz> vos no te diste cuenta, pero cuando estas en pedo, y si yo estoy, te saco del alcanse todo objeto contundente
00:20:45 <Korollary> aye
00:20:47 <therp> lambdabot is fun isn't it :)
00:20:52 <opqdonut> ?quote
00:20:53 <lambdabot> ghci.debugger says: http://haskell.org/haskellwiki/Ghci/Debugger
00:20:58 <opqdonut> :D
00:21:02 <glguy> Hmm, I wonder who added that one to my ?quote
00:21:06 <glguy> ?quote glguy
00:21:06 <lambdabot>  lol, making lambdabot fight your battles
00:21:16 <Korollary> ?quote audreyt
00:21:17 <lambdabot>  yes, I'm aware that I'm abusing GHC beyond its designed purpose
00:21:20 <opqdonut> ?quote
00:21:21 <lambdabot> joelr says: the learning curve is far steeper with Haskell but it is far more elegant and readable
00:21:31 <Korollary> I like readable curves
00:21:46 <glguy> ?quote glguy
00:21:47 <lambdabot>  that's odd, mine is this big : |-----------------------------|
00:21:54 <sieni> ?quote sieni
00:21:55 <lambdabot>  scheme adheres to the TIMTOBFTTWTDI principle instead of TIMTOWTDI
00:22:25 <Korollary> btf=?
00:22:28 <Korollary> err bft
00:22:47 <glguy> TIMTOWTDI?
00:22:54 <sieni> Korollary: "but fewer than" (the next t is "three")
00:22:56 <Korollary> there is more than one way to do it
00:23:01 <audreyt> There is more than one way to do it. Dogma of perl
00:23:11 <Korollary> ah
00:23:19 <Korollary> happy thanksgiving, yanks
00:23:57 <opqdonut> perl is a perfectly nice language
00:24:25 <xnito> does anyone know how to get the readstree function to work
00:24:38 <audreyt> it's nice for certain things; very, very far from perfect though, imho :)
00:24:40 <Korollary> xnito: from the gentle intro ?
00:24:44 <xnito> for readsTree "<1|<2|3>>" i get unresolved overloading
00:24:50 <xnito> yes
00:25:15 <monochrom> readsTree "<1|<2|3>>" :: Tree Int   ??
00:25:21 <monochrom> err that's still wrong
00:25:23 <Korollary> xnito: paste what you are trying to compile
00:25:31 <Korollary> lisppaste2: url?
00:25:35 <xnito>  Type error in type annotation
00:25:37 <xnito> ok
00:25:38 <monochrom> readsTree "<1|<2|3>>" :: ReadS (Tree Int)   perhaps
00:25:42 <Korollary> ?paste
00:25:42 <lambdabot> http://paste.lisp.org/new/haskell
00:26:58 <xnito> http://www.mathematik.uni-marburg.de/~priebe/docs/mirror/tutorial/code/part16.lhs
00:27:02 <lambdabot> http://tinyurl.com/swzqx
00:27:15 <xnito> its from the gentle intro
00:27:56 <monochrom> OK, look at e11.  It tells you what to do.
00:30:51 <Korollary> glguy: that's a really stupid hack. Too bad you're getting modded down for saying it.
00:31:03 <glguy> I even presented the correct solution
00:31:27 <Korollary> so NilClass is blank, also false, also 0.0, whatever you can think of, eh?
00:31:35 <Korollary> where does this end
00:31:39 <glguy> I guess the important thing is that people that think that this is a good idea are drawn to languages like these
00:31:44 <glguy> and away from the ones that I use
00:31:55 <audreyt> having the ability to do this is a good idea...
00:31:59 <audreyt> to do this particular thing is quite unwise
00:32:03 <monochrom> I want to say that you shouldn't waste your time on reddit, but I guess that's too negative a thing to say.  I guess I should say a positive thing: your time is better spent on the haskell wiki :)
00:32:07 <Korollary> (btw, what the heck does it have to do with metaprogramming?)
00:32:26 <audreyt> not one bit :)
00:32:48 <glguy> woot, I'm back up to 0 ;)
00:33:19 <glguy> at least when you to type system programming, you still have a sane result
00:33:25 <glguy> it's just in the type system
00:33:32 <audreyt> sane?
00:33:33 <glguy> s/to/do
00:33:35 <audreyt> see oleg :)
00:33:51 <audreyt> it's easier to remain sane, though
00:34:43 <glguy> the fact that ruby tutorials condone renaming "myMethod" to "myMethod_old" and then adding a new "myMethod" that does something in addition to calling "myMethod_old" is abhorent to me
00:35:06 <monochrom> I am glad I don't know ruby.
00:35:19 <Korollary> I dont understand all of what Oleg does, but I get the feeling that the bats**t crazy bits are not actually meant to be used seriously. It's a bit of research on how they can be used.
00:35:36 <glguy> I'm not advocating using type-system programming in the wild like that
00:36:21 <monochrom> That is a correct assessment.
00:38:43 <Turks> Heya
00:38:50 <Korollary> yo
00:49:48 <boegel> Itkovian: you're in #haskell but not in #haskell-blah?
00:59:29 <xnito> does anyone here find n+k patterns in haskell disgusting?
01:00:09 <int-e> xnito: http://www.mail-archive.com/haskell@haskell.org/msg01272.html
01:00:11 <lambdabot> Title: Re: n+k patterns, http://tinyurl.com/utvyd
01:01:42 <Turks> @ Turks
01:01:45 <int-e> ironically that's the first google hit for "n+k patterns" :)
01:01:53 * Turks is bored
01:02:14 * earthy doesn't think Oleg does batshit crazy things
01:02:35 <lispy> earthy: oleg does very interesting things
01:02:36 <int-e> is 'map head . group'
01:02:40 * earthy nods
01:02:41 <int-e> considered harmful now?
01:02:49 <earthy> nope
01:02:57 <audreyt> > let n+1+2 = n in 1+2
01:02:58 <lambdabot>  Parse error in pattern
01:03:07 <audreyt> oh well :)
01:03:41 <int-e> > let (1+1)+(1+1) = 2 in 2 + 2
01:03:41 <lambdabot>  Parse error in pattern
01:03:52 <int-e> that would be evil :)
01:03:52 <audreyt> int-e: it's the preparser again
01:04:03 <lispy> yeah, the evil preprocessor
01:04:07 <xnito> > f 3 where f (a+1) = a
01:04:07 <lispy> lambdabot: bad bot! ;)
01:04:07 <lambdabot>  Parse error
01:05:20 <int-e> noone uses n+k patterns anyway *ducks*
01:06:52 * lispy doesn't
01:06:56 <johnnowak> it's bonkers.
01:07:09 <lispy> i found out they only work on positive numbers
01:07:09 <int-e> I use k patterns though.
01:07:55 <int-e> they're specified that way.
01:08:26 <lispy> that may be, but when i see them in code i expect them to work for ints :)
01:08:35 <xnito> i wouldnt mind n+k patterns so long as they upgraded it for subtract multiply etc
01:08:53 <xnito> they should make a class called inverse map which finds the inverse of a function
01:08:57 <int-e> hmm, but with multiplication you get yourself into a nightmare
01:09:06 <lispy> while we're at it, can i have non-linear pattern matching? ;)
01:09:19 <xnito> pattern matching for all
01:09:21 * int-e imagines  f (n `mod` 5) = ...
01:09:22 <Botty> xnito - that'd be fun, but which parameter to inverse, and what if it's not a function (in math terms)
01:10:01 <xnito> you mean what if its not a one to one mapping?
01:10:12 <Botty> right
01:10:21 <int-e> well, if it's not injective you get into trouble
01:10:33 <xnito> then you create a class
01:11:04 <Botty> hmm, is that the new solve-all-problems method?
01:11:19 <Botty> I'd think it'd be "create a monad" by now :)
01:11:19 <int-e> f (2*n) = ...  would actually be meaningful for Integral instances. It could be translated to  f n' | n' `mod` 2 == 0 = let n = n' `div` 2 in ...
01:11:24 <lispy> i thought GADTs were the new solve-all-problems method
01:11:34 <int-e> but it's highly artificial.
01:11:49 <xnito> i dont get GADT's
01:12:05 <xnito> i read the wiki but it still doesnt compute
01:12:42 <lispy> yeah, the basic GADTs stuff is easy, but some of the corner cases are hard to follow
01:13:55 <lispy> if you have a GADT, data Pair a b where Asymmetric a b -> Pair a b; Symmetric a a -> Pair a a (I may have the syntax a bit off) you can define some funky functions
01:14:53 <lispy> foo :: Pair a b -> b -> a; foo (Symmetric x y) z = z -- this is actually valid
01:15:04 <Botty> 0_o
01:15:14 <lispy> the reason is that for the Symmetric constructor to match a = b
01:15:21 <xnito> do GADTS work on Hugs?
01:15:59 <boegel> Turks: join #haskell-blah and have some fun with lambdabot!
01:16:04 <lispy> xnito: never tried hugs :(
01:16:06 <boegel> @vixen wanna have some fun with Turks?
01:16:07 <lambdabot> i'm always up for fun
01:16:23 <Turks> o.0
01:16:52 * lispy takes vixen into private chat
01:47:03 <araujo> morning!
01:52:08 <lispy> araujo: morning!
01:52:08 <Lemmih> yes!
01:52:28 <lispy> but only by a technicality in my timezone :)
01:52:33 <lispy> ?localtime lisppaste2
01:52:34 <lambdabot> Local time for lisppaste2 is Thu Nov 23 04:47:56 2006
01:52:36 <boegel> yo Lemmih, been a while since I've seen you here? but maybe that's just me ;-)
01:52:47 <lispy> ?localtime lispy
01:52:49 <lambdabot> Local time for lispy is Thu Nov 23 01:48:51 2006
01:52:57 * Lemmih is always lurking in the shadows.
01:53:30 * lispy pictures Lemmih in a dark robe, clouded by a permament haze standing near a shadow
01:53:47 <lispy> the secret order of the lambda
01:54:52 <psykotic> knights of the lambda calculus
01:57:23 <lispy> on second thought, #haskell is a silly place
01:58:03 <Korollary> what was the 1st thought?
01:59:25 <araujo> lispy, hello there
01:59:30 <lispy> araujo: hi
01:59:44 <lispy> araujo: have you played with the small talk stuff lately?  i haven't...
02:00:47 <dblhelix> @seen SyntaxNinja
02:00:49 <lambdabot> I saw SyntaxNinja leaving #haskell, #darcs and #haskell-blah 1d 6h 13m 47s ago, and .
02:11:34 <araujo> lispy, no, been kind of buys
02:11:55 <araujo> lispy, but i got some ideas i hope to start playing with soon
02:12:38 * araujo off to univ
02:12:41 <araujo> brb
02:46:38 <osfameron> surely the darcs.cgi at http://cgi.cse.unsw.edu.au/~pls/cgi-bin/darcs.cgi/yi can't be as useless as it looks ?
02:46:40 <lambdabot> Title: darcs repository, http://tinyurl.com/yytbp5
02:46:53 <osfameron> it has the possibility of viewing patches or annotations (whichj don't exist)
02:46:58 <osfameron> and won't let you view or download the file
02:54:30 <Korollary> hm
02:54:54 <Korollary> it may be misconfigured
02:55:06 <Korollary> ?where yi
02:55:07 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
03:10:02 <dons> ?users
03:10:02 <lambdabot> Maximum users seen in #haskell: 276, currently: 252 (91.3%), active: 27 (10.7%)
03:15:48 <dons> looks like even gizmo wants haskell karma points now: http://programming.reddit.com/info/s4lb/comments (pulling out the big guns, oh well)
03:15:51 <lambdabot> Title: Tackling the awkward squad: monadic input/output, concurrency, exceptions, and f ..., http://tinyurl.com/ycr6su
03:19:00 <Lemmih> ?lusers #scheme
03:19:00 <lambdabot> Maximum users seen in #scheme: 142, currently: 122 (85.9%), active: 4 (3.3%)
03:19:21 <dons> :}
03:19:36 <dons> haskell wins. prizes for all!
03:20:26 <jeffz> hm, for such an interesting language, it surprises me there are no job advertisements on seek in my country Australia, New Zealand, America, the UK and similarly Monster.com for the US.
03:20:42 <jeffz> er, which mention haskell :)
03:21:07 <dons> basically, the jobs go via advertisements on the mailing lists, or word of mouth
03:21:38 <dons> so you'll see research jobs on haskell@ weekly, and often people will just get cherry picked from the community
03:21:55 <dons> i've met one HR person in Sydney who knew about haskell though
03:22:18 <jeffz> once I get a better grasp on the language, I'm going to attempt to use it where I work, probably a good way to get some experience.
03:22:20 <dons> and said when haskell jobs do come up, they're usually very top end defence and finance jobs (when they come up)
03:22:40 <dons> jeffz: very good way. even if you just prototype tools in haskell first
03:23:01 <astrolabe> Has anyone here used tables in gtk2Hs or gtk?
03:23:06 <dons> present executable "pseudocode" to your colleagues ;)
03:23:34 <jeffz> hmm, my colleagues program in COBOL and do not like the languages I use ;)
03:23:40 <dons> heh scary.
03:23:45 <dons> in .au?
03:23:48 <jeffz> yes
03:23:49 <dons> (i'm at UNSW)
03:24:00 <dons> and so is lambdabot :)
03:24:20 * jeffz works near macquarie uni... might enroll there one day.
03:24:27 <dons> jeffz: dibblego is in brisbane, and works for a company there that's looking to migrate to haskell (from java)
03:24:34 <dons> jeffz: oh, they've got a great haskell gropu there
03:24:42 <dons> tony sloane et al, do lots of interesting haskell things
03:24:54 <dons> let me fine you a ref.
03:25:30 <dons> jeffz: http://www.comp.mq.edu.au/~asloane/plrg/PLRG.html
03:25:31 <lambdabot> Title: PLRG, http://tinyurl.com/y6yqrb
03:26:03 <dons> we had the first sydney area programming languages meeting last week
03:26:12 <dons> guys from usyd, unsw, mq, and anu
03:26:24 <jeffz> sounds interesting
03:27:14 <dons> ah, this page is a bit more informative, http://www.comp.mq.edu.au/~asloane
03:27:15 <lambdabot> Title:
03:31:39 <vincenz> dons: ping
03:31:42 <vincenz> dons: seen my tells?
03:31:58 <dons> yes :)
03:32:11 <dons> is it a big problem? you sending patches?
03:32:11 <vincenz> cool :)
03:32:16 <vincenz> I might send patches
03:32:23 <dons> patches are good
03:32:26 <dons> i like patches
03:32:30 <dons> so does lambdabot
03:32:32 <vincenz> I get the idea
03:33:02 <dons> :)
03:33:07 <vincenz> @version
03:33:08 <lambdabot> lambdabot 4p272, GHC 6.5 (OpenBSD i386)
03:33:08 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
03:33:49 <vincenz> hm, remind me what I need to build again
03:34:15 <vincenz> crap, darcs get failed
03:34:17 <dons> jeffz: you learning haskell?
03:34:21 <dons> vincenz: oh?
03:34:57 <vincenz> must be my proxy
03:35:11 <vincenz> tho if that happens, usually it hangs, I'm getting a 404
03:35:20 <dons> $ darcs get --partial http://www.cse.unsw.edu.au/~dons/lambdabot
03:35:20 <dons> Copying patch 14 of 278...
03:35:21 <lambdabot> Title: Index of /~dons/lambdabot
03:35:26 <dons> seems to be working here
03:35:35 <jeffz> dons, I've been spending my spare time over the last week or so attempting to, yes
03:36:03 <vincenz> dons: what else do I need to make lambdabot work?
03:36:40 <vincenz> ouch, partial of lambdabot: 278 patches
03:36:40 <jeffz> my boss doesn't mind me researching things when there's not much else to do, so learning and using haskell is on my todo list.
03:37:42 <dozer> it seems I've been confused by State - it represents a state transition, not a state itself?
03:39:17 <dons> jeffz: great. feel free to hang out here and ask questions, and joining haskell@ and haskell-cafe@haskell.org mailing lists is also a good idea
03:39:34 <dons> vincenz: Applying patch 277 of 277... done.
03:39:35 <dons> Finished getting.
03:39:39 <dons> (all looks good)
03:39:51 <dons> > fix ((1:) . scanl (+) 1) -- have a fixpoint, jeffz
03:39:52 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
03:42:09 * jeffz hasn't read about fixpoints yet, but is appreciative none the less.
03:48:16 <dons> :)
03:48:36 <opqdonut> wow, i hadn't realized fix can be used like that
03:48:50 <dons> also, we have a new wiki page, jeffz : http://haskell.org/haskellwiki/Haskell_in_industry
03:48:52 <lambdabot> Title: Haskell in industry - HaskellWiki, http://tinyurl.com/ylh86r
03:48:57 <dons> might be interesting to you
03:53:25 <araujo> hiya!
03:53:28 * araujo at univ
03:58:49 <dons> hey araujo
03:59:13 <araujo> dons!!
04:05:17 <metaperl> it's not clear what bluespec, linspire, and erlang are doing listed on that Haskell in Industry page :)
04:08:29 <araujo> metaperl, ??
04:08:52 <metaperl> araujo - i didnt see much haskell reference on the bluespec or erlang pages
04:09:25 <dons> the bluespec language is written in haskell (and based on it too, iirc) check the CUFP page
04:09:30 <dons> some 80k
04:09:36 <dons> loc
04:09:38 <araujo> oh, never heard
04:09:53 <metaperl> oh
04:10:01 <araujo> dons, wwow
04:10:13 <dons> metaperl: you know why linspire is on there, right?
04:10:37 <araujo> well, linspire is using Haskell as its system PL right?
04:10:41 <dons> yeah
04:10:45 <metaperl> CUFP means what? I searched for Haskell on this page: http://www.bluespec.com/about/SWEngineers.htm
04:10:46 <lambdabot> Title: SWEngineers
04:11:01 <dons> CUFP: http://www.galois.com/cufp/
04:11:03 <lambdabot> Title: Commercial Users of Functional Programming Workshop 2006
04:11:16 <metaperl> wow, you mean instead of bash, they are using Haskell?
04:11:24 <araujo> hah
04:11:38 <araujo> metaperl, i'd love that
04:11:56 * araujo got some patches around to rutn ghci into a pseudo monadic shell
04:11:59 <dons> metaperl: right. and #haskell guys like stepcut work there (and thetallguy)
04:12:18 <osfameron> spj++ # very clear
04:12:38 <dons> osfameron: the awkward squad paper, or the video? or ?
04:13:12 <osfameron> the awkward squad paper
04:13:29 <osfameron> it's rather dense, but  not because he's obfuscating or going too fast
04:13:53 <osfameron> it gives the impression of having the capacity to percolate through the various layers of stupidity in my brane that other tutorials so far haven't
04:14:03 <osfameron> which video ?
04:14:16 <dons> http://programming.reddit.com/goto?id=s43f
04:14:20 <lambdabot> Title: Programming in the Age of Concurrency: Software Transactional Memory
04:15:20 <osfameron> dons: ta
04:21:45 <metaperl> I'm looking at the Linspire toolchain paper: http://www.galois.com/cufp/slides/2006/CliffordBeshers.pdf   .. and it talks about advantages of Haskell over OCaml... what does "function composition" mean? and you cant do it in Haskell?
04:21:48 <lambdabot> http://tinyurl.com/ygzrtd
04:21:49 <metaperl> I mean ocaml
04:22:20 <metaperl> dons - what does "fps" stand for?
04:22:51 <dons> fast packed strings
04:23:03 <dons> ?type (.) -- function composition
04:23:04 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
04:23:17 <dons> > toUpper . chr $ 49
04:23:17 <opqdonut> dons, aren't you the guy responsible for yi?
04:23:19 <lambdabot>  '1'
04:23:24 <dons> opqdonut: yep
04:23:46 <opqdonut> dons: great idea, but lacks documentation and examples
04:23:56 <dons> agreed :)
04:24:20 <dons> unfortunately, idon't have much time (or any) to work on it these days
04:24:47 <opqdonut> i'm in the process of coding my own editor (c & lua) but might want to use the yi framework, is there any way i could help?
04:25:42 <dons> well, just grab the src and poke around (or read the paper on yi's architecture?)
04:25:51 <dons> its only 5k loc, you could write your own in a week or two
04:25:59 <metaperl> you mean ocaml doesnt have f . g
04:26:01 <metaperl> ?
04:26:04 <dons> metaperl: sure it does.
04:26:31 <dons> it would hardly be FP if you didn't have (.)
04:26:46 <metaperl> the linspire slides implied that as an advantage of haskell over ocaml
04:27:10 <metaperl> slide 6
04:27:16 <dons> not sure what they mean there. i thought it was more libraries and community support that were important factors in the switch
04:27:30 <dons> but ask thetallguy himself when he's around
04:28:17 <opqdonut> dons: ok, i have read the paper already
04:28:39 <Philippa_> they may've meant compositionality
04:28:48 <Philippa_> pure code tends to be easier to compose than impure
04:29:03 <metaperl> I see
04:29:06 <dons> ahyes, that's almsot certainly it
04:29:16 <metaperl> Philippa_ - are you still in school ? undergrad still?
04:31:03 <Philippa_> on paper, yes
04:31:10 <Philippa_> why?
04:31:18 <metaperl> oh just wondering what you were up to these days
04:31:31 <metaperl> I'm writing a script to make installing Hope easier right now
04:31:37 <dons> cool
04:31:44 <Philippa_> mostly the same not being up to much as ever. My personal life is proving interesting of late though
04:31:45 <dons> to solve all the dep chasing?
04:33:04 <lisppaste2> metaperl pasted "current install program" at http://paste.lisp.org/display/30543
04:34:31 <dons> metaperl: nice.
04:34:37 <metaperl> :) thanks
04:37:02 <araujo> nybody knows what kind of notation is this? http://people.ofset.org/~ckhung/b/pr/expression.php
04:37:05 <lambdabot> http://tinyurl.com/y6azgl
04:38:01 <psykotic> what do you mean, notation? it's chinese characters, no?
04:38:44 <dons> araujo: you wondering if it was epigram code or something? ;)
04:38:58 <psykotic> haha
04:39:20 <araujo> dons. haha
04:39:25 <psykotic> more like K code. i think the entropy of an average K program is close to that of compressed text.
04:39:43 <dons> that must suck for the great language shootout gzip test
04:39:54 <dons> lines of code out the window ;)
04:40:22 <araujo> i was asking about the code
04:40:50 <araujo> it's just that i am following that page to get the postfix notation out of an AST
05:02:16 <lisppaste2> metaperl pasted "help needed writing function to take optional flag argument" at http://paste.lisp.org/display/30545
05:03:52 <lennart> How about using a Maybe type for the second argument?
05:04:24 <metaperl> lennart - I'm not to that point in Craft yet (in my 2nd go-round)... how would I do that?
05:05:29 <lennart> Oh, now I see what you are doing.  A Bool works here.
05:05:49 <lennart> so you just say 'if p then "partial" else ""
05:05:51 <metaperl> but I want it to default to partial
05:06:03 <metaperl> I dont want to have to pass the 2nd argument if it is partial
05:06:13 <lennart> that's not the Haskell way
05:06:26 <metaperl> :)
05:06:31 <lennart> Then you'd make two different functions
05:07:12 <JKnecht> is perl6 still haskell based?
05:07:12 <lennart> Well, what you want can be done, but not in a very nice way.  And if you're a Haskell beginner I don't think it's time for type class magic yet. :)
05:07:45 <metaperl> JKnecht - i think the only implementaiton of Perl6 is done in Haskell.. you can ask in #perl6 to be sure
05:08:48 <JKnecht> metaperl - Acknowledged.
05:09:12 <metaperl> is there something about optional arguments that violates the idea of pure functional application?
05:11:19 <opqdonut> yes
05:11:27 <metaperl> opqdonut  - what's that?
05:11:28 <opqdonut> it violates partial application
05:11:34 <opqdonut> imo atleast
05:11:36 <metaperl> oh, currying
05:11:50 <metaperl> good point
05:12:59 <Lemmih> @seen dcoutts
05:12:59 <lambdabot> dcoutts is in #haskell.hac07, #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts speak 9h 43m 2s ago.
05:14:47 <dcoutts> hia Lemmih
05:14:51 <astrolabe> @seen dcoutts
05:14:51 <lambdabot> dcoutts is in #haskell.hac07, #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts speak 4s ago.
05:14:52 <astrolabe> ah
05:15:00 <astrolabe> Now that is magic
05:15:43 <astrolabe> dcoutts: Could you give me a hint please as to where I find out how to colour buttons?
05:15:56 <astrolabe> in hs2Gtk
05:18:54 <dcoutts> astrolabe, have you tried widgetModifyBg
05:19:22 <astrolabe> I haven't known what to try
05:19:30 <astrolabe> but I'll look that up.  Thanks
05:22:43 <dcoutts> astrolabe, more generally that kind of thing is controlled by the theme and style properties which we do not bind
05:24:25 <astrolabe> Ah, I see.  Would I use widgetModifyBg if I wanted the button to have a certain color from the start?
05:25:16 <dcoutts> astrolabe, probably, if it works :-)
05:25:39 <astrolabe> Ta.  I'm off to work now, but I'll let you know how it turns out.
05:26:09 <dozer> I'm working through an example haskell program - http://www.nomaware.com/monads/html/examples.html example 24
05:26:12 <lambdabot> Title: Haskell code examples, http://tinyurl.com/y42fms
05:26:35 <dozer> could someone explain what guard does in the function getFinalVars?
05:44:20 <dozer> ?t StateT st [] a
05:44:20 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
05:45:00 <dozer> ?type StateT st [] a
05:45:02 <lambdabot> Not in scope: `st'
05:45:02 <lambdabot>  
05:45:02 <lambdabot> <interactive>:1:13: Not in scope: `a'
05:45:18 <dozer> ?type \st a -> StateT st [] a
05:45:19 <lambdabot>   The function `StateT' is applied to three arguments,
05:45:20 <lambdabot>   but its type `(s -> m (a, s)) -> StateT s m a' has only one
05:47:06 <lennart> The guard makes sure the function returns mzero if the variable bindings are inconsistent.
05:47:27 <lennart> if c is true, the function proceeds ad returns vars
05:47:56 <lennart> ?kind StateT
05:47:57 <lambdabot> * -> (* -> *) -> * -> *
05:48:35 <dozer> lennart: so if c is false, that do-block will effectively 'terminate' at the guard?
05:51:14 <dozer> I think I'm having trouble with how the nested list is being hidden/unpacked
05:54:42 <twodogsandacat> ?where unfoldTree
05:54:43 <lambdabot> I know nothing about unfoldtree.
05:54:49 <twodogsandacat> hi all.
05:55:04 <dozer> hi
05:55:39 <twodogsandacat> anybody knows about a tutorial on Data.Tree?
05:56:22 <twodogsandacat> ?where Data.Tree
05:56:23 <lambdabot> I know nothing about data.tree.
05:56:29 * twodogsandacat sighs.
05:56:39 <Cossins> hello!
05:56:48 <dcoutts> ndm, heh, if nhc doesn't work on windows or linux, where does it work ?
05:56:52 * Cossins has a question. *raises hand*
05:56:54 <metaperl> Cossins HI
05:57:18 <Cossins> How do I specify constraints on type parameters for data types?
05:57:49 <ndm> dcoutts, in the mists of time, only, pretty much
05:57:52 <Cossins> I have data MyDataThing a b = blablabla... a needs to implement Ord
05:58:16 <ndm> dcoutts, it does work on Linux, as long as you use an older version which doesn't allocate stuff in himem (although thats since been fixed, it should work on linux now)
05:58:22 <metaperl> (Ord a) => data MyDataThingg a b
05:58:24 <dozer> Cossins: always, or in the functions that manipulate it?
05:58:26 <metaperl> something like that
05:58:27 <dcoutts> ndm, I keep seeing patches going into base to make bits work with nhc
05:58:31 <Cossins> dozer: always
05:58:41 <dozer> then what metaperl said :)
05:58:41 <dcoutts> ndm, oh, the high mem bug is fixed? when did that happen ?
05:58:55 <ndm> dcoutts, malcolm is still using it sometimes - not sure when it wsa fixed, but saw a commit message fly past
05:58:58 <metaperl> dozer what are those annotations called?
05:59:13 <twodogsandacat> Can't you set instances directly in the data definition? Just a sec...
05:59:18 <Cossins> "parse error on input `=>'"
05:59:19 <dcoutts> ndm, yes I thought it was only linux-2.4 that it worked with (ie >4 years old version)
05:59:24 <pedro> any9one here uses o'haskell?
05:59:46 <ndm> dcoutts, perhaps, i certainly know it doesn't work on any machines at York
06:00:27 <dozer> metaperl: I think the collection of things before (=>) is called the context
06:00:31 <ndm> i get a "nhc98 is not installed message" when typing nhc98 (which is weird, if its not installed i shouldnd't get a message like that!)
06:00:34 <Cossins> metaperl: are you sure about that syntax? ghci says syntax error.
06:00:49 <dcoutts> ndm, heh, wierdy
06:00:49 <metaperl> Cossins no, it is something like that, not exactly like that... hold on I will get you a ref
06:01:08 <isaacd> Cossins: the context goes after "data"
06:01:18 <isaacd> data (Ord a) => MyDataThingg a b
06:01:46 <Cossins> isaacd: hey thanks! :-) that worked.
06:01:49 <metaperl> Cossins - here is an example: http://www.haskell.org/tutorial/classes.html
06:01:50 <lambdabot> Title: A Gentle Introduction to Haskell: Classes
06:01:51 <Cossins> metaperl: thanks to you too
06:01:51 <metaperl> oh ok
06:01:54 <metaperl> sure :)
06:02:22 <twodogsandacat> ?where unfold
06:02:23 <lambdabot> I know nothing about unfold.
06:02:45 <pedro> does haskell compilers compile o'haskell code ?
06:02:53 <pedro> or vice-versa
06:03:51 <isaacd> pedro: in theory o'haskell compilers can compile ordinary haskell code. but afaik there aren't any o'haskell compilers
06:04:08 <pedro> hmm
06:04:11 <twodogsandacat> ghc 6.6 doesn't compile o'haskell afaik.
06:04:21 <pedro> isaacd, and how can i compile o'haskel code?
06:04:25 <twodogsandacat> ?where packages
06:04:25 <lambdabot> I know nothing about packages.
06:04:44 <isaacd> pedro: last I knew there was the expermental o'hugs interpreter
06:04:53 <pedro> hmm
06:05:05 <pedro> so... i can use OOP with haskell ?
06:05:18 <pedro> or OOP is only in o'haskell
06:05:18 <pedro> ?
06:05:36 <isaacd> pedro: Just ordinary Haskell is quite good, it has many elements/benefits of OOP
06:05:42 <twodogsandacat> theoretically, you could write your own OOP library.
06:05:57 <pedro> isaacd, as much as Common Lisp (for exemple) ?
06:05:57 <Lemmih> You can use functions. They're so much cooler.
06:06:54 <pedro> hmm
06:07:12 <twodogsandacat> Speaking of which, what Haskell features are like objects in OOP?
06:07:29 * earthy doesn't quite grasp the question
06:07:34 <araujo> yay!
06:07:35 <twodogsandacat> Or rather, what principles/benefits are the same?
06:07:38 <isaacd> Algebraic data types. Functions. In different ways
06:07:54 <earthy> there is overloading, but it's handled differently
06:07:55 <pedro> brb
06:08:12 <earthy> there is the ability to encapsulate functions in abstract datatypes
06:08:36 <metaperl> twodogsandacat - this article covers taht pretty well - "Software Extension and Integration with Type Classes" - http://homepages.cwi.nl/~ralf/gpce06/
06:08:39 <lambdabot> Title: Software Extension and Integration with Type Classes
06:08:39 <isaacd> You think differently in Haskell -- different kinds of abstraction are different, not bundled into one "object" concept
06:09:04 <isaacd> s/you/I/ anyway
06:09:07 <earthy> then there is parametric polymorphism, which oftentimes obviates the need for having objects in the first place
06:09:15 <metaperl> classes and objects
06:09:29 <earthy> and at other times the overloading combined with the parametric polymorphism allows you to express what you want cleanly
06:09:34 <twodogsandacat> The way I see it - and forgive my "newbie-ness", OO's objects model boundaries between entities while Haskell abstracts on the level of domains.
06:09:40 <twodogsandacat> If that makes any sense?
06:09:54 <pedro> isaacd, can you say to me a good book about haskell?
06:09:55 <earthy> some sense, yes
06:10:10 <isaacd> pedro: no, I don't know any books about haskell
06:10:14 <earthy> in OO objects, overloading is entangled with objects
06:10:18 <earthy> in Haskell this is decoupled
06:10:21 <metaperl> "Craft of Functional Programming" by Simon J. Thompson pedro
06:10:29 <pedro> ok, i will search...
06:10:34 <earthy> however, you can still model boundaries between entities
06:10:57 <earthy> as functions are first class citizens and therefore can be tupled with other data easily
06:11:06 <araujo> pedro, Introduction to Functional Programming , Richard Bird.
06:11:43 <earthy> pedro, 'The Haskell School of Expression' by Paul Hudak
06:11:43 <earthy> :)
06:11:53 <dozer> the problems that a lot of the oo design patterns tackl (state, visitor, factory...) can be addressed directly in functional programming by just using higher-order functions
06:12:06 <metaperl> earthy - hard to get the right libs for SOE... I liked the book but got dismayed at the state of the libraries
06:12:16 <metaperl> Graphics.SOE, etc
06:12:18 <earthy> metaperl: true
06:12:30 * araujo thinks functional languages actually tend to offer better abstractions than oo
06:12:56 * dozer agrees, but still hasn't had a eurecka moment with monads
06:13:14 * dozer can sometimes use them right but isn't grocking them
06:13:17 <twodogsandacat> what part of monads is bugging you, dozer?
06:13:50 <dozer> I think it's what is going on inside a do-block
06:13:57 <earthy> monads are much like schroedinger's equations. you don't grok them, you just get used to them.
06:14:02 <twodogsandacat> lol!
06:14:05 <metaperl> araujo - Bird's book is prohbitively expensive: http://www.amazon.com/Introduction-Functional-Programming-Prentice-International/dp/0134841972
06:14:08 <dozer> I'm still working through http://www.nomaware.com/monads/html/examples.html example 24
06:14:09 <lambdabot> http://tinyurl.com/y8of4k
06:14:09 <lambdabot> Title: Haskell code examples, http://tinyurl.com/y42fms
06:14:29 <dozer> so now I'm confused with tryAllValues - I think because of this do-block thing
06:14:38 <twodogsandacat> dozer - what's really going on is: the interpreter is stripping the "do" syntactic sugar away.
06:15:16 <twodogsandacat> And what's left is a function composition.
06:15:26 <dozer> I understand the 'do' is fluf, and that >>= is used to glue everything together, but that's not helping me
06:15:32 <araujo> metaperl, it is worthy
06:16:07 <twodogsandacat> Try writing the >>= syntax directly yourself, and also check out the rules for removing the fluff.
06:16:15 <isaacd> dozer: if you just see the raw monadic syntax without "do", does it make sense to you?
06:16:18 <twodogsandacat> Maybe that will give you the 'heureka' moment.
06:16:19 <araujo> dozer, where ar you stuck at?
06:16:35 <dozer> isaacd: syntactically, but I don't get what it's 'doing'
06:16:39 <araujo> metaperl, it is actually one of the best book ive read
06:17:09 <twodogsandacat> Really, check out the rules for converting 'do' into de-sugared Haskell.
06:17:15 <twodogsandacat> It helped me a lot.
06:17:25 <dozer> I'm stuck at understanding the tryAllValues function in that example above
06:17:56 <isaacd> which is basically: "x <- ..." is moved around to "... >>= \x ->"
06:18:10 <twodogsandacat> (btw, anybody remembered anything about unfoldTree?)
06:20:09 <dozer> what happens to bits in a do that don't have a <- on them?
06:20:20 <metaperl> araujo - it's based on haskell98?
06:20:23 <metaperl> thank god the internet didn't take a thanksgiving break
06:21:14 <metaperl> araujo - but is it based on haskell98?
06:21:16 <isaacd> dozer: personally, I although I got used to monads, I think this was the thing that "made the most sense" to me: http://www.haskell.org/pipermail/haskell-cafe/2006-November/019190.html
06:21:18 <lambdabot> Title: [Haskell-cafe] there's a monster in my Haskell!, http://tinyurl.com/y49m75
06:21:32 <twodogsandacat> dozer: >>= Q _ ->
06:21:41 <twodogsandacat> sorry: >>= \ _ ->
06:21:52 <isaacd> I don't know how good it is for getting used to monads before you are already, though
06:21:52 <araujo> metaperl, "B&W was dense, and magic. It reminded me of the first time I read the K&R C book" , in one of the amazon review
06:22:20 <metaperl> yes, but what language is it based on :)
06:22:26 <araujo> metaperl, it's amazing, i had just the _very_ same feeling
06:22:39 <dozer> i sure as hell am not writing this code manually managing and branchign the state :)
06:22:40 <araujo> metaperl, yes, haskell98
06:22:58 <twodogsandacat> lol
06:23:07 <twodogsandacat> do it just as an exercise
06:45:08 <dozer> where could I find the deffinition of >>= for Monad []
06:45:36 <Stinger> concatMap isnt it?
06:50:04 <beschmi> dozer, http://www.google.com/codesearch?hl=en&lr=&q=%22Monad+%5B%5D%22&btnG=Search
06:50:07 <lambdabot> Title: "Monad []" - Google Code Search, http://tinyurl.com/y5yvld
06:50:39 <dozer> so if I have "do c <- someList", then now c will range over each element of someList?
06:52:10 <dozer> thanks beschmi
06:52:51 <metaperl> Yo, I have a list of strings representing shell commands... How can I print each of these and have the shell execute them?
06:53:48 <Syzygy-> print each onewould be something like putStrLn $ unlines mylist
06:54:48 <metaperl> Syzygy- thanks
07:14:41 * Syzygy- is trying my best to outgeek planet haskell... :P
07:15:10 <metaperl> > take 5 [1..]
07:15:17 <lambdabot>  [1,2,3,4,5]
07:15:30 <dcoutts> @seen SyntaxNinja
07:15:31 <lambdabot> I saw SyntaxNinja leaving #haskell, #darcs and #haskell-blah 1d 11h 28m 38s ago, and .
07:20:08 <eviltwin_b> l >>= putSrLn >>= System.system
07:20:11 <eviltwin_b> whoops
07:20:33 <eviltwin_b> very not.
07:23:35 <dozer> @paste
07:23:36 <lambdabot> http://paste.lisp.org/new/haskell
07:23:55 <lisppaste2> dozer pasted "trouble with do" at http://paste.lisp.org/display/30555
07:25:37 <dozer> I'm trying to run the first func-arg to generate a [t] from the symState
07:26:05 <dozer> and then use the seccond fun-arg to generate a new simulation state from each choice of t
07:26:59 <eviltwin_b> trf isn't monadic, so you don't want or need monad-unwrapping
07:27:26 <eviltwin_b> so return $ step $ trf state
07:28:09 <dozer> that complains that t can't be matched with [t]
07:29:20 <eviltwin_b> hm, looking closer, this does seem a bit confused, esp. since step returns a monad
07:30:29 <dozer> it's meant to return the new state, and some parameter, so I guess hsould be in State, not StateT
07:31:44 <eviltwin_b> hm, not so good with nested monads as yet (list inside StateT), wait for someone with more intelligence to show up :)
08:12:43 <tobbes> greetings I'm trying to prove that rev rev xs = xs, but I get stuck in the inductive case with rev rev xs ++[x]) obviously I want to rewrite this in some way to rev(rev xs) ++ [x] and then use the induction hypothesis
08:12:48 <Cale> Syzygy-: awesome
08:13:17 <Cale> tobbes: rev rev xs is a type error
08:13:19 <flux__> tobbes, I don't have any real suggestions, but have you taken a look at machine proving assistants?
08:13:29 <Cale> so yeah, you really do want rev (rev xs)
08:13:46 <Cale> (at least, if you mean what I think you mean by rev)
08:13:52 <flux__> tobbes, I faintly recall one had (four letters and 2?) that case in their tutorial too..
08:13:57 <kpreid> (rev (rev xs) = xs only if xs is finite, of course)
08:14:24 <tobbes> yes I know
08:14:31 <tobbes> I'm trying to prove it
08:14:34 <tobbes> by induction
08:15:11 <tobbes> so rev rev x:xs = rev(rev(xs)++[x]) by definition of rev
08:15:32 <tobbes> and the induction hypothesis is that rev rev xs = xs
08:15:54 <kpreid> so prove that rev(xs ++ [y]) = y : rev xs?
08:17:10 <tobbes> hmm good point
08:18:19 <tobbes> and then rewrite that to reverse(reverse xs) ++[x]
08:24:38 <LoganCapaldo> this must be the only channel where people try to prove things with induction on thanksgiving
08:24:58 <eviltwin_b> us-centric...
08:25:24 <LoganCapaldo> it doesn't matter if I'm us-centric, I bet you its still true ;)
08:25:36 <tobbes> well, I'm not american so I don't celebrate thanksgiving :)
08:26:37 <tobbes> hmm so I got to ys ++ [y]
08:26:44 <tobbes> can I rewrite that to y:ys?
08:27:23 <LoganCapaldo> You can't, can you? y:ys /= ys ++ [y]
08:27:36 <tobbes> I don't think so either
08:27:41 <tobbes> hmm
08:27:58 <tobbes> stuck again, then
08:28:30 <LoganCapaldo> Have you tried starting with reverse [x] = [x] ?
08:28:46 <tobbes> ??
08:29:02 <LoganCapaldo> I dunno
08:29:03 <tobbes> I started with xs = []
08:29:09 <tobbes> and proved the property for that
08:29:16 <LoganCapaldo> induction is all about the f(n), f(n + 1)
08:29:17 <tobbes> and now I try to show the inductive step
08:29:44 <tobbes> so what do you suggest? :)
08:29:59 <LoganCapaldo> hmm
08:30:43 <LoganCapaldo> Nothing really
08:30:45 <LoganCapaldo> lol
08:31:09 <pkhuong> tobbes: a lemma that rev (y ++ x) = (rev x) ++ (rev y)
08:31:31 <tobbes> hmm yes
08:31:35 <Nickf> hi, is there anyone who can give some advice on unit testing haskell?
08:31:57 <LoganCapaldo> > let y = [1,2,3] in let x = [4,5,6] in [rev (y ++ x), (rev x) ++ (rev y)]
08:31:58 <lambdabot>  Not in scope: `rev'
08:32:13 <LoganCapaldo> > let y = [1,2,3] in let x = [4,5,6] in [reverse (y ++ x), (reverse x) ++ (reverse y)]
08:32:14 <lambdabot>  [[6,5,4,3,2,1],[6,5,4,3,2,1]]
08:32:23 <LoganCapaldo> well I'll be
08:32:37 <LoganCapaldo> for some reason I didn't expect that to work
08:33:10 <pkhuong> LoganCapaldo: yeah, rev doesn't need as strong a combinator as fold, since it's associative and has a zero ([]).
08:33:25 <tobbes> so then I would get rev(rev(ys) ++ rev([y])
08:34:09 <pkhuong> tobbes: actually, I went with an arbitrary split with both left and right portions non-empty, but sure.
08:34:27 <tobbes> how does that help me?
08:34:36 <pkhuong> what? what you just got?
08:34:44 <tobbes> I still need to lift out the [x] in some way so that I can use the IH
08:35:22 <pkhuong> rev (rev ys) ++ (rev [y]) ... does that look like anything?
08:35:50 <pkhuong> * rev ((rev ys) ++ (rev [y]))
08:36:00 <LoganCapaldo> hmm
08:36:15 <malcolm> ndm: i was wondering what machine you were using that doesn't have nhc98 installed on it?
08:36:19 <kpreid> LoganCapaldo: why didn't you expect that to work?
08:36:34 <LoganCapaldo> kpreid: My intuition betrayed me?
08:36:34 <tobbes> pkhuong - hmm, no not really
08:36:40 <tobbes> ;)
08:36:50 <LoganCapaldo> rev ((rev ys) ++ [y])
08:36:58 <pkhuong> is this homework?
08:37:04 <tobbes> no
08:37:06 <kpreid> LoganCapaldo: also, you can replace "in let" with ";"
08:37:37 <LoganCapaldo> rev ((rev qs ++ rev  [q]) ++ [y]
08:37:48 <LoganCapaldo> etc.
08:37:53 <LoganCapaldo> Is that a proof?
08:37:58 <pkhuong> tobbes: apply the same lemma. rev ((rev ys) ++ (rev [y])) = (rev (rev [y])) ++ (rev (rev ys))
08:38:27 <tobbes> I must be really stupid
08:38:32 <tobbes> but I don't follow
08:38:45 <LoganCapaldo> rev [x] = [x] right?
08:39:05 <LoganCapaldo> so if you jsut keep doing that you get [a] ++ [b] ++ [c] ++ [d] ...
08:39:09 <LoganCapaldo> I think
08:39:51 <pkhuong> tobbes: `rev (y ++ x) = (rev x) ++ (rev y)' here, y = (rev ys) and x = (rev [y])
08:40:25 <tobbes> ??
08:41:58 <tobbes> and I probably am not smart enough anyway to prove that rev(x ++ y) = rev(x) ++ rev(y)
08:42:07 <tobbes> maybe I should just drop this course...
08:42:08 <tobbes> :)
08:43:41 <ProfTeggy> tobbes, it is rev (x ++ y) = rev y ++ rev x, by the way  (note order of x and y ;-)
08:44:07 <ProfTeggy> Just so you safe unwieldy hours of hopeless proof attempts ;-)
08:44:12 <ProfTeggy> save, rather
08:45:07 * earthy grins
08:45:34 <dozer> ok, I am totaly stuck
08:45:55 <dozer> how would I write this: liftState::State s a -> StateT s [] a
08:50:04 <araujo> hello!
08:50:09 * araujo back at home
08:50:24 <Cale> liftState x = do s <- get; let {(y,s') = runState x s}; put s'; return y
08:50:48 <lennart> ?users
08:50:48 <lambdabot> Maximum users seen in #haskell: 276, currently: 245 (88.8%), active: 29 (11.8%)
08:52:03 <tobbes> rev(xs ++ ys) = rev(ys ++ xs)
08:52:13 <tobbes> this can't be true, right?
08:52:18 <tobbes> in the general case..
08:52:18 <Cale> tobbes: that's rarely true
08:52:44 <dozer> ah, thanks Cale - that's been bugging me for far too long
08:53:10 <tobbes> on the other hand reverse(xs ++ ys) = reverse(ys) ++ reverse(xs)
08:53:13 <Cale> @quickcheck \xs ys -> rev ((xs :: [T]) ++ ys) = rev (ys ++ xs)
08:53:14 <lambdabot> Unknown command, try @list
08:53:17 <tobbes> He must have meant that
08:53:24 <Cale> @check \xs ys -> rev ((xs :: [T]) ++ ys) = rev (ys ++ xs)
08:53:24 <lambdabot>  Parse error
08:53:27 <Cale> er
08:53:39 <Cale> @check \xs ys -> reverse ((xs :: [T]) ++ ys) = reverse (ys ++ xs)
08:53:40 <lambdabot>  Parse error
08:53:51 <Cale> @check \xs ys -> reverse ((xs :: [T]) ++ ys) == reverse (ys ++ xs)
08:53:52 <lambdabot>  Falsifiable, after 4 tests: [[1,-4],[],[4,-1,-2]], [[-5,2],[-5,-3,1,-4,4],[-...
08:54:03 <Cale> excuse me, I just woke up
08:54:08 <Cale> :)
08:54:32 <Cale> @check \xs ys -> reverse ((xs :: T) ++ ys) == reverse (ys ++ xs)
08:54:34 <lambdabot>  Falsifiable, after 4 tests: [1], [2,-1]
08:54:42 <gaal> hello. I noticed debian unstable ships ghc6.6 now; but the package does not include extralibs. what's the debianly correct way of getting them?
08:54:46 <Cale> there we go
08:55:11 <gaal> ooh shiny!
08:59:13 <vraj> How do I install lamdbabot locally? I am new to Haskell and have never installed an external package...
08:59:48 <edwardk_> vraj: you download a lot of packages and keeep installing them until lambdabot runs =)
09:01:13 <vraj> Any more helpful answer:-) ?
09:02:08 <pejo> gaal, isn't there another package with the extralibs?
09:02:16 <edwardk_> vraj the usual process is to go in runhaskell Setup.lhs configure; runhaskell Setup.lhs build; runhaskell Setup.lhs install
09:02:22 <edwardk_> then spot that it complained about a missing package
09:02:28 <edwardk_> then go to darcs.haskell.org
09:02:31 <edwardk_> and download the package
09:02:34 <edwardk_> and rinse was repeat
09:02:40 <gaal> pejo: not that I can see here: http://packages.debian.org/cgi-bin/search_packages.pl?keywords=ghc&searchon=names&subword=1&version=unstable&release=all
09:02:44 <edwardk_> lambdabot is a bit of a pathological example of this process
09:02:50 <lambdabot> Title: Debian -- Debian Package Search Results, http://tinyurl.com/y68zmh
09:02:52 <edwardk_> as it requires just about everything
09:03:03 <edwardk_> =)
09:04:42 <vraj> Thanks, is there an easier package to start with, to get my feet wet? I am looking for a command-line browse/search feature which lambdabot seems to provide
09:05:13 <edwardk_> pretty much any other package will be easier to install to get used to cabal
09:05:33 <edwardk_> once you have built up a bit of stamina for the process, then lambdabot isn't that bad
09:05:59 <pejo> gaal, ah. There's atleast libghc6-mtl-dev, maybe the bits and pieces of extralibs are available as separate packages?
09:09:38 <gaal> pejo: oh! thanks; that package didn't come up on the search page for some reason. yes, this is more like it.
09:10:10 <gaal> a metapackage with all the extralibs would be nice. (but maybe it also already exists?)
09:11:05 <pejo> gaal, apt-cache search ghc6 should give the desired result. Dont' have a debian box handy.
09:12:51 <gaal> there doesn't seem to be one.
09:15:48 <vincenz> holy cow
09:15:59 <vincenz> SPJ is british, I always imagined him with an american accent
09:16:09 <Cale> hehe
09:16:30 <Cale> which video of him are you watching? The STM one?
09:21:00 <lennart> he's very british :)
09:26:39 <vincenz> Cale: yeah the one with harris
09:26:40 <vincenz> stm
09:28:50 <therp> what videos?
09:29:53 <Cale> http://channel9.msdn.com/Showpost.aspx?postid=231495
09:29:56 <lambdabot> Title: Programming in the Age of Concurrency: Software Transactional Memory, http://tinyurl.com/ylylaa
09:33:57 <vincenz> LOOOL
09:34:06 <opqdonut> ok
09:34:40 <vincenz> SPJ: "We've only just started to improve the performance, if we throw a few 100% phd students into the trenches, by stamping onto their bodies we'll be able to build a wall faster"
09:34:51 <vincenz> 100 not 100%
09:35:04 <Cale> haha
09:35:07 <opqdonut> 100% phd guaranteed
10:05:25 <monochrom> hello
10:36:34 <tobbes> greetings
10:36:43 <tobbes> still trying to understand induction properly
10:37:13 <tobbes> how would you use the definition of ++ on a pair of arguments xs y:ys
10:37:15 <tobbes> ?
10:37:20 <opqdonut> e = -L d\Phi/dt
10:37:22 <opqdonut> nothing to it
10:37:44 <tobbes> it seems to me that I cannot know if xs is an empty list or a list with a head and a tail
10:37:57 <tobbes> so how can I use it in inductive proofs?
10:38:02 <tobbes> for example
10:38:14 <tobbes> length reverse(xs) = length(xs)
10:38:39 <opqdonut> an empty list wont match y:ys
10:38:39 <tobbes> assume xs = y:ys then length(y:ys) = length ys +1
10:38:46 <tobbes> yes
10:38:47 <tobbes> I know
10:38:51 <pkhuong> tobbes: you can use ++ inductively if you ask that both parts of the split are non-empty.
10:39:09 <tobbes> ok
10:39:19 <pkhuong> (that means you have 2 base cases, btw)
10:39:29 <tobbes> so this simplifies to length(xs) ++ x
10:39:39 <tobbes> how do I go on from here?
10:40:03 <tobbes> given that length(rev(xs)) = length xs
10:40:39 <monochrom> assume length(rev(xs)) = length xs, prove length(rev(x:xs)) = length(x:xs).
10:40:42 <pkhuong> You probably want to use length (x ++ y) == length x + length y (see a pattern here?)
10:41:12 <tobbes> hmm yes
10:41:16 <monochrom> If you need the lemma length (x ++ y) == length x + length y, prove this lemma by induction too.
10:41:29 <tobbes> yes
10:41:33 <tobbes> that lemma would help
10:42:30 <tobbes> so if x = [] then length(x ++ y) is obviously length(y)
10:43:33 <tobbes> and then assuming that x = y:ys and assuming that length(ys++xs) = length xs + length ys
10:43:50 <tobbes> then I get x:(xs++ys)
10:44:27 * lispy wants to learn how to build buildings without using bananas
10:44:31 <pkhuong> tobbes: why are you destructuring your argument twice?
10:44:43 <ihope_> data FL a = a :+: !(FL a) | E -- is this a finite list?
10:44:51 <tobbes> and length x:(xs++ys) = 1 + length(xs++ys) and length(xs++ys) = length(xs) + length(ys) by IH
10:45:24 <tobbes> then length(x:xs ++ y) must be length(xs)+length(ys) +1
10:45:28 <tobbes> correct?
10:46:18 <monochrom> No, ihope_.
10:46:42 <ihope_> That's nice...
10:46:42 <monochrom> Damn, I may be wrong.
10:47:20 <monochrom> myrepeat x = x :+: myrepeat x
10:47:26 <lispy> this video about stm is interesting, but the camera work and audio leaves a lot to be desired
10:47:43 <monochrom> If myrepeat x works, or if it doesn't work, you know the answer.
10:49:58 <Binkley> lispy: maybe jean-luc godard will do the remake
10:50:13 <lispy> Binkley: hehe
10:53:40 <monochrom> length (x:xs ++ ys) =?= length (x:xs) ++ length ys
10:53:51 <Heffalump> +, not ++
10:54:44 <monochrom> length (x:xs ++ ys) = length (x : (xs++ys)) = 1 + length (xs++ys) =ih= 1 + length xs + length ys = length(x:xs) + ys.
10:55:09 <monochrom> It's just algebra.
10:56:16 <Heffalump> what's length _|_ ?
10:56:23 <Heffalump> oh, _|_, duh
10:57:12 <monochrom> Stylistic remark.  I also don't like to write like "if x=[] ... if x=z:zs ...".  It wastes the symbol x.
10:58:59 <monochrom> Stylistic remark.  I don't like to reason in English or any daily language.  It's distracting and unorganized, potentially incoherent.
11:00:31 <lispy> oh, they implemented stm for C#...interested
11:00:35 <lispy> er interesting*
11:01:12 <monochrom> W00T!
11:01:46 <monochrom> OK I'm officially switching from Java to C# now!
11:03:07 <pkhuong> youths these days... you're supposed to take that as a challenge to implement an STM in java!
11:03:14 <dcoutts_> Heffalump, congratulations BTW.
11:03:52 <monochrom> I'm a theorist. I'm supposed to theorize.
11:04:19 <monochrom> I'm also very old.
11:06:36 <Botje> mathematician :: Coffee -> [Theorems]
11:06:39 <Botje> mathematician :: Coffee -> [Theorem]
11:06:40 <Botje> even :)
11:07:15 <tibbe> actually that's a time dependent function
11:07:26 <tibbe> the effects of coffee diminishes over time
11:07:44 <eviltwin_b> IO Coffee -> IO [Theorem] -- surely?
11:07:56 <Botje> not all coffee is the same :)
11:08:02 <tibbe> nah, probably in the coffee monad
11:08:04 <glguy> IO Coffee? or Coffee?
11:08:46 <Botje> so what would the coffee monad do?
11:09:01 <Botje> give a task a certain chance of success, depending on caffeine level?
11:12:19 <emu> has anyone ever written code which calls a Haskell library from Java?
11:12:41 <eviltwin_b> Coffee [Cup] -> IO [Theorem]
11:13:01 <glguy> Cup<T>
11:14:03 <lispy> emu: that is doable
11:14:18 <lispy> emu: but most approaches go through JNI on the java side and the FFI on the haskell side
11:14:49 <emu> to link it as a C library?
11:15:05 <lispy> emu: and i bet some people have compiled haskell to the java bytecode, but i don't know how well that interoperates
11:15:09 <lispy> emu: correct
11:15:28 <emu> can you return arbitrary haskell data, opaquely, such that java could hand it to other functions?
11:15:53 <lispy> emu: well, kind-of.  You're limited by what you can pass through the FFI
11:16:19 <fabiim> if i do foldr (\x y-> x + y*10) 1 [1,2,3] , for every y (1,2,3) what do x stands for?
11:16:28 <lispy> emu: for example, i don't think exported functions can be polymorphic
11:17:09 <glguy> I wonder if amazon is down now because they were offering XBox360 Core for $100 12 minutes ago
11:17:13 <emu> hmm.  a circularly-linked graph? =)
11:17:19 <mauke> fabiim: huh? x is 1, 2, 3 (the current list element)
11:17:38 <emu> actually i've been pondering how i could marshal this efficiently
11:17:42 <fabiim> so the first step in the evolution in that function is what?
11:18:06 <jcreigh> > foldr (:) [] [1,2,3]
11:18:08 <lambdabot>  [1,2,3]
11:18:17 <jcreigh> think of it like 1 : 2 : 3 : []
11:18:18 <mauke> 1 + (foldr 1 [2,3])*10
11:18:30 <mauke> er, missing function
11:18:35 <emu> @type foldr
11:18:37 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
11:18:51 <fabiim> i understand foldr , the lambda thing is the one making me confuse about
11:18:52 <mauke> 1 + (foldr (\x y-> x + y*10) 1 [2,3])*10
11:19:07 <fabiim> .\x y -> x + y*10
11:19:13 <tibbe_> > [1..]
11:19:14 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
11:19:22 <tibbe_> > length [1..]
11:19:26 <lambdabot> Terminated
11:19:26 <vincenz> eviltwin_b: you need a lifting operatiorn like liftIO
11:19:32 <mauke> fabiim: what do you not understand about lambda?
11:19:42 <vincenz> liftHead :: Coffee [Cup] -> IO [Theorem]
11:19:43 <lispy> emu: well, usually you can make your datatype an instance of storable (which ammounts to telling haskell how to poke your data into a chunk of memory) and then just marshall as you need :)
11:20:00 <emu> that's not derivable is it?
11:20:29 <lispy> emu: i don't think so
11:20:31 <fabiim> in foldr (\x y-> x + y*10) 1 [1,2,3] , the first evaluation is  x + 1*10 ,  x == 1? it can't be ...
11:20:50 <lispy> emu: but, DriFT (which i've never used) might be able to derive it
11:20:55 <fabiim> x== foldr 1 [2,3] ?? like mauke said ? i don't get it ...
11:20:57 <jcreigh> fabiim: x is the current element of the list, and y is the rest of the list already folded.
11:21:21 <eviltwin_b> yeh
11:21:31 * eviltwin_b mentioned ear;lier he was bad at such things still :>
11:22:20 <pkhuong> fabiim: fold_r_, starting from the right.
11:22:45 <jcreigh> > foldr (\x y -> x + y*10) 1 [1,2,3]
11:22:47 <lambdabot>  1321
11:23:02 <jcreigh> > foldr (\x y -> x + y*10) 1 [2,3]
11:23:03 <lambdabot>  132
11:23:05 <jcreigh> > foldr (\x y -> x + y*10) 1 [3]
11:23:07 <lambdabot>  13
11:23:08 <jcreigh> > foldr (\x y -> x + y*10) 1 []
11:23:10 <lambdabot>  1
11:23:58 <fabiim> > foldr (\x y -> x + y*10) 0  [1,2,3]
11:24:00 <lambdabot>  321
11:24:00 <pkhuong> > foldl (\s x -> x + 10 * s) 0 [1..5]
11:24:01 <lambdabot>  12345
11:24:04 <fabiim> > foldr (\x y -> x + y*10) 0  [2,3]
11:24:06 <lambdabot>  32
11:24:07 <fabiim> > foldr (\x y -> x + y*10) 0  [3]
11:24:08 <fabiim> > foldr (\x y -> x + y*10) 0  []
11:24:08 <lambdabot>  3
11:24:10 <lambdabot>  0
11:24:29 <monochrom> You can /msg lambdabot
11:25:12 <fabiim> sorry
11:26:28 <fabiim> so y is the aplication of my function to every element that haven't been "foldr" in the list?
11:26:33 <fabiim> starting from right ...
11:26:34 <fabiim> ?
11:27:28 <lispy> foldr (\x y -> x + y) 0 [2,3,4] == (2 + (3 + (4 + 0)))
11:27:38 <lispy> you can't see this with (+), but try (-)
11:27:58 <mauke> y is the result of folding the rest of the list
11:28:00 <lispy> > foldr (\x y -> x - y) 0 [2..4]
11:28:02 <lambdabot>  3
11:28:06 <lispy> > foldl (\x y -> x - y) 0 [2..4]
11:28:08 <lambdabot>  -9
11:28:53 <lispy> > (2 - (3 - (4 - 0)))
11:28:55 <lambdabot>  3
11:29:24 <lispy> > (((0 - 2) - 3) - 4)
11:29:25 <lambdabot>  -9
11:30:08 <monochrom> In more detail,  foldr op 0 (x:xs) = op x (foldr op 0 xs).  If you think of op as (\x y -> op x y), you have (foldr op 0 xs) plugged into y.
11:30:11 <fabiim> i think i finally get it lol =) tks
11:30:27 <mauke> > foldr (\x y -> "current: " ++ show x ++ "; rest: {" ++ y ++ "}") "end" [1,2,3]
11:30:28 <lambdabot>  "current: 1; rest: {current: 2; rest: {current: 3; rest: {end}}}"
11:31:55 <fabiim> foldl will do exactly the same thing but starting left , right?
11:32:16 <lispy> correct
11:33:20 <mauke> > foldl (\x y -> "previous: {" ++ x ++ "}; current: " ++ show y) "start" [1,2,3]
11:33:21 <lambdabot>  "previous: {previous: {previous: {start}; current: 1}; current: 2}; current: 3"
11:33:27 <lispy> fabiim: and because foldl starts at the left, you can make a version which completely constructs the value it's building up (instead of doing it lazily)
11:33:39 <lispy> fabiim: and that version of foldl is called foldl'
11:34:29 <lispy> fabiim: it's useful when you buildiing a value which takes up less memory than the unevaluated value would take up
11:35:48 <fabiim> lispy: so that version carry's the actual value until the end of the calculation right?
11:36:48 <lispy> fabiim: not sure what you mean, but the lazy version, foldl, doesn't compute the answer until it is needed, instead it just builds up the "thing" that can be evaulated
11:37:25 <lispy> fabiim: the strict version, foldl', doesn't build up the "thing" it actually computes the value as it goes
11:38:03 <integral> @djinn a -> a -> ()
11:38:03 <lambdabot> f _ _ = ()
11:38:13 <integral> @djinn a -> b -> ()
11:38:13 <lambdabot> f _ _ = ()
11:38:43 <integral> hmm, so are there no expressions that would be inferred to have that type?
11:38:51 <fabiim> i lispy yeah i get it , but i need to play around with those functions tough , nothing like practising
11:39:21 <lispy> fabiim: yes, practice! ;)
11:40:10 <glguy> integral: without a unsafe coersion, such a function could never do anything
11:40:49 <integral> glguy: *nod* I'm just doing some type level programming, so it's a handy tool
11:41:02 <glguy> but i suppose that it could return ``undefined''
11:41:28 <monochrom> (\x y -> ()) has that type.
11:41:40 <monochrom> (\x y -> ()) is an expression too.
11:42:33 <glguy> ?type const () . const
11:42:35 <lambdabot> forall a. a -> ()
11:42:47 <lispy> how is \x y -> () different from f _ _ = ()?  other than syntatically?
11:42:56 <glguy> ?type (const () .) . const
11:42:57 <lambdabot> forall a a1. a1 -> a -> ()
11:43:40 <monochrom> No difference.  But someone asked for an expression.
11:43:55 <integral> monochrom: I was wanting the first type, I obviously had the one that had the second type
11:51:38 <lisppaste2> metaperl pasted "monad time" at http://paste.lisp.org/display/30573
11:51:55 <monochrom> It's monad time!
11:52:07 <mauke> no, dad! no!
11:52:28 <metaperl> :)
11:52:36 <metaperl> catchy title. I knew it would work to get me some help :)
11:52:59 <dcoutts> why does this need a monad ?
11:53:11 <metaperl> dcoutts I dont know... maybe it does not
11:53:15 <metaperl> but I dont know how to do it
11:53:29 <dcoutts> try breaking the problem down into smaller bits
11:53:33 <mauke> @type forM
11:53:35 <lambdabot> Not in scope: `forM'
11:54:23 <dcoutts> I think forM encourages bad style
11:54:31 <dcoutts> I'd prefer sequence_
11:54:41 <metaperl> googling for ghc execute system command yields nothing
11:54:44 <mauke> why?
11:54:49 <dcoutts> generate in a pure way all the work you indend to do and then do it
11:54:59 <dcoutts> @hoogle system
11:55:00 <lambdabot> System.system :: String -> IO ExitCode
11:55:00 <lambdabot> System :: module
11:55:00 <lambdabot> System.Win32.Info.SystemColor :: type SystemColor
11:55:24 <mauke> metaperl: http://haskell.org/ghc/docs/latest/html/libraries/base/System-Cmd.html
11:55:26 <lambdabot> http://tinyurl.com/yg2s4l
11:55:28 <emu> i don't think DriFT can handle cyclic data structures
11:55:38 <metaperl> ok...
11:55:53 <monochrom> Write a function that works for one tuple (no list).  Add map or mapM or mapM_.  I know dcoutts disagrees.
11:56:08 <dcoutts> using map is fine
11:57:41 <dcoutts> sequence_ [ putStr (dlMsg n) >> system cmd | (cmd, n) <- stuff ]
11:58:12 <dcoutts> oh, I misread, "print the shell command and then execute it"
11:58:28 <dcoutts> sequence_ [ putStrLn (dlMsg n) >> putStrLn cmd >> system cmd | (cmd, n) <- stuff ]
11:59:03 <dcoutts> monochrom, I presume you want to print the dlMsg (though you don't say so)
11:59:18 <dcoutts> oops I meant metaperl
11:59:22 <metaperl> dcoutts yes I want to rpint it
11:59:53 <dcoutts> metaperl, here's a tip, you don't need to start with a list of tuples with the index, you can use:
12:00:16 <dcoutts> [ ... | (n, thing) <- zip [1..] stuff ]
12:00:34 <dcoutts> zip [1..]  enumerates things
12:00:39 <metaperl> yeah I was breaking it down
12:00:52 <metaperl> I did enumerate them: goGetEm = [z |  z <- zip download [1..] ]
12:01:01 <dcoutts> ok
12:01:04 <metaperl> download is the list of urls
12:01:09 <metaperl> actually the list of syscmds
12:01:29 <metaperl> now I just want to improve doOne... doOne (shell_cmd, n) = system shell_cmd
12:02:25 <metaperl> instead of it just doing the syscmd, I want it to putStrLn dlMsg ... then putStrLn url and then do the syscmd
12:02:34 <metaperl> I was trying to avoid do notation
12:03:10 <dcoutts> metaperl, you can use >> like I did in my solution
12:03:11 <metaperl> I dont understand >>
12:03:18 <metaperl> @type (>>)
12:03:19 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b -> m b
12:03:25 <dcoutts> do { a; b } = a >> b
12:03:39 <metaperl> shucks
12:03:55 <dcoutts> do { x <- a; b x } = a >>= b
12:19:14 <mauke> java homework is much more fun if you're insane
12:19:31 <stepcut> :p
12:19:47 <mauke> http://rafb.net/paste/results/AgIihp83.html  http://rafb.net/paste/results/yLVkwb37.html  http://rafb.net/paste/results/4FIS8D10.html  http://rafb.net/paste/results/ffkndZ33.html  (my solution)
12:21:02 <mauke> (haskell programmers should understand how stuff like ((. set-a-i i2) . (>>) . set-a-i i1) works :-)
12:21:24 <monochrom> Eh, which of the four pastes should I read?
12:22:57 <mauke> the first two are the actual program, using the third file for all the real work
12:24:17 <mauke> http://rafb.net/paste/results/yLVkwb37.html is short and awesome IMHO :-)
12:27:07 <metaperl> this Wikipedia article on monads is great... http://en.wikipedia.org/wiki/Monads_in_functional_programming
12:27:10 <lambdabot> http://tinyurl.com/y586b9
12:27:13 <metaperl> a very good beginner article
12:27:25 <metaperl> I could've taught myself what I wasted everyone's time on
12:29:43 <stepcut> metaperl: I think by 'function composition', Cliff means Haskell is nice enough to provide (.) by default
12:29:57 <stepcut> I don't think ocaml provides an infix composition operator..
12:30:03 <metaperl> stepcut - oh wow
12:30:09 <metaperl> stepcut - you work at linspire?
12:30:13 <stepcut> yes
12:30:17 <metaperl> nice
12:30:35 <metaperl> is there a linspire IRC channel?
12:31:04 <metaperl> another person "thetallguy" works there too I understand
12:31:05 <stepcut> I think there is a linspire user channel somewhere -- but no linspire employees hang out there
12:32:25 <stepcut> one of the reasons for switching from O'Caml to Haskell is Haskell is just more aesthetically pleasing
12:32:48 <metaperl> yes, I read the slides.. "OCaml is a mess of nested letrecs" :)
12:33:05 <stepcut> yeah
12:33:14 <metaperl> At least OCaml can compile on any platform in 3 minutes though
12:33:22 <metaperl> ghc is a compilation nightmare
12:33:35 <stepcut> I can 'apt-get install ghc' in under 3 minutes ;)
12:33:59 <metaperl> I can't believe Jane St. Capital is using OCaml for financial work... I wonder how many times they type "+." or "/." in a day
12:34:05 <stepcut> heh
12:34:07 * lispy waits for people to reply to his STM email...
12:34:08 <Korollary> it
12:34:12 <Korollary> it
12:34:13 <Korollary> err
12:34:18 <Korollary> it's not that big of a deal
12:35:02 <Korollary> if you realize, we also write quite a bit of fromIntegral, etc.
12:35:14 <metaperl> good point
12:35:22 <metaperl> but you can tuck that away in a where clause
12:35:37 <Igloo> Does financial software really use floats, anyway?
12:35:38 <lispy> yeah, but at least we can use the same (+) as long as the argument types are the same
12:36:14 <stepcut> Maybe I can tempt Jane St over to Haskell with my Decimal library
12:36:22 <lispy> also, pattern matching in ocaml is dreadful
12:36:34 <Korollary> Igloo: They may as long as they're fully aware of the issues. I bet they are. Also, floating point hardware is fast.
12:36:54 <lispy> there seemed to be some weirdness where you have to put it in a tuple to pat. match with it
12:37:08 <metaperl> I doubt it . If you read the slides, the presenter (Yaron Minsky) is the second group there to start with OCaml. They ahve a huge OCaml codebase
12:37:15 * stepcut goes to make lunch
12:37:22 <metaperl> stepcut - linspire uses apt?
12:37:26 <metaperl> oh
12:37:37 <metaperl> are you on the westcoast stepcut?
12:38:09 <stepcut> metaperl: San Diego
12:38:21 <metaperl> i see... ok talk with yo ulater
12:38:23 <stepcut> yes, Linspire is debian based
12:38:29 <metaperl> i see
12:42:53 <piggybox> diffClockTimes isn't in module Time anymore?
12:51:49 <dozer> ?type do (x:xs) <- get ; put xs ; return x
12:51:50 <lambdabot> forall (m :: * -> *) a. (MonadState [a] m) => m a
12:59:28 <dozer> @paste
12:59:28 <lambdabot> http://paste.lisp.org/new/haskell
13:00:53 <lisppaste2> dozer pasted "foreach" at http://paste.lisp.org/display/30575
13:01:03 <dozer> so what does this do when it's run on the empty list?
13:01:32 <monochrom> it becomes "fail".
13:02:00 <Baughn> It doesn't become a runtime error?
13:02:46 <monochrom> Depends on which monad, since "fail" is also a class method.  For the State monad, it may be a runtime error afterall.
13:02:49 <mauke> > do (x : xs) <- []; return (x + 1)
13:02:51 <lambdabot>  []
13:03:18 <Baughn> @undo do (x : xs) <- []; return (x + 1)
13:03:18 <lambdabot> [] >>= \ a -> case a of { (x : xs) -> return (x + 1); _ -> fail ""}
13:03:44 <dozer> > do (x : xs) <- [5,2]; return (x + 1)
13:03:45 <lambdabot>  add an instance declaration for (Num [a])
13:03:45 <lambdabot>   In the list element: 2
13:03:45 <lambdabot>   In...
13:04:01 <monochrom> mauke is demonstrating that for the list monad fail is no erroneous.
13:04:08 <Baughn> I didn't know <- worked that way. Okay!
13:04:26 <dozer> > do (x :: Int : xs) <- [5,2]; return (x + 1)
13:04:26 <lambdabot>  Parse error
13:04:38 <dozer> 3rd time lucky...
13:04:55 <monochrom> Yeah you can pattern match during <-.  Pattern matching errors will lead to "fail", which then is at the mercy of the author of the instance declaration.
13:04:58 <mauke> > do (x : xs) <- [[5,2]]; return (x + 1)
13:05:00 <lambdabot>  [6]
13:05:02 <dozer> > do ((x :: Int) : xs) <- [5,2]; return (x + 1)
13:05:02 <lambdabot>  Parse error in pattern
13:05:37 <Baughn> > do (x : xs) <- [[5,2],[99,50]]; return (x + 1)
13:05:38 <Syzygy-> > do (x : xs) <- [[5 :: Int,2 :: Int]]; return (x+1)
13:05:39 <lambdabot>  [6,100]
13:05:40 <lambdabot>  [6]
13:06:17 <Baughn> @type  do (x : xs) <- [[5,2],[99,50]]; x
13:06:19 <lambdabot> forall a. (Num [a]) => [a]
13:06:30 <Baughn> @type  do (x : xs) <- [[5,2],[99,50]]; return x
13:06:31 <lambdabot> forall a. (Num a) => [a]
13:07:00 <dozer> right, these examples are executing in the list monad
13:07:10 <dozer> but my paste is executing in the state monad, where the state value is a list
13:07:25 <Baughn> ..too many monads. I'll go back to reading documentation.
13:07:32 <mauke> > do (x : xs) <- [[],[5,2],[]]; return (x + 1)
13:07:33 <monochrom> It might abort.
13:07:34 <lambdabot>  [6]
13:08:00 <Syzygy-> > do (x:xs) <- []; return (x+1)
13:08:02 <lambdabot>  []
13:08:53 <Oejet> audreyt is a girl?
13:09:20 <Luitzen> yes
13:09:51 <monochrom> > evalState (do { x:xs <- return []; return x }) () :: Int
13:09:52 <lambdabot>  Exception: Pattern match failure in do expression at <irc>:1:16-19
13:09:53 <Botty> is there a good source for syntax specific info - like record update stuff, something that goes into more complicated examples, specifications.  All I can find is either a BNF/CF, proposals, or tutorials that just barely touch the topic with a tiny example.  Other stuff includes where/let..in syntax, precedence rules, etc
13:10:05 <monochrom> That shows what happens to the State monad.
13:10:10 <Oejet> Luitzen: Thanks, I just had a different impression. :-)
13:10:32 <Botty> Oejet - shouldn't matter too much ;)
13:10:38 <mauke> Botty: http://haskell.org/onlinereport/ ?
13:10:39 <lambdabot> Title: The Haskell 98 Language Report
13:11:03 <Botty> I've heard its handy to take on a female persona when pursuing online help though :)
13:11:20 <monochrom> audreyt doesn't pursue online help. :)
13:11:49 <Botty> heh, yeah, wasn't suggesting that, just shows how such things influence people
13:12:09 <Botty> mauke - thanks
13:12:17 <monochrom> Yes there are two common tactics.  (1) be a female.  (2) provoke and challenge, i.e., "why can't Haskell bloody do strong typing?"
13:12:38 <Luitzen> heh
13:12:40 <Botty> that page needs to get a better pagerank...
13:12:53 <Botty> hah. strong typing. haah
13:12:54 <Syzygy-> Whoa? Modal logic is just monads?
13:12:58 <mauke> Botty: heh, just start at haskell.org
13:13:01 <Syzygy-> (and conversely)
13:13:23 <lisppaste2> dozer annotated #30575 with "empty-list safe" at http://paste.lisp.org/display/30575#1
13:13:37 <Botty> mauke - yeah, google has made me go rather link-agnostic
13:13:39 <monochrom> http://haskell.org/onlinereport/ is like RTFM.  Everyone should bookmark it and read it.
13:13:40 <lambdabot> Title: The Haskell 98 Language Report
13:14:42 <Baughn> Botty: I've had people try to convince me that Haskell doesn't do strong typing because, quote, strong typing is less restrictive, unquote.
13:15:04 <Botty> hah, wierd
13:16:04 <Botty> Now I've got four lambda icons on my bookmarks toolbar (Prelude, Hoogle, Lambdabot, Online Report)
13:16:10 <monochrom> "Is X strong typing" is like "Is X high-level".  Does anyone recognize that such adjectives as "strong" and "high" are continuums not booleans?
13:25:34 <metaperl> actually Haskell uses div versus / kinda like how OCaml uses / and /.
13:27:04 <Botje> (/.) = div -- :)
13:27:11 <integral> woo, 0.103 lines compiled per second.  Go GHC!
13:27:24 <metaperl> Botje  - div is for integer division though
13:27:25 <metaperl> @type div
13:27:27 <lambdabot> forall a. (Integral a) => a -> a -> a
13:27:34 <metaperl> @type (/)
13:27:35 <lambdabot> forall a. (Fractional a) => a -> a -> a
13:27:41 <Botje> oh.
13:27:44 <metaperl> :)
13:27:54 <integral> (my 37 line file is taking ~6 minutes to compile)
13:28:38 <monochrom> Also like Pascal.
13:28:52 <lisppaste2> metaperl pasted "mamma jamma error message" at http://paste.lisp.org/display/30578
13:29:06 <monochrom> You're being creative!
13:29:10 <mauke> metaperl: `div`, not div
13:29:23 <metaperl> mauke thanks
13:29:39 <monochrom> x `div` y   AHEM
13:29:53 * metaperl smiles
13:30:04 <mauke> > div 5 2
13:30:06 <lambdabot>  2
13:39:19 <elux> hi
13:39:32 <elux> are there any haskell packages for x86 os x?
13:40:30 <lisppaste2> metaperl annotated #30578 with "How to iterate through a bunch of IO Actions successfully?" at http://paste.lisp.org/display/30578#1
13:40:37 <metaperl> last line of the code is the problem function
13:40:43 <Igloo> You can get GHC for x86 OS X
13:40:48 <metaperl> Elux yes
13:41:18 <metaperl> elux but it has some Darwinports / Fink necessitiies ... it expects libreadline in /opt
13:41:26 <metaperl> audreyt put it together
13:41:31 <Igloo> metaperl: I don't understand the question...is sequence_ what you want?
13:41:43 <metaperl> I dont know what sequence_ is yet
13:41:52 <metaperl> but dcoutts used it earlier, so I guess so
13:41:55 <metaperl> @type sequence_
13:41:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
13:42:10 <corellian> yup
13:42:13 <monochrom> You will soon.  Try (sequence_ doAll)
13:42:32 <elux> ill just install it from fink
13:42:37 <metaperl> doAll does not compile
13:42:48 <metaperl> Elux there is no haskell in fink is there?
13:43:06 <monochrom> what error message?
13:43:21 <metaperl> elux yes I see none
13:44:36 <elux> no
13:44:37 <elux> its there
13:44:48 <elux> http://pdb.finkproject.org/pdb/package.php/ghc
13:44:53 <lambdabot> Title: Fink - Package Database - Package ghc, http://tinyurl.com/ykpw6k
13:44:57 <elux> well .. not for intel
13:45:06 <lisppaste2> metaperl annotated #30578 with "doAll error message" at http://paste.lisp.org/display/30578#2
13:45:08 <elux> maybe ill scrap fink and use darwinports then
13:45:23 <metaperl> elux - no - you just need libreadline
13:45:30 <metaperl> elux I recommend fink over darwinports
13:45:39 <elux> why is that
13:45:39 <metaperl> you just haveto make a symlink to get it to work
13:46:08 <elux> fair enuf
13:46:13 <elux> thanks
13:46:27 <metaperl> elux - right here - http://www.haskell.org/ghc/download_ghc_66.html#macosxintel
13:46:29 <lambdabot> Title: GHC: Download version 6.6, http://tinyurl.com/ybqjsb
13:46:46 <monochrom> It is not an error, metaperl.  sequence_ doAll   you will be happy.
13:47:24 <monochrom> doAll cannot be displayed, that's all.  But who cares about displaying doAll anyway.
13:48:02 <metaperl> i'm making it easy to download 90% of the things you need for HOPE
13:48:15 <metaperl> but is cabal the thing that normally does this?
13:48:33 <corellian> how I use the graphics function withBrush?
13:52:30 <RemiTurk> hi guys
13:53:04 <metaperl> RemiTurk - happy turkey day RemiTurk
13:53:20 <dozer> how would I apply a State or StateT repeatedly untill it fails, and return a list of all the intermediate resulting values?
13:54:18 <dozer> my nose says some sort of recursion is called for
13:54:31 <RemiTurk> metaperl: ahhh, thanksgiving. I had to look that up, but thanks! You too ;)
13:54:32 <metaperl> dozer - try using your brain
13:54:40 <metaperl> :)
13:54:44 <metaperl> i'm just kidding dozer
13:54:56 <metaperl> no harm intended :)
13:55:28 <metaperl> dozer  - you arent mad at me are you?
13:55:37 <dozer> no
13:55:43 <dozer> but it's been a long and frustrating day
13:55:46 <metaperl> oh
13:55:59 <metaperl> sorry about that... it's a holiday here
13:56:08 <metaperl> where are you?
13:56:13 <dozer> UK
13:56:18 <metaperl> go Arsenal!
13:56:26 <dozer> Newcastle
13:56:39 <metaperl> theytook over Michael Owen, no?
13:56:50 <dozer> something like that
13:57:06 <monochrom> If your thing is State s (Maybe a), some combination of unfoldr and runState will work.
13:57:12 <Botty> is there a good way to handle when you have two fairly different patterns/guards, yet the same function content (other than sticking that content in a new function)
13:58:03 <RemiTurk> metaperl: the netherlands. we're slowly getting in Sinterklaas-mood here :)
13:58:15 <metaperl> Sinterklass?
13:58:41 <metaperl> Kluivert is retired isn't he?
13:59:09 <Korollary> that's quite nostalgic
13:59:23 <RemiTurk> metaperl: sinterklaas, the original Santa Claus
13:59:36 <metaperl> oh
13:59:50 <monochrom> runState yourthing :: (Maybe a, s)  so you need a bit of code to turn that into Maybe(a,s) so as to satisfy unfoldr.
14:01:33 <monochrom> If there are two guards, why can't they be or'ed together?
14:02:00 <monochrom> Two patterns is much more difficult.
14:11:31 <Botty> yeah, two patterns.  I'll just leave it, no big deal
14:12:12 <Botty> tokenize ts ('\r':'\n':xs) and tokenize ts (c:xs) | c `elem` "\r\n"
14:12:22 <dozer> > let gen i = case (i > 0) of { True -> Just (i, i-1) ; False -> Nothing } in unfoldr gen 5
14:12:24 <lambdabot>  [5,4,3,2,1]
14:15:11 <dcoutts> Igloo, is it just me or does ghc ticket #1024 seem like a bad idea? :-)
14:15:27 <dcoutts> it's going in the wrong direction
14:15:52 <dcoutts> please note, ghc is a *haskell* compiler, not a C or C++ compiler
14:15:59 <george--> hi, im trying for the first time to use IO stuff and its really confusing me. I'm trying to write a program which counts the number of lines until one line is "END"
14:15:59 <dcoutts> http://hackage.haskell.org/trac/ghc/ticket/1024
14:16:02 <lambdabot> Title: #1024 (Include cc1plus.exe into GHC distribution for Windows) - GHC - Trac, http://tinyurl.com/y85vl6
14:16:15 <Botje> O_O
14:16:28 <dcoutts> george--, no need to use IO for that, except to read the file. For that use readFile
14:16:41 <Botje> george--: YAHT has a nice example of a line-counting script.
14:16:50 <Botje> it can be easily adapted to check for "END" first.
14:16:54 <george--> the purpose for this is for me to learn IO
14:17:21 <psnl> george--: write guis. they have tons on tons of IO
14:17:25 <dcoutts> george--, ok, it should be a good example because it shows how little of the program needs to use IO
14:17:38 <dcoutts> psnl, don't scare the newbies! :-)
14:17:45 <lispy> george--: if you would like to understand how the IO monad works under the hood, recommend reading "Tackling the awkward squad...". Yes, it's accessible to people with just a bit of haskell experience: http://research.microsoft.com/~simonpj/Papers/marktoberdorf/
14:17:47 <lambdabot> Title: Simon Peyton Jones: papers, http://tinyurl.com/jl2rm
14:17:56 <george--> im actually doinh it in hugs. so i can just type the function name then keep putting in input till i use a single line saying END
14:18:22 <Botje> george--: well, at least read the chapter on I/O in YAHT. it's short
14:18:28 <george--> lispy: haha. that exact paper is the suggested reading once im finished doing this task ;)
14:18:38 <lispy> george--: sweet!
14:18:38 <george--> botje: YAHT?
14:19:06 <monochrom> There are many ways to do this.
14:19:23 <monochrom> What have you tried?
14:19:25 <Botje> george--: google for it, it's IMO the best haskell tutorial around
14:19:36 <dcoutts> @where YAHT
14:19:37 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
14:19:46 <monochrom> Programming is not a spectator sport.
14:20:02 <psnl> monochrom: really? how about sysadmining?
14:20:05 <dcoutts> monochrom, really? I thought it was. Read code rather than write it an all that.
14:20:06 <george--> thanks... ill follow these two documents and see if i have a query then
14:20:35 <george--> http://darcs.haskell.org/yaht/yaht.pdf
14:20:39 <george--> sorry ;(
14:21:00 <monochrom> A professional tennis player watches the videos of other players' games too.
14:21:15 <psnl> is that to learn their tactics?
14:21:19 <monochrom> But that is a means, not an end.  The end is he/she will still have to play a game.
14:22:06 <monochrom> Or to laugh at them.
14:22:10 <eviltwin_b> re sysadmin: depends on how you mean spectator sport
14:22:25 <monochrom> I don't know about sysadmining.
14:22:25 <eviltwin_b> but just watching won't help you much.  working *with* an experienced sysadmin can help a lot
14:23:22 <dozer> k, monochrom, I think I see how unfoldr and runstate fit together, with a bit of bodging
14:24:07 <dozer> the bit I'm not sure about is how I do the "success -> Just x   vs   failure -> Nothing"
14:24:30 <lispy> > do { x <- Just 1; return x }
14:24:31 <lambdabot>  Just 1
14:24:32 <monochrom> StateT s Maybe a  would be an even better fit, since runStateT yourthing :: Maybe (s,a)  :)
14:24:36 <lispy> > do { x <- Nothing; return x }
14:24:37 <lambdabot>  Add a type signature
14:24:42 <lispy> > do { x <- Nothing; return x } :: Maybe Int
14:24:44 <lambdabot>  Nothing
14:24:53 <lispy> dozer: is that helpful?
14:27:18 <dozer> monochrom: I almost certainly do want StateT, but I've got that drowning feeling
14:27:43 <zptao> jesus can free your soul
14:27:50 <opqdonut> ok
14:27:55 <opqdonut> so can meth
14:28:00 <zptao> BELIEVE IN THE POWER OF THE LORD
14:28:13 <psnl> does the lord use haskell?
14:28:23 <zptao> only if you really want him to
14:28:27 <dozer> the irony is, I'm writing this code to generate simulations to show to a creationist to demonstrate that he's talking bolox
14:28:45 <psnl> zptao: nah, I want him to suffer
14:29:20 <opqdonut> dozer: how can you demonstrate that?
14:29:49 <opqdonut> as they can just whisk all your evindence away by saying god created thing to look like that
14:30:19 <dozer> it's one of those things where he says "this emergent behavior can't come from this kind of system" and I can simulate the system and show under what conditions the particular interesting stuff emerges
14:30:37 <opqdonut> oh, fine
14:30:39 <dozer> should be a slam-dunk, once I've got this %$& state code behaving
14:30:50 <dozer> classic symetry breaking
14:30:54 <opqdonut> i'm actually coding a genetic algorithm too
14:30:58 <psnl> so? all that does is show that god can change your sim ;-)
14:31:54 <monochrom> unfoldr (\s -> case runState thingie s of (Just x, s') -> Just(x,s'); (Nothing, _) -> Nothing) initialstate
14:32:06 * psnl thinks of god as being like the universe's sysadmin
14:32:30 <lispy> and science is like hacking the root password?
14:32:53 * RemiTurk wouldn't like to be god in that case
14:33:26 <zptao> most interesting metaphor to date
14:33:41 <george--> can someone rewrite this without the >>= please? echo :: IO () \n echo = getChar >>= putChar
14:34:01 <lispy> ?help undo
14:34:01 <lambdabot> undo <expr>
14:34:02 <lambdabot> Translate do notation to Monad operators.
14:34:09 <psnl> input <- getchar \n putChar input
14:34:10 <lispy> ?help do
14:34:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:34:23 <eviltwin_b> @help redo
14:34:23 <lambdabot> redo <expr>
14:34:24 <lambdabot> Translate Monad operators to do notation.
14:34:29 <lispy> ah there we go
14:34:56 <lispy> ?redo \n echo -> getChar >>= putChar
14:34:57 <lambdabot> \ n echo -> do { _ <- getChar; putChar}
14:35:14 <lispy> ?redo getChar >>= putChar
14:35:15 <lambdabot> do { _ <- getChar; putChar}
14:35:16 <eviltwin_b> I think that \n was supposed to be a newline between the type signature and the def
14:35:23 <dozer> the fly in the ointment of unfoldr is that it looses the final value of the chained-through state
14:35:32 <lispy> that's wrong
14:35:35 <opqdonut> yeah it is
14:35:38 <opqdonut> weird
14:35:43 <eviltwin_b> isn't redo known slightly buggy?
14:35:44 <monochrom> You need the final state?
14:36:09 <dozer> ah, just seen the stupidity of my statement
14:36:09 <opqdonut> george--: what about "do { x <- getChar; putChar x }
14:36:13 <lispy> eviltwin_b: but surely it should get the easiest use of (>>=) correct?
14:36:38 <george--> thanks, thin i understand it a bit better now... anyway without 'do' ?
14:36:40 <lispy> Oh
14:36:59 <lispy> ?redo getChar >>= \c -> putChar c
14:37:00 <lambdabot> do { c <- getChar; putChar c}
14:37:00 <opqdonut> george--: no, it's either do or >>=
14:37:16 <lispy> now it gets it, but it cannot understand it without explicit params
14:37:17 <opqdonut> george--: or there might be some monad combinator thing
14:37:28 <monochrom> do or die!
14:38:13 <george--> ok =) im just trying to do it with as little new stuff as possible, it confuses me slightly how with IO stuff there is much more arrows and err.. more confusing symbols everywhere... but i think i am understanding this part now
14:38:17 <lispy> ?. redo undo do { x <- getChar; putChar x }
14:38:18 <lambdabot> do { x <- getChar; putChar x}
14:39:22 <eviltwin_b> IO requires a monad, so you need to use monadic operations like >>= or the do-notation which hides it
14:39:23 <opqdonut> george--: you see, there has to be something special as getChar returns IO Char but putChar takes Char
14:40:06 <Botje> hmm
14:40:12 <Botje> arrows look easier than monads to me.
14:40:19 <Botje> (easier to learn/grok, that is)
14:40:27 <zptao> haskell seems like a language with no end to confusion
14:40:29 <opqdonut> yeah they're a bit nicer
14:41:19 <monochrom> That is not my feeling about Haskell.
14:41:44 <monochrom> My first encounter with Haskell was "finally something that makes sense"
14:41:47 <opqdonut> couldn't IO be expressed with arrows so that IO Char would be (Char,IOState)
14:41:51 <zptao> like, say, i wanted to generate a list such as ["1", "11", "111", ...] and so forth?
14:42:02 <lispy> well, everything which you can learn requires growing mentally...which means it has confusing parts, frustrating parts and so on
14:42:08 <eviltwin_b> haskell takes some getting used to.  so does any other language, really, but most people don't start out with functional-think and monad-think
14:42:15 <opqdonut> mhmm
14:42:23 <opqdonut> but i'm starting to get the grip on monads
14:42:29 <opqdonut> they're a really neat system
14:42:32 <monochrom> Monads were a steep learning curve to me too but it was always "this is hard but elegant" rather than confusing.
14:42:49 <eviltwin_b> people who don't even have procedural-programming-think are deeply confused by procedural programming languages (see almost any intro programming course for evidence)
14:43:00 <opqdonut> true, that
14:43:01 <george--> i just dont understand the 'getLine' function... looking at the code for it I dont see how it works. if a char is a new line symbol it returns an empty list otherwise it calls getLine again?
14:43:28 <fons> does anyone know why ghc gives execution permissions to the obtained file when using -o even if -no-hs-main is provided ?
14:44:04 <opqdonut> george--: yeah, but the next getLine is appended to the just read letter
14:44:17 <monochrom> If you think c, c++, perl, java to be intuitive, you are bound to find haskell confusing.  But when that happens, is it intuition or is it brainwashing?
14:44:20 <opqdonut> george--: so in the end we've appended all the letters of the line together
14:44:44 <opqdonut> george--: and returning [] when endl is encountered cuts the recursion and makes the whole pasted-together string return
14:44:51 <george--> and then what happens to the remainder of the input
14:44:52 <eviltwin_b> "intuitive" in this case isn't really intuitive, it's just what you're used to
14:44:55 <george--> say if its a 10 line input?
14:45:04 <opqdonut> george--: it just hasn't been read yet
14:45:19 <eviltwin_b> (cue "the only intuitive user interface is the nipple", etc. :)
14:45:29 <monochrom> Is it intuition or is it brainwashing, if your background disables you from seeing alternatives?
14:46:13 <george--> ok. but say i have some variable called 'document' if i read one line... how do i now read the next?
14:46:33 <george--> if i run getline on document again then it just gets the first line again?
14:46:52 <monochrom> do { x<-getLine; y<-getLine; ... }  x receives the first line, y receives the second line.
14:46:54 <eviltwin_b> monochrom: neither, really; none of it is truly intuitive, but brainwashing is far more severe than ordinary acculturation
14:46:56 <zptao> how would i generate a list of repetitive strings (like ["1", "11", "111", ...]) to n places?
14:47:10 <monochrom> This is all stdin so there is no "variable called document".
14:47:15 <lispy> > map concat (iterate ("1":) ["1"])
14:47:27 <lambdabot>  ["1","11","111","1111","11111","111111","1111111","11111111","111111111","11...
14:47:36 <opqdonut> > unfold "1" (:"1")
14:47:37 <lambdabot>  Not in scope: `unfold'
14:47:45 <opqdonut> > unfoldl "1" (:"1")
14:47:46 <lambdabot>  Not in scope: `unfoldl'
14:47:49 <opqdonut> borg
14:47:54 <fik> :)
14:48:03 <george--> monochrom: i am suggesting i have defined a variable called document... ie. > document = "a sjd jasd nasd\n djs idf sn\n etc etc"
14:48:08 <opqdonut> > unfoldr "1" (:"1")
14:48:09 <lambdabot>  Couldn't match `b -> Maybe (a, b)' against `[Char]'
14:48:15 <opqdonut> bah, i give up
14:48:25 <monochrom> That is a string.  You cannot apply getLine to it.
14:48:27 <RemiTurk> > unfoldr (Just . ('1':)) ""
14:48:28 <lambdabot>  Couldn't match `(a, [Char])' against `[Char]'
14:48:36 <lispy> > concatMap . iterate ("1":) ["1"]
14:48:38 <lambdabot>    Expecting a function type, but found `[a]'
14:48:38 <lambdabot>    Expected type: a1 -> a ...
14:48:39 <monochrom> People, there is such a thing as /msg lambdabot
14:48:42 <george--> even if it has \n's in for new lines?
14:48:44 <lispy> > concatMap (iterate ("1":) ["1"])
14:48:45 <lambdabot>    Expecting a function type, but found `[a]'
14:48:46 <lambdabot>    Expected type: a -> [b]...
14:48:55 <eviltwin_b> getLine is for actual I/O
14:48:56 <zptao> you can apply iterate to things other than integers? eh?
14:48:58 <lispy> monochrom: yeah, i worked out how to do it there, but then i wanted to showe it off :)
14:49:08 <lispy> and my second attempt doesn't seem to work :(
14:49:12 <RemiTurk> zptao: you can apply iterate to lists of any type
14:49:12 <eviltwin_b> hint: unlines
14:49:20 <monochrom> Yes lispy, I'm referring to other people, all these newbies.
14:49:24 <opqdonut> > iterate (:"1") "1"
14:49:31 <lambdabot>  Couldn't match `Char' against `[Char]'
14:49:53 <lispy> opqdonut: two things, you need to flip the first part and put the second argument in a []
14:50:02 <RemiTurk> > inits (repeat '1')
14:50:03 <pkhuong> > scanl (flip (:)) [] (replicate 10 '1') -- ?
14:50:03 <lambdabot>  ["","1","11","111","1111","11111","111111","1111111","11111111","111111111",...
14:50:04 <lambdabot>  ["","1","11","111","1111","11111","111111","1111111","11111111","111111111",...
14:50:10 <lispy> RemiTurk: nice!
14:50:14 <pkhuong> RemiTurk++
14:50:25 <lispy> but you might want to take the tail of that list
14:50:33 <lispy> unless the first element there is fine
14:50:36 <opqdonut> > iterate ("1":) ["1"]
14:50:37 <RemiTurk> lispy: if I remember correctly it's space behaviour isn't too nice
14:50:38 <lambdabot>  [["1"],["1","1"],["1","1","1"],["1","1","1","1"],["1","1","1","1","1"],["1",...
14:50:42 <opqdonut> > iterate ("1":) "1"
14:50:43 <lambdabot>  Couldn't match `[Char]' against `Char'
14:50:49 <opqdonut> > iterate ('1':) "1"
14:50:51 <lambdabot>  ["1","11","111","1111","11111","111111","1111111","11111111","111111111","11...
14:50:53 <opqdonut> there!
14:51:11 <lispy> opqdonut: nice, i thought about doing that
14:51:12 <zptao> whats the purpose of the colon?
14:51:26 <psnl> dcoutts: do you have any papers on gtk2hs?
14:51:28 <lispy> zptao: "cons" takes one element and puts it on the frist of a list
14:51:35 <lispy> ?type (:)
14:51:36 <lambdabot> forall a. a -> [a] -> [a]
14:51:43 <opqdonut> zptao: 1:[2,3] == [1,2,3]
14:51:44 <george--> zptao adds an item to a list
14:51:48 <dcoutts> psnl, not formal academic ones, no.
14:52:05 <zptao> i don't know what that gibber gabber means lispy --> a -> [b] -> c -> .b is meaningless to me :(
14:52:28 <lispy> zptao: then learn than before studying more haskell
14:52:31 <eviltwin_b> ?where yaht
14:52:31 <dcoutts> psnl, though there's a presentation we gave at Nottingham to a bunch of academics
14:52:32 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
14:52:32 <opqdonut> zptao: you should read some haskell tutorial
14:52:36 <dozer> @paste
14:52:36 <lambdabot> http://paste.lisp.org/new/haskell
14:52:38 <psnl> dcoutts: thanks
14:52:46 <dcoutts> psnl, want to help write a tutorial ? :-)
14:52:51 <psnl> dcoutts: I'm writing up my lit survey
14:52:53 <monochrom> a->b stands for functions from a to b.
14:53:03 <dcoutts> psnl, oh? what are you writing ?
14:53:04 <opqdonut> where a and b are types
14:53:07 <psnl> dcoutts: the intro one I started with is good
14:53:11 <monochrom> x->y->z is to be read as x->(y->z)
14:53:13 <psnl> dcoutts: gui for hat
14:53:25 <dcoutts> psnl, ah right, cool.
14:53:36 <lisppaste2> dozer pasted "untilFail with final state" at http://paste.lisp.org/display/30583
14:53:54 <dcoutts> psnl, how did you find using gtk2hs then ? What should we be concentrating on?
14:54:01 <monochrom> If you want to write a function that takes two parameters, there are thus two ways.  make it x->y->z, or make it (x,y)->z.
14:54:04 <dozer> that looks more like what I want
14:54:11 <monochrom> Haskell chose the former; ML chose the latter.
14:54:15 <psnl> dcoutts: I'm loaded with things to do, so I can't really help gtk2hs
14:54:20 <dcoutts> psnl, the focus at the moment is on simplifying the api
14:54:28 <psnl> dcoutts: thats good
14:54:43 <dcoutts> psnl, sure, sure. so's everyone :-) any feedback is great though.
14:54:51 * psnl thinks
14:55:00 <lispy> zptao: take a function like (:) :: a -> [a] -> [a]
14:55:06 <psnl> can it be less verbose?
14:55:13 <lispy> zptao: when you give it an 'a', it really gives you a new function
14:55:28 <lispy> :t (1:)
14:55:32 <lispy> ?type (1:)
14:55:34 <lambdabot> forall a. (Num a) => [a] -> [a]
14:55:46 <dcoutts> psnl, the code, aye. One thing that'd help there is more use of properties and less get/set functions.
14:55:58 <lispy> so really, (:) :: a -> ([a] -> [a])
14:56:04 <lispy> (just to confuse you a bit :)
14:56:16 <dcoutts> psnl, and being able to set properties at construction time.
14:56:20 <psnl> dcoutts: I'm also writing a lot with a GUI thread and a backend thread {,s}, which seems to work. is that what you have in mind
14:56:31 <RemiTurk> monochrom: do you know why exactly Haskell chose the former? Could that be because of laziness?
14:56:42 <opqdonut> RemiTurk: partial application
14:56:52 <psnl> dcoutts: the glade stuff could be better, but all round its very good as a gui toolkit
14:57:00 <monochrom> I don't know.
14:57:04 <dcoutts> psnl, using threads is great. Though ndm found that we do have some issue on win32 with using threads.
14:57:16 <dcoutts> psnl, anything specifically about glade?
14:57:25 <RemiTurk> opqdonut: I know, but then perhaps I should rephrase my question as "why didn't ML choose the former too?"
14:57:35 <opqdonut> RemiTurk: that i don't know
14:57:44 <opqdonut> implementation efficiency?
14:57:49 <lispy> RemiTurk: they like ugly syntax? oh wait, that's ocaml ;)
14:57:57 <RemiTurk> lispy: haha :D
14:58:00 <Blackfoot> is there a left shift operator?
14:58:10 <lispy> ?hoogle shiftL
14:58:10 <lambdabot> Data.Bits.shiftL :: Bits a => a -> Int -> a
14:58:11 <lambdabot> GHC.Exts.shiftL# :: Word# -> Int# -> Word#
14:58:11 <lambdabot> GHC.Exts.iShiftL# :: Int# -> Int# -> Int#
14:58:22 <lispy> ?instances Bits
14:58:23 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
14:58:27 <dcoutts> @hoogle shiftLeft
14:58:28 <lambdabot> No matches found
14:58:31 <lispy> ?instances Data.Bits
14:58:32 <lambdabot> Not a class! Perhaps you need to import the  module that defines it? Try @help instances-importing.
14:58:39 <dcoutts> @docs Data.Bits
14:58:39 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
14:58:43 <Blackfoot> so import Data.Bits ok
14:58:51 <Blackfoot> thank you!
14:58:53 <lispy> > shiftL 1 3
14:58:54 <lambdabot>  Add a type signature
14:58:56 <monochrom> Data.Bits.Bits ?
14:58:59 <lispy> > shiftL (1::Int) 3
14:59:01 <lambdabot>  8
14:59:03 <psnl> dcoutts: its just you go though a lot of wndMain <- xmlGetWidget dialogXml castToWindow "wndMain" style stuff.
14:59:17 <lispy> actually, i prefer it this way: 1 `shiftL` 2
14:59:27 * psnl would try to automagicly generate it somehow, but doesn't quite know how
14:59:41 <dcoutts> psnl, yeah, that's rather verbose, though I'm not quite sure how to simplify it.
15:00:08 <RemiTurk> opqdonut: I can imagine it having something to do with laziness: with tuples, it might be easier to remember when what is computed in a strict language (I'm thinking about things like \x -> let x' = expensive in \y -> ...)
15:00:30 <dcoutts> psnl, perhaps xmlNew should return a pure function from widget names to widgets
15:00:49 <psnl> dcoutts: I'ld be tempted to generate it all from the XML
15:01:08 <dcoutts> psnl, hmm, generating code from the xml is not considered best style these days.
15:01:14 <psnl> cool
15:01:21 <monochrom> Really?!
15:01:30 <psnl> dcoutts: ok, cool
15:01:39 * psnl missed that bit of the style guide
15:01:46 <dcoutts> doing the loading at runtime is the way people seem to be going
15:01:56 <dcoutts> glade3 drops the code gen features completely
15:01:58 <monochrom> OH!  Right, I do that.
15:02:09 <psnl> dcoutts: ah right
15:02:18 <dcoutts> psnl, though we could generate the bit that loads the named things
15:02:35 * monochrom notes to self: there is a difference between generating code and generating widgets.
15:03:07 <psnl> dcoutts: oh, I mean take lines like <widget class="GtkWindow" id="wndMain"> and get lines like xmlGetWidget dialogXml castToWindow "wndMain" in a really big file
15:03:20 <dcoutts> I quite like the style where you can omit the castToFoo and it just casts it automagically to the type at which you use it (and throws an exception if it isn't of the right type).
15:03:36 <psnl> so you still read in the xml at runtime, but the coder doesn't have to type it all
15:03:40 <dcoutts> right
15:03:50 <dcoutts> that would be ok
15:04:00 * psnl feels a really bad bit of python coming on
15:04:04 <dcoutts> heh
15:04:09 <dcoutts> no! use haxml
15:04:21 <monochrom> use hxt
15:04:54 <dcoutts> xmlLoad :: Widget w => FilePath -> IO (String -> w)
15:05:06 <lispy> haxml + TH could even do it at compile time, then the code would be transparent! ;)
15:05:42 <monochrom> Oh God...
15:05:45 <psnl> Dear $supervisor, sorry for lack of draft, I got side tracked into implementing random stuff and arguing xml toolkits, love Pete
15:05:54 <dcoutts> heh
15:05:57 <lispy> heh
15:06:06 <dcoutts> thanks for the suggestions psnl, you can go now :-)
15:06:19 <lispy> monochrom: well, it would have one nice side effect...that code generated by the code generator wouldn't get edited by humans
15:06:21 <psnl> heh
15:06:57 <psnl> dcoutts: I'm wondering what the idea behind the function you had was
15:06:57 <lispy> which can happen when you work on some teams...someone doesn't realize that a module is autogenerated, modifies it and then their changes disappear
15:07:15 <dcoutts> psnl, oh that xmlLoad I pasted?
15:07:30 <psnl> yeah
15:08:06 <dcoutts> psnl, well it loads the glade file, instantiates all the objects and gives you a pure function that gets named widgets from the collection of widgets you just instantiated
15:08:21 <dcoutts> psnl, and it's type safe by doing a dynamic type check
15:08:44 <psnl> woah
15:08:57 <dcoutts> psnl, so depending on the type at which you use the result it tries a dynamic cast to that type and if it's ok you get it back
15:09:13 <dcoutts> otherwise it throws an error, similarly if the named widget doesn't exist.
15:09:33 <dcoutts> at the moment you specify the type you want by passing in a casting function
15:10:00 <dcoutts> but you could do it by using the result at a particular type
15:10:52 <monochrom> Fancy.
15:10:56 <dcoutts> getWidget <- xmlLoad "foo.glade"
15:11:13 <dcoutts> window1 :: Window <- getWidget "window1"
15:11:53 <dcoutts> there's a danger of it being ambiguous though
15:12:00 <dcoutts> like show . read
15:12:12 <dozer> ah, I think I'm starting to get this state stuff - written my first propper state combinator
15:13:25 <lisppaste2> dozer pasted "combinators" at http://paste.lisp.org/display/30584
15:15:50 <dancor> how do i execute an external program
15:16:32 <eviltwin_b> @hoogle system
15:16:33 <lambdabot> System.system :: String -> IO ExitCode
15:16:33 <lambdabot> System :: module
15:16:33 <lambdabot> System.Win32.Info.SystemColor :: type SystemColor
15:16:40 <RemiTurk> @hoogle runProcess
15:16:41 <lambdabot> System.Process.runProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> Maybe Handle -> Maybe Handle -> Maybe Handle -> IO ProcessHandle
15:17:04 <RemiTurk> dancor: so you'll want to look at the modules System and System.Process
15:17:21 <dancor> ok
15:19:26 <earthy> yaay!
15:19:33 <earthy> both questions answered, within a day
15:19:40 * earthy hugs Haskell and its maintainers
15:21:32 <earthy> evenin mrchebas
15:21:45 <earthy> did the battery get to you safely?
15:21:52 <mrchebas> earthy! What are you doing still up? ;)
15:21:59 <mrchebas> yes, thank you a lot!
15:22:01 <earthy> coding haskell. :)
15:22:05 <mrchebas> remind me to pay you a coffee
15:22:13 <mrchebas> i also fixed my imovie problem
15:22:22 <mrchebas> indeed, copying the bundle was more than enough
15:22:23 <earthy> actually, just finishing up the last strands of thought for the day
15:22:35 <mrchebas> dazzle hacking?
15:22:39 * earthy nods
15:22:53 <earthy> implemented (part of) a new feature
15:23:11 <earthy> ran into my first use of unsafePerformIO.
15:23:14 * earthy feels dirty now
15:23:25 <mrchebas> it always feels like that the first time ;)
15:23:35 <earthy> took a beer to convince me I was right ;)
15:23:51 <mrchebas> sometimes it is worth it
15:24:04 <mrchebas> remember this crazy list of IO actions that I was coding some time ago?
15:24:18 <mrchebas> I just threw away all the complexity and embraced unsafePerformIO
15:24:24 <earthy> in this case the code is just calling a C library that does some calculations in-memory
15:24:35 * earthy grins
15:24:50 <earthy> yeah, that'd fix that problem a treat ;)
15:25:01 <mrchebas> that seems to be a good use
15:25:06 * earthy nods
15:25:11 <mrchebas> what library are you using?
15:25:23 <earthy> dazzle uses the Smile library for bayesian networks
15:25:40 <earthy> which is in C++ and is closed source... :|
15:25:45 <mrchebas> oh
15:25:57 * mrchebas shivers
15:26:16 <earthy> any results on testing with the new counting stuff for ghc, btw?
15:26:24 <mrchebas> do you have to write C wrappers to use it?
15:26:33 <mrchebas> I have some results
15:26:45 <mrchebas> But not with the full blown semitagging
15:26:50 <mrchebas> something more simple minded
15:27:09 <mrchebas> and it was surprising to see 20% improvement in the running time for some programs
15:27:20 <earthy> yeah, there's a C wrapper for smile in the dazzle sources
15:27:25 <mrchebas> the counting stuff helped to pinpoint at why things were going faster
15:27:39 <mrchebas> the faster programs caused less branch mispredictions
15:27:41 <dancor> is there a built-in like (rep (+ 1) 4 100) = (104)
15:28:07 <dancor> more clearly perhaps (rep (+ 1) 4) = (+ 4)
15:28:33 <mrchebas> dancor: what is rep doing?
15:28:50 <dancor> (rep f 3 x) = (f (f (f x)))
15:28:52 <earthy> dancor: foldr ($) 100 (replicate 4 (+ 1))
15:28:55 <dancor> ok
15:29:12 <earthy> > foldr ($) 100 (replicate 4 (+ 1))
15:29:14 <lambdabot>  104
15:29:33 <RemiTurk> good night everyone
15:29:35 <mrchebas> > take 4 $ iterate (+1) 1
15:29:37 <lambdabot>  [1,2,3,4]
15:29:40 <mrchebas> oops
15:29:50 <mrchebas> iterate (+1) 1 !! 4
15:29:54 <mrchebas> again oops
15:30:03 <mrchebas> > iterate (+1) 1 !! 4
15:30:04 <dancor> reoops
15:30:05 <lambdabot>  5
15:30:15 <dibblego> hello
15:30:46 <earthy> timtowtdi! :)
15:31:05 <earthy> the iterate is more efficient though ;)
15:31:17 <eviltwin_b> you knew there was a reason pugs is written in haskell, right? :>
15:31:24 <mrchebas> it is also easier to read IMO
15:31:28 <earthy> (even if it's prone to off by ones)
15:31:50 <mrchebas> don't know about efficiency though
15:31:53 * earthy grins at eviltwin
15:32:01 <earthy> mrchebas: fewer thunks created
15:32:05 <earthy> I'd guess
15:32:41 <dancor> wouldn't a recursive def of rep be the easiest to read
15:33:02 <mrchebas> he, don't ask me! I am working on the compiler, I am not the compiler! ;)
15:33:11 * earthy laughs
15:33:27 <dancor> recursion for life
15:34:21 <Igloo> Does anyone know what bulat means by "docracy"?
15:34:48 <Pseudonym> Surely it's a government run by pieces of paper.
15:34:49 <earthy> dancor: something like
15:34:51 <earthy> > let rep f 0 = id; rep f n = f . rep f (n - 1) in rep (+ 1) 4 1
15:34:53 <earthy> maybe?
15:34:53 <lambdabot>  5
15:35:06 <bringert> a week is enough time to wait for reactions to a proposal, right?
15:35:19 <monochrom> If you are operationally minded, rolling your own recursion/loop is "easier" to read.
15:35:24 <earthy> bringert: depends on the proposal
15:35:37 <monochrom> If you are declaratively minded, using a canned looper is easier to read.
15:36:01 <bringert> earthy: fairly obscure, it's changes to the time package, and I got no response at all
15:36:04 <earthy> anyway, high time for me to hit the sack
15:36:10 <monochrom> It comes down to whether you read code for mental execution or for intention.
15:36:16 <dons> morning
15:36:20 <mrchebas> Igloo: I guess that it means not waiting for consensus or approval, "Just do it"
15:36:21 <earthy> bringert: does a 'yaay! parsing!' vote count?
15:36:30 <bringert> earthy: yes
15:36:37 <monochrom> If you ask me, I leave execution to the computer.
15:36:40 <earthy> how do I submit it? :)
15:36:50 <Igloo> Aha, that could be it. Thanks!
15:37:18 * Igloo finds there's a whole thread on this on the libraries list. Bah.
15:37:29 <earthy> in fact, I've not gotten round to the hacking I meant to do with Data.Time
15:37:33 <bringert> earthy: reply to libraries list thread on my proposal
15:37:35 <mrchebas> heh, I just erased 800 unread messages from that list
15:37:40 <bringert> well, the thread is just me
15:37:41 <mrchebas> I guess I missed it then :)
15:37:50 <monochrom> For example Microsoft used to do docracy to HTML and CSS standards.
15:37:51 <earthy> I'm not subscribed to libraries, for good reasons. :)
15:38:02 <earthy> but, I will
15:38:11 <mrchebas> for bad reasons?
15:38:15 * mrchebas grins
15:38:17 <Igloo> bringert: I mean the base libraries thread, which I don't think is you
15:38:48 <bringert> Igloo: yeah, I was replying to my own comment to earthy
15:38:54 <Igloo> Ah, OK  :-)
15:39:53 <dibblego> does GHC produce Java source?
15:40:05 <Igloo> No
15:40:11 <bringert> earthy: http://article.gmane.org/gmane.comp.lang.haskell.libraries/5706
15:40:14 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/ye3njc
15:40:17 <Igloo> I think there are a number of incomplete or bitrotted efforts to make it do so
15:40:27 <dibblego> I just read a mailing thread that says it does with -J, but I can't seem to do it
15:40:30 <Igloo> If you mean JVM bytecode, anyway
15:40:46 <dibblego> no, Java source according to this thread
15:40:48 * psnl returns, having fixed the internet connection
15:40:48 <Igloo> Right, that's almost certainly bitrotted
15:40:51 <bringert> good night
15:40:52 <dibblego> but bytecode and source sre the same thing
15:41:01 <monochrom> I have seen a proof-of-concept translator (not GHC) from Haskell to Java, source-to-source.
15:41:43 <Igloo> I would say Java bytecode is the stuff with all the braces in, distinct from the bytecode
15:41:47 <Igloo> Gah
15:41:53 <Igloo> I would say Java /source/ is the stuff with all the braces in, distinct from the bytecode
15:41:54 <monochrom> haha
15:41:57 <dibblego> sure, but there is a 1:1 is what I mean
15:42:28 <dibblego> how would you handle the fact that the Sun VM has no tail call elim?
15:42:32 <dibblego> compile to a loop?
15:42:52 <dibblego> how would you translate functions like readFile?
15:42:53 <dons> dibblego: yeah, there's a bunch of tricks for diong this.
15:43:01 <dons> trampolines and so on
15:43:10 <dibblego> oh right I was reading about those
15:43:21 <dibblego> wtf is a trampoline exactly? I could find no clear definition
15:43:58 <Botje> dibblego: setup for a function call, i believe
15:44:00 <pkhuong> dibblego: instead of calling a function directly, you return something that tells the trampoline loop to call that function (w/ the args, etc)
15:44:13 <eviltwin_b> writing a think to the stack or scratch space to do setup for a function call in a different context
15:44:25 <eviltwin_b> er, thunk
15:45:33 <dibblego> can you write trampolines in haskell?
15:45:36 <mrchebas> the same trick has to be used in .NET too?
15:45:36 <dons> eviltwin_b: I prefer your use of 'think' there :) 1 think, 2 thunks
15:45:53 <dibblego> mrchebas, I believe .NET has tail call elim (I was reading about it on the F# page)
15:46:00 <dons> .Net has proper tail calls
15:46:03 <cjay> mrchebas: .NET has a tail instruction
15:46:07 <dibblego> there is an instruction in its VM
15:46:11 <mrchebas> aha
15:46:14 <mrchebas> thanks
15:46:28 <mrchebas> dibblego: i was indeed wondering about F#
15:47:03 <arjanb> i heard the tail call instruction is rarely used because workarounds are faster..
15:47:15 <dibblego> how do you return something that tells the trampoline loop to call a function? do you just return a function?
15:53:10 <earthy> there. time for bed.
15:56:19 <dancor> @time earthy
15:56:21 <lambdabot> Local time for earthy is Fri Nov 24 00:52:46 2006
15:56:41 <psnl> earthy: France?
15:56:58 <dancor> Earth
15:58:14 <mrchebas> g'night
16:02:12 <dibblego> > let fact' 1 = 1; fact' n | n > 0 = n * fact' (n - 1) in fact' 7
16:02:14 <lambdabot>  5040
16:05:17 <dibblego> let fact 0 acc = acc; fact n acc = fact (n - 1) n * acc -- how is that converted to a trampoline?
16:21:56 <dons> reddit for today: http://programming.reddit.com/info/s8cx/details
16:21:59 <lambdabot> Title: LogicT: backtracking monad transformer with fair operations and pruning (reddit. ..., http://tinyurl.com/ygmyu2
16:22:39 <Pseudonym> Woo.
16:22:52 * Pseudonym is cited in that paper
16:23:32 <dons> hey cool
16:24:26 <Pseudonym> Trice, in fact.
16:24:37 <Pseudonym> Twioce
16:24:39 <Pseudonym> Twice
16:24:46 * Pseudonym tipes korektlie
16:25:30 <dcoutts> dons, so how many reddit points do you control do you think? :-)
16:25:52 <dcoutts> I mean how many points get automatically added to things you post when you mention them on #haskell ?
16:27:12 <dons> between 2-5
16:27:28 <dons> enough to stop the articles from being killed by rubyists ;)
16:27:31 <dcoutts> heh
16:27:48 <michelgbr> Hello
16:27:58 <michelgbr> anyone can help me on a simple question?
16:27:58 <dons> i.e. 3 pts on the LogicT article atm, 1 from me, 2 from here I suspect
16:28:03 <dons> michelgbr: yes.
16:28:08 <michelgbr> hello dons
16:28:10 <dcoutts> dons, aye, 1 from me
16:28:16 <michelgbr> i'm leaning haskell
16:28:24 <michelgbr> and I wrote this function:
16:28:42 <michelgbr> pegaNumero = do
16:28:42 <michelgbr>    putStrLn "Digite um inteiro positivo, ou 0 para parar."
16:28:42 <michelgbr>    tmp <- getLine
16:28:42 <michelgbr>    let numero = read tmp
16:28:42 <michelgbr>    if (numero == 0)
16:28:43 <michelgbr>       then return []
16:28:45 <michelgbr>       else do
16:28:47 <michelgbr>          total <- pegaNumero
16:28:49 <michelgbr>          return(numero : total)
16:28:59 <dcoutts> @paste
16:28:59 <lambdabot> http://paste.lisp.org/new/haskell
16:29:01 <michelgbr> it's only read n numbers from the console, and return a list
16:29:11 <dcoutts> michelgbr, in future use this site ^^ to paste bigger chunks of code
16:29:18 <michelgbr> okz,,,sorry :)
16:29:28 <dcoutts> s'ok, just next time :-)
16:29:32 <michelgbr> okz
16:29:37 <michelgbr> so, the problem is
16:29:49 <michelgbr> the type of this function is IO [Integer]
16:30:01 <dcoutts> right
16:30:09 <michelgbr> and I need to pass this list to other function:
16:30:21 <michelgbr> soma a = foldr (+) 0 a
16:30:33 <michelgbr> but this function receive [Integer]
16:30:44 <dcoutts> michelgbr, use do notation
16:30:44 <michelgbr> How do I make the "cast" ?
16:30:45 <monochrom> pegaNumero >>= liftM soma
16:30:46 <eviltwin_b> you have to do it in the IO monad
16:31:00 <monochrom> pegaNumero >>= liftM soma   :: IO Integer
16:31:11 <dcoutts> michelgbr, do { n <- pegaNumero; return (soma a) }
16:31:28 <michelgbr> uou, this is strange to me
16:31:33 <michelgbr> what this means?
16:31:46 <dcoutts> michelgbr, the point is that once inside IO, you can't get out.
16:32:06 <monochrom> In dcoutts code, "a" should be "n"
16:32:16 <dcoutts> oh yes, oops
16:32:26 <michelgbr> so I need to make a third function
16:32:27 <dcoutts> do { ns <- pegaNumero; return (soma ns) }
16:32:31 <michelgbr> to "translate" the type?
16:32:34 <monochrom> Note: do { n <- pegaNumero; return (soma a) } :: IO Integer
16:33:03 <monochrom> (Darn my copy and paste and inherit the typo)
16:33:23 <michelgbr> I see
16:33:28 <michelgbr> let me try
16:34:03 <markha> Is HiDE usable?  I see the wiki page, but not much on the progess of development
16:34:03 <monochrom> Note also that soma = sum  already in the Prelude :)
16:34:23 <michelgbr> really? :)
16:34:51 <monochrom> Would it be nice if there were a Prelude in Latin?
16:35:15 <monochrom> "import International.Prelude.Latin ..."
16:35:57 <monochrom> "import International.Prelude.Chinese ...  main = print ( [1,2,3])"   hahaha
16:36:12 <monochrom> Err yuck forgot to translate print to Chinese!
16:36:21 <cjay> :)
16:39:44 <syntaxfree> I want to write a reverse-literate programming parser.
16:39:55 <syntaxfree> Usual literate programming reverts the role of comments and code.
16:40:27 <syntaxfree> I want to keep comments as such, so I can run files against compilers that don't support literate programming (say, GNU R), and yet auto-produce  LaTeX code from the .R files.
16:40:52 <syntaxfree> do you recommend using Happy, Parsec or just go do string processing by myself?
16:41:11 <dons> markha: its not usable yet
16:41:18 <psnl> processing by yourself
16:41:50 <dons> I'd just roll my own grammar (it'd be dead simple), then you know you can get a faster parser and lexer from alex/happy
16:42:01 <dons> but you could do it yourself in 10 mins anyway ;)
16:42:39 <syntaxfree> I did write a quick-and-dirty one to get this job done, but it hits a few walls, and I'm thinking of shopping around for pre-made, better than my nave one, string processing fu
16:43:03 <pkhuong> syntaxfree: look at pbook ( http://fresh.homeunix.net/~luke/ )
16:43:06 <lambdabot> Title: Luke Gorrie's 'puter page
16:43:18 <syntaxfree> besides, it basically hardcodes the GNU R style of comments, and I'd like it to be able to parse a small configuration file defining the comment style of a language.
16:44:19 <syntaxfree> pkhuong: that's somewhat beyond what I need, I guess :)
16:44:29 <syntaxfree> somewhat beyond and somewhat less, too.
16:45:23 <syntaxfree> I guess what I really want is a parser generator for a simple language description language I want to roll out.
16:49:38 <dons> try parsec then?
16:50:07 <syntaxfree> I'm reading the Parsec documentation to see if it fits me.
16:50:25 <syntaxfree> Apparently it has an entire module for common programming language structures like comments and blocks.
16:51:13 <dons> dcoutts: does your api diff program work on arbitrary haskell programs?
16:51:39 <dcoutts> dons, yes it should. It just compares the output of ghc --show-iface
16:51:56 <dcoutts> with a script to do that for each .hi file in two versions of a package
16:51:57 <dons> cool. should use it to check fps apis
16:52:20 <dcoutts> it would be more robust if it used the ghci api rather than munging the --show-iface output
16:53:20 <dibblego> can all general recursive functions be converted to tail recursive functions with the addition on an accumulator - that is the return value
16:54:06 <dcoutts> to do it efficiently, the operator has to be associative
16:54:25 <dcoutts> dibblego, eg the classic example of summing relies on + being associative
16:54:42 <dibblego> ah right, of course
16:56:21 <dcoutts> f [] = 0; f (x:xs) = x `op` sum xs  ~~> f a [] = a; f a (x:xs) = f (a `op` x) xs
16:56:51 <dcoutts> it's basically turning a foldr into a foldl
16:57:18 <dcoutts> which makes it really clear that it's only true for associative ops
16:57:59 <dibblego> thanks
17:04:43 <dons> ?yow
17:04:44 <lambdabot> Clear the laundromat!!  This whirl-o-matic just had a nuclear meltdown!!
17:05:01 <thebug> :O
17:06:07 <syntaxfree> Parsec is creepy.
17:06:21 <syntaxfree> It's doing what I want, but I don't have the slightest idea of how it does it.
17:06:27 <syntaxfree> Feels like black magic.
17:07:13 <dons> heh
17:07:45 <syntaxfree> I think I never really saw the monadic structure working outside IO and State.
17:07:54 <syntaxfree> (And silly examples like Either and Maybe)
17:09:02 <dons> metaperl: around? i'm interested in your recent blog post, and what issues create the barrier to entry? http://sequence.complete.org/node/228
17:09:31 <dons> (since haskell is taught as a beginners language, we know it can be taught to junior programmers. so i wonder what troubles you're having?)
17:10:00 <monochrom> Parsec is a state monad, in that the string to be parsed is the state.  It is also an Either monad for success and failure, of course.
17:10:42 <dozer> dons: I've found the basic syntax - the deccorated lambda if you like - to be very easy
17:10:57 <dozer> the class system was different to what I was expecting, but that was ok after a few weeks
17:11:13 <dozer> monads I'm still comming to terms with
17:11:23 <dons> so metaperl talks about the 'functional decompositoin' of a problem, which makes me think its more of an imperative mindset he's talking about
17:11:34 <monochrom> seniority is a barrier.
17:11:37 <dozer> but the main thing is that some of the stdlib docs are not very clear to someone not already in the haskell club
17:11:49 <dons> dozer: ah interesting! do you have examples?
17:12:01 <syntaxfree> you mean, the Prelude?
17:12:07 <dozer> perhaps I should just keep a list :)
17:12:21 <dons> please! i'm happy to improve docs if people point out poor ones
17:12:24 <syntaxfree> it does presuppose functional programming, a working knowledge of recursive definitions and whatnot.
17:12:34 <syntaxfree> If you've never done that, it should be perfectly opaque.
17:12:40 <monochrom> "I have programmed in Java for 30 years" is most often a barrier (to anything really)
17:12:41 <dons> hence the textbooks
17:12:49 <dibblego> monochrom++
17:12:52 <dons> monochrom: yeah, imperative mindset.
17:13:02 <dibblego> 99% unlearning, 1% learning
17:13:05 <dozer> hum - unfoldr docs made no sense - I had to write several examples to grok it
17:13:14 <dozer> but there isn't a worked example by the method in the text
17:13:37 <dons> ok. cool. i can add that
17:13:40 <dons> ?type unfoldr
17:13:41 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
17:13:56 <dons> > unfoldr (\b -> Just (b, b+1)) 0
17:13:58 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
17:14:30 <dons> dozer: how's that?
17:14:34 <dozer> flip it to count down - that shows the Just and the Nothing cases
17:15:12 <dons> > unfoldr (\b -> if b == 0 then Nothing else Just (b, b-1)) 10
17:15:14 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
17:15:20 <dozer> great
17:15:44 <syntaxfree> I don't understand parseTest.
17:16:17 <syntaxfree> if I have a parser that's myparser :: Char -> Parser String
17:16:55 <syntaxfree> why is (parseTest (myparser '#')) :: String -> IO ()  and not :: String -> IO String?
17:17:27 <Botty> hmm, is there a parser library for haskell that uses data as the parser definition? I'd like to have a mutable parser
17:17:45 <Cale> Botty: Parsec?
17:17:47 <Botty> (currently writing my own, but it'd be nice if there was one i could adapt)
17:17:56 <Cale> In fact, most of them do
17:17:59 <Botty> parsec uses functions though, right?
17:18:03 <Cale> yes
17:18:11 <dons> all the combinator parsers can create new functions on the fly and switch to them
17:18:18 <dozer> > map (\i -> i + 1) [1, 2, 3]
17:18:19 <lambdabot>  [2,3,4]
17:18:21 <dons> (isn't this how pugs does its self-modifying parser?)
17:18:27 <Botty> ah
17:18:34 <eviltwin_b> yes
17:18:36 <Botty> yeah, I should look at pugs if it does perl6
17:18:42 <lisppaste2> syntaxfree pasted ":~" at http://paste.lisp.org/display/30589
17:18:42 <Cale> Bind is really (almost painfully) general
17:18:49 <dons> dozer: how's this for adding to the standard docs:
17:18:50 <dons> +--
17:18:50 <dons> +-- A simple use of unfoldr:
17:18:50 <dons> +--
17:18:50 <dons> +-- > unfoldr (\b -> if b == 0 then Nothing else Just (b, b-1)) 10
17:18:52 <dons> +-- >  [10,9,8,7,6,5,4,3,2,1]
17:18:53 <Cale> Parser a -> (a -> Parser b) -> Parser b
17:18:55 <dons> +--
17:18:59 <Cale> context sensitivity :)
17:19:02 <dozer> brill
17:19:31 <syntaxfree> dons: it'd be better to add a reference to "Functional programming with bananas, lenses, etc. etc."
17:19:55 <Cale> I think unfoldr would be more useful if it took a separate parameter for the termination condition
17:20:21 <Cale> (or at least, that version would probably be used more)
17:20:23 <pkhuong> Cale: but then you run the risk of computing the same intermediate result twice.
17:20:25 <syntaxfree> Cale: I think it's like that because of the ana definition in the paper I just mentioned.
17:20:28 <dozer> also, in examples it would be good to be warey of haskell tricks
17:20:40 <dons> dozer: its in the cvs now:
17:20:41 <dons> Fri Nov 24 12:12:49 EST 2006  Don Stewart <dons@cse.unsw.edu.au>
17:20:41 <dozer>  e.g. in my map example, use the full lambda, not the neat way of writing (+1)
17:20:42 <dons>   * Add an example of the use of unfoldr, following doc feedback from dozer
17:20:45 <dons> :)
17:20:45 <Cale> well, yes, this way is closer to the formal idea
17:20:48 <dozer> hehe
17:20:56 <Cale> pkhuong: oh?
17:21:05 <dozer> I'm feeling the need for a dockuthon comming on
17:21:30 <syntaxfree> Cale: how would you define "twicecom" in that paste?
17:21:58 <syntaxfree> (If you were trying to answer me saying bind is really painful, etc.)
17:22:06 <Cale> syntaxfree: hm?
17:22:18 <syntaxfree> Ah, nevermind. I thought you were talking to me ;)
17:22:20 <Cale> iscom isn't composable
17:22:27 <pkhuong> Cale: if you use f(x) to compute the result and to decide termination: you'd first evaluate f(x) in the termination test, and then again in the actual result.
17:22:47 <syntaxfree> I don't understand parseTest.
17:22:52 <Cale> pkhuong: ah, okay
17:22:54 <syntaxfree> Why IO () and not IO String?
17:23:03 <syntaxfree> (I do know the type of parseTest)
17:23:03 <Cale> pkhuong: I think a lot of the time, that doesn't happen though
17:23:24 <pkhuong> Cale: probably not, since termination conditions are usually really simple.
17:23:24 <Cale> Most of the unfold cases I've actually seen have had perfectly separable termination conditions.
17:23:45 <Cale> syntaxfree: use parse instead?
17:24:00 <syntaxfree> Cale: but then it isn't a general unfoldr, it's a specific unfold.
17:24:09 <Cale> If you want to operate on your parser, do it before calling parse.
17:24:14 <Cale> syntaxfree: no, it's equivalent
17:24:16 <pkhuong> Cale: but it's probably to build the separate version on top of the current unfoldr than the reverse.
17:24:29 <syntaxfree> @type Parsec.parse
17:24:30 <lambdabot> Couldn't find qualified module.
17:24:41 <pkhuong> *probably easier
17:24:49 <syntaxfree> ahh.
17:25:13 <syntaxfree> oh-la-la.
17:25:20 <syntaxfree> Thanks!
17:27:51 <monochrom> I don't understand the question. And I don't understand the closing of the question.
17:28:04 <syntaxfree> my question?
17:28:16 <syntaxfree> I was using this:
17:28:17 <monochrom> Yeah.
17:28:21 <syntaxfree> @type import Text.ParserCombinators.Parsec.parseTest
17:28:22 <lambdabot> parse error on input `import'
17:28:27 <syntaxfree> oops.
17:28:36 <syntaxfree> @type Text.ParserCombinators.Parsec.parseTest
17:28:38 <lambdabot> forall tok a. (Show a) => Text.ParserCombinators.Parsec.Prim.GenParser tok () a -> [tok] -> IO ()
17:28:45 <syntaxfree> What I really wanted was this:
17:28:47 <syntaxfree> @type import Text.ParserCombinators.Parsec.parse
17:28:48 <lambdabot> parse error on input `import'
17:28:51 <syntaxfree> grr.
17:28:57 <syntaxfree> @typeText.ParserCombinators.Parsec.parse
17:28:58 <lambdabot> Unknown command, try @list
17:29:01 <syntaxfree> @type Text.ParserCombinators.Parsec.parse
17:29:03 <lambdabot> forall a tok. Text.ParserCombinators.Parsec.Prim.GenParser tok () a -> Text.ParserCombinators.Parsec.Pos.SourceName -> [tok] -> Either Text.ParserCombinators.Parsec.Error.ParseError a
17:30:02 <monochrom> Yeah parseTest prints the result or throws up. Either way not much need to return anything, since it's just "testing".
17:30:35 <syntaxfree> No instance for (Monad (Either a))
17:31:43 <syntaxfree> hmm.
17:32:03 <syntaxfree> @instances Monad
17:32:04 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
17:32:10 <syntaxfree> :(
17:32:24 <syntaxfree> why doesn't my GHC know about Either being a monad?
17:32:54 <monochrom> Does it help if you imported Control.Monad?
17:33:23 <monochrom> Recall that lambdabot has imported a truckload of garbage. :)
17:33:59 <syntaxfree> I did import Control.Monad.
17:34:06 <syntaxfree> I'm attempting to use liftM.
17:34:13 * dcoutts ponders using darcs, txt2tags and a bit of php as a CMS
17:36:34 <monochrom> OH!  (Error e) => Monad (Either e).
17:36:54 <syntaxfree> So?
17:37:20 <monochrom> So, no instance for Monad (Either a), if a arbitrary.
17:38:06 <syntaxfree> @instances Functor
17:38:08 <lambdabot> ((->) r), Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
17:38:16 <syntaxfree> same thing?
17:38:22 <dancor> is a test for being a string the kind of thing that is a builtin
17:38:47 <syntaxfree> well, there are no "isType"-like functions in Haskell.
17:38:54 <syntaxfree> Things have types since they're born.
17:39:00 <monochrom> Functor (Either e)  is in Control.Monad fine.
17:39:03 <syntaxfree> and you can only act on things if you know their type.
17:39:17 <syntaxfree> monochrom: yes, but it seems to be defined only for Error e.
17:39:29 <dancor> syntaxfree: but i have a fcn that returns strings or numbers
17:39:30 <syntaxfree> dancor: Haskell is very fussy about types.
17:39:37 <syntaxfree> dancor: how so?
17:40:14 <monochrom> I am asking ghci with :info Either and it is saying Functor (Either e) and (Error e) => Monad (Either e).  I would trust it instead of lambdabot.
17:43:08 <monochrom> For the latter one has to import Control.Monad.Error.
17:44:08 <sjanssen> lambdabot probably doesn't print the instance contexts
17:44:26 <monochrom> @instances Show
17:44:28 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, ST s a, [a]
17:44:30 <syntaxfree> I didn't know about #info
17:44:34 <syntaxfree> or :info
17:44:38 <dancor> ok how are errors normally done
17:44:46 <monochrom> Clearly you cannot believe there is Show (a,b) or Show [a].
17:44:52 <sjanssen> dancor: with either
17:44:56 <dancor> ok
17:44:59 <sjanssen> monochrom: yes, clearly
17:45:06 <sjanssen> wonder how that plugin works
17:45:08 <syntaxfree> dancor: you make your function of type Either a b
17:45:17 <syntaxfree> in your case, (Num a) => Either a String
17:45:18 <monochrom> It works naively.
17:45:47 <sjanssen> monochrom: right.  I'm guessing a ghci session and some regexps
17:45:48 <syntaxfree> I wrote a tutorial on Either, but it's in portuguese.
17:45:59 <sjanssen> I think I'll sleuth a bit and see if I can fix it
17:46:08 <dibblego> are there any database packages that work by having a database monad that gets passed as a function argument?
17:46:36 <syntaxfree> dancor: it seems to me you might want to learn a few more basic things about Haskell before messing around with Either.
17:46:47 <sjanssen> dibblego: I think haskelldb has a monadic query system
17:46:53 <dancor> nope i need it for the thing i'm doing :)
17:47:02 <dancor> my learning is decidedly lazy
17:47:03 <dibblego> sjanssen, oh right thanks, I'll have a look
17:47:06 <syntaxfree> see.
17:47:12 <syntaxfree> functions in Haskell need to have a type.
17:47:22 <dibblego> sjanssen, by "query system" you mean something like Database -> DatabaseUpdateQuery -> Database?
17:47:24 <syntaxfree> types are made with data constructors.
17:47:37 <syntaxfree> in the case of Either a b, it can either be Left a or Right b.
17:47:42 <syntaxfree> we write
17:47:52 <syntaxfree> data Either a b = Left a | Right b
17:48:05 <syntaxfree> so you have a function that goes to either numbers or strings.
17:48:30 <syntaxfree> that function will be of type (Num a) => (stuff here) -> Either a String
17:48:34 <sjanssen> dibblego: I haven't really worked with it, but as I recall, it uses the do notation to write SQL queries in
17:48:37 <syntaxfree> and then you'll have a two-line function definition.
17:48:38 <dancor> it seems like it would be cooler to use more specific names in different cases
17:48:42 <syntaxfree> f (Left a)  = stuff on nums
17:48:44 <dancor> Result a | Error b
17:48:49 <syntaxfree> f (Right a) = stuff on strings
17:48:57 <dibblego> sjanssen, ok thanks
17:49:19 <zptao> > 38 + 19
17:49:20 <lambdabot>  57
17:51:38 <dancor> > (0,0,0,0,0)
17:51:39 <lambdabot>  (0,0,0,0,0)
17:51:43 <dancor> there is a show!
17:52:17 <dancor> why wasn't (a,b,c,d,e) in @instances Show
17:53:11 <dons> ?instances-importing Data.Tuple Show
17:53:12 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, ST s a, [a]
17:53:23 <dons> innerresting
17:53:24 <sjanssen> whoa, ST s a has a show instance?
17:53:39 <dons> huh
17:53:49 <monochrom> don't you love it
17:53:51 <sjanssen> just show . runST I suppose
17:53:57 <sjanssen> still a little strangt
17:53:58 <sjanssen> e
17:54:15 <dons> instance  Show (ST s a)  where
17:54:16 <dons>     showsPrec _ _  = showString "<<ST action>>"
17:54:16 <dons>     showList       = showList__ (showsPrec 0)
17:54:23 <dons> i.e. like the show instance for IO we added
17:54:56 <sjanssen> oh, that seems kind of useless
17:54:57 * SimonRC finds a cartoon labeled "Dr. Larson's renowned treatise on non-inferring static type systems"
17:55:02 <SimonRC> http://photos1.blogger.com/blogger2/1715/1669/1600/larson-oct-1987.gif
17:55:04 <SimonRC> hehehe
17:55:05 <lambdabot> http://tinyurl.com/joqce
17:55:20 <dons> SimonRC, yeah, its a classic
17:55:31 <sjanssen> nice
17:55:39 <dons> you gotta get the type inference
17:56:14 <zptao> http://www.ceilingcat.com
17:56:16 <lambdabot> Title: Ceiling Cat
17:56:54 <monochrom> dons: remember the haskell wiki page on community and poisonous members?
17:56:59 <dons> yes
17:57:05 <dons> ?op
17:57:06 <lambdabot> Maybe you meant: . bf ft id map pl v wn yow
17:57:08 --- mode: ChanServ set +o dons
17:57:13 --- mode: dons set +b *!*i=zptao@*.dsl.pltn13.pacbell.net
17:57:13 --- kick: zptao was kicked by dons (troll)
17:57:21 <dons> he's been previously kicked from here
17:57:23 <dons> sigh
17:57:27 --- mode: ChanServ set -o dons
17:57:42 <dons> 06.11.09:17:39:25 --- kick: zptao was kicked by dons (trollin on #haskell and #perl6)
17:57:46 <monochrom> I like the criterion that says "don't post urls without a summary" XD
17:57:58 <dons> heh
17:58:56 <dons> monochrom++ thanks for reminding me
17:59:05 <dancor> is it considered cooler to do like (f (x:xs) = g x ++ f xs) or (f xs = fbuild xs []; fbuild (x:xs) b = fbuild xs (b ++ g x); fbuild _ b = b)
17:59:21 <dancor> this is assuming you do something cooler inside than just a map g xs
17:59:45 <dons> so you apply g to the head, and f to the tail?
18:00:00 <dancor> yeah
18:00:03 <dancor> well
18:00:09 <Botty> > let 1+1 = 3 in 1+1
18:00:10 <lambdabot>  3
18:00:12 <dancor> i'm parsing an input string
18:00:32 <dancor> and i don't know if i should keep the result so far as a parameter
18:00:32 <Botty> ^ that's just pathetic
18:00:43 <Botty> (the 1+1 thing)
18:00:49 <monochrom> It's rather rampant on the internet to post urls without saying a word.  It is as though they think you owe it to them to take a look.  I don't understand this mindset.  But it seems the new generation takes it for granted.
18:00:56 <dons> > ((toUpper.head) *** map ord) (splitAt 1 "haskell")
18:00:58 <lambdabot>  ('H',[97,115,107,101,108,108])
18:01:08 <dons> :}
18:01:25 <dibblego> there is a much funnier link than that one anyway :)
18:01:37 <dons> monochrom: well, zptao is a known troll. i.e. if you actually follow the link
18:02:07 <dibblego> http://shadowdane.shackspace.com/cats.htm if you're interested (work safe) - I found it hilarious
18:02:24 <sjanssen> dancor: first version is better
18:02:55 <dons> you can tell, dancor: its shorter:  f (x:xs) = g x ++ f xs -- and obvious
18:02:59 <dancor> sjanssen: ok.  isn't true that in ocaml you would do something like the 2nd one to get tail recursion?
18:03:19 <dons> > ((return.toUpper.head) *** reverse) (splitAt 1 "haskell")
18:03:19 <lambdabot>  add an instance declaration for (Show (m Char))
18:03:29 <dons> > ((toUpper.head) *** reverse) (splitAt 1 "haskell")
18:03:30 <lambdabot>  ('H',"lleksa")
18:03:31 <sjanssen> dancor: right, but in Haskell we'd write the 1st one to take advantage of laziness
18:03:57 <dancor> ok, excellent
18:04:39 <sjanssen> dancor: for bonus points, you could write it as "concatMap g xs"
18:04:43 <Cale> tail recursion is usually evil, unless you pair it up with explicit strictness annotations, or you use something like foldl'
18:05:25 <Korollary> Botty: (+) is not special, so you can redefine it if you want to.
18:05:31 <monochrom> evaluation order changes costs.
18:06:21 <monochrom> Freedom is the right to write let 2+2=5 in 2+2.
18:06:27 <dancor> is there a builtin to break a list into pairs, not finding it at http://www.cs.chalmers.se/Cs/Grundutb/Kurser/d1pt/d1pta/ListDoc/ and i don't have a sense for what kinds of things are likely to be builtin
18:06:29 <lambdabot> Title: Haskell's Standard List Functions, http://tinyurl.com/ydom9r
18:06:34 <Botty> Korollary - don't definitions have to be contiguous?
18:06:51 <Korollary> Botty: contiguous?
18:06:57 <Botty> so in this case its making + special
18:07:12 <Korollary> no
18:07:14 <Botty> yeah, you can't mix definitions together
18:07:20 <dons> dancor: pairs/
18:07:23 <dons> ?
18:07:24 <sjanssen> Botty: the example is creating a new function with the same name
18:07:30 <dons> > splitAt 7 "haskellis fun"
18:07:31 <lambdabot>  ("haskell","is fun")
18:07:37 <Botty> > let a 1 = 5; b 2 = 4; a 2 = 3 in a 1
18:07:38 <lambdabot>    Conflicting definitions for `a'
18:07:38 <lambdabot>   In the binding group for: a, b, a
18:07:41 <sjanssen> it's just scope
18:07:52 <Botty> hmm
18:07:58 <sjanssen> > let head = const 1 in head [2]
18:08:00 <lambdabot>  1
18:08:29 <Botty> oh, hmm, cool
18:08:57 <dancor> > let gpsOf n [] = []; let gpsOf n l = [take n l] ++ gpsOf n (drop n l); gpsOf 3 [1..]
18:08:58 <lambdabot>  Parse error
18:10:03 * dancor does not know how to use lbot
18:10:27 <dancor> / haskell
18:11:00 <dons> > let f x = x in f 10
18:11:02 <lambdabot>  10
18:11:08 <dons> -- just expressions only
18:11:20 <dons> > > let gpsOf n [] = []; let gpsOf n l = [take n l] ++ gpsOf n (drop n l) in gpsOf 3 [1..]
18:11:20 <lambdabot>  Parse error
18:11:23 <Botty> > let gpsOf n [] = []; gpsOf n l = [take n l] ++ gpsOf n (drop n l) in gpsOf 3 [1..]
18:11:25 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23,...
18:12:14 <dancor> ok back from the metaquestion to the question:  should i just use that fcn or is there a builtin
18:13:01 <dons> no builtin function. and you've written your own as a one liner, so i think you're done :)
18:13:30 <dancor> ok
18:13:31 <dons> splitN n xs | null   xs = []
18:13:31 <dons>             | otherwise = l : splitN n r
18:13:31 <dons>     where (l, r) = splitAt n xs
18:13:35 <dons> is also good
18:13:37 <dons> sjanssen++
18:14:12 <dons> > let splitN n xs | null   xs = [] | otherwise = l : splitN n r where (l, r) = splitAt n xs in splitAt 3 [1..]
18:14:13 <lambdabot>  ([1,2,3],[4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
18:14:21 <dons> > let splitN n xs | null   xs = [] | otherwise = l : splitN n r where (l, r) = splitAt n xs in splitN 3 [1..]
18:14:22 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23,...
18:14:30 <Cale> > let gpsOf n = map (take n) . takeWhile (not . null) . iterate (drop n) in gpsOf 3 [1..]
18:14:31 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23,...
18:14:56 <dibblego> ?paste
18:14:57 <lambdabot> http://paste.lisp.org/new/haskell
18:18:39 <dozer> I've got stuck again
18:19:01 <dozer> I'll paste the full source, as I don't know what bits I can cut out and still get the same error
18:19:09 <dozer> sorry for the uberpost
18:22:48 <lisppaste2> dozer pasted "uberpost" at http://paste.lisp.org/display/30592
18:23:28 <dozer> The problem function is rescheduleOnly
18:23:52 <dozer> at the very end
18:38:45 <dancor> so i have data ResErr a b = Res a | Err b
18:39:09 <dancor> and i end up with like [Res 4, Res 2, Err "Bad Num", Res 5]
18:39:32 <Cale> dozer: I can't believe that QAsList could possibly be an instance of EventQ
18:39:39 <dancor> i would to convert my [ResErr a b] to a ResErr [a] b
18:39:49 <dancor> s/would/\0 like
18:39:53 <Cale> oh, no, it's fine
18:40:05 <Cale> I see what you're doing there
18:40:16 <dancor> so the above would become just Err "Bad Num"
18:40:33 <dancor> wereas [Res 2, Res 3] would go to Res [2, 3]
18:40:39 <dancor> s/w/wh
18:40:56 <dozer> ah, perhaps I've missed a parameter off rescheduleAt
18:41:28 <dancor> what's the right way to do this
18:41:40 <Cale> dozer: yeah, that seems likely
18:41:50 <dozer> shiney
18:42:10 <Cale> dancor: do you have a Monad instance?
18:42:10 <dozer> now I've just got some "could not deduce ..." things that I can fix myself :)
18:42:17 <dancor> Cale: no
18:42:33 <Cale> > sequence [Right 4, Right 2, Left "Bad Num", Right 5]
18:42:34 <lambdabot>  Left "Bad Num"
18:42:38 <Cale> > sequence [Right 4, Right 2, Right 5]
18:42:39 <lambdabot>  Add a type signature
18:42:53 <Cale> > sequence [Right 4, Right 2, Right 5] :: Either String Integer
18:42:54 <lambdabot>  Couldn't match `Integer' against `[a]'
18:42:57 <Cale> > sequence [Right 4, Right 2, Right 5] :: [Either String Integer]
18:42:58 <lambdabot>  Couldn't match `Either String Integer' against `[a]'
18:43:00 <dibblego> why doesn't Setup.hs configure recognise the --bindir flag?
18:43:01 <dons> this guy seems to be doing some interesting things in haskell for a beginner, http://haskell-web.blogspot.com/2006/11/search-engine-written-in-haskell-part_24.html
18:43:04 <lambdabot> http://tinyurl.com/y56hqh
18:43:06 <Cale> err
18:43:18 <Cale> > sequence [Right 4, Right 2, Right 5] :: Either String [Integer]
18:43:19 <dons> dibblego: it does
18:43:19 <lambdabot>  Right [4,2,5]
18:43:22 <Cale> right :)
18:43:25 <dancor> heh
18:43:30 <dibblego> dons, Unrecognised flags: --bindir=/home/tmorris/f
18:43:30 <dons> $ ./Setup.hs configure --bindir=`pwd`
18:43:39 <dons> wrong cabal version?
18:43:47 <Cale> I should actually think before coding, but the type system is so good :)
18:43:50 <dibblego> how do I find the version again? I forget
18:43:50 <dons> heh
18:43:57 <dons> ?remember Cale I should actually think before coding, but the type system is so good :)
18:44:13 <dons> $ ghc-pkg list Cabal
18:44:13 <dons> /home/dons/lib/ghc-6.6/package.conf:
18:44:13 <dons>     Cabal-1.1.6
18:44:19 <dibblego> that's it ta
18:44:29 <dibblego> 1.0 :)
18:44:32 <dons> ah ha
18:44:41 <dons> old ghc too then?
18:44:50 <dibblego> 6.4.1
18:45:17 <dons> right. 6.4.2 has a newer Cabal
18:45:31 <dons> (and you keep src compat with 6.4.1 code)
18:45:32 <dozer> sweet - it compiles
18:45:48 <dozer> so I think I have 400 lines of petri-net simulator ready to glue together
18:45:58 <dozer> time for bed said Zeberdie
18:46:37 <dancor> can i use Either = Left | Right but call them other things
18:46:47 <dancor> the way String means [Char]
18:46:58 <dozer> you can call Either something else
18:47:12 <dozer> type MyType a b = Either a b
18:47:20 <dancor> but not Left and Right
18:47:34 <Cale> You could also just implement your own Either monad
18:47:42 <Cale> But I don't really recommend that
18:47:55 <dozer> you could create MyLeft = Left, but I don't think you'd then be able to use MyLeft in pattern matching
18:48:06 <Cale> actually, you couldn't :)
18:48:10 <Cale> myLeft = Left
18:48:14 <Cale> would be okay
18:48:19 <dozer> ah, good point
18:48:41 * edwardk waves hello.
18:48:46 <dozer> which is definitely no use in pattern matching
18:48:50 <dancor> well ok.  but Right as "Error" is a stretch in the extreme
18:49:04 <dancor> for the record
18:49:08 <sjanssen> Left is error
18:49:12 <dancor> it's important to do things for the record
18:49:19 <dancor> sjanssen: hah is it now
18:49:27 <Cale> dancor: no, it's the other way around
18:49:35 <Cale> Right is right, Left is error
18:49:47 <sjanssen> dancor: maybe you can use "fail"
18:49:47 <dancor> you mean that's the normal convention
18:49:49 <dozer> so you have sinistor errors?
18:49:52 <Cale> It's another scheme to marginalise the left-handed
18:50:16 <dancor> i was worried about the decline of new such schemes
18:51:19 <dancor> so you really write Either String Int for ints that might be bad
18:51:28 <dancor> shouldn't the main type be first
18:51:30 <dancor> it's madness!
18:51:49 <Cale> no, in fact, you can't
18:51:50 <sjanssen> dancor: it's necessary for the Monad instance
18:52:08 <Cale> The main type is last because (Either String) is the monad
18:52:42 <Cale> If you try to do it the other way around, you'll run into a problem writing the instance declaration.
18:55:01 <dancor> ok how do i get from (Left "bad", Right 4) to Left "bad"
18:55:16 <dancor> sequence likes lists
18:56:07 <eviltwin_b> it can't be both at the same time (hence "Either")
18:56:08 <dancor> i guess i could use lists there but tuples made more sense since they are always pairs
18:56:14 <sjanssen> > liftM2 (,) (Left "bad") (Right 4)
18:56:15 <lambdabot>  Add a type signature
18:56:58 <eviltwin_b> case result of Left s -> signalAnError; Right r -> processResult r -- roughly
18:57:10 <sjanssen> > liftM2 (,) (Left "bad") (Right 4) :: Either String (Int, Int)
18:57:11 <lambdabot>  Left "bad"
18:57:26 <sjanssen> > liftM2 (,) (Right 5) (Right 4) :: Either String (Int, Int)
18:57:27 <lambdabot>  Right (5,4)
18:57:48 <dancor> sjanssen: but that takes sep args not a pair
18:58:04 <Cale> uncurry
18:58:22 <sjanssen> > uncurry (liftM2 (,)) (Right 5, Right 4) :: Either String (Int, Int)
18:58:24 <lambdabot>  Right (5,4)
18:58:37 <dancor> sweet
19:01:07 <palomer> my thesis is exactly 1000 lines!
19:01:11 <palomer> I can't change _anything_
19:01:18 <edwardk> heh
19:01:25 <Pseudonym> Typo on page 35
19:01:26 <Cale> You need 24 more
19:01:29 <Pseudonym> Sorry.
19:01:37 <edwardk> i felt that way when i hit exactly 100 pages on my first one =)
19:01:48 <palomer> nooooooo!
19:02:20 <dancor> why would haskell say this to me: No instance for (Monad (Either [Char]))
19:02:36 <jcreigh> @hoogle (a -> Bool) -> [a] -> Int
19:02:37 <lambdabot> No matches, try a more general search
19:03:34 <jcreigh> is there a "count" function in prelude? eg, count (>10) [1..15] returns 5
19:03:59 <Cale> there's length and filter
19:04:38 <Cale> @type (length .) . filter
19:04:40 <lambdabot> forall a. (a -> Bool) -> [a] -> Int
19:04:52 <dcoutts> length (filter (>10) [1..5])
19:04:56 <dcoutts> > length (filter (>10) [1..5])
19:04:58 <lambdabot>  0
19:05:03 <dcoutts> > length (filter (>10) [1..15])
19:05:05 <lambdabot>  5
19:06:02 <dcoutts> > length [ n | n <- [1..15], n > 10 ]
19:06:04 <lambdabot>  5
19:06:08 <dcoutts> like SQL, only cooler
19:06:43 <dancor> is that haskell's new tagline
19:06:53 <Korollary> what is the old tagline?
19:06:56 <dcoutts> hah, no, that's a bit limiting
19:06:57 <jcreigh> > foldl (\x y -> if y > 10 then x + 1 else x) 0 [1..15]
19:06:58 <lambdabot>  5
19:07:00 <dancor> better than nothing!
19:07:15 <dons> Just a little better than Nothing
19:07:26 <skeh-> hey its me again, what is the symbol for newline in haskell?
19:07:30 <Cale> > Just 0 > Nothing
19:07:31 <lambdabot>  True
19:07:31 <dcoutts> The language of choice for discriminating hackers.
19:07:33 <dancor> "\n"
19:07:33 <dons> > '\n'
19:07:35 <lambdabot>  '\n'
19:07:36 <dancor> ok
19:07:38 <dancor> i lose
19:07:40 <skeh-> ah single quotes
19:07:41 <skeh-> thanks
19:07:47 <dons> > "\n"
19:07:49 <lambdabot>  "\n"
19:07:55 <dons> ?type "\n"
19:07:56 <dancor> both quines
19:07:58 <lambdabot> [Char]
19:07:59 <dons> ?type '\n'
19:08:02 <lambdabot> Char
19:08:02 <dibblego> how do I tell GHC to use a different version of cabal?
19:08:09 <dcoutts> dibblego, -package Cabal-x.y
19:08:10 <dons> -package Cabal-1.1.6
19:08:29 <dons> the libraries are getting spammed like mad today :/
19:08:34 <Korollary> I am looking at the report, and I can't find the definition of pat0 in the grammar. Where is it?
19:08:35 <dons> good thing the filters work
19:08:48 <dcoutts> dons, the libraries mailing list ?
19:09:00 <dons> yeah, and cvs-all and glasgow-haskell-bugs
19:09:15 <dcoutts> gtk2hs bug tracker is thoroughly spammed
19:09:18 <dons> some spammer sending 10 or so an hour
19:09:21 <dons> maybe more
19:09:24 <dibblego> dons, do I pass that to runhaskell?
19:09:36 <dons> dibblego: to ghc. you might want to hide Cabal 1.0 now though
19:09:54 <dibblego> dons, apparently it is is hidden, but I'm not sure it is still being used
19:09:57 <dcoutts> @seen SyntaxNinja
19:09:58 <lambdabot> I saw SyntaxNinja leaving #haskell, #darcs and #haskell-blah 1d 23h 23m 24s ago, and .
19:10:22 <dcoutts> dibblego, you can find out, use ghc-pkg list Cabal
19:10:23 <jcreigh> so am I wrong to think that the foldl version is more efficient than the (length .) . filter version?
19:10:33 <jcreigh> wrt count
19:10:55 <dibblego> dcoutts, yeah I see it there, (Cabal-1.0), Cabal-1.1.3
19:11:05 <dons> length . filter should fuse to a foldl
19:11:07 <dcoutts> jcreigh, at the moment a foldl' version could be faster because length doesn't fuse with filter.
19:11:12 <dons> ah
19:11:23 <dons> jcreigh: or use Data.ByteString.Char8.count
19:11:27 <dons> ?type Data.ByteString.Char8.count
19:11:29 <lambdabot> Char -> Data.ByteString.Base.ByteString -> Int
19:11:30 <dcoutts> dons, it doesn't. Due to the well known build/fold limitation
19:11:35 <dons> dcoutts: yes
19:11:45 <dcoutts> dons, well at least well know to you an me as we wrote about it! :-)
19:11:47 * dons forgets that not everyone is using streams-based bytestrings ;)
19:11:51 <dcoutts> heh
19:12:10 <jcreigh> dcoutts: how is foldl' different from foldl?
19:12:19 <dcoutts> jcreigh, strict in the accumulator
19:13:58 <sjanssen> length . filter isn't going to be much slower than a foldl' solution
19:14:17 <sjanssen> and length . filter will look much nicer
19:14:27 <dons> if you care about speed, count should kick butt
19:16:09 <Korollary> Does anybody know where pat0 is defined in the report?
19:16:14 <jcreigh> It's not about speed...it's just that, for some reason, it seems counting elements that match a predicate, should do it by counting them, not making a list and taking the length. ie, all speed considerations aside, I like "count f = foldl (\n elem -> if f elem then n + 1 else n) 0" better. I don't know why, I just do.
19:16:55 <dons> foldl' is better there.
19:17:09 <Cale> jcreigh: why not use filter?
19:17:22 <Cale> jcreigh: it's not like it's going to stupidly make the whole list first
19:17:27 <dons> > foldl (\n elem -> if elem `mod` 2 == 0 then n + 1 else n) 0 $ [1..1000000]
19:17:30 <lambdabot>  500000
19:17:36 <Cale> The list elements might not even exist at runtime
19:17:42 <dons> > foldl (\n elem -> if elem `mod` 2 == 0 then n + 1 else n) 0 $ [1..10000000]
19:17:46 <lambdabot> Terminated
19:17:50 <Korollary> The list is still articificial> I agree with him.
19:17:50 <dons> > foldl' (\n elem -> if elem `mod` 2 == 0 then n + 1 else n) 0 $ [1..10000000]
19:17:51 <Cale> depending on how much optimisation gets done
19:17:55 <lambdabot> Terminated
19:18:19 <sjanssen> Cale: length . filter will create list cells in current GHC
19:18:19 <Korollary> I suppose one can use mapAccumL
19:18:48 <dons> but length . filter is a nice decomposition of the problem.
19:18:59 <dons> and since it works pretty well, that's good.
19:19:23 <jcreigh> I don't fully understand how being strict on the accumulator is going to help. ISTR seeing something about this on the wiki...lemme see if I can find it...
19:19:28 <dons> and you could add a custom rule to turn length . filter into foldl' if you want.. ;)
19:20:06 <Cale> sjanssen: yeah, but even then, they won't be around for long
19:20:33 <sjanssen> true
19:22:18 <Cale> I would typically consider using foldl here bad style, since the problem is more decomposable than that.
19:22:30 <sjanssen> any bets on how soon dons will add RULES support to lambdabot's evaluator?
19:22:49 <jcreigh> ah, foldl' is in Data.List
19:22:55 <sjanssen> oh, jeez, maybe they work already?
19:23:01 <Pseudonym> I suspect he won't.
19:23:06 <Cale> Unless you profiled it and really found out that the few intermediate cons cells were your problem
19:23:09 <Pseudonym> We'll just find an exploit for it fairly quickly.
19:24:02 * Pseudonym builds a dynamic Markov model of English
19:25:09 <dons> sjanssen: hmm!
19:25:12 <dons> :)
19:25:26 <dons> Pseudonym: shouldn't be exploitable (pure rewrites stay pure)
19:25:40 * dons hacks more on gang threads for par QC
19:26:53 <sjanssen> ah, we're safe from RULES, no -fglasgow-exts
19:27:50 <dons> true.
19:30:33 <dancor> No instance for (Monad (Either String))
19:30:41 <dancor> do i need to import more than Monad..
19:31:36 <jcreigh> My hugs segfaults on "foldl (+) 0 [1..100000]". (but foldl' is fine.) Is it saying "stack overflow"?
19:31:37 <Korollary> Either apparently is not an instance of Monad.
19:31:50 <Cale> Korollary: Control.Monad.Error
19:31:50 <dons> jcreigh: that's a hugs bug fixed in the most recent hugs relesae
19:31:53 <dons> i reccomend ghci :)
19:32:02 <Cale> it's not a bug
19:32:07 <Cale> er
19:32:17 <Cale> Well, it should stack overflow :)
19:32:39 <Cale> So maybe segfaulting isn't such a good way to do that :)
19:33:29 <dons> the segfault is a bug, that's been fixed
19:33:29 <dancor> no application that doesn't include pointer arithmetic in its featureset should ever segfault
19:33:40 <dons> dancor: hugs is written in C
19:33:49 <dibblego> ?where hs-plugins
19:33:49 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
19:33:51 <dons> lesson: don't write hugs in C :)
19:34:07 <Korollary> Cale: ?
19:34:13 <dibblego> where's the darcs repos for hs-plugins?
19:34:26 <Cale> Korollary: that's where the instance is
19:34:41 <dibblego> oh found it
19:34:51 <dibblego> I am blind
19:38:51 <Korollary> Blimey
19:40:18 <Korollary> Either String String is. How are you supposed to know this?
19:42:48 <Korollary> err Either String a is.
19:44:45 <Cale> It's listed in the documentation for that module
19:45:03 <Cale> Error e => MonadError e (Either e)
19:45:59 <Cale> however, it is a little annoying that it requires Error e
19:46:16 <Cale> though it's pretty easy to implement that for whatever type of error you want
19:46:34 <robreim> dons: any progress with hs-plugins?
19:49:38 <dancor> omg what is this error Inferred type is less polymorphic than expected
19:49:52 <dons> robreim: getting there..
19:49:59 <palomer> dancor, maybe you're trying to specify a polymorphically recursive function?
19:50:04 <palomer> dancor, if so, annotate your function
19:50:52 <Cale> Or maybe you just gave it a type signature which was too general
19:51:25 <dancor> how do you do f :: Num a => Num b => a -> b
19:51:38 <Cale> f :: (Num a, Num b) => a -> b
19:52:15 <dibblego> I have hit this problem so many times, but forgotten what I did to fix it; compiling lambdabot gives Not in scope: data constructor `PATCH_COUNT' (5 more)
19:52:25 <dons> sjanssen: can you give the pqc suite a run again? i've change the implementatoin to use gang threads (i.e. fork N threads, and they just take jobs from the queue when ready -- should run a bit better)
19:52:33 <dons> dibblego: chmod +x configure
19:53:36 <dibblego> dons, nope
19:54:07 <dibblego> sorry
19:54:25 <dons> what's in config.h ?
19:54:45 <dibblego> I made a mistake
19:54:51 <dibblego> I was trying to do a build
19:54:58 <dibblego> but I had to reconfigure with configure +x
19:55:50 <dons> yesw
20:01:07 <dons> sjanssen: seems to scale better:
20:01:08 <dons> $ time ./a.out 2 > /dev/null
20:01:09 <dons> ./a.out 2 > /dev/null  18.65s user 0.02s system 99% cpu 18.682 total
20:01:14 <dons> $ time ./a.out 4 +RTS -N4 > /dev/null
20:01:15 <dons> ./a.out 4 +RTS -N4 > /dev/null  22.20s user 0.25s system 288% cpu 7.777 total
20:01:22 <dons> 288% cpu me like :)
20:03:54 <Pseudonym> That's some serious overclocking.
20:05:42 <dons> i love how i can scale my haskell apps to run on N processors by tweaking the runtime -N flag
20:07:51 <dibblego> dibblego> > 1
20:07:51 <dibblego> <lambdabot> Terminated
20:07:56 <dibblego> wtf is up with that?
20:08:03 <dons> no runplugs?
20:08:17 <dibblego> no I don't actually
20:08:52 <dibblego> where could I find that?
20:09:04 <Cale> dibblego: it's in the scripts directory
20:09:13 <Cale> you have to compile it separately for some reason
20:09:27 <dibblego> ok ta
20:09:51 <dibblego> just compile Runplugs.hs?
20:11:07 <Cale> yeah
20:11:20 <edwardk> i ran into the problem that i had to manually compile ShowQ and ShowFun in order to get runplugs to work
20:11:22 <dons> dibblego: the lambdabot build system should do this for you
20:11:29 <dons> presuming you have ghc 6.4.2 and hs-plugins installed...
20:11:34 <edwardk> as i recall
20:11:36 <Cale> Oh, usually I have to hack those out of it
20:11:39 <dibblego> edwardk, looks like I'm running into that now :)
20:11:46 <dibblego> dons, 6,4,1
20:11:53 <dibblego> er 6.4.1 (and hs-plugins)
20:11:56 <Cale> I usually just remove all traces of template haskell from runplugs
20:11:59 <edwardk> if you just run ghc to compile them, then it works
20:12:24 <dibblego> ghc --make RunPlugs.hs -o runplugs
20:14:02 <dibblego> how do you compile ShowQ and ShowFun? there is no main
20:15:37 <edwardk> i just ran ghc, let it complain it spat out a .o
20:15:46 <edwardk> then when i ran the other stuff it worked coz it was able to link
20:16:03 <dibblego> did you ln -s scripts/runplugs ?
20:16:36 <edwardk> it was in a different directory by then coz i hacked up my install pretty bad trying to work around the ./foo paths everywhere
20:19:03 <dibblego> where did you put the .o files?
20:19:26 <dibblego> I am getting Failed to load interface for `ShowQ':
20:22:03 <dons> dibblego: follow the build script please
20:22:07 <dons> if ./build doesn't work, let me know
20:22:10 <dibblego> I'm trying mate
20:23:35 <dibblego> I was running Setup.hs build - hope that doesn't make a difference
20:24:19 <sjanssen> ./Example 1 -- 17.256s
20:24:36 <sjanssen> ./Example 2 +RTS -N2 -- 10.402s
20:24:51 <edwardk> dibblego i wound up with them in the same directory as the runplugs executable
20:25:31 <edwardk> and ahh, the ./build script does the build for ShowQ and ShowFun
20:25:31 <edwardk> didn't see that =)
20:25:31 <dibblego> I just tried rebuilding, but now it won't connect to the server
20:25:51 <edwardk> never noticed the ./build script
20:25:53 <dons> sjanssen: cool.
20:26:26 <dons> sjanssen: on a dual core mac?
20:26:29 <sjanssen> dons: have any ideas to automatically determine how many workers to run?
20:26:44 <dons> if we had a env var indicating the number of cores
20:26:47 <dons> we could use that
20:26:53 <dons> or a ghc rts flag
20:28:05 <sjanssen> it'd be nice if I could set an environment var to tell GHC how many cores to run on
20:28:21 <dons> sjanssen: yeah. so is that result on the mac? (i'd like to mention that in the release announce)
20:28:36 <dons> api here, http://www.cse.unsw.edu.au/~dons/pqc/Test-QuickCheck-Parallel.html
20:28:38 <lambdabot> http://tinyurl.com/yxnuyh
20:28:40 <sjanssen> dons: yes, a Macbook
20:29:00 <dons> dual core?
20:29:07 <sjanssen> right
20:29:40 <sjanssen> do you want more data?  I've got a dual processor Athlon MP too
20:29:58 <dons> yeah, that'd be cool if you could
20:30:08 <dons> i've tested on a single core, and a 4 cpu, 8 core box.
20:30:12 <dons> but the more the better
20:32:18 <dancor> is there ctags for haskell
20:32:32 <Cale> yeah
20:32:40 <Cale> @where hasktags
20:32:40 <lambdabot> http://www.cl.cam.ac.uk/users/rje33/software.html
20:33:17 <Cale> It's satisfying when @where works :)
20:33:22 <sjanssen> dancor: there is also a patch to exuberant-ctags.  Gentoo uses, not sure about other distributions
20:34:08 <dancor> sjanssen: didn't work for me
20:34:17 <dancor> don't see any use flags for ctags either
20:34:26 <dancor> do i need like 5.6 maybe
20:34:32 <dancor> what version do you have
20:35:38 <sjanssen> dancor: I have 5.5.4-r3
20:35:48 <sjanssen> I think it worked, let me double check
20:36:41 <dancor> ok
20:36:55 <dancor> it's only 5.5.4-r3 and 5.6
20:37:02 <dancor> grepping in /usr/portage
20:38:54 <sjanssen> @where paste
20:38:55 <lambdabot> http://paste.lisp.org/new/haskell
20:42:34 <lisppaste2> sjanssen pasted "trials for dons" at http://paste.lisp.org/display/30598
20:44:44 <dancor> sjanssen: 5.6 did not work, in case you were thinking of upgrading, don't
20:45:01 <sjanssen> dancor: ouch :/
20:45:08 <dancor> but 5.5.4-r3 is good..
20:45:36 <sjanssen> that's too bad, I don't like hasktags as much
20:46:05 <sjanssen> someone ought to do the legwork and get the patch upstream
20:52:12 <dancor> parse error is the bane of my existence
20:53:02 <dancor> parse error is the bane of my existence
20:53:06 <dancor> heh oops
20:53:30 <sjanssen> > replicate 2 "dancor"
20:53:31 <lambdabot>  ["dancor","dancor"]
20:54:50 <dancor> so i wish i could do: do\..(if' a\....b\....c\..)
20:54:59 <dancor> \ -> \n
20:55:01 <dancor> . -> ' '
20:55:17 <dancor> but haskell insists on: do\..(if' a\....b\....c\....)
20:55:28 <sjanssen> thems the breaks, I suppose
20:55:38 <sjanssen> is if' special somehow?
20:55:59 <dancor> if' is just if-then-else as a function
20:56:07 <dancor> so that it isn't special
20:56:11 <dancor> syntactically
20:56:25 <dancor> and i don't have to learn any more weird syntax whitespace rules
20:57:32 <dibblego> dons, can we get lambdabot to join #jtiger?
20:57:33 <dons> thanks sjanssen
20:57:40 <dons> ?join #jtiger
20:57:46 <dibblego> thanks
20:57:46 <dons> dibblego: did it join?
20:57:50 <dibblego> yep
20:57:56 <dons> let me know if it needs to be removed..
20:58:11 <dibblego> I don't think lambdabot will follow if I use ?join right?
20:58:18 <sjanssen> dancor: if-then-else does what you want ;)
20:58:27 <dancor> sjanssen: figures
20:59:03 <dibblego> ?join #blahblah
20:59:04 <lambdabot> Not enough privileges
21:04:50 <robreim> ooh parallel quickcheck...
21:05:01 <Pseudonym> ReallyQuickCheck
21:10:43 <dibblego> why does lambdabot come with a Setup.hs?
21:11:58 <edwardk> dibblego: quirk of its internal install process
21:12:22 <dibblego> I just tried to install on a clean vmware exactly as the README says and I'm back in the same position
21:12:45 <dibblego> oh wait, it worked! (after I built runplugs manually)
21:21:12 <dancor> can i filter a list and just get the indices of the matches
21:23:45 <LoganCapaldo> > let xs = ["a", "b", "c"] in map (\(x,i) -> i) $ filter (\(x, i) -> x == "a") $ zip xs [0..((length xs) - 1)]
21:23:46 <lambdabot>  [0]
21:23:49 <dibblego> ?hoogle (a -> Bool) -> [a] -> [Int]
21:23:50 <lambdabot> List.findIndices :: (a -> Bool) -> [a] -> [Int]
21:23:55 <LoganCapaldo> Oh damn
21:24:03 <LoganCapaldo> I feel dumb now
21:24:27 <dancor> LoganCapaldo: if it will make you feel better, i will use yours in my program :)
21:24:42 <LoganCapaldo> Nah that's ok, use findIndices ;)
21:24:45 <LoganCapaldo> It's clearer
21:25:50 <sjanssen> LoganCapaldo's function won't work on infinite lists
21:26:03 <sjanssen> but it's an easy fix, just remove the length xs - 1 part
21:26:12 <LoganCapaldo> LOL
21:26:20 <LoganCapaldo> zip will limit it based on the shorter list?
21:26:25 <sjanssen> yes
21:26:25 <psykotic> yes
21:26:27 <LoganCapaldo> I did not know that
21:27:26 <LoganCapaldo> obviously
21:30:12 <LoganCapaldo> > let xs = ["a", "b", "c"] in map snd $ filter ((== "a") . fst) $ zip xs [0..]
21:30:13 <lambdabot>  [0]
21:30:17 <LoganCapaldo> heh
21:30:58 <LoganCapaldo> I feel like the more haskell I write the more it looks like forth with the occasional infix operator
21:31:00 <sjanssen> \p xs -> [i | x <- xs, not (p x) | i <- [0..]] -- uses Glasgow extensions
21:31:35 <LoganCapaldo> oooo two bars
21:31:52 <sjanssen> LoganCapaldo: the pipline generally flows from right to left in Haskell, though
21:32:00 <LoganCapaldo> yeah
21:32:43 <sjanssen> it's a rarely used syntax, called "parallel list comprehensions" iirc
21:37:55 <dancor> how do you reverse a tuple
21:38:03 <int-e> \p -> zipWith const [0..] . filter (not . p)  seems clearer to me.
21:38:15 <int-e> \(a,b) -> (b,a) ?
21:38:16 <sjanssen> @djinn (a, b) -> (b, a)
21:38:17 <lambdabot> f (a, b) = (b, a)
21:38:29 <sjanssen> int-e: perhaps it does, but it's wrong ;)
21:38:58 <sjanssen> @. pl djinn (a, b) -> (b, a)
21:38:59 <lambdabot> f = uncurry (flip (,))
21:39:01 <int-e> sjanssen: no. that's what you wrote.
21:39:32 <sjanssen> ha, so I was wrong first
21:39:41 <LoganCapaldo> > uncurry (flip (,)) (1, 2)
21:39:42 <lambdabot>  (2,1)
21:39:45 <LoganCapaldo> heh
21:40:40 <Botty> ?type uncurry
21:40:41 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
21:40:53 <sjanssen> so can this even be written with parallel list comprehensions?
21:40:53 <Botty> oooh
21:41:38 <LoganCapaldo> Can you write uncurry in Haskell?
21:41:51 <LoganCapaldo> @djinn forall c b a. (a -> b -> c) -> (a, b) -> c
21:41:52 <lambdabot> f a (b, c) = a b c
21:41:54 <Botty> Logan - sure
21:41:54 <sjanssen> @djinn (a -> b -> c) -> (a, b) -> c
21:41:55 <lambdabot> f a (b, c) = a b c
21:42:08 <int-e> sjanssen: so you meant \p xs -> [i | (x, i) <- zip xs [0..], not (p x)] ? (I didn't succeed in writing that with parallel list comprehensions)
21:42:27 <LoganCapaldo> Heh, I asked lambdabot <g>
21:42:39 <LoganCapaldo> @type curry
21:42:40 <sjanssen> int-e: yes, I was trying to write findIndices
21:42:41 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
21:42:54 <LoganCapaldo> @djinn forall c b a. ((a, b) -> c) -> a -> b -> c
21:42:55 <lambdabot> f a b c = a (b, c)
21:43:10 <Botty> hmm, that's contrary what I thought the term "currying" meant
21:43:34 <LoganCapaldo> @type (,)
21:43:36 <lambdabot> forall b a. a -> b -> (a, b)
21:43:50 <LoganCapaldo> @type uncurry (,)
21:43:53 <lambdabot> forall a b. (a, b) -> (a, b)
21:44:05 <Botty> why does lambdabot always do a forall when it could just be implied by standard haskell sugar?
21:44:16 <dibblego> Botty, one would think that "uncurry" is the contrary to what one thinks is "currying", yes?
21:44:44 <Botty> dibblego: sure, but curry in either sense means being able to do stuff like (+1) 5
21:44:44 <LoganCapaldo> @type flip (,)
21:44:46 <lambdabot> forall a b. b -> a -> (a, b)
21:45:07 <sieni> huh, fortunately ghc downgrade was easy on debian
21:45:07 <LoganCapaldo> @type uncurry flip
21:45:09 <lambdabot> forall a c b. (a -> b -> c, b) -> a -> c
21:45:23 <LoganCapaldo> @type uncurry . flip
21:45:24 <lambdabot> forall a b c. (b -> a -> c) -> (a, b) -> c
21:46:05 <sjanssen> uncurry is the hylomorphism on pairs!
21:46:15 <LoganCapaldo> @type uncurry . flip (,)
21:46:17 <lambdabot>   Couldn't match `b -> c' against `(a, a1)'
21:46:17 <lambdabot>    Expected type: a -> a1 -> b -> c
21:46:27 <LoganCapaldo> @type uncurry . (flip (,))
21:46:28 <lambdabot>   Couldn't match `b -> c' against `(a, a1)'
21:46:29 <lambdabot>    Expected type: a -> a1 -> b -> c
21:46:36 <LoganCapaldo> @type uncurry (flip (,))
21:46:37 <lambdabot> forall a b. (a, b) -> (b, a)
21:46:47 <Botty> oh well, doesn't really matter, I could complain about map too :P even fold to some extent, though that makes sense
21:47:14 <LoganCapaldo> What boggles my mind is that constructors seem to be for all intents and purposes functions
21:47:16 <sjanssen> Botty: where'd you pick up that defn. of curry?
21:47:31 <jcreigh> hmm, I didn't know about (,)
21:47:40 <sjanssen> LoganCapaldo: they are (when in an expression)
21:47:57 <LoganCapaldo> It's just boggling
21:48:04 * LoganCapaldo boggles
21:48:05 <sjanssen> they're a little special when they're in a pattern match
21:48:14 <Botty> either wikibooks or the Haskell School of Expression
21:48:37 <Botty> jcreigh - me neither.  Pretty elegant i'd say
21:48:39 <sjanssen> Botty: usually (1+) is called a "section"
21:48:50 <dons> > (,) 1 2
21:48:51 <sjanssen> sadly, we can't write "(x,)"
21:48:52 <lambdabot>  (1,2)
21:48:54 <Botty> sjanssen - yes, i know.  I should have had a better example
21:49:01 <Botty> really?
21:49:05 <Botty> why not
21:49:09 <LoganCapaldo> we can do ((,) x) though right?
21:49:10 <dons> > Right . id . Just . (,) $ 1 2
21:49:11 <lambdabot>  add an instance declaration for (Num (t -> a))
21:49:17 <dons> > Right . id . Just . (,) 2 $ 1
21:49:19 <lambdabot>  Add a type signature
21:49:20 <LoganCapaldo> @type (,) 1
21:49:21 <lambdabot> forall a b. (Num a) => b -> (a, b)
21:49:25 <Botty> eg, (foldl (+) 0) [1,2..5]
21:49:29 <dons> ?type Right . id . Just . (,) 2 $ 1
21:49:31 <lambdabot> forall a a1 a2. (Num a1, Num a2) => Either a (Maybe (a1, a2))
21:49:32 <Botty> currying going on there
21:49:43 <sjanssen> Botty: that's actually partial application
21:49:47 <Botty> hmm
21:49:49 <LoganCapaldo> hehh
21:49:59 <sjanssen> which happens by virtue of the fact that all functions in Haskell are curried
21:50:00 <LoganCapaldo> I've got a half a tuple :)
21:50:05 <LoganCapaldo> wait
21:50:09 <Botty> oh, thats probably where i got the defn
21:50:15 <LoganCapaldo> Now I know what bothers me about (,)
21:50:21 <Botty> functions are curried, so you can have partial application
21:50:21 <LoganCapaldo> (,) 1 2 3
21:50:25 <LoganCapaldo> Doens't work
21:50:53 <LoganCapaldo> but (,) 1$ (,) 2 3 isn't the same as (1,2,3) right?
21:50:54 <Pseudonym> > (,,) 1 2 3
21:50:55 <lambdabot>  (1,2,3)
21:51:00 <Pseudonym> Correct.
21:51:11 <LoganCapaldo> Pseudonym: Why don't you just dash my hopes and dreams <g>
21:51:12 <Pseudonym> In a lazy language, (1,(2,3)) isn't the same as ((1,2),3).
21:51:32 <LoganCapaldo> @type (,,,,,,,,)
21:51:33 <lambdabot> forall i h g f e d c b a. -> b -> c -> d -> e -> f -> g -> h -> i -> (a, b, c, d, e, f, g, h, i)
21:51:45 <sieni> Pseudonym: how does laziness have to do anything with that?
21:51:49 <LoganCapaldo> Is that just generated on tehe fly?
21:51:59 <sjanssen> Botty: exactly.  So 'curry' turns tuple functions into curried functions
21:52:04 <LoganCapaldo> weird
21:52:10 <LoganCapaldo> hmmm
21:52:10 <sjanssen> and uncurry goes the other way
21:52:15 <LoganCapaldo> (:::) 1 2 []
21:52:20 <LoganCapaldo> > (:::) 1 2 []
21:52:20 <Pseudonym> sieni: (1,undefined) is a perfectly valid element of (Int,(Int,Int))
21:52:21 <lambdabot>  Not in scope: data constructor `:::'
21:52:26 <LoganCapaldo> darn
21:52:38 <LoganCapaldo> That was one too many colons anyway
21:52:44 <LoganCapaldo> > (::) 1 2 []
21:52:45 <lambdabot>  Parse error
21:52:58 <eviltwin_b> I think the point is that , is not an operator, so much as (,[,...]) is a tuple constructor
21:53:00 <Botty> sjanssen - ah, though you have to call it a few times.
21:53:03 <sieni> Pseudonym: Well, but (1 . (2 . 3)) and ((1 . 2) . 3) are not the same in lisp either
21:53:07 <Pseudonym> There's no obvious isomorphism between (Int,(Int,Int)) and ((Int,Int),Int)
21:53:16 <Pseudonym> Because of bottom.
21:53:16 <sieni> ahh
21:53:29 <jcreigh> > (,,) 1 2 3
21:53:31 <lambdabot>  (1,2,3)
21:53:35 <jcreigh> oh, even stranger.
21:53:35 <Pseudonym> An in particular, neither are isomorphic to (Int,Int,Int).
21:53:42 <LoganCapaldo> Pseudonym: I wasn't asking about those two though I was wondering about (1,2,3) vs. (1,(2,3))
21:53:45 <sjanssen> Botty: right, it's complicated to do it for a varying number of arguments.  We also have uncurry3
21:53:51 <sjanssen> @hoogle uncurry
21:53:53 <lambdabot> Prelude.uncurry :: (a -> b -> c) -> (a, b) -> c
21:53:54 <Botty> ah ok
21:53:59 <LoganCapaldo> which of course you showed was not a problem since we can jsut use more commas
21:54:10 <sjanssen> at least I thought so . . .
21:54:27 <Pseudonym> In a strict language, (Int,(Int,Int)) is isomorphic to (Int,Int,Int) because you can always guarantee that the "tuple cell" is evaluated.
21:55:17 <LoganCapaldo> Pseudoym: Just for a a a or also for a b c ?
21:55:25 <Pseudonym> Also for a b c.
21:55:30 <jcreigh> weird: http://www.google.com/search?q=%28%2C%29
21:55:31 <lambdabot> Title: (,) - Google Search
21:55:31 <Botty> my problem was that I was looking at the function in a different way than its meant.  like sumTuple = uncurry (+)
21:55:45 <Botty> wait....
21:55:51 <Botty> actually, that is basically what that's doing
21:55:55 <Botty> doh
21:57:29 <LoganCapaldo> Pseudonym: Does isomorphic mean I can do: let f (a, b, c) = a + b + c in f (1,(2,3)), or will a real language like SML not actually allow that?
21:58:05 <Botty> > snd $ snd (1,2,3)
21:58:06 <lambdabot>  Couldn't match `(a1, (a, b))' against `(a2, b1, c)'
21:58:19 <Botty> :type (1,2,3)
21:58:28 <Botty> ?type (1,2,3)
21:58:29 <lambdabot> forall a b c. (Num a, Num b, Num c) => (a, b, c)
21:58:30 <Pseudonym> I can't comment about SML.
21:58:34 <Pseudonym> But the answer is probably not.
21:58:43 <LoganCapaldo> Ok
21:58:53 <Pseudonym> "Isomorphic" means that you can freely inter-convert between the two types.
21:59:12 <LoganCapaldo> Not necessarily that its done automatically
21:59:18 <LoganCapaldo> yes?
21:59:23 <emu> isomorphic just means there is an equivalency relationship between the two
21:59:29 <LoganCapaldo> k
21:59:30 <Pseudonym> Right.
21:59:36 <LoganCapaldo> thanks
21:59:36 <Pseudonym> See, if you try:
21:59:44 <Pseudonym> f (a,(b,c)) = (a,b,c)
21:59:59 <Pseudonym> Then (1,undefined) and (1,(undefined,undefined)) have the same representation.
22:00:07 <Pseudonym> So that's NOT an isomorphism.
22:00:15 <LoganCapaldo> Oooo
22:00:20 <Botty> how would you access elements in a triple tuple?
22:00:21 <glguy> if that isomorphism was automatic, we'd be no better than the barbarian languages from the land of Ducktype
22:00:36 <LoganCapaldo> Because in Haskell things can "safely" go to bottom
22:00:43 <Pseudonym> ?hoogle (a,b,c) -> a
22:00:44 <lambdabot> No matches, try a more general search
22:00:52 <emu> that would resemble perl list-flattening, even more barbarous than barbarituy
22:00:52 <Pseudonym> > fst3 (1,2,3)
22:00:53 <lambdabot>  Not in scope: `fst3'
22:00:55 <Pseudonym> Hmm.
22:01:06 <glguy> or Ruby's adding method to the NilClass
22:01:26 <sjanssen> Botty: use pattern matching
22:01:42 * eviltwin_b is on record as saying that "duck typing" should be read as "Duck!" typing :)
22:02:12 * Botty thinks numbered functions make haskell ugly, signals a deficiency of some kind.
22:02:34 <Botty> sjanssen - yeah, i do, just figured there'd be a decent way
22:02:39 <sjanssen> Botty: tuples just suck, generally
22:02:42 <emu> SML has functions named #1, #2, #3... that work on all tuples
22:02:45 <emu> special cased though
22:02:49 <Pseudonym> True, tuples do suck.
22:02:54 <dibblego> Botty, prefer a lambda expression?
22:02:55 <Botty> eg, maybe tuples are converted to tree structures internally (1,2,3) -> (1,(2,3))
22:02:56 <glguy> I think of it as typing done with duck-tape
22:02:56 <Pseudonym> Generally speaking, you don't want them.
22:03:02 <eviltwin_b> 'cause you're not supposed to use 'em :)
22:03:17 <sjanssen> emu: we could do that with type classes in Haskell, but meh
22:03:18 <Botty> dibblego - well, lambdas have matches, that's not the issue
22:03:57 <LoganCapaldo> Oh man, that would be a lot of instance declarations :)
22:04:13 <sjanssen> yes, O(n^2)
22:04:17 <Pseudonym> Consider scrapping your boilerplate.
22:11:28 <Botty> > let tail = drop 1
22:11:28 <lambdabot>  Parse error
22:12:31 <LoganCapaldo> heh
22:14:00 <LoganCapaldo> > let tail = drop 1 ; head = (\[x] -> x) . (take 1) ; xs = [1,2,3] in (head xs, tail xs)
22:14:02 <lambdabot>  (1,[2,3])
22:14:15 <LoganCapaldo> head isn't cool enough
22:15:25 <sjanssen> @where paster
22:15:26 <lambdabot> I know nothing about paster.
22:15:28 <sjanssen> @where paste
22:15:29 <lambdabot> http://paste.lisp.org/new/haskell
22:15:37 <Botty> ?hooge [a] -> a
22:15:38 <lambdabot> Prelude.head :: [a] -> a
22:15:38 <lambdabot> Prelude.last :: [a] -> a
22:15:38 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
22:16:11 <Cale>  let (x:xs) = [1,2,3] in (x, xs)
22:16:13 <Cale> > let (x:xs) = [1,2,3] in (x, xs)
22:16:15 <lambdabot>  (1,[2,3])
22:16:19 <Pseudonym> ?free maximumBy
22:16:21 <lambdabot> (forall x. g x = h (f x) . f) => f . maximumBy g = maximumBy h . $map f
22:16:37 <Botty> > let head = last $ take 1 in head [1,2,3]
22:16:38 <lambdabot>    Expecting a function type, but found `a'
22:16:38 <lambdabot>    Expected type: [a]
22:16:38 <lambdabot>    ...
22:16:52 <Botty> > let head = last . take 1 in head [1,2,3]
22:16:54 <lambdabot>  1
22:17:07 <LoganCapaldo> Hmm
22:17:09 <LoganCapaldo> better
22:17:47 <Botty> not very good though, last is more complicated than head
22:18:03 <Cale> > let head = foldr const undefined in head [1,2,3]
22:18:04 <lambdabot>  1
22:18:09 <Botty> really that's just a hack to not use head in its definition
22:18:14 <Botty> nice
22:18:20 <sjanssen> boo lisppaste
22:18:23 <LoganCapaldo> @hoogle const
22:18:24 <lambdabot> Prelude.const :: a -> b -> a
22:18:24 <lambdabot> Data.Generics.Basics.constrFields :: Constr -> [String]
22:18:24 <lambdabot> Data.Generics.Basics.constrFixity :: Constr -> Fixity
22:18:34 <Cale> @free const
22:18:36 <lambdabot> f . const x = const (f x) . g
22:18:36 <sjanssen> anyone notice how it goes down every so often?
22:18:45 <LoganCapaldo> Oh is const K?
22:18:52 <Cale> yes
22:18:57 <Cale> > const 2 3
22:18:59 <lambdabot>  2
22:19:52 <LoganCapaldo> heh
22:19:54 <LoganCapaldo> LOL
22:19:58 <LoganCapaldo> ROFLMAO
22:20:06 <LoganCapaldo> I feel like I just got the joke
22:20:18 <LoganCapaldo> fold--->R<--- const
22:20:20 <Cale> which joke?
22:20:36 <LoganCapaldo> Theres no joke really
22:20:44 <LoganCapaldo> I just grasped how that worked
22:21:07 <lisppaste2> sjanssen pasted "a scheme for overloaded functions on tuples" at http://paste.lisp.org/display/30601
22:21:13 <Cale> > let head = foldr const undefined in head [1..]
22:21:15 <lambdabot>  1
22:22:00 <Cale> LoganCapaldo: http://cale.yi.org/index.php/Fold_Diagrams
22:22:03 <lambdabot> Title: Fold Diagrams - CaleWiki
22:22:07 <LoganCapaldo> > foldl const undefined [1,2,3,4]
22:22:09 <lambdabot>  Add a type signature
22:22:18 <LoganCapaldo> hmmm
22:22:31 <sjanssen> only have to write O(n) instances with this system
22:22:32 <Cale> > foldl (flip const) undefined [1,2,3,4]
22:22:34 <lambdabot>  4
22:25:39 <Cale> > let append = scanr const in append 5 [1,2,3,4]
22:25:40 <lambdabot>  [1,2,3,4,5]
22:27:34 <Cale> > let cons = scanl (flip const) in cons 0 [1,2,3,4]
22:27:36 <lambdabot>  [0,1,2,3,4]
22:28:24 <Cale> How to waste the power of higher order functions
22:30:04 <psykotic> killing flies with nuclear bazookas?
22:33:41 <LoganCapaldo> sjanssen: Was that code supposed to work yet?
22:33:56 <LoganCapaldo> fourth (1,2,3,4,5,6,7,8) doesn't work
22:34:09 <sjanssen> LoganCapaldo: I haven't written that many instances yet
22:34:45 <LoganCapaldo> Oh when you said O(n) I thought you meant n as in the number of positions you could get at
22:34:51 <LoganCapaldo> (n = 4)
22:34:59 <LoganCapaldo> sorry
22:35:02 <sjanssen> easy to finish, just write the THead and TTail instances for 5, 6, 7, 8 tuples
22:35:07 <sjanssen> I should have been more clear
22:36:31 <sjanssen> we need O(n) instances (the maximum a compiler supports, 200 something in GHC), and O(i) functions, where i is the number of indexes we want to access
22:42:03 <dons> hmm, I do get the error with haddock:
22:42:04 <dons> $ runhaskell Setup.lhs haddock
22:42:04 <dons> Preprocessing executables for haq-0.0...
22:42:04 <dons> Running Haddock for haq-0.0...
22:42:04 <dons> Warning: cannot use package haq-0.0:
22:42:07 <dons>    ghc-pkg failed
22:42:14 <dons> anyone else seen this when running haddock and ghc 6.6 via cabal?
22:46:33 <glguy> dons: you read that LogicT paper?
22:46:49 <dons> bits of it
22:47:03 <glguy> does it compare to Cale's (?) Nondet monad?
22:47:04 <dons> (I was there during the presentation, last year)
22:47:09 <dons> (or the year before?)
22:47:17 <dons> not sure, have to check with Cale
22:47:32 <glguy> Ah ok
22:47:39 <Cale> The Nondet monad isn't mine, and LogicT is more powerful
22:47:43 <glguy> ah, cool
22:47:52 <glguy> You are about the only person I've seen use Nondet
22:47:59 <glguy> so I just assumed =/
22:53:56 <Cale> The Nondet monad isn't mine, and LogicT is more powerful
22:54:41 <glguy> i *believe* you
22:54:59 <Cale> er
22:55:00 <Cale> sorry :)
22:55:03 <glguy> ;)
22:55:08 <Cale> I'm not sure how that got sent again
23:10:54 <vincenz> Morning
23:12:19 <vincenz> Cale: nice post
23:12:29 <Cale> which one?
23:13:05 <vincenz> the comment you put on that Measure Measure Measure site
23:13:15 <vincenz> I presume there are no other Cale's
23:13:52 <Cale> hmmm...
23:14:05 <Cale> http://www.taylor.se/blog/2006/11/22/why-optimizing-without-profiling-is-inefficient/ ?
23:14:09 <lambdabot> Title: Andres&#8217; thoughts  Why optimizing without profiling is inefficient, http://tinyurl.com/y5lnwm
23:14:37 <vincenz> the one about groceries
23:14:46 <vincenz> yeah that one
23:15:06 <vincenz> Time I entered the blogosphere as well
23:16:04 <Cale> Words like blogosphere are one of the reasons that I don't feel like doing so :)
23:16:30 <Adamant> Cale++
23:17:08 <Botty> heh my sentiments exactly
23:17:10 <vincenz> added a commoent as wel
23:17:22 <vincenz> Cale: My point is, I never put anything on my blog or online
23:17:23 <MP0> @sort
23:17:23 <lambdabot> Maybe you meant: more part
23:17:31 <Botty> I've seen some good 'blogs' though.  I'd call them more very easy publishing
23:17:37 <vincenz> That's odd, I got this Sorry, but your comment has been flagged by the spam filter running on this blog: this might be an error, in which case all apologies. Your comment will be presented to the blog admin who will be able to restore it immediately.
23:17:42 <vincenz> erm, once
23:17:59 <vincenz> Cale: did you get that too?
23:18:02 <Botty> (all the good ones are just the result of people 'abusing' a blog system to post articles :) )
23:18:17 <Cale> vincenz: no
23:18:33 <vincenz> Cale: did you give an email?
23:18:48 <Cale> yeah
23:19:46 <vincenz> that might be it
23:33:06 <MP0> when I'm in ghci, why can't I  "import List" ... is there a good alternative?
23:33:45 <Korollary> do a :m + Data.List
23:35:43 <MP0> that works... why the different syntax?
23:36:17 <MP0> @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
23:36:17 <lambdabot>  Hello World!
23:36:37 <Botty> @bf  ++++++++[>+++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
23:36:38 <lambdabot>  *QXX[9[^XP
23:37:16 <Botty> wonder what the smallest bf quine is
23:37:18 <Korollary> I don't really know. It may have been what hugs initially had and people may have stuck with it.
23:37:51 <MP0> @bf
23:37:52 <lambdabot> Done.
23:38:01 <Botty> @bf ->+>+++>>+>++>+>+++>>+>++>>>+>+>+>++>+>>>>+++>+>>++>+>+++>>++>++>>+>>+>++>++>+>>>>+++>+>>>>++>++>>>>+>>++>+>+++>>>++>>++++++>>+>>++>+>>>>+++>>+++++>>+>+++>>>++>>++>>+>>++>+>+++>>>++>>+++++++++++++>>+>>++>+>+++>+>+++>>>++>>++++>>+>>++>+>>>>+++>>+++++>>>>++>>>>+>+>++>>+++>+>>>>+++>+>>>>+++>+>>>>+++>>++>++>+>+++>+>++>++>>>>>>++>+>+++>>>>>+++>>>++>+>+++>+>+>++>>>>>>++>>>+>>>++>+>>>>+++>+>>>+>>++>+>++++++++++++++++++>>>>+>+>>>+>>++>+>+
23:38:02 <lambdabot> Done.
23:38:06 <MP0> heh, a befunge interpreter
23:38:25 <Botty> brainfuck, actually
23:38:33 <MP0> ah
23:38:54 <Botty> befunge is the one on the 2d grid
23:39:10 <fik> 2d grid?
23:39:29 <Botty> ?wikipedia befunge
23:39:31 <lambdabot> No Result Found.
23:39:39 <Botty> http://en.wikipedia.org/wiki/Befunge
23:40:34 <Botty> It's rather nicer than brainfuck...
23:40:47 <Botty> no easy irc adaption though
23:41:04 <Korollary> @unlambda `r```````````.H.e.l.l.o. .w.o.r.l.di
23:41:05 <lambdabot>  Hello world
23:41:15 <Korollary> I am so happy.
23:42:21 <Lemmih> dons: Do you know how to avoid constant strings being lifted to the top-level?
23:42:30 <Lemmih> dons: (the inlining is breaking my rules)
23:44:28 <fik> Korollary, "unlambda" stands for untyped lambda calculus?
23:44:50 <bringert> dons: damn, you beat me to it.
23:45:05 * bringert was also working on a parallel quickcheck
23:46:38 <Korollary> fik: Yeah, it's one minimal untyped LC: http://en.wikipedia.org/wiki/Unlambda
23:46:54 <fik> k, thanks
23:47:22 <fik> k, very good article.
23:51:06 <dons> Lemmih: hmm. no, don't know a way
23:51:15 <dons> i seem to recall SPJ saying something about it once though
23:51:19 <dons> bringert: same idea?
23:51:31 <dons> fork n OS threads, have them pull jobs off the properties list?
23:52:07 <dons> bringert: did you get this week's HWN/pdf ?
23:52:35 <bringert> dons: yep, looks great, thanks. it's on the wall since yesterday
23:52:41 <dons> cool
23:55:57 <vincenz> dons: where does one find it
23:56:08 <dons> the pdfs?
23:56:12 <dons> in the archives/ dir of HWN
23:56:13 <dons> ?where hwn
23:56:14 <lambdabot> http://sequence.complete.org/
23:56:15 <dons> not there
23:56:32 <dons> ?where+ hwn-archives http://www.cse.unsw.edu.au/~dons/code/hwn/archives/
23:56:32 <lambdabot> Done.
23:56:53 <vincenz> aha
23:57:04 <vincenz> fancy ;0
23:57:06 <vincenz> :)
23:58:11 <dons> its designed to print nicely on a4, for handing out and posting around uni ;)
