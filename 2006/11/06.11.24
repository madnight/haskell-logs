00:07:19 <SimonRC> Ah, this compiler is a pleasure to modify.  I am quite glad it is not written in (say) Python.  The type-system and the purity requirement are doing all the work for me really.  All I have to do is think which datastructure to put stuff in and which functions need to see it, and the rest writes itself.
00:07:49 <Cale> which compiler?
00:10:40 <dons> SimonRC: yeah, you need a language with first class data types and static typing to make symbolic manipulation and structure hacking fun/easy
00:12:18 <SimonRC> Cale: Paul Callaghan's MiniJava -> C Subset compiler
00:12:40 <SimonRC> Cale: http://www.dur.ac.uk/cs.old/ug/proj06/pcc-compiler-opt.html
00:12:44 <lambdabot> Title: Compiler optimization, http://tinyurl.com/y5p4ra
00:22:53 <Botty> why is it that none of the compilers written in haskell use parsec?
00:23:41 <Lemmih> It's a bit slow.
00:23:46 <Botty> well, maybe a few use it (Henk, Mondrian, Tiger)
00:25:42 <Botty> Ah, well, the website says its designed with speed in mind, but I guess when you go combinatorial it'll still leave you behind speedwise
00:29:31 <dons> you could use the bytestring-based parsec, that'd help
00:29:44 <Botty> ooh
00:32:45 <opqdonut_> there's also the fact that the specifications of a language are usually in EBNF, so making the grammar file isn't as much added trouble
00:32:58 <Botty> true
00:33:03 <opqdonut_> instead, it's easier to be sure that the parser is correct than when coding with parsec
00:33:08 <Botty> good thing I would never reimplement a language :)
00:33:24 <opqdonut> it's fun actually
00:33:43 <opqdonut> i reimplemented a subset of scheme/lisp in c a few years back
00:33:52 <opqdonut> just very basic stuff and lambda
00:33:59 <Botty> I suppose.  I prefer to discover new territory of lang design
00:34:03 <Botty> oh, well, lisp, sure
00:34:07 <Botty> lisp is fun :)
00:34:24 <Botty> discover's not the right word
00:34:42 <dons> yeah, parsec is more useful for very hard grammars with strange forms, or experimenting
00:34:52 <Botty> mm
00:34:54 <opqdonut> yeah, and quick prototyping
00:34:57 <dons> if you have the EBNF, just dump it into happy
00:35:19 <opqdonut> dump it into happy and you're happy
00:35:28 <dons> a friend of mine wrote a GCC grammar, using a standard EBNF for C, via happy, with a backup clause for the gcc extensions, that called a parsec handler
00:35:54 <opqdonut> heheh
00:35:54 <Botty> cool
00:36:26 <dons> and since the gcc stuff was rare, it doesn't matter if its a bit slower
00:36:34 <dons> just as long as your core forms are fast
00:38:38 <Botty> probably the best thing for a quickie lang then
00:47:22 * earthy still likes Doaitse Swiestra's deterministic parser combinators
00:47:30 <earthy> plenty fast and nicely declarative
00:48:21 <MP0> I'm a newbie when it comes to Haskell, so like any Newbie, I've been trying to compile code I see on the internet. I came across this: http://web.engr.oregonstate.edu/~erwig/papers/Zurg_JFP04.pdf
00:48:23 <lambdabot> http://tinyurl.com/v5yq9
00:48:49 <dons> MP0: interesting, how'd you go?
00:49:03 <MP0> not well, when I compile it like this, I get:
00:49:04 <MP0> voyager2:~/dev/haskell/scheme pingemi$ ghc -fglasgow-exts zurg.hs
00:49:04 <MP0> zurg.hs:49:11:
00:49:05 <MP0>     No instance for (SearchProblem (Pos, [Toy]) m)
00:49:36 <MP0> I would've thought BridgePos Move would match that
00:49:49 <MP0> ie, where it says "instance SearchProblem BridgePos Move where "
00:50:32 <dons> perhaps the lesson is: don't compile random code on the internet ;) (seriously, though, being a research paper, it might use some ghc extension,s -foverlapping-instances or something? you could always mail the author (he's on the haskell lists))
00:50:42 <dons> actually, i think he's lispy's supervisor
00:53:40 <Botty> uhhhhhh somehow I managed to get admin control of ehc's svn
00:53:51 <MP0> congrats
00:54:24 <earthy> ?
00:54:40 <Botty> err nevermind
00:54:51 <Botty> just an ugly webform
00:55:07 <MP0> hmm, I tried a bunch of those extensions to no avail. I might try the recode-it-in-c maneuver.
00:55:36 <dons> MP0: or ask the author?
00:56:01 <dons> ttp://web.engr.oregonstate.edu/~erwig
00:56:45 <earthy> btw, dons, Doaitse presented your stuff to us yesterday. didn't know it was *that* cool... :)
00:58:33 <slime_mold> @pointless \a b -> fst a == fst b
00:58:34 <lambdabot> (. fst) . (==) . fst
00:59:07 <lispy> earthy: which stuff? hs-plugins?
00:59:20 <earthy> the bytestring and espicially fusion stuff
00:59:26 <lispy> ah
00:59:34 <lispy> i haven't read that paper yet
00:59:41 <earthy> do. :)
00:59:42 <lispy> i should queue it up
00:59:54 * earthy came away wild with ideas
01:00:06 <earthy> (that'll probably never see fruition, but still)
01:00:06 <dons> earthy: hehe great :)
01:00:59 <dons> feel free to talk to me or dcoutts about the ideas:esp. now dcoutts is working on fusion for his phd topic
01:01:12 <lispy> i think that is the mark of a good research paper though, it accomplishes something and inspires future work
01:01:32 * earthy was just thinking of extending to arbitrarily sized two-dimensional arrays
01:01:37 <earthy> i.e.: pictures. :)
01:02:13 <earthy> an efficient lazy library for image manipulation would really be cool. :)
01:03:10 <MP0> thanks dons, I added a main module and the thing worked beautifully. Lesson learned: don't assume the paper has all the code.
01:03:25 <lispy> > (liftM3 (\x y z -> if x then y else z)) (Just True) (Just 3) Nothing
01:03:27 <lambdabot>  Nothing
01:03:34 <lispy> oh dear, why does that return nothing?
01:05:43 <lispy> MP0: cool link
01:06:18 <lispy> i don't understand why liftM* should have to evaluate all the parameters
01:06:51 <lispy> ?type liftM (\x y z -> if x then y else z)
01:06:52 <lambdabot> forall t (m :: * -> *). (Monad m) => m Bool -> m (t -> t -> t)
01:07:25 <MP0> What I find annoying is that before seeing the solution, I could swear up and down that the problem is not solvable.
01:07:45 <MP0> Somehow I need to change my brain so that doesn't happen again for the same class of problems.
01:08:09 <lispy> MP0: that's fairly easy though, practice this example and try to break it
01:08:17 <lispy> MP0: in the process you'll improve your intuition
01:08:29 <Botty> yikes, I figured haskell lists would be stored mostly contiguously since they are strongly typed
01:08:49 <dons> earthy: 2d arrays eh? sounds do able! you might even be able to just store images in normal Lazy bytestrings, and get fusion on them for free (like dcoutts gzip library)
01:08:51 <lispy> Botty: what is the connection between data storage and types?
01:08:56 <araujo> morning
01:09:10 <dons> Botty: laziness...
01:09:11 <lispy> araujo: hiyo
01:09:13 <Botty> types have a size
01:09:24 <Botty> dons - oh yeah i forgot about that little thing ;p
01:09:33 <dons> Botty: for strict lists, of certain kinds, ghc does unpack them. (i.e. string literals)
01:09:40 <Botty> oh, good
01:09:51 * Botty is just reading your paper :)
01:10:07 <earthy> dons: exactly
01:10:11 <earthy> sounds very doable
01:10:37 <Korollary> also sharing. contiguous sublists are hard to share.
01:10:37 <dons> earthy: the ndp array library (soon to be released) almost certainly can handle 2d arrays, let me find a ref.
01:10:47 <araujo> hello lispy
01:11:38 <lispy> ?type lifM2 (liftM (\x y z -> if x then y else z))
01:11:40 <lambdabot> Not in scope: `lifM2'
01:11:45 <lispy> ?type liftM2 (liftM (\x y z -> if x then y else z))
01:11:46 <lambdabot> forall a2 t (m :: * -> *). (Monad m) => m (a2 -> Bool) -> m a2 -> m (t -> t -> t)
01:12:03 <lispy> darn :)
01:12:13 <Botty> Korollary - value sharing? I suppose so
01:12:25 <dons> earthy: this array lib: http://darcs.haskell.org/packages/ndp/Data/Array/Parallel/
01:12:28 <lambdabot> Title: Index of /packages/ndp/Data/Array/Parallel, http://tinyurl.com/yk3g9n
01:12:47 <lispy> what does ndp stand for?
01:13:01 <dons> nested data parallelism
01:13:15 <dons> so non-1d data
01:13:25 <earthy> looks sweet
01:13:44 <earthy> but now I have to finish some Dazzle code within the next 45 mins
01:13:52 <dons> go earthy, go!
01:13:55 <earthy> ;)
01:14:15 <dons> lispy: http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
01:14:17 <lambdabot> Title: GHC/Data Parallel Haskell - HaskellWiki, http://tinyurl.com/y77oeb
01:16:08 <lispy> heh, taken out of context this subtitle is funny, "Speed with less convenience: package ndp"
01:18:29 <MP0> That makes me want to say something like Functional: Languages where speed is an inconvenient detail.
01:19:16 <lispy> s/Functional: Languages/Ruby:/
01:19:33 <MP0> lol
01:19:48 <MP0> that makes it work well
01:19:57 <dons> heh
01:20:21 <Korollary> speed is really the property of the implementation on a platform, not necessarily the language spec.
01:20:27 <nikita2222> haskell on rails
01:20:34 <lispy> hor?
01:20:39 <lispy> Korollary: i know
01:20:41 <MP0> Functional: Language where speed is an implementation detail
01:20:52 <lispy> Korollary: otoh, have you seen a fast ruby implementation yet?
01:21:12 <Korollary> Is there another ruby implementation yet?
01:21:16 <nikita2222> perl is faster than ruby
01:21:26 <lispy> Korollary: sure, people make toy ruby implementations all the time
01:21:34 <lispy> ?google haskell rtype
01:21:37 <lambdabot> http://raa.ruby-lang.org/cat.rhtml?category_major=Application;category_minor=Interpreter
01:21:38 <nikita2222> but ruby is being ported to the java VM so it may run faster on bytecode
01:21:43 <Korollary> well I certainly didnt mean toy implementations
01:22:11 <ValarQ> nikita2222: like python?
01:22:16 <lispy> Korollary: just an example, my point is that, _right now_ we don't have a fast ruby implementation
01:23:20 * dons is glad to have a language where the compilation strategy was sorted out by lennart, spj and others
01:23:57 <lispy> dons: yeah, they did a fine job, and yet it could be faster!
01:24:01 <lispy> dons: as shown by jhc
01:25:57 <dons> the compiler writer employment theorem keeps us all occupied ;)
01:26:18 <lispy> eh?
01:26:45 <MP0> If it were possible to make a perfect optimizer, no one would need compiler writers
01:26:58 <lispy> does it go something like, if you can write a high performance/quality compiler your employer will keep you busy with interesting work?
01:27:25 <dons> http://en.wikipedia.org/wiki/Full_employment_theorem
01:27:30 <lambdabot> http://tinyurl.com/yhke6e
01:27:33 <dons> not quite. if only. :)
01:28:22 <Korollary> I was just going to say that it sounded like Goedel's theorem's consequence.
01:28:51 <lispy> dons: neat
01:29:36 <dons> there's some kind of full employment theorm for wiki authors i'm sure
01:29:43 <MP0> of course there's a logic error in there: Just because no one would need compiler writers if a perfect optimizer existed doesn't mean the lack of a perfect optimizer requires compiler writers to exist.
01:29:45 <lispy> heh
01:31:20 <lispy> heh
01:31:28 <lispy> this spam contains the line, "jrvch.$IMAGE_EXTENSION$"
01:31:45 <lispy> someone's regular expression didn't math :)
01:31:48 <lispy> er match
01:31:50 <dons> also combative tasks such as posting to reddit may have full employment theorems
01:31:57 <Botty> huh, from my perspective the point of compiler writers is writing cool languages/language features, not optimization
01:31:59 <dons> lispy: hehe
01:32:05 <Korollary> It's not about optimizations
01:32:42 <dons> all you have to do is post one link about ever compile written by the fully employed compiler writers
01:32:53 <dons> s/every compiler/
01:33:41 <MP0> Every programmer is a compiler writer. It's just that some curry one less time than the others.
01:34:17 <MP0> I'm not sure if that joke came out the way I wanted it to.
01:35:10 <kfish> mmm ... curry
01:35:23 <MP0> I'm all out, finished it for lunch.
01:35:49 <araujo> hahaha
01:35:59 <araujo> MP0, you are from spain?
01:36:02 <araujo> hahaha
01:36:18 <MP0> ... maybe I made an unintentional foreign language joke? I'm afraid not.
01:36:25 <araujo> yeah, hahahaha
01:36:36 <MP0> You'll have to explain it to me.
01:36:38 <Botty> hmm, File IO could be really good with ByteStrings - read the available buffer into a strict chunk
01:36:53 <araujo> MP0, hahaha, i can't explain it
01:36:59 <araujo> i just can laugh
01:37:29 <araujo> dons, add that for the quote of the week
01:37:32 <araujo> :-)
01:37:53 <lispy> Botty: certainly if you have specific space requirements that's good, but also reading into a lazy byte string gives very good performance
01:38:21 <earthy> the proof of the pudding is in the eating
01:38:47 <lispy> Botty: i have done the reverse (writing into lazy byte string for output) and it improved performance by an order of magnitude of memory and a similar factor on run time (although I couldn't measure that one because I had been running out of heap)
01:39:16 <araujo> MP0, you can stop by #haskell.es if you are spanish speaker too :-)
01:39:42 <MP0> No hablo espanol
01:40:33 <araujo> hah ok
01:40:42 <MP0> <--- stupid American
01:40:45 <araujo> hahaha
01:40:51 * lispy only knows enough espanol to ask a girl's name and say he has a date :)
01:41:11 <MP0> What do you call a person who speaks three languages?
01:41:18 <araujo> MP0, i don't get how did you come with that joke then ....
01:41:20 <lispy> MP0: indian?
01:41:25 <araujo> :-P
01:42:36 <earthy> okay, that at least *seems* to work
01:43:00 <MP0> I was trying to make a joke on the fact that every program in the functional world is fcompiler(source program, finput) => foutput ... programmers curry that using a compiler to fprogram(finput) => foutput
01:43:05 <earthy> Haskell, where you can do an hour's work in 30 minutes. :)
01:43:31 <MP0> and in retrospect it's kinda lame... I have no clue what you're seeing in it.
01:43:34 <lispy> earthy: yeah, at that rate expect to die "young" ;)
01:44:26 * earthy grinz
01:44:43 <earthy> unfortunately I have *no* clue as to what I just coded makes any sense. :)
01:44:55 <earthy> that is, algorithmically
01:45:00 <Botty> earthy - i wish.  since I'm still fairly noob, it takes like 6 hours to do 1 hours work, but the result is much more elegant and generally delightful
01:45:17 <araujo> MP0, it's because we got a spanish word 'currar' ... i don't think there exist an english translation for it, but if you replace it with 'curry' (which i thought you intended to do) , is funny :-)
01:45:23 <earthy> Botty: ah. yes, you need to do the brain reshuffle first.
01:45:46 <earthy> that is a one time cost, however, and will therefore be amortized over all subsequent programs you write
01:45:55 <MP0> currar: "to work" ?
01:45:56 <lispy> ?bable es en currar
01:45:58 <lambdabot>  to currar
01:46:01 <lispy> lol
01:46:05 <araujo> MP0, yeah
01:46:14 <Botty> I've got it fairly reshuffled, I can read functional fine, and write it, just when I write in a language that allows a closer approximation of perfection I have to pursue it more
01:46:26 <MP0> ah, now that's funny!
01:46:31 <araujo> :-)
01:47:00 <earthy> looks like it does make sense. *good*.
01:52:53 <MP0> interesting... getting args requires importing System.Environment which blows up your program a few hundred k
01:53:16 <MP0> and all I do is getArgs
01:53:23 * earthy nods
01:53:41 <earthy> you need quite a bit of posix glue to do getArgs
01:54:28 <MP0> well, lets see how much it should cost in terms of space...
01:55:30 <lispy> MP0: does it help if you only import getArgs?  Maybe you recover a lot of space if you strip the binary?
01:56:39 <MP0> a C implementation of testargs is 16 kb
01:57:08 <MP0> lets test out only getting getArgs
01:58:49 <MP0> importing only getArgs makes no difference
01:58:54 <MP0> lets try strip
01:59:48 <MP0> strip is pretty nice, lots of stuff goes bye bye... now to test it against a stripped program that doesn't import getArgs
02:00:21 <MP0> the difference now seems much smaller... about 100k
02:01:41 <dons> maybe you don't have splitobjs?
02:01:52 <MP0> what's that?
02:01:54 <earthy> sounds like it
02:02:38 <dons> the libraries on most systems are compiled into per-top-level-decl object chunks: splitobjs, so when statically linking the linker can import a smaller chunk of the library from which you load your function == smaller binaries
02:03:05 <dons> now, if you're getArgs is blowing things up by > few k, then sounds like your libs weren't compiled with split objs
02:04:26 <MP0> so basically, blame the ghc maintainer for my system?
02:04:33 <MP0> *ghc package maintainer
02:04:44 <dons> yes, possibly.
02:04:47 <dons> what system?
02:04:52 <MP0> OS X
02:04:55 <MP0> intel
02:05:11 <dons> could well be that split objs doesn't work on the mac. but dynamically linked libraries does!
02:05:22 <dons> I *think* its just -dynamic you add, for a 10k hello world
02:05:28 <dons> check the wiki (there's a page on it)
02:05:37 <dons> dynamically linked rts and libs is a Mac OSX only feature, atm
02:06:12 <MP0> ghc -dynamic -o test test.hs
02:06:13 <MP0> collect2: ld returned 1 exit status
02:06:43 <MP0> | /usr/bin/ld: can't locate file for: -lHShaskell98_dyn
02:06:54 <MP0> oh well, I guess that isn't set up on my system
02:06:58 <MP0> maybe I should track that down
02:07:00 <dons> seems like so
02:07:18 <MP0> might only be a PPC feature
02:07:23 <dons> the -dynamic stuff is documented somewhere , but i don't have the link handy
02:08:53 <Botty> ?google ghc dynamic flag
02:08:55 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/DynamicLinking
02:08:56 <lambdabot> Title: DynamicLinking - GHC - Trac
02:09:30 <Botty> looks like its ppc only
02:11:42 <Si> Hi haskellers, did anyone ever get round to doing a Software Project management system with darcs support?
02:14:00 <vincenz> Anyone use google calendar?
02:14:15 <lispy> Si: like trac+darcs?
02:14:18 <lispy> vincenz: i do
02:15:00 <MP0> Is lambdabot on AIM?
02:15:08 <Si> lispy: Yeah, I guess
02:15:31 <lispy> Si: i ask because someone did do an integration between those two
02:16:05 <lispy> Si: other than that, i don't really know of anything
02:16:05 <vincenz> lispy: I cancelled an event from gmail cause it was mucking it up, now I lost it... it shows as cancelled in my gmail.. I want to uncancel it
02:16:05 <Si> ok, but nothing official/affiliated with haskell.org?
02:16:24 <lispy> vincenz: i haven't tried that :(
02:16:53 <lispy> Si: why does it have to be affiliated with haskell.org?
02:17:05 <Si> well it doesn't, I was just wondering
02:17:05 <lispy> Si: and what's unofficial about darcs + trac? ;)
02:17:47 <Si> because people were talking about it at one point, IIRC
02:19:01 <lispy> Si: maybe ask in #darcs or on the darcs mailing list, check the darcs wiki...
02:19:14 <Si> oh of course
02:28:30 <Renkin> Of what shape does a string need to be in order to be able to read it as a list?
02:28:37 <Renkin> read "2"
02:28:42 <Renkin> > read "2"
02:28:43 <lambdabot>  Add a type signature
02:28:54 <int-e> > read "[2,3]" :: [Int]
02:28:55 <Renkin> > read "2" :: Int
02:28:55 <lambdabot>  [2,3]
02:28:56 <lambdabot>  2
02:29:03 <Renkin> Ok, thanks
02:29:16 <int-e> > read "\"abc\"" :: [Char] -- special case
02:29:18 <lambdabot>  "abc"
02:29:43 <int-e> > read "['a','b']" :: [Char] -- hmm
02:29:45 <lambdabot>  "ab"
02:30:17 <Renkin> > read "\"abc\"" :: String
02:30:19 <lambdabot>  "abc"
02:30:24 <Renkin> alright, cool
02:30:31 <int-e> String and [Char] are the same type
02:30:36 <Renkin> Yeah
02:30:49 <Renkin> It's just a Type definition right?
02:31:03 <int-e> yup
02:31:28 <Renkin> It's pretty cool that String is just a list of Chars and it's still such a powerful datatype :)
02:31:42 <Renkin> Because list is powerful in its own
02:34:36 <MP0> how do you download an install extra modules, like the network module? I'm trying to build lamdbabot however setup.hs says it's missing the network-any dependency.
02:37:08 <malcolm_> ping dons
02:56:46 <kzm> The banana-analogy (bananalogy?) of Simon PJ is great!  "Haskell: building a better banana"
02:57:35 <vincenz> ban-analogy?
03:02:25 <osfameron> where's that?
03:45:00 <michel_> hello
03:45:10 <AtnNn> hi
03:45:10 <michel_> I need some help on a simple question
03:45:16 <michel_> can anyone help me?
03:45:19 <AtnNn> sure
03:46:02 <michel_> I have a function who has tys tipe: f :: IO [Integer]
03:46:32 <michel_> this function read n numbers on the console, then return a list whith this values, ok?
03:46:39 <AtnNn> ok
03:47:21 <michel_> I need this list on main, because I need to calculate the sum, product and factorial of all the numbers
03:47:31 <michel_> so I wrote the simple function soma:
03:47:44 <michel_> soma n = foldr (+) 0 n
03:48:10 <michel_> but when I try to use: soma (f)
03:48:25 <AtnNn> ah, yes
03:48:31 <michel_> ghci complains that soma receive [Integer], while f returns IO [Integer]
03:48:46 <michel_> if it was C, I just write soma ([Integer]) pegaNumero
03:48:48 <michel_> :)
03:48:55 <michel_> but ins haskell I don't know what to do
03:48:57 <AtnNn> you need to use the list of integers inside the IO monad, this isn't C ;)
03:49:02 <Lemmih> michel_: do lst <- f; return (soma lst)
03:49:17 <Lemmih> michel_: Or: fmap soma f
03:49:56 <michel_> you mean I write a third function that make de conversion?
03:50:39 <AtnNn> main is of type IO (), you can do that in main
03:53:50 <michel_> in main I did:
03:53:59 <michel_> tmp <- f
03:54:03 <michel_> return (soma tmp)
03:54:07 <michel_> it compiles
03:54:21 <michel_> but how do I get the value of soma tmp?
03:54:39 <AtnNn> use print instead of return
03:56:17 <michel_> works :
03:56:19 <michel_> :)
03:56:25 <michel_> but my last question :)
03:56:39 <michel_> I need to print: The sum of the list is X
03:56:45 <michel_> i try:
03:57:04 <michel_> print "The sum of the list is" ++ (soma f)
03:57:09 <michel_> don't works
03:57:27 <AtnNn> yeah, (soma f) is an Integer, not a string
03:57:36 <AtnNn> you can eitherconvert it to a string using show
03:57:58 <AtnNn> and use putStr
03:58:27 <Lemmih> putStrLn ("The sum ..." ++ show (soma f))
03:58:42 <AtnNn> putStr "The sum is "; print (soma f)
03:58:50 <Lemmih> Or: putStrLn $ "The sum ..." ++ show (soma f)
03:58:57 <michel_> works
03:59:03 <michel_> haskell is really nice
03:59:17 <michel_> but I'm used to program in C
03:59:28 <michel_> It's hard :)
03:59:32 <michel_> thanks a lot
03:59:37 <michel_> you're very nice
04:00:03 <AtnNn> any time
04:00:05 <kzm> osfameron, it was posted to the list.  Here: http://channel9.msdn.com/Showpost.aspx?postid=231495
04:00:09 <lambdabot> Title: Programming in the Age of Concurrency: Software Transactional Memory, http://tinyurl.com/ylylaa
04:01:06 <michel_> bye AthNn
04:01:17 <AtnNn> I have a simple question to. When I have an instance of a class, my code compiles, when i add a second instance, ghc complains that they overlap, but when i remove the first one ghc says there is no match. how is this possible?
04:03:00 <Lemmih> They may overlap without being interchangeable, I think.
04:03:22 <TomMD> ?paste
04:03:22 <Bourbaki> moin
04:03:22 <lambdabot> http://paste.lisp.org/new/haskell
04:03:31 <Bourbaki> does anyone of you know this thingy here?
04:03:31 <Bourbaki> http://kahu.zoot.net.nz/
04:03:32 <lambdabot> Title: Welcome to Kahu Research
04:05:15 <osfameron> kzm: ah, thanks :-)  I have that bookmarked to watch when I get a chance
04:05:36 <lisppaste2> AtnNn pasted "overlapping instances" at http://paste.lisp.org/display/30612
04:05:52 <AtnNn> lemmih: interchangeable?
04:06:03 <twodogsandacat> hi there.
04:06:31 <AtnNn> hello
04:06:41 <osfameron> cool! can download it too
04:07:06 <osfameron> though the colours are rather, er, psychedelic
04:07:13 <russo> does anyone here no a pastebin or something similar where one can interactively draw and let others see it? or should one just paint and then imageshack? i was just curious if there was something better.
04:09:34 <psnl> I love talking to my supervisor
04:09:49 <vincenz> psnl: oh?
04:09:52 <lisppaste2> TomMD pasted "Problem with classes" at http://paste.lisp.org/display/30613
04:10:19 <TomMD> As you can see, I am screwing up class instances some how.  Anyone have a second to help?
04:11:47 <TomMD> AFK for a minute, I'll see your comments in a little
04:12:30 <twodogsandacat> i've read that lists can be used to backtrack over the problem space, prolog-like. Anyone can point me to a tutorial with specifics on that?
04:12:46 <vincenz> TomMD: ping
04:12:52 <vincenz> TomMD: I can easily help
04:14:28 <TomMD> vincenz: back, I'd appriciate any assistance.
04:14:54 <Lemmih> AtnNn: Haskell doesn't consider the constrains of the instances. Both the instances match but only the first is usable.
04:14:59 <vincenz> TomMD: Ok, easy :)
04:15:10 <vincenz> TomMD: I take it that "Repo.update" is meant to imply some other update function, no the one in that class?
04:15:14 <psnl> vincenz: I quote "you can just add a bit to ghc to make that known" Me: "Isn;t that a new language primitive?" Him: "well yes"
04:15:38 <vincenz> psnl: ah, he beat the obvious into you?
04:15:40 <TomMD> vincenz: Oops, no - it is for THIS update call RIGHT HERE.
04:15:56 <vincenz> TomMD: Repo.update ... what is that supposed to mean?  you know that there is no module access
04:16:12 <vincenz> Repo.update actually means: Repo . update
04:16:22 <vincenz> aka, call update and then call Repo dataconstructor with the result
04:16:29 <psnl> vincenz: I think I lack the fu to start adding new bits to haskell
04:16:37 <TomMD> Vincens: Problem with pasting a fragment is all, Repo is this module - I just was being explicit - deleting the "Repo" should be the same, right?
04:16:38 <AtnNn> lemmih: is there any way to get around that restriction?
04:16:46 <vincenz> TomMD: Yes
04:16:54 <vincenz> TomMD: But that is incorrect usage
04:17:04 <vincenz> TomMD: In fact it means not what you mean
04:17:19 <vincenz> "X.foo" = \v -> X ( foo v0
04:17:22 <vincenz> "X.foo" = \v -> X ( foo v)
04:17:26 <vincenz> not: call foo from module X
04:17:49 <vincenz> psnl: What does he want you to add to ghc?
04:18:39 <TomMD> Vincenz: So I've changed it to just: update es''' es'
04:18:48 <vincenz> You man update es''' e'?
04:18:52 <Lemmih> AtnNn: Not to my knowledge.
04:18:54 <vincenz> Btw, you're missing code, so it's hard to tell what is what
04:18:58 <TomMD> But it makes no difference - the error is still
04:19:27 <psnl> vincenz: having just looked, he isn't the first to suggest adding it. Its myThreadID
04:19:43 <vincenz> TomMD: what is MainAddress? MainAddress = HostAddress?
04:19:50 <TomMD> Yes, sorry
04:20:48 <vincenz> TomMD: btw, this is cleaner
04:20:48 <vincenz>         where (TSet es'')  = update (TSet es) e'
04:21:33 <vincenz> do you have a full source code sample?
04:21:35 <vincenz> It's hard to tell like this
04:21:46 <vincenz> like a compileable piece?
04:21:49 <TomMD> Yep, just a sec
04:22:25 <vincenz> ah!
04:22:27 <vincenz> no I know
04:22:29 <vincenz> :)
04:22:35 <vincenz> it's quite clear :)
04:22:43 <vincenz> I checked your class-definition
04:22:49 <vincenz> You use things which are slightly illegal
04:22:59 <vincenz> except with GHC extensions which makes it less decideable
04:23:07 <TomMD> Damn, that has happened before with some basic monads
04:23:13 <vincenz> TomMD: the problem is... the second parameter MainAddress is not used ANYWHERE in update
04:23:17 <vincenz> so it doesn't know which instance to infer
04:23:25 <vincenz> so it has to generalize to a variable 'k'
04:23:38 <vincenz> You could doe something like
04:23:45 <TomMD> vincenz: But I don't want to use MainAddress anywhere in update - that is ment for other functions.
04:23:51 <vincenz> class (Ord k) => Database a k e | a->kwhere
04:23:54 <vincenz> class (Ord k) => Database a k e | a -> k where
04:23:57 <vincenz> use that in your def
04:24:35 <vincenz> class (Ord k) => Database a k e | a -> k, a -> e where
04:24:36 <vincenz> in fact
04:24:37 <vincenz> and!
04:24:39 <vincenz> Maybe is meaningless
04:24:42 <vincenz> you want to return a Maybe e?
04:25:00 <vincenz> since I don't have a compileable code, it's hard to tell if that will fix all bugs
04:25:46 <lisppaste2> vincenz annotated #30613 with "use fundeps" at http://paste.lisp.org/display/30613#1
04:26:00 <twodogsandacat> ?where backtracking
04:26:01 <lambdabot> I know nothing about backtracking.
04:26:04 <vincenz> of course with a space between e and where :)
04:26:32 <TomMD> Vincenz: I don't have compilable code either :-).  I do want to return a "Maybe e".  And now I run into the same type of issue, but this time it is the second "member" instance and the lack of an "e"
04:27:07 <vincenz> TomMD: did use use -both- fundeps?
04:27:10 <vincenz> a -> k, a -> e
04:27:37 <TomMD> ?where fundeps
04:27:38 <lambdabot> I know nothing about fundeps.
04:27:46 <vincenz> not sure if it's called fundeps
04:27:48 <vincenz> aasically
04:27:52 <vincenz> class ... | x -> y
04:28:00 <vincenz> look at the code that I pasted
04:28:01 <vincenz> use that
04:28:07 <vincenz> (and add a space in "ewhere")
04:28:11 <TomMD> I'm too new, I can't read that and have it make sense.
04:28:27 <osfameron> right, Windows Media Player sees the STM talk as a psychedelic blur... oh well, maybe it'll work better on Linux :-)
04:29:12 <vincenz> TomMD: just use it :)
04:30:12 <TomMD> Vincenz, did do, but now it is still generalizing 'e' at member.  Do I need to say e is a type class, like with (Ord k) => Database ...
04:30:37 <vincenz> TomMD: you added -both-?
04:30:58 <vincenz> clas
04:31:01 <vincenz> class (Ord k) => Database a k e | a -> k, a -> e where
04:32:05 <lisppaste2> TomMD annotated #30613 with "New code" at http://paste.lisp.org/display/30613#2
04:32:20 <TomMD> Vincenz: That is what I have
04:32:49 <vincenz> TomMD: stop qualifying methods
04:32:53 <vincenz> X.something means nothing
04:33:01 <vincenz> it means apply the data-constructor after apply function something
04:34:11 <TomMD> vincenz: Roger that, I'll just hide the Prelude lookup.
04:35:01 <vincenz> works fine here
04:35:57 <vincenz>     member k (TSet (e:es)) = if k == (t_dest_addr e) then True else member k (TSe es)
04:36:03 <vincenz> actually, add the TSet here at the end
04:36:13 <vincenz> now it compiles
04:36:26 <lisppaste2> vincenz annotated #30613 with "works" at http://paste.lisp.org/display/30613#3
04:38:14 <TomMD> Ok... odd error message when that TSet is missing.   Thank you very much Vincenz.
04:39:22 <vincenz> vincenz++ :)
04:39:23 <TomMD> When that last "TSet" is missing, is that error message a ghc bug?  It seems like it shouldn't say that.
04:39:46 <vincenz> TomMD: no the error is correct
04:39:47 <vincenz>     Probable fix:
04:39:47 <vincenz>       add an instance declaration for (Database [TopologyTuple] HostAddress e)
04:39:54 <vincenz> it asks for a [TopologyTuple] as list
04:40:08 <vincenz> and some sort of e that belongs to it, but obviously it can't know that
04:40:16 <kzm> osfameron, (g)mplayer with w32codecs works for me.
04:40:31 <TomMD> Ok, I see.
04:40:32 <kzm> osfameron, if you get entirely stuck, I can try to transcode it?
04:40:54 <TomMD> Have a good time everyone, I should start getting ready for work.
04:41:06 * vincenz wants karma!
04:45:05 <dcoutts> http://haskell.org/gtk2hs/docs/tutorial/glade/
04:45:08 <lambdabot> Title: Gtk2Hs ¬ª Glade Tutorial, http://tinyurl.com/y8kq2f
04:45:33 <dcoutts> see the first addition to the Gtk2Hs tutorial collection ^^
04:45:46 <dcoutts> it's not yet linked or approved from the original authors
04:45:52 <dcoutts> this is a sneak peek
05:25:46 <osfameron> kzm: oh, yeah.  Thanks, I'll try on home machine over the weekend and if it doesn't work I have ffmpeg on one of the work boxes.
05:42:04 <unclear> @source transpose
05:42:05 <lambdabot> transpose not available
05:42:13 <unclear> @source Data.List
05:42:14 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
05:47:11 <dons> ?users
05:47:12 <lambdabot> Maximum users seen in #haskell: 276, currently: 252 (91.3%), active: 20 (7.9%)
05:53:05 <norpan> how active is active?
05:53:20 <vincenz> dons: ping
05:53:26 <vincenz> dons: how do you call it when you do
05:53:40 <vincenz> (\x -> ... x ...) (\y -> ...) -> ... (\y -> ...) ...
05:53:44 <vincenz> (\x -> ... x ...) (\y -> ...) => ... (\y -> ...) ...
05:53:57 <vincenz> alpha, beta or eta-reduce?
05:54:02 * vincenz isn't familiar with the linguistics
05:54:52 <opqdonut> vincenz: look at the wikipedia article on lambda calculus
05:54:57 <vincenz> opqdonut: thx
05:55:06 <vincenz> good idea :)
05:55:18 <opqdonut> np, rtf'ing is a good idea before asking :)
05:55:31 <vincenz> beta-reduction :)
05:55:45 <vincenz> opqdonut: just didn't know wher eto look ;)
05:55:58 <opqdonut> np
05:57:33 <vincenz> Anyways, nearly done doing something, I'd appreciate feedback once it's written :)
05:57:38 <vincenz> (though it is scheme o.O)
06:20:19 * malcolm_ wonders what dons thought of his fps patches
06:24:13 * mux wonders what happened to those lambdabot patches he sent to dons ages ago :-)
06:37:51 <dons> malcolm_: looks o
06:38:05 <dons> k. i'll merge them in the morning (got caught up on the QC stuff)
06:38:16 <dons> mux, should be in lambdabot, iirc? (figlet, yeah?)
06:39:04 <malcolm_> dons: OK, great.  I thought maybe you disliked some of the grungy stuff I needed to do to workaround bugs in nhc98
06:40:48 <dons> oh, its ok. i'm want to make things work on nhc98 too :) i didn't see anything too weird
06:40:56 <dons> ?time dons
06:40:59 <lambdabot> Local time for dons is Sat Nov 25 01:37:45 2006
06:41:01 <dons> should get some sleep :)
06:41:16 <malcolm_> sweet haskell dreams
06:41:46 <dons> hopefully not the dreams where the types never check
06:42:26 <dons> or where ghc says: TELL SIMON: panic!
06:42:40 * dons wonders if that msg is still in the compiler...
06:43:15 <malcolm_> @ghc
06:43:16 <lambdabot>  Can't represent a guarded lambda in Template Haskell
06:44:13 <astrolabe> I see there is a wikipedia article about SPJ.  Someone should add the photograph of him trying Shapr's unicycle.
06:44:15 <dons> oh, I still see: pprTrace "TELL SIMON: evalStrictness" (ppr demand_info $$ ppr val)
06:44:34 <dons> prizes for anyone who triggers that in lambdabot :)
06:44:39 <dons> astrolabe: that's a nice idea.
06:45:07 <mux> dons: yeah, but there were subsequent patches that are still in my darcs repo only
06:45:18 <mux> (now maybe it's only my fault and I somehow forgot to send those :-P)
07:02:46 <CosmicRay> does josef svenningsson ever hang out in here?
07:04:52 <norpan> CosmicRay: sometimes
07:05:07 <norpan> you afraid he is going to catch you asking about homework assignments? :)
07:05:40 <CosmicRay> heh, no ;-)  He just left a comment on my blog saying that he likes my MissingH library but thinks it could be organized beter
07:05:48 <CosmicRay> and I wanted to see if he had some more specific ideas
07:06:00 <CosmicRay> because I think it could be organized better as well, but haven't yet been able to work out how to do it.
07:06:16 <chr1s> Hi all!
07:06:51 <chr1s> Anyone here who knows some stuff about the haskell98-report?
07:07:02 <norpan> we all probably know some stuff
07:07:15 <chr1s> ok
07:07:25 <CosmicRay> whoa, a haskell to javascript converter
07:07:31 <chr1s> well, there's a syntax rule like this:
07:07:38 <chr1s> CosmicRay: no :(
07:07:55 <chr1s> btype -> [btype] atype
07:08:20 <chr1s> is there a difference between that and btype -> (atype)*
07:08:39 <norpan> btype -> (atype)+ in that case
07:08:52 <norpan> and if there is no other production for btype then there is no difference
07:08:59 <chr1s> yes
07:09:04 <ibid> does the report use Kleene star/plus?
07:09:09 <norpan> i don't know
07:09:12 <chr1s> norpan: there is no other rule
07:09:24 <chr1s> ibid: I don't think so
07:09:27 <ibid> yeah, A -> ; A -> A B is the standard encoding of a list with no separators
07:09:32 <chr1s> but I'm writing a simple parser with ANTLR
07:09:35 <shapr> CosmicRay: Hey, I'm using your simple ipv6 for debian, and sometimes I get "Destination unreachable: Address unreachable"
07:09:55 <chr1s> which doesn't handle left-recursion :(
07:09:58 <ibid> hmm, that's not right
07:10:03 <shapr> CosmicRay: I'm not sure if that's because I'm using shorewall, or if it's because there aren't any v6 to v4 routers available.. any ideas?
07:10:08 <ibid> A -> B ; A -> A B in this case
07:10:26 <CosmicRay> shapr: hmm, are you able to ping the gateway address?  and when it happens, does it happen for all ipv6 hosts or just some?
07:10:28 <ibid> chr1s: you can left-factor it, or use a plus, yes
07:10:52 <ibid> chr1s: A -> B A' ; A' -> ; A' -> A' B iirc
07:11:08 <CosmicRay> I actually don't have ipv6 working right now, due to not having my usual firewall at home (because of our temporary arrangement)
07:11:24 <ibid> of course, if you do have the Kleene operators available, left-factoring is not a good idea
07:11:25 <shapr> CosmicRay: You mean, can I ping ::192.88.99.1 right?
07:11:41 <chr1s> ibid: exactly
07:11:50 <CosmicRay> shapr: that sound sright, nes
07:12:07 <chr1s> I left-factored it but realized afterwards that I could just use the +
07:12:07 <CosmicRay> it's also possible that your isp filters
07:12:08 <ibid> chr1s: but yeah, A -> [A] B is A -> B+
07:12:24 <shapr> I can't ping6 ::192.88.199.1, I address unreachable. But it works sometimes, which makes me wonder if it's my shorewall config.
07:12:31 <ibid> (given no other productions for A)
07:12:45 <CosmicRay> well, it *could* be shorewall, but if it were, I'd normally expect it to either always work or never work.
07:12:53 <CosmicRay> being intermittent is weird.
07:12:56 <chr1s> ibid: thanks!
07:13:07 <CosmicRay> now that is a special address, what do they call it?  anycast, I think.
07:13:09 <shapr> CosmicRay: It seems to depend on whether I've restarted shorewall after I ran ifup sit1
07:13:14 <CosmicRay> so it could be that your isp's routers suxx0rs
07:13:19 <CosmicRay> ah ha.
07:13:27 <CosmicRay> I saw a similar problem recently with openvpn and shorewall
07:13:38 <CosmicRay> I believe it went away after I dist-upgraded my firewall
07:13:41 <CosmicRay> (it's running sid)
07:13:47 <shapr> Shorewall is nice, but it gets in my way a lot...
07:13:52 <CosmicRay> you might try the latest shorewall
07:14:14 <CosmicRay> I've generally found it to be an "install and forget it" sort of thing, although the upgrades are not as smooth as I'd like.
07:15:26 <ibid> chr1s: btw, a better prelude to the question would have been "anybody know about grammars" or sth ;) (or no prelude at all. just ask it, don't ask to ask)
07:15:43 <shapr> @timein stockholm
07:15:45 <lambdabot> Local time for stockholm is Fri Nov 24 16:12:34 2006
07:16:03 * shapr blinks
07:16:04 <CosmicRay> nifty
07:16:08 <CosmicRay> @timein chicago
07:16:22 <ibid> @timein jyv√§skyl√§
07:16:31 <ibid> @timein helsinki
07:16:32 <shapr> I think it's using /ctcp time
07:16:33 <chr1s> ibid: okay, I'll do that the next time!
07:16:37 <CosmicRay> shapr: does it only work for stockholm? ;-)
07:16:48 <shapr> Well, if you look at /whois stockholm you'll what happened :-)
07:16:54 <CosmicRay> ah!
07:17:00 <ibid> @timein ibid
07:17:03 <CosmicRay> shapr: tricky
07:17:03 <lambdabot> Local time for ibid is Fri Nov 24 17:13:51 2006
07:17:09 <ibid> but ibid is not a place!
07:17:11 <CosmicRay> @timein cosmicray
07:17:27 <CosmicRay> thought so.  I'm behind a NAT.
07:17:30 <ibid> didn't it used to be @localtime or sth
07:17:35 <shapr> I think it's meant to question a user's irc client for their localtime.
07:17:37 <Syzygy-> @timein Syzygy-
07:17:40 <lambdabot> Local time for Syzygy- is Fri Nov 24 16:14:27 2006
07:17:49 <shapr> Yeah, I think the spell checker is 'fixing' it.
07:18:11 <shapr> Anyway, I really got onto #haskell to learn more about Cabal...
07:18:53 <Syzygy-> @source lambdabot
07:18:54 <lambdabot> lambdabot not available
07:18:55 <shapr> Now that I'm doing more commercial Haskell hacking in emacs, I want more integration.
07:18:57 <shapr> @where lambdabot
07:18:58 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
07:19:04 <shapr> @where shapr
07:19:05 <lambdabot> http://www.ScannedInAvian.com/hope
07:19:07 <shapr> !
07:19:15 <ibid> @where ibid
07:19:15 <lambdabot> I know nothing about ibid.
07:19:22 <ibid> pah
07:19:48 <shapr> Does anyone know of a way to integrate Haddock and TAGS files?
07:19:57 <astrolabe> @help where+
07:19:57 <lambdabot> where+ <key> <elem>. Define an association
07:19:58 <shapr> @where+ ibid http://antti-juhani.kaijanaho.fi/newblog
07:19:58 <lambdabot> Done.
07:20:03 <shapr> @where astrolabe
07:20:03 <lambdabot> http://www.mhs.ox.ac.uk/epact/picturel.asp?record=95&enumber=40428&level=overview&sort=InstrumentTypeWithoutMarkup&searchtext=
07:20:22 <Syzygy-> I wonder I wonder how difficult it could do to extend the localtime plugin (or write a new plugin) that takes a city/timezone (among the "normal" ones) and returns current time there...
07:20:31 <shapr> Probably easy.. go for it!
07:20:40 <Syzygy-> Yeah. Would be a neat exercise.
07:20:51 <Syzygy-> Not today though. Time to leafve the office...
07:20:52 <astrolabe> usefull too
07:21:02 <shapr> lambdabot got popular because users got to write socially visible code.
07:21:09 <Syzygy-> :)
07:21:16 <Syzygy-> @help rot13
07:21:17 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:21:21 <Syzygy-> @list
07:21:22 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
07:21:37 <dons> Syzygy-: look in lambdabot/scripts/timein -- old perl script that does the job
07:21:38 <dons> $ perl timein Stockholm
07:21:39 <dons> Friday, November 24, 2006 at 4:18:05 PM CET
07:21:49 <dons> port it to haskell, stick it in Plugin/Time.hs
07:21:51 <Syzygy-> $ perl timein Chicago
07:21:57 <shapr> Speaking of which, I need to call my Swedish bank..
07:22:00 <Syzygy-> Yeah, looks like aneat idea.
07:22:21 <dons> $ perl timein Chicago
07:22:21 <dons> Friday, November 24, 2006 at 9:19:02 AM CST
07:22:35 <dons> all the code is there, just never bothered reintegrating it into lambdabot
07:22:38 <Syzygy-> Hmmmm. How good is that one? Can you do timein Jena?
07:22:54 <dons> $ perl timein Jena
07:22:54 <dons> Sorry, don't know this city
07:22:59 <Syzygy-> Check.
07:23:07 <Syzygy-> But still, it'll do about all I'm asking...
07:23:12 <shapr> Somedays I wish my head were smaller. It'd make buying helmets much easier.
07:23:20 <dons> http://www.cse.unsw.edu.au/~dons/code/lambdabot/scripts/timein
07:23:22 <lambdabot> http://tinyurl.com/ujmp8
07:23:32 <Syzygy-> Though ... doesn't Haskell have neat interfacing to system time and TZ-handling? You wouldn't need to go via webreading...
07:23:40 <dons> yeah
07:23:56 <Syzygy-> Looks a little bit silly to do a HTTP GET for each time question.
07:23:57 <astrolabe> Shapr: not necessaraly.  You might not understand money.
07:24:08 <shapr> That's true.
07:24:11 <dons> hint: $ TZ=America/New_York date +"NY %H.%M"
07:24:11 <Syzygy-> @help elite
07:24:11 <dons> NY 10.19
07:24:12 <lambdabot> elite <phrase>. Translate English to elitespeak
07:24:33 <Syzygy-> Yeah.
07:24:38 <astrolabe> @help yow
07:24:39 <lambdabot> yow. The zippy man.
07:24:49 <Syzygy-> I don't understand yow. I really don't.
07:24:50 <astrolabe> What is the zippy man?
07:24:52 <norpan> @elite elite
07:24:53 <lambdabot> Elite
07:24:53 <Syzygy-> @help botsnack
07:24:54 <lambdabot> botsnack. Feeds the bot a snack
07:24:59 <Syzygy-> @botsnack
07:24:59 <lambdabot> :)
07:25:02 <Syzygy-> :)
07:25:07 <norpan> :)
07:25:08 <Syzygy-> @help get-shapr
07:25:08 <lambdabot> get-shapr. Summon shapr instantly
07:25:13 <Syzygy-> Oooooooh. That works?
07:25:16 <Syzygy-> @get-shapr
07:25:17 <lambdabot> shapr!!
07:25:34 <opqdonut> @yow
07:25:34 <lambdabot> Hmmm ... a CRIPPLED ACCOUNTANT with a FALAFEL sandwich is HIT by a
07:25:35 <lambdabot> TROLLEY-CAR ...
07:25:38 <Syzygy-> @help hylo
07:25:38 <lambdabot> hylo <expr>. Derive hylomorphism for <expr>. Based on DrHylo.
07:25:39 <lambdabot> Uses the Pointless.Combinators from:
07:25:39 <lambdabot>  http://wiki.di.uminho.pt/twiki/bin/view/Alcino/PointlessHaskell
07:25:39 <lambdabot> Mirrored:
07:25:39 <lambdabot>  http://www.cse.unsw.edu.au/~dons/Pointless/
07:25:46 <Syzygy-> Hylomorphisms???
07:25:51 <dons> Syzygy-: perhaps in privmsg? :)
07:25:57 <Syzygy-> Yeah...
07:26:07 <Syzygy-> I should be leaving the office anyway. Need to stop this.
07:26:14 <dons> ?hylo f x g y= g y (g x)
07:26:14 <lambdabot> f x g y = g y (g x)
07:26:21 <dons> ?hylo f x g y= y x
07:26:22 <lambdabot> f x g y = y x
07:26:32 <dons> ?hylo f x = x
07:26:32 <lambdabot> f = hylo (_L :: Mu (Const v0)) g h
07:26:33 <lambdabot>  where g (x) = x
07:26:33 <lambdabot>     h x = (x)
07:26:37 <dons> heh
07:26:42 <Syzygy-> O.o
07:26:58 <opqdonut> :D
07:27:13 * shapr is here!
07:27:23 <LoganCapaldo> @hoogle a -> b -> [b]
07:27:24 <shapr> Syzygy-: You called?
07:27:25 <lambdabot> List.genericReplicate :: Integral a => a -> b -> [b]
07:27:25 <lambdabot> Data.List.genericReplicate :: Integral i => i -> a -> [a]
07:27:25 <lambdabot> Data.Graph.Inductive.Internal.FiniteMap.rangeFM :: Ord a => FiniteMap a b -> a -> a -> [b]
07:27:47 <Syzygy-> shapr: Regard it as the Big Red Button phenomenon... "Ooooh. I wonder what happens if I press this..."
07:27:48 <LoganCapaldo> > replicate 2 1
07:27:53 * shapr grins
07:27:55 <lambdabot>  [1,1]
07:28:15 <Syzygy-> @type flip . replicate
07:28:17 <lambdabot>   Couldn't match `b -> c' against `[a]'
07:28:17 <shapr> heippa hei opqdonut, opitko haskellia?
07:28:17 <lambdabot>    Expected type: Int -> a -> b -> c
07:28:24 * shapr pretends to speak finnish...
07:28:30 <opqdonut> shapr: hyvinh‰n sit‰
07:28:33 <dons> shapr: did you see the QC2 code is available?
07:28:37 <Syzygy-> shapr: It's lost with me... I'm swedish. :)
07:28:42 <Syzygy-> Now. Gone. *poof*
07:28:44 <dons> ?where+ QC2 darcs get http://www.cs.chalmers.se/~bringert/darcs/QuickCheck/
07:28:44 <lambdabot> Done.
07:28:45 <shapr> Syzygy-: Jag kan tala lite svenska..
07:28:50 <Syzygy-> Utm√§rkt!!
07:28:51 <shapr> dons: yay!
07:28:57 <dons> shapr: also:
07:29:04 <shapr> Men jag kan inte tala sÂ mycket som jag vill
07:29:05 <dons> ?where pqc
07:29:06 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/pqc
07:29:13 <dons> (smp qc)
07:29:13 <shapr> tyv‰rr...
07:29:28 * shapr boings cheerfully
07:29:32 * dylan wonders if that is non-utf8 or if he is missing a font
07:29:35 <dons> ?where+ pqc http://www.cse.unsw.edu.au/~dons/pqc.html
07:29:36 <lambdabot> Done.
07:29:52 <shapr> dylan: √§r det b√§ttre?
07:30:23 <opqdonut> shapr: i think i know you from somewhere but i can't seem to recall?
07:30:25 <shapr> opqdonut: I really don't speak Finnish, just a few words I picked up when I lived in Finland.
07:30:32 <opqdonut> oh heh
07:31:00 <shapr> I learned useful stuff like Min√§ haluan hampurilainen!
07:31:26 <shapr> opqdonut: So, are you an academic, or is your hostname deceptive?
07:31:57 <dylan> shapr: ah, good.
07:32:06 <opqdonut> shapr: heh academica is an ISP which takes care of the universities' connections
07:32:23 <opqdonut> shapr: my isp is somehow in the academica network
07:32:30 <shapr> So you're not an academic?
07:32:38 <opqdonut> shapr: i'm going to univ. next year, hischool atm
07:32:51 <opqdonut> shapr: probably cs and math @helsinki before you ask
07:33:08 <earthy> ?where ndp
07:33:09 <lambdabot> http://www.cse.unsw.edu.au/~chak/project/dph
07:33:34 <shapr> dons: pqc is way cool!
07:33:44 <shapr> opqdonut: Spiffy, how'd you find your way to #haskell?
07:34:25 <shapr> Before you ask, I found my way here to #haskell before anyone else, the channel was empty when I arrived!
07:34:32 <opqdonut> shapr: i'm interested in functional programming and recently coded a genetic algorithm for a paper in haskell
07:34:48 <shapr> Neato, you're writing academic papers while in hischool?
07:34:55 <opqdonut> or actually the algorithm is a wip still :)
07:35:06 <shapr> I'm not really an academic, though some people don't believe me when I say that.
07:35:07 <opqdonut> shapr: yeah, this is for a competition for hischoolers
07:35:11 <shapr> Wow, cool!
07:35:14 <lisppaste2> LoganCapaldo annotated #30601 with "Why doesn't this work?" at http://paste.lisp.org/display/30601#1
07:35:16 <opqdonut> genetic algorithms in combat modelling is my topic
07:35:32 <LoganCapaldo> Sooo
07:35:42 <shapr> Sounds like a lot of fun, were you able to plug you algorithm into an FPS or RTS game?
07:35:45 <LoganCapaldo> who wants to look at that and beat me with the clue bat?
07:35:46 <shapr> your*
07:36:20 <earthy> ?where+ ndp http://darcs.haskell.org/packages/ndp/Data/Array/Parallel/
07:36:20 <lambdabot> Done.
07:36:22 <earthy> ?where ndp
07:36:23 <lambdabot> http://darcs.haskell.org/packages/ndp/Data/Array/Parallel/
07:36:31 <earthy> that wasn't the idea
07:36:40 <opqdonut> shapr: not yet, it breeds event->reaction based AIs, for a simple combat model atm tho
07:36:46 <opqdonut> shapr: a real combat model tho
07:36:46 <shapr> earthy: I think you can add multiple entries.
07:36:58 <opqdonut> one they use at the finnish defence force :)
07:37:00 <earthy> ?where+ ndp http://darcs.haskell.org/packages/ndp/Data/Array/Parallel/ ttp://www.cse.unsw.edu.au/~chak/project/dph
07:37:01 <lambdabot> Done.
07:37:04 <shapr> opqdonut: interesting!
07:37:04 <earthy> ?where ndp
07:37:05 <lambdabot> http://darcs.haskell.org/packages/ndp/Data/Array/Parallel/ ttp://www.cse.unsw.edu.au/~chak/project/dph
07:37:07 <opqdonut> shapr: it is
07:37:17 <earthy> ?where+ ndp http://darcs.haskell.org/packages/ndp/Data/Array/Parallel/ http://www.cse.unsw.edu.au/~chak/project/dph
07:37:17 <lambdabot> Done.
07:37:20 <earthy> there.
07:37:21 <opqdonut> shapr: deadline is approaching fast tho, and i've lots to write still
07:37:30 <opqdonut> shapr: luckily the coding is done
07:37:30 <shapr> Oh, maybe I should let you get back to work then :-)
07:38:00 <shapr> Coding is always the harder part for me, writing seems easier.
07:38:32 <opqdonut> depends on the code
07:38:38 <opqdonut> writing haskell was a pleasure
07:38:50 <opqdonut> ^^
07:39:08 <shapr> Same for me, Haskell is easier to write than other languages I've used.
07:44:10 <shapr> CosmicRay: Oh hey, I get a lot of "Remote user rejected the call" from voxee lately, do you know if that means their capacity is all used up?
07:49:24 <yaarg> @where hasktags
07:49:28 <lambdabot> http://www.cl.cam.ac.uk/users/rje33/software.html
07:52:52 <araujo> hi hi
08:07:56 <emu> ghci can also output tags files
08:09:34 <eviltwin_b> haskell wiki also has "tagsh" fwiw
08:11:31 <michel> hello guys
08:11:58 <psnl> hello
08:12:03 <michel> any on cah help me with a little thing?
08:12:11 <michel> hello psnl
08:13:09 <psnl> quick check, you don't go to uni in Durham, do you?
08:15:16 <earthy> ghci can output tags files?
08:16:48 <malcolm_> psnl: how is the hat-gui coming along?  got any screenshots? :-)
08:17:04 * dcoutts_ is eager to see screenshots too :-)
08:17:36 * psnl has failed to take screen shots yet
08:17:41 <psnl> I keep meaning to
08:18:04 <psnl> malcolm_: apart from that, not bad
08:19:03 <malcolm_> so, without screenshots, can you describe briefly what it can do by now?
08:19:48 <psnl> malcolm_: it supports delta, observe and trail, plus ndm did stack and cover.
08:20:15 <malcolm_> psnl: cool.  that sounds like a lot of useful tools
08:21:20 <malcolm_> psnl: does each tool live in a separate tab or something?
08:21:27 <psnl> malcolm_: no idea how things work at york, but here you are supposed to produce three bits to your project, a basic bit, a intermediate bit and a advanced bit. The basic Gui is the basic bit.
08:21:32 <psnl> malcolm_: yeah
08:21:43 <psnl> making the tools work together is the advanced bit
08:22:19 <dcoutts_> psnl, so did you need lots of list & tree widgets ?
08:22:29 <malcolm_> psnl: by "working together", you mean being able to jump from one tool to another, taking a given expression/equation with you...
08:22:35 <psnl> malcolm_: aye
08:23:08 <psnl> dcoutts_: yes
08:23:34 <dcoutts_> psnl, are you using the old or new style tree model api ?
08:23:57 <malcolm_> psnl: and what is the intermediate part of the project going to be (or have you done it already perhaps)?
08:24:35 <dcoutts_> psnl, I ask because we're pondering what to do with it for the immediate release, whether to make the new api the default or keep the new api as an experimental bit that for the current release
08:26:20 <psnl> malcolm_: support for concurrent haskell and a bit of work on monads
08:26:43 <psnl> dcoutts_: I'm using the old style, but I could move ;-)
08:26:53 * psnl is failing to do two things at once
08:27:27 <malcolm_> psnl: conc and monads sound like an interesting challenge - I might have made them the advanced part
08:27:32 <dcoutts_> psnl, ok, thanks. That's an interesting data point.
08:28:13 <dcoutts_> psnl, my inclination is not to break your program in the next release, but break it in the following one :-)
08:28:46 <psnl> malcolm_: its a bit of a handwave. in theory the three bits map to the three classes of degree, but if your inter step is hard, then you get a first without having to do tons of stuff for the advanced stage
08:29:36 <psnl> malcolm_: OTOH, if your project is easy, or a stage in it is easy, then you have to make a very good job of it.
08:29:48 <psnl> dcoutts_: thanks, I think
08:29:59 <dcoutts_> heh
08:30:13 <dcoutts_> psnl, the new api should be much much easier to use once it's mature
08:30:25 <dcoutts_> it's all typed and everything, no messing with iterators etc
08:30:33 <psnl> I will look at it then
08:32:48 <psnl> malcolm_: sorry for being vague
08:33:27 <malcolm_> psnl: no, that wasn't vague at all
08:34:33 <malcolm_> psnl: a very informative summary
08:41:51 <psnl> malcolm_: the mildly annoying bit about glade is that its really easy to knock up guis, and a lot harder to write the backend to them ;-)
08:43:04 <dcoutts_> psnl, yeah, I find that too. I always add more buttons than I eventually make feature-complete :-)
09:21:19 <bringert> shapr: QuickCheck 2
09:21:22 <bringert> shapr: need I say more?
09:22:18 <psnl> is it a good or bad sequel?
09:22:53 <bringert> I think good. More car chases.
09:23:10 <bringert> gotta go, say hi to shapr
09:23:25 <psnl> @tell shapr bringet says hi
09:23:26 <lambdabot> Consider it noted.
09:24:08 <vincenz> @tell psnl bringert said to say hi to shapr, not to tell the bot to say hi
09:24:10 <lambdabot> Consider it noted.
09:25:59 * psnl ponders the difference
09:26:00 <lambdabot> psnl: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:26:06 <psnl> @messages
09:26:07 <lambdabot> ndm said 1m 1d 5h 3m 21s ago: no, windows
09:26:07 <lambdabot> vincenz said 1m 57s ago: bringert said to say hi to shapr, not to tell the bot to say hi
09:26:31 <psnl> @help
09:26:31 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:26:35 <psnl> @help tell
09:26:35 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
09:26:45 * psnl wonders how to remove old messages
09:26:57 <glguy> I need a good way to attack an instance running in VirtualPC
09:27:08 <glguy> with a normal OS / computer I can kick the box ...
09:27:14 <vincenz> kill -9
09:27:23 <glguy> physical damage is key
09:27:36 <psnl> glguy: have a punchbag
09:27:53 <vincenz> glguy: reify the OS inside virtualpc to the native os and then throw your computer out of the window
09:28:08 <glguy> hmm, that could work...
09:28:42 <glguy> then I'll just tell the tech guy that my PC crashed... into the sidewalk... at least I'd *feel* better
09:29:13 <vincenz> hehe
09:29:19 <vincenz> "my pc crashed" *looks down *
09:29:33 <glguy> fatal gravity exception, i think
09:29:43 <vincenz> nah gravity ain't an issue
09:29:47 <vincenz> fatal concrete exception
09:29:47 <glguy> my eyes weren't good enough to see the blue screen on it's way down...
09:29:56 <glguy> ah, yeah, must have been my glasses
09:30:25 <glguy> ...plug it into an extension cord so it would still e powered up with it hit the sidewalk...
09:30:42 <shapr> briyay!
09:30:43 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
09:30:47 <shapr> @messages
09:30:48 <lambdabot> psnl said 7m 22s ago: bringet says hi
09:30:51 <shapr> heh
09:30:52 <glguy> lol
09:31:14 <vincenz> glguy: your battery doesn't last to groundlevle?
09:31:16 <psnl> shapr: hi
09:31:30 <glguy> vincenz: naw, this is a desktop
09:31:42 <vincenz> @tell lambdabot Hi
09:31:43 <lambdabot> Nice try ;)
09:31:48 * vincenz laughs
09:32:06 <glguy> @tell glguy hi
09:32:07 <lambdabot> You can tell yourself!
09:32:12 <shapr> hi psnl
09:32:14 * psnl wonders where shapr is these days
09:32:15 <vincenz> That should be
09:32:20 <shapr> psnl: Birmingham, Alabama
09:32:21 <vincenz> "You can tell yourself yourselff"
09:32:44 <vincenz> shapr: and virtually?
09:33:07 <shapr> Oh, virtually I'm busy hacking on HAppS
09:33:26 <glguy> is it virtually done?
09:33:35 <shapr> Problem is that I can't focus and irc at the same time.
09:33:37 <shapr> I just end up chatting.
09:34:05 <shapr> So I have to delete everything from my computer that might possibly distract me, and then pull my ethernet cable.
09:35:04 <psnl> I'm not sure I can hack haskell without hoogle
09:35:27 <shapr> Yeah, I keep having to get back online to get docs I'm missing.
09:35:29 <shapr> That sort of sucks.
09:36:14 <shapr> I need more emacs integration. I'd really like to have a local version of @index @type that know about all the projects/source I'm using.
09:36:34 <psnl> it used to be that I felt I owed ndm a beer for every time I used it, but these days the beer would cover any bar
09:48:51 <mstevens> I randomly suggested to someone that haskell was theoretically faster than C. They argued, and it quickly became apparent that I was basically saying this because someone I consider reliable told me once. Where can I get some references on the subject?
09:50:25 <opqdonut> mstevens: well, the computer language shootout has some data
09:50:36 <opqdonut> not large or good enough to make decisions
09:50:59 <opqdonut> s/computer/programming/
09:51:05 <opqdonut> http://shootout.alioth.debian.org/
09:51:15 <mstevens> opqdonut: I'm not arguing that it's currently faster, just that one could, in theory, write a faster haskell compiler because it has more information
09:52:05 <opqdonut> http://shootout.alioth.debian.org/debian/benchmark.php?test=all&lang=ghc&lang2=gcc
09:52:10 <lambdabot> Title: Haskell GHC benchmarks | Debian : AMD&#8482; Sempron&#8482; Computer Language Sh ..., http://tinyurl.com/fkt9u
09:52:35 <Cale> mstevens: I'll actually agree on that point. :)
09:53:14 <mstevens> cale: I find myself lacking any information with which to convince the dubious, I was hoping you lot could tell me what to read :)
09:53:18 <opqdonut> yeah me too
09:53:21 <Cale> mstevens: a good example of where high-level information about a problem really helps is in, say, matrix computations.
09:53:23 <opqdonut> ocaml is a good example
09:53:28 <opqdonut> damn fast functional language
09:53:47 <opqdonut> see http://shootout.alioth.debian.org/gp4sandbox/benchmark.php?test=all&lang=ocaml&lang2=gcc
09:53:49 <lambdabot> Title: OCaml benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 The Sandbox, http://tinyurl.com/y86zsb
09:53:55 <Cale> Suppose you compute apply(product(A, inverse(A)), x), where A is a matrix, and x is some vector
09:54:00 <opqdonut> very small margin with C
09:54:13 <Cale> A compiler which knows about matrices can optimise this to x
09:54:24 <mstevens> cale: the problem is that my opponent is the sort of person who will fall back on "I wrote a gcc backend and you didn't so I'm right"
09:54:59 <opqdonut> mstevens: all arguments can't be won, face it :)
09:55:06 <mstevens> yes :)
09:55:08 <Cale> (you might say that's ridiculous code to write, but it might occur after inlining, for instance)
09:55:40 <Cale> At the C level-of-granularity, this is brutally impossible to optimise
09:55:55 <Cale> You don't have matrix multiplication, you have a bunch of loops.
09:57:01 <Cale> In order to optimise it, you'll have to work out that what is being done is actually matrix multiplication, or at least that everything would cancel.
09:57:52 <opqdonut> but c compilers can be damn good optimizers
09:57:59 <Cale> mstevens: But yeah, point him at Data.ByteString -- it's beating na√Øve C programs in simple cases now.
09:58:20 <opqdonut> naive C is easy to beat
09:58:21 <Cale> http://www.cse.unsw.edu.au/~dons/fps.html
09:58:21 <lambdabot> Title: Data.ByteString
09:58:26 <opqdonut> standard library C very hard
09:58:34 <Cale> Well, not-block-IO-C
10:00:19 <Cale> For instance, consider a program which uses fgets and atoi one line at a time to read stdin and print out the sum.
10:03:20 <Cale> Data.ByteString makes use of the higher-level information you're giving it to rewrite your code into an efficient form.
10:04:42 <Cale> http://www.cse.unsw.edu.au/~dons/talks/streams-sapling-talk.ps.gz -- check this out :)
10:04:43 <lambdabot> http://tinyurl.com/yzzlsz
10:05:01 <Cale> (or if you don't have a postscript viewer for whatever reason, I'll convert it for you :)
10:18:13 <cjay> the type of build confuses me
10:21:35 <dcoutts_> cjay, it confused me too at first
10:21:47 <dcoutts_> @type GHC.Base.build
10:21:48 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
10:22:02 <dcoutts_> build g = g (:) []
10:22:22 <dcoutts_> so (:) is an example of that (a -> b -> b)
10:22:26 <dcoutts_> and [] is a b
10:22:48 <KoenigGunther> hi
10:22:52 <dcoutts_> if you substitute a = x, b = [x]
10:23:25 <dcoutts_> ((x -> [x] -> [x]) -> [x] -> [x]) -> [x]
10:24:02 <dcoutts_> so we've been given g :: ((x -> [x] -> [x]) -> [x] -> [x])
10:24:09 <dcoutts_> and we give it (:) and []
10:24:23 <dcoutts_> and it gives us back [x] which is also our final result
10:24:54 <cjay> now I get it, thanks :)
10:25:17 <KoenigGunther> i have got a question regarding functions
10:26:33 <KoenigGunther> i do have to implement a binary tree and defined it as data bTree a = Nil | Node a (bTree) (bTree)
10:27:13 <KoenigGunther> i'd like to insert something: insert ::a -> bTree a -> bTree a
10:27:26 <KoenigGunther> insert el (Node a (l) (r))
10:27:51 <dcoutts_> KoenigGunther, remember that type names must start with a capital letter
10:27:52 <KoenigGunther> but it does not work since haskell says that a may not be applied to two arguments
10:27:55 <dcoutts_> eg BTree
10:28:18 <KoenigGunther> sorry, forgot shift :)
10:28:47 <KoenigGunther> my problem is the function thing... is it possible to declare a as a variable not as a function?
10:29:22 <dcoutts_> KoenigGunther, I think we need to see more of the code to see what is wrong
10:29:25 <dcoutts_> @paste
10:29:31 <KoenigGunther> ok :)
10:29:32 <lambdabot> http://paste.lisp.org/new/haskell
10:30:47 <lisppaste2> KoenigGunther pasted "SearchTree" at http://paste.lisp.org/display/30624
10:30:55 <KoenigGunther> I'll paste another version which has the same problem...
10:32:32 <dcoutts_> KoenigGunther, you're using 'a' as if it were a function
10:32:38 <dcoutts_> | el == a = (a l r)
10:32:44 <dcoutts_> do you really mean that?
10:33:24 <KoenigGunther> ermm... no :P
10:33:41 <KoenigGunther> thank you, i didnt see that actually
10:34:02 <dcoutts_> you want some kind of node, what is the result supposed to be when they're equal?
10:35:22 <KoenigGunther> yes, if there is a node inside of the tree that already has the value of the element I want to add nothing should happen, but i didnt know how to write that...
10:35:41 <mauke> @djinn (a -> Bool) -> (a -> IO Bool)
10:35:42 <lambdabot> -- f cannot be realized.
10:35:53 <KoenigGunther> I thought it would be a good idea if i would just overwrite it
10:36:05 <dcoutts_> KoenigGunther, don't think of it in terms of what 'happens' think of what you want the result to be.
10:37:23 <KoenigGunther> ah, i think i have got it now
10:37:53 <KoenigGunther> if the element is already inside of the tree, i simply return the *old* tree, right?
10:38:51 <dcoutts_> KoenigGunther, sounds reasonable
10:39:03 <KoenigGunther> thank you very much :)
10:39:25 <dcoutts_> KoenigGunther, though if the new and old values are distinguishable by something other than == then you might want to return a new tree with the new value
10:40:40 <KoenigGunther> okay
11:08:27 <xerox> ?yow
11:08:27 <lambdabot> With YOU, I can be MYSELF ...  We don't NEED Dan Rather ...
11:08:42 <xerox> ?vixen right, we don't
11:08:43 <lambdabot> right indeed
11:21:52 <glguy> ?yar
11:21:53 <lambdabot> Prepare to be boarded!
11:22:13 <Cale> @yow
11:22:13 <lambdabot> I need to discuss BUY-BACK PROVISIONS with at least six studio
11:22:14 <lambdabot> SLEAZEBALLS!!
11:22:43 <glguy> What is the source of ?yow quotes?
11:23:24 <mauke> zippy the pinhead
11:28:26 <KoenigGunther> i guess i need your help again
11:28:42 <Cale> KoenigGunther: what's up?
11:29:10 <lisppaste2> KoenigGunther annotated #30624 with "problem#2" at http://paste.lisp.org/display/30624#1
11:29:29 <mauke> wasn't there a function for getting all permutations of a list?
11:29:34 <KoenigGunther> i had to wrote the function countLeaf...
11:30:24 <Cale> mauke: no, there was in Haskell 1.3, but I think it was removed at some point.
11:30:39 <KoenigGunther> there is no syntactical mistake, but a logical i guess
11:30:49 <mauke> ok, is there a standard way to define this function? :-)
11:30:54 <mauke> probably involving a monad or two
11:30:58 <Cale> KoenigGunther: You're counting nodes.
11:31:38 <KoenigGunther> damn
11:31:57 <KoenigGunther> i think i should eat something before i continue :)
11:32:48 <lisppaste2> KoenigGunther annotated #30624 with "permutations" at http://paste.lisp.org/display/30624#2
11:33:14 <KoenigGunther> i just wrote a function that gives you permuations of a list
11:33:36 <KoenigGunther> ...if you need it...
11:33:45 <Cale> lisppaste2: url
11:33:45 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:34:38 <lisppaste2> Cale pasted "permutations" at http://paste.lisp.org/display/30628
11:37:13 <mauke> nice
11:41:08 <Cale> that perms2 is iirc, the fastest implementation I've run into so far
11:41:54 <Cale> If you find a way to beat it, please let me know, since at some point, I plan to submit a patch to libraries@ containing some basic combinatorial functions for Data.List
11:42:29 <Cale> the advantage of the first perms there is that it works on infinite lists.
11:43:47 <mauke> is ghc smart enough to turn foo (x : xs) = x : xs into foo ys = ys?
11:44:27 <Cale> Those wouldn't be the same, would they?
11:44:48 <dcoutts> one is stricter
11:44:52 <mauke> ok, foo ys@(_ : _) = ys
11:45:09 <dcoutts> but yes I think yes it can, though I'm not 100% sure of it
11:45:26 <Oejet> What about "foo []"?
11:45:47 <mauke> Oejet: that's handled by the first equation
11:46:24 <Oejet> mauke: Sorry, I did not notice the first equation.
11:46:55 * Oejet loves adding noise to any random conversation.
11:47:16 <Cale> which first equation?
11:47:31 <mauke> foo [] = [] :-)
11:48:21 <KoenigGunther> if i have the given signature of "(b -> [a]) -> (b -> [a]) -> [b] -> Bool" - is it possible to determine wether the last [b] is a list of lists or a list with elements of the type b?
11:48:43 <opqdonut> KoenigGunther: it is a list of b's
11:48:54 <opqdonut> KoenigGunther: a list of lists of b would be a [[b]]
11:49:02 <KoenigGunther> yes
11:49:03 <opqdonut> of course if b is a list type to begin with
11:49:06 <Cale> unless b is a type of lists, [b] is not a list of lists.
11:49:08 <kzm_> of courses, b might be [c]
11:49:18 <KoenigGunther> but i could say that b = [bla...]
11:49:30 <KoenigGunther> then [b] would be [[bla..]]
11:49:30 <kzm_> (Glad we agree on that :-)
11:49:33 <opqdonut> wow, 4 people just said exactly the same thing
11:49:35 <opqdonut> yeah :D
11:49:53 <Cale> but in the case that you have that type signature, you're not allowed to use any more structure than given
11:49:53 <KoenigGunther> :P
11:50:17 <Cale> (i.e. in the definition you're not allowed to assume anywhere that you have a list of lists, because then the function would not be as polymorphic)
11:51:07 <kzm_> I wonder - I posted the dummy fps module a bit tongue in cheek, but now I wonder if it isn't a really good idea to include it?  Especially if there are plans to separate fps again in 6.8 or so...
11:51:26 <KoenigGunther> the thing is that i am doing this for my teacher - she has some test data and applies my functions on these datas to determine wether my function works correct..
11:51:28 <Cale> There's too much arguing about package structure :)
11:51:45 <kzm_> (Perhaps there are other, more important incompatiblities in cabal.. but it solved it for me)
11:51:47 <KoenigGunther> she actually has one test data in which b is [c]
11:51:56 <opqdonut> KoenigGunther: well, it shouldn't matter
11:52:14 <kzm_> Cale, actually, I tend to agree.  I'm not sure why I should care what set of libraries ghc ships with.
11:52:26 <kzm_> As long as the rest are easily available.
11:52:37 <kzm_> Ideally through my preferred Linux distribution.
11:52:48 <Cale> It's not only about what libraries GHC ships with, it's how the libraries that GHC is going to ship with anyway are broken into packages.
11:53:06 <kzm_> Ah, but that /is/ important, I think.
11:53:11 <Cale> really?
11:53:16 <Cale> I've never had to care about it
11:53:52 <kzm_> (Where have you been? :-)  The point is that bundling a lot of stuff into an un-upgradeable base makes bazaar development difficult.
11:54:28 <Cale> Can't people just submit patches to libraries@ ?
11:54:36 <dblhelix> anyone already gave quickcheck 2 a spin?
11:54:40 <kzm_> Patches to what?
11:54:45 <Cale> To the libraries :)
11:55:04 <kzm_> Untested patches to development versions that may or may not coincide with shipped sources?
11:55:38 <kzm_> I want to darcs a package, ./Setup conf/build/install, modify, experiment, etc.
11:56:01 <kzm_> If that means recompiling GHC and his grandmother, it ain't gonna happen.
11:56:34 <pejo> kzm, I think a stronger argument for unbundling is modularity. I had to think to understand what you meant with Bazaar development. :-)
11:57:02 <ValarQ> > ((+2) ‚ãô (+3)) 4
11:57:02 <lambdabot>  Illegal character ''\139''
11:57:12 <pejo> Ok, you beat me to the point with the rest of the sentences.
11:57:13 <kzm_> pejo, yep - perhaps that isn't the right word for it - or that it needs a bit more elaboration.
11:57:14 <Cale> hehe, aww
11:57:16 <MP0> I haven't figured out where you download packages for haskell.
11:57:25 <eviltwin_b> modularity is arguably part of the bazaar argument
11:57:30 <mauke> VERY MUCH GREATER-THAN!
11:57:53 <eviltwin_b> just watch out for duplicating e.g. linux shared library hell :)
11:58:02 <Cale> I like the "Very much greater than or less than" sign :)
11:58:21 <eviltwin_b> (and speaking of that, and downloading packages, where's CHAN? :)
11:58:29 <kzm_> What I think is crucial, is a very low threshold to pick interesting parts of the libraries, and hack them.  As independently of the rest as possible.
11:58:35 <pejo> eviltwin_b, to me, as a user - I don't really care if it's dons or Simon^2 who does the library development. But I might want improvements from the next version of the library today.
11:58:47 <Cale> actually, "Very much greater than or equal to" is even better :)
11:59:03 <ValarQ> Cale: sounds like a quite special symbol
11:59:07 <Cale> hehe
11:59:43 <Cale> It was in the pure math club's quotebook on the notation page near the back :)
11:59:58 <ValarQ> can't find the utf-8 code for it... :(
11:59:59 <Cale> (at waterloo)
12:00:02 <pejo> Is there anyone working on "CHAN" today, or is it the next logical step, or is it already out there?
12:00:14 <Cale> However, unicode really does have "DIVISION TIMES"
12:00:17 <kzm_> eviltwin_b, CHAN - well, there's stuff at Haskell.org.  It could be better organized, I'm sure.
12:00:19 <Cale> which was also there :)
12:00:32 <mauke> U+22C7 (0xe2 0x8b 0x87): DIVISION TIMES [‚ãá]
12:00:45 <Cale> yep
12:00:45 <kzm_> Cale, well if you have plus-minus ¬±
12:00:46 <ValarQ> Cale: what the heck is that?
12:00:47 <mauke> .oO( let the DIVISION TIMES roll )
12:00:55 <eviltwin_b> well, every time I look at Cabal I keep thinking it should include a CPAN/CTAN/etc.-alike
12:00:56 <kzm_> heh.
12:01:02 <Cale> ValarQ: multiplied by or divided by
12:01:24 <Cale> though I think "plus or times" is way more useful
12:01:51 <Cale> ‚àî
12:02:10 <kzm_> eviltwin_b, you will usually be able to find somebody's darcs repo if you hunt around.  Suffices for me.  Of course, perl's ability to d/l and install for you is neat.  cabal-get?
12:02:26 <eviltwin_b> something like, yes
12:02:42 <kzm_> Cale: I bet Unicode has the full set of arithmetic combinations.
12:02:42 <eviltwin_b> which would install (possibly an updated version of) a package
12:02:50 <Cale> kzm: it doesn't though
12:03:07 <Cale> It also doesn't have "Greater than or a fish"
12:03:23 <kzm_> U+234553: DIVISION OR MULTIPLICATION BUT DEFINITELY NOT PLUS
12:03:31 <Cale> which as you can imagine is a greater than sign with a fish under it
12:04:05 <kzm_> tsk tsk.  Time to call the Unicode people again.  They *always* miss important parts.
12:04:14 <dblhelix> @seen SyntaxNinja
12:04:14 <kzm_> Basic Antilingual Plane?
12:04:15 <lambdabot> I saw SyntaxNinja leaving #haskell, #darcs and #haskell-blah 2d 16h 18m 7s ago, and .
12:09:52 <MP0> Sweet, I finally found the download link to the network package.
12:14:53 <metaperl> If I wanted to zip the letters  'A' thru 'Z' with the numbers 1 thru 26, how would I do that?
12:15:06 <Botje> you'd .. just do it?
12:15:10 <Botje> what's the problem?
12:15:20 <metaperl> Botje - anyway to iterate?
12:15:27 <metaperl> i mean shortand specify the range
12:15:35 <metaperl> > 'A' .. 'Z'
12:15:36 <lambdabot>  Parse error
12:15:42 <jdev> > zip [1..26] ['A'..'Z']
12:15:43 <lambdabot>  [(1,'A'),(2,'B'),(3,'C'),(4,'D'),(5,'E'),(6,'F'),(7,'G'),(8,'H'),(9,'I'),(10...
12:15:44 <metaperl> > ['A' .. 'Z' ]
12:15:46 <lambdabot>  "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
12:15:54 <metaperl> ok great thanks jdev
12:16:27 <MenTaLguY> hello
12:16:28 <ValarQ> easier to just write  zip [1..] ...
12:17:30 <metaperl> so a 2-tuple is more common in Haskell than an associative array? I want to be able to get the number for a char and vice versa... I think a 2-tuple is most versatile, no?
12:17:37 <MenTaLguY> what are the best practices for setting up HUnit?
12:18:11 <tibbe_> metaperl: like a ascii code or some other number?
12:18:37 <metaperl> tibbe_ no just looking it up in my 2-tuple - ['A'..'Z'][1..]
12:18:39 <eviltwin_b> @hoogle [(a, b)] -> a -> b
12:18:41 <lambdabot> No matches, try a more general search
12:18:42 <metaperl> that is zipped
12:18:52 <eviltwin_b> @hoogle a -> [(a, b)] -> b
12:18:53 <lambdabot> No matches, try a more general search
12:18:55 <MenTaLguY> in particular, the HUnit docmentation shows how to write tests, and run them from an interactive session
12:19:01 <eviltwin_b> hm, thought that was predefined
12:19:08 <MenTaLguY> but how should test runs be automated?
12:19:10 <metaperl> @type snd
12:19:12 <lambdabot> forall b a. (a, b) -> b
12:19:31 <eviltwin_b> sure, I meant lookups treating a list of tuples as an associative array
12:19:42 <MenTaLguY> or, heck
12:19:46 <Igloo> CosmicRay: I don't want to fill the list with metoos, but I addres with Malcolm re MissingH FWIW
12:19:49 <metaperl> yeah, they should be - that is very common
12:19:58 <MenTaLguY> can someone point me to a particular project that uses HUnit and cabal, so I can just look at that as an example?
12:20:56 <CosmicRay> Igloo: thanks, I've appreciated all the feedback
12:22:06 <MenTaLguY> hackage is down too
12:22:09 <MenTaLguY> so I can't look there
12:22:18 <MenTaLguY> someone help?
12:22:24 <eviltwin_b> hm, Array yes, List no
12:22:51 <MenTaLguY> okay, let me try again
12:22:59 <MenTaLguY> has anyone here written a project that used HUnit for testing?
12:23:26 <Botty> http://haskell.org/haskellwiki/How_to_write_a_Haskell_program <- this page is handy though it doesn't deal with HUnit particulalry
12:23:28 <lambdabot> Title: How to write a Haskell program - HaskellWiki, http://tinyurl.com/yxe296
12:24:11 <Botty> (mentions is once in the testing section)
12:24:16 <MP0> I installed the Haskell Network-2.0 package on my MacOS system, but actually trying to use it results in link errors:
12:24:18 <MP0> ghc nt.hs
12:24:18 <MP0> compilation IS NOT required
12:24:19 <MP0> _networkzm2zi0_Network_PortNumber_con_info
12:24:19 <MP0> _networkzm2zi0_Network_connectTo_closure
12:24:19 <MP0> _networkzm2zi0_NetworkziSocket_zdf9_closure
12:24:20 <MP0> collect2: ld returned 1 exit status
12:24:46 <MP0> (nt.hs is just a small test of the Network stuff)
12:25:03 <Binkley> MP0: compile your code with --make
12:25:30 <MP0> wow, that worked... what does --make do?
12:25:41 <Binkley> automatically figures out what your code depends on
12:25:48 <Binkley> In this case, figures out that it depends on the Network package
12:26:01 <MP0> Ah, is there a reason that it's not the default behavior?
12:26:11 <Binkley> good question!
12:26:16 <Binkley> I don't know the answer to it, other than historical reasons
12:26:26 <CosmicRay> Igloo: what is the best way to send a contribution to one of the former-fptools libraries?  Just darcs send it?
12:27:50 <CosmicRay> is there a hunit or quickcheck suite that runs over the standard libraries as well?
12:28:30 <lisppaste2> metaperl annotated #30573 with "before this code gets too inelegant..." at http://paste.lisp.org/display/30573#1
12:28:44 <Igloo> CosmicRay: Follow the proposals procedure on a wiki page i can't find
12:28:57 <metaperl> I'm almost positive this stuff could be refactored... any suggestions : http://paste.lisp.org/display/30573#1
12:29:13 <Igloo> Ah, it's called submissions, not proposals
12:29:15 <Igloo> CosmicRay: http://www.haskell.org/haskellwiki/Library_submissions
12:29:18 <lambdabot> Title: Library submissions - HaskellWiki, http://tinyurl.com/y8yqmm
12:29:55 <CosmicRay> oh, excellent.
12:30:25 <CosmicRay> how long is the discussion period?
12:31:00 <CosmicRay> and would I have to do a separate ticket/patch for each individual function, or could I send half a dozen for consideration at once?
12:31:10 <Igloo> As long as you think sensible. 2 weeks is probably a sensible default?
12:31:42 <Botty> MenTaLguY: from that link I gather that HUnit is for your impure stuff, Quickcheck etc will be alot nicer than unit testing.
12:31:43 <Igloo> If the functions will either all be accepted or all rejected then you can do it in one
12:32:06 <CosmicRay> probably not, most of what I've got don't have interdependencies
12:32:17 <CosmicRay> but do you really want two dozen tickets for small 1-5 lines functions?
12:32:22 <Igloo> You probably don't want to do lots at once, either
12:33:18 <MP0> hmm, any idea what the Happy preprocessor is?
12:33:18 <MP0> Setup.hs: Language/Haskell/Parser.ly: no happy preprocessor available
12:33:42 <Igloo> MP0: http://www.haskell.org/happy/
12:33:43 <lambdabot> Title: Happy: The Parser Generator for Haskell
12:35:35 <CosmicRay> Igloo: I have literally dozens of list and string utility functions.  It would probably be cumbersome for everyone to have to track a bunch of statuses separately.  Perhaps I could at least create trac tickets all at once, and bring them up on the mailing list periodically?
12:37:35 <Igloo> CosmicRay: If you do them in series then it can only be cumbersome for you, at worst
12:38:46 <metaperl> How can I split a string into a list of strings at a delimiter... E.g: "Hi there" => ["Hi", "there"]
12:38:59 <CosmicRay> ok.  well I will try to arrive at a sane strategy, and if I don't hit the mark right off, then people can just tell me
12:39:03 <Cale> > words "Hi there"
12:39:04 <lambdabot>  ["Hi","there"]
12:39:12 <metaperl> Cale - thanks
12:39:28 <Igloo> CosmicRay: You might want to try them all at once, and then see if people think they would be better split up
12:39:33 <CosmicRay> metaperl: a more general option is also MissingH.Str.split, while we're on the topic.
12:39:41 <metaperl> CosmicRay - ok thanks
12:39:50 <CosmicRay> Igloo: one big ticket, or a bunch of separate tickets sent in at the same time?
12:39:54 <metaperl> but words will suffice for now
12:39:55 <glguy> It's a bit of a shame that the (.) operator is in use already, eliminating the possibility of having lambda expressions as: (Œªx.x^2+x)
12:40:08 <glguy> that just looks particularly cool to me
12:40:13 <Igloo> CosmicRay: I meant one big ticket
12:40:18 <CosmicRay> Igloo: ok.
12:40:38 <CosmicRay> I will probably start on this Monday, but maybe this weekend if I have some spare time.
12:40:43 <CosmicRay> thanks everyone for the feedback
12:40:48 * CosmicRay afks for a bit
12:40:49 <Igloo> CosmicRay: If you're going to split them up anyway then I'd much rather they were sequential, so I didn't wake up to n huge threads
12:41:05 <Cale> glguy: I actually think I like -> better.
12:41:10 <CosmicRay> Igloo: gotcha.
12:41:18 <Cale> Or ‚Üí :)
12:41:42 <Cale> Œªx‚Üíx¬≤+x
12:41:54 <Cale> heh
12:44:18 <Cale> I like how in the whole text, there's essentially one physics problem, and it gets its own chapter
12:44:19 <mbishop> I'm sure you've all seen http://research.microsoft.com/~simonpj/Papers/marktoberdorf/
12:44:21 <lambdabot> Title: Simon Peyton Jones: papers, http://tinyurl.com/jl2rm
12:44:25 <Cale> er, ECHAN :)
12:44:25 <mbishop> but I'm liking it :P
12:48:53 <lispy> mbishop: yes, we have and we do too :)
12:52:54 <kzm_> @type lookup
12:52:56 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
12:53:56 <eviltwin_b> hm, yeh, that's what I was looking for
12:54:07 <mbishop> where does the use of "xs" come from?
12:54:15 <pejo> Is there any book out there that covers haskell with glasgow-exts programming?
12:55:09 <Cale> pejo: the GHC documentation? :)
12:55:34 <Cale> mbishop: it's the plural of x :)
12:55:51 <Cale> (and it's pronounced as if it is too)
12:55:54 <glguy> mbishop: You mean "Who first started using 'xs'?" or just that if 'x' is one of something 'xs' must be many of them
12:56:14 <Cale> I think I've seen uses of xs going back to Miranda
12:56:16 <mbishop> glguy: well, the latter explains what I was asking, but who WAS the first? :P
12:56:33 <kzm_> eviltwin_b, sorry, I was looking at some past discussion.
12:56:47 <pejo> Cale, heh, wasn't the phrasing of my question a give-away that I wasn't looking for the ghc docs? :P
12:56:57 <glguy> mbishop: "I don't think anyone knows anymore. Scholars maintain that the translation was lost"
12:57:25 <MP0> the happy configure script doesn't seem to recognize darwin intel... On one hand, someone in high places must be smiling down on me, because hacking configure.ac seemed to have worked. On the other hand, the compile fails.
12:59:21 <lisppaste2> metaperl annotated #30573 with "type error (see end of file)" at http://paste.lisp.org/display/30573#2
13:01:52 <Cale> metaperl: It's saying that 0 isn't a character.
13:01:53 <lennart> has anyone here recompiled ghc HEAD recently?  It complains about Text.Regex not being found for me
13:02:07 <Cale> metaperl: so my guess is that bForA c is returning a character
13:04:14 <lennart> I think the 'xs' tradition is from Bird&Wadler
13:06:11 * monochrom has recently learned callcc
13:06:49 <mauke> haha, I thought you said "calloc" at first
13:07:18 <MP0> So I can't install lambdabot because it requires haskell_src, and haskell_src requires happy which is bailing with:
13:07:20 <MP0> LALR.lhs:626:34: Not in scope: `bounds'
13:08:08 <Cale> Control.Monad.Cont should have more stuff in it. callCC is kind of a powerful but usually unhelpful primitive
13:08:37 <Cale> (as in, you usually want to build something from callCC which is closer to the form of control you're interested in
13:08:38 <Cale> )
13:09:46 <xerox> monochrom: great.  How was it?
13:10:39 <pejo> MP0, are you trying to build Happy 1.15 or similar on Macos X/Intel?
13:10:51 <MP0> Yeah, I found a log about the issue
13:10:55 <MP0> http://tunes.org/~nef/logs/haskell/06.09.02
13:11:10 <dblhelix> MP0: I built happy some weeks ago... but it required some source code tweaking...
13:11:48 <dblhelix> MP0: interestingly, I did it because I wanted to build lambdabot, too...
13:12:06 <dblhelix> MP0: it might take some time to get there, though...
13:12:10 <monochrom> I determined how to write "try ... catch ..." with callcc.
13:12:26 <MP0> dblhelix: that's not too encouraging
13:12:38 <monochrom> Soon I will attempt Python's "yield".
13:13:26 <pejo> MP0, I think the bleeding edge happy had a bunch of fixes. But you need darcs for that, and 1.0.8 doesn't build with ghc 6.6 without patching either. :/
13:13:33 <Cale> It would be nice to have a YieldT
13:13:44 <MP0> will it build in 6.5 which I'm using?
13:14:06 <MP0> (I have darcs)
13:14:27 <dblhelix> iirc, you don't really need it for building lambdabot
13:15:00 <MP0> well, lambdabot declares a dependency on haskell-src, and that needs happy... where can I break the chain?
13:15:31 <dblhelix> I'm sorry, you're right... you do need happy...
13:15:35 <xerox> Cale, it would be Cont transformed?
13:15:48 <Cale> xerox: it would be a restriction of ContT
13:16:02 <dblhelix> MP0: iirc ... it's two or three changes you need to make to the happy source
13:16:15 <dblhelix> MP0: did you get happy from darcs?
13:16:28 <MP0> I got it from the tarball on http://www.haskell.org/happy/
13:16:29 <lambdabot> Title: Happy: The Parser Generator for Haskell
13:17:04 <MP0> I don't see the DARCS repository listed on that page
13:17:21 <dblhelix> the tarball should be fine too...
13:17:54 <MP0> @hoogle bounds
13:17:55 <lambdabot> Array.bounds :: Ix a => Array a b -> (a, a)
13:17:56 <lambdabot> Data.Array.bounds :: Ix i => Array i e -> (i, i)
13:17:56 <lambdabot> Data.Array.IArray.bounds :: (HasBounds a, Ix i) => a i e -> (i, i)
13:18:13 <pejo> MP0, darcs.haskell.org/happy iirc.
13:18:21 <dblhelix> MP0: http://www.mail-archive.com/glasgow-haskell-bugs@haskell.org/msg09911.html
13:18:24 <lambdabot> Title: Re: no happy, http://tinyurl.com/y8xn53
13:18:47 <dblhelix> MP0: my answer to Christian Maeder on the same issue...
13:18:55 <MP0> thanks
13:19:59 <MP0> out of curiousity, how did you get it to configure? I had to hack configure.ac with an extra case statement for i686-apple-darwin
13:21:12 <MP0> I'm not sure that's the kosher way to do it
13:22:00 <dblhelix> MP0: I'm sure it isn't
13:22:10 <dblhelix> MP0: it's the quick way :)
13:22:53 <dblhelix> MP0: anyway... I don't remember any issues when running configure...
13:23:06 <dblhelix> it configured just fine, that is...
13:23:49 <MP0> oh, hmm, maybe your version is newer... I got happy to build
13:24:25 <pejo> dblhelix, were you building on i386-darwin? (I had the exact same problem as MP0).-
13:24:45 <dblhelix> pejo: no, on powerpc-darwin
13:24:52 <MP0> ah, that works fine
13:25:17 <MP0> But I guess that means someone should tell the happy folks to update their automake thingie
13:25:36 <dblhelix> I believe JaffaCake already knows
13:25:46 <pejo> MP0, there's a rc2 for 1.16 out - http://haskell.org/happy/happy-1.16rc2.tar.gz
13:27:17 <MP0> what's the advantage of happy over parsec?
13:27:19 <lisppaste2> metaperl annotated #30573 with "need help on simple number theory algorithm" at http://paste.lisp.org/display/30573#3
13:29:28 <monochrom> Yes metaperl just apply reverse.
13:29:46 <metaperl> monochrom - ok like in a boilerplate function I guess?
13:30:03 <monochrom> I don't think there is any way you can get the MSD first without having gone through the LSDs.
13:30:15 <mauke> resolve = map (\c -> ord c - ord '0') . show
13:30:30 <monochrom> haha
13:30:56 <mauke> that's how you do it in perl
13:31:09 <lennart> map digitToInt would be better
13:31:10 <lisppaste2> eviltwin_b annotated #30573 with "how about this?" at http://paste.lisp.org/display/30573#4
13:31:13 <monochrom> I don't know "boilerplate function".
13:31:47 <metaperl> In other words resolve = reverse resolve_   -- and then resolve_ has the code originally in resolve
13:31:52 <mauke> ah, I always forget about that one
13:31:54 <eviltwin_b> it does uselessly call reverse in the trivial case
13:31:54 <monochrom> Um, eviltwin_b, you can't "reverse the number".
13:31:59 <eviltwin_b> sorry
13:32:10 <metaperl> @type digitToInt
13:32:12 <lambdabot> Char -> Int
13:32:23 <mauke> mostly because I think it should be in Numeric
13:32:24 <monochrom> You have reversed the order of reverse and resolve' ! XD
13:32:25 * eviltwin_b tried to rush it.  should just go turn into a pumpkin anyway :)
13:32:29 <eviltwin_b> yeh
13:32:29 <metaperl> clever mauke hanks
13:32:47 <metaperl> monochrom - I dont get your meaning
13:32:58 <yax1> wow, i try downloading wxhaskell from sourceforge and i get an ad popup trying to get me to join an online casino
13:33:07 <monochrom> reverse (resolve' n)
13:33:39 <MP0> now fps-0.7 is trying to define Data.ByteString.Char8 which is already defined in module base
13:34:13 <metaperl> mauke - Haskell is much nicer than Perl you think?
13:34:22 <phas> hi, i've a problem with c2hs
13:34:32 <phas> when i try to compile a certain file
13:34:35 <mauke> metaperl: it's different
13:34:38 <phas> against id3.h
13:34:43 <phas> it tells me :
13:34:50 <phas> phas@lucy:~/hid3$ c2hs /usr/include/id3.h libid3.chs
13:34:50 <phas> c2hs: Error in C header file.
13:34:50 <phas> /usr/include/bits/pthreadtypes.h:69: (column 6) [FATAL]
13:34:50 <phas>   >>> Syntax error!
13:34:50 <phas>   The symbol `;' does not fit here.
13:34:58 <phas> but this is a system library!
13:37:53 <dcoutts> phas, eew, that's nasty C that is.
13:38:38 <dcoutts> I think that might be one of the tricky typedef name issues we have with c2hs
13:38:58 <dcoutts> it can be fixed, but it's a lot of work
13:39:17 <phas> docutts: oh, so there's nothing i can do to make it work?
13:39:23 <dcoutts> MP0, in that case you don't need fps at all since ByteString is in base.
13:39:42 <MP0> That's what I think too... so I have to remove the dependency on fps from lambdabot
13:39:47 <dcoutts> phas, probably not. Unless you know a bit about LALR grammars.
13:40:05 <phas> dcoutts: no, i'm not
13:41:47 <phas> dcoutts: i think that i can still make the whole thing manually using FFI, right?
13:41:55 <dcoutts> phas, sure
13:42:09 <MP0> dcoutts... whatever's in base, it doesn't look like it covers everything that fps does. Is there any way I can hide Base's definition of ByteString?
13:42:15 <xerox> dcoutts, the __extension__ right?
13:42:23 <MP0> when I try to compile it without fps, I get: scripts/BotPP.hs:41:25: Not in scope: `B.breakChar'
13:42:33 <MP0> (where B is the ByteString)
13:42:42 <dcoutts> xerox, __extension__ is usually ok
13:43:01 <dcoutts> MP0, perhaps you need a later version of lambdabot
13:43:02 <phas> dcoutts: well ... sigh
13:43:15 <dcoutts> phas, what are you binding ?
13:43:21 <phas> libid3
13:43:26 <phas> for mp3 id tags
13:43:33 <dcoutts> it uses pthreads ?!
13:43:39 <phas> don't look at me
13:43:57 <dcoutts> that's the bit c2hs is choking on
13:44:52 <phas> well, i mean, i assume that it uses pthread because c2hs says that
13:45:06 <phas> but they are not directly included
13:45:16 <phas> #include <math.h>
13:45:16 <phas> #include <stdio.h>
13:45:16 <phas> #include <stdlib.h>
13:45:16 <phas> #include <string.h>
13:45:16 <phas> #include <strings.h>
13:45:17 <phas> #include <sys/mman.h>
13:45:19 <phas> #include <sys/types.h>
13:45:21 <phas> #include <sys/stat.h>
13:45:23 <phas> #include <assert.h>
13:45:25 <phas> #include <unistd.h>
13:45:27 <phas> #include <errno.h>
13:45:29 <phas> #include <fcntl.h>
13:45:31 <phas> #include <ctype.h>
13:45:33 <phas> maybe they are from ctype.h
13:46:22 <metaperl> I wanted to use a composition character between resolve and b_given_a but could not ...  char_logic c = if c == ' ' then [0] else resolve (b_given_a c)
13:47:01 <obsethryl> phas: do not paste in here, read topic
13:47:08 <vincenz> WOAH
13:47:10 <phas> ok, sorry
13:47:13 <monochrom> f (g x) = (f . g) x    not really worth it in most cases.
13:47:30 <monochrom> (For example, it doesn't reduce the number of parentheses.)
13:47:31 <metaperl> monochrom thanks
13:47:55 <glguy> but: map (f . g) xs    vs    map (\x -> f (g x)) xs
13:48:09 <metaperl> monochrom - picking things out of nested tuples is good for composition ...     s = sum (map (snd .snd) breakdown)
13:48:27 <glguy> or: map f (map g xs)
13:48:51 <monochrom> Yeah, I would just write f.g, no x.
13:49:18 <astrolabe> I've got a style question
13:49:22 <mauke> resolve $ b_given_a c
13:49:25 * glguy admits that he has no idea what context monochrom was making that statement in
13:49:34 <monochrom> char_logic c = (if c == ' ' then const [0] else f . g) x    hahaha
13:50:04 <astrolabe> How do you choose between 'if x then y else z'    and    '|x = y   | otherwise = z'?
13:50:05 <glguy> char_logic ' ' = const [0]; char_logic _ = f . g
13:50:25 <mauke> um, no
13:50:34 <MP0> @hoogle Text.Regex
13:50:35 <lambdabot> No matches, try a more general search
13:50:44 <mauke> unless you join it
13:50:49 * glguy always avoids if-then-else when possible
13:50:52 <Philippa_> astrolabe: depends. I tend to use if in monads
13:50:56 <monochrom> astrolabe: usually I would choose the latter.
13:50:58 <Philippa_> I should use guards more often though
13:51:32 <Philippa_> where reasonably possible I'd rather just match straight on True or False though
13:51:46 <vincenz> edwardk_: ping
13:51:54 <astrolabe> I prefer if   when it works because guards are more general, but I'm teaching someone else, so I'm interested in other opinions.
13:52:15 <mauke> liftM2 (!!) (map id [const [0], resolve . b_given_a]) (fromEnum . (' ' /=))
13:52:39 <astrolabe> yes, if is nice in monads
13:53:03 <monochrom> When defining a function by cases or writing cases, I use guards.  When inside a deep expression, I use if.
13:53:09 <MP0> curious... Plugin.hs:46:7:
13:53:09 <MP0>     Could not find module `Text.Regex':
13:53:10 <MP0> but
13:53:18 <Philippa_> if you're going to nest ifs, definitely use guards instead
13:53:19 <MP0> Prelude> :m + Text.Regex
13:53:19 <MP0> Prelude Text.Regex>
13:53:25 <MP0> so it's there, but won't import
13:53:41 <Philippa_> even if you have to introduce a new case statement to do it
13:53:49 <Philippa_> case _|_ of ... _ | ... :-)
13:54:02 <monochrom> compare "if x then ... else..."  with  "case x of x | x -> ..."
13:54:20 <Philippa_> the latter's crap
13:54:23 <Philippa_> because it could be:
13:54:35 <Philippa_> case x of {True -> ...; False -> ...}
13:54:36 <monochrom> If you need the case statement for other reasons, of course may as well do the test there.
13:54:40 <Philippa_> yep
13:55:02 <Philippa_> if there're additional tests, the case is probably still preferable
13:55:12 <monochrom> It's all about Kolmogorov complexity to me :)
13:57:00 <mauke> what's that?
13:57:31 <monochrom> given a task, what is the shortest program (or just the length of that)?
13:57:49 <phas> dcoutts: well, i need to access a c-structure. But doing it handy, will not work on different architecture right?
13:57:50 <monochrom> (of course you have to fix the programming language first)
13:58:07 <Philippa_> I don't think char count is necessarily the appropriate way to measure
13:58:07 <dcoutts> phas, you could use hsc2hs for that.
13:58:35 <monochrom> Yeah you can also fix a useful metric of "length".
13:58:56 <Philippa_> roughly speaking, "concept count" is probably better for human-readability
13:59:18 <monochrom> You can define "programming language" to be trees rather than strings, then you'll count nodes.
14:00:38 <astrolabe> thanks
14:01:00 <yaxu> anyone got wxhaskell working under ubuntu?
14:01:52 <astrolabe> I think there is a good analogy with information theory
14:02:50 <astrolabe> so program lengh should really be information
14:03:10 <Philippa_> monochrom: much then depends on how you handle nodes with an arbitrary number of children - do you need an embedding of lists?
14:03:18 <Philippa_> if so, that makes them a lot more expensive...
14:03:45 <Philippa_> astrolabe: the problem there is measuring info-for-human-reader. Long identifiers, conceptual breakdowns, stuff like that
14:03:45 <mauke> about ffi, what's the right haskell type for a void * parameter?
14:03:54 <mauke> Ptr ()? forall a. Ptr a?
14:04:09 <monochrom> I usually count tokens.
14:04:51 <astrolabe> Phillipa.  I'm just saying information is better than program length.  Neither measure accounts for human readability.
14:06:18 <Cale> mauke: I think the usual trick is to make a newtype
14:06:47 <Philippa_> astrolabe: Information can do. It depends what language you think you're talking
14:06:48 <Cale> newtype WhatItReallyIs = WIRI (Ptr WhatItReallyIs)
14:07:00 <mauke> it is really a void *
14:07:18 <mauke> wait, is that a recursive type?
14:07:42 <Philippa_> mauke: sort of
14:07:49 <Philippa_> the type's recursive, the representation isn't
14:07:53 <Cale> mauke: usually void pointers have some semantic meaning which just isn't carried by the C source
14:08:26 <mauke> I don't really care about the meaning; I just want the FFI to work
14:08:29 <monochrom> http://groups.google.com/group/comp.lang.functional/browse_thread/thread/6179df438bd4138d/17520bdd236b3351?lnk=st&q=&rnum=1#17520bdd236b3351
14:08:32 <lambdabot> Title: Google Groups: comp.lang.functional, http://tinyurl.com/yxqg4p
14:08:34 <Cale> But if you want, you can use Ptr ()
14:08:51 <monochrom> That's something I posted some time ago, somewhat related to the present subject.
14:09:12 <pejo> l
14:09:15 <monochrom> Someone thought that verbose was good because "one concept at a time".  I mocked him.
14:11:02 <MP0> finally, lambdabot built... after a bit of tweaking
14:11:14 <monochrom> Two major uses of void* in C.  Existential type.  Crossing abstraction boundaries.
14:11:40 <monochrom> Perhaps can be merged to one: poor man's polymorphism.
14:11:41 <Philippa_> memory blocks, too
14:11:55 <Philippa_> if it's *just* a memory block and that's your level of abstraction, it's a void *
14:12:24 <Philippa_> of course, you have to cast it to look inside :-)
14:13:00 <monochrom> Thus it is completely untrue that "it's just void*, it can be anything".  Dude, "anything" is a tall order.
14:13:23 <mauke> any C value can be represented as an array of bytes
14:13:26 <mauke> problem solved
14:14:07 <Philippa_> yes, but that doesn't mean its actual representation is one
14:14:17 <mauke> Cale: I can't just introduce a new type because then it wouldn't match the type of the external C function
14:14:24 <Philippa_> it can be represented within one, sure. We call this the "address space"
14:14:38 <Cale> mauke: it doesn't have to match it exactly
14:14:42 <mauke> I thought we called it "object representation"
14:15:00 <mauke> Cale: then how does the FFI know what conversions to apply?
14:15:04 <Cale> mauke: there are lots of rules for what Haskell types a C type can be mapped to
14:15:15 <lisppaste2> metaperl  annotated #30573 with "peculiar type error right at top of my program" at http://paste.lisp.org/display/30573#5
14:15:44 <Philippa_> oh, wait, yeah. OK, C values do tend to all occupy contiguous space. Doesn't apply to some other domain's concept of value mapped into C. The difference between a linked list (there being no such thing in C) and a node
14:16:19 <Cale> metaperl: there is no bug in that code
14:16:31 <mauke> > zip ['A'..'Z'] [1 ..]
14:16:32 <lambdabot>  [('A',1),('B',2),('C',3),('D',4),('E',5),('F',6),('G',7),('H',8),('I',9),('J...
14:16:33 <metaperl> ok it must be further down then
14:16:46 <metaperl> but that error is generated
14:16:50 <metaperl> what does 3:32 mean
14:16:54 <mauke> what zip is in scope there?
14:17:02 <monochrom> Imperative programming is about missing the whole program for the individual statements.
14:17:17 <shapr> yeah!
14:17:17 <mauke> metaperl: line:column
14:17:34 <Cale> metaperl: add a proper type signature to alpha_numbers
14:17:38 <lisppaste2> metaperl annotated #30573 with "my whole program..." at http://paste.lisp.org/display/30573#6
14:17:47 <Cale> alpha_numbers :: [(Char, Integer)]
14:17:54 <Cale> and then see where the error moves to
14:18:03 <Cale> er
14:18:09 <Cale> yes
14:18:55 <Cale> t.hs:34:26:
14:18:55 <Cale>     Couldn't match `Integer' against `Char'
14:18:55 <Cale>       Expected type: Integer
14:18:55 <Cale>       Inferred type: Char
14:18:55 <Cale>     In the first argument of `a_given_b', namely `x'
14:18:56 <Cale>     In the first argument of `(:)', namely `a_given_b x'
14:19:02 <Cale> it changes to that
14:19:11 <metaperl> yes, I'm clear now.... a_given_b is not given an Integer
14:19:20 <metaperl> I think read is in order
14:22:39 <mauke> I wonder why hsc2hs has #size, but not #alignment
14:22:43 <lisppaste2> metaperl annotated #30573 with "Integer versus Int problem (at very bottom)" at http://paste.lisp.org/display/30573#7
14:23:06 <Cale> metaperl: Okay, then [(Char, Int)]
14:27:43 <MP0> is altdata deprecated by plugins?
14:29:44 <metaperl> Cale - that just creates a different error
14:31:52 <Cale> which one?
14:34:08 <metaperl> fixed it
14:34:19 <metaperl> how does Int differ from Integer?
14:34:29 <Cale> Int is a machine integer
14:34:46 <Cale> Integer allows for arbitrarily large numbers
14:34:50 <Cale> > 2^100
14:34:52 <lambdabot>  1267650600228229401496703205376
14:34:55 <Cale> > 2^500
14:34:56 <lambdabot>  3273390607896141870013189696827599152216642046043064789483291368096133796404...
14:35:04 <Cale> > product [1..100]
14:35:06 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
14:35:16 <Cale> > product [1..100] :: Int
14:35:18 <lambdabot>  0
14:35:20 <metaperl> not only is the word "Int" smaller than the word "Integer" but it is also only capable of holding a smaller set of integers :)
14:35:26 <Cale> yeah
14:39:06 <newsham> > let sod = sum.(map (read.return)).show in (sod.sod.sod) (5555^5555)
14:39:09 <lambdabot>  5
14:40:01 <yaxu> I'm getting this kind of thing from wxhaskell, any one got some clues?
14:40:10 <yaxu> Loading package wxcore-0.9.4 ... can't load .so/.DLL for: wxc-gtk2.4.5-0.9.4 (/usr/lib/libwxc-gtk2.4.5-0.9.4.so: undefined symbol: _ZN10wxGLCanvas11SwapBuffersEv)
14:40:26 <kpreid> newtype Integ = Integ Integer; instance Num Integ where fromIntegral i = i `mod` (10^100) -- :-)
14:40:29 <Syzygy-> yaxu: AVI for the latest demo? *pokes*
14:40:45 <yaxu> sure one sec
14:40:46 <xerox> Hiya newsham.
14:41:33 <yaxu> http://yaxu.org/haskell2.avi
14:41:50 <Syzygy-> thanks
14:43:23 <newsham> Setup.hs: cannot satisfy dependency regex-compat-any
14:43:28 <newsham> what do I need?
14:45:53 <yaxu> Syzygy-: source as well?
14:46:39 <xerox> yaxu: i can't hear it properly I think
14:46:43 <xerox> but the coding looks nice
14:47:08 <yaxu> heh
14:47:27 <xerox> You use line <- readline "> " ?
14:48:20 <yaxu> xerox: should sound like hand drums
14:48:48 <yaxu> xerox: yes
14:48:53 <xerox> cool.
14:49:10 <yaxu> i'll try to extract an mp3
14:49:10 <xerox> what does it need to be set up to produce sound?
14:49:20 <yaxu> supercollider
14:49:34 * xerox investigates
14:49:36 <yaxu> and some samples
14:49:40 <Syzygy-> yaxu: I'll poke you again later if I want it. :)
14:49:48 * Syzygy- needs to sleep. I'll watch the clip tomorrow.
14:50:01 <yaxu> source is here anyway http://yaxu.org/hs20061124/
14:50:02 <lambdabot> Title: Index of /hs20061124
14:50:03 <xerox> No supercollider in the ports.
14:50:19 <xerox> Make it a darcs repository!
14:50:34 <xerox> It becomes easier to get it.
14:50:38 <yaxu> xerox: ok :)
14:51:01 <xerox> Are you comfortable with darcs?
14:51:09 <yaxu> have only done darcs get so far
14:51:50 * xerox waits anxiously until he can pull
14:51:51 <newsham> so i found regex-compat on darcs.haskell.org/packages
14:51:54 <dcoutts> hia xerox, looking for something to do? ;-)
14:51:57 <newsham> and it depends on regex-base which is also there
14:52:02 <newsham> but it depends on "base >=2.0"
14:52:03 <newsham> wtf is that?
14:52:06 <yaxu> does darcs need dav?
14:52:13 <xerox> dcoutts, I'm not *sure*... thought it might seemed so.
14:52:16 <xerox> yaxu: nope.
14:52:26 <dcoutts> xerox, there's the cairo updates :-)
14:52:27 <xerox> dcoutts, this music stuff is pretty exciting :)
14:52:32 <dcoutts> oh yes?
14:52:35 <dcoutts> what's that?
14:52:36 <newsham> i'm trying to build happs which says it just needs haxml and ghc.
14:52:38 <xerox> yeah, did you see the video?
14:52:43 <MP0> base 2.0 comes with ghc 6.5
14:52:47 <xerox> http://yaxu.org/haskell2.avi
14:52:49 <xerox> yaxu++
14:52:51 <newsham> i have ghc6.4
14:52:51 <dcoutts> xerox, the live mixing thing?
14:52:56 <xerox> yep!
14:52:57 <newsham> i have to upgrade ghc now?
14:53:28 <MP0> well, before the regex stuff was built into base
14:53:32 <dcoutts> newsham, what version do you have now ?
14:53:39 <MP0> but then they moved it out into regex-base and regex-compat
14:53:41 <newsham> i dont even see a 6.5.  the site lists 6.4.2 and 6.6
14:53:54 <dcoutts> newsham, 6.5 was a dev version you don't want it.
14:54:00 <newsham> GHC Interactive, version 6.4.2
14:54:08 <xerox> I don't know if I am any good at making music, since I never done it before, but programming it gives a totally new shiny nice view on the thing.
14:54:45 <yaxu> xerox: i extracted an mp3 to http://yaxu.org/haskell2.mp3
14:55:08 <MP0> hey xerox, did you ever get a solution to " fd:6: hClose: resource vanished (Broken pipe)"
14:55:20 <MP0> in local lambdabot?
14:55:35 <xerox> MP0: lambdabot itself does that?
14:55:50 <newsham> *sigh*
14:55:54 <newsham> i gotta build ghc6.6 now
14:55:57 <MP0> yeah
14:56:03 <MP0> lambdabot> > 1+2
14:56:04 <MP0>  fd:6: hClose: resource vanished (Broken pipe)
14:56:18 <MP0> I noticed you complained about the same thing here: http://tunes.org/~nef/logs/haskell/06.07.11
14:56:24 <xerox> MP0: ah.
14:56:33 <dcoutts> yaxu, interesting rhythm
14:56:34 <yaxu> xerox: what os are you using?
14:56:41 <xerox> MP0: I think I didn't get around that.
14:56:45 <xerox> yaxu: OS X
14:57:10 <xerox> QuickTime refused to play it, VLC played it but I don't think it was the right sound.
14:58:09 <xerox> OK, it probably was the right sound..
14:58:15 <yaxu> thought as much :)
14:59:34 <yaxu> xerox: should be easy to find a binary for os x, just make sure you get supercollider server
14:59:47 <xerox> okie.
15:00:26 <xerox> http://www.audiosynth.com/SCserver-screen3.jpg
15:00:28 <xerox> looks nice
15:00:29 <lambdabot> http://tinyurl.com/yhhuu9
15:01:42 <yaxu> it's a great language
15:01:53 <yaxu> fantastic piece of software really
15:02:34 <Excedrin> that url is forbidden
15:02:56 <yaxu> Excedrin: yeah you have to follow the link from http://www.audiosynth.com/
15:02:57 <lambdabot> Title: The SuperCollider Home Page
15:05:53 <yaxu> xerox: to get my haskell running you'd need my crappy supercollider patch running http://yaxu.org/broken.sc and these samples http://freesound.iua.upf.edu/packsViewSingle.php?id=1472
15:06:49 <xerox> yaxu, allright, I will try
15:07:03 <xerox> Now heading to bed though, busy day :)
15:07:13 <newsham> http://www.thenewsh.com/%7Enewsham/x/machine/mand3_1.jpg http://www.thenewsh.com/%7Enewsham/x/machine/mand3_2.jpg http://www.thenewsh.com/%7Enewsham/x/machine/mand3_3.jpg
15:07:16 <lambdabot> http://tinyurl.com/yxxrsg
15:07:26 <yaxu> night!
15:29:30 <glguy> ‡∏≠‡∏¢‡∏≤‡∏Å‡πÉ‡∏´‡πâ‡πÉ‡∏ô‡∏ä‡πà‡∏≠‡∏á   pop quiz, what language might htis be?
15:30:19 <pkhuong> glguy: thai.
15:31:42 <glguy> thanks
15:32:09 <newsham> is that the programming language used by financial people?
15:32:29 <pkhuong> newsham: j and k are all ascii, IIRC.
15:32:32 <glguy> APL?
15:32:36 <MP0> Malasian?
15:32:50 <glguy> pkhuong: correct :)
15:33:04 <MP0> Thai?
15:33:13 <glguy> correct about J and K
15:33:20 <glguy> I have no idea what language that is :)
15:33:20 <newsham> isnt that askk?  tihs is what I see:  <glguy> a,-a,ca,2a,?a1?a,<a1?a1?a,?a,?a1?a,-a,?   pop quiz, what language
15:33:25 <newsham> ascii
15:33:45 <glguy> newsham: those were UTF-8 encoded chars
15:33:50 <newsham> i see.
15:33:50 <MP0> something similar to this is what I see: http://www.omniglot.com/writing/thai.htm
15:33:52 <lambdabot> Title: Thai language, alphabet and pronunciation
15:33:55 <newsham> i'm using ircII
15:53:03 <dons> ?users
15:53:04 <lambdabot> Maximum users seen in #haskell: 276, currently: 254 (92.0%), active: 28 (11.0%)
15:53:31 <MP0> hey dons, runplugs doesn't work for me. I noticed you said something about ShowQ not being built
15:54:37 <MP0> I added "Other-modules:       ShowQ" to the runplugs stanza of lambdabot.cabal
15:56:32 <dons> what ghc versoin?
15:56:36 <MP0> 6.5
15:56:44 <dons> are you using the lambdabot.cabal.plugins file?
15:56:48 <dons> its needed to get runplugs
15:56:49 <MP0> yes
15:56:56 <dons> hs-plugins installed?
15:56:58 <MP0> yes
15:57:27 <dons> building using the ./build script?
15:57:35 <dons> which contains the line: ghc -v0 -c -O2 -odir . -hidir . scripts/ShowQ.hs
15:57:52 <Lemmih> Good morning, #haskell.
15:57:56 <dons> everyone: today's link: http://programming.reddit.com/info/sbt8/details
15:57:58 <lambdabot> Title: Haskell binding to Python interpreter and libraries (reddit.com), http://tinyurl.com/ybe6go
15:57:59 <dons> good morning Lemmih
15:59:45 <MP0> That's probably the problem, dons, I forgot to use "build" instead of "runhaskell Setup.hs" after installing so many packages. I'll try again!
15:59:54 <dons> ok. great
16:00:20 <pejo> dons, what usage for that, to embed a Python interpreter in your hsakell programs?
16:00:56 <dons> to use python libraries, I suspect
16:01:34 <dons> e.g. http://quux.org:70/devel/missingpy/html/MissingPy.AnyDBM.html
16:01:37 <lambdabot> http://tinyurl.com/y484f8
16:05:45 <MP0> I did a clean build, now it's runplugs: Ix{Int}.index: Index (1024) out of range ((0,30))
16:06:58 <dons> ghc 6.5 only works for versions earlier than July or so
16:07:05 <dons> before the .hi file format changed
16:07:13 <dons> ?version
16:07:14 <lambdabot> lambdabot 4p272, GHC 6.5 (OpenBSD i386)
16:07:14 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
16:07:17 <dons> for example, Jun 9
16:07:51 <dons> easiest, till hs-plugins is ported to 6.6, is to use ghc 6.4.2 for runplugs
16:09:16 <MP0> it seems pretty complicated to compile and load in haskell code.
16:12:08 <dons> markha: you just need hs-plugins
16:12:12 <dons> MP0: sorry
16:12:26 <dons> MP0: but that implies using ghc < 6.5 (since hs-plugins isn't ported to the new .hi file format)
16:12:29 <MP0> eh, it's no problem, it's just interesting.
16:12:42 <vincenz> whoops
16:12:49 <vincenz> I slightly spammed planet haskell
16:12:53 <MP0> yeah, I'm kinda at the mercy of whoever ported GHC to OS X intel
16:16:04 <Cale> I like how the "Click here to toggle visibility" has been turned into plaintext.
16:17:34 <Cale> Also how the top 3 articles have nothing at all to do with Haskell :)
16:20:35 <kfish> morning all
16:23:27 <oskimura> good morning
16:26:22 <dons> Cale: i think the more group cohomology articles the better
16:26:45 <dons> though might create a weird impression about haskell. then again, recruiting more maths guys would be good
16:27:24 <dons> Cale: you seen the matroids textbook in haskell?
16:27:56 <dons> http://www.bookzilla.de/shop/action/productDetails;jsessionid=fdc-3im7hb88d3c.www12?aUrl=90006951&artiId=4435822
16:27:59 <lambdabot> Title: Bookzilla.de - Juergen Bokowski: Computational Oriented Matroids, http://tinyurl.com/ufodm
16:34:52 <dcoutts> dons, so we missed the lazy lines bug because we didn't have a quick check for that one ?
16:36:51 <dons> dcoutts: i think so, yes
16:37:28 <dons> oh, i see .Lazy.Char8.lines is fairly tricky
16:41:06 <dcoutts> aye, it's quite performance sensitive
16:41:08 <dons> (tricky as in 1 page of code :)
16:41:12 <dcoutts> :-)
16:41:29 <dcoutts> it's split into the common and general cases
16:41:35 <dons> yep
16:53:48 <Saizan> hi, is it possible to load (and "reload") some modules programmatically at runtime within a compiled application?
16:55:16 <Lemmih> Saizan: Not really.
16:55:35 <dons> Lemmih: ?
16:55:41 <Saizan> so?
16:55:57 <dons> Saizan: hs-plugins does this. It's a dynamic linker you're describing, right?
16:56:07 <dons> ?where hs-plugins
16:56:08 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
16:56:29 <Saizan> uhm yes
16:56:32 <dons> you'll need ghc 6.4.x though (not yet ported to ghc 6.6)
16:57:12 <Lemmih> Perhaps I misunderstood. I read it as recompiling modules statically linked with the application.
16:57:13 <dons> Saizan: what kind of application are you thinking for this?
16:57:37 <dons> yes, dynamically link the modules you want to swap out at runtime
16:58:19 <Saizan> dons: an irc bot with a central core and additional plugin to specify its commands
16:58:32 <Saizan> event-driven..
16:58:39 <dons> you mean like lambdabot? :)
16:58:52 <dons> there's papers on this stuff. check out the hs-plugins web site
16:58:54 <Saizan> yes :D
16:59:20 <dons> lambdabot consists of a central core, some 4k loc, and 85 or so plugin modules that are swappable at runtime
16:59:37 <Saizan> actually i'm searching something to do in haskell to learn the language, and writing a ircbot helped me with python, so..
16:59:37 <dons> Saizan: you've seen the simple irc bot tutorial?
16:59:47 <Saizan> yes
16:59:54 <dons> yes, i recommend writing an irc bot.
17:00:08 <dons> adding plugin support for the commands should be fairly easy
17:00:20 <dons> based on http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
17:00:23 <lambdabot> Title: Roll your own IRC bot - HaskellWiki, http://tinyurl.com/y4prf8
17:00:28 <dons> ask here if you want more advice/get stuck
17:01:11 <dons> and there's also the lambdabot src for hints and inspiratoin
17:01:16 <dons> ?version
17:01:17 <lambdabot> lambdabot 4p272, GHC 6.5 (OpenBSD i386)
17:01:17 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:02:03 <Saizan> i've browsed the sources briefly, the IRC module the most
17:03:10 <Saizan> mmh I'm wondering how to keep some state local to each plugin
17:03:41 <dons> you can define a Module class, with an associated state type
17:03:49 <dons> then provide an instance of Module for each plugin
17:03:55 <dons> which will encapsulate some hidden state type
17:04:12 <dons> e.g.
17:04:13 <dons> class Module m s | m -> s where
17:04:35 <dons> where for some plugin 'm', there is an associated (hidden) state type 's' unique to that plugin
17:05:04 <dons> for exampe:
17:05:08 <dons> type KarmaState = M.Map String Integer
17:05:12 <dons> instance Module KarmaModule KarmaState where
17:05:22 <dons> hides a map of names to numbers inside the Karma module
17:06:33 <Saizan> and it survives through the "listen-parse-call" cycle?
17:11:50 <Fhran> hi?
17:12:06 <Lemmih> hello?
17:12:21 <Fhran> hi Lemmih, i'm from Argentina...
17:12:46 <Lemmih> Hiya, I'm from Denmark.
17:12:47 <Fhran> and I'm preparing a Haskell inform for college
17:14:00 <MP0> @google haskell inform
17:14:03 <lambdabot> http://swik.net/Haskell+linux
17:14:07 <dons> Fhran: welcome
17:14:15 <dons> we also have a spanish channel, #haskell.es
17:14:24 <dons> Fhran: feel free to drop by
17:14:33 <Fhran> dons: thanks
17:14:58 * yaxu reads lambdabot's quote database
17:15:34 <Lemmih> ?quote
17:15:35 <lambdabot> goltrpoat says: Lemma: three cats chasing a deranged cricket all over the living room at 4am does not provide for a good reading environment
17:18:02 <Saizan> uhm, a good haskell IDE? I'm using EMACS with haskell-mode but it's not much different from vi+ghci
17:19:59 <dons> vim + ghci or emacs are usually preferred
17:20:14 <dons> windows people can try Visual Haskell or Eclipse (and WinHugs)
17:21:41 <Saizan> I've not enough ram to use Eclipse for long :)
17:23:52 <dons> i'd stick with vim or emacs: the majority of good hackers would probably agree
17:24:26 <pkhuong> dons: the majority of good hackers would also disagree.
17:24:51 <dons> :)
17:25:01 * dons takes a stab at controversy
17:25:33 <dons> emacs with haskell-mode seems to work fine for SPJ, amongst others, so it can't be too bad
17:26:35 <kfish> dons: what color is your vim?
17:26:54 <dons> hmm?
17:27:21 <Saizan> I hate the ":r" thing :D
17:27:38 <hyrax42> C-c C-l
17:27:42 <Saizan> :O
17:27:52 <hyrax42> or you could add it to a hook somewhere probably
17:27:53 <Saizan> in src buffer?
17:27:57 <hyrax42> yeah
17:27:58 <kfish> dons: if you're going to start an editor controversy, we may as well cut straight to the futile
17:28:02 <hyrax42> but some headaches to get it to work
17:28:07 <hyrax42> at least for me
17:28:13 <hyrax42> it insisted on opening in hugs when I wanted ghci
17:28:19 <hyrax42> and then the opposite when I wanted the opposite
17:28:32 <Saizan> good,,
17:29:06 <hyrax42> but C-c C-l will save if necessary, create a *haskell* buffer if necessary, launch your interpreter if necessary in that buffer
17:29:15 <hyrax42> and (re)load the file in there
17:29:52 <hyrax42> so if you keep that buffer visible downstairs, it's almost as good as mucking about in lisp/scheme
17:30:16 <Saizan> but, more importantly, where is a doc for the standard library that explains a little more the semantics?
17:30:19 * hyrax42 finds development in languages without a REPL of some kind *incredibly* frustrating
17:30:33 <hyrax42> Saizan: huh?
17:30:40 <hyrax42> standard library of?
17:30:40 <dons> kfish: here you go :) http://www.cse.unsw.edu.au/~dons/tmp/vim.png
17:31:02 <kfish> heh
17:31:03 <Saizan> of haskell/ghc
17:31:09 <kfish> what's that window manager you run called?
17:31:18 <newsham> which wm is that?
17:31:34 <dons> dwm
17:31:47 <Saizan> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html <-- I'm talking about this, for example, it's a little cryptic for a newbe (for me at least)
17:31:49 <lambdabot> http://tinyurl.com/yy4aqu
17:31:52 <newsham> looks sorta plan9-ish
17:32:10 <dons> http://dwm.suckless.org/
17:32:12 <lambdabot> Title: suck less
17:32:26 * dons notes there's an advert for the plan9 conference on the dwm main page
17:32:40 <pejo> Saizan, theres a bunch of monad tutorials around
17:33:01 <dons> Saizan: yeah, you got YAHT? and seen haskell.org's tutorials page?
17:33:03 <pejo> Saizan, and Mark P. Jones has a couple of articles from 95 for some summer school on his homepage.
17:33:05 <dons> ?where yaht
17:33:05 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
17:33:19 <dgriffi3> dons: why dwm?
17:33:28 <newsham> looks like it was influenced by rio/acme
17:34:08 <newsham> why are people gonna write WMs in haskell?
17:34:09 <dons> dgriffi3: smaller faster than ion and wmii. less silly config stuff i don't use
17:34:21 <dons> newsham: why, cause its fun and we have x11 bindings
17:34:28 <Saizan> I've seen the tutorials(, by the way the most enlighting was that on Neighborhood of Infinity)
17:34:41 <dons> dwm is 1800 lines of C, so I think we could do that in say 600 lines of haskell
17:34:52 <dons> given the existing Xlib binding
17:35:17 <newsham> s/why/when/
17:35:24 <newsham> typo
17:35:25 <dons> when not?
17:35:39 <dons> (we've been talking about here for a couple of months)
17:35:55 <newsham> are the x11 bindings ffi to the X libs, or socket calls to the X protocol?
17:36:04 <dons> you've got both, afaik
17:36:09 <newsham> cool.
17:36:27 <newsham> i would like to see more native code and less bindings-to-underlying-C-lib.
17:36:28 <kfish> then it shouldn't be too hard to port the example in Xlib vol 1
17:36:39 <dons> newsham: please write some :)
17:36:43 <pejo> kfish, there's a complete window manager there?
17:36:46 <newsham> when will someone write a good SSL impl in haskell? :)
17:36:53 <kfish> pejo, a minimal one
17:37:16 <dons> newsham: all you need is to follow: http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
17:37:18 <lambdabot> Title: How to write a Haskell program - HaskellWiki, http://tinyurl.com/yxe296
17:38:08 <kfish> i was with raster when he bough xlib vol1 at the unsw bookstore. He sat down outside, found the chapter on writing a wm (which starts "only crazy people write wms") and decided to write enlightenment
17:38:10 <newsham> *nod* saw that.. also wrote a cabal config for HWS
17:38:38 <newsham> ruby snorts rails
17:38:49 <dons> kfish: nice.
17:38:55 <newsham> if ruby keeps it up ruby will kill itself.
17:39:09 <psykotic> there are plenty of example WMs around with varying levels of features/complexity
17:39:14 <pejo> Of course we'd want a pluggable wm in Haskell. *cough*dons*cough*.
17:39:15 <Saizan> kfish: ask him if e17 will ever become stable :D
17:39:32 <newsham> isnt enlightenment the really nice looking WM that crashed all the time and took up gigs of ram?
17:39:33 <kfish> Saizan, haha
17:39:51 <newsham> enlightenment is for hollywood, not for the desktop
17:39:58 <pejo> newsham, I tend to crash most stuff, including twm. But I didn't manage to crash E when I tried it.
17:40:19 <Saizan> newsham: I used it and it was very stable and light
17:40:31 <kfish> newsham, the earlier form (a fork of fvwm) was, but the versions since about 1999 are ok ...
17:40:43 <newsham> i havent used it since 1998
17:40:50 <newsham> no.. wait.. i used it in 2000
17:40:54 <Saizan> I couldn't achieve to compile his file manager though
17:41:11 <Saizan> *its
17:41:21 <kfish> and since then gnome etc. have taken the bloat crown and run with it
17:41:39 <newsham> thats the great thing about bloat.. there's always someone willing to take up the torch!
17:41:50 <newsham> write something small and efficient and good luck finding someone to carry that on
17:42:25 <psykotic> http://twb.ath.cx/~twb/hack/SCRATCHPAD/c/tinywm/tinywm-haskell.hs
17:42:27 <lambdabot> http://tinyurl.com/yg32zx
17:42:29 <kfish> the canvas lib that E17 uses (evas) is really nice
17:43:11 <kfish> iirc ChilliX started some haskell bindings ...
17:43:28 <dons> yeah
17:43:44 <dons> psykotic: also, there's the House WM
17:44:47 <Saizan> link?
17:45:03 <Svrog> ?unpl test = (. ((readFile =<<) . peekCAString)) . ((=<<) . ((flip (liftM2 (>>)) test3) . test2 . fromIntegral))
17:45:04 <lambdabot> test l ad
17:45:04 <lambdabot>  = ((peekCAString ad) >>= readFile) >>=
17:45:04 <lambdabot>    ((test2 (fromIntegral l)) >>=
17:45:04 <lambdabot>      \ g -> test3 >>= \ h -> return (g >> (>>)))
17:45:19 <dons> nice
17:45:20 <Svrog> ?pl test n s = do { c <- peekCAString s >>= readFile; test2 (fromIntegral n) c; test3 c }
17:45:21 <lambdabot> (line 1, column 15):
17:45:21 <lambdabot> unexpected "{"
17:45:21 <lambdabot> expecting variable, "(", operator or end of input
17:45:45 <newsham> http://twb.ath.cx/~twb/hack/SCRATCHPAD/c/tinywm/tinywm-haskell.hs
17:45:46 <newsham> http://twb.ath.cx/~twb/hack/SCRATCHPAD/c/tinywm/tinywm-haskell.hs
17:45:46 <lambdabot> http://tinyurl.com/yg32zx
17:45:47 <lambdabot> http://tinyurl.com/yg32zx
17:45:52 <newsham> http://twb.ath.cx/~twb/hack/SCRATCHPAD/c/tinywm/tinywm-haskell.hs
17:45:53 <lambdabot> http://tinyurl.com/yg32zx
17:45:54 <dons> newsham: ?
17:46:03 <dons> gone insane?
17:46:37 <Svrog> ?pl test n s = do { x <- peekCAString s; c <- readFile x; test2 (fromIntegral n) c; test3 c }
17:46:38 <lambdabot> (line 1, column 15):
17:46:38 <lambdabot> unexpected "{"
17:46:38 <lambdabot> expecting variable, "(", operator or end of input
17:46:39 <dons> Saizan: http://programatica.cs.pdx.edu/House/
17:46:40 <lambdabot> Title: House
17:46:46 <Svrog> huh
17:46:47 <dons> Svrog: perhaps in a privmsg to lambdabot?
17:46:48 <newsham> eek.. sorry.
17:46:53 <Svrog> oh
17:46:54 <Svrog> sorry
17:47:02 <newsham> i musta hit the mouse buttons
17:47:29 <Saizan> thanks, google wasn't helping
17:48:01 <dons> that's kernel, drivers, userland all in haskell, on top of the ghc runtime on bare metal
17:48:02 <Svrog> im getting the hang of this pointfree thing :)
17:48:27 * dons wonders why there's no lispOS but there's two Haskell OSs in the last 2 years..
17:48:51 <Excedrin> movitz?
17:48:52 <Saizan> for those who say that to write OS you have to use C?:D
17:48:56 <dons> haskell's rise coinciding with the high assurance/verfication movement in the OS world
17:49:14 <psykotic> imo something like minix3 for the core is fine to have in c.
17:49:17 <psykotic> (it's 3000 lines of code)
17:49:34 <dons> yeah, like having the ghc rts underneath
17:49:45 <Svrog> whats the 2nd haskell os? ive only heard of house
17:49:48 <newsham> dons: http://www.unlambda.com/cadr/index.html ?
17:49:50 <lambdabot> Title: Retrocomputing - MIT CADR Lisp Machines
17:49:50 <lispy> whoa, how long have we had unpl?
17:49:55 <dons> house and the L4/verified project.
17:50:10 <lispy> ?unpl fst
17:50:10 <lambdabot> fst
17:50:12 <newsham> sel4 is not entirely a haskell OS
17:50:16 <Svrog> oh
17:50:17 <newsham> its an OS prototyped in haskell.
17:50:18 <Svrog> cool
17:50:25 <lispy> ?unpl fst . map snd
17:50:26 <lambdabot> (\ c -> fst (map snd c))
17:50:35 <dons> newsham: the "prototype" runs though :)
17:50:42 <dons> http://haskell.org/haskellwiki/Research_papers/Program_development#Operating_systems
17:50:43 <newsham> most prototypes do :)
17:50:44 <lambdabot> Title: Research papers/Program development - HaskellWiki, http://tinyurl.com/y4929f
17:50:51 <newsham> i think you mean "the spec runs"
17:50:58 <newsham> which is more impressive :)
17:51:03 <dons> yeah, running the manual
17:51:21 <newsham> i've written several prototypes that run, but none of my specs run
17:52:56 <pejo> Svrog, OsKer, L4 implementation afaik.
17:53:14 <psykotic> dons: do any of these projects use hutton's asynchronous exception work?
17:53:31 <psykotic> (the "what is with these constant interruptions" paper)
17:53:36 <Svrog> ah
17:53:54 <dons> psykotic: hmm, not sure. they probably use ghc's async exceptions
17:53:55 <Saizan> (there's an howto on disinfesting a CS course infected by Java?:D)
17:54:46 <dgriffi3> Saizan: link?
17:55:02 <Saizan> to what?
17:55:05 <pejo> dons, boggle, there is an endless amount of OS' written in Haskell now.
17:55:26 <dgriffi3> < Saizan> (there's an howto on disinfesting a CS course infected by Java?:D)
17:55:31 <dcoutts> go Udo!
17:55:32 <dcoutts> http://www.haskell.org/pipermail/libraries/2006-November/006488.html
17:55:34 <lambdabot> Title: base libraries, http://tinyurl.com/tcy9l
17:55:50 <dcoutts> that discussion is getting a little silly
17:55:55 <dons> yes
17:56:02 <dons> I think Bulat's gone a bit awol.
17:56:10 <dcoutts> heh heh :-)
17:56:15 <Saizan> err, misstyped "is there", it was a question
17:56:24 <dgriffi3> ahh, my bad
17:56:24 <fincher> there's a paper out there somewhere that goes through higher-order functions in order (first-order, second-order, third-order, etc.) giving examples up until sixth- or seventh-order.  Anyone remember it and have a link?
17:57:07 <dcoutts> dons, did you seriously find that [Char] was a bottleneck in hmp3 for command line params and file names ?
17:57:37 <dcoutts> I have to say, I do get nervous when people suggest an IsString class or similar things
17:57:42 <dons> dcoutts: I'm reminded of the 'protect the community' page about people who display:  Noisy minority,  Unable to pick up on the "mood" of the community,  Doesn't understand the common goals of the community.
17:57:54 <dcoutts> aye
17:57:56 <dons> dcoutts: re. hmp3, yes, but I was passing 8000 strings as arguments
17:57:59 <dons> :)
17:58:04 <dcoutts> fair enough :-)
17:58:39 <dcoutts> dons, so what does one do? Ask certain individuals for less talk and more code?
17:59:05 <dons> well, we should probably ignore some of the flame bait , and offer guidance
17:59:11 <dons> but i'm not sure how effective that would be
17:59:24 <dons> the personal style is too abrasive (poor SvenP for example)
17:59:25 <dcoutts> yeah, I'm as guilty as anyone of taking the bait
17:59:51 <dons> too much of a tendancy to prescibe big changes, and offer no follow up code
17:59:57 <dons> its bikeshed territory
18:00:09 <dcoutts> yeah
18:00:29 * lispy doesn't usually listen to Udo because he's usually so rude
18:01:28 <dcoutts> http://www.haskell.org/pipermail/libraries/2006-November/006474.html
18:01:31 <lambdabot> Title: base libraries, http://tinyurl.com/szjmh
18:01:38 <dons> so yes, we're seeing basically some radical new proposal in each mail from this certain individual
18:01:50 <dons> without follow up code, or practical though on the consequences
18:02:03 * dcoutts likes the "mad programming skillz" comment
18:02:07 <dons> so most likely silence is better treatment.
18:02:10 <dons> dcoutts: right.
18:03:25 <dcoutts> it's difficult as half of what he says is true
18:03:27 <dons> i guess this is what happens as the community grows, and people come to the language from other than 8 years of haskell schooling at the old lambda universities. there's a less coherent vision of the road ahead.
18:03:54 <dcoutts> he does make legitimate points
18:03:58 <dons> he does
18:04:13 <Saizan> lambda universities?
18:04:18 <dons> the style is just too coarse grained though, meaning he's unlikely to get community consensus
18:04:25 <dcoutts> yes
18:04:40 <dons> Saizan: joke about half the haskell devs having gone to chalmers, cambridge, oxford, unsw, .. (places they teach haskell from first year)
18:04:41 <dcoutts> Saizan, universities that indoctrinate you in the way of the lambda.
18:06:05 <lispy> in darcs features don't get added unless the user proposing them implmentents it and then negotiates/iterates the details with the maintainer ;)
18:06:12 <Saizan> and i've to stick with Java..
18:06:26 <lispy> Saizan: me too, i'm at a Java school
18:06:34 <Botty> wow, imagine if all the unis taught it first year
18:06:38 <dcoutts> you poor things
18:06:51 <MP0> Java isn't so bad
18:06:55 <dcoutts> at least I only have to teach Java, not actually code anything in it
18:07:00 <lispy> dcoutts: i can barely write java programs though, because i only used it for classes that required it :)
18:07:17 <dcoutts> yeah, me too :-)
18:07:56 <Saizan> you know, to create and assign a parametric object there's often more code than the logic of the method ..
18:07:57 <lispy> i think languages like Java/VB/C# are actually really hard to program in...i can hack something together which is fragile and buggy easily...but to write a real piece of software takes so much effort
18:07:58 <dcoutts> though I do seem to be able to debug students' Java progs
18:09:07 <newsham> it seems like there are a large number of java and c# programmers who dont seem to think its hard
18:09:11 <Svrog> java is pretty horrible
18:09:32 <lispy> i do agree about one thing, it is annoying that that FPS is now in base so you can't easily write cabal files anymore, but i'm not convinced the problem is with FPS being in base...maybe it's that cabal is not mature enough
18:09:35 <Svrog> as far as oo languages go i think smalltalk and self are probably the nicest ones - probably cause they're pretty close to lisp in many ways
18:09:43 <Saizan> i don't think it's hard, it's just "in the way"
18:09:50 <dcoutts> newsham, they've probably not compared it to any really interesting programming language.
18:09:57 <Svrog> and ironically the first version of self was released at sun when they were just starting their work on java
18:10:17 <MP0> lispy: I think sun got that right, when java files go into base, they keep their old package names
18:10:39 <dcoutts> lispy, we have a proposed solution in Cabal to the problem of modules moving packages, or packages getting renamed.
18:11:19 <lispy> dcoutts: is this done with the configurations or something else?
18:11:23 <dcoutts> and a whole class of other conditional configurations stuff
18:11:27 <dcoutts> yes configurations
18:12:02 <lispy> i look forward to the day when darcs can be built with just a .cabal file
18:12:06 <dcoutts> we had a long face-to-face discussion with Igloo, JaffaCake and Ross the other week.
18:12:21 <lispy> i think when it reaches that point i'll stop saying it's not mature :)
18:13:11 <dcoutts> Igloo, btw, we need to do that next iteration on the proposal
18:13:36 <MP0> I look forward to the day when any arbitrary source code can be built without even needing a .cabal file
18:13:41 <kfish> http://hackage.haskell.org/ModHackage/Hackage.hs?action=view
18:13:44 <lambdabot> http://tinyurl.com/yynxlq
18:13:46 <dcoutts> lispy, my measure is when we can build base and Gtk2Hs with it
18:14:02 <lispy> dcoutts: no, no, darcs first ;)
18:14:13 <newsham> something like freebsd ports?  .cabal pulls in srcs and builds?
18:14:14 <dons> darcs could be done now couldn't it?
18:14:22 <kfish> ^^^ there is an error on that hackage URL
18:14:30 <dons> it uses the same build system as lambdabot, and lambdabot builds in cabal now
18:14:38 <dcoutts> dons, though probably not and have it work with several versions of ghc
18:14:40 <dons> (well, darcs has more phases in the build system these days)
18:14:46 <dons> dcoutts: fair enough
18:15:04 <lispy> dons: if we had the .cabal run the configure script it might work
18:15:17 <dcoutts> lispy, that's easy
18:15:17 <lispy> dons: but my goal is to be ride of that autotools cruft
18:15:22 <dons> cabal does run configure scripts...
18:15:23 <lispy> s/ride/rid
18:15:29 <dons> (see lambdabot)
18:15:34 <dcoutts> lispy, yeah, same here for Gtk2Hs
18:16:05 <newsham> autotools == gnu autoconfigure?
18:16:06 <lispy> and the autools stuff doesn't even work on win32 correctly, it fails to detect when things are missing and adjust for that
18:16:07 <newsham> blech.
18:16:44 <lispy> (granted that's probably user error on the side of darcs devs, but still annoing)
18:16:55 <dmead> any monad experts alive?
18:17:09 <newsham> monad expert?  phd in monology?
18:17:10 <dcoutts> lispy, yeah it's a pita, mind you I'd never have got Gtk2Hs building on win32 if it hadn't been for autotools, so it's not all bad, it's just messy.
18:17:11 <lispy> of course :)
18:17:21 <dmead> hah
18:17:21 <lispy> dcoutts: right
18:17:29 <dmead> well
18:17:34 <dmead> i'm experimenting with parsec
18:17:46 <lispy> dmead: good!
18:18:02 <dmead> and i've got it to the point where it returns the correct haskell code from a string
18:18:07 <dmead> so right now i can do
18:18:11 <Svrog> i had a go at building lambdabot and joinhs with cabal yesterday - gave up after about half an hour - cant remember what didnt work right now but i ran into heaps of problems, especially with joinhs
18:18:14 <dmead> anExpr("P->Q")
18:18:37 <dmead> and it returns the corresponding type constructors
18:18:49 * dcoutts -> sleep
18:18:52 <dmead> haha
18:18:58 <dmead> =p
18:19:01 <dmead> anyway
18:19:37 <dmead> now that i try and use it with my other logic functions, i get typing errors
18:19:47 <dmead> because i don't use monads in the rest of the code
18:20:01 <dmead> do i need to use a return statement to finish converting to my logic datatypes?
18:20:45 <newsham> depends.  what does the code that calls it look like?
18:21:10 <lispy> dmead: are you familiar with runState?
18:21:10 <dmead> anExpr a = parseTest expr a
18:21:16 <dmead> no
18:21:21 <lispy> ?type runState
18:21:23 <lambdabot> forall s a. State s a -> s -> (a, s)
18:21:32 <dmead> i should use that instead of parseTest?
18:21:34 <lispy> dmead: basically, you have a state monad, you run it and get the result
18:21:39 <dmead> ah
18:21:46 <lispy> dmead: so, you can do something similar with parsec
18:21:53 <dmead> hmm
18:21:59 <lispy> dmead: and extract the syntax tree from running your parser on some input
18:22:11 <dmead> well, my string to expression function is [Char]->IO
18:22:22 <dmead> i don't really understand how to factor out the IO
18:22:33 <dmead> so i can go back to using other Expression -> Expression functions
18:22:36 <lispy> well, why does it require IO?
18:22:37 <newsham> except for unsafe* you cant really just get rid of IO
18:23:19 <dmead> it doesn't i guess
18:23:23 <dmead> thats what it's been inferred to
18:23:45 <glguy> are you opening the file inside your parser? or reading input from the parser?
18:23:54 <glguy> (from the kyeboard)
18:24:09 <dmead> anExpr a = (parseTest expr a)
18:24:19 <glguy> ?type parseTest
18:24:21 <lambdabot> Not in scope: `parseTest'
18:24:21 <lispy> ?hoogle parseTest
18:24:22 <lambdabot> Text.ParserCombinators.Parsec.Prim.parseTest :: Show a => GenParser tok () a -> [tok] -> IO ()
18:24:30 <glguy> ?hoogle parse
18:24:31 <lambdabot> Text.ParserCombinators.Parsec.Prim.parse :: GenParser tok () a -> SourceName -> [tok] -> Either ParseError a
18:24:31 <lambdabot> Data.Version.parseVersion :: ReadP Version
18:24:31 <lambdabot> Distribution.InstalledPackageInfo.parseInstalledPackageInfo :: String -> ParseResult InstalledPackageInfo
18:24:33 <dmead> thats my function, had to fish it out of emacs
18:24:34 <lispy> dmead: ah, okay, you don't have to use parseTest
18:24:52 <dmead> lispy: what do i do instead?
18:24:59 <lispy> parse can be nice
18:25:03 <dmead> oh
18:25:04 <dmead> right
18:25:11 * lispy checks the parsec docs
18:26:15 <Svrog> runParser p filename stringToParse
18:26:18 <dmead> how hugs complains about no show function for "[Char]-> Either ParseError Expression
18:26:32 <lispy> right
18:26:32 <dmead> im not using files, and this is in hugs
18:26:50 <lispy> well, the FilePath that parse takes is meaningless here
18:26:51 <glguy> parse "name of source" "input string"
18:26:53 <lispy> just passin "
18:26:55 <dons> so you're not applying your parser to an input string?
18:27:00 <Svrog> filename can just be an empty string - it is just used for error reporting if i remember correctly
18:27:16 <dmead> i'm doing input from variables or from the hugs prompt
18:27:28 <dmead> anExpr "P->Q"
18:27:33 <dmead> gives a show function error
18:27:47 <glguy> dmead: parse myParser "" "input string"
18:27:48 <newsham> does "anExpr" take more than 1 argunent?
18:28:05 <lispy> dmead: right, so anExpr a = parse expr "" a
18:28:53 <dmead> lispy: ok that works, but now it's printing "Right" along with the correct output
18:29:06 <dmead> weird
18:29:10 <Saizan> that's the Either constructor
18:29:10 <lispy> but that's okay!
18:29:15 <glguy> Right is success, Left is error
18:29:18 <lispy> Left would be a parse error
18:29:29 <lispy> if you don't want that you could simplify it
18:29:32 <dmead> ah
18:29:49 <dmead> how?
18:29:55 * dmead is lost on monads atm
18:30:12 <lispy> anExpr a = do r <- parse expr "" a; case r of Right v -> v
18:30:32 <lispy> then it will just fail with a pattern match failure when there is a parse error
18:30:37 <glguy> case (anExpr a) of Left e -> error e; Right p -> r
18:30:38 <lispy> so it's not so great for tracking errors
18:30:49 <dmead> yea that seems preferable in general though
18:30:59 <lispy> oh yeah, sorry use glguy's :)
18:31:06 <lispy> i was thinking this was inside another monad
18:31:26 <lispy> er
18:31:27 <glguy> ?type either
18:31:28 <lambdabot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
18:31:32 <lispy> glguy: Right p -> r?
18:31:42 <glguy> yeah, whatever, so I had a typo
18:31:44 <glguy> ;)
18:31:47 <glguy> or better still
18:31:54 <glguy> either error id (anExpr a)
18:32:19 <dmead> oh
18:32:21 <dmead> k
18:32:21 <dmead> sec
18:32:41 <lispy> glguy: np, i had a typo or three as well :)
18:33:14 <Svrog> either (\err -> 'x') (\c -> c) (runParser (char 'a' <|> char 'b') () "" "a")
18:33:34 <Svrog> will print 'a'
18:33:40 <Svrog> either (\err -> 'x') (\c -> c) (runParser (char 'a' <|> char 'b') () "" "z")
18:33:50 <Svrog> will print 'x'
18:34:01 <Svrog> or rather just return 'a' or 'x'
18:34:38 <dmead> hmm
18:35:33 <Svrog> in the first case the input string is "a" and the parser only matches characters 'a' or 'b' - in case of success it will return the parsed character
18:35:55 <Svrog> in the second case parser will fail when it tries to parse "z" and the (\err -> 'x') will get triggered, returning 'x'
18:36:50 <dmead> a
18:36:51 <dmead> er
18:36:55 <Svrog> the other way you could do it is with case runParser (char 'a' <|> char 'b') () "" "a" of and then match against Left or Right like glguy said
18:37:13 <dmead> wait,,
18:37:14 <dmead> mm
18:37:17 <dmead> like this?
18:37:17 <dmead> anExpr a = do r <- parse expr "" a
18:37:17 <dmead>            case (anExpr a) of Left e -> error e
18:37:17 <dmead>                 Right p -> r
18:37:28 <lispy> no
18:37:31 <lispy> Right p -> p
18:37:40 <lispy> but actually, you don't want the do
18:38:03 <lispy> anExpr a = case (anExpr a) of Left e -> error e; Right p -> p
18:38:16 <lispy> that's all you should need as long as i didn't make another typo :)
18:38:28 <Saizan> he doesn't want the (anExpr a) in the case, i think
18:38:39 <dmead> yea
18:38:43 <dmead> error =/
18:38:57 <dmead> anExpr a = do r <- parse expr "" a
18:38:57 <dmead>            case (anExpr a) of Left e -> error e
18:38:57 <dmead>                 Right p -> r
18:39:00 <dmead> oops
18:39:02 <lispy> sorry, case (anExpr a) should be case (parse expr "" a)
18:39:46 <lispy> anExpr a = case (parse expr "" a) of Left e -> error e; Right p -> p
18:39:58 <dmead> nope =/
18:40:02 <lispy> nope?
18:40:11 <dmead> it's saying e has type parseerror
18:40:22 <dmead> which does not match [char]
18:40:24 <dmead> oh wait
18:40:30 <dmead> i'll give it a type !
18:40:52 <dmead> blah
18:41:03 <lispy> use errorMessages
18:41:15 <lispy> and showErrorMessages
18:41:20 <dmead> hmm?
18:41:42 <lispy> does this type check? Left e -> showErrorMessages (errorMessages e)
18:41:53 <lispy> er
18:41:58 <lispy> slip the error back in there
18:42:10 <lispy> Left e -> error (showErrorMessages (errorMessages e))
18:43:31 <dmead> doesn't seem like it =/
18:43:52 <dmead> just gives unexpected -> with :type
18:44:35 <lispy> ?type \e -> error (showErrorMessages (errorMessages e))
18:44:37 <lambdabot> Not in scope: `showErrorMessages'
18:44:37 <lambdabot>  
18:44:37 <lambdabot> <interactive>:1:32: Not in scope: `errorMessages'
18:44:55 <lispy> lambdabot must not have parsec imported
18:45:30 <dmead> it seems that hugs and ghc haven't kept their parsec versions syncronized
18:45:38 <Saizan> something like this?
18:45:39 <Saizan> parse source = case (Text.ParserCombinators.Parsec.parse parseExpr "" source) of
18:45:40 <Saizan> 		 Right x -> return x
18:45:40 <Saizan> 		 Left e -> throwError $ show e
18:46:05 <Saizan> uhm but here we are in a monad
18:47:11 <lispy> bleh, the documentation is wrong
18:47:14 <dmead> =/
18:47:23 <lispy> ?hoogle showErrorMessages
18:47:23 <lambdabot> Text.ParserCombinators.Parsec.Error.showErrorMessages :: String -> String -> String -> String -> String -> [Message] -> String
18:47:26 <dmead> yea the parsec docs are ancient
18:47:41 <Svrog> just do \err -> error (show err)
18:48:39 <Svrog> either (\err -> error (show err)) (\c -> putStrLn (show c)) (runParser (char 'a' <|> char 'b') () "" "z")
18:48:49 <Svrog> *** Exception: (line 1, column 1):
18:48:49 <Svrog> unexpected "z"
18:48:49 <Svrog> expecting "a" or "b"
18:48:58 <Svrog> either (\err -> error (show err)) (\c -> putStrLn (show c)) (runParser (char 'a' <|> char 'b') () "" "a")
18:48:59 <dmead> Left e ->
18:49:02 <Svrog> 'a'
18:49:02 <dmead> is the line with the problem
18:49:10 <TomMD> I was in here this morning and someone showed me what I think are fundeps: "class (Ord k) => Blah a k g | a -> k, a -> g where"  I currently don't understand what is goin on in this statement, what is this line telling the compiler?
18:49:28 <kfish> ?where lambdaTeX
18:49:29 <lambdabot> http://www.cse.unsw.edu.au/~patrykz/lambdaTeX/
18:49:38 <dmead> heres a good error...
18:49:43 <dmead> unresolved overloading
18:49:45 <lispy> TomMD: a determines k and g
18:49:51 <dmead> mondad a => a Expression
18:49:55 <dmead> anExpr "P"
18:50:03 <kfish> ?where+ lambdaTeX http://www.jantar.org/lambdaTeX/
18:50:03 <lambdabot> Done.
18:50:05 <dmead> when i do anExpr "P"
18:50:22 <dmead> i commented out the Left case
18:50:25 <dmead> and it compiles
18:50:27 <TomMD> lispy: is there a wiki on this?
18:50:54 <lispy> TomMD: so if you have two instances of Blah with the same a but different k or g it would be a type error
18:51:13 <lispy> TomMD: at least, that's how i understandit, i could be wrong
18:51:35 <lispy> TomMD: there are some research papers, but i don't know about the wiki, it's hard to search :(
18:53:12 <TomMD> lispy: ok, thanks.  I'll take it on faith for now while I hunt down an authoritative but understandable text.  When I find such a text I will e-mail you and let you know Hurd has been released and hell has frozen over.
18:53:29 <TomMD> :-)
18:53:31 <dmead> wow
18:53:40 <dmead> it worked for a second
18:53:42 <dmead> now it's broken again
18:54:11 <lispy> TomMD: i'm already on the HURD mailing list :)
18:55:10 <lispy> i removed myself a couple years ago from their list after playing with debian GNU/Hurd and yet i still get the emails...
18:55:38 <TomMD> lispy: Oh, sorry, so you wouldn't be liking that joke.  Interesting choice, I would be less surprised to hear Osker rather than Coyotos.
18:55:46 <newsham> i heard HURD will finally be ready in 1993.
18:56:06 <TomMD> oh dear, I knew the project was funky (what will STILL have a public CVS server) but gees.
18:56:12 <lispy> TomMD: i like the joke :)
18:56:49 <dmead> why are they still bothering with that =/
18:57:22 <lispy> dmead: because we don't have a good unix kernel which uses the GP....er...nevermind :)
18:57:25 <TomMD> Cause coyotos is going to be great... and we'll need to be able to use it for something besides research?
18:57:35 <dmead> =p
18:57:58 <dmead> yea. lispy
18:58:23 <newsham> is coyotos the new hurd?
18:58:33 <dmead> i can't figure out the Left e -> case
18:58:42 <dmead> but it still "works" with just right
18:59:01 <TomMD> Kind of, it is the new mico-kernel for Hurd.  The switch isn't well documented yet seeing as the web pages lag ~3 years.
18:59:05 <Svrog> i think its about time people start making os-s that are not unix clones or almost unix clones
18:59:09 <dmead> anExpr a = case (parse expr "" a) of
18:59:09 <dmead>            Right x ->   x
18:59:20 <lispy> TomMD: lol
18:59:23 <dmead> Left e -> e won't work =/
18:59:30 <newsham> svrog: there are and have been many.
18:59:47 <Svrog> only toy os-s
18:59:47 <dmead> or Left e-> showError e
18:59:48 <lispy> dmead: right, you'll have to do semithng like Left e -> error (show e)
18:59:48 <dmead> etc etc
18:59:50 <TomMD> lispy: I wasn't trying to be funny.  Sadly this makes it funny.
19:00:15 <dmead> ahh
19:00:25 <dmead> i was close =o
19:00:31 <lispy> TomMD: all i know is that recently there was all that drama on the mail list about some trollR
19:00:35 <lispy> s/R/?
19:01:09 <TomMD> lispy: I know nothing about a troll, just about the Sharpio work a little.
19:01:26 <lispy> would STM make writing a microkernel easier?
19:01:56 <dons> it might be a nice abstraction to employ
19:02:33 <dmead> weeeeee
19:02:38 <dmead> thanks lispy
19:02:42 <dmead> it fits together now :)
19:02:54 <dmead> lispy++
19:03:03 <lispy> dmead: cool, just remember, you don't handle errors and you'll want to do that some day :)
19:03:20 <dmead> from parsec you mean?
19:03:22 <TomMD> lispy: I'd ask the programatica guys that, I wouldn't know beyond a guess.
19:05:21 <lispy> dmead: if you use your version of anExpr then a parse error will essentially cause your program to crash
19:05:39 <lispy> dmead: you can think of it like this, error is throwing an exception that you don't catch
19:06:06 <dmead> but i thought thats what Left e -> is for?
19:06:59 <lispy> dmead: you're accepting the parser error, and then calling "error"
19:07:12 <lispy> > error "foo"
19:07:13 <lambdabot>  Add a type signature
19:07:18 <lispy> > error "foo" :: Int
19:07:20 <lambdabot>  Exception: foo
19:07:32 <lispy> dmead: see, the error function throws an exception
19:07:40 <dmead> ahh
19:08:00 <dmead> yea i suppose i'll have to clean that upl ater
19:08:05 <lispy> the type is so general you can use it in place of any value
19:08:11 <dmead> ahh
19:08:14 <lispy> ?type error
19:08:15 <lambdabot> forall a. [Char] -> a
19:08:41 <lispy> dmead: i have a tutorial for you
19:08:53 <dmead> alright =)
19:09:03 <lispy> dmead: http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
19:09:06 <lambdabot> Title: Monad Transformers Step by Step, http://tinyurl.com/esboz
19:09:14 <dmead> thanks =)
19:09:17 <lispy> np
19:09:35 <dmead> yea i haven't taken combinatorics or group theory
19:09:45 <dmead> so it's not something i've come across i guess
19:09:50 <lispy> s'okay
19:09:56 <lispy> you won't need it
19:10:00 <dmead> koo
19:10:11 <lispy> combinators != combinators
19:10:17 <lispy> er
19:10:28 <lispy> hehe, i can't spell, i meant, combinators != combinatorics
19:11:05 <dmead> i gotcha =p
19:13:32 <newsham> ... still building ghc....
19:17:17 <dmead> it takes like 4 hours in my 2ghz athlon =/
19:17:23 <dmead> or some huge amount of time like that
19:18:31 <newsham> ahh, i'm only at 4hr10min on my 700mhz athlon
19:18:47 <dmead> oh, i guess you'll be there a while then :s
19:19:04 <dmead> it's gentoo i guess?
19:19:10 <newsham> no
19:20:53 <bean> So i'm reading the wikibook on haskell and one of the exercises is to "Write a function cons8 that takes a list and cons'es 8 on to it."  cons8 [] = 8:[] works with an empty list but how do i get it to work with any list of Ints?
19:21:22 <Svrog> is there a combinator in the standard library that can be used to replace if/else/then when using pointfree style or do i have to roll my own?
19:21:29 <lispy> bean: my hint: don't use pattern matching heer!
19:21:46 <newsham> what if instead of [] you accepted any list x?
19:21:52 <Smokey`> cons8 list = 8:list
19:21:55 <newsham> what would "cons8 x" be?
19:21:59 <lispy> Svrog: we should have if' but we don't, so if' b t e = if b then t else e
19:22:08 <Svrog> oh
19:22:14 <dons> ?pl cons8 list = 8:list
19:22:15 <lambdabot> cons8 = (8 :)
19:22:23 <Svrog> is if' going to be included in future versions of haskell?
19:22:27 <dons> ?let cons8 = (8 :)
19:22:28 <lambdabot> Defined.
19:22:30 <lispy> Svrog: i wish!
19:22:34 <dons> > L.cons8 [1..10]
19:22:35 <lambdabot>  [8,1,2,3,4,5,6,7,8,9,10]
19:22:52 <lispy> > reverse . L.cons8 . reverse [1..7]
19:22:53 <lambdabot>    Expecting a function type, but found `[a]'
19:22:53 <lambdabot>    Expected type: a -> [In...
19:22:58 <lispy> > reverse . L.cons8 . reverse $ [1..7]
19:22:59 <lambdabot>  [1,2,3,4,5,6,7,8]
19:23:13 <dons> ?check \xs -> let _=xs::Int in L.cons8 xs == (:) 8 xs
19:23:15 <lambdabot>  Couldn't match `[Integer]' against `Int'
19:23:29 <newsham> ?let revFrev f = rev.f.rev
19:23:29 <lambdabot> <local>:4:12: Not in scope: `rev'  <local>:4:18: Not in scope: `rev'
19:23:34 <dons> ?check \xs -> let _=(xs::Integer) in L.cons8 xs == (:) 8 xs
19:23:35 <lambdabot>  Couldn't match `[Integer]' against `Integer'
19:23:42 <newsham> ?let revFrev f = reverse . f . reverse
19:23:43 <lambdabot> Defined.
19:24:02 <newsham> > L.revFrev L.cons8 [1..7]
19:24:03 <lambdabot>  [1,2,3,4,5,6,7,8]
19:24:29 <bean> Okay, so i don't know what anyone is doing.
19:25:06 <dons> > let cons8 = (8 :) in cons8 [1..4] -- yeah?
19:25:08 <lambdabot>  [8,1,2,3,4]
19:25:09 <lispy> bean: it's called showing off ;)
19:25:38 <dons> > let cons8 = (:) 8 in cons8 [1..4] -- perchance?
19:25:40 <lambdabot>  [8,1,2,3,4]
19:25:52 <lispy> > (fix (\cons8 -> (8:)) [1..4]
19:25:53 <lambdabot>  Parse error
19:26:01 <lispy> > (fix (\cons8 -> (8:))) [1..4]
19:26:03 <lambdabot>  [8,1,2,3,4]
19:26:40 <dons> pointless use of fix award goes to ...
19:26:59 <bean> "cons8 list = 8:list" works, but why doesn't "cons8 [list] = 8:[list]" .. because "1,2,3
19:27:04 <lispy> dons: just practicing for the next time someone asks for homework help the wrong way :)
19:27:05 <bean> " isn't a type right?
19:27:08 <dons> pattern matching bean
19:27:14 <newsham> > (2^3 :) [9]
19:27:15 <lambdabot>  [8,9]
19:27:17 <dons> cons8 [list] = 8:[list] matches lists of 1 element only
19:27:32 <bean> okay, i get that
19:27:36 <bean> thanks guys
19:27:45 <Svrog> [list] == (list:[])
19:27:49 <dons> > let cons8 [x] = 8 : [x] in cons8 [1]
19:27:50 <lambdabot>  [8,1]
19:27:57 <dons> > let cons8 [x] = 8 : [x] in cons8 [1,2] -- will fail
19:27:58 <lambdabot>  Non-exhaustive patterns in function cons8
19:28:18 <dons> > let cons8 x = 8 : x in cons8 [1,2] -- fine
19:28:20 <lambdabot>  [8,1,2]
19:28:42 <dons> > let cons8 = (8 :) in cons8 [1,2] -- same thing
19:28:43 <lambdabot>  [8,1,2]
19:29:05 <lispy> > (fix (\cons8 -> ([2^8] ++))) [1..4]
19:29:07 <lambdabot>  [256,1,2,3,4]
19:29:13 <lispy> > (fix (\cons8 -> ([2^3] ++))) [1..4]
19:29:14 <lambdabot>  [8,1,2,3,4]
19:29:38 <lispy> there we, i don't think i can obsfucate mine much more
19:30:01 <lispy> > (fix (const ([2^3] ++))) [1..4]
19:30:03 <lambdabot>  [8,1,2,3,4]
19:30:11 <dmead> hah
19:30:23 <Svrog> dons: does yi support syntax highlighting?
19:30:41 <lispy> ?type fix . const
19:30:43 <lambdabot> forall a. a -> a
19:31:10 <newsham> > ((:).(`div` 66).sum.(map fromEnum)) "eight" [1,2,3]
19:31:12 <lambdabot>  [8,1,2,3]
19:31:17 <lispy> ?scheck \x -> (fix . const) x == (x::Int)
19:31:19 <lambdabot>  Completed 10 test(s) without failure.
19:31:38 <lispy> newsham: very nice
19:31:44 <newsham> *bows*
19:31:46 <dons> lispy: how about:
19:31:49 <dons> > let cons8 xs = [fromJust $ elemIndex 34 (fix ((1:) . scanl (+) 1))] ++ xs in cons8 [1..4]
19:31:50 <lambdabot>  [8,1,2,3,4]
19:32:16 <dons> Svrog: there's some support in the src, but not enabled or complete
19:32:24 <lispy> ?check \x -> (fix . const) x == (x::Int)
19:32:25 <lambdabot>  OK, passed 500 tests.
19:32:26 <Svrog> oh
19:32:27 <sreeram> the draft paper link on http://haskell.org/haskellwiki/History_of_Haskell is broken. does anybody if i can get it from some other place?
19:32:30 <lambdabot> Title: History of Haskell - HaskellWiki, http://tinyurl.com/o6xyu
19:32:38 <dons> sreeram: looking ...
19:32:48 <lispy> oh, it should have published by now, right?
19:33:39 <dons> yes, looks like spj has moved it from his tmp dir
19:34:07 * dons searches some more
19:34:21 <sreeram> dons, thanks for looking
19:34:26 <lispy> it's a good paper, i hope we can find it
19:35:15 <newsham> > ((:).(`div` 66).sum.(map fromEnum)) "thirteen" [1,2,3]
19:35:16 <lambdabot>  [13,1,2,3]
19:35:16 <Svrog> i have a local copy here - can send it through irc if anyone wants it
19:35:27 <newsham> > ((:).(`div` 66).sum.(map fromEnum)) "eight" [1,2,3]
19:35:28 <lambdabot>  [8,1,2,3]
19:35:56 <Svrog> history of haskell august 11, 2006 draft
19:37:15 <sreeram> Svrog, can you send me the file?
19:37:19 <Svrog> sure
19:37:48 * sreeram hasn't done file transfer on xchat before
19:37:58 <dons> sreeram: here you go, a local copy....www.cse.unsw.edu.au/~dons/tmp/history.pdf
19:38:10 <sreeram> cool
19:38:40 <Svrog> ok then i can cancel the transfer?
19:38:41 <dons> we'll ask the authors to put the final version up (they're happy to I think)
19:39:26 <sreeram> Svrog, yes, thanks anyways
19:39:44 <Svrog> np
19:42:05 <newsham> $ ghci
19:42:06 <newsham> Segmentation fault
19:42:07 <newsham> :(
19:42:27 <dons> OS, ghc version, any gmaes you played?
19:42:48 <lispy> newsham: the one you just built?
19:42:56 <newsham> just got done building 6.6.  not working.  linux, athlon, fc3.
19:43:25 <lispy> newsham: what about, ghc -e '4'
19:43:37 <newsham> # ghc -e '4'
19:43:38 <newsham> Segmentation fault
19:44:09 <lispy> newsham: is there any invokation of ghc/ghci that doesn't lead to a segfault?
19:44:18 <lispy> newsham: maybe no params?
19:44:31 <dons> i've mailed the authors of 'the history of haskell' asking for an online version
19:44:36 <dons> so hopefully that will happen
19:45:06 <dons> newsham: hmm interesting. i noticed just recently the head started segfauting on openbsd/x86 too (not the 6.6 stable though)
19:45:57 <newsham> Program received signal SIGSEGV, Segmentation fault.
19:46:00 <newsham> 0x00421d3b in __pthread_clock_gettime () from /lib/i686/libpthread.so.0
19:47:12 <dons> interesting
19:47:17 <dons> does -threaded help?
19:47:21 <dons> oh, no. it wouldn't
19:49:57 <newsham> why wouldnt it have crashed doing the triple-build?
19:50:07 <newsham> doesnt ghc build a compiler and then recompile itself?
19:50:25 * monochrom has come up with an evil idea.
19:53:24 <lispy> newsham: that's a good quesiton
19:54:57 <newsham> are there tests i can run in the ghc src dir?
19:56:04 <lispy> newsham: i don't kno how it works, but "nofib" is the ghc benchmark
19:56:18 <lispy> newsham: so maybe there is a nofib target in the makefile
19:58:40 <newsham> sweet, so i couldnt build happs because it relied on some ghc libraries that arent in 6.4, so i built ghc for 4.5hrs and now it dumps core.
20:00:51 <newsham> luckily it doesnt overwrite the older version, just the symlink to the old version
20:06:12 <lispy> newsham: fc3 doesn't have a binary version?
20:06:14 <Svrog> just curious, why do binaries for code using point-free style end up larger than for the same code using point-full style? for trivial programs it's only a few kb difference but i would have thought it would be easy for the compiler to figure out the code is the same and that the generated code would be the same usually?
20:15:02 <Svrog> hmm.. just tried a few tests and generated code is the same size - havent tried running diff on the code though - but i definitely noticed in the past that after rewriting an expression in pointfree style the code size would go up
20:18:52 <lispy> Svrog: i was going to say i find it hard to believe and wanted an example :)
20:19:03 <Korollary> Svrog: If you're using ghc, the right thing to do would be to use -fvia-C and -keep-hc-files and compare the files' contents.
20:19:27 <Svrog> ill try to find an example - i just tried some tests now and i couldnt reproduce it heh
20:29:59 <newsham> i dont know if there's a bin version or not.  for some things i'm not really keen on rpms
20:30:48 <lispy> rpms really are terrible, maybe you can use yum?
20:31:01 <lispy> iirc, that's what apt is called in FC
20:32:17 <newsham> if i was using it regularly i would.  i dont want to start some massive pull of dependencies that might leave something broken
20:32:36 <newsham> (machine is due for an upgrade/switch in the near future anyway)
20:34:32 <lispy> well, i hope you get the problem sorted either way
20:36:03 <monochrom> How do I add {-# OPTIONS_GHC #-} pragmas to .lhs files?
20:36:52 <sjanssen> monochrom: in a code fragment
20:36:53 <dons> Svrog: -ddump-simpl would be better
20:36:59 <sjanssen> so > or \begin{code}
20:37:12 <dons> to see what your pointfree vs pointfull code compiles to
20:37:26 <Svrog> cool - ill try that next time it happens
20:37:47 * lispy has notice a lot of people worried about the size of executables lately
20:37:58 <Svrog> im not worried about size of executables
20:38:02 <Svrog> i was just curious
20:38:05 <lispy> okay
20:38:14 <lispy> i have talk to two others about it lately :)
20:38:20 <lispy> it's a bit worrisome
20:38:20 <newsham> do you thikn that people shouldnt worry about the size of executables?
20:38:29 <lispy> newsham: most people shouldn't
20:38:30 <dons> ?unpl (. filter) . id . flip . flip
20:38:31 <lambdabot> (\ k t e -> k (filter t) e)
20:38:53 <lispy> newsham: of course people developing for small platforms like embedded devices are free to worry :)
20:39:12 <dons> that pointfree and pointfull produces exactly the same number of exectuabe bytes
20:39:29 <newsham> there are still plenty of machines with small ram/swap.
20:40:33 <newsham> i'm a big believer in "programmer time is more important than cpu time" (and memory footprint), but i dont think you should completely ignore the other factors
20:40:46 <Svrog> yeah like i said i tried to come up with an example but no luck - ill make note of it when i see it next time in my code though - if i see it
20:40:51 <newsham> just not rank them as highly
20:41:37 <lispy> newsham: that's what strip is for ;)
20:46:07 <Svrog> has anyone played with smp support in ghc much?
20:47:51 <sjanssen> Svrog: a bit.  Do you have any questions?
20:48:36 <Svrog> yeah - mostly questions on how well does that work?
20:48:43 <dons> Svrog: yep
20:49:03 <dons> seems to work very well :) can you be more specific
20:49:10 <monochrom> Haha fun. Suppose I import a lot of modules but they don't exist.  ghc reports the last one only.  So, after I fix one, ghc points me to the previous one, etc.
20:49:12 <dons> (i.e. scales up to 40 processors so faR)
20:49:55 <Svrog> well if i understand correctly the current version of ghc still has a single threaded garbage collector - does that negatively impact smp support?
20:50:01 <Svrog> oh
20:50:02 <Svrog> nice
20:50:30 <dons> Svrog: it affects some applications, but work on the parallel GC has begone. so far i've never noticed the GC being an issue on smp though
20:50:35 <dons> its theoretically an issue anyway
20:50:41 <dons> s/begun/
20:50:56 <Svrog> cool
20:51:02 <dons> so: maybe it might be an issue, if you have very hard smp requirements, most likely not.
20:51:03 <Svrog> that's all i wanted to know pretty much :)
20:51:09 <dons> and it'll be a non issue by ghc 6.8 anyway
20:51:12 <Svrog> i got a core 2 duo recently so i wanna try out the smp stuff
20:51:19 <dons> go nuts. sjanssen's got one
20:51:28 <dons> seems to run nicely
20:51:54 <sjanssen> nah, I'm outdated.  I just have the Core Duo
20:52:00 <dgriffi3> dons: what happens in 6.8?
20:52:11 <dons> dgriffi3: parallel GC lands
20:52:46 <dons> some links: http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
20:52:49 <lambdabot> Title: GHC/Data Parallel Haskell - HaskellWiki, http://tinyurl.com/y77oeb
20:52:53 <dons> and...
20:53:58 <dons> http://programming.reddit.com/info/lr5w/comments/clr6k
20:54:00 <lambdabot> Title: GHC 6.6 is out, supporting: SMP concurrency, impredicative polymorphism and more ..., http://tinyurl.com/y2hlp6
20:54:25 <dons> also: http://haskell.org/haskellwiki/Libraries_and_tools/Concurrency_and_parallelism
20:54:28 <lambdabot> Title: Libraries and tools/Concurrency and parallelism - HaskellWiki, http://tinyurl.com/wvlsw
20:55:02 <Svrog> yeah i had a look through those already but thanks
20:55:08 <dons> writing smp parallel haskell programs is so easy its almost scary
20:55:23 <Svrog> cool :)
20:55:26 <dons> just write a normal concurrent haskell program, and add: +RTS -N8 to the command line
20:55:37 <dons> ie. .using forkIO, par or DPH arrays
20:55:41 <dons> and it *just works*
20:56:15 <sjanssen> DPH arrays don't actually work in GHC 6.6, do they?
20:56:17 <sigfpe__> f A
20:56:51 <Svrog> yeah - few days ago i wrote a c main function stub that checks the number of processors on win32/linux/os x and based on that sets up +RTS -N<x> -RTS args and passes them to hs_init
20:56:54 <dons> sjanssen: you'd need the head with associated types, i think
20:56:59 <Svrog> but other than that i havent done anything else with smp yet
20:57:00 <dons> Svrog: oh, url?
20:57:07 <dons> i was looking for just such a thing yesterday
20:57:18 <Svrog> i dont have a web page
20:57:22 <Svrog> i can send you the code if you want
20:57:24 <dons> wiki then?
20:57:41 <dons> i.e. i wanted that for: http://www.cse.unsw.edu.au/~dons/pqc.html
20:57:42 <Svrog> wiki?
20:57:42 <lambdabot> Title: PQC : (SMP) Parallel QuickCheck
20:57:56 <dons> Svrog: stick it on a new page on haskell.org
20:58:00 <dons> ?paste even
20:58:01 <lambdabot> http://paste.lisp.org/new/haskell
20:58:19 <Svrog> ok
20:58:23 <Svrog> give me a few seconds
20:58:47 <Svrog> is that gonna handle c code? or just haskell?
20:59:05 <dons> it can test C code via FFI bindings
20:59:15 <Svrog> cool
20:59:33 <Svrog> what about files? its split across a few files currently - do i have to combine all that into 1 file?
20:59:56 <dons> i.e. prop_strlen x = fromIntegral (c_strlen (pack x)) == haskell_length x ; foreign import strlen :: ...
21:00:03 <dons> Svrog: as many modules as you want
21:00:33 <Svrog> yeah but how do i paste them? just select all and paste it in there? or is there a better way?
21:00:41 <dons> paste?
21:00:58 <dons> i don't understand what you're asking?
21:01:00 <newsham> C code -> pastebin?
21:01:02 <dons> you hvae properties in multiple modules?
21:01:10 <dons> ah sorry
21:01:16 <dons> you have multiple C modules you want to paste?
21:01:27 <dons> just dump them all in one paste buffer, i suggest
21:01:34 <Svrog> no but i have several different modules with the same name in different directories - like the code that checks the number of processors - there's 3 different versions
21:01:39 <Svrog> one for win32, one for linux and one for os x
21:02:05 <Svrog> so do i have to merge all that into 1 and just separate different versions with #if-s?
21:02:48 <Svrog> ill just merge them...
21:04:47 <sreeram> is it possible to define a function which can take either an integer or a string, and returns an integer?
21:05:32 <newsham> you can define a type that has either an integer or a string
21:05:39 <newsham> and then a function which maps that to an integer
21:05:39 <monochrom> Yay, I have got Hood to compile in GHC 6.6!
21:06:09 <dons> sreeram: what does the function do?
21:06:11 <newsham> data MyType = MyInt Int | MyStr String;  myfunc :: MyType -> Int
21:06:36 <newsham> myfunc (MyInt x) = x + 1;  myfunc (MyStr xs) = length xs
21:06:42 <monochrom> f _ = 10    is a function which can take anything and returns an integer :)
21:07:08 <sreeram> say, the function is "serialized-size" in a serialization library which can serialize integers or strings
21:07:09 <dons> ?instances Enum
21:07:10 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
21:07:17 <dons> sreeram: yep sure. you can do that.
21:07:27 <newsham> sreeraM: for that you probably want to make a class (ie. Serializable)
21:07:27 <monochrom> Ah, type classes are suitable.
21:07:33 <newsham> and make both Int and String instances of those
21:07:56 <monochrom> I think Ralf Hinze has done that
21:08:45 <dons> sreeram: you might consider:
21:08:47 <dons> class Serial a where sizeOf :: a -> Int
21:08:47 <dons> instance Serial Int32  where sizeOf n = 4 -- bytes
21:08:47 <dons> instance Serial [Char] where sizeOf s = length s
21:08:57 <dons> something like that, for your class of types that can be serialised
21:09:12 <dons> then sizeOf :: Serial a => a -> Int
21:09:19 <dons> and works on any type with an instance defined for Serial
21:09:22 <sreeram> cool
21:09:33 <sreeram> thanks
21:09:46 <newsham> there is some code to do this already, btw.
21:10:01 <dons> yeah, Binary, NewBinary, ...
21:10:05 <dons> ?wiki Binary_Io
21:10:06 <lambdabot> http://www.haskell.org/haskellwiki/Binary_Io
21:10:25 <dons> http://www.haskell.org/haskellwiki/Binary_IO
21:10:26 <dons> i mean
21:10:26 <lambdabot> Title: Binary IO - HaskellWiki
21:16:43 <lisppaste2> Svrog pasted "One thread per processor" at http://paste.lisp.org/display/30651
21:17:30 <Svrog> the code hasnt been thoroughly tested
21:20:15 <Svrog> ive tested the osx and linux code under os x (got a dump of /proc/cpuinfo from a friend's linux box and just created /proc/cpuinfo directory under os x) and the windows code compiles with the cross compiler but i haven't actually tried it yet
21:21:26 <Svrog> oops
21:21:46 <Svrog> hs_init line should be "hs_init(&hs_argc, &hs_argv);"
21:21:56 <Svrog> heh
21:24:10 <Svrog> eh.. ill paste it again when i fix it up
21:33:02 <monochrom> Why do we request "NOINLINE" for things like Debug.Trace.trace?
21:33:50 <dons> so the unsafePerformIO isn't duplicated
21:35:58 <monochrom> where does the potential duplication come from?
21:39:18 <newsham> # compiler/stage1/ghc-6.6
21:39:18 <newsham> ghc-6.6: missing -B<dir> option
21:39:18 <newsham> # compiler/stage2/ghc-6.6
21:39:18 <newsham> Segmentation fault
21:39:22 <newsham> i guess it didnt build properly
21:44:16 <newsham> is there a way to clean the stage2 and rebuild it without rebuilding stage1?
21:44:31 <Lemmih> make stage=2 clean, iirc
21:53:58 <Svrog> ok.. so to get smp working i need to compile with -threaded and then pass +RTS -N<number of threads> -RTS to the compiled binary from the command line? am i missing something?
21:54:22 <Svrog> because the binaries im getting don't seem to like -N
21:55:01 <dons> Svrog: exactly that. with ghc 6.6
21:55:09 <Svrog> yes - i have ghc 6.6 installed
21:55:11 <dons> compile with -threaded, run with +RTS -N4
21:55:13 <Svrog> and it doesnt work :(
21:55:34 <Svrog> ghc --version returns 6.6
21:55:50 <dons> for example:
21:56:53 <Svrog> ghc -threaded --make main.hs
21:57:04 <Svrog> ./main +RTS -N2 -RTS
21:57:22 <Svrog> unknown RTS option: -N2
21:57:22 <Svrog> Usage: <prog> <args> [+RTS <rtsopts> | -RTS <args>] ... --RTS <args> ..... blah blah
21:57:56 <dons> compiled with wrong ghc? running the wrong binary?
21:58:06 <dons> try ghc-6.6  explicitly
21:58:18 <Korollary> no version of ghc should have given that msg
21:58:22 <Korollary> err
21:58:26 <Korollary> I am on crack. Continue.
21:58:28 <Svrog> i get the same thing heh
21:58:34 <dons> oh yeah. weird msg.
21:58:45 <dons> that's not ghc
21:58:54 <dons> oh hang on. yes it is
21:58:57 <Svrog> well it didnt have the blah blah part heh - i added that cause the text that follows is 1 to 2 pages long
21:59:06 <Svrog> yeah
21:59:54 <lisppaste2> Svrog annotated #30651 with "One thread per processor" at http://paste.lisp.org/display/30651#1
22:00:16 <Svrog> thats the updated code - but i get that error when i run the binary cause it doesnt like -N
22:00:50 <dons> $ /home/dons/ghc/bin/ghc-6.6 -O -threaded --make Example.hs -o E
22:00:50 <dons> [1 of 1] Compiling Main             ( Example.hs, Example.o )
22:00:53 <dons> ...
22:01:00 <dons> $ time ./E 1 +RTS -N1 > /dev/null
22:01:06 <dons> ./E 1 +RTS -N1 > /dev/null  19.33s user 0.04s system 99% cpu 19.383 total
22:01:18 <dons> $ time ./E 4 +RTS -N5 > /dev/null
22:01:24 <Svrog> ill try it on my other computer
22:01:26 <dons> ./E 4 +RTS -N5 > /dev/null  23.79s user 0.25s system 288% cpu 8.326 total
22:01:42 <Svrog> im getting this error on G5 iMac
22:01:51 <Svrog> ill try it on a win32 box
22:01:59 <dons> its the kind of error the wrong ghc would produce
22:02:05 <dons> i.e. a ghc 6.5 before smp went in
22:02:09 <Svrog> hmm
22:02:24 <Svrog> maybe i have an old copy of 6.4 somewhere on there... pretty sure i got rid of it though
22:02:34 <Svrog> and i get the same error if i compile it with ghc-6.6
22:02:48 <Svrog> and --version prints 6.6
22:03:05 <dons> it should work, unless it wasn't built with an smp rts for some reason
22:03:33 <Svrog> hmm
22:03:50 <MP0> The imperative approach: make everything a variable and let the compiler figure out what is const. The functional approach: make everything a const and let the compiler figure out what is a variable.
22:05:57 <newsham> kill em all and let god sort em out
22:07:02 <dons> in a concurrent world, mutable variables are the wrong default
22:10:52 <monochrom> The concurrent sharing approach: make everything a variable and let the STM sort them out.
22:11:45 <Rolling> > 4+3
22:11:47 <lambdabot>  7
22:12:27 <newsham> > (sum.(map (read.return)).show) 43
22:12:29 <lambdabot>  7
22:13:22 <dons> newsham: heh
22:14:18 <Rolling> did someone write a simple LISP interpreter in Haskell here?
22:14:55 <dons> > fromJust(elemIndex(21)(fix((1:).scanl(+)1)))
22:14:56 <lambdabot>  7
22:15:10 <dons> yeah, a few guys have done that
22:15:12 <Svrog> ok - just tried it under windows and it works there
22:15:35 <MP0> here's one: http://www.defmacro.org/ramblings/lisp-in-haskell.html
22:15:37 <Rolling> where can i find it?
22:15:38 <lambdabot> Title: defmacro - Writing A Lisp Interpreter In Haskell, http://tinyurl.com/yyr8sf
22:15:49 <dons> ?google write a lisp interpreter in haskell
22:15:51 <lambdabot> http://www.defmacro.org/ramblings/lisp-in-haskell.html
22:15:51 <lambdabot> Title: defmacro - Writing A Lisp Interpreter In Haskell
22:15:53 <Rolling> thanks,
22:16:22 <newsham> > let f = (sum.(map (read.return)).show) in (f.f.f) (5555^5555)
22:16:25 <lambdabot>  5
22:16:31 <newsham> how would I do the fixed-point of that func?
22:16:47 <newsham> > fix (sum.(map (read.return)).show) 43
22:16:48 <lambdabot>  add an instance declaration for (Read (t -> a))
22:16:53 <dons> ?pl let f = (sum.(map (read.return)).show) in (f.f.f) (5555^5555)
22:17:04 <dons> too hard...?
22:17:09 <lambdabot> ap (.) (join (.)) (sum . map (read . return) . show) (5555 ^ 5555)
22:17:09 <lambdabot> optimization suspended, use @pl-resume to continue.
22:17:14 <dons> yep
22:17:22 <dons> i thought it'd slip a fix in, ah well
22:17:41 <dons> at least it found the fix point ;)
22:17:43 <newsham> the func can do Int -> Int, fix should work, no?
22:21:24 <newsham> oh, heh, my bad.
22:21:50 <lisppaste2> Svrog annotated #30651 with "One thread per processor" at http://paste.lisp.org/display/30651#2
22:22:02 <Svrog> that should be it
22:22:29 <Svrog> still not sure why -N keeps failing on my mac... but it works under windows
22:24:40 <Svrog> might rebuild ghc
22:25:02 <dons> yeah. grab ghc 6.6 stable and build it
22:29:39 <dons> dcoutts: hmm, strange, we actually *do* have a test for Lazy.lines
22:29:40 <dons> prop_linesBP        = D.lines       `eq1`  C.lines
22:29:54 <dons> import qualified Data.ByteString.Char8 as C
22:29:56 <dons> import qualified Data.ByteString.Lazy.Char8 as D
22:30:54 <dons> so maybe no \n's being generated... hmm
22:39:00 <dons> yes :/
22:40:38 <newsham> > (head.(dropWhile (> 9)).(iterate (sum.(map (read.return)).show))) (5555^5555)
22:40:41 <lambdabot>  5
22:46:28 <newsham> is there an "iterate-till-convergence" function?
22:53:04 <Svrog> what's in ghc-6.6-src-extralibs.tar.bz2? do i just extract that into the same directory as ghc sources prior to building? or build it separately after?
22:53:14 <Korollary> just extract
22:53:25 <Korollary> it's got a bunch of additional modules
22:53:37 <Svrog> so they'll get built along with the rest?
22:53:41 <Svrog> not separately?
22:53:41 <Korollary> yes
22:53:44 <Svrog> cool
22:53:44 <Svrog> thanks
22:53:52 <Korollary> you can also build separately with some effort
22:54:45 <dons> ok, now who wants to order some isotopes? i think it would help lambdabot's development effort go atomic!! http://unitednuclear.com/isotopes.htm
22:54:46 <lambdabot> Title: United Nuclear- Radioactive Isotopes
22:55:54 <dons> only $69.00 for some Polonium 210. gotta get your alpha-emitting warez
22:56:13 <Korollary> I worry about the packaging
22:56:42 <dons> i'm sure they can add some extra bubble wrap if you're worried about breakage.
23:04:35 <Svrog> why do i always have to resort to editing various .hs files every time i try to build some haskell library or program? just now im trying to build happy so i can rebuild ghc and i get LALR.lhs:626:34: Not in scope: `bounds'
23:05:12 <Svrog> then i change import Data.Array hiding (bounds) to just import Data.Array and that fixes it but i get another error
23:05:13 <dgoldsmith> Svrog: Apple recommends MPProcessorsScheduled() since the number of processors actually available can change due to power management.
23:05:22 <dons> *sigh* http://blog.lostlake.org/index.php?/archives/18-Functional-languages-will-rule.html
23:05:25 <lambdabot> Title: Functional languages will rule - David Pollak's Blog, http://tinyurl.com/uwtfu
23:05:25 <Svrog> ah
23:05:40 <dgoldsmith> SVrog: I understand that you're computer an environment variable, so you can't change it on the fly.
23:05:47 <dgoldsmith> The best you can do is take a snapshot.
23:05:53 <dons> "As a side note, I was going to try Haskell, the allegedly purest functional language, until I read this post, and decided not to spend a lot of time with Haskell" -- links to joelr's attempt to write his own binary parser et al and failing. :/
23:06:17 <Svrog> cant change what on the fly?
23:07:39 <Svrog> dgoldsmith: what do you mean?
23:08:00 <dons> why, or why, did joelr persist with his own parser combinators, instead of just using newbinary. so frustrating to watch
23:08:17 <dgoldsmith> Svrog: the number of processors.
23:08:37 <dgoldsmith> Svrog: you have to take a snapshot at the time you initialize the runtime system.
23:08:40 <glguy_> "If you've ever used a spreadsheet, you've done functional programming."
23:08:55 <Korollary> what the hell does allegedly mean there
23:09:03 <newsham> heh.  "well defined side effects for function calls."
23:09:20 <glguy_> Korollary: it means "someone else said it, not me" =D
23:09:22 <dgoldsmith> Svrog: the documentation says the number of available processors can vary based on power management and temperature control issues.
23:09:55 <Svrog> dgoldsmith: i actually saw that but didnt think it would matter that much - in the worst case the program would run with a few extra threads
23:10:11 <emu> i gave SerTH a whirl, and it worked out great
23:10:14 <dgoldsmith> Svrog: true.
23:10:24 <Svrog> but it's easy to change to MPProcessorsScheduled()
23:10:38 <dons> emu: that's good to know.
23:10:54 <emu> i had to write instance declarations for Map and Set
23:10:55 <dgoldsmith> Svrog: I can't honestly say I know which would work better for ghc. Probably it would be a good idea to test it.
23:11:11 <emu> which i did with fromList/toList, probably better ways
23:11:18 <Svrog> unfortunately i cant test it - only have a G5 iMac which only has one processor
23:11:21 <glguy_> http://www.artima.com/forums/flat.jsp?forum=106&thread=98196
23:11:23 <lambdabot> Title: Weblogs Forum - The fate of reduce() in Python 3000, http://tinyurl.com/bhl9d
23:11:33 <glguy_> This guido fellow much think very poorly of Python programmers
23:12:02 <Svrog> i can test under windows and linux on core 2 duo - but have no multi-processor or multi-core os x box
23:12:08 <dons> glguy_: that's a very old link we've discussed to death here :)
23:12:18 <glguy_> it's new to me :-p
23:12:19 <Korollary> glguy_ wants to rant.
23:12:45 <Korollary> IV drip. Give me 20cc of oxytocin.
23:12:54 <Korollary> Don't give up on me glguy_ !
23:13:00 <glguy_> Korollary: have I been particularly grumpy tonight?
23:13:01 <Korollary> 300J! Clear.
23:13:03 <newsham> glguy: any business plan that relies on the existance of idiots is bound to succeed.  any business plan that relies on nobody being an idiot will fail.
23:13:14 <Korollary> glguy_: Nah I am just messing with you.
23:13:23 <newsham> i dont think its all that bad for python to be geared towards avoiding idiot mistakes
23:13:58 <newsham> especially as a reaction to all the perl code thats been written :)
23:14:43 <dons> here, i can summarise our entire discussion about guido's FP phobia: http://www.cse.unsw.edu.au/~dons/tmp/guido.txt   :)
23:14:45 <lambdabot> http://tinyurl.com/y544n3
23:14:46 <glguy_> "Why drop lambda?" he asks. Of course the first reason is, "Most Python users are unfamiliar with Lisp or Scheme, so the name is confusing;"
23:14:47 <newsham> this "functional languages will rule" post is amusing.  "i looked at x for 5 minutes but because of y I didnt look at it any further"
23:14:57 <newsham> "then I looked at z for 2 minutes and gave up"
23:15:19 <glguy_> Alright guys, the name "Monad" scares people, who's going to submit the patch to tear them out ;)
23:15:34 <newsham> glguy: why does everyone care?  lambda is unnecessary in python (and its only an expression anyway.. whereas named functions are fully general)
23:15:40 <dons> newsham: you can tell the rigourous critical analysis is just around the corner ;)
23:15:44 <Svrog> i think its a shame python and ruby are more popular than smalltalk and self - python and ruby don't improve on smalltalk and self in any way as far as i can tell - they just have more syntax
23:15:53 <newsham> i think functional people crying over python eliminating lambda is the most pointless argument ever
23:16:01 <newsham> there's lots of real things you can complain about
23:16:03 <dons> exactly.
23:16:10 <glguy_> I don't care what happens to the language, I just think that it's hillarious
23:16:39 <newsham> glguy: so why are we talking about python lambda again?
23:17:02 <newsham> python lambda was very limited, extraneous and hardly used.  now its going away.  nobody will miss it.
23:17:04 <monochrom> For the same reason newsham has given, I don't even look at reddit.com, even if it is a link from good sweet dons.
23:17:06 <glguy_> Because you keep responding
23:17:30 <dons> show me your catamorphisms now!
23:17:33 * dons boings like a shapr
23:17:35 <glguy_> Korollary: there, no you can call me argumentative, or whatever it was :)
23:17:35 <dons> ?yow!
23:17:36 <lambdabot> my NOSE is NUMB!
23:17:42 <glguy_> now*
23:17:45 <dons> ?uptime
23:17:45 <lambdabot> uptime: 8d 3h 19m 12s, longest uptime: 8d 3h 19m 12s
23:19:20 <newsham> "I've used A for 10 days now, and I'm telling you, this is the best programming language ever made!"
23:19:32 <newsham> "and I oughta know, i've used it for *TEN* days!"
23:19:32 <glguy_> I'm reading that log from dons' home dir... but I'm confused... there is only one Guido, right?
23:19:42 <glguy_> A?
23:19:52 <dons> newsham: hehe
23:19:59 <dons> its very deep
23:20:01 <newsham> glguy: names removed to protect the innocent
23:20:08 <glguy_> ahh
23:20:14 * glguy_ wonders if he's being made fun of
23:20:20 <dons> i shouldn't have posted the link. damn my rss google feed! damn it to hell!
23:20:29 <dons> glguy_: nope
23:20:44 * dons pulls some more rss 
23:20:53 <newsham> also yacc is a functional programming language
23:21:04 <dons> heh
23:21:43 <dons> welll, haskell is functional, haskell compiles to C, yacc compiles to C, therefore yacc is functional
23:21:57 <Svrog> has Data.Array.MArray.indices been removed from ghc-6.6? dont see it in the docs
23:22:00 <glguy_> In the spirit of acceptance, I will admit that Python's list-comprehensions are decent alternative to map, filter, etc.
23:22:02 <lispy> yacc is declarative, right?
23:22:20 <newsham> but doesnt haskell compile to an imperative assembly language?
23:22:26 <dons> Svrog: its there, module Data.Array.MArray
23:22:36 <Svrog> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-MArray.html
23:22:38 <lambdabot> http://tinyurl.com/y2qz4l
23:22:39 <Svrog> doesnt seem to be there
23:22:45 <lispy> newsham: just wondering...is there a non-declarative assembly language?
23:22:52 <Svrog> and im getting an error when compiling happy:
23:22:54 <dons> ?source Data.Array.MArray
23:22:55 <lambdabot> http://darcs.haskell.org/packages/base/Data/Array/MArray.hs
23:22:59 <newsham> glguy: plus if you really care, you can always provide your own map/filter/reduce if someone yanks them from std libs
23:23:01 <Svrog> ProduceCode.lhs:31:20: Not in scope: `Data.Array.MArray.indices'
23:23:15 <newsham> lispy: i dont know of any
23:23:21 <newsham> but what i dont know could fill a library (or two)
23:23:30 <lispy> newsham: er, i meant non-imperative
23:23:39 <lispy> newsham: but you probably knew that
23:23:41 <Svrog> is there a way to build ghc w/o happy?
23:23:57 <dons> Svrog: there's no indices in that module.
23:24:03 <lispy> Svrog: i think the build newsham had ealier was unhappy, is that the same thing ;)
23:24:07 <glguy_> newsham: Of course :-p and I'm trying to be agreeable... it's too late to be grumpy
23:24:12 <Svrog> damn....
23:24:22 <Svrog> so how do i build ghc then? huh
23:24:30 <dons> Svrog: you want the bounds?
23:24:58 <Svrog> im just trying to compile happy so i can then proceed to rebuild ghc
23:24:59 <lispy> Svrog: surely, someone has fixed this and you just need a different version?
23:25:06 <dons> do you have the latest happy/
23:25:13 <Svrog> this is the latest version off the web site
23:25:15 <dons> you need the darcs version of happy with ghc 6.6
23:25:16 <newsham> didja ever see the hack in python that lets you do infix operators?
23:25:20 <dons> (there's a tarball available now too)
23:25:26 <Svrog> havent tried stuff out of darcs or cvs or whatever they're using for happy
23:25:26 <dons> ?where happy
23:25:27 <lambdabot> http://www.haskell.org/happy/
23:25:38 <Svrog> thats it - version 1.15
23:25:40 <dons> darcs get the happy src, and build that. it contains the ghc 6.6 fix
23:25:48 <Svrog> ok
23:25:49 <Svrog> thanks
23:26:03 <dons> there's a tarball, but i don't have it handy, or do i? ...
23:26:05 * dons looks
23:26:09 <glguy_> newsham: me? (if so, no)
23:26:32 <newsham> its cute.  like x `func` y in haskell:  http://www.thenewsh.com/%7Enewsham/x/machine/infix.py
23:26:34 <lambdabot> http://tinyurl.com/yeoq9u
23:27:13 <Svrog> should i just get everything out of darcs and try building that? latest version of happy, alex and ghc, all out of darcs?
23:28:01 <glguy_> newsham: That is definitely too clever to be good Python (-;
23:28:13 <glguy_> (but is quite cool)
23:28:53 <newsham> saw someone use that to implement one of the monads (infix bind operator)
23:29:20 <dons> Svrog: just happy I think
23:29:24 <Svrog> ok
23:29:34 <dons> i'd recommend *not* using the darcs version of ghc (use the 6.6 stable tarball)
23:29:40 <Svrog> ok
23:29:52 <monochrom> <Lunar^> shapr: What about GHC 6.6 dropping '\' to follow Guido's advice ? :)
23:29:54 <monochrom> Hahahaha
23:30:12 <monochrom> (Time really flied.)
23:31:08 <Svrog> joy.. the cvs link is broken
23:32:16 <lispy> Svrog: probably only the darcs works
23:32:22 <Svrog> yeah i just found that
23:32:27 <lispy> i think most haskell projects have stopped using cvs
23:32:39 <Svrog> yeah - the main page for happy only had the cvs link though
23:32:48 <lispy> and if they haven't they deserve the segfaults, corrupted repositories and manual merging :)
23:32:56 <Svrog> had to google for "haskell happy darcs" to find the darcs link
23:32:56 <dons> Svrog: darcs.
23:33:11 <lispy> Svrog: here is a good trick, google for _darcs instead of darcs
23:33:20 <lispy> Svrog: because a repository will always have a _darcs dir
23:33:24 <dons> probably darcs.haskell.org/happy
23:33:27 <Svrog> ah
23:33:33 <Svrog> yeah thats the link i found
23:34:10 <dons> ?where+ happy-darcs darcs get http://darcs.haskell.org/happy/
23:34:11 <lambdabot> Done.
23:34:25 <glguy_> Would it be completely absurd for (using Haskell as a specific example) Haskell to have a GUID that everyone added to a website when the topic was Haskell (to facilitate searching)
23:34:45 <glguy_> this seems like it would benefit projects like "Clean" where the name can be ambiguous
23:34:57 <monochrom> Not absurd.
23:35:10 <dons> probably useful. we have the google search engine for haskell, that sort of does that
23:35:13 <dons> you could add more sites
23:35:55 <glguy_> This would obviously not work on the large scale (see meta-tag keywords)
23:36:27 <glguy_> because people would lie, but it seems like it could work for things like software projects where there isn't an incentive to pretend
23:36:49 <glguy_> I guess people with spam pages would just list as many guids as possible though...
23:36:59 <glguy_> oh well
23:37:21 <lispy> glguy_: maybe, but then it's easy to filter those out
23:37:59 <glguy_> true... pages with more than a couple unique-ids could be ignored
23:39:29 <glguy_> anyway, it's getting pretty late, goodnight
23:41:00 <lispy> night
23:42:04 * glguy &
23:47:50 <emu> is there a way to generate a profilable library with cabal
23:48:23 <emu> i want to profile my program but this library keeps getting in the way
23:49:30 <dons> yep
23:49:34 <lispy> emu: always use configure -p when you use cabal
23:49:36 <dons> runhaskell Setup.lhs -p
23:49:43 <dons> s/^configure in there/
23:50:12 <lispy> emu: otherwise you get into a situation where you want to profile something and you have to go back and recompile everything with -p
23:50:21 <lispy> i wish they would make it the default
23:50:39 <lispy> ?tell dcoutts is it time for -p to be the default with cabal and configure?
23:50:40 <lambdabot> Consider it noted.
23:50:46 <emu> k
23:52:11 <dons> slows builds down though.
23:53:04 <lispy> dons: and doesn't make sense as the default for executables
23:53:10 <dons> yep
23:53:22 <lispy> dons: but for libraries i think its a nice default (during dev I can remember to turn it off)
23:53:42 <lispy> it makes it nice for the causal library user...i guess that what i should say
23:54:29 <Korollary> I cant think of anything else that builds with profiling support by default
23:54:40 <dons> even ghc doesn't
23:55:08 <dons> i don't know, maybe it should. maybe it shouldn't. doesn't come up very often, and people seem to know the fix
23:57:49 <emu> i went ahead and built my program with configure -p as well, but it doesn't seem to generate executables with prof
23:57:54 <emu> need another option for that?
23:58:33 <lispy> emu: that should be all you need
23:58:41 <lispy> emu: did you remember to use the rts options?
23:58:44 <emu> yes
23:58:49 <emu> says its not built with -prof
23:58:59 <lispy> are  you running it out of the dist directory?
23:59:04 <emu> yes
23:59:07 <lispy> (maybe you forgot to run install)
23:59:08 <lispy> hmm...
23:59:22 <lispy> Oh
23:59:26 <lispy> maybe it didn't really rebuild it?
23:59:31 <lispy> i've had cabal do that
23:59:52 <emu> i see it create a lib with _p but it does not build an executable with that
