00:01:10 <xerox> G'day.
00:04:27 <dons> Cale: here? maybe. hmm.
00:04:28 <dons> ?seen taw
00:04:29 <lambdabot> I haven't seen taw.
00:04:31 <dons> no.
00:04:55 <Cale> maybe in #scheme
00:05:12 <Cale> but then, lambdabot's been there a while
00:06:11 <dons> my last remark on that thread: "Until then, there's always #haskell at freenode, where we have live monad and arrow shows, Until then, there's always #haskell at freenode, where we have live monad and arrow shows, in channel, daily! Distribute your cognition :-)"
00:06:21 <dons> pasto. :}
00:07:12 <Cale> :)
00:08:16 <xerox> Maybe we could organize lectures like #math does :)
00:09:16 <dons> seems almost like we should. there's a lot of people interested out there (lisp hackers?) who now there's something going on, but need some help.
00:09:22 <kosmikus> #math organizes lectures?
00:09:28 <Cale> bounded parametric polymorphism :)
00:09:33 <xerox> Yeah.
00:09:43 <kosmikus> well, why not
00:09:45 <Cale> kosmikus: every once in a blue moon :)
00:09:51 <kosmikus> if there's sufficient interest
00:10:37 <dons> these reddit threads almost turn into lectures.
00:10:38 <gour> full moon is on sunday ;)
00:10:40 <xerox> That's more or less what those shows degenerate (or converge?) to.  I believe it would be nice.
00:10:46 <xerox> Ah-ha.
00:10:48 <roconnor> #math should have a 4 part lectures series on FLT.
00:10:52 <dons> and what's nice is that we have a lot of professional lecturers in channel already
00:10:58 <dons> maybe even with slides prepared :)
00:11:08 <Cale> dons: sorry, I didn't direct that at you -- I don't think parametric polymorphism is really enough to get the full force of it, you need bounded parametric polymorphism like typeclasses give you
00:11:10 <kosmikus> FLT?
00:11:11 <xerox> Right :)  And lambdaweb!
00:11:23 <roconnor> Fermat's Last Theorem
00:11:26 <dons> Cale: ah yes. sleepy me, I agree.
00:11:29 <kosmikus> oh
00:11:47 <kosmikus> pretty advanced stuff
00:12:31 <Cale> Heh, it's possible to give a 15 minute talk where one proves FLT. It just relies on lots of context :)
00:12:41 <dons> kosmikus: do you know of a modern literature survey on the uses monads have been put to since the mid 90s?
00:12:55 <kosmikus> Cale: that being said, it's possible to give a 2-seconds talk about it, too :)
00:13:00 <Cale> heh
00:13:16 <xerox> kosmikus: you assume it? :)
00:13:19 <kosmikus> dons: no, unfortunately not
00:13:30 <dons> including things like the ml monadic regions and LINQ's monad comprehensions
00:13:46 <dons> maybe its time for a "Monads at Age 15" paper
00:14:04 <kosmikus> xerox: more or less. I argue that I'm performing the final step in the proof.
00:14:47 <roconnor> MonadFixs is even better than Monads
00:15:01 <roconnor> Not only do you get sequencing, but you get to use values from the future too.
00:20:17 * Lemmih swears at ghc-asm.
00:30:01 <earthy> hm. updating gcc while doing a ghc compile is not the smartest of things.
00:30:26 <Syzygy-> Ehe
00:32:55 <Baughn> Kaboom!
00:39:31 <kzm> @seen dcoutts
00:39:32 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts speak 7h 26m 18s ago.
00:39:44 <kzm> Should be awake again soon, then :-)
00:40:00 <kzm> Anybody use ghc on IA64?
00:44:45 <dons> kzm: yes, in the past
00:44:50 <dons> even with ghci support
00:45:38 <kzm> Well - I found dcoutts in a thread about 6.4.1 or something, so it's not that distant past.
00:46:03 <kzm> It'd be nice if there was a more concerted effort to port ghc.  (And I want a pony, too)
00:46:05 <kzm> :-)
00:46:51 <kzm> Anyway - if there is good reason to think ghc can be ported with relative ease, I can give it a try.  I got access to HP test drive now, so there's a bunch of systems waiting to be used.
00:47:30 <kzm> My half-hearted attempts in the past have failed, though.  But I hear it's easier these days.
00:51:03 <xnito> Does anyone know how to use Data.Bits
00:51:30 <xnito> i cant get shiftL to work
00:53:00 <Lemmih> > 10 `shiftL` 2 :: Int
00:53:03 <lambdabot>  40
00:54:37 <xnito> ok thanks i was missing the :: Int
00:56:55 <xnito> Is their a way to invoke a constructor method in Haskell like in c++
00:57:27 <dons> just use the constructor?
00:57:56 <dons> > Just "foo" -- ? not sure what a "constructor method" is ..
00:57:59 <lambdabot>  Just "foo"
00:59:13 <Cale> dons: think OO
00:59:18 <ibid> xnito: there are no constructor methods (as in C++) in haskell
00:59:34 <Cale> Unless you'd count something like % from Data.Ratio
00:59:43 <xnito> yea like that
00:59:46 <Cale> we tend to call those "smart constructors"
00:59:57 <xnito> but i want it for my Time Constructor
01:00:03 <Cale> they're just ordinary functions
01:00:04 <therp> can someone give me a brief idea what "zonk"-ing is about in the GHC type checker?
01:00:11 <xnito> so that it converts its to hours and minutes
01:00:14 <Cale> g'night all
01:00:24 <therp> good night cale
01:00:49 <skew> therp: I think that applies a substitution to the type variables in a term
01:00:58 <xnito> so i type in Time 0 130 => Time 2 10
01:01:02 <ibid> xnito: yeah, in that sense any function ... -> Foo is a constructor function of Foo
01:01:13 <skew> the substitutions that came from some unification
01:01:51 <kosmikus> xnito: just define a function that does the transformation and call it ...
01:02:03 <xnito> I currently have: data Duration = Time Int Int
01:02:10 <therp> skew: ah ok, now stuff starts to make a bit of sense :)
01:03:03 <xnito> i was thinking maybe i could use the read instance but i can't seem to get that to work
01:03:07 <dons> Cale: I can't think OO anymore. it's lost to me.
01:03:30 <skew> xnito: just define a function time :: Int -> Int -> Duration
01:03:44 <dons> therp: re. zonking, better ask on #ghc (or glasgow-haskell-users@ .. )
01:03:52 <dons> I used to know, but not anymore :}
01:04:17 <skew> like time min sec = let (min',sec') = sec `divMod` 60 in Time (min+min') sec'
01:05:18 <xnito> ok
01:05:27 <kosmikus> therp, dons: I think it was something about updating or eliminating Ref's in types, but I also forgot again ...
01:14:49 <xnito> ok thanks skew that function works well
01:16:48 <roconnor> ugh, why is aptitude so slow?
01:16:58 <roconnor> you'd think it was written in Haskell ;)
01:18:15 <Lemmih> ?slap roconnor
01:18:16 <lambdabot> why on earth would I slap roconnor
01:18:33 <roconnor> *L*
01:18:57 <roconnor> @botsnack
01:19:00 <lambdabot> :)
01:22:15 <dons> roconnor: ruby you mean ;)
01:22:45 * dons wonders how much faster his box would boot if all the /etc shell scripts were compiled haskell
01:23:12 <skew> isn't that called Freespire?
01:23:52 <xnito> I looked up that smart constructor thing. That satifies my data abstraction needs thanks.
01:24:12 <Baughn> dons: Not much - the scripts aren't really what takes time
01:24:39 <Baughn> dons: Check google://why userspace sucks for more details
01:24:40 <lisppaste2> skew annotated #29207 with "A nicer structured version" at http://paste.lisp.org/display/29207#3
01:25:11 <Baughn> dons: http://linux.inet.hr/files/ols2006/jones-reprint.pdf
01:25:15 <lambdabot> http://tinyurl.com/yypc54
01:28:35 <xnito> does anyone know a way to input binary directly into haskell or do i have to roll my own function?
01:31:38 <Baughn> xnito: readFile
01:31:54 <Baughn> xnito: Or any other function that returns IO ByteString, I suppose
01:36:05 <Baughn> xnito: IOW, see http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-ByteString.html#27
01:36:08 <lambdabot> http://tinyurl.com/yjac9t
01:38:15 <therp> are there any howto's for GHC debugging (via gdb if it's gotta be). the bug I'm hunting is frustrating me for 12 work hours and I'm about to just throw my whole project into trash
01:38:55 <lispy> therp: whatis the bug?
01:39:21 <therp> lispy: http://article.gmane.org/gmane.comp.lang.haskell.glasgow.user/11130
01:39:25 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/y29msz
01:39:26 <lispy> therp: there was somework done on a debugger for ghc this summer as a soc project, otherwise there is buddah
01:39:34 * lispy lookingnow
01:40:57 <skew> therp: have you read through the commentary?
01:42:29 <lispy> therp: okay, i don't understand that email, too many concepts i'm not comfortable with :(
01:42:47 <skew> I think there might be some problem with when and how names get into the renamer environment
01:42:48 <therp> skew: no, good idea.
01:43:23 <lispy> therp: as for gdb, i would look for a general tutorial, i don't know of antyhing specific to ghc
01:43:44 <therp> skew: well, the frustrating thing is, that the same template haskell expression works and it gets converted to the same HsExpr as my hack, but for some reason mine doesn't work.
01:43:44 <skew> also, you probably should look up the definition of names and uniques, and maybe make a better printer
01:43:57 <skew> can you use them together, though?
01:44:08 <therp> skew: already done that. the RdrNames are equivalent that are handed to HsVar
01:44:17 <skew> I think you might need an extra step to register the unique you invented with the renamer, or something like that
01:44:27 <skew> I mean put both versions as subexpressions in the same splice
01:44:29 <lispy> therp: Igloo is a good person to ask, he has helped to implement a good portion of TH
01:45:09 <therp> skew: the same would have to be done by TH, and the worst thing is the error: I can't find "foo", but I got "... foo ..."
01:45:41 <therp> lispy: uh ok thanks for the tip. I hope he has some spare time for such things
01:45:58 <skew> yeah, I'm thinking perhaps there is some internal state GHC carries around, which is properly updated by the reanming process when it's handling a normal expression, but your hook for passing an already-renamed expression is not handling
01:45:59 <therp> skew: the variable is obviously in the renamer. the -ddump-rn-trace shows its there.
01:46:11 <skew> have you tried actually putting both versions inside the same splice?
01:46:18 <therp> skew: the hsexpr is renamed after TH
01:47:04 <therp> skew: I have tried to put them into the same splice, but not into the same hsexpr .. like HsApp (myfoo thfoo)
01:47:17 <therp> skew: the mail just includes about 10% of the things I've tried ..
01:47:28 <skew> ah, and that still has trouble, and also still shows that the variable look identical
01:47:38 <lispy> therp: are you coming from lisp?
01:48:00 <therp> lipsy: me as a coder or the problem here?
01:48:08 <lispy> therp: as a coder
01:48:27 <therp> lispy: yes, Common Lisp
01:48:49 <lispy> therp: i ask simply because lisper seem to expect far more from TH than others
01:49:07 <lispy> okay
01:49:22 <therp> lispy: that could be true :)
01:49:32 <lispy> CL is a good language, it's where i derive my nick from :)
01:50:10 <therp> lispy: the problem I'm talking about here, is that on top of this hack, my macro facility for the Liskell will take place
01:50:21 <lispy> Ah!
01:50:35 <lispy> yeah, liskell is quite interesting
01:50:46 <skew> ah, OccName contains a "FastString"
01:50:59 <skew> I'm guessing that's something like a buffer of memory allocated with some unsafeEvil
01:51:30 <skew> so yeah, it's good to be sure they are shared
01:51:31 <therp> skew: if you hinting that these two might not be equal, I checked their equalness down to (getKey# (getUnique faststring))
01:52:12 <skew> have you tried stepping things along manually?
01:52:13 <therp> skew: this should guarantee that the UniqFM code (that is responsible for RnEnv lookups) should find it because it checks for equalness of getKey#
01:52:30 <therp> skew: no, that's why I was starting to ask for a debugger, as last resort
01:52:38 <skew> like, like, running ghci -package ghc
01:52:54 <skew> importing all the right modules, and doing the processing steps by hand, so you can see where it breaks down
01:52:55 * lispy wishes haskell had better debugggers
01:53:20 <profmakx> write one lispy :]
01:53:23 <skew> I've never done that, and you might need to recompile a few things to get those modules built for interactive use, but it sounds like it might work
01:54:21 <therp> skew: I have to do that by hand right? there is no support for step evaluation of some expression, isn't it?
01:54:55 <skew> unless the SoC debugger thing is working, but I don't know anything about it
01:57:05 <skew> now, what is failing?
01:57:12 <skew> I've got OccName loaded up in ghci
01:57:19 <lispy> profmakx: i don't know the first thing about it, but i appreciate the vote of confidence :)
01:58:23 <skew> therp: try ghc-pkg describe ghc-6.6
01:59:02 <therp> skew: you have to add this InternalE hack for this to work
01:59:29 <therp> skew: erm, what for? I'm working from a source tree, so in place package files
02:00:16 <profmakx> ;)
02:00:45 <lisppaste2> therp pasted "InternalE hack session" at http://paste.lisp.org/display/29216
02:01:04 <therp> the strange printing of RdrNames comes from my ppr extension..
02:02:35 <therp> hm to bad I can't add instance declarations for HsExpr on the ghci prompt..
02:02:53 <skew> have you tried making the thing in different name spaces?
02:03:01 <skew> waat does that U: mean?
02:03:27 <therp> skew: different from varName? yes. It also fails for dataNames
02:03:33 <skew> hmm
02:04:04 <therp> skew: RdrNames come in four flavours. U stands for Unqual (next to Orig/Qual/.. and something for unique names)
02:04:08 <skew> I think you should read the commentary, and talk to somebody who knows TH
02:04:42 <therp> skew :) yes, I think so too. thanks for looking at it
02:04:54 <therp> wow!
02:04:55 <skew> I'm not TH even shared internals with the RdrName stuff you are working with
02:05:07 <therp> a simon p. jones reply to my g-h-u posting
02:05:11 <therp> I'm excited
02:05:11 <skew> it's got it's own version of the syntax, for example
02:06:59 <skew> seems like he says they may not share the same internals
02:07:00 <therp> skew: no it doesn't share it. TH got its own idea of OccName, but also the exact imitation of the conversion TH.OccName to GHC's OccName doesn't change things
02:07:13 <skew> except if you look at the
02:07:43 <skew> if you look at the FastString library, it's using unsafePerformIO and some IORef to an interning table
02:09:59 <dcoutts> kzm, pong
02:10:01 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
02:10:30 <therp> skew: combing the two things $(return (AppE (VarE (mkName string)) (InternalE (HsVar (mkRdrUnqual (mkOccNameFS varName (mkFastString string))))))) should at least cause a successful interning :/
02:10:49 <skew> this is where things might get wierd with linking
02:12:20 <skew> the version of mkFastString you have loaded from some library into your program may have ended up with a separate interning table from the one built into the compiler, for example
02:12:45 <skew> there used to be a similar problem with the table used to implement Typeable
02:12:54 <skew> dons had to define his own to go hs-plugins working
02:13:32 <skew> otherwise Dynamic values created in dynamically loaded code didn't match up properly with the type codes from the parent program
02:14:18 <skew> well, I'm not going to be figuring anything out tonight, but what are you trying to do with TH?
02:14:20 <therp> skew: but the faststring are identical in terms of uniqueable definition, should they be different when the sit in different tables? but also I tried to create my faststring solely with mkName, unwrap the faststring and reuse it in my HsVar construct. failing too.
02:15:34 <dcoutts> kzm, we do have a binary build of ghc-6.4.1 for ia64, it's not a generic binary though, it's just a .tbz2 that expects to unpack to /usr . However it can be relocated to /opt with a bit of sed.
02:15:39 <therp> skew: I have written a set of functions that convert from a lisplike parsetree to HsExpr. now I want a parse tree modifing function to be run on a parse tree at compile time, and to make a valid HsExpr, I hand it to my ParseTree->HsExpr conversion routine. The bad thing is TH doesn't like HsExpr as result, therefore this hack
02:17:14 <therp> the thing is a bit more complicated as the ParseTree it's modifying has to be lifted to an expression that reconstructs the parse tree given to the actual parser at compile time. but that's working, I promise :)
02:17:45 <therp> it's just that issue that's denying me world domination :)
02:18:05 <skew> maybe you could target Language.Haskell.TH.Syntax.Exp instead?
02:19:30 <therp> I have to rewrite the whole thing, and also Exp doesn't provide me with location information (that is hell annoying to drag through the converter but is indispensible when really coding in the lisp language)
02:19:48 <therp> s/I have to rewrite/I don't want to rewrite/
02:20:16 <skew> figuring out how to feed various stages back into TH probably has other uses too
02:20:36 <therp> also Exp is inferior to HsExpr as target. HsExpr can take all the glasgow exts, Exp knows none of them
02:20:51 <skew> at least, being able to feed parse trees into the GHC compilation functions would be nice for editors and such
02:21:45 <therp> that's not hard. I don't need TH.Exp for that
02:22:36 <skew> hmm?
02:22:54 <skew> I mean functions like the API ghci uses, for typechecking, compiling, and loading up a bit of code
02:23:14 <therp> I could just feed $(InternalE (conversion_function <parsetree>)) into GHCi. same effect
02:25:08 <therp> well, I get some food. and I will look into GHC debugging afterwards..
02:25:22 <therp> thanks for the discussion
02:25:48 <skew> I need to go, but dons might know something about linking duplicating internal tables, if he's still up
02:26:19 <dcoutts> xerox, cairo 1.2.6 is out :-)
02:30:31 <kzm> dcoutts, well - my tests show that the x86 emulation performs adequately, as far as I can tell.  So I'll postpone it until native IA64 becomes a requirement.
02:30:36 <kzm> Thanks anyway.
02:31:18 <dcoutts> kzm, ok, the ia64 build is registerised so might be faster. dunno.
02:33:40 <kzm> Yeah.  I had a user who experienced severe slowdowns (x100? x1000?), but I get almost exactly the same performance pr MHz, so I think it is a problem on his box.
02:34:38 <kzm> For me, a 900MHz IA64 takes three times as much time as a 2.8GHz P4..
02:37:50 <dcoutts> kzm, yeah, kind of a shame.
02:38:25 <dcoutts> kzm, if you know about ia64, the ia64 ghc port could do with some love.
02:38:31 <dcoutts> it works, but only just.
02:38:44 <dcoutts> I've not tried 6.6 yet
02:40:27 <dcoutts> most of the problems are down to gcc interactions. I think it'd do better with a native code gen as we could control things better, eg register usage / spills
02:41:53 <kzm> I haven't really been successful in previous attempts to compile ghc on less common architectures.
02:42:38 <kzm> I got an HP test drive account now, so I can try it out.
02:44:58 * roconnor thinks we should use Control.Function
02:45:17 <lispy> roconnor: why is that? we *just* got it!
02:45:56 <lispy> dcoutts: are you a graduate student?
02:46:03 <dcoutts> lispy, aye
02:46:10 <lispy> dcoutts: i thougth youw were an advisor :)
02:46:18 <lispy> but i saw you talking to dons about advisors :)
02:46:20 <dcoutts> what's an advisor ?
02:46:31 <lispy> well, a professor who has studenst
02:46:39 <roconnor> lispy:  isn't the Control hierarchy about data flow?
02:46:50 <dcoutts> lispy, well I'm also a teaching assistant
02:46:51 <lispy> roconnor: yes
02:47:03 <roconnor> Don't functions flow data?
02:47:24 <lispy> dcoutts: cool, you seem very knowledgable, are you an older (or should I say, more experienced, student?)
02:47:29 <dcoutts> kzm, at least for linux there are builds for loads of arches, between debian and gentoo we've got most arches I can think of.
02:48:00 <lispy> roconnor: yeah, i read kosmikus's emails...i agree with them...
02:48:02 <dcoutts> lispy, are you calling me fat^H^H^Hold ?! ;-)
02:48:08 <lispy> dcoutts: hehe
02:48:26 <lispy> dcoutts: i'm calling you wise, take it as  you will :)
02:48:31 <dcoutts> heh
02:48:44 <roconnor> lispy: who is kosmikus?
02:48:50 <lispy> roconnor: malcom
02:49:02 <lispy> the wallace guy
02:49:14 <dcoutts> you're confused
02:49:18 <lispy> i am?
02:49:21 <lispy> hm...
02:49:30 <dcoutts> kosmikus is Andres Loeh
02:49:36 <lispy> yes
02:49:42 <lispy> gash...i'm silly
02:49:57 * lispy growels at the confused memories
02:50:12 <lispy> i met so many people at the haskell-workshop
02:50:27 <dcoutts> lispy, malcolm is malcolm
02:50:37 <lispy> yes, Andres Loeh is definitely kosmikus...but i must have also met malcom wallace
02:50:45 * malcolm waves
02:51:02 <lispy> malcolm: hi, sorry to confuse you with others!
02:51:06 * roconnor doesn't think of functions as data
02:51:10 <dcoutts> lispy, and careful wit the spelling ;-)
02:51:18 <roconnor> Functions are the one thing that isn't data :)
02:51:43 <ski> functions are "righty"
02:51:47 <lispy> dcoutts: you mean i even get the spelling wrong too!  geez....i'm just going to hang my head in shame....
02:51:58 * lispy hangs his head
02:52:30 <dcoutts> lispy, silent second 'l' in malcolm, trick ism just use tab completion. :-)
02:52:32 <malcolm> functions and data are totally interchangeable
02:52:50 <ski> it depends of course on what one means by 'data'
02:53:00 <lispy> yeah, if lisp taught me one thing it's that code is data and data is code
02:53:07 <malcolm> I'm thinking of the Church encoding of numerals as lambda expressions
02:53:17 <malcolm> as just one example
02:53:39 <dcoutts> malcolm, btw, are you coming to the Oxford afternoon event later this month?
02:53:45 <lispy> dcoutts: tab completetion is good....thanks :)
02:54:05 <roconnor> malcolm: try doing a case analysis on a function
02:54:07 <malcolm> dcoutts: sorry, can't come because I'm teaching that afternoon
02:54:15 <roconnor> then you will see the difference
02:54:18 <lispy> having 2 long islands and a pitcher of beer makes irc hard...
02:54:18 <ski> roconnor : i assume by 'data' here you mean something like things that can be pattern-matched and analyzed etc
02:54:28 <dcoutts> malcolm, oh that's a shame. I was hoping to compare notes on fusion stuff.
02:54:42 <roconnor> ski: yes, something declared with the data keyword is a good start.
02:55:21 <ski> in Charity, there's "left" and "right" types .. and functions are a "right" type, while e.g. 'Either','(,)' would be "left"
02:55:24 <lispy> roconnor: but, if you can tell the difference, you just need to do a bit more FP
02:55:26 <malcolm> dcoutts: yeah, I'd like to do that too.  I have a paper on my hylo fusion ideas that I'd quite like to co-author with one of you guys, by including a comparison with the Streams stuff
02:55:47 <araujo> Morning!
02:55:56 <lispy> araujo: morning@
02:56:00 <lispy> s/@/!/
02:56:02 <dcoutts> malcolm, well I'm going to switch focus of my Phd to work on this, so the more papers the better :-)
02:56:13 <araujo> lispy, heya :-)
02:56:20 <roconnor> lispy: I do a lot of function programming, and I am always see the difference between (co-)inductive data and function / dependent products.
02:56:21 <malcolm> dcoutts: oh cool.
02:56:43 <dcoutts> malcolm, yeah, it's a good deal more fun that what I was doing before.
02:56:49 <lispy> roconnor: okay, you just bested me with terminology! :)
02:56:55 <ski> roconnor : hm, are you separating coinductives and functions, here ?
02:56:56 <malcolm> dcoutts: it is possible that I might have caught up with my lecture material sufficiently to be able to cancel my lecture that day
02:57:03 <dcoutts> and fortunately my funding isn't tied to any particular project
02:57:17 <malcolm> dcoutts: what was your previous topic?
02:57:18 <roconnor> ski: in type theory the seem to be separate.
02:57:44 <roconnor> they seem to be separate
02:57:56 <ski> roconnor : not so much in linear type theory, i think
02:58:02 <dcoutts> malcolm, making partial evaluation in typed languages more practical and easier for the programmer to predict & control.
02:58:12 * lispy needs to read more about these linear types
02:58:34 <roconnor> ski: that may be true.
02:58:45 <roconnor> none the less, haskell doesn't have a liner type system.
02:58:46 <malcolm> dcoutts: ah, well that sounds pretty interesting too.
02:59:23 <dcoutts> malcolm, yeah, though it was only going so so.
02:59:25 * lispy thinks linear means soemthing different here than in linear algebra
02:59:33 <ski> roconnor : if you have a value of an additive product, then the only thing you can do to eliminate it is to extract one of the parts .. and this is similar to applying a function, see ?
02:59:49 <dcoutts> malcolm, well, let me know if you'll be there, otherwise we can probably arrange something else.
03:00:26 <malcolm> dcoutts: sure.  I'll probably only know if it is going to be possible nearer the day.
03:00:27 <roconnor> ski: with co-inductive type I can do co-recursion, but I can't do co-recursion to produce functions.
03:01:15 <dcoutts> malcolm, eg I can probably arrange to invite you to come talk some other time
03:01:59 <ski> roconnor : hm, yes .. i think this aspect is another aspect than the left/right one, though
03:02:17 <malcolm> dcoutts: OK, that sounds almost like a plan
03:02:26 <dcoutts> malcolm, there's a seminar series for this new 'metacomputation' project. Apparently fusion is on-topic.
03:02:45 <ski> (roconnor : e.g. additive products still doesn't behave like normal data ..)
03:03:54 <ski> (left / right btw seems to correspond to strict / non-strict)
03:08:44 <gds> @where Links
03:08:46 <lambdabot> I know nothing about links.
03:09:49 <gds> @where+ Links http://groups.inf.ed.ac.uk/links/
03:09:51 <lambdabot> Done.
03:09:54 <pejo> Do people keep their darcs repositories in ~/public_html, or do they simply copy them there?
03:10:16 <dcoutts> pejo, I use symlinks
03:10:17 <wolverian> symlink
03:10:20 <kzm> pejo: I push there when I think the program is ready for it.
03:10:22 <wolverian> ..what dcoutts said.
03:10:30 <kzm> (but my public_html is on a different host anyway)
03:10:34 <lispy> pejo: i keep them theer
03:10:45 <wolverian> (you might have to configure your web server to enable symlinks out of public_html, though)
03:11:09 <Cale> heh, written with the insanely overloaded (.) operator: ((f . g) .) = ((f .) . (g .))
03:11:26 <lispy> pejo: but i also follow the advice on the darcs wiki about keeping a separate 'master' copy of the repo that you never work in
03:12:01 <Cale> ((.) = fmap)
03:12:42 <lispy> Cale: fwiw, i really struggle with ((foo .) .)
03:13:03 <Cale> or else
03:13:13 <Cale> (.) (f . g) = (.) f . (.) g
03:13:33 <lispy> oy
03:13:47 <Cale> crazy :)
03:13:56 <Cale> (.) = fmap is kind of an interesting idea
03:14:00 <wolverian> agh my brane
03:14:00 <lispy> so (.) (f . g) takes too parameters?
03:14:21 <Cale> no, just one functorial parameter
03:14:23 <dcoutts> @type (.) (f . g)
03:14:25 <lambdabot> Not in scope: `f'
03:14:26 <lambdabot>  
03:14:26 <lambdabot> <interactive>:1:9: Not in scope: `g'
03:14:35 <dcoutts> @type \f g -> (.) (f . g)
03:14:37 <lambdabot> forall b c b1 a. (b -> c) -> (b1 -> b) -> (a -> b1) -> a -> c
03:14:38 <pejo> lispy, um, so when I run darcs init I get one repository, which I'm supposed to copy to a backup, and don't use it?
03:14:45 <Cale> (it depends on which functor)
03:14:53 <Cale> I'm using the definition (.) = fmap
03:14:57 <Cale> and the Reader instance
03:15:05 <ski> @type (.) (.)
03:15:07 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
03:15:09 <ski> @type (.) . (.)
03:15:11 <lispy> pejo: yeah, i guess you could think of it that way
03:15:11 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
03:15:34 <Cale> So we get things like f . Just x = (Just . f) x
03:15:54 <lispy> pejo: i think that  you want one copy which you don't work out of but push to, so that in your local copy you can do whatever the hell you want without feer of corrupting it
03:16:13 <Cale> or more generally,  f . return x = (return . f) x
03:16:39 <lispy> pejo: i tend to use a star togology with my repositories if that helps
03:17:00 <lispy> pejo: i tried some more general topologies but i found star is the easiest to work with
03:17:31 <pejo> lispy, how exactly is a push done, you check out the master repository, merge the patches from the other repository and hten commit to the master rep?
03:18:42 <lispy> pejo: hm...how to explain...i guess i kinda follow (implicitly) the cvs/svn model...each checked out copy pushes to the master when they want to update, and pulls when they want to synchronize
03:19:16 <lispy> but, you can still cherry pick between repos when you need/want to
03:19:22 <lispy> (which i do sometimes)
03:19:43 <pejo> lispy, isn't part of the idea that I'm supposed to be able to wildly commit to my local rep, while slashing away at stuff?
03:20:22 <lispy> pejo: yeah, that is fine, but i've found it's even safer to do that when yopu have some 'master' repo
03:20:50 <lispy> pejo: so if you ever look at your local copy and say, 'this sucks....rm -rf *
03:20:57 <lispy> you still have some copy :)
03:22:43 <lispy> pejo: i guess i would say, arbitrary togology is allowed but that doesn't mean in always makes sense
03:22:56 <Syzygy-> togology?
03:23:25 <lispy> Syzygy-: yeah, not in the sense of open and closed sets, but in the more general sense of how things are connected
03:23:34 <Syzygy-> Ah. Topology.
03:23:49 <lispy> oops, yeah, misspellings and all :)
03:24:54 <metaperl> any bored haskellers want to contribute to this node? it only would take you 5 minutes: http://sequence.complete.org/node/222
03:26:37 <lispy> metaperl: i'm not sure you could do that in 2 lines of haskell, portably and nicely looking
03:27:02 <love-pingoo> metaperl: saying that python is functional is a bit abused
03:27:05 <lispy> the pay off in haskell is in maintainability and in knowing certain things are correct
03:27:06 <metaperl> lispy: contribute to the thread please?
03:27:11 <love-pingoo> being functional is not just having first class functions
03:27:12 <norpan> bah, everybody knows you use find -print0 and xargs -0
03:27:18 <metaperl> love-pingoo: did I say python was functional?
03:27:35 <love-pingoo> you wrote "And PYthon combined object, functional and imperative in a prettier more understandable way than Ocaml did."
03:27:44 <metaperl> lispy: the payoff in haskell need not be talked about... it is head and shoulders above all else int he world of programming
03:27:59 <lispy> metaperl: heh
03:28:09 <metaperl> love-pingoo:  oh... yeah ... well.. i have reduce() list comprehensions... recursion ...
03:28:32 <metaperl> norpan: print0 fixes that?
03:28:43 <metaperl> i dont know what print0 is
03:28:44 <norpan> -print0 for find and -0 for xargs
03:28:45 <love-pingoo> yeah, but statements<>expressions, no block-scoping, and guido wants to remove reduce and map...
03:29:00 <norpan> it separates the filenames by \0 instead
03:29:22 <metaperl> remove reduce and map???
03:29:37 <metaperl> norpan: but it idd not escape the spaces int he filenames
03:29:52 <norpan> it doesn't have to, -0 to xargs takes care of that
03:29:58 <love-pingoo> http://www.artima.com/weblogs/viewpost.jsp?thread=98196
03:30:02 <lambdabot> Title: The fate of reduce() in Python 3000, http://tinyurl.com/65lfo
03:30:32 <love-pingoo> lambdabot: wow
03:32:53 <lispy> metaperl: okay, i posted
03:32:57 <araujo> mr_ank, .ar?
03:33:03 <metaperl> lispy: thanks
03:33:19 <lispy> as for escaping args, i have used the xargs replace string functionality for that
03:33:32 * araujo playing with his baoding-balls
03:33:33 <lispy> i forget the syntax, but the man page is pretty clear
03:33:45 <dons> i like this: "filter(P, S) is almost always written clearer as [x for x in S if P(x)],"
03:34:03 <araujo> i'd like to have them painted with the lambda symbol
03:34:05 <lispy> uh..yeah....
03:34:30 <dons> that was a fun post. sometimes i think there should be a compiler-writer license
03:35:35 <lispy> dons: well, practicing CS should require a licences
03:35:39 <lispy> license*
03:35:56 <metaperl> I am going to miss reduce. I suppose I will personally implement it and use it
03:35:58 <lispy> and i'd be a card carrying member :)
03:36:17 <lispy> metaperl: well, CL reduce == foldl
03:36:21 <metaperl> lispy: the IT world and practicing CS are 2 different beasts altogether
03:36:26 <lispy> metaperl: maybe the same is true of python?
03:37:07 <lispy> metaperl: yeah, sometimes too different
03:37:32 <SamB_XP> IT should require a cage or something
03:37:34 <metaperl> PHP is completely non-CS, but it 0wnzzz
03:37:55 <metaperl> I still laught when I recall dons trying to setup a PHP bulletin board
03:38:19 <metaperl> a ph.d candidate doing memory mgmt issues in haskell gets body-slammed trying to setup a php bb :)
03:39:05 <lispy> metaperl: i cannot programming php, fwiw
03:39:12 <lispy> and i have a degree in CS
03:39:26 <profmakx> PHP is so non-CS
03:39:29 <lispy> but, i'm sorry, i'm too lazy to deal with issues the compiler should see
03:39:50 <_matthew_> surely, a degree in CS should ensure you are insulated from having to program in PHP?
03:40:14 <dons> metaperl: heh. it was the "patches" that sucked
03:40:28 <dons> they were distributed as manual diffs that had to be edited by hand
03:40:36 <lispy> ouch
03:40:40 <dons> no automation at all. very nasty.
03:40:45 <metaperl> Drupal is one of the most amazing pieces of software ever written. I have installed it and loved it and then removed it simply because it is PHP and MySQL, the 2 most non-CS things in open source
03:40:57 <lispy> i've only done that for one piece of sofware, and that was for the linux kernel and i desparately needed the patches to get my driver working
03:41:00 <dons> i.e. "goto line 7; substitute x for y; goto line 9; remove that line ; ..."
03:41:09 <_matthew_> metaperl: you can make it work with postgresql
03:41:18 <dons> apparently 'diff/patch' isn't widely used in the php community?
03:41:21 <metaperl> _matthew_:  yeah, true
03:41:30 <int-e> dons: heh that makes cvs sound like heaven. or even rcs.
03:41:38 <SamB_XP> int-e: even *diff*!
03:41:40 <lispy> int-e: heh
03:41:44 <int-e> SamB_XP: right.
03:41:46 <dons> let me see if i can find one of these 'patches'
03:41:53 <lispy> cvs sounding like heaven is insanity where i come from
03:41:53 <_matthew_> int-e: you know you're in trouble when...
03:42:01 <dons> oh, theyre called 'mods' too :)
03:42:03 <dons> not patches
03:42:10 <profmakx> there?s always darcs
03:42:11 <dons> cause there all kewl modders
03:42:21 <profmakx> its funny how fast i switched from svn to darcs -.-
03:42:29 <dons> heh
03:42:45 <SamB_XP> dons: well, you would think if they were called patches one of the "patchers" would haver run accross patch(1)
03:43:42 <dons> what is nice is that the mods are distributed with cabal-like files, containing useful advice like:
03:43:45 <dons>                 Installation Level: Easy
03:43:48 <dons>                 Installation Time: ~ 10 Minutes
03:43:52 <dons> since you have to apply the patch by hand...
03:44:33 <earthy> sick it makes me
03:44:40 <lispy> automation? what's that? where i get the intern to do it for me?
03:45:00 <lispy> darcs++
03:45:05 <SamB_XP> lispy: yes, exactly! you get the intern to distribute the patch for you!
03:45:20 * lispy delegates to the intern
03:45:24 <lispy> intern++
03:45:25 <SamB_XP> maybe he has heard of diff(1)/patch(1)
03:45:49 <earthy> then again, I already knew PHP sucked when it was still called personal home page / form interpreter
03:45:57 <lispy> darcs may have a few theoretical flaws, but at least darcs doesn't suck
03:46:13 <metaperl> lispy: why 2-liner is now an 8-liner: http://sequence.complete.org/node/222
03:46:24 <lispy> i cannot say the same about cvs/svn
03:46:43 <int-e> darcs pretends history is not important though - I think that's a mistake. Or maybe I just can't wrap my head around it.
03:46:59 <dons> ah, here we go. see they have their own DSL for describing manual 'mods'..
03:47:12 <profmakx> braindead
03:47:13 <dons> so for example, if you want to add some locking feature to phpbB, you download
03:47:14 <dons> http://www.cse.unsw.edu.au/~dons/tmp/auto-lock-1.0.0em.txt
03:47:17 <lambdabot> http://tinyurl.com/y6xtpj
03:47:26 <dons> and then execute that file *by hand*
03:47:27 <lispy> int-e: i'd love to hear your thoughts on it (but not now)
03:47:51 <lispy> int-e: i have some similar intuition, but at the same time, darcs breaks ground by pretending this
03:47:58 <dons> now the scary thing is that they have 100s or 1000s of these files.
03:47:59 <arjanb> int-e: history is important for darcs but it has another definition of history than all other rcs
03:48:09 <dons> all distributed as manual patches http://www.phpbb.com/phpBB/catdb.php?cat=52
03:49:03 <profmakx> dons thats just because you can sell it as a big new shiny feature if you have it automated in phpBB v14.2
03:49:17 <dons> metaperl: so this is why phpBB body-slammed me :)
03:49:24 <metaperl> ah
03:49:44 <dons> now, how many dollars do I make if I write a little program to translate their patches into darcs hunk format
03:49:46 <int-e> dons: wow, that looks like there should be a tool to apply these
03:50:00 <int-e> dons: crazy stuff.
03:50:13 <profmakx> zero
03:50:32 <profmakx> it?s not the money-sell thing i guess ;)
03:50:37 <metaperl> I can _NOT_ believe I am seeing this in the year 2006: http://www.phpbb.com/files/mods/cia_101.mod
03:51:09 <metaperl> are kindergarten teachers writting these mod files?
03:51:19 <dons> see the little hints you're supposed to follow: [ AFTER, ADD ]
03:51:20 <dons> for example.
03:51:30 <dons> the whole language is documented, and designed to be executed by humans
03:51:35 <dons> its realy really bizarre
03:51:40 <metaperl> yes, definitely intended so that kindergartners can apply patches
03:51:41 <dons> let me find the spec...
03:51:56 <metaperl> this is a waking nightmare and nothing less. i'm leaving is disgust
03:52:46 <mr_ank> araujo: yes, .ar = argentina
03:53:19 <lispy> metaperl: have you thought about going back to the find command and using the replace sting syntax?
03:53:24 <Cale> hehe, someone doesn't know about diff :)
03:53:37 <dons> and they built a huge community that didn't know either..
03:54:06 <lispy> metaperl: as an example from the man pgae
03:54:08 <lispy> /bin/ls -1d [A-Z]* | xargs -J % cp -rp % destdir
03:54:16 <lispy>  /bin/ls -1d [A-Z]* | xargs -J % cp -rp % destdir
03:54:31 <Cale> What does MOD stand for, or if "modification", why is it in all-caps?
03:54:32 <lispy> the % character gets replaced
03:54:34 <araujo> mr_ank, cool!
03:54:34 <dons> "Description: Installing a MOD, whatever size it is and whatever your skills in HTML/PHP/phpBB are
03:54:37 <dons> is always a very risky operation"
03:54:37 <lispy> so you you can wrap in in quotes
03:54:51 <araujo> mr_ank, haskell programmer?
03:55:14 <dons> ah, here we go. the spec, http://www.phpbb.com/phpBB/viewtopic.php?t=61611
03:55:17 <lambdabot> http://tinyurl.com/ydjoe9
03:55:24 <lispy> find ~/Music -name '*m3u' | xargs -J % rm "%"
03:55:50 <dons> Cale: its all caps because its cool! isn't that obvious?
03:56:09 <Cale> heh
03:56:13 <int-e> lispy: -J ?
03:56:37 <lispy> int-e: yes, the man page says, -J defines a replacement string
03:56:44 <lispy> int-e: perhaps, ymmv
03:57:05 <Cale> MOD Version: 1.0.2
03:57:05 <Cale> Installation Level: Intermediate
03:57:05 <Cale> Installation Time: ~ 15 Minutes
03:57:07 <Cale> haha
03:57:08 * beelsebob pokes people
03:57:15 <beelsebob> anyone fancy a data structure challenge?
03:57:22 <Cale> What could be less than a second takes 15 minutes
03:57:23 <lispy> beelsebob: i do!
03:57:29 <int-e> here it's --replace[=replace-str], -i[replace-str] (deprecated), -I replace-str
03:57:33 <int-e> no -J.
03:57:39 <beelsebob> lispy: okay... see if you can come up with a structure for this...
03:57:44 <beelsebob> I have a graph
03:57:53 <beelsebob> this graph contains different kinds of edges
03:57:54 <lispy> int-e: hm...yeah, that -i looks really familiar...i'm on OSX
03:58:00 <Cale> "I took a long time to create this MOD, so you should take a long time to install it."
03:58:02 <dons> Cale: oh, and they construct the patches  by hand too, of course.
03:58:04 <beelsebob> one kind of edge is the "result pointer"
03:58:19 <int-e> lispy: yay for portability.
03:58:20 <beelsebob> I need to build a set of all the nodes in the graph making a traversal over it
03:58:25 <beelsebob> BUT*
03:58:40 <beelsebob> I must also group all the nodes with result pointers between them together
03:58:44 <Cale> Right, so if you're hacking on phpbb, I suppose it's normal to just keep a list of everything that you've done
03:58:45 <beelsebob> into their own sets
03:58:48 <dons> they sit down and write out the editing steps they have to take. its really stunning how far they ran with this idea
03:58:48 <lispy> int-e: yeah, iirc, bzip2 has a similar issue
03:59:11 <dons> Cale: and can you imgaine how slow the dev process must be?
03:59:12 <araujo> mr_ank, we got this haskell spanish channel going on, stop by #haskell.es if you are interested, you are welcome
03:59:20 <Cale> dons: It's ridiculous
03:59:21 <beelsebob> how do I maintain not only the whole set as a set, but also all the items in the sub-sets appropriately
03:59:36 <dons> "oh wait ... my patch didn't apply ... oh hang on .. let me write that again .. can you resend it... was that really line 17? ... "
03:59:54 <Cale> heh, someone should post an announcement on the board that they're all idiots
04:00:13 <lispy> dons: i've had some very "enlightening" conversations with droundy about 'patch' and the limitiations it has
04:00:32 <Cale> and show how diff, and the occasional shellscript could do what they're doing
04:00:41 <lispy> dons: aparantly you can construct diffs which look innocent, but combined together have unexpected behavior
04:00:55 <Cale> Though the real WTF is why phpbb isn't modular if so many people are writing mods for it
04:01:01 <SamB_XP> Cale: why bother telling them they are all idiots?
04:01:17 <Cale> SamB_XP: Well, not just that they're idiots, but how to use diff :)
04:01:18 <psnl> Cale: the real wtf... is that people run it
04:01:20 <dcoutts> aye, they're clearly happy, leave them be
04:01:30 <lispy> Cale: SamB_XP has a point, just write a *new* forum software...
04:01:34 <dons> lispy: huh, interesting. I guess TimToady knows? (but patch is kinda unmaintained for the last 20 years?)
04:02:09 <dons> maybe they should rewrite patch in perl6 now. that'd be fun.
04:02:09 <lispy> dons: droundy did tell someone about it, Tom lords, iirc, but they didn't see it as a problem since it was a pathelogical example
04:02:27 <dons> yeah, fair enough.
04:02:52 <lispy> well, ignoring pathelogical examples is the difference between unix and windows, if you ask me :
04:02:53 <Cale> http://www.phpbb.com/phpBB/viewtopic.php?t=217673&sid=df05a81e8ab2b00a68afca2cf821bb2e -- haha
04:02:54 <lispy> :)
04:02:56 <lambdabot> http://tinyurl.com/yykufd
04:03:32 <dons> cool! Installation Level: Fully Automated
04:03:37 <dcoutts> ooooh
04:03:38 <lispy> dons: take unix scheduling for instance versus windows scheduler...go ahead, google it..you'll see that many expoilts exist if programs wanted to use them
04:03:45 <SamB> actually, I meant you could just suggest diff/patch and be done with it...
04:04:10 <SamB> insulting their intelligence, as satisfying as it might seem, won't endear the suggestion to them...
04:04:12 <dons> then ... Installation Time: ~ 3 Minutes
04:04:23 <dcoutts> in some sense their patch system is more flexible than diff / patch
04:04:26 <dons> maybe darcs should tag patches with their applicatoin time.
04:04:31 <SamB> hah
04:04:41 <lispy> dons: heh, i'll suggest it some time....
04:04:45 <SamB> it depends on if you have conflicting or almost-conflicting patches, dons ;-)
04:04:47 <dcoutts> even with patch's ability to use context
04:04:49 <lispy> see how many laughs i get
04:04:50 <dons> SamB: right!
04:05:06 <dons> dcoutts: yeah, the machine they execute it on has a rich instructoin set
04:05:15 <dcoutts> yes
04:05:24 <mr_ank> araujo: cool, will do
04:05:27 <dons> no cherry picking support, though, i suspect
04:05:39 <dons> and i think conflicts may be a problem after a while.
04:05:42 <dcoutts> kosmikus would say that their patches express intention better than diff/patch
04:05:45 <dons> i wonder if there is a conflict handling protocol
04:05:45 <lispy> dons: heh, nice way to explain humans in computablility theory :)
04:06:05 <SamB> are you kidding? gotos everywhere!
04:06:16 <SamB> that isn't a very intentional way to express patches!
04:06:27 <dons> dcoutts: should i mail swiert and kosmikus pointing out this rich patch format they've neglected in the paper?
04:06:34 <dons> i think this is a critical oversight
04:06:41 <dcoutts> dons, yeah definately :-)
04:06:58 <SamB> though the processor time for that can get expensive
04:07:17 <SamB> hmm. what should I eat...
04:07:25 <SamB> I had an english muffin already...
04:07:35 * SamB wonders if those are really english
04:07:36 <dcoutts> how rude!
04:07:41 <dons> heh
04:07:42 <dcoutts> oh, I see "muffin"
04:07:48 <dons> not a bit of crumpet
04:07:51 <SamB> what did you think I said?
04:08:06 * dcoutts doesn't say
04:08:11 <SamB> "english man"?
04:08:16 <SamB> "english buffoon"?
04:08:16 <dons> no no
04:08:32 <lispy> joking aside, i thought the paper by kosmikus was very good, but droundy didn't think it was general enough
04:08:51 <lispy> sadly, i'm no expert on patch theory
04:08:56 <lispy> it all looks promising to me
04:09:05 <dons> Cale: you think there's a MOD to add LAMBDAS in there somewhere?
04:09:06 <SamB> didn't droundy just invent patch theory?
04:09:17 <lispy> SamB: pretty much
04:09:18 <dcoutts> lispy, really? not general enough? I thought it was very general. More so than darcs' system which is obviously anchored in practicality.
04:09:34 <lispy> dcoutts: that's how i felt
04:09:47 <dons> they have a cool rating system for their patches
04:09:50 <lispy> dcoutts: but, david felt like it wasn't right
04:09:52 <dons> Rating: 3.93 (40 votes)                          Discuss/Rate/Review  Hits:  Reviews:
04:09:55 <dons>                                                                                       36828  259
04:09:59 <dons> maybe we need that for libraries@
04:10:11 <Cale> dons: heh, they should have MODs to the MOD spec to add new instructions before you can properly apply their MODs to phpBB.
04:10:11 <lispy> dcoutts: although, i did feel that line labels was completely impractical
04:10:15 <dons> intercalate : Rating 7.3
04:10:21 <lispy> dons: hehe
04:10:28 <dons> concoculate: Ration -0.2
04:10:37 <dcoutts> lispy, I thought that was a very interesting idea, not sure exactly how it should be implemented though.
04:10:38 <lispy> dcoutts: so, until someone proves to me that line labels can be made practical, i'm not sold
04:10:44 <dons> Cale: heh
04:10:49 <SamB> dons: thats no good!
04:10:56 <SamB> I want *positive* rations
04:11:02 <dcoutts> lispy, aye. It'd have the advantage that patches would then be constant and hashable.
04:11:13 <lispy> dcoutts: have you heard what Igloo produced recently documenting darcs' conflictors?
04:11:22 <dcoutts> no
04:11:32 <lispy> it's enligtening from the darcs POV
04:11:40 <SamB> "line labels"?
04:11:58 <dcoutts> SamB, the point is to abstract away slightly from line numbers
04:12:06 <lispy> dcoutts: http://urchin.earth.li/~ian/conflictors/
04:12:09 <lambdabot> Title: Index of /~ian/conflictors
04:12:16 <SamB> how does it work?
04:12:19 <dcoutts> SamB, because line numbers in patches change when other patches add lines earlier in the file.
04:12:27 <SamB> yes, I'm aware ;-)
04:12:34 <SamB> or remove lines
04:12:40 <lispy> SamB: well, in theory you just give each line a unique label, in practice...well not much discussion yet
04:12:50 <SamB> lispy: "each line"?
04:13:05 <lispy> SamB: yup, how about we agree to view a file as a linked list of lines
04:13:06 <SamB> also, what unique label?
04:13:18 <lispy> SamB: then we just label each node in the list uniquely and we're done
04:13:27 <Cale> http://www.phpbb.com/mods/modx/index.php -- apparently they have an XML version of the MOD description format, but I don't see a tool to automatically apply them.
04:13:32 <SamB> yes, but. that is the same thing we already do.
04:13:54 <lispy> SamB: keep in mind, i'm not convinced of the practicality
04:14:10 <SamB> @type liftM (zip [1..] . lines) readFile
04:14:11 <dons> Cale: there's something charming about that. they try so hard!
04:14:12 <lambdabot>   Couldn't match `String' against `IO String'
04:14:13 <lambdabot>    Expected type: FilePath -> String
04:14:15 <SamB> aww.
04:14:21 <SamB> @type liftM (zip [1..] . lines) . readFile
04:14:24 <lambdabot> forall a. (Num a, Enum a) => FilePath -> IO [(a, String)]
04:14:28 <SamB> ah, better ;-)
04:14:58 <SamB> lispy: so what is the difference between that and line numbers?
04:15:02 <dons> ?users
04:15:03 <lambdabot> Maximum users seen in #haskell: 265, currently: 223 (84.2%), active: 36 (16.1%)
04:15:15 <lispy> dons: the php approach here is not an isolated thing... a lot of computer savvy people don't seem to realize that if they just tweaked things a little thy could automate
04:15:16 <dons> ah , so not that many lurkers lost after the reboot
04:15:27 <lispy> SamB: line numbers are not unique
04:15:51 <SamB> explain!
04:15:53 <dons> lispy: scary. i thought automation was the defining characterstic of programmers
04:15:56 <dons> apparenly not.
04:16:05 <SamB> not in comm systems I guess
04:16:09 <lispy> SamB: line lables would be unique even if we created the same identical files, i would have my lables and you'd have yours and they'd differ
04:16:19 <SamB> oh, okay.
04:16:27 <SamB> so does each line get a UUID?
04:16:41 <lispy> SamB: hehe
04:16:50 <SamB> (why are there several names for those anyway?)
04:16:54 <lispy> SamB: i don't believe UUIDs are really unique
04:17:01 <SamB> perhaps not
04:17:11 <SamB> though, they are supposed to include the ethernet address aren't they?
04:17:13 <lispy> SamB: this is why i'm not convinced line lableswork
04:17:30 <dons> Cale: qwe1234 troll of the day, "oh come on, what do 'functional languages' have to do with lambda calculus?"
04:17:33 <lispy> SamB: oh big deal, so i swap network cards with you,n now what?
04:17:37 <dons> i like the touch of adding quotes
04:17:39 <Binkley> haha
04:17:40 <roconnor> lispy: UUIDs are effectively unique
04:17:41 <SamB> lispy: and the time
04:17:57 <lispy> but we share time!
04:18:02 <SamB> hmm?
04:18:06 <roconnor> especially UUID 4 based on random bitts
04:18:16 <roconnor> bit
04:18:18 <roconnor> bits
04:18:24 <lispy> SamB: we both expreienced Nov 3rd, 2006
04:18:37 <SamB> yes. but, not with the same ethernet card!
04:18:44 <lispy> SamB: so how is time going to give us a unique name?
04:18:58 <arjanb> lispy: UUIDs for line labels are easy if you can sign patches
04:18:59 <SamB> personally I'd be more worried about virtual ethernet cards, or those with reconfigured MAC addresses
04:19:00 <roconnor> and not with the same random initial value
04:19:03 <SamB> (you can do that, you know!)
04:19:24 <lispy> SamB: right
04:19:42 <Cale> dons: that's great
04:20:02 <lispy> arjanb: perhaps crytography gives us an answer, i certainly can't refute it
04:20:19 <SamB> but, I will be surprised if someone manages to encounter an accidental conflict
04:20:37 <lispy> SamB: okay, so maybe practicallity should win here...
04:20:39 <SamB> arjanb: how does that work?
04:20:44 <lispy> but caution can't hurt
04:20:46 <roconnor> UUID are unique in practice if they are properly created
04:20:48 <SamB> the line label includes a signer key?
04:21:01 <dons> also a good one "no, turing machines et al. are abstractions of computations. 'monads', on the other hand, is a meaningless buzzword." -- should we tell Moggi that monads are now buzz-worthy?
04:21:22 <therp> lispy: uniqueness in cryptography is defined that given a good entropy source an a sufficiently large target domain, we assume that the chance of generated the same unique id (or UUID in this case) is neglegtably small
04:21:30 <lispy> okay so now line labels are huge, and we need, say, 4million for a big file...now the repository is 4million*1024 bytes..great, users are annoyed
04:21:30 <SamB> dons: you could tell him it isn't *quite* meaningless
04:21:41 <SamB> just almost so, due to generality
04:21:56 <lispy> therp: okay
04:22:17 <lispy> therp: not what i would intuitively call unique but i can see how its useful to us that
04:22:39 <SamB> but, I'm not sure that is a good enough guarentee when line labels are involved
04:22:40 <roconnor> lispy: 256 bytes per UUID is sufficent.
04:22:40 <dons> hmm. btw, is there any work on reducing the size of darcs patches?
04:22:46 <dons> cksums of cksums or something?
04:22:47 <roconnor> er
04:22:54 <roconnor> lispy: 256 _bits_ per UUID is sufficent.
04:23:08 <lispy> dons: arjanb had a solution, but no one, afaik, has implemented it
04:23:21 <SamB> if you can guarentee that it is impossible for line labels from distinct parties' patches to be the same, though, that sounds good enough
04:23:22 <lispy> > 256 / 8
04:23:24 <lambdabot>  32.0
04:23:36 <lispy> roconnor: so 4million*32 is okay?
04:23:54 <SamB> dons: huh?
04:23:56 <roconnor> lispy: I will leave that for you to judge
04:24:07 <lispy> roconnor: i'm saynig, multiply all files stored in the hitory by 32 in size....
04:24:11 <roconnor> lispy: how many bytes are on each line anyways?
04:24:19 <lispy> roconnor: dunno
04:24:28 <lispy> but, this term i will write DarcsSim!
04:24:33 <lispy> ?where darcsSim
04:24:34 <lambdabot> I know nothing about darcssim.
04:24:39 <SamB> lispy: huh?
04:24:45 <SamB> *32?
04:24:47 <lispy> lambdabot: you always forget! you're worse than my ex-gf!
04:25:07 <lispy> SamB: yeah, 256 bits = 32 bytes
04:25:34 <int-e> where did you pull the 4 million from? do you have 4 million patches?
04:25:57 <SamB> also, where did you get the *?
04:25:58 <lispy> http://codersbase.com/index.php/DarcsSim
04:26:21 <lispy> int-e: okay, the 4 million is made up, supposing a file with 4 million lines
04:26:31 <int-e> oh. per line, hmm.
04:26:52 <lispy> ah yeah, because you potentionally need 1 label per line
04:26:56 <roconnor> > 256*(log 2)/(log 10)
04:26:58 <lambdabot>  77.06367888997917
04:27:11 <roconnor> > 128*(log 2)/(log 10)
04:27:13 <lambdabot>  38.531839444989586
04:27:47 <lispy> and the 1 label per line, assumes just one 1 patch for that file
04:27:47 <roconnor> so you expect a collision after 10^38 randomly generated UUIDs or so.
04:28:07 <lispy> roconnor: okay, i may actually be able to live with odds like that
04:28:15 <lispy> remind me how many moves a game of chess has?
04:28:20 <lispy> isn't it 10^33?
04:28:33 <int-e> 50 or so ;)
04:28:35 <profmakx> 4one game has about 50
04:28:46 <lispy> hmm...
04:28:52 <SamB> but, you'd usually have more than one thing on a given line
04:28:58 <lispy> anyway, 10^38 is still pretty good :)
04:29:02 <therp> lispy: that's at least the definition of a "Nonce" (=Number used once) in the NIST standard process for cipher modes | iirc
04:29:44 <roconnor> lispy:  Maybe.  Where did you get 10^33 from?
04:29:46 <lispy> SamB: and it seems that a line which is hot, get edited often and some lines only once
04:30:00 <lispy> roconnor: my memory, so consider it bogus
04:30:31 * lispy is pretty tired and it's been years since he heard the real figure
04:30:38 <roconnor> lispy: I was doing a pure 256 byte random number.  random UUIDs have slightly few bits
04:30:43 <int-e> lispy: http://en.wikipedia.org/wiki/Shannon_number
04:31:03 <roconnor> er 256 bit
04:31:22 <lispy> roconnor: yeah, and in the version control world i doubt we could actually assume a normal distribution
04:31:40 <lispy> int-e: thanks
04:31:50 <lispy> int-e: so i was close-ish, but only exponent wise
04:32:49 <lispy> roconnor: say in realitity it was actually 10^14, i'd still think that was fine
04:33:00 <lispy> roconnor: because it would be very rare
04:33:09 <roconnor> lispy: no.
04:33:25 <roconnor> I think I would want at least 10^18
04:33:27 <lispy> 10^14 isn't rare?
04:33:30 <lispy> ah
04:33:43 <roconnor> lispy:  lets say you generate a billion per second
04:33:56 <roconnor> then you have 10^5 seconds
04:34:08 <roconnor> @google 10^5 seconds in days
04:34:10 <lambdabot> (10^5) seconds = 1.15740741 days
04:34:22 <roconnor> and that isn't very long before a collision happens
04:34:41 <roconnor> @google 10^9 seconds in days
04:34:42 <lambdabot> (10^9) seconds = 11,574.0741 days
04:34:53 <roconnor> @google 10^9 seconds in years
04:34:54 <lambdabot> (10^9) seconds = 31.6887646 years
04:34:57 <roconnor> hmm
04:35:02 <roconnor> that is shorter than I thought
04:35:03 <lispy> if you generate 1 billion patches per second, what maintainer will review them?
04:35:16 <roconnor> :)
04:35:39 <lispy> but actually we are talking line labels
04:35:43 <roconnor> @google 10^11 seconds in years
04:35:45 <lambdabot> (10^11) seconds = 3,168.87646 years
04:35:47 <lispy> so, we don't need nearly that many patches
04:35:59 <beelsebob> so... how do you add a package to ghc?
04:36:20 <lispy> since i would guess that most patches are at least 8 lines (huge guess, based purely on intuition)
04:36:46 <roconnor> okay, I think 10^18 is kinda low too.  10^20 is round, and more or less acceptable.  Still seems a little low.  10^25 would make me feel better.
04:37:11 <lispy> we should draw the line somewhere, and make it official
04:37:16 <roconnor> now we are upto the number of nanoseconds since the universe began.
04:37:23 <lispy> heh
04:37:35 <roconnor> although I'd rather the number of nanoseconds until the universe ends
04:37:51 <roconnor> 10^30 make me feel quite comfortable
04:38:35 <lispy> i should bring this up on darcs-devel
04:38:37 <roconnor> ah random UUIDs have 122 bits
04:38:48 <roconnor> oh, that is much smaller than I thought ...
04:38:53 <lispy> see if we can agree on, say, 10^30 as "unique"
04:39:22 <roconnor> 61*(log 2)/(log 10
04:39:25 <roconnor> > 61*(log 2)/(log 10)
04:39:27 <lambdabot>  18.362829735502853
04:39:39 <roconnor> so it is 10^18 before a collision
04:39:52 <roconnor> that is kinda low
04:39:57 <lispy> roconnor: what is your formula for collision preducition?
04:40:14 <arcatan> large hadron collider
04:40:23 <musasabi> doesn't this all fail if one if few of the distributed peers don't play nicely?
04:40:27 <dons> Cale: ah, i found a great example of a real world monad stack (2 actually). pugs perl6 Eval monad, and lambdabot's LB
04:40:36 <lispy> #bits/# * (log 2) / (log 10) ?
04:40:41 <roconnor> lispy: according to the birthday paradox, the expect time to collion is the square root of the number of possibilities.
04:41:03 <lispy> roconnor: ah
04:41:31 <lispy> roconnor: but taht is an approximation right? is that still accurate with such large numbers?
04:41:47 <roconnor> so for 122 random bits there are 2^122 posibiltilies, and you expect collision in sqrt(2^122) = 2^61 time
04:41:53 <roconnor> > 2^61
04:41:55 <lambdabot>  2305843009213693952
04:42:17 <roconnor> it may look small, but it is still pretty big.
04:42:34 <dcoutts> > length "2305843009213693952"
04:42:36 <lambdabot>  19
04:42:42 <dcoutts> pft, that's small
04:42:53 <roconnor> lispy: I'm not sure it is an approximation ... but if it is, then it works best for large numbers.
04:43:19 <lispy> roconnor: ah, been a while since looked at the birthday problem
04:43:28 <lispy> either way, i should go to sleep
04:43:40 <lispy> thanks for the discussion
04:43:48 <lispy> it's been quite insightful
04:43:50 <roconnor> > sequence $ replicate (2^61) [x<-randomDouble]
04:43:51 <lambdabot>  Parse error
04:44:03 <roconnor> > sequence $ replicate (2^61) (randomDouble)
04:44:05 <lambdabot>  Not in scope: `randomDouble'
04:44:08 <roconnor> heh
04:44:21 <lispy> you want it the otherway anyway right?
04:44:42 <lispy> > randomDouble >>= sequence $ replicate (2^61)
04:44:44 <lambdabot>  Not in scope: `randomDouble'
04:45:07 * lispy &
04:50:57 <roconnor> is there a UUID library for haskell?
04:56:10 <roconnor> @google 2^61 nanoseconds in years
04:56:13 <lambdabot> (2^61) nanoseconds = 73.0693164 years
04:56:55 <dons> mmm. pugs has some really pretty code
04:57:10 <dons> http://svn.openfoundry.org/pugs/src/Pugs/Eval.hs
04:57:14 <lambdabot> http://tinyurl.com/ymhqc2
05:13:13 <therp> dons: would you mind telling me what the problem was with hs-plugins and a seperate interning table for faststring? skew told me this morning
05:14:09 <dons> the old typeable used a unique supply stored in the rts to generate unique type keys at runtiem
05:14:24 <dons> but it also loads two copies of typeable, in static and dynamically linked code
05:14:38 <dons>  the result is that depending on whether the code was statically linked or dynamically linked
05:14:47 <dons> the same type would compare as not equal
05:14:59 <dons> breaking typeable testing of interfaces between static and dynamic code
05:15:06 <dons> now, this has been fixed
05:15:27 <dons> making AltData.Typeable obsolete (it used strings for keys)
05:15:41 <dons> now, how this affects faststrings, i'm not sure
05:17:00 <jacobian> Is there a zipper like thing that works with graphs?
05:17:33 <therp> hm, thanks. I already though of that with my problem, but I though I made sure that I only and solely use the compiler's mkFastString with a few tricks..
05:17:49 <dons> jacobian: hmm. in a library? not that i know of.
05:18:00 <jacobian> Is there a name for one?
05:18:07 <dons> jacobian: possibly Oleg has one hidden away, you could ask on haskell-cafe@haskell.org
05:18:19 <dons> or, you want to know if zippers for graphs have even been invented?
05:18:50 <therp> sigh, compiling GHC on my box takes about an hour.. :(
05:19:06 <dons> do you have the fast compile options set?
05:19:10 <therp> yes
05:19:11 <dons> i can get it down to around 16 minutes or so
05:19:18 <dons> on a P4 2.6G box
05:19:40 <dons> don't build prof libs, and compile everything -fasm
05:19:59 <therp> dons: I used the build options from the developer wiki
05:20:25 <dons> -jN might help if you've got a few cores to throw around
05:20:38 <_matthew_> you could rent the apache compute cloud for the compilation ;)
05:20:45 <_matthew_> not apache, amazon!
05:20:50 <therp> just a midclass single-core amd64 1.8ghz.
05:20:55 <dons> yeah, i built it on a cluster once, with gmake-pvm
05:21:01 <dons> that was pretty wild
05:21:17 <dons> but gmake-pvm is a bit unstable/unmaintained
05:21:19 * _matthew_ pictures horses roaming the american mid-west
05:21:49 <dons> therp: should be able to get it under an hour, i reckon. i used to get an our on a 800Mhz celeron
05:21:56 <dons> we do have more code since then though
05:22:04 * ski made something a bit like a zipper for walking around an acyclic graph recently
05:22:13 <jacobian> dons: I guess I'm curious if they have been invented, and what they are called if they have.
05:22:18 <jacobian> hi ski
05:22:21 <therp> dons: a whole build from scratch? or are you referring to a stage2 build for instance
05:22:26 <ski> hiya jacobian
05:22:27 <musasabi> I think a typelevel zipper on graphs does exist but is not implemented.
05:22:42 <dons> therp: whole build, without anything i don't need. no prof, and using -fasm -Onot
05:22:53 <dons> i.e. just for typechecking purposes basically
05:22:59 <therp> dons: profiling is -Rghc-timing?
05:23:07 <dons> no ways=p
05:23:28 <dons> so you want GhcLibWays      =
05:23:43 <therp> got that, just as on http://hackage.haskell.org/trac/ghc/wiki/Building/Hacking
05:23:47 <lambdabot> Title: Building/Hacking - GHC - Trac, http://tinyurl.com/y567ol
05:24:17 <ski> (jacobian : for possibly cyclic graphs, i don't know)
05:25:22 <ski> (btw, the one i made was for a simple adventure game)
05:30:39 <jacobian> It seems like if you could have a zipper with cyclic references than you could dispense with the need for director strings
05:31:25 <jacobian> You could refer back to the binding occurance of the variable, and the variable need only be "versioned" at a single point
05:32:14 <jacobian> hmm, maybe that wouldnt' work
05:38:10 <jacobian> http://www-static.cc.gatech.edu/~shivers/papers/bubs.pdf
05:38:14 <lambdabot> http://tinyurl.com/y64dea
05:41:19 <Igloo> therp: Are you here?
05:41:23 <therp> igloo: positive
05:42:14 <therp> igloo: skew told me your a TH wizard? :)
05:42:36 <Igloo> therp: I'm confused. Is myfoo in scope?
05:43:32 <therp> igloo: yes, in the posting I gave a TH expression that compiles just fine and it's referring to myfoo too. also the -ddump-rn-trace causes the global environment to be dumped and there it clearly says "myfoo{v}: <definition place>"
05:45:53 <dons> ?seen shapr
05:45:54 <lambdabot> I saw shapr leaving #haskell and #ScannedInAvian 22h 2m 48s ago, and .
05:47:12 <Limbic_Region> anyone mind hitting me with a clue stick?  "Could not find module `System.Posix.Time'"
05:47:58 <_matthew_> import System.Posix.Time ?
05:48:54 <Limbic_Region> _matthew_ - is it possible that System.Posix.Time doesn't exist on my system (win32 6.6 bin distro)?
05:49:19 <_matthew_> um, maybe. I have no idea whatsoever about windows
05:49:26 <Limbic_Region> I only ask because I do not maintain the code I am trying to run and no one else appears to be whining
05:50:10 <Limbic_Region> hrm - so how would I go about verifying its existance and/or installing it if not present?
05:50:38 <Lemmih> There's no System.Posix.* on windows, iirc.
05:51:11 <dons> missing -package unix
05:51:27 <Limbic_Region> ok - that makes a bit of sense
05:51:31 <dons> there is some System.Posix on windows, iirc. the stuff in base/
05:51:56 <Limbic_Region> so I just need to beat the maintainers of the code about the head to offer a sane alternative for Win32 architectures
05:52:05 <dons> what code is it?
05:52:14 <Limbic_Region> pugs
05:52:17 <malebria> Hello, do you know how to get the String in a statusBar?
05:52:20 <dons> oh, that definitely runs on windows
05:52:23 <malebria> In gtk2hs.
05:52:31 <Limbic_Region> dons - yes, except as of this morning
05:52:33 <Igloo> therp: I'm not sure, SPJ is the man for this. The only thing I wonder is whether you want mkRdrUnqual rather than mkUnqual
05:52:37 <dons> Limbic_Region: ah ok :)
05:52:54 <Limbic_Region> dons - I run pugs on many platforms but I am restricted at work
05:53:02 <dons> Limbic_Region: you use pugs for work?
05:53:32 <Limbic_Region> dons - in an indirect way.  I have x time set aside for personal development (that can be later applied to work)
05:53:39 <dons> ah ok. cool.
05:53:45 <Limbic_Region> so teaching myself haskell and perl 6 falls into that category
05:53:59 <Limbic_Region> in any case, will let audreyt and team know
05:54:06 <dons> yep, good idea.
05:54:54 <Limbic_Region> now I am going to see if I can't hack in an alternative
05:55:29 <Limbic_Region> dons - if I wanted to conditionally import something based off OS, how would I do that?
05:56:26 <dons> does pugs use cpp to distinguish windows?
05:56:35 <dons> if so, some cpp on the imports woudl work.
05:56:42 <dons> but its really a per-project decision
05:57:28 <Limbic_Region> ah, got it
05:57:46 <Limbic_Region> and will trying to install System.Posix.Time without package unix blow up on me?
05:58:40 <Limbic_Region> guess so - it wants HsUnix.h
05:58:58 <Limbic_Region> ok, I give up trying to be helpful - thanks all
06:02:39 <malebria> dcoutts: are you there?
06:02:41 <malebria> dcoutts_: ?
06:32:48 <psi> I can't import Test.QuickCheck, has it been moved?
06:34:37 <ndm> @hoogle quickcheck
06:34:39 <lambdabot> Test.QuickCheck :: module
06:34:40 <lambdabot> Test.QuickCheck.quickCheck :: Testable a => a -> IO ()
06:34:50 <ndm> psi: it might be in extralibs for GHC 6.6
06:35:27 <chessguy> are continuations in prolog like monads?
06:35:52 <dons> psi: its an extra lib, maybe you didn't install it?
06:36:00 <psi> ok, that's probably it. I think I only installed the ghc package.
06:36:13 <dons> monads can be used to implement continuations and backtracking, so maybe
06:36:23 <dons> ?hoogle Cont
06:36:25 <lambdabot> Control.Monad.Cont :: module
06:36:25 <lambdabot> Control.Monad.Cont.Cont :: ((a -> r) -> r) -> Cont r a
06:36:25 <lambdabot> Control.Monad.Cont.Cont :: newtype Cont r a
06:36:26 <chessguy> so monads are more general
06:37:05 <kzm> What is the recommended way to read a binary file?  I'll need to break it into different parts later, Ptr This, Ptr That, and some real data types.
06:37:20 <kzm> (Read and write a binary file, I might add.)
06:37:29 <dons> yeah. continuations abstract the control stack (very powerful idea!), monads abstract over the entire evaluation mechanism
06:38:01 <dons> kzm, ByteString?
06:38:15 <dons> and then layer a Binary instance over the top, or use a parser
06:38:48 <dons> I'd use ByteString, but I might be biased. not sure.
06:39:01 <dons> Bulat would use streams I guess. :)
06:39:14 <pharm> kzm: http://haskell.org/haskellwiki/Binary_IO any use?
06:39:15 <kzm> No, BS is fine.  I'll have to keep the bulk in memory anyway.
06:39:16 <lambdabot> Title: Binary IO - HaskellWiki
06:39:32 <dons> cheers pharm
06:39:46 <pharm> pleasure...
06:40:17 <pharm> nb. Have asked Jeremy about videoing Fun in the Afternoon & he's happy for it to happen, but can't supply a camera...
06:40:20 <kzm> Can I 'cast' parts of a BS to a Ptr a?
06:41:48 <roconnor> why does `on` only work for binary functions?
06:42:09 <dons> kzm, yep
06:42:14 <dons> withForeignPtr, iirc
06:42:25 <dons> (check the api, you can take apart a ByteString and get the ptr inside)
06:42:40 <dons> oh, fromForeignPtr, toForeignPtr, actually I think
06:43:09 <kzm> The link from the binary_io page to Seen.hs doesn't seem to work (404).
06:43:42 <dons> its in lambdabot, just illustrates an instance of Binary
06:44:00 <dons> www.cse.unsw.edu.au/~dons/code/lambdabot/Plugins/Seen.hs iirc
06:46:04 <kzm> Still 404 Not found
06:46:16 <kzm> (that is the page linked to from the wiki as well)
06:46:30 <kzm> But I prolly have some old \bot code lying around locally.
06:46:33 <Syzygy-> So why do I get Not in scope when I try to define a new binary operator on my new type class?
06:46:40 <Syzygy-> (*.) :: Monomial -> Monomial -> Monomial
06:46:40 <Syzygy-> (*) (Monomial a) (Monomial b) = Monomial (zipWith (+) a b)
06:46:59 <Syzygy-> Hmr. Ooops.
06:47:04 <Syzygy-> If I call both *. it helps.
06:49:05 <dons> one too many 's'
06:49:16 <dons> http://www.cse.unsw.edu.au/~dons/code/lambdabot/Plugin/Seen.hs
06:49:18 <lambdabot> http://tinyurl.com/y47jwh
06:49:18 <kzm> The great thing about IRC is that somebody always has the answer.  Even when it's yourself.
06:50:04 <norpan> kzm: the not-so-great thing is that sometimes nobody has the question
06:50:40 <kzm> dons: I fixed the wiki as well.  Thanks.
06:50:48 <kzm> norpan, :-)
06:53:45 <ndm> pharm: malcolm has one but h's not going
06:53:59 <ndm> pharm: you might be able to ask if he can lend it to colin, who is going
06:54:50 <ski> <dons> monads can be used to implement continuations and backtracking, so maybe
06:55:07 <ski> not quite .. continuations *form* a monad
06:55:11 <malcolm> pharm: anyone with a recent Mac laptop should have a vid cam built in
06:55:37 <Syzygy-> Why is this wrong? Num a => data Term a = Term a Monomial
06:55:52 <pharm> malcolm: true, but a webcam is pretty low quality. Better than nothing..
06:55:56 <ski> data Num a => Term a = Term a Monomial
06:55:57 <ski> iirc
06:56:06 <Syzygy-> Ah.
06:56:25 <ski> (note though that this is weaker than one would like)
06:56:40 <Syzygy-> And in this it's redundant with Num a =>, is it?
06:56:42 <Syzygy-> Num a => (*.) :: a -> Term a -> Term a
06:56:53 <ski> that's also syntax error :)
06:57:01 <Syzygy-> I noticed. Hence my asking...
06:57:05 <ski> (*.) :: Num a => a -> Term a -> Term a
06:57:26 <Syzygy-> Yah.
06:57:29 <ski> and, no .. it is not redundant, it is required ..
06:57:45 <ski> .. this shows how it is weaker than expected
06:58:31 <Syzygy-> Next question. If I want to have two different multiplications, one a -> Term a -> Term a, and one Term a -> Monomial -> Term a, I need to name them differently?
06:58:39 <Syzygy-> Or can I make polymorphism deal with it?
06:58:56 <Syzygy-> (this is my latest compile error :)
06:59:00 <integral> if they're different multiplications they're different...
06:59:11 <ski> probably different names
06:59:15 <roconnor> Syzygy-: you can't use the (*) operator if you use the prelude
06:59:36 <ski> (one could possibly hack up something to use same name, but i think it will not be pretty for other reasons)
06:59:53 <roconnor> Syzygy-: You can use your own class craziness to make your own multipication operator (say (<*>)) and then you can do all sorts of crazy things.
07:00:02 <ski> @hoogle +
07:00:04 <lambdabot> Prelude.(+) :: Num a => a -> a -> a
07:00:04 <lambdabot> Prelude.(++) :: [a] -> [a] -> [a]
07:00:04 <lambdabot> Control.Arrow.(+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
07:00:06 <ski> @hoogle <*>
07:00:08 <lambdabot> No matches found
07:00:34 <Syzygy-> roconnor: I'm building up to a point where I want to instantiate a mutlivariate polynomial type as a Num, and then get * and whatever from there...
07:00:44 <ski> for some reason, they use '<*>' for 'ap' in the 'Applicative' class
07:00:56 <roconnor> Syzygy-: I have code lying around that soes this thing
07:01:04 <Syzygy-> However, I'll have a bunch of intermediate multiplications, and I don't want to instantiate all of Num everywhere...
07:01:37 <Syzygy-> So I have defiend a Monomial type and a Term type, and I want the Term type to be capable of multiplications with other scalars as well as with other monomials and other terms.
07:01:48 <Syzygy-> Preferably, I'll want all three to be the same sign.
07:02:27 <roconnor> Syzygy-: http://r6.ca/FewDigits/_darcs/current/Data/Multinomial.hs
07:02:30 <lambdabot> http://tinyurl.com/y467s2
07:02:46 * Syzygy- more and more comes to see the point of view expressed somewhere recently, that the Haskell type system had been much nicer if it had built in part of a mathematician, who won't use idiotic things like normed rings as the basic building block.
07:02:54 <Syzygy-> roconnor: Are you the r6 on LJ?
07:02:58 <roconnor> yes
07:03:05 <Syzygy-> o.O
07:03:05 <Syzygy-> :)
07:03:20 <Syzygy-> I think I comment every now and then at your LJ...
07:03:23 <Syzygy-> michiexile@LJ.
07:03:38 <roconnor> Syzygy-: I figured that out a few weeks ago I think ;)
07:03:42 <Syzygy-> Heh
07:03:55 <roconnor> instance (Num a) => Num (Polynomial a) where
07:03:55 <roconnor>  (Poly a) + (Poly b) = Poly (polyPlus a b)
07:03:55 <roconnor>  (Poly a) * (Poly b) = Poly (polyMult a b)
07:04:09 <roconnor> But it sounds like you are doing something more sophisticated
07:04:10 <integral> normed rings?
07:04:24 <Syzygy-> integral: Num wants +, -, *, / and abs and signum...
07:04:35 <integral> ah.  ugg.
07:04:40 <dons> there's a lot of research into partitioning C programs to limit the amount of suid code, and using privledge separation (like in ssh). doing it in C is error prone though. i wonder if there's a case there for an instance Monad Privledged connecting to unix user ids and root power
07:04:47 <dons> so you could be in the Root monad
07:04:49 <Syzygy-> I would have been much more happy if we had a Monoid, a Group, a Ring, a Field, and a Ring...
07:04:49 * integral would like it if the mathematicians were forced to type things properly
07:04:56 <Syzygy-> Hrm. Ring came twice.
07:04:58 <roconnor> Syzygy-: The entire class mechanism was invented to do operator overloading for Integer and Floats and Ints.
07:05:04 <Syzygy-> Yeah...
07:05:18 <roconnor> Syzygy-: the fact that it proved to be so widely useful wasn't known at the time
07:05:20 <integral> Syzygy-: I'd like better dependent types, then we can have a polynomial type for runtime use, but also compile-time use for quotient fields
07:05:37 <Syzygy-> I don't mind that very much, but what's wrong with building a small bit of extra mechanism into it and get the full expressive power of mathematical typing?
07:05:46 <Syzygy-> integral: You almost made me droool. :)
07:05:50 <roconnor> Syzygy-: This has been done
07:05:59 <roconnor> Syzygy-: but you need to hide the prelude.
07:06:04 <Syzygy-> roconnor: You mean Thielemanns stuff?
07:06:05 * integral hugs epigram
07:06:26 <roconnor> Syzygy-: I don't know the author.
07:06:30 <Syzygy-> Hide prelude? Sounds obnoxious... Meh.
07:06:44 <roconnor> Syzygy-: exactly
07:07:00 <dons> so runRootT would be a setresuid and back
07:07:27 <Syzygy-> Oh well. Henning Thielemann, active on the Haskell-Cafe, was here in Jena a while ago and spoke on computer algebra in Haskell, demonstrating code he'd built that lets you get arbitrary precision with lazy evaluation and other neat stuff..
07:08:05 <roconnor> In another lib I write:
07:08:09 <roconnor> class Wedge a b c | a b -> c, b c -> a, c a -> b where
07:08:09 <roconnor>  (/\) :: a -> b -> c
07:08:19 <roconnor> A very generic class ;)
07:08:29 <roconnor> although it could be more generic.
07:08:39 <Syzygy-> Eeeeehhhh... How do I even read that?
07:09:03 <roconnor> Wedge is a class of types a b c.
07:09:14 <Syzygy-> What does | a b -> c, b c -> a, c a -> b mean?
07:09:17 <roconnor> and given any a and b there is only one type c that is allowed.
07:09:27 <roconnor> and given b and c there is only one type a allowed
07:09:34 <roconnor> and given a c there is only one type b allowed
07:09:45 <Syzygy-> Oh...
07:09:49 <roconnor> This helps the type inference engine allong when you use /\
07:09:59 <roconnor> Of course, all this isn't haskell 98
07:10:16 <roconnor> which is part of the problem with generalizing the operators.
07:10:37 <roconnor> class Contraction a b c | a b -> c, b c -> a, c a -> b where
07:10:37 <roconnor>  (.:) :: a -> b -> c
07:11:03 <roconnor> unfortuantely (.:) is often defined to be (.) . (.)
07:11:22 <integral> @type (.) . (.)
07:11:27 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
07:21:15 <ski> roconnor : reminds me of triality
07:22:13 <Oejet> I am trying to solve some of the ACM competition problems.  Do you have any idea, where I can find solutions, or like-minded peers online?
07:22:15 <roconnor> ski: I wanted a lower right arrowhead _|
07:22:26 <roconnor> but _| is not an infix operator
07:22:33 <roconnor> ... I don't think
07:22:57 <ski> @type let (_|) = (_|) in (_|)
07:23:02 <lambdabot> parse error on input `|'
07:23:26 <ski> why did you want that, btw ?
07:23:40 <roconnor> ski: this is the standard symbol for the contraction operation.
07:23:51 <ski> and what is this "contraction" ?
07:24:03 <roconnor> um, something strange from differential geometry
07:24:04 * ski knows a "contraction" rule from logic
07:24:23 <dons> roconnor: use a unicode sym? :)
07:24:39 <dons> Oejet: which competition is that?
07:24:59 <roconnor> ah
07:25:16 <roconnor> it appears to be a generalization of an inner product
07:25:18 <Oejet> ACM International Collegiate Programming Contest.
07:25:25 <roconnor> instance Contraction Vector Vector Scalar where
07:25:26 <roconnor>  (Vector x1 y1 z1) .: (Vector x2 y2 z2) = x1*x2 + y1*y2 + z1*z2
07:25:51 <ski> that's duality, yes ?
07:26:11 <ski> (i.e. self-duality of finite vector spaces)
07:29:36 <kosmikus> dons, lispy, dcoutts: just saw your remarks on our paper in the backlog, and would be very interested in more details
07:30:49 <dcoutts_> kosmikus, sure
07:31:10 <dcoutts_> kosmikus, it all came out of looking at an obviously rediculous system
07:31:18 <dons> kosmikus: oh. it was a semi-joke :) the phpbb guys don't use diff/patch, they use a manual patching language to be executed by humans. this language is quite rich.
07:31:22 <dcoutts_> of patching by hand
07:31:44 <Dylan> dons: what's the best way of handing #define'd constants in the FFI?
07:31:45 <dons> though apparently there's a tool for automated application of patches for a subset of the patch language
07:32:14 <kosmikus> dons: interesting
07:32:24 <Dylan> I'm thinking of having... data Key = Char Char | <variant for each other define>...
07:32:25 <dcoutts_> kosmikus, in the context of you paper it's (somewhat) interesting because of the intentional forms of patches.
07:32:31 <dons> Dylan: #include a .h file?
07:32:36 <kosmikus> dcoutts_: do you have a link?
07:32:44 <dcoutts_> Dylan, use hsc2hs
07:33:05 <kosmikus> also, lispy said that droundy commented on the paper ...
07:33:05 <dcoutts_> dons, can you remember the page describing the patch format ?
07:33:12 <kosmikus> but unfortunately, he never answered my mail.
07:33:31 <dons> the spec was here http://www.phpbb.com/phpBB/viewtopic.php?t=61611 I think
07:33:36 <lambdabot> http://tinyurl.com/ydjoe9
07:33:42 <kosmikus> dons: thanks
07:33:59 <dons> kosmikus: prepared to be a little shocked -- these are applied manually
07:34:42 <dcoutts_> kosmikus, but it does abstract over line numbers :-)
07:34:54 <dons> here's an example patch, http://www.cse.unsw.edu.au/~dons/tmp/auto-lock-1.0.0em.txt
07:34:56 <lambdabot> http://tinyurl.com/y6xtpj
07:35:05 <Dylan> hsc2hs doesn't look very fun. :P
07:35:13 <roconnor> ski: I think that contraction can be defined in terms of duality somehow. ... something like x .: y = (x /\ y*)* where * is the dual
07:35:18 <roconnor> but I forget
07:35:56 <roconnor> instance Contraction Vector BiVector Vector where
07:35:56 <roconnor>  (Vector x1 y1 z1) .: (BiVector z2 y2 x2) =
07:35:56 <roconnor>   Vector (z1*y2 - y1*z2) (x1*z2 - z1*x2) (y1*x2 - x1*y2)
07:36:06 <dcoutts_> Dylan, it's pretty easy. Just change to .hsc and #include thing.h and then you can get at #defines, C constants, C struct sizes etc, see the manual. The syntax is fairly simple.
07:36:15 <ski> and what is '/\' there ?
07:36:50 <roconnor> ski:  /\ is the wedge product.  It is a tensor product modulo some symetry ... or antisymetry
07:37:22 <roconnor> anyhow it is modulo x /\ y = - y /\ x for vectors x and y
07:37:44 <Dylan> dcoutts_: will it ignore function definitions?
07:37:49 <roconnor> which means it is modulo x /\ y + y /\ x
07:38:14 <dcoutts_> Dylan, not sure what you mean, will what ignore which functions? C functions? Haskell functions ?
07:38:19 <ski> roconnor : sesquilinear ?
07:38:29 <Syzygy-> roconnor: antisymmetry.
07:38:40 <roconnor> ski: i'm not familiar with that word.
07:38:44 <Dylan> dcoutts_: will it not write bindings for the C functions it sees?
07:38:45 <ski> hm, maybe not
07:38:49 <ski> http://en.wikipedia.org/wiki/Sesquilinear_form
07:38:52 <lambdabot> http://tinyurl.com/yxpqcg
07:38:55 <Syzygy-> roconnor: It's used occasionally for antisymmetricity in forms.
07:39:05 <dcoutts_> Dylan, no, for that use c2hs. It's more powerful than hsc2hs.
07:39:08 <dons> kosmikus: actually, this might be a better spec for the patch format, http://www.phpbb.com/kb/article.php?article_id=39
07:39:10 <lambdabot> http://tinyurl.com/y6wyhn
07:39:11 <ski> (i'm not sure)
07:39:14 <roconnor> ski: the wedge product is what you really mean to be using when you do a cross product.
07:39:23 <ski> ok
07:39:30 <Dylan> dcoutts_: see, I don't want it to do that.
07:39:34 <roconnor> but the results is a Bivector instead of a vector
07:39:36 <kosmikus> dons: thanks again
07:39:40 <dons> dcoutts_: notice there's one edit action we missed, "DIY INSTRUCTIONS"
07:39:46 <Dylan> so if it doesn't attempt to foreign import functions, it's all good.
07:39:54 <kosmikus> dons: looks quite funny. you said there's an implementation for a subset?
07:39:54 <dons> that lets you include plain english editing instructions.
07:39:55 <ski> roconnor : first i though you renamed 'Wedge' to 'Contraction'
07:39:56 <dcoutts_> dons, how do we automate that? :-)
07:39:58 <roconnor> and doesn't have the arbitrary left or right hand rule nonsense.
07:40:02 <dcoutts_> kosmikus, or http://www.phpbb.com/kb/article.php?article_id=150
07:40:04 <lambdabot> http://tinyurl.com/y23zny
07:40:07 <dons> kosmikus: yeah, EasyMod I think its called
07:40:40 <dcoutts_> dons, DIY INSTRUCTIONS: fidget with it 'til it works.
07:40:41 <roconnor> ski: wedge is to plus as contraction is to minus.
07:40:52 <roconnor> I think
07:40:55 <ski> mhm
07:41:06 <roconnor> I was going to build a ray-tracer around this.
07:41:11 <dons> dcoutts_: i think that means the spec requires a natural language parser at the very least ..
07:41:12 <roconnor> but I never got past the geometry.
07:41:47 <ski> so the three spaces of a wedge don't need to be the same ?
07:42:15 <Syzygy-> roconnor: Sounds cool. If you can make it work. :)
07:42:55 <kosmikus> @tell lispy can you tell me more about what droundy has said about our version control paper?
07:42:56 <lambdabot> Consider it noted.
07:43:27 <Dylan> dcoutts_: hm. it seems to just output a one-line .hs file
07:43:43 <roconnor> Syzygy-: it would be a thing of beauty
07:44:05 <dcoutts_> Dylan, if your .hsc file is one line then sure.
07:44:12 <roconnor> ski: right, and often they aren't
07:44:25 <Dylan> dcoutts_: Ah, so it doesn't inspect the #include'd header.
07:44:41 <roconnor> ski: a wedge take and n-form and an m-form and makes an (n+m)-form.
07:44:45 <dcoutts_> Dylan, it substitutes for things of the form #{blah blah} in your .hsc file.
07:44:50 <ski> roconnor : ok .. are wedge or contraction related to triality, somehow ?
07:45:02 <roconnor> ski: I don't know what triality is.
07:45:03 <dcoutts_> Dylan, for example: sizeOfFoo = #{sizeof Foo}
07:45:05 <roconnor> @what triality
07:45:06 <lambdabot> I know nothing about triality.
07:45:12 <roconnor> neither does lambdabot
07:45:43 <ski> http://math.ucr.edu/home/baez/octonions/node7.html
07:45:43 <dcoutts_> Dylan, and if a type called Foo is defined in that .h file, then the .hs file spat out at the end will have sizeOfFoo = 8 (or whatever the size really is)
07:45:46 <lambdabot> Title: Spinors and Trialities, http://tinyurl.com/yjwgue
07:45:47 <Igloo> @tell lispy I'd be interested in being CCed too
07:45:48 <lambdabot> Consider it noted.
07:46:19 <dcoutts_> Dylan, and there's a similar #{  } hook for C constants or #defined constants. Look at the manual.
07:47:07 <roconnor> ski: this seems related somehow
07:47:28 <ski> i thought it maybe was ..
07:47:35 <roconnor> if only because that page talks about Clifford algebras
07:47:50 <roconnor> And the file that contains my instances is called Clifford3.hs
07:48:36 <Dylan> dcoutts_: thansk
07:52:34 <kosmikus> dons: what's this reddit thing?
07:53:01 <dcoutts_> it's a thing which has just been taken over
08:14:48 * Dylan wonders how the heck SLkp_define_keysym(char *, long int) should work in haskell...
08:15:29 <Dylan> perhaps a Slang.Key typeclass...
08:16:19 <Dylan> and define_keysym :: Slang.Key k => CString -> k...
08:19:53 <emu> class JustTakenOver a ... instance JustTakenOver Reddit?
08:26:23 <fasta> Is there existing software to simulate Haskell programs on multi-core CPUs accurately?
08:36:27 <ex0r> is it unheard of in haskell to have a function with no return type?
08:36:43 <Dylan> How would that work?
08:36:58 <ex0r> I have a function which uses an auxilliary function to split a list up and then reapply the orginial function to the elements
08:37:07 <ex0r> I have no idea, I only know OOP
08:37:11 <Dylan> Eventually the function has to return.
08:37:18 <ex0r> making the transition is a little difficult
08:37:40 <Dylan> a function by definition is a relation between two things...
08:38:23 <ex0r> well I was thinking along the lines of oop functions which return void
08:38:23 <Dylan> you can have IO actions like main which arn't really functions.
08:38:40 <Dylan> Ah. void would be ()
08:38:52 <Dylan> (which is how you write the empty tuple)
08:39:00 <ex0r> ah
08:39:02 <xerox> (The unit type.)
08:39:17 <xerox> (The only values of type () are () and _|_.)
08:39:27 <Dylan> you're almost always goiing to use that with IO, IO ().
08:39:31 <sieni> ex0r: yes, because the terminology in C and such is confused.
08:39:37 <Dylan> (or some other stateful monad)
08:40:28 <Dylan> @hoogle a -> ()
08:40:29 <lambdabot> No matches, try a more general search
08:40:36 <xerox> const ()
08:40:37 <ski> @type const ()
08:40:43 <lambdabot> forall b. b -> ()
08:41:01 <Dylan> const () isn't terribly useful
08:41:08 <ski> yes
08:41:20 <xerox> The other value of type forall a. a -> () is undefined.
08:41:36 <Dylan> well, unless you're using something unsafe.
08:41:45 <ex0r> would it be more syntactically correct to try and incorporate an auxilliary function which doesnt return anything (in an OOP sense) into the original function then?
08:41:57 <ski> @type (`seq` ())
08:41:58 <lambdabot> forall a. a -> ()
08:42:05 <xerox> ski!
08:42:14 <ex0r> basically I have a data type like so: data Tree a = Empty | Leaf a | Node a [Tree a]
08:42:20 <ski> xerox :)
08:42:26 <xerox> Nice one.
08:42:38 <ex0r> now, if I build a tree out of that I could have at some point a list of Trees
08:42:42 <chessguy> silly question. is there something equivalent to #if in haskell?
08:42:48 <ex0r> hence the last option
08:42:56 <xerox> ski: from a language-level perspective const () and flip seq () are the same, right?
08:43:17 <ex0r> but, if I split the list by head|tail and reapply both parts to my function the function would fail because it doesnt expect a list
08:43:25 <xerox> chessguy: yes, you can use cpp pragmas.
08:43:33 <ex0r> so I had an aux function that split the list into its elements and sent them back
08:43:39 <chessguy> @google haskell cpp pragma
08:43:42 <lambdabot> http://www.cs.york.ac.uk/fp/cpphs/
08:43:43 <lambdabot> Title: cpphs
08:43:58 <ski> ex0r : by 'split'
08:44:02 <xerox> Right.  Or just add {-# OPTIONS_GHC -cpp #-}, or call ghc with -cpp.
08:44:07 <ski> do you mean getting the head and the tail ?
08:44:15 <chessguy> thanks
08:44:30 <ex0r> I mean if the tail is bigger than a single element it would be a list, correct?
08:44:54 <ski> the tail is always a list
08:45:02 <ski> > tail [2,3]
08:45:06 <lambdabot>  [3]
08:45:13 <ex0r> so if I simply do (pseudo) function a = function (head a) | function (tail a)
08:45:19 <profmakx> > tail [2]
08:45:20 <lambdabot>  []
08:45:55 <ex0r> then it will fail will it not, because the first function gives it a single element (of whatever) and the second function gives it a list instead
08:46:20 <ex0r> this probably seems quite confusing
08:47:07 <ski> ex0r : maybe it would be good here if you tell what it is you want to do
08:47:34 <ex0r> im making a tree module
08:47:45 <ex0r> basically binary tree but with more than 2 branches
08:47:50 <ex0r> n branches if you like
08:47:56 <jgrimes> a rose tree? :)
08:47:57 <ex0r> general trees I suppose you could call it
08:48:03 <ex0r> or that!
08:48:12 <chessguy> also called ordered trees
08:48:16 <ex0r> Im not familiar with all these lingo names, sorry :P
08:48:41 <chessguy> at least, that's what we called them in my algos class
08:48:46 <ex0r> well, in my case I dont really want (or need) it to be ordered in anyway
08:48:54 <jgrimes> or n-ary tree.
08:49:19 <ex0r> just needs the ability to have more than 2 branches for any given node
08:49:31 <ski> and what should your function do
08:49:32 <ski> ?
08:49:38 <profmakx> like a list of branches ^^
08:50:00 <ex0r> im just writing some basic functions to check if a node/leaf occurs in a given tree, etc
08:50:13 <ex0r> its traversing the tree thats the problem
08:50:30 <arjanb> do you know pattern matching?
08:50:51 <ex0r> I do but not in haskell
08:51:00 <jgrimes> ex0r: ah, I suppose you are aware of the usual traversal algorithms?
08:51:17 <ex0r> well, the binary traversal is pretty obvious
08:51:25 <ex0r> because you will only ever have 2 branches to consider
08:51:37 <ex0r> its the fact that I can have n branches which is confusing me
08:52:22 <ex0r> is this a reasonable data type for an n-breadth tree? : data Tree a = Empty | Leaf a | Node a [Tree a]
08:52:43 <ex0r> I based it off the haskell binary tree example
08:52:56 <ski> that should work, probably
08:53:01 <arjanb> can you show the code you have already?
08:53:04 <arjanb> ?paste
08:53:05 <lambdabot> http://paste.lisp.org/new/haskell
08:53:10 <ex0r> just changed it from having (tree a) (tree a) to a list of Tree a
08:53:15 <ex0r> sure
08:53:20 <ex0r> its not alot mind
08:53:57 <jgrimes> Why do you separate the Leaf and Node? you can just refer to a Leaf with pattern matching as: (Node val [])
08:54:04 <ski> ex0r : i think the auxilary function that "doesn't return anything" actually will return the same as the main function, in your case
08:54:20 <ski> jgrimes : maybe internal elements is not wanted
08:54:31 <ski> er
08:54:54 <ski> (sorry, i missed that 'Node' also had element)
08:55:23 <ski> (so, i agree that 'Leaf' is probably not needed)
08:55:40 <lisppaste2> ex0r pasted "trees" at http://paste.lisp.org/display/29230
08:55:58 <ex0r> oh I see what you mean
08:56:07 <ex0r> so instead of leaf I could just do node with an empty list
08:56:17 <ex0r> didnt even consider that
08:56:20 <jgrimes> yep :)
08:56:56 <ex0r> that code will seem quite odd I expect
08:57:11 <ex0r> its some binary tree member code I was trying to adapt from a book
08:59:02 <ski> ex0r : first, in 'member_aux', since you have a list, why not pattern-match on it ?
08:59:09 <ski> do you know how to do that ?
08:59:47 <ex0r> not in haskell, no
08:59:47 <ski> (you *can* do it with 'head' and 'tail', too .. but it is clumsier)
09:00:01 <ski> ok
09:00:16 <ex0r> I only used head/tail because its the way I did it in java, didnt realise pattern matching was faster
09:00:31 <ski> do you know that '[1,2,3]' is syntactic sugar ?
09:01:51 <dds> hello?
09:01:57 <ski> hello
09:02:00 <jgrimes> dds: hello!
09:02:15 <ex0r> ill be honest, I have never heard that phrase before
09:02:19 <ski> ok
09:03:09 <ski> ex0r : "syntactic sugar" is something that has a nicer alternative syntax, but which really means something more basic
09:03:22 <ski> the empty list is written '[]'
09:03:37 <dds> I'm a small time haskell hacker, but until now I haven't had to bootstrap GHC before (building it on a redhat box that I don't have root on; I'm a debian user so shrug)... The documentation tells me to download a set of HC files but I don't know where to find them.
09:03:53 <ski> if you have a list, you can add an element in front of it, by means of the ':' operator (pronounced "cons")
09:03:59 <ski> > 3 : [2,1,0]
09:04:01 <lambdabot>  [3,2,1,0]
09:04:06 <Igloo> dds: It'll be simplest to get the binary tarball from teh download page
09:04:11 <ski> ex0r : ok, so far ?
09:04:40 <ex0r> oh yes I know that
09:05:07 <ski> ok, now the '[]' for empty list and ':' for adding element in front is the *basic* form for lists
09:05:16 <ski> '[1,2,3]' is the sugared form
09:05:25 <dds> Igloo: right, but (1) I'm not root so I'm installing it locally in my home directory and so I need to make sure it uses the necessary libraries (curses, etc) from there. I'm pretty sure the binary is using them dynamically anyway but I want to do it from source for the experience anyway.
09:05:30 <ski> it *really* means '1 : (2 : (3 : []))'
09:05:30 <ex0r> right
09:05:32 <ski> > 1 : (2 : (3 : []))
09:05:34 <lambdabot>  [1,2,3]
09:05:45 <dds> I mean, for all I tell other people to try haskell and haskell-based software like darcs, I need to know better how to build ghc.
09:05:48 <xerox> > 1 : 2 : 3 : []
09:05:48 <ski> (but when you print it, you get the shorter form, for convenience)
09:05:49 <lambdabot>  [1,2,3]
09:06:01 <Igloo> dds: You can build GHC from source with the GHC in the binary tarball
09:06:09 <ski> as xerox just showed, the parens are not needed, since the ':' operator associates to the right
09:06:11 <dds> Igloo: ah, true.
09:06:14 <xerox> Right!
09:06:16 <Igloo> dds: You can install it in your home directory (just configure with --prefix)
09:06:22 <dds> Igloo: nod.
09:06:26 <ex0r> ok
09:06:30 <Igloo> dds: And set LD_LIBRARY_PATH to point to your local libraries if necessary
09:06:33 <dds> right, the installation part would be no problem
09:06:38 <dds> nod nod
09:06:51 <dds> just the documentation refers to a set of possibly downloadable HC files that I couldn't find on the site
09:06:53 <dds> that's what I'm asking about
09:06:57 <ski> ex0r : now, the point we're getting to is that you can *pattern-match* on '[]' and ':' (similarly as you pattern-match on 'Empty', 'Leaf', and 'Node')
09:07:04 <Igloo> dds: I don't think that route works ATM
09:07:10 <ex0r> oh I see
09:07:11 <ski> ex0r : a very simple example is the summing function
09:07:16 <ski> sum [    ] = 0
09:07:22 <dds> Igloo: don't get me wrong, your solution is fine and all, but I'm really more interested in the bootstrapping issue.
09:07:22 <ski> sum (n:ns) = n + sum ns
09:07:53 <ex0r> yeah I get that
09:07:59 <arjanb> the declaration of a list is something like: data [a] = []  |  a : [a]
09:08:02 <ski> ex0r : if you want, you could say that the list datatype is like syntactic sugar for 'data List a = Nil | Cons a (List a)', if that helps ..
09:08:09 <Igloo> dds: Someone's going to have to sit down and work out what's going wrong, but it's not particularly high priority as there are other ways of solving that problem
09:08:26 <dds> Igloo: I see, ok.
09:08:32 <ex0r> yep yep
09:08:40 <ski> ex0r : now, can you try see if you can use this in 'member_aux' :)
09:10:36 <ski> (also you need to look closer at the 'Node' case of your 'member' .. what should 'member' return ?)
09:15:31 <ex0r> yes I see the problem with the node case
09:15:42 <ski> and the solution ?
09:20:30 <ex0r> well, im presuming you mean the fact that it calls memeber_aux, which as written doesnt return anything so any member functions initiated by that will be lost anyway?
09:20:48 <ex0r> member* even
09:21:29 <ski> well
09:21:46 <ski> remember again what 'member' should do ?
09:21:53 <ski> what should 'member' return ?
09:22:31 <ex0r> a boolean
09:22:33 <ski> yes
09:22:51 <ex0r> true if it finds the element and false if it doesnt exist
09:22:54 <ski> yes
09:22:55 <ski> if you have two calls in the 'Node' case ..
09:23:06 <ex0r> ahh I see
09:23:13 <ex0r> hrm
09:23:37 <ski> .. then you need to combine the results of those two calls, somehow, to get the boolean to return from this current call
09:23:57 <ex0r> well in this case if one of them is true then ignore anything else
09:24:08 <ski> yes
09:24:13 <ex0r> if they are both false then by definition it would be false
09:24:46 <ex0r> I see where your coming from now
09:24:51 <ex0r> finally ;)
09:24:52 <ski> how would you do that in e.g. Java ?
09:25:06 <ex0r> ||
09:25:23 <ex0r> OR case logic
09:25:28 <ski> (not the looping or recursion, but this "if one of them is true then ignore anything else","if they are both false then by definition it would be false")
09:25:36 <ski> yes
09:25:46 <ski> @type (||)
09:25:47 <lambdabot> Bool -> Bool -> Bool
09:25:58 <ski> it takes two booleans and returns a boolean
09:26:15 <ski> (and it is "short-circuiting" just as you want)
09:26:34 <ski> > True || (error "bang!")
09:26:35 <lambdabot>  True
09:26:37 <ski> > False || (error "bang!")
09:26:39 <lambdabot>  Exception: bang!
09:27:02 <ski> so if left argument is 'True' then the right argument is not evaluated
09:27:38 <ex0r> I see
09:29:09 <ski> so, in the 'Node' case, the 'member search (head lis)' will give a boolean that tells whether 'search' occurs in the first subtree
09:30:04 <ski> what about if it doesn't .. how will you know if it occurs in any of the other subtrees ?
09:32:03 <ex0r> hmm
09:33:04 <ski> why have you put a 'member_aux search (tail lis)' call in there ?
09:33:51 <ex0r> I think its an error in understanding on my part
09:34:15 <ski> (it is a small error, yes .. but i'd still like an answer :)
09:34:46 <ski> why not just
09:34:48 <ski> member search (Node x lis) =
09:34:52 <ski>                 member search (head lis)
09:34:53 <ski> ?
09:35:05 <ski> what would be problematic about that ?
09:35:22 <ex0r> because thats ignoring all the other n possible nodes on any particular level
09:35:26 <ski> yes
09:35:37 <ex0r> if its a list of nodes all of them need to be considered not just the head
09:35:42 <ski> yes
09:35:58 <ski> and what information do you want to extract, regarding the rest of the subtrees ?
09:36:30 <ex0r> the same
09:36:35 <ski> which is ?
09:36:51 <ski> (i want you to spell it out :)
09:36:54 <ex0r> boolean for if the node exists in one of the other subtrees
09:36:58 <ski> yes
09:37:05 <ski> so, you want another boolean
09:37:33 <ski> the 'member search (head lis)' will give you one boolean that tells whether 'search' occurs in the first subtree
09:37:56 <ski> you want something that gives you another boolean, that tells whether 'search' occurs in any of the other subtrees
09:38:02 <ex0r> yes
09:38:15 <ski> now. where should you get other this boolean from ?
09:38:40 <ski> (note that you have stated that 'member_aux' "returns nothing")
09:39:03 <ex0r> that was my error in understanding :P
09:39:17 <ex0r> I realise that if the aux function returns nothing then I have no boolean
09:39:18 <ski> ok .. so what do you think a correction would be ?
09:39:22 <ski> yes
09:39:28 <ski> so, how to fix this ?
09:39:43 <ex0r> make it return a boolean based on whatever its doing
09:39:46 <ski> yes
09:39:55 <ex0r> which would be "or" again on all the subtrees
09:40:17 <ski> that boolean should of course tell whether 'search' occurs in any of the trees in the list that is handed to 'member_aux'
09:40:20 <ski> exactly
09:41:09 <ski> now, i assume you know what to say to state that 'member_aux' should return a boolean (never mind the code for 'member_aux' for the moment)
09:41:40 <ski> do you ?
09:41:48 <ex0r> member_aux :: a -> [Tree a] -> Bool
09:41:49 <ex0r> member_aux search lis = member search (head lis) || member_aux search (tail lis)
09:41:50 <ex0r> whoops
09:41:55 <ex0r> little too much there
09:42:03 <ski> heh, doesn't matter :)
09:42:33 <ski> adding '||' there to combine the two booleans from those two calls is actually just what you needed in that place :)
09:42:51 <ex0r> :)
09:43:04 <ski> now, maybe you can see what to do in the 'Node' case of 'member' too ?
09:43:54 <ex0r> member search (Node x lis) = member search (head lis) || member_aux search (tail lis)?
09:43:58 <ski> yes
09:44:08 <ski> now this is some good steps forward
09:44:20 <ski> there's still some steps left, though
09:44:27 <ex0r> :)
09:44:36 <ski> e.g. if you look at 'member_aux'
09:44:59 <ski> what happens when tou take the 'head' (or 'tail' for that matter) of an empty list ?
09:45:17 <ex0r> I need to check for null lis
09:45:18 <ski> (you may try with lambdabot if you want :)
09:45:23 <ski> yes
09:45:30 <fasta> > head [] -- gives error
09:45:31 <lambdabot>  Add a type signature
09:45:46 <ski> > head ([] :: [Int])
09:45:47 <fasta> > head ([]::[Int]) -- gives error
09:45:48 <lambdabot>  Exception: Prelude.head: empty list
09:45:49 <lambdabot>  Exception: Prelude.head: empty list
09:45:57 <ex0r> if its null then return false
09:46:15 <fasta> heh, we chose the same type....
09:46:21 <ski> you can check for 'null' either with a "guard" or with an 'if'-'then'-'else'
09:46:29 <ski> ex0r : yes
09:46:32 <ex0r> ill use guards
09:46:44 <fasta> or with case
09:47:08 <fasta> > case [] of []->"empty";_->error "wtf!"
09:47:09 <lambdabot>  "empty"
09:47:20 <ski> fasta : i see no call to 'null' there ?
09:47:25 <ski> (s/ ?//)
09:48:09 <fasta> ski: well, if the constraint is to use null, you are right.
09:48:13 <ex0r> with otherwise = member...|| member....etc will I need para's round the logic evalutation?
09:48:33 <ski> parens are not needed there, no
09:48:37 <ex0r> I know you need to in java, I thought haskell wasnt dependant on paras
09:48:41 <ex0r> ah
09:48:42 <ex0r> thought so
09:48:52 <fasta> @dict paras
09:48:55 <lambdabot> Supported dictionary-lookup commands:
09:48:56 <lambdabot>  all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
09:48:56 <lambdabot> Use "dict-help [cmd...]" for more.
09:49:04 <ski> function application binds harder than all other operators
09:49:11 <fasta> @dict all-dicts paras
09:49:12 <lambdabot> Supported dictionary-lookup commands:
09:49:12 <lambdabot>  all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
09:49:12 <lambdabot> Use "dict-help [cmd...]" for more.
09:49:13 <ex0r> yeah
09:49:18 <fasta> @all-dicts paras
09:49:20 <lambdabot> No match for "paras".
09:49:25 <fasta> :)
09:49:27 <ex0r> paras was a typo ;)
09:49:32 <ex0r> albeit twice..
09:49:38 <fasta> I know what you meant.
09:49:43 <ex0r> heh
09:50:04 <ski> now, if you ever have a subtree like 'Node a []' (e.g. if you follow jgrimes idea), then the 'Node' case of 'member' is also problematic
09:50:16 <ski> see ?
09:50:46 <ex0r> yes
09:50:52 <ex0r> because again, its null lis
09:50:55 <ski> yes
09:51:02 <ski> and same solution can of course be used
09:51:22 <ex0r> yep
09:51:39 <ski> now, i'd like to show you how the same thing looks with pattern-matching, instead of 'head','tail' and 'null'
09:51:43 <ski> ok ?
09:51:48 <ex0r> ok :)
09:52:07 <ski> ok, so lets compare with 'sum' i showed earlier
09:52:12 <jgrimes> pattern-matching++
09:52:18 <ski> -- sum without pattern-matching
09:52:25 <ski> sum ns
09:52:41 <ski>   | null ns   = 0
09:52:51 <ski>   | otherwise = head ns + sum (tail ns)
09:52:55 <ski> ok ?
09:53:00 <ex0r> yep
09:53:10 <ski> do you see that that works ?
09:53:42 <ex0r> yes
09:53:48 <ex0r> basic recursion
09:53:52 <ski> yes
09:53:55 <ski> -- sum with pattern-matching
09:53:59 <ski> sum [    ] = 0
09:54:06 <ski> sum (n:ns) = n + sum ns
09:54:24 <ski> the line with '[]' matches when an empty list is passed in
09:54:37 <ex0r> I see yes
09:54:41 <fasta> > foldr (+) 0 [1..10] -- spoiler
09:54:43 <lambdabot>  55
09:55:10 <ski> the line with 'n:ns' matches when a non-empty list is passed in .. and then 'n' becomes the first element (the head) and 'ns' becomes the rest of the elements (the tail)
09:55:16 <fasta> > foldl (+) 0 [1..10] -- look the same
09:55:17 <lambdabot>  55
09:55:30 <fasta> > foldr' (+) [1..10] -- look the same
09:55:31 <lambdabot>  Not in scope: `foldr''
09:55:38 <fasta> > foldr1 (+) [1..10] -- look the same
09:55:40 <lambdabot>  55
09:55:45 <ski> ex0r : ok ?
09:55:49 <ex0r> yes
09:55:50 <ski> so, now, can you try to rewrite 'member_aux' in a similar way ?
09:57:01 <ex0r> member_aux _ [] = False
09:57:02 <ex0r> member_aux search (n:ns) = member search n || member_aux search ns
09:57:11 <ski> yes
09:57:27 <ex0r> much nicer looking code
09:57:44 <dsacode> Hello! Are general (theoretical) questions about functional programming are welcome here?
09:57:54 <xerox> Sure dsacode!
09:57:56 <ski> (though you may want to rename 'n' -> 't' and 'ns' -> 'ts' or something .. since you're handling trees, there, not numbers .. of course you could use 'tree' and 'trees' if you want to be more verbose)
09:58:22 <ski> ex0r :)
09:58:53 <ex0r> ah yes
09:59:29 <ski> ex0r : now, you seem to have some code redundancy .. in the 'Node' case of 'member' you do something with the head and tail of the list .. and in one of the cases of 'member_aux' you also do something with the head and a tail of a list ..
09:59:55 <ski> .. does these two places look any bit similar to you ?
10:00:29 <dsacode> Ok.. Recently I read about "tail recursion" - it's property of programming language implementation that converts linear recursive proccess to linear iterative proccess. I tried to find some algorithm that performs this optimization in general case (but for program written in functional style) and I failed. May be you can advice me something?
10:00:41 <ex0r> they are nearly identical
10:00:47 <fasta> dsacode: SICP?
10:00:49 <ex0r> well, the member || member bits
10:00:55 <dsacode> fasta, yes :)
10:01:14 <ski> ex0r : yes .. and in the non-pattern-matching version, i think you'll see that they was precicely the same
10:01:27 <ex0r> yep
10:01:44 <ski> so, instead of writing the same code twice, can you remove one of those two chunks and make it call the other ?
10:02:51 <fasta> > let member_aux  =  (\search list->foldr (\x bool->member search x || bool) False list) --didn't test this, but should work.
10:02:52 <lambdabot>  Parse error
10:03:26 <dsacode> Hmm, may be there's some information about tail recursion implementation in Haskell?
10:03:29 <ski> (fasta : missing 'in')
10:03:44 <fasta> ski: oh, I thought this was lambdabots syntax
10:03:52 <fasta> ski: (for specifying persistent functions)
10:03:57 <ski> @help let
10:03:59 <lambdabot> let <x> = <e>. Add a binding
10:04:20 <fasta> @let member_aux  =  (\search list->foldr (\x bool->member search x || bool) False list) --didn't test this, but should work.
10:04:21 <lambdabot> <local>:11:46: Not in scope: `member'
10:04:32 <fasta> @let member_aux  =  (\search list member->foldr (\x bool->member search x || bool) False list) --didn't test this, but should work.
10:04:34 <lambdabot> Defined.
10:04:39 <fasta> :)
10:05:25 <ski> ex0r : can you see how ?
10:05:28 <fasta> dsacode: you can look up the source code of GHC/Hugs, but I think you can better just read on.
10:05:29 <ex0r> do you mean remove the list split from member, and just make it call member_aux with the lis?
10:05:56 <ex0r> or do you mean remove the aux entirely
10:06:33 <ski> will making it just call 'member_aux' on 'lis' make it return the same thing as before, in the 'Node' case ?
10:06:58 <fasta> > 4 `elem` [1,4]
10:07:01 <lambdabot>  True
10:07:41 <ex0r> from what I can see, yes?
10:07:59 <ex0r> its still going to end up doing member on the head, just in a different place
10:08:26 <ex0r> instead of splitting it and doing member on the head, it gives it to the aux, which splits it and does it anyway?
10:08:46 <ski> yes, since it does the same with 'lis' (namely first check if it is empty, and then give 'False', and otherwise call 'member' on the head and 'member_aux' on the tail, and or-ing those two booleans and return)
10:08:54 <ski> yes
10:09:14 <ski> no need to write code for that checking, splitting and calling in two places
10:09:26 <ski> 'member_aux' already does the job
10:09:40 <ski> ok ?
10:09:56 <ex0r> yep
10:09:58 <ski> so what should the 'Node' case of 'member' look like, now ?
10:09:58 <ex0r> thank you btw
10:10:13 <ex0r> member search (Node x lis) = member_aux search lis
10:10:16 <ski> yes
10:10:33 <ski> does this read more clearly ?
10:10:40 <ex0r> alot more clearly
10:10:43 <ski> (:
10:11:00 <ski> now, one could do some more things ..
10:11:21 <syntaxfree> I keep on trying to understand this "OO" thing.
10:11:34 <ski> ex0r : are you acquainted with the 'map' function ?
10:11:46 <syntaxfree> It seems to be  something like a data type attached to a list of functions.
10:11:51 <ex0r> yes
10:12:02 <ski> now, assume you have a list of trees
10:12:13 <ski> [tree0,tree1,tree2,...]
10:12:24 <ex0r> map member lis?
10:12:43 <ski> something like that could convert each tree in the list to a boolean, yes ;)
10:13:02 <ex0r> hmm
10:13:27 <ex0r> that woul give a list of bools,
10:13:28 <ski> though, now you would get a *list* of booleans, and not just a single boolean
10:13:29 <ski> yes
10:13:39 <ex0r> does foldr take (||)
10:13:40 <ski> what should be done with the list of booleans ?
10:13:42 <ex0r> >
10:13:44 <ex0r> ?*
10:13:45 <lambdabot> Maybe you meant: . v
10:13:51 <ski> it can do
10:14:07 <ex0r> foldr (||) (map member lis)
10:14:21 <ex0r> would that work?
10:14:21 <ski> you're missing an argument of 'foldr'
10:14:26 <ex0r> oh
10:14:50 <syntaxfree> maybe you want foldr1.
10:14:54 <syntaxfree> @type foldr
10:14:55 <syntaxfree> @type foldr1
10:14:56 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
10:14:56 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
10:15:11 <ex0r> ah
10:15:22 <ski> syntaxfree : s/he doesn't, if s/he wants to support empty list of trees too (which is not complicated)
10:16:01 <syntaxfree> well, foldr1 is equivalent to Lisp's "reduce". But I'm no blackbelt.
10:16:14 <ex0r> supporting empty lists isnt necess' in this case, but for the sake of learning I think it would be better to have it in
10:16:30 <ski> ex0r : do you recall what the "b" argument of 'foldr' means ?
10:16:42 <roconnor> @google ThingsToAvoid
10:16:45 <lambdabot> http://www.haskell.org/hawiki/ThingsToAvoid
10:16:45 <lambdabot> Title: ThingsToAvoid - The Haskell Wiki
10:16:57 <syntaxfree> > foldr1 (+) [1..10] 7
10:16:58 <lambdabot>  add an instance declaration for (Num (t -> a))
10:16:59 <lambdabot>   In an arithmetic sequenc...
10:17:00 <syntaxfree> oops.
10:17:06 <ex0r> no
10:17:07 <syntaxfree> > foldr (+) [1..10] 7
10:17:07 <lambdabot>  add an instance declaration for (Num [[a]])
10:17:27 <ex0r> the only time I have used it recently was for (+), and the b was 0 I believe
10:17:32 <syntaxfree> > foldr (+) 7 [1..10]
10:17:33 <lambdabot>  62
10:17:41 <ski> ex0r : it says what to do in the "empty" case
10:17:49 <ex0r> ah
10:18:05 <ex0r> empty case would need to be false
10:18:08 <ski> ex0r : yes, the sum of an empty list is 0 (which is related to that if you add 0 to anything, you get the same back)
10:18:12 <ski> yes
10:18:19 <ski> http://www.haskell.org/hawiki/ThingsToAvoid
10:18:20 <lambdabot> Title: ThingsToAvoid - The Haskell Wiki
10:18:25 <syntaxfree> foldr f b [] = b; foldr f b (x:xs) = f x (foldr f b xs)
10:18:28 <ski> (sorry, slip of hand)
10:18:34 <ex0r> so foldr (||) False (map member lis)
10:18:38 <ex0r> something like that?
10:18:50 <ski> yes, something like that :)
10:18:58 <ski> now
10:19:20 <ski> map :: (x -> y) -> [x] -> [y]
10:19:31 <ski> 'x' is 'Tree a' in your case
10:19:39 <ski> you want 'y' yo be 'Bool'
10:19:40 <ski> yes ?
10:19:43 <syntaxfree> map f [] = []; map f (x:xs) = x : (map f xs)
10:19:50 <ex0r> yes
10:20:07 <ski> so, then map wants a function argument of type 'Tree a -> Bool'
10:20:18 <ski> what type does 'member' have ?
10:20:26 <xerox> > ((. (return .) . (>>=)) [1,2,3] (+1)
10:20:27 <lambdabot>  Parse error
10:20:29 <xerox> ops.
10:20:31 <ex0r> ah its missing the search argument
10:20:42 <ski> (: yes
10:20:43 <xerox> > ((. (return .)) . (>>=)) [1,2,3] (+1)
10:20:45 <lambdabot>  [2,3,4]
10:20:47 <xerox> heh
10:20:54 <ex0r> foldr (||) False (map member search lis)
10:20:57 <xerox> that is map also :P
10:20:58 <ex0r> :S
10:21:07 <ski> some parens could be helpful
10:21:13 <xerox> 'foldr (||) False' is 'or'
10:21:14 <syntaxfree> hmm
10:21:20 <ski> (since 'map' doesn't want four arguments)
10:21:31 <ex0r> yes
10:21:33 <ski> (xerox : coming soon :)
10:21:38 <xerox> Ah! Sorry.
10:21:51 <syntaxfree> ski: choosy bitch! She doesn't want four arguments!
10:21:56 <syntaxfree> Hmph!
10:21:59 <ex0r> foldr (||) False (map member (search lis))?
10:22:04 <roconnor> isLowerLimit x = all (x<=)
10:22:04 <roconnor> This definition terminates for infinite lists, if x is not a lower limit.
10:22:13 <roconnor> from ThingsToAvoid
10:22:18 <ski> (err .. of course i meant "since 'map' doesn't want *three* arguments" :)
10:22:30 * ski needs to learn how to count
10:22:31 <ex0r> :P~
10:22:34 <roconnor> You know, semi-deciable boolean functions are not useful.
10:22:39 <syntaxfree> ski: she doesn't want four arguments either.
10:22:40 <syntaxfree> or seven arguments.
10:22:47 <xerox> she.
10:23:01 * ski didn't know before that 'map' had a gender
10:23:20 <ski> ex0r
10:23:23 <ex0r> if map was a woman she could probably handle infinite arguments
10:23:27 <Binkley> :-(((
10:23:29 <ex0r> she probably loves having arguments
10:23:29 <xerox> haha
10:23:45 <xerox> @remember ex0r if map was a woman she could probably handle infinite arguments
10:23:46 <Binkley> I didn't know that functions had genders either
10:23:54 <syntaxfree> data  GenderFUnction = Male (a->b) l  Female (a->b)
10:24:01 <Binkley> syntaxfree, you're missing a few cases there
10:24:09 <ski> ex0r : anyway ..
10:24:13 <ski> <ex0r> foldr (||) False (map member (search lis))?
10:24:20 <syntaxfree> (I just realized I can[t find the vertical bar in this keyboard)
10:24:23 <ski> you are here passing 'member' as second argument to 'map'
10:24:32 <ski> member :: a -> (Tree a) -> Bool
10:24:39 <ex0r> oh wait yes that isnt right is it
10:24:40 <syntaxfree> Blinkley: I've seen variadic function types in some research paper, so.
10:24:48 <ski> map :: (Tree a -> Bool) -> [Tree a] -> [Bool]
10:24:58 <ski> ex0r : so it still doesn't match up
10:24:58 <syntaxfree> | l
10:25:17 <Binkley> syntaxfree: I think that's not what I meant, but anyway...
10:25:35 * shapr yodels cheerfully
10:25:50 <ski> shapr : hiya !
10:25:54 <shapr> hej ski!
10:26:06 <ex0r> map (member search) lis ?
10:26:12 <ex0r> wait
10:26:12 <Binkley> I tried to be polymorphic in my gender but then I got screwed over by the monomorphism restriction
10:26:14 <ski> search :: a
10:26:19 <ski> member :: a -> (Tree a) -> Bool
10:26:23 <syntaxfree> I guess map is male if defined as a catamorphism and female if defined as an anamorphism.
10:26:29 <ski> member search :: Tree a -> Bool
10:26:35 <ski> map :: (Tree a -> Bool) -> [Tree a] -> [Bool]
10:26:35 <xerox> search :: a ?!
10:26:41 <Binkley> syntax: that's the worst pun I've heard all week :-((((((
10:26:42 <ski> this matches up
10:26:53 <syntaxfree> OTOH, map (member search)  is either female or gay.
10:26:57 <xerox> blech? no Eq a?
10:27:04 <ski> (xerox : i'm not using implicit 'forall's here :)
10:27:07 <syntaxfree> er, (member search) is either female or gay.
10:27:16 <syntaxfree> so map (member search) is either lesbian or impossible.
10:27:16 <ex0r> or bi.
10:27:22 <syntaxfree> or bi.
10:27:58 <ski> (syntaxfree : how about hylo ro zygo ?)
10:28:05 <ski> (s/ro/or/)
10:28:09 <syntaxfree> can you define map as a hylomorphism?
10:28:26 <Binkley> maybe hylo and zygo correspond to neuter-gender and bi-gender
10:28:29 <ski> ex0r : so, yes, that should work :)
10:28:50 * ski actually doesn't remember definition of hylo or zygo ;)
10:28:50 <syntaxfree> Isn't hylo like group sex?
10:28:56 <xerox> ski ahah!
10:29:08 <syntaxfree> you compose a cata with an ana, and have it do someone else.
10:29:27 * syntaxfree is afraid of paramorphisms.
10:29:37 <Binkley> well, a hylo is something that produces a result and then consumes it immediately...
10:29:37 <xerox> ski, Haskell rots your brain (mine).
10:29:40 <Binkley> so it's sort of like masturbation
10:29:48 <ex0r> ski, that would remove the need for the aux function?
10:30:08 <ski> (this must be one of the strangest discussion on blah-morphisms, yet)
10:30:17 <ski> ex0r :)
10:30:17 <Templar85> anyone who knows a java chat?...
10:30:21 <ex0r> :O
10:30:33 <syntaxfree> I'm going to a Java chat with friends in a minute.
10:30:33 <shapr> Templar85: Yeah, I had a chat about Java once.
10:30:44 <Templar85> hmm
10:30:45 <syntaxfree> I mean, we're going to a coffeeshop to have some Macchiatos.
10:30:51 <ex0r> java ftw?
10:31:04 <shapr> ex0r: yes, "for the whine"
10:31:09 <xerox> syntaxfree: fun
10:31:12 <Templar85> lol
10:31:14 <ex0r> hehe
10:31:16 <ex0r> so true
10:31:38 <Templar85> java is a beather choise if you have hard to learn
10:31:47 <Binkley> I'm wondering how bananas play into all of this
10:31:52 <syntaxfree> Sadly, they don't know enough Haskell for me to use the fun *-morphism jokes.
10:31:57 <ski> ex0r : however (as xerox managed to mention in advance :), some of this 'Node' case can be shortened somewhat more, by a few built-in functions
10:31:58 <ex0r> member _ Empty = False
10:32:05 <syntaxfree> Blinkey: that's why catamorphisms are male!
10:32:06 <ex0r> Cannot justify co
10:32:07 <ex0r> nstraints in explicitly typed binding
10:32:11 <syntaxfree> bananas ----- lenses ----
10:32:14 <xerox> ski: I'm sorry to have stepped into the conversation multiple times
10:32:15 <syntaxfree> the barbed wire is for bondage.
10:32:19 <ex0r> never seen that error before
10:32:26 <shapr> Templar85: In my opinion, Haskell is easier to learn than Java.
10:32:33 <ski> ex0r : ah, yes ..
10:32:35 <Binkley> I guess it's pretty obvious what the envelopes are
10:32:46 <fasta> > or [False, True] -- see that ex0r ?
10:32:48 <lambdabot>  True
10:32:49 <ski> ex0r : that is because you use '==' ..
10:32:53 <shapr> For shipping functional toys?
10:32:53 <syntaxfree> Templar85: If you have no programming experience, Haskell is easy to learn and great.
10:33:07 <Binkley> I also guess I understand now why people assume things about my gender when I use "catamorphism" as a username :-)
10:33:10 <Templar85> I have read haskell 7 weeks and dont know anything an have just started with java and it feels like I understand that a LOT more
10:33:17 <syntaxfree> Templar85: It just happens that's significantly different from the more popular languages, so experienced programmers often have trouble picking it up.
10:33:28 <ski> ex0r : '(==)' requires the thing to be compared to support equality .. not all types support equality
10:33:32 <shapr> Templar85: Yes, but have you asked question about Haskell here on #haskell?
10:33:36 <Binkley> shapr: well, I was thinking of envelopes as being the opposite of bananas, if you get my drift
10:33:39 <ski> so, when you say
10:33:44 <ski> member :: a -> (Tree a) -> Bool
10:33:50 <syntaxfree> Templar85: Maybe you've been using the Gentle Introduction to Haskell.
10:33:55 <syntaxfree> That's not gentle, or an introduction.
10:33:57 <shapr> Binkley: I know, I was trying to lead your joke astray :-)
10:33:57 <ski> you say that your 'member' will work for any type 'a'
10:34:01 <syntaxfree> You want Hal Daume's YAHT.
10:34:03 <Binkley> shapr: ah, well, carry on :-)
10:34:05 <shapr> ski: argh
10:34:11 <Templar85> hehe, have asked a LOT of questins in here :P
10:34:19 <Templar85> *questions
10:34:20 <ski> ex0r : but it can only work for those types 'a' which actually support equality
10:34:24 <shapr> ski: Are you trying to follow in Binkley's footsteps with that comment? :-)
10:34:25 <ski> ex0r : do you follow ?
10:34:28 <ex0r> ah I see
10:34:32 <Binkley> ski: Yes, it's like refusing to have sex with non-feminists
10:34:33 <ex0r> yes
10:34:47 <syntaxfree> jesus christ.
10:34:52 <ski> (shapr : pardon, which comment ?)
10:34:55 <shapr> Binkley: That was an incredible joke.
10:34:58 <syntaxfree> Haskell needs a complete reform to better suit the puns.
10:35:00 <Binkley> shapr: thank you
10:35:19 <Binkley> syntaxfree: I was just reading in the History of Haskell paper how they decided not to name Haskell "Curry" instead, because they were afraid of Tim Curry puns :-)
10:35:40 <ski> ex0r : do you know the way to say that 'member' will work for any type 'a', *except* it has to support equality ?
10:36:09 <ski> (shapr : hm, the part about 'member' ?)
10:36:11 <ex0r> change the a to Eq a => <types>?
10:36:15 <ski> yes
10:36:38 <ski> if you ask '(==)' itself, it will show it in this way
10:36:40 <ski> @type (==)
10:36:42 <lambdabot> forall a. (Eq a) => a -> a -> Bool
10:36:55 <ski> (parens not needed for single constraint)
10:37:46 <ski> ex0r : btw .. you could note that the list pattern-matching that you before did in 'member_aux' is now done inside 'map'
10:37:51 <ski> map f [    ] = []
10:37:58 <shapr> ski: yes
10:37:58 <ski> map f (a:as) = f a : map f as
10:38:17 <shapr> Binkley: Hey, did you see that I got mentioned TWICE in History of Haskell!!
10:38:21 <syntaxfree> I read the HIstory of Haskell paper.
10:38:21 <ex0r> hmm I just noticed I have made another error
10:38:22 * shapr boings furiously
10:38:23 <syntaxfree> CONCORD!
10:38:23 <Binkley> shapr: yes, I saw :-)
10:38:31 <syntaxfree> they should have named it CONCORD!
10:38:36 <ex0r> it only considers leaves when doing the member check
10:38:38 <Binkley> another thing I noticed about the paper is that Audrey Tang is the only person who's subsequently referred to by their first name rather than last name
10:38:46 <ex0r> it should really check the nodes "x" aswell
10:38:48 <fnord123> hi all. has anyone written any tools in haskell that stay on all day and dont really lag from gc?
10:38:49 <Binkley> it looks like it's too late to mention that to anyone, though
10:38:50 <ex0r> argh! :)
10:38:54 <shapr> Binkley: I was totally thrilled! I even got my IRC NICKNAME mentioned in that paper!
10:38:54 <ski> (ex0r : so, in some sense, that pattern-matching is still happening .. just that you don't have to retype it over and over in many cases .. instead reusing the code of 'map')
10:39:01 * shapr boing explodes!
10:39:03 <fnord123> im wondering if haskell is something i can make a long running process out of
10:39:04 <Binkley> shapr: yeah, that was pretty cool :-)
10:39:06 <xerox> shapr: I've got only the real name :D
10:39:12 <syntaxfree> congrats, shapr.
10:39:12 <ski> ex0r : you're right ..
10:39:27 <Binkley> that was a great paper
10:39:28 <fnord123> shapr: which paper?
10:39:29 * ski again forgot about the element inside the 'Node's :)
10:39:46 <ski> ex0r : can you see how to fix this ?
10:39:48 <shapr> xerox: Hey, you got mentioned in History of Haskell after being in the community for about 2 years, yeah? That awesome :-)
10:40:04 <xerox> Yeah!  The Haskell community is fabulous!
10:40:14 <shapr> fnord123: History of Haskell - http://www.haskell.org/haskellwiki/History_of_Haskell
10:40:16 <lambdabot> Title: History of Haskell - HaskellWiki, http://tinyurl.com/yl5s8h
10:40:57 <ex0r> ski: yes
10:41:19 <ski> ex0r : so, how does your 'Node' case look like, now ?
10:41:21 <ex0r> I added a guard into the node member function to do x==search = True, otherwise the foldr....
10:41:27 <ndm> they missed hoogle from that history thing :(
10:41:42 <ex0r> because if its already found it there is no need to check the other subtrees anyway
10:41:55 <ski> (that's right)
10:41:59 <ex0r> (as each item in this tree is strictly unique)
10:42:22 <ski> (even if it wasn't there would be no need to check more ..)
10:42:49 <ex0r> thank you for your help everyone
10:43:04 <ski> ((since you're not returning something about how many times the element occurs, just whether it does or not))
10:43:07 <ski> ex0r : so, how does your 'Node' case look like, now ?
10:43:27 <ex0r> 		| x==search = True
10:43:28 <ex0r> 		| otherwise = foldr (||) False (map (member search) lis)
10:44:04 <ski> ok .. when you're returning a boolean, you shouldn't need to test booleans (in guards or 'if'), normally
10:44:18 <ex0r> oh
10:44:28 <ski> do you see what i'm getting at ?
10:44:37 <fasta> ski: Did you and ex0r even consider my code?
10:45:33 <ex0r> ski: not entirely
10:46:04 <ex0r> do you mean just not having = True?
10:46:10 <ex0r> err
10:46:16 <fasta> ex0r: you should implement map in terms of foldr as an exercise.
10:46:20 <ski> fasta : no .. we're taking it step-by-step, and we factored it a bit different than to get what you got
10:46:48 <ski> ex0r : well, about the previous 'member search (head lis)' and 'member_aux search (tail lis)' calls ..
10:47:14 <ex0r> ah yes :)
10:47:40 <ski> got it now ? :)
10:48:04 <ex0r> yup
10:48:11 <ski> so, what do you get, then ?
10:48:12 <ex0r> its just remembering it
10:48:26 <ex0r> member search (Node x lis) = x==search || foldr (||) False (map (member search) lis)
10:48:30 <ski> yes :)
10:48:41 <ex0r> :)
10:48:42 <ski> now, i'd like to bang a bit more on
10:48:48 <ski> foldr (||) False (map (member search) lis)
10:48:55 * shapr boings cheerfully
10:49:02 <shapr> happiness in codery!
10:49:05 <ski> > foldr (||) False [True,True,False,True]
10:49:07 <lambdabot>  True
10:49:09 <ski> > foldr (||) False [True,True,True,True]
10:49:11 <lambdabot>  True
10:49:15 <ski> > or [True,True,False,True]
10:49:17 <lambdabot>  True
10:49:19 <ski> > or [True,True,True,True]
10:49:20 <lambdabot>  True
10:49:28 <ski> > foldr (||) False [True,True,False,error "foo !"]
10:49:28 <ex0r> ah right
10:49:29 <lambdabot>  True
10:49:29 <xerox> @check \xs -> or xs == foldr (||) False
10:49:31 <lambdabot>    Expecting a function type, but found `a'       Expected type: Bool,     ...
10:49:33 <ski> > or [True,True,False,error "foo !"]
10:49:34 <lambdabot>  True
10:49:35 <ski> @type or
10:49:36 <xerox> @check \xs -> or xs == foldr (||) False xs
10:49:37 <lambdabot> [Bool] -> Bool
10:49:37 <lambdabot>  OK, passed 500 tests.
10:49:38 <xerox> OK?
10:49:39 <xerox> :)
10:49:39 <ex0r> presumably there are functions "and", etc?
10:49:49 <ski> or bs = foldr (||) False bs
10:49:52 <ski> yes
10:49:55 <ski> @type and
10:49:57 <lambdabot> [Bool] -> Bool
10:50:10 <ski> so, what do you get, now ?
10:50:32 <ex0r> member search (Node x lis) = x==search || or (map (member search) lis)
10:50:35 <ski> ok
10:50:38 <ski> > or (map (> 10) [1,5,2,9,15,4])
10:50:40 <lambdabot>  True
10:50:47 <ski> @type any
10:50:48 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
10:50:52 <ski> > any (> 10) [1,5,2,9,15,4]
10:50:54 <lambdabot>  True
10:51:07 <ski> do you see the point of 'any' ?
10:51:51 <ski> > any (> 10) [1,5,2,9,0,4]
10:51:53 <lambdabot>  False
10:51:54 <ex0r> if any elements in the list match the condition clause it returns true?
10:51:58 <ex0r> something like that
10:52:04 <ski> > any (> 10) [1,5,2,9,15,4,error "oops"]
10:52:05 <lambdabot>  True
10:52:07 <ski> yes
10:52:33 <ski> any test as = or (map test as)
10:52:42 <ex0r> any (member search) lis
10:52:46 <ski> ;)
10:53:03 <int-e> @type elem
10:53:05 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
10:53:26 <ski> ok, i'm done bashing the code now
10:53:30 <int-e> > any (`elem` [1,2,3]) [0,3,6]
10:53:31 <ski> any question ?
10:53:32 <lambdabot>  True
10:53:39 <ex0r> quite cool how you can filter something down to such a small piece of code
10:54:00 <ex0r> no, just a thanks!
10:54:03 <ski> it helps knowing a few common standard functions :)
10:54:09 <ski> yw
10:54:21 <ex0r> I shall now go and make like the man himself, and have a Curry.
10:54:21 <ski> (hope you learned a thing or two)
10:54:28 <int-e> heh, may I suggest reading the standard prelude?
10:54:48 <ex0r> I may well do that
10:56:00 <xerox> ex0r[a]: it is so fun that you probably will end up searching the smallest pieces that composed solve the given problem, at some point :)  and you will start hating named arguments
10:57:26 * mux hates named arguments indeed
10:57:32 <mux> but I like them more than flip
10:57:44 <mux> and other stuff tht makes code much harder to read
10:58:05 <mux> am I ok doctor?
10:58:23 <ski> Jag vill bo .. i en svamp, .. annars fr jag kramp !
10:58:29 <shapr> xerox: Do we have scheduled Haskell golf meetings on #haskell?
10:58:37 <Heffalump> will Data.Map just work in ghc 6.2.2
10:59:01 <xerox> shapr: haha, not YET.  Yesterday I was thinking we could organize Proper Lectures though.
10:59:08 <xerox> shapr: you know, as #math does.
10:59:30 <shapr> ski: Jag gillar inte hghus.
10:59:41 <ski> shapr : ok
10:59:49 <shapr> ski: Was that the right response? :-)
11:00:02 <ski> shapr : inte vad jag vet
11:00:29 <shapr> ski: That's the next line of the song by Lasse Oberg from Electric Banana Band, right?
11:00:55 <ski> shapr : "Det finns hopp .. fr min kropp .. i en saftig sopp - zvamp !" tror jag
11:01:04 <shapr> xerox: Does #haskell call it something other than golf? Maybe Haskell @pl ?
11:01:11 <ski> shapr : m, jag vet inte riktigt
11:01:25 <shapr> ski: Ah, Jag gillar inte hghus is the start of the verse.
11:01:42 <ski> shapr : oh .. i guess i've never heard that, then :)
11:01:50 <xerox> shapr: I think there are both cases, golfs, and straight @pls, where I try to beat lambdabot :P
11:02:06 <ski> (btw, s/Oberg/berg/, no ?)
11:02:43 <shapr> ski: Ooops, yes. Sofia's morfar heter berg, och jag var frvirrad.
11:03:04 <ski> (/me 's cramps seem to have subsided ..)
11:03:51 <ski> mux : you are not ok. you need to write fully pointless code !
11:04:43 * mux screams
11:04:59 <int-e> > fix (():)
11:05:01 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),...
11:05:26 <xerox> > fix (flip (:()))
11:05:27 <lambdabot>  Couldn't match `[a]' against `()'
11:05:31 <xerox> Ow.
11:05:32 <ski> mux : i prescribe wading through 'Algebra of Programming'
11:06:02 <mux> I really like pointless code, but sometimes it's way too much of an obfuscation
11:06:07 <ski> (Bird, De Moor)
11:06:24 <mux> ?pl \x -> x == y || x == z
11:06:25 <lambdabot> liftM2 (||) (y ==) (z ==)
11:06:39 <mux> which one do you prefer, ski? :-)
11:07:03 <ski> wouldn't you like one with monadic reflection even better ?
11:07:13 <mux> heh
11:07:34 <ski> [} [{ (y ==) }] || [{ (z ==) }] {]
11:07:42 <mux> arg, my eyes
11:07:44 * mux goes blind
11:07:54 <ski> (and yes, i would like better brackets)
11:08:30 <ski> `,(y ==). || ,(z ==).'
11:08:40 * xerox frags ski
11:08:44 <ski> ^^ i write in pseudo-code
11:09:04 * ski defrags xerox
11:09:33 * xerox swings the railgun...
11:10:20 * mux BFG9000's ski
11:10:21 * ski jumps into the unallocated space
11:12:27 * ski keeps mux on a weak pointer, and hopes for garbage-collection
11:12:54 <ski> (i.e. a pointer without a scroll-wheel)
11:14:56 * ibid invokes gc
11:15:19 <ski> but maybe there's a resurrecting finalizer ?
11:15:23 <xerox> haha... somebody turn ski off before he damages himself please.
11:15:41 <mux> heh
11:15:48 <mux> I can't keep up with the pace of this
11:16:00 <ski> xerox : already done
11:16:02 <ski> (the latter, i.e.)
11:16:53 <xerox> ?yarr
11:16:53 <lambdabot> Where d' all t' pirates come from?
11:16:54 <lambdabot> Great Yarrmouth!
11:17:07 <xerox> haha, I heard this spoken.
11:17:13 <xerox> (From Duncan himself.)
11:17:27 <dcoutts> I never!
11:17:37 <xerox> Lies!  Wasn't that one the one you had to add?
11:17:46 <dcoutts> It was the PiRats!
11:17:56 <dcoutts> I added to lambdabot though, sure.
11:18:05 <xerox> Hmrmrm, alright.... he likes screaming yarr in real life anyway.
11:18:09 <dcoutts> but I wasn't the one who had that line on stage.
11:18:11 <dcoutts> @arr!
11:18:11 <lambdabot> Aye
11:19:04 <arcatan> lambdabot sure can do lot of things
11:19:27 <dcoutts> @commands
11:19:27 <lambdabot> Unknown command, try @list
11:19:30 <dcoutts> @list
11:19:30 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
11:19:32 <ski> @yarr
11:19:32 <lambdabot> I want me grog!
11:20:11 <ski> @vixen But surely the mug will melt before we get it to you?
11:20:11 <lambdabot> what about me?
11:20:26 <dcoutts> @free [a] -> [a]
11:20:27 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
11:20:29 <Twigathy> @protontorpedo
11:20:30 <lambdabot> wil haskell make mroe more money?
11:20:42 <xerox> @keal
11:20:43 <lambdabot> there is no way to prove the failsafe exists
11:20:54 <ski> @palomer
11:20:55 <lambdabot> Brump!
11:20:56 <arcatan> @elite I is your new dictator
11:20:57 <lambdabot> i iz yOUR NeW dic7a7Or
11:21:10 <dcoutts> @yhjulwwiefzojcbxybbruweejw
11:21:10 <lambdabot> "\""
11:21:17 <dcoutts> wt?
11:21:22 <ski> haha
11:21:23 <dcoutts> @protontorpedo
11:21:24 <lambdabot> is haskell doomed to be a mysql driver?
11:21:33 <Cale> haha
11:21:38 <dcoutts> @v
11:21:38 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
11:21:43 <dcoutts> @girl19
11:21:43 <lambdabot> well.. I never hacked Russians
11:22:15 <dcoutts> @brain
11:22:16 <lambdabot> I think so, Brain! How much deeper would the ocean be if there weren't sponges down there?
11:22:31 <ski> @. type keal
11:22:32 <lambdabot> parse error (possibly incorrect indentation)
11:22:37 <arcatan> @keal
11:22:38 <lambdabot> its because the timeline diverges and past events themselves unhappen
11:22:56 * dcoutts thinks the brain quotes are under-appreciated
11:22:59 <dcoutts> @brain
11:23:00 <lambdabot> Zort!
11:23:14 <ski> @brian
11:23:15 <lambdabot> Now, Pinky, if by any chance you are captured during this mission,
11:23:16 <lambdabot> remember you are Gunther Heindriksen from Appenzell. You moved to Grindelwald
11:23:16 <lambdabot> to drive the cog train to Murren.  Can you repeat that?
11:23:23 <arcatan> I wonder what yhjulwwiefzojcbxybbruweejw stands for
11:23:42 <xerox> "difficult to find"
11:23:46 <ski> sounds remniscent of 'potrzeibe', somehow
11:24:02 <xerox> ski, that's just another weird word :P
11:24:43 <ski> oh, sorry, i misspelled it
11:24:57 <ski> ttp://64.233.183.104/search?q=cache:yXBIREuPCwgJ:potrzebie.ask.dyndns.dk/+potrzbeie+mad&hl=en&ct=clnk&cd=1
11:25:06 <ski> s/ttp/http/
11:25:48 <ski> ok, of course, better http://en.wikipedia.org/wiki/Potrzebie
11:25:49 <dcoutts> arcatan, it's about an old bug in @eval
11:26:07 <dcoutts> arcatan, see notoriousV in http://www.cse.unsw.edu.au/~dons/lambdabot/Plugin/Quote/Text.hs
11:26:09 <lambdabot> http://tinyurl.com/ybze5v
11:26:36 <ski> (xerox : you see it's not *just* another weird word :)
11:26:47 <xerox> dcoutts, is that a joke on a rapper's name?
11:27:26 <dcoutts> xerox, no idea, I don't follow *rap
11:27:54 <dcoutts> s/*/c/
11:28:01 <xerox> crazy.
11:28:11 <xerox> TV plays strange jokes
11:29:05 * xerox <- dinner
11:30:14 <dcoutts> does that mean the dinner produces xerox as a result ?
11:30:30 <spiffy> hello
11:31:23 <ski> hi there, spiffy
11:32:32 <Cale> dcoutts: it does!
11:33:21 <Cale> Humans are just dinners' way of making more dinners.
11:33:53 <dcoutts> Cale, hah hah hah
11:36:35 <spiffy> whats the opposite of filter?
11:37:05 <ski> @type filter . (not .)
11:37:07 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
11:37:16 <spiffy> ha ahh jeeze
11:37:22 * spiffy has had a long day
11:48:11 <edwardk> hey, does anyone have a nice binary of ghc for sparc solaris 8?
11:52:10 <lispy> heh, one of my professors just said this on a mailing list, "
11:52:11 <lambdabot> lispy: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:52:12 <lispy> I am not smart enough to program in Perl."
11:53:43 <lispy> ?tell kosmikus i wish i could, but i didn't understand it well enough...i'll bug him again
11:53:44 <lambdabot> Consider it noted.
11:53:54 <lispy> ?tell Igloo  i wish i could, but i didn't understand it well enough...i'll bug him again
11:53:55 <lambdabot> Consider it noted.
11:54:08 <edwardk> lispy: hehe
11:56:24 <lispy> ?tell kosmikus my only objection is that i haven't figured out a nice practical implementation of line labels
11:56:24 <lambdabot> Consider it noted.
12:01:09 <pejo> edwardk, isn't there one on the homepage?
12:11:49 * shapr throws sugared lambdas
12:12:12 * lispy enjoys a sugard lambda
12:12:21 <lispy> shapr: how's code?
12:13:35 <edwardk> pejo: nada
12:16:12 <thetallguy> Anyone have a method for removing non-registered files from a darcs tree?
12:16:40 <edwardk> darcs update then copy the contents of the pristine folder from _darcs? =)
12:17:04 <thetallguy> Hmm.
12:17:44 <thetallguy> That won't remove anything, will it?
12:17:54 <thetallguy> I'd have to remove the tree by had first
12:17:57 <edwardk> yeah
12:18:05 <edwardk> i was presuming you would do something like that
12:18:10 <lispy> darcs update?
12:18:20 <Heffalump> darcs revert -l ?
12:18:37 <lispy> thetallguy: you could get a list of those files with darcs what -ls | grep 'a'
12:18:39 <Heffalump> (and how about asking on #darcs :-)
12:19:03 <edwardk> lispy: er darcs record i meant =-)
12:19:41 <lispy> edwardk: okay, i would have guessed darcs pull :)
12:19:43 <shapr> lispy: code roxx
12:19:48 <lispy> shapr: awesome
12:19:52 <lispy> shapr: i can't say the same :(
12:20:07 <edwardk> lispy: i was assuming he was working in the repository he wanted to gut
12:20:19 <lispy> shapr: been reqired to do some VBA in Excel lately....ugh...I'm not smart enough to program in VBA where you have to reinvent every wheel you need
12:20:58 <shapr> I have fulltime Haskell contracting work, I'm producing BSD3 licensed code, and my coworkers and client/boss are just my kind of people.
12:21:15 <lispy> shapr: wow
12:21:19 <lispy> shapr: sounds great
12:21:21 <Binkley> shapr: how are you pulling that off?
12:21:42 <edwardk> shapr has officially gone delusional. =)
12:21:48 * shapr laughs
12:22:18 <thetallguy> lispy: what's the a stand for?
12:22:41 <lispy> thetallguy: let's see...A means added and a means not sure
12:22:43 <musasabi> shapr: thanks :-)
12:23:15 <lispy> thetallguy: and when i say 'not sure' i mean, that's what darcs is saying
12:23:23 <lispy> thetallguy: the file is there but it doesn't remember it
12:23:33 <thetallguy> Gotcha.  That's what I was looking for
12:26:50 <Igloo> If I can only do   runCmd ['prog', 'arg1', ...]   then is there a way to create a file containing a string I have using only standard tools and not having to worry about escaping?
12:27:41 <lispy> Igloo: so, piping is not an option?
12:27:55 <Igloo> No
12:28:21 <lispy> well, then echo and cat are out :)
12:28:31 <Igloo> And tee, I think
12:28:48 <Igloo> This is just silly
12:29:12 <Heffalump> is perl a standard tool?
12:29:26 <Heffalump> oh, you'd still have escaping problems
12:29:58 <profmakx> [1;2B
12:29:59 <Igloo> I guess something like perl or awk would do
12:30:17 <Igloo> If cygwin comes with them
12:36:37 <thetallguy> igloo, there is a function that doesn't escape.
12:36:42 <thetallguy> I need to look it up.
12:36:55 <thetallguy> it may be in one of our unreleased libraries
12:39:40 <dmead> hey lispy
12:39:54 * therp jumps
12:40:01 <therp> I solved my strange FastString unequalness problem
12:40:03 <dmead> do you know if theres a library with hugs or ghci that lets you trace haskell like you can lisp?
12:40:21 <therp> nothing is more blinding to a solution than wrong test cases.
12:40:48 <Excedrin> Igloo: System.Posix.Process.executeFile?
12:40:51 <therp> and indeed skew guess was right. It was a "different linking environment" issue
12:43:55 <thetallguy> igloo: look at runInteractiveProcess
12:44:24 <musasabi> if the function *can* be changed then there is writeFile ;)
12:44:25 * Igloo isn't writing Haskell code, I'm working on buildbot for GHC
12:44:50 <Igloo> I've decided just to call python, as the testsuite uses that anyway
12:44:59 <musasabi> Igloo: I have some buildbot things for cabal packages if you are interested.
12:45:35 <musasabi> but just a few lines which are easily replicated.
12:45:54 <Igloo> musasabi: Only if you have a nice way to have it create a file with given contents  :-)
12:47:44 <thetallguy> igloo:  Ah.  That clears things up.
12:48:15 <thetallguy> what language are you writing in?
12:48:53 <thetallguy> buildbot is what they are using for ghc?
12:48:59 <thetallguy> sorry, yhc?
12:49:00 <Igloo> thetallguy: Well, buildbot is python if that's what you mean
12:49:03 <Igloo> yes
12:49:31 <thetallguy> Hmm...
12:55:27 <Baughn> @type map
12:55:28 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
12:57:11 <Baughn> @type ($)
12:57:13 <lambdabot> forall b a. (a -> b) -> a -> b
12:57:20 <scodil> why can't the compiler disambiguate duplicate identifiers based on type? sure it can't always be done, but why not try? is there a reason why it shouldn't?
12:57:57 <monochrom> Like what?
12:58:10 <Heffalump> that's what type classes are for
12:58:41 <Heffalump> they're a principled and reliable way to do the disambiguation
12:59:01 <scodil> like hopengl and gtk2hs both have set and get functions
12:59:34 <Cale> There would need to be a typeclass for those.
13:01:01 <scodil> no thats not what i'm thinking of. someone would have to arbitrate that. its not realistic for separate library writers to agree on a common class. if you import two modules, and they both define functions with the same name, try to disambiguate based on type
13:01:38 <scodil> it can't be any harder than type inference
13:01:39 <scodil> can it?
13:01:53 <monochrom> I recommend PL/I for that.
13:02:03 <scodil> whats pl/i?
13:02:18 <Heffalump> ChilliX: hi
13:02:20 <monochrom> It permits you to write "if if=then then then=else else else=if"
13:02:39 <monochrom> some of the "if", "then", "else" there are variables.
13:02:42 <ChilliX> Hi Heffalump!
13:03:02 <monochrom> So, the compiler disambiguates your intention by context!
13:03:08 <monochrom> You'll love it.
13:03:27 <scodil> wild
13:03:41 <monochrom> Precisely what I would say to your proposal.
13:03:48 <Heffalump> scodil: that's what import qualified is for
13:04:04 <Heffalump> (not disambiguation by type, but to allow users to disambiguate explicitly)
13:06:59 <twanvl> It's actually not hard at all, for each use of an identifier with two definitions duplicate the program. Compile both versions with the different definition (for that particular use). If exactly one program compiles without errors then that is the output.
13:08:18 <scodil> yeah exactly
13:08:35 <scodil> i was thinking more along the lines of (extra?) backtracking in the type-inferrer
13:08:57 <ski> backtracking compilation ! fun !
13:09:03 <scodil> i don't know how much it does already. if memory servers, it doesn't need to do any.
13:09:14 <scodil> serves, even
13:09:44 <ski> "compiler : maybe the programmer intended it to be read in this way .. or maybe in this way .. lets try all of them"
13:10:06 <scodil> ... and if exactly one type checks, use that one. otherwise, complain
13:10:11 <ski> nonono
13:10:25 <ski> if more than one type checks, use all of them !
13:10:35 <scodil> a.out1, a.out2 ... a.outn
13:10:41 <ski> (but in parallel universes, you understand)
13:11:35 <ski> (if none type-checks, the universe should of course self-destruct)
13:11:52 <scodil> the universe where it successfully compiled, you mean
13:12:06 <ski> the universe where it failed type-checking
13:14:50 <scodil> yeah. exaclty. where it did both.
13:16:27 <ski> if it succeeded, it didn't fail
13:16:51 <scodil> in some universes, sure
13:17:12 <ski> are you working in a para-consistent logic again ?
13:17:31 <edwardk> ski: or you could randomly try one on the premise that in some universe one of them would succeed =)
13:18:32 <ski> edwardk : that would be a kind of demonic nondeterminism .. and if some choices lead to no solution, then it's highly unsafe
13:19:15 <monochrom> You people are crazy.
13:19:15 <edwardk> of course, not advocating it as a general principle, just taking your parallel world version to its extreme
13:19:37 <SamB> hmm, is P = NP?
13:19:57 <ski> the fun thing is if we could get the parallel universes to communicate (using cut, of course)
13:20:21 <ski> SamB : ask the excluded middle
13:20:43 <SamB> what is para-consistancy?
13:20:49 <SamB> ski: excluded middle?:
13:20:58 <SamB> how does that relate to the answer?
13:21:02 <ski> http://plato.stanford.edu/entries/logic-paraconsistent/
13:21:05 <lambdabot> Title: Paraconsistent Logic (Stanford Encyclopedia of Philosophy), http://tinyurl.com/7253d
13:21:12 <edwardk> samb: paraconsistency is where you accept that something can be both true and false, but reject the notion that A ^ ~A -> B for all B.
13:21:52 <ski> SamB : according to excluded middle, 'P = NP' is either true or false .. so you just do a case analysis on the proof that the excluded middle returns and ...
13:22:47 <edwardk> samb: its useful whenever you are willing or must accept all claims, but reject contradiction. for instance i am starting to use it when searching data marked up by ontologies, so you can infer things in a paraconsistent manner, and search for consequences of a set of axioms, and find matches, and then the user can prune the overgenerous list.
13:23:02 <ski> (in some sense, para-consistency is actually quite reasonable, though ..)
13:25:18 <ski> (everybody knows that from both 'A' and '~A' you get '_|_' (aka 'Absurd'/'Bot') .. the step that's questionable is the inferring of any 'B' from '_|_', imo)
13:25:42 <Baughn> Has anyone written a sexp-to-haskell syntax translator yet, or am I being blasphemic in considering one?
13:25:59 <mauke> .oO( LambdaBottom )
13:29:07 <edwardk> you basically have to give up injection: (a -> a or b), the ability to eliminate one of two options from the fact that if a or b and ~a both hold then b must be true, or you have to give up cut elimination, the latter would require you to give up forming theorems/lemmas in the logic so its probably not the best choice.
13:29:54 <edwardk> you also have to give up either double negation elimination, weakening or the ability to reason that if a implies both b and ~b, then ~a.
13:30:07 <ski> edwardk : or you can simply split disjunction
13:30:26 <xerox> edwardk: I'm not sure what you mean there, could you "quote" the laws, or write them in some form distinguishable from the English of the phrase?
13:31:22 <monochrom> "p  p" double negation elimination
13:31:26 <ski> weakening is weak
13:31:51 <edwardk> one of A |- A v B  ;   A v B, ~A |- B  ;   or A |- B; B |- C ==> A |- C have to be given up.
13:32:22 <edwardk> in addition one of: A -> (B ^ ~B) |- ~A    ; A |- B -> A  ; or ~~A |- A
13:32:33 <xerox> I don't understand the first two sorry.
13:32:50 <edwardk> A |- A v B?
13:32:53 <xerox> Is it (A |- A) v B or A |- (A v B) ?
13:33:00 <edwardk> A |- (A v B)
13:33:06 <edwardk> |- has the lowest precedence
13:33:28 <xerox> Why should A imply (A or B) ?
13:33:33 <edwardk> |- can be read as entails, its a tool for manipulating sequents
13:33:43 <edwardk> because if A is true, then its definitely true that A or B is true.
13:33:57 <ski> @type Left
13:33:59 <lambdabot> forall b a. a -> Either a b
13:34:00 <Baughn> Tautological, even
13:34:14 <ski> @djinn a -> Either a b
13:34:15 <lambdabot> f = Left
13:34:20 <edwardk> in constructive/classical logic =)
13:34:21 <xerox> I.e. a proposition is either the only true one, or there is at least another one true?
13:35:28 <edwardk> well, if A is true, then A v B is true, because it doesn't matter what you choose for B. if B is false A v B is still true, A v B is also true of B is true. so B is irrelevant, but nevertheless the statement A v B is a true statement.
13:36:09 <edwardk> the second one states that if A v B holds, and A doesn't, then the only way that can occur is if B holds.
13:36:21 <xerox> I was thinking of it as a way to say that |- is useful to something :)
13:36:36 <xerox> Right.  I was working on that as we spoken
13:36:37 <edwardk> you read items to the left of the |- separated by ','s as conjuncts.
13:36:41 <ski> '|-' is a meta-predicate
13:36:52 <ski> on the same level as the "is true" meta-predicate
13:37:21 <xerox> ski: care to elaborate slightly more?
13:37:25 <ski> (though '|-' has two arguments .. which usually are sequences of formulae)
13:37:48 <xerox> Is it "the same" meta-predicate, or a different one, or what.
13:37:52 <edwardk> xerox: |- is a tool you use to reason about any logic, not just some particular logic, so its not a tool of the logic itself.
13:38:02 <edwardk> its a tool for reasoning about logics.
13:38:06 <monochrom> |- is an overloaded operator
13:38:06 <ski> xerox : we need to separate between the object logic and the meta-logic used to reason about the object-logic (and the meta-logic is assumed given)
13:38:43 <xerox> Does this just *look* overly complicated, but simple in the being, or am I trying to understand something very complex?
13:38:53 <ski> xerox : ".. |- .." can be read as ".. leads to ..", "if .. then ..", ".. entails ..", etc
13:39:15 <edwardk> there is a little finesse to it, but you are basically getting it. i think.
13:39:21 <monochrom> It looks simple and it is simple.
13:39:57 <ski> A0,A1,.. |- B0,B1,..
13:40:05 <ski> usually is interpreted intuitively as
13:40:34 <xerox> monochrom: I always thought of it as =>, but seems to be more to it
13:40:34 <ski> if A0,A1,... are all true, then some of B0,B1,.. is true
13:40:53 <edwardk> says that given A0 and A1 and ... then B0 or B1 or ...
13:40:55 <edwardk> yeah
13:41:01 <ski> so ',' to the left of '|-' works like "and"
13:41:08 <ski> and ',' to the right of '|-' works like "or"
13:41:13 <ski> (only on the meta-level)
13:41:46 <ski> (note that i included the "are/is true" on purpose)
13:41:50 <edwardk> in constructive logics you find you wind up with a single proposition on the right hand side of the |-. so sequents constructed for things like the lambda calculus have a pretty simple structure.
13:42:13 <xerox> Sequents for LC?
13:42:16 <xerox> What does that mean?
13:42:25 <ski> x :: Int, y :: Int, b :: Bool |- if b then x else y+1 :: Int
13:42:41 <monochrom> OK.  In Haskell you write "f x = x + 1".  Note the "=" there.  Now I want to say, at the level of reasoning about programs (rather than at the level of code), f 5 "is" 6.  What symbol should I use for "is"?
13:42:52 <ski> note that there's only one conclusion (the 'if b then x else y+1 :: Int')
13:42:52 <edwardk> well, is we label these we can say things like x : A, y : B |- (x,y) : A x B
13:43:22 <xerox> monochrom: i guess the answer is that you use |-.
13:43:36 <monochrom> Yes, something like that.
13:43:44 <ski> monochrom : /me usually uses '=' ..
13:44:08 <monochrom> |- is what you use to reason about the properties of 
13:44:08 <ski> .. if you want to stress directedness, you could use something like '-->'
13:44:09 <xerox> I think he's giving me another example, that I can reason about, of the possible usage of |-, which is nice, thanks.
13:44:57 <ski> i'm not sure it is nice to use '|-' for term equivalence (/evaluation)
13:45:15 <ski> (maybe if you think of the terms as "types")
13:45:29 <monochrom> I'm drawing an analogy tailor-made to a particular person with a particular background, OK?
13:45:37 <ski> xerox : did you understand the example entailments for LC ?
13:45:41 <xerox> monochrom: yes, that's great.
13:45:43 <monochrom> It is not supposed to be comprehensible to anyone other than me and xerox.
13:46:04 <ski> monochrom : don't let me deter you if you think it is reasonable
13:46:07 <xerox> ski: no sorry, at that point three different explanations were too much to follow at the same time.
13:46:24 <ski> (i'm just not sure i myself think it is nice)
13:46:34 <xerox> Ah, now I see what you mean there.
13:46:52 <ski> if you omit the proof terms (i.e. expressions) you get just
13:46:58 <ski> Int,Int,Bool |- Int
13:47:04 <xerox> x, y, and b on the LHS, the if expression on the RHS of |-.
13:47:09 <edwardk> Another example is that if Gamma represents a sequence of propositions A0, A1, A2, ..., An and we overload , so that it can join that list of propositions with elements, so Gamma, x : A is the same as A0, A1, A2, ... An, x : A then if Gamma, x : S |- M : T     then  Gamma |- (\(x : S) -> M) : S -> T   so you can start to view things on the left hand side of the turnstile as the context you are evaluating in
13:47:20 <ski> i.e. if Int,Int,Boll are all true (inhabited), then Int is true (inhabited)
13:47:32 <xerox> Right.
13:47:51 <edwardk> using haskell notation for the \(x: S) -> M rather than the lambda notation
13:48:02 <xerox> monochrom used |- to reason about value level properties, ski for type level ones.
13:48:20 <ski> yes
13:48:23 <ski> Gamma, x : S |- M : T
13:48:25 <ski> --------------------------------------
13:48:28 <ski> Gamma |- (\(x : S) -> M) : S -> T
13:48:31 <xerox> edwardk: KISS (for me, hehe.)
13:48:36 <ski> it is often written like that
13:48:48 <xerox> I have seen sequents in a logic book (the last summer) !
13:49:12 <ski> (the horizontal line reads as "from ..(all of the) above.. you can infer ..below.."
13:49:14 <xerox> It probably didn't have a good introduction to "|-".
13:49:16 <ski> )
13:49:19 <edwardk> xerox: http://comonad.com/reader/ the bottom post there while i was testing has a set of sequents for part of a simply typed lambda calculus
13:49:23 <lambdabot> Title: The Comonad.Reader
13:49:32 <edwardk> look under 'syntax highlighting works' =)
13:49:45 <xerox> haha, the comonad reader.
13:49:49 <ski> edwardk : that's your domain ?
13:49:50 <xerox> Is there such a thing?
13:50:01 <edwardk> xerox: the term to look for would be 'Gentzen style sequent calculus' in wikipedia or something =)
13:50:04 <edwardk> ski: yeah
13:50:06 <ski> cool name !
13:50:19 <edwardk> ski: picked it up a couple weeks back
13:50:35 <xerox> onad.com
13:50:43 <xerox> Too crazy.
13:51:21 <edwardk> onad.com was taken. =) i was bored and looking for decent mathematically themed domains
13:51:24 <xerox> edwardk: ok, you can write greek letters and symbols, and lines.
13:51:45 <edwardk> xerox: ok, lets work through what those statements mean one at a time
13:51:58 <ski> data Comonad.Reader r a = MkCR r a
13:52:08 <ski> instance Comonad (Comonad.Reader r)
13:52:27 <edwardk> the first one says, that if something is on the left hand side of the turnstile you can use it on the right. thats kind of a nobrainer.
13:52:37 <edwardk> the second one says you can build lambdas
13:52:41 <edwardk> the third says you can apply them =)
13:52:56 <xerox> turnstyle?
13:52:58 <ski> 'turnstile' = yet another name for the 'entails' sign
13:53:00 <edwardk> that the result of applying a function of type S -> T  to a value of type S is a value of type T.
13:53:01 <xerox> *turnstile ?
13:53:05 <xerox> Ah, thanks.
13:53:19 <xerox> Adding names without introduction while explaining is very helpful :)
13:53:21 <edwardk> it looks like the thing you walk through in the subway (kinda)
13:53:30 <edwardk> which is called a turnstile
13:53:48 <ski> oh
13:53:50 <edwardk> turnstile, vdash, entails, right tack, it has lots of names =)
13:53:57 * ski didn't know the origin of that word
13:55:08 <ski> with those three inference rules, you can type-check simple (monomorphic) lambda-calculus expressions
13:55:15 <xerox> What are '', 'M', and 'N'?
13:55:29 <ski> '?' ?
13:55:41 <ski> do you mean the upper case greek letter "gamma" ?
13:55:50 <xerox> Right.
13:56:01 <ski> that is the typing environment
13:56:21 <ski> which tells what free variables are in scope at this point, and what their types are
13:56:30 <ski> compare
13:56:39 <ski> x :: Int, y :: Int, b :: Bool |- if b then x else y+1 :: Int
13:56:47 <mathewm> I am not findind much documentation on GHC's unicode support - is Char unicode aware?
13:57:01 <edwardk> normally you would have something like a BNF grammar that indicates how they can be constructed syntactically. like M, N ::= \lambda x : \sigma. M | M N | C | V . then define C as the syntax of the constants you are allowed and V as the set of variable names.
13:57:10 <fasta> Can I create re-invocable continuations in Haskell? If so: how?
13:57:12 <xerox> If in a context Gamma, there is a term x of type tau, then you can use the term x of a type tau?
13:57:13 <fasta> "n addition to the escape mechanism provided by callCC, the Continuation monad can be used to implement other, more powerful continuation manipulations."
13:57:49 <ski> xerox : yes
13:57:52 <xerox> Cool.
13:57:59 <ski> that just says that you can use variables that are in scope
13:58:16 <xerox> What's M instead?
13:58:36 <ski> it's a meta-variable, ranging over (lambda-calculus-)expressions
13:58:37 <xerox> It should be a term, as x, shouldn't it?
13:58:45 <edwardk> xerox: thats basically what the first line says, except, except to be more precise, its saying that if you have any context gamma, that if you extended it with a term x of type tau, then you could infer x has type tau from that extended context. =)
13:58:46 <ski> 'N' is also such a one
13:59:14 <ski> fasta : just invoke the continuation captured by 'callCC' more than once
13:59:18 <xerox> edwardk: ah, I see, so it is useful to construct contexts in fact.
13:59:36 <edwardk> xerox: the distinction is somewhat trivial though. and you can find versions that use sequents like x : \tau \in Gamma   ===> Gamma |- x : \tau
13:59:40 <ski> sometimes people write
13:59:50 <ski> (x : tau) `elem` Gamma
13:59:52 <ski> ---------------------------
13:59:52 <edwardk> but the latter doesn't say how to build contexts, just that they contain values
13:59:56 <ski> Gamma |- x : tau
13:59:56 <fasta> ski: ok, do you know of a practical example?
14:00:12 <xerox> edwardk: I see.  What is the difference between 'x' and 'M' ?
14:00:24 <edwardk> xerox: x is a variable name, M is a whole expression.
14:00:40 <xerox> They contain different things?
14:00:50 <ski> 'x' is a meta-variable ranging over (object-)variables in our little language
14:00:59 <xerox> Like, say, numbers.
14:01:03 <ski> 'x' can only be a variable, while 'M' could be any expression
14:01:16 <xerox> Say, "if ... then ... else ..."
14:01:20 <edwardk> well, x is just the name 'foo', 'bar', 'baz', etc. M is an expression that can contain something like a lambda expression and function application
14:01:28 <ski> data Expr = V Var | L Var Expr | A Expr Expr
14:01:31 <ski> x :: Var
14:01:37 <ski> m,n :: Expr
14:01:46 <xerox> !
14:01:58 <xerox> V bridges the gap.
14:02:43 <ski> fasta : well, if you want a useful example .. e.g. backtracking implemented by continuations .. or monadic reflection, implemented by composable continuations
14:03:12 <fasta> ski: do you mean callCC (\continuation-> code with placing this continuation in a datastructure and calling it later)
14:03:14 <ski> (in the monadic reflect case it depends on the monad, of course)
14:03:23 <ski> fasta : e.g. that, yes
14:03:42 <ski> (fasta : though note that the "data-structure" could be a function)
14:03:46 <xerox> edwardk: in your LC syntax there, \x. M applies x to M without the need to write \x. M x, right?
14:03:50 <edwardk> yeah in the little BNF blurb i gave above: M,N ::= M N | \x : T.M | x | C, says that you can use variables as terms, ski spelled it out by typing the expressions and wrapping variables in the V constructor
14:04:09 <ski> '\x. M' corresponds to 'L x m'
14:04:19 <ski> 'M N' corresponds to 'A m n'
14:04:23 <fasta> ski: I only recently understand Scheme call/cc and I wanted to know whether Haskell was in the same league
14:04:29 <ski> 'x' as an expression corresponds to 'V x'
14:04:40 <xerox> ski: yes, in your model.
14:04:45 <edwardk> \x:T.M corresponds to haskell \(x :: T) -> M
14:05:01 <fasta> ski: what is a composable continuation?
14:05:14 <fasta> ski: or where can I read about what a composable continuation is?
14:05:44 <edwardk> xerox: so \x. M. binds the variable x inside of the expression M by constructing a lambda expression.
14:05:44 <ski> fasta : well, afaik, no haskell implementation has primitive (reifiable) continuations .. nevertheless, one can get similar effects (though one have to live in a monad)  (note that continuations is a kind of side-effect, so allowing it directly, would entail allowing side-effects in haskell)
14:05:48 <xerox> edwardk: can you help me read the bottom part of the second sequent, adding parenthesis?
14:05:52 <fasta> ski: "the datastructure" being a closure, you mean?
14:06:10 <ski> yes
14:06:24 <ski> fasta : http://community.schemewiki.org/?composable-continuations-tutorial may perchance explain it
14:06:28 <lambdabot> http://tinyurl.com/yy2eux
14:06:37 <edwardk> Gamma |- ( \ (x :: s) -> M ) :: s -> t
14:06:40 <fasta> ski: Thanks, I didn't know that page yeyt.
14:06:43 <fasta> er yet
14:06:58 <edwardk> using haskell notation for the right of the |-
14:07:17 <xerox> AH!
14:07:30 <xerox> That's what the type is bound to.  Makes sense now :)
14:08:00 <xerox> You always read the implicit parenthesis right without writing them down?  I find that hard.
14:08:07 <edwardk> basically what its saying is that if i could extend the context Gamma with a variable x, and get an expression M that might include references to x to be well typed, then I can use just gamma, and the expression \x -> M would be well typed as well.
14:08:27 <edwardk> xerox: you get used to them if you use this a lot =)
14:09:02 <edwardk> but yeah you can parenthesize if the precedence isn't clear.
14:09:02 <ski> this inference rule implements the essence of local scope
14:09:12 <xerox> > ((. (return .)) . (>>=)) [1..10] (*2) -- yeah, probably.
14:09:14 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
14:10:04 <edwardk> then the last rule is trivial
14:10:13 <edwardk> which just says that function application reutrns the type you'd expect
14:10:20 <ski> just application / modus ponens
14:10:36 <ski> (if you know A, and you know that A implies B, then you may infer B)
14:10:43 <xerox> Yeah, I can see that.
14:11:01 <xerox> After having learnt a bunch of grammar :)
14:11:04 <edwardk> heh
14:11:20 <edwardk> yeah, but the grammar is useful, if you scroll up you can see a scarier example, which i won't try to explain right now =)
14:11:56 <edwardk> that would be hard to express without the formalisms
14:12:10 <xerox> Enough logic for me today too.
14:12:24 <edwardk> if you want i can refer you to some nice papers on the subject.
14:12:29 <edwardk> but probably another day
14:12:30 <xerox> Guess what, this afternoon I have taken my first lecture in logic at the university.
14:13:03 <xerox> (Unfortunately it wasn't the first one they've made, I've missed the first bunch :( )
14:13:13 <edwardk> doh
14:13:20 <xerox> Yeah, I travel too much.
14:13:40 <edwardk> are you taking the course for credit or just sitting in on random lectures?
14:13:49 <xerox> The latter one, but with a bonus.
14:13:54 <ski> fasta : are you getting some of it ?
14:14:09 <fasta> ski: Actually, I walked away from the computer for a few minutes.
14:14:18 <fasta> ski: I will read it some other day.
14:14:21 <xerox> I was told that the professor let you take the exam, if you want, and then formalize the vote in the third year, when it actually matters. (It's a third year course.)
14:14:54 <ski> fasta : the author there uses it to convert internal to external iteration
14:15:07 <edwardk> formalize the vote?
14:15:07 <xerox> I shouldn't have said that publicly in a logged channel, but I doubt anyone interested will ever find this out :)
14:15:10 <ski> (monadic reflection is, as i mentioned, another use)
14:15:17 <fasta> ski: I don't know the concept of internal or external iteration.
14:15:21 <xerox> Write it down in your curriculum, how is that called?
14:15:32 <fasta> ski: monadic reflection is also jargon for me, sorry
14:15:42 <fasta> ski: willing to learn, but unfamiliar.
14:16:00 <dolio> Internal is where you pass in a function, and the data structure converts the elements (like a map)...
14:16:12 <ski> fasta : when traversing a collection, if you have an interator, that you ask if there's another element, and to get that one (and advance to the next one), then that is external iteration
14:16:14 <dolio> External is where you ask for each element, use it, and then possibly build a new structure.
14:16:15 * xerox hunts for water
14:16:36 <ski> fasta : otoh, if you pass your "loop body" as an argument, like with 'map' or 'foldr', that is internal iteration
14:17:20 <fasta> That's pretty simple. So external iterator is what Java's Iterator does, and Haskell's way (map) is internal.
14:17:51 <ski> (and, generally, it is hard to define external iteration, if you only have internal iteration. however, having composable continuations enables this neat trick)
14:18:05 <edwardk> xerox: ah
14:18:10 <SamB> what about folds?
14:18:18 <ski> fasta : you could think of 'toList' as external iteration
14:18:24 <ski> @hoogle toList
14:18:25 <xerox> Does that make any sense edwardk?
14:18:25 <lambdabot> Data.HashTable.toList :: HashTable key val -> IO [(key, val)]
14:18:26 <lambdabot> Data.IntMap.toList :: IntMap a -> [(Key, a)]
14:18:26 <lambdabot> Data.IntSet.toList :: IntSet -> [Int]
14:18:46 <edwardk> xerox: yeah, take it now, record it later =)
14:18:47 <fasta> ski: is there also a formal definition of "external iteration"?
14:19:06 <xerox> edwardk: right. On the other side, it is not exactly "legal".
14:19:14 <edwardk> understand
14:19:17 <fasta> ski: or is it like <insert non agreed concept> where people are still arguing on what it means?
14:19:25 <ski> fasta : hm, formal definition ?  (did someone give a such for internal iteration ?)
14:19:44 <fasta> ski: no, but I don't really like fuzzy concepts.
14:19:49 <xerox> Is there a #logic channel?
14:20:07 <edwardk> xerox: not that ever has anyone on it talking =)
14:20:09 <fasta> ski: I see how they obviously differ, but it seems a rather useless idea.
14:20:30 <ski> fasta : which ?
14:20:50 <fasta> ski: internal vs external iterator.
14:21:15 <fasta> ski: it's just the abstraction of being able to pass a function that enables things like map.
14:21:23 <ski> it's a useful distinction
14:21:28 <xerox> ski - come over to #logic!  monochrom too?
14:22:43 <fasta> ski: maybe for the monadic reflection you talked about, well, I don't know. It's better to discuss it further when I have been enlightened on monadic reflection.
14:22:45 <xerox> Everybody that wants to talk about logic, but in fact I just have another question and I'll be sleeping, so it's up to the others :)
14:22:45 <monochrom> No time.
14:23:17 <xerox> monochrom - nevermind.
14:23:58 <ski> fasta : ok (but, from what i know, the monadic reflection isn't related to the internal -> external iteration .. other that both can be implemented using composable continuations)
14:24:20 <fasta> ski: oh, right, I was confusing things.
14:24:34 <fasta> ski: I am now under the influence of randomizing fluids.
14:27:48 * xerox -> bed
14:28:42 <SamB> @hoogle Int -> Char
14:28:43 <lambdabot> Char.chr :: Int -> Char
14:28:44 <lambdabot> Char.intToDigit :: Int -> Char
14:28:44 <lambdabot> Data.PackedString.indexPS :: PackedString -> Int -> Char
14:29:03 <jajs> hello. What would be the best book to learn "advanced" Haskell ?
14:30:09 <chessguy> the libraries?
14:32:04 <jajs> chessguy, sorry i do not understand
14:32:27 <chessguy> look at the source code for the libraries
14:33:42 <jajs> oh. well, maybe what i call "advanced" is just "intermediate" :-)
14:34:16 <fasta> jajs: Write a practical program
14:34:29 <chessguy> you could write a chess program :)
14:34:36 <fasta> jajs: subscribe to the mailing lists.
14:35:02 <fasta> jajs: read okmij.org/ftp
14:35:10 <jajs> fabiim, i'm writing a compiler for Tiger following Appel's book, but i do not use Monads/GADTs/Arrows/typeclasses :-(
14:35:18 <jajs> ooops, fasta not fabim, sorry
14:35:31 <fasta> jajs: well, if it's still understandable you are doing ok.
14:36:01 <dolio> Which Appel book? ML?
14:36:02 <fasta> jajs: if it's not, then you need to see how these techniques work.
14:36:31 <jajs> dolio, yes
14:36:42 <dolio> Is it any good?
14:36:56 <ski> jajs : probably you'll need to use monads for the mutation here and there
14:37:09 <fasta> I don't think software gets written in its final form the first time.
14:38:01 <fasta> At one point, I was creating a program that became too complex to manage, so I learned about the various Monads, which seemed to help.
14:38:11 <jajs> ski, i'm only at semantic analysis; dolio : yes i think so, but i'm not an expert
14:38:36 <dolio> Ah, okay. Nor am I. :)
14:40:38 * ski thinks it is nice
14:41:05 <ski> (they mention the continuation-implementation of io :)
14:41:25 <dolio> Well, I ask because I bought the Java one back when I was young and naive, and was disappointed at Appel's ability to write C code in Java.
14:41:38 <ibid> the second edition is much better
14:41:47 <chessguy> i hope the haskell and haskell-cafe mailing lists are more interesting than the GHC one
14:42:27 <dolio> But then, now I realize I probably wouldn't build a compiler in Java anyway, so I thought perhaps the ML book would strike me better, but I've never seen it at a bookstore.
14:43:35 <ibid> dolio: the first edition of both the C ans Java books stroke me as ML in C and Java :). the second edition of the java book is much more idiomatic
14:44:50 <jajs> isn't Andrew Appel a ML person at heart ?
14:44:58 <monochrom> haskell-cafe is interesting
14:45:02 <dolio> Ah, well that could be, too. I didn't know ML or anything like it at the time, so I'd have been ill equipped to identify it, and I haven't gone back and re-read it after learning Haskell.
14:45:02 <ski> jajs : indeed
14:45:15 <chessguy> are you guys talking about ML, the language?
14:45:18 <ski> yes
14:45:25 <ski> (or, rather, SML)
14:45:33 <monochrom> I have a precious copy of the ML editon :)
14:45:38 <chessguy> hey ski. sorry i had to run out on you earlier
14:46:03 * ski bought the book at uni shop, just because it looked cool
14:46:23 <largos> I'd like to implement some form of driver-independant transparency (could be fake) with gtk2hs.  Does anyone have any pointers to get started on this?
14:46:31 <chessguy> there's a book on designing compilers in ML?
14:46:51 <ibid> yes
14:46:57 <ski> chessguy : http://www.cs.princeton.edu/~appel/modern/
14:47:01 <lambdabot> Title: Modern Compiler Implementation
14:47:02 <ibid> well, writing them
14:47:05 <chessguy> aha
14:47:06 <largos> I've found a fair bit of info about doing transparency with a composition manager, but that doesn't fit my needs (as comp. managers don't seem to be stable on non-nvidia systems)
14:47:27 <fasta> largos: Are you talking about compiz?
14:47:37 <largos> fasta: yeah, or xcmpmgr
14:47:38 <ski> (the blue tiger looks cooler)
14:47:50 <largos> fasta: basically, I have an ati card, but I want a transparent batter monitor :)
14:47:52 <fasta> largos: is xcmpmgr better?
14:48:09 <chessguy> so who's going to write "modern compiler implementation in haskell" :)
14:48:10 <largos> fasta: personally, I don't think either is ready for general use
14:48:19 <fasta> largos: I installed compiz and some operations are _really_ stupidly implemented.
14:48:20 <largos> fasta: but I've never used either with an nvidia card
14:48:25 <largos> fasta: yep
14:48:28 <fasta> largos: I have an nvidia card
14:48:40 <fasta> largos: the "cube" effect is really smooth.
14:48:47 <largos> fasta: compiz/XGL seems like a huge hack
14:48:47 <fasta> largos: but resizing a window is painfull.
14:48:54 <largos> fasta: yeah, I like the cube thing
14:48:56 <fasta> largos: yeah, amateurs probably.
14:49:03 <largos> fasta: but I also don't like gnome / kde
14:49:12 <fasta> largos: What do you like?
14:49:23 <largos> fasta: FVWM, and enlightenment
14:49:45 <ski> chessguy : that could be interesting to see
14:49:51 <fasta> largos: enlightenment (17) was unstable, and I thought 16 was "old" for an irrational reason.
14:49:55 <largos> gnome+metacity and kde are just not as configurable as I would like
14:50:09 <dolio> What language does SPJ's book use?
14:50:12 <fasta> largos: FVWM seemed like the stone-age, right?
14:50:16 <largos> fasta: yeah, I"ve been using fvwm for the last year or so, but I keep drooling over e17 shots
14:50:31 <largos> fasta: the typical / default FVWM setup is very "old" looking
14:50:38 <largos> fasta: but you can do a *lot* with it
14:51:01 <fasta> largos: If I ever would do an "alternative" WM, it would be a fully programmable one.
14:51:08 <fasta> largos: ratpoison or something like that.
14:51:18 <largos> fasta: you should consider fvwm
14:51:37 <chessguy> actually, it doesn't look like it would be bad to translate the given SML code into haskell
14:51:41 <fasta> largos: Gnome works good for me now, and it seems to be pretty stable in Debian Unstable.
14:51:51 * dmead just finished his prover functions
14:51:53 <fasta> (yeah, I should use Stable)
14:51:55 * dmead does a little dance
14:52:08 <largos> fasta: http://www.ciscavate.org/data/sshot.jpg
14:52:11 * fasta checks gvwm website again.
14:52:13 <fasta> er f
14:53:18 <fasta> largos: the thing in the background is compiz or equivalent stuff?
14:53:25 <largos> fasta: nope, all fvwm
14:53:36 <fasta> largos: oh, that's actually quite usefull.
14:53:39 <fasta> er useful
14:53:47 <fasta> largos: so you can click on it, and raise it?
14:53:50 <largos> fasta: the background is xplanet, with a dynamic cloud map piped through some rough scripts to make it sepia
14:54:04 <largos> fasta: you're talking about the mini-windows in the top left, right?
14:54:07 <fasta> oh, right sepia. I have no idea what that is.
14:54:09 <largos> fasta: those are just minimized apps
14:54:14 <fasta> largos: right
14:54:39 <largos> fasta: yeah, when you minimize an app it just takes a screenshot of it and uses that as the mini-thumbnail, and then they're made transparent
14:54:40 <chessguy> sepia is what gives it the kind of brownish tint
14:55:01 <largos> yeah, it's like black and white, but with brown added :)
14:55:08 <largos> normally xplanet outputs full color
14:55:17 <largos> but I find that to distracting
14:55:19 <fasta> largos: I think I was confused with another WM.
14:55:26 <fasta> largos: it seems pretty nice.
14:55:27 <fasta> http://www.fvwm.org/screenshots/desktops/Pierre-Eric_Marchandet-1600x1200/screenshot.jpg
14:55:34 <lambdabot> http://tinyurl.com/4zr8a
14:55:53 <chessguy> that looks mac-ish
14:55:54 <largos> yeah, that's fvwm :)
14:56:18 <fasta> largos: does e17 compile from cvs with one command already?
14:56:24 <largos> fasta: no idea
14:56:38 <largos> fasta:  it took me like 4 hours or better to do the e17 install last I tried
14:56:49 <fasta> largos: similar experience here.
14:57:05 <fasta> largos: I don't really see why they do that.
14:57:23 <fasta> largos: if you want developers or users, it should be easy to compile and install.
14:58:02 <largos> fasta: yeah.. it just has a lot of dependencies, and the project is broken up into a lot of stand-alone modules
14:58:20 <ski> chessguy : maybe, if i feel bored sometime, i could start and see how far i'd get
14:58:32 <largos> so you can make use of just some parts of it, like the image viewer, or theme editor if you want.
14:58:41 <largos> but it would be nice to have a unified build script
14:58:51 <fasta> largos: I am sure that anyone who writes a script to install e17 flawlessly, will be placed pretty high at e.g. reddit.
14:59:04 <fasta> I don't care for such things, but some people do.
14:59:10 <largos> heh, yeah
14:59:42 <fasta> I wrote such a script, but the names change sometimes, and I don't feel like maintaining it.
14:59:50 <chessguy> ski, sorry, start what?
15:00:01 <ski> chessguy : translating the SML to Haskell
15:00:08 <chessguy> oh!
15:00:18 <dmead> mmm sml
15:00:25 <dmead> that should take like three seconds
15:00:27 <chessguy> yes, sounds worthwhile
15:00:32 <dmead> hehe
15:00:35 <ski> how does enlightment fit in with say Gnome and KDE .. is it a desktop environment, or just a window manager, or something in between, or other ?
15:00:43 <dmead> it's a WM
15:00:45 <largos> ski: it's a WM
15:00:45 <dmead> dot a DM
15:00:52 <dmead> gnome and kde are DM
15:01:02 <dmead> (s)
15:01:02 <ski> 'DM' = ?
15:01:08 <dmead> desktop managers
15:01:14 <dmead> the window managers just do the window controls
15:01:20 <dmead> like kde has kwin for it's wm
15:01:23 <ski> ok (i thought it was s/manager/environment/ there)
15:01:26 <dmead> and gnome has whatever it's called now
15:01:32 <dmead> hehe
15:01:33 <chessguy> konquerer?
15:01:39 <dmead> konqueror is a shell
15:01:42 <fasta> ski: I thought E17 was a desktop shell.
15:01:51 <chessguy> oy. too many little bits and pieces
15:01:53 <dmead> e17 is a dm i think
15:01:54 <dmead> yea
15:01:58 <dmead> a wm is part of a dm
15:02:07 <largos> dmead: it does window management too.. so it's at least a WM :)
15:02:11 <dmead> yea
15:02:12 <ski> dmead : 'dot' ?
15:02:23 <maskd> enlightenment can be used along with kde/gnome
15:02:24 <largos> dmead: but gnome isn't *really* tied to any one WM
15:02:56 <dmead> yea
15:02:58 <dmead> neither is kde
15:03:17 <largos> *nods*
15:03:19 <ski> but it has a default WM, right ?
15:03:21 <dmead> you used to be able to use enlightement in kde
15:03:22 <dmead> yea
15:03:24 <largos> ski: yeah
15:03:36 <dmead> kde has kwin
15:03:44 <largos> you can also run Enlightenment and just portions of kde / gnome, like the kicker or gnome-panel
15:03:50 <dmead> yeaa
15:04:13 <dmead> have you tried compiz?
15:04:17 <largos> I have
15:04:19 <dmead> slash beryl
15:05:01 <Excedrin> Enlightenment and GNUStep, plus Kcalc and Nautilus makes a nice desktop
15:05:05 <dmead> hmm
15:05:10 <dmead> i just tweak the shit out of kde
15:05:58 <fasta> largos: does fvwm looks nice out of the (Debian) box?
15:07:23 <fasta> largos: Is FVWM-crystal "better"?
15:08:12 <dmead> i read fvwm-crystal is nice
15:08:23 <dmead> you might wanna check out xfce 4.2 as well
15:08:28 <dmead> reminds me of the BeOS gui
15:09:14 <fasta> dmead: I tried xfce 4.X and it seemed a slimmed down Gnome (which it is).
15:09:31 <dmead> yea
15:09:35 <dmead> it's all in gtk+ i think
15:09:39 <fasta> right
15:10:07 <earthy> hm. BeOS was more polished than xfce is though
15:10:12 <dmead> yes
15:11:15 * earthy should dig out his BeBox again...
15:11:20 <earthy> try to get ghc to compile on it :P
15:11:59 <dmead> you know their almost finished openbeos?
15:12:13 <earthy> come again?
15:12:42 <dmead> http://haiku-os.org/screenshots
15:12:44 <lambdabot> Title: R1 Development Branch | Haiku
15:12:46 <dmead> open beos
15:12:53 <dmead> they've been working on it for like 5 years
15:12:58 <dmead> more like 7 i think
15:13:31 <earthy> hm. schweet
15:13:36 <fasta> Is that based on a kind of "new" approach?
15:13:49 <dmead> hm?
15:13:57 <dmead> it's BeOS...
15:13:59 <dmead> it WAS new
15:14:04 <fasta> Or is it just that they think they can make something better with less resources?
15:14:14 <dmead> mmm
15:14:16 <dmead> i guess
15:14:29 <dmead> try using beos sometime
15:14:32 <earthy> x86 however though
15:14:34 <dmead> it's really good
15:14:35 <dmead> http://haiku-os.org/node/15
15:14:37 <lambdabot> Title: Quake 3 | Haiku
15:14:38 <dmead> hot
15:14:38 <dmead> q3...
15:14:42 <jgrimes> dmead: oh wow, BeOS was awesome. I didn't even realize haiku had made so much progress.
15:14:55 <dmead> yea they've been working for a really long time
15:14:59 <earthy> bedtime, but I'm surely going to look into that
15:15:11 <dmead> haiku used to be called openbeos
15:15:15 <dmead> openbeos.org
15:15:17 <dmead> etc
15:15:22 <dmead> but they renamed like 2 years ago
15:15:47 <dmead> one of the devs is called darkwyrum
15:15:56 <jgrimes> have there been any legal issues, with having been bought by palm and all of that?
15:15:59 <dmead> i'm guessing he never told anyone his name cause he's an ex-beos engineer
15:16:17 <dmead> i think they got permission and rights to use a bit of the source code
15:16:28 <jgrimes> oh, thats cool.
15:16:29 <fasta> 1 or 0?
15:16:31 <dmead> but other than that they've totally rewritten the tracker, kernel and shell
15:16:44 <dmead> it's a really good OS
15:16:48 <dmead> too bad the company tanked =/
15:17:07 <dmead> haskell on beos would definatly be a hip platform
15:17:12 <fasta> dmead: good in what way?
15:17:24 <dmead> in how well it performs
15:17:28 <sylvan> What does "R1" stand for in "R1 Development Branch"?
15:17:30 <fasta> dmead: better than Linux?
15:17:37 * sylvan is asking the tough questions
15:17:45 <dmead> yea, it's performance has always outdone linux
15:17:56 <dmead> it's a sort of microkernel design if i remember correctly
15:18:05 <fasta> dmead: then why is it never used for benchmarks?
15:18:22 <fasta> dmead: why does't every server in the world run BeOs?
15:18:30 <fasta> er BeOS
15:18:36 <dmead> well it never had multiuser
15:18:39 <ski> Excedrin : and what is GNUStep ?
15:18:52 <dmead> it was seen as a well engineered replacement to windows
15:18:59 <dmead> but MS cut them out of the market
15:19:03 <ski> (i.e. what kind of thing .. not WM i suppose)
15:19:08 <fasta> dmead: so, you are saying it's better than Linux now is, while it has had a standstill of who knows how many years?
15:19:19 <dmead> it's still ahead IMO
15:19:22 <edwardk> anyone here who can boss lambdabot around?
15:19:28 <ski> dmead : was that GNUStep or NextStep (spelling?) ?
15:19:32 <dmead> the design process for BeOS started in 1994
15:19:41 <dmead> ski: what?
15:19:47 <fasta> dmead: Ok, I thought it was older.
15:19:59 <ski> dmead : oh, sorry, i think i misread you as answering me
15:20:06 <dmead> oh =p
15:20:38 <dmead> i remember reading alot of the design specs for Be back in the day
15:20:45 <sylvan> dmead, Im reading the wikipedia entry and it sounds a bit more lik apple cut them out of the market...
15:20:48 <dmead> they way they do things just make the system respond so fast
15:21:01 <dmead> well
15:21:22 <dmead> theres probably some info there about how toshiba wanted to start selling their machines with beos preinstalled
15:21:37 <dmead> but ms changed the windows liscence to say you can't sell anything other than windows on your machine
15:21:43 <dmead> if you have an OEM liscence
15:21:47 <dmead> so they didn't take the change
15:21:53 <dmead> and pulled out of selling Be
15:22:15 <dmead> i had BeOS R4.5
15:22:18 <jgrimes> that surely wasn't an anti-competitive move. </sarcasm>
15:22:21 <dmead> and the free version of R5
15:22:22 <edwardk> vincenz, dons: anyone here that can get lambdabot to join ##logic?
15:22:27 <dmead> hehe
15:22:55 <dmead> but yea
15:23:00 <dmead> when Be went under
15:23:09 <dmead> they released R5 personal for free
15:23:21 <dmead> and there were distros based on it that got patched for P4 and up
15:23:29 <dmead> so you can still run it if you really want
15:23:39 <dmead> i'll probably try it when haiku released a distro cd
15:30:36 <araujo> haiuku .. mm
15:30:50 <araujo> does it support Haskell?
15:34:57 <dmead> no =/
15:35:02 <dmead> but you could probably get that workin
15:35:03 <dmead> =p
15:35:32 <dmead> bbl
15:37:22 <lispy> "Pay close attention to how your code uses these types, and add type checking as necessary." <-- from a MS guide on transitioning from VB6 to VB.NET, sad isn't it?
15:37:37 <lispy> asking the programmer to add type checking!
15:38:46 <jgrimes> o.o
15:48:33 <dmead> hah
15:48:46 <dmead> it's scary how many people think C# is a good language...
15:49:31 <ski> maybe what is meant is that the programmer should just-in-time (i.e. lazy) add type checking to the compiler for the part of the type system they neeed
15:49:41 <SamB> ski: hah!
15:49:45 <SamB> right
15:49:53 <SamB> as if the compiler was open source!
15:52:53 <ski> of course you'd have to sign a non-disclosure agreement (under pain of serfdom), and sign over all code additions to microsoft
15:53:38 <SamB> signing stuff over is a fairly normal procedure
15:53:47 <SamB> FSF makes you do that too
15:54:09 <SamB> 'course, the FSF doesn't make you sign and NDA
15:54:33 <sylvan> While C# isn't a great language, it's a whole lot better than C++ (especially version 3.0), and in certain circles the best you could hope for is a switch to C#, Haskell is just out of the question...
15:54:38 <lispy> ski: yes, how better to leverage the benefits of stability and scalability your business intelligence needs in order to take the product team to the next level!
15:55:19 <lispy> er what i mean is...this MS marketing drivel is driving me nuts
15:56:49 <ski> Code Production of Users for Make Benifit Glorious $Language Compiler
16:00:18 <dcoutts> largos, there's one missing function I think in Gtk2Hs to be able to do proper transparency
16:00:34 <dcoutts> largos, so it should be doable fairly easyily I reckon.
16:01:31 <dcoutts> largos, I nearly did it for that cairo clock demo, but I didn't have X11 7.0 at the time so I couldn't test the proper transparency
16:01:43 <dcoutts> so if you're keen I can look into binding that
16:02:04 <dcoutts> it does of course require you to be using a composition manager
16:16:58 <largos> dcoutts: I haven't been able to find a comp. mgr that works with my system (ATI video), so I'm probably stuck with "fake" transparency, which seems doable
16:17:29 <dcoutts> largos, really? xcomgr should be fine pretty much any ati card
16:17:33 <largos> dcoutts: I'm just not sure how it's generally done (take a screenshot of some sort, and use that as the background of your app, I'd assume.. but I'm lost on the details
16:17:52 <dcoutts> no idea how to do 'fake' transparency
16:18:05 <dcoutts> real transparency should be easy these days
16:18:14 <largos> dcoutts: huh, I've had horrible luck when I've tried, but I do have hardware acceleration working
16:18:15 <dcoutts> just allocate a RGBA surface
16:18:48 <largos> when I tried xcmpmgr everything was very sluggish and the shadows often were left as artifacts :(
16:19:23 <dcoutts> largos, could try metacity's comp manager
16:19:44 <dcoutts> or what's the derivitive of the novel one ?
16:19:45 <largos> dcoutts: is it tied to metacity? (I really dislike that WM)
16:19:58 <dmead> whats wrong with xcompmgr?
16:20:03 <dcoutts> yeah it's built into metacity
16:20:11 <dmead> you have to turn on a bunch of x extensions for it to work right
16:20:30 <largos> dmead: that's the sort of zoo I'm trying to avoid...
16:20:35 * lispy preferred gnome when they used sawfish
16:20:43 <largos> I only want my desktop background to show through :)
16:20:47 <dmead> largos: it's really not a big deal
16:20:48 <lispy> sawfish was simple and easy to extend via lisp!
16:20:57 <largos> lispy: I wouldn't saya "easy" ;)
16:21:21 <lispy> largos: it's all relative...have you tried to extend enlightenment? ;)
16:21:22 <dmead> http://gentoo-wiki.com/TIP_Xorg_X11_and_Transparency#xcompmgr_and_transset
16:21:27 <lambdabot> http://tinyurl.com/yjnatu
16:21:27 <largos> dmead: that's not been my experience :(
16:21:47 <dmead> look at that wiki
16:21:47 <dmead> xcompmgr does have a memory leak
16:21:50 <largos> heh
16:22:02 <largos> yeah' first thing: "Warning: It's been reported that xcompmgr has memory leak problems. It's encouraged to use built-in composite effects in xfwm and metacity."
16:22:03 <dmead> if you want transparency use xgl or beryl
16:22:15 <largos> dmead: I don't consider xgl an option
16:22:28 <dmead> you don't need xgl anymore to use beryl
16:22:30 <largos> anything that requires me to run a specific wm or desktop environment is out of the question
16:22:44 <largos> I'm not familiar with beryl though.. looking it up
16:22:53 <dmead> well
16:23:05 <dmead> xorg movied the Ailgx code into their codebase
16:23:13 <dmead> and nvidia added a GL extension to their drivers
16:23:28 <dmead> so you can do beryl ( a branch of compiz ) on regular xorg
16:23:41 <dmead> but you need a nvidia card
16:24:26 <largos> I know it's futile, but this is "the zoo" I'm trying to avoid
16:24:30 <dmead> yea
16:24:45 <largos> I'm *not* buying a new video card so my batter monitor will be transparent enough to show my desktop bg
16:24:46 <dmead> if you want good transparency xorg + nvidia + beryl is the easiest way to go
16:24:59 <largos> see, I don't need good transparency :)
16:25:04 <dmead> ah
16:25:24 <largos> I just need a way to get a given rectangle of my desktop bg, and use that to draw the bg. of my app
16:25:44 <largos> good transparency *would* be cool, but it's obviously not there yet
16:25:52 <dmead> oh, it is there
16:26:07 <dmead> but it's not trivial to install
16:26:09 <largos> no, it's not
16:26:40 <dmead> look at my screenshot
16:26:41 <dmead> http://taz.cs.wcupa.edu/~dmead/stuff/q3.png
16:26:44 <largos> you just told me I needed new hardware to do it ;)
16:26:58 <dmead> how do you expect real time texturing to happen?
16:27:56 <lispy> i don't think largos needs real time texturing
16:28:05 <dmead> =p
16:28:20 <largos> <shrug> my video card does fine -- in games it does these sorts of effects
16:29:10 <lispy> at this point if you guys want to keep discussing, it may be kind to move over to #haskell-blah
16:29:22 <largos> it even does this stuff with xgl
16:29:36 <largos> anyway, I'm pretty lagged
16:30:06 <lispy> anyone here familiar with the paper, typing haskell in haskell?
16:30:49 <lispy> or better yet, if i wanted to learn how to implement type checking, what should i read?
16:31:03 <lispy> i have TaPL, but maybe it's not a good intro?
16:32:57 <ski> hm, you should learn to read the type inference rules, if you don't already know that
16:33:22 <lispy> okay, i know a little about that notation, but i don't know it fluently
16:33:36 <ski> http://citeseer.ist.psu.edu/michael95polymorphic.html could maybe help some
16:33:39 <lambdabot> http://tinyurl.com/y7scr5
16:33:40 <lispy> i know that above the bar must be true for below the bar to apply
16:33:59 * ski can't remember how/where he learned what he know about type checking
16:34:44 <lispy> ski: ah, this paper looks neat
16:35:22 <ski> istr it explains some basic issues in a clear (imo) way
16:35:30 <lispy> i'm toying with the idea of adding type inference elisp, which complicates things because i probably can't just reject things which don't type since they may still be valid lisp programs
16:35:47 * ski thinks he mostly learned by osmosis
16:37:26 <ski> istr some tool for PLT Scheme which did something like that
16:37:37 <ski> (maybe it was Mr Flow ?)
16:38:18 <lispy> right, and SBCL uses it to give hints to the optimizer
16:38:30 <lispy> and actually, once in a while it will reject a progrom
16:38:55 <lispy> but that's not common, and usually its non-conformant for some other reason
16:44:05 <lispy> hmm...guess i could help myself at work by making a type checker for vba!
16:49:36 <ski> lispy : hrm, misread 'vba' as 'gba' ..
16:49:41 <ski> (what is 'vba' ?)
16:50:53 <jajs> ski, Visual Basic for Applications ?
16:51:03 <ski> ok
17:07:10 <Renkin> or visual boy advance =)
17:07:20 <Renkin> virtual boy advance, even
17:07:50 <Renkin> oh, no, visual
17:13:39 <dmead> i have a virtual boy
17:13:41 <dmead> *had
17:13:45 <dmead> so much time wasted with warrio...
17:21:40 <dons> moin
17:21:52 <araujo> dons!
17:21:54 <dons> ?users
17:21:55 <lambdabot> Maximum users seen in #haskell: 265, currently: 223 (84.2%), active: 22 (9.9%)
17:22:11 <dons> ?seen lambdabot
17:22:12 <lambdabot> Yes, I'm here. I'm in #ScannedInAvian, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell_ru, #haskell.jp, #haskell.es, #haskell.se, #haskell.it, #haskell-overflow, #haskell-blah
17:22:12 <lambdabot> and #haskell
17:22:25 <dons> ?join ##logic
17:22:28 <dons> edwardk: ok?
17:22:48 <ski> dons : ty
17:23:18 <dons> ski, should it be there permanently?
17:23:27 <ski> (Renkin : aha, that's why i was thinking about gameboy advance ..)
17:23:43 <lispy> dons: yes please
17:23:49 <dons> ok.
17:24:15 <edwardk> dons: yes please
17:24:28 <edwardk> i'll add her to the chanserv's autoop and all that
17:24:44 <dons> autoop? why?
17:25:17 <edwardk> heh, reflex, used to the wild west days of irc =)
17:25:22 <dons> heh
17:25:37 <dons> mm. this thread turned out quite well in the end, http://programming.reddit.com/info/p66e/comments
17:25:40 <lambdabot> Title: Are monads actually used in anything except Haskell ? (reddit.com), http://tinyurl.com/yhg87v
17:25:50 <dons> if the topic is sufficiently hard, you only get good comments it seems
17:26:54 <lispy> dons: corollary to the bikeshed theorem
17:27:16 <lispy> if you ask a sufficiently hard question, only competent people will answer?
17:29:06 <monochrom> Ah, yes, Slashdot proves that everyone is inclined to comment on everything.  OK actually TV shows proved it first.
17:33:40 <dmead> i've found slashdot really boring after reading digg and shoutwire
17:40:33 <dons> lispy: hmm. yes!
17:40:53 <dons> dmead: and digg can be pretty boring compared to programming.reddit.com (sometimes) and LtU (always)
17:41:09 <dons> which is the Lispy Corollary, i think, at play
17:41:32 <SamB> you mean the Nuclear Reactor corollary
17:41:33 <dmead> LtU?
17:41:47 <SamB> right?
17:41:51 <dons> yep
17:41:58 <dons> ?google lambda the ultimate
17:42:01 <lambdabot> http://lambda-the-ultimate.org/
17:42:01 <lambdabot> Title: Lambda the Ultimate | Programming Languages Weblog
17:42:27 <dons> still, i think a better LtU could be created if the barrier to joining wasn't so high, like reddit, but was a little higher than reddit.
17:42:46 <dons> i.e. a CAPTCHA for dumb people: you have to fix a type error before you can vote or submit
17:42:54 <dons> so you'd get the dynamism of reddit, with the quality of LtU
17:42:55 <dmead> ahh
17:43:00 <dons> and then... $$profit!
17:43:06 <SamB> haha
17:43:06 <dmead> profit!!
17:45:05 <dmead> bbl
17:45:12 <dmead> :>
17:54:25 <dons> Cale: I think the copyright here needs to be fixed? http://haskell.org/haskellwiki/New_monads/MonadUnique
17:54:28 <lambdabot> Title: New monads/MonadUnique - HaskellWiki, http://tinyurl.com/yeasl6
17:56:45 <ski> @vixen thank you!
17:56:45 <lambdabot> my pleasure
18:02:07 <Dylan> @where aam
18:02:07 <lambdabot> http://www.nomaware.com/monads/
18:02:18 <dons> hmmm. this looks like a nice puzzle for someone looking for something to hack in haskell, http://haskell.org/haskellwiki/Haskell_Quiz/Bytecode_Compiler
18:02:21 <lambdabot> Title: Haskell Quiz/Bytecode Compiler - HaskellWiki, http://tinyurl.com/y7a8pt
18:02:32 <dons> should be possibly to get a _really_ nice soln
18:07:38 <Botty> dons - looks fun, I'll hack up a newbie soln
18:18:41 <lispy> why do they say the example Compiler.compile('3+2') has a sub optimal soltion?  Because it didn't do constant folding?
18:35:24 <Botty> lispy - it didn't use the smaller CONST
18:36:04 <Botty> there's a 15bit one and a 31 bit one. no, i do not know where the missing bit went
18:36:38 <Botty> the whole thing is pretty rediculous because you can reduce any program to 3 to 5 bytes
18:39:09 <SamB> Botty: missing bit?
18:39:21 <lispy> Botty: by doing constant folding?
18:39:43 <lispy> probably those missing bits happen because ruby has some tagged rep for numbers? (just guessing)
18:39:51 <SamB> heh
18:39:57 <SamB> doubt it
18:40:06 <SamB> that would *not* explain the 15-bit one
18:40:15 <Botty> could be, or this guy just doesn't know how to specify signed values
18:41:03 <Botty> lispy - oh, i assumed constant folding was like preprocessing pure functions
18:41:26 <SamB> it *is*
18:42:06 <Botty> of which the entire bytecode is pure with no interface to the outside, so really the program can be reduced to the constant solution
18:42:16 <lispy> yeah
18:43:28 <Botty> so doing optimizations on such a thing is pretty rediculous :) I suppose just do things that could be applied to any function (pure or nonpure), and language specific things (CONST, LCONST)
18:44:05 <SamB> well, you might need to inline things to get constant folding to work right, depending on your strategy
18:45:58 <syntaxfree> I'm reading about hungarian notation.
18:46:15 <syntaxfree> that's hysterical. Couldn't they just cook up separate syntax for data constructors?
18:46:33 <Adamant> hungarian notation has to drive Haskellers up a wall.
18:46:36 <Botty> lol
18:47:02 <syntaxfree> it's more pathetic than annoying. they're mixing two separate concepts. Or am I stupid enough that I don't see the genius behind this?
18:50:54 <syntaxfree> I wonder why Scheme never became popular.
18:51:10 <syntaxfree> it's a standard Lisp. Lisp does things better than C or Pascal.
18:53:39 <dons> too small?
18:54:03 <SamB_XP> no #ifdefs?
18:54:03 <dons> lack of monads? ;)
18:54:20 <dolio> Yeah, that's definitely it.
18:54:22 <jgrimes> yeah, it was definitely lack of monads.
18:54:32 <dons> schemes rather popular in the US , or has been, for teaching CS theory.
18:54:46 <SamB_XP> oh that totally explains why Python and Perl and Ruby are more popular
18:54:48 <dons> it fills the same role haskell does in the uk and europe
18:54:57 <SamB_XP> does not!
18:55:01 <SamB_XP> it is uglier
18:55:08 <SamB_XP> and less fun
18:55:12 <syntaxfree> Python is Lispish.
18:55:37 <dons> maybe its "just another lisp". so didn't distinguish itself in the market enough
18:55:39 <SamB_XP> Python *has* been called a 1-lisp without all the silly parentheses
18:55:51 <jgrimes> did they ever add the ability to have closures with more than one line in python?
18:55:54 <SamB_XP> or, at least a 1-lisp
18:55:56 <jdev> Except for the expression/statement stuff that makes lambda less than useful.
18:55:59 <syntaxfree> Ruby is unreadable to me. Does 5.upto6{do this}  mean "5" is an object?
18:56:00 <dons> where we at least have syntax, types and monads to help differentiate our brand
18:56:02 <SamB_XP> jdev: there is that
18:56:12 <syntaxfree> Well, Lisp doesn't encourage recursion and closures.
18:56:12 <SamB_XP> but you can just write a "def" anyway
18:56:13 <dolio> Yes, 5 is an object.
18:56:28 <dons> What's scheme: another lisp. What's Haskell: some hard language with monads and types
18:56:34 <syntaxfree> why do I want 5 to be an object?
18:56:57 <dolio> Because you can do cute things like 5.time { do stuff }
18:57:01 <dolio> times, even.
18:57:03 <SamB_XP> syntaxfree: so you could pass 5.__add__ to things!
18:57:22 <dolio> You can even do crazy things like add methods to it.
18:57:22 <dons> Getting your language used is as much marketing as technological superiority, after all.
18:57:26 <SamB_XP> that is a facetious Python example
18:57:32 <dons> as the ruby guys know
18:57:37 <syntaxfree> of the languages a typical CS undergrad might hear of, Scheme/Lisp is the closest to Haskell, isn't?
18:57:39 <SamB_XP> it isn't even valid syntax AFAIK
18:57:40 <dolio> Or change the definition of addition on integers.
18:57:49 <SamB_XP> I think you have to do (5).__add__
18:57:54 <dons> syntaxfree: its close, yes. unless they do ML or OCaml
18:58:10 <syntaxfree> ML and Ocaml are research-y languages already, aren't they?
18:58:33 <dons> yeah, but also taught to undergrads, well, SML anyway (see CMU)
18:58:34 <jdev> Semi-facetious.  I've seen stuff like map((1).__lshift__, range(0,9)) in actual Python code.
18:58:45 <dons> I suspect OCaml is widely taught in .fr
18:58:54 <syntaxfree> I've heard of advanced undergrads doing some basic research in MLs.
18:58:55 <Excedrin> SML and Ocaml are pretty practical imho
18:58:56 <SamB_XP> jdev: I knew it might actually be done ;-)
18:59:21 <syntaxfree> but it's not something you'd likely to find in job-market-oriented programs.
18:59:39 <dons> there's a few jobs in OCaml out there.
18:59:43 <dons> at the top end
18:59:46 <dolio> I suppose the reason you want 5 to be an object in ruby is the same reason as smalltalk: everything is framed in terms of message passing/method calls. There are no top level functions.
18:59:50 <dons> also haskell, if you look in the right places
18:59:52 <dons> and ML.
19:00:01 <dons> syntaxfree: but yes. right
19:00:10 <Excedrin> "job-market-oriented programs" what's that mean? DeVry?
19:00:14 <dons> at training colleges i guess its java and C++ or some such
19:00:22 <syntaxfree> dons: I wrote to a company hiring for Ocaml asking if they'd consider a brazilian economist who knows Haskell.
19:00:32 <dons> heh yeah? hear back?
19:00:33 <syntaxfree> They even brought up a visa program and all.
19:00:38 <dons> cool
19:00:50 <syntaxfree> They seemed interested. There must be *really* a shortage of FP people out there.
19:01:00 <dons> most of the good ones already have jobs
19:01:01 <SamB_XP> wow
19:01:13 <SamB_XP> what country was this? the US?
19:01:18 <dons> MS seems to snap up the really good ones pretty quick too
19:01:18 <syntaxfree> Anyway, I'm not ready to drop out of grad school and leave my current relationship.
19:01:30 <dons> exactly how many ex-haskellers (or current) work at microsoft now?
19:01:35 <syntaxfree> I'm really serious about this relationship. Serious enough that I can't' fathom living outside of it.
19:01:54 <syntaxfree> SamB: yes, US.
19:02:04 <dons> jane street?
19:02:07 <dons> or somewhere else?
19:02:20 <syntaxfree> dons: I'll try to find the emails. Just a min.
19:02:21 <Adamant> there's a simple reason Scheme and CL never caught on - most imperative/OO programmers can't handle (Lots (of ())
19:02:22 <SamB_XP> is there a haskell-jobs@ list?
19:02:33 <dons> yeah, so syntax too.
19:02:35 <dons> syntaxfree: that's haskell@
19:02:45 <dons> and I try to also put them in the hwn.
19:02:53 <syntaxfree> yes, jane street.
19:02:58 <SamB_XP> dons: I'm not syntaxfree ...
19:03:09 <dons> yeah, so i can see why Haskell + economist would be good there.
19:03:09 <SamB_XP> how much traffic does haskell@ get?
19:03:16 <dons> small. you're not on it?
19:03:17 <Excedrin> Adamant: many imperative/OO programmers use CL
19:03:28 <syntaxfree> There are two different reasons to use Lisp.
19:03:30 <Adamant> Excedrin, I should say the conventional ones
19:03:32 <syntaxfree> One is FP. The other is macros.
19:03:38 <dons> 3. Emacs
19:04:07 <syntaxfree> As far as I understood, the essence of Lisp is bottom-up programming. Both closures and macros are paths to that.
19:04:07 <dons> I think *everyone* in this channel should be on haskell@, if you're not already.
19:04:15 <dons> that's where all the jobs, meeting, projects get announced
19:04:15 <Excedrin> dons: how is yi coming? do you still work on it? do you use it as your daily editor?
19:04:19 <syntaxfree> I'm on haskell-cafe, but I don't read it much.
19:04:24 <SamB_XP> dons: smaller than libraries@?
19:04:27 <syntaxfree> It gets filtered out into a folder.
19:04:40 <syntaxfree> How heavy-traffic is hakell@?
19:04:41 <dons> i'm not working on it. it's likely to remain a vim clone, it may get syntax highlighting finished after i'm done my phd.
19:04:48 <dons> syntaxfree: much smaller
19:04:51 <dons> grr.
19:04:54 <SamB_XP> heh
19:04:55 <dons> SamB_XP: :)
19:04:58 <dons> tab tab!
19:05:03 <dolio> haskell@ probably gets like 2 mails a day average.
19:05:10 <dons> there traffic is listed on gmane
19:05:22 <SamB_XP> dons: you don't have to worry about getting me straight with SamB, I've set this one up to highlight when you say SamB too...
19:05:42 <SamB_XP> and don't bother giving me the screen(1) lecture
19:05:52 <dons> oh, i just let my irssi tab out the names. so S\t -> ...
19:06:03 <dons> now, you know about screen(1) right?
19:06:10 <dons> that's why you never see dons' or dons''
19:06:11 <SamB_XP> at this point it would be irssi that I need to learn
19:06:36 <dons> that, and also i have had my clones executed
19:06:48 <dons> so you won't be seeing dons' till he regrows in his vat
19:07:42 <SamB_XP> I thought those things were outlawed after the clone wars!
19:07:46 <dons> comparative traffic: http://dir.gmane.org/gmane.comp.lang.haskell.cafe, http://dir.gmane.org/gmane.comp.lang.haskell.general, http://dir.gmane.org/gmane.comp.lang.haskell.libraries
19:07:50 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/ykhs86
19:07:54 <dons> note the growth in libraries and cafe talk!
19:08:00 <syntaxfree> 12:01 AM  Adamant: there's a simple reason Scheme and CL never caught on - most imperative/OO programmers can't handle (Lots (of ())
19:08:12 <syntaxfree> but they can handle Dots.lots_of.new() ?
19:08:29 <dons> hmm. this new libraries process seems to be producing more code
19:08:43 <dons> people know now exactly what they have to do to turn their ideas into real library features
19:08:47 <dons> so maybe that's the reason
19:09:31 <SamB_XP> what happened in '03?
19:09:56 <dolio> I can't imagine that scares off C++ people.
19:10:11 <dons> dolio: oh, i just worked out who "doliorules" on reddit is
19:10:22 <dolio> With their foo<bar, baz<quux> >::std_blorf
19:10:42 <dolio> Yeah, I signed up as dolio at first, but it automatically logged me out, and I lost my password.
19:10:57 <dons> doh
19:10:58 <SamB_XP> okay, I'm attempting to subscribe to haskell@
19:11:05 <dons> good!
19:11:24 <dolio> And apparently their Web2.0 ajax login avoids my browser's password saving feature.
19:11:27 <SamB_XP> oh cool, it works if you just send a message with subject "subscribe" to haskell-request@
19:11:39 <dons> there's the web interface too
19:11:50 <SamB_XP> but this way is easier!
19:11:58 <SamB_XP> not so much clicking
19:12:21 <SamB_XP> look, see, I'm done already
19:12:23 <Adamant> syntaxfree, don't ask me why, but that is easier for most programmers to parse. not me, of course.
19:12:28 <dons> click? you use w3m don't you? have i told you about screen yet?
19:12:54 <SamB_XP> agggh
19:13:00 <dons> mm! "Wed Nov 1 08:43:29 PST 2006. Simon Peyton Jones. Major overhaul of the Simplifier."
19:13:08 <SamB_XP> yeah, I grabbed that one
19:13:08 <dons> dcoutts: ^^ we better check this out some time
19:13:20 <SamB_XP> I'm hoping it goes nicely with my changes ;-)
19:13:38 <jgrimes> the simplifier?
19:13:47 <dons> ghc's big inliner/optimiser/rule firer
19:13:50 <SamB> as well as the one that fixes the worker/wrapper code
19:13:51 <jgrimes> ah
19:13:52 <jgrimes> ok
19:14:02 <dons> ?google secrets of the ghc inliner
19:14:06 <lambdabot> http://research.microsoft.com/~simonpj/Papers/inlining/
19:14:06 <lambdabot> Title: Simon Peyton Jones: papers
19:14:07 <jgrimes> I was going to ask if thats what handled rules.
19:14:14 <jgrimes> but it seems it handles much more than that
19:14:15 <jgrimes> :)
19:14:40 <SamB> yes, apparantly SPJ went and simplified it
19:14:44 <dons> we've been really stepping on its neck recently, with all the rules hacking, so its good to see its getting cleaned up.
19:14:56 <dons> its been improving a lot (particuarly just before 6.6 came out)
19:15:17 <dons> we had code that reduces in size by 2/3rds, as a result of a better simplifier, coming out  of Data.ByteString.
19:15:18 <SamB> though unfortunately last I knew it was running out of gas... or something like that...
19:20:39 <lispy> heh, i posted to reddit and my comment already has 2 points and i wasn't even finished fixing typos :)
19:20:59 <syntaxfree> how ironic.
19:21:12 <syntaxfree> Microsoft's hiring all the smart Haskell types.
19:21:23 <syntaxfree> On the other hand, Linux represents a lot of Unix/C radicalism.
19:21:42 <syntaxfree> Linux being a conservative force.
19:23:16 <Adamant> is Microsoft actually doing anything with them though, besides LINQ?
19:23:38 <Adamant> I get the impression MS Research is not followed very closely by most MS programmers.
19:23:55 <syntaxfree> what about F#?
19:24:24 <Adamant> F# is neat, but it doesn't really do much for the guy in the trenches.
19:25:03 <jgrimes> won't it run on .NET, too?
19:25:08 <dons> Adamant: also lambdas for excel
19:25:19 <dons> i imagine there are others. the xml guys (like Lammel) are doing lots of things
19:25:39 <Adamant> LINQ is neat and definitely Haskell
19:26:01 <lispy> if i could swap out VBA for, say, haskell, then the guys like me in the trenches would rejoice
19:26:38 <Adamant> you would. 99% of VBA programmers would disagree with you
19:26:45 <syntaxfree> Linq is actually Haskell?
19:26:46 <lispy> i've been looking at it, but it looks like my only hope would be to have the VBA call out to something external, whether by COM, sockets or whatever...
19:27:06 <Adamant> and of course, 85% of all statistics are made up on the spot
19:27:09 <lispy> Adamant: i mean, if it were easier to swap in X for VBA at the programmers choice
19:27:18 <Adamant> ah, now, that would be nice
19:27:23 <jgrimes> Adamant, of course, and only 2.1% of statistics are presented with citations.
19:27:33 <dons> do you have a ref for that?
19:27:37 <undated> Microsoft seems to want to supplant VBA with .NET integration.
19:27:40 <Adamant> IORef
19:27:46 <lispy> Adamant: there is VSTO which lets you use anything VS can handle as the extension language for Office, but the problem is that it's beyond the budget at my company to get it
19:27:54 <undated> While leaving VBA itself mostly alone for backwards-compatibility.
19:28:08 <syntaxfree> how is LINQ related to Haskell again?
19:28:20 <Adamant> syntaxfree, it uses monads IIRC
19:28:32 <lispy> undated: yeah, i want VSTO, but it's $700-$1000 for a copy of VSTO
19:28:52 <lispy> if i could use VB.NET or C# instead of VBA i would be much happier
19:29:01 <undated> It's probably too complicated/heavy too for what most people use VBA for anyway.
19:29:09 <syntaxfree> Adamant: oh?
19:29:25 <Dylan> dons: how did you handle SIGINT with Curses?
19:29:58 <Adamant> syntaxfree, there was something posted that today earlier in the channel, IIRC. either that or I read it on reddit
19:30:11 <Dylan> dons: it seems the signal doesn't stop the program for several seconds after it's received.
19:30:33 <Adamant> *about that
19:31:14 <syntaxfree> VB will have monad comprehensions and we don't ! !
19:31:38 <syntaxfree> (according to Erik Meijer)
19:32:16 <dons> Dylan: hmm. should stop immediately. i've not seen any delay
19:32:30 <dons> delivered via ^C ?
19:32:34 <Dylan> dons: I wonder if it's some magic slang is doing.
19:32:34 <dons> or via kill ?
19:32:38 <Dylan> dons: yes, with ^C
19:32:50 <dons> then it could be the char handling routines
19:33:01 <Dylan> (but the user can change that when s/he calls Slang.init_tty
19:33:14 <dons> sounds like a slang feature of some kind though
19:33:27 <dons> check what happens with kill -KILL
19:33:44 <dons> and you'll know whether its the char input handling , or the sig handers themselves
19:34:03 <Dylan> instantly killed
19:34:03 <dons> syntaxfree: yeah. i know!
19:34:23 <syntaxfree> Bring MOnad Comprehensions back!
19:34:28 <dons> +1 !!
19:34:46 <Dylan> dons: aha! Slang I think installs a SIGINT handler
19:34:52 <Dylan> kill -INT also delays
19:35:02 <dons> haskell must always be the source of the most powerful language features
19:35:13 <dons> otherwise we'll concept-rot, like lisp.
19:35:20 <dons> so bring back monad comprehensions!
19:36:07 <Pete_I> concept rot?
19:36:47 <dons> yeah, just made it up :) the idea is that if you don't support the latest language research ,you're language can't be used for the generation of research built on top of the new features. so the language gets left behind since its not expressive or powerful enough for the new ideas
19:37:06 <dons> i.e. say ocaml without typeclasses, or lisp without static typing. they miss out on a lot of things
19:37:19 <dons> haskell needs associated types to build on the ML functor work, for the same reason
19:37:51 <dons> or just about every language lacking typeclasses and good syntax, can't support monads well enough to be useful
19:37:55 <dons> that's concept rot
19:38:21 <dons> so, if the Next Big Thing happens to be built on top of monad comprehensions... well, we better have them.
19:38:33 <dons> (have them back)
19:38:52 <dons> otherwise people who want the Next big Thing will use some other language
19:38:56 <SamB_XP> does anyone *else* have them?
19:39:05 <dons> LINQ :)
19:39:16 <syntaxfree> which means c# and vb!
19:39:39 <syntaxfree> quick question. Let's say I have a list with N elements. N!!a should be faster than N!!b if a< b, right?
19:39:41 <dons> right. so if you want to port that to some other language, better have monad comprehensions
19:39:56 <ski> <edwardk> simon marlow told me i could add monad comprehensions back in =)
19:40:07 <dons> right.
19:40:15 <SamB_XP> with a -f flag, I hope?
19:40:15 <dons> i'm thinking we should try to get this done by the end of the year
19:40:18 <edwardk> yeah
19:40:20 <Dylan> dons: I wonder, should I bother using slang's keymap features or just the low-level character reading interface?
19:40:21 <dons> sounds like a good holiday coding patch
19:40:30 <SamB_XP> I wouldn't want to have those when I wasn't expecting them
19:40:33 <dons> Dylan: hmm. can you get raw input and add your own layer?
19:40:41 <dons> -fmonad-comprehensions
19:40:43 <edwardk> i just haven't had time to work on the idea since the ICFP coz of my thesis and such
19:40:46 <edwardk> dons: yeah
19:40:53 <SamB_XP> dons: yes, that would be the obvious flag
19:40:55 <dons> and then if they're good, they get into haskell''
19:40:56 <dons> or some such
19:41:00 <edwardk> heh
19:41:04 <dons> but we won't know unless we have them
19:41:13 <Dylan> dons: yes, slang has two layers. One returns chars, the other returns ints, and values > 255 are for special character things like Backspace or Enter
19:41:26 <Pupeno> Hello.
19:41:48 <SamB_XP> hello!
19:41:49 <Dylan> dons: I can make both available, but I suppose keymap lexing would be better.
19:41:50 <Pupeno> In this code: apply func args = maybe (Bool False) ($ args) (lookup func primitives), what does ($ args) mean ?
19:42:03 <dons> that's not code: (Bool False)
19:42:14 <SamB_XP> dons: it *could*
19:42:16 <SamB_XP> er. could be
19:42:19 <Pupeno> dons: what ?
19:42:22 <dons> Pupeno: it applies the args value to each element of the list.
19:42:24 <SamB_XP> maybe it is a LISP interpreter
19:42:32 <SamB_XP> with data Duck = Bool Bool | ...
19:42:33 <dons> > map ($ 4) [(+1), (*2)]
19:42:35 <lambdabot>  [5,8]
19:42:39 <Pupeno> SamB_XP: heh, it is.
19:43:02 <dons> so its applying args to the list of functoins returned by the lookup
19:43:03 <dons> p
19:43:06 <dons> returning a list of results
19:43:11 <ski> isn
19:43:17 <ski> 't that 'swing map' ?
19:44:15 <ski> Pupeno : '($ args)' means same as '\f -> f args'
19:44:26 <dons> ?pl \f -> f args
19:44:26 <lambdabot> ($ args)
19:44:58 <ski> or, if you will '\f -> f $ args'
19:46:49 <SamB_XP> dons: now go over "maybe"
19:47:20 <ski> @. djinn type maybe
19:47:22 <lambdabot> f a b c =
19:47:22 <lambdabot>   case c of
19:47:22 <lambdabot>   Nothing -> a
19:47:22 <lambdabot>   Just d -> b d
19:47:47 * Dylan sleeps
19:48:01 <SamB_XP> hmm, that could be done much more prettily!
19:48:44 <dons> yeah, the multi spaces are collapsed
19:48:50 <dons> needs to avoid the whitespace filter
19:54:20 <dino-> Hello.
19:54:56 <jgrimes> dino-, hello. :)
19:55:59 <syntaxfree> http://c2.com/cgi/wiki?FunctionalProgrammingInCpp
19:56:03 <lambdabot> Title: Functional Programming In Cpp, http://tinyurl.com/scu82
19:56:03 <dino-> jgrimes: Hey, getting cold earlier this year in the Raleigh area.
19:56:27 <jgrimes> dino-, yeah, except that one day it was 75 for some reason :p
19:56:39 <dino-> Oh yeah, middle of last week. crazy
19:56:54 <jdev> Oh, I thought they meant the C PreProcessor.
19:58:01 <SamB_XP> I doubt if anyone understands the C PreProcessor well enough to know if that is even possible
19:58:22 <SamB_XP> Woo! WcDonalds sighting!
19:58:37 <SamB_XP> Ranma 1x06...
20:00:32 <dolio> Are they drinking Pepmi?
20:00:42 <dons> mmm http://ropas.snu.ac.kr/~kwang/paper/06-jfp-yi.pdf Proof-directed debugging
20:00:43 <dino-> I've got a function that :: IO Bool and I want to replicate a list of some number of these results..
20:00:47 <lambdabot> http://tinyurl.com/y64coy
20:00:51 <dino-> Having trouble figuring out how to work liftM into this.
20:01:24 <dons> ?type replicateM
20:01:26 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
20:01:36 <dino-> :o
20:01:39 <dons> ?type replicateM 10 (return True :: IO Bool)
20:01:39 <SamB_XP> the soda cups appear to be without identifying marks
20:01:41 <lambdabot> IO [Bool]
20:01:45 <dons> dino-: ?
20:01:58 <dolio> Are there any functional programming features that were intentionally added to C++?
20:02:02 <SamB_XP> well, I mean, they have yellow, green, and red stripes on them, I think...
20:02:02 <dino-> That's what I needed.
20:02:08 <dons> dolio: closures are to be added
20:02:22 <dons> ?google closures added to c++ site:sequence.complete.org
20:02:25 <lambdabot> http://sequence.complete.org/hwn
20:02:41 <dolio> As opposed to the template system accidentally allowing people to make ridiculous 3rd party libraries that add them.
20:02:43 <dons> ther'es also monads, as a library. but they will induce nausea and vomiting
20:02:48 <dolio> Yeah, but closures aren't there yet. :)
20:03:05 <dons> right. C++ is lagging behind in the language feature set
20:03:18 <Botty> is it possible to have a single line caseof with semicolons?
20:03:32 <dons> yes
20:03:38 <Botty> cool
20:03:48 <dons> > case 1+2 of 1 -> True ; 2 => False ; 3 -> error "sure"
20:03:49 <lambdabot>  Parse error
20:03:54 <dolio> I mean, I doubt that when Stroustrup and company were designing the template system, they were thinking, "This will allow people to make a library that provides closures."
20:03:57 <dino-> dons: Thank you.
20:04:00 <dons> > case 1+2 of 1 -> True ; 2 -> False ; 3 -> error "sure"
20:04:01 <lambdabot>  Exception: sure
20:04:02 <sjanssen> dolio: functions objects are like a crappy version of functional programming
20:04:09 <Botty> dons - whoah, 16 seconds for that bit of haskell
20:04:16 <Botty> :)
20:04:20 <dons> too slow!
20:04:20 <SamB_XP> oh, and the bag has the same stripes anyway
20:04:46 <sjanssen> dolio: and there are a couple of composition function objects
20:04:50 <dons> i have a theory that lambdabot's eval system is driving improvements in haskell conciseness and brevity
20:05:07 <dons> as we get used to using (-> a), pointfree and things like fmap and `on` for shrinking code size
20:05:20 <dolio> Hmm.
20:05:20 <dons> i susecpt that there aren't very good irc/online java eval bots.
20:05:25 <chessguy> ?type (on)
20:05:26 <lambdabot> Not in scope: `on'
20:05:31 <dons> too cutting edge :)
20:05:35 <lispy> dons: the idea is absurb for java
20:05:36 <dons> its only on the libraries@ mailing list atm
20:05:52 <dons> is that a cross between absurd and abused?
20:06:02 <dons> java is absurb!
20:06:04 <lispy> dons: no one wants to write public class IrcExample { public static void main(....
20:06:12 <lispy> heh
20:06:21 <lispy> absurb...totally absurb
20:07:04 <dons> yeah, so the one line restriction drives us to find ways to shrink code size and increase information density in the code
20:07:13 <dons> i certainly use more pointfree style than i used to
20:07:20 <lispy> > public class IrcExample { public static  void main(String[] args) { System.out.println("Hello, #haskell!"); }}
20:07:21 <lambdabot>  Parse error
20:07:24 <dons> its a kind of natural selection against verbosity, irc-based eval
20:07:49 <dons> the other major tool is @pl
20:07:59 <dons> which showed us the *true way* towards a lot of concepts that were a bit hard
20:08:00 <lispy> ?pl public class IrcExample { public static  void main(String[] args) { System.out.println("Hello, #haskell!"); }}
20:08:01 <lambdabot> (line 1, column 25):
20:08:01 <lambdabot> unexpected "{"
20:08:01 <lambdabot> expecting variable, "(", operator or end of input
20:08:08 <dons> like arrows for tuple hacking, or esp. (-> a) monad
20:08:15 <dons> heh
20:08:16 <lispy> ya
20:08:39 <lispy> ?pl System.out.println("Hello, #haskell!")
20:08:40 <lambdabot> System . out . println "Hello, #haskell!"
20:10:35 <lispy> i guess java is as compact as it gets
20:10:44 <dolio> What's on do again? It's like comparing, right?
20:11:14 <lispy> on is weird
20:11:27 <dolio> Where is it?
20:11:36 <SamB_XP> libraries@
20:11:46 <lispy> (*) `on` f = \x y -> f x * f y
20:12:08 <lispy> i see that in one email about on
20:12:23 <dolio> Ah, yeah, that's what I was thinking.
20:12:24 <dons> Igloo: around?
20:12:28 <dolio> Did it not make it into 6.6?
20:12:30 <lispy> g `on` f = \x y -> f x `g` f y
20:12:31 <SamB_XP> I think someone maybe once wrote
20:12:39 <SamB_XP> (*) `on` f = \x y -> f x * f x
20:12:42 <dons> dolio: yep. its a generalise comparing/equating
20:12:57 <dons> the Idiom /Applicative stuff also will shrink code size
20:13:04 <dons> hmm. we'll need to update @pl to use these new things
20:13:19 <Igloo> dons: Only if it's quick
20:13:28 <SamB_XP> @pl f . fix . const . g
20:13:29 <lambdabot> f . fix . const . g
20:13:40 <SamB_XP> dons: also, it won't handle *that*
20:13:41 <dons> Igloo: i'm going to have to book plane tickets for PADL in the next week or two
20:13:47 <SamB_XP> I don't know how to see why :-(
20:13:50 <dons> any word on the oxford infrastructure hackathon?
20:13:52 <lispy> ?let on g f = \x y -> g (f x) (f y)
20:13:53 <dolio> Yeah, that'll prevent bloggers from complaining about (. fst) . compare . fst. :)
20:13:54 <lambdabot> Defined.
20:13:55 <dons> will we go ahead with ti?
20:13:58 <SamB_XP> not enough Show instances in that module
20:14:21 <Igloo> Ah, I'll have to check with dons and also check dates of other things. I'll try to do that this weekend
20:14:28 <dons> check with dcoutts
20:14:33 <dons> since i can check with dons today
20:14:54 <dons> either way, i might just come and visit you guys anyway
20:14:58 <Igloo> Nah, dcoutts will do what we tell him. It's dons who's the fussy one.
20:15:01 <lispy> > (*) `L.on` (+1) $ 1 2
20:15:02 <lambdabot>  add an instance declaration for (Num (t -> a))
20:15:04 <dons> ah ok.
20:15:09 <SamB_XP> Igloo: dons is right here though
20:15:11 <lispy> > ((*) `L.on` (+1)) 1 2
20:15:13 <lambdabot>  6
20:15:22 <SamB_XP> Igloo: and you are talking to him
20:15:38 <SamB_XP> in case you somehow didn't notice
20:15:43 <dolio> > groupBy ((==) `L.on` isSpace) "This is a sentence."
20:15:44 <lambdabot>  ["This"," ","is"," ","a"," ","sentence."]
20:16:10 <Igloo> Anyway, sleep time! 'night
20:16:18 <dons> night!
20:17:15 <lispy> > groupBy isSpace "This is a sentence."
20:17:16 <lambdabot>    Expecting a function type, but found `Bool'
20:17:16 <lambdabot>    Expected type: Char ->...
20:17:20 <ski> @type L.on
20:17:21 <lambdabot> Couldn't find qualified module.
20:17:32 <lispy> ?type groupBy
20:17:34 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
20:17:47 <dons> ski, yeah, its not exported to ghci (for @type)
20:17:50 <dons> could be done though...
20:18:00 <dons> ah, though qualified names hmm.
20:18:05 <dons> yeah, no, could still be done
20:18:25 <dons> oh, hmm. is "yeah, no" an aussie-ism?
20:18:44 <SamB_XP> I dunno.
20:18:45 * Korollary wonders what the percentage of ">" commands to lambdabot typecheck.
20:18:47 <SamB_XP> ask an aussian.
20:18:52 <SamB_XP> it might be a donsism
20:19:05 <sjanssen> what does "yeah, no" mean?
20:19:09 <lispy> Korollary: for me it's gotta be like 1/10
20:19:21 <dons> it means "yes", but in a polite way
20:19:34 <lispy> oh, like "yeah not really..."
20:19:43 <ski> 'sequence' should use 'Applicative'
20:19:53 * dons tries to find a reference
20:20:33 <SamB_XP> @google australian cultural assumptions
20:20:37 <lambdabot> http://www.ozemail.com.au/~macinnis/ozkulcha.htm
20:20:38 <lambdabot> Title: Australian culture, customs and lifestyle <META Name="description" Content="Aust ...
20:20:45 <SamB_XP> @google australian cultural assumptions wiki
20:20:47 <lambdabot> http://en.wikipedia.org/wiki/Halloween
20:20:51 <SamB_XP> hah
20:20:53 <lispy> hah
20:21:04 <SamB_XP> halloween!
20:21:09 <dons> ah, there's a paper ""Yeah-no he's a good kid: A discourse analysis of yeah-no in Australian English"
20:21:51 <dons> oh, even online, http://taylorandfrancis.metapress.com/index/ACJN16E8RV7J7RW7.pdf
20:21:56 <lambdabot> http://tinyurl.com/ubt55
20:22:05 <dons> maybe ...
20:22:19 <SamB_XP> is that one of those idiomatic phrases -- you know, the ones that if you say you might sound like some kind of an idiom to people of other cultures?
20:22:47 <lispy> SamB_XP: like, "that takes the cake" ?
20:23:00 <ski> return :: Idiom i => a -> i a
20:23:04 <SamB_XP> that comes from the cakewalk, right?
20:23:06 <dons> "Yeah-no in Australian English is a relatively new marker which serves a number of functions, including discourse cohesion, the pragmatic functions of hedging and face-saving, and assent and dissent."
20:23:37 <dons> "the peak of yeah-no production occurs among speakers aged 35-49 years"
20:23:45 <SamB_XP> lispy: do you get the joke about "some kind of an idiom"?
20:23:54 <lispy> SamB_XP: no
20:24:08 <SamB_XP> that is a "wallyism"
20:24:17 <lispy> wally?
20:24:21 <lispy> like walmart?
20:24:37 <SamB_XP> my mom's friend named wally has said a number of goofy things...
20:24:52 <lispy> oh, i'm not expected to know wally :)
20:25:00 <SamB_XP> like "some kind of an idiom" instead of "some kind of an idiot", I think.
20:25:17 <SamB_XP> or "Jabba the Hunn" for the big slug in Revenge of the Jedi
20:25:47 <dino-> Ah ha, looking at source for replicateM and sequence I get it. replicateM sequences with replicate, which in the case of replicating an IO Bool is making a list of those actions.
20:26:44 <lispy> ?type replicateM
20:26:45 <dons> yeah, repicate would make a list of the actions
20:26:45 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
20:26:51 <dons> replicateM will give you a list of the results of hte actions
20:26:52 <dino-> But when I was trying to lift replicate it was bringing the Int up into the monad and dorking things.
20:26:58 <dons> i.e. it will evaluate them
20:27:02 <dons> yeah
20:27:10 <lispy> ?type replicate
20:27:12 <lambdabot> forall a. Int -> a -> [a]
20:27:19 <lispy> ?type lift replicate
20:27:19 <dons> replicateM n x    = sequence (replicate n x)
20:27:20 <lambdabot> forall (t :: (* -> *) -> * -> *) a. (MonadTrans t) => t ((->) Int) (a -> [a])
20:27:24 <dons> ?pl replicateM n x    = sequence (replicate n x)
20:27:25 <lambdabot> replicateM = (sequence .) . replicate
20:27:31 <dons> oh, could we use `on` there?
20:27:49 <dons> i'd like a useful combinator for avoiding the (f .) . or (. f)  .  syndrome
20:28:00 <ski> replicateM = sequence .: replicate
20:28:06 <lispy> ?type sequence `L.on` replicate
20:28:07 <lambdabot> Couldn't find qualified module.
20:28:08 <ski> (.:) = (.) . (.)
20:28:22 <ski> (.::) = (.) . (.) . (.)
20:28:22 <lispy> > let foo = sequence `L.on` replicate in foo
20:28:23 <lambdabot>    Occurs check: cannot construct the infinite type: t = [t -> a]
20:28:24 <lambdabot>    Exp...
20:28:33 <dons> ?let (.:) = (.) . (.)
20:28:35 <lambdabot> Defined.
20:29:00 <ski> @type sequence .: replicate
20:29:01 <lambdabot> Not in scope: `.:'
20:29:13 <dolio> L..: ?
20:29:24 <dons> > sequence (L..:) replicate $ 4 Nothing
20:29:25 <lambdabot>    Expecting a function type, but found `t_a1TD'
20:29:26 <lambdabot>    Expected type: a -> ...
20:29:40 <ski> no parens
20:29:42 <emu> aie, smilies
20:29:57 <dons> > sequence L..: replicate $ 4 Nothing
20:29:58 <lambdabot>  add an instance declaration for (Num (Maybe a -> Int))
20:29:58 <lispy> ?yar emu
20:29:59 <lambdabot> I want me grog!
20:30:06 <ski> > (sequence L..: replicate) 4 Nothing
20:30:07 <lambdabot>  Add a type signature
20:30:16 <dons> ah. fix the 'a' in the monad
20:30:25 <dons> > (sequence L..: replicate) 4 Nothing :: Maybe ()
20:30:26 <lambdabot>  Couldn't match `()' against `[a]'
20:30:28 <ski> > (sequence L..: replicate) 4 (Nothing :: Maybe ())
20:30:29 <lambdabot>  Nothing
20:30:34 <dons> nice
20:30:52 <ski> @type (.) . (.)
20:30:53 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
20:30:55 <ski> @type (.) . (.) . (.)
20:30:56 <lambdabot> forall a a1 b c a2. (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
20:31:03 <dons> > (sequence L..: replicate) 4 (Just 7 :: Maybe Int)
20:31:04 <lambdabot>  Just [7,7,7,7]
20:31:09 <ski> passes on 2 resp. 3 args to the right argument
20:31:42 <ski> > (sequence L..: replicate) 4 ([0,1] :: [] Int)
20:31:44 <lambdabot>  [[0,0,0,0],[0,0,0,1],[0,0,1,0],[0,0,1,1],[0,1,0,0],[0,1,0,1],[0,1,1,0],[0,1,...
20:31:48 <dons> ?check \n m -> (sequence L..: replicate) 4 (Just 7 :: Maybe Int) == replicateM (n::Int) (m::Int)
20:31:49 <lambdabot>  Couldn't match `Maybe Int' against `Int'
20:32:13 <dons> ?check \n m -> (sequence L..: replicate) n (Just m) == replicateM (n::Int) (m::Int)
20:32:14 <lambdabot>  Couldn't match `Maybe Int' against `Int'
20:32:29 <dons> ?check \n m -> (sequence L..: replicate) n (Just m) == replicateM (n::Int) (Just (m::Int))
20:32:30 <lambdabot>  OK, passed 500 tests.
20:32:58 <dons> not sure I like .: though
20:33:05 <dons> something infix would be ok.
20:33:11 <dons> `dot`
20:33:24 <dons> sequence `over` replicate
20:34:05 <ski> dot2
20:34:08 <ski> dot3
20:34:10 <ski> maybe ?
20:34:12 <lispy> how does something like the double brace idiom find nearly 40 people to mod it up?
20:34:30 <dons> lispy: scary isn't it
20:34:47 <dons> this explains why the industry is where it is
20:35:12 <lispy> dons: the old maxim, "peopre are idiots" turns out to be true? ;)
20:35:36 <dons> ski, i'll add (.) . (.) to the Pointfree discoveries page
20:35:44 <dons> maybe we can get some of these into Data.Function
20:35:59 <dons> along with `swing` and ((.)$(.))
20:36:10 <dons> ?type ((.)$(.))
20:36:11 <lambdabot> forall a b c a1. (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
20:36:14 <dons> ?type ((.).(.))
20:36:15 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
20:36:20 <lispy> but, in their defense, haskell is esoteric and exotic...also it doesn't work with VS and the wiki doesn't seem to use the words, "leverage" or "synergize" anywhere
20:36:36 <lispy> what is swing?
20:37:14 <ski> dons : i think i put '(.) . (.)' on the old wiki some years ago ..
20:38:36 <ski> lispy : see http://haskell.org/hawiki/LicensedPreludeExts
20:38:38 <lambdabot> Title: LicensedPreludeExts - The Haskell Wiki
20:38:47 <dons> http://haskell.org/haskellwiki/Pointfree#Swing
20:38:50 <lambdabot> Title: Pointfree - HaskellWiki, http://tinyurl.com/y6tf6n
20:38:54 <dons> http://haskell.org/haskellwiki/Pointfree#Dot
20:38:56 <lambdabot> Title: Pointfree - HaskellWiki
20:41:01 <lispy> ski: oh, swing is neat
20:41:39 <dons> yeah, i really like how this thread turned out. http://programming.reddit.com/info/p66e/comments
20:41:42 <lambdabot> Title: Are monads actually used in anything except Haskell ? (reddit.com), http://tinyurl.com/yhg87v
20:41:48 <dons> gives me hope for programming.reddit
20:42:02 <dons> just need to post more LtU-ish items
20:42:11 <dons> and drive away the php/Mod-ers ;)
20:42:49 <lispy> hot captcha is interesting
20:42:59 <lispy> but, not really programming.reddit material is it?
20:43:28 <dons> heh
20:44:38 <lispy> "After looking at the way its working, I think the test should say "find 3 females that aren't fat" ."
20:44:47 <lispy> what's the difference? /me ducks
20:46:15 <lispy> whoa, sun's java will get open sourced
20:46:53 <Korollary> yeah. really need to 'duck' on a friday night in #haskell for saying that...
20:47:10 <lispy> yeah....
20:47:54 <lispy> with my luck lately i have better odds of meeting a girl at home on irc than i do out there where it's cold and rainy
20:48:43 <Korollary> I suppose cold and rain lowers your odds drastically while they don't do jack to other guys?
20:49:27 <monochrom> Yeah you'll meet Philippa right here...
20:49:51 <lispy> Korollary: mentioning the weather was a red herring
20:49:57 <SamB> but he already knows Philippa, doesn't he?
20:50:33 <Korollary> There's the little bit of the atlantic ocean between us guys on the west coast of the US and brit women.
20:50:50 <SamB> that too
20:51:09 <SamB> maybe he meant in some *other* channel?
20:51:20 * lispy looks around shifty eyed
20:51:49 * SamB hits the capslock button on lispy's face
20:51:49 <monochrom> Oh, perhaps a girl from #logic?
20:52:04 <SamB> they have girls there?
20:52:11 <monochrom> I don't know. :)
20:52:12 * SamB would check #illogic as well
20:52:24 <Korollary> is this #assholz ?
20:52:25 <lispy> SamB: heh, you're full of bad jokes tonight :)
20:52:51 <SamB> should sleep
20:53:04 <SamB> then bad jokes will be in dreams where they are appreciated, or something
20:53:12 <lispy> righto
20:53:29 <SamB> at least I will get rest, at any rate
20:53:40 <SamB> 'night!
20:54:11 <dino-> Night for me too. Thank you guys, as always, very instructive.
20:54:17 <lispy> SamB: good night
20:54:24 <lispy> dino-: night!
20:54:46 <monochrom> everyone is going to bed right when I have time to explain Haskell...
20:54:57 <lispy> yes, do explain
20:55:02 <Korollary> write something on the wiki then
20:55:24 <lispy> ?prototorpedo
20:55:24 <lambdabot> I hear from an essay by E raymod that perl is shitty for large projects
20:55:49 <lispy> monochrom: i'll find you something to explain :)
20:55:51 <lispy> ?prototorpedo
20:55:52 <lambdabot> is functional progrmaming the same as object oriented?
20:55:57 <lispy> ah, there we go
20:56:01 <Adamant> ?keal
20:56:01 <lambdabot> T could perform expressions 600mb and bigger
20:56:17 <lispy> ?keal
20:56:18 <lambdabot> Keal angry @ dons
20:56:21 <lispy> heh
20:56:33 <lispy> ah the memories
20:56:36 <Adamant> you wouldn't like keal when he's angry
20:56:38 <lispy> man, i've been in #haskell a long time
20:56:48 <lispy> yeah, he turns into a big green bug in math
20:57:30 <Adamant> ok.. what are arrows, and why are they important?
20:57:47 <Adamant> (wrt Haskell, of course)
20:58:12 <lispy> Adamant: well, fruit flies like a banana and flies like an arrow
20:58:20 <ski> one thing is that they allow static information to be used
20:58:23 <lispy> er time flies on the second part
20:58:54 <ski> e.g. static information about whether a parser could possibly fail .. and what possibly tokens it can accept as starting token
20:59:06 <monochrom> arrows generalize functions.  if you want to define something that's almost a function except you also want to add state etc., you may have an arrow.
20:59:12 <Adamant> ah.
20:59:20 <ski> arrows generalize comonads, also
20:59:46 <dons> ok, my daily FP reddit submission, http://programming.reddit.com/info/pdr4/comments
20:59:48 <lambdabot> Title: Multi-core, lock-free Haskell programming [pdf] (reddit.com), http://tinyurl.com/ylz26x
20:59:49 <chessguy> but not monads?
20:59:53 <lispy> so they generalize, functors, monads, comands and functions?
21:00:29 <dolio> How about: 'I've heard TCL described as a functional language, therefore data parallelism is bunk, and C/POSIX is great for writing concurrent programs.'
21:00:39 <monochrom> For example there is a paradigm of programming based on stream transformers, i.e., functions of type [a]->[b].  These can be made arrows of type "Streamer a b".
21:00:45 <dons> dolio: heh
21:00:48 <dons> where's that from?
21:01:03 <dolio> The 'C is efficient' comments.
21:01:09 <dons> hehe
21:01:22 <dons> i welcome my competitors to use C/POSIX on their 40 core + machines
21:01:36 <dons> in fact, I encourage them to do so.
21:01:37 <dolio> That sounds like a lot of fun.
21:01:46 <edwardk> dons: heh
21:01:48 <Adamant> heh. POSIX is not going anywhere.
21:01:51 <ski> lispy : not functors ..
21:01:54 <Adamant> although C may
21:02:34 <Adamant> monochrom, thanks for the info. :)
21:02:37 <dons> lock free data parallel haskell is crystallising exactly that the right time, imo.
21:02:38 <lispy> ski: wait a sec, but all monads are functors and arrows generalize monads...so at the least arrows can act as functors
21:03:48 <dons> tmoertel: what do you reckon? any chance for a lock-free SMP haskell blog/tut entry?
21:03:58 <ski> lispy : not all arrows can be described as monads
21:04:03 <monochrom> all monads are arrows.  not all arrows are monads.  this is a generalization.
21:04:05 <dons> we need some tuts out there on solving problems with true SMP forkIO.
21:04:06 <Adamant> I wonder how Erlang handles multi-core stuff
21:04:13 <edwardk> every monad gives an arrowmonad, every instance of arrowapply gives you a monad, so you can use arrowapply like a functor if you want
21:04:26 <edwardk> but not all arrows
21:05:13 <edwardk> the isa relation is running the wrong way
21:06:18 <lispy> what about the pci relation? ;)
21:06:32 <edwardk> its a little slower than the agp relation
21:06:37 <edwardk> but it should do =)
21:08:06 <monochrom> hahahahaha
21:08:36 <dons> hey lispy, which compiler is this you're writing?
21:08:43 <dons> Helisp?
21:09:06 <lispy> ya
21:09:11 <dons> code online?
21:09:16 <lispy> ya
21:09:19 <lispy> ?where helisp
21:09:20 <lambdabot> http://www.codersbase.com/index.php/helisp
21:09:26 * jgrimes checks it out
21:09:26 <dons> and have you read the 'extending a lisp interpreter with monad transformers" ?
21:09:33 <lispy> ya
21:09:40 <dons> dive in guys, do for lisp what pugs did for perl6!
21:09:49 <jgrimes> :)
21:09:57 <lispy> oh wait, maybe i read a difference one
21:10:04 <dons> Steele?
21:10:13 <lispy> but, it wasa lisp interpreter and they built it step by step by using monad transformers
21:10:18 <lispy> recent tutorial
21:10:22 <dons> oh, not the paper
21:10:33 * dons chases url thunks
21:10:59 <lispy> dons: yeah, i'm currently wondering how faithful i should be to elisp
21:10:59 <dons> http://www.swiss.ai.mit.edu/~dae/related-papers/steele.ps.Z
21:11:02 <lambdabot> http://tinyurl.com/ymxzng
21:11:05 <dons>  "Building Interpreters by Composing Monads"
21:11:19 <lispy> dons: one goal is to be emacs compatible...but at the same time, there are a lot of cool things taht could be done to make elisp better
21:11:28 <lispy> dons: switch to lexical scope for example
21:11:39 <jgrimes> hm, why elisp compat.?
21:12:01 <lispy> jgrimes: i started helisp over a year ago with the goal to make yi be able to run elisp
21:12:02 <undated> I remember Erik Naggum at one time talking about a cl-emacs.
21:12:10 <lispy> undated: right, climacs
21:13:12 <ski> there's edwin also
21:13:21 <lispy> climacs was very slow the last time i tried to use it
21:13:32 <lispy> and it didn't have all my emacs tricks
21:13:43 <undated> Wasn't there also one written in dylan?
21:13:48 <lispy> which is when i realized, to switch away from emacs i actually need a migration path
21:13:53 <lispy> undated: yeah
21:13:59 <ski> (imagine saving an editor continuation :)
21:14:00 <undated> My memory of such things is regrettably hazy.
21:14:27 <edwardk> ski: heheh
21:14:27 <undated> Mostly because I haven't had to use emacs in like five years.
21:14:54 <dons> yeah, so another aspect of reddit is that you can have the mundane next to the astounding . i.e. "lock free haskell" ranked next to "Notepad2 with Ruby syntax highlighting"
21:14:58 <edwardk> ski: now make it pure functional so you can go back there and not have destroyed the edit buffer irrevocably in the meantime
21:15:09 <lispy> dons: heh
21:15:27 <ski> edwardk : zipper ?
21:16:02 <lispy> some ideas i've had, 1) make a translator for elisp -> X (where X = haskell, CL, or whatever), 2) implement elisp in something else
21:16:12 <lispy> maybe i should try a hybrid
21:16:31 <lispy> remake elisp to be what i think it should have been and provide a translator for elisp -> helisp
21:17:27 <lispy> i would also like to add some type inferencing to my language...i don't know how far i'd be able to take it, but if it helps write less buggy emacs programs then yay!
21:18:17 <dons> lispy: regarding lexical scope, isn't there a lisp extension that specified this somewhere?
21:18:23 <dons> i.e. you could just implement the standard
21:18:40 <dons> -flexical-scope or something
21:18:43 <lispy> scheme has lexical scope and CL has both
21:19:11 <lispy> dons: saying i should provide it as a compiler option?
21:19:39 <lispy> i'm also thinking of dropping the notion of bytecode
21:19:41 <lispy> not sure yet
21:20:26 <lispy> i could stop compiling to machine code, implement a better elisp vm and then JIT
21:20:53 <lispy> one perk to that is the ease of cross platform
21:21:17 <lispy> otoh, currently you have to recompile your bytecode for each version of emacs, so you don't get much portability in practice
21:21:57 <dons> mm, i really like this comment on the shootout, on lua and ghc both doing well, "This is awesome. It's like watching a match between the team of the town where you're from, and the team of the town where you live. Either way you've got a reason to get drunk after the game."
21:22:20 <lispy> heh
21:22:42 <dolio> You need reasons to get drunk?
21:22:47 <dons> hehe
21:22:58 <undated> I don't like sports and I don't drink so I'm 0/2 :(
21:23:12 <jcreigh> whoa, people are starting to work on a parallel GC for GHC? I can't even begin to understand how that would work.
21:23:44 <dons> apprently multicore parallel GC is well understood
21:23:46 <dons> i didn't know that.
21:24:12 <monochrom> Dijkstra and Lamport gave an algorithm a while ago.
21:24:42 <monochrom> Certainly advances have been made too since then.
21:25:12 <Pupeno> [OT] Any texts on implementing Smalltalk-like languages ? something like http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html but for a Smalltalk like language ?
21:25:14 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/l986o
21:25:28 <dons> the paper says "numerous existing designs for parallel GC" "should be relatively straightforward"
21:25:46 <dons> Pupeno: I have a theory we could implement ruby in 48 hours
21:25:54 <dons> anyone know ruby well enough to want to try?
21:25:58 <lispy> ?google smallworld smalltalk
21:26:00 <lambdabot> http://web.engr.oregonstate.edu/~budd/SmallWorld/ReadMe.html
21:26:00 <lambdabot> Title: Small World: A tiny Smalltalk-80 like interpreter
21:26:07 <lispy> Pupeno: take a look at that
21:26:13 <dons> but yeah, its been suggested a few times that we implement smalltalk
21:26:16 <lispy> Pupeno: the author wrote it to be short and illustrative
21:26:35 <Pupeno> dons: why don't you implement Smalltalk in 48 hs ? it would be similar than Ruby, but better :)
21:26:46 <Pupeno> lispy: Thank you.
21:26:56 <dons> heh. but think of the PR value. like pugs but more so. ;)
21:27:06 <lispy> Pupeno: yw, please port it to haskell and then post a link on the wiki :)
21:27:25 <Pupeno> dons: I cerntanly want to do it... but with my knowledge and resources, it'd take me more like 6 months.
21:27:28 <dolio> It'd be quite amusing if you beat the VM that's been in progress for a couple years.
21:27:30 <dons> i.e. we could have Ruby 2.0 with SMP threads and monadic continuatoins before the ruby 2.0 guys get out ruby 2.0 without those features :)
21:27:54 <lispy> ouch
21:27:59 <monochrom> dons you're a great source of temptations.
21:28:07 <lispy> truely
21:28:09 <Pupeno> ajj... Java :/
21:28:19 <lispy> Pupeno: oh yeah, the author is an OO nut
21:28:23 <dons> it would pretty much guarantee instant audreyt-level fame for anyone who does it...
21:28:32 <monochrom> For the love of you I have been spending too much time on HaskellWiki already...
21:28:36 <dons> (who's giving an opening address as POPL , btw...)
21:28:45 <dons> s/at/
21:28:59 * lispy puts dons on ignore for fear of not finishing his real life obligations :)
21:29:05 <dons> he
21:29:21 <edwardk> brb
21:29:36 <lispy> but yeah, that is a really, really cool idea, re: ruby
21:29:37 <dons> and there's even a 1.0 ruby-in-haskell impl. to start with..
21:30:05 <undated> Ruby interests me about as much as genital warts.
21:30:09 <lispy> BTW, does pugs compile or interpret or both?
21:30:16 <dons> http://groups.google.com/group/comp.lang.ruby/browse_thread/thread/7f3c1fd7d6c906aa
21:30:19 <lambdabot> Title: Google Groups: comp.lang.ruby, http://tinyurl.com/ymxzta
21:30:20 <dons> lispy: both.
21:30:39 <dons> monadic interpreter, and then a couple of code gen backends (or 3?)
21:30:43 <lispy> dons: so, then there is a bytecode vm?
21:30:49 <lispy> oh wow
21:31:19 <lispy> i'd also like to write a C99 compiler in Haskell
21:31:20 <dons> and you wouldn't even need to compile ruby. an interpreter would be plenty fast enough for the ruby crowd
21:31:29 <lispy> dons: yeah
21:31:41 <dolio> Heh.
21:32:25 <lispy> i think it would be cool if ghc could compile the C backend compiler it uses :)
21:32:33 <dons> unlike the megamonadical haskellers who demand C-like speed at all costs
21:32:40 <monochrom> I know how to do C99.  execute_C99 _ = undefined
21:32:59 <lispy> execute_C99 = unsafePerformEverything
21:33:08 <monochrom> Not perfect but "90% coverage" already!
21:33:22 <dons> let c99 = intercalate unsafeCoerce# src
21:33:35 <lispy> nice use of intercalate
21:33:41 <dons> thanks
21:33:46 <lispy> bleh, i should be designing/implementing darcsSim
21:33:51 <lispy> i really need to get on that
21:33:54 <monochrom> What is intercalate?
21:33:55 <lispy> and i have some cool ideas...
21:33:56 <dolio> The link to that interpreter seems to be dead.
21:34:07 <lispy> monochrom: concat . intersperse, roughly
21:34:09 <dons> yeah, maybe someone with some .jp skills can find it?
21:34:20 <lispy> dolio: the smallworld one?
21:34:34 <dons> or did you mean the ruby one?
21:34:37 <lispy> dolio: the author teaches my class so i can definitely let him know if that's the case
21:34:50 <monochrom> AH!
21:34:55 <dolio> The ruby one.
21:34:58 <dolio> http://raa.ruby-lang.org/project/rtype/
21:35:00 <lispy> ah, n/m
21:35:00 <lambdabot> Title: RAA - rtype
21:35:02 <dolio> It's available there.
21:35:13 <Botty> ?check \x -> mod x 5 >= 0
21:35:14 <lambdabot>  Add a type signature
21:35:18 <dons> http://raa.ruby-lang.org/project/rtype/
21:35:20 <lambdabot> Title: RAA - rtype
21:35:31 <dons> yeah, src seems to work
21:35:43 <Botty> ?check mod x 5 >= 0
21:35:44 <lambdabot>  Not in scope: `x'
21:35:53 <lispy> bbiab
21:36:18 <Botty> ?help check
21:36:19 <lambdabot> check <expr>
21:36:19 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
21:36:30 <Botty> -_-
21:36:54 <dons> ?check \x -> mod x 5 >= (0::Int)
21:36:55 <lambdabot>  OK, passed 500 tests.
21:38:01 <Botty> thanks
21:39:09 <jcreigh> ?check \x -> mod x 1000 > (0::Int)
21:39:11 <lambdabot>  Falsifiable, after 0 tests: 0
21:39:21 <jcreigh> aww, it starts with zero.
21:39:29 <jcreigh> how does it decide which values to check?
21:39:44 <dons> it uses the Arbitrary instance for the type you ask it to generate, in this case Int
21:39:45 <Botty> ?where quickcheck
21:39:45 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
21:39:55 <dons> ?scheck ?check \x -> mod x 1000 > (0::Int) -- uses a different generator model
21:39:55 <lambdabot>  Parse error
21:40:03 <dons> ?scheck \x -> mod x 1000 > (0::Int) -- uses a different generator model
21:40:05 <lambdabot>   Failed test no. 2. Test values follow.: 0
21:40:20 <Botty> ?scheck \x -> mod x 1000 >= (0::Int)
21:40:21 <lambdabot>  Completed 10 test(s) without failure.
21:40:34 <Botty> lol. a whole 10. amazing ;P
21:40:35 <dons> it generates tests to a certain depth , inductively
21:40:48 <dons> so it doesn't need to brute force the random data
21:40:54 <Botty> ah
21:40:55 <Botty> cool
21:41:05 <dons> ?scheck \x -> x
21:41:06 <lambdabot>  Add a type signature
21:41:14 <dons> ?scheck \x -> (x :: Bool)
21:41:15 <lambdabot>   Failed test no. 2. Test values follow.: False
21:41:36 <Botty> 0_o
21:41:36 <dons> ?scheck \x y -> y && x
21:41:37 <lambdabot>   Failed test no. 2. Test values follow.: True, False
21:41:43 <jgrimes> dons, that paper on building interpreters by composing monads is pretty informative.
21:41:55 <jgrimes> and inspiring
21:42:07 <dons> ?scheck \x y z -> x || y || z
21:42:08 <lambdabot>   Failed test no. 8. Test values follow.: False, False, False
21:42:18 <dons> jgrimes: cool. maybe i should read it again
21:42:39 <dons> ?check \x y z -> x || y || z
21:42:41 <lambdabot>  Falsifiable, after 4 tests: False, False, False
21:42:59 * jcreigh wonders if ?check could find carmichael numbers...
21:43:33 <dons> if you have a boolean test for them, then yeah, maybe. if they don't take too long to generate
21:45:52 <jdev> @check liftM2 (||) (<=(0::Integer)) $ let c x = if x `mod` 2 == 0 then x `div` 2 else 3*x+1 in any (==1) . iterate c
21:45:54 <lambdabot>  OK, passed 500 tests.
21:46:15 <dons> so if you invert the test, it'll print them for you
21:53:08 <syntaxfree> oh jesus.
21:53:13 <syntaxfree> I just found out what SOL means.
21:53:19 <Botty> > [0,1..5]
21:53:21 <lambdabot>  [0,1,2,3,4,5]
21:53:43 <syntaxfree> I thought it meant something serious like "solitary on Lsomething"
21:53:50 <jcreigh> what's really sad is that I read that as "SQL" initially.
21:53:59 <syntaxfree> I don't understand [a,b..n] semantics to the day.
21:53:59 <Botty> jcreigh: me too
21:54:12 <syntaxfree> > [7, -3, 2..10]
21:54:12 <lambdabot>  Parse error
21:54:20 <syntaxfree> > [7, -3...10]
21:54:21 <lambdabot>  Not in scope: `...'
21:54:24 <dons> > [1,4..]
21:54:25 <lambdabot>  [1,4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,76,...
21:54:32 <syntaxfree> > [7,-3,..10]
21:54:32 <lambdabot>  Parse error
21:54:38 <Botty> syntax - lol, well, delta is b-a, start is a, end is c
21:54:41 <dons> > [0,10..100]
21:54:43 <lambdabot>  [0,10,20,30,40,50,60,70,80,90,100]
21:54:43 <syntaxfree> > [7,-3..10]
21:54:45 <lambdabot>  []
21:54:51 <syntaxfree> dons: those simple cases I get. But look at mine.
21:55:04 <dons> > 7 : [-3..10]
21:55:05 <lambdabot>  [7,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10]
21:55:06 <syntaxfree> why is [7,-3..10] = []  ?
21:55:12 <Botty> I think its too bad they didn't generalize it to do n-diminsional polynomials :)
21:55:14 <dons> since you go backwards
21:55:27 <Botty> err, not diminsional
21:55:28 <dons> > [LT..]
21:55:29 <lambdabot>  Parse error
21:55:32 <Botty> forgot the term...
21:55:37 <dons> > [LT]
21:55:38 <syntaxfree> I wish Haskell's  syntax was a tad bit more tweakable.
21:55:39 <lambdabot>  [LT]
21:55:40 <monochrom> 7, -3, what is the next term?  XD
21:55:45 <dons> >[LT ..]
21:55:46 <Botty> syntaxfree: me too
21:55:48 <dons> > [LT ..]
21:55:49 <lambdabot>  [LT,EQ,GT]
21:55:55 <syntaxfree> infix operators are nice, very nice.
21:56:02 <dons> > [GT, EQ ..]
21:56:03 <lambdabot>  [GT,EQ,LT]
21:56:08 <syntaxfree> I'd like to be able to define a data type to use { brackets, elements, elements }
21:56:15 <Botty> after learning haskell, i've got an idea in my head for a very cool functional language.
21:56:15 <dons> > [7, 3 ..]
21:56:17 <lambdabot>  [7,3,-1,-5,-9,-13,-17,-21,-25,-29,-33,-37,-41,-45,-49,-53,-57,-61,-65,-69,-7...
21:56:20 <jgrimes> > [1.1,2.2..10]
21:56:21 <lambdabot>  [1.1,2.2,3.3000000000000003,4.4,5.5,6.6,7.699999999999999,8.799999999999999,...
21:56:22 <jgrimes> =/
21:56:48 <Botty> uh-oh-spagedio
21:56:55 <syntaxfree> I mean, whenever I have data Type a = Somestuff [a], be able to use /2,3,5/ or 2,3,5 etc.
21:56:55 <dons> Botty: is it called `Haskell'? :)
21:57:00 <syntaxfree> (as type constructors)
21:57:02 <Botty> lol, nah
21:57:15 <dons> > fromEnum 2 :: Ordering
21:57:16 <lambdabot>  Couldn't match `Ordering' against `Int'
21:57:20 <Botty> dons - the odd part is the average programmer won't even know its functional
21:57:23 <dons> > (fromEnum 2) :: Ordering
21:57:24 <lambdabot>  Couldn't match `Ordering' against `Int'
21:57:30 <syntaxfree> Botty: that's the essence of Linq/.
21:57:36 <monochrom> Oh I know!  It's Excel!
21:57:38 <dons> ?type fromEnum
21:57:40 <lambdabot> forall a. (Enum a) => a -> Int
21:57:46 <dons> ah , i always get them around the wrong way
21:57:52 <dons> > (toEnum 2) :: Ordering
21:57:53 <lambdabot>  GT
21:58:10 <dons> > map toEnum [0,2..] :: [Ordering]
21:58:11 <syntaxfree> they're basically tricking VB programmers into using monads using DB as a sales pitch.
21:58:11 <lambdabot>  Exception: Prelude.Enum.Ordering.toEnum: bad argument
21:58:19 <Botty> syntaxfree: yeah, but kind of reverse.  linq is like functional within procedural.  mine is procedural (among many other paradigms) within functional
21:58:20 <dons> > map toEnum [0,1,2] :: [Ordering]
21:58:22 <lambdabot>  [LT,EQ,GT]
21:58:31 <jgrimes> > [1.5..10]
21:58:33 <lambdabot>  [1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5]
21:58:35 <jgrimes> =/
21:58:36 <monochrom> monads?
21:58:46 <syntaxfree> multiparadigm language are a dime a dozen.
21:58:51 <Botty> syntaxfree: Linq is in VB? I thought it was just C#
21:58:52 <syntaxfree> Python, Perl, you name it.
21:59:02 <monochrom> Haskell.
21:59:07 <Botty> yeah, but my language will be the first truely multiparadigm language
21:59:10 <syntaxfree> quoth Erik Meijer:
21:59:26 <Botty> the paradigms will be implemented within the language, as libraries :)
21:59:31 <syntaxfree> "Functional programming has finally arrived to the masses. It's name is not Lisp, ML or Haskell: it's Visual Basic"
21:59:41 <dons> yeah
21:59:51 <syntaxfree> s/It's name/Its name
22:00:00 <dons> ?remember syntaxfree Functional programming has finally arrived to the masses. Its name is not Lisp, ML or Haskell: it's Visual Basic
22:00:03 <monochrom> How is VB functional?
22:00:06 <Botty> maybe not the first, someone has probably done it, just not as well as i plan
22:00:06 <dons> syntaxfree: gets HWN quote of the week awrad
22:00:13 <dons> monochrom: LINQ
22:00:21 <syntaxfree> dons: that's from Erik Meijer's "Confessions of an used programming language salesman".
22:00:23 <monochrom> What is it like?
22:00:23 <dons> monad comprehenion-based, along with some monoids
22:00:29 <syntaxfree> @google confessions of an used programming
22:00:32 <lambdabot> http://research.microsoft.com/~emeijer/Papers/ICFP06.pdf
22:00:36 <dons> ah ! yes.
22:01:07 <monochrom> Sounds nice.
22:01:20 <syntaxfree> that might be the least mathematical paper Meijer ever brought to the table.
22:01:27 <Botty> yes, my language idea sounds rather crazy, but its not. really.  I've got it fleshed out for the most part in my head ;)
22:02:33 <syntaxfree> there's an orkut community called "My killer app isn't ready yet"
22:03:06 <Botty> I haven't even started programming on my killer app ;)
22:03:19 <syntaxfree> most never do. myself included.
22:03:49 <jgrimes> I don't even know what a killer app looks like. All I've ever seen are lucky apps.
22:03:53 <Botty> I probably won't.  I do want to write a spec for my language in case i ever take a compiler construction class
22:04:02 <syntaxfree> the spreadsheet is the killer app.
22:04:10 <undated> calc.exe forever
22:04:17 <syntaxfree> (though I guess S-Plus/R get close)
22:04:18 <Botty> first person shooters are the ultimate killer apps
22:05:37 <Botty> actually, defcon is the ultimate killer app
22:05:40 <syntaxfree> I think I might be the only one who used the matrix multiplication oriented programming paradigm.
22:05:58 <syntaxfree> My code used to consist  entirely of matrix multiplications in Matlab.
22:06:07 <Botty> lol
22:06:09 <syntaxfree> I basically expressed all looping constructs as matrix multiplications.
22:06:23 <syntaxfree> Documentation consisted of stacks of paper with hollow matrix shapes and arrows.
22:06:24 <Botty> pretty cool
22:06:36 <syntaxfree> I didn't know the first thing about programming, I guess.
22:07:00 <syntaxfree> I actually wrote a full backpropagation library in that style before even finding out Matlab does them NNs.
22:08:15 <syntaxfree> I should call it LOOP.
22:08:20 <syntaxfree> Linear Operator Oriented Programming.
22:08:38 <undated> You should call it Table Oriented Programming
22:08:38 <syntaxfree> The advantage is that you can go back and forward between states merely inverting matrices at the apropriate points.
22:08:54 <lispy> syntaxfree: so you're a loopy programmer? ;)
22:08:56 <syntaxfree> there is TOP already, and it's not quite I did.
22:09:24 <syntaxfree> not anymore. Getting something done in that style takes an energy I can't focus into programming anymore.
22:09:25 <undated> No, but it's funny thinking of the results.
22:09:52 <Botty> I'd imagine he knows that.  TOP is actually pretty cool.  definitely only really good for a certain set of applications (namely, embedded scripting)
22:10:26 <undated> I've been up for 36 hours and the idea of calling out the Derek Smart of programming paradigms amuses me.
22:10:41 <syntaxfree> I think LOOP is an extreme form of array-oriented programming, if I understood correctly what the latter means.
22:10:41 <undated> I'm sure it will pass with some much-needed rest.
22:11:22 <syntaxfree> Somehow, my complete ignorance of numerical analysis got me thinking that LOOP would be somehow faster.
22:11:25 * lispy think he might try to write smallworld into haskell
22:11:29 <syntaxfree> It also felt more "mathematical" somehow.
22:11:34 <syntaxfree> Mathematically tractable, anyway.
22:11:51 <syntaxfree> I didn't know about BIrd-Merteens theory by then, of course.
22:13:02 <Cale> hmm...
22:13:36 <Cale> Someone said my name, but my scrollback isn't long enough
22:14:24 <Botty> Cale - buy some more ram ;)
22:14:41 <syntaxfree> @seen alunoiemestrado
22:14:42 <lambdabot> I saw alunoiemestrado leaving #haskell 4d 10h 32m 20s ago, and .
22:14:48 <arjanoosting>  < dons> Cale: I think the copyright here needs to be fixed? http://haskell.org/haskellwiki/New_monads/MonadUnique
22:14:49 <Cale> Botty: ram isn't the problem, it's just that I had it set too low
22:14:51 <lambdabot> Title: New monads/MonadUnique - HaskellWiki, http://tinyurl.com/yeasl6
22:15:13 <syntaxfree> Yes, But Are Monads Invertible?  (TM)
22:15:19 <Botty> I know, I just figured ram would be the only reason you might set it to anything but astronomical values
22:15:39 <lispy> Cale: presumably you set it too low as a reminder to buy more ram? ;)
22:16:27 <Cale> No, probably more that I'd never touched the default which is ridiculously small
22:16:48 <lispy> mine is 500 lines give or take a 50
22:17:00 <lispy> and that's fine for me
22:23:18 <lispy> oh hrm...to make a smalltalk interpreter you apparently have to do graphics
22:29:17 <Botty> oh, you guys must be in some terminal or something
22:29:32 <Botty> I've got that set pretty dang high too
22:29:47 <Botty> but gaim doesn't even have a scrollback min
22:30:20 <lispy> how do you emulate inheritance?
22:30:57 <monochrom> virtual function table
22:31:34 <lispy> monochrom: i have (in java) class SmallObject and then i have things like class SmallInt extends SmallObject
22:32:08 <monochrom> the latter has a larger table
22:32:42 <lispy> so was going to do data SmallObject = ... and then when i got to data SmallInt, i was stumped
22:33:06 <monochrom> OH!  In Haskell.  Ask Oleg.
22:33:21 <monochrom> I thought you were interpreting.
22:33:24 <lispy> er, there must be some simple way
22:33:45 <lispy> i guess i could check the oohaskell paper and take one of the non-oohaskell approaches they mention
22:33:46 <monochrom> You can use type classes.
22:33:50 <lispy> but i was hoping to find something simple
22:33:56 <lispy> so class SmallObject ...
22:34:09 <lispy> but then I want to associate certain fields with each data type
22:34:16 <lispy> using classes only lets me extend the interface
22:34:41 <monochrom> oohaskell is better than me
22:35:05 <lispy> i can't get oohaskell to work
22:35:13 <lispy> oleg wasn't very helpful either :)
22:35:20 <lispy> (I don't think he can reproduce my problem)
22:35:21 <monochrom> I mean the ideas in oohaskell
22:35:33 <lispy> yeah, i don't get HList
22:36:26 <lispy> ah, so here is what i do...i just make functions in the type class that correspond to the data fields i want to inherit
22:36:51 <lispy> objClass :: a -> SmallObject b
22:36:55 <lispy> something like that
22:37:09 <lispy> where in java it's public SmallObject objClass;
22:38:47 <lispy> hmm...and another potential problem
22:38:51 <monochrom> The fun begins when you have x::SmallObject, z::SmallInt, and you want the list [x,z] :: [SmallObject].  There you'll want existential types.
22:38:56 <lispy> public SmallObject [ ] data;
22:39:02 <lispy> right
22:39:07 <lispy> yeah, i was just realizing that
22:39:11 <jcreigh> @pl \xs -> sum $ map fst xs
22:39:12 <lambdabot> sum . map fst
22:39:18 <lispy> soData     :: SmallObject b => a -> [b]
22:39:31 <lispy> that's not gonna work, how do i make that exstential types?
22:39:38 * jcreigh smacks himself in the forehead
22:39:51 <lispy> soData :: a -> [SmallObject b => b]
22:39:53 <lispy> something like that?
22:39:57 <lispy> is that even haskell?
22:39:57 <monochrom> I have not studied existential types.  I just heard that it will work.
22:40:22 <monochrom> I heard this from Cale.
22:40:27 <lispy> Cale: ping!
22:40:34 * monochrom is an information broker :)
22:40:35 <lispy> that syntax was not valid...
22:40:43 <Cale> hi
22:40:56 <lispy> Cale: i'm translating some Java
22:41:04 <lispy> Cale: and it uses inheritance like crazy
22:41:06 <Cale> You need to create a proper datatype if you want an existential type
22:41:45 <lispy> okay, but then if i make SmallObject a data type instead of a class how do i do inheritance?
22:42:44 <Cale> It looks like  data SomeSmallObject = forall a. SmallObject a => SSO a
22:43:00 <monochrom> Each class manifests as a data type and a type class.  Some say it is even the orthodox way in OOP, cf the Eclipse architecture.
22:43:17 <lispy> hmm...i see
22:43:33 <Cale> Then you can apply the constructor SSO to strip off all the type information from a value except that it belongs to the class SmallObject
22:44:09 <Cale> You're essentially denying any access to that value except via the SmallObject class
22:44:49 <Cale> Then, usually it helps to write an instance of SmallObject for SomeSmallObject values, which simply unwraps the values before applying the members of the class.
22:45:40 <Cale> data Showable = forall a. Show a => Showable a
22:45:40 <Cale> instance Show Showable where
22:45:40 <Cale>     show (Showable x) = show x
22:45:46 <Cale> *Main> [Showable "Hello", Showable 5]
22:45:46 <Cale> ["Hello",5]
22:46:14 <jgrimes> interesting.
22:46:25 <Cale> Of course, only being allowed to apply show to something is pretty pointless, since you might as well just turn it into a string, but it works.
22:46:47 <lispy> SmallObject.hs:7:19: Not a constructor: `forall'
22:46:51 <lispy> am i missing an extension?
22:46:54 <Cale> -fglasgow-exts
22:48:38 <lispy>     Can't combine named fields with locally-quantified type variables or context
22:48:40 <lispy> hmm...
22:48:46 <lispy> i have done similar things
22:48:51 <lispy> but today it's not working so well :)
22:49:57 <Cale> Which GHC?
22:50:13 <lispy> 6.4.2
22:50:14 <Cale> If you're trying to use record syntax, you'll need 6.6
22:50:20 <lispy> Ah
22:50:29 <lispy> that would be the reason probably :)
22:52:56 <lispy> ?where lisppaste
22:52:56 <lambdabot> I know nothing about lisppaste.
22:52:59 <lispy> ?where paste
22:53:00 <lambdabot> http://paste.lisp.org/new/haskell
22:53:37 <lisppaste2> lispy pasted "Type class problems" at http://paste.lisp.org/display/29258
22:53:55 <lisppaste2> lispy annotated #29258 with "error messages" at http://paste.lisp.org/display/29258#1
22:54:02 <lispy> Cale: does any of that make sense?
22:54:31 <lispy> maybe i need MPTC with fundeps to do this?
22:54:47 <lispy> class CSmallObject a b | a -> b where, perhaps?
22:57:09 <Cale> yes
22:57:15 <Cale> objClass :: CSmallObject b => a -> b -- which b? :)
22:57:39 <lispy> i tried the MPTC thing but then i couldn't write the instance
22:58:35 <Cale> well, that's because CSmallObject is trying to remember exactly what SmallObject forgets
22:59:19 <lispy> how do we fix it?
23:00:23 <Cale> well, hmm
23:00:28 <lisppaste2> lispy annotated #29258 with "closer" at http://paste.lisp.org/display/29258#2
23:00:52 <Cale> I'm trying to understand just what you're trying to accomplish
23:01:02 <lispy> let me paste some java
23:01:20 <Cale> Suppose I apply SmallObject to a value and a list of values of the same type
23:01:29 <lisppaste2> lispy annotated #29258 with "trying to emulate this" at http://paste.lisp.org/display/29258#3
23:02:32 <Cale> hmm, that's a tree?
23:02:38 <Cale> er...
23:03:05 <Cale> a tree of values extending the SmallObject class?
23:03:06 <lispy> it's a small talk interpreter
23:03:14 <Cale> hmm
23:03:27 <lispy> i'm these are the basic classes of smalltalk
23:03:32 <lispy> Object and Int
23:03:39 <Cale> okay
23:03:43 <lispy> next i have Array and a few others
23:04:08 <lispy> so everything will inherint from object ultimately
23:04:12 <Cale> What data do we need to be able to obtain? We need to be able to obtain the class, which is another object of *some* type
23:04:23 <Cale> and the data elements, which are objects of *some* type
23:04:35 <Cale> So...
23:04:48 <Cale> class CSmallObject a where
23:04:49 <lispy> right, and the data elements need not be all the same type other than being SmallObjects
23:05:02 <Cale>   objClass :: a -> SomeSmallObject
23:05:12 <Cale>   odata :: a -> [SomeSmallObject]
23:05:27 <Botty> ?hoogle a -> [a] -> Integer
23:05:28 <lambdabot> No matches, try a more general search
23:05:32 <Cale> Or you can just call that SmallObject if you want :)
23:05:42 <lispy> right
23:05:45 <Botty> is there a counting function in the prelude/data.list?
23:05:45 <lispy> i have been :)
23:05:54 <lispy> Cale: so this is basically whati started with
23:06:17 <lispy> Cale: so now how do i write the SmallObject data type?
23:06:24 <jgrimes> Botty, what do you mean by counting function?
23:06:26 <lispy> data SmallObject = forall a. CSmallObject a =>
23:06:27 <lispy>      SmallObject a [a]
23:06:30 <Cale> data SmallObject = forall a. CSmallObject a => SmallObject a
23:06:34 <lispy> that's what i have right now, but i dont' think that's right
23:07:00 <Cale> no, that's mixing levels of abstraction -- all that the SmallObject constructor is going to do is throw away the type information
23:07:04 <lispy> because it's very unlikely that the object will be holding data of the same type as its class
23:07:04 <Botty> count 'b' "bouncing bable-fishies" == 3
23:07:32 <Cale> length . filter (== 'b') would do it
23:07:41 <Botty> bah ;)
23:07:44 <lispy> Cale: okay... but then were will I store the class and data?
23:08:06 <Botty> yes, it would. prelude functions have been written for less though
23:08:17 <Cale> well, perhaps we should call this something simpler for convenience
23:08:42 <Cale> data O = forall a. CSmallObject a => O a
23:09:14 <Cale> So a value of type O is just an object, with essentially everything about its type forgotten, except the class object and the data objects
23:09:24 <Botty> would length $ filter (== 'b') be the same thing?
23:09:26 <Cale> You know, this is going to be quite strange :)
23:09:39 <Cale> Botty: yeah, except it's a type error
23:09:54 <lispy> Cale: what do you mean except the class object and data objects?  we just forgot them :)
23:09:58 <Botty> ohh, cuz of the pointlessness
23:10:59 <Cale> lispy: no, just their type :)
23:11:15 <Cale> lispy: the problem is going to be that we have no interface except this
23:11:33 <Cale> So there's essentially no way to extract information from this system
23:11:48 <Cale> well, except for the numbers of members :)
23:12:38 <Cale> How many other cases are there?
23:12:46 <Cale> Other than SmallObject and SmallInt?
23:12:47 <Botty> > count x xs = length $ filter (==x) xs in count 'b' "bouncing bable-fishies"
23:12:47 <lambdabot>  Parse error
23:12:58 <Botty> > let count x xs = length $ filter (==x) xs in count 'b' "bouncing bable-fishies"
23:12:59 <lambdabot>  3
23:13:00 <lispy> Cale: http://web.engr.oregonstate.edu/~budd/SmallWorld/Source/SmallObject.java
23:13:04 <lambdabot> http://tinyurl.com/yllt62
23:13:19 <Botty> > let count x = length . filter (==x) in count 'b' "bouncing bable-fishies"
23:13:20 <lambdabot>  3
23:13:39 <lispy> Cale: i'm open to ideas on how to encode this, but i have to say, the way it's done in java right now makes a lot of sense
23:14:22 <Cale> well, the way it's done in Java is essentially using the similarity between Java and Smalltalk to lift things :)
23:14:38 <Cale> So what are the cases?
23:14:57 <Cale> Object, Int, ByteArray, JavaObject, Exception...
23:14:58 <lispy> cases?
23:15:19 <Cale> are there any other children of SmallObject
23:15:35 <lispy> i dont' see any others
23:15:49 <lispy> but i know smalltalk has a bit more
23:15:53 <lispy> like it has metaclasses
23:15:55 <lispy> but i dont' see those
23:16:59 <Cale> But there aren't many
23:17:04 <lispy> right
23:17:05 <Cale> You could use an algebraic datatype
23:17:14 <lispy> yeah
23:17:29 <lispy> how do thinsg like wxHaskell solve this problem?
23:18:58 <Cale> One thing you'll notice about the Java implementation is that it does a lot of downcasts.
23:19:15 <lispy> well, yeah that's java :)
23:19:25 <lispy> what does that mean for us?
23:19:32 <Cale> That's what we can't do with existentials.
23:19:43 <araujo> lispy, writing a smalltalk implementation on haskell?
23:19:48 <Cale> (and why the direct translation is stupid)
23:19:58 <lispy> araujo: yes, based on a minimal smalltalk in java
23:20:05 <araujo> lispy, cool
23:20:18 <lispy> Cale: okay, i'll try a sum type
23:20:26 <Cale> yeah, I think that'll work out okay
23:20:29 <araujo> lispy, you already have a darcs repo? :-)
23:20:34 <lispy> oh, maybe  a GADT is good?
23:20:46 <Cale> These objects are not objects for the sake of encapsulating much of anything interesting.
23:20:46 <lispy> araujo: yes, but no code to check in :)
23:20:54 <araujo> argh :-)
23:21:07 <Cale> Well, only go to a GADT if using an ADT becomes a problem
23:21:16 <lispy> ah
23:21:34 <Cale> GADTs are what you use when you want to hijack Haskell's typesystem for your EDSL.
23:22:00 <dons> ?users
23:22:00 <lispy> interesting way to look at it
23:22:01 <lambdabot> Maximum users seen in #haskell: 265, currently: 216 (81.5%), active: 30 (13.9%)
23:22:08 <lispy> dons: oh, that was snappy
23:22:35 <dons> yeah, i fixed the bit of thunkful state.
23:22:59 <Cale> Oh, the Exception type is just at the Java level, so that's not part of it
23:23:22 <lispy> Cale: so, do i even need a data constructor for SmallObject?
23:23:38 <araujo> <lispy> oh hrm...to make a smalltalk interpreter you apparently have to do graphics
23:23:39 <Cale> I think you do.
23:23:51 <araujo> Not necessarily ...
23:24:05 <araujo> check gnu-smalltalk for instance
23:24:10 <Cale> Unless you want to do something zany and represent it all as a single tree
23:24:11 <lispy> araujo: ah, this one uses a lot of 2d graphics stuff
23:24:13 <dons> hey pkhuong
23:24:31 <lispy> Cale: isn't that what we're planning to do?
23:24:35 <dons> we've got a sizeable chunk of the reddit FP community here now. yay!
23:24:46 <pkhuong> dons: hey. Figured i'd check in before dropping dead tired.
23:24:52 <dons> :)
23:25:00 <Cale> lispy: sort of :)
23:25:33 <dons> > fix $ \f -> 1 : 1 : zipWith (+) f (tail f) -- have a complimentary lambda
23:25:35 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
23:25:39 <pkhuong> dons: I blame you for this (http://paste.lisp.org/display/29256), btw. I totally intended to go with a state machine DSL, but adding serialisable closures was too easy.
23:25:47 <lispy> Cale: and i'm not sure what to do with the SmallJavaObject class
23:26:26 <dons> pkhuong: oh, that rocks!
23:26:50 <dons> Cale: see that?
23:26:51 <lisppaste2> lispy annotated #29258 with "Cale, something like this?" at http://paste.lisp.org/display/29258#4
23:27:18 <Cale> lispy: yeah
23:27:21 <lispy> pkhuong++
23:28:24 <lispy> Cale: well, in that case i may be done with the data declaration for the SmallTalk values
23:28:37 <pkhuong> dons: not that sure, we get `cool' URLs, but making them human readable doesn't seem as straightforward as with a state machine. We'll see...
23:28:56 <Cale> lispy: indeed, I expect you are
23:29:04 <wolverian> dons, by the way, did audrey answer you about monads in perl6?
23:29:11 <wolverian> (or pugs)
23:29:12 <Cale> lispy: you might decide to use a ByteString :)
23:29:18 <lispy> Cale: the hard part will be figuring out what is inside the "image"
23:29:24 <dons> wolverian: nope.
23:29:32 <lispy> Cale: instead of [Word8]?
23:29:36 <lispy> Cale: i want simple and easy for now
23:29:37 <Cale> yeah
23:29:39 <wolverian> dons, okay. just checking. :)
23:29:44 <lispy> but that's certainly a good idea
23:31:36 <lispy> Cale: i think SmallInterpreter should be a state monad
23:31:42 <satan> hello all :)
23:31:43 <lispy> or at least some form of monad
23:31:47 <lispy> satan: wb
23:31:58 <satan> thx, lispy
23:32:14 <lispy> mm...good adio :)
23:32:17 <lispy> audio*
23:32:24 <satan> so i've been trying to get that infinite series function of mine working and i think i'm almost there :)
23:32:32 <lispy> oh, neat
23:32:45 <Botty> infixParse o s (LPar:RPar:xs) =
23:32:45 <Botty> infixParse o s (x:xs)
23:32:50 <Botty> would this be legal
23:32:52 <Botty> ?
23:32:52 <satan> thanks to twanvl earlier, i had something that worked for finite lists, and looking at that, i came up with my own
23:33:00 <Botty> (the second one is defined)
23:33:10 <Botty> (and i haven't written the first's defs)
23:33:18 <Botty> (the point is the pattern)
23:34:17 <satan> the function should give an answer of [6,19,12,23,12,6,0] when called with fn [2,5,0,6] [3,2,1,0], but all i get is [6,19,12,23]
23:34:20 <satan> the code is at http://nanobin.nanosouffle.net/1828
23:34:20 <Cale> pkhuong, dons: neat!
23:34:23 <lambdabot> Title: nanoPaste your Crap
23:34:35 <satan> if anyone could have a look and let me know how to get those last missing terms... :S
23:34:44 <workbean> guys, why can't I do ($ 1 2) (+)?
23:35:09 <lispy> ?type ($ 1 2)
23:35:11 <lambdabot> forall a b. (Num (Integer -> a)) => (a -> b) -> b
23:35:30 <lispy> ?type (+)
23:35:31 <lambdabot> forall a. (Num a) => a -> a -> a
23:35:39 <lispy> type error :)
23:35:42 <Cale> ($ 1 2) = \x -> x $ 1 2
23:35:47 <Botty> that's retarded...
23:35:48 <lispy> > ($ 1 2) (+1)
23:35:49 <lambdabot>  add an instance declaration for (Num (t -> a))
23:35:59 <monochrom> I don't understand ($ 1 2) either.
23:35:59 <Cale> So you're applying 1 to 2
23:36:09 <Botty> ohh
23:36:17 <Cale> and so unless 1 is a function capable of taking 2 as a parameter...
23:36:25 <lispy> > ($ 1) (+1)
23:36:26 <lambdabot>  2
23:36:38 <lispy> > (id 1) (+1)
23:36:39 <lambdabot>  add an instance declaration for (Num ((a -> a) -> a1))
23:36:47 <lispy> > (const id 1) (+1)
23:36:48 <lambdabot>  Add a type signature
23:36:55 <jdev> > (($ 1).($ 2)) (+)
23:36:56 <lambdabot>  3
23:37:03 <Cale> > (`id` 1) (+1)
23:37:03 <jdev> > (($ 1).($ 2)) (-)
23:37:04 <lambdabot>  2
23:37:05 <lispy> jdev: nice one
23:37:05 <lambdabot>  1
23:37:07 <Botty> jdev - i was about to do that >_<
23:37:09 <Cale> > (flip id 1) (+1)
23:37:11 <lambdabot>  2
23:37:14 <lispy> ?pl (($ 1).($ 2)) (+)
23:37:14 <lambdabot> 3
23:37:24 <Cale> @type flip id
23:37:24 <Botty> i'm a newb though, wasn't sure if it'd work
23:37:26 <lambdabot> forall b c. b -> (b -> c) -> c
23:37:30 <lispy> wait a sec
23:37:32 <lispy> ?pl (($ 1).($ 2)) (+)
23:37:32 <lambdabot> 3
23:37:35 <lispy> omg!
23:37:38 <Botty> lol
23:37:43 <Cale> heh
23:37:44 <lispy> lambdabot++
23:37:58 <lispy> i didn't know pl could do computation
23:38:01 <lispy> ?pl 1 + 2
23:38:02 <lambdabot> 3
23:38:11 <Botty> > ($1 . $2) (+)
23:38:12 <lambdabot>  Parse error
23:38:27 <Botty> > ($ 1 . $ 2) (+)
23:38:28 <lambdabot>  Parse error
23:38:57 <Botty> ((.) $ 1 $ 2) (+)
23:39:06 <Botty> > ((.) $ 1 $ 2) (+)
23:39:07 <lambdabot>  add an instance declaration for (Num (a1 -> (a -> a) -> c))
23:39:24 <Botty> ah nevermind
23:41:45 <workbean_> sorry guys, got disconnected, thanks
23:43:35 <workbean_> this partial evaluation stuff is very tricky
23:43:39 <pkhuong> can you think of some paper exploring the parallel between CPS and monads, if any?
23:46:49 <lispy> pkhuong: i know i've seen mention of it
23:48:08 <pkhuong> lispy: it's tickling my brain, but I can't articulate anything yet. Very annoying.
23:48:17 <Botty> hehe, I just misread "mconcat" in the docs as "mooncat"
23:48:28 <lispy> pkhuong: well, certainly you can implement CPS with a monad
23:48:37 <lispy> howling like mooncat
23:49:36 <pkhuong> lispy: yeah, I was hoping for something a bit more general.
23:54:03 <satan> > tail $ scanl (flip (:)) [] [1..5]
23:54:04 <lambdabot>  [[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1]]
23:55:58 <satan> how would i prepend a certain # of zeroes to future sublists, upto a specified number? say i wanted 3 more, for output of [[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1],[0,5,4,3,2,1],[0,0,5,4,3,2,1],[0,0,0,5,4,3,2,1]]
23:57:58 <araujo> > (.) (+) id 1 2
23:57:59 <lambdabot>  3
