00:04:05 * EvilRanter is away: z.
00:23:47 <tibbe> > let intercalate = concat . intersperse in intercalate " " ["good", "morning"]
00:23:48 <lambdabot>    Expecting a function type, but found `b'
00:23:48 <lambdabot>    Expected type: a1 -> [[a]...
00:24:04 <tibbe> gack
00:24:37 <Botty> @pl foldl (\a b -> a ++ show b) ""
00:24:37 <lambdabot> foldl ((. show) . (++)) []
00:24:57 <dons> ?type intersperse
00:24:58 <lambdabot> forall a. a -> [a] -> [a]
00:25:06 <tibbe> eh
00:25:16 <emu> @pl \x y -> concat (intersperse x y)
00:25:17 <lambdabot> (join .) . intersperse
00:25:24 <tibbe> > let intercalate x = concat . intersperse x in intercalate " " ["good", "morning"]
00:25:25 <lambdabot>  "good morning"
00:25:58 <tibbe> ?type join
00:25:59 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
00:26:21 <Botty> > intersperse " " ["good", "morning"]
00:26:23 <lambdabot>  ["good"," ","morning"]
00:26:26 <Botty> ah
00:30:03 <mwc> wtf... INTERCAL?
00:31:08 <dons> ?web1913 intercalate
00:31:10 <lambdabot> *** "Intercalate" web1913 "Webster's Revised Unabridged Dictionary (1913)"
00:31:10 <lambdabot> Intercalate \In*ter"ca*late\, v. t. [imp. & p. p.
00:31:10 <lambdabot>   {Intercalated}; p. pr. & vb. n. {Intercalating}.] [L.
00:31:10 <lambdabot>   intercalatus, p. p. of intercalare to intercalate to
00:31:10 <lambdabot>   intercalate; inter between + calare to call, proclaim. See
00:31:12 <lambdabot> [10 @more lines]
00:31:23 <dons> ?more
00:31:23 <lambdabot>   {Calendar}.]
00:31:24 <lambdabot>   1. (Chron.) To insert, as a day or other portion of time, in
00:31:24 <lambdabot>    a calendar.
00:31:24 <lambdabot>  
00:31:24 <lambdabot>   2. To insert among others, as a verse in a stanza; specif.
00:31:25 <Botty> > concat $ intersperse ["he" ++ (replicate 2 'l') ++ "o", reverse "dlrow"]
00:31:26 <lambdabot> [5 @more lines]
00:31:30 <lambdabot>    Expecting a function type, but found `a'
00:31:32 <lambdabot>    Expected type: [[a]]
00:31:34 <lambdabot>   ...
00:32:03 <tibbe> haha
00:32:05 <Botty> > concat $ intersperse [("he" ++ (replicate 2 'l') ++ "o"), (reverse "dlrow")]
00:32:07 <lambdabot>    Expecting a function type, but found `a'
00:32:07 <tibbe> same as me
00:32:07 <lambdabot>    Expected type: [[a]]
00:32:07 <lambdabot>   ...
00:32:15 <tibbe> > let intercalate = concat . intersperse in intercalate " " ["good", "morning"]
00:32:16 <lambdabot>    Expecting a function type, but found `b'
00:32:16 <lambdabot>    Expected type: a1 -> [[a]...
00:32:17 <Botty> > concat $ intersperse ' ' [("he" ++ (replicate 2 'l') ++ "o"), (reverse "dlrow")]
00:32:18 <lambdabot>  Couldn't match `[a]' against `Char'
00:32:22 <dons> Botty: what are you trying to intersperse?
00:32:42 <dons> > intersperse ' ' "haskell"
00:32:43 <lambdabot>  "h a s k e l l"
00:32:44 <Botty> concat (intersperse " " [("he" ++ (replicate 2 'l') ++ "o"), (reverse "dlrow")])
00:32:57 <Botty> > concat (intersperse " " [("he" ++ (replicate 2 'l') ++ "o"), (reverse "dlrow")])
00:32:59 <lambdabot>  "hello world"
00:33:03 <Botty> finally, jeez
00:33:15 <dons> :)
00:33:51 <tibbe> ?type mapM
00:33:52 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
00:33:59 <xerox> (concat .) . intersperse " " :)
00:34:10 <Botty> I imagine someone has already written a lib for perfectly precise numbers
00:34:18 * Botty is writing his own anyway
00:34:25 <xerox> ?docs Data.Rational
00:34:26 <lambdabot> Data.Rational not available
00:34:28 <xerox> ?docs Data.Ratio
00:34:29 <tibbe> mapM putStrLn ["hi","there"]
00:34:29 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Ratio.html
00:34:36 <tibbe> > mapM putStrLn ["hi","there"]
00:34:37 <mwc> Wow, that'd be awesome if you could get all the numbers in there
00:34:37 <lambdabot>  No IO allowed
00:34:40 <Botty> ratio isn't perfectly precise
00:34:55 <xerox> I'm not sure what you mean then
00:34:57 <mwc> > pi :: Rational
00:34:58 <lambdabot>  add an instance declaration for (Floating Rational)
00:34:58 <lambdabot>   In the expression: ...
00:35:26 <tibbe> ?type mapM putStrLn ["hi","there"]
00:35:28 <lambdabot> IO [()]
00:35:56 <xerox> tibbe: you might even do mapM_ to be explicit about the fact that you are discarding the result of the actions
00:36:07 <tibbe> ?type mapM_
00:36:09 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
00:36:09 <xerox> (i.e. you are only interested in the effect)
00:36:11 <tibbe> xerox: :)
00:36:25 <Botty> how about rational powers?
00:36:41 <dolio> > 10^5 :: Rational
00:36:43 <lambdabot>  100000%1
00:37:00 <Botty> > (1%3) ** ((-1)%2)
00:37:01 <lambdabot>  add an instance declaration for (Floating (Ratio a))
00:37:02 <lambdabot>   In the definition ...
00:37:09 <Botty> > (1%3) ^ ((-1)%2)
00:37:10 <lambdabot>  add an instance declaration for (Integral (Ratio a))
00:37:11 <lambdabot>   In the definition ...
00:37:16 <mwc> > approxRational pi 0.01
00:37:18 <lambdabot>  22%7
00:37:25 <mwc> Nicely done...
00:37:28 <mwc> > approxRational pi 0.001
00:37:29 <lambdabot>  201%64
00:37:37 <mwc> > approxRational pi 0
00:37:39 <lambdabot>  884279719003555%281474976710656
00:37:50 <Botty> mwc - my stuff will handle pi perfectly
00:37:53 <xerox> (:
00:37:54 <tibbe> > 884279719003555%281474976710656
00:37:56 <lambdabot>  884279719003555%281474976710656
00:37:57 <xerox> ?keal
00:37:58 <lambdabot> i lack in verbal and social expression
00:38:04 <tibbe> > 884279719003555%281474976710656 :: Double
00:38:05 <lambdabot>  Couldn't match `Double' against `Ratio a'
00:38:17 <Botty> and other constants, as long as you can calculate the next digit iteratively
00:38:43 <mwc> Botty, how so... I can't htink of a way to represent a transcendental perfectly on a computer
00:39:16 <Botty> basically, you store the operations applied to the number, and simplify as you go
00:39:27 <mwc> at least with mere reals you can do things like pow(2,1/2)
00:39:38 <mwc> that's what I was thinking, so represent pi*e for me
00:39:49 <Botty> I haven't really figured it all out, I'm not super mathy (yet)
00:40:12 <mwc> It strikes me as being problematic since you'll need an infinite set of transcendental constants
00:40:37 <dolio> Well, you only need the transcendental constants that people actually use.
00:40:45 <Botty> well, that'll be represented as (Product [Const "pi", Const "e"])
00:40:47 <Botty> :)
00:41:07 <mwc> right, so then you're limited to a finite number of transcendental constants
00:41:24 <dobblego> why does take not error or return Maybe for n where n > length?
00:41:26 <Botty> This will also handle diminsional analysis by using things like meters and seconds and such
00:41:27 <mwc> that should be sufficient for most people
00:41:34 <Botty> (by the same method)
00:41:36 <xerox> Ever used Mathematica, or other CAS?
00:41:37 <mwc> what you're really doing is what CAS's do
00:42:07 <Botty> dobblego - probably figured it was more useful just to ignore the error
00:42:22 <dobblego> hm
00:43:03 <dobblego> drop is the same, returning []
00:43:04 <Botty> there are more cases where you would want to take a certain number or less, than there are where you'd want it to take a certain number or error
00:43:27 <Botty> xerox - me? no.
00:43:47 <Botty> well, I used the mathbot on #math a bit
00:49:54 <Botty> *Main> show (Product [(Power (Const "e") (I 2)), (Const "pi")])
00:49:54 <Botty> "pie^2"
00:49:56 <Botty> tee-hee
00:51:26 <Patterner> what is the volume of a pizza with radius z and height a?
00:52:52 <ibid> assume a sylinderial pizza. then the answer might be a*pi*z^2
00:53:03 <ibid> *sylinderical
00:53:46 <dolio> Cylindrical.
00:53:50 <Botty> HAHAHA
00:53:52 <Botty> pizza
00:55:06 <Botty> (only reason that's funny is because it didn't dawn on you
00:55:13 <ibid> hah. of course, you do need to make the assumption that i made, and no pizza that i know is perfectly cylindrical
00:55:37 <ibid> +of
00:56:18 <Botty> true.  He only gave enough degrees of freedom for a cylinder though
00:57:08 <ibid> besides, the answer is *not* pizza, because that's p*i*z*z*a, and not pi*z*z*a
00:59:06 <Botty> πzza then
00:59:40 <ibid> and the joke spoils when you go unicode: πzza
01:00:13 <Botty> nah, I think I'll start calling it piezza
01:00:35 <ibid> well, pizza is just a glorified pie :)
01:05:20 <xerox> In Italian pizza and pi*z*z*a sound the same :)
01:26:07 <rdivacky> hi
01:26:18 <rdivacky> is there any nice/small example on how to use mutable arrays?
01:36:14 <vegai> http://www.acc.umu.se/~zqad/cats/Schroedingerscatwanted.jpg
01:36:33 <lambdabot> http://tinyurl.com/yj744d
01:45:30 <rdivacky> anyone who can help me with mutable arrays? :)
01:47:10 <mwc> rdivacky, ST or IO?
01:47:28 <rdivacky> ST
01:48:17 <rdivacky> I am trying to invent some simple example.... create array of 10 zeros and then print 3rd one
01:48:21 <mwc> I had some nice code that did an imperative quicksort on an ST mutable array, but alas my powerbook's died and it's gone
01:49:06 <Botty> @pl concat $ intersperse " * " $ foldl (\x y -> x ++ show y) ""
01:49:07 <lambdabot> join (intersperse " * " (foldl ((. show) . (++)) []))
01:49:27 <rdivacky> mwc: can you help me with the example I described?
01:49:48 <Botty> @pl concat $ intersperse " * " $ foldl (\x y -> x ++ show y) "" sortBy (monoPos)
01:49:49 <lambdabot> join (intersperse " * " (foldl ((. show) . (++)) [] sortBy monoPos))
01:50:14 <mwc> rdivacky, let me see that I know what I'm doing :)
01:51:55 <rdivacky> I seem to have problem combining the IO and MArray monad
01:53:09 <Botty> > join (intersperse " * " (foldl ((. show) . (++)) [])) [1,2]
01:53:11 <lambdabot>  Couldn't match `(->) t' against `[]'
01:53:37 <Botty> > join (intersperse " * " (foldl ((. show) . (++)) [])) $ [1,2]
01:53:38 <lambdabot>  Couldn't match `(->) a' against `[]'
01:53:59 <Botty> > (join (intersperse " * " (foldl ((. show) . (++)) []))) [1,2]
01:54:00 <lambdabot>    Expecting a function type, but found `[a]'
01:54:01 <lambdabot>    Expected type: [[Char]]...
01:54:35 <Botty> > concat $ intersperse " * " $ foldl (\x y -> x ++ show y) "" [1,2]
01:54:36 <lambdabot>  Couldn't match `[Char]' against `Char'
01:55:07 <Botty> DOH!
01:55:28 <Botty> > concat $ intersperse " * " $ map (show) [1,2]
01:55:30 <lambdabot>  "1 * 2"
01:55:49 <Botty> @pl concat $ intersperse " * " $ map (show)
01:55:50 <lambdabot> join (intersperse " * " (map show))
01:56:34 <Botty> @pl concat $ intersperse " * " $ map (show) (sortBy monoPos)
01:56:35 <lambdabot> join (intersperse " * " (map show (sortBy monoPos)))
01:56:46 <Botty> sorry for the bot-spam
01:57:46 <mwc> rdivacky, it's a real mess involving a lot of explicit type annotations
01:58:02 <mwc> turn on GHC exts and start adding them unitl things work
01:58:17 <rdivacky> mwc: the problem is that I dont have a slightest clue how to do it ;(
02:08:36 <rdivacky> whats wrong with this
02:08:37 <rdivacky> ar1 <- newArray (0, x) (newArray (0, y) 0)
02:08:49 <rdivacky> (trying to make 2D array)
02:11:58 <wilx> Hm...newArray returns IO action.
02:12:32 <wilx> @type newArray
02:12:34 <lambdabot> Not in scope: `newArray'
02:12:40 <wilx> @type Data.Array.newArray
02:12:42 <lambdabot> Not in scope: `Data.Array.newArray'
02:12:50 <wilx> @info newArray
02:12:50 <lambdabot> newArray
02:13:07 <rdivacky> I dont understand how to make 2D array
02:13:20 <Botty> ?hoogle newArray
02:13:22 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
02:13:22 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
02:13:22 <lambdabot> Foreign.Marshal.Array.newArray :: Storable a => [a] -> IO (Ptr a)
02:13:23 <wilx> Well, I would use 1D array.
02:13:30 <wilx> And compute the indicies myself.
02:13:37 <rdivacky> hm... thats possible
02:13:37 <Lemmih> rdivacky: How about: newArray ((0,0),(x,y)) ?
02:13:49 <wilx> Ah.
02:13:51 <wilx> Indeed.
02:14:29 <rdivacky> lemme try that
02:14:55 <Botty> better way of doing something like
02:14:57 <Botty> noI (I n) = False
02:14:57 <Botty> noI _ = True
02:14:57 <rdivacky> doesnt seem to work
02:14:58 <Botty> ?
02:15:13 <Lemmih> rdivacky: It should.
02:15:38 <rdivacky>   Couldn't match `Int' against `(a, b)'
02:15:38 <rdivacky>       Expected type: Int
02:15:38 <rdivacky>       Inferred type: (a, b)
02:15:42 <emu> woot
02:15:45 <rdivacky> ah.. my fault
02:16:04 <emu> free airport wireless!
02:16:06 <rdivacky> ok, thnx :)
02:19:59 <matthew-_> @seen igloo
02:20:00 <lambdabot> igloo is in #darcs, #haskell and #ghc. I last heard igloo speak 6h 58m 59s ago.
02:21:20 <matthew-_> does anyone know how to debuild the ghc6-6.6 src debian package with the extralibs such that it produces the extra libs in the ghc6 package?
02:22:19 <matthew-_> eg, I need the hopengl package, but it's not available yet - libghc6-hopengl-dev doesn't exist.
02:33:52 <rdivacky> may I write [[Int]] to a 2D IOUArray directly?
02:35:17 <dons> you can write a list to an array, yeah
02:35:34 <rdivacky> how?
02:46:42 <rdivacky> I invented this
02:46:43 <rdivacky>   let bah = [ writeArray arr (x, y) (toI ((fileLines !! x) !! y)) |
02:46:43 <rdivacky>                                 x <- [0..const_x], y <- [0..const_y]]
02:46:43 <rdivacky>                         sequence bah
02:49:17 <_roconnor> @type array
02:49:18 <lambdabot> forall e i. (Ix i) => (i, i) -> [(i, e)] -> Array i e
02:50:00 <_roconnor> [(0,0)..(2,2)]
02:50:04 <_roconnor> > [(0,0)..(2,2)]
02:50:05 <lambdabot>  add an instance declaration for (Enum (a, b))
02:50:06 <lambdabot>   In an arithmetic sequence...
02:52:08 <roconnor> array [((x,y), toI z) | (x,l) <- zip [0..] fileLines, (y,z) <- zip [0..] l]
02:53:53 <rdivacky> is this 2D mutable array?
02:54:07 <roconnor> immutable
02:54:48 <roconnor> oh forgot the bounds
02:54:58 <roconnor> hmmm
02:55:29 <roconnor> array ((0,0),(const_x,const_y)) [((x,y), toI z) | (x,l) <- zip [0..] fileLines, (y,z) <- zip [0..] l]
02:56:08 <rdivacky> I'd better fix my case
02:59:52 <roconnor> array ((0,0),(const_x,const_y)) [((x,y), toI z) | (x,l) <- zip [0..const_x] fileLines, (y,z) <- zip [0..const_y] l]
03:05:59 <rdivacky> writePattern arr = sequence [ x | x <-
03:06:00 <rdivacky>                                         do
03:06:00 <rdivacky>                                            c <- readArray arr (x, 0)
03:06:00 <rdivacky>                                            putStr $ show c, x <- [0..const_x - 1]
03:06:06 <rdivacky> how to indent this?
03:17:53 <matthew-_> @seen igloo
03:17:54 <lambdabot> igloo is in #darcs, #haskell and #ghc. I last heard igloo speak 7h 56m 53s ago.
04:13:01 <rdivacky> printX :: (IOUArray (Int, Int) Int) -> (Int, Int) -> IO ()
04:13:06 <rdivacky> let bah = [ printX arr (x,y) | x <- [0..const_x - 1], y <- [0..const_y - 1]]
04:13:08 <rdivacky> what type is bah?
04:13:12 <rdivacky> [IO ()] right?
04:13:28 <ElPenguin> why don't you ask the bot?
04:13:38 <rdivacky> I dont know how
04:14:50 <rdivacky> ghc itself seems confused
04:15:08 <rdivacky> it sometimes says [IO ()] and sometimes [IO [a]]
04:20:26 <Lemmih> rdivacky: You probably want: mapM_ (printX arr) [ (x,y) | x <- ..., y <- ... ]
04:21:33 <rdivacky> Lemmih: I have working code now
04:21:40 <rdivacky> but it requires "putStr """ on the end of the do
04:22:40 <rdivacky> your solution works nice
04:22:41 <rdivacky> thnx
04:41:53 <tobbes> greetings.
04:42:53 <tobbes> I've built a function that should calculate the total product of all numbers in a range
04:43:02 <tobbes> I've defined it as follows:
04:43:49 <tobbes> range_product x y = case x == y of
04:43:49 <tobbes>                          True -> x
04:43:49 <tobbes>                          False -> x*(x+1) * range_product(x+1) y
04:44:09 <wolverian> @pl \x -> [x]
04:44:10 <lambdabot> return
04:44:13 <wolverian> heh.
04:44:39 <tobbes> and then I'm trying to define faculty as x > 0 = range_product 1 x
04:44:45 <tobbes> what am I missing
04:44:59 <tobbes> 'cause I don't get correct results for the fac
04:45:52 <Botje> why the x*(x+1) ?
04:46:33 <tobbes> I should mutiply hmm good question...
04:46:54 <tobbes> should work with just x * range_product x+1 y
04:47:05 <Botje> yeah
04:47:13 <Botje> so what should range_product 5 5 be ?
04:49:19 <tobbes> I don't know
04:49:22 <tobbes> actually
04:49:43 <tobbes> it just says that i should range from x to y-1
04:50:02 <Botje> so you should just return 1 if x == y
04:50:10 <tobbes> so that the last one should be 4*5
04:50:29 <tobbes> don't I have to return 5 ?
04:51:04 <Botje> if you want fac to be defined as range_product 1 n
04:51:12 <Botje> you have to return y (or x) when x == y
04:51:20 <tobbes> yeah
04:51:34 <tobbes> so 5 in this example, right?
04:51:40 <Botje> yeah
04:52:47 <tobbes> hmm still doesn't work
04:53:17 <tobbes> I've defined fac x > 0 as range_product 1 x
04:53:24 <tobbes> but fac 2 gives me 2
04:53:54 <tobbes> hmm wait
04:54:03 <tobbes> fac 0 is defined as 1
04:54:05 <Botje> > let range_prod x y = if x == y then y else x * range_prod (x+1) y in range_prod 1 5
04:54:06 <lambdabot>  120
04:54:10 <Botje> works for me :)
04:57:06 <tobbes> range_product x y = case x == y of
04:57:06 <tobbes>                          True -> x
04:57:06 <tobbes>                          False -> x*range_product(x+1) y
04:57:32 <tobbes> and fac x > 1 = range_product 1 x
04:58:54 <tobbes> still fac 2 return 2
04:59:25 <Botje> but that's the correct answer ..
05:01:04 <tobbes> ha
05:01:09 <tobbes> you're right
05:01:11 <tobbes> :)
05:01:16 <tobbes> thx :)
05:18:18 <dons> ?yow
05:18:19 <lambdabot> My mind is making ashtrays in Dayton ...
05:18:21 <dons> ?users
05:18:22 <lambdabot> Maximum users seen in #haskell: 265, currently: 237 (89.4%), active: 10 (4.2%)
05:18:25 <dons> ?uptime
05:18:26 <lambdabot> uptime: 4d 13h 15m 15s, longest uptime: 6d 23h 44m 3s
05:32:36 <vincenz> Hi
05:36:27 <wolverian> @pl concatMap (\x -> [fst x])
05:36:29 <lambdabot> (fst `fmap`)
05:36:36 <wolverian> whoa.
05:37:26 <vincenz> wolverian: sort of lame to do a concatMap like that
05:37:30 <vincenz> you could just write
05:37:33 <vincenz> map (\x -> fst x)
05:37:42 <vincenz> @pl map (\x -> fst x)
05:37:43 <lambdabot> map fst
05:37:51 <vincenz> which is the same as fst `map`
05:38:11 <lennart> ?users
05:38:12 <lambdabot> Maximum users seen in #haskell: 265, currently: 236 (89.1%), active: 10 (4.2%)
05:38:22 <wolverian> erm, sheesh. yeah.
05:38:23 <wolverian> thanks
05:39:05 <vincenz> > return "lambda-cookie" >>= replicate 236
05:39:06 <lambdabot>  ["lambda-cookie","lambda-cookie","lambda-cookie","lambda-cookie","lambda-coo...
05:39:57 <psykotic> stupid question, but why is head :: [a] -> a rather than head :: [a] -> Maybe a?
05:40:18 <vincenz> psykotic: choices
05:40:20 <Philippa> lisp
05:40:27 <Philippa> or more generally, history
05:40:31 <lennart> history and usefulness
05:40:33 <Philippa> head existed before Maybe did
05:40:49 <vincenz> that works too :)
05:41:05 <psykotic> but there's no way to deal gracefully with head failure, right?
05:41:15 <vincenz> nopes
05:41:19 <lennart> if you don't know if the list is non-empty you should use pattern matching on the list
05:41:23 <psykotic> (i know that you're supposed to deconstruct lists with pattern matching)
05:41:36 <vincenz> hey flippa
05:41:40 <Philippa> think of it as unsafeHead, I guess
05:41:45 <Philippa> 'lo vincenz
05:42:31 <lennart> except it's not unsafe in the way of unsafePerformIO
05:42:42 <lennart> maybe unsoundHead
05:43:04 <Philippa> true, there's no sense in which head'll cause the universe to stop making sense
05:43:52 <lennart> it'll just stop the universe altogether :)
05:44:00 <lennart> if the universe is the program
05:44:21 <Philippa> sure, but we're hoping it'll terminate anyway, right?
05:44:40 <lennart> perhaps
05:44:57 <Philippa> that, or we're doing IO and have another notion of universe to talk about
05:45:11 <lennart> yep
05:45:50 <lennart> let's ban bottom altogether, it's a pain
05:46:02 <Philippa> *winces*
05:46:06 <Philippa> *switches back into the right context*
05:46:12 <guerra> if i define a function that can result in an Integer or a String, shouldnt i define it as funct Int -> a?
05:46:13 <psykotic> hmm, a monad transformer just works out to a morphism in the category of monads, right? (a natural transformation between the functors with the induced diagrams all commutative)
05:46:20 <wolverian> ?hoogle (&&&)
05:46:21 <lambdabot> Did you mean: (&&&)
05:46:22 <lambdabot> Prelude.undefined :: a
05:46:22 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
05:46:28 <rdivacky> guerra: see Either
05:46:28 <wolverian> er, what?
05:47:00 <Lemmih> guerra: No, it should have the type: Int -> Either Integer String.
05:47:09 <lennart> guerra: if you claim your function returns 'a' it must return every type, not just In or String
05:47:09 <Philippa> lennart: when Epigram gets there... I need it in the meantime though
05:47:19 <Philippa> 'lo Smokey`
05:47:26 <psykotic> Philippa, epigram doesn't allow general recursion, right?
05:47:32 <Smokey`> 'lo Philippa :)
05:47:49 <lennart> psykotic: the idea is to allow general recursion in a monad
05:48:16 <guerra> rdivacky: see either where?
05:48:23 <psykotic> @type Either
05:48:24 <lennart> so you can tell what things can potentially yield bottom
05:48:24 <rdivacky> guerra: its a moand
05:48:25 <lambdabot> Not in scope: data constructor `Either'
05:48:29 <wolverian> hm. so there's no equivalent of (&&&) in the standard?
05:48:33 <psykotic> @kind Either
05:48:35 <lambdabot> * -> * -> *
05:48:50 <psykotic> lennart, interesting, how does that work?
05:48:58 <guerra> Lemmih: ooh cool will check it
05:49:02 <guerra> thanks
05:49:16 <Philippa_> that's the bit they've been working on :-) Presumably with an explicit recursion operator
05:49:19 <wolverian> @pl \x -> sort . nub $ tails xs ++ inits xs
05:49:20 <lambdabot> const (sort (nub (tails xs ++ inits xs)))
05:49:29 <wolverian> :/
05:49:43 <twanvl> @pl \xs -> sort . nub $ tails xs ++ inits xs
05:49:44 <lambdabot> sort . nub . liftM2 (++) tails inits
05:50:07 <psykotic> Philippa_, well you need to add something even to System F to get general recursion, but i'm assuming there are no technical issues with Epigram?
05:50:17 <psykotic> err, that there _are_ technical issues
05:50:26 <wolverian> twanvl, thanks
05:50:52 <psykotic> lennart: i like the idea of isolating recursion in a monad though. i guess the idea is that you can look at the type of a term and determine conservatively whether it is strongly normalizing?
05:51:07 <lennart> psykotic: exactly
05:51:17 <Philippa_> psykotic: I think it was a case of the design space being non-trivial and worth playing with
05:51:41 <wolverian> actually, what lambdabot gave doesn't typecheck
05:51:51 <lennart> psykotic: and terms that are not strongly normalizing cannot be used as proofs
05:52:23 <psykotic> right
05:52:54 <psykotic> that's a really neat idea actually.
05:53:01 <Philippa_> I had an idea about that one
05:53:27 <Philippa_> admittedly it mostly amounts to bundling in another form of proof that it terminates
05:53:43 <integral> wolverian: it does if (a->) is taken to be the reader monad
05:54:09 <wolverian> integral, oh. how do you know? :)
05:54:15 <wolverian> (asking seriously)
05:54:25 <integral> I guess that's what you're referring to :-)
05:54:42 <lennart> wolverian: it typechecks for me
05:54:45 <psykotic> does sectioning type constructors work generally?
05:54:59 <integral> (newtype Reader a t = Reader { runReader :: a -> t })
05:56:19 <wolverian> oh. yeah. it typechecks with Reader. :) thanks integral and lennart.
05:56:23 <lennart> psykotic: there is just one infix type constructor, so who knows if it works in general :)
05:56:59 <psykotic> lennart, yeah that was my thought, i can't think of any example other than the canonical environment/reader monad one :)
05:57:35 * vincenz mutters
05:57:40 <lennart> psykotic: well, i was thinking purely syntactically.  since sectioning is a syntactical concept
05:57:44 <vincenz> my paper got rejected with three 3s and one 2
05:57:51 <vincenz> And one guy seems to have missed the point
05:58:08 <lennart> psykotic: but partial application of type constructors works in general
05:58:09 <psykotic> lennart, i know, i meant that i've never seen any other use of type constructor sectioning than that one.
05:58:17 <psykotic> lennart, of course. :)
05:58:20 <psykotic> @kind (->)
05:58:22 <lambdabot> ?? -> ? -> *
05:58:26 <psykotic> err
05:58:29 <Philippa> vincenz: treat that as an opportunity to figure out how that happened and make sure they can't next time?
05:58:31 <psykotic> what the hell
05:58:38 <vincenz> Philippa: yeps, but it's such a borderline case
05:58:44 <vincenz> fwiw it could have been accepted
05:58:46 <Philippa> heh, those're Core kinds...
05:58:53 <lennart> psykotic: ghc has it's own little kind world
05:59:01 <vincenz> but the acceptance rate was only 17%
05:59:01 <lennart> with sub-kinds
05:59:17 <wolverian> integral, what I meant was that it was not obvious to me at all that I was looking at an application of Reader, and I wondered how you knw. :)
05:59:21 <wolverian> s,knw,knew,
05:59:41 <integral> wolverian: Oh, easy, people have asked that question before =)
05:59:52 <lennart> join (.) is my new favourite
05:59:59 <integral> @type join (.)
06:00:00 <lambdabot> forall c. (c -> c) -> c -> c
06:00:20 <lennart> > join (.) (+1) 0
06:00:22 <lambdabot>  2
06:00:51 <Philippa> vincenz: yeah, that's a bit of a kicker
06:00:54 <lennart> it's the good ole twice function
06:00:59 <psykotic> any inhabitant of forall c. (c -> c) -> c -> c must be n-fold application of the first argument, n >= 0, right?
06:01:05 <vincenz> Ah well, overall the feedback was positive
06:01:08 <vincenz> so at leasat they liked it :)
06:01:09 <lennart> psykotic: yes
06:01:12 <vincenz> just was missing some edge
06:01:36 <psykotic> lennart, ah right, the church numerals!
06:01:49 <lennart> vincenz: what was your paper about?
06:02:00 <psykotic> btw does anyone understand wadler's "recursive types for free" thing?
06:02:05 <vincenz> lennart: erm, I'd prefer not mentioning it until it gets accepted elsewhere
06:02:21 <lennart> ok, whatever
06:02:43 <psykotic> i was reminded right now because of the relationship between the recursive definition of Nat as Nat = mu X. 1 + X, and forall a. (a -> a) -> a -> a.
06:03:30 <kpreid> psykotic: what about undefined :: (c -> c) -> c -> c? does that count?
06:03:42 <psykotic> kpreid, bottom always sneaks in there. :)
06:03:43 <lennart> undefined never counts ;)
06:04:04 <integral> that's just n == oo ! :-P
06:04:07 <psykotic> it's there just for completeness's sake! :P
06:04:15 <psykotic> (bad lattice theory joke)
06:05:42 <lennart> vincenz: just a comment though.  i've found that a good way to improve a paper is to let others read and comment on it.
06:06:05 <vincenz> lennart: yeah but I'm resubmitting something close to it soon, and in our community it's all doubly blind reviewed
06:06:22 <vincenz> I do have people commenting on it, however ;)
06:07:02 <lennart> oh, double blind.  that's a stupid idea in my opinion, but nothing you as a submitter can do much about
06:07:17 <vincenz> it's pretty much std practice in my community
06:07:35 <merus> well, double-blind prevents certain political problems from popping up... sort of.
06:07:41 <lennart> i know it's standard in many communities.  it doesn't make it any better in my opinion
06:07:42 <merus> It allows other sorts of political problems.
06:08:08 <psykotic> like what? (genuinely curious)
06:08:09 <vincenz> I wasn't claiming it was better, just stating a fact :)
06:08:18 <lennart> vincenz: i know
06:08:23 <vincenz> either way, at times it's quite a hoax
06:08:27 <vincenz> it's still political as hell
06:08:35 <merus> Oh, yes.  Definitely.
06:08:40 <vincenz> the major players are known
06:08:47 <vincenz> and thus, some conferences tend to skew one way or the other
06:08:47 <merus> Yeah.
06:08:48 <lennart> vincenz: exactly
06:08:59 <vincenz> since I'm somewhat outside of the scope of where I work
06:09:03 <vincenz> I'm not that known :)
06:09:09 <merus> :)
06:09:09 <psykotic> what field is this?
06:09:16 <vincenz> design automation / embedded software
06:09:19 <merus> Being invisible is always preferable.
06:09:34 <merus> not a good way of getting grant money, but it keeps one sane.
06:09:40 <wolverian> integral, ah. :)
06:09:51 <vincenz> conferences such as: DATE, DAC, SCOPES, EMSOFT, (sometimes PLDI), CASES, SIPS, ...
06:10:01 <vincenz> TODAEs being the journal mirroring toplas
06:10:44 <vincenz> but yeah, I'm borderline
06:11:10 <vincenz> (erm, not in the personality sense :P)
06:12:12 <vincenz> lennart: what context do you publish in?
06:13:51 <vincenz> @join #oasis
06:14:55 <wolverian> integral, now.. can you tell me why it works? :)
06:15:54 <vincenz> merus: what context do you work in?
06:16:04 <_matthew-> @seen igloo
06:16:04 <lambdabot> igloo is in #darcs, #haskell and #ghc. I last heard igloo speak 10h 55m 4s ago.
06:16:18 <Igloo> _matthew-: ?
06:16:29 <_matthew-> ah!
06:16:44 <_matthew-> hi, I was just wondering about libghc6-hopengl-dev
06:16:50 <_matthew-> or rather, that lack of it!
06:16:58 <Igloo> It's in NEW
06:17:02 <integral> @type init
06:17:04 <lambdabot> forall a. [a] -> [a]
06:17:04 <integral> @type inits
06:17:06 <lambdabot> forall a. [a] -> [[a]]
06:17:09 <integral> wolverian: liftM2 (++) inits tails is using the monad ([x]->). inits :: ([x]->) [[x]] for example
06:17:14 <Igloo> You can grab source and amd64 packages from http://urchin.earth.li/~ian/gl/ in the mean time
06:17:16 <lambdabot> Title: Index of /~ian/gl
06:17:21 <_matthew-> oh! cool, is that the same as experimental? or pre experimental?
06:17:42 <Igloo> It's pre-unstable (in this case), and not accessible
06:17:44 <integral> @type Control.Monad.lifeM2
06:17:45 <lambdabot> Not in scope: `Control.Monad.lifeM2'
06:17:50 <integral> @type Control.Monad.liftM2
06:17:52 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
06:18:15 <integral> wolverian: liftM2's just a combinator which runs two monads and then purely combines their values
06:18:20 <psykotic> > init [1, 2, 3]
06:18:21 <lambdabot>  [1,2]
06:18:30 <psykotic> > init []
06:18:31 <lambdabot>  Add a type signature
06:18:36 <_matthew-> Igloo: ok, is there an eta into unstable?
06:18:43 <psykotic> > init [] :: [Int]
06:18:44 <wolverian> integral, I'm figuring it out. thanks a lot.
06:18:45 <lambdabot>  Exception: Prelude.init: empty list
06:18:51 <psykotic> haha, another of those ghetto functions exposed.
06:18:53 <integral> np.  hope I've helped
06:18:55 <Igloo> _matthew-: No
06:19:28 <_matthew-> oh. ok.
06:19:35 <wolverian> integral, hm. where does the ([x]->) monad come from?
06:19:44 <wolverian> (I can see how it fits.)
06:19:50 <merus> vincenz: I don't work in anything, yet.  I'm still an undergrad mathematics/physics/philosophy major.
06:20:01 <integral> wolverian: Oh, that's this reader monad again.   In real haskell, it's (Reader [x])
06:20:03 <merus> But I've been to enough conferences to see how things play out.
06:20:25 <wolverian> integral, why does Reader match here?
06:20:27 <vincenz> merus: you have, who pays for that?
06:20:28 * wolverian looks at it
06:20:34 <integral> undergrads going to conferences?!
06:20:41 <vincenz> integral: yeah exactly my thought
06:20:58 <merus> I just listen to the talks, really...
06:21:06 <merus> I don't contribute -- obviously.
06:21:10 <wolverian> integral, oh. :t Reader is relevant, right?
06:21:19 <integral> merus: Are these ones hosted at your own uni?
06:21:25 <integral> wolverian: :k Reader?
06:21:49 <merus> We don't actually host one here.
06:21:56 <vincenz> merus: it costs money to go to a confernece...
06:22:02 <wolverian> oh, I see. State would work too
06:22:02 <vincenz> unless you're talking local ones
06:22:17 <merus> I guess the department covers it.
06:22:29 <wolverian> is there a recommended monad for this? :)
06:22:33 <integral> wolverian: yeah.  Reader's all about having an "environment".  Just like global variables and perl's local :)
06:22:35 <vincenz> wolverian: the nomonad!
06:22:47 <vincenz> instance Monad No where
06:22:50 * merus shrugs.
06:22:52 <wolverian> heh.
06:22:55 <vincenz>   v >>= k = No
06:22:56 <Philippa> I'm having to pay my own train fare to Fun in the Afternoon :-(
06:23:01 <vincenz> return x = No
06:23:22 <wolverian> vincenz, that's a rude monad.
06:23:53 <Philippa> heh, I think it fulfills the monad laws too
06:24:00 <vincenz> fail x = No
06:24:10 <vincenz> Philippa: yep it does :)
06:24:35 <vincenz> type No = Not Yes
06:24:37 <vincenz> type Yes = ()
06:24:51 <merus> How hegelian.
06:24:53 <vincenz> erm, the first one shouuld be "data" not "type"
06:26:57 <vincenz> hey dmhouse
06:27:47 <guerra> guys i didnt suceed yet, i want just to return a message when the function receives an empty list, how could i do that? sorry for the noobsh :P
06:27:50 <psykotic> @pl (a -> a) -> a -> a
06:27:51 <lambdabot> (line 1, column 4):
06:27:52 <lambdabot> unexpected ">"
06:27:52 <lambdabot> expecting variable, "(", operator or ")"
06:28:04 <psykotic> @djinn (a -> a) -> a -> a
06:28:05 <lambdabot> f a = a
06:28:20 <vincenz> djinn gave you 'id'
06:28:22 <psykotic> yeah
06:28:28 <psykotic> does djinn just work by backward chaining from a basis set?
06:28:33 <integral> guerra: error :: String -> (forall a. a) ?
06:29:09 <psykotic> it might be fun to write a linear or affine logic version of djinn. often that gives you a better idea of the "generic inhabitant" of a type.
06:29:17 <psykotic> at least it seems that way to me.
06:30:47 <guerra> integral: what is "forall' for?
06:31:16 <vincenz> the result is polymorphic
06:31:16 <Philippa> the only inhabitant of "forall a.a" should be bottom
06:31:21 <vincenz> Philippa: whose?
06:31:46 <psykotic> Philippa, you could write that as forall a. String -> a, too, right? which is the same as String -> a in the usual implied forall quantifier convention?
06:32:01 <Philippa> you could, yes
06:32:09 <vincenz> really?
06:32:10 <vincenz> I would think that
06:32:18 <Philippa> but not generally
06:32:21 <vincenz> forall a. String -> a != String -> forall a. a
06:32:29 <Philippa> well, they're subtly different
06:32:30 <psykotic> vincenz, they are isomorphic anyway.
06:32:35 <vincenz> not really
06:32:36 <Philippa> the rank-1 version, the caller gets to choose what a is
06:32:37 <dmhouse> Hmm.
06:32:47 <dmhouse> I have an impulsive urge to work on the wikibook.
06:32:50 <Philippa> or rather, /has/ to, straight away
06:32:53 <vincenz> go dmhouse, go
06:33:05 <vincenz> exactly, the first one determines 'a' at call site
06:33:14 <vincenz> and then it's fixed
06:33:35 <vincenz> (I'm no type expert, but that's my gutfeeling)
06:34:27 <psykotic> vincenz, doesn't parametricity make them equivalent?
06:34:37 <psykotic> (me neither)
06:34:39 <vincenz> psykotic: what is "parametricity"?
06:34:57 <guerra> omg =/
06:34:57 <psykotic> well, what is an inhabitant of String -> (forall a. a)?
06:35:09 <dmhouse> const _|_
06:35:15 <vincenz> what dmhouse said
06:35:27 <vincenz> though yeah, the other one, idem
06:35:28 <psykotic> dmhouse, i'm talking more abstractly. what is an inhabitant of a polymorphic type? it is conceptually a tuple (T, t :: T), right?
06:36:01 <dmhouse> psykotic: I'm not sure I follow.
06:36:11 <vincenz> dmhouse: basically a tuple with a type and a value
06:36:20 <vincenz> psykotic: correct me if I'm wrong
06:36:25 <psykotic> yes
06:36:33 <vincenz> dmhouse: the type is encoded in the tuple as you don't know what it is cause it's polymorphic
06:36:39 <psykotic> just like an inhabitant of an existential type is a "witness type" and an element of that type.
06:36:50 <vincenz> "witness type"?
06:36:53 <dmhouse> Could you give an example?
06:37:06 <vincenz> (String, "lala")
06:37:07 <dmhouse> maxBound would do.
06:37:27 <dmhouse> (That's polymorphic without confusing things by introducing functions.)
06:37:41 <vincenz> maxbound is not polymorphic at runtime
06:37:59 <dmhouse> Ah. What is?
06:38:08 <vincenz> something that returns forall a.a
06:38:09 <psykotic> anyway, what i'm working up to is this. an element of String -> (forall a. a) is conceptually a tuple (T, f :: String -> T). an element of forall a. String -> T is conceptually a tuple (T, f :: String -> T).
06:38:13 <vincenz> an existential basically
06:38:30 <vincenz> psykotic: I disagree
06:38:32 <Philippa> psykotic: an inhabitant of a universal type isn't that tuple - that's the whole point, it doesn't need to be
06:38:40 <vincenz> String -> foral..
06:38:41 <vincenz> is
06:38:45 <vincenz> String -> (T, f::T)
06:38:52 <vincenz> the second one is what you wrote
06:38:56 <psykotic> Philippa, you can't _inspect_ the type but it's still there. just like a witness type for an existential.
06:39:02 <Philippa> forall a.a is conceptually \T->v::T
06:39:20 <vincenz> Philippa: right, and a tuple is an implementation of a function
06:39:24 <vincenz> (T, v)
06:39:33 <psykotic> Philippa, right, but can you tell me what an element of String -> (forall a. a) is conceptually in these kind of terms?
06:39:34 <vincenz> just one point in it, however :)
06:39:43 <psykotic> i'm actually trying to clear this up for myself
06:39:54 <vincenz> psykotic: it's non-existent
06:40:15 <psykotic> you can't say that the binding time is different because the concrete type of an instance can't depend on the String, that's my gutfeel.
06:40:33 <psykotic> vincenz, that's the solution, i'm trying to figure out the concrete spec of the problem.
06:40:35 <vincenz> it is different
06:40:35 <vincenz> !
06:40:37 <vincenz> look
06:40:39 <vincenz> once you use a function
06:40:42 <vincenz> forall a. String -> a
06:40:43 <vincenz> in some context
06:40:46 <vincenz> a is fixed
06:40:53 <vincenz> while the second one, the value can pass from one type to the next
06:41:04 <psykotic> yes, but i'm talking about isomorphisms between the types as a whole.
06:41:21 <psykotic> maybe it's a weaker kind of equivalence but it seems to be there, don't you agree?
06:41:29 <Philippa_> there's a weaker equivalence, yes
06:41:56 <vincenz> Anyways, I'm no expert, I'm just going on gutfeeling :)
06:42:23 <psykotic> Philippa_, so can we formalize this? please give me a concrete intuitionistic-style definition of what an element of String -> (forall a. a) is, and i'll shut up :)
06:42:42 <vincenz> psykotic: that's the whole problem, it can only be const _|_
06:42:43 <xerox> psykotic: a bottom?
06:42:55 <vincenz> psykotic: cause that's the only value that can change type at runtime
06:43:08 <vincenz> unless we somehow
06:43:11 <vincenz> get a \T -> v::T
06:43:14 <vincenz> with more than one point :)
06:43:35 <vincenz> psykotic: am I making sense? (I'm bad at explaining)
06:43:57 <dmhouse> psykotic: that has a codomain of {_|_}, so 1) is must be a constant function, as the codomain only has one element, and 2) it's constantly bottomm.
06:43:59 <psykotic> vincenz, i agree about bottom but that seems to be a solution to a problem i'm trying to formalize--i know the solution, i care about the specification of the problem.
06:44:05 <dmhouse> forall a. a = {_|_}
06:44:52 <psykotic> vincenz, so, i agree that they are different but they are still equivalent in some weaker sense and i'm trying to tease out the concrete definition of that equivalence.
06:44:59 <vincenz> psykotic: basically... in the "forall a. String -> a"  you can return a value that looks like (T, v::T).  And this is basically a function : \T -> v::T, except taht it only has one point.  Now this is no problem, cause at calltime, the type is fixed.  While for the second case, "String -> forall a. a"  you would need a function "\T -> v::T" with more than one point, in fact it would have to be defined for all types or it would crash.  
06:45:28 <vincenz> They are both \T -> v::T as Philippa_ put it
06:45:34 <vincenz> but the prior only needs one point in that function
06:45:37 <psykotic> right. okay, i'm with you.
06:45:45 <vincenz> That's what my intuition tells me
06:45:49 * vincenz never studied type theory
06:46:15 <psykotic> it's like thunking at the type level :)
06:46:23 <vincenz> :)
06:46:23 <psykotic> in terms of delaying evaluation
06:46:27 <vincenz> it'd be cool, tho
06:46:31 <vincenz> to have some \T -> v::T
06:46:33 <vincenz> with more than one point
06:47:10 <vincenz> possibly feasible by defining a monad with some generating function and defining it for all types
06:47:45 <vincenz> monad Existential a where unit :: a
06:48:39 * vincenz shrugs
06:50:11 <vincenz> (feedback would be welcome:)
06:50:43 <Philippa> re
06:50:45 <Philippa> apparently my ISP're doing maintenance today
06:50:47 <Philippa> what'd I miss?
06:50:50 <vincenz> oy
06:50:54 <vincenz> join #oasis and I'll paste
06:51:54 <Philippa> psykotic: the forall's on the RHS of the ->, I think that's the equivalence you're after
06:52:26 <Philippa> it doesn't matter which order the two lambdas are in
06:52:36 <psykotic> right, i think i sorted out my confusion, thanks
06:53:05 <psykotic> i was trying to reformulate it in terms of dependent products and sums to get a second view
06:53:22 <Philippa> doesn't buy you much
06:53:42 <Philippa> you just end up reinventing the lambda cube
06:54:25 <xerox> My new glasses are too strong, I can't barely see the monitor, hrmpf.
06:54:28 <Philippa> though I guess you might get a generalisation?
06:56:52 <vincenz> Philippa: comment in #oasis on what I said?
06:56:56 <vincenz> I was out on a lim
06:56:57 <vincenz> b
07:22:43 <loumz> hello, I'm following the "Yet Another Haskell Tutorial" and I want to know why the Char.isLower works in ghci but when I try to compile using ghc I get "Not in scope"
07:22:54 <loumz> do I need to "import" this somehow?
07:23:27 <twanvl> Yes, you need to add "import Char" (or Data.Char) to the program
07:24:58 <loumz> twanvl: thanks, it worked
07:28:54 <dmhouse> What values have type forall a. [a]?
07:29:10 <vincenz> dmhouse: []
07:29:19 <dmhouse> vincenz: apart from that trivial case.
07:29:26 <vincenz> _|_
07:29:31 <dmhouse> Is it just replicate N _|_?
07:29:51 <dmhouse> And _|_ itself, of course.
07:32:25 <kosmikus> dmhouse: no, also _|_ : _|_ and the like
07:33:09 <vincenz> incomplete lists of bottoms
07:33:32 <dmhouse> But the elements are necessarily _|_.
07:33:40 <vincenz> yep
07:33:59 <vincenz> _|_:_|_:....:(either [] or _|_)
07:34:15 <vincenz> that's quite a large value space
07:34:21 <dmhouse> :)
07:43:07 <chessguy> uh, is nickserv not around?
07:43:13 <edwardk> yeah
07:43:18 <edwardk> nickserv and chanserv are both missing
07:43:30 <dmhouse> There was a global message a while back about that.
07:43:30 <chessguy> that can't be good
07:43:34 <edwardk> ah
07:44:20 <lisppaste2> dmhouse pasted "Services down" at http://paste.lisp.org/display/29689
07:44:56 <chessguy> i guess that means no /msg's
07:45:29 <dmhouse> Oh, they're back.
07:45:36 <chessguy> lol
07:46:31 <chessguy> i should have whined sooner
08:02:09 <JFT> Hello all, I'm new to Haskell, I dove into the FP world 2 months ago and since then I split my time between CL, Scheme, Haskell (I dropped Ocaml from the lot in favor of haskell) Here's my question:
08:02:36 <JFT> Is there something in the language that make it hard or impossible to have a full fledge REPL loop?
08:02:46 <vincenz> yes
08:02:54 <vincenz> scoping rules at top level
08:03:10 <vincenz> and the fact that code needs to be typed
08:03:20 <JFT> Please tell me more, Ocaml didn't seem embarassed by that?
08:03:27 <vincenz> ocaml is top-down scoped
08:03:29 <vincenz> haskell is not
08:03:33 <Cale> Definitions are permitted to be fully mutually recursive.
08:03:33 <JFT> Oh!
08:03:49 <vincenz> iow what cale said
08:03:52 <Philippa> you could allow complete binding groups to be entered at a time?
08:04:15 <vincenz> Philippa: heh, I've been hoping on nested data-decls to be allowed in exprs :D
08:04:19 <vincenz> then you could easily do it
08:04:49 <Philippa> I think the obvious syntax'd be something like {binding;...}, and it'd probably be REPL-only at first
08:05:01 <Cale> You could. You'd easily get the user into confusing scenarios where the REPL would be waiting for more input because they'd misspelled a name.
08:05:17 <JFT> That can be offset with a different prompt though
08:05:18 <vincenz> Cale: lambdabot sort of does it
08:06:05 <JFT> I wasn't aware of lambdabot Thanks I'm going to check it
08:06:25 <JFT> and thank you for the explanation about the REPL difficulty
08:06:51 <JFT> it ought to be in a faq somewhere as I'm sure I'm not the first one to ask but it is the first clear and concise answer I see :)
08:06:53 <vincenz> > let {foo 0 = 0; foo x = bar (x-1); bar 0 = 0; bar x = foo (x-1)} in foo 3
08:06:57 <lambdabot>  0
08:10:32 <lennart> JFT: You could have a much more full fledged REPL.  In fact hbi (an old interactive Haskell) had.  You could define data types etc at the top level.
08:11:31 <Philippa> Cale: I had explicit {;} in mind
08:12:17 <vincenz> sadly {} does not allow datatype definitions :/
08:12:33 <psykotic> couldn't you have a nested prompt that stays alive until enough data has been entered to "tie the knot"?
08:13:23 <psykotic> you could even have some feedback functionality for telling the user that outstanding unresolved refs
08:32:51 <urz> @pl \x -> sum x / length x
08:32:52 <lambdabot> liftM2 (/) sum length
08:44:49 <Cale> urz: you might have a problem with types there
08:45:00 <Cale> length returns an Int, which you can't divide by
08:45:18 <slash86> just an idea: \x -> fromIntegral (sum x) / fromIntegral (length x)
08:45:50 <Cale> there's also
08:45:56 <Cale> @type genericLength
08:45:58 <lambdabot> forall i b. (Num i) => [b] -> i
08:46:29 <lennart> which was the type of length in Haskell 1.0
08:46:30 <slash86> ah, ok
08:46:32 <Cale> you might not have to apply fromIntegral to the sum
08:47:12 <slash86> ok... I'm a newbie ^^
08:47:41 <slash86> i've just started learning haskell yesterday ^^
08:48:10 <SamB> we like newbies ;-)
08:48:47 <slash86> eheh
08:48:49 <psykotic> they taste good with ketchup
08:48:59 <SamB> bad psykotic! bad!
08:49:06 <slash86> well, not in that sense o_O
08:49:08 <SamB> we do not *eat* newbies
08:49:17 <SamB> if we eat them, they never grow up to write nice libraries!
08:49:48 <pwned> you can eat the tail, they grow a new one.
08:51:11 <slash86> let tail newbie@(_:t) = t
08:56:07 <SamB> slash86: which tutorial are you using?
08:57:03 <slash86> I'm not following any specific tutorial... I just read various articles and then experiment myself
08:57:24 <slash86> I've started reading "A gentle introduction to Haskell" btw
08:57:25 <SamB> ah ;-)
08:57:48 <SamB> you know where to find the Report and library docs, I hope?
08:57:54 <SamB> @where report
08:57:55 <lambdabot> http://www.haskell.org/onlinereport/
08:58:06 <therp> don't forget about hoogle :)
08:58:10 * SamB was just checking if that worked
08:58:17 <SamB> ah, yeah, hoogle is neat
08:58:20 <chessguy> sending newbies to the report is not nice :)
08:58:22 <slash86> yes I've found it before
08:58:27 <slash86> hoogle?
08:58:34 <therp> @where hoogle
08:58:34 <lambdabot> http://www.haskell.org/hoogle
08:58:37 <SamB> chessguy: it is usefull if they are article-hopping
08:58:37 <pejo> Is it obvious what the result of a function composition becomes if they are both pure?
08:59:16 <psykotic> why oh why are n+k patterns part of haskell 98? anyone know the history?
08:59:18 <slash86> mh... hoogle is fashion ^^
08:59:27 <therp> pejo: obvious = unambiguous?
08:59:41 <SamB> hmm.
08:59:43 <SamB> history.
09:00:31 <pejo> therp, I realize it is well defined, I'm having a hard time to 'see' the result though.
09:00:43 <therp> I would say the motivation comes from writing recursive functions. like f(n+1) = ... f(n) .. but why it's actually part of Haskell. no idea, sorry.
09:01:56 <SamB> well, obviously it is a popular notation for mathemeticians
09:02:04 <psykotic> therp: the typical n+1 case is just primitive "data-directed" recursion.. guess what, we have folds for that :)
09:02:37 <SamB> however, mathemeticians have intelligent readers who can tell just what is being defined
09:03:03 <SamB> and who are also capable of pattern matching on functions
09:03:26 <slash86> does anybody know where to find italian documentation? I can read english quite well but obviously I'd prefer to read in my mother tongue :D
09:04:08 <therp> psykotic: I guess n+k patterns could be replaced by about 1000 other language constructs :) .. no question.
09:04:20 <cm> psykotic, http://research.microsoft.com/~simonpj/tmp/history.pdf 5.6
09:04:23 <lambdabot> http://tinyurl.com/ymevcx
09:04:33 <SamB> you could try asking in #haskell.it
09:04:53 <psykotic> cm: oh, hey :)
09:05:00 <cm> ;)
09:05:01 <slash86> ok... I'll ask there
09:05:03 <cm> sup
09:05:32 <SamB> well, apparantly they've been around since at least '93?
09:05:40 <psykotic> they must be good then! :)
09:06:08 <loumz> hello, I'm having a little trouble with printing lists. In http://rafb.net/paste/results/18K31j41.html how do I say "if the list is empty do nothing"?
09:06:26 <Cale> printFactList [] = return ()
09:07:45 <loumz> Cale: thanks, that worked. What is the "()"  in this "return ()" thing?
09:07:55 <Cale> The empty tuple
09:08:08 <Cale> It works well when you need a meaningless value.
09:08:18 <RemiTurk> good evening
09:11:08 <loumz> so if I see  "putStrLn :: String -> IO ()" that means somewhere inside putStrLn there is also a "return ()"?
09:11:56 <RemiTurk> hi Lemmih
09:12:22 <Lemmih> Hiya.
09:12:42 <xerox> Lemmih ~ yow! Did you solve your Hope problems?
09:12:57 <RemiTurk> loumz: yes, or at least somewhere inside putStrLn or one of the functions called by putStrLn
09:13:04 <Lemmih> xerox: No, haven't had a chance to look at it again.
09:13:33 <Lemmih> bringert: ping.
09:13:33 <vincenz> hi Lemmih
09:13:47 * vincenz kicks Lemmih to the lazy bottoms channel
09:14:21 <loumz> RemiTurk: ok, thanks
09:14:46 <Lemmih> vincenz: #oasis?
09:15:07 <SamB> it is kind of odd that we have 0-tuples, 2-tuples, 3-tuples, but no 1-tuples
09:15:42 <psykotic> the literal syntax would be annoying :)
09:15:57 <psykotic> python does (x,)
09:16:08 <SamB> point ;-)
09:16:09 <xerox> SamB ~ a 1-tuple is a newtype on some type.
09:16:18 <SamB> I just think it is odd to call () a tuple
09:16:25 <Lemmih> @djinn mkUniple :: a -> (a)
09:16:25 <sjanssen> psykotic: but that's a partially applied 2-tuple in Haskell
09:16:25 <lambdabot> Cannot parse command
09:16:29 <SamB> just because it has similar syntax...
09:16:31 <psykotic> sjanssen, yup :)
09:16:34 <sjanssen> > (1,) 2
09:16:35 <lambdabot>  Parse error
09:16:49 <xerox> > (flip (,) 1) 2
09:16:49 <SamB> and indistinguishable semantics
09:16:50 <lambdabot>  (2,1)
09:17:25 <sjanssen> there's no good reason to have a 1-tuple, as far as I can see
09:17:29 <RemiTurk> SamB: It is kind of odd that we have lots of different tuple-types IMO..
09:17:46 <RemiTurk> I wish tuples where syntactic sugar for something like HList's
09:18:11 <psykotic> HList?
09:18:30 <sjanssen> @where hlist
09:18:31 <lambdabot> http://homepages.cwi.nl/~ralf/hlist/
09:18:35 <sjanssen> psykotic: heterogenous lists
09:18:50 <sjanssen> data HList a b = HCons a b; data HNil = HNil
09:19:03 <psykotic> yeah, that's what i assumed
09:19:08 <sjanssen> the length and types stored in the list are reflected in the type
09:19:38 <SamB> hmm, does the Haskell report still leave it ambiguous where names used in the translation of language constructs come from?
09:19:42 <RemiTurk> so e.g. (1,2,3) would be synsugar for HCons 1 (HCons 2 (HCons 3 HNil))
09:19:53 <pejo> That url is faulty, it's "HList", not "hlist".
09:20:19 <sjanssen> @where+ hlist http://homepages.cwi.nl/~ralf/HList
09:20:20 <lambdabot> Done.
09:20:23 <sjanssen> @where hlist
09:20:24 <lambdabot> http://homepages.cwi.nl/~ralf/HList
09:21:11 <SamB> i.e., does it specify that an if expression refers to Prelude.True and Prelude.False?
09:22:00 <SamB> oh, hmm, apparantly they didn't leave that ambiguous...
09:22:25 <RemiTurk> I suspect it does, 'cause IIRC GHC has a special flag to use whatever is in scope
09:22:37 <SamB> apparantly that was only an oversight....
09:22:44 <SamB> regarding n+k patterns.
09:23:01 <psykotic> sjanssen, you need gadts to ensure that the b is itself an HList, right?
09:23:43 <sjanssen> psykotic: the library uses type class constraints in all of the functions to make sure the tail is an HList
09:23:57 <sjanssen> but yes, it is possible to construct something like "HCons 1 2"
09:24:06 <xerox> it would be cool to have HList in lambdabot runplugs or whatever is called now ("> ..")
09:24:16 <SamB> sjanssen: isn't that inefficient?
09:24:19 * RemiTurk agrees
09:24:24 <RemiTurk> (with xerox)
09:24:32 <SamB> the typeclass approach, I mean
09:24:42 <xerox> RemiTurk: do you have time to give it a try to add HList to \bot's scope?
09:24:45 <sjanssen> SamB: maybe, but who cares?  It's just type level computation
09:24:54 <SamB> once, it lead to some kind of really bad blowup in the type checker, remember?
09:25:27 <xerox> type level computation is guaranteed to not affect run time!
09:25:30 <RemiTurk> xerox: Actually, I've never ever done anything with lambdabot at all
09:25:43 <RemiTurk> xerox: so I have no idea how much free time I would need ;)
09:25:44 <SamB> yes, but some people are liking their programs to compile on finite computers
09:25:53 <sjanssen> yeah, HList might be a bad idea.  If you want to add it, make sure that there's a time out for compilation as well as execution
09:26:19 <SamB> GADTs, afaik, don't have that problem
09:26:32 <xerox> RemiTurk: I think everybody here agrees that it is a very nice piece of software to work with, at least to try to get the hands dirty in "running" Haskell code
09:26:38 <xerox> @help run
09:26:39 <SamB> oh, those are on the "in" list for Haskell', right?
09:26:39 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
09:26:44 <xerox> 3 secs, sjanssen (:
09:26:47 <sjanssen> SamB: actually, I think the two approaches are the same
09:26:53 <SamB> xerox: but does that include compilation?
09:26:58 <sjanssen> xerox: but are you sure that the time out includes compilation?
09:27:04 <SamB> sjanssen: I think the typechecker doesn't know that
09:27:06 <xerox> that's dons-fu
09:27:13 <RemiTurk> and to be honest, I haven't really done much with HList either: I've mostly been silently hoping a cabalized version that actually looks like a library instead of a research project (I'm talking about the number of import TestThis; import TestThat; etc things)
09:27:35 <SamB> actually, I really don't think they are the same approach.
09:27:53 <SamB> they may have some kind of equivalence...
09:27:58 * RemiTurk downloads lambdabot
09:28:09 <xerox> @tell dons do the 3 secs limit of @run include compilation? we were thinking if it were alright to add HList to \bot's scope...
09:28:10 <lambdabot> Consider it noted.
09:28:32 <xerox> RemiTurk: ah, it is not cabalized? :(
09:28:33 <chessguy> \bot :)
09:29:00 <chessguy> cute syntactic sugar :)
09:29:29 <psykotic> maybe a LaTeX macro for _|_, too :)
09:29:49 <RemiTurk> xerox: I'm not even 100% sure. AFAIK it's not really "a library". I'd really like to be able to import Data.HList and Just Use It, but last time I tried I gave up after poking around in it for a while
09:30:44 <RemiTurk> perhaps I should ask Ralf about it instead of complaining here ;)
09:31:03 <sjanssen> RemiTurk: it really shouldn't be hard to cabalize it
09:31:33 <xerox> if anybody cabalizes it, ping me, so that I can add it to cabal-install repository of packages
09:32:29 <pejo> xerox, is cabal-install similar to yum/apt-get?
09:32:38 <xerox> yes it is
09:32:49 <RemiTurk> I suspect (I'm _not_ a HList expert at all though) that the more difficult part of it might be exactly _what_ to package: There's a lot of different labels for the different record thingies for example
09:33:06 <pejo> xerox, Oh, sweet. Needs a rather recent version of GHC I presume though?
09:34:28 <xerox> pejo: i worked on it with ghc 6.5
09:36:26 * RemiTurk makes a note to look at HList, lambdabot & cabalization
09:37:23 * xerox hugs RemiTurk 
09:38:44 * RemiTurk thinks xerox never saw my TODO
09:38:56 <RemiTurk> but thanks anyway ;)
09:40:29 <RemiTurk> and now I'm leaving for dinner
09:40:36 <RemiTurk> bye
09:41:06 <Pegazus> does anyone knows by chance what's the best algorithm for the maximum flow? (in complexity and in real time too)//Clear
09:42:00 <|m0rph|> hello, I need to use ghcI 6.4.2 on a intel mac because I have a project that uses many packages that are not avaiable on the 6.6 version. I just want the interpreter .. any help ?
09:42:15 <psykotic> i think one of the fastest is goldman-tarjan which is slightly more than O(mn)
09:43:41 <psykotic> haven't implemented it but iirc it's pretty complicated so it might not be the fastest in practice for all i know
09:44:45 <|m0rph|> hello?
09:45:51 <pejo> morph, can't run the ppc binary in Rosetta?
09:45:55 <chessguy> maximum flow, that's a graph theory problem, isn't it?
09:46:21 <|m0rph|> I get an error with Readline libm wrong arquitecture
10:05:34 <therp> chessguy: yes graph theory
10:05:45 <chessguy> have you checked the wikipedia page?
10:05:53 <chessguy> @go wiki maximum flow
10:05:56 <lambdabot> http://en.wikipedia.org/wiki/Maximum_flow_problem
10:05:56 <therp> no, am I wrong?
10:06:14 <chessguy> oh, sorry
10:06:19 <chessguy> i thought you were the original asker
10:57:14 <chessguy> @figlet
10:57:14 <lambdabot> Unknown command, try @list
11:22:39 <guerra__> where can i go to learn about wxhaskell?
11:24:24 <complaisant> hi m8s
11:24:49 <complaisant> im having a little problem here.. with an instance in the Read Class
11:25:44 <complaisant> readsSimpleExp x = [(Const i,y) | (i,y) <- lex x]
11:25:44 <complaisant>                 ++ [(Var v,y) | (v,y) <- lex x, isAlpha $ head v]
11:26:05 <complaisant> data Exp = Const Int | Var String
11:26:19 <complaisant> that lex in Const is not lex it's reads
11:26:38 <complaisant> the problem is that lex can parse a Int too .. & i get the ambiguous parse message
11:27:07 <int-e> @type lex
11:27:08 <lambdabot> ReadS String
11:27:39 * int-e has lex on his private 'functions to avoid' list.
11:28:45 <complaisant> indeed int-e
11:29:07 <complaisant> any other function that permit me consume a string?
11:29:18 <monochrom> "isAlpha $ head v" is supposed to suppress the ambiguity.
11:29:37 <complaisant> it is suppose.. but it doesnt :\
11:30:02 <monochrom> Can you give enough data for me to reproduce the problem on my computer?
11:30:16 * monochrom likes the scientific way of thinking.
11:30:40 <complaisant> look
11:30:42 <complaisant> *Main> read "2" :: Exp Ops
11:30:42 <complaisant> *** Exception: Prelude.read: ambiguous parse
11:30:42 <complaisant> *Main> read "a" :: Exp Ops
11:30:42 <complaisant> *** Exception: Prelude.read: ambiguous parse
11:31:06 <skew> > read "a" :: Exp Ops
11:31:08 <lambdabot>  Not in scope: type constructor or class `Ops'
11:31:13 <int-e> complaisant: what does reads return?
11:31:25 <skew> hmm, maybe something is screwed up with the read instance?
11:31:27 <complaisant> [(a,String)] i think
11:31:34 <int-e> complaisant: and are you sure that  readsSimpleExp  is at fault?
11:31:44 <int-e> complaisant: I meant the actual values
11:31:46 <skew> Am I missing a paste here?
11:32:13 <int-e> skew: a bit of channel history, yes.
11:32:21 <complaisant> i'll copy/paste the code.. look
11:32:23 <complaisant> instance (Read o, Opt o) => Read (Exp o) where
11:32:23 <complaisant>   readsPrec _ x = (readsSimpleExp x) ++ (readsComplexExp x)
11:32:31 <complaisant> readsSimpleExp x = [(Const i,y) | (i,y) <- reads x]
11:32:31 <complaisant>                 ++ [(Var v,y) | (v,y) <- lex x, isAlpha $ head v]
11:32:31 <complaisant>                 ++ [(e,w) | ("(",y) <- lex x , (e,z) <- reads y, (")",w) <- lex z]
11:32:31 <complaisant> readsComplexExp x = [(Op o [e,f],w) | (e,y) <- readsSimpleExp x, (o,z) <- reads y, (f,w) <- readsComplexExp z ]
11:32:31 <complaisant>                  ++ (readsSimpleExp x)
11:32:48 <Lemmih> complaisant: Use a pastebin, please.
11:32:51 <dmhouse> ?where paste
11:32:52 <lambdabot> http://paste.lisp.org/new/haskell
11:33:02 <skew> Ah - ambigous parse means you're ending up with several elements in that list
11:33:22 <complaisant> yes skew
11:33:32 <int-e> complaisant: what do you get if you type "reads "2" :: [(Exp Ops, String)] ?
11:33:57 <complaisant> *Main> reads "2" :: [(Exp Ops, String)]
11:33:57 <complaisant> [(2
11:34:04 <skew> so, readsPrec _ x = readSimpleExp x ++ readComplexExp x
11:34:13 <skew> and readComplexExp x = ... ++ readSimpleExp x
11:34:26 <int-e> complaisant: I think you'll get the same result multiple times. read expects that there is only one.
11:34:46 <int-e> complaisant: because readsComplexExp calls readSimpleExp again
11:34:56 <skew> so readsPrec _ x = readSimpleExp x ++ readSimpleExp x ++ ..., and you'll get that error for anything which parses as a complex exp.
11:36:22 <complaisant> y
11:36:32 <skew> Er, parses as a simple exp
11:36:39 <complaisant> so the problem is with complexExp
11:36:41 <complaisant> -.-
11:36:54 <complaisant> *Main> read "a" :: Exp Ops
11:36:54 <complaisant> a
11:36:54 <complaisant> *Main> read "1" :: Exp Ops
11:36:54 <complaisant> 1
11:36:54 <complaisant>  -> nice
11:37:03 <skew> try readsPrec _ x = readsComplexExp x
11:37:06 <monochrom> The problem is always in the part you don't show.
11:37:21 <skew> unless there's a problem in the part you show...
11:37:30 <skew> but we usually catch those
11:37:52 <truetom> hi, are there any binary operators in Haskell, like in C &, |, etc ?
11:38:04 <skew> you might be happier defining your parsers with Text.ParserCombinators.ReadP
11:38:07 <int-e> @docs Data.Bits
11:38:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
11:38:12 <edwardk> truetom: look in Data.Bits
11:38:13 <therp> is there any common reason why GHC segfaults? Binary: expanding to size: 54xxxx..? it doesn't seem like a programming error, but some inconsistancy at compilation.
11:38:24 <truetom> thanks
11:38:37 <monochrom> > True || undefined
11:38:37 <skew> truetom: you mean "binary" as in bitwise operations, right?
11:38:38 <lambdabot>  True
11:38:47 <monochrom> Oh, & and |, nevermind.
11:39:02 <monochrom> All operators are binary :)
11:39:13 <complaisant> skew : y. it works
11:39:22 <edwardk> monochrom: depends on your definition of operator =)
11:39:23 <complaisant> ty
11:39:26 <edwardk> > (-1)
11:39:27 <lambdabot>  -1
11:39:28 <pejo> therp, doing TH?
11:39:38 <therp> pejo: no
11:39:39 <skew> complaisant: what Haskell implementation are you using?
11:39:39 <int-e> edwardk: boo ;)
11:40:19 <int-e> edwardk: does your toy language have unary minus?
11:41:20 <edwardk> int-e: not exactly, i have a distinction between (- 1) and (-1) the former is a binary minus in a partially applied section, the latter is a negative 1
11:42:11 <dmhouse> edwardk: how is that 'not exactly' unary minus?
11:42:13 <edwardk> if i do add prefix operators they'll have to be unseparated from their operand. so something like -x, but right now i only have a special rule for -[:digit:]+
11:42:17 * Igloo thinks Haskell would be better off with that, but sees little hope of that before Haskell 2
11:42:27 <edwardk> dmhouse: coz i only have it as part of the lexing of numbers
11:42:41 <edwardk> -x is still a symbol '-x'
11:42:42 <int-e> so (-a) is a section again
11:42:49 <int-e> ?
11:43:23 <complaisant> skew : i have to make a simple calculator compiler to an "very simple" (not simple 4 me :P) assembler language
11:43:34 <edwardk> in my toy lang a sequence of characters is an identifier, whether its infix or a regular identifier is determined by its first char, so (-a) is the infix operator -a applied to 0 of its 2 arguments.
11:43:50 <int-e> oh.
11:44:32 <skew> Making a -x and a - x mean different things is an excellent idea - according to Bjorn Stroustrup: http://public.research.att.com/~bs/whitespace98.pdf
11:44:35 <lambdabot> http://tinyurl.com/y4nsny
11:44:50 <edwardk> skew: well, i'm already on the wrong side of bjorn's arguments =)
11:45:32 <skew> complaisant: are you using Hugs or GHC?
11:46:06 <Igloo> Hmm, personally I'd have -1 being 1 lexeme but - 1 and -x being two each
11:46:21 <int-e> me too
11:46:21 <complaisant> ghc
11:46:33 <skew> x - y = minus
11:46:43 <edwardk> igloo: it gives me _|_ as a valid identifier and -o as a valid operator. i'm using a lot of linear logic type terms, so i run out of easy to type operators without this convention
11:46:53 <skew> x  - y = "Hello "++x++", it looks very "++y++" today"
11:47:03 <skew> x -  y = map (x:) (tails y)
11:47:05 <skew> etc.
11:47:15 <edwardk> plus it makes foo-bar a valid identifier, so all valid xml identifiers are valid identifiers in the language once you make that concession.
11:47:37 <Igloo> edwardk: I don't see how _|_ is related, but if you want -o then fair enough
11:47:41 <dmhouse> edwardk: and you could use Lisp-style identifiers.
11:47:43 <pejo> skew, heh, was that about Stroustrup sarcasm?
11:47:49 <edwardk> it lets me reclaim . for 3 meanings. because a.b is one identifier a . b is function composition and a .b is the partial application of the operator .b to argument a on the left
11:47:51 <edwardk> dmhouse; yeah
11:47:53 * dmhouse has always felt Lisp-style variable names were the most readable
11:47:54 <skew> pejo: did you read the paper?
11:48:23 <edwardk> igloo: _|_ is parsable as a valid identifier by the rules that govern my lexemes
11:48:29 <edwardk> in haskell its _
11:48:32 <edwardk> er _ | _
11:48:45 <edwardk> which is nonsensical
11:49:17 <dmhouse> > let _|_ = undefined in 2|3
11:49:18 <lambdabot>  Parse error in expression
11:49:19 <pejo> skew, no, just your statement about what Stroustrup thought about - a and -a.
11:49:27 <dmhouse> Aww.
11:50:05 <edwardk> similarly it gives me an 'answer' to larry wall's language design dilemma that 'every language feature wants the :' since i can use it in three or four different ways depending on spacing.
11:50:08 <monochrom> Well seeing this is someone who wants >> different from > >, ...
11:50:51 <edwardk> monochrom: heh, they were talking about dropping that next revision i think
11:51:22 <monochrom> OK that's better.
11:52:20 <monochrom> Haskell has unicode. It can accept ⊥
11:52:29 <monochrom> unicode ftw
11:52:32 <edwardk> anyways, it also gives a clean out towards xml literals as long as i reserve operators that start with <foo
11:52:56 <dmhouse> monochrom: does it work with GHC, though?
11:53:08 <edwardk> dmhouse: as of 6.5 as i recall
11:53:14 <dmhouse> Awesome. :)
11:53:20 <monochrom> I have not checked. I have not installed 6.6.
11:53:46 <dmhouse> > let ⊥ = undefined in ⊥ 2
11:53:47 <lambdabot>  Illegal character ''\138''
11:53:48 <int-e> edwardk: I like that actually. Not for Haskell though because it'd break too much code.
11:53:52 <edwardk> of course, unless i missed something they don't do nfkc/nfkd rewriting on identifiers so you can have two strings that look identical be totally different identifiers =/
11:53:57 <monochrom> Anyway ASCII art is for the 19th century.
11:53:58 <vincenz> > '\138'
11:54:00 <lambdabot>  '\138'
11:54:04 <vincenz> > show '\138'
11:54:06 <lambdabot>  "'\\138'"
11:54:07 <int-e> edwardk: but I think you're not proposing it for Haskell anyway :)
11:54:13 <edwardk> int-e: yeah its totally not backwards compatible, but since i'm building from the ground up, it works for me =)
11:54:23 <dmhouse> > '⊥'
11:54:23 <lambdabot>  Improperly terminated character constant
11:54:43 <monochrom> lambdabot doesn't decode utf-8 yet.
11:55:30 <edwardk> starting from day 1 with unicode, a well defined nkfc decomposition applied to all identifiers, an optional xml source file syntax so you can use entities to name operators that you can't type, etc.
11:55:55 <monochrom> Nice. I love you.
11:56:26 <skew> pejo: the papper is pretty funny
11:56:56 <edwardk> and my syntax uses uppercase/lowercase as a hint, not a rule, so lacks the undefinedness that haskell runs into with international characters that lack case.
11:57:27 <edwardk> but in the end, its all just syntax
11:57:47 <monochrom> Oh haha that inspires me.
11:57:48 <xerox> edwardk: and the language itself compares to Haskell?
11:57:49 <skew> edwardk: I like the idea of letting the lexical syntax start with these characters
11:58:19 <skew> presented that way, it seem much more sensible that making decisions based on whitespace
11:59:20 <xerox> whitespace, the programming language?
11:59:29 <monochrom> Suppose I want to use my Chinese name for a type.  There is no case in Chinese.  So 黎裕昌 won't work.  To fix that I prepend my English name.  data Albert黎裕昌 = ...
11:59:32 <edwardk> xerox: in the end i'm hoping, with a bunch of substructural type things, probably painfully overgeneralized versions of stuff from the prelude and what will probably wind up being undecidable type inference.
12:00:15 <edwardk> xerox: all depends on how my principal types work out in some of my corner cases.
12:00:47 <skew> edwardk: you might want to look at MLF
12:01:04 <edwardk> skew: i have, my type system is a bit more abusive than theirs =)
12:01:11 <xerox> .oO( GHC is one of the most important Haskell features... )
12:01:27 <skew> specifically the way the restore principal types
12:01:56 <monochrom> edwardk: how to tell where an identifier ends?
12:02:00 <edwardk> skew: yeah, read the paper, the biggest issue i run into is i have a lot of substructural type annotations that are kind of problematic which i carry around
12:02:05 <skew> hey, is there any interface for a running program to talk to the typechecker?
12:02:16 <skew> oops, garbage collector
12:02:23 <moconnor> @pl (\x y -> x == y && x == Male)
12:02:23 <lambdabot> ap (flip . ((&&) .) . (==)) (Male ==)
12:02:24 <edwardk> monochrom: whitespace, or a limited pool of symbols for delimiting ranges like ( ) [ ] { }
12:02:32 <monochrom> Ah ok.
12:02:34 <edwardk> and , is currently a delimited but may change
12:02:52 <skew> although being able run instance resolution on types from dynamics would be cool too
12:03:08 <xerox> moconnor: f Male Male = ..; f ..
12:03:29 <skew> I want to be able to manage things like cache size based on memory pressure
12:03:44 <edwardk> skew: can see that.
12:04:11 <monochrom> skew: System.Mem.performGC  does that do?
12:04:38 <monochrom> Err nevermind.
12:04:44 <edwardk> skew: in my case i don't currently have a garbage collector, so its a non-issue =)
12:05:40 <skew> maybe if it returned (bytesRemaining, bytesFreed, bytesAllocated)
12:05:42 <xerox> edwardk: the language needs manual allocation and deallocation?
12:05:52 <edwardk> trying to use regions to avoid having to box things, lets me use more unboxed stuff without a problem
12:06:06 <edwardk> linear region annotations are quite flexible
12:06:31 <xerox> I have no idea about what they are.
12:06:35 <edwardk> a little tricky to get to work right in a lazy setting though
12:06:43 <skew> just linear types, or do you have other substructural things going on?
12:07:12 <edwardk> look up tofte and talpin, and a paper by fluet & greg morisett
12:07:45 <edwardk> skew: linear, relevant, affine, unrestricted, uniqueness and a number of them that don't have names in traditional literature that arise from considering these properties as points on a lattice and filling in the gaps.
12:08:15 <lennart> edwardk: so do you have a paper on this yet?
12:08:28 <edwardk> i have a VERY limited notion of ordered types, but only using it for continuations
12:08:40 <edwardk> lennart: writing up my thesis on it now.
12:08:49 <edwardk> lennart: so not yet
12:09:20 <lennart> cool.  because I'd like change my PTS implementation to have the structural rules pluggable.
12:09:45 <edwardk> unfortunately my predeliction for throwing everything and the kitchen sink into the mix (arguably a form of procrastination) has slowed me down =)
12:10:19 <edwardk> lennart: yeah. i am currently finding myself forced to work in a funny PTS as a result of some of the substructural types. so my PTS has only sigma types, no pi types. =/
12:10:38 <lennart> i'd prefer the other way around
12:10:45 <edwardk> kind of a fully CPS transformed calculus.
12:11:34 <edwardk> well, it lets you be explicit about evaluation order. so i generate the CPS'd PTS after desugaring the surface syntax.
12:12:19 <lennart> hmmm, well, i want to leave evaluation order flexible
12:12:24 <edwardk> and it opens up some other opportunities that aren't confluent in the other form. in this setting weird things like castagna's lambda {} calculus work
12:13:18 * xerox wanders off to dinner
12:13:30 <edwardk> i'm currently controlling evaluation order by the presence of modalities and leaving the default evaluation order unspecified so i can do things like chunk up evaluation of lists into SIMD unit sized chunks.
12:14:09 <lennart> edwardk: it does sound like you've thrown all but the kitchen sink in there ;)
12:14:16 <edwardk> yeah
12:14:37 <edwardk> well, i figured it would give me something to work on for the forseeable future =)
12:14:50 <skew> edwardk: how about compiling stuff for a GPU?
12:15:11 <edwardk> right now i'm just trying to get an interpreter to work for the language as a whole, then i'll get to work on compiling it.
12:15:52 <edwardk> skew: that is/was a goal in the very long term, but i don't think that is going to happen any time soon. its one of the reasons for leaving default evaluation order unspecified.
12:16:05 <monochrom> I love you more.
12:16:11 <edwardk> lets you do things like Accelerator
12:17:14 <edwardk> i have a pet project going here with one of the other guys in the grad program to put together a large number library using the GPU just to experiment with it, but its threshold relative to, say, libgmp is going to be very high, you'll need really big numbers to make it a win.
12:18:09 <edwardk> mainly want that so there can BE a library with the same interface as gmp but bsd licensed, coz then you can say, no we don't reexport gmp's functions, we reexport this other cheapo library. and the legal issues of ghc and libgmp and licensing could go away, even if the library sucks ;)
12:18:58 <edwardk> in any event, we're using that to get a feel for what works in gpgpu terms.
12:19:54 <edwardk> i figure, if nothing else a language that isn't horrid, with good unicode support, should draw a decent international user base that are sick of coding in english =)
12:20:42 <lennart> but we like coding in english :)
12:22:00 <edwardk> but anyways, i'll be the first to admit i have probably bitten off more than i can chew
12:22:06 <edwardk> but it'll be fun trying to choke it down
12:22:26 <poliquin> I'm a Haskell newbie and  Schemer trying to learn about Monads .. from a great Haskell centric tutorial
12:22:33 <poliquin> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
12:22:36 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
12:22:49 <poliquin> The typing has me a bit confused ..
12:23:00 <poliquin> The first example (about 1/5 into the document)  gives ..
12:23:07 <poliquin> bind :: (Float -> (Float,String)) -> ((Float,String) -> (Float,String))
12:23:17 <poliquin> he then writes the code ..
12:23:28 <poliquin> bind f' (gx,gs) = let (fx,fs) = f' gx in (fx,gs++fs)
12:23:38 <poliquin> Which doesn't seem to match the original definition
12:23:51 <poliquin> What the heck am I missing?
12:24:06 <poliquin> Any help greatly appreciated ..
12:24:20 <edwardk> @type (=<<)
12:24:22 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
12:25:21 <poliquin> That's a little much for me ..
12:25:51 <edwardk> hrmm
12:27:26 <edwardk> well, lets look at what his function does. it calls f' with the parameter gx obtained by unpacking its second argument, then, takes the float that function returned and passes it out along with the string that function returns appended to whatever string was passed in
12:27:39 <edwardk> maybe reading it as
12:27:42 <edwardk> bind f' (gx,gs) = (fx,gs++fs) where (fx,fs) = f' gx
12:27:45 <edwardk> is more informative?
12:28:26 <poliquin> your description seems to match what it's supposed to do ..
12:29:58 <poliquin> it returns a list .. not a function as in his type statement ..
12:30:28 <poliquin> Also it appears that his original bind statement takes one argument .. not two ..
12:30:58 * monochrom kisses and hugs "newtype T = forall a. Show a => T a"
12:31:27 <edwardk> i am not seeing that function return a list
12:32:20 <edwardk> it reads as returning a pair consisting of a float and the result of appending the second argument of the passed function to the second part of the pair it was passed.
12:32:47 <poliquin> Sorry .. I meant pair ..
12:32:52 <edwardk> now, that append is appending using ++ which appends lists, since a String is just a [Char], is that the list you see?
12:32:53 <edwardk> ahh
12:33:11 <monochrom> Oops nevermind, existential newtype is illegal.
12:33:55 <lennart> monochrom: as it should be!
12:33:59 <poliquin> How would you read his type statement ?
12:34:16 <monochrom> Of course changing newtype to data is no big deal.
12:34:40 <poliquin> .. takes a function which takes a float and a pair .. and returns a function that takes a pair and returns a pair?
12:35:23 <edwardk> poliquin: i see your problem
12:35:30 <edwardk> how familiar are you with the idea of currying?
12:35:36 <edwardk> @type (+)
12:35:38 <lambdabot> forall a. (Num a) => a -> a -> a
12:35:50 <poliquin> pretty familiar in Scheme ..
12:35:56 <edwardk> we can read that as a function that takes one argument and returns a function that takes one argument and returns the answer.
12:36:07 <edwardk> or we can read that as something that we can apply to two arguments to get the answer.
12:36:30 <edwardk> in his case he is defining his function to take two arguments, when partially applied, it will have the meaning you want it to have
12:36:52 <edwardk> so you can read (Float -> (Float,String)) -> ((Float,String) -> (Float,String)) as take a function and return a function
12:36:58 <monochrom> data T = forall a. Show a => T a; show' (T x) = show x; mylist = [ T (0::Int), T "hello", T True ]; main = print (map show' mylist)
12:37:03 <monochrom> I love that.
12:37:03 <lennart> The definition of bind is equivalent to writing: bind f' = \ (gx, gs) -> let (fx,fs) = f' gx in (fx,gs++fs)
12:37:05 <edwardk> or you can read it as (Float -> (Float, String)) -> (Float, String) -> (Float, String)
12:37:15 <edwardk> a function that takes a function AND a pair, and returns a pair
12:37:24 <edwardk> that is the interpretation that code follows
12:37:27 <lennart> poliquin: perhaps this alternate definition is easier?
12:38:21 <poliquin> Ok .. this is starting to make sense ..
12:38:25 <edwardk> in general f = \x -> foo can be rewritten as f x = foo
12:38:30 <lennart> monochrom: existentials are cool.  they almost made it into Haskell 1.3 :)
12:38:40 <edwardk> in his case he took lennarts definition and applied that rule =)
12:39:40 <monochrom> Hmm what stopped it from happening?
12:39:42 <poliquin> Ok .. Thanks everyone .. I'll go internalize that over a cup of tea ..
12:39:53 <edwardk> lennart: btw- had an excuse to play around in cayenne a couple weeks back and had a lot of fun. neat language.
12:39:57 <pejo> lennart, how close is Haskell to the ideal language, in your opinion?
12:40:12 <poliquin> I've been struggling for a day on that .. Thanks again .. !!
12:40:19 <monochrom> pejo, I'm already in heaven :)
12:40:21 <lennart> pejo: hmmm, ideal for what? :)
12:40:25 <edwardk> poliquin: no problem, feel free to stop in any time
12:40:43 <monochrom> Until I learned existential types I wasn't.
12:41:23 <lennart> pejo: I think Haskell still have quite a way to go.  But it's closer than anything I know.
12:41:30 <edwardk> my biggest gripe about haskell is that that type level programming and term level programming are completely different
12:42:05 <lennart> edwardk: yes.  An untyped logic programming language at the type level seems wrong
12:42:15 <edwardk> so type level programming feels like you are programming in a broken form of prolog
12:42:19 <pejo> lennart, anything big that is missing?
12:42:43 <lennart> pejo: well, depedent types :)
12:42:57 <monochrom> haha broken prolog
12:43:04 <edwardk> substructural types, dependent types, record polymorphism, subtyping,...
12:43:49 <edwardk> too many names for fmap, etc =)
12:44:24 <edwardk> but all in all its easily my favorite language
12:45:17 <lennart> it is also missing a really efficient implementation for numerical computation
12:45:43 <edwardk> oh, and the numerical tower is crap =)
12:46:07 <lennart> yes, but apart from that, little attention has been paid to numerical efficiency
12:46:14 <edwardk> *nods*
12:47:07 <lennart> i'd also like to see non-termination confined to a monad
12:48:04 <edwardk> i haven't currently decided how to handle pointed types in my case. i have been trying to figure out how to corral them into something similar so the base logic isn't degenerate
12:48:11 <lennart> monadic syntax is also kinda clunky in haskell
12:48:28 <edwardk> yeah
12:48:45 <lennart> i would like to write 'x+y', not 'liftM2 (+) x y'
12:48:51 <edwardk> > let (.) = fmap in (+2) . [1..4] -- is the best we've been able to come up with =)
12:48:53 <lambdabot>  [3,4,5,6]
12:49:38 <edwardk> heff was playing around with some weird template haskell trick to get a natural monad syntax too
12:50:12 <lennart> but despite all its flaws, i prefer haskell over anything else
12:51:44 <lennart> designing a coherent language with all the new features we want is highly non-trivial
12:52:11 <edwardk> *nods*
12:52:42 <edwardk> every time i've sat down and tried to put together a language with 'invisible' monads at the expression level, i've run into degenerate cases. =/
12:53:25 <edwardk> and in my current obsession i am dangerously close to giving up decidability of type inference.
13:00:56 <vincenz> edwardk: if you drop decideability can you still observe whcih cases are undecideable so you can inform the user?
13:01:17 <edwardk> vincenz: can do the same thing haskell does and provide a threshold you can change.
13:01:31 <vincenz> edwardk: my point is, will you know when you are being undecideable
13:01:41 <edwardk> if i can corral recursion into a monad then i can avoid those cases
13:01:52 <edwardk> vincenz: thats kind of the problem with being undecidable isn't it? =)
13:02:12 <edwardk> i can know when i'm using a language feature that leads to undecidability if thats what you mean
13:02:46 <vincenz> Not really
13:02:54 <vincenz> It's just like error correction vs error detection
13:03:20 <EvilRanter> identify situations where the input could be parsed two different ways, and complain?
13:03:46 * vincenz nods
13:03:52 <vincenz> well "typed" two different ways
13:04:10 <edwardk> evil: well, in my case the parsing isn't the problem. i understand exactly what it is they said, its a matter of whether or not that results in lack of termination in type checking.
13:04:21 <edwardk> i'm more concerned with lack of termination than confluence
13:04:35 <vincenz> or undetectability of confluence
13:05:20 <edwardk> well, right now i don't have any cases that might resolve to different non-equivalent answers, i just have cases that might not finish
13:06:40 <vincenz> Ah, that's a different story
13:07:11 <edwardk> allow-undecidable-instances not allow-incoherent-instances =)
13:14:28 <EvilRanter> instance Incoherent Drunkard where...
13:14:41 <edwardk> =)
13:29:16 <SamB> hmm, apparantly they've been trying to get rid of n+k patterns since 1.[34]. Or, at least, they were mandatorily toggleable in theory, which would seem to indicate some people didn't want them...
13:31:14 <pejo> SamB, cm gave a link to that history of haskell paper on SPJ's homepage, think it was section 5.6.
13:32:34 <dcoutts> I see that the languages shootout folk are considering adding some unicode processing exmples
13:32:45 <SamB> lovely
13:32:48 <dcoutts> time for that updated Data.PackedString module then
13:33:11 <dcoutts> @seen sjanssen
13:33:11 <lambdabot> I saw sjanssen leaving #ghc, #gentoo-haskell, #haskell-blah, #haskell and #haskell-overflow 1h 50m 22s ago, and .
13:33:18 <SamB> oh, is that what you are calling the Unicode version of Data.ByteString?
13:33:23 <dcoutts> SamB, yes
13:33:38 <SamB> thats a pretty nice name
13:33:44 <dcoutts> we should get the UTF8, 16 and 32 versions and benchmark them against each other for a range of operations
13:34:03 <dcoutts> and for a range of mixtures of characters
13:34:19 <dcoutts> ASCII, european and others
13:34:45 <SamB> it would be funny if the utf8 one was slowest for ASCII
13:35:03 <dcoutts> it'd be pretty bad!
13:35:22 <SamB> it seems unlikely, though, with cache being so important
13:35:28 <dcoutts> aye
13:35:36 <dcoutts> I'd expect utf8 or 16 to win mostly
13:36:48 <dcoutts> So Data.PackedString should just re-export one of Data.PackedString.UTF(8|16|32)
13:37:01 <SamB> mmm.
13:37:35 <SamB> what about Data.LooselyPackedString?
13:37:38 <dcoutts> heh
13:37:40 <dcoutts> you mean .Lazy
13:37:44 <SamB> exactly
13:38:16 <dcoutts> yeah, I expect we'd do it the same as ByteString and ByteString.Lazy
13:38:29 <dcoutts> unless there seems to be some good reason to do it differently
13:38:49 <dcoutts> is there a good argument for not needing both ?
13:38:59 * SamB was thinking maybe that would actually have multiple kinds of strings at some point
13:39:58 <guerra__> anyone anyone knows how do i create a menu entry that calls a function in wxhaskell?
13:40:23 * dcoutts knows how to do it with Gtk2Hs but not wxHaskell
13:40:49 * dcoutts gets back to hacking on Gtk2Hs
13:40:56 <SamB> maybe it should be newtyped from the .Lazy corresponding to whatever is used for Data.PackedString?
13:41:21 <guerra__> dcoutts i just cant understand how its done =/
13:41:46 <dcoutts> guerra__, sorry, I know nothing about wxHaskell
13:41:48 <SamB> hmm, I *so* want to have a Stringy class
13:42:03 <guerra__> dcoutts thanks man
13:42:12 <dcoutts> SamB, sorry, what should be newtyped ?
13:42:21 <dcoutts> guerra__, you've found the documentation I presume ?
13:42:33 <dcoutts> it'll be some named signal handler
13:43:20 <guerra__> dcoutts sure but since im pretty tired by now and wxhaskell is totally new to me, i think i just cant understand hehe will try to check it again
13:43:46 <dcoutts> guerra__, well if you get stuck, switch to gkt2hs :-)
13:43:56 <dcoutts> it's got good reference docs
13:44:15 <guerra__> dcoutts will check it now, maybe it looks easier ^^
13:44:25 <SamB> module Data.PackedString.Lazy (PackedString, ...) where { import qualified Data.PackedString.UTF16.Lazy as LPS; newtype PackedString = PS LPS.PackedString; ...}
13:45:11 <dcoutts> SamB, why would we want it newtyped rather than just re-exporting UTF16 ?
13:45:44 <SamB> dcoutts: in case you wanted to change it later to be something like...
13:46:02 <dcoutts> SamB, aye, fair enough.
13:46:48 <SamB> data Seg = UTF8 UTF8.PackedString | UTF16 UTF16.PackedString | UTF32 UTF32.PackedString
13:47:12 <SamB> newtype PackedString = PS [Seg]
13:47:30 <SamB> oh, except you'd have bangs everywhere
13:48:05 <SamB> and probably {-# OPTIONS_GHC -funbox-strict-fields #-}
13:49:40 <SamB> I have no idea how you'd build them, though, which is why this would be something for *later*
13:50:28 <SamB> that is, how to know in advance how big a segment should be and what kind it should be
13:51:06 <SamB> even knowing how big an array to allocate for UTF8 or UTF16 string would be tricky, though
13:52:19 <dcoutts> there is some advantage to using lazy arrays there
13:52:29 <SamB> mmm.
13:52:30 <dcoutts> you can always allocate another chunk
13:52:34 <SamB> yeah.
13:52:57 <araujo> guerra__, gtk2hs is more cool
13:53:05 <dcoutts> the Streams thing we use contains a length hint which helps
13:53:05 <SamB> but, I still want to know how you decide what kind of segment should be next
13:53:15 <dcoutts> I wouldn't do it that way
13:53:26 <guerra__> araujo: brasileiro? the problem is that my teacher wants the gui made with it
13:53:41 <dcoutts> SamB, why do you want to have different segments in different encodings ?
13:53:49 <guerra__> araujo: i mean, made with wxhaskell
13:53:52 <araujo> guerra__, no , though near brazil ... tell your teacher about gtk2hs
13:54:03 <SamB> well. suppose you had something that lapsed into japanese halfway through?
13:54:05 <guerra__> araujo: will actually ask him
13:54:23 <guerra__> araujo: do u know anything about wxhaskell though?
13:54:23 <dcoutts> SamB, all the UTF things can handle all chars
13:54:30 <SamB> yeah.
13:54:47 <SamB> it was just a thought...
13:54:58 <SamB> someone *might* come up with a good way, you never know.
13:55:15 <dcoutts> SamB, I'm not sure an adaptive approach like that would be much of an advantage
13:55:34 <twanvl> Why would you use UTF-anything for an internal represenation? You can certainly do better than UTF8.
13:55:40 <araujo> guerra__, nothing .... sorry
13:55:49 <guerra__> araujo: thanks man
13:55:54 <dcoutts> twanvl, UTF16 is a reasonable internal rep
13:55:59 <SamB> twanvl: they don't come in anything but UTF anymore, man!
13:56:14 <SamB> the UCS brand was discontinued
13:56:38 <twanvl> yes, UTF16 is a reasonable compromise, what I mean is that if you use the encoding only in memory, then you can use your own.
13:56:48 <dcoutts> twanvl, UTF8 is only good because it's compact for mostly ASCII/european stuff and if you're not doing much processing and you need to interoperate in UTF8 then it can be and advantage
13:56:52 <SamB> twanvl: that would be stupid ;-)
13:57:17 <pzpz> hey all -- i'm trying to use getLine in a state monad, however-- I can't seem to get around "expecting IO b"
13:57:19 <twanvl> UTF8 is not as efficient as it could be
13:57:30 <dcoutts> twanvl, what internal representation would you use ?
13:57:33 <SamB> what do you mean?
13:57:54 <dcoutts> UTF8 wasn't designed for efficiency or as an internal rep
13:58:24 <SamB> the best you can hope for is that the characters you actually use will require only one comparison to distinguish from those you need to store in more than one "word"
13:58:29 <twanvl> In UTF8 you use something like 110aaaaa 10bbbbbb, but it is much simpler if you use a single bit to encode whether more data follows, so 1aaaaaaa 0bbbbbbb
13:58:49 <SamB> or, well, the absolute best would be if you didn't need to check
13:58:55 <SamB> because everything was in only one word...
13:59:09 <pzpz> we should force all computer users to use english :)
13:59:25 <SamB> twanvl: you have a bit of a point... maybe.
13:59:31 <mauke> how naïve
13:59:37 <dcoutts> heh
13:59:38 <pzpz> :)
13:59:39 <SamB> mauke: who?
13:59:45 <mauke> pzpz :-)
13:59:52 <SamB> don't we already do that?
14:00:02 <pzpz> only since english is teh language of science
14:00:28 <pzpz> oh, i hate cygwin so much.
14:00:32 <mauke> .oO( eigenvalue )
14:00:33 <SamB> hah
14:00:40 <mauke> I still don't know how that happened
14:00:44 <SamB> what does cygwin have to do with english?
14:01:09 <pzpz> nothing at all. i'm still hoping someone answers my monad question :)
14:01:15 <araujo> guerra__, i know they changed maintainers recently though
14:01:15 <araujo> its development has been kind of stalled
14:01:38 <guerra__> araujo: didnt know
14:17:07 <pzpz> woah -- irssi saves the day with a windows binary.
14:17:49 <Lemmih> Hurrah for irssi.
14:17:50 <pzpz> not sure if my previous messages made it through, so: http://paste.lisp.org/display/29705
14:18:04 <monochrom> Why do you want to use getLine in State?  Is there another way to do what you want?
14:18:34 <pzpz> i'm just trying to learn monads, i figured this would be a decent approach
14:18:54 <pzpz> i just want to write a little driver to insert/remove/modify elements from the tree
14:19:22 <pzpz> and the only method i know of doing that is via a some sort of get
14:19:35 <pzpz> monochrom: is there another solution?
14:21:31 <monochrom> Ah, you are not in State.  You are in StateT ... IO.  That's different.  getStr = lift getLine.
14:22:10 <monochrom> But the paste shows that you're doing the equivalent.
14:22:29 <pzpz> ignore the getStr method i wrote, heh. i should have deleted that :)
14:23:38 <monochrom> lift $ getLine >>= (\str -> myInsert str)    this should be correct, but watch out for operator precedence.
14:24:11 <pzpz> it seems correct from everything i've read, but ic an't avoid the:
14:24:27 <pzpz> Expected type: IO b;  Inferred type: MyState ()
14:24:38 <monochrom> I would just write lift getLine >>= (\str -> myInsert str).  I mean, only getLine needs lifting.  Adding $ may change the meaning.  lift (getLine >>= \str -> myInsert str) is wrong.
14:24:53 <monochrom> IOW I think this is the problem.
14:25:07 <pzpz> ohh.. that was the issue
14:25:16 <pzpz> and it makes sense :(
14:25:21 <monochrom> You definitely don't want to lift myInsert.
14:25:37 <pzpz> you're very very right
14:26:11 <monochrom> I personally just avoid $ and just use parentheses these days.
14:26:14 <xerox> (beta-reduction:  \str -> myInsert str  =  myInsert)
14:26:42 <pzpz> that's nifty
14:26:54 <monochrom> (do-reduction: xxx >>= \str -> myInsert str   =   str <- xxx; myInsert str )
14:27:01 <edwardk> twanvl: the reasons for unicode's inefficiency are for backwards compatibility and so you can always determine where you are in a character based on the first couple of bits.
14:27:07 <monochrom> do-notation ftw :)
14:27:19 <edwardk> twanvl: your representation isn't as efficient for reading backwards as utf-8
14:27:23 <SamB> edwardk: you mean utf-8
14:27:30 <edwardk> samb: er yeah =)
14:27:33 <SamB> edwardk: hahaha
14:27:37 <SamB> reading backwards...
14:27:49 <edwardk> samb: its a real concern =)
14:27:58 <SamB> it isn't that much worse, though
14:28:40 <edwardk> yeah, but the need to be able to read it backwards and determine if the final byte in your string is actually the final byte in the character so you don't get truncated strings that transliterate characters is.
14:29:02 <edwardk> there are a number of reasons that all add up to give the unicode rep
14:29:21 <SamB> anyway, it is called utf-8
14:29:29 <edwardk> reading backwards, never truncating to yield a different character, ignoring high ascii characters to ignore all high utf-8 special chars
14:29:30 <edwardk> sure
14:30:15 <SamB> also, um, lexicographic ordering
14:30:27 <edwardk> yeah
14:30:29 <pzpz> are there any more effective prelude split methods other than break?
14:30:46 <pzpz> something like a, "hello world".split(" ") ie ruby
14:30:46 <edwardk> didn't think about that one =)
14:31:32 <edwardk> > lex "foo bar"
14:31:34 <lambdabot>  [("foo"," bar")]
14:31:42 <vincenz> > lex "foo bar bling"
14:31:43 <lambdabot>  [("foo"," bar bling")]
14:37:42 <dcoutts> pzpz, I use:
14:37:43 <dcoutts> breakBy :: Eq a => a -> [a] -> [[a]]
14:37:43 <dcoutts> breakBy sep = unfoldr (\s -> case break (sep==) s of
14:37:43 <dcoutts>   ([],_) -> Nothing
14:37:43 <dcoutts>   (w,_:r) -> Just (w,r)
14:37:45 <dcoutts>   (w,[]) -> Just (w,[]))
14:38:20 <dcoutts> nice use of unfoldr methinks
14:38:51 <dcoutts> I'm going to try and popularise unfoldr by making it fusable
14:38:53 <vincenz> why are you dropping the head off of :r
14:39:18 <dcoutts> vincenz, so that breakBy "a,b,c" = ["a","b","c"]
14:39:19 <vincenz> > break (=='a') "bac"
14:39:20 <lambdabot>  ("b","ac")
14:39:23 <vincenz> ah right
14:39:38 <vincenz> > break (=='a') "bc"
14:39:39 <lambdabot>  ("bc","")
14:39:41 <SamB> dcoutts: huh?
14:39:51 <SamB> oh
14:39:53 <SamB> popularize
14:39:56 <vincenz> @type unfoldr
14:39:58 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
14:39:59 * SamB wonders where he got the "de"
14:40:01 <monochrom> The regex libraries can split "hello how are you" into ["hello","how","are","you"]
14:40:08 <dcoutts> SamB, what did you think I said? :-)
14:40:14 <SamB> "depopularize"
14:40:18 <dcoutts> hah :-)
14:40:28 <dcoutts> it's not popular yet
14:40:31 <chessguy> you can do that with "words", can't you?
14:40:46 <SamB> @type unfoldr
14:40:48 <lambdabot> forall a b. (b -> Maybe (a, b)) -> b -> [a]
14:40:51 <vincenz> chessguy: yes but only for spaces
14:40:53 <monochrom> Also I hate this OOP notation val.function(more params).
14:41:08 * dcoutts agrees with monochrom 
14:41:10 <vincenz> monochrom: what's wrong with it
14:41:22 <dcoutts> what's special about val
14:41:29 <dcoutts> why should it go first ?
14:41:35 <dcoutts> it means I can't partially apply
14:41:38 <mauke> because it determines the function to be called
14:41:40 <vincenz> sometimes it's easier to visualize if you have a tone of funcs
14:41:43 <monochrom> Well its a hatred, an emotion of disgust.  There is no why.
14:41:45 <vincenz> a.foo.bar.bling.blong.damn
14:41:53 <dcoutts> vincenz, thats' what (.) is for :-)
14:41:59 <vincenz> dcoutts: except you're reading backwards
14:42:23 <dcoutts> vincenz, you're thinking imperatively
14:42:30 * vincenz thinks that both have their advantages
14:42:33 <monochrom> Not to mention (now I'm just being reckless) that " ".split("hello world") makes more sense :)
14:42:38 <dcoutts> Do this, then do this, then do this etc
14:42:47 <vincenz> you're just as bad as those "dumb people that don't like functional programming" when you condemn oo syntax
14:42:52 <vincenz> dcoutts: I disagree
14:43:09 <mauke> dcoutts: your breakBy doesn't work
14:43:09 <monochrom> Generally let r be a regex object.  r.split(thing to be splitted)  makes a lot of sense from the regex library author's point of view.
14:43:38 <dcoutts> mauke, in what way? I use that code in a project. did I mess it up when I pasted ?
14:44:12 <mauke> breakBy ',' "a,b,,c" == ["a","b"]
14:44:22 <dcoutts> hmm
14:44:24 <mauke> should be ["a","b","","c"]
14:44:26 <vincenz> ah the eternal question :)
14:44:57 <monochrom> Clearly there are three different expectations of breakBy.
14:45:10 <complaisant> mauke use splitAt
14:45:24 <vincenz> except that the one with an empty thingy can always be filtered over
14:45:28 <vincenz> I had this argument once in another language channel
14:45:36 <vincenz> they would automatically filter out the empty bits
14:45:45 <vincenz> instead of not doing that and seeing that you can easily filter afterwards
14:45:49 <vincenz> I think it was ocaml, not sure
14:46:01 <monochrom> I move that it should be ["a", ",", "b", ",", "", ",", "c"]
14:46:09 <monochrom> Oh nevermind.
14:46:10 <mauke> strtok also does something like that
14:46:18 <mauke> or words
14:46:36 <vincenz> > words "haha you  sob"
14:46:37 <mauke> monochrom: meh, just add intersperse
14:46:37 <lambdabot>  ["haha","you","sob"]
14:46:39 <vincenz> yeps
14:46:58 <monochrom> Anyway the library code for "lines" splits at line breaks.  One can easily adapt it to split at spaces.
14:47:24 <Botje> like words does?
14:47:29 <vincenz> > words "haha you  sob"
14:47:30 <lambdabot>  ["haha","you","sob"]
14:47:35 <vincenz> > lines "haha\nyou\n\nsob"
14:47:37 <lambdabot>  ["haha","you","","sob"]
14:47:37 <monochrom> Damn!  I forgot words.
14:48:07 <vincenz> it ain't the same
14:48:12 <mauke> > lines "a\nb\n\n\n"
14:48:13 <lambdabot>  ["a","b","",""]
14:48:25 <vincenz> except lines isn't perfect either, it drops the last one if empty
14:48:49 <vincenz> > lines "a\nb\n\n\n "
14:48:51 <lambdabot>  ["a","b","",""," "]
14:48:52 <vincenz> > lines "a\nb\n\n\n"
14:48:53 <lambdabot>  ["a","b","",""]
14:49:38 <complaisant> Prelude.filter (\x -> x/=';') "x = 2 ; print x"
14:49:42 <dcoutts> mauke, fixed:
14:49:42 <dcoutts> breakBy :: Eq a => a -> [a] -> [[a]]
14:49:42 <dcoutts> breakBy sep = unfoldr next
14:49:42 <dcoutts>   where next s =
14:49:42 <dcoutts>           case break (sep==) s of
14:49:45 <dcoutts>             ([],[])  -> Nothing
14:49:47 <dcoutts>             ([],_:r) -> next r
14:49:48 <dcoutts>             (w ,_:r) -> Just (w,r)
14:49:50 <dcoutts>             (w ,[])  -> Just (w,[])
14:50:11 <chessguy> uh, ever heard of a pastebin?
14:50:33 <dcoutts> aye, perhaps a little on the long side
14:50:35 <monochrom> Actually I now reinstate my motion for ["a", ",", "b", ",", "", ",", "c"].  In general you split by a regex, say ",|;", so applying it to "a,b;c" yields ["a", ",", "b", ";", "c"].  If you drop the delimiters, you cannot recover them with intersperse.
14:50:35 * vincenz gives dcoutts a demerit
14:50:38 <mauke> eww, collapses empty fields
14:51:01 <dcoutts> mauke, yes, that's what I wanted. I'm sure you can change that.
14:52:01 <vincenz> mauke: referring to the fact that next calls itself without going through unfoldr/
14:52:35 <dcoutts> mauke, just remove the 'next r' line
14:53:07 <dcoutts> then it preserves the empty entries
14:53:37 <mauke> still removes the last field
14:53:52 <dcoutts> then change the [] [] pattern
14:54:12 <mauke> to what?
14:58:51 <dcoutts> mm, ok it's not quite that simple
15:07:21 <therp> will different optimization flags break GHC generated code? or even GHC itself?
15:10:03 <dcoutts> therp, yes, some gcc flags will break GHC generated code
15:10:16 <dcoutts> be careful of using greater than -O2
15:10:26 <dcoutts> and any of the other ricer flags
15:10:31 <therp> dcoutts: hm, I'm using -fasm anyway
15:10:38 <dcoutts> that's ok then
15:12:07 <therp> dcoutts: because my self-compiled GHC (almost HEAD) jokes on an alex generated parser.
15:12:38 <dcoutts> what's the error message?
15:12:44 <dylan> best ricer flag: -mregparm
15:13:28 <dylan> friend of mine has totally broken his machine by using that.
15:14:01 <therp> dcoutts: Binary: expanding to size: 543457811284099072 \n zsh: segmentation fault  /usr/local/bin/ghc --make LexLiskell.hs -O0 -package ghc
15:14:13 <therp> it also dies without -O0
15:14:30 <dcoutts> therp, mm, definately a bug :-)
15:14:45 <dcoutts> I think it's dieing when writing out the .hi file
15:14:59 <dcoutts> that's what the Binary bit is
15:15:16 <dcoutts> so it's getting the size wrong somehow, I'd report it.
15:15:22 <therp> dcoutts: oh, ok. hm what would cause that (anymore of GHC fu?)
15:15:23 <dcoutts> or just try the 6.6 version
15:15:54 <dcoutts> not sure what would cause it, there's many things to go wrong :-)
15:15:55 <therp> dcoutts: 6.6 is fine. the strange thing is, making this file part of GHC causes no problems.
15:17:22 <therp> so it's not a problem with the file itself. that's compilable by this GHC. well strange. I'll keep on looking
15:23:31 <Igloo> therp: Could the .hi file have been made by a different compiler to that which you are using?
15:24:02 <mauke> my version of breakBy: http://rafb.net/paste/results/HAAIvr61.html
15:24:14 <mauke> does it make sense to use unfoldr at all?
15:28:55 <therp> igloo: positive! cleaning the *.hi works, many thanks
15:29:34 <monochrom> It makes sense to use unfoldr.
15:30:25 <monochrom> It also makes sense to erase *.hi when rebuilding.
15:31:57 <therp> igloo: ah, ok reading the GHC commentary corrects my false assumption that .hi would be a text file describing the interface. I assumed it would be something like an autogenerated header, never looked at it
15:32:34 <therp> and I started to think that my HEAD branch had some issues.
15:32:37 <Igloo> Even if it was text, the format could still change between versions
15:33:27 <therp> igloo: right, but at least then it could exit more gracefully, but when it's a "super symbol table" as the commentary says, I'm not surprised by segfaulting
15:34:44 <therp> well, thanks again. I just thought to myself 10 minutes ago, "do I really want to hunt that down or shall I go to bed?". Now I can sleep well
15:34:57 <therp> good night everyone
15:38:21 <encryptio> is the wikibook on haskell good for a newbie to learn from?
15:41:12 <vincenz> encryptio: yep
15:43:00 <encryptio> coo.
15:46:29 <dcoutts> (except the gui section which is very sparse and only covers one toolkit)
15:46:40 <vincenz> those bastards
15:46:47 <vincenz> blegh
15:46:55 <vincenz> don't ruin your food by trying to make something special
15:47:04 <vincenz> I just blew all my couscous when I decided to add a homemade sauce
15:47:08 <vincenz> now I'm completely foodless
15:47:44 <edwardk> vincenz: the result was that vile?
15:47:52 <vincenz> yeah
15:47:58 <vincenz> well I have some rice and spaghetti
15:48:04 <vincenz> just too lazy to actually cook it
15:55:57 <cjeris> @karma+ Y-combinator
15:55:57 <lambdabot> Y-combinator's karma raised to 1.
16:09:13 <sohail> is the haskell compiler written in haskell?
16:09:21 <SamB> "the"?
16:09:35 <SamB> well, all of the compilers are lately...
16:09:47 <SamB> there might have been one written in Lazy ML, once
16:09:47 <sohail> so does the compiler utilize lazy evaluation
16:09:59 <SamB> GHC does
16:10:07 <sohail> to what end
16:10:08 <RemiTurk> hello everyone
16:10:09 <sohail> ?
16:10:15 <SamB> lazily evaluating things?
16:10:48 <sohail> like what things would you lazily evaluate
16:10:54 <mauke> EVERYTHING
16:11:13 <dcoutts> actually that's a slightly tricky question, it's a bit like asking what you use objects for in an OOP language
16:11:20 <dcoutts> it's just the way everythign is done
16:11:24 <SamB> like, well, in the simplifier, if it is deciding whether to callsite-inline a function or not, it only looks at however many arguments the function will actually take
16:11:31 <sohail> ok in a compiler, some things *must* be computed always. like for example, an ast.
16:11:33 <SamB> not any more that may have been given...
16:11:38 <dcoutts> it's a bit hard to pick out a specific example and say that's an excelent example
16:11:47 <SamB> sohail: not all ASTs must be computed all the time
16:11:58 <sohail> SamB, you think?
16:12:04 <dcoutts> sohail, for example, the AST is cyclic, that relies on lazy evaluation
16:12:15 <monochrom> I use objects for obfuscation.
16:12:16 <sohail> ah
16:12:23 <SamB> well, for instance, any extra arguments are ASTs that aren't computed
16:12:24 <Igloo> The only use of laziness I know if is in looking up imports, and I only know if that one because it causes problems with --make -j
16:12:27 <monochrom> OOP = object obfuscation pomposity
16:12:30 <dcoutts> sohail, the AST contains names, and the names link to the thing that is named.
16:13:06 <dcoutts> Igloo, am I right? the names link directly to the named thing?
16:13:08 <sohail> well its just i have this gut feeling that lazy evaluation is very useful for compilers
16:13:14 <dcoutts> so it ties the loop
16:13:16 <sohail> in stuff like optimizations
16:13:21 <dcoutts> loop/knot whatever
16:13:21 <SamB> I'm only mentioning this because the comments explicitly stated that the lazyness was being used to avoid work
16:13:29 <Igloo> dcoutts: Yeah, that's another one
16:13:38 <Igloo> s/know/can think of OTTOMH/ above  :-)
16:13:47 <SamB> sohail: I'm sure it is!
16:13:55 <sohail> SamB, :)
16:14:10 <SamB> but, you obviously have to be careful
16:14:17 <dons> moin
16:14:17 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
16:14:18 <sohail> yes
16:14:20 <dcoutts> hia dons
16:14:25 <sohail> i hear lazy evaluation can take up lots of memory
16:14:35 <mauke> so can strict evaluation
16:14:38 <mauke> (duh)
16:15:08 <dons> yeah, usually we use lazy evaluation to have O(1) space instead of O(n)
16:15:14 * RemiTurk has a question
16:15:20 <dcoutts> sohail, yes, the normal effeciency problems are due either to being too strict or too lazy.
16:15:26 <SamB> well, I was thinking more along the lines of not running circles around your AST because it is shaped like a mobius strip ;-)
16:15:31 <RemiTurk> has anyone wished for a zipTail / zipTailWith prelude-function?
16:15:37 <vincenz> @type repeat
16:15:38 <lambdabot> forall a. a -> [a]
16:15:49 <sohail> i've not used a lazily evaluated language yet
16:15:56 <dcoutts> sohail, fortunately in a lazy language you can make things more lazy. In strict language you've got to rewite things to simulate lazyness.
16:16:02 <dons> people see sigfpe's new article, http://programming.reddit.com/info/qgml/comments
16:16:04 <mauke> @type zip =<< tail
16:16:05 <lambdabot> Title: Monads, Kleisli Arrows, Comonads and other Rambling Thoughts (reddit.com), http://tinyurl.com/yyl8hw
16:16:06 <lambdabot> forall b. [b] -> [(b, b)]
16:16:16 <SamB> dcoutts: how do you make things more lazy?
16:16:27 <dcoutts> SamB, use let not case, use ~patterns
16:16:59 <RemiTurk> mauke: indeed. but that doesn't help when I'm trying to explain people how great Haskell is ;)
16:17:38 <RemiTurk> (and actually, when I want one, I usually want flip zip, and quite often flip (zipWith f)
16:18:14 <RemiTurk> but perhaps I'm biased by creating markov chains too often
16:18:25 <mauke> > (tail >>= zip) [0 ..]
16:18:27 <lambdabot>  [(1,0),(2,1),(3,2),(4,3),(5,4),(6,5),(7,6),(8,7),(9,8),(10,9),(11,10),(12,11...
16:18:44 <sohail> well thanks for the knowledge guys.
16:18:46 <sohail> later
16:19:15 <RemiTurk> > ap zip tail [0..]
16:19:17 <lambdabot>  [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12...
16:19:53 <vincenz> > zipWith (+) [1..3] [1..4]
16:19:55 <lambdabot>  [2,4,6]
16:20:27 <mauke> > (tail =<< zip) [0 ..]
16:20:28 <lambdabot>    Expecting a function type, but found `m a'
16:20:28 <lambdabot>    Expected type: [[a]]
16:20:28 <lambdabot>  ...
16:20:38 <mauke> > (zip =<< tail) [0 ..]
16:20:39 <lambdabot>  [(1,0),(2,1),(3,2),(4,3),(5,4),(6,5),(7,6),(8,7),(9,8),(10,9),(11,10),(12,11...
16:20:45 <mauke> hrml
16:21:06 <Botty> :type ap
16:21:10 <Botty> ?type ap
16:21:12 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
16:22:10 <mauke> (a -> b -> c) -> (a -> b) -> a -> c
16:22:50 <vincenz> > 0x10
16:22:52 <lambdabot>  16
16:23:18 <RemiTurk> > takeWhile (not . and . ap (zipWith (==)) tail) . iterate (ap (zipWith ((abs.) . (-))) tail) $ map (^3) [0..10]
16:23:20 <lambdabot>  [[0,1,8,27,64,125,216,343,512,729,1000],[1,7,19,37,61,91,127,169,217,271],[6...
16:23:35 <Botty> > tail $ zip [0..]
16:23:36 <lambdabot>    Expecting a function type, but found `a'
16:23:37 <lambdabot>    Expected type: [a]
16:23:37 <lambdabot>    ...
16:23:38 <vincenz> @hoogle zipWith4
16:23:38 <lambdabot> List.zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
16:23:51 <dcoutts> dons, interesting point about FRP and co-monads.
16:24:01 <vincenz> @type sequence
16:24:03 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
16:24:15 <Botty> oh, hmm
16:24:20 <dcoutts> dons, I suppose there must be some connection between the list co-monad and unfoldr
16:24:22 <mauke> > sequence ["abc", "def"]
16:24:24 <lambdabot>  ["ad","ae","af","bd","be","bf","cd","ce","cf"]
16:25:08 <Botty> > sequence [0..]
16:25:09 <lambdabot>  add an instance declaration for (Show (m [a]))
16:25:36 <Botty> > sequence [[0..],[0..]]
16:25:38 <lambdabot>  [[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[0,6],[0,7],[0,8],[0,9],[0,10],[0,11],[...
16:27:21 <Botty> @check \x -> sequence [x,[0..]] == map (\x -> [0,x]) [0..]
16:27:23 <lambdabot>  Add a type signature
16:31:38 <Botty> @check let foo x :: Int = sequence [x,[0..]] == map (\x -> [0,x]) [0..] in (foo)
16:31:39 <lambdabot>  Parse error
16:31:58 <Botty> @check let foo x :: Int = sequence [x,[0..]] == map (\x -> [0,x]) [0..] in (\x -> foo x)
16:31:59 <lambdabot>  Parse error
16:32:45 <twanvl> That will not work, because the (==) loops.
16:32:55 <Botty> mm, well, ohwel
16:33:09 <dons> dcoutts: hmm, list co-monad and unfoldr eh? maybe.
16:33:29 <dons> ?users
16:33:30 <lambdabot> Maximum users seen in #haskell: 265, currently: 243 (91.7%), active: 26 (10.7%)
16:33:40 <dcoutts> maybe I'm getting confused
16:33:58 <dcoutts> a list monad function is going to be :: [a] -> b
16:34:15 <dcoutts> so that's going to be a fold
16:34:21 <dons> i don't understand co-monads enough
16:34:36 <dcoutts> me neither
16:35:27 <vincenz> dons: I lost lambdabotperms?
16:35:37 <dons> oh?
16:35:52 <dons> vincenz: nope. maybe you aren't identified?
16:36:02 <vincenz> I am
16:36:11 * dons doublechecks
16:36:25 <dons>         admins          = [
16:36:25 <dons>                 "Pseudonym",    "shapr", "vincenz",    "Igloo",
16:36:25 <dons>                 "Cale",         "dons", "TheHunter",    "musasabi", "Lemmih"
16:36:25 <dons>         ],
16:36:30 <vincenz> odd
16:36:32 <dcoutts> we need a convenient reference card we defs of: functor, applicative functor, monad, co-monad, arrow etc
16:36:36 <vincenz> @join #oasis
16:36:39 <vincenz> that explains
16:36:42 <vincenz> @part alone doesn't work
16:36:46 <dons> yes.
16:36:47 <dons> :)
16:36:50 <dons> syntax error.
16:37:27 <vincenz> riastradh in #scheme ws asking me the way to do something in haskell
16:37:35 <vincenz> not sure what I put is idiomatic
16:37:37 <vincenz> http://paste.lisp.org/display/29694#3
16:38:53 <dons> import Arrays as ??
16:39:19 <EvilRanter> @type zip4
16:39:21 <lambdabot> forall d c b a. [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
16:39:37 <EvilRanter> zip4 = zipWith4 (,,,)
16:39:47 <vincenz> dons: oh A.
16:39:53 <vincenz> dons: the main point was doing different things in "parallel"
16:39:58 <vincenz> dons: while also outputting the integer
16:40:33 <dons> EvilRanter++
16:40:39 <dons> ?pl zipWith4 (,,,)
16:40:39 <lambdabot> zipWith4 (,,,)
16:40:42 <dons> too hard :)
16:41:14 <dcoutts> isn't it point free already ?
16:41:31 <dcoutts> @type zipWith4 (,,,)
16:41:33 <dons> yeah, but @pl also spots refactorings of other kinds
16:41:33 <lambdabot> forall a b c d. [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
16:41:47 * beelsebob remembers why he doesn't use php
16:41:51 <dons> ?pl return . f =<< getContents
16:41:52 <lambdabot> f `fmap` getContents
16:41:56 <dons> for example
16:42:09 <vincenz> dons: for the rest it looks ok, right?
16:42:23 <dons> beelsebob: because its like programming while having a stroke?
16:42:39 <dons> vincenz: yeah. you see my annotation?
16:42:40 <dcoutts> @pl \as bs cs ds -> zipWith4 (\a b c d ->(a,b,c,d)) as bs cs ds
16:42:41 <lambdabot> zipWith4 (,,,)
16:42:45 <vincenz> dons: yeps
16:42:52 <beelsebob> dons: well, yes, that, and the community are a load of wankers...
16:43:05 * lambdabot hugs dons
16:43:06 <vincenz> doh
16:43:29 <dcoutts> beelsebob, is that because they're trying to make money rather than doing it for fun ? :-)
16:43:39 <vincenz> those soulless bastards
16:43:39 <dons> beelsebob: how can you say that about a community that invented a manual MOD patch language? ;)
16:43:42 <beelsebob> @paste
16:43:43 <lambdabot> http://paste.lisp.org/new/haskell
16:44:29 <dcoutts> dons, that stands for MODular programming style doesn't it ? ;-)
16:45:48 <beelsebob> http://paste.lisp.org/display/29709 <-- the oppers in #php kick you for asking questions about the languge
16:45:50 <dcoutts> presumably their progs are so monolithic that standard diff/patch causes too many conflicts and so they needed a more forgiving patch format
16:48:22 <dons> I suspect they didn't know about diff/patch
16:50:01 <jgrimes> beelsebob, wow... thats quite a display on their part.
16:50:12 <beelsebob> jgrimes: it's stunning - isn't it?
16:50:15 <dcoutts> beelsebob, though to be fair, you were annoying the oper. That's never a good idea,
16:50:28 <beelsebob> dcoutts: I had no idea he was an opper until he opped and banned
16:50:31 <dcoutts> dons, I really find that hard to believe.
16:50:33 <jgrimes> beelsebob, yes. and now I am curious as to why that wouldn't be allowed.
16:50:38 <dcoutts> beelsebob, heh ok
16:51:06 <jgrimes> it didn't seem to me that beelsebob was being -that- annoying. the guy just didn't know the answer and should have said so.
16:51:09 <jgrimes> :p
16:51:10 <dons> beelsebob: wow. kind of a psycho chan
16:51:22 <beelsebob> dcoutts: I wasn't deliberately annoying anyone... I was trying to get an answer to a question about the language... specifically on something that's not documented anywhere
16:51:32 <dcoutts> yeah, I saw
16:51:34 <beelsebob> jgrimes: yeh, that's the conclusion I came to
16:51:51 <dons> beelsebob: yeah, but i guess the channel isn't full of people who deeply understand the language .. if anyone does
16:52:11 <dons> try to avoid php if you possibly can. its a very demoralising thing to use
16:52:17 <jgrimes> I'd like to meet a person that deeply understands php.
16:52:21 <beelsebob> I mean... it could have ended *way* before then if he'd just said "I don't know why it doesn't work, sorry... but this does work"
16:52:29 * RemiTurk would like that too, but with a fence between us
16:52:31 <dcoutts> beelsebob, you're too used to orthogonal languages without arbitrary restrictions :-)
16:52:37 <beelsebob> hehehe
16:52:39 <beelsebob> *g*
16:53:08 <dcoutts> there's a talk in Oxford on Wednesday about trying to program sanely in PHP
16:53:15 <beelsebob> oh oh oh!
16:53:17 <beelsebob> can I come!
16:53:21 <RemiTurk> it looks to me as if they've got _far_ too many annoying teens screaming why something doesn't work, and lost the ability to reasobly reply to questions about The Language
16:53:22 <beelsebob> can I try and get an answer?
16:53:24 <dcoutts> beelsebob, "Applying Good Practice to a Misused Language"
16:53:32 <dcoutts> beelsebob, you can certainly come
16:53:34 <dons> rm -rf php ; tar xzf ghc-6.6.tgz ?
16:53:36 <beelsebob> *g*
16:53:37 <osfameron> there does appear to be some good PHP code though...
16:53:39 <RemiTurk> :)
16:53:41 <beelsebob> I may just have to
16:53:45 <osfameron> Drupal seems fairly sanely architected for example
16:53:52 <osfameron> can't say I was impressed by Mediawiki though
16:54:34 <beelsebob> the thing that confuses me most... is that one person said "you should never want to do that", and the other person said "yeh, there's a languageg construct specifically for that because you want to do it so often"
16:54:51 <dons> heh
16:55:00 * RemiTurk thinks "class HBool b => HTIntersectBool b h t l1 l2 | b h t l1 -> l2" doesn't that great either
16:55:07 <dcoutts> designed by people too close to the problem
16:55:12 <beelsebob> indeed
16:55:32 <beelsebob> they were thinking too much about "what you would want to do" instead of "what being allowed to do this would let you do"
16:55:43 <dcoutts> beelsebob, anyway, the talk should be advertised on http://www.ox.compsoc.net/ except that the site seems to be down.
16:56:00 <beelsebob> okay, I'll have a stare at some point
16:56:07 <beelsebob> and I might just drive over
16:56:19 <beelsebob> although Oxford has not too many happy memories for me
16:56:29 <dcoutts> beelsebob, are you turning up for the Thursday afternoon thing ?
16:56:41 <beelsebob> dcoutts: there's a thursday afternoon thing?
16:56:51 <lambdabot> Title: Oxford University Computer Society
16:56:53 <beelsebob> and probably not... I think I have to give an FP group talk on thursday
16:57:11 <dcoutts> beelsebob, heh, most other FP people will be in Oxford!
16:57:20 <beelsebob> hehe
16:57:31 * Igloo imagines beelsebob turning up to an empty room and wondering where everyone is
16:57:34 <beelsebob> so what's happening on thursday afternoon then?
16:57:46 * beelsebob pokes Igloo - that's mean!
16:58:37 <dcoutts> http://sneezy.cs.nott.ac.uk/fun/
16:58:38 <lambdabot> Title: Fun in the Afternoon
16:58:40 <dcoutts> beelsebob, ^^
16:58:40 <Igloo> The webserver seems fine now, incidentally
16:58:50 <dcoutts> Igloo, ah yes, it's back
16:59:45 <theoco> what do people here think about the new c-compiler for nvidia cards?
17:00:24 <beelsebob> dcoutts: hmm, looks interesting, but I don't think I can put off the FP group talk because Simon T and his host of minions will be at that one, and they're pretty much the only people this talk is aimed at
17:00:52 <dcoutts> beelsebob, shame, you should tell Simon et al to come up to Oxford
17:01:09 <beelsebob> hehe, I don't think he has time
17:01:16 <beelsebob> he seems ludicrously busy at the moment
17:01:22 <dcoutts> what's he up to?
17:01:24 <theoco> to me it seems that nvidia gpu + fp would be an awesome combination
17:01:36 <beelsebob> trying to get HaRe to become the Erlang Refactorer instead
17:01:48 <beelsebob> and trying to run a department
17:02:09 <dcoutts> beelsebob, I want to tell him that I want to come to UKC for a post-doc to hack on Haskell refactoring and IDE-like dev tools :-)
17:02:24 <Igloo> UKC?
17:02:32 <beelsebob> hehe, ahhh... so there's an alteriour motive then!
17:02:33 <beelsebob> :P
17:03:09 <dcoutts> Igloo, kent.ac.uk
17:03:14 <dcoutts> beelsebob, well, that too :-)
17:03:20 * Igloo scratches his head
17:03:26 <dcoutts> beelsebob, I'm only half serious
17:03:32 <beelsebob> hehe :P
17:03:41 <dcoutts> I doubt there's funding for that kind of thing
17:03:59 <beelsebob> I don't know... he's just started this Erlang project so there *might* be money floating about
17:04:02 <Igloo> Ah, I see
17:04:15 <beelsebob> but I think that goes to Hui King
17:04:22 <beelsebob> or however you spell her name
17:04:37 <dcoutts> beelsebob, ah so there's more money in Erlang because of the business connections?
17:05:01 <beelsebob> err... maybe
17:05:07 <beelsebob> don't ask me... ask him :P
17:05:08 <Igloo> Urgle - Kent has a Brussels campus?
17:05:12 <beelsebob> apparently
17:05:16 <dcoutts> heh
17:05:28 <beelsebob> not that anyone here actually knows
17:05:42 <dons> theoco: we actually have people working on compiling haskell to the gpu
17:05:55 <theoco> dons: sweet!
17:06:01 <dons> now there's an nvidia C -> GPU compiler, and the new gen nvidia machines have 128 core...
17:06:05 <dons> its a pretty attractive target
17:06:31 <Igloo> I think he said Erlang was easier for a refactorer, because pretty much all Erlangers use the same Haskell mode with the same code layout, so you can just pretty-print in that style without upsetting them and thus don't have to try to be clever with laying stuff out as it started off
17:06:44 <Igloo> Arg, s/Haskell/emacs/
17:07:22 <Igloo> dons: Is there a sane way of getting results back?
17:07:28 <beelsebob> Igloo: yes and no... He has a lot of problems with erlang doing odd things
17:07:39 <beelsebob> last I saw he was saying that erlang was a lot harder than Haskell
17:07:46 <dons> Igloo: yeah, you can just copy the data back from the gpu
17:07:50 <dons> (doesn't have to go to the screen ;)
17:07:53 <Igloo> Heh, well you've probably heard more recently than I  :-)
17:07:59 <theoco> dons: will haskell be able to put different functions into processors on-the-fly aka without specifing that in the language?
17:08:02 <Igloo> Cool
17:08:20 <dons> processors? you mean like multi core machines?
17:08:34 <Igloo> ISTR someone telling me when pixel shaders first appeared that getting them to do computatino for you was easy, but getting the results back was difficult and/or slow
17:08:35 <beelsebob> well... the GPUs *are* multi-core machines
17:08:40 <theoco> dons: yes, like automatically thread your program to use the 128 cpus
17:08:45 <dons> yes, that's underway. at least for arrays you can already do it. with forkIO/par you get the same effect
17:08:47 <dcoutts> Igloo, it's certainly slow
17:08:59 <dons> completely automatic threading is unlikely soon
17:09:06 <theoco> dons: My next cpu is a gpu!!
17:09:11 <dons> but for the gpu, there's a class of array programs for which is will work
17:09:29 <dcoutts> they're set up to be fast for writing to the gfx memory but slow to read back
17:09:47 <dons> though, since they're a lot simpler than a cpu, they're progressing much faster
17:09:57 <dons> so the gpu manufacturers are ahead in the game, atm
17:10:03 <theoco> after that im gonna buy a RPU
17:10:05 <dons> and lifting more and more restrictions on how the gpu can be used
17:10:22 <theoco> the nvidia rpu, comming to stores 2008
17:10:26 <dcoutts> I expect that in a few years we'll see gfx 'cards' being co-processors on dual-socket motherboards and going via hypertransport
17:10:32 <dcoutts> well at least for amd/ati
17:10:52 <beelsebob> dcoutts: we already do... the problem is that they're non-upgradable
17:11:08 <dcoutts> beelsebob, because they're in the northbridge
17:11:19 <dcoutts> rather than in a cpu socket
17:11:23 <encryptio> eh... cell seems like a more likely scenario...
17:11:28 <theoco> has nvidia solved the von neumann bottleneck?
17:11:48 <theoco> with its massive 384-bit memory bus?
17:11:52 <lispy> about 5-6 years ago i heard about processor that was very fast at pattern matching but couldn't do much else...i'm surprised those haven't become popular for accelerating machine learning...could have applications in usability i'd think
17:12:00 <beelsebob> dcoutts: yeh, because if you do put the chip on the mobo you also need to stick the bus and the RAM on there too
17:12:14 <falconair> does any one know if there is a general computer science irc channel (like #math)?
17:12:24 <beelsebob> and GFX RAM and buses get upgraded much faster than the bus to connect to the mobo
17:13:49 <dcoutts> beelsebob, an amd64 style thing where the processor connects directly to the ram isn't that much different
17:14:08 <dcoutts> and the much faster link to the main cpu would be an advantage
17:15:21 <dons> i also wonder that if the cpu manufacturers can get their act together, the gpu would be just about obsolete. 128 cpu cores, why not use one as a gpu :)
17:15:35 <beelsebob> dcoutts: suppose I'm the kind of person that makes gfx card makers money... i.e. I'm a gamer
17:15:37 <encryptio> dons: that's the idea behind cell
17:15:43 <beelsebob> suppose I bought a computer last year
17:15:45 <SamB> dons: one what?
17:15:45 <dons> though by that point the cpu would look like a gpu pretty much
17:15:47 <dons> encryptio: yeah.
17:15:57 <beelsebob> I will have a GeForce 6 or some such
17:15:59 <SamB> and I thought GPUs were vector units
17:16:01 <theoco> dons: I think going the graphics route has led ati/nvidia innovate the processing unit in general
17:16:02 <beelsebob> this year I will upgrade it
17:16:09 <beelsebob> for another $600
17:16:14 <dons> theoco: exactly
17:16:19 <theoco> dons: intel is too far behind with 2 and 4 cores
17:16:20 <beelsebob> if I'd bought the gfx card on the mobo I couldn't do that
17:16:24 <dons> and more so now they realise how close to general purpose computatoin they are
17:16:29 <dons> i.e. the new nvidia C compiler, for exmaple
17:16:36 <dons> illustrates they know what's going on
17:16:39 <SamB> wouldn't you maybe have different cores for GPU and CPU usage?
17:16:53 <dcoutts> beelsebob, I just upgraded my cpu without changing anything else, is a gfx cpu that different ?
17:16:53 <beelsebob> theoco: I actually saw recently, Intel were experimenting with an 80 core CPU
17:17:15 <beelsebob> dcoutts: because the upgrade to the graphics card is *mostly* powered by memory bandwidth, not by processing power
17:17:24 <SamB> dcoutts: the gpu is soldered on
17:17:31 <beelsebob> it's the bus you upgrade, not the processor
17:17:47 <dcoutts> beelsebob, the bus between the gpu and the memory ?
17:17:53 <beelsebob> yes
17:17:56 <dcoutts> mm
17:18:03 <beelsebob> brb
17:18:59 <theoco> beelsebob: and the multiple cores
17:19:45 <theoco> dcoutts: nvidia 8800 can do 86/GBps between processor and memory
17:19:59 <lispy> wow
17:20:26 <dcoutts> so that's mostly down to multiple channels I suppose
17:20:37 <theoco> dcoutts: they had to to support 1600x1200@30fps. Intel has been engineering "branch prediction" aka crap
17:20:38 <dcoutts> because of the great parallelism
17:21:18 <dcoutts> so what's the memory bandwidth of the top cpus ?
17:21:20 <theoco> hmm, our processor can do far more than the bus allows, hmmm lets guess at data....
17:21:26 <beelsebob> dcoutts: 22.3GB-s
17:21:30 <beelsebob> on the MacPro
17:21:37 <beelsebob> which is 2 dual core chips
17:21:44 <beelsebob> so about 11GB/s on a single chip
17:21:49 <dcoutts> so that's because it is only 2 way rather than 128
17:21:55 <dcoutts> so it can't use much more
17:22:01 <theoco> 100/mhz bus * 64-bit, somthing like 1/GBps
17:22:38 <theoco> compare nvidia: 384-bit bus @ 788Mhz
17:22:49 <beelsebob> dcoutts: bear in mind that that's an increadably high bandwidth chip
17:23:07 <beelsebob> the Core2Duo has a bandwidth of about 4GB/s
17:23:15 <beelsebob> as does the Core2Extreme
17:25:45 <dons> jcreigh++ http://jcreigh.blogspot.com/2006/11/simple-rpn-calculator-in-haskell.html
17:25:48 <lambdabot> Title: Jason Creighton's Blog: A Simple RPN Calculator in Haskell, http://tinyurl.com/trg44
17:28:18 <dons> interesting, http://murad-m.blogspot.com/2006/11/haskell.html
17:28:20 <lambdabot> http://tinyurl.com/yab4k2
17:31:37 <dons> hmm http://www.quviq.com/ ?
17:31:39 <lambdabot> Title: This page is under construction
17:31:49 <dons> !!
17:31:57 <dons> "What is Quviq QuickCheck?"
17:33:37 <dons> wow
17:42:13 <dons> mmm. nice. http://www.theregister.co.uk/2006/11/10/gpl_wallace_appeal/
17:42:16 <lambdabot> http://tinyurl.com/yneb8n
17:44:07 <mwc> Lokos like he's taken haskell's quickcheck and set it up to run for other languages.
17:45:21 <dons> well, he's the original author, so I guess that's ok :)
17:45:53 <dons> (the erlang port has been around for quite a while, and the java port too, but looks like they've got an erlang-automated-testing startup?)
17:46:24 <mwc> I'm not sure who Mike Dodds is, but props to him for the firefox search plugin
17:46:25 <mwc> http://mycroft.mozdev.org/download.html?name=hoogle&sherlock=yes&opensearch=yes&submitform=Search
17:46:27 <lambdabot> http://tinyurl.com/y6ojux
17:46:48 <dons> oh, i recognise the name. i think he's on the mailing lists
17:46:54 <dons> and here too?
17:47:06 <mwc> Yeah, he wrote a Hoogle plugin for firefox
17:47:09 <mwc> saves me a coupla seconds
17:47:28 <dons> cool
17:48:51 <dcoutts> I think it'd be nice to integrate hoogle into haddock more
17:48:56 <chessguy> is that a hoogle plugin?
17:49:07 <mwc> chessguy, yeps
17:49:07 <dcoutts> we should be able to generate haddock docs with a built-in hoogle search
17:49:16 <chessguy> nice
17:49:24 <dcoutts> and the hoogle search would be just for those docs
17:49:28 <mwc> dcoutts, well, the javascript would be pretty easy
17:49:32 <mwc> the issue I see is the database...
17:49:37 <dons> dcoutts: hmm. yes!
17:49:43 <dcoutts> mwc, haddock already generates hoogle databases
17:49:59 <dons> i bet ndm would be interested
17:50:11 <mwc> oh, then it sounds like a simple enough job for somebody who can hack on HTML and JS
17:50:26 <dcoutts> mwc, but it'd need hoogle installed server side, no ?
17:50:45 <dcoutts> mwc, or you mean rewriting it all in JS ?
17:51:12 <mwc> Yeah, well, you'd need to have something availible to look through the database and pull up results
17:51:32 <mwc> so I think you could do it with some JS if you want a self-contained system
17:51:36 <dcoutts> right, so include the hoogle db in the directory, much like the current .haddock file
17:51:55 <dcoutts> and then include a .cgi file too
17:52:06 <dcoutts> so you'd need hoogle installed server side
17:52:11 <dcoutts> but no other config necssary
17:52:23 <dcoutts> the .cgi would tell the hoogle command line where the db is
17:52:37 <mwc> well, if you wanted some portability, you could do something like hoogle.cgi: #! runHaskell
17:52:53 <dcoutts> aye, could do, might be a bit slow
17:52:56 <mwc> and then put a simple search code in there
17:53:05 <mwc> I suppose, but the database is already generated
17:53:11 <mwc> doing the actual lookup shouldn't be too hard.
17:53:46 <mwc> Actually, does runHaskell admit #!?
17:53:59 <mwc> or would that trigger a syntax error
17:55:57 <monochrom> #! triggers a syntax error for *.hs files.
17:56:10 <dons> no it doesn't!
17:56:11 <monochrom> But don't forget there is also *.lhs
17:56:22 <monochrom> Woah?!  Too good to be true!
17:56:25 <dons> $ cat Setup.hs
17:56:25 <dons> #!/usr/bin/env runhaskell
17:56:25 <dons> import Distribution.Simple
17:56:25 <dons> main = defaultMainWithHooks defaultUserHooks
17:56:43 <dons> might be ghc only
17:57:14 <monochrom> Why is /usr/bin/env there?
17:57:22 <SamB_XP> is it too late to add it to Haskell'?
17:57:34 <dons> monochrom: since runhaskell lives in some other places
17:57:41 <dons> SamB_XP: hmm.
17:57:43 <dons> good questoin.
17:57:56 <dons> would be trivial i suspect, to have every compiler support it
17:57:56 <SamB_XP> I suspect, being so trivial, it isn't...
17:58:06 <SamB_XP> i mean, even adding it to hugs would not be hard
17:58:57 <SamB_XP> hmm, I think I see why VBA has a "pause when inactive window" option...
18:00:00 <SamB_XP> because otherwise, when you try to type, it is still reading the keyboard, and strange things could happen in your game...
18:01:04 <lispy> SamB_XP: it can read the keyboard even when not focused?
18:01:14 <SamB_XP> apparantly!
18:01:51 <SamB_XP> note that this is the Windows version
18:02:09 <SamB_XP> the other one, of course, wouldn't be able to do things like that...
18:03:12 <lispy> you'd think they'd just check "if (hasFocus) { /* process keyboard */ } else { /* skip it */ }"
18:04:29 <lispy> i mean, assuming they have a legitimate reason for look at all keyboard input
18:05:40 <SamB_XP> does "the API we were using works that way" count?
18:06:04 <SamB_XP> okay, so maybe that isn't the *only* reason it has that option
18:06:11 <SamB_XP> I guess I just figured out why I had had it on
18:10:30 <dons> is ocaml doing something weird in this article? http://programming.reddit.com/info/qgre/comments
18:10:34 <lambdabot> Title: Seeing what an OCaml looks like (reddit.com), http://tinyurl.com/ydv4bk
18:12:01 <dcoutts> dons, what do you mean exactly?
18:13:00 <sjanssen> http://www.haskell.org/haskellwiki/Shootout/Fasta
18:13:03 <dcoutts> you mean it's being too eager ?
18:13:04 <lambdabot> Title: Shootout/Fasta - HaskellWiki, http://tinyurl.com/vznau
18:13:09 <dons> dcoutts: yeah?
18:13:23 <sjanssen> comments and enhancements for the "Proposed entry" would be much appreciated
18:13:48 <dcoutts> dons, because it's printing Hello at the time of constructing the function rather than when it's finally evaluated.
18:13:57 <dons> very nice sjanssen
18:13:57 <dcoutts> dons, that's the advantage of IO monad
18:14:00 <dons> i'll have a look today
18:14:06 <dons> dcoutts: ah yes.
18:14:09 <dons> seems weird :)
18:14:16 <dcoutts> it prevents you from making that kind of mistake
18:14:17 <dons> strict languages, eh?
18:14:26 <dcoutts> yep, poor things
18:16:23 <dcoutts> come to think of it, there's a whole class of bugs we just can't make because of having the IO monad
18:16:31 <dcoutts> eg in guis you're often passing IO () values about
18:16:38 <dons> yeah
18:16:42 <dcoutts> if they happened too early ....
18:16:43 <dons> which just wouldn't work
18:16:45 <dons> scary
18:16:48 <dcoutts> yeah
18:17:10 <jcreigh> dons: just out of curiosity, how'd you even find my blog? I didn't think anybody read it. :)
18:17:22 <SamB_XP> see,
18:17:39 <dcoutts> jcreigh, you mentioned Haskell, so dons found you. He can smell that kind of thing.
18:17:45 <SamB_XP> this is what I mean when I say that Haskell is the only language I know of that has first-class support for imperative programming...
18:17:45 <jcreigh> heh
18:17:53 <dons> jcreigh: rss! http://www.google.com.au/blogsearch?hl=en&q=haskell+programming
18:17:56 <lambdabot> Title: Google Blog Search: haskell programming, http://tinyurl.com/y2dtr8
18:17:59 <dons> ;)
18:18:12 <dcoutts> SamB_XP, yep, SPJ agrees with you. There' that nice quote somewhere
18:18:15 <dons> i have an acute haskell spiny sense.
18:18:24 <SamB_XP> @quote SamB
18:18:25 <sjanssen> @quote+ dcoutts jcreigh, you mentioned Haskell, so dons found you. He can smell that kind of thing.
18:18:25 <lambdabot>  any list of application domains is either incomplete or depressing
18:18:26 <lambdabot> dcoutts jcreigh, you mentioned Haskell, so dons found you. He can smell that kind of thing. hasn't said anything memorable
18:18:41 <dcoutts> sjanssen, @remember
18:18:44 <sjanssen> bleh
18:18:51 <SamB_XP> @quote SamB
18:18:51 <lambdabot>  C is a good language. If what you want is an assembly language where you can't be sure what anything does
18:18:53 <SamB_XP> @quote SamB
18:18:53 <lambdabot>  O(n^2) is better than O(hair-gone)
18:18:54 <SamB_XP> @quote SamB
18:18:55 <lambdabot>  and then I'd like to see your Os
18:18:57 <SamB_XP> @quote SamB
18:18:57 <lambdabot>  GHC is smart
18:18:58 <SamB_XP> @quote SamB
18:18:59 <lambdabot>  I was just saying that encasing poeple in concrete is not the best solution to that problem
18:19:02 <SamB_XP> @quote SamB
18:19:02 <lambdabot>  any list of application domains is either incomplete or depressing
18:19:06 <dons> (yeah, i actually have an rss feeder that pulls google blog search results :)
18:19:07 <SamB_XP> hmm.
18:19:12 <SamB_XP> I think it was in there somewhere...
18:19:14 <SamB_XP> @quote SamB
18:19:15 <lambdabot>  I was just saying that encasing poeple in concrete is not the best solution to that problem
18:19:16 <SamB_XP> @quote SamB
18:19:17 <lambdabot>  <SamB> @. bf . id . pl . v . wn yow  <lambdabot> Done.
18:19:25 <sjanssen> @remember dcoutts jcreigh, you mentioned Haskell, so dons found you. He can smell that kind of thing.
18:19:25 <dcoutts> dons, you shouldn't have let on :-)
18:19:48 <dcoutts> SamB_XP, I liked the mob solution quote :-)
18:20:00 <dons> and maintain my aura of god-like search powers, eh?
18:20:08 <SamB_XP> @quote SamB
18:20:08 <dcoutts> exactly :-)
18:20:08 <lambdabot>  C is a good language. If what you want is an assembly language where you can't be sure what anything does
18:20:10 <SamB_XP> @quote SamB
18:20:10 <lambdabot>  C is a good language. If what you want is an assembly language where you can't be sure what anything does
18:20:12 <SamB_XP> @quote SamB
18:20:12 <lambdabot>  I was just saying that encasing poeple in concrete is not the best solution to that problem
18:20:20 <SamB_XP> dcoutts: which, that one?
18:20:24 <dcoutts> yep
18:20:37 <SamB_XP> why oh why does it keep repeating the ones I don't want?
18:20:55 <dcoutts> SamB_XP, because it know which one you do want.
18:21:04 <dcoutts> @botsnack
18:21:04 <lambdabot> :)
18:21:12 <EvilRanter> @foo
18:21:12 <lambdabot> Maybe you meant: faq ft todo yow
18:21:21 <SamB_XP> how about we let nasty = False
18:21:26 <SamB_XP> and try again?
18:21:28 <lispy> SamB_XP: because as soon as you get the quote you want you'll stop playing with her...and lambdabot is lonely?
18:21:30 <SamB_XP> @let nasty = False
18:21:32 <lambdabot> Defined.
18:21:33 <SamB_XP> @quote SamB
18:21:34 <lambdabot>  Haskell is the only language I know with first-class support for imperative programming
18:21:36 <SamB_XP> ah.
18:21:40 <SamB_XP> worked nicely ;-)
18:21:44 <sjanssen> impressive
18:21:56 <SamB_XP> @bot
18:21:56 <lambdabot> :)
18:22:03 <sjanssen> @undefine nasty
18:22:05 <lambdabot> Undefined.
18:22:31 <dcoutts> @slap sjanssen
18:22:32 * lambdabot smacks sjanssen about with a large trout
18:22:42 <dcoutts> yep, back to normal
18:24:13 <lispy> > fix show
18:24:14 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
18:24:19 <lispy> very normal
18:24:32 <sjanssen> > fix show -- was it ever broken?
18:24:34 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
18:24:41 <lispy> ?. vixen fix show
18:24:42 <lambdabot> compose module failed: IRCRaised Parse error: "fix"
18:24:47 <lispy> ?. vixen run fix show
18:24:49 <lambdabot> Tell me truthfully what the nastiest thing you have ever done.
18:25:11 <lispy> lambdabot: i think you mean "...what is the ..."
18:25:23 <jcreigh> > fix cos
18:25:25 <lambdabot>  Exception: <<loop>>
18:25:35 <Botty> actually, I'm pretty sure she means it as a command...
18:25:47 <sjanssen> @vixen Exception: <<loop>>
18:25:47 <lambdabot> Bollox!
18:26:16 <SamB_XP> truthfully what the nastiest thing you have ever done.
18:26:32 <lispy> ?quote largos
18:26:33 <lambdabot>  [on programming languages] "...and I'd rather not own as much rope as c/c++ gives you."
18:26:33 <Botty> good point
18:27:00 <jcreigh> um...does "fix" do what I think it does? (ie, try to find the fixed point of a function?)
18:27:13 <lispy> jcreigh: yup
18:27:27 <SamB_XP> try?
18:27:31 <lispy> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
18:27:32 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
18:27:59 <sjanssen> @pl y f = f (y f)
18:28:01 <lambdabot> y = fix (ap id)
18:28:40 <lispy> ?type ap id
18:28:42 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
18:28:56 <jcreigh> @type fix
18:28:57 <EvilRanter> @djinn MonadPlus m => Bool -> m a
18:28:58 <lambdabot> forall a. (a -> a) -> a
18:28:58 <lambdabot> Cannot parse command
18:29:03 * RemiTurk thinks that looks more complicated than it needs to be
18:29:15 <SamB_XP> how could it fail?
18:29:22 <SamB_XP> > fix id
18:29:23 <lambdabot>  Add a type signature
18:29:23 <sjanssen> RemiTurk: ideally, lambdabot would've said "y = fix"
18:29:26 <SamB_XP> > fix id :: ()
18:29:28 <lambdabot>  Exception: <<loop>>
18:29:36 <RemiTurk> sjanssen: indeed
18:29:44 <lispy> SamB_XP: well, some people might consider fix f = _|_ to be failure
18:29:56 <SamB_XP> lispy: I'd say it was also the least fixed point...
18:30:05 <lispy> right
18:30:11 <SamB_XP> since it is the *least*
18:30:24 <SamB_XP> isn't it?
18:30:27 <RemiTurk> hm, that is, unless lambdabot is smart enough to see that fix is "more efficient" than "y f = f (y f)" and decided it needed to give something less efficient than fix
18:30:40 <jcreigh> > fix \x -> 1 + (1 / x)
18:30:40 <lambdabot>  Parse error
18:30:47 <SamB_XP> RemiTurk: you give @pl too much credit
18:30:51 <jcreigh> > fix (\x -> 1 + (1 / x))
18:30:52 <lambdabot>  Exception: <<loop>>
18:30:58 <RemiTurk> SamB_XP: a man can dream ;)
18:31:03 <lispy> > fix $ \x -> 1 + (1 / x)
18:31:04 <lambdabot>  Exception: <<loop>>
18:31:28 <SamB_XP> @pl doesn't know a thing about efficieny. it also doesn't know english from haskell
18:31:28 <lambdabot> doesn't know a thing about efficieny . it also doesn't know english from haskell
18:31:31 <lispy> > fix \x -> x + 1
18:31:31 <lambdabot>  Parse error
18:31:37 <lispy> > fix $ \x -> x + 1
18:31:38 <lambdabot>  Exception: <<loop>>
18:32:32 <sjanssen> SamB_XP: your input /is/ valid Haskell
18:32:47 <SamB_XP> sjanssen: point
18:33:14 <lispy> ?pl But.does it handle modules?
18:33:14 <lambdabot> (line 1, column 27):
18:33:15 <lambdabot> unexpected "?"
18:33:15 <lambdabot> expecting variable, "(", ".", white space, operator or end of input
18:33:15 <lambdabot> ambiguous use of a left associative operator
18:33:23 <lispy> ?pl But.does it handle modules
18:33:24 <lambdabot> But . does it handle modules
18:33:31 <lispy> and the answer is no
18:34:24 <jcreigh> > fix id :: Int
18:34:26 <lambdabot>  Exception: <<loop>>
18:35:57 <EvilRanter> shurely id == id id?
18:36:10 <lispy> > (fix $ \fact n -> if n == 0 then 1 else n * fact (n-1)) 4
18:36:12 <lambdabot>  24
18:36:12 <SamB_XP> indeed not
18:36:18 <SamB_XP> > id == id id
18:36:18 <lambdabot>  add an instance declaration for (Eq (a -> a))
18:36:19 <lambdabot>   In the definition of `eop...
18:36:26 <lispy> ?type id id
18:36:28 <lambdabot> forall a. a -> a
18:37:10 <SamB_XP> @scheck \x -> id x == id id (x :: Int)
18:37:11 <lambdabot>  Completed 10 test(s) without failure.
18:37:52 <SamB_XP> EvilRanter: but what does that have to do with fixed points?
18:37:53 <EvilRanter> _s_check?
18:38:25 * RemiTurk is sleepy
18:38:27 <SamB_XP> @check \x -> id x == id id (x :: Int)
18:38:28 <lambdabot>  OK, passed 500 tests.
18:38:28 <RemiTurk> good night everyone
18:38:39 <SamB_XP> see, SmallCheck /= QuickCheck
18:38:54 <EvilRanter> er, nm
18:38:56 <RemiTurk> > fix ('z':)
18:38:58 <lambdabot>  "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz...
18:39:01 <EvilRanter> haha
18:39:32 <EvilRanter> > fix (1.1*)
18:39:33 <lambdabot>  Exception: <<loop>>
18:39:52 <lispy> > fix ('"':)
18:39:53 <lambdabot>  "\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\"\...
18:40:00 <SamB_XP> actually, I suppose if _|_ counted as a fixed point, then fix would *always* return it...
18:40:23 <SamB_XP> unless it is supposed to find the next-least fixed point?
18:40:45 <jcreigh> > fix (\x -> 42)
18:40:46 <lambdabot>  42
18:42:50 <jcreigh> SamB_XP: since \x -> 42 doesn't even evaluate its argument, wouldn't that mean it doesn't have _|_ as a fixed point? Or am I just confused?
18:42:59 <SamB_XP> jcreigh: oh, true
18:43:01 <SamB_XP> hmm.
18:43:11 <SamB_XP> so I guess maybe it does find the least fixed point?
18:43:20 <SamB_XP> yeah, it must...
18:43:38 <dolio> 'z': doesn't really have _|_ as a fixed point, either.
18:43:56 <SamB_XP> > fix (z:)
18:43:57 <lambdabot>  Not in scope: `z'
18:44:01 <SamB_XP> > fix ('z':)
18:44:03 <lambdabot>  "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz...
18:44:10 <SamB_XP> okay, so it does ;-)
18:44:18 <dolio> Because f _|_ is 'z':_|_
18:44:32 * SamB_XP was right after all
18:44:47 <dolio> Since the way you define least fixed point is the limit of such applications.
18:45:17 <dolio> _|_, 'z':_|_, 'z':'z':_|_ ...
18:45:23 <SamB_XP> so for strict f, fix f = _|_, for lazy functions, it does not...
18:45:31 <SamB_XP> hmm?
18:46:15 <jcreigh> > fix (\x -> x*x)
18:46:16 <lambdabot>  Exception: <<loop>>
18:46:20 <SamB_XP> well, that is, if a function needs its argument in WHNF before applications of it reach WHNF
18:46:25 <dolio> I guess that's true. Strict f means that f _|_ = _|_, so every element in that sequence is _|_.
18:46:48 <dolio> So for there to be a fixed point other than _|_, f has to be non-strict.
18:47:06 <lispy> now this is cool
18:47:08 <dons> what did we ever talk about in here before > eval in lambdabot?
18:47:16 <lispy> > take 50 . map length . group . fix $ \s -> show s
18:47:20 <lambdabot> Terminated
18:47:28 <lispy> > take 20 . map length . group . fix $ \s -> show s
18:47:30 <lambdabot>  [1,1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,511,1,1023]
18:47:35 <lispy> > take 20 . map length . group . fix $ \s -> "\"" ++ show s
18:47:37 <lambdabot>  [2,1,1,1,1,3,1,3,1,7,1,7,1,15,1,15,1,31,1,31]
18:47:48 <lispy> > take 50 . map length . group . fix $ \s -> "\"\"" ++ show s
18:47:50 <lambdabot>  [3,1,1,1,1,1,1,3,1,3,1,3,1,7,1,7,1,7,1,15,1,15,1,15,1,31,1,31,1,31,1,63,1,63...
18:47:58 <SamB_XP> hmm, the CBV's logo is Haskell Curry's Y combinator...
18:48:20 <lispy> adding quotes at the front increases the number of duplicates but otherwise doesn't change the sequuence
18:48:45 <dolio> That's least fixed point (mu), though. There's also nu (greatest fixed point?), and I don't know how that's defined.
18:49:09 <SamB_XP> oh, that isn't going to be defined for Haskell I don't think...
18:49:11 <lispy> > take 50 . map length . group . fix $ \s -> drop 1 (show s)
18:49:12 <lambdabot>  Exception: <<loop>>
18:49:43 <jcreigh> > fix (1:)
18:49:45 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:49:59 <jcreigh> > length $ fix (1:)
18:50:06 <lambdabot> Terminated
18:51:07 <SamB_XP> @type \f -> (\x -> f (x x)) (\x -> f (x x))
18:51:09 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
18:51:09 <lambdabot>    Expected type: t
18:51:36 <SamB_XP> kind of ironic that Haskell's Y combinator is illegal in Haskell, isn't it?
18:51:39 <lispy> and the head of the list is equal to how many times the numbers are repeated
18:51:46 <lispy> it's legal
18:51:47 <jcreigh> > take 10 $ show $ fix (1:)
18:51:48 <lambdabot>  "[1,1,1,1,1"
18:52:03 <lispy> just requires you to use some tricks
18:52:06 <lispy> i've seen it defined
18:52:14 <SamB_XP> lispy: than why did the typechecker try to construct the infinite type?
18:52:15 <dolio> "x x" is the problem.
18:52:20 <SamB_XP> oh!
18:52:37 <lispy> SamB_XP: well, that definition isn't valid
18:52:43 <SamB_XP> okay then
18:52:47 <SamB_XP> let me try it again
18:52:55 <dolio> So you need to wrap it somehow.
18:52:56 <lispy> ?google haskell fix mu
18:52:59 <lambdabot> http://paolo.is-a-geek.com/mu/
18:53:32 <lispy> http://www.mail-archive.com/haskell@haskell.org/msg19231.html
18:53:35 <lambdabot> Title: Re: [Haskell] How to define Y combinator in Haskell, http://tinyurl.com/yfpd3n
18:56:23 <SamB_XP> okay.
18:56:27 <SamB_XP> that looks like cheating, somehow.
18:56:33 <psykotic> you can define it in haskell by first defining an appropriate recursive type.
18:56:41 <psykotic> oh, that's what that page does.
18:56:44 <SamB_XP> yeah, so the messages says...
18:56:59 <SamB_XP> I suppose it makes sense that you would need a type combinator...
18:57:08 <psykotic> well, you have to do that. it's well known that system f without recursive types or similar is strongly normalizing, isn't it?
18:57:25 <SamB_XP> probably
18:57:29 <SamB_XP> but I'm not so well read
18:57:34 <psykotic> which implies indirectly that you can't write something like a least fixed point combinator
18:57:59 <SamB_XP> hey, where did that z come from?
18:58:49 <SamB_XP> Curry's is:
18:58:58 <SamB_XP> Y = λf.(λx.f (x x)) (λx.f (x x))
19:00:09 <psykotic> looked at the follow up message
19:00:17 <psykotic> err, look. he seems to say it makes the typing work out :)
19:09:59 <EvilRanter> is there a builtin foo::MonadPlus m => Bool -> m a -> m a; foo p x = if p then x else mzero
19:10:29 <EvilRanter> ?
19:11:46 <EvilRanter> @type when
19:11:47 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
19:12:14 <EvilRanter> is close to what I want, mut it's ->m()->m(), not ->m a->m a
19:12:36 <dons> ?hoogle Bool -> m a -> m a
19:12:37 <lambdabot> Control.Exception.assert :: Bool -> a -> a
19:12:47 <dons> ?hoogle Monadplus m => Bool -> m a -> m a
19:12:48 <lambdabot> Control.Exception.assert :: Bool -> a -> a
19:14:17 <encryptio> noob question: i want to process a string character-by-character. i get "Type error in explicitly typed binding" from hugs when i try: rotString [x:xs] = rotChar x : rotString xs -- rotString has type String -> String
19:14:27 <encryptio> what am i doing wrong?
19:14:45 <EvilRanter>  rotString (x:xs) = rotChar x : rotString xs
19:14:50 <EvilRanter> [x:xs] :: [[a]]
19:14:54 <EvilRanter> (x:xs) :: [a]
19:15:39 <EvilRanter> x:xs is already a list. you only need to [] a list if it's not already one
19:15:57 <dcoutts> encryptio, you use ordinary round brackets for patterns like (x:xs)
19:15:58 <encryptio> ah, kay. thanks.
19:16:22 <Cale> [x:xs] means the list with one element which is the list starting with x and whose tail is xs
19:16:52 <encryptio> i understand now. =D
19:17:08 <dcoutts> encryptio, the confusing thing at first is that while literal lists are written with [1,2,3,4] etc, the pattern for constructing and deconstructing them is just the (:) operator
19:17:19 <dcoutts> [1,2,3] = 1 : 2 : 3 : []
19:17:28 <dcoutts> [1,2,3] = 1 : (2 : (3 : []))
19:17:52 <hyrax42> ?djinn MonadPlus m => Bool -> m a -> m a
19:17:52 <lambdabot> Cannot parse command
19:18:25 <hyrax42> ?help djinn
19:18:26 <lambdabot> djinn <type>.
19:18:26 <lambdabot> Generates Haskell code from a type.
19:18:26 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
19:19:50 <hyrax42> ?djinn Bool -> Maybe a -> Maybe a
19:19:51 <lambdabot> f a b =
19:19:51 <lambdabot>   case a of
19:19:51 <lambdabot>   False -> b
19:19:51 <lambdabot>   True -> Nothing
19:19:52 <dons> interesting, http://www.haskell.org/haskellwiki/Enterprise_Haskell
19:19:56 <lambdabot> Title: Enterprise Haskell - HaskellWiki, http://tinyurl.com/yzttap
19:20:25 <hyrax42> EvilRanter: the opposite of what you want ;)
19:21:52 <EvilRanter> hyrax42, that's basically the code i asked for a standard fn of, just with case instead of if (and backwards). I guess i'll just stick with what I've got
19:22:07 * EvilRanter (basically wants an if with no else...)
19:22:23 <hyrax42> yeah I know.. I just wanted to see if djinn could come up with it
19:22:54 <hyrax42> it is sort of weird that such a function doesn't exist
19:25:13 <hyrax42> dons, is that meant to be a "state of the union" type thing, or a roadmap or just a wishlist?
19:27:42 <dons> hyrax42: not sure. the page seems to have been just created.
19:27:51 <dons> maybe a sketch for questions , and ideas?
19:27:52 <hyrax42> oh, I didn't note that
19:33:51 <lispy> > take 20 . map length . group . fix $ \s -> "\":\":" ++ concat (zipWith (\x y -> x ++ y ++ ":") (filter (/=":") (group s)) (tail (filter (/=":") (group s))))
19:33:53 <lambdabot>  [1,1,1,1,2,1,3,1,5,1,8,1,13,1,21,1,34,1,55,1]
19:34:30 <lispy> it's my fibonacci version of show
19:34:32 <dons> dcoutts: did you see we're the first talk up at PADL, after the invited talk?
19:34:35 <dons> http://www.informatik.uni-kiel.de/~mh/padl07/program.html
19:34:39 <lambdabot> Title: PADL'07: Conference Program, http://tinyurl.com/yal8dr
19:34:44 <lispy> > take 100 . fix $ \s -> "\":\":" ++ concat (zipWith (\x y -> x ++ y ++ ":") (filter (/=":") (group s)) (tail (filter (/=":") (group s))))
19:34:46 <lambdabot>  "\":\":\"\":\"\"\":\"\"\"\"\":\"\"\"\"\"\"\"\":\"\"\"\"\"\"\"\"\"\"\"\"\":\"...
19:34:48 <dons> (which is jhughes talking about QuickCheck )
19:34:59 <dcoutts> dons, cool, if a little scary :-)
19:35:08 <meddle> have any of you ever come across the term "eigenvariable" (perhaps in the context of theorem-proving)?
19:35:10 <dons> :)
19:35:20 <dons> meddle: yeah
19:35:31 <dons> even in terms of Oleg type classes, iirc
19:35:38 <dons> ?google oleg eigen variable
19:35:40 <lambdabot> http://okmij.org/ftp/ML/eliminating-array-bound-check-literally.ml
19:35:42 <dons> heh
19:35:58 <meddle> loaf; i'm looking at a paper that references that code right now :D
19:36:10 <dons> ?google haskell oleg eigen variable
19:36:12 <lambdabot> http://okmij.org/ftp/ML/eliminating-array-bound-check-literally.ml
19:36:15 <dons> boo
19:36:29 <pzpz> what are the best methods for managing struct-like objects with variable bit lengths? (something like a packet header)
19:36:38 <dcoutts> dons, so we can mention in our talk that we made extensive use of QuickCheck :-)
19:36:45 <dons> yes, just thinking that
19:36:55 <lispy> pzpz: lists are good at varying in size
19:37:03 <dons> pzpz: do you have a C struct defining this packet type?
19:37:17 <dons> (and yeah, lists are good. Integer makes a good unbounded bit vector too)
19:37:29 <pzpz> dons: i could write one easily enough. could i just link against a c struct and use it somehow?
19:37:35 <dons> yeah
19:37:44 <dons> using c2hs you could generating a binding to the struct
19:37:48 <lispy> pzpz: you'll want to look at hsc2hs probably
19:37:51 <dons> and keep it in C land, if you wish
19:37:53 <lispy> ahyeah that too
19:37:54 <dons> yeah, or hsc2hs
19:38:21 <pzpz> well, i feel like writing a haskell bot for battle.net.
19:38:29 <lispy> i think i was trying to build c2hs on windows and having a hell of a time
19:39:07 <lispy> pzpz: people write bots for battle.net?  do the bots play the games?
19:39:47 <pzpz> some do. i'm just going to write a chatbot / haskell evaulator :)
19:39:57 <pzpz> well, at least begin writin gone.
19:40:26 <hyrax42> lol
19:40:30 <hyrax42> haskell evaluator on bnet
19:40:31 <lispy> i have diablo2 but i don't know that i've ever used battle.net
19:40:46 <pzpz> lispy: developing transparent bots is actually a profitable business, especially for WoW
19:41:01 <lispy> pzpz: really?!
19:41:03 <pzpz> since there's such an amazing amount of addicted pepole
19:41:04 <hyrax42> bnet doesn't use tcp/udp?
19:41:27 <lispy> pzpz: the goal is to have the bot play the game for you?
19:41:41 <lispy> to earn and then you sell the equipment/items on ebay? ;)
19:41:45 <pzpz> lispy: of course, so you don't have to waste 400 hours doing mundane tasks
19:42:09 <pzpz> lispy: it's actually a fairly large chinese industry :)
19:42:20 <hyrax42> isn't it all mundane tasks?
19:42:26 <hyrax42> just highly addictive mundane tasks
19:42:29 <pzpz> pretty much.
19:42:38 * hyrax42 avoids those games
19:42:42 <hyrax42> I know they'd be bad for me
19:42:50 <hyrax42> also
19:42:57 <pzpz> and according to some, a true hacker would see a mundane task as aproblem :)
19:42:58 <hyrax42> I am perfectly good wasting my own time
19:43:07 <hyrax42> I do *not* need to pay someone $15/mo. to waste it for me
19:43:38 <hyrax42> pzpz: good point
19:44:05 <pwned> scripting mundane tasks can also be a mundane task.
19:44:20 <jcreigh> I'm fairly sure that developing a bot violates that TOS for most MMORPGs...
19:44:46 <hyrax42> simply the act of developing one?
19:44:49 <hyrax42> or of using it?
19:45:13 <jcreigh> well, using it. But how would you develop one without testing on the live network?
19:45:50 <dons> ?where Missingh
19:45:51 <lambdabot> http://quux.org/devel/missingh
19:47:49 <pzpz> developing anything these days almost breaks some tos/eula
19:47:58 <pzpz> i think it's against fair use to open your xbox
19:48:09 <jcreigh> heh. point.
19:50:22 <Smokey`> lispy: decent, undetectable bots... can seriously sell for thousands :)
19:50:27 <Smokey`> (for WoW that is)
19:51:21 <Smokey`> but yeah as pzpz said, it'll be breaking the eula & ToS...
19:51:41 <EvilRanter> who reads those things anyway
19:51:44 <pzpz> i honestly think writing your own bot should be pro-eula :)
19:52:53 <edwardk> dons: just fyi, went through and built lambdabot, finally got it working right, but it seems to rely on running in the same directory as all of the scripts, but installs those scripts in /usr/local/bin by default, so unless you override the binary path or chdir to where the binaries are all the . relative paths are wrong.
19:52:58 <monochrom> Ah, how to develop without testing or using, good question.
19:53:16 <monochrom> Perhaps all those formal methods have real applications after all. :)
19:53:45 <dons> edwardk: right. it does need to be run inplace, for now
19:53:52 * monochrom writes Refinement Calculus For Game Botting
19:54:00 <dons> hence the readme says configure --bindir=`pwd`
19:54:09 <dons> note that you can write a wrapper that does:
19:54:19 <dons> cd $LAMBDABOT_HOME
19:54:21 <edwardk> does that work? isn't there a dir there named lambdabot?
19:54:22 <dons> ./lambdabot
19:54:37 <edwardk> ah nevermind
19:54:42 <edwardk> artifact of my install process =)
19:54:44 <edwardk> hah
19:54:48 <dons> follow the readme ;)
19:54:51 <edwardk> =P
19:55:03 <dons> it's a wart, i agree.
19:55:12 <dons> an hysterical artifact of how lambdabot was built
19:55:34 <edwardk> heh, well, i mangled things pretty badly to get it to run under 6.6 before i realized half of the stuff wasn't functional, then unmangled it to get it to run in 6.4.2 ;)
19:55:59 <edwardk> any idea when we'll have a working 6.6 hsplugins?
19:56:02 <dons> there are .cabal files for both 6.6 and 6.4.x though...
19:56:05 <dons> soon!
19:56:19 <dons> edwardk is #16 to ask
19:56:23 <edwardk> heh
19:56:32 <dons> cool, 16 users!
19:56:51 <edwardk> or at least sixteen close enough to the bleeding edge to be affected =)
19:57:04 <edwardk> and annoying enough to follow up =)
19:57:14 <dons> yeah
19:57:38 <edwardk> the other problem i ran into was the ShowQ and ShowFun stuff, i had to use ghc to compile those in place before runplugs saw them
19:57:50 <edwardk> was quite strange
19:57:56 <pzpz> dons, Foreign.Marshall would work, wouldn't it?
19:58:08 * dons loads up a webpage in w3m, which prints the msg:
19:58:10 <dons> We see you're using Internet Explorer, which is not compatible with this site.  We strongly suggest
19:58:13 <dons> downloading Firefox.
19:58:32 <dons> now, a pro-firefox site is good, but assuming everything else is IE is almost as bad as IE only
19:58:35 <pzpz> dons: heh :)
19:58:47 <dons> pzpz: yeah
19:58:53 <Smokey`> dons: heh, all the sites I've done reject IE. :) (but i'm a bit of an elitist)
19:59:04 <dons> heh
19:59:07 <dons> but I'm using w3m!
19:59:17 <dons> and no magic cookie spoofing
19:59:23 <edwardk> dons: and i seemed to have to jump through some hoops to get the current haskell-src to work. did they recently remove a bunch of things like as_name, pling_name, etc?
19:59:26 <pzpz> w3m is pretty much as elitist as you can get :)
19:59:30 <Smokey`> dons: hmm, does w3m let you change your browser id? (maybe it's pretending to be IE...)
19:59:31 <edwardk> it affected the lambdabot setup
20:00:05 <dons> Smokey`: doubt it. and it helpfully offers a javascript button to click on to 'continue without firefox'...
20:00:10 <dons> hmm... no javascript in w3m :/
20:00:14 <dons> boo boo
20:00:24 <Smokey`> no JS... how do you browser most sites without JS...
20:01:28 <pzpz> i'm pretty sure javascript isn't part of the w3m standard
20:01:31 <edwardk> i wonder how bad it would be to actually wire up spidermonkey to something like w3m
20:01:51 <edwardk> would probably require keeping around a lot more of the DOM than they presently do
20:02:08 <Smokey`> pzpz: hmm, I don't think it is... (though the w3m site does have specs on the DOM)
20:02:30 <dons> almost all sites work without javascript
20:02:34 <dons> you know .. this thing called html?
20:02:51 * dmead <3's ice cream cake
20:02:55 <dons> mostly just means i don't see stupid pop ups and so on
20:03:09 <edwardk> html is vastly overrated =)
20:03:17 <Smokey`> dons: agreed most sites 'should' be using XHTML/CSS2.0, but alot dont :P  Infact more often then not they use javascript when they could get the same result, with better performance (on most browsers), and half the work using CSS instead of JS
20:03:17 <jcreigh> dons: usability is so web 1.0
20:03:19 <dons> and makes wiki editing a breeze, as i've written about elsewhere
20:03:30 <dons> jcreigh: heh!
20:03:41 <dons> ?remember jcreigh usability is so web 1.0
20:04:17 <edwardk> jcreigh: heh, the backbutton was overrated anyways =)
20:06:38 <chessguy> @quote jcreigh
20:06:39 <lambdabot>  usability is so web 1.0
20:06:42 <chessguy> @quote jcreigh
20:06:43 <lambdabot>  usability is so web 1.0
20:13:11 <dons> good to see more bloggers getting started in haskell, http://therning.org/magnus/archives/219
20:13:13 <lambdabot> Title: therning.org/ magnus » Getting real with Haskell
20:13:19 <dons> i wish *everyone* in here blogged their code ... :)
20:13:32 <dons> dcoutts, edwardk, chessguy!
20:13:40 <dcoutts> heh
20:13:55 <dcoutts> making releases isn't enough ?
20:14:10 <dons> as long as you blog the release
20:14:15 <dcoutts> I should write more on the gtk2hs dev blog
20:14:28 <dons> i actually put up a response to the above here, just for fun, http://cgi.cse.unsw.edu.au/~dons/blog/2006/11/12#parsedate
20:14:31 <lambdabot> Title: Haskell, hacking and other stuff, http://tinyurl.com/yx4hn3
20:14:31 <ralf`> dons: Don't forget me. I should blog my code too.
20:14:41 <dons> ralf`: you too!
20:22:40 <monochrom> May I use emoticons such as :> for name of type class (multiple parameter) e.g., class :> a b where f::a->b
20:23:24 <dons> yeah
20:23:42 <monochrom> krad!
20:23:48 <dons> http://programming.reddit.com/info/qjgr/details
20:23:51 <lambdabot> Title: Automated testing of industrial Erlang with QuickCheck (reddit.com), http://tinyurl.com/ya7qjh
20:23:53 <monochrom> I mean :>
20:23:56 * dons finds monochrom a ref...
20:24:33 <monochrom> OK I can do now "class parent :> child where up::child->parent"  :> :> :>
20:24:55 <dons> here ttp://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#infix-tycons
20:25:02 <dons> s/^h/
20:25:17 <monochrom> Thanks.
20:26:50 <chessguy> good thing this is #haskell and not #perl
20:27:28 <dons> to the .se guys, how does one pronounce "Quviq" ? "Qwvick" ?
20:27:50 * dons trys on a chalmers accent
20:28:24 <dons> not as much fun as the utrecht "parsher combinatorsh" accent, though.
20:28:47 <dons> chessguy: "#haskell and not #perl" ?
20:29:20 <monochrom> sob, it allows me ""class parent :> child" but not "instance P :> C"
20:29:35 <chessguy> i don't think that was a valid s///
20:29:40 <dons> :)
20:29:48 <dons> s/^/h/
20:30:17 <chessguy> don't mind my analness
20:30:28 * lispy doesn't mind
20:31:05 <lispy> monochrom: what are you working on?
20:31:22 <monochrom> OOP
20:31:33 * chessguy barfs
20:31:39 <chessguy> c'mon man, i just ate
20:33:13 <lispy> haskell uses OOP
20:33:18 <lispy> or at least some ideas
20:33:33 <lispy> like polymorphism is very common in haskell
20:33:57 <ralf`> freakin' dependancies.
20:34:07 <chessguy> polymorphism doesn't belong to OOP
20:34:15 <chessguy> it's a math idea
20:34:28 <ralf`> I pasted the code about time from the blog above, but my hugs doesn't understand the dependancies.
20:34:36 <chessguy> 2 + 2 uses the same mathematical ideas as 3.0+3.0
20:35:10 <monochrom> (:>)
20:35:38 <dons> hmm, i think this is worth a couple of up mods at least, damn this reddit "mod down of death", http://programming.reddit.com/info/qjgr/details
20:35:41 <lambdabot> Title: Automated testing of industrial Erlang with QuickCheck (reddit.com), http://tinyurl.com/ya7qjh
20:35:44 <lispy> chessguy: type classes are essentially interfaces
20:36:45 <chessguy> but interfaces aren't really essential to OOP either. e.g., c++ doesn't (explicitly) have them
20:37:53 <lispy> okay so polymorphism and interfaces have nothing to do with OOP...gotcha
20:37:57 <psykotic> a language level concept called an "interface" isn't essential but the notion of an interface as a type is.
20:38:10 <chessguy> that's not what i said
20:40:08 <psykotic> a purely abstract class in c++ serves the same purpose as a java interface, i.e. it describes a type.
20:40:49 <chessguy> that's why i put the word explicitly in there
20:40:54 <spiffy> hello all.
20:41:09 <ralf`> what is MissingH.Time.ParseDate?
20:41:20 <ralf`> It is in that blog post, but ghc doesn't know how to find it..
20:41:39 <chessguy> @hoogle ParseDate
20:41:40 <lambdabot> No matches found
20:41:40 <psykotic> (btw what is it with oop programmers and their inability to distinguish between class and type?)
20:42:15 <monochrom> Please don't use C++ to illustrate OOP.
20:42:27 <chessguy> ?
20:42:50 <psykotic> monochrom, i'm reminded me of that alan kay quote. "i invented the term 'object-oriented' and i can tell you c++ wasn't what i had in mind"
20:42:57 <monochrom> I accept OCaml and Smalltalk as examples of OOPL.
20:43:07 <spiffy> clos?
20:43:22 <chessguy> ?remember psykotic monochrom, i'm reminded me of that alan kay quote. "i invented the term 'object-oriented' and i can tell you c++ wasn't what i had in mind"
20:43:24 <dons> ralf`: its in missingh
20:43:28 <dons> ?where missingh
20:43:29 <lambdabot> http://quux.org/devel/missingh
20:43:37 <monochrom> I am ignorant of CLOS, but yeah it works too.
20:43:45 <psykotic> monochrom, but not java say?
20:43:54 <monochrom> Java is borderline.
20:44:06 <dylan> CLOS reminds me of run-time type classes...
20:44:10 <ralf`> dons: so then, do I have to download it from there?
20:45:04 <spiffy> CLOS is what detached types from encapsalation of methods.
20:45:08 <spiffy> for me
20:45:40 <psykotic> another nice thing about CLOS style OO is that you can use the module system to deal with issues like name hiding/control
20:46:01 <lispy> the package system
20:46:06 <psykotic> in that sense there's a more gradual progression more polymorphism a la ML-style modules to full-on OO
20:46:19 <psykotic> *from polymorphism
20:46:50 <lispy> method combination is CLOS is mighty fine
20:46:51 <psykotic> lispy, i was speaking generally, i know in cl it's called the package system.
20:47:02 <lispy> psykotic: ah, okay :)
20:47:32 <ralf`>  /nick ladyCode
20:47:45 <lispy> i've used method combination to great success when debugging large lisp applications
20:48:23 <psykotic> how easy is it to write your own method combinators in CL?
20:48:51 <lispy> i've never tried, i just used the built in ones
20:49:11 <psykotic> is it easy to e.g. sum the result of all applicable methods?
20:49:28 <psykotic> i've mostly seen before/after stuff
20:49:45 <lispy> yeah, i've seen before,  after, and around
20:49:50 <dons> ralf`: yep.
20:50:03 <lispy> but, afaik, you can define arbitrary stuff
20:50:25 <lispy> iirc, practical common lisp has a chapter on it
20:50:40 <spiffy> lispy: very much so. i had some neat ones for a webapp
20:50:42 <lispy> if you do much lisp programming i highly recommend it
20:51:40 <spiffy> so im in a fresh ubuntu install
20:51:52 <spiffy> ive installed ghc and haskell-mode (and emacs)
20:52:03 <spiffy> how do i bring up an repl loop in eamcs for ghc?
20:52:29 <dmead> repl loop?
20:52:30 <monochrom> open a *.hs file.  C-c C-z
20:52:39 <lispy> dmead: read-eval-print
20:52:44 <monochrom> repl loop = ghci
20:52:45 <dmead> meta-x turn-on-haskell-hugs
20:52:48 <lispy> but repl loop is redundant
20:52:50 <dmead> ah
20:52:58 <lispy> should just be repl
20:53:00 <spiffy> sorry sorry
20:53:01 <dmead> ghci is rly slow compared to hugs
20:53:03 <monochrom> but do you have hugs?
20:53:10 <spiffy> i can get it easily enough
20:53:17 <dmead> go for it
20:53:23 <monochrom> OK as long as you're happy.
20:53:41 <lispy> i tend to use ghci in a different terminal
20:53:43 <monochrom> Who says Automatic ABM Banking Machine is redundant?
20:54:11 <lispy> and pin number
20:54:13 <spiffy> isnt it atm?
20:54:23 <spiffy> automated teller machine?
20:54:26 <jcreigh> IMO, in my opinion, it's redundant.
20:54:35 <monochrom> It's T or B depending on continent.  Automatic ATM Teller Machine.
20:54:38 <psykotic> monochrom, at least ABM Banking Machine would be recursive!
20:54:48 <Adamant> at least it's not A2M
20:54:52 <dmead> =p
20:54:55 <dmead> reboot time
20:55:16 <spiffy> hmmm
20:55:25 <spiffy> seems that emacs has b0rked itself
20:55:26 <spiffy> awsome
20:55:39 <monochrom> Tell me next time you hear "DVD disc".
20:57:00 <spiffy> hmmm whats the most likely cause for all characters in the emacs text editing area to show up as little boxes?
20:57:20 <psykotic> you actually do hear that when people want to emphasize the physical disc rather the contents of the DVD or the box-with-disc :)
20:57:33 <monochrom> non-text file
20:58:02 <monochrom> or alien text file
20:58:08 <spiffy> monochrom: on loading emacs?
20:58:13 <spiffy> no file etc
20:58:19 <spiffy> even the miniduffer etc
20:58:24 <monochrom> Wonderful.
20:58:32 <spiffy> i can however copy and paste text out of it fine
20:58:36 <lispy> heh, miniduffer, nice typo :)
20:58:53 * lispy thinks he'll start calling it hat
20:59:27 <monochrom> When you installed ubuntu and selected your language and locale etc.,
20:59:34 <monochrom> did you select "Mars"? XD
20:59:34 <spiffy> us-english
20:59:50 <spiffy> laugh na, i didnt even select canada english to keep it simple
21:00:02 <monochrom> OK I cannot even imagine it can happen.
21:00:06 <lispy> they have a canadian english?
21:00:13 <spiffy> some distros do
21:00:18 <spiffy> didnt actually bother checking
21:00:32 <lispy> do you know how it is different than american or international english?
21:00:40 <lispy> (i'm not sure i have the right name for the latter one)
21:00:41 <Thomas2> no retarded americanisations?
21:00:43 <spiffy> some word endings generally
21:00:51 <spiffy> colour instead of color
21:00:56 <spiffy> but its not british either
21:00:59 <monochrom> little boxes mean emacs doesn't know what characters or encoding they are, or missing font.
21:01:04 <PipeDream> 'aboot'
21:01:27 <monochrom> But us-english should never cause that.
21:01:28 <spiffy> hmmm whats a pretty safe font i try passing as an arguement to emacs?
21:02:32 <Thomas2> xfontsel
21:03:13 <monochrom> try courier
21:03:29 <spiffy> No fonts match `courier'
21:04:02 <dons> hmm, there should be something nicer for this:
21:04:02 <dons>     binaryOp f (a:b:stack) = f b a : stack
21:04:05 <dons> any ideas?
21:04:11 <monochrom> this is strange. ubuntu should have installed a million fonts.  certainly worked for me.
21:04:11 <Thomas2> sounds like you have an interesting font set up
21:04:16 <Thomas2> do try running xfontsel
21:04:17 <dons> or, more simpler:
21:04:17 <dons>     unaryOp  f (a:stack)   = f a : stack
21:04:42 <Thomas2> dons: more simpler?
21:04:55 <dons> its a funny fold
21:05:12 <dons> (everything's a funny fold, though)
21:05:23 <PipeDream> isnt' that what apply does?
21:05:29 <Thomas2> isn't that map?
21:05:40 <dons> its only applying f to the first element
21:05:51 <ladyCode> so i was defribulating th OOgh polydiotic when the trifibule TT # decoded my agrowork
21:05:51 <ladyCode> any suggestions?  ubuntu install is best when fresh, in my humble opinion
21:05:52 <Thomas2> oh, right, heh.
21:05:57 <ladyCode> you all need to read up on the RYO configuation.  It makes your head spin.   #th#
21:06:03 <dino-> Hm. You want to treat the first two of the list as args and flip them.
21:06:12 <dons> dino-: hmm. yes.
21:06:19 <dons> almost a curry/uncurry
21:06:24 <dons> ?type curry
21:06:25 <lambdabot> forall c b a. ((a, b) -> c) -> a -> b -> c
21:06:26 <dons> ?type uncurry
21:06:27 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
21:06:41 <dino-> If you can get that stack into a list of pairs.
21:06:45 * lispy wonders if ladyCode is a bot
21:07:01 <dons> hmm
21:07:22 <dons> oh, i recognise that ip...
21:07:33 <PipeDream> Huh, haskell doesn't have an apply like lisp
21:07:46 <dons> ($) ?
21:07:46 <lispy> PipeDream: try ($)
21:07:48 <Botty> dons - stick 'that ip' and others in the bot
21:08:16 <PipeDream> ($) ?
21:08:51 <lispy> > zipWith ($) [(+1), (+2), (+3)] [1..3]
21:08:53 <lambdabot>  [2,4,6]
21:09:57 <dons> ah , no i don't recognise the ip. (thought it was gschuett)
21:10:15 <dons> but is it ralf`'s bot?
21:10:38 <lispy> has the same ip as ralf`
21:11:02 <jcreigh> dons: hey, cool, that does work. For some reason I hadn't thought making the stack an argument of the *Op functions and letting Haskell curry it for me.
21:11:02 <lispy> 20:47 <ralf`>  /nick ladyCode
21:11:16 <dons> ralf`: yeah?
21:11:31 <dons> ralf``: you playing with a megamonad bot?
21:11:43 <dons> jcreigh: oh, what did you do?
21:11:50 <dons> (i'm rewriting your code for fun, atm :)
21:12:01 <jcreigh> I had "unaryOp f = (\ (a:stack) -> f a : stack)"
21:12:05 <dons> yes
21:12:08 <dons> and you've now got?
21:12:44 <jcreigh> what you pasted: unaryOp f (a:stack) = f a : stack
21:12:51 <spiffy> ok, using mule ive got a useable font. How do i save it?
21:13:01 <dons> jcreigh: oh. yes.
21:13:15 <dons> but i think we can avoid the pattern match altogether if we're tricksy
21:13:23 <dons> well, there's always:  unaryOp = (`ap` tail) . (. head) . ((:) .)
21:13:24 <dons> :)
21:13:56 <PipeDream> haha.  can you walk through that one?
21:14:28 <dons> ?pl unaryOp f (a:stack) = f a : stack -- not really ;)
21:14:29 <lambdabot> unaryOp = (`ap` tail) . (. head) . ((:) .)
21:14:37 <lispy> ?pl unaryOp f = (\(a:stack) -> f a : stack)
21:14:37 <lambdabot> unaryOp = (`ap` tail) . (. head) . ((:) .)
21:14:37 <spiffy> ah got it
21:14:39 <spiffy> excellent
21:14:43 * lispy is too slow :)
21:14:57 <PipeDream> Pfff
21:16:26 <SamB_XP> hmm... apparantly "fix f" is a shortcut for "last (iterate f undefined)"...
21:16:46 <jcreigh> SamB_XP: ah, I was wondering if that might be the case.
21:17:01 <SamB_XP> I'm being slightly facetious ;-)
21:17:08 <edwardk> heh
21:17:12 <SamB_XP> obviously, it isn't *quite* that
21:17:19 <SamB_XP> because iterate returns an infinite list...
21:17:26 <jcreigh> SamB_XP: no, I mean, is it like f(f(f(f(f(_|_)))))
21:17:32 <SamB_XP> yes ;-)
21:17:34 <jcreigh> ...if you know what I mean
21:17:43 <SamB_XP> but. you can't implement that quite that way ;-)
21:18:07 <dons> ?pl eval = flip (foldl (flip ($)))
21:18:09 <lambdabot> eval = flip (foldl (flip id))
21:18:12 <dons> heh
21:18:24 <SamB_XP> hmm, is definedness a lattice or just a plain-old partial order?
21:18:49 <Thomas2> eh?
21:18:55 <Pupeno> What is the past tense of "talk" ?
21:19:07 <SamB_XP> "talked"?
21:19:09 <dons> spoke?
21:19:15 <Thomas2> said?
21:19:18 <Thomas2> different words
21:19:24 <SamB_XP> Thomas2: no, that isn't it
21:19:29 <Thomas2> yeah, I know.
21:19:31 <dons> we talk now, we spoke then.
21:19:39 <SamB_XP> you speak *with* people. you *say* things.
21:19:42 <dons> he's talking now, he said that then.
21:20:17 <PipeDream> said that ?
21:20:21 <dcoutts> dons, your wish is my command, more details on what I've been hacking on
21:20:28 <SamB_XP> @all-dict talked
21:20:29 <lambdabot> *** "talked" gcide "The Collaborative International Dictionary of English v.0.48"
21:20:30 <lambdabot> talk \talk\ (t[add]k), v. i. [imp. & p. p. {talked} (t[add]kt);
21:20:30 <lambdabot>   p. pr. & vb. n. {talking}.] [Cf. LG. talk talk, gabble, Prov.
21:20:30 <lambdabot>   G. talken to speak indistinctly; or OD. tolken to interpret,
21:20:30 <lambdabot>   MHG. tolkan to interpret, to tell, to speak indistinctly,
21:20:30 <dons> great!
21:20:31 <lambdabot> [33 @more lines]
21:21:20 <dcoutts> dons, actually it's the background to what I'm hacking on now, part 1 if you will. I dind't get round to writing about the current work as I'd written enough for the moment. :-)
21:21:57 <jcreigh> > (iterate (\x -> 1 + (1 / x)) 1.0) !! 100
21:21:59 <lambdabot>  1.618033988749895
21:22:36 <dons> jcreigh: http://cgi.cse.unsw.edu.au/~dons/blog/2006/11/12#rpn-reloaded
21:22:41 <lambdabot> Title: Haskell, hacking and other stuff, http://tinyurl.com/yx4hn3
21:22:47 <dons> hmm. I should really submit my 'forever' patch to the libraries process
21:23:29 <PipeDream> Golden ratio?
21:23:39 <PipeDream> Golden ratio?
21:23:45 <PipeDream> (oops)
21:24:24 <dcoutts> dons, so perhaps the gtk2hs dev blog should be on planet haskell
21:24:37 <dcoutts> dons, or is that just personal ones?
21:24:44 <dons> no. gtk2hs would be great.
21:24:49 <dons> ping ibid with the rss feed
21:25:13 <jcreigh> PipeDream: yeah. I don't know why exactly, but SICP says the golden ratio is the fixpoint of f(x) = 1 + (1/x), which certainly seems to be the case. :)
21:25:24 <dcoutts> ibid, http://haskell.org/gtk2hs/archives/category/development/feed/
21:25:27 <lambdabot> http://tinyurl.com/y7p2pk
21:25:32 <PipeDream> that's probably the newtons' method for the root
21:26:01 <dcoutts> ibid, or did I tell you this before and you already added it ?
21:27:06 <dcoutts> ibid, ah I think you added the main gtk2hs category so that includes the dev section, so ignore me it's all ok already. :-)
21:27:35 <lispy> right, the golden ratio would be x = 1 + (1/x), so if you viewed that equation as a function of f, then yeah, the golden ratio becomes a fix point of f
21:28:05 <lispy> not a function of f, but a function named f
21:28:06 <dons> dcoutts: yeah, looks like he's got http://haskell.org/gtk2hs/feed/
21:28:14 <dcoutts> yeah
21:28:21 <dcoutts> that covers everything
21:29:11 <lispy> hmm...i think eclipse is broken...why do i keep giving it a second chance?
21:29:58 <dmead> you mean the fp plugin is broken?
21:31:27 <lispy> no, eclipse and i don't see eye to eye
21:31:34 <dmead> oh =p
21:31:36 <lispy> i haven't tried the fp plugin for quite some time
21:31:36 <dmead> whats wrong?
21:31:48 <lispy> why do i have to have a workbench?
21:32:02 <lispy> and installing plugins is a pain
21:32:12 <dmead> did you try the plugin manager?
21:32:14 <lispy> and i currently need plugins for darcs and for scala
21:32:23 <lispy> yeah, that's the pain i'm talking about :)
21:32:26 <dmead> oh
21:32:30 <dons> do we know this guy, http://jpmoresmau.blogspot.com/2006/11/my-first-haskell-adventure-game.html
21:32:31 <dmead> hmm
21:32:33 <lambdabot> Title: JP Moresmau's Programming Blog: My first Haskell adventure game!, http://tinyurl.com/ylbnyn
21:33:08 <dmead> ;o
21:33:29 <dmead> eclipse with anything other than java is usually a pain
21:33:47 <lispy> dmead: one really annoying thing it just did is sitting there for ages waiting for me to answer a question...but i couldn't tell it was asking me anything because the window with the question appeared behind the eclipse window
21:34:02 <dmead> lispy: yea i've seen that before
21:34:03 <lispy> well, scala is basically java with a different syntax an a type system
21:34:17 <dmead> you gotta press the little icon in the corner
21:34:23 <dmead> to bring up the dialogs
21:34:31 <lispy> ah
21:34:34 <dmead> it's really not obvious
21:34:38 <dmead> it's in the bottom left
21:34:42 <dmead> *right
21:34:50 <dmead> yea, bottom right
21:35:14 <dmead> yea the workbenches are there to make your environment portable
21:35:55 <lispy> i wish it was more like emacs though, and let you open whatever, where ever
21:35:57 <jcreigh> ?type io
21:35:59 <lambdabot> Not in scope: `io'
21:36:02 <jcreigh> hmm...
21:36:11 <dmead> ?type IO
21:36:14 <lambdabot> Not in scope: data constructor `IO'
21:36:23 <jcreigh> oh, nm, dons has "io = lifeIO"
21:36:31 <lispy> ?type liftIO
21:36:33 <lambdabot> forall (m :: * -> *) a. (MonadIO m) => IO a -> m a
21:36:43 <PipeDream> D'oh, the newton's method works out to (iterate (\x -> (x/2)+(1/4)+(5/4)*(1/(2*x-1))) 1.0)
21:36:58 <dmead> lispy: yea, it's a similar structure to emacs and elisp... but it's kinda hard to run java interactively
21:37:37 <lispy> dmead: i think we're talking about different things
21:37:49 <lispy> dmead: i'm whining that i have to put all my source code in the same place
21:37:56 <dmead> lispy: oh
21:37:59 <lispy> dmead: but i want to be able to open any file on my hard drive
21:38:04 <dmead> ahh
21:40:45 <lispy> dmead: i need eclipse to ignore _darcs how do you do thta?
21:41:00 <lispy> dmead: i have the darcs plugin so i thought that would do it, but eclipse doesn't seem to be that smart
21:41:23 <lispy> oh, n/m
21:41:38 <lispy> i had to go to Team -> Share -> Darcs -> Connect to existing repository
21:41:48 <dons> anyone contribute to this: http://programming.reddit.com/info/qjkz/comments
21:41:54 <lambdabot> Title: Haskellers, are you coding for money ? if so, what ? for whom ? (reddit.com), http://tinyurl.com/ycelxw
21:41:55 <dons> lispy? edwardk? anyone else?
21:42:09 <dmead> ahh
21:42:10 <dmead> coo
21:45:34 <edwardk> back
21:45:46 <edwardk> well, not doing haskell for cash anyways =)
21:47:09 <dons> psykotic: :) http://programming.reddit.com/info/qgml/comments (quoted)
21:47:13 <lambdabot> Title: Monads, Kleisli Arrows, Comonads and other Rambling Thoughts (reddit.com), http://tinyurl.com/yyl8hw
21:49:01 <dons> thanks lispy
21:49:52 <lispy> np :)
21:49:56 <lispy> you noticed fast
21:50:38 <dons> c.f. god-like search powers mentioned earlier today.  ;)
21:51:01 <dmead> a google of one
21:52:35 <lispy> i forget, does yhc run on .NET?
21:52:45 <lispy> and can it interoperate with existing .NET code?
21:53:07 <dons> it might. i've heard rumours
21:54:06 <lispy> http://www.mail-archive.com/yhc@haskell.org/msg00055.html
21:54:09 <lambdabot> Title: Re: [Yhc] YHC.NET, http://tinyurl.com/yhemag
21:56:46 <dons> hey pkhuong
21:57:47 <lispy> whoa
21:57:47 <lispy> http://galois.com/~sof/hugs98.net/
21:57:49 <lambdabot> Title: Hugs98 for .NET
21:58:06 <pkhuong> hey dons.
21:59:43 <lispy> why is it that no one has really made progress on Haskell/.NET in the last three years?
22:00:13 <dons> no one cares enough? open source fascists ;)
22:00:16 <lispy> it's like in 2003 several people were excited and then they all stopped
22:00:47 <dons> same reason windows versions of *.hs lag behind linux, I suspect.
22:01:24 <lispy> who am i kidding...even if Haskell interoperated flawlessly with .NET i wouldn't get to use it on important projects...i had to fight for about a week just to be able to use VB.NET instead of VBA
22:01:54 <dmead> open source fascists?
22:01:59 <dmead> zeig hail!
22:02:22 <dons> :)
22:03:21 * dmead is installing beryl
22:06:31 <jcreigh> hmm...is "flip id" always the same as "flip ($)"? seems like that should be the case.
22:06:41 <dons> ?type id
22:06:42 <lambdabot> forall a. a -> a
22:06:44 <dons> ?type ($)
22:06:46 <lambdabot> forall b a. (a -> b) -> a -> b
22:06:55 <jcreigh> @type flip id
22:06:57 <dons> > (*2) `id` 3
22:06:57 <lambdabot> forall b c. b -> (b -> c) -> c
22:06:58 <lambdabot>  6
22:07:02 <jcreigh> @type flip ($)
22:07:03 <lambdabot> forall b b1. b1 -> (b1 -> b) -> b
22:07:03 <dons> > (*2) $ 3
22:07:05 <lambdabot>  6
22:07:14 <dons> using id is obfuscating though :)
22:08:51 <dons> interesting blog title, http://monad.carnalreason.org/wordpress/
22:08:53 <lambdabot> Title: A kick in the monads
22:10:02 <lispy> you can define ($) as ($) = id
22:10:22 <lispy> right?
22:10:32 <lispy> ?type id
22:10:34 <lambdabot> forall a. a -> a
22:10:40 <dons> ?let (#) = id
22:10:41 <lambdabot> Defined.
22:10:49 <dons> > (*2) (L.#) 3
22:10:50 <lambdabot>  add an instance declaration for (Num (a -> a))
22:10:56 <dons> > (*2) L.(#) 3
22:10:57 <lambdabot>  Not in scope: `#'
22:10:59 <dons> grr
22:11:15 <dons> > L.(#) (*2) 3
22:11:16 <lambdabot>  Not in scope: `#'
22:11:21 <dons> > (L.#) (*2) 3
22:11:22 <lambdabot>  6
22:11:35 <dons> > (*2) L.# 3
22:11:36 <lambdabot>  6
22:11:40 <dons> yeah
22:12:12 <lispy> > let (#) :: forall b a. (a -> b) -> a -> b; (#) = id in (*2) # 3
22:12:13 <lambdabot>  Parse error
22:12:22 <lispy> > let {(#) :: forall b a. (a -> b) -> a -> b; (#) = id} in (*2) # 3
22:12:23 <lambdabot>  Parse error
22:12:37 <lispy> > let {(#) :: (a -> b) -> a -> b; (#) = id} in (*2) # 3
22:12:38 <dons> now foralls in h98
22:12:39 <lambdabot>  6
22:12:41 <dons> s/no/
22:13:59 <lispy> and the seceret to understanding how it works is that (a -> b) -> a -> b == (a -> b) -> (a -> b)
22:14:19 <lispy> and since type of id is t -> t, you just replace t with (a -> b)
22:15:12 <dons> hey dibblego
22:15:32 <dibblego> hey mate
22:16:05 <dons> dibblego: any comments you can add to http://programming.reddit.com/info/qjkz/comments
22:16:08 <lambdabot> Title: Haskellers, are you coding for money ? if so, what ? for whom ? (reddit.com), http://tinyurl.com/ycelxw
22:16:14 <dons> as a possible commerical user?
22:16:26 <dons> why do I always write "commerical". weird.
22:16:38 <dons> freudian "comical use of haskell" slip?
22:16:46 <dibblego> I do it too - I think it's the keys
22:17:06 <dons> yeah, i keep hitting the 'i' on the rhs before diping down to the 'c'
22:17:21 <jcreigh> so is there a difference in precedence between "f `id` x" and "f $ x"?
22:17:30 <dons> r -> c (same hand, finger). but there's a race on the rhs to hit the 'i'
22:17:56 <dons> leading to comme-ric instead of comme-rci
22:19:12 <lispy> jcreigh: probably
22:19:28 <lispy> jcreigh: `id` should have fixity of 5
22:19:41 <lispy> jcreigh: and ($) will have some other arbitrary fixity
22:20:30 <dons> i.e. 0
22:20:41 <dons> :Prelude> :info ($)
22:20:41 <dons> $ :: (a -> b) -> a -> b         -- Imported from GHC.Base
22:20:41 <dons> infixr 0 $
22:21:38 <dons> > (+) `id` 3 $ (*7) `id` 2 -- so you can mix them safely
22:21:39 <lambdabot>  17
22:22:04 <dons> since the `id` binds first.
22:22:45 * dons thinks it was critical to introduce inline haskell to the channel. exploration/learning was so tedious before
22:23:08 <jcreigh> "Any operator lacking a fixity declaration is assumed to be infixl 9" (http://www.haskell.org/onlinereport/decls.html#sect4.4.2)
22:23:11 <lambdabot> Title: The Haskell 98 Report: Declarations, http://tinyurl.com/yy9y4w
22:24:55 <lispy> jcreigh: oh, sorry
22:25:02 <lispy> jcreigh: i was thinking it was infixl 5
22:28:08 <dibblego> dons, done
22:28:39 * Botty supposes that implementing isFinite for lists would be tantamount to solving the halting problem
22:28:54 <dibblego> Botty, good luck :)
22:28:55 <dons> any lisp hackers comment on this (i'm just speculating): Lisp and Haskell share roughly the same blub space (though laziness, explicit side effects, strong static typing and monads might make some lispers a big blubish? Not sure.)
22:29:11 <Botty> dibblego: yeah, i'm not even going to try
22:29:14 <dons> (from http://programming.reddit.com/info/qhzm/comments)
22:29:16 <lambdabot> Title: Kenzo: non-trivial Common Lisp program which would be very difficult to reimplem ..., http://tinyurl.com/yc59ky
22:29:23 <pkhuong> dons: huh?
22:29:45 <jcreigh> Does anything bind more tightly than function application?
22:30:00 <dons> just pondering whether some of the features of haskell seem difficult to appreciate from the lisp side of the fence.
22:30:07 <jcreigh> > (+) 9 9 `div` 3
22:30:08 <lambdabot>  6
22:30:10 <Botty> i wish : binded tighter that $
22:30:22 <pkhuong> take pg, throw him out of the window and lead a happy life ever after. (I know this is gonna come back to bite me some day, somehow)
22:30:28 <jcreigh> but `div` has infixl 7...
22:30:38 <dons> pkhuong: heh
22:31:13 <dons> (the comment was mine, btw. i'm just thinking aloud/online :)
22:31:15 <pkhuong> dons: Some lispers think static typing gets in the way, but I think they just haven't explored enough.
22:31:45 <dons> yeah, that's been my impression. of course, a lot of lispers do get it
22:32:09 <dons> the control of side effects is probably a bit less recognised? hard to say though.
22:32:21 <dibblego> I have met a couple of people who believe that "monads are a hack to permit I/O" -- they are from the Lisp/Scheme side of the fence
22:32:24 <pkhuong> yeah, CL at least is very flower power.
22:32:26 <dons> and hardly anyone gets laziness-by-default :)
22:32:31 <dons> pkhuong: yeah
22:32:41 <dons> dibblego: right.
22:32:46 <dons> though i suspect that view will slowly change
22:32:50 <dibblego> dons, I think a lot of people get laziness by default - they just don't know it - even the Java people
22:32:55 <dons> heh
22:33:01 <dibblego> look at java.io.InputStream and a byte[] in Java
22:33:18 <pkhuong> so people tend not to care about typing/controlling effects.
22:33:23 <Botty> just tell people its like streams and their fine
22:33:31 <dons> pkhuong: mm. interesting. yes.
22:33:31 <Botty> they're
22:33:41 <dibblego> I distinctly recall the marketing around InputStream and all this wonderful "abstraction" of I/O
22:34:11 <pkhuong> I think monads just happen though, whether you recognize them or not. And re laziness, a lot of lispers have laziness macros.
22:34:38 <dibblego> I showed my Java colleagues readFile :: IO String (or whatever it is) just to watch their jaw drop
22:34:53 <dibblego> then I explained laziness and the metaphor to what they are already doing
22:34:59 <dons> pkhuong: yeah. good point.
22:35:40 <dibblego> pkhuong, yes people reinvent monads, but that's less obvious - one step at a time :)
22:36:35 <dons> i remember reading a java blog recently where a guy was complaing about purity, and pointing out that it is perfectly safe to have local mutable variables, as long as they don't escape the local scope. i.e. he reinvented runState/and the State monad :)
22:36:37 <pkhuong> dons: but with haskell, you get better integration. I really wish we had standard generic sequences. SBCL has them, and someone built generator streams with them.
22:36:52 <lispy> interesting, scala lets you call-by-name on a per formal parameter basis
22:37:13 <Poeir> join #ruby
22:37:19 <pkhuong> no.
22:37:21 <lispy> no thanks
22:37:22 <dibblego> I have just written most of Data.List in Java without using assignment
22:37:50 <dons> welcome Poeir :)
22:37:51 <dibblego> as a weaning tool
22:38:02 <Poeir> Howdy, dons.
22:38:39 <dons> > fix ((0:) . scanl (+) 1) -- have a lazy list, on the host. first taste is free!
22:38:41 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
22:38:44 <dons> s/house/ :)
22:39:09 <merus> hey ,that's cool
22:39:52 <Botty> > take 1 (fix ((0:) . scanl (+) 1)) -- first taste is free ;)
22:39:54 <lambdabot>  [0]
22:39:58 <dons> yeah, the first time I saw it was, 06.07.28:13:58:44 <int-e> > fix ((0:) . scanl (+) 1)
22:40:09 <dons> but maybe its been mentioned before :)
22:40:43 <lispy> here is a more compilcated way of doing it
22:40:44 <lispy> > take 20 . filter (/=1) . map length . group . fix $ \s -> "\":\":" ++ concat (zipWith (\x y -> x ++ y ++ ":") (filter (/=":") (group s)) (tail (filter (/=":") (group s))))
22:40:46 <lambdabot>  [2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17711]
22:40:51 <dons> :)
22:41:00 <dons> just a little bit more complicated ;)
22:41:05 <lispy> missing the first few...but eh
22:41:18 <dons> ah, though I have an earlier ref, 04.09.12:09:39:00 <anduril1> dan2: how does "fibs = 0:(scanl (+) 1 fibs)" compare to the others?
22:41:36 <Poeir> pkhuong: lispy: Those were typos, the / found its way into #nethack.
22:41:46 <pkhuong> Poeir: we kid.
22:41:53 <dons> whoa.
22:42:02 <dons> tmoertel++ (first fibs in #haskell):
22:42:04 <dons> 02.09.05:07:46:55 <tmoertel> much uglier w/o laziness: fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
22:42:13 <Poeir> pkhuong: Yeah, but I thought perhaps I should explain it.  I didn't even realize I'd done it until I tried to figure out what you're making.
22:42:53 <lispy> Poeir: you can't trick me!  i'm still not going to /join #ruby!
22:42:59 <dons> heh
22:43:19 <Poeir> lispy: Anyway...  What are you trying to make intentionally complicated with the take 20 ... ?
22:43:33 <Poeir> Fibonacci sequence?
22:43:38 <lispy> ya
22:43:53 <Poeir> And I take it you're trying to make it complicated just for the sake of making it complicated?
22:43:58 <lispy> > take 30 . map length . group . fix $ show
22:44:00 <lambdabot>  [1,1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,511,1,1023,1,2047,1,4095,1,8191,1,...
22:44:15 <lispy> Poeir: because i wanted that idea ^^^ to get fibs
22:44:20 <lispy> but it has to be a lot more compilacted
22:44:23 <dons> no, he's generating it without using any input numbers.
22:44:30 <lispy> yeah that too
22:44:34 <dons> which is pretty nifty. just taking a fix point
22:45:40 <Poeir> Oh, all right.
22:45:53 <lispy> fwiw, playing with it has taught me a lot about 'fix'
22:46:19 <lispy> > fix show -- understanding this will teach you a lot about fix
22:46:20 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
22:46:48 <EvilRanter> @type fix
22:46:48 <meddle> @type fix
22:46:49 <lambdabot> forall a. (a -> a) -> a
22:46:50 <lambdabot> forall a. (a -> a) -> a
22:46:51 * lispy thinks he could put this as a job interview question ;)
22:46:52 <EvilRanter> heh
22:46:58 <meddle> ;)
22:47:03 <dons> lispy: hah!
22:47:13 <dons> lispy++ evil lispy
22:47:35 <lispy> "The ideal candidate will be able to explain the output of the following haskell program..."
22:47:49 <dons> mmm
22:48:50 <lispy> scala is no haskell, but it appears (I haven't really written much yet, just reading the guides) to be a very good language
22:49:04 <lispy> you can get laziness if you want it
22:49:24 <psykotic> dons: that kenzo program is scary. i'm pretty sure there are only 3-4 people in the world who understand enough algebraic topology AND enough common lisp to grok it :)
22:49:30 <psykotic> (the implementation i mean)
22:50:16 <lispy> psykotic: what does kenzo do?
22:50:31 <dons> psykotic: agreed.
22:50:51 <psykotic> heavy duty algebraic topology
22:51:32 <dons> Cale, want to do a port? :) http://www-fourier.ujf-grenoble.fr/~sergerar/Kenzo/
22:51:39 <lambdabot> Title: The Kenzo program., http://tinyurl.com/yyj24l
22:51:57 <psykotic> you could probably do a port without understanding the algorithms
22:52:13 * psykotic didn't even _know_ there was an effective version of serre's spectral sequence.
22:53:11 * psykotic would be impressed if cale understood iterated loop spaces, let alone effective formulations of them :)
23:07:25 <Smokey`> ugh, ctrl+c not working for ghci (6.6) in windows is relaly annoying me now
23:08:44 <lispy> Smokey`: it's not just 6.6
23:08:53 <lispy> Smokey`: but, there is a work around somewhere
23:08:56 <lispy> a wrapper script
23:10:03 <dons> yeah, the wrapper script is what you need
23:10:36 <dons> rlwrap
23:10:39 <dons> http://haskell.org/haskellwiki/Windows#Special_tips_and_tricks_for_Windows
23:10:42 <lambdabot> Title: Windows - HaskellWiki, http://tinyurl.com/y6smcb
23:22:55 <Smokey`> hmm, random pointless excersize, but i think i've managed to recreate the output of "fix show" in list recursion :)  (i know, probably simple, but I'm a haskell newbie :))
23:25:08 <monochrom> Ah, nice.  fix show is non-trivial
23:27:04 <monochrom> > take 20 (fix show)
23:27:06 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
23:27:39 <monochrom> > map ord (take 20 (fix show))
23:27:41 <lambdabot>  [34,92,34,92,92,92,34,92,92,92,92,92,92,92,34,92,92,92,92,92]
23:30:44 <Smokey`> > map ord (take 20 (concat [ (take (max 0 ((2^x) - 1)) (repeat '\\')) ++ "\"" | x <- [0..] ]))
23:30:45 <lambdabot>  [34,92,34,92,92,92,34,92,92,92,92,92,92,92,34,92,92,92,92,92]
23:30:53 <Smokey`> <3 my newbieness :)
23:31:18 <Smokey`> The things I do when I'm procrastinating :)
23:32:26 <monochrom> That is correct.
23:33:23 <lispy> ?type repeat
23:33:25 <lambdabot> forall a. a -> [a]
23:33:42 <lispy> > repeat '\\'
23:33:43 <lambdabot>  "\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\...
23:33:50 <lispy> Oh
23:33:53 <lispy> i see
23:34:04 <lispy> i thought you wrote (repeat '\\') ++ "\""
23:34:22 <lispy> and i wondered how you appended to the end of that infinite list :)
23:36:49 <Smokey`> I guess I could've used genericReplicate instead of take x (repeat y)
23:37:13 <Smokey`> would've made it clearer. (but I didn't know about genericReplicate untill ~60 seconds ago :P)
23:37:19 <EvilRanter> just replicate, shurely?
23:37:34 <EvilRanter> @type (replicate, genericReplicate)
23:37:36 <lambdabot> forall a i a1. (Integral i) => (Int -> a -> [a], i -> a1 -> [a1])
23:37:44 <Smokey`> I didn't know about replicate untill just 15 seconds ago ;)
23:37:48 <EvilRanter> hehe
23:38:11 <EvilRanter> @where libraries
23:38:11 <lambdabot> I know nothing about libraries.
23:38:14 <EvilRanter> meh
23:55:01 <dons> Cale: around? Looking for advice on the patch to add:
23:55:02 <dons> -- | Left-to-right Kleisli composition of monads.
23:55:02 <dons> (>=>)       :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
23:55:02 <dons> f >=> g     = \x -> f x >>= g
23:55:02 <dons> -- | Right-to-left Kleisli composition of monads. '(>=>)', with the arguments flipped
23:55:05 <dons> (<=<)       :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
23:55:08 <dons> (<=<)       = flip (>=>)
