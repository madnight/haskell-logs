13:09:23 --- topic: '["Design a #haskell tshirt - Distribute your cognition!", "Haskell - the language of ICFP winners 3 years running", "Logs: http://tunes.org/~nef/logs/haskell/"]'
13:09:23 --- topic: set by dons on [Tue Oct 31 01:30:26 2006]
13:09:23 --- names: list (clog sad0ur SyntaxNinja Excedrin alexj rahikkala kpreid dblog reilly Saulzar cdfh_ essiene povman Grey-z araujo int-e Binkley binary42 dolio jtoy faszos dgoldsmith PupenoR gFunk calvin_ Pete_I Una^ lhz qz clanehin Renkin beantmt dcoutts_ boliver dylan SamB_XP Ontolog perspectival BCoppens stevan_ triple_ rzoz pyronicide twanvl fabiim GeoBesh cjeris vincenz pitecus yaxu LOkadin_ paat metaperl iblechbot tizoc arjanb atsampso1 Prip pkhuong-)
13:09:23 --- names: list (gaal hyrax42 guerra ziggurat slipstream SamB JohnMeacham_ JohnMeacham Pupeno mwc Kattana Botje ms_ merus therp Philippa jeffz abrim obsethryl threeq theoco Mibori Khisanth MisterC sjanssen foxy_ satan Elifant cods Daveman fnordus osfameron Plareplane Akheron cwest lennart revision17 pkazmier drbean Syzygy- lisppaste2 saccade tessier psykotic arguile piggybox yosemite Twigathy badalex psnl Eidolos Korollary gdsx_ meddle kosmikus TSC jdev)
13:09:23 --- names: list (jgrimes lazer kzm_ converter ksandstr Averell scw_ mlh explicitjelly mr_ank jrigby nothingmuch Lunar^ encryptio dvekravy woggle nicodaemos_ slime_mold lambdabot Krunch alex777 pejo cmeme Tigge cpatrick crashmatrix pandres integral Carneus dgriffi3 jeol audreyt wolverian xinming wli Smokey` TwigEther eviltwin_b liyang|oxfrod ulfdoz johs MP0 tmoertel_away Pegazus orbitz ex_nor ozone ChilliX makinen thou thebug ascii Foxyloxy ADEpt astrolabe)
13:09:23 --- names: list (LoganCapaldo glguy noj yaarg szabi_ Lemmih scsibug dan2 Nioate Baughn gds aking Poeir arjanoosting wilx Cale profmakx arcatan eno dav Nanar sylvan Ugarte Codex_ carp dons flux__ kaol rafl mux edwinb ski JKnecht cognominal lispy tessier_ ricebowl aleator norpan klutometis SimonRC kzm vegai df__ resiak mathrick nnunley moonlite dcoutts newsham moconnor pingu musasabi ValarQ unclear lucca l_a_m dany2k Spark Igloo kpk qwr jcreigh earthy toyz)
13:09:23 --- names: list (bdash svens Hirvinen Maddas mornfall kolmodin Wallbraker desrt bran__ robreim Thomas2 Adamant sieni magagr mattam dino- ibid emu arcasin)
13:09:25 <SamB> @type \xs -> runKleisli (foldr1 (>>>) (map (Kleisli xs)))
13:09:26 <lambdabot>   Expecting a function type, but found `[a]'
13:09:26 <lambdabot>    Expected type: [Kleisli m a a]
13:09:32 <SamB> same thing...
13:09:42 <SamB> oh.
13:09:44 <SamB> duh.
13:09:44 <Cale> There were a lot of really cool things which got dropped going from 1.4 to 98 though
13:09:47 <SamB> @type \xs -> runKleisli (foldr1 (>>>) (map Kleisli xs))
13:09:49 <lambdabot> forall (m :: * -> *) b. (Arrow (Kleisli m)) => [b -> m b] -> b -> m b
13:10:17 <povman> i am so confused by this discussion
13:10:22 <SamB> hmm, it would be more informative if it said "Monad m" instead of "Arrow (Kleisli m)"
13:10:31 <Cale> I seem to recall reading over the mailing list archives (I wasn't around back then), and being shocked at the people who hate polymorphism :)
13:11:07 <SamB> did they hate polymorphism, or merely accidental overloading?
13:11:18 <Cale> I don't know.
13:11:31 <Cale> I think there were no SPECIALIZE pragmas back then
13:12:16 <sjanssen> and I bet reliable automatic specialization was even further off the horizon
13:12:47 <chessguy> ya'all should be proud of me
13:13:13 <Cale> chessguy: fighting the good fight?
13:13:14 <chessguy> i had an interviewer ask me how i would approach a particular problem, and i described it in haskell :)
13:13:14 <povman> chessguy: yeah?
13:13:22 <Cale> awesome
13:13:28 <Cale> what did they think?
13:13:29 <Binkley> hee
13:13:33 <Botje> chessguy: what problem did he ask you to solve?
13:13:33 <Binkley> did the interviewer know haskell?
13:13:39 <Botje> s/he/they/
13:13:41 <chessguy> no he didn't know it
13:13:50 <Cale> did he understand what you wrote?
13:13:53 <sjanssen> did he say, "I don't want pseudo-code, I want a real solution!" ?
13:13:58 <chessguy> i didn't actually write code
13:14:02 <chessguy> it was a verbal description
13:14:18 <Cale> What was the problem?
13:14:29 <SamB> sjanssen: hehe
13:14:30 <chessguy> the problem was to parse the text on my resume and to give a list of all the words appearing on it, sorted by frequency
13:14:57 <chessguy> i wanted grouBy :)
13:15:02 <chessguy> groupBy, even
13:15:17 <sjanssen> chessguy: you easily could've written that out though ;)
13:15:21 <newsham> *Foo> ["foo"] >>= prepend "!" >>= append "!"
13:15:21 <newsham> ["!foo!"]
13:15:28 <chessguy> sure
13:15:37 <newsham> i want a way to make a list  [prepend "!", append "!"]
13:15:40 <newsham> and compose them
13:15:49 <newsham> *Foo> ["foo"] >>= withId (prepend "!") >>= withId (append "!")
13:15:49 <newsham> ["foo","foo!","!foo","!foo!"]
13:15:51 <chessguy> i also could've pulled out my laptop and created a program :)
13:15:56 <newsham> also so I can map withId    over this
13:16:03 <pkhuong-> chessguy: shell script anyone>
13:16:04 <pkhuong-> ?
13:16:21 <chessguy> i did say the other language i might use is perl
13:16:34 <newsham> hi chessguy from #math
13:16:37 <sjanssen> pkhuong-: Haskell would likely be just as easy
13:16:42 <newsham> who didn thelp me with my math question
13:16:49 <Binkley> @karma+ chessguy
13:16:50 <lambdabot> chessguy's karma raised to 1.
13:17:15 <chessguy> heh. i do have a few other things to do, newsham
13:17:20 <chessguy> i don't owe you anything
13:17:43 <Cale> map head . sortBy (flip (comparing length)) . group . sort . words . map toLower
13:18:08 <Botje> O_O
13:18:14 <chessguy> yeah, i shoulda just said that :)
13:18:38 <sjanssen> tack on "main = interact $", and you've got an entire program
13:18:47 <Cale> yep :)
13:18:53 <sjanssen> oh, and show
13:18:56 <chessguy> interact?
13:19:02 <Cale> right
13:19:03 <sjanssen> @type interact
13:19:05 <lambdabot> (String -> String) -> IO ()
13:19:08 <twanvl> ?type interact
13:19:09 <lambdabot> (String -> String) -> IO ()
13:19:37 <monochrom> interact is cool
13:20:04 <Binkley> this channel always makes me feel like such a n00b. were I answering that interview question I'd probably have written it in terms of foldr
13:20:06 <Cale> interact is the one true way to write unix programs in Haskell :)
13:20:59 <monochrom> Software re-use is a rare skill.  Most people are tempted to write code from scratch.
13:21:07 <Cale> Binkley: I don't think you're in danger of being confused with a n00b
13:21:22 <Binkley> that's not how I feel!
13:21:40 <chessguy> hmm, is that a good way to approach it?
13:21:43 <norpan> n00b: rember that double-ohs have a short life-expectency
13:21:59 <norpan> expectancy, sorry
13:22:00 <Cale> I think that working at Microsoft Research on GHC pretty much disqualifies you from n00bness.
13:22:03 <Binkley> heh
13:22:13 <Binkley> any day now they'll figure out that I'm actually a n00b, though.
13:22:25 <Binkley> Maybe there's some equivalent of the full employment theorem for compiler writers for Haskell programmers
13:22:38 <Binkley> no matter how short a Haskell program you write, someone else will always write an equivalent shorter Haskell program
13:23:02 <chessguy> besides, he wouldn't have had a clue what foldr was :)
13:23:06 <pkhuong-> Binkley: breadth-first search + quickcheck? :)
13:23:18 <Binkley> well, I always end up explaining what foldr is in my interviews anyway
13:23:26 <chessguy> lol
13:23:26 <monochrom> The theorem for Haskell programs is the Schwarzchild theorem.
13:23:33 <sjanssen> ha
13:23:34 <Binkley> pkhuong: good point. I smell a research paper there
13:23:49 <chessguy> then again, you probably explain what foldr is in conversations about the weather, too :)
13:23:53 <Binkley> "Automatic Synthesis of Haskell Programs Using Random Test Generation and Tree Traversal"
13:24:19 <pkhuong-> Binkley: it's mine! :)
13:24:23 <Cale> I know I always have trouble explaining what the weather is like without involving foldr somehow.
13:24:36 <monochrom> How?
13:24:38 <sjanssen> we could just instance Arbitrary for the types in Language.Haskell
13:25:01 <pitecus> Prelude> :m Control.Monad.Reader
13:25:01 <pitecus> Could not find module `Control.Monad.Reader':
13:25:01 <pitecus>   Use -v to see a list of the files searched for.
13:25:06 <pitecus> Isnt that weird?
13:25:13 <sjanssen> pitecus: with GHC 6.6?
13:25:16 <chessguy> so Cale, did you solve my math problem yet?
13:25:17 <pitecus> yes
13:25:18 <sjanssen> you need extralibs
13:25:26 <sjanssen> or the mtl package
13:25:32 <sjanssen> what platform are you on?
13:25:37 <pitecus> additional package to install?
13:25:42 <pitecus> Fedora
13:25:54 <monochrom> ta ta dum!
13:26:11 <sjanssen> pitecus: search for either an "extralib" or "mtl" package
13:26:25 <Cale> chessguy: nope, though to be honest I've been bouncing around between a bunch of different things
13:26:32 <chessguy> pff
13:26:43 <pitecus> sjanssen, thanks
13:26:58 <chessguy> surely i'm not going to have to do my final math project myself
13:27:41 <chessguy> actually, i hope i do get it mostly myself.
13:27:47 <chessguy> it could turn into a good paper
13:27:50 <pitecus> hm there seems to be extralibs source but no binary distribution...
13:28:54 <chessguy> oh, the other thing i said during the interview
13:29:09 <chessguy> the guy was asking me about the differences between c/c++/perl
13:29:23 <Binkley> and did you say that the latter two suck a lot and the first one only sucks somewhat?
13:29:28 <chessguy> he wanted to know which was better, or if they were all equivalent
13:29:31 <Binkley> heh
13:29:38 <Binkley> yes, C++ and perl are equivalent
13:29:42 <chessguy> i jokingly said, "well, they're all turing complete'
13:29:58 <chessguy> i don't think he got it though
13:30:10 <Binkley> maybe that's a sign you don't want to work for him
13:30:13 <chessguy> or at least he didn't think it was funny
13:30:31 <SamB> it isn't particularly funny, is it?
13:31:01 <dolio> Perhaps he's an epigram guy and frowns on Turing completeness.
13:31:09 <SamB> haha
13:31:13 <chessguy> i guess not, but it was a pun on his word equivalent, purposely interpreting it in a way he obviously didn't intend
13:31:15 <SamB> now *that* is funny
13:31:42 <SamB> frowns on turing completeness...
13:31:51 <sjanssen> chessguy: if I were your interviewer, I'd respond "Prove it."
13:32:04 <monochrom> This is a very uneducated interviewer.
13:32:12 <SamB> sjanssen: that isn't hard...
13:32:19 <chessguy> and i'd say "it's trivial, i'll leave it as an exercise for you"
13:32:27 <SamB> you just write a universal turing machine in C and port it to Perl...
13:32:38 <Cale> SamB: this is perl we're talking about though -- proving that a perl program does anything in particular is bound to be tricky
13:32:45 <chessguy> ?remember dolio Perhaps he's an epigram guy and frowns on Turing completeness.
13:32:47 <SamB> well.
13:33:09 <sjanssen> SamB: Cale is right, you'd have to prove that the C implementation is correct
13:33:10 <monochrom> Reduce Perl to C by pointing at the Perl interpreter written in C.
13:33:23 <sjanssen> ah, there we go
13:33:27 <SamB> sjanssen: Cale said to prove the Perl one.
13:33:33 <SamB> the C one is surely easier to prove...
13:33:41 <povman> wouldn't you just write a C compiler in perl?
13:33:48 <Cale> but that's not a surjective map, and so it may be impossible to construct some programs
13:33:59 <monochrom> Ah, but what is the definition of "Perl"?  The definition says it's whatever Larry's interpreter does.  Proof by axiom.
13:34:18 <Cale> Larry says that it's Turing complete, so it is.
13:34:23 <SamB> heh
13:34:41 <monochrom> And then, since the claim is that Perl sucks more than C does, one isn't obliged to prove the reduction from C to Perl.
13:34:54 <emu> can all recursive functions be expressed in that language
13:34:56 <Cale> I don't even know if you could really even claim that perl is an abstract language
13:35:04 <SamB> wait, I thought we were proving they were all turing complete?
13:35:13 <pejo> chessguy, what kind of position was it anyways?
13:35:19 <Cale> The only thing which parses Perl is perl, and that only runs on real computers :)
13:35:20 <monochrom> I thought we were proving they all suck.
13:35:31 <chessguy> mostly programming in perl for an internet marketing company
13:35:53 <SamB> oh, but if we want to prove that they are all equivalent -- don't we need to prove that they are also implementable *by* turing machines?
13:36:16 <SamB> ... I don't know if that is true of Perl or not.
13:36:37 <SamB> in fact, I kind of doubt it
13:36:41 <chessguy> in a very "hierarchically flat" company. i can't decide if that's a good thing or a bad one
13:36:43 <int-e> give the turing machine a random number generator ...
13:36:44 <Ugarte> Why  is that necessary? If they can all implement a turing machine, they are all turing complete. Is there a superset of turing completeness to computability?
13:36:52 <dolio> Does Perl require an oracle to run?
13:37:01 <SamB> Ugarte: there might be!
13:37:11 <Ugarte> But working under the assumption there is not, you're finished at that step.
13:37:11 <monochrom> Anyway this interviewer seems uneducated and religious.  He's probably wanting an answer along the party line such as "c++ is OO but c is not".  Well I was writing Windows apps in C since the days of Windows 3.0 and I tell you it's very OO.
13:37:18 <povman> SamB: the other way around
13:37:25 <Binkley> ?remember monochrom Well I was writing Windows apps in C since the days of Windows 3.0 and I tell you it's very OO.
13:37:48 <emu> OO as in oO?
13:37:48 <SamB> oh, I guess I'm confused with time complexity...
13:37:53 <Cale> monochrom: really? I always had the feeling that the Win32 api would actually be easier to use if I was coding in assembler.
13:38:08 <chessguy> he did ask me a bunch of questions about the advantages/disadvantages of different languages for different problems. i'm not sure what he was looking for
13:38:11 <monochrom> Ahem, WIndows 3.0 was Win16.
13:38:16 <Cale> ah, right
13:38:26 <Cale> So you're saying they actually went backwards?
13:38:41 <SamB> huh?
13:38:43 <sjanssen> chessguy: he was probably looking for the cliche "different tools for different problems" answer
13:39:01 <Cale> I thought the win32 api was rather similar to the 16-bit api.
13:39:02 <povman> one tool for all problems imo
13:39:18 <monochrom> Ha, I actually don't know.  I have only looked at Win16.  It was OK.  It was OK because nothing was original from Microsoft anyway.  Copying from PARC and/or X can't go wrong. :)
13:39:24 <SamB> he should have offered you Perl, Python, Shell, Awk, and Sed.
13:39:25 <Binkley> and Windows 1.0 was Win1?
13:39:30 <chessguy> well i did say that
13:39:45 <SamB> Binkley: no, they used 16 bit words already then I'm sure
13:40:01 <Binkley> well, I was trying to imply that they were using 1-bit words then
13:40:04 <Binkley> but I guess my attempt at humor failed
13:40:23 <SamB> oh, well, I was just about to say something about how unusable 1-bit words would be
13:40:28 <SamB> but I hadn't figured out how
13:40:35 <Binkley> yeah
13:40:37 <Binkley> much like Windows 1.0
13:40:50 <SamB> yeah, but it had a UI didn't it?
13:40:51 <Cale> 1-bit words are an extravagance. Try using 0-bit words.
13:40:51 <int-e> . o O ( python is a good language to write perl programs in )
13:40:51 <chessguy> windows 1.0? did that exist?
13:41:01 <Binkley> I think "UI" is probably an overstatement
13:41:01 <dolio> Ugarte: You can talk about supersets of problems decidable by turing machines.
13:41:06 <SamB> I think that is evidence that there are more than two memory locations within a segment, don't you?
13:41:11 <monochrom> Someone tried to give a class-based binding of Win16 in C++.  It didn't go well, mainly because C++ (esp. at that time) is not very expressive.
13:41:12 <Binkley> "when I was starting out, we didn't have 1s, only 0s. and some of the 0s didn't even have holes"
13:41:32 <SamB> Binkley: clearly, the ones without holes stood for ones
13:41:40 <dolio> Ugarte: For instance, you can suppose you have a machine that will decide the halting problem, and then talk about what other problems you can solve by relying that machine.
13:41:48 <Cale> A 1 is just a simply-connected 0
13:42:09 <Ugarte> dolio: In the hypothetical. But that's only relevant if one of those languages can decide the halting problem.
13:42:09 <monochrom> Eh?!  Firefox is telling me that 1.5.0.8 is ready for download?!  I thought the talk of the town was 2.0 ...
13:42:29 <emu> security update to .7
13:42:57 <dolio> Ah, well, yeah. It doesn't make much difference in practice.
13:43:07 <chessguy> i suppose i should go do my 'principles of programming languages' class
13:43:07 <monochrom> Yes I appreciate security updates, but I'm expecting to be offered 2.0 :)
13:43:10 <chessguy> homework
13:43:11 <Cale> I really like how they removed features from the quicksearch bar in 2.0, and made the proxy settings harder to get to.
13:43:24 <Ugarte> Right, so for his proof, he need only show that any programming language can implement a turing machine. He need not show a turing machine can implement the program. No?
13:43:32 <Ugarte> Cale: Yeah, the quicksearch thing bugs me.
13:43:39 <Cale> Ugarte: it's fixable
13:43:46 <Ugarte> How?
13:44:02 <Cale> add
13:44:05 <Cale> #FindToolbar > * { display:-moz-box !important; }
13:44:11 <Cale> to your userChrome.css
13:44:14 <monochrom> Haha yeah there are Pi_1 and SomethingRather_1 problems that can be solved by asking the halt-problem-solver once.  Generally Pi_n and SomethingRather_n are about asking the solver n questions.
13:44:17 <Ugarte> Thanks.
13:44:26 <povman> it still won't use system wide proxy settings in mac os x
13:44:35 <monochrom> This suddenly reminds me of fairy tales about being granted three wishes.
13:44:37 <roconnor> monochrom: Sigma_1?
13:44:42 <Cale> I also like adding:
13:44:43 <monochrom> YES!  Thanks.
13:44:46 <Cale> #searchbar {
13:44:46 <Cale> -moz-box-flex: 400 !important;
13:44:46 <Cale> }
13:44:46 <Cale> #search-container {
13:44:46 <Cale> -moz-box-flex: 400 !important;
13:44:46 <Cale> }
13:45:02 <Cale> that will make the search bar expand to whatever size it's given
13:45:03 <roconnor> Sigma_1 problems are semidecidable
13:45:08 <Ugarte> Now if only I knew where that file was on Vista.
13:45:16 <Cale> Probably Application Data
13:45:31 <Ugarte> Found it.
13:45:49 <Ugarte> Maybe.
13:46:09 <Cale> You probably have a userChrome-example.css
13:46:14 <Ugarte> I don;t.
13:46:17 <Cale> hmm
13:46:18 <Ugarte> I have a profile.
13:46:20 <Ugarte> But it's empty.
13:46:20 <Ugarte> Odd.
13:46:22 <Cale> okay
13:46:26 <Cale> completely empty?
13:46:40 <Cale> are you showing hidden/system files?
13:46:41 <Ugarte> Save for two MFL files and a cache?
13:46:44 <Ugarte> Yes.
13:46:47 <LOkadin_> if I have a haskell functions valsi,cmene, and sumti, is there an easier way than having a case statement to use them from input. meaning if in stdin I put valsi, do I have to match with a case statement, and then run valsi, or could I just somehow get it to use the string to directly call the function, like with input in Python I believe
13:46:47 <Cale> hmm
13:47:12 <Cale> search the disk for userChrome-example.css
13:47:18 <newsham> http://www.thenewsh.com/~newsham/x/machine/Transform.hs
13:47:23 <lambdabot> http://tinyurl.com/y2v2kg
13:47:35 <monochrom> Yes LOkadin I think you have to do that.
13:47:42 <integral> LOkadin: there's no reflection like that in Haskell-98
13:47:56 <Cale> All the names are gone by the time the program is compiled.
13:47:57 <monochrom> The feature you wish for is a security hole.
13:48:01 <integral> (with GHC there's at least hs-plugins's eval...)
13:48:12 <povman> EVAL?!?!?!??!?!?!?!?!
13:48:17 <LOkadin> cool, okay, thanks that's what I needed to know
13:48:19 <Cale> povman: yeah
13:48:19 * povman looks
13:48:20 <integral> LOkadin: Even for Perl the standard advice is to use an explicit map for this.
13:48:31 <integral> (err, s/map/hash/ if you talk perl-speak)
13:48:37 <povman> this is perfect
13:48:55 <povman> i was trying to figure a way of marshalling monads
13:49:21 <monochrom> If you have followed all the threads about security vulnerabilities due to user strings going into SQL statements, you'll wish you've never seen it.
13:50:08 <povman> what if you could run it sandboxed?
13:50:44 <newsham> "SQL Injection"
13:51:14 <newsham> string splicing unsafe user provided data into textual SQL query resulting in SQL string that parses in a way other than originally intended.
13:51:15 <newsham> oopz
13:51:58 <integral> @eval System.Cmd.system "rm /tmp/foobar"
13:52:03 <monochrom> Haha, template haskell's "runIO" command is a security vulnerability too!
13:52:13 * integral pokes lambdabot 
13:52:44 <newsham> mono: but at least an attacker cant get at TH at runtime unless the program is rebuilt every time it is run
13:52:50 <newsham> (with user inputs!)
13:52:50 <monochrom> So basically I give you Haskell source code, and you compile on your computer, and during the compilation my TH code can snoop your files and send them to me...
13:53:12 <newsham> sure, but i can also put naughty code in ./configure
13:53:20 <newsham> or in the actual src code and wait till you run
13:53:27 <newsham> therein lies the trust
13:53:45 <monochrom> Suppose I'm your student and you're my grader, and I want to change my marks, and you're marking my homework source code...
13:53:46 <SamB> > id$(runIO (readFile "/etc/password"))
13:53:47 <lambdabot>  Not in scope: `runIO'
13:53:55 <Binkley> lambdabot doesn't allow IO
13:53:57 <Binkley> that would be naughty
13:54:13 <monochrom> lambdabot is smart!
13:54:18 <SamB> Binkley: it was a vulnerability until dons changed the import...
13:54:21 <Binkley> monochrom: I think in a lot of classes, that would result in an automatic A for the student
13:54:22 <Binkley> heh
13:54:32 <povman> ah, what if you force an initial library and disallow imports
13:54:39 <povman> in the eval code
13:54:46 <SamB> the id there is so that lambdabot's parser (which parses differently from TH) will parse that as an expression
13:55:02 <sjanssen> povman: that's how lambdabot does it
13:55:06 <SamB> povman: that only works if you don't accidentally import anything unsafe
13:55:28 <povman> SamB: i'm sure you can do that.
13:56:40 <povman> i was planning on having bot code replaceable while the game is running
13:58:56 <cdfh_> How does one perform "ceiling (a/b)" in haskell? Hugs is complaining about requiring an instance of RealFrac - surely there's a better way?
13:58:58 <sjanssen> povman: you should look at dons' (the author of hs-plugins) papers
13:59:02 <cdfh_> a and b would be Int's
13:59:26 <sjanssen> > ceiling (fromIntegral 1 / fromIntegral 2)
13:59:28 <lambdabot>  1
13:59:49 <integral> cdfh_: basically you have to use fromIntegral a lot in Haskell :)
13:59:59 <vincenz> > ceiling (1/2)
14:00:01 <lambdabot>  1
14:00:06 <cdfh_> integral: ;-)
14:00:16 <povman> sjanssen: ok, thanks
14:00:27 <cdfh_> ceiling (1/2) gets shouted at when i run it from within a program, though
14:00:36 <cdfh_> Hugs is happy when I type it at the interactive prompt, though
14:00:44 <integral> that sounds like defaulting :-/
14:00:51 <cdfh_> sjanssen: will try - thanks :-)
14:00:57 <SamB> > ceiling (1/2)
14:00:59 <lambdabot>  1
14:01:19 <pitecus> a weird runtime error: No match in record selector ...
14:01:26 <pitecus> what does it refer to?
14:01:55 <sjanssen> pitecus: you used a record selector that somehow doesn't apply to the value you applied it to
14:02:25 <sjanssen> do you have something like data Foo = A {a :: Int} | B {b :: Int} in your program?
14:03:15 <pitecus> i do
14:03:56 <pitecus> Shouldnt that be caught at compile time though?
14:04:00 <sjanssen> you tried to apply "a (B something)"
14:04:02 <sjanssen> nope
14:04:05 <monochrom> > (1::Integer / 2)
14:04:06 <lambdabot>  Parse error
14:04:08 <sjanssen> A and B are the same type
14:04:23 <pitecus> fair enough
14:04:24 <monochrom> > ((1::Integer) / 2)
14:04:24 <sjanssen> erm, constructors for the same type
14:04:26 <lambdabot>  add an instance declaration for (Fractional Integer)
14:04:26 <lambdabot>   In the definition ...
14:04:31 <monochrom> That is the reason.
14:05:07 <pitecus> So is it best to avoid such datatypes?
14:05:15 <metaperl> @type replicate
14:05:17 <lambdabot> forall a. Int -> a -> [a]
14:07:15 <povman> is hs-plugins what yi uses?
14:07:32 <SamB> pitecus: try Catch
14:07:45 <SamB> it is supposed to catch things like that
14:07:54 <pitecus> whats that a module?
14:08:05 <SamB> no, a tool
14:08:13 <SamB> ndm is always recommending it
14:09:12 <Binkley> are you talking about neil's back end again
14:09:14 <pitecus> Dunno I guess I d rather adjust programming style to avoid those runtime errors
14:18:08 <dcoutts> @yarr!
14:18:09 <lambdabot> I want me grog!
14:18:18 <dcoutts> wait, I've have me grog.
14:18:25 <dcoutts> (plenty)
14:19:01 <dcoutts> I should like to report that the "fun in the afternoon" event in Oxford was indeed good fun.
14:19:22 <jgrimes> :)
14:19:38 <SamB> obviously lambdabot would like you to share your grog with her, dcoutts ;-)
14:19:45 <lisppaste2> metaperl pasted "trying to left-pad a string... " at http://paste.lisp.org/display/30045
14:19:51 <dcoutts> SamB, ah, I see :-)
14:20:10 <scodil> if you freeze a StorableArray, will it box the values?
14:20:24 <metaperl> can somebody help me right a fn to left-pad a string with spaces: http://paste.lisp.org/display/30045
14:20:31 <SamB> I am assuming grog refers to a beverage and not the feeling you get from drinking it?
14:21:07 <metaperl> please help me: http://paste.lisp.org/display/30045
14:21:19 <dcoutts> sjanssen, so I've proposed a Msc project here to pick up your project and complete the Data.PackedString, to make it do UTF8/16/32 and make it fusible and get it integrated into base.
14:21:35 <dcoutts> SamB, both I suppose :-)
14:21:53 <Lemmih> > let leftpad len str = reverse (take len (reverse str ++ repeat ' ')) in (leftpad 6 "Hi", leftpad 6 "Hello")
14:21:55 <lambdabot>  ("    Hi"," Hello")
14:21:56 <dcoutts> sjanssen, we'll see if any Msc student volunteers :-)
14:22:06 <metaperl> Lemmih: ouch
14:22:11 <Botje> dcoutts: what about UTF-36?
14:22:23 <Botje> or UTF-9?
14:22:23 <metaperl> Lemmih:  what is wrong with what I did?
14:22:31 <dcoutts> Botje, pfft. Yeah, what of it?
14:22:40 <Botje> will you support them? ;)
14:22:42 <dcoutts> hia bringert
14:22:56 <bringert> hi dcoutts
14:23:03 <jgrimes> > let leftpad len str = (take len $ repeat ' ') ++ str in leftpad 10 "asdf"
14:23:05 <lambdabot>  "          asdf"
14:23:11 <dcoutts> Botje, as long as they can be supported by only writing stream & unstream then yeah, it's easy.
14:23:33 <dino-> metaperl: While not specifically wrong, you can use '| otherwise = ...' for your fall-through guard.
14:23:35 <Lemmih> metaperl: Is there anything wrong with it?
14:23:50 <metaperl> dino-:  yes, its jus so much longer to type
14:23:53 <metaperl> Lemmih: it doesnt work
14:23:54 <dino-> :)
14:24:07 <metaperl> dino-: it does read better though
14:24:46 <Lemmih> > let pushRight len str | length str >= len = str | otherwise = ' ':pushRight (len-1) str in (pushRight 6 "Hi", pushRight 6 "Hello")
14:24:48 <lambdabot>  ("    Hi"," Hello")
14:25:10 <Lemmih> metaperl: It works just fine.
14:25:27 <metaperl> hmm, yes, but I had " " ++ (pushRight (len-1) str)
14:25:34 <dino-> His code has (++)
14:25:42 <metaperl> shouldnt that work
14:25:52 <Lemmih> metaperl: Oh, and (<=) instead of (>=).
14:26:05 <rumpl> Cale, hi :)
14:26:30 <metaperl> ah!
14:26:32 <metaperl> thanks!
14:26:33 <Cale> rumpl: hi :)
14:51:14 <dons> ?users
14:51:15 <lambdabot> Maximum users seen in #haskell: 270, currently: 256 (94.8%), active: 42 (16.4%)
14:52:26 <shapr> hej alla!
14:54:05 <heisenbug> so, can anybody offer a proof for the Hurry-Coward Correspondence?
14:54:18 <heisenbug> ;-)
14:55:24 <shapr> hi alexj_
14:55:38 <lispy> heisenbug: sorry, it's not real :(
14:55:42 <alexj_> shapr: hi there.  jabber?
14:55:49 <shapr> alexj_: yup
14:57:01 <heisenbug> lispy: you have a counterexample?
14:57:05 <gene9> @type .
14:57:06 <lambdabot> parse error on input `.'
14:57:31 <gene9> @djinn a -> a -> Int
14:57:31 <lambdabot> -- f cannot be realized.
14:57:39 <gene9> @djinn a -> a -> Bool
14:57:40 <lambdabot> f _ _ = False
14:57:55 <gene9> @djinn a -> a -> (Int -> Bool)
14:57:55 <lambdabot> f _ _ _ = False
14:58:40 <gene9> @djinn
14:58:41 <lambdabot> Cannot parse command
14:58:41 <lispy> heisenbug: of course! (i actuall i'm just teasing)
14:58:53 <lispy> @djinn Maybe a -> a
14:58:54 <lambdabot> -- f cannot be realized.
14:59:01 <lispy> @djinn a -> Maybe a
14:59:01 <lambdabot> f = Just
14:59:09 * heisenbug is in joking mood
14:59:31 <chessguy> grr, i've written all my scheme homework assignments with 1- or 2-liners in haskell except rrotate, which returns a list rotated to the right. e.g., [a,b,c,d] -> [d,a,b,c]
15:00:03 <lispy> chessguy: it takes me more than one line to
15:00:19 <chessguy> more than 2?
15:00:20 <gene9> @djinn lispy -> ForSure lispy
15:00:21 <lambdabot> -- f cannot be realized.
15:00:43 <gene9> :)
15:00:58 <SamB_XP> @djinn ForSure
15:00:59 <lambdabot> -- f cannot be realized.
15:01:05 <SamB_XP> @help djinn
15:01:06 <lambdabot> djinn <type>.
15:01:06 <lambdabot> Generates Haskell code from a type.
15:01:06 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
15:01:12 <lispy> chessguy: iirc, it took 4 lines because i defined both lrotate and rrotate in terms of each other
15:01:12 <Botje> chessguy: [tail list] ++ init list :)
15:01:33 <chessguy> that's lrotate
15:01:35 <Botje> err
15:01:36 <chessguy> wrong direction
15:01:49 <lispy> oh, mine took number of times to be shifted too
15:02:01 <lispy> rrotate :: Int -> [a] -> [a]
15:02:21 <chessguy> mine's only supposed to shift once
15:02:35 <Botje> chessguy:
15:02:37 <Botje> Hugs.Base> let list = [1,2,3,4] in (last list) : init list
15:02:37 <Botje> [4,1,2,3]
15:02:42 <gene9> djinn f ? Either () (a, b) -> Either () (b, a)
15:02:44 <chessguy> i have lrotate []=[]  and lrotate (x:xs) = xs ++ x
15:02:50 <chessguy> last!
15:02:52 <gene9> @djinn f ? Either () (a, b) -> Either () (b, a)
15:02:53 <lambdabot> Cannot parse command
15:02:57 <chessguy> that's what i was missing
15:03:09 <astrolabe> Work out what rrotate (a:as)   is in terms of   a    and   rrotate as
15:03:30 <chessguy> huh?
15:03:40 <chessguy> Botje's solution is fine
15:03:51 <astrolabe> Ah, I missed that
15:03:51 <gene9> @djinn a -> Bool -> (a -> b)
15:03:52 <lambdabot> -- f cannot be realized.
15:03:59 <chessguy> i'm not turning this in anyway. i just want to write everything in haskell before i write it in scheme, on principle
15:04:04 <gene9> @djinn a -> Bool  -> b -> (a -> b)
15:04:04 <lambdabot> f _ _ a _ = a
15:04:28 <kpreid> @let rotate n = take (length xs) . drop n . cycle
15:04:29 <lambdabot> <local>:16:24: Not in scope: `xs'
15:04:31 <chessguy> > let list = [] in (last list) : init list
15:04:32 <lambdabot>  Add a type signature
15:04:36 <kpreid> @let rotate n xs = take (length xs) . drop n . cycle $ xs
15:04:38 <lambdabot> Defined.
15:04:46 <kpreid> > L.rotate 1 [1..10]
15:04:47 <lambdabot>  [2,3,4,5,6,7,8,9,10,1]
15:04:49 <SamB_XP> couldn't you write a Yhc bytecode interpreter for scheme and then append the bytecode to it or something?
15:04:51 <kpreid> > L.rotate -1 [1..10]
15:04:52 <lambdabot>  add an instance declaration for (Num ([a1] -> Int -> [a] -> [a]))
15:05:03 <kpreid> hm, oops
15:05:11 <kpreid> > -1 `mod` 10
15:05:13 <lambdabot>  -1
15:05:29 <lispy> > L.rotate (-1) [1..10]
15:05:30 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
15:05:31 <kpreid> @let rotate n xs = take l . drop (n `mod` l) . cycle $ xs where l = length xs
15:05:32 <lambdabot> <local>:16:0:     Warning: Pattern match(es) are overlapped              In t...
15:05:45 <kpreid> huh?
15:05:47 <Renkin> Would it be bad practice to create a monad where the programs had no return type, just to be able to use the do-construct?
15:05:50 <chessguy> now i can go to class in peace :)
15:05:56 <kpreid> > L.rotate (-1) [1..10]
15:05:57 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
15:06:04 <kpreid> @undefine
15:06:05 <lambdabot> Undefined.
15:06:07 <kpreid> @let rotate n xs = take l . drop (n `mod` l) . cycle $ xs where l = length xs
15:06:09 <lambdabot> Defined.
15:06:10 <kpreid> > L.rotate (-1) [1..10]
15:06:12 <lambdabot>  [10,1,2,3,4,5,6,7,8,9]
15:06:32 <monochrom> Renkin: I don't know what you mean, but I suppose yes.
15:06:35 <lispy> kpreid: nice
15:06:36 <LoganCapaldo> Renkin: could you not just return ()
15:06:50 <shizzy0> Hey guys, I've got problem composing data types that I'd really appreciate some one helping me with.  I think it's a problem that requires a 'forall' kind of magic.
15:06:55 <kpreid> @let rotate n xs = take l . drop (n `mod` l) . replicate 2 $ xs where l = length xs
15:06:56 <lambdabot> <local>:2:14:     Occurs check: cannot construct the infinite type: a = [a]  ...
15:07:02 <Renkin> monochrom: I'm not sure if I know what I mean, either :)
15:07:06 <Renkin> LoganCapaldo: Yes, probably
15:07:34 <shizzy0> I'm writing a physics engine, so I have particles which works great.
15:07:40 <lispy> > L.rotate 100 [1..10]
15:07:41 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
15:07:46 <lispy> > L.rotate 101 [1..10]
15:07:47 <lambdabot>  [2,3,4,5,6,7,8,9,10,1]
15:07:54 <lispy> looks good to me
15:08:09 <shizzy0> Now, I want to compose those particles into rigid bodies and I'm running into some typing problems.
15:08:11 <kpreid> cycle isn't needed given the mod
15:08:32 <kpreid> @pl \a -> a ++ a
15:08:33 <lambdabot> join (++)
15:08:39 <kpreid> @let rotate n xs = take l . drop (n `mod` l) . join (++) $ xs where l = length xs
15:08:41 <lambdabot> <local>:1:0:     Warning: Pattern match(es) are overlapped              In th...
15:08:44 <kpreid> @undefine
15:08:45 <lambdabot> Undefined.
15:08:46 <kpreid> @let rotate n xs = take l . drop (n `mod` l) . join (++) $ xs where l = length xs
15:08:47 <lambdabot> Defined.
15:08:56 <kpreid> > L.rotate 101 [1..10]
15:08:58 <lambdabot>  [2,3,4,5,6,7,8,9,10,1]
15:09:03 <fik> shizzy0, what problem?
15:09:14 <SamB_XP> > join (++) "zen"
15:09:16 <lambdabot>  "zenzen"
15:09:22 <kpreid> @unpl rotate n xs = take l . drop (n `mod` l) . join (++) $ xs where l = length xs
15:09:22 <lambdabot> rotate n xs
15:09:23 <lambdabot>  = (\ c -> take l (drop (mod n l) (((++) >>= \ g -> g) c))) $ xs
15:09:23 <lambdabot>  where l = length xs
15:09:31 <SamB_XP> @type (join (++))
15:09:33 <lambdabot> forall a. [a] -> [a]
15:09:40 <SamB_XP> @type join
15:09:41 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
15:09:42 <LoganCapaldo> @help pl
15:09:43 <lambdabot> pointless <expr>. Play with pointfree code.
15:09:57 <LoganCapaldo> aha
15:10:03 <shizzy0> fik, I put together some code snippets that focuses on the problem I'm having.  Is there somewhere I can paste it?
15:10:05 <LoganCapaldo> that's a smart lambdabot
15:10:24 <LoganCapaldo> @help paste
15:10:25 <lambdabot> paste. Paste page url
15:10:41 <kpreid> SamB_XP: join = combine two monadic layers; one Reader layer is one argument; ++ takes two arguments, so join makes the two arguments the same...right?
15:10:43 <vincenz> @paste
15:10:43 <lambdabot> http://paste.lisp.org/new/haskell
15:10:58 <SamB_XP> kpreid: oh.
15:10:59 <Excedrin> @help yhjulwwiefzojcbxybbruweejw
15:11:00 <lambdabot> V RETURNS!
15:11:03 <SamB_XP> that explains that I guess.
15:11:06 <Excedrin> I don't get it
15:11:08 <SamB_XP> ;-)
15:11:17 <lisppaste2> shizzy0 pasted "data type composition problem" at http://paste.lisp.org/display/30050
15:11:19 <SamB_XP> @yhjulwwiefzojcbxybbruweejw
15:11:20 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
15:11:28 <vincenz> @y
15:11:29 <lambdabot> Maybe you meant: yarr yhjulwwiefzojcbxybbruweejw yow . v
15:11:29 <kpreid> Excedrin: once upon a time lambdabot's eval bound 'v' to 'show' of the value of the expression
15:11:34 <vincenz> LOOOL
15:11:41 <vincenz> where did that come from?
15:11:43 <vincenz> @yuiafsfarew
15:11:44 <lambdabot> Unknown command, try @list
15:11:46 <gene9> > L
15:11:47 <kpreid> Excedrin: the yhjulwwiefzojcbxybbruweejw/v command preserves some things that did
15:11:47 <lambdabot>  Not in scope: data constructor `L'
15:11:51 <Excedrin> @v
15:11:52 <lambdabot> Exception: <<loop>>
15:11:57 <SamB_XP> I think "v" must have been the name of what @run would show?
15:11:59 <vincenz> @yhjulwwiefzojcbxybbruweejw
15:11:59 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
15:12:01 * shizzy0 pastes
15:12:02 <SamB_XP> or print?
15:12:02 <vincenz> @help yhjulwwiefzojcbxybbruweejw
15:12:03 <gene9> > L.rotate 101 [1..10]
15:12:03 <lambdabot> V RETURNS!
15:12:04 <lambdabot>  [2,3,4,5,6,7,8,9,10,1]
15:12:07 <SamB_XP> > fix show
15:12:09 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
15:12:10 <vincenz> Who the fuck came up with that idea
15:12:20 <Ontolog> What is wrong with this? putStrLn (show x) ++ " factorial is " ++ (show (factorial x))
15:12:23 <gene9> > L.rotate (-2) [1..10]
15:12:25 <lambdabot>  [9,10,1,2,3,4,5,6,7,8]
15:12:31 <kpreid> Excedrin: for example, > v was equivalent to 'fix show'
15:12:33 <kpreid> SamB_XP: yes
15:12:35 <Excedrin> @help v
15:12:36 <kpreid> SamB_XP: I had a time trying to figure out what exactly this mysterious v is :-)
15:12:36 <lambdabot> let v = show v in v
15:12:37 <fik> may be lisp.paste.org
15:12:37 <vincenz> Ontolog: precedence
15:12:43 <vincenz> Ontolog: putStrLN $ .....
15:12:46 <fik> wait
15:12:48 <kpreid> SamB_XP: I didn't know it changed with the input, so I was baffled by its behavior
15:12:53 <kpreid> > fix (show . Just)
15:12:54 <lambdabot>  "Just \"Just \\\"Just \\\\\\\"Just \\\\\\\\\\\\\\\"Just \\\\\\\\\\\\\\\\\\\\...
15:13:02 <LoganCapaldo> @type putStrLn (show x) ++ " factorial is " ++ (show (factorial x))
15:13:03 <kpreid> > fix (show . Just . head)
15:13:04 <lambdabot> Not in scope: `x'
15:13:04 <lambdabot>  
15:13:04 <lambdabot> <interactive>:1:48: Not in scope: `factorial'
15:13:05 <lambdabot>  "Just 'J'"
15:13:05 <gene9> type? fix
15:13:05 <vincenz> Ontolog: putStrLn $ (show x) ++ " factorial is "  ++ (show (factorial x))
15:13:08 <kpreid> > fix (show . head)
15:13:09 <LoganCapaldo> oops
15:13:10 <lambdabot>  Exception: <<loop>>
15:13:13 <vincenz> kpreid: please use private message
15:13:22 <lispy> > take 30 . map length . group . fix $ show
15:13:23 <lambdabot>  [1,1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,511,1,1023,1,2047,1,4095,1,8191,1,...
15:13:29 <vincenz> guys..it's getting spammy
15:13:30 <kpreid> vincenz: for what? I'm demonstrating, not playing
15:13:34 <kpreid> okay
15:14:01 <fik> shizzy0, paste.lisp.org/new/haskell
15:14:12 <vincenz> Ontolog: function application has tighter precedence than ++
15:14:22 <shizzy0> fik, oh, I pasted already: http://paste.lisp.org/display/30050
15:14:49 <fik> shizzy0, ok
15:14:49 <shizzy0> I thought the bot announced it.
15:15:32 <shizzy0> Thanks fik, I appreciate you looking at it.  :)
15:16:15 <vincenz> shizzy0: the AnyBody is quite obvious
15:16:41 <monochrom> Sometimes I resent lambdabot giving its answers in the channel at all.
15:16:55 <shizzy0> vincenz, what's obvious?
15:17:02 <Excedrin> /ignore lambdabot
15:17:12 <Excedrin> oops
15:17:17 <vincenz> why computeForces (Anybody a) forces = computeForces a forces doesn't work
15:17:50 <vincenz> you need to remove the AnyBody constructors from the stuff inside forces
15:18:42 <shizzy0> How?
15:18:47 <vincenz> look
15:18:50 <vincenz> for that instance
15:18:52 <vincenz> the function type is
15:19:05 <vincenz> AnyBody -> [Anybody -> (Vector, Vectp)] -> ...
15:19:16 <vincenz> and you the forces [Anybody -> (vector, vector)]
15:19:19 <vincenz> to a function taking just 'a'
15:19:48 * vincenz can't type
15:21:09 <shizzy0> Right.  So is this what I want to get to?  AnyBody -> [(Body a) => a -> (Vector, Vector)] -> [(Vector, Vector)]
15:21:48 <dons> [(Body a) => a -> (Vector, Vector)] -- seems a bit weird ..
15:21:55 <shizzy0> I don't want my force bound to AnyBody.  I want it to stick with just the class Body, so I can apply it in compositions.
15:22:13 <vincenz> dons: yeah, the existential makes it rather tough
15:22:14 <shizzy0> dons, [nods] yeah, I'm not saying that'll compile.
15:22:32 <lispy> ?type [nods] -- ;)
15:22:32 <dons> you really want a heterogeneous list of a -> (Vector, Vector) ?
15:22:33 <lambdabot> Not in scope: `nods'
15:22:47 <dons> in which case you may actually need a proper existential
15:23:01 <shapr> @seen paj
15:23:02 <lambdabot> I haven't seen paj.
15:23:05 <shapr> @seen paulaj
15:23:06 <lambdabot> I saw paulaj leaving #haskell 19d 2h 38m 38s ago, and .
15:23:06 <vincenz> @seen spj
15:23:07 <lambdabot> I haven't seen spj.
15:23:13 <shapr> @seen simonpj
15:23:14 <lambdabot> I haven't seen simonpj.
15:23:17 <shapr> @seen jaffacake
15:23:18 <lambdabot> I saw jaffacake leaving #ghc 14h 17m 33s ago, and .
15:23:26 <shapr> Ah, that's where he hangs out.
15:23:40 <dons> data T = forall a . (Body a) => T (a -> (Vector, Vector)) -- or some such
15:23:54 <gene9> @seen
15:23:55 <lambdabot> Lately, I have seen araujo, br1, dcoutts, dons, excedrin, fik, gene9, kpreid, limbic_region, lisppaste2, lispy, lleberg, logancapaldo, monochrom, samb_xp, shapr, shizzy0, tizoc, ulph and vincenz.
15:23:56 <dons> where Body is a class containing the methods for applying things of a -> (Vector, Vector)
15:24:02 <monochrom> Yes! dons's right.
15:24:04 <shizzy0> dons, ou, that looks good.
15:24:21 <dons> ?where wikibook
15:24:22 <lambdabot> http://en.wikibooks.org/wiki/Haskell
15:24:30 <dons> there's a section in there on using existentials
15:24:33 * dcoutts disapproves of @seen as it makes me prick up my ears for no reason at all
15:24:44 <vincenz> @seen dcoutts
15:24:44 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts speak 11s ago.
15:24:51 <dons> yeah, we could pad a leading space
15:24:58 <dons> but its useful to know if someone is looking for you?
15:25:03 <dcoutts> now, that's ok of course as you're looking for me
15:25:03 <monochrom> I propose data AnyBody = forall a. (Body a) => AnyBody a (a -> (Vector, Vector))
15:25:17 <dcoutts> it's just @seen on it's own that's unnecessary imho
15:25:26 <vincenz> oh!
15:25:38 <vincenz> @arr!
15:25:38 <lambdabot> Drink up, me 'earties
15:25:45 <dcoutts> @yarr!
15:25:45 <lambdabot> Aye Aye Cap'n
15:25:47 <dons> how was Fun in the Afternoon, dcoutts ?
15:25:52 <SamB_XP> dcoutts: patch your client!
15:25:53 <dcoutts> it was great
15:25:54 * shizzy0 starts typing vigorously seeing if this'll work.
15:25:54 <Excedrin> dons: stick some "invisible" sequence between the characters in @seen names so that exact match for a particular nickname won't trigger
15:26:06 <SamB_XP> dons: he said it was fun
15:26:06 <dons> Excedrin: tricky!
15:26:12 <SamB_XP> surprisingly enough
15:26:18 <vincenz> dons: not with <div>s
15:26:21 <dcoutts> SamB_XP, to do what? ignore lines containing my name and @seen?
15:26:31 <monochrom> There are actually several variations and they all work.  You could put the (a -> (Vector,Vector)) part into class Body too.
15:26:41 <dcoutts> dons, we got Phill Wadler with his lambdaman outfit :-)
15:26:50 <dons> dcoutts: any chance someone took/remember's enough details to send me a couple of sentennces on each talk, and any other transpirings?
15:26:57 <dons> oh!
15:27:02 <dcoutts> "This sounds like a job for... lambda man!"
15:27:04 * monochrom <3 existentialism types
15:27:14 <vincenz> you've got to be kidding me
15:27:26 <dons> vincenz: no!
15:27:28 <dcoutts> vincenz, I'm not joking, there are photos
15:27:33 <vincenz> dcoutts: where?
15:27:41 <dcoutts> vincenz, on peoples cameras
15:27:43 <dons> (though his secret Lambda Man identity is secret..)
15:27:50 <dcoutts> dons, ask me tomorrow when the pub effect has worn off :-)
15:27:57 <dons> ok
15:28:02 <lispy> monochrom: why is that? for me these seem to cause problems
15:28:08 <vincenz> dcoutts: dehydration is a bitchc
15:28:18 <dcoutts> dons, there was one on why C# 3.0 is a functional language
15:28:21 <monochrom> What problems does it cause?
15:28:30 <vincenz> dcoutts: I guess that got a good chuckle?
15:28:35 <dons> dcoutts: ah ha, malcolm adds bytestring support to nhc:   * add primitive implementations of h{Put,Get}Buf
15:28:40 <dcoutts> vincenz, yeah :-)
15:28:52 <lispy> monochrom: for one, it breaks deriving
15:28:56 <dcoutts> dons, and one on a more rigorous theory of patches for version control systems
15:29:09 <lispy> monochrom: and the other problems i don't remember so well...
15:29:21 <dcoutts> and another on what amounts to quickcheck for type systems
15:29:26 <shapr> dcoutts: whoa cool
15:29:51 <dcoutts> ie from the operational semantics, it tries to find counterexamples to the typing rules you've given
15:29:58 <lispy> dcoutts: is this FASE?
15:30:03 <dons> dcoutts: oh interesting.
15:30:10 <dcoutts> lispy, never heard of that
15:30:18 <lispy> hmmm
15:30:19 <dons> not using Twelf or some such?
15:30:28 <lispy> dcoutts: who wrote the version control paper?
15:30:29 <dons> i.e. not proofs on the typesystem, but counter examples?
15:30:30 <dcoutts> basically by translating into a prolog program to do bounded depth first search for counter examples
15:30:37 <dons> lispy: swiert, kosmikus (et al?)
15:30:39 <dcoutts> dons, exactly
15:30:42 <bringert> dcoutts: like this: http://www.cs.uni.edu/~wallingf/blog-images/misc/lambda-man.jpg ?
15:30:45 <lambdabot> http://tinyurl.com/ymh46u
15:30:51 <dons> ah very interesting
15:31:01 <lispy> dons: okay, i've already read it :)
15:31:06 <dcoutts> dons, yep swiert, kosmikus's paper. swiert presented.
15:31:16 <shapr> That's a good paper.
15:31:30 <lispy> heh, did lambda man talk about foozles?
15:31:30 <dcoutts> bringert, yes, but a much better photo :-)
15:31:34 <vincenz> bringert: BWAHAHA
15:31:40 <dcoutts> lispy, "links"
15:31:47 <dcoutts> a language for web programming
15:32:15 <dcoutts> a single erlang-like functional language for writing web apps that do client, server and db stuff.
15:32:19 <pkhuong-> bringert: wow!
15:32:21 <lispy> hmm... i think they had that on the old lisp machines ;)
15:32:33 <dcoutts> so links code compiles to JavaScript, server side code and SQL
15:32:43 <bringert> I just googled, I've never seen that picture before
15:32:58 <dons> bringert: oh, you should read the HWN...
15:33:07 <dons> there were photos a couple of weeks ago
15:33:12 <shizzy0> dons, so I have computeForce :: a -> Force -> (Vector, Vector)
15:33:22 <bringert> yeah, I found the link there when googling
15:33:30 <dcoutts> yeah, we say lambda man up close and in bright lighting :-)
15:33:33 <bringert> dons: I do read it, I must have missed that
15:33:36 <dcoutts> say/saw
15:33:38 <shizzy0> dons, and is the simple implementation for particle, computeForce body (Force f) = f body ?
15:33:42 <dons> bringert: ;)
15:33:52 <dons> shizzy0: I think so.
15:33:57 <gene9> @seen Cale
15:33:57 <lambdabot> Cale is in #oasis, #ghc and #haskell. I last heard Cale speak 1h 7m 26s ago.
15:34:04 <Cale> hi
15:34:27 <dcoutts> dons, btw, people were commenting at the pub after that you're a hero for doing HWN and that they can almost stop reading anything else and still keep up :-)
15:34:33 <bringert> dons: you are doing a great job with HWN, I really like it.
15:34:39 <dcoutts> heh ^^^
15:34:41 <dons> :D
15:34:41 <gene9> @seen Cale
15:34:42 <lambdabot> Cale is in #oasis, #ghc and #haskell. I last heard Cale speak 37s ago.
15:34:44 <dons> good to know.
15:34:47 <shapr> dons: Yeah, HWN is great!
15:34:49 <dcoutts> @arr
15:34:49 <lambdabot> Drink up, me 'earties
15:34:50 <lispy> dons++
15:35:18 <shizzy0> dons, oh you do that.  yeah, it's great.  I look forward to seeing it pop up on my RSS feed.  :)
15:35:25 <dons> heh
15:35:32 <dons> shizzy0: what do you read it in? which rss reader?
15:35:36 <bringert> hmm, maybe I should print HWN and put up in our department every week
15:35:41 <monochrom> I like the quotes in HWN.
15:35:42 <dons> bringert: hmm!
15:35:42 <shizzy0> dons, I read it Safari.
15:35:45 <monochrom> dons++
15:35:54 <dons> bringert: at somewhere like chalmers that actually makes sense..
15:35:58 <bringert> dons: is there a nice PDF-version or anything
15:36:06 <dons> bringert: not at the moment....
15:36:10 <dons> but if there was demand...
15:36:24 <dons> (adding new backends to the tool generator is pretty easy)
15:36:34 <dons> s/edition generator/
15:36:36 <bringert> can you subscribe to just HWN e-mails btw? maybe our FP research group mailing list would like to would like to do that
15:36:52 <dons> hmm. you could forward them from haskell@ ?
15:36:53 <SamB_XP> > 1500*3^2/10
15:36:54 <lambdabot>  1350.0
15:36:58 <shapr> bringert: rss2email?
15:37:01 <dons> ah yes
15:37:05 <dons> yeah, grab the rss feed
15:38:03 <bringert> dons: if you do make PDFs, I promise to put them up in our department
15:38:19 <lisppaste2> shizzy0 pasted "One last look at this physics problem" at http://paste.lisp.org/display/30051
15:38:22 <dons> bringert: ok. i'll see what I can do
15:38:27 <bringert> wasn't there an RSS reader that printed on toilet paper btw?
15:38:34 <dons> oh heh
15:38:40 <bringert> :-)
15:39:15 <bringert> people like to read on the toliet
15:39:37 <bringert> might as well have up-to-date stuff and then reuse the paper
15:39:45 <shizzy0> dons, so my simple implementation seems to still have an error.  I'm not good with existential types.  I made one more paste, and included my new code with your data type, and the error I'm getting from the compiler.  http://paste.lisp.org/display/30051
15:40:10 <bringert> ah, yes: http://www.djspyhunter.com/teapot/2005/12/rsstroom-reader-toilet-paper-printer.html
15:40:13 <lambdabot> Title: The Adventures of Teapot the Cat: rsstroom reader - toilet paper printer!, http://tinyurl.com/bywer
15:40:27 <gene9> Can anybody tell me how haskell is related to array languages. I'm talking about K, Q, J, APL etc. It's actually the question from my friend (he wanted to learn something from functional domain and accidentely stuck with J for a moment) and actually I would like to ask it (if it's okay here)
15:41:15 <bringert> dons: that's not what I'll do though. I'm thinking that I'll put up a "Haskell Weekly News" banner on the wall outside my office, and then post the latest issue there
15:41:48 <dons> bringert: ok. i like this idea. i'll try to whip up a nice pdf generating script
15:42:10 <dons> "office" eh? fancy schmancy ;)
15:42:14 * dons stills has his desk
15:42:26 <bringert> so where is this desk?
15:42:37 * vincenz has an office, he just shares it with 5 other people
15:42:40 <bringert> the bathroom? boiler room?
15:42:53 * bringert shares with 1-2 other
15:42:59 <bringert> I guess I would need relatively large print
15:43:11 <vincenz> bringert: we have a0 plotters
15:43:26 <dons> so one a4 sized page?
15:43:28 <bringert> well, I'm meant the individual letters :-)
15:43:33 <osser_> Reading in the bathroom has always seemed incredibly strange.
15:43:42 <vincenz> osser_: no it hasn't
15:43:48 <vincenz> well perhaps at the office
15:43:51 <bringert> dons: that would be ideal, but I guess the print would be too small
15:44:09 <dons> the announces list I suppose could be done
15:44:20 <dons> a bit like the headlines on haskell.org ?
15:44:37 <bringert> yeah, also URLs are not needed I guess
15:44:46 <osser_> Eat some colon blow.
15:44:48 <bringert> just one for were to get the full version of HWN maybe
15:44:57 <monochrom> Who is suggesting to use A0 paper for toilet paper?!
15:44:59 <dons> hmm. right.
15:46:15 <Itkovian> dons if you like refactoring code ...
15:46:17 <bringert> dons: yeah, announcements, jobs could be interesting to people about to graduate
15:46:23 <Itkovian> we can always mail you some more
15:46:37 <dons> more jobs, announcements?
15:46:58 <dons> (I'd like to see *all* jobs, announcements and *papers* ... maybe have to publicise that more widely.)
15:46:58 <bringert> ?
15:47:35 <dons> Itkovian: what did you mean by "mail you some more" ?
15:48:00 <bringert> dons: no rush, just do it if you think that it would be fun
15:48:27 <dons> right ok
15:48:40 <vincenz> dons: he wants you to write his phd
15:48:46 <Itkovian> well, just that ... we can start mailing you the code we'd like to have improved :-)
15:48:51 <bringert> dons: I'm happy with whatever you give me. Putting up the current text or HTML versions would be fine too
15:48:52 <Itkovian> I was just kidding, duh.
15:49:04 <vincenz> No you weren't
15:49:07 <Itkovian> vincenz: unfortunately my PhD is not about haskell
15:49:14 <Itkovian> vincenz: yes, I was.
15:49:15 <vincenz> Itkovian: but your tools are in haskell
15:49:17 <dons> i'd just run it through @pl and send it back...
15:49:17 <vincenz> :D
15:49:25 <vincenz> dons == pl?
15:49:32 <dons> getmail | ./lambdabot '@pl' | mailx   -- ;)
15:49:34 <bringert> I would like to help people in the department be more up to date with what's happening with haskell
15:49:42 <Itkovian> vincenz: one tool - and perhaps I will not use it for stuff I'll include in my PhD - is haskell.
15:49:44 <monochrom> It would be fun to write a refactoring server.  A beefed up DrHaskell.  Now that's a PhD waiting for someone.
15:49:47 <vincenz> Itkovian: I'm teasing
15:50:02 <Itkovian> sure ;-)
15:50:14 <Excedrin> Itkovian: what's your PhD about?
15:50:30 <Itkovian> Performance analysis of (Java) apps.
15:50:39 <dons> :}
15:50:52 <Itkovian> performance as in behaviour on a real machine
15:51:02 <dons> interesting!
15:51:23 <dons> so profiling jitted code?
15:51:26 <Itkovian> dons: yes, but the goal I really want to reach seems unattainable with what I currently can do
15:51:41 <dons> or an offline analysis?
15:51:45 <Itkovian> which is predicting performance of a given piece of bytecode + input
15:51:57 <dons> ah right. hard..
15:52:04 <dons> you could spend a phd on that
15:52:08 <Itkovian> most is offline, but we have some things we'd like to take online too
15:52:51 <SamB_XP> isn't that like the halting problem?
15:52:52 <lispy> Itkovian: are you skirting around undecidability at every turn?
15:53:27 <SamB_XP> (I say like because you not only want to know whether it halts, but if so when)
15:53:28 <Itkovian> basically you'd have a model of things you know and can compare against or relate to.
15:53:44 <dons> oh, nice! http://programming.reddit.com/info/r57w/comments
15:53:46 <vincenz> lispy: I am certain that it's limited to a certain class of applications
15:53:48 <lambdabot> Title: OpenGL programming in Haskell (reddit.com), http://tinyurl.com/ykqd57
15:53:49 <Itkovian> but that's a long way off and I should get writing soon
15:53:52 <dons> mod up guys :)
15:54:25 <vincenz> karmawhoring
15:54:27 <vincenz> dons--
15:54:38 <dons> i didn't post it...
15:54:54 <dons> vincenz: read the link before you mod me down :P
15:55:03 <shapr> dons++ -- HWN
15:55:13 <shapr> @karma dons
15:55:13 <lambdabot> dons has a karma of 87
15:55:15 <vincenz> dons: I was kidding
15:55:16 <shapr> whoa
15:55:26 <dons> oh, unlucky number
15:55:35 <SamB_XP> ?
15:55:37 <SamB_XP> how?
15:55:41 <monochrom> dons is in no danger of losing karma.
15:55:43 <astrolabe> 100 -13?
15:55:46 <SamB_XP> > factor 87
15:55:46 <lambdabot>  Not in scope: `factor'
15:55:57 <SamB_XP> L.factor 87
15:55:57 <dons> at least in .au, 100 -13 is bad for cricketers, you get out on 87 a lot
15:56:00 <SamB_XP> > L.factor 87
15:56:01 <lambdabot>  Not in scope: `L.factor'
15:56:20 <astrolabe> > 3*29
15:56:21 <lambdabot>  87
15:56:41 <BCoppens> Itkovian: ah, so when can we go to your PhD defence? :)
15:56:48 <vincenz> @karma vincenz
15:56:49 <lambdabot> You have a karma of 14
15:56:52 * vincenz sniffs
15:57:01 <Itkovian> BCoppens: After I wrote down the lot
15:57:10 <glguy> you can also just type:
15:57:11 <glguy> @karma
15:57:12 <lambdabot> You have a karma of 8
15:57:16 <astrolabe> dons has collected nearly all the karma.  There's none left for the rest of us.
15:57:22 <Itkovian> BCoppens: I hope you did figure out the lifo-2 issue this morning
15:57:24 <SamB_XP> @karma SamB
15:57:24 <lambdabot> SamB has a karma of 20
15:57:30 <SamB_XP> @karma shapr
15:57:31 <lambdabot> shapr has a karma of 25
15:57:34 <vincenz> I told you all, but you wouldn't believe me!! While you were all looking the other way, he was karmahworing!
15:57:36 <SamB_XP> shapr++
15:57:42 <shapr> dons: Hey, I'm going to have lunch with a guy tomorrow who's been on some panels at Agile Programming conferences. One of the questions he had was "how does Haskell scale up from examples to large scale applications?" Any thoughts?
15:57:45 <lispy> dons: thanks for the heads up, i put in a link to my nehe conversions
15:57:48 <glguy> astrolabe, vincenz: weren't you two doing a karma "circle jerk" yesterday?
15:57:49 <SamB_XP> @karma dcoutts
15:57:49 <lambdabot> dcoutts has a karma of 31
15:57:55 <Itkovian> BCoppens: Key was the fact that restarted and new processed get into the front of the run-queue
15:57:57 <vincenz> glguy: not me
15:57:59 <SamB_XP> dcoutts++
15:58:00 <SamB_XP> dcoutts++
15:58:01 <glguy> oh
15:58:02 <SamB_XP> dcoutts++
15:58:08 <dcoutts> SamB_XP, wtf?
15:58:12 <astrolabe> glguy: I wasn't given any karma
15:58:13 <shapr> This guy has also been the head of an XP project in Birmingham since 1998, so I figure I better have my ducks in a row.
15:58:14 <vincenz> someone is in love
15:58:20 <dcoutts> shapr, I guess we're not all that sure to be honest.
15:58:23 <dons> shapr: seems to scale well, programming in the large benefits from strong typing, strong interfaces, and compositional structures like monads
15:58:25 <SamB_XP> dcoutts: it looks way too much lower than dons' karma
15:58:33 <dons> and now with the smp runtime..
15:58:37 <lispy> is a lifo like a typo except with your life?
15:58:42 <BCoppens> Itkovian: was just returning a fixed value, right?
15:58:44 <vincenz> lispy: last in first out
15:58:51 <monochrom> haha lispy
15:58:51 <dcoutts> SamB_XP, your syntax is wrojg ;-)
15:58:56 <dcoutts> err wrong
15:58:57 <Itkovian> BCoppens: yes. If you set p->counter too.
15:59:02 <SamB_XP> dcoutts: how so?
15:59:03 <lispy> vincenz: :)
15:59:05 <BCoppens> Itkovian: yes :)
15:59:05 <Itkovian> that's what I did anyway
15:59:06 <SamB_XP> @karma dcoutts
15:59:06 <lambdabot> dcoutts has a karma of 34
15:59:09 <SamB_XP> dcoutts++
15:59:11 <SamB_XP> @karma dcoutts
15:59:11 <lambdabot> dcoutts has a karma of 35
15:59:12 <dcoutts> oh?
15:59:14 <dons> shapr: you might point out how haskell seems to do very well in the fast, agile ICFP contest :)
15:59:14 <dcoutts> oh ok
15:59:16 <shapr> dons, dcoutts: Do you know of any comparisons between objects and monad transformers?
15:59:17 <dcoutts> my mistake
15:59:21 <Itkovian> BCoppens: did you get the RR?
15:59:26 <SamB_XP> dcoutts: how did you think it went?
15:59:30 <vincenz> vincenz++
15:59:31 <vincenz> vincenz++
15:59:31 <BCoppens> Itkovian: at least I wasn't the only person who was a bit confused with lifo-2 =)
15:59:32 <vincenz> vincenz++
15:59:32 <vincenz> vincenz++
15:59:32 <vincenz> vincenz++
15:59:39 <BCoppens> Itkovian: I think so, yes
15:59:45 <vincenz> @karma
15:59:45 <lambdabot> You have a karma of 14
15:59:46 <dcoutts> SamB_XP, @karma++ <nick>, but clearly I'm wrong
15:59:47 * vincenz mutters
15:59:56 <dons> shapr: i'm not aware of comparisions, but objects are more like existentials (so typeclass-based polymorphism is a bit connected)
16:00:04 <Itkovian> BCoppens: the issue was that you have two things going on ... bash accepting the input and forking to run rmmod
16:00:05 <glguy> dcoutts: @karma++ will cause lambdabot to announce the new value
16:00:12 <SamB_XP> vincenz: see, if you use the silent form it doesn't give you nasty messages
16:00:20 <vincenz> SamB_XP: I know
16:00:23 <BCoppens> Itkovian: comparing p with prev->next_task if prev->counter == 0, and then setting the counter
16:00:27 <lispy> i tihnk it's just one + on @karma+
16:00:29 <SamB_XP> also, the noisy form is
16:00:32 <SamB_XP> @help karma+
16:00:33 <lambdabot> karma+ <nick>. Increment someone's karma
16:00:36 <vincenz> @karma++
16:00:37 <lambdabot> You have a karma of 14
16:00:43 <shapr> dons: Can you explain that more?
16:00:46 <SamB_XP> @help karma++
16:00:46 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:00:48 <dcoutts> shapr, we were talking about this this evening. We covered the relation between OO and parametric polymorphism and existentials
16:00:49 * shapr thinks
16:00:54 <shapr> dcoutts: oh oh tell me more!
16:00:57 * shapr boings!
16:01:00 <dcoutts> but not monads really
16:01:00 <BCoppens> Itkovian: yeah
16:01:17 <vincenz> dcoutts: yeah ok but the question is whether it is expressive
16:01:20 <SamB_XP> anyway, I wrote the filter myself, so I should know ;-)
16:01:28 <SamB_XP> dons did hack it a fair bit afterwards, though
16:01:30 <shapr> Monad transformers feel like OO inheritance hierarchies to me.
16:01:32 <monochrom> shapr, dons: try  data O = forall a. O a (a -> Bool)
16:01:36 <shapr> Except, with less pain.
16:01:56 <SamB_XP> one of us had to make it quieter when the #perl6 folks complained of the noise from nick++ style...
16:02:08 <Itkovian> dcoutts: isn;t there something like that in the erm ... Pierce book (Types and Programming Languages?)
16:02:12 <dcoutts> shapr, well many examples of OO translate into algebraic data types, then may others trnalsate into parametric polymorphism, in a few cases you need existentials or records of methods and in a very minor number it does look like you genuinely need subtyping.
16:02:35 <vincenz> dcoutts: the advantage of non statically typed OO languages, however, is ducktyping, which gives you a lot looser coupling
16:02:39 * bringert just e-mailed the CS furniture manager (translated crazy swedish title) asking for a notice board for HWN
16:02:43 <dons> oh, and Cale did post:
16:02:44 <dons> http://programming.reddit.com/info/r2xp/comments
16:02:45 * dcoutts hates ducks
16:02:45 <dons> good!
16:02:48 <lambdabot> Title: Major typeclass overhaul in Haskell GHC (reddit.com), http://tinyurl.com/y46s3u
16:02:49 <shapr> vincenz: Ducktyping looks like typeclasses to me.
16:02:52 <dons> bringert: great!
16:02:53 <vincenz> dcoutts: even the peking kind?
16:03:01 <SamB_XP> I think duck tastes good if it is cooked right
16:03:07 <dcoutts> vincenz, well I don't eat them either :-)
16:03:26 <Cale> shapr: only much less safe? :)
16:03:29 <vincenz> I fear that for bigger apps, haskell might not scale as well
16:03:33 <SamB_XP> vincenz: ah, yeah, thats the way to cook them ;-)
16:03:33 <vincenz> mostly for biz apps
16:03:42 <shapr> Python has had ducktyping forever, "This method accepts a file-like object that must implement these methods:..." and typeclasses are just like that, with more guarantees.
16:03:46 <lispy> shapr: duck typing is essentially admiting that two different types which share an interface can be used interchangably
16:03:50 <bringert> "If it looks like a duck and tastes like a duck, then it might well be a duck"
16:03:53 <shapr> vincenz: Why scale not?
16:04:00 <shapr> lispy: yes!
16:04:01 <vincenz> but /me >>= bed
16:04:01 <dons> vincenz: have you written any big ones? seems to work fine for ghc (200k), bluespec (100k) , and there must be some big things at galois and credit suisse now
16:04:08 <SamB_XP> lispy: no it isn't
16:04:09 <shapr> vincenz: Oh c'mon, you can't say that and then disappear!
16:04:10 <lispy> shapr: sounds like type inference to me!
16:04:12 <vincenz> dons: these are algorithmic intensive apps
16:04:19 <shapr> SamB_XP: That's not ducktyping?
16:04:24 <vincenz> dons: I was talking about biz-apps
16:04:26 <SamB_XP> ducktyping is when, instead of typechecking, you duck
16:04:32 <Itkovian> vincenz: so what are you referring to then?
16:04:33 <SamB_XP> ;-P
16:04:34 <shapr> SamB_XP: argh!
16:04:36 * SamB_XP ducks
16:04:38 <shapr> vincenz: Yeah, I wanna know
16:04:42 <bringert> GF is 61 KLOC
16:04:51 <dons> pugs is up near 30k these days
16:04:53 <vincenz> not now, I'd have to reflect my thoguhts and I want to sleep
16:04:56 <astrolabe> GF?
16:04:57 <shapr> vincenz: bah
16:04:59 <vincenz> I'll expand on it sometime
16:04:59 <shapr> @where gf
16:05:00 <lambdabot> http://www.cs.chalmers.se/~aarne/GF/
16:05:03 <vincenz> or put it in a blog
16:05:05 <vincenz> so I can get a lot of hatemail
16:05:18 <shapr> vincenz: I just want to know what you think. You're not stupid :-)
16:05:22 <dons> vincenz: what's your intuition though?
16:05:32 <SamB_XP> maybe he hasn't figured out what he thinks yet ;-)
16:05:40 <shapr> Yeah, I have that problem lots.
16:05:43 <vincenz> my intuition is that you a) you become too rigid, b) you get a serious overhead in conversion of different data bits
16:05:45 <Itkovian> I recon it needs some thought
16:05:51 <bringert> Although Lolita currently exhibits only modest parallelism, we believe that it is the largest parallel functional program ever, comprising more than 47,000 lines of Haskell.
16:05:59 <SamB_XP> vincenz: personally, I would be more worried about compile time
16:06:06 <vincenz> c) for the not so static stuff like GUI etc, you don't scale as well
16:06:09 <dons> bringert: hmm!
16:06:12 <bringert> eh, that's missing ""'s
16:06:24 <astrolabe> how big is ghc?
16:06:31 <Itkovian> vincenz: I thought functional -like languages excelled at GUI stuff
16:06:32 <shapr> dons just said 200kloc
16:06:32 <dons> 200k or so
16:06:34 <bringert> dons: they're they guys who wrote Control.Parallel.Strategies
16:06:38 <dons> ah right
16:06:49 * astrolabe should concentrate more.  thanks.
16:06:58 <vincenz> Itkovian: imho guis are inherently oo, and compilers are inherently fp
16:07:22 <bringert> wasn't someone talking about assembling a corpus of haskell programs to find out what features people use etc?
16:07:26 <dons> vincenz: yeah, you'd want to find some experimental evidence on that. guys like the linspire people are reporting the opposite, in terms of maintainability in the long term, and interacting with lots of different data formats
16:07:27 <bringert> at HW maybe
16:07:35 <dons> becomes easier once you can type all the different formats
16:07:37 <vincenz> dons: just giving you my intuition
16:07:40 <shapr> I haven't used monad transformers long enough in a large enough program to have much intuition about how they compare to OO hierarchies. But the little bit I have says monad transformers are easier to deal with.
16:07:42 <dons> and changes don't break things, they report type errors
16:07:43 <lispy> it does seem that guis are writtable in OO with good success...but that doesn't exclude FP from being good at it also
16:07:56 <dons> the gui thin, maybe. don't know.
16:08:04 <dons> don't have a sense either way
16:08:08 <lispy> bringert: yeah at HW, it was during a discussion of cabal-install
16:08:12 <dons>  dcoutts probably has some experience with big guis
16:08:20 <dcoutts> well, medium
16:08:22 <astrolabe> shapr: I heard monad transformers are a pain if you want to change them around.  What do you think?
16:08:32 <dons> that's true.
16:08:33 <tobbes> has anybody had any experience in proving properties of programs?
16:08:33 <monochrom> A widget is a monad...  Hmm!
16:08:44 <vincenz> anywho
16:08:45 <dcoutts> dons, oh, btw Jeremy said that he'd be happy to vouch for us, so I'll talk to the admin folk tomorrow.
16:08:46 <shapr> astrolabe: I'd guess that the pain is limited to the stack you're changing, not to all stacks.
16:08:48 <lispy> or maybe hackage
16:08:52 <vincenz> now that I got my fingers burned, may I go to sleep?
16:08:52 <dons> dcoutts: oh great!
16:08:56 <tobbes> I'm trying to prove that sum(rev(xs)) == sum(xs).
16:09:09 <shapr> So that feels like a separate class hierarchy.
16:09:13 <monochrom> induction on xs, can you do that?
16:09:17 <astrolabe> vincenz: mind the bugs don't bite.
16:09:20 <dcoutts> tobbes, induction
16:09:21 <lispy> tobbes: what is rev?
16:09:23 <Itkovian> vincenz: night
16:09:30 <vincenz> cya
16:09:38 <tobbes> but I get stuck with sum(rev(xs) ++ [x]) = sum(xs)+1
16:09:43 <tobbes> reverse
16:09:48 <vincenz> dons: don't get me wrong I prefer fp, just at times I wonder about scalability to ultra big is all
16:09:51 <shapr> Except that this hierarchy is directly executable. Class hierarchies are not, they just produce instances.
16:09:57 <lispy> tobbes: why the +1?
16:10:03 <vincenz> dons: or moving the results that are out there to less algorithmic intensive apps
16:10:10 <shapr> So I'd guess that makes monad transformers closer to executable specifications.
16:10:18 <shapr> Admittedly, only one step closer, but...
16:10:18 <tobbes> by definition of err sorry +x
16:10:27 <lispy> vincenz: so what is the largest FP program we know of?
16:10:32 <vincenz> lispy: ask dons
16:10:45 <lispy> dons: so what is the largest FP program we know of?
16:10:54 <tobbes> the problem is I don't seem to be able to simplyfy the RightHandside
16:11:09 <monochrom> Induction hypothesis: sum(rev(xs))=sum(xs). Don't forget that.
16:11:11 <shapr> What about the InForM workbench? It's a leviathan.
16:11:18 <tobbes> yes
16:11:36 <lispy> vincenz: i think it gets kinda muddled...OO programs tend to be very large, but FP programs that do the same amount of work tend to be much smaller...this alone is a win when things are getting complex
16:11:46 <monochrom> Another thing you need is a property sum(ys ++ [x]) = sum(ys)+x.  Another induction proof.
16:11:47 <dcoutts> tobbes, perhaps you need a lemma about sum (xs ++ [x]) = sum xs + x
16:11:50 <shapr> er, the UniForM workbench
16:11:57 <vincenz> lispy: that's a large claim
16:12:04 <tobbes> but I can't swap rev(xs ++ [x]) to sum(xs).
16:12:30 <shapr> lispy: Have you seen "Are Ours Really Smaller Than Theirs?"
16:12:38 <lispy> shapr: nop
16:12:59 <shizzy0> It works!  Thank you, dons.
16:13:03 <shapr> @google Are Ours Really Smaller Than Theirs? simon booth
16:13:07 <lambdabot> http://citeseer.ist.psu.edu/booth96are.html
16:13:21 <monochrom> sum(rev(xs) ++ [x]) =lemma you have to prove= sum(rev(xs)) + x =induction hypothesis= sum(xs)+x  is this clear?
16:13:29 <shizzy0> Here was the final data type that I had to define, data Force = Force (forall a. (Body a) => (a -> (Vector, Vector)))
16:14:01 <lispy> heh, what is it about the same simon and FP :)
16:14:08 <lispy> er name not same
16:14:54 <tobbes> monochrom no, sorry :)
16:15:06 <shapr> @google software metrics measuring haskell ryder
16:15:09 <lambdabot> http://www.cs.kent.ac.uk/pubs/2005/2249/index.html
16:15:09 <lambdabot> Title: Computer Science: Publication: Software Metrics: Measuring Haskell
16:15:32 <monochrom> Sigh.  sum(ys ++ [x]) = sum(ys) + x   this is a new lemma you have to prove by induction.
16:15:48 <tobbes> yes
16:15:50 <shapr> dons: Oh hey, there *must* be some direct connection among spigot algorithms and worst case data structures. Do you already know of such a connection?
16:15:54 <dons> lispy: the largest FP programs are probably the big erlang things at ericsson? the 2M+ ones.
16:15:58 <dons> or something in lisp?
16:16:02 <monochrom> Applying this lemma allows you to decompose sum(rev(xs)++[x]) = sum(rev(xs)) + x
16:16:53 <shapr> Maybe I should ask dcoutts since he's worked with Oege de Moor?
16:17:01 <shapr> Maybe I should go finish my work? =)
16:17:06 <lispy> dons: i dunno about lisp, it's a very golfable language due to macros and hofs
16:17:07 <dcoutts> shapr, what's that?
16:17:44 <lispy> dons: the largest lisp application i worked on was something like 80kloc
16:17:51 <dcoutts> shapr, I know nothing about spigot thingies :-)
16:18:03 <Itkovian> night all
16:18:04 <lispy> dcoutts: does FP scale?
16:18:08 <lispy> dcoutts: that's the topic
16:18:14 <dcoutts> dons, the problem is that ours really are smaller than theirs :-)
16:18:19 <astrolabe> night
16:18:23 <lispy> dcoutts: and we want to find instances of rather large FP programs
16:18:31 <dcoutts> so it makes it look like we're tackling small problems
16:18:36 <dons> I think erlang shows that FP scales.
16:18:44 <dcoutts> yeah, that's true
16:18:49 <astrolabe> loc is a crappy measure of course
16:19:08 <dons> and C++ shows something else
16:19:09 <lispy> astrolabe: agreed, darcs is an example of that
16:19:21 <tobbes> because rev(xs) ++ [x] = x:rev(xs) ?
16:19:28 <lispy> darcs is very concept dense and featureful, but realatively few lines of code
16:19:31 <dons> what's that quote about the internet littered with 100k C++ programs that became unmaintainable?
16:19:48 <osser_> That anything scales if you hit on it hard enough, long enough.
16:19:50 <shapr> dunno, but it's probably right
16:19:59 <shapr> osser_: even asm?
16:20:12 <dcoutts> shapr, WordPerfect 5.1 ?
16:20:18 <osser_> If you hate yourself?
16:20:28 <lispy> shapr: good organization and human stubbornness goes a long ways :)
16:20:44 <shapr> I should mention my favorite research paper again...
16:20:46 <osser_> Humans will build abstractions out of water if they have to.
16:21:12 <shapr> My favorite research paper of all time: http://alistair.cockburn.us/index.php/Characterizing_people_as_non-linear,_first-order_components_in_software_development
16:21:13 <lispy> i recon that any sufficiently large application develops its own language and endsup being extended in that once you reach a certain threshold
16:21:15 <lambdabot> http://tinyurl.com/y4qmjx
16:21:32 <shapr> lispy: domain specific languages...
16:21:39 <astrolabe> There's a chap at my work learning haskell because of me.  I feel a bit guilty -- like a pusher.  Once you've used type inference, lambda abstractions etc. it is hard to do cold turkey.
16:22:04 <shapr> astrolabe: maybe you're not pushing drugs, but instead pushing a cure?
16:22:23 <monochrom> drugs cure.
16:22:24 <osser_> It's more like pushing torment when you have no choice what you work in.
16:22:29 <dons> it was interesting at the Google SoC summit to hear from the Zope guys
16:22:34 <shapr> dons: oh?
16:22:46 <shapr> Zope is nice. Plone is not.
16:22:50 <astrolabe> shapr: but in the real world, we (at my work) are all going to have to do a lot of C++.
16:23:01 <dons> apparently (is it php?) they grew so fast and accepted so many patches (without tests) that they had to give up and rewrite from scratch. the codebase became just that unstable
16:23:08 <dons> now you have to provide tests with every patch
16:23:11 <astrolabe> shapr: I like the title :)
16:23:27 <monochrom> At the end of the day I think it'll come down to this.  FP doesn't scale for biz apps because there are not enough FPers.
16:23:45 <dons> i think that would be less likely to happen with a strongly typed language, and a pure one, since a wide class of bugs won't get in and start making things unstable
16:23:55 <SamB_XP> monochrom: there are more FPers than you know
16:23:56 <shapr> I think it's silly to specify a programming language for a project. The project should be to find the (domain specific) language and then specify it.
16:23:57 <dons> language support for less bugs scales well
16:24:05 <osser_> I think there's really not a lot of evidence to make any generalizations.
16:24:11 <monochrom> That doesn't contradict my claim.
16:24:51 <dons> there weren't any java hackers 10 or so years ago, now there's too many
16:24:54 <dons> its just the market
16:25:15 <osser_> Making large programs takes time and people, which requires money, which isn't spent on making "biz apps" in fp languages.
16:25:35 <shapr> I'm getting paid to write a biz app in an fp language.
16:25:37 <dons> the FP coprorate alliance might help a bit in encouraging people to think they'll need FP for at least some jobs
16:25:37 <SamB_XP> monochrom: well, it makes it hard for you to validate your claim
16:25:47 <monochrom> Right.
16:26:15 <monochrom> Here is a revised one.  There are not enough abstract programmers.
16:26:16 <shapr> Speaking of which... I should pull my ethernet cable and get back to coding...
16:26:40 * lispy too but i'm using wireless :(
16:26:49 <lispy> i can't help it! the signal finds me!
16:26:53 <wilx> Pull the ether!
16:27:05 <monochrom> Hmm that's a hard one.
16:27:16 <monochrom> How about EMPing yourself :)
16:27:28 <osser_> Ok.
16:27:30 <shapr> osser_: Anyway, money is being spent to make biz apps in fp languages, just not as much as is being spent to write biz apps in PHP,C++,Java, etc
16:27:36 <monochrom> Oh why am I always thinking hi-tech solutions?  Just throw the computer on the floor.
16:27:51 <monochrom> Oh wait you still have to code...
16:28:23 <osser_> There just isn't any large-scale investment for large-scale codebases.
16:28:51 <osser_> So you can't make any conclusions because there's not really any evidence.
16:29:07 <shapr> There is evidence, it's just hard to interpret :-)
16:29:14 <tobbes> #haskell.se
16:29:50 <SamB_XP> monochrom: while you may be right that there aren't enough, there are probably enough for the next few companies!
16:30:11 <SamB_XP> at least for seeder populations
16:30:32 <SamB_XP> if they are willing to employ some 5-year-olds on a temporary basis
16:32:02 <shapr> osser_: What are your thoughts on these? http://citeseer.ist.psu.edu/hudak94haskell.html http://citeseer.ist.psu.edu/booth96are.html http://www.cs.kent.ac.uk/pubs/2005/2249/index.html
16:32:06 <lambdabot> http://tinyurl.com/eogz7
16:33:54 <osser_> I've only read the second, but I do not think that it addresses the specific issue of whether fp is suited for large-scale "biz apps" or not.
16:34:49 <shapr> How do you think that should be addressed?
16:34:54 <shapr> Like, what should be compared?
16:35:17 <osser_> I guess the most effective means would be by construction of such tasks specifically in study.
16:35:40 <osser_> So as to basically push aside the ever-present hand-waving.
16:36:26 <shapr> Part of the problem is that if you got the Simons, Hudak, Hughes, and that sort of people together, then the study would clearly be biased.
16:36:38 <shapr> It would likely conclude that Haskell should rule the world =)
16:36:52 <shapr> But a bunch of beginners might end up with the opposite conclusion.
16:37:17 <shapr> I don't see how you can get around the hand-waving. The human element is always there.
16:37:17 <osser_> Setting up any useful experiment would probably cost a lot of money.
16:37:34 <dcoutts> lets just make loads of cash instead
16:37:58 <shapr> I like it!
16:38:02 <shapr> 1. FP
16:38:04 <shapr> 2. ...
16:38:08 <shapr> 3. Profit!
16:38:10 <emu> woot
16:38:11 <dcoutts> precisely :-
16:38:38 <emu> :- Ax.FP -> x -> Profit
16:38:42 <dcoutts> shapr, problem is that: 2. lot of time and effort
16:38:48 <shapr> dcoutts: I'm okay with that.
16:39:17 <shapr> When Haskell becomes the next big thing, I'll probably move on to Epigram or something.
16:39:40 <osser_> You'll have to wait a while.
16:39:44 <shapr> I doubt it :-)
16:39:46 <ralf`> hi shapr
16:40:00 <shapr> hi ralf`
16:40:06 <osser_> The jargon entailed in the haskell world scares away the unmotivated.
16:40:30 <osser_> The come for the pugs and leave =]
16:40:35 <chessguy> is it haskell's strong typing that doesn't allow you to have a list like [1,2,[3,4]] or is it something else?
16:40:40 <dons> oh, that's interesting. you mean the technical terminology?
16:40:50 <dons> so instead of sigils we hvae typeclasses? :)
16:40:52 <robreim> That's when turning words like "monad" into marketing terms can have a positive effect
16:40:56 <astrolabe> chessguy: yes
16:41:01 <shapr> osser_: I dunno, have you seen the number of monad implementations that exist in random proglangs?
16:41:13 <astrolabe> (the first)
16:41:17 <dons> chessguy: yeah, type inference: find a most general type for that expression
16:41:22 <osser_> Scheme and O'Caml
16:41:36 <ralf`> chessguy: you can have a list like that, but it would be a list of type listOrInt where type listOrInt = Int | [Int]
16:41:42 <ralf`> I think.
16:41:43 <shapr> osser_: http://lambda-the-ultimate.org/node/1136
16:41:44 <chessguy> i'm learning scheme for this stupid class i'm in, and it's really ugly, but it does let you have mixed lists
16:41:44 <lambdabot> Title: Collection of links to monad implementations in various languages. | Lambda the  ...
16:41:54 <dons> shapr: oh its much more than that now: http://haskell.org/haskellwiki/Monad#Monads_in_other_languages
16:41:57 <lambdabot> Title: Monad - HaskellWiki, http://tinyurl.com/y2fdhw
16:42:07 <lispy> "If people could just act consistently, they could keep their desks clean, avoid cavities, lose weight, give up smoking, play a musical instrument, and possibly even produce software on a regular and timely basis."
16:42:16 <dons> All your monads belong to us
16:42:18 <osser_> Though I don't just mean monads, though that's a start. The literature on the whole related to haskell is not exactly approachable to those that chat on slashdot about those "cs topics" like "big o notation"
16:42:38 <lispy> chessguy: lisp is not ugly! ;)
16:42:41 <astrolabe> lispy: you've got further than me :)
16:42:42 <osser_> Not to sound like an elitest or anything, you just have to realize a lot of people are going to be intimidated away once their interest is piqued.
16:42:44 <shapr> osser_: How so? Like what?
16:42:46 <chessguy> bleah
16:42:51 <dons> osser_: yep. programming languages are hard to get right, so rigour and precisoin is important. otherwise you end up with php
16:43:06 <chessguy> way too many parentheses. they at least need a $
16:43:11 <dons> making this easier for people is an important goal
16:43:13 <ralf`> chessguy: scheme is pretty fun.  Have you browsed sussman's "The Structure and Interpretation of Computer Programs"? (SICP)
16:43:26 <emu> chessguy: use emacs
16:43:33 <chessguy> ralf`, sure, but any of that can be done in haskell
16:43:34 <shapr> osser_: In my experience, whatever people come for, they stay for the community.
16:43:42 <ralf`> chessguy: Maybe you could write a compiler in Haskell which takes the $ format and makes it pure parens and sends it to the scheme interpreter.
16:43:47 <chessguy> and probably more easily
16:44:01 <astrolabe> I've heard it said that eventually your brain parses the parentheses, and you don't see them.
16:44:16 <emu> parentheses in scheme/lisp do not mean the same thing they mean in other programming languages
16:44:22 <chessguy> but you still have to write them
16:44:23 <emu> do not interpret them the same way
16:44:24 <dons> astrolabe: oh interesting. i think that must be true
16:44:35 <ralf`> astrolabe: not without a text editor helping you ;)
16:44:37 <emu> then you will not be confused
16:44:39 <LoganCapaldo> (defmacro (with-dollars ....)  (with-dollars f $ g $ x ) ;)
16:44:41 <rahikkala> (troll "If Haskell used sexp syntax, Template Haskell would long since have been ready... in fact, we wouldn't even need it since we would have a simpler macro facility")
16:44:47 <robreim> Yeah, the parentheses grow on you after you code in lisp after a while. Macros in particular make you pretty fond of them.
16:45:03 <shapr> rahikkala: ei ole!
16:45:19 <chessguy> we haven't talked about macros for scheme yet
16:45:24 <dons> ?users #haskell.fi
16:45:25 <lambdabot> Maximum users seen in #haskell.fi: 11, currently: 11 (100.0%), active: 0 (0.0%)
16:45:27 <dons> ?users #haskell.se
16:45:28 <lambdabot> Maximum users seen in #haskell.se: 12, currently: 11 (91.7%), active: 4 (36.4%)
16:45:31 <dons> ?users #haskell.no
16:45:32 <lambdabot> Maximum users seen in #haskell.no: 3, currently: 1 (33.3%), active: 0 (0.0%)
16:45:37 <dons> ?users #haskell.de
16:45:37 <lambdabot> Maximum users seen in #haskell.de: 5, currently: 3 (60.0%), active: 1 (33.3%)
16:45:40 <shapr> rahikkala: But seriously... how would you build an HM type-safe templating system on top of lambda cal?
16:45:51 <Botty> better yet, write it in scheme and then bootstrap
16:45:52 <emu> frankly, the precedence issues in Haskell make defensive use of parentheses necessary. at least in lisp, the rules are simple.
16:45:55 <rahikkala> shapr: I have no idea, that's why I specified that that was a troll :)
16:46:02 <shapr> heh ok
16:46:04 <Botty> err, /me was scrolled up, nevermind
16:46:28 <osser_> Actually I do recall reading this first study for the Navy, but it was a really long time ago.
16:46:42 <robreim> Actually, scheme's standard macros don't seem to make a lot of use of the lisp structure due to trying to be referentially transparent. I'm not really sure what the advantage of brackets in scheme might be...
16:46:43 <Botty> emu - I don't like parenthesis counting, that's my problem with lisp
16:46:44 <osser_> Which makes me feel old and senile.
16:46:48 <emu> Botty: use emacs
16:46:58 <robreim> s/lisp structure/list structure/
16:46:59 <shapr> osser_: Are you older than me?
16:47:02 <emu> who the fuck would count parentheses in this day and age. or for the last 30 years.
16:47:06 <osser_> I don't know, how old are you?
16:47:20 <emu> use emacs and learn to use M-( and M-) too, to really be enlightened
16:47:23 <chessguy> just because you have a parentheses-matching IDE, doesn't make it much less annoying to see ))))))) everywhere
16:47:32 <shapr> osser_: I'm 35
16:47:38 <osser_> Nope.
16:47:44 <robreim> yeah, I appreciate lisp's prefix notation over infix precedence rules...
16:47:50 <Botty> emu - yeah, but emacs is fucking retarded, if were going to prophanatize
16:47:53 <emu> chessguy: when you realize the benefits of the structure that parentheses provide, you learn to really love it
16:47:59 <emu> Botty: vim works too
16:48:01 <osser_> Though obviously my paper-recollection skills are inferior =]
16:48:15 * Botty doesn't like any text editor that looks like crap
16:48:19 <emu> Botty: for being "fucking retarded", emacs still outdoes every other editor/IDE pretty much
16:48:22 <shapr> osser_: Nah, you probably just do productive stuff instead of obsessive paper reading :-)
16:48:22 <chessguy> you can learn to appreciate prefix notation, or you can use haskell which allows you to do either infix OR prefix
16:48:29 <Botty> and requires you to use wierd ass keycodes to do things
16:48:36 <shapr> Botty, emu: emotional declarations can't be unit tested!
16:48:47 <emu> Botty: dude.  get RSI, then you will learn to love the keycodes.;
16:48:52 <dons> ?remember knuth We will perhaps eventually be writing only small modules which are identified by name as they are used to build larger ones, so that devices like indentation, rather than delimiters, might become feasible for expressing local structure in the source language. ["Structured Programming with goto Statements", Computing Surveys, Vol 6 No 4, Dec. 1974]
16:48:55 <emu> mouse == bad for wrist
16:49:01 <shapr> That was tactful for, holy wars on #haskell-blah please
16:49:03 <dcoutts> quickcheck (\x -> vim x >= emacs x)
16:49:08 <Botty> shapr : he, yeah /me was making fun of his dirty little moutgh
16:49:23 <dons> Extra extra: knuth advocates haskell's layout in 1974!
16:49:34 <dcoutts> heh, got a ref?
16:49:36 <Botty> emu - so, you can get RSI doing the same keycodes over and over
16:49:43 <shapr> Botty: dude, chill
16:49:50 <dons> its Donald E. Knuth, "Structured Programming with goto Statements", Computing Surveys, Vol 6 No 4, Dec. 1974
16:50:10 <osser_> A little of both, but unfortunately my memory works more in approximations than precision.
16:50:16 * dcoutts apologises to shapr for mentioning v*&e*
16:50:38 <osser_> After I read a bit I remembered it.
16:50:44 <shapr> dcoutts: I use both vim & emacs. I don't think they're each good at different stuff.
16:50:45 <povman> n00 i neeeeed hs-plugins
16:50:51 <shapr> er wargh
16:50:52 <dons> povman: for what?
16:50:57 <dcoutts> shapr, I use two editors too
16:51:02 <emu> i also use both vim and emacs.  they both have the right idea.
16:51:03 <shapr> um "Each tool has its own good points, use whatever fits your own head."
16:51:09 <dons> let's talk about lambdas... please!
16:51:10 <povman> for dynamicaly loadable code
16:51:15 <dons> povman: ok . good.
16:51:20 <dons> you know where to get it?
16:51:22 <shapr> dons: Is hs-plugins working with ghc 6.6?
16:51:26 <dons> not yet....
16:51:32 <shapr> When do you expect it?
16:51:34 * dons needs a team of flying code monkeys
16:51:35 <shapr> hah
16:51:38 <povman> oh you're the author
16:51:42 <dons> within dyas
16:51:45 <dons> povman: yep
16:51:46 * shapr wants to join the flying code monkey brigade
16:51:51 <lollan> ehat is IFCP ?
16:51:51 <robreim> dons: I'll be a code monkey if it'll help pump hs-plugins out quicker
16:51:57 <lollan> ehat is ICFP sorry ?
16:51:59 <dons> fly my pretty, fly!
16:52:01 <shapr> Now, who can make a logo for the Flying Code Monkey Brigade?
16:52:02 <ralf`> emu: what's rsi?
16:52:04 <povman> yes, i was complaining because i don't want to compile ghc 6.4 again :p
16:52:05 <Botty> I suppose i should give the two a shot, but the codes that don't make any sense repulse me.  Stuff that actually matches what you want it to do would be nice - like Ctrl S for save, etc
16:52:20 <dons> povman: 6.4.2 should be ok
16:52:26 <povman> i have 6.6
16:52:26 <shapr> Botty: Your definition of sense is windows-centric.
16:52:27 <emu> how about Ctrl S for incremental search, something you do a lot more often :P
16:52:39 <ralf`> How do you get the hang of vim?  I keep trying it, but I can never get a handle on it?
16:52:43 <astrolabe> lollan: international conference on functional programming.  and google is your friend :)
16:52:43 <emu> vimtutor
16:52:44 <dons> povman: yep, so hs-plugins hasn't been ported to the new 6.6 .hi file format
16:52:50 <povman> i know
16:52:50 <emu> ralf`: repetitive strain injury
16:52:51 <Botty> shapr - probably, though i've been using linux mostly for about a year
16:52:52 <povman> :'(
16:52:53 <ralf`> I still can't even cut and paste.
16:52:55 <dons> are you using it in a project? if so, which proejct?
16:52:58 <dcoutts> dons, I was sitting in an OOP practical the other day. It about hacking features into a console mode line editor, like yi+curses. (It's on Java of course) It was getting me thinking about a Data.Rope based on a Data.Sequence of ByteStrings, possibly augmented with a string builder for sequences of insertions.
16:53:02 <emu> ralf`: look up the d and p actions
16:53:10 <emu> and y for copy
16:53:14 <povman> dons: http://azzor.homelinux.net/doku.php?id=rol:game
16:53:17 <dcoutts> dons, so you get a persistent editor buffer, so undo becomes easy
16:53:17 <lambdabot> Title: rol:game [BrainDumpWiki], http://tinyurl.com/ykfd6h
16:53:25 <shapr> Botty: emacs has a plugin to do that flavor of windows bindings. I don't know if vim does also.
16:53:39 <povman> ok so, i PROBABLY need hs-plugins.
16:53:42 <emu> cua-mode, however, you'll find  you're missing out on a lot by doing that
16:53:50 <shapr> dcoutts: oh COOL
16:53:52 <satan> hello all
16:53:54 <Botty> shapr - just because windows uses Ctrl-S doesn't mean that it's a bad idea...
16:53:59 <resiak> dcoutts: This sounds similar to a talk Sufrin gave about a year ago on the perfect text editor...
16:54:06 <Botty> not to mention nearly all linux gui apps
16:54:11 <dcoutts> resiak, oh yeah? I missed that.
16:54:13 <emu> Botty: it is a bad idea; C-s is an easy to hit key-chord, shouldn't be wasted on non-common operations
16:54:16 <shapr> Botty: No, I didn't say that. I said that your definition of sense is based on windows experience, that's all I meant.
16:54:20 <satan> am i correct in thinking that foldr (:) [] (x:xs) is equivalent to x: foldr (:) [] xs ?
16:54:21 <shapr> emu: dude, chill out.
16:54:23 <resiak> dcoutts: I'll see if I can find the paper he based it on tomorrow
16:54:26 <dons> povman: ok. let me know if you want any advice on it.
16:54:27 <dcoutts> dons, presumably you use an explicit history of editor commands with inverses.
16:54:32 <dcoutts> resiak, ta.
16:54:36 <shapr> emu: 'bad' cannot be unit tested.
16:54:51 <dons> dcoutts: hmm. interessting
16:54:56 <shapr> emu: I see what you mean about non-common operations, but everybody got their own approach.
16:55:05 <emu> you can measure ease of use and usage patterns quantitatively
16:55:11 <povman> dons: thanks. i just needed to vent before installing ghc 6.4.2 :D
16:55:15 <dons> :)
16:55:19 <dons> povman: you in sydney?
16:55:24 <povman> canberra
16:55:26 <emu> well, in any case, you can rebind the keys to whatever you want
16:55:28 <dons> oh, ANU?
16:55:31 <povman> yeah
16:55:32 <shapr> emu: And in fact, I asked delYsid to write just such a bit of elisp for me...
16:55:36 <lollan> thanks astrolabe
16:55:42 <Botty> shapr - dunno, i suppose....  I've had experience with lots of OSes though.  I suppose something like not having to hold ctrl (or any other initiation key) would be nice
16:55:50 <kpreid> @check \xs -> foldr (:) [] xs == xs
16:55:51 <lambdabot>  Add a type signature
16:55:57 <dcoutts> dons, so possibly that'd give you a purely functional editor, as a function from a sequence of editor commands to a sequence of editor states.
16:56:00 <emu> Botty: vim users tend to be those who don't want to hold down chord keys and such
16:56:01 <kpreid> @check \xs -> foldr (:) [] xs == (xs :: [Int])
16:56:03 <lambdabot>  OK, passed 500 tests.
16:56:09 <kpreid> satan:
16:56:13 <dons> povman: you know Ben Lippmeier?
16:56:24 <lollan> astrolabe: for little question like that, I prefer ask to people, it makes e feel like IRC is not only about programming but also about speaking with each other
16:56:31 <shapr> Botty: Both emacs and vim have advantages to their approaches. Another approach is outlined in Jef Raskin's 'The Humane Interface' book. Each of those is worth knowing about in my opinion.
16:56:32 * Botty assumed you didn't actually have to hold the S-s or whatever it is
16:56:33 <emu> (I rebind Caps Lock to Control, which helps a lot)
16:56:43 <povman> dons: yeah
16:56:45 <emu> yes, Raskin's book is great
16:56:48 <Botty> shapr - ok, I'll look into it..
16:56:53 <emu> it's about interface design in general
16:56:56 <povman> i have no idea what he's doing though
16:56:59 <dons> povman: oh cool. i met him on saturday :)
16:57:01 <Botty> Must be something to it, so many intelligent people swear by em
16:57:06 <satan> kpreid: yes?
16:57:09 <povman> hehe awesome
16:57:12 <shapr> emu: Have you seen my "I am not a koala" xkb layout for the kinesis keyboard?
16:57:20 <emu> no
16:57:25 <dons> (he's working on an effect calculus for haskell-like compilers)
16:57:34 <kpreid> satan: foldr (:) [] == id
16:57:41 <povman> *eyes glazed over*
16:57:50 <dons> povman: you know Clem Baker-Finch?
16:58:07 <emu> http://www.kinesis-ergo.com/contoured.htm?
16:58:09 <lambdabot> Title: Kinesis US Model Contoured Keyboards
16:58:11 <povman> kind of, he introduced me to haskell
16:58:21 <dons> cool :) I met him on Thursday :)
16:58:26 <LoganCapaldo> @type foldr (:) []
16:58:28 <povman> yesterday?
16:58:28 <lambdabot> forall a. [a] -> [a]
16:58:32 <povman> where are you?
16:58:33 <dons> last week
16:58:35 <shapr> emu: Yeah, that one. I'm looking for the url to my blog entry about it...
16:58:36 <dons> at UNSw
16:58:36 <povman> oh
16:58:40 <povman> what were you doing?
16:58:53 <satan> kpreid: right, i'm doing a proof, so i'm wondering if they were equivalent
16:59:04 <shapr> emu: http://lwn.net/Articles/207326/
16:59:06 <lambdabot> Title: LWN: I like both kinds of editor & Emacs Pinky Solutions
16:59:13 <kpreid> satan: oh, well, don't take my word for it then :)
16:59:24 <dons> oh, he was in Sydney for the APLAS conference, and Ben was on Saturday for SAPLING, http://www.comp.mq.edu.au/~asloane/SAPLING/Meetings/FDBB102C-5A09-4F08-86E4-49B5A6F60BDE.html
16:59:26 <lambdabot> Title: 1st SAPLING Meeting, http://tinyurl.com/y4scwr
16:59:32 <satan> kpreid: alright :) thanks anyway, i'm trying to porve that that's = id
16:59:55 <dons> povman: so big haskell secret meeting :)
17:00:04 <povman> wow....
17:00:15 <dons> at which I learnt  there's a thriving ANU haskell community
17:00:15 <kpreid> satan: prove that it's the same for each case of the argument being [], (_:_) or _|_?
17:00:18 <emu> i once tried dvorak, i have qwerty pretty well embedded unfortunately :/
17:00:24 <lispy> ANU?
17:00:30 <shapr> Botty, emu: I did have RSI such that I couldn't use my left arm for about nine months. Whatever you use, be careful with your hands!
17:00:31 <povman> dons: i didn't even know that
17:00:33 <lispy> gah, i need to leave irc...
17:00:42 * lispy fades away
17:01:07 <povman> we had to learn haskell for a formal methods course
17:01:07 <shapr> emu: I've been using dvorak for ... 14 years now.
17:01:14 <dons> povman: ah cool.
17:01:17 <emu> i'm generally pretty unhappy with my keyboards, but it's much better than moving the mouse around with my wrist
17:01:19 <dons> and you're using it for robots or something?
17:01:20 <lispy> dvorak++
17:01:36 <emu> i can type fast and i don't get pain, for now
17:01:45 <povman> dons: think more like mindrover or robot wars
17:01:59 <robreim> dvorak only takes a couple of weeks to get productive with
17:02:03 <dons> ah ok, not programming robots? like this http://haskell.org/haskellwiki/Research_papers/Functional_reactive_programming
17:02:05 <lambdabot> Title: Research papers/Functional reactive programming - HaskellWiki, http://tinyurl.com/jsfmb
17:02:08 <emu> i used to get periodic problems, but i've changed my working habits to eliminate most uses of the mouse, and it seems to have worked
17:02:24 <robreim> And once you've done it you can pretty well use qwerty or dvorak (usually dvorak's a bit quicker though)
17:02:32 <shapr> emu: Trackballs fix part of the mouse problem, you don't need to suspend your hand/wrist anymore.
17:02:34 <emu> so do you just remap the keyboard?
17:02:38 <povman> robreim: emacs shortcuts get really annoying
17:02:56 <robreim> povman: I don't find they're annoying. In fact I find it annoying when I have to use emacs in qwerty :P
17:03:11 <emu> people tell me in dvorak, emacs keybindings are about the same, and vim gets all messed up
17:03:38 <povman> robreim: yeah vim gets really annoying. oh and so does copy/cut/paste standard shortcuts
17:03:48 <shapr> emu: Nah, more important than remapping is to not maintain a static join position, and stay relaxed.
17:04:11 <robreim> Yeah, the xcv keys get scattered accross the keyboard, but I use linux anyway so it's just a highlight + middle-click job to paste most of the time.
17:04:13 <astrolabe> what were those machines stenographers used to have?  maybe they would be faster?
17:05:05 <povman> dons: i still don't fully comprehend everything about monads :p
17:05:13 <dons> heh
17:05:16 <shapr> povman, robreim: try xclip
17:05:20 <robreim> What we really need is to map our brain neurons into a computer so we can just think with the same speed and accuracy of a computer. Then we don't need computers (or mortality) anymore :P
17:05:21 <SamB> hah
17:05:31 <povman> robreim: hell yes
17:06:06 <povman> anyway nice meeting you all
17:06:09 * povman -> lunch
17:06:51 <robreim> actually, we'd still need computers... we just wouldn't need keyboards or mice
17:07:39 <Botty> ohh, you guys know mindrover?  I loved that game
17:07:45 <SamB> you can't think intelligently that fast, I don't think
17:07:56 <SamB> or accurately
17:08:07 <SamB> inaccuracy is a very important part of being intelligent
17:09:18 <lispy> heh, we're all very OT today
17:09:33 <lispy> more code!
17:09:38 <robreim> SamB: you reckon? I think it'd be great to have 1GB of short-term memory to work with rather than just "7 items" I think the accuracy of being able to keep more things in mind at the same time would be great! :)
17:10:00 <robreim> Ooh yeah... haskell... Ok, so implementing virtual neurons using haskell...
17:12:49 <SamB> robreim: we might be able to have that
17:13:03 <SamB> but our actual thinking would be just as innacurate, I suspect
17:13:56 <hyrax42_> I'm spoilt by parsec
17:14:17 <hyrax42_> scanf "parsing" leaves a lot to be desired
17:14:36 <ralf`> robreim: since I started learned how to stretch in yoga classes, I've been doing a lot of my "thinking" with hips, not brain, so you would have to map that in there too.
17:14:38 <robreim> SamB: Yeah, I don't mean the thinking would be inaccurate, I mean the memory would be accurate. eg being able to remember things at a precise quality...
17:16:41 <robreim> Being able to choose accurately what you remember would be nice - no more annoying songs stuck in your head. Hell, not having to listen to Britney Spears the whole day long is enough of a reason to do it.
17:16:52 <SamB> how do you program with your hips?
17:17:13 * SamB doesn't listen to britney spears anyway
17:17:23 * glguy would like to teach his fiancee to program with her hips...
17:18:02 <robreim> Sometimes there's no choice - if someone has the radio on and it comes on there - or someone else has it stuck in their head and is singing the tune... gah!
17:18:27 <eviltwin_b> this is why I have headphones and an ipod :)
17:18:41 <robreim> Or where your mind plays a trick on you and decides to play the song in one of your dreams so you wake up with the song stuck in your head...
17:19:07 <robreim> Anyway, this isn't productive :P
17:20:02 <lispy> is the new haskell wiki intentionall hard to search?
17:20:09 <lispy> ?google site:haskell.org monadrandom
17:20:12 <lambdabot> http://www.haskell.org/hawiki/MonadRandom
17:20:12 <lambdabot> Title: MonadRandom - The Haskell Wiki
17:20:24 <ralf`> SamB: Good question.  What I meant to say was that I think with my hips.  I won't deny that I program with my hips, but I'll have to think about what that would mean.
17:20:24 <ralf`> I will also remind anyone on this channel who claims that thinking happens in the brain that there is a bundle of nerves branching off from the spine and innervating the colon which is large enough that it seems to do its own thinking.
17:20:27 <ralf`> robreim: It's true.  If you live in a city, a lot of choices about your sound environment are made for you.
17:20:32 <lispy> but i wanted: http://haskell.org/haskellwiki/NewMonads/MonadRandom
17:20:35 <lambdabot> Title: New monads/MonadRandom - HaskellWiki, http://tinyurl.com/fs3av
17:22:05 <ralf`> glguy: first step: learn about your own hips.
17:23:21 <astrolabe> ralf: you think people with severed spinal chords are mentally impared?
17:24:10 <robreim> I kind of think of motor functions as being a bit different to "thinking"... I don't think the spine participates in much other than the former.
17:24:27 <astrolabe> (that sounds as though I want to critise you, I don't, I'm interested).
17:26:42 <robreim> astrolabe: have I ever told you that you look just like Astroboy's hot sister?
17:27:39 <dons> ralf`: when creating new pages on the wiki, follow the naming conventions :)
17:27:53 <dons> so not 'HaskellColourChords" but rather 'Colour_chords'
17:28:00 <astrolabe> robreim: you haven't but thanks very much.  Even with my beard?
17:28:02 <dons> e.g. http://haskell.org/haskellwiki/Color_chords
17:28:03 <lambdabot> Title: Color chords - HaskellWiki
17:28:30 <robreim> astrolabe: I can't see your beard. I can only see your nick which looks a lot like Astroyboy's hot sister :P
17:30:45 <ralf`> dons: Thx.  I guess I was following the convention for haskell identifiers.
17:30:56 <ralf`> I just posted some code there, but it's not quite working.
17:31:04 <ralf`> I will post another screenshot soon.
17:31:29 <dons> cool
17:32:12 <ralf`> I met a graphic designer at a coffee shop here in Oakland last night.  I sat down with him and picked out a couple of color chords.  I showed him what it looks to edit "code" in "emacs" and he thought it was great and saw immediately how powerful it could be to blend a working knowledge of color theory with the process of creating software.
17:32:51 <ralf`> It was great to hear him talk about color and how the decisions that he makes about color today are affected by his entire life's experience up until now.
17:33:29 <Botty> uh, any decision you make is affected by your entire life's experience
17:34:15 <dons> Botty: writing any haskell code at the moment?
17:34:40 <Botty> nope, writing notes for a history test
17:34:47 <Botty> US history, ugg
17:36:36 <robreim> Hmm... just a point of curiousity - is there any way to declare a type to be a subset of another existing type? eg the range of Ints between two specified bounds?
17:37:39 <Cale> robreim: nope
17:37:55 <robreim> ok, thanks.
17:38:46 <Cale> Types like that would be too hard to infer, and too hard to actually check at compile time.
17:39:30 <psykotic> cale: if you can do something like oleg's number-parameterized types, why not this?
17:39:34 <psykotic> (i'm not saying it's practical)
17:40:22 <Cale> Well, okay, if you want to change the types of all the numeric operations, possibly you could rig something up with a lot of work.
17:41:53 <Cale> Like, possibly you could represent numbers and intervals in the type system and have it do interval arithmetic.
17:42:00 <psykotic> yup
17:42:11 <Cale> The type signatures would be insane.
17:43:01 <robreim> I'm thinking along the lines of lisp's type system, where you can declare types to be a subset of another in that way. So you could conceivably make a type which consisted only of even integers.
17:43:42 <Cale> Yeah, but can lisp actually statically prove that those types hold?
17:43:43 <eviltwin_b> but lisp does typing at runtime, doesn't it?
17:44:02 <psykotic> it's not really a "type system", those constraints are usually just checked pointwise.
17:44:28 <Cale> You can definitely rig up a numeric type with additional dynamic conditions.
17:44:30 <robreim> I'm not sure how it's implemented, but it probably is just equivalent to a bunch of asserts...
17:45:00 <Cale> Types in Haskell are things which the compiler proves at compile time.
17:45:28 <SamB> occassionally it can actually prove something, though, and open-code things
17:46:03 <Cale> You can actually express fairly strong conditions with enough work.
17:46:24 * SamB was talking about "the Lisp compiler"
17:47:04 <Cale> iirc, types are mostly used for efficiency
17:47:06 <eviltwin_b> I think if you really, really wanted to, you could represent finite restricted types as enumerated types.  be a lot of work, though, for dubious gain
17:47:22 <Cale> Oh, yeah, you could do that as well.
17:47:24 <eviltwin_b> (you couldn't do e.g. all even integers, though)
17:47:38 <ralf`> emacs folks: as you can see in the code pasted at the link which dons referenced above, I am using facemenu-set-background to set the background in emacs.  This does not seem like the appropriate function.  Can anyone suggest another function?
17:47:42 <Cale> You could, if you didn't mind them having a separate representation from Integers
17:47:46 <Cale> In fact,
17:47:55 <psykotic> something like odd/even integers could probably be done using GADTs. isn't that one of the examples in "putting curry-howard to work"?
17:48:04 <Cale> newtype Even = Twice Integer
17:48:17 <eviltwin_b> I was talking about using enumerated types
17:48:25 <Cale> Then you just have to implement Num correctly :)
17:48:59 <Cale> (whereby Twice n is treated as 2*n)
17:49:30 <robreim> you'd have to figure out what to do with odd number results of computations like (+1)...
17:49:42 <Cale> You can't add 1 to Twice n
17:50:00 <robreim> oh, true...
17:50:13 <Cale> well, make fromInteger partial
17:50:21 <robreim> ok, well that was kind of the lines I was thinking of then. (I discarded it because I thought +1 wouldn't work)
17:50:41 <robreim> Odd would be more difficult though... you could add two odds and end up with a non-odd.
17:51:16 <Cale> yeah, for that, you'd need a different numeric hierarchy
17:51:53 <Cale> Even evens are pushing it, because you can't properly implement fromInteger
17:52:15 <Cale> except possibly by doing something extremely dubious like fromInteger = Twice
17:52:35 <robreim> or rounding down
17:52:57 <Cale> Which would mean that (Twice n) + 1 would get treated as Twice n + Twice 1 = Twice (n + 1)
17:53:00 <dolio> That'd be pretty sketchy, considering all your literals would end up having twice the expected value.
17:53:04 <Cale> right
17:53:20 <Cale> probably the sanest thing to do is just error out
17:53:34 <SamB> Cale: you can't properly implement that for galois fields, either, so that argument is silly
17:53:41 <int-e> na, do not implement Num at all ...
17:53:45 <SamB> hah
17:53:47 <int-e> I think that's sanest :)
17:53:49 <Cale> SamB: sure you can
17:54:16 <Cale> There's always a natural homomorphism from Z to any ring.
17:54:18 <SamB> Cale: but x^1 + 0 is nothing like 2
17:54:33 <Cale> fromInteger is not required to be surjective
17:54:44 <SamB> what would you suggest?
17:54:45 <int-e> (note that Cale's rings have a multiplicative unit)
17:54:55 <Cale> 0*x + 2 is rather like 2 :)
17:55:03 <psykotic> SamB, n gets sent to sum of n copies of the identity in whatever ring.
17:55:03 <beantmt> i'm working on an exercise on polymorphic recursion and it asks:  f x = if x == x then True else f False .. what would the type of the function be?  just a generic type, a, that implements Eq?
17:55:15 <beantmt> (terribly new at haskell btw)
17:55:19 <psykotic> i should say unit.
17:55:21 <SamB> Cale: but say this is a GF(2^n)
17:55:26 <Cale> SamB: sure
17:55:35 <Cale> There's still a hom Z -> GF(2^n)
17:55:41 <Cale> It sends 2 to 0
17:55:42 <int-e> SamB: then fromInteger 2 = fromInteger 0
17:55:45 <Cale> that's not a problem
17:55:48 <SamB> oh, well, whatever
17:55:52 <Cale> because 2 = 0 in that ring
17:56:04 <int-e> implementing toInteger is whacky though.
17:56:23 <SamB> I think mine just errors out, because if you tried that you probably aren't getting what you wanted...
17:56:26 <psykotic> you get a faithful embedding in the char 0 case, in any case
17:56:50 <Cale> SamB: I'd want to get 0 for the literal 2 if I was working in GF(2^n)
17:56:51 <SamB> int-e: you don't need to do that though, because most of the stuff in Integral does not make sense for galois fields
17:56:54 <robreim> hmm... how does fromInteger of floats work? surely fromInteger of evens would work the same?
17:57:21 <SamB> Cale: why would you use 2?
17:57:34 <int-e> SamB: ah. I thought that was in Num, too. thanks.
17:57:46 <Cale> beantmt: f :: Bool -> Bool
17:58:12 <Cale> SamB: because maybe some more general algorithm is being applied in the GF(2^n) case
17:58:19 <robreim> hmm.. actually, fromInteger would need to be more like toInteger...
17:58:45 <SamB> Cale: I was thinking those probably don't work most of the time...
17:58:47 <int-e> SamB: Ah, Num has signum and abs ... those are a nuisance, too.
17:58:58 <Cale> @type let f x = if x == x then True else f False in f
17:58:59 <SamB> int-e: not really
17:58:59 <lambdabot> Bool -> Bool
17:59:02 <SamB> abs = id
17:59:43 <beantmt> Ok.. how does that work?
17:59:46 <SamB> I suppose signum 0 = 0; signum x = 1
17:59:54 <SamB> or you could just skip that
18:00:04 <SamB> because who would want to try to find the sign?
18:00:05 <int-e> SamB: signum (-x) = signum x. Hmm.
18:00:20 <beantmt> i thought it being polymorphic recursive it would have to have a general type
18:00:21 <int-e> SamB: I define them as errors.
18:00:39 <SamB> int-e: well, that makes perfect sense when (-x) = x
18:00:44 <Cale> Because f is applied to False, its type must be Bool -> t for some type t, and because f returns True, its type must be s -> Bool for some type s. Unifying these gives f :: Bool -> Bool.
18:01:08 <Cale> Unless I'm missing something
18:01:32 <Cale> Actually, I suppose it might be f :: (Eq a) => a -> Bool
18:01:42 <eviltwin_b> I thought that stray f in the tail was a typo, actually
18:02:05 <eviltwin_b> sicne it was right at what for my client was the linebreak... but with a proportional font I guess that's not a safe ssumption
18:02:15 <LoganCapaldo> riddle me this Haskellites, why isn't there a data Sign = Positive | Zero | Negative and signum (Num a) => a -> Sign ?
18:02:26 <Cale> LoganCapaldo: complex numbers
18:02:38 <LoganCapaldo> k...
18:02:38 <Cale> What's the sign of i?
18:02:54 <LoganCapaldo> what does signum do for complex numbers?
18:03:13 <Cale> > signum (3 :+ 2)
18:03:15 <lambdabot>  0.8320502943378437 :+ 0.5547001962252291
18:03:25 <Cale> > signum (2 :+ 2)
18:03:26 <lambdabot>  0.7071067811865475 :+ 0.7071067811865475
18:03:26 * LoganCapaldo boggles
18:03:27 <int-e> heh. normalize?
18:03:37 <Cale> It normalises, yeah
18:03:46 <LoganCapaldo> Ok I guess that makes sense if I think about it for a second
18:03:46 <eviltwin_b> but even if it's not a typo, I don't think that forces f to take a Bool
18:03:57 <LoganCapaldo> Yep it does
18:04:00 <eviltwin_b> so my guess would be the latter)
18:04:00 <LoganCapaldo> nvm
18:04:19 <LoganCapaldo> thats quite funky
18:04:32 <dolio> Seems like a reasonable generalization.
18:04:38 <lollan> funk is good
18:04:40 <LoganCapaldo> what I get for not understanding how signum works at first blush
18:04:42 <int-e> abs x * signum x = x
18:04:53 <int-e> hmm :)
18:04:57 <beantmt> Cale: (Eq a) => a was my original though, how would you know?
18:04:58 <LoganCapaldo> int-e: Yeah I figured it out
18:05:40 <Cale> beantmt: I suppose that's the most general type which can be given. It's not the type which Haskell will give because of the monomorphism restriction.
18:06:33 <beantmt> Cale: Okay.. i think i'm following.  Thanks.
18:06:55 <Cale> f has type a -> b, for some a and b, and you know immediately that b = Bool. All that can be gleaned about a is that it implements the class Eq because (==) is applied to it.
18:07:37 <Cale> Eq Bool holds, so applying f to False is okay
18:08:06 <Cale> But in this case, it doesn't actually guarantee that f takes Bool values only.
18:11:04 <beantmt> Got it.
18:12:35 <lispy> i'm just learing scala so i could be wrong, but it seems that the fold operation on lists must return the same type as the list
18:12:45 <lispy> ?type foldl
18:12:46 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
18:14:03 <int-e> SamB: ok, your signum and abs definitions are reasonable, but I'd argue that they're useless.
18:14:17 <lispy> so they have foldLeft :: (b -> a -> b) -> b -> b -> b where a is a subtype of b
18:14:36 <lispy> so to use a fold effectively you have to use map first
18:15:29 <lispy> (I tried putting the map i needed in the lambda i was giving fold but i only got type errors
18:16:31 <monochrom> I don't understand why a is a subtype of b. I don't understand why there is no [b] in the type signature. I don't understand anything.
18:17:31 <lispy> oh sorry
18:17:35 <lispy> put a [b] in ther ight place
18:17:39 <lispy> i forgot the brackets
18:17:52 <lispy> (b -> a -> b) -> b -> [b] -> b
18:18:09 <lispy> basically the 'a' in their is meaningless for haskell
18:18:15 <lispy> there*
18:19:46 <glauber_sp> hi guys =) I'd like to ask you some paper that relates lambda calculus with Haskell or with functional programming in general. Can you tell me any?
18:22:42 <SamB> int-e: they might be useful if you were using generic algorithms
18:22:56 <SamB> probably I would just not bother to write those, though
18:23:18 <SamB> unless I actually encountered something trying to use them...
18:25:23 <SamB> I admit Cale's definition of fromInteger is reasonable in some way, too, but I wouldn't bother to think so much until I encountered a real reason
18:26:38 <Cale> SamB: I suppose it's just natural to me because I'm used to using that sort of overloading in mathematics.
18:26:57 <Cale> I also write '2' for twice the identity matrix :)
18:27:08 <SamB> that makes sense to me, though
18:27:18 <SamB> because I can see the point in using that
18:27:31 <SamB> I can't see the point in using 2 when it does the same as 0, though
18:27:59 <Cale> Well, whenever you have a quotient ring, the tendency is to identify an element of the original ring with the equivalence class containing it in the new ring.
18:28:18 <SamB> hmm?
18:28:23 <SamB> which one is the original ring?
18:28:26 <Cale> So, for example, in Z/12, you consider 13 and 1 to mean the same thing.
18:28:36 <Cale> Z being the original ring in that case
18:28:40 <SamB> oh.
18:28:56 <SamB> is GF(2) the same as Z/2?
18:29:08 <Cale> yeah, but GF(4) isn't the same as Z/4
18:29:15 <SamB> oh?
18:29:23 <monochrom> Some Backus lecture on "can programming be liberated from the von Neuman style" may be useful to glauber_sp
18:29:23 <SamB> wait, 4 is not prime
18:29:27 <Cale> In the case of Galois fields, you're usually modding out a polynomial ring by some irreducible polynomial.
18:29:35 <Cale> It's a power of a prime.
18:29:45 <SamB> don't you mean GF(2^2) ;-)?
18:29:57 <Cale> There's a unique finite field of each prime power order.
18:30:24 <SamB> "prime power order"?
18:30:50 <Cale> size
18:30:58 <glauber_sp> monochrom, hum, I'v already read this paper some time ago. I'll search for it again. thanks =D
18:31:39 <SamB> so, GF(p) is Z/p where p is prime...
18:31:44 <Cale> For each prime p and positive integer n, there is exactly one field with p^n elements
18:32:02 * SamB would like to call that Z%p
18:32:05 <Cale> and yeah GF(p) is isomorphic to Z/p when p is prime.
18:32:20 <Cale> Z/<p> is more correct
18:32:20 <SamB> Cale: exactly one?
18:32:25 <Cale> Or Z/pZ
18:32:29 <Cale> yeah
18:32:47 <SamB> you mean you can prove that there is a single irreducible polynomial of each degree?
18:32:50 <Cale> In other words, two finite fields with the same number of elements are isomorphic.
18:32:53 <Cale> no
18:32:55 <SamB> (in the given field)
18:33:02 <SamB> oh.
18:33:07 <Cale> In general there will be many, but it won't matter which you pick.
18:33:30 <SamB> you mean the polynomial isn't part of the field, or they are all isomorphic so you for some reason don't care which?
18:33:40 <Cale> the latter
18:33:45 <SamB> not that I'd care either
18:34:16 <Cale> We don't usually care too much about the differences between fields which are isomorphic.
18:34:22 <SamB> unless I wanted to exchange data with someone else
18:34:29 <Cale> right :)
18:34:42 <Cale> In which case you'd want to provide your explicit construction
18:34:47 <SamB> I mean, it wouldn't do if I had my data error coded with one polynomial and someone tried to decode it with another one!
18:35:01 <chessguy> > sum [2,3,4]
18:35:01 <LoganCapaldo> Just would not do
18:35:02 <lambdabot>  9
18:35:24 <SamB> hmm, what is the isomorphism anyway?
18:35:34 <SamB> log/exp?
18:35:51 <chessguy> ok, best practices question
18:36:05 <chessguy> i've got two implementations here of sum
18:36:18 <chessguy> i want to know which one is better style
18:36:32 <chessguy> here's implementation 1
18:36:34 <chessguy> sum [] = 0          sum (x:xs) = x + (sum xs)
18:36:44 <chessguy> implementation 2:
18:36:46 <chessguy> sum [x] = x         sum (x:xs) = x + (sum xs)
18:36:55 * SamB wonders why chessguy is implementing sum
18:37:02 <SamB> also, that doesn't parse
18:37:07 <Cale> SamB: the proof I know isn't terribly constructive
18:37:08 <chessguy> to make a point
18:37:09 <SamB> you need a semicolon between parts
18:37:23 <Cale> actually the isomorphism is highly non-unique
18:37:25 <chessguy> yes, they're both on two lines
18:37:31 <Cale> There are at least n! of them
18:37:42 <dcoutts> chessguy, clearly version 1 is better
18:37:46 <SamB> Cale: that really isn't very good for anything
18:37:50 <chessguy> dcoutts, why?
18:37:59 <SamB> but they all have the same abstract properties
18:38:06 <dcoutts> because we count from 0 and lists from []
18:38:19 <SamB> as long as you don't know what the polynomial is, it can't hurt you, eh?
18:38:22 <chessguy> hmm, see this is where i disagree
18:38:25 <pkhuong> chessguy: implementation 3: `sum = foldr (+) 0' .
18:38:26 <chessguy> for two reasons
18:38:31 <dcoutts> chessguy, also, version 2 doesn't work for []
18:38:37 <chessguy> yes!
18:38:43 <dcoutts> pkhuong, or foldl'
18:39:05 <chessguy> first of all, the first version is bad form, mathematically. the sum of the elements of the empty set is not 0. it's invalid.
18:39:07 <psykotic> samb: btw all the stuff about finite fields is probably an order of magnitude easier to understand/prove when approached abstractly rather than concretely via the kronecker-weber construction (the one where you mod out by a certain cyclotomic polynomial).
18:39:14 <pkhuong> chessguy: really?
18:39:18 <Cale> To show that there's a unique field for each prime power, suppose that K is any field of order p^n. Then K has a subfield isomorphic to Z/p (generated by 1), and because the nonzero elements of K form a multiplicative group of order p^n - 1, every element of K is a zero of f(x) = x^(p^n) - x.
18:39:31 <chessguy> but more importantly, if i'm taking the sum of an empty list, more than likely it's because there's an error in my code somewhere
18:39:36 <Cale> So K must be a splitting field for f(x) over Z/p.
18:39:36 <dcoutts> chessguy, it depends on how you define it
18:39:37 <SamB> psykotic: hmm?
18:39:40 <chessguy> so i think sum SHOULD bomb out
18:39:46 <SamB> which way is easier?
18:39:48 * dcoutts disagrees
18:39:49 <chessguy> rather than go merrily on its way
18:39:51 <psykotic> the abstract way.
18:39:52 <glauber_sp> bye ppl =) good night
18:39:52 <Cale> We have a theorem which says that splitting fields are unique up to isomorphism.
18:39:59 <SamB> what way is that?
18:40:37 <psykotic> you define a finite field as a field of finite order. you then proceed to show that any field is a vector space over its prime subfield. then you classify finite prime subfields: they have prime orders, and are hence isomorphic to Z/p for p prime. etc.
18:41:01 <SamB> Cale: okay, that is going over my head
18:41:07 <SamB> I don't really know abstract algebra
18:41:13 <chessguy> dcoutts, why do you disagree?
18:41:22 <psykotic> that then shows that any finite subfield must have order p^n for some prime p where p is the order of its prime subfield.
18:41:28 <SamB> I just try to pretend I do
18:41:34 <SamB> well, okay, I try to know it
18:41:38 <Cale> SamB: yeah, it's unlikely that will make sense unless you've taken the course in which they'd show you this result anyway :)
18:41:38 <dcoutts> chessguy, I think sum of the empty list/set is perfectly well defined and indeed useful.
18:41:45 <SamB> but I don't spend enough time on it
18:42:17 * SamB wonders if they have any at his school
18:42:27 <SamB> yup, I definately need to major in maths
18:42:29 <LoganCapaldo> Are commas illegal in operator defns?
18:42:45 <dcoutts> LoganCapaldo, almost certainly
18:42:50 <chessguy> dcoutts, but if i'm calling sum from some other complex set of code, and passing it an empty set, chances are, it's because there's an error in that complex set of code. and treating it as if it's fine in sum only compounds the problem
18:42:56 <Cale> psykotic: it almost, but not quite, shows that two fields of the same order are isomorphic. They're certainly isomorphic as vector spaces over Z/p
18:43:05 <LoganCapaldo> goody
18:43:25 <dcoutts> chessguy, then check it there, no need to force every other bit of code to workaround to define sum [] = 0
18:43:29 <psykotic> cale: yeah, i thought that was enough but you're right, you need something more.
18:43:53 <SamB> Cale: I'm sure if you just decide to do things without quibbling over what polynomial you are using, you can get general results that will work well for any particular polynomial you might find...
18:44:04 <psykotic> i wonder if there's an elementary way that doesn't involve results about splitting fields, though.
18:44:23 <chessguy> dcoutts, that made no sense to me
18:44:26 <psykotic> SamB, abstractly finite/galois fields don't have anything to do with polynomials at all.
18:44:38 <dcoutts> chessguy, you can see from the code that it is unnatural, it's treating [_] as a special case when there are only two natural cases of lists, [] and (x:xs), similarly for the inductive structure of naturals
18:44:52 <LoganCapaldo> wow, after I stopped trying to use "<,>" as an operator that was scary easy
18:44:56 <psykotic> SamB, in other words, you can't count a particular construction of some GF(p^n) having to dow ith polynomials.
18:45:03 <psykotic> *do with
18:45:11 <dcoutts> chessguy, you can asset the non-emptyness at the point you use it in your complex code
18:45:15 <SamB> psykotic: well sure
18:45:24 <chessguy> it only seems unnatural to you because you're used to seeing it that way
18:45:33 <psykotic> otoh they will be something "like" polynomials because of the vector space property i mentioned above.
18:45:35 <SamB> well, I'm not sure what you mean about not being able to count
18:45:36 <chessguy> i think taking the sum of the elements of an empty set is unnatural
18:45:48 <Cale> SamB: yeah, these are sort of the abstract fields that happen to be isomorphic to certain quotients of polynomial rings
18:45:58 <SamB> chessguy: you might like the roman empire
18:46:11 <dcoutts> no, it's unnatural because it doesn't follow the inductive structure of lists
18:46:11 <monochrom> "natural" is subjective
18:46:26 <chessguy> SamB, ?
18:46:27 <monochrom> The Greeks define "number" to be at least 2.
18:46:32 <Cale> chessguy: the sum of the empty set of numbers is 0
18:46:35 <LoganCapaldo> Hmm I can't use semicolons either huh
18:46:36 * dcoutts counts from 0
18:46:42 <araujo> Sun Computational Theologist Gilad Bracha admits, "It has come to our attention that some people want to program in things other than Java."
18:46:45 <Cale> chessguy: this is not a Haskell convention, it's a mathematics convention :)
18:46:45 <LoganCapaldo> No comma-look-alike for me I suppose
18:46:48 <SamB> chessguy: they had no zero, so they COULD NOT take the sum of an empty list
18:46:51 <Cale> similarly
18:46:54 <Cale> > product []
18:46:55 <araujo> That's corporative wisdom
18:46:56 <lambdabot>  1
18:47:01 <chessguy> yuck
18:47:06 <Cale> not yuck
18:47:09 <Cale> it's beautiful
18:47:10 <SamB> it works out well for...
18:47:18 <Cale> > (\n -> product [1..n]) 0
18:47:20 <lambdabot>  1
18:47:28 <Cale> 0! = 1
18:47:30 <SamB> > let factorial n = product [1..n] in map factorial [0..]
18:47:32 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
18:47:36 <chessguy> > (\n -> product [1..n]) 1
18:47:36 <psykotic> > 0^0
18:47:38 <lambdabot>  1
18:47:38 <lambdabot>  1
18:47:41 <psykotic> good :)
18:47:46 <dcoutts> chessguy, if I've sold [] items, how much money have I made ?
18:47:50 <Cale> > let n^m = product (replicate m n) in 0^0
18:47:51 <lambdabot>  1
18:47:54 <Cale> > 0^0
18:47:55 <lambdabot>  1
18:48:02 <chessguy> [] isn't a number, you can't sell [] items
18:48:03 <SamB> dcoutts: good idea!
18:48:07 <psykotic> cale: more critically, there is one function from the empty set to itself! :)
18:48:14 * psykotic hates it when 0^0 is left undefined.
18:48:21 <SamB> money always gets people interested in making sure things actually make sense
18:48:22 <monochrom> Why should sum [] = 0?  Because you like sum (xs++ys) = sum xs + sum ys.  Well if ys happens to be [] you still want that to work.  The only way is sum [] = 0.
18:48:23 <Cale> psykotic: indeed, that's my favourite definition of n^m as well
18:48:26 <dcoutts> methinks it's not "exception: user error(sum [])"
18:48:33 <Botty> chessguy - sure, its 0
18:48:46 <SamB> they don't want to lose their money to inconsistant mathematical systems, after all ;-)
18:48:55 <psykotic> cale: yeah, it nicely fits the view of natural numbers as decategoried finite sets.
18:48:57 <dcoutts> monochrom, ah yes, mapping units to units, another good point
18:49:01 <monochrom> Why should product [] = 1?  Because you like product (xs++ys) = product xs * product ys.  Well if ys happens to be [] you still want that to work.  The only way is product [] = 1.
18:49:05 <psykotic> decategorified, even
18:49:06 <Cale> chessguy: general formulas would break if things weren't defined like this
18:49:29 <emu> similarly for any and all
18:49:32 <emu> > any []
18:49:33 <lambdabot>    Expecting a function type, but found `[a]'
18:49:34 <lambdabot>    Expected type: a -> Boo...
18:49:34 <SamB> hmm, what was the log of 0?
18:49:37 <chessguy> hmm
18:49:46 <Cale> SamB: not defined :)
18:49:47 <emu> > any (const True) []
18:49:50 <lambdabot>  False
18:50:00 <monochrom> So I want to say that all kinds of analogies and mysticisms that you want to use to associate "empty" with "zero" blindly is ill-conceived.
18:50:04 <emu> > all (const False) []
18:50:05 <lambdabot>  True
18:50:09 <LoganCapaldo> Darn
18:50:09 <SamB> hmm, I guess that must be special cased then ;-)
18:50:14 <SamB> for multiplication...
18:50:31 <dcoutts> chessguy, you're quite right that it might sometimes indicate an error condition, but you can always check that explicitly, or define a local sumNonEmpty
18:50:43 <SamB> > 0^0
18:50:45 <lambdabot>  1
18:50:53 <SamB> hmm.
18:50:54 <emu> > 0%0
18:50:54 <Cale> SamB: a^b = exp (b * log a) is a suitable definition when a is nonzero
18:50:55 <lambdabot>  Exception: Ratio.%: zero denominator
18:51:02 <SamB> Cale: yeah.
18:51:03 <SamB> I know.
18:51:03 <Cale> (or in the real case, when a is positive)
18:51:12 <SamB> its really the only practical one.
18:51:15 <chessguy> dcoutts, yes, but now you're losing cohesion
18:51:26 <SamB> I mean, for GF(2^n)
18:51:27 <psykotic> the more elementary (but not as practical) definition relies on a limit argument.
18:51:40 <psykotic> i think rudin does that.
18:51:56 <SamB> I don't think you can do calculus in GF(2^n)
18:52:17 <monochrom> Someone should write a blog on "you could have re-discovered the necessity of product[]=1 too!"
18:52:18 <dcoutts> chessguy, judicious use of assert is probably best, assert (not (null listOfStuff)) $ ...
18:52:23 <psykotic> i.e. define a^b for first naturals, then integers, then rationals and then finally reals by a limiting argument. each step is guided by natural requirements on exponetiation.
18:52:53 <chessguy> ok, well i guess this is one of those things which i'm not going to like, but that's just the way it is :)
18:53:00 <chessguy> thanks for the interesting discussion anyway
18:53:18 <Cale> psykotic: I don't really care too much for the supremum thing with the reals. For the reals and complexes, I'd just go straight to the series definition of exp.
18:53:26 <SamB> psykotic: I was still talking of GF(2^n), and possibly other bases but I don't care about those because my computer runs on binary, not some other prime base...
18:53:53 <Cale> SamB: It doesn't really work in GF(2^n) naturally though.
18:54:00 <SamB> Cale: oh?
18:54:24 <Cale> Multiplication in GF(2^n) is screwy, it doesn't correspond to integer multiplication in any obvious way.
18:54:28 <SamB> Cale: you just nead log and exp tables...
18:54:44 <Cale> The series for exp doesn't work.
18:54:53 <SamB> what series?
18:54:58 <SamB> you don't need no stinkin series
18:55:03 <LoganCapaldo> Can I overload a function without creating a type class?
18:55:04 <Cale> exp(x) = sum over k >= 0 of x^k / k!
18:55:15 <Cale> 2 isn't invertible
18:55:17 <chessguy> "i just can't function without you!"
18:55:31 <Cale> LoganCapaldo: no
18:55:36 <SamB> you don't use that exp...
18:55:41 <Cale> LoganCapaldo: you can make it polymorphic
18:55:46 <Cale> LoganCapaldo: but you can't overload it
18:55:59 <Cale> SamB: which exp are you thinking of?
18:56:40 <LoganCapaldo> I'm trying to make a "show + concat" operator that doesn't apply show to things that are already strings. So right now, its _too_ polymorphic ;)
18:56:47 <SamB> it is the log/exp WRT that irreducible polynomial
18:56:58 <psykotic> samb: what does that mean?
18:57:23 <SamB> I think thats what it is
18:57:32 <Cale> I've never heard of that.
18:57:35 <monochrom> Why do people like to define operators that don't behave uniformly across types?
18:57:44 <LoganCapaldo> we're stupid?
18:57:52 <psykotic> the irreducible polynomial is zero in the finite field, so you'd be taking powers of 0 (if i understand what you're proposing)
18:57:56 <SamB> hmm.
18:58:03 <LoganCapaldo> It's because I don't really want a show, I want a toString
18:58:09 <SamB> okay, I'm forgetting what it is
18:58:14 <Cale> LoganCapaldo: the silly thing about this is that if something is a string, you know that it's a string at compile time
18:58:31 <Cale> So you normally just prevent yourself from typing 'show'
18:58:41 <LoganCapaldo> yeah
18:58:49 <SamB> but anyway, there is some number "a" for which exp x = a^x and log(exp(x)) = 1
18:59:06 <LoganCapaldo> I'm being silly and trying to fold ++ into the show (or is it the opther way around?)
18:59:34 <liyang|oxfrod> LoganCapaldo: rather than that, look at the definition of the ShowS type.
18:59:39 <monochrom> I think de-classifying your real problem is going to be more fruitful.
18:59:54 <LoganCapaldo> monochrom: I don't have a real problem
18:59:54 <Cale> > shows 5 . (' ':) . shows [1,2,3] $ []
18:59:56 <lambdabot>  "5 [1,2,3]"
19:00:18 <LoganCapaldo> I'm just making life difficult on myself on purpose ;)
19:00:29 <monochrom> No real problem? No purpose behind this?
19:00:35 <Cale> > shows 5 . showString " hello " . shows [1,2,3] $ []
19:00:37 <lambdabot>  "5 hello [1,2,3]"
19:00:54 <SamB> oh...
19:00:54 <LoganCapaldo> monochrom: Well abusing/learning Haskell would be the only purpose
19:01:02 <SamB> actually...
19:01:07 <Cale> SamB: I don't understand how a^x is defined for non-integer x
19:01:13 <SamB> apparantly this is log/exp with WRT x
19:01:18 <SamB> Cale: it ain't
19:01:23 <SamB> those are integer x!
19:01:35 <SamB> these are oddly typed exp/log
19:01:44 <LoganCapaldo> monochrom: I promise I don't have some secret real world problem I'm not telling you guys ;)
19:01:50 <Cale> oh, so exp: Z -> GF(2^n)
19:01:52 <Cale> ?
19:01:56 <SamB> yeah
19:01:59 <Cale> ah, okay
19:02:19 * SamB is now actually looking at his code
19:02:36 * SamB did not know he knew how to use unfoldr
19:02:59 <liyang> LoganCapaldo: so define a ToString class... I mean, if you're familiar with OO lingo, all you're doing there is making some sort of virtual function table.
19:04:00 <emu> ghc internals has an interesting pretty printer class
19:06:34 <SamB> @google "utils/Outputtable.lhs"
19:06:36 <lambdabot> No Result Found.
19:06:41 <SamB> @google "utils/Outputable.lhs"
19:06:44 <lambdabot> http://www.haskell.org/pipermail/cvs-ghc/2002-May/014126.html
19:06:44 <lambdabot> Title: cvs commit: fptools/ghc/compiler/utils Outputable.lhs
19:06:47 <jcreigh> what does lambdabot do if you try to do IO?
19:06:48 <SamB> hmm.
19:06:51 <jcreigh> > putStrLn "Hello"
19:06:52 <lambdabot>  No IO allowed
19:06:54 <jcreigh> ah
19:06:55 <SamB> @google inurl:utils/Outputable.lhs
19:06:57 <lambdabot> No Result Found.
19:07:01 <SamB> @google url:utils/Outputable.lhs
19:07:02 <lambdabot> No Result Found.
19:07:06 <SamB> arg.
19:07:12 <SamB> @google help
19:07:15 <lambdabot> http://www.nytimes.com/membercenter/sitehelp.html
19:07:36 <monochrom> That's funny
19:07:58 <monochrom> overuse of lambdabot is harmful to #haskell
19:13:01 <pkhuong> SamB: I think you have to add a search term when you use options like that.
19:13:09 <jcreigh> @google lambdabot considered harmful
19:13:15 <lambdabot> http://blog.gmane.org/gmane.comp.lang.haskell.cafe?set_skin=zawodny
19:13:15 <lambdabot> Title: gmane.comp.lang.haskell.cafe
19:13:47 <SamB> @google outputable inurl:utils/Outputable.lhs
19:13:49 <lambdabot> No Result Found.
19:17:41 <LoganCapaldo> Hey look at that, I abused it enough for it to finally work
19:18:05 <LoganCapaldo> In conclusion, I shall just "not type show" in the future
19:18:49 <dons> monochrom: serious? what are your concerns?
19:18:58 * dons is interested in keeping lambdabot a good citizen
19:21:04 <mwc> lambdabot makes a good whiteboard for community discussions, but we should encourage people who are trying things out for themselves to do it in private messages
19:21:27 <dons> yes. perhaps we can codify this somehow, so people know
19:21:50 <dons> perhaps 3 failed attempts, or exploration, and they should be directed towards /msg lambdabot @foo ?
19:22:06 <pkhuong> dons: or let people vote via ctcp or privmsgs.
19:22:13 <dons> vote?
19:22:15 <jcreigh> OTOH, it's neat when you try something out, and then somebody shows you a Much Cooler Way To Do It(TM).
19:22:27 <Excedrin> I don't think it's a problem, since it's easy to ignore people talking to the bot and the bot's responses if you someone wants to
19:22:40 <dons> definitely, that's good to see in channel. we want to see the collaborative stuff happening
19:22:59 <mwc> plus somebody's likely to observe something in the convo with lambdabot
19:23:10 <mwc> "You meant foo" or "try bar"
19:23:13 <emu> thats what we need, a real whiteboard which can evaluate expressions drawn on it
19:23:17 <dons> pkhuong: have you experience in other channels with similar kinds of bots?
19:23:27 <dons> #lisp for example?
19:23:28 <pkhuong> dons: no, I was thinking of counter strike :)
19:23:45 <LoganCapaldo> @djinn () -> RealWhiteboardWhichCanVaulateExpressionDrawnOnIt
19:23:46 <lambdabot> -- f cannot be realized.
19:23:57 <emu> i've never seen such a bot problem in #lisp
19:24:01 <pkhuong> #lisp's bot simply ignores people after too many failed commands in too short an amount of time.
19:24:03 <dons> any suggestions on improving the bot, making it nicer in channel, are always welcome
19:24:08 <dons> oh, that's interesting
19:24:14 <dons> but we use social pressure for that
19:24:32 <mwc> so long as social pressure doesn't become "you suck, tard."
19:25:09 <dons> definitely. #haskell should never be like that.
19:25:20 <emu> a combination lisp-paste/lambdabot web site might be nice
19:25:48 <mwc> dons, I tend to use a lot of gratuitous hyperbole, but I certainly thing that there's negative and positve pressure
19:25:58 <mwc> thing/think
19:26:46 <jcreigh> I definitely think lambdabot is a net win...being able to eval code is just so useful. I find myself wishing for a rubybot over in #ruby-lang. Maybe I'll get around to writing one someday.
19:27:09 <dons> how would you solve the side-effects-ate-my-harddrive problem?
19:27:10 <jcreigh> s/eval code/& in channel/
19:27:32 <jcreigh> dons: I was thinking maybe a chroot jail or User Mode Linux or something. I haven't really thought it through.
19:27:51 <pkhuong> dons: I was thinking of that for CL (even worse)... I think a post-parse but pre-eval verification/rewrite pass + chroot would be doable.
19:28:16 <dons> so some kind of purity type check, with chroot for backup?
19:28:19 <Korollary> there are ruby bots already I think
19:28:32 <mwc> why don't you just give the bot absolutely no priviledgs?
19:29:07 <pkhuong> dons: more like control access to functionalities via rewriting.
19:29:15 <sjanssen> pkhuong: couldn't you just limit the names in scope?
19:29:23 <dons> ah, so s/writeFile/dontWriteFile/ ?
19:29:34 <pkhuong> dons: yeah, or intern -> checked-intern
19:29:35 <jcreigh> mwc: well, there's networking and fork bombing, but ulimit should be able to handle those...
19:29:38 <LoganCapaldo> jcreigh: There's corundum in #ruby-lang, he doesn't eval code though AFAIK
19:29:59 <dons> I think any solution is going to approximate a type system though, which is hard to get right.
19:30:07 <dons> its an interesting problem.
19:30:23 <dons> i'd like to write a paper on how we solve it in lambdabot, and contrast with other bots
19:31:06 <mwc> > openFile WriteMode "foo" >>= \h -> hPutStrLn h "bar" >> hClose h
19:31:08 <lambdabot>  Not in scope: `hClose'
19:31:27 <mwc> dons, not trying to screw around, just wanted to see how you handled it
19:31:50 <dons> i.e. lambdabot essentially uses proof-carrying code techniques to have the compiler generate a "No IO" certificate (correct type inference), combined with resource limits and a trusted h98 module base
19:31:50 <sjanssen> > putStrLn ""
19:31:54 <lambdabot>  No IO allowed
19:31:55 <jcreigh> LoganCapaldo: right. evaling is the key. I want <jcreigh> > (1..5).map { |x| x*x } <rubybot> [1,4,9,16,25]
19:32:10 <dons> > readFile "/etc/passwd"
19:32:10 <lambdabot>  No IO allowed
19:32:17 <sjanssen> dons: isn't there just a dummy show instance for IO a?
19:32:28 <mwc> > openFile WriteMode "foo" >>= \h -> hPutStrLn h "bar" >> System.IO.hClose h
19:32:31 <lambdabot>  Not in scope: `System.IO.hClose'
19:32:33 <dons> not for IO a, but there could be. i.e. "No IO allowed" :)
19:32:37 <dons> its not a bad idea.
19:32:41 <dons> > readFile -- for example
19:32:45 <lambdabot>  <[Char] -> IO [Char]>
19:33:09 <sjanssen> dons: how does it work?  Stuff with Data.Typeable?
19:33:16 <dons> the show instance? yes.
19:34:14 <dons> instance (Typeable a, Typeable b) => Show (a -> b) where
19:34:15 <dons>     show e = '<' : (show . typeOf) e ++ ">"
19:35:15 <sjanssen> I was actually talking about the IO restricting stuff, but it's probably best I look at the code instead of asking you vague questions repeatedly ;)
19:35:30 <dons> oh, the IO restriction works like this:
19:35:42 <dons>  a) we show the value the user provides
19:35:47 <dons>  b) there's no show instance for IO
19:35:48 <pkhuong> dons: I was thinking more like control @ the border, especially wrt privilege escalation, and then threads + timer.
19:36:03 <dons> so IO code won't compile
19:36:11 <sjanssen> ah, so lambdabot reads the compilation error
19:36:25 <dons> yes. and maps it to "No IO allowed"
19:36:33 <dons> now it could actually just provide a dummy IO instance
19:36:38 <dons> as we discussed
19:36:51 <dons> show io_action = "Nice try"
19:37:12 <monochrom> dons commanding the bot to show answers in the channel is good, since it's collaborating.  a novice commanding the same is bad, since the novice doesn't know when to stop.  I propose two alternatives.  (A) only selected personnels can cause answers to show in the channel.  (B) by default answers don't show, but there is an undocumented way you can pm to the bot to show in the channel, and so at least novices don't know how to
19:37:12 <monochrom>  do it.
19:37:46 <psykotic> that seems drastic
19:37:51 <dons> hmm, but do you have any statistics pointing to how common rogue newbies go over the top?
19:37:55 <dons> seems too drastic.
19:38:02 <sjanssen> or we could just say to newbies, "hey, lambdabot responds to /msg"
19:38:23 <dons> yeah, i'm thinking of adding a shortcut to @help that prints the /msg command to use
19:38:55 <dons> monochrom: by all means grep the logs, and work out how often newbie command spam happens
19:38:55 <sjanssen> lambdabot could also send an orientation msg when she first 'meets' a user
19:39:00 * Botty 's problem with lambdabot is Botty can never get the syntax right on the first try
19:39:02 <sjanssen> but that could be annoying
19:39:21 <dons> i'm quite happy with it as it is, btw. i've not noticed any noise issues
19:39:23 <lispy> sjanssen: yeah, i find that annoying
19:39:32 <dons> Igloo usually lets me know when lambdabot gets too big for her boots
19:39:33 <pkhuong> dons: sometimes...
19:39:57 <kpreid> dons: I'd go for show io_action = "<IO action>" -- IMO it's mildly misleading to say "No IO allowed" and more informative to point out that the eval did/would succeed but just doesn't do anything but construct an action
19:40:12 <dons> > putStr -- like this?
19:40:15 <lambdabot>  <[Char] -> IO ()>
19:40:20 <Botty> I think that wouldn't be too bad of an idea sjannssen - have the message sent on the first interaction with the bot, and have it be a private message, so it doesn't add more to the chan
19:40:40 <kpreid> dons: yeah, but for type IO just like type ->
19:41:13 * dons trys this
19:41:52 <kpreid> is there a Haskell 98 conformance test suite?
19:42:33 <kpreid> I was idly pondering writing a bizarre evaluator
19:43:36 <dons> yeah, the 'testsuite' has a set of h98 tests
19:44:04 <dons> llambdabot> > readFile "/etc/passwd"
19:44:04 <dons>  <IO [Char]>
19:44:06 <dons> like that guys?
19:44:15 <dons> (that's with the new show instance)
19:44:17 <kpreid> that was what I had in mind
19:45:07 <sjanssen> it is consistent with the function stuff
19:45:29 <psykotic> dons: how does lambdabot currently do its thing wrt IO? does it just black-list unsafePerformIO, etc?
19:45:48 <sjanssen> maybe it should print: RealWord# -> (# Char, RealWord# #) (or however it goes)
19:46:40 <monochrom> that's scary!
19:47:00 <lennart> it should not.  IO is an abstract type
19:47:09 <sjanssen> psykotic: selective imports
19:47:42 <psykotic> sjanssen, right, that's what i figured. he was just talking about proof-carrying code before as if he was doing something out of the ordinary. in the absense of loop holes like unsafePerformIO the type _is_ the proof, you don't have to do anything extra, no?
19:47:53 <olliej> > let fib = 1:1:zipWith (+) fib (tail fib) in take 10 fib
19:47:56 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
19:48:06 <lennart> psykotic: right
19:48:13 <sjanssen> psykotic: right, you just have to avoid all the functions that subvert the type system
19:49:24 <monochrom> Nice!  lambdabot requires users to provide proof-carrying code.  that will solve many problems!  I support it!
19:49:58 <sjanssen> maybe "proof-carrying code" can be our new buzzword?
19:50:16 <dons> exactly, we use the type system for a minimal certifying compiler: it hands out IO-free certificates
19:50:21 <lennart> luckily the proof system has an automatic thm prover
19:50:52 <lennart> the type checker...
19:50:54 <monochrom> It is a simple generalization of "Add a type signature" hee hee hee
19:51:16 <dons> :)
19:51:30 <psykotic> btw something i was considering the other day
19:51:30 <monochrom> The proposed generalization is "Add a type derivation sequent"
19:51:40 <psykotic> proof-carrying code for termination proofs
19:51:57 <dons> being able to establish an arbitrary haskell fragment is IO-free, relying only on the type checker and a trusted module base is a very good property
19:52:03 <dons> one that we should try to keep
19:52:17 <pkhuong> psykotic: remove fix, only allow lexicographically descending ~fix.
19:52:19 <monochrom> Oh, so far PCP proofs are for safety properties.  Termination is a liveness property.  The approaches are quite different.
19:52:21 <dons> (i.e. TH breaks this, since you can splice IO actions in at compile time)
19:52:32 <lennart> psykotic: it would be easy to only have terminating programs type check.  but it takes away some useful things :)
19:52:43 <pkhuong> psykotic: that still leaves the problem that terminating after 30 years isn't really different from not terminating.
19:52:51 <Botty> hehe
19:53:05 <dons> iirc the epigram guys suggested having a separate kind for terminating haskell expressions
19:53:09 <psykotic> pkhuong, sure. actually what i had in mind was removing fix and instead exposing a version of fix with a limit.
19:53:32 <psykotic> so the termination proof would be the upper bound on the number of iterations, expressed as a function of the input parameters.
19:53:36 <lennart> you can have fix in a monad.  just like IO
19:54:02 <pkhuong> psykotic: yeah, and if you have magic conway's arrow or some other notation for huge numbers, you're pretty close to turing complete ;)
19:54:15 <pkhuong> *magic like. Discussed that on ##logic 2 days ago (:
19:54:22 <psykotic> pkhuong, ackermann will do for conway's arrow notation :)
19:54:37 <pkhuong> psykotic: ack is just a short sequence of arrows!
19:54:51 <psykotic> hah!
19:55:01 <monochrom> OTOH PCP for termination can be done this way.  You give the program and the bound.  E.g., (take 10 (repeat 1), 100).  Then lambdabot is happy to try 100 steps and no more.
19:55:18 <dons> monochrom: that's how lamdabot's lambda and pl interpreters work
19:55:36 <dons> ?lam Y I
19:55:40 <lambdabot> out of fuel - use @resume to continue
19:55:43 <dons> @resume
19:55:46 <lambdabot> out of fuel - use @resume to continue
19:55:46 <psykotic> vroom vroom
19:55:49 <dons> :)
19:56:09 <psykotic> iirc in second life they "solve" this problem by just stepping your code at a low rate
19:56:43 <psykotic> dons: looks like you ran lambdabot dry!
19:56:54 <Excedrin> I wrote an x86 asm bot once
19:56:55 <dons> nah, just rebooted to bring in the new IO show instance
19:57:02 <lennart> dons: you should make people pay for fuel
19:57:09 <pkhuong> psykotic: doesn't stop fork bombs from happening, though.
19:57:09 <psykotic> oh right
19:57:21 <SamB> > putStrLn "Hi!"
19:57:23 <psykotic> lennart, fuel should be karma related, surely!
19:57:30 <SamB> psykotic: no
19:57:37 <dons> psykotic: heh
19:57:39 <SamB> because people with lots of karma could do stupid things too
19:57:39 <psykotic> you can buy at the lamdabot's gas station
19:57:50 <SamB> you just have to say @resume...
19:58:02 <psykotic> SamB, that was a joke on my part
19:58:03 <lambdabot>  <IO ()>
19:58:06 <SamB> yeah
19:58:07 <psykotic> a weak one
19:58:11 <SamB> yeah
19:58:12 <dons> > readFile "/etc/passwd"
19:58:15 <psykotic> :)
19:58:15 <Excedrin> it evaled x86 assembly, on freedos, with no safety whatsoever, but it ran under bochs, so it's simply restarted when it broke
19:58:31 <monochrom> why is it so slow?
19:58:34 <kpreid> > map print "hello"
19:58:45 <SamB> Excedrin: heh
19:58:46 <lambdabot>  <IO [Char]>
19:58:46 <dons> freenode seems to kick it around a bit when it first joins
19:58:51 <monochrom> is it because it is reading /etc/passwd and it's long?
19:58:51 <SamB> that sounds pretty safe
19:58:54 <lambdabot>  [<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>]
19:58:57 <SamB> monochrom: hah
19:59:00 <dons> heh.
19:59:03 <SamB> it took long to not print Hi!
19:59:11 <dons> ?bot
19:59:12 <lambdabot> :)
19:59:18 <dons> > map print "hello"
19:59:20 <lambdabot>  [<IO ()>,<IO ()>,<IO ()>,<IO ()>,<IO ()>]
19:59:24 <SamB> > print "hi!"
19:59:26 <lambdabot>  <IO ()>
19:59:32 <Botty> 0-o why's it doing that?
19:59:32 <dons> fine now. its just the lag when the bot first joins
19:59:34 <lennart> mmmmm, i like the new show instance
19:59:36 <SamB> > putStrLn "hi!"
19:59:38 <lambdabot>  <IO ()>
19:59:40 <lennart> makes me nostalic
19:59:42 <dons> :)
19:59:45 <lennart> nostalgic
19:59:45 <SamB> Botty: dons added a Show instance for IO
19:59:52 <Botty> oh cool
20:00:12 <SamB> all it does is show the type in angle brackets, though
20:00:13 <SamB> so...
20:00:28 <SamB> > getContents
20:00:30 <lambdabot>  <IO [Char]>
20:00:35 <Botty> right, so you can't get shtuff.  Can monkey with his system though, right? ;P
20:00:45 <SamB> nope
20:01:14 <lennart> > show ord
20:01:16 <lambdabot>  "<Char -> Int>"
20:01:24 <dons> ah interesting
20:01:53 <dons> lennart: hbi bug for you :)
20:01:53 <dons> > show ord ;
20:01:54 <dons> " GC Unlikely, but may happen, increase heap and try again.
20:01:54 <lambdabot>  Parse error
20:01:54 <dons> Out of heap space
20:02:13 <lennart> dons: hmmmmm
20:02:38 <lennart> I only hack ghc these days
20:02:53 <dons> I know :)
20:03:20 <lennart> perhaps it's time for a new hbc release
20:03:38 <dons> stick the source in darcs perhaps?
20:03:54 <dons> that'd help keep it alive.
20:04:18 <lennart> yeah.  i just have to find the latest version.  it's on some dead machine at chalmers
20:04:51 <lispy> or
20:04:53 <lispy> oops
20:07:23 <lennart> yay, ghc with overloaded strings has recompiled itself
20:07:47 <dons> oh cool!
20:07:49 <sjanssen> lennart: with defaulting too?
20:07:49 <dons> lennart++
20:08:06 <sjanssen> of course defaulting, how else would you manage to compile GHC
20:08:12 <lennart> yeah, without defaulting it fails
20:08:32 <monochrom> This is scary!
20:08:37 <lennart> it doesn't fail much without defaulting, though
20:08:38 <lispy> lennart: so this allows you to (in theory) drop in bytestring or similar anywhere we see strings?
20:08:49 <dcoutts> no
20:09:00 <lennart> lispy: only string literals are overloaded
20:09:09 <dcoutts> besides, the problem is the semantics
20:09:09 <lennart> not the functions operating on them.
20:09:13 <lispy> hmm...what does this overloading mean?
20:09:37 <lennart> it means "foo" :: (IsString a) => a
20:10:01 <lennart> so you can use ordinary string liters with other things than [Char]
20:10:10 <lispy> okay
20:10:14 <lispy> very cool
20:10:50 <dcoutts> so it'd help to make using packed strings easier
20:11:19 <dylan> woot!
20:11:21 <dcoutts> since you wouldn't have to use pack on literals
20:11:49 <lennart> yep
20:14:23 <dylan> lennart> pattern matching too? :)
20:14:36 <lennart> of course
20:14:48 <dylan> lennart> And you're responsible for this?
20:15:14 <lennart> yeah, a couple of nights of hacking
20:15:32 <lispy> lennart: so you could say foo (x:xs) = x, and it would work with bytestring as well as [Char] ?
20:15:41 <dylan> you deserve a beer or (or a pet monkey if you don't drink)! :-D
20:15:47 <lennart> lispy: no
20:16:00 <lispy> lennart: then what do you mean by pattern matching?
20:16:09 <lennart> f "foo" = 5
20:16:15 <dylan> lispy> things like handleCommand "FOO" = ...
20:16:39 <lennart> strings are matched like numbers, by comparing for equality
20:16:42 <lispy> lennart: and so it desugars differently depending on the underlying string rep?
20:16:52 <lennart> lispy: yes
20:17:22 <lennart> it normally desugars to a test with ==, but [Char] is special
20:18:03 <lispy> makes sense
20:18:07 <lennart> (doesn't have to be special, but there were already hooks for it)
20:19:03 <sjanssen> lennart: how is it special?
20:19:51 <dylan> I hope ByteString replaces String entirely some day. ;)
20:20:13 <sjanssen> dylan: eh, String can be very elegant
20:20:30 <dylan> True.
20:20:34 <dons> just having bytestring literals is a big improvement
20:20:45 <dons> we can wait for a Views push to get pattern matching too...
20:20:49 <Korollary> the string vs bytestring is a fundamental problem. We're not going to invent special modules for every data type we can need.
20:20:50 <dons> dcoutts: want to write a paper :)
20:20:59 <lennart> sjanssen: it's only special in the sense that it falls back on the old string pattern matching code.  which i'm not sure what it does :)
20:21:10 <dylan> it'd be nice if foo (x : xs) = ... desugared to 'uncons'  the bytestring.
20:21:30 <lennart> dylan: that's a totally different problem
20:21:31 <sjanssen> dylan: this is what dons was hinting at with "Views"
20:21:40 <dylan> lennart> indeed, I suspect it's a magic problem.
20:22:01 <lennart> yeah, you can do it with views
20:22:31 <dylan> I actually unpack some (short) strings in my chat client, so I can do handle "foo" args = ...
20:23:16 <dylan> where args :: [ByteString]
20:24:52 <sjanssen> though promoting (:) pattern matching with ByteString might be a bad idea, (:) is a terribly slow way to construct ByteStrings
20:25:05 <dylan> True.
20:25:40 <lennart> but deconstructing with : should be fast
20:25:51 <dylan> I ought to post my unescaping code to see about making it more efficient than pack . unescapeL . unpack...
20:26:18 <dylan> probably should just some sort of regexp.
20:26:27 <lispy> views have been around ages, why haven't they been added to haskell yet?
20:26:40 <lispy> seems like everyone agrees they'd be handy
20:27:16 <lennart> lispy: i implemented them in hbc over 10 years ago :)
20:27:29 <lispy> lennart: exactly!
20:27:40 * lispy glares at ghc
20:27:50 <lennart> but they never became popular
20:28:13 <sjanssen> any insights as to why they never took off?
20:29:22 <lispy> i would also like to see reinstancing allowed
20:29:29 <dons> sjanssen: we didn't have a bytestring v String problem
20:29:34 <dons> so views seemed like overkill
20:29:41 <dons> but now we have a really good use case
20:29:42 <lispy> so that i can have a module which makes Num [Int] mean one thing and a different module that makes Num [Int] mean something else
20:29:58 <dons> yeah, and deconstructing a bytestring with (x : xs) is really fast
20:29:59 <sjanssen> so generic code wasn't as important back in the day?
20:30:38 <dons> I'm only guessing why they never took off. lennart would have more insight on that, being the author of the only haskell compiler to actually provide views... :)
20:31:05 <lennart> dons: I don't really know
20:31:15 <lennart> i never used them myself either :)
20:31:21 <psykotic> hah!
20:31:42 <dons> Cale needs to come up with a good use case for monad comprehensions, like "C# can do something Haskell can't" . that'd get monad comprehensions back quick smart too...
20:32:02 <lennart> lispy: allowing different instances in different scopes is a road towards madness
20:32:23 <lennart> lispy: unless you can pass instances explicitly
20:32:44 <emu> does that include "comprehending monads?"
20:33:21 <lennart> but haskell has do notation.  it looks as much as the C# monads as the list comprehensions do.  i.e., not at all
20:33:59 <dons> yeah :)
20:34:10 <pkhuong> C# has monads? I'm getting old.
20:34:38 <lennart> C# has something like list comprehensiopns
20:34:50 <lennart> except they are monad comprehensions
20:35:23 <lennart> but since C# lacks higher kinded type variables you can't wrtite any code that works with any monad
20:35:28 <lennart> so they are still behind
20:35:33 <dons> http://research.microsoft.com/~emeijer/Papers/XLinq%20XML%20Programming%20Refactored%20(The%20Return%20Of%20The%20Monoids).htm
20:35:35 <lambdabot> Title: XLinq: XML Programming Refactored (The Return Of The Monoids), http://tinyurl.com/yd462e
20:35:40 <dons> thank you tiny url
20:35:55 <dons> oh, also, http://www.idealliance.org/xmlusa/05/call/xmlpapers/63.1015/.63.html#S4.
20:35:55 <pkhuong> thank you.
20:35:57 <lambdabot> http://tinyurl.com/y7r3q8
20:37:36 <dons> yeah, Cale pointed this out a couple of days ago: http://programming.reddit.com/info/qw12/comments/cqxnl?context=5
20:37:39 <lambdabot> Title: The New Lambda Expressions Feature in C# 3.0 (reddit.com), http://tinyurl.com/y4gmwt
20:37:48 <dons> "LINQ doesn't quite seem to provide full monad comprehensions. In fact, it looks an awful lot like ordinary list comprehensions, combined with a bunch of the standard List library from Haskell"
20:39:09 <Korollary> whoa. mlton compiles itself under 5 minutes. Heh.
20:39:23 <dons> oh? via C?
20:39:32 <Korollary> doesnt say
20:39:35 <dons> (GHC compiles via C in about 12 minutes too)
20:39:38 <Korollary> http://mlton.org/pages/References/attachments/060916-mlton.pdf
20:39:43 <lambdabot> http://tinyurl.com/y2tqpl
20:39:50 <dons> actually, probably a lot faster than that now with a decent multicore box and -j8
20:39:56 * dons notes down to try this
20:39:58 <Korollary> that's cheating
20:40:00 <pkhuong> dons: the key point is that full-program compilation is still realistic.
20:40:04 <dons> yeah
20:40:11 <dons> I know, I know ;)
20:40:25 <Korollary> Does anyone have any nifty STM examples with SMP?
20:41:20 <dons> there's some examples on the wiki, not sure if they've been tried with the -N smp flag
20:41:30 <dons> I suspect there's some in the multicore/smp paper...
20:41:43 <dons> http://www.haskell.org/~simonmar/papers/multiproc.pdf
20:41:46 <lambdabot> http://tinyurl.com/ymjxs2
20:42:42 <sieni> Korollary: you can probably port any heavy duty mutex masturbation code to STM relatively easily.
20:43:14 <Korollary> sieni: I don't have any such masturbation handy.
20:43:48 <Korollary> ok you can stop vomiting now.
20:46:18 <monochrom> Do some dining philosophers :)
20:46:59 <Korollary> Hah. The mlton slides mentions Haskellton and ocamlton as future projects.
20:47:58 <pkhuong> Korollary: heh. clton would be neat ;)
20:48:26 <pkhuong> (we already have Stalin(ton))
20:48:31 <sieni> pkhuong: I could do that
20:48:52 <pkhuong> sieni: hack away.
20:48:57 <psykotic> mlton is about five orders of magnitude faster than stalin though :)
20:49:17 <sieni> pkhuong: oops, I parsed that as C-lton, not CL-ton :-)
20:49:37 <sieni> pkhuong: I would have just used gcc as a back end ;-)
20:49:46 <lispy> what is ton?
20:49:56 <pkhuong> sieni: surely you mean icc! :p
20:50:27 <emu> doesn't someone have a whole-program analysis module that fits on top of ghc?
20:51:12 <Korollary> ghc does cross-module, but not whole program optimizations iirc.
20:51:20 <emu> it was a project i read about
20:55:04 <lispy> what does whole program analysis really mean?
20:56:26 <Korollary> it's the opposite of separate compilation of modules into an exe.
20:56:33 <lispy> or let me ask this, since you can't solve the halting problem, how much does it really help to look at the whole program?
20:57:10 <Korollary> it's not about the HP.
20:57:40 <sieni> lispy: it's about optimization
20:58:09 <monochrom> More inlining opportunities, and therefore more CSE or fusion or ... opportunities.
20:58:11 <sieni> lispy: check some papers from MLton site or the Stalin paper
20:58:47 <pkhuong> lispy: also, you can monomorphise everything, so no *need* to box anything.
20:59:38 <monochrom> Does HP sell HP machines?  XD
20:59:55 <lispy> what about saving the whole program stuff for run-time?
21:00:13 * monochrom looks for an HP Laserjet III.  May solve Sigma_3 problems :)
21:00:44 <monochrom> That would be JIT, but no one seems to have done that to FP yet.
21:00:56 <Korollary> that's one big JIT
21:00:59 <dons> jhc does whole program analysis, though, right?
21:01:18 <pkhuong> lispy: what would you do with that, and what would be gained VS doing it at compile-time?
21:01:19 <Korollary> dons: I don't know, but from what I read it had better for that kind of memory usage ;)
21:01:58 <Korollary> happy 10th birthday, xml.
21:02:07 <monochrom> Oh nice!
21:02:12 <lispy> pkhuong: i was thinking about your monomorphic comment and then wondering about libraries with polymorphic apis
21:02:41 <pkhuong> lispy: probably easier to use explicit staging for that sort of library, if performance sensitive.
21:03:06 <sieni> Korollary: is it that old?
21:03:11 <sieni> Korollary: AM I THIS OLD?!?!?!
21:03:30 <lispy> in another decade we'll have to tree xml like an adult
21:03:39 <lispy> instead of the brat it is :)
21:03:41 <Korollary> sieni: You are one old fart.
21:04:14 <Korollary> yeah, wikipedia says Nov 1996
21:04:37 <emu> and then there's sgml
21:04:44 <mwc> XML is like violence. If it doesn't work, use more.
21:05:12 <Korollary> I'll use that one
21:05:38 <robreim> ?remember mwc XML is like violence. If it doesn't work, use more.
21:05:45 <emu> pointy too
21:12:43 <Korollary> Jeebus. http://www.oasis-open.org/cover/thml.html
21:12:46 <lambdabot> Title: Cover Pages: Theological Markup Language (ThML)
21:18:55 <emu> is that for cross-cultural communication?
21:19:14 <vincenz> moin
21:22:12 <Korollary> emu: I don't know. I just didn't know that there was such a 'need'.
21:22:20 <emu> heeh
21:22:30 <emu> XML is a solution in search of a problem
21:24:29 <Korollary> I especially love it when they use it sans a schema/dtd. It's essentially open to your choice of interpretation.
21:34:36 <robreim> Hmm... could a plugin for hs-plugins be written in, say, C?
21:39:20 <dons> yep
21:39:45 <dons> any language which can compile to .o files, and has an ffi binding from haskell will work
21:40:25 <dons> I'm working on a project now where the haskell program generates C code at runtime, compiles it with arch-specific flags, loads it back into haskell, and jumps to this runtime-specialised C code)
21:40:41 <pkhuong> dons: oh neat :)
21:41:40 <dons> the "haskell" program ends up running 4x faster than the standalone C program
21:41:52 <dons> since it can be runtime specialised and filled up with compiled in constants
21:42:04 <dons> basically haskell is used as a C-generating EDSL
21:43:02 <vincenz> how do you jump somewhere/
21:43:40 <vincenz> a standard name for the init?
21:43:51 <dons> do f <- load "my.o" ; f
21:44:03 <dons> yeah, you know the entry point
21:44:07 * vincenz nods
21:44:20 <vincenz> @hoogle load
21:44:21 <lambdabot> System.Win32.DLL.loadLibrary :: String -> IO HINSTANCE
21:44:22 <lambdabot> System.Win32.DLL.loadLibraryEx :: String -> HANDLE -> LoadLibraryFlags -> IO HINSTANCE
21:44:22 <lambdabot> System.Win32.DLL.lOAD_LIBRARY_AS_DATAFILE :: LoadLibraryFlags
21:44:28 <dons> but you can pass arbitrary entry points if you want
21:44:35 <dons> by having a distinguished C function:
21:44:36 <dons> void apply(void (*f)(void)) {
21:44:36 <dons>     f();
21:44:36 <dons> }
21:44:52 <dons> which you call from Haskell:
21:44:53 <dons>     start <- getCPUTime
21:44:53 <dons>     withStatus "Handing control to C" $ apply f
21:44:53 <dons>     end   <- getCPUTime
21:45:19 <dons> you load a C object, getting back a function ptr to a C function, which you run by ffi-calling into apply, passing the function
21:45:20 <vincenz> how does apply get bound
21:45:28 <dons> foreign import
21:45:28 <vincenz> oh right
21:45:36 <dons> foreign import ccall unsafe "apply.h apply"
21:45:36 <dons>    apply :: Ptr () -> IO ()
21:45:56 <dons> we'll have a paper on this soon
21:46:17 <dons> its kind of a nice trick for side stepping the GHC code generator ;)
21:46:27 <dons> just generate your own C code and run it, if you know a better way to solve the problem
21:46:57 <robreim> dons: (sorry, got pulled away) that sounds really cool. Is any of the code in darcs?
21:48:00 <emu> http://www.cse.unsw.edu.au/~dons/code/hs-plugins/
21:48:02 <lambdabot> Title: Index of /~dons/code/hs-plugins, http://tinyurl.com/yxk9vb
21:48:03 <dons> its not public at the moment (possibly commercial options, I guess) but that's the basic technique
21:48:11 <dons> yeah, hs-plugins is online of course
21:49:41 <emu> could hs-plugins be used to implement some kind of dynamic recompilation for development of applications
21:50:00 <dons> yeah, see the first hs-plugins paper
21:50:01 <eviltwin_b> hm, "broken on mac"
21:50:03 <dons> (we do just this)
21:50:11 <dons> eviltwin_b: hs-plugins?
21:50:14 <eviltwin_b> yeh
21:50:18 <dons> (the darcs version is fixed on the mac)
21:50:41 <eviltwin_b> (and yes, extra underscores.  more modern unixlikes don't do that any more, but OSX is still showing its origins)
21:50:47 <dons> its fixed though
21:50:53 <eviltwin_b> ah
21:51:00 <dons> grab the darcs repo
21:51:14 <eviltwin_b> I presume it also works with 6.6?  last time I tried to build it it was very unhappy
21:51:34 <dons> nope. not yet. FAQ :)
21:51:53 <dons> lesson: linkers are a little tricksy and need tender love and care
21:51:56 <dons> dynamic linkers more so
21:52:01 <eviltwin_b> yes, yes they do
21:52:28 <eviltwin_b> especially on odd platforms (mmm, AIX4... so glad I don't need to deal with it any more)
21:53:33 <robreim> how is the 6.6 port anyway? Got an updated ETA?
21:53:57 <robreim> I'm guessing not "end of this week" after all ;)
21:54:07 <dons> i'll try to get it out this weekend
21:54:48 <robreim> sweet. That's got to be worth at least a point of karma from each person awaiting it :)
21:55:02 <skew> at least
21:55:12 <eviltwin_b> dons++
21:55:17 <robreim> then all we need is a way to buy food and shelter with karma points
21:55:18 <dons> hehe. *wait* till its ported
21:55:30 <dons> yeah, an entire economy of karma
21:55:31 * eviltwin_b is not in the habit of karma-ing on IRC, it's been a few years
21:55:43 <skew> except I'm going on vacation for a while, so dons will need to wait a bit for my karma
21:55:51 <robreim> the karma LETS scheme
21:56:04 <skew> I have some notions about mobile code with hs-plugins I'm itching to try out
21:56:04 <eviltwin_b> well, that one was for the darcs hs-plugins for mac.  6.6 will get another one :)
21:56:23 <dons> heh
21:57:11 <glguy> ?seen Cale
21:57:12 <lambdabot> Cale is in #oasis, #ghc and #haskell. I don't know when Cale last spoke.
21:57:23 <glguy> hmm... lambdabot was reset recently?
21:57:48 <glguy> ?uptime
21:57:48 <lambdabot> uptime: 2h 1m 13s, longest uptime: 7d 1h 24m 44s
21:58:51 <dons> glguy: yep
21:58:53 <glguy> ?version
21:58:54 <lambdabot> lambdabot 4p272, GHC 6.5 (OpenBSD i386)
21:58:54 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:58:58 <dons> > putStrLn "foo" -- for this
21:58:59 <lambdabot>  <IO ()>
21:59:29 <glguy> oh, you just announce the type of IO operations instead of executing them?
22:00:07 <glguy> Was that your own idea?
22:00:25 <dons> sjanssen suggested it
22:00:34 <dons> sjanssen++
22:00:34 <Korollary>   > return 'a' :: IO Char
22:00:40 <Korollary> > return 'a' :: IO Char
22:00:42 <lambdabot>  <IO Char>
22:01:05 <Korollary> > getChar
22:01:06 <lambdabot>  <IO Char>
22:01:24 <glguy> ah, good job sjanssen ... that seems so obvious now
22:01:41 <glguy> which is why it seems so brilliant ;)
22:01:44 <dons> yeah :)
22:01:54 <Korollary> Elementary, dear Watson.
22:01:55 <robreim> what a bloody easy way to secure haskell code, eh?
22:02:14 * vincenz wishes it'd be possible to have holes in haskell structures
22:02:28 <dons> yeah, one line: instance Typeable a => Show (IO a) where show io = "<" ++ (show . typeOf) io ++ ">"
22:02:44 <skew> vincenz: you could try some evil with unsafePerformIO and MVars
22:05:04 <robreim> does lambdabot know not to use unsafePerformIO?
22:05:35 <vincenz> skew: that wouldn't work
22:05:44 <skew> depends what you mean by hole
22:06:02 <vincenz> as in a partially defined structure
22:06:14 <vincenz> data Tree a = Leaf | Branch a (Tree a) (Tree a)
22:06:20 <dons> robreim: yep
22:06:20 <vincenz> Branch 1 Leaf [
22:06:22 <vincenz> Branch 1 Leaf []
22:06:24 <skew> oh, then you probably want zippers
22:06:28 <vincenz> [] being a hole
22:07:24 <robreim> > unsafePerformIO $ putStrLn "Stop This"
22:07:25 <lambdabot>  Not in scope: `unsafePerformIO'
22:08:22 <robreim> cool. Folks back in the day of CGI would have loved that.
22:08:59 <robreim> ?elite say something "elite"
22:09:00 <lambdabot> Say z0M37|-|ING "3lI+e"
22:09:04 <robreim> heh
22:09:23 <robreim> oh man, this thing even has figlet?
22:09:47 <robreim> ?figlet test
22:09:47 <lambdabot> Unknown command, try @list
22:10:18 <robreim> @list
22:10:18 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
22:10:38 <glguy> lol when did lambdabot start using a URL for list?
22:11:15 <eviltwin_b> presumably when the list got big enough to trigger flood suppression
22:11:15 <robreim> good idea though. I was thinking anything like figlet or anything else that returned things multi-line could be used as a half-arsed DoS
22:12:36 <olliej> Saulzar: boo
22:13:26 <robreim> ?babel english german hello
22:13:28 <lambdabot>  hallo
22:13:49 <robreim> ?babel english spanish hello world
22:13:51 <lambdabot>  hola mundo
22:13:52 <vincenz> @babel english german You damned pig
22:13:53 <lambdabot>  Sie verdammten Schwein
22:13:59 <robreim> LoL
22:14:19 <glguy> @
22:14:25 <glguy> @y
22:14:26 <lambdabot> Maybe you meant: yarr yhjulwwiefzojcbxybbruweejw yow . v
22:14:34 <glguy> ?yhjulwwiefzojcbxybbruweejw
22:14:35 <lambdabot> Just 'J'
22:14:46 <glguy> ?help yhjulwwiefzojcbxybbruweejw
22:14:46 <vincenz> ?yhjulwwiefzojcbxybbruweejw
22:14:47 <lambdabot> V RETURNS!
22:14:47 <lambdabot> Just 'J'
22:14:49 <vincenz> ?yhjulwwiefzojcbxybbruweejw
22:14:50 <lambdabot> Just 'J'
22:14:52 <vincenz> oh yeah
22:14:54 <vincenz> > 1+ 1=
22:14:55 <lambdabot>  Parse error
22:14:56 <vincenz> ?yhjulwwiefzojcbxybbruweejw
22:14:57 <lambdabot> "\""
22:15:20 <eviltwin_b> "gesundheit"
22:15:31 <glguy> wtf is that command for?
22:15:38 <vincenz> history
22:16:17 <robreim> ?babel german english gesundheit
22:16:18 <lambdabot>  health
22:17:33 <vincenz> bless you
22:18:58 <glguy> We will perhaps eventually be writing only small modules which are identified by name as they are used to build larger ones, so that devices like indentation, rather than delimiters, might become feasible for expressing local structure in the source language.
22:19:04 <glguy> Donald E. Knuth, "Structured Programming with goto Statements", Computing Surveys, Vol 6 No 4, Dec. 1974
22:19:04 <vincenz> ack
22:19:06 <vincenz> deja vu
22:19:11 <glguy> redddit?
22:19:17 <dons> @tell bringert HWN headilnes now available as a4 .pdf files: http://www.cse.unsw.edu.au/~dons/code/hwn/archives/20061114.pdf
22:19:17 <sjanssen> glguy: if you're really curious, http://tunes.org/~nef/logs/haskell/06.04.09
22:19:18 <lambdabot> Consider it noted.
22:19:22 * vincenz winces
22:20:24 <glguy> sjanssen: which part
22:20:33 <sjanssen> glguy: but to make a long story short, v was this little artifact of the Haskell execution stuff in lambdabot
22:20:54 <sjanssen> "> E" changes into "let v = show E in v"
22:21:12 <sjanssen> so if E == v, you get infinite quotings of a string
22:21:18 <sjanssen> and other bizarre behavior
22:21:39 <sjanssen> the channel spent several hours puzzling over this, it was quit humorous
22:22:10 <glguy> ahhh
22:22:13 <glguy> > E
22:22:14 <lambdabot>  Not in scope: data constructor `E'
22:22:15 <sjanssen> glguy: the first mention I see is at 11:25
22:22:18 <jgrimes> haha, yeah reading over it is funny.
22:22:20 <glguy> ok, I'll scroll down
22:22:32 <glguy> > v
22:22:33 <lambdabot>  Not in scope: `v'
22:22:34 <sjanssen> it goes on for hours and hours
22:23:11 <glguy> but where did the name of that command come from?
22:23:17 <sjanssen> glguy: when dons caught word of this bug, he changed it to some other variable (yhjulwwiefzojcbxybbruweejw, naturally) and we discovered it again
22:23:30 <dons> :)
22:23:38 <jgrimes> haha
22:23:38 <dons> security through obscurity doesn't work!
22:23:42 <sjanssen> and then dons got fed up and added a proper randomly generated identifier
22:23:55 <sjanssen> > let f x = x + 1 in show f
22:23:56 <lambdabot>  Add a type signature
22:24:17 <glguy> why does it need to exist?
22:24:30 <sjanssen> ah, looks like the regexps that filter the compiler errors have been fixed since then
22:24:38 <sjanssen> glguy: like vincenz says, history
22:25:10 <dons> its part of our cultural memory now :)
22:26:02 <sjanssen> maybe yhjulwwiefzojcbxybbruweejw would make a good #haskell shirt
22:26:17 <glguy> > fix show
22:26:18 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
22:27:11 <sjanssen> > let e = fromDynamic $ fromJust $ dynApply (toDyn (head :: String -> Char)) (toDyn v) :: Maybe Char; v = show e in v
22:27:13 <lambdabot>  "Just 'J'"
22:27:50 <sjanssen> that's when I became truly paranoid about v ;)
22:28:58 <vincenz> V of vendetta?
22:29:21 <dons> sjanssen: that rocks, I don't remember that trick..
22:31:25 <jgrimes> > let e = fromDynamic $ fromJust $ dynApply (toDyn (show::String -> String)) (toDyn v) :: Maybe Char; v = show e in v
22:31:27 <lambdabot>  "Nothing"
22:32:06 <skew> > let v = show e; e = Just (head v) in v
22:32:08 <lambdabot>  "Just 'J'"
22:32:30 <skew> ?pl let v = show e; e = Just (head v) in v
22:32:30 <lambdabot> snd (fix (uncurry (flip ((,) . Just . head) . show)))
22:32:40 <skew> > fix (Just . head . show)
22:32:42 <lambdabot>  Just 'J'
22:33:04 <skew> > fix (Show . just . head)
22:33:05 <lambdabot>  Not in scope: `just'
22:33:11 <skew> > fix (show . Just . head)
22:33:13 <lambdabot>  "Just 'J'"
22:37:55 <Excedrin> <dons> yeah, an entire economy of karma
22:37:59 <Excedrin> http://www.epiphyte.net/SF/old-fashioned-future.html
22:38:03 <lambdabot> Title: Bruce Sterling: A Good Old-Fashioned Future, http://tinyurl.com/y7un92
22:38:27 <Excedrin> that statement reminded me of Maneki Neko by Bruce Sterling
22:48:26 <dons> @tell bringert PDF headline posters for the last 5 HWN's are in the archive, future posters will appear there on publishing day, http://www.cse.unsw.edu.au/~dons/code/hwn/archives/
22:48:27 <lambdabot> Consider it noted.
22:48:52 <dons> also, anyone else who wants to put up the HWN in their office or desk, feel free to grab the pdfs :)
22:49:05 * dons now has the HWN on his office wall. it's like Press Gang!
23:00:13 <glguy> dons: You know the new type-system changes that Simon announce on the mailing list?
23:00:55 <glguy> announced*
23:01:13 <dons> yep
23:01:26 * dons finally got up enough courage to suggest deprecating fromJust on the list
23:01:37 <glguy> =/
23:01:53 <glguy> (I was wondering if you knew how long it would take for those changes to appear ina stable release)
23:02:01 <dons> they'll be in ghc 6.8
23:02:33 <glguy> so are you suggesting that head and deprecated as well?
23:02:50 <glguy> s/and/be
23:03:04 <dons> nope
23:03:07 <dons> just fromJust
23:03:19 <glguy> OK, how come one and not the other
23:03:20 <Heffalump> how would you suggest replacing it?
23:03:24 <dons> and only that it be deprecated (i.e. you get a compiler warning if you want to use it)
23:03:42 * Heffalump thinks that's silly
23:03:46 <dons> I suggest: maybe, fromMaybe and let Just x = ..., all of which provide better information on Nothing
23:04:15 <dons> having ghc do something more useful on 'error' would be another option
23:04:15 <glguy> dons: ok, but why do that to fromJust and not head?
23:04:15 <Heffalump> @type (maybe, fromMaybe)
23:04:15 <lambdabot> forall b a a1. (b -> (a -> b) -> Maybe a -> b, a1 -> Maybe a1 -> a1)
23:04:25 <dons> > fromJust Nothing
23:04:26 <lambdabot>  Add a type signature
23:04:26 <Heffalump> fromMaybe (error "foo") is just annoying though
23:04:29 <dons> > fromJust Nothing :: Maybe ()
23:04:31 <lambdabot>  Exception: Maybe.fromJust: Nothing
23:04:36 <glguy> > head [] :: ()
23:04:38 <lambdabot>  Exception: Prelude.head: empty list
23:04:41 <dons> fromMaybe (assert False) -- not so bad
23:04:47 * Heffalump is with glguy
23:04:51 <Heffalump> when did assert appear?
23:04:58 <dons> hmm, 10 years ago? :)
23:05:03 <Heffalump> oh :-)
23:05:11 <Heffalump> > assert False
23:05:12 <lambdabot>  Not in scope: `assert'
23:05:19 <glguy> ?type assert
23:05:20 <lambdabot> Not in scope: `assert'
23:05:44 <glguy> head should be : foldr const (assert False) ?
23:06:29 <glguy> > foldr const (assert False) [1,2]
23:06:29 <lambdabot>  Not in scope: `assert'
23:06:41 <glguy> > foldr const (undefined) [1,2]
23:06:42 <lambdabot>  1
23:06:45 <glguy> > foldr const (undefined) []
23:06:46 <lambdabot>  Add a type signature
23:06:54 <glguy> > foldr const (undefined) ([] :: [()])
23:06:56 <lambdabot>  Undefined
23:07:29 <dons> anyway, I'm not going to push it, but this is a nice solution for serious applications:
23:07:33 <dons> fromMaybe (failure assert "fromMaybe died")
23:07:34 <dons> $ runhaskell A.hs
23:07:34 <dons> *** Exception: A.hs:5:34-39: fromMaybe died
23:07:37 <dons>                          (Nothing :: Maybe ())
23:07:52 <dons> compared to:
23:07:52 <dons> $ runhaskell A.hs
23:07:52 <dons> *** Exception: Maybe.fromJust: Nothing
23:07:53 <vincenz> re
23:08:19 <dons> ghc should tag errors with call site locations, that'd be enough for most people
23:08:39 <glguy> fromJust requires the programmer to prove that it is correct to use fromJust, just like instances Monad requires the programmer to ensure that their implementation satisfies the monad laws
23:08:55 <glguy> some things just exist outside of the language...
23:09:02 <glguy> oh well
23:09:09 <dons> the problem is that fromJust isn't discouraged as much as it should be
23:09:12 <glguy> no sense arguing over it, our points are made :)
23:09:14 <Heffalump> why not just get ghc improved so some functions report errors at their call site?
23:09:14 <dons> in that newbies tend to use fromJust
23:09:20 <dons> they tend *not* to roll their own monad laws
23:09:26 <dons> Heffalump: that'd do
23:09:31 <dons> and its happening :)
23:09:38 <glguy> Things like this are why we lost monad comprehensions :(
23:09:41 <dons> sheesh, I knew I shouldn't have suggested it
23:09:42 <Heffalump> then don't deprecate fromJust as an interim measure :-p
23:10:08 <dons> the comments about fromJust should threaten serious consequences then :)
23:10:22 <Heffalump> I still don't follow why you hate that and not head.
23:10:35 <dons> fromJust is an easy target.
23:10:41 <dons> head is a bit harder to discourage..
23:10:47 <Heffalump> so how does assert work, anyway?
23:11:01 <dons> Heffalump: there's a *giant* thread on haskell-cafe about this, which all my comments are implicitly in the context of
23:11:15 <dons> it throws an exception with ghc magically inserting src loc info
23:11:16 <Heffalump> ah
23:11:18 * glguy read most of the thread yesterday
23:11:21 <Heffalump> too high volume for me to read that normally :-(
23:11:26 <Heffalump> I should start again really.
23:12:20 <glguy> the newbie training wheels should require a --newbie-training-wheels flag ;)
23:12:39 <Korollary> I abuse fromJust left & right
23:12:41 <skew> 9~
23:54:01 <lispy> i think haskell has ruined me
23:54:16 <emu> yep
23:54:17 <lispy> imperative languages are getting harder to code in!
23:54:24 <Heffalump> :-)
23:54:25 <emu> you can never go back
23:54:30 <emu> bahahahaha
23:54:41 * emu probes some stupid java code
23:55:04 <lispy> part of my problem is that i'm a complete n00b in scaal
23:55:05 <lispy> er scala
23:55:17 <pkhuong> I just spent 90 minutes writing ASM for the most gimped imaginary ISA ever. Don't you dare complain about java :p
23:55:32 <psykotic> pkhuong, a minsky machine? :)
23:56:24 <Heffalump> what are you using scala for?
23:56:30 <emu> actually, it's more about waht i can't fix, because it's in some crazy proprietary library which abuses jini and rmi or something
23:56:52 <pkhuong> psykotic: the `Little Man Computer'. No stack, no indirect addressing, no literals. Self modifying code for everything. Actually, the author deliberately made it so that HLL would be obviously better. I don't think they expected me to write fortran-style subroutines.
23:57:22 <emu> hmm fun
23:57:31 <psykotic> no indirection? yeah then you need self-modifying code for control flow. heh, fun.
23:57:36 <emu> that's sorta like early computers
23:58:08 <pkhuong> google it, the images are particularly amusing (and the metaphor) -- intro to arch.
23:58:45 <pkhuong> psykotic: bah, 'sok, redcode was my second language ;)
