00:00:16 <astrolabe> Machines are a bit crap in a lot of ways
00:00:20 <gour> dons: #haskell.hr is now in the lisppaste's channel list (http://paste.lisp.org/channels) can you fix  "@where paste" to give proper url?
00:00:26 <monochrom> No.  I read one too many anti-AI argument and found it completely circular.  This argument comes from "the archenemy of AI", supposedly the most well-thought out.
00:01:29 <zptao> no, you read too many scifi books and need to get out more
00:01:54 <astrolabe> If I could, I'd write a computer program to do my job.  It would accept email tasking, and would email out reports and computer programs it had written.
00:02:00 <monochrom> I also carefully phrase the neutral "compare", not denying that there may be difference.
00:02:28 <pzpz> 'gday all
00:03:09 <astrolabe> humans are so arrogant as to refuse to compare themselves with bricks.  Bricks are much better at holding house roofs in place.
00:03:29 <dolio> Huzzah, my ghci is now vi-like.
00:03:33 <Adamant> I think an AI can be built, I just think it's not gonna happen in my natural lifetime
00:03:37 <lispy> dolio: what does that mean?\
00:03:38 <dolio> monochrom++
00:03:52 <pzpz> i see far more bricks refusing to compare themselves to humans than i see the reverse.
00:04:03 * lispy thinks he's just walking into #ai_debate
00:04:14 <dolio> It means that I can use escape to enter movement mode, use hjkl to move around...
00:04:20 <Adamant> shall I compare thee to a summer's brick?
00:04:29 <dolio>  / for search
00:04:32 <dolio> Etc.
00:04:39 <lispy> dolio: neat
00:04:52 <lispy> dolio: is this on the wiki somewhere?
00:05:00 <pzpz> M x shell :)
00:05:14 <dolio> It's in some docs I found for GNU readline somewhere.
00:05:27 <monochrom> wiki wiki wiki
00:05:41 <lispy> the wiki wiki web
00:08:09 <pzpz> any ideas why after installing ghc6.6, hmp3 still refuses to build?
00:08:35 <dolio> In case anyone's interested, the method is to add "set editing-mode vi" to your ~/.inputrc
00:09:13 <musasabi> @pl ptrop 1 . flip poke
00:09:15 <lambdabot> ptrop 1 . flip poke
00:09:16 <pzpz> Setup.hs: cannot satisfy dependency fps>=0.7, isn't thi sincluded in ghc6.6?
00:09:40 <vegai> pzpz: yeah, but it isn't called that anymore ;/
00:09:43 <musasabi> pzpz: it is included in 6.6 base package - just remove the dep.
00:10:44 <pzpz> vegai, musasabi: that worked --ty
00:11:10 <dons> pzpz: yeah, just remove the dep on fps
00:11:18 <dons> let me know how you like it :)
00:11:38 <pzpz> build just puked on Lexer.hs
00:11:41 <dons> (and if you have multiple cores, it'll even run transparently SMP, if you run it with hmp3 +RTS -N2 ) :)
00:11:49 <pzpz> Lexer.hs:92:16: Not in scope: `P.dropSpaceEnd'
00:11:56 <pzpz> dons: any idea/
00:12:03 <dons> hmm. can you get the darcs version of hmp3?
00:12:07 <dons> ?where hmp3
00:12:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
00:12:12 <pzpz> yah. 1 sec
00:13:30 <pzpz> you sure that's a valid repository?
00:14:36 <lispy> that url hopefully points to one, but it's definitely not a repo
00:14:54 <pzpz> i concurr. at least there's a binary version :)
00:26:39 <dons> that's a web page :) you found the darcs repo?
00:26:49 <dons> http://www.cse.unsw.edu.au/~dons/code/hmp3 --iirc
00:26:50 <lambdabot> Title: Index of /~dons/code/hmp3
00:50:23 <pzpz> dons: getting now.
00:50:46 <pzpz> lots of patches + slowinternet :(
00:53:56 <musasabi> Why does this not match:
00:53:57 <musasabi> {-# RULES "comb-putW8-putW8" forall a b. (>>) (putW8 a) (putW8 b) = ptrop 2 (\p -> poke p a >> poke (plusPtr p 1) b) #-}
00:54:00 <musasabi> t = (>>) (putW8 a) (putW8 b) where a = 50; b = 60
00:55:19 <musasabi> Is there something stupid I am missing?
01:00:12 <dons> do you have INLINE [1] or so on on putW8 ?
01:00:34 <dons> check with -ddump-simpl-iterations, iirc, to see each phase of inlining
01:03:18 <musasabi> INLINE [1] didn't make any change, looking at -ddump-simpl-iterations
01:05:12 <musasabi> fixed ^_^
01:05:29 <pzpz> dons is a pro!
01:06:17 <dons> what was the issue, musasabi ?
01:06:59 <musasabi> dons: too much too early inlining I think.
01:08:46 <dons> that's usually the reason, I find.
01:14:40 <roconnor> > 528 + 166
01:14:42 <lambdabot>  694
01:32:47 <musasabi-> dcoutts: I think I got rules working for ByteString serialization. Releasing code in a few days.
01:34:08 <dons> mmm!
01:34:15 <dons> musasabi++
01:35:14 <dons> seriaisation, i.e. a FastNewBinary?
01:37:00 <musasabi-> dons: ops like putW8, putW16be, putW32be, putByteString and rules to combine them. Adding a binary class on top of that should be quite trivial.
01:38:47 <dons> great :)
01:38:50 <pzpz> say I have a data type of IORefs,
01:39:13 <pzpz> and i'm using ReaderT to emulate state
01:39:55 <pzpz> .. I'm just not fully understanding lift/asks/ask
01:40:08 <pzpz> and some type transformation
01:41:33 <pzpz> say i have a handle :: IORef Handle within my data type
01:42:15 <pzpz> and within a function foo, how would I sucessfully use putStr handle
01:42:16 <dons> why the IORef? that's true state :) if you've got ReaderT, you may as well just have Handle ?
01:42:24 <dons> something liek:
01:42:35 <dons> do ref <- ask
01:42:48 <dons>    x < liftIO $ readIoRef
01:42:54 <dons>    liftio $ print "foo"
01:43:07 <dons> see why the IORef is a bit excessive?
01:43:40 <dons> oh, readIORef ref
01:43:57 <pzpz> i tried,
01:44:03 <pzpz> h <- asks handle
01:44:10 <dons> yep
01:44:14 <pzpz> hstr <- readIORef h
01:44:23 <pzpz> the previous errors
01:44:24 <dons> no, that gives you a Handle
01:44:35 <dons> you hve a pointer to a Handle, remember
01:44:53 <dons> the IORef Handle.
01:45:30 <dons> do ref <- asks handle
01:45:31 <dons>    h   <- liftIO $ readIORef ref
01:45:31 <dons>    liftIO $ hPutStr h "foo"
01:45:38 <dons> should print "foo" out on the h handle.
01:45:50 <dons> now, you don't need the IORe
01:46:14 <dons> so if instead you had:
01:46:15 <dons> data S = S { handle :: Handle }
01:46:15 <dons> do h   <- asks handle
01:46:15 <dons>    liftIO $ hPutStr h "foo"
01:46:33 <dons> that's a bit simpler, and one less indirection
01:47:02 <dons> (why have a ReaderT with an IORef in it? that's just a slower StateT  ?
01:47:23 <pzpz> i see, a tutorial misled me :)
01:47:33 <dons> ah :)
01:47:43 <dons> IORefs are useful sometimes, but not always
01:48:06 <dons> they're not a magic bullet, just a pointer :)
01:48:51 <pzpz> well, I'm just trying to maintain a Map somewhat efficiently
01:49:39 <dons> a Map directly in a StateT should be ok, for almost everyone
01:50:26 <pzpz> I'm not really aware of the differences between a StateT and ReaderT :\
01:50:44 <dons> one has 'ask', which lets you read the state,
01:50:48 * pzpz needs to read more
01:50:53 <dons> StateT has get and put, which lets you read *and* write
01:51:02 <dons> ?docs Control.Monad.Reader
01:51:03 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Reader.html
01:51:06 <dons> ?docs Control.Monad.State
01:51:06 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
01:51:45 <dons> > flip runState 2 $ do x <- get ; put (x+1) ; return 7
01:51:47 <lambdabot>  (7,3)
01:52:00 <araujo> morning
01:52:01 <pzpz> do brief explinations exist for these methods beyond just their type definition?
01:52:40 <dons> probably in the monad tutorials, available from haskell.org, under the 'Tutorial' link
01:52:44 <dons> maybe in yaht
01:52:48 <dons> ?where yaht
01:52:49 <lambdabot> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
01:53:04 <pzpz> cool cool.
01:53:59 <pzpz> how would you exactly fefine liftIO?
01:54:10 <pzpz> define
01:54:38 <dons> > flip runState M.empty $ do m <- get ; put (M.insert 2 'x' m) ; return 7
01:54:39 <lambdabot>  (7,{2:='x'})
01:54:48 <dons> (map update in a State monad)
01:55:20 <dons> liftIO, it lifts an io action into an enclosing monad
01:55:23 <dons> ?type liftIO
01:55:25 <lambdabot> forall (m :: * -> *) a. (MonadIO m) => IO a -> m a
01:55:42 <dons> so something of IO a becomes something of type 'm a', where m is some monad
01:55:53 <dons> ?type print
01:55:55 <lambdabot> forall a. (Show a) => a -> IO ()
01:55:58 <dons> ?type liftIO print
01:56:00 <lambdabot>   Expecting a function type, but found `IO a'
01:56:00 <lambdabot>    Expected type: IO a
01:56:08 <dons> ?type liftIO (print "foo")
01:56:10 <lambdabot> forall (m :: * -> *). (MonadIO m) => m ()
01:56:15 <dons> ?type (print "foo")
01:56:17 <lambdabot> IO ()
01:56:57 <pzpz> hmm
01:57:41 <pzpz> ?type get
01:57:43 <lambdabot> forall s (m :: * -> *). (MonadState s m) => m s
01:58:07 <dons> returns the monad's state
01:58:18 <pzpz> entirety?
01:58:40 <dons> yea
01:58:44 <dons> ?type gets
01:58:46 <lambdabot> forall a (m :: * -> *) s. (MonadState s m) => (s -> a) -> m a
02:03:20 * araujo `offTo` univ :: IO (Maybe Late)
02:03:41 <dons> :)
02:04:29 <araujo> :-)
02:11:34 <beelsebob> anyone remember jaffa cake's email address off the top of their head?
02:11:59 <dons> ?google Simon Marow
02:12:02 <lambdabot> http://allotment21.blogspot.com/2006/04/friday-14th-april-good-friday-simon.html
02:12:03 <lambdabot> Title: Allotment No 21: Friday 14th April (Good Friday) - Simon the Marow
02:12:04 <dons> grr
02:12:10 <dons> ?google Simon Marlow
02:12:13 <lambdabot> http://research.microsoft.com/~simonmar/
02:12:40 <beelsebob> cheers dons
02:12:44 <beelsebob> oh dons - I was looking for you
02:12:59 <beelsebob> when was it you were planning hackathons?
02:13:16 <dons> just before PADL. so around hmm, 15th Jan (/me guesses)
02:13:22 <dons> we should fix a date this week
02:13:28 <beelsebob> okay, cool :)
02:13:32 <dons> (just before POPL as well)
02:13:44 <dons> you'll be around?
02:14:06 <beelsebob> quite possibly
02:15:30 <pzpz> how does get exactly work when your state isn't composed of a basic type
02:15:54 <dons> it returns the entire state object
02:15:57 <pzpz> like, Data Foo = Foo Apples Oranges
02:16:07 <dons> you would use gets to access just a piece
02:16:16 <pzpz> so, could i do something like, (a,o) <- get
02:16:25 <dons> if it was a tuple, yeah
02:16:32 <pzpz> ?gets
02:16:33 <lambdabot> Defined.
02:16:48 <pzpz> ?type gets
02:16:50 <lambdabot> forall a (m :: * -> *) s. (MonadState s m) => (s -> a) -> m a
02:30:38 <ivanm> Hi everyone, this is my first time on this channel, I just started having a look at Haskell
02:31:02 <profmakx> not a problem at all ivanm ;)
02:31:04 <ivanm> Gour told me about it on the Gentoo forums
02:31:13 <dons> cool. welcome!
02:31:20 <dons> gour++
02:31:22 <ivanm> Well, I should hope it's not a problem ;)
02:31:40 <pzpz> speaking of gentoo, when's 6.6 getting into portage?
02:31:59 <gour> pzpz: use overlay with layman
02:32:08 <gour> pzpz: #gentoo-haskell
02:33:43 <ivanm> Out of curiosity, what does everyone program in?
02:34:00 * gour uses gvim
02:34:12 * pzpz uses emacs
02:34:15 <ivanm> Then loading it in at a prompt?
02:34:19 * threeq uses vim
02:34:40 <ivanm> pzpz: do you use haskell-mode? cos I'm having trouble getting it working :s
02:34:52 <pzpz> ivanm: yes, but it's a little quirky.
02:35:12 <pzpz> how so?
02:36:04 <ivanm> Well, I load in a new file, and I try and use the C-c,C-l to load in a new file, and emacs freezes
02:36:44 <pzpz> you can't perform C-g?
02:37:19 <ivanm> What does that keyboard shortcut do?  All the shortcuts for haskell-mode that I've found have been by looking through the elisp files manually
02:38:02 <pzpz> it's some sort of odd haskell-hugs-load-file
02:38:11 <pzpz> i've never used that functionality, nor do i have hugs
02:38:24 <pzpz> C-x f *.hs RET
02:38:24 <ivanm> Oh, I've got that already set as a global go-to-line command :s
02:38:46 <ivanm> No, I mean parsing the file into GHC
02:38:52 <matley> ivanm, in every buffer you can know the current shortcut with C-h b
02:38:59 <ivanm> I can open the file alright, just trying to parse it
02:39:14 <ivanm> Wow, didn't know that, thanks matley!
02:39:45 <pzpz> oh, i got confused and defined the command you're trying to use,heh
02:39:47 <pzpz> <- tired
02:40:04 <pzpz> C-g breaks the current operation, generally solves most emacs "lockups"
02:40:34 <ivanm> Yeah, but I've globally defined C-g as a go-to-line operation :s
02:40:38 <ivanm> So that's out
02:41:05 <TSC> I don't think that's a good idea
02:41:08 <ivanm> I'm trying to parse the example files from the haskell-mode website, but I can't seem to get the contents of the buffer parsed by GHC
02:41:34 <ivanm> Well, I didn't know the shortcut was used for something else, and just copied it from an example .emacs file for use with Java
02:41:44 <TSC> Can you use C-c C-s and C-c C-b?
02:42:27 <ivanm> Yeah, they work, but trying to get the upper buffer parsed is what's annoying me :s
02:42:54 <pzpz> not sure... never tried that method
02:43:00 <pzpz> i prefer M x compile :)
02:43:13 <TSC> I use C-c C-l, it works fine
02:43:42 <ivanm> Hmmm.... whenever I try it, emacs crashes :@
02:43:47 <ivanm> And I don't know why
02:44:55 <ivanm> Hmmm.... it must just be the example files from the haskell-mode website
02:45:25 <ivanm> When I copied over the factorial code off the "Haskell in 5 steps" site, it instead decided to complain about improper formatting ;)
02:54:21 <dcoutts> musasabi-, cool!
02:54:50 <dcoutts> musasabi-, so are you serialising to a lazy bytestring ?
03:04:51 <dons> huh, the authors of both cachegrine and valgrind have worked on ghc...
03:04:58 <dons> cachegrind.
03:07:37 <pejo> dons, Nethercoete? The article about how haskell programs perform?
03:09:27 <dons> article?
03:09:43 <dons> i just saw it on the mailing list, that yes, Nethercoete has worked on ghc
03:10:02 <dons> what article? :)
03:10:23 <pejo> dons, The Cache Behaviour of Large Lazy Functional Programs on Stock Hardware.
03:11:09 <dons> ah, yeah, that's probably something he wrote :)
03:12:05 <pejo> Would be interesting to know if it's exactly the same today, or if there has been any changes in CPU's (branch prediction has gotten better for example) that makes the performance hit less severe.
03:12:47 <dons> and we have things like bytestrings, which are tuned for the cache
03:12:50 <dons> well, somewhat
03:13:03 <dons> they at least know the cache is there, and try to help it out
03:14:24 <pejo> Heh, yeah. Seems like a fairly involved proejct to redo his measurements though, if his testsuite needs to be "fixed" for bytestring.
03:15:28 <dcoutts> dons, btw, I'm giving another bytestring talk today
03:15:32 <dcoutts> this time on the fusion
03:15:39 <dons> oh interesting. i'm giving one on the fusion on saturday
03:15:52 <dcoutts> to the prog tools and algebra of programming groups here in the lab
03:15:54 * dons notes that he won't have to write so many new slides
03:15:59 <dons> ah great
03:16:09 <dcoutts> dons, heh, yeah, I'm reusing my Chalmers ones
03:16:15 <dcoutts> http://haskell.org/~duncan/bytestring/
03:16:17 <lambdabot> Title: Index of /~duncan/bytestring
03:16:27 <dons> is that a repo/
03:16:44 <dcoutts> no, just a couple sets of slides for talks I've done
03:16:49 <dons> one wèay to find out .. libcurl: HTTP error (404?)
03:16:59 <dcoutts> dons, one is a tweaked version of your intro talk
03:17:04 <dons> ok.
03:17:08 <dcoutts> the other is one I wrote for Chalmers
03:17:16 <dons> i was going to write a fresh one based on the paper
03:17:32 <dons> which would be the base for PADL
03:17:38 <dcoutts> yes
03:17:55 <dcoutts> in the chalmers one I was trying to cover more of the stuff from the paper
03:18:07 <dons> yep
03:18:16 <dons> oh, did you talk to Oege?
03:18:21 <dcoutts> yep
03:18:32 <dons> rl and chillix (who's back in .au) are keen to know when you'll be here :)
03:18:37 <dons> they have plans, i think
03:18:53 <dons> something involving  hacking ghc to make it go faster
03:19:19 <dcoutts> ok, so the dates are not changed, I'm available to go from the end of the spring term to the begining of the summer term
03:19:30 <dons> so what dates are those?
03:19:34 <dons> March-> mid April?
03:19:37 <dcoutts> I'll send an email
03:19:41 <dons> ok. good
03:19:41 <dcoutts> I gotta go find a projector
03:20:00 * dons is at APLAS all week
03:20:03 <dcoutts> I've been busy fixing up this FP practical, but that's done now
03:20:22 <dcoutts> dons, that's where you're giving the fusion talk right ?
03:20:40 <dons> nope. after, at SAPLING, Sydney Area PL Interest Group meeting
03:20:47 <dcoutts> ah right
03:20:56 <dons> http://www.comp.mq.edu.au/~asloane/iWeb/SAPLING-1.html
03:20:58 <lambdabot> Title: SAPLING-1, http://tinyurl.com/tkzb2
03:21:12 <dcoutts> too many acronyms :-)
03:21:19 <dons> heh
03:21:27 <dcoutts> ok, gotta go!
03:21:30 <dons> ciao
03:21:37 <dcoutts> @arr
03:21:38 <lambdabot> Yeh scurvy dog...
03:21:42 <dcoutts> ahem.
04:02:16 <_frederik_> is the cabal manual indexed by google?
04:26:59 <vincenz> -LOL- http://blootics.com/2006/11/07/fw-notepad-bug-new-one/
04:27:03 <lambdabot> Title: Fw: Notepad bug (New one) !!! at Blootics, http://tinyurl.com/yk8kal
04:28:44 <boegel> vincenz: wtf? :)
04:29:11 <vincenz> it works!
04:29:15 <vincenz> o.O
04:29:20 <vincenz> only on a new file
04:29:24 <vincenz> and opening the notepad.exe in vim
04:29:25 <vincenz> I can
04:29:30 <vincenz> 't find that string anywhere
04:32:52 * Lemmih wonders why the article doesn't contain any text.
04:42:27 <roconnor> @yow
04:42:28 <lambdabot> CHUBBY CHECKER just had a CHICKEN SANDWICH in downtown DULUTH!
04:48:06 <JKnecht> anybody here relatively knowledgable about caching in the net generally? Wonder how great delta can be between accesses from caching clients and servers ISPs nets relative to what actually hits your servers
04:51:57 <roconnor> JKnecht: I supose in principle it could be as far out of date as the last Expires HTTP header sent.
04:52:39 <roconnor> HTTP/1.1 servers SHOULD NOT send Expires dates more than one year in the future.
04:53:45 <Syzygy-> roconnor: Why nooooot? ;)
04:57:38 <psnl> quick syntax question; how do you include non printable characters in a pattern?
04:58:23 <roconnor> Syzygy-: I'm just quoting RFC 2616
04:58:50 <Philippa> psnl: '\<code>'?
04:58:54 <Syzygy-> roconnor: Yeah, and I'm trying to whine unreasonably against the standards... Hmmm. Hang on. Does this mean that 355 days in the future is ok??
04:59:03 <roconnor> yes
04:59:15 <Syzygy-> o.O
04:59:20 <psnl> Philippa: lovely, thanks
04:59:40 * Syzygy- really was trying to be unreasonable. Not somehow embracing yearold caches....
04:59:50 <Syzygy-> Oh well. Now, the local algebra seminar. *poof*
05:02:44 <vincenz> read this
05:02:45 <vincenz> and send around
05:02:45 <vincenz> http://www.yardley.ca/blog/index.php/archives/2006/11/06/care-and-feeding-of-top-users/
05:02:49 <lambdabot> Title: yardley.ca » Care and feeding of top users, http://tinyurl.com/yzomtz
05:02:52 <vincenz> ack
05:02:52 <vincenz> wrong one
05:03:00 <vincenz> http://www.guardian.co.uk/commentisfree/story/0,,1941076,00.html
05:03:03 <vincenz> !
05:03:04 <lambdabot> http://tinyurl.com/y3nlvy
05:07:57 <roconnor> maybe we should sprinkle some cluster bombs around parliment
05:08:15 <vincenz> I think we should start a poll
05:08:22 <vincenz> stop cluster bombs
05:09:06 <roconnor> a poll?
05:09:39 <vincenz> petition
05:09:40 <vincenz> sorry
05:09:46 <roconnor> ah
05:11:05 <vegai> Haskell Programmers Against Clusterbombs
05:11:16 <musasabi> dcoutts: yes, lazy. although the serialization is non-lazy.
05:11:43 <roconnor> we could put it in the licencing of our software.
05:11:57 <roconnor> this software cannot be used by organizations or people who deploy clusterbombs
05:12:10 <vincenz> well seriously
05:12:13 <profmakx> or landmines
05:12:13 <vincenz> if we get a page setup
05:12:18 <vincenz> and email around that everyone should sign it
05:12:25 <vincenz> we can start a grassroots movement to get a petition signed
05:12:29 <vincenz> :)
05:13:30 <vegai> which weapons should we allow, then?
05:13:36 <vincenz> precision ones
05:13:45 <roconnor> vegai: landmines!
05:13:52 <roconnor> no wait.
05:13:55 <vincenz> landmines are already outlawed afaik
05:14:02 <vincenz> but if you see the article
05:14:16 <vincenz> they're currently discussing clusterbombs, and uk/us are putting serious diplomatic pressure to keep em legal
05:14:37 <vegai> allow only nukes and make it unlawful not to carry one
05:15:31 <roconnor> I wonder if embeded linux systems are used in any nuclear warheads.
05:16:18 <vincenz> roconnor: no, they use ps2's
05:16:20 <vincenz> :P
05:16:32 <pkhuong> vincenz: ps2 linux?
05:16:45 <vincenz> I doubt you need an OS
05:18:24 <roconnor> oh right
05:32:06 <vincenz> roconnor: truth be told, I doubt they'd want an OS, too unreliable :P
05:35:03 <roconnor> vincenz: what they need is a Haskell OS for their warheads
05:37:20 <vincenz> roconnor: surrrrree....
05:37:23 * vincenz sighs
05:44:02 <JKnecht> roconnor: thanks, will look into what happens when no expiry specified.
05:45:36 <JKnecht> (or ignored)
05:52:42 <ventonegro> dcoutts, is current gtk2hs darcs repo stable for use with 6.6?
05:53:36 <dcoutts_> ventonegro, yep
05:53:51 <ventonegro> and includes opengl, right?
05:54:01 <dcoutts_> yep
05:54:13 <ventonegro> dcoutts_, ok, thanks!
06:32:15 <kzm> One question re the ongoing discussion on the ghc-users list.  AFAIU, Simon M doesn't like seq as specifying sequencing of operations but only strictness (denotational but not operational semantics?).
06:32:30 <kzm> But isn't seq used mainly for its operational semantics?
06:33:10 <kzm> I.e. I use it to eliminate laziness not because I want the function to fail on 'undefined', but to consume less memory and/or go faster.
06:33:54 <kzm> What am I missing?
06:35:59 <musasabi> kzm: operational things should be inferred by the compiler if it has the strictness info.
06:37:09 <kzm> so a compiler is free to implement foldl' the same way as foldl?
06:38:25 <musasabi> kzm: the definition of foldl' is not even standardized.
06:38:39 <kzm> I guess this is a bit similar to tail call elimination (scheme vs common lisp)
06:39:47 <musasabi> foldl' is different from foldl with regards how bottoms will be handled.
06:40:19 <kzm> denotationally, yes, but that's not the main reason it is used.
06:41:24 <kzm> oh, well, I'll leave them to slug it out.
06:42:03 <kzm> From a practical pov it doesn't matter much if it is specified in the standard, or just understood that 'no sane implementation will..'
06:42:05 <musasabi> kzm: what do you think sensible operational semantics would be?
06:42:25 <kzm> Hah.  I'm on thin ice here.
06:42:30 <musasabi> kzm: how about a massively parallel implementation?
06:43:03 <kzm> But I think the point of seq in many cases (in actual code) is to ensure that something is performed before something else.  The name even alludes to it.
06:43:27 <kzm> Ideally, we should use 'par' as well.  x `par` y `seq` z :-)
06:43:36 <kzm> (from GPH and, I think, STM)
06:44:18 <musasabi> so you would ban speculative evaluation in places where seq exists?
06:44:28 <kzm> I would?
06:45:35 <musasabi> if "a `seq` b" means "a" before "b" that would ban speculative evaluation of b.
06:47:20 <kzm> Right.  But if the programmer thinks it's okay to evaluate them in parallel, he could write a `par`b instead.
06:48:20 <kzm> I suspect that if you started to have seq evaluate in a different order, you'd break a lot of code.
06:50:33 <kpreid> @pl \x -> [x,x]
06:50:34 <lambdabot> ap (:) return
06:51:34 <kpreid> @type ap
06:51:39 <musasabi> kzm: which code? this is pure functional things.
06:51:39 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
06:51:41 <kpreid> @type ap (:)
06:51:43 <lambdabot> forall a. (a -> [a]) -> a -> [a]
06:51:53 <musasabi> kzm: it won't break any normal code.
06:52:31 <musasabi> The only problems are if people do really unsafe hacks that were never guaranteeded to work.
06:53:32 <kzm> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
06:54:18 <kzm> Isn't the 'seq' the only difference to regular foldl?
06:54:53 <musasabi> @type foldl
06:54:55 <musasabi> @type foldl'
06:54:55 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
06:54:56 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
06:54:59 <musasabi> yes.
06:55:09 <kzm> ...and, one might ask, is 'finite memory' one of those 'unsafe hacks' you are referring to :-)
06:55:22 <kzm> I must run.
06:57:33 <musasabi> kzm: I think it would be bad form to implement it in a way that would cause memory leaks, but it is possible to both avoid strict sequencing and memory leaks.
07:32:31 <petekaz> @hoogle Char -> [String] -> String
07:32:33 <lambdabot> No matches, try a more general search
07:32:52 <petekaz> @hoogle a -> [[a]] -> [a]
07:32:54 <lambdabot> No matches, try a more general search
07:33:05 <petekaz> @hoogle [[a]] -> a -> [a]
07:33:06 <lambdabot> No matches, try a more general search
07:33:17 <psnl> petekaz: what do you want to do?
07:33:48 <petekaz> I just want to take a list of strings, and a character to join them with and end up with a single string.
07:33:56 <petekaz> like the python join method.
07:34:13 <vincenz> > concat $ intersperse "." ["a", "b"]
07:34:18 <lambdabot>  "a.b"
07:34:25 <petekaz> thanks.
07:34:32 <vincenz> > let join c l = concat $ intersperse (c:"") l
07:34:33 <lambdabot>  Parse error
07:34:48 <petekaz> > intersperse "." ["a", "b"]
07:34:50 <lambdabot>  ["a",".","b"]
07:34:50 <vincenz> > let join c l = concat $ intersperse (c:"") l in join 'a' ["a", "b", "c"]
07:34:52 <lambdabot>  "aabac"
07:36:02 <glguy> intercalate*
07:37:42 <Syzygy-> @pl \x -> concat $ intersperse " " x
07:37:43 <lambdabot> join . intersperse " "
07:37:57 <Syzygy-> @pl words
07:37:58 <lambdabot> words
07:37:58 <vincenz> @pl \c l -> concat $ intersperse (c:"") l
07:37:59 <lambdabot> (join .) . intersperse . return
07:38:01 <Syzygy-> @pl unwords
07:38:02 <lambdabot> unwords
07:38:10 <vincenz> Syzygy-: that's a specific case for spaces
07:38:25 <Syzygy-> vincenz: Yah. I was just curious whether pl actually knew about that.
07:38:35 <vincenz> > ((join .) . intersperse . return) 'a' ["a", "b", "c"]
07:38:37 <lambdabot>  "aabac"
07:38:44 <vincenz> @type ((join .) . intersperse . return)
07:38:46 <lambdabot> forall a. a -> [[a]] -> [a]
07:38:48 <vincenz> :)
07:39:10 <vincenz> @hoogle [a] -> [[a]] -> [a]
07:39:11 <lambdabot> No matches, try a more general search
07:55:54 <chessguy> > foldr (&&) True [True, True, True]
07:55:55 <lambdabot>  True
07:56:01 <chessguy> > foldr (&&) True [True, True, False]
07:56:02 <lambdabot>  False
07:56:19 <vincenz> > foldr (&&) True [True, False,undefined]
07:56:20 <lambdabot>  False
07:56:21 <chessguy> @type &&
07:56:22 <lambdabot> parse error on input `&&'
07:56:24 <vincenz> :)
07:56:29 <kpreid> > and [True, True, False]
07:56:30 <lambdabot>  False
07:56:32 <chessguy> @type (&&)
07:56:34 <lambdabot> Bool -> Bool -> Bool
07:56:34 <vincenz> > fodlr (&&) True [True, undefined, False]
07:56:35 <lambdabot>  Not in scope: `fodlr'
07:56:44 <vincenz> > foldr (&&) True [True, undefined, False]
07:56:46 <lambdabot>  Undefined
07:57:16 <dr_strangelove_> > True && False
07:57:18 <lambdabot>  False
07:57:21 <glguy> ?type (and,or)
07:57:23 <lambdabot> ([Bool] -> Bool, [Bool] -> Bool)
07:57:34 <chessguy> @type (fst == '#' || read fst = snd)
07:57:36 <lambdabot> parse error on input `='
07:57:42 <chessguy> @type (fst == '#' || read fst == snd)
07:57:42 <vincenz> @type (idiots == idiots)
07:57:44 <lambdabot>   Couldn't match `(a, b) -> a' against `Char'
07:57:44 <lambdabot>    Expected type: (a, b) -> a
07:57:45 <lambdabot> Not in scope: `idiots'
07:57:45 <lambdabot>  
07:57:45 <lambdabot> <interactive>:1:11: Not in scope: `idiots'
07:57:58 <chessguy> @type (fst == '#' || read fst == snd)
07:58:00 <lambdabot>   Couldn't match `(a, b) -> a' against `Char'
07:58:00 <lambdabot>    Expected type: (a, b) -> a
07:58:30 <vincenz> chessguy: what are you trying to do?
07:58:38 <vincenz> the type of read is not runtime dependent on the data it is fed
07:58:54 <vincenz> besides, fst and snd are already known functions
07:58:56 <vincenz> @type fst
07:58:58 <lambdabot> forall a b. (a, b) -> a
07:58:58 <vincenz> @type snd
07:58:59 <lambdabot> forall b a. (a, b) -> b
07:59:01 <chessguy> @type (\x -> (fst x == '#' || read (fst x) == (snd x))
07:59:02 <lambdabot> parse error (possibly incorrect indentation)
07:59:17 <vincenz> o.O
07:59:18 <profmakx> whats going on here? stress-testing lambdabot?
07:59:25 <vincenz> chessguy: what are you trying to do
07:59:32 <kpreid> > G.gread "(Just (True))"
07:59:33 <lambdabot>  Add a type signature
07:59:44 <kpreid> > (show . G.gread) "(Just (True))"
07:59:44 <vincenz> chessguy: You don't get it.... you can't know what type until the compiler knows from elsewhere, types are not dynamic
07:59:45 <lambdabot>  Add a type signature
07:59:51 <vincenz> that won't wokr!
08:00:00 <vincenz> the compiler needs to know the type of the expression apriori
08:00:24 <chessguy> i want to test a [(Char,Int)] to see if the char is # or the Int is equal to the numeric representation of the Char
08:00:34 <vincenz> chessguy: you'll have to constrain your type
08:01:03 <chessguy> s/\#/'\#'/
08:01:03 <vincenz> > \(x :: (Char, Int) -> fst x == '#' || read (fst x) == snd x)
08:01:04 <lambdabot>  Parse error
08:01:14 <vincenz> > \(x :: (Char, Int)) -> fst x == '#' || read (fst x) == snd x)
08:01:15 <lambdabot>  Parse error in pattern
08:01:27 <kpreid> @type \(c,i) -> c == '#' || i == ord c
08:01:29 <lambdabot> (Char, Int) -> Bool
08:01:29 <kpreid> no 'read' involved in that
08:01:44 <vincenz> oh numeric representation
08:01:45 <vincenz> yeah
08:02:15 <chessguy> the first is going to be '#', '1', or '0', and the second is going to be 0 or 1
08:03:49 <chessguy> > read '1'
08:03:51 <lambdabot>  Couldn't match `String' against `Char'
08:04:00 <chessguy> > read "1"
08:04:01 <lambdabot>  Add a type signature
08:04:16 <vincenz> chessguy: read has type String -> a
08:04:25 <vincenz> and that 'a' is NOT defined by what input you give it
08:04:28 <vincenz> but how it is later used
08:04:31 <chessguy> hmm
08:04:34 <vincenz> it's -statically- typed
08:04:38 <chessguy> @type read
08:04:40 <lambdabot> forall a. (Read a) => String -> a
08:04:54 <vincenz> > let x = read "1" in x + 1
08:04:55 <lambdabot>  2
08:04:59 <vincenz> that works because from +
08:05:04 <vincenz> it knows the x must be a number
08:05:06 <chessguy> ah
08:05:15 <chessguy> so how can i do what i want to do?
08:05:24 <vincenz> use it somewhere
08:05:26 <vincenz> and it will know it's an int
08:05:29 <vincenz> by how its used
08:05:53 <chessguy> > \(x :: (Char, Int)) -> fst x == '#' || read (fst x) == snd x) ('#','1')
08:05:53 <lambdabot>  Parse error in pattern
08:06:13 <chessguy> > (\(x :: (Char, Int)) -> fst x == '#' || read (fst x) == snd x) ('#','1')
08:06:14 <lambdabot>  Parse error in pattern
08:06:26 <vincenz> might want to try
08:06:31 <vincenz> but erm
08:06:33 <vincenz> that won't work
08:06:36 <vincenz> 'read' takes a String
08:06:37 <vincenz> not a Char
08:06:43 <chessguy> oh right
08:06:58 <chessguy> @hoogle Char -> Int
08:07:00 <lambdabot> Char.digitToInt :: Char -> Int
08:07:00 <lambdabot> Char.ord :: Char -> Int
08:07:28 <chessguy> > (\(x :: (Char, Int)) -> fst x == '#' || Char.digitToInt (fst x) == snd x) ('#','1')
08:07:29 <lambdabot>  Parse error in pattern
08:08:20 <chessguy> > (\(x :: (Char, Int)) -> (fst x == '#') || (Char.digitToInt (fst x) == snd x)) ('#','1')
08:08:21 <lambdabot>  Parse error in pattern
08:08:35 <vincenz> no need to specify type
08:08:39 <vincenz> it will know from digitToInt
08:08:59 <vincenz> > (\x -> (fst x == '#') || (digitToInt (fst x) == snd x)) ('#', 1)
08:09:01 <lambdabot>  True
08:10:29 <chessguy> > thanks
08:10:31 <lambdabot>  Not in scope: `thanks'
08:10:39 <chessguy> whoops
08:10:40 <chessguy> lol
08:10:45 <vincenz> chessguy: vincenz++ :P
08:10:52 <chessguy> vincenz++
08:10:55 <vincenz> \o/
08:11:00 <chessguy> as if that really matters
08:11:06 <vincenz> @karma vincenz
08:11:07 <lambdabot> You have a karma of 10
08:11:13 <vincenz> woo! 2 karma
08:13:18 <int-e> @version
08:13:19 <lambdabot> lambdabot 4p263, GHC 6.5 (OpenBSD i386)
08:13:19 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
08:13:48 <chessguy> :type @all
08:13:52 <chessguy> @type all
08:13:54 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
08:22:56 <vincenz> @type none
08:22:57 <lambdabot> Not in scope: `none'
08:23:38 <chessguy> @hoogle minus
08:23:39 <lambdabot> Data.FiniteMap.minusFM :: Ord key => FiniteMap key elt1 -> FiniteMap key elt2 -> FiniteMap key elt1
08:23:40 <lambdabot> Data.Set.minusSet :: Ord a => Set a -> Set a -> Set a
08:23:40 <lambdabot> Foreign.Ptr.minusPtr :: Ptr a -> Ptr b -> Int
08:23:56 <chessguy> huh
08:24:12 <chessguy> > [1,2,3] `minus` [1,2]
08:24:13 <lambdabot>  Not in scope: `minus'
08:24:19 <chessguy> > [1,2,3] - [1,2]
08:24:21 <lambdabot>  add an instance declaration for (Num [a])
08:24:21 <lambdabot>   In the definition of `njb': n...
08:24:36 <chessguy> i could've sworn there was a simple minus operator for lists
08:24:41 <profmakx> > [1,2,3} \\ [1,2]
08:24:46 <profmakx> > [1,2,3] \\ [1,2]
08:24:48 <lambdabot>  [3]
08:24:50 <chessguy> ohhh, right
08:25:23 <chessguy> @hoogle (\\)
08:25:26 <lambdabot> Did you mean: (\\)
08:25:26 <lambdabot> Prelude.undefined :: a
08:25:26 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
08:25:45 <chessguy> @hoogle `\\`
08:25:46 <lambdabot> Hoogle Error: Parse Error: Unexpected character '`\\`'
08:25:55 <chessguy> oy. today is not my day
08:26:53 <chessguy> i think i should go back to bed :)
08:27:19 <psnl> anyone know where ndm is?
08:29:18 <shapr> york?
08:30:01 <psnl> ah, so he isn't on holiday then
08:30:57 * shapr doesn't know
08:31:50 <chessguy> > 1 ==\ 3
08:31:51 <lambdabot>  Not in scope: `==\'
08:31:57 <chessguy> > 1 \== 3
08:31:58 <lambdabot>  Not in scope: `\=='
08:31:59 <xerox> ?yow
08:32:01 <lambdabot> TONY RANDALL!  Is YOUR life a PATIO of FUN??
08:32:09 <xerox> > () /= ()
08:32:11 <lambdabot>  False
08:32:15 * psnl grins, I couldn't tell if you were being useful
08:32:28 <xerox> Hiya psnl.
08:32:37 <psnl> morning
08:33:30 <shapr> @quote
08:33:31 <lambdabot> wadler says: Curried food and curried functions are both aquired tastes
08:35:17 <JKnecht> mmmmmmm
08:35:19 <Syzygy-> > 1/=3
08:35:21 <lambdabot>  True
08:36:55 <edwinb> Mmm, curry.
08:37:07 <psnl> you bastard, I was going to say that
08:37:14 <edwinb> you still can!
08:37:51 * psnl supposes its a statement and not an expression
08:38:06 <edwinb> It doesn't have any side effects.
08:38:12 <edwinb> Although curry often does.
08:39:39 <psnl> edwinb: it changes the state of the channel, so must have a side effect, or at least a front effect
08:39:59 <xerox> We all run in a monad.
08:40:22 <xerox> Don't you see the light, at the end of the monad?
08:40:36 * xerox is probably pushing it too far.
08:41:13 <jgrimes> I tried running the Life monad in ContT but all I got was a cryptic type error =/
08:41:23 <edwinb> xerox: but once you're in the monad, you can't get out!
08:41:35 <xerox> Wake up, edwinb.
08:41:52 <psnl> xerox: you mean the ouncoming return, which sends us back to the place we came from?
08:42:31 <xerox> psnl: you also have other interpretations, buddhism is mdo.
08:42:47 <xerox> ?spell buddhism
08:42:49 <lambdabot> Buddhism Buddhisms Buddhist Buddhism's Buddhas
08:42:55 <xerox> Okay.
08:43:49 <psnl> I like the christan mapping, since extending it implies that heaven is both pure and lazy
08:44:50 <edwinb> Careful or you'll start sounding like Thorsten
08:45:10 <xerox> Who's Thorsten?
08:45:20 <psnl> he also talks bollocks?
08:45:45 <edwinb> Altenkirch, in Nottingham
08:46:24 <xerox> Keywords: Constructive Logic, Type Theory, Category Theory, Lambda calculus, Quantum Computing, Certified Correct Programs
08:46:39 <psnl> that would be the chappy
08:46:56 <edwinb> Heaven is where all functions are total, Purgatory is where type level functions are total but values may be partial, hell is where anything can happen and typechecking is undecidable
08:47:00 <edwinb> or some such nonsense
08:48:12 <psnl> you know you need to stop doing type theory when.....
08:48:47 <edwinb> Never! You never need to stop doing type theory!
08:49:08 * edwinb wanders off back to his theorem prover
08:49:16 * xerox slaps edwinb 
08:49:17 * psnl wanders back to hat
08:49:34 <Codex_> stop doing type theory -- obviously when you've solved the problem...
08:49:48 <xerox> Codex_: I think edwinb *really* meant what he said.
08:50:07 <psnl> Codex_: um, you haven't seen edwinb's problems
08:50:29 <xerox> psnl: don't they call them "interests" ?
08:50:48 <edwinb> I prefer to think of them as interests, but people may argue over that ;)
08:52:45 <psnl> edwinb: still doing Ivor?
08:54:14 <xerox> Dr. Altenkirch's research covers applications of Category Theory as a formalism to concisely express abstract properties of mathematical constructions in Computer Science and the investigation of typed lambda calculi as a foundation of (functional) programming languages and Type Theory.
08:54:37 <xerox> Can a native English person put parenthesis around the proper places in that phrase?  Yuck.
08:55:13 <psnl> Category Theory as a formalism to concisely express abstract properties of mathematical constructions in Computer Science
08:55:22 <psnl> investigation of typed lambda calculi as a foundation of (functional) programming languages and Type Theory.
08:55:35 <psnl> the second everyone does
08:55:48 <xerox> right
08:56:18 <xerox> is there still something to say about typed lambda calculi as a foundation of programming languages?
08:56:47 <shapr> I haven't seen it mentioned on TheDailyWTF yet.
08:56:53 <psnl> xerox: better type systems, normally
08:56:56 <edwinb> heh
08:57:07 <xerox> shapr: haha
08:57:23 <xerox> psnl: oh right, edwardk's like work?
08:57:30 <psnl> xerox: the first line... I know what he means, but I can't put it in a better way
08:57:39 <edwinb> There is certainly more to say about, e.g., dependently typed lambda calculi as a foundation of programming languages
08:57:47 <edwinb> beyond just dependently typed languages like Epigram
08:59:05 <shapr> Though I would love to get a production quality version of Epigram that I could use to write commercial programs.
08:59:07 <xerox> psnl: e.g. using ct as your formalism in talking about Haskell's new features?
08:59:25 <shapr> Would you consider writing Epigram 2 in Epigram 1?
08:59:51 <xerox> Is Epigram 1 anywhere usable?
08:59:57 * edwinb says nothing
09:00:05 * xerox shakes edwinb 
09:00:13 <edwinb> There is no reason why Epigram can't be written in Epigram, other than the lack of a currently usable implementation
09:00:21 <edwinb> which is admittedly quite a big reason not to do it
09:00:36 <xerox> That's exactly what we were asking!
09:01:16 <dgoldsmith> ?tell enolan yes, there's a problem with the ghc-6.6 binary distribution for Intel Mac. You can fix it by recompiling from source.
09:01:16 <edwinb> I'll be in Nottingham next week, I'll tell them to get on with it ;)
09:01:17 <lambdabot> Consider it noted.
09:01:40 <xerox> dgoldsmith: is it?
09:01:45 <xerox> *what
09:01:52 <xerox> edwinb: yes please :)
09:02:08 <dgoldsmith> xerox: What? The problem with the Intel distribution?
09:02:28 <xerox> By the way, have you noticed edwinb that System-F_C paper talks about associated types?
09:02:37 <xerox> dgoldsmith: yes, I haven't installed it yet tho
09:02:54 <dgoldsmith> xerox: the problem is that there are some C header files missing for OpenGL in lib/includes
09:03:10 <xerox> oh, okay
09:03:18 <dgoldsmith> xerox: the same problem is not present in the PPC distribution
09:03:47 <dgoldsmith> you can fix it by recompiling from source, though then you run into problems with configuring readline.
09:04:11 <edwinb> xerox: I haven't seen the latest version of the paper, but I know they can capture all that stuff
09:04:33 <edwinb> I still say they should just abandon it and use a full dependent type system ;)
09:05:51 <roconnor> what do associated types have to do with dependent types?
09:06:03 <psnl> edwinb: I keep meaning to make dakka dakka dependant types jokes at you ;-)
09:06:10 <edwinb> :-P
09:07:44 <psnl> ooh, you have done some more code
09:13:22 <palomer> yo my bitches
09:21:00 <xerox> edwinb: how's your theorem prover coming along?
09:24:02 <petekaz> how do I get this to work?
09:24:09 <petekaz> secs2str s = printf "%.2d:%.2d" m s''
09:24:10 <edwinb> xerox: I've done almost no work on it recently...
09:24:15 <petekaz>     where (m,s') = properFraction $ s / 60
09:24:21 <petekaz>           s''    = s' * 60
09:25:43 <Lemmih> petekaz: Why doesn't it work?
09:25:58 <petekaz> I get some strange type errors
09:26:16 <xerox> They're vital for the resolution of the problem.
09:26:55 <lisppaste2> petekaz pasted "errors for sample code" at http://paste.lisp.org/display/29447
09:29:54 <xerox> petekaz: try doing what the "Probable fix" line suggests you to do.
09:36:30 <xerox> Why don't we use get :: () ->_Kleisli s and put :: s ->_Kleisli (), instead of get :: State s s, and put :: State s () ?  You have to admit the former two are much better looking (maybe ~> ?)
09:37:09 <scodil> so i'm trying to install this gsl wrapper, and it uses cabal, and the configure stage takes a --prefix argument, but after installing ghc can't find the package, and its looking in the default installation directiory, not the --prefix directory. how might I go about changing this manually?
09:39:35 <Lemmih> scodil: did you run the 'install' step?
09:40:12 <scodil> yeah. ghc-pkg list says its there
09:42:33 <Lemmih> scodil: but 'ghci -package gsl' fails?
09:43:31 <scodil> yes
09:43:46 <scodil> Loading package GSL-0.5 ... ghc-6.6: can't load .so/.DLL for: HSGSL-0.5 (libHSGSL-0.5.so: cannot open shared object file: No such file or directory)
09:44:08 <scodil> ghc -v tells me where its looking, and i can see that its looking in the wrong place
09:45:31 <scodil> found it. there were bad entries in ~/.ghc/.../package.conf
09:45:52 <scodil> what would have done this? is this the packagers fault, or a cabal bug?
09:54:09 <petekaz> xerox: I'm not quite sure how to.
09:54:27 <xerox> petekaz: specify a fixed type for the function, for one
09:55:44 * psnl hits edwinb with his tazer
10:08:08 <palomer> haskell gives me a woody
10:08:22 <Philippa> I guess Debian's too old to do that any more
10:09:22 <ibid> we'll just have to scratch our etches
10:12:28 * kpreid sends dons an @unpl implementation
10:21:00 <palomer> you're all nuts!
10:23:15 <petekaz> @seen dcoutts
10:23:19 <lambdabot> dcoutts is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I last heard dcoutts speak 7h 1m 34s ago.
10:23:50 <dcoutts_> @arr!
10:23:51 <lambdabot> Aye Aye Cap'n
10:24:02 <dcoutts_> petekaz, ?
10:24:25 <petekaz> dcoutts_: gtk2hs question, if I am changing a label's value, do I have te explicitly refresh it somehow?
10:24:39 <petekaz> dcoutts_: I'm trying to write a stopwatch
10:25:31 <dcoutts_> it gets redrawn after you change it
10:25:39 <dcoutts_> next time the window is redrawn
10:25:49 <dcoutts_> which is triggered by you changing the label
10:26:15 <dcoutts_> however if you change the label and then block doing something else then you prevent the gui from redrawing itself
10:26:24 <dcoutts_> so the trick is not to do blocking operations
10:26:34 <dcoutts_> or if you must do blocking things then use threads
10:26:37 <petekaz> dcoutts_: admittedly, it'll be a bit awkward strapping a laptop on my wrish.
10:26:44 <dcoutts_> heh :-)
10:27:02 <petekaz> Well, I am just trying to start a thread to update the label every second.
10:27:08 <dcoutts_> so depending on the accuracy you need you could use the gtk timer stuff
10:27:11 <petekaz> but I don't see anything happening.
10:27:24 <dcoutts_> see timeoutAdd
10:27:38 <petekaz> is that because my thread is being lazy?
10:27:42 <dcoutts_> petekaz, how are you doing the waiting ?
10:27:45 <dcoutts_> threadDelay ?
10:28:17 <dcoutts_> because that blocks the thread and prevents the gui updating
10:28:24 <lisppaste2> petekaz pasted "my stopwatch" at http://paste.lisp.org/display/29448
10:28:32 <petekaz> dcoutts_: yes.
10:28:56 <dcoutts_> petekaz, ah, so you are using threads.
10:29:05 <dcoutts_> petekaz, then you need to use the magic...
10:29:12 <petekaz> I am a GUI retard.
10:29:35 <petekaz> If there is a better way to create a simple stopwatch, I'm all ears
10:29:44 <dcoutts_> http://haskell.org/gtk2hs/archives/2005/07/24/writing-multi-threaded-guis/
10:29:47 <lambdabot> Title: Gtk2Hs » Blog Archive » Writing multi-threaded GUIs, http://tinyurl.com/gt648
10:29:48 <petekaz> gtk timer would be more approriate?
10:29:54 <dcoutts_> probably
10:30:08 <petekaz> ok ... thanks.
10:30:10 <dcoutts_> you can make either work
10:30:40 <dcoutts_> for the threads one you just have to add: timeoutAddFull (yield >> return True) priorityDefaultIdle 50
10:30:53 <petekaz> I'm trying to make a GTD (Getting Things Done) 2-minute timer
10:31:05 <dcoutts_> but for simple stuff, yeah a gtk timer is easier
10:31:12 <petekaz> ok.
10:31:14 <petekaz> thanks.
10:31:40 <dcoutts_> http://haskell.org/hoogle/?package=gtk&q=timeout
10:31:43 <lambdabot> Title: timeout - Hoogle, http://tinyurl.com/y6gkqb
10:32:25 <petekaz> thx
10:33:28 <dcoutts_> petekaz, you'll want 2 timers I think, one for the per-second update and one for the overall time
10:33:41 <dcoutts_> since the per-second one will not be accurate over long periods
10:34:35 <dcoutts_> see what it says in the docs about not trying to 'catch up' if it missed a timeout due to high load.
10:34:46 <petekaz> ok.
10:35:09 <petekaz> I'll have to shelve this until later, its a bit harder than I thought.
10:35:18 <petekaz> (for a newbie - haskell and gtk)
10:38:19 <jgrimes> ok, I'm trying to get output from running a command using runInteractiveCommand. I am reading the contents of the buffer and then using evaluate on the length of the read value (to force evaluation); but I'm not getting any of the output that is sent to the out handle
10:38:54 <jgrimes> and when I run the command manually (outside of haskell) I do get output to stdout
10:39:20 <jgrimes> any ideas as to what I might be doing wrong?
10:43:21 <shapr> petekaz: ooh, GTD Haskell code?
10:43:26 <shapr> petekaz: tell me more!
10:46:24 <shapr> Man, I've had this splitting headache for days, it's hard to think like this!
10:46:47 <petekaz> shapr: I'm just reading the book now.
10:46:58 <petekaz> shapr: And I wanted a 2-minute timer.
10:47:18 <shapr> I have an egg timer.
10:47:27 <petekaz> nice.
10:47:27 <shapr> A friend of mine bought me the GTD book but I lost it before I finished reading it :-(
10:47:43 <petekaz> so you aren't really getting things done then are you?
10:48:00 <shapr> I do get more things done just from the little bits I read.
10:48:38 <shapr> GTD is great, I want to buy another copy and chain it to my keyboard.
10:49:00 <shapr> I also read "The Pragmatic Programmer" and "Making ADD Work" but that second book may not be for you :-)
10:50:22 <astrolabe> Do you recommend The Pragmatic P?
10:50:30 <shapr> Yes, strongly.
10:50:39 <astrolabe> even for a haskeller?
10:50:44 <shapr> Yup
10:50:52 <lispy> pragmatic programmer was good
10:51:37 <lispy> shapr: making add work? like attention defeciet?
10:51:40 * lispy can't spell
10:51:42 <shapr> lispy: Yeah
10:51:55 <lispy> shapr: do you think the advice would be useful to non-add?
10:52:08 <shapr> Some of it would be.
10:52:19 <lispy> hmm...maybe i'll try to find it
10:52:54 <shapr> ADD people generally are incredibly good at a few things and really bad at appointments, deadlines, bill paying, etc.
10:52:57 <lispy> i don't have add, but if i live my life the wrong way i have many similar smyptoms
10:53:09 <xerox> dons: do you use "nick:: expression" because it reminds you of types? :)
10:53:20 <xerox> ("they type, their type!")
10:53:32 <shapr> So the book mostly says 'Find out what you do well. Do that to the best of your ability. Get paid for it if at all possible.'
10:53:47 <lispy> heh, okay
11:00:09 <nomeata> jgrimes: can you paste your code? are you using hGetContents?
11:01:07 <svref> I'm suprised that HashTables taint their return values with IO.  I could certainly imagine passing all the data to a hash in the constructor, and then having it be read-only from there on out.
11:01:29 <dcoutts_> svref, but it also would have to be persistent
11:01:42 <dcoutts_> so you would not be able to use an ordinary array for the hash
11:01:42 <nomeata> shapr: hi
11:02:03 <dcoutts_> it'd have to be a diffarray or a tree, or some other persistent data structure
11:02:09 <svref> dcoutts_: I don't follow you.  "persistant" = "serializable, as if to disk"?
11:02:11 <shapr> hiya nomeata
11:02:20 <petekaz> dcoutts_: is the timeout functions in secs or microsecs?
11:02:25 <dcoutts_> svref, no, persistent means I can use old copies of the value
11:02:26 <nomeata> shapr: you once expressed interest in latexki for the monad reader. latexki is now “in production use”, on http://mitschriebwiki.nomeata.de/, and maybe you might want to have a closer look now
11:02:28 <lambdabot> Title: Das VorlesungsMitschiebWiki - index
11:02:41 <nomeata> shapr: it even supports directories, but that code is not tested much yes :-)
11:02:50 <dcoutts_> svref, eg, I have hashtable0, and hashtable1 = addToHash x hashtable0
11:02:50 <shapr> nomeata: cool!
11:02:55 <nomeata> the url was http://latexki.nomeata.de/
11:02:57 <lambdabot> Title: The Latexki Latex Wiki Wiki - index
11:03:04 <dcoutts_> svref, right, so now I can still use both hashtable0 and hashtable1
11:03:08 <jgrimes> nomeata, I can in a bit, about to head to class.
11:03:25 <dcoutts_> svref, so you can't implement it just as a mutable array since they you've not preserved the value hashtable0
11:03:29 <dcoutts_> svref, see ?
11:03:53 <svref> I don't think that follows...just pass in a huge alist as an initializer...what's the problem?
11:04:03 <nomeata> I’d love to see it in use somewhere in the haskell community, that’s probably the best place to get patches from :-)
11:04:42 <dcoutts_> svref, ah, you mean a non-updatable hash? that you initialise once and then only do lookups with, yeah, that'd be fine.
11:04:42 <xerox> nomeata: cool!
11:04:45 <monochrom> I don't like Bulat Ziganshin's opinion.  It's hoping to see || redefined so as to allow (first_time || putStrLn ""), "like those in C/perl/ruby", i.e., completely ignoring strong typing.
11:05:13 <svref> dcoutts_: so...there's no such beastie in the standard libraries, I gather...
11:05:20 <xerox> monochrom: eeek!
11:05:22 <svref> (other than alists)
11:05:31 <dcoutts_> svref, no. you could use an array quite easily though.
11:05:39 <svref> good point.
11:05:47 <svref> thanks.
11:05:52 <xerox> monochrom: and what will happen to the type of (||)? or will it be lifted to "syntax" ?
11:06:46 <nomeata> another nice featuer of latexki is that you can actually \input whole tex documents. So they can be articles on their own and generate pdf’s, but also serve as chapters to a large document.
11:06:50 <monochrom> Yes I dislike fudging the type system for allowing some confused C/perl/ruby idiom.
11:06:51 <dcoutts_> svref, hashtbl = array (0, max) [ (hash x, x) | x <- xs ]; lookup x tbl = tbl ! hash x
11:07:06 <xerox> monochrom: yeah, it doesn't make any sense
11:07:21 <dcoutts_> svref, well it'd be slightly more complicated than that as you'd want an array of lists so that you can handle hash collisions.
11:07:36 <shapr> nomeata: Sounds perfect for The Monad.Reader
11:07:47 <monochrom> The only point is to be "like C/perl/ruby".  This is very moronic.
11:07:49 <svref> yeah.
11:07:55 * dcoutts_ -> home
11:07:58 <shapr> Do you have demo(s) of that feature?
11:08:22 <nomeata> shapr: yes, but in german
11:08:54 <nomeata> shapr: http://mitschriebwiki.nomeata.de/Ana1Par10.pdf is one paragraph (actually chapter) of http://mitschriebwiki.nomeata.de/Ana1.pdf
11:08:57 <lambdabot> http://tinyurl.com/y6rqd7
11:09:12 <nomeata> sources are http://mitschriebwiki.nomeata.de/data/Ana1.tex and http://mitschriebwiki.nomeata.de/data/Ana1Par10.tex
11:09:16 <lambdabot> http://tinyurl.com/y9uufr
11:09:35 <nomeata> (I hope I remembered the urls correctly)
11:10:06 <nomeata> it just strips of \begin{document}, \end{document} and the preamble, and adds a \chapter{...} with the contents of \title.
11:12:19 <shapr> nomeata: Is there someway to have the LaTeX rendered inline in the wiki pages?
11:12:48 <int-e> @docs Data.Graph.Inductive
11:12:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/fgl/Data-Graph-Inductive.html
11:13:18 <nomeata> shapr: no, not at the moment. you mean in a mediawiki-way?
11:13:34 <ibid> before i fix it, go behold our very first planet flood :)
11:13:46 <shapr> Yeah, I'd like to view the document in my browser, but also have a pretty printing feature via PDF.
11:14:06 <nomeata> I thought about integrating pdf2latex
11:14:23 <xerox> pdflatex or ps2pdf you mean?
11:14:35 <nomeata> äh, no, latex2html
11:15:09 <shapr> I'd like that.
11:15:24 <xerox> is it any good?
11:15:38 <nomeata> has anyone ever tried to creata a complete website only with linked PDFs?
11:15:49 <shapr> I haven't, it's an interesting idea.
11:15:55 <xerox> citeseer? arxiv? :)
11:16:04 <nomeata> then why bother with HTML :-)
11:16:14 <dylan> hevea is bit better than latex2html
11:16:49 <dylan> and I'd like to point out reading PDFs on-screen is a slow and painful process on some machines...
11:17:29 * nomeata has a look at hevea
11:18:06 <shapr> At the rate I read research papers, the only benefits of print would be margin comments.
11:18:25 <shapr> At the rate I move to new places, there's no point in carrying many kilos of margin comments...
11:18:47 <nomeata> (hevea fails with my amsart documents)
11:18:57 <dylan> pdfs are annoying because they require a pixel-addressable display...
11:19:22 <shapr> I wish there were an open source PDF killer.
11:19:25 <dylan> nomeata: ouch. well, it's still a better code base than latex2html
11:19:33 <monochrom> pss are annoyng because they require a continuum-addressable display... :)
11:20:40 <nomeata> my other file failes because the input encodig is specified in a extra .sty file…
11:22:59 <dylan> when I'm a rich world leader, I'll hire teams of people to transcribe PDFs into plain, utf8 text files.
11:23:34 <monochrom> I will lead a rebel.
11:23:45 <ibid> dylan: you could adapt catdvi to do that
11:23:53 <ibid> dylan: just make it read pdf and not dvi
11:24:03 <dylan> ibid: I'm sure that's non-trivial
11:24:24 <monochrom> Why are rich world leaders obsessed with hiring tons of people?
11:24:34 <monochrom> I would just use machines.
11:24:42 <dylan> monochrom: gotta keep family employed!
11:24:51 <glguy> monochrom: I know... you think that they would just buy them
11:25:08 <Binkley> monochrom, it's classier to hire people because it shows you can afford to do it
11:25:09 <ibid> dylan: yea, but you'd not have to rewrite the actual guessing-the-lines-and-words logic :)
11:26:26 <dylan> oh, there's a pstotext which works on PDFs too.
11:26:42 <pejo> dylan, or pdftotext from xpdf package.
11:27:16 <nomeata> havea can’t handle inputencoding utf8, it seems.
11:27:51 <dylan> nomeata: sounds like a typical ocaml application. Sorry I suggested it
11:28:11 <nomeata> no, it is a good suggestion, i very much like the output
11:28:25 <nomeata> I’m just having trouble getting it running with the no-so-simple setup here :-)
11:31:26 <nomeata> ARG. filing a bug about havea not being able to hande utf8 makes reportbug crash, because I used utf8 in the subject
11:31:45 <dylan> LOL
11:32:15 <profmakx> o.O
11:34:47 <ibid> nominolo: report a bug :)
11:34:49 <ibid> gah
11:34:56 <ibid> nomeata: ^
11:35:20 <dolio> People defending PHP make me laugh.
11:35:50 <int-e> "but it's almost as good as visual basic!"?
11:36:11 <nominolo> ibid: i only have feature requests, atm ;)
11:36:15 <dolio> "PHP is usable by people coming right out of college, unlike Python or Ruby!"
11:36:24 <monochrom> reddit.com again?
11:36:30 <dolio> Yeah.
11:36:33 <int-e> python is too simple for its own good.
11:36:34 <nomeata> ibid: I filed one already, but I forgot that it wasn’t fixed :-)
11:36:36 <dolio> http://programming.reddit.com/info/ppj2/comments
11:36:40 <lambdabot> Title: PHP analysed pretty well (reddit.com), http://tinyurl.com/yjxwtv
11:36:42 <monochrom> Oh God I wish reddit.com never existed.
11:36:54 <dolio> Search for posts by supermike. They're tragic.
11:37:31 <tibbe> monochrom: how would I spend my days at work then?
11:37:35 <pejo> dolio, is he saying people coming right out of college can't write code, or something else?
11:38:07 <monochrom> Also people want is: programming without education, getting a job without education, voting for politicians without education, becoming politicians without education, ...
11:38:17 <dolio> I believe he's saying Python and Ruby are too difficult for undergraduates to understand.
11:38:21 <Binkley> haha
11:38:26 <dolio> Or something like that. It's one of many points.
11:38:28 <tibbe> quite a lot of haskell links on programming.reddit.com nowadays
11:38:32 <dolio> Almost all of which are bad.
11:38:37 <monochrom> programming is too difficult for undergraduates to understand.
11:38:44 <nominolo> monochrom: not to forget becoming president without ... ok, we'll leave it for now
11:39:21 <int-e> the referenced article seems nice though. 'More precisely, my primary issue with PHP is its culture as a project. Cultures are inherently difficult to describe, but if I had to put it in a few words, I'd call it the "Works for me" culture.'
11:39:28 <monochrom> Does anyone still remember COBOL?  Touted as "even managers can code now".
11:39:43 <dolio> He also complains elsewhere about how many import statements you have to put at the top of a Python program to write (his example) a Gnome application.
11:40:00 <dolio> Whereas PHP has no module system, so everything is in the same namespace with prefixed_Functions.
11:40:00 <ibid> monochrom: it's still in use
11:40:38 <monochrom> Someone should post a reply saying "you may like COBOL too, even managers can code in COBOL they said"
11:40:49 <tibbe> ibid: quite a lot, COBOL that is
11:41:06 <dolio> "It's faster than Ruby!"
11:41:44 <monochrom> I'm trying to appeal to people's common sense that COBOL was a joke, and therefore see that any argument of "anyone can code in ___" implies ___ is a joke.
11:41:57 <tibbe> :)
11:42:02 <dolio> And the "fantastic community of PHP coders" who, evidently, come to defend their language with the most boneheaded arguments ever. :)
11:42:12 <monochrom> But perhaps these people will actually like COBOL.
11:42:38 <tibbe> dolio: a come on, let them
11:42:54 <dolio> I also like today's link to a slashdot comment: "J2EE sucks huge donkey balls"
11:42:56 <tibbe> you... must... refuse... to... read...
11:43:01 <tibbe> it...
11:43:18 <tibbe> dolio: that's a scientific term mind you
11:43:22 <monochrom> This is a very sad day.
11:43:29 <int-e> PHP is good for ... "Running code on very cheap web servers on the Internet." ... given PHP's history of ... encouraging security holes ..., that's something I never understood.
11:43:51 <int-e> why do ISPs do that?
11:44:21 <tibbe> perhaps the security holes haven't bitten anyone bad enough yet?
11:44:22 <monochrom> because no one cares about security holes
11:44:45 <monochrom> Ask Microsoft the same question too.
11:45:17 <monochrom> Given MSWord's history of encouraging security holes, why does Microsoft still do it?
11:45:28 <monochrom> Or at least the MSWord group.
11:45:33 <tibbe> cost/benefit ratio?
11:46:43 <monochrom> If you look at the leaked Windows kernel source code and comments, you'll see what the kernel group has to say about the MSWord group, and I have to agree with the professional opinion of the kernel group.
11:48:22 <monochrom> At various places in the kernel, it has to recognize that MSWord is making an illegal operation or call, and try to go into some contingency plan to avoid crashing MSWord and embarrassment.  The comments doesn't say very favourable words about MSWord.
11:48:52 <monochrom> I must conclude that the MSWord group is retarded.
11:49:59 <SamB_XP> wow
11:50:40 <int-e> wait, the kernel has workarounds for ms word bugs?!
11:50:50 <int-e> ow.
11:51:08 <SamB_XP> hmm, I bet anyone can code in Haskell -- if you can teach them some very basic math
11:52:26 <SamB> though maybe if it was a programmer you'd need to claim that Haskell was not a programming language
11:53:12 <dylan> wwoah. someone compared sex ed to a CS education...
11:53:24 <SamB> hmm.
11:53:33 <SamB> what did they say about sex ed?
11:53:55 <dolio> It doesn't prepare you for actually having sex.
11:53:59 <dylan> http://programming.reddit.com/info/ppj2/comments/cpsq1
11:54:02 <lambdabot> Title: PHP analysed pretty well (reddit.com), http://tinyurl.com/ykn5bk
11:54:04 <SamB> oh
11:54:25 <monochrom> There is no oral exam for both.
11:54:32 <dylan> well, people should obviously program a lot before they enter college. ;)
11:54:36 <SamB> well, the difference is that sex ed isn't *supposed* to do that...
11:55:17 <palomer> sex ed is to scare you from having sex
11:55:44 <SamB> so is a CS education supposed to scare you away from programming?
11:55:47 <monochrom> hehehe cs ed is to scare you from touching computers
11:56:05 <Binkley> a CS education is focused on how to do it safely, like a *good* sex education should be
11:56:06 <largos> if CS courses were like sex ed you'd spend 4 years learning how to build black-box test suites..
11:56:09 <Binkley> the pleasurable parts can't be taught
11:56:30 <mwc> Binkley, only because of puritanial moralism
11:56:38 <Binkley> well, yeah, I know. I'm American.
11:58:06 <SamB> the puritans actually liked sex, believe it or not
11:58:19 <astrolabe> they did?
11:58:25 <dylan> puritans were horndogs.
12:00:34 <tibbe> corndogs?
12:01:42 <Binkley> Ooh, that reddit commenter also conflated "sex" with "penetration". nice.
12:02:01 <dylan> I dunno exactly the definition of horndog. It's just what my fiancee calls me. >:)
12:03:09 <dylan> where's a good paper on pretty printer combinator things?
12:03:31 <dylan> I thought there was a reference in hmp3's source, but I can't find it there.
12:04:14 <monochrom> http://www.cs.chalmers.se/~rjmh/Papers/pretty.ps
12:04:17 <lambdabot> http://tinyurl.com/y8gr4o
12:04:27 <dylan> monochrom: thanks!
12:04:31 <monochrom> this from the ghc lib docs for Text.PrettyPrint.HughesPJ
12:04:33 <glguy> ugh, I hate analog lcd monitors
12:05:00 <monochrom> I do too.  what's the point of analog for lcd.  get one with dvi input.
12:05:25 <glguy> The point is that that is what my office has
12:05:31 <glguy> I'm not buying them monitors (-:
12:05:57 <monochrom> they probably still use old analog video cards
12:06:05 <glguy> this video card has a DVI out
12:06:06 <dolio> Are they really analog only, or do the video cards just lack dvi?
12:06:28 <glguy> it's easy to find a video card that supports DVI
12:06:29 <dolio> I didn't realize they made LCDs that don't accept DVI.
12:06:34 <glguy> the trick is to find a cheap DVI monitor
12:06:35 <monochrom> hehehe of course I just mean the lack of digital output
12:07:07 <shapr> I got an AL1916W for $200 usd. It's a great monitor!
12:07:08 <monochrom> It's a scam.  They actually mark down the prices of those LCDs without dvi.
12:07:30 <palomer> shapr, I got mine for 200$ new
12:07:37 <palomer> what's dvi?
12:07:46 <monochrom> It's the same story as 486SX and Pentium Overdrive again.
12:08:01 <dolio> "Ask Reddit: Why is OCaml faster than Haskell?"
12:08:12 <palomer> my 1916 broke down
12:08:16 <palomer> sending it back today
12:08:21 <palomer> (to get it fixed)
12:08:31 <monochrom> dvi refers to the digital interface between video card and monitor
12:08:40 <palomer> what do I care for dvi?
12:08:47 <shapr> Yeah, my AL1916W is a DVI monitor, that's why I purchased it.
12:08:57 <glguy> DVI makes LCD monitors pretty
12:09:06 <monochrom> <palomer> what's dvi?   <--- I'm just answering.
12:09:20 <palomer> and I asked another question!
12:09:23 <palomer> keep an answering!
12:09:27 <Binkley> "why is OCaml faster than Haskell"?
12:09:31 <Binkley> that question makes jesus cry
12:09:34 <monochrom> You don't care about dvi.
12:09:41 <palomer> ohh
12:09:43 <palomer> good
12:09:52 <palomer> so why are dvi monitors cheaper?
12:09:59 <palomer> I mean, if I don't care about dvi, then most people don't either
12:10:01 <glguy> they are not cheaper
12:10:12 <palomer> err
12:10:16 <palomer> non dvi monitors cheaper
12:10:22 <glguy> Binkley: respond: "Why do people beg the question?"
12:10:33 <monochrom> because you don't care about dvi? :)
12:10:37 <palomer> ocaml is usually faster than haskell
12:10:39 <glguy> palomer: because marketing people are dirty fuckers
12:10:45 <Binkley> I actually gave a serious response
12:10:46 <monochrom> It's the same story as 486SX and Pentium Overdrive again.
12:10:53 <palomer> SX was slower
12:10:55 <Binkley> maybe I should have just flamed the hell out of the questioner, though
12:11:27 <monochrom> Extra work is done to sabotage a product so as to sell it at a marked-down price.
12:11:43 <palomer> Binkley, I don't see a problem with the question
12:12:07 <Binkley> palomer: it's nonsensical to ask why one language is faster than another.
12:12:17 <Binkley> you can compare the performance of different *implementations* of different languages, sure.
12:12:26 <explicitjelly> any americans here? where's a good website to see the progress of the voting?
12:12:26 <palomer> by ocaml they mean the ocaml compiler
12:12:30 <palomer> and by haskell they probably mean ghc
12:12:32 <Binkley> yes, but that wasn't made explicit
12:12:35 <Binkley> ocaml is not ocamlc
12:12:36 <monochrom> Oh bare in mind this is reddit.com, even more moronic than slashdot.  They don't know the difference between spec and imp.
12:12:37 <Binkley> haskell is not ghc
12:12:40 <Binkley> heh
12:12:42 <monochrom> s/bare/bear/
12:13:04 <Binkley> can you represent "more moronic than Slashdot" with a 32-bit integer?
12:13:04 <palomer> Binkley, it doesn't take much imagination to understand what the person meant
12:13:15 <monochrom> explicitjelly: try asking reddit.com
12:13:24 <palomer> do dvi video cards exist?
12:13:25 <Binkley> palomer: people need to be precise about what they mean. if you confuse a language with a compiler, you lack imagination.
12:13:37 <monochrom> I would need a 32-bit floating point number :)
12:13:53 <monochrom> dvi video cards exist, lots of them by now actually
12:14:12 <palomer> I don't see why you should be more precise if everyone reading your question can understand what you mean
12:14:24 <palomer> monochrom, and can you see a difference in image quality?
12:14:43 <monochrom> Not yet.
12:14:50 <palomer> phew
12:15:12 <glguy> it's easy to find differences in analog and digital signals on lcd
12:15:22 <glguy> the analog ones are less crisp
12:15:39 <palomer> noticeably less crisp?
12:16:01 <glguy> palomer: annoying like a slight flicker because your refresh rate is set too low
12:16:11 <glguy> not a blatant 60hz flicker
12:16:23 <palomer> oh, my monitor doesn't flicker
12:16:27 <glguy> but maybe the annoying effect you get at 70
12:16:44 <glguy> then you are using a CRT with a high enough refresh rate
12:16:48 <glguy> or, and lcd , which would never flicker
12:16:51 <glguy> an*
12:16:57 <glguy> or, your eyes can't detect it
12:17:00 <palomer> wait, I'm talking about my lcd
12:17:05 <monochrom> fair-trade coffee and non-fair-trade coffee do not have any detectable difference.  but some people rightfully insist on the former.  it's the principle of boycotting a scam.
12:17:07 <palomer> I bought an lcd without dvi
12:17:10 <palomer> and I'm wondering if I should care
12:17:43 <palomer> non fair trade coffee tastes like the sweat and blood of poor farmers. I'm rather fond of the taste
12:17:44 <monochrom> of course it is not like the boycott will cause any difference either
12:17:47 <glguy> palomer: if you don't know the difference, just don't go looking for it
12:17:55 <glguy> and you'll stay happy :)
12:18:01 <palomer> true
12:18:08 <palomer> but for the future?!!
12:18:08 <monochrom> yeah don't worry about my choice
12:18:35 <monochrom> In five years you will want to buy a new monitor anyway.  Then you will make a new decision.
12:18:44 <glguy> palomer: for me, it was like seeing HD TV, and then going home to my crappy old TV
12:18:52 <glguy> the difference is not that dramatic
12:18:53 <palomer> WHOA
12:18:59 <glguy> as it is with HD, obviously
12:19:01 <palomer> you just made me miserable
12:19:06 <palomer> !!
12:19:06 <glguy> but I found it to be noticable
12:19:35 <shapr> DVI gives you roughly three times the resolution if you use subpixel font rendering.
12:19:45 <palomer> oh no!
12:19:51 <glguy> I gave my analog LCD monitor away to my brother and just use my nicer CRT monitor now
12:20:02 <glguy> which I already had
12:20:29 <monochrom> This monitor talk is certainly more enjoyable than reddit.com talk :)
12:20:55 <shapr> Hey, is there a tutorial that covers why and how of forall in Haskell?
12:21:08 <shapr> I think I understand it, but I want to be sure.
12:21:15 <bringert> the GHC manual :-)
12:21:36 <glguy> forall monitors you might own, there exists a monitor that is better than yours
12:21:36 <glguy> like that?
12:21:37 <shapr> No papers and illustrative code samples?
12:22:20 <monochrom> forall is somewhat overloaded.
12:22:22 <palomer> I used to use CRT, but then the electrons shooting at my head drove me insane
12:22:24 <shapr> Foo, forall isn't in the index.
12:22:33 <shapr> palomer: Do you understand forall?
12:22:45 <palomer> oh my
12:22:47 <monochrom> http://www.vex.net/~trebla/haskell/annote-STArray.html  is this what you mean?
12:22:50 <lambdabot> Title: How to annotate STArray types?, http://tinyurl.com/gmrt9
12:22:51 <palomer> that question sounds philosophical
12:22:58 <glguy> palomer: and in your insanity, you bought an analog LCD display?
12:22:59 <palomer> do you understand existence?
12:23:09 <palomer> enough already!
12:23:27 <shapr> palomer: Why would I need forall, and how would I use it?
12:23:30 <monochrom> Perhaps not.
12:23:45 <palomer> shapr, you need forall?
12:24:00 <bringert> shapr: I think this covers many places where forall can be used: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html
12:24:02 <shapr> palomer: Do I?
12:24:03 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
12:24:04 <palomer> forall is far superior from what you're using
12:24:06 <kosmikus> how do I catch ctrl-c in a haskell program?
12:24:25 <dons> kosmikus: register a signal handler for sigint?
12:24:26 <bringert> kosmikus: posix or win32?
12:24:27 <Igloo> Catch the SIGINT exception with GHC, I think
12:24:29 <palomer> when I didn't have forall I went to radio shack and saw forall and I fainted and found jesus that same moment
12:24:39 <Igloo> I don't remember a portable way
12:24:44 <kosmikus> bringert: both :)
12:24:51 <shapr> palomer: Have you written any Haskell code recently?
12:24:59 <monochrom> why do you catch ctrl-c?
12:25:09 <dons> you can catch the signal in a signal handler, then throw an exception out, or otherwise handle it
12:25:11 <palomer> nope:/
12:25:19 <shapr> palomer: aw, it's fun!
12:25:25 <palomer> I know!
12:25:27 <bringert> kosmikus: I was talking to Krasimir about that recently. the best we could come up with was one implementation for win32 and one for posix
12:25:30 <bringert> ifdefed
12:25:34 <palomer> but now I'm pissed at dons, and I associate dons with haskell
12:25:37 <dons> kosmikus: here, http://www.cse.unsw.edu.au/~dons/code/yi/Yi.hs
12:25:39 <palomer> which stops me from writing haskell code
12:25:39 <lambdabot> http://tinyurl.com/szkwe
12:25:48 <dons> so this just ignores the ^C,
12:25:49 <dons>     -- to pass \^C to keymap (think emacs mode)
12:25:49 <dons>     installHandler sigINT (Catch (return ())) Nothing
12:25:50 <kosmikus> bringert: that's sad. I was hoping to avoid ifdefs
12:25:53 <shapr> palomer: Well, you can be pissed at me too if you like. I feel the same way.
12:26:03 <kosmikus> dons, bringert: thanks
12:26:08 <bringert> it could be bundled up in a library
12:26:11 <dons> kosmikus: i don't know of a portably way, but there may be code in darcs
12:26:22 <palomer> I don't mind people feeling a certain way
12:26:26 <bringert> I think ghci does it on windows too
12:26:28 <palomer> I mind it when they take it on others, though
12:26:40 <palomer> well, only when me \in others
12:26:58 <shapr> palomer: I'll take it out on you too if you continue to distract without contributing. But I hope you'll contribute and not distract...
12:27:23 <palomer> hope is for the hopeless
12:27:26 <shapr> palomer: You could stick to #haskell-blah
12:27:31 <palomer> I've already said that I'll distract
12:27:39 <palomer> and that I probably won't contribute
12:27:42 <shapr> So do you think I should remove you immediately?
12:28:04 <bringert> for win32, krasimir said that there is a way to listen for "console events". I don't know anything about win32 myself unfortunately
12:28:04 <palomer> Personally, I think you should do no such thing
12:28:22 * glguy don't understand what the heck just happen... turn away from the channel and when I look back shapr is threatening bans!
12:28:35 <palomer> glguy, yeah, I don't get it either
12:28:35 <glguy> doesn't*
12:28:43 <shapr> palomer: Look at it this way... #haskell is here to focus on the process of learning and writing the Haskell programming language.
12:29:17 <palomer> #haskell is what we make of it
12:29:43 <shapr> Yes, that's true. So if we want it to be a certain way, we prune away the parts that aren't that way.
12:30:22 <palomer> well, yes, if you want things to start getting disagreeable you ban and kick people
12:30:53 <Binkley> usually people only get banned and kicked after they've already behaved disagreeably
12:30:57 --- mode: ChanServ set +o shapr
12:31:07 <Binkley> banning and kicking doesn't typically happen when people have been talking about how great puppies and kittens and monads are
12:31:28 <palomer> Binkley, shapr and dons seem to disagree
12:31:46 <palomer> kittens are too distracting
12:31:47 <shapr> Binkley: Yeah, but part of disagreeable is not distracting and not contributing.
12:31:58 <shapr> er, distracting and not contributing.
12:32:09 <dons> that's a huge part, in fact. since the focus of the good contributors is our key asset
12:32:10 <Binkley> shapr: sorry, I was agreeing with you
12:32:17 <shapr> Binkley: ah, ok
12:32:23 <Binkley> I was taking issue with palomer's view of the direction of causality
12:32:32 <Binkley> it's usually disagreeable behavior that causes banning and kicking, rather than vice versa#
12:32:33 <dons> so if someone's going to say "I've already said that I'll distract", that's basically a critical issue
12:32:40 <shapr> yeah, it is.
12:32:41 <dons> there are alternative channels for distracting behaviour.
12:32:50 <Ugarte> Jesus. It's IRC. You don't have to have a philosophical discussion over whether you can ban him!
12:32:56 <Ugarte> IRC is a dictatorship, not a democracy.
12:33:10 <glguy> Ugarte: I disagree (-: let us debate
12:33:18 <Ugarte> heh
12:33:20 <Ugarte> Oi, vhey.
12:33:29 <shapr> palomer: Well, tell me if you decide to contribute and not distract.
12:33:31 <bringert> we all like to chat about off topic stuff once in a while (at least I do), but I think that we should try to maintain the spirit of the channel, preferrably by coming to a consensus
12:33:32 --- kick: palomer was kicked by shapr (Kicked by shapr)
12:33:38 <Binkley> A+
12:33:55 <Binkley> laying down the law!
12:33:59 <bringert> my client makes all these funny noises I'm not used to
12:34:16 <Ugarte> bringert: No, I like to talk about off topic things, too, and I like consensus. But it seemed there was little disagreement about the kicking. ;)
12:34:21 <glguy> It looks like Cale's attempt at clearing out the ban list didn't last for long
12:34:21 <Philippa> Ugarte: sometimes benevolence dictates some discussion, or at least explanation
12:34:35 <Ugarte> Philippa: I think there's something in Machiavelli about that.
12:35:01 <shapr> I just want to keep #haskell talking and learning about Haskell, that's all.
12:35:19 <shapr> #haskell-blah was created for the #haskell people to talk about stuff that's not Haskell related.
12:35:22 <dons> let's clean out the ban list while we're here
12:35:23 --- mode: ChanServ set +o dons
12:35:27 --- mode: dons set -b Google_Firefox@*!*@*
12:35:37 --- mode: dons set -b *!*n=hohoho@*.hsd1.nj.comcast.net
12:35:38 <scodil> if i've got two calls to a function, and one of em is throwing an error, how do i determine which one?
12:35:45 --- mode: dons set -b *!*=silvermo@222.155.137.*
12:35:57 --- mode: ChanServ set -o dons
12:35:59 <scodil> trace prints its string regardless
12:35:59 <bringert> scodil: maybe Debug.Trace.trace
12:36:14 <Philippa> Ugarte: Machiavelli was writing for people who can be unseated by means other than ircop
12:36:21 <bringert> ok, Control.Exception.catch then
12:36:25 --- mode: shapr set -o shapr
12:36:40 <Ugarte> Philippa: I'm not sure the principles don't apply in any case.
12:36:48 <Philippa> ...not the same way
12:36:53 <scodil> this is burried kind of deep in pure code. there's nothing outside IO?
12:36:58 <dons> > fix $ \f -> 1 : 1: zipWith (+) f (tail f) -- free lambas for all!
12:37:00 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
12:37:02 <Ugarte> Either way, Philippa. :)
12:37:24 <Philippa> ...I think that's a topic for -blah
12:37:25 <glguy> dons: It seems to me that the channel should have an eggdrop manage the ban list, instead of watching it grow :)
12:37:35 <dons> maybe
12:37:42 <dons> ?users
12:37:42 <lambdabot> Maximum users seen in #haskell: 265, currently: 244 (92.1%), active: 48 (19.7%)
12:38:24 <largos> >:t fix
12:38:30 <bringert> scodil: you can try forcing the result inside the argument to trace
12:39:20 <glguy> > fix ( (1:) . (1:) . ap (zipWith (+)) tail )
12:39:20 <largos> how does one find the lambdabot syntax?
12:39:22 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
12:39:29 <xerox> ?listcommands
12:39:30 <lambdabot> Unknown command, try @list
12:39:36 <xerox> ?commandlist
12:39:36 <lambdabot> Unknown command, try @list
12:39:41 <xerox> ?list
12:39:42 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
12:39:46 <xerox> die!
12:39:52 <largos> ah, thanks
12:40:04 <mauke> @pl fix $ \f -> 1 : 1: zipWith (+) f (tail f)
12:40:05 <lambdabot> fix ((1 :) . (1 :) . ap (zipWith (+)) tail)
12:40:14 <xerox> ?dice 3d12
12:40:15 <lambdabot> 3d12 => 29
12:40:19 * glguy didn't use ?pl though (c:
12:40:26 <xerox> glguy: yarr!
12:40:37 <xerox> mauke: is f shared there?
12:40:45 <glguy> mauke: I think that ?glguy works too :)
12:40:53 <glguy> xerox: because of ap
12:41:02 <mauke> > fix ((1 :) . (1 :) . zipWith (+) =<< tail)
12:41:04 <lambdabot>    Expecting a function type, but found `b'
12:41:04 <lambdabot>    Expected type: [a1] -> [a...
12:41:10 <monochrom> scodil: can you insert "trace" at the call sites instead?
12:41:12 <mauke> > fix ((1 :) . (1 :) . (zipWith (+) =<< tail))
12:41:14 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
12:41:19 <mauke> where is your god now?
12:41:37 <xerox> hehe
12:41:40 <largos> hoogle fix
12:41:46 <mauke> @index fix
12:41:47 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
12:41:54 <glguy> Having no god..
12:42:00 * glguy is not qualified to hold office in Texas
12:42:46 --- mode: ChanServ set +b palomer!*@*
12:42:53 <xerox> O_o
12:43:10 <glguy> ``requested by ChanServ''
12:43:30 <glguy> Chanserv: mind leaving? palomer: oh, yeah, no problem \n/part
12:43:47 <mauke> where requested = forced
12:43:50 <xerox> a.k.a. forced
12:43:56 <xerox> ?yarr
12:43:57 <lambdabot> Har de har har!
12:44:02 <mauke> ?yow
12:44:02 <swiert> Is anyone here planning on buying Graham Hutton's book on  Haskell?
12:44:03 <lambdabot> Your CHEEKS sit like twin NECTARINES above a MOUTH that knows no BOUNDS --
12:44:32 <swiert> In particular, would anyone like to write a review for TMR?
12:44:47 <Philippa> swiert: I don't know about actively planning, but I should see how my housemates find the preview chapters that were made available - my ex's got some interest
12:44:55 * glguy will probably buy it just to help encourage people to produce haskell books (c:
12:45:01 <bringert> swiert: [OT] thanks for the card!
12:45:31 <glguy> we have to prefix off-topic discussion with [OT] now? (-;
12:45:43 <bringert> I'm just playing it safe :-)
12:45:57 <swiert> No problem! Congratulations once again.
12:46:02 <Philippa> swiert: I'm probably not a good call for a reviewer though, and nor would I expect my ex to manage more than a few hundred words
12:46:19 <Philippa> though I could ask if a newbie's comments'd be welcome?
12:46:30 <Philippa> (how soon'd you need a review?)
12:46:34 <swiert> Yeah. I'd do it myself, but I feel I may be a bit too close.
12:46:36 <scodil> how do you find out where a <<loop>> is? i miss gdb
12:46:42 <swiert> Not any time soon. January.
12:47:35 <glguy> > let e = e in e
12:47:36 <lambdabot>  Add a type signature
12:47:40 <Philippa> I'm coming from totally the wrong angle unless I see how my housemates learn from it
12:47:51 <glguy> > let e = e in e :: ()
12:47:52 <Philippa> Mari's probably not going to put in enough good time before January
12:47:53 <lambdabot>  Exception: <<loop>>
12:48:25 <glguy> What region is the name "Mari" from?
12:48:39 <Philippa> glguy: abbreviation of "Marianne"
12:48:45 <glguy> ahhh
12:48:50 <bringert> scodil: it's often a mistake with variable names somewhere
12:49:20 <scodil> yeah i figured... but there's no helpful tool to help track it down?
12:49:38 <bringert> trace :-)
12:49:51 <xerox> profiling?
12:49:55 <bringert> there are some debuggers, but I've never used any
12:49:57 <monochrom> unit testing/proving
12:50:18 <xerox> ah! that's what you use them for.
12:50:33 <bringert> splitting the functions up into smaller units which can be independently tested and understodd
12:50:41 <monochrom> paid consultation
12:51:03 <scodil> all this to find a typo..
12:51:16 <bringert> if you catch the loop exception, profiling, as xerox suggested, could work
12:51:23 <glguy> I wonder if voting officials ever worried that the only people that seem to trust electronic voting machines are the ones that *don't* understand them
12:51:28 <monochrom> Debuggers for ghc are hard to implement too.
12:51:30 <glguy> (or that are making a bunch of money with them)
12:51:56 <scodil> whats a "voting official"? you mean "incumbents"?
12:52:07 <mtahti> Hi! I use read to convert a String to Int. Is there any way to catch the error that gets raised when the string doesn't contain a valid integer?
12:52:17 <monochrom> voting officials, by definition, worry about how many people, not who.
12:52:17 <glguy> scodil: those are the people that stand to make all the money with them :)
12:52:24 <dolio> Binkley: I'd recommend not bothering to respond to qwe1234 posts on the Haskell/Ocaml thread. It's a waste of time.
12:52:50 <Binkley> dolio: I'm replying when there are interesting points to be made, but not otherwise
12:52:56 <xerox> glguy: on Tuesday there will be a conference in the lecture room I attend my lectures about divisions, remainders, and arithmetic in voting!
12:53:50 <xerox> well, in voting calculations or whatever, I'll see :)
12:53:53 <monochrom> mtahti: try to utilities in Control.Exception.  The catcher and handler has to be in IO.
12:54:18 <monochrom> I think it's Tuesday already.
12:54:26 <bringert> mtahti: try using reads instead of read
12:54:37 <bringert> @type reads
12:54:39 <lambdabot> forall a. (Read a) => ReadS a
12:54:47 <bringert> @info ReadS
12:54:48 <dolio> Yeah, but he's a pathological troll, so any replies at all are likely to only motivate him to post more garbage.
12:54:48 <lambdabot> ReadS
12:55:13 <bringert> how do you get lambdabot to tell you the definition of a type synonym
12:55:31 <scodil> can you profile if some library you use doesn't have profiling built in?
12:55:41 <mtahti> monochrom, bringert: Thanks!
12:55:43 <monochrom> ReadS a = String -> [(a,String)]
12:55:47 <Binkley> dolio: well, ok, but I guess I'm also curious what he'll come up with next. I'll probably get tired of it in a few minutes :-)
12:56:13 <Binkley> scodil: you need to build all the libraries you use with -prof
12:56:24 <bringert> mtahti: reads returns a singleton list if successful, the Int will be the first element of the tuple
12:56:31 <dolio> :) It is hard to resist, I admit.
12:56:34 <bringert> the second element is the rest of the input, normally empty
12:56:51 <Binkley> I mean, I'm basically seeing what happens if I apply to Socratic method
12:56:56 <Binkley> the Socratic method, even.
12:57:02 <mtahti> > reads "123fsd2" :: [(Int, String)]
12:57:04 <lambdabot>  [(123,"fsd2")]
12:57:19 <mtahti> It works ... thanks a lot.
12:57:35 <Binkley> it's fun to get all Socratic on people when they're expecting you to flame them... as they say, "love your enemies, it really gets them confused"
12:57:40 <bringert> > reads "foo" :: [(Int,String)]
12:57:42 <lambdabot>  []
12:57:45 <dolio> Heh.
12:58:25 <Binkley> eh, ok, now he's just spouting nonsense
12:58:33 <Binkley> I was hoping he would say something really outlandish
12:59:10 <dolio> His point b) is especially ironic.
12:59:41 <dolio> Because he trolls against monads at every opportunity, when in fact they give you "correctness (read: safety) guarantees".
12:59:51 <Binkley> yeah, it's a very strange reply. "compilers have no business being lazy in the first place, performance or not"?
13:00:03 <Binkley> I mean, what's there to dislike about laziness *besides* performance problems?
13:00:14 <Binkley> it's no fun when the trolls don't even try to be internally consistent
13:00:54 <pejo> Binkley, the trouble to reason about space/time behaviour.
13:01:14 <Binkley> pejo, I'd incorporate that under "performance"
13:02:06 <pejo> Binkley, I think most people would interpret performance as "lets hope it's fast".
13:02:24 <Binkley> pejo: their wrong interpretations aren't my problem :-)
13:02:44 <monochrom> People are hostile to unfamiliar things.
13:02:44 <glguy> Sung to the tune of "Oklahoma": Fuuuuuu-sck, my com-pan-y for put-ting up this fi-re-wall!
13:02:58 <scodil> so there's nothing like trace that prints its string on the way out instead of on the way in?
13:03:15 <monochrom> on the way out?
13:03:21 <scodil> after evaluation
13:03:24 <scodil> not before
13:03:44 <Binkley> scodil: you could write (fooblitzky `seq` (trace "hello" ())) if you wanted...
13:03:52 <Binkley> is that what you're looking for?
13:03:57 <scodil> lets see..
13:04:12 <ibid> i'd assume you'd want to replace () with fooblitzy
13:04:24 <ibid> (which had better be a variable)
13:04:35 <monochrom> (you misspelt :) )
13:06:26 <glguy> aparently Tor sends all packets with a 512 byte minimum, so if everyone could please write their thoughts on a few lines as possible, it would be appreciated q-:
13:07:15 <ibid> no
13:07:16 <ibid> :)
13:07:52 <monochrom> What happens to smaller packets?  padding padding padding padding padding padding padding padding padding padding padding padding padding padding padding padding padding padding padding padding padding padding
13:08:19 <glguy> yeah, padding, that way people have a harder time doing analysis on your packets!
13:08:29 * xerox imagines monochrom dancing like badger badger badger...
13:08:43 <glguy_> Ah , this will work better
13:08:48 <xerox> padding padding padding - mushroom mushroom! - padding padding padding...
13:08:51 <scodil> ok so if i do the (v `seq` (trace "v" v)) thing, and my call stack (or whatever) looks like f(g(h()) and all I see is "h", then that means the crash is in h, right?
13:08:56 <xerox> Hiya yaxu.
13:09:02 <yaxu> hey xerox
13:09:16 <dcoutts> @seen ChilliX
13:09:16 <lambdabot> I saw ChilliX leaving #ghc and #haskell 2d 1h 30m 32s ago, and .
13:09:24 <RemiTurk> Hi all
13:09:29 <ibid> scodil: call stack does not mean what you think it means in lazy eval
13:09:35 <RemiTurk> @seen RemiTurk
13:09:36 <lambdabot> You are in #haskell. I last heard you speak just now.
13:09:41 <scodil> i know i know i don't know what to call it
13:09:50 <scodil> the nesting of expressions
13:09:54 <Philippa> ibid: depends what you think's on it, no?
13:09:58 <monochrom> scodil: f is instrumented, g is intrumented, h is intrumented, and all you see is h evaluated?
13:09:59 <ibid> scodil: doesn't matter what you call it, it probably isn't relevant
13:10:00 <RemiTurk> how do I see how incredibly long ago I've last been here?
13:10:05 <ibid> Philippa: well, yes :)
13:10:16 <monochrom> You know, it's very hard to talk imperative terms.
13:10:30 <ibid> scodil: you have a crash in pure code? what kind of crash?
13:10:49 <scodil> <<loop>>.  i guess its not a crash. but its a bug and i'm trying to find it
13:10:57 <monochrom> @seen RemiTurk
13:10:58 <lambdabot> RemiTurk is in #haskell. I last heard RemiTurk speak 57s ago.
13:11:04 <Binkley> scodil: when you say you're looking at your call stack, what do you mean?
13:11:43 <ibid> scodil: that means you have a bad circular definition somewhere
13:11:50 <scodil> f, g and h all trace using (x `seq` (trace "x" x)), and I have an exp that looks like f(g(h())) and I only see h
13:11:55 <scodil> i guess that means g is the culprit
13:11:57 <ibid> scodil: and no, seq probably won't tell you where it is
13:12:18 <monochrom> Since you have f g h, I think you can evaluate h by hand at the ghci prompt, find out what it does.  Then by hand call g with the parameter, find out what it does, ...
13:12:25 <RemiTurk> monochrom: thanks, but I mean _before_ I logged in just now ;)
13:12:27 <glguy> scodil: x `seq` trace "error" x    ==== trace "error" $! x
13:12:55 <ibid> scodil: you need to look for circular definitions, and look at them hard
13:13:18 <ibid> scodil: <<loop>> means that your code needs the value of a recursive definition before it has calculated its head
13:13:20 <monochrom> Can you reproduce the problem with three lines of code?
13:13:30 <ibid> (head being the toplevel constructor of the value)
13:14:25 <ibid> scodil: stuff like let x = 2*x in ...
13:17:36 <ibid> scodil: all your trace tells you is that h probably isn't it; but it could be either f or g or something else that they depend on
13:18:13 <scodil> i found it. h returns a closure and i forot to stick a trace in there
13:18:20 <scodil> when i did i found it
13:19:12 <glguy> What consitutes a closure in Haskell? referring to variables that are otherwise out of scope?
13:19:23 <scodil> sorry
13:19:23 <ibid> glguy: depends on the implementation
13:19:25 <scodil> a function
13:19:42 <glguy> scodil: I'm not attempting to disagree with what you said
13:20:28 <scodil> oh. ok. i'm not a pro with this nomenclature so i just assumed. like when ibid got upset when i mentioned call stack
13:20:59 <ibid> scodil: i didn't get upset, i just pointed out that the imperative terminology will not be very useful in this context
13:21:10 <scodil> i know i'm kidding :)
13:21:11 <glguy> Don't get me wrong, I'm typically a pedant, I was just curious in this case, however.
13:21:39 <glguy> second ',' -> '.'
13:21:55 <Cale> > fix ((0:) . scanl (+) 1)
13:21:56 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
13:21:57 <LordBrain> i recall reading about something that was supposed to be the haskell equivalent of a closure... but i forgot now what it was.
13:22:19 <ibid> glguy: you could probably say that any expression that is on the right hand side of a let binding, or in the argument position in any function call, is a closure (and i probably forget some others)
13:22:34 * glguy wonders if printing fibs to screen is a #haskell way of saying`` Hello''
13:22:36 <Cale> closures are just a way of implementing partially applied functions
13:22:37 <ibid> LordBrain: the implementations talk about thunks, i think
13:22:56 <ibid> Cale: or non-combinator functions
13:23:12 <scodil> is there a compiler option that will warn you when you shadow a name in a local binding? like if I do let x in let x in x
13:24:28 <dany2k> hey there... is there an implmementation of the binomial coefficient in haskell?
13:24:37 <Binkley> dany2k: probably
13:24:55 <dany2k> Binkley: yeah, thought soo. but... where to get it?!
13:24:56 <glguy> > fix ( (1:) `liftM` (1:) `liftM` (zipWith (+) =<< tail))
13:24:58 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
13:25:11 <Binkley> dany2k: who knows? maybe google. or maybe it would be faster to write your own
13:25:22 <Binkley> is this for homework?
13:25:54 <dany2k> Binkley: well, the coefficient is not my homework, it is just something in need for doing my homework...
13:26:12 <glguy> > take 10 $ fix $ liftM (1:) $ liftM (1:) $ flip ap tail $ zipWith (+)
13:26:14 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
13:27:22 <dany2k> but acutally, i dont care what programming language to take... just found a java implmentation ;-) *g*
13:27:37 <Binkley> sure, if you just need the answer for something else, it shouldn't matter what language it's in :-)
13:28:02 <dolio> > let (!) 0 = 1 ; (!) n = n * ((!) (n-1)) in (5!)
13:28:03 <lambdabot>  add an instance declaration for (Num (t -> t1))
13:28:03 <lambdabot>   In the definition of `g...
13:28:05 <cjeris> > ((0:) . scanl (+) 1) [0,1,1,2,3,5,8,13,21]
13:28:06 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55]
13:28:16 <dany2k> Binkley: yeah. though haskell would have been the apropriate one...
13:28:39 <cjeris> > (scanl (+) 1) [0,1,1,2,3,5,8,13,21]
13:28:40 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
13:29:08 <Cale> dany2k: It's easy enough if you know the mathematical definition
13:29:22 <cjeris> oh, I'm slow.
13:29:34 <Cale> (n;k) = n! / (k! (n-k)!)
13:29:37 <xerox> @check \n k -> let n `choose` k = product [1..n] `div` (product [1..n-k] * product [1..k]) in n > k && k > 0 ==> (n::Int) `choose` k == n `choose` (n-k)
13:29:37 <dany2k> Cale: yeah... you're perfectly true..
13:29:38 <lambdabot>  Arguments exhausted after 91 tests.
13:29:47 <dcoutts> @seen ndm
13:29:48 <lambdabot> I saw ndm leaving #ghc, #haskell-overflow, #haskell-blah and #haskell 2h 48m 32s ago, and .
13:29:56 <dany2k> Cale: i reckon i still go fore the haskell way.. ;-)
13:30:17 <glguy> if Cale then print "a" else print "b" -> "a"
13:30:37 <xerox> @scheck \n k -> let n `choose` k = product [1..n] `div` (product [1..n-k] * product [1..k]) in n > k && k > 0 ==> (n::Int) `choose` k == n `choose` (n-k)
13:30:39 <lambdabot>  Completed 100 test(s) without failure.  But 72 did not meet ==> condition.
13:30:49 <Cale> > let bin n k = fac n `div` (fac k * fac (n - k)); fac n = product [1..n] in map (bin 5) [0..5]
13:30:50 <glguy> ?let cale = True
13:30:51 <lambdabot>  [1,5,10,10,5,1]
13:30:51 <lambdabot> Defined.
13:30:59 <Cale> > let bin n k = fac n `div` (fac k * fac (n - k)); fac n = product [1..n] in map (bin 10) [0..10]
13:31:01 <lambdabot>  [1,10,45,120,210,252,210,120,45,10,1]
13:31:09 <Syzygy-> > cale
13:31:10 <lambdabot>  Not in scope: `cale'
13:31:15 <glguy> > L.cale
13:31:17 <lambdabot>  True
13:31:18 <Syzygy-> Ah.
13:31:27 <Syzygy-> How would you remove things from the L context? Can you?
13:31:36 <xerox> Time sucks them into void.
13:31:36 <jgrimes>  @undefine
13:31:37 <Cale> @undefine cale
13:31:39 <Syzygy-> Ah.
13:31:39 <lambdabot> Undefined.
13:31:41 <Syzygy-> > L.cale
13:31:44 <glguy> Syzygy-: you can flush the whole L using @undefine
13:31:45 <lambdabot>  Not in scope: `L.cale'
13:32:01 * Syzygy- goes off to drink beer with a colleague.
13:32:08 <xerox> Have fun.
13:32:34 <chessguy> does haskell have something like sigma notation?
13:33:37 <dolio> sum . map f $ [1..n] ?
13:33:39 <Binkley> chessguy: sure. for example, you can write sigma(i=1->n)(f(x)) as (map f [1..n])
13:33:48 <DeeJay> @pl \(x,y) -> (x,f y)
13:33:49 <lambdabot> second f
13:33:51 <Binkley> er, what dolio said, rather
13:34:11 <Cale> > sum [k | k <- [1..10]
13:34:12 <lambdabot>  Parse error
13:34:13 <Cale> > sum [k | k <- [1..10]]
13:34:15 <lambdabot>  55
13:34:52 <dolio> Ooo, 512-core math coprocessor.
13:34:57 <chessguy> but nothing directly, like summation :: Int -> Int -> (Int -> Int)
13:35:25 <ibid> chessguy: you can write one
13:35:28 <glguy> ?hoogle mapAccum
13:35:29 <lambdabot> Data.IntMap.mapAccum :: (a -> b -> (a, c)) -> a -> IntMap b -> (a, IntMap c)
13:35:30 <lambdabot> Data.Map.mapAccum :: (a -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
13:35:30 <lambdabot> List.mapAccumL :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
13:35:30 <cjeris> > return [] >>= \l -> [0:l, 1:l]
13:35:32 <lambdabot>  [[0],[1]]
13:35:41 <chessguy> i KNOW i can write one
13:35:50 <chessguy> i was asking if there was one already
13:35:52 <Botje> that fix function looks nice, where can I read more about it?
13:36:05 <Botje> ah, it mentions a paper, nm
13:36:13 <dolio> Botje: google for "Y-combinator"
13:36:25 <Cale> chessguy: I like combining sum with the list comprehension syntax.
13:36:30 <dolio> And avoid the web 2.0 use of the word. :)
13:36:37 <Botje> I know it resembles that. I was just wondering how it applies to haskell :)
13:36:38 <Cale> chessguy: it ends up looking a lot like a usual summation
13:36:40 <Botje> but i'll google it, thanks
13:36:43 <Binkley> Y-combinator? I don't even know 'er
13:37:04 <glguy> > mapAccumL (\acc x -> (acc+x,()) 0 [1..10]
13:37:05 <lambdabot>  Parse error
13:37:06 <Cale> Hehehe
13:37:12 <glguy> > mapAccumL (\acc x -> acc+x,()) 0 [1..10]
13:37:20 <lambdabot>  Couldn't match `acc -> x -> (acc, y)' against `(a, b)'
13:37:37 <glguy> > mapAccumL (\acc x -> (acc+x,())) 0 [1..10]
13:37:39 <lambdabot>  (55,[(),(),(),(),(),(),(),(),(),()])
13:37:45 <glguy> oops, took the wrong parenthesis off
13:37:59 <xerox> > let sigma = (sum .) . ((. enumFromTo 1) . map) in sigma (*2) 10
13:38:01 <lambdabot>  110
13:39:24 <chessguy> > 2 + 4 + 6 + 8 + 10 + 12 + 14 + 16 + 18 + 20
13:39:26 <lambdabot>  110
13:39:27 <xerox> I like sections of composition :)
13:40:41 <monochrom> I don't, but that's fine.
13:42:06 <monochrom> There is a web 2.0 use of sigma notation?
13:42:22 <dolio> No, of Y-combinator.
13:42:50 <dolio> It's some company that finances other startups or something.
13:43:01 <cjeris> Cale: woo, crappiest binomial coefficient thing ever
13:43:04 <cjeris> > let iter f n x = (iterate f x) !! n; bin n k = length $ filter ((== k) . (foldl (+) 0)) $ iter (>>= \l -> [0:l, 1:l]) n (return []) in bin 10 5
13:43:06 <lambdabot>  252
13:43:25 <Cale> hehe
13:43:33 <cjeris> how can this be made more clever but still equivalently crappy?
13:44:04 <Botje> dolio: it's funded by Paul Graham, iirc
13:44:06 <dolio> Are you building an nCk sized list?
13:44:17 <monochrom> Galois.com, Y-combinator, ... when is it the turn of Monad IT?
13:44:19 <Binkley> cjeris: by not using (!!) :-)
13:44:30 <Cale> dolio: no, an n-sized list of 0's and 1's
13:44:45 <Cale> actually
13:44:48 <cjeris> dolio: i'm filtering a 2^n list of 0-1 lists representign the subsets of [0..n) by checking which ones of them have k 1-bits set
13:45:03 <dolio> Heh.
13:45:08 <chessguy> i need to build a list of size 1+sum(i=2..n, nCi)
13:45:10 <cjeris> it's the, um, purely combinatorial way to do it :)
13:45:16 <chessguy> since we're talking about summation and combination both :)
13:45:18 <Cale> You could just not put the 0's in, but that would be better
13:45:30 <monochrom> You should consider Church numerals too.
13:45:43 <cjeris> chessguy: sum(i=2..n, nCi) = 2^n - n - 1
13:45:51 <chessguy> yes
13:45:55 * monochrom contemplates unary arithmetic
13:46:04 <monochrom> instance Num String where ...
13:46:11 <monochrom>   a+b = a++b
13:46:23 <cjeris> Cale: "not put the 0's in" ?
13:46:24 <dolio> You could use one of the later Evolution of a Haskell Programmer factorial definitions in your algorithm.
13:46:39 <dolio> That'd probably be pretty bad.
13:47:03 <Cale> > cjeris: as in don't choose to cons 0 onto the list, just leave it alone.
13:47:03 <lambdabot>  Parse error
13:47:04 <cjeris> dolio: i'm not that evolved yet... every time i try to read past the middle of the page my head explodes
13:47:11 <Cale> Then you have nothing to filter
13:47:30 <glguy> so... the church encoding of a number is a function that takes an f and an x and applies f to x the number of times as defined by the number encoded?
13:47:34 <dolio> But they're very clear if you've studied all the papers on cata/ana/paramorphisms, I'm sure. :)
13:47:41 <monochrom>   fromInteger n = replicate n '0'
13:48:00 <chessguy> @type fromInteger
13:48:01 <lambdabot> forall a. (Num a) => Integer -> a
13:48:02 <cjeris> > let iter f n x = (iterate f x) !! n; bin n k = length $ filter ((== k) . length) $ iter (>>= \l -> [l, 1:l]) n (return []) in bin 10 5
13:48:04 <lambdabot>  252
13:48:09 <glguy> dolio: Like, bananas, lenses, envelopes and barbed wire?
13:48:27 <Cale> > let iter f n x = (iterate f x) !! n; bin n k = length $ iter (>>= \l -> [l, 1:l]) n (return []) in bin 10 5
13:48:28 <lambdabot>  1024
13:48:31 <monochrom> My invention is going to be the next big monster since functions as Nums!
13:48:32 <dolio> Yeah. And possibly bananas in space, I'm not sure.
13:48:35 <Cale> mm, right :)
13:49:04 <glguy> let churchEncoding n f x = iterate f x !! n -- like this?
13:50:14 <cjeris> > let iter f n x = (iterate f x) !! n; bin n k = length $ filter (== k) $ iter (>>= \x -> [x, x + 1]) n (return 0) in bin 10 5
13:50:16 <lambdabot>  252
13:50:26 <dolio> I don't remember zygomorphisms from either of those papers, though.
13:51:31 <dany2k> Cale: yay! my programm is running ;-)
13:53:33 <cjeris> Mycomorphism, n. A sophisticated higher-order programming technique discovered by Haskell programmers under the influence of magic mushrooms.
13:53:51 <Binkley> well, that would explain some of the code I've been reading.
13:53:59 <musasabi> :-)
13:55:48 <dany2k> but... whats the data type for big integer in haskell?!
13:55:59 <glguy> Integer
13:56:13 <dany2k> glguy: thx ;-9
13:56:26 <glguy> > maxBound :: Int
13:56:27 <lambdabot>  2147483647
13:56:31 <glguy> > maxBound :: Integer
13:56:32 <lambdabot>  add an instance declaration for (Bounded Integer)
13:56:33 <lambdabot>   In the expression: ma...
13:56:38 <glguy> ^^ not bounded
13:58:35 <glguy> Time to go and vote!
13:58:37 * glguy &
13:58:44 <__alf> hi all! is there a way to use 'deriving Show' when one of the alternatives is unprintable?
13:58:56 <scodil> how do I read from an ioRef and print it at the same time? like print $ (liftM show) =<< readIORef   or something like that
13:59:00 <Binkley> alf: what do you mean by unprintable?
13:59:04 <Igloo> __alf: no
13:59:16 * dany2k tries to collect the dusty remains of the haskell lectures a year ago
13:59:18 <__alf> I wanted to learn haskell, so I made a Unlambda interpreter thing
13:59:33 <nomeata> Ok, I gave it a shot, the wiki now generates also PDF instead of HTML, so you can browse the complete wiki in pdf
13:59:35 <Igloo> __alf: Not without giving a show instance for whatever is unshowable, e.g. one that always returns "foo"
13:59:47 <nomeata> It still lacks an alternative to the menu bar, thought
13:59:49 <nomeata> http://latexki.nomeata.de/index.pdf
13:59:57 <__alf> how do I do that? i have something like
13:59:58 <__alf> data Expr = Dot Char | S | K | I | V | D | C | R | App Expr Expr | K1 Expr | S1 Expr | S2 Expr Expr | D1 Expr | CC (Expr -> IO Expr)
14:00:10 <xerox> scodil: liftM f =<< amb ? hmm.
14:00:10 <__alf> and the continuation part is obviously unprintable
14:00:23 <xerox> ?type \f amb -> liftM f =<< amb
14:00:25 <lambdabot> forall (m :: * -> *) a1 r. (Monad m) => (a1 -> r) -> m (m a1) -> m r
14:00:27 <__alf> how do I give it a dummy implementation of show?
14:00:28 <nomeata> see http://latexki.nomeata.de/index.pdf and http://latexki.nomeata.de/RecentChanges.pdf
14:00:52 <xerox> ?type \f amb -> liftM f amb
14:00:53 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:01:19 <scodil> what is amb?
14:01:20 <__alf> right now I just have a hand-coded Show instance for Expr, but it feels like i shouldn't have to do that
14:02:00 <xerox> scodil: a monadic action/value
14:02:03 <Igloo> __alf: instance Show (a -> b) where show _ = "<function>"  is the easiest way
14:02:16 <__alf> Igloo: ooh.. that was easier than I thought :)
14:02:17 <Cale> __alf: hand code a trivial Show instance for functions, and then derive show
14:03:32 <SamB> or, you could use a not-so-trivial instance!
14:04:22 <__alf> samb: I don't think I want to stringify my continuations -- they'd be completely unreadable no matter what I do
14:04:30 <SamB> heh
14:04:56 <xerox> __alf: are you implementing something like the S K I calculus?
14:05:04 <__alf> xerox: Unlambda. So, yes :)
14:05:09 <xerox> Ah!
14:05:52 <__alf> xerox: I just started playing with Haskell, and I'm really impressed so far
14:06:44 <__alf> xerox: I rewrote the interpreter in CPS (to add the call/cc thing), and it's still readable
14:06:52 <xerox> cool
14:08:00 <__alf> I'm probably supposed to use a monad to hide the CPS plumbing -- I just did it by hand first so I'd understand what was happening
14:08:19 <pkhuong-> alf: yeah, it makes your code better looking (:
14:09:39 <chessguy> so does everything in haskell boil down to a lambda expression, ultimately?
14:09:58 <xerox> __alf: it's a good idea, a tutorial is built exactly on that idea, and it guides you through a completely written-out state-passing implementation of something, to the monadic writing
14:10:06 <xerox> (piece by piece)
14:10:08 <Binkley> chessguy: depends whether you're talking about theory or implementation
14:10:16 <chessguy> both
14:10:30 <chessguy> i'm guessing as theory it does, but as implementation it doesn't
14:10:43 <xerox> yeah
14:10:49 <xerox> the implementation is way smarter, heh
14:10:52 <Philippa> as theory it can be reduced to that but isn't explicitly in haskell
14:10:56 <Binkley> chessguy: right. implementation-wise, you don't translate let or case expressions into lambda expressions, because they have special meanings
14:10:59 <Binkley> let allocates, case evaluates
14:11:05 <xerox> it cooks the code to System F_C in fact!
14:11:17 <Philippa> let has a special meaning for the type-checker, too
14:11:20 <__alf> (sorry, "System F_C"?)
14:11:32 <xerox> (passing through a lot of things, you could check out the video of the Simons explaining the GHC pipeline at the Hackaton that you can find on the GHC wiki!)
14:11:33 <Binkley> besides the fact that you don't need to translate into pure lambda-calculus in order to compile it to C, or rather, it doesn't help
14:12:04 <chessguy> compile it to C?
14:12:06 <Philippa> exactly. Every non-IO computation in any programming language can be translated into a lambda expression, so what?
14:12:14 <Binkley> chessguy: yes, like GHC does
14:12:27 <xerox> Philippa: and every lambda expression can be translated in the points-free SKI calculus! yay!
14:12:29 <chessguy> ghc translates everything to c?
14:12:48 <Philippa> xerox: yeah, but it's less cool when I point out there's a turing machine you could use :-)
14:12:53 <Philippa> chessguy: normally, yes
14:12:57 <xerox> aw.
14:13:09 <Philippa> it has other back ends, but the C one's normally fastest
14:13:10 <chessguy> why not compile it directly to machine code?
14:13:12 <xerox> silly arguments :)
14:13:17 <Philippa> because that's hard work
14:13:21 <chessguy> ...
14:13:33 <Philippa> because other features are better to have with the time
14:13:35 <Philippa> because C is portable
14:13:35 <Binkley> chessguy: because the C compiler is already good at generating efficient assembly code from C, so we might as well exploit it :-)
14:13:37 <__alf> chessguy: you don't want to reimplement all the optimizations
14:13:44 <Philippa> and thus GHC is portable too
14:13:49 <Philippa> exactly
14:13:53 <xerox> I think they hope to do (and probably do) a lot of optimization work with the intermediate languages.
14:14:01 <Philippa> good low-level codegen is hard work
14:14:01 <chessguy> well, but then you've got to worry about translating it to optimized C
14:14:16 <Philippa> into optimisable C
14:14:21 <Philippa> not the same thing
14:14:28 <Binkley> yeah, the optimizations get done on FC and on STG code, not C
14:14:34 <chessguy> i guess
14:14:36 <Binkley> mostly FC
14:15:03 <xerox> it's all explained in video by the authors :)
14:15:12 <chessguy> video?
14:15:15 <xerox> yeah!
14:15:18 <chessguy> i want!
14:15:23 <xerox> i told you!
14:15:23 <Binkley> yes you do!
14:15:33 <chessguy> where is it?
14:15:40 <xerox> on the ghc wiki
14:15:56 <xerox> well, there you'll find links to google video
14:16:07 <Binkley> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Pipeline
14:16:11 <lambdabot> Title: Commentary/Pipeline - GHC - Trac, http://tinyurl.com/yc4zb2
14:16:11 <cjeris> and a trailer:  IN A WORLD... WHERE LAMBDA IS THE ONLY TRUTH...
14:16:13 <Binkley> look for the Video: link at the top
14:16:14 <Binkley> lol
14:16:22 <Binkley> now that sounds more like Erlang: The Movie
14:16:31 <xerox> piece of art
14:16:52 <chessguy> are you guys pulling my leg?
14:16:58 <cjeris> about the trailer, yes.
14:17:29 <Binkley> but there really is a video
14:17:33 <Binkley> and it really is worth watching :-)
14:17:43 <Binkley> heh
14:17:52 <Binkley> i guess we ruined his childhood innocence there
14:18:13 <cjeris> sorry... the image of a haskell hollywood blockbuster just popped into my head
14:18:26 <xerox> there are lots of videos
14:18:32 <Binkley> I meant ruined his innocence about compiling from Haskell to C
14:18:35 <Binkley> "you mean GHC generates C?"
14:18:36 <xerox> all describing a different part of the system
14:18:41 <Binkley> "next you'll tell me there's no Santa Claus"
14:18:43 <xerox> i've 12 of them, but there are probably more
14:19:05 <cjeris> xerox: are they collected anywhere?
14:19:17 <chessguy> hmm
14:19:21 <chessguy> i closed the window by accident
14:19:22 <xerox> yes, i told that before, on google video, and you find the links on the ghc wiki
14:19:37 <Pete_I> ....ghc generates C code? I thought it went straight to binary?
14:19:43 <xerox> http://video.google.com/videosearch?q=ghc+hackathon
14:19:44 <chessguy> yes, i found the video. the audio's pretty crappy
14:19:46 <lambdabot> Title: ghc hackathon - Google Video, http://tinyurl.com/t3n4l
14:20:07 <xerox> http://hackage.haskell.org/trac/ghc/wiki/Hackathon first link
14:20:09 <lambdabot> Title: Hackathon - GHC - Trac, http://tinyurl.com/f5y5y
14:20:13 <chessguy> for that matter, so is the video
14:20:17 <cjeris> xerox: right, just found ghc/wiki/AboutVideos.
14:20:24 <xerox> yep
14:20:40 <xerox> "still lots more to come..."  /me awaits
14:21:22 <xerox> malcolm did a very nice job in recording the events, he has also recorded the icfp meeting
14:21:25 <Binkley> well, the content of the video is good. the cinematography isn't exactly Oscar-worthy
14:21:32 <Binkley> but given the tools that were available, it's good
14:21:39 <xerox> hehe, yeah, but they are there, which is nice :)
14:21:43 <Binkley> exactly
14:23:54 <scodil> if you have an IO function f :: a -> b -> IO c, is it possible to chain two other IOs a and b with something like f =<< (a x) =<< (b y)  ?
14:24:08 <vincenz> Yay or qwe1234 spammag
14:24:21 <vincenz> +e
14:24:37 <Binkley> heh, yeah, he/she/ze/it is pretty special
14:24:47 <vincenz> time to water my plants and train some tai chi
14:28:09 <cjeris> scodil: you can lift the pairing into the IO monad: liftM2 (\c d -> (c, d)) (a x) (b y) >>= (\(c, d) -> f c d)
14:28:29 <cjeris> (is that right?)
14:29:17 <scodil> the function is already in IO though
14:29:38 <scodil> you can liftM f if f :: a -> IO a, can you?
14:29:47 <scodil> can't
14:30:11 <scodil> you can't do ( liftM f) if the type of f is ( f:: a -> IO a )
14:30:14 <scodil> is what i meant to say
14:30:18 <cjeris> scodil: we're not lifting f, but the pairing-and-unpairing we need to give f a single argument to make it work with >>= .
14:30:45 <ski> join (liftM2 f (a x) (b y))
14:30:47 <ski> is one way
14:31:41 <cjeris> oh, i forgot about join!
14:31:41 <tmoertel> Would anybody here agree (or disagree) with the claim that recursion ought to be to professional programming what the chef's knife is to professional cooking?
14:31:51 <ski> @type let (.:) = (.) . (.) in  join .: liftM2
14:31:53 <lambdabot>   Occurs check: cannot construct the infinite type: m = (->) (m a2)
14:31:53 <lambdabot>    Expected type: (a1 -> a2 -> r) -> m a1 -> m a2 -> m a2 -> a
14:31:59 <ski> mrf
14:32:11 <ski> oh
14:32:11 <scodil> tmoertel: what if you're making ice cream?
14:32:12 <Botje> tmoertel: it's one knife in a set of many.
14:32:19 <ski> @type let (.::) = (.) . (.) . (.) in  join .:: liftM2
14:32:21 <lambdabot> forall a a1 a2 (m :: * -> *). (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
14:32:38 <ski> possibly should have a name
14:32:49 <Botje> triple-breasted beast from hell?
14:33:31 <ski> (why not heaven ?)
14:33:43 <Botje> you only have two hands.
14:34:14 <ski> you forget the gripping hand
14:34:40 <Botje> :)
14:34:43 <Botje> << sleep
14:34:51 <Botje> school in 8 hours :(
14:34:59 <xerox> ski: kleisli-something?
14:35:24 <vincenz> slaapwel Botje
14:35:35 <ski> http://www.catb.org/jargon/html/O/on-the-gripping-hand.html
14:35:38 <lambdabot> Title: on the gripping hand, http://tinyurl.com/y2dc4g
14:35:39 <ski> (also on WP)
14:35:57 <ski> xerox : hm ?
14:36:16 <ski> that's an idea ..
14:36:40 <ski> extendM :: Monad m => (a -> m b) -> (m a -> m b)
14:36:53 <xerox> (yeah, there was someone that wanted kleisli composition to have an operator on its own)
14:36:56 <ski> extendM2 :: Monad m => (a -> b -> m c) -> (m a -> m b -> m c)
14:36:57 <ski> ?
14:37:34 <ski> (>@>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
14:37:47 <ski> was what you meant by kleisli composition, yes ?
14:37:48 <lennart> @type join . liftM
14:37:49 <lambdabot>   Occurs check: cannot construct the infinite type: m = (->) (m a1)
14:37:50 <xerox> oh that's quite different
14:37:50 <lambdabot>    Expected type: (a1 -> r) -> m a1 -> m a1 -> a
14:37:52 <xerox> yep
14:38:00 <xerox> ?type (join .) . liftM
14:38:02 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m a) -> m a1 -> m a
14:38:26 <ski> @type let (.:) = (.) . (.) in join .: lifTM
14:38:28 <lambdabot> Not in scope: `lifTM'
14:38:29 <ski> @type let (.:) = (.) . (.) in join .: liftM
14:38:31 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m a) -> m a1 -> m a
14:38:56 <lennart> mmm, .:
14:39:13 <ski> @let (.:) = (.) . (.)
14:39:15 <lambdabot> Defined.
14:39:20 <ski> @let (.::) = (.) . (.) . (.)
14:39:21 <xerox> evil!
14:39:23 <lambdabot> Defined.
14:39:24 <ski> @type (.:)
14:39:25 <lambdabot> Not in scope: `.:'
14:39:30 <lennart> @let (...) = (.) . (.)
14:39:31 <lambdabot> Defined.
14:39:32 <ski> @type (L..:)
14:39:34 <lambdabot> Couldn't find qualified module.
14:39:44 <ski> bah
14:39:44 <xerox> ?type L.(.::)
14:39:46 <lambdabot> Not in scope: data constructor `L'
14:39:46 <lambdabot>  
14:39:46 <lambdabot> <interactive>:1:2: Not in scope: `.::'
14:39:50 <xerox> bah indeed
14:41:01 <ski> [<(f [<(a x) [<(b y))
14:41:02 <ski> hm
14:41:35 <ski> does that look ugly, too ?
14:41:36 <xerox> welcome to ski's parenthesis of hell's dream
14:42:07 <ski> the idea is very nice i think .. only the concrete syntax could maybe be better
14:42:37 <lispy> dons: i just had a crazy idea...maybe lambdabot could be set to kick people with really low karma in order to help with some of the trolls we occasionally get
14:42:49 <ski> (a keyword 'reflect' would look uglier, methinks)
14:43:04 <lispy> dons: the idea would be that the person comes into the channel and everyone votes their karma down and then lambdabot boots them
14:43:27 <ski> lispy : how would they be able to increase their karma ?
14:43:33 <xerox> ski: I can't get this reify/reflect idea, is there a simple explanation?
14:44:12 <lispy> ski: well, the kind of people i'm thinking of are so annoying that we  usually have to go find an op to get rid of them
14:44:31 <cjeris> ok, so ((join .) . liftM) f = (join . (liftM f)) :: (Monad m) => (a -> m b) -> m a -> m b ?  but if you don't parenthesize it, and write (join .) . liftM f x, it winds up trying to postcompose join on the result of (liftM f x) ?
14:44:34 <dany2k> how can i concat a String with an Integer value?
14:44:57 <ski> > "foo" ++ show (42 :: Integer)
14:44:58 <lambdabot>  "foo42"
14:45:01 <nomeata> dany2k: str ++ (show int)
14:45:09 <dany2k> ski: thx
14:45:11 <dany2k> nomeata: ;-9
14:45:20 <astrolabe> But can't one person remove lots of karma from another?
14:45:34 <ski> cjeris : something like that, i think, yes
14:45:38 <xerox> cjeris: you better use ((join .) . liftM) or name it
14:45:44 <dany2k> bloody hell, this seems to be ages away sincie i've been doin this last time...
14:46:12 <ski> xerox : it's bothersome that everyone seems to think the syntax is verbose ..
14:46:16 <lispy> astrolabe: so maybe the attacker would then use the bot to get innocent people kicked?
14:46:51 <xerox> > (join .) . liftM $ (\x -> [x,2*x,3*x]) [1..3]
14:46:52 <ski> xerox : if i may borrow '`' and ',' from scheme a moment, i can try to show some simple example
14:46:53 <lambdabot>  Couldn't match `a1 -> m a' against `[a11]'
14:46:56 <xerox> ops.
14:47:23 <xerox> but then you see
14:47:24 <xerox> > ((join .) . liftM) (\x -> [x,2*x,3*x]) [1..3]
14:47:26 <lambdabot>  [1,2,3,2,4,6,3,6,9]
14:47:30 <astrolabe> lispy: or any bad hat could get anyone kicked.
14:47:32 <xerox> I think it is related to ($) associativity problem?
14:47:54 <xerox> ski: hmm, I should probably sleep, but I'd love to see that.
14:48:00 <cjeris> xerox: thanks!
14:48:05 <ski> (lispy : i was asking how they could possibly redeem themselves)
14:48:48 <ski> data Person = MkPerson Name Age
14:48:56 <ski> getName :: IO Name
14:49:01 <ski> getAge :: IO Age
14:49:02 <astrolabe> ski: maybe kick them if their karma crosses the first boundary, and ban them if it crosses a second.
14:49:16 <ski> astrolabe : or thrice ..
14:49:21 <ski> getPerson :: IO Person
14:49:26 <ski> getPerson = do
14:49:28 <xerox> ski: maybe on #haskell-overflow, so to not have interspersed other things?
14:49:31 <ski>   name <- getName
14:49:36 <ski> ok
14:49:40 <xerox> thanks much
14:55:41 <Rule> Hi, I have a question about zipWith
14:55:53 <Rule> I would like to zip spatial vectors
14:56:13 <Rule> So basicely I want to have a zipWith that works with arbitrary types
14:56:23 <Rule> But I don't know exactly how to do that :-)
14:56:55 <Rule> Here's a snippet of code: http://paste.lisp.org/display/29461
14:57:17 <Patterner> great... comp.lang.haskell is brand new and already 50% of the articles is spam.
14:57:44 <SamB> Patterner: what do you expect for a brand new group?
14:58:18 <SamB> hmm, is usenet spam traceable?
14:58:19 <largos> Rule: zipWith does work with all types ...
14:58:26 <largos> Rule: oh.. I see
14:58:37 <Rule> largos: exactly :-)
14:58:38 <Patterner> Love, Peace and Understanding.
14:59:12 <Rule> I would like to define how two vectors should be added without knowing the exact type of the vector
14:59:29 <Rule> It can have 2, 3 of 4 coordinates
14:59:58 <largos> Rule: wait.. you're zipping arrays of vectors, or your zipping vectors together?
15:00:19 <Rule> largos: zipping plain vectors
15:00:39 <Rule> largos: ie. zipWith (+) (Vec3 1 2 3) (Vec3 10 20 30)
15:01:11 <Rule> Maybe I need to create a class that generalises over zipping
15:01:29 <Cale> Rule: Yeah
15:01:34 <nomeata> shoudn’t you be using plust instead of (+)?
15:01:35 <largos> yeah..
15:01:35 <shapr> azippative?
15:02:09 <cjeris> Rule: call it YKK
15:02:42 <nomeata> or better asked: what is the difference between you plus andd addVector?
15:04:02 <RemiTurk> I have a question: Is there a parsec-implementation of read :: String -> Double?
15:04:25 <RemiTurk> I know there has been a lot of talk of a faster Read class, so someone might actually have implemented something ;)
15:05:08 <nomeata> Rule: you can implemet zip with foldr, if I recall correctly. and you already have foldable vectors.
15:06:02 <SamB> @hoogle toReadP
15:06:04 <lambdabot> No matches found
15:06:06 <SamB> @hoogle toReadS
15:06:07 <lambdabot> No matches found
15:06:10 <SamB> @hoogle ReadS
15:06:11 <lambdabot> Prelude.ReadS :: type ReadS a
15:06:11 <lambdabot> Prelude.reads :: Read a => ReadS a
15:06:11 <lambdabot> Numeric.readSigned :: Real a => ReadS a -> ReadS a
15:06:16 <SamB> @hoogle ReadP
15:06:17 <lambdabot> Text.ParserCombinators.ReadP :: module
15:06:17 <lambdabot> Text.ParserCombinators.ReadP.ReadP :: data ReadP a
15:06:17 <lambdabot> Text.ParserCombinators.ReadPrec :: module
15:07:57 <SamB> @hoogle to_ReadS
15:07:58 <lambdabot> No matches found
15:08:00 <SamB> @hoogle to_S
15:08:02 <lambdabot> Text.ParserCombinators.ReadP.readP_to_S :: ReadP a -> ReadS a
15:08:02 <lambdabot> Text.ParserCombinators.ReadPrec.readPrec_to_S :: ReadPrec a -> Int -> ReadS a
15:08:05 <SamB> @hoogle to_P
15:08:06 <lambdabot> Text.ParserCombinators.ReadP.readS_to_P :: ReadS a -> ReadP a
15:08:07 <lambdabot> Text.ParserCombinators.ReadPrec.readPrec_to_P :: ReadPrec a -> Int -> ReadP a
15:08:07 <lambdabot> Text.ParserCombinators.ReadPrec.readP_to_Prec :: (Int -> ReadP a) -> ReadPrec a
15:08:52 <SamB> @hoogle Read
15:08:53 <lambdabot> Text.Read :: module
15:08:53 <lambdabot> Prelude.Read :: class Read a
15:08:53 <lambdabot> Prelude.read :: Read a => String -> a
15:08:58 <SamB> @doc Text.Read
15:08:59 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Read.html
15:36:45 <vincenz> wow
15:36:46 <vincenz> silence
15:37:45 <xerox> psssssst.
15:38:00 <Heffalump> ?
15:38:07 <RemiTurk> hello
15:39:06 <RemiTurk> hm, Text.Read.read still seems rather slow compared to my handhacked read version
15:40:00 <RemiTurk> I guess everybody is playing bzflag
15:41:29 <zptao> thats not the only thing they're playing with
15:42:11 <monochrom> Have you tried Text.ParserCombinators.ReadP ?
15:43:47 <RemiTurk> I thought it was the same as Text.Read?
15:43:51 <RemiTurk> *tries*
15:44:51 <RemiTurk> hm
15:45:12 <RemiTurk> actually, it doesn't have anything remotely like read::String->Double AFAICS...
15:46:19 <RemiTurk> (actually, I need a read::String->([Int],Double), and my own Parsec version of the [Int] was 5 times faster than standard read :() faster
15:47:08 <RemiTurk> but I didn't look forward to the details (-2.0, -2.0e-1, Infinity etc) of floatings
15:48:12 <scodil> anyone here use gtk2hs?
15:48:28 <dcoutts> yep
15:48:52 <monochrom> Oh, using Text.ParserCombinators.ReadP, you write code in its ReadP monad, then use a converter to convert it to ReadS, then you can convert it to String->Double
15:48:57 <scodil> hah. i'll bet.  is there an easy way to render fonts into a glwindow?
15:49:08 <scodil> i'm getting a segfault using pangoLayouts
15:49:16 <dcoutts> ah, interesting
15:49:29 <scodil> i can paste the code
15:49:29 <dcoutts> I bound the functions but I can't recall ever using them
15:49:41 <scodil> ?paste
15:49:41 <lambdabot> http://paste.lisp.org/new/haskell
15:49:42 <RemiTurk> monochrom: but that's exactly the problem. I hoped to avoid writing the code to parse a Double at all ;)
15:50:13 <lisppaste2> scodil pasted "pango fonts in glwindow" at http://paste.lisp.org/display/29465
15:51:11 <scodil> i don't know gtk/gdk/pango at all, and there seem to be a billion functions involved in rendering a font, so i'm probably missing something
15:52:38 <scodil> these glFontUsePangoFont functions... i don't have to use those, do i? thats just if I wanted to make display lists out of the fonts, right?
15:55:45 <dcoutts> scodil, hmm, my impression was that you were supposed to use gl funtions for the fonts
15:56:10 <lisppaste2> scodil annotated #29465 with "stack trace" at http://paste.lisp.org/display/29465#1
15:56:43 <scodil> GLwindow is an instance of Drawable, right?
15:56:52 <dcoutts> that's a bit odd, it's crashing in the gdk code
15:57:13 <scodil> its in a cairo function too. does pango not actually do any rendering?
15:57:25 <scodil> i haven't made any calls to anything cairo
15:57:46 <dcoutts> scodil, gdk uses cairo for lots of stuff
15:59:58 <dcoutts> scodil, I'll get back to you in a sec
16:00:05 <scodil> sure
16:00:08 <scodil> thanks
16:01:01 <scodil> i might head home soon ... is there a gtk2hs forum or something anywhere?
16:01:16 <dcoutts> scodil, try it without using withGLDrawingArea
16:01:17 <chessguy> dcoutts IS the forum :)
16:01:30 <dcoutts> scodil, there's a gtk2hs-user mailing list
16:01:39 <scodil> what do I use for the GdkDrawable?
16:01:44 <dcoutts> scodil, the operation doesn't use any GL stuff at all you'll note
16:01:56 <dcoutts> scodil, the DrawWindow of the canvas
16:02:07 <dcoutts> like with other non-GL drawing things you might do
16:02:22 <EvilRanter> @pl \ a b c d -> a c ( b d)
16:02:23 <lambdabot> flip . ((.) .)
16:03:07 <scodil> what function gives me that?
16:04:07 <dcoutts> scodil, drawingAreaGetDrawWindow
16:06:24 * tessier wonders if there will ever be a Haskell based web application server like Zope/Plone 
16:06:35 <tessier> Apparently Erlang has a webserver called Yaws.
16:06:47 <tessier> The concurrency of Erlang is really sweet it seems.
16:07:44 <JKnecht> yeah but that's what it's for isn't it?
16:07:49 <dcoutts> tessier, try HApps
16:08:14 <tessier> JKnecht: "what it's for"? You mean doing something useful? I think that should apply to any programming language.
16:08:28 <tessier> Concurrency is going to have to be a big part of the future of any language
16:09:35 <JKnecht> tessier: meant I've mostly heard of Erlang being used in switches and stuff, i.e. having parallelism as it's purpose.
16:09:57 <tessier> JKnecht: Parallelism, correctness, reliability, etc. yes. Those are qualities I look for in any language.
16:10:10 <scodil> dcoutts: excellent. thank you.
16:10:17 <dcoutts> scodil, it works ?
16:10:33 <scodil> yeah. transparent background and everything
16:10:50 <dcoutts> scodil, it shouldn't segfault of course, but the thing to watch out for is mixing GL and non-GL rendering at the same time
16:11:07 <dcoutts> scodil, there are some syncing functions to allow you to do that mixing
16:11:09 <scodil> i was worried because there seems to be nowhere to specifiy opacity in any of the pango stuff
16:11:54 <dcoutts> scodil, glDrawableWaitGL / glDrawableWaitGdk
16:12:07 <scodil> pardon?
16:12:17 <scodil> oh... right
16:12:20 <dcoutts> scodil, the functions for syncing GL and non-GL drawing
16:12:34 <dcoutts> since 2D pango layout doesn't go via GL
16:13:21 <shapr> tessier: HAppS will probably end up like Zope/Plone with much less suck/bloat.
16:14:14 <shapr> tessier: I wrote a wiki with HAppS. The basic approach is to create a State type and your application is a state transformer.
16:14:14 <dcoutts> scodil, yeah, pango doesn't deal with transparency (though as you notice, it doesn't draw any background so that's normally enough) but if you use cairo to draw the pango layout then you can even have alpha components in the text colour itself.
16:15:38 <shapr> Heffalump: I love my ARM :-)
16:15:56 <shapr> Just thought you might like to know that.
16:15:57 <Heffalump> shapr: oh?
16:16:00 <Heffalump> right..
16:16:05 <Heffalump> which particular ARM is this?
16:16:10 <vincenz> shapr: ARM7?
16:16:37 <shapr> arm926tej
16:16:50 <shapr> It's the one in my Nokia 770.
16:16:53 <Heffalump> ah
16:16:57 <Heffalump> done anything interesting with it?
16:17:31 <tessier> shapr: Does it tie into some sort of db other than mysql? I like the idea of zope's db. Or mnesia for Erlang. Would be cool if haskell had something similar.
16:18:02 <shapr> Nothing technically interesting. But it holds my grocery lists, todo lists, research papers, useful notes, contact list, etc. I use it to look up directions on map sites and then keep the resulting browser window in my pocket. It's wonderful!
16:18:20 <Heffalump> the problem I see with HAppS is that it is inherently single threaded
16:18:34 <Heffalump> I don't see how this can ever be a good long-term design
16:18:35 <tessier> Look up directions on map sites and then keep the resulting browser window in your pocket?
16:18:40 <tessier> Heffalump: Indeed.
16:19:58 <shapr> tessier: It does have two things like the zodb. 1. You can define your own way to serialize the state, or you can use the default Read/Show serializers. I think the binary serializer will be working in a coupla days. 2. There's built-in "RDBMS"-like code using ... Data.Set I think.
16:20:07 * shapr checks details.
16:20:31 <shapr> I haven't used the RDBMS-like code yet, I haven't needed it.
16:20:46 * Heffalump goes to bed too
16:20:53 <shapr> Heffalump: Can you explain that more?
16:20:59 <shapr> dang
16:21:07 <chessguy> tut tut, such language
16:21:08 <shapr> I'd like to hear more about single threadedness...
16:21:15 <shapr> oops :-)
16:21:34 <tessier> Whatever you do, don't say fuck.
16:21:41 <tessier> Fuck. I just said it.
16:22:30 <shapr> tessier: The browser on the 770 is good enough for google maps, so I recently asked for Myaddress, Birmingham, AL to International Airport, Atlanta, Georgia. Then when I had the directions in the browser, I put the cover onto the device, putting it to sleep, and put it in my pocket.
16:22:42 * dcoutts points tessier in the direction of #haskell-blah
16:23:06 <shapr> whoops
16:23:10 <tessier> hah
16:23:11 * shapr moves this conversation to #haskell-blah
16:23:36 <dcoutts> shapr, na, I wasn't meaning about 770 stuff
16:23:57 <shapr> Well, it is off-topic unless I'm talking about Haskell on it :-)
16:23:59 * dcoutts wasn't seriously suggesting banishing tessier and shapr for bad language
16:24:29 * shapr shouldn't say dang
16:24:33 <dcoutts> hah hah
16:24:38 <chessguy> lol
16:25:06 <monochrom> dang
16:25:17 <chessguy> i was joking about 'dang'. what followed was certainly inappropriate, IMHO, but i don't care about that word
16:25:18 <monochrom> linging pointers are not a problem in Haskell
16:25:32 <shapr> Actually, I only swear in two situations, when my computer breaks and when people try to kill me on the interstate. But Sofia says that I nearly strip paint off nearby objects in those situations.
16:26:01 <scodil> ok, thanks for the help dcoutts. later
16:26:04 <dcoutts> np
16:26:05 <monochrom> (That's how you can repair a swearing)
16:26:18 <dcoutts> by paint stripping ?
16:27:27 <monochrom> by completion.
16:28:53 <monochrom> If you say "dang", you pretend to continue to talk about dangling pointers
16:29:32 <monochrom> If you say "fuck", you pretend to continue to talk about "fucktions" and then it's just a German typo.  Then you say "pardon my German".
16:32:35 <EvilRanter> "...I haven't finished training him yet"
16:32:50 <EvilRanter> (apologies to all germans, politically corrects, etcetc)
16:39:59 <flawed> cale
16:40:28 <flawed> i need to speak with cale
16:40:37 <Cale> why?
16:40:44 <flawed> cale: hilander banned me from #math for no reason
16:40:49 <flawed> i don't have a registered nick so i can't /msg you
16:41:20 <Cale> nick registration is free
16:41:27 <flawed> anyway, can you unban me please?
16:41:28 <Cale>  /msg nickserv help
16:41:30 <flawed> i was not misbehaving at all
16:41:33 <flawed> i was simply asking a question about my gre
16:41:39 <Cale> not until I know why HiLander banned you
16:41:48 <flawed> and he helped me, then said "i should have seen who this was before i helped him"
16:41:50 <flawed> and banned me
16:42:01 <flawed> look i haven't bothered you guys in months
16:42:17 <flawed> if you want to start this fight again - and me coming in places like this and your other regular channels, just to start trouble - then by all means do so.
16:42:21 <flawed> but hilander is just being an ass, and you know it.
16:42:37 <chessguy> sounds to me like he was being smart
16:42:44 <SamB> I would say Cale does not!
16:44:05 <Cale> flawed: that wouldn't be of any help to you. I'd say talk to HiLander about it.
16:44:10 <flawed> iokay
16:44:12 <Cale> He's the one who banned you
16:44:14 <flawed> you've made your choice
16:44:17 <dcoutts> flawed, do try not to pester too much, it's not a good strategy for getting un-banned. It's frustrating but do try to chill.
16:44:24 <flawed> i guess we have to start this bullshit again
16:44:40 <Cale> Huh?
16:44:55 <flawed> the flooding and what not
16:45:00 <flawed> weren't you paying attention to what i just said, moron?
16:45:01 <Cale> That'll just result in you getting k-lined, I wouldn't recommend it.
16:45:05 <SamB> yeah really
16:45:10 <dcoutts> not a good strategy at all
16:45:16 <SamB> that "again" is probably why you got banned
16:45:16 <flawed> are you retarded
16:45:20 <flawed> remember how many proxies i have?
16:45:22 <dcoutts> op?
16:45:28 <flawed> SamB: no you idiot, don't speculate if you don't know
16:45:29 <dcoutts> shapr, ping
16:45:31 <Cale> dcoutts: I'm an op here
16:45:35 <dcoutts> ok
16:45:43 <SamB> meaning ... if you have a history of flooding, you shouldn't expect to be well liked...
16:45:47 * dcoutts leaves it for Cale 
16:45:51 <flawed> this was MONTHS ago
16:45:57 <SamB> even so
16:46:05 <Cale> Yeah, but you're already talking about starting it back up
16:46:11 <Cale> which isn't doing you any favours
16:46:14 <SamB> and threatening to do it *again* is a *really* bad idea
16:46:21 <flawed> lol
16:46:28 <flawed> well i'll just stick around here till you leave cale
16:46:33 <SamB> it totally ruins your credibility
16:46:43 <Cale> There's basically always an op around here now.
16:46:44 <dcoutts> flawed, Cale isn't the only op here
16:47:00 <flawed> well we'll see
16:47:00 <Cale> We added a few after last time because you were such a problem
16:47:24 <SamB> was this the one with the penisbird?
16:47:29 <Cale> SamB: yeah
16:47:41 * Igloo wonders why flawed is still here
16:47:45 <flawed> lol
16:48:22 <SamB> Igloo: because he hasn't quite managed to annoy Cale out of the "talk about it" mode?
16:48:29 <EvilRanter> he is? I /ignored at "i guess we have to start this bullshit again"
16:48:45 <Cale> Yeah, this is really offtopic. In any event, if you're serious about self-reform, I'll talk to HiLander about it, but given your remarks, I really don't know.
16:49:18 <EvilRanter> I find "your a moron! unban me, or i shall TAUNT YOU A SECOND TIME!!" to be a particularly poor attempt
16:50:03 <dcoutts> EvilRanter, it'd have been better if he really had use the python quote :-)
16:51:27 <flawed> EvilRanter: i tried discussing this rationally
16:51:28 <flawed> like
16:51:31 <flawed> how i haven't bothered anyone in MONTHS
16:51:38 <flawed> he was the one uninterested in dealing with it
16:51:57 <Cale> I usually don't unban people who I haven't personally banned.
16:52:12 <Cale> If one of the other ops bans someone, then it's their decision.
16:52:56 <SamB> yeah. and you'd have to at least talk about it with them before reversing it, or risk angering them. and having fights between ops is not fun...
16:54:20 <svref> So I have a list of ballots of the form [(abe,33),(bette,64),(abe,13),(charlie,50),...]... what's the clever way to sum votes for abe, bette, and charlie?
16:54:58 <int-e> sort, groupBy and map
16:55:40 <int-e> assuming that abe, bette and charlie are ordered.
16:56:24 <svref> int-e: thanks!
16:56:38 <pkhuong-> int-e: s/map/fold/ ?
16:56:51 <cjeris> @hoogle groupBy
16:56:52 <lambdabot> List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
16:57:15 <svref> > group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
16:57:16 <lambdabot>  Parse error
16:57:26 <svref> > group "Mississippi"
16:57:28 <lambdabot>  ["M","i","ss","i","ss","i","pp","i"]
16:58:02 <SamB> funny, around here we tend to have ballots of a form isomorphic to Bool^n X (Either String Bool)^m
16:58:07 <int-e> pkhuong-: actually the map was meant to work on the separate groups. it'd involve a sum or a fold.
16:58:23 <pkhuong-> ah k.
16:58:23 <dolio> map (first head . second sum . unzip) . groupBy ((==) `on` fst) . sort
16:58:27 <dolio> Something like that.
16:58:53 * svref isn't really busily writing election software tonight
16:59:11 <int-e> unzip, nice.
16:59:13 * svref thought he'd try to keep it in theme for the americans here though
16:59:41 <cjeris> svref: "election" implies that the votes are counted... that's not necessarily what's going on here :p
16:59:48 <chessguy> @type (on)
16:59:50 <lambdabot> Not in scope: `on'
17:00:01 <chessguy> @hoogle on
17:00:03 <lambdabot> Test.QuickCheck.oneof :: [Gen a] -> Gen a
17:00:03 <lambdabot> System.Console.Readline.onNewLine :: IO ()
17:00:03 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
17:00:09 <sjanssen> I wrote my vote on a piece of paper, I'm fairly confident it will be counted
17:00:10 <dolio> on f g a b = g a `f` g b
17:00:11 <Adamant> svref, I'd feel a lot better if the voting software we use was written in Haskell
17:00:20 <dolio> it doesn't exist in the standard library yet.
17:00:26 <Adamant> that and it was open sourced.
17:00:48 <sjanssen> Adamant: totally
17:00:52 <chessguy> hmm
17:01:02 <RemiTurk> indeed, if it weren't open source it'd merely allow diebold to screw america more easily
17:01:02 <sjanssen> next time some state wants voting machines, #haskell is totally going to bid
17:01:07 <RemiTurk> oops, did I say that?
17:01:17 <Adamant> then again, maybe we'd have to worry about SPJ pulling a Ken Thompson on the ghc compiler
17:01:25 <Adamant> ;)
17:01:55 <RemiTurk> or maybe that "ken" in almost all the worlds software now...
17:02:01 <int-e> well, maybe that has already happened.
17:02:34 <RemiTurk> the first ghc was compiled by... gcc?
17:03:14 <Adamant> I would hate to have to check a disassembly of gcc for compiler trojans
17:03:27 <Adamant> or any real compiler
17:04:02 <chessguy> compiler trojans?
17:04:34 <Adamant> chessguy, a tweaked compiler that inserts backdoors, etc. in special code it compiles
17:04:43 <chessguy> hmm
17:04:51 <RemiTurk> http://www.acm.org/classics/sep95/
17:04:52 <lambdabot> Title: ACM Classic: Reflections on Trusting Trust
17:04:56 <Adamant> @google "Reflections on Trusting Trust"
17:04:58 <lambdabot> http://www.acm.org/classics/sep95/
17:04:58 <lambdabot> Title: ACM Classic: Reflections on Trusting Trust
17:04:59 <Adamant> arrgh
17:05:06 <Adamant> ya got me RemiTurk!
17:05:07 <dcoutts> Adamant, I think all you need is to write another compiler, because even if you compile that with the tainted compiler it can't insert code into the resulting compiler to make that compiler taint things it compiles. That's far too compilcated.
17:05:14 <chessguy> oh is that thompson's speech?
17:05:15 <RemiTurk> Adamant: :PP
17:05:21 <Adamant> dcoutts, read the paper
17:05:50 <dcoutts> Adamant, recognising itself is one thing, recognising a compiler for an arbitrary language and making that taint things is too hard.
17:06:11 <Adamant> dcoutts, that's only true if you are creating a new compiler from scratch
17:06:44 <Adamant> you can create "signatures" for existing compilers
17:07:06 <dcoutts> only if you make the compiler after the thing you're trying to infect
17:07:07 <pkhuong-> dcoutts: yes, there was a paper by someone at the naval academy (iirc) that depended on having 2 compilers
17:08:01 <dcoutts> so yeah, all you need to do is make a new compiler and you can bootstrap that with the infected compiler
17:08:18 <Adamant> I think the guy who wrote "Secure Linux/Unix Programming HOWTO" wrote a good paper on beating trojaned compilers.
17:09:03 <RemiTurk> btw, I solved my Read speed problem by implementing a parseReadable :: Read a => GenParser Char st a: Most of the time was spent in the much easier [Int] parser anyway
17:09:18 <dcoutts> eg make a new C compiler in Haskell, and bootstrap that using hugs that was compiled with the tainted C compiler.
17:10:23 <int-e> maybe Ken solved the problem of program equivalence ;)
17:11:13 <monochrom> How to beat trojaned compilers?
17:12:35 <monochrom> RemiTurk: Doesn't parseReadable use Read?  How to make it faster than Read?
17:14:23 <RemiTurk> monochrom: I wanted String->([Int],Double)  The ([Int], ...) part was easy (and fast) in parsec, but I didn't like implementing the Double part myself
17:14:51 <monochrom> Ah! Way to go.
17:15:36 <RemiTurk> monochrom: But as the [Int] parsing takes most of the time anyway, I decided to fallback on standard Read for the Double part (using my parseReadable (thank goodness for get/setInput))
17:16:43 <monochrom> Yes that works.
17:18:07 <RemiTurk> although I guess I've got a new problem now: I optimized the Int-parser further, got it to take less time, but apparantly the rest became slower due to this ^o)
17:18:22 <RemiTurk> oh well
17:18:28 <RemiTurk> perhaps I should get some sleep
17:18:38 <monochrom> If Read is asked to parse just one Double, it can't be that slow.
17:18:58 <psykotic> monochrom, re: trojaned compilers, there's a famous talk that ken thompson gave as his turing award acceptance speech that introduced the issue.
17:19:04 <int-e> > read ('"':repeat ' ') :: Double
17:19:09 <lambdabot> Terminated
17:19:23 <int-e> monochrom: is that slow enough? ;-)
17:23:55 <monochrom> The Turing Award lecture defines the problem.  But no solution.  I know the problem.
17:25:23 <pkhuong-> @google Countering Trusting Trust through Diverse Double-Compiling
17:25:27 <lambdabot> http://www.acsac.org/2005/abstracts/47.html
17:25:28 <lambdabot> Title: ACSAC (www.acsac.org): Countering Trusting Trust through Diverse Double-Compilin ...
17:25:49 <monochrom> Oh diversity.  That sounds right.
17:25:58 <pkhuong-> mmm... iirc, it was on the author's homepage too.
17:32:31 <cmarcelo> @paste
17:32:32 <lambdabot> http://paste.lisp.org/new/haskell
17:37:17 <lisppaste2> cmarcelo pasted "fundeps behaviour => difference between 6.4.2 and 6.6" at http://paste.lisp.org/display/29470
17:39:19 <dolio> That seems like it shouldn't compile.
17:39:44 <cmarcelo> dolio: why not?
17:40:30 <dolio> Because a -> m says that for any a, there is a uniqe m, but the instance says that given a = A, m can be any monad.
17:40:32 <dolio> Right?
17:41:22 <dolio> I'm not a fundep expert, though.
17:42:02 <cmarcelo> yes, makes sense indeed.. I'll try something here.
17:44:14 <cmarcelo> dolio: changed to "data A m = A" (phantom, right?), and now instance "RI m (A m)", and now both works. tks. I wonder why 6.6 works with the less tight version...
17:44:46 <int-e> cmarcelo: add  x1 = hello "World" :: IO A; x2 = hello "World" :: Maybe A  and get a funny error message
17:45:17 <dolio> Does 6.6 just not complain as long as you only actually use one monad, then? :)
17:45:34 <int-e> dolio: that's what it looks like
17:45:39 <dolio> Heh.
17:48:24 <dons> ?yow!
17:48:24 <lambdabot> Well, I'm INVISIBLE AGAIN ... I might as well pay a visit to the LADIES
17:48:25 <lambdabot> ROOM ...
17:48:27 <int-e> I also think the code shouldn't compile though.
17:48:27 <cmarcelo> int-e: IO (A IO) and Maybe (A Maybe) works.. "A" alone is the constructor, the type is "A m"
17:48:31 * dons is at APLAS
17:48:44 <dons> lots of fun talk, type inference for MPTCs, exceptions in multi-staged lisp
17:48:54 <dons> private row types for ocaml
17:49:03 <int-e> cmarcelo: you had  data A = A
17:49:28 <cmarcelo> oh. sorry. I changed to data A m = A to make it work on 6.4.2..
17:49:35 <coffeemug> hey guys
17:50:06 <pkhuong-> dons: multi-staged lisp? Linky? (:
17:50:19 <cmarcelo> int-e: it allows any combination "m (A m)" to work.. I'll repaste, just a sec..
17:50:23 <coffeemug> I just encountered a slight issue
17:50:28 <int-e> cmarcelo: I know what you did
17:50:34 <coffeemug> it looks like runhaskell outputs errors to stdout, not stderr
17:50:42 <coffeemug> which really sucks for CGIs
17:50:45 <int-e> cmarcelo: I just experimented with the lack of error in ghc 6.6 some more.
17:51:56 <dons> pkhuong-: "Type and Effect Systems for Multi-Staged Exceptions', Eo, Kim and Yi.
17:51:57 <int-e> cmarcelo: and found that you get an error if you actually use RI m A with two different monads for m.
17:52:04 <dons> pkhuong-: i'll have a write up for the HWN done by tonight
17:52:18 <pkhuong-> dons: thank you.
17:52:34 <dons> coffeemug: how about myerror = hPutStrLn stderr "foo" ?
17:52:45 <dons> (if that's the case, re. runhaskell)
17:53:02 <coffeemug> dons: I mean if I run runhaskell Blah.hs
17:53:06 <coffeemug> and it can't find Blah.hs
17:53:15 <coffeemug> it outputs "can't find Blah.hs" to stdout, not stderr
17:53:37 <dons> ah right. yeah
17:53:39 <cmarcelo> int-e: ah. I get it now. the 6.4.2 fix actually is relevant for 6.6..
17:53:49 <dons> I *think* that's fixed in 6.6? or else ghc is fixed for that in 6.6
17:53:52 <dons> not sure about runhaskell
17:53:56 <coffeemug> which confuses the webserver since it can't know whether it needs to prepend "\r\n"
17:54:08 <dons> roll your own runhaskell wrapper?
17:54:13 <dons> that checks the exit status?
17:54:31 <coffeemug> well, I have my own webserver
17:54:36 <coffeemug> so I can just do it there
17:54:56 <dons> ok. you could report it though
17:54:59 <dons> would be easy to fix
17:55:05 <dons> stick a not on the ghc Trac bug tracker
17:55:07 <dons> s/note/
17:55:18 <dons> (or even submit a patch to runhaskell.hs ?)
17:55:49 <coffeemug> a bit scary to dive into runhaskell :)
17:55:56 <coffeemug> what's the url of the bug tracker?
17:55:58 <dons> its only a single module, iirc
17:56:07 <dons> it's finable from http://haskell.org/ghc
17:56:10 <lambdabot> Title: The Glasgow Haskell Compiler
17:56:16 <dons> when you find it, hand me the url, and I'll @where+ it
17:56:52 <zeeeeeee> hi all, in 'do' blocks, <- assigns the return of another monadic function, but how do i assign the return of a regular function (as in 'let')? i get errors when trying to use lets in my 'do's.
17:57:12 <dons> use let
17:57:13 <coffeemug> http://hackage.haskell.org/trac/ghc
17:57:16 <lambdabot> Title: GHC - Trac
17:57:18 <dons> demo...
17:57:36 <dons> > flip runState 0 $ do x <- get ; let y = x + 1 ; put y ; return 7
17:57:37 <lambdabot>  Parse error
17:57:50 <dons> ah, well, it works, i think that's the h98 parser kicking in :)
17:57:54 <dons> > flip runState 0 $ do x <- get ; let y = x + 1 in do put y ; return 7
17:57:56 <lambdabot>  (7,1)
17:58:05 <dons> (but you don't need the 'in' )
17:58:07 <dons> also,
17:58:13 <zeeeeeee> > flip runState 0 $ do putStr "hello"
17:58:14 <lambdabot>  Couldn't match `State b a' against `IO ()'
17:58:19 <dons> > flip runState 0 $ do x <- get ; y <- return $ x + 1 ; put y ; return 7
17:58:21 <lambdabot>  (7,1)
17:58:26 <dons> state monad. no IO for you@!
17:58:44 <zeeeeeee> erm
17:58:45 <dons> so you can always lift the pure computation, with 'return'. but its easier to just use a do-ish 'let'
17:58:45 <zeeeeeee> hm
17:59:01 <dons> so the syntax is: do x <- a ; let y = x + 1; return b
17:59:17 <zeeeeeee> dons: ok, so this 'let' is actually a different let
17:59:30 <dons> sort of. its' really a let .. in ...
17:59:32 <dons> with some sugar
17:59:38 <zeeeeeee> dons: thanks!
17:59:43 <dons> since we know what the 'in' part is, in a do block, its the rest of the block
18:00:50 <int-e> the sugar covers the ' in ' *g*
18:00:53 <spiffy> back to the State monad i see :)
18:01:11 <dons> spiffy: its a nice useful *safe* monad to play with in irc :)
18:01:23 <int-e> @type do x <- a ; let y = x + 1; return b
18:01:25 <lambdabot> parse error (possibly incorrect indentation)
18:01:27 <dons> control those effects, and we get the typechecker giving us safety proofs
18:01:31 <int-e> @type do x <- a ; let { y = x + 1 }; return b
18:01:33 <lambdabot> Not in scope: `a'
18:01:33 <lambdabot>  
18:01:33 <lambdabot> <interactive>:1:38: Not in scope: `b'
18:01:35 <spiffy> Im still playing around with it. Its an interesting little beast.
18:01:50 <dons> > flip runState 0 $ do x <- get ; let { y = x + 1 } ; put y ; return 7
18:01:52 <lambdabot>  (7,1)
18:01:53 <coffeemug> I have to try this with 6.6
18:01:55 <dons> int-e++
18:01:55 <coffeemug> brb
18:01:56 <zeeeeeee> dons: so the way to get the value out of a monad is via <-
18:01:57 <zeeeeeee> ?
18:02:05 <dons> zeeeeeee: of evaluate a monadic action, yeah.
18:02:18 <dons> to actually get a value *out* of a monad, and back into pure code, you use run* for your monad
18:02:22 <dons> n.b. IO has no run* action
18:02:31 <dons> its a black whole of side-effecting doom!
18:02:31 <int-e> > flip runState 0 $ get >>= put . (1+) >> return 7
18:02:33 <lambdabot>  (7,1)
18:02:45 <dons> *whole*!
18:03:05 <dons> kpreid: thanks for the @unpl patch, but it seems to have misfired ? content of file: "???
18:03:08 <dons> "
18:03:19 <SamB> runIO = unsafePerformIO -- DOOM AND DESPAYRE!
18:03:35 <dons> sssh!
18:03:40 <zeeeeeee> dons: i guess my real question is...is the easiest way of seeing the "return value" of my monadic function by writing "do x <- myFuncM "blah"; putStr (show x); return 0"?
18:03:43 * int-e slaps SamB with an unsafeSpoon
18:03:44 <spiffy> dons: One thing of discovered since the last time we talked. The joys of calling a state action inside of a state action. they *gasp* share state!.
18:03:48 <dons> zeeeeeee: yep
18:04:00 <dons> spiffy: heh
18:04:05 <zeeeeeee> dons: (from the ghci interpreter)
18:04:12 <dons> ah, yeah, use print
18:04:13 <kpreid> dons: checking
18:04:19 <dons> ie. myaction >>= print
18:04:29 <spiffy> dons: I was honestly surprised when i got that one. Not sure why, it just makes sense.
18:04:32 <dons> i thought there was a ghci flag now to turn on printing by default
18:04:42 <dons> spiffy: cool :)
18:04:55 <zeeeeeee> dons: thanks agai
18:04:56 <zeeeeeee> n
18:05:06 <kpreid> dons: hm, my client appears to have produced a badly structured message
18:05:07 * dons notes down: "state monads make sense" -- spiffy
18:05:30 <kpreid> dons: the attachment is inside one half of an alternative.
18:05:34 <int-e> dons: if by 'flag' you mean 'use ghci 6.6'?
18:05:37 <psykotic> spiffy: you can of course do a runState on it to have it run in isolation.
18:05:37 <spiffy> laugh I resent that.
18:06:01 <dons> int-e, ah so it prints by default now?
18:06:04 <zeeeeeee> if i want to (say) multiply the 'return values' of 2 monads, i would first need to extract their values by assigning each with a <-, then multiply?
18:06:09 <dons> i thought we had a flag to toggle printing.
18:06:14 <spiffy> psykotic: ya I figured that out too. All kinds of fun stuff in haskell :D
18:06:28 <int-e> dons: I don't know. I've never seen one.
18:06:28 <dons> zeeeeeee: there's ways to combine them , but <- will be easier on the brain to start with
18:06:39 <dons> do x <- get1 ; y <- get2 ; ... x * y .. ?
18:06:43 <coffeemug> dons: ok, no need for bug reports
18:06:44 <zeeeeeee> i.e. nothing shorter than: do x <- f 1; y <- f 2; let z = x*y
18:06:52 <coffeemug> this has, in fact, been fixed in 6.6
18:06:59 <dons> ?unpl do x <- f 1; y <- f 2; let z = x*y
18:07:00 <lambdabot> Maybe you meant: pl undo url
18:07:00 <kpreid> dons: clarification: I think it's there, but your client isn't displaying it
18:07:02 <dons> ?undo do x <- f 1; y <- f 2; let z = x*y
18:07:03 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
18:07:13 <dons> ?. pl undo do x <- f 1; y <- f 2; let z = x*y in return z
18:07:14 <lambdabot> (line 1, column 35):
18:07:15 <lambdabot> unexpected "{"
18:07:15 <lambdabot> expecting natural, identifier or "in"
18:07:20 <dons> ?. pl undo do x <- f 1; y <- f 2; let { z = x*y } in return z
18:07:21 <lambdabot> (line 1, column 35):
18:07:21 <lambdabot> unexpected "{"
18:07:21 <lambdabot> expecting natural, identifier or "in"
18:07:26 <spiffy> I found myself writing type signatures on my physics midterm today too
18:07:37 <SamB> heh
18:07:47 <SamB> one or two colons?
18:07:47 <zeeeeeee> dons: that's the 'wrong let', isn't it?
18:07:51 <dons> ?. pl undo undo do x <- f 1; y <- f 2; let { z = x*y }; return z
18:07:52 <lambdabot> (line 1, column 21):
18:07:52 <lambdabot> unexpected "{"
18:07:52 <lambdabot> expecting variable, "(", operator or ")"
18:07:54 <dons> ?. pl undo do x <- f 1; y <- f 2; let { z = x*y }; return z
18:07:55 <lambdabot> (line 1, column 35):
18:07:55 <lambdabot> unexpected "{"
18:07:56 <lambdabot> expecting natural, identifier or "in"
18:08:00 <dons> hmm. weird.
18:08:02 <dons> works in my bot ..
18:08:11 <dons> ah, its @pl failing
18:08:15 <dons> ?undo do x <- f 1; y <- f 2; let { z = x*y }; return z
18:08:16 <lambdabot> f 1 >>= \ x -> f 2 >>= \ y -> let { z = x * y} in return z
18:08:48 <int-e> dons: changes in ghci: "    *
18:08:48 <int-e>       GHCi now invokes print by default on the result of IO actions and bindings at the prompt. This is occasionally not what you want, so it can be disabled (at least for bindings) with :set -fno-print-bind-result. See Section 3.4.2, “Using do-notation at the prompt”."
18:08:49 <dons> (`fmap` f 2) . (*) =<< f 1
18:08:50 <zeeeeeee> dons: does `undo` show a shorter/shortest equivalent?
18:09:02 <dons> it unsugars the do notation
18:09:07 <spiffy> SamB: two
18:09:16 <dons> ?undo do x <- f 1; y <- f 2; return (x * y)
18:09:17 <lambdabot> f 1 >>= \ x -> f 2 >>= \ y -> return (x * y)
18:09:20 <dons> ?. pl undo do x <- f 1; y <- f 2; return (x * y)
18:09:21 <lambdabot> (`fmap` f 2) . (*) =<< f 1
18:09:25 <dcoutts> nice
18:09:30 <zeeeeeee> wow
18:09:45 <dons> which, once unsugared, we can feed to the refactorer
18:10:06 <SamB> hmm.
18:10:24 <dons> ?type \f -> (`fmap` f 2) . (*) =<< f 1
18:10:26 <lambdabot> forall (f :: * -> *) a t. (Monad f, Functor f, Num a, Num t) => (t -> f a) -> f a
18:10:26 * SamB is getting a stack overflow with smallcheck...
18:10:26 <RemiTurk> good night everybody
18:10:30 <dcoutts> int-e, I'm convinced that the right behaviour is to not print if you bind a result with <-
18:10:49 <dons> dcoutts: but pretty much every other interpreter prints results..
18:10:54 * RemiTurk agrees with dcoutts
18:10:55 <dons> ocaml, ruby ...
18:10:56 <dcoutts> int-e, so readFile "foo" would print the content, but c <- readFile "foo" would not print
18:10:57 <kpreid__> dons: oh, btw, something about lambdabot's build process didn't like my having a string literal like "foo \
18:10:59 <dons> so it should be switchable
18:11:00 <kpreid__> \\n bar \
18:11:03 <kpreid__> \ " in Pointful.hs
18:11:04 <RemiTurk> bye
18:11:08 <kpreid__> (so I replaced it with unlines)
18:11:14 <dons> kpreid__: that \\n is on the wrong end of the string, isn't it?
18:11:21 <kpreid__> no
18:11:22 <SamB> % python
18:11:22 <SamB> Python 2.3.5 (#2, Jul 30 2006, 15:57:01)
18:11:22 <SamB> [GCC 4.1.2 20060715 (prerelease) (Debian 4.1.1-9)] on linux2
18:11:22 <SamB> Type "help", "copyright", "credits" or "license" for more information.
18:11:22 <SamB> >>> x = 1
18:11:22 <SamB> >>>
18:11:24 <dons> unlines is fine. ghc'll spot it anyway
18:11:32 <kpreid__> the first \ is the second half of a line continuation
18:11:32 <dcoutts> dons, sure but a sensible default I think is not to print if you're binding a value with <-
18:11:41 <kpreid__> it works fine with ghc/ghci, but not after ./build
18:11:45 <SamB> dcoutts: indeed
18:11:47 <dcoutts> dons, I think that "does what I mean" more of the time.
18:11:51 <dons> ok. well python is a weirdo. "for PhDs only"-- or whatever that reddit common about python v php was.
18:11:55 <dons> :)
18:11:57 <int-e> dcoutts: agreed
18:12:01 <kpreid__> dons: did you find the attachment?
18:12:07 <SamB> Python is *not* for PhDs.
18:12:14 <SamB> PHP *is* apparantly for idiots, though
18:12:19 <lisppaste2> jgrimes pasted "simple fix?" at http://paste.lisp.org/display/29477
18:12:20 <dons> kpreid__: ah god it.
18:12:23 <dcoutts> int-e, SamB, I did propose this when the change was suggested, perhaps we should suggest it again.
18:12:23 <dons> s/got/
18:12:27 <spiffy> well, im off. Just poped in to see what new and amazing things #haskell had come up with today.
18:12:42 <jgrimes> anyone want to take a look at that? :)
18:12:47 <dons> spiffy: :)
18:13:00 <dons> i'd like to have something fun and new *everyday*
18:13:03 <dons> maybe we need a todo list
18:13:06 <dons> on the wiki
18:13:09 <jgrimes> it isn't outputting anything... where I would think it would output what the program "test" output
18:13:10 <jgrimes> s
18:13:10 <dons> for cool things to try to get working
18:13:21 <dcoutts> jgrimes, suggestion for next time you post this kind of thing: paste the error message too!
18:13:30 <jgrimes> no error message
18:13:31 <jgrimes> :)
18:13:36 <dcoutts> jgrimes, ok, then the problem
18:14:09 <jgrimes> dcoutts, will do.
18:14:13 <dons> SamB: the genii of reddit disagrees with you: to quote tubby: "Python's stuck-up, arrogant, PhD in CS attitude is its sole down fall. It's a great langauge, but a lot of arrogant assholes use it."
18:14:30 <dons> there are some weird, broken people in the world
18:14:34 <spiffy> dons: O im sure our versions of "fun and new" are completely different. Im still amazed by infinite lists.
18:14:40 <dons> :)
18:14:45 <dons> > [1..] -- have a free one
18:14:45 <dcoutts> jgrimes, that code looks ok to me, so I don't know what's wrong.
18:14:46 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:15:08 <SamB> dons: we don't take their advice when determining how GHCi should behave, generally
18:15:14 <dons> heh. fair enough
18:15:16 <SamB> anyway, does PHP even have a REPL?
18:15:24 <jgrimes> dcoutts, yeah, and I got it from a program that works for others, but doesn't work for me.
18:15:33 <dons> what is this PHP you speak of? i'm not familiar with a language by that name
18:15:34 <pkhuong-> SamB: yeah, any of the thousands of holed servers.
18:15:45 <SamB> pkhuong-: I meant a REPL with a REPL UI
18:15:50 <spiffy> uh oh. anyway to kill GHCi and bring it back to a prompt. I may have printed the fibanacci sequence.
18:16:02 <SamB> C-c!
18:16:03 <dons> heh
18:16:13 <Igloo> jgrimes: Try putting "forkIO $ " before the evaluate, and compile with -threaded
18:16:33 <jgrimes> oh.. wait. I found the problem
18:16:44 <jgrimes> I need ./test instead of just test..
18:16:47 <jgrimes> -_-
18:16:49 <Igloo> Ah, OK
18:16:57 <jgrimes> of course it would be something simple =/
18:17:37 <araujo> hellu
18:18:55 <SamB> I can't figure out how to set a variable in Scheme
18:19:19 <araujo> (set! .. ) ?
18:20:05 <SamB> okay
18:20:11 <SamB> guile> (set! foo 'bar)
18:20:12 <SamB> guile> foo
18:20:12 <SamB> bar
18:20:29 <SamB> (see? no printing! CL was wierd though.)
18:20:55 <lispy> araujo: i want to forward you an email, if you don't mind, please /msg me with your email
18:21:00 <spiffy> SAmB, not only no printing, but no defined return value.
18:21:13 <araujo> hi hi lispy
18:21:16 <araujo> lispy, sure
18:21:21 <SamB> spiffy: those tend to go together ;-)
18:21:39 <spiffy> that always bugged me
18:21:41 <spiffy> always
18:21:51 <jgrimes> lispy, I got the tests working for helisp, and the 32 bit port fails two of them , both of which are due to overflow, so.. I'll be looking at that
18:22:24 <SamB> actually, Python does it that way because assignments aren't expressions, which is in turn because of the tendancy to write stuff like...
18:22:35 <SamB> while n = 1:
18:22:35 <lispy> jgrimes: ah yeah, makes sense since the 2^61 stuff is hardcoded
18:22:43 <lispy> jgrimes: that's really cool, btw
18:22:44 <SamB> instead of
18:22:48 <SamB> while n == 1:
18:23:05 <SamB> so basically, because the creators know they are idiots...
18:23:30 <SamB> then again that is also the idea behind typechecking ;-)
18:25:28 <dons> ?where+ trac http://hackage.haskell.org/trac/ghc/newticket?type=bug
18:25:30 <lambdabot> Done.
18:26:29 * lispy is watching a live presentation on how to use inkscape
18:26:37 <lispy> maybe now i'll be able to make a tshirt design
18:28:25 <Igloo> My problem isn't how to use tools, but how to make something nice with them
18:29:07 <dons> Igloo: so when were we thinking to have the hackathon?
18:29:16 <dons> 2 or 3 days, including the weekend, before PADL/POPL?
18:29:32 <dons> i'd might come up with a preliminary schedule/plan and seek some comments
18:30:06 <zeeeeeee> > return 0
18:30:07 <lambdabot>  add an instance declaration for (Show (m a))
18:30:15 <zeeeeeee> > show( return 0)
18:30:17 <lambdabot>  add an instance declaration for (Show (m a))
18:30:17 <lambdabot>   In the definition of `btw'...
18:30:34 <Igloo> Well, it mostly depends on how long people want to spend on it and when PADLers need to leave
18:30:34 <zeeeeeee> > return 0 >>= print
18:30:35 <lambdabot>  No IO allowed
18:30:48 <zeeeeeee> > do return 0
18:30:49 <lambdabot>  add an instance declaration for (Show (m a))
18:31:36 <lispy> ?pl do return x
18:31:37 <lambdabot> do return x
18:31:47 <lispy> ?. pl undo do return x
18:31:48 <lambdabot> return x
18:31:57 <zeeeeeee> lispy: ah, so they're the same
18:32:11 <zeeeeeee> do return x and return x
18:32:46 <lispy> zeeeeeee: yup
18:40:39 <shapr> dcoutts: You pinged?
18:41:03 <dcoutts> shapr, oh, sorry ages ago, one of Cale's stalkers
18:41:06 <dcoutts> sorted now
18:41:15 <sieni> hmph, what a time to wake up
18:41:36 <shapr> I think that's the same stalker as last time.
18:41:37 <sieni> although 4:40 am is better than yesterday's 3:50 am
18:41:46 <dcoutts> shapr, aye
18:42:06 <dcoutts> shapr, so one to watch for when Cale is elsewhere
18:42:22 <shapr> Since his #math talk just takes up space on #haskell, I'll ban him instantly next time he mentions it.
18:42:28 <dons> which one was that?
18:42:38 <dcoutts> shapr, do we have enough ops btw, I could be one I guess since I tend to be around quite a bit.
18:42:46 <shapr> No wait, he's not talking about #math, he's talking about politics of being banned on #math
18:42:55 <dcoutts> dons, ssh, don't mention his name :-)
18:43:16 <dons> heh
18:43:35 <lispy> banning Cale seems a bit extreme....
18:43:37 <lispy> ;)
18:43:49 <shapr> :-P
18:44:04 <shapr> dcoutts: It's okay by me, but you should ask the guy in charge of #haskell :-)
18:44:16 * shapr points at dons
18:44:33 <lispy> shapr: did you used to carry that torch?
18:44:42 <dcoutts> for years
18:44:44 <shapr> Yeah, for more than five years.
18:44:49 <lispy> shapr: nice!
18:45:03 <shapr> From the time I started #haskell
18:45:24 <dons> ?users
18:45:25 <lambdabot> Maximum users seen in #haskell: 265, currently: 229 (86.4%), active: 35 (15.3%)
18:45:25 <lispy> and i got to shake your hand!
18:45:29 <dons> and its flourishing
18:45:36 * shapr grins
18:45:38 <dons> ?where stats
18:45:39 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
18:45:59 <shapr> And now dons is a better choice for keeping the community focussed and moving.
18:46:11 <dons> less talk, more code!
18:46:16 * dons grins
18:46:19 <lispy> yeah, he's doing a good job but i didn't want to say that and give him a big head ;)
18:46:22 <shapr> exactly :-)
18:46:26 * shapr goes back to code
18:46:36 * dmead is happy
18:46:43 * dmead 's party is kicking ass
18:47:02 <SamB_XP> dons: so why haven't you gone on a banning spree, if you want us to talk less?
18:47:26 <dons> Igloo: so i'm thinking something like 3 days. And tasks such as: make hackage work. "port your favourite library", release some more projects
18:47:36 <dons> SamB_XP: its ok if you *talk code*
18:47:42 <SamB_XP> oh okay
18:47:47 <dons> > fix (:1) -- :)
18:47:49 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
18:47:49 <lambdabot>    Expected...
18:47:55 <dons> now, explain!
18:48:00 <sieni> argh
18:48:08 <lispy> > fix (1:)
18:48:10 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:48:12 <sjanssen> "talk amongst yourselves"
18:48:20 * lispy fixes the bug
18:48:25 <dons> sjanssen: any chance you'd be able to make it to oxford for a hackathon?
18:48:35 <SamB_XP> you tried to buuild the list [[[[...,1],1],1],1]
18:48:38 <dons> or i wonder if we could run simultaneous US and UK-based ones.
18:48:45 <SamB_XP> but the type of that list is... um...
18:48:54 <dons> SamB++
18:48:55 <shapr> dons: That would rock!
18:48:56 <pkhuong-> SamB: infinite :)
18:49:00 <Igloo> dons: OK, that's fine with me
18:49:13 <SamB_XP> [[[[...Int...]]]]
18:49:19 <SamB_XP> or is that Integer
18:49:30 <SamB_XP> and, that type isn't legal in Haskell
18:49:31 <sjanssen> dons: that'd be fun, but I don't think I can buy tickets all the way across the ocean
18:49:45 * dons isn't sure how much trans-atlantic flights cost
18:49:51 <dons> i guess they're cheaper than trans-pacific
18:49:52 <SamB_XP> probably because HM-typing isn't lazy
18:50:04 <lispy> dons: for 4 people it's about $8k (just saw a statistic)
18:50:05 <Igloo> Too much for 3 days of hacking, I'd say  :-)
18:50:12 <dons> fair enough
18:50:16 <cdrubin> @paste
18:50:17 <lambdabot> http://paste.lisp.org/new/haskell
18:50:29 <SamB_XP> sjanssen: how about half-way?
18:50:39 <dons> iceland?
18:50:53 * monochrom shudders
18:50:58 <SamB_XP> oh, I was thinking they'd drop you off in the middle with a life raft
18:51:04 <Igloo> Although all the tickets I've looked at have been across the Atlantic and then across America, thinking about it
18:51:06 <dons> has to be oxford anyway, since we get a free venue
18:51:09 <pkhuong-> SamB: not really. I have an eager system, and it unifies constructs like that correctly to "a : (list a)". I'm pretty sure there's a specific check for circularity.
18:51:36 <lispy> oh yeah, actually my statistic was just oregon to sydney
18:51:39 <dcoutts> g'night folks
18:51:54 <lispy> so transatlantic might be even more
18:51:55 <lisppaste2> cdrubin pasted "Too tired to see straight..." at http://paste.lisp.org/display/29481
18:52:12 <dons> lispy: hmm. but oregon -> oxford is not 13 hours, surely?
18:52:24 <dons> more like 8?
18:52:24 <cdrubin> Evening all
18:52:33 <Igloo> I think it was 500 and something UKP to get to ICFP et al and back
18:52:35 <cdrubin> I hope that you might consider helping a tired soul
18:52:57 <cdrubin> I have pasted my stuff here http://paste.lisp.org/display/29481
18:53:09 <pkhuong-> cdrubin: syntax wrong. Parens go around the application, not the arguments.
18:53:09 <kpreid__> cdrubin: f(x y) doesn't mean what you think it means
18:53:12 <shapr> dons: Oregon to Oxford will probably be 12+ hours if you include a layover.
18:53:14 <dons> cdrubin: syntax, eqExpr( expr1right expr2right )
18:53:23 <dons> should be: (eqExpr expr1right expr2right)
18:53:31 <dons> or expr1right `eqExpr` expr2right
18:53:31 <cdrubin> :) good lord
18:53:40 <kpreid__> (note that those parens are perfectly fine if your application is uncurried, though!)
18:53:41 <dons> or, instance Eq Expr where (==) = eqExpr
18:53:48 <dons> and then, expr1right == expr2right
18:53:53 <kpreid__> > let f = uncurry (==) in f(1, 1)
18:53:55 <lambdabot>  True
18:54:03 <cdrubin> Wow!
18:54:08 <cdrubin> Thanks all. :)
18:54:21 <kpreid> well, not *those* parens. you need a comma.
18:54:24 <kpreid> as I showed
18:54:31 <dons> also, i see you're using hugs. if you have time, installing ghc might be fun, since you get to compile your code to an executable
18:54:31 <cdrubin> ta
18:54:48 <shapr> dons: Unless there's a direct flight from Portland to Oxford. Nowadays security and similar cattle processing takes up much of the time.
18:54:57 <dons> yeah, true.
18:55:02 <cdrubin> Is there any sort of web framework used by the Haskell gang?
18:55:13 <cdrubin> (that is a Haskell framework of course...
18:55:14 <dons> HAppS is one.
18:55:14 * Igloo looks it up: 600 quid, 16h 21m one way and 14h the other
18:55:25 <dons> then there's the new AJAX/haskell binding we got from the summer of code
18:55:30 <shapr> I like HAppS, but note my bias: I get paid to develop HAppS.
18:55:36 <dons> cdrubin: details on http://haskell.org, look under 'libraries and tools'
18:55:38 <lambdabot> Title: Haskell - HaskellWiki
18:55:43 <Igloo> Of which 14h 48 and 11h 39 are in the air
18:55:45 <dons> s/applications and libraries/ as its now called
18:55:45 <cdrubin> Hmmn... ace
18:55:51 <coffeemug> shapr: who funds HAppS?
18:55:52 <dons> Igloo: huh
18:55:56 <SamB_XP> shapr: oh, nice!
18:55:59 <SamB_XP> when did that happen?
18:56:05 <Igloo> dons: "huh"?
18:56:14 <shapr> SamB_XP: About a month ago.
18:56:15 <dons> "I get paid to develop HAppS" cool!
18:56:23 * shapr grins
18:56:41 <SamB_XP> and to think, you used to have to do Python and *shudder* PHP work!
18:56:58 <shapr> I've been doing webdev in Python & Java for about six years and I've been doing Haskell for about five years, so I think I have a good perspective.
18:57:12 <coffeemug> eww, Java :)
18:57:32 <monochrom> A coffee mug doesn't like Java...
18:57:44 <SamB_XP> the language, not the coffee, silly
18:57:46 <shapr> coffeemug: Alex Jacobson funds HAppS, but not because he thinks HAppS itself will make money.
18:58:09 <SamB_XP> does he think he can use it to make money?
18:58:22 <shapr> Alex has a bunch of good ideas for webapps that will make money, but he wants a heavy duty scalable webapp framework first.
18:58:28 <shapr> SamB_XP: yup
18:58:47 <weitzman> Aren't there enough heavy duty scalable frameworks already?
18:58:49 <weitzman> I've lost count
18:58:53 <shapr> And Heffalump said earlier that he thinks the single-threadedness of HAppS will be a problem, so I want to know why :-)
18:58:56 <SamB_XP> in what? PHP?
18:59:11 <Igloo> shapr: Because it means you can't scale to multiple threads?
18:59:31 <SamB_XP> yes, but why would you need to unless you were on a Sun?
18:59:35 <Igloo> Be they multiple cores, or multiple machines
19:01:08 <shapr> afaik, HAppS does scale to multiple machines by putting parts of the pipeline on their own machine.
19:01:21 <shapr> But I haven't tried that myself, I should experiment...
19:02:04 * Igloo doesn't know the details
19:03:27 <dons> the thing is that coding in SMP with forkIO or par is just so easy now, and we know it scales up big
19:03:36 <dons> so you may as well start using par/forkIO on single-cpu machines
19:03:44 <dons> so those threads will *just work* on multicore
19:03:56 * dons has to get a 16 core machine this week, for more DPH research
19:04:07 <dons> mmm. it's like xmas !
19:04:41 <shapr> !
19:05:01 <dons> i put some more comments on this stuff here, btw, http://programming.reddit.com/info/pylx/comments
19:05:04 <lambdabot> Title: Ask Reddit: Why is OCaml faster than Haskell? (reddit.com), http://tinyurl.com/y4qv6c
19:05:10 <SamB_XP> dons: what are you getting me for xmax?
19:05:13 <shapr> Will it be a MIPS x16? or an x86 with lots of mobo sockets?
19:05:20 <dons> sparc probably
19:05:26 <shapr> cool
19:05:32 <dons> the mips is too slow (its easier to get big speedups on slow boxes)
19:05:55 <dons> so we're getting 2 boxes, the biggest amd64 we can find (4 cores?) and then a 16+ core sparc
19:05:58 <dons> hopefully more
19:06:15 <SamB_XP> er. xmas.
19:06:27 <dons> and hopefully this will be something fun for dcoutts to play with when he's down here.
19:06:34 <shapr> Reminds me of the time I was trolling about adding a parallelization benchmark to the gcl shootout. Max Skaller said "but we don't have any languages that can transparently use multiple CPUs." and of course I'd set him up...
19:06:48 <dolio> One of the comments says that it's easy to implement lazy evaluation in OCaml. How would one do that? It doesn't have macros, does it?
19:07:04 <pkhuong-> dons: biggest amd64 is 4 cpu, dual core for now, quad soon, iirc.
19:07:28 <shapr> Doesn't Tyan make a four socket amd64 dual-core mobo?
19:08:12 <dons> yeah, we've a 2 cpu, 2 core, hyperthreaded machine atm.
19:08:13 <SamB_XP> dolio: doesn't it have some "camlp4" or somesuch?
19:08:16 <dons> but we need more1
19:08:25 <dons> Please Sir, can I have more cores?
19:08:38 * SamB_XP smacks dons good
19:08:39 <dolio> SamB: I don't know. My caml knowledge is pretty limited.
19:08:47 <SamB_XP> dolio: mine too!
19:09:04 <dons> shapr: yeah, i think there should be a parallel benchmark. soon enough, soon enough...
19:09:20 <pkhuong-> dolio: yeah, you can frob the syntax with camlp4, but iiuc, transformations can't be composed.
19:09:21 <dons> we're going to get a DPH/NDP array lib release out by christmas
19:09:34 <dons> SamB_XP: so that might be your gift :)
19:09:42 <dons> transparently parallel arrays, anyone?
19:09:46 <kpreid> do I correctly understand `par` is automatically ""thread-safe"" by way of doing only pure computations and updating the thunks safely? I haven't read much on that stuff
19:09:47 <dolio> Ah.
19:09:55 <dons> kpreid: yep.
19:09:59 <dons> lock-free updates, too
19:10:12 <kpreid> also, 6.4 doesn't do multithread `par`, right?
19:10:29 <dons> no. 6.6 does. multithread/multicore par
19:10:39 <SamB_XP> dons: oh, its just that I remember that that line is never met with much in the way of a helpful response...
19:10:55 <kpreid> dons: oh, warning: my patch doesn't update Modules.hs
19:11:12 <kpreid> (because I have other changes in that file's sole line which shouldn't be pushed)
19:11:19 <SamB_XP> kpreid: I bet it doesn't update DynModules.hs either!
19:11:21 <kpreid> Modules.hs can be autogenerated, right?
19:11:46 <SamB_XP> it used to be, afaik! but I didn't see anything to do that anymore!
19:12:05 <kpreid> I thought I saw some code to do that
19:13:32 <kpreid> dons: anyway, let me know when you've read Pointful.hs if you'd like to hear a ramble about the design choices
19:14:21 <shapr> Wow, qwe123 got -19 points on a comment??
19:14:44 <dolio> I think it's more amazing that he has one with 1 point.
19:14:52 <jgrimes> dolio, agreed.
19:15:02 <dolio> :)
19:15:03 <dons> kpreid: ok. i'll have a read of it today
19:15:14 <jgrimes> it's a rare thing for qwe123 to have positive points.
19:15:23 <dons> the reddit admins should just block you once you hit -1000 karma points
19:15:35 <shapr> hah
19:15:43 <dolio> Actually, I don't think you can have negative karma.
19:15:55 <SamB_XP> @karma dolio
19:15:56 <lambdabot> dolio has a karma of 4
19:16:02 <dons> right. otherwise there'd be a competition to have the lowest
19:16:03 <dolio> If you click on his name, it says he has 1 karma.
19:16:14 <SamB_XP> dons: really?
19:16:19 <sieni> @karma sieni
19:16:20 <lambdabot> You have a karma of 2
19:16:23 <SamB_XP> thats why you ban people at -400
19:16:24 <sieni> cool
19:16:35 <mattrepl> comments don't affect karma
19:16:41 <SamB_XP> oh
19:16:55 <SamB_XP> they ought to have millikarma
19:16:58 <SamB_XP> or something
19:17:01 <mattrepl> heh
19:18:35 <Adamant> @karma Adamant
19:18:35 <lambdabot> You have a karma of 0
19:18:59 <sieni> @karma dons
19:19:00 <lambdabot> dons has a karma of 81
19:19:07 <sieni> pretty leet
19:19:07 <Adamant> at least I'm not upsetting the natural karma balance
19:19:33 <kpreid> @localtime dons
19:19:36 <lambdabot> Local time for dons is Wed Nov  8 14:19:12 2006
19:19:43 <shapr> dons: Four sockets, each socket can have a dual-core opteron - http://www.tyan.com/products/html/thunderk8qsdpro.html
19:19:47 <lambdabot> Title: thunderK8QSDpro, http://tinyurl.com/awpje
19:19:51 <SamB_XP> @karma shapr
19:19:52 <lambdabot> shapr has a karma of 24
19:19:52 <dons> mmm
19:19:55 <kpreid> @localtime kpreid
19:19:57 <SamB_XP> @karma SamB
19:19:57 <lambdabot> SamB has a karma of 20
19:19:59 <lambdabot> Local time for kpreid is Tue Nov  7 22:19:34 2006
19:20:07 <kpreid> dons: as you can guess, I'll be asleep shortly
19:20:08 <sieni> @localtime sieni
19:20:12 <lambdabot> Local time for sieni is Wed Nov  8 05:19:46 2006
19:20:16 <SamB_XP> shapr++ shapr should have more more than I
19:20:21 <shapr> heh
19:20:24 <Adamant> shapr, when do we get qual-core Opterons?
19:20:27 <sieni> as you can guess, I just woke up :-/
19:20:36 <Adamant> 32 cores of processing goodness!
19:20:39 <shapr> Adamant: AMD says next year.
19:20:56 <shapr> I think the current approach is quite silly. The cpu/ram quilt makes more sense.
19:21:43 <SamB_XP> shapr: also makes things trickier with the OS and the memory allocation and all that, though
19:22:31 <SamB_XP> like, how would the program allocate memory associated with a given thread?
19:23:03 <SamB_XP> and it *would* need to
19:23:05 <shapr> There is existing literatuer on data locality. Not much though.
19:23:31 <shapr> Actually, I think edwardk's substructural typing could be used for that sort of thing.
19:23:42 <pkhuong-> shapr: locality has gotten so important that compressing the workset can improve performance :\
19:23:45 <SamB_XP> you would need to figure out OS interfaces, though
19:24:00 <shapr> The combination of uniqueness and linear types is a good thing.
19:24:11 <dons> so, a point i was making earlier. haskell people should, even if they don't have a multicore box, starting designing with forkIO in mind. since the program will run unmodified on the SMP rts, when you do get the extra cores
19:24:26 <shapr> pkhuong-: Yeah, but that's partly because MHz numbers sell the product, not cpu<->memory bandwidth numbers.
19:24:28 <dons> i'm going to run lambdabot on the 2x 2 core box this week sometime
19:24:34 <shapr> w00
19:24:35 <dons> and it should just eat the thing up
19:24:44 <dons> the only change is to add +RTS -N4
19:24:48 <SamB_XP> you would at *least* need to segregate allocation pools between threads, though I suppose GHC already does that?
19:24:48 <dons> to the command line :)
19:25:08 <shapr> SamB_XP: ghc-smp assumes shared memory.
19:25:18 <shapr> It ignores NUMA entirely.
19:25:25 <SamB_XP> indeed
19:25:38 <SamB_XP> but I suppose it probably doesn't allocate from the same pool in every thread?
19:25:53 <SamB_XP> that would kind of require compare-and-swap on every allocation...
19:25:55 * shapr dunno
19:26:05 <SamB_XP> or something of that nature
19:27:42 <glguy> is "gNewSense" a joke? or is the the name of something actually useful? I keep reading it as "g-nuisance"
19:28:03 <SamB_XP> anyway, you'd clearly want things that a given thread was the sole user of (so far) to be near that thread, yes?
20:14:07 <chessguy> ok people, let's be a little more lively in here!
20:14:23 <shapr> shhh!
20:15:17 <chessguy> don't make me start asking inane haskell questions :)
20:15:35 <chessguy> you all know how good i am at that
20:24:32 <chessguy> so i need to construct a table in haskell, and i'm trying to figure out the best construction for it
20:24:40 <chessguy> s/construction/data structure/
20:25:29 <chessguy> the number of rows and columns, and their labels aren't known at runtime
20:26:16 <chessguy> but it is square, or actually the upper diagonal half of a square is all i really need
20:28:08 <chessguy> wow, this channel really is dead tonight
20:28:24 <sieni> @localtime sieni
20:28:28 <lambdabot> Local time for sieni is Wed Nov  8 06:28:03 2006
20:30:35 <chessguy> @hoogle [a] -> [a]
20:30:36 <lambdabot> Prelude.cycle :: [a] -> [a]
20:30:37 <lambdabot> Prelude.init :: [a] -> [a]
20:30:37 <lambdabot> Prelude.reverse :: [a] -> [a]
20:30:47 <chessguy> cycle [1,2,3]
20:30:52 <chessguy> > cycle [1,2,3]
20:30:54 <lambdabot>  [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2...
20:31:06 <chessguy> > init [1,2,3]
20:31:08 <lambdabot>  [1,2]
20:31:40 <chessguy> @hoogle [a] -> [[a]]
20:31:41 <lambdabot> List.inits :: [a] -> [[a]]
20:31:42 <lambdabot> List.tails :: [a] -> [[a]]
20:31:42 <lambdabot> List.group :: Eq a => [a] -> [[a]]
20:31:54 <chessguy> > inits [1,2,3]
20:31:56 <lambdabot>  [[],[1],[1,2],[1,2,3]]
20:32:19 <chessguy> > tails [1,2,3]
20:32:21 <lambdabot>  [[1,2,3],[2,3],[3],[]]
20:32:30 <chessguy> hmm
20:47:07 <chessguy> > [[x,y] | x<-[1..5], y<-[1..5]\\x]
20:47:08 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
20:47:08 <lambdabot>    Expected...
20:47:53 <chessguy> > let foo = [1..5] \\ x in [[x,y] | x<-[1..5], y<-foo]
20:47:54 <lambdabot>  Not in scope: `x'
20:48:30 <chessguy> > [[x,y] | x<-[1..5], y<-([1..5]\\x)]
20:48:31 <lambdabot>    Occurs check: cannot construct the infinite type: a = [a]
20:48:31 <lambdabot>    Expected...
20:49:10 <chessguy> > [[x,y] | x<-[1..5], y<-[1..5]\\[x]]
20:49:12 <lambdabot>  [[1,2],[1,3],[1,4],[1,5],[2,1],[2,3],[2,4],[2,5],[3,1],[3,2],[3,4],[3,5],[4,...
20:49:48 <chessguy> > [[x,y] | x<-[1..5], y<-[1..5]\\[x], y>x]
20:49:50 <lambdabot>  [[1,2],[1,3],[1,4],[1,5],[2,3],[2,4],[2,5],[3,4],[3,5],[4,5]]
20:50:00 <dons> Haskell Weekly News out! http://programming.reddit.com/info/q0zu/details
20:50:04 <lambdabot> Title: Haskell Weekly News: SmallCheck, testing with iterative deepening and introducin ..., http://tinyurl.com/yldebk
20:50:16 <chessguy> > length [[x,y] | x<-[1..5], y<-[1..5]\\[x], y>x]
20:50:18 <lambdabot>  10
20:51:23 <chessguy> > let n = 5 in length [[x,y] | x<-[1..n], y<-[1..n]\\[x], y>x]
20:51:24 <lambdabot>  10
20:52:06 <chessguy> > let n = 6 in length [[x,y] | x<-[1..n], y<-[1..n]\\[x], y>x]
20:52:07 <lambdabot>  15
20:52:51 <kfish> hmm, news from dons via reddit via dons
20:54:04 <dmead> anyone else watching the election?
20:54:54 <kfish> dons: i think you missed the HLADSPA announce (in fons' earlier mail on sunday)
21:45:49 <dons> kfish: ah right.
22:31:07 <dons> ?users
22:31:08 <lambdabot> Maximum users seen in #haskell: 265, currently: 226 (85.3%), active: 20 (8.8%)
22:31:10 <dons> ?yow!
22:31:10 <lambdabot> If you can't say something nice, say something surrealistic.
22:33:05 <dons> mm. just had a very interesting talk from one of the Clean hackers, about a QuickCheck-like tool, or more like SmallCheck, that generates custom higher order functions, in a methodical (non-random)way, for testing heavily higher-order code
22:33:13 <dons> i *bet* we could port that to SmallCheck and QuickCheck
22:37:34 <gour> dons: what can be done that "@where paste" in #haskell.org will give "http://paste.lisp.org/new/haskell.hr ?
22:37:49 <gour> dons: s/haskell.org/haskell.hr
22:41:00 <dons> ?where+ paste-hr http://paste.lisp.org/new/haskell.hr
22:41:02 <lambdabot> Done.
22:41:04 <dons> ?where paste-hr
22:41:05 <lambdabot> http://paste.lisp.org/new/haskell.hr
22:41:08 <dons> :)
22:41:16 <gour> thanks
22:41:23 <dons> ?where+ paste.hr http://paste.lisp.org/new/haskell.hr
22:41:24 <lambdabot> Done.
22:41:28 <dons> just in case someone gets the syntax wrong
22:41:37 <dons> ?where paste.hr
22:41:38 <lambdabot> http://paste.lisp.org/new/haskell.hr
22:42:37 <gour> :-)
22:50:44 <dmead> ?karma dmead
22:50:45 <lambdabot> You have a karma of 2
22:50:51 <dmead> =p
22:51:34 <dons> write more code!
22:51:37 <dons> :)
22:51:59 <dons> we should have 'internatoinal port a library to haskell' week soon..
22:52:09 <dons> with fun karma prizes for the best port :)
22:54:45 <dmead> =o
22:54:47 <dmead> cool
22:55:05 <dmead> ok, looks like the democrats have both houses in the bag
22:55:09 <dmead> time to sleeep
22:56:02 <dons> how 'bout the senate?
22:56:18 <dolio> The senate is one of the houses.
22:56:22 <zptao> LOL
22:56:28 <dmead> =p
22:56:35 <zptao> america is so ruled
22:56:37 <dons> ah *both* houses.
22:56:42 <dmead> the senate is probably going to go democrat
22:56:51 <dmead> we won missouri and montana
22:56:59 <dmead> and viriginia will probably take weeks, but the democrat is winning
22:56:59 <dons> #haskell did? cool!
22:57:05 <dmead> =p
22:57:26 <dmead> so thats 51 seats in the senate and 230+ in the house
22:57:31 <dons> So who's going to run with me on a Wadler-For-President ticket?
22:57:35 <dmead> for the majority... and the power to impeach bush
22:57:40 <dmead> muahaha
22:57:51 <dmead> whats a Wadler?
22:58:05 <dons> Lambda Man
22:58:05 <dolio> It's a man with a bushy beard.
22:58:17 <dons> ?google wadler lambda man
22:58:21 <lambdabot> http://www.cs.uni.edu/~wallingf/blog/archives/monthly/2006-10.html
22:58:21 <lambdabot> Title: Knowing and Doing: October 2006 Archives
22:58:27 <dons> hmm maybe.
22:59:11 <dolio> He did some minor Haskell stuff.
22:59:18 <dolio> Like inventing type classes, I think.
22:59:35 <dolio> Among other things. :)
22:59:41 <dons> yeah, and had some part in the moads too I heard.
22:59:54 <dons> monads. oh yes, here:
23:00:09 <dons> http://haskell.org/haskellwiki/Research_papers/Top_10
23:00:12 <lambdabot> Title: Research papers/Top 10 - HaskellWiki, http://tinyurl.com/l2blg
23:00:23 <dmead> alright sleep for me =p
23:00:30 <Cale> Yeah, congratulations to the US :)
23:00:40 <Cale> I hope that all goes well with the senate
23:00:45 <dmead> =)
23:01:22 <dons> Cale can sleep well at night now, knowing Canada's about 10% less likely to be invaded this year
23:01:27 <Cale> hehe
23:02:39 <Cale> Yeah, it's rather scary, because at some point I figure they're going to run out of fresh water, of which Canada has ridiculous amounts.
23:02:51 <dolio> Canada's an important ally. We need their maple syrup and comedians.
23:03:03 <dons> i guess that's after alaska has been melted first?
23:03:16 <dons> who's guarding greenland? i hear there's an ice cap.
23:03:31 <dons> the danes can't hold it, i bet. #haskell could probably take over greenland..
23:03:55 <dolio> Yeah, but would we really want it?
23:04:26 <dons> well, a lot of good lambda hackers seem to live in very cold places. maybe its conducive to the understanding of monads?
23:04:45 <Cale> We could pass a law which bans hand-generation of C code.
23:04:46 <dons> anyway, it'll be green soon enough, given global warming..
23:04:46 <Adamant> that, or they don't have anything better to do
23:04:50 <dons> think of it as an investment property
23:04:57 <Cale> and the use of Java altogether
23:05:03 <dons> yeah what a utopia!
23:05:15 <Adamant> given that it's -45 degrees outside
23:08:06 <dons> btw, those not around earlier, http://programming.reddit.com/info/q0zu/details
23:08:09 <lambdabot> Title: Haskell Weekly News: SmallCheck, testing with iterative deepening and introducin ..., http://tinyurl.com/yldebk
23:08:23 <dons> oh, reminds me we should port SmallCheck 0.2 to lambdabot
23:08:30 <dons> should have enough instances now to keep us busy.
23:11:49 <caotic> hello, im kinda new to haskell, coming from a "scheme background", im having trouble making a function in haskell that may return a integer or a double, any suggestion how may manage that ?
23:12:15 <Cale> caotic: You can use the Either type
23:12:56 <dons> > let f x | x = Left 7 | otherwise = Right 7.0 in f True
23:12:58 <lambdabot>  Left 7
23:12:59 <dons> > let f x | x = Left 7 | otherwise = Right 7.0 in f False
23:13:01 <lambdabot>  Right 7.0
23:13:10 <dons> ?type let f x | x = Left 7 | otherwise = Right 7.0 in f False
23:13:12 <lambdabot> forall a b. (Num a, Fractional b) => Either a b
23:13:16 <dons> ?docs Data.Either
23:13:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Either.html
23:13:45 <flux__> ?docs Foo.Bar
23:13:46 <lambdabot> Foo.Bar not available
23:13:48 <flux__> just checking ;)
23:13:59 * dons wonders what flux__ was hoping for? 
23:14:01 <caotic> well i did try it but it gets me an error
23:14:04 <dons> oh, i know \x -> url ++ x
23:14:10 <dons> ?paste
23:14:11 <lambdabot> http://paste.lisp.org/new/haskell
23:14:15 <dons> you could paste the error?
23:14:27 <caotic> im tryng to make a function that recives tu functions as parameters and two integers
23:14:39 <caotic> and one of those funcitons has to be a division
23:15:16 <caotic> twoFunc = \x  y z w -> x(y z w)
23:15:25 <dons> yep ok.
23:15:33 <dons> ?type \x  y z w -> x(y z w)
23:15:35 <lambdabot> forall t t1 t2 t3. (t -> t3) -> (t1 -> t2 -> t) -> t1 -> t2 -> t3
23:15:47 <caotic> twofunc divideby2 somefunction 2 3
23:15:47 <dons> so one function of 2 args, one of 1 arg, and then composes them?
23:16:05 <flux__> dons, I wondered if it could've been a similar 'fake' operation as ?wiki is ;)
23:16:18 <dons> ?pl \f g x y -> f (g x y)
23:16:19 <flux__> but obviously it actually needs to do a search to do what it does
23:16:19 <lambdabot> (.) . (.)
23:16:34 <dons> ?let dot = (.) . (.)
23:16:35 <lambdabot> Defined.
23:16:47 <dons> > L.dot (/2) (id) 2 3
23:16:48 <lambdabot>  add an instance declaration for (Num (a1 -> b))
23:16:57 <dons> > L.dot (/2) (+) 2 3
23:16:58 <lambdabot>  2.5
23:17:07 <dons> caotic: ?
23:17:33 <caotic> im tring to understand it, give me a moment, i just realize lambdabot is evaluating
23:17:34 <dons> dot++ -- strikes again!
23:17:39 <dons> yep
23:17:53 <dons> > let dot f g x y = f (g x y) in dot (/2) (+) 2 3
23:17:55 <lambdabot>  2.5
23:17:57 <Cale> > (\f g x y -> f (g x y)) (/2) (+) 2 3
23:17:59 <lambdabot>  2.5
23:18:13 <Cale> now, if you have to pass this thing integers, it won't work
23:18:19 <Cale> @type (\f g x y -> f (g x y))
23:18:19 <dons> not sure which is easiest for a schemer?
23:18:20 <lambdabot> forall t t1 t2 t3. (t -> t3) -> (t1 -> t2 -> t) -> t1 -> t2 -> t3
23:18:30 <Cale> er
23:18:36 <Cale> @type (\f g x y -> f (g x y)) (/2) (+)
23:18:38 <lambdabot> forall a. (Fractional a) => a -> a -> a
23:18:54 <Cale> There's a Fractional constraint added by the use of division
23:19:10 <Cale> so you'll have to use something like fromIntegral to convert any integers first
23:19:25 <Cale> @type (\f g x y -> f (g (fromIntegral x) (fromIntegral y))) (/2) (+)
23:19:27 <lambdabot> forall a b a1. (Integral a, Integral a1, Fractional b) => a -> a1 -> b
23:19:39 <caotic> dons: i think i got it gonna try that thanks
23:20:55 <dons> and feel free to hang out here while you're learning
23:21:01 <dons> and after that too!
23:22:20 <caotic> ill do that
23:29:10 <caotic> dons : well the problem is tha it has to work more like the "h" function
23:29:11 <caotic> http://rafb.net/paste/results/51yrKh92.html
23:29:31 <caotic> using the dot wont let me use the functions by them self
23:29:37 <caotic> as funcitons
23:30:25 <Cale> um, that code you pasted works
23:30:37 <protoloco> hi
23:30:54 <Cale> protoloco: hello
23:31:02 <protoloco> how do i use lambdas ?
23:31:15 <Cale> > (\x -> x^2) 5
23:31:17 <lambdabot>  25
23:31:26 <Cale> The > is just part of the bot's syntax
23:31:34 <dons> the easiest lambdas this side of the lambda calculus
23:31:47 <Cale> the x after the \ is the formal parameter
23:31:56 <Cale> and the part after the -> is the result
23:32:13 <caotic> Cale: it doesnt when the result is a double
23:32:40 <Cale> caotic: hm?
23:33:18 <Cale> caotic: Open up ghci and look at the types of the things you have with :t
23:33:31 <caotic> yeah if let say polinomio returns a odd number the interpreter tell me something about double -> double not matchinf integer -> Double
23:33:34 <protoloco> thx
23:34:09 <Cale> caotic: The types are completely determined at compile time
23:34:25 <Cale> caotic: because you're using / in divby2, it won't work with Integers at all
23:34:41 <caotic> ghci ??
23:34:53 <caotic> oh ok
23:34:55 <Cale> yeah, the interactive environment
23:35:06 <Cale> Any integer you want to pass to divby2, you have to convert to a Double or something first
23:35:17 <Cale> the way you do this is to use  fromIntegral
23:35:20 <caotic> so its x/2 what is failing not the function (to put it in some words )
23:35:55 <Cale> Well, yeah. The constraint generated there is propagating to whatever functions call divby2 as well.
23:36:43 <caotic> i thounght it was a problem of the parameters recived and returned by the function
23:36:46 <Cale> so, suppose I define h by:
23:36:48 <caotic> not the evaluation itself
23:36:57 <Cale> h = twoFs divby2 polynomio
23:37:04 <caotic> so i would have had wonder for a while with that
23:37:13 <Cale> then you'll see something like  h :: Double -> Double -> Double
23:37:49 <Cale> Numerics are a little confusing in Haskell at first sight :)
23:38:45 <zptao> what value does functional programming have?
23:39:26 <caotic> thanks a lot Cale :)
23:39:30 <caotic> that helped me a lot
23:39:44 <Cale> zptao: perhaps try reading "Why Functional Programming Matters", by John Hughes. It's on the web.
23:40:02 <dons> it has immutable value (s)
23:40:10 * lispy assumes zptao is a troll
23:40:18 <lispy> zptao: please prove me wrong!
23:40:35 <Cale> zptao: But I could talk to you for hours about it, and it would be a waste of time -- that time would be better spent for you in just learning a functional programming language.
23:41:04 <caotic> protoloco: do i knwo you ?
23:41:39 <dons> there's a small chance zptao is actually xahlee
23:41:42 <zptao> ...no, dons
23:41:48 <dons> no?
23:42:00 <Cale> There are lots of benefits (fewer bugs, more expressiveness, more compositionality)
23:42:02 <zptao> that is what i said
23:42:07 <dons> zptao, ok. well. welcome. nice way to put the channel offside :)
23:42:52 <Cale> zptao: But really, having us preach at you about it for a long while will teach you a lot less about it than just going out and learning a bit of functional programming :)
23:43:18 <dons> ?google what value does functional programming have
23:43:22 <lambdabot> http://www.ibm.com/developerworks/library/l-prog.html
23:43:22 <lambdabot> Title: Charming Python: Functional programming in Python, Part 1
23:43:26 <dons> heh
23:43:27 <Cale> hehe
23:43:32 <lispy> er?
23:43:37 <lispy> they added FP to python?
23:43:45 <dons> remember, python: the language of PhDs ;)
23:43:46 <caotic> is there someone familiar with scheme ?
23:43:48 <Cale> lispy: "kind of"
23:43:55 <dons> Cale: should be a few in here yeah
23:44:00 <dons> s/cale/caotic/
23:44:00 <Cale> caotic: I think many of us are.
23:44:04 <lispy> caotic: kinda, i'm buing a scheme compiler
23:44:08 <lispy> building*
23:44:14 <caotic> wow
23:44:18 <lispy> and i used lisp for a long time
23:44:27 <arcatan> mmm, pie-thon
23:44:28 <zptao> python is the language of phds?
23:44:39 <dons> compared to php, i suppose it is
23:44:40 <Cale> zptao: note the ";)"
23:44:40 <zptao> good thing i learned it...
23:44:40 <caotic> well i was wondering how the operations cdr/car would translate into scheme
23:44:50 <zptao> Cale: which implies what
23:44:51 <caotic> while using lists
23:45:09 <Cale> zptao: that it's at least partly sarcastic
23:45:24 <Cale> I think scheme has car and cdr
23:45:57 <zptao> Cale: so what, you look down on python?
23:46:05 <Cale> zptao: not me
23:46:19 <dons> zptao: drop it. it's a joke about some silly thread on reddit earlier this week
23:46:23 <Cale> zptao: well, a little. :) It's fine if what you want is an imperative OO language.
23:46:30 <dons> i'm sorry for the confusion :)
23:46:53 <Cale> Its type system is a bit sad.
23:47:03 <zptao> Cale: how so?
23:47:21 <kzm> as in, it doesn't have one?
23:47:21 <zptao> i use python and find it to be really powerful/extendable
23:47:26 <caotic> err: i meant into haskell :P
23:47:27 <dons> yeah, its cool.
23:47:36 <Cale> It's really hard to catch bugs early with the type system in python
23:47:41 <zptao> it has a few primitive types
23:47:43 <Cale> caotic: head and tail
23:47:54 <caotic> thanks
23:48:03 <zptao> Cale: what do you mean?
23:48:26 <Cale> You end up getting type errors after it's too late to do anything about them, and the types don't really express a whole lot.
23:48:57 <lispy> caotic: maybe the biggest difference between scheme and haskell with lists is that in haskell all the elements must have the same type
23:49:05 <zptao> Cale: express?
23:49:09 <Cale> zptao: yeah
23:49:14 <Cale> Let me give you an example
23:49:16 <zptao> Cale: elaborate?
23:49:20 <lispy> caotic: second biggest difference is that lists in scheme are mor like trees compared to haskell lists
23:49:37 <Cale> map :: (a -> b) -> [a] -> [b] -- map takes a function from a's to b's and a list of a's and returns a list of b's.
23:49:51 <Cale> Now, suppose I try to write map, and I mess it up:
23:49:55 <Cale> map f [] = []
23:50:02 <Cale> map f (x:xs) = x : map f xs
23:50:04 <Adamant> Cale, it depends on what kind of program you are writing
23:50:21 <Cale> That says "mapping f over the empty list gives the empty list"
23:50:26 <zptao> Cale: i don't know haskell well, so most of that looks like gibberish
23:50:39 <zptao> and haskell has a very... odd syntax
23:50:41 <Cale> and "mapping f over the list which starts with x and the rest is called xs gives
23:50:53 <Cale> the list which starts with x and where the rest is map f xs"
23:51:11 <Cale> Now, this is actually wrong
23:51:18 * gour sees haskell's syntax as very cute & clean
23:51:19 <Cale> we didn't apply f to that first element
23:51:34 <Cale> The compiler will actually catch that bug.
23:51:37 <Adamant> dynamically-typed strong typing is still preferrable to no strong typing.
23:51:45 <Cale> Adamant: that's true
23:51:51 <zptao> but python doesn't use a compiler
23:52:01 <zptao> not so much anyway... it all goes through the interpreter eventually
23:52:03 <Cale> zptao: Even in an interpreter case
23:52:05 * Adamant has been coding PHP and getting all kinds of type errors. ugh
23:52:20 <Cale> I'll use compiler/interpreter interchangeably here
23:52:33 <Cale> That's not really what matters.
23:52:35 <Adamant> zptao, IIRC Python uses a bytecode compiler
23:52:38 <zptao> Cale: so your expectation here is that the interpreter should be responsible for coding errors?
23:52:47 <Cale> zptao: Certain kinds of them
23:52:54 <Cale> zptao: The more it catches, the better.
23:53:06 <gour> zptao: get all the help you can ;)
23:53:07 <zptao> Ok. I get it
23:53:37 <zptao> haskell's syntax seems pretty globbed together, at least to a novice
23:53:52 <Cale> It's actually rather clean and clear once you learn what it means.
23:53:55 <zptao> map :: (a -> b) -> [a] -> [b]
23:53:55 <zptao> map f (x:xs) = x : map f xs
23:53:57 <zptao> like that :x
23:54:09 <Cale> > 1 : [2,3,4,5]
23:54:11 <lambdabot>  [1,2,3,4,5]
23:54:18 <gour> it must be that i become unimperative a bit :-/
23:54:20 <desrt> hello, haskell
23:54:24 <Cale> : is the operator which sticks an element onto the start of a list
23:54:25 <mwc> zptao, novice == c programmer?
23:54:25 <zptao> : is append?
23:54:32 <Cale> a single element
23:54:35 <zptao> mwc: novice == python programmer
23:54:40 <zptao> oops, i meant prepend
23:54:41 <mwc> zptao, I'd call it prepend, but same diff
23:54:45 <Cale> ++ is list concatenation
23:54:51 <desrt> Cale; bad definition
23:54:59 <desrt> Cale; : is nothing more than a data constructor
23:55:01 <zptao> so what is map :: doing?
23:55:02 <Cale> desrt: I know that it's a lie :)
23:55:03 <desrt> :)
23:55:20 <Cale> map is applying the function f to each of the elements of the list it's given
23:55:24 <Cale> like map in python
23:55:25 <mwc> zptao, the first line is basically us asserting the type of map
23:55:28 <desrt> hmm
23:55:30 <desrt> i wonder
23:55:35 <desrt> ?type (: :)
23:55:37 <lambdabot> parse error on input `:'
23:55:39 <Cale> map :: (a -> b) -> [a] -> [b]
23:55:43 <zptao> i haven't used map in python
23:55:50 <desrt> oic.
23:55:54 <mwc> so if our implementation differs, the compiler will shriek.
23:55:57 <Cale> that tells us that map takes a function from values of type a to values of type b
23:56:00 <desrt> ?type ((:) :)
23:56:02 <lambdabot> forall a. [a -> [a] -> [a]] -> [a -> [a] -> [a]]
23:56:02 <Cale> and a list of values of type a
23:56:09 <Cale> and returns a list of values of type b
23:56:31 <Cale> The only nonstupid thing it could do is to apply the function to the elements of the list it's given.
23:56:48 <mwc> @djinn map ? (a -> b) -> [a] -> [b]
23:56:49 <Cale> (it could also throw some elements away or permute them)
23:56:50 <lambdabot> Cannot parse command
23:56:58 <Cale> (or duplicate some)
23:57:01 <mwc> @djinn help
23:57:02 <lambdabot> -- f cannot be realized.
23:57:08 <Cale> but it can't just come up with completely unrelated elements
23:57:11 <zptao> uh... so what map is doing is calling the function f with the other elements as parameters?
23:57:16 <desrt> gleeeuh
23:57:25 <desrt> midnight and exausted
23:57:28 <Cale> with the elements of the list it's given as parameters
23:57:29 <desrt> so busy anymore :(
23:57:32 <Cale> and collecting the results
23:57:32 <desrt> goodnight everyone.
23:57:39 <Cale> desrt: 'night!
23:57:44 <zptao> and sorting them into the order they were passed?
23:57:46 <Cale> > map (*2) [1,2,3,4,5]
23:57:48 <lambdabot>  [2,4,6,8,10]
23:57:53 <Cale> > map (+1) [1,2,3,4,5]
23:57:55 <lambdabot>  [2,3,4,5,6]
23:57:58 <Cale> see?
23:57:59 <zptao> hah.
23:58:05 <zptao> thats handy
23:58:07 <Cale> yeah
23:58:12 <zptao> > map :: [1,2,3,4,5]
23:58:13 <lambdabot>  Parse error
23:58:17 <zptao> o :(
23:58:21 <arcatan> Parsley error
23:58:24 <Cale> :: means "has type"
23:58:42 <zptao> is lambdabot like an interactive interpreter?
23:58:44 <mwc> > map (:[]) [1,2,3,4,5]
23:58:45 <Cale> yeah
23:58:46 <lambdabot>  [[1],[2],[3],[4],[5]]
23:59:13 <Cale> > map (6-) [1,2,3,4,5]
23:59:15 <lambdabot>  [5,4,3,2,1]
23:59:25 <Cale> hehe
23:59:28 <zptao> seems really powerful, but i feel like i'm missing something here
23:59:34 <zptao> imma read a tutorial tomorrow, night
23:59:38 <Cale> 'night
